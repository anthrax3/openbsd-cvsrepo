head	1.339;
access;
symbols
	OPENBSD_6_1:1.339.0.4
	OPENBSD_6_1_BASE:1.339
	OPENBSD_6_0:1.334.0.4
	OPENBSD_6_0_BASE:1.334
	OPENBSD_5_9:1.334.0.2
	OPENBSD_5_9_BASE:1.334
	OPENBSD_5_8:1.330.0.4
	OPENBSD_5_8_BASE:1.330
	OPENBSD_5_7:1.329.0.2
	OPENBSD_5_7_BASE:1.329
	OPENBSD_5_6:1.325.0.4
	OPENBSD_5_6_BASE:1.325
	OPENBSD_5_5:1.323.0.4
	OPENBSD_5_5_BASE:1.323
	OPENBSD_5_4:1.315.0.2
	OPENBSD_5_4_BASE:1.315
	OPENBSD_5_3:1.314.0.2
	OPENBSD_5_3_BASE:1.314
	OPENBSD_5_2:1.312.0.2
	OPENBSD_5_2_BASE:1.312
	OPENBSD_5_1_BASE:1.309
	OPENBSD_5_1:1.309.0.2
	OPENBSD_5_0:1.304.0.2
	OPENBSD_5_0_BASE:1.304
	OPENBSD_4_9:1.303.0.2
	OPENBSD_4_9_BASE:1.303
	OPENBSD_4_8:1.300.0.2
	OPENBSD_4_8_BASE:1.300
	OPENBSD_4_7:1.294.0.2
	OPENBSD_4_7_BASE:1.294
	OPENBSD_4_6:1.282.0.4
	OPENBSD_4_6_BASE:1.282
	OPENBSD_4_5:1.280.0.2
	OPENBSD_4_5_BASE:1.280
	OPENBSD_4_4:1.277.0.2
	OPENBSD_4_4_BASE:1.277
	OPENBSD_4_3:1.273.0.2
	OPENBSD_4_3_BASE:1.273
	OPENBSD_4_2:1.268.0.2
	OPENBSD_4_2_BASE:1.268
	OPENBSD_4_1:1.262.0.2
	OPENBSD_4_1_BASE:1.262
	OPENBSD_4_0:1.247.0.2
	OPENBSD_4_0_BASE:1.247
	OPENBSD_3_9:1.244.0.2
	OPENBSD_3_9_BASE:1.244
	OPENBSD_3_8:1.243.0.2
	OPENBSD_3_8_BASE:1.243
	OPENBSD_3_7:1.234.0.2
	OPENBSD_3_7_BASE:1.234
	OPENBSD_3_6:1.222.0.2
	OPENBSD_3_6_BASE:1.222
	OPENBSD_3_5:1.213.0.2
	OPENBSD_3_5_BASE:1.213
	OPENBSD_3_4:1.188.0.2
	OPENBSD_3_4_BASE:1.188
	OPENBSD_3_3:1.161.0.2
	OPENBSD_3_3_BASE:1.161
	OPENBSD_3_2:1.83.0.2
	OPENBSD_3_2_BASE:1.83
	OPENBSD_3_1:1.60.0.2
	OPENBSD_3_1_BASE:1.60
	OPENBSD_3_0:1.47.0.2
	OPENBSD_3_0_BASE:1.47;
locks; strict;
comment	@ * @;


1.339
date	2017.03.27.17.38.09;	author benno;	state Exp;
branches;
next	1.338;
commitid	o5cVlyYjFCPEtIjN;

1.338
date	2017.01.26.08.24.34;	author benno;	state Exp;
branches;
next	1.337;
commitid	LS683r4g6WQ5GcPt;

1.337
date	2016.09.03.21.30.49;	author jca;	state Exp;
branches;
next	1.336;
commitid	6f8c9bpPbhgk8CTf;

1.336
date	2016.09.03.17.56.07;	author sashan;	state Exp;
branches;
next	1.335;
commitid	bBmnBbiF6W9ohhBs;

1.335
date	2016.09.03.17.11.40;	author sashan;	state Exp;
branches;
next	1.334;
commitid	JAk2J5vzbGC5EyfM;

1.334
date	2016.01.14.12.05.51;	author henning;	state Exp;
branches;
next	1.333;
commitid	sDyX1wqb2ztqveVA;

1.333
date	2016.01.05.22.51.38;	author benno;	state Exp;
branches;
next	1.332;
commitid	RdgH2L9cn05DeHbW;

1.332
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.331;
commitid	82PdNqu2kKAuXPfA;

1.331
date	2015.10.02.15.32.17;	author krw;	state Exp;
branches;
next	1.330;
commitid	ihrzoKJ6ANcpzWWW;

1.330
date	2015.06.12.16.10.43;	author mikeb;	state Exp;
branches;
next	1.329;
commitid	sKt0eCwXQNoau0VS;

1.329
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.328;
commitid	Uu5nFG3wCl0LACBb;

1.328
date	2014.12.10.13.59.29;	author bluhm;	state Exp;
branches;
next	1.327;
commitid	gPVLn9LQsd8hvOLi;

1.327
date	2014.11.13.17.35.30;	author pelikan;	state Exp;
branches;
next	1.326;
commitid	fa4STfE4zutHmPJh;

1.326
date	2014.08.23.00.11.03;	author pelikan;	state Exp;
branches;
next	1.325;
commitid	YY1Dd1zH9rSATCPx;

1.325
date	2014.04.19.14.22.32;	author henning;	state Exp;
branches;
next	1.324;

1.324
date	2014.04.11.02.56.41;	author jsg;	state Exp;
branches;
next	1.323;

1.323
date	2014.02.28.22.18.23;	author mikeb;	state Exp;
branches;
next	1.322;

1.322
date	2014.02.17.04.52.25;	author lteo;	state Exp;
branches;
next	1.321;

1.321
date	2013.11.01.22.55.39;	author pelikan;	state Exp;
branches;
next	1.320;

1.320
date	2013.10.17.19.59.54;	author henning;	state Exp;
branches;
next	1.319;

1.319
date	2013.10.12.12.16.11;	author henning;	state Exp;
branches;
next	1.318;

1.318
date	2013.10.09.02.59.27;	author lteo;	state Exp;
branches;
next	1.317;

1.317
date	2013.08.12.17.42.08;	author mikeb;	state Exp;
branches;
next	1.316;

1.316
date	2013.08.02.08.33.11;	author mikeb;	state Exp;
branches;
next	1.315;

1.315
date	2013.03.21.00.54.33;	author deraadt;	state Exp;
branches;
next	1.314;

1.314
date	2012.09.19.15.52.17;	author camield;	state Exp;
branches;
next	1.313;

1.313
date	2012.07.26.11.48.00;	author mikeb;	state Exp;
branches;
next	1.312;

1.312
date	2012.05.07.11.55.34;	author henning;	state Exp;
branches;
next	1.311;

1.311
date	2012.05.02.14.23.49;	author henning;	state Exp;
branches;
next	1.310;

1.310
date	2012.04.18.14.42.17;	author deraadt;	state Exp;
branches;
next	1.309;

1.309
date	2012.01.15.15.59.33;	author dhill;	state Exp;
branches;
next	1.308;

1.308
date	2011.12.03.12.46.16;	author mcbride;	state Exp;
branches;
next	1.307;

1.307
date	2011.12.03.12.44.56;	author mcbride;	state Exp;
branches;
next	1.306;

1.306
date	2011.11.23.10.24.37;	author henning;	state Exp;
branches;
next	1.305;

1.305
date	2011.11.08.19.17.07;	author mikeb;	state Exp;
branches;
next	1.304;

1.304
date	2011.07.08.02.16.12;	author mcbride;	state Exp;
branches;
next	1.303;

1.303
date	2010.10.01.12.33.14;	author reyk;	state Exp;
branches;
next	1.302;

1.302
date	2010.09.02.14.01.04;	author sobrado;	state Exp;
branches;
next	1.301;

1.301
date	2010.08.11.10.03.29;	author jsg;	state Exp;
branches;
next	1.300;

1.300
date	2010.07.03.02.28.57;	author mcbride;	state Exp;
branches;
next	1.299;

1.299
date	2010.07.01.15.12.25;	author stsp;	state Exp;
branches;
next	1.298;

1.298
date	2010.06.28.23.21.41;	author mcbride;	state Exp;
branches;
next	1.297;

1.297
date	2010.06.25.23.27.47;	author henning;	state Exp;
branches;
next	1.296;

1.296
date	2010.04.02.09.48.48;	author sthen;	state Exp;
branches;
next	1.295;

1.295
date	2010.03.23.13.31.29;	author henning;	state Exp;
branches;
next	1.294;

1.294
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.293;

1.293
date	2010.01.13.01.41.58;	author jsg;	state Exp;
branches;
next	1.292;

1.292
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.291;

1.291
date	2009.12.10.15.57.20;	author deraadt;	state Exp;
branches;
next	1.290;

1.290
date	2009.11.22.22.34.50;	author henning;	state Exp;
branches;
next	1.289;

1.289
date	2009.10.28.20.11.01;	author jsg;	state Exp;
branches;
next	1.288;

1.288
date	2009.09.29.12.54.14;	author jmc;	state Exp;
branches;
next	1.287;

1.287
date	2009.09.28.22.13.20;	author dlg;	state Exp;
branches;
next	1.286;

1.286
date	2009.09.03.15.14.33;	author jmc;	state Exp;
branches;
next	1.285;

1.285
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.284;

1.284
date	2009.08.21.05.27.57;	author ratchov;	state Exp;
branches;
next	1.283;

1.283
date	2009.07.09.23.52.25;	author henning;	state Exp;
branches;
next	1.282;

1.282
date	2009.04.16.04.40.19;	author david;	state Exp;
branches;
next	1.281;

1.281
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.280;

1.280
date	2009.02.23.06.58.30;	author deraadt;	state Exp;
branches;
next	1.279;

1.279
date	2009.02.16.23.53.59;	author sthen;	state Exp;
branches;
next	1.278;

1.278
date	2008.08.31.20.18.17;	author jmc;	state Exp;
branches;
next	1.277;

1.277
date	2008.07.24.10.52.43;	author henning;	state Exp;
branches;
next	1.276;

1.276
date	2008.05.27.08.14.57;	author mcbride;	state Exp;
branches;
next	1.275;

1.275
date	2008.05.09.13.59.31;	author mpf;	state Exp;
branches;
next	1.274;

1.274
date	2008.05.06.03.45.21;	author mpf;	state Exp;
branches;
next	1.273;

1.273
date	2008.02.13.19.55.12;	author kettenis;	state Exp;
branches;
next	1.272;

1.272
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.271;

1.271
date	2007.10.24.13.07.38;	author wilfried;	state Exp;
branches;
next	1.270;

1.270
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.269;

1.269
date	2007.10.13.16.35.18;	author deraadt;	state Exp;
branches;
next	1.268;

1.268
date	2007.06.30.18.25.08;	author henning;	state Exp;
branches;
next	1.267;

1.267
date	2007.05.31.04.13.37;	author mcbride;	state Exp;
branches;
next	1.266;

1.266
date	2007.04.21.14.50.26;	author henning;	state Exp;
branches;
next	1.265;

1.265
date	2007.04.21.14.49.45;	author henning;	state Exp;
branches;
next	1.264;

1.264
date	2007.04.20.07.30.16;	author jmc;	state Exp;
branches;
next	1.263;

1.263
date	2007.03.21.03.01.31;	author mcbride;	state Exp;
branches;
next	1.262;

1.262
date	2007.03.01.17.20.53;	author deraadt;	state Exp;
branches;
next	1.261;

1.261
date	2007.02.23.21.31.52;	author deraadt;	state Exp;
branches;
next	1.260;

1.260
date	2007.02.09.11.28.32;	author henning;	state Exp;
branches;
next	1.259;

1.259
date	2007.02.09.11.25.27;	author henning;	state Exp;
branches;
next	1.258;

1.258
date	2007.01.18.20.45.55;	author henning;	state Exp;
branches;
next	1.257;

1.257
date	2006.11.20.14.31.17;	author mcbride;	state Exp;
branches;
next	1.256;

1.256
date	2006.11.07.06.16.56;	author mcbride;	state Exp;
branches;
next	1.255;

1.255
date	2006.11.07.01.12.01;	author mcbride;	state Exp;
branches;
next	1.254;

1.254
date	2006.11.05.07.19.30;	author mcbride;	state Exp;
branches;
next	1.253;

1.253
date	2006.11.01.12.27.26;	author jmc;	state Exp;
branches;
next	1.252;

1.252
date	2006.11.01.03.39.24;	author mcbride;	state Exp;
branches;
next	1.251;

1.251
date	2006.10.31.23.46.24;	author mcbride;	state Exp;
branches;
next	1.250;

1.250
date	2006.10.31.14.17.45;	author mcbride;	state Exp;
branches;
next	1.249;

1.249
date	2006.10.31.07.02.35;	author mcbride;	state Exp;
branches;
next	1.248;

1.248
date	2006.10.28.14.29.05;	author mcbride;	state Exp;
branches;
next	1.247;

1.247
date	2006.06.30.16.52.27;	author deraadt;	state Exp;
branches;
next	1.246;

1.246
date	2006.05.28.02.45.45;	author mcbride;	state Exp;
branches;
next	1.245;

1.245
date	2006.04.24.06.10.54;	author dhartmei;	state Exp;
branches;
next	1.244;

1.244
date	2005.11.17.20.52.39;	author dhartmei;	state Exp;
branches;
next	1.243;

1.243
date	2005.07.11.14.16.09;	author dhartmei;	state Exp;
branches;
next	1.242;

1.242
date	2005.06.13.20.17.25;	author henning;	state Exp;
branches;
next	1.241;

1.241
date	2005.06.13.19.26.06;	author jaredy;	state Exp;
branches;
next	1.240;

1.240
date	2005.05.28.01.48.23;	author dhartmei;	state Exp;
branches;
next	1.239;

1.239
date	2005.05.27.17.22.40;	author dhartmei;	state Exp;
branches;
next	1.238;

1.238
date	2005.05.23.23.28.53;	author dhartmei;	state Exp;
branches;
next	1.237;

1.237
date	2005.05.22.21.05.23;	author mpf;	state Exp;
branches;
next	1.236;

1.236
date	2005.05.21.21.03.58;	author henning;	state Exp;
branches;
next	1.235;

1.235
date	2005.05.05.04.00.26;	author joel;	state Exp;
branches;
next	1.234;

1.234
date	2005.03.07.13.52.50;	author henning;	state Exp;
branches;
next	1.233;

1.233
date	2005.03.06.02.40.08;	author dhartmei;	state Exp;
branches;
next	1.232;

1.232
date	2005.01.06.08.30.22;	author mcbride;	state Exp;
branches;
next	1.231;

1.231
date	2005.01.05.18.23.10;	author mcbride;	state Exp;
branches;
next	1.230;

1.230
date	2004.12.29.15.09.30;	author danh;	state Exp;
branches;
next	1.229;

1.229
date	2004.12.29.14.21.01;	author danh;	state Exp;
branches;
next	1.228;

1.228
date	2004.12.29.10.54.01;	author henning;	state Exp;
branches;
next	1.227;

1.227
date	2004.12.28.18.12.14;	author henning;	state Exp;
branches;
next	1.226;

1.226
date	2004.12.27.15.47.07;	author deraadt;	state Exp;
branches;
next	1.225;

1.225
date	2004.12.27.13.35.57;	author henning;	state Exp;
branches;
next	1.224;

1.224
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.223;

1.223
date	2004.09.21.16.59.11;	author aaron;	state Exp;
branches;
next	1.222;

1.222
date	2004.08.26.16.35.36;	author jaredy;	state Exp;
branches;
next	1.221;

1.221
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.220;

1.220
date	2004.07.23.10.20.42;	author jmc;	state Exp;
branches;
next	1.219;

1.219
date	2004.07.19.22.04.00;	author dlg;	state Exp;
branches;
next	1.218;

1.218
date	2004.07.16.23.44.24;	author frantzen;	state Exp;
branches;
next	1.217;

1.217
date	2004.05.21.23.10.48;	author dhartmei;	state Exp;
branches;
next	1.216;

1.216
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.215;

1.215
date	2004.05.05.23.16.03;	author frantzen;	state Exp;
branches;
next	1.214;

1.214
date	2004.04.09.12.42.06;	author cedric;	state Exp;
branches;
next	1.213;

1.213
date	2004.03.20.09.31.42;	author david;	state Exp;
branches;
next	1.212;

1.212
date	2004.03.15.15.25.44;	author dhartmei;	state Exp;
branches;
next	1.211;

1.211
date	2004.03.03.02.00.23;	author deraadt;	state Exp;
branches;
next	1.210;

1.210
date	2004.02.27.10.42.00;	author henning;	state Exp;
branches;
next	1.209;

1.209
date	2004.02.26.15.43.51;	author cedric;	state Exp;
branches;
next	1.208;

1.208
date	2004.02.25.10.09.40;	author cedric;	state Exp;
branches;
next	1.207;

1.207
date	2004.02.19.21.37.01;	author cedric;	state Exp;
branches;
next	1.206;

1.206
date	2004.02.19.21.29.51;	author cedric;	state Exp;
branches;
next	1.205;

1.205
date	2004.02.17.08.48.29;	author cedric;	state Exp;
branches;
next	1.204;

1.204
date	2004.02.12.11.03.45;	author jmc;	state Exp;
branches;
next	1.203;

1.203
date	2004.02.12.02.05.32;	author beck;	state Exp;
branches;
next	1.202;

1.202
date	2004.02.10.22.26.55;	author dhartmei;	state Exp;
branches;
next	1.201;

1.201
date	2004.02.10.17.53.37;	author henning;	state Exp;
branches;
next	1.200;

1.200
date	2004.02.04.10.43.18;	author mcbride;	state Exp;
branches;
next	1.199;

1.199
date	2004.01.29.01.25.13;	author mcbride;	state Exp;
branches;
next	1.198;

1.198
date	2003.12.31.22.14.41;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.196;

1.196
date	2003.12.19.16.12.43;	author henning;	state Exp;
branches;
next	1.195;

1.195
date	2003.12.16.00.32.59;	author mcbride;	state Exp;
branches;
next	1.194;

1.194
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.193;

1.193
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.192;

1.192
date	2003.11.14.13.51.09;	author henning;	state Exp;
branches;
next	1.191;

1.191
date	2003.11.06.15.01.30;	author henning;	state Exp;
branches;
next	1.190;

1.190
date	2003.10.02.17.01.16;	author mcbride;	state Exp;
branches;
next	1.189;

1.189
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.188;

1.188
date	2003.08.29.21.47.36;	author cedric;	state Exp;
branches;
next	1.187;

1.187
date	2003.08.22.17.24.27;	author dhartmei;	state Exp;
branches;
next	1.186;

1.186
date	2003.08.21.19.12.08;	author frantzen;	state Exp;
branches;
next	1.185;

1.185
date	2003.08.04.17.29.44;	author dhartmei;	state Exp;
branches;
next	1.184;

1.184
date	2003.08.04.12.17.01;	author henning;	state Exp;
branches;
next	1.183;

1.183
date	2003.07.31.22.25.54;	author cedric;	state Exp;
branches;
next	1.182;

1.182
date	2003.07.18.06.30.07;	author cedric;	state Exp;
branches;
next	1.181;

1.181
date	2003.07.11.08.29.34;	author cedric;	state Exp;
branches;
next	1.180;

1.180
date	2003.07.03.21.09.13;	author cedric;	state Exp;
branches;
next	1.179;

1.179
date	2003.07.03.09.13.06;	author cedric;	state Exp;
branches;
next	1.178;

1.178
date	2003.06.29.12.22.39;	author dhartmei;	state Exp;
branches;
next	1.177;

1.177
date	2003.06.13.12.10.42;	author cedric;	state Exp;
branches;
next	1.176;

1.176
date	2003.06.03.12.18.57;	author henning;	state Exp;
branches;
next	1.175;

1.175
date	2003.05.19.02.32.47;	author henning;	state Exp;
branches;
next	1.174;

1.174
date	2003.05.19.00.54.19;	author henning;	state Exp;
branches;
next	1.173;

1.173
date	2003.05.18.20.25.15;	author henning;	state Exp;
branches;
next	1.172;

1.172
date	2003.05.17.02.46.22;	author mcbride;	state Exp;
branches;
next	1.171;

1.171
date	2003.05.12.01.25.31;	author dhartmei;	state Exp;
branches;
next	1.170;

1.170
date	2003.05.10.00.45.24;	author henning;	state Exp;
branches;
next	1.169;

1.169
date	2003.04.30.13.22.26;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.167;

1.167
date	2003.04.03.15.52.24;	author cedric;	state Exp;
branches;
next	1.166;

1.166
date	2003.04.02.22.31.06;	author henning;	state Exp;
branches;
next	1.165;

1.165
date	2003.04.02.14.09.20;	author henning;	state Exp;
branches;
next	1.164;

1.164
date	2003.04.02.14.07.38;	author henning;	state Exp;
branches;
next	1.163;

1.163
date	2003.03.27.20.21.34;	author dhartmei;	state Exp;
branches;
next	1.162;

1.162
date	2003.03.27.18.01.57;	author henning;	state Exp;
branches;
next	1.161;

1.161
date	2003.03.11.13.20.17;	author dhartmei;	state Exp;
branches;
next	1.160;

1.160
date	2003.03.11.11.53.28;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2003.03.10.13.28.00;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2003.03.08.14.26.31;	author henning;	state Exp;
branches;
next	1.157;

1.157
date	2003.03.07.12.55.37;	author henning;	state Exp;
branches;
next	1.156;

1.156
date	2003.02.20.22.09.27;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2003.02.20.11.08.06;	author cedric;	state Exp;
branches;
next	1.154;

1.154
date	2003.02.19.21.50.16;	author henning;	state Exp;
branches;
next	1.153;

1.153
date	2003.02.18.21.59.34;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2003.02.17.15.33.07;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2003.02.17.15.11.29;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2003.02.17.06.58.27;	author mpech;	state Exp;
branches;
next	1.149;

1.149
date	2003.02.14.17.17.27;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2003.02.11.20.11.36;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2003.02.05.11.18.45;	author cedric;	state Exp;
branches;
next	1.146;

1.146
date	2003.02.05.10.13.44;	author cedric;	state Exp;
branches;
next	1.145;

1.145
date	2003.02.03.14.51.36;	author cedric;	state Exp;
branches;
next	1.144;

1.144
date	2003.02.03.13.57.47;	author henning;	state Exp;
branches;
next	1.143;

1.143
date	2003.02.03.13.40.45;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2003.02.02.23.22.07;	author henning;	state Exp;
branches;
next	1.141;

1.141
date	2003.01.27.15.42.29;	author dhartmei;	state Exp;
branches;
next	1.140;

1.140
date	2003.01.24.11.11.17;	author henning;	state Exp;
branches;
next	1.139;

1.139
date	2003.01.21.19.12.08;	author camield;	state Exp;
branches;
next	1.138;

1.138
date	2003.01.20.18.37.52;	author camield;	state Exp;
branches;
next	1.137;

1.137
date	2003.01.19.15.28.12;	author camield;	state Exp;
branches;
next	1.136;

1.136
date	2003.01.19.13.48.06;	author dhartmei;	state Exp;
branches;
next	1.135;

1.135
date	2003.01.18.22.23.00;	author dhartmei;	state Exp;
branches;
next	1.134;

1.134
date	2003.01.18.15.00.24;	author cedric;	state Exp;
branches;
next	1.133;

1.133
date	2003.01.15.20.53.36;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2003.01.15.12.13.02;	author cedric;	state Exp;
branches;
next	1.131;

1.131
date	2003.01.11.21.10.56;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2003.01.10.14.21.21;	author cedric;	state Exp;
branches;
next	1.129;

1.129
date	2003.01.09.18.55.32;	author dhartmei;	state Exp;
branches;
next	1.128;

1.128
date	2003.01.09.18.34.29;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2003.01.09.17.33.19;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.125;

1.125
date	2003.01.07.01.04.33;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2003.01.05.22.34.20;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.122;

1.122
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2003.01.03.22.57.26;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2003.01.03.22.48.17;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2003.01.03.22.47.51;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2003.01.03.21.37.44;	author cedric;	state Exp;
branches;
next	1.117;

1.117
date	2003.01.01.17.20.14;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2003.01.01.04.26.19;	author dhartmei;	state Exp;
branches;
next	1.115;

1.115
date	2003.01.01.00.58.10;	author dhartmei;	state Exp;
branches;
next	1.114;

1.114
date	2002.12.31.19.27.08;	author mcbride;	state Exp;
branches;
next	1.113;

1.113
date	2002.12.31.01.39.46;	author dhartmei;	state Exp;
branches;
next	1.112;

1.112
date	2002.12.29.22.02.46;	author dhartmei;	state Exp;
branches;
next	1.111;

1.111
date	2002.12.25.16.05.23;	author dhartmei;	state Exp;
branches;
next	1.110;

1.110
date	2002.12.22.15.52.13;	author dhartmei;	state Exp;
branches;
next	1.109;

1.109
date	2002.12.18.19.40.41;	author dhartmei;	state Exp;
branches;
next	1.108;

1.108
date	2002.12.18.16.28.40;	author dhartmei;	state Exp;
branches;
next	1.107;

1.107
date	2002.12.18.16.00.03;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2002.12.18.14.14.09;	author mcbride;	state Exp;
branches;
next	1.105;

1.105
date	2002.12.17.20.06.05;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2002.12.17.12.36.59;	author mcbride;	state Exp;
branches;
next	1.103;

1.103
date	2002.12.16.22.59.37;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2002.12.10.11.03.52;	author henning;	state Exp;
branches;
next	1.101;

1.101
date	2002.12.09.18.26.09;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2002.12.07.20.45.04;	author mcbride;	state Exp;
branches;
next	1.99;

1.99
date	2002.12.06.00.47.31;	author dhartmei;	state Exp;
branches;
next	1.98;

1.98
date	2002.12.05.14.10.45;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2002.12.05.12.26.55;	author mcbride;	state Exp;
branches;
next	1.96;

1.96
date	2002.12.04.08.07.28;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2002.12.01.22.10.40;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2002.12.01.19.56.42;	author mcbride;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.24.16.47.02;	author dhartmei;	state Exp;
branches;
next	1.92;

1.92
date	2002.11.24.13.34.15;	author dhartmei;	state Exp;
branches;
next	1.91;

1.91
date	2002.11.24.13.26.29;	author dhartmei;	state Exp;
branches;
next	1.90;

1.90
date	2002.11.23.09.33.54;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2002.11.23.07.52.54;	author mcbride;	state Exp;
branches;
next	1.88;

1.88
date	2002.11.23.05.22.24;	author mcbride;	state Exp;
branches;
next	1.87;

1.87
date	2002.11.22.12.24.30;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2002.11.18.22.49.15;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2002.10.07.14.34.40;	author dhartmei;	state Exp;
branches;
next	1.84;

1.84
date	2002.10.07.14.13.48;	author dhartmei;	state Exp;
branches;
next	1.83;

1.83
date	2002.07.05.14.07.32;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2002.07.01.05.28.22;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.25.08.13.26;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.14.17.31.30;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.12.22.27.05;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.11.17.43.46;	author kjell;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.11.08.22.15;	author kjell;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.11.06.12.15;	author kjell;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.11.02.26.10;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.10.23.07.46;	author kjell;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.10.15.19.13;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.09.02.14.29;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.08.16.44.15;	author drahn;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.08.07.58.07;	author dhartmei;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.07.21.25.35;	author dhartmei;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.06.22.22.44;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.03.16.13.17;	author kjell;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.23.09.47.20;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.19.22.26.27;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.19.22.15.19;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.19.21.09.56;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.19.21.08.34;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.24.18.10.25;	author dhartmei;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.01.20.01.16;	author dhartmei;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.01.15.06.21;	author dhartmei;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.28.23.13.18;	author dhartmei;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.26.17.37.11;	author frantzen;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.25.22.05.49;	author frantzen;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.11.22.22.57;	author dhartmei;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.28.15.51.17;	author dhartmei;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.27.18.11.45;	author dhartmei;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.26.07.25.33;	author dhartmei;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.09.11.30.53;	author dhartmei;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.06.21.56.12;	author dhartmei;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.31.16.48.36;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.10.18.08.12;	author dhartmei;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.04.21.54.15;	author dhartmei;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.02.18.18.28;	author frantzen;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.02.18.00.38;	author frantzen;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.02.17.55.24;	author dhartmei;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.01.17.58.16;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.01.14.38.34;	author dhartmei;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.30.05.29.37;	author frantzen;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.22.18.30.11;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.06.18.05.46;	author jasoni;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.28.00.02.43;	author frantzen;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.23.04.10.31;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.19.19.57.33;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.19.19.03.58;	author dhartmei;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.19.18.20.46;	author dhartmei;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.18.21.09.13;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.11.12.05.00;	author dhartmei;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.11.09.54.59;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.26.12.55.15;	author dhartmei;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.17.17.39.09;	author marc;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.16.21.09.37;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.05.11.40.25;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.03.12.10.45;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.01.16.58.51;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.29.21.11.24;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.28.20.30.53;	author dhartmei;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.21.54.47;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.21.27.47;	author dhartmei;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.19.06.32;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.27.10.31.49;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.26.23.24.06;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.26.22.24.14;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.26.22.19.47;	author smart;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.26.22.18.17;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.26.20.50.26;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.17.46.02;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.00.18.30;	author jasoni;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.22.14.07;	author smart;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.17.59.19;	author smart;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.17.17.06;	author dhartmei;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.10.14.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.09.44.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.00.02.55;	author dhartmei;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.24.23.44.07;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.23.20.57;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.23.16.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.21.40.51;	author dhartmei;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.24.21.04.15;	author kjell;	state Exp;
branches;
next	;


desc
@@


1.339
log
@rather than printing the wrong function name, dont print it at all.
found by Klemens Nanni
@
text
@/*	$OpenBSD: pfctl.c,v 1.338 2017/01/26 08:24:34 benno Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2013 Henning Brauer <henning@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>
#include <arpa/inet.h>
#include <net/hfsc.h>
#include <sys/sysctl.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <syslog.h>

#include "pfctl_parser.h"
#include "pfctl.h"

void	 usage(void);
int	 pfctl_enable(int, int);
int	 pfctl_disable(int, int);
void	 pfctl_clear_queues(struct pf_qihead *);
int	 pfctl_clear_stats(int, const char *, int);
int	 pfctl_clear_interface_flags(int, int);
int	 pfctl_clear_rules(int, int, char *);
int	 pfctl_clear_src_nodes(int, int);
int	 pfctl_clear_states(int, const char *, int);
void	 pfctl_addrprefix(char *, struct pf_addr *);
int	 pfctl_kill_src_nodes(int, const char *, int);
int	 pfctl_net_kill_states(int, const char *, int, int);
int	 pfctl_label_kill_states(int, const char *, int, int);
int	 pfctl_id_kill_states(int, int);
void	 pfctl_init_options(struct pfctl *);
int	 pfctl_load_options(struct pfctl *);
int	 pfctl_load_limit(struct pfctl *, unsigned int, unsigned int);
int	 pfctl_load_timeout(struct pfctl *, unsigned int, unsigned int);
int	 pfctl_load_debug(struct pfctl *, unsigned int);
int	 pfctl_load_logif(struct pfctl *, char *);
int	 pfctl_load_hostid(struct pfctl *, unsigned int);
int	 pfctl_load_reassembly(struct pfctl *, u_int32_t);
void	 pfctl_print_rule_counters(struct pf_rule *, int);
int	 pfctl_show_rules(int, char *, int, enum pfctl_show, char *, int, int,
	    long);
int	 pfctl_show_src_nodes(int, int);
int	 pfctl_show_states(int, const char *, int, long);
int	 pfctl_show_status(int, int);
int	 pfctl_show_timeouts(int, int);
int	 pfctl_show_limits(int, int);
void	 pfctl_debug(int, u_int32_t, int);
int	 pfctl_show_anchors(int, int, char *);
int	 pfctl_ruleset_trans(struct pfctl *, char *, struct pf_anchor *);
u_int	 pfctl_find_childqs(struct pfctl_qsitem *);
void	 pfctl_load_queue(struct pfctl *, u_int32_t, struct pfctl_qsitem *);
int	 pfctl_load_queues(struct pfctl *);
u_int	 pfctl_leafqueue_check(char *);
u_int	 pfctl_check_qassignments(struct pf_ruleset *);
int	 pfctl_load_ruleset(struct pfctl *, char *, struct pf_ruleset *, int);
int	 pfctl_load_rule(struct pfctl *, char *, struct pf_rule *, int);
const char	*pfctl_lookup_option(char *, const char **);
void	pfctl_state_store(int, const char *);
void	pfctl_state_load(int, const char *);

struct pf_anchor_global	 pf_anchors;
struct pf_anchor	 pf_main_anchor;

const char	*clearopt;
char		*rulesopt;
const char	*showopt;
const char	*debugopt;
char		*anchoropt;
const char	*optiopt = NULL;
char		*pf_device = "/dev/pf";
char		*ifaceopt;
char		*tableopt;
const char	*tblcmdopt;
int		 src_node_killers;
char		*src_node_kill[2];
int		 state_killers;
char		*state_kill[2];

int		 dev = -1;
int		 first_title = 1;
int		 labels = 0;

#define INDENT(d, o)	do {						\
				if (o) {				\
					int i;				\
					for (i=0; i < d; i++)		\
						printf("  ");		\
				}					\
			} while (0)					\


static const struct {
	const char	*name;
	int		index;
} pf_limits[] = {
	{ "states",		PF_LIMIT_STATES },
	{ "src-nodes",		PF_LIMIT_SRC_NODES },
	{ "frags",		PF_LIMIT_FRAGS },
	{ "tables",		PF_LIMIT_TABLES },
	{ "table-entries",	PF_LIMIT_TABLE_ENTRIES },
	{ NULL,			0 }
};

struct pf_hint {
	const char	*name;
	int		timeout;
};
static const struct pf_hint pf_hint_normal[] = {
	{ "tcp.first",		2 * 60 },
	{ "tcp.opening",	30 },
	{ "tcp.established",	24 * 60 * 60 },
	{ "tcp.closing",	15 * 60 },
	{ "tcp.finwait",	45 },
	{ "tcp.closed",		90 },
	{ "tcp.tsdiff",		30 },
	{ NULL,			0 }
};
static const struct pf_hint pf_hint_satellite[] = {
	{ "tcp.first",		3 * 60 },
	{ "tcp.opening",	30 + 5 },
	{ "tcp.established",	24 * 60 * 60 },
	{ "tcp.closing",	15 * 60 + 5 },
	{ "tcp.finwait",	45 + 5 },
	{ "tcp.closed",		90 + 5 },
	{ "tcp.tsdiff",		60 },
	{ NULL,			0 }
};
static const struct pf_hint pf_hint_conservative[] = {
	{ "tcp.first",		60 * 60 },
	{ "tcp.opening",	15 * 60 },
	{ "tcp.established",	5 * 24 * 60 * 60 },
	{ "tcp.closing",	60 * 60 },
	{ "tcp.finwait",	10 * 60 },
	{ "tcp.closed",		3 * 60 },
	{ "tcp.tsdiff",		60 },
	{ NULL,			0 }
};
static const struct pf_hint pf_hint_aggressive[] = {
	{ "tcp.first",		30 },
	{ "tcp.opening",	5 },
	{ "tcp.established",	5 * 60 * 60 },
	{ "tcp.closing",	60 },
	{ "tcp.finwait",	30 },
	{ "tcp.closed",		30 },
	{ "tcp.tsdiff",		10 },
	{ NULL,			0 }
};

static const struct {
	const char *name;
	const struct pf_hint *hint;
} pf_hints[] = {
	{ "normal",		pf_hint_normal },
	{ "satellite",		pf_hint_satellite },
	{ "high-latency",	pf_hint_satellite },
	{ "conservative",	pf_hint_conservative },
	{ "aggressive",		pf_hint_aggressive },
	{ NULL,			NULL }
};

static const char *clearopt_list[] = {
	"rules", "Sources", "states", "info", "Tables", "osfp", "all", NULL
};

static const char *showopt_list[] = {
	"queue", "rules", "Anchors", "Sources", "states", "info",
	"Interfaces", "labels", "timeouts", "memory", "Tables", "osfp",
	"all", NULL
};

static const char *tblcmdopt_list[] = {
	"kill", "flush", "add", "delete", "replace", "show",
	"test", "zero", "expire", NULL
};

static const char *debugopt_list[] = {
	"debug", "info", "notice", "warning",
	"error", "crit", "alert", "emerg",
	NULL
};

static const char *optiopt_list[] = {
	"none", "basic", "profile", NULL
};

struct pf_qihead qspecs = TAILQ_HEAD_INITIALIZER(qspecs);
struct pf_qihead rootqs = TAILQ_HEAD_INITIALIZER(rootqs);


__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-deghnPqrvz] ", __progname);
	fprintf(stderr, "[-a anchor] [-D macro=value] [-F modifier]\n");
	fprintf(stderr, "\t[-f file] [-i interface] [-K host | network]\n");
	fprintf(stderr, "\t[-k host | network | label | id] ");
	fprintf(stderr, "[-L statefile] [-o level] [-p device]\n");
	fprintf(stderr, "\t[-S statefile] [-s modifier [-R id]] ");
	fprintf(stderr, "[-t table -T command [address ...]]\n");
	fprintf(stderr, "\t[-V rdomain] [-x level]\n");
	exit(1);
}

int
pfctl_enable(int dev, int opts)
{
	if (ioctl(dev, DIOCSTART)) {
		if (errno == EEXIST)
			errx(1, "pf already enabled");
		else
			err(1, "DIOCSTART");
	}
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf enabled\n");

	return (0);
}

int
pfctl_disable(int dev, int opts)
{
	if (ioctl(dev, DIOCSTOP)) {
		if (errno == ENOENT)
			errx(1, "pf not enabled");
		else
			err(1, "DIOCSTOP");
	}
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf disabled\n");

	return (0);
}

int
pfctl_clear_stats(int dev, const char *iface, int opts)
{
	struct pfioc_iface pi;

	memset(&pi, 0, sizeof(pi));
	if (iface != NULL && strlcpy(pi.pfiio_name, iface,
	    sizeof(pi.pfiio_name)) >= sizeof(pi.pfiio_name))
		errx(1, "invalid interface: %s", iface);

	if (ioctl(dev, DIOCCLRSTATUS, &pi))
		err(1, "DIOCCLRSTATUS");
	if ((opts & PF_OPT_QUIET) == 0) {
		fprintf(stderr, "pf: statistics cleared");
		if (iface != NULL)
			fprintf(stderr, " for interface %s", iface);
		fprintf(stderr, "\n");
	}
	return (0);
}

int
pfctl_clear_interface_flags(int dev, int opts)
{
	struct pfioc_iface	pi;

	if ((opts & PF_OPT_NOACTION) == 0) {
		bzero(&pi, sizeof(pi));
		pi.pfiio_flags = PFI_IFLAG_SKIP;

		if (ioctl(dev, DIOCCLRIFFLAG, &pi))
			err(1, "DIOCCLRIFFLAG");
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "pf: interface flags reset\n");
	}
	return (0);
}

int
pfctl_clear_rules(int dev, int opts, char *anchorname)
{
	struct pfr_buffer t;

	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_TRANS_RULESET, anchorname) ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_rules");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "rules cleared\n");
	return (0);
}

int
pfctl_clear_src_nodes(int dev, int opts)
{
	if (ioctl(dev, DIOCCLRSRCNODES))
		err(1, "DIOCCLRSRCNODES");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "source tracking entries cleared\n");
	return (0);
}

int
pfctl_clear_states(int dev, const char *iface, int opts)
{
	struct pfioc_state_kill psk;

	memset(&psk, 0, sizeof(psk));
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);

	if (ioctl(dev, DIOCCLRSTATES, &psk))
		err(1, "DIOCCLRSTATES");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "%d states cleared\n", psk.psk_killed);
	return (0);
}

void
pfctl_addrprefix(char *addr, struct pf_addr *mask)
{
	char *p;
	const char *errstr;
	int prefix, ret_ga, q, r;
	struct addrinfo hints, *res;

	if ((p = strchr(addr, '/')) == NULL)
		return;

	*p++ = '\0';
	prefix = strtonum(p, 0, 128, &errstr);
	if (errstr)
		errx(1, "prefix is %s: %s", errstr, p);

	bzero(&hints, sizeof(hints));
	/* prefix only with numeric addresses */
	hints.ai_flags |= AI_NUMERICHOST;

	if ((ret_ga = getaddrinfo(addr, NULL, &hints, &res))) {
		errx(1, "getaddrinfo: %s", gai_strerror(ret_ga));
		/* NOTREACHED */
	}

	if (res->ai_family == AF_INET && prefix > 32)
		errx(1, "prefix too long for AF_INET");
	else if (res->ai_family == AF_INET6 && prefix > 128)
		errx(1, "prefix too long for AF_INET6");

	q = prefix >> 3;
	r = prefix & 7;
	switch (res->ai_family) {
	case AF_INET:
		bzero(&mask->v4, sizeof(mask->v4));
		mask->v4.s_addr = htonl((u_int32_t)
		    (0xffffffffffULL << (32 - prefix)));
		break;
	case AF_INET6:
		bzero(&mask->v6, sizeof(mask->v6));
		if (q > 0)
			memset((void *)&mask->v6, 0xff, q);
		if (r > 0)
			*((u_char *)&mask->v6 + q) =
			    (0xff00 >> r) & 0xff;
		break;
	}
	freeaddrinfo(res);
}

int
pfctl_kill_src_nodes(int dev, const char *iface, int opts)
{
	struct pfioc_src_node_kill psnk;
	struct addrinfo *res[2], *resp[2];
	struct sockaddr last_src, last_dst;
	int killed, sources, dests;
	int ret_ga;

	killed = sources = dests = 0;

	memset(&psnk, 0, sizeof(psnk));
	memset(&psnk.psnk_src.addr.v.a.mask, 0xff,
	    sizeof(psnk.psnk_src.addr.v.a.mask));
	memset(&last_src, 0xff, sizeof(last_src));
	memset(&last_dst, 0xff, sizeof(last_dst));

	pfctl_addrprefix(src_node_kill[0], &psnk.psnk_src.addr.v.a.mask);

	if ((ret_ga = getaddrinfo(src_node_kill[0], NULL, NULL, &res[0]))) {
		errx(1, "getaddrinfo: %s", gai_strerror(ret_ga));
		/* NOTREACHED */
	}
	for (resp[0] = res[0]; resp[0]; resp[0] = resp[0]->ai_next) {
		if (resp[0]->ai_addr == NULL)
			continue;
		/* We get lots of duplicates.  Catch the easy ones */
		if (memcmp(&last_src, resp[0]->ai_addr, sizeof(last_src)) == 0)
			continue;
		last_src = *(struct sockaddr *)resp[0]->ai_addr;

		psnk.psnk_af = resp[0]->ai_family;
		sources++;

		if (psnk.psnk_af == AF_INET)
			psnk.psnk_src.addr.v.a.addr.v4 =
			    ((struct sockaddr_in *)resp[0]->ai_addr)->sin_addr;
		else if (psnk.psnk_af == AF_INET6)
			psnk.psnk_src.addr.v.a.addr.v6 =
			    ((struct sockaddr_in6 *)resp[0]->ai_addr)->
			    sin6_addr;
		else
			errx(1, "Unknown address family %d", psnk.psnk_af);

		if (src_node_killers > 1) {
			dests = 0;
			memset(&psnk.psnk_dst.addr.v.a.mask, 0xff,
			    sizeof(psnk.psnk_dst.addr.v.a.mask));
			memset(&last_dst, 0xff, sizeof(last_dst));
			pfctl_addrprefix(src_node_kill[1],
			    &psnk.psnk_dst.addr.v.a.mask);
			if ((ret_ga = getaddrinfo(src_node_kill[1], NULL, NULL,
			    &res[1]))) {
				errx(1, "getaddrinfo: %s",
				    gai_strerror(ret_ga));
				/* NOTREACHED */
			}
			for (resp[1] = res[1]; resp[1];
			    resp[1] = resp[1]->ai_next) {
				if (resp[1]->ai_addr == NULL)
					continue;
				if (psnk.psnk_af != resp[1]->ai_family)
					continue;

				if (memcmp(&last_dst, resp[1]->ai_addr,
				    sizeof(last_dst)) == 0)
					continue;
				last_dst = *(struct sockaddr *)resp[1]->ai_addr;

				dests++;

				if (psnk.psnk_af == AF_INET)
					psnk.psnk_dst.addr.v.a.addr.v4 =
					    ((struct sockaddr_in *)resp[1]->
					    ai_addr)->sin_addr;
				else if (psnk.psnk_af == AF_INET6)
					psnk.psnk_dst.addr.v.a.addr.v6 =
					    ((struct sockaddr_in6 *)resp[1]->
					    ai_addr)->sin6_addr;
				else
					errx(1, "Unknown address family %d",
					    psnk.psnk_af);

				if (ioctl(dev, DIOCKILLSRCNODES, &psnk))
					err(1, "DIOCKILLSRCNODES");
				killed += psnk.psnk_killed;
			}
			freeaddrinfo(res[1]);
		} else {
			if (ioctl(dev, DIOCKILLSRCNODES, &psnk))
				err(1, "DIOCKILLSRCNODES");
			killed += psnk.psnk_killed;
		}
	}

	freeaddrinfo(res[0]);

	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "killed %d src nodes from %d sources and %d "
		    "destinations\n", killed, sources, dests);
	return (0);
}

int
pfctl_net_kill_states(int dev, const char *iface, int opts, int rdomain)
{
	struct pfioc_state_kill psk;
	struct addrinfo *res[2], *resp[2];
	struct sockaddr last_src, last_dst;
	int killed, sources, dests;
	int ret_ga;

	killed = sources = dests = 0;

	memset(&psk, 0, sizeof(psk));
	memset(&psk.psk_src.addr.v.a.mask, 0xff,
	    sizeof(psk.psk_src.addr.v.a.mask));
	memset(&last_src, 0xff, sizeof(last_src));
	memset(&last_dst, 0xff, sizeof(last_dst));
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);

	psk.psk_rdomain = rdomain;

	pfctl_addrprefix(state_kill[0], &psk.psk_src.addr.v.a.mask);

	if ((ret_ga = getaddrinfo(state_kill[0], NULL, NULL, &res[0]))) {
		errx(1, "getaddrinfo: %s", gai_strerror(ret_ga));
		/* NOTREACHED */
	}
	for (resp[0] = res[0]; resp[0]; resp[0] = resp[0]->ai_next) {
		if (resp[0]->ai_addr == NULL)
			continue;
		/* We get lots of duplicates.  Catch the easy ones */
		if (memcmp(&last_src, resp[0]->ai_addr, sizeof(last_src)) == 0)
			continue;
		last_src = *(struct sockaddr *)resp[0]->ai_addr;

		psk.psk_af = resp[0]->ai_family;
		sources++;

		if (psk.psk_af == AF_INET)
			psk.psk_src.addr.v.a.addr.v4 =
			    ((struct sockaddr_in *)resp[0]->ai_addr)->sin_addr;
		else if (psk.psk_af == AF_INET6)
			psk.psk_src.addr.v.a.addr.v6 =
			    ((struct sockaddr_in6 *)resp[0]->ai_addr)->
			    sin6_addr;
		else
			errx(1, "Unknown address family %d", psk.psk_af);

		if (state_killers > 1) {
			dests = 0;
			memset(&psk.psk_dst.addr.v.a.mask, 0xff,
			    sizeof(psk.psk_dst.addr.v.a.mask));
			memset(&last_dst, 0xff, sizeof(last_dst));
			pfctl_addrprefix(state_kill[1],
			    &psk.psk_dst.addr.v.a.mask);
			if ((ret_ga = getaddrinfo(state_kill[1], NULL, NULL,
			    &res[1]))) {
				errx(1, "getaddrinfo: %s",
				    gai_strerror(ret_ga));
				/* NOTREACHED */
			}
			for (resp[1] = res[1]; resp[1];
			    resp[1] = resp[1]->ai_next) {
				if (resp[1]->ai_addr == NULL)
					continue;
				if (psk.psk_af != resp[1]->ai_family)
					continue;

				if (memcmp(&last_dst, resp[1]->ai_addr,
				    sizeof(last_dst)) == 0)
					continue;
				last_dst = *(struct sockaddr *)resp[1]->ai_addr;

				dests++;

				if (psk.psk_af == AF_INET)
					psk.psk_dst.addr.v.a.addr.v4 =
					    ((struct sockaddr_in *)resp[1]->
					    ai_addr)->sin_addr;
				else if (psk.psk_af == AF_INET6)
					psk.psk_dst.addr.v.a.addr.v6 =
					    ((struct sockaddr_in6 *)resp[1]->
					    ai_addr)->sin6_addr;
				else
					errx(1, "Unknown address family %d",
					    psk.psk_af);

				if (ioctl(dev, DIOCKILLSTATES, &psk))
					err(1, "DIOCKILLSTATES");
				killed += psk.psk_killed;
			}
			freeaddrinfo(res[1]);
		} else {
			if (ioctl(dev, DIOCKILLSTATES, &psk))
				err(1, "DIOCKILLSTATES");
			killed += psk.psk_killed;
		}
	}

	freeaddrinfo(res[0]);

	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "killed %d states from %d sources and %d "
		    "destinations\n", killed, sources, dests);
	return (0);
}

int
pfctl_label_kill_states(int dev, const char *iface, int opts, int rdomain)
{
	struct pfioc_state_kill psk;

	if (state_killers != 2 || (strlen(state_kill[1]) == 0)) {
		warnx("no label specified");
		usage();
	}
	memset(&psk, 0, sizeof(psk));
	if (iface != NULL && strlcpy(psk.psk_ifname, iface,
	    sizeof(psk.psk_ifname)) >= sizeof(psk.psk_ifname))
		errx(1, "invalid interface: %s", iface);

	if (strlcpy(psk.psk_label, state_kill[1], sizeof(psk.psk_label)) >=
	    sizeof(psk.psk_label))
		errx(1, "label too long: %s", state_kill[1]);

	psk.psk_rdomain = rdomain;

	if (ioctl(dev, DIOCKILLSTATES, &psk))
		err(1, "DIOCKILLSTATES");

	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "killed %d states\n", psk.psk_killed);

	return (0);
}

int
pfctl_id_kill_states(int dev, int opts)
{
	struct pfioc_state_kill psk;

	if (state_killers != 2 || (strlen(state_kill[1]) == 0)) {
		warnx("no id specified");
		usage();
	}

	memset(&psk, 0, sizeof(psk));
	if ((sscanf(state_kill[1], "%llx/%x",
	    &psk.psk_pfcmp.id, &psk.psk_pfcmp.creatorid)) == 2)
		HTONL(psk.psk_pfcmp.creatorid);
	else if ((sscanf(state_kill[1], "%llx", &psk.psk_pfcmp.id)) == 1) {
		psk.psk_pfcmp.creatorid = 0;
	} else {
		warnx("wrong id format specified");
		usage();
	}
	if (psk.psk_pfcmp.id == 0) {
		warnx("cannot kill id 0");
		usage();
	}

	psk.psk_pfcmp.id = htobe64(psk.psk_pfcmp.id);
	if (ioctl(dev, DIOCKILLSTATES, &psk))
		err(1, "DIOCKILLSTATES");

	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "killed %d states\n", psk.psk_killed);

	return (0);
}

void
pfctl_print_rule_counters(struct pf_rule *rule, int opts)
{
	if (opts & PF_OPT_DEBUG) {
		const char *t[PF_SKIP_COUNT] = { "i", "d", "r", "f",
		    "p", "sa", "da", "sp", "dp" };
		int i;

		printf("  [ Skip steps: ");
		for (i = 0; i < PF_SKIP_COUNT; ++i) {
			if (rule->skip[i].nr == rule->nr + 1)
				continue;
			printf("%s=", t[i]);
			if (rule->skip[i].nr == -1)
				printf("end ");
			else
				printf("%u ", rule->skip[i].nr);
		}
		printf("]\n");

		printf("  [ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n",
		    rule->qname, rule->qid, rule->pqname, rule->pqid);
	}
	if (opts & PF_OPT_VERBOSE) {
		printf("  [ Evaluations: %-8llu  Packets: %-8llu  "
			    "Bytes: %-10llu  States: %-6u]\n",
			    (unsigned long long)rule->evaluations,
			    (unsigned long long)(rule->packets[0] +
			    rule->packets[1]),
			    (unsigned long long)(rule->bytes[0] +
			    rule->bytes[1]), rule->states_cur);
		if (!(opts & PF_OPT_DEBUG))
			printf("  [ Inserted: uid %lu pid %lu "
			    "State Creations: %-6u]\n",
			    (unsigned long)rule->cuid, (unsigned long)rule->cpid,
			    rule->states_tot);
	}
}

void
pfctl_print_title(char *title)
{
	if (!first_title)
		printf("\n");
	first_title = 0;
	printf("%s\n", title);
}

int
pfctl_show_rules(int dev, char *path, int opts, enum pfctl_show format,
    char *anchorname, int depth, int wildcard, long shownr)
{
	struct pfioc_rule pr;
	u_int32_t nr, mnr, header = 0;
	int len = strlen(path), ret = 0;
	char *npath, *p;

	/*
	 * Truncate a trailing / and * on an anchorname before searching for
	 * the ruleset, this is syntactic sugar that doesn't actually make it
	 * to the kernel.
	 */
	if ((p = strrchr(anchorname, '/')) != NULL &&
	    p[1] == '*' && p[2] == '\0') {
		p[0] = '\0';
	}

	memset(&pr, 0, sizeof(pr));
	if (anchorname[0] == '/') {
		if ((npath = calloc(1, PATH_MAX)) == NULL)
			err(1, "calloc");
		strlcpy(npath, anchorname, PATH_MAX);
	} else {
		if (path[0])
			snprintf(&path[len], PATH_MAX - len, "/%s", anchorname);
		else
			snprintf(&path[len], PATH_MAX - len, "%s", anchorname);
		npath = path;
	}

	memcpy(pr.anchor, npath, sizeof(pr.anchor));
	if (opts & PF_OPT_SHOWALL) {
		pr.rule.action = PF_PASS;
		if (ioctl(dev, DIOCGETRULES, &pr)) {
			warn("DIOCGETRULES");
			ret = -1;
			goto error;
		}
		header++;
		if (format == PFCTL_SHOW_RULES && (pr.nr > 0 || header))
			pfctl_print_title("FILTER RULES:");
		else if (format == PFCTL_SHOW_LABELS && labels)
			pfctl_print_title("LABEL COUNTERS:");
	}
	if (opts & PF_OPT_CLRRULECTRS)
		pr.action = PF_GET_CLR_CNTR;

	pr.rule.action = PF_PASS;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		ret = -1;
		goto error;
	}

	if (shownr < 0) {
		mnr = pr.nr;
		nr = 0;
	} else if (shownr < pr.nr) {
		nr = shownr;
		mnr = shownr + 1;
	} else {
		warnx("rule %ld not found", shownr);
		ret = -1;
		goto error;
	}
	for (; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			ret = -1;
			goto error;
		}

		/* anchor is the same for all rules in it */
		if (pr.rule.anchor_wildcard == 0)
			wildcard = 0;

		switch (format) {
		case PFCTL_SHOW_LABELS:
			if (pr.rule.label[0]) {
				INDENT(depth, !(opts & PF_OPT_VERBOSE));
				printf("%s %llu %llu %llu %llu"
				    " %llu %llu %llu %llu\n",
				    pr.rule.label,
				    (unsigned long long)pr.rule.evaluations,
				    (unsigned long long)(pr.rule.packets[0] +
				    pr.rule.packets[1]),
				    (unsigned long long)(pr.rule.bytes[0] +
				    pr.rule.bytes[1]),
				    (unsigned long long)pr.rule.packets[0],
				    (unsigned long long)pr.rule.bytes[0],
				    (unsigned long long)pr.rule.packets[1],
				    (unsigned long long)pr.rule.bytes[1],
				    (unsigned long long)pr.rule.states_tot);
			}
			break;
		case PFCTL_SHOW_RULES:
			if (pr.rule.label[0] && (opts & PF_OPT_SHOWALL))
				labels = 1;
			INDENT(depth, !(opts & PF_OPT_VERBOSE));
			print_rule(&pr.rule, pr.anchor_call, opts);

			/*
			 * If this is an 'unnamed' brace notation anchor OR
			 * the user has explicitly requested recursion,
			 * print it recursively.
			 */
       		        if (pr.anchor_call[0] &&
			    (((p = strrchr(pr.anchor_call, '/')) ?
			    p[1] == '_' : pr.anchor_call[0] == '_') ||
			    opts & PF_OPT_RECURSE)) {
				printf(" {\n");
				pfctl_print_rule_counters(&pr.rule, opts);
				pfctl_show_rules(dev, npath, opts, format,
				    pr.anchor_call, depth + 1,
				    pr.rule.anchor_wildcard, -1);
				INDENT(depth, !(opts & PF_OPT_VERBOSE));
				printf("}\n");
			} else {
				printf("\n");
				pfctl_print_rule_counters(&pr.rule, opts);
			}
			break;
		case PFCTL_SHOW_NOTHING:
			break;
		}
	}

	/*
	 * If this anchor was called with a wildcard path, go through
	 * the rulesets in the anchor rather than the rules.
	 */
	if (wildcard && (opts & PF_OPT_RECURSE)) {
		struct pfioc_ruleset	 prs;
		u_int32_t		 mnr, nr;

		memset(&prs, 0, sizeof(prs));
		memcpy(prs.path, npath, sizeof(prs.path));
		if (ioctl(dev, DIOCGETRULESETS, &prs)) {
			if (errno == EINVAL)
				fprintf(stderr, "Anchor '%s' "
				    "not found.\n", anchorname);
			else
				err(1, "DIOCGETRULESETS");
		}
		mnr = prs.nr;

		for (nr = 0; nr < mnr; ++nr) {
			prs.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &prs))
				err(1, "DIOCGETRULESET");
			INDENT(depth, !(opts & PF_OPT_VERBOSE));
			printf("anchor \"%s\" all {\n", prs.name);
			pfctl_show_rules(dev, npath, opts,
			    format, prs.name, depth + 1, 0, shownr);
			INDENT(depth, !(opts & PF_OPT_VERBOSE));
			printf("}\n");
		}
		path[len] = '\0';
		return (0);
	}

 error:
	if (path != npath)
		free(npath);
	path[len] = '\0';
	return (ret);
}

int
pfctl_show_src_nodes(int dev, int opts)
{
	struct pfioc_src_nodes psn;
	struct pf_src_node *p;
	char *inbuf = NULL, *newinbuf = NULL;
	unsigned int len = 0;
	int i;

	memset(&psn, 0, sizeof(psn));
	for (;;) {
		psn.psn_len = len;
		if (len) {
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
				err(1, "realloc");
			psn.psn_buf = inbuf = newinbuf;
		}
		if (ioctl(dev, DIOCGETSRCNODES, &psn) < 0) {
			warn("DIOCGETSRCNODES");
			free(inbuf);
			return (-1);
		}
		if (psn.psn_len + sizeof(struct pfioc_src_nodes) < len)
			break;
		if (len == 0 && psn.psn_len == 0)
			goto done;
		if (len == 0 && psn.psn_len != 0)
			len = psn.psn_len;
		if (psn.psn_len == 0)
			goto done;	/* no src_nodes */
		len *= 2;
	}
	p = psn.psn_src_nodes;
	if (psn.psn_len > 0 && (opts & PF_OPT_SHOWALL))
		pfctl_print_title("SOURCE TRACKING NODES:");
	for (i = 0; i < psn.psn_len; i += sizeof(*p)) {
		print_src_node(p, opts);
		p++;
	}
done:
	free(inbuf);
	return (0);
}

int
pfctl_show_states(int dev, const char *iface, int opts, long shownr)
{
	struct pfioc_states ps;
	struct pfsync_state *p;
	char *inbuf = NULL, *newinbuf = NULL;
	unsigned int len = 0;
	int i, dotitle = (opts & PF_OPT_SHOWALL);

	memset(&ps, 0, sizeof(ps));
	for (;;) {
		ps.ps_len = len;
		if (len) {
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
				err(1, "realloc");
			ps.ps_buf = inbuf = newinbuf;
		}
		if (ioctl(dev, DIOCGETSTATES, &ps) < 0) {
			warn("DIOCGETSTATES");
			free(inbuf);
			return (-1);
		}
		if (ps.ps_len + sizeof(struct pfioc_states) < len)
			break;
		if (len == 0 && ps.ps_len == 0)
			goto done;
		if (len == 0 && ps.ps_len != 0)
			len = ps.ps_len;
		if (ps.ps_len == 0)
			goto done;	/* no states */
		len *= 2;
	}
	p = ps.ps_states;
	for (i = 0; i < ps.ps_len; i += sizeof(*p), p++) {
		if (iface != NULL && strcmp(p->ifname, iface))
			continue;
		if (dotitle) {
			pfctl_print_title("STATES:");
			dotitle = 0;
		}
		if (shownr < 0 || ntohl(p->rule) == shownr)
			print_state(p, opts);
	}
done:
	free(inbuf);
	return (0);
}

int
pfctl_show_status(int dev, int opts)
{
	struct pf_status status;

	if (ioctl(dev, DIOCGETSTATUS, &status)) {
		warn("DIOCGETSTATUS");
		return (-1);
	}
	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("INFO:");
	print_status(&status, opts);
	return (0);
}

int
pfctl_show_timeouts(int dev, int opts)
{
	struct pfioc_tm pt;
	int i;

	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("TIMEOUTS:");
	memset(&pt, 0, sizeof(pt));
	for (i = 0; pf_timeouts[i].name; i++) {
		pt.timeout = pf_timeouts[i].timeout;
		if (ioctl(dev, DIOCGETTIMEOUT, &pt))
			err(1, "DIOCGETTIMEOUT");
		printf("%-20s %10d", pf_timeouts[i].name, pt.seconds);
		if (pf_timeouts[i].timeout >= PFTM_ADAPTIVE_START &&
		    pf_timeouts[i].timeout <= PFTM_ADAPTIVE_END)
			printf(" states");
		else
			printf("s");
		printf("\n");
	}
	return (0);

}

int
pfctl_show_limits(int dev, int opts)
{
	struct pfioc_limit pl;
	int i;

	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("LIMITS:");
	memset(&pl, 0, sizeof(pl));
	for (i = 0; pf_limits[i].name; i++) {
		pl.index = pf_limits[i].index;
		if (ioctl(dev, DIOCGETLIMIT, &pl))
			err(1, "DIOCGETLIMIT");
		printf("%-13s ", pf_limits[i].name);
		if (pl.limit == UINT_MAX)
			printf("unlimited\n");
		else
			printf("hard limit %8u\n", pl.limit);
	}
	return (0);
}

/* callbacks for rule/nat/rdr/addr */
int
pfctl_add_rule(struct pfctl *pf, struct pf_rule *r, const char *anchor_call)
{
	struct pf_rule		*rule;
	struct pf_ruleset	*rs;
	char 			*p;

	rs = &pf->anchor->ruleset;
	if (anchor_call[0] && r->anchor == NULL) {
		/*
		 * Don't make non-brace anchors part of the main anchor pool.
		 */
		if ((r->anchor = calloc(1, sizeof(*r->anchor))) == NULL)
			err(1, "pfctl_add_rule: calloc");

		pf_init_ruleset(&r->anchor->ruleset);
		r->anchor->ruleset.anchor = r->anchor;
		if (strlcpy(r->anchor->path, anchor_call,
		    sizeof(rule->anchor->path)) >= sizeof(rule->anchor->path))
                        errx(1, "pfctl_add_rule: strlcpy");
		if ((p = strrchr(anchor_call, '/')) != NULL) {
			if (strlen(p) == 1)
				errx(1, "pfctl_add_rule: bad anchor name %s",
				    anchor_call);
		} else
			p = (char *)anchor_call;
		if (strlcpy(r->anchor->name, p,
		    sizeof(rule->anchor->name)) >= sizeof(rule->anchor->name))
                        errx(1, "pfctl_add_rule: strlcpy");
	}

	if ((rule = calloc(1, sizeof(*rule))) == NULL)
		err(1, "calloc");
	bcopy(r, rule, sizeof(*rule));

	TAILQ_INSERT_TAIL(rs->rules.active.ptr, rule, entries);
	return (0);
}

int
pfctl_ruleset_trans(struct pfctl *pf, char *path, struct pf_anchor *a)
{
	int osize = pf->trans->pfrb_size;

	if (pfctl_add_trans(pf->trans, PF_TRANS_RULESET, path))
		return (3);
	if (pfctl_add_trans(pf->trans, PF_TRANS_TABLE, path))
		return (4);
	if (pfctl_trans(pf->dev, pf->trans, DIOCXBEGIN, osize))
		return (5);

	return (0);
}

int
pfctl_add_queue(struct pfctl *pf, struct pf_queuespec *q)
{
	struct pfctl_qsitem	*qi;

	if (pf->anchor->name[0]) {
		printf("must not have queue definitions in an anchor\n");
		return (1);
	}

	if (q->parent[0] == '\0') {
		TAILQ_FOREACH(qi, &rootqs, entries) {
			if (strcmp(q->ifname, qi->qs.ifname))
			    continue;
			printf("A root queue is already defined on %s\n",
			    qi->qs.ifname);
			return (1);
		}
	}

	if ((qi = calloc(1, sizeof(*qi))) == NULL)
		err(1, "calloc");
	bcopy(q, &qi->qs, sizeof(qi->qs));
	TAILQ_INIT(&qi->children);

	if (qi->qs.parent[0])
		TAILQ_INSERT_TAIL(&qspecs, qi, entries);
	else
		TAILQ_INSERT_TAIL(&rootqs, qi, entries);

	return (0);
}

struct pfctl_qsitem *
pfctl_find_queue(char *what, struct pf_qihead *where)
{
	struct pfctl_qsitem *q;

	TAILQ_FOREACH(q, where, entries)
		if (strcmp(q->qs.qname, what) == 0)
			return (q);

	return (NULL);
}

u_int
pfctl_find_childqs(struct pfctl_qsitem *qi)
{
	struct pfctl_qsitem	*n, *p, *q;
	u_int			 flags = qi->qs.flags;

	TAILQ_FOREACH(p, &qspecs, entries) {
		if (strcmp(p->qs.parent, qi->qs.qname))
			continue;
		if (p->qs.ifname[0] && strcmp(p->qs.ifname, qi->qs.ifname))
			continue;
		if (++p->matches > 10000)
			errx(1, "pfctl_find_childqs: excessive matches, loop?");

		if ((q = pfctl_find_queue(p->qs.qname, &qi->children)) == NULL) {
			/* insert */
			if ((n = calloc(1, sizeof(*n))) == NULL)
				err(1, "calloc");
			TAILQ_INIT(&n->children);
			bcopy(&p->qs, &n->qs, sizeof(n->qs));
			TAILQ_INSERT_TAIL(&qi->children, n, entries);
		} else {
			if ((q->qs.ifname[0] && p->qs.ifname[0]))
				errx(1, "queue %s on %s respecified",
				    q->qs.qname, q->qs.ifname);
			if (!q->qs.ifname[0] && !p->qs.ifname[0])
				errx(1, "queue %s respecified",
				    q->qs.qname);
			/* ifbound beats floating */
			if (!q->qs.ifname[0])
				bcopy(&p->qs, &q->qs, sizeof(q->qs));
		}
	}

	TAILQ_FOREACH(p, &qi->children, entries)
		flags |= pfctl_find_childqs(p);

	if (qi->qs.flags & HFSC_DEFAULTCLASS && !TAILQ_EMPTY(&qi->children))
		errx(1, "default queue %s is not a leaf queue", qi->qs.qname);

	return (flags);
}

void
pfctl_load_queue(struct pfctl *pf, u_int32_t ticket, struct pfctl_qsitem *qi)
{
	struct pfioc_queue	 q;
	struct pfctl_qsitem	*p;

	q.ticket = ticket;
	bcopy(&qi->qs, &q.queue, sizeof(q.queue));
	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(pf->dev, DIOCADDQUEUE, &q))
			err(1, "DIOCADDQUEUE");
	if (pf->opts & PF_OPT_VERBOSE)
		print_queuespec(&qi->qs);

	TAILQ_FOREACH(p, &qi->children, entries) {
		strlcpy(p->qs.ifname, qi->qs.ifname, IFNAMSIZ);
		pfctl_load_queue(pf, ticket, p);
	}
}

int
pfctl_load_queues(struct pfctl *pf)
{
	struct pfctl_qsitem	*qi, *tempqi, rqi;
	u_int32_t		 ticket;

	TAILQ_FOREACH(qi, &qspecs, entries) {
		if (qi->matches == 0)
			errx(1, "queue %s: parent %s not found\n", qi->qs.qname,
			    qi->qs.parent);
		if (qi->qs.realtime.m1.percent || qi->qs.realtime.m2.percent ||
		    qi->qs.linkshare.m1.percent ||
		    qi->qs.linkshare.m2.percent ||
		    qi->qs.upperlimit.m1.percent ||
		    qi->qs.upperlimit.m2.percent)
			errx(1, "only absolute bandwidth specs for now");
	}

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		ticket = pfctl_get_ticket(pf->trans, PF_TRANS_RULESET, "");

	TAILQ_FOREACH_SAFE(qi, &rootqs, entries, tempqi) {
		TAILQ_REMOVE(&rootqs, qi, entries);

		/*
		 * We must have a hidden root queue below the user-
		 * specified/visible root queue, due to the way the
		 * dequeueing works far down there... don't ask.
		 * the _ namespace is reserved for these.
		 */
		bzero(&rqi, sizeof(rqi));
		TAILQ_INIT(&rqi.children);
		TAILQ_INSERT_TAIL(&rqi.children, qi, entries);
		snprintf(rqi.qs.qname, PF_QNAME_SIZE, "_root_%s",
		    qi->qs.ifname);
		strlcpy(rqi.qs.ifname, qi->qs.ifname, sizeof(rqi.qs.ifname));
		strlcpy(qi->qs.parent, rqi.qs.qname, sizeof(qi->qs.parent));

		pfctl_load_queue(pf, ticket, &rqi);

		TAILQ_INSERT_HEAD(&rootqs, qi, entries);
	}

	return (0);
}

void
pfctl_clear_queues(struct pf_qihead *head)
{
	struct pfctl_qsitem *qi;

	while ((qi = TAILQ_FIRST(head)) != NULL) {
		TAILQ_REMOVE(head, qi, entries);
		pfctl_clear_queues(&qi->children);
		free(qi);
	}
}

u_int
pfctl_leafqueue_check(char *qname)
{
	struct pfctl_qsitem	*qi;
	if (qname == NULL || qname[0] == 0)
		return (0);

	TAILQ_FOREACH(qi, &rootqs, entries) {
		if (strcmp(qname, qi->qs.qname))
			continue;
		if (!TAILQ_EMPTY(&qi->children)) {
			printf("queue %s: packets must be assigned to leaf "
			    "queues only\n", qname);
			return (1);
		}
	}
	TAILQ_FOREACH(qi, &qspecs, entries) {
		if (strcmp(qname, qi->qs.qname))
			continue;
		if (!TAILQ_EMPTY(&qi->children)) {
			printf("queue %s: packets must be assigned to leaf "
			    "queues only\n", qname);
			return (1);
		}
	}
	return (0);
}

u_int
pfctl_check_qassignments(struct pf_ruleset *rs)
{
	struct pf_rule		*r;
	struct pfctl_qsitem	*qi;
	u_int			 flags, errs = 0;

	/* main ruleset: need find_childqs to populate qi->children */
	if (rs->anchor->path[0] == 0) {
		TAILQ_FOREACH(qi, &rootqs, entries) {
			flags = pfctl_find_childqs(qi);
			if (!(flags & HFSC_DEFAULTCLASS))
				errx(1, "no default queue specified");
		}
	}

	TAILQ_FOREACH(r, rs->rules.active.ptr, entries) {
		if (r->anchor)
			errs += pfctl_check_qassignments(&r->anchor->ruleset);
		if (pfctl_leafqueue_check(r->qname) ||
		    pfctl_leafqueue_check(r->pqname))
			errs++;
	}
	return (errs);
}

int
pfctl_load_ruleset(struct pfctl *pf, char *path, struct pf_ruleset *rs,
    int depth)
{
	struct pf_rule *r;
	int		error, len = strlen(path);
	int		brace = 0;

	pf->anchor = rs->anchor;

	if (path[0])
		snprintf(&path[len], PATH_MAX - len, "/%s", pf->anchor->name);
	else
		snprintf(&path[len], PATH_MAX - len, "%s", pf->anchor->path);

	if (depth) {
		if (TAILQ_FIRST(rs->rules.active.ptr) != NULL) {
			brace++;
			if (pf->opts & PF_OPT_VERBOSE)
				printf(" {\n");
			if ((pf->opts & PF_OPT_NOACTION) == 0 &&
			    (error = pfctl_ruleset_trans(pf,
			    path, rs->anchor))) {
				printf("pfctl_load_rulesets: "
				    "pfctl_ruleset_trans %d\n", error);
				goto error;
			}
		} else if (pf->opts & PF_OPT_VERBOSE)
			printf("\n");

	}

	if (pf->optimize)
		pfctl_optimize_ruleset(pf, rs);

	while ((r = TAILQ_FIRST(rs->rules.active.ptr)) != NULL) {
		TAILQ_REMOVE(rs->rules.active.ptr, r, entries);
		if ((error = pfctl_load_rule(pf, path, r, depth)))
			goto error;
		if (r->anchor) {
			if ((error = pfctl_load_ruleset(pf, path,
			    &r->anchor->ruleset, depth + 1)))
				goto error;
		} else if (pf->opts & PF_OPT_VERBOSE)
			printf("\n");
		free(r);
	}
	if (brace && pf->opts & PF_OPT_VERBOSE) {
		INDENT(depth - 1, (pf->opts & PF_OPT_VERBOSE));
		printf("}\n");
	}
	path[len] = '\0';
	return (0);

 error:
	path[len] = '\0';
	return (error);

}

int
pfctl_load_rule(struct pfctl *pf, char *path, struct pf_rule *r, int depth)
{
	char			*name;
	struct pfioc_rule	pr;
	int			len = strlen(path);

	bzero(&pr, sizeof(pr));
	/* set up anchor before adding to path for anchor_call */
	if ((pf->opts & PF_OPT_NOACTION) == 0)
		pr.ticket = pfctl_get_ticket(pf->trans, PF_TRANS_RULESET, path);
	if (strlcpy(pr.anchor, path, sizeof(pr.anchor)) >= sizeof(pr.anchor))
		errx(1, "pfctl_load_rule: strlcpy");

	if (r->anchor) {
		if (r->anchor->match) {
			if (path[0])
				snprintf(&path[len], PATH_MAX - len,
				    "/%s", r->anchor->name);
			else
				snprintf(&path[len], PATH_MAX - len,
				    "%s", r->anchor->name);
			name = r->anchor->name;
		} else
			name = r->anchor->path;
	} else
		name = "";

	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		memcpy(&pr.rule, r, sizeof(pr.rule));
		if (r->anchor && strlcpy(pr.anchor_call, name,
		    sizeof(pr.anchor_call)) >= sizeof(pr.anchor_call))
			errx(1, "pfctl_load_rule: strlcpy");
		if (ioctl(pf->dev, DIOCADDRULE, &pr))
			err(1, "DIOCADDRULE");
	}

	if (pf->opts & PF_OPT_VERBOSE) {
		INDENT(depth, !(pf->opts & PF_OPT_VERBOSE2));
		print_rule(r, name, pf->opts);
	}
	path[len] = '\0';
	return (0);
}

int
pfctl_rules(int dev, char *filename, int opts, int optimize,
    char *anchorname, struct pfr_buffer *trans)
{
#define ERR(x) do { warn(x); goto _error; } while(0)
#define ERRX(x) do { warnx(x); goto _error; } while(0)

	struct pfr_buffer	*t, buf;
	struct pfctl		 pf;
	struct pf_ruleset	*rs;
	struct pfr_table	 trs;
	char			*path = NULL;
	int			 osize;
	char			*p;

	bzero(&pf, sizeof(pf));
	RB_INIT(&pf_anchors);
	memset(&pf_main_anchor, 0, sizeof(pf_main_anchor));
	pf_init_ruleset(&pf_main_anchor.ruleset);
	pf_main_anchor.ruleset.anchor = &pf_main_anchor;
	if (trans == NULL) {
		bzero(&buf, sizeof(buf));
		buf.pfrb_type = PFRB_TRANS;
		t = &buf;
		osize = 0;
	} else {
		t = trans;
		osize = t->pfrb_size;
	}

	memset(&pf, 0, sizeof(pf));
	memset(&trs, 0, sizeof(trs));
	if ((path = calloc(1, PATH_MAX)) == NULL)
		ERRX("pfctl_rules: calloc");
	if (strlcpy(trs.pfrt_anchor, anchorname,
	    sizeof(trs.pfrt_anchor)) >= sizeof(trs.pfrt_anchor))
		ERRX("pfctl_rules: strlcpy");
	pf.dev = dev;
	pf.opts = opts;
	pf.optimize = optimize;

	/* non-brace anchor, create without resolving the path */
	if ((pf.anchor = calloc(1, sizeof(*pf.anchor))) == NULL)
		ERRX("pfctl_rules: calloc");
	rs = &pf.anchor->ruleset;
	pf_init_ruleset(rs);
	rs->anchor = pf.anchor;
	if (strlcpy(pf.anchor->path, anchorname,
	    sizeof(pf.anchor->path)) >= sizeof(pf.anchor->path))
		errx(1, "pfctl_add_rule: strlcpy");

	if ((p = strrchr(anchorname, '/')) != NULL) {
		if (strlen(p) == 1)
			errx(1, "pfctl_add_rule: bad anchor name %s",
			    anchorname);
	} else
		p = anchorname;

	if (strlcpy(pf.anchor->name, p,
	    sizeof(pf.anchor->name)) >= sizeof(pf.anchor->name))
		errx(1, "pfctl_add_rule: strlcpy");


	pf.astack[0] = pf.anchor;
	pf.asd = 0;
	pf.trans = t;
	pfctl_init_options(&pf);

	if ((opts & PF_OPT_NOACTION) == 0) {
		/*
		 * XXX For the time being we need to open transactions for
		 * the main ruleset before parsing, because tables are still
		 * loaded at parse time.
		 */
		if (pfctl_ruleset_trans(&pf, anchorname, pf.anchor))
			ERRX("pfctl_rules");
		pf.astack[0]->ruleset.tticket =
		    pfctl_get_ticket(t, PF_TRANS_TABLE, anchorname);
	}

	if (parse_config(filename, &pf) < 0) {
		if ((opts & PF_OPT_NOACTION) == 0)
			ERRX("Syntax error in config file: "
			    "pf rules not loaded");
		else
			goto _error;
	}

	if (!anchorname[0] && (pfctl_check_qassignments(&pf.anchor->ruleset) ||
	    pfctl_load_queues(&pf))) {
		if ((opts & PF_OPT_NOACTION) == 0)
			ERRX("Unable to load queues into kernel");
		else
			goto _error;
	}

	if (pfctl_load_ruleset(&pf, path, rs, 0)) {
		if ((opts & PF_OPT_NOACTION) == 0)
			ERRX("Unable to load rules into kernel");
		else
			goto _error;
	}

	free(path);
	path = NULL;

	/* process "load anchor" directives that might have used queues */
	if (!anchorname[0]) {
		if (pfctl_load_anchors(dev, &pf, t) == -1)
			ERRX("load anchors");
		pfctl_clear_queues(&qspecs);
		pfctl_clear_queues(&rootqs);
	}

	if (trans == NULL && (opts & PF_OPT_NOACTION) == 0) {
		if (!anchorname[0])
			if (pfctl_load_options(&pf))
				goto _error;
		if (pfctl_trans(dev, t, DIOCXCOMMIT, osize))
			ERR("DIOCXCOMMIT");
	}
	return (0);

_error:
	if (trans == NULL) {	/* main ruleset */
		if ((opts & PF_OPT_NOACTION) == 0)
			if (pfctl_trans(dev, t, DIOCXROLLBACK, osize))
				err(1, "DIOCXROLLBACK");
		exit(1);
	} else {		/* sub ruleset */
		free(path);
		return (-1);
	}

#undef ERR
#undef ERRX
}

FILE *
pfctl_fopen(const char *name, const char *mode)
{
	struct stat	 st;
	FILE		*fp;

	fp = fopen(name, mode);
	if (fp == NULL)
		return (NULL);
	if (fstat(fileno(fp), &st)) {
		fclose(fp);
		return (NULL);
	}
	if (S_ISDIR(st.st_mode)) {
		fclose(fp);
		errno = EISDIR;
		return (NULL);
	}
	return (fp);
}

void
pfctl_init_options(struct pfctl *pf)
{
	int64_t mem;
	int mib[2], mcl;
	size_t size;

	pf->timeout[PFTM_TCP_FIRST_PACKET] = PFTM_TCP_FIRST_PACKET_VAL;
	pf->timeout[PFTM_TCP_OPENING] = PFTM_TCP_OPENING_VAL;
	pf->timeout[PFTM_TCP_ESTABLISHED] = PFTM_TCP_ESTABLISHED_VAL;
	pf->timeout[PFTM_TCP_CLOSING] = PFTM_TCP_CLOSING_VAL;
	pf->timeout[PFTM_TCP_FIN_WAIT] = PFTM_TCP_FIN_WAIT_VAL;
	pf->timeout[PFTM_TCP_CLOSED] = PFTM_TCP_CLOSED_VAL;
	pf->timeout[PFTM_UDP_FIRST_PACKET] = PFTM_UDP_FIRST_PACKET_VAL;
	pf->timeout[PFTM_UDP_SINGLE] = PFTM_UDP_SINGLE_VAL;
	pf->timeout[PFTM_UDP_MULTIPLE] = PFTM_UDP_MULTIPLE_VAL;
	pf->timeout[PFTM_ICMP_FIRST_PACKET] = PFTM_ICMP_FIRST_PACKET_VAL;
	pf->timeout[PFTM_ICMP_ERROR_REPLY] = PFTM_ICMP_ERROR_REPLY_VAL;
	pf->timeout[PFTM_OTHER_FIRST_PACKET] = PFTM_OTHER_FIRST_PACKET_VAL;
	pf->timeout[PFTM_OTHER_SINGLE] = PFTM_OTHER_SINGLE_VAL;
	pf->timeout[PFTM_OTHER_MULTIPLE] = PFTM_OTHER_MULTIPLE_VAL;
	pf->timeout[PFTM_FRAG] = PFTM_FRAG_VAL;
	pf->timeout[PFTM_INTERVAL] = PFTM_INTERVAL_VAL;
	pf->timeout[PFTM_SRC_NODE] = PFTM_SRC_NODE_VAL;
	pf->timeout[PFTM_TS_DIFF] = PFTM_TS_DIFF_VAL;
	pf->timeout[PFTM_ADAPTIVE_START] = PFSTATE_ADAPT_START;
	pf->timeout[PFTM_ADAPTIVE_END] = PFSTATE_ADAPT_END;

	pf->limit[PF_LIMIT_STATES] = PFSTATE_HIWAT;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MAXCLUSTERS;
	size = sizeof(mcl);
	if (sysctl(mib, 2, &mcl, &size, NULL, 0) == -1)
		err(1, "sysctl");
	pf->limit[PF_LIMIT_FRAGS] = mcl / 4;

	pf->limit[PF_LIMIT_SRC_NODES] = PFSNODE_HIWAT;
	pf->limit[PF_LIMIT_TABLES] = PFR_KTABLE_HIWAT;
	pf->limit[PF_LIMIT_TABLE_ENTRIES] = PFR_KENTRY_HIWAT;

	mib[0] = CTL_HW;
	mib[1] = HW_PHYSMEM64;
	size = sizeof(mem);
	if (sysctl(mib, 2, &mem, &size, NULL, 0) == -1)
		err(1, "sysctl");
	if (mem <= 100*1024*1024)
		pf->limit[PF_LIMIT_TABLE_ENTRIES] = PFR_KENTRY_HIWAT_SMALL;

	pf->debug = LOG_ERR;
	pf->debug_set = 0;
	pf->reassemble = PF_REASS_ENABLED;
}

int
pfctl_load_options(struct pfctl *pf)
{
	int i, error = 0;

	/* load limits */
	for (i = 0; i < PF_LIMIT_MAX; i++)
		if (pfctl_load_limit(pf, i, pf->limit[i]))
			error = 1;

	/*
	 * If we've set the limit, but haven't explicitly set adaptive
	 * timeouts, do it now with a start of 60% and end of 120%.
	 */
	if (pf->limit_set[PF_LIMIT_STATES] &&
	    !pf->timeout_set[PFTM_ADAPTIVE_START] &&
	    !pf->timeout_set[PFTM_ADAPTIVE_END]) {
		pf->timeout[PFTM_ADAPTIVE_START] =
			(pf->limit[PF_LIMIT_STATES] / 10) * 6;
		pf->timeout_set[PFTM_ADAPTIVE_START] = 1;
		pf->timeout[PFTM_ADAPTIVE_END] =
			(pf->limit[PF_LIMIT_STATES] / 10) * 12;
		pf->timeout_set[PFTM_ADAPTIVE_END] = 1;
	}

	/* load timeouts */
	for (i = 0; i < PFTM_MAX; i++)
		if (pfctl_load_timeout(pf, i, pf->timeout[i]))
			error = 1;

	/* load debug */
	if (pf->debug_set && pfctl_load_debug(pf, pf->debug))
		error = 1;

	/* load logif */
	if (pf->ifname_set && pfctl_load_logif(pf, pf->ifname))
		error = 1;

	/* load hostid */
	if (pf->hostid_set && pfctl_load_hostid(pf, pf->hostid))
		error = 1;

	/* load reassembly settings */
	if (pf->reass_set && pfctl_load_reassembly(pf, pf->reassemble))
		error = 1;

	return (error);
}

int
pfctl_set_limit(struct pfctl *pf, const char *opt, unsigned int limit)
{
	int i;


	for (i = 0; pf_limits[i].name; i++) {
		if (strcasecmp(opt, pf_limits[i].name) == 0) {
			pf->limit[pf_limits[i].index] = limit;
			pf->limit_set[pf_limits[i].index] = 1;
			break;
		}
	}
	if (pf_limits[i].name == NULL) {
		warnx("Bad pool name.");
		return (1);
	}

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set limit %s %d\n", opt, limit);

	return (0);
}

int
pfctl_load_limit(struct pfctl *pf, unsigned int index, unsigned int limit)
{
	struct pfioc_limit pl;

	memset(&pl, 0, sizeof(pl));
	pl.index = index;
	pl.limit = limit;
	if (ioctl(pf->dev, DIOCSETLIMIT, &pl)) {
		if (errno == EBUSY)
			warnx("Current pool size exceeds requested %s limit %u",
			    pf_limits[index].name, limit);
		else
			warnx("Cannot set %s limit to %u",
			    pf_limits[index].name, limit);
		return (1);
	}
	return (0);
}

int
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds, int quiet)
{
	int i;

	for (i = 0; pf_timeouts[i].name; i++) {
		if (strcasecmp(opt, pf_timeouts[i].name) == 0) {
			pf->timeout[pf_timeouts[i].timeout] = seconds;
			pf->timeout_set[pf_timeouts[i].timeout] = 1;
			break;
		}
	}

	if (pf_timeouts[i].name == NULL) {
		warnx("Bad timeout name.");
		return (1);
	}


	if (pf->opts & PF_OPT_VERBOSE && ! quiet)
		printf("set timeout %s %d\n", opt, seconds);

	return (0);
}

int
pfctl_load_timeout(struct pfctl *pf, unsigned int timeout, unsigned int seconds)
{
	struct pfioc_tm pt;

	memset(&pt, 0, sizeof(pt));
	pt.timeout = timeout;
	pt.seconds = seconds;
	if (ioctl(pf->dev, DIOCSETTIMEOUT, &pt)) {
		warnx("DIOCSETTIMEOUT");
		return (1);
	}
	return (0);
}

int
pfctl_set_reassembly(struct pfctl *pf, int on, int nodf)
{
	pf->reass_set = 1;
	if (on) {
		pf->reassemble = PF_REASS_ENABLED;
		if (nodf)
			pf->reassemble |= PF_REASS_NODF;
	} else {
		pf->reassemble = 0;
	}

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set reassemble %s %s\n", on ? "yes" : "no",
		    nodf ? "no-df" : "");

	return (0);
}

int
pfctl_set_optimization(struct pfctl *pf, const char *opt)
{
	const struct pf_hint *hint;
	int i, r;

	for (i = 0; pf_hints[i].name; i++)
		if (strcasecmp(opt, pf_hints[i].name) == 0)
			break;

	hint = pf_hints[i].hint;
	if (hint == NULL) {
		warnx("invalid state timeouts optimization");
		return (1);
	}

	for (i = 0; hint[i].name; i++)
		if ((r = pfctl_set_timeout(pf, hint[i].name,
		    hint[i].timeout, 1)))
			return (r);

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set optimization %s\n", opt);

	return (0);
}

int
pfctl_set_logif(struct pfctl *pf, char *ifname)
{
	if (!strcmp(ifname, "none")) {
		free(pf->ifname);
		pf->ifname = NULL;
	} else {
		pf->ifname = strdup(ifname);
		if (!pf->ifname)
			errx(1, "pfctl_set_logif: strdup");
	}
	pf->ifname_set = 1;

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set loginterface %s\n", ifname);

	return (0);
}

int
pfctl_load_logif(struct pfctl *pf, char *ifname)
{
	struct pfioc_iface	pi;

	memset(&pi, 0, sizeof(pi));
	if (ifname && strlcpy(pi.pfiio_name, ifname,
	    sizeof(pi.pfiio_name)) >= sizeof(pi.pfiio_name)) {
		warnx("pfctl_load_logif: strlcpy");
		return (1);
	}
	if (ioctl(pf->dev, DIOCSETSTATUSIF, &pi)) {
		warnx("DIOCSETSTATUSIF");
		return (1);
	}
	return (0);
}

void
pfctl_set_hostid(struct pfctl *pf, u_int32_t hostid)
{
	HTONL(hostid);

	pf->hostid = hostid;
	pf->hostid_set = 1;

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set hostid 0x%08x\n", ntohl(hostid));
}

int
pfctl_load_hostid(struct pfctl *pf, u_int32_t hostid)
{
	if (ioctl(dev, DIOCSETHOSTID, &hostid)) {
		warnx("DIOCSETHOSTID");
		return (1);
	}
	return (0);
}

int
pfctl_load_reassembly(struct pfctl *pf, u_int32_t reassembly)
{
	if (ioctl(dev, DIOCSETREASS, &reassembly)) {
		warnx("DIOCSETREASS");
		return (1);
	}
	return (0);
}

int
pfctl_set_debug(struct pfctl *pf, char *d)
{
	u_int32_t	level;
	int		loglevel;

	if ((loglevel = string_to_loglevel(d)) >= 0)
		level = loglevel;
	else {
		warnx("unknown debug level \"%s\"", d);
		return (-1);
	}
	pf->debug = level;
	pf->debug_set = 1;

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(dev, DIOCSETDEBUG, &level))
			err(1, "DIOCSETDEBUG");

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set debug %s\n", d);

	return (0);
}

int
pfctl_load_debug(struct pfctl *pf, unsigned int level)
{
	if (ioctl(pf->dev, DIOCSETDEBUG, &level)) {
		warnx("DIOCSETDEBUG");
		return (1);
	}
	return (0);
}

int
pfctl_set_interface_flags(struct pfctl *pf, char *ifname, int flags, int how)
{
	struct pfioc_iface	pi;

	bzero(&pi, sizeof(pi));

	pi.pfiio_flags = flags;

	if (strlcpy(pi.pfiio_name, ifname, sizeof(pi.pfiio_name)) >=
	    sizeof(pi.pfiio_name))
		errx(1, "pfctl_set_interface_flags: strlcpy");

	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (how == 0) {
			if (ioctl(pf->dev, DIOCCLRIFFLAG, &pi))
				err(1, "DIOCCLRIFFLAG");
		} else {
			if (ioctl(pf->dev, DIOCSETIFFLAG, &pi))
				err(1, "DIOCSETIFFLAG");
		}
	}
	return (0);
}

void
pfctl_debug(int dev, u_int32_t level, int opts)
{
	struct pfr_buffer t;

	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    ioctl(dev, DIOCSETDEBUG, &level) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_debug ioctl");

	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "debug level set to '%s'\n",
		    loglevel_to_string(level));
}

int
pfctl_show_anchors(int dev, int opts, char *anchorname)
{
	struct pfioc_ruleset	 pr;
	u_int32_t		 mnr, nr;

	memset(&pr, 0, sizeof(pr));
	memcpy(pr.path, anchorname, sizeof(pr.path));
	if (ioctl(dev, DIOCGETRULESETS, &pr)) {
		if (errno == EINVAL)
			fprintf(stderr, "Anchor '%s' not found.\n",
			    anchorname);
		else
			err(1, "DIOCGETRULESETS");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		char sub[PATH_MAX];

		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULESET, &pr))
			err(1, "DIOCGETRULESET");
		if (!strcmp(pr.name, PF_RESERVED_ANCHOR))
			continue;
		sub[0] = 0;
		if (pr.path[0]) {
			strlcat(sub, pr.path, sizeof(sub));
			strlcat(sub, "/", sizeof(sub));
		}
		strlcat(sub, pr.name, sizeof(sub));
		if (sub[0] != '_' || (opts & PF_OPT_VERBOSE))
			printf("  %s\n", sub);
		if ((opts & PF_OPT_VERBOSE) && pfctl_show_anchors(dev, opts, sub))
			return (-1);
	}
	return (0);
}

const char *
pfctl_lookup_option(char *cmd, const char **list)
{
	const char *item = NULL;
	if (cmd != NULL && *cmd)
		for (; *list; list++)
			if (!strncmp(cmd, *list, strlen(cmd))) {
				if (item == NULL)
					item = *list;
				else
					errx(1, "%s is ambigious", cmd);
			}

	return (item);
}


void
pfctl_state_store(int dev, const char *file)
{
	FILE *f;
	struct pfioc_states ps;
	char *inbuf = NULL, *newinbuf = NULL;
	unsigned int len = 0;
	size_t n;

	f = fopen(file, "w");
	if (f == NULL)
		err(1, "open: %s", file);

	memset(&ps, 0, sizeof(ps));
	for (;;) {
		ps.ps_len = len;
		if (len) {
			newinbuf = realloc(inbuf, len);
			if (newinbuf == NULL)
				err(1, "realloc");
			ps.ps_buf = inbuf = newinbuf;
		}
		if (ioctl(dev, DIOCGETSTATES, &ps) < 0)
			err(1, "DIOCGETSTATES");

		if (ps.ps_len + sizeof(struct pfioc_states) < len)
			break;
		if (len == 0 && ps.ps_len == 0)
			goto done;
		if (len == 0 && ps.ps_len != 0)
			len = ps.ps_len;
		if (ps.ps_len == 0)
			goto done;	/* no states */
		len *= 2;
	}

	n = ps.ps_len / sizeof(struct pfsync_state);
	if (fwrite(inbuf, sizeof(struct pfsync_state), n, f) < n)
		err(1, "fwrite");

done:
	free(inbuf);
	fclose(f);
}

void
pfctl_state_load(int dev, const char *file)
{
	FILE *f;
	struct pfioc_state ps;

	f = fopen(file, "r");
	if (f == NULL)
		err(1, "open: %s", file);

	while (fread(&ps.state, sizeof(ps.state), 1, f) == 1) {
		if (ioctl(dev, DIOCADDSTATE, &ps) < 0) {
			switch (errno) {
			case EEXIST:
			case EINVAL:
				break;
			default:
				err(1, "DIOCADDSTATE");
			}
		}
	}

	fclose(f);
}

int
main(int argc, char *argv[])
{
	int	 error = 0;
	int	 ch;
	int	 mode = O_RDONLY;
	int	 opts = 0;
	int	 optimize = PF_OPTIMIZE_BASIC;
	int	 level;
	int	 rdomain = 0;
	char	 anchorname[PATH_MAX];
	int	 anchor_wildcard = 0;
	char	*path;
	char	*lfile = NULL, *sfile = NULL;
	const char *errstr;
	long	 shownr = -1;

	if (argc < 2)
		usage();

	while ((ch = getopt(argc, argv,
	    "a:dD:eqf:F:ghi:k:K:L:no:Pp:R:rS:s:t:T:vV:x:z")) != -1) {
		switch (ch) {
		case 'a':
			anchoropt = optarg;
			break;
		case 'd':
			opts |= PF_OPT_DISABLE;
			mode = O_RDWR;
			break;
		case 'D':
			if (pfctl_cmdline_symset(optarg) < 0)
				warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'e':
			opts |= PF_OPT_ENABLE;
			mode = O_RDWR;
			break;
		case 'q':
			opts |= PF_OPT_QUIET;
			break;
		case 'F':
			clearopt = pfctl_lookup_option(optarg, clearopt_list);
			if (clearopt == NULL) {
				warnx("Unknown flush modifier '%s'", optarg);
				usage();
			}
			mode = O_RDWR;
			break;
		case 'i':
			ifaceopt = optarg;
			break;
		case 'k':
			if (state_killers >= 2) {
				warnx("can only specify -k twice");
				usage();
				/* NOTREACHED */
			}
			state_kill[state_killers++] = optarg;
			mode = O_RDWR;
			break;
		case 'K':
			if (src_node_killers >= 2) {
				warnx("can only specify -K twice");
				usage();
				/* NOTREACHED */
			}
			src_node_kill[src_node_killers++] = optarg;
			mode = O_RDWR;
			break;
		case 'n':
			opts |= PF_OPT_NOACTION;
			break;
		case 'r':
			opts |= PF_OPT_USEDNS;
			break;
		case 'R':
			shownr = strtonum(optarg, -1, LONG_MAX, &errstr);
			if (errstr) {
				warnx("invalid rule id: %s", errstr);
				usage();
			}
			break;
		case 'f':
			rulesopt = optarg;
			mode = O_RDWR;
			break;
		case 'g':
			opts |= PF_OPT_DEBUG;
			break;
		case 'o':
			optiopt = pfctl_lookup_option(optarg, optiopt_list);
			if (optiopt == NULL) {
				warnx("Unknown optimization '%s'", optarg);
				usage();
			}
			opts |= PF_OPT_OPTIMIZE;
			break;
		case 'P':
			opts |= PF_OPT_PORTNAMES;
			break;
		case 'p':
			pf_device = optarg;
			break;
		case 's':
			showopt = pfctl_lookup_option(optarg, showopt_list);
			if (showopt == NULL) {
				warnx("Unknown show modifier '%s'", optarg);
				usage();
			}
			break;
		case 't':
			tableopt = optarg;
			break;
		case 'T':
			tblcmdopt = pfctl_lookup_option(optarg, tblcmdopt_list);
			if (tblcmdopt == NULL) {
				warnx("Unknown table command '%s'", optarg);
				usage();
			}
			break;
		case 'v':
			if (opts & PF_OPT_VERBOSE)
				opts |= PF_OPT_VERBOSE2;
			opts |= PF_OPT_VERBOSE;
			break;
		case 'V':
			rdomain = strtonum(optarg, 0, RT_TABLEID_MAX, &errstr);
			if (errstr) {
				warnx("Invalid rdomain: %s", errstr);
				usage();
			}
			break;
		case 'x':
			debugopt = pfctl_lookup_option(optarg, debugopt_list);
			if (debugopt == NULL) {
				warnx("Unknown debug level '%s'", optarg);
				usage();
			}
			mode = O_RDWR;
			break;
		case 'z':
			opts |= PF_OPT_CLRRULECTRS;
			mode = O_RDWR;
			break;
		case 'S':
			sfile = optarg;
			break;
		case 'L':
			mode = O_RDWR;
			lfile = optarg;
			break;
		case 'h':
			/* FALLTHROUGH */
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (tblcmdopt != NULL) {
		argc -= optind;
		argv += optind;
		ch = *tblcmdopt;
		mode = strchr("acdefkrz", ch) ? O_RDWR : O_RDONLY;
	} else if (argc != optind) {
		warnx("unknown command line argument: %s ...", argv[optind]);
		usage();
		/* NOTREACHED */
	}

	if ((path = calloc(1, PATH_MAX)) == NULL)
		errx(1, "pfctl: calloc");
	memset(anchorname, 0, sizeof(anchorname));
	if (anchoropt != NULL) {
		int len = strlen(anchoropt);

		if (anchoropt[len - 1] == '*') {
			if (len >= 2 && anchoropt[len - 2] == '/') {
				anchoropt[len - 2] = '\0';
				anchor_wildcard = 1;
			} else
				anchoropt[len - 1] = '\0';
			opts |= PF_OPT_RECURSE;
		}
		if (strlcpy(anchorname, anchoropt,
		    sizeof(anchorname)) >= sizeof(anchorname))
			errx(1, "anchor name '%s' too long",
			    anchoropt);
	}

	if ((opts & PF_OPT_NOACTION) == 0) {
		dev = open(pf_device, mode);
		if (dev == -1)
			err(1, "%s", pf_device);
	} else {
		dev = open(pf_device, O_RDONLY);
		if (dev >= 0)
			opts |= PF_OPT_DUMMYACTION;
		/* turn off options */
		opts &= ~ (PF_OPT_DISABLE | PF_OPT_ENABLE);
		clearopt = showopt = debugopt = NULL;
	}

	if (opts & PF_OPT_DISABLE)
		if (pfctl_disable(dev, opts))
			error = 1;

	if (showopt != NULL) {
		switch (*showopt) {
		case 'A':
			pfctl_show_anchors(dev, opts, anchorname);
			break;
		case 'r':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_rules(dev, path, opts, PFCTL_SHOW_RULES,
			    anchorname, 0, anchor_wildcard, shownr);
			break;
		case 'l':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_rules(dev, path, opts, PFCTL_SHOW_LABELS,
			    anchorname, 0, anchor_wildcard, shownr);
			break;
		case 'q':
			pfctl_show_queues(dev, ifaceopt, opts,
			    opts & PF_OPT_VERBOSE2);
			break;
		case 's':
			pfctl_show_states(dev, ifaceopt, opts, shownr);
			break;
		case 'S':
			pfctl_show_src_nodes(dev, opts);
			break;
		case 'i':
			pfctl_show_status(dev, opts);
			break;
		case 't':
			pfctl_show_timeouts(dev, opts);
			break;
		case 'm':
			pfctl_show_limits(dev, opts);
			break;
		case 'a':
			opts |= PF_OPT_SHOWALL;
			pfctl_load_fingerprints(dev, opts);

			pfctl_show_rules(dev, path, opts, 0, anchorname,
			    0, 0, -1);
			pfctl_show_queues(dev, ifaceopt, opts,
			    opts & PF_OPT_VERBOSE2);
			pfctl_show_states(dev, ifaceopt, opts, -1);
			pfctl_show_src_nodes(dev, opts);
			pfctl_show_status(dev, opts);
			pfctl_show_rules(dev, path, opts, 1, anchorname,
			    0, 0, -1);
			pfctl_show_timeouts(dev, opts);
			pfctl_show_limits(dev, opts);
			pfctl_show_tables(anchorname, opts);
			pfctl_show_fingerprints(opts);
			break;
		case 'T':
			pfctl_show_tables(anchorname, opts);
			break;
		case 'o':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_fingerprints(opts);
			break;
		case 'I':
			pfctl_show_ifaces(ifaceopt, opts);
			break;
		}
	}

	if ((opts & PF_OPT_CLRRULECTRS) && showopt == NULL)
		pfctl_show_rules(dev, path, opts, PFCTL_SHOW_NOTHING,
		    anchorname, 0, 0, -1);

	if (clearopt != NULL) {
		if (anchorname[0] == '_' || strstr(anchorname, "/_") != NULL)
			errx(1, "anchor names beginning with '_' cannot "
			    "be modified from the command line");

		switch (*clearopt) {
		case 'r':
			pfctl_clear_rules(dev, opts, anchorname);
			break;
		case 's':
			pfctl_clear_states(dev, ifaceopt, opts);
			break;
		case 'S':
			pfctl_clear_src_nodes(dev, opts);
			break;
		case 'i':
			pfctl_clear_stats(dev, ifaceopt, opts);
			break;
		case 'a':
			pfctl_clear_rules(dev, opts, anchorname);
			pfctl_clear_tables(anchorname, opts);
			if (ifaceopt && *ifaceopt) {
				warnx("don't specify an interface with -Fall");
				usage();
				/* NOTREACHED */
			}
			if (!*anchorname) {
				pfctl_clear_states(dev, ifaceopt, opts);
				pfctl_clear_src_nodes(dev, opts);
				pfctl_clear_stats(dev, ifaceopt, opts);
				pfctl_clear_fingerprints(dev, opts);
				pfctl_clear_interface_flags(dev, opts);
			}
			break;
		case 'o':
			pfctl_clear_fingerprints(dev, opts);
			break;
		case 'T':
			pfctl_clear_tables(anchorname, opts);
			break;
		}
	}
	if (state_killers) {
		if (!strcmp(state_kill[0], "label"))
			pfctl_label_kill_states(dev, ifaceopt, opts, rdomain);
		else if (!strcmp(state_kill[0], "id"))
			pfctl_id_kill_states(dev, opts);
		else
			pfctl_net_kill_states(dev, ifaceopt, opts, rdomain);
	}

	if (src_node_killers)
		pfctl_kill_src_nodes(dev, ifaceopt, opts);

	if (tblcmdopt != NULL) {
		error = pfctl_command_tables(argc, argv, tableopt,
		    tblcmdopt, rulesopt, anchorname, opts);
		rulesopt = NULL;
	}
	if (optiopt != NULL) {
		switch (*optiopt) {
		case 'n':
			optimize = 0;
			break;
		case 'b':
			optimize |= PF_OPTIMIZE_BASIC;
			break;
		case 'o':
		case 'p':
			optimize |= PF_OPTIMIZE_PROFILE;
			break;
		}
	}

	if ((rulesopt != NULL) && !anchorname[0])
		if (pfctl_clear_interface_flags(dev, opts | PF_OPT_QUIET))
			error = 1;

	if (rulesopt != NULL && !anchorname[0])
		if (pfctl_file_fingerprints(dev, opts, PF_OSFP_FILE))
			error = 1;

	if (rulesopt != NULL) {
		if (anchorname[0] == '_' || strstr(anchorname, "/_") != NULL)
			errx(1, "anchor names beginning with '_' cannot "
			    "be modified from the command line");
		if (pfctl_rules(dev, rulesopt, opts, optimize,
		    anchorname, NULL))
			error = 1;
		else if (!(opts & PF_OPT_NOACTION))
			warn_namespace_collision(NULL);
	}

	if (opts & PF_OPT_ENABLE)
		if (pfctl_enable(dev, opts))
			error = 1;

	if (debugopt != NULL) {
		if ((level = string_to_loglevel((char *)debugopt)) < 0) {
			switch (*debugopt) {
			case 'n':
				level = LOG_CRIT;
				break;
			case 'u':
				level = LOG_ERR;
				break;
			case 'm':
				level = LOG_NOTICE;
				break;
			case 'l':
				level = LOG_DEBUG;
				break;
			}
		}
		if (level >= 0)
			pfctl_debug(dev, level, opts);
	}

	if (sfile != NULL)
		pfctl_state_store(dev, sfile);
	if (lfile != NULL)
		pfctl_state_load(dev, lfile);

	exit(error);
}
@


1.338
log
@Select the routing domain to be used for kill states by host or by
label, by adding a -V <rdomain> option.
written by Bertrand Provost, provost DOT bertrand AT gmail DOT com, thanks.
ok florian@@, with feedback from florian and jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.337 2016/09/03 21:30:49 jca Exp $ */
d756 1
a756 1
			errx(1, "pfctl_rules: calloc");
@


1.337
log
@err->errx, errno info is not related to the failure mode

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.336 2016/09/03 17:56:07 sashan Exp $ */
d72 3
a74 3
int	 pfctl_net_kill_states(int, const char *, int);
int	 pfctl_label_kill_states(int, const char *, int);
int	 pfctl_id_kill_states(int, const char *, int);
d234 1
a234 1
void
d246 1
a246 1
	fprintf(stderr, "\t[-x level]\n");
d515 1
a515 1
pfctl_net_kill_states(int dev, const char *iface, int opts)
d534 2
d623 1
a623 1
pfctl_label_kill_states(int dev, const char *iface, int opts)
d640 2
d652 1
a652 1
pfctl_id_kill_states(int dev, const char *iface, int opts)
d2114 1
d2126 1
a2126 1
	    "a:dD:eqf:F:ghi:k:K:L:no:Pp:R:rS:s:t:T:vx:z")) != -1) {
d2232 7
d2427 1
a2427 1
			pfctl_label_kill_states(dev, ifaceopt, opts);
d2429 1
a2429 1
			pfctl_id_kill_states(dev, ifaceopt, opts);
d2431 1
a2431 1
			pfctl_net_kill_states(dev, ifaceopt, opts);
@


1.336
log
@pfctl mixes up anchorname with anchorpath

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.334 2016/01/14 12:05:51 henning Exp $ */
d1080 1
a1080 1
				err(1, "pfctl_add_rule: bad anchor name %s",
d1490 1
a1490 1
			err(1, "pfctl_add_rule: bad anchor name %s",
@


1.335
log
@Let purge thread to remove once rules, not packets.
Thanks mikeb@@ for idea to add expire time.

OK mpi@@, OK mikeb@@
@
text
@a703 4

		if (rule->rule_flag & PFRULE_EXPIRED)
			printf("  [ Expired: %lld secs ago ]\n",
			    (long long)(time(NULL) - rule->exptime));
d851 1
a851 7
				/*
				 * Do not print newline, when we have not
				 * printed expired rule.
				 */
				if (!(pr.rule.rule_flag & PFRULE_EXPIRED) ||
				    (opts & (PF_OPT_VERBOSE2|PF_OPT_DEBUG)))
					printf("\n");
d1079 1
a1079 1
			if (!strlen(p))
d1345 1
a1345 1
		snprintf(&path[len], PATH_MAX - len, "%s", pf->anchor->name);
d1450 1
d1487 9
a1495 1
	if (strlcpy(pf.anchor->name, anchorname,
@


1.334
log
@detect multiple root queues on a single interface and give a nice error
message - beats "pfctl: DIOCXCOMMIT: Invalid argument".
from Nathanael Rensen <nathanael at list.polymorpheus.com>, 10x!
ok sthen phessler, commit reminder mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.333 2016/01/05 22:51:38 benno Exp $ */
d704 4
d855 7
a861 1
				printf("\n");
@


1.333
log
@remove long deprecated "set debug "none|urgent|misc|loud" levels in
pf.conf. Change this before upgrade or pf.conf won't load.
florian@@ henning@@ phessler@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.332 2015/12/10 17:27:00 mmcc Exp $ */
d1120 10
@


1.332
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.331 2015/10/02 15:32:17 krw Exp $ */
a222 1
	"none", "urgent", "misc", "loud",
d1885 1
a1885 9
	if (!strcmp(d, "none"))
		level = LOG_CRIT;
	else if (!strcmp(d, "urgent"))
		level = LOG_ERR;
	else if (!strcmp(d, "misc"))
		level = LOG_NOTICE;
	else if (!strcmp(d, "loud"))
		level = LOG_DEBUG;
	else if ((loglevel = string_to_loglevel(d)) >= 0)
@


1.331
log
@Make 'pfctl -s all' show queues. pfctl(8) says it does, and 5.4
pfctl(8) did for the old queues.

ok sashan@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.330 2015/06/12 16:10:43 mikeb Exp $ */
d1549 1
a1549 2
		if (path)
			free(path);
@


1.330
log
@Allow rule ID filter to be specified for show states output

Tweak pfctl to respect the rule ID parameter (-R) specified
along with the show states (-s states) option to filter out
states that are not associated with a given rule from the
output.

ok sthen, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.329 2015/01/16 06:40:00 deraadt Exp $ */
d2333 2
@


1.329
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.328 2014/12/10 13:59:29 bluhm Exp $ */
d87 1
a87 1
int	 pfctl_show_states(int, const char *, int);
d948 1
a948 1
pfctl_show_states(int dev, const char *iface, int opts)
d988 2
a989 1
		print_state(p, opts);
d2313 1
a2313 1
			pfctl_show_states(dev, ifaceopt, opts);
d2333 1
a2333 1
			pfctl_show_states(dev, ifaceopt, opts);
@


1.328
log
@If pfctl cannot set a limit in the kernel, print the name of the
limit and the requested value.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.327 2014/11/13 17:35:30 pelikan Exp $ */
d752 1
a752 1
		if ((npath = calloc(1, MAXPATHLEN)) == NULL)
d754 1
a754 1
		strlcpy(npath, anchorname, MAXPATHLEN);
d757 1
a757 1
			snprintf(&path[len], MAXPATHLEN - len, "/%s", anchorname);
d759 1
a759 1
			snprintf(&path[len], MAXPATHLEN - len, "%s", anchorname);
d1333 1
a1333 1
		snprintf(&path[len], MAXPATHLEN - len, "/%s", pf->anchor->name);
d1335 1
a1335 1
		snprintf(&path[len], MAXPATHLEN - len, "%s", pf->anchor->name);
d1399 1
a1399 1
				snprintf(&path[len], MAXPATHLEN - len,
d1402 1
a1402 1
				snprintf(&path[len], MAXPATHLEN - len,
d1458 1
a1458 1
	if ((path = calloc(1, MAXPATHLEN)) == NULL)
d1983 1
a1983 1
		char sub[MAXPATHLEN];
d2100 1
a2100 1
	char	 anchorname[MAXPATHLEN];
d2255 1
a2255 1
	if ((path = calloc(1, MAXPATHLEN)) == NULL)
@


1.327
log
@keep queues around when anchors are being loaded

ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.326 2014/08/23 00:11:03 pelikan Exp $ */
d1715 2
a1716 1
			warnx("Current pool size exceeds requested hard limit");
d1718 2
a1719 1
			warnx("cannot set '%s' limit", pf_limits[index].name);
@


1.326
log
@when you specify queues in a rule, make sure they have been defined.

DIOCADDRULE EBUSY turns into an error message that pfctl -n catches.
DIOCXCOMMIT EINVAL after the kernel rejected the rules was reported
to occur, possibly from hfsc.c: this should be fixed as well.

ok henning mikeb sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.325 2014/04/19 14:22:32 henning Exp $ */
d64 1
d1203 2
a1204 2
	while ((p = TAILQ_FIRST(&qi->children)) != NULL) {
		TAILQ_REMOVE(&qi->children, p, entries);
a1206 1
		free(p);
d1213 1
a1213 1
	struct pfctl_qsitem	*qi, rqi;
d1216 1
a1216 1
	while ((qi = TAILQ_FIRST(&qspecs)) != NULL) {
a1225 3

		TAILQ_REMOVE(&qspecs, qi, entries);
		free(qi);
d1230 2
a1231 1
	while ((qi = TAILQ_FIRST(&rootqs)) != NULL) {
d1250 1
d1256 12
d1524 2
a1525 2
	/* process "load anchor" directives */
	if (!anchorname[0])
d1528 3
@


1.325
log
@remove altq bits here, too
(i was convinced i committed that yesterday already, hrm)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.324 2014/04/11 02:56:41 jsg Exp $ */
d230 4
a1110 3
TAILQ_HEAD(qspecs, pfctl_qsitem) qspecs = TAILQ_HEAD_INITIALIZER(qspecs);
TAILQ_HEAD(rootqs, pfctl_qsitem) rootqs = TAILQ_HEAD_INITIALIZER(rootqs);

d1134 12
d1160 1
a1160 5
		/* check wether a children with that name is already there */
		TAILQ_FOREACH(q, &qi->children, entries)
			if (!strcmp(q->qs.qname, p->qs.qname))
				break;
		if (q == NULL) {
@


1.324
log
@fix a use after free in an error path
ok henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.323 2014/02/28 22:18:23 mikeb Exp $ */
a42 1
#include <altq/altq.h>
a66 1
int	 pfctl_clear_altq(int, int);
a90 1
int	 pfctl_test_altqsupport(int, int);
a120 2
int		 loadaltq = 1;
int		 altqsupport;
d205 1
a205 2
	"queue", "rules", "Sources",
	"states", "info", "Tables", "osfp", "all", NULL
a257 4
	if (altqsupport && ioctl(dev, DIOCSTARTALTQ))
		if (errno != EEXIST)
			err(1, "DIOCSTARTALTQ");

a272 4
	if (altqsupport && ioctl(dev, DIOCSTOPALTQ))
			if (errno != ENOENT)
				err(1, "DIOCSTOPALTQ");

a330 17
pfctl_clear_altq(int dev, int opts)
{
	struct pfr_buffer t;
	if (!altqsupport)
		return (-1);
	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_TRANS_ALTQ, "") ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_altq");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "altq cleared\n");
	return (0);
}

int
a1096 4
	if (a == pf->astack[0] && (altqsupport && loadaltq)) {
		if (pfctl_add_trans(pf->trans, PF_TRANS_ALTQ, path))
			return (2);
	}
a1407 21
pfctl_add_altq(struct pfctl *pf, struct pf_altq *a)
{
	if (altqsupport) {
		memcpy(&pf->paltq->altq, a, sizeof(struct pf_altq));
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCADDALTQ, pf->paltq)) {
				if (errno == ENXIO)
					errx(1, "qtype not configured");
				else if (errno == ENODEV)
					errx(1, "%s: driver does not support "
					    "altq", a->ifname);
				else
					err(1, "DIOCADDALTQ");
			}
		}
		pfaltq_store(&pf->paltq->altq);
	}
	return (0);
}

int
a1414 1
	struct pfioc_altq	 pa;
a1435 1
	memset(&pa, 0, sizeof(pa));
a1445 2
	if (anchorname[0])
		loadaltq = 0;
a1462 1
	pf.paltq = &pa;
a1473 3
		if (altqsupport && loadaltq)
			pa.ticket =
			    pfctl_get_ticket(t, PF_TRANS_ALTQ, anchorname);
a1503 3
	if (altqsupport && loadaltq && check_commit_altq(dev, opts) != 0)
		ERRX("errors in altq config");

a1940 17
pfctl_test_altqsupport(int dev, int opts)
{
	struct pfioc_altq pa;

	if (ioctl(dev, DIOCGETALTQS, &pa)) {
		if (errno == ENODEV) {
			if (!(opts & PF_OPT_QUIET))
				fprintf(stderr, "No ALTQ support in kernel\n"
				    "ALTQ related functions disabled\n");
			return (0);
		} else
			err(1, "DIOCGETALTQS");
	}
	return (1);
}

int
a2253 1
		altqsupport = pfctl_test_altqsupport(dev, opts);
a2260 1
		altqsupport = 1;
a2284 2
			pfctl_show_altq(dev, ifaceopt, opts,
			    opts & PF_OPT_VERBOSE2);
a2306 1
			pfctl_show_altq(dev, ifaceopt, opts, 0);
a2342 3
		case 'q':
			pfctl_clear_altq(dev, opts);
			break;
a2360 1
				pfctl_clear_altq(dev, opts);
@


1.323
log
@Bring back the code removed in rev1.317 used to print anchors with
wildcard path ("ftp-proxy/*"), but make sure to call it after we're
done with the ruleset for the current anchor.  On one hand this
repairs printing content of such anchors and on the other it allows
to use a wildcard on the command line for anchors that were not
initially specified with a wildcard.  Makes pfctl regress happy
again.  OK henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.322 2014/02/17 04:52:25 lteo Exp $ */
d1566 1
@


1.322
log
@Remove a stray debug printf that crept in via one of the newqueue
commits.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.321 2013/11/01 22:55:39 pelikan Exp $ */
d832 4
d885 34
@


1.321
log
@keep net/hfsc.h away from userspace, except in pfctl

tested by naddy, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.320 2013/10/17 19:59:54 henning Exp $ */
a1957 1
printf("pfctl_debug DIOCXCOMMIT\n");
@


1.320
log
@cannot have queue definitions inside anchors.
don't attempt to load them and err out if we run into one
ran into by Gregor Best <gbe@@@@ring0.de>, analysis & fix your's truly
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.319 2013/10/12 12:16:11 henning Exp $ */
d44 1
@


1.319
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.318 2013/10/09 02:59:27 lteo Exp $ */
d1111 5
d1511 2
a1512 2
	if (pfctl_check_qassignments(&pf.anchor->ruleset) ||
	    pfctl_load_queues(&pf)) {
@


1.318
log
@Make sure that pfctl_state_store() frees the inbuf pointer and closes
the state file before returning.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.317 2013/08/12 17:42:08 mikeb Exp $ */
d5 1
a5 1
 * Copyright (c) 2002,2003 Henning Brauer
d95 5
a346 1

d1103 190
d1506 8
d1952 1
d2325 2
@


1.317
log
@Remove duplicate and incorrect recursive anchor printing code
and instead rely on the one provided by the same function just
a few lines below.

ok lteo henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.316 2013/08/02 08:33:11 mikeb Exp $ */
d1861 1
a1861 1
			return;
d1865 1
a1865 1
			return; /* no states */
d1873 2
@


1.316
log
@Remove an incorrect call to pfctl_print_rule_counters when trying to
print out anchor rules recursively;  unbreaks pf1.loaded regress test.
ok lteo, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.315 2013/03/21 00:54:33 deraadt Exp $ */
a783 34
	/*
	 * If this anchor was called with a wildcard path, go through
	 * the rulesets in the anchor rather than the rules.
	 */
	if (wildcard && (opts & PF_OPT_RECURSE)) {
		struct pfioc_ruleset	 prs;
		u_int32_t		 mnr, nr;

		memset(&prs, 0, sizeof(prs));
		memcpy(prs.path, npath, sizeof(prs.path));
		if (ioctl(dev, DIOCGETRULESETS, &prs)) {
			if (errno == EINVAL)
				fprintf(stderr, "Anchor '%s' "
				    "not found.\n", anchorname);
			else
				err(1, "DIOCGETRULESETS");
		}
		mnr = prs.nr;

		for (nr = 0; nr < mnr; ++nr) {
			prs.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &prs))
				err(1, "DIOCGETRULESET");
			INDENT(depth, !(opts & PF_OPT_VERBOSE));
			printf("anchor \"%s\" all {\n", prs.name);
			pfctl_show_rules(dev, npath, opts,
			    format, prs.name, depth + 1, 0, shownr);
			INDENT(depth, !(opts & PF_OPT_VERBOSE));
			printf("}\n");
		}
		path[len] = '\0';
		return (0);
	}

d853 3
a855 3
			 * If this is a 'unnamed' brace notation
			 * anchor, OR the user has explicitly requested
			 * recursion, print it recursively.
d2112 1
a2112 5
			    anchorname, 0, 0, shownr);
			if (anchor_wildcard)
				pfctl_show_rules(dev, path, opts,
				    PFCTL_SHOW_RULES, anchorname, 0,
				    anchor_wildcard, shownr);
d2117 1
a2117 5
			    anchorname, 0, 0, shownr);
			if (anchor_wildcard)
				pfctl_show_rules(dev, path, opts,
				    PFCTL_SHOW_LABELS, anchorname, 0,
				    anchor_wildcard, shownr);
@


1.315
log
@fetch NMBCLUSTERS at runtime from the sysctl kern.maxclusters
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.314 2012/09/19 15:52:17 camield Exp $ */
a802 1
		pfctl_print_rule_counters(&pr.rule, opts);
@


1.314
log
@Show which limit cannot be set.  idea mikeb

ok mikeb henning beck
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.313 2012/07/26 11:48:00 mikeb Exp $ */
d1414 1
a1414 1
	int mib[2];
d1439 8
a1446 1
	pf->limit[PF_LIMIT_FRAGS] = PFFRAG_FRENT_HIWAT;
@


1.313
log
@load os passive fingerprints when testing the ruleset; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.312 2012/05/07 11:55:34 henning Exp $ */
d1542 1
a1542 1
			warnx("DIOCSETLIMIT");
@


1.312
log
@fix printing of wildcard anchors, from lteo, ok phessler sthen me
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.311 2012/05/02 14:23:49 henning Exp $ */
d2290 1
a2290 1
	if (rulesopt != NULL && !(opts & PF_OPT_NOACTION) && !anchorname[0])
@


1.311
log
@remove redundant check; from lteo; ok haesbaert
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.310 2012/04/18 14:42:17 deraadt Exp $ */
d865 1
d1939 1
d2100 1
a2100 1
			if (len >= 2 && anchoropt[len - 2] == '/')
d2102 2
a2103 1
			else
d2141 4
d2150 4
@


1.310
log
@not (unsigned); ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.309 2012/01/15 15:59:33 dhill Exp $ */
a827 2
	}
	if (opts & PF_OPT_SHOWALL) {
@


1.309
log
@convert an snprintf to strlcpy

ok mikeb henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.308 2011/12/03 12:46:16 mcbride Exp $ */
d736 1
a736 1
			printf("  [ Inserted: uid %u pid %u "
d738 1
a738 1
			    (unsigned)rule->cuid, (unsigned)rule->cpid,
@


1.308
log
@pfctl_set_hostid always returns 0; don't pretend otherwise and make it a
void function instead.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.307 2011/12/03 12:44:56 mcbride Exp $ */
d775 1
a775 1
		snprintf(npath, MAXPATHLEN, anchorname);
@


1.307
log
@Avoid loading garbage hostid and other values not always initialised,
by bzero()ing the 'struct pfsync' properly.

ok dlg mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.306 2011/11/23 10:24:37 henning Exp $ */
d1672 1
a1672 1
int
a1681 2

	return (0);
@


1.306
log
@print ports as numbers by default; -P prints names instead
2/2 from Lawrence Teo <lteo at devio dot us>
ok sthen dlg and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.305 2011/11/08 19:17:07 mikeb Exp $ */
d1276 1
@


1.305
log
@Fixup skip step printout: rdomains come after direction;  ok mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.304 2011/07/08 02:16:12 mcbride Exp $ */
d235 1
a235 1
	fprintf(stderr, "usage: %s [-deghnqrvz] ", __progname);
a757 1
	int rule_numbers = opts & (PF_OPT_VERBOSE2 | PF_OPT_DEBUG);
d886 1
a886 1
			print_rule(&pr.rule, pr.anchor_call, rule_numbers);
d1234 1
a1234 1
		print_rule(r, name, pf->opts & PF_OPT_VERBOSE2);
d1950 1
a1950 1
	    "a:dD:eqf:F:ghi:k:K:L:no:p:R:rS:s:t:T:vx:z")) != -1) {
d2027 3
@


1.304
log
@Correctly print skip steps in -vv mode
- Did not include PF_SKIP_RDOM
- Changed order of address and ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.303 2010/10/01 12:33:14 reyk Exp $ */
d708 1
a708 1
		const char *t[PF_SKIP_COUNT] = { "i", "r", "d", "f",
@


1.303
log
@Add the -R id option to pfctl that allows to show only a specified rule
by numeric ID in combination with the "-s rules" or "-s labels" options.
For example, this allows you to dump the statistics of a specified rule
only (pfctl -sr -v -R 0).

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.302 2010/09/02 14:01:04 sobrado Exp $ */
d708 2
a709 2
		const char *t[PF_SKIP_COUNT] = { "i", "d", "f",
		    "p", "sa", "sp", "da", "dp" };
@


1.302
log
@remove trailing spaces and tabs; no binary change.

written with help from henning@@, who suggested ensuring that there
are no changes in the digests for object files, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.301 2010/08/11 10:03:29 jsg Exp $ */
d84 2
a85 1
int	 pfctl_show_rules(int, char *, int, enum pfctl_show, char *, int, int);
d240 1
a240 1
	fprintf(stderr, "\t[-S statefile] [-s modifier] ");
d754 1
a754 1
    char *anchorname, int depth, int wildcard)
d812 1
a812 1
			    format, prs.name, depth + 1, 0);
d845 13
a857 2
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
d902 1
a902 1
				    pr.rule.anchor_wildcard);
d1944 2
d1951 1
a1951 1
	    "a:dD:eqf:F:ghi:k:K:L:no:p:rS:s:t:T:vx:z")) != -1) {
d2007 7
d2138 1
a2138 1
			    anchorname, 0, 0);
d2143 1
a2143 1
			    anchorname, 0, 0);
d2168 2
a2169 1
			pfctl_show_rules(dev, path, opts, 0, anchorname, 0, 0);
d2174 2
a2175 1
			pfctl_show_rules(dev, path, opts, 1, anchorname, 0, 0);
d2196 1
a2196 1
		    anchorname, 0, 0);
@


1.301
log
@Fix a logic problem which could in theory cause pfctl
to recursively print anchors with wildcards when not
requested via the command line but in practice only
applied to automatically generated inline anchors
(which don't have wildcards) or when recursion
was requested.

Found by the clang static analyser and behaviour explained
by mcbride@@

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.300 2010/07/03 02:28:57 mcbride Exp $ */
d672 1
a672 1
	
d765 1
a765 1
	 */ 
d1075 1
a1075 1
		/* 
d1080 1
a1080 1
		
d1439 1
a1439 1
		pf->limit[PF_LIMIT_TABLE_ENTRIES] = PFR_KENTRY_HIWAT_SMALL; 
d1915 1
a1915 1
	} 
@


1.300
log
@Fix a couple of problems with printing of anchors, in particular recursive
printing, both of inline anchors and when requested explicitly with a '*'
in the anchor.
- Correct recursive printing of wildcard anchors (recurse into child anchors
  rather than rules, which don't exist)
- Print multi-part anchor paths correctly (pr6065)
- Fix comments and prevent users from specifying multi-component names for
  inline anchors.

tested by phessler
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.298 2010/06/28 23:21:41 mcbride Exp $ */
d788 1
a788 1
	if (wildcard && PF_OPT_RECURSE) {
@


1.299
log
@Fix 'pfctl -a anchor -Fa' segfault introduced in r1.298.
ok mcbride
@
text
@d84 1
a84 1
int	 pfctl_show_rules(int, char *, int, enum pfctl_show, char *, int);
d753 1
a753 1
    char *anchorname, int depth)
d758 2
a759 3
	int len = strlen(path);
	int brace;
	char *p;
d761 9
a769 4
	if (path[0])
		snprintf(&path[len], MAXPATHLEN - len, "/%s", anchorname);
	else
		snprintf(&path[len], MAXPATHLEN - len, "%s", anchorname);
d772 48
a819 1
	memcpy(pr.anchor, path, sizeof(pr.anchor));
d824 1
d841 1
d849 1
a871 1
			brace = 0;
d875 11
a885 15
			if (pr.anchor_call[0] &&
			   ((((p = strrchr(pr.anchor_call, '_')) != NULL) &&
			   ((void *)p == (void *)pr.anchor_call ||
			   *(--p) == '/')) || (opts & PF_OPT_RECURSE))) {
				brace++;
				if ((p = strrchr(pr.anchor_call, '/')) !=
				    NULL)
					p++;
				else
					p = &pr.anchor_call[0];
			} else
				p = &pr.anchor_call[0];
		
			print_rule(&pr.rule, p, rule_numbers);
			if (brace)
d887 4
a890 6
			else
				printf("\n");
			pfctl_print_rule_counters(&pr.rule, opts);
			if (brace) { 
				pfctl_show_rules(dev, path, opts, format,
				    p, depth + 1);
d893 3
a901 2
	path[len] = '\0';
	return (0);
d904 2
d907 1
a907 1
	return (-1);
d1206 1
a1206 1
			name = path;
d1223 1
a1223 2
		print_rule(r, r->anchor ? r->anchor->name : "",
		    pf->opts & PF_OPT_VERBOSE2);
d2117 1
a2117 1
			    anchorname, 0);
d2122 1
a2122 1
			    anchorname, 0);
d2147 1
a2147 1
			pfctl_show_rules(dev, path, opts, 0, anchorname, 0);
d2152 1
a2152 1
			pfctl_show_rules(dev, path, opts, 1, anchorname, 0);
d2173 1
a2173 1
		    anchorname, 0);
@


1.298
log
@Clean up iterface stats handling:
- 'make -Fi' reset ALL the interface statistics
     can be restricted with -i ifname
- 'make -Fa -i ifname' fail (it's meaningless)
- get rid of a silly little struct that's only used for one thing

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.297 2010/06/25 23:27:47 henning Exp $ */
d2150 1
a2150 1
			if (*ifaceopt) {
@


1.297
log
@remove -m (merge).
it is violating the transactional model we have and made stronger in
pf, it is broken in some cases and since some options are passed to the
kernel while some are userland only and affect how the rules are
parsed it is complete bullshit anyway - obviously, changing options
that affect ruleset parsing without reloading and thus reparsing the
ruleset cannot work. so stop pretending it could and cut the crap.
ok dlg krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.296 2010/04/02 09:48:48 sthen Exp $ */
d64 1
a64 1
int	 pfctl_clear_stats(int, int);
d284 1
a284 1
pfctl_clear_stats(int dev, int opts)
d286 8
a293 1
	if (ioctl(dev, DIOCCLRSTATUS))
d295 6
a300 2
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf: statistics cleared\n");
d1596 1
a1596 1
	struct pfioc_if pi;
d1599 2
a1600 2
	if (ifname && strlcpy(pi.ifname, ifname,
	    sizeof(pi.ifname)) >= sizeof(pi.ifname)) {
d2145 1
a2145 1
			pfctl_clear_stats(dev, opts);
d2150 5
d2159 1
a2159 1
				pfctl_clear_stats(dev, opts);
@


1.296
log
@Use a dedicated variable to prevent attempting to open multiple
ALTQ transactions when anchors are loaded.

Fixes pfctl when using 'load anchor ... from' as seen by beck@@
and Toni Mueller, which stopped working after r1.295 removed loadopt
(which was overloaded to do this job as well as indicate command-
line flags).

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.295 2010/03/23 13:31:29 henning Exp $ */
d234 1
a234 1
	fprintf(stderr, "usage: %s [-deghmnqrvz] ", __progname);
d1392 1
a1392 3
	for (i = 0; i < PF_LIMIT_MAX; i++) {
		if ((pf->opts & PF_OPT_MERGE) && !pf->limit_set[i])
			continue;
a1394 1
	}
d1412 1
a1412 3
	for (i = 0; i < PFTM_MAX; i++) {
		if ((pf->opts & PF_OPT_MERGE) && !pf->timeout_set[i])
			continue;
a1414 1
	}
d1417 2
a1418 3
	if (!(pf->opts & PF_OPT_MERGE) || pf->debug_set)
		if (pfctl_load_debug(pf, pf->debug))
			error = 1;
d1421 2
a1422 3
	if (!(pf->opts & PF_OPT_MERGE) || pf->ifname_set)
		if (pfctl_load_logif(pf, pf->ifname))
			error = 1;
d1425 2
a1426 3
	if (!(pf->opts & PF_OPT_MERGE) || pf->hostid_set)
		if (pfctl_load_hostid(pf, pf->hostid))
			error = 1;
d1429 2
a1430 3
	if (!(pf->opts & PF_OPT_MERGE) || pf->reass_set)
		if (pfctl_load_reassembly(pf, pf->reassemble))
			error = 1;
d1877 1
a1877 1
	    "a:dD:eqf:F:ghi:k:K:L:mno:p:rS:s:t:T:vx:z")) != -1) {
a1926 3
		case 'm':
			opts |= PF_OPT_MERGE;
			break;
d2192 1
a2192 2
	if (rulesopt != NULL && !(opts & (PF_OPT_MERGE|PF_OPT_NOACTION)) &&
	    !anchorname[0])
@


1.295
log
@remove -A, -O, -R and -T load
the partial loading of a ruleset (leaving ancors aside) is wrong and
conflicts with the general idea of how pf works. last not least it breaks
with the optimizer generating tables automagically.
ok deraadt sthen krw manpage jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.294 2010/01/18 23:52:46 mcbride Exp $ */
d117 1
d1049 1
a1049 1
	if (a == pf->astack[0] && altqsupport) {
d1230 2
d1261 1
a1261 1
		if (altqsupport)
d1285 1
a1285 1
	if (altqsupport && check_commit_altq(dev, opts) != 0)
@


1.294
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.293 2010/01/13 01:41:58 jsg Exp $ */
a116 1
int		 loadopt;
d213 1
a213 1
	"kill", "flush", "add", "delete", "load", "replace", "show",
d233 1
a233 1
	fprintf(stderr, "usage: %s [-AdeghmnOqRrvz] ", __progname);
d1048 1
a1048 2
	if (a == pf->astack[0] && ((altqsupport &&
	     (pf->loadopt & PFCTL_FLAG_ALTQ) != 0))) {
d1052 4
a1055 7
	if ((pf->loadopt & PFCTL_FLAG_FILTER) != 0) {
		if (pfctl_add_trans(pf->trans, PF_TRANS_RULESET, path))
			return (3);
	}
	if (pf->loadopt & PFCTL_FLAG_TABLE)
		if (pfctl_add_trans(pf->trans, PF_TRANS_TABLE, path))
			return (4);
d1171 1
a1171 2
	if (altqsupport &&
	    (loadopt & PFCTL_FLAG_ALTQ) != 0) {
a1228 1
	pf.loadopt = loadopt;
a1245 2
	if (anchorname[0])
		pf.loadopt &= ~PFCTL_FLAG_ALTQ;
d1258 1
a1258 1
		if (altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ))
d1261 2
a1262 3
		if (pf.loadopt & PFCTL_FLAG_TABLE)
			pf.astack[0]->ruleset.tticket =
			    pfctl_get_ticket(t, PF_TRANS_TABLE, anchorname);
d1273 1
a1273 2
	if ((pf.loadopt & PFCTL_FLAG_FILTER &&
	    pfctl_load_ruleset(&pf, path, rs, 0))) {
d1282 2
a1283 3
	if ((altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ) != 0))
		if (check_commit_altq(dev, opts) != 0)
			ERRX("errors in altq config");
a1387 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1488 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1526 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1548 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1572 4

	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1609 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1646 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

a1688 3
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);

d1884 1
a1884 1
	    "a:AdD:eqf:F:ghi:k:K:L:mnOo:p:rRS:s:t:T:vx:z")) != -1) {
a1949 6
		case 'A':
			loadopt |= PFCTL_FLAG_ALTQ;
			break;
		case 'R':
			loadopt |= PFCTL_FLAG_FILTER;
			break;
a1957 3
		case 'O':
			loadopt |= PFCTL_FLAG_OPTION;
			break;
d2014 1
a2014 5
		if (ch == 'l') {
			loadopt |= PFCTL_FLAG_TABLE;
			tblcmdopt = NULL;
		} else
			mode = strchr("acdefkrz", ch) ? O_RDWR : O_RDONLY;
a2019 2
	if (loadopt == 0)
		loadopt = ~0;
a2037 1
		loadopt &= PFCTL_FLAG_FILTER|PFCTL_FLAG_TABLE;
d2198 1
a2198 2
	if ((rulesopt != NULL) && (loadopt & PFCTL_FLAG_OPTION) &&
	    !anchorname[0])
d2203 1
a2203 1
	    !anchorname[0] && (loadopt & PFCTL_FLAG_OPTION))
d2214 1
a2214 2
		else if (!(opts & PF_OPT_NOACTION) &&
		    (loadopt & PFCTL_FLAG_TABLE))
@


1.293
log
@fix some leaks found by parfait
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.292 2010/01/12 03:20:51 mcbride Exp $ */
d56 2
d219 4
a222 1
	"none", "urgent", "misc", "loud", NULL
d1390 2
a1391 1
	pf->debug = PF_DEBUG_URGENT;
d1676 1
d1682 1
a1682 1
		pf->debug = PF_DEBUG_NONE;
d1684 1
a1684 1
		pf->debug = PF_DEBUG_URGENT;
d1686 1
a1686 1
		pf->debug = PF_DEBUG_MISC;
d1688 3
a1690 1
		pf->debug = PF_DEBUG_NOISY;
d1695 1
a1695 1

d1758 3
a1760 21
	if ((opts & PF_OPT_QUIET) == 0) {
		fprintf(stderr, "debug level set to '");
		switch (level) {
		case PF_DEBUG_NONE:
			fprintf(stderr, "none");
			break;
		case PF_DEBUG_URGENT:
			fprintf(stderr, "urgent");
			break;
		case PF_DEBUG_MISC:
			fprintf(stderr, "misc");
			break;
		case PF_DEBUG_NOISY:
			fprintf(stderr, "loud");
			break;
		default:
			fprintf(stderr, "<invalid>");
			break;
		}
		fprintf(stderr, "'\n");
	}
d1822 1
d1825 8
a1832 3
			if (!strncmp(cmd, *list, strlen(cmd)))
				return (*list);
	return (NULL);
d1912 1
d2278 15
a2292 13
		switch (*debugopt) {
		case 'n':
			pfctl_debug(dev, PF_DEBUG_NONE, opts);
			break;
		case 'u':
			pfctl_debug(dev, PF_DEBUG_URGENT, opts);
			break;
		case 'm':
			pfctl_debug(dev, PF_DEBUG_MISC, opts);
			break;
		case 'l':
			pfctl_debug(dev, PF_DEBUG_NOISY, opts);
			break;
d2294 2
@


1.292
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.291 2009/12/10 15:57:20 deraadt Exp $ */
d1285 2
@


1.291
log
@plug some memory leaks; found by parfait, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.290 2009/11/22 22:34:50 henning Exp $ */
a80 2
int	 pfctl_get_pool(int, struct pf_pool *, u_int32_t, u_int32_t, int,
	    char *, int);
a686 58
int
pfctl_get_pool(int dev, struct pf_pool *pool, u_int32_t nr,
    u_int32_t ticket, int r_action, char *anchorname, int which)
{
	struct pfioc_pooladdr pp;
	struct pf_pooladdr *pa;
	u_int32_t pnr, mpnr;

	memset(&pp, 0, sizeof(pp));
	memcpy(pp.anchor, anchorname, sizeof(pp.anchor));
	pp.r_action = r_action;
	pp.r_num = nr;
	pp.ticket = ticket;
	pp.which = which;
	if (ioctl(dev, DIOCGETADDRS, &pp)) {
		warn("DIOCGETADDRS");
		return (-1);
	}
	mpnr = pp.nr;
	TAILQ_INIT(&pool->list);
	for (pnr = 0; pnr < mpnr; ++pnr) {
		pp.nr = pnr;
		if (ioctl(dev, DIOCGETADDR, &pp)) {
			warn("DIOCGETADDR");
			return (-1);
		}
		pa = calloc(1, sizeof(struct pf_pooladdr));
		if (pa == NULL)
			err(1, "calloc");
		bcopy(&pp.addr, pa, sizeof(struct pf_pooladdr));
		TAILQ_INSERT_TAIL(&pool->list, pa, entries);
	}

	return (0);
}

void
pfctl_move_pool(struct pf_pool *src, struct pf_pool *dst)
{
	struct pf_pooladdr *pa;

	while ((pa = TAILQ_FIRST(&src->list)) != NULL) {
		TAILQ_REMOVE(&src->list, pa, entries);
		TAILQ_INSERT_TAIL(&dst->list, pa, entries);
	}
}

void
pfctl_clear_pool(struct pf_pool *pool)
{
	struct pf_pooladdr *pa;

	while ((pa = TAILQ_FIRST(&pool->list)) != NULL) {
		TAILQ_REMOVE(&pool->list, pa, entries);
		free(pa);
	}
}

a782 10
		if (pfctl_get_pool(dev, &pr.rule.rdr,
		    nr, pr.ticket, PF_PASS, path, PF_RDR) != 0)
			goto error;
		if (pfctl_get_pool(dev, &pr.rule.nat,
		    nr, pr.ticket, PF_PASS, path, PF_NAT) != 0)
			goto error;
		if (pfctl_get_pool(dev, &pr.rule.route,
		    nr, pr.ticket, PF_PASS, path, PF_RT) != 0)
			goto error;

a834 3
		pfctl_clear_pool(&pr.rule.rdr);
		pfctl_clear_pool(&pr.rule.nat);
		pfctl_clear_pool(&pr.rule.route);
a1000 15
pfctl_add_pool(struct pfctl *pf, struct pf_pool *p, sa_family_t af, int which)
{
	struct pf_pooladdr *pa;

	pf->paddr.af = af;
	TAILQ_FOREACH(pa, &p->list, entries) {
		pf->paddr.which = which;
		memcpy(&pf->paddr.addr, pa, sizeof(struct pf_pooladdr));
		if (ioctl(pf->dev, DIOCADDADDR, &pf->paddr))
			err(1, "DIOCADDADDR");
	}
	return (0);
}

int
a1033 6
	TAILQ_INIT(&rule->rdr.list);
	pfctl_move_pool(&r->rdr, &rule->rdr);
	TAILQ_INIT(&rule->nat.list);
	pfctl_move_pool(&r->nat, &rule->nat);
	TAILQ_INIT(&rule->route.list);
	pfctl_move_pool(&r->route, &rule->route);
a1150 9
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr))
			err(1, "DIOCBEGINADDRS");
		if (pfctl_add_pool(pf, &r->rdr, r->af, PF_RDR))
			return (1);
		if (pfctl_add_pool(pf, &r->nat, r->af, PF_NAT))
			return (1);
		if (pfctl_add_pool(pf, &r->route, r->af, PF_RT))
			return (1);
		pr.pool_ticket = pf->paddr.ticket;
a1164 2
	pfctl_clear_pool(&r->rdr);
	pfctl_clear_pool(&r->nat);
@


1.290
log
@cleanup after the NAT changes. we used to have multiple rulesets (scrub,
NAT, filter). now we only have one. no need for an array any more. simplifies
the code quite a bit.
in the process fix the abuse of PF_RULESET_* by (surprise, isn't it) the
table code.
written at the filesystem hackathon in stockholm, committed from the
hardware hackathon in portugal. ok gcc and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.289 2009/10/28 20:11:01 jsg Exp $ */
d1307 1
a1307 1
	char			*path;
d1416 2
@


1.289
log
@Add a dedicated pf pool for route options as suggested by henning,
which unbreaks ie route-to after the recent pf changes.

With much help debugging and pointing out of missing bits from claudio@@

ok claudio@@ "looks good" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.288 2009/09/29 12:54:14 jmc Exp $ */
d94 1
a94 2
int	 pfctl_load_ruleset(struct pfctl *, char *,
		struct pf_ruleset *, int, int);
d314 1
a314 1
	if (pfctl_add_trans(&t, PF_RULESET_FILTER, anchorname) ||
d332 1
a332 1
	if (pfctl_add_trans(&t, PF_RULESET_ALTQ, "") ||
a1090 1
	u_int8_t		rs_num;
a1094 5
	rs_num = pf_get_ruleset_number(r->action == PF_MATCH ? PF_PASS :
	    r->action);
	if (rs_num == PF_RULESET_MAX)
		errx(1, "Invalid rule type %d", r->action);

a1095 1

d1129 1
a1129 1
	TAILQ_INSERT_TAIL(rs->rules[rs_num].active.ptr, rule, entries);
d1140 1
a1140 1
		if (pfctl_add_trans(pf->trans, PF_RULESET_ALTQ, path))
d1144 1
a1144 1
		if (pfctl_add_trans(pf->trans, PF_RULESET_FILTER, path))
d1148 1
a1148 1
		if (pfctl_add_trans(pf->trans, PF_RULESET_TABLE, path))
d1158 1
a1158 1
    int rs_num, int depth)
d1172 1
a1172 1
		if (TAILQ_FIRST(rs->rules[rs_num].active.ptr) != NULL) {
d1188 1
a1188 1
	if (pf->optimize && rs_num == PF_RULESET_FILTER)
d1191 2
a1192 2
	while ((r = TAILQ_FIRST(rs->rules[rs_num].active.ptr)) != NULL) {
		TAILQ_REMOVE(rs->rules[rs_num].active.ptr, r, entries);
d1197 1
a1197 1
			    &r->anchor->ruleset, rs_num, depth + 1)))
a1218 1
	u_int8_t		rs_num = pf_get_ruleset_number(r->action);
d1226 1
a1226 1
		pr.ticket = pfctl_get_ticket(pf->trans, rs_num, path);
d1369 1
a1369 1
			    pfctl_get_ticket(t, PF_RULESET_ALTQ, anchorname);
d1372 1
a1372 1
			    pfctl_get_ticket(t, PF_RULESET_TABLE, anchorname);
d1384 1
a1384 1
	    pfctl_load_ruleset(&pf, path, rs, PF_RULESET_FILTER, 0))) {
@


1.288
log
@sort usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.287 2009/09/28 22:13:20 dlg Exp $ */
d850 3
d908 1
d1134 2
d1259 2
@


1.287
log
@add -S and -L options to store and load the pf state table from a file.

inspired by the short reboot times on an rb600a provided by stephan
rickauer.
testing and bugfixing by sthen@@
ok mcbride@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.286 2009/09/03 15:14:33 jmc Exp $ */
d237 1
a237 1
	fprintf(stderr, "\t[-s modifier] [-S statefile] ");
@


1.286
log
@remove -N from usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.285 2009/09/01 13:42:00 henning Exp $ */
d98 2
d236 4
a239 3
	fprintf(stderr, "[-o level] [-p device]\n");
	fprintf(stderr, "\t[-s modifier] ");
	fprintf(stderr, "[-t table -T command [address ...]] [-x level]\n");
d1940 69
d2019 1
d2025 1
a2025 1
	    "a:AdD:eqf:F:ghi:k:K:mnOo:p:rRs:t:T:vx:z")) != -1) {
d2145 7
d2397 5
@


1.285
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.284 2009/08/21 05:27:57 ratchov Exp $ */
d230 1
a230 1
	fprintf(stderr, "usage: %s [-AdeghmNnOqRrvz] ", __progname);
@


1.284
log
@remove the ``;'' at the end of INDENT() macro definition using
the ``do { ... } while (0)'' construct.
ok henning, from Frederic Culuot <frederic _at_ culot.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.283 2009/07/09 23:52:25 henning Exp $ */
a64 1
int	 pfctl_clear_nat(int, int, char *);
d82 1
a82 1
	    char *);
a84 1
int	 pfctl_show_nat(int, int, char *);
d202 1
a202 1
	"nat", "queue", "rules", "Sources",
d207 1
a207 1
	"nat", "queue", "rules", "Anchors", "Sources", "states", "info",
a321 18
pfctl_clear_nat(int dev, int opts, char *anchorname)
{
	struct pfr_buffer t;

	memset(&t, 0, sizeof(t));
	t.pfrb_type = PFRB_TRANS;
	if (pfctl_add_trans(&t, PF_RULESET_NAT, anchorname) ||
	    pfctl_add_trans(&t, PF_RULESET_BINAT, anchorname) ||
	    pfctl_add_trans(&t, PF_RULESET_RDR, anchorname) ||
	    pfctl_trans(dev, &t, DIOCXBEGIN, 0) ||
	    pfctl_trans(dev, &t, DIOCXCOMMIT, 0))
		err(1, "pfctl_clear_nat");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "nat cleared\n");
	return (0);
}

int
d689 1
a689 1
    u_int32_t ticket, int r_action, char *anchorname)
d700 1
d841 5
a845 2
		if (pfctl_get_pool(dev, &pr.rule.rpool,
		    nr, pr.ticket, PF_PASS, path) != 0)
d900 2
a901 1
		pfctl_clear_pool(&pr.rule.rpool);
a911 40
pfctl_show_nat(int dev, int opts, char *anchorname)
{
	struct pfioc_rule pr;
	u_int32_t mnr, nr;
	static int nattype[3] = { PF_NAT, PF_RDR, PF_BINAT };
	int i, dotitle = opts & PF_OPT_SHOWALL;

	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	for (i = 0; i < 3; i++) {
		pr.rule.action = nattype[i];
		if (ioctl(dev, DIOCGETRULES, &pr)) {
			warn("DIOCGETRULES");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULE, &pr)) {
				warn("DIOCGETRULE");
				return (-1);
			}
			if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
			    pr.ticket, nattype[i], anchorname) != 0)
				return (-1);
			if (dotitle) {
				pfctl_print_title("TRANSLATION RULES:");
				dotitle = 0;
			}
			print_rule(&pr.rule, pr.anchor_call,
			    opts & PF_OPT_VERBOSE2);
			printf("\n");
			pfctl_print_rule_counters(&pr.rule, opts);
			pfctl_clear_pool(&pr.rule.rpool);
		}
	}
	return (0);
}

int
d1068 1
a1068 1
pfctl_add_pool(struct pfctl *pf, struct pf_pool *p, sa_family_t af)
a1071 5
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr))
			err(1, "DIOCBEGINADDRS");
	}

d1074 1
d1076 2
a1077 4
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCADDADDR, &pf->paddr))
				err(1, "DIOCADDADDR");
		}
d1123 4
a1126 2
	TAILQ_INIT(&rule->rpool.list);
	pfctl_move_pool(&r->rpool, &rule->rpool);
a1136 6
	if ((pf->loadopt & PFCTL_FLAG_NAT) != 0) {
		if (pfctl_add_trans(pf->trans, PF_RULESET_NAT, path) ||
		    pfctl_add_trans(pf->trans, PF_RULESET_BINAT, path) ||
		    pfctl_add_trans(pf->trans, PF_RULESET_RDR, path))
			return (1);
	}
d1245 5
a1249 1
		if (pfctl_add_pool(pf, &r->rpool, r->af))
d1266 2
a1267 1
	pfctl_clear_pool(&r->rpool);
d1381 1
a1381 5
	if ((pf.loadopt & PFCTL_FLAG_NAT &&
	    (pfctl_load_ruleset(&pf, path, rs, PF_RULESET_NAT, 0) ||
	    pfctl_load_ruleset(&pf, path, rs, PF_RULESET_RDR, 0) ||
	    pfctl_load_ruleset(&pf, path, rs, PF_RULESET_BINAT, 0))) ||
	    (pf.loadopt & PFCTL_FLAG_FILTER &&
d1952 1
a1952 1
	    "a:AdD:eqf:F:ghi:k:K:mnNOo:p:rRs:t:T:vx:z")) != -1) {
a2007 3
		case 'N':
			loadopt |= PFCTL_FLAG_NAT;
			break;
d2114 1
a2114 1
		loadopt &= PFCTL_FLAG_FILTER|PFCTL_FLAG_NAT|PFCTL_FLAG_TABLE;
a2150 4
		case 'n':
			pfctl_load_fingerprints(dev, opts);
			pfctl_show_nat(dev, opts, anchorname);
			break;
a2173 1
			pfctl_show_nat(dev, opts, anchorname);
a2210 3
		case 'n':
			pfctl_clear_nat(dev, opts, anchorname);
			break;
a2224 1
			pfctl_clear_nat(dev, opts, anchorname);
@


1.283
log
@repair -x
since all this stuff is transactional now we need to wrap that into
DIOCXBEGIN/COMMIT.
bad henning forgot to commit this chunk at c2k9
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.282 2009/04/16 04:40:19 david Exp $ */
d131 1
a131 1
			} while (0);					\
@


1.282
log
@Really turn fragment reassembly on by default.  pfctl must handle this
since the DIOCSETREASS ioctl is called on every ruleset load and was
overriding the initial setting in pfattach().  Fix setting of the global
no-df bitmask as well.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.281 2009/04/06 12:05:55 henning Exp $ */
d1903 9
a1911 2
	if (ioctl(dev, DIOCSETDEBUG, &level))
		err(1, "DIOCSETDEBUG");
@


1.281
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.280 2009/02/23 06:58:30 deraadt Exp $ */
d1549 1
d1709 3
a1711 1
			pf->reassemble &= PF_REASS_NODF;
@


1.280
log
@back out last commit since it breaks a few regress tests -- this will be
looked at post-release -- out of time for these kinds of problems
david@@ says: pfopt6 and f91.ok; pfopt6 change looks ok, but pf91 is
of concern.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.278 2008/08/31 20:18:17 jmc Exp $ */
d81 1
d314 1
a314 2
	if (pfctl_add_trans(&t, PF_RULESET_SCRUB, anchorname) ||
	    pfctl_add_trans(&t, PF_RULESET_FILTER, anchorname) ||
a837 5
	pr.rule.action = PF_SCRUB;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		goto error;
	}
a843 1
	mnr = pr.nr;
a846 26
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			goto error;
		}

		if (pfctl_get_pool(dev, &pr.rule.rpool,
		    nr, pr.ticket, PF_SCRUB, path) != 0)
			goto error;

		switch (format) {
		case PFCTL_SHOW_LABELS:
			break;
		case PFCTL_SHOW_RULES:
			if (pr.rule.label[0] && (opts & PF_OPT_SHOWALL))
				labels = 1;
			print_rule(&pr.rule, pr.anchor_call, rule_numbers);
			printf("\n");
			pfctl_print_rule_counters(&pr.rule, opts);
			break;
		case PFCTL_SHOW_NOTHING:
			break;
		}
		pfctl_clear_pool(&pr.rule.rpool);
	}
d1151 2
a1152 1
	rs_num = pf_get_ruleset_number(r->action);
d1208 1
a1208 2
		if (pfctl_add_trans(pf->trans, PF_RULESET_SCRUB, path) ||
		    pfctl_add_trans(pf->trans, PF_RULESET_FILTER, path))
d1441 1
a1441 3
	if ((pf.loadopt & PFCTL_FLAG_FILTER &&
	    (pfctl_load_ruleset(&pf, path, rs, PF_RULESET_SCRUB, 0))) ||
	    (pf.loadopt & PFCTL_FLAG_NAT &&
d1605 5
d1699 20
d1811 10
@


1.279
log
@fix pfctl -v printing of anchors, from camield@@. Closes user/6065
@
text
@d1355 2
a1356 1
		print_rule(r, name, pf->opts & PF_OPT_VERBOSE2);
@


1.278
log
@avoid line wrap in usage() output;
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.277 2008/07/24 10:52:43 henning Exp $ */
d1355 1
a1355 2
		print_rule(r, r->anchor ? r->anchor->name : "",
		    pf->opts & PF_OPT_VERBOSE2);
@


1.277
log
@check sysctl return value
From: Gleydson Soares <gsoares@@gmail.com>, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.276 2008/05/27 08:14:57 mcbride Exp $ */
d233 5
a237 4
	fprintf(stderr, "\t[-f file] [-i interface] [-K host | network] ");
	fprintf(stderr, "[-k host | network | label | id]\n");
	fprintf(stderr, "\t[-o level] [-p device] [-s modifier]\n");
	fprintf(stderr, "\t[-t table -T command [address ...]] [-x level]\n");
@


1.276
log
@Fix count of states flushed, broken when the psnk_af hack was removed in pf_ioctl.c r1.196.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.275 2008/05/09 13:59:31 mpf Exp $ */
d1576 2
a1577 1
	(void) sysctl(mib, 2, &mem, &size, NULL, 0);
@


1.275
log
@Add support to kill states by rule label or state id.
Fix printing of the state id in pfctl -ss -vv.
Remove the psnk_af hack to return the number of killed states.
OK markus, beck. "I like it" henning, deraadt.
Manpage help from jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.274 2008/05/06 03:45:21 mpf Exp $ */
d381 1
a381 1
		fprintf(stderr, "%d states cleared\n", psk.psk_af);
@


1.274
log
@Add a counter to record how many states have been created by a rule.
It shows up in pfctl verbose mode and in the 7th field of the labels
output.  Also remove the label printing for scrub rules, as they
do not support labels.
OK dhartmei@@ (on an earlier version), henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.273 2008/02/13 19:55:12 kettenis Exp $ */
d71 3
a73 1
int	 pfctl_kill_states(int, const char *, int);
d234 1
a234 1
	fprintf(stderr, "[-k host | network]\n");
d520 1
a520 3
				killed += psnk.psnk_af;
				/* fixup psnk.psnk_af */
				psnk.psnk_af = resp[1]->ai_family;
d526 1
a526 3
			killed += psnk.psnk_af;
			/* fixup psnk.psnk_af */
			psnk.psnk_af = res[0]->ai_family;
d539 1
a539 1
pfctl_kill_states(int dev, const char *iface, int opts)
d626 1
a626 3
				killed += psk.psk_af;
				/* fixup psk.psk_af */
				psk.psk_af = resp[1]->ai_family;
d632 1
a632 3
			killed += psk.psk_af;
			/* fixup psk.psk_af */
			psk.psk_af = res[0]->ai_family;
d645 62
d2306 8
a2313 2
	if (state_killers)
		pfctl_kill_states(dev, ifaceopt, opts);
@


1.273
log
@Use HW_PHYSMEM64.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.272 2007/11/27 16:22:13 martynas Exp $ */
d737 1
a737 1
			    rule->bytes[1]), rule->states);
d739 4
a742 2
			printf("  [ Inserted: uid %u pid %u ]\n",
			    (unsigned)rule->cuid, (unsigned)rule->cpid);
a808 13
			if (pr.rule.label[0]) {
				printf("%s ", pr.rule.label);
				printf("%llu %llu %llu %llu %llu %llu %llu\n",
				    (unsigned long long)pr.rule.evaluations,
				    (unsigned long long)(pr.rule.packets[0] +
				    pr.rule.packets[1]),
				    (unsigned long long)(pr.rule.bytes[0] +
				    pr.rule.bytes[1]),
				    (unsigned long long)pr.rule.packets[0],
				    (unsigned long long)pr.rule.bytes[0],
				    (unsigned long long)pr.rule.packets[1],
				    (unsigned long long)pr.rule.bytes[1]);
			}
d842 3
a844 2
				printf("%s ", pr.rule.label);
				printf("%llu %llu %llu %llu %llu %llu %llu\n",
d853 2
a854 1
				    (unsigned long long)pr.rule.bytes[1]);
@


1.272
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.271 2007/10/24 13:07:38 wilfried Exp $ */
d1495 2
a1496 1
	int mib[2], mem;
d1527 1
a1527 1
	mib[1] = HW_PHYSMEM;
d1530 1
a1530 1
	if ((unsigned)mem <= 100*1024*1024)
@


1.271
log
@HW_PHYSMEM is unsigned

yuck & ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.270 2007/10/15 02:16:35 deraadt Exp $ */
d1552 1
a1552 1
	 * If we've set the limit, but havn't explicitly set adaptive
@


1.270
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.269 2007/10/13 16:35:18 deraadt Exp $ */
d1529 1
a1529 1
	if (mem <= 100*1024*1024)
@


1.269
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.268 2007/06/30 18:25:08 henning Exp $ */
d956 1
a956 1
	unsigned len = 0;
d1001 1
a1001 1
	unsigned len = 0;
@


1.268
log
@allow states instead of just state for -s and -F for consistency's sake.
since only the first letter matters in the end and state still matches
states since we do strncmp this does not change xisting behaviour and
just allows plural states to be used as well.
pt out by Tom Van Looy <tom@@ctors.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.267 2007/05/31 04:13:37 mcbride Exp $ */
a121 2
const char	*infile;

d1338 1
a1338 1
pfctl_rules(int dev, char *filename, FILE *fin, int opts, int optimize,
a1373 1
	infile = filename;
d1417 1
a1417 1
	if (parse_rules(fin, &pf) < 0) {
a1442 5
	if (fin != stdin) {
		fclose(fin);
		fin = NULL;
	}

a1463 2
		if (fin != NULL && fin != stdin)
			fclose(fin);
a1949 1
	FILE	*fin = NULL;
a2283 9
 	if (rulesopt != NULL) {
		if (strcmp(rulesopt, "-") == 0) {
			fin = stdin;
			rulesopt = "stdin";
		} else {
			if ((fin = pfctl_fopen(rulesopt, "r")) == NULL)
				err(1, "%s", rulesopt);
		}
	}
d2298 1
a2298 1
		if (pfctl_rules(dev, rulesopt, fin, opts, optimize,
@


1.267
log
@Cope with new ioctl interface (use pfsync_state instead of pf_state)

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.266 2007/04/21 14:50:26 henning Exp $ */
d204 1
a204 1
	"state", "info", "Tables", "osfp", "all", NULL
d208 1
a208 1
	"nat", "queue", "rules", "Anchors", "Sources", "state", "info",
@


1.266
log
@"o" in optiopt_list is superfluous now too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.265 2007/04/21 14:49:45 henning Exp $ */
d1001 1
a1001 1
	struct pf_state *p;
d1032 1
a1032 1
		if (iface != NULL && strcmp(p->u.ifname, iface))
@


1.265
log
@fix -o handling. syntax is now -o none|basic|profile. -o without argument
is invalid now, it doesn't serve any purpose any more anyway since that is
the default. ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.264 2007/04/20 07:30:16 jmc Exp $ */
d223 1
a223 1
	"o", "none", "basic", "profile", NULL
@


1.264
log
@no whitespace allowed between -o and its argument, so update doc/usage()
to reflect this;

whilst there i had to wrap -t in Xo/Xc to stop line split,
and i zapped some extra whitespace in usage();

fixes user/5441 from sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.263 2007/03/21 03:01:31 mcbride Exp $ */
d235 1
a235 1
	fprintf(stderr, "\t[-o[level]] [-p device] [-s modifier]\n");
d1966 1
a1966 1
	    "a:AdD:eqf:F:ghi:k:K:mnNOo::p:rRs:t:T:vx:z")) != -1) {
d2042 4
a2045 16
			if (optarg) {
				optiopt = pfctl_lookup_option(optarg,
				    optiopt_list);
					if (optiopt == NULL) {
					warnx("Unknown optimization '%s'",
					    optarg);
					usage();
				}
			}
			if (opts & PF_OPT_OPTIMIZE) {
				if (optiopt != NULL) {
					warnx("Cannot specify -o multiple times"
					    "with optimizer level");
					usage();
				}
				optimize |= PF_OPTIMIZE_PROFILE;
a2046 1
			optimize |= PF_OPTIMIZE_BASIC;
@


1.263
log
@Enable basic ruleset optimization by default.

ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.262 2007/03/01 17:20:53 deraadt Exp $ */
d234 2
a235 2
	fprintf(stderr, "[-k host | network ]\n");
	fprintf(stderr, "\t[-o [level]] [-p device] [-s modifier ]\n");
@


1.262
log
@be more careful with mixing &/| with &&/||, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.261 2007/02/23 21:31:52 deraadt Exp $ */
d1957 1
a1957 1
	int	 optimize = 0;
@


1.261
log
@if machine has more than 100MB of physmem, default the max table entries
to 200,000 instead of the conservative 100,000; ok dhartmei beck
tested by ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.260 2007/02/09 11:28:32 henning Exp $ */
d876 1
a876 1
			   *(--p) == '/')) || opts & PF_OPT_RECURSE)) {
d1932 1
a1932 1
		if (sub[0] != '_' || opts & PF_OPT_VERBOSE)
d1934 1
a1934 1
		if (opts & PF_OPT_VERBOSE && pfctl_show_anchors(dev, opts, sub))
d2233 1
a2233 1
	if (opts & PF_OPT_CLRRULECTRS && showopt == NULL)
@


1.260
log
@pfctl_clear_rule_counters() is not needed any more
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.259 2007/02/09 11:25:27 henning Exp $ */
d44 1
d1505 3
d1534 7
@


1.259
log
@use DIOCGETRULE ioctl & action set to PF_GET_CLR_CNTR to clear counters
with -z instead of DIOCCLRRULECTRS. Unbreaks -z with anchors and makes the
read & reset operation atomic.
innstrument pfctl_show_rules() to clear counters while reading rules and
add a new output format for it, showing nothing, if only resetting counters
without actually displaying them is requested. minor cleanups on the way.
ok dhartmei & agreement from theo and ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.258 2007/01/18 20:45:55 henning Exp $ */
a88 1
int	 pfctl_clear_rule_counters(int, int);
a1870 10
}

int
pfctl_clear_rule_counters(int dev, int opts)
{
	if (ioctl(dev, DIOCCLRRULECTRS))
		err(1, "DIOCCLRRULECTRS");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf: rule counters cleared\n");
	return (0);
@


1.258
log
@implement -T expire.
"pfctl -t tablename -T expire 3600" would expire all entries in the given
table that are older than 3600 seconds. ok dhartmei, manpage help & ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.257 2006/11/20 14:31:17 mcbride Exp $ */
d81 1
a81 1
int	 pfctl_show_rules(int, char *, int, int, char *, int);
d756 1
a756 1
pfctl_show_rules(int dev, char *path, int opts, int format,
d787 1
a787 1
		if (format == 0 && (pr.nr > 0 || header))
d789 1
a789 1
		else if (format == 1 && labels)
d793 3
d808 1
a808 1
		case 1:
d823 1
a823 1
		default:
d829 3
d853 1
a853 1
		case 1:
d868 1
a868 1
		default:
d898 3
d1959 1
d2127 2
a2166 5
		char *path;

		if ((path = calloc(1, MAXPATHLEN)) == NULL)
			errx(1, "pfctl: calloc");

d2173 2
a2174 1
			pfctl_show_rules(dev, path, opts, 0, anchorname, 0);
d2178 2
a2179 1
			pfctl_show_rules(dev, path, opts, 1, anchorname, 0);
d2233 4
a2359 4
	if (opts & PF_OPT_CLRRULECTRS) {
		if (pfctl_clear_rule_counters(dev, opts))
			error = 1;
	}
@


1.257
log
@-K argument to kill source tracking nodes explicitly, behaves like the
-k argument for killing states; From Berk D. Demir <bdd@@mindcast.org>

ok dhartmei henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.256 2006/11/07 06:16:56 mcbride Exp $ */
d215 1
a215 1
	"test", "zero", NULL
d2108 1
a2108 1
			mode = strchr("acdfkrz", ch) ? O_RDWR : O_RDONLY;
@


1.256
log
@Only try to recursively print rules if they are actually anchors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.255 2006/11/07 01:12:01 mcbride Exp $ */
d69 1
d111 2
d233 4
a236 5
	fprintf(stderr, "\t[-f file] [-i interface] [-k host | network] ");
	fprintf(stderr, "[-o [level]]\n");
	fprintf(stderr, "\t[-p device] [-s modifier] ");
	fprintf(stderr, "[-t table -T command [address ...]]\n");
	fprintf(stderr, "\t[-x level]\n");
d436 107
d1956 1
a1956 1
	    "a:AdD:eqf:F:ghi:k:mnNOo::p:rRs:t:T:vx:z")) != -1) {
d1997 9
d2271 3
@


1.255
log
@Unbreak authpf by handling non-inline anchors separately from the { } anchors
as pf_find_or_create_ruleset() will mangle relative anchor names and wildcards.
Also fixes some nits with nesting and printing inline anchors.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.254 2006/11/05 07:19:30 mcbride Exp $ */
d758 2
a759 1
			if ((((p = strrchr(pr.anchor_call, '_')) != NULL) &&
d761 1
a761 1
			   *(--p) == '/')) || opts & PF_OPT_RECURSE) {
@


1.254
log
@Don't open a transaction for a ruleset unless it's a brace ruleset that
contains rules. Fixes DIOCXCOMMIT: Device busy when multiple anchors with
the same name are specified.

reported by ckuethe@@ and mkb@@crypt.org.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.253 2006/11/01 12:27:26 jmc Exp $ */
d655 1
d758 3
a760 4
			print_rule(&pr.rule, pr.anchor_call, rule_numbers);
			if (strlen(pr.anchor_call) &&
			    (pr.anchor_call[0] == '_' ||
			     opts & PF_OPT_RECURSE)) {
d762 10
d773 1
a773 1
			} else
d776 1
a776 1
			if (brace) {
d778 1
a778 1
				    pr.anchor_call, depth + 1);
d1016 1
d1024 22
a1045 3

	if (anchor_call[0] && r->anchor == NULL)
		r->anchor = pf_find_or_create_ruleset(anchor_call)->anchor;
d1102 1
a1102 1
	if (pf->opts & PF_OPT_VERBOSE && depth) {
d1105 8
a1112 8
			printf(" {\n");
			if ((pf->opts & PF_OPT_NOACTION) == 0) {
				if ((error = pfctl_ruleset_trans(pf,
				    path, rs->anchor))) {
					printf("pfctl_load_rulesets: "
					    "pfctl_ruleset_trans %d\n", error);
					goto error;
				}
d1114 1
a1114 1
		} else
d1116 1
a1121 1

d1134 1
a1134 1
	if (brace) {
d1151 1
d1153 22
a1176 4
		bzero(&pr, sizeof(pr));
		if (strlcpy(pr.anchor, path, sizeof(pr.anchor)) >=
		    sizeof(pr.anchor))
			errx(1, "pfctl_load_rule: strlcpy");
a1178 1
		pr.ticket = pfctl_get_ticket(pf->trans, rs_num, path);
d1181 3
a1183 2
		if (r->anchor && strlcpy(pr.anchor_call, r->anchor->name,
		    sizeof(pr.anchor_call)));
d1187 1
d1193 1
d1262 4
a1265 1
	pf.anchor = pf_find_or_create_ruleset(anchorname)->anchor;
d1267 10
@


1.253
log
@sync usage(); ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.252 2006/11/01 03:39:24 mcbride Exp $ */
a1071 12
	if (rs != &pf->astack[0]->ruleset &&
	    ((pf->opts & PF_OPT_NOACTION) == 0)) {
		if ((error = pfctl_ruleset_trans(pf, path, rs->anchor))) {
			printf("pfctl_load_rulesets: "
			    "pfctl_ruleset_trans %d\n", error);
				goto error;
		}
	}

	if (pf->optimize && rs_num == PF_RULESET_FILTER)
		pfctl_optimize_ruleset(pf, rs);

d1076 8
d1087 4
@


1.252
log
@Don't recures ALL the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.251 2006/10/31 23:46:24 mcbride Exp $ */
d228 1
a228 1
	fprintf(stderr, "usage: %s [-AdeghmNnOoqRrvz] ", __progname);
d230 5
a234 6
	fprintf(stderr, "             ");
	fprintf(stderr, "[-f file] [-i interface] [-k host | network] ");
	fprintf(stderr, "[-p device]\n");
	fprintf(stderr, "             ");
	fprintf(stderr, "[-s modifier] [-t table -T command [address ...]] ");
	fprintf(stderr, "[-x level]\n");
@


1.251
log
@Allow a user to recursively print anchors including those without
reserved names, if a trailing * is specified in the anchor name.
e.g. recursively print the main  ruleset:

	pfctl -a '*' -sr

Recursively print the spam anchor:

	pfctl -a 'spam*'
	pfctl -a 'spam/*'

Also fix a bug which prevented the contents of inline anchors with
explicit names from being loaded into the kernel.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.250 2006/10/31 14:17:45 mcbride Exp $ */
d1944 1
a1945 1
		opts |= PF_OPT_RECURSE;
@


1.250
log
@Allow pfctl ruleset optimizer to be controlled from the ruleset.

"set" "ruleset-optimization" [ "none" | "basic" | "profile" ]

You can optionally control ruleset optimization with these keywords on the
command line with the -o option; the command line setting will override the
pf.conf setting. The existing -o/-oo flags continue to work as expected.

cleanup and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.249 2006/10/31 07:02:35 mcbride Exp $ */
d655 1
d715 1
d754 1
d759 7
d767 1
a767 1
			if (pr.anchor_call[0] == '_') {
d816 1
d1064 1
d1085 8
d1097 1
a1097 1
		if (r->anchor && r->anchor->name[0] == '_') {
d1101 2
a1102 4
			INDENT(depth, (pf->opts & PF_OPT_VERBOSE));
			if (pf->opts & PF_OPT_VERBOSE)
				printf("}\n");
		}
d1105 4
d1937 9
@


1.249
log
@- don't allow anchors with _* names to be cleared or loaded from the
  command line (but they can still be viewed)
- don't allow users to specify _* as an anchor name in the ruleset
- don't print _* anchor names with pfctl -sA unless -v is specified

'looks sensible' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.248 2006/10/28 14:29:05 mcbride Exp $ */
d105 1
d219 3
d1070 1
a1070 1
	if ((pf->opts & PF_OPT_OPTIMIZE) && rs_num == PF_RULESET_FILTER)
d1149 2
a1150 2
pfctl_rules(int dev, char *filename, FILE *fin, int opts, char *anchorname,
    struct pfr_buffer *trans)
d1188 1
d1249 1
a1249 1
		if (pfctl_load_anchors(dev, opts, t) == -1)
d1488 1
a1488 1
		warnx("Bad hint name.");
d1753 1
d1761 1
a1761 1
	    "a:AdD:eqf:F:ghi:k:mnNOop:rRs:t:T:vx:z")) != -1) {
d1828 19
a1846 4
			if (opts & PF_OPT_OPTIMIZE)
				opts |= PF_OPT_OPTIMIZE_PROFILE;
			else
				opts |= PF_OPT_OPTIMIZE;
d2064 16
a2079 1
	if (rulesopt != NULL) {
d2102 2
a2103 1
		if (pfctl_rules(dev, rulesopt, fin, opts, anchorname, NULL))
@


1.248
log
@Load all rules into memory before loading into the kernel, and add support
for anchors loaded inline in pf.conf, enclosed in a brace-delimited
block ("{" "}").

anchor on fxp0 {
	pass in proto tcp port 22
}

The anchor name is optional on inline loaded anchors.

testing ckuethe@@
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.247 2006/06/30 16:52:27 deraadt Exp $ */
d1723 2
a1724 1
		printf("  %s\n", sub);
d1991 4
d2063 3
@


1.247
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.246 2006/05/28 02:45:45 mcbride Exp $ */
d80 1
a80 1
int	 pfctl_show_rules(int, int, int, char *);
d91 4
d97 3
d120 9
d576 11
d644 2
a645 1
pfctl_show_rules(int dev, int opts, int format, char *anchorname)
d650 6
d658 1
a658 1
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
d663 1
a663 1
			return (-1);
d670 1
a670 1
		return (-1);
d683 1
a683 1
			return (-1);
d687 2
a688 2
		    nr, pr.ticket, PF_SCRUB, anchorname) != 0)
			return (-1);
d717 1
a717 1
		return (-1);
d724 1
a724 1
			return (-1);
d728 2
a729 2
		    nr, pr.ticket, PF_PASS, anchorname) != 0)
			return (-1);
d750 1
d753 6
d762 1
d764 4
d990 2
a991 1
	struct pfioc_rule	pr;
d993 2
a994 32
	switch (r->action) {
	case PF_SCRUB:
	case PF_NOSCRUB:
		if ((loadopt & PFCTL_FLAG_FILTER) == 0)
			return (0);
		rs_num = PF_RULESET_SCRUB;
		break;
	case PF_DROP:
	case PF_PASS:
		if ((loadopt & PFCTL_FLAG_FILTER) == 0)
			return (0);
		rs_num = PF_RULESET_FILTER;
		break;
	case PF_NAT:
	case PF_NONAT:
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
			return (0);
		rs_num = PF_RULESET_NAT;
		break;
	case PF_RDR:
	case PF_NORDR:
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
			return (0);
		rs_num = PF_RULESET_RDR;
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		if ((loadopt & PFCTL_FLAG_NAT) == 0)
			return (0);
		rs_num = PF_RULESET_BINAT;
		break;
	default:
d996 37
a1032 1
		break;
d1034 17
d1052 4
d1057 8
a1064 8
	if ((pf->opts & PF_OPT_OPTIMIZE) && rs_num == PF_RULESET_FILTER) {
		/*
		 * We'll do an optimization post-pass before finally adding the
		 * rules.  Then we'll disable the optimization flag and feed
		 * the rules right back into this function.
		 */
		struct pf_opt_rule *pfr;
		struct pf_pooladdr *pa;
d1066 2
a1067 18
		if ((pfr = calloc(1, sizeof(*pfr))) == NULL)
			err(1, "calloc");
		memcpy(&pfr->por_rule, r, sizeof(*r));
		if (strlcpy(pfr->por_anchor, anchor_call,
		    sizeof(pfr->por_anchor)) >= sizeof(pfr->por_anchor))
			errx(1, "pfctl_add_rule: strlcpy");
		TAILQ_INSERT_TAIL(&pf->opt_queue, pfr, por_entry);

		if (TAILQ_FIRST(&r->rpool.list) != NULL)  {
			TAILQ_INIT(&pfr->por_rule.rpool.list);
			while ((pa = TAILQ_FIRST(&r->rpool.list)) != NULL) {
				TAILQ_REMOVE(&r->rpool.list, pa, entries);
				TAILQ_INSERT_TAIL(&pfr->por_rule.rpool.list, pa,
				    entries);
			}
		} else {
			memset(&pfr->por_rule.rpool, 0,
			    sizeof(pfr->por_rule.rpool));
d1069 11
d1081 1
a1081 1
		return (0);
d1083 14
d1100 1
a1100 1
		if (strlcpy(pr.anchor, pf->anchor, sizeof(pr.anchor)) >=
d1102 1
a1102 1
			errx(1, "pfctl_add_rule: strlcpy");
d1105 1
a1105 1
		pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor);
d1108 2
a1109 1
		strlcpy(pr.anchor_call, anchor_call, sizeof(pr.anchor_call));
d1113 5
a1117 2
	if (pf->opts & PF_OPT_VERBOSE)
		print_rule(r, anchor_call, pf->opts & PF_OPT_VERBOSE2);
d1154 1
d1156 1
d1159 4
d1164 4
a1167 4
	    bzero(&buf, sizeof(buf));
	    buf.pfrb_type = PFRB_TRANS;
	    t = &buf;
	    osize = 0;
d1169 2
a1170 2
	    t = trans;
	    osize = t->pfrb_size;
d1176 2
d1185 4
a1192 3
	pf.rule_nr = 0;
	pf.anchor = anchorname;
	TAILQ_INIT(&pf.opt_queue);
d1196 7
a1202 21
		if ((pf.loadopt & PFCTL_FLAG_NAT) != 0) {
			if (pfctl_add_trans(t, PF_RULESET_NAT, anchorname) ||
			    pfctl_add_trans(t, PF_RULESET_BINAT, anchorname) ||
			    pfctl_add_trans(t, PF_RULESET_RDR, anchorname))
				ERR("pfctl_rules");
		}
		if (((altqsupport && (pf.loadopt & PFCTL_FLAG_ALTQ) != 0))) {
			if (pfctl_add_trans(t, PF_RULESET_ALTQ, anchorname))
				ERR("pfctl_rules");
		}
		if ((pf.loadopt & PFCTL_FLAG_FILTER) != 0) {
			if (pfctl_add_trans(t, PF_RULESET_SCRUB, anchorname) ||
			    pfctl_add_trans(t, PF_RULESET_FILTER, anchorname))
				ERR("pfctl_rules");
		}
		if (pf.loadopt & PFCTL_FLAG_TABLE) {
			if (pfctl_add_trans(t, PF_RULESET_TABLE, anchorname))
				ERR("pfctl_rules");
		}
		if (pfctl_trans(dev, t, DIOCXBEGIN, osize))
			ERR("DIOCXBEGIN");
d1204 2
a1205 2
			pa.ticket = pfctl_get_ticket(t, PF_RULESET_ALTQ,
			    anchorname);
d1207 2
a1208 2
			pf.tticket = pfctl_get_ticket(t, PF_RULESET_TABLE,
			    anchorname);
d1210 1
d1218 13
a1230 3
	if (pf.opts & PF_OPT_OPTIMIZE) {
		if (pfctl_optimize_rules(&pf))
			ERRX("Failed to optimize ruleset: pf rules not loaded");
d1251 1
a1251 1
		if (pfctl_trans(dev, t, DIOCXCOMMIT, 0))
d1259 1
a1259 1
			if (pfctl_trans(dev, t, DIOCXROLLBACK, 0))
d1920 5
d1931 1
a1931 1
			pfctl_show_rules(dev, opts, 0, anchorname);
d1935 1
a1935 1
			pfctl_show_rules(dev, opts, 1, anchorname);
d1965 1
a1965 1
			pfctl_show_rules(dev, opts, 0, anchorname);
d1970 1
a1970 1
			pfctl_show_rules(dev, opts, 1, anchorname);
@


1.246
log
@Enable adaptive timeouts by default, with adaptive.start of 60% of the
state limit and adaptive.end of 120% of the state limit.
Explicitly setting the adaptive timeouts will override the default,
and it can be disabled by setting both adaptive.start and adaptive.end to 0.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.245 2006/04/24 06:10:54 dhartmei Exp $ */
d1005 1
a1005 1
			    	entries);
@


1.245
log
@don't clear interface flags (set skip on) when -N/-F is used without -O,
from Jon Simola, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.244 2005/11/17 20:52:39 dhartmei Exp $ */
d1221 2
d1247 15
@


1.244
log
@for pfctl -f rules, open the file before resetting options. when opening
the file fails, produce only the error message and leave options
unchanged. reported by Tamas TEVESZ, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.243 2005/07/11 14:16:09 dhartmei Exp $ */
d1932 2
a1933 1
	if ((rulesopt != NULL) && (!*anchorname))
@


1.243
log
@clear PFI_IFLAG_SKIP when clearing interface flags, found by David Hill,
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.242 2005/06/13 20:17:25 henning Exp $ */
d1058 1
a1058 1
pfctl_rules(int dev, char *filename, int opts, char *anchorname,
a1063 1
	FILE			*fin;
d1086 1
a1086 10
	if (strcmp(filename, "-") == 0) {
		fin = stdin;
		infile = "stdin";
	} else {
		if ((fin = pfctl_fopen(filename, "r")) == NULL) {
			warn("%s", filename);
			return (1);
		}
		infile = filename;
	}
d1633 6
a1638 5
	int	error = 0;
	int	ch;
	int	mode = O_RDONLY;
	int	opts = 0;
	char	anchorname[MAXPATHLEN];
d1923 9
a1931 1

d1942 1
a1942 1
		if (pfctl_rules(dev, rulesopt, opts, anchorname, NULL))
@


1.242
log
@make the packet and byte counters on rules and src nodes per direction,
matches the counters on states now. also fix the counting on scrub rules
where we previously did not handle the byte counters at all.
extend pfctl -sl output to include the new seperate in/out counters
hacked on the ferry from Earls Cove to Saltery Bay
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.241 2005/06/13 19:26:06 jaredy Exp $ */
d274 1
@


1.241
log
@free memory in show_src_nodes and show_states, as reported by
Henrik Gustafsson <openbsd@@fnord.se> via tech@@.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.240 2005/05/28 01:48:23 dhartmei Exp $ */
d596 4
a599 2
			    (unsigned long long)rule->packets,
			    (unsigned long long)rule->bytes, rule->states);
d659 1
a659 1
				printf("%llu %llu %llu\n",
d661 8
a668 2
				    (unsigned long long)pr.rule.packets,
				    (unsigned long long)pr.rule.bytes);
d700 1
a700 1
				printf("%llu %llu %llu\n",
d702 8
a709 2
				    (unsigned long long)pr.rule.packets,
				    (unsigned long long)pr.rule.bytes);
@


1.240
log
@don't print the "[ Inserted: uid pid ]" line when -g is used, so the
regress tests don't have to deal with it (and it's a useless thing to
check from there).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.239 2005/05/27 17:22:40 dhartmei Exp $ */
d768 1
d774 1
a774 1
			return (0);
d778 1
a778 1
			return (0);	/* no src_nodes */
d788 2
d813 1
d819 1
a819 1
			return (0);
d823 1
a823 1
			return (0);	/* no states */
d836 2
@


1.239
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.238 2005/05/23 23:28:53 dhartmei Exp $ */
d598 3
a600 2
		printf("  [ Inserted: uid %u pid %u ]\n",
		    (unsigned)rule->cuid, (unsigned)rule->cpid);
@


1.238
log
@change pool allocation of table entries, no longer use the oldnointr
allocator and two pools, but PR_WAITOK when called from non-interrupt
context (ioctl). add configurable hard limits for tables and table
entries (set limit tables/table-entries), defaulting to 1000/100000.
ok aaron@@, henning@@, mcbride@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.237 2005/05/22 21:05:23 mpf Exp $ */
d592 1
a592 1
	if (opts & PF_OPT_VERBOSE)
d598 3
@


1.237
log
@Add support to kill states that match networks.
man page from jmc@@
OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.236 2005/05/21 21:03:58 henning Exp $ */
d117 6
a122 4
	{ "states",	PF_LIMIT_STATES },
	{ "src-nodes",	PF_LIMIT_SRC_NODES },
	{ "frags",	PF_LIMIT_FRAGS },
	{ NULL,		0 }
d884 1
a884 1
		printf("%-10s ", pf_limits[i].name);
d888 1
a888 1
			printf("hard limit %6u\n", pl.limit);
d1207 5
a1211 3
	pf->limit[PF_LIMIT_STATES]	= PFSTATE_HIWAT;
	pf->limit[PF_LIMIT_FRAGS]	= PFFRAG_FRENT_HIWAT;
	pf->limit[PF_LIMIT_SRC_NODES]	= PFSNODE_HIWAT;
@


1.236
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.235 2005/05/05 04:00:26 joel Exp $ */
d68 1
d209 2
a210 2
	fprintf(stderr, "[-f file] [-i interface] [-k host] ");
	fprintf(stderr, "[-p device] [-s modifier]\n");
d212 1
a212 1
	fprintf(stderr, "[-t table -T command [address ...]] ");
d361 50
d431 2
d463 2
@


1.235
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.234 2005/03/07 13:52:50 henning Exp $ */
a270 1
		pi.pfiio_flags = PFI_IFLAG_SETABLE_MASK;
@


1.234
log
@fd leaks in error paths, From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.233 2005/03/06 02:40:08 dhartmei Exp $ */
d1346 1
a1346 1
		warnx("pfctl_set_logif: strlcpy");
@


1.233
log
@print "set skip on" with -v in such a way that the output is valid input
syntax, instead of the cryptic hex flags output.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.232 2005/01/06 08:30:22 mcbride Exp $ */
d1072 2
a1073 1
	if (fin != stdin)
d1075 2
d1098 3
a1100 1
	} else			/* sub ruleset */
d1102 1
@


1.232
log
@Missing braces in pfctl_load_debug(), pointed out by camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.231 2005/01/05 18:23:10 mcbride Exp $ */
a1444 5

	if (pf->opts & PF_OPT_VERBOSE)
		printf("%s %s:0x%x flags\n", how ? "set" : "clear",
		    pi.pfiio_name, pi.pfiio_flags);

@


1.231
log
@Modify pfctl behaviour so that 'set ...' options are no longer "sticky", ie.
they are reset to default values if omitted from a subsequent ruleset load.
Also:
- make sure 'set ...' options are not loaded in anchors.
- add a -m ("merge") flag to pfctl which allows an individual option to be set
  without reseting the others, eg:
   # echo "set loginterface fxp0" | pfctl -mf -

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.230 2004/12/29 15:09:30 danh Exp $ */
d1413 1
a1413 1
	if (ioctl(pf->dev, DIOCSETDEBUG, &level))
d1416 1
@


1.230
log
@change last commit so that the test for PF_OPT_NOACTION is actually in
pfctl_clear_interface_flags().

suggested by and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.229 2004/12/29 14:21:01 danh Exp $ */
d69 7
d86 1
a86 1
int	 pfctl_debug(int, u_int32_t, int);
d205 1
a205 1
	fprintf(stderr, "usage: %s [-AdeghNnOoqRrvz] ", __progname);
d1026 1
d1080 4
a1083 1
	if (trans == NULL && (opts & PF_OPT_NOACTION) == 0)
d1086 1
d1123 71
a1196 1
	struct pfioc_limit pl;
a1198 2
	if ((loadopt & PFCTL_FLAG_OPTION) == 0)
		return (0);
a1199 1
	memset(&pl, 0, sizeof(pl));
d1202 2
a1203 13
			pl.index = pf_limits[i].index;
			pl.limit = limit;
			if ((pf->opts & PF_OPT_NOACTION) == 0) {
				if (ioctl(pf->dev, DIOCSETLIMIT, &pl)) {
					if (errno == EBUSY) {
						warnx("Current pool "
						    "size exceeds requested "
						    "hard limit");
						return (1);
					} else
						err(1, "DIOCSETLIMIT");
				}
			}
d1219 18
a1238 1
	struct pfioc_tm pt;
a1243 1
	memset(&pt, 0, sizeof(pt));
d1246 2
a1247 1
			pt.timeout = pf_timeouts[i].timeout;
a1256 5
	pt.seconds = seconds;
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCSETTIMEOUT, &pt))
			err(1, "DIOCSETTIMEOUT");
	}
d1265 15
a1311 1
	struct pfioc_if pi;
d1316 7
a1322 11
	memset(&pi, 0, sizeof(pi));
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (!strcmp(ifname, "none"))
			bzero(pi.ifname, sizeof(pi.ifname));
		else {
			if (strlcpy(pi.ifname, ifname,
			    sizeof(pi.ifname)) >= sizeof(pi.ifname))
				errx(1, "pfctl_set_logif: strlcpy");
		}
		if (ioctl(pf->dev, DIOCSETSTATUSIF, &pi))
			err(1, "DIOCSETSTATUSIF");
d1324 1
d1333 18
d1358 2
a1359 3
	if ((pf->opts & PF_OPT_NOACTION) == 0)
		if (ioctl(dev, DIOCSETHOSTID, &hostid))
			err(1, "DIOCSETHOSTID");
d1368 10
d1386 1
a1386 1
		level = PF_DEBUG_NONE;
d1388 1
a1388 1
		level = PF_DEBUG_URGENT;
d1390 1
a1390 1
		level = PF_DEBUG_MISC;
d1392 1
a1392 1
		level = PF_DEBUG_NOISY;
d1398 2
d1411 9
d1452 1
a1452 1
int
a1477 1
	return (0);
d1568 1
a1568 1
	    "a:AdD:eqf:F:ghi:k:nNOop:rRs:t:T:vx:z")) != -1) {
d1609 3
d1852 2
a1853 1
	if (rulesopt != NULL)
@


1.229
log
@don't clear interface flags if '-n' option was given.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.228 2004/12/29 10:54:01 henning Exp $ */
d262 3
a264 2
	bzero(&pi, sizeof(pi));
	pi.pfiio_flags = PFI_IFLAG_SETABLE_MASK;
d266 5
a270 4
	if (ioctl(dev, DIOCCLRIFFLAG, &pi))
		err(1, "DIOCCLRIFFLAG");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "pf: interface flags reset\n");
d1717 1
a1717 2
	if ((rulesopt != NULL) && (!*anchorname)
	    && (opts & PF_OPT_NOACTION) == 0)
@


1.228
log
@be quiet about resetting the interface flags omn ruleset load, only
print that info on manual flushes. noticed by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.227 2004/12/28 18:12:14 henning Exp $ */
d1715 2
a1716 1
	if ((rulesopt != NULL) && (!*anchorname))
@


1.227
log
@reset skip interface flags on reloads and for -Fall
from max, this time working :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.226 2004/12/27 15:47:07 deraadt Exp $ */
d1716 1
a1716 1
		if (pfctl_clear_interface_flags(dev, opts))
@


1.226
log
@unbreak tree
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.224 2004/12/22 17:17:55 dhartmei Exp $ */
d62 1
d258 15
d1695 1
d1714 4
@


1.225
log
@reset skip interface flags on reloads and for -Fall
from max
@
text
@a1678 2
				pfctl_set_interface_flags(pf, "",
				    PFI_IFLAG_SKIP, 0);
a1696 4

	if ((rulesopt != NULL) && !*anchorname)
		if (pfctl_set_interface_flags(pf, "", PFI_IFLAG_SKIP, 0))
			error = 1;
@


1.224
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.223 2004/09/21 16:59:11 aaron Exp $ */
d1679 2
d1699 4
@


1.223
log
@Implement "no scrub" to allow exclusion of specific traffic from scrub rules.
First match wins, just like "no {binat,nat,rdr}".  henning@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.222 2004/08/26 16:35:36 jaredy Exp $ */
d1268 33
@


1.222
log
@sync usage for -a

reminded by jmc, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.221 2004/08/08 19:04:25 deraadt Exp $ */
d842 1
@


1.221
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.220 2004/07/23 10:20:42 jmc Exp $ */
d198 1
a198 1
	fprintf(stderr, "[-a anchor[/ruleset]] [-D macro=value]\n");
d200 2
a201 2
	fprintf(stderr, "[-F modifier] [-f file] [-i interface] ");
	fprintf(stderr, "[-k host] [-p device]\n");
a202 1
	fprintf(stderr, "[-s modifier] ");
@


1.220
log
@- make SYNOPSIS and usage() clear that -t precedes -T;
spotted by Tamas Tevesh, via dhartmei@@;

also, add -o to usage(), and note that /ruleset is now the correct syntax,
not :ruleset;

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.219 2004/07/19 22:04:00 dlg Exp $ */
d1073 1
a1073 1
pfctl_fopen(const char *name, const char *mode) 
@


1.219
log
@print the correct labels when displaying timeouts with pfctl (eg, pfctl -st).
From Chris Pascoe.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.218 2004/07/16 23:44:24 frantzen Exp $ */
d197 2
a198 2
	fprintf(stderr, "usage: %s [-AdeghNnOqRrvz] ", __progname);
	fprintf(stderr, "[-a anchor[:ruleset]] [-D macro=value]\n");
d203 3
a205 2
	fprintf(stderr, "[-s modifier] [-T command [address ...]] ");
	fprintf(stderr, "[-t table] [-x level]\n");
@


1.218
log
@'pfctl -o' ruleset optimizer that doesnt change the meaning of the final ruleset
- remove identical and subsetted rules
- when advantageous merge rules w/ similar addresses into a table and one rule
- re-order rules to improve skip step performance (can do better w/ kernel mods)
- 'pfctl -oo' will load the currently running ruleset and use it as a profile
to direct the optimization of quicked rules
ok henning@@ mcbride@@.  man page help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.217 2004/05/21 23:10:48 dhartmei Exp $ */
d779 2
a780 1
		if (i >= PFTM_ADAPTIVE_START && i <= PFTM_ADAPTIVE_END)
@


1.217
log
@Use '/' instead of ':' as separator for anchor path components. Note that
the parser now needs quotes around paths containing separators.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.216 2004/05/19 17:50:51 dhartmei Exp $ */
d874 33
d998 1
d1036 5
d1387 1
a1387 1
	    "a:AdD:eqf:F:ghi:k:nNOp:rRs:t:T:vx:z")) != -1) {
d1449 6
@


1.216
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.215 2004/05/05 23:16:03 frantzen Exp $ */
d1315 1
a1315 1
			strlcat(sub, ":", sizeof(sub));
@


1.215
log
@Use RFC1323 PAWS timestamps as a logical extension to the conventional TCP
sequence numbers by taking advantage of the maximum 1KHz clock as an upperbound
on the timestamp.  Typically gains 10 to 18 bits of additional security against
blind data insertion attacks.  More if the TS Echo wasn't optional :-(
Enabled with:  scrub on !lo0 all reassemble tcp
ok dhartmei@@.  documentation help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.214 2004/04/09 12:42:06 cedric Exp $ */
d62 2
a63 2
int	 pfctl_clear_rules(int, int, char *, char *);
int	 pfctl_clear_nat(int, int, char *, char *);
d69 1
a69 1
	    char *, char *);
d71 2
a72 2
int	 pfctl_show_rules(int, int, int, char *, char *);
int	 pfctl_show_nat(int, int, char *, char *);
d257 1
a257 1
pfctl_clear_rules(int dev, int opts, char *anchorname, char *rulesetname)
a260 28
	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int mnr, nr, r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = mnr - 1; nr >= 0; --nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_clear_rules(dev, opts | PF_OPT_QUIET,
			    anchorname, pr.name);
			if (r)
				return (r);
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "rules cleared\n");
		return (0);
	}
d263 2
a264 2
	if (pfctl_add_trans(&t, PF_RULESET_SCRUB, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_FILTER, anchorname, rulesetname) ||
d274 1
a274 1
pfctl_clear_nat(int dev, int opts, char *anchorname, char *rulesetname)
a277 28
	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int mnr, nr, r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = mnr - 1; nr >= 0; --nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_clear_nat(dev, opts | PF_OPT_QUIET,
			    anchorname, pr.name);
			if (r)
				return (r);
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "nat cleared\n");
		return (0);
	}
d280 3
a282 3
	if (pfctl_add_trans(&t, PF_RULESET_NAT, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_BINAT, anchorname, rulesetname) ||
	    pfctl_add_trans(&t, PF_RULESET_RDR, anchorname, rulesetname) ||
d300 1
a300 1
	if (pfctl_add_trans(&t, PF_RULESET_ALTQ, "", "") ||
d444 1
a444 1
    u_int32_t ticket, int r_action, char *anchorname, char *rulesetname)
a451 1
	memcpy(pp.ruleset, rulesetname, sizeof(pp.ruleset));
d529 1
a529 2
pfctl_show_rules(int dev, int opts, int format, char *anchorname,
    char *rulesetname)
a534 29
	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		if (opts & PF_OPT_SHOWALL && pr.nr)
			pfctl_print_title("FILTER RULES:");
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_show_rules(dev, opts, format, anchorname,
			    pr.name);
			if (r)
				return (r);
		}
		return (0);
	}

a536 1
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
d565 1
a565 1
		    nr, pr.ticket, PF_SCRUB, anchorname, rulesetname) != 0)
d581 1
a581 1
			print_rule(&pr.rule, rule_numbers);
d600 1
a600 1
		    nr, pr.ticket, PF_PASS, anchorname, rulesetname) != 0)
d616 1
a616 1
			print_rule(&pr.rule, rule_numbers);
d625 1
a625 1
pfctl_show_nat(int dev, int opts, char *anchorname, char *rulesetname)
a631 26
	if (*anchorname && !*rulesetname) {
		struct pfioc_ruleset pr;
		int r;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
			return (-1);
		}
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			r = pfctl_show_nat(dev, opts, anchorname, pr.name);
			if (r)
				return (r);
		}
		return (0);
	}

a633 1
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
d648 1
a648 2
			    pr.ticket, nattype[i], anchorname,
			    rulesetname) != 0)
d654 2
a655 1
			print_rule(&pr.rule, opts & PF_OPT_VERBOSE2);
d834 1
a834 1
pfctl_add_rule(struct pfctl *pf, struct pf_rule *r)
d870 1
a870 1
		errx(1, "Invalid rule type");
d877 1
a877 3
		    sizeof(pr.anchor) ||
		    strlcpy(pr.ruleset, pf->ruleset, sizeof(pr.ruleset)) >=
		    sizeof(pr.ruleset))
d881 1
a881 2
		pr.ticket = pfctl_get_ticket(pf->trans, rs_num, pf->anchor,
		    pf->ruleset);
d884 1
d889 1
a889 1
		print_rule(r, pf->opts & PF_OPT_VERBOSE2);
d918 1
a918 1
    char *rulesetname, struct pfr_buffer *trans)
d944 1
a944 3
	    sizeof(trs.pfrt_anchor)) >= sizeof(trs.pfrt_anchor) ||
	    strlcpy(trs.pfrt_ruleset, rulesetname,
	    sizeof(trs.pfrt_ruleset)) >= sizeof(trs.pfrt_ruleset))
a964 1
	pf.ruleset = rulesetname;
d968 3
a970 6
			if (pfctl_add_trans(t, PF_RULESET_NAT, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_BINAT, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_RDR, anchorname,
			    rulesetname))
d974 1
a974 2
			if (pfctl_add_trans(t, PF_RULESET_ALTQ, anchorname,
			    rulesetname))
d978 2
a979 4
			if (pfctl_add_trans(t, PF_RULESET_SCRUB, anchorname,
			    rulesetname) ||
			    pfctl_add_trans(t, PF_RULESET_FILTER, anchorname,
			    rulesetname))
d983 1
a983 2
			if (pfctl_add_trans(t, PF_RULESET_TABLE, anchorname,
			    rulesetname))
d990 1
a990 1
			    anchorname, rulesetname);
d993 1
a993 1
			    anchorname, rulesetname);
d1009 1
a1009 1
	if (!anchorname[0] && !rulesetname[0])
d1290 2
a1291 1
	u_int32_t nr, mnr;
d1293 13
a1305 2
	if (!*anchorname) {
		struct pfioc_anchor pa;
d1307 13
a1319 28
		memset(&pa, 0, sizeof(pa));
		if (ioctl(dev, DIOCGETANCHORS, &pa)) {
			warn("DIOCGETANCHORS");
			return (-1);
		}
		mnr = pa.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pa.nr = nr;
			if (ioctl(dev, DIOCGETANCHOR, &pa)) {
				warn("DIOCGETANCHOR");
				return (-1);
			}
			if (!(opts & PF_OPT_VERBOSE) &&
			    !strcmp(pa.name, PF_RESERVED_ANCHOR))
				continue;
			printf("  %s\n", pa.name);
		}
	} else {
		struct pfioc_ruleset pr;

		memset(&pr, 0, sizeof(pr));
		memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
		if (ioctl(dev, DIOCGETRULESETS, &pr)) {
			if (errno == EINVAL)
				fprintf(stderr, "No rulesets in anchor '%s'.\n",
				    anchorname);
			else
				err(1, "DIOCGETRULESETS");
a1320 8
		}
		mnr = pr.nr;
		for (nr = 0; nr < mnr; ++nr) {
			pr.nr = nr;
			if (ioctl(dev, DIOCGETRULESET, &pr))
				err(1, "DIOCGETRULESET");
			printf("  %s:%s\n", pr.anchor, pr.name);
		}
d1342 1
a1342 2
	char	anchorname[PF_ANCHOR_NAME_SIZE];
	char	rulesetname[PF_RULESET_NAME_SIZE];
a1476 1
	memset(rulesetname, 0, sizeof(rulesetname));
d1478 4
a1481 23
		char *t;

		if ((t = strchr(anchoropt, ':')) == NULL) {
			if (strlcpy(anchorname, anchoropt,
			    sizeof(anchorname)) >= sizeof(anchorname))
				errx(1, "anchor name '%s' too long",
				    anchoropt);
		} else {
			char *p;

			if ((p = strdup(anchoropt)) == NULL)
				err(1, "anchoropt: strdup");
			t = strsep(&p, ":");
			if (*t == '\0' || *p == '\0')
				errx(1, "anchor '%s' invalid", anchoropt);
			if (strlcpy(anchorname, t, sizeof(anchorname)) >=
			    sizeof(anchorname))
				errx(1, "anchor name '%s' too long", t);
			if (strlcpy(rulesetname, p, sizeof(rulesetname)) >=
			    sizeof(rulesetname))
				errx(1, "ruleset name '%s' too long", p);
			free(t); /* not p */
		}
d1511 1
a1511 2
			pfctl_show_rules(dev, opts, 0, anchorname,
			    rulesetname);
d1515 1
a1515 2
			pfctl_show_rules(dev, opts, 1, anchorname,
			    rulesetname);
d1519 1
a1519 1
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
d1544 2
a1545 3
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
			pfctl_show_rules(dev, opts, 0, anchorname,
			    rulesetname);
d1550 1
a1550 1
			pfctl_show_rules(dev, opts, 1, anchorname, rulesetname);
d1553 1
a1553 1
			pfctl_show_tables(anchorname, rulesetname, opts);
d1557 1
a1557 1
			pfctl_show_tables(anchorname, rulesetname, opts);
d1572 1
a1572 1
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
d1575 1
a1575 1
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
d1590 4
a1593 4
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			pfctl_clear_tables(anchorname, rulesetname, opts);
			if (!*anchorname && !*rulesetname) {
d1605 1
a1605 1
			pfctl_clear_tables(anchorname, rulesetname, opts);
d1614 1
a1614 1
		    tblcmdopt, rulesopt, anchorname, rulesetname, opts);
d1623 1
a1623 2
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname,
		    NULL))
@


1.214
log
@Do not try to load directories. found+ok mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.213 2004/03/20 09:31:42 david Exp $ */
d125 1
d135 1
d145 1
d155 1
@


1.213
log
@make pfctl -s osfp work and remove -o option from manpage; ok deraadt@@
pointed out by David Hill <davidh at wmis dot net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.212 2004/03/15 15:25:44 dhartmei Exp $ */
d37 1
d1065 1
a1065 1
		if ((fin = fopen(filename, "r")) == NULL) {
d1152 21
@


1.212
log
@cast %llu arguments to unsigned long long, from Max Laier,
ok henning@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.211 2004/03/03 02:00:23 deraadt Exp $ */
d173 1
a173 1
	"Interfaces", "labels", "timeouts", "memory", "Tables", "ospf",
@


1.211
log
@no newline in errx, bad cedric; spotted by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.210 2004/02/27 10:42:00 henning Exp $ */
d566 3
a568 2
			    rule->evaluations, rule->packets,
			    rule->bytes, rule->states);
d656 3
a658 2
				    pr.rule.evaluations, pr.rule.packets,
				    pr.rule.bytes);
d691 3
a693 2
				    pr.rule.evaluations, pr.rule.packets,
				    pr.rule.bytes);
@


1.210
log
@make pfctl -s all a bit more useful again by not printing a lllooooooottttt of
OS fingerprints and a list of interface drivers...
cedric deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.209 2004/02/26 15:43:51 cedric Exp $ */
d378 1
a378 1
		errx(1, "invalid interface: %s\n", iface);
d405 1
a405 1
		errx(1, "invalid interface: %s\n", iface);
@


1.209
log
@Fix/Simplify printing of titles with "pfctl -s all". ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.208 2004/02/25 10:09:40 cedric Exp $ */
a1687 1
			pfctl_show_ifaces(ifaceopt, opts);
@


1.208
log
@Don't clear global stuff when an anchor is given in addition to -Fa.
Ok mcbride@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.207 2004/02/19 21:37:01 cedric Exp $ */
d710 1
a710 1
	int i;
a740 13
	if (opts & PF_OPT_SHOWALL) {
		for (i = 0; i < 3; i++) {
			pr.rule.action = nattype[i];
			if (ioctl(dev, DIOCGETRULES, &pr)) {
				warn("DIOCGETRULES");
				return (-1);
			}
			if (pr.nr > 0) {
				pfctl_print_title("TRANSLATION RULES:");
				break;
			}
		}
	}
d758 4
a799 2
		else if (opts & PF_OPT_SHOWALL)
			pfctl_print_title("SOURCE TRACKING NODES:");
d803 2
d866 1
a866 1
	if (opts && PF_OPT_SHOWALL)
d878 1
a878 1
	if (opts && PF_OPT_SHOWALL)
@


1.207
log
@Makes pfctl -ss and pfctl -sq use optional -i argument.
ok dhartmei@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.206 2004/02/19 21:29:51 cedric Exp $ */
a1734 4
			pfctl_clear_altq(dev, opts);
			pfctl_clear_states(dev, ifaceopt, opts);
			pfctl_clear_src_nodes(dev, opts);
			pfctl_clear_stats(dev, opts);
d1736 7
a1742 1
			pfctl_clear_fingerprints(dev, opts);
@


1.206
log
@Makes pfctl -Fs and pfctl -w works with the optional -i specifier.
Kernel/Userland Sync needed. ok dhartmei@@ jmc@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.205 2004/02/17 08:48:29 cedric Exp $ */
d73 1
a73 1
int	 pfctl_show_states(int, u_int8_t, int);
d822 1
a822 1
pfctl_show_states(int dev, u_int8_t proto, int opts)
d828 1
a828 1
	int i;
a850 2
		else if (opts && PF_OPT_SHOWALL)
			pfctl_print_title("STATES:");
d854 8
a861 4
	for (i = 0; i < ps.ps_len; i += sizeof(*p)) {
		if (!proto || (p->proto == proto))
			print_state(p, opts);
		p++;
d1663 2
a1664 1
			pfctl_show_altq(dev, opts, opts & PF_OPT_VERBOSE2);
d1667 1
a1667 1
			pfctl_show_states(dev, 0, opts);
d1688 2
a1689 2
			pfctl_show_altq(dev, opts, 0);
			pfctl_show_states(dev, 0, opts);
@


1.205
log
@add -i flag, use it for -sI as a start. ok henning@@, ok+test mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.204 2004/02/12 11:03:45 jmc Exp $ */
d65 2
a66 2
int	 pfctl_clear_states(int, int);
int	 pfctl_kill_states(int, int);
d371 1
a371 1
pfctl_clear_states(int dev, int opts)
d373 8
a380 1
	if (ioctl(dev, DIOCCLRSTATES))
d383 1
a383 1
		fprintf(stderr, "states cleared\n");
d388 1
a388 1
pfctl_kill_states(int dev, int opts)
d403 3
d1721 1
a1721 1
			pfctl_clear_states(dev, opts);
d1733 1
a1733 1
			pfctl_clear_states(dev, opts);
d1748 1
a1748 1
		pfctl_kill_states(dev, opts);
@


1.204
log
@- sort SYNOPSIS and options list
- add -p to SYNOPSIS
- uppercase start of sentence
- sync usage() w/ SYNOPSIS
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.203 2004/02/12 02:05:32 beck Exp $ */
d89 1
d195 2
a196 3
	fprintf(stderr, "[-F modifier] [-f file] [-k host] [-p device] \n");
	fprintf(stderr, "             ");
	fprintf(stderr, "[-s modifier] [-T command [address ...]]\n");
d198 1
d1454 2
a1455 2
	while ((ch = getopt(argc, argv, "a:AdD:eqf:F:ghk:nNOp:rRs:t:T:vx:z")) !=
		-1) {
d1484 3
d1684 1
a1684 1
			pfctl_show_ifaces(opts);
d1694 1
a1694 1
			pfctl_show_ifaces(opts);
@


1.203
log
@add -p flag to specify the device - ok mcbride@@, henning@@ with no objections
from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.202 2004/02/10 22:26:55 dhartmei Exp $ */
d191 1
a191 1
	fprintf(stderr, "usage: %s [-AdeghnNqrROvz] ", __progname);
d194 1
a194 1
	fprintf(stderr, "[-f file] [-F modifier] [-k host] [-p device] \n");
d196 1
a196 1
	fprintf(stderr, "[-s modifier] [-t table]\n");
d198 1
a198 1
	fprintf(stderr, "[-T command [address ...]] [-x level]\n");
@


1.202
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.201 2004/02/10 17:53:37 henning Exp $ */
d88 1
d194 1
a194 1
	fprintf(stderr, "[-f file] [-F modifier] [-k host] [-s modifier]\n");
d196 3
a198 1
	fprintf(stderr, "[-t table] [-T command [address ...]] [-x level]\n");
d1453 1
a1453 1
	while ((ch = getopt(argc, argv, "a:AdD:eqf:F:ghk:nNOrRs:t:T:vx:z")) !=
d1517 3
d1609 1
a1609 1
		dev = open("/dev/pf", mode);
d1611 1
a1611 1
			err(1, "/dev/pf");
d1614 1
a1614 1
		dev = open("/dev/pf", O_RDONLY);
@


1.201
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.200 2004/02/04 10:43:18 mcbride Exp $ */
d68 1
a68 1
	     char *, char *);
d1025 6
a1030 6
	FILE *fin;
	struct pfr_buffer      *t, buf;
	struct pfioc_altq	pa;
	struct pfctl		pf;
	struct pfr_table	trs;
	int			osize;
@


1.200
log
@Fix a number of bugs with setting pool limits which I introduced with
source-tracking. Found by Pyun YongHyeon.
Also add support to pfctl to set the src-nodes pool limit.

"Luckily" some of the bugs cancel each other out; update kernel before
pfctl.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.199 2004/01/29 01:25:13 mcbride Exp $ */
d425 2
a426 1
				errx(1, "getaddrinfo: %s", gai_strerror(ret_ga));
@


1.199
log
@Clean up 'pfctl -s all' output.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.198 2003/12/31 22:14:41 deraadt Exp $ */
d106 1
d898 1
a898 1
		pl.index = i;
d1154 1
a1154 1
			pl.index = i;
@


1.198
log
@spacing.  note this, cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.197 2003/12/31 11:18:24 cedric Exp $ */
d75 2
a76 2
int	 pfctl_show_timeouts(int);
int	 pfctl_show_limits(int);
d96 2
d554 9
d568 1
a568 1
	u_int32_t nr, mnr;
d585 2
d603 8
d616 6
d644 2
d678 2
d725 13
d793 2
d835 2
d857 2
d864 1
a864 1
pfctl_show_timeouts(int dev)
d869 2
d888 1
a888 1
pfctl_show_limits(int dev)
d893 2
d1651 1
a1651 1
			pfctl_show_timeouts(dev);
d1654 1
a1654 1
			pfctl_show_limits(dev);
d1657 1
d1660 1
a1662 1
			pfctl_show_nat(dev, opts, anchorname, rulesetname);
d1668 2
a1669 2
			pfctl_show_timeouts(dev);
			pfctl_show_limits(dev);
@


1.197
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.196 2003/12/19 16:12:43 henning Exp $ */
d1342 1
a1342 1
			if (!(opts & PF_OPT_VERBOSE) && 
@


1.196
log
@i wrote much of these, assert my copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.195 2003/12/16 00:32:59 mcbride Exp $ */
d168 2
a169 1
	"labels", "timeouts", "memory", "Tables", "ospf", "all", NULL
a1335 2
		if (!(opts & PF_OPT_QUIET))
			printf("%u anchors:\n", mnr);
d1342 3
a1360 2
		if (!(opts & PF_OPT_QUIET))
			printf("%u rulesets in anchor %s:\n", mnr, anchorname);
d1507 1
a1507 1
		} else {
a1508 6
			if (opts & PF_OPT_NOACTION) {
				dev = open("/dev/pf", mode);
				if (dev >= 0)
					opts |= PF_OPT_DUMMYACTION;
			}
		}
d1552 3
d1617 1
d1625 3
@


1.195
log
@hostid is stored in network byte order, print in host byte order.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.194 2003/12/15 07:11:30 mcbride Exp $ */
d5 1
@


1.194
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.193 2003/12/15 00:02:03 mcbride Exp $ */
d1228 1
a1228 1
		printf("set hostid %#08x\n", hostid);
@


1.193
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.192 2003/11/14 13:51:09 henning Exp $ */
d1211 18
@


1.192
log
@allow the debuglevel to  be set from pf.conf (set debug)

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.191 2003/11/06 15:01:30 henning Exp $ */
d63 1
d71 1
d73 1
a73 1
int	 pfctl_show_status(int);
d161 2
a162 1
	"nat", "queue", "rules", "state", "info", "Tables", "osfp", "all", NULL
d166 2
a167 2
	"nat", "queue", "rules", "Anchors", "state", "info", "labels",
	"timeouts", "memory", "Tables", "osfp", "all", NULL
d352 10
d718 40
d799 1
a799 1
pfctl_show_status(int dev)
d807 1
a807 1
	print_status(&status);
d1574 3
d1578 1
a1578 1
			pfctl_show_status(dev);
d1594 2
a1595 1
			pfctl_show_status(dev);
d1626 3
d1637 1
@


1.191
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.190 2003/10/02 17:01:16 mcbride Exp $ */
d1158 31
@


1.190
log
@clean up p = realloc(p

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.189 2003/09/26 21:44:09 cedric Exp $ */
d873 1
a873 1
		    pf->ruleset);    
d930 1
a930 1
    
@


1.189
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.188 2003/08/29 21:47:36 cedric Exp $ */
d709 1
a709 1
	char *inbuf = NULL;
d717 2
a718 2
			ps.ps_buf = inbuf = realloc(inbuf, len);
			if (inbuf == NULL)
d720 1
@


1.188
log
@Document interactions between tables and anchors.
Add a warning on global/anchor name clashes to help prevent mistakes from our
users during the 3.3 -> 3.4 switch.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.187 2003/08/22 17:24:27 dhartmei Exp $ */
d242 1
a242 1
	struct pfioc_rule pr;
d272 7
a278 13
	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
	pr.rule.action = PF_SCRUB;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
	pr.rule.action = PF_PASS;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
d287 1
a287 1
	struct pfioc_rule pr;
d317 8
a324 18
	memset(&pr, 0, sizeof(pr));
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
	pr.rule.action = PF_NAT;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
	pr.rule.action = PF_BINAT;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
	pr.rule.action = PF_RDR;
	if (ioctl(dev, DIOCBEGINRULES, &pr))
		err(1, "DIOCBEGINRULES");
	else if (ioctl(dev, DIOCCOMMITRULES, &pr))
		err(1, "DIOCCOMMITRULES");
d333 1
a333 1
	struct pfioc_altq pa;
d337 6
a342 5
	memset(&pa, 0, sizeof(pa));
	if (ioctl(dev, DIOCBEGINALTQS, &pa.ticket))
		err(1, "DIOCBEGINALTQS");
	else if (ioctl(dev, DIOCCOMMITALTQS, &pa.ticket))
		err(1, "DIOCCOMMITALTQS");
d824 2
a825 1
	u_int8_t rs_num;
d863 6
d871 5
a875 4
		memcpy(&pf->prule[rs_num]->rule, r,
		    sizeof(pf->prule[rs_num]->rule));
		pf->prule[rs_num]->pool_ticket = pf->paddr.ticket;
		if (ioctl(pf->dev, DIOCADDRULE, pf->prule[rs_num]))
d908 1
a908 1
    char *rulesetname)
d914 1
a914 1
	struct pfioc_rule	pr[PF_RULESET_MAX];
d918 1
a918 1
	int			i;
d920 10
a932 5
	for (i = 0; i < PF_RULESET_MAX; i++) {
		memset(&pr[i], 0, sizeof(pr[i]));
		memcpy(pr[i].anchor, anchorname, sizeof(pr[i].anchor));
		memcpy(pr[i].ruleset, rulesetname, sizeof(pr[i].ruleset));
	}
a947 30
	if ((opts & PF_OPT_NOACTION) == 0) {
		if ((loadopt & PFCTL_FLAG_NAT) != 0) {
			pr[PF_RULESET_NAT].rule.action = PF_NAT;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_NAT]))
				ERR("DIOCBEGINRULES");
			pr[PF_RULESET_RDR].rule.action = PF_RDR;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_RDR]))
				ERR("DIOCBEGINRULES");
			pr[PF_RULESET_BINAT].rule.action = PF_BINAT;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_BINAT]))
				ERR("DIOCBEGINRULES");
		}
		if (((altqsupport && (loadopt & PFCTL_FLAG_ALTQ) != 0)) &&
		    ioctl(dev, DIOCBEGINALTQS, &pa.ticket)) {
			ERR("DIOCBEGINALTQS");
		}
		if ((loadopt & PFCTL_FLAG_FILTER) != 0) {
			pr[PF_RULESET_SCRUB].rule.action = PF_SCRUB;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_SCRUB]))
				ERR("DIOCBEGINRULES");
			pr[PF_RULESET_FILTER].rule.action = PF_PASS;
			if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_FILTER]))
				ERR("DIOCBEGINRULES");
		}
		if (loadopt & PFCTL_FLAG_TABLE) {
			if (pfr_ina_begin(&trs, &pf.tticket, NULL, 0) != 0)
				ERR("begin table");
		}
	}
	/* fill in callback data */
d951 2
d954 1
a954 3
	for (i = 0; i < PF_RULESET_MAX; i++) {
		pf.prule[i] = &pr[i];
	}
d958 37
d1002 1
a1002 1
	if ((altqsupport && (loadopt & PFCTL_FLAG_ALTQ) != 0))
a1004 34
	if ((opts & PF_OPT_NOACTION) == 0) {
		if ((loadopt & PFCTL_FLAG_NAT) != 0) {
			pr[PF_RULESET_NAT].rule.action = PF_NAT;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_NAT]) &&
			    (errno != EINVAL || pf.rule_nr))
				ERR("DIOCCOMMITRULES NAT");
			pr[PF_RULESET_RDR].rule.action = PF_RDR;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_RDR]) &&
			    (errno != EINVAL || pf.rule_nr))
				ERR("DIOCCOMMITRULES RDR");
			pr[PF_RULESET_BINAT].rule.action = PF_BINAT;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_BINAT]) &&
			    (errno != EINVAL || pf.rule_nr))
				ERR("DIOCCOMMITRULES BINAT");
		}
		if (((altqsupport && (loadopt & PFCTL_FLAG_ALTQ) != 0)) &&
		    ioctl(dev, DIOCCOMMITALTQS, &pa.ticket))
			ERR("DIOCCOMMITALTQS");
		if ((loadopt & PFCTL_FLAG_FILTER) != 0) {
			pr[PF_RULESET_SCRUB].rule.action = PF_SCRUB;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_SCRUB]) &&
			    (errno != EINVAL || pf.rule_nr))
				ERR("DIOCCOMMITRULES SCRUB");
			pr[PF_RULESET_FILTER].rule.action = PF_PASS;
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_FILTER]) &&
			    (errno != EINVAL || pf.rule_nr))
				ERR("DIOCCOMMITRULES FILTER");
		}
		if (loadopt & PFCTL_FLAG_TABLE) {
			if (pfr_ina_commit(&trs, pf.tticket, NULL, NULL, 0))
				ERR("commit table");
			pf.tdirty = 0;
		}
	}
d1010 1
a1010 1
		if (pfctl_load_anchors(dev, opts) == -1)
d1013 3
d1019 7
a1025 3
	if (pf.tdirty) /* cleanup kernel leftover */
		pfr_ina_begin(&trs, NULL, NULL, 0);
	exit(1);
d1571 2
a1572 1
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname))
@


1.187
log
@move pfctl_file_fingerprints() call, table commands can use -f themselves
(like pfctl -t spammers -vvTt -f file, causing EPERM on DIOCOSFPFLUSH).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.186 2003/08/21 19:12:08 frantzen Exp $ */
d1592 1
a1592 1
	if (rulesopt != NULL)
d1595 4
@


1.186
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.185 2003/08/04 17:29:44 dhartmei Exp $ */
a1581 3
	if (rulesopt && pfctl_file_fingerprints(dev, opts, PF_OSFP_FILE))
		error = 1;

d1587 4
@


1.185
log
@Not every suggested patch is perfect :)

ERRX() has two effects: the message printing and goto _error; which causes
exit(1). While we don't want the message if pfctl was invoked with -n, we
DO want to abort. Otherwise subsequent 'load anchor' statements will get
executed, for instance, and the return value is handy for scripts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.184 2003/08/04 12:17:01 henning Exp $ */
d159 1
a159 1
	"nat", "queue", "rules", "state", "info", "Tables", "all", NULL
d164 1
a164 1
	"timeouts", "memory", "Tables", "all", NULL
d173 1
a173 1
	"none", "urgent", "misc", NULL
d1200 3
d1492 1
d1497 1
d1502 1
d1521 2
d1533 1
d1538 4
d1569 4
d1582 3
d1609 3
@


1.184
log
@don't whine about "cannot load ruleset" when ruleset load wasn't desired
(with pfctl -n)
Jared Yanovich <phirerunner@@comcast.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.183 2003/07/31 22:25:54 cedric Exp $ */
d990 7
a996 2
	if ((parse_rules(fin, &pf) < 0) && ((opts & PF_OPT_NOACTION) == 0))
		ERRX("Syntax error in config file: pf rules not loaded");
@


1.183
log
@Make table tickets per-ruleset instead of global.
Make table tickets u_int32_t for consistency with other parts of PF.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.182 2003/07/18 06:30:07 cedric Exp $ */
d990 1
a990 1
	if (parse_rules(fin, &pf) < 0)
@


1.182
log
@Simplify handling of flags (-R, -N...). Remove PFCTL_FLAG_ALL.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.181 2003/07/11 08:29:34 cedric Exp $ */
d924 1
d929 1
d935 5
d975 1
a975 1
			if (pfr_ina_begin(&pf.tticket, NULL, 0) != 0)
d1024 1
a1024 1
			if (pfr_ina_commit(pf.tticket, NULL, NULL, 0))
d1041 1
a1041 1
		pfr_ina_begin(NULL, NULL, 0);
@


1.181
log
@Better parsing and -v support for tables:

  - remove the tableaddrs and tableaddr yacc production and reuse
    host_list instead.
  - produce better error messages.
  - do not load addresses from external file when it is not
    required (like with -R option).
  - store initializers in a new node_tinit linked list before
    putting them into the address buffer (see next point).
  - add a new print_tabledef() function, which makes "pfctl -nvf"
    print something useful for table definitions, which in turn
    makes it possible to write better regress tests (see first chunk
    of the diff) and bring table definition consistant with other
    parsed rules.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.180 2003/07/03 21:09:13 cedric Exp $ */
d89 1
a89 1
int		 loadopt = PFCTL_FLAG_ALL;
d843 1
a843 1
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) == 0)
d849 1
a849 1
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) == 0)
d855 1
a855 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) == 0)
d861 1
a861 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) == 0)
d867 1
a867 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) == 0)
d895 1
a895 1
	    (loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) {
d944 1
a944 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
d955 1
a955 2
		if (((altqsupport && (loadopt &
		    (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0)) &&
d959 1
a959 1
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) {
d967 1
a967 1
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) {
d985 1
a985 1
	if ((altqsupport && (loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0))
d989 1
a989 1
		if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
d1003 1
a1003 2
		if (((altqsupport && (loadopt &
		    (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0)) &&
d1006 1
a1006 1
		if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) {
d1016 1
a1016 1
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) {
d1047 1
a1047 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1086 1
a1086 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1120 1
a1120 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
d1149 1
a1149 1
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) == 0)
a1339 1
			loadopt &= ~PFCTL_FLAG_ALL;
a1352 1
			loadopt &= ~PFCTL_FLAG_ALL;
a1355 1
			loadopt &= ~PFCTL_FLAG_ALL;
a1358 1
			loadopt &= ~PFCTL_FLAG_ALL;
d1408 1
a1408 1
			loadopt = PFCTL_FLAG_TABLE;
d1423 2
d1452 1
a1452 6
		if (loadopt & PFCTL_FLAG_ALL) {
			loadopt &= ~PFCTL_FLAG_ALL;
			loadopt |= PFCTL_FLAG_FILTER;
			loadopt |= PFCTL_FLAG_NAT;
			loadopt |= PFCTL_FLAG_TABLE;
		}
@


1.180
log
@Bye bye atexit(), bye bye globals...
The pfctl.c part will probably need some further improvements.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.179 2003/07/03 09:13:06 cedric Exp $ */
a923 1
	struct pfr_buffer	ab;
a927 2
	memset(&ab, 0, sizeof(ab));
	ab.pfrb_type = PFRB_ADDRS;
d969 1
a969 1
		        if (pfr_ina_begin(&pf.tticket, NULL, 0) != 0)
a977 1
	pf.ab = &ab;
@


1.179
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.178 2003/06/29 12:22:39 dhartmei Exp $ */
d917 3
d950 1
a950 1
				err(1, "DIOCBEGINRULES");
d953 1
a953 1
				err(1, "DIOCBEGINRULES");
d956 1
a956 1
				err(1, "DIOCBEGINRULES");
d961 1
a961 1
			err(1, "DIOCBEGINALTQS");
d966 1
a966 1
				err(1, "DIOCBEGINRULES");
d969 5
a973 1
				err(1, "DIOCBEGINRULES");
a974 2
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL))
			pfctl_begin_table();
d989 1
a989 1
		errx(1, "Syntax error in config file: pf rules not loaded");
d992 1
a992 1
			errx(1, "errors in altq config");
d998 1
a998 1
				err(1, "DIOCCOMMITRULES NAT");
d1002 1
a1002 1
				err(1, "DIOCCOMMITRULES RDR");
d1006 1
a1006 1
				err(1, "DIOCCOMMITRULES BINAT");
d1011 1
a1011 1
			err(1, "DIOCCOMMITALTQS");
d1016 1
a1016 1
				err(1, "DIOCCOMMITRULES SCRUB");
d1020 6
a1025 1
				err(1, "DIOCCOMMITRULES FILTER");
a1026 2
		if (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL))
			pfctl_commit_table();
d1034 1
a1034 1
			return (-1);
d1037 8
@


1.178
log
@Replace assert(3) calls with warnx(3), if the warning is relevant at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.177 2003/06/13 12:10:42 cedric Exp $ */
d921 1
d926 2
d976 1
@


1.177
log
@Make "show Anchor" obey quiet flag.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.176 2003/06/03 12:18:57 henning Exp $ */
a51 1
#include <assert.h>
a1509 2
		default:
			assert(0);
a1540 2
		default:
			assert(0);
a1570 2
		default:
			assert(0);
@


1.176
log
@process show options before ruleset reload
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.175 2003/05/19 02:32:47 henning Exp $ */
d1225 2
a1226 1
		printf("%u anchors:\n", mnr);
d1249 2
a1250 1
		printf("%u rulesets in anchor %s:\n", mnr, anchorname);
@


1.175
log
@don't print altq en-/disabled - there's no point, you can't turn them on
and off independently. so only complain if there's a real error.

ok dhartmei@@ pb@@ camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.173 2003/05/18 20:25:15 henning Exp $ */
a1462 45
	if (clearopt != NULL) {
		switch (*clearopt) {
		case 'r':
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			break;
		case 'n':
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			break;
		case 'q':
			pfctl_clear_altq(dev, opts);
			break;
		case 's':
			pfctl_clear_states(dev, opts);
			break;
		case 'i':
			pfctl_clear_stats(dev, opts);
			break;
		case 'a':
			pfctl_clear_rules(dev, opts, anchorname, rulesetname);
			pfctl_clear_nat(dev, opts, anchorname, rulesetname);
			pfctl_clear_altq(dev, opts);
			pfctl_clear_states(dev, opts);
			pfctl_clear_stats(dev, opts);
			pfctl_clear_tables(anchorname, rulesetname, opts);
			break;
		case 'T':
			pfctl_clear_tables(anchorname, rulesetname, opts);
			break;
		default:
			assert(0);
		}
	}
	if (state_killers)
		pfctl_kill_states(dev, opts);

	if (tblcmdopt != NULL) {
		error = pfctl_command_tables(argc, argv, tableopt,
		    tblcmdopt, rulesopt, anchorname, rulesetname, opts);
		rulesopt = NULL;
	}

	if (rulesopt != NULL)
		if (pfctl_rules(dev, rulesopt, opts, anchorname, rulesetname))
			error = 1;

d1513 45
@


1.174
log
@style consistency
@
text
@d204 3
a206 10
	if (altqsupport) {
		if (ioctl(dev, DIOCSTARTALTQ)) {
			if (errno == EEXIST)
				errx(1, "altq already enabled");
			else
				err(1, "DIOCSTARTALTQ");
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "altq enabled\n");
	}
d223 2
a224 5
	if (altqsupport) {
		if (ioctl(dev, DIOCSTOPALTQ)) {
			if (errno == ENOENT)
				errx(1, "altq not enabled");
			else
a225 4
		}
		if ((opts & PF_OPT_QUIET) == 0)
			fprintf(stderr, "altq disabled\n");
	}
@


1.173
log
@in the pfctl -vsr output (-vvsr/-gvvsr as well), indent instead of extra
newline. requested by markus@@, dhartmei and myself agree
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.172 2003/05/17 02:46:22 mcbride Exp $ */
d82 1
a82 1
char	*rulesopt;
d85 2
a86 2
char	*anchoropt;
char	*tableopt;
d88 4
a91 4
int	 state_killers;
char	*state_kill[2];
int	 loadopt = PFCTL_FLAG_ALL;
int	 altqsupport;
d93 1
a93 1
int dev = -1;
d95 1
a95 1
const char *infile;
@


1.172
log
@A little bugfix. We want pfioc_states, not pfioc_state.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.171 2003/05/12 01:25:31 dhartmei Exp $ */
d545 1
a545 1
		printf("[ Skip steps: ");
d557 1
a557 1
		printf("[ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n",
d561 2
a562 2
		printf("[ Evaluations: %-8llu  Packets: %-8llu  "
			    "Bytes: %-10llu  States: %-6u]\n\n",
@


1.171
log
@Adaptive timeout value scaling. Allows to reduce timeout values as the
number of state table entries grows, so entries time out faster before
the table fills up. Works both globally and per-rule. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.170 2003/05/10 00:45:24 henning Exp $ */
d755 1
a755 1
		if (ps.ps_len + sizeof(struct pfioc_state) < len)
@


1.170
log
@support loading of anchors from within the main ruleset via
load anchor anchorname:rulesetname file /path/to/file

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.169 2003/04/30 13:22:26 henning Exp $ */
d798 6
a803 1
		printf("%-20s %10ds\n", pf_timeouts[i].name, pt.seconds);
@


1.169
log
@kill globals anchorname and rulesetname; have them in main instead and pass
to the functions that need them. makes the code easier and cleaner in some
places and will be needed for other things to come soon

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.168 2003/04/30 12:30:27 cedric Exp $ */
a74 1
int	 pfctl_rules(int, char *, int, char *, char *);
d1028 6
@


1.168
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.167 2003/04/03 15:52:24 cedric Exp $ */
d61 2
a62 2
int	 pfctl_clear_rules(int, int);
int	 pfctl_clear_nat(int, int);
d66 2
a67 1
int	 pfctl_get_pool(int, struct pf_pool *, u_int32_t, u_int32_t, int);
d69 2
a70 2
int	 pfctl_show_rules(int, int, int);
int	 pfctl_show_nat(int, int);
d75 1
a75 1
int	 pfctl_rules(int, char *, int);
d79 1
a79 1
int	 pfctl_show_anchors(int, int);
a92 2
char	 anchorname[PF_ANCHOR_NAME_SIZE];
char	 rulesetname[PF_RULESET_NAME_SIZE];
d256 1
a256 1
pfctl_clear_rules(int dev, int opts)
d279 2
a280 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_clear_rules(dev, opts | PF_OPT_QUIET);
			memset(rulesetname, 0, sizeof(rulesetname));
d307 1
a307 1
pfctl_clear_nat(int dev, int opts)
d330 2
a331 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_clear_nat(dev, opts | PF_OPT_QUIET);
			memset(rulesetname, 0, sizeof(rulesetname));
d493 1
a493 1
    u_int32_t ticket, int r_action)
d569 2
a570 1
pfctl_show_rules(int dev, int opts, int format)
d595 2
a596 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_show_rules(dev, opts, format);
			memset(rulesetname, 0, sizeof(rulesetname));
d620 1
a620 1
		    nr, pr.ticket, PF_SCRUB) != 0)
d652 1
a652 1
		    nr, pr.ticket, PF_PASS) != 0)
d674 1
a674 1
pfctl_show_nat(int dev, int opts)
d700 1
a700 3
			memcpy(rulesetname, pr.name, sizeof(rulesetname));
			r = pfctl_show_nat(dev, opts);
			memset(rulesetname, 0, sizeof(rulesetname));
d724 2
a725 1
			    pr.ticket, nattype[i]) != 0)
d925 2
a926 1
pfctl_rules(int dev, char *filename, int opts)
d1216 1
a1216 1
pfctl_show_anchors(int dev, int opts)
d1276 6
a1281 4
	int error = 0;
	int ch;
	int mode = O_RDONLY;
	int opts = 0;
d1470 1
a1470 1
			pfctl_clear_rules(dev, opts);
d1473 1
a1473 1
			pfctl_clear_nat(dev, opts);
d1485 2
a1486 2
			pfctl_clear_rules(dev, opts);
			pfctl_clear_nat(dev, opts);
d1509 1
a1509 1
		if (pfctl_rules(dev, rulesopt, opts))
d1515 1
a1515 1
			pfctl_show_anchors(dev, opts);
d1518 2
a1519 1
			pfctl_show_rules(dev, opts, 0);
d1522 2
a1523 1
			pfctl_show_rules(dev, opts, 1);
d1526 1
a1526 1
			pfctl_show_nat(dev, opts);
d1544 3
a1546 2
			pfctl_show_rules(dev, opts, 0);
			pfctl_show_nat(dev, opts);
d1550 1
a1550 1
			pfctl_show_rules(dev, opts, 1);
@


1.167
log
@Simplify pfctl printing code.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.166 2003/04/02 22:31:06 henning Exp $ */
d991 2
d1001 3
a1003 2
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_NAT]))
				err(1, "DIOCCOMMITRULES");
d1005 3
a1007 2
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_RDR]))
				err(1, "DIOCCOMMITRULES");
d1009 3
a1011 2
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_BINAT]))
				err(1, "DIOCCOMMITRULES");
d1019 3
a1021 2
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_SCRUB]))
				err(1, "DIOCCOMMITRULES");
d1023 3
a1025 2
			if (ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_FILTER]))
				err(1, "DIOCCOMMITRULES");
d1448 1
d1491 1
a1491 1
			pfctl_clear_tables(opts);
d1494 1
a1494 1
			pfctl_clear_tables(opts);
d1505 1
a1505 1
		    tblcmdopt, rulesopt, opts);
d1551 1
a1551 1
			pfctl_show_tables(opts);
d1554 1
a1554 1
			pfctl_show_tables(opts);
@


1.166
log
@no \n w/ errx(3), reminded by andrushock
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.165 2003/04/02 14:09:20 henning Exp $ */
d681 2
d715 4
a718 10
	pr.rule.action = PF_NAT;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
d721 13
a733 18
		if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
		    pr.ticket, PF_NAT) != 0)
			return (-1);
		print_nat(&pr.rule, opts & PF_OPT_VERBOSE2);
		pfctl_print_rule_counters(&pr.rule, opts);
		pfctl_clear_pool(&pr.rule.rpool);
	}
	pr.rule.action = PF_RDR;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			return (-1);
a734 25
		if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
		    pr.ticket, PF_RDR) != 0)
			return (-1);
		print_rdr(&pr.rule, opts & PF_OPT_VERBOSE2);
		pfctl_print_rule_counters(&pr.rule, opts);
		pfctl_clear_pool(&pr.rule.rpool);
	}
	pr.rule.action = PF_BINAT;
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		warn("DIOCGETRULES");
		return (-1);
	}
	mnr = pr.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pr.nr = nr;
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			warn("DIOCGETRULE");
			return (-1);
		}
		if (pfctl_get_pool(dev, &pr.rule.rpool, nr,
		    pr.ticket, PF_BINAT) != 0)
			return (-1);
		print_binat(&pr.rule, opts & PF_OPT_VERBOSE2);
		pfctl_print_rule_counters(&pr.rule, opts);
		pfctl_clear_pool(&pr.rule.rpool);
@


1.165
log
@better error handling
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.164 2003/04/02 14:07:38 henning Exp $ */
d949 1
a949 1
					errx(1, "qtype not configured\n");
d952 1
a952 1
					    "altq\n", a->ifname);
@


1.164
log
@better error message
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.163 2003/03/27 20:21:34 dhartmei Exp $ */
d949 1
a949 2
					fprintf(stderr,
					    "qtype not configured\n");
d951 1
a951 2
					fprintf(stderr,
					    "%s: driver does not support "
d953 2
a954 1
				err(1, "DIOCADDALTQ");
@


1.163
log
@minor tweaks from Andrey Matveev, ok henning@@ and cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.162 2003/03/27 18:01:57 henning Exp $ */
d953 2
a954 2
					    "driver does not support "
					    "altq\n");
@


1.162
log
@lotsa const char *
from David Hill <david at phobia.ms> a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.161 2003/03/11 13:20:17 dhartmei Exp $ */
d432 1
a432 1
			errx(1, "Unknown address family!?!?!");
d467 2
a468 1
					errx(1, "Unknown address family!?!?!");
d983 4
a986 1
		fin = fopen(filename, "r");
a988 4
	if (fin == NULL) {
		warn("%s", filename);
		return (1);
	}
d1027 1
a1027 1
		errx(1, "Syntax error in file: pf rules not loaded");
@


1.161
log
@On pfctl -a foo -Fn/-Fr, traverse all subrulesets in the anchor and
clear nat/rules, like -sn/-sr already does.
Reported by Julien Bordet. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.160 2003/03/11 11:53:28 henning Exp $ */
d79 1
a79 1
char	*pfctl_lookup_option(char *, char **);
d81 1
a81 1
char	*clearopt;
d83 2
a84 2
char	*showopt;
char	*debugopt;
d87 1
a87 1
char	*tblcmdopt;
d161 1
a161 1
static char *clearopt_list[] = {
d165 1
a165 1
static char *showopt_list[] = {
d170 1
a170 1
static char *tblcmdopt_list[] = {
d175 1
a175 1
static char *debugopt_list[] = {
d1294 2
a1295 2
char *
pfctl_lookup_option(char *cmd, char **list)
@


1.160
log
@fix format strings in debugging output, qid is unsigned

ok cedric@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.159 2003/03/10 13:28:00 henning Exp $ */
d261 29
d313 29
d588 1
a588 1
				warn("DIOCGETRULESETS");
d594 2
a595 4
			if (ioctl(dev, DIOCGETRULESET, &pr)) {
				warn("DIOCGETRULESET");
				return (-1);
			}
d692 1
a692 1
				warn("DIOCGETRULESETS");
d698 2
a699 4
			if (ioctl(dev, DIOCGETRULESET, &pr)) {
				warn("DIOCGETRULESET");
				return (-1);
			}
d1279 1
a1279 1
				warn("DIOCGETRULESETS");
d1286 2
a1287 4
			if (ioctl(dev, DIOCGETRULESET, &pr)) {
				warn("DIOCGETRULESET");
				return (-1);
			}
@


1.159
log
@it doesn't make sense to mimic pfctl -vsr output in pfctl -vsl (same for
-vvsr ./. -vvsl). this resulted in more or less garbage in pfctl -vsl and
-vvsl output.
so ignore the extra verbosity flags for -sl.

found by pb@@
ok pb@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.158 2003/03/08 14:26:31 henning Exp $ */
d502 1
a502 1
		printf("[ Queue: qname=%s qid=%d pqname=%s pqid=%d ]\n",
@


1.158
log
@inlcude queue interals in -gsr and -gsq output; will make debugging easier.

ok cedric@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.157 2003/03/07 12:55:37 henning Exp $ */
d572 1
a572 4
				if (opts & PF_OPT_VERBOSE)
					print_rule(&pr.rule, rule_numbers);
				else
					printf("%s ", pr.rule.label);
d604 1
a604 4
				if (opts & PF_OPT_VERBOSE)
					print_rule(&pr.rule, rule_numbers);
				else
					printf("%s ", pr.rule.label);
@


1.157
log
@don't include debugging output, namely, the result of teh skip steps
calculation, in verbose output (pfctl -vvsr). Instead, use a new flag -g for
that.

result of a longer discussion with dhartmei@@ and jakob@@

ok cedric@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.156 2003/02/20 22:09:27 deraadt Exp $ */
d501 3
d1509 1
a1509 2
			pfctl_show_altq(dev, opts & PF_OPT_VERBOSE,
			    opts & PF_OPT_VERBOSE2);
d1526 1
a1526 1
			pfctl_show_altq(dev, opts & PF_OPT_VERBOSE, 0);
@


1.156
log
@extra plurals; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.155 2003/02/20 11:08:06 cedric Exp $ */
d185 1
a185 1
	fprintf(stderr, "usage: %s [-AdehnNqrROvz] ", __progname);
d485 1
a485 1
	if (opts & PF_OPT_VERBOSE2) {
d514 1
d570 1
a570 2
					print_rule(&pr.rule,
					    opts & PF_OPT_VERBOSE2);
d579 1
a579 1
			print_rule(&pr.rule, opts & PF_OPT_VERBOSE2);
d605 1
a605 2
					print_rule(&pr.rule,
					    opts & PF_OPT_VERBOSE2);
d614 1
a614 1
			print_rule(&pr.rule, opts & PF_OPT_VERBOSE2);
d1266 1
a1266 1
	while ((ch = getopt(argc, argv, "a:AdD:eqf:F:hk:nNOrRs:t:T:vx:z")) !=
d1318 3
@


1.155
log
@Fix table syntax documentation, from David Krause.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.154 2003/02/19 21:50:16 henning Exp $ */
d190 1
a190 1
	fprintf(stderr, "[-t table] [-T command [addresses ...]] [-x level]\n");
@


1.154
log
@cmdline options in alphabetical order in usage() and manpage; and sync them

from krause
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.153 2003/02/18 21:59:34 henning Exp $ */
d190 1
a190 1
	fprintf(stderr, "[-t table [-T command [addresses]*]] [-x level]\n");
@


1.153
log
@fix load option handling (-A, -N, -R) for options.
due to a bug in the loadopt check options were always loaded no matter which
loadopts where specified.
while beeing there, move the prints for that to where they belong, into the
appropriate pfctl_set_* functions, and thus only print when the options are
actually loaded.
fixes regress tests pfopt3, pfopt4, pfopt5 I added earlier.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.152 2003/02/17 15:33:07 henning Exp $ */
d185 2
a186 2
	fprintf(stderr, "usage: %s [-AdeqhnNrROvz] ", __progname);
	fprintf(stderr, "[-a anchor:ruleset] [-f file]\n");
d188 1
a188 2
	fprintf(stderr, "[-F modifier] [-k host] [-s modifier] [-x level] "
	    "[-D macro=value ]\n");
d190 1
a190 1
	fprintf(stderr, "[-t table [-T command [addresses]*]]\n");
@


1.152
log
@pfctl_clear_pool doesn't need to be prototyped twice either
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.151 2003/02/17 15:11:29 henning Exp $ */
d1020 3
d1024 13
a1036 16
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) != 0) {
		for (i = 0; pf_limits[i].name; i++) {
			if (strcasecmp(opt, pf_limits[i].name) == 0) {
				pl.index = i;
				pl.limit = limit;
				if ((pf->opts & PF_OPT_NOACTION) == 0) {
					if (ioctl(pf->dev, DIOCSETLIMIT, &pl)) {
						if (errno == EBUSY) {
							warnx("Current pool "
							    "size exceeds "
							    "requested "
							    "hard limit");
							return (1);
						} else
							err(1, "DIOCSETLIMIT");
					}
a1037 1
				break;
d1039 1
a1039 4
		}
		if (pf_limits[i].name == NULL) {
			warnx("Bad pool name.");
			return (1);
d1042 8
d1054 1
a1054 1
pfctl_set_timeout(struct pfctl *pf, const char *opt, int seconds)
d1059 3
d1063 4
a1066 6
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) != 0) {
		for (i = 0; pf_timeouts[i].name; i++) {
			if (strcasecmp(opt, pf_timeouts[i].name) == 0) {
				pt.timeout = pf_timeouts[i].timeout;
				break;
			}
d1068 1
d1070 4
a1073 4
		if (pf_timeouts[i].name == NULL) {
			warnx("Bad timeout name.");
			return (1);
		}
d1075 4
a1078 5
		pt.seconds = seconds;
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (ioctl(pf->dev, DIOCSETTIMEOUT, &pt))
				err(1, "DIOCSETTIMEOUT");
		}
d1080 4
d1093 6
a1098 10
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) != 0) {
		for (i = 0; pf_hints[i].name; i++)
			if (strcasecmp(opt, pf_hints[i].name) == 0)
				break;

		hint = pf_hints[i].hint;
		if (hint == NULL) {
			warnx("Bad hint name.");
			return (1);
		}
d1100 4
a1103 4
		for (i = 0; hint[i].name; i++)
			if ((r = pfctl_set_timeout(pf, hint[i].name,
			    hint[i].timeout)))
				return (r);
d1105 9
d1122 3
d1126 7
a1132 11
	if ((loadopt & (PFCTL_FLAG_OPTION | PFCTL_FLAG_ALL)) != 0) {
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			if (!strcmp(ifname, "none"))
				bzero(pi.ifname, sizeof(pi.ifname));
			else {
				if (strlcpy(pi.ifname, ifname,
				    sizeof(pi.ifname)) >= sizeof(pi.ifname))
					errx(1, "pfctl_set_logif: strlcpy");
			}
			if (ioctl(pf->dev, DIOCSETSTATUSIF, &pi))
				err(1, "DIOCSETSTATUSIF");
d1134 2
d1137 4
@


1.151
log
@no need to prototype pfctl_add_pool twice
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.150 2003/02/17 06:58:27 mpech Exp $ */
a66 1
void	 pfctl_clear_pool(struct pf_pool *);
@


1.150
log
@We want err() after failed ioctl() here too.

mcbride@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.149 2003/02/14 17:17:27 henning Exp $ */
a77 1
int	 pfctl_add_pool(struct pfctl *, struct pf_pool *, sa_family_t);
@


1.149
log
@remove explicit table creation ( -T create ), it's useless.

ok pb@@ mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.148 2003/02/11 20:11:36 henning Exp $ */
d1121 1
a1121 1
				return (1);
@


1.148
log
@allow macro definition on the command line:
pfctl -Dextif=wi0 -f /etc/pf.conf
command line macro definitions override the ones made in the file (idea
theo), very handy if your notebook has another NIC at some conference, as
well as for debugging etc.
idea rezine@@mistrusted.net via pb@@
hacked live at FOSDEM

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.147 2003/02/05 11:18:45 cedric Exp $ */
d173 1
a173 1
	"create", "kill", "flush", "add", "delete", "load", "replace", "show",
@


1.147
log
@Simplify more.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.146 2003/02/05 10:13:44 cedric Exp $ */
d190 2
a191 1
	fprintf(stderr, "[-F modifier] [-k host] [-s modifier] [-x level]\n");
d1251 1
a1251 1
	while ((ch = getopt(argc, argv, "a:Adeqf:F:hk:nNOrRs:t:T:vx:z")) !=
d1260 5
@


1.146
log
@Simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.145 2003/02/03 14:51:36 cedric Exp $ */
d1457 1
a1457 1
	if (tableopt != NULL || tblcmdopt != NULL) {
@


1.145
log
@remove loadopt global definition and cleanup a bit.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.144 2003/02/03 13:57:47 henning Exp $ */
d1352 1
a1352 1
	if (tableopt != NULL || tblcmdopt != NULL) {
d1355 1
a1355 1
		ch = (tblcmdopt != NULL) ? *tblcmdopt : 0;
@


1.144
log
@zap dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.143 2003/02/03 13:40:45 henning Exp $ */
d966 2
a967 1
		pfctl_begin_table();
d1007 2
a1008 1
		pfctl_commit_table();
@


1.143
log
@fix a problem with queue definitions when load options (like -N etc) are
given; they used to check for their parent interface/queue even in this
case.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.142 2003/02/02 23:22:07 henning Exp $ */
a1006 8
#if 0
		if ((opts & PF_OPT_QUIET) == 0) {
			fprintf(stderr, "%u nat entries loaded\n", n);
			fprintf(stderr, "%u rdr entries loaded\n", r);
			fprintf(stderr, "%u binat entries loaded\n", b);
			fprintf(stderr, "%u rules loaded\n", n);
		}
#endif
@


1.142
log
@there is no need to pass opts to parse_rules explicitely; it's passed as
part of the struct pfctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.141 2003/01/27 15:42:29 dhartmei Exp $ */
d971 1
@


1.141
log
@When -a is specified, the operation affects an anchor only, so don't try
to replace queues (or options) which are global and can't be loaded into
an anchor. Found by j@@pureftpd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.140 2003/01/24 11:11:17 henning Exp $ */
d976 1
a976 1
	if (parse_rules(fin, &pf, opts) < 0)
@


1.140
log
@let pfctl -vvsq loop and display measured bandwidth and packets/s per queue.
cbq only for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.139 2003/01/21 19:12:08 camield Exp $ */
d1403 5
@


1.139
log
@remove redundant if

ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.138 2003/01/20 18:37:52 camield Exp $ */
d1482 2
a1483 1
			pfctl_show_altq(dev, opts & PF_OPT_VERBOSE);
d1500 1
a1500 1
			pfctl_show_altq(dev, opts & PF_OPT_VERBOSE);
@


1.138
log
@Remove unused argument from print_name() and fix two other nits
found by lint.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.137 2003/01/19 15:28:12 camield Exp $ */
d499 1
a499 1
			else if (rule->skip[i].nr != rule->nr + 1)
@


1.137
log
@Simplify and KNF anchoropt processing.

ok dhartmei henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.136 2003/01/19 13:48:06 dhartmei Exp $ */
d1180 2
a1181 2
	} else
		return (1);
@


1.136
log
@The -s option to show anchors is 'A' or 'Anchors', not 'a' (which is used
to show 'all' information).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.135 2003/01/18 22:23:00 dhartmei Exp $ */
d1381 1
a1381 1
		char *t = strchr(anchoropt, ':');
d1383 1
a1383 1
		if (t == NULL) {
d1391 5
a1395 8
			if (t == anchoropt || !strlen(t+1))
				errx(1, "anchor names '%s' invalid", anchoropt);
			if ((p = malloc(strlen(anchoropt) + 1)) == NULL)
				err(1, "malloc");
			strlcpy(p, anchoropt, strlen(anchoropt) + 1);
			if ((t = strsep(&p, ":")) == NULL)
				errx(1, "anchor names '%s' invalid",
				    anchoropt);
d1402 1
a1402 1
			free(t);
@


1.135
log
@Move freeaddrinfo() so it doesn't get called with an uninitialized
pointer (which segfaults). From Julien Bordet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.134 2003/01/18 15:00:24 cedric Exp $ */
d168 1
a168 1
	"nat", "queue", "rules", "anchors", "state", "info", "labels",
@


1.134
log
@Cleanup PF_OPT_NOACTION with tables. No changes on current behaviour,
but do something useful when the user has no access to /dev/pf.
Tested on i386, sparc64.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.133 2003/01/15 20:53:36 deraadt Exp $ */
d419 1
a429 2
	if (res[1])
		freeaddrinfo(res[1]);
@


1.133
log
@what a bogus message
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.132 2003/01/15 12:13:02 cedric Exp $ */
a1251 1
	int dummy = 0;
d1368 3
a1370 2
				opts &= ~PF_OPT_NOACTION;
				dummy = PF_OPT_NOACTION;
a1409 2
	if (opts & PF_OPT_NOACTION)
		mode = O_RDONLY;
d1463 1
a1463 1
		    tblcmdopt, rulesopt, opts | dummy);
@


1.132
log
@Repair table "load" command.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.131 2003/01/11 21:10:56 henning Exp $ */
d1415 1
a1415 1
			err(1, "open(\"/dev/pf\")");
@


1.131
log
@whitespace KNF _AGAIN_
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.130 2003/01/10 14:21:21 cedric Exp $ */
d173 1
a173 1
	"create", "kill", "flush", "add", "delete", "replace", "show",
@


1.130
log
@Be a bit more strict when parsing options.
Disallow "pfctl -s rabbits" and friends.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.129 2003/01/09 18:55:32 dhartmei Exp $ */
d168 1
a168 1
	"nat", "queue", "rules", "anchors", "state", "info", "labels", 
a1243 2
			

d1322 1
a1322 1
			}			
@


1.129
log
@strlcpy return checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.128 2003/01/09 18:34:29 henning Exp $ */
d52 1
d81 1
d163 19
d1235 12
d1277 5
a1281 1
			clearopt = optarg;
d1320 5
a1324 1
			showopt = optarg;
d1330 5
a1334 1
			tblcmdopt = optarg;
d1342 5
a1346 1
			debugopt = optarg;
d1459 1
a1459 2
			warnx("Unknown flush modifier '%s'", clearopt);
			error = 1;
d1519 1
a1519 2
			warnx("Unknown show modifier '%s'", showopt);
			error = 1;
d1539 1
a1539 2
			warnx("Unknown debug level '%s'", debugopt);
			error = 1;
@


1.128
log
@use a verbose flag in pfctl_show_altq instead of carrying around opts from
pfctl.c, and get rid of the #include "pfctl_parser.h"
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.127 2003/01/09 17:33:19 henning Exp $ */
d1099 5
a1103 2
			else
				strlcpy(pi.ifname, ifname, sizeof(pi.ifname));
@


1.127
log
@first attack at pfctl queue statistics, to be displayed with pfctl -vsq

This commit is dedicated to the cute KLM girls who made part of this
possible with giving me a seat in the plane where you actually have enough
place to hack. Thanks, girls.

ok markus@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.126 2003/01/09 10:40:44 cedric Exp $ */
d1439 1
a1439 1
			pfctl_show_altq(dev, opts);
d1456 1
a1456 1
			pfctl_show_altq(dev, opts);
@


1.126
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.125 2003/01/07 01:04:33 henning Exp $ */
a69 1
int	 pfctl_show_altq(int);
a605 30
pfctl_show_altq(int dev)
{
	struct pf_altq_node *root = NULL;

	struct pfioc_altq pa;
	u_int32_t mnr, nr;

	if (!altqsupport)
		return (-1);
	memset(&pa, 0, sizeof(pa));
	if (ioctl(dev, DIOCGETALTQS, &pa)) {
		warn("DIOCGETALTQS");
		return (-1);
	}
	mnr = pa.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pa.nr = nr;
		if (ioctl(dev, DIOCGETALTQ, &pa)) {
			warn("DIOCGETALTQ");
			return (-1);
		}
		pfctl_insert_altq_node(&root, pa.altq);
	}
	for (; root != NULL; root = root->next)
		pfctl_print_altq_node(root, 0);
	pfctl_free_altq_node(root);
	return (0);
}

int
d1439 1
a1439 1
			pfctl_show_altq(dev);
d1456 1
a1456 1
			pfctl_show_altq(dev);
@


1.125
log
@the "default" alias for "normal" optimization in pf_hints is dead for some
time now...
catched by david krause
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.124 2003/01/05 22:34:20 henning Exp $ */
d977 1
a977 1

d1016 1
d1344 9
a1352 4
		mode = strchr("acdfkrz", ch) ? O_RDWR : O_RDONLY;
		if (opts & PF_OPT_NOACTION) {
			opts &= ~PF_OPT_NOACTION;
			dummy = PF_OPT_NOACTION;
@


1.124
log
@don't whine about missing altq support in the kernel in the -q case

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.123 2003/01/05 22:14:23 dhartmei Exp $ */
a154 1
	{ "default",		pf_hint_normal },
@


1.123
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.122 2003/01/04 00:01:34 deraadt Exp $ */
d79 1
a79 1
int	 pfctl_test_altqsupport(int);
d1176 1
a1176 1
pfctl_test_altqsupport(int dev)
d1182 3
a1184 2
			fprintf(stderr, "No ALTQ support in the kernel\n");
			fprintf(stderr, "ALTQ related functions disabled\n");
d1392 1
a1392 1
		altqsupport = pfctl_test_altqsupport(dev);
@


1.122
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.121 2003/01/03 22:57:26 deraadt Exp $ */
d329 2
a330 1
	memset(&psk.psk_src.addr.mask, 0xff, sizeof(psk.psk_src.addr.mask));
d350 1
a350 1
			psk.psk_src.addr.addr.v4 =
d353 1
a353 1
			psk.psk_src.addr.addr.v6 =
d361 2
a362 2
			memset(&psk.psk_dst.addr.mask, 0xff,
			    sizeof(psk.psk_dst.addr.mask));
d384 1
a384 1
					psk.psk_dst.addr.addr.v4 =
d388 1
a388 1
					psk.psk_dst.addr.addr.v6 =
@


1.121
log
@no need to close
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.120 2003/01/03 22:48:17 deraadt Exp $ */
d54 1
a54 4
#include "pf_print_state.h"
#include "pfctl_altq.h"
#include "pfctl_table.h"
#include "pfctl_radix.h"
@


1.120
log
@(a && (b & c))
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.118 2003/01/03 21:37:44 cedric Exp $ */
a1524 1
	close(dev);
@


1.119
log
@simplify ioctl access
@
text
@d967 2
a968 2
		if (((altqsupport && loadopt
		    & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) &&
d992 1
a992 1
	if ((altqsupport && loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0)
d1007 2
a1008 2
		if (((altqsupport && loadopt
		    & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) &&
@


1.118
log
@Bring in userland code for accessing PF radix tables.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.117 2003/01/01 17:20:14 henning Exp $ */
d99 2
a1246 1
	int dev = -1;
a1393 1
		pfr_set_fd(dev);
@


1.117
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.116 2003/01/01 04:26:19 dhartmei Exp $ */
d56 2
d90 2
d173 2
d1249 1
d1254 2
a1255 1
	while ((ch = getopt(argc, argv, "a:Adeqf:F:hk:nNOrRs:vx:z")) != -1) {
d1313 6
d1340 10
a1349 1
	if (argc != optind) {
d1393 1
d1428 4
d1441 6
d1489 4
@


1.116
log
@Remove skip step for action (scrub vs. non-scrub), as scrub rules are
stored in a separate list now. Regress tests still pass after
sed "s/ a=end / /g", other skip steps are not affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.115 2003/01/01 00:58:10 dhartmei Exp $ */
d966 1
a966 1
		    	if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_SCRUB]))
d969 1
a969 1
		    	if (ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_FILTER]))
@


1.115
log
@Extend two error messages, change one err() -> errx() where there's no
errno to translate. From Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.114 2002/12/31 19:27:08 mcbride Exp $ */
d464 1
a464 1
		const char *t[PF_SKIP_COUNT] = { "a", "i", "d", "f",
@


1.114
log
@Match kernel changes splitting scrub rules into their own ruleset type.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.113 2002/12/31 01:39:46 dhartmei Exp $ */
d329 1
a329 1
		errx(1, "%s", gai_strerror(ret_ga));
d360 1
a360 1
				errx(1, "%s", gai_strerror(ret_ga));
d878 1
a878 1
		err(1, "Invalid rule type");
@


1.113
log
@err() doesn't return. from Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.112 2002/12/29 22:02:46 dhartmei Exp $ */
d242 5
d526 36
d849 4
d857 1
a857 1
		rs_num = PF_RULESET_RULE;
d882 1
a882 1
	if ((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) {
d885 9
a893 11
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			memcpy(&pf->prule[rs_num]->rule, r,
			    sizeof(pf->prule[rs_num]->rule));
			pf->prule[rs_num]->pool_ticket = pf->paddr.ticket;
			if (ioctl(pf->dev, DIOCADDRULE, pf->prule[rs_num]))
				err(1, "DIOCADDRULE");
		}
		if (pf->opts & PF_OPT_VERBOSE)
			print_rule(r, pf->opts & PF_OPT_VERBOSE2);
		pfctl_clear_pool(&r->rpool);
	}
d964 9
a972 4
		pr[PF_RULESET_RULE].rule.action = PF_PASS;
		if (((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) &&
		    ioctl(dev, DIOCBEGINRULES, &pr[PF_RULESET_RULE]))
			err(1, "DIOCBEGINRULES");
d1003 8
a1010 4
		pr[PF_RULESET_RULE].rule.action = PF_PASS;
		if (((loadopt & (PFCTL_FLAG_FILTER | PFCTL_FLAG_ALL)) != 0) &&
		    ioctl(dev, DIOCCOMMITRULES, &pr[PF_RULESET_RULE]))
			err(1, "DIOCCOMMITRULES");
@


1.112
log
@Make pfctl -a name -sr/-sn show all rules of all rulesets within the
anchor. From discussion with Michael Lucas. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.111 2002/12/25 16:05:23 dhartmei Exp $ */
d435 1
a435 1
		if (pa == NULL) {
a436 2
			return (-1);
		}
@


1.111
log
@Honour -R/-N and don't attempt to load other rules in those cases.
Found by Michael Lucas.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.110 2002/12/22 15:52:13 dhartmei Exp $ */
d490 30
d597 30
@


1.110
log
@Handle pool addresses in binat rules, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.109 2002/12/18 19:40:41 dhartmei Exp $ */
d752 2
d758 2
d764 2
d770 2
a827 1
	memset(&pr, 0, sizeof(pr));
d831 1
@


1.109
log
@Store translation rule pointer in state entries, so pfctl -vsn can print
evaluation, packet, byte and state entry counters similar to -vsr. Helps
verify whether/how often translation rules are evaluated/matched.
ok frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.108 2002/12/18 16:28:40 dhartmei Exp $ */
d621 3
d626 1
@


1.108
log
@Pass skip step values through ioctl interface, pfctl -vvsr shows them,
main purpose is making them regress-testable.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.107 2002/12/18 16:00:03 henning Exp $ */
d68 1
d70 1
a70 1
int	 pfctl_show_nat(int);
d457 27
d525 1
a525 26
			if (opts & PF_OPT_VERBOSE2) {
				const char *t[PF_SKIP_COUNT] = { "a",
				    "i", "d", "f", "p", "sa", "sp",
				    "da", "dp" };
				int i;

				printf("[ Skip steps: ");
				for (i = 0; i < PF_SKIP_COUNT; ++i) {
					if (pr.rule.skip[i].nr ==
					    pr.rule.nr + 1)
						continue;
					printf("%s=", t[i]);
					if (pr.rule.skip[i].nr == -1)
						printf("end ");
					else if (pr.rule.skip[i].nr !=
					    pr.rule.nr + 1)
						printf("%u ",
						    pr.rule.skip[i].nr);
				}
				printf("]\n");
			}
			if (opts & PF_OPT_VERBOSE)
				printf("[ Evaluations: %-8llu  Packets: %-8llu  "
				    "Bytes: %-10llu  States: %-6u]\n\n",
				    pr.rule.evaluations, pr.rule.packets,
				    pr.rule.bytes, pr.rule.states);
d563 1
a563 1
pfctl_show_nat(int dev)
d586 2
a587 1
		print_nat(&pr.rule);
d605 2
a606 1
		print_rdr(&pr.rule);
d621 2
a622 1
		print_binat(&pr.rule);
d1307 1
a1307 1
			pfctl_show_nat(dev);
d1326 1
a1326 1
			pfctl_show_nat(dev);
@


1.107
log
@ryan, look at this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.106 2002/12/18 14:14:09 mcbride Exp $ */
d497 21
@


1.106
log
@Maintain separate pfioc_rule structures for each type of rule,
to prevent tickets from getting overwritten.

bug reported by dhartmei@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.105 2002/12/17 20:06:05 henning Exp $ */
d716 1
a716 1
	
d721 1
a721 1
		rs_num = PF_RULESET_RULE;	
d725 1
a725 1
		rs_num = PF_RULESET_NAT;	
d729 1
a729 1
		rs_num = PF_RULESET_RDR;	
d733 1
a733 1
		rs_num = PF_RULESET_BINAT;	
d736 1
a736 1
		err(1, "Invalid rule type");	
d739 1
a739 1
	
@


1.105
log
@add support for the PRIQ scheduler

partitially from kjc@@

ok kjc@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.104 2002/12/17 12:36:59 mcbride Exp $ */
d715 25
d744 4
a747 3
			memcpy(&pf->prule->rule, r, sizeof(pf->prule->rule));
			pf->prule->pool_ticket = pf->paddr.ticket;
			if (ioctl(pf->dev, DIOCADDRULE, pf->prule))
d784 1
a784 1
	struct pfioc_rule	pr;
d787 1
d792 4
a795 2
	memcpy(pr.anchor, anchorname, sizeof(pr.anchor));
	memcpy(pr.ruleset, rulesetname, sizeof(pr.ruleset));
d809 2
a810 2
			pr.rule.action = PF_NAT;
			if (ioctl(dev, DIOCBEGINRULES, &pr))
d812 2
a813 2
			pr.rule.action = PF_RDR;
			if (ioctl(dev, DIOCBEGINRULES, &pr))
d815 2
a816 2
			pr.rule.action = PF_BINAT;
			if (ioctl(dev, DIOCBEGINRULES, &pr))
d824 1
a824 1
		pr.rule.action = PF_PASS;
d826 1
a826 1
		    ioctl(dev, DIOCBEGINRULES, &pr))
d833 3
a835 1
	pf.prule = &pr;
d844 2
a845 2
			pr.rule.action = PF_NAT;
			if (ioctl(dev, DIOCCOMMITRULES, &pr))
d847 2
a848 2
			pr.rule.action = PF_RDR;
			if (ioctl(dev, DIOCCOMMITRULES, &pr))
d850 2
a851 2
			pr.rule.action = PF_BINAT;
			if (ioctl(dev, DIOCCOMMITRULES, &pr))
d858 1
a858 1
		pr.rule.action = PF_PASS;
d860 1
a860 1
		    ioctl(dev, DIOCCOMMITRULES, &pr))
@


1.104
log
@Match merge of pf_nat/pf_binat/pf_rdr structs into pf_rule

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.103 2002/12/16 22:59:37 henning Exp $ */
d738 10
a747 13
			/* only cbq needs a root queue */
			if (a->scheduler == ALTQT_CBQ ||
			    a->qname[0] == 0 || a->parent[0] != 0)
				if (ioctl(pf->dev, DIOCADDALTQ, pf->paltq)) {
					if (errno == ENXIO)
						fprintf(stderr,
						    "qtype not configured\n");
					else if (errno == ENODEV)
						fprintf(stderr,
						    "driver does not support "
						    "altq\n");
					err(1, "DIOCADDALTQ");
				}
@


1.103
log
@only try to add the root queue for cbq

from kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.102 2002/12/10 11:03:52 henning Exp $ */
d241 1
d254 1
a254 3
	struct pfioc_nat pn;
	struct pfioc_binat pb;
	struct pfioc_rdr pr;
a255 2
	memset(&pn, 0, sizeof(pn));
	memset(&pb, 0, sizeof(pb));
a256 4
	memcpy(pn.anchor, anchorname, sizeof(pn.anchor));
	memcpy(pn.ruleset, rulesetname, sizeof(pn.ruleset));
	memcpy(pb.anchor, anchorname, sizeof(pb.anchor));
	memcpy(pb.ruleset, rulesetname, sizeof(pb.ruleset));
d259 15
a273 12
	if (ioctl(dev, DIOCBEGINNATS, &pn))
		err(1, "DIOCBEGINNATS");
	else if (ioctl(dev, DIOCCOMMITNATS, &pn))
		err(1, "DIOCCOMMITNATS");
	if (ioctl(dev, DIOCBEGINBINATS, &pb))
		err(1, "DIOCBEGINBINATS");
	else if (ioctl(dev, DIOCCOMMITBINATS, &pb))
		err(1, "DIOCCOMMITBINATS");
	else if (ioctl(dev, DIOCBEGINRDRS, &pr))
		err(1, "DIOCBEGINRDRS");
	else if (ioctl(dev, DIOCCOMMITRDRS, &pr))
		err(1, "DIOCCOMMITRDRS");
d409 1
a409 1
    u_int32_t ticket, int id)
d418 1
a418 1
	pp.r_id = id;
d465 1
d478 2
a479 2
		if (pfctl_get_pool(dev, &pr.rule.rt_pool,
		    nr, pr.ticket, PF_POOL_RULE_RT) != 0)
d503 1
a503 1
		pfctl_clear_pool(&pr.rule.rt_pool);
d541 1
a541 3
	struct pfioc_nat pn;
	struct pfioc_rdr pr;
	struct pfioc_binat pb;
a543 1
	memset(&pn, 0, sizeof(pn));
a544 3
	memset(&pb, 0, sizeof(pb));
	memcpy(pn.anchor, anchorname, sizeof(pn.anchor));
	memcpy(pn.ruleset, rulesetname, sizeof(pn.ruleset));
d547 3
a549 4
	memcpy(pb.anchor, anchorname, sizeof(pb.anchor));
	memcpy(pb.ruleset, rulesetname, sizeof(pb.ruleset));
	if (ioctl(dev, DIOCGETNATS, &pn)) {
		warn("DIOCGETNATS");
d552 1
a552 1
	mnr = pn.nr;
d554 3
a556 3
		pn.nr = nr;
		if (ioctl(dev, DIOCGETNAT, &pn)) {
			warn("DIOCGETNAT");
d559 2
a560 2
		if (pfctl_get_pool(dev, &pn.nat.rpool, nr,
		    pn.ticket, PF_POOL_NAT_R) != 0)
d562 2
a563 2
		print_nat(&pn.nat);
		pfctl_clear_pool(&pn.nat.rpool);
d565 3
a567 2
	if (ioctl(dev, DIOCGETRDRS, &pr)) {
		warn("DIOCGETRDRS");
d573 2
a574 2
		if (ioctl(dev, DIOCGETRDR, &pr)) {
			warn("DIOCGETRDR");
d577 2
a578 2
		if (pfctl_get_pool(dev, &pr.rdr.rpool, nr,
		    pr.ticket, PF_POOL_RDR_R) != 0)
d580 2
a581 2
		print_rdr(&pr.rdr);
		pfctl_clear_pool(&pr.rdr.rpool);
d583 3
a585 2
	if (ioctl(dev, DIOCGETBINATS, &pb)) {
		warn("DIOCGETBINATS");
d588 1
a588 1
	mnr = pb.nr;
d590 3
a592 3
		pb.nr = nr;
		if (ioctl(dev, DIOCGETBINAT, &pb)) {
			warn("DIOCGETBINAT");
d595 1
a595 1
		print_binat(&pb.binat);
d716 1
a716 1
		if (pfctl_add_pool(pf, &r->rt_pool, r->af))
a725 54
		pfctl_clear_pool(&r->rt_pool);
	}
	return (0);
}

int
pfctl_add_nat(struct pfctl *pf, struct pf_nat *n)
{
	if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
		if (pfctl_add_pool(pf, &n->rpool, n->af))
			return (1);
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			memcpy(&pf->pnat->nat, n, sizeof(pf->pnat->nat));
			pf->pnat->pool_ticket = pf->paddr.ticket;
			if (ioctl(pf->dev, DIOCADDNAT, pf->pnat))
				err(1, "DIOCADDNAT");
		}
		if (pf->opts & PF_OPT_VERBOSE)
			print_nat(n);
		pfctl_clear_pool(&n->rpool);
	}
	return (0);
}

int
pfctl_add_binat(struct pfctl *pf, struct pf_binat *b)
{
	if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			memcpy(&pf->pbinat->binat, b,
			    sizeof(pf->pbinat->binat));
			if (ioctl(pf->dev, DIOCADDBINAT, pf->pbinat))
				err(1, "DIOCADDBINAT");
		}
		if (pf->opts & PF_OPT_VERBOSE)
			print_binat(b);
	}
	return (0);
}

int
pfctl_add_rdr(struct pfctl *pf, struct pf_rdr *r)
{
	if ((loadopt & (PFCTL_FLAG_NAT | PFCTL_FLAG_ALL)) != 0) {
		if (pfctl_add_pool(pf, &r->rpool, r->af))
			return (1);
		if ((pf->opts & PF_OPT_NOACTION) == 0) {
			memcpy(&pf->prdr->rdr, r, sizeof(pf->prdr->rdr));
			pf->prdr->pool_ticket = pf->paddr.ticket;
			if (ioctl(pf->dev, DIOCADDRDR, pf->prdr))
				err(1, "DIOCADDRDR");
		}
		if (pf->opts & PF_OPT_VERBOSE)
			print_rdr(r);
d761 1
a761 4
	struct pfioc_nat	pn;
	struct pfioc_binat	pb;
	struct pfioc_rdr	pr;
	struct pfioc_rule	pl;
a764 2
	memset(&pn, 0, sizeof(pn));
	memset(&pb, 0, sizeof(pb));
a765 1
	memset(&pl, 0, sizeof(pl));
a767 4
	memcpy(pn.anchor, anchorname, sizeof(pn.anchor));
	memcpy(pn.ruleset, rulesetname, sizeof(pn.ruleset));
	memcpy(pb.anchor, anchorname, sizeof(pb.anchor));
	memcpy(pb.ruleset, rulesetname, sizeof(pb.ruleset));
a769 2
	memcpy(pl.anchor, anchorname, sizeof(pl.anchor));
	memcpy(pl.ruleset, rulesetname, sizeof(pl.ruleset));
d783 9
a791 6
			if (ioctl(dev, DIOCBEGINNATS, &pn))
				err(1, "DIOCBEGINNATS");
			if (ioctl(dev, DIOCBEGINRDRS, &pr))
				err(1, "DIOCBEGINRDRS");
			if (ioctl(dev, DIOCBEGINBINATS, &pb))
				err(1, "DIOCBEGINBINATS");
d798 1
d800 1
a800 1
		    ioctl(dev, DIOCBEGINRULES, &pl))
a805 3
	pf.pnat = &pn;
	pf.pbinat = &pb;
	pf.prdr = &pr;
d807 1
a807 1
	pf.prule = &pl;
d816 9
a824 6
			if (ioctl(dev, DIOCCOMMITNATS, &pn))
				err(1, "DIOCCOMMITNATS");
			if (ioctl(dev, DIOCCOMMITRDRS, &pr))
				err(1, "DIOCCOMMITRDRS");
			if (ioctl(dev, DIOCCOMMITBINATS, &pb))
				err(1, "DIOCCOMMITBINATS");
d830 1
d832 1
a832 1
		    ioctl(dev, DIOCCOMMITRULES, &pl))
@


1.102
log
@don't warnx after ioctl, use warn

pointed out by form@@ via mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.101 2002/12/09 18:26:09 henning Exp $ */
d41 1
d796 2
a797 2
	if ((altqsupport && loadopt
	    & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) {
d800 13
a812 2
			if (ioctl(pf->dev, DIOCADDALTQ, pf->paltq))
				err(1, "DIOCADDALTQ");
@


1.101
log
@replace (properly guarded) strncpy using logic by a strsep & strlcpy using
one.

discussion & ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.100 2002/12/07 20:45:04 mcbride Exp $ */
d1075 1
a1075 1
			warnx("DIOCGETANCHORS");
d1083 1
a1083 1
				warnx("DIOCGETANCHOR");
d1098 1
a1098 1
				warnx("DIOCGETRULESETS");
d1106 1
a1106 1
				warnx("DIOCGETRULESET");
@


1.100
log
@TAILQ_INSERT_TAIL instead of TAILQ_INSERT_HEAD. Makes addresses print
out in correct order when getting rules from kernel (affects pfctl -s).

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.99 2002/12/06 00:47:31 dhartmei Exp $ */
d1218 3
a1220 2
			if (strlen(anchoropt) >= sizeof(anchorname))
				err(1, "anchor name '%s' too long",
a1221 1
			strcpy(anchorname, anchoropt);
d1223 2
d1226 6
a1231 5
				err(1, "anchor names '%s' invalid",
				    anchoropt);
			if (t-anchoropt >= sizeof(anchorname) ||
			    strlen(t+1) >= sizeof(rulesetname))
				err(1, "anchor names '%s' too long",
d1233 7
a1239 2
			strncpy(anchorname, anchoropt, t-anchoropt);
			strcpy(rulesetname, t+1);
@


1.99
log
@Introduce anchors and named rule sets, allowing to load additional rule
sets with pfctl and evaluate them from the main rule set using a new type
of rule (which will support conditional evaluation soon). Makes
maintenance of sub-rulesets simpler for pfctl and daemons.

Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.98 2002/12/05 14:10:45 henning Exp $ */
d442 1
a442 1
		TAILQ_INSERT_HEAD(&pool->list, pa, entries);
@


1.98
log
@one step further to "program output is valid program input" and the related
extra regress testing opportunities (an excellent idea by markus@@).
only print rule numbers in case of pfctl -v -v; but not with pfctl -v.

ok markus@@ frantzen@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.97 2002/12/05 12:26:55 mcbride Exp $ */
d79 1
d85 1
d90 2
d163 2
a164 2
	fprintf(stderr, "usage: %s [-AdeqhnNrROvz] [-f file] ", __progname);
	fprintf(stderr, "[-F modifier] [-k host]\n");
d166 1
a166 1
	fprintf(stderr, "[-s modifier] [-x level]\n");
d237 4
a240 1
	if (ioctl(dev, DIOCBEGINRULES, &pr.ticket))
d242 1
a242 1
	else if (ioctl(dev, DIOCCOMMITRULES, &pr.ticket))
d256 10
a265 1
	if (ioctl(dev, DIOCBEGINNATS, &pn.ticket))
d267 1
a267 1
	else if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket))
d269 1
a269 1
	if (ioctl(dev, DIOCBEGINBINATS, &pb.ticket))
d271 1
a271 1
	else if (ioctl(dev, DIOCCOMMITBINATS, &pb.ticket))
d273 1
a273 1
	else if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket))
d275 1
a275 1
	else if (ioctl(dev, DIOCCOMMITRDRS, &pr.ticket))
d289 1
a289 1

d418 3
d465 3
d520 1
a520 1

d548 9
d616 1
d666 1
d683 1
d704 1
a704 1
		if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
d818 14
d845 1
a845 1
			if (ioctl(dev, DIOCBEGINNATS, &pn.ticket))
d847 1
a847 1
			if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket))
d849 1
a849 1
			if (ioctl(dev, DIOCBEGINBINATS, &pb.ticket))
d858 1
a858 1
		    ioctl(dev, DIOCBEGINRULES, &pl.ticket))
d877 1
a877 1
			if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket))
d879 1
a879 1
			if (ioctl(dev, DIOCCOMMITRDRS, &pr.ticket))
d881 1
a881 1
			if (ioctl(dev, DIOCCOMMITBINATS, &pb.ticket))
d889 1
a889 1
		    ioctl(dev, DIOCCOMMITRULES, &pl.ticket))
d911 1
d946 1
d999 1
d1066 50
d1127 1
a1127 1
	while ((ch = getopt(argc, argv, "Adeqf:F:hk:nNOrRs:vx:z")) != -1) {
d1129 3
d1212 23
d1291 3
@


1.97
log
@Replace warnx with warn on ioctls so that we get the error message associated
with the warning. From DJ Gregor.

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.96 2002/12/04 08:07:28 deraadt Exp $ */
d466 2
a467 1
					print_rule(&pr.rule);
d476 1
a476 1
			print_rule(&pr.rule);
d698 1
a698 1
			print_rule(r);
@


1.96
log
@do not warn for unused variables except with -v -v; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.95 2002/12/01 22:10:40 henning Exp $ */
d406 1
a406 1
		warnx("DIOCGETADDRS");
d414 1
a414 1
			warnx("DIOCGETADDR");
d447 1
a447 1
		warnx("DIOCGETRULES");
d454 1
a454 1
			warnx("DIOCGETRULE");
d499 1
a499 1
		warnx("DIOCGETALTQS");
d506 1
a506 1
			warnx("DIOCGETALTQ");
d526 1
a526 1
		warnx("DIOCGETNATS");
d533 1
a533 1
			warnx("DIOCGETNAT");
d543 1
a543 1
		warnx("DIOCGETRDRS");
d550 1
a550 1
			warnx("DIOCGETRDR");
d560 1
a560 1
		warnx("DIOCGETBINATS");
d567 1
a567 1
			warnx("DIOCGETBINAT");
d592 1
a592 1
			warnx("DIOCGETSTATES");
d620 1
a620 1
		warnx("DIOCGETSTATUS");
@


1.95
log
@deal with not-ALTQ-enabled kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.94 2002/12/01 19:56:42 mcbride Exp $ */
d821 1
a821 1
	if (parse_rules(fin, &pf) < 0)
d1081 2
@


1.94
log
@Match pf_ioctl.c cleanup; set up the pool_ticket when loading rules

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.93 2002/11/24 16:47:02 dhartmei Exp $ */
d78 1
d87 1
d178 9
a186 5
	if (ioctl(dev, DIOCSTARTALTQ)) {
		if (errno == EEXIST)
			errx(1, "altq already enabled");
		else
			err(1, "DIOCSTARTALTQ");
a187 2
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "altq enabled\n");
d204 9
a212 5
	if (ioctl(dev, DIOCSTOPALTQ)) {
		if (errno == ENOENT)
			errx(1, "altq not enabled");
		else
			err(1, "DIOCSTOPALTQ");
a213 2
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "altq disabled\n");
d271 3
d495 3
d760 2
a761 1
	if ((loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) {
d803 3
a805 2
		if (((loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) &&
		    ioctl(dev, DIOCBEGINALTQS, &pa.ticket))
d807 1
d823 1
a823 1
	if ((loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0)
d835 2
a836 1
		if (((loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) != 0) &&
d998 16
d1111 1
d1116 1
@


1.93
log
@Fix an error message and remove 'S' from getopt, it's not used.
From Andreas Oestling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.92 2002/11/24 13:34:15 dhartmei Exp $ */
d680 1
d699 1
d715 2
a716 1
			memcpy(&pf->pbinat->binat, b, sizeof(pf->pbinat->binat));
d734 1
@


1.92
log
@Same fix for nat and rdr. Now all regress tests pass with malloc.conf J
again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.91 2002/11/24 13:26:29 dhartmei Exp $ */
d852 2
a853 2
							    "exceeds requested "
							    " hard limit");
d989 1
a989 1
	while ((ch = getopt(argc, argv, "Adeqf:F:hk:nNOrRs:Svx:z")) != -1) {
@


1.91
log
@Don't memcpy() structures that contain TAILQs. If you need a copy, you have
to perform a deep copy (memcpy() is shallow, and the structures contain
pointers to head/nodes). This solves the malloc.conf J segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.90 2002/11/23 09:33:54 deraadt Exp $ */
a695 1
		memcpy(&pf->pnat->nat, n, sizeof(pf->pnat->nat));
d697 1
d702 2
a703 2
			print_nat(&pf->pnat->nat);
		pfctl_clear_pool(&pf->pnat->nat.rpool);
a711 1
		memcpy(&pf->pbinat->binat, b, sizeof(pf->pbinat->binat));
d713 1
d718 1
a718 1
			print_binat(&pf->pbinat->binat);
a728 1
		memcpy(&pf->prdr->rdr, r, sizeof(pf->prdr->rdr));
d730 1
d735 2
a736 2
			print_rdr(&pf->prdr->rdr);
		pfctl_clear_pool(&pf->prdr->rdr.rpool);
@


1.90
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.89 2002/11/23 07:52:54 mcbride Exp $ */
d408 1
a408 1
		pa = malloc(sizeof(struct pf_pooladdr));
d410 1
a410 1
			err(1, "malloc");
d425 1
a425 1
	TAILQ_FOREACH(pa, &pool->list, entries) {
d577 1
a577 1
				err(1, "malloc");
a677 1
		memcpy(&pf->prule->rule, r, sizeof(pf->prule->rule));
d679 1
d684 2
a685 2
			print_rule(&pf->prule->rule);
		pfctl_clear_pool(&pf->prule->rule.rt_pool);
@


1.89
log
@don't try to do ioctl with pfctl -n

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.88 2002/11/23 05:22:24 mcbride Exp $ */
d415 1
a415 1
	} 
d448 1
a448 1
	
d541 1
a541 1
		if (pfctl_get_pool(dev, &pr.rdr.rpool, nr, 
d663 1
a663 1
		memcpy(&pf->paddr.addr, pa, sizeof(struct pf_pooladdr)); 
@


1.88
log
@code to support loading of pf rules with multiple redirection addresses
(in nat, rdr, route-to, dup-to and reply-to)

Syntax looks like this, see pf.conf(5) for details:

nat on wi0 proto { tcp, icmp } from any to 192.168.0.2 -> \
        192.168.0.16/29 source-hash random

rdr on wi0 proto { tcp } from any to 192.168.0.34 port 22 -> \
        { 192.168.0.8/31, 192.168.0.15 } port 22 round-robin

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.87 2002/11/22 12:24:30 henning Exp $ */
d656 4
a659 2
	if (ioctl(pf->dev, DIOCBEGINADDRS, &pf->paddr.ticket))
		err(1, "DIOCBEGINADDRS");
@


1.87
log
@print altq and queue lines in the pfctl -v case including the child queue
assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.86 2002/11/18 22:49:15 henning Exp $ */
d65 2
d77 1
d296 1
a296 1
	memset(&psk.psk_src.mask, 0xff, sizeof(psk.psk_src.mask));
d327 2
a328 2
			memset(&psk.psk_dst.mask, 0xff,
			    sizeof(psk.psk_dst.mask));
d386 46
d448 5
d473 1
d524 3
d528 1
d541 3
d545 1
d650 19
a668 1
/* callbacks for rule/nat/rdr */
d674 2
d683 1
d692 2
d701 1
d725 2
d734 1
@


1.86
log
@altq and pf merged

this isn't 100% done yet: the print_ stuff isn't finished, some features
will be added later, and there is no documetation yet, but committing now
enables a few more people to work on.

print_altq_node stuff hacked by Daniel at euroBSDcon; lotsa stuff from kjc,
debugging help also pb and camiel. lots of good ideas by theo.

"commit now" theo philipp daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.85 2002/10/07 14:34:40 dhartmei Exp $ */
a658 4
		if (pf->opts & PF_OPT_VERBOSE) {
			print_altq(&pf->paltq->altq, 0);
			printf("\n");
		}
@


1.85
log
@-Wsign-compare clean
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.84 2002/10/07 14:13:48 dhartmei Exp $ */
d54 1
d62 1
d67 1
d154 1
a154 1
	fprintf(stderr, "usage: %s [-deqhnNrROvz] [-f file] ", __progname);
d172 10
d196 10
d258 14
d424 27
d650 18
d675 1
d698 3
d711 1
d716 3
d728 3
d901 1
a901 1
	while ((ch = getopt(argc, argv, "deqf:F:hk:nNOrRs:Svx:z")) != -1) {
d941 4
d1005 3
d1017 1
d1044 3
d1062 1
@


1.84
log
@Two cases of const-correctness and make one global local.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.83 2002/07/05 14:07:32 henning Exp $ */
d442 2
a443 1
	int i, len = 0;
@


1.83
log
@allow unsetting the statusinterface via

set loginterface none

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.82 2002/07/01 05:28:22 deraadt Exp $ */
a72 1
int	 opts = 0;
d81 1
a81 1
char	*infile;
d802 1
@


1.82
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.81 2002/06/25 08:13:26 henning Exp $ */
d749 4
a752 1
			strlcpy(pi.ifname, ifname, sizeof(pi.ifname));
@


1.81
log
@move pfctl options -t, -m, -O and -l to pf.conf. These are set using the
"set" keyword. example rulefile:

set optimization aggressive
set timeout { tcp.closing 6, tcp.opening 6 }
set limit { states 1000, frags 1000 }
set loginterface wi0
pass out all keep state label "$nr:$srcaddr:$srcport:$dstaddr:$dstport"
block in all

fries@@ is working on an updated pf.conf(5)
discussed at c2k2 and on icb
ok dhartmei@@, kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.80 2002/06/14 17:31:30 henning Exp $ */
d80 1
a80 1
int 	 loadopt = PFCTL_FLAG_ALL;
d735 1
a735 1
			if ((r = pfctl_set_timeout(pf, hint[i].name, 
@


1.80
log
@make the output of pfctl -k look nice again
noticed by pb@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.79 2002/06/12 22:27:05 henning Exp $ */
a62 1
int	 pfctl_hint(int, const char *, int);
d67 2
a69 7
int	 pfctl_log(int, char *, int);
int	 pfctl_timeout(int, char *);
int	 pfctl_gettimeout(int, const char *);
int	 pfctl_settimeout(int, const char *, int);
int	 pfctl_limit(int, char *, int);
int	 pfctl_getlimit(int, const char *);
int	 pfctl_setlimit(int, const char *, unsigned int);
a74 2
char	*hintopt;
char	*logopt;
a76 2
char	*timeoutopt;
char	*limitopt;
d152 2
a153 2
	fprintf(stderr, "usage: %s [-deqhnrvz] [-f file] ", __progname);
	fprintf(stderr, "[-F modifier] [-k host] [-l interface]\n");
d155 1
a155 2
	fprintf(stderr, "[-m modifier] [-O level] [-s modifier] ");
	fprintf(stderr, "[-t modifier] [-x level]\n");
d488 35
d656 1
a656 1
pfctl_log(int dev, char *ifname, int opts)
d658 2
a659 1
	struct pfioc_if pi;
d661 18
a678 50
	strlcpy(pi.ifname, ifname, sizeof(pi.ifname));
	if (ioctl(dev, DIOCSETSTATUSIF, &pi))
		err(1, "DIOCSETSTATUSIF");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "now logging %s\n", pi.ifname);
	return (0);
}

int
pfctl_hint(int dev, const char *opt, int opts)
{
	const struct pf_hint *hint;
	int i, r;

	for (i = 0; pf_hints[i].name; i++)
		if (strcasecmp(opt, pf_hints[i].name) == 0)
			break;

	hint = pf_hints[i].hint;
	if (hint == NULL) {
		warnx("Bad hint name.  Format -O hint");
		return (1);
	}

	for (i = 0; hint[i].name; i++)
		if ((r = pfctl_settimeout(dev, hint[i].name, hint[i].timeout)))
			return (r);
	return (0);
}

int
pfctl_limit(int dev, char *opt, int opts)
{
	char *arg, *serr = NULL;
	unsigned int limit;

	arg = strchr(opt, '=');
	if (arg == NULL)
		return pfctl_getlimit(dev, opt);
	else {
		if (*arg)
			*arg++ = 0;
		if (strcasecmp(arg, "inf") == 0)
			limit = UINT_MAX;
		else {
			limit = strtol(arg, &serr, 10);
			if (*serr || !*arg) {
				warnx("Bad limit argument.  "
				    "Format -m name=limit");
				return (1);
d681 3
a683 22
		return pfctl_setlimit(dev, opt, limit);
	}
}

int
pfctl_getlimit(int dev, const char *opt)
{
	struct pfioc_limit pl;
	int i, found = 0;

	for (i = 0; pf_limits[i].name; i++) {
		if (strcmp(opt, "all") == 0 ||
		    strcasecmp(opt, pf_limits[i].name) == 0) {
			found = 1;
			pl.index = i;
			if (ioctl(dev, DIOCGETLIMIT, &pl))
				err(1, "DIOCGETLIMIT");
			printf("%-10s ", pf_limits[i].name);
			if (pl.limit == UINT_MAX)
				printf("unlimited\n");
			else
				printf("hard limit %6u\n", pl.limit);
a685 4
	if (found == 0) {
		warnx("Bad pool name.  Format -m name[=<limit>]");
		return (1);
	}
d690 1
a690 1
pfctl_setlimit(int dev, const char *opt, unsigned int limit)
d692 1
a692 1
	struct pfioc_limit pl;
d695 5
a699 24
	for (i = 0; pf_limits[i].name; i++) {
		if (strcasecmp(opt, pf_limits[i].name) == 0) {
			pl.index = i;
			pl.limit = limit;
			if (ioctl(dev, DIOCSETLIMIT, &pl)) {
				if (errno == EBUSY) {
					warnx("Current pool size exceeds "
					    "requested hard limit");
					return (1);
				} else
					err(1, "DIOCSETLIMIT");
			}
			if ((opts & PF_OPT_QUIET) == 0) {
				printf("%s ", pf_limits[i].name);
				if (pl.limit == UINT_MAX)
					printf("unlimited");
				else
					printf("hard limit %u", pl.limit);
				printf(" -> ");
				if (limit == UINT_MAX)
					printf("unlimited");
				else
					printf("hard limit %u", limit);
				printf("\n");
a700 1
			break;
a701 7
	}
	if (pf_limits[i].name == NULL) {
		warnx("Bad pool name.  Format -m name[=<limit>]");
		return (1);
	}
	return (0);
}
d703 4
a706 5
int
pfctl_timeout(int dev, char *opt)
{
	char *seconds, *serr = NULL;
	int setval;
d708 4
a711 11
	seconds = strchr(opt, '=');
	if (seconds == NULL)
		return pfctl_gettimeout(dev, opt);
	else {
		/* Set the timeout value */
		if (*seconds != '\0')
			*seconds++ = '\0';	/* Eat '=' */
		setval = strtol(seconds, &serr, 10);
		if (*serr != '\0' || *seconds == '\0' || setval < 0) {
			warnx("Bad timeout argument.  Format -t name=seconds");
			return (1);
a712 1
		return pfctl_settimeout(dev, opt, setval);
d714 1
d718 1
a718 1
pfctl_gettimeout(int dev, const char *opt)
d720 2
a721 2
	struct pfioc_tm pt;
	int i;
d723 9
a731 10
	for (i = 0; pf_timeouts[i].name; i++) {
		if (strcmp(opt, "all") == 0) {
			/* Need to dump all of the values */
			pt.timeout = pf_timeouts[i].timeout;
			if (ioctl(dev, DIOCGETTIMEOUT, &pt))
				err(1, "DIOCGETTIMEOUT");
			printf("%-20s %ds\n", pf_timeouts[i].name, pt.seconds);
		} else if (strcasecmp(opt, pf_timeouts[i].name) == 0) {
			pt.timeout = pf_timeouts[i].timeout;
			break;
a732 3
	}
	if (strcmp(opt, "all") == 0)
		return (0);
d734 4
a737 3
	if (pf_timeouts[i].name == NULL) {
		warnx("Bad timeout name.  Format -t name[=<seconds>]");
		return (1);
a738 6

	if (ioctl(dev, DIOCGETTIMEOUT, &pt))
		err(1, "DIOCGETTIMEOUT");
	if ((opts & PF_OPT_QUIET) == 0)
		printf("%s timeout %ds\n", pf_timeouts[i].name,
		    pt.seconds);
d743 1
a743 1
pfctl_settimeout(int dev, const char *opt, int seconds)
d745 1
a745 2
	struct pfioc_tm pt;
	int i;
d747 5
a751 4
	for (i = 0; pf_timeouts[i].name; i++) {
		if (strcasecmp(opt, pf_timeouts[i].name) == 0) {
			pt.timeout = pf_timeouts[i].timeout;
			break;
a753 12

	if (pf_timeouts[i].name == NULL) {
		warnx("Bad timeout name.  Format -t name[=<seconds>]");
		return (1);
	}

	pt.seconds = seconds;
	if (ioctl(dev, DIOCSETTIMEOUT, &pt))
		err(1, "DIOCSETTIMEOUT");
	if ((opts & PF_OPT_QUIET) == 0)
		fprintf(stderr, "%s timeout %ds -> %ds\n", pf_timeouts[i].name,
		    pt.seconds, seconds);
d804 1
a804 1
	while ((ch = getopt(argc, argv, "deqf:F:hk:l:m:nNO:rRs:St:vx:z")) != -1) {
a829 9
		case 'l':
			logopt = optarg;
			mode = O_RDWR;
			break;
		case 'm':
			limitopt = optarg;
			if (strchr(limitopt, '=') != NULL)
				mode = O_RDWR;
			break;
a836 4
		case 'O':
			hintopt = optarg;
			mode = O_RDWR;
			break;
d848 4
a854 5
		case 't':
			timeoutopt = optarg;
			if (strchr(timeoutopt, '=') != NULL)
				mode = O_RDWR;
			break;
d889 1
a889 1
		clearopt = logopt = showopt = debugopt = NULL;
d945 6
d957 2
a964 16

	if (logopt != NULL)
		if (pfctl_log(dev, logopt, opts))
			error = 1;

	if (hintopt != NULL)
		if (pfctl_hint(dev, hintopt, opts))
			error = 1;

	if (timeoutopt != NULL)
		if (pfctl_timeout(dev, timeoutopt))
			error = 1;

	if (limitopt != NULL)
		if (pfctl_limit(dev, limitopt, opts))
			error = 1;
@


1.79
log
@this stuff really belongs to stderr, not stdout
pointed out by ho@@
ok dhartmei@@, kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.78 2002/06/11 17:43:46 kjell Exp $ */
d352 2
a353 2
		fprintf(stderr, "killed %d states from %d sources and %d \
		    destinations\n", killed, sources, dests);
@


1.78
log
@Typo in err()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.77 2002/06/11 08:22:15 kjell Exp $ */
d180 1
a180 1
		printf("pf enabled\n");
d194 1
a194 1
		printf("pf disabled\n");
d204 1
a204 1
		printf("pf: statistics cleared\n");
d218 1
a218 1
		printf("rules cleared\n");
d242 1
a242 1
		printf("nat cleared\n");
d252 1
a252 1
		printf("states cleared\n");
d352 2
a353 2
		printf("killed %d states from %d sources and %d destinations\n",
		    killed, sources, dests);
d619 4
a622 4
			printf("%u nat entries loaded\n", n);
			printf("%u rdr entries loaded\n", r);
			printf("%u binat entries loaded\n", b);
			printf("%u rules loaded\n", n);
d640 1
a640 1
		printf("now logging %s\n", pi.ifname);
d838 1
a838 1
		printf("%s timeout %ds -> %ds\n", pf_timeouts[i].name,
d849 1
a849 1
		printf("debug level set to '");
d852 1
a852 1
			printf("none");
d855 1
a855 1
			printf("urgent");
d858 1
a858 1
			printf("misc");
d861 1
a861 1
			printf("<invalid>");
d864 1
a864 1
		printf("'\n");
d875 1
a875 1
		printf("pf: rule counters cleared\n");
@


1.77
log
@nuke an unused parameter in pfctl_timeout. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.76 2002/06/11 06:12:15 kjell Exp $ */
d809 1
a809 1
		err(1, "DIOCSETTIMEOUT");
@


1.76
log
@Add -N and -R options. When used in conjunction with
pfctl -f <rulefile> they allow just the nat or filter rules to
be reloaded, respectively. The default (no flags) is to load everything.
If -N is specified, any existing filter rules are retained,
similarly for -R.

ok deraadt@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.75 2002/06/11 02:26:10 henning Exp $ */
d70 1
a70 1
int	 pfctl_timeout(int, char *, int);
d761 1
a761 1
pfctl_timeout(int dev, char *opt, int opts)
d1067 1
a1067 1
		if (pfctl_timeout(dev, timeoutopt, opts))
@


1.75
log
@sync usage() with reality
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.74 2002/06/10 23:07:46 kjell Exp $ */
d90 1
d504 8
a511 4
	memcpy(&pf->prule->rule, r, sizeof(pf->prule->rule));
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCADDRULE, pf->prule))
			err(1, "DIOCADDRULE");
a512 2
	if (pf->opts & PF_OPT_VERBOSE)
		print_rule(&pf->prule->rule);
d519 8
a526 4
	memcpy(&pf->pnat->nat, n, sizeof(pf->pnat->nat));
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCADDNAT, pf->pnat))
			err(1, "DIOCADDNAT");
a527 2
	if (pf->opts & PF_OPT_VERBOSE)
		print_nat(&pf->pnat->nat);
d534 8
a541 4
	memcpy(&pf->pbinat->binat, b, sizeof(pf->pbinat->binat));
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCADDBINAT, pf->pbinat))
			err(1, "DIOCADDBINAT");
a542 2
	if (pf->opts & PF_OPT_VERBOSE)
		print_binat(&pf->pbinat->binat);
d549 8
a556 4
	memcpy(&pf->prdr->rdr, r, sizeof(pf->prdr->rdr));
	if ((pf->opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(pf->dev, DIOCADDRDR, pf->prdr))
			err(1, "DIOCADDRDR");
a557 2
	if (pf->opts & PF_OPT_VERBOSE)
		print_rdr(&pf->prdr->rdr);
d583 10
a592 7
		if (ioctl(dev, DIOCBEGINNATS, &pn.ticket))
			err(1, "DIOCBEGINNATS");
		if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket))
			err(1, "DIOCBEGINRDRS");
		if (ioctl(dev, DIOCBEGINBINATS, &pb.ticket))
			err(1, "DIOCBEGINBINATS");
		if (ioctl(dev, DIOCBEGINRULES, &pl.ticket))
d606 10
a615 7
		if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket))
			err(1, "DIOCCOMMITNATS");
		if (ioctl(dev, DIOCCOMMITRDRS, &pr.ticket))
			err(1, "DIOCCOMMITRDRS");
		if (ioctl(dev, DIOCCOMMITBINATS, &pb.ticket))
			err(1, "DIOCCOMMITBINATS");
		if (ioctl(dev, DIOCCOMMITRULES, &pl.ticket))
d890 1
a890 1
	while ((ch = getopt(argc, argv, "deqf:F:hk:l:m:nO:rs:t:vx:z")) != -1) {
d928 4
d942 4
@


1.74
log
@Merge the NAT and rules files into a single rulefile. Rules must be
in this order, to remove any ambiguity about what order things happen in:

scrub rules
nat rules
filter rules

The -N and -R modifiers go away. Rulefiles are now loaded with the
more POSIXly-correct '-f'

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.73 2002/06/10 15:19:13 mickey Exp $ */
d161 2
a162 2
	fprintf(stderr, "usage: %s [-dehnqrvz] [-F modifier] ", __progname);
	fprintf(stderr, "[-N file] [-O level] [-R file] [-k host]\n");
d164 1
a164 1
	fprintf(stderr, "[-l interface] [-m modifier] [-s modifier] ");
@


1.73
log
@some olde version piece crept into my diffski; pt out by dfa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.72 2002/06/09 02:14:29 deraadt Exp $ */
a68 1
int	 pfctl_nat(int, char *, int);
a82 1
char	*natopt;
a555 42
	struct pfioc_rule	pr;
	struct pfctl		pf;

	if (strcmp(filename, "-") == 0) {
		infile = "stdin";
		fin = stdin;
	} else {
		fin = fopen(filename, "r");
		infile = filename;
	}
	if (fin == NULL) {
		warn("%s", filename);
		return (1);
	}
	if ((opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(dev, DIOCBEGINRULES, &pr.ticket))
			err(1, "DIOCBEGINRULES");
	}
	/* fill in callback data */
	pf.dev = dev;
	pf.opts = opts;
	pf.prule = &pr;
	pf.rule_nr = 0;
	if (parse_rules(fin, &pf) < 0)
		errx(1, "syntax error in rule file: pf rules not loaded");
	if ((opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(dev, DIOCCOMMITRULES, &pr.ticket))
			err(1, "DIOCCOMMITRULES");
#if 0
		if ((opts & PF_OPT_QUIET) == 0)
			printf("%u rules loaded\n", n);
#endif
	}
	if (fin != stdin)
		fclose(fin);
	return (0);
}

int
pfctl_nat(int dev, char *filename, int opts)
{
	FILE *fin;
d559 1
a572 1

d580 2
d589 4
a592 2
	if (parse_nat(fin, &pf) < 0)
		errx(1, "syntax error in file: nat rules not loaded");
d600 2
d607 1
d875 1
a875 1
	while ((ch = getopt(argc, argv, "deqF:hk:l:m:nN:O:rR:s:t:vx:z")) != -1) {
a912 4
		case 'N':
			natopt = optarg;
			mode = O_RDWR;
			break;
d920 1
a920 1
		case 'R':
a1002 4
			error = 1;

	if (natopt != NULL)
		if (pfctl_nat(dev, natopt, opts))
@


1.72
log
@use strchr() instead of index()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.71 2002/06/08 16:44:15 drahn Exp $ */
d481 1
a481 1
			print_state(p, opts & PF_OPT_VERBOSE);
@


1.71
log
@pf_timeouts is shared between pfctl and authpf, put it in the shared file.
unbreak build.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.70 2002/06/08 07:58:07 dhartmei Exp $ */
d694 1
a694 1
	arg = index(opt, '=');
d788 1
a788 1
	seconds = index(opt, '=');
@


1.70
log
@Make state timeouts configurable per rule, like

  pass in from any to any port www keep state (tcp.established 60)

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.69 2002/06/07 21:25:35 dhartmei Exp $ */
a93 20

const struct pf_timeout pf_timeouts[] = {
	{ "tcp.first",		PFTM_TCP_FIRST_PACKET },
	{ "tcp.opening",	PFTM_TCP_OPENING },
	{ "tcp.established",	PFTM_TCP_ESTABLISHED },
	{ "tcp.closing",	PFTM_TCP_CLOSING },
	{ "tcp.finwait",	PFTM_TCP_FIN_WAIT },
	{ "tcp.closed",		PFTM_TCP_CLOSED },
	{ "udp.first",		PFTM_UDP_FIRST_PACKET },
	{ "udp.single",		PFTM_UDP_SINGLE },
	{ "udp.multiple",	PFTM_UDP_MULTIPLE },
	{ "icmp.first",		PFTM_ICMP_FIRST_PACKET },
	{ "icmp.error",		PFTM_ICMP_ERROR_REPLY },
	{ "other.first",	PFTM_OTHER_FIRST_PACKET },
	{ "other.single",	PFTM_OTHER_SINGLE },
	{ "other.multiple",	PFTM_OTHER_MULTIPLE },
	{ "frag",		PFTM_FRAG },
	{ "interval",		PFTM_INTERVAL },
	{ NULL,			0 }
};
@


1.69
log
@Add "(max <number>)" option for "keep/modulate state" to limit the number
of concurrent connections a rule can create. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.68 2002/06/06 22:22:44 mickey Exp $ */
d95 1
a95 4
static const struct {
	const char	*name;
	int		timeout;
} pf_timeouts[] = {
@


1.68
log
@split out the pf_state printing functions to be used elsewhere, no functional change; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.67 2002/06/03 16:13:17 kjell Exp $ */
d413 4
a416 3
				printf("[ Evaluations: %-10llu  Packets: %-10llu  "
				    "Bytes: %-10llu ]\n\n", pr.rule.evaluations,
				    pr.rule.packets, pr.rule.bytes);
@


1.67
log
@Also print labels in 'pfctl -s all'. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.66 2002/05/23 09:47:20 deraadt Exp $ */
d53 1
d503 1
a503 1
			print_state(p, opts);
@


1.66
log
@tiny KNF, some malloc checks, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.65 2002/05/19 22:26:27 deraadt Exp $ */
d1093 1
@


1.65
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.64 2002/05/19 22:15:19 deraadt Exp $ */
d75 1
a75 1
int	 pfctl_setlimit(int, const char *, unsigned);
a189 1

d713 1
a713 1
	unsigned limit;
d763 1
a763 1
pfctl_setlimit(int dev, const char *opt, unsigned limit)
d894 12
a905 12
			case PF_DEBUG_NONE:
				printf("none");
				break;
			case PF_DEBUG_URGENT:
				printf("urgent");
				break;
			case PF_DEBUG_MISC:
				printf("misc");
				break;
			default:
				printf("<invalid>");
				break;
@


1.64
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.63 2002/05/19 21:09:56 deraadt Exp $ */
d90 1
a90 1
char 	*state_kill[2];
d318 1
a318 1
		else 
d353 1
a353 1
				else 
@


1.63
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.62 2002/05/19 21:08:34 deraadt Exp $ */
d114 2
a115 1
	{ NULL,			0 }};
d123 2
a124 1
	{ NULL,		0 }};
d137 2
a138 1
	{ NULL,			0}};
d140 2
a141 2
	{ "tcp.first",		3 * 60},
	{ "tcp.opening",	30 + 5},
d143 5
a147 4
	{ "tcp.closing",	15 * 60 + 5},
	{ "tcp.finwait",	45 + 5},
	{ "tcp.closed",		90 + 5},
	{ NULL,			0}};
d155 2
a156 1
	{ NULL,			0}};
d164 2
a165 1
	{ NULL,			0}};
d177 2
a178 1
	{ NULL,			NULL }};
d378 1
a378 1
	return 0;
d534 1
a534 1
	return 0;
d547 1
a547 1
	return 0;
d560 1
a560 1
	return 0;
d573 1
a573 1
	return 0;
d701 1
a701 1
		return 1;
d706 1
a706 1
			return r;
d820 1
a820 1
			return 1;
d845 1
a845 1
		return 0;
d849 1
a849 1
		return 1;
d875 1
a875 1
		return 1;
a1141 1

a1142 1

@


1.62
log
@nicer usage
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.61 2002/04/24 18:10:25 dhartmei Exp $ */
d927 1
a927 2
	while ((ch = getopt(argc, argv, "deqF:hk:l:m:nN:O:rR:s:t:vx:z")) != -1)
	{
@


1.61
log
@Add dynamic (in-kernel) interface name -> address translation. Instead of
using just the interface name instead of an address and reloading the rule
set whenever the interface changes its address, the interface name can be
put in parentheses, and the kernel will keep track of changes and update
rules. There is no additional cost for evaluating rules (per packet),
the cost occurs when an interface changes address (and the rules are
traversed and updated where necessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.60 2002/04/01 20:01:16 dhartmei Exp $ */
d179 2
a180 1
	fprintf(stderr, "[-N file] [-O level] [-R file] [-k host] ");
@


1.60
log
@change return values back from EX_* to 0/1
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.59 2002/04/01 15:06:21 dhartmei Exp $ */
d304 1
a304 1
			psk.psk_src.addr.v4 =
d307 1
a307 1
			psk.psk_src.addr.v6 =
d338 1
a338 1
					psk.psk_dst.addr.v4 =
d342 1
a342 1
					psk.psk_dst.addr.v6 =
@


1.59
log
@style(9) improvements from Raymond M Schneider
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.58 2002/03/28 23:13:18 dhartmei Exp $ */
a50 1
#include <sysexits.h>
d183 1
a183 1
	exit(EX_USAGE);
d918 1
a918 1
	int error = EX_OK;
d1027 1
a1027 1
			error = EX_USAGE;
d1051 1
a1051 1
			error = EX_USAGE;
d1059 1
a1059 1
			error = EX_USAGE;
d1063 1
a1063 1
			error = EX_USAGE;
d1090 1
a1090 1
			error = EX_USAGE;
d1096 1
a1096 1
			error = EX_USAGE;
d1100 1
a1100 1
			error = EX_USAGE;
d1104 1
a1104 1
			error = EX_USAGE;
d1108 1
a1108 1
			error = EX_USAGE;
d1112 1
a1112 1
			error = EX_USAGE;
d1127 1
a1127 1
			error = EX_USAGE;
d1133 1
a1133 1
			error = EX_USAGE;
@


1.58
log
@prototype pfctl_kill_states()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.57 2002/03/26 17:37:11 frantzen Exp $ */
d51 1
d175 1
a175 1
usage()
d184 1
a184 1
	exit(1);
d472 1
a472 1
	while (1) {
d919 1
a919 1
	int error = 0;
d1001 1
d1028 1
a1028 1
			error = 1;
d1052 1
a1052 1
			error = 1;
d1060 1
a1060 1
			error = 1;
d1064 1
a1064 1
			error = 1;
d1091 1
a1091 1
			error = 1;
d1097 1
a1097 1
			error = 1;
d1101 1
a1101 1
			error = 1;
d1105 1
a1105 1
			error = 1;
d1109 1
a1109 1
			error = 1;
d1113 1
a1113 1
			error = 1;
d1128 1
a1128 1
			error = 1;
d1134 1
a1134 1
			error = 1;
@


1.57
log
@tidy up usage statement and sort headers.  patch from dfa@@solo.ee
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.56 2002/03/25 22:05:49 frantzen Exp $ */
d61 1
@


1.56
log
@add -k option to shootdown all the state entries from the specified host
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.55 2002/03/11 22:22:57 dhartmei Exp $ */
d36 1
d42 5
a50 5
#include <fcntl.h>
#include <errno.h>
#include <err.h>
#include <limits.h>
#include <netdb.h>
d177 5
a181 4
	fprintf(stderr, "usage: %s [-dehnqrv] [-F set] [-l interface] ",
	    __progname);
	fprintf(stderr, "[-N file] [-O level] [-R file] [-s set] [-t set] "
	    "[-x level] [-z]\n");
a916 2
	extern char *optarg;
	extern int optind;
@


1.55
log
@Add -r to reverse lookup addresses when displaying states.
From John Kerbawy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.54 2002/02/28 15:51:17 dhartmei Exp $ */
d39 1
d49 1
d87 2
d270 101
d925 2
a926 1
	while ((ch = getopt(argc, argv, "deqF:hl:m:nN:O:rR:s:t:vx:z")) != -1) {
d943 9
d1052 2
@


1.54
log
@Don't force /dev/pf to be opened read-write for pfctl -t/-m when values
are only queried but not set.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.53 2002/02/27 18:11:45 dhartmei Exp $ */
d172 1
a172 1
	fprintf(stderr, "usage: %s [-dehnqv] [-F set] [-l interface] ",
d820 1
a820 1
	while ((ch = getopt(argc, argv, "deqF:hl:m:nN:O:R:s:t:vx:z")) != -1) {
d856 3
@


1.53
log
@Instead of printing useless @@0 rule numbers from pfctl -vR, increase a
counter. Helps debugging rule sets that are not loaded. Suggested by
John Kerbawy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.52 2002/02/26 07:25:33 dhartmei Exp $ */
d843 2
a844 1
			mode = O_RDWR;
d866 2
a867 1
			mode = O_RDWR;
@


1.52
log
@Add optional pool memory hard limits, mainly as temporary solution
until pool exhaustion causes problems no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.51 2002/01/09 11:30:53 dhartmei Exp $ */
d486 1
@


1.51
log
@Add labels to rules. These are arbitrary names (not to be confused with
tags that will be used to tag packets later on). Add pfctl -z to clear
per-rule counters. Add pfctl -s labels to output per-rule counters in
terse format and only for rules that have labels. Suggested by
Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.50 2002/01/06 21:56:12 dhartmei Exp $ */
d47 1
d69 3
d83 1
d110 8
d594 94
d702 1
a702 1
			warnx("Bad timeout arguement.  Format -t name=seconds");
d819 1
a819 1
	while ((ch = getopt(argc, argv, "deqF:hl:nN:O:R:s:t:vx:z")) != -1) {
d840 4
d979 4
@


1.50
log
@-x needs read-write access for DIOCSETDEBUG ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.49 2001/12/31 16:48:36 mickey Exp $ */
d58 1
a58 1
int	 pfctl_show_rules(int, int);
d69 1
d161 2
a162 1
	fprintf(stderr, "[-N file] [-O level] [-R file] [-s set] [-t set] [-x level]\n");
d253 1
a253 1
pfctl_show_rules(int dev, int opts)
d269 19
a287 5
		print_rule(&pr.rule);
		if (opts & PF_OPT_VERBOSE)
			printf("[ Evaluations: %-10llu  Packets: %-10llu  "
			    "Bytes: %-10llu ]\n\n", pr.rule.evaluations,
			    pr.rule.packets, pr.rule.bytes);
d690 10
d712 1
a712 1
	while ((ch = getopt(argc, argv, "deqF:hl:nN:O:R:s:t:vx:")) != -1) {
d762 4
d832 4
a835 1
			pfctl_show_rules(dev, opts);
d847 1
a847 1
			pfctl_show_rules(dev, opts);
d889 5
@


1.49
log
@only open device for writing if we gonna modify anything
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.48 2001/12/10 18:08:12 dhartmei Exp $ */
d734 1
@


1.48
log
@Add stateful filtering for other (non-TCP/UDP/ICMP) protocol, based on
source/destination addresses/ports only.
Add RDR for ICMP. Add NAT/RDR/BINAT for other protocols.
Destination and redirection port(s) are now optional for RDR rules.
Not specifying destination port(s) means 'redirect all ports', not
specifying redirection port(s) means 'redirect to the original port'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.47 2001/10/04 21:54:15 dhartmei Exp $ */
d681 1
d690 1
d694 1
d701 1
d705 1
d712 1
d716 1
d720 1
d727 1
d748 2
d751 1
a751 1
		dev = open("/dev/pf", O_RDWR);
@


1.47
log
@Honour -v flag when printing states, print only one line per state when
non-verbose. Suggested by gwyllion@@ace.ulyssis.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.46 2001/10/02 18:18:28 frantzen Exp $ */
d97 3
@


1.46
log
@Remove duplication from simultaneous commits
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.45 2001/10/02 18:00:38 frantzen Exp $ */
d60 1
a60 1
int	 pfctl_show_states(int, u_int8_t);
d324 1
a324 1
pfctl_show_states(int dev, u_int8_t proto)
d355 1
a355 1
			print_state(p);
d793 1
a793 1
			pfctl_show_states(dev, 0);
d801 1
a801 1
			pfctl_show_states(dev, 0);
@


1.45
log
@Typo fixes (thanks gwyllion@@ace.ulyssis.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.44 2001/10/02 17:55:24 dhartmei Exp $ */
a554 1
	hint = pf_hints[i].hint;
@


1.44
log
@'pfctl -O foo' dumped core. A check was there, but didn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.43 2001/10/01 17:58:16 markus Exp $ */
d116 1
d134 1
a134 1
	{ "tcp.finwait",	60 },
d549 2
a550 1
	if (pf_hints[i].name == NULL) {
@


1.43
log
@print variable asignments only if -v is given. ok dhartmei/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.42 2001/10/01 14:38:34 dhartmei Exp $ */
d548 1
a548 2
	hint = pf_hints[i].hint;
	if (hint->name == NULL) {
d553 1
@


1.42
log
@Print error message when pfctl -N/-R can't open the specified file
(instead of failing silently). Found by niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.41 2001/09/30 05:29:37 frantzen Exp $ */
a48 6

#define PF_OPT_DISABLE		0x0001
#define PF_OPT_ENABLE		0x0002
#define PF_OPT_VERBOSE		0x0004
#define PF_OPT_NOACTION		0x0008
#define PF_OPT_QUIET		0x0010
@


1.41
log
@Selectable preset FSM optimizations for several network environments.
Thanks to everyone who sent me packet captures!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.40 2001/09/22 18:30:11 deraadt Exp $ */
d447 2
a448 1
	if (fin == NULL)
d450 1
d490 2
a491 1
	if (fin == NULL)
d493 1
@


1.40
log
@remove debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.39 2001/09/06 18:05:46 jasoni Exp $ */
d63 1
d78 1
d107 48
d162 1
a162 1
	fprintf(stderr, "[-N file] [-R file] [-s set] [-t set] [-x level]\n");
d541 22
d683 1
a683 1
	while ((ch = getopt(argc, argv, "deqF:hl:nN:R:s:t:vx:")) != -1) {
d706 3
d813 4
@


1.39
log
@1:1 bidrectional NAT (binat); ok dhartmei@@ and frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.38 2001/08/28 00:02:43 frantzen Exp $ */
a85 1

d299 1
a299 2
		if (len == 0 && ps.ps_len == 0) {
			printf("no states\n");
a300 1
		}
@


1.38
log
@Bump state timeouts and allow tweaking them from pfctl.
(The state timeouts need some _serious_ tuning)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.37 2001/08/23 04:10:31 deraadt Exp $ */
d173 1
d180 4
d234 1
d263 13
d361 13
d430 1
d449 2
d456 1
d465 2
d471 1
@


1.37
log
@for -s all, do not error out when the first ioctl fails
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.36 2001/08/19 19:57:33 deraadt Exp $ */
d70 3
d81 1
d86 20
d113 1
a113 1
	fprintf(stderr, "[-N file] [-R file] [-s set] [-x level]\n");
d455 83
d575 1
a575 1
	while ((ch = getopt(argc, argv, "deqF:hl:nN:R:s:vx:")) != -1) {
d604 3
d702 4
@


1.36
log
@do not spin if no states are found
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.35 2001/08/19 19:03:58 dhartmei Exp $ */
d4 1
a4 1
 * Copyright (c) 2001, Daniel Hartmeier
d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer. 
d16 1
a16 1
 *      with the distribution. 
d180 4
a183 2
	if (ioctl(dev, DIOCGETRULES, &pr))
		err(1, "DIOCGETRULES");
d187 4
a190 2
		if (ioctl(dev, DIOCGETRULE, &pr))
			err(1, "DIOCGETRULE");
d207 4
a210 2
	if (ioctl(dev, DIOCGETNATS, &pn))
		err(1, "DIOCGETNATS");
d214 4
a217 2
		if (ioctl(dev, DIOCGETNAT, &pn))
			err(1, "DIOCGETNAT");
d220 4
a223 2
	if (ioctl(dev, DIOCGETRDRS, &pr))
		err(1, "DIOCGETRDRS");
d227 4
a230 2
		if (ioctl(dev, DIOCGETRDR, &pr))
			err(1, "DIOCGETRDR");
d251 4
a254 2
		if (ioctl(dev, DIOCGETSTATES, &ps) < 0)
			err(1, "DIOCGETSTATES");
d257 4
d281 4
a284 2
	if (ioctl(dev, DIOCGETSTATUS, &status))
		err(1, "DIOCGETSTATUS");
@


1.35
log
@Add per-rule byte counter, so mickey can do accounting. We're counting the
data part (without IP and TCP/UDP/ICMP headers), like the state counter does.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.34 2001/08/19 18:20:46 dhartmei Exp $ */
d245 2
@


1.34
log
@Print per-rule statistics when -v is used with -sr (show rules).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.33 2001/08/18 21:09:13 deraadt Exp $ */
d189 3
a191 2
			printf("[ Evaluations: %-10llu  Packets: %-10llu ]\n\n",
			    pr.rule.evaluations, pr.rule.packets);
@


1.33
log
@make pfctl -s state SCREAM; frantzen is now happy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.32 2001/08/11 12:05:00 dhartmei Exp $ */
d63 1
a63 1
int	 pfctl_show_rules(int);
d175 1
a175 1
pfctl_show_rules(int dev)
d188 3
d544 1
a544 1
			pfctl_show_rules(dev);
d556 1
a556 1
			pfctl_show_rules(dev);
@


1.32
log
@Add support for ICMP errors referring to ICMP queries/replies. Fixes
'ICMP error message for bad proto' messages. Reported by Mark Grimes
and Steve Rumble.

Add debugging level with ioctl interface and pfctl switch. Default
is 'None'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.31 2001/08/11 09:54:59 deraadt Exp $ */
d223 25
a247 7
	struct pfioc_state ps;

	ps.nr = 0;
	while (!ioctl(dev, DIOCGETSTATE, &ps)) {
		if (!proto || (ps.state.proto == proto))
			print_state(&ps.state);
		ps.nr++;
a363 1
		
d396 1
a396 1
	strncpy(pi.ifname, ifname, 16);
a504 1
		
@


1.31
log
@\+\n support, and spit out cc-style error messages.  the parser's line
counting is lex dependent, and will need to be tweaked
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.30 2001/07/26 12:55:15 dhartmei Exp $ */
d70 1
d78 1
d89 1
a89 1
	fprintf(stderr, "[-N file] [-R file] [-s set]\n");
d388 26
d425 1
a425 1
	while ((ch = getopt(argc, argv, "deqF:hl:nN:R:s:v")) != -1) {
d457 3
d480 1
a480 1
		clearopt = logopt = showopt = NULL;
d555 17
@


1.30
log
@usage() with __progname according to style(9), typo in man page. both from mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.29 2001/07/17 17:39:09 marc Exp $ */
d78 2
d291 2
a292 1
	if (strcmp(filename, "-") == 0)
d294 1
a294 1
	else
d296 2
d331 1
a331 1
	if (strcmp(filename, "-") == 0)
d333 2
a334 1
	else
d336 2
@


1.29
log
@bitch about extra command line args; ok dhartmei@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.28 2001/07/16 21:09:37 markus Exp $ */
d81 4
a84 1
	fprintf(stderr, "usage: pfctl [-dehnqv] [-F set] [-l interface] ");
@


1.28
log
@add a yacc parser for pf.conf and nat.conf, with help from mickey@@,
plus: -n now turns off all operations, and just parses the conf files
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.27 2001/07/05 11:40:25 ho Exp $ */
d423 6
@


1.27
log
@&, not &&. Pointed out by dhartmei@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.26 2001/07/03 12:10:45 ho Exp $ */
a56 1
char	*load_file(char *, size_t *);
a85 67
char *
load_file(char *name, size_t *len)
{
	FILE *file;
	char *buf = 0, *buf2 = 0;
	u_int32_t i;

	if (!strcmp(name, "-"))
		file = stdin;
	else  
		file = fopen(name, "r");

	*len = 0;
	if (file == NULL) {
		fprintf(stderr, "ERROR: couldn't open file %s (%s)\n",
		    name, strerror(errno));
		return (0);
	}

	i = 512;	/* Start with this. Grow it as req'd */
	*len = 0;
	if ((buf = malloc(i)) == NULL) {
		fprintf(stderr, "ERROR: could not allocate space "
			"for rules file\n");
		return (0);
	}
	while (!feof(file)) {
		*len += fread((buf + *len), 1, (i - *len), file);
		if (*len == i) {
			/* Out of space - realloc time */
			i *= 2;
			if ((buf2 = realloc(buf, i)) == NULL) {
				if (buf)
					free(buf);
				buf = NULL;
				fprintf(stderr, "ERROR: realloc of "
					"stdin buffer failed\n");
				return (0);
			}
			buf = buf2;
		}
	}
	if (*len == i) {
		/* 
		 * file is exactly the size of our buffer.
		 * grow ours one so we can null terminate it
		 */
		if ((buf2 = realloc(buf, i+1)) == NULL) {
			if (buf)
				free(buf);
			buf = NULL;
			fprintf(stderr, "ERROR: realloc of "
				"stdin buffer failed\n");
			return (0);
		}
		buf = buf2;
	}
	if (file != stdin)
		fclose(file);
	buf[*len]='\0';
	if (strlen(buf) != *len) {
		fprintf(stderr, "WARNING: nulls embedded in rules file\n");
		*len = strlen(buf);
	}
	return (buf);
}

d238 41
d282 9
a290 7
	struct pfioc_rule pr;
	char *buf, *s;
	size_t len;
	unsigned n, nr;

	buf = load_file(filename, &len);
	if (buf == NULL)
d296 6
a301 18
	n = 0;
	nr = 0;
	s = buf;
	do {
		char *line = next_line(&s);
		nr++;
		if (*line && (*line != '#'))
			if (parse_rule(nr, line, &pr.rule)) {
				if ((opts & PF_OPT_NOACTION) == 0) {
					if (ioctl(dev, DIOCADDRULE, &pr))
						err(1, "DIOCADDRULE");
				}
				if (opts & PF_OPT_VERBOSE)
					print_rule(&pr.rule);
				n++;
			}
	} while (s < (buf + len));
	free(buf);
d305 1
d308 1
d310 2
d318 11
a328 5
	struct pfioc_nat pn;
	struct pfioc_rdr pr;
	char *buf, *s;
	size_t len;
	unsigned n, r, nr;
d337 7
a343 31

	buf = load_file(filename, &len);
	if (buf == NULL)
		return (1);
	n = 0;
	r = 0;
	nr = 0;
	s = buf;
	do {
		char *line = next_line(&s);
		nr++;
		if (*line && (*line == 'n'))
			if (parse_nat(nr, line, &pn.nat)) {
				if ((opts & PF_OPT_NOACTION) == 0)
					if (ioctl(dev, DIOCADDNAT, &pn))
						err(1, "DIOCADDNAT");
				if (opts & PF_OPT_VERBOSE)
					print_nat(&pn.nat);
				n++;
			}
		if (*line && (*line == 'r'))
			if (parse_rdr(nr, line, &pr.rdr)) {
				if ((opts & PF_OPT_NOACTION) == 0)
					if (ioctl(dev, DIOCADDRDR, &pr))
						err(1, "DIOCADDRDR");
				if (opts & PF_OPT_VERBOSE)
					print_rdr(&pr.rdr);
				r++;
			}
	} while (s < (buf + len));

d349 1
d354 1
d356 2
a357 1
	free(buf);
d380 1
a380 1
	int dev;
d425 9
a433 3
	dev = open("/dev/pf", O_RDWR);
	if (dev == -1)
		err(1, "open(\"/dev/pf\")");
@


1.26
log
@Add a -q (quiet) option. dhartmei@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.25 2001/07/01 16:58:51 kjell Exp $ */
d163 1
a163 1
	if ((opts && PF_OPT_QUIET) == 0)
d177 1
a177 1
	if ((opts && PF_OPT_QUIET) == 0)
d187 1
a187 1
	if ((opts && PF_OPT_QUIET) == 0)
d201 1
a201 1
	if ((opts && PF_OPT_QUIET) == 0)
d220 1
a220 1
	if ((opts && PF_OPT_QUIET) == 0)
d230 1
a230 1
	if ((opts && PF_OPT_QUIET) == 0)
d342 1
a342 1
		if ((opts && PF_OPT_QUIET) == 0)
@


1.25
log
@Finish with posixifying command options. Now both "pfctl -Fs" and
"pfctl -F states" work.

Changed -[Fs]S to -[Fs] info (or -[Fs]i) based on an earlier conversation
with theo.

Added -[Fs] "all" to show or flush everything

Fixup some man page pastos in the process
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.24 2001/06/29 21:11:24 kjell Exp $ */
d54 1
d58 6
a63 6
int	 pfctl_enable(int);
int	 pfctl_disable(int);
int	 pfctl_clear_stats(int);
int	 pfctl_clear_rules(int);
int	 pfctl_clear_nat(int);
int	 pfctl_clear_states(int);
d70 1
a70 1
int	 pfctl_log(int, char *);
d82 1
a82 1
	fprintf(stderr, "usage: pfctl [-denvh] [-F set] [-l interface] ");
d155 1
a155 1
pfctl_enable(int dev)
d163 2
a164 1
	printf("pf enabled\n");
d169 1
a169 1
pfctl_disable(int dev)
d177 2
a178 1
	printf("pf disabled\n");
d183 1
a183 1
pfctl_clear_stats(int dev)
d187 2
a188 1
	printf("pf: statistics cleared\n");
d193 1
a193 1
pfctl_clear_rules(int dev)
d201 2
a202 1
	printf("rules cleared\n");
d207 1
a207 1
pfctl_clear_nat(int dev)
d220 2
a221 1
	printf("nat cleared\n");
d226 1
a226 1
pfctl_clear_states(int dev)
d230 2
a231 1
	printf("states cleared\n");
d342 2
a343 1
		printf("%u rules loaded\n", n);
d400 4
a403 2
		printf("%u nat entries loaded\n", n);
		printf("%u rdr entries loaded\n", r);
d410 1
a410 1
pfctl_log(int dev, char *ifname)
d417 2
a418 1
	printf("now logging %s\n", pi.ifname);
d434 1
a434 1
	while ((ch = getopt(argc, argv, "deF:hl:nN:R:s:v")) != -1) {
d442 3
d478 1
a478 1
		if (pfctl_disable(dev))
d485 1
a485 1
			pfctl_clear_rules(dev);
d488 1
a488 1
			pfctl_clear_nat(dev);
d491 1
a491 1
			pfctl_clear_states(dev);
d494 1
a494 1
			pfctl_clear_stats(dev);
d497 4
a500 4
			pfctl_clear_rules(dev);
			pfctl_clear_nat(dev);
			pfctl_clear_states(dev);
			pfctl_clear_stats(dev);
d543 1
a543 1
		if (pfctl_log(dev, logopt))
d547 1
a547 1
		if (pfctl_enable(dev))
@


1.24
log
@change load_file implementation so we can accept input on
stdin. Rewrite NAT processing loop to accomodate this fact
(we can only read the rules file once). ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.23 2001/06/28 20:30:53 dhartmei Exp $ */
d81 2
a82 4
	extern char *__progname;
 
	fprintf(stderr, "usage: %s [-de] [-F set] [-l interface]", __progname);
	fprintf(stderr, " [-n] [-N file] [-R file] [-s set] [-v]\n");
d468 21
a488 13
		if (!strcmp(clearopt, "r")) {
			if (pfctl_clear_rules(dev))
				error = 1;
		} else if (!strcmp(clearopt, "n")) {
			if (pfctl_clear_nat(dev))
				error = 1;
		} else if (!strcmp(clearopt, "s")) {
			if (pfctl_clear_states(dev))
				error = 1;
		} else if (!strcmp (clearopt, "S")) {
			if (pfctl_clear_stats(dev))
				error = 1;
		} else {
d503 20
a522 13
		if (!strcmp(showopt, "r")) {
			if (pfctl_show_rules(dev))
				error = 1;
		} else if (!strcmp(showopt, "n")) {
			if (pfctl_show_nat(dev))
				error = 1;
		} else if (!strcmp(showopt, "s")) {
			if (pfctl_show_states(dev, 0))
				error = 1;
		} else if (!strcmp(showopt, "S")) {
			if (pfctl_show_status(dev))
				error = 1;
		} else {
@


1.23
log
@usage() was out of date
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.22 2001/06/27 21:54:47 kjell Exp $ */
d91 8
a98 2
	FILE *file = fopen(name, "r");
	char *buf = 0;
d106 6
a111 7
	fseek(file, 0, SEEK_END);
	*len = ftell(file);
	fseek(file, 0, SEEK_SET);
	buf = malloc(*len);
    	if (buf == NULL) {
		fclose(file);
		fprintf(stderr, "ERROR: malloc() failed\n");
d114 32
a145 2
	if (fread(buf, 1, *len, file) != *len) {
		free(buf);
d147 4
a150 2
		fprintf(stderr, "ERROR: fread() failed\n");
		return (0);
a151 1
	fclose(file);
d349 1
a349 1
	unsigned n, nr;
d351 1
a351 1
	if ((opts & PF_OPT_NOACTION) == 0) 
d354 4
d363 1
a377 19
	} while (s < (buf + len));
	free(buf);
	if ((opts & PF_OPT_NOACTION) == 0) {
		if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket))
			err(1, "DIOCCOMMITNATS");
		printf("%u nat entries loaded\n", n);

		if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket))
			err(1, "DIOCBEGINRDRS");
	}
	buf = load_file(filename, &len);
	if (buf == NULL)
		return (1);
	n = 0;
	nr = 0;
	s = buf;
	do {
		char *line = next_line(&s);
		nr++;
d385 1
a385 1
				n++;
d388 1
a388 1
	free(buf);
d390 2
d394 2
a395 1
		printf("%u rdr entries loaded\n", n);
d397 1
@


1.22
log
@Change flag syntax
-Fs, -Fn, -Fr, -FS to flush states, nat rules, filter rules, stats
-ss, -sn, -sr, -sS to show them
-z goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.21 2001/06/27 21:27:47 dhartmei Exp $ */
d83 2
a84 2
	fprintf(stderr, "usage: %s [-de] [-c set] [-l interface]", __progname);
	fprintf(stderr, " [-N] [-n file] [-r file] [-s set] [-v] [-z]\n");
@


1.21
log
@errx() doesn't return. use err() to get errno as well. translate two common errno. ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.20 2001/06/27 19:06:32 kjell Exp $ */
a53 1
#define PF_OPT_ZEROSTATS	0x0010
d399 1
a399 1
	while ((ch = getopt(argc, argv, "c:dehl:Nn:r:s:vz")) != -1) {
a400 3
		case 'c':
			clearopt = optarg;
			break;
d407 3
d413 1
a413 1
		case 'N':
d416 1
a416 1
		case 'n':
d419 1
a419 1
		case 'r':
a427 3
		case 'z':
			opts |= PF_OPT_ZEROSTATS;
			break;
a442 4
	if (opts & PF_OPT_ZEROSTATS)
		if (pfctl_clear_stats(dev))
			error = 1;

d444 1
a444 1
		if (!strcmp(clearopt, "rules")) {
d447 1
a447 1
		} else if (!strcmp(clearopt, "nat")) {
d450 1
a450 1
		} else if (!strcmp(clearopt, "states")) {
d453 3
d457 1
a457 1
			warnx("Unknown keyword '%s'", clearopt);
d471 1
a471 1
		if (!strcmp(showopt, "rules")) {
d474 1
a474 1
		} else if (!strcmp(showopt, "nat")) {
d477 1
a477 1
		} else if (!strcmp(showopt, "states")) {
d480 1
a480 1
		} else if (!strcmp(showopt, "status")) {
d484 1
a484 1
			warnx("Unknown keyword '%s'", showopt);
@


1.20
log
@Use bitfields for flag options in getopt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.19 2001/06/27 10:31:49 kjell Exp $ */
d124 4
a127 2
		errx(1, "DIOCSTART");
		return (1);
d137 4
a140 2
		errx(1, "DIOCSTOP");
		return (1);
d149 2
a150 4
	if (ioctl(dev, DIOCCLRSTATUS)) {
		errx(1, "DIOCCLRSTATUS");
		return (1);
	}
d160 4
a163 7
	if (ioctl(dev, DIOCBEGINRULES, &pr.ticket)) {
		errx(1, "DIOCBEGINRULES");
		return (1);
	} else if (ioctl(dev, DIOCCOMMITRULES, &pr.ticket)) {
		errx(1, "DIOCCOMMITRULES");
		return (1);
	}
d174 8
a181 13
	if (ioctl(dev, DIOCBEGINNATS, &pn.ticket)) {
		errx(1, "DIOCBEGINNATS");
		return (1);
	} else if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket)) {
		errx(1, "DIOCCOMMITNATS");
		return (1);
	} else if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket)) {
		errx(1, "DIOCBEGINRDRS");
		return (1);
	} else if (ioctl(dev, DIOCCOMMITRDRS, &pr.ticket)) {
		errx(1, "DIOCCOMMITRDRS");
		return (1);
	}
d189 2
a190 4
	if (ioctl(dev, DIOCCLRSTATES)) {
		errx(1, "DIOCCLRSTATES");
		return (1);
	}
d201 2
a202 4
	if (ioctl(dev, DIOCGETRULES, &pr)) {
		errx(1, "DIOCGETRULES");
		return (1);
	}
d206 2
a207 4
		if (ioctl(dev, DIOCGETRULE, &pr)) {
			errx(1, "DIOCGETRULE");
			return (1);
		}
d220 2
a221 4
	if (ioctl(dev, DIOCGETNATS, &pn)) {
		errx(1, "DIOCGETNATS");
		return (1);
	}
d225 2
a226 4
		if (ioctl(dev, DIOCGETNAT, &pn)) {
			errx(1, "DIOCGETNAT");
			return (1);
		}
d229 2
a230 4
	if (ioctl(dev, DIOCGETRDRS, &pr)) {
		errx(1, "DIOCGETRDRS");
		return (1);
	}
d234 2
a235 4
		if (ioctl(dev, DIOCGETRDR, &pr)) {
			errx(1, "DIOCGETRDR");
			return (1);
		}
d260 2
a261 4
	if (ioctl(dev, DIOCGETSTATUS, &status)) {
		errx(1, "DIOCGETSTATUS");
		return (1);
	}
d278 2
a279 5
		if (ioctl(dev, DIOCBEGINRULES, &pr.ticket)) {
			errx(1, "DIOCBEGINRULES");
			free(buf);
			return (1);
		}
d290 2
a291 5
					if (ioctl(dev, DIOCADDRULE, &pr)) {
						errx(1, "DIOCADDRULE");
						free(buf);
						return (1);
					}
d300 2
a301 4
		if (ioctl(dev, DIOCCOMMITRULES, &pr.ticket)) {
			errx(1, "DIOCCOMMITRULES");
			return (1);
		}
d317 2
a318 4
		if (ioctl(dev, DIOCBEGINNATS, &pn.ticket)) {
			errx(1, "DIOCBEGINNATS");
			return (1);
		}
d332 2
a333 5
					if (ioctl(dev, DIOCADDNAT, &pn)) {
						errx(1, "DIOCADDNAT");
						free(buf);
						return (1);
					}
d341 2
a342 4
		if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket)) {
			errx(1, "DIOCCOMMITNATS");
			return (1);
		}
d345 2
a346 4
		if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket)) {
			errx(1, "DIOCBEGINRDRS");
			return 1;
		}
d360 2
a361 5
					if (ioctl(dev, DIOCADDRDR, &pr)) {
						errx(1, "DIOCADDRDR");
						free(buf);
						return (1);
					}
d369 2
a370 4
		if (ioctl(dev, DIOCCOMMITRDRS, &pr.ticket)) {
			errx(1, "DIOCCOMMITRDRS");
			return (1);
		}
d382 2
a383 4
	if (ioctl(dev, DIOCSETSTATUSIF, &pi)) {
		errx(1, "DIOCSETSTATUSIF");
		return (1);
	}
d440 2
a441 4
	if (dev == -1) {
		errx(1, "/dev/pf");
		return (1);
	}
@


1.19
log
@add -z flag for zeroing statistics. -s status no longer resets anything
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.18 2001/06/26 23:24:06 kjell Exp $ */
d50 6
d68 2
a69 2
int	 pfctl_rules(int, char *, int, int);
int	 pfctl_nat(int, char *, int, int);
d72 1
a72 5
int	 dflag = 0;
int	 eflag = 0;
int	 vflag = 0;
int	 Nflag = 0;
int	 zflag = 0;
d289 1
a289 1
pfctl_rules(int dev, char *filename, int nflag, int vflag)
d299 1
a299 1
	if (!nflag) {
d314 1
a314 1
				if (!nflag) {
d321 1
a321 1
				if (vflag)
d327 1
a327 1
	if (!nflag) {
d338 1
a338 1
pfctl_nat(int dev, char *filename, int nflag, int vflag)
d346 1
a346 1
	if (!nflag) 
d363 1
a363 1
				if (!nflag)
d369 1
a369 1
				if (vflag)
d375 1
a375 1
	if (!nflag) {
d398 1
a398 1
				if (!nflag)
d404 1
a404 1
				if (vflag)
d410 1
a410 1
	if (!nflag) {
d446 1
a446 1
	while ((ch = getopt(argc, argv, "c:del:Nn:r:s:vz")) != -1) {
d452 1
a452 1
			dflag++;
d455 1
a455 1
			eflag++;
d461 1
a461 1
			Nflag++;
d473 1
a473 1
			vflag++;
d476 1
a476 1
			zflag++;
d478 1
d491 1
a491 1
	if (dflag)
d495 1
a495 1
	if (zflag)
d516 1
a516 1
		if (pfctl_rules(dev, rulesopt, Nflag, vflag))
d520 1
a520 1
		if (pfctl_nat(dev, natopt, Nflag, vflag))
d546 1
a546 1
	if (eflag)
@


1.18
log
@Add -N (parse, but do not load) and -v (verbose: show parsed rules)
for pf and nat rules.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.17 2001/06/26 22:24:14 provos Exp $ */
d54 1
d70 1
d83 1
a83 1
	fprintf(stderr, " [-n file] [-r file] [-s set]\n");
d141 11
d444 1
a444 1
	while ((ch = getopt(argc, argv, "c:del:Nn:r:s:v")) != -1) {
d473 3
d490 4
@


1.17
log
@bad smart
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.16 2001/06/26 22:19:47 smart Exp $ */
d61 2
a62 2
int	 pfctl_rules(int, char *);
int	 pfctl_nat(int, char *);
d65 4
a68 2
int	 dflag;
int	 eflag;
d274 1
a274 1
pfctl_rules(int dev, char *filename)
d284 6
a289 4
	if (ioctl(dev, DIOCBEGINRULES, &pr.ticket)) {
		errx(1, "DIOCBEGINRULES");
		free(buf);
		return (1);
d299 6
a304 4
				if (ioctl(dev, DIOCADDRULE, &pr)) {
					errx(1, "DIOCADDRULE");
					free(buf);
					return (1);
d306 2
d312 6
a317 3
	if (ioctl(dev, DIOCCOMMITRULES, &pr.ticket)) {
		errx(1, "DIOCCOMMITRULES");
		return (1);
a318 1
	printf("%u rules loaded\n", n);
d323 1
a323 1
pfctl_nat(int dev, char *filename)
d331 6
a336 4
	if (ioctl(dev, DIOCBEGINNATS, &pn.ticket)) {
		errx(1, "DIOCBEGINNATS");
		return (1);
	}
d348 8
a355 5
				if (ioctl(dev, DIOCADDNAT, &pn)) {
					errx(1, "DIOCADDNAT");
					free(buf);
					return (1);
				}
d360 6
a365 5
	if (ioctl(dev, DIOCCOMMITNATS, &pn.ticket)) {
		errx(1, "DIOCCOMMITNATS");
		return (1);
	}
	printf("%u nat entries loaded\n", n);
d367 4
a370 3
	if (ioctl(dev, DIOCBEGINRDRS, &pr.ticket)) {
		errx(1, "DIOCBEGINRDRS");
		return 1;
d383 8
a390 5
				if (ioctl(dev, DIOCADDRDR, &pr)) {
					errx(1, "DIOCADDRDR");
					free(buf);
					return (1);
				}
d395 6
a400 3
	if (ioctl(dev, DIOCCOMMITRDRS, &pr.ticket)) {
		errx(1, "DIOCCOMMITRDRS");
		return (1);
a401 1
	printf("%u rdr entries loaded\n", n);
d431 1
a431 1
	while ((ch = getopt(argc, argv, "c:del:n:r:s:")) != -1) {
d445 3
d457 3
d493 1
a493 1
		if (pfctl_rules(dev, rulesopt))
d497 1
a497 1
		if (pfctl_nat(dev, natopt))
@


1.16
log
@Add err.h for errx()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.15 2001/06/26 22:18:17 provos Exp $ */
a39 1
#include <err.h>
@


1.15
log
@some warnx, and exit instead of return
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.14 2001/06/26 20:50:26 dhartmei Exp $ */
d40 1
@


1.14
log
@add rule nr for Niels
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.13 2001/06/26 17:46:02 deraadt Exp $ */
d46 1
d458 2
a459 1
		} else
d461 1
d485 2
a486 1
		} else
d488 1
d500 2
a501 1
	return (error);
@


1.13
log
@use errx()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.12 2001/06/26 00:18:30 jasoni Exp $ */
a201 1
		printf("@@%u ", nr + 1);
@


1.12
log
@display usage if no command line args; ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.11 2001/06/25 22:14:07 smart Exp $ */
a48 1
void	 print_error(char *);
a72 7
print_error(char *s)
{
	fprintf(stderr, "ERROR: %s: %s\n", s, strerror(errno));
	return;
}

void
d85 1
a86 1
	FILE *file = fopen(name, "r");
d117 1
a117 1
		print_error("DIOCSTART");
d128 1
a128 1
		print_error("DIOCSTOP");
d141 1
a141 1
		print_error("DIOCBEGINRULES");
d144 1
a144 1
		print_error("DIOCCOMMITRULES");
d158 1
a158 1
		print_error("DIOCBEGINNATS");
d161 1
a161 1
		print_error("DIOCCOMMITNATS");
d164 1
a164 1
		print_error("DIOCBEGINRDRS");
d167 1
a167 1
		print_error("DIOCCOMMITRDRS");
d178 1
a178 1
		print_error("DIOCCLRSTATES");
d192 1
a192 1
		print_error("DIOCGETRULES");
d199 1
a199 1
			print_error("DIOCGETRULE");
d216 1
a216 1
		print_error("DIOCGETNATS");
d223 1
a223 1
			print_error("DIOCGETNAT");
d229 1
a229 1
		print_error("DIOCGETRDRS");
d236 1
a236 1
			print_error("DIOCGETRDR");
d264 1
a264 1
		print_error("DIOCGETSTATUS");
d283 1
a283 1
		print_error("DIOCBEGINRULES");
d296 1
a296 1
					print_error("DIOCADDRULE");
d305 1
a305 1
		print_error("DIOCCOMMITRULES");
d322 1
a322 1
		print_error("DIOCBEGINNATS");
d337 1
a337 1
					print_error("DIOCADDNAT");
d346 1
a346 1
		print_error("DIOCCOMMITNATS");
d352 1
a352 1
		print_error("DIOCBEGINRDRS");
d367 1
a367 1
					print_error("DIOCADDRDR");
d376 1
a376 1
		print_error("DIOCCOMMITRDRS");
d390 1
a390 1
		print_error("DIOCSETSTATUSIF");
d439 2
a440 2
	if (dev < 0) {
		print_error("open(/dev/pf)");
@


1.11
log
@Fix up usage() and alphabetize options.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.10 2001/06/25 17:59:19 smart Exp $ */
d413 3
@


1.10
log
@Separate getopt handling from execution of functions.  Still need
to do stricter checking to make sure invalid option combinations
don't get through.  deraadt@@, dhartmei@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.9 2001/06/25 17:17:06 dhartmei Exp $ */
d85 2
a86 2
	fprintf(stderr, "usage: %s [-d] [-c set] [-r file]", __progname);
	fprintf(stderr, " [-n file] [-s set] [-l if] [-e]\n");
d126 1
a126 1
		return 1;
d129 1
a129 1
	return 0;
d137 1
a137 1
		return 1;
d140 1
a140 1
	return 0;
d414 1
a414 1
	while (!error && (ch = getopt(argc, argv, "dc:r:n:s:l:e")) != -1) {
d416 3
d422 2
a423 2
		case 'c':
			clearopt = optarg;
d425 2
a426 2
		case 'r':
			rulesopt = optarg;
d431 3
a436 6
		case 'l':
			logopt = optarg;
			break;
		case 'e':
			eflag++;
			break;
d439 1
@


1.9
log
@revised ioctl interface, first getopt version of pfctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.8 2001/06/25 10:14:07 deraadt Exp $ */
d50 1
a50 1
void	 usage();
d64 8
a71 1
int	 main(int, char *[]);
d87 1
a413 9
	if (argc <= 1) {
		usage();
		return (0);
	}
	dev = open("/dev/pf", O_RDWR);
	if (dev < 0) {
		print_error("open(/dev/pf)");
		return (1);
	}
d417 1
a417 2
			if (pfctl_disable(dev))
				error = 1;
d420 1
a420 11
			if (!strcmp(optarg, "rules")) {
				if (pfctl_clear_rules(dev))
					error = 1;
			} else if (!strcmp(optarg, "nat")) {
				if (pfctl_clear_nat(dev))
					error = 1;
			} else if (!strcmp(optarg, "states")) {
				if (pfctl_clear_states(dev))
					error = 1;
			} else
				error = 1;
d423 1
a423 2
			if (pfctl_rules(dev, optarg))
				error = 1;
d426 1
a426 2
			if (pfctl_nat(dev, optarg))
				error = 1;
d429 1
a429 14
			if (!strcmp(optarg, "rules")) {
				if (pfctl_show_rules(dev))
					error = 1;
			} else if (!strcmp(optarg, "nat")) {
				if (pfctl_show_nat(dev))
					error = 1;
			} else if (!strcmp(optarg, "states")) {
				if (pfctl_show_states(dev, 0))
					error = 1;
			} else if (!strcmp(optarg, "status")) {
				if (pfctl_show_status(dev))
					error = 1;
			} else
				error = 1;
d432 1
a432 2
			if (pfctl_log(dev, optarg))
				error = 1;
d435 1
a435 2
			if (pfctl_enable(dev))
				error = 1;
d439 49
a488 1
		}
d490 9
@


1.8
log
@catch up, might have introduced bugs, but there is a next pass...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.7 2001/06/25 09:44:32 deraadt Exp $ */
d49 2
a50 2
void	 printerror(char *);
void	 usage(char *);
d52 12
d67 1
a67 1
printerror(char *s)
d74 1
a74 1
usage(char *argv0)
d76 4
a79 21
	char *n = rindex(argv0, '/');

	if (n != NULL)
		n++;
	else
		n = argv0;
	fprintf(stderr, "Usage: %s command argument\n", n);
	fprintf(stderr, "\tstart\t\t\tStart packet filter\n");
	fprintf(stderr, "\tstop\t\t\tStop packet filter\n");
	fprintf(stderr, "\tshow\trules\t\tShow filter rules\n");
	fprintf(stderr, "\t\tnat\t\t     NAT/RDR rules\n");
	fprintf(stderr, "\t\tstates [proto]\t     list of active states\n");
	fprintf(stderr, "\t\tstatus\t\t     status\n");
	fprintf(stderr, "\tclear\trules\t\tClear filter rules\n");
	fprintf(stderr, "\t\tnat\t\t      NAT/RDR rules\n");
	fprintf(stderr, "\t\tstates\t\t      states\n");
	fprintf(stderr, "\tparse\trules\t<file>\tCheck syntax of filter rules\n");
	fprintf(stderr, "\t\tnat\t<file>\t                NAT/RDR rules\n");
	fprintf(stderr, "\tload\trules\t<file>\tLoad filter rules\n");
	fprintf(stderr, "\t\tnat\t<file>\t     NAT/RDR rules\n");
	fprintf(stderr, "\tlog\t\t<if>\tSet interface to log\n");
d114 23
a136 1
main(int argc, char *argv[])
d138 1
a138 3
	int dev;
	struct pfioc *ub;
	u_int16_t n = 0;
d140 5
a144 3
	ub = malloc(sizeof(struct pfioc));
	if (ub == NULL) {
		printf("ERROR: malloc() failed\n");
d147 21
a167 4
	ub->size = 131072;
	ub->buffer = malloc(ub->size);
	if (ub->buffer == NULL) {
		printf("ERROR: malloc() failed\n");
d170 9
a178 4
	memset(ub->buffer, 0, ub->size);
	ub->entries = 0;
	if (argc < 2) {
		usage(argv[0]);
d181 12
a192 3
	dev = open("/dev/pf", O_RDWR);
	if (dev < 0) {
		printerror("open(/dev/pf)");
d195 5
a199 16
	if (!strcmp(argv[1], "start")) {
		if (ioctl(dev, DIOCSTART))
			printerror("DIOCSTART");
		else
			printf("packetfilter started\n");
	}
	else if (!strcmp(argv[1], "stop")) {
		if (ioctl(dev, DIOCSTOP))
			printerror("DIOCSTOP");
		else
			printf("packetfilter stopped\n");
	}
	else if (!strcmp(argv[1], "show")) {
		if (argc < 3) {
			close(dev);
			usage(argv[0]);
d202 5
a206 2
		if (!strcmp(argv[2], "rules")) {
			struct pf_rule *rule = ub->buffer;
d208 6
a213 49
			ub->entries = ub->size / sizeof(struct pf_rule);
			if (ioctl(dev, DIOCGETRULES, ub))
				printerror("DIOCGETRULES");
			for (n = 0; n < ub->entries; ++n) {
				printf("@@%u ", n + 1);
				print_rule(rule + n);
			}
		}
		else if (!strcmp(argv[2], "nat")) {
			struct pf_nat *nat = ub->buffer;
			struct pf_rdr *rdr = ub->buffer;

			ub->entries = ub->size / sizeof(struct pf_nat);
			if (ioctl(dev, DIOCGETNAT, ub))
				printerror("DIOCGETNAT");
			for (n = 0; n < ub->entries; ++n)
				print_nat(nat + n);
			ub->entries = ub->size / sizeof(struct pf_rdr);
			if (ioctl(dev, DIOCGETRDR, ub))
				printerror("DIOCGETRDR");
			for (n = 0; n < ub->entries; ++n)
				print_rdr(rdr + n);
		}
		else if (!strcmp(argv[2], "states")) {
			u_int8_t proto = 0;
			struct pf_state *state = ub->buffer;

			if (argc >= 4) {
				if (!strcmp(argv[3], "tcp"))
					proto = IPPROTO_TCP;
				else if (!strcmp(argv[3], "udp"))
					proto = IPPROTO_UDP;
				else if (!strcmp(argv[3], "icmp"))
					proto = IPPROTO_ICMP;
				else {
					close(dev);
					usage(argv[0]);
					return (1);
				}
			}
			ub->entries = ub->size / sizeof(struct pf_state);
			if (ioctl(dev, DIOCGETSTATES, ub))
				printerror("DIOCGETSTATES");
			for (n = ub->entries; n > 0; --n)
				if (!proto || (state[n - 1].proto == proto))
					print_state(state + n - 1);
		}
		else if (!strcmp(argv[2], "status")) {
			struct pf_status *status = ub->buffer;
d215 9
a223 8
			ub->entries = 1;
			if (ioctl(dev, DIOCGETSTATUS, ub))
				printerror("DIOCGETSTATUS");
			print_status(status);
		}
		else {
			close(dev);
			usage(argv[0]);
d226 5
d232 5
a236 28
	else if (!strcmp(argv[1], "clear")) {
		if (argc < 3) {
			close(dev);
			usage(argv[0]);
			return (1);
		}
		ub->entries = 0;
		if (!strcmp(argv[2], "rules")) {
			if (ioctl(dev, DIOCSETRULES, ub))
				printerror("DIOCSETRULES");
			else printf("rules cleared\n");
		}
		else if (!strcmp(argv[2], "nat")) {
			if (ioctl(dev, DIOCSETNAT, ub))
				printerror("DIOCSETNAT");
			else if (ioctl(dev, DIOCSETRDR, ub))
				printerror("DIOCSETRDR");
			else printf("nat cleared\n");
		}
		else if (!strcmp(argv[2], "states")) {
			if (ioctl(dev, DIOCCLRSTATES))
				printerror("DIOCCLRSTATES");
			else
				printf("states cleared\n");
		}
		else {
			close(dev);
			usage(argv[0]);
d239 15
d255 7
a261 26
	else if (!strcmp(argv[1], "log")) {
		if (argc < 3) {
			close(dev);
			usage(argv[0]);
			return (1);
		}
		strncpy(ub->buffer, argv[2], 16);
		if (ioctl(dev, DIOCSETSTATUSIF, ub))
			printerror("DIOCSETSTATUSIF");
		else
			printf("now logging %s\n", argv[2]);
	}
	else if (!strcmp(argv[1], "parse") || !strcmp(argv[1], "load")) {
		int load = !strcmp(argv[1], "load");
		char *buf, *s;
		size_t len;
		unsigned nr = 0;
		if ((argc < 4) || (strcmp(argv[2], "nat") &&
		    strcmp(argv[2], "rules"))) {
			close(dev);
			usage(argv[0]);
			return (1);
		}
		buf = load_file(argv[3], &len);
		if (buf == NULL)
			return (1);
d263 7
a269 2
		if (!strcmp(argv[2], "rules")) {
			struct pf_rule *rule = ub->buffer;
d271 7
a277 69
			n = 0;
			nr = 0;
			s = buf;
			do {
				char *line = next_line(&s);
				nr++;
				if (*line && (*line != '#'))
					if (parse_rule(nr, line, rule + n))
						n++;
			} while (s < (buf + len));
			ub->entries = n;
			if (load) {
				if (ioctl(dev, DIOCSETRULES, ub))
					printerror("DIOCSETRULES");
				else
					printf("%u rules loaded\n",
					    ub->entries);
			} else
				for (n = 0; n < ub->entries; ++n)
					print_rule(rule + n);
		} else {
			struct pf_nat *nat = ub->buffer;
			struct pf_rdr *rdr = ub->buffer;

			n = 0;
			nr = 0;
			s = buf;
			do {
				char *line = next_line(&s);
				nr++;
				if (*line && (*line == 'n'))
					if (parse_nat(nr, line, nat + n))
						n++;
			} while (s < (buf + len));
			ub->entries = n;
			if (load) {
				if (ioctl(dev, DIOCSETNAT, ub))
					printerror("DIOCSETNAT");
				else
					printf("%u nat entries loaded\n",
					    ub->entries);
			} else
				for (n = 0; n < ub->entries; ++n)
					print_nat(nat + n);
			free(buf);
			buf = load_file(argv[3], &len);
			if (buf == NULL)
				return (1);
			n = 0;
			nr = 0;
			s = buf;
			do {
				char *line = next_line(&s);
				nr++;
				if (*line && (*line == 'r'))
					if (parse_rdr(nr, line, rdr + n))
						n++;
			} while (s < (buf + len));
			ub->entries = n;
			if (load) {
				if (ioctl(dev, DIOCSETRDR, ub))
					printerror("DIOCSETRDR");
				else
					printf("%u rdr entries loaded\n",
					    ub->entries);
			} else
				for (n = 0; n < ub->entries; ++n)
					print_rdr(rdr + n);
		}
d279 5
d285 1
d287 60
a346 3
	else {
		close(dev);
		usage(argv[0]);
d349 45
a393 3
	close(dev);
	free(ub->buffer);
	free(ub);
d397 77
@


1.7
log
@catch up to Art changes in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.6 2001/06/25 00:02:55 dhartmei Exp $ */
d52 1
a52 1
int		 main(int, char *[]);
@


1.6
log
@use only ioctl return values found in errno.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.5 2001/06/24 23:44:07 art Exp $ */
d49 3
a51 3
static void	 printerror(char *);
static void	 usage(char *);
static char	*load_file(char *, size_t *);
d54 1
a54 1
static void
d61 1
a61 1
static void
d65 1
d87 1
a87 1
static char *
d92 1
d124 1
d166 3
a168 2
			struct rule *rule = ub->buffer;
			ub->entries = ub->size / sizeof(struct rule);
d177 4
a180 3
			struct nat *nat = ub->buffer;
			struct rdr *rdr = ub->buffer;
			ub->entries = ub->size / sizeof(struct nat);
d185 1
a185 1
			ub->entries = ub->size / sizeof(struct rdr);
d193 2
a194 1
			struct state *state = ub->buffer;
d208 1
a208 1
			ub->entries = ub->size / sizeof(struct state);
d216 2
a217 1
			struct status *status = ub->buffer;
d288 2
a289 1
			struct rule *rule = ub->buffer;
d311 3
a313 2
			struct nat *nat = ub->buffer;
			struct rdr *rdr = ub->buffer;
@


1.5
log
@ioctlbuffer renamed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.4 2001/06/24 23:20:57 provos Exp $ */
a53 8
static char *errormsg[] = {
	"invalid operation",		/* ERROR_INVALID_OP */
	"packetfilter is running",	/* ERROR_ALREADY_RUNNING */
	"packetfilter not running",	/* ERROR_NOT_RUNNING */
	"invalid parameters",		/* ERROR_INVALID_PARAMETERS */
	"memory allocation failed"	/* ERROR_MALLOC */
};

d57 1
a57 6
	char *msg;
	if ((errno >= 100) && (errno < MAX_ERROR_NUM))
		msg = errormsg[errno-100];
	else
		msg = strerror(errno);
	fprintf(stderr, "ERROR: %s: %s\n", s, msg);
@


1.4
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.3 2001/06/24 23:16:35 deraadt Exp $ */
d133 1
a133 1
	struct ioctlbuffer *ub;
d135 1
a135 1
	ub = malloc(sizeof(struct ioctlbuffer));
@


1.3
log
@match changes in header files
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.2 2001/06/24 21:40:51 dhartmei Exp $ */
d108 1
a108 1
		return 0;
d117 1
a117 1
		return 0;
d123 1
a123 1
		return 0;
d126 1
a126 1
	return buf;
d138 1
a138 1
		return 1;
d144 1
a144 1
		return 1;
d150 1
a150 1
		return 1;
d155 1
a155 1
		return 1;
d173 1
a173 1
			return 1;
d212 1
a212 1
					return 1;
d232 1
a232 1
			return 1;
d239 1
a239 1
			return 1;
d263 1
a263 1
			return 1;
d270 1
a270 1
			return 1;
d287 1
a287 1
			return 1;
d291 1
a291 1
			return 1;
d341 1
a341 1
				return 1;
d369 1
a369 1
		return 1;
d374 1
a374 1
	return 0;
@


1.2
log
@REGENTS -> COPYRIGHT HOLDERS
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.1 2001/06/24 21:04:15 kjell Exp $ */
d33 7
a42 1
#include <sys/ioctl.h>
a45 1
#include <netinet/in.h>
@


1.1
log
@Move and rename packet filter userland.
grr. CVS: making easy things difficult, and directory operations impossible.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfm.c,v 1.1 2001/06/24 20:18:12 kjell Exp $ */
d22 1
a22 1
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
@

