head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.2
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.33.0.8
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.10
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.14
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.12
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.8
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.10
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.34
date	2017.08.11.22.30.38;	author benno;	state Exp;
branches;
next	1.33;
commitid	y1VyeV9JnotblbHq;

1.33
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	82PdNqu2kKAuXPfA;

1.32
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	3o2AkhiRPQXvG94X;

1.31
date	2014.05.07.14.59.11;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.05.12.01.47;	author chl;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.21.21.03.58;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.14.20.44.22;	author cedric;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.09.12.42.06;	author cedric;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.10.18.29.30;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.24.09.12.35;	author cedric;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.31.22.25.54;	author cedric;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.04.11.05.44;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.03.09.13.06;	author cedric;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.30.20.02.46;	author cedric;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.28.12.26.22;	author cedric;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.27.15.35.00;	author cedric;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.08.09.41.07;	author cedric;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.27.16.02.08;	author cedric;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.03.08.42.15;	author cedric;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.25.23.17.34;	author cedric;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.20.20.47.10;	author cedric;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.07.00.21.08;	author dhartmei;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.03.22.47.51;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.03.22.31.15;	author cedric;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.03.21.55.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.03.21.43.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.03.21.37.44;	author cedric;	state Exp;
branches;
next	;


desc
@@


1.34
log
@add option -N (no domain resolution)
manpage wording and reminder about usage() jmc@@
ok florian@@ henning@@
@
text
@/*	$OpenBSD: pfctl_radix.c,v 1.33 2015/12/10 17:27:00 mmcc Exp $ */

/*
 * Copyright (c) 2002 Cedric Berger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <err.h>

#include "pfctl.h"
#include "pfctl_parser.h"

#define BUF_SIZE 256

extern int dev;

static int	 pfr_next_token(char buf[], FILE *);


int
pfr_clr_tables(struct pfr_table *filter, int *ndel, int flags)
{
	struct pfioc_table io;

	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	if (filter != NULL)
		io.pfrio_table = *filter;
	if (ioctl(dev, DIOCRCLRTABLES, &io))
		return (-1);
	if (ndel != NULL)
		*ndel = io.pfrio_ndel;
	return (0);
}

int
pfr_add_tables(struct pfr_table *tbl, int size, int *nadd, int flags)
{
	struct pfioc_table io;

	if (size < 0 || (size && tbl == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_buffer = tbl;
	io.pfrio_esize = sizeof(*tbl);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRADDTABLES, &io))
		return (-1);
	if (nadd != NULL)
		*nadd = io.pfrio_nadd;
	return (0);
}

int
pfr_del_tables(struct pfr_table *tbl, int size, int *ndel, int flags)
{
	struct pfioc_table io;

	if (size < 0 || (size && tbl == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_buffer = tbl;
	io.pfrio_esize = sizeof(*tbl);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRDELTABLES, &io))
		return (-1);
	if (ndel != NULL)
		*ndel = io.pfrio_ndel;
	return (0);
}

int
pfr_get_tables(struct pfr_table *filter, struct pfr_table *tbl, int *size,
	int flags)
{
	struct pfioc_table io;

	if (size == NULL || *size < 0 || (*size && tbl == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	if (filter != NULL)
		io.pfrio_table = *filter;
	io.pfrio_buffer = tbl;
	io.pfrio_esize = sizeof(*tbl);
	io.pfrio_size = *size;
	if (ioctl(dev, DIOCRGETTABLES, &io))
		return (-1);
	*size = io.pfrio_size;
	return (0);
}

int
pfr_get_tstats(struct pfr_table *filter, struct pfr_tstats *tbl, int *size,
	int flags)
{
	struct pfioc_table io;

	if (size == NULL || *size < 0 || (*size && tbl == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	if (filter != NULL)
		io.pfrio_table = *filter;
	io.pfrio_buffer = tbl;
	io.pfrio_esize = sizeof(*tbl);
	io.pfrio_size = *size;
	if (ioctl(dev, DIOCRGETTSTATS, &io))
		return (-1);
	*size = io.pfrio_size;
	return (0);
}

int
pfr_clr_addrs(struct pfr_table *tbl, int *ndel, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	if (ioctl(dev, DIOCRCLRADDRS, &io))
		return (-1);
	if (ndel != NULL)
		*ndel = io.pfrio_ndel;
	return (0);
}

int
pfr_add_addrs(struct pfr_table *tbl, struct pfr_addr *addr, int size,
    int *nadd, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size < 0 || (size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRADDADDRS, &io))
		return (-1);
	if (nadd != NULL)
		*nadd = io.pfrio_nadd;
	return (0);
}

int
pfr_del_addrs(struct pfr_table *tbl, struct pfr_addr *addr, int size,
    int *ndel, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size < 0 || (size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRDELADDRS, &io))
		return (-1);
	if (ndel != NULL)
		*ndel = io.pfrio_ndel;
	return (0);
}

int
pfr_set_addrs(struct pfr_table *tbl, struct pfr_addr *addr, int size,
    int *size2, int *nadd, int *ndel, int *nchange, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size < 0 || (size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = size;
	io.pfrio_size2 = (size2 != NULL) ? *size2 : 0;
	if (ioctl(dev, DIOCRSETADDRS, &io))
		return (-1);
	if (nadd != NULL)
		*nadd = io.pfrio_nadd;
	if (ndel != NULL)
		*ndel = io.pfrio_ndel;
	if (nchange != NULL)
		*nchange = io.pfrio_nchange;
	if (size2 != NULL)
		*size2 = io.pfrio_size2;
	return (0);
}

int
pfr_get_addrs(struct pfr_table *tbl, struct pfr_addr *addr, int *size,
    int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size == NULL || *size < 0 ||
	    (*size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = *size;
	if (ioctl(dev, DIOCRGETADDRS, &io))
		return (-1);
	*size = io.pfrio_size;
	return (0);
}

int
pfr_get_astats(struct pfr_table *tbl, struct pfr_astats *addr, int *size,
    int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size == NULL || *size < 0 ||
	    (*size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = *size;
	if (ioctl(dev, DIOCRGETASTATS, &io))
		return (-1);
	*size = io.pfrio_size;
	return (0);
}

int
pfr_clr_tstats(struct pfr_table *tbl, int size, int *nzero, int flags)
{
	struct pfioc_table io;

	if (size < 0 || (size && !tbl)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_buffer = tbl;
	io.pfrio_esize = sizeof(*tbl);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRCLRTSTATS, &io))
		return (-1);
	if (nzero)
		*nzero = io.pfrio_nzero;
	return (0);
}

int
pfr_tst_addrs(struct pfr_table *tbl, struct pfr_addr *addr, int size,
    int *nmatch, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size < 0 || (size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRTSTADDRS, &io))
		return (-1);
	if (nmatch)
		*nmatch = io.pfrio_nmatch;
	return (0);
}

int
pfr_ina_define(struct pfr_table *tbl, struct pfr_addr *addr, int size,
    int *nadd, int *naddr, int ticket, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size < 0 || (size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = size;
	io.pfrio_ticket = ticket;
	if (ioctl(dev, DIOCRINADEFINE, &io))
		return (-1);
	if (nadd != NULL)
		*nadd = io.pfrio_nadd;
	if (naddr != NULL)
		*naddr = io.pfrio_naddr;
	return (0);
}

/* interface management code */

int
pfi_get_ifaces(const char *filter, struct pfi_kif *buf, int *size)
{
	struct pfioc_iface io;

	if (size == NULL || *size < 0 || (*size && buf == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	if (filter != NULL)
		if (strlcpy(io.pfiio_name, filter, sizeof(io.pfiio_name)) >=
		    sizeof(io.pfiio_name)) {
			errno = EINVAL;
			return (-1);
		}
	io.pfiio_buffer = buf;
	io.pfiio_esize = sizeof(*buf);
	io.pfiio_size = *size;
	if (ioctl(dev, DIOCIGETIFACES, &io))
		return (-1);
	*size = io.pfiio_size;
	return (0);
}

/* buffer management code */

size_t buf_esize[PFRB_MAX] = { 0,
	sizeof(struct pfr_table), sizeof(struct pfr_tstats),
	sizeof(struct pfr_addr), sizeof(struct pfr_astats),
	sizeof(struct pfi_kif), sizeof(struct pfioc_trans_e)
};

/*
 * add one element to the buffer
 */
int
pfr_buf_add(struct pfr_buffer *b, const void *e)
{
	size_t bs;

	if (b == NULL || b->pfrb_type <= 0 || b->pfrb_type >= PFRB_MAX ||
	    e == NULL) {
		errno = EINVAL;
		return (-1);
	}
	bs = buf_esize[b->pfrb_type];
	if (b->pfrb_size == b->pfrb_msize)
		if (pfr_buf_grow(b, 0))
			return (-1);
	memcpy(((caddr_t)b->pfrb_caddr) + bs * b->pfrb_size, e, bs);
	b->pfrb_size++;
	return (0);
}

/*
 * return next element of the buffer (or first one if prev is NULL)
 * see PFRB_FOREACH macro
 */
void *
pfr_buf_next(struct pfr_buffer *b, const void *prev)
{
	size_t bs;

	if (b == NULL || b->pfrb_type <= 0 || b->pfrb_type >= PFRB_MAX)
		return (NULL);
	if (b->pfrb_size == 0)
		return (NULL);
	if (prev == NULL)
		return (b->pfrb_caddr);
	bs = buf_esize[b->pfrb_type];
	if ((((caddr_t)prev)-((caddr_t)b->pfrb_caddr)) / bs >= b->pfrb_size-1)
		return (NULL);
	return (((caddr_t)prev) + bs);
}

/*
 * minsize:
 *    0: make the buffer somewhat bigger
 *    n: make room for "n" entries in the buffer
 */
int
pfr_buf_grow(struct pfr_buffer *b, int minsize)
{
	caddr_t p;
	size_t bs;

	if (b == NULL || b->pfrb_type <= 0 || b->pfrb_type >= PFRB_MAX) {
		errno = EINVAL;
		return (-1);
	}
	if (minsize != 0 && minsize <= b->pfrb_msize)
		return (0);
	bs = buf_esize[b->pfrb_type];
	if (!b->pfrb_msize) {
		if (minsize < 64)
			minsize = 64;
	}
	if (minsize == 0)
		minsize = b->pfrb_msize * 2;
	p = reallocarray(b->pfrb_caddr, minsize, bs);
	if (p == NULL)
		return (-1);
	bzero(p + b->pfrb_msize * bs, (minsize - b->pfrb_msize) * bs);
	b->pfrb_caddr = p;
	b->pfrb_msize = minsize;
	return (0);
}

/*
 * reset buffer and free memory.
 */
void
pfr_buf_clear(struct pfr_buffer *b)
{
	if (b == NULL)
		return;
	free(b->pfrb_caddr);
	b->pfrb_caddr = NULL;
	b->pfrb_size = b->pfrb_msize = 0;
}

int
pfr_buf_load(struct pfr_buffer *b, char *file, int nonetwork, int opts)
{
	FILE	*fp;
	char	 buf[BUF_SIZE];
	int	 rv;
	int	 ev = 0;

	if (file == NULL)
		return (0);
	if (!strcmp(file, "-"))
		fp = stdin;
	else {
		fp = pfctl_fopen(file, "r");
		if (fp == NULL)
			return (-1);
	}
	while ((rv = pfr_next_token(buf, fp)) == 1)
		if ((ev = append_addr(b, buf, nonetwork, opts)) == -1) {
			rv = -1;
			break;
		}
	if (ev == 1) /* expected further append_addr call */
		rv = -1;
	if (fp != stdin)
		fclose(fp);
	return (rv);
}

int
pfr_next_token(char buf[BUF_SIZE], FILE *fp)
{
	static char	next_ch = ' ';
	int		i = 0;

	for (;;) {
		/* skip spaces */
		while (isspace((unsigned char)next_ch) && !feof(fp))
			next_ch = fgetc(fp);
		/* remove from '#' until end of line */
		if (next_ch == '#')
			while (!feof(fp)) {
				next_ch = fgetc(fp);
				if (next_ch == '\n')
					break;
			}
		else
			break;
	}
	if (feof(fp)) {
		next_ch = ' ';
		return (0);
	}
	do {
		if (i < BUF_SIZE)
			buf[i++] = next_ch;
		next_ch = fgetc(fp);
	} while (!feof(fp) && !isspace((unsigned char)next_ch));
	if (i >= BUF_SIZE) {
		errno = EINVAL;
		return (-1);
	}
	buf[i] = '\0';
	return (1);
}

char *
pfr_strerror(int errnum)
{
	switch (errnum) {
	case ESRCH:
		return "Table does not exist";
	case ENOENT:
		return "Anchor or Ruleset does not exist";
	default:
		return strerror(errnum);
	}
}
@


1.33
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.32 2015/01/21 21:50:33 deraadt Exp $ */
d499 1
a499 1
pfr_buf_load(struct pfr_buffer *b, char *file, int nonetwork)
d516 1
a516 1
		if ((ev = append_addr(b, buf, nonetwork)) == -1) {
@


1.32
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.31 2014/05/07 14:59:11 tedu Exp $ */
d493 1
a493 2
	if (b->pfrb_caddr != NULL)
		free(b->pfrb_caddr);
@


1.31
log
@consolidate some code by using reallocarray in all cases.
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.30 2013/11/22 04:12:48 deraadt Exp $ */
d37 1
@


1.30
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.29 2011/07/27 00:26:10 mcbride Exp $ */
a471 18
		b->pfrb_caddr = calloc(bs, minsize);
		if (b->pfrb_caddr == NULL)
			return (-1);
		b->pfrb_msize = minsize;
	} else {
		if (minsize == 0)
			minsize = b->pfrb_msize * 2;
		if (minsize < 0 || minsize >= SIZE_T_MAX / bs) {
			/* msize overflow */
			errno = ENOMEM;
			return (-1);
		}
		p = realloc(b->pfrb_caddr, minsize * bs);
		if (p == NULL)
			return (-1);
		bzero(p + b->pfrb_msize * bs, (minsize - b->pfrb_msize) * bs);
		b->pfrb_caddr = p;
		b->pfrb_msize = minsize;
d473 8
@


1.29
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.28 2007/12/05 12:01:47 chl Exp $ */
d545 1
a545 1
		while (isspace(next_ch) && !feof(fp))
d565 1
a565 1
	} while (!feof(fp) && !isspace(next_ch));
@


1.28
log
@remove unused functions

from tobias@@

ok mcbride@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.27 2005/05/21 21:03:58 henning Exp $ */
d49 1
d509 1
a509 2
pfr_buf_load(struct pfr_buffer *b, char *file, int nonetwork,
    int (*append_addr)(struct pfr_buffer *, char *, int))
d514 1
d526 1
a526 1
		if (append_addr(b, buf, nonetwork)) {
d530 2
@


1.27
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.26 2004/06/14 20:44:22 cedric Exp $ */
a302 23
pfr_clr_astats(struct pfr_table *tbl, struct pfr_addr *addr, int size,
    int *nzero, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL || size < 0 || (size && addr == NULL)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = addr;
	io.pfrio_esize = sizeof(*addr);
	io.pfrio_size = size;
	if (ioctl(dev, DIOCRCLRASTATS, &io))
		return (-1);
	if (nzero != NULL)
		*nzero = io.pfrio_nzero;
	return (0);
}

int
a319 26
	return (0);
}

int
pfr_set_tflags(struct pfr_table *tbl, int size, int setflag, int clrflag,
    int *nchange, int *ndel, int flags)
{
	struct pfioc_table io;

	if (size < 0 || (size && !tbl)) {
		errno = EINVAL;
		return (-1);
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_buffer = tbl;
	io.pfrio_esize = sizeof(*tbl);
	io.pfrio_size = size;
	io.pfrio_setflag = setflag;
	io.pfrio_clrflag = clrflag;
	if (ioctl(dev, DIOCRSETTFLAGS, &io))
		return (-1);
	if (nchange)
		*nchange = io.pfrio_nchange;
	if (ndel)
		*ndel = io.pfrio_ndel;
@


1.26
log
@Remove unused functions. ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.25 2004/04/09 12:42:06 cedric Exp $ */
d424 1
a424 1
pfi_get_ifaces(const char *filter, struct pfi_if *buf, int *size, int flags)
a432 1
	io.pfiio_flags = flags;
d453 1
a453 1
	sizeof(struct pfi_if), sizeof(struct pfioc_trans_e)
@


1.25
log
@Do not try to load directories. found+ok mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.24 2004/02/10 18:29:30 henning Exp $ */
a391 38
	return (0);
}

int
pfr_ina_begin(struct pfr_table *trs, int *ticket, int *ndel, int flags)
{
	struct pfioc_table io;

	bzero(&io, sizeof io);
	if (trs != NULL)
		io.pfrio_table = *trs;
	io.pfrio_flags = flags;
	if (ioctl(dev, DIOCRINABEGIN, &io))
		return (-1);
	if (ndel != NULL)
		*ndel = io.pfrio_ndel;
	if (ticket != NULL)
		*ticket = io.pfrio_ticket;
	return (0);
}

int
pfr_ina_commit(struct pfr_table *trs, int ticket, int *nadd, int *nchange,
    int flags)
{
	struct pfioc_table io;

	bzero(&io, sizeof io);
	if (trs != NULL)
		io.pfrio_table = *trs;
	io.pfrio_flags = flags;
	io.pfrio_ticket = ticket;
	if (ioctl(dev, DIOCRINACOMMIT, &io))
		return (-1);
	if (nadd != NULL)
		*nadd = io.pfrio_nadd;
	if (nchange != NULL)
		*nchange = io.pfrio_nchange;
@


1.24
log
@lotsoflotsoflotsof KNF
and an off by one
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.23 2003/12/31 11:18:24 cedric Exp $ */
d608 1
a608 1
		fp = fopen(file, "r");
@


1.23
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.22 2003/09/26 21:44:09 cedric Exp $ */
d262 2
a263 1
	if (tbl == NULL || size == NULL || *size < 0 || (*size && addr == NULL)) {
d285 2
a286 1
	if (tbl == NULL || size == NULL || *size < 0 || (*size && addr == NULL)) {
d473 2
a474 2
		if (strlcpy(io.pfiio_name, filter, sizeof(io.pfiio_name))
		     > sizeof(io.pfiio_name)) {
@


1.22
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.21 2003/09/24 09:12:35 cedric Exp $ */
d457 28
d490 1
a490 1
	sizeof(struct pfioc_trans_e)
@


1.21
log
@Fix realloc usage and make sure we don't increase buffer size on failure.
ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.20 2003/08/22 21:50:34 david Exp $ */
d462 1
@


1.20
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.19 2003/07/31 22:25:54 cedric Exp $ */
d515 1
d526 3
a528 4
		b->pfrb_msize = minsize;
		if (b->pfrb_msize < 64)
			b->pfrb_msize = 64;
		b->pfrb_caddr = calloc(bs, b->pfrb_msize);
d531 1
a532 2
		int omsize = b->pfrb_msize;

d534 2
a535 4
			b->pfrb_msize *= 2;
		else
			b->pfrb_msize = minsize;
		if (b->pfrb_msize < 0 || b->pfrb_msize >= SIZE_T_MAX / bs) {
d540 2
a541 2
		b->pfrb_caddr = realloc(b->pfrb_caddr, b->pfrb_msize * bs);
		if (b->pfrb_caddr == NULL)
d543 3
a545 2
		bzero(((caddr_t)b->pfrb_caddr) + omsize * bs,
		    (b->pfrb_msize-omsize) * bs);
@


1.19
log
@Make table tickets per-ruleset instead of global.
Make table tickets u_int32_t for consistency with other parts of PF.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.18 2003/07/04 11:05:44 henning Exp $ */
d457 1
a457 1
/* buffer managment code */
@


1.18
log
@KNF after cedric (grmpf)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.17 2003/07/03 09:13:06 cedric Exp $ */
d394 1
a394 1
pfr_ina_begin(int *ticket, int *ndel, int flags)
d399 2
d412 2
a413 1
pfr_ina_commit(int ticket, int *nadd, int *nchange, int flags)
d418 2
@


1.17
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.16 2003/06/30 20:02:46 cedric Exp $ */
d454 1
a454 1
size_t buf_esize[PFRB_MAX] = { 0, 
d498 1
a498 1
		return (NULL); 
d551 1
a551 1
pfr_buf_clear(struct pfr_buffer *b) 
@


1.16
log
@Buffer management functions.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.15 2003/06/28 12:26:22 cedric Exp $ */
d476 1
a476 1
	memcpy(b->pfrb_caddr + bs * b->pfrb_size, e, bs);
d497 1
a497 1
	if ((((caddr_t)prev) - b->pfrb_caddr) / bs >= b->pfrb_size - 1)
d541 2
a542 1
		bzero(b->pfrb_caddr + omsize * bs, (b->pfrb_msize-omsize) * bs);
d561 3
a563 2
void
pfr_buf_load(char *file, int nonetwork, void (*append_addr)(char *, int))
d567 1
d570 1
a570 1
		return;
d576 1
a576 1
			err(1, "%s", file);
d578 5
a582 2
	while (pfr_next_token(buf, fp))
		append_addr(buf, nonetwork);
d585 1
d617 4
a620 2
	if (i >= BUF_SIZE)
		errx(1, "address too long (%d bytes)", i);
@


1.15
log
@No need to include the same header twice.
Thanks to Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.14 2003/06/27 15:35:00 cedric Exp $ */
d44 2
d450 108
@


1.14
log
@Reorg part I: move 3 functions out of pf_table.c to pf_radix.c
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.13 2003/06/08 09:41:07 cedric Exp $ */
a42 1
#include <stdio.h>
@


1.13
log
@A table in an anchor creates a real anchor: pfctl -sA works.
The following two pfctl functions work with an "-a" option:
  - pfctl [-a foo[:bar]] -sT
  - pfctl [-a foo[:bar]] -FT
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.12 2003/04/27 16:02:08 cedric Exp $ */
d42 4
d49 2
d53 3
d449 69
@


1.12
log
@Update the pfioc_table IOCTL structure.
Prepare for anchors, improve robustness.
WARNING: need to sync kernel/userland.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.11 2003/02/03 08:42:15 cedric Exp $ */
d48 1
a48 1
pfr_clr_tables(int *ndel, int flags)
d54 2
d106 2
a107 1
pfr_get_tables(struct pfr_table *tbl, int *size, int flags)
d117 2
d129 2
a130 1
pfr_get_tstats(struct pfr_tstats *tbl, int *size, int flags)
d140 2
@


1.11
log
@More cleanup in tables thanks to Andrey Matveev:
 - get rid of unnecessary header netinet/in.h in pfctl_radix.c and pfctl_table.c
 - do fclose(3) only when we use config file, not STDIN
 - get rid of unneeded temporatory variables
 - minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.10 2003/01/25 23:17:34 cedric Exp $ */
d73 1
d94 1
d115 1
d135 1
d176 1
d199 1
d222 1
d252 1
d274 1
d296 1
d317 1
d339 1
d366 1
d422 1
@


1.10
log
@Another nice cleanup patch from Andrey Matveev
KNF + remove/reorg headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.9 2003/01/20 20:47:10 cedric Exp $ */
a37 1
#include <netinet/in.h>
@


1.9
log
@Cut & paste madness. We were (un)lucky it worked before!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.8 2003/01/09 10:40:44 cedric Exp $ */
d41 1
a42 3
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
d69 1
a69 1
		return -1;
d89 1
a89 1
		return -1;
d109 1
a109 1
		return -1;
d128 1
a128 1
		return -1;
d147 1
a147 1
		return -1;
d167 1
a167 1
		return -1;
d189 1
a189 1
		return -1;
d211 1
a211 1
		return -1;
d234 1
a234 1
	int flags)
d240 1
a240 1
		return -1;
d255 1
a255 1
	int flags)
d261 1
a261 1
		return -1;
d282 1
a282 1
		return -1;
d303 1
a303 1
		return -1;
d318 1
a318 1
	int *nchange, int *ndel, int flags)
d324 1
a324 1
		return -1;
d343 1
a343 1
	int *nmatch, int flags)
d349 1
a349 1
		return -1;
d398 1
a398 1
	int *nadd, int *naddr, int ticket, int flags)
d404 1
a404 1
		return -1;
@


1.8
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.7 2003/01/07 00:21:08 dhartmei Exp $ */
d154 1
a154 1
	if (ioctl(dev, DIOCRSETADDRS, &io))
d291 1
a291 1
	if (ioctl(dev, DIOCRCLRTSTATS, &io))
d334 1
a334 1
	if (ioctl(dev, DIOCRCLRTSTATS, &io))
@


1.7
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.6 2003/01/04 00:01:34 deraadt Exp $ */
d318 24
d362 58
@


1.6
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.5 2003/01/03 22:47:51 deraadt Exp $ */
a337 43
	return (0);
}

int
pfr_wrap_table(struct pfr_table *tbl, struct pf_addr_wrap *wrap,
    int *exists, int flags)
{
	struct pfioc_table io;

	if (tbl == NULL) {
		errno = EINVAL;
		return -1;
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_table = *tbl;
	io.pfrio_buffer = wrap;
	io.pfrio_size = wrap ? 1 : 0;
	io.pfrio_exists = exists ? 1 : 0;
	if (ioctl(dev, DIOCRWRAPTABLE, &io))
		return (-1);
	if (exists)
		*exists = io.pfrio_exists;
	return (0);
}

int
pfr_unwrap_table(struct pfr_table *tbl, struct pf_addr_wrap *wrap, int flags)
{
	struct pfioc_table io;

	if (wrap == NULL) {
		errno = EINVAL;
		return -1;
	}
	bzero(&io, sizeof io);
	io.pfrio_flags = flags;
	io.pfrio_buffer = wrap;
	io.pfrio_size = 1;
	if (ioctl(dev, DIOCRUNWRTABLE, &io))
		return (-1);
	if (tbl != NULL)
		*tbl = io.pfrio_table;
@


1.5
log
@simplify ioctl access
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.4 2003/01/03 22:31:15 cedric Exp $ */
d46 1
a46 1
#include "pfctl_radix.h"
@


1.4
log
@Remove _ before static functions & variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.3 2003/01/03 21:55:51 deraadt Exp $ */
d48 1
a48 21
static int pfr_dev = -1;

static int
pfr_ioctl(unsigned long op, void *buf)
{
	if (pfr_dev < 0)
		return (pfr_dev);
	return (ioctl(pfr_dev, op, buf));
}

void
pfr_set_fd(int fd)
{
	pfr_dev = fd;
}

int
pfr_get_fd(void)
{
	return pfr_dev;
}
d57 1
a57 1
	if (pfr_ioctl(DIOCRCLRTABLES, &io))
d77 1
a77 1
	if (pfr_ioctl(DIOCRADDTABLES, &io))
d97 1
a97 1
	if (pfr_ioctl(DIOCRDELTABLES, &io))
d117 1
a117 1
	if (pfr_ioctl(DIOCRGETTABLES, &io))
d136 1
a136 1
	if (pfr_ioctl(DIOCRGETTSTATS, &io))
d154 1
a154 1
	if (pfr_ioctl(DIOCRSETADDRS, &io))
d176 1
a176 1
	if (pfr_ioctl(DIOCRADDADDRS, &io))
d198 1
a198 1
	if (pfr_ioctl(DIOCRDELADDRS, &io))
d221 1
a221 1
	if (pfr_ioctl(DIOCRSETADDRS, &io))
d249 1
a249 1
	if (pfr_ioctl(DIOCRGETADDRS, &io))
d270 1
a270 1
	if (pfr_ioctl(DIOCRGETASTATS, &io))
d291 1
a291 1
	if (pfr_ioctl(DIOCRCLRTSTATS, &io))
d311 1
a311 1
	if (pfr_ioctl(DIOCRCLRTSTATS, &io))
d334 1
a334 1
	if (pfr_ioctl(DIOCRTSTADDRS, &io))
d357 1
a357 1
	if (pfr_ioctl(DIOCRWRAPTABLE, &io))
d377 1
a377 1
	if (pfr_ioctl(DIOCRUNWRTABLE, &io))
@


1.3
log
@kill stupid macro
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.2 2003/01/03 21:43:11 deraadt Exp $ */
d48 1
a48 1
static int _pfr_dev = -1;
d51 1
a51 1
_pfr_ioctl(unsigned long op, void *buf)
d53 3
a55 3
	if (_pfr_dev < 0)
		return (_pfr_dev);
	return (ioctl(_pfr_dev, op, buf));
d61 1
a61 1
	_pfr_dev = fd;
d67 1
a67 1
	return _pfr_dev;
d77 1
a77 1
	if (_pfr_ioctl(DIOCRCLRTABLES, &io))
d97 1
a97 1
	if (_pfr_ioctl(DIOCRADDTABLES, &io))
d117 1
a117 1
	if (_pfr_ioctl(DIOCRDELTABLES, &io))
d137 1
a137 1
	if (_pfr_ioctl(DIOCRGETTABLES, &io))
d156 1
a156 1
	if (_pfr_ioctl(DIOCRGETTSTATS, &io))
d174 1
a174 1
	if (_pfr_ioctl(DIOCRSETADDRS, &io))
d196 1
a196 1
	if (_pfr_ioctl(DIOCRADDADDRS, &io))
d218 1
a218 1
	if (_pfr_ioctl(DIOCRDELADDRS, &io))
d241 1
a241 1
	if (_pfr_ioctl(DIOCRSETADDRS, &io))
d269 1
a269 1
	if (_pfr_ioctl(DIOCRGETADDRS, &io))
d290 1
a290 1
	if (_pfr_ioctl(DIOCRGETASTATS, &io))
d311 1
a311 1
	if (_pfr_ioctl(DIOCRCLRTSTATS, &io))
d331 1
a331 1
	if (_pfr_ioctl(DIOCRCLRTSTATS, &io))
d354 1
a354 1
	if (_pfr_ioctl(DIOCRTSTADDRS, &io))
d377 1
a377 1
	if (_pfr_ioctl(DIOCRWRAPTABLE, &io))
d397 1
a397 1
	if (_pfr_ioctl(DIOCRUNWRTABLE, &io))
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.1 2003/01/03 21:37:44 cedric Exp $ */
a47 6
#define RETURN_EINVAL		\
	do {			\
		errno = EINVAL;	\
		return (-1);	\
	} while (0)

d89 4
a92 2
	if (size < 0 || (size && tbl == NULL))
		RETURN_EINVAL;
d109 4
a112 2
	if (size < 0 || (size && tbl == NULL))
		RETURN_EINVAL;
d129 4
a132 2
	if (size == NULL || *size < 0 || (*size && tbl == NULL))
		RETURN_EINVAL;
d148 4
a151 2
	if (size == NULL || *size < 0 || (*size && tbl == NULL))
		RETURN_EINVAL;
d167 4
a170 2
	if (tbl == NULL)
		RETURN_EINVAL;
d187 4
a190 2
	if (tbl == NULL || size < 0 || (size && addr == NULL))
		RETURN_EINVAL;
d209 4
a212 2
	if (tbl == NULL || size < 0 || (size && addr == NULL))
		RETURN_EINVAL;
d231 4
a234 2
	if (tbl == NULL || size < 0 || (size && addr == NULL))
		RETURN_EINVAL;
d260 4
a263 2
	if (tbl == NULL || size == NULL || *size < 0 || (*size && addr == NULL))
		RETURN_EINVAL;
d281 4
a284 2
	if (tbl == NULL || size == NULL || *size < 0 || (*size && addr == NULL))
		RETURN_EINVAL;
d302 4
a305 2
	if (tbl == NULL || size < 0 || (size && addr == NULL))
		RETURN_EINVAL;
d323 4
a326 2
	if (size < 0 || (size && !tbl))
		RETURN_EINVAL;
d345 4
a348 2
	if (tbl == NULL || size < 0 || (size && addr == NULL))
		RETURN_EINVAL;
d367 4
a370 2
	if (tbl == NULL)
		RETURN_EINVAL;
d389 4
a392 2
	if (wrap == NULL)
		RETURN_EINVAL;
@


1.1
log
@Bring in userland code for accessing PF radix tables.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_radix.c,v 1.37 2002/12/22 14:19:29 dhartmei Exp $ */
d286 1
a286 1
        struct pfioc_table io;
d288 12
a299 12
        if (tbl == NULL || size < 0 || (size && addr == NULL))
                RETURN_EINVAL;
        bzero(&io, sizeof io);
        io.pfrio_flags = flags;
        io.pfrio_table = *tbl;
        io.pfrio_buffer = addr;
        io.pfrio_size = size;
        if (_pfr_ioctl(DIOCRCLRTSTATS, &io))
                return (-1);
        if (nzero != NULL)
                *nzero = io.pfrio_nzero;
        return (0);
@

