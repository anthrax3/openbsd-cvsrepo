head	1.34;
access;
symbols
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.14
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.12
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.8
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.14
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.12
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.10
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.8
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.6
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15;
locks; strict;
comment	@ * @;


1.34
date	2014.04.19.14.22.32;	author henning;	state dead;
branches;
next	1.33;

1.33
date	2013.10.12.12.16.12;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.04.22.49.03;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.27.21.47.32;	author kjc;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.15.15.25.44;	author dhartmei;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.19.21.37.01;	author cedric;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.10.17.53.37;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.05.18.06.12;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.29.01.25.13;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.31.09.46.08;	author kjc;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.21.20.57.45;	author dhartmei;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.20.16.53.48;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.06.17.53.05;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.19.00.22.15;	author camield;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.18.20.32.36;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.15.11.51.42;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.15.11.29.24;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.14.14.50.46;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.11.11.53.28;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.08.14.26.31;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.02.23.37.24;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.27.19.37.46;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.24.11.20.46;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.24.11.11.17;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.24.10.22.11;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.24.08.54.09;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.10.08.03.28;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.10.08.00.23;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.10.07.59.18;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.09.18.34.29;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.09.18.27.41;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.09.18.24.42;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.09.17.33.20;	author henning;	state Exp;
branches;
next	;


desc
@@


1.34
log
@remove altq bits here, too
(i was convinced i committed that yesterday already, hrm)
@
text
@/*	$OpenBSD: pfctl_qstats.c,v 1.33 2013/10/12 12:16:12 henning Exp $ */

/*
 * Copyright (c) 2003 - 2013 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>
#include <arpa/inet.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>

#include "pfctl.h"
#include "pfctl_parser.h"

union class_stats {
	class_stats_t		cbq_stats;
	struct priq_classstats	priq_stats;
	struct hfsc_classstats	hfsc_stats;
};

#define AVGN_MAX	8
#define STAT_INTERVAL	5

struct queue_stats {
	union class_stats	 data;
	int			 avgn;
	double			 avg_bytes;
	double			 avg_packets;
	u_int64_t		 prev_bytes;
	u_int64_t		 prev_packets;
};

struct pf_altq_node {
	struct pf_altq		 altq;
	struct pf_altq_node	*next;
	struct pf_altq_node	*children;
	struct queue_stats	 qstats;
};

int			 pfctl_update_altqstats(int, struct pf_altq_node **);
void			 pfctl_insert_altq_node(struct pf_altq_node **,
			    const struct pf_altq, const struct queue_stats);
struct pf_altq_node	*pfctl_find_altq_node(struct pf_altq_node *,
			    const char *, const char *);
void			 pfctl_print_altq_node(int, const struct pf_altq_node *,
			     unsigned, int);
void			 print_cbqstats(struct queue_stats);
void			 print_priqstats(struct queue_stats);
void			 print_hfscstats(struct queue_stats);
void			 pfctl_free_altq_node(struct pf_altq_node *);
void			 pfctl_print_altq_nodestat(int,
			    const struct pf_altq_node *);

void			 altq_update_avg(struct pf_altq_node *);

int
pfctl_show_altq(int dev, const char *iface, int opts, int verbose2)
{
	struct pf_altq_node	*root = NULL, *node;
	int			 nodes, dotitle = (opts & PF_OPT_SHOWALL);


	if ((nodes = pfctl_update_altqstats(dev, &root)) < 0)
		return (-1);

	if (nodes == 0)
		printf("No altq queue in use\n");
	for (node = root; node != NULL; node = node->next) {
		if (iface != NULL && strcmp(node->altq.ifname, iface))
			continue;
		if (dotitle) {
			pfctl_print_title("ALTQ:");
			dotitle = 0;
		}
		pfctl_print_altq_node(dev, node, 0, opts);
	}

	while (verbose2 && nodes > 0) {
		printf("\n");
		fflush(stdout);
		sleep(STAT_INTERVAL);
		if ((nodes = pfctl_update_altqstats(dev, &root)) == -1)
			return (-1);
		for (node = root; node != NULL; node = node->next) {
			if (iface != NULL && strcmp(node->altq.ifname, iface))
				continue;
			pfctl_print_altq_node(dev, node, 0, opts);
		}
	}
	pfctl_free_altq_node(root);
	return (0);
}

int
pfctl_update_altqstats(int dev, struct pf_altq_node **root)
{
	struct pf_altq_node	*node;
	struct pfioc_altq	 pa;
	struct pfioc_altqstats	 pq;
	u_int32_t		 mnr, nr;
	struct queue_stats	 qstats;
	static	u_int32_t	 last_ticket;

	memset(&pa, 0, sizeof(pa));
	memset(&pq, 0, sizeof(pq));
	memset(&qstats, 0, sizeof(qstats));
	if (ioctl(dev, DIOCGETALTQS, &pa)) {
		warn("DIOCGETALTQS");
		return (-1);
	}

	/* if a new set is found, start over */
	if (pa.ticket != last_ticket && *root != NULL) {
		pfctl_free_altq_node(*root);
		*root = NULL;
	}
	last_ticket = pa.ticket;

	mnr = pa.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pa.nr = nr;
		if (ioctl(dev, DIOCGETALTQ, &pa)) {
			warn("DIOCGETALTQ");
			return (-1);
		}
		if (pa.altq.qid > 0) {
			pq.nr = nr;
			pq.ticket = pa.ticket;
			pq.buf = &qstats.data;
			pq.nbytes = sizeof(qstats.data);
			if (ioctl(dev, DIOCGETALTQSTATS, &pq)) {
				warn("DIOCGETALTQSTATS");
				return (-1);
			}
			if ((node = pfctl_find_altq_node(*root, pa.altq.qname,
			    pa.altq.ifname)) != NULL) {
				memcpy(&node->qstats.data, &qstats.data,
				    sizeof(qstats.data));
				altq_update_avg(node);
			} else {
				pfctl_insert_altq_node(root, pa.altq, qstats);
			}
		}
	}
	return (mnr);
}

void
pfctl_insert_altq_node(struct pf_altq_node **root,
    const struct pf_altq altq, const struct queue_stats qstats)
{
	struct pf_altq_node	*node;

	node = calloc(1, sizeof(struct pf_altq_node));
	if (node == NULL)
		err(1, "pfctl_insert_altq_node: calloc");
	memcpy(&node->altq, &altq, sizeof(struct pf_altq));
	memcpy(&node->qstats, &qstats, sizeof(qstats));
	node->next = node->children = NULL;

	if (*root == NULL)
		*root = node;
	else if (!altq.parent[0]) {
		struct pf_altq_node	*prev = *root;

		while (prev->next != NULL)
			prev = prev->next;
		prev->next = node;
	} else {
		struct pf_altq_node	*parent;

		parent = pfctl_find_altq_node(*root, altq.parent, altq.ifname);
		if (parent == NULL)
			errx(1, "parent %s not found", altq.parent);
		if (parent->children == NULL)
			parent->children = node;
		else {
			struct pf_altq_node *prev = parent->children;

			while (prev->next != NULL)
				prev = prev->next;
			prev->next = node;
		}
	}
	altq_update_avg(node);
}

struct pf_altq_node *
pfctl_find_altq_node(struct pf_altq_node *root, const char *qname,
    const char *ifname)
{
	struct pf_altq_node	*node, *child;

	for (node = root; node != NULL; node = node->next) {
		if (!strcmp(node->altq.qname, qname)
		    && !(strcmp(node->altq.ifname, ifname)))
			return (node);
		if (node->children != NULL) {
			child = pfctl_find_altq_node(node->children, qname,
			    ifname);
			if (child != NULL)
				return (child);
		}
	}
	return (NULL);
}

void
pfctl_print_altq_node(int dev, const struct pf_altq_node *node,
    unsigned int level, int opts)
{
	const struct pf_altq_node	*child;

	if (node == NULL)
		return;

	print_altq(&node->altq, level, NULL, NULL);

	if (node->children != NULL) {
		printf("{");
		for (child = node->children; child != NULL;
		    child = child->next) {
			printf("%s", child->altq.qname);
			if (child->next != NULL)
				printf(", ");
		}
		printf("}");
	}
	printf("\n");

	if (opts & PF_OPT_VERBOSE)
		pfctl_print_altq_nodestat(dev, node);

	if (opts & PF_OPT_DEBUG)
		printf("  [ qid=%u ifname=%s ifbandwidth=%s ]\n",
		    node->altq.qid, node->altq.ifname,
		    rate2str((double)(node->altq.ifbandwidth)));

	for (child = node->children; child != NULL;
	    child = child->next)
		pfctl_print_altq_node(dev, child, level + 1, opts);
}

void
pfctl_print_altq_nodestat(int dev, const struct pf_altq_node *a)
{
	if (a->altq.qid == 0)
		return;

	switch (a->altq.scheduler) {
	case ALTQT_CBQ:
		print_cbqstats(a->qstats);
		break;
	case ALTQT_PRIQ:
		print_priqstats(a->qstats);
		break;
	case ALTQT_HFSC:
		print_hfscstats(a->qstats);
		break;
	}
}

void
print_cbqstats(struct queue_stats cur)
{
	printf("  [ pkts: %10llu  bytes: %10llu  "
	    "dropped pkts: %6llu bytes: %6llu ]\n",
	    (unsigned long long)cur.data.cbq_stats.xmit_cnt.packets,
	    (unsigned long long)cur.data.cbq_stats.xmit_cnt.bytes,
	    (unsigned long long)cur.data.cbq_stats.drop_cnt.packets,
	    (unsigned long long)cur.data.cbq_stats.drop_cnt.bytes);
	printf("  [ qlength: %3d/%3d  borrows: %6u  suspends: %6u ]\n",
	    cur.data.cbq_stats.qcnt, cur.data.cbq_stats.qmax,
	    cur.data.cbq_stats.borrows, cur.data.cbq_stats.delays);

	if (cur.avgn < 2)
		return;

	printf("  [ measured: %7.1f packets/s, %s/s ]\n",
	    cur.avg_packets / STAT_INTERVAL,
	    rate2str((8 * cur.avg_bytes) / STAT_INTERVAL));
}

void
print_priqstats(struct queue_stats cur)
{
	printf("  [ pkts: %10llu  bytes: %10llu  "
	    "dropped pkts: %6llu bytes: %6llu ]\n",
	    (unsigned long long)cur.data.priq_stats.xmitcnt.packets,
	    (unsigned long long)cur.data.priq_stats.xmitcnt.bytes,
	    (unsigned long long)cur.data.priq_stats.dropcnt.packets,
	    (unsigned long long)cur.data.priq_stats.dropcnt.bytes);
	printf("  [ qlength: %3d/%3d ]\n",
	    cur.data.priq_stats.qlength, cur.data.priq_stats.qlimit);

	if (cur.avgn < 2)
		return;

	printf("  [ measured: %7.1f packets/s, %s/s ]\n",
	    cur.avg_packets / STAT_INTERVAL,
	    rate2str((8 * cur.avg_bytes) / STAT_INTERVAL));
}

void
print_hfscstats(struct queue_stats cur)
{
	printf("  [ pkts: %10llu  bytes: %10llu  "
	    "dropped pkts: %6llu bytes: %6llu ]\n",
	    (unsigned long long)cur.data.hfsc_stats.xmit_cnt.packets,
	    (unsigned long long)cur.data.hfsc_stats.xmit_cnt.bytes,
	    (unsigned long long)cur.data.hfsc_stats.drop_cnt.packets,
	    (unsigned long long)cur.data.hfsc_stats.drop_cnt.bytes);
	printf("  [ qlength: %3d/%3d ]\n",
	    cur.data.hfsc_stats.qlength, cur.data.hfsc_stats.qlimit);

	if (cur.avgn < 2)
		return;

	printf("  [ measured: %7.1f packets/s, %s/s ]\n",
	    cur.avg_packets / STAT_INTERVAL,
	    rate2str((8 * cur.avg_bytes) / STAT_INTERVAL));
}

void
pfctl_free_altq_node(struct pf_altq_node *node)
{
	while (node != NULL) {
		struct pf_altq_node	*prev;

		if (node->children != NULL)
			pfctl_free_altq_node(node->children);
		prev = node;
		node = node->next;
		free(prev);
	}
}

void
altq_update_avg(struct pf_altq_node *a)
{
	struct queue_stats	*qs;
	u_int64_t		 b, p;
	int			 n;

	if (a->altq.qid == 0)
		return;

	qs = &a->qstats;
	n = qs->avgn;

	switch (a->altq.scheduler) {
	case ALTQT_CBQ:
		b = qs->data.cbq_stats.xmit_cnt.bytes;
		p = qs->data.cbq_stats.xmit_cnt.packets;
		break;
	case ALTQT_PRIQ:
		b = qs->data.priq_stats.xmitcnt.bytes;
		p = qs->data.priq_stats.xmitcnt.packets;
		break;
	case ALTQT_HFSC:
		b = qs->data.hfsc_stats.xmit_cnt.bytes;
		p = qs->data.hfsc_stats.xmit_cnt.packets;
		break;
	default:
		b = 0;
		p = 0;
		break;
	}

	if (n == 0) {
		qs->prev_bytes = b;
		qs->prev_packets = p;
		qs->avgn++;
		return;
	}

	if (b >= qs->prev_bytes)
		qs->avg_bytes = ((qs->avg_bytes * (n - 1)) +
		    (b - qs->prev_bytes)) / n;

	if (p >= qs->prev_packets)
		qs->avg_packets = ((qs->avg_packets * (n - 1)) +
		    (p - qs->prev_packets)) / n;

	qs->prev_bytes = b;
	qs->prev_packets = p;
	if (n < AVGN_MAX)
		qs->avgn++;
}
@


1.33
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.32
log
@tsc tsc, no waikiki for me. copyright statement without year. 2003 it was.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.31 2007/10/15 02:16:35 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
d67 1
a67 1
int			 pfctl_update_qstats(int, struct pf_altq_node **);
d81 1
a81 1
void			 update_avg(struct pf_altq_node *);
d90 1
a90 1
	if ((nodes = pfctl_update_qstats(dev, &root)) < 0)
d94 1
a94 1
		printf("No queue in use\n");
d109 1
a109 1
		if ((nodes = pfctl_update_qstats(dev, &root)) == -1)
d122 1
a122 1
pfctl_update_qstats(int dev, struct pf_altq_node **root)
d126 1
a126 1
	struct pfioc_qstats	 pq;
d158 2
a159 2
			if (ioctl(dev, DIOCGETQSTATS, &pq)) {
				warn("DIOCGETQSTATS");
d166 1
a166 1
				update_avg(node);
d212 1
a212 1
	update_avg(node);
d366 1
a366 1
update_avg(struct pf_altq_node *a)
@


1.31
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.30 2004/04/27 21:47:32 kjc Exp $ */
d4 1
a4 1
 * Copyright (c) Henning Brauer <henning@@openbsd.org>
@


1.30
log
@make "pfctl -vvsq" to print "No queue in use" and exit when there is no
queue to show the state.

requested by "Alexey E. Suslikov" <cruel@@texnika.com.ua>

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.29 2004/03/15 15:25:44 dhartmei Exp $ */
d236 2
a237 2
pfctl_print_altq_node(int dev, const struct pf_altq_node *node, unsigned level,
    int opts)
@


1.29
log
@cast %llu arguments to unsigned long long, from Max Laier,
ok henning@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.28 2004/02/19 21:37:01 cedric Exp $ */
d93 2
d105 1
a105 1
	while (verbose2) {
d109 1
a109 1
		if (pfctl_update_qstats(dev, &root) == -1)
@


1.28
log
@Makes pfctl -ss and pfctl -sq use optional -i argument.
ok dhartmei@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.27 2004/02/10 17:53:37 henning Exp $ */
d293 4
a296 4
	    cur.data.cbq_stats.xmit_cnt.packets,
	    cur.data.cbq_stats.xmit_cnt.bytes,
	    cur.data.cbq_stats.drop_cnt.packets,
	    cur.data.cbq_stats.drop_cnt.bytes);
d314 4
a317 4
	    cur.data.priq_stats.xmitcnt.packets,
	    cur.data.priq_stats.xmitcnt.bytes,
	    cur.data.priq_stats.dropcnt.packets,
	    cur.data.priq_stats.dropcnt.bytes);
d334 4
a337 4
	    cur.data.hfsc_stats.xmit_cnt.packets,
	    cur.data.hfsc_stats.xmit_cnt.bytes,
	    cur.data.hfsc_stats.drop_cnt.packets,
	    cur.data.hfsc_stats.drop_cnt.bytes);
@


1.27
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.26 2004/02/05 18:06:12 henning Exp $ */
d84 1
a84 1
pfctl_show_altq(int dev, int opts, int verbose2)
d87 1
a87 1
	int			 nodes;
a91 2
	if (opts & PF_OPT_SHOWALL && nodes > 0)
		pfctl_print_title("ALTQ:");
d93 7
a99 1
	for (node = root; node != NULL; node = node->next)
d101 1
d109 3
a111 1
		for (node = root; node != NULL; node = node->next)
d113 1
@


1.26
log
@pfctl_update_qstats() returns -1 on error and the # of queues otehrwise
fix a check of the return value to cope woth that
inspired by PR3675 from Marc Huber <Marc.Huber@@web.de>, fixed slightly
different.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.25 2004/01/29 01:25:13 mcbride Exp $ */
d87 1
a87 1
	int nodes; 
d252 3
a254 2
		printf("  [ qid=%u ifname=%s ifbandwidth=%s ]\n", node->altq.qid,
		    node->altq.ifname, rate2str((double)(node->altq.ifbandwidth)));
d258 1
a258 1
		pfctl_print_altq_node(dev, child, level+1, opts);
@


1.25
log
@Clean up 'pfctl -s all' output.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.24 2003/07/31 09:46:08 kjc Exp $ */
d102 1
a102 1
		if (pfctl_update_qstats(dev, &root))
@


1.24
log
@remove the old tree when we find a new ticket.
this fixes printing obsolete (non-existent) queues.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.23 2003/06/21 20:57:45 dhartmei Exp $ */
d87 1
d89 2
a90 1
	if (pfctl_update_qstats(dev, &root))
d92 2
d162 1
a162 1
	return (0);
@


1.23
log
@fflush(stdout) in pfctl -vvsq endless output.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.22 2003/06/20 16:53:48 deraadt Exp $ */
d115 1
d124 8
@


1.22
log
@some cleanings recommended by lint; dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.21 2003/06/06 17:53:05 henning Exp $ */
d96 1
@


1.21
log
@simplify license. pfctl_altq.c with kenjiro's permission of course.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.20 2003/05/19 00:22:15 camield Exp $ */
d239 1
a239 1
		    node->altq.ifname, rate2str(node->altq.ifbandwidth));
@


1.20
log
@Use a decaying average for smoother rate estimates.

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.19 2003/05/18 20:32:36 henning Exp $ */
d4 1
a4 2
 * Copyright (c) 2003 Henning Brauer
 * All rights reserved.
d6 3
a8 23
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d10 7
@


1.19
log
@indent here in the same way as in -vsr for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.18 2003/04/15 11:51:42 henning Exp $ */
d62 3
d67 5
a71 2
	struct timeval		 timestamp;
	u_int8_t		 valid;
a78 1
	struct queue_stats	 qstats_last;
d88 3
a90 5
void			 print_cbqstats(struct queue_stats, struct queue_stats);
void			 print_priqstats(struct queue_stats,
			     struct queue_stats);
void			 print_hfscstats(struct queue_stats,
			     struct queue_stats);
d95 1
a95 3
double	calc_interval(struct timeval *, struct timeval *);
double	calc_rate(u_int64_t, u_int64_t, double);
double	calc_pps(u_int64_t, u_int64_t, double);
d110 1
a110 1
		sleep(5);
d146 2
a147 2
			pq.buf = &qstats;
			pq.nbytes = sizeof(qstats);
a151 2
			qstats.valid = 1;
			gettimeofday(&qstats.timestamp, NULL);
d154 4
a157 5
				memcpy(&node->qstats_last, &node->qstats,
				    sizeof(struct queue_stats));
				memcpy(&node->qstats, &qstats,
				    sizeof(qstats));
			} else
d159 1
d202 1
d268 1
a268 1
		print_cbqstats(a->qstats, a->qstats_last);
d271 1
a271 1
		print_priqstats(a->qstats, a->qstats_last);
d274 1
a274 1
		print_hfscstats(a->qstats, a->qstats_last);
d280 1
a280 1
print_cbqstats(struct queue_stats cur, struct queue_stats last)
a281 2
	double	interval;

d292 1
a292 1
	if (!last.valid)
a294 1
	interval = calc_interval(&cur.timestamp, &last.timestamp);
d296 2
a297 4
	    calc_pps(cur.data.cbq_stats.xmit_cnt.packets,
		last.data.cbq_stats.xmit_cnt.packets, interval),
	    rate2str(calc_rate(cur.data.cbq_stats.xmit_cnt.bytes,
		last.data.cbq_stats.xmit_cnt.bytes, interval)));
d301 1
a301 1
print_priqstats(struct queue_stats cur, struct queue_stats last)
a302 2
	double	interval;

d312 1
a312 1
	if (!last.valid)
a314 1
	interval = calc_interval(&cur.timestamp, &last.timestamp);
d316 2
a317 4
	    calc_pps(cur.data.priq_stats.xmitcnt.packets,
		last.data.priq_stats.xmitcnt.packets, interval),
	    rate2str(calc_rate(cur.data.priq_stats.xmitcnt.bytes,
		last.data.priq_stats.xmitcnt.bytes, interval)));
d321 1
a321 1
print_hfscstats(struct queue_stats cur, struct queue_stats last)
a322 2
	double	interval;

d332 1
a332 1
	if (!last.valid)
a334 1
	interval = calc_interval(&cur.timestamp, &last.timestamp);
d336 2
a337 4
	    calc_pps(cur.data.hfsc_stats.xmit_cnt.packets,
		last.data.hfsc_stats.xmit_cnt.packets, interval),
	    rate2str(calc_rate(cur.data.hfsc_stats.xmit_cnt.bytes,
		last.data.hfsc_stats.xmit_cnt.bytes, interval)));
d354 9
a362 10
/* calculate interval in sec */
double
calc_interval(struct timeval *cur_time, struct timeval *last_time)
{
	double	sec;

	sec = (double)(cur_time->tv_sec - last_time->tv_sec) +
	    (double)(cur_time->tv_usec - last_time->tv_usec) / 1000000;
	return (sec);
}
d364 2
a365 5
/* calculate rate in bps */
double
calc_rate(u_int64_t new_bytes, u_int64_t last_bytes, double interval)
{
	double	rate;
d367 18
a384 3
	rate = (double)(new_bytes - last_bytes) * 8 / interval;
	return (rate);
}
d386 6
a391 5
/* calculate packets in second */
double
calc_pps(u_int64_t new_pkts, u_int64_t last_pkts, double interval)
{
	double	pps;
d393 12
a404 2
	pps = (double)(new_pkts - last_pkts) / interval;
	return (pps);
@


1.18
log
@display basic hfsc stats
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.17 2003/04/15 11:29:24 henning Exp $ */
d252 1
a252 1
		printf("[ qid=%u ifname=%s ifbandwidth=%s ]\n", node->altq.qid,
d284 1
a284 1
	printf("[ pkts: %10llu  bytes: %10llu  "
d290 1
a290 1
	printf("[ qlength: %3d/%3d  borrows: %6u  suspends: %6u ]\n",
d298 1
a298 1
	printf("[ measured: %7.1f packets/s, %s/s ]\n",
d310 1
a310 1
	printf("[ pkts: %10llu  bytes: %10llu  "
d316 1
a316 1
	printf("[ qlength: %3d/%3d ]\n",
d323 1
a323 1
	printf("[ measured: %7.1f packets/s, %s/s ]\n",
d335 1
a335 1
	printf("[ pkts: %10llu  bytes: %10llu  "
d341 1
a341 1
	printf("[ qlength: %3d/%3d ]\n",
d348 1
a348 1
	printf("[ measured: %7.1f packets/s, %s/s ]\n",
@


1.17
log
@pass down the unparsed queue opts (struct node_queue_opt) to
print_altq/print_hfsc -> print_hfsc_opts and extract struct node_hfsc_sc
there for each service curve and pass those down to print_hfsc_sc. now
bandwidth specifications in the service curves are printed correct in the
case of a queue belonging to more than one interface/parent queue, the
parent queues having different bandwidths and the bandwith on teh service
curve beeing specified in percent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.16 2003/04/14 14:50:46 henning Exp $ */
d86 2
d273 3
d328 25
@


1.16
log
@let print_altq and print_queue take a struct node_queue_bw parameter instead
of dintinct bw_percent
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.15 2003/03/11 11:53:28 henning Exp $ */
d232 1
a232 1
	print_altq(&node->altq, level, NULL);
@


1.15
log
@fix format strings in debugging output, qid is unsigned

ok cedric@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.14 2003/03/08 14:26:31 henning Exp $ */
d232 1
a232 1
	print_altq(&node->altq, level, 0);
@


1.14
log
@inlcude queue interals in -gsr and -gsq output; will make debugging easier.

ok cedric@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.13 2003/03/02 23:37:24 henning Exp $ */
d250 1
a250 1
		printf("[ qid=%d ifname=%s ifbandwidth=%s ]\n", node->altq.qid,
@


1.13
log
@when printing queues at load time that have bandwidth specified in percent,
print the bandwidth in percent instead of the calculated absolute value.
if a queue belongs to more than one interface and they have different
bandwidth the calculated absolute is of course different per interface.
previously the first calculated absolute value was shown; what of course is
incorrect on the second interface. note that only the print was wrong, the
correct values were passed to the kernel.

ok theo daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.12 2003/01/27 19:37:46 henning Exp $ */
d54 1
d95 1
a95 1
pfctl_show_altq(int dev, int verbose, int verbose2)
d103 1
a103 1
		pfctl_print_altq_node(dev, node, 0, verbose);
d111 1
a111 1
			pfctl_print_altq_node(dev, node, 0, verbose);
d225 1
a225 1
    int verbose)
d246 1
a246 1
	if (verbose)
d249 4
d255 1
a255 1
		pfctl_print_altq_node(dev, child, level+1, verbose);
@


1.12
log
@bit KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.11 2003/01/24 11:20:46 henning Exp $ */
d231 1
a231 1
	print_altq(&node->altq, level);
@


1.11
log
@pfctl -vvsq shows bandwidth and packets/s for PRIQ now too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.10 2003/01/24 11:11:17 henning Exp $ */
d179 1
a179 1
		struct pf_altq_node *prev = *root;
d185 1
a185 1
		struct pf_altq_node *parent;
d324 1
a324 1
		struct pf_altq_node *prev;
@


1.10
log
@let pfctl -vvsq loop and display measured bandwidth and packets/s per queue.
cbq only for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.9 2003/01/24 10:22:11 henning Exp $ */
d298 2
d308 10
@


1.9
log
@tune internal APIs a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.8 2003/01/24 08:54:09 henning Exp $ */
d94 1
a94 1
pfctl_show_altq(int dev, int verbose)
d103 9
d272 2
d283 10
@


1.8
log
@bring in 3 yet unused helper functions before I lose 'em again
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.7 2003/01/10 08:03:28 henning Exp $ */
d64 1
d82 3
a84 2
void			 print_cbqstats(class_stats_t);
void			 print_priqstats(struct priq_classstats);
d139 1
d252 1
a252 1
		print_cbqstats(a->qstats.data.cbq_stats);
d255 1
a255 1
		print_priqstats(a->qstats.data.priq_stats);
d261 1
a261 1
print_cbqstats(class_stats_t qstats)
d265 4
a268 2
	    qstats.xmit_cnt.packets, qstats.xmit_cnt.bytes,
	    qstats.drop_cnt.packets, qstats.drop_cnt.bytes);
d270 2
a271 1
	    qstats.qcnt, qstats.qmax, qstats.borrows, qstats.delays);
d275 1
a275 1
print_priqstats(struct priq_classstats qstats)
d279 4
a282 2
	    qstats.xmitcnt.packets, qstats.xmitcnt.bytes,
	    qstats.dropcnt.packets, qstats.dropcnt.bytes);
d284 1
a284 1
	    qstats.qlength, qstats.qlimit);
@


1.7
log
@no return after err(3), errx -> err after calloc failure

andrushock at korovino.net via dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.6 2003/01/10 08:00:23 henning Exp $ */
d87 4
d291 31
@


1.6
log
@print queue length for PRIQ, works now
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.5 2003/01/10 07:59:18 henning Exp $ */
d154 2
a155 4
	if (node == NULL) {
		errx(1, "pfctl_insert_altq_node: calloc");
		return;
	}
d172 1
a172 1
		if (parent == NULL) {
a173 2
			return;
		}
a273 1

@


1.5
log
@fix thinko
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.4 2003/01/09 18:34:29 henning Exp $ */
a274 3

/* strange results. disable for now */
#if 0
a276 1
#endif
@


1.4
log
@use a verbose flag in pfctl_show_altq instead of carrying around opts from
pfctl.c, and get rid of the #include "pfctl_parser.h"
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.3 2003/01/09 18:27:41 henning Exp $ */
d59 5
a63 1
	struct timeval		timestamp;
d70 2
a71 2
	union class_stats	 qstats;
	union class_stats	 qstats_last;
d76 1
a76 1
			    const struct pf_altq, const union class_stats);
d108 1
a108 1
	union class_stats	 qstats;
d137 1
a137 1
				    sizeof(union class_stats));
d139 1
a139 1
				    sizeof(union class_stats));
d149 1
a149 1
    const struct pf_altq altq, const union class_stats qstats)
d159 1
a159 1
	memcpy(&node->qstats, &qstats, sizeof(union class_stats));
d249 1
a249 1
		print_cbqstats(a->qstats.cbq_stats);
d252 1
a252 1
		print_priqstats(a->qstats.priq_stats);
@


1.3
log
@zap unneeded #include <errno.h> as seen by both of us while discussing
#include stuff with dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.2 2003/01/09 18:24:42 henning Exp $ */
a52 1
#include "pfctl_parser.h"
d84 1
a84 1
pfctl_show_altq(int dev, int opts)
d92 1
a92 1
		pfctl_print_altq_node(dev, node, 0, opts & PF_OPT_VERBOSE);
@


1.2
log
@support PRIQ in queue statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_qstats.c,v 1.1 2003/01/09 17:33:20 henning Exp $ */
a42 1
#include <errno.h>
@


1.1
log
@first attack at pfctl queue statistics, to be displayed with pfctl -vsq

This commit is dedicated to the cute KLM girls who made part of this
possible with giving me a seat in the plane where you actually have enough
place to hack. Thanks, girls.

ok markus@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.c,v 1.126 2003/01/09 10:40:44 cedric Exp $ */
d80 1
d250 1
d262 1
a262 1
	printf("[ qcount: %3d/%3d  borrows: %6u  suspends: %6u ]\n",
d264 15
@

