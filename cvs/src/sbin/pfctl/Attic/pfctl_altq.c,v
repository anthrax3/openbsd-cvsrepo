head	1.102;
access;
symbols
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.99.0.2
	OPENBSD_5_4_BASE:1.99
	OPENBSD_5_3:1.98.0.4
	OPENBSD_5_3_BASE:1.98
	OPENBSD_5_2:1.98.0.2
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.97
	OPENBSD_5_1:1.97.0.4
	OPENBSD_5_0:1.97.0.2
	OPENBSD_5_0_BASE:1.97
	OPENBSD_4_9:1.94.0.12
	OPENBSD_4_9_BASE:1.94
	OPENBSD_4_8:1.94.0.10
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.94.0.6
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.94.0.8
	OPENBSD_4_6_BASE:1.94
	OPENBSD_4_5:1.94.0.4
	OPENBSD_4_5_BASE:1.94
	OPENBSD_4_4:1.94.0.2
	OPENBSD_4_4_BASE:1.94
	OPENBSD_4_3:1.93.0.2
	OPENBSD_4_3_BASE:1.93
	OPENBSD_4_2:1.92.0.2
	OPENBSD_4_2_BASE:1.92
	OPENBSD_4_1:1.91.0.2
	OPENBSD_4_1_BASE:1.91
	OPENBSD_4_0:1.89.0.2
	OPENBSD_4_0_BASE:1.89
	OPENBSD_3_9:1.87.0.2
	OPENBSD_3_9_BASE:1.87
	OPENBSD_3_8:1.86.0.4
	OPENBSD_3_8_BASE:1.86
	OPENBSD_3_7:1.86.0.2
	OPENBSD_3_7_BASE:1.86
	OPENBSD_3_6:1.85.0.2
	OPENBSD_3_6_BASE:1.85
	OPENBSD_3_5:1.83.0.2
	OPENBSD_3_5_BASE:1.83
	OPENBSD_3_4:1.77.0.2
	OPENBSD_3_4_BASE:1.77
	OPENBSD_3_3:1.46.0.2
	OPENBSD_3_3_BASE:1.46;
locks; strict;
comment	@ * @;


1.102
date	2014.04.19.14.22.32;	author henning;	state dead;
branches;
next	1.101;

1.101
date	2014.01.19.04.14.34;	author claudio;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.12.12.16.11;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.20.00.18.00;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2012.05.02.07.45.50;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2011.07.04.01.07.43;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2011.07.03.23.59.43;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.03.23.46.23;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.25.17.43.44;	author martynas;	state Exp;
branches;
next	1.93;

1.93
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.27.05.15.17;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2006.11.28.00.08.50;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2006.11.10.06.07.11;	author joel;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.14.15.52.11;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2006.04.08.02.04.48;	author ray;	state Exp;
branches;
next	1.87;

1.87
date	2006.01.28.18.54.28;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2005.02.28.14.04.51;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2004.05.20.12.18.52;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.26.02.50.04;	author kjc;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.14.21.51.44;	author dhartmei;	state Exp;
branches;
next	1.82;

1.82
date	2004.02.19.07.44.00;	author kjc;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.10.22.26.56;	author dhartmei;	state Exp;
branches;
next	1.80;

1.80
date	2004.02.10.17.53.37;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.14.08.42.23;	author kjc;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.21.21.09.13;	author itojun;	state Exp;
branches;
next	1.77;

1.77
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.76;

1.76
date	2003.08.20.13.03.35;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.20.16.53.48;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.06.17.53.05;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.08.22.09.54;	author dhartmei;	state Exp;
branches;
next	1.72;

1.72
date	2003.04.15.11.29.24;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2003.04.15.11.01.34;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2003.04.15.10.56.21;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2003.04.15.10.20.19;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.14.16.51.36;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.14.16.35.13;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2003.04.14.15.50.53;	author kjc;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.14.14.50.46;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.13.23.22.05;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.13.22.03.18;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2003.04.13.21.44.42;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2003.04.13.20.55.50;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2003.04.13.20.16.06;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2003.04.13.19.36.00;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.12.19.08.40;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.12.19.07.42;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.12.19.05.57;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.12.16.44.19;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.12.16.39.01;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.12.15.09.57;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.11.15.18.33;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2003.04.11.15.13.34;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.05.21.44.46;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.03.14.41.46;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.03.05.08.59;	author kjc;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.28.16.47.39;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.11.14.02.12;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.10.14.54.17;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.10.14.48.38;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.08.14.40.03;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.06.12.50.40;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.03.14.16.18;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.02.23.37.24;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.02.12.37.49;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.02.11.24.58;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.25.12.03.02;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.24.11.37.24;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.24.10.53.32;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.20.19.07.50;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.20.19.05.46;	author camield;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.09.18.55.32;	author dhartmei;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.09.17.33.19;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.05.02.17.09;	author dhartmei;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.03.21.48.21;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.24.13.29.13;	author mcbride;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.23.15.56.24;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.17.20.06.05;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.17.11.29.04;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.17.01.15.59;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.17.00.00.08;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.16.23.06.28;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.08.00.19.47;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.07.19.12.34;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.06.16.16.15;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.03.10.57.13;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.02.22.18.21;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.29.15.52.13;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.28.14.50.23;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.28.14.44.57;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.27.16.23.01;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.27.16.06.20;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.27.15.00.41;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.25.16.30.22;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.22.11.46.02;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.19.17.49.53;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.19.17.41.19;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.19.17.37.39;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.18.23.20.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.18.23.13.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.18.22.55.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.18.22.49.15;	author henning;	state Exp;
branches;
next	;


desc
@@


1.102
log
@remove altq bits here, too
(i was convinced i committed that yesterday already, hrm)
@
text
@/*	$OpenBSD: pfctl_altq.c,v 1.101 2014/01/19 04:14:34 claudio Exp $	*/

/*
 * Copyright (c) 2002
 *	Sony Computer Science Laboratories Inc.
 * Copyright (c) 2002, 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>

#include "pfctl_parser.h"
#include "pfctl.h"

#define is_sc_null(sc)	(((sc) == NULL) || ((sc)->m1 == 0 && (sc)->m2 == 0))

TAILQ_HEAD(altqs, pf_altq) altqs = TAILQ_HEAD_INITIALIZER(altqs);
LIST_HEAD(gen_sc, segment) rtsc, lssc;

struct pf_altq	*qname_to_pfaltq(const char *, const char *);
u_int32_t	 qname_to_qid(const char *);

static int	eval_pfqueue_cbq(struct pfctl *, struct pf_altq *);
static int	cbq_compute_idletime(struct pfctl *, struct pf_altq *);
static int	check_commit_cbq(int, int, struct pf_altq *);
static int	print_cbq_opts(const struct pf_altq *);

static int	eval_pfqueue_priq(struct pfctl *, struct pf_altq *);
static int	check_commit_priq(int, int, struct pf_altq *);
static int	print_priq_opts(const struct pf_altq *);

static int	eval_pfqueue_hfsc(struct pfctl *, struct pf_altq *);
static int	check_commit_hfsc(int, int, struct pf_altq *);
static int	print_hfsc_opts(const struct pf_altq *,
		    const struct node_queue_opt *);

static void		 gsc_add_sc(struct gen_sc *, struct service_curve *);
static int		 is_gsc_under_sc(struct gen_sc *,
			     struct service_curve *);
static void		 gsc_destroy(struct gen_sc *);
static struct segment	*gsc_getentry(struct gen_sc *, double);
static int		 gsc_add_seg(struct gen_sc *, double, double, double,
			     double);
static double		 sc_x2y(struct service_curve *, double);

u_int32_t	 getifspeed(char *);
u_long		 getifmtu(char *);
int		 eval_queue_opts(struct pf_altq *, struct node_queue_opt *,
		     u_int32_t);
u_int32_t	 eval_bwspec(struct node_queue_bw *, u_int32_t);
void		 print_hfsc_sc(const char *, u_int, u_int, u_int,
		     const struct node_hfsc_sc *);

void
pfaltq_store(struct pf_altq *a)
{
	struct pf_altq	*altq;

	if ((altq = malloc(sizeof(*altq))) == NULL)
		err(1, "malloc");
	memcpy(altq, a, sizeof(struct pf_altq));
	TAILQ_INSERT_TAIL(&altqs, altq, entries);
}

struct pf_altq *
pfaltq_lookup(const char *ifname)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    altq->qname[0] == 0)
			return (altq);
	}
	return (NULL);
}

struct pf_altq *
qname_to_pfaltq(const char *qname, const char *ifname)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    strncmp(qname, altq->qname, PF_QNAME_SIZE) == 0)
			return (altq);
	}
	return (NULL);
}

u_int32_t
qname_to_qid(const char *qname)
{
	struct pf_altq	*altq;

	/*
	 * We guarantee that same named queues on different interfaces
	 * have the same qid, so we do NOT need to limit matching on
	 * one interface!
	 */

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(qname, altq->qname, PF_QNAME_SIZE) == 0)
			return (altq->qid);
	}
	return (0);
}

void
print_altq(const struct pf_altq *a, unsigned int level,
    struct node_queue_bw *bw, struct node_queue_opt *qopts)
{
	if (a->qname[0] != 0) {
		print_queue(a, level, bw, 1, qopts);
		return;
	}

	printf("altq on %s ", a->ifname);

	switch (a->scheduler) {
	case ALTQT_CBQ:
		if (!print_cbq_opts(a))
			printf("cbq ");
		break;
	case ALTQT_PRIQ:
		if (!print_priq_opts(a))
			printf("priq ");
		break;
	case ALTQT_HFSC:
		if (!print_hfsc_opts(a, qopts))
			printf("hfsc ");
		break;
	}

	if (bw != NULL && bw->bw_percent > 0) {
		if (bw->bw_percent < 100)
			printf("bandwidth %u%% ", bw->bw_percent);
	} else
		printf("bandwidth %s ", rate2str((double)a->ifbandwidth));

	if (a->qlimit != DEFAULT_QLIMIT)
		printf("qlimit %u ", a->qlimit);
	printf("tbrsize %u ", a->tbrsize);
}

void
print_queue(const struct pf_altq *a, unsigned int level,
    struct node_queue_bw *bw, int print_interface,
    struct node_queue_opt *qopts)
{
	unsigned int	i;

	printf("oldqueue ");
	for (i = 0; i < level; ++i)
		printf(" ");
	printf("%s ", a->qname);
	if (print_interface)
		printf("on %s ", a->ifname);
	if (a->scheduler == ALTQT_CBQ || a->scheduler == ALTQT_HFSC) {
		if (bw != NULL && bw->bw_percent > 0) {
			if (bw->bw_percent < 100)
				printf("bandwidth %u%% ", bw->bw_percent);
		} else
			printf("bandwidth %s ", rate2str((double)a->bandwidth));
	}
	if (a->priority != DEFAULT_PRIORITY)
		printf("priority %u ", a->priority);
	if (a->qlimit != DEFAULT_QLIMIT)
		printf("qlimit %u ", a->qlimit);
	switch (a->scheduler) {
	case ALTQT_CBQ:
		print_cbq_opts(a);
		break;
	case ALTQT_PRIQ:
		print_priq_opts(a);
		break;
	case ALTQT_HFSC:
		print_hfsc_opts(a, qopts);
		break;
	}
}

/*
 * eval_pfaltq computes the discipline parameters.
 */
int
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw,
    struct node_queue_opt *opts)
{
	u_int	rate, size, errors = 0;

	if (bw->bw_absolute > 0)
		pa->ifbandwidth = bw->bw_absolute;
	else
		if ((rate = getifspeed(pa->ifname)) == 0) {
			fprintf(stderr, "interface %s does not know its bandwidth, "
			    "please specify an absolute bandwidth\n",
			    pa->ifname);
			errors++;
		} else if ((pa->ifbandwidth = eval_bwspec(bw, rate)) == 0)
			pa->ifbandwidth = rate;

	errors += eval_queue_opts(pa, opts, pa->ifbandwidth);

	/* if tbrsize is not specified, use heuristics */
	if (pa->tbrsize == 0) {
		rate = pa->ifbandwidth;
		if (rate <= 1 * 1000 * 1000)
			size = 1;
		else if (rate <= 10 * 1000 * 1000)
			size = 4;
		else if (rate <= 200 * 1000 * 1000)
			size = 8;
		else
			size = 24;

		if ((pf->opts & PF_OPT_NOACTION) == 0)
			size = size * getifmtu(pa->ifname);
		else
			size = size * 1500;

		if (size > 0xffff)
			size = 0xffff;
		pa->tbrsize = size;
	}
	return (errors);
}

/*
 * check_commit_altq does consistency check for each interface
 */
int
check_commit_altq(int dev, int opts)
{
	struct pf_altq	*altq;
	int		 error = 0;

	/* call the discipline check for each interface. */
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (altq->qname[0] == 0) {
			switch (altq->scheduler) {
			case ALTQT_CBQ:
				error = check_commit_cbq(dev, opts, altq);
				break;
			case ALTQT_PRIQ:
				error = check_commit_priq(dev, opts, altq);
				break;
			case ALTQT_HFSC:
				error = check_commit_hfsc(dev, opts, altq);
				break;
			default:
				break;
			}
		}
	}
	return (error);
}

/*
 * eval_pfqueue computes the queue parameters.
 */
int
eval_pfqueue(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw,
    struct node_queue_opt *opts)
{
	/* should be merged with expand_queue */
	struct pf_altq	*if_pa, *parent, *altq;
	u_int32_t	 bwsum;
	int		 error = 0;

	/* find the corresponding interface and copy fields used by queues */
	if ((if_pa = pfaltq_lookup(pa->ifname)) == NULL) {
		fprintf(stderr, "altq not defined on %s\n", pa->ifname);
		return (1);
	}
	pa->scheduler = if_pa->scheduler;
	pa->ifbandwidth = if_pa->ifbandwidth;

	if (qname_to_pfaltq(pa->qname, pa->ifname) != NULL) {
		fprintf(stderr, "queue %s already exists on interface %s\n",
		    pa->qname, pa->ifname);
		return (1);
	}
	pa->qid = qname_to_qid(pa->qname);

	parent = NULL;
	if (pa->parent[0] != 0) {
		parent = qname_to_pfaltq(pa->parent, pa->ifname);
		if (parent == NULL) {
			fprintf(stderr, "parent %s not found for %s\n",
			    pa->parent, pa->qname);
			return (1);
		}
		pa->parent_qid = parent->qid;
	}
	if (pa->qlimit == 0)
		pa->qlimit = DEFAULT_QLIMIT;

	if (pa->scheduler == ALTQT_CBQ || pa->scheduler == ALTQT_HFSC) {
		pa->bandwidth = eval_bwspec(bw,
		    parent == NULL ? 0 : parent->bandwidth);

		if (pa->bandwidth > pa->ifbandwidth) {
			fprintf(stderr, "bandwidth for %s higher than "
			    "interface\n", pa->qname);
			return (1);
		}
		/* check the sum of the child bandwidth is under parent's */
		if (parent != NULL) {
			if (pa->bandwidth > parent->bandwidth) {
				warnx("bandwidth for %s higher than parent",
				    pa->qname);
				return (1);
			}
			bwsum = 0;
			TAILQ_FOREACH(altq, &altqs, entries) {
				if (strncmp(altq->ifname, pa->ifname,
				    IFNAMSIZ) == 0 &&
				    altq->qname[0] != 0 &&
				    strncmp(altq->parent, pa->parent,
				    PF_QNAME_SIZE) == 0)
					bwsum += altq->bandwidth;
			}
			bwsum += pa->bandwidth;
			if (bwsum > parent->bandwidth) {
				warnx("the sum of the child bandwidth higher"
				    " than parent \"%s\"", parent->qname);
			}
		}
	}

	if (eval_queue_opts(pa, opts, parent == NULL? 0 : parent->bandwidth))
		return (1);

	switch (pa->scheduler) {
	case ALTQT_CBQ:
		error = eval_pfqueue_cbq(pf, pa);
		break;
	case ALTQT_PRIQ:
		error = eval_pfqueue_priq(pf, pa);
		break;
	case ALTQT_HFSC:
		error = eval_pfqueue_hfsc(pf, pa);
		break;
	default:
		break;
	}
	return (error);
}

/*
 * CBQ support functions
 */
#define	RM_FILTER_GAIN	5	/* log2 of gain, e.g., 5 => 31/32 */
#define	RM_NS_PER_SEC	(1000000000)

static int
eval_pfqueue_cbq(struct pfctl *pf, struct pf_altq *pa)
{
	struct cbq_opts	*opts;
	u_int		 ifmtu;

	if (pa->priority >= CBQ_MAXPRI) {
		warnx("priority out of range: max %d", CBQ_MAXPRI - 1);
		return (-1);
	}

	if ((pf->opts & PF_OPT_NOACTION) == 0)
		ifmtu = getifmtu(pa->ifname);
	else
		ifmtu = 1500;

	opts = &pa->pq_u.cbq_opts;

	if (opts->pktsize == 0) {	/* use default */
		opts->pktsize = ifmtu;
		if (opts->pktsize > 2048)	/* do what TCP does */
			opts->pktsize &= ~2048;
	} else if (opts->pktsize > ifmtu)
		opts->pktsize = ifmtu;
	if (opts->maxpktsize == 0)	/* use default */
		opts->maxpktsize = ifmtu;
	else if (opts->maxpktsize > ifmtu)
		opts->pktsize = ifmtu;

	if (opts->pktsize > opts->maxpktsize)
		opts->pktsize = opts->maxpktsize;

	if (pa->parent[0] == 0)
		opts->flags |= (CBQCLF_ROOTCLASS | CBQCLF_WRR);

	cbq_compute_idletime(pf, pa);
	return (0);
}

/*
 * compute ns_per_byte, maxidle, minidle, and offtime
 */
static int
cbq_compute_idletime(struct pfctl *pf, struct pf_altq *pa)
{
	struct cbq_opts	*opts;
	double		 maxidle_s, maxidle, minidle;
	double		 offtime, nsPerByte, ifnsPerByte, ptime, cptime;
	double		 z, g, f, gton, gtom;
	u_int		 minburst, maxburst;

	opts = &pa->pq_u.cbq_opts;
	ifnsPerByte = (1.0 / (double)pa->ifbandwidth) * RM_NS_PER_SEC * 8;
	minburst = opts->minburst;
	maxburst = opts->maxburst;

	if (pa->bandwidth == 0)
		f = 0.0001;	/* small enough? */
	else
		f = ((double) pa->bandwidth / (double) pa->ifbandwidth);

	nsPerByte = ifnsPerByte / f;
	ptime = (double)opts->pktsize * ifnsPerByte;
	cptime = ptime * (1.0 - f) / f;

	if (nsPerByte * (double)opts->maxpktsize > (double)INT_MAX) {
		/*
		 * this causes integer overflow in kernel!
		 * (bandwidth < 6Kbps when max_pkt_size=1500)
		 */
		if (pa->bandwidth != 0 && (pf->opts & PF_OPT_QUIET) == 0)
			warnx("queue bandwidth must be larger than %s",
			    rate2str(ifnsPerByte * (double)opts->maxpktsize /
			    (double)INT_MAX * (double)pa->ifbandwidth));
		fprintf(stderr, "cbq: queue %s is too slow!\n", pa->qname);
		nsPerByte = (double)(INT_MAX / opts->maxpktsize);
	}

	if (maxburst == 0) {  /* use default */
		if (cptime > 10.0 * 1000000)
			maxburst = 4;
		else
			maxburst = 16;
	}
	if (minburst == 0)  /* use default */
		minburst = 2;
	if (minburst > maxburst)
		minburst = maxburst;

	z = (double)(1 << RM_FILTER_GAIN);
	g = (1.0 - 1.0 / z);
	gton = pow(g, (double)maxburst);
	gtom = pow(g, (double)(minburst-1));
	maxidle = ((1.0 / f - 1.0) * ((1.0 - gton) / gton));
	maxidle_s = (1.0 - g);
	if (maxidle > maxidle_s)
		maxidle = ptime * maxidle;
	else
		maxidle = ptime * maxidle_s;
	offtime = cptime * (1.0 + 1.0/(1.0 - g) * (1.0 - gtom) / gtom);
	minidle = -((double)opts->maxpktsize * (double)nsPerByte);

	/* scale parameters */
	maxidle = ((maxidle * 8.0) / nsPerByte) *
	    pow(2.0, (double)RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte *
	    pow(2.0, (double)RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) *
	    pow(2.0, (double)RM_FILTER_GAIN);

	maxidle = maxidle / 1000.0;
	offtime = offtime / 1000.0;
	minidle = minidle / 1000.0;

	opts->minburst = minburst;
	opts->maxburst = maxburst;
	opts->ns_per_byte = (u_int)nsPerByte;
	opts->maxidle = (u_int)fabs(maxidle);
	opts->minidle = (int)minidle;
	opts->offtime = (u_int)fabs(offtime);

	return (0);
}

static int
check_commit_cbq(int dev, int opts, struct pf_altq *pa)
{
	struct pf_altq	*altq;
	int		 root_class, default_class;
	int		 error = 0;

	/*
	 * check if cbq has one root queue and one default queue
	 * for this interface
	 */
	root_class = default_class = 0;
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (altq->pq_u.cbq_opts.flags & CBQCLF_ROOTCLASS)
			root_class++;
		if (altq->pq_u.cbq_opts.flags & CBQCLF_DEFCLASS)
			default_class++;
	}
	if (root_class != 1) {
		warnx("should have one root queue on %s", pa->ifname);
		error++;
	}
	if (default_class != 1) {
		warnx("should have one default queue on %s", pa->ifname);
		error++;
	}
	return (error);
}

static int
print_cbq_opts(const struct pf_altq *a)
{
	const struct cbq_opts	*opts;

	opts = &a->pq_u.cbq_opts;
	if (opts->flags) {
		printf("cbq(");
		if (opts->flags & CBQCLF_RED)
			printf(" red");
		if (opts->flags & CBQCLF_ECN)
			printf(" ecn");
		if (opts->flags & CBQCLF_BORROW)
			printf(" borrow");
		if (opts->flags & CBQCLF_WRR)
			printf(" wrr");
		if (opts->flags & CBQCLF_ROOTCLASS)
			printf(" root");
		if (opts->flags & CBQCLF_DEFCLASS)
			printf(" default");
		printf(" ) ");

		return (1);
	} else
		return (0);
}

/*
 * PRIQ support functions
 */
static int
eval_pfqueue_priq(struct pfctl *pf, struct pf_altq *pa)
{
	struct pf_altq	*altq;

	if (pa->priority >= PRIQ_MAXPRI) {
		warnx("priority out of range: max %d", PRIQ_MAXPRI - 1);
		return (-1);
	}
	/* the priority should be unique for the interface */
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) == 0 &&
		    altq->qname[0] != 0 && altq->priority == pa->priority) {
			warnx("%s and %s have the same priority",
			    altq->qname, pa->qname);
			return (-1);
		}
	}

	return (0);
}

static int
check_commit_priq(int dev, int opts, struct pf_altq *pa)
{
	struct pf_altq	*altq;
	int		 default_class;
	int		 error = 0;

	/*
	 * check if priq has one default class for this interface
	 */
	default_class = 0;
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (altq->pq_u.priq_opts.flags & PRCF_DEFAULTCLASS)
			default_class++;
	}
	if (default_class != 1) {
		warnx("should have one default queue on %s", pa->ifname);
		error++;
	}
	return (error);
}

static int
print_priq_opts(const struct pf_altq *a)
{
	const struct priq_opts	*opts;

	opts = &a->pq_u.priq_opts;

	if (opts->flags) {
		printf("priq(");
		if (opts->flags & PRCF_RED)
			printf(" red");
		if (opts->flags & PRCF_ECN)
			printf(" ecn");
		if (opts->flags & PRCF_DEFAULTCLASS)
			printf(" default");
		printf(" ) ");

		return (1);
	} else
		return (0);
}

/*
 * HFSC support functions
 */
static int
eval_pfqueue_hfsc(struct pfctl *pf, struct pf_altq *pa)
{
	struct pf_altq		*altq, *parent;
	struct hfsc_opts	*opts;
	struct service_curve	 sc;

	opts = &pa->pq_u.hfsc_opts;

	if (pa->parent[0] == 0) {
		/* root queue */
		opts->lssc_m1 = pa->ifbandwidth;
		opts->lssc_m2 = pa->ifbandwidth;
		opts->lssc_d = 0;
		return (0);
	}

	LIST_INIT(&rtsc);
	LIST_INIT(&lssc);

	/* if link_share is not specified, use bandwidth */
	if (opts->lssc_m2 == 0)
		opts->lssc_m2 = pa->bandwidth;

	if ((opts->rtsc_m1 > 0 && opts->rtsc_m2 == 0) ||
	    (opts->lssc_m1 > 0 && opts->lssc_m2 == 0) ||
	    (opts->ulsc_m1 > 0 && opts->ulsc_m2 == 0)) {
		warnx("m2 is zero for %s", pa->qname);
		return (-1);
	}

	if ((opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0) ||
	    (opts->lssc_m1 < opts->lssc_m2 && opts->lssc_m1 != 0) ||
	    (opts->ulsc_m1 < opts->ulsc_m2 && opts->ulsc_m1 != 0)) {
		warnx("m1 must be zero for convex curve: %s", pa->qname);
		return (-1);
	}

	/*
	 * admission control:
	 * for the real-time service curve, the sum of the service curves
	 * should not exceed 80% of the interface bandwidth.  20% is reserved
	 * not to over-commit the actual interface bandwidth.
	 * for the linkshare service curve, the sum of the child service
	 * curve should not exceed the parent service curve.
	 * for the upper-limit service curve, the assigned bandwidth should
	 * be smaller than the interface bandwidth, and the upper-limit should
	 * be larger than the real-time service curve when both are defined.
	 */
	parent = qname_to_pfaltq(pa->parent, pa->ifname);
	if (parent == NULL)
		errx(1, "parent %s not found for %s", pa->parent, pa->qname);

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;

		/* if the class has a real-time service curve, add it. */
		if (opts->rtsc_m2 != 0 && altq->pq_u.hfsc_opts.rtsc_m2 != 0) {
			sc.m1 = altq->pq_u.hfsc_opts.rtsc_m1;
			sc.d = altq->pq_u.hfsc_opts.rtsc_d;
			sc.m2 = altq->pq_u.hfsc_opts.rtsc_m2;
			gsc_add_sc(&rtsc, &sc);
		}

		if (strncmp(altq->parent, pa->parent, PF_QNAME_SIZE) != 0)
			continue;

		/* if the class has a linkshare service curve, add it. */
		if (opts->lssc_m2 != 0 && altq->pq_u.hfsc_opts.lssc_m2 != 0) {
			sc.m1 = altq->pq_u.hfsc_opts.lssc_m1;
			sc.d = altq->pq_u.hfsc_opts.lssc_d;
			sc.m2 = altq->pq_u.hfsc_opts.lssc_m2;
			gsc_add_sc(&lssc, &sc);
		}
	}

	/* check the real-time service curve.  reserve 20% of interface bw */
	if (opts->rtsc_m2 != 0) {
		/* add this queue to the sum */
		sc.m1 = opts->rtsc_m1;
		sc.d = opts->rtsc_d;
		sc.m2 = opts->rtsc_m2;
		gsc_add_sc(&rtsc, &sc);
		/* compare the sum with 80% of the interface */
		sc.m1 = 0;
		sc.d = 0;
		sc.m2 = pa->ifbandwidth / 100 * 80;
		if (!is_gsc_under_sc(&rtsc, &sc)) {
			warnx("real-time sc exceeds 80%% of the interface "
			    "bandwidth (%s)", rate2str((double)sc.m2));
			goto err_ret;
		}
	}

	/* check the linkshare service curve. */
	if (opts->lssc_m2 != 0) {
		/* add this queue to the child sum */
		sc.m1 = opts->lssc_m1;
		sc.d = opts->lssc_d;
		sc.m2 = opts->lssc_m2;
		gsc_add_sc(&lssc, &sc);
		/* compare the sum of the children with parent's sc */
		sc.m1 = parent->pq_u.hfsc_opts.lssc_m1;
		sc.d = parent->pq_u.hfsc_opts.lssc_d;
		sc.m2 = parent->pq_u.hfsc_opts.lssc_m2;
		if (!is_gsc_under_sc(&lssc, &sc)) {
			warnx("linkshare sc exceeds parent's sc");
			goto err_ret;
		}
	}

	/* check the upper-limit service curve. */
	if (opts->ulsc_m2 != 0) {
		if (opts->ulsc_m1 > pa->ifbandwidth ||
		    opts->ulsc_m2 > pa->ifbandwidth) {
			warnx("upper-limit larger than interface bandwidth");
			goto err_ret;
		}
		if (opts->rtsc_m2 != 0 && opts->rtsc_m2 > opts->ulsc_m2) {
			warnx("upper-limit sc smaller than real-time sc");
			goto err_ret;
		}
	}

	gsc_destroy(&rtsc);
	gsc_destroy(&lssc);

	return (0);

err_ret:
	gsc_destroy(&rtsc);
	gsc_destroy(&lssc);
	return (-1);
}

static int
check_commit_hfsc(int dev, int opts, struct pf_altq *pa)
{
	struct pf_altq	*altq, *def = NULL;
	int		 default_class;
	int		 error = 0;

	/* check if hfsc has one default queue for this interface */
	default_class = 0;
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (altq->parent[0] == 0)  /* dummy root */
			continue;
		if (altq->pq_u.hfsc_opts.flags & HFCF_DEFAULTCLASS) {
			default_class++;
			def = altq;
		}
	}
	if (default_class != 1) {
		warnx("should have one default queue on %s", pa->ifname);
		return (1);
	}
	/* make sure the default queue is a leaf */
	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(altq->ifname, pa->ifname, IFNAMSIZ) != 0)
			continue;
		if (altq->qname[0] == 0)  /* this is for interface */
			continue;
		if (strncmp(altq->parent, def->qname, PF_QNAME_SIZE) == 0) {
			warnx("default queue is not a leaf");
			error++;
		}
	}
	return (error);
}

static int
print_hfsc_opts(const struct pf_altq *a, const struct node_queue_opt *qopts)
{
	const struct hfsc_opts		*opts;
	const struct node_hfsc_sc	*rtsc, *lssc, *ulsc;

	opts = &a->pq_u.hfsc_opts;
	if (qopts == NULL)
		rtsc = lssc = ulsc = NULL;
	else {
		rtsc = &qopts->data.hfsc_opts.realtime;
		lssc = &qopts->data.hfsc_opts.linkshare;
		ulsc = &qopts->data.hfsc_opts.upperlimit;
	}

	if (opts->flags || opts->rtsc_m2 != 0 || opts->ulsc_m2 != 0 ||
	    (opts->lssc_m2 != 0 && (opts->lssc_m2 != a->bandwidth ||
	    opts->lssc_d != 0))) {
		printf("hfsc(");
		if (opts->flags & HFCF_RED)
			printf(" red");
		if (opts->flags & HFCF_ECN)
			printf(" ecn");
		if (opts->flags & HFCF_DEFAULTCLASS)
			printf(" default");
		if (opts->rtsc_m2 != 0)
			print_hfsc_sc("realtime", opts->rtsc_m1, opts->rtsc_d,
			    opts->rtsc_m2, rtsc);
		if (opts->lssc_m2 != 0 && (opts->lssc_m2 != a->bandwidth ||
		    opts->lssc_d != 0))
			print_hfsc_sc("linkshare", opts->lssc_m1, opts->lssc_d,
			    opts->lssc_m2, lssc);
		if (opts->ulsc_m2 != 0)
			print_hfsc_sc("upperlimit", opts->ulsc_m1, opts->ulsc_d,
			    opts->ulsc_m2, ulsc);
		printf(" ) ");

		return (1);
	} else
		return (0);
}

/*
 * admission control using generalized service curve
 */

/* add a new service curve to a generalized service curve */
static void
gsc_add_sc(struct gen_sc *gsc, struct service_curve *sc)
{
	if (is_sc_null(sc))
		return;
	if (sc->d != 0)
		gsc_add_seg(gsc, 0.0, 0.0, (double)sc->d, (double)sc->m1);
	gsc_add_seg(gsc, (double)sc->d, 0.0, INFINITY, (double)sc->m2);
}

/*
 * check whether all points of a generalized service curve have
 * their y-coordinates no larger than a given two-piece linear
 * service curve.
 */
static int
is_gsc_under_sc(struct gen_sc *gsc, struct service_curve *sc)
{
	struct segment	*s, *last, *end;
	double		 y;

	if (is_sc_null(sc)) {
		if (LIST_EMPTY(gsc))
			return (1);
		LIST_FOREACH(s, gsc, _next) {
			if (s->m != 0)
				return (0);
		}
		return (1);
	}
	/*
	 * gsc has a dummy entry at the end with x = INFINITY.
	 * loop through up to this dummy entry.
	 */
	end = gsc_getentry(gsc, INFINITY);
	if (end == NULL)
		return (1);
	last = NULL;
	for (s = LIST_FIRST(gsc); s != end; s = LIST_NEXT(s, _next)) {
		if (s->y > sc_x2y(sc, s->x))
			return (0);
		last = s;
	}
	/* last now holds the real last segment */
	if (last == NULL)
		return (1);
	if (last->m > sc->m2)
		return (0);
	if (last->x < sc->d && last->m > sc->m1) {
		y = last->y + (sc->d - last->x) * last->m;
		if (y > sc_x2y(sc, sc->d))
			return (0);
	}
	return (1);
}

static void
gsc_destroy(struct gen_sc *gsc)
{
	struct segment	*s;

	while ((s = LIST_FIRST(gsc)) != NULL) {
		LIST_REMOVE(s, _next);
		free(s);
	}
}

/*
 * return a segment entry starting at x.
 * if gsc has no entry starting at x, a new entry is created at x.
 */
static struct segment *
gsc_getentry(struct gen_sc *gsc, double x)
{
	struct segment	*new, *prev, *s;

	prev = NULL;
	LIST_FOREACH(s, gsc, _next) {
		if (s->x == x)
			return (s);	/* matching entry found */
		else if (s->x < x)
			prev = s;
		else
			break;
	}

	/* we have to create a new entry */
	if ((new = calloc(1, sizeof(struct segment))) == NULL)
		return (NULL);

	new->x = x;
	if (x == INFINITY || s == NULL)
		new->d = 0;
	else if (s->x == INFINITY)
		new->d = INFINITY;
	else
		new->d = s->x - x;
	if (prev == NULL) {
		/* insert the new entry at the head of the list */
		new->y = 0;
		new->m = 0;
		LIST_INSERT_HEAD(gsc, new, _next);
	} else {
		/*
		 * the start point intersects with the segment pointed by
		 * prev.  divide prev into 2 segments
		 */
		if (x == INFINITY) {
			prev->d = INFINITY;
			if (prev->m == 0)
				new->y = prev->y;
			else
				new->y = INFINITY;
		} else {
			prev->d = x - prev->x;
			new->y = prev->d * prev->m + prev->y;
		}
		new->m = prev->m;
		LIST_INSERT_AFTER(prev, new, _next);
	}
	return (new);
}

/* add a segment to a generalized service curve */
static int
gsc_add_seg(struct gen_sc *gsc, double x, double y, double d, double m)
{
	struct segment	*start, *end, *s;
	double		 x2;

	if (d == INFINITY)
		x2 = INFINITY;
	else
		x2 = x + d;
	start = gsc_getentry(gsc, x);
	end = gsc_getentry(gsc, x2);
	if (start == NULL || end == NULL)
		return (-1);

	for (s = start; s != end; s = LIST_NEXT(s, _next)) {
		s->m += m;
		s->y += y + (s->x - x) * m;
	}

	end = gsc_getentry(gsc, INFINITY);
	for (; s != end; s = LIST_NEXT(s, _next)) {
		s->y += m * d;
	}

	return (0);
}

/* get y-projection of a service curve */
static double
sc_x2y(struct service_curve *sc, double x)
{
	double	y;

	if (x <= (double)sc->d)
		/* y belongs to the 1st segment */
		y = x * (double)sc->m1;
	else
		/* y belongs to the 2nd segment */
		y = (double)sc->d * (double)sc->m1
			+ (x - (double)sc->d) * (double)sc->m2;
	return (y);
}

/*
 * misc utilities
 */
#define	R2S_BUFS	8
#define	RATESTR_MAX	16

char *
rate2str(double rate)
{
	char		*buf;
	static char	 r2sbuf[R2S_BUFS][RATESTR_MAX];  /* ring bufer */
	static int	 idx = 0;
	int		 i;
	static const char unit[] = " KMG";

	buf = r2sbuf[idx++];
	if (idx == R2S_BUFS)
		idx = 0;

	for (i = 0; rate >= 1000 && i <= 3; i++)
		rate /= 1000;

	if ((int)(rate * 100) % 100)
		snprintf(buf, RATESTR_MAX, "%.2f%cb", rate, unit[i]);
	else
		snprintf(buf, RATESTR_MAX, "%d%cb", (int)rate, unit[i]);

	return (buf);
}

u_int32_t
getifspeed(char *ifname)
{
	int		s;
	struct ifreq	ifr;
	struct if_data	ifrdat;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	bzero(&ifr, sizeof(ifr));
	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		errx(1, "getifspeed: strlcpy");
	ifr.ifr_data = (caddr_t)&ifrdat;
	if (ioctl(s, SIOCGIFDATA, (caddr_t)&ifr) == -1)
		err(1, "SIOCGIFDATA");
	if (close(s))
		err(1, "close");
	return ((u_int32_t)ifrdat.ifi_baudrate);
}

u_long
getifmtu(char *ifname)
{
	int		s;
	struct ifreq	ifr;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");
	bzero(&ifr, sizeof(ifr));
	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		errx(1, "getifmtu: strlcpy");
	if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == -1)
		err(1, "SIOCGIFMTU");
	if (close(s))
		err(1, "close");
	if (ifr.ifr_mtu > 0)
		return (ifr.ifr_mtu);
	else {
		warnx("could not get mtu for %s, assuming 1500", ifname);
		return (1500);
	}
}

int
eval_queue_opts(struct pf_altq *pa, struct node_queue_opt *opts,
    u_int32_t ref_bw)
{
	int	errors = 0;

	switch (pa->scheduler) {
	case ALTQT_CBQ:
		pa->pq_u.cbq_opts = opts->data.cbq_opts;
		break;
	case ALTQT_PRIQ:
		pa->pq_u.priq_opts = opts->data.priq_opts;
		break;
	case ALTQT_HFSC:
		pa->pq_u.hfsc_opts.flags = opts->data.hfsc_opts.flags;
		if (opts->data.hfsc_opts.linkshare.used) {
			pa->pq_u.hfsc_opts.lssc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.linkshare.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.lssc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.linkshare.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.lssc_d =
			    opts->data.hfsc_opts.linkshare.d;
		}
		if (opts->data.hfsc_opts.realtime.used) {
			pa->pq_u.hfsc_opts.rtsc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.realtime.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.rtsc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.realtime.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.rtsc_d =
			    opts->data.hfsc_opts.realtime.d;
		}
		if (opts->data.hfsc_opts.upperlimit.used) {
			pa->pq_u.hfsc_opts.ulsc_m1 =
			    eval_bwspec(&opts->data.hfsc_opts.upperlimit.m1,
			    ref_bw);
			pa->pq_u.hfsc_opts.ulsc_m2 =
			    eval_bwspec(&opts->data.hfsc_opts.upperlimit.m2,
			    ref_bw);
			pa->pq_u.hfsc_opts.ulsc_d =
			    opts->data.hfsc_opts.upperlimit.d;
		}
		break;
	default:
		warnx("eval_queue_opts: unknown scheduler type %u",
		    opts->qtype);
		errors++;
		break;
	}

	return (errors);
}

u_int32_t
eval_bwspec(struct node_queue_bw *bw, u_int32_t ref_bw)
{
	if (bw->bw_absolute > 0)
		return (bw->bw_absolute);

	if (bw->bw_percent > 0)
		return (ref_bw / 100 * bw->bw_percent);

	return (0);
}

void
print_hfsc_sc(const char *scname, u_int m1, u_int d, u_int m2,
    const struct node_hfsc_sc *sc)
{
	printf(" %s", scname);

	if (d != 0) {
		printf("(");
		if (sc != NULL && sc->m1.bw_percent > 0)
			printf("%u%%", sc->m1.bw_percent);
		else
			printf("%s", rate2str((double)m1));
		printf(" %u", d);
	}

	if (sc != NULL && sc->m2.bw_percent > 0)
		printf(" %u%%", sc->m2.bw_percent);
	else
		printf(" %s", rate2str((double)m2));

	if (d != 0)
		printf(")");
}
@


1.101
log
@Fix minor ident issue. OK benno@@, pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.100 2013/10/12 12:16:11 henning Exp $	*/
@


1.100
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.99 2013/03/20 00:18:00 deraadt Exp $	*/
d462 1
a462 2
			fprintf(stderr, "cbq: queue %s is too slow!\n",
			    pa->qname);
@


1.99
log
@MCLBYTES does not belong in here.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.98 2012/05/02 07:45:50 henning Exp $	*/
d184 1
a184 1
	printf("queue ");
@


1.98
log
@don't call getifmtu in -n mode, assume 1500. calling getifmtu requires
the interface in question to be there, breaking ruleset verification
From: Silamael <Silamael at coronamundi dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.97 2011/07/04 01:07:43 henning Exp $	*/
d408 2
a409 2
		if (opts->pktsize > MCLBYTES)	/* do what TCP does */
			opts->pktsize &= ~MCLBYTES;
@


1.97
log
@rip out more effectively dead code, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.96 2011/07/03 23:59:43 henning Exp $	*/
d247 6
a252 1
		size = size * getifmtu(pa->ifname);
d399 5
a403 1
	ifmtu = getifmtu(pa->ifname);
@


1.96
log
@g/c RIO traces (aka clean up after tedu :))
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.95 2011/07/03 23:46:23 henning Exp $	*/
a548 2
		if (opts->flags & CBQCLF_FLOWVALVE)
			printf(" flowvalve");
a552 2
		if (opts->flags & CBQCLF_EFFICIENT)
			printf(" efficient");
@


1.95
log
@*_CLEARDSCP could never possibly have been set, no point in being able to
print that as flag then
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.94 2008/07/25 17:43:44 martynas Exp $	*/
a548 2
		if (opts->flags & CBQCLF_RIO)
			printf(" rio");
a631 2
		if (opts->flags & PRCF_RIO)
			printf(" rio");
a843 2
		if (opts->flags & HFCF_RIO)
			printf(" rio");
@


1.94
log
@don't redefine INFINITY -- math.h defines it now
pointed out by, and ok david@@, go ahead henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.93 2007/10/15 02:16:35 deraadt Exp $	*/
a550 2
		if (opts->flags & CBQCLF_CLEARDSCP)
			printf(" cleardscp");
a635 2
		if (opts->flags & PRCF_CLEARDSCP)
			printf(" cleardscp");
a849 2
		if (opts->flags & HFCF_CLEARDSCP)
			printf(" cleardscp");
@


1.93
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.92 2007/05/27 05:15:17 claudio Exp $	*/
a877 1
#define	INFINITY	HUGE_VAL  /* positive infinity defined in <math.h> */
@


1.92
log
@No need to shutdown(2) DGRAM socket before closing it. Found while looking
at the code with jdixon@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.91 2006/11/28 00:08:50 henning Exp $	*/
d141 2
a142 2
print_altq(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw,
	struct node_queue_opt *qopts)
d178 3
a180 2
print_queue(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw,
    int print_interface, struct node_queue_opt *qopts)
d182 1
a182 1
	unsigned	i;
@


1.91
log
@fix servicecurve check; no point in checking the same sc three times, it
was obviously intended to check all three. has been wrong since the
beginning, 4 years... noticed by Earl Lapus <earl.lapus@@gmail.com>,
Vasil Dimov <vd@@FreeBSD.org> mailed me then, ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.90 2006/11/10 06:07:11 joel Exp $	*/
a1093 2
	if (shutdown(s, SHUT_RDWR) == -1)
		err(1, "shutdown");
a1112 2
	if (shutdown(s, SHUT_RDWR) == -1)
		err(1, "shutdown");
@


1.90
log
@Print the interface that each queue is bound to in the pfctl -sq output

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.89 2006/05/14 15:52:11 deraadt Exp $	*/
d683 2
a684 2
	    (opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0) ||
	    (opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0)) {
@


1.89
log
@better english to describe interfaces without bandwidth info; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.88 2006/04/08 02:04:48 ray Exp $	*/
d145 1
a145 1
		print_queue(a, level, bw, 0, qopts);
@


1.88
log
@Remove a little bit of dead code; minburst is set to 2 earlier, and
cannot be 0.

From NetBSD from Coverity CID 577.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.87 2006/01/28 18:54:28 henning Exp $	*/
d226 2
a227 2
			fprintf(stderr, "cannot determine interface bandwidth "
			    "for %s, specify an absolute bandwidth\n",
@


1.87
log
@zap unused function
From: Andrey Matveev <evol@@online.ptt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.86 2005/02/28 14:04:51 henning Exp $	*/
d478 1
a478 4
	if (minburst)
		offtime = cptime * (1.0 + 1.0/(1.0 - g) * (1.0 - gtom) / gtom);
	else
		offtime = cptime;
@


1.86
log
@use the linkshar keyword when gtalking about the link sharing service
curve, inspired by PR4127
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.85 2004/05/20 12:18:52 henning Exp $	*/
a93 15
}

void
pfaltq_free(struct pf_altq *a)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(a->ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    strncmp(a->qname, altq->qname, PF_QNAME_SIZE) == 0) {
			TAILQ_REMOVE(&altqs, altq, entries);
			free(altq);
			return;
		}
	}
@


1.85
log
@bzero() ifr before use, From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.84 2004/04/26 02:50:04 kjc Exp $	*/
d712 1
a712 1
	 * for the link-sharing service curve, the sum of the child service
d739 1
a739 1
		/* if the class has a link-sharing service curve, add it. */
d766 1
a766 1
	/* check the link-sharing service curve. */
d778 1
a778 1
			warnx("link-sharing sc exceeds parent's sc");
@


1.84
log
@do more careful altq bandwidth checking.
- fix a bug in HFSC that does not take the newly added
queue into account when computing the bandwidth for
admission control.
- warn when the sum of the child bandwidth exceeds
parent's bandwidth for both CBQ and HFSC.
- allow to explicitly specify 0bps to bandwidth.
HFSC can have only the real-time sc, and it means
a blackhole queue for CBQ.

problem reports by "Alexey E. Suslikov" <cruel@@texnika.com.ua>

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.83 2004/03/14 21:51:44 dhartmei Exp $	*/
d1105 1
d1127 1
@


1.83
log
@#include fixes, from Max Laier, ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.82 2004/02/19 07:44:00 kjc Exp $	*/
d307 2
a308 1
	struct pf_altq	*if_pa, *parent;
d340 2
a341 6
		if ((pa->bandwidth = eval_bwspec(bw,
		    parent == NULL ? 0 : parent->bandwidth)) == 0) {
			fprintf(stderr, "bandwidth for %s invalid (%d / %d)\n",
			    pa->qname, bw->bw_absolute, bw->bw_percent);
			return (1);
		}
d348 21
a368 4
		if (parent != NULL && pa->bandwidth > parent->bandwidth) {
			fprintf(stderr, "bandwidth for %s higher than parent\n",
			    pa->qname);
			return (1);
d750 6
d760 2
a761 1
			warnx("real-time sc exceeds the interface bandwidth");
d768 6
@


1.82
log
@now that qids are managed entirely in the kernel, the qid related code
is no longer needed in pfctl.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.81 2004/02/10 22:26:56 dhartmei Exp $	*/
a23 1
#include <sys/limits.h>
d31 1
@


1.81
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.80 2004/02/10 17:53:37 henning Exp $	*/
a84 2
static u_int32_t	 max_qid = 0;

a412 2
	if (pa->qid == 0)
		pa->qid = ++max_qid;
a596 3
	if (pa->qid == 0)
		pa->qid = ++max_qid;

a663 2
	if (pa->qid == 0)
		pa->qid = ++max_qid;
@


1.80
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.79 2004/01/14 08:42:23 kjc Exp $	*/
d726 1
a726 1
			sc.d  = altq->pq_u.hfsc_opts.rtsc_d;
d737 1
a737 1
			sc.d  = altq->pq_u.hfsc_opts.lssc_d;
d746 1
a746 1
		sc.d  = 0;
d757 1
a757 1
		sc.d  = parent->pq_u.hfsc_opts.lssc_d;
d1015 1
a1015 1
	end   = gsc_getentry(gsc, x2);
@


1.79
log
@eliminate the predefined special qids so that qids become simple
identifiers without embedded meanings.

this also allows us to make the semantics of the qid assignment in line
with the tag assignment in the next step.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.78 2003/10/21 21:09:13 itojun Exp $	*/
d168 1
a168 1
	switch(a->scheduler) {
d490 6
a495 3
	maxidle = ((maxidle * 8.0) / nsPerByte) * pow(2.0, (double)RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte * pow(2.0, (double)RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) * pow(2.0, (double)RM_FILTER_GAIN);
d503 2
a504 2
	opts->ns_per_byte = (u_int) nsPerByte;
	opts->maxidle = (u_int) fabs(maxidle);
d506 1
a506 1
	opts->offtime = (u_int) fabs(offtime);
@


1.78
log
@don't use NULL as (int)0.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.77 2003/08/22 21:50:34 david Exp $	*/
d85 1
a85 1
static u_int32_t	 max_qid = 1;
d264 2
d415 1
a415 1
	else if (pa->qid == 0 && (opts->flags & CBQCLF_DEFCLASS) == 0)
d668 2
a671 1
		pa->qid = HFSC_ROOTCLASS_HANDLE;
d676 1
a676 2
	} else if (pa->qid == 0)
		pa->qid = ++max_qid;
@


1.77
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.76 2003/08/20 13:03:35 henning Exp $	*/
d161 1
a161 1
	if (a->qname[0] != NULL) {
@


1.76
log
@catch invalid CBQ priorities earlier, including a better error message
prodded by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.75 2003/06/20 16:53:48 deraadt Exp $	*/
d874 1
a874 1
/* add a new service curve to a generilized service curve */
@


1.75
log
@some cleanings recommended by lint; dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.74 2003/06/06 17:53:05 henning Exp $	*/
d388 5
@


1.74
log
@simplify license. pfctl_altq.c with kenjiro's permission of course.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.73 2003/05/08 22:09:54 dhartmei Exp $	*/
d483 3
a485 3
	maxidle = ((maxidle * 8.0) / nsPerByte) * pow(2, RM_FILTER_GAIN);
	offtime = (offtime * 8.0) / nsPerByte * pow(2, RM_FILTER_GAIN);
	minidle = ((minidle * 8.0) / nsPerByte) * pow(2, RM_FILTER_GAIN);
d876 2
a877 2
		gsc_add_seg(gsc, 0, 0, (double)sc->d, (double)sc->m1);
	gsc_add_seg(gsc, (double)sc->d, 0, INFINITY, (double)sc->m2);
@


1.73
log
@Close sockets (otherwise the file handle limit can be reached when many
queues are defined). Reported by Fernando Braga. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.72 2003/04/15 11:29:24 henning Exp $	*/
d4 3
a6 3
 * Copyright (C) 2002
 *	Sony Computer Science Laboratories Inc.  All rights reserved.
 * Copyright (C) 2002, 2003 Henning Brauer. All rights reserved.
d8 3
a10 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d12 7
a18 11
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.72
log
@pass down the unparsed queue opts (struct node_queue_opt) to
print_altq/print_hfsc -> print_hfsc_opts and extract struct node_hfsc_sc
there for each service curve and pass those down to print_hfsc_sc. now
bandwidth specifications in the service curves are printed correct in the
case of a queue belonging to more than one interface/parent queue, the
parent queues having different bandwidths and the bandwith on teh service
curve beeing specified in percent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.71 2003/04/15 11:01:34 henning Exp $	*/
d1094 2
d1114 2
@


1.71
log
@make print_hfsc_sc() take an extra struct node_hfsc_sc parameter and print
relative bandwidth specification if that ws given instead of the calculated
absolute ones. to be used soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.69 2003/04/15 10:20:19 henning Exp $	*/
d74 2
a75 1
static int	print_hfsc_opts(const struct pf_altq *);
d91 2
a92 2
void		 print_hfsc_sc(char *, u_int, u_int, u_int,
		     struct node_hfsc_sc *);
d167 2
a168 1
print_altq(const struct pf_altq *a, unsigned level, struct node_queue_bw *bw)
d171 1
a171 1
		print_queue(a, level, bw, 0);
d187 1
a187 1
		if (!print_hfsc_opts(a))
d205 1
a205 1
    int print_interface)
d234 1
a234 1
		print_hfsc_opts(a);
d828 1
a828 1
print_hfsc_opts(const struct pf_altq *a)
d830 2
a831 1
	const struct hfsc_opts	*opts;
d834 7
d858 1
a858 1
			    opts->rtsc_m2, NULL);
d862 1
a862 1
			    opts->lssc_m2, NULL);
d865 1
a865 1
			    opts->ulsc_m2, NULL);
d1189 2
a1190 2
print_hfsc_sc(char *scname, u_int m1, u_int d, u_int m2,
    struct node_hfsc_sc *sc)
@


1.70
log
@don't include the unit "ms" when printing the service curve; parser wants
raw number
@
text
@d90 2
a91 1
void		 print_hfsc_sc(char *, u_int, u_int, u_int);
d848 1
a848 1
			    opts->rtsc_m2);
d852 1
a852 1
			    opts->lssc_m2);
d855 1
a855 1
			    opts->ulsc_m2);
d1179 2
a1180 1
print_hfsc_sc(char *scname, u_int m1, u_int d, u_int m2)
d1182 18
a1199 7
			if (d != 0)
				printf(" %s(%s %u %s)", scname,
				    rate2str((double)m1), d,
				    rate2str((double)m2));
			else
				printf(" %s %s", scname,
				    rate2str((double)m2));
@


1.69
log
@factor out service curve printing to it's own function, print_hfsc_sc().
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.68 2003/04/14 16:51:36 henning Exp $	*/
d1181 1
a1181 1
				printf(" %s(%s %ums %s)", scname,
@


1.68
log
@if linkshare service curve m2 == bandwidth, but d given, we do need to print
linkshare as it is not exactly the default case then
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.67 2003/04/14 16:35:13 henning Exp $	*/
d90 1
d845 3
a847 10
		if (opts->rtsc_m2 != 0) {
			if (opts->rtsc_d != 0)
				printf(" realtime(%s %ums %s)",
				    rate2str((double)opts->rtsc_m1),
				    opts->rtsc_d,
				    rate2str((double)opts->rtsc_m2));
			else
				printf(" realtime %s",
				    rate2str((double)opts->rtsc_m2));
		}
d849 6
a854 20
		    opts->lssc_d != 0)) {
			if (opts->lssc_d != 0)
				printf(" linkshare(%s %ums %s)",
				    rate2str((double)opts->lssc_m1),
				    opts->lssc_d,
				    rate2str((double)opts->lssc_m2));
			else
				printf(" linkshare %s",
				    rate2str((double)opts->lssc_m2));
		}
		if (opts->ulsc_m2 != 0) {
			if (opts->ulsc_d != 0)
				printf(" upperlimit(%s %ums %s)",
				    rate2str((double)opts->ulsc_m1),
				    opts->ulsc_d,
				    rate2str((double)opts->ulsc_m2));
				else
					printf(" upperlimit %s",
					    rate2str((double)opts->ulsc_m2));
		}
d1175 12
@


1.67
log
@only print hfsc linkshare when it differs from the default
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.66 2003/04/14 15:50:53 kjc Exp $	*/
d832 1
a832 1
	    (opts->lssc_m2 != a->bandwidth && opts->lssc_m1 != 0)))) {
d855 1
a855 1
		    (opts->lssc_m2 != a->bandwidth && opts->lssc_m1 != 0))) {
@


1.66
log
@do not add a realtime service curve to the root queue as
the realtime service is not hierarchically distributed.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.65 2003/04/14 14:50:46 henning Exp $	*/
d830 3
a832 2
	if (opts->flags || opts->rtsc_m2 != 0 || opts->lssc_m2 != 0 ||
	    opts->ulsc_m2 != 0) {
d854 2
a855 1
		if (opts->lssc_m2 != 0) {
@


1.65
log
@let print_altq and print_queue take a struct node_queue_bw parameter instead
of dintinct bw_percent
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.64 2003/04/13 23:22:05 henning Exp $	*/
a668 3
		opts->rtsc_m1 = pa->ifbandwidth;
		opts->rtsc_m2 = pa->ifbandwidth;
		opts->rtsc_d = 0;
@


1.64
log
@concistency in the print-funtions, here: HFSC uppercurve and brackets
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.63 2003/04/13 22:03:18 henning Exp $	*/
d164 1
a164 1
print_altq(const struct pf_altq *a, unsigned level, u_int16_t bwpercent)
d167 1
a167 1
		print_queue(a, level, bwpercent, 0);
d188 3
a190 3
	if (bwpercent > 0) {
		if (bwpercent < 100)
			printf("bandwidth %u%% ", bwpercent);
d193 1
d200 1
a200 1
print_queue(const struct pf_altq *a, unsigned level, u_int16_t bwpercent,
d212 3
a214 3
		if (bwpercent > 0) {
			if (bwpercent < 100)
				printf("bandwidth %u%% ", bwpercent);
@


1.63
log
@use pa->ifbandwidth instead of rate as reference bandwidth for the root queue
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.62 2003/04/13 21:44:42 henning Exp $	*/
d872 1
a872 1
					printf(" upperlimit(%s)",
@


1.62
log
@process HFSC options for the linkshare, realtime and upperlimit service curves
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.61 2003/04/13 20:55:50 henning Exp $	*/
d254 1
a254 1
	errors += eval_queue_opts(pa, opts, rate);
@


1.61
log
@break out bandwidth specification processing code to its own function, will
be used in more places soonish
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.60 2003/04/13 20:16:06 henning Exp $	*/
d1144 30
@


1.60
log
@pass down the struct node_queue_opts from the altqif/queuespec yacc targets
to expand_altq/expand_queue -> eval_pfaltq/eval_pfqueue and
further down to the new eval_queue_opts() instead of evaluating them directly
in the yacc grammar.
this will be needed to process the hfsc options which can contain relative
bandwidth specifications, and we can't break them down to an absolute one
earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.59 2003/04/13 19:36:00 henning Exp $	*/
d89 1
d251 2
a252 5
		} else
			if (bw->bw_percent > 0)
				pa->ifbandwidth = rate / 100 * bw->bw_percent;
			else
				pa->ifbandwidth = rate;
d343 2
a344 6
		if (bw->bw_absolute > 0)
			pa->bandwidth = bw->bw_absolute;
		else if (bw->bw_percent > 0 && parent != NULL)
			pa->bandwidth = parent->bandwidth / 100 *
			    bw->bw_percent;
		else {
d1153 12
@


1.59
log
@move the structs node_queue_bw and node_queue_opt to pfctl_parser.h.
let eval_pfqueue() and eval_pfaltq() take a pointer to a struct
node_queue_bw instead of two distince bw_absolute and bw_percent parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.58 2003/04/12 19:08:40 henning Exp $	*/
d87 2
d237 2
a238 1
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw)
d256 2
d309 2
a310 1
eval_pfqueue(struct pfctl *pf, struct pf_altq *pa, struct node_queue_bw *bw)
d368 3
d1133 26
@


1.58
log
@make the first queue id we assign 2 instead of 1, 1 is the default queue for
HFSC
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.57 2003/04/12 19:07:42 henning Exp $	*/
d235 1
a235 2
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa, u_int32_t bw_absolute,
    u_int16_t bw_percent)
d239 2
a240 2
	if (bw_absolute > 0)
		pa->ifbandwidth = bw_absolute;
d248 2
a249 2
			if (bw_percent > 0)
				pa->ifbandwidth = rate / 100 * bw_percent;
d304 1
a304 2
eval_pfqueue(struct pfctl *pf, struct pf_altq *pa, u_int32_t bw_absolute,
    u_int16_t bw_percent)
d339 5
a343 4
		if (bw_absolute > 0)
			pa->bandwidth = bw_absolute;
		else if (bw_percent > 0 && parent != NULL)
			pa->bandwidth = parent->bandwidth / 100 * bw_percent;
d346 1
a346 1
			    pa->qname, bw_absolute, bw_percent);
@


1.57
log
@in check_commit_hfsc, don't check wether the default queue is a leaf queue
when we have no default queue. avoids null pointer deref.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.56 2003/04/12 19:05:57 henning Exp $	*/
d88 1
a88 1
static u_int32_t	 max_qid = 0;
@


1.56
log
@correctly make up the root queue in eval_pfqueue_hfsc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.55 2003/04/12 16:44:19 henning Exp $	*/
d807 1
a807 1
		error++;
@


1.55
log
@make print_*_opts() int instead of void where the return value indicates
wether it printed something or not, and use that to decide wether to print
the scheduler name in the altq on .. case instead of checking flags again,
which would be a horrible mess for hfsc with its tons of opts (checking
flags is not enough there)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.54 2003/04/12 16:39:01 henning Exp $	*/
d661 2
d664 1
a664 1
		/* this is for dummy root */
d666 6
a671 1
		pa->pq_u.hfsc_opts.lssc_m2 = pa->ifbandwidth;
a675 1
	opts = &pa->pq_u.hfsc_opts;
@


1.54
log
@fix print_hfsc_opts to only print "hfsc( " and " )" when there are opts to
print, so it behaves like the print_*_opts for the other schedulers
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.53 2003/04/12 15:09:57 henning Exp $	*/
d66 1
a66 1
static void	print_cbq_opts(const struct pf_altq *);
d70 1
a70 1
static void	print_priq_opts(const struct pf_altq *);
d74 1
a74 1
static void	print_hfsc_opts(const struct pf_altq *);
d172 1
a172 2
		print_cbq_opts(a);
		if (!a->pq_u.cbq_opts.flags)
d176 1
a176 2
		print_priq_opts(a);
		if (!a->pq_u.priq_opts.flags)
d180 1
a180 2
		print_hfsc_opts(a);
		if (!a->pq_u.hfsc_opts.flags)
d536 1
a536 1
static void
d565 4
a568 1
	}
d625 1
a625 1
static void
d645 4
a648 1
	}
d817 1
a817 1
static void
d868 4
a871 1
	}
@


1.53
log
@assign queue IDs for HFSC simimar to what we do for PRIQ and CBQ
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.52 2003/04/11 15:18:33 henning Exp $	*/
d821 29
a849 34
	printf("hfsc(");
	if (opts->flags & HFCF_RED)
		printf(" red");
	if (opts->flags & HFCF_ECN)
		printf(" ecn");
	if (opts->flags & HFCF_RIO)
		printf(" rio");
	if (opts->flags & HFCF_CLEARDSCP)
		printf(" cleardscp");
	if (opts->flags & HFCF_DEFAULTCLASS)
		printf(" default");
	if (opts->rtsc_m2 != 0) {
		if (opts->rtsc_d != 0)
			printf(" realtime(%s %ums %s)",
			    rate2str((double)opts->rtsc_m1), opts->rtsc_d,
			    rate2str((double)opts->rtsc_m2));
		else
			printf(" realtime %s",
			    rate2str((double)opts->rtsc_m2));
	}
	if (opts->lssc_m2 != 0) {
		if (opts->lssc_d != 0)
			printf(" linkshare(%s %ums %s)",
			    rate2str((double)opts->lssc_m1), opts->lssc_d,
			    rate2str((double)opts->lssc_m2));
		else
			printf(" linkshare %s",
			    rate2str((double)opts->lssc_m2));
	}
	if (opts->ulsc_m2 != 0) {
		if (opts->ulsc_d != 0)
			printf(" upperlimit(%s %ums %s)",
			    rate2str((double)opts->ulsc_m1), opts->ulsc_d,
			    rate2str((double)opts->ulsc_m2));
d851 8
a858 1
				printf(" upperlimit(%s)",
d860 5
a865 1
	printf(" ) ");
@


1.52
log
@qname_to_qid and qname_to_pfaltq can be private functions now; nothing
outside pfctl_altq.c uses them any more, nor should.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.51 2003/04/11 15:13:34 henning Exp $	*/
d663 2
a664 1
	}
@


1.51
log
@kill dead code.
qid_to_qname is not used anywhere. moreover, I cannot think of any
legitimate use; misuse is easy tho.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.50 2003/04/05 21:44:46 henning Exp $	*/
d59 3
@


1.50
log
@allow queue specs to be limited to certain interfaces.

altq on { $if0 $if1 $if2 $if3 } priq bandwidth 10Mb queue { one two }
queue one priority 1 priq(default)
queue two on $if0 priority 15
queue two on ! $if0 priority 0

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.49 2003/04/03 14:41:46 henning Exp $	*/
a154 13
}

char *
qid_to_qname(u_int32_t qid, const char *ifname)
{
	struct pf_altq	*altq;

	TAILQ_FOREACH(altq, &altqs, entries) {
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
		    altq->qid == qid)
			return (altq->qname);
	}
	return (NULL);
@


1.49
log
@use a simple linear queue ID assignment algorithm for PRIQ like we do for
cbq already.
together with the previous change that means it is now possible to have
differently named priq queues on different interfaces with the same
priorities and packets end up in the right queues.

ok dhartmei@@ kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.48 2003/04/03 05:08:59 kjc Exp $	*/
d174 1
a174 1
		print_queue(a, level, bwpercent);
d209 2
a210 1
print_queue(const struct pf_altq *a, unsigned level, u_int16_t bwpercent)
d218 2
@


1.48
log
@explicitly include <sys/limits.h> for INT_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.47 2003/03/28 16:47:39 henning Exp $	*/
d600 2
a601 2
	/* qid is tied to priority with priq */
	pa->qid = pa->priority + 1;
@


1.47
log
@assign qid early for priq too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.46 2003/03/11 14:02:12 henning Exp $	*/
d33 1
@


1.46
log
@do the queue ID assignment for cbq already in userland. ensure that queues
with different names always have different queue IDs, even if they live on
different interfaces (that was the goal here).
fixes regress pfaltq4

ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.45 2003/03/10 14:54:17 henning Exp $	*/
d598 3
@


1.45
log
@check for multiple same named queues on one interface.
before this was rejected at load time with a rather useless error message,
now a nice error message points out the actual error.

inspired by an error report from Damien Miller

ok dhartmei@@ pb@@ (monsterdiff complete)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.43 2003/03/08 14:40:03 henning Exp $	*/
d84 2
d419 2
@


1.44
log
@rework error handling in eval_pfqueue().
instead of using errx, print the error message and return. This is
consistent with what we do everywhere in pfctl.

ok dhartmei@@ pb@@ (as part of a monsterdiff)
@
text
@d326 6
@


1.43
log
@when complaining about a queue's abndwidth beeing to small (below the
resolution we can handle), don't say it must be >6KB, the value actually
depends on quite some factors, including interface MTU. Instead, calculate
the real minimum value and show that.

mpech@@ did a good job in bugging me to fix that ;-)

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.42 2003/03/06 12:50:40 henning Exp $	*/
d320 4
a323 3
	if_pa = pfaltq_lookup(pa->ifname);
	if (if_pa == NULL)
		errx(1, "altq not defined on %s", pa->ifname);
d331 2
a332 2
		if (parent == NULL)
			errx(1, "parent %s not found for %s",
d334 2
d346 5
a350 3
		else
			errx(1, "bandwidth for %s invalid (%d / %d)", pa->qname,
			    bw_absolute, bw_percent);
d352 7
a358 5
		if (pa->bandwidth > pa->ifbandwidth)
			errx(1, "bandwidth for %s higher than interface",
			    pa->qname);
		if (parent != NULL && pa->bandwidth > parent->bandwidth)
			errx(1, "bandwidth for %s higher than parent",
d360 2
@


1.42
log
@fix queue assignment on filter rules which are not bound to an interface.
when looking up the queue IDs using qname_to_qid, we do not need to limit
the matching on the interface in question, as it is guaranteed that same
named queues on different interfaces habe the same queue id. moreover, we
must not limit the matches to the interface if we do not have an interface
given on the filter rule to match on ;-)

found after problems reported by Andre Nathan <andre at v2r dot com dot br>

ok dhartmei@@ pb@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.41 2003/03/03 14:16:18 henning Exp $	*/
d439 3
a441 1
			warnx("queue bandwidth must be larger than 6Kb");
@


1.41
log
@rate2str() overhaul:
-do not print 100.00Kb but 100Kb, but still 1.50Mb. requested by theo. hint
 by dhartmei lead to a easier algorithm than initially had
-while beeing there, use a much nicer, shorter algorithm for determining
 and printing the unit. a little further easification thanks to a hint by
 markus@@

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.40 2003/03/02 23:37:24 henning Exp $	*/
d137 1
a137 1
qname_to_qid(const char *qname, const char *ifname)
d141 6
d148 1
a148 3
		if ((ifname == NULL ||
		    strncmp(ifname, altq->ifname, IFNAMSIZ) == 0) &&
		    strncmp(qname, altq->qname, PF_QNAME_SIZE) == 0)
d325 1
a325 1
	pa->qid = qname_to_qid(pa->qname, NULL);
@


1.40
log
@when printing queues at load time that have bandwidth specified in percent,
print the bandwidth in percent instead of the calculated absolute value.
if a queue belongs to more than one interface and they have different
bandwidth the calculated absolute is of course different per interface.
previously the first calculated absolute value was shown; what of course is
incorrect on the second interface. note that only the print was wrong, the
correct values were passed to the kernel.

ok theo daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.39 2003/03/02 12:37:49 henning Exp $	*/
d1025 2
d1032 5
a1036 9
	if (rate == 0.0)
		snprintf(buf, RATESTR_MAX, "0b");
	else if (rate >= 1000 * 1000 * 1000)
		snprintf(buf, RATESTR_MAX, "%.2fGb",
		    rate / (1000.0 * 1000.0 * 1000.0));
	else if (rate >= 1000 * 1000)
		snprintf(buf, RATESTR_MAX, "%.2fMb", rate / (1000.0 * 1000.0));
	else if (rate >= 1000)
		snprintf(buf, RATESTR_MAX, "%.2fKb", rate / 1000.0);
d1038 2
a1039 1
		snprintf(buf, RATESTR_MAX, "%db", (int)rate);
@


1.39
log
@remove the control keyword for cbq queues.
the control class was a legacy of the original CBQ design by LBL/Sun
to support RSVP.
the control class is not used in openbsd, in the sense that
we don't automatically set filters for ICMP/IGMP/RSVP for the control
class.

ok dhartmei@@ kjc@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.38 2003/03/02 11:24:58 henning Exp $	*/
d164 1
a164 1
print_altq(const struct pf_altq *a, unsigned level)
d167 1
a167 1
		print_queue(a, level);
d191 5
a195 1
	printf("bandwidth %s ", rate2str((double)a->ifbandwidth));
d202 1
a202 1
print_queue(const struct pf_altq *a, unsigned level)
d210 7
a216 2
	if (a->scheduler == ALTQT_CBQ || a->scheduler == ALTQT_HFSC)
		printf("bandwidth %s ", rate2str((double)a->bandwidth));
@


1.38
log
@add a guarantee that two same named queues on different interfaces have the
same queue id. in the usual case this was already true, but not guaranteed.

ok dhartmei@@ kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.37 2003/02/25 12:03:02 henning Exp $	*/
a538 2
		if (opts->flags & CBQCLF_CTLCLASS)
			printf(" control");
@


1.37
log
@extend copyright to 2003
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.36 2003/01/24 11:37:24 henning Exp $	*/
d142 2
a143 1
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0 &&
d312 1
@


1.36
log
@make rate2str include the unit in the ouput even if it is 0b. was irrelevant
before as you cannot specify "bandwidth 0b" on a rule; now that rate2str is
used for the stats output it does matter.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.35 2003/01/24 10:53:32 henning Exp $	*/
d6 1
a6 1
 * Copyright (C) 2002 Henning Brauer. All rights reserved.
@


1.35
log
@export rate2str
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.34 2003/01/20 19:07:50 henning Exp $	*/
d1022 1
a1022 1
		snprintf(buf, RATESTR_MAX, "0");
@


1.34
log
@unused var; found by dhartmei@@ and camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.33 2003/01/20 19:05:46 camield Exp $	*/
a80 1
static char	*rate2str(double);
d1010 1
a1010 1
static char *
@


1.33
log
@no named parameters in prototypes

ok dhartmei cedric henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.32 2003/01/09 18:55:32 dhartmei Exp $	*/
d402 1
a402 1
	double		 z, g, f, gton, gtom, maxrate;
a416 1
	maxrate = f * ((double)pa->ifbandwidth / 8.0);
@


1.32
log
@strlcpy return checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.31 2003/01/09 17:33:19 henning Exp $	*/
d59 1
a59 1
static int	eval_pfqueue_cbq(struct pfctl *pf, struct pf_altq *);
d64 1
a64 1
static int	eval_pfqueue_priq(struct pfctl *pf, struct pf_altq *);
d68 1
a68 1
static int	eval_pfqueue_hfsc(struct pfctl *pf, struct pf_altq *);
@


1.31
log
@first attack at pfctl queue statistics, to be displayed with pfctl -vsq

This commit is dedicated to the cute KLM girls who made part of this
possible with giving me a seat in the plane where you actually have enough
place to hack. Thanks, girls.

ok markus@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.30 2003/01/05 02:17:09 dhartmei Exp $	*/
d1046 3
a1048 1
	strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
d1065 3
a1067 1
	strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
@


1.30
log
@err()/errx() do not return, errx() -> err() after calloc(), it sets errno.
From Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.29 2003/01/04 00:01:34 deraadt Exp $	*/
a1003 98
}

void
pfctl_insert_altq_node(struct pf_altq_node **root,
    const struct pf_altq altq)
{
	struct pf_altq_node	*node;

	node = calloc(1, sizeof(struct pf_altq_node));
	if (node == NULL)
		err(1, "pfctl_insert_altq_node: calloc");
	memcpy(&node->altq, &altq, sizeof(struct pf_altq));
	node->next = node->children = NULL;

	if (*root == NULL)
		*root = node;
	else if (!altq.parent[0]) {
		struct pf_altq_node *prev = *root;

		while (prev->next != NULL)
			prev = prev->next;
		prev->next = node;
	} else {
		struct pf_altq_node *parent;

		parent = pfctl_find_altq_node(*root, altq.parent, altq.ifname);
		if (parent == NULL)
			errx(1, "parent %s not found", altq.parent);
		if (parent->children == NULL)
			parent->children = node;
		else {
			struct pf_altq_node *prev = parent->children;

			while (prev->next != NULL)
				prev = prev->next;
			prev->next = node;
		}
	}
}

struct pf_altq_node *
pfctl_find_altq_node(struct pf_altq_node *root, const char *qname,
    const char *ifname)
{
	struct pf_altq_node	*node, *child;

	for (node = root; node != NULL; node = node->next) {
		if (!strcmp(node->altq.qname, qname) &&
		    !(strcmp(node->altq.ifname, ifname)))
			return (node);
		if (node->children != NULL) {
			child = pfctl_find_altq_node(node->children, qname,
			    ifname);
			if (child != NULL)
				return (child);
		}
	}
	return (NULL);
}

void
pfctl_print_altq_node(const struct pf_altq_node *node, unsigned level)
{
	const struct pf_altq_node	*child;

	if (node == NULL)
		return;

	print_altq(&node->altq, level);

	if (node->children != NULL) {
		printf("{");
		for (child = node->children; child != NULL;
		    child = child->next) {
			printf("%s", child->altq.qname);
			if (child->next != NULL)
				printf(", ");
		}
		printf("}");
	}
	printf("\n");
	for (child = node->children; child != NULL;
	    child = child->next)
		pfctl_print_altq_node(child, level+1);
}

void
pfctl_free_altq_node(struct pf_altq_node *node)
{
	while (node != NULL) {
		struct pf_altq_node *prev;

		if (node->children != NULL)
			pfctl_free_altq_node(node->children);
		prev = node;
		node = node->next;
		free(prev);
	}
@


1.29
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.28 2003/01/03 21:48:21 deraadt Exp $	*/
d1013 2
a1014 4
	if (node == NULL) {
		errx(1, "pfctl_insert_altq_node: calloc");
		return;
	}
d1030 1
a1030 1
		if (parent == NULL) {
a1031 2
			return;
		}
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.27 2002/12/24 13:29:13 mcbride Exp $	*/
d52 1
a52 1
#include "pfctl_altq.h"
@


1.27
log
@print_cbq_opts should print "control" if CBQCLF_CTLCLASS is set.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.26 2002/12/23 15:56:24 henning Exp $	*/
d1055 2
a1056 2
		if (!strcmp(node->altq.qname, qname)
		    && !(strcmp(node->altq.ifname, ifname)))
@


1.26
log
@remove dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.25 2002/12/17 20:06:05 henning Exp $	*/
d539 2
@


1.25
log
@add support for the PRIQ scheduler

partitially from kjc@@

ok kjc@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.24 2002/12/17 11:29:04 henning Exp $	*/
a516 9

/*	printf("  cbq options: minburst %u maxburst %u"
	    " pktsize %u maxpktsize %u\n",
	    opts->minburst, opts->maxburst,
	    opts->pktsize, opts->maxpktsize);
	printf("        ns_per_byte %u maxidle %u minidle %d offtime %u\n",
	    opts->ns_per_byte, opts->maxidle, opts->minidle, opts->offtime);
*/

@


1.24
log
@PRIQ and HFSC support functions, not yet used.
mostly from kjc@@ with adjustments by me.

ok theo ryan daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.23 2002/12/17 01:15:59 henning Exp $	*/
d206 2
a207 1
	printf("bandwidth %s ", rate2str((double)a->bandwidth));
d324 8
a331 7
	if (bw_absolute > 0)
		pa->bandwidth = bw_absolute;
	else if (bw_percent > 0 && parent != NULL)
		pa->bandwidth = parent->bandwidth / 100 * bw_percent;
	else
		errx(1, "bandwidth for %s invalid (%d / %d)", pa->qname,
		    bw_absolute, bw_percent);
d333 7
a339 4
	if (pa->bandwidth > pa->ifbandwidth)
		errx(1, "bandwidth for %s higher than interface", pa->qname);
	if (parent != NULL && pa->bandwidth > parent->bandwidth)
		errx(1, "bandwidth for %s higher than parent", pa->qname);
a559 4
	if (pa->parent[0] == 0)
		/* this is for dummy root */
		return (0);

d567 1
a567 2
		    altq->qname[0] != 0 && altq->parent[0] != 0 &&
		    altq->priority == pa->priority) {
a573 3
	if (pa->bandwidth != pa->ifbandwidth)
		warnx("priq does not have a bandwidth parameter -- ignored");

a591 2
			continue;
		if (altq->parent[0] == 0)  /* dummy root */
@


1.23
log
@class -> queue
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.22 2002/12/17 00:00:08 henning Exp $	*/
d48 2
d54 27
a80 4
static int	 eval_pfqueue_cbq(struct pfctl *pf, struct pf_altq *);
static int	 cbq_compute_idletime(struct pfctl *, struct pf_altq *);
static int	 check_commit_cbq(int, int, struct pf_altq *);
static void	 print_cbq_opts(const struct pf_altq *);
a84 2
TAILQ_HEAD(altqs, pf_altq) altqs = TAILQ_HEAD_INITIALIZER(altqs);

d178 11
d215 6
d224 3
d264 3
d273 1
d280 6
d294 3
d340 6
d381 1
a381 1
	if (pa->parent[0] == 0 || strcasecmp("NULL", pa->parent) == 0)
a384 1

d421 1
d481 1
a481 1
	 * check if cbq has one root class and one default class
d547 471
d1125 1
@


1.22
log
@duh. two checks in rate2str which decide wether to print Mb or Kb had 1024
instead of 1000 in.
cosmetic changes if at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.21 2002/12/16 23:06:28 henning Exp $	*/
d360 1
a360 1
			fprintf(stderr, "cbq: class %s is too slow!\n",
d434 1
a434 1
		warnx("should have one root class on %s", pa->ifname);
d438 1
a438 1
		warnx("should have one default class on %s", pa->ifname);
@


1.21
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.20 2002/12/08 00:19:47 henning Exp $	*/
d608 1
a608 1
	else if (rate >= 1024 * 1024)
d610 1
a610 1
	else if (rate >= 1024)
@


1.20
log
@allow flexible options order like Theo did for rules.

idea, lots of input, motivation and ok deraadt@@

ATTENTION:
this changes the syntax. the "scheduler" keyword is gone now.
old: altq on $interface scheduler cbq ...
new: altq on $interface cbq ...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.19 2002/12/07 19:12:34 henning Exp $	*/
d52 7
a58 7
static	int eval_pfqueue_cbq(struct pfctl *pf, struct pf_altq *);
static	int cbq_compute_idletime(struct pfctl *, struct pf_altq *);
static	int check_commit_cbq(int, int, struct pf_altq *);
static	void print_cbq_opts(const struct pf_altq *);
static	char *rate2str(double);
u_int32_t	getifspeed(char *);
u_long	getifmtu(char *);
d65 1
a65 1
	struct	pf_altq *altq;
d76 1
a76 1
	struct	pf_altq *altq;
d91 1
a91 1
	struct	pf_altq *altq;
d104 1
a104 1
	struct	pf_altq *altq;
d117 1
a117 1
	struct	pf_altq *altq;
d130 1
a130 1
	struct	pf_altq *altq;
d224 2
a225 2
	struct	pf_altq *altq;
	int	error = 0;
d246 2
a247 2
	struct	pf_altq *if_pa, *parent;
	int	error = 0;
d299 2
a300 2
	struct	cbq_opts *opts;
	u_int	ifmtu;
d333 5
a337 5
	struct	cbq_opts *opts;
	double	maxidle_s, maxidle, minidle;
	double	offtime, nsPerByte, ifnsPerByte, ptime, cptime;
	double	z, g, f, gton, gtom, maxrate;
	u_int	minburst, maxburst;
d414 3
a416 3
	struct	pf_altq *altq;
	int	root_class, default_class;
	int	error = 0;
d447 1
a447 1
	const	struct cbq_opts *opts;
d489 1
a489 1
	struct	pf_altq_node *node;
d531 1
a531 1
	struct	pf_altq_node *node, *child;
d550 1
a550 1
	const struct pf_altq_node *child;
d595 3
a597 3
	char	*buf;
	static	char r2sbuf[R2S_BUFS][RATESTR_MAX];  /* ring bufer */
	static	int idx = 0;
d620 3
a622 3
	int	s;
	struct	ifreq ifr;
	struct	if_data ifrdat;
d638 2
a639 2
	int	s;
	struct	ifreq ifr;
@


1.19
log
@get the interface's MTU instead of assuming 1500
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.18 2002/12/06 16:16:15 henning Exp $	*/
d148 1
a148 1
	printf("altq on %s scheduler ", a->ifname);
@


1.18
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.17 2002/12/03 10:57:13 henning Exp $	*/
d58 1
d215 1
a215 1
		size = size * 1500;  /* assume the default mtu is 1500 */
d302 1
a302 3
#if 1
	ifmtu = 1500;	/* should be obtained from the interface */
#endif
d633 21
@


1.17
log
@be nice and shutdown the socket after beeing done; pointed out by kenjiro
@
text
@d1 2
a2 1
/*	$OpenBSD: pfctl_altq.c,v 1.16 2002/12/02 22:18:21 henning Exp $	*/
d40 1
a44 1
#include <math.h>
d52 5
a56 5
static int eval_pfqueue_cbq(struct pfctl *pf, struct pf_altq *);
static int cbq_compute_idletime(struct pfctl *, struct pf_altq *);
static int check_commit_cbq(int, int, struct pf_altq *);
static void print_cbq_opts(const struct pf_altq *);
static char *rate2str(double);
d64 1
a64 1
	struct pf_altq *altq;
d75 1
a75 1
	struct pf_altq *altq;
d90 1
a90 1
	struct pf_altq *altq;
d103 1
a103 1
	struct pf_altq *altq;
d116 1
a116 1
	struct pf_altq *altq;
d129 1
a129 1
	struct pf_altq *altq;
d165 1
a165 1
	unsigned i;
d187 1
a187 1
	u_int rate, size, errors = 0;
d223 2
a224 2
	struct pf_altq *altq;
	int error = 0;
d245 2
a246 2
	struct pf_altq *if_pa, *parent;
	int error = 0;
a273 4
	/*
	 * admission control: bandwidth should be smaller than the
	 * interface bandwidth and the parent bandwidth
	 */
d298 2
a299 2
	struct cbq_opts *opts;
	u_int ifmtu;
d334 5
a338 5
	struct cbq_opts *opts;
	double maxidle_s, maxidle, minidle,
	    offtime, nsPerByte, ifnsPerByte, ptime, cptime;
	double z, g, f, gton, gtom, maxrate;
	u_int minburst, maxburst;
d415 3
a417 3
	struct pf_altq *altq;
	int root_class, default_class;
	int error = 0;
d448 1
a448 1
	const struct cbq_opts *opts;
a455 1

d490 1
a490 1
	struct pf_altq_node *node;
d532 1
a532 1
	struct pf_altq_node *node, *child;
d596 3
a598 3
	char *buf;
	static char r2sbuf[R2S_BUFS][RATESTR_MAX];  /* ring bufer */
	static int idx = 0;
@


1.16
log
@allow for "altq on $interface" without specifying a bandwidth. The
interface's bandwidth is taken then.
as a side-effect, "altq on $interface bandwidth xx%" is also possible now,
it's relative to the interface's bandwidth then.

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.15 2002/11/29 15:52:13 henning Exp $	*/
d635 2
@


1.15
log
@in pfctl_find_altq_node also compare the interface.
fixes pfctl -sq output in case the queuespec was expanded to >1 queues
on different interfaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.14 2002/11/28 14:50:23 henning Exp $	*/
d56 1
d183 2
a184 1
eval_pfaltq(struct pfctl *pf, struct pf_altq *pa)
d186 15
a200 1
	u_int rate, size;
d216 1
a216 1
	return (0);
d620 16
@


1.14
log
@qlimit before tbrsize
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.13 2002/11/28 14:44:57 henning Exp $	*/
d499 1
a499 1
		parent = pfctl_find_altq_node(*root, altq.parent);
d517 2
a518 1
pfctl_find_altq_node(struct pf_altq_node *root, const char *qname)
d523 2
a524 1
		if (!strcmp(node->altq.qname, qname))
d527 2
a528 1
			child = pfctl_find_altq_node(node->children, qname);
@


1.13
log
@print qlimit on altq if not equal to the default value
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.12 2002/11/27 16:23:01 henning Exp $	*/
d154 1
a154 2
	printf("bandwidth %s tbrsize %u ", rate2str((double)a->ifbandwidth),
	    a->tbrsize);
d157 1
@


1.12
log
@-use a #define for default qlimit instead of hardcoding it
-print qlimit in print_queue if it is not the default one
-assign the default qlimit early in the parser instead of using 0
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.11 2002/11/27 16:06:20 henning Exp $	*/
d156 2
@


1.11
log
@next round in print fixes:
-only print priority if it is not equal to the default one
-space handling overhaul
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.10 2002/11/27 15:00:41 henning Exp $	*/
d170 2
d245 1
a245 1
		pa->qlimit = 50;
@


1.10
log
@in print_altq() correctly print scheduler type and options
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.9 2002/11/25 16:30:22 henning Exp $	*/
d145 1
a145 1
	printf("altq on %s scheduler", a->ifname);
d151 1
a151 1
			printf(" cbq");
d154 1
a154 1
	printf(" bandwidth %s tbrsize %u", rate2str((double)a->ifbandwidth),
d166 4
a169 2
	printf("%s bandwidth %s priority %u", a->qname,
	    rate2str((double)a->bandwidth), a->priority);
d445 1
a445 1
		printf(" cbq(");
d466 1
a466 1
		printf(" )");
d540 1
a540 1
		printf(" {");
@


1.9
log
@1Kb = 1000b, not 1024; as discussed with kjc@@ and theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.8 2002/11/22 11:46:02 henning Exp $	*/
d145 10
a154 2
	printf("altq on %s scheduler %u bandwidth %s tbrsize %u",
	    a->ifname, a->scheduler, rate2str((double)a->ifbandwidth),
@


1.8
log
@kill dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.7 2002/11/19 17:49:53 henning Exp $	*/
d175 1
a175 1
		if (rate <= 1 * 1024 * 1024)
d177 1
a177 1
		else if (rate <= 10 * 1024 * 1024)
d179 1
a179 1
		else if (rate <= 200 * 1024 * 1024)
d577 1
a577 1
	else if (rate >= 1024 * 1024 * 1024)
d579 1
a579 1
		    rate / (1024.0 * 1024.0 * 1024.0));
d581 1
a581 1
		snprintf(buf, RATESTR_MAX, "%.2fMb", rate / (1024.0 * 1024.0));
d583 1
a583 1
		snprintf(buf, RATESTR_MAX, "%.2fKb", rate / 1024.0);
@


1.7
log
@pfctl -sq prettier
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.6 2002/11/19 17:41:19 henning Exp $	*/
a159 4
/*	printf("queue on %s %s parent 0x%x priority %u bandwidth %s"
	    " qlimit %u qid 0x%x\n",
	    a->ifname, a->qname, a->parent_qid, a->priority,
	    rate2str((double)a->bandwidth), a->qlimit, a->qid); */
@


1.6
log
@altq ifspec is always level 0
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.5 2002/11/19 17:37:39 henning Exp $	*/
d155 1
d157 2
a158 2
		printf("  ");
	printf("queue %s bandwidth %s priority %u", a->qname,
d546 1
a546 1
		pfctl_print_altq_node(child, level+2);
@


1.5
log
@altq interface spec should be printed as altq interface spec, not queue
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.4 2002/11/18 23:20:43 deraadt Exp $	*/
a139 2
	unsigned i;

a144 2
	for (i = 0; i < level; ++i)
		printf("  ");
@


1.4
log
@support Gb in print; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.3 2002/11/18 23:13:32 deraadt Exp $	*/
d534 1
a534 4
	if (node->altq.qname[0])
		print_altq(&node->altq, level);
	else
		print_queue(&node->altq, level);
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.2 2002/11/18 22:55:39 deraadt Exp $	*/
d247 2
a248 1
		errx(1, "bandwidth for %s invalid (%d / %d)", pa->qname, bw_absolute, bw_percent);
d587 3
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_altq.c,v 1.1 2002/11/18 22:49:15 henning Exp $	*/
d76 2
a77 2
		if (strncmp(a->ifname, altq->ifname, IFNAMSIZ) == 0
		    && strncmp(a->qname, altq->qname, PF_QNAME_SIZE) == 0) {
d91 2
a92 2
		if (strncmp(ifname, altq->ifname, IFNAMSIZ) == 0
		    && altq->qname[0] == 0)
@


1.1
log
@altq and pf merged

this isn't 100% done yet: the print_ stuff isn't finished, some features
will be added later, and there is no documetation yet, but committing now
enables a few more people to work on.

print_altq_node stuff hacked by Daniel at euroBSDcon; lotsa stuff from kjc,
debugging help also pb and camiel. lots of good ideas by theo.

"commit now" theo philipp daniel
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 1
a161 1
	printf("queue %s bandwidth %s priority %u", a->qname, 
@

