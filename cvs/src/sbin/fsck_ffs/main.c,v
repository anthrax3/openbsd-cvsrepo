head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.2
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.49.0.4
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.38.0.8
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.6
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.4
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.26.0.6
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.18.0.4
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.16.0.4
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2016.09.09.15.37.15;	author tb;	state Exp;
branches;
next	1.49;
commitid	TXzQrSRLn0xGub30;

1.49
date	2015.11.24.21.42.54;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	6EMrEc62rgfU2L4N;

1.48
date	2015.11.23.23.01.20;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	VgdALmHg2RTg5Jdl;

1.47
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Cz19p5I1S6mVZIjV;

1.46
date	2015.10.15.03.10.05;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	1Cz9iNuje72nNplB;

1.45
date	2015.10.14.14.33.45;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	BweGlCJbPgfbxjH9;

1.44
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	pzd3OPiuZ6mCFBtc;

1.43
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	F55lwc3gS4GN2mLs;

1.42
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2013.11.01.17.36.18;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2010.08.12.15.26.34;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.09.08.06.37;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.09.19.52.32;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.08.19.02.23;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.17.09.34.16;	author moritz;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.03.05.03.50;	author jaredy;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.20.21.57.56;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.29.15.02.58;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.22.20.24.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.03.01.07.45.17;	author d;	state Exp;
branches;
next	1.14;

1.14
date	98.02.05.03.22.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.02.05.00.26.24;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.20.22.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.15.33.33;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.07.14.20.59.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.14.14.16.47;	author graichen;	state Exp;
branches;
next	1.8;

1.8
date	97.06.25.18.12.16;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.15.23.41.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.20.08.36.35;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.10.12.03.06.54;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.30.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.00.03.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.11.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Tighten pledge for fsdb and eliminate a strcmp("fsdb", getprogname())
by passing a flag to setup().

ok deraadt
@
text
@/*	$OpenBSD: main.c,v 1.49 2015/11/24 21:42:54 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.22 1996/10/11 20:15:48 thorpej Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <unistd.h>
#include <err.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

volatile sig_atomic_t returntosingle;

int	argtoi(int, char *, char *, int);
int	checkfilesys(char *, char *, long, int);
int	main(int, char *[]);

extern char *__progname;

void
usage(void)
{
	fprintf(stderr, "usage: %s [-fnpy] [-b block#] [-c level] "
	    "[-m mode] filesystem\n", __progname);
	exit(1);
}
int
main(int argc, char *argv[])
{
	int ch;
	int ret = 0;

	sync();
	skipclean = 1;
	while ((ch = getopt(argc, argv, "dfpnNyYb:c:m:")) != -1) {
		switch (ch) {
		case 'p':
			preen = 1;
			break;

		case 'b':
			skipclean = 0;
			bflag = argtoi('b', "number", optarg, 10);
			printf("Alternate super block location: %d\n", bflag);
			break;

		case 'c':
			skipclean = 0;
			cvtlevel = argtoi('c', "conversion level", optarg, 10);
			if (cvtlevel < 3)
				errexit("cannot do level %d conversion\n",
				    cvtlevel);
			break;

		case 'd':
			debug = 1;
			break;

		case 'f':
			skipclean = 0;
			break;

		case 'm':
			lfmode = argtoi('m', "mode", optarg, 8);
			if (lfmode &~ 07777)
				errexit("bad mode to -m: %o\n", lfmode);
			printf("** lost+found creation mode %o\n", lfmode);
			break;

		case 'n':
		case 'N':
			nflag = 1;
			yflag = 0;
			break;

		case 'y':
		case 'Y':
			yflag = 1;
			nflag = 0;
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void)signal(SIGINT, catch);
	if (preen)
		(void)signal(SIGQUIT, catchquit);
	catchinfo(0);

	(void)checkfilesys(blockcheck(*argv), 0, 0L, 0);

	if (returntosingle)
		ret = 2;

	exit(ret);
}

int
argtoi(int flag, char *req, char *str, int base)
{
	char *cp;
	int ret;

	ret = (int)strtol(str, &cp, base);
	if (cp == str || *cp)
		errexit("-%c flag requires a %s\n", flag, req);
	return (ret);
}

/*
 * Check the specified filesystem.
 */
/* ARGSUSED */
int
checkfilesys(char *filesys, char *mntpt, long auxdata, int child)
{
	daddr_t n_ffree, n_bfree;
	struct dups *dp;
	struct zlncnt *zlnp;
	int cylno;

	if (preen && child)
		(void)signal(SIGQUIT, voidquit);
	setcdevname(filesys, NULL, preen);
	if (debug && preen)
		pwarn("starting\n");

	switch (setup(filesys, 0)) {
	case 0:
		if (preen)
			pfatal("CAN'T CHECK FILE SYSTEM.");
		/* FALLTHROUGH */
	case -1:
		if (fsreadfd != -1) {
			(void)close(fsreadfd);
			fsreadfd = -1;
		}
		if (fswritefd != -1) {
			(void)close(fswritefd);
			fswritefd = -1;
		}
		return (0);
	}
	info_filesys = filesys;

	/*
	 * Cleared if any questions answered no. Used to decide if
	 * the superblock should be marked clean.
	 */
	resolved = 1;

	/*
	 * 1: scan inodes tallying blocks used
	 */
	if (preen == 0) {
		printf("** Last Mounted on %s\n", sblock.fs_fsmnt);
		if (hotroot())
			printf("** Root file system\n");
		printf("** Phase 1 - Check Blocks and Sizes\n");
	}
	pass1();

	/*
	 * 1b: locate first references to duplicates, if any
	 */
	if (duplist) {
		if (preen || usedsoftdep)
			pfatal("INTERNAL ERROR: dups with -p");
		printf("** Phase 1b - Rescan For More DUPS\n");
		pass1b();
	}

	/*
	 * 2: traverse directories from root to mark all connected directories
	 */
	if (preen == 0)
		printf("** Phase 2 - Check Pathnames\n");
	pass2();

	/*
	 * 3: scan inodes looking for disconnected directories
	 */
	if (preen == 0)
		printf("** Phase 3 - Check Connectivity\n");
	pass3();

	/*
	 * 4: scan inodes looking for disconnected files; check reference counts
	 */
	if (preen == 0)
		printf("** Phase 4 - Check Reference Counts\n");
	pass4();

	/*
	 * 5: check and repair resource counts in cylinder groups
	 */
	if (preen == 0)
		printf("** Phase 5 - Check Cyl groups\n");
	pass5();

	/*
	 * print out summary statistics
	 */
	n_ffree = sblock.fs_cstotal.cs_nffree;
	n_bfree = sblock.fs_cstotal.cs_nbfree;
	pwarn("%lld files, %lld used, %lld free ",
	    n_files, (long long)n_blks,
	    (long long)(n_ffree + sblock.fs_frag * n_bfree));
	printf("(%lld frags, %lld blocks, %lld.%lld%% fragmentation)\n",
	    (long long)n_ffree, (long long)n_bfree,
	    (long long)((n_ffree * 100) / sblock.fs_dsize),
	    (long long)(((n_ffree * 1000 + sblock.fs_dsize / 2) /
	    sblock.fs_dsize) % 10));
	if (debug &&
	    (n_files -= maxino - ROOTINO - sblock.fs_cstotal.cs_nifree))
		printf("%lld files missing\n", n_files);
	if (debug) {
		n_blks += sblock.fs_ncg *
			(cgdmin(&sblock, 0) - cgsblock(&sblock, 0));
		n_blks += cgsblock(&sblock, 0) - cgbase(&sblock, 0);
		n_blks += howmany(sblock.fs_cssize, sblock.fs_fsize);
		if (n_blks -= maxfsblock - (n_ffree + sblock.fs_frag * n_bfree))
			printf("%lld blocks missing\n", (long long)n_blks);
		if (duplist != NULL) {
			printf("The following duplicate blocks remain:");
			for (dp = duplist; dp; dp = dp->next)
				printf(" %lld,", (long long)dp->dup);
			printf("\n");
		}
		if (zlnhead != NULL) {
			printf("The following zero link count inodes remain:");
			for (zlnp = zlnhead; zlnp; zlnp = zlnp->next)
				printf(" %llu,",
				    (unsigned long long)zlnp->zlncnt);
			printf("\n");
		}
	}
	zlnhead = NULL;
	duplist = NULL;
	muldup = NULL;
	inocleanup();
	if (fsmodified) {
		sblock.fs_time = (time_t)time(NULL);
		sbdirty();
	}
	if (cvtlevel && sblk.b_dirty) {
		/*
		 * Write out the duplicate super blocks
		 */
		for (cylno = 0; cylno < sblock.fs_ncg; cylno++)
			bwrite(fswritefd, (char *)&sblock,
			    fsbtodb(&sblock, cgsblock(&sblock, cylno)), SBSIZE);
	}
	if (rerun)
		resolved = 0;
	ckfini(resolved); /* Don't mark fs clean if fsck needs to be re-run */

	for (cylno = 0; cylno < sblock.fs_ncg; cylno++)
		free(inostathead[cylno].il_stat);
	free(inostathead);
	inostathead = NULL;

	free(blockmap);
	blockmap = NULL;
	free(sblock.fs_csp);
	free(sblk.b_un.b_buf);
	free(asblk.b_un.b_buf);

	if (!fsmodified)
		return (0);
	if (!preen)
		printf("\n***** FILE SYSTEM WAS MODIFIED *****\n");
	if (rerun || !resolved)
		printf("\n***** PLEASE RERUN FSCK *****\n");
	if (hotroot()) {
		struct statfs stfs_buf;
		/*
		 * We modified the root.  Do a mount update on
		 * it, unless it is read-write, so we can continue.
		 */
		if (statfs("/", &stfs_buf) == 0) {
			long flags = stfs_buf.f_flags;
			struct ufs_args args;
			int ret;

			if (flags & MNT_RDONLY) {
				args.fspec = 0;
				args.export_info.ex_flags = 0;
				args.export_info.ex_root = 0;
				flags |= MNT_UPDATE | MNT_RELOAD;
				ret = mount(MOUNT_FFS, "/", flags, &args);
				if (ret == 0)
					return(0);
			}
		}
		if (!preen)
			printf("\n***** REBOOT NOW *****\n");
		sync();
		return (4);
	}
	return (0);
}
@


1.49
log
@hotroot is calculated late in fsck_ffs, so defer the pledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2015/11/23 23:01:20 deraadt Exp $	*/
d173 1
a173 1
	switch (setup(filesys)) {
@


1.48
log
@Cannot pledge() in the hotroot case
Discovered by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2015/11/23 19:19:30 deraadt Exp $	*/
a171 4

	if (!hotroot())
		if (pledge("stdio rpath wpath getpw disklabel", NULL) == -1)
			err(1, "pledge");
@


1.47
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2015/10/15 03:10:05 deraadt Exp $	*/
d173 3
a175 2
	if (pledge("stdio rpath wpath getpw disklabel", NULL) == -1)
		err(1, "pledge");
@


1.46
log
@fsck_ffs has a ^T signal handler which opens /dev/tty late.  Hoist that
opening to before the pledge, and cache the fd.
looked over by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2015/10/14 14:33:45 deraadt Exp $	*/
d43 1
d172 4
@


1.45
log
@Only accept one filesystem/device as argument for checking.  Few people
will be calling these directly, and not for the multiple filesystem case.
fsck(8) is generally the parent and will handle things.
ok semarie; this change will also help a goal jsing has
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2015/02/07 02:09:13 deraadt Exp $	*/
d132 1
a132 1
	(void)signal(SIGINFO, catchinfo);
@


1.44
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2015/01/20 18:22:21 deraadt Exp $	*/
d56 7
d119 1
a119 2
			errexit("usage: %s [-fnpy] [-b block#] [-c level] "
			    "[-m mode] filesystem ...\n", __progname);
d124 4
d134 1
a134 3
	if (argc)
		while (argc-- > 0)
			(void)checkfilesys(blockcheck(*argv++), 0, 0L, 0);
@


1.43
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2015/01/16 06:39:57 deraadt Exp $	*/
d67 1
a67 1
			preen++;
d85 1
a85 1
			debug++;
d101 1
a101 1
			nflag++;
d107 1
a107 1
			yflag++;
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2013/11/01 17:36:18 krw Exp $	*/
a32 1
#include <sys/param.h>	/* MAXFRAG */
@


1.41
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2013/06/11 16:42:04 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d35 1
@


1.40
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2013/04/25 06:43:20 otto Exp $	*/
d242 2
a243 1
	    n_files, n_blks, n_ffree + sblock.fs_frag * n_bfree);
d245 4
a248 2
	    n_ffree, n_bfree, (n_ffree * 100) / sblock.fs_dsize,
	    ((n_ffree * 1000 + sblock.fs_dsize / 2) / sblock.fs_dsize) % 10);
d258 1
a258 1
			printf("%lld blocks missing\n", n_blks);
d262 1
a262 1
				printf(" %lld,", dp->dup);
@


1.39
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2011/04/24 07:07:03 otto Exp $	*/
d153 1
a153 1
	daddr64_t n_ffree, n_bfree;
@


1.38
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2011/04/16 16:37:21 otto Exp $	*/
d265 2
a266 1
				printf(" %u,", zlnp->zlncnt);
@


1.37
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2010/08/12 15:26:34 jsing Exp $	*/
d79 3
@


1.36
log
@Print the real device name followed by the disklabel UID in parenthesis
when fsck is run against a disklabel UID. This allows a user to determine
which device is really being scanned.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2009/10/27 23:59:32 deraadt Exp $	*/
d285 6
a292 4
	free(stmap);
	stmap = NULL;
	free(lncntp);
	lncntp = NULL;
@


1.35
log
@kill redundant docheck() function; ok deraadt@@
@
text
@d157 1
a157 1
	setcdevname(filesys, preen);
@


1.34
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2008/06/10 23:10:29 otto Exp $	*/
a37 1
#include <fstab.h>
a51 1
int	docheck(struct fstab *);
a140 16
}

/*
 * Determine whether a filesystem should be checked.
 */
int
docheck(struct fstab *fsp)
{

	if ((strcmp(fsp->fs_vfstype, "ufs") &&
	     strcmp(fsp->fs_vfstype, "ffs")) ||
	    (strcmp(fsp->fs_type, FSTAB_RW) &&
	     strcmp(fsp->fs_type, FSTAB_RO)) ||
	    fsp->fs_passno == 0)
		return (0);
	return (1);
@


1.33
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2007/06/25 19:59:55 otto Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1986, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.2 (Berkeley) 1/23/94";
#else
static const char rcsid[] = "$OpenBSD: main.c,v 1.32 2007/06/25 19:59:55 otto Exp $";
#endif
#endif /* not lint */
@


1.32
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2007/04/10 16:08:17 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.31 2007/04/10 16:08:17 millert Exp $";
d319 2
a320 4
	free(statemap);
	statemap = NULL;
	free(typemap);
	typemap = NULL;
@


1.31
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2007/03/19 13:27:47 pedro Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.30 2007/03/19 13:27:47 pedro Exp $";
d182 1
a182 1
	daddr_t n_ffree, n_bfree;
d270 1
a270 1
	pwarn("%d files, %d used, %d free ",
d272 1
a272 1
	printf("(%d frags, %d blocks, %lld.%lld%% fragmentation)\n",
d277 1
a277 1
		printf("%d files missing\n", n_files);
d284 1
a284 1
			printf("%d blocks missing\n", n_blks);
d288 1
a288 1
				printf(" %d,", dp->dup);
@


1.30
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2007/02/09 19:52:32 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.29 2007/02/09 19:52:32 otto Exp $";
d268 2
a269 2
	n_ffree = sblock.fs_ffs1_cstotal.cs_nffree;
	n_bfree = sblock.fs_ffs1_cstotal.cs_nbfree;
d272 3
a274 3
	printf("(%d frags, %d blocks, %d.%d%% fragmentation)\n",
	    n_ffree, n_bfree, (n_ffree * 100) / sblock.fs_ffs1_dsize,
	    ((n_ffree * 1000 + sblock.fs_ffs1_dsize / 2) / sblock.fs_ffs1_dsize) % 10);
d276 1
a276 1
	    (n_files -= maxino - ROOTINO - sblock.fs_ffs1_cstotal.cs_nifree))
d303 1
a303 1
		(void)time(&sblock.fs_ffs1_time);
@


1.29
log
@fix a fd leak that happens whe checking multiple file systems and some
of them are clean. ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2007/02/08 19:02:23 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.28 2007/02/08 19:02:23 otto Exp $";
d268 2
a269 2
	n_ffree = sblock.fs_cstotal.cs_nffree;
	n_bfree = sblock.fs_cstotal.cs_nbfree;
d273 2
a274 2
	    n_ffree, n_bfree, (n_ffree * 100) / sblock.fs_dsize,
	    ((n_ffree * 1000 + sblock.fs_dsize / 2) / sblock.fs_dsize) % 10);
d276 1
a276 1
	    (n_files -= maxino - ROOTINO - sblock.fs_cstotal.cs_nifree))
d303 1
a303 1
		(void)time(&sblock.fs_time);
@


1.28
log
@Plug some mem leaks that occur when checking multiple file systems in a
row. ok beck@@ pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2006/04/17 09:34:16 moritz Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.27 2006/04/17 09:34:16 moritz Exp $";
d196 1
d198 8
@


1.27
log
@Remove "l:" from getopt(3) string, since the option was
removed long ago. From Steffen Wendzel. ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2005/02/03 05:03:50 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.26 2005/02/03 05:03:50 jaredy Exp $";
d312 2
d316 4
@


1.26
log
@sync usage output
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2003/06/02 20:06:15 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.25 2003/06/02 20:06:15 millert Exp $";
d80 1
a80 1
	while ((ch = getopt(argc, argv, "dfpnNyYb:c:l:m:")) != -1) {
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2002/08/23 09:09:04 gluk Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.24 2002/08/23 09:09:04 gluk Exp $";
d125 2
a126 1
			errexit("usage: %s -p [-f] [-m mode]\n       %s [-f] [-b block#] [-c level] [-y] [-n] [-m mode] [filesystem] ...\n", __progname, __progname);
@


1.24
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2002/08/20 21:57:56 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.23 2002/08/20 21:57:56 deraadt Exp $";
@


1.23
log
@clean some more signal races, some cannot be fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2002/06/09 08:13:05 todd Exp $	*/
d38 1
a38 1
static char copyright[] =
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 2002/06/09 08:13:05 todd Exp $";
d77 1
a77 3
main(argc, argv)
	int	argc;
	char	*argv[];
d100 1
a100 1
		
d151 1
a151 4
argtoi(flag, req, str, base)
	int flag;
	char *req, *str;
	int base;
d166 1
a166 2
docheck(fsp)
	struct fstab *fsp;
d183 1
a183 4
checkfilesys(filesys, mntpt, auxdata, child)
	char *filesys, *mntpt;
	long auxdata;
	int child;
d315 1
a315 1
	free((char *)lncntp);
@


1.22
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2002/04/23 18:54:12 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 2002/04/23 18:54:12 espie Exp $";
d67 2
a68 1
int	returntosingle;
d321 1
d323 1
d325 1
@


1.21
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2002/02/16 21:27:34 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 2002/02/16 21:27:34 millert Exp $";
d309 1
a309 1
		/* 
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2001/11/05 07:39:16 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 2001/11/05 07:39:16 mpech Exp $";
d341 2
a342 2
				args.export.ex_flags = 0;
				args.export.ex_root = 0;
@


1.19
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2001/03/02 08:33:55 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 2001/03/02 08:33:55 art Exp $";
d68 4
a71 4
int	argtoi __P((int, char *, char *, int));
int	checkfilesys __P((char *, char *, long, int));
int	docheck __P((struct fstab *));
int	main __P((int, char *[]));
@


1.18
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2000/12/29 15:02:58 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2000/12/29 15:02:58 angelos Exp $";
d171 1
a171 1
	register struct fstab *fsp;
@


1.17
log
@Don't mark filesystem clean if fsck needs to be rerun (PR 1572)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2000/01/22 20:24:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 2000/01/22 20:24:56 deraadt Exp $";
d211 7
d233 1
a233 1
		if (preen)
d316 3
a318 1
	ckfini(!rerun); /* Don't mark fs clean if fsck needs to be re-run */
d326 1
a326 1
	if (rerun)
@


1.16
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1999/03/01 07:45:17 d Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1999/03/01 07:45:17 d Exp $";
d309 1
a309 1
	ckfini(1);
@


1.15
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1998/02/05 03:22:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1998/02/05 03:22:18 deraadt Exp $";
a81 2
	extern char *optarg;
	extern int optind;
@


1.14
log
@Ha! Caught Todd making a mistake!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1998/02/05 00:26:24 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 1998/02/05 00:26:24 millert Exp $";
d141 1
d212 1
@


1.13
log
@Add usage line
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/10/06 20:22:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1997/10/06 20:22:33 deraadt Exp $";
d132 1
a132 1
			errexit("usage: %s -p [-f] [-m mode]\n       %s [-f] [-b block#] [-c level] [-y] [-n] [-m mode] [filesystem] ...", __progname, __progname);
@


1.12
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1997/07/14 20:59:11 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1997/07/14 20:59:11 deraadt Exp $";
d73 2
d132 1
a132 1
			errexit("%c option?\n", ch);
@


1.11
log
@VFS Lite2 Changes
@
text
@a208 7

        /*
         * Cleared if any questions answered no. Used to decide if
         * the superblock should be marked clean.
         */
        resolved = 1;

d224 1
a224 1
		if (preen || usedsoftdep)
d307 4
d315 1
a315 2
	if (rerun) {
		resolved = 0;
a316 6
	}
	ckfini(resolved);
	free(blockmap);
	free(statemap);
	free((char *)lncntp);

@


1.10
log
@that was not a nice change
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1997/06/25 18:12:16 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1997/06/25 18:12:16 kstailey Exp $";
d209 7
d231 1
a231 1
		if (preen)
a313 4
	ckfini(1);
	free(blockmap);
	free(statemap);
	free((char *)lncntp);
d318 2
a319 1
	if (rerun)
d321 6
@


1.9
log
@change the output so that it fits into 80 columns
@
text
@d263 1
a263 1
	pwarn("%d files, %d used, %d free\n",
d265 1
a265 1
	pwarn("(%d frags, %d blocks, %d.%d%% fragmentation)\n",
@


1.8
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/01/15 23:41:46 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/01/15 23:41:46 millert Exp $";
d263 1
a263 1
	pwarn("%d files, %d used, %d free ",
d265 1
a265 1
	printf("(%d frags, %d blocks, %d.%d%% fragmentation)\n",
@


1.7
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1996/10/20 08:36:35 tholo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1996/10/20 08:36:35 tholo Exp $";
d291 3
a293 3
	zlnhead = (struct zlncnt *)0;
	duplist = (struct dups *)0;
	muldup = (struct dups *)0;
@


1.6
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/10/12 03:06:54 tholo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/10/12 03:06:54 tholo Exp $";
d85 1
a85 1
	while ((ch = getopt(argc, argv, "dfpnNyYb:c:l:m:")) != EOF) {
@


1.5
log
@From Kirk McKusick:
  If a directory somehow develops a hole (that is a block pointer
  that has a value of zero), fsck would give the filesystem a clean
  bill of health, but the kernel would panic when accessing the
  directory with the hole. Fsck now checks for holes in directories.
  If found in preen mode, fsck fails. In manual mode, it can be
  directed to shorten the directory to the beginning of the hole. A
  more complete solution would be to allocate a block to fill the
  hole. However, this is a lot more work for a `cannot happen' error,
  so the extra effort seems unwarranted.
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.4 1996/06/23 14:30:29 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.18.2.1 1995/11/01 00:06:18 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1996/06/23 14:30:29 deraadt Exp $";
d65 1
a66 1
void	catch(), catchquit(), voidquit();
d68 4
a71 14
int argtoi __P((int, char *, char *, int));
int checkfilesys __P((char *, char *, long, int));
int docheck __P((struct fstab *));

void
usage()
{
	fprintf(stderr,
	    "usage: fsck -p [-f] [-m mode]\n");
	fprintf(stderr,
	    "       fsck [-f] [-b block#] [-c level] [-l maxparallel] [-y] "
	    "[-n] [-m mode] [filesystems]\n");
	exit(1);
}
d79 2
a80 2
	int ret, maxrun = 0;
	extern char *optarg, *blockcheck();
a109 4
		case 'l':
			maxrun = argtoi('l', "number", optarg, 10);
			break;

d130 1
a130 1
			usage();
d139 2
a140 1
	if (argc) {
d143 1
a143 3
		exit(0);
	}
	ret = checkfstab(preen, maxrun, docheck, checkfilesys);
d145 2
a146 1
		exit(2);
d199 1
a199 1
	cdevname = filesys;
d214 1
a214 1
		if (hotroot)
d263 1
a263 1
	pwarn("%ld files, %ld used, %ld free ",
d265 1
a265 1
	printf("(%ld frags, %ld blocks, %d.%d%% fragmentation)\n",
d270 1
a270 1
		printf("%ld files missing\n", n_files);
d277 1
a277 1
			printf("%ld blocks missing\n", n_blks);
d281 1
a281 1
				printf(" %ld,", dp->dup);
d287 1
a287 1
				printf(" %lu,", zlnp->zlncnt);
d317 1
a317 1
	if (hotroot) {
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18.2.1 1995/11/01 00:06:18 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18.2.1 1995/11/01 00:06:18 jtc Exp $";
d329 2
@


1.3
log
@add usage printout
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.18.2.1 1995/11/01 00:06:18 jtc Exp $";
@


1.2
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d71 11
d143 1
a143 1
			errexit("%c option?\n", ch);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.18 1995/07/12 03:39:53 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: main.c,v 1.18 1995/07/12 03:39:53 cgd Exp $";
d333 1
a333 1
				ret = mount(MOUNT_UFS, "/", flags, &args);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
