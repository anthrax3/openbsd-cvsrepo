head	1.44;
access;
symbols
	OPENBSD_6_1:1.43.0.8
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.38.0.8
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.8
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.6
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2017.04.10.08.19.12;	author fcambus;	state Exp;
branches;
next	1.43;
commitid	lO8kfrJ4fL9HKeVJ;

1.43
date	2015.08.22.06.00.27;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	xDasScyANI04nV0X;

1.42
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	F55lwc3gS4GN2mLs;

1.41
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	Uu5nFG3wCl0LACBb;

1.40
date	2014.10.14.15.01.51;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	bEiwmyKl9kRYD0Ja;

1.39
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.38;
commitid	qlzrzgnJ4ZiiF6XQ;

1.38
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.02.22.23.59;	author chl;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.09.06.41.17;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.05.29.07.57.43;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.09.15.54.54;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.06.18.01.44;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.02.08.54.10;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.01.23.42.35;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.01.06.41.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.12.16.35.55;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.22.20.24.32;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.12.02.28.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.19.15.18.01;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.16.18.15.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.16.17.37.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.11.01.43.45;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.07.18.26.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.03.01.07.45.17;	author d;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.22.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.33.34;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.10.20.08.36.36;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.37.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Remove always false comparison: inosused type is ino_t, which is
unsigned.

While there, fix a whitespace issue.

OK deraadt@@
@
text
@/*	$OpenBSD: pass1.c,v 1.43 2015/08/22 06:00:27 deraadt Exp $	*/
/*	$NetBSD: pass1.c,v 1.16 1996/09/27 22:45:15 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MIN setbit btodb isset */
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

static daddr_t badblk;
static daddr_t dupblk;
static void checkinode(ino_t, struct inodesc *);

static ino_t info_inumber;

static int
pass1_info(char *buf, size_t buflen)
{
	return (snprintf(buf, buflen, "phase 1, inode %llu/%llu",
	    (unsigned long long)info_inumber,
	    (unsigned long long)sblock.fs_ipg * sblock.fs_ncg) > 0);
}

void
pass1(void)
{
	ino_t inumber, inosused, ninosused;
	size_t inospace;
	struct inostat *info;
	int c;
	struct inodesc idesc;
	daddr_t i, cgd;
	u_int8_t *cp;

	/*
	 * Set file system reserved blocks in used block map.
	 */
	for (c = 0; c < sblock.fs_ncg; c++) {
		cgd = cgdmin(&sblock, c);
		if (c == 0)
			i = cgbase(&sblock, c);
		else
			i = cgsblock(&sblock, c);
		for (; i < cgd; i++)
			setbmap(i);
	}
	i = sblock.fs_csaddr;
	cgd = i + howmany(sblock.fs_cssize, sblock.fs_fsize);
	for (; i < cgd; i++)
		setbmap(i);
	/*
	 * Find all allocated blocks.
	 */
	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = ADDR;
	idesc.id_func = pass1check;
	n_files = n_blks = 0;
	info_inumber = 0;
	info_fn = pass1_info;
	for (c = 0; c < sblock.fs_ncg; c++) {
		inumber = c * sblock.fs_ipg;
		setinodebuf(inumber);
		getblk(&cgblk, cgtod(&sblock, c), sblock.fs_cgsize);
		if (sblock.fs_magic == FS_UFS2_MAGIC) {
			inosused = cgrp.cg_initediblk;
			if (inosused > sblock.fs_ipg)
				inosused = sblock.fs_ipg;
		} else
			inosused = sblock.fs_ipg;

		/*
		 * If we are using soft updates, then we can trust the
		 * cylinder group inode allocation maps to tell us which
		 * inodes are allocated. We will scan the used inode map
		 * to find the inodes that are really in use, and then
		 * read only those inodes in from disk.
		 */
		if (preen && usedsoftdep) {
			cp = &cg_inosused(&cgrp)[(inosused - 1) / CHAR_BIT];
			for ( ; inosused > 0; inosused -= CHAR_BIT, cp--) {
				if (*cp == 0)
					continue;
				for (i = 1 << (CHAR_BIT - 1); i > 0; i >>= 1) {
					if (*cp & i)
						break;
					inosused--;
				}
				break;
			}
		}
		/*
		 * Allocate inoinfo structures for the allocated inodes.
		 */
		inostathead[c].il_numalloced = inosused;
		if (inosused == 0) {
			inostathead[c].il_stat = 0;
			continue;
		}
		info = calloc((unsigned)inosused, sizeof(struct inostat));
		inospace = (unsigned)inosused * sizeof(struct inostat);
		if (info == NULL)
			errexit("cannot alloc %zu bytes for inoinfo", inospace);
		inostathead[c].il_stat = info;
		/*
		 * Scan the allocated inodes.
		 */
		for (i = 0; i < inosused; i++, inumber++) {
			info_inumber = inumber;
			if (inumber < ROOTINO) {
				(void)getnextinode(inumber);
				continue;
			}
			checkinode(inumber, &idesc);
		}
		lastino += 1;
		if (inosused < sblock.fs_ipg || inumber == lastino)
			continue;
		/*
		 * If we were not able to determine in advance which inodes
		 * were in use, then reduce the size of the inoinfo structure
		 * to the size necessary to describe the inodes that we
		 * really found.
		 */
		if (lastino < (c * sblock.fs_ipg))
			ninosused = 0;
		else
			ninosused = lastino - (c * sblock.fs_ipg);
		inostathead[c].il_numalloced = ninosused;
		if (ninosused == 0) {
			free(inostathead[c].il_stat);
			inostathead[c].il_stat = 0;
			continue;
		}
		if (ninosused != inosused) {
			struct inostat *ninfo;
			size_t ninospace;

			ninfo = reallocarray(info, ninosused, sizeof(*ninfo));
			if (ninfo == NULL) {
				pfatal("too many inodes %llu, or out of memory\n",
				    (unsigned long long)ninosused);
				exit(8);
			}
			ninospace = ninosused * sizeof(*ninfo);
			if (ninosused > inosused)
				memset(&ninfo[inosused], 0, ninospace - inospace);
			inostathead[c].il_stat = ninfo;
		}
	}
	info_fn = NULL;
	freeinodebuf();
}

static void
checkinode(ino_t inumber, struct inodesc *idesc)
{
	union dinode *dp;
	off_t kernmaxfilesize;
	struct zlncnt *zlnp;
	int ndb, j;
	mode_t mode;
	u_int64_t lndb;

	dp = getnextinode(inumber);
	mode = DIP(dp, di_mode) & IFMT;
	if (mode == 0) {
		if ((sblock.fs_magic == FS_UFS1_MAGIC &&
		     (memcmp(dp->dp1.di_db, ufs1_zino.di_db,
			NDADDR * sizeof(int32_t)) ||
		      memcmp(dp->dp1.di_ib, ufs1_zino.di_ib,
			NIADDR * sizeof(int32_t)) ||
		      dp->dp1.di_mode || dp->dp1.di_size)) ||
		    (sblock.fs_magic == FS_UFS2_MAGIC &&
		     (memcmp(dp->dp2.di_db, ufs2_zino.di_db,
			NDADDR * sizeof(daddr_t)) ||
		      memcmp(dp->dp2.di_ib, ufs2_zino.di_ib,
			NIADDR * sizeof(daddr_t)) ||
		      dp->dp2.di_mode || dp->dp2.di_size))) {
			pfatal("PARTIALLY ALLOCATED INODE I=%llu",
			    (unsigned long long)inumber);
			if (reply("CLEAR") == 1) {
				dp = ginode(inumber);
				clearinode(dp);
				inodirty();
			}
		}
		SET_ISTATE(inumber, USTATE);
		return;
	}
	lastino = inumber;
	/* This should match the file size limit in ffs_mountfs(). */
	kernmaxfilesize = FS_KERNMAXFILESIZE(getpagesize(), &sblock);
	if (DIP(dp, di_size) > kernmaxfilesize ||
	    DIP(dp, di_size) > sblock.fs_maxfilesize ||
	    (mode == IFDIR && DIP(dp, di_size) > MAXDIRSIZE)) {
		if (debug)
			printf("bad size %llu:",
			    (unsigned long long)DIP(dp, di_size));
		goto unknown;
	}
	if (!preen && mode == IFMT && reply("HOLD BAD BLOCK") == 1) {
		dp = ginode(inumber);
		DIP_SET(dp, di_size, sblock.fs_fsize);
		DIP_SET(dp, di_mode, IFREG|0600);
		inodirty();
	}
	lndb = howmany(DIP(dp, di_size), sblock.fs_bsize);
	ndb = lndb > (u_int64_t)INT_MAX ? -1 : (int)lndb;
	if (ndb < 0) {
		if (debug)
			printf("bad size %llu ndb %d:",
			    (unsigned long long)DIP(dp, di_size), ndb);
		goto unknown;
	}
	if (mode == IFBLK || mode == IFCHR)
		ndb++;
	if (mode == IFLNK) {
		/*
		 * Fake ndb value so direct/indirect block checks below
		 * will detect any garbage after symlink string.
		 */
		if (DIP(dp, di_size) < sblock.fs_maxsymlinklen ||
		    (sblock.fs_maxsymlinklen == 0 && DIP(dp, di_blocks) == 0)) {
			if (sblock.fs_magic == FS_UFS1_MAGIC)
				ndb = howmany(DIP(dp, di_size),
				    sizeof(int32_t));
			else
				ndb = howmany(DIP(dp, di_size),
				    sizeof(int64_t));
			if (ndb > NDADDR) {
				j = ndb - NDADDR;
				for (ndb = 1; j > 1; j--)
					ndb *= NINDIR(&sblock);
				ndb += NDADDR;
			}
		}
	}
	for (j = ndb; j < NDADDR; j++)
		if (DIP(dp, di_db[j]) != 0) {
			if (debug)
				printf("bad direct addr: %lld\n",
				    (long long)DIP(dp, di_db[j]));
			goto unknown;
		}
	for (j = 0, ndb -= NDADDR; ndb > 0; j++)
		ndb /= NINDIR(&sblock);
	for (; j < NIADDR; j++)
		if (DIP(dp, di_ib[j]) != 0) {
			if (debug)
				printf("bad indirect addr: %lld\n",
				    (long long)DIP(dp, di_ib[j]));
			goto unknown;
		}
	if (ftypeok(dp) == 0)
		goto unknown;
	n_files++;
	ILNCOUNT(inumber) = DIP(dp, di_nlink);
	if (DIP(dp, di_nlink) <= 0) {
		zlnp = malloc(sizeof *zlnp);
		if (zlnp == NULL) {
			pfatal("LINK COUNT TABLE OVERFLOW");
			if (reply("CONTINUE") == 0) {
				ckfini(0);
				errexit("%s", "");
			}
		} else {
			zlnp->zlncnt = inumber;
			zlnp->next = zlnhead;
			zlnhead = zlnp;
		}
	}
	if (mode == IFDIR) {
		if (DIP(dp, di_size) == 0)
			SET_ISTATE(inumber, DCLEAR);
		else
			SET_ISTATE(inumber, DSTATE);
		cacheino(dp, inumber);
	} else
		SET_ISTATE(inumber, FSTATE);
	SET_ITYPE(inumber, IFTODT(mode));
	badblk = dupblk = 0;
	idesc->id_number = inumber;
	(void)ckinode(dp, idesc);
	idesc->id_entryno *= btodb(sblock.fs_fsize);
	if (DIP(dp, di_blocks) != idesc->id_entryno) {
		pwarn("INCORRECT BLOCK COUNT I=%llu (%lld should be %lld)",
		    (unsigned long long)inumber, (long long)DIP(dp, di_blocks),
		    (long long)idesc->id_entryno);
		if (preen)
			printf(" (CORRECTED)\n");
		else if (reply("CORRECT") == 0)
			return;
		dp = ginode(inumber);
		DIP_SET(dp, di_blocks, idesc->id_entryno);
		inodirty();
	}
	return;
unknown:
	pfatal("UNKNOWN FILE TYPE I=%llu", (unsigned long long)inumber);
	SET_ISTATE(inumber, FCLEAR);
	if (reply("CLEAR") == 1) {
		SET_ISTATE(inumber, USTATE);
		dp = ginode(inumber);
		clearinode(dp);
		inodirty();
	}
}

int
pass1check(struct inodesc *idesc)
{
	int res = KEEPON;
	int anyout, nfrags;
	daddr_t blkno = idesc->id_blkno;
	struct dups *dlp;
	struct dups *new;

	if ((anyout = chkrange(blkno, idesc->id_numfrags)) != 0) {
		blkerror(idesc->id_number, "BAD", blkno);
		if (badblk++ >= MAXBAD) {
			pwarn("EXCESSIVE BAD BLKS I=%llu",
			    (unsigned long long)idesc->id_number);
			if (preen)
				printf(" (SKIPPING)\n");
			else if (reply("CONTINUE") == 0) {
				ckfini(0);
				errexit("%s", "");
			}
			return (STOP);
		}
	}
	for (nfrags = idesc->id_numfrags; nfrags > 0; blkno++, nfrags--) {
		if (anyout && chkrange(blkno, 1)) {
			res = SKIP;
		} else if (!testbmap(blkno)) {
			n_blks++;
			setbmap(blkno);
		} else {
			blkerror(idesc->id_number, "DUP", blkno);
			if (dupblk++ >= MAXDUP) {
				pwarn("EXCESSIVE DUP BLKS I=%llu",
				    (unsigned long long)idesc->id_number);
				if (preen)
					printf(" (SKIPPING)\n");
				else if (reply("CONTINUE") == 0) {
					ckfini(0);
					errexit("%s", "");
				}
				return (STOP);
			}
			new = malloc(sizeof(struct dups));
			if (new == NULL) {
				pfatal("DUP TABLE OVERFLOW.");
				if (reply("CONTINUE") == 0) {
					ckfini(0);
					errexit("%s", "");
				}
				return (STOP);
			}
			new->dup = blkno;
			if (muldup == 0) {
				duplist = muldup = new;
				new->next = 0;
			} else {
				new->next = muldup->next;
				muldup->next = new;
			}
			for (dlp = duplist; dlp != muldup; dlp = dlp->next)
				if (dlp->dup == blkno)
					break;
			if (dlp == muldup && dlp->dup != blkno)
				muldup = new;
		}
		/*
		 * count the number of blocks found in id_entryno
		 */
		idesc->id_entryno++;
	}
	return (res);
}
@


1.43
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.42 2015/01/20 18:22:21 deraadt Exp $	*/
a128 2
			if (inosused < 0)
				inosused = 0;
d131 1
a131 1
 		 * Allocate inoinfo structures for the allocated inodes.
@


1.42
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.41 2015/01/16 06:39:57 deraadt Exp $	*/
d300 1
a300 1
		zlnp =  malloc(sizeof *zlnp);
@


1.41
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.40 2014/10/14 15:01:51 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG MIN setbit btodb isset */
@


1.40
log
@rely on reallocarray() to give us the overflow detection, rather than
hand-crafting a solution.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.39 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d43 1
@


1.39
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.38 2013/06/11 16:42:04 deraadt Exp $	*/
d176 1
a176 1
			size_t ninospace = ninosused * sizeof(*ninfo);
d178 3
a180 2
			if (ninospace / sizeof(*info) != ninosused) {
				pfatal("too many inodes %llu\n",
d184 1
a184 6
			ninfo = realloc(info, ninospace);
			if (ninfo == NULL) {
				pfatal("cannot realloc %zu bytes to %zu "
				    "for inoinfo\n", inospace, ninospace);
				exit(8);
			}
d186 1
a186 1
				(void)memset(&ninfo[inosused], 0, ninospace - inospace);
@


1.38
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.37 2013/04/24 13:46:29 deraadt Exp $	*/
d142 1
a142 2
			errexit("cannot alloc %u bytes for inoinfo",
			    (unsigned)(sizeof(struct inostat) * inosused));
d177 1
d285 2
a286 2
				printf("bad direct addr: %ld\n",
				    (long)DIP(dp, di_db[j]));
d294 2
a295 2
				printf("bad indirect addr: %ld\n",
				    (long)DIP(dp, di_ib[j]));
d330 3
a332 3
		pwarn("INCORRECT BLOCK COUNT I=%llu (%ld should be %d)",
		    (unsigned long long)inumber, (long)DIP(dp, di_blocks),
		    idesc->id_entryno);
@


1.37
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.36 2011/05/02 22:23:59 chl Exp $	*/
d48 2
a49 2
static daddr64_t badblk;
static daddr64_t dupblk;
d70 1
a70 1
	daddr64_t i, cgd;
d219 1
a219 1
			NDADDR * sizeof(daddr64_t)) ||
d221 1
a221 1
			NIADDR * sizeof(daddr64_t)) ||
d358 1
a358 1
	daddr64_t blkno = idesc->id_blkno;
@


1.36
log
@Remove unused variable

ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.35 2011/04/24 07:07:03 otto Exp $	*/
d57 3
a59 2
	return (snprintf(buf, buflen, "phase 1, inode %d/%d",
	    info_inumber, sblock.fs_ipg * sblock.fs_ncg) > 0);
d223 2
a224 1
			pfatal("PARTIALLY ALLOCATED INODE I=%u", inumber);
d330 3
a332 2
		pwarn("INCORRECT BLOCK COUNT I=%u (%ld should be %d)",
		    inumber, (long)DIP(dp, di_blocks), idesc->id_entryno);
d343 1
a343 1
	pfatal("UNKNOWN FILE TYPE I=%u", inumber);
d365 2
a366 2
			pwarn("EXCESSIVE BAD BLKS I=%u",
				idesc->id_number);
d385 2
a386 2
				pwarn("EXCESSIVE DUP BLKS I=%u",
					idesc->id_number);
@


1.35
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.34 2011/04/16 16:37:21 otto Exp $	*/
a204 1
	char *symbuf;
@


1.34
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.33 2010/07/09 06:41:17 otto Exp $	*/
a261 28
		 * Note that the old fastlink format always had di_blocks set
		 * to 0.  Other than that we no longer use the `spare' field
		 * (which is now the extended uid) for sanity checking, the
		 * new format is the same as the old.  We simply ignore the
		 * conversion altogether.  - mycroft, 19MAY1994
		 */
		if (sblock.fs_magic == FS_UFS1_MAGIC && doinglevel2 &&
		    DIP(dp, di_size) > 0 &&
		    DIP(dp, di_size) < MAXSYMLINKLEN_UFS1 &&
		    DIP(dp, di_blocks) != 0) {
			symbuf = alloca(secsize);
			if (bread(fsreadfd, symbuf,
			    fsbtodb(&sblock, DIP(dp, di_db[0])),
			    (long)secsize) != 0)
				errexit("cannot read symlink\n");
			if (debug) {
				symbuf[DIP(dp, di_size)] = 0;
				printf("convert symlink %d(%s) of size %llu\n",
					inumber, symbuf,
					(unsigned long long)DIP(dp, di_size));
			}
			dp = ginode(inumber);
			memcpy(dp->dp1.di_shortlink, symbuf,
			    (long)DIP(dp, di_size));
			DIP_SET(dp, di_blocks, 0);
			inodirty();
		}
		/*
a323 10
	if (sblock.fs_magic == FS_UFS1_MAGIC && doinglevel2 &&
	   (dp->dp1.di_ouid != (u_short)-1 ||
	    dp->dp1.di_ogid != (u_short)-1)) {
		dp = ginode(inumber);
		DIP_SET(dp, di_uid, dp->dp1.di_ouid);
		dp->dp1.di_ouid = -1;
		DIP_SET(dp, di_gid, dp->dp1.di_ogid);
		dp->dp1.di_ogid = -1;
		inodirty();
	}
@


1.33
log
@Avoid crashes by using correct types for block numbers, which can grow
large on very large filesystems; reported by Benny Lofgren; partly
from FreeBSD. ok deraadt@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.32 2009/10/27 23:59:32 deraadt Exp $	*/
d64 4
a68 2
	ino_t inumber, inosused;
	int c;
d70 1
d107 40
a146 1
		cginosused[c] = inosused;
d149 2
a150 1
			if (inumber < ROOTINO)
d152 1
d155 37
d328 1
a328 1
	lncntp[inumber] = DIP(dp, di_nlink);
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.31 2009/05/29 07:57:43 otto Exp $	*/
d66 2
a67 1
	int c, i, cgd;
@


1.31
log
@catch funny values of cg_initediblk; make fsck_ffs more robust
against forms of cg header corruption as experienced by todd@@; ok
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.30 2008/11/09 15:54:54 chl Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)pass1.c	8.1 (Berkeley) 6/5/93";
#else
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.30 2008/11/09 15:54:54 chl Exp $";
#endif
#endif /* not lint */
@


1.30
log
@add missing header needed by getpagesize().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.29 2008/11/06 18:01:44 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.29 2008/11/06 18:01:44 deraadt Exp $";
d105 1
a105 1
		if (sblock.fs_magic == FS_UFS2_MAGIC)
d107 3
a109 1
		else
@


1.29
log
@Have called pass pagesize into FS_KERNMAXFILESIZE(), because there is no
automatic symbol that has this information.  PAGE_SIZE is simply not
portable, or even fixed on some systems.
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.28 2008/11/02 08:54:10 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.28 2008/11/02 08:54:10 otto Exp $";
d50 1
@


1.28
log
@check for the maximum file size to avoid some out-of-bounds accesses;
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.27 2008/06/10 23:10:29 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.27 2008/06/10 23:10:29 otto Exp $";
d158 1
a158 1
	kernmaxfilesize = FS_KERNMAXFILESIZE(&sblock);
@


1.27
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.26 2007/06/25 19:59:55 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.26 2007/06/25 19:59:55 otto Exp $";
d124 1
d157 5
a161 2
	if (/* DIP(dp, di_size) < 0 || */
	    DIP(dp, di_size) + sblock.fs_bsize - 1 < DIP(dp, di_size)) {
@


1.26
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.25 2007/06/01 23:42:35 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.25 2007/06/01 23:42:35 pedro Exp $";
d152 1
a152 1
		statemap[inumber] = USTATE;
d264 1
a264 1
			statemap[inumber] = DCLEAR;
d266 1
a266 1
			statemap[inumber] = DSTATE;
d269 2
a270 2
		statemap[inumber] = FSTATE;
	typemap[inumber] = IFTODT(mode);
d299 1
a299 1
	statemap[inumber] = FCLEAR;
d301 1
a301 1
		statemap[inumber] = USTATE;
@


1.25
log
@ufs1_daddr_t cleanup, okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.24 2007/06/01 06:41:33 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.24 2007/06/01 06:41:33 deraadt Exp $";
d55 2
a56 2
static daddr_t badblk;
static daddr_t dupblk;
d313 1
a313 1
	daddr_t blkno = idesc->id_blkno;
@


1.24
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.23 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.23 2007/04/10 16:08:17 millert Exp $";
d135 1
a135 1
			NDADDR * sizeof(ufs1_daddr_t)) ||
d137 1
a137 1
			NIADDR * sizeof(ufs1_daddr_t)) ||
d216 1
a216 1
				    sizeof(ufs1_daddr_t));
d219 1
a219 1
				    sizeof(daddr64_t));
@


1.23
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.22 2007/03/19 13:27:47 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.22 2007/03/19 13:27:47 pedro Exp $";
d141 1
a141 1
			NDADDR * sizeof(ufs2_daddr_t)) ||
d143 1
a143 1
			NIADDR * sizeof(ufs2_daddr_t)) ||
d219 1
a219 1
				    sizeof(ufs2_daddr_t));
@


1.22
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.21 2007/02/12 16:35:55 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.21 2007/02/12 16:35:55 otto Exp $";
d72 1
a72 1
	ino_t inumber;
d87 1
a87 1
	i = sblock.fs_ffs1_csaddr;
a96 1
	inumber = 0;
a97 1
	resetinodebuf();
d101 9
a109 1
		for (i = 0; i < sblock.fs_ipg; i++, inumber++) {
d123 1
a123 1
	struct ufs1_dinode *dp;
d131 1
a131 1
	mode = dp->di_mode & IFMT;
d133 12
a144 3
		if (memcmp(dp->di_db, zino.di_db, NDADDR * sizeof(daddr_t)) ||
		    memcmp(dp->di_ib, zino.di_ib, NIADDR * sizeof(daddr_t)) ||
		    dp->di_mode || dp->di_size) {
d156 2
a157 2
	if (/* dp->di_size < 0 || */
	    dp->di_size + sblock.fs_bsize - 1 < dp->di_size) {
d159 2
a160 1
			printf("bad size %llu:", (unsigned long long)dp->di_size);
d165 2
a166 2
		dp->di_size = sblock.fs_fsize;
		dp->di_mode = IFREG|0600;
d169 1
a169 1
	lndb = howmany(dp->di_size, sblock.fs_bsize);
d174 1
a174 1
			    (unsigned long long)dp->di_size, ndb);
d187 4
a190 3
		if (doinglevel2 &&
		    dp->di_size > 0 && dp->di_size < MAXSYMLINKLEN_UFS1 &&
		    dp->di_blocks != 0) {
d193 1
a193 1
			    fsbtodb(&sblock, dp->di_db[0]),
d197 1
a197 1
				symbuf[dp->di_size] = 0;
d200 1
a200 1
					(unsigned long long)dp->di_size);
d203 3
a205 2
			memcpy(dp->di_shortlink, symbuf, (long)dp->di_size);
			dp->di_blocks = 0;
d212 8
a219 3
		if (dp->di_size < sblock.fs_maxsymlinklen ||
		    (sblock.fs_maxsymlinklen == 0 && dp->di_blocks == 0)) {
			ndb = howmany(dp->di_size, sizeof(daddr_t));
d229 1
a229 1
		if (dp->di_db[j] != 0) {
d231 2
a232 1
				printf("bad direct addr: %d\n", dp->di_db[j]);
d238 1
a238 1
		if (dp->di_ib[j] != 0) {
d240 2
a241 2
				printf("bad indirect addr: %d\n",
					dp->di_ib[j]);
d247 2
a248 2
	lncntp[inumber] = dp->di_nlink;
	if (dp->di_nlink <= 0) {
d263 1
a263 1
		if (dp->di_size == 0)
d271 3
a273 1
	if (doinglevel2 && (dp->di_ouid != (u_short)-1 || dp->di_ogid != (u_short)-1)) {
d275 4
a278 4
		dp->di_uid = dp->di_ouid;
		dp->di_ouid = -1;
		dp->di_gid = dp->di_ogid;
		dp->di_ogid = -1;
d285 3
a287 3
	if (dp->di_blocks != idesc->id_entryno) {
		pwarn("INCORRECT BLOCK COUNT I=%u (%d should be %d)",
		    inumber, dp->di_blocks, idesc->id_entryno);
d293 1
a293 1
		dp->di_blocks = idesc->id_entryno;
@


1.21
log
@detect truncation of block number, which can happen which trashed
inodes; ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.20 2006/03/22 20:24:32 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.20 2006/03/22 20:24:32 deraadt Exp $";
d87 1
a87 1
	i = sblock.fs_csaddr;
@


1.20
log
@earlier asprintf diff caused malloc in signal handler.  clarify the
code a bit more so that this mistake will not be done again
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.18 2005/12/19 15:18:01 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.18 2005/12/19 15:18:01 pedro Exp $";
d122 1
d153 2
a154 1
	ndb = howmany(dp->di_size, sblock.fs_bsize);
@


1.19
log
@use asprintf instead of a static buffer; dhill, tested by pedro
@
text
@d62 1
a62 1
pass1_info(char *buf)
d64 1
a64 1
	return (asprintf(&buf, "phase 1, inode %d/%d",
@


1.18
log
@Add and use a few more constants and macros needed by UFS2
No functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.17 2005/04/16 18:15:41 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.17 2005/04/16 18:15:41 millert Exp $";
d62 1
a62 1
pass1_info(char *buf, int buflen)
d64 1
a64 1
	return (snprintf(buf, buflen, "phase 1, inode %d/%d",
@


1.17
log
@Since the return value from the *_info functions is only actually used as a
boolean, make it so.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.16 2005/04/16 17:37:25 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.16 2005/04/16 17:37:25 deraadt Exp $";
d170 1
a170 1
		    dp->di_size > 0 && dp->di_size < MAXSYMLINKLEN &&
@


1.16
log
@while snprintf and strlcpy and strlcat have this nice >buflen API (and the
-1 mess as well), it is probably not wise to make other functions do the same
thing.  make them return strlen().  ok uwe marco
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.15 2003/10/11 01:43:45 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.15 2003/10/11 01:43:45 tedu Exp $";
d64 2
a65 4
	if (snprintf(buf, buflen, "phase 1, inode %d/%d",
	    info_inumber, sblock.fs_ipg * sblock.fs_ncg) > 0)
		return (strlen(buf));
	return (0);
@


1.15
log
@consistent newlines, from tom cosgrove at arches-consulting.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.14 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.14 2003/08/25 23:28:15 tedu Exp $";
d64 4
a67 2
	return snprintf(buf, buflen, "phase 1, inode %d/%d",
		info_inumber, sblock.fs_ipg * sblock.fs_ncg);
@


1.14
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.13 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.13 2003/06/02 20:06:15 millert Exp $";
d176 1
a176 1
				errexit("cannot read symlink");
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.12 2002/08/23 09:09:04 gluk Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.12 2002/08/23 09:09:04 gluk Exp $";
d117 1
a117 1
	struct dinode *dp;
@


1.12
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.11 2002/02/16 21:27:34 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass1.c,v 1.11 2002/02/16 21:27:34 millert Exp $";
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.10 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.10 2001/11/05 07:39:16 mpech Exp $";
d66 1
a66 3
pass1_info(buf, buflen)
	char * buf;
	int buflen;
d73 1
a73 1
pass1()
d119 1
a119 3
checkinode(inumber, idesc)
	ino_t inumber;
	struct inodesc *idesc;
d227 1
a227 1
		zlnp = (struct zlncnt *)malloc(sizeof *zlnp);
d249 1
a249 2
	if (doinglevel2 &&
	    (dp->di_ouid != (u_short)-1 || dp->di_ogid != (u_short)-1)) {
d285 1
a285 2
pass1check(idesc)
	struct inodesc *idesc;
d326 1
a326 1
			new = (struct dups *)malloc(sizeof(struct dups));
@


1.10
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.9 2001/07/07 18:26:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.9 2001/07/07 18:26:12 deraadt Exp $";
d61 1
a61 1
static void checkinode __P((ino_t, struct inodesc *));
@


1.9
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d123 1
a123 1
	register struct inodesc *idesc;
d125 1
a125 1
	register struct dinode *dp;
d291 1
a291 1
	register struct inodesc *idesc;
d296 1
a296 1
	register struct dups *dlp;
@


1.8
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.7 1999/03/01 07:45:17 d Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.7 1999/03/01 07:45:17 d Exp $";
d151 1
a151 1
			printf("bad size %qu:", dp->di_size);
d163 2
a164 2
			printf("bad size %qu ndb %d:",
				dp->di_size, ndb);
d187 3
a189 2
				printf("convert symlink %d(%s) of size %qd\n",
					inumber, symbuf, dp->di_size);
@


1.7
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.6 1997/10/06 20:22:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.6 1997/10/06 20:22:34 deraadt Exp $";
d233 2
a234 1
			if (reply("CONTINUE") == 0)
d236 1
d305 2
a306 1
			else if (reply("CONTINUE") == 0)
d308 1
d325 2
a326 1
				else if (reply("CONTINUE") == 0)
d328 1
d334 2
a335 1
				if (reply("CONTINUE") == 0)
d337 1
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.4 1996/10/20 08:36:36 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.4 1996/10/20 08:36:36 tholo Exp $";
d63 11
d77 1
a79 1
	struct inodesc idesc;
d106 2
d110 1
d116 1
@


1.5
log
@VFS Lite2 Changes
@
text
@d218 1
a218 2
			if (reply("CONTINUE") == 0) {
				ckfini(0);
a219 1
			}
d288 1
a288 2
			else if (reply("CONTINUE") == 0) {
				ckfini(0);
a289 1
			}
d306 1
a306 2
				else if (reply("CONTINUE") == 0) {
					ckfini(0);
a307 1
				}
d313 1
a313 2
				if (reply("CONTINUE") == 0) {
					ckfini(0);
a314 1
				}
@


1.4
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.3 1996/06/23 14:30:30 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.3 1996/06/23 14:30:30 deraadt Exp $";
d218 2
a219 1
			if (reply("CONTINUE") == 0)
d221 1
d290 2
a291 1
			else if (reply("CONTINUE") == 0)
d293 1
d310 2
a311 1
				else if (reply("CONTINUE") == 0)
d313 1
d319 2
a320 1
				if (reply("CONTINUE") == 0)
d322 1
@


1.3
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: pass1.c,v 1.14 1996/01/18 21:55:27 mycroft Exp $	*/
/*	$NetBSD: pass1.c,v 1.14 1996/01/18 21:55:27 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.14 1996/01/18 21:55:27 mycroft Exp $";
d57 1
d61 1
a61 3
int pass1check();
struct dinode *getnextinode();
void checkinode __P((ino_t, struct inodesc *));
d105 1
a105 1
void
d122 1
a122 1
			pfatal("PARTIALLY ALLOCATED INODE I=%lu", inumber);
d172 2
a173 2
				printf("convert symlink %d(%s) of size %d\n",
					inumber, symbuf, (long)dp->di_size);
d198 1
a198 1
				printf("bad direct addr: %ld\n", dp->di_db[j]);
d206 1
a206 1
				printf("bad indirect addr: %ld\n",
d219 1
a219 1
				errexit("");
d249 1
a249 1
		pwarn("INCORRECT BLOCK COUNT I=%lu (%ld should be %ld)",
d261 1
a261 1
	pfatal("UNKNOWN FILE TYPE I=%lu", inumber);
d284 1
a284 1
			pwarn("EXCESSIVE BAD BLKS I=%lu",
d289 1
a289 1
				errexit("");
d302 1
a302 1
				pwarn("EXCESSIVE DUP BLKS I=%lu",
d307 1
a307 1
					errexit("");
d314 1
a314 1
					errexit("");
@


1.2
log
@use fs_csaddr to find the cg summary area; from mouse@@collatz.mccrim.mcgill.edu; netbsd pr#1366
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: pass1.c,v 1.14 1996/01/18 21:55:27 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pass1.c,v 1.13 1995/03/18 14:55:49 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: pass1.c,v 1.13 1995/03/18 14:55:49 cgd Exp $";
d75 1
a75 1
		if (c == 0) {
d77 1
a77 2
			cgd += howmany(sblock.fs_cssize, sblock.fs_fsize);
		} else
d82 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
