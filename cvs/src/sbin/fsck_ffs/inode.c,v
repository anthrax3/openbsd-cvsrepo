head	1.48;
access;
symbols
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.8
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.6
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.12
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.10
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.8
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.6
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.8
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.6
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.4
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2016.12.16.17.44.59;	author krw;	state Exp;
branches;
next	1.47;
commitid	q7MaMOobu9Z5raUb;

1.47
date	2015.12.10.17.26.59;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	82PdNqu2kKAuXPfA;

1.46
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	F55lwc3gS4GN2mLs;

1.45
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	Uu5nFG3wCl0LACBb;

1.44
date	2014.10.08.16.28.38;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	floDHYuUloEFVxnt;

1.43
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.42;
commitid	qlzrzgnJ4ZiiF6XQ;

1.42
date	2014.05.21.18.53.05;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2013.11.11.18.51.06;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.03.02.22.07;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.01.17.36.18;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.08.14.38.40;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.29.18.06.10;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.12.16.41.07;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.24.13.24.58;	author bluhm;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.11.01.43.45;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.25.04.23.26;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.26.00.39.28;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.07.18.26.12;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.15.19.32.39;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.08.06.20.41.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.10.11.20.19.36;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.20.22.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.15.33.33;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.06.25.18.12.13;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.22.20.10.48;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.10.20.08.36.34;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.10.12.03.06.54;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.06.23.14.30.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.28.12.37.26;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.18.16.41.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.16.13.50.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.57.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Eliminate some gcc warnings about 'unused variables', mostly by
adding appropriate #ifdef's around declarations.

ok millert@@ (with a tweak I will commit separately)
@
text
@/*	$OpenBSD: inode.c,v 1.47 2015/12/10 17:26:59 mmcc Exp $	*/
/*	$NetBSD: inode.c,v 1.23 1996/10/11 20:15:47 thorpej Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* setbit btodb */
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#ifndef SMALL
#include <pwd.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "fsck.h"
#include "fsutil.h"
#include "extern.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

static ino_t startinum;

static int iblock(struct inodesc *, long, off_t);

int
ckinode(union dinode *dp, struct inodesc *idesc)
{
	long ret, ndb, offset;
	union dinode dino;
	off_t sizepb, remsize;
	mode_t mode;
	int i;
	char pathbuf[PATH_MAX + 1];

	if (idesc->id_fix != IGNORE)
		idesc->id_fix = DONTKNOW;
	idesc->id_entryno = 0;
	idesc->id_filesize = DIP(dp, di_size);
	mode = DIP(dp, di_mode) & IFMT;
	if (mode == IFBLK || mode == IFCHR || (mode == IFLNK &&
	    (DIP(dp, di_size) < sblock.fs_maxsymlinklen ||
	     (sblock.fs_maxsymlinklen == 0 && DIP(dp, di_blocks) == 0))))
		return (KEEPON);
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		dino.dp1 = dp->dp1;
	else
		dino.dp2 = dp->dp2;
	ndb = howmany(DIP(&dino, di_size), sblock.fs_bsize);
	for (i = 0; i < NDADDR; i++) {
		if (--ndb == 0 && (offset = blkoff(&sblock,
		    DIP(&dino, di_size))) != 0)
			idesc->id_numfrags =
				numfrags(&sblock, fragroundup(&sblock, offset));
		else
			idesc->id_numfrags = sblock.fs_frag;
		if (DIP(&dino, di_db[i]) == 0) {
			if (idesc->id_type == DATA && ndb >= 0) {
				/* An empty block in a directory XXX */
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
				    pathbuf);
				if (reply("ADJUST LENGTH") == 1) {
					dp = ginode(idesc->id_number);
					DIP_SET(dp, di_size,
					    i * sblock.fs_bsize);
					printf(
					    "YOU MUST RERUN FSCK AFTERWARDS\n");
					rerun = 1;
					inodirty();
				}
			}
			continue;
		}
		idesc->id_blkno = DIP(&dino, di_db[i]);
		if (idesc->id_type == ADDR)
			ret = (*idesc->id_func)(idesc);
		else
			ret = dirscan(idesc);
		if (ret & STOP)
			return (ret);
	}
	idesc->id_numfrags = sblock.fs_frag;
	remsize = DIP(&dino, di_size) - sblock.fs_bsize * NDADDR;
	sizepb = sblock.fs_bsize;
	for (i = 0; i < NIADDR; i++) {
		if (DIP(&dino, di_ib[i])) {
			idesc->id_blkno = DIP(&dino, di_ib[i]);
			ret = iblock(idesc, i + 1, remsize);
			if (ret & STOP)
				return (ret);
		} else {
			if (idesc->id_type == DATA && remsize > 0) {
				/* An empty block in a directory XXX */
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
				    pathbuf);
				if (reply("ADJUST LENGTH") == 1) {
					dp = ginode(idesc->id_number);
					DIP_SET(dp, di_size,
					     DIP(dp, di_size) - remsize);
					remsize = 0;
					printf(
					    "YOU MUST RERUN FSCK AFTERWARDS\n");
					rerun = 1;
					inodirty();
					break;
				}
			}
		}
		sizepb *= NINDIR(&sblock);
		remsize -= sizepb;
	}
	return (KEEPON);
}

static int
iblock(struct inodesc *idesc, long ilevel, off_t isize)
{
	struct bufarea *bp;
	int i, n, (*func)(struct inodesc *), nif;
	off_t sizepb;
	char buf[BUFSIZ];
	char pathbuf[PATH_MAX + 1];
	union dinode *dp;

	if (idesc->id_type == ADDR) {
		func = idesc->id_func;
		if (((n = (*func)(idesc)) & KEEPON) == 0)
			return (n);
	} else
		func = dirscan;
	if (isize < 0 || chkrange(idesc->id_blkno, idesc->id_numfrags))
		return (SKIP);
	bp = getdatablk(idesc->id_blkno, sblock.fs_bsize);
	ilevel--;
	for (sizepb = sblock.fs_bsize, i = 0; i < ilevel; i++)
		sizepb *= NINDIR(&sblock);
	if (howmany(isize, sizepb) > NINDIR(&sblock))
		nif = NINDIR(&sblock);
	else
		nif = howmany(isize, sizepb);
	if (idesc->id_func == pass1check && nif < NINDIR(&sblock)) {
		for (i = nif; i < NINDIR(&sblock); i++) {
			if (IBLK(bp, i) == 0)
				continue;
			(void)snprintf(buf, sizeof buf,
			    "PARTIALLY TRUNCATED INODE I=%llu",
			    (unsigned long long)idesc->id_number);
			if (preen)
				pfatal("%s", buf);
			else if (dofix(idesc, buf)) {
				IBLK_SET(bp, i, 0);
				dirty(bp);
			}
		}
		flush(fswritefd, bp);
	}
	for (i = 0; i < nif; i++) {
		if (IBLK(bp, i)) {
			idesc->id_blkno = IBLK(bp, i);
			if (ilevel == 0)
				n = (*func)(idesc);
			else
				n = iblock(idesc, ilevel, isize);
			if (n & STOP) {
				bp->b_flags &= ~B_INUSE;
				return (n);
			}
		} else {
			if (idesc->id_type == DATA && isize > 0) {
				/* An empty block in a directory XXX */
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
				    pathbuf);
				if (reply("ADJUST LENGTH") == 1) {
					dp = ginode(idesc->id_number);
					DIP_SET(dp, di_size,
					    DIP(dp, di_size) - isize);
					isize = 0;
					printf(
					    "YOU MUST RERUN FSCK AFTERWARDS\n");
					rerun = 1;
					inodirty();
					bp->b_flags &= ~B_INUSE;
					return(STOP);
				}
			}
		}
		isize -= sizepb;
	}
	bp->b_flags &= ~B_INUSE;
	return (KEEPON);
}

/*
 * Check that a block in a legal block number.
 * Return 0 if in range, 1 if out of range.
 */
int
chkrange(daddr_t blk, int cnt)
{
	int c;

	if (cnt <= 0 || blk <= 0 || blk > maxfsblock ||
	    cnt - 1 > maxfsblock - blk)
		return (1);
	if (cnt > sblock.fs_frag ||
	    fragnum(&sblock, blk) + cnt > sblock.fs_frag) {
		if (debug)
			printf("bad size: blk %lld, offset %lld, size %d\n",
			    (long long)blk, (long long)fragnum(&sblock, blk),
			    cnt);
		return (1);
	}
	c = dtog(&sblock, blk);
	if (blk < cgdmin(&sblock, c)) {
		if ((blk + cnt) > cgsblock(&sblock, c)) {
			if (debug) {
				printf("blk %lld < cgdmin %lld;",
				    (long long)blk,
				    (long long)cgdmin(&sblock, c));
				printf(" blk + cnt %lld > cgsbase %lld\n",
				    (long long)(blk + cnt),
				    (long long)cgsblock(&sblock, c));
			}
			return (1);
		}
	} else {
		if ((blk + cnt) > cgbase(&sblock, c+1)) {
			if (debug)  {
				printf("blk %lld >= cgdmin %lld;",
				    (long long)blk,
				    (long long)cgdmin(&sblock, c));
				printf(" blk + cnt %lld > sblock.fs_fpg %d\n",
				    (long long)(blk+cnt), sblock.fs_fpg);
			}
			return (1);
		}
	}
	return (0);
}

/*
 * General purpose interface for reading inodes.
 */
union dinode *
ginode(ino_t inumber)
{
	daddr_t iblk;

	if (inumber < ROOTINO || inumber > maxino)
		errexit("bad inode number %llu to ginode\n",
		    (unsigned long long)inumber);
	if (startinum == 0 ||
	    inumber < startinum || inumber >= startinum + INOPB(&sblock)) {
		iblk = ino_to_fsba(&sblock, inumber);
		if (pbp != 0)
			pbp->b_flags &= ~B_INUSE;
		pbp = getdatablk(iblk, sblock.fs_bsize);
		startinum = (inumber / INOPB(&sblock)) * INOPB(&sblock);
	}
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		return ((union dinode *)
		    &pbp->b_un.b_dinode1[inumber % INOPB(&sblock)]);
	return ((union dinode *)&pbp->b_un.b_dinode2[inumber % INOPB(&sblock)]);
}

/*
 * Special purpose version of ginode used to optimize first pass
 * over all the inodes in numerical order.
 */
ino_t nextino, lastinum;
long readcnt, readpercg, fullcnt, inobufsize, partialcnt, partialsize;
static caddr_t inodebuf;

union dinode *
getnextinode(ino_t inumber)
{
	long size;
	daddr_t dblk;
	union dinode *dp;
	static caddr_t nextinop;

	if (inumber != nextino++ || inumber > maxino)
		errexit("bad inode number %llu to nextinode %llu\n",
		    (unsigned long long)inumber,
		    (unsigned long long)nextino);
	if (inumber >= lastinum) {
		readcnt++;
		dblk = fsbtodb(&sblock, ino_to_fsba(&sblock, lastinum));
		if (readcnt % readpercg == 0) {
			size = partialsize;
			lastinum += partialcnt;
		} else {
			size = inobufsize;
			lastinum += fullcnt;
		}
		(void)bread(fsreadfd, inodebuf, dblk, size);
		nextinop = inodebuf;
	}
	dp = (union dinode *)nextinop;
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		nextinop += sizeof(struct ufs1_dinode);
	else
		nextinop += sizeof(struct ufs2_dinode);
	return (dp);
}

void
setinodebuf(ino_t inum)
{

	startinum = 0;
	nextino = inum;
	lastinum = inum;
	readcnt = 0;
	if (inodebuf != NULL)
		return;
	inobufsize = blkroundup(&sblock, INOBUFSIZE);
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		fullcnt = inobufsize / sizeof(struct ufs1_dinode);
	else
		fullcnt = inobufsize / sizeof(struct ufs2_dinode);
	readpercg = sblock.fs_ipg / fullcnt;
	partialcnt = sblock.fs_ipg % fullcnt;
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		partialsize = partialcnt * sizeof(struct ufs1_dinode);
	else
		partialsize = partialcnt * sizeof(struct ufs2_dinode);
	if (partialcnt != 0) {
		readpercg++;
	} else {
		partialcnt = fullcnt;
		partialsize = inobufsize;
	}
	if (inodebuf == NULL &&
	    (inodebuf = malloc((unsigned)inobufsize)) == NULL)
		errexit("Cannot allocate space for inode buffer\n");
}

void
freeinodebuf(void)
{

	free(inodebuf);
	inodebuf = NULL;
}

/*
 * Routines to maintain information about directory inodes.
 * This is built during the first pass and used during the
 * second and third passes.
 *
 * Enter inodes into the cache.
 */
void
cacheino(union dinode *dp, ino_t inumber)
{
	struct inoinfo *inp;
	struct inoinfo **inpp, **newinpsort;
	unsigned int blks;
	long newlistmax;
	int i;

	blks = howmany(DIP(dp, di_size), sblock.fs_bsize);
	if (blks > NDADDR)
		blks = NDADDR + NIADDR;
	inp = malloc(sizeof(*inp) + (blks ? blks - 1 : 0) * sizeof(daddr_t));
	if (inp == NULL)
		errexit("cannot allocate memory for inode cache\n");
	inpp = &inphead[inumber % numdirs];
	inp->i_nexthash = *inpp;
	*inpp = inp;
	inp->i_child = inp->i_sibling = 0;
	if (inumber == ROOTINO)
		inp->i_parent = ROOTINO;
	else
		inp->i_parent = 0;
	inp->i_dotdot = 0;
	inp->i_number = inumber;
	inp->i_isize = DIP(dp, di_size);
	inp->i_numblks = blks;
	for (i = 0; i < (blks < NDADDR ? blks : NDADDR); i++)
		inp->i_blks[i] = DIP(dp, di_db[i]);
	if (blks > NDADDR)
		for (i = 0; i < NIADDR; i++)
			inp->i_blks[NDADDR + i] = DIP(dp, di_ib[i]);
	if (inplast == listmax) {
		newlistmax = listmax + 100;
		newinpsort = reallocarray(inpsort,
		    (unsigned)newlistmax, sizeof(struct inoinfo *));
		if (newinpsort == NULL)
			errexit("cannot increase directory list");
		inpsort = newinpsort;
		listmax = newlistmax;
	}
	inpsort[inplast++] = inp;
}

/*
 * Look up an inode cache structure.
 */
struct inoinfo *
getinoinfo(ino_t inumber)
{
	struct inoinfo *inp;

	for (inp = inphead[inumber % numdirs]; inp; inp = inp->i_nexthash) {
		if (inp->i_number != inumber)
			continue;
		return (inp);
	}
	errexit("cannot find inode %llu\n", (unsigned long long)inumber);
	return (NULL);
}

/*
 * Clean up all the inode cache structure.
 */
void
inocleanup(void)
{
	struct inoinfo **inpp;

	if (inphead == NULL)
		return;
	for (inpp = &inpsort[inplast - 1]; inpp >= inpsort; inpp--)
		free(*inpp);
	free(inphead);
	free(inpsort);
	inphead = inpsort = NULL;
}

void
inodirty(void)
{
	dirty(pbp);
}

void
clri(struct inodesc *idesc, char *type, int flag)
{
	union dinode *dp;

	dp = ginode(idesc->id_number);
	if (flag == 1) {
		pwarn("%s %s", type,
		    (DIP(dp, di_mode) & IFMT) == IFDIR ? "DIR" : "FILE");
		pinode(idesc->id_number);
	}
	if (preen || reply("CLEAR") == 1) {
		if (preen)
			printf(" (CLEARED)\n");
		n_files--;
		(void)ckinode(dp, idesc);
		clearinode(dp);
		SET_ISTATE(idesc->id_number, USTATE);
		inodirty();
	}
}

int
findname(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;

	if (dirp->d_ino != idesc->id_parent)
		return (KEEPON);
	memcpy(idesc->id_name, dirp->d_name, (size_t)dirp->d_namlen + 1);
	return (STOP|FOUND);
}

int
findino(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;

	if (dirp->d_ino == 0)
		return (KEEPON);
	if (strcmp(dirp->d_name, idesc->id_name) == 0 &&
	    dirp->d_ino >= ROOTINO && dirp->d_ino <= maxino) {
		idesc->id_parent = dirp->d_ino;
		return (STOP|FOUND);
	}
	return (KEEPON);
}

void
pinode(ino_t ino)
{
	union dinode *dp;
	char *p;
#ifndef SMALL
	struct passwd *pw;
#endif
	time_t t;

	printf(" I=%llu ", (unsigned long long)ino);
	if (ino < ROOTINO || ino > maxino)
		return;
	dp = ginode(ino);
	printf(" OWNER=");
#ifndef SMALL
	if ((pw = getpwuid(DIP(dp, di_uid))) != 0)
		printf("%s ", pw->pw_name);
	else
#endif
		printf("%u ", (unsigned)DIP(dp, di_uid));
	printf("MODE=%o\n", DIP(dp, di_mode));
	if (preen)
		printf("%s: ", cdevname());
	printf("SIZE=%llu ", (unsigned long long)DIP(dp, di_size));
	t = DIP(dp, di_mtime);
	p = ctime(&t);
	printf("MTIME=%12.12s %4.4s ", &p[4], &p[20]);
}

void
blkerror(ino_t ino, char *type, daddr_t blk)
{

	pfatal("%lld %s I=%llu", blk, type, (unsigned long long)ino);
	printf("\n");
	switch (GET_ISTATE(ino)) {

	case FSTATE:
		SET_ISTATE(ino, FCLEAR);
		return;

	case DSTATE:
		SET_ISTATE(ino, DCLEAR);
		return;

	case FCLEAR:
	case DCLEAR:
		return;

	default:
		errexit("BAD STATE %d TO BLKERR\n", GET_ISTATE(ino));
		/* NOTREACHED */
	}
}

/*
 * allocate an unused inode
 */
ino_t
allocino(ino_t request, int type)
{
	ino_t ino;
	union dinode *dp;
	struct cg *cgp = &cgrp;
	int cg;
	time_t t;
	struct inostat *info;

	if (request == 0)
		request = ROOTINO;
	else if (GET_ISTATE(request) != USTATE)
		return (0);
	for (ino = request; ino < maxino; ino++)
		if (GET_ISTATE(ino) == USTATE)
			break;
	if (ino == maxino)
		return (0);
	cg = ino_to_cg(&sblock, ino);
	/* If necessary, extend the inoinfo array. grow exponentially */
	if ((ino % sblock.fs_ipg) >= (uint64_t)inostathead[cg].il_numalloced) {
		unsigned long newalloced, i;
		newalloced = MINIMUM(sblock.fs_ipg,
			MAXIMUM(2 * inostathead[cg].il_numalloced, 10));
		info = calloc(newalloced, sizeof(struct inostat));
		if (info == NULL) {
			pwarn("cannot alloc %zu bytes to extend inoinfo\n",
				sizeof(struct inostat) * newalloced);
			return 0;
		}
		memmove(info, inostathead[cg].il_stat,
			inostathead[cg].il_numalloced * sizeof(*info));
		for (i = inostathead[cg].il_numalloced; i < newalloced; i++) {
			info[i].ino_state = USTATE;
		}
		if (inostathead[cg].il_numalloced)
			free(inostathead[cg].il_stat);
		inostathead[cg].il_stat = info;
		inostathead[cg].il_numalloced = newalloced;
		info = inoinfo(ino);
	}
	getblk(&cgblk, cgtod(&sblock, cg), sblock.fs_cgsize);
	if (!cg_chkmagic(cgp))
		pfatal("CG %d: BAD MAGIC NUMBER\n", cg);
	setbit(cg_inosused(cgp), ino % sblock.fs_ipg);
	cgp->cg_cs.cs_nifree--;

	switch (type & IFMT) {
	case IFDIR:
		SET_ISTATE(ino, DSTATE);
		cgp->cg_cs.cs_ndir++;
		break;
	case IFREG:
	case IFLNK:
		SET_ISTATE(ino, FSTATE);
		break;
	default:
		return (0);
	}
	cgdirty();
	dp = ginode(ino);
	DIP_SET(dp, di_db[0],  allocblk(1));
	if (DIP(dp, di_db[0]) == 0) {
		SET_ISTATE(ino, USTATE);
		return (0);
	}
	DIP_SET(dp, di_mode, type);
	DIP_SET(dp, di_uid, geteuid());
	DIP_SET(dp, di_gid, getegid());
	DIP_SET(dp, di_flags, 0);
	(void)time(&t);
	DIP_SET(dp, di_atime, t);
	DIP_SET(dp, di_atimensec, 0);
	DIP_SET(dp, di_mtime, t);
	DIP_SET(dp, di_mtimensec, 0);
	DIP_SET(dp, di_ctime, t);
	DIP_SET(dp, di_ctimensec, 0);
	DIP_SET(dp, di_size, sblock.fs_fsize);
	DIP_SET(dp, di_blocks, btodb(sblock.fs_fsize));
	n_files++;
	inodirty();
	SET_ITYPE(ino, IFTODT(type));
	return (ino);
}

/*
 * deallocate an inode
 */
void
freeino(ino_t ino)
{
	struct inodesc idesc;
	union dinode *dp;

	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = ADDR;
	idesc.id_func = pass4check;
	idesc.id_number = ino;
	dp = ginode(ino);
	(void)ckinode(dp, &idesc);
	clearinode(dp);
	inodirty();
	SET_ISTATE(ino, USTATE);
	n_files--;
}
@


1.47
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.46 2015/01/20 18:22:21 deraadt Exp $	*/
d529 1
d531 1
@


1.46
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.45 2015/01/16 06:39:57 deraadt Exp $	*/
d381 1
a381 2
	if (inodebuf != NULL)
		free(inodebuf);
@


1.45
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.44 2014/10/08 16:28:38 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG setbit btodb */
@


1.44
log
@trivial use of getreallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.43 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d45 1
d51 3
d66 1
a66 1
	char pathbuf[MAXPATHLEN + 1];
d158 1
a158 1
	char pathbuf[MAXPATHLEN + 1];
d605 2
a606 2
		newalloced = MIN(sblock.fs_ipg,
			MAX(2 * inostathead[cg].il_numalloced, 10));
@


1.43
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.42 2014/05/21 18:53:05 krw Exp $	*/
d423 2
a424 2
		newinpsort = realloc(inpsort,
		    (unsigned)newlistmax * sizeof(struct inoinfo *));
@


1.42
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.41 2013/11/11 18:51:06 deraadt Exp $	*/
d605 1
a605 1
			pwarn("cannot alloc %lu bytes to extend inoinfo\n",
@


1.41
log
@incorrect %lld for an int
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.40 2013/11/03 02:22:07 krw Exp $	*/
d295 1
a295 1
		return ((union dinode *) 
@


1.40
log
@Add missing (long long) cast of variable, (long long) casts
for defines fragnum, fsbtodb, cgsblock, and cgdmin.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.39 2013/11/01 17:36:18 krw Exp $	*/
d242 1
a242 1
			printf("bad size: blk %lld, offset %lld, size %lld\n",
@


1.39
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.38 2013/06/11 16:42:04 deraadt Exp $	*/
d242 2
a243 2
			printf("bad size: blk %lld, offset %lld, size %d\n",
			    (long long)blk, fragnum(&sblock, blk),
d252 2
a253 1
				    (long long)blk, cgdmin(&sblock, c));
d256 1
a256 1
				    cgsblock(&sblock, c));
d264 2
a265 1
				    (long long)blk, cgdmin(&sblock, c));
@


1.38
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.37 2013/04/24 13:46:29 deraadt Exp $	*/
d243 2
a244 1
			    blk, fragnum(&sblock, blk), cnt);
d252 1
a252 1
				    blk, cgdmin(&sblock, c));
d254 2
a255 1
				    blk + cnt, cgsblock(&sblock, c));
d263 1
a263 1
				    blk, cgdmin(&sblock, c));
d265 1
a265 1
				    blk+cnt, sblock.fs_fpg);
@


1.37
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.36 2011/05/08 14:38:40 otto Exp $	*/
d232 1
a232 1
chkrange(daddr64_t blk, int cnt)
d277 1
a277 1
	daddr64_t iblk;
d308 1
a308 1
	daddr64_t dblk;
d397 1
a397 1
	inp = malloc(sizeof(*inp) + (blks ? blks - 1 : 0) * sizeof(daddr64_t));
d546 1
a546 1
blkerror(ino_t ino, char *type, daddr64_t blk)
@


1.36
log
@Small memory optimization from NetBSD; ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.35 2011/04/24 07:07:03 otto Exp $	*/
d178 2
a179 2
			    "PARTIALLY TRUNCATED INODE I=%u",
			    idesc->id_number);
d280 2
a281 1
		errexit("bad inode number %d to ginode\n", inumber);
d313 3
a315 1
		errexit("bad inode number %d to nextinode %d\n", inumber, nextino);
d442 1
a442 1
	errexit("cannot find inode %d\n", inumber);
d525 1
a525 1
	printf(" I=%u ", ino);
d549 1
a549 1
	pfatal("%lld %s I=%u", blk, type, ino);
@


1.35
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.34 2011/04/16 16:37:21 otto Exp $	*/
d400 1
a400 1
	inp->i_child = inp->i_sibling = inp->i_parentp = 0;
@


1.34
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.33 2009/10/27 23:59:32 deraadt Exp $	*/
d653 1
a653 2
	if (newinofmt)
		SET_ITYPE(ino, IFTODT(type));
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.32 2008/12/29 18:06:10 otto Exp $	*/
d312 1
a312 1
		errexit("bad inode number %d to nextinode\n", inumber);
a363 2
	while (nextino < ROOTINO)
		(void)getnextinode(nextino);
d579 1
d591 22
@


1.32
log
@Some forms of inode corruption can make remsize and thus isize go
negative and cause SEGVs. Handle this the same as an out of range
blockno. ok jsg@@ (also victim) pedro@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.31 2008/06/10 23:10:29 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)inode.c	8.5 (Berkeley) 2/8/95";
#else
static const char rcsid[] = "$OpenBSD: inode.c,v 1.31 2008/06/10 23:10:29 otto Exp $";
#endif
#endif /* not lint */
@


1.31
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.30 2007/06/25 19:59:55 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.30 2007/06/25 19:59:55 otto Exp $";
d171 1
a171 1
	if (chkrange(idesc->id_blkno, idesc->id_numfrags))
@


1.30
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.29 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.29 2007/04/10 16:08:17 millert Exp $";
d493 1
a493 1
		statemap[idesc->id_number] = USTATE;
d558 1
a558 1
	switch (statemap[ino]) {
d561 1
a561 1
		statemap[ino] = FCLEAR;
d565 1
a565 1
		statemap[ino] = DCLEAR;
d573 1
a573 1
		errexit("BAD STATE %d TO BLKERR\n", statemap[ino]);
d592 1
a592 1
	else if (statemap[request] != USTATE)
d595 1
a595 1
		if (statemap[ino] == USTATE)
d608 1
a608 1
		statemap[ino] = DSTATE;
d613 1
a613 1
		statemap[ino] = FSTATE;
d622 1
a622 1
		statemap[ino] = USTATE;
d641 1
a641 1
		typemap[ino] = IFTODT(type);
d662 1
a662 1
	statemap[ino] = USTATE;
@


1.29
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.28 2007/02/12 16:41:07 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.28 2007/02/12 16:41:07 otto Exp $";
d240 1
a240 1
chkrange(daddr_t blk, int cnt)
d250 2
a251 2
			printf("bad size: blk %ld, offset %i, size %d\n",
			    (long)blk, (int)fragnum(&sblock, blk), cnt);
d258 1
a258 1
				printf("blk %d < cgdmin %d;",
d260 1
a260 1
				printf(" blk + cnt %d > cgsbase %d\n",
d268 1
a268 1
				printf("blk %d >= cgdmin %d;",
d270 1
a270 1
				printf(" blk + cnt %d > sblock.fs_fpg %d\n",
d285 1
a285 1
	daddr_t iblk;
d315 1
a315 1
	daddr_t dblk;
d404 1
a404 1
	inp = malloc(sizeof(*inp) + (blks ? blks - 1 : 0) * sizeof(daddr_t));
d553 1
a553 1
blkerror(ino_t ino, char *type, daddr_t blk)
d556 1
a556 1
	pfatal("%d %s I=%u", blk, type, ino);
@


1.28
log
@remsize must be signed to avoid wrapping around to some huge number.
Solves a case were fsck_ffs was causing a segv. If it didn't do that
it would have mangled the filesystem later, very probably.
Diff from FreeBSD; ok millert@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.27 2007/01/24 13:24:58 bluhm Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.27 2007/01/24 13:24:58 bluhm Exp $";
d63 1
a63 1
ckinode(struct ufs1_dinode *dp, struct inodesc *idesc)
d65 2
a66 3
	ufs_daddr_t *ap;
	long ret, n, ndb, offset;
	struct ufs1_dinode dino;
d69 1
d75 2
a76 2
	idesc->id_filesize = dp->di_size;
	mode = dp->di_mode & IFMT;
d78 2
a79 2
	    (dp->di_size < sblock.fs_maxsymlinklen ||
	     (sblock.fs_maxsymlinklen == 0 && dp->di_blocks == 0))))
d81 8
a88 4
	dino = *dp;
	ndb = howmany(dino.di_size, sblock.fs_bsize);
	for (ap = &dino.di_db[0]; ap < &dino.di_db[NDADDR]; ap++) {
		if (--ndb == 0 && (offset = blkoff(&sblock, dino.di_size)) != 0)
d93 1
a93 1
		if (*ap == 0) {
d102 2
a103 2
					dp->di_size = (ap - &dino.di_db[0]) *
					    sblock.fs_bsize;
d112 1
a112 1
		idesc->id_blkno = *ap;
d121 1
a121 1
	remsize = dino.di_size - sblock.fs_bsize * NDADDR;
d123 4
a126 4
	for (ap = &dino.di_ib[0], n = 1; n <= NIADDR; ap++, n++) {
		if (*ap) {
			idesc->id_blkno = *ap;
			ret = iblock(idesc, n, remsize);
d138 2
a139 1
					dp->di_size -= remsize;
a157 2
	daddr_t *ap;
	daddr_t *aplim;
d163 1
a163 1
	struct ufs1_dinode *dp;
d182 2
a183 3
		aplim = &bp->b_un.b_indir[NINDIR(&sblock)];
		for (ap = &bp->b_un.b_indir[nif]; ap < aplim; ap++) {
			if (*ap == 0)
d191 1
a191 1
				*ap = 0;
d197 3
a199 4
	aplim = &bp->b_un.b_indir[nif];
	for (ap = bp->b_un.b_indir; ap < aplim; ap++) {
		if (*ap) {
			idesc->id_blkno = *ap;
d217 2
a218 1
					dp->di_size -= isize;
d282 1
a282 1
struct ufs1_dinode *
d297 4
a300 1
	return (&pbp->b_un.b_dinode[inumber % INOPB(&sblock)]);
d309 1
a309 1
struct ufs1_dinode *inodebuf;
d311 1
a311 1
struct ufs1_dinode *
d316 2
a317 1
	static struct ufs1_dinode *dp;
d331 2
a332 2
		(void)bread(fsreadfd, (char *)inodebuf, dblk, size); /* ??? */
		dp = inodebuf;
d334 6
a339 1
	return (dp++);
d343 1
a343 1
resetinodebuf(void)
d347 2
a348 2
	nextino = 0;
	lastinum = 0;
d350 2
d353 4
a356 1
	fullcnt = inobufsize / sizeof(struct ufs1_dinode);
d359 4
a362 1
	partialsize = partialcnt * sizeof(struct ufs1_dinode);
d393 1
a393 1
cacheino(struct ufs1_dinode *dp, ino_t inumber)
d399 1
d401 1
a401 1
	blks = howmany(dp->di_size, sblock.fs_bsize);
d417 7
a423 3
	inp->i_isize = dp->di_size;
	inp->i_numblks = blks * sizeof(daddr_t);
	memcpy(&inp->i_blks[0], &dp->di_db[0], (size_t)inp->i_numblks);
d479 1
a479 1
	struct ufs1_dinode *dp;
d484 1
a484 1
		    (dp->di_mode & IFMT) == IFDIR ? "DIR" : "FILE");
d527 1
a527 1
	struct ufs1_dinode *dp;
d538 1
a538 1
	if ((pw = getpwuid(dp->di_uid)) != 0)
d542 2
a543 2
		printf("%u ", (unsigned)dp->di_uid);
	printf("MODE=%o\n", dp->di_mode);
d546 2
a547 2
	printf("SIZE=%llu ", (unsigned long long)dp->di_size);
	t = dp->di_mtime;
d585 1
a585 1
	struct ufs1_dinode *dp;
d620 2
a621 2
	dp->di_db[0] = allocblk(1);
	if (dp->di_db[0] == 0) {
d625 4
a628 4
	dp->di_mode = type;
	dp->di_uid = geteuid();
	dp->di_gid = getegid();
	dp->di_flags = 0;
d630 8
a637 4
	dp->di_atime = t;
	dp->di_mtime = dp->di_ctime = dp->di_atime;
	dp->di_size = sblock.fs_fsize;
	dp->di_blocks = btodb(sblock.fs_fsize);
d652 1
a652 1
	struct ufs1_dinode *dp;
@


1.27
log
@A reallocated root directory gets ownership of the fsck process.
If lost+found is created, it gets ownership of the root directory.

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.26 2003/10/11 01:43:45 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.26 2003/10/11 01:43:45 tedu Exp $";
d60 1
a60 1
static int iblock(struct inodesc *, long, u_int64_t);
d68 1
a68 1
	u_int64_t remsize, sizepb;
d151 1
a151 1
iblock(struct inodesc *idesc, long ilevel, u_int64_t isize)
d157 1
a157 1
	u_int64_t sizepb;
d174 1
a174 1
	if (isize > sizepb * NINDIR(&sblock))
d186 3
a188 1
			if (dofix(idesc, buf)) {
d242 2
a243 1
	if ((unsigned)blk > maxfsblock || (unsigned)(blk + cnt) > maxfsblock)
d245 7
@


1.26
log
@consistent newlines, from tom cosgrove at arches-consulting.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.25 2003/09/25 04:23:26 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.25 2003/09/25 04:23:26 deraadt Exp $";
d52 1
d592 2
@


1.25
log
@do not crank size first, do not do p = realloc(p, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.24 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.24 2003/08/25 23:28:15 tedu Exp $";
d375 1
a375 1
		errexit("cannot allocate memory for inode cache");
d538 1
a538 1
		errexit("BAD STATE %d TO BLKERR", statemap[ino]);
@


1.24
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.23 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.23 2003/06/02 20:06:15 millert Exp $";
d366 1
a366 1
	struct inoinfo **inpp;
d368 1
d390 4
a393 4
		listmax += 100;
		inpsort = realloc(inpsort,
		    (unsigned)listmax * sizeof(struct inoinfo *));
		if (inpsort == NULL)
d395 2
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.22 2003/04/26 00:39:28 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.22 2003/04/26 00:39:28 deraadt Exp $";
d62 1
a62 1
ckinode(struct dinode *dp, struct inodesc *idesc)
d66 1
a66 1
	struct dinode dino;
d159 1
a159 1
	struct dinode *dp;
d269 1
a269 1
struct dinode *
d293 1
a293 1
struct dinode *inodebuf;
d295 1
a295 1
struct dinode *
d300 1
a300 1
	static struct dinode *dp;
d329 1
a329 1
	fullcnt = inobufsize / sizeof(struct dinode);
d332 1
a332 1
	partialsize = partialcnt * sizeof(struct dinode);
d363 1
a363 1
cacheino(struct dinode *dp, ino_t inumber)
d441 1
a441 1
	struct dinode *dp;
d489 1
a489 1
	struct dinode *dp;
d547 1
a547 1
	struct dinode *dp;
d608 1
a608 1
	struct dinode *dp;
@


1.22
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.21 2002/08/23 09:09:04 gluk Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.21 2002/08/23 09:09:04 gluk Exp $";
@


1.21
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.20 2002/05/22 08:21:02 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: inode.c,v 1.20 2002/05/22 08:21:02 deraadt Exp $";
d95 2
a96 2
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
d131 2
a132 2
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
d211 2
a212 2
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
@


1.20
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.19 2002/02/16 21:27:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.19 2002/02/16 21:27:34 millert Exp $";
d66 1
a66 3
ckinode(dp, idesc)
	struct dinode *dp;
	struct inodesc *idesc;
d154 1
a154 4
iblock(idesc, ilevel, isize)
	struct inodesc *idesc;
	long ilevel;
	u_int64_t isize;
d239 1
a239 3
chkrange(blk, cnt)
	daddr_t blk;
	int cnt;
d274 1
a274 2
ginode(inumber)
	ino_t inumber;
d300 1
a300 2
getnextinode(inumber)
	ino_t inumber;
d325 1
a325 1
resetinodebuf()
d344 1
a344 1
	    (inodebuf = (struct dinode *)malloc((unsigned)inobufsize)) == NULL)
d351 1
a351 1
freeinodebuf()
d355 1
a355 1
		free((char *)inodebuf);
d367 1
a367 3
cacheino(dp, inumber)
	struct dinode *dp;
	ino_t inumber;
d376 1
a376 2
	inp = (struct inoinfo *)
		malloc(sizeof(*inp) + (blks ? blks - 1 : 0) * sizeof(daddr_t));
d386 2
a387 2
		inp->i_parent = (ino_t)0;
	inp->i_dotdot = (ino_t)0;
d394 1
a394 1
		inpsort = (struct inoinfo **)realloc((char *)inpsort,
d406 1
a406 2
getinoinfo(inumber)
	ino_t inumber;
d423 1
a423 1
inocleanup()
d430 3
a432 3
		free((char *)(*inpp));
	free((char *)inphead);
	free((char *)inpsort);
d435 1
a435 1
	
d437 1
a437 1
inodirty()
a438 1
	
d443 1
a443 4
clri(idesc, type, flag)
	struct inodesc *idesc;
	char *type;
	int flag;
d465 1
a465 2
findname(idesc)
	struct inodesc *idesc;
d476 1
a476 2
findino(idesc)
	struct inodesc *idesc;
d491 1
a491 2
pinode(ino)
	ino_t ino;
d519 1
a519 4
blkerror(ino, type, blk)
	ino_t ino;
	char *type;
	daddr_t blk;
d548 1
a548 3
allocino(request, type)
	ino_t request;
	int type;
d586 1
a586 1
	dp->di_db[0] = allocblk((long)1);
d609 1
a609 2
freeino(ino)
	ino_t ino;
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.18 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.18 2001/11/05 07:39:16 mpech Exp $";
d191 3
a193 2
			(void)sprintf(buf, "PARTIALLY TRUNCATED INODE I=%u",
				idesc->id_number);
@


1.18
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.17 2001/07/07 18:26:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.17 2001/07/07 18:26:12 deraadt Exp $";
d63 1
a63 1
static int iblock __P((struct inodesc *, long, u_int64_t));
d164 1
a164 1
	int i, n, (*func) __P((struct inodesc *)), nif;
@


1.17
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.16 2001/05/15 19:32:39 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.16 2001/05/15 19:32:39 mickey Exp $";
d68 1
a68 1
	register struct inodesc *idesc;
d70 1
a70 1
	register ufs_daddr_t *ap;
d161 3
a163 3
	register daddr_t *ap;
	register daddr_t *aplim;
	register struct bufarea *bp;
d247 1
a247 1
	register int c;
d376 1
a376 1
	register struct dinode *dp;
d379 1
a379 1
	register struct inoinfo *inp;
d420 1
a420 1
	register struct inoinfo *inp;
d437 1
a437 1
	register struct inoinfo **inpp;
d457 1
a457 1
	register struct inodesc *idesc;
d461 1
a461 1
	register struct dinode *dp;
d484 1
a484 1
	register struct direct *dirp = idesc->id_dirp;
d496 1
a496 1
	register struct direct *dirp = idesc->id_dirp;
d512 2
a513 2
	register struct dinode *dp;
	register char *p;
d574 2
a575 2
	register ino_t ino;
	register struct dinode *dp;
@


1.16
log
@error out if failed to malloc memory for inode cache entry; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.15 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.15 2001/03/02 08:33:55 art Exp $";
d531 1
a531 1
	printf("SIZE=%qu ", dp->di_size);
@


1.15
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.14 1999/08/06 20:41:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.14 1999/08/06 20:41:06 deraadt Exp $";
d389 1
a389 1
		return;
@


1.14
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.13 1997/10/11 20:19:36 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.13 1997/10/11 20:19:36 niklas Exp $";
d576 2
d589 7
d599 1
d608 1
d616 1
@


1.13
log
@Never involve negative numbers in unsigned expressions.  Fixes a segfault some
bad fs images triggers.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.12 1997/10/06 20:22:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.12 1997/10/06 20:22:32 deraadt Exp $";
d523 1
a523 1
	if ((pw = getpwuid((int)dp->di_uid)) != 0)
@


1.12
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.10 1997/06/25 18:12:13 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.10 1997/06/25 18:12:13 kstailey Exp $";
d387 1
a387 1
		malloc(sizeof(*inp) + (blks - 1) * sizeof(daddr_t));
@


1.11
log
@VFS Lite2 Changes
@
text
@a575 2
	struct cg *cgp = &cgrp;
	int cg;
a586 7
	cg = ino_to_cg(&sblock, ino);
	getblk(&cgblk, cgtod(&sblock, cg), sblock.fs_cgsize);
	if (!cg_chkmagic(cgp))
		pfatal("CG %d: BAD MAGIC NUMBER\n", cg);
	setbit(cg_inosused(cgp), ino % sblock.fs_ipg);
	cgp->cg_cs.cs_nifree--;

a589 1
		cgp->cg_cs.cs_ndir++;
a597 1
	cgdirty();
a604 1
	dp->di_flags = 0;
@


1.10
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.9 1997/06/22 20:10:48 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.9 1997/06/22 20:10:48 tholo Exp $";
d576 2
d589 7
d599 1
d608 1
d616 1
@


1.9
log
@Avoid an overflow when checking inode numbers; from FreeBSD PR #3528 by
Ian Dowse <iedowse@@maths.tcd.ie>
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.8 1996/10/20 08:36:34 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.8 1996/10/20 08:36:34 tholo Exp $";
d428 1
a428 1
	return ((struct inoinfo *)0);
@


1.8
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.7 1996/10/12 03:06:54 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.7 1996/10/12 03:06:54 tholo Exp $";
d249 1
a249 1
	if ((unsigned)(blk + cnt) > maxfsblock)
@


1.7
log
@From Kirk McKusick:
  If a directory somehow develops a hole (that is a block pointer
  that has a value of zero), fsck would give the filesystem a clean
  bill of health, but the kernel would panic when accessing the
  directory with the hole. Fsck now checks for holes in directories.
  If found in preen mode, fsck fails. In manual mode, it can be
  directed to shorten the directory to the beginning of the hole. A
  more complete solution would be to allocate a block to fill the
  hole. However, this is a lot more work for a `cannot happen' error,
  so the extra effort seems unwarranted.
@
text
@d1 2
a2 2
/*	$OpenBSD: inode.c,v 1.6 1996/06/23 14:30:29 deraadt Exp $	*/
/*	$NetBSD: inode.c,v 1.18 1996/05/21 16:58:12 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.6 1996/06/23 14:30:29 deraadt Exp $";
d58 1
d63 1
a63 1
int iblock __P((struct inodesc *, long, quad_t));
d73 1
a73 1
	quad_t remsize, sizepb;
d98 4
a101 4
						idesc->id_number);
                        	pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
					pathbuf);
                        	if (reply("ADJUST LENGTH") == 1) {
d103 1
a103 1
                                	dp->di_size = (ap - &dino.di_db[0]) *
d108 2
a109 3
                                	inodirty();
					
                        	}
d134 4
a137 4
						idesc->id_number);
                        	pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
					pathbuf);
                        	if (reply("ADJUST LENGTH") == 1) {
d139 1
a139 1
                                	dp->di_size -= remsize;
d144 1
a144 1
                                	inodirty();
d146 1
a146 1
                        	}
d155 1
a155 1
int
d159 1
a159 1
	quad_t isize;
d164 3
a166 2
	int i, n, (*func)(), nif;
	quad_t sizepb;
a167 1
	char buf[BUFSIZ];
a168 1
	extern int pass1check();
d191 1
a191 1
			(void)sprintf(buf, "PARTIALLY TRUNCATED INODE I=%lu",
d216 4
a219 4
						idesc->id_number);
                        	pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
					pathbuf);
                        	if (reply("ADJUST LENGTH") == 1) {
d221 1
a221 1
                                	dp->di_size -= isize;
d226 1
a226 1
                                	inodirty();
d229 1
a229 1
                        	}
d255 1
a255 1
				printf("blk %ld < cgdmin %ld;",
d257 1
a257 1
				printf(" blk + cnt %ld > cgsbase %ld\n",
d265 1
a265 1
				printf("blk %ld >= cgdmin %ld;",
d267 1
a267 1
				printf(" blk + cnt %ld > sblock.fs_fpg %ld\n",
d393 1
d517 1
a517 1
	printf(" I=%lu ", ino);
d530 1
a530 1
		printf("%s: ", cdevname);
d544 1
a544 1
	pfatal("%ld %s I=%lu", blk, type, ino);
@


1.6
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.18 1996/05/21 16:58:12 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.18 1996/05/21 16:58:12 mycroft Exp $";
d74 1
d93 18
a110 1
		if (*ap == 0)
d112 1
d130 18
d166 1
d168 1
d212 19
@


1.5
log
@be more careful
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: inode.c,v 1.18 1996/05/21 16:58:12 mycroft Exp $";
@


1.4
log
@use ufs_daddr_t; another time_t cleanup
@
text
@d1 1
a1 1
/*	$NetBSD: inode.c,v 1.17 1995/12/17 06:03:36 thorpej Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: inode.c,v 1.17 1995/12/17 06:03:36 thorpej Exp $";
d143 1
a143 2
	nif = howmany(isize , sizepb);
	if (nif > NINDIR(&sblock))
d145 2
@


1.3
log
@handle time_t things that really are not time_t
@
text
@d1 1
a1 1
/*	$NetBSD: inode.c,v 1.16 1995/12/14 22:17:26 thorpej Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: inode.c,v 1.16 1995/12/14 22:17:26 thorpej Exp $";
d68 1
a68 1
	register daddr_t *ap;
d455 1
a455 1
	char *ctime();
d472 2
a473 1
	p = ctime(&dp->di_mtime);
@


1.2
log
@time_t typecast; from bernd@@arresum.inka.de; netbsd pr#1724
@
text
@d1 1
a1 1
/*	$NetBSD: inode.c,v 1.15 1995/06/07 17:16:10 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: inode.c,v 1.15 1995/06/07 17:16:10 cgd Exp $";
d515 1
d544 2
a545 1
	(void)time((time_t *)&dp->di_atime);
@


1.1
log
@Initial revision
@
text
@d543 1
a543 1
	(void)time(&dp->di_atime);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
