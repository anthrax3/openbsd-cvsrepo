head	1.51;
access;
symbols
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.51.0.8
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.49.0.6
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.35.0.8
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.4
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.34.0.4
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2015.10.15.03.10.05;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	1Cz9iNuje72nNplB;

1.50
date	2015.09.05.20.07.11;	author guenther;	state Exp;
branches;
next	1.49;
commitid	YONuUa04kio8ur0h;

1.49
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	F55lwc3gS4GN2mLs;

1.48
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	Uu5nFG3wCl0LACBb;

1.47
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.46;
commitid	qlzrzgnJ4ZiiF6XQ;

1.46
date	2014.05.24.14.54.49;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.21.18.53.05;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.09.13.19.34;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2013.11.01.17.36.18;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.10.16.01.51;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.13.20.37.07;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.17.19.33.54;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.17.19.22.29;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.17.19.18.09;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.07.11.25.37;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.02.00.48.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.30.01.16.31;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.22.20.24.32;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.20.20.00.05;	author dhill;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.12.02.28.28;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.25.06.25.46;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.26.00.39.28;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.20.21.57.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.23.21.23.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.13.02.39.05;	author gluk;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.19.17.57.36;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.15.19.52.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.30.16.06.34;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.03.01.07.45.18;	author d;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.22.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.33.36;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.06.25.18.12.17;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.20.08.36.42;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.51
log
@fsck_ffs has a ^T signal handler which opens /dev/tty late.  Hoist that
opening to before the pledge, and cache the fd.
looked over by millert
@
text
@/*	$OpenBSD: utilities.c,v 1.50 2015/09/05 20:07:11 guenther Exp $	*/
/*	$NetBSD: utilities.c,v 1.18 1996/09/27 22:45:20 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE isset setbit clrbit */
#include <sys/time.h>
#include <sys/uio.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>

#include "fsutil.h"
#include "fsck.h"
#include "extern.h"

long	diskreads, totalreads;	/* Disk cache statistics */

static void rwerror(char *, daddr_t);

int
ftypeok(union dinode *dp)
{
	switch (DIP(dp, di_mode) & IFMT) {
	case IFDIR:
	case IFREG:
	case IFBLK:
	case IFCHR:
	case IFLNK:
	case IFSOCK:
	case IFIFO:
		return (1);
	default:
		if (debug)
			printf("bad file type 0%o\n", DIP(dp, di_mode));
		return (0);
	}
}

int
reply(char *question)
{
	int persevere, c;

	if (preen)
		pfatal("INTERNAL ERROR: GOT TO reply()");
	persevere = !strcmp(question, "CONTINUE");
	printf("\n");
	if (!persevere && (nflag || fswritefd < 0)) {
		printf("%s? no\n\n", question);
		resolved = 0;
		return (0);
	}
	if (yflag || (persevere && nflag)) {
		printf("%s? yes\n\n", question);
		return (1);
	}

	do {
		printf("%s? [Fyn?] ", question);
		(void) fflush(stdout);
		c = getc(stdin);
		if (c == 'F') {
			yflag = 1;
			return (1);
		}
		while (c != '\n' && getc(stdin) != '\n') {
			if (feof(stdin)) {
				resolved = 0;
				return (0);
			}
		}
	} while (c != 'y' && c != 'Y' && c != 'n' && c != 'N');
	printf("\n");
	if (c == 'y' || c == 'Y')
		return (1);
	resolved = 0;
	return (0);
}

/*
 * Look up state information for an inode.
 */
struct inostat *
inoinfo(ino_t inum)
{
	static struct inostat unallocated = { USTATE, 0, 0 };
	struct inostatlist *ilp;
	int iloff;

	if (inum > maxino)
		errexit("inoinfo: inumber %llu out of range",
		    (unsigned long long)inum);
	ilp = &inostathead[inum / sblock.fs_ipg];
	iloff = inum % sblock.fs_ipg;
	if (iloff >= ilp->il_numalloced)
		return (&unallocated);
	return (&ilp->il_stat[iloff]);
}

/*
 * Malloc buffers and set up cache.
 */
void
bufinit(void)
{
	struct bufarea *bp;
	long bufcnt, i;
	char *bufp;

	pbp = pdirbp = NULL;
	bufp = malloc((unsigned int)sblock.fs_bsize);
	if (bufp == 0)
		errexit("cannot allocate buffer pool\n");
	cgblk.b_un.b_buf = bufp;
	initbarea(&cgblk);
	bufhead.b_next = bufhead.b_prev = &bufhead;
	bufcnt = MAXBUFSPACE / sblock.fs_bsize;
	if (bufcnt < MINBUFS)
		bufcnt = MINBUFS;
	for (i = 0; i < bufcnt; i++) {
		bp = malloc(sizeof(struct bufarea));
		bufp = malloc((unsigned int)sblock.fs_bsize);
		if (bp == NULL || bufp == NULL) {
			free(bp);
			free(bufp);
			if (i >= MINBUFS)
				break;
			errexit("cannot allocate buffer pool\n");
		}
		bp->b_un.b_buf = bufp;
		bp->b_prev = &bufhead;
		bp->b_next = bufhead.b_next;
		bufhead.b_next->b_prev = bp;
		bufhead.b_next = bp;
		initbarea(bp);
	}
	bufhead.b_size = i;	/* save number of buffers */
}

/*
 * Manage a cache of directory blocks.
 */
struct bufarea *
getdatablk(daddr_t blkno, long size)
{
	struct bufarea *bp;

	for (bp = bufhead.b_next; bp != &bufhead; bp = bp->b_next)
		if (bp->b_bno == fsbtodb(&sblock, blkno))
			goto foundit;
	for (bp = bufhead.b_prev; bp != &bufhead; bp = bp->b_prev)
		if ((bp->b_flags & B_INUSE) == 0)
			break;
	if (bp == &bufhead)
		errexit("deadlocked buffer pool\n");
	getblk(bp, blkno, size);
	/* FALLTHROUGH */
foundit:
	totalreads++;
	bp->b_prev->b_next = bp->b_next;
	bp->b_next->b_prev = bp->b_prev;
	bp->b_prev = &bufhead;
	bp->b_next = bufhead.b_next;
	bufhead.b_next->b_prev = bp;
	bufhead.b_next = bp;
	bp->b_flags |= B_INUSE;
	return (bp);
}

void
getblk(struct bufarea *bp, daddr_t blk, long size)
{
	daddr_t dblk;

	dblk = fsbtodb(&sblock, blk);
	if (bp->b_bno != dblk) {
		flush(fswritefd, bp);
		diskreads++;
		bp->b_errs = bread(fsreadfd, bp->b_un.b_buf, dblk, size);
		bp->b_bno = dblk;
		bp->b_size = size;
	}
}

void
flush(int fd, struct bufarea *bp)
{
	int i, j;

	if (!bp->b_dirty)
		return;
	if (bp->b_errs != 0)
		pfatal("WRITING %sZERO'ED BLOCK %lld TO DISK\n",
		    (bp->b_errs == bp->b_size / DEV_BSIZE) ? "" : "PARTIALLY ",
		    (long long)bp->b_bno);
	bp->b_dirty = 0;
	bp->b_errs = 0;
	bwrite(fd, bp->b_un.b_buf, bp->b_bno, (long)bp->b_size);
	if (bp != &sblk)
		return;
	for (i = 0, j = 0; i < sblock.fs_cssize; i += sblock.fs_bsize, j++) {
		bwrite(fswritefd, (char *)sblock.fs_csp + i,
		    fsbtodb(&sblock, sblock.fs_csaddr + j * sblock.fs_frag),
		    sblock.fs_cssize - i < sblock.fs_bsize ?
		    sblock.fs_cssize - i : sblock.fs_bsize);
	}
}

static void
rwerror(char *mesg, daddr_t blk)
{

	if (preen == 0)
		printf("\n");
	pfatal("CANNOT %s: BLK %lld", mesg, (long long)blk);
	if (reply("CONTINUE") == 0)
		errexit("Program terminated\n");
}

void
ckfini(int markclean)
{
	struct bufarea *bp, *nbp;
	int cnt = 0;
	sigset_t oset, nset;
	int64_t sblockloc;

	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigprocmask(SIG_BLOCK, &nset, &oset);

	if (fswritefd < 0) {
		(void)close(fsreadfd);
		fsreadfd = -1;
		sigprocmask(SIG_SETMASK, &oset, NULL);
		return;
	}
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		sblockloc = SBLOCK_UFS1;
		sblock.fs_ffs1_time = sblock.fs_time;
		sblock.fs_ffs1_size = sblock.fs_size;
		sblock.fs_ffs1_dsize = sblock.fs_dsize;
		sblock.fs_ffs1_csaddr = sblock.fs_csaddr;
		sblock.fs_ffs1_cstotal.cs_ndir = sblock.fs_cstotal.cs_ndir;
		sblock.fs_ffs1_cstotal.cs_nbfree = sblock.fs_cstotal.cs_nbfree;
		sblock.fs_ffs1_cstotal.cs_nifree = sblock.fs_cstotal.cs_nifree;
		sblock.fs_ffs1_cstotal.cs_nffree = sblock.fs_cstotal.cs_nffree;
		/* Force update on next mount */
		sblock.fs_ffs1_flags &= ~FS_FLAGS_UPDATED;
	} else
		sblockloc = SBLOCK_UFS2;
	flush(fswritefd, &sblk);
	if (havesb && sblk.b_bno != sblockloc / DEV_BSIZE && !preen &&
	    reply("UPDATE STANDARD SUPERBLOCK")) {
		sblk.b_bno = sblockloc / DEV_BSIZE;
		sbdirty();
		flush(fswritefd, &sblk);
	}
	flush(fswritefd, &cgblk);
	free(cgblk.b_un.b_buf);
	for (bp = bufhead.b_prev; bp && bp != &bufhead; bp = nbp) {
		cnt++;
		flush(fswritefd, bp);
		nbp = bp->b_prev;
		free(bp->b_un.b_buf);
		free(bp);
	}
	if (bufhead.b_size != cnt)
		errexit("Panic: lost %d buffers\n", bufhead.b_size - cnt);
	pbp = pdirbp = NULL;
	if (markclean && (sblock.fs_clean & FS_ISCLEAN) == 0) {
		/*
		 * Mark the file system as clean, and sync the superblock.
		 */
		if (preen)
			pwarn("MARKING FILE SYSTEM CLEAN\n");
		else if (!reply("MARK FILE SYSTEM CLEAN"))
			markclean = 0;
		if (markclean) {
			sblock.fs_clean = FS_ISCLEAN;
			sbdirty();
			flush(fswritefd, &sblk);
		}
	}
	if (debug)
		printf("cache missed %ld of %ld (%d%%)\n", diskreads,
		    totalreads, (int)(diskreads * 100 / totalreads));
	(void)close(fsreadfd);
	fsreadfd = -1;
	(void)close(fswritefd);
	fswritefd = -1;
	sigprocmask(SIG_SETMASK, &oset, NULL);
}

int
bread(int fd, char *buf, daddr_t blk, long size)
{
	char *cp;
	int i, errs;
	off_t offset;

	offset = blk;
	offset *= DEV_BSIZE;
	if (pread(fd, buf, size, offset) == size)
		return (0);
	rwerror("READ", blk);
	errs = 0;
	memset(buf, 0, (size_t)size);
	printf("THE FOLLOWING DISK SECTORS COULD NOT BE READ:");
	for (cp = buf, i = 0; i < size; i += secsize, cp += secsize) {
		if (pread(fd, cp, secsize, offset + i) != secsize) {
			if (secsize != DEV_BSIZE)
				printf(" %lld (%lld),",
				    (long long)(offset + i) / secsize,
				    (long long)blk + i / DEV_BSIZE);
			else
				printf(" %lld,", (long long)blk +
				    i / DEV_BSIZE);
			errs++;
		}
	}
	printf("\n");
	return (errs);
}

void
bwrite(int fd, char *buf, daddr_t blk, long size)
{
	int i;
	char *cp;
	off_t offset;

	if (fd < 0)
		return;
	offset = blk;
	offset *= DEV_BSIZE;
	if (pwrite(fd, buf, size, offset) == size) {
		fsmodified = 1;
		return;
	}
	rwerror("WRITE", blk);
	printf("THE FOLLOWING SECTORS COULD NOT BE WRITTEN:");
	for (cp = buf, i = 0; i < size; i += secsize, cp += secsize)
		if (pwrite(fd, cp, secsize, offset + i) != secsize) {
			if (secsize != DEV_BSIZE)
				printf(" %lld (%lld),",
				    (long long)(offset + i) / secsize,
				    (long long)blk + i / DEV_BSIZE);
			else
				printf(" %lld,", (long long)blk +
				    i / DEV_BSIZE);
		}
	printf("\n");
	return;
}

/*
 * allocate a data block with the specified number of fragments
 */
daddr_t
allocblk(int frags)
{
	daddr_t i, baseblk;
	int j, k, cg;
	struct cg *cgp = &cgrp;

	if (frags <= 0 || frags > sblock.fs_frag)
		return (0);
	for (i = 0; i < maxfsblock - sblock.fs_frag; i += sblock.fs_frag) {
		for (j = 0; j <= sblock.fs_frag - frags; j++) {
			if (testbmap(i + j))
				continue;
			for (k = 1; k < frags; k++)
				if (testbmap(i + j + k))
					break;
			if (k < frags) {
				j += k;
				continue;
			}
			cg = dtog(&sblock, i + j);
			getblk(&cgblk, cgtod(&sblock, cg), sblock.fs_cgsize);
			if (!cg_chkmagic(cgp))
				pfatal("CG %d: BAD MAGIC NUMBER\n", cg);
			baseblk = dtogd(&sblock, i + j);

			for (k = 0; k < frags; k++) {
				setbmap(i + j + k);
				clrbit(cg_blksfree(cgp), baseblk + k);
			}
			n_blks += frags;
			if (frags == sblock.fs_frag)
				cgp->cg_cs.cs_nbfree--;
			else
				cgp->cg_cs.cs_nffree -= frags;
			return (i + j);
		}
	}
	return (0);
}

/*
 * Free a previously allocated block
 */
void
freeblk(daddr_t blkno, int frags)
{
	struct inodesc idesc;

	idesc.id_blkno = blkno;
	idesc.id_numfrags = frags;
	(void)pass4check(&idesc);
}

/*
 * Find a pathname
 */
void
getpathname(char *namebuf, size_t namebuflen, ino_t curdir, ino_t ino)
{
	int len;
	char *cp;
	struct inodesc idesc;
	static int busy = 0;

	if (curdir == ino && ino == ROOTINO) {
		(void)strlcpy(namebuf, "/", namebuflen);
		return;
	}
	if (busy ||
	    (GET_ISTATE(curdir) != DSTATE && GET_ISTATE(curdir) != DFOUND)) {
		(void)strlcpy(namebuf, "?", namebuflen);
		return;
	}
	busy = 1;
	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = DATA;
	idesc.id_fix = IGNORE;
	cp = &namebuf[PATH_MAX - 1];
	*cp = '\0';
	if (curdir != ino) {
		idesc.id_parent = curdir;
		goto namelookup;
	}
	while (ino != ROOTINO) {
		idesc.id_number = ino;
		idesc.id_func = findino;
		idesc.id_name = "..";
		if ((ckinode(ginode(ino), &idesc) & FOUND) == 0)
			break;
	namelookup:
		idesc.id_number = idesc.id_parent;
		idesc.id_parent = ino;
		idesc.id_func = findname;
		idesc.id_name = namebuf;
		if ((ckinode(ginode(idesc.id_number), &idesc)&FOUND) == 0)
			break;
		len = strlen(namebuf);
		cp -= len;
		memcpy(cp, namebuf, (size_t)len);
		*--cp = '/';
		if (cp < &namebuf[MAXNAMLEN])
			break;
		ino = idesc.id_number;
	}
	busy = 0;
	if (ino != ROOTINO)
		*--cp = '?';
	memcpy(namebuf, cp, (size_t)(&namebuf[PATH_MAX] - cp));
}

/*ARGSUSED*/
void
catch(int signo)
{
	ckfini(0);			/* XXX signal race */
	_exit(12);
}

/*
 * When preening, allow a single quit to signal
 * a special exit after filesystem checks complete
 * so that reboot sequence may be interrupted.
 */
/*ARGSUSED*/
void
catchquit(int signo)
{
	extern volatile sig_atomic_t returntosingle;
	static const char message[] =
	    "returning to single-user after filesystem check\n";

	write(STDOUT_FILENO, message, sizeof(message)-1);
	returntosingle = 1;
	(void)signal(SIGQUIT, SIG_DFL);
}

/*
 * Ignore a single quit signal; wait and flush just in case.
 * Used by child processes in preen.
 */
/*ARGSUSED*/
void
voidquit(int signo)
{
	int save_errno = errno;

	sleep(1);
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_DFL);
	errno = save_errno;
}

/*
 * determine whether an inode should be fixed.
 */
int
dofix(struct inodesc *idesc, char *msg)
{
	switch (idesc->id_fix) {

	case DONTKNOW:
		if (idesc->id_type == DATA)
			direrror(idesc->id_number, msg);
		else
			pwarn("%s", msg);
		if (preen) {
			printf(" (SALVAGED)\n");
			idesc->id_fix = FIX;
			return (ALTERED);
		}
		if (reply("SALVAGE") == 0) {
			idesc->id_fix = NOFIX;
			return (0);
		}
		idesc->id_fix = FIX;
		return (ALTERED);

	case FIX:
		return (ALTERED);

	case NOFIX:
	case IGNORE:
		return (0);

	default:
		errexit("UNKNOWN INODESC FIX MODE %d\n", idesc->id_fix);
	}
	/* NOTREACHED */
}

int (* info_fn)(char *, size_t) = NULL;
char *info_filesys = "?";

/*ARGSUSED*/
void
catchinfo(int signo)
{
	static int info_fd;
	int save_errno = errno;
	struct iovec iov[4];
	char buf[1024];

	if (signo == 0) {
		info_fd = open(_PATH_TTY, O_WRONLY);
		signal(SIGINFO, catchinfo);
	} else if (info_fd > 0 && info_fn != NULL && info_fn(buf, sizeof buf)) {
		iov[0].iov_base = info_filesys;
		iov[0].iov_len = strlen(info_filesys);
		iov[1].iov_base = ": ";
		iov[1].iov_len = sizeof ": " - 1;
		iov[2].iov_base = buf;
		iov[2].iov_len = strlen(buf);
		iov[3].iov_base = "\n";
		iov[3].iov_len = sizeof "\n" - 1;

		writev(info_fd, iov, 4);
	}
	errno = save_errno;
}
@


1.50
log
@snprintf+write --> dprintf

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.49 2015/01/20 18:22:21 deraadt Exp $	*/
d596 2
a597 1
	int save_errno = errno, fd;
d601 12
a612 11
	if (info_fn != NULL && info_fn(buf, sizeof buf)) {
		fd = open(_PATH_TTY, O_WRONLY);
		if (fd >= 0) {
			iov[0].iov_base = info_filesys;
			iov[0].iov_len = strlen(info_filesys);
			iov[1].iov_base = ": ";
			iov[1].iov_len = sizeof ": " - 1;
			iov[2].iov_base = buf;
			iov[2].iov_len = strlen(buf);
			iov[3].iov_base = "\n";
			iov[3].iov_len = sizeof "\n" - 1;
d614 1
a614 3
			writev(fd, iov, 4);
			close(fd);
		}
@


1.49
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.48 2015/01/16 06:39:57 deraadt Exp $	*/
d527 2
a528 1
	char buf[1024];
d530 1
a530 3
	snprintf(buf, sizeof buf,
	    "returning to single-user after filesystem check\n");
	write(STDOUT_FILENO, buf, strlen(buf));
@


1.48
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.47 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE isset setbit clrbit */
@


1.47
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.46 2014/05/24 14:54:49 krw Exp $	*/
d33 1
a33 1
#include <sys/param.h>
a34 1
#include <sys/types.h>
d45 1
d476 1
a476 1
	cp = &namebuf[MAXPATHLEN - 1];
d506 1
a506 1
	memcpy(namebuf, cp, (size_t)(&namebuf[MAXPATHLEN] - cp));
@


1.46
log
@Use consistent format specifiers (%lld) and casts (long long) when
printing out block numbers and sector numbers. Make output verbiage
consistent. -Wall happier.

Original diff and ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.45 2014/05/21 18:53:05 krw Exp $	*/
d398 2
a399 2
int
allocblk(long frags)
d401 2
a402 1
	int i, j, k, cg, baseblk;
d443 1
a443 1
freeblk(daddr_t blkno, long frags)
@


1.45
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.44 2014/05/20 21:11:16 krw Exp $	*/
d352 2
a353 3
				    (long long)((blk * DEV_BSIZE + i) /
				    secsize),
				    (long long)(blk + i / DEV_BSIZE));
d355 2
a356 2
				printf(" %lld,",
				    (long long)(blk + i / DEV_BSIZE));
d385 2
a386 3
				    (long long)((blk * DEV_BSIZE + i) /
				    secsize),
				    (long long)(blk + i / DEV_BSIZE));
d388 2
a389 2
				printf(" %lld,",
				    (long long)(blk + i / DEV_BSIZE));
@


1.44
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.43 2014/05/09 13:19:34 krw Exp $	*/
a619 1

@


1.43
log
@Fix '-b' option to work with the superblock locations output by newfs
on 4096-byte sector disks. No-op on 512-byte sector disks.

Adhering to the bedrock idea that ffs will *never* use anything but
512-byte block disk addressing (a.k.a. daddr_t), and believing that
the 'fake' bread()/bwrite() functions should always be using 512-btye
block numbers like their kernel big brothers, nuke the computed
dev_bsize and use DEV_BSIZE for conversions to/from byte offsets.

Spotted and various fixes tested by David Vasek.

Still to fix: scanning for superblocks on 4K disks.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.42 2013/11/01 17:36:18 krw Exp $	*/
d342 1
a342 3
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
	else if (read(fd, buf, (int)size) == size)
a344 2
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
d349 1
a349 2
		if (read(fd, cp, (int)secsize) != secsize) {
			(void)lseek(fd, offset + i + secsize, SEEK_SET);
d376 1
a376 3
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
	else if (write(fd, buf, (int)size) == size) {
a380 2
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
d383 1
a383 2
		if (write(fd, cp, (int)secsize) != secsize) {
			(void)lseek(fd, offset + i + secsize, SEEK_SET);
@


1.42
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.41 2013/06/11 16:42:04 deraadt Exp $	*/
d232 1
a232 1
		    (bp->b_errs == bp->b_size / dev_bsize) ? "" : "PARTIALLY ",
d291 1
a291 1
	if (havesb && sblk.b_bno != sblockloc / dev_bsize && !preen &&
d293 1
a293 1
		sblk.b_bno = sblockloc / dev_bsize;
d341 1
a341 1
	offset *= dev_bsize;
d355 1
a355 1
			if (secsize != dev_bsize && dev_bsize != 1)
d357 1
a357 1
				    (long long)((blk * dev_bsize + i) /
d359 1
a359 1
				    (long long)(blk + i / dev_bsize));
d362 1
a362 1
				    (long long)(blk + i / dev_bsize));
d380 1
a380 1
	offset *= dev_bsize;
d391 11
a401 4
	for (cp = buf, i = 0; i < size; i += dev_bsize, cp += dev_bsize)
		if (write(fd, cp, (int)dev_bsize) != dev_bsize) {
			(void)lseek(fd, offset + i + dev_bsize, SEEK_SET);
			printf(" %lld,", (long long)(blk + i / dev_bsize));
@


1.41
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.40 2013/04/24 13:46:29 deraadt Exp $	*/
d233 1
a233 1
		    bp->b_bno);
d253 1
a253 1
	pfatal("CANNOT %s: BLK %lld", mesg, blk);
d357 3
a359 2
				    (blk * dev_bsize + i) / secsize,
				    blk + i / dev_bsize);
d361 2
a362 1
				printf(" %lld,", blk + i / dev_bsize);
d394 1
a394 1
			printf(" %lld,", blk + i / dev_bsize);
@


1.40
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.39 2011/04/24 07:07:03 otto Exp $	*/
d56 1
a56 1
static void rwerror(char *, daddr64_t);
d182 1
a182 1
getdatablk(daddr64_t blkno, long size)
d209 1
a209 1
getblk(struct bufarea *bp, daddr64_t blk, long size)
d211 1
a211 1
	daddr64_t dblk;
d248 1
a248 1
rwerror(char *mesg, daddr64_t blk)
d334 1
a334 1
bread(int fd, char *buf, daddr64_t blk, long size)
d369 1
a369 1
bwrite(int fd, char *buf, daddr64_t blk, long size)
d445 1
a445 1
freeblk(daddr64_t blkno, long frags)
@


1.39
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.38 2011/04/16 16:37:21 otto Exp $	*/
d129 2
a130 1
		errexit("inoinfo: inumber %d out of range", inum);
@


1.38
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.37 2009/12/10 16:01:51 deraadt Exp $	*/
d514 1
a514 2
	if (!doinglevel2)
		ckfini(0);			/* XXX signal race */
@


1.37
log
@do not leak memory, found by parfait, ok millert otto
(one case was a false positive, but one is a modified copy of the other)
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.36 2009/10/27 23:59:32 deraadt Exp $	*/
d116 19
@


1.36
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.35 2008/06/10 23:10:29 otto Exp $	*/
d142 3
a144 3
			if (i >= MINBUFS) {
				free(bp);
				free(bufp);
a145 1
			}
@


1.35
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.34 2007/06/25 19:59:55 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)utilities.c	8.1 (Berkeley) 6/5/93";
#else
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.34 2007/06/25 19:59:55 otto Exp $";
#endif
#endif /* not lint */
@


1.34
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.33 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.33 2007/04/10 16:08:17 millert Exp $";
d459 1
a459 1
	    (statemap[curdir] != DSTATE && statemap[curdir] != DFOUND)) {
@


1.33
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.32 2007/03/19 13:27:47 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.32 2007/03/19 13:27:47 pedro Exp $";
d64 1
a64 1
static void rwerror(char *, daddr_t);
d171 1
a171 1
getdatablk(daddr_t blkno, long size)
d198 1
a198 1
getblk(struct bufarea *bp, daddr_t blk, long size)
d200 1
a200 1
	daddr_t dblk;
d220 1
a220 1
		pfatal("WRITING %sZERO'ED BLOCK %d TO DISK\n",
d237 1
a237 1
rwerror(char *mesg, daddr_t blk)
d242 1
a242 1
	pfatal("CANNOT %s: BLK %d", mesg, blk);
d323 1
a323 1
bread(int fd, char *buf, daddr_t blk, long size)
d345 1
a345 1
				printf(" %ld (%ld),",
d349 1
a349 1
				printf(" %ld,", blk + i / dev_bsize);
d358 1
a358 1
bwrite(int fd, char *buf, daddr_t blk, long size)
d381 1
a381 1
			printf(" %ld,", blk + i / dev_bsize);
d434 1
a434 1
freeblk(daddr_t blkno, long frags)
@


1.32
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.31 2007/02/13 20:37:07 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.31 2007/02/13 20:37:07 otto Exp $";
d67 1
a67 1
ftypeok(struct ufs1_dinode *dp)
d69 1
a69 1
	switch (dp->di_mode & IFMT) {
d80 1
a80 1
			printf("bad file type 0%o\n", dp->di_mode);
d230 1
a230 1
		    fsbtodb(&sblock, sblock.fs_ffs1_csaddr + j * sblock.fs_frag),
d253 1
d265 14
a278 2
	/* Force update on next mount */
	sblock.fs_ffs1_flags &= ~FS_FLAGS_UPDATED;
d280 3
a282 3
	if (havesb && sblk.b_bno != SBOFF / dev_bsize &&
	    !preen && reply("UPDATE STANDARD SUPERBLOCK")) {
		sblk.b_bno = SBOFF / dev_bsize;
@


1.31
log
@"Fix" a horrible signal handler. ckfini() breaks all the rules for
signal handlers, calling free() and not being reentrant. This commit
fixes to most importamt problem (^C on the "MARK FILESYSTEM CLEAN?"
question causes a double free), but actually SIGINT handling should
be completely rewritten.  ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.30 2006/04/17 19:33:54 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.30 2006/04/17 19:33:54 deraadt Exp $";
d230 1
a230 1
		    fsbtodb(&sblock, sblock.fs_csaddr + j * sblock.fs_frag),
d264 2
a265 1
	sblock.fs_flags &= ~FS_FLAGS_UPDATED; /* Force update on next mount */
@


1.30
log
@more signal handler cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.29 2006/04/17 19:22:29 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.29 2006/04/17 19:22:29 deraadt Exp $";
d48 1
d252 5
d261 1
d305 1
@


1.29
log
@solve half of the signal race issues
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.28 2006/04/17 19:18:09 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.28 2006/04/17 19:18:09 deraadt Exp $";
d478 1
d480 1
a480 1
catch(int n)
d492 1
d494 1
a494 1
catchquit(int n)
d510 1
d512 1
a512 1
voidquit(int n)
d514 1
d519 1
@


1.28
log
@prettier code; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.27 2006/04/07 11:25:37 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.27 2006/04/07 11:25:37 pedro Exp $";
a480 1
	/* XXX signal race */
d482 2
a483 2
		ckfini(0);
	exit(12);
@


1.27
log
@fsck needs to unset FS_FLAGS_UPDATED if it changes the super block
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.26 2006/04/02 00:48:35 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.26 2006/04/02 00:48:35 deraadt Exp $";
a68 1

a76 1

d87 1
a87 2
	int persevere;
	int c;
d102 1
a151 1
				
d254 1
d295 1
d297 1
d563 2
a564 1
	int save_errno = errno;
a565 2
	struct iovec iov[4];
	int fd;
@


1.26
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.25 2006/03/30 01:16:31 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.25 2006/03/30 01:16:31 deraadt Exp $";
d259 1
@


1.25
log
@when asking y or n, accept "F" which forces yes from the on.  i have
wished for this for 10+ year, but always forgotten to make the change
after cleaning up a nasty file system; ok pedro millert
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.24 2006/03/22 20:24:32 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.24 2006/03/22 20:24:32 deraadt Exp $";
d308 1
a308 1
	if (lseek(fd, offset, 0) < 0)
d313 1
a313 1
	if (lseek(fd, offset, 0) < 0)
d320 1
a320 1
			(void)lseek(fd, offset + i + secsize, 0);
d345 1
a345 1
	if (lseek(fd, offset, 0) < 0)
d352 1
a352 1
	if (lseek(fd, offset, 0) < 0)
d357 1
a357 1
			(void)lseek(fd, offset + i + dev_bsize, 0);
@


1.24
log
@earlier asprintf diff caused malloc in signal handler.  clarify the
code a bit more so that this mistake will not be done again
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.22 2006/03/12 02:28:28 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.23 2006/03/20 20:00:05 dhill Exp $";
d105 2
a106 2
	do	{
		printf("%s? [yn] ", question);
d109 4
@


1.23
log
@NetBSD Coverity CID 2074: Fix memory leak.

ok deraadt@@
@
text
@d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.22 2006/03/12 02:28:28 deraadt Exp $";
d551 1
a551 1
int (* info_fn)(char *) = NULL;
d554 1
d556 1
a556 1
catchinfo(int n)
d559 1
a559 1
	char *buf = NULL;
d563 1
a563 1
	if (info_fn != NULL && info_fn(buf)) {
a578 2
	if (buf)
		free(buf);
@


1.22
log
@use asprintf instead of a static buffer; dhill, tested by pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.21 2006/01/25 06:25:46 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.21 2006/01/25 06:25:46 tedu Exp $";
d147 4
a150 1
			if (i >= MINBUFS)
d152 1
@


1.21
log
@spell fall through as FALLTHROUGH
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.20 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.20 2003/08/25 23:28:15 tedu Exp $";
d547 1
a547 1
int (* info_fn)(char *, int) = NULL;
d554 1
a554 1
	char buf[1024];
d558 1
a558 1
	if (info_fn != NULL && info_fn(buf, sizeof buf)) {
d574 2
@


1.20
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.19 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.19 2003/06/02 20:06:15 millert Exp $";
d178 1
a178 1
	/* fall through */
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.18 2003/04/26 00:39:28 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.18 2003/04/26 00:39:28 deraadt Exp $";
d66 1
a66 1
ftypeok(struct dinode *dp)
@


1.18
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.17 2002/08/23 09:09:04 gluk Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.17 2002/08/23 09:09:04 gluk Exp $";
@


1.17
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.16 2002/08/20 21:57:56 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.16 2002/08/20 21:57:56 deraadt Exp $";
d420 1
a420 1
getpathname(char *namebuf, ino_t curdir, ino_t ino)
d428 1
a428 1
		(void)strcpy(namebuf, "/");
d433 1
a433 1
		(void)strcpy(namebuf, "?");
@


1.16
log
@clean some more signal races, some cannot be fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.15 2002/02/23 21:23:46 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.15 2002/02/23 21:23:46 deraadt Exp $";
d70 1
a70 2
ftypeok(dp)
	struct dinode *dp;
d91 1
a91 2
reply(question)
	char *question;
d131 1
a131 1
bufinit()
d148 1
a148 1
		bp = (struct bufarea *)malloc(sizeof(struct bufarea));
d169 1
a169 3
getdatablk(blkno, size)
	daddr_t blkno;
	long size;
d196 1
a196 4
getblk(bp, blk, size)
	struct bufarea *bp;
	daddr_t blk;
	long size;
d211 1
a211 3
flush(fd, bp)
	int fd;
	struct bufarea *bp;
d235 1
a235 3
rwerror(mesg, blk)
	char *mesg;
	daddr_t blk;
d246 1
a246 2
ckfini(markclean)
	int markclean;
d269 1
a269 1
		free((char *)bp);
d296 1
a296 5
bread(fd, buf, blk, size)
	int fd;
	char *buf;
	daddr_t blk;
	long size;
d331 1
a331 5
bwrite(fd, buf, blk, size)
	int fd;
	char *buf;
	daddr_t blk;
	long size;
d364 1
a364 2
allocblk(frags)
	long frags;
d407 1
a407 3
freeblk(blkno, frags)
	daddr_t blkno;
	long frags;
d420 1
a420 3
getpathname(namebuf, curdir, ino)
	char *namebuf;
	ino_t curdir, ino;
d474 1
a474 2
catch(n)
	int n;
d488 1
a488 2
catchquit(n)
	int n;
d505 1
a505 2
voidquit(n)
	int n;
d517 1
a517 3
dofix(idesc, msg)
	struct inodesc *idesc;
	char *msg;
a518 1

d555 1
a555 2
catchinfo(n)
	int n;
@


1.15
log
@getc() returns an int
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.14 2002/02/16 21:27:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.14 2002/02/16 21:27:34 millert Exp $";
d517 2
a518 1
	extern int returntosingle;
d520 3
a522 2
	/* XXX signal race */
	printf("returning to single-user after filesystem check\n");
a535 1
	/* XXX signal race */
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.13 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.13 2001/11/05 07:39:16 mpech Exp $";
d96 1
a96 1
	char c;
@


1.13
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.12 2001/04/13 02:39:05 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.12 2001/04/13 02:39:05 gluk Exp $";
d67 1
a67 1
static void rwerror __P((char *, daddr_t));
@


1.12
log
@Fix overflow in superblock. From FreeBSD.

FreeBSD's log:
> The ffs superblock includes a 128-byte region for use by temporary
> in-core pointers to summary information. An array in this region
> (fs_csp) could overflow on filesystems with a very large number of
> cylinder groups (~16000 on i386 with 8k blocks). When this happens,
> other fields in the superblock get corrupted, and fsck refuses to
> check the filesystem.
>
> Solve this problem by replacing the fs_csp array in 'struct fs'
> with a single pointer, and add padding to keep the length of the
> 128-byte region fixed. Update the kernel and userland utilities
> to use just this single pointer.
>
> With this change, the kernel no longer makes use of the superblock
> fields 'fs_csshift' and 'fs_csmask'. Add a comment to newfs/mkfs.c
> to indicate that these fields must be calculated for compatibility
> with older kernels.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.11 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.11 2001/03/02 08:33:55 art Exp $";
d135 1
a135 1
	register struct bufarea *bp;
d175 1
a175 1
	register struct bufarea *bp;
d201 1
a201 1
	register struct bufarea *bp;
d220 1
a220 1
	register struct bufarea *bp;
d222 1
a222 1
	register int i, j;
d260 1
a260 1
	register struct bufarea *bp, *nbp;
d448 1
a448 1
	register char *cp;
d545 1
a545 1
	register struct inodesc *idesc;
@


1.11
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.10 2001/01/19 17:57:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.10 2001/01/19 17:57:36 deraadt Exp $";
d236 1
a236 1
		bwrite(fswritefd, (char *)sblock.fs_csp[j],
@


1.10
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.9 2001/01/15 19:52:37 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.9 2001/01/15 19:52:37 deraadt Exp $";
d104 1
d115 3
a117 2
		while (c != '\n' && getc(stdin) != '\n')
			if (feof(stdin))
d119 2
d125 1
d387 2
a388 1
	register int i, j, k;
d403 7
a409 1
			for (k = 0; k < frags; k++)
d411 2
d414 4
@


1.9
log
@save_errno in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.8 2000/09/30 16:06:34 aaron Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.8 2000/09/30 16:06:34 aaron Exp $";
d484 1
d501 1
d516 1
@


1.8
log
@Some format string problems that were missed during initial audit; deraadt@@ and
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.7 1999/03/01 07:45:18 d Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.7 1999/03/01 07:45:18 d Exp $";
d57 1
d567 1
d588 1
@


1.7
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.6 1997/10/06 20:22:37 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.6 1997/10/06 20:22:37 deraadt Exp $";
d533 1
a533 1
			pwarn(msg);
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.4 1997/06/25 18:12:17 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.4 1997/06/25 18:12:17 kstailey Exp $";
d47 2
d57 2
d497 1
a497 1
	extern returntosingle;
d558 30
@


1.5
log
@VFS Lite2 Changes
@
text
@a98 1
		resolved = 0;
d109 2
a110 3
		while (c != '\n' && getc(stdin) != '\n') {
			if (feof(stdin)) {
				resolved = 0;
a111 2
			}
		}
a115 1
	resolved = 0;
d377 1
a377 2
	int i, j, k, cg, baseblk;
	struct cg *cgp = &cgrp;
d392 1
a392 7
			cg = dtog(&sblock, i + j);
			getblk(&cgblk, cgtod(&sblock, cg), sblock.fs_cgsize);
			if (!cg_chkmagic(cgp))
				pfatal("CG %d: BAD MAGIC NUMBER\n", cg);
			baseblk = dtogd(&sblock, i + j);

			for (k = 0; k < frags; k++) {
a393 2
				clrbit(cg_blksfree(cgp), baseblk + k);
			}
a394 4
			if (frags == sblock.fs_frag)
				cgp->cg_cs.cs_nbfree--;
			else
				cgp->cg_cs.cs_nffree -= frags;
@


1.4
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.3 1996/10/20 08:36:42 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.3 1996/10/20 08:36:42 tholo Exp $";
d99 1
d110 3
a112 2
		while (c != '\n' && getc(stdin) != '\n')
			if (feof(stdin))
d114 2
d120 1
d382 2
a383 1
	register int i, j, k;
d398 7
a404 1
			for (k = 0; k < frags; k++)
d406 2
d409 4
@


1.3
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.2 1996/06/23 14:30:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.2 1996/06/23 14:30:35 deraadt Exp $";
d129 1
a129 1
	pbp = pdirbp = (struct bufarea *)0;
d275 1
a275 1
	pbp = pdirbp = (struct bufarea *)0;
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: utilities.c,v 1.15 1995/04/23 10:33:09 cgd Exp $	*/
/*	$NetBSD: utilities.c,v 1.15 1995/04/23 10:33:09 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.15 1995/04/23 10:33:09 cgd Exp $";
d56 1
d62 2
d233 1
a233 1
void
d241 1
a241 1
	pfatal("CANNOT %s: BLK %ld", mesg, blk);
d476 2
a477 1
catch()
d490 2
a491 1
catchquit()
d505 2
a506 1
voidquit()
a553 58

/* VARARGS1 */
errexit(s1, s2, s3, s4)
	char *s1;
	long s2, s3, s4;
{
	printf(s1, s2, s3, s4);
	exit(8);
}

/*
 * An unexpected inconsistency occured.
 * Die if preening, otherwise just print message and continue.
 */
/* VARARGS1 */
pfatal(s, a1, a2, a3)
	char *s;
	long a1, a2, a3;
{

	if (preen) {
		printf("%s: ", cdevname);
		printf(s, a1, a2, a3);
		printf("\n");
		printf("%s: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.\n",
			cdevname);
		exit(8);
	}
	printf(s, a1, a2, a3);
}

/*
 * Pwarn just prints a message when not preening,
 * or a warning (preceded by filename) when preening.
 */
/* VARARGS1 */
pwarn(s, a1, a2, a3, a4, a5, a6)
	char *s;
	long a1, a2, a3, a4, a5, a6;
{

	if (preen)
		printf("%s: ", cdevname);
	printf(s, a1, a2, a3, a4, a5, a6);
}

#ifndef lint
/*
 * Stub for routines from kernel.
 */
panic(s)
	char *s;
{

	pfatal("INTERNAL INCONSISTENCY:");
	errexit(s);
}
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: utilities.c,v 1.15 1995/04/23 10:33:09 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
