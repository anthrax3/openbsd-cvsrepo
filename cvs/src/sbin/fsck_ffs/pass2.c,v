head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.10
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.12
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.8
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.4
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.34.0.8
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.6
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	F55lwc3gS4GN2mLs;

1.36
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	Uu5nFG3wCl0LACBb;

1.35
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.34;
commitid	qlzrzgnJ4ZiiF6XQ;

1.34
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2011.05.08.14.38.40;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.22.20.24.32;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.12.02.28.28;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.25.06.25.46;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.16.14.51.37;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.16.18.15.41;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.16.17.37.25;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.11.01.43.45;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.26.00.39.28;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.16.02.57.51;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.07.18.26.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.28.21.22.47;	author gluk;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.02.08.33.55;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.03.01.07.45.18;	author d;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.22.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.33.34;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.10.20.08.36.38;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.28.12.37.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.06.04.06.54;	author jason;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@/*	$OpenBSD: pass2.c,v 1.36 2015/01/16 06:39:57 deraadt Exp $	*/
/*	$NetBSD: pass2.c,v 1.17 1996/09/27 22:45:15 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE roundup */
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "fsck.h"
#include "fsutil.h"
#include "extern.h"

#define MINDIRSIZE	(sizeof(struct dirtemplate))

static int pass2check(struct inodesc *);
static int blksort(const void *, const void *);

static int info_max;
static int info_pos;

static int
pass2_info1(char *buf, size_t buflen)
{
	return (snprintf(buf, buflen, "phase 2, directory %d/%d",
	    info_pos, info_max) > 0);
}

static int
pass2_info2(char *buf, size_t buflen)
{
	if (snprintf(buf, buflen, "phase 2, parent directory %d/%d",
	    info_pos, info_max) > 0)
		return (strlen(buf));
	return (0);
}

void
pass2(void)
{
	union dinode *dp;
	struct inoinfo **inpp, *inp, *pinp;
	struct inoinfo **inpend;
	struct inodesc curino;
	union dinode dino;
	char pathbuf[PATH_MAX + 1];
	int i;

	switch (GET_ISTATE(ROOTINO)) {

	case USTATE:
		pfatal("ROOT INODE UNALLOCATED");
		if (reply("ALLOCATE") == 0) {
			ckfini(0);
			errexit("%s", "");
		}
		if (allocdir(ROOTINO, ROOTINO, 0755) != ROOTINO)
			errexit("CANNOT ALLOCATE ROOT INODE\n");
		break;

	case DCLEAR:
		pfatal("DUPS/BAD IN ROOT INODE");
		if (reply("REALLOCATE")) {
			freeino(ROOTINO);
			if (allocdir(ROOTINO, ROOTINO, 0755) != ROOTINO)
				errexit("CANNOT ALLOCATE ROOT INODE\n");
			break;
		}
		if (reply("CONTINUE") == 0) {
			ckfini(0);
			errexit("%s", "");
		}
		break;

	case FSTATE:
	case FCLEAR:
		pfatal("ROOT INODE NOT DIRECTORY");
		if (reply("REALLOCATE")) {
			freeino(ROOTINO);
			if (allocdir(ROOTINO, ROOTINO, 0755) != ROOTINO)
				errexit("CANNOT ALLOCATE ROOT INODE\n");
			break;
		}
		if (reply("FIX") == 0) {
			ckfini(0);
			errexit("%s", "");
		}
		dp = ginode(ROOTINO);
		DIP_SET(dp, di_mode, DIP(dp, di_mode) & ~IFMT);
		DIP_SET(dp, di_mode, DIP(dp, di_mode) | IFDIR);
		inodirty();
		break;

	case DSTATE:
		break;

	default:
		errexit("BAD STATE %d FOR ROOT INODE\n", GET_ISTATE(ROOTINO));
	}
	SET_ISTATE(ROOTINO, DFOUND);
	/*
	 * Sort the directory list into disk block order.
	 */
	qsort(inpsort, (size_t)inplast, sizeof *inpsort, blksort);
	/*
	 * Check the integrity of each directory.
	 */
	memset(&curino, 0, sizeof(struct inodesc));
	curino.id_type = DATA;
	curino.id_func = pass2check;
	inpend = &inpsort[inplast];
	info_pos = 0;
	info_max = inpend - inpsort;
	info_fn = pass2_info1;
	for (inpp = inpsort; inpp < inpend; inpp++) {
		inp = *inpp;
		info_pos ++;
		if (inp->i_isize == 0)
			continue;
		if (inp->i_isize < MINDIRSIZE) {
			direrror(inp->i_number, "DIRECTORY TOO SHORT");
			inp->i_isize = roundup(MINDIRSIZE, DIRBLKSIZ);
			if (reply("FIX") == 1) {
				dp = ginode(inp->i_number);
				DIP_SET(dp, di_size, inp->i_isize);
				inodirty();
			}
		} else if ((inp->i_isize & (DIRBLKSIZ - 1)) != 0) {
			getpathname(pathbuf, sizeof pathbuf,
			    inp->i_number, inp->i_number);
			if (usedsoftdep)
			        pfatal("%s %s: LENGTH %zu NOT MULTIPLE of %d",
				       "DIRECTORY", pathbuf, inp->i_isize,
				       DIRBLKSIZ);
			else
				pwarn("%s %s: LENGTH %zu NOT MULTIPLE OF %d",
				      "DIRECTORY", pathbuf, inp->i_isize,
				      DIRBLKSIZ);
			if (preen)
				printf(" (ADJUSTED)\n");
			inp->i_isize = roundup(inp->i_isize, DIRBLKSIZ);
			if (preen || reply("ADJUST") == 1) {
				dp = ginode(inp->i_number);
				DIP_SET(dp, di_size, inp->i_isize);
				inodirty();
			}
		}
		memset(&dino, 0, sizeof(union dinode));
		dp = &dino;
		DIP_SET(dp, di_mode, IFDIR);
		DIP_SET(dp, di_size, inp->i_isize);
		for (i = 0;
		     i < (inp->i_numblks<NDADDR ? inp->i_numblks : NDADDR);
		     i++)
			DIP_SET(dp, di_db[i], inp->i_blks[i]);
		if (inp->i_numblks > NDADDR)
			for (i = 0; i < NIADDR; i++)
				DIP_SET(dp, di_ib[i], inp->i_blks[NDADDR + i]);
		curino.id_number = inp->i_number;
		curino.id_parent = inp->i_parent;
		(void)ckinode(dp, &curino);
	}
	/*
	 * Now that the parents of all directories have been found,
	 * make another pass to verify the value of `..'
	 */
	info_pos = 0;
	info_fn = pass2_info2;
	for (inpp = inpsort; inpp < inpend; inpp++) {
		inp = *inpp;
		info_pos++;
		if (inp->i_parent == 0 || inp->i_isize == 0)
			continue;
		if (inp->i_dotdot == inp->i_parent ||
		    inp->i_dotdot == (ino_t)-1)
			continue;
		if (inp->i_dotdot == 0) {
			inp->i_dotdot = inp->i_parent;
			fileerror(inp->i_parent, inp->i_number, "MISSING '..'");
			if (reply("FIX") == 0)
				continue;
			(void)makeentry(inp->i_number, inp->i_parent, "..");
			ILNCOUNT(inp->i_parent)--;
			continue;
		}
		fileerror(inp->i_parent, inp->i_number,
		    "BAD INODE NUMBER FOR '..'");
		if (reply("FIX") == 0)
			continue;
		ILNCOUNT(inp->i_dotdot)++;
		ILNCOUNT(inp->i_parent)--;
		inp->i_dotdot = inp->i_parent;
		(void)changeino(inp->i_number, "..", inp->i_parent);
	}
	info_fn = NULL;
	/*
	 * Create a list of children for each directory.
	 */
	inpend = &inpsort[inplast];
	for (inpp = inpsort; inpp < inpend; inpp++) {
		inp = *inpp;
		if (inp->i_parent == 0 ||
		    inp->i_number == ROOTINO)
			continue;
		pinp = getinoinfo(inp->i_parent);
		inp->i_sibling = pinp->i_child;
		pinp->i_child = inp;
	}
	/*
	 * Mark all the directories that can be found from the root.
	 */
	propagate(ROOTINO);
}

static int
pass2check(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;
	struct inoinfo *inp;
	int n, entrysize, ret = 0;
	union dinode *dp;
	char *errmsg;
	struct direct proto;
	char namebuf[PATH_MAX + 1];
	char pathbuf[PATH_MAX + 1];

	/*
	 * check for "."
	 */
	if (idesc->id_entryno != 0)
		goto chk1;
	if (dirp->d_ino != 0 && strcmp(dirp->d_name, ".") == 0) {
		if (dirp->d_ino != idesc->id_number) {
			direrror(idesc->id_number, "BAD INODE NUMBER FOR '.'");
			dirp->d_ino = idesc->id_number;
			if (reply("FIX") == 1)
				ret |= ALTERED;
		}
		if (dirp->d_type != DT_DIR) {
			direrror(idesc->id_number, "BAD TYPE VALUE FOR '.'");
			dirp->d_type = DT_DIR;
			if (reply("FIX") == 1)
				ret |= ALTERED;
		}
		goto chk1;
	}
	direrror(idesc->id_number, "MISSING '.'");
	proto.d_ino = idesc->id_number;
	proto.d_type = DT_DIR;
	proto.d_namlen = 1;
	(void)strlcpy(proto.d_name, ".", sizeof proto.d_name);
	entrysize = DIRSIZ(0, &proto);
	if (dirp->d_ino != 0 && strcmp(dirp->d_name, "..") != 0) {
		pfatal("CANNOT FIX, FIRST ENTRY IN DIRECTORY CONTAINS %s\n",
			dirp->d_name);
	} else if (dirp->d_reclen < entrysize) {
		pfatal("CANNOT FIX, INSUFFICIENT SPACE TO ADD '.'\n");
	} else if (dirp->d_reclen < 2 * entrysize) {
		proto.d_reclen = dirp->d_reclen;
		memcpy(dirp, &proto, (size_t)entrysize);
		if (reply("FIX") == 1)
			ret |= ALTERED;
	} else {
		n = dirp->d_reclen - entrysize;
		proto.d_reclen = entrysize;
		memcpy(dirp, &proto, (size_t)entrysize);
		idesc->id_entryno++;
		ILNCOUNT(dirp->d_ino)--;
		dirp = (struct direct *)((char *)(dirp) + entrysize);
		memset(dirp, 0, (size_t)n);
		dirp->d_reclen = n;
		if (reply("FIX") == 1)
			ret |= ALTERED;
	}
chk1:
	if (idesc->id_entryno > 1)
		goto chk2;
	inp = getinoinfo(idesc->id_number);
	proto.d_ino = inp->i_parent;
	proto.d_type = DT_DIR;
	proto.d_namlen = 2;
	(void)strlcpy(proto.d_name, "..", sizeof proto.d_name);
	entrysize = DIRSIZ(0, &proto);
	if (idesc->id_entryno == 0) {
		n = DIRSIZ(0, dirp);
		if (dirp->d_reclen < n + entrysize)
			goto chk2;
		proto.d_reclen = dirp->d_reclen - n;
		dirp->d_reclen = n;
		idesc->id_entryno++;
		ILNCOUNT(dirp->d_ino)--;
		dirp = (struct direct *)((char *)(dirp) + n);
		memset(dirp, 0, (size_t)proto.d_reclen);
		dirp->d_reclen = proto.d_reclen;
	}
	if (dirp->d_ino != 0 && strcmp(dirp->d_name, "..") == 0) {
		inp->i_dotdot = dirp->d_ino;
		if (dirp->d_type != DT_DIR) {
			direrror(idesc->id_number, "BAD TYPE VALUE FOR '..'");
			dirp->d_type = DT_DIR;
			if (reply("FIX") == 1)
				ret |= ALTERED;
		}
		goto chk2;
	}
	if (dirp->d_ino != 0 && strcmp(dirp->d_name, ".") != 0) {
		fileerror(inp->i_parent, idesc->id_number, "MISSING '..'");
		pfatal("CANNOT FIX, SECOND ENTRY IN DIRECTORY CONTAINS %s\n",
			dirp->d_name);
		inp->i_dotdot = -1;
	} else if (dirp->d_reclen < entrysize) {
		fileerror(inp->i_parent, idesc->id_number, "MISSING '..'");
		pfatal("CANNOT FIX, INSUFFICIENT SPACE TO ADD '..'\n");
		inp->i_dotdot = -1;
	} else if (inp->i_parent != 0) {
		/*
		 * We know the parent, so fix now.
		 */
		inp->i_dotdot = inp->i_parent;
		fileerror(inp->i_parent, idesc->id_number, "MISSING '..'");
		proto.d_reclen = dirp->d_reclen;
		memcpy(dirp, &proto, (size_t)entrysize);
		if (reply("FIX") == 1)
			ret |= ALTERED;
	}
	idesc->id_entryno++;
	if (dirp->d_ino != 0)
		ILNCOUNT(dirp->d_ino)--;
	return (ret|KEEPON);
chk2:
	if (dirp->d_ino == 0)
		return (ret|KEEPON);
	if (dirp->d_namlen <= 2 &&
	    dirp->d_name[0] == '.' &&
	    idesc->id_entryno >= 2) {
		if (dirp->d_namlen == 1) {
			direrror(idesc->id_number, "EXTRA '.' ENTRY");
			dirp->d_ino = 0;
			if (reply("FIX") == 1)
				ret |= ALTERED;
			return (KEEPON | ret);
		}
		if (dirp->d_name[1] == '.') {
			direrror(idesc->id_number, "EXTRA '..' ENTRY");
			dirp->d_ino = 0;
			if (reply("FIX") == 1)
				ret |= ALTERED;
			return (KEEPON | ret);
		}
	}
	idesc->id_entryno++;
	n = 0;
	if (dirp->d_ino > maxino) {
		fileerror(idesc->id_number, dirp->d_ino, "I OUT OF RANGE");
		n = reply("REMOVE");
	} else {
again:
		switch (GET_ISTATE(dirp->d_ino)) {
		case USTATE:
			if (idesc->id_entryno <= 2)
				break;
			fileerror(idesc->id_number, dirp->d_ino, "UNALLOCATED");
			n = reply("REMOVE");
			break;

		case DCLEAR:
		case FCLEAR:
			if (idesc->id_entryno <= 2)
				break;
			if (GET_ISTATE(dirp->d_ino) == FCLEAR)
				errmsg = "DUP/BAD";
			else if (!preen && !usedsoftdep)
				errmsg = "ZERO LENGTH DIRECTORY";
			else {
				n = 1;
				break;
			}
			fileerror(idesc->id_number, dirp->d_ino, errmsg);
			if ((n = reply("REMOVE")) == 1)
				break;
			dp = ginode(dirp->d_ino);
			SET_ISTATE(dirp->d_ino, (DIP(dp, di_mode) & IFMT) ==
			    IFDIR ? DSTATE : FSTATE);
			ILNCOUNT(dirp->d_ino) = DIP(dp, di_nlink);
			goto again;

		case DSTATE:
		case DFOUND:
			inp = getinoinfo(dirp->d_ino);
			if (inp->i_parent != 0 && idesc->id_entryno > 2) {
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				getpathname(namebuf, sizeof namebuf,
				    dirp->d_ino, dirp->d_ino);
				pwarn("%s %s %s\n", pathbuf,
				    "IS AN EXTRANEOUS HARD LINK TO DIRECTORY",
				    namebuf);
				if (preen) {
					printf (" (REMOVED)\n");
					n = 1;
					break;
				}
				if ((n = reply("REMOVE")) == 1)
					break;
			}
			if (idesc->id_entryno > 2)
				inp->i_parent = idesc->id_number;
			/* FALLTHROUGH */

		case FSTATE:
			if (dirp->d_type != GET_ITYPE(dirp->d_ino)) {
				fileerror(idesc->id_number, dirp->d_ino,
				    "BAD TYPE VALUE");
				dirp->d_type = GET_ITYPE(dirp->d_ino);
				if (reply("FIX") == 1)
					ret |= ALTERED;
			}
			ILNCOUNT(dirp->d_ino)--;
			break;

		default:
			errexit("BAD STATE %d FOR INODE I=%llu\n",
			    GET_ISTATE(dirp->d_ino),
			    (unsigned long long)dirp->d_ino);
		}
	}
	if (n == 0)
		return (ret|KEEPON);
	dirp->d_ino = 0;
	return (ret|KEEPON|ALTERED);
}

/*
 * Routine to sort disk blocks.
 */
static int
blksort(const void *inpp1, const void *inpp2)
{
	daddr_t d;

	d = (* (struct inoinfo **) inpp1)->i_blks[0] -
	    (* (struct inoinfo **) inpp2)->i_blks[0];
	if (d < 0)
		return (-1);
	else if (d > 0)
		return (1);
	else
		return (0);
}
@


1.36
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.35 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE roundup */
@


1.35
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.34 2013/06/11 16:42:04 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d42 1
d80 1
a80 1
	char pathbuf[MAXPATHLEN + 1];
d258 2
a259 2
	char namebuf[MAXPATHLEN + 1];
	char pathbuf[MAXPATHLEN + 1];
@


1.34
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.33 2013/04/24 13:46:29 deraadt Exp $	*/
d165 2
a166 2
			        pfatal("%s %s: LENGTH %ld NOT MULTIPLE of %d",
				       "DIRECTORY", pathbuf, (long)inp->i_isize,
d169 2
a170 2
				pwarn("%s %s: LENGTH %ld NOT MULTIPLE OF %d",
				      "DIRECTORY", pathbuf, (long)inp->i_isize,
@


1.33
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.32 2011/05/08 14:38:40 otto Exp $	*/
d472 1
a472 1
	daddr64_t d;
@


1.32
log
@Small memory optimization from NetBSD; ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.31 2011/04/24 07:07:03 otto Exp $	*/
d455 3
a457 2
			errexit("BAD STATE %d FOR INODE I=%d\n",
			    GET_ISTATE(dirp->d_ino), dirp->d_ino);
@


1.31
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.30 2011/04/16 16:37:21 otto Exp $	*/
a238 1
		inp->i_parentp = pinp;
@


1.30
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.29 2009/10/27 23:59:32 deraadt Exp $	*/
a261 7
	 * If converting, set directory entry type.
	 */
	if (doinglevel2 && dirp->d_ino > 0 && dirp->d_ino < maxino) {
		dirp->d_type = GET_ITYPE(dirp->d_ino);
		ret |= ALTERED;
	}
	/*
d273 1
a273 1
		if (newinofmt && dirp->d_type != DT_DIR) {
d283 1
a283 4
	if (newinofmt)
		proto.d_type = DT_DIR;
	else
		proto.d_type = 0;
a285 9
#	if BYTE_ORDER == LITTLE_ENDIAN
		if (!newinofmt) {
			u_char tmp;

			tmp = proto.d_type;
			proto.d_type = proto.d_namlen;
			proto.d_namlen = tmp;
		}
#	endif
d314 1
a314 4
	if (newinofmt)
		proto.d_type = DT_DIR;
	else
		proto.d_type = 0;
a316 9
#	if BYTE_ORDER == LITTLE_ENDIAN
		if (!newinofmt) {
			u_char tmp;

			tmp = proto.d_type;
			proto.d_type = proto.d_namlen;
			proto.d_namlen = tmp;
		}
#	endif
d332 1
a332 1
		if (newinofmt && dirp->d_type != DT_DIR) {
d445 1
a445 2
			if (newinofmt && dirp->d_type !=
			    GET_ITYPE(dirp->d_ino)) {
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.28 2008/06/10 23:10:29 otto Exp $	*/
d216 1
a216 1
			lncntp[inp->i_parent]--;
d223 2
a224 2
		lncntp[inp->i_dotdot]++;
		lncntp[inp->i_parent]--;
d321 1
a321 1
		lncntp[dirp->d_ino]--;
d356 1
a356 1
		lncntp[dirp->d_ino]--;
d393 1
a393 1
		lncntp[dirp->d_ino]--;
d449 1
a449 1
			lncntp[dirp->d_ino] = DIP(dp, di_nlink);
d484 1
a484 1
			lncntp[dirp->d_ino]--;
@


1.28
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.27 2007/06/25 19:59:55 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)pass2.c	8.6 (Berkeley) 10/27/94";
#else
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.27 2007/06/25 19:59:55 otto Exp $";
#endif
#endif /* not lint */
@


1.27
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.26 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.26 2007/04/10 16:08:17 millert Exp $";
d90 1
a90 1
	switch (statemap[ROOTINO]) {
d139 1
a139 1
		errexit("BAD STATE %d FOR ROOT INODE\n", statemap[ROOTINO]);
d141 1
a141 1
	statemap[ROOTINO] = DFOUND;
d273 1
a273 1
		dirp->d_type = typemap[dirp->d_ino];
d431 1
a431 1
		switch (statemap[dirp->d_ino]) {
d443 1
a443 1
			if (statemap[dirp->d_ino] == FCLEAR)
d455 2
a456 2
			statemap[dirp->d_ino] =
			    (DIP(dp, di_mode) & IFMT) == IFDIR ? DSTATE : FSTATE;
d484 2
a485 1
			if (newinofmt && dirp->d_type != typemap[dirp->d_ino]) {
d488 1
a488 1
				dirp->d_type = typemap[dirp->d_ino];
d497 1
a497 1
			    statemap[dirp->d_ino], dirp->d_ino);
@


1.26
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.25 2006/03/22 20:24:32 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.25 2006/03/22 20:24:32 deraadt Exp $";
d511 10
a520 2
	return ((* (struct inoinfo **) inpp1)->i_blks[0] -
		(* (struct inoinfo **) inpp2)->i_blks[0]);
@


1.25
log
@earlier asprintf diff caused malloc in signal handler.  clarify the
code a bit more so that this mistake will not be done again
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.23 2006/01/25 06:25:46 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.23 2006/01/25 06:25:46 tedu Exp $";
d82 1
a82 1
	struct ufs1_dinode *dp;
d86 1
a86 1
	struct ufs1_dinode dino;
d88 1
d130 2
a131 2
		dp->di_mode &= ~IFMT;
		dp->di_mode |= IFDIR;
d166 1
a166 1
				dp->di_size = inp->i_isize;
d185 1
a185 1
				dp->di_size = inp->i_isize;
d189 11
a199 4
		memset(&dino, 0, sizeof(struct ufs1_dinode));
		dino.di_mode = IFDIR;
		dino.di_size = inp->i_isize;
		memcpy(&dino.di_db[0], &inp->i_blks[0], (size_t)inp->i_numblks);
d202 1
a202 1
		(void)ckinode(&dino, &curino);
d263 1
a263 1
	struct ufs1_dinode *dp;
d456 2
a457 2
			    (dp->di_mode & IFMT) == IFDIR ? DSTATE : FSTATE;
			lncntp[dirp->d_ino] = dp->di_nlink;
@


1.24
log
@use asprintf instead of a static buffer; dhill, tested by pedro
@
text
@d64 1
a64 1
pass2_info1(char *buf)
d66 1
a66 1
	return (asprintf(&buf, "phase 2, directory %d/%d",
d71 1
a71 1
pass2_info2(char *buf)
d73 1
a73 1
	if (asprintf(&buf, "phase 2, parent directory %d/%d",
@


1.23
log
@spell fall through as FALLTHROUGH
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.22 2005/06/16 14:51:37 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.22 2005/06/16 14:51:37 millert Exp $";
d64 1
a64 1
pass2_info1(char *buf, int buflen)
d66 1
a66 1
	return (snprintf(buf, buflen, "phase 2, directory %d/%d",
d71 1
a71 1
pass2_info2(char *buf, int buflen)
d73 1
a73 1
	if (snprintf(buf, buflen, "phase 2, parent directory %d/%d",
@


1.22
log
@bye bye whiteouts
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.21 2005/04/16 18:15:41 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.21 2005/04/16 18:15:41 millert Exp $";
d473 1
a473 1
			/* fall through */
@


1.21
log
@Since the return value from the *_info functions is only actually used as a
boolean, make it so.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.20 2005/04/16 17:37:25 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.20 2005/04/16 17:37:25 deraadt Exp $";
a140 4
	if (newinofmt) {
		statemap[WINO] = FSTATE;
		typemap[WINO] = DT_WHT;
	}
a420 8
	} else if (newinofmt &&
		   ((dirp->d_ino == WINO && dirp->d_type != DT_WHT) ||
		    (dirp->d_ino != WINO && dirp->d_type == DT_WHT))) {
		fileerror(idesc->id_number, dirp->d_ino, "BAD WHITEOUT ENTRY");
		dirp->d_ino = WINO;
		dirp->d_type = DT_WHT;
		if (reply("FIX") == 1)
			ret |= ALTERED;
@


1.20
log
@while snprintf and strlcpy and strlcat have this nice >buflen API (and the
-1 mess as well), it is probably not wise to make other functions do the same
thing.  make them return strlen().  ok uwe marco
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.19 2003/10/11 01:43:45 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.19 2003/10/11 01:43:45 tedu Exp $";
d66 2
a67 4
	if (snprintf(buf, buflen, "phase 2, directory %d/%d",
	    info_pos, info_max) > 0)
		return (strlen(buf));
	return (0);
@


1.19
log
@consistent newlines, from tom cosgrove at arches-consulting.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.18 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.18 2003/08/25 23:28:15 tedu Exp $";
d66 4
a69 2
	return snprintf(buf, buflen, "phase 2, directory %d/%d",
		info_pos, info_max);
d75 4
a78 2
	return snprintf(buf, buflen, "phase 2, parent directory %d/%d",
		info_pos, info_max);
@


1.18
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.17 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.17 2003/06/02 20:06:15 millert Exp $";
d136 1
a136 1
		errexit("BAD STATE %d FOR ROOT INODE", statemap[ROOTINO]);
d497 1
a497 1
			errexit("BAD STATE %d FOR INODE I=%d",
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.16 2003/04/26 00:39:28 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.16 2003/04/26 00:39:28 deraadt Exp $";
d80 1
a80 1
	struct dinode *dp;
d84 1
a84 1
	struct dinode dino;
d190 1
a190 1
		memset(&dino, 0, sizeof(struct dinode));
d257 1
a257 1
	struct dinode *dp;
@


1.16
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.15 2003/04/16 02:57:51 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.15 2003/04/16 02:57:51 deraadt Exp $";
@


1.15
log
@string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.14 2002/08/23 09:09:04 gluk Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.14 2002/08/23 09:09:04 gluk Exp $";
d175 2
a176 1
			getpathname(pathbuf, inp->i_number, inp->i_number);
d470 4
a473 3
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
				getpathname(namebuf, dirp->d_ino, dirp->d_ino);
@


1.14
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.13 2002/06/09 08:13:05 todd Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pass2.c,v 1.13 2002/06/09 08:13:05 todd Exp $";
d300 1
a300 1
	(void)strcpy(proto.d_name, ".");
d343 1
a343 1
	(void)strcpy(proto.d_name, "..");
@


1.13
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.12 2002/02/16 21:27:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.12 2002/02/16 21:27:34 millert Exp $";
d59 1
a59 1
#define MINDIRSIZE	(sizeof (struct dirtemplate))
d68 1
a68 3
pass2_info1(buf, buflen)
	char	*buf;
	int	buflen;
d75 1
a75 3
pass2_info2(buf, buflen)
	char	*buf;
	int	buflen;
d82 1
a82 1
pass2()
d150 1
a150 1
	qsort((char *)inpsort, (size_t)inplast, sizeof *inpsort, blksort);
d255 1
a255 2
pass2check(idesc)
	struct inodesc *idesc;
d380 1
a380 1
		inp->i_dotdot = (ino_t)-1;
d384 1
a384 1
		inp->i_dotdot = (ino_t)-1;
d513 1
a513 2
blksort(inpp1, inpp2)
	const void *inpp1, *inpp2;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.11 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.11 2001/11/05 07:39:16 mpech Exp $";
d72 1
a72 1
	return snprintf(buf, buflen, "phase 2, directory %d/%d", 
d81 1
a81 1
	return snprintf(buf, buflen, "phase 2, parent directory %d/%d", 
d278 1
a278 1
	/* 
@


1.11
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.10 2001/07/07 18:26:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.10 2001/07/07 18:26:12 deraadt Exp $";
d61 2
a62 2
static int pass2check __P((struct inodesc *));
static int blksort __P((const void *, const void *));
@


1.10
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.9 2001/05/28 21:22:47 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.9 2001/05/28 21:22:47 gluk Exp $";
d88 2
a89 2
	register struct dinode *dp;
	register struct inoinfo **inpp, *inp, *pinp;
d262 2
a263 2
	register struct direct *dirp = idesc->id_dirp;
	register struct inoinfo *inp;
@


1.9
log
@Fix directory state tracking.

- If the lost+found directory is created by fsck, it will do a cacheino()
  which sets the inoinfo's i_parent and i_dotdot to 0, but they never get
  set to ROOTINO. This means that propagate will never find lost+found and
  its descendents, subdirectories will remain DSTATE (instead of DFOUND)
  even though they are correctly linked in, and pass4.c will try to
  clear them unsuccessfully, thinking that there is no link count from the
  DSTATE directory's parent. The result is that you need to run fsck twice
  and get "EXTRANEOUS HARD LINK TO DIRECTORY" error (which are unexpected
  and fatal when running in preen mode). The fix is to set i_parent and
  i_dotdot to "parent" after the second cacheino() call in dir.c:allocdir().
  From NetBSD via FreeBSD.
- modify propagate() so it be able to start from any point in the tree.
- minor tweaks to get more generality in state propagation.

In other words fsck doesn't leave unremovable directories anymore.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d181 2
a182 2
			        pfatal("%s %s: LENGTH %d NOT MULTIPLE of %d",
				       "DIRECTORY", pathbuf, inp->i_isize,
d185 2
a186 2
				pwarn("%s %s: LENGTH %d NOT MULTIPLE OF %d",
				      "DIRECTORY", pathbuf, inp->i_isize,
@


1.8
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.7 1999/03/01 07:45:18 d Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.7 1999/03/01 07:45:18 d Exp $";
d89 1
a89 1
	register struct inoinfo **inpp, *inp;
d146 1
d239 14
d255 1
a255 1
	propagate();
d485 1
a485 1
				else if ((n = reply("REMOVE")) == 1)
@


1.8.2.1
log
@Pull in patch from current:
Fix (gluk):
Fix directory state tracking.

- If the lost+found directory is created by fsck, it will do a cacheino()
  which sets the inoinfo's i_parent and i_dotdot to 0, but they never get
  set to ROOTINO. This means that propagate will never find lost+found and
  its descendents, subdirectories will remain DSTATE (instead of DFOUND)
  even though they are correctly linked in, and pass4.c will try to
  clear them unsuccessfully, thinking that there is no link count from the
  DSTATE directory's parent. The result is that you need to run fsck twice
  and get "EXTRANEOUS HARD LINK TO DIRECTORY" error (which are unexpected
  and fatal when running in preen mode). The fix is to set i_parent and
  i_dotdot to "parent" after the second cacheino() call in dir.c:allocdir().
  From NetBSD via FreeBSD.
- modify propagate() so it be able to start from any point in the tree.
- minor tweaks to get more generality in state propagation.

In other words fsck doesn't leave unremovable directories anymore.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d89 1
a89 1
	register struct inoinfo **inpp, *inp, *pinp;
a145 1
	statemap[ROOTINO] = DFOUND;
a237 14
	 * Create a list of children for each directory.
	 */
	inpend = &inpsort[inplast];
	for (inpp = inpsort; inpp < inpend; inpp++) {
		inp = *inpp;
		if (inp->i_parent == 0 ||
		    inp->i_number == ROOTINO)
			continue;
		pinp = getinoinfo(inp->i_parent);
		inp->i_parentp = pinp;
		inp->i_sibling = pinp->i_child;
		pinp->i_child = inp;
	}
	/*
d240 1
a240 1
	propagate(ROOTINO);
d470 1
a470 1
				if ((n = reply("REMOVE")) == 1)
@


1.7
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.6 1997/10/06 20:22:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.6 1997/10/06 20:22:35 deraadt Exp $";
d99 2
a100 1
		if (reply("ALLOCATE") == 0)
d102 1
d115 2
a116 1
		if (reply("CONTINUE") == 0)
d118 1
d130 2
a131 1
		if (reply("FIX") == 0)
d133 1
d179 8
a186 2
			pwarn("DIRECTORY %s: LENGTH %d NOT MULTIPLE OF %d",
				pathbuf, inp->i_isize, DIRBLKSIZ);
d440 1
a440 1
			else if (!preen)
d465 5
a469 2
				if (preen)
					printf(" (IGNORED)\n");
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.4 1996/10/20 08:36:38 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.4 1996/10/20 08:36:38 tholo Exp $";
d64 21
d155 3
d160 1
d196 2
d200 1
d224 1
@


1.5
log
@VFS Lite2 Changes
@
text
@d78 1
a78 2
		if (reply("ALLOCATE") == 0) {
			ckfini(0);
a79 1
		}
d92 1
a92 2
		if (reply("CONTINUE") == 0) {
			ckfini(0);
a93 1
		}
d105 1
a105 2
		if (reply("FIX") == 0) {
			ckfini(0);
a106 1
		}
d148 2
a149 8
			if (usedsoftdep)
			        pfatal("%s %s: LENGTH %d NOT MULTIPLE of %d",
				       "DIRECTORY", pathbuf, inp->i_isize,
				       DIRBLKSIZ);
			else
				pwarn("%s %s: LENGTH %d NOT MULTIPLE OF %d",
				      "DIRECTORY", pathbuf, inp->i_isize,
				      DIRBLKSIZ);
d399 1
a399 1
			else if (!preen && !usedsoftdep)
d424 2
a425 5
				if (preen) {
					printf (" (REMOVED)\n");
					n = 1;
					break;
				}
@


1.4
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: pass2.c,v 1.3 1996/06/23 14:30:31 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.3 1996/06/23 14:30:31 deraadt Exp $";
d78 2
a79 1
		if (reply("ALLOCATE") == 0)
d81 1
d94 2
a95 1
		if (reply("CONTINUE") == 0)
d97 1
d109 2
a110 1
		if (reply("FIX") == 0)
d112 1
d154 8
a161 2
			pwarn("DIRECTORY %s: LENGTH %d NOT MULTIPLE OF %d",
				pathbuf, inp->i_isize, DIRBLKSIZ);
d411 1
a411 1
			else if (!preen)
d436 5
a440 2
				if (preen)
					printf(" (IGNORED)\n");
@


1.3
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: pass2.c,v 1.14 1996/05/21 15:32:16 mycroft Exp $	*/
/*	$NetBSD: pass2.c,v 1.14 1996/05/21 15:32:16 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass2.c,v 1.14 1996/05/21 15:32:16 mycroft Exp $";
d54 1
d56 1
d61 2
a62 1
int	pass2check(), blksort();
d79 1
a79 1
			errexit("");
d93 1
a93 1
			errexit("");
d106 1
a106 1
			errexit("");
a118 1
	statemap[ROOTINO] = DFOUND;
a174 3
		if (statemap[inp->i_parent] == DFOUND &&
		    statemap[inp->i_number] == DSTATE)
			statemap[inp->i_number] = DFOUND;
d202 1
a202 1
int
a414 4
			if (statemap[idesc->id_number] == DFOUND)
				statemap[dirp->d_ino] = DFOUND;
			/* fall through */

d458 1
a458 1
int
d460 1
a460 1
	struct inoinfo **inpp1, **inpp2;
d462 2
a463 2

	return ((*inpp1)->i_blks[0] - (*inpp2)->i_blks[0]);
@


1.2
log
@be more careful
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: pass2.c,v 1.14 1996/05/21 15:32:16 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pass2.c,v 1.12 1995/03/18 14:55:52 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: pass2.c,v 1.12 1995/03/18 14:55:52 cgd Exp $";
a129 1
	dp = &dino;
a141 1
				dp = &dino;
d152 1
a152 1
				dp->di_size = roundup(inp->i_isize, DIRBLKSIZ);
a153 1
				dp = &dino;
d158 2
a159 2
		dp->di_size = inp->i_isize;
		memcpy(&dp->di_db[0], &inp->i_blks[0], (size_t)inp->i_numblks);
d162 1
a162 1
		(void)ckinode(dp, &curino);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
