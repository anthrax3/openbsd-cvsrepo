head	1.63;
access;
symbols
	OPENBSD_6_2:1.63.0.2
	OPENBSD_6_2_BASE:1.63
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.60.0.4
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.60.0.2
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.57.0.6
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.8
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.8
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.4
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.37.0.4
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.8
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.6
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.63
date	2016.09.09.15.37.15;	author tb;	state Exp;
branches;
next	1.62;
commitid	TXzQrSRLn0xGub30;

1.62
date	2016.09.01.10.34.40;	author otto;	state Exp;
branches;
next	1.61;
commitid	qmrxWP8Y8Dgfrt6n;

1.61
date	2016.08.20.15.04.21;	author tb;	state Exp;
branches;
next	1.60;
commitid	nYLoQNeToeyyY9Ok;

1.60
date	2015.11.24.21.42.54;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	6EMrEc62rgfU2L4N;

1.59
date	2015.10.15.15.11.10;	author semarie;	state Exp;
branches;
next	1.58;
commitid	Ku0Mi2yDsPNOS1Oo;

1.58
date	2015.10.14.16.58.55;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	7vEhrQZryjO1AvBa;

1.57
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	F55lwc3gS4GN2mLs;

1.56
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	Uu5nFG3wCl0LACBb;

1.55
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.54;
commitid	qlzrzgnJ4ZiiF6XQ;

1.54
date	2014.05.29.12.02.50;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.09.13.56.33;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.09.13.19.34;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.22.04.38.02;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2013.11.05.00.51.58;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.12.15.26.34;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.15.14.25.09;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.09.21.34.56;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.05.07.36.23;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.10.13.49.24;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.09.21.56.06;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.01.23.42.35;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.01.06.41.33;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.18.20.49.46;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.19.22.13.36;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.18.21.44.01;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.16.08.34.29;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.13.15.56.22;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.12.16.32.54;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.09.19.52.32;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.08.19.02.23;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.17.19.18.08;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.09.13.35.02;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.19.15.18.01;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.25.04.19.39;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.26.08.01.54;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.30.22.54.32;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.07.18.26.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.15.09.01.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.19.16.22.17;	author gluk;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.13.02.39.05;	author gluk;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.06.20.43.31;	author gluk;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.08.17.09.13.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.22.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.33.35;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.10.20.08.36.41;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.28.12.37.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Tighten pledge for fsdb and eliminate a strcmp("fsdb", getprogname())
by passing a flag to setup().

ok deraadt
@
text
@/*	$OpenBSD: setup.c,v 1.62 2016/09/01 10:34:40 otto Exp $	*/
/*	$NetBSD: setup.c,v 1.27 1996/09/27 22:45:19 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE roundup */
#define DKTYPENAMES
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/disklabel.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <util.h>
#include <limits.h>
#include <ctype.h>
#include <err.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define altsblock (*asblk.b_un.b_fs)
#define POWEROF2(num)	(((num) & ((num) - 1)) == 0)

void badsb(int, char *);
int calcsb(char *, int, struct fs *, struct disklabel *, uint32_t);
static struct disklabel *getdisklabel(char *, int);
static int readsb(int);
static int cmpsb(struct fs *, struct fs *);
static char rdevname[PATH_MAX];

long numdirs, listmax, inplast;

/*
 * Possible locations for the superblock.
 */
static const int sbtry[] = SBLOCKSEARCH;
/* locations the 1st alternate sb can be at */
static const int altsbtry[] = { 32, 64, 128, 144, 160, 192, 256 };

int
setup(char *dev, int isfsdb)
{
	long cg, size, asked, i, j;
	size_t bmapsize;
	struct disklabel *lp;
	off_t sizepb;
	struct stat statb;
	struct fs proto;
	int doskipclean;
	int32_t maxsymlinklen, nindir, inopb;
	u_int64_t maxfilesize;
	char *realdev;

	havesb = 0;
	fswritefd = fsreadfd = -1;
	doskipclean = skipclean;
	if ((fsreadfd = opendev(dev, O_RDONLY, 0, &realdev)) < 0) {
		printf("Can't open %s: %s\n", dev, strerror(errno));
		return (0);
	}
	if (strncmp(dev, realdev, PATH_MAX) != 0) {
		blockcheck(unrawname(realdev));
		strlcpy(rdevname, realdev, sizeof(rdevname));
		setcdevname(rdevname, dev, preen);

		if (isfsdb || !hotroot())
			if (pledge("stdio rpath wpath getpw tty disklabel",
			    NULL) == -1)
				err(1, "pledge");
	}
	if (fstat(fsreadfd, &statb) < 0) {
		printf("Can't stat %s: %s\n", realdev, strerror(errno));
		close(fsreadfd);
		return (0);
	}
	if (!S_ISCHR(statb.st_mode)) {
		pfatal("%s is not a character device", realdev);
		if (reply("CONTINUE") == 0) {
			close(fsreadfd);
			return (0);
		}
	}
	if (preen == 0) {
		printf("** %s", realdev);
		if (strncmp(dev, realdev, PATH_MAX) != 0)
			printf(" (%s)", dev);
	}
	if (nflag || (fswritefd = opendev(dev, O_WRONLY, 0, NULL)) < 0) {
		fswritefd = -1;
		if (preen)
			pfatal("NO WRITE ACCESS");
		printf(" (NO WRITE)");
	}
	if (preen == 0)
		printf("\n");
	fsmodified = 0;
	lfdir = 0;
	initbarea(&sblk);
	initbarea(&asblk);
	sblk.b_un.b_buf = malloc(SBSIZE);
	asblk.b_un.b_buf = malloc(SBSIZE);
	if (sblk.b_un.b_buf == NULL || asblk.b_un.b_buf == NULL)
		errexit("cannot allocate space for superblock\n");
	if ((lp = getdisklabel(NULL, fsreadfd)) != NULL)
		secsize = lp->d_secsize;
	else
		secsize = DEV_BSIZE;

	if (isfsdb) {
		if (pledge("stdio rpath getpw tty", NULL) == -1)
			err(1, "pledge");
	} else if (!hotroot()) {
#ifndef SMALL
		if (pledge("stdio getpw", NULL) == -1)
			err(1, "pledge");
#else
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
#endif
	}

	/*
	 * Read in the superblock, looking for alternates if necessary
	 */
	if (readsb(1) == 0) {
		if (bflag || preen ||
		    calcsb(realdev, fsreadfd, &proto, lp, SBLOCK_UFS1) == 0)
			return(0);
		if (reply("LOOK FOR ALTERNATE SUPERBLOCKS") == 0)
			return (0);
		for (i = 0; i < sizeof(altsbtry) / sizeof(altsbtry[0]); i++) {
			bflag = altsbtry[i];
			/* proto partially setup by calcsb */
			if (readsb(0) != 0 &&
			    proto.fs_fsize == sblock.fs_fsize &&
			    proto.fs_bsize == sblock.fs_bsize)
				goto found;
		}
		for (cg = 0; cg < proto.fs_ncg; cg++) {
			bflag = fsbtodb(&proto, cgsblock(&proto, cg));
			if (readsb(0) != 0 &&
			    proto.fs_fsize == sblock.fs_fsize &&
			    proto.fs_bsize == sblock.fs_bsize)
				goto found;
		}
		calcsb(realdev, fsreadfd, &proto, lp, SBLOCK_UFS2);
		for (cg = 0; cg < proto.fs_ncg; cg++) {
			bflag = fsbtodb(&proto, cgsblock(&proto, cg));
			if (readsb(0) != 0 &&
			    proto.fs_fsize == sblock.fs_fsize &&
			    proto.fs_bsize == sblock.fs_bsize)
				goto found;
		}
		if (cg >= proto.fs_ncg) {
			printf("%s %s\n%s %s\n%s %s\n",
			    "SEARCH FOR ALTERNATE SUPER-BLOCK",
			    "FAILED. YOU MUST USE THE",
			    "-b OPTION TO FSCK_FFS TO SPECIFY THE",
			    "LOCATION OF AN ALTERNATE",
			    "SUPER-BLOCK TO SUPPLY NEEDED",
			    "INFORMATION; SEE fsck_ffs(8).");
			return(0);
		}
found:
		doskipclean = 0;
		pwarn("USING ALTERNATE SUPERBLOCK AT %d\n", bflag);
	}
	if (debug)
		printf("clean = %d\n", sblock.fs_clean);
	if (sblock.fs_clean & FS_ISCLEAN) {
		if (doskipclean) {
			pwarn("%sile system is clean; not checking\n",
			    preen ? "f" : "** F");
			return (-1);
		}
		if (!preen)
			pwarn("** File system is already clean\n");
	}
	maxfsblock = sblock.fs_size;
	maxino = sblock.fs_ncg * sblock.fs_ipg;
	sizepb = sblock.fs_bsize;
	maxfilesize = sblock.fs_bsize * NDADDR - 1;
	for (i = 0; i < NIADDR; i++) {
		sizepb *= NINDIR(&sblock);
		maxfilesize += sizepb;
	}
	/*
	 * Check and potentially fix certain fields in the super block.
	 */
	if (sblock.fs_optim != FS_OPTTIME && sblock.fs_optim != FS_OPTSPACE) {
		pfatal("UNDEFINED OPTIMIZATION IN SUPERBLOCK");
		if (reply("SET TO DEFAULT") == 1) {
			sblock.fs_optim = FS_OPTTIME;
			sbdirty();
		}
	}
	if ((sblock.fs_minfree < 0 || sblock.fs_minfree > 99)) {
		pfatal("IMPOSSIBLE MINFREE=%d IN SUPERBLOCK",
		    sblock.fs_minfree);
		if (reply("SET TO DEFAULT") == 1) {
			sblock.fs_minfree = 10;
			sbdirty();
		}
	}
	if (sblock.fs_npsect < sblock.fs_nsect ||
	    sblock.fs_npsect > sblock.fs_nsect*2) {
		pwarn("IMPOSSIBLE NPSECT=%d IN SUPERBLOCK",
		    sblock.fs_npsect);
		sblock.fs_npsect = sblock.fs_nsect;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("SET TO DEFAULT") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_bmask != ~(sblock.fs_bsize - 1)) {
		pwarn("INCORRECT BMASK=%x IN SUPERBLOCK",
		    sblock.fs_bmask);
		sblock.fs_bmask = ~(sblock.fs_bsize - 1);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_fmask != ~(sblock.fs_fsize - 1)) {
		pwarn("INCORRECT FMASK=%x IN SUPERBLOCK",
		    sblock.fs_fmask);
		sblock.fs_fmask = ~(sblock.fs_fsize - 1);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (1 << sblock.fs_bshift != sblock.fs_bsize) {
		pwarn("INCORRECT BSHIFT=%d IN SUPERBLOCK", sblock.fs_bshift);
		sblock.fs_bshift = ffs(sblock.fs_bsize) - 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (1 << sblock.fs_fshift != sblock.fs_fsize) {
		pwarn("INCORRECT FSHIFT=%d IN SUPERBLOCK", sblock.fs_fshift);
		sblock.fs_fshift = ffs(sblock.fs_fsize) - 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_inodefmt < FS_44INODEFMT) {
		pwarn("Format of filesystem is too old.\n");
		pwarn("Must update to modern format using a version of fsck\n");
		pfatal("from before release 5.0 with the command ``fsck -c 2''\n");
		exit(8);
	}
	if (sblock.fs_maxfilesize != maxfilesize) {
		pwarn("INCORRECT MAXFILESIZE=%llu IN SUPERBLOCK",
		    (unsigned long long)sblock.fs_maxfilesize);
		sblock.fs_maxfilesize = maxfilesize;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	maxsymlinklen = sblock.fs_magic == FS_UFS1_MAGIC ?
	    MAXSYMLINKLEN_UFS1 : MAXSYMLINKLEN_UFS2;
	if (sblock.fs_maxsymlinklen != maxsymlinklen) {
		pwarn("INCORRECT MAXSYMLINKLEN=%d IN SUPERBLOCK",
		    sblock.fs_maxsymlinklen);
		sblock.fs_maxsymlinklen = maxsymlinklen;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_qbmask != ~sblock.fs_bmask) {
		pwarn("INCORRECT QBMASK=%lx IN SUPERBLOCK",
		    (unsigned long)sblock.fs_qbmask);
		sblock.fs_qbmask = ~sblock.fs_bmask;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_qfmask != ~sblock.fs_fmask) {
		pwarn("INCORRECT QFMASK=%lx IN SUPERBLOCK",
		    (unsigned long)sblock.fs_qfmask);
		sblock.fs_qfmask = ~sblock.fs_fmask;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_cgsize != fragroundup(&sblock, CGSIZE(&sblock))) {
		pwarn("INCONSISTENT CGSIZE=%d\n", sblock.fs_cgsize);
		sblock.fs_cgsize = fragroundup(&sblock, CGSIZE(&sblock));
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_magic == FS_UFS2_MAGIC)
		inopb = sblock.fs_bsize / sizeof(struct ufs2_dinode);
	else
		inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
	if (INOPB(&sblock) != inopb) {
		pwarn("INCONSISTENT INOPB=%d\n", INOPB(&sblock));
		sblock.fs_inopb = inopb;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_magic == FS_UFS2_MAGIC)
		nindir = sblock.fs_bsize / sizeof(int64_t);
	else
		nindir = sblock.fs_bsize / sizeof(int32_t);
	if (NINDIR(&sblock) != nindir) {
		pwarn("INCONSISTENT NINDIR=%d\n", NINDIR(&sblock));
		sblock.fs_nindir = nindir;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (asblk.b_dirty && !bflag) {
		memcpy(&altsblock, &sblock, (size_t)sblock.fs_sbsize);
		flush(fswritefd, &asblk);
	}
	/*
	 * read in the summary info.
	 */
	asked = 0;
	sblock.fs_csp = calloc(1, sblock.fs_cssize);
	if (sblock.fs_csp == NULL) {
		printf("cannot alloc %u bytes for cylinder group summary area\n",
		    (unsigned)sblock.fs_cssize);
		goto badsblabel;
	}
	for (i = 0, j = 0; i < sblock.fs_cssize; i += sblock.fs_bsize, j++) {
		size = sblock.fs_cssize - i < sblock.fs_bsize ?
		    sblock.fs_cssize - i : sblock.fs_bsize;
		if (bread(fsreadfd, (char *)sblock.fs_csp + i,
		    fsbtodb(&sblock, sblock.fs_csaddr + j * sblock.fs_frag),
		    size) != 0 && !asked) {
			pfatal("BAD SUMMARY INFORMATION");
			if (reply("CONTINUE") == 0) {
				ckfini(0);
				errexit("%s", "");
			}
			asked++;
		}
	}
	/*
	 * allocate and initialize the necessary maps
	 */
	bmapsize = roundup(howmany(maxfsblock, NBBY), sizeof(int16_t));
	blockmap = calloc(bmapsize, sizeof(char));
	if (blockmap == NULL) {
		printf("cannot alloc %zu bytes for blockmap\n", bmapsize);
		goto badsblabel;
	}
	inostathead = calloc((unsigned)(sblock.fs_ncg),
	    sizeof(struct inostatlist));
	if (inostathead == NULL) {
		printf("cannot alloc %zu bytes for inostathead\n",
		    (unsigned)sblock.fs_ncg * sizeof(struct inostatlist));
		goto badsblabel;
	}
	numdirs = MAXIMUM(sblock.fs_cstotal.cs_ndir, 128);
	inplast = 0;
	listmax = numdirs + 10;
	inpsort = calloc((unsigned)listmax, sizeof(struct inoinfo *));
	if (inpsort == NULL) {
		printf("cannot alloc %zu bytes for inpsort\n",
		    (unsigned)listmax * sizeof(struct inoinfo *));
		goto badsblabel;
	}
	inphead = calloc((unsigned)numdirs, sizeof(struct inoinfo *));
	if (inphead == NULL) {
		printf("cannot alloc %zu bytes for inphead\n",
		    (unsigned)numdirs * sizeof(struct inoinfo *));
		goto badsblabel;
	}
	bufinit();
	if (sblock.fs_flags & FS_DOSOFTDEP)
		usedsoftdep = 1;
	else
		usedsoftdep = 0;
	return (1);

badsblabel:
	ckfini(0);
	return (0);
}

/*
 * Read in the super block and its summary info.
 */
static int
readsb(int listerr)
{
	daddr_t super = 0;
	int i;

	if (bflag) {
		super = bflag;

		if (bread(fsreadfd, (char *)&sblock, super, (long)SBSIZE) != 0)
			return (0);

		if (sblock.fs_magic != FS_UFS1_MAGIC &&
		    sblock.fs_magic != FS_UFS2_MAGIC) {
			badsb(listerr, "MAGIC NUMBER WRONG");
			return (0);
		}
	} else {
		for (i = 0; sbtry[i] != -1; i++) {
			super = sbtry[i] / DEV_BSIZE;

			if (bread(fsreadfd, (char *)&sblock, super,
			    (long)SBSIZE) != 0)
				return (0);

			if (sblock.fs_magic != FS_UFS1_MAGIC &&
			    sblock.fs_magic != FS_UFS2_MAGIC)
				continue; /* Not a superblock */

			/*
			 * Do not look for an FFS1 file system at SBLOCK_UFS2.
			 * Doing so will find the wrong super-block for file
			 * systems with 64k block size.
			 */
			if (sblock.fs_magic == FS_UFS1_MAGIC &&
			    sbtry[i] == SBLOCK_UFS2)
				continue;

			if (sblock.fs_magic == FS_UFS2_MAGIC &&
			    sblock.fs_sblockloc != sbtry[i])
				continue; /* Not a superblock */

			break;
		}

		if (sbtry[i] == -1) {
			badsb(listerr, "MAGIC NUMBER WRONG");
			return (0);
		}
	}

	sblk.b_bno = super;
	sblk.b_size = SBSIZE;

	/*
	 * run a few consistency checks of the super block
	 */
	if (sblock.fs_ncg < 1) {
		badsb(listerr, "NCG OUT OF RANGE");
		return (0);
	}
	if (sblock.fs_cpg < 1) {
		badsb(listerr, "CPG OUT OF RANGE");
		return (0);
	}
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		if (sblock.fs_ncg * sblock.fs_cpg < sblock.fs_ncyl ||
		    (sblock.fs_ncg - 1) * sblock.fs_cpg >= sblock.fs_ncyl) {
			badsb(listerr, "NCYL LESS THAN NCG*CPG");
			return (0);
		}
	}
	if (sblock.fs_sbsize > SBSIZE) {
		badsb(listerr, "SBSIZE PREPOSTEROUSLY LARGE");
		return (0);
	}

	if (!POWEROF2(sblock.fs_bsize) || sblock.fs_bsize < MINBSIZE ||
	    sblock.fs_bsize > MAXBSIZE) {
		badsb(listerr, "ILLEGAL BLOCK SIZE IN SUPERBLOCK");
		return (0);
	}

	if (!POWEROF2(sblock.fs_fsize) || sblock.fs_fsize > sblock.fs_bsize ||
	    sblock.fs_fsize < sblock.fs_bsize / MAXFRAG) {
		badsb(listerr, "ILLEGAL FRAGMENT SIZE IN SUPERBLOCK");
		return (0);
	}

	if (bflag)
		goto out;
	getblk(&asblk, cgsblock(&sblock, sblock.fs_ncg - 1), sblock.fs_sbsize);
	if (asblk.b_errs)
		return (0);
	if (cmpsb(&sblock, &altsblock)) {
		if (debug) {
			long *nlp, *olp, *endlp;

			printf("superblock mismatches\n");
			nlp = (long *)&altsblock;
			olp = (long *)&sblock;
			endlp = olp + (sblock.fs_sbsize / sizeof *olp);
			for ( ; olp < endlp; olp++, nlp++) {
				if (*olp == *nlp)
					continue;
				printf("offset %d, original %ld, alternate %ld\n",
				    (int)(olp - (long *)&sblock), *olp, *nlp);
			}
		}
		badsb(listerr,
		    "VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN LAST ALTERNATE");
		return (0);
	}
out:
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		sblock.fs_time = sblock.fs_ffs1_time;
		sblock.fs_size = sblock.fs_ffs1_size;
		sblock.fs_dsize = sblock.fs_ffs1_dsize;
		sblock.fs_csaddr = sblock.fs_ffs1_csaddr;
		sblock.fs_cstotal.cs_ndir = sblock.fs_ffs1_cstotal.cs_ndir;
		sblock.fs_cstotal.cs_nbfree = sblock.fs_ffs1_cstotal.cs_nbfree;
		sblock.fs_cstotal.cs_nifree = sblock.fs_ffs1_cstotal.cs_nifree;
		sblock.fs_cstotal.cs_nffree = sblock.fs_ffs1_cstotal.cs_nffree;
	}
	havesb = 1;
	return (1);
}

void
badsb(int listerr, char *s)
{

	if (!listerr)
		return;
	if (preen)
		printf("%s: ", cdevname());
	pfatal("BAD SUPER BLOCK: %s\n", s);
}

/*
 * Calculate a prototype superblock based on information in the disk label.
 * When done the cgsblock macro can be calculated and the fs_ncg field
 * can be used. Do NOT attempt to use other macros without verifying that
 * their needed information is available!
 */
int
calcsb(char *dev, int devfd, struct fs *fs, struct disklabel *lp,
    uint32_t sblockloc)
{
	struct partition *pp;
	char *cp;
	int i;

	cp = strchr(dev, '\0');
	if ((cp == NULL || (cp[-1] < 'a' || cp[-1] >= 'a' + MAXPARTITIONS)) &&
	    !isdigit((unsigned char)cp[-1])) {
		pfatal("%s: CANNOT FIGURE OUT FILE SYSTEM PARTITION\n", dev);
		return (0);
	}
	cp--;
	if (lp == NULL)
		pfatal("%s: CANNOT READ DISKLABEL\n", dev);
	if (isdigit((unsigned char)*cp))
		pp = &lp->d_partitions[0];
	else
		pp = &lp->d_partitions[*cp - 'a'];
	if (pp->p_fstype != FS_BSDFFS) {
		pfatal("%s: NOT LABELED AS A BSD FILE SYSTEM (%s)\n",
		    dev, pp->p_fstype < FSMAXTYPES ?
		    fstypenames[pp->p_fstype] : "unknown");
		return (0);
	}
	memset(fs, 0, sizeof(struct fs));
	fs->fs_fsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock);
	fs->fs_frag = DISKLABELV1_FFS_FRAG(pp->p_fragblock);
	fs->fs_fpg = pp->p_cpg * fs->fs_frag;
	fs->fs_bsize = fs->fs_fsize * fs->fs_frag;
	fs->fs_nspf = DL_SECTOBLK(lp, fs->fs_fsize / lp->d_secsize);
	for (fs->fs_fsbtodb = 0, i = NSPF(fs); i > 1; i >>= 1)
		fs->fs_fsbtodb++;
	/*
	 * fs->fs_size is in fragments, DL_GETPSIZE() is in disk sectors
	 * and fs_nspf is in DEV_BSIZE blocks. Shake well.
	 */
	fs->fs_size = DL_SECTOBLK(lp, DL_GETPSIZE(pp)) / fs->fs_nspf;
	fs->fs_ncg = howmany(fs->fs_size, fs->fs_fpg);
	/* we can't use lp->d_sbsize, it is the max sb size */
	fs->fs_sblkno = roundup(
		howmany(sblockloc + SBSIZE, fs->fs_fsize),
		fs->fs_frag);

	return (1);
}

static struct disklabel *
getdisklabel(char *s, int fd)
{
	static struct disklabel lab;

	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
		if (s == NULL)
			return (NULL);
		pwarn("ioctl (GCINFO): %s\n", strerror(errno));
		errexit("%s: can't read disk label\n", s);
	}
	return (&lab);
}

/*
 * Compare two superblocks
 */
static int
cmpsb(struct fs *sb, struct fs *asb)
{
	/*
	 * Only compare fields which should be the same, and ignore ones
	 * likely to change to ensure future compatibility.
	 */
	if (asb->fs_sblkno != sb->fs_sblkno ||
	    asb->fs_cblkno != sb->fs_cblkno ||
	    asb->fs_iblkno != sb->fs_iblkno ||
	    asb->fs_dblkno != sb->fs_dblkno ||
	    asb->fs_cgoffset != sb->fs_cgoffset ||
	    asb->fs_cgmask != sb->fs_cgmask ||
	    asb->fs_ncg != sb->fs_ncg ||
	    asb->fs_bsize != sb->fs_bsize ||
	    asb->fs_fsize != sb->fs_fsize ||
	    asb->fs_frag != sb->fs_frag ||
	    asb->fs_bmask != sb->fs_bmask ||
	    asb->fs_fmask != sb->fs_fmask ||
	    asb->fs_bshift != sb->fs_bshift ||
	    asb->fs_fshift != sb->fs_fshift ||
	    asb->fs_fragshift != sb->fs_fragshift ||
	    asb->fs_fsbtodb != sb->fs_fsbtodb ||
	    asb->fs_sbsize != sb->fs_sbsize ||
	    asb->fs_nindir != sb->fs_nindir ||
	    asb->fs_inopb != sb->fs_inopb ||
	    asb->fs_cssize != sb->fs_cssize ||
	    asb->fs_cpg != sb->fs_cpg ||
	    asb->fs_ipg != sb->fs_ipg ||
	    asb->fs_fpg != sb->fs_fpg ||
	    asb->fs_magic != sb->fs_magic)
		    return (1);
	/* they're the same */
	return (0);
}
@


1.62
log
@better computation of location of alternate superblocks, based on info
in the label; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.61 2016/08/20 15:04:21 tb Exp $	*/
d80 1
a80 1
setup(char *dev)
d105 1
a105 1
		if (!hotroot())
d148 4
a151 1
	if (!hotroot()) {
d153 2
a154 7
		if (strcmp("fsdb", getprogname()) == 0) {
			if (pledge("stdio rpath getpw tty", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio getpw", NULL) == -1)
				err(1, "pledge");
		}
@


1.61
log
@fsdb(8) sucks in and is pledged by fsck(8).  Since it uses editline(3),
add a special case for the missing "rpath" and "tty" promises.
Issue found and initial analysis by Jan Stary, thanks!

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.60 2015/11/24 21:42:54 deraadt Exp $	*/
d64 1
a64 1
int calcsb(char *, int, struct fs *, struct disklabel *);
d167 2
a168 1
		if (bflag || preen || calcsb(realdev, fsreadfd, &proto, lp) == 0)
d182 12
a193 2
			if (readsb(0) != 0)
				break;
d610 2
a611 1
calcsb(char *dev, int devfd, struct fs *fs, struct disklabel *lp)
d639 1
a640 1
	fs->fs_cpg = pp->p_cpg;
d642 2
d649 1
a649 3
	fs->fs_ntrak = lp->d_ntracks;
	fs->fs_nsect = DL_SECTOBLK(lp, lp->d_nsectors);
	fs->fs_spc = DL_SECTOBLK(lp, lp->d_secpercyl);
d652 1
a652 1
		howmany(lp->d_bbsize + SBSIZE, fs->fs_fsize),
d654 1
a654 22
again:
	fs->fs_cgmask = 0xffffffff;
	for (i = fs->fs_ntrak; i > 1; i >>= 1)
		fs->fs_cgmask <<= 1;
	if (!POWEROF2(fs->fs_ntrak))
		fs->fs_cgmask <<= 1;
	fs->fs_cgoffset = roundup(
		howmany(fs->fs_nsect, NSPF(fs)), fs->fs_frag);
	fs->fs_fpg = (fs->fs_cpg * fs->fs_spc) / NSPF(fs);
	fs->fs_ncg = howmany(DL_GETPSIZE(pp) / fs->fs_spc, fs->fs_cpg);
	for (fs->fs_fsbtodb = 0, i = NSPF(fs); i > 1; i >>= 1)
		fs->fs_fsbtodb++;
	/*
	 * Mimic what mkfs is doing to get an acceptable cgsize,
	 * not all fields used by CGSIZE() are filled in, but it's a best
	 * effort anyway.
	 */
	if (CGSIZE(fs) > fs->fs_bsize && fs->fs_ntrak > 1) {
		fs->fs_ntrak >>= 1;
		fs->fs_spc >>= 1;
		goto again;
	}
@


1.60
log
@hotroot is calculated late in fsck_ffs, so defer the pledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.59 2015/10/15 15:11:10 semarie Exp $	*/
d106 2
a107 1
			if (pledge("stdio rpath wpath getpw disklabel", NULL) == -1)
d150 7
a156 2
		if (pledge("stdio getpw", NULL) == -1)
			err(1, "pledge");
@


1.59
log
@corrects pledge code for fsck_ffs and fsck_ext2fs

on filesystem error, fsck will try to display username of inode, resulting need
of "getpw" for not SMALL version.

add a missed (?) -DSMALL in distrib/special/ for fsck_ffs and fsck_ext2fs

found by hard way by ajacoutot@@

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.58 2015/10/14 16:58:55 deraadt Exp $	*/
d104 4
@


1.58
log
@Since the fsck_* programs now only handle one filesystem, this creates
a point where open() and disklabel reading have completed.  After that
point, pledge "stdio".

As a result, an fsck of a hostile partition (noone ever does that, or
do they? :) is done by a program with SUBSTANTIALLY less system call
exposure.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.57 2015/01/20 18:22:21 deraadt Exp $	*/
d144 4
d150 1
@


1.57
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.56 2015/01/16 06:39:57 deraadt Exp $	*/
d47 1
a49 1
#include <unistd.h>
d52 1
d64 1
a64 1
int calcsb(char *, int, struct fs *);
d142 6
d152 1
a152 1
		if (bflag || preen || calcsb(realdev, fsreadfd, &proto) == 0)
a434 1

d584 1
a584 1
calcsb(char *dev, int devfd, struct fs *fs)
a585 1
	struct disklabel *lp;
d597 2
a598 1
	lp = getdisklabel(dev, devfd);
@


1.56
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.55 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE roundup */
@


1.55
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.54 2014/05/29 12:02:50 krw Exp $	*/
d33 1
a34 1
#include <sys/param.h>
d50 1
d57 2
d67 1
a67 1
static char rdevname[MAXPATHLEN];
d401 1
a401 1
	numdirs = MAX(sblock.fs_cstotal.cs_ndir, 128);
@


1.54
log
@fsck should use the same values in checking as newfs does in creating
a filesystem. fs_nspf and its derivitives like fs_spc are DEV_BSIZE
values, not actual hardware disk sector values. Adjust initializations
accordingly.

Tweak header and man page comments to make the DEV_BSIZE'ness more
obvious for future spelunkers.

No-op for DEV_BSIZE (a.k.a. 512-byte) sector devices but should help
checking filesystems on, e.g., 4k-byte sector devices.

ok jmc@@ on the man page tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.53 2014/05/09 13:56:33 krw Exp $	*/
d78 2
a79 1
	long cg, size, asked, i, j, bmapsize;
d386 1
a386 1
	blockmap = calloc((unsigned)bmapsize, sizeof(char));
d388 1
a388 2
		printf("cannot alloc %u bytes for blockmap\n",
		    (unsigned)bmapsize);
d394 2
a395 2
		printf("cannot alloc %u bytes for inostathead\n",
		    (unsigned)(sizeof(struct inostatlist) * (sblock.fs_ncg)));
@


1.53
log
@Modernize spelling. 'Mimick' -> 'Mimic' in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.52 2014/05/09 13:19:34 krw Exp $	*/
d605 6
a610 3
	fs->fs_nspf = fs->fs_fsize / lp->d_secsize;
	/* unit for fs->fs_size is fragments, for DL_GETPSIZE() it is sectors */
	fs->fs_size = DL_GETPSIZE(pp) / fs->fs_nspf;
d612 2
a613 2
	fs->fs_nsect = lp->d_nsectors;
	fs->fs_spc = lp->d_secpercyl;
@


1.52
log
@Fix '-b' option to work with the superblock locations output by newfs
on 4096-byte sector disks. No-op on 512-byte sector disks.

Adhering to the bedrock idea that ffs will *never* use anything but
512-byte block disk addressing (a.k.a. daddr_t), and believing that
the 'fake' bread()/bwrite() functions should always be using 512-btye
block numbers like their kernel big brothers, nuke the computed
dev_bsize and use DEV_BSIZE for conversions to/from byte offsets.

Spotted and various fixes tested by David Vasek.

Still to fix: scanning for superblocks on 4K disks.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.51 2013/11/22 04:38:02 guenther Exp $	*/
d628 1
a628 1
	 * Mimick what mkfs is doing to get an acceptable cgsize,
@


1.51
log
@Kirk was being waaaay too chummy with the compiler when he trusted
it to not optimize away a comparison against NULL-1.
Add (unsigned char) casts for some ctype calls.
Teach fsck_ext2fs about MAXPARTITIONS, letting it operate on
partitions 'i' through 'p'.

ok deraadt@@ millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.50 2013/11/05 00:51:58 krw Exp $	*/
d134 1
a134 1
		dev_bsize = secsize = lp->d_secsize;
d136 1
a136 1
		dev_bsize = secsize = DEV_BSIZE;
d448 1
a448 1
			super = sbtry[i] / dev_bsize;
a517 9

	/*
	 * Compute block size that the filesystem is based on,
	 * according to fsbtodb, and adjust superblock block number
	 * so we can tell if this is an alternate later.
	 */
	super *= dev_bsize;
	dev_bsize = sblock.fs_fsize / fsbtodb(&sblock, 1);
	sblk.b_bno = super / dev_bsize;
a636 1
	dev_bsize = lp->d_secsize;
@


1.50
log
@Replace direct references to p_size, p_offset and d_secperunit with
DL_[GET|SET]PSIZE(), DL_[GET|SET]POFFSET(), DL_[GET|SET]DSIZE() in
order to get|set correct value that includes the high bits of the
value.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.49 2013/06/11 16:42:04 deraadt Exp $	*/
d591 3
a593 3
	cp = strchr(dev, '\0') - 1;
	if ((cp == (char *)-1 || (*cp < 'a' || *cp >= 'a' + MAXPARTITIONS)) &&
	    !isdigit(*cp)) {
d597 1
d599 1
a599 1
	if (isdigit(*cp))
@


1.49
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.48 2011/04/24 07:07:03 otto Exp $	*/
d614 2
a615 2
	/* unit for fs->fs_size is fragments, for pp->p_size it is sectors */
	fs->fs_size = pp->p_size / fs->fs_nspf;
d632 1
a632 1
	fs->fs_ncg = howmany(pp->p_size / fs->fs_spc, fs->fs_cpg);
@


1.48
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.47 2011/04/16 16:37:21 otto Exp $	*/
d432 1
a432 1
	daddr64_t super = 0;
@


1.47
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.46 2010/08/12 15:26:34 jsing Exp $	*/
d263 15
a277 46
	if (sblock.fs_inodefmt >= FS_44INODEFMT) {
		if (sblock.fs_maxfilesize != maxfilesize) {
			pwarn("INCORRECT MAXFILESIZE=%llu IN SUPERBLOCK",
			    (unsigned long long)sblock.fs_maxfilesize);
			sblock.fs_maxfilesize = maxfilesize;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		maxsymlinklen = sblock.fs_magic == FS_UFS1_MAGIC ?
		    MAXSYMLINKLEN_UFS1 : MAXSYMLINKLEN_UFS2;
		if (sblock.fs_maxsymlinklen != maxsymlinklen) {
			pwarn("INCORRECT MAXSYMLINKLEN=%d IN SUPERBLOCK",
			    sblock.fs_maxsymlinklen);
			sblock.fs_maxsymlinklen = maxsymlinklen;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		if (sblock.fs_qbmask != ~sblock.fs_bmask) {
			pwarn("INCORRECT QBMASK=%lx IN SUPERBLOCK",
			    (unsigned long)sblock.fs_qbmask);
			sblock.fs_qbmask = ~sblock.fs_bmask;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		if (sblock.fs_qfmask != ~sblock.fs_fmask) {
			pwarn("INCORRECT QFMASK=%lx IN SUPERBLOCK",
			    (unsigned long)sblock.fs_qfmask);
			sblock.fs_qfmask = ~sblock.fs_fmask;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
a278 5
		newinofmt = 1;
	} else {
		sblock.fs_qbmask = ~sblock.fs_bmask;
		sblock.fs_qfmask = ~sblock.fs_fmask;
		newinofmt = 0;
d280 6
a285 4
	/*
	 * Convert to new inode format.
	 */
	if (cvtlevel >= 2 && sblock.fs_inodefmt < FS_44INODEFMT) {
d287 9
a295 7
			pwarn("CONVERTING TO NEW INODE FORMAT\n");
		else if (!reply("CONVERT TO NEW INODE FORMAT"))
			return(0);
		doinglevel2++;
		sblock.fs_inodefmt = FS_44INODEFMT;
		sblock.fs_maxfilesize = maxfilesize;
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
d297 10
a307 7
		sbdirty();
		dirty(&asblk);
	}
	/*
	 * Convert to new cylinder group format.
	 */
	if (cvtlevel >= 1 && sblock.fs_postblformat == FS_42POSTBLFMT) {
d309 5
a313 15
			pwarn("CONVERTING TO NEW CYLINDER GROUP FORMAT\n");
		else if (!reply("CONVERT TO NEW CYLINDER GROUP FORMAT"))
			return(0);
		doinglevel1++;
		sblock.fs_postblformat = FS_DYNAMICPOSTBLFMT;
		sblock.fs_nrpos = 8;
		sblock.fs_postbloff =
		    (char *)(&sblock.fs_maxbsize) -
		    (char *)(&sblock.fs_firstfield);
		sblock.fs_rotbloff = &sblock.fs_space[0] -
		    (u_char *)(&sblock.fs_firstfield);
		sblock.fs_cgsize =
			fragroundup(&sblock, CGSIZE(&sblock));
		sbdirty();
		dirty(&asblk);
@


1.46
log
@Print the real device name followed by the disklabel UID in parenthesis
when fsck is run against a disklabel UID. This allows a user to determine
which device is really being scanned.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.45 2010/06/15 14:25:09 jsing Exp $	*/
d430 5
a434 16
	stmap = calloc((unsigned)(maxino + 1), sizeof(char));
	if (stmap == NULL) {
		printf("cannot alloc %u bytes for stmap\n",
		    (unsigned)(maxino + 1));
		goto badsblabel;
	}
	lncntp = calloc((unsigned)(maxino + 1), sizeof(int16_t));
	if (lncntp == NULL) {
		printf("cannot alloc %zu bytes for lncntp\n",
		    (maxino + 1) * sizeof(int16_t));
		goto badsblabel;
	}
	cginosused = calloc((unsigned)sblock.fs_ncg, sizeof(long));
	if (cginosused == NULL) {
		printf("cannot alloc %u bytes for cginosused\n",
		    (unsigned)sblock.fs_ncg);
@


1.45
log
@When fsck_ffs is used with disklabel UIDs the hot root test fails in
blockcheck() since we try to stat() the UID. This means that we fail to
reload the mount if we have indeed cleaned the read-only root file system.
To avoid this, rerun blockcheck() if the real name is different to the
original device name, once we have opened the device with opendev(3).

ok krw@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.43 2010/06/05 07:36:23 jsing Exp $	*/
d64 1
d95 5
d112 1
a112 3
	if (strncmp(dev, realdev, PATH_MAX) != 0)
		blockcheck(unrawname(realdev));
	if (preen == 0)
d114 3
@


1.44
log
@add missing headers needed for opendev() and close()

ok jsing@@ krw@@
@
text
@d106 2
@


1.43
log
@Switch fsck_ffs(8) and fsdb(8) to opendev(3) so that they will soon be able
to operate with disklabel UIDs.

ok marco@@ krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.41 2009/10/27 23:59:32 deraadt Exp $	*/
d48 2
@


1.42
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d83 1
d88 7
a94 2
	if (stat(dev, &statb) < 0) {
		printf("Can't stat %s: %s\n", dev, strerror(errno));
d98 3
a100 2
		pfatal("%s is not a character device", dev);
		if (reply("CONTINUE") == 0)
d102 1
a102 4
	}
	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
		printf("Can't open %s: %s\n", dev, strerror(errno));
		return (0);
d105 2
a106 2
		printf("** %s", dev);
	if (nflag || (fswritefd = open(dev, O_WRONLY)) < 0) {
d130 1
a130 1
		if (bflag || preen || calcsb(dev, fsreadfd, &proto) == 0)
@


1.41
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.40 2008/06/10 23:10:29 otto Exp $	*/
d40 1
@


1.40
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.39 2008/06/10 13:49:24 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)setup.c	8.5 (Berkeley) 11/23/94";
#else
static const char rcsid[] = "$OpenBSD: setup.c,v 1.39 2008/06/10 13:49:24 otto Exp $";
#endif
#endif /* not lint */
@


1.39
log
@print sizeofs using %zu; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.38 2008/06/09 21:56:06 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.38 2008/06/09 21:56:06 otto Exp $";
d422 3
a424 9
	statemap = calloc((unsigned)(maxino + 1), sizeof(char));
	if (statemap == NULL) {
		printf("cannot alloc %u bytes for statemap\n",
		    (unsigned)(maxino + 1));
		goto badsblabel;
	}
	typemap = calloc((unsigned)(maxino + 1), sizeof(char));
	if (typemap == NULL) {
		printf("cannot alloc %u bytes for typemap\n",
d446 1
a446 1
		    (unsigned)numdirs * sizeof(struct inoinfo *));
@


1.38
log
@The new newfs(8) code causes alternate superblocks to end up in
different locations than before.  Actually, the disklabel does not
contain enough info to completely reconstruct the locations of all
alternate sb's.  So use a hardcoded list of all possible 1st alternate
sb locations, but don't forget to verify against the label.
ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.37 2007/06/01 23:42:35 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.37 2007/06/01 23:42:35 pedro Exp $";
d436 2
a437 2
		printf("cannot alloc %lu bytes for lncntp\n",
		    (unsigned long)(maxino + 1) * sizeof(int16_t));
d450 5
d456 3
a458 3
	if (inpsort == NULL || inphead == NULL) {
		printf("cannot alloc %lu bytes for inphead\n",
		    (unsigned long)numdirs * sizeof(struct inoinfo *));
@


1.37
log
@ufs1_daddr_t cleanup, okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.36 2007/06/01 06:41:33 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.36 2007/06/01 06:41:33 deraadt Exp $";
d76 2
d137 8
d160 1
d591 1
a591 1
		    "VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE");
@


1.36
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.35 2007/05/29 06:28:15 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.35 2007/05/29 06:28:15 otto Exp $";
d360 1
a360 1
		nindir = sblock.fs_bsize / sizeof(daddr64_t);
d362 1
a362 1
		nindir = sblock.fs_bsize / sizeof(ufs1_daddr_t);
@


1.35
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.34 2007/04/18 20:49:46 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.34 2007/04/18 20:49:46 otto Exp $";
d360 1
a360 1
		nindir = sblock.fs_bsize / sizeof(ufs2_daddr_t);
d464 1
a464 1
	ufs2_daddr_t super = 0;
@


1.34
log
@When trying to read the primary superblock, do not accidentially read
a ffs1 alternate sb at the primary ffs2 sb location. Use the same test
as the kernel does. ok millert@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.33 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.33 2007/04/10 16:08:17 millert Exp $";
d641 2
a642 2
	fs->fs_fsize = pp->p_fsize;
	fs->fs_frag = pp->p_frag;
@


1.33
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.32 2007/03/19 22:13:36 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.32 2007/03/19 22:13:36 otto Exp $";
d489 9
@


1.32
log
@be a tiny little bit more verbose when encoutering bad block or fragment
sizes; requested by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.31 2007/03/19 13:27:47 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.31 2007/03/19 13:27:47 pedro Exp $";
d72 5
d86 1
d164 1
a164 1
	maxfsblock = sblock.fs_ffs1_size;
a189 12
	if (sblock.fs_interleave < 1 ||
	    sblock.fs_interleave > sblock.fs_nsect) {
		pwarn("IMPOSSIBLE INTERLEAVE=%d IN SUPERBLOCK",
		    sblock.fs_interleave);
		sblock.fs_interleave = 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("SET TO DEFAULT") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
d256 3
a258 1
		if (sblock.fs_maxsymlinklen != MAXSYMLINKLEN_UFS1) {
d261 1
a261 1
			sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
d345 5
a349 1
	if (INOPB(&sblock) != sblock.fs_bsize / sizeof(struct ufs1_dinode)) {
d351 1
a351 1
		sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
d359 5
a363 1
	if (NINDIR(&sblock) != sblock.fs_bsize / sizeof(ufs1_daddr_t)) {
d365 1
a365 1
		sblock.fs_nindir = sblock.fs_bsize / sizeof(daddr_t);
d391 1
a391 1
		    fsbtodb(&sblock, sblock.fs_ffs1_csaddr + j * sblock.fs_frag),
d429 7
a435 1
	numdirs = sblock.fs_ffs1_cstotal.cs_ndir;
d446 1
a446 1
	if (sblock.fs_ffs1_flags & FS_DOSOFTDEP)
d457 1
d464 38
a501 1
	daddr_t super = bflag ? bflag : SBOFF / dev_bsize;
a502 2
	if (bread(fsreadfd, (char *)&sblock, super, (long)SBSIZE) != 0)
		return (0);
d505 1
a508 4
	if (sblock.fs_magic != FS_MAGIC) {
		badsb(listerr, "MAGIC NUMBER WRONG");
		return (0);
	}
d517 6
a522 4
	if (sblock.fs_ncg * sblock.fs_cpg < sblock.fs_ncyl ||
	    (sblock.fs_ncg - 1) * sblock.fs_cpg >= sblock.fs_ncyl) {
		badsb(listerr, "NCYL LESS THAN NCG*CPG");
		return (0);
d550 2
a551 4
	if (bflag) {
		havesb = 1;
		return (1);
	}
d574 11
d638 1
a638 1
	fs->fs_ffs1_size = pp->p_size / fs->fs_nspf;
@


1.31
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.30 2007/03/18 21:44:01 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.30 2007/03/18 21:44:01 otto Exp $";
d486 1
a486 1
		badsb(listerr, "ILLEGAL BLOCK SIZE");
d492 1
a492 1
		badsb(listerr, "ILLEGAL FRAGMENT SIZE");
@


1.30
log
@there's no way we're going to be able to handle illegal block or
fragment sizes, so just make those conditions fatal errors and tell
the calling code to go look for alternate superblocks. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.29 2007/02/16 08:34:29 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.29 2007/02/16 08:34:29 otto Exp $";
d158 1
a158 1
	maxfsblock = sblock.fs_size;
d330 1
a330 1
		    (char *)(&sblock.fs_opostbl_start) -
d387 1
a387 1
		    fsbtodb(&sblock, sblock.fs_csaddr + j * sblock.fs_frag),
d425 1
a425 1
	numdirs = sblock.fs_cstotal.cs_ndir;
d436 1
a436 1
	if (sblock.fs_flags & FS_DOSOFTDEP)
d584 1
a584 1
	fs->fs_size = pp->p_size / fs->fs_nspf;
@


1.29
log
@Fix a row of bugs in the code that computes the alternate superblock
locations based on the disklabel.

- unit bug: disklabel size is in sectors, but superblock
fs size is in fragments.
- The disklabel contains the maximum superblock size, not the actual
as used by newfs.
- problem is that mkfs reduces track/sector and secors/track to
make the cylindergroup fit in a fs block. In this case the values
in the disklabel do not predict what's in the superblock.

This fixes all these problems. It correctly predicts the location
of all superblocks on all my filesystems I have online (sized between
100MB and 1000GB).  Also tested with filesystems with different
block and fragment sizes.

Written this with a goto to make the diff easier to read.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.28 2007/02/13 15:56:22 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.28 2007/02/13 15:56:22 otto Exp $";
d485 1
a485 1
	    sblock.fs_bsize > MAXBSIZE)
d487 2
d491 1
a491 1
	    sblock.fs_fsize < sblock.fs_bsize / MAXFRAG)
d493 2
@


1.28
log
@Do some extra validation of the superblock, otherwise a corrupt
superblock might lead to crashes or other mishap. Now my fuzzed fs
images no longer crash fsck_ffs.  ok mickey@@ pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.27 2007/02/12 16:32:54 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.27 2007/02/12 16:32:54 otto Exp $";
d576 1
d578 3
a580 1
	fs->fs_size = pp->p_size;
d584 1
a584 1
	fs->fs_nspf = fs->fs_fsize / lp->d_secsize;
d586 1
a586 1
		howmany(lp->d_bbsize + lp->d_sbsize, fs->fs_fsize),
d588 1
d597 1
a597 1
	fs->fs_ncg = howmany(fs->fs_size / fs->fs_spc, fs->fs_cpg);
d600 10
@


1.27
log
@max partition letter is 'a' + MAXPARTITIONS - 1, not 'h'. ok (and
help) miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.26 2007/02/09 19:52:32 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.26 2007/02/09 19:52:32 otto Exp $";
d230 20
d339 30
d480 1
a480 1
		badsb(listerr, "SIZE PREPOSTEROUSLY LARGE");
d483 9
@


1.26
log
@fix a fd leak that happens whe checking multiple file systems and some
of them are clean. ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.25 2007/02/08 19:02:23 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.25 2007/02/08 19:02:23 otto Exp $";
d498 2
a499 1
	if ((cp == (char *)-1 || (*cp < 'a' || *cp > 'h')) && !isdigit(*cp)) {
@


1.25
log
@Plug some mem leaks that occur when checking multiple file systems in a
row. ok beck@@ pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.24 2006/04/17 19:18:08 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.24 2006/04/17 19:18:08 deraadt Exp $";
d84 1
a84 1
	fswritefd = -1;
@


1.24
log
@prettier code; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.23 2006/03/09 13:35:02 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.23 2006/03/09 13:35:02 pedro Exp $";
a60 1
struct bufarea asblk;
@


1.23
log
@Remove option -n from newfs as well as all references to fs_postbl()
Various testing for a while, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.22 2005/12/19 15:18:01 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.22 2005/12/19 15:18:01 pedro Exp $";
d76 1
a76 2
	long cg, size, asked, i, j;
	long bmapsize;
d137 6
a142 6
				"SEARCH FOR ALTERNATE SUPER-BLOCK",
				"FAILED. YOU MUST USE THE",
				"-b OPTION TO FSCK_FFS TO SPECIFY THE",
				"LOCATION OF AN ALTERNATE",
				"SUPER-BLOCK TO SUPPLY NEEDED",
				"INFORMATION; SEE fsck_ffs(8).");
d179 1
a179 1
			sblock.fs_minfree);
d188 1
a188 1
			sblock.fs_interleave);
d200 1
a200 1
			sblock.fs_npsect);
d211 1
a211 1
			sblock.fs_bmask);
d222 1
a222 1
			sblock.fs_fmask);
d234 1
a234 1
				(unsigned long long)sblock.fs_maxfilesize);
d245 1
a245 1
				sblock.fs_maxsymlinklen);
d256 1
a256 1
				(unsigned long)sblock.fs_qbmask);
d267 1
a267 1
				(unsigned long)sblock.fs_qfmask);
d413 12
a424 6
	if (sblock.fs_magic != FS_MAGIC)
		{ badsb(listerr, "MAGIC NUMBER WRONG"); return (0); }
	if (sblock.fs_ncg < 1)
		{ badsb(listerr, "NCG OUT OF RANGE"); return (0); }
	if (sblock.fs_cpg < 1)
		{ badsb(listerr, "CPG OUT OF RANGE"); return (0); }
d426 9
a434 4
	    (sblock.fs_ncg - 1) * sblock.fs_cpg >= sblock.fs_ncyl)
		{ badsb(listerr, "NCYL LESS THAN NCG*CPG"); return (0); }
	if (sblock.fs_sbsize > SBSIZE)
		{ badsb(listerr, "SIZE PREPOSTEROUSLY LARGE"); return (0); }
d466 1
a466 1
		"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE");
d510 2
a511 2
			dev, pp->p_fstype < FSMAXTYPES ?
			fstypenames[pp->p_fstype] : "unknown");
@


1.22
log
@Add and use a few more constants and macros needed by UFS2
No functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.21 2003/09/25 04:19:39 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.21 2003/09/25 04:19:39 deraadt Exp $";
d312 1
a312 1
		    (char *)(&sblock.fs_opostbl[0][0]) -
@


1.21
log
@whack commons as wanted by ho
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.20 2003/06/26 08:01:54 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.20 2003/06/26 08:01:54 tedu Exp $";
d244 1
a244 1
		if (sblock.fs_maxsymlinklen != MAXSYMLINKLEN) {
d247 1
a247 1
			sblock.fs_maxsymlinklen = MAXSYMLINKLEN;
d294 1
a294 1
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN;
@


1.20
log
@const the rcsid, and make it say OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.19 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.19 2003/06/02 20:06:15 millert Exp $";
d70 2
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.18 2003/04/30 22:54:32 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.18 2003/04/30 22:54:32 tedu Exp $";
@


1.18
log
@only compare suberblock fields that are interesting, instead of trying to
ignore the noninteresting ones.  will allow future changes to work
with an older fsck.  similar to changes in NetBSD and FreeBSD.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.17 2002/08/23 09:09:04 gluk Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.17 2002/08/23 09:09:04 gluk Exp $";
@


1.17
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.16 2002/06/09 08:13:05 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.16 2002/06/09 08:13:05 todd Exp $";
d73 1
a438 5
	/*
	 * Set all possible fields that could differ, then do check
	 * of whole super block against an alternate super block.
	 * When an alternate super-block is specified this check is skipped.
	 */
d442 1
a442 39
	altsblock.fs_firstfield = sblock.fs_firstfield;
	altsblock.fs_fscktime = sblock.fs_fscktime;
	altsblock.fs_time = sblock.fs_time;
	altsblock.fs_cstotal = sblock.fs_cstotal;
	altsblock.fs_cgrotor = sblock.fs_cgrotor;
	altsblock.fs_fmod = sblock.fs_fmod;
	altsblock.fs_clean = sblock.fs_clean;
	altsblock.fs_ronly = sblock.fs_ronly;
	altsblock.fs_flags = sblock.fs_flags;
	altsblock.fs_maxcontig = sblock.fs_maxcontig;
	altsblock.fs_minfree = sblock.fs_minfree;
	altsblock.fs_optim = sblock.fs_optim;
	altsblock.fs_rotdelay = sblock.fs_rotdelay;
	altsblock.fs_maxbpg = sblock.fs_maxbpg;
	memcpy(altsblock.fs_ocsp, sblock.fs_ocsp, sizeof sblock.fs_ocsp);
	altsblock.fs_contigdirs = sblock.fs_contigdirs;
	altsblock.fs_csp = sblock.fs_csp;
	altsblock.fs_maxcluster = sblock.fs_maxcluster;
	altsblock.fs_avgfilesize = sblock.fs_avgfilesize;
	altsblock.fs_avgfpdir = sblock.fs_avgfpdir;
	memcpy(altsblock.fs_fsmnt, sblock.fs_fsmnt,
		sizeof sblock.fs_fsmnt);
	memcpy(altsblock.fs_snapinum, sblock.fs_snapinum,
		sizeof sblock.fs_snapinum);
	memcpy(altsblock.fs_sparecon, sblock.fs_sparecon,
		sizeof sblock.fs_sparecon);
	/*
	 * The following should not have to be copied.
	 */
	altsblock.fs_fsbtodb = sblock.fs_fsbtodb;
	altsblock.fs_interleave = sblock.fs_interleave;
	altsblock.fs_npsect = sblock.fs_npsect;
	altsblock.fs_nrpos = sblock.fs_nrpos;
	altsblock.fs_state = sblock.fs_state;
	altsblock.fs_qbmask = sblock.fs_qbmask;
	altsblock.fs_qfmask = sblock.fs_qfmask;
	altsblock.fs_state = sblock.fs_state;
	altsblock.fs_maxfilesize = sblock.fs_maxfilesize;
	if (memcmp(&sblock, &altsblock, (int)sblock.fs_sbsize)) {
d545 39
@


1.16
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.15 2002/02/16 21:27:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.15 2002/02/16 21:27:34 millert Exp $";
d75 1
a75 2
setup(dev)
	char *dev;
d120 1
a120 1
	if ((lp = getdisklabel((char *)NULL, fsreadfd)) != NULL)
d354 1
a354 1
	blockmap = calloc((unsigned)bmapsize, sizeof (char));
d372 1
a372 1
	lncntp = (int16_t *)calloc((unsigned)(maxino + 1), sizeof(int16_t));
d381 2
a382 4
	inpsort = (struct inoinfo **)calloc((unsigned)listmax,
	    sizeof(struct inoinfo *));
	inphead = (struct inoinfo **)calloc((unsigned)numdirs,
	    sizeof(struct inoinfo *));
d404 1
a404 2
readsb(listerr)
	int listerr;
d508 1
a508 3
badsb(listerr, s)
	int listerr;
	char *s;
d525 1
a525 4
calcsb(dev, devfd, fs)
	char *dev;
	int devfd;
	struct fs *fs;
d576 1
a576 3
getdisklabel(s, fd)
	char *s;
	int	fd;
d582 1
a582 1
			return ((struct disklabel *)NULL);
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.14 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.14 2001/11/05 07:39:16 mpech Exp $";
d188 1
a188 1
	if (sblock.fs_interleave < 1 || 
d200 1
a200 1
	if (sblock.fs_npsect < sblock.fs_nsect || 
d375 1
a375 1
		printf("cannot alloc %lu bytes for lncntp\n", 
d387 1
a387 1
		printf("cannot alloc %lu bytes for inphead\n", 
@


1.14
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.13 2001/07/07 18:26:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.13 2001/07/07 18:26:12 deraadt Exp $";
d69 4
a72 4
void badsb __P((int, char *));
int calcsb __P((char *, int, struct fs *));
static struct disklabel *getdisklabel __P((char *, int));
static int readsb __P((int));
@


1.13
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.12 2001/05/15 09:01:02 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.12 2001/05/15 09:01:02 deraadt Exp $";
d534 1
a534 1
	register struct fs *fs;
d536 3
a538 3
	register struct disklabel *lp;
	register struct partition *pp;
	register char *cp;
@


1.12
log
@report on another calloc() failure
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.11 2001/04/19 16:22:17 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.11 2001/04/19 16:22:17 gluk Exp $";
d236 2
a237 2
			pwarn("INCORRECT MAXFILESIZE=%qd IN SUPERBLOCK",
				sblock.fs_maxfilesize);
d258 2
a259 2
			pwarn("INCORRECT QBMASK=%qx IN SUPERBLOCK",
				sblock.fs_qbmask);
d269 2
a270 2
			pwarn("INCORRECT QFMASK=%qx IN SUPERBLOCK",
				sblock.fs_qfmask);
d375 2
a376 2
		printf("cannot alloc %u bytes for lncntp\n", 
		    (unsigned)(maxino + 1) * sizeof(int16_t));
d387 2
a388 2
		printf("cannot alloc %u bytes for inphead\n", 
		    (unsigned)numdirs * sizeof(struct inoinfo *));
d500 1
a500 1
				    olp - (long *)&sblock, *olp, *nlp);
@


1.11
log
@Cleanup dirpref and synhronize superblock with freebsd.
From FreeBSD with little changes.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.10 2001/04/13 02:39:05 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.10 2001/04/13 02:39:05 gluk Exp $";
d332 5
@


1.10
log
@Fix overflow in superblock. From FreeBSD.

FreeBSD's log:
> The ffs superblock includes a 128-byte region for use by temporary
> in-core pointers to summary information. An array in this region
> (fs_csp) could overflow on filesystems with a very large number of
> cylinder groups (~16000 on i386 with 8k blocks). When this happens,
> other fields in the superblock get corrupted, and fsck refuses to
> check the filesystem.
>
> Solve this problem by replacing the fs_csp array in 'struct fs'
> with a single pointer, and add padding to keep the length of the
> 128-byte region fixed. Update the kernel and userland utilities
> to use just this single pointer.
>
> With this change, the kernel no longer makes use of the superblock
> fields 'fs_csshift' and 'fs_csmask'. Add a comment to newfs/mkfs.c
> to indicate that these fields must be calculated for compatibility
> with older kernels.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.9 2001/04/06 20:43:31 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.9 2001/04/06 20:43:31 gluk Exp $";
d460 1
a462 1
	altsblock.fs_contigdirs = sblock.fs_contigdirs;
d467 2
@


1.9
log
@Replace FFS directory preference algorithm(dirpref) by new one.
It allocates directory inode in the same cylinder group as a parent
directory in. This speedup file/directory intensive operations on
a big file systems in times.

Don't forget to recompile fsck_ffs with updated fs.h or you will get
"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE" at
the next boot. In any case you can ignore this error safely.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d331 1
d335 1
a335 2
		sblock.fs_csp[j] = (struct csum *)calloc(1, (unsigned)size);
		if (bread(fsreadfd, (char *)sblock.fs_csp[j],
d459 2
a460 2
	memcpy(altsblock.fs_csp, sblock.fs_csp,
		sizeof sblock.fs_csp);
@


1.8
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.7 1999/08/17 09:13:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.7 1999/08/17 09:13:14 millert Exp $";
d462 3
@


1.7
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.6 1997/10/06 20:22:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.6 1997/10/06 20:22:36 deraadt Exp $";
d339 2
a340 1
			if (reply("CONTINUE") == 0)
d342 1
d387 4
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.4 1996/10/20 08:36:41 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.4 1996/10/20 08:36:41 tholo Exp $";
a52 1
#include <sys/file.h>
d55 1
@


1.5
log
@VFS Lite2 Changes
@
text
@d339 1
a339 2
			if (reply("CONTINUE") == 0) {
				ckfini(0);
a340 1
			}
a384 4
	if (sblock.fs_flags & FS_DOSOFTDEP)
		usedsoftdep = 1;
	else
		usedsoftdep = 0;
@


1.4
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.3 1996/06/23 14:30:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.3 1996/06/23 14:30:34 deraadt Exp $";
d339 2
a340 1
			if (reply("CONTINUE") == 0)
d342 1
d387 4
@


1.3
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: setup.c,v 1.25 1996/05/21 17:36:21 mycroft Exp $	*/
/*	$NetBSD: setup.c,v 1.25 1996/05/21 17:36:21 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.25 1996/05/21 17:36:21 mycroft Exp $";
d60 1
d63 1
d71 2
a72 2
struct disklabel *getdisklabel();
int readsb __P((int));
d121 1
a121 1
	if (lp = getdisklabel((char *)NULL, fsreadfd))
d340 1
a340 1
				errexit("");
d395 1
a395 1
int
d483 1
a483 1
				printf("offset %d, original %d, alternate %d\n",
d504 1
a504 1
		printf("%s: ", cdevname);
d526 1
a526 1
	if (cp == (char *)-1 || (*cp < 'a' || *cp > 'h') && !isdigit(*cp)) {
d568 1
a568 1
struct disklabel *
@


1.2
log
@be more careful
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: setup.c,v 1.25 1996/05/21 17:36:21 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: setup.c,v 1.22 1995/07/12 01:49:23 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: setup.c,v 1.22 1995/07/12 01:49:23 cgd Exp $";
d82 1
d139 1
a139 1
				"-b OPTION TO FSCK TO SPECIFY THE",
d142 1
a142 1
				"INFORMATION; SEE fsck(8).");
d161 6
d209 22
d232 44
d292 1
a292 6
		sizepb = sblock.fs_bsize;
		sblock.fs_maxfilesize = sblock.fs_bsize * NDADDR - 1;
		for (i = 0; i < NIADDR; i++) {
			sizepb *= NINDIR(&sblock);
			sblock.fs_maxfilesize += sizepb;
		}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
