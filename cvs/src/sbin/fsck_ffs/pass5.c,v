head	1.48;
access;
symbols
	OPENBSD_6_0:1.48.0.8
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.4
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.43.0.6
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.41.0.8
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.6
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.4
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.8
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.4
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	F55lwc3gS4GN2mLs;

1.47
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Uu5nFG3wCl0LACBb;

1.46
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.45;
commitid	qlzrzgnJ4ZiiF6XQ;

1.45
date	2014.07.08.17.19.24;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	EF98ch02VpFassUi;

1.44
date	2014.05.21.18.53.05;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.09.06.41.17;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.17.18.54.40;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.04.20.43.44;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.01.14.26.08;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.18.19.21.34;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.11.08.28.52;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.05.22.17.34;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.23.10.18.30;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.21.19.25.52;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.15.10.27.00;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.27.02.40.03;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.22.20.24.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.12.02.28.28;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.25.06.25.46;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.16.14.51.37;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.16.18.15.41;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.16.17.37.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.11.01.43.45;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.01.19.04.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.07.18.26.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.09.07.26.09;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.02.18.35.20;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.02.14.45.30;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.03.01.07.45.18;	author d;	state Exp;
branches;
next	1.6;

1.6
date	97.11.09.19.53.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.22.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.33.35;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.10.20.08.36.40;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@/*	$OpenBSD: pass5.c,v 1.47 2015/01/16 06:39:57 deraadt Exp $	*/
/*	$NetBSD: pass5.c,v 1.16 1996/09/27 22:45:18 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE roundup setbit */
#include <sys/time.h>
#include <sys/lock.h>
#include <sys/ucred.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ffs/ffs_extern.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>

#include "fsutil.h"
#include "fsck.h"
#include "extern.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static int info_cg;
static int info_maxcg;

static int
pass5_info(char *buf, size_t buflen)
{
	return (snprintf(buf, buflen, "phase 5, cg %d/%d",
	    info_cg, info_maxcg) > 0);
}

void
pass5(void)
{
	int c, blk, frags, basesize, sumsize, mapsize, savednrpos=0;
	int inomapsize, blkmapsize;
	struct fs *fs = &sblock;
	struct cg *cg = &cgrp;
	daddr_t dbase, dmax;
	daddr_t d;
	long i, j, k, rewritecg = 0;
	struct csum *cs;
	struct csum_total cstotal;
	struct inodesc idesc[3];
	char buf[MAXBSIZE];
	struct cg *newcg = (struct cg *)buf;
	struct ocg *ocg = (struct ocg *)buf;

	memset(newcg, 0, (size_t)fs->fs_cgsize);
	if (cvtlevel >= 3) {
		if (fs->fs_maxcontig < 2 && fs->fs_contigsumsize > 0) {
			if (preen)
				pwarn("DELETING CLUSTERING MAPS\n");
			if (preen || reply("DELETE CLUSTERING MAPS")) {
				fs->fs_contigsumsize = 0;
				rewritecg = 1;
				sbdirty();
			}
		}
		if (fs->fs_maxcontig > 1) {
			char *doit = 0;

			if (fs->fs_contigsumsize < 1) {
				doit = "CREAT";
			} else if (fs->fs_contigsumsize < fs->fs_maxcontig &&
				   fs->fs_contigsumsize < FS_MAXCONTIG) {
				doit = "EXPAND";
			}
			if (doit) {
				i = fs->fs_contigsumsize;
				fs->fs_contigsumsize =
				    MINIMUM(fs->fs_maxcontig, FS_MAXCONTIG);
				if (CGSIZE(fs) > fs->fs_bsize) {
					pwarn("CANNOT %s CLUSTER MAPS\n", doit);
					fs->fs_contigsumsize = i;
				} else if (preen ||
				    reply("CREATE CLUSTER MAPS")) {
					if (preen)
						pwarn("%sING CLUSTER MAPS\n",
						    doit);
					fs->fs_cgsize =
					    fragroundup(fs, CGSIZE(fs));
					rewritecg = 1;
					sbdirty();
				}
			}
		}
	}
	switch ((int)fs->fs_postblformat) {

	case FS_42POSTBLFMT:
		basesize = (char *)(&ocg->cg_btot[0]) -
		    (char *)(&ocg->cg_firstfield);
		sumsize = &ocg->cg_iused[0] - (u_int8_t *)(&ocg->cg_btot[0]);
		mapsize = &ocg->cg_free[howmany(fs->fs_fpg, NBBY)] -
			(u_char *)&ocg->cg_iused[0];
		blkmapsize = howmany(fs->fs_fpg, NBBY);
		inomapsize = sizeof(ocg->cg_iused);
		ocg->cg_magic = CG_MAGIC;
		savednrpos = fs->fs_nrpos;
		fs->fs_nrpos = 8;
		break;

	case FS_DYNAMICPOSTBLFMT:
		if (sblock.fs_magic == FS_UFS2_MAGIC) {
			newcg->cg_iusedoff = sizeof(struct cg);
		} else {
			newcg->cg_btotoff = sizeof(struct cg);
			newcg->cg_boff = newcg->cg_btotoff +
			    fs->fs_cpg * sizeof(int32_t);
			newcg->cg_iusedoff = newcg->cg_boff + fs->fs_cpg *
			    fs->fs_nrpos * sizeof(int16_t);
		}
		inomapsize = howmany(fs->fs_ipg, CHAR_BIT);
		newcg->cg_freeoff = newcg->cg_iusedoff + inomapsize;
		blkmapsize = howmany(fs->fs_fpg, CHAR_BIT);
		newcg->cg_nextfreeoff = newcg->cg_freeoff + blkmapsize;
		if (fs->fs_contigsumsize > 0) {
			newcg->cg_clustersumoff = newcg->cg_nextfreeoff -
			    sizeof(int32_t);
			newcg->cg_clustersumoff =
			    roundup(newcg->cg_clustersumoff, sizeof(int32_t));
			newcg->cg_clusteroff = newcg->cg_clustersumoff +
			    (fs->fs_contigsumsize + 1) * sizeof(int32_t);
			newcg->cg_nextfreeoff = newcg->cg_clusteroff +
			    howmany(fragstoblks(fs, fs->fs_fpg), CHAR_BIT);
		}
		newcg->cg_magic = CG_MAGIC;
		basesize = sizeof(struct cg);
		sumsize = newcg->cg_iusedoff - newcg->cg_btotoff;
		mapsize = newcg->cg_nextfreeoff - newcg->cg_iusedoff;
		break;

	default:
		inomapsize = blkmapsize = sumsize = 0;
		errexit("UNKNOWN ROTATIONAL TABLE FORMAT %d\n",
			fs->fs_postblformat);
	}
	memset(&idesc[0], 0, sizeof idesc);
	for (i = 0; i < 3; i++)
		idesc[i].id_type = ADDR;
	memset(&cstotal, 0, sizeof(struct csum_total));
	dmax = blknum(fs, fs->fs_size + fs->fs_frag - 1);
	for (d = fs->fs_size; d < dmax; d++)
		setbmap(d);
	info_cg = 0;
	info_maxcg = fs->fs_ncg;
	info_fn = pass5_info;
	for (c = 0; c < fs->fs_ncg; c++) {
		info_cg = c;
		getblk(&cgblk, cgtod(fs, c), fs->fs_cgsize);
		if (!cg_chkmagic(cg))
			pfatal("CG %d: BAD MAGIC NUMBER\n", c);
		dbase = cgbase(fs, c);
		dmax = dbase + fs->fs_fpg;
		if (dmax > fs->fs_size)
			dmax = fs->fs_size;
		newcg->cg_time = cg->cg_time;
		newcg->cg_ffs2_time = cg->cg_ffs2_time;
		newcg->cg_cgx = c;
		if (c == fs->fs_ncg - 1)
			newcg->cg_ncyl = fs->fs_ncyl % fs->fs_cpg;
		else
			newcg->cg_ncyl = fs->fs_cpg;
		newcg->cg_ndblk = dmax - dbase;
		if (fs->fs_contigsumsize > 0)
			newcg->cg_nclusterblks = newcg->cg_ndblk / fs->fs_frag;
		newcg->cg_cs.cs_ndir = 0;
		newcg->cg_cs.cs_nffree = 0;
		newcg->cg_cs.cs_nbfree = 0;
		newcg->cg_cs.cs_nifree = fs->fs_ipg;
		if (cg->cg_rotor < newcg->cg_ndblk)
			newcg->cg_rotor = cg->cg_rotor;
		else
			newcg->cg_rotor = 0;
		if (cg->cg_frotor >= 0 && cg->cg_frotor < newcg->cg_ndblk)
			newcg->cg_frotor = cg->cg_frotor;
		else
			newcg->cg_frotor = 0;
		newcg->cg_irotor = 0;
		if (fs->fs_magic == FS_UFS1_MAGIC) {
			newcg->cg_initediblk = 0;
			newcg->cg_niblk = cg->cg_niblk;
			if (cg->cg_irotor >= 0 &&
			    cg->cg_irotor < fs->fs_ipg)
				newcg->cg_irotor = cg->cg_irotor;
		} else {
			newcg->cg_ncyl = 0;
			if ((unsigned)cg->cg_initediblk > fs->fs_ipg)
				newcg->cg_initediblk = fs->fs_ipg;
			else
				newcg->cg_initediblk = cg->cg_initediblk;
			newcg->cg_ffs2_niblk = fs->fs_ipg;
			if (cg->cg_irotor >= 0 &&
			    cg->cg_irotor < newcg->cg_ffs2_niblk)
				newcg->cg_irotor = cg->cg_irotor;
		}
		memset(&newcg->cg_frsum[0], 0, sizeof newcg->cg_frsum);
		memset(cg_inosused(newcg), 0, (size_t)(mapsize));
		if (fs->fs_postblformat == FS_42POSTBLFMT)
			ocg->cg_magic = CG_MAGIC;
		j = fs->fs_ipg * c;
		for (i = 0; i < inostathead[c].il_numalloced; j++, i++) {
			switch (GET_ISTATE(j)) {

			case USTATE:
				break;

			case DSTATE:
			case DCLEAR:
			case DFOUND:
				newcg->cg_cs.cs_ndir++;
				/* FALLTHROUGH */

			case FSTATE:
			case FCLEAR:
				newcg->cg_cs.cs_nifree--;
				setbit(cg_inosused(newcg), i);
				break;

			default:
				if (j < ROOTINO)
					break;
				errexit("BAD STATE %d FOR INODE I=%llu\n",
				    GET_ISTATE(j), (unsigned long long)j);
			}
		}
		if (c == 0)
			for (i = 0; i < ROOTINO; i++) {
				setbit(cg_inosused(newcg), i);
				newcg->cg_cs.cs_nifree--;
			}
		for (i = 0, d = dbase;
		     d < dmax;
		     d += fs->fs_frag, i += fs->fs_frag) {
			frags = 0;
			for (j = 0; j < fs->fs_frag; j++) {
				if (testbmap(d + j))
					continue;
				setbit(cg_blksfree(newcg), i + j);
				frags++;
			}
			if (frags == fs->fs_frag) {
				newcg->cg_cs.cs_nbfree++;
				if (fs->fs_contigsumsize > 0)
					setbit(cg_clustersfree(newcg),
					    i / fs->fs_frag);
			} else if (frags > 0) {
				newcg->cg_cs.cs_nffree += frags;
				blk = blkmap(fs, cg_blksfree(newcg), i);
				ffs_fragacct(fs, blk, newcg->cg_frsum, 1);
			}
		}
		if (fs->fs_contigsumsize > 0) {
			int32_t *sump = cg_clustersum(newcg);
			u_char *mapp = cg_clustersfree(newcg);
			int map = *mapp++;
			int bit = 1;
			int run = 0;

			for (i = 0; i < newcg->cg_nclusterblks; i++) {
				if ((map & bit) != 0) {
					run++;
				} else if (run != 0) {
					if (run > fs->fs_contigsumsize)
						run = fs->fs_contigsumsize;
					sump[run]++;
					run = 0;
				}
				if ((i & (NBBY - 1)) != (NBBY - 1)) {
					bit <<= 1;
				} else {
					map = *mapp++;
					bit = 1;
				}
			}
			if (run != 0) {
				if (run > fs->fs_contigsumsize)
					run = fs->fs_contigsumsize;
				sump[run]++;
			}
		}
		cstotal.cs_nffree += newcg->cg_cs.cs_nffree;
		cstotal.cs_nbfree += newcg->cg_cs.cs_nbfree;
		cstotal.cs_nifree += newcg->cg_cs.cs_nifree;
		cstotal.cs_ndir += newcg->cg_cs.cs_ndir;
		cs = &fs->fs_cs(fs, c);
		if (memcmp(&newcg->cg_cs, cs, sizeof *cs) != 0 &&
		    dofix(&idesc[0], "FREE BLK COUNT(S) WRONG IN SUPERBLK")) {
			memcpy(cs, &newcg->cg_cs, sizeof *cs);
			sbdirty();
		}
		if (rewritecg) {
			memcpy(cg, newcg, (size_t)fs->fs_cgsize);
			cgdirty();
			continue;
		}
		if (memcmp(newcg, cg, basesize) &&
		    dofix(&idesc[2], "SUMMARY INFORMATION BAD")) {
			memcpy(cg, newcg, (size_t)basesize);
			cgdirty();
		}
		if (usedsoftdep) {
			for (i = 0; i < inomapsize; i++) {
				j = cg_inosused(newcg)[i];
				if ((cg_inosused(cg)[i] & j) == j)
					continue;
				for (k = 0; k < NBBY; k++) {
					if ((j & (1 << k)) == 0)
						continue;
					if (cg_inosused(cg)[i] & (1 << k))
						continue;
					pwarn("ALLOCATED INODE %lld MARKED FREE\n",
					      ((long long)c * fs->fs_ipg + i * 8) + k);
				}
			}
			for (i = 0; i < blkmapsize; i++) {
				j = cg_blksfree(cg)[i];
				if ((cg_blksfree(newcg)[i] & j) == j)
					continue;
				for (k = 0; k < NBBY; k++) {
					if ((j & (1 << k)) == 0)
						continue;
					if (cg_blksfree(newcg)[i] & (1 << k))
						continue;
					pwarn("ALLOCATED FRAG %lld MARKED FREE\n",
					      ((long long)c * fs->fs_fpg + i * 8) + k);
				}
			}
		}
		if (memcmp(cg_inosused(newcg), cg_inosused(cg),
			   mapsize) != 0 &&
		    dofix(&idesc[1], "BLK(S) MISSING IN BIT MAPS")) {
			memmove(cg_inosused(cg), cg_inosused(newcg),
				(size_t)mapsize);
			cgdirty();
		}
	}
	info_fn = NULL;
	if (fs->fs_postblformat == FS_42POSTBLFMT)
		fs->fs_nrpos = savednrpos;

	sumsize = sizeof(cstotal) - sizeof(cstotal.cs_spare);
	if (memcmp(&cstotal, &fs->fs_cstotal, sumsize) != 0
	    && dofix(&idesc[0], "FREE BLK COUNT(S) WRONG IN SUPERBLK")) {
		memcpy(&fs->fs_cstotal, &cstotal, sumsize);
		fs->fs_ronly = 0;
		fs->fs_fmod = 0;
		sbdirty();
	}
}
@


1.47
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.46 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE roundup setbit */
@


1.46
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.45 2014/07/08 17:19:24 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d43 1
d49 2
d101 1
a101 1
				    MIN(fs->fs_maxcontig, FS_MAXCONTIG);
@


1.45
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.44 2014/05/21 18:53:05 krw Exp $	*/
d339 2
a340 2
					pwarn("ALLOCATED INODE %ld MARKED FREE\n",
					      c * fs->fs_ipg + i * 8 + k);
d350 1
a350 1
					if (cg_inosused(cg)[i] & (1 << k))
d352 2
a353 2
					pwarn("ALLOCATED FRAG %ld MARKED FREE\n",
					      c * fs->fs_fpg + i * 8 + k);
@


1.44
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.43 2013/06/11 16:42:04 deraadt Exp $	*/
a36 1
#include <ufs/ufs/dinode.h>
@


1.43
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.42 2013/04/24 13:46:29 deraadt Exp $	*/
d369 1
a369 1
	
@


1.42
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.41 2011/04/24 07:07:03 otto Exp $	*/
d66 2
a67 2
	daddr64_t dbase, dmax;
	daddr64_t d;
@


1.41
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.40 2011/04/16 16:37:21 otto Exp $	*/
d251 2
a252 2
				errexit("BAD STATE %d FOR INODE I=%ld\n",
				    GET_ISTATE(j), j);
@


1.40
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.39 2010/07/09 06:41:17 otto Exp $	*/
d68 1
a68 1
	long i, j, k;
d83 1
a83 1
				doinglevel1 = 1;
d110 1
a110 1
					doinglevel1 = 1;
d167 1
a167 1
	for (i = 0; i < 3; i++) {
a168 3
		if (doinglevel2)
			idesc[i].id_fix = FIX;
	}
d320 1
a320 1
		if (doinglevel1) {
@


1.39
log
@Avoid crashes by using correct types for block numbers, which can grow
large on very large filesystems; reported by Benny Lofgren; partly
from FreeBSD. ok deraadt@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.38 2009/10/27 23:59:32 deraadt Exp $	*/
d233 1
a233 1
		for (i = 0; i < cginosused[c]; j++, i++) {
@


1.38
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.37 2008/06/10 23:10:29 otto Exp $	*/
d173 3
a175 3
	j = blknum(fs, fs->fs_size + fs->fs_frag - 1);
	for (i = fs->fs_size; i < j; i++)
		setbmap(i);
@


1.37
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.36 2007/07/17 18:54:40 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)pass5.c	8.6 (Berkeley) 11/30/94";
#else
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.36 2007/07/17 18:54:40 otto Exp $";
#endif
#endif /* not lint */
@


1.36
log
@rmoev the macppc workaround, now that isset() and friends use expressions
that gcc likes better
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.35 2007/07/04 20:43:44 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.35 2007/07/04 20:43:44 deraadt Exp $";
d242 1
a242 1
			switch (statemap[j]) {
d263 1
a263 1
				    statemap[j], j);
@


1.35
log
@workaround for [daddr64_t] issue; worked on mostly by otto, wee bit by me
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.34 2007/06/25 19:59:55 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.34 2007/06/25 19:59:55 otto Exp $";
d276 1
a276 2
				/* XXX macppc has problems with [daddr64_t] */
				if (testbmap((u_int)d + j))
@


1.34
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.33 2007/06/01 14:26:08 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.33 2007/06/01 14:26:08 otto Exp $";
d276 2
a277 1
				if (testbmap(d + j))
@


1.33
log
@Don't use cg.cg_niblk but fs.fs_ipg; the former has no meaning any more.
Fixes PR 5494; with pedro@@; ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.32 2007/05/18 19:21:34 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.32 2007/05/18 19:21:34 millert Exp $";
d74 2
a75 2
	daddr_t dbase, dmax;
	daddr_t d;
@


1.32
log
@Fix mismerge; remove statement without effect.  OK otto@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.31 2007/05/11 08:28:52 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.31 2007/05/11 08:28:52 otto Exp $";
d223 1
a223 1
			    cg->cg_irotor < newcg->cg_niblk)
@


1.31
log
@pass the right size arg to memset, otherwise we end up with a
partially initialized summary info struct. ok millert@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.30 2007/05/05 22:17:34 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.30 2007/05/05 22:17:34 millert Exp $";
a282 1
				j = cbtocylno(fs, i);
@


1.30
log
@Do not rely on fs_cpg; this is especially important for ffs2 which
does not use fs_cpg at all.  From FreeBSD.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.29 2007/04/23 10:18:30 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.29 2007/04/23 10:18:30 pedro Exp $";
d180 1
a180 1
	memset(&cstotal, 0, sizeof(struct csum));
@


1.29
log
@Remove 'cg_space' from 'struct cg'. Due to the alignment on 64-bit
architectures, CGSIZE() was returning something sligthly over one block.
The 'new' fsck would round this value up to a fragment boundary, and end
up trying to access memory beyond allocated space. From mickey@@, okay
pedro@@, millert@@ and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.28 2007/04/21 19:25:52 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.28 2007/04/21 19:25:52 otto Exp $";
d149 4
a152 6
		newcg->cg_freeoff = newcg->cg_iusedoff +
		    howmany(fs->fs_ipg, NBBY);
		inomapsize = newcg->cg_freeoff - newcg->cg_iusedoff;
		newcg->cg_nextfreeoff = newcg->cg_freeoff +
		    howmany(fs->fs_cpg * fs->fs_spc / NSPF(fs), NBBY);
		blkmapsize = newcg->cg_nextfreeoff - newcg->cg_freeoff;
d161 1
a161 1
			    howmany(fs->fs_cpg * fs->fs_spc / NSPB(fs), NBBY);
@


1.28
log
@use the correct size arg to memcmp when checking fs_cstotal.
now jmc does not use 8TB in /tmp anymore. ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.27 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.27 2007/04/10 16:08:17 millert Exp $";
d141 1
a141 2
			newcg->cg_iusedoff = &newcg->cg_space[0] -
			    (u_char *)(&newcg->cg_firstfield);
d143 1
a143 2
			newcg->cg_btotoff = &newcg->cg_space[0] -
			    (u_char *)(&newcg->cg_firstfield);
d166 1
a166 2
		basesize = &newcg->cg_space[0] -
		    (u_char *)(&newcg->cg_firstfield);
@


1.27
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.26 2007/03/19 13:27:47 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.26 2007/03/19 13:27:47 pedro Exp $";
d386 3
a388 1
	if (memcmp(&cstotal, &fs->fs_cstotal, sizeof *cs) != 0
d390 1
a390 1
		memcpy(&fs->fs_cstotal, &cstotal, sizeof *cs);
@


1.26
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.25 2007/03/15 10:27:00 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.25 2007/03/15 10:27:00 pedro Exp $";
d78 1
a78 1
	struct csum cstotal;
a84 1
	newcg->cg_niblk = fs->fs_ipg;
d140 13
a152 8
		newcg->cg_btotoff =
		     &newcg->cg_space[0] - (u_char *)(&newcg->cg_firstfield);
		newcg->cg_boff =
		    newcg->cg_btotoff + fs->fs_cpg * sizeof(int32_t);
		newcg->cg_iusedoff = newcg->cg_boff +
		    fs->fs_cpg * fs->fs_nrpos * sizeof(int16_t);
		newcg->cg_freeoff =
		    newcg->cg_iusedoff + howmany(fs->fs_ipg, NBBY);
d186 2
a187 2
	j = blknum(fs, fs->fs_ffs1_size + fs->fs_frag - 1);
	for (i = fs->fs_ffs1_size; i < j; i++)
d199 2
a200 2
		if (dmax > fs->fs_ffs1_size)
			dmax = fs->fs_ffs1_size;
d223 18
a240 4
		if (cg->cg_irotor >= 0 && cg->cg_irotor < newcg->cg_niblk)
			newcg->cg_irotor = cg->cg_irotor;
		else
			newcg->cg_irotor = 0;
d242 1
a242 2
		memset(&cg_blktot(newcg)[0], 0,
		      (size_t)(sumsize + mapsize));
d246 1
a246 1
		for (i = 0; i < fs->fs_ipg; j++, i++) {
a288 2
				cg_blktot(newcg)[j]++;
				cg_blks(fs, newcg, j)[cbtorpos(fs, i)]++;
d342 1
a342 3
		if ((memcmp(newcg, cg, basesize) != 0 ||
		     memcmp(&cg_blktot(newcg)[0],
			    &cg_blktot(cg)[0], sumsize) != 0) &&
a344 2
			memcpy(&cg_blktot(cg)[0],
			       &cg_blktot(newcg)[0], (size_t)sumsize);
d386 1
a386 1
	if (memcmp(&cstotal, &fs->fs_ffs1_cstotal, sizeof *cs) != 0
d388 1
a388 1
		memcpy(&fs->fs_ffs1_cstotal, &cstotal, sizeof *cs);
@


1.25
log
@Check for cg_irotor and cg_frotor being negative, okay millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.24 2006/04/27 02:40:03 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.24 2006/04/27 02:40:03 pedro Exp $";
d182 2
a183 2
	j = blknum(fs, fs->fs_size + fs->fs_frag - 1);
	for (i = fs->fs_size; i < j; i++)
d195 2
a196 2
		if (dmax > fs->fs_size)
			dmax = fs->fs_size;
d375 1
a375 1
	if (memcmp(&cstotal, &fs->fs_cstotal, sizeof *cs) != 0
d377 1
a377 1
		memcpy(&fs->fs_cstotal, &cstotal, sizeof *cs);
@


1.24
log
@Avoid spurious 'summary information bad' warnings, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.23 2006/03/22 20:24:32 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.23 2006/03/22 20:24:32 deraadt Exp $";
d215 1
a215 1
		if (cg->cg_frotor < newcg->cg_ndblk)
d219 1
a219 1
		if (cg->cg_irotor < newcg->cg_niblk)
@


1.23
log
@earlier asprintf diff caused malloc in signal handler.  clarify the
code a bit more so that this mistake will not be done again
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.21 2006/01/25 06:25:46 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.21 2006/01/25 06:25:46 tedu Exp $";
d198 1
@


1.22
log
@use asprintf instead of a static buffer; dhill, tested by pedro
@
text
@d61 1
a61 1
pass5_info(char *buf)
d63 1
a63 1
	return (asprintf(&buf, "phase 5, cg %d/%d",
@


1.21
log
@spell fall through as FALLTHROUGH
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.20 2005/06/16 14:51:37 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.20 2005/06/16 14:51:37 millert Exp $";
d61 1
a61 1
pass5_info(char *buf, int buflen)
d63 1
a63 1
	return (snprintf(buf, buflen, "phase 5, cg %d/%d",
@


1.20
log
@bye bye whiteouts
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.19 2005/04/16 18:15:41 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.19 2005/04/16 18:15:41 millert Exp $";
d238 1
a238 1
				/* fall through */
@


1.19
log
@Since the return value from the *_info functions is only actually used as a
boolean, make it so.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.18 2005/04/16 17:37:25 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.18 2005/04/16 17:37:25 deraadt Exp $";
a83 1
	statemap[WINO] = USTATE;
@


1.18
log
@while snprintf and strlcpy and strlcat have this nice >buflen API (and the
-1 mess as well), it is probably not wise to make other functions do the same
thing.  make them return strlen().  ok uwe marco
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.17 2003/10/11 01:43:45 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.17 2003/10/11 01:43:45 tedu Exp $";
d63 2
a64 4
	if (snprintf(buf, buflen, "phase 5, cg %d/%d",
	    info_cg, info_maxcg) > 0)
		return (strlen(buf));
	return (0);
@


1.17
log
@consistent newlines, from tom cosgrove at arches-consulting.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.16 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.16 2003/06/02 20:06:15 millert Exp $";
d63 4
a66 1
	return snprintf(buf, buflen, "phase 5, cg %d/%d", info_cg, info_maxcg);
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.15 2002/08/23 09:09:04 gluk Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.15 2002/08/23 09:09:04 gluk Exp $";
d249 1
a249 1
				errexit("BAD STATE %d FOR INODE I=%ld",
@


1.15
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.14 2001/12/01 19:04:41 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: pass5.c,v 1.14 2001/12/01 19:04:41 deraadt Exp $";
@


1.14
log
@fix headers
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.13 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.13 2001/11/05 07:39:16 mpech Exp $";
d65 1
a65 3
pass5_info(buf, buflen)
	char *buf;
	int buflen;
d71 1
a71 1
pass5()
@


1.13
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.12 2001/07/07 18:26:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.12 2001/07/07 18:26:12 deraadt Exp $";
d48 1
@


1.12
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.11 2001/03/09 07:26:09 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.11 2001/03/09 07:26:09 mickey Exp $";
d76 2
a77 2
	register struct fs *fs = &sblock;
	register struct cg *cg = &cgrp;
d85 1
a85 1
	register struct cg *newcg = (struct cg *)buf;
@


1.11
log
@missing \n for MARKED FREE messages, some spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.10 2001/03/02 18:35:20 csapuntz Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.10 2001/03/02 18:35:20 csapuntz Exp $";
d47 1
d50 3
d350 1
a350 1
					pwarn("ALLOCATED INODE %d MARKED FREE\n",
d363 1
a363 1
					pwarn("ALLOCATED FRAG %d MARKED FREE\n",
@


1.10
log
@
Simpler algorithm or calculating inomapsize
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.9 2001/03/02 14:45:30 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.9 2001/03/02 14:45:30 art Exp $";
d146 1
a146 1
		newcg->cg_iusedoff = newcg->cg_boff + 
d172 1
a172 1
		inomapsize = blkmapsize = sumsize = 0; 
d343 1
a343 1
                                               continue;
d346 1
a346 1
					pwarn("ALLOCATED INODE %d MARKED FREE",
d353 1
a353 1
                                       continue;
d359 1
a359 1
					pwarn("ALLOCATED FRAG %d MARKED FREE",
d364 1
a364 1
		if (memcmp(cg_inosused(newcg), cg_inosused(cg), 
d369 2
a370 2
                        cgdirty();
                }
@


1.9
log
@When doing last second fixes before a commit, it's a good idea
to check if it builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d135 1
a135 1
		inomapsize = (u_char *)&ocg->cg_magic - (u_char *)&ocg->cg_iused[0];
@


1.8
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.7 1999/03/01 07:45:18 d Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.7 1999/03/01 07:45:18 d Exp $";
d135 1
a135 1
		inomapsize = &ocg->cg_magic - (u_char *)&ocg->cg_iused[0];
@


1.7
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.6 1997/11/09 19:53:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.6 1997/11/09 19:53:17 millert Exp $";
d71 1
d75 2
a76 2
	register daddr_t d;
	register long i, j;
d134 2
d150 6
a155 6
		if (fs->fs_contigsumsize <= 0) {
			newcg->cg_nextfreeoff = newcg->cg_freeoff +
			    howmany(fs->fs_cpg * fs->fs_spc / NSPF(fs), NBBY);
		} else {
			newcg->cg_clustersumoff = newcg->cg_freeoff +
			    howmany(fs->fs_cpg * fs->fs_spc / NSPF(fs), NBBY) -
d172 1
a326 7
		if (memcmp(cg_inosused(newcg),
			   cg_inosused(cg), mapsize) != 0 &&
		    dofix(&idesc[1], "BLK(S) MISSING IN BIT MAPS")) {
			memcpy(cg_inosused(cg), cg_inosused(newcg),
			      (size_t)mapsize);
			cgdirty();
		}
d336 35
@


1.6
log
@Don't include <ufs/ffs/ffs_extern.h>.  fsck_ffs now compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.5 1997/10/06 20:22:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.5 1997/10/06 20:22:35 deraadt Exp $";
d49 1
d56 11
d70 1
a70 1
	int c, blk, frags, basesize, sumsize, mapsize, savednrpos;
d182 3
d186 1
d340 1
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.3 1996/10/20 08:36:40 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.3 1996/10/20 08:36:40 tholo Exp $";
a48 1
#include <ufs/ffs/ffs_extern.h>
@


1.4
log
@VFS Lite2 Changes
@
text
@d49 1
a59 1
	int inomapsize, blkmapsize;
d63 2
a64 2
        daddr_t d;
	long i, j, k;
a121 2
		blkmapsize = howmany(fs->fs_fpg, NBBY);
		inomapsize = &ocg->cg_free[0] - (u_char *)&ocg->cg_iused[0];
d136 6
a141 6
		inomapsize = newcg->cg_freeoff - newcg->cg_iusedoff;
		newcg->cg_nextfreeoff = newcg->cg_freeoff +
		    howmany(fs->fs_cpg * fs->fs_spc / NSPF(fs), NBBY);
		blkmapsize = newcg->cg_nextfreeoff - newcg->cg_freeoff;
		if (fs->fs_contigsumsize > 0) {
			newcg->cg_clustersumoff = newcg->cg_nextfreeoff -
a157 1
		inomapsize = blkmapsize = sumsize = 0; 
d308 7
a323 35
		if (usedsoftdep) {
			for (i = 0; i < inomapsize; i++) {
				j = cg_inosused(newcg)[i];
				if ((cg_inosused(cg)[i] & j) == j)
					continue;
				for (k = 0; k < NBBY; k++) {
					if ((j & (1 << k)) == 0)
                                               continue;
					if (cg_inosused(cg)[i] & (1 << k))
						continue;
					pwarn("ALLOCATED INODE %d MARKED FREE",
					      c * fs->fs_ipg + i * 8 + k);
				}
			}
			for (i = 0; i < blkmapsize; i++) {
				j = cg_blksfree(cg)[i];
				if ((cg_blksfree(newcg)[i] & j) == j)
                                       continue;
				for (k = 0; k < NBBY; k++) {
					if ((j & (1 << k)) == 0)
						continue;
					if (cg_inosused(cg)[i] & (1 << k))
						continue;
					pwarn("ALLOCATED FRAG %d MARKED FREE",
					      c * fs->fs_fpg + i * 8 + k);
				}
			}
		}
		if (memcmp(cg_inosused(newcg), cg_inosused(cg), 
			   mapsize) != 0 &&
		    dofix(&idesc[1], "BLK(S) MISSING IN BIT MAPS")) {
			memmove(cg_inosused(cg), cg_inosused(newcg),
				(size_t)mapsize);
                        cgdirty();
                }
@


1.3
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: pass5.c,v 1.2 1996/06/23 14:30:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.2 1996/06/23 14:30:33 deraadt Exp $";
a48 1
#include <ufs/ffs/ffs_extern.h>
d59 1
d63 2
a64 2
	register daddr_t d;
	register long i, j;
d122 2
d138 6
a143 6
		if (fs->fs_contigsumsize <= 0) {
			newcg->cg_nextfreeoff = newcg->cg_freeoff +
			    howmany(fs->fs_cpg * fs->fs_spc / NSPF(fs), NBBY);
		} else {
			newcg->cg_clustersumoff = newcg->cg_freeoff +
			    howmany(fs->fs_cpg * fs->fs_spc / NSPF(fs), NBBY) -
d160 1
a310 7
		if (memcmp(cg_inosused(newcg),
			   cg_inosused(cg), mapsize) != 0 &&
		    dofix(&idesc[1], "BLK(S) MISSING IN BIT MAPS")) {
			memcpy(cg_inosused(cg), cg_inosused(newcg),
			      (size_t)mapsize);
			cgdirty();
		}
d320 35
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: pass5.c,v 1.14 1995/03/21 01:30:16 cgd Exp $	*/
/*	$NetBSD: pass5.c,v 1.14 1995/03/21 01:30:16 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pass5.c,v 1.14 1995/03/21 01:30:16 cgd Exp $";
d49 1
d51 2
d231 1
a231 1
				errexit("BAD STATE %d FOR INODE I=%d",
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: pass5.c,v 1.14 1995/03/21 01:30:16 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
