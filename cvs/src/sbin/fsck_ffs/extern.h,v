head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.16
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.14
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.10
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.09.09.15.37.15;	author tb;	state Exp;
branches;
next	1.13;
commitid	TXzQrSRLn0xGub30;

1.13
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.12;
commitid	qlzrzgnJ4ZiiF6XQ;

1.12
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.26.00.39.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.28.21.22.47;	author gluk;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.07.45.17;	author d;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	96.10.20.08.36.31;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches;
next	;

1.4.10.1
date	2001.06.06.04.06.54;	author jason;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Tighten pledge for fsdb and eliminate a strcmp("fsdb", getprogname())
by passing a flag to setup().

ok deraadt
@
text
@/*	$OpenBSD: extern.h,v 1.13 2014/09/06 04:05:40 guenther Exp $	*/
/*	$NetBSD: extern.h,v 1.6 1996/09/27 22:45:12 christos Exp $	*/

/*
 * Copyright (c) 1994 James A. Jegers
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

void	adjust(struct inodesc *, short);
daddr_t	allocblk(int);
ino_t	allocdir(ino_t, ino_t, int);
void	blkerror(ino_t, char *, daddr_t);
int	bread(int, char *, daddr_t, long);
void	bufinit(void);
void	bwrite(int, char *, daddr_t, long);
void	cacheino(union dinode *, ino_t);
int	changeino(ino_t, char *, ino_t);
struct	fstab;
int	chkrange(daddr_t, int);
void	ckfini(int);
int	ckinode(union dinode *, struct inodesc *);
void	clri(struct inodesc *, char *, int);
int	dircheck(struct inodesc *, struct direct *);
void	direrror(ino_t, char *);
int	dirscan(struct inodesc *);
int	dofix(struct inodesc *, char *);
void	fileerror(ino_t, ino_t, char *);
int	findino(struct inodesc *);
int	findname(struct inodesc *);
void	flush(int, struct bufarea *);
void	freeblk(daddr_t, int);
void	freeino(ino_t);
void	freeinodebuf(void);
int	ftypeok(union dinode *);
void	getpathname(char *, size_t, ino_t, ino_t);
void	inocleanup(void);
void	inodirty(void);
struct inostat *inoinfo(ino_t);
int	linkup(ino_t, ino_t);
int	makeentry(ino_t, ino_t, char *);
void	pass1(void);
void	pass1b(void);
void	pass2(void);
void	pass3(void);
void	pass4(void);
int	pass1check(struct inodesc *);
int	pass4check(struct inodesc *);
void	pass5(void);
void	pinode(ino_t);
void	propagate(ino_t);
int	reply(char *);
void	setinodebuf(ino_t);
int	setup(char *, int);
union dinode * getnextinode(ino_t);
void	catch(int);
void	catchquit(int);
void	voidquit(int);
void	catchinfo(int);
@


1.13
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.12 2013/06/11 16:42:04 deraadt Exp $	*/
d72 1
a72 1
int	setup(char *);
@


1.12
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.11 2011/04/16 16:37:21 otto Exp $	*/
d29 2
a30 2
int	allocblk(long);
int	allocdir(ino_t, ino_t, int);
d50 1
a50 1
void	freeblk(daddr_t, long);
@


1.11
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.10 2007/06/25 19:59:55 otto Exp $	*/
d31 2
a32 2
void	blkerror(ino_t, char *, daddr64_t);
int	bread(int, char *, daddr64_t, long);
d34 1
a34 1
void	bwrite(int, char *, daddr64_t, long);
d38 1
a38 1
int	chkrange(daddr64_t, int);
d50 1
a50 1
void	freeblk(daddr64_t, long);
@


1.10
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.9 2007/04/10 16:08:17 millert Exp $	*/
d57 1
@


1.9
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.8 2003/08/25 23:28:15 tedu Exp $	*/
d31 2
a32 2
void	blkerror(ino_t, char *, daddr_t);
int	bread(int, char *, daddr_t, long);
d34 1
a34 1
void	bwrite(int, char *, daddr_t, long);
d38 1
a38 1
int	chkrange(daddr_t, int);
d50 1
a50 1
void	freeblk(daddr_t, long);
@


1.8
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.7 2003/04/26 00:39:28 deraadt Exp $	*/
d35 1
a35 1
void	cacheino(struct ufs1_dinode *, ino_t);
d40 1
a40 1
int	ckinode(struct ufs1_dinode *, struct inodesc *);
d53 1
a53 1
int	ftypeok(struct ufs1_dinode *);
d70 1
a70 1
void	resetinodebuf(void);
d72 1
a72 1
struct	ufs1_dinode * getnextinode(ino_t);
@


1.7
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.6 2002/02/16 21:27:34 millert Exp $	*/
d35 1
a35 1
void	cacheino(struct dinode *, ino_t);
d40 1
a40 1
int	ckinode(struct dinode *, struct inodesc *);
d53 1
a53 1
int	ftypeok(struct dinode *);
d72 1
a72 1
struct	dinode * getnextinode(ino_t);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.5 2001/05/28 21:22:47 gluk Exp $	*/
d54 1
a54 1
void	getpathname(char *, ino_t, ino_t);
@


1.5
log
@Fix directory state tracking.

- If the lost+found directory is created by fsck, it will do a cacheino()
  which sets the inoinfo's i_parent and i_dotdot to 0, but they never get
  set to ROOTINO. This means that propagate will never find lost+found and
  its descendents, subdirectories will remain DSTATE (instead of DFOUND)
  even though they are correctly linked in, and pass4.c will try to
  clear them unsuccessfully, thinking that there is no link count from the
  DSTATE directory's parent. The result is that you need to run fsck twice
  and get "EXTRANEOUS HARD LINK TO DIRECTORY" error (which are unexpected
  and fatal when running in preen mode). The fix is to set i_parent and
  i_dotdot to "parent" after the second cacheino() call in dir.c:allocdir().
  From NetBSD via FreeBSD.
- modify propagate() so it be able to start from any point in the tree.
- minor tweaks to get more generality in state propagation.

In other words fsck doesn't leave unremovable directories anymore.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.4 1999/03/01 07:45:17 d Exp $	*/
d28 9
a36 9
void	adjust __P((struct inodesc *, short));
int	allocblk __P((long));
int	allocdir __P((ino_t, ino_t, int));
void	blkerror __P((ino_t, char *, daddr_t));
int	bread __P((int, char *, daddr_t, long));
void	bufinit __P((void));
void	bwrite __P((int, char *, daddr_t, long));
void	cacheino __P((struct dinode *, ino_t));
int	changeino __P((ino_t, char *, ino_t));
d38 39
a76 39
int	chkrange __P((daddr_t, int));
void	ckfini __P((int));
int	ckinode __P((struct dinode *, struct inodesc *));
void	clri __P((struct inodesc *, char *, int));
int	dircheck __P((struct inodesc *, struct direct *));
void	direrror __P((ino_t, char *));
int	dirscan __P((struct inodesc *));
int	dofix __P((struct inodesc *, char *));
void	fileerror __P((ino_t, ino_t, char *));
int	findino __P((struct inodesc *));
int	findname __P((struct inodesc *));
void	flush __P((int, struct bufarea *));
void	freeblk __P((daddr_t, long));
void	freeino __P((ino_t));
void	freeinodebuf __P((void));
int	ftypeok __P((struct dinode *));
void	getpathname __P((char *, ino_t, ino_t));
void	inocleanup __P((void));
void	inodirty __P((void));
int	linkup __P((ino_t, ino_t));
int	makeentry __P((ino_t, ino_t, char *));
void	pass1 __P((void));
void	pass1b __P((void));
void	pass2 __P((void));
void	pass3 __P((void));
void	pass4 __P((void));
int	pass1check __P((struct inodesc *));
int	pass4check __P((struct inodesc *));
void	pass5 __P((void));
void	pinode __P((ino_t));
void	propagate __P((ino_t));
int	reply __P((char *));
void	resetinodebuf __P((void));
int	setup __P((char *));
struct	dinode * getnextinode __P((ino_t));
void	catch __P((int));
void	catchquit __P((int));
void	voidquit __P((int));
void	catchinfo __P((int));
@


1.4
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.3 1996/10/20 08:36:31 tholo Exp $	*/
d68 1
a68 1
void	propagate __P((void));
@


1.4.10.1
log
@Pull in patch from current:
Fix (gluk):
Fix directory state tracking.

- If the lost+found directory is created by fsck, it will do a cacheino()
  which sets the inoinfo's i_parent and i_dotdot to 0, but they never get
  set to ROOTINO. This means that propagate will never find lost+found and
  its descendents, subdirectories will remain DSTATE (instead of DFOUND)
  even though they are correctly linked in, and pass4.c will try to
  clear them unsuccessfully, thinking that there is no link count from the
  DSTATE directory's parent. The result is that you need to run fsck twice
  and get "EXTRANEOUS HARD LINK TO DIRECTORY" error (which are unexpected
  and fatal when running in preen mode). The fix is to set i_parent and
  i_dotdot to "parent" after the second cacheino() call in dir.c:allocdir().
  From NetBSD via FreeBSD.
- modify propagate() so it be able to start from any point in the tree.
- minor tweaks to get more generality in state propagation.

In other words fsck doesn't leave unremovable directories anymore.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.4 1999/03/01 07:45:17 d Exp $	*/
d68 1
a68 1
void	propagate __P((ino_t));
@


1.3
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.2 1996/06/23 14:30:27 deraadt Exp $	*/
d76 1
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: extern.h,v 1.4 1995/04/12 21:24:07 mycroft Exp $	*/
/*	$NetBSD: extern.h,v 1.4 1995/04/12 21:24:07 mycroft Exp $	*/
d28 48
a75 44
void adjust __P((struct inodesc *, short));
int allocblk __P((long));
int allocdir __P((ino_t, ino_t, int));
void blkerror __P((ino_t, char *, daddr_t));
int bread __P((int, char *, daddr_t, long));
void bufinit();
void bwrite __P((int, char *, daddr_t, long));
void cacheino __P((struct dinode *, ino_t));
int changeino __P((ino_t, char *, ino_t));
int checkfstab __P((int, int, int (*)(), int (*)() ));
int chkrange __P((daddr_t, int));
void ckfini __P((int));
int ckinode __P((struct dinode *, struct inodesc *));
void clri __P((struct inodesc *, char *, int));
int dircheck __P((struct inodesc *, struct direct *));
void direrror __P((ino_t, char *));
int dirscan __P((struct inodesc *));
int dofix __P((struct inodesc *, char *));
void fileerror __P((ino_t, ino_t, char *));
int findino __P((struct inodesc *));
int findname __P((struct inodesc *));
void flush __P((int, struct bufarea *));
void freeblk __P((daddr_t, long));
void freeino __P((ino_t));
void freeinodebuf();
int ftypeok __P((struct dinode *));
void getpathname __P((char *, ino_t, ino_t));
void inocleanup();
void inodirty();
int linkup __P((ino_t, ino_t));
int makeentry __P((ino_t, ino_t, char *));
void pass1();
void pass1b();
void pass2();
void pass3();
void pass4();
int pass4check();
void pass5();
void pinode __P((ino_t));
void propagate();
int reply __P((char *));
void resetinodebuf();
int setup __P((char *));

@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
