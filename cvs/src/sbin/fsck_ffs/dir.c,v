head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.12
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.8
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.4
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.29.0.8
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.8
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	F55lwc3gS4GN2mLs;

1.31
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Uu5nFG3wCl0LACBb;

1.30
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.29;
commitid	qlzrzgnJ4ZiiF6XQ;

1.29
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.08.14.38.40;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.16.17.42.40;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.08.13.09.53;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.24.13.24.58;	author bluhm;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.05.02.31.54;	author pvalchev;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.26.00.39.28;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.23.09.09.04;	author gluk;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.28.21.22.47;	author gluk;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.02.08.33.55;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	97.10.06.20.22.31;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.33.32;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.03.27.16.28.51;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.20.06.03.04;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.10.20.08.36.30;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.06.04.06.54;	author jason;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@/*	$OpenBSD: dir.c,v 1.31 2015/01/16 06:39:57 deraadt Exp $	*/
/*	$NetBSD: dir.c,v 1.20 1996/09/27 22:45:11 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE roundup btodb */
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "fsck.h"
#include "fsutil.h"
#include "extern.h"

char	*lfname = "lost+found";
int	lfmode = 01700;
struct	dirtemplate emptydir = { 0, DIRBLKSIZ };
struct	dirtemplate dirhead = {
	0, 12, DT_DIR, 1, ".",
	0, DIRBLKSIZ - 12, DT_DIR, 2, ".."
};
struct	odirtemplate odirhead = {
	0, 12, 1, ".",
	0, DIRBLKSIZ - 12, 2, ".."
};

static int expanddir(union dinode *, char *);
static void freedir(ino_t, ino_t);
static struct direct *fsck_readdir(struct inodesc *);
static struct bufarea *getdirblk(daddr_t, long);
static int lftempname(char *, ino_t);
static int mkentry(struct inodesc *);
static int chgino(struct  inodesc *);

/*
 * Propagate connected state through the tree.
 */
void
propagate(ino_t inumber)
{
	struct	inoinfo *inp;
	char	state;

	inp = getinoinfo(inumber);
	state = GET_ISTATE(inp->i_number);
	for (;;) {
		SET_ISTATE(inp->i_number, state);
		if (inp->i_child &&
		    GET_ISTATE(inp->i_child->i_number) != state)
			inp = inp->i_child;
		else if (inp->i_number == inumber)
			break;
		else if (inp->i_sibling)
			inp = inp->i_sibling;
		else
			inp = getinoinfo(inp->i_parent);
	}
}

/*
 * Scan each entry in a directory block.
 */
int
dirscan(struct inodesc *idesc)
{
	struct direct *dp;
	struct bufarea *bp;
	int dsize, n;
	long blksiz;
	char dbuf[DIRBLKSIZ];

	if (idesc->id_type != DATA)
		errexit("wrong type to dirscan %d\n", idesc->id_type);
	if (idesc->id_entryno == 0 &&
	    (idesc->id_filesize & (DIRBLKSIZ - 1)) != 0)
		idesc->id_filesize = roundup(idesc->id_filesize, DIRBLKSIZ);
	blksiz = idesc->id_numfrags * sblock.fs_fsize;
	if (chkrange(idesc->id_blkno, idesc->id_numfrags)) {
		idesc->id_filesize -= blksiz;
		return (SKIP);
	}
	idesc->id_loc = 0;
	for (dp = fsck_readdir(idesc); dp != NULL; dp = fsck_readdir(idesc)) {
		dsize = dp->d_reclen;
		memcpy(dbuf, dp, (size_t)dsize);
		idesc->id_dirp = (struct direct *)dbuf;
		if ((n = (*idesc->id_func)(idesc)) & ALTERED) {
			bp = getdirblk(idesc->id_blkno, blksiz);
			memcpy(bp->b_un.b_buf + idesc->id_loc - dsize, dbuf,
			    (size_t)dsize);
			dirty(bp);
			sbdirty();
		}
		if (n & STOP)
			return (n);
	}
	return (idesc->id_filesize > 0 ? KEEPON : STOP);
}

/*
 * get next entry in a directory.
 */
static struct direct *
fsck_readdir(struct inodesc *idesc)
{
	struct direct *dp, *ndp;
	struct bufarea *bp;
	long size, blksiz, fix, dploc;

	blksiz = idesc->id_numfrags * sblock.fs_fsize;
	bp = getdirblk(idesc->id_blkno, blksiz);
	if (idesc->id_loc % DIRBLKSIZ == 0 && idesc->id_filesize > 0 &&
	    idesc->id_loc < blksiz) {
		dp = (struct direct *)(bp->b_un.b_buf + idesc->id_loc);
		if (dircheck(idesc, dp))
			goto dpok;
		if (idesc->id_fix == IGNORE)
			return (0);
		fix = dofix(idesc, "DIRECTORY CORRUPTED");
		bp = getdirblk(idesc->id_blkno, blksiz);
		dp = (struct direct *)(bp->b_un.b_buf + idesc->id_loc);
		dp->d_reclen = DIRBLKSIZ;
		dp->d_ino = 0;
		dp->d_type = 0;
		dp->d_namlen = 0;
		dp->d_name[0] = '\0';
		if (fix)
			dirty(bp);
		idesc->id_loc += DIRBLKSIZ;
		idesc->id_filesize -= DIRBLKSIZ;
		return (dp);
	}
dpok:
	if (idesc->id_filesize <= 0 || idesc->id_loc >= blksiz)
		return NULL;
	dploc = idesc->id_loc;
	dp = (struct direct *)(bp->b_un.b_buf + dploc);
	idesc->id_loc += dp->d_reclen;
	idesc->id_filesize -= dp->d_reclen;
	if ((idesc->id_loc % DIRBLKSIZ) == 0)
		return (dp);
	ndp = (struct direct *)(bp->b_un.b_buf + idesc->id_loc);
	if (idesc->id_loc < blksiz && idesc->id_filesize > 0 &&
	    dircheck(idesc, ndp) == 0) {
		size = DIRBLKSIZ - (idesc->id_loc % DIRBLKSIZ);
		idesc->id_loc += size;
		idesc->id_filesize -= size;
		if (idesc->id_fix == IGNORE)
			return (0);
		fix = dofix(idesc, "DIRECTORY CORRUPTED");
		bp = getdirblk(idesc->id_blkno, blksiz);
		dp = (struct direct *)(bp->b_un.b_buf + dploc);
		dp->d_reclen += size;
		if (fix)
			dirty(bp);
	}
	return (dp);
}

/*
 * Verify that a directory entry is valid.
 * This is a superset of the checks made in the kernel.
 */
int
dircheck(struct inodesc *idesc, struct direct *dp)
{
	int size;
	char *cp;
	u_char namlen, type;
	int spaceleft;

	spaceleft = DIRBLKSIZ - (idesc->id_loc % DIRBLKSIZ);
	if (dp->d_ino >= maxino ||
	    dp->d_reclen == 0 ||
	    dp->d_reclen > spaceleft ||
	    (dp->d_reclen & 0x3) != 0)
		return (0);
	if (dp->d_ino == 0)
		return (1);
	size = DIRSIZ(0, dp);
	namlen = dp->d_namlen;
	type = dp->d_type;
	if (dp->d_reclen < size ||
	    idesc->id_filesize < size ||
	    type > 15)
		return (0);
	for (cp = dp->d_name, size = 0; size < namlen; size++)
		if (*cp == '\0' || (*cp++ == '/'))
			return (0);
	if (*cp != '\0')
		return (0);
	return (1);
}

void
direrror(ino_t ino, char *errmesg)
{
	fileerror(ino, ino, errmesg);
}

void
fileerror(ino_t cwd, ino_t ino, char *errmesg)
{
	union dinode *dp;
	char pathbuf[PATH_MAX + 1];

	pwarn("%s ", errmesg);
	pinode(ino);
	printf("\n");
	getpathname(pathbuf, sizeof pathbuf, cwd, ino);
	if (ino < ROOTINO || ino > maxino) {
		pfatal("NAME=%s\n", pathbuf);
		return;
	}
	dp = ginode(ino);
	if (ftypeok(dp))
		pfatal("%s=%s\n",
		    (DIP(dp, di_mode) & IFMT) == IFDIR ? "DIR" : "FILE",
		    pathbuf);
	else
		pfatal("NAME=%s\n", pathbuf);
}

void
adjust(struct inodesc *idesc, short lcnt)
{
	union dinode *dp;

	dp = ginode(idesc->id_number);
	if (DIP(dp, di_nlink) == lcnt) {
		if (linkup(idesc->id_number, 0) == 0)
			clri(idesc, "UNREF", 0);
	} else {
		pwarn("LINK COUNT %s", (lfdir == idesc->id_number) ? lfname :
			((DIP(dp, di_mode) & IFMT) == IFDIR ? "DIR" : "FILE"));
		pinode(idesc->id_number);
		printf(" COUNT %d SHOULD BE %d", DIP(dp, di_nlink),
		    DIP(dp, di_nlink) - lcnt);
		if (preen || usedsoftdep) {
			if (lcnt < 0) {
				printf("\n");
				pfatal("LINK COUNT INCREASING");
			}
			if (preen)
				printf(" (ADJUSTED)\n");
		}
		if (preen || reply("ADJUST") == 1) {
			DIP_SET(dp, di_nlink, DIP(dp, di_nlink) - lcnt);
			inodirty();
		}
	}
}

static int
mkentry(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;
	struct direct newent;
	int newlen, oldlen;

	newent.d_namlen = strlen(idesc->id_name);
	newlen = DIRSIZ(0, &newent);
	if (dirp->d_ino != 0)
		oldlen = DIRSIZ(0, dirp);
	else
		oldlen = 0;
	if (dirp->d_reclen - oldlen < newlen)
		return (KEEPON);
	newent.d_reclen = dirp->d_reclen - oldlen;
	dirp->d_reclen = oldlen;
	dirp = (struct direct *)(((char *)dirp) + oldlen);
	dirp->d_ino = idesc->id_parent;	/* ino to be entered is in id_parent */
	dirp->d_reclen = newent.d_reclen;
	dirp->d_type = GET_ITYPE(idesc->id_parent);
	dirp->d_namlen = newent.d_namlen;
	memcpy(dirp->d_name, idesc->id_name, (size_t)dirp->d_namlen + 1);
	return (ALTERED|STOP);
}

static int
chgino(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;

	if (memcmp(dirp->d_name, idesc->id_name, (int)dirp->d_namlen + 1))
		return (KEEPON);
	dirp->d_ino = idesc->id_parent;
	dirp->d_type = GET_ITYPE(idesc->id_parent);
	return (ALTERED|STOP);
}

int
linkup(ino_t orphan, ino_t parentdir)
{
	union dinode *dp;
	int lostdir;
	ino_t oldlfdir;
	struct inodesc idesc;
	char tempname[BUFSIZ];

	memset(&idesc, 0, sizeof(struct inodesc));
	dp = ginode(orphan);
	lostdir = (DIP(dp, di_mode) & IFMT) == IFDIR;
	pwarn("UNREF %s ", lostdir ? "DIR" : "FILE");
	pinode(orphan);
	if ((preen || usedsoftdep) && DIP(dp, di_size) == 0)
		return (0);
	if (preen)
		printf(" (RECONNECTED)\n");
	else
		if (reply("RECONNECT") == 0)
			return (0);
	if (lfdir == 0) {
		dp = ginode(ROOTINO);
		idesc.id_name = lfname;
		idesc.id_type = DATA;
		idesc.id_func = findino;
		idesc.id_number = ROOTINO;
		if ((ckinode(dp, &idesc) & FOUND) != 0) {
			lfdir = idesc.id_parent;
		} else {
			pwarn("NO lost+found DIRECTORY");
			if (preen || reply("CREATE")) {
				lfdir = allocdir(ROOTINO, 0, lfmode);
				if (lfdir != 0) {
					if (makeentry(ROOTINO, lfdir, lfname) != 0) {
						if (preen)
							printf(" (CREATED)\n");
					} else {
						freedir(lfdir, ROOTINO);
						lfdir = 0;
						if (preen)
							printf("\n");
					}
				}
			}
		}
		if (lfdir == 0) {
			pfatal("SORRY. CANNOT CREATE lost+found DIRECTORY");
			printf("\n\n");
			return (0);
		}
	}
	dp = ginode(lfdir);
	if ((DIP(dp, di_mode) & IFMT) != IFDIR) {
		pfatal("lost+found IS NOT A DIRECTORY");
		if (reply("REALLOCATE") == 0)
			return (0);
		oldlfdir = lfdir;
		if ((lfdir = allocdir(ROOTINO, 0, lfmode)) == 0) {
			pfatal("SORRY. CANNOT CREATE lost+found DIRECTORY\n\n");
			return (0);
		}
		if ((changeino(ROOTINO, lfname, lfdir) & ALTERED) == 0) {
			pfatal("SORRY. CANNOT CREATE lost+found DIRECTORY\n\n");
			return (0);
		}
		inodirty();
		idesc.id_type = ADDR;
		idesc.id_func = pass4check;
		idesc.id_number = oldlfdir;
		adjust(&idesc, ILNCOUNT(oldlfdir) + 1);
		ILNCOUNT(oldlfdir) = 0;
		dp = ginode(lfdir);
	}
	if (GET_ISTATE(lfdir) != DFOUND) {
		pfatal("SORRY. NO lost+found DIRECTORY\n\n");
		return (0);
	}
	(void)lftempname(tempname, orphan);
	if (makeentry(lfdir, orphan, tempname) == 0) {
		pfatal("SORRY. NO SPACE IN lost+found DIRECTORY");
		printf("\n\n");
		return (0);
	}
	ILNCOUNT(orphan)--;
	if (lostdir) {
		if ((changeino(orphan, "..", lfdir) & ALTERED) == 0 &&
		    parentdir != (ino_t)-1)
			(void)makeentry(orphan, lfdir, "..");
		dp = ginode(lfdir);
		DIP_SET(dp, di_nlink, DIP(dp, di_nlink) + 1);
		inodirty();
		ILNCOUNT(lfdir)++;
		pwarn("DIR I=%llu CONNECTED. ",
		    (unsigned long long)orphan);
		if (parentdir != (ino_t)-1) {
			printf("PARENT WAS I=%llu\n",
			    (unsigned long long)parentdir);
			/*
			 * The parent directory, because of the ordering
			 * guarantees, has had the link count incremented
			 * for the child, but no entry was made.  This
			 * fixes the parent link count so that fsck does
			 * not need to be rerun.
			 */
			ILNCOUNT(parentdir)++;
		}
		if (preen == 0)
			printf("\n");
	}
	return (1);
}

/*
 * fix an entry in a directory.
 */
int
changeino(dir, name, newnum)
	ino_t dir;
	char *name;
	ino_t newnum;
{
	struct inodesc idesc;

	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = DATA;
	idesc.id_func = chgino;
	idesc.id_number = dir;
	idesc.id_fix = DONTKNOW;
	idesc.id_name = name;
	idesc.id_parent = newnum;	/* new value for name */
	return (ckinode(ginode(dir), &idesc));
}

/*
 * make an entry in a directory
 */
int
makeentry(ino_t parent, ino_t ino, char *name)
{
	union dinode *dp;
	struct inodesc idesc;
	char pathbuf[PATH_MAX + 1];

	if (parent < ROOTINO || parent >= maxino ||
	    ino < ROOTINO || ino >= maxino)
		return (0);
	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = DATA;
	idesc.id_func = mkentry;
	idesc.id_number = parent;
	idesc.id_parent = ino;	/* this is the inode to enter */
	idesc.id_fix = DONTKNOW;
	idesc.id_name = name;
	dp = ginode(parent);
	if (DIP(dp, di_size) % DIRBLKSIZ) {
		DIP_SET(dp, di_size, roundup(DIP(dp, di_size), DIRBLKSIZ));
		inodirty();
	}
	if ((ckinode(dp, &idesc) & ALTERED) != 0)
		return (1);
	getpathname(pathbuf, sizeof pathbuf, parent, parent);
	dp = ginode(parent);
	if (expanddir(dp, pathbuf) == 0)
		return (0);
	return (ckinode(dp, &idesc) & ALTERED);
}

/*
 * Attempt to expand the size of a directory
 */
static int
expanddir(union dinode *dp, char *name)
{
	daddr_t lastbn, newblk;
	struct bufarea *bp;
	char *cp, firstblk[DIRBLKSIZ];
	u_int64_t dis;

	dis = lblkno(&sblock, DIP(dp, di_size));
	if (dis > (u_int64_t)INT_MAX)
		return (0);
	lastbn = dis;
	if (lastbn >= NDADDR - 1 || DIP(dp, di_db[lastbn]) == 0 ||
	    DIP(dp, di_size) == 0)
		return (0);
	if ((newblk = allocblk(sblock.fs_frag)) == 0)
		return (0);
	DIP_SET(dp, di_db[lastbn + 1], DIP(dp, di_db[lastbn]));
	DIP_SET(dp, di_db[lastbn], newblk);
	DIP_SET(dp, di_size, DIP(dp, di_size) + sblock.fs_bsize);
	DIP_SET(dp, di_blocks, DIP(dp, di_blocks) + btodb(sblock.fs_bsize));
	bp = getdirblk(DIP(dp, di_db[lastbn + 1]),
	    sblksize(&sblock, DIP(dp, di_size), lastbn + 1));
	if (bp->b_errs)
		goto bad;
	memcpy(firstblk, bp->b_un.b_buf, DIRBLKSIZ);
	bp = getdirblk(newblk, sblock.fs_bsize);
	if (bp->b_errs)
		goto bad;
	memcpy(bp->b_un.b_buf, firstblk, DIRBLKSIZ);
	for (cp = &bp->b_un.b_buf[DIRBLKSIZ];
	     cp < &bp->b_un.b_buf[sblock.fs_bsize];
	     cp += DIRBLKSIZ)
		memcpy(cp, &emptydir, sizeof emptydir);
	dirty(bp);
	bp = getdirblk(DIP(dp, di_db[lastbn + 1]),
	    sblksize(&sblock, DIP(dp, di_size), lastbn + 1));
	if (bp->b_errs)
		goto bad;
	memcpy(bp->b_un.b_buf, &emptydir, sizeof emptydir);
	pwarn("NO SPACE LEFT IN %s", name);
	if (preen)
		printf(" (EXPANDED)\n");
	else if (reply("EXPAND") == 0)
		goto bad;
	dirty(bp);
	inodirty();
	return (1);
bad:
	DIP_SET(dp, di_db[lastbn], DIP(dp, di_db[lastbn + 1]));
	DIP_SET(dp, di_db[lastbn + 1], 0);
	DIP_SET(dp, di_size, DIP(dp, di_size) - sblock.fs_bsize);
	DIP_SET(dp, di_blocks, DIP(dp, di_blocks) - btodb(sblock.fs_bsize));
	freeblk(newblk, sblock.fs_frag);
	return (0);
}

/*
 * allocate a new directory
 */
ino_t
allocdir(ino_t parent, ino_t request, int mode)
{
	ino_t ino;
	uid_t uid;
	gid_t gid;
	char *cp;
	union dinode *dp;
	struct bufarea *bp;
	struct dirtemplate *dirp;
	struct inoinfo *inp;

	ino = allocino(request, IFDIR|mode);
	dirp = &dirhead;
	dirp->dot_ino = ino;
	dirp->dotdot_ino = parent;
	dp = ginode(ino);
	bp = getdirblk(DIP(dp, di_db[0]), sblock.fs_fsize);
	if (bp->b_errs) {
		freeino(ino);
		return (0);
	}
	memcpy(bp->b_un.b_buf, dirp, sizeof(struct dirtemplate));
	for (cp = &bp->b_un.b_buf[DIRBLKSIZ];
	     cp < &bp->b_un.b_buf[sblock.fs_fsize];
	     cp += DIRBLKSIZ)
		memcpy(cp, &emptydir, sizeof emptydir);
	dirty(bp);
	DIP_SET(dp, di_nlink, 2);
	inodirty();
	if (ino == ROOTINO) {
		ILNCOUNT(ino) = DIP(dp, di_nlink);
		cacheino(dp, ino);
		return(ino);
	}
	if (GET_ISTATE(parent) != DSTATE && GET_ISTATE(parent) != DFOUND) {
		freeino(ino);
		return (0);
	}
	cacheino(dp, ino);
	inp = getinoinfo(ino);
	inp->i_parent = parent;
	inp->i_dotdot = parent;
	SET_ISTATE(ino, GET_ISTATE(parent));
	if (GET_ISTATE(ino) == DSTATE) {
		ILNCOUNT(ino) = DIP(dp, di_nlink);
		ILNCOUNT(parent)++;
	}
	dp = ginode(parent);
	DIP_SET(dp, di_nlink, DIP(dp, di_nlink) + 1);
	uid = DIP(dp, di_uid);
	gid = DIP(dp, di_gid);
	inodirty();
	dp = ginode(ino);
	DIP_SET(dp, di_uid, uid);
	DIP_SET(dp, di_gid, gid);
	inodirty();
	return (ino);
}

/*
 * free a directory inode
 */
static void
freedir(ino_t ino, ino_t parent)
{
	union dinode *dp;

	if (ino != parent) {
		dp = ginode(parent);
		DIP_SET(dp, di_nlink, DIP(dp, di_nlink) - 1);
		inodirty();
	}
	freeino(ino);
}

/*
 * generate a temporary name for the lost+found directory.
 */
static int
lftempname(char *bufp, ino_t ino)
{
	ino_t in;
	char *cp;
	int namlen;

	cp = bufp + 2;
	for (in = maxino; in > 0; in /= 10)
		cp++;
	*--cp = 0;
	namlen = cp - bufp;
	in = ino;
	while (cp > bufp) {
		*--cp = (in % 10) + '0';
		in /= 10;
	}
	*cp = '#';
	return (namlen);
}

/*
 * Get a directory block.
 * Insure that it is held until another is requested.
 */
static struct bufarea *
getdirblk(daddr_t blkno, long size)
{

	if (pdirbp != 0)
		pdirbp->b_flags &= ~B_INUSE;
	pdirbp = getdatablk(blkno, size);
	return (pdirbp);
}
@


1.31
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.30 2014/09/06 04:05:40 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE roundup btodb */
@


1.30
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.29 2013/06/11 16:42:04 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d42 1
d238 1
a238 1
	char pathbuf[MAXPATHLEN + 1];
d467 1
a467 1
	char pathbuf[MAXPATHLEN + 1];
@


1.29
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.28 2013/04/24 13:46:29 deraadt Exp $	*/
d555 1
a555 1
int
@


1.28
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.27 2011/05/08 14:38:40 otto Exp $	*/
d62 1
a62 1
static struct bufarea *getdirblk(daddr64_t, long);
d498 1
a498 1
	daddr64_t lastbn, newblk;
d660 1
a660 1
getdirblk(daddr64_t blkno, long size)
@


1.27
log
@Small memory optimization from NetBSD; ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.26 2011/04/24 07:07:03 otto Exp $	*/
d417 2
a418 1
		pwarn("DIR I=%u CONNECTED. ", orphan);
d420 2
a421 1
			printf("PARENT WAS I=%u\n", parentdir);
@


1.26
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.25 2011/04/16 16:37:21 otto Exp $	*/
d88 1
a88 1
			inp = inp->i_parentp;
@


1.25
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.24 2009/10/27 23:59:32 deraadt Exp $	*/
a117 10
#		if (BYTE_ORDER == LITTLE_ENDIAN)
			if (!newinofmt) {
				struct direct *tdp = (struct direct *)dbuf;
				u_char tmp;

				tmp = tdp->d_namlen;
				tdp->d_namlen = tdp->d_type;
				tdp->d_type = tmp;
			}
#		endif
a119 11
#			if (BYTE_ORDER == LITTLE_ENDIAN)
				if (!newinofmt && !doinglevel2) {
					struct direct *tdp;
					u_char tmp;

					tdp = (struct direct *)dbuf;
					tmp = tdp->d_namlen;
					tdp->d_namlen = tdp->d_type;
					tdp->d_type = tmp;
				}
#			endif
d212 3
a214 13
	size = DIRSIZ(!newinofmt, dp);
#	if (BYTE_ORDER == LITTLE_ENDIAN)
		if (!newinofmt) {
			type = dp->d_namlen;
			namlen = dp->d_type;
		} else {
			namlen = dp->d_namlen;
			type = dp->d_type;
		}
#	else
		namlen = dp->d_namlen;
		type = dp->d_type;
#	endif
d306 1
a306 4
	if (newinofmt)
		dirp->d_type = GET_ITYPE(idesc->id_parent);
	else
		dirp->d_type = 0;
a308 15
#	if (BYTE_ORDER == LITTLE_ENDIAN)
		/*
		 * If the entry was split, dirscan() will only reverse the byte
		 * order of the original entry, and not the new one, before
		 * writing it back out.  So, we reverse the byte order here if
		 * necessary.
		 */
		if (oldlen != 0 && !newinofmt && !doinglevel2) {
			u_char tmp;

			tmp = dirp->d_namlen;
			dirp->d_namlen = dirp->d_type;
			dirp->d_type = tmp;
		}
#	endif
d320 1
a320 4
	if (newinofmt)
		dirp->d_type = GET_ITYPE(idesc->id_parent);
	else
		dirp->d_type = 0;
d566 1
a566 4
	if (newinofmt)
		dirp = &dirhead;
	else
		dirp = (struct dirtemplate *)&odirhead;
@


1.24
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.23 2008/06/10 23:10:29 otto Exp $	*/
d446 2
a447 2
		adjust(&idesc, lncntp[oldlfdir] + 1);
		lncntp[oldlfdir] = 0;
d460 1
a460 1
	lncntp[orphan]--;
d468 1
a468 1
		lncntp[lfdir]++;
d479 1
a479 1
			lncntp[parentdir]++;
d639 1
a639 1
		lncntp[ino] = DIP(dp, di_nlink);
d653 2
a654 2
		lncntp[ino] = DIP(dp, di_nlink);
		lncntp[parent]++;
@


1.23
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.22 2007/09/16 17:42:40 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dir.c	8.5 (Berkeley) 12/8/94";
#else
static const char rcsid[] = "$OpenBSD: dir.c,v 1.22 2007/09/16 17:42:40 otto Exp $";
#endif
#endif /* not lint */
@


1.22
log
@Do not use DIP() as an lvalue; founc by pcc. ok millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.21 2007/06/25 19:59:55 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.21 2007/06/25 19:59:55 otto Exp $";
d85 1
a85 1
	state = statemap[inp->i_number];
d87 1
a87 1
		statemap[inp->i_number] = state;
d89 1
a89 1
		    statemap[inp->i_child->i_number] != state)
d346 1
a346 1
		dirp->d_type = typemap[idesc->id_parent];
d378 1
a378 1
		dirp->d_type = typemap[idesc->id_parent];
d458 1
a458 1
	if (statemap[lfdir] != DFOUND) {
d651 1
a651 1
	if (statemap[parent] != DSTATE && statemap[parent] != DFOUND) {
d659 2
a660 2
	statemap[ino] = statemap[parent];
	if (statemap[ino] == DSTATE) {
@


1.21
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.20 2007/04/10 16:08:17 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.20 2007/04/10 16:08:17 millert Exp $";
d319 1
a319 1
			DIP(dp, di_nlink) -= lcnt;
@


1.20
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.19 2007/02/08 13:09:53 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.19 2007/02/08 13:09:53 otto Exp $";
d70 1
a70 1
static struct bufarea *getdirblk(daddr_t, long);
d556 1
a556 1
	daddr_t lastbn, newblk;
d721 1
a721 1
getdirblk(daddr_t blkno, long size)
@


1.19
log
@A corrrup inode might lead to preposterous dir sizes. So check the
size to avoid a negative lastbn which might cause a segv or heap
corruption. With help from mickey@@; ok mickey@@ pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.18 2007/01/24 13:24:58 bluhm Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.18 2007/01/24 13:24:58 bluhm Exp $";
d67 1
a67 1
static int expanddir(struct ufs1_dinode *, char *);
d275 1
a275 1
	struct ufs1_dinode *dp;
d289 2
a290 1
		    (dp->di_mode & IFMT) == IFDIR ? "DIR" : "FILE", pathbuf);
d298 1
a298 1
	struct ufs1_dinode *dp;
d301 1
a301 1
	if (dp->di_nlink == lcnt) {
d306 1
a306 1
			((dp->di_mode & IFMT) == IFDIR ? "DIR" : "FILE"));
d308 2
a309 2
		printf(" COUNT %d SHOULD BE %d",
			dp->di_nlink, dp->di_nlink - lcnt);
d319 1
a319 1
			dp->di_nlink -= lcnt;
d387 1
a387 1
	struct ufs1_dinode *dp;
d395 1
a395 1
	lostdir = (dp->di_mode & IFMT) == IFDIR;
d398 1
a398 1
	if ((preen || usedsoftdep) && dp->di_size == 0)
d437 1
a437 1
	if ((dp->di_mode & IFMT) != IFDIR) {
d474 1
a474 1
		dp->di_nlink++;
d522 1
a522 1
	struct ufs1_dinode *dp;
d537 2
a538 2
	if (dp->di_size % DIRBLKSIZ) {
		dp->di_size = roundup(dp->di_size, DIRBLKSIZ);
d554 1
a554 1
expanddir(struct ufs1_dinode *dp, char *name)
d561 1
a561 1
	dis = lblkno(&sblock, dp->di_size);
d565 2
a566 1
	if (lastbn >= NDADDR - 1 || dp->di_db[lastbn] == 0 || dp->di_size == 0)
d570 6
a575 6
	dp->di_db[lastbn + 1] = dp->di_db[lastbn];
	dp->di_db[lastbn] = newblk;
	dp->di_size += sblock.fs_bsize;
	dp->di_blocks += btodb(sblock.fs_bsize);
	bp = getdirblk(dp->di_db[lastbn + 1],
		(long)dblksize(&sblock, dp, lastbn + 1));
d588 2
a589 2
	bp = getdirblk(dp->di_db[lastbn + 1],
		(long)dblksize(&sblock, dp, lastbn + 1));
d602 4
a605 4
	dp->di_db[lastbn] = dp->di_db[lastbn + 1];
	dp->di_db[lastbn + 1] = 0;
	dp->di_size -= sblock.fs_bsize;
	dp->di_blocks -= btodb(sblock.fs_bsize);
d620 1
a620 1
	struct ufs1_dinode *dp;
d633 1
a633 1
	bp = getdirblk(dp->di_db[0], sblock.fs_fsize);
d644 1
a644 1
	dp->di_nlink = 2;
d647 1
a647 1
		lncntp[ino] = dp->di_nlink;
d661 1
a661 1
		lncntp[ino] = dp->di_nlink;
d665 3
a667 3
	dp->di_nlink++;
	uid = dp->di_uid;
	gid = dp->di_gid;
d670 2
a671 2
	dp->di_uid = uid;
	dp->di_gid = gid;
d682 1
a682 1
	struct ufs1_dinode *dp;
d686 1
a686 1
		dp->di_nlink--;
@


1.18
log
@A reallocated root directory gets ownership of the fsck process.
If lost+found is created, it gets ownership of the root directory.

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.17 2004/07/05 02:31:54 pvalchev Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.17 2004/07/05 02:31:54 pvalchev Exp $";
d558 1
d560 4
a563 1
	lastbn = lblkno(&sblock, dp->di_size);
@


1.17
log
@remove useless (always false) check; ok millert henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.16 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.16 2003/08/25 23:28:15 tedu Exp $";
d611 2
d660 6
@


1.16
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.15 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.15 2003/06/02 20:06:15 millert Exp $";
a255 1
	    namlen > MAXNAMLEN ||
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.14 2003/04/26 00:39:28 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.14 2003/04/26 00:39:28 deraadt Exp $";
d67 1
a67 1
static int expanddir(struct dinode *, char *);
d276 1
a276 1
	struct dinode *dp;
d298 1
a298 1
	struct dinode *dp;
d387 1
a387 1
	struct dinode *dp;
d522 1
a522 1
	struct dinode *dp;
d554 1
a554 1
expanddir(struct dinode *dp, char *name)
d613 1
a613 1
	struct dinode *dp;
d669 1
a669 1
	struct dinode *dp;
@


1.14
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.13 2002/08/23 09:09:04 gluk Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.13 2002/08/23 09:09:04 gluk Exp $";
@


1.13
log
@- Convert function definitions to new style
- eliminate trailing whitespace
- remove casts that aren't needed.
- make rcsid strings const, for -Wall compilation.

 from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.12 2002/06/09 08:13:05 todd Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: dir.c,v 1.12 2002/06/09 08:13:05 todd Exp $";
d286 1
a286 1
	getpathname(pathbuf, cwd, ino);
d547 1
a547 1
	getpathname(pathbuf, parent, parent);
@


1.12
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.11 2002/02/16 21:27:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.11 2002/02/16 21:27:34 millert Exp $";
d83 1
a83 2
propagate(inumber)
	ino_t	inumber;
d108 1
a108 2
dirscan(idesc)
	struct inodesc *idesc;
d169 1
a169 2
fsck_readdir(idesc)
	struct inodesc *idesc;
d230 1
a230 3
dircheck(idesc, dp)
	struct inodesc *idesc;
	struct direct *dp;
d272 1
a272 3
direrror(ino, errmesg)
	ino_t ino;
	char *errmesg;
a273 1

d278 1
a278 3
fileerror(cwd, ino, errmesg)
	ino_t cwd, ino;
	char *errmesg;
d300 1
a300 3
adjust(idesc, lcnt)
	struct inodesc *idesc;
	short lcnt;
d306 1
a306 1
		if (linkup(idesc->id_number, (ino_t)0) == 0)
d330 1
a330 2
mkentry(idesc)
	struct inodesc *idesc;
d374 1
a374 2
chgino(idesc)
	struct inodesc *idesc;
d389 1
a389 3
linkup(orphan, parentdir)
	ino_t orphan;
	ino_t parentdir;
d420 1
a420 1
				lfdir = allocdir(ROOTINO, (ino_t)0, lfmode);
d446 1
a446 1
		if ((lfdir = allocdir(ROOTINO, (ino_t)0, lfmode)) == 0) {
d524 1
a524 3
makeentry(parent, ino, name)
	ino_t parent, ino;
	char *name;
d529 1
a529 1
	
d558 1
a558 3
expanddir(dp, name)
	struct dinode *dp;
	char *name;
d613 1
a613 3
allocdir(parent, request, mode)
	ino_t parent, request;
	int mode;
d671 1
a671 2
freedir(ino, parent)
	ino_t ino, parent;
d687 1
a687 3
lftempname(bufp, ino)
	char *bufp;
	ino_t ino;
d712 1
a712 3
getdirblk(blkno, size)
	daddr_t blkno;
	long size;
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.10 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.10 2001/11/05 07:39:16 mpech Exp $";
d161 1
a161 1
		if (n & STOP) 
@


1.10
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.9 2001/05/28 21:22:47 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.9 2001/05/28 21:22:47 gluk Exp $";
d71 7
a77 7
static int expanddir __P((struct dinode *, char *));
static void freedir __P((ino_t, ino_t));
static struct direct *fsck_readdir __P((struct inodesc *));
static struct bufarea *getdirblk __P((daddr_t, long));
static int lftempname __P((char *, ino_t));
static int mkentry __P((struct inodesc *));
static int chgino __P((struct  inodesc *));
@


1.9
log
@Fix directory state tracking.

- If the lost+found directory is created by fsck, it will do a cacheino()
  which sets the inoinfo's i_parent and i_dotdot to 0, but they never get
  set to ROOTINO. This means that propagate will never find lost+found and
  its descendents, subdirectories will remain DSTATE (instead of DFOUND)
  even though they are correctly linked in, and pass4.c will try to
  clear them unsuccessfully, thinking that there is no link count from the
  DSTATE directory's parent. The result is that you need to run fsck twice
  and get "EXTRANEOUS HARD LINK TO DIRECTORY" error (which are unexpected
  and fatal when running in preen mode). The fix is to set i_parent and
  i_dotdot to "parent" after the second cacheino() call in dir.c:allocdir().
  From NetBSD via FreeBSD.
- modify propagate() so it be able to start from any point in the tree.
- minor tweaks to get more generality in state propagation.

In other words fsck doesn't leave unremovable directories anymore.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d110 1
a110 1
	register struct inodesc *idesc;
d112 2
a113 2
	register struct direct *dp;
	register struct bufarea *bp;
d172 1
a172 1
	register struct inodesc *idesc;
d174 2
a175 2
	register struct direct *dp, *ndp;
	register struct bufarea *bp;
d235 1
a235 1
	register struct direct *dp;
d237 2
a238 2
	register int size;
	register char *cp;
d290 1
a290 1
	register struct dinode *dp;
d311 1
a311 1
	register struct inodesc *idesc;
d314 1
a314 1
	register struct dinode *dp;
d345 1
a345 1
	register struct direct *dirp = idesc->id_dirp;
d390 1
a390 1
	register struct direct *dirp = idesc->id_dirp;
d407 1
a407 1
	register struct dinode *dp;
d577 1
a577 1
	register struct dinode *dp;
d581 1
a581 1
	register struct bufarea *bp;
d640 1
a640 1
	register struct bufarea *bp;
d714 2
a715 2
	register ino_t in;
	register char *cp;
@


1.8
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.7 1997/10/06 20:22:31 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.7 1997/10/06 20:22:31 deraadt Exp $";
d83 2
a84 1
propagate()
d86 2
a87 2
	register struct inoinfo **inpp, *inp, *pinp;
	struct inoinfo **inpend;
d89 4
a92 17
	/*
	 * Create a list of children for each directory.
	 */
	inpend = &inpsort[inplast];
	for (inpp = inpsort; inpp < inpend; inpp++) {
		inp = *inpp;
		if (inp->i_parent == 0 ||
		    inp->i_number == ROOTINO)
			continue;
		pinp = getinoinfo(inp->i_parent);
		inp->i_parentp = pinp;
		inp->i_sibling = pinp->i_child;
		pinp->i_child = inp;
	}
	inp = getinoinfo(ROOTINO);
	while (inp) {
		statemap[inp->i_number] = DFOUND;
d94 1
a94 1
		    statemap[inp->i_child->i_number] == DSTATE)
d96 2
a424 2
	if (parentdir != 0)
		lncntp[parentdir]++;
d642 1
d675 3
@


1.8.2.1
log
@Pull in patch from current:
Fix (gluk):
Fix directory state tracking.

- If the lost+found directory is created by fsck, it will do a cacheino()
  which sets the inoinfo's i_parent and i_dotdot to 0, but they never get
  set to ROOTINO. This means that propagate will never find lost+found and
  its descendents, subdirectories will remain DSTATE (instead of DFOUND)
  even though they are correctly linked in, and pass4.c will try to
  clear them unsuccessfully, thinking that there is no link count from the
  DSTATE directory's parent. The result is that you need to run fsck twice
  and get "EXTRANEOUS HARD LINK TO DIRECTORY" error (which are unexpected
  and fatal when running in preen mode). The fix is to set i_parent and
  i_dotdot to "parent" after the second cacheino() call in dir.c:allocdir().
  From NetBSD via FreeBSD.
- modify propagate() so it be able to start from any point in the tree.
- minor tweaks to get more generality in state propagation.

In other words fsck doesn't leave unremovable directories anymore.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.8 2001/03/02 08:33:55 art Exp $";
d83 1
a83 2
propagate(inumber)
	ino_t	inumber;
d85 2
a86 2
	struct	inoinfo *inp;
	char	state;
d88 17
a104 4
	inp = getinoinfo(inumber);
	state = statemap[inp->i_number];
	for (;;) {
		statemap[inp->i_number] = state;
d106 1
a106 1
		    statemap[inp->i_child->i_number] != state)
a107 2
		else if (inp->i_number == inumber)
			break;
d435 2
a653 1
	struct inoinfo *inp;
a685 3
	inp = getinoinfo(ino);
	inp->i_parent = parent;
	inp->i_dotdot = parent;
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.5 1997/03/27 16:28:51 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.5 1997/03/27 16:28:51 kstailey Exp $";
d336 1
a336 1
		if (preen) {
d341 2
a342 1
			printf(" (ADJUSTED)\n");
d428 1
a428 1
	if (preen && dp->di_size == 0)
d435 2
@


1.6
log
@VFS Lite2 Changes
@
text
@d336 1
a336 1
		if (preen || usedsoftdep) {
d341 1
a341 2
			if (preen)
				printf(" (ADJUSTED)\n");
d427 1
a427 1
	if ((preen || usedsoftdep) && dp->di_size == 0)
a433 2
	if (parentdir != 0)
		lncntp[parentdir]++;
@


1.5
log
@use 700 not 777 for new lost+found dirs
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.4 1997/02/20 06:03:04 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.4 1997/02/20 06:03:04 tholo Exp $";
d336 1
a336 1
		if (preen) {
d341 2
a342 1
			printf(" (ADJUSTED)\n");
d428 1
a428 1
	if (preen && dp->di_size == 0)
d435 2
@


1.4
log
@From FreeBSD [Terry Lambert]:

The following small diff fixes the annoying fsck bug that causes it to
need to be run twice to end up with correct reference counts for inodes
for directories that had subdirectories relocated into the lost+found
directory.

I found the need to rerun *extremely* annoying.  This fix causes the
count to be correctly adjusted later in pass 4 by correctly stating
the parent reference count.

Note that the parent reference count is incremented when the directory
entry is made (for ".."), but is not really there in the case of a
directory that does not make an entry in its parent dir.

This can be tested by waiting for the inode sync after cd'ing from a
shell into a test fs.  Then you "mkdir xxx yyy zzz", wait a second,
and hit the machine reset button.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.3 1996/10/20 08:36:30 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.3 1996/10/20 08:36:30 tholo Exp $";
d60 1
a60 1
int	lfmode = 01777;
@


1.3
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.2 1996/06/23 14:30:26 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.2 1996/06/23 14:30:26 deraadt Exp $";
d507 1
a507 1
		if (parentdir != (ino_t)-1)
d509 9
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.17 1995/03/18 14:55:40 cgd Exp $	*/
/*	$NetBSD: dir.c,v 1.17 1995/03/18 14:55:40 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.17 1995/03/18 14:55:40 cgd Exp $";
d56 1
d71 7
a77 5
int expanddir __P((struct dinode *, char *));
void freedir __P((ino_t, ino_t));
struct direct *fsck_readdir();
struct bufarea *getdirblk();
int lftempname __P((char *, ino_t));
d85 1
a85 1
	register struct inoinfo **inpp, *inp;
a86 1
	long change;
d88 3
d92 21
a112 13
	do {
		change = 0;
		for (inpp = inpsort; inpp < inpend; inpp++) {
			inp = *inpp;
			if (inp->i_parent == 0)
				continue;
			if (statemap[inp->i_parent] == DFOUND &&
			    statemap[inp->i_number] == DSTATE) {
				statemap[inp->i_number] = DFOUND;
				change++;
			}
		}
	} while (change > 0);
d180 1
a180 1
struct direct *
d350 1
a350 1
int
d395 1
a395 1
int
d506 1
a506 1
		pwarn("DIR I=%lu CONNECTED. ", orphan);
d508 1
a508 1
			printf("PARENT WAS I=%lu\n", parentdir);
d575 1
a575 1
int
d688 1
a688 1
void
d705 1
a705 1
int
d732 1
a732 1
struct bufarea *
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: dir.c,v 1.17 1995/03/18 14:55:40 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
