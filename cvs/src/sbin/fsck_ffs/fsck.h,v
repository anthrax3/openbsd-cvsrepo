head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.10
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.8
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.4
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.23.0.12
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.10
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2015.01.19.18.20.47;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	1CWwCgfv5daBoWlX;

1.30
date	2014.09.06.04.05.40;	author guenther;	state Exp;
branches;
next	1.29;
commitid	qlzrzgnJ4ZiiF6XQ;

1.29
date	2014.05.09.13.19.34;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.02.00.08.17;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.08.14.38.40;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.24.07.07.03;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.16.16.37.21;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.10.23.10.29;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.26.11.51.20;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.25.19.59.55;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.01.23.42.35;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.01.06.41.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.10.16.08.17;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.08.19.02.23;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.22.20.24.32;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.12.02.28.28;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.25.04.19.39;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.11.04.42.25;	author david;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.02.08.33.55;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.03.01.07.45.17;	author d;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.22.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.33.33;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.10.20.08.36.32;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.10.12.03.06.53;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@remove #ifndef #define blocks trying to handle lack of BUFSIZ
ok millert
@
text
@/*	$OpenBSD: fsck.h,v 1.30 2014/09/06 04:05:40 guenther Exp $	*/
/*	$NetBSD: fsck.h,v 1.13 1996/10/11 20:15:46 thorpej Exp $	*/

/*
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by Marshall
 * Kirk McKusick and Network Associates Laboratories, the Security
 * Research Division of Network Associates, Inc. under DARPA/SPAWAR
 * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
 * research program.
 *
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fsck.h	8.1 (Berkeley) 6/5/93
 */

#define	MAXDUP		10	/* limit on dup blks (per inode) */
#define	MAXBAD		10	/* limit on bad blks (per inode) */
#define	MAXBUFSPACE	40*1024	/* maximum space to allocate to buffers */
#define	INOBUFSIZE	56*1024	/* size of buffer to read inodes in pass1 */

union dinode {
	struct ufs1_dinode dp1;
	struct ufs2_dinode dp2;
};

#define	DIP(dp, field)				\
	((sblock.fs_magic == FS_UFS1_MAGIC) ?	\
	(dp)->dp1.field : (dp)->dp2.field)

#define	DIP_SET(dp, field, val) do { \
	if (sblock.fs_magic == FS_UFS1_MAGIC)	\
		(dp)->dp1.field = (val);	\
	else					\
		(dp)->dp2.field = (val);	\
	} while (0)

/*
 * Each inode on the file system is described by the following structure.
 * The linkcnt is initially set to the value in the inode. Each time it
 * is found during the descent in passes 2, 3, and 4 the count is
 * decremented. Any inodes whose count is non-zero after pass 4 needs to
 * have its link count adjusted by the value remaining in ino_linkcnt.
 */
struct inostat {
	char    ino_state;      /* state of inode, see below */
	char    ino_type;       /* type of inode */
	short   ino_linkcnt;    /* number of links not found */
};

#define	USTATE	01		/* inode not allocated */
#define	FSTATE	02		/* inode is file */
#define	DSTATE	03		/* inode is directory */
#define	DFOUND	04		/* directory found during descent */
#define	DCLEAR	05		/* directory is to be cleared */
#define	FCLEAR	06		/* file is to be cleared */

/*
 * Inode state information is contained on per cylinder group lists
 * which are described by the following structure.
 */
struct inostatlist {
	long    il_numalloced;  /* number of inodes allocated in this cg */
	struct inostat *il_stat;/* inostat info for this cylinder group */
} *inostathead;

#define GET_ISTATE(ino)		(inoinfo(ino)->ino_state)
#define GET_ITYPE(ino)		(inoinfo(ino)->ino_type)
#define SET_ISTATE(ino, v)	do { GET_ISTATE(ino) = (v); } while (0)
#define SET_ITYPE(ino, v)	do { GET_ITYPE(ino) = (v); } while (0)
#define ILNCOUNT(ino)		(inoinfo(ino)->ino_linkcnt)

/*
 * buffer cache structure.
 */
struct bufarea {
	daddr_t	b_bno;
	struct bufarea	*b_next;		/* free list queue */
	struct bufarea	*b_prev;		/* free list queue */
	int	b_size;
	int	b_errs;
	int	b_flags;
	union {
		char	*b_buf;			/* buffer space */
		int32_t	*b_indir1;		/* FFS1 indirect block */
		int64_t	*b_indir2;		/* FFS2 indirect block */
		struct	fs *b_fs;		/* super block */
		struct	cg *b_cg;		/* cylinder group */
		struct	ufs1_dinode *b_dinode1;	/* FFS1 inode block */
		struct	ufs2_dinode *b_dinode2;	/* FFS2 inode block */
	} b_un;
	char	b_dirty;
};

#define IBLK(bp, i)				\
	((sblock.fs_magic == FS_UFS1_MAGIC) ?	\
	(bp)->b_un.b_indir1[i] : (bp)->b_un.b_indir2[i])

#define IBLK_SET(bp, i, val) do {		\
	if (sblock.fs_magic == FS_UFS1_MAGIC)	\
		(bp)->b_un.b_indir1[i] = (val);	\
	else					\
		(bp)->b_un.b_indir2[i] = (val);	\
	} while (0)

#define	B_INUSE 1

#define	MINBUFS		5	/* minimum number of buffers required */
struct bufarea bufhead;		/* head of list of other blks in filesys */
struct bufarea sblk;		/* file system superblock */
struct bufarea asblk;		/* alternate file system superblock */
struct bufarea cgblk;		/* cylinder group blocks */
struct bufarea *pdirbp;		/* current directory contents */
struct bufarea *pbp;		/* current inode block */
struct bufarea *getdatablk(daddr_t, long);

#define	dirty(bp)	(bp)->b_dirty = 1
#define	initbarea(bp) \
	(bp)->b_dirty = 0; \
	(bp)->b_bno = -1; \
	(bp)->b_flags = 0;

#define	sbdirty()	sblk.b_dirty = 1
#define	cgdirty()	cgblk.b_dirty = 1
#define	sblock		(*sblk.b_un.b_fs)
#define	cgrp		(*cgblk.b_un.b_cg)

enum fixstate {DONTKNOW, NOFIX, FIX, IGNORE};

struct inodesc {
	daddr_t id_blkno;	/* current block number being examined */
	quad_t id_filesize;	/* for DATA nodes, the size of the directory */
	u_int64_t id_entryno;	/* for DATA nodes, current entry number */
	ino_t id_number;	/* inode number described */
	ino_t id_parent;	/* for DATA nodes, their parent */
	int (*id_func)		/* function to be applied to blocks of inode */
(struct inodesc *);
	struct direct *id_dirp;	/* for DATA nodes, ptr to current entry */
	char *id_name;		/* for DATA nodes, name to find or enter */
	int id_numfrags;	/* number of frags contained in block */
	int id_loc;		/* for DATA nodes, current location in dir */
	enum fixstate id_fix;	/* policy on fixing errors */
	char id_type;		/* type of descriptor, DATA or ADDR */
};
/* file types */
#define	DATA	1
#define	ADDR	2

/*
 * Linked list of duplicate blocks.
 *
 * The list is composed of two parts. The first part of the
 * list (from duplist through the node pointed to by muldup)
 * contains a single copy of each duplicate block that has been
 * found. The second part of the list (from muldup to the end)
 * contains duplicate blocks that have been found more than once.
 * To check if a block has been found as a duplicate it is only
 * necessary to search from duplist through muldup. To find the
 * total number of times that a block has been found as a duplicate
 * the entire list must be searched for occurrences of the block
 * in question. The following diagram shows a sample list where
 * w (found twice), x (found once), y (found three times), and z
 * (found once) are duplicate block numbers:
 *
 *    w -> y -> x -> z -> y -> w -> y
 *    ^		     ^
 *    |		     |
 * duplist	  muldup
 */
struct dups {
	struct dups *next;
	daddr_t dup;
};
struct dups *duplist;		/* head of dup list */
struct dups *muldup;		/* end of unique duplicate dup block numbers */

/*
 * Linked list of inodes with zero link counts.
 */
struct zlncnt {
	struct zlncnt *next;
	ino_t zlncnt;
};
struct zlncnt *zlnhead;		/* head of zero link count list */

/*
 * Inode cache data structures.
 */
struct inoinfo {
	struct	inoinfo *i_nexthash;	/* next entry in hash chain */
	struct	inoinfo	*i_child, *i_sibling;
	size_t	i_isize;		/* size of inode */
	ino_t	i_number;		/* inode number of this entry */
	ino_t	i_parent;		/* inode number of parent */
	ino_t	i_dotdot;		/* inode number of `..' */
	u_int	i_numblks;		/* size of block array in bytes */
	daddr_t	i_blks[1];		/* actually longer */
} **inphead, **inpsort;

extern long numdirs, listmax, inplast;

long	secsize;		/* actual disk sector size */
char	nflag;			/* assume a no response */
char	yflag;			/* assume a yes response */
int	bflag;			/* location of alternate super block */
int	debug;			/* output debugging info */
int	cvtlevel;		/* convert to newer file system format */
char    usedsoftdep;            /* just fix soft dependency inconsistencies */
int	preen;			/* just fix normal inconsistencies */
char    resolved;               /* cleared if unresolved changes => not clean */
char	havesb;			/* superblock has been read */
char	skipclean;		/* skip clean file systems if preening */
int	fsmodified;		/* 1 => write done to file system */
int	fsreadfd;		/* file descriptor for reading file system */
int	fswritefd;		/* file descriptor for writing file system */
int	rerun;			/* rerun fsck.  Only used in non-preen mode */

daddr_t	maxfsblock;		/* number of blocks in the file system */
char	*blockmap;		/* ptr to primary blk allocation map */
ino_t	maxino;			/* number of inodes in file system */
ino_t	lastino;		/* last inode in use */

ino_t	lfdir;			/* lost & found directory inode number */
char	*lfname;		/* lost & found directory name */
int	lfmode;			/* lost & found directory creation mode */

daddr_t	n_blks;			/* number of blocks in use */
int64_t	n_files;		/* number of files in use */

#define	clearinode(dp)	\
	if (sblock.fs_magic == FS_UFS1_MAGIC) {	\
		(dp)->dp1 = ufs1_zino;		\
	} else {				\
		(dp)->dp2 = ufs2_zino;		\
	}

struct ufs1_dinode ufs1_zino;
struct ufs2_dinode ufs2_zino;

#define	setbmap(blkno)	setbit(blockmap, blkno)
#define	testbmap(blkno)	isset(blockmap, blkno)
#define	clrbmap(blkno)	clrbit(blockmap, blkno)

#define	STOP	0x01
#define	SKIP	0x02
#define	KEEPON	0x04
#define	ALTERED	0x08
#define	FOUND	0x10

union dinode *ginode(ino_t);
struct inoinfo *getinoinfo(ino_t);
void getblk(struct bufarea *, daddr_t, long);
ino_t allocino(ino_t, int);

int	(*info_fn)(char *, size_t);
char	*info_filesys;
@


1.30
log
@inodesc.id_entryno holds a file size, so upgrade it from int to u_int64_t;
  this fixes handling of very large files on FFS2.
Correct a copy-n-pasto that rendered useless the check for allocated
  fragmented that are marked free in the bitmap.
allocdir() returns an inode number, so return an ino_t.
sizeof()*N should be printed with %zu, while direct and indirect block
  numbers should be cast to (long long) use %lld

inodesc.id_entryno fix based on a diff from David Vasek <vasek@@fido.cz>
ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.29 2014/05/09 13:19:34 krw Exp $	*/
a63 4

#ifndef BUFSIZ
#define BUFSIZ 1024
#endif
@


1.29
log
@Fix '-b' option to work with the superblock locations output by newfs
on 4096-byte sector disks. No-op on 512-byte sector disks.

Adhering to the bedrock idea that ffs will *never* use anything but
512-byte block disk addressing (a.k.a. daddr_t), and believing that
the 'fake' bread()/bwrite() functions should always be using 512-btye
block numbers like their kernel big brothers, nuke the computed
dev_bsize and use DEV_BSIZE for conversions to/from byte offsets.

Spotted and various fixes tested by David Vasek.

Still to fix: scanning for superblocks on 4K disks.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.28 2013/11/02 00:08:17 krw Exp $	*/
d164 3
a170 3
	ino_t id_number;	/* inode number described */
	ino_t id_parent;	/* for DATA nodes, their parent */
	enum fixstate id_fix;	/* policy on fixing errors */
d173 1
a173 1
	int id_entryno;		/* for DATA nodes, current entry number */
@


1.28
log
@No need to cast constants or simple variables to (daddr_t). Use
(u_int64_t) instead of (daddr_t) when casting a variable in an
expression passed to DL_SETDSIZE().

Change a variable counting open files from daddr_t to int64_t.

ok deraadt@@ with the tweak to fix that pesky expression.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.27 2013/06/11 16:42:04 deraadt Exp $	*/
a232 1
long	dev_bsize;		/* computed value of DEV_BSIZE */
@


1.27
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.26 2011/05/08 14:38:40 otto Exp $	*/
d151 1
a151 1
	(bp)->b_bno = (daddr_t)-1; \
d260 1
a260 1
daddr_t	n_files;		/* number of files in use */
@


1.26
log
@Small memory optimization from NetBSD; ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.25 2011/04/24 07:07:03 otto Exp $	*/
d108 1
a108 1
	daddr64_t	b_bno;
d146 1
a146 1
struct bufarea *getdatablk(daddr64_t, long);
d151 1
a151 1
	(bp)->b_bno = (daddr64_t)-1; \
d162 1
a162 1
	daddr64_t id_blkno;	/* current block number being examined */
d203 1
a203 1
	daddr64_t dup;
d228 1
a228 1
	daddr64_t	i_blks[1];		/* actually longer */
d250 1
a250 1
daddr64_t	maxfsblock;		/* number of blocks in the file system */
d259 2
a260 2
daddr64_t	n_blks;			/* number of blocks in use */
daddr64_t	n_files;		/* number of files in use */
d284 1
a284 1
void getblk(struct bufarea *, daddr64_t, long);
@


1.25
log
@remove support for (very) old ffs on-disk formats; ok krw@@ and no
objection form the usual suspects
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.24 2011/04/16 16:37:21 otto Exp $	*/
d222 1
a222 1
	struct	inoinfo	*i_child, *i_sibling, *i_parentp;
@


1.24
log
@Blend in some code from netbsd and freebsd that reduces memory consumption
and speeds things up in a lot of cases.
Prompted by Amit Kulkarni; ok krw@@ on a slighly diffrenent incarnation
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.23 2008/06/10 23:10:29 otto Exp $	*/
a239 3
int	doinglevel1;		/* converting to new cylinder group format */
int	doinglevel2;		/* converting to new inode format */
int	newinofmt;		/* filesystem has new inode format */
@


1.23
log
@reduce mem usage by about 20% by packing state and type of an inode in a single
byte. Original diff by drahn@@; twists by me; ok millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.22 2008/05/26 11:51:20 otto Exp $	*/
d69 13
d89 14
a102 6
#define GET_ISTATE(ino)		(stmap[(ino)] & 0xf)
#define GET_ITYPE(ino)		(stmap[(ino)] >> 4)
#define SET_ISTATE(ino, v)	do { stmap[(ino)] = (stmap[(ino)] & 0xf0) | \
				    ((v) & 0xf); } while (0)
#define SET_ITYPE(ino, v)	do { stmap[(ino)] = (stmap[(ino)] & 0x0f) | \
				    ((v) << 4); } while (0)
a256 2
u_char	*stmap;			/* ptr to inode state and type table */
int16_t	*lncntp;		/* ptr to link count table */
a263 1
long   *cginosused;		/* # of allocated inodes in each cg */
@


1.22
log
@reorg fields in structs inodesc and inoinfo to reduce size on some archs; from
mickey; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.21 2007/06/25 19:59:55 otto Exp $	*/
d76 7
d236 1
a236 2
char	*statemap;		/* ptr to inode state table */
char	*typemap;		/* ptr to inode type table */
@


1.21
log
@Teach fsck_ffs about 64-bit block addresses. ok (and help) moritz@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.20 2007/06/01 23:42:35 pedro Exp $	*/
d80 1
a82 1
	daddr64_t	b_bno;
d134 2
a135 1
	enum fixstate id_fix;	/* policy on fixing errors */
d138 2
d142 1
a142 1
	daddr64_t id_blkno;	/* current block number being examined */
a143 1
	quad_t id_filesize;	/* for DATA nodes, the size of the directory */
a145 2
	struct direct *id_dirp;	/* for DATA nodes, ptr to current entry */
	char *id_name;		/* for DATA nodes, name to find or enter */
d195 1
a198 1
	size_t	i_isize;		/* size of inode */
@


1.20
log
@ufs1_daddr_t cleanup, okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.19 2007/06/01 06:41:33 deraadt Exp $	*/
d82 1
a82 1
	daddr_t	b_bno;
d118 1
a118 1
struct bufarea *getdatablk(daddr_t, long);
d123 1
a123 1
	(bp)->b_bno = (daddr_t)-1; \
d139 1
a139 1
	daddr_t id_blkno;	/* current block number being examined */
d175 1
a175 1
	daddr_t dup;
d200 1
a200 1
	daddr_t	i_blks[1];		/* actually longer */
d225 1
a225 1
daddr_t	maxfsblock;		/* number of blocks in the file system */
d237 2
a238 2
daddr_t	n_blks;			/* number of blocks in use */
daddr_t	n_files;		/* number of files in use */
d263 1
a263 1
void getblk(struct bufarea *, daddr_t, long);
@


1.19
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.18 2007/04/10 16:08:17 millert Exp $	*/
d88 2
a89 2
		ufs1_daddr_t	*b_indir1;	/* FFS1 indirect block */
		daddr64_t	*b_indir2;	/* FFS2 indirect block */
@


1.18
log
@Add support for checking ffs2 filesystems.  From pedro@@ based on
the ufs2 changes in FreeBSD by Kirk Mckusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.17 2007/02/08 19:02:23 otto Exp $	*/
d89 1
a89 1
		ufs2_daddr_t	*b_indir2;	/* FFS2 indirect block */
@


1.17
log
@Plug some mem leaks that occur when checking multiple file systems in a
row. ok beck@@ pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.16 2006/03/22 20:24:32 deraadt Exp $	*/
d5 9
d49 16
d88 2
a89 1
		daddr_t	*b_indir;		/* indirect block */
d92 2
a93 1
		struct	ufs1_dinode *b_dinode;	/* inode block */
d98 11
d239 8
d248 2
a249 2
#define	clearinode(dp)	(*(dp) = zino)
struct	ufs1_dinode zino;
d261 1
a261 1
struct ufs1_dinode *ginode(ino_t);
@


1.16
log
@earlier asprintf diff caused malloc in signal handler.  clarify the
code a bit more so that this mistake will not be done again
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.14 2003/09/25 04:19:39 deraadt Exp $	*/
d76 1
@


1.15
log
@use asprintf instead of a static buffer; dhill, tested by pedro
@
text
@d219 1
a219 1
int	(*info_fn)(char *);
@


1.14
log
@whack commons as wanted by ho
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.13 2003/08/25 23:28:15 tedu Exp $	*/
d219 1
a219 1
int	(*info_fn)(char *, int);
@


1.13
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.12 2003/06/02 20:06:15 millert Exp $	*/
d163 2
a164 1
long numdirs, listmax, inplast;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.11 2003/03/11 04:42:25 david Exp $	*/
d66 1
a66 1
		struct	dinode *b_dinode;	/* inode block */
d201 1
a201 1
struct	dinode zino;
d213 1
a213 1
struct dinode *ginode(ino_t);
@


1.11
log
@spelling
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.10 2002/06/09 08:13:05 todd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.9 2002/02/16 21:27:34 millert Exp $	*/
d128 1
a128 1
 * the entire list must be searched for occurences of the block
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.8 2001/03/02 08:33:55 art Exp $	*/
d119 1
a119 1
 * 
d122 1
a122 1
 * contains a single copy of each duplicate block that has been 
d126 1
a126 1
 * necessary to search from duplist through muldup. To find the 
@


1.8
log
@Make fsck aware of soft updates.
We had this in the tree 1997, but it went away because it was too close to
release.
Ok: csapuntz@@
(as a size note: It's really good to test fsck when you are torture testing
the filesystems)
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.7 1999/03/01 07:45:17 d Exp $	*/
d83 1
a83 1
struct bufarea *getdatablk __P((daddr_t, long));
d101 1
a101 1
	    __P((struct inodesc *));
d217 4
a220 4
struct dinode *ginode __P((ino_t));
struct inoinfo *getinoinfo __P((ino_t));
void getblk __P((struct bufarea *, daddr_t, long));
ino_t allocino __P((ino_t, int));
@


1.7
log
@SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.6 1997/10/06 20:22:32 deraadt Exp $	*/
d179 1
d181 1
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.4 1996/10/20 08:36:32 tholo Exp $	*/
d219 3
@


1.5
log
@VFS Lite2 Changes
@
text
@a178 1
char    usedsoftdep;            /* just fix soft dependency inconsistencies */
a179 1
char    resolved;               /* cleared if unresolved changes => not clean */
@


1.4
log
@Sync with NetBSD 961019
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.3 1996/10/12 03:06:53 tholo Exp $	*/
d179 1
d181 1
@


1.3
log
@From Kirk McKusick:
  If a directory somehow develops a hole (that is a block pointer
  that has a value of zero), fsck would give the filesystem a clean
  bill of health, but the kernel would panic when accessing the
  directory with the hole. Fsck now checks for holes in directories.
  If found in preen mode, fsck fails. In manual mode, it can be
  directed to shorten the directory to the beginning of the hole. A
  more complete solution would be to allocate a block to fill the
  hole. However, this is a lot more work for a `cannot happen' error,
  so the extra effort seems unwarranted.
@
text
@d1 2
a2 2
/*	$OpenBSD: fsck.h,v 1.2 1996/06/23 14:30:28 deraadt Exp $	*/
/*	$NetBSD: fsck.h,v 1.10 1995/04/12 21:24:09 mycroft Exp $	*/
d83 1
a83 1
struct bufarea *getdatablk();
d100 2
a101 1
	int (*id_func)();	/* function to be applied to blocks of inode */
d159 1
a168 1
char	*cdevname;		/* name of device being checked */
d179 1
a179 2
char	preen;			/* just fix normal inconsistencies */
char	hotroot;		/* checking root device */
d185 1
a185 1
int	rerun;			/* rerun fsck. Only used in non-preen mode */
d215 4
a218 5
time_t time();
struct dinode *ginode();
struct inoinfo *getinoinfo();
void getblk();
ino_t allocino();
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.10 1995/04/12 21:24:09 mycroft Exp $	*/
d185 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
