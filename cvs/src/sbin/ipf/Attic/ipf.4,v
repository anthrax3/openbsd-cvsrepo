head	1.23;
access;
symbols
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.21.0.4
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@# @;


1.23
date	2001.05.30.02.11.38;	author deraadt;	state dead;
branches;
next	1.22;

1.22
date	2001.01.30.04.26.01;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.13.19.59.39;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.16.00.36.38;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.19.21.46.45;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.24.07.25.37;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.07.07.45.03;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	99.11.23.22.27.31;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.10.12.05.05.00;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	99.09.23.04.12.02;	author alex;	state Exp;
branches;
next	1.13;

1.13
date	98.09.15.09.55.44;	author pattonme;	state Exp;
branches;
next	1.12;

1.12
date	98.09.01.16.38.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.08.29.21.12.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.07.20.07.18.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.01.26.04.13.33;	author dgregor;	state Exp;
branches;
next	1.8;

1.8
date	97.04.09.11.44.26;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.09.11.42.16;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.09.11.39.51;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.11.22.23.36;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.18.05.11.00;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.21.39.51;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.33.31;	author dm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@.\"	$OpenBSD: ipf.4,v 1.22 2001/01/30 04:26:01 kjell Exp $
.\"
.TH IPF 4
.SH NAME
ipf \- packet filtering kernel interface
.SH SYNOPSIS
#include <netinet/ip_compat.h>
.br
#include <netinet/ip_fil.h>
.SH IOCTLS
.PP
To add and delete rules to the filter list, three 'basic' ioctls are provided
for use.  The ioctl's are called as:
.LP
.nf
	ioctl(fd, SIOCADDFR, struct frentry **)
	ioctl(fd, SIOCDELFR, struct frentry **)
	ioctl(fd, SIOCIPFFL, int *)
.fi
.PP
However, the full complement is as follows:
.LP
.nf
	ioctl(fd, SIOCADAFR, struct frentry **) (same as SIOCADDFR)
	ioctl(fd, SIOCRMAFR, struct frentry **) (same as SIOCDELFR)
	ioctl(fd, SIOCADIFR, struct frentry **)
	ioctl(fd, SIOCRMIFR, struct frentry **)
	ioctl(fd, SIOCINAFR, struct frentry **)
	ioctl(fd, SIOCINIFR, struct frentry **)
	ioctl(fd, SIOCSETFF, u_int *)
	ioctl(fd, SIOGGETFF, u_int *)
	ioctl(fd, SIOCGETFS, struct friostat **)
	ioctl(fd, SIOCIPFFL, int *)
	ioctl(fd, SIOCIPFFB, int *)
	ioctl(fd, SIOCSWAPA, u_int *)
	ioctl(fd, SIOCFRENB, u_int *)
	ioctl(fd, SIOCFRSYN, u_int *)
	ioctl(fd, SIOCFRZST, struct friostat **)
	ioctl(fd, SIOCZRLST, struct frentry **)
	ioctl(fd, SIOCAUTHW, struct fr_info **)
	ioctl(fd, SIOCAUTHR, struct fr_info **)
	ioctl(fd, SIOCATHST, struct fr_authstat **)
.fi
.PP
The variations, SIOCADAFR vs. SIOCADIFR, allow operation on the two lists,
active and inactive, respectively.  All of these ioctl's are implemented
as being routing ioctls and thus the same rules for the various routing
ioctls and the file descriptor are employed, mainly being that the fd must
be that of the device associated with the module (i.e., /dev/ipl).
.LP
.PP
The three groups of ioctls above perform adding rules to the end of the
list (SIOCAD*), deletion of rules from any place in the list (SIOCRM*)
and insertion of a rule into the list (SIOCIN*).  The rule place into
which it is inserted is stored in the "fr_hits" field, below.
.LP
.nf
typedef struct  frentry {
        struct  frentry *fr_next;
        u_short fr_group;       /* group to which this rule belongs */
        u_short fr_grhead;      /* group # which this rule starts */
        struct  frentry *fr_grp;
        int     fr_ref;         /* reference count - for grouping */
        void    *fr_ifa;
#if BSD >= 199306
        void    *fr_oifa;
#endif
        /*
         * These are only incremented when a packet  matches this rule and
         * it is the last match
         */
        U_QUAD_T        fr_hits;
        U_QUAD_T        fr_bytes;
        /*
         * Fields after this may not change whilst in the kernel.
         */
        struct  fr_ip   fr_ip;
        struct  fr_ip   fr_mip; /* mask structure */

        u_char  fr_tcpfm;       /* tcp flags mask */
        u_char  fr_tcpf;        /* tcp flags */

        u_short fr_icmpm;       /* data for ICMP packets (mask) */
        u_short fr_icmp;

        u_char  fr_scmp;        /* data for port comparisons */
        u_char  fr_dcmp; 
        u_short fr_dport;
        u_short fr_sport;
        u_short fr_stop;        /* top port for <> and >< */ 
        u_short fr_dtop;        /* top port for <> and >< */
        u_32_t  fr_flags;       /* per-rule flags && options (see below) */
        u_short fr_skip;        /* # of rules to skip */
        u_short fr_loglevel;    /* syslog log facility + priority */
        int     (*fr_func) __P((int, ip_t *, fr_info_t *));
        char    fr_icode;       /* return ICMP code */
        char    fr_ifname[IFNAMSIZ];
#if BSD > 199306
        char    fr_oifname[IFNAMSIZ];
#endif  
        struct  frdest  fr_tif; /* "to" interface */
        struct  frdest  fr_dif; /* duplicate packet interfaces */
} frentry_t;
.fi
.PP
When adding a new rule, all unused fields (in the filter rule) should be
initialised to be zero.  To insert a rule, at a particular position in the
filter list, the number of the rule which it is to be inserted before must
be put in the "fr_hits" field (the first rule is number 0).
.LP
.PP
Flags which are recognised in fr_flags:
.nf

     FR_BLOCK        0x000001   /* do not allow packet to pass */
     FR_PASS         0x000002   /* allow packet to pass */
     FR_OUTQUE       0x000004   /* outgoing packets */
     FR_INQUE        0x000008   /* ingoing packets */
     FR_LOG          0x000010   /* Log */
     FR_LOGB         0x000011   /* Log-fail */
     FR_LOGP         0x000012   /* Log-pass */
     FR_LOGBODY      0x000020   /* log the body of packets too */
     FR_LOGFIRST     0x000040   /* log only the first packet to match */
     FR_RETRST       0x000080   /* return a TCP RST packet if blocked */
     FR_RETICMP      0x000100   /* return an ICMP packet if blocked */
     FR_FAKEICMP     0x00180    /* Return ICMP unreachable with fake source */
     FR_NOMATCH      0x000200   /* no match occured */
     FR_ACCOUNT      0x000400   /* count packet bytes */
     FR_KEEPFRAG     0x000800   /* keep fragment information */
     FR_KEEPSTATE    0x001000   /* keep `connection' state information */
     FR_INACTIVE     0x002000
     FR_QUICK        0x004000   /* match & stop processing list */
     FR_FASTROUTE    0x008000   /* bypass normal routing */
     FR_CALLNOW      0x010000   /* call another function (fr_func) if matches */
     FR_DUP          0x020000   /* duplicate the packet */
     FR_LOGORBLOCK   0x040000   /* block the packet if it can't be logged */
     FR_NOTSRCIP     0x080000   /* not the src IP# */
     FR_NOTDSTIP     0x100000   /* not the dst IP# */
     FR_AUTH         0x200000   /* use authentication */
     FR_PREAUTH      0x400000   /* require preauthentication */
	
.fi
.PP
Values for fr_scomp and fr_dcomp (source and destination port value
comparisons) :
.LP
.nf
	FR_NONE         0
	FR_EQUAL        1
	FR_NEQUAL       2
	FR_LESST        3
	FR_GREATERT     4
	FR_LESSTE       5
	FR_GREATERTE    6
	FR_OUTRANGE     7
	FR_INRANGE      8
.fi
.PP
The third ioctl, SIOCIPFFL, flushes either the input filter list, the
output filter list or both and it returns the number of filters removed
from the list(s).  The values which it will take and recognise are FR_INQUE
and FR_OUTQUE (see above).  This ioctl is also implemented for
\fB/dev/ipstate\fP and will flush all state tables entries if passed 0
or just all those which are not established if passed 1.

.IP "\fBGeneral Logging Flags\fP" 0
There are two flags which can be set to log packets independantly of the
rules used.  These allow for packets which are either passed or blocked
to be logged.  To set (and clear)/get these flags, two ioctls are
provided:
.IP SIOCSETFF 16
Takes an unsigned integer as the parameter.  The flags are then set to
those provided (clearing/setting all in one).
.nf

	FF_LOGPASS	0x10000000
	FF_LOGBLOCK	0x20000000
	FF_LOGNOMATCH	0x40000000
	FF_BLOCKNONIP	0x80000000    /* Solaris 2.x only */
.fi
.IP SIOCGETFF 16
Takes a pointer to an unsigned integer as the parameter.  A copy of the
flags currently in used is copied to user space.
.IP "\fBFilter statistics\fP" 0
Statistics on the various operations performed by this package on packets
is kept inside the kernel.  These statistics apply to packets traversing
through the kernel.  To retrieve this structure, use this ioctl:
.nf

	ioctl(fd, SIOCGETFS, struct friostat *)

struct  friostat        {
        struct  filterstats     f_st[2];
        struct  frentry         *f_fin[2];
        struct  frentry         *f_fout[2];
        struct  frentry         *f_acctin[2];
        struct  frentry         *f_acctout[2];
        struct  frentry         *f_auth;
        u_long  f_froute[2];
        int     f_active;       /* 1 or 0 - active rule set */
        int     f_defpass;      /* default pass - from fr_pass */
        int     f_running;      /* 1 if running, else 0 */
        int     f_logging;      /* 1 if enabled, else 0 */
        char    f_version[32];  /* version string */
};

struct	filterstats {
        u_long  fr_pass;        /* packets allowed */
        u_long  fr_block;       /* packets denied */
        u_long  fr_nom;         /* packets which don't match any rule */
        u_long  fr_ppkl;        /* packets allowed and logged */
        u_long  fr_bpkl;        /* packets denied and logged */
        u_long  fr_npkl;        /* packets unmatched and logged */
        u_long  fr_pkl;         /* packets logged */
        u_long  fr_skip;        /* packets to be logged but buffer full */
        u_long  fr_ret;         /* packets for which a return is sent */
        u_long  fr_acct;        /* packets for which counting was performed */
        u_long  fr_bnfr;        /* bad attempts to allocate fragment state */
        u_long  fr_nfr;         /* new fragment state kept */
        u_long  fr_cfr;         /* add new fragment state but complete pkt */
        u_long  fr_bads;        /* bad attempts to allocate packet state */
        u_long  fr_ads;         /* new packet state kept */
        u_long  fr_chit;        /* cached hit */
        u_long  fr_pull[2];     /* good and bad pullup attempts */
#if SOLARIS
        u_long  fr_notdata;     /* PROTO/PCPROTO that have no data */
        u_long  fr_nodata;      /* mblks that have no data */
        u_long  fr_bad;         /* bad IP packets to the filter */
        u_long  fr_notip;       /* packets passed through no on ip queue */
        u_long  fr_drop;        /* packets dropped - no info for them! */
#endif
};
.fi
If we wanted to retrieve all the statistics and reset the counters back to
0, then the ioctl() call would be made to SIOCFRZST rather than SIOCGETFS.
In addition to the statistics above, each rule keeps a hit count, counting
both number of packets and bytes.  To reset these counters for a rule,
load the various rule information into a frentry structure and call
SIOCZRLST.
.IP "Swapping Active lists" 0
IP Filter supports two lists of rules for filtering and accounting: an
active list and an inactive list.  This allows for large scale rule base
changes to be put in place atomically with otherwise minimal interruption.
Which of the two is active can be changed using the SIOCSWAPA ioctl.  It
is important to note that no passed argument is recognised and that the
value returned is that of the list which is now inactive.
.br
.SH FILES
/dev/ipauth
.br
/dev/ipl
.br
/dev/ipnat
.br
/dev/ipstate
.SH SEE ALSO
ipl(4), ipnat(4), ipf(5), ipf(8), ipfstat(8)
@


1.22
log
@reimplement local ipf mods and import some missed patches
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.21 2000/04/13 19:59:39 kjell Exp $
@


1.21
log
@Long overdue documentation update for IPFilter. These
are taken directly from the ipf distribution, and are
not mandoc'ed. ipf(8), ipfstat(8), and ipnat(8) are yet
to go and must be done manually. (sigh)
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d16 2
a17 2
	ioctl(fd, SIOCADDFR, struct frentry *)
	ioctl(fd, SIOCDELFR, struct frentry *)
d24 6
a29 6
	ioctl(fd, SIOCADAFR, struct frentry *) (same as SUICADDFR)
	ioctl(fd, SIOCRMAFR, struct frentry *) (same as SUICDELFR)
	ioctl(fd, SIOCADIFR, struct frentry *)
	ioctl(fd, SIOCRMIFR, struct frentry *)
	ioctl(fd, SIOCINAFR, struct frentry *)
	ioctl(fd, SIOCINIFR, struct frentry *)
d32 1
a32 1
	ioctl(fd, SIOCGETFS, struct friostat *)
d38 5
a42 5
	ioctl(fd, SIOCFRZST, struct friostat *)
	ioctl(fd, SIOCZRLST, struct frentry *)
	ioctl(fd, SIOCAUTHW, struct fr_info *)
	ioctl(fd, SIOCAUTHR, struct fr_info *)
	ioctl(fd, SIOCATHST, struct fr_authstat *)
d112 1
a112 1
Flags which are recognised in fr_pass:
@


1.20
log
@Convert to mdoc, but it's still a pretty ugly man page.
@
text
@d1 11
a11 12
.\"	$OpenBSD: ipf.4,v 1.19 2000/02/19 21:46:45 aaron Exp $
.Dd March 15, 2000
.Dt IPF 4
.Os
.Sh NAME
.Nm ipf
.Nd "packet filtering kernel interface"
.Sh SYNOPSIS
.Fd #include <netinet/ip_fil_compat.h>
.Fd #include <netinet/ip_fil.h>
.Sh DESCRIPTION
.Pp
d13 3
a15 3
for use.
The ioctls are called as:
.Bd -literal -offset indent
d19 2
a20 2
.Ed
.Pp
d22 4
a25 3
.Bd -literal -offset indent
	ioctl(fd, SIOCADAFR, struct frentry *) (same as SIOCADDFR)
	ioctl(fd, SIOCRMAFR, struct frentry *) (same as SIOCDELFR)
d43 4
a46 9
.Ed
.Pp
The variations,
.Dv SIOCADAFR
versus
.Dv SIOCADIFR ,
allow operation on the two lists,
active and inactive, respectively.
All of these ioctls are implemented
d49 3
a51 3
be that of the device associated with the module (i.e.,
.Pa /dev/ipl ) .
.Pp
d54 4
a57 6
and insertion of a rule into the list (SIOCIN*).
The rule place into
which it is inserted is stored in the
.Fa fr_hits
field, below.
.Bd -literal
d64 1
a64 1
        void	*fr_ifa;
d66 1
a66 1
        void	*fr_oifa;
d69 1
a69 1
         * These are only incremented when a packet matches this rule and
d72 2
a73 2
        U_QUAD_T	fr_hits;
        U_QUAD_T	fr_bytes;
d87 1
a87 1
        u_char  fr_dcmp;
d90 1
a90 1
        u_short fr_stop;        /* top port for <> and >< */
d99 2
a100 2
        char	fr_oifname[IFNAMSIZ];
#endif
d104 2
a105 2
.Ed
.Pp
d107 1
a107 2
initialized to be zero.
To insert a rule, at a particular position in the
d109 6
a114 6
be put in the
.Fa fr_hits
field (the first rule is number 0).
.Pp
Flags which are recognized in fr_pass:
.Bd -literal
d127 1
a127 1
     FR_NOMATCH      0x000200   /* no match occurred */
d141 7
a147 8
.Ed
.Pp
Values for
.Fa fr_scomp
and
.Fa fr_dcomp
(source and destination port value comparisons):
.Bd -literal
d157 3
a159 5
.Ed
.Pp
The third ioctl,
.Dv SIOCIPFFL ,
flushes either the input filter list, the
d161 9
a169 16
from the list(s).
The values which it will take and recognize are
.Dv FR_INQUE
and
.Dv FR_OUTQUE
(see above).
This ioctl is also implemented for
.Pa /dev/ipstate
and will flush all state tables entries if passed 0 or just all those
which are not established if passed 1.
.Ss General logging flags
There are two flags which can be set to log packets independently of the
rules used.
These allow for packets which are either passed or blocked
to be logged.
To set (and clear) or get these flags, two ioctls are
d171 2
a172 4
.Bl -tag -width Ds
.It SIOCSETFF
Takes an unsigned integer as the parameter.
The flags are then set to
d174 2
a175 1
.Bd -literal
d180 5
a184 7
.Ed
.Pp
.It SIOCGETFF
Takes a pointer to an unsigned integer as the parameter.
A copy of the flags currently in used is copied to user space.
.El
.Ss Filter statistics
d186 4
a189 4
is kept inside the kernel.
These statistics apply to packets traversing through the kernel.
To retrieve this structure, use this ioctl:
.Bd -literal
d228 1
a228 1
	u_long  fr_bad;         /* bad IP packets to the filter */
d233 1
a233 2
.Ed
.Pp
d235 1
a235 4
0, then the ioctl() call would be made to
.Dv SIOCFRZST
rather than
.Dv SIOCGETFS .
d237 4
a240 7
both number of packets and bytes.
To reset these counters for a rule,
load the various rule information into a
.Fa frentry
structure and call
.Dv SIOCZRLST .
.Ss Swapping active lists
d242 1
a242 2
active list and an inactive list.
This allows for large scale rule base
d244 2
a245 4
Which of the two is active can be changed using the
.Dv SIOCSWAPA
ioctl.
It is important to note that no passed argument is recognized and that the
d247 11
a257 18
.Sh FILES
.Bl -tag -width /dev/ipstate -compact
.It Pa /dev/ipauth
.It Pa /dev/ipl
.It Pa /dev/ipstate
.El
.Sh SEE ALSO
.Xr ipftest 1 ,
.Xr ipl 4 ,
.Xr ipnat 4 ,
.Xr ipf 5 ,
.Xr ipnat 5 ,
.Xr ipf 8 ,
.Xr ipfstat 8 ,
.Xr ipmon 8 ,
.Xr ipnat 8
.Pp
http://coombs.anu.edu.au/~avalon
@


1.19
log
@Re-order SEE ALSO entries.
@
text
@d1 12
a12 10
.\"	$OpenBSD: ipf.4,v 1.18 2000/01/24 07:25:37 kjell Exp $
.TH IPF 4
.SH NAME
ipf \- packet filtering kernel interface
.SH SYNOPSIS
#include <netinet/ip_fil_compat.h>
.br
#include <netinet/ip_fil.h>
.SH IOCTLS
.PP
d14 3
a16 3
for use.  The ioctls are called as:
.LP
.nf
d20 2
a21 2
.fi
.PP
d23 1
a23 2
.LP
.nf
d43 9
a51 4
.fi
.PP
The variations, SIOCADAFR vs. SIOCADIFR, allow operation on the two lists,
active and inactive, respectively.  All of these ioctls are implemented
d54 3
a56 3
be that of the device associated with the module (i.e., /dev/ipl).
.LP
.PP
d59 6
a64 4
and insertion of a rule into the list (SIOCIN*).  The rule place into
which it is inserted is stored in the "fr_hits" field, below.
.LP
.nf
d111 2
a112 2
.fi
.PP
d114 2
a115 1
initialized to be zero.  To insert a rule, at a particular position in the
d117 6
a122 6
be put in the "fr_hits" field (the first rule is number 0).
.LP
.PP
Flags which are recognised in fr_pass:
.nf

d149 8
a156 7
	
.fi
.PP
Values for fr_scomp and fr_dcomp (source and destination port value
comparisons) :
.LP
.nf
d166 5
a170 3
.fi
.PP
The third ioctl, SIOCIPFFL, flushes either the input filter list, the
d172 7
a178 2
from the list(s).  The values which it will take and recognise are FR_INQUE
and FR_OUTQUE (see above). This ioctl is also implemented for
d182 1
a182 2

.IP "\fBGeneral Logging Flags\fP" 0
d184 4
a187 2
rules used.  These allow for packets which are either passed or blocked
to be logged.  To set (and clear)/get these flags, two ioctls are
d189 4
a192 2
.IP SIOCSETFF 16
Takes an unsigned integer as the parameter.  The flags are then set to
d194 1
a194 2
.nf

d199 7
a205 6
.fi
.IP SIOCGETFF 16
Takes a pointer to an unsigned integer as the parameter.  A copy of the
flags currently in used is copied to user space.
.LP
.IP "\fBFilter statistics\fP" 0
d207 4
a210 4
is kept inside the kernel.  These statistics apply to packets traversing
through the kernel.  To retrieve this structure, use this ioctl:
.nf

d254 2
a255 1
.fi
d257 4
a260 1
0, then the ioctl() call would be made to SIOCFRZST rather than SIOCGETFS.
d262 7
a268 4
both number of packets and bytes.  To reset these counters for a rule,
load the various rule information into a frentry structure and call
SIOCZRLST.
.IP "Swapping Active lists" 0
d270 2
a271 1
active list and an inactive list.  This allows for large scale rule base
d273 4
a276 2
Which of the two is active can be changed using the SIOCSWAPA ioctl.  It
is important to note that no passed argument is recognised and that the
d278 17
a294 10
.br
.SH FILES
/dev/ipauth
.br
/dev/ipl
.br
/dev/ipstate
.SH SEE ALSO
ipftest(1), ipl(4), ipnat(4), ipf(5), ipnat(5), ipf(8), ipfstat(8), ipmon(8), ipnat(8)
.br
@


1.18
log
@correct Xrs. marc@@snafu.org.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.17 2000/01/07 07:45:03 kjell Exp $
d256 1
a256 1
ipf(8), ipftest(1), ipnat(8), ipl(4), ipnat(4), ipf(5), ipnat(5), ipfstat(8), ipmon(8)
@


1.17
log
@Update documentation to reflect 3.3.6
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.16 1999/11/23 22:27:31 deraadt Exp $
d256 1
a256 2
ipf(1), ipftest(1), ipnat(1), ipl(4), ipnat(4), ipf(5), ipnat(5), ipfstat(8), i
pmon(8)
@


1.16
log
@fix typo; jwk@@lords.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.15 1999/10/12 05:05:00 ericj Exp $
d29 3
d33 9
d60 1
a60 1
        u_short fr_head;        /* group # which this rule starts */
d63 4
a66 1
        struct  ifnet   *fr_ifa;
d68 1
a68 1
         * These are only incremented when a packet  matches this rule and
d71 2
a72 2
        U_QUAD_T  fr_hits;
        U_QUAD_T  fr_bytes;
d77 1
a77 1
        struct  fr_ip   fr_mip;
d91 4
a94 3
        u_long  fr_flags;       /* per-rule flags && options (see below) */
        int     fr_skip;        /* # of rules to skip */
        int     (*fr_func)();   /* call this function */
d97 3
d124 2
a125 1
     FR__RETICMP     0x000100   /* return an ICMP packet if blocked */
d161 4
a164 1
and FR_OUTQUE (see above).
d166 1
a166 1
\fBGeneral Logging Flags\fP
d185 1
a185 1
\fBFilter statistics\fP
d200 6
a205 1
        int     f_active;
d227 3
a229 1
        u_long  fr_bad;         /* bad IP packets to the filter */
d235 14
@


1.15
log
@correct ipfilter url
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.14 1999/09/23 04:12:02 alex Exp $
d100 2
a101 2
     FR_LOGP         0x000011   /* Log-pass */
     FR_LOGB         0x000012   /* Log-fail */
@


1.14
log
@Typo fixes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.13 1998/09/15 09:55:44 pattonme Exp $
d215 1
a215 1
http://coombs.anu.edu.au/ipfilter/
@


1.13
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.10 1998/07/20 07:18:39 deraadt Exp $
d106 1
a106 1
     FR_NOMATCH      0x000200   /* no match occured */
d144 1
a144 1
There are two flags which can be set to log packets independantly of the
@


1.12
log
@more man page fixes; aaron@@ug.cs.dal.ca
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.11 1998/08/29 21:12:26 deraadt Exp $
d7 1
d106 1
a106 1
     FR_NOMATCH      0x000200   /* no match occurred */
d144 1
a144 1
There are two flags which can be set to log packets independently of the
d205 6
d212 4
a215 1
ipfstat(8), ipf(1), ipf(5)
@


1.11
log
@man page repairs; aaron@@ug.cs.dal.ca
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.10 1998/07/20 07:18:39 deraadt Exp $
d105 1
a105 1
     FR_NOMATCH      0x000200   /* no match occured */
@


1.10
log
@typo repair; garath@@garath.static.dialin.ntplx.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.9 1998/01/26 04:13:33 dgregor Exp $
d143 1
a143 1
There are two flags which can be set to log packets independantly of the
@


1.9
log
@IPF 3.2.3
@
text
@d1 1
a1 1
.\"	$OpenBSD: ipf.4,v 1.8 1997/04/09 11:44:26 kstailey Exp $
d22 2
a23 2
	ioctl(fd, SIOCADAFR, struct frentry *) (same as SUICADDFR)
	ioctl(fd, SIOCRMAFR, struct frentry *) (same as SUICDELFR)
@


1.8
log
@add tags
@
text
@d1 1
a1 1
.\"	$OpenBSD$
a5 1
.nf
a7 1
.fi
d46 4
d51 6
a56 3
        u_long  fr_hits;
        u_long  fr_bytes;       /* this is only incremented when a packet */
                                /* stops matching on this rule */
d76 1
d91 1
a91 1
Flags which are recognized in fr_pass:
d94 25
a118 21
	FR_BLOCK        0x00001    /* do not allow packet to pass */
	FR_PASS         0x00002    /* allow packet to pass */
	FR_OUTQUE       0x00004    /* outgoing packets */
	FR_INQUE        0x00008    /* ingoing packets */
	FR_LOG          0x00010    /* Log */
	FR_LOGP         0x00011    /* Log-pass */
	FR_LOGB         0x00012    /* Log-fail */
        FR_LOGBODY      0x00020    /* log the body of packets too */
        FR_LOGFIRST     0x00040    /* log only the first packet to match */
	FR_RETRST       0x00080    /* return a TCP RST packet if blocked */
	FR_RETICMP      0x00100    /* return an ICMP packet if blocked */
        FR_NOMATCH      0x00200    /* no match occurred */
        FR_ACCOUNT      0x00400    /* count packet bytes */
        FR_KEEPFRAG     0x00800
        FR_KEEPSTATE    0x01000    /* keep packet flow state information */
        FR_INACTIVE     0x02000
        FR_QUICK        0x04000    /* quick-match and return */
        FR_FASTROUTE    0x08000
        FR_CALLFUNC     0x10000
        FR_CALLNOW      0x20000
        FR_DUP          0x40000    /* duplicate the packet (not Solaris2)
d139 1
a139 1
from the list(s).  The values which it will take and recognize are FR_INQUE
d143 1
a143 1
There are two flags which can be set to log packets independently of the
d152 4
a155 2
	FF_LOGPASS	1
	FF_LOGBLOCK	2
d169 8
a176 4
struct	friostat        {
	struct  filterstats     f_st[2];
	struct  frentry *f_fin;
	struct  frentry *f_fout;
d196 1
d205 1
a205 1
ipfstat(1), ipf(1), ipf(5)
@


1.7
log
@correct paragraph fill
@
text
@d1 1
@


1.6
log
@spelling
@
text
@d5 1
d8 1
@


1.5
log
@IPF 1.3.7
@
text
@d5 2
a6 1
#include <sys/ip_fil.h>
d10 1
a10 1
for use.  The ioctl's are called as:
d31 1
a31 1
active and inactive, respectively.  All of these ioctl's are implemented
d77 1
a77 1
initialised to be zero.  To insert a rule, at a particular position in the
d82 1
a82 1
Flags which are recognised in fr_pass:
d96 1
a96 1
        FR_NOMATCH      0x00200    /* no match occured */
d126 1
a126 1
from the list(s).  The values which it will take and recognise are FR_INQUE
d130 1
a130 1
There are two flags which can be set to log packets independantly of the
@


1.4
log
@ipfilter 3.1.0
@
text
@d3 1
a3 1
ipf - packet filtering kernel interface
d29 1
a29 1
The variations, SIOCADAFR vs SIOCADIFR, allow operation on the two lists,
d33 1
a33 1
be that of the device associated with the module (ie /dev/ipl).
@


1.3
log
@update rcsid
@
text
@a0 2
.\"	$OpenBSD$
.\"
a41 1

d45 3
a47 2
        u_int   fr_hits;

d51 5
a55 2
        struct  ip      fr_ip;
        struct  ip      fr_mip;
a59 3
        char    fr_tcpfm;       /* tcp flags mask */
        char    fr_tcpf;        /* tcp flags */

d66 3
a68 1
        u_short fr_flags;       /* per-rule flags && options */
d70 2
d75 6
d84 22
a105 13
	FR_BLOCK        0x0001    /* do not allow packet to pass */
	FR_PASS         0x0002    /* allow packet to pass */
	FR_OUTQUE       0x0004    /* outgoing packets */
	FR_QUICK        0x0008    /* quick-match and return */
	FR_LOGP         0x0010    /* Log-pass */
	FR_INQUE        0x0020    /* ingoing packets */
	FR_LOGB         0x0040    /* Log-fail */
	FR_LOG          0x0080    /* Log */
	FR_RETRST       0x0100    /* return a TCP RST packet if blocked */
	FR_OPTFRAG      0x0200    /* filter packets which are fragments */
	FR_OPTSHORT     0x0400    /* filter short TCP packets */
	FR_RETICMP      0x0800    /* return an ICMP packet if blocked */
	FR_TCPUDP       0x1000    /* TCP/UCP implied comparison involved */
d143 1
a143 1
fags currently in used is copied to user space.
d160 21
a180 6
        u_long  fr_pass;    /* packets allowed */
        u_long  fr_block;   /* packets denied */
        u_long  fr_ppkl;    /* packets allowed and logged */
        u_long  fr_bpkl;    /* packets denied and logged */
        u_long  fr_pkl;	    /* packets logged */
        u_long  fr_skip;    /* packets to be logged but buffer full */
a182 3
.SH BUGS
It would be nice if there were more flexibility when adding and deleting
filter rules.
@


1.2
log
@ipfilter 3.0.4
@
text
@d1 2
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d33 1
a33 2
be that of the device associated with the module (ie /dev/ipl).  In addition
to this, these ioctl's will only succeed if made as root.
@
