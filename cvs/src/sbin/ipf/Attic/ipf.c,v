head	1.27;
access;
symbols
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_8:1.24.0.4
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.24.0.2
	OPENBSD_2_7_BASE:1.24
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2001.05.30.02.11.41;	author deraadt;	state dead;
branches;
next	1.26;

1.26
date	2001.01.30.04.26.01;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.17.05.00.58;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.12.21.51.48;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.13.23.40.19;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.16.22.34.21;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.01.19.30.00;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	99.12.15.05.20.24;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	99.07.06.19.06.42;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	99.03.06.23.18.23;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.02.08.18.58.59;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.02.08.18.29.11;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.02.08.06.23.26;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.02.07.00.55.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.02.05.05.58.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.09.15.09.55.44;	author pattonme;	state Exp;
branches;
next	1.11;

1.11
date	98.01.26.04.13.35;	author dgregor;	state Exp;
branches;
next	1.10;

1.10
date	97.02.26.04.35.39;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.29.01.28.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.17.07.12.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.08.07.33.31;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.07.21.16.40.04;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.07.18.05.11.01;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.30.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.39.52;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.26;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.33.32;	author dm;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ipf.c,v 1.26 2001/01/30 04:26:01 kjell Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#ifdef	__FreeBSD__
# include <osreldate.h>
#endif
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#if !defined(__SVR4) && !defined(__GNUC__)
#include <strings.h>
#endif
#include <sys/types.h>
#include <sys/param.h>
#include <sys/file.h>
#include <stdlib.h>
#include <stddef.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <sys/time.h>
#include <net/if.h>
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
#endif
#include <netinet/ip.h>
#include <netdb.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_nat.h>
#include "ipf.h"
#include <netinet/ipl.h>

#if !defined(lint)
static const char sccsid[] = "@@(#)ipf.c	1.23 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipf.c,v 2.10.2.5 2000/10/25 10:37:11 darrenr Exp $";
#endif

#if	SOLARIS
static	void	blockunknown __P((void));
#endif
#if !defined(__SVR4) && defined(__GNUC__)
extern	char	*index __P((const char *, int));
#endif

extern	char	*optarg;

void	frsync __P((void));
void	zerostats __P((void));
int	main __P((int, char *[]));

int	opts = 0;
#ifdef	USE_INET6
int	use_inet6 = 0;
#endif

static	int	fd = -1;

static	void	procfile __P((char *, char *)), flushfilter __P((char *));
static	void	set_state __P((u_int)), showstats __P((friostat_t *));
static	void	packetlogon __P((char *)), swapactive __P((void));
static	int	opendevice __P((char *));
static	void	closedevice __P((void));
static	char	*getline __P((char *, size_t, FILE *, int *));
static	char	*ipfname = IPL_NAME;
static	void	usage __P((void));
static	void	showversion __P((void));
static	int	get_flags __P((void));

#if SOLARIS
#define OPTS	"6AdDEf:F:Il:noPrsUvVyzZ"
#else
#define OPTS	"6AdDEf:F:Il:noPrsvVyzZ"
#endif

static void usage()
{
#if SOLARIS
	fprintf(stderr, "usage: ipf [-6AdDEInoPrsUvVyzZ] %s %s %s\n",
#else
	fprintf(stderr, "usage: ipf [-6AdDEInoPrsvVyzZ] %s %s %s\n",
#endif
		"[-l block|pass|nomatch]", "[-F i|o|a|s|S]", "[-f filename]");
	exit(1);
}


int main(argc,argv)
int argc;
char *argv[];
{
	int c;

	while ((c = getopt(argc, argv, OPTS)) != -1)
		if (c == '?')
			usage();

	optreset=1;
	optind=1;
	while ((c = getopt(argc, argv, OPTS)) != -1) {
		switch (c)
		{
#ifdef	USE_INET6
		case '6' :
			use_inet6 = 1;
			break;
#endif
		case 'A' :
			opts &= ~OPT_INACTIVE;
			break;
		case 'E' :
			set_state((u_int)1);
			break;
		case 'D' :
			set_state((u_int)0);
			break;
		case 'd' :
			opts |= OPT_DEBUG;
			break;
		case 'f' :
			procfile(argv[0], optarg);
			break;
		case 'F' :
			flushfilter(optarg);
			break;
		case 'I' :
			opts |= OPT_INACTIVE;
			break;
		case 'l' :
			packetlogon(optarg);
			break;
		case 'n' :
			opts |= OPT_DONOTHING;
			break;
		case 'o' :
			break;
		case 'P' :
			ipfname = IPL_AUTH;
			break;
		case 'r' :
			opts |= OPT_REMOVE;
			break;
		case 's' :
			swapactive();
			break;
#if SOLARIS
		case 'U' :
			blockunknown();
			break;
#endif
		case 'v' :
			opts |= OPT_VERBOSE;
			break;
		case 'V' :
			showversion();
			break;
		case 'y' :
			frsync();
			break;
		case 'z' :
			opts |= OPT_ZERORULEST;
			break;
		case 'Z' :
			zerostats();
			break;
		}
	}

	if (fd != -1)
		(void) close(fd);

	exit(0);
	/* NOTREACHED */
}


static int opendevice(ipfdev)
char *ipfdev;
{
	if (opts & OPT_DONOTHING)
		return -2;

	if (!ipfdev)
		ipfdev = ipfname;

	if (!(opts & OPT_DONOTHING) && fd == -1)
		if ((fd = open(ipfdev, O_RDWR)) == -1)
			if ((fd = open(ipfdev, O_RDONLY)) == -1)
				perror("open device");
	return fd;
}


static void closedevice()
{
	close(fd);
	fd = -1;
}


static	int	get_flags()
{
	int i;

	if ((opendevice(ipfname) != -2) && (ioctl(fd, SIOCGETFF, &i) == -1)) {
		perror("SIOCGETFF");
		return 0;
	}
	return i;
}


static	void	set_state(enable)
u_int	enable;
{
	if (opendevice(ipfname) != -2)
		if (ioctl(fd, SIOCFRENB, &enable) == -1) {
			if (errno == EBUSY)
				fprintf(stderr,
					"IP FIlter: already initialized\n");
			else
				perror("SIOCFRENB");
		}
	return;
}

static	void	procfile(name, file)
char	*name, *file;
{
	FILE	*fp;
	char	line[513], *s;
	struct	frentry	*fr;
	u_int	add, del;
	int     linenum = 0;

	(void) opendevice(ipfname);

	if (opts & OPT_INACTIVE) {
		add = SIOCADIFR;
		del = SIOCRMIFR;
	} else {
		add = SIOCADAFR;
		del = SIOCRMAFR;
	}
	if (opts & OPT_DEBUG)
		printf("add %x del %x\n", add, del);

	initparse();

	if (!strcmp(file, "-"))
		fp = stdin;
	else if (!(fp = fopen(file, "r"))) {
		fprintf(stderr, "%s: fopen(%s) failed: %s\n", name, file,
			STRERROR(errno));
		exit(1);
	}

	while (getline(line, sizeof(line), fp, &linenum)) {
		/*
		 * treat CR as EOL.  LF is converted to NUL by getline().
		 */
		if ((s = index(line, '\r')))
			*s = '\0';
		/*
		 * # is comment marker, everything after is a ignored
		 */
		if ((s = index(line, '#')))
			*s = '\0';

		if (!*line)
			continue;

		if (opts & OPT_VERBOSE)
			(void)fprintf(stderr, "[%s]\n", line);

		fr = parse(line, linenum);
		(void)fflush(stdout);

		if (fr) {
			if (opts & OPT_ZERORULEST)
				add = SIOCZRLST;
			else if (opts & OPT_INACTIVE)
				add = (u_int)fr->fr_hits ? SIOCINIFR :
							   SIOCADIFR;
			else
				add = (u_int)fr->fr_hits ? SIOCINAFR :
							   SIOCADAFR;
			if (fr->fr_hits)
				fr->fr_hits--;
			if (fr && (opts & OPT_VERBOSE))
				printfr(fr);
			if (fr && (opts & OPT_OUTQUE))
				fr->fr_flags |= FR_OUTQUE;

			if (opts & OPT_DEBUG)
				binprint(fr);

			if ((opts & OPT_ZERORULEST) &&
			    !(opts & OPT_DONOTHING)) {
				if (ioctl(fd, add, &fr) == -1) {
					fprintf(stderr, "%d:", linenum);
					perror("ioctl(SIOCZRLST)");
				} else {
#ifdef	USE_QUAD_T
					printf("hits %qd bytes %qd ",
						(long long)fr->fr_hits,
						(long long)fr->fr_bytes);
#else
					printf("hits %ld bytes %ld ",
						fr->fr_hits, fr->fr_bytes);
#endif
					printfr(fr);
				}
			} else if ((opts & OPT_REMOVE) &&
				   !(opts & OPT_DONOTHING)) {
				if (ioctl(fd, del, &fr) == -1) {
					fprintf(stderr, "%d:", linenum);
					perror("ioctl(delete rule)");
				}
			} else if (!(opts & OPT_DONOTHING)) {
				if (ioctl(fd, add, &fr) == -1) {
					fprintf(stderr, "%d:", linenum);
					perror("ioctl(add/insert rule)");
				}
			}
		}
	}
	if (ferror(fp) || !feof(fp)) {
		fprintf(stderr, "%s: %s: file error or line too long\n",
		    name, file);
		exit(1);
	}
	(void)fclose(fp);
}

/*
 * Similar to fgets(3) but can handle '\\' and NL is converted to NUL.
 * Returns NULL if error occured, EOF encounterd or input line is too long.
 */
static char *getline(str, size, file, linenum)
register char	*str;
size_t	size;
FILE	*file;
int	*linenum;
{
	char *p;
	int s, len;

	do {
		for (p = str, s = size;; p += (len - 1), s -= (len - 1)) {
			/*
			 * if an error occured, EOF was encounterd, or there
			 * was no room to put NUL, return NULL.
			 */
			if (fgets(p, s, file) == NULL)
				return (NULL);
			len = strlen(p);
			if (p[len - 1] != '\n') {
				p[len] = '\0';
				break;
			}
			(*linenum)++;
			p[len - 1] = '\0';
			if (len < 2 || p[len - 2] != '\\')
				break;
			else
				/*
				 * Convert '\\' to a space so words don't
				 * run together
				 */
				p[len - 2] = ' ';
		}
	} while (*str == '\0');
	return (str);
}


static void packetlogon(opt)
char	*opt;
{
	int	flag, err;

	flag = get_flags();
	if (flag != 0) {
		if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE)
			printf("log flag is currently %#x\n", flag);
	}

	flag &= ~(FF_LOGPASS|FF_LOGNOMATCH|FF_LOGBLOCK);

	if (index(opt, 'p')) {
		flag |= FF_LOGPASS;
		if (opts & OPT_VERBOSE)
			printf("set log flag: pass\n");
	}
	if (index(opt, 'm') && (*opt == 'n' || *opt == 'N')) {
		flag |= FF_LOGNOMATCH;
		if (opts & OPT_VERBOSE)
			printf("set log flag: nomatch\n");
	}
	if (index(opt, 'b') || index(opt, 'd')) {
		flag |= FF_LOGBLOCK;
		if (opts & OPT_VERBOSE)
			printf("set log flag: block\n");
	}

	if (opendevice(ipfname) != -2 && (err = ioctl(fd, SIOCSETFF, &flag)))
		perror("ioctl(SIOCSETFF)");

	if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE) {
		flag = get_flags();
		printf("log flag is now %#x\n", flag);
	}
}


static	void	flushfilter(arg)
char	*arg;
{
	int	fl = 0, rem;

	if (!arg || !*arg)
		return;
	if (!strcmp(arg, "s") || !strcmp(arg, "S")) {
		if (*arg == 'S')
			fl = 0;
		else
			fl = 1;
		rem = fl;

		closedevice();
		if (opendevice(IPL_STATE) != -2 &&
		    ioctl(fd, SIOCIPFFL, &fl) == -1)
			perror("ioctl(SIOCIPFFL)");
		if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE) {
			printf("remove flags %s (%d)\n", arg, rem);
			printf("removed %d filter rules\n", fl);
		}
		closedevice();
		return;
	}
	if (strchr(arg, 'i') || strchr(arg, 'I'))
		fl = FR_INQUE;
	if (strchr(arg, 'o') || strchr(arg, 'O'))
		fl = FR_OUTQUE;
	if (strchr(arg, 'a') || strchr(arg, 'A'))
		fl = FR_OUTQUE|FR_INQUE;
	fl |= (opts & FR_INACTIVE);
	rem = fl;

	if (opendevice(ipfname) != -2 && ioctl(fd, SIOCIPFFL, &fl) == -1)
		perror("ioctl(SIOCIPFFL)");
	if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE) {
		printf("remove flags %s%s (%d)\n", (rem & FR_INQUE) ? "I" : "",
			(rem & FR_OUTQUE) ? "O" : "", rem);
		printf("removed %d filter rules\n", fl);
	}
	return;
}


static void swapactive()
{
	int in = 2;

	if (opendevice(ipfname) != -2 && ioctl(fd, SIOCSWAPA, &in) == -1)
		perror("ioctl(SIOCSWAPA)");
	else
		printf("Set %d now inactive\n", in);
}


void frsync()
{
	int frsyn = 0;

	if (opendevice(ipfname) != -2 && ioctl(fd, SIOCFRSYN, &frsyn) == -1)
		perror("SIOCFRSYN");
	else
		printf("filter sync'd\n");
}


void zerostats()
{
	friostat_t	fio;
	friostat_t	*fiop = &fio;

	if (opendevice(ipfname) != -2) {
		if (ioctl(fd, SIOCFRZST, &fiop) == -1) {
			perror("ioctl(SIOCFRZST)");
			exit(-1);
		}
		showstats(fiop);
	}

}


/*
 * read the kernel stats for packets blocked and passed
 */
static void showstats(fp)
friostat_t	*fp;
{
#if SOLARIS
	printf("dropped packets:\tin %lu\tout %lu\n",
			fp->f_st[0].fr_drop, fp->f_st[1].fr_drop);
	printf("non-ip packets:\t\tin %lu\tout %lu\n",
			fp->f_st[0].fr_notip, fp->f_st[1].fr_notip);
	printf("   bad packets:\t\tin %lu\tout %lu\n",
			fp->f_st[0].fr_bad, fp->f_st[1].fr_bad);
#endif
	printf(" input packets:\t\tblocked %lu passed %lu nomatch %lu",
			fp->f_st[0].fr_block, fp->f_st[0].fr_pass,
			fp->f_st[0].fr_nom);
	printf(" counted %lu\n", fp->f_st[0].fr_acct);
	printf("output packets:\t\tblocked %lu passed %lu nomatch %lu",
			fp->f_st[1].fr_block, fp->f_st[1].fr_pass,
			fp->f_st[1].fr_nom);
	printf(" counted %lu\n", fp->f_st[0].fr_acct);
	printf(" input packets logged:\tblocked %lu passed %lu\n",
			fp->f_st[0].fr_bpkl, fp->f_st[0].fr_ppkl);
	printf("output packets logged:\tblocked %lu passed %lu\n",
			fp->f_st[1].fr_bpkl, fp->f_st[1].fr_ppkl);
	printf(" packets logged:\tinput %lu-%lu output %lu-%lu\n",
			fp->f_st[0].fr_pkl, fp->f_st[0].fr_skip,
			fp->f_st[1].fr_pkl, fp->f_st[1].fr_skip);
}


#if SOLARIS
static void blockunknown()
{
	u_32_t	flag;

	if (opendevice(ipfname) == -1)
		return;

	flag = get_flags();
	if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE)
		printf("log flag is currently %#x\n", flag);

	flag ^= FF_BLOCKNONIP;

	if (opendevice(ipfname) != -2 && ioctl(fd, SIOCSETFF, &flag))
		perror("ioctl(SIOCSETFF)");

	if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE) {
		if (ioctl(fd, SIOCGETFF, &flag))
			perror("ioctl(SIOCGETFF)");

		printf("log flag is now %#x\n", flag);
	}
}
#endif


static void showversion()
{
	struct friostat fio;
	struct friostat *fiop=&fio;
	u_32_t flags;
	char *s;
	int vfd;

	printf("ipf: %s (%d)\n", IPL_VERSION, (int)sizeof(frentry_t));

	if ((vfd = open(ipfname, O_RDONLY)) == -1) {
		perror("open device");
		return;
	}

	if (ioctl(vfd, SIOCGETFS, &fiop)) {
		perror("ioctl(SIOCGETFS)");
		close(vfd);
		return;
	}
	close(vfd);
	flags = get_flags();

	printf("Kernel: %-*.*s\n", (int)sizeof(fio.f_version),
		(int)sizeof(fio.f_version), fio.f_version);
	printf("Running: %s\n", fio.f_running ? "yes" : "no");
	printf("Log Flags: %#x = ", flags);
	s = "";
	if (flags & FF_LOGPASS) {
		printf("pass");
		s = ", ";
	}
	if (flags & FF_LOGBLOCK) {
		printf("%sblock", s);
		s = ", ";
	}
	if (flags & FF_LOGNOMATCH) {
		printf("%snomatch", s);
		s = ", ";
	}
	if (flags & FF_BLOCKNONIP) {
		printf("%snonip", s);
		s = ", ";
	}
	if (!*s)
		printf("none set");
	putchar('\n');

	printf("Default: ");
	if (fio.f_defpass & FR_PASS)
		s = "pass";
	else if (fio.f_defpass & FR_BLOCK)
		s = "block";
	else
		s = "nomatch -> block";
	printf("%s all, Logging: %savailable\n", s, fio.f_logging ? "" : "un");
	printf("Active list: %d\n", fio.f_active);
}
@


1.26
log
@reimplement local ipf mods and import some missed patches
@
text
@d1 1
a1 1
/*	$OpenBSD: ipf.c,v 1.25 2001/01/17 05:00:58 fgsch Exp $	*/
@


1.25
log
@1st part of ipf userland code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a39 1
#include <netinet/ip_compat.h>
a41 1
#include <netinet/ip_state.h>
d81 5
d89 1
d91 3
d105 7
a111 1
	while ((c = getopt(argc, argv, "6AdDEf:F:Il:noPrsUvVyzZ")) != -1) {
a113 2
		case '?' :
			usage();
@


1.24
log
@remove unnecessary kernel dependency - mep@@netsec.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ipf.c,v 1.23 2000/03/13 23:40:19 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d39 1
a39 1
#include <netinet/ip_fil_compat.h>
d42 1
d47 2
a48 2
static const char sccsid[] = "@@(#)ipf.c	1.23 6/5/96 (C) 1993-1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipf.c,v 2.2.2.1 2000/02/16 14:40:39 darrenr Exp $";
a58 2
extern	int	optind;
extern	int	optreset;
d65 3
d76 1
a76 1
static	char	*getline __P((char *, size_t, FILE *));
a81 5
#if SOLARIS
#define OPTS	"AdDEf:F:Il:noPrsUvVyzZ"
#else
#define OPTS	"AdDEf:F:Il:noPrsvVyzZ"
#endif
d85 1
a85 5
#if SOLARIS
	fprintf(stderr, "usage: ipf [-AdDEInoPrsUvVyzZ] %s %s %s\n",
#else
	fprintf(stderr, "usage: ipf [-AdDEInoPrsvVyzZ] %s %s %s\n",
#endif
d97 1
a97 7
	while ((c = getopt(argc, argv, OPTS)) != -1)
		if (c == '?')
			usage();

	optreset = 1;
	optind = 1;
	while ((c = getopt(argc, argv, OPTS)) != -1) {
d100 7
a134 1
			opts |= OPT_OUTQUE;
d187 1
a187 1
			if ((fd = open(ipfname, O_RDONLY)) == -1)
d205 1
a205 1
		perror("SIOCFRENB");
d216 7
a222 2
		if (ioctl(fd, SIOCFRENB, &enable) == -1)
			perror("SIOCFRENB");
d257 1
a257 2
	while (getline(line, sizeof(line), fp)) {
	        linenum++;
d299 2
a300 1
				if (ioctl(fd, add, fr) == -1)
d302 1
a302 1
				else {
d305 2
d309 1
a310 1
						fr->fr_hits, fr->fr_bytes);
d315 4
a318 2
				if (ioctl(fd, del, fr) == -1)
					perror("ioctl(SIOCDELFR)");
d320 4
a323 2
				if (ioctl(fd, add, fr) == -1)
					perror("ioctl(SIOCADDFR)");
d339 1
a339 1
static char *getline(str, size, file)
d343 1
d349 1
a349 1
		for (p = str, s = size;; p += len, s -= len) {
d357 5
d363 1
a363 1
			if (p[len - 1] != '\\')
d365 6
a370 1
			size -= len;
d372 1
a372 1
	} while (*str == '\0' || *str == '\n');
d486 1
d489 1
a489 1
		if (ioctl(fd, SIOCFRZST, &fio) == -1) {
d493 1
a493 1
		showstats(&fio);
d561 1
d564 1
d566 6
a571 1
	printf("ipf: %s (%d)\n", IPL_VERSION, sizeof(frentry_t));
d573 3
a575 2
	if (opendevice(ipfname) != -2 && ioctl(fd, SIOCGETFS, &fio)) {
		perror("ioctl(SIOCGETFS");
d578 1
@


1.23
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a41 1
#include <netinet/ip_state.h>
@


1.22
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d48 1
a48 1
static const char rcsid[] = "@@(#)$IPFilter: ipf.c,v 2.2 1999/08/06 15:26:08 darrenr Exp $";
d368 2
a369 2
	err = get_flags();
	if (err != 0) {
@


1.21
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.20
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 2.2 1999/08/06 15:26:08 darrenr Exp $";
@


1.19
log
@Option -U is solaris only. Pointed out by theo.
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.18 1999/03/06 23:18:23 deraadt Exp $      */
d38 1
a38 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d40 2
d43 1
d47 1
a47 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 1.18 1999/03/06 23:18:23 deraadt Exp $";
a49 1
static	void	frsync __P((void));
d61 1
d76 3
d81 1
a81 1
#define OPTS	"AdDEf:F:Il:noPrsUvyzZ"
d83 1
a83 1
#define OPTS	"AdDEf:F:Il:noPrsvyzZ"
d86 1
a86 1
void usage()
d89 1
a89 1
	fprintf(stderr, "usage: ipf [-AdDEInorsUvyzZ] [-l block|pass|nomatch] "
d91 1
a91 1
	fprintf(stderr, "usage: ipf [-AdDEInorsvyzZ] [-l block|pass|nomatch] "
d93 1
a93 1
	    "[-F i|o|a|s|S] [-f filename]\n");
d97 1
d160 3
d207 12
d234 2
a235 1
	u_int	add = SIOCADAFR, del = SIOCRMAFR;
d242 3
d260 1
d278 1
a278 1
		fr = parse(line);
d365 1
a365 5
	int	err, flag = 0;

	if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE) {
		if ((err = ioctl(fd, SIOCGETFF, &flag)))
			perror("ioctl(SIOCGETFF)");
d367 4
a370 1
		printf("log flag is currently %#x\n", flag);
d395 1
a395 3
		if ((err = ioctl(fd, SIOCGETFF, &flag)))
			perror("ioctl(SIOCGETFF)");

d457 1
a457 1
static void frsync()
d518 1
a518 1
	int	flag;
d523 2
a524 4
	if ((opts & (OPT_DONOTHING|OPT_VERBOSE)) == OPT_VERBOSE) {
		if (ioctl(fd, SIOCGETFF, &flag))
			perror("ioctl(SIOCGETFF)");

a525 1
	}
d540 51
@


1.18
log
@match usage and man page
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.17 1999/02/08 18:58:59 millert Exp $      */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 1.17 1999/02/08 18:58:59 millert Exp $";
d78 1
d80 3
d86 1
d88 3
@


1.17
log
@back out last change, there was a reason for the dual getopt, ugly as it is...
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.15 1999/02/08 06:23:26 millert Exp $      */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 1.15 1999/02/08 06:23:26 millert Exp $";
d83 1
a83 1
	    "[-F i|o|a|s|S] -f file ...\n");
@


1.16
log
@no real point in calling getopt() twice
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.14 1999/02/07 00:55:16 deraadt Exp $      */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 1.14 1999/02/07 00:55:16 deraadt Exp $";
d60 2
d93 6
a156 3
			break;
		default :
			usage();
@


1.15
log
@If you are going to set optreset, you need to set optind to 1 as well.
@
text
@a59 1
extern	int	optreset;
a90 6
	while ((c = getopt(argc, argv, OPTS)) != -1)
		if (c == '?')
			usage();

	optreset = 1;
	optind = 1;
d149 3
@


1.14
log
@add usage() support using optreset
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.13 1999/02/05 05:58:42 deraadt Exp $      */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 1.13 1999/02/05 05:58:42 deraadt Exp $";
d97 1
@


1.13
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.12 1998/09/15 09:55:44 pattonme Exp $      */
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 1.12 1998/09/15 09:55:44 pattonme Exp $";
d60 1
d77 9
d92 6
a97 1
	while ((c = getopt(argc, argv, "AdDEf:F:Il:noPrsUvyzZ")) != -1) {
@


1.12
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*     $OpenBSD: ipf.c,v 1.11 1998/01/26 04:13:35 dgregor Exp $      */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id$";
@


1.11
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*     $OpenBSD$      */
d38 6
a43 2
#include "ip_fil_compat.h"
#include "ip_fil.h"
d48 1
a48 1
static const char rcsid[] = "@@(#)$Id: ipf.c,v 2.0.2.13.2.2 1997/11/06 21:23:36 darrenr Exp $";
d212 1
a212 1
	while (getline(line, sizeof(line)-1, fp)) {
d214 1
a214 1
		 * treat both CR and LF as EOL
a215 2
		if ((s = index(line, '\n')))
			*s = '\0';
d228 1
a228 1
			(void)fprintf(stderr, "[%s]\n",line);
d275 5
d284 2
a285 1
 * Similar to fgets(3) but can handle '\\'
d292 2
a293 2
	register char *p;
	register int len;
d296 7
a302 3
		for (p = str; ; p += strlen(p) - 1) {
			if (!fgets(p, size, file))
				return(NULL);
d310 1
a310 1
	return(str);
d414 3
a416 1
	if (opendevice(ipfname) != -2 && ioctl(fd, SIOCFRSYN, 0) == -1)
@


1.10
log
@version 1.3.8
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d9 3
a19 3
#if !defined(__SVR4) && defined(__GNUC__) && !defined(__OpenBSD__)
extern	char	*index();
#endif
a23 1
#include <unistd.h>
d29 1
d31 3
a34 2
#include "ip_fil_compat.h"
#include "ip_fil.h"
d38 2
d42 3
a44 3
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)ipf.c	1.23 6/5/96 (C) 1993-1995 Darren Reed";
static	char	rcsid[] = "$DRId: ipf.c,v 2.0.1.2 1997/02/04 14:37:46 darrenr Exp $";
d47 1
d49 4
a52 1
void	frsync(), blockunknown();
a53 1
void	zerostats();
d57 3
d64 7
a70 3
static	void	procfile(), flushfilter(), set_state();
static	void	packetlogon(), swapactive(), showstats();
static	char   *getline();
d76 1
a76 1
	char	c;
d78 1
a78 1
	while ((c = getopt(argc, argv, "AdDEf:F:Il:noprsUvyzZ")) != -1) {
d81 3
d85 1
a85 1
			set_state(1);
d88 1
a88 4
			set_state(0);
			break;
		case 'A' :
			opts &= ~OPT_INACTIVE;
d111 2
a112 2
		case 'p' :
			opts |= OPT_PRINTFR;
a127 1
#if SOLARIS
a130 1
#endif
d148 2
a149 1
static int opendevice()
d154 3
d158 2
a159 2
		if ((fd = open(IPL_NAME, O_RDWR)) == -1)
			if ((fd = open(IPL_NAME, O_RDONLY)) == -1)
d165 7
d175 1
a175 1
	if (opendevice() != -2)
d189 1
a189 1
	(void) opendevice();
d212 1
a212 1
		if ((s = strchr(line, '\n')))
d214 1
a214 1
		if ((s = strchr(line, '\r')))
d219 1
a219 1
		if ((s = strchr(line, '#')))
d235 2
a236 1
				add = fr->fr_hits ? SIOCINIFR : SIOCADIFR;
d238 2
a239 1
				add = fr->fr_hits ? SIOCINAFR : SIOCADAFR;
d255 3
d259 1
d285 1
d288 1
a288 1
		for (p = str;; p+= strlen(p) - 1) {
d291 3
a293 2
			p[strlen(p) -1] = '\0';
			if (p[strlen(p) - 1] != '\\')
d295 1
d316 1
a316 1
	if (strchr(opt, 'p')) {
d321 1
a321 1
	if (strchr(opt, 'm') && (*opt == 'n' || *opt == 'N')) {
d326 1
a326 1
	if (strchr(opt, 'b') || strchr(opt, 'd')) {
d332 1
a332 1
	if (opendevice() != -2 && (err = ioctl(fd, SIOCSETFF, &flag)))
d351 18
d378 1
a378 1
	if (opendevice() != -2 && ioctl(fd, SIOCIPFFL, &fl) == -1)
d393 1
a393 1
	if (opendevice() != -2 && ioctl(fd, SIOCSWAPA, &in) == -1)
d400 1
a400 2
#if defined(sun) && (defined(__SVR4) || defined(__svr4__))
void frsync()
d402 1
a402 1
	if (opendevice() != -2 && ioctl(fd, SIOCFRSYN, 0) == -1)
a406 1
#endif
d413 1
a413 1
	if (opendevice() != -2) {
d457 1
a457 1
void blockunknown()
d461 1
a461 1
	if (opendevice() == -1)
d473 1
a473 1
	if (opendevice() != -2 && ioctl(fd, SIOCSETFF, &flag))
@


1.9
log
@getopt & int
@
text
@d1 1
d17 3
d39 1
a39 1
#ifndef	lint
d41 1
a41 1
static	char	rcsid[] = "$Id: ipf.c,v 1.8 1997/01/17 07:12:16 millert Exp $";
d45 1
a45 1
void	frsync();
d57 1
d63 1
a63 1
	int	c;
d65 1
a65 1
	while ((c = getopt(argc, argv, "AsInopvdryf:F:l:EDzZ")) != -1) {
d107 5
d181 1
a181 1
		fprintf(stderr, "%s: fopen(%s) failed: %s", name, file,
d186 1
a186 1
	while (fgets(line, sizeof(line)-1, fp)) {
d230 2
a231 2
				else
					printf("hits %d bytes %d\n",
d233 2
d248 22
d274 1
a274 1
	int	err, flag;
d283 1
a283 1
	flag = 0;
d407 30
@


1.8
log
@r?index -> strr?chr
@
text
@d37 1
a37 1
static	char	rcsid[] = "$Id: ipf.c,v 1.7 1996/10/08 07:33:31 niklas Exp $";
d58 1
a58 1
	char	c;
@


1.7
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@a15 3
#if !defined(__SVR4) && defined(__GNUC__)
extern	char	*index();
#endif
d37 1
a37 1
static	char	rcsid[] = "$Id: ipf.c,v 1.6 1996/07/21 16:40:04 dm Exp $";
d180 1
a180 1
		if ((s = index(line, '\n')))
d182 1
a182 1
		if ((s = index(line, '\r')))
d187 1
a187 1
		if ((s = index(line, '#')))
d251 1
a251 1
	if (index(opt, 'p')) {
d256 1
a256 1
	if (index(opt, 'm') && (*opt == 'n' || *opt == 'N')) {
d261 1
a261 1
	if (index(opt, 'b') || index(opt, 'd')) {
@


1.6
log
@Correct fix for -Fa brokenness.
@
text
@d31 1
d40 1
a40 1
static	char	rcsid[] = "$Id: ipf.c,v 1.5 1996/07/18 05:11:01 dm Exp $";
@


1.5
log
@ipfilter 3.1.0
@
text
@d39 1
a39 1
static	char	rcsid[] = "$Id: ipf.c,v 1.2 1996/07/04 13:22:13 darrenr Exp $";
d297 1
a297 1
	if (opendevice() == -2 || ioctl(fd, SIOCIPFFL, &fl) == -1)
@


1.4
log
@update rcsid
@
text
@a0 2
/*	$OpenBSD$	*/

d12 1
d38 2
a39 1
static	char	sccsid[] = "@@(#)ipf.c	1.22 2/3/96 (C) 1993-1995 Darren Reed";
d52 1
d54 1
a54 1
static	void	packetlogon(), swapactive();
d62 1
a62 4
	if ((fd = open(IPL_NAME, O_RDONLY)) == -1)
		perror("open device");

	while ((c = getopt(argc, argv, "AsInovdryf:F:l:EDZ")) != -1)
d78 1
a78 1
			procfile(optarg);
d95 3
d112 3
d119 1
d123 3
a125 1
	return 0;
d128 14
d145 3
a147 2
	if (ioctl(fd, SIOCFRENB, &enable) == -1)
		perror("SIOCFRENB");
d151 2
a152 2
static	void	procfile(file)
char	*file;
d159 2
d173 3
a175 2
		perror("fopen");
		exit(1);;
d202 3
a204 1
			if (opts & OPT_INACTIVE)
d217 10
a226 2
				
			if ((opts & OPT_REMOVE) && !(opts & OPT_DONOTHING)) {
d244 1
a244 1
	if (opts & OPT_VERBOSE) {
d269 1
a269 2
	if (!(opts & OPT_DONOTHING) &&
	    (err = ioctl(fd, SIOCSETFF, &flag)))
d272 1
a272 1
	if (opts & OPT_VERBOSE) {
d297 1
a297 1
	if (!(opts & OPT_DONOTHING) && ioctl(fd, SIOCIPFFL, &fl) == -1)
d299 1
a299 1
	if (opts & OPT_VERBOSE){
d312 1
a312 1
	if (ioctl(fd, SIOCSWAPA, &in) == -1)
d322 1
a322 1
	if (ioctl(fd, SIOCFRSYN, 0) == -1)
d332 1
a332 1
	struct	friostat	fio;
d334 6
a339 3
	if (ioctl(fd, SIOCFRZST, &fio) == -1) {
		perror("ioctl(SIOCFRZST)");
		exit(-1);
d342 32
@


1.3
log
@ipfilter 3.0.4
@
text
@d1 2
@


1.2
log
@IP filter 3.0.1
@
text
@d37 1
a37 1
static	char	sccsid[] = "@@(#)ipf.c	1.21 1/14/96 (C) 1993-1995 Darren Reed";
d141 2
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d30 1
a30 1
#include <netinet/ip_fil.h>
d37 1
a37 1
static	char	sccsid[] = "@@(#)ipf.c	1.18 11/11/95 (C) 1993-1995 Darren Reed";
d40 5
d104 1
a104 1
#if defined(sun) && (defined(__SVR4) || defined(__svr4__))
d144 4
a147 2
	else if (!(fp = fopen(file, "r")))
		return;
d219 5
d250 1
a250 1
	if (*arg == 'i' || *arg == 'I')
d252 1
a252 1
	else if (*arg == 'o' || *arg == 'O')
d254 1
a254 1
	else if (*arg == 'a' || *arg == 'A')
d282 1
a282 1
frsync()
d292 1
a292 1
zerostats()
@
