head	1.39;
access;
symbols
	OPENBSD_2_9:1.38.0.2
	OPENBSD_2_9_BASE:1.38
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	OPENBSD_2_6:1.26.0.2
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.39
date	2001.05.30.02.11.42;	author deraadt;	state dead;
branches;
next	1.38;

1.38
date	2001.01.30.04.26.02;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.20.06.36.52;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.17.05.00.59;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.10.05.50.27;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.05.05.35.28;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.13.23.40.19;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.16.22.34.21;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.01.19.30.00;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	99.12.28.08.30.31;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	99.12.17.06.17.08;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	99.12.16.07.38.45;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	99.12.15.05.20.24;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	99.07.06.04.38.11;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.07.05.20.12.44;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	99.06.06.20.34.55;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.02.05.05.58.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.11.24.03.05.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.09.15.09.55.45;	author pattonme;	state Exp;
branches;
next	1.20;

1.20
date	98.07.09.06.12.23;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.02.27.19.37.35;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.01.26.04.13.38;	author dgregor;	state Exp;
branches;
next	1.17;

1.17
date	97.11.24.03.25.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.08.24.18.29.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.06.24.05.37.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.06.23.17.20.31;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.06.23.01.16.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.04.19.19.08.29;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.04.06.19.52.11;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.02.26.15.05.36;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.02.26.04.35.40;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.17.07.12.18;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.08.07.33.32;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.07.18.05.11.03;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.16.48.44;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.30.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.39.53;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.28;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.33.34;	author dm;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: parse.c,v 1.38 2001/01/30 04:26:02 kjell Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#include <sys/types.h>
#if !defined(__SVR4) && !defined(__svr4__)
#include <strings.h>
#else
#include <sys/byteorder.h>
#endif
#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <net/if.h>
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
#endif
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <netdb.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <resolv.h>
#include <ctype.h>
#include <syslog.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include "ipf.h"
#include "facpri.h"

#if !defined(lint)
static const char sccsid[] = "@@(#)parse.c	1.44 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: parse.c,v 2.8 1999/12/28 10:49:46 darrenr Exp $";
#endif

extern	struct	ipopt_names	ionames[], secclass[];
extern	int	opts;
#ifdef	USE_INET6
extern	int	use_inet6;
#endif

int	addicmp __P((char ***, struct frentry *, int));
int	extras __P((char ***, struct frentry *, int));

int	icmpcode __P((char *)), addkeep __P((char ***, struct frentry *, int));
int	to_interface __P((frdest_t *, char *, int));
void	print_toif __P((char *, frdest_t *));
void	optprint __P((u_short *, u_long, u_long));
int	loglevel __P((char **, u_int *, int));
void	printlog __P((frentry_t *));

extern	char	*proto;
extern	char	flagset[];
extern	u_char	flags[];


/* parse()
 *
 * parse a line read from the input filter rule file
 */
struct	frentry	*parse(line, linenum)
char	*line;
int     linenum;
{
	static	struct	frentry	fil;
	struct	protoent	*p = NULL;
	char	*cps[31], **cpp, *endptr;
	int	i, cnt = 1, j, ch;
	u_int	k;

	while (*line && isspace(*line))
		line++;
	if (!*line)
		return NULL;

	bzero((char *)&fil, sizeof(fil));
	fil.fr_mip.fi_v = 0xf;
#ifdef	USE_INET6
	fil.fr_ip.fi_v = use_inet6 ? 6 : 4;
#else
	fil.fr_ip.fi_v = 4;
#endif
	fil.fr_loglevel = 0xffff;

	/*
	 * break line up into max of 20 segments
	 */
	if (opts & OPT_DEBUG)
		fprintf(stderr, "parse [%s]\n", line);
	for (i = 0, *cps = strtok(line, " \b\t\r\n"); cps[i] && i < 30; cnt++)
		cps[++i] = strtok(NULL, " \b\t\r\n");
	cps[i] = NULL;

	if (cnt < 3) {
		fprintf(stderr, "%d: not enough segments in line\n", linenum);
		return NULL;
	}

	cpp = cps;
	if (**cpp == '@@')
		fil.fr_hits = (U_QUAD_T)atoi(*cpp++ + 1) + 1;


	if (!strcasecmp("block", *cpp)) {
		fil.fr_flags |= FR_BLOCK;
		if (!strncasecmp(*(cpp+1), "return-icmp-as-dest", 19) &&
		    (i = 19))
			fil.fr_flags |= FR_FAKEICMP;
		else if (!strncasecmp(*(cpp+1), "return-icmp", 11) && (i = 11))
			fil.fr_flags |= FR_RETICMP;
		if (fil.fr_flags & FR_RETICMP) {
			cpp++;
			if (strlen(*cpp) == i) {
				if (*(cpp + 1) && **(cpp +1) == '(') {
					cpp++;
					i = 0;
				} else
					i = -1;
			}

			/*
			 * The ICMP code is not required to follow in ()'s
			 */
			if ((i >= 0) && (*(*cpp + i) == '(')) {
				i++;
				j = icmpcode(*cpp + i);
				if (j == -1) {
					fprintf(stderr,
					"%d: unrecognised icmp code %s\n",
						linenum, *cpp + 20);
					return NULL;
				}
				fil.fr_icode = j;
			}
		} else if (!strncasecmp(*(cpp+1), "return-rst", 10)) {
			fil.fr_flags |= FR_RETRST;
			cpp++;
		}
	} else if (!strcasecmp("count", *cpp)) {
		fil.fr_flags |= FR_ACCOUNT;
	} else if (!strcasecmp("pass", *cpp)) {
		fil.fr_flags |= FR_PASS;
	} else if (!strcasecmp("auth", *cpp)) {
		 fil.fr_flags |= FR_AUTH;
	} else if (!strcasecmp("preauth", *cpp)) {
		 fil.fr_flags |= FR_PREAUTH;
	} else if (!strcasecmp("skip", *cpp)) {
		cpp++;
		if (ratoui(*cpp, &k, 0, UINT_MAX))
			fil.fr_skip = k;
		else {
			fprintf(stderr, "%d: integer must follow skip\n",
				linenum);
			return NULL;
		}
	} else if (!strcasecmp("log", *cpp)) {
		fil.fr_flags |= FR_LOG;
		if (!strcasecmp(*(cpp+1), "body")) {
			fil.fr_flags |= FR_LOGBODY;
			cpp++;
		}
		if (!strcasecmp(*(cpp+1), "first")) {
			fil.fr_flags |= FR_LOGFIRST;
			cpp++;
		}
		if (*cpp && !strcasecmp(*(cpp+1), "or-block")) {
			fil.fr_flags |= FR_LOGORBLOCK;
			cpp++;
		}
		if (!strcasecmp(*(cpp+1), "level")) {
			cpp++;
			if (loglevel(cpp, &fil.fr_loglevel, linenum) == -1)
				return NULL;
			cpp++;
		}
	} else {
		/*
		 * Doesn't start with one of the action words
		 */
		fprintf(stderr, "%d: unknown keyword (%s)\n", linenum, *cpp);
		return NULL;
	}
	if (!*++cpp) {
		fprintf(stderr, "%d: missing 'in'/'out' keyword\n", linenum);
		return NULL;
	}

	if (!strcasecmp("in", *cpp))
		fil.fr_flags |= FR_INQUE;
	else if (!strcasecmp("out", *cpp)) {
		fil.fr_flags |= FR_OUTQUE;
		if (fil.fr_flags & FR_RETICMP) {
			fprintf(stderr,
				"%d: Can only use return-icmp with 'in'\n",
				linenum);
			return NULL;
		} else if (fil.fr_flags & FR_RETRST) {
			fprintf(stderr,
				"%d: Can only use return-rst with 'in'\n", 
				linenum);
			return NULL;
		}
	}
	if (!*++cpp) {
		fprintf(stderr, "%d: missing source specification\n", linenum);
		return NULL;
	}

	if (!strcasecmp("log", *cpp)) {
		if (!*++cpp) {
			fprintf(stderr, "%d: missing source specification\n",
				linenum);
			return NULL;
		}
		if (fil.fr_flags & FR_PASS)
			fil.fr_flags |= FR_LOGP;
		else if (fil.fr_flags & FR_BLOCK)
			fil.fr_flags |= FR_LOGB;
		if (*cpp && !strcasecmp(*cpp, "body")) {
			fil.fr_flags |= FR_LOGBODY;
			cpp++;
		}
		if (*cpp && !strcasecmp(*cpp, "first")) {
			fil.fr_flags |= FR_LOGFIRST;
			cpp++;
		}
		if (*cpp && !strcasecmp(*cpp, "or-block")) {
			if (!(fil.fr_flags & FR_PASS)) {
				fprintf(stderr,
					"%d: or-block must be used with pass\n",
					linenum);
				return NULL;
			}
			fil.fr_flags |= FR_LOGORBLOCK;
			cpp++;
		}
		if (*cpp && !strcasecmp(*cpp, "level")) {
			if (loglevel(cpp, &fil.fr_loglevel, linenum) == -1)
				return NULL;
			cpp++;
			cpp++;
		}
	}

	if (*cpp && !strcasecmp("quick", *cpp)) {
		cpp++;
		fil.fr_flags |= FR_QUICK;
	}

	*fil.fr_ifname = '\0';
	if (*cpp && !strcasecmp(*cpp, "on")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: interface name missing\n",
				linenum);
			return NULL;
		}
		(void)strncpy(fil.fr_ifname, *cpp, IFNAMSIZ-1);
		fil.fr_ifname[IFNAMSIZ-1] = '\0';
		cpp++;
		if (!*cpp) {
			if ((fil.fr_flags & FR_RETMASK) == FR_RETRST) {
				fprintf(stderr,
					"%d: %s can only be used with TCP\n",
					linenum, "return-rst");
				return NULL;
			}
			return &fil;
		}

		if (*cpp) {
			if (!strcasecmp(*cpp, "dup-to") && *(cpp + 1)) {
				cpp++;
				if (to_interface(&fil.fr_dif, *cpp, linenum))
					return NULL;
				cpp++;
			}
			if (*cpp && !strcasecmp(*cpp, "to") && *(cpp + 1)) {
				cpp++;
				if (to_interface(&fil.fr_tif, *cpp, linenum))
					return NULL;
				cpp++;
			} else if (*cpp && !strcasecmp(*cpp, "fastroute")) {
				if (!(fil.fr_flags & FR_INQUE)) {
					fprintf(stderr,
						"can only use %s with 'in'\n",
						"fastroute");
					return NULL;
				}
				fil.fr_flags |= FR_FASTROUTE;
				cpp++;
			}
		}
	}
	if (*cpp && !strcasecmp(*cpp, "tos")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: tos missing value\n", linenum);
			return NULL;
		}
		fil.fr_tos = strtol(*cpp, NULL, 0);
		fil.fr_mip.fi_tos = 0xff;
		cpp++;
	}

	if (*cpp && !strcasecmp(*cpp, "ttl")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: ttl missing hopcount value\n",
				linenum);
			return NULL;
		}
		if (ratoi(*cpp, &i, 0, 255))
			fil.fr_ttl = i;
		else {
			fprintf(stderr, "%d: invalid ttl (%s)\n",
				linenum, *cpp);
			return NULL;
		}
		fil.fr_mip.fi_ttl = 0xff;
		cpp++;
	}

	/*
	 * check for "proto <protoname>" only decode udp/tcp/icmp as protoname
	 */
	proto = NULL;
	if (*cpp && !strcasecmp(*cpp, "proto")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: protocol name missing\n", linenum);
			return NULL;
		}
		proto = *cpp++;
		if (!strcasecmp(proto, "tcp/udp")) {
			fil.fr_ip.fi_fl |= FI_TCPUDP;
			fil.fr_mip.fi_fl |= FI_TCPUDP;
		} else {
			if (!(p = getprotobyname(proto)) && !isdigit(*proto)) {
				fprintf(stderr,
					"%d: unknown protocol (%s)\n",
					linenum, proto);
				return NULL;
			}
			if (p)
				fil.fr_proto = p->p_proto;
			else if (isdigit(*proto)) {
				i = (int)strtol(proto, &endptr, 0);
				if (*endptr != '\0' || i < 0 || i > 255) {
					fprintf(stderr,
						"%d: unknown protocol (%s)\n",
						linenum, proto);
					return NULL;		
				}
				fil.fr_proto = i;
			}
			fil.fr_mip.fi_p = 0xff;
		}
	}
	if ((fil.fr_proto != IPPROTO_TCP) &&
	    ((fil.fr_flags & FR_RETMASK) == FR_RETRST)) {
		fprintf(stderr, "%d: %s can only be used with TCP\n",
			linenum, "return-rst");
		return NULL;
	}

	/*
	 * get the from host and bit mask to use against packets
	 */

	if (!*cpp) {
		fprintf(stderr, "%d: missing source specification\n", linenum);
		return NULL;
	}
	if (!strcasecmp(*cpp, "all")) {
		cpp++;
		if (!*cpp)
			return &fil;
	} else {
		if (strcasecmp(*cpp, "from")) {
			fprintf(stderr, "%d: unexpected keyword (%s) - from\n",
				linenum, *cpp);
			return NULL;
		}
		if (!*++cpp) {
			fprintf(stderr, "%d: missing host after from\n",
				linenum);
			return NULL;
		}
		if (**cpp == '!') {
			fil.fr_flags |= FR_NOTSRCIP;
			(*cpp)++;
		}
		ch = 0;
		if (hostmask(&cpp, (u_32_t *)&fil.fr_src,
			     (u_32_t *)&fil.fr_smsk, &fil.fr_sport, &ch,
			     &fil.fr_stop, linenum)) {
			return NULL;
		}

		fil.fr_scmp = ch;
		if (!*cpp) {
			fprintf(stderr, "%d: missing to fields\n", linenum);
			return NULL;
		}

		/*
		 * do the same for the to field (destination host)
		 */
		if (strcasecmp(*cpp, "to")) {
			fprintf(stderr, "%d: unexpected keyword (%s) - to\n",
				linenum, *cpp);
			return NULL;
		}
		if (!*++cpp) {
			fprintf(stderr, "%d: missing host after to\n", linenum);
			return NULL;
		}
		ch = 0;
		if (**cpp == '!') {
			fil.fr_flags |= FR_NOTDSTIP;
			(*cpp)++;
		}
		if (hostmask(&cpp, (u_32_t *)&fil.fr_dst,
			     (u_32_t *)&fil.fr_dmsk, &fil.fr_dport, &ch,
			     &fil.fr_dtop, linenum)) {
			return NULL;
		}
		fil.fr_dcmp = ch;
	}

	/*
	 * check some sanity, make sure we don't have icmp checks with tcp
	 * or udp or visa versa.
	 */
	if (fil.fr_proto && (fil.fr_dcmp || fil.fr_scmp) &&
	    fil.fr_proto != IPPROTO_TCP && fil.fr_proto != IPPROTO_UDP) {
		fprintf(stderr, "%d: port operation on non tcp/udp\n", linenum);
		return NULL;
	}
	if (fil.fr_icmp && fil.fr_proto != IPPROTO_ICMP) {
		fprintf(stderr, "%d: icmp comparisons on wrong protocol\n",
			linenum);
		return NULL;
	}

	if (!*cpp)
		return &fil;

	if (*cpp && !strcasecmp(*cpp, "flags")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: no flags present\n", linenum);
			return NULL;
		}
		fil.fr_tcpf = tcp_flags(*cpp, &fil.fr_tcpfm, linenum);
		cpp++;
	}

	/*
	 * extras...
	 */
	if ((fil.fr_v == 4) && *cpp && (!strcasecmp(*cpp, "with") ||
	     !strcasecmp(*cpp, "and")))
		if (extras(&cpp, &fil, linenum))
			return NULL;

	/*
	 * icmp types for use with the icmp protocol
	 */
	if (*cpp && !strcasecmp(*cpp, "icmp-type")) {
		if (fil.fr_proto != IPPROTO_ICMP) {
			fprintf(stderr,
				"%d: icmp with wrong protocol (%d)\n",
				linenum, fil.fr_proto);
			return NULL;
		}
		if (addicmp(&cpp, &fil, linenum))
			return NULL;
		fil.fr_icmp = htons(fil.fr_icmp);
		fil.fr_icmpm = htons(fil.fr_icmpm);
	}

	/*
	 * Keep something...
	 */
	while (*cpp && !strcasecmp(*cpp, "keep"))
		if (addkeep(&cpp, &fil, linenum))
			return NULL;

	/*
	 * head of a new group ?
	 */
	if (*cpp && !strcasecmp(*cpp, "head")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: head without group #\n", linenum);
			return NULL;
		}
		if (ratoui(*cpp, &k, 0, UINT_MAX))
			fil.fr_grhead = (u_32_t)k;
		else {
			fprintf(stderr, "%d: invalid group (%s)\n",
				linenum, *cpp);
			return NULL;
		}
		cpp++;
	}

	/*
	 * head of a new group ?
	 */
	if (*cpp && !strcasecmp(*cpp, "group")) {
		if (!*++cpp) {
			fprintf(stderr, "%d: group without group #\n",
				linenum);
			return NULL;
		}
		if (ratoui(*cpp, &k, 0, UINT_MAX))
			fil.fr_group = k;
		else {
			fprintf(stderr, "%d: invalid group (%s)\n",
				linenum, *cpp);
			return NULL;
		}
		cpp++;
	}

	/*
	 * leftovers...yuck
	 */
	if (*cpp && **cpp) {
		fprintf(stderr, "%d: unknown words at end: [", linenum);
		for (; *cpp; cpp++)
			fprintf(stderr, "%s ", *cpp);
		fprintf(stderr, "]\n");
		return NULL;
	}

	/*
	 * lazy users...
	 */
	if ((fil.fr_tcpf || fil.fr_tcpfm) && fil.fr_proto != IPPROTO_TCP) {
		fprintf(stderr, "%d: TCP protocol not specified\n", linenum);
		return NULL;
	}
	if (!(fil.fr_ip.fi_fl & FI_TCPUDP) && (fil.fr_proto != IPPROTO_TCP) &&
	    (fil.fr_proto != IPPROTO_UDP) && (fil.fr_dcmp || fil.fr_scmp)) {
		if (!fil.fr_proto) {
			fil.fr_ip.fi_fl |= FI_TCPUDP;
			fil.fr_mip.fi_fl |= FI_TCPUDP;
		} else {
			fprintf(stderr,
				"%d: port comparisons for non-TCP/UDP\n",
				linenum);
			return NULL;
		}
	}
/*
	if ((fil.fr_flags & FR_KEEPFRAG) &&
	    (!(fil.fr_ip.fi_fl & FI_FRAG) || !(fil.fr_ip.fi_fl & FI_FRAG))) {
		fprintf(stderr,
			"%d: must use 'with frags' with 'keep frags'\n",
			linenum);
		return NULL;
	}
*/
	return &fil;
}


int loglevel(cpp, facpri, linenum)
char **cpp;
u_int *facpri;
int linenum;
{
	int fac, pri;
	char *s;

	fac = 0;
	pri = 0;
	if (!*++cpp) {
		fprintf(stderr, "%d: %s\n", linenum,
			"missing identifier after level");
		return -1;
	}

	s = index(*cpp, '.');
	if (s) {
		*s++ = '\0';
		fac = fac_findname(*cpp);
		if (fac == -1) {
			fprintf(stderr, "%d: %s %s\n", linenum,
				"Unknown facility", *cpp);
			return -1;
		}
		pri = pri_findname(s);
		if (pri == -1) {
			fprintf(stderr, "%d: %s %s\n", linenum,
				"Unknown priority", s);
			return -1;
		}
	} else {
		pri = pri_findname(*cpp);
		if (pri == -1) {
			fprintf(stderr, "%d: %s %s\n", linenum,
				"Unknown priority", *cpp);
			return -1;
		}
	}
	*facpri = fac|pri;
	return 0;
}


int to_interface(fdp, to, linenum)
frdest_t *fdp;
char *to;
int linenum;
{
	char *s;

	s = index(to, ':');
	fdp->fd_ifp = NULL;
	if (s) {
		*s++ = '\0';
		if (hostnum((u_32_t *)&fdp->fd_ip, s, linenum) == -1)
			return -1;
	}
	(void) strncpy(fdp->fd_ifname, to, sizeof(fdp->fd_ifname) - 1);
	fdp->fd_ifname[sizeof(fdp->fd_ifname) - 1] = '\0';
	return 0;
}


void print_toif(tag, fdp)
char *tag;
frdest_t *fdp;
{
	printf("%s %s%s", tag, fdp->fd_ifname,
		     (fdp->fd_ifp || (long)fdp->fd_ifp == -1) ? "" : "(!)");
	if (fdp->fd_ip.s_addr)
		printf(":%s", inet_ntoa(fdp->fd_ip));
	putchar(' ');
}


/*
 * deal with extra bits on end of the line
 */
int	extras(cp, fr, linenum)
char	***cp;
struct	frentry	*fr;
int     linenum;
{
	u_short	secmsk;
	u_long	opts;
	int	notopt;
	char	oflags;

	opts = 0;
	secmsk = 0;
	notopt = 0;
	(*cp)++;
	if (!**cp)
		return -1;

	while (**cp && (!strncasecmp(**cp, "ipopt", 5) ||
	       !strncasecmp(**cp, "not", 3) || !strncasecmp(**cp, "opt", 3) ||
	       !strncasecmp(**cp, "frag", 4) || !strncasecmp(**cp, "no", 2) ||
	       !strncasecmp(**cp, "short", 5))) {
		if (***cp == 'n' || ***cp == 'N') {
			notopt = 1;
			(*cp)++;
			continue;
		} else if (***cp == 'i' || ***cp == 'I') {
			if (!notopt)
				fr->fr_ip.fi_fl |= FI_OPTIONS;
			fr->fr_mip.fi_fl |= FI_OPTIONS;
			goto nextopt;
		} else if (***cp == 'f' || ***cp == 'F') {
			if (!notopt)
				fr->fr_ip.fi_fl |= FI_FRAG;
			fr->fr_mip.fi_fl |= FI_FRAG;
			goto nextopt;
		} else if (***cp == 'o' || ***cp == 'O') {
			if (!*(*cp + 1)) {
				fprintf(stderr,
					"%d: opt missing arguements\n",
					linenum);
				return -1;
			}
			(*cp)++;
			if (!(opts = optname(cp, &secmsk, linenum)))
				return -1;
			oflags = FI_OPTIONS;
		} else if (***cp == 's' || ***cp == 'S') {
			if (fr->fr_tcpf) {
				fprintf(stderr,
				"%d: short cannot be used with TCP flags\n",
					linenum);
				return -1;
			}

			if (!notopt)
				fr->fr_ip.fi_fl |= FI_SHORT;
			fr->fr_mip.fi_fl |= FI_SHORT;
			goto nextopt;
		} else
			return -1;

		if (!notopt || !opts)
			fr->fr_mip.fi_fl |= oflags;
		if (notopt) {
		  if (!secmsk) {
				fr->fr_mip.fi_optmsk |= opts;
		  } else {
				fr->fr_mip.fi_optmsk |= (opts & ~0x0100);
		  }
		} else {
				fr->fr_mip.fi_optmsk |= opts;
		}
		fr->fr_mip.fi_secmsk |= secmsk;

		if (notopt) {
			fr->fr_ip.fi_fl &= (~oflags & 0xf);
			fr->fr_ip.fi_optmsk &= ~opts;
			fr->fr_ip.fi_secmsk &= ~secmsk;
		} else {
			fr->fr_ip.fi_fl |= oflags;
			fr->fr_ip.fi_optmsk |= opts;
			fr->fr_ip.fi_secmsk |= secmsk;
		}
nextopt:
		notopt = 0;
		opts = 0;
		oflags = 0;
		secmsk = 0;
		(*cp)++;
	}
	return 0;
}


u_32_t optname(cp, sp, linenum)
char ***cp;
u_short *sp;
int linenum;
{
	struct ipopt_names *io, *so;
	u_long msk = 0;
	u_short smsk = 0;
	char *s;
	int sec = 0;

	for (s = strtok(**cp, ","); s; s = strtok(NULL, ",")) {
		for (io = ionames; io->on_name; io++)
			if (!strcasecmp(s, io->on_name)) {
				msk |= io->on_bit;
				break;
			}
		if (!io->on_name) {
			fprintf(stderr, "%d: unknown IP option name %s\n",
				linenum, s);
			return 0;
		}
		if (!strcasecmp(s, "sec-class"))
			sec = 1;
	}

	if (sec && !*(*cp + 1)) {
		fprintf(stderr, "%d: missing security level after sec-class\n",
			linenum);
		return 0;
	}

	if (sec) {
		(*cp)++;
		for (s = strtok(**cp, ","); s; s = strtok(NULL, ",")) {
			for (so = secclass; so->on_name; so++)
				if (!strcasecmp(s, so->on_name)) {
					smsk |= so->on_bit;
					break;
				}
			if (!so->on_name) {
				fprintf(stderr,
					"%d: no such security level: %s\n",
					linenum, s);
				return 0;
			}
		}
		if (smsk)
			*sp = smsk;
	}
	return msk;
}


#ifdef __STDC__
void optprint(u_short *sec, u_long optmsk, u_long optbits)
#else
void optprint(sec, optmsk, optbits)
u_short *sec;
u_long optmsk, optbits;
#endif
{
	u_short secmsk = sec[0], secbits = sec[1];
	struct ipopt_names *io, *so;
	char *s;
	int secflag = 0;

	s = " opt ";
	for (io = ionames; io->on_name; io++)
		if ((io->on_bit & optmsk) &&
		    ((io->on_bit & optmsk) == (io->on_bit & optbits))) {
			if ((io->on_value != IPOPT_SECURITY) ||
			    (!secmsk && !secbits)) {
				printf("%s%s", s, io->on_name);
				if (io->on_value == IPOPT_SECURITY)
					io++;
				s = ",";
			} else
				secflag = 1;
		}


	if (secmsk & secbits) {
		printf("%ssec-class", s);
		s = " ";
		for (so = secclass; so->on_name; so++)
			if ((secmsk & so->on_bit) &&
			    ((so->on_bit & secmsk) == (so->on_bit & secbits))) {
				printf("%s%s", s, so->on_name);
				s = ",";
			}
	}

	if ((optmsk && (optmsk != optbits)) ||
	    (secmsk && (secmsk != secbits))) {
		s = " ";
		printf(" not opt");
		if (optmsk != optbits) {
			for (io = ionames; io->on_name; io++)
				if ((io->on_bit & optmsk) &&
				    ((io->on_bit & optmsk) !=
				     (io->on_bit & optbits))) {
					if ((io->on_value != IPOPT_SECURITY) ||
					    (!secmsk && !secbits)) {
						printf("%s%s", s, io->on_name);
						s = ",";
						if (io->on_value ==
						    IPOPT_SECURITY)
							io++;
					} else
						io++;
				}
		}

		if (secmsk != secbits) {
			printf("%ssec-class", s);
			s = " ";
			for (so = secclass; so->on_name; so++)
				if ((so->on_bit & secmsk) &&
				    ((so->on_bit & secmsk) !=
				     (so->on_bit & secbits))) {
					printf("%s%s", s, so->on_name);
					s = ",";
				}
		}
	}
}

char	*icmptypes[] = {
	"echorep", (char *)NULL, (char *)NULL, "unreach", "squench",
	"redir", (char *)NULL, (char *)NULL, "echo", "routerad",
	"routersol", "timex", "paramprob", "timest", "timestrep",
	"inforeq", "inforep", "maskreq", "maskrep", "END"
};

/*
 * set the icmp field to the correct type if "icmp" word is found
 */
int	addicmp(cp, fp, linenum)
char	***cp;
struct	frentry	*fp;
int     linenum;
{
	char	**t;
	int	i;

	(*cp)++;
	if (!**cp)
		return -1;
	if (!fp->fr_proto)	/* to catch lusers */
		fp->fr_proto = IPPROTO_ICMP;
	if (isdigit(***cp)) {
		if (!ratoi(**cp, &i, 0, 255)) {
			fprintf(stderr,
				"%d: Invalid icmp-type (%s) specified\n",
				linenum, **cp);
			return -1;
		}
	} else {
		for (t = icmptypes, i = 0; ; t++, i++) {
			if (!*t)
				continue;
			if (!strcasecmp("END", *t)) {
				i = -1;
				break;
			}
			if (!strcasecmp(*t, **cp))
				break;
		}
		if (i == -1) {
			fprintf(stderr,
				"%d: Invalid icmp-type (%s) specified\n",
				linenum, **cp);
			return -1;
		}
	}
	fp->fr_icmp = (u_short)(i << 8);
	fp->fr_icmpm = (u_short)0xff00;
	(*cp)++;
	if (!**cp)
		return 0;

	if (**cp && strcasecmp("code", **cp))
		return 0;
	(*cp)++;
	if (isdigit(***cp)) {
		if (!ratoi(**cp, &i, 0, 255)) {
			fprintf(stderr, 
				"%d: Invalid icmp code (%s) specified\n",
				linenum, **cp);
			return -1;
		}
	} else {
		i = icmpcode(**cp);
		if (i == -1) {
			fprintf(stderr, 
				"%d: Invalid icmp code (%s) specified\n",
				linenum, **cp);
			return -1;
		}
	}
	i &= 0xff;
	fp->fr_icmp |= (u_short)i;
	fp->fr_icmpm = (u_short)0xffff;
	(*cp)++;
	return 0;
}


#define	MAX_ICMPCODE	15

char	*icmpcodes[] = {
	"net-unr", "host-unr", "proto-unr", "port-unr", "needfrag", "srcfail",
	"net-unk", "host-unk", "isolate", "net-prohib", "host-prohib",
	"net-tos", "host-tos", "filter-prohib", "host-preced", "preced-cutoff", 
	NULL };
/*
 * Return the number for the associated ICMP unreachable code.
 */
int icmpcode(str)
char *str;
{
	char	*s;
	int	i, len;

	if ((s = strrchr(str, ')')))
		*s = '\0';
	if (isdigit(*str)) {
		if (!ratoi(str, &i, 0, 255))
			return -1;
		else
			return i;
	}
	len = strlen(str);
	for (i = 0; icmpcodes[i]; i++)
		if (!strncasecmp(str, icmpcodes[i], MIN(len,
				 strlen(icmpcodes[i])) ))
			return i;
	return -1;
}


/*
 * set the icmp field to the correct type if "icmp" word is found
 */
int	addkeep(cp, fp, linenum)
char	***cp;
struct	frentry	*fp;
int     linenum; 
{
	if (fp->fr_proto != IPPROTO_TCP && fp->fr_proto != IPPROTO_UDP &&
#ifdef	USE_INET6
	    fp->fr_proto != IPPROTO_ICMPV6 &&
#endif
	    fp->fr_proto != IPPROTO_ICMP && !(fp->fr_ip.fi_fl & FI_TCPUDP)) {
		fprintf(stderr, "%d: Can only use keep with UDP/ICMP/TCP\n",
			linenum);
		return -1;
	}

	(*cp)++;
	if (!**cp) {
		fprintf(stderr, "%d: Missing state/frag after keep\n",
			linenum);
		return -1;
	}
	if (strcasecmp(**cp, "state") && strcasecmp(**cp, "frags")) {
		fprintf(stderr, "%d: Unrecognised state keyword \"%s\"\n",
			linenum, **cp);
		return -1;
	}

	if (***cp == 's' || ***cp == 'S')
		fp->fr_flags |= FR_KEEPSTATE;
	else if (***cp == 'f' || ***cp == 'F')
		fp->fr_flags |= FR_KEEPFRAG;
	(*cp)++;
	return 0;
}


/*
 * print the filter structure in a useful way
 */
void	printfr(fp)
struct	frentry	*fp;
{
	struct protoent	*p;
	u_short	sec[2];
	char *s;
	u_char *t;
	int pr;

	if (fp->fr_flags & FR_PASS)
		printf("pass");
	else if (fp->fr_flags & FR_BLOCK) {
		printf("block");
		if (fp->fr_flags & FR_RETICMP) {
			if ((fp->fr_flags & FR_RETMASK) == FR_FAKEICMP)
				printf(" return-icmp-as-dest");
			else if ((fp->fr_flags & FR_RETMASK) == FR_RETICMP)
				printf(" return-icmp");
			if (fp->fr_icode) {
				if (fp->fr_icode <= MAX_ICMPCODE)
					printf("(%s)",
						icmpcodes[(int)fp->fr_icode]);
				else
					printf("(%d)", fp->fr_icode);
			}
		} else if ((fp->fr_flags & FR_RETMASK) == FR_RETRST)
			printf(" return-rst");
	} else if ((fp->fr_flags & FR_LOGMASK) == FR_LOG) {
		printlog(fp);
	} else if (fp->fr_flags & FR_ACCOUNT)
		printf("count");
	else if (fp->fr_flags & FR_AUTH)
		printf("auth");
	else if (fp->fr_flags & FR_PREAUTH)
		printf("preauth");
	else if (fp->fr_skip)
		printf("skip %hu", fp->fr_skip);

	if (fp->fr_flags & FR_OUTQUE)
		printf(" out ");
	else
		printf(" in ");

	if (((fp->fr_flags & FR_LOGB) == FR_LOGB) ||
	    ((fp->fr_flags & FR_LOGP) == FR_LOGP)) {
		printlog(fp);
		putchar(' ');
	}

	if (fp->fr_flags & FR_QUICK)
		printf("quick ");

	if (*fp->fr_ifname) {
		printf("on %s%s ", fp->fr_ifname,
			(fp->fr_ifa || (long)fp->fr_ifa == -1) ? "" : "(!)");
		if (*fp->fr_dif.fd_ifname)
			print_toif("dup-to", &fp->fr_dif);
		if (*fp->fr_tif.fd_ifname)
			print_toif("to", &fp->fr_tif);
		if (fp->fr_flags & FR_FASTROUTE)
			printf("fastroute ");

	}
	if (fp->fr_mip.fi_tos)
		printf("tos %#x ", fp->fr_tos);
	if (fp->fr_mip.fi_ttl)
		printf("ttl %d ", fp->fr_ttl);
	if (fp->fr_ip.fi_fl & FI_TCPUDP) {
			printf("proto tcp/udp ");
			pr = -1;
	} else if ((pr = fp->fr_mip.fi_p)) {
		if ((p = getprotobynumber(fp->fr_proto)))
			printf("proto %s ", p->p_name);
		else
			printf("proto %d ", fp->fr_proto);
	}

	printf("from %s", fp->fr_flags & FR_NOTSRCIP ? "!" : "");
	printhostmask(fp->fr_v, (u_32_t *)&fp->fr_src.s_addr,
		      (u_32_t *)&fp->fr_smsk.s_addr);
	if (fp->fr_scmp)
		printportcmp(pr, &fp->fr_tuc.ftu_src);

	printf(" to %s", fp->fr_flags & FR_NOTDSTIP ? "!" : "");
	printhostmask(fp->fr_v, (u_32_t *)&fp->fr_dst.s_addr,
		      (u_32_t *)&fp->fr_dmsk.s_addr);
	if (fp->fr_dcmp)
		printportcmp(pr, &fp->fr_tuc.ftu_dst);

	if ((fp->fr_ip.fi_fl & ~FI_TCPUDP) ||
	    (fp->fr_mip.fi_fl & ~FI_TCPUDP) ||
	    fp->fr_ip.fi_optmsk || fp->fr_mip.fi_optmsk ||
	    fp->fr_ip.fi_secmsk || fp->fr_mip.fi_secmsk) {
		printf(" with");
		if (fp->fr_ip.fi_optmsk || fp->fr_mip.fi_optmsk ||
		    fp->fr_ip.fi_secmsk || fp->fr_mip.fi_secmsk) {
			sec[0] = fp->fr_mip.fi_secmsk;
			sec[1] = fp->fr_ip.fi_secmsk;
			optprint(sec,
				 fp->fr_mip.fi_optmsk, fp->fr_ip.fi_optmsk);
		} else if (fp->fr_mip.fi_fl & FI_OPTIONS) {
			if (!(fp->fr_ip.fi_fl & FI_OPTIONS))
				printf(" not");
			printf(" ipopt");
		}
		if (fp->fr_mip.fi_fl & FI_SHORT) {
			if (!(fp->fr_ip.fi_fl & FI_SHORT))
				printf(" not");
			printf(" short");
		}
		if (fp->fr_mip.fi_fl & FI_FRAG) {
			if (!(fp->fr_ip.fi_fl & FI_FRAG))
				printf(" not");
			printf(" frag");
		}
	}
	if (fp->fr_proto == IPPROTO_ICMP && fp->fr_icmpm) {
		int	type = fp->fr_icmp, code;

		type = ntohs(fp->fr_icmp);
		code = type & 0xff;
		type /= 256;
		if (type < (sizeof(icmptypes) / sizeof(char *) - 1) &&
		    icmptypes[type])
			printf(" icmp-type %s", icmptypes[type]);
		else
			printf(" icmp-type %d", type);
		if (ntohs(fp->fr_icmpm) & 0xff)
			printf(" code %d", code);
	}
	if (fp->fr_proto == IPPROTO_TCP && (fp->fr_tcpf || fp->fr_tcpfm)) {
		printf(" flags ");
		if (fp->fr_tcpf & ~TCPF_ALL)
			printf("0x%x", fp->fr_tcpf);
		else
			for (s = flagset, t = flags; *s; s++, t++)
				if (fp->fr_tcpf & *t)
					(void)putchar(*s);
		if (fp->fr_tcpfm) {
			(void)putchar('/');
			if (fp->fr_tcpfm & ~TCPF_ALL)
				printf("0x%x", fp->fr_tcpfm);
			else
				for (s = flagset, t = flags; *s; s++, t++)
					if (fp->fr_tcpfm & *t)
						(void)putchar(*s);
		}
	}

	if (fp->fr_flags & FR_KEEPSTATE)
		printf(" keep state");
	if (fp->fr_flags & FR_KEEPFRAG)
		printf(" keep frags");
	if (fp->fr_grhead)
		printf(" head %d", fp->fr_grhead);
	if (fp->fr_group)
		printf(" group %d", fp->fr_group);
	(void)putchar('\n');
}

void	binprint(fp)
struct frentry *fp;
{
	int i = sizeof(*fp), j = 0;
	u_char *s;

	for (s = (u_char *)fp; i; i--, s++) {
		j++;
		printf("%02x ", *s);
		if (j == 16) {
			printf("\n");
			j = 0;
		}
	}
	putchar('\n');
	(void)fflush(stdout);
}


void printlog(fp)
frentry_t *fp;
{
	char *s, *u;

	printf("log");
	if (fp->fr_flags & FR_LOGBODY)
		printf(" body");
	if (fp->fr_flags & FR_LOGFIRST)
		printf(" first");
	if (fp->fr_flags & FR_LOGORBLOCK)
		printf(" or-block");
	if (fp->fr_loglevel != 0xffff) {
		printf(" level ");
		if (fp->fr_loglevel & LOG_FACMASK) {
			s = fac_toname(fp->fr_loglevel);
			if (s == NULL)
				s = "!!!";
		} else
			s = "";
		u = pri_toname(fp->fr_loglevel);
		if (u == NULL)
			u = "!!!";
		if (*s)
			printf("%s.%s", s, u);
		else
			printf("%s", u);
	}
}
@


1.38
log
@reimplement local ipf mods and import some missed patches
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.37 2001/01/20 06:36:52 fgsch Exp $	*/
@


1.37
log
@Print the service name instead of the number if available.
Similar to the problem found by millert@@ (next thing to commit).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.36 2001/01/17 05:00:59 fgsch Exp $	*/
d39 1
a39 1
#include <netinet/ip_compat.h>
d1106 1
a1106 1
	} else if ((pr = fp->fr_ip.fi_p)) {
@


1.36
log
@1st part of ipf userland code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1106 1
a1106 1
	} else if ((pr = fp->fr_mip.fi_p)) {
@


1.35
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.34 2000/04/05 05:35:28 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d39 1
a39 1
#include <netinet/ip_fil_compat.h>
d45 2
a46 2
static const char sccsid[] = "@@(#)parse.c	1.44 6/5/96 (C) 1993-1996 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: parse.c,v 2.1.2.14 2000/06/21 14:50:52 darrenr Exp $";
d51 3
a54 2
int	portnum __P((char *, u_short *, int));
u_char	tcp_flags __P((char *, u_char *, int));
d57 1
a57 8
char    ***seg;
u_long  *sa, *msk;
u_short *pp, *tp;
u_char  *cp;

int	hostmask __P((char ***, u_32_t *, u_32_t *, u_short *, u_char *,
		      u_short *, int));
int	ports __P((char ***, u_short *, u_char *, u_short *, int));
d62 1
a62 4
int	countbits __P((u_32_t));
char	*portname __P((int, int));
int	ratoi __P((char *, int *, int, int));
int	loglevel __P((char **, u_short *, int));
a63 3
#if defined(__OpenBSD__)
extern int     if_addr __P((char *, struct in_addr *));
#endif
d65 3
a67 12

char	*proto = NULL;
char	flagset[] = "FSRPAU";
u_char	flags[] = { TH_FIN, TH_SYN, TH_RST, TH_PUSH, TH_ACK, TH_URG };

static	char	thishost[MAXHOSTNAMELEN];


void initparse()
{
	gethostname(thishost, sizeof(thishost));
}
d81 2
a82 2
	u_char	ch;
	int	i, cnt = 1, j;
d91 3
d95 1
d162 2
a163 2
		if (ratoi(*cpp, &i, 0, USHRT_MAX))
			fil.fr_skip = i;
a250 37
			int fac, pri;
			char *s;

			fac = 0;
			pri = 0;
			if (!*++cpp) {
				fprintf(stderr, "%d: %s\n", linenum,
					"missing identifier after level");
				return NULL;
			}
			s = index(*cpp, '.');
			if (s) {
				*s++ = '\0';
				fac = fac_findname(*cpp);
				if (fac == -1) {
					fprintf(stderr, "%d: %s %s\n", linenum,
						"Unknown facility", *cpp);
					return NULL;
				}
				pri = pri_findname(s);
				if (pri == -1) {
					fprintf(stderr, "%d: %s %s\n", linenum,
						"Unknown priority", s);
					return NULL;
				}
			} else {
				pri = pri_findname(*cpp);
				if (pri == -1) {
					fprintf(stderr, "%d: %s %s\n", linenum,
						"Unknown priority", *cpp);
					return NULL;
				}
			}
			fil.fr_loglevel = fac|pri;
			cpp++;
		}
		if (*cpp && !strcasecmp(*cpp, "level")) {
a398 1
		ch = 0;
d403 1
d409 1
d471 2
a472 1
	if (*cpp && (!strcasecmp(*cpp, "with") || !strcasecmp(*cpp, "and")))
d507 2
a508 2
		if (ratoi(*cpp, &i, 0, USHRT_MAX))
			fil.fr_grhead = i;
d526 2
a527 2
		if (ratoi(*cpp, &i, 0, USHRT_MAX))
			fil.fr_group = i;
d581 1
a581 1
u_short *facpri;
d628 1
a628 2
	int	r = 0;
	char	*s;
d634 1
a634 2
		fdp->fd_ip.s_addr = hostnum(s, &r, linenum);
		if (r == -1)
a655 273
 * returns -1 if neither "hostmask/num" or "hostmask mask addr" are
 * found in the line segments, there is an error processing this information,
 * or there is an error processing ports information.
 */
int	hostmask(seg, sa, msk, pp, cp, tp, linenum)
char	***seg;
u_32_t	*sa, *msk;
u_short	*pp, *tp;
u_char	*cp;
int     linenum;
{
	char	*s, *endptr;
	int	bits = -1, resolved;
	struct	in_addr	maskaddr;

	/*
	 * is it possibly hostname/num ?
	 */
	if ((s = index(**seg, '/')) || (s = index(**seg, ':'))) {
		*s++ = '\0';
		if (index(s, '.') || index(s, 'x')) {
			/* possibly of the form xxx.xxx.xxx.xxx
			 * or 0xYYYYYYYY */
			if (inet_aton(s, &maskaddr) == 0) {
				fprintf(stderr, "%d: bad mask (%s)\n",
					linenum, s);
				return -1;
			} 
			*msk = maskaddr.s_addr;
		} else {
			/*
			 * set x most significant bits
			 */
			bits = (int)strtol(s, &endptr, 0);
			if (*endptr != '\0' || bits > 32 || bits < 0) {
				fprintf(stderr, "%d: bad mask (/%s)\n",
					linenum, s);
				return -1;
			}
			if (bits == 0)
				*msk = 0;
			else
				*msk = htonl(0xffffffff << (32 - bits));
		}
		*sa = hostnum(**seg, &resolved, linenum) & *msk;
		if (resolved == -1) {
			fprintf(stderr, "%d: bad host (%s)\n", linenum, **seg);
			return -1;
		}
		(*seg)++;
		return ports(seg, pp, cp, tp, linenum);
	}

	/*
	 * look for extra segments if "mask" found in right spot
	 */
	if (*(*seg+1) && *(*seg+2) && !strcasecmp(*(*seg+1), "mask")) {
		*sa = hostnum(**seg, &resolved, linenum);
		if (resolved == -1) {
			fprintf(stderr, "%d: bad host (%s)\n", linenum, **seg);
			return -1;
		}
		(*seg)++;
		(*seg)++;
		if (inet_aton(**seg, &maskaddr) == 0) {
			fprintf(stderr, "%d: bad mask (%s)\n", linenum, **seg);
			return -1;
		}
		*msk = maskaddr.s_addr;
		(*seg)++;
		*sa &= *msk;
		return ports(seg, pp, cp, tp, linenum);
	}

	if (**seg) {
		*sa = hostnum(**seg, &resolved, linenum);
		if (resolved == -1) {
			fprintf(stderr, "%d: bad host (%s)\n", linenum, **seg);
			return -1;
		}
		(*seg)++;
		*msk = (*sa ? inet_addr("255.255.255.255") : 0L);
		*sa &= *msk;
		return ports(seg, pp, cp, tp, linenum);
	}
	fprintf(stderr, "%d: bad host (%s)\n", linenum, **seg);
	return -1;
}

/*
 * returns an ip address as a long var as a result of either a DNS lookup or
 * straight inet_addr() call
 */
u_32_t	hostnum(host, resolved, linenum)
char	*host;
int	*resolved;
int     linenum;
{
	struct	hostent	*hp;
	struct	netent	*np;
	struct	in_addr	ip;
#if defined(__OpenBSD__)
        struct in_addr  addr;
#endif

	*resolved = 0;
	if (!strcasecmp("any", host))
		return 0;
	if (isdigit(*host) && inet_aton(host, &ip))
		return ip.s_addr;

	if (!strcasecmp("<thishost>", host))
		host = thishost;

#if defined(__OpenBSD__)
        /* attempt a map from interface name to address */
        if (if_addr(host, &addr))
                return (u_32_t)addr.s_addr;
#endif

	if (!(hp = gethostbyname(host))) {
		if (!(np = getnetbyname(host))) {
			*resolved = -1;
			fprintf(stderr, "%d: can't resolve hostname: %s\n",
				linenum, host);
			return 0;
		}
		return htonl(np->n_net);
	}
	return *(u_32_t *)hp->h_addr;
}

/*
 * check for possible presence of the port fields in the line
 */
int	ports(seg, pp, cp, tp, linenum)
char	***seg;
u_short	*pp, *tp;
u_char	*cp;
int     linenum;
{
	int	comp = -1;

	if (!*seg || !**seg || !***seg)
		return 0;
	if (!strcasecmp(**seg, "port") && *(*seg + 1) && *(*seg + 2)) {
		(*seg)++;
		if (isdigit(***seg) && *(*seg + 2)) {
			if (portnum(**seg, pp, linenum) == 0)
				return -1;
			(*seg)++;
			if (!strcmp(**seg, "<>"))
				comp = FR_OUTRANGE;
			else if (!strcmp(**seg, "><"))
				comp = FR_INRANGE;
			else {
				fprintf(stderr,
					"%d: unknown range operator (%s)\n",
					linenum, **seg);
				return -1;
			}
			(*seg)++;
			if (**seg == NULL) {
				fprintf(stderr, "%d: missing 2nd port value\n",
					linenum);
				return -1;
			}
			if (portnum(**seg, tp, linenum) == 0)
				return -1;
		} else if (!strcmp(**seg, "=") || !strcasecmp(**seg, "eq"))
			comp = FR_EQUAL;
		else if (!strcmp(**seg, "!=") || !strcasecmp(**seg, "ne"))
			comp = FR_NEQUAL;
		else if (!strcmp(**seg, "<") || !strcasecmp(**seg, "lt"))
			comp = FR_LESST;
		else if (!strcmp(**seg, ">") || !strcasecmp(**seg, "gt"))
			comp = FR_GREATERT;
		else if (!strcmp(**seg, "<=") || !strcasecmp(**seg, "le"))
			comp = FR_LESSTE;
		else if (!strcmp(**seg, ">=") || !strcasecmp(**seg, "ge"))
			comp = FR_GREATERTE;
		else {
			fprintf(stderr, "%d: unknown comparator (%s)\n",
					linenum, **seg);
			return -1;
		}
		if (comp != FR_OUTRANGE && comp != FR_INRANGE) {
			(*seg)++;
			if (portnum(**seg, pp, linenum) == 0)
				return -1;
		}
		*cp = comp;
		(*seg)++;
	}
	return 0;
}

/*
 * find the port number given by the name, either from getservbyname() or
 * straight atoi(). Return 1 on success, 0 on failure
 */
int	portnum(name, port, linenum)
char	*name;
u_short	*port;
int     linenum;
{
	struct	servent	*sp, *sp2;
	u_short	p1 = 0;
	int i;
	if (isdigit(*name)) {
		if (ratoi(name, &i, 0, USHRT_MAX)) {
			*port = (u_short)i;
			return 1;
		}
		fprintf(stderr, "%d: unknown port \"%s\"\n", linenum, name);
		return 0;
	}
	if (proto != NULL && strcasecmp(proto, "tcp/udp") != 0) {
		sp = getservbyname(name, proto);
		if (sp) {
			*port = ntohs(sp->s_port);
			return 1;
		}
		fprintf(stderr, "%d: unknown service \"%s\".\n", linenum, name);
		return 0;
	}
	sp = getservbyname(name, "tcp");
	if (sp) 
		p1 = sp->s_port;
	sp2 = getservbyname(name, "udp");
	if (!sp || !sp2) {
		fprintf(stderr, "%d: unknown tcp/udp service \"%s\".\n",
			linenum, name);
		return 0;
	}
	if (p1 != sp2->s_port) {
		fprintf(stderr, "%d: %s %d/tcp is a different port to ",
			linenum, name, p1);
		fprintf(stderr, "%d: %s %d/udp\n", linenum, name, sp->s_port);
		return 0;
	}
	*port = ntohs(p1);
	return 1;
}


u_char tcp_flags(flgs, mask, linenum)
char *flgs;
u_char *mask;
int    linenum;
{
	u_char tcpf = 0, tcpfm = 0, *fp = &tcpf;
	char *s, *t;

	for (s = flgs; *s; s++) {
		if (*s == '/' && fp == &tcpf) {
			fp = &tcpfm;
			continue;
		}
		if (!(t = index(flagset, *s))) {
			fprintf(stderr, "%d: unknown flag (%c)\n", linenum, *s);
			return 0;
		}
		*fp |= flags[t - flagset];
	}
	if (!tcpfm)
		tcpfm = 0xff;
	*mask = tcpfm;
	return tcpf;
}


/*
d676 2
a677 2
	       !strncasecmp(**cp, "not", 3) || !strncasecmp(**cp, "opt", 4) ||
	       !strncasecmp(**cp, "frag", 3) || !strncasecmp(**cp, "no", 2) ||
d1003 3
d1018 1
a1018 2

	if (**cp && strcasecmp(**cp, "state") && strcasecmp(**cp, "frags")) {
a1033 59
 * count consecutive 1's in bit mask.  If the mask generated by counting
 * consecutive 1's is different to that passed, return -1, else return #
 * of bits.
 */
int	countbits(ip)
u_32_t	ip;
{
	u_32_t	ipn;
	int	cnt = 0, i, j;

	ip = ipn = ntohl(ip);
	for (i = 32; i; i--, ipn *= 2)
		if (ipn & 0x80000000)
			cnt++;
		else
			break;
	ipn = 0;
	for (i = 32, j = cnt; i; i--, j--) {
		ipn *= 2;
		if (j > 0)
			ipn++;
	}
	if (ipn == ip)
		return cnt;
	return -1;
}


char	*portname(pr, port)
int	pr, port;
{
	static	char	buf[32];
	struct	protoent	*p = NULL;
	struct	servent	*sv = NULL, *sv1 = NULL;

	if (pr == -1) {
		if ((sv = getservbyport(htons(port), "tcp"))) {
			strncpy(buf, sv->s_name, sizeof(buf)-1);
			buf[sizeof(buf)-1] = '\0';
			sv1 = getservbyport(htons(port), "udp");
			sv = strncasecmp(buf, sv->s_name, strlen(buf)) ?
			     NULL : sv1;
		}
		if (sv)
			return buf;
	} else if (pr && (p = getprotobynumber(pr))) {
		if ((sv = getservbyport(htons(port), p->p_name))) {
			strncpy(buf, sv->s_name, sizeof(buf)-1);
			buf[sizeof(buf)-1] = '\0';
			return buf;
		}
	}

	(void) sprintf(buf, "%d", port);
	return buf;
}


/*
d1039 1
a1039 6
	static	char	*pcmp1[] = { "*", "=", "!=", "<", ">", "<=", ">=",
				    "<>", "><"};
	struct	protoent	*p;
	int	ones = 0, pr;
	char	*s;
	u_char	*t;
d1041 3
d1084 1
d1114 10
a1123 17
	if (!fp->fr_src.s_addr && !fp->fr_smsk.s_addr)
		printf("any ");
	else {
		printf("%s", inet_ntoa(fp->fr_src));
		if ((ones = countbits(fp->fr_smsk.s_addr)) == -1)
			printf("/%s ", inet_ntoa(fp->fr_smsk));
		else
			printf("/%d ", ones);
	}
	if (fp->fr_scmp) {
		if (fp->fr_scmp == FR_INRANGE || fp->fr_scmp == FR_OUTRANGE)
			printf("port %d %s %d ", fp->fr_sport,
				     pcmp1[fp->fr_scmp], fp->fr_stop);
		else
			printf("port %s %s ", pcmp1[fp->fr_scmp],
				     portname(pr, fp->fr_sport));
	}
a1124 18
	printf("to %s", fp->fr_flags & FR_NOTDSTIP ? "!" : "");
	if (!fp->fr_dst.s_addr && !fp->fr_dmsk.s_addr)
		printf("any");
	else {
		printf("%s", inet_ntoa(fp->fr_dst));
		if ((ones = countbits(fp->fr_dmsk.s_addr)) == -1)
			printf("/%s", inet_ntoa(fp->fr_dmsk));
		else
			printf("/%d", ones);
	}
	if (fp->fr_dcmp) {
		if (fp->fr_dcmp == FR_INRANGE || fp->fr_dcmp == FR_OUTRANGE)
			printf(" port %d %s %d", fp->fr_dport,
				     pcmp1[fp->fr_dcmp], fp->fr_dtop);
		else
			printf(" port %s %s", pcmp1[fp->fr_dcmp],
				     portname(pr, fp->fr_dport));
	}
d1168 6
a1173 3
		for (s = flagset, t = flags; *s; s++, t++)
			if (fp->fr_tcpf & *t)
				(void)putchar(*s);
d1176 6
a1181 3
			for (s = flagset, t = flags; *s; s++, t++)
				if (fp->fr_tcpfm & *t)
					(void)putchar(*s);
a1242 15
}


int	ratoi(ps, pi, min, max)
char 	*ps;
int	*pi, min, max;
{
	int i;
	char *pe;

	i = (int)strtol(ps, &pe, 0);
	if (*pe != '\0' || i < min || i > max)
		return 0;
	*pi = i;
	return 1;
@


1.34
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.33 2000/03/13 23:40:19 kjell Exp $	*/
d46 1
a46 1
static const char rcsid[] = "@@(#)$IPFilter: parse.c,v 2.1.2.12 2000/03/08 11:43:55 darrenr Exp $";
d1271 8
a1278 4
		fp->fr_icmp |= (u_short)i;
		fp->fr_icmpm = (u_short)0xffff;
		(*cp)++;
		return 0;
d1280 5
a1284 3
	fprintf(stderr, "%d: Invalid icmp code (%s) specified\n",
		linenum, **cp);
	return -1;
d1304 2
a1305 3
	if (!(s = strrchr(str, ')')))
		return -1;
	*s = '\0';
d1573 1
a1573 1
		if (code)
@


1.33
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static const char rcsid[] = "@@(#)$IPFilter: parse.c,v 2.1.2.11 2000/03/04 05:19:25 darrenr Exp $";
d1563 1
a1563 1
		if (type < (sizeof(icmptypes) / sizeof(char *)) &&
@


1.32
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d46 1
a46 1
static const char rcsid[] = "@@(#)$IPFilter: parse.c,v 2.1.2.8 2000/01/27 08:49:42 darrenr Exp $";
d71 2
d77 1
d194 5
d201 2
a202 8
			int fac, pri;
			char *s;

			fac = 0;
			pri = 0;
			if (!*++cpp) {
				fprintf(stderr, "%d: %s\n", linenum,
					"missing identifier after level");
a203 25
			}
			s = index(*cpp, '.');
			if (s) {
				*s++ = '\0';
				fac = fac_findname(*cpp);
				if (fac == -1) {
					fprintf(stderr, "%d: %s %s\n", linenum,
						"Unknown facility", *cpp);
					return NULL;
				}
				pri = pri_findname(s);
				if (pri == -1) {
					fprintf(stderr, "%d: %s %s\n", linenum,
						"Unknown priority", s);
					return NULL;
				}
			} else {
				pri = pri_findname(*cpp);
				if (pri == -1) {
					fprintf(stderr, "%d: %s %s\n", linenum,
						"Unknown priority", *cpp);
					return NULL;
				}
			}
			fil.fr_loglevel = fac|pri;
d304 6
d631 44
d1332 6
d1422 1
a1422 1
	char	*s, *u;
d1445 1
a1445 5
		printf("log");
		if (fp->fr_flags & FR_LOGBODY)
			printf(" body");
		if (fp->fr_flags & FR_LOGFIRST)
			printf(" first");
d1462 2
a1463 23
		printf("log ");
		if (fp->fr_flags & FR_LOGBODY)
			printf("body ");
		if (fp->fr_flags & FR_LOGFIRST)
			printf("first ");
		if (fp->fr_flags & FR_LOGORBLOCK)
			printf("or-block ");
		if (fp->fr_loglevel != 0xffff) {
			if (fp->fr_loglevel & LOG_FACMASK) {
				s = fac_toname(fp->fr_loglevel);
				if (s == NULL)
					s = "!!!";
			} else
				s = "";
			u = pri_toname(fp->fr_loglevel);
			if (u == NULL)
				u = "!!!";
			if (*s)
				printf("level %s.%s ", s, u);
			else
				printf("level %s ", u);
		}
			
d1611 31
@


1.31
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.30
log
@ipf could dump core when fed unfinished rules. Inspired by pr/995.
@
text
@d1 2
a2 1
/* $OpenBSD: parse.c,v 1.29 1999/12/17 06:17:08 kjell Exp $ */
d46 1
a46 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.29 1999/12/17 06:17:08 kjell Exp $";
d133 2
a134 1
		if (!strncasecmp(*(cpp+1), "return-icmp-as-dest", 19))
d136 1
a136 1
		else if (!strncasecmp(*(cpp+1), "return-icmp", 11))
d140 6
a145 4
			if (!*(cpp+1)) {
				fprintf(stderr, "%d: missing icmp code\n",
					linenum);
				return NULL;
d147 5
a151 4
			i = 11;
			if ((strlen(*cpp) > i) && (*(*cpp + i) != '('))
				i = 19;
			if (*(*cpp + i) == '(') {
d264 1
a264 1
			fprintf(stderr, "%d: missing source specification\n", 
d774 1
a774 1
 * straight inet_aton() call
d1255 1
a1255 1
#define	MAX_ICMPCODE	12
d1260 2
a1261 1
	"net-tos", "host-tos", NULL };
@


1.29
log
@Update to Darren Reed's IPFilter 3.3.5
Fixes: realaudio proxy issues, "log level" printing, and
source address for icmp replies (was reversed).

Thoughtfully submitted by techs@@obfuscation.org
@
text
@d1 1
a1 1
/* $OpenBSD: parse.c,v 1.28 1999/12/16 07:38:45 kjell Exp $ */
d45 1
a45 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.28 1999/12/16 07:38:45 kjell Exp $";
d138 5
d193 5
a197 1
			cpp++;
d231 4
a234 1
	cpp++;
d251 3
a253 3
	} else {
		fprintf(stderr, "%d: missing 'in'/'out' keyword (%s)\n",
			linenum, *cpp);
a255 2
	if (!*++cpp)
		return NULL;
d258 5
a262 1
		cpp++;
d267 1
a267 1
		if (!strcasecmp(*cpp, "body")) {
d271 1
a271 1
		if (!strcasecmp(*cpp, "first")) {
d275 1
a275 1
		if (!strcasecmp(*cpp, "or-block")) {
d285 1
a285 1
		if (!strcasecmp(*cpp, "level")) {
d291 5
a295 1
			cpp++;
d324 1
a324 1
	if (!strcasecmp("quick", *cpp)) {
d356 1
a356 1
			if (!strcasecmp(*cpp, "to") && *(cpp + 1)) {
d361 1
a361 1
			} else if (!strcasecmp(*cpp, "fastroute")) {
@


1.28
log
@Add the ability to use interface names in place of addresses
in firewall rules. i.e.

block return-rst in quick on fxp0 proto tcp from any to fxp0 port = 9999

This will make things like DHCP much easier to deal with in the future.
@
text
@d1 1
a1 1
/* $OpenBSD: parse.c,v 1.27 1999/12/15 05:20:24 kjell Exp $ */
d45 1
a45 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.27 1999/12/15 05:20:24 kjell Exp $";
d271 33
d1427 1
a1427 1
				printf("%s.%s ", s, u);
d1429 1
a1429 1
				printf("%s ", u);
@


1.27
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d45 1
a45 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 2.1.2.3 1999/12/04 02:10:33 darrenr Exp $";
d70 3
a72 1

d728 3
d740 6
@


1.26
log
@gethostname() is safe
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.25 1999/07/05 20:12:44 kjell Exp $      */
a8 2
#include <stdio.h>
#include <string.h>
a16 3
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
d23 9
d37 1
d41 1
d44 2
a45 2
static const char sccsid[] ="@@(#)parse.c	1.44 6/5/96 (C) 1993-1996 Darren Reed";
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.25 1999/07/05 20:12:44 kjell Exp $";
d51 4
a54 4
int	portnum __P((char *, u_short *));
u_char	tcp_flags __P((char *, u_char *));
int	addicmp __P((char ***, struct frentry *));
int	extras __P((char ***, struct frentry *));
d61 4
a64 4
		      u_short *));
int	ports __P((char ***, u_short *, u_char *, u_short *));
int	icmpcode __P((char *)), addkeep __P((char ***, struct frentry *));
int	to_interface __P((frdest_t *, char *));
d66 1
a66 1
void	optprint __P((u_short, u_short, u_long, u_long));
d78 1
d89 1
a89 1
struct	frentry	*parse(line)
d91 1
d97 1
a97 1
	int	i, cnt = 1;
d107 2
d119 1
a119 1
		(void)fprintf(stderr, "not enough segments in line\n");
d130 3
a132 1
		if (!strncasecmp(*(cpp+1), "return-icmp", 11)) {
d134 1
d136 7
a142 3
			if (*(*cpp + 11) == '(') {
				i = icmpcode(*cpp + 12);
				if (i == -1) {
d144 2
a145 2
						"unrecognised icmp code %s\n",
						*cpp + 12);
d148 1
a148 1
				fil.fr_icode = i;
d164 1
a164 1
		if (ratoi(*cpp, &i, 0, INT_MAX))
d167 2
a168 1
			(void)fprintf(stderr, "integer must follow skip\n");
d179 32
d217 1
a217 1
		(void)fprintf(stderr, "unknown keyword (%s)\n", *cpp);
d227 3
a229 2
			(void)fprintf(stderr,
				"Can only use return-icmp with 'in'\n");
d232 3
a234 2
			(void)fprintf(stderr,
				"Can only use return-rst with 'in'\n");
d238 2
a239 2
		(void)fprintf(stderr,
			"missing 'in'/'out' keyword (%s)\n", *cpp);
d261 3
a263 2
				(void)fprintf(stderr,
					"or-block must be used with pass\n");
d279 2
a280 1
			(void)fprintf(stderr, "interface name missing\n");
d287 4
a290 4
			if (fil.fr_flags & FR_RETRST) {
				(void)fprintf(stderr,
					"%s can only be used with TCP\n",
					"return-rst");
d299 1
a299 1
				if (to_interface(&fil.fr_dif, *cpp))
d305 1
a305 1
				if (to_interface(&fil.fr_tif, *cpp))
d309 6
d322 1
a322 1
			(void)fprintf(stderr, "tos missing value\n");
d332 2
a333 1
			(void)fprintf(stderr, "ttl missing hopcount value\n");
d339 2
a340 1
			(void)fprintf(stderr, "invalid ttl (%s)\n", *cpp);
d353 1
a353 1
			(void)fprintf(stderr, "protocol name missing\n");
d356 2
a357 1
		if (!strcasecmp(*cpp, "tcp/udp")) {
d361 4
a364 3
			if (!(p = getprotobyname(*cpp)) && !isdigit(**cpp)) {
				(void)fprintf(stderr,
					"unknown protocol (%s)\n", *cpp);
d369 2
a370 2
			else if (isdigit(**cpp)) {
				i = (int)strtol(*cpp, &endptr, 0);
d372 3
a374 2
					(void)fprintf(stderr,
						"unknown protocol (%s)\n", *cpp);
a380 9
		proto = *cpp;
		if (fil.fr_proto != IPPROTO_TCP && fil.fr_flags & FR_RETRST) {
			(void)fprintf(stderr,
				"%s can only be used with TCP\n",
				"return-rst");
			return NULL;
		}
		if (!*++cpp)
			return &fil;
d382 4
a385 3
	if (fil.fr_proto != IPPROTO_TCP && fil.fr_flags & FR_RETRST) {
		(void)fprintf(stderr, "%s can only be used with TCP\n",
			"return-rst");
d394 1
a394 1
		fprintf(stderr, "missing source specification\n");
d403 2
a404 2
			(void)fprintf(stderr,
				"unexpected keyword (%s) - from\n", *cpp);
d408 2
a409 1
			(void)fprintf(stderr, "missing host after from\n");
d419 1
a419 1
			     &fil.fr_stop)) {
d424 1
a424 1
			(void)fprintf(stderr, "missing to fields\n");
d432 2
a433 2
			(void)fprintf(stderr,
				"unexpected keyword (%s) - to\n", *cpp);
d437 1
a437 1
			(void)fprintf(stderr, "missing host after to\n");
d447 1
a447 1
			     &fil.fr_dtop)) {
d459 1
a459 1
		(void)fprintf(stderr, "port operation on non tcp/udp\n");
d463 2
a464 1
		(void)fprintf(stderr, "icmp comparisons on wrong protocol\n");
d473 1
a473 1
			(void)fprintf(stderr, "no flags present\n");
d476 1
a476 1
		fil.fr_tcpf = tcp_flags(*cpp, &fil.fr_tcpfm);
d484 1
a484 1
		if (extras(&cpp, &fil))
d492 3
a494 3
			(void)fprintf(stderr,
				"icmp with wrong protocol (%d)\n",
				fil.fr_proto);
d497 1
a497 1
		if (addicmp(&cpp, &fil))
d507 1
a507 1
		if (addkeep(&cpp, &fil))
d515 1
a515 1
			(void)fprintf(stderr, "head without group #\n");
d521 2
a522 1
			(void)fprintf(stderr, "invalid group (%s)\n", *cpp);
d533 2
a534 1
			(void)fprintf(stderr, "group without group #\n");
d540 4
a543 3
			(void)fprintf(stderr, "invalid group (%s)\n", *cpp);
                        return NULL;
                }
d551 1
a551 1
		fprintf(stderr, "unknown words at end: [");
d553 2
a554 2
			(void)fprintf(stderr, "%s ", *cpp);
		(void)fprintf(stderr, "]\n");
d562 1
a562 1
		(void)fprintf(stderr, "TCP protocol not specified\n");
d571 3
a573 2
			(void)fprintf(stderr,
				     "port comparisons for non-TCP/UDP\n");
d580 3
a582 2
		(void)fprintf(stderr,
			"must use 'with frags' with 'keep frags'\n");
d590 1
a590 1
int to_interface(fdp, to)
d593 1
d602 1
a602 1
		fdp->fd_ip.s_addr = hostnum(s, &r);
d616 1
a616 1
	(void)printf("%s %s%s", tag, fdp->fd_ifname,
d619 1
a619 1
		(void)printf(":%s", inet_ntoa(fdp->fd_ip));
d629 1
a629 1
int	hostmask(seg, sa, msk, pp, cp, tp)
d634 1
d646 2
a647 4
			/* 
			 * Netmask possibly of the form xxx.xxx.xxx.xxx
			 * or 0xYYYYYYYY 
			 */
d649 2
a650 1
				(void)fprintf(stderr, "bad mask (%s)\n", s);
d660 2
a661 1
				(void)fprintf(stderr, "bad mask (/%s)\n", s);
d669 1
a669 1
		*sa = hostnum(**seg, &resolved) & *msk;
d671 1
a671 1
			(void)fprintf(stderr, "bad host (%s)\n", **seg);
d675 1
a675 1
		return ports(seg, pp, cp, tp);
d682 1
a682 1
		*sa = hostnum(**seg, &resolved);
d684 1
a684 1
			(void)fprintf(stderr, "bad host (%s)\n", **seg);
d690 1
a690 1
			(void)fprintf(stderr, "bad mask (%s)\n", **seg);
d696 1
a696 1
		return ports(seg, pp, cp, tp);
d700 1
a700 1
		*sa = hostnum(**seg, &resolved);
d702 1
a702 1
			(void)fprintf(stderr, "bad host (%s)\n", **seg);
d708 1
a708 1
		return ports(seg, pp, cp, tp);
d710 1
a710 1
	(void)fprintf(stderr, "bad host (%s)\n", **seg);
d716 1
a716 1
 * straight inet_addr() call
d718 1
a718 1
u_32_t	hostnum(host, resolved)
d721 1
d725 1
a725 1
	struct	in_addr addr;
d729 4
a732 3
		return 0L;
	if (inet_aton(host, &addr))
		return addr.s_addr;
d739 2
a740 1
			fprintf(stderr, "can't resolve hostname: %s\n", host);
d751 1
a751 1
int	ports(seg, pp, cp, tp)
d755 1
d764 1
a764 1
			if (portnum(**seg, pp) == 0)
d772 3
a774 2
				fprintf(stderr, "unknown range operator (%s)\n",
					**seg);
d779 2
a780 1
				fprintf(stderr, "missing 2nd port value\n");
d783 1
a783 1
			if (portnum(**seg, tp) == 0)
d798 2
a799 2
			(void)fprintf(stderr, "unknown comparator (%s)\n",
					**seg);
d804 1
a804 1
			if (portnum(**seg, pp) == 0)
d817 1
a817 1
int	portnum(name, port)
d820 1
d830 1
a830 1
		(void)fprintf(stderr, "unknown port \"%s\"\n", name);
d839 1
a839 1
		(void) fprintf(stderr, "unknown service \"%s\".\n", name);
d847 2
a848 2
		(void) fprintf(stderr, "unknown tcp/udp service \"%s\".\n",
			name);
d852 3
a854 3
		(void) fprintf(stderr, "%s %d/tcp is a different port to ",
			name, p1);
		(void) fprintf(stderr, "%s %d/udp\n", name, sp->s_port);
d862 1
a862 1
u_char tcp_flags(flgs, mask)
d865 1
d876 1
a876 1
			(void)fprintf(stderr, "unknown flag (%c)\n", *s);
d891 1
a891 1
int	extras(cp, fr)
d894 1
d928 3
a930 2
				(void)fprintf(stderr,
					"opt missing arguements\n");
d934 1
a934 1
			if (!(opts = optname(cp, &secmsk)))
d939 3
a941 2
				(void) fprintf(stderr,
				    "short cannot be used with TCP flags\n");
d954 2
a955 2
		if (notopt)
			if (!secmsk)
d957 1
a957 1
			else
d959 2
a960 1
		else
d962 1
d985 1
a985 1
u_32_t optname(cp, sp)
d988 1
d1003 2
a1004 1
			fprintf(stderr, "unknown IP option name %s\n", s);
d1012 2
a1013 1
		fprintf(stderr, "missing security level after sec-class\n");
d1026 3
a1028 2
				fprintf(stderr, "no such security level: %s\n",
					s);
d1040 1
a1040 1
void optprint(u_short secmsk, u_short secbits, u_long optmsk, u_long optbits)
d1042 2
a1043 2
void optprint(secmsk, secbits, optmsk, optbits)
u_short secmsk, secbits;
d1047 1
d1123 1
a1123 1
int	addicmp(cp, fp)
d1126 1
d1138 3
a1140 2
			(void)fprintf(stderr,
				"Invalid icmp-type (%s) specified\n", **cp);
d1155 3
a1157 2
			(void)fprintf(stderr,
				"Invalid icmp-type (%s) specified\n", **cp);
d1172 3
a1174 2
			(void)fprintf(stderr, 
				"Invalid icmp code (%s) specified\n", **cp);
d1182 2
a1183 1
	(void)fprintf(stderr, "Invalid icmp code (%s) specified\n", **cp);
d1224 1
a1224 1
int	addkeep(cp, fp)
d1227 1
d1231 2
a1232 1
		(void)fprintf(stderr, "Can only use keep with UDP/ICMP/TCP\n");
d1238 2
a1239 2
		(void)fprintf(stderr, "Unrecognised state keyword \"%s\"\n",
			**cp);
d1289 1
a1289 1
		if ((sv = getservbyport(port, "tcp"))) {
d1292 1
a1292 1
			sv1 = getservbyport(port, "udp");
d1299 1
a1299 1
		if ((sv = getservbyport(port, p->p_name))) {
d1321 1
a1321 1
	char	*s;
d1323 1
d1326 1
a1326 1
		(void)printf("pass");
d1328 1
a1328 1
		(void)printf("block");
d1330 5
a1334 2
			(void)printf(" return-icmp");
			if (fp->fr_icode)
d1340 3
a1342 3
		}
		if (fp->fr_flags & FR_RETRST)
			(void)printf(" return-rst");
d1344 1
a1344 1
		(void)printf("log");
d1346 1
a1346 1
			(void)printf(" body");
d1348 1
a1348 1
			(void)printf(" first");
d1350 1
a1350 1
		(void)printf("count");
d1352 1
a1352 1
		(void)printf("auth");
d1354 1
a1354 1
		(void)printf("preauth");
d1356 1
a1356 1
		(void)printf("skip %d", fp->fr_skip);
d1359 1
a1359 1
		(void)printf(" out ");
d1361 1
a1361 1
		(void)printf(" in ");
d1365 1
a1365 1
		(void)printf("log ");
d1367 1
a1367 1
			(void)printf("body ");
d1369 1
a1369 1
			(void)printf("first ");
d1371 17
a1387 1
			(void)printf("or-block ");
d1390 1
a1390 1
		(void)printf("quick ");
d1393 1
a1393 1
		(void)printf("on %s%s ", fp->fr_ifname,
d1400 1
a1400 1
			(void)printf("fastroute ");
d1404 1
a1404 1
		(void)printf("tos %#x ", fp->fr_tos);
d1406 1
a1406 1
		(void)printf("ttl %d ", fp->fr_ttl);
d1408 1
a1408 1
			(void)printf("proto tcp/udp ");
d1412 1
a1412 1
			(void)printf("proto %s ", p->p_name);
d1414 1
a1414 1
			(void)printf("proto %d ", fp->fr_proto);
d1418 2
a1419 2
	if (!fp->fr_src.s_addr & !fp->fr_smsk.s_addr)
		(void)printf("any ");
d1421 1
a1421 1
		(void)printf("%s", inet_ntoa(fp->fr_src));
d1423 1
a1423 1
			(void)printf("/%s ", inet_ntoa(fp->fr_smsk));
d1425 1
a1425 1
			(void)printf("/%d ", ones);
d1427 1
a1427 1
	if (fp->fr_scmp)
d1429 1
a1429 1
			(void)printf("port %d %s %d ", fp->fr_sport,
d1432 1
a1432 1
			(void)printf("port %s %s ", pcmp1[fp->fr_scmp],
d1434 1
d1437 2
a1438 2
	if (!fp->fr_dst.s_addr & !fp->fr_dmsk.s_addr)
		(void)printf("any");
d1440 1
a1440 1
		(void)printf("%s", inet_ntoa(fp->fr_dst));
d1442 1
a1442 1
			(void)printf("/%s", inet_ntoa(fp->fr_dmsk));
d1444 1
a1444 1
			(void)printf("/%d", ones);
d1448 1
a1448 1
			(void)printf(" port %d %s %d", fp->fr_dport,
d1451 1
a1451 1
			(void)printf(" port %s %s", pcmp1[fp->fr_dcmp],
d1458 1
a1458 1
		(void)printf(" with");
d1460 6
a1465 6
		    fp->fr_ip.fi_secmsk || fp->fr_mip.fi_secmsk)
			optprint(fp->fr_mip.fi_secmsk,
				 fp->fr_ip.fi_secmsk,
				 fp->fr_mip.fi_optmsk,
				 fp->fr_ip.fi_optmsk);
		else if (fp->fr_mip.fi_fl & FI_OPTIONS) {
d1467 2
a1468 2
				(void)printf(" not");
			(void)printf(" ipopt");
d1472 2
a1473 2
				(void)printf(" not");
			(void)printf(" short");
d1477 2
a1478 2
				(void)printf(" not");
			(void)printf(" frag");
d1489 1
a1489 1
			(void)printf(" icmp-type %s", icmptypes[type]);
d1491 1
a1491 1
			(void)printf(" icmp-type %d", type);
d1493 1
a1493 1
			(void)printf(" code %d", code);
d1496 1
a1496 1
		(void)printf(" flags ");
d1527 1
a1527 1
		(void)printf("%02x ", *s);
d1529 1
a1529 1
			(void)printf("\n");
@


1.25
log
@Big cleanup of the userland ipf parsing code.
inet_addr() was replaced with inet_aton. atoi() tests were replaced by
range-checked strtol calls. Error checking of ipf.rules input should
be vastly improved now.
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.24 1999/06/06 20:34:55 deraadt Exp $      */
d39 1
a39 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.24 1999/06/06 20:34:55 deraadt Exp $";
a71 1

a74 1
	thishost[sizeof(thishost) - 1] = '\0';
@


1.24
log
@use inet_aton() instead of inet_addr()
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.23 1999/02/05 05:58:42 deraadt Exp $      */
d33 1
a33 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d39 1
a39 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.23 1999/02/05 05:58:42 deraadt Exp $";
d45 1
a45 1
u_short	portnum __P((char *));
d63 1
d89 1
a89 1
	char	*cps[31], **cpp;
d111 1
a111 1
		(void)fprintf(stderr,"not enough segments in line\n");
d129 1
a129 1
						"uncrecognised icmp code %s\n",
d149 3
a151 1
		if (!isdigit(**cpp)) {
a154 1
		fil.fr_skip = atoi(*cpp);
d277 6
a282 1
		fil.fr_ttl = atoi(*cpp);
d307 9
a315 2
			else if (isdigit(**cpp))
				fil.fr_proto = atoi(*cpp);
a363 1
			(void)fprintf(stderr, "bad host (%s)\n", *cpp);
a391 1
			(void)fprintf(stderr, "bad host (%s)\n", *cpp);
d461 6
a466 1
		fil.fr_grhead = atoi(*cpp);
d478 6
a483 1
		fil.fr_group = atoi(*cpp);
d562 3
a564 2
 * returns false if neither "hostmask/num" or "hostmask mask addr" are
 * found in the line segments
d572 1
a572 1
	char	*s;
d574 1
d581 11
a591 5
		if (!isdigit(*s))
			return -1;
		if (index(s, '.'))
			*msk = inet_addr(s);
		if (!index(s, '.') && !index(s, 'x')) {
d595 4
a598 3
			for (bits = atoi(s); bits; bits--) {
				*msk /= 2;
				*msk |= ntohl(inet_addr("128.0.0.0"));
d600 4
a603 4
			*msk = htonl(*msk);
		} else {
			if (inet_aton(s, (struct in_addr *)msk) == -1)
				return -1;
d606 2
a607 1
		if (resolved == -1)
d609 1
d619 2
a620 1
		if (resolved == -1)
d622 1
d625 2
a626 1
		if (inet_aton(**seg, (struct in_addr *)msk) == -1)
d628 2
d637 2
a638 1
		if (resolved == -1)
d640 1
d646 1
d663 1
a663 1
	if (!strcasecmp("any",host))
d696 2
a697 1
			*pp = portnum(**seg);
d704 2
a705 2
				fprintf(stderr,"unknown range operator (%s)\n",
				    **seg);
d709 6
a714 1
			*tp = portnum(**seg);
d728 1
a728 1
			(void)fprintf(stderr,"unknown comparator (%s)\n",
d734 2
a735 1
			*pp = portnum(**seg);
d745 1
a745 1
 * straight atoi()
d747 1
a747 1
u_short	portnum(name)
d749 1
d753 10
a762 6

	if (isdigit(*name))
		return (u_short)atoi(name);
	if (!proto)
		proto = "tcp/udp";
	if (strcasecmp(proto, "tcp/udp")) {
d764 4
a767 2
		if (sp)
			return ntohs(sp->s_port);
d772 1
a772 1
	if (sp)
d786 2
a787 1
	return ntohs(p1);
d1054 5
a1058 1
		i = atoi(**cp);
d1086 5
a1090 1
		i = atoi(**cp);
d1096 1
d1119 6
a1124 2
	if (isdigit(*str))
		return atoi(str);
d1417 1
a1417 1
		(void)printf("%02x ",*s);
d1425 15
@


1.23
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.22 1998/11/24 03:05:34 deraadt Exp $      */
d43 1
a43 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.22 1998/11/24 03:05:34 deraadt Exp $";
d623 1
d628 2
a629 2
	if (isdigit(*host))
		return inet_addr(host);
@


1.22
log
@Bail out instead of core-dumping if we don't understand the port range operator; ws@@netbsd
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.21 1998/09/15 09:55:45 pattonme Exp $      */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d43 1
a43 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.21 1998/09/15 09:55:45 pattonme Exp $";
@


1.21
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.20 1998/07/09 06:12:23 deraadt Exp $      */
d43 1
a43 1
static const char rcsid[] = "@@(#)$Id$";
d664 5
@


1.20
log
@MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.19 1998/02/27 19:37:35 deraadt Exp $      */
d33 6
a38 2
#include "ip_fil_compat.h"
#include "ip_fil.h"
d43 1
a43 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.19 1998/02/27 19:37:35 deraadt Exp $";
d65 1
a65 1
int	countbits __P((u_long));
d483 2
a484 4
	if (!fil.fr_proto && !(fil.fr_ip.fi_fl & FI_TCPUDP) &&
	    (fil.fr_dcmp || fil.fr_scmp || fil.fr_tcpf)) {
		(void)fprintf(stderr,
			"no protocol given for TCP/UDP comparisons\n");
d487 11
a996 1
		(*cp)++;
d1098 1
a1098 1
u_long	ip;
d1100 1
a1100 1
	u_long	ipn;
@


1.19
log
@network byte order; reed
@
text
@d1 1
a1 1
/*     $OpenBSD: parse.c,v 1.18 1998/01/26 04:13:38 dgregor Exp $      */
d39 1
a39 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 1.18 1998/01/26 04:13:38 dgregor Exp $";
d69 1
a69 1
static	char	thishost[64];
@


1.18
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*     $OpenBSD$      */
d39 1
a39 1
static const char rcsid[] = "@@(#)$Id: parse.c,v 2.0.2.18.2.1 1997/11/20 12:43:49 darrenr Exp $";
d625 1
a625 1
		return np->n_net;
@


1.17
log
@fix parsing of various arguments; felix@@mamba.pond.sub.org
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.16 1997/08/24 18:29:39 millert Exp $	*/
d3 1
a3 1
 * (C)opyright 1993-1996 by Darren Reed.
d11 1
a16 1
#include <sys/types.h>
d18 1
a27 2
#include "ip_fil_compat.h"
#include "ip_fil.h"
d32 3
a35 1
#include <ctype.h>
d37 3
a39 3
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] ="@@(#)parse.c	1.44 6/5/96 (C) 1993-1996 Darren Reed";
static	char	rcsid[] = "$DRId: parse.c,v 2.0.1.4 1997/03/20 15:49:25 darrenr Exp $";
a43 1
extern	int	gethostname();
d45 18
a62 7
u_long	hostnum(), optname();
u_short	portnum();
u_char	tcp_flags();
struct	frentry	*parse();
void	binprint(), printfr();
int	addicmp(), extras(), hostmask(), ports(), icmpcode(), addkeep();
int	to_interface();
d116 2
a117 1
		fil.fr_hits = atoi(*cpp++ + 1) + 1;
d120 1
a120 1
		fil.fr_flags = FR_BLOCK;
d125 2
a126 2
				fil.fr_icode = icmpcode(*cpp + 12);
				if (fil.fr_icode == -1) {
d128 1
a128 1
						"unrecognized icmp code %s\n",
d132 1
d139 1
a139 1
		fil.fr_flags = FR_ACCOUNT;
d141 12
a152 1
		fil.fr_flags = FR_PASS;
d154 1
a154 1
		fil.fr_flags = FR_LOG;
d343 7
a349 2
		if (hostmask(&cpp, &fil.fr_src, &fil.fr_smsk,
			     &fil.fr_sport, &ch, &fil.fr_stop)) {
d372 7
a378 2
		if (hostmask(&cpp, &fil.fr_dst, &fil.fr_dmsk,
			     &fil.fr_dport, &ch, &fil.fr_dtop)) {
d442 24
d479 2
a480 1
	if (!fil.fr_proto && (fil.fr_dcmp || fil.fr_scmp || fil.fr_tcpf)) {
d504 1
a504 1
	s = strchr(to, ':');
d536 1
a536 1
u_long	*sa, *msk;
d546 1
a546 1
	if ((s = strchr(**seg, '/'))) {
d550 1
a550 1
		if (strchr(s, '.'))
d552 1
a552 1
		if (!strchr(s, '.') && !strchr(s, 'x')) {
d604 1
a604 1
u_long	hostnum(host, resolved)
d627 1
a627 1
	return *(u_int32_t *)hp->h_addr;
d732 1
a732 1
		if (!(t = strchr(flagset, *s))) {
d765 2
a766 2
	       !strncasecmp(**cp, "not", 3) || !strncasecmp(**cp, "opt", 3) ||
	       !strncasecmp(**cp, "frag", 4) || !strncasecmp(**cp, "no", 2) ||
d837 1
a837 1
u_long optname(cp, sp)
d887 3
d893 1
d962 2
a963 2
	"redir", (char *)NULL, (char *)NULL, "echo", (char *)NULL,
	(char *)NULL, "timex", "paramprob", "timest", "timestrep",
d1152 1
a1152 1
	if (fp->fr_flags & FR_PASS) {
d1154 1
a1154 1
	} else if (fp->fr_flags & FR_BLOCK) {
d1175 6
d1225 1
d1227 1
a1227 1
		(void)printf("from any ");
d1229 1
a1229 1
		(void)printf("from %s", inet_ntoa(fp->fr_src));
d1242 2
d1245 1
a1245 1
		(void)printf("to any");
d1247 1
a1247 1
		(void)printf("to %s", inet_ntoa(fp->fr_dst));
d1319 4
@


1.16
log
@64bit fix, cast pointers to long, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.15 1997/06/24 05:37:35 millert Exp $	*/
d706 2
a707 2
	       !strncasecmp(**cp, "not", 3) || !strncasecmp(**cp, "opt", 4) ||
	       !strncasecmp(**cp, "frag", 3) || !strncasecmp(**cp, "no", 2) ||
@


1.15
log
@Remove an errant line that got missed in the merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.14 1997/06/23 17:20:31 kstailey Exp $	*/
d464 1
a464 1
		     (fdp->fd_ifp || (int)fdp->fd_ifp == -1) ? "" : "(!)");
d1133 1
a1133 1
			(fp->fr_ifa || (int)fp->fr_ifa == -1) ? "" : "(!)");
@


1.14
log
@merge in 3.1.11
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.13 1997/06/23 01:16:14 deraadt Exp $	*/
a119 1
				fil.fr_icode = icode;
@


1.13
log
@sizeof(int) != sizeof(long)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.12 1997/04/19 19:08:29 kstailey Exp $	*/
d38 1
a38 1
static	char	rcsid[] = "$DRId: parse.c,v 2.0.1.2 1997/02/17 13:59:44 darrenr Exp $";
d113 2
a114 3
				int icode = icmpcode(*cpp + 12);

				if (icode == -1) {
d465 1
a465 1
		     (fdp->fd_ifp || (long)fdp->fd_ifp == -1) ? "" : "(!)");
d934 3
a936 1
		if (i == -1)
d938 1
d1134 1
a1134 1
			(fp->fr_ifa || (long)fp->fr_ifa == -1) ? "" : "(!)");
@


1.12
log
@thorpej:
icmpcode() returns an int, and, more importantly, -1 on failure.  So,
make this work on systems with unsigned chars by placing the return
value of icmpcode() in a temporary variable, checking for failure, and
then only setting fil.fr_icode (a char) upon success.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.11 1997/04/06 19:52:11 millert Exp $	*/
d570 1
a570 1
	return *(u_long *)hp->h_addr;
@


1.11
log
@Fix int vs. long problems
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.10 1997/02/26 15:05:36 kstailey Exp $	*/
d113 3
a115 2
				fil.fr_icode = icmpcode(*cpp + 12);
				if (fil.fr_icode == -1) {
d117 1
a117 1
						"uncrecognised icmp code %s\n",
d121 1
@


1.10
log
@post 1.3.8 patches
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.9 1997/02/26 04:35:40 kstailey Exp $	*/
d464 1
a464 1
		     (fdp->fd_ifp || (int)fdp->fd_ifp == -1) ? "" : "(!)");
d1130 1
a1130 1
			(fp->fr_ifa || (int)fp->fr_ifa == -1) ? "" : "(!)");
@


1.9
log
@version 1.3.8
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d875 3
@


1.8
log
@r?index -> strr?chr
@
text
@d1 1
d36 1
a36 1
#ifndef	lint
d38 1
a38 1
static	char	rcsid[] = "$Id: parse.c,v 1.7 1996/10/08 07:33:32 niklas Exp $";
d51 2
d81 5
d106 2
a107 9
	/*
	 * does it start with one of the two possible first words ?
	 */
	if (strcasecmp("block",*cpp) && strcasecmp("pass",*cpp) &&
	    strcasecmp("log",*cpp) && strcasecmp("count",*cpp)) {
		(void)fprintf(stderr, "unknown keyword (%s)\n", *cpp);
		return NULL;
	}
	if (**cpp == 'b') {
d125 1
a125 1
	} else if (**cpp == 'c')
d127 1
a127 1
	else if (**cpp == 'p') {
d129 1
a129 1
	} else if (**cpp == 'l') {
d139 6
d150 1
a150 1
	else if (!strcasecmp("out", *cpp))
d152 10
a161 1
	else {
d183 9
d200 1
a200 1
	if (!strcasecmp(*cpp, "on")) {
a218 10
#if SOLARIS
			if (!strcasecmp(*cpp, "dup-to")  ||
			    !strcasecmp(*cpp, "to") ||
			    !strcasecmp(*cpp, "fastroute")) {
				(void) fprintf(stderr,
					"%s not supported under SunOS5\n",
					*cpp);
				return NULL;
			}
#endif
d236 1
a236 1
	if (!strcasecmp(*cpp, "tos")) {
d246 1
a246 1
	if (!strcasecmp(*cpp, "ttl")) {
d260 1
a260 1
	if (!strcasecmp(*cpp, "proto")) {
d300 4
d709 1
a709 1
		if (***cp == 'n') {
d713 1
a713 1
		} else if (***cp == 'i') {
d718 1
a718 1
		} else if (***cp == 'f') {
d723 1
a723 1
		} else if (***cp == 'o') {
d733 1
a733 1
		} else if (***cp == 's') {
d1002 1
a1002 1
	if (***cp == 's')
d1004 1
a1004 1
	else if (***cp == 'f')
a1078 1
	frdest_t	*fdp;
d1119 2
@


1.7
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d37 1
a37 1
static	char	rcsid[] = "$Id: parse.c,v 1.6 1996/07/18 05:11:03 dm Exp $";
d426 1
a426 1
	s = index(to, ':');
d468 1
a468 1
	if ((s = index(**seg, '/'))) {
d472 1
a472 1
		if (index(s, '.'))
d474 1
a474 1
		if (!index(s, '.') && !index(s, 'x')) {
d654 1
a654 1
		if (!(t = index(flagset, *s))) {
@


1.6
log
@ipfilter 3.1.0
@
text
@d26 1
d37 1
a37 1
static	char	rcsid[] = "$Id: parse.c,v 1.3 1996/06/30 11:33:35 darrenr Exp $";
@


1.5
log
@Print empty TCP flags checks (like '/SA' ) properly
@
text
@a0 2
/*	$OpenBSD: parse.c,v 1.4 1996/06/23 14:30:55 deraadt Exp $	*/

d35 2
a36 1
static	char	sccsid[] ="@@(#)parse.c	1.41 4/10/96 (C) 1993-1996 Darren Reed";
d125 1
a125 1
	else if (**cpp == 'p')
d127 1
a127 1
	else if (**cpp == 'l') {
d191 28
a219 1

d417 34
d816 1
a816 1
	s = "opt ";
d836 1
a836 1
			    ((io->on_bit & secmsk) == (io->on_bit & secbits))) {
a841 2
	if (strcmp(s, "opt "))
		putchar(' ');
d845 1
a845 1
		printf("not opt");
d970 1
a970 1
	    fp->fr_proto != IPPROTO_ICMP) {
d1059 1
d1064 1
a1064 1
	if (fp->fr_flags & FR_PASS)
a1065 6
	else if (fp->fr_flags & FR_LOG) {
		(void)printf("log");
		if (fp->fr_flags & FR_LOGBODY)
			(void)printf(" body");
		if (fp->fr_flags & FR_LOGFIRST)
			(void)printf(" first");
d1079 6
d1104 1
a1104 1
	if (*fp->fr_ifname)
d1107 8
d1146 1
a1146 1
		(void)printf("to any ");
d1150 1
a1150 1
			(void)printf("/%s ", inet_ntoa(fp->fr_dmsk));
d1152 1
a1152 1
			(void)printf("/%d ", ones);
d1156 1
a1156 1
			(void)printf("port %d %s %d ", fp->fr_dport,
d1159 1
a1159 1
			(void)printf("port %s %s ", pcmp1[fp->fr_dcmp],
d1166 1
a1166 1
		(void)printf("with ");
d1175 2
a1176 2
				(void)printf("not ");
			(void)printf("ipopt ");
d1180 2
a1181 2
				(void)printf("not ");
			(void)printf("short ");
d1185 2
a1186 2
				(void)printf("not ");
			(void)printf("frag ");
d1197 1
a1197 1
			(void)printf("icmp-type %s ", icmptypes[type]);
d1199 1
a1199 1
			(void)printf("icmp-type %d ", type);
d1201 1
a1201 1
			(void)printf("code %d ", code);
d1204 1
a1204 1
		(void)printf("flags ");
d1215 5
a1219 3
	if (fp->fr_flags & (FR_KEEPFRAG|FR_KEEPSTATE))
		printf(" keep %s ",
			(fp->fr_flags & FR_KEEPFRAG) ? "frags" : "state");
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1136 1
a1136 1
	if (fp->fr_proto == IPPROTO_TCP && fp->fr_tcpf) {
@


1.3
log
@ipfilter 3.0.4
@
text
@d1 2
@


1.2
log
@IP filter 3.0.1
@
text
@d2 1
a2 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d35 1
a35 1
static	char	sccsid[] ="@@(#)parse.c	1.33 1/14/96 (C) 1993 Darren Reed";
d355 1
a355 1
	if (*cpp && !strcasecmp(*cpp, "keep"))
d378 8
a385 1

d411 1
a411 1
		else {
d420 3
d440 2
a441 4
		if (index(**seg, '.'))
			*msk = inet_addr(**seg);
		else
			*msk = (u_long)strtol(**seg, NULL, 0);
d501 1
a501 1
	if (!strcasecmp(**seg, "port") && *(*seg + 1) && *(seg + 2)) {
d503 1
a503 1
		if (isdigit(***seg) && *(seg + 2)) {
d550 1
a550 1
		return htons((u_short)atoi(name));
d556 1
a556 1
			return sp->s_port;
d575 1
a575 1
	return p1;
d627 1
a627 1
		if (***cp == 'n')
d629 13
a641 5
		else if (***cp == 'i')
			oflags = FI_OPTIONS;
		else if (***cp == 'f')
			oflags = FI_FRAG;
		else if (***cp == 'o') {
d657 5
a661 1
			oflags = FI_SHORT;
d665 9
a673 2
		fr->fr_mip.fi_fl |= oflags;
		fr->fr_mip.fi_optmsk |= opts;
d685 2
d746 3
a748 2
void optprint(optmsk, secmsk)
u_char optmsk, secmsk;
d751 2
a752 1
	char *s = "", *t = "";
d754 1
a754 1
	printf("opt ");
d756 10
a765 3
		if (io->on_bit & optmsk) {
			printf("%s%s", s, io->on_name);
			s = ",";
d767 5
a771 2
	if (secmsk) {
		putchar(' ');
d773 4
a776 3
			if (secmsk & so->on_bit) {
				printf("%s%s", t, so->on_name);
				t = ",";
d779 33
d968 1
a968 1
		if ((sv = getservbyport(htons(port), "tcp"))) {
d971 3
a973 3
			sv1 = getservbyport(htons(port), "udp");
			if (sv1 && !strcasecmp(buf, sv->s_name))
				return buf;
d975 2
d978 1
a978 1
		if ((sv = getservbyport(htons(port), p->p_name))) {
d1017 2
a1018 1
					printf("(%s)",icmpcodes[fp->fr_icode]);
d1053 1
a1053 1
	} else if ((pr = fp->fr_proto)) {
d1069 1
a1069 1
	if (fp->fr_sport)
d1071 2
a1072 2
			(void)printf("port %d %s %d ", ntohs(fp->fr_sport),
				     pcmp1[fp->fr_scmp], ntohs(fp->fr_stop));
d1075 1
a1075 1
				     portname(pr, ntohs(fp->fr_sport)));
d1085 1
a1085 1
	if (fp->fr_dport) {
d1087 2
a1088 2
			(void)printf("port %d %s %d ", ntohs(fp->fr_dport),
				     pcmp1[fp->fr_dcmp], ntohs(fp->fr_dtop));
d1091 1
a1091 1
				     portname(pr, ntohs(fp->fr_dport)));
d1093 4
a1096 1
	if (fp->fr_mip.fi_fl & (FI_SHORT|FI_OPTIONS|FI_FRAG)) {
d1098 10
a1107 9
		if (fp->fr_mip.fi_fl & FI_OPTIONS) {
			if (fp->fr_ip.fi_optmsk)
				optprint(fp->fr_ip.fi_optmsk,
					 fp->fr_ip.fi_secmsk);
			else {
				if (!(fp->fr_ip.fi_fl & FI_OPTIONS))
					(void)printf("not ");
				(void)printf("ipopt ");
			}
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d26 1
a26 1
#include <netinet/ip_fil.h>
d35 1
a35 1
static	char	sccsid[] ="@@(#)parse.c	1.25 11/11/95 (C) 1993 Darren Reed";
d40 1
d47 1
a47 1
int	addicmp(), extras(), hostmask(), ports();
d53 10
d100 1
a100 1
	    strcasecmp("log",*cpp)) {
d109 9
d122 3
a124 1
	} else if (**cpp == 'p')
d132 4
d144 2
a145 2
		(void)fprintf(stderr, "missing 'in'/'out' keyword (%s)\n",
			*cpp);
a147 1

d150 1
d161 4
d353 7
d393 1
a393 1
	int	bits = -1;
d414 3
a416 1
		*sa = hostnum(**seg) & *msk;
d425 3
a427 1
		*sa = hostnum(**seg);
d430 4
a433 1
		*msk = inet_addr(**seg);
d440 3
a442 1
		*sa = hostnum(**seg);
d455 1
a455 1
u_long	hostnum(host)
d457 1
d462 1
d467 2
d471 3
a473 1
		if (!(np = getnetbyname(host)))
d475 1
d541 1
a541 1
	if (isdigit(*name) || !proto)
d543 2
d798 58
d932 2
d936 1
a936 1
		if (fp->fr_flags & FR_RETICMP)
d938 6
d946 2
a947 1
	}
d954 2
a955 1
	if (fp->fr_flags & (FR_LOGB|FR_LOGP)) {
d958 3
a960 1
			(void)printf(" body");
d1064 3
@

