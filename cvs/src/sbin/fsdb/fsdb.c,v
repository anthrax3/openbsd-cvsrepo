head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.2
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.8
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.12
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.10
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.09.09.15.37.14;	author tb;	state Exp;
branches;
next	1.30;
commitid	TXzQrSRLn0xGub30;

1.30
date	2016.06.07.01.29.38;	author tedu;	state Exp;
branches;
next	1.29;
commitid	aJp7bbwjTwgUYbAT;

1.29
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	F55lwc3gS4GN2mLs;

1.28
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.23.07.11.27;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.16.19.25.49;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.10.16.08.08;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.10.17.17.25;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.20.22.23.57;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.19.14.16.01;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.31.08.44.07;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.26.16.09.27;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.26.08.01.54;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.06.22.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.17.06.56.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	99.08.06.20.41.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.05.19.03.17.15;	author alex;	state Exp;
branches;
next	1.5;

1.5
date	98.08.08.20.56.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.16.04.04.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.46.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.21.00.15.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Tighten pledge for fsdb and eliminate a strcmp("fsdb", getprogname())
by passing a flag to setup().

ok deraadt
@
text
@/*	$OpenBSD: fsdb.c,v 1.30 2016/06/07 01:29:38 tedu Exp $	*/
/*	$NetBSD: fsdb.c,v 1.7 1997/01/11 06:50:53 lukem Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by John T. Kohl.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/mount.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <grp.h>
#include <histedit.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include "fsdb.h"
#include "fsck.h"
#include "extern.h"

extern char *__progname;	/* from crt0.o */

int main(int, char *[]);
static void usage(void);
static int cmdloop(void);
static int helpfn(int, char *[]);
static char *prompt(EditLine *);
static int scannames(struct inodesc *);
static int dolookup(char *);
static int chinumfunc(struct inodesc *);
static int chnamefunc(struct inodesc *);
static int dotime(char *, time_t *, int32_t *);

int returntosingle = 0;
union dinode *curinode;
ino_t curinum;

static void
usage(void)
{
	fprintf(stderr, "usage: %s [-d] -f fsname\n", __progname);
	exit(1);
}

/*
 * We suck in lots of fsck code, and just pick & choose the stuff we want.
 *
 * fsreadfd is set up to read from the file system, fswritefd to write to
 * the file system.
 */
int
main(int argc, char *argv[])
{
	int ch, rval;
	char *fsys = NULL;

	while (-1 != (ch = getopt(argc, argv, "f:d"))) {
		switch (ch) {
		case 'f':
			fsys = optarg;
			break;
		case 'd':
			debug++;
			break;
		default:
			usage();
		}
	}
	if (fsys == NULL)
		usage();
	if (!setup(fsys, 1))
		errx(1, "cannot set up file system `%s'", fsys);
	printf("Editing file system `%s'\nLast Mounted on %s\n", fsys,
	    sblock.fs_fsmnt);
	rval = cmdloop();
	sblock.fs_clean = 0;		/* mark it dirty */
	sbdirty();
	ckfini(0);
	printf("*** FILE SYSTEM MARKED DIRTY\n");
	printf("*** BE SURE TO RUN FSCK TO CLEAN UP ANY DAMAGE\n");
	printf("*** IF IT WAS MOUNTED, RE-MOUNT WITH -u -o reload\n");
	exit(rval);
}

#define CMDFUNC(func) static int func(int argc, char *argv[])
#define CMDFUNCSTART(func) static int func(int argc, char *argv[])

CMDFUNC(helpfn);
CMDFUNC(focus);				/* focus on inode */
CMDFUNC(active);			/* print active inode */
CMDFUNC(focusname);			/* focus by name */
CMDFUNC(zapi);				/* clear inode */
CMDFUNC(uplink);			/* incr link */
CMDFUNC(downlink);			/* decr link */
CMDFUNC(linkcount);			/* set link count */
CMDFUNC(quit);				/* quit */
CMDFUNC(ls);				/* list directory */
CMDFUNC(rm);				/* remove name */
CMDFUNC(ln);				/* add name */
CMDFUNC(newtype);			/* change type */
CMDFUNC(chmode);			/* change mode */
CMDFUNC(chlen);				/* change length */
CMDFUNC(chaflags);			/* change flags */
CMDFUNC(chgen);				/* change generation */
CMDFUNC(chowner);			/* change owner */
CMDFUNC(chgroup);			/* Change group */
CMDFUNC(back);				/* pop back to last ino */
CMDFUNC(chmtime);			/* Change mtime */
CMDFUNC(chctime);			/* Change ctime */
CMDFUNC(chatime);			/* Change atime */
CMDFUNC(chinum);			/* Change inode # of dirent */
CMDFUNC(chname);			/* Change dirname of dirent */

static struct cmdtable cmds[] = {
	{ "help", "Print out help", 1, 1, helpfn },
	{ "?", "Print out help", 1, 1, helpfn },
	{ "inode", "Set active inode to INUM", 2, 2, focus },
	{ "clri", "Clear inode INUM", 2, 2, zapi },
	{ "lookup", "Set active inode by looking up NAME", 2, 2, focusname },
	{ "cd", "Set active inode by looking up NAME", 2, 2, focusname },
	{ "back", "Go to previous active inode", 1, 1, back },
	{ "active", "Print active inode", 1, 1, active },
	{ "print", "Print active inode", 1, 1, active },
	{ "uplink", "Increment link count", 1, 1, uplink },
	{ "downlink", "Decrement link count", 1, 1, downlink },
	{ "linkcount", "Set link count to COUNT", 2, 2, linkcount },
	{ "ls", "List current inode as directory", 1, 1, ls },
	{ "rm", "Remove NAME from current inode directory", 2, 2, rm },
	{ "del", "Remove NAME from current inode directory", 2, 2, rm },
	{ "ln", "Hardlink INO into current inode directory as NAME", 3, 3, ln },
	{ "chinum", "Change dir entry number INDEX to INUM", 3, 3, chinum },
	{ "chname", "Change dir entry number INDEX to NAME", 3, 3, chname },
	{ "chtype", "Change type of current inode to TYPE", 2, 2, newtype },
	{ "chmod", "Change mode of current inode to MODE", 2, 2, chmode },
	{ "chown", "Change owner of current inode to OWNER", 2, 2, chowner },
	{ "chlen", "Change length of current inode to LENGTH", 2, 2, chlen },
	{ "chgrp", "Change group of current inode to GROUP", 2, 2, chgroup },
	{ "chflags", "Change flags of current inode to FLAGS", 2, 2, chaflags },
	{ "chgen", "Change generation number of current inode to GEN", 2, 2, chgen },
	{ "mtime", "Change mtime of current inode to MTIME", 2, 2, chmtime },
	{ "ctime", "Change ctime of current inode to CTIME", 2, 2, chctime },
	{ "atime", "Change atime of current inode to ATIME", 2, 2, chatime },
	{ "quit", "Exit", 1, 1, quit },
	{ "q", "Exit", 1, 1, quit },
	{ "exit", "Exit", 1, 1, quit },
	{ NULL, 0, 0, 0 },
};

static int
helpfn(int argc, char *argv[])
{
	struct cmdtable *cmdtp;

	printf("Commands are:\n%-10s %5s %5s   %s\n",
	    "command", "min argc", "max argc", "what");

	for (cmdtp = cmds; cmdtp->cmd; cmdtp++)
		printf("%-10s %5u %5u   %s\n",
		    cmdtp->cmd, cmdtp->minargc, cmdtp->maxargc, cmdtp->helptxt);
	return 0;
}

static char *
prompt(EditLine *el)
{
	static char pstring[64];

	snprintf(pstring, sizeof(pstring), "fsdb (inum: %llu)> ",
	    (unsigned long long)curinum);
	return pstring;
}


static int
cmdloop(void)
{
	char *line = NULL;
	const char *elline;
	int cmd_argc, rval = 0, known;
#define scratch known
	char **cmd_argv;
	struct cmdtable *cmdp;
	History *hist;
	EditLine *elptr;
	HistEvent hev;

	curinode = ginode(ROOTINO);
	curinum = ROOTINO;
	printactive();

	hist = history_init();
	history(hist, &hev, H_SETSIZE, 100);	/* 100 elt history buffer */

	elptr = el_init(__progname, stdin, stdout, stderr);
	el_set(elptr, EL_EDITOR, "emacs");
	el_set(elptr, EL_PROMPT, prompt);
	el_set(elptr, EL_HIST, history, hist);
	el_source(elptr, NULL);

	while ((elline = el_gets(elptr, &scratch)) != NULL && scratch != 0) {
		if (debug)
			printf("command `%s'\n", line);

		history(hist, &hev, H_ENTER, elline);

		line = strdup(elline);
		if (line == NULL)
			errx(1, "out of memory");
		cmd_argv = crack(line, &cmd_argc);
		if (cmd_argc) {
			/*
			 * el_parse returns -1 to signal that it's not been handled
			 * internally.
			 */
			if (el_parse(elptr, cmd_argc, (const char **)cmd_argv) != -1)
				continue;
			known = 0;
			for (cmdp = cmds; cmdp->cmd; cmdp++) {
				if (!strcmp(cmdp->cmd, cmd_argv[0])) {
					if (cmd_argc >= cmdp->minargc &&
					    cmd_argc <= cmdp->maxargc)
						rval = (*cmdp->handler)(cmd_argc,
						    cmd_argv);
					else
						rval = argcount(cmdp,
						    cmd_argc, cmd_argv);
					known = 1;
					break;
				}
			}
			if (!known) {
				warnx("unknown command `%s'", cmd_argv[0]);
				rval = 1;
			}
		} else
			rval = 0;
		free(line);
		if (rval < 0)
			return rval;
		if (rval)
			warnx("rval was %d", rval);
	}
	el_end(elptr);
	history_end(hist);
	return rval;
}

static ino_t ocurrent;

#define GETINUM(ac,inum)    inum = strtoull(argv[ac], &cp, 0); \
	if (inum < ROOTINO || inum > maxino || cp == argv[ac] || *cp != '\0' ) { \
		printf("inode %llu out of range; range is [%llu,%llu]\n", \
		    (unsigned long long)inum, (unsigned long long)ROOTINO, \
		    (unsigned long long)maxino); \
		return 1; \
	}

/*
 * Focus on given inode number
 */
CMDFUNCSTART(focus)
{
	ino_t inum;
	char *cp;

	GETINUM(1,inum);
	curinode = ginode(inum);
	ocurrent = curinum;
	curinum = inum;
	printactive();
	return 0;
}

CMDFUNCSTART(back)
{
	curinum = ocurrent;
	curinode = ginode(curinum);
	printactive();
	return 0;
}

CMDFUNCSTART(zapi)
{
	ino_t inum;
	union dinode *dp;
	char *cp;

	GETINUM(1,inum);
	dp = ginode(inum);
	clearinode(dp);
	inodirty();
	if (curinode)			/* re-set after potential change */
		curinode = ginode(curinum);
	return 0;
}

CMDFUNCSTART(active)
{
	printactive();
	return 0;
}


CMDFUNCSTART(quit)
{
	return -1;
}

CMDFUNCSTART(uplink)
{
	if (!checkactive())
		return 1;
	DIP_SET(curinode, di_nlink, DIP(curinode, di_nlink) + 1);
	printf("inode %llu link count now %d\n",
	    (unsigned long long)curinum, DIP(curinode, di_nlink));
	inodirty();
	return 0;
}

CMDFUNCSTART(downlink)
{
	if (!checkactive())
		return 1;
	DIP_SET(curinode, di_nlink, DIP(curinode, di_nlink) - 1);
	printf("inode %llu link count now %d\n",
	    (unsigned long long)curinum, DIP(curinode, di_nlink));
	inodirty();
	return 0;
}

static const char *typename[] = {
	"unknown",
	"fifo",
	"char special",
	"unregistered #3",
	"directory",
	"unregistered #5",
	"blk special",
	"unregistered #7",
	"regular",
	"unregistered #9",
	"symlink",
	"unregistered #11",
	"socket",
	"unregistered #13",
	"whiteout",
};

static int slot;

static int
scannames(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;

	printf("slot %d ino %llu reclen %d: %s, `%.*s'\n",
	    slot++, (unsigned long long)dirp->d_ino, dirp->d_reclen,
	    typename[dirp->d_type], dirp->d_namlen, dirp->d_name);
	return (KEEPON);
}

CMDFUNCSTART(ls)
{
	struct inodesc idesc;
	checkactivedir();			/* let it go on anyway */

	slot = 0;
	idesc.id_number = curinum;
	idesc.id_func = scannames;
	idesc.id_type = DATA;
	idesc.id_fix = IGNORE;
	ckinode(curinode, &idesc);
	curinode = ginode(curinum);

	return 0;
}

static int
dolookup(char *name)
{
	struct inodesc idesc;

	if (!checkactivedir())
		return 0;
	idesc.id_number = curinum;
	idesc.id_func = findino;
	idesc.id_name = name;
	idesc.id_type = DATA;
	idesc.id_fix = IGNORE;
	if (ckinode(curinode, &idesc) & FOUND) {
		curinum = idesc.id_parent;
		curinode = ginode(curinum);
		printactive();
		return 1;
	} else {
		warnx("name `%s' not found in current inode directory", name);
		return 0;
	}
}

CMDFUNCSTART(focusname)
{
	char *p, *val;

	if (!checkactive())
		return 1;

	ocurrent = curinum;

	if (argv[1][0] == '/') {
		curinum = ROOTINO;
		curinode = ginode(ROOTINO);
	} else {
		if (!checkactivedir())
		    return 1;
	}
	for (p = argv[1]; p != NULL;) {
		while ((val = strsep(&p, "/")) != NULL && *val == '\0')
			continue;
		if (val) {
			printf("component `%s': ", val);
			fflush(stdout);
			if (!dolookup(val)) {
				curinode = ginode(curinum);
				return(1);
			}
		}
	}
	return 0;
}

CMDFUNCSTART(ln)
{
	ino_t inum;
	int rval;
	char *cp;

	GETINUM(1,inum);

	if (!checkactivedir())
		return 1;
	rval = makeentry(curinum, inum, argv[2]);
	if (rval)
		printf("Ino %llu entered as `%s'\n",
		    (unsigned long long)inum, argv[2]);
	else
		printf("could not enter name? weird.\n");
	curinode = ginode(curinum);
	return rval;
}

CMDFUNCSTART(rm)
{
	int rval;

	if (!checkactivedir())
		return 1;
	rval = changeino(curinum, argv[1], 0);
	if (rval & ALTERED) {
		printf("Name `%s' removed\n", argv[1]);
		return 0;
	} else {
		printf("could not remove name? weird.\n");
		return 1;
	}
}

static long slotcount, desired;

static int
chinumfunc(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;

	if (slotcount++ == desired) {
	    dirp->d_ino = idesc->id_parent;
	    return STOP|ALTERED|FOUND;
	}
	return KEEPON;
}

CMDFUNCSTART(chinum)
{
	char *cp;
	ino_t inum;
	struct inodesc idesc;

	slotcount = 0;
	if (!checkactivedir())
		return 1;
	GETINUM(2,inum);

	desired = strtol(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' || desired < 0) {
		printf("invalid slot number `%s'\n", argv[1]);
		return 1;
	}

	idesc.id_number = curinum;
	idesc.id_func = chinumfunc;
	idesc.id_fix = IGNORE;
	idesc.id_type = DATA;
	idesc.id_parent = inum;		/* XXX convenient hiding place */

	if (ckinode(curinode, &idesc) & FOUND)
		return 0;
	else {
		warnx("no %sth slot in current directory", argv[1]);
		return 1;
	}
}

static int
chnamefunc(struct inodesc *idesc)
{
	struct direct *dirp = idesc->id_dirp;
	struct direct testdir;

	if (slotcount++ == desired) {
		/* will name fit? */
		testdir.d_namlen = strlen(idesc->id_name);
		if (DIRSIZ(NEWDIRFMT, &testdir) <= dirp->d_reclen) {
			dirp->d_namlen = testdir.d_namlen;
			strlcpy(dirp->d_name, idesc->id_name, sizeof dirp->d_name);
			return STOP|ALTERED|FOUND;
		} else
			return STOP|FOUND;	/* won't fit, so give up */
	}
	return KEEPON;
}

CMDFUNCSTART(chname)
{
	int rval;
	char *cp;
	struct inodesc idesc;

	slotcount = 0;
	if (!checkactivedir())
		return 1;

	desired = strtoul(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0') {
		printf("invalid slot number `%s'\n", argv[1]);
		return 1;
	}

	idesc.id_number = curinum;
	idesc.id_func = chnamefunc;
	idesc.id_fix = IGNORE;
	idesc.id_type = DATA;
	idesc.id_name = argv[2];

	rval = ckinode(curinode, &idesc);
	if ((rval & (FOUND|ALTERED)) == (FOUND|ALTERED))
		return 0;
	else if (rval & FOUND) {
		warnx("new name `%s' does not fit in slot %s", argv[2], argv[1]);
		return 1;
	} else {
		warnx("no %sth slot in current directory", argv[1]);
		return 1;
	}
}

static struct typemap {
	const char *typename;
	int typebits;
} typenamemap[]  = {
	{"file", IFREG},
	{"dir", IFDIR},
	{"socket", IFSOCK},
	{"fifo", IFIFO},
};

CMDFUNCSTART(newtype)
{
	int type;
	struct typemap *tp;

	if (!checkactive())
		return 1;
	type = DIP(curinode, di_mode) & IFMT;
	for (tp = typenamemap;
	    tp < &typenamemap[sizeof(typenamemap)/sizeof(*typenamemap)];
	    tp++) {
		if (!strcmp(argv[1], tp->typename)) {
			printf("setting type to %s\n", tp->typename);
			type = tp->typebits;
			break;
		}
	}
	if (tp == &typenamemap[sizeof(typenamemap)/sizeof(*typenamemap)]) {
		warnx("type `%s' not known", argv[1]);
		warnx("try one of `file', `dir', `socket', `fifo'");
		return 1;
	}
	DIP_SET(curinode, di_mode, DIP(curinode, di_mode) & ~IFMT);
	DIP_SET(curinode, di_mode, DIP(curinode, di_mode) | type);
	inodirty();
	printactive();
	return 0;
}

CMDFUNCSTART(chmode)
{
	int rval = 1;
	long modebits;
	char *cp;

	if (!checkactive())
		return 1;

	modebits = strtol(argv[1], &cp, 8);
	if (cp == argv[1] || *cp != '\0' ) {
		warnx("bad modebits `%s'", argv[1]);
		return 1;
	}

	DIP_SET(curinode, di_mode, DIP(curinode, di_mode) & ~07777);
	DIP_SET(curinode, di_mode, DIP(curinode, di_mode) | modebits);
	inodirty();
	printactive();
	return rval;
}

CMDFUNCSTART(chlen)
{
	int rval = 1;
	long len;
	char *cp;

	if (!checkactive())
		return 1;

	len = strtol(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' || len < 0) {
		warnx("bad length '%s'", argv[1]);
		return 1;
	}

	DIP_SET(curinode, di_size, len);
	inodirty();
	printactive();
	return rval;
}

CMDFUNCSTART(chaflags)
{
	int rval = 1;
	u_long flags;
	char *cp;

	if (!checkactive())
		return 1;

	flags = strtoul(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' ) {
		warnx("bad flags `%s'", argv[1]);
		return 1;
	}

	if (flags > UINT_MAX) {
		warnx("flags set beyond 32-bit range of field (%lx)", flags);
		return(1);
	}
	DIP_SET(curinode, di_flags, flags);
	inodirty();
	printactive();
	return rval;
}

CMDFUNCSTART(chgen)
{
	int rval = 1;
	long gen;
	char *cp;

	if (!checkactive())
		return 1;

	gen = strtol(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' ) {
		warnx("bad gen `%s'", argv[1]);
		return 1;
	}

	if (gen > INT_MAX || gen < INT_MIN) {
		warnx("gen set beyond 32-bit range of field (%lx)", gen);
		return(1);
	}
	DIP_SET(curinode, di_gen, gen);
	inodirty();
	printactive();
	return rval;
}

CMDFUNCSTART(linkcount)
{
	int rval = 1;
	int lcnt;
	char *cp;

	if (!checkactive())
		return 1;

	lcnt = strtol(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' ) {
		warnx("bad link count `%s'", argv[1]);
		return 1;
	}
	if (lcnt > USHRT_MAX || lcnt < 0) {
		warnx("max link count is %d", USHRT_MAX);
		return 1;
	}

	DIP_SET(curinode, di_nlink, lcnt);
	inodirty();
	printactive();
	return rval;
}

CMDFUNCSTART(chowner)
{
	int rval = 1;
	uid_t uid;
	char *cp;
	struct passwd *pwd;

	if (!checkactive())
		return 1;

	uid = strtoul(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' ) {
		/* try looking up name */
		if ((pwd = getpwnam(argv[1]))) {
			uid = pwd->pw_uid;
		} else {
			warnx("bad uid `%s'", argv[1]);
			return 1;
		}
	}

	DIP_SET(curinode, di_uid, uid);
	inodirty();
	printactive();
	return rval;
}

CMDFUNCSTART(chgroup)
{
	int rval = 1;
	gid_t gid;
	char *cp;
	struct group *grp;

	if (!checkactive())
		return 1;

	gid = strtoul(argv[1], &cp, 0);
	if (cp == argv[1] || *cp != '\0' ) {
		if ((grp = getgrnam(argv[1]))) {
			gid = grp->gr_gid;
		} else {
			warnx("bad gid `%s'", argv[1]);
			return 1;
		}
	}

	DIP_SET(curinode, di_gid, gid);
	inodirty();
	printactive();
	return rval;
}

static int
dotime(char *name, time_t *rsec, int32_t *rnsec)
{
	char *p, *val;
	struct tm t;
	time_t sec;
	int32_t nsec;

	p = strchr(name, '.');
	if (p) {
		*p = '\0';
		nsec = strtoul(++p, &val, 0);
		if (val == p || *val != '\0' || nsec >= 1000000000 || nsec < 0) {
			warnx("invalid nanoseconds");
			goto badformat;
		}
	} else
		nsec = 0;

	if (strlen(name) != 14) {
badformat:
		warnx("date format: YYYYMMDDHHMMSS[.nsec]");
		return 1;
	}

	for (p = name; *p; p++)
		if (*p < '0' || *p > '9')
			    goto badformat;

	p = name;
#define VAL() ((*p++) - '0')
	bzero(&t, sizeof t);
	t.tm_year = VAL();
	t.tm_year = VAL() + t.tm_year * 10;
	t.tm_year = VAL() + t.tm_year * 10;
	t.tm_year = VAL() + t.tm_year * 10 - 1900;
	t.tm_mon = VAL();
	t.tm_mon = VAL() + t.tm_mon * 10 - 1;
	t.tm_mday = VAL();
	t.tm_mday = VAL() + t.tm_mday * 10;
	t.tm_hour = VAL();
	t.tm_hour = VAL() + t.tm_hour * 10;
	t.tm_min = VAL();
	t.tm_min = VAL() + t.tm_min * 10;
	t.tm_sec = VAL();
	t.tm_sec = VAL() + t.tm_sec * 10;
	t.tm_isdst = -1;

	sec = mktime(&t);
	if (sec == -1) {
		warnx("date/time out of range");
		return 1;
	}
	*rsec = sec;
	*rnsec = nsec;
	return 0;
}

CMDFUNCSTART(chmtime)
{
	time_t rsec;
	int32_t nsec;

	if (dotime(argv[1], &rsec, &nsec))
		return 1;
	DIP_SET(curinode, di_mtime, rsec);
	DIP_SET(curinode, di_mtimensec, nsec);
	inodirty();
	printactive();
	return 0;
}

CMDFUNCSTART(chatime)
{
	time_t rsec;
	int32_t nsec;

	if (dotime(argv[1], &rsec, &nsec))
		return 1;
	DIP_SET(curinode, di_atime, rsec);
	DIP_SET(curinode, di_atimensec, nsec);
	inodirty();
	printactive();
	return 0;
}

CMDFUNCSTART(chctime)
{
	time_t rsec;
	int32_t nsec;

	if (dotime(argv[1], &rsec, &nsec))
		return 1;
	DIP_SET(curinode, di_ctime, rsec);
	DIP_SET(curinode, di_ctimensec, nsec);
	inodirty();
	printactive();
	return 0;
}
@


1.30
log
@per trending style, add continue to emtpy loop bodies.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.29 2015/01/20 18:22:21 deraadt Exp $	*/
d106 1
a106 1
	if (!setup(fsys))
@


1.29
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.28 2015/01/16 06:39:58 deraadt Exp $	*/
d454 1
a454 1
			;
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.27 2013/04/25 06:43:20 otto Exp $	*/
a32 1
#include <sys/param.h>	/* MAXFRAG */
@


1.27
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.26 2013/04/24 13:46:29 deraadt Exp $	*/
d33 1
a33 1
#include <sys/types.h>
a34 1
#include <sys/param.h>
@


1.26
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.25 2013/04/23 07:11:27 otto Exp $	*/
d287 1
a287 1
#define GETINUM(ac,inum)    inum = strtoul(argv[ac], &cp, 0); \
d289 3
a291 2
		printf("inode %llu out of range; range is [%d,%d]\n", \
		    (unsigned long long)inum, ROOTINO, maxino); \
@


1.25
log
@prepare for more time (bits); ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.24 2013/04/16 19:25:49 deraadt Exp $	*/
d205 2
a206 1
	snprintf(pstring, sizeof(pstring), "fsdb (inum: %d)> ", curinum);
d289 2
a290 2
		printf("inode %d out of range; range is [%d,%d]\n", \
		    inum, ROOTINO, maxino); \
d350 2
a351 1
	printf("inode %d link count now %d\n", curinum, DIP(curinode, di_nlink));
d361 2
a362 1
	printf("inode %d link count now %d\n", curinum, DIP(curinode, di_nlink));
d392 3
a394 3
	printf("slot %d ino %d reclen %d: %s, `%.*s'\n",
	    slot++, dirp->d_ino, dirp->d_reclen, typename[dirp->d_type],
	    dirp->d_namlen, dirp->d_name);
d480 2
a481 1
		printf("Ino %d entered as `%s'\n", inum, argv[2]);
@


1.24
log
@bzero struct tm before use
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.23 2009/10/27 23:59:33 deraadt Exp $	*/
d69 1
a69 1
static int dotime(char *, int32_t *, int32_t *);
d809 1
a809 1
dotime(char *name, int32_t *rsec, int32_t *rnsec)
d813 1
a813 1
	int32_t sec;
d868 2
a869 1
	int32_t rsec, nsec;
d882 2
a883 1
	int32_t rsec, nsec;
d896 2
a897 1
	int32_t rsec, nsec;
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.22 2008/06/26 05:42:06 ray Exp $	*/
d839 1
@


1.22
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.21 2008/06/10 16:08:08 otto Exp $	*/
a31 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.21 2008/06/10 16:08:08 otto Exp $";
#endif /* not lint */
@


1.21
log
@better take the size of the right table; found while tinkering with fsck_ffs
by accident the buggy expression yields the same value.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.20 2007/04/10 17:17:25 millert Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.20 2007/04/10 17:17:25 millert Exp $";
@


1.20
log
@Add support for ffs2 filesystems.  From pedro@@ based on the ufs2
changes in FreeBSD by Kirk McKusick.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.19 2007/02/20 22:23:57 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.19 2007/02/20 22:23:57 jmc Exp $";
d628 1
a628 1
	    tp < &typenamemap[sizeof(typemap)/sizeof(*typemap)];
d636 1
a636 1
	if (tp == &typenamemap[sizeof(typemap)/sizeof(*typemap)]) {
@


1.19
log
@clarify that -f is not optional; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.18 2004/03/19 14:16:01 aaron Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.18 2004/03/19 14:16:01 aaron Exp $";
d83 1
a83 1
struct ufs1_dinode *curinode;
d331 1
a331 1
	struct ufs1_dinode *dp;
d359 2
a360 1
	printf("inode %d link count now %d\n", curinum, ++curinode->di_nlink);
d369 2
a370 1
	printf("inode %d link count now %d\n", curinum, --curinode->di_nlink);
d626 1
a626 1
	type = curinode->di_mode & IFMT;
d641 2
a642 2
	curinode->di_mode &= ~IFMT;
	curinode->di_mode |= type;
d663 2
a664 2
	curinode->di_mode &= ~07777;
	curinode->di_mode |= modebits;
d685 1
a685 1
	curinode->di_size = len;
d710 1
a710 1
	curinode->di_flags = flags;
d735 1
a735 1
	curinode->di_gen = gen;
d760 1
a760 1
	curinode->di_nlink = lcnt;
d787 1
a787 1
	curinode->di_uid = uid;
d813 1
a813 1
	curinode->di_gid = gid;
d878 3
a880 1
	if (dotime(argv[1], &curinode->di_mtime, &curinode->di_mtimensec))
d882 2
d891 3
a893 1
	if (dotime(argv[1], &curinode->di_atime, &curinode->di_atimensec))
d895 2
d904 3
a906 1
	if (dotime(argv[1], &curinode->di_ctime, &curinode->di_ctimensec))
d908 2
@


1.18
log
@Fix bad indentation that creates the illusion that there's a bug here. tedu@@,
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.17 2003/10/31 08:44:07 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.17 2003/10/31 08:44:07 otto Exp $";
d89 1
a89 1
	fprintf(stderr, "usage: %s [-d] -f <fsname>\n", __progname);
@


1.17
log
@New libedit api changes.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.16 2003/09/26 16:09:27 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.16 2003/09/26 16:09:27 deraadt Exp $";
d460 8
a467 8
		while ((val = strsep(&p, "/")) != NULL && *val == '\0');
			if (val) {
				printf("component `%s': ", val);
				fflush(stdout);
				if (!dolookup(val)) {
					curinode = ginode(curinum);
					return(1);
				}
d469 1
@


1.16
log
@check strdup failure; ok anil millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.15 2003/08/25 23:28:15 tedu Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.15 2003/08/25 23:28:15 tedu Exp $";
d232 1
d239 1
a239 1
	history(hist, H_EVENT, 100);	/* 100 elt history buffer */
d241 1
a241 1
	elptr = el_init(__progname, stdin, stdout);
d251 1
a251 1
		history(hist, H_ENTER, elline);
d262 1
a262 1
			if (el_parse(elptr, cmd_argc, cmd_argv) != -1)
@


1.15
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.14 2003/06/26 08:01:54 tedu Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fsdb.c,v 1.14 2003/06/26 08:01:54 tedu Exp $";
d253 2
@


1.14
log
@const the rcsid, and make it say OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.13 2003/06/11 06:22:13 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d83 1
a83 1
struct dinode *curinode;
d328 1
a328 1
	struct dinode *dp;
@


1.13
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.12 2003/04/17 06:56:04 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: fsdb.c,v 1.4 1996/03/21 17:56:15 jtc Exp $";
@


1.12
log
@strlcpy; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.11 2002/06/09 08:13:06 todd Exp $	*/
d87 1
a87 1
usage()
d100 1
a100 3
main(argc, argv)
	int argc;
	char *argv[];
d122 1
a122 1
	       sblock.fs_fsmnt);
d134 1
a134 3
#define CMDFUNCSTART(func) static int func(argc, argv)		\
				int argc;		\
				char *argv[];
d198 11
a208 13
helpfn(argc, argv)
	int argc;
	char *argv[];
{
    struct cmdtable *cmdtp;

    printf("Commands are:\n%-10s %5s %5s   %s\n",
	   "command", "min argc", "max argc", "what");

    for (cmdtp = cmds; cmdtp->cmd; cmdtp++)
	printf("%-10s %5u %5u   %s\n",
	       cmdtp->cmd, cmdtp->minargc, cmdtp->maxargc, cmdtp->helptxt);
    return 0;
d212 1
a212 2
prompt(el)
	EditLine *el;
d214 4
a217 3
    static char pstring[64];
    snprintf(pstring, sizeof(pstring), "fsdb (inum: %d)> ", curinum);
    return pstring;
d222 1
a222 1
cmdloop()
d224 3
a226 3
    char *line = NULL;
    const char *elline;
    int cmd_argc, rval = 0, known;
d228 62
a289 58
    char **cmd_argv;
    struct cmdtable *cmdp;
    History *hist;
    EditLine *elptr;

    curinode = ginode(ROOTINO);
    curinum = ROOTINO;
    printactive();

    hist = history_init();
    history(hist, H_EVENT, 100);	/* 100 elt history buffer */

    elptr = el_init(__progname, stdin, stdout);
    el_set(elptr, EL_EDITOR, "emacs");
    el_set(elptr, EL_PROMPT, prompt);
    el_set(elptr, EL_HIST, history, hist);
    el_source(elptr, NULL);

    while ((elline = el_gets(elptr, &scratch)) != NULL && scratch != 0) {
	if (debug)
	    printf("command `%s'\n", line);

	history(hist, H_ENTER, elline);

	line = strdup(elline);
	cmd_argv = crack(line, &cmd_argc);
	if (cmd_argc) {
	    /*
	     * el_parse returns -1 to signal that it's not been handled
	     * internally.
	     */
	    if (el_parse(elptr, cmd_argc, cmd_argv) != -1)
		continue;
	    known = 0;
	    for (cmdp = cmds; cmdp->cmd; cmdp++) {
		if (!strcmp(cmdp->cmd, cmd_argv[0])) {
		    if (cmd_argc >= cmdp->minargc &&
			cmd_argc <= cmdp->maxargc)
			rval = (*cmdp->handler)(cmd_argc, cmd_argv);
		    else
			rval = argcount(cmdp, cmd_argc, cmd_argv);
		    known = 1;
		    break;
		}
	    }
	    if (!known)
		warnx("unknown command `%s'", cmd_argv[0]), rval = 1;
	} else
	    rval = 0;
	free(line);
	if (rval < 0)
	    return rval;
	if (rval)
	    warnx("rval was %d", rval);
    }
    el_end(elptr);
    history_end(hist);
    return rval;
d295 5
a299 5
    if (inum < ROOTINO || inum > maxino || cp == argv[ac] || *cp != '\0' ) { \
	printf("inode %d out of range; range is [%d,%d]\n", \
	       inum, ROOTINO, maxino); \
	return 1; \
    }
d306 2
a307 2
    ino_t inum;
    char *cp;
d309 6
a314 6
    GETINUM(1,inum);
    curinode = ginode(inum);
    ocurrent = curinum;
    curinum = inum;
    printactive();
    return 0;
d319 4
a322 4
    curinum = ocurrent;
    curinode = ginode(curinum);
    printactive();
    return 0;
d327 11
a337 11
    ino_t inum;
    struct dinode *dp;
    char *cp;

    GETINUM(1,inum);
    dp = ginode(inum);
    clearinode(dp);
    inodirty();
    if (curinode)			/* re-set after potential change */
	curinode = ginode(curinum);
    return 0;
d342 2
a343 2
    printactive();
    return 0;
d349 1
a349 1
    return -1;
d354 5
a358 5
    if (!checkactive())
	return 1;
    printf("inode %d link count now %d\n", curinum, ++curinode->di_nlink);
    inodirty();
    return 0;
d363 5
a367 5
    if (!checkactive())
	return 1;
    printf("inode %d link count now %d\n", curinum, --curinode->di_nlink);
    inodirty();
    return 0;
d371 15
a385 15
    "unknown",
    "fifo",
    "char special",
    "unregistered #3",
    "directory",
    "unregistered #5",
    "blk special",
    "unregistered #7",
    "regular",
    "unregistered #9",
    "symlink",
    "unregistered #11",
    "socket",
    "unregistered #13",
    "whiteout",
d391 1
a391 2
scannames(idesc)
	struct inodesc *idesc;
d396 2
a397 2
	       slot++, dirp->d_ino, dirp->d_reclen, typename[dirp->d_type],
	       dirp->d_namlen, dirp->d_name);
d403 2
a404 2
    struct inodesc idesc;
    checkactivedir();			/* let it go on anyway */
d406 7
a412 7
    slot = 0;
    idesc.id_number = curinum;
    idesc.id_func = scannames;
    idesc.id_type = DATA;
    idesc.id_fix = IGNORE;
    ckinode(curinode, &idesc);
    curinode = ginode(curinum);
d414 1
a414 1
    return 0;
d418 1
a418 2
dolookup(name)
	char *name;
d420 1
a420 1
    struct inodesc idesc;
d422 16
a437 16
    if (!checkactivedir())
	    return 0;
    idesc.id_number = curinum;
    idesc.id_func = findino;
    idesc.id_name = name;
    idesc.id_type = DATA;
    idesc.id_fix = IGNORE;
    if (ckinode(curinode, &idesc) & FOUND) {
	curinum = idesc.id_parent;
	curinode = ginode(curinum);
	printactive();
	return 1;
    } else {
	warnx("name `%s' not found in current inode directory", name);
	return 0;
    }
d442 1
a442 1
    char *p, *val;
d444 2
a445 2
    if (!checkactive())
	return 1;
d447 1
a447 1
    ocurrent = curinum;
d449 17
a465 16
    if (argv[1][0] == '/') {
	curinum = ROOTINO;
	curinode = ginode(ROOTINO);
    } else {
	if (!checkactivedir())
	    return 1;
    }
    for (p = argv[1]; p != NULL;) {
	while ((val = strsep(&p, "/")) != NULL && *val == '\0');
	if (val) {
	    printf("component `%s': ", val);
	    fflush(stdout);
	    if (!dolookup(val)) {
		curinode = ginode(curinum);
		return(1);
	    }
d467 1
a467 2
    }
    return 0;
d472 15
a486 15
    ino_t inum;
    int rval;
    char *cp;

    GETINUM(1,inum);

    if (!checkactivedir())
	return 1;
    rval = makeentry(curinum, inum, argv[2]);
    if (rval)
	printf("Ino %d entered as `%s'\n", inum, argv[2]);
    else
	printf("could not enter name? weird.\n");
    curinode = ginode(curinum);
    return rval;
d491 1
a491 1
    int rval;
d493 10
a502 10
    if (!checkactivedir())
	return 1;
    rval = changeino(curinum, argv[1], 0);
    if (rval & ALTERED) {
	printf("Name `%s' removed\n", argv[1]);
	return 0;
    } else {
	printf("could not remove name? weird.\n");
	return 1;
    }
d508 1
a508 2
chinumfunc(idesc)
	struct inodesc *idesc;
d521 27
a547 27
    char *cp;
    ino_t inum;
    struct inodesc idesc;

    slotcount = 0;
    if (!checkactivedir())
	return 1;
    GETINUM(2,inum);

    desired = strtol(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' || desired < 0) {
	printf("invalid slot number `%s'\n", argv[1]);
	return 1;
    }

    idesc.id_number = curinum;
    idesc.id_func = chinumfunc;
    idesc.id_fix = IGNORE;
    idesc.id_type = DATA;
    idesc.id_parent = inum;		/* XXX convenient hiding place */

    if (ckinode(curinode, &idesc) & FOUND)
	return 0;
    else {
	warnx("no %sth slot in current directory", argv[1]);
	return 1;
    }
d551 1
a551 2
chnamefunc(idesc)
	struct inodesc *idesc;
d557 8
a564 8
	    /* will name fit? */
	    testdir.d_namlen = strlen(idesc->id_name);
	    if (DIRSIZ(NEWDIRFMT, &testdir) <= dirp->d_reclen) {
		dirp->d_namlen = testdir.d_namlen;
		strlcpy(dirp->d_name, idesc->id_name, sizeof dirp->d_name);
		return STOP|ALTERED|FOUND;
	    } else
		return STOP|FOUND;	/* won't fit, so give up */
d571 30
a600 30
    int rval;
    char *cp;
    struct inodesc idesc;

    slotcount = 0;
    if (!checkactivedir())
	return 1;

    desired = strtoul(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0') {
	printf("invalid slot number `%s'\n", argv[1]);
	return 1;
    }

    idesc.id_number = curinum;
    idesc.id_func = chnamefunc;
    idesc.id_fix = IGNORE;
    idesc.id_type = DATA;
    idesc.id_name = argv[2];

    rval = ckinode(curinode, &idesc);
    if ((rval & (FOUND|ALTERED)) == (FOUND|ALTERED))
	return 0;
    else if (rval & FOUND) {
	warnx("new name `%s' does not fit in slot %s", argv[2], argv[1]);
	return 1;
    } else {
	warnx("no %sth slot in current directory", argv[1]);
	return 1;
    }
d604 2
a605 2
    const char *typename;
    int typebits;
d607 4
a610 4
    {"file", IFREG},
    {"dir", IFDIR},
    {"socket", IFSOCK},
    {"fifo", IFIFO},
d615 2
a616 2
    int type;
    struct typemap *tp;
d618 22
a639 22
    if (!checkactive())
	return 1;
    type = curinode->di_mode & IFMT;
    for (tp = typenamemap;
	 tp < &typenamemap[sizeof(typemap)/sizeof(*typemap)];
	 tp++) {
	if (!strcmp(argv[1], tp->typename)) {
	    printf("setting type to %s\n", tp->typename);
	    type = tp->typebits;
	    break;
	}
    }
    if (tp == &typenamemap[sizeof(typemap)/sizeof(*typemap)]) {
	warnx("type `%s' not known", argv[1]);
	warnx("try one of `file', `dir', `socket', `fifo'");
	return 1;
    }
    curinode->di_mode &= ~IFMT;
    curinode->di_mode |= type;
    inodirty();
    printactive();
    return 0;
d644 18
a661 18
    int rval = 1;
    long modebits;
    char *cp;

    if (!checkactive())
	return 1;

    modebits = strtol(argv[1], &cp, 8);
    if (cp == argv[1] || *cp != '\0' ) {
	warnx("bad modebits `%s'", argv[1]);
	return 1;
    }

    curinode->di_mode &= ~07777;
    curinode->di_mode |= modebits;
    inodirty();
    printactive();
    return rval;
d666 17
a682 17
    int rval = 1;
    long len;
    char *cp;

    if (!checkactive())
	return 1;

    len = strtol(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' || len < 0) {
	warnx("bad length '%s'", argv[1]);
	return 1;
    }

    curinode->di_size = len;
    inodirty();
    printactive();
    return rval;
d687 21
a707 21
    int rval = 1;
    u_long flags;
    char *cp;

    if (!checkactive())
	return 1;

    flags = strtoul(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' ) {
	warnx("bad flags `%s'", argv[1]);
	return 1;
    }

    if (flags > UINT_MAX) {
	warnx("flags set beyond 32-bit range of field (%lx)", flags);
	return(1);
    }
    curinode->di_flags = flags;
    inodirty();
    printactive();
    return rval;
d712 21
a732 21
    int rval = 1;
    long gen;
    char *cp;

    if (!checkactive())
	return 1;

    gen = strtol(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' ) {
	warnx("bad gen `%s'", argv[1]);
	return 1;
    }

    if (gen > INT_MAX || gen < INT_MIN) {
	warnx("gen set beyond 32-bit range of field (%lx)", gen);
	return(1);
    }
    curinode->di_gen = gen;
    inodirty();
    printactive();
    return rval;
d737 21
a757 21
    int rval = 1;
    int lcnt;
    char *cp;

    if (!checkactive())
	return 1;

    lcnt = strtol(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' ) {
	warnx("bad link count `%s'", argv[1]);
	return 1;
    }
    if (lcnt > USHRT_MAX || lcnt < 0) {
	warnx("max link count is %d", USHRT_MAX);
	return 1;
    }

    curinode->di_nlink = lcnt;
    inodirty();
    printactive();
    return rval;
d762 17
a778 16
    int rval = 1;
    uid_t uid;
    char *cp;
    struct passwd *pwd;

    if (!checkactive())
	return 1;

    uid = strtoul(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' ) {
	/* try looking up name */
	if ((pwd = getpwnam(argv[1]))) {
	    uid = pwd->pw_uid;
	} else {
	    warnx("bad uid `%s'", argv[1]);
	    return 1;
a779 1
    }
d781 4
a784 4
    curinode->di_uid = uid;
    inodirty();
    printactive();
    return rval;
d789 16
a804 15
    int rval = 1;
    gid_t gid;
    char *cp;
    struct group *grp;

    if (!checkactive())
	return 1;

    gid = strtoul(argv[1], &cp, 0);
    if (cp == argv[1] || *cp != '\0' ) {
	if ((grp = getgrnam(argv[1]))) {
	    gid = grp->gr_gid;
	} else {
	    warnx("bad gid `%s'", argv[1]);
	    return 1;
a805 1
    }
d807 4
a810 4
    curinode->di_gid = gid;
    inodirty();
    printactive();
    return rval;
d814 19
a832 19
dotime(name, rsec, rnsec)
	char *name;
	int32_t *rsec, *rnsec;
{
    char *p, *val;
    struct tm t;
    int32_t sec;
    int32_t nsec;
    p = strchr(name, '.');
    if (p) {
	*p = '\0';
	nsec = strtoul(++p, &val, 0);
	if (val == p || *val != '\0' || nsec >= 1000000000 || nsec < 0) {
		warnx("invalid nanoseconds");
		goto badformat;
	}
    } else
	nsec = 0;
    if (strlen(name) != 14) {
d834 7
a840 7
	warnx("date format: YYYYMMDDHHMMSS[.nsec]");
	return 1;
    }

    for (p = name; *p; p++)
	if (*p < '0' || *p > '9')
	    goto badformat;
d842 1
a842 1
    p = name;
d844 24
a867 24
    t.tm_year = VAL();
    t.tm_year = VAL() + t.tm_year * 10;
    t.tm_year = VAL() + t.tm_year * 10;
    t.tm_year = VAL() + t.tm_year * 10 - 1900;
    t.tm_mon = VAL();
    t.tm_mon = VAL() + t.tm_mon * 10 - 1;
    t.tm_mday = VAL();
    t.tm_mday = VAL() + t.tm_mday * 10;
    t.tm_hour = VAL();
    t.tm_hour = VAL() + t.tm_hour * 10;
    t.tm_min = VAL();
    t.tm_min = VAL() + t.tm_min * 10;
    t.tm_sec = VAL();
    t.tm_sec = VAL() + t.tm_sec * 10;
    t.tm_isdst = -1;

    sec = mktime(&t);
    if (sec == -1) {
	warnx("date/time out of range");
	return 1;
    }
    *rsec = sec;
    *rnsec = nsec;
    return 0;
d872 5
a876 5
    if (dotime(argv[1], &curinode->di_mtime, &curinode->di_mtimensec))
	return 1;
    inodirty();
    printactive();
    return 0;
d881 5
a885 5
    if (dotime(argv[1], &curinode->di_atime, &curinode->di_atimensec))
	return 1;
    inodirty();
    printactive();
    return 0;
d890 5
a894 5
    if (dotime(argv[1], &curinode->di_ctime, &curinode->di_ctimensec))
	return 1;
    inodirty();
    printactive();
    return 0;
@


1.11
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.10 2002/03/14 06:51:41 mpech Exp $	*/
d567 1
a567 1
		strcpy(dirp->d_name, idesc->id_name);
@


1.10
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.9 2002/02/16 21:27:34 millert Exp $	*/
d86 1
a86 1
static void 
d210 1
a210 1
    
d389 1
a389 1
    
d452 1
a452 1
    
d529 1
a529 1
    
d580 1
a580 1
    
d658 1
a658 1
    if (cp == argv[1] || *cp != '\0' ) { 
d662 1
a662 1
    
d701 1
a701 1
    if (cp == argv[1] || *cp != '\0' ) { 
d705 1
a705 1
    
d726 1
a726 1
    if (cp == argv[1] || *cp != '\0' ) { 
d730 1
a730 1
    
d751 1
a751 1
    if (cp == argv[1] || *cp != '\0' ) { 
d759 1
a759 1
    
d777 1
a777 1
    if (cp == argv[1] || *cp != '\0' ) { 
d786 1
a786 1
    
d804 1
a804 1
    if (cp == argv[1] || *cp != '\0' ) { 
d812 1
a812 1
    
d847 1
a847 1
    
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.8 2001/11/05 07:39:16 mpech Exp $	*/
d601 1
a601 1
	warnx("new name `%s' does not fit in slot %s\n", argv[2], argv[1]);
d707 1
a707 1
	warnx("flags set beyond 32-bit range of field (%lx)\n", flags);
d732 1
a732 1
	warnx("gen set beyond 32-bit range of field (%lx)\n", gen);
d756 1
a756 1
	warnx("max link count is %d\n", USHRT_MAX);
@


1.8
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.7 1999/08/06 20:41:06 deraadt Exp $	*/
d71 10
a80 10
int main __P((int, char *[]));
static void usage __P((void));
static int cmdloop __P((void));
static int helpfn __P((int, char *[]));
static char *prompt __P((EditLine *));
static int scannames __P((struct inodesc *));
static int dolookup __P((char *));
static int chinumfunc __P((struct inodesc *));
static int chnamefunc __P((struct inodesc *));
static int dotime __P((char *, int32_t *, int32_t *));
d135 1
a135 1
#define CMDFUNC(func) static int func __P((int argc, char *argv[]))
@


1.7
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.6 1999/05/19 03:17:15 alex Exp $	*/
d206 1
a206 1
    register struct cmdtable *cmdtp;
d396 1
a396 1
	register struct direct *dirp = idesc->id_dirp;
d515 1
a515 1
	register struct direct *dirp = idesc->id_dirp;
d559 1
a559 1
	register struct direct *dirp = idesc->id_dirp;
@


1.6
log
@Use fprintf/exit in place of errx for usage display.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.5 1998/08/08 20:56:28 deraadt Exp $	*/
d769 1
a769 1
    unsigned long uid;
d796 1
a796 1
    unsigned long gid;
@


1.5
log
@fix atime and mtime commands; ms@@xy.org
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.4 1997/01/16 04:04:19 millert Exp $	*/
d89 2
a90 1
	errx(1, "usage: %s [-d] -f <fsname>", __progname);
@


1.4
log
@Update from NetBSD: adds chlen command and makes -Wall happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsdb.c,v 1.3 1996/04/21 23:46:22 deraadt Exp $	*/
d877 1
a877 1
    if (dotime(argv[1], &curinode->di_ctime, &curinode->di_ctimensec))
d886 1
a886 1
    if (dotime(argv[1], &curinode->di_ctime, &curinode->di_ctimensec))
@


1.3
log
@sync to netbsd 960418
@
text
@d1 2
a2 2
/*	$OpenBSD: fsdb.c,v 1.2 1996/03/21 00:15:46 niklas Exp $	*/
/*	$NetBSD: fsdb.c,v 1.4 1996/03/21 17:56:15 jtc Exp $	*/
d50 1
d67 1
d71 10
a80 2
void usage __P((void));
int cmdloop __P((void));
d82 5
a86 1
void 
a91 2
int returntosingle = 0;

a104 1
	struct stat stb;
d134 2
a135 2
#define CMDFUNC(func) int func __P((int argc, char *argv[]))
#define CMDFUNCSTART(func) int func(argc, argv)		\
d153 1
d165 1
a165 1
struct cmdtable cmds[] = {
d187 1
d200 1
a200 1
int
d216 1
a216 1
char *
d226 1
a226 1
int
d229 1
a229 1
    char *line;
a258 6
	/*
	 * el_parse returns -1 to signal that it's not been handled
	 * internally.
	 */
	if (el_parse(elptr, cmd_argc, cmd_argv) != -1)
	    continue;
d260 6
d293 1
a293 2
struct dinode *curinode;
ino_t curinum, ocurrent;
d371 1
a371 1
const char *typename[] = {
d389 1
a389 1
int slot;
d391 1
a391 1
int
a418 3
int findino __P((struct inodesc *idesc)); /* from fsck */
static int dolookup __P((char *name));

a475 1
    struct dinode *dp;
d508 1
a508 1
long slotcount, desired;
d510 1
a510 1
int
a524 1
    int rval;
d554 1
a554 1
int
a577 1
    ino_t inum;
d608 1
a608 1
struct typemap {
a619 1
    int rval = 1;
d669 21
d778 1
a778 1
	if (pwd = getpwnam(argv[1])) {
d804 1
a804 1
	if (grp = getgrnam(argv[1])) {
d818 1
a818 1
int
@


1.2
log
@From NetBSD: Merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fsdb.c,v 1.3 1996/02/27 22:28:12 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: fsdb.c,v 1.3 1996/02/27 22:28:12 jtc Exp $";
d86 1
a86 1
void
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: fsdb.c,v 1.2 1995/10/08 23:18:10 thorpej Exp $	*/
d4 33
a36 25
/*
 *  Copyright (c) 1995 John T. Kohl
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
d41 1
a41 1
static char rcsid[] = "$NetBSD: fsdb.c,v 1.2 1995/10/08 23:18:10 thorpej Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
