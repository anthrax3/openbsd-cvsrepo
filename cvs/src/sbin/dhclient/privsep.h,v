head	1.55;
access;
symbols
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.22
	OPENBSD_5_0:1.5.0.20
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.18
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.16
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.12
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.14
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.55
date	2017.08.13.17.57.32;	author krw;	state Exp;
branches;
next	1.54;
commitid	oOY5ImcWRP40TSDp;

1.54
date	2017.08.12.16.57.38;	author krw;	state Exp;
branches;
next	1.53;
commitid	jGTi8EOBzAFijRJv;

1.53
date	2017.08.10.17.15.05;	author krw;	state Exp;
branches;
next	1.52;
commitid	jlDoPkMXimQCh050;

1.52
date	2017.08.08.17.54.24;	author krw;	state Exp;
branches;
next	1.51;
commitid	1nTMhlFbQaELsZ7R;

1.51
date	2017.08.05.12.35.17;	author krw;	state Exp;
branches;
next	1.50;
commitid	MiblZ5ktpRO7eVny;

1.50
date	2017.07.30.15.26.46;	author krw;	state Exp;
branches;
next	1.49;
commitid	lr0mi3Mj4EhnFCwr;

1.49
date	2017.07.27.12.45.06;	author krw;	state Exp;
branches;
next	1.48;
commitid	RkpsTm8vUpdi2W1u;

1.48
date	2017.07.24.17.15.41;	author krw;	state Exp;
branches;
next	1.47;
commitid	FSXpMhxAeFtIckUQ;

1.47
date	2017.07.23.13.44.53;	author krw;	state Exp;
branches;
next	1.46;
commitid	Q8jsydlNiyf4AeZW;

1.46
date	2017.07.22.14.56.27;	author krw;	state Exp;
branches;
next	1.45;
commitid	z2BOCyb4irSflclb;

1.45
date	2017.07.21.18.57.55;	author krw;	state Exp;
branches;
next	1.44;
commitid	jKsjPeE2L2H4ksIK;

1.44
date	2017.07.10.14.11.47;	author krw;	state Exp;
branches;
next	1.43;
commitid	zPfpB13LVx1r8eha;

1.43
date	2017.07.08.00.36.10;	author krw;	state Exp;
branches;
next	1.42;
commitid	fG77ONbQ8YTfWdI4;

1.42
date	2017.07.07.15.39.30;	author krw;	state Exp;
branches;
next	1.41;
commitid	mAXBZAHTo5c00SKV;

1.41
date	2017.07.01.23.27.56;	author krw;	state Exp;
branches;
next	1.40;
commitid	UWIW511YvInk5uK6;

1.40
date	2017.06.28.16.31.52;	author krw;	state Exp;
branches;
next	1.39;
commitid	78CHyOkgKoAWELkJ;

1.39
date	2017.06.28.14.35.43;	author krw;	state Exp;
branches;
next	1.38;
commitid	3nygEKTzwCipdpn4;

1.38
date	2017.06.24.23.32.57;	author krw;	state Exp;
branches;
next	1.37;
commitid	kMjmTgmAjjj8SVH3;

1.37
date	2017.06.24.10.09.26;	author krw;	state Exp;
branches;
next	1.36;
commitid	9Mm9vI6emJNtny4z;

1.36
date	2017.06.23.15.40.56;	author krw;	state Exp;
branches;
next	1.35;
commitid	2V1Vp5y5sN8YqgCW;

1.35
date	2017.04.11.13.59.27;	author krw;	state Exp;
branches;
next	1.34;
commitid	zUymlMql24I51JEz;

1.34
date	2017.04.10.21.47.44;	author krw;	state Exp;
branches;
next	1.33;
commitid	ubZF40SEC22PLlgj;

1.33
date	2017.03.08.20.11.00;	author krw;	state Exp;
branches;
next	1.32;
commitid	bjI89TSXtQclq3kl;

1.32
date	2016.09.02.15.44.26;	author mpi;	state Exp;
branches;
next	1.31;
commitid	GuoxNV4NXpbUVBHj;

1.31
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.30;
commitid	Tm7CrlqCKqgQoJ7P;

1.30
date	2016.07.20.19.40.04;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	KBgBSoOXMlfVq81D;

1.29
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.28;
commitid	5ELOU0S0Zl3aCrHG;

1.28
date	2015.02.10.04.20.26;	author krw;	state Exp;
branches;
next	1.27;
commitid	TKehEr2jJpb2ARar;

1.27
date	2015.02.07.10.08.06;	author krw;	state Exp;
branches;
next	1.26;
commitid	DyjrY1dcWE4nZyJh;

1.26
date	2015.02.06.09.16.06;	author reyk;	state Exp;
branches;
next	1.25;
commitid	vYyCsIthQQMdADc1;

1.25
date	2015.02.06.06.47.29;	author krw;	state Exp;
branches;
next	1.24;
commitid	NYRWhJb6ZVSnKVWu;

1.24
date	2015.01.16.06.39.56;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2013.12.10.17.02.35;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.09.22.39.51;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.09.15.06.34;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.16.26.07;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.30.16.10.01;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.11.16.01.01;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.02.20.18.50.29;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2013.02.02.04.18.30;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.27.02.45.46;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.17.23.41.07;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.15.21.44.28;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2012.12.02.17.03.19;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.01.00.13.32;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.29.00.31.57;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.13.21.54.22;	author stevesk;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.07.01.35.11;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.05.16.23.30;	author moritz;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.04.18.51.18;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.04.12.52.05;	author henning;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Simplify HUP handling now that proper error
checks are done on the imsg socket to detect
closure, etc.

Die immediately if the priv process notices
the interface name can't be turned into an
index.
@
text
@/*	$OpenBSD: privsep.h,v 1.54 2017/08/12 16:57:38 krw Exp $ */

/*
 * Copyright (c) 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE, ABUSE OR PERFORMANCE OF THIS SOFTWARE.
 */

enum imsg_code {
	IMSG_NONE,
	IMSG_HUP,
	IMSG_DELETE_ADDRESS,
	IMSG_SET_ADDRESS,
	IMSG_FLUSH_ROUTES,
	IMSG_ADD_ROUTE,
	IMSG_SET_MTU,
	IMSG_SET_RESOLV_CONF,
	IMSG_WRITE_RESOLV_CONF
};

struct imsg_delete_address {
	struct	in_addr addr;
};

struct imsg_set_address {
	struct	in_addr	addr;
	struct	in_addr mask;
};

struct imsg_add_route {
	struct in_addr	dest;
	struct in_addr	netmask;
	struct in_addr	gateway;
	int		flags;
};

struct imsg_set_mtu {
	int	mtu;
};

void	dispatch_imsg(char *, int, int, int, struct imsgbuf *);
int	default_route_index(int, int);

void	priv_add_route(char *, int, int, struct imsg_add_route *);
void	priv_flush_routes(int, int, int);

void	priv_write_resolv_conf(char *);

void	priv_delete_address(char *, int, struct imsg_delete_address *);
void	priv_set_address(char *, int, struct imsg_set_address *);

void	priv_set_mtu(char *, int, struct imsg_set_mtu *);
@


1.54
log
@Stop trying to outfox the routing table
by labelling dhclient routes. Just use
the route(8) logic when flushing routes.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.53 2017/08/10 17:15:05 krw Exp $ */
d51 1
a51 1
int	dispatch_imsg(char *, int, int, int, struct imsgbuf *);
@


1.53
log
@Add IMSG_SET_RESOLV_CONF and keep the cached contents
in the priv process, so that they do not have to be
continually retransmitted. IMSG_WRITE_RESOLV_CONF
now just triggers a write of the cached info.

Simplifies a bunch of logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.52 2017/08/08 17:54:24 krw Exp $ */
d55 1
a55 1
void	priv_flush_routes(char *, int, int);
@


1.52
log
@Rename resolv_conf_priority() to default_route_index() to
reflect what it does.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.51 2017/08/05 12:35:17 krw Exp $ */
d27 1
d57 1
a57 3
char	*resolv_conf_contents(char *, uint8_t *, unsigned int, uint8_t *,
    unsigned int);
void	priv_write_resolv_conf(uint8_t *, size_t);
@


1.51
log
@Bring route creation into line with what route(8) does. In
particular stop providing RFA_IFA, and instead supply the
relevant interface index in the RTM_ADD message.

Various code simplifications as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.50 2017/07/30 15:26:46 krw Exp $ */
d51 1
a57 1
int	resolv_conf_priority(int, int);
@


1.50
log
@Use effective_proposal data to build resolv.conf contents.

Fix a missing != NULL, and add a comment on why no search
path and no dns servers means resolv.conf.tail is ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.49 2017/07/27 12:45:06 krw Exp $ */
a42 2
	struct in_addr	ifa;
	int		addrs;
d52 1
a52 1
void	priv_add_route(int, int, struct imsg_add_route *);
@


1.49
log
@Fold add_direct_route(), add_default_route() and
add_classless_static_routes() into set_routes(). One
less layer of abstraction and all five add_route()
invocations now in one place.

Clearly comment the route(8) command equivalents for each
add_route() invocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.48 2017/07/24 17:15:41 krw Exp $ */
d57 2
a58 2
char	*resolv_conf_contents(char *, struct option_data *,
    struct option_data *, struct option_data *);
@


1.48
log
@Shuffle some declarations and functions into the only
files they are used in. Tweak a bunch of whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.47 2017/07/23 13:44:53 krw Exp $ */
a53 3
void	add_direct_route(struct in_addr, struct in_addr, struct in_addr);
void	add_default_route(struct in_addr, struct in_addr);
void	add_classless_static_routes(struct option_data *, struct in_addr);
@


1.47
log
@Cease pretending to support option 33 (classFULL static routes). They
are dead to the internet. And the current code actually creates /32
routes since kernel magic for classfull routes died a while ago.

ok phessler@@ claudio@@ reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.46 2017/07/22 14:56:27 krw Exp $ */
d62 1
a62 1
void	write_resolv_conf(uint8_t *, size_t);
@


1.46
log
@Rename *_add_address to *_set_address to reflect that the
lease address replaces all current addresses. Shuffle some
code from bind_lease() into set_mtu()/set_address() to
shrink  bind_lease().
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.45 2017/07/21 18:57:55 krw Exp $ */
a55 1
void	add_static_routes(struct option_data *, struct in_addr);
@


1.45
log
@s/set_interface_mtu/set_mtu/g
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.44 2017/07/10 14:11:47 krw Exp $ */
d23 1
a23 1
	IMSG_ADD_ADDRESS,
d34 1
a34 1
struct imsg_add_address {
d67 1
a67 1
void	priv_add_address(char *, int, struct imsg_add_address *);
@


1.44
log
@Use ioctlfd/routefd sockets rather than rolling one's own
for resolving 'egress' and adding a route. Move creation
of main()'s ioctlfd up so it can be used for the
'egress' resolution.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.43 2017/07/08 00:36:10 krw Exp $ */
d26 1
a26 1
	IMSG_SET_INTERFACE_MTU,
d48 1
a48 1
struct imsg_set_interface_mtu {
d69 1
a69 1
void	priv_set_interface_mtu(char *, int, struct imsg_set_interface_mtu *);
@


1.43
log
@Always use uintNN_t instead of sometimes u_intNN_t
and sometimes uintNN_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.42 2017/07/07 15:39:30 krw Exp $ */
d58 1
a58 1
void	priv_add_route(int, struct imsg_add_route *);
@


1.42
log
@dispatch_imsg() only needs to know name and rdomain.

No more struct interface_info knowledge in privsep.[ch]
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.41 2017/07/01 23:27:56 krw Exp $ */
d63 2
a64 2
void	write_resolv_conf(u_int8_t *, size_t);
void	priv_write_resolv_conf(u_int8_t *, size_t);
@


1.41
log
@Eliminate multiple socket openings/closings and pass
fd'd from main loops as required. One socket to do
ioctl's per process (called ioctlfd) and one socket to
do route messages per socket (called routefd).

Clean up local variable declaration lists in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.40 2017/06/28 16:31:52 krw Exp $ */
d52 1
a52 1
int	dispatch_imsg(struct interface_info *, int, int, struct imsgbuf *);
@


1.40
log
@Only pass required fields of interface_info to priv_* functions
and friends. i.e. ifi->name, ifi->rdomain, or both.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.39 2017/06/28 14:35:43 krw Exp $ */
d52 1
a52 1
int	dispatch_imsg(struct interface_info *, struct imsgbuf *);
d59 1
a59 1
void	priv_flush_routes(char *, int);
d64 1
a64 1
void	priv_write_resolv_conf(int, u_int8_t *, size_t);
d66 2
a67 2
void	priv_delete_address(char *, struct imsg_delete_address *);
void	priv_add_address(char *, struct imsg_add_address *);
d69 1
a69 1
void	priv_set_interface_mtu(char *, struct imsg_set_interface_mtu *);
@


1.39
log
@Stop trying to clean up addresses, routes and "-L" file
whenever dhclient dies. Eliminates differences in handling
and thus need to intercept signals INT, TERM, USR1,
USR2. Eliminates need for 'zapzombies' field and thus
entire struct imsg_flushroutes. Eliminates need for 'imsg'
parameter to and associated logic in priv_flush_routes().

Address, routes and '-L' file are still cleaned out when
binding a lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.38 2017/06/24 23:32:57 krw Exp $ */
d58 2
a59 2
void	priv_add_route(struct interface_info *, struct imsg_add_route *);
void	priv_flush_routes(struct interface_info *);
d61 2
a62 2
char	*resolv_conf_contents(struct interface_info *ifi, struct option_data *,
	    struct option_data *, struct option_data *);
d64 1
a64 1
void	priv_write_resolv_conf(struct interface_info *, u_int8_t *, size_t);
d66 2
a67 3
void	priv_delete_address(struct interface_info *,
	    struct imsg_delete_address *);
void	priv_add_address(struct interface_info *, struct imsg_add_address *);
d69 1
a69 2
void	priv_set_interface_mtu(struct interface_info *,
	    struct imsg_set_interface_mtu *);
@


1.38
log
@Tweak handling of HUP and new LLADDR. Just use expose and use sighup()
function. Don't exit dispatch() loop on SIGHUP, wait for privileged
child to execvp() dhclient. Eliminate struct imsg_hup since its
contents were not being used except in priv_cleanup(). And
'active_addr' works just as well there.

Cleaner and eliminates some extraneous log entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.37 2017/06/24 10:09:26 krw Exp $ */
a38 4
struct imsg_flush_routes {
	int	zapzombies;
};

d59 1
a59 1
void	priv_flush_routes(struct interface_info *, struct imsg_flush_routes *);
a71 2

void	priv_cleanup(struct interface_info *);
@


1.37
log
@Use a local variable rather than a global flag to record
the reception of a IMSG_HUP message and trigger the
desired restart.

Nuke the now pointless IFI_HUP.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.36 2017/06/23 15:40:56 krw Exp $ */
a29 4
struct imsg_hup {
	struct	in_addr addr;
};

d77 1
a77 1
void	priv_cleanup(struct interface_info *, struct imsg_hup *);
@


1.36
log
@Take reyk's imsg resolv.conf improvements of a while ago to their
logical conclusion.

Nuke _PATH_RESOLV_CONF since the value is only meant to be
known inside priv_write_resolv_conf(). Just use a local const char *.

Bring priv_write_resolv_conf() into line with other priv_ functions
invoked from the dispatch loop. i.e. don't pass it the imsg, just pass
a pointer to the data and a size after ensuring there is data to pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.35 2017/04/11 13:59:27 krw Exp $ */
d60 1
a60 1
void	dispatch_imsg(struct interface_info *, struct imsgbuf *);
@


1.35
log
@Shuffle route/interface changing functions together into kroute.c. Try to
group related functions in kroute.c together and comment them a bit.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.34 2017/04/10 21:47:44 krw Exp $ */
d72 1
a72 1
void	priv_write_resolv_conf(struct interface_info *, struct imsg *);
@


1.34
log
@Rework -L logic to use the idiom used in handling the leases file.
i.e. open FILE during program set up and use the FILE created for
the rest of the program lifetime after dropping privilege and
pledge()'ing. No need for passing messages to the priv process.

Tweak lease file handling a bit in passing.

Monitoring the -L file with external programs like sysutils/entr
still works.

Looks good to sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.33 2017/03/08 20:11:00 krw Exp $ */
d61 13
a73 2
void	priv_write_file(char *, int, mode_t, u_int8_t *, size_t);
void	priv_cleanup(struct interface_info *, struct imsg_hup *);
d77 1
a77 2
void	priv_flush_routes(struct interface_info *, struct imsg_flush_routes *);
void	priv_add_route(struct interface_info *, struct imsg_add_route *);
d80 2
a81 1
void	priv_write_resolv_conf(struct interface_info *, struct imsg *);
@


1.33
log
@Shuffle, shuffle, shuffle.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.32 2016/09/02 15:44:26 mpi Exp $ */
a21 1
	IMSG_WRITE_OPTION_DB,
a60 1
void	priv_write_option_db(struct imsg *);
@


1.32
log
@Kill 'ifi' global.

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.31 2016/08/23 09:26:02 mpi Exp $ */
d21 2
d28 5
a32 3
	IMSG_HUP,
	IMSG_WRITE_RESOLV_CONF,
	IMSG_WRITE_OPTION_DB
a60 4
struct imsg_hup {
	struct	in_addr addr;
};

d62 3
a69 1
void	priv_cleanup(struct interface_info *, struct imsg_hup *);
a72 2
void	priv_write_option_db(struct imsg *);
void	priv_write_file(char *, int, mode_t, u_int8_t *, size_t);
@


1.31
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.30 2016/07/20 19:40:04 deraadt Exp $ */
d70 1
a70 1
void	priv_write_resolv_conf(struct imsg *);
@


1.30
log
@Shrink priv_write_file() API so that it does less, and the callers ask
it to do less.  Discussion with guenther.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.29 2016/02/06 19:30:52 krw Exp $ */
d61 9
a69 7
void	dispatch_imsg(struct imsgbuf *);
void	priv_delete_address(struct imsg_delete_address *);
void	priv_add_address(struct imsg_add_address *);
void	priv_flush_routes(struct imsg_flush_routes *);
void	priv_add_route(struct imsg_add_route *);
void	priv_cleanup(struct imsg_hup *);
void	priv_set_interface_mtu(struct imsg_set_interface_mtu *);
@


1.29
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.28 2015/02/10 04:20:26 krw Exp $ */
d70 1
a70 1
void	priv_write_file(char *, int, mode_t, uid_t, gid_t, u_int8_t *, size_t);
@


1.28
log
@Groundwork for better route support over multiple interfaces by
using RTM_IFA to bind routes to an interface. Keep the subnet route
conflict avoidance code for the time being.

diff from claudio@@ as part of larger routing magic diff.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.27 2015/02/07 10:08:06 krw Exp $ */
a17 4

#include <arpa/inet.h>

#include <imsg.h>
@


1.27
log
@Add support for interface-mtu (option 26).

Original request+diff from matthew@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.26 2015/02/06 09:16:06 reyk Exp $ */
d52 1
@


1.26
log
@The write_file() privsep interface was too permissive and
theoretically allowed the unprivileged child process to write to
arbitrary files.  Restrict it by replacing it with two specific
write_resolv_conf() and write_option_db() privsep interfaces where all
the critical decision has been moved to the parent.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.25 2015/02/06 06:47:29 krw Exp $ */
d29 1
d56 4
d70 1
@


1.25
log
@matthew@@ points out that it's a bad idea to rely on the non-privileged,
network-facing process to properly fill out the interface name and
rdomain on which operations are to be performed.

Instead, always use the interface name and rdomain discovered before
forking and dropping privs. Lets all the imsg structs to drop a
couple of members.

ok matthew@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.24 2015/01/16 06:39:56 deraadt Exp $ */
d30 2
a31 1
	IMSG_WRITE_FILE
a58 9
struct imsg_write_file {
	char	path[PATH_MAX];
	int	flags;
	mode_t	mode;
	size_t	len;
	uid_t	uid;
	gid_t	gid;
};

d65 3
a67 1
void	priv_write_file(struct imsg_write_file *);
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.23 2013/12/10 17:02:35 krw Exp $ */
a33 2
	char	ifname[IFNAMSIZ];
	int	rdomain;
a37 2
	char	ifname[IFNAMSIZ];
	int	rdomain;
a42 2
	char	ifname[IFNAMSIZ];
	int	rdomain;
a49 1
	int		rdomain;
a54 2
	char	ifname[IFNAMSIZ];
	int	rdomain;
a59 1
	int	rdomain;
@


1.23
log
@Oops. Missed file.

Rework [priv_]write_file() and associated struct imsg_write_file
to use imsg_composev() rather than allocating memory, copying data
into it, and then passing it to imsg_compose() to copy data again
into imsg buffer.

ok pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.22 2013/06/09 22:39:51 krw Exp $ */
d68 1
a68 1
	char	path[MAXPATHLEN];
@


1.22
log
@Make route adding interface more flexible by passing flags to be
used rather than deducing them. Use priv_add_route() to add
the 127.0.0.1 address when adding an address.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.21 2013/06/09 15:06:34 krw Exp $ */
a74 1
	char	contents[1];
@


1.21
log
@Re-apply route adding code refactoring -- it wasn't the problem that
broke populating the egress group.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.20 2013/06/09 00:30:06 krw Exp $ */
d58 1
@


1.20
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.19 2013/06/01 16:26:07 krw Exp $ */
d28 1
a28 1
	IMSG_ADD_DEFAULT_ROUTE,
d52 4
a55 1
struct imsg_add_default_route {
d57 1
a57 2
	struct in_addr	addr;
	struct in_addr	gateway;
d81 1
a81 1
void	priv_add_default_route(struct imsg_add_default_route *);
@


1.19
log
@Refactor the default route adding code to use a general route adding
function that will be reused for future work.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.18 2013/03/30 16:10:01 krw Exp $ */
d28 1
a28 1
	IMSG_ADD_ROUTE,
d52 3
a54 3
struct imsg_add_route {
	struct in_addr	dest;
	struct in_addr	netmask;
a55 2
	int		rdomain;
	int		addrs;
d79 1
a79 1
void	priv_add_route(struct imsg_add_route *);
@


1.18
log
@Since deleting all the addresses on an interface removes all the
relevant entries from the arp cache, don't bother asking for/processing
arp entries in the route dumps. Thus allowing use of NET_RT_FLAGS
with RTF_GATEWAY and AF_INET, to ask for only the routes dhclient
wants to expunge rather than all routes in existance.

Greatly shrinks and simplifies the code. No intentional functional
change. Tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.17 2013/03/11 16:01:01 krw Exp $ */
d28 1
a28 1
	IMSG_ADD_DEFAULT_ROUTE,
d52 4
a55 1
struct imsg_add_default_route {
d57 1
a57 2
	struct in_addr	addr;
	struct in_addr	gateway;
d81 1
a81 1
void	priv_add_default_route(struct imsg_add_default_route *);
@


1.17
log
@When binding a lease, check for and clear out any 'zombie' routes
left behind by dead dhclients. i.e. dhclients that no longer respond
to 'kill(pid, 0)'.

As a result, no need to handle the 127.0.0.1 route separately when
deleting an interface.

Appears to fix in passing a problem with routes vs link addresses
that sthen@@ was seeing.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.16 2013/02/20 18:50:29 krw Exp $ */
d78 1
a78 1
void	priv_flush_routes_and_arp_cache(struct imsg_flush_routes *);
@


1.16
log
@Nuke unused imsg_resolv_conf struct and declaration for non-existant function priv_resolv_conf().
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.15 2013/02/18 15:57:08 krw Exp $ */
d49 1
@


1.15
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.14 2013/02/02 04:18:30 krw Exp $ */
a56 5
struct imsg_resolv_conf {
	size_t	len;
	char	contents[1];
};

a74 1
void	priv_resolv_conf(struct imsg_resolv_conf *);
@


1.14
log
@Fix resolv.conf magic. Add identifying comment to generated resolv.conf
so it is easy to see which interface generated it.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.13 2013/01/27 02:45:46 krw Exp $ */
d29 1
a29 1
	IMSG_CLEANUP,
d62 1
a62 1
struct imsg_cleanup {
d85 1
a85 1
void	priv_cleanup(struct imsg_cleanup *);
@


1.13
log
@Refactor code a bit. Calculate resolv.conf contents once when binding a
lease and reuse as required whenever resolv.conf is written. Use
write_file() rather than a custom message/functions to write out
resolv.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.12 2013/01/17 23:41:07 krw Exp $ */
d70 1
@


1.12
log
@Try harder to clear out default routes on the interface being
configured. Only exempt default routes labelled as being the
property of another dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.11 2013/01/15 21:44:28 krw Exp $ */
a22 2
#define MAXRESOLVCONFSIZE	2048

a28 1
	IMSG_NEW_RESOLV_CONF,
d58 2
a59 1
	char	contents[MAXRESOLVCONFSIZE];
@


1.11
log
@Add IMSG_WRITE_FILE and associated bits to allow the unprivileged
process to ask that a file be written by the privileged process.

Not yet used.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.10 2012/12/02 17:03:19 krw Exp $ */
d50 1
@


1.10
log
@Try harder to cleanup when exiting. In particular catch signals
SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUS2 and cleanup before exiting
when getting them. Cleanup meaning removing routes and the interface
address added.

Tweaks and feedback from phessler@@, sthen@@, otto@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.9 2012/12/01 00:13:32 krw Exp $ */
d32 2
a33 1
	IMSG_CLEANUP
d69 10
d86 1
@


1.9
log
@A couple of whitespace nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.8 2012/11/29 00:31:57 krw Exp $ */
d31 2
a32 1
	IMSG_NEW_RESOLV_CONF
d62 6
d74 1
@


1.8
log
@Nuke unused 'extern' declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.7 2012/11/23 15:25:47 krw Exp $ */
d37 1
a37 1
	struct in_addr addr;
d41 1
a41 1
	char 	ifname[IFNAMSIZ];
@


1.7
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.6 2012/10/30 18:39:44 krw Exp $ */
a23 2

extern struct imsgbuf *ibuf;
@


1.6
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.5 2007/02/13 21:54:22 stevesk Exp $ */
d19 1
a19 1
#include <sys/types.h>
d21 5
a25 6
struct buf {
	u_char			*buf;
	size_t			 size;
	size_t			 wpos;
	size_t			 rpos;
};
d36 25
a60 3
struct imsg_hdr {
	enum imsg_code	code;
	size_t		len;
d63 6
a68 5
struct buf	*buf_open(size_t);
void		 buf_add(struct buf *, void *, size_t);
void		 buf_close(int, struct buf *);
void		 buf_read(int, void *, size_t);
void		 dispatch_imsg(int);
@


1.5
log
@move includes only needed in dhclient.c; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.4 2005/08/07 01:35:11 krw Exp $ */
d30 5
a34 4
	IMSG_SCRIPT_INIT,
	IMSG_SCRIPT_WRITE_PARAMS,
	IMSG_SCRIPT_GO,
	IMSG_SCRIPT_GO_RET
@


1.4
log
@Simplify code by calling error() from inside buf_* functions rather
than always testing the return code and calling error() from the
caller.

From a diff by moritz@@, ok henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.3 2005/08/05 16:23:30 moritz Exp $ */
a19 3

#include <poll.h>
#include <pwd.h>
@


1.3
log
@remove duplicate privsep prototypes and put all
of them into privsep.h. ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.h,v 1.2 2004/05/04 18:51:18 henning Exp $ */
d45 3
a47 3
int		 buf_add(struct buf *, void *, size_t);
int		 buf_close(int, struct buf *);
ssize_t		 buf_read(int, void *, size_t);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d47 2
a48 1
ssize_t		 buf_read(int sock, void *, size_t);
@


1.1
log
@privilege seperate dhclient.
the privileged child's duty is the dhclient-script env setup & exection.
the parent process now chroots to /var/empty and drops privileges to _dhcp
mostly hacked at vancouver airport
with some feedback from krw@@ and otto@@, tested to not break installs by krw@@
@
text
@d1 2
@

