head	1.487;
access;
symbols
	OPENBSD_6_1:1.405.0.4
	OPENBSD_6_1_BASE:1.405
	OPENBSD_6_0:1.379.0.2
	OPENBSD_6_0_BASE:1.379
	OPENBSD_5_9:1.372.0.2
	OPENBSD_5_9_BASE:1.372
	OPENBSD_5_8:1.361.0.4
	OPENBSD_5_8_BASE:1.361
	OPENBSD_5_7:1.359.0.2
	OPENBSD_5_7_BASE:1.359
	OPENBSD_5_6:1.318.0.4
	OPENBSD_5_6_BASE:1.318
	OPENBSD_5_5:1.293.0.4
	OPENBSD_5_5_BASE:1.293
	OPENBSD_5_4:1.260.0.2
	OPENBSD_5_4_BASE:1.260
	OPENBSD_5_3:1.240.0.2
	OPENBSD_5_3_BASE:1.240
	OPENBSD_5_2:1.146.0.4
	OPENBSD_5_2_BASE:1.146
	OPENBSD_5_1_BASE:1.142
	OPENBSD_5_1:1.142.0.2
	OPENBSD_5_0:1.141.0.2
	OPENBSD_5_0_BASE:1.141
	OPENBSD_4_9:1.137.0.2
	OPENBSD_4_9_BASE:1.137
	OPENBSD_4_8:1.135.0.2
	OPENBSD_4_8_BASE:1.135
	OPENBSD_4_7:1.132.0.2
	OPENBSD_4_7_BASE:1.132
	OPENBSD_4_6:1.130.0.4
	OPENBSD_4_6_BASE:1.130
	OPENBSD_4_5:1.123.0.2
	OPENBSD_4_5_BASE:1.123
	OPENBSD_4_4:1.120.0.2
	OPENBSD_4_4_BASE:1.120
	OPENBSD_4_3:1.116.0.2
	OPENBSD_4_3_BASE:1.116
	OPENBSD_4_2:1.114.0.2
	OPENBSD_4_2_BASE:1.114
	OPENBSD_4_1:1.111.0.2
	OPENBSD_4_1_BASE:1.111
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.81.0.2
	OPENBSD_3_9_BASE:1.81
	OPENBSD_3_8:1.80.0.2
	OPENBSD_3_8_BASE:1.80
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.58.0.2
	OPENBSD_3_6_BASE:1.58
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31;
locks; strict;
comment	@ * @;


1.487
date	2017.07.29.15.07.47;	author krw;	state Exp;
branches;
next	1.486;
commitid	fs7wm6LApZTZyE2c;

1.486
date	2017.07.26.18.16.21;	author jca;	state Exp;
branches;
next	1.485;
commitid	WjRD21zXq3UaT6Ny;

1.485
date	2017.07.26.16.53.22;	author krw;	state Exp;
branches;
next	1.484;
commitid	VUWLiQ8takqTvzwp;

1.484
date	2017.07.26.14.11.25;	author krw;	state Exp;
branches;
next	1.483;
commitid	NuV2ULTPEdxKeEBb;

1.483
date	2017.07.24.18.13.19;	author krw;	state Exp;
branches;
next	1.482;
commitid	xjcyncKfDSt3Q91S;

1.482
date	2017.07.24.17.15.41;	author krw;	state Exp;
branches;
next	1.481;
commitid	FSXpMhxAeFtIckUQ;

1.481
date	2017.07.24.16.17.35;	author krw;	state Exp;
branches;
next	1.480;
commitid	nGCLYHNGfubVs4Qc;

1.480
date	2017.07.24.13.51.43;	author krw;	state Exp;
branches;
next	1.479;
commitid	jsqXn4fMPFV7qq60;

1.479
date	2017.07.24.13.16.06;	author krw;	state Exp;
branches;
next	1.478;
commitid	lUzbtUr3ZWUbhveI;

1.478
date	2017.07.22.17.55.20;	author krw;	state Exp;
branches;
next	1.477;
commitid	1O4BY8IJfs1mMEfs;

1.477
date	2017.07.22.15.34.22;	author krw;	state Exp;
branches;
next	1.476;
commitid	pLF1Zo1VrQd9aeuG;

1.476
date	2017.07.22.15.28.56;	author krw;	state Exp;
branches;
next	1.475;
commitid	d9ZaDg57s3GaE6I0;

1.475
date	2017.07.22.14.56.27;	author krw;	state Exp;
branches;
next	1.474;
commitid	z2BOCyb4irSflclb;

1.474
date	2017.07.21.18.57.55;	author krw;	state Exp;
branches;
next	1.473;
commitid	jKsjPeE2L2H4ksIK;

1.473
date	2017.07.21.18.43.05;	author krw;	state Exp;
branches;
next	1.472;
commitid	bNtSuevCsdMrP8to;

1.472
date	2017.07.20.17.44.13;	author krw;	state Exp;
branches;
next	1.471;
commitid	o43uKtQF1MtIj84J;

1.471
date	2017.07.17.16.13.13;	author krw;	state Exp;
branches;
next	1.470;
commitid	hcl5Wo2fyRrTrfDS;

1.470
date	2017.07.17.15.05.03;	author krw;	state Exp;
branches;
next	1.469;
commitid	71kVBKSsGPwJWydJ;

1.469
date	2017.07.14.16.21.03;	author krw;	state Exp;
branches;
next	1.468;
commitid	MneUE6JB4herdkKT;

1.468
date	2017.07.14.14.03.15;	author krw;	state Exp;
branches;
next	1.467;
commitid	tlFMQdvTkGuWS3BL;

1.467
date	2017.07.14.13.47.09;	author krw;	state Exp;
branches;
next	1.466;
commitid	Y4nJn3XgUlUAAC5d;

1.466
date	2017.07.10.17.13.24;	author krw;	state Exp;
branches;
next	1.465;
commitid	kBYEloYpDyLW1Mqg;

1.465
date	2017.07.10.14.11.47;	author krw;	state Exp;
branches;
next	1.464;
commitid	zPfpB13LVx1r8eha;

1.464
date	2017.07.10.00.47.47;	author krw;	state Exp;
branches;
next	1.463;
commitid	NbrwpC5tx5StmvcS;

1.463
date	2017.07.09.19.19.58;	author krw;	state Exp;
branches;
next	1.462;
commitid	0BGOuT2HbB9sCm2t;

1.462
date	2017.07.09.12.38.47;	author krw;	state Exp;
branches;
next	1.461;
commitid	VZSWvnhCdpuBNPDo;

1.461
date	2017.07.08.20.38.31;	author krw;	state Exp;
branches;
next	1.460;
commitid	kyvbR5ak3LYhr95l;

1.460
date	2017.07.08.00.36.10;	author krw;	state Exp;
branches;
next	1.459;
commitid	fG77ONbQ8YTfWdI4;

1.459
date	2017.07.07.16.58.45;	author krw;	state Exp;
branches;
next	1.458;
commitid	SZpYrtXCWLHh9BMf;

1.458
date	2017.07.07.15.39.30;	author krw;	state Exp;
branches;
next	1.457;
commitid	mAXBZAHTo5c00SKV;

1.457
date	2017.07.07.14.53.06;	author krw;	state Exp;
branches;
next	1.456;
commitid	9W4HKbFTwzuS5o2J;

1.456
date	2017.07.06.16.56.52;	author krw;	state Exp;
branches;
next	1.455;
commitid	gkJDzWHD0LTQO3CJ;

1.455
date	2017.07.05.16.17.42;	author krw;	state Exp;
branches;
next	1.454;
commitid	Qknwt3FrsPLqVGpA;

1.454
date	2017.07.01.23.27.55;	author krw;	state Exp;
branches;
next	1.453;
commitid	UWIW511YvInk5uK6;

1.453
date	2017.06.29.13.55.53;	author krw;	state Exp;
branches;
next	1.452;
commitid	slBDG7uu1EsDqTzi;

1.452
date	2017.06.28.16.31.52;	author krw;	state Exp;
branches;
next	1.451;
commitid	78CHyOkgKoAWELkJ;

1.451
date	2017.06.28.14.35.43;	author krw;	state Exp;
branches;
next	1.450;
commitid	3nygEKTzwCipdpn4;

1.450
date	2017.06.28.12.53.46;	author krw;	state Exp;
branches;
next	1.449;
commitid	45BzeMuwQrzKMF8o;

1.449
date	2017.06.27.13.24.49;	author krw;	state Exp;
branches;
next	1.448;
commitid	ZE4BYkFcC5NFyvgl;

1.448
date	2017.06.25.00.38.38;	author krw;	state Exp;
branches;
next	1.447;
commitid	9RMKcCZgFmzmMKFD;

1.447
date	2017.06.24.23.32.57;	author krw;	state Exp;
branches;
next	1.446;
commitid	kMjmTgmAjjj8SVH3;

1.446
date	2017.06.24.10.09.26;	author krw;	state Exp;
branches;
next	1.445;
commitid	9Mm9vI6emJNtny4z;

1.445
date	2017.06.23.19.51.07;	author krw;	state Exp;
branches;
next	1.444;
commitid	xaNvyZNFGHmJ8rY0;

1.444
date	2017.06.23.16.09.38;	author krw;	state Exp;
branches;
next	1.443;
commitid	d4dfTAw5JtOJIZaD;

1.443
date	2017.06.21.16.39.05;	author krw;	state Exp;
branches;
next	1.442;
commitid	O5inDDrI9gxajcs8;

1.442
date	2017.06.21.15.49.27;	author krw;	state Exp;
branches;
next	1.441;
commitid	SGFZso8o5MopkevR;

1.441
date	2017.06.21.15.24.34;	author krw;	state Exp;
branches;
next	1.440;
commitid	7HePkhlUwc4gu0vl;

1.440
date	2017.06.21.12.37.24;	author krw;	state Exp;
branches;
next	1.439;
commitid	uwCc9nEeaGRYvLCU;

1.439
date	2017.06.19.19.28.35;	author krw;	state Exp;
branches;
next	1.438;
commitid	ueq2M4294OXNv6H1;

1.438
date	2017.06.19.01.09.09;	author krw;	state Exp;
branches;
next	1.437;
commitid	WAeYy2MH7nbwQR0L;

1.437
date	2017.06.18.21.08.15;	author krw;	state Exp;
branches;
next	1.436;
commitid	03NUXBjegTBXfm4K;

1.436
date	2017.06.18.17.01.46;	author krw;	state Exp;
branches;
next	1.435;
commitid	0RASdOJOvRipKjqj;

1.435
date	2017.06.18.16.37.19;	author krw;	state Exp;
branches;
next	1.434;
commitid	Qe5NDyTMpXQZWUrC;

1.434
date	2017.06.18.14.54.19;	author krw;	state Exp;
branches;
next	1.433;
commitid	sB4Y9mqK6mIBMfZD;

1.433
date	2017.06.18.11.26.14;	author krw;	state Exp;
branches;
next	1.432;
commitid	9xDkhhxMd2h4Syn2;

1.432
date	2017.06.17.20.23.17;	author krw;	state Exp;
branches;
next	1.431;
commitid	VBK0laFiJ3DaJaMY;

1.431
date	2017.06.17.17.10.26;	author krw;	state Exp;
branches;
next	1.430;
commitid	2SwVocUJ4PTaQdIe;

1.430
date	2017.06.17.16.58.55;	author krw;	state Exp;
branches;
next	1.429;
commitid	l7JlcHqNJUIfaJjc;

1.429
date	2017.06.17.15.53.03;	author krw;	state Exp;
branches;
next	1.428;
commitid	S5as0pLhDvUkyD87;

1.428
date	2017.06.16.14.12.12;	author krw;	state Exp;
branches;
next	1.427;
commitid	sjpyGq49Fw7RSSLS;

1.427
date	2017.06.15.17.06.17;	author krw;	state Exp;
branches;
next	1.426;
commitid	3Bd8xw2tLnMI6fM7;

1.426
date	2017.06.15.16.56.11;	author krw;	state Exp;
branches;
next	1.425;
commitid	GBIJ2rz4qiEuOud5;

1.425
date	2017.06.14.20.27.08;	author krw;	state Exp;
branches;
next	1.424;
commitid	Do2Wb0ASjzojBK6g;

1.424
date	2017.06.14.16.52.35;	author krw;	state Exp;
branches;
next	1.423;
commitid	qdJehrUm6vQEMjRB;

1.423
date	2017.06.14.16.29.58;	author krw;	state Exp;
branches;
next	1.422;
commitid	tsqEu09O9dSQSutt;

1.422
date	2017.06.14.16.09.42;	author krw;	state Exp;
branches;
next	1.421;
commitid	d5OX3PwMWtaAMnZV;

1.421
date	2017.06.14.15.57.25;	author krw;	state Exp;
branches;
next	1.420;
commitid	xleVcb5KQcOBndeE;

1.420
date	2017.06.14.15.39.55;	author krw;	state Exp;
branches;
next	1.419;
commitid	leRXJH8PurJqMWtQ;

1.419
date	2017.06.13.15.49.32;	author krw;	state Exp;
branches;
next	1.418;
commitid	OYT2CturRpIwAbZo;

1.418
date	2017.05.26.14.57.41;	author krw;	state Exp;
branches;
next	1.417;
commitid	LtnIfwk19YWgSOjU;

1.417
date	2017.05.26.14.35.49;	author krw;	state Exp;
branches;
next	1.416;
commitid	6Ljt53Z15NCqgjcm;

1.416
date	2017.05.26.14.25.14;	author krw;	state Exp;
branches;
next	1.415;
commitid	OPNE72stB5hPQGWU;

1.415
date	2017.04.12.14.08.15;	author krw;	state Exp;
branches;
next	1.414;
commitid	6ffV2PYFDbjlnmUZ;

1.414
date	2017.04.11.13.59.27;	author krw;	state Exp;
branches;
next	1.413;
commitid	zUymlMql24I51JEz;

1.413
date	2017.04.11.10.40.14;	author krw;	state Exp;
branches;
next	1.412;
commitid	fZH0FasjbItTtOXw;

1.412
date	2017.04.10.21.47.44;	author krw;	state Exp;
branches;
next	1.411;
commitid	ubZF40SEC22PLlgj;

1.411
date	2017.04.09.20.44.13;	author krw;	state Exp;
branches;
next	1.410;
commitid	Qbefa1v9yY6ObGzy;

1.410
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.409;
commitid	KIdulj0iLtM6kXff;

1.409
date	2017.04.08.17.00.10;	author krw;	state Exp;
branches;
next	1.408;
commitid	NmYVWunprpEm8q1k;

1.408
date	2017.04.07.15.03.00;	author krw;	state Exp;
branches;
next	1.407;
commitid	IJyiLQCmbwzmKm5U;

1.407
date	2017.04.04.15.15.48;	author krw;	state Exp;
branches;
next	1.406;
commitid	hBAWRbZZAV0xgcf3;

1.406
date	2017.04.04.13.01.20;	author krw;	state Exp;
branches;
next	1.405;
commitid	XnNlR4VEiZFpMvjG;

1.405
date	2017.03.08.20.54.30;	author krw;	state Exp;
branches;
next	1.404;
commitid	z409yvPZa6kAXQkv;

1.404
date	2017.03.08.15.34.44;	author krw;	state Exp;
branches;
next	1.403;
commitid	BWHYmHLL5uFxPuU2;

1.403
date	2017.03.08.14.55.21;	author krw;	state Exp;
branches;
next	1.402;
commitid	fWv7pIMDQy8PZBtV;

1.402
date	2017.03.08.14.36.19;	author krw;	state Exp;
branches;
next	1.401;
commitid	rm7YvBU8q5yzpO6r;

1.401
date	2017.03.08.14.28.44;	author krw;	state Exp;
branches;
next	1.400;
commitid	ZSSmZ4tQdrW9AFNB;

1.400
date	2017.03.08.14.19.00;	author krw;	state Exp;
branches;
next	1.399;
commitid	H8xvWxW8Df1Sly9w;

1.399
date	2017.02.15.20.00.16;	author krw;	state Exp;
branches;
next	1.398;
commitid	hD8qJgE1mUGpmAxx;

1.398
date	2017.02.14.22.46.53;	author krw;	state Exp;
branches;
next	1.397;
commitid	bri6pdd6g2CmmzEv;

1.397
date	2017.02.12.15.53.15;	author krw;	state Exp;
branches;
next	1.396;
commitid	YTCiHbXKpxvNuYuw;

1.396
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.395;
commitid	WchZmaQT4LJ4im5M;

1.395
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.394;
commitid	IDlzr3qamZK5lxzj;

1.394
date	2017.01.23.04.45.59;	author deraadt;	state Exp;
branches;
next	1.393;
commitid	hQYURPGr4b7LJN3W;

1.393
date	2016.11.25.14.46.57;	author krw;	state Exp;
branches;
next	1.392;
commitid	80Jb79mbaaiwpu5s;

1.392
date	2016.10.06.16.29.17;	author krw;	state Exp;
branches;
next	1.391;
commitid	dTOGnqxN6bqeD6hy;

1.391
date	2016.09.29.15.29.06;	author krw;	state Exp;
branches;
next	1.390;
commitid	ilzC5NQZafIL2nyk;

1.390
date	2016.09.27.15.17.58;	author jca;	state Exp;
branches;
next	1.389;
commitid	mK7Bwh5kPDjMyoji;

1.389
date	2016.09.16.23.35.45;	author krw;	state Exp;
branches;
next	1.388;
commitid	IQSC0g91XPl16i4N;

1.388
date	2016.09.15.16.19.04;	author jca;	state Exp;
branches;
next	1.387;
commitid	Rz8oxlUMJ1mv0MV4;

1.387
date	2016.09.04.11.21.24;	author jca;	state Exp;
branches;
next	1.386;
commitid	eqaJHdCwk0ksxJ6X;

1.386
date	2016.09.02.15.44.25;	author mpi;	state Exp;
branches;
next	1.385;
commitid	GuoxNV4NXpbUVBHj;

1.385
date	2016.09.02.11.11.49;	author krw;	state Exp;
branches;
next	1.384;
commitid	hTOiUZqaFtt2u1G3;

1.384
date	2016.08.31.23.16.16;	author krw;	state Exp;
branches;
next	1.383;
commitid	ItCrw4bcAaeqphAl;

1.383
date	2016.08.31.13.55.08;	author krw;	state Exp;
branches;
next	1.382;
commitid	uQBoIWgcb7NI3eMV;

1.382
date	2016.08.31.12.57.31;	author mpi;	state Exp;
branches;
next	1.381;
commitid	dRGzj71S05fFJodM;

1.381
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.380;
commitid	Tm7CrlqCKqgQoJ7P;

1.380
date	2016.08.16.21.57.51;	author krw;	state Exp;
branches;
next	1.379;
commitid	fX275BVALtbId2xm;

1.379
date	2016.07.23.15.53.19;	author stsp;	state Exp;
branches;
next	1.378;
commitid	TTaHvvpnzgDyaXre;

1.378
date	2016.07.22.13.23.38;	author krw;	state Exp;
branches;
next	1.377;
commitid	llO1gdOt4i2PG3Vg;

1.377
date	2016.07.21.09.58.55;	author krw;	state Exp;
branches;
next	1.376;
commitid	PqPfLTbAliUfPkYk;

1.376
date	2016.07.20.19.40.04;	author deraadt;	state Exp;
branches;
next	1.375;
commitid	KBgBSoOXMlfVq81D;

1.375
date	2016.07.20.19.25.39;	author deraadt;	state Exp;
branches;
next	1.374;
commitid	TfQwAGbhyS8UIFdK;

1.374
date	2016.07.19.17.23.20;	author krw;	state Exp;
branches;
next	1.373;
commitid	okxVGQawE5SK5RDk;

1.373
date	2016.04.28.17.34.49;	author krw;	state Exp;
branches;
next	1.372;
commitid	iUILNJNLVoYrXEAk;

1.372
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.371;
commitid	5ELOU0S0Zl3aCrHG;

1.371
date	2016.01.26.18.26.19;	author mmcc;	state Exp;
branches;
next	1.370;
commitid	W1L20xeSwlpa0n3G;

1.370
date	2015.12.12.14.48.17;	author krw;	state Exp;
branches;
next	1.369;
commitid	skRihYvealiyczYj;

1.369
date	2015.12.10.18.22.59;	author krw;	state Exp;
branches;
next	1.368;
commitid	eIRbR8uPZXf5sK1V;

1.368
date	2015.12.07.07.40.47;	author tb;	state Exp;
branches;
next	1.367;
commitid	BpM7jijfwtxcxfKY;

1.367
date	2015.12.05.13.09.11;	author claudio;	state Exp;
branches;
next	1.366;
commitid	BwmRUc9nP1VmVyAO;

1.366
date	2015.11.12.18.46.14;	author krw;	state Exp;
branches;
next	1.365;
commitid	E7LgF9FpEKFi8BqU;

1.365
date	2015.10.26.16.32.33;	author krw;	state Exp;
branches;
next	1.364;
commitid	Y03Zu0zFPhi0Triz;

1.364
date	2015.09.08.17.19.20;	author krw;	state Exp;
branches;
next	1.363;
commitid	6ugSXq1T9BwKpgvA;

1.363
date	2015.09.05.07.41.16;	author krw;	state Exp;
branches;
next	1.362;
commitid	dltuGJK0WEUSRh6L;

1.362
date	2015.08.31.21.32.07;	author krw;	state Exp;
branches;
next	1.361;
commitid	yEnbHSKktVmH2R1j;

1.361
date	2015.05.18.14.59.42;	author krw;	state Exp;
branches;
next	1.360;
commitid	TDloDnGAJKxV5TnQ;

1.360
date	2015.04.16.15.14.30;	author gsoares;	state Exp;
branches;
next	1.359;
commitid	UfLCPtkHd0jUaFye;

1.359
date	2015.02.15.01.56.42;	author tedu;	state Exp;
branches;
next	1.358;
commitid	MizPuKMrwD760Res;

1.358
date	2015.02.10.04.20.26;	author krw;	state Exp;
branches;
next	1.357;
commitid	TKehEr2jJpb2ARar;

1.357
date	2015.02.07.10.08.06;	author krw;	state Exp;
branches;
next	1.356;
commitid	DyjrY1dcWE4nZyJh;

1.356
date	2015.02.07.02.07.32;	author krw;	state Exp;
branches;
next	1.355;
commitid	WadF2oct8H7f0Oaz;

1.355
date	2015.02.06.09.16.06;	author reyk;	state Exp;
branches;
next	1.354;
commitid	vYyCsIthQQMdADc1;

1.354
date	2015.02.06.06.47.29;	author krw;	state Exp;
branches;
next	1.353;
commitid	NYRWhJb6ZVSnKVWu;

1.353
date	2015.02.05.23.56.06;	author krw;	state Exp;
branches;
next	1.352;
commitid	w9yBa6bfLdeG0Wty;

1.352
date	2015.02.01.18.43.39;	author krw;	state Exp;
branches;
next	1.351;
commitid	MGxD3aLHy6xeOkpL;

1.351
date	2015.01.31.23.18.29;	author krw;	state Exp;
branches;
next	1.350;
commitid	5dKBcvBbg9NrcjJc;

1.350
date	2015.01.31.23.05.58;	author krw;	state Exp;
branches;
next	1.349;
commitid	rJsoXDOGMIFNl6Q8;

1.349
date	2015.01.31.05.56.19;	author krw;	state Exp;
branches;
next	1.348;
commitid	hJhNuGLqU94L1UUi;

1.348
date	2015.01.30.14.30.54;	author krw;	state Exp;
branches;
next	1.347;
commitid	lJJClj2RKY9zFtwm;

1.347
date	2015.01.16.06.39.56;	author deraadt;	state Exp;
branches;
next	1.346;
commitid	Uu5nFG3wCl0LACBb;

1.346
date	2014.12.10.02.34.03;	author krw;	state Exp;
branches;
next	1.345;
commitid	ctbVz96wZgUYQsW7;

1.345
date	2014.12.10.01.05.13;	author krw;	state Exp;
branches;
next	1.344;
commitid	HhtwzgITnpzP4ckb;

1.344
date	2014.12.09.02.27.54;	author krw;	state Exp;
branches;
next	1.343;
commitid	8KJms1aR6oFWuJmG;

1.343
date	2014.12.08.02.04.58;	author krw;	state Exp;
branches;
next	1.342;
commitid	04nAgMUMwzOdV9TY;

1.342
date	2014.12.07.22.45.39;	author krw;	state Exp;
branches;
next	1.341;
commitid	BfGn7ZlFa5Opwcc7;

1.341
date	2014.12.07.17.01.09;	author krw;	state Exp;
branches;
next	1.340;
commitid	MnkcAfdGAZo1h8Ky;

1.340
date	2014.12.07.15.28.23;	author krw;	state Exp;
branches;
next	1.339;
commitid	VfvFzONbXXzLkOBM;

1.339
date	2014.12.05.15.47.05;	author krw;	state Exp;
branches;
next	1.338;
commitid	SbDeDj1TfxdJZP9f;

1.338
date	2014.11.30.00.09.30;	author krw;	state Exp;
branches;
next	1.337;
commitid	G4KmFVTJozqenTdp;

1.337
date	2014.11.29.22.06.55;	author krw;	state Exp;
branches;
next	1.336;
commitid	NNudhkUnsADDesfj;

1.336
date	2014.11.27.23.04.12;	author krw;	state Exp;
branches;
next	1.335;
commitid	ZQM9VieH9ikl0yoj;

1.335
date	2014.11.25.17.03.03;	author krw;	state Exp;
branches;
next	1.334;
commitid	gLO1K5mRKwEcbiPG;

1.334
date	2014.11.23.18.22.45;	author krw;	state Exp;
branches;
next	1.333;
commitid	A0DT3bmZICMqss1d;

1.333
date	2014.11.20.19.27.28;	author krw;	state Exp;
branches;
next	1.332;
commitid	CuLz3FRsBvVb6LuO;

1.332
date	2014.11.17.16.18.20;	author krw;	state Exp;
branches;
next	1.331;
commitid	9ti1t9Bua0fbYDEw;

1.331
date	2014.11.16.21.05.24;	author krw;	state Exp;
branches;
next	1.330;
commitid	D2XQKsOTR42l8Zgt;

1.330
date	2014.11.15.00.12.52;	author krw;	state Exp;
branches;
next	1.329;
commitid	kM0Hf8zKOzmkvwDF;

1.329
date	2014.11.04.04.03.10;	author krw;	state Exp;
branches;
next	1.328;
commitid	I4TC92Ilfe7oAseR;

1.328
date	2014.11.04.01.20.27;	author guenther;	state Exp;
branches;
next	1.327;
commitid	1RXWrRSfBlGGwkGY;

1.327
date	2014.11.03.02.22.15;	author krw;	state Exp;
branches;
next	1.326;
commitid	ZyHVXaqxErfUkJIw;

1.326
date	2014.11.02.15.18.32;	author krw;	state Exp;
branches;
next	1.325;
commitid	mfa2z1UxKtO5K6t8;

1.325
date	2014.11.01.15.49.07;	author krw;	state Exp;
branches;
next	1.324;
commitid	w5Quqsm7xyo3zcuD;

1.324
date	2014.10.29.15.28.51;	author krw;	state Exp;
branches;
next	1.323;
commitid	JuTrpYbMuawgGoRl;

1.323
date	2014.10.27.19.54.31;	author krw;	state Exp;
branches;
next	1.322;
commitid	iZuuBugp0WbgCtXQ;

1.322
date	2014.10.26.23.36.44;	author krw;	state Exp;
branches;
next	1.321;
commitid	ElvOocDepzhhYCyv;

1.321
date	2014.10.17.13.21.44;	author krw;	state Exp;
branches;
next	1.320;
commitid	6pRiEvJsOcvG3DI3;

1.320
date	2014.10.02.18.04.49;	author matthew;	state Exp;
branches;
next	1.319;
commitid	BEdkxopkUgv5xM9I;

1.319
date	2014.08.11.18.41.13;	author tobias;	state Exp;
branches;
next	1.318;
commitid	PQAFO99R88uYjk46;

1.318
date	2014.07.13.14.50.03;	author krw;	state Exp;
branches;
next	1.317;
commitid	gDaEPAsOTWa7Tyg6;

1.317
date	2014.07.12.21.04.07;	author krw;	state Exp;
branches;
next	1.316;
commitid	Lb4AL5SGAwxJeaCL;

1.316
date	2014.07.12.09.04.21;	author krw;	state Exp;
branches;
next	1.315;
commitid	jyULtSgV2bVzuJGr;

1.315
date	2014.07.11.21.08.20;	author krw;	state Exp;
branches;
next	1.314;
commitid	nRx7hT0l9vKZ4Zji;

1.314
date	2014.07.11.20.41.41;	author krw;	state Exp;
branches;
next	1.313;
commitid	HOL2C5xNqfNQEbpZ;

1.313
date	2014.07.11.20.19.30;	author krw;	state Exp;
branches;
next	1.312;
commitid	Cq1oZ0THixVNQ7gK;

1.312
date	2014.07.09.15.16.38;	author krw;	state Exp;
branches;
next	1.311;
commitid	j471lw6pShGoXIJ5;

1.311
date	2014.05.23.17.36.59;	author krw;	state Exp;
branches;
next	1.310;

1.310
date	2014.05.23.15.26.22;	author krw;	state Exp;
branches;
next	1.309;

1.309
date	2014.05.19.10.42.08;	author krw;	state Exp;
branches;
next	1.308;

1.308
date	2014.05.19.10.37.40;	author krw;	state Exp;
branches;
next	1.307;

1.307
date	2014.05.18.15.17.50;	author krw;	state Exp;
branches;
next	1.306;

1.306
date	2014.05.12.18.50.02;	author krw;	state Exp;
branches;
next	1.305;

1.305
date	2014.05.11.14.00.52;	author krw;	state Exp;
branches;
next	1.304;

1.304
date	2014.05.11.12.40.37;	author krw;	state Exp;
branches;
next	1.303;

1.303
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.302;

1.302
date	2014.05.05.14.44.18;	author krw;	state Exp;
branches;
next	1.301;

1.301
date	2014.05.04.21.07.50;	author krw;	state Exp;
branches;
next	1.300;

1.300
date	2014.04.30.15.11.00;	author krw;	state Exp;
branches;
next	1.299;

1.299
date	2014.04.21.15.26.50;	author krw;	state Exp;
branches;
next	1.298;

1.298
date	2014.04.20.21.25.07;	author krw;	state Exp;
branches;
next	1.297;

1.297
date	2014.04.17.13.46.48;	author krw;	state Exp;
branches;
next	1.296;

1.296
date	2014.04.17.09.59.30;	author krw;	state Exp;
branches;
next	1.295;

1.295
date	2014.04.16.18.46.41;	author krw;	state Exp;
branches;
next	1.294;

1.294
date	2014.04.16.13.57.58;	author krw;	state Exp;
branches;
next	1.293;

1.293
date	2014.02.09.20.45.56;	author krw;	state Exp;
branches;
next	1.292;

1.292
date	2014.02.08.18.12.17;	author krw;	state Exp;
branches;
next	1.291;

1.291
date	2014.02.07.18.42.17;	author krw;	state Exp;
branches;
next	1.290;

1.290
date	2014.02.07.18.12.17;	author krw;	state Exp;
branches;
next	1.289;

1.289
date	2014.02.07.13.38.55;	author krw;	state Exp;
branches;
next	1.288;

1.288
date	2014.01.25.05.21.23;	author krw;	state Exp;
branches;
next	1.287;

1.287
date	2014.01.21.05.17.45;	author krw;	state Exp;
branches;
next	1.286;

1.286
date	2014.01.21.03.07.50;	author krw;	state Exp;
branches;
next	1.285;

1.285
date	2014.01.20.09.16.36;	author deraadt;	state Exp;
branches;
next	1.284;

1.284
date	2014.01.20.02.54.07;	author deraadt;	state Exp;
branches;
next	1.283;

1.283
date	2014.01.17.23.11.42;	author tobias;	state Exp;
branches;
next	1.282;

1.282
date	2014.01.16.21.41.22;	author tobias;	state Exp;
branches;
next	1.281;

1.281
date	2013.12.30.03.36.17;	author krw;	state Exp;
branches;
next	1.280;

1.280
date	2013.12.21.18.23.10;	author krw;	state Exp;
branches;
next	1.279;

1.279
date	2013.12.15.03.15.47;	author krw;	state Exp;
branches;
next	1.278;

1.278
date	2013.12.14.05.07.09;	author krw;	state Exp;
branches;
next	1.277;

1.277
date	2013.12.10.17.01.27;	author krw;	state Exp;
branches;
next	1.276;

1.276
date	2013.12.09.18.05.36;	author krw;	state Exp;
branches;
next	1.275;

1.275
date	2013.12.08.22.49.02;	author krw;	state Exp;
branches;
next	1.274;

1.274
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.273;

1.273
date	2013.12.05.21.32.59;	author krw;	state Exp;
branches;
next	1.272;

1.272
date	2013.12.04.22.14.33;	author matthew;	state Exp;
branches;
next	1.271;

1.271
date	2013.12.04.19.44.41;	author krw;	state Exp;
branches;
next	1.270;

1.270
date	2013.12.04.19.39.50;	author krw;	state Exp;
branches;
next	1.269;

1.269
date	2013.12.04.16.54.28;	author krw;	state Exp;
branches;
next	1.268;

1.268
date	2013.11.20.17.22.46;	author deraadt;	state Exp;
branches;
next	1.267;

1.267
date	2013.11.11.21.00.01;	author krw;	state Exp;
branches;
next	1.266;

1.266
date	2013.11.11.18.43.45;	author krw;	state Exp;
branches;
next	1.265;

1.265
date	2013.11.11.17.16.11;	author krw;	state Exp;
branches;
next	1.264;

1.264
date	2013.11.11.15.39.20;	author krw;	state Exp;
branches;
next	1.263;

1.263
date	2013.10.22.18.15.58;	author krw;	state Exp;
branches;
next	1.262;

1.262
date	2013.09.09.20.30.05;	author krw;	state Exp;
branches;
next	1.261;

1.261
date	2013.08.14.13.52.53;	author florian;	state Exp;
branches;
next	1.260;

1.260
date	2013.07.15.14.03.01;	author krw;	state Exp;
branches;
next	1.259;

1.259
date	2013.07.06.03.13.34;	author krw;	state Exp;
branches;
next	1.258;

1.258
date	2013.07.05.22.13.10;	author krw;	state Exp;
branches;
next	1.257;

1.257
date	2013.06.18.17.02.41;	author krw;	state Exp;
branches;
next	1.256;

1.256
date	2013.06.18.00.30.39;	author krw;	state Exp;
branches;
next	1.255;

1.255
date	2013.06.17.19.51.41;	author krw;	state Exp;
branches;
next	1.254;

1.254
date	2013.06.09.22.39.51;	author krw;	state Exp;
branches;
next	1.253;

1.253
date	2013.06.09.17.31.54;	author krw;	state Exp;
branches;
next	1.252;

1.252
date	2013.06.09.16.21.50;	author krw;	state Exp;
branches;
next	1.251;

1.251
date	2013.06.09.15.06.34;	author krw;	state Exp;
branches;
next	1.250;

1.250
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.249;

1.249
date	2013.06.04.21.04.52;	author krw;	state Exp;
branches;
next	1.248;

1.248
date	2013.06.01.16.26.07;	author krw;	state Exp;
branches;
next	1.247;

1.247
date	2013.05.05.16.45.01;	author krw;	state Exp;
branches;
next	1.246;

1.246
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.245;

1.245
date	2013.05.02.14.48.35;	author krw;	state Exp;
branches;
next	1.244;

1.244
date	2013.04.27.17.54.24;	author krw;	state Exp;
branches;
next	1.243;

1.243
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.242;

1.242
date	2013.03.30.16.10.01;	author krw;	state Exp;
branches;
next	1.241;

1.241
date	2013.03.22.23.58.51;	author krw;	state Exp;
branches;
next	1.240;

1.240
date	2013.02.27.17.25.59;	author krw;	state Exp;
branches;
next	1.239;

1.239
date	2013.02.24.01.10.28;	author krw;	state Exp;
branches;
next	1.238;

1.238
date	2013.02.19.23.40.25;	author krw;	state Exp;
branches;
next	1.237;

1.237
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.236;

1.236
date	2013.02.17.17.04.41;	author krw;	state Exp;
branches;
next	1.235;

1.235
date	2013.02.17.00.02.44;	author krw;	state Exp;
branches;
next	1.234;

1.234
date	2013.02.16.13.50.17;	author krw;	state Exp;
branches;
next	1.233;

1.233
date	2013.02.15.19.52.38;	author krw;	state Exp;
branches;
next	1.232;

1.232
date	2013.02.15.15.00.17;	author krw;	state Exp;
branches;
next	1.231;

1.231
date	2013.02.15.14.54.04;	author krw;	state Exp;
branches;
next	1.230;

1.230
date	2013.02.15.14.40.03;	author krw;	state Exp;
branches;
next	1.229;

1.229
date	2013.02.14.22.18.12;	author krw;	state Exp;
branches;
next	1.228;

1.228
date	2013.02.14.20.39.46;	author krw;	state Exp;
branches;
next	1.227;

1.227
date	2013.02.13.19.32.52;	author krw;	state Exp;
branches;
next	1.226;

1.226
date	2013.02.09.23.37.21;	author krw;	state Exp;
branches;
next	1.225;

1.225
date	2013.02.02.20.20.42;	author krw;	state Exp;
branches;
next	1.224;

1.224
date	2013.02.02.04.18.29;	author krw;	state Exp;
branches;
next	1.223;

1.223
date	2013.02.02.02.47.16;	author krw;	state Exp;
branches;
next	1.222;

1.222
date	2013.02.01.23.43.33;	author florian;	state Exp;
branches;
next	1.221;

1.221
date	2013.02.01.20.46.04;	author florian;	state Exp;
branches;
next	1.220;

1.220
date	2013.02.01.20.07.30;	author krw;	state Exp;
branches;
next	1.219;

1.219
date	2013.02.01.15.24.55;	author krw;	state Exp;
branches;
next	1.218;

1.218
date	2013.02.01.01.33.44;	author krw;	state Exp;
branches;
next	1.217;

1.217
date	2013.01.27.02.45.46;	author krw;	state Exp;
branches;
next	1.216;

1.216
date	2013.01.26.18.51.42;	author krw;	state Exp;
branches;
next	1.215;

1.215
date	2013.01.26.05.07.21;	author krw;	state Exp;
branches;
next	1.214;

1.214
date	2013.01.22.06.02.52;	author krw;	state Exp;
branches;
next	1.213;

1.213
date	2013.01.18.08.07.32;	author jmc;	state Exp;
branches;
next	1.212;

1.212
date	2013.01.18.05.50.32;	author krw;	state Exp;
branches;
next	1.211;

1.211
date	2013.01.17.23.41.07;	author krw;	state Exp;
branches;
next	1.210;

1.210
date	2013.01.16.21.35.41;	author krw;	state Exp;
branches;
next	1.209;

1.209
date	2013.01.16.11.02.09;	author krw;	state Exp;
branches;
next	1.208;

1.208
date	2013.01.16.06.11.21;	author krw;	state Exp;
branches;
next	1.207;

1.207
date	2013.01.16.05.16.02;	author krw;	state Exp;
branches;
next	1.206;

1.206
date	2013.01.15.21.44.28;	author krw;	state Exp;
branches;
next	1.205;

1.205
date	2013.01.14.02.46.29;	author krw;	state Exp;
branches;
next	1.204;

1.204
date	2013.01.13.22.09.38;	author krw;	state Exp;
branches;
next	1.203;

1.203
date	2013.01.13.04.51.28;	author krw;	state Exp;
branches;
next	1.202;

1.202
date	2013.01.06.15.33.12;	author krw;	state Exp;
branches;
next	1.201;

1.201
date	2013.01.05.20.34.17;	author krw;	state Exp;
branches;
next	1.200;

1.200
date	2013.01.02.16.27.42;	author krw;	state Exp;
branches;
next	1.199;

1.199
date	2012.12.29.14.40.00;	author krw;	state Exp;
branches;
next	1.198;

1.198
date	2012.12.21.20.37.28;	author krw;	state Exp;
branches;
next	1.197;

1.197
date	2012.12.19.12.25.38;	author krw;	state Exp;
branches;
next	1.196;

1.196
date	2012.12.18.14.34.58;	author krw;	state Exp;
branches;
next	1.195;

1.195
date	2012.12.17.22.52.59;	author krw;	state Exp;
branches;
next	1.194;

1.194
date	2012.12.16.03.15.46;	author lteo;	state Exp;
branches;
next	1.193;

1.193
date	2012.12.15.13.26.28;	author krw;	state Exp;
branches;
next	1.192;

1.192
date	2012.12.10.10.39.01;	author jmc;	state Exp;
branches;
next	1.191;

1.191
date	2012.12.09.20.28.03;	author krw;	state Exp;
branches;
next	1.190;

1.190
date	2012.12.05.18.11.33;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2012.12.05.03.14.10;	author krw;	state Exp;
branches;
next	1.188;

1.188
date	2012.12.04.19.24.02;	author krw;	state Exp;
branches;
next	1.187;

1.187
date	2012.12.03.22.36.16;	author krw;	state Exp;
branches;
next	1.186;

1.186
date	2012.12.03.22.19.47;	author krw;	state Exp;
branches;
next	1.185;

1.185
date	2012.12.02.17.03.19;	author krw;	state Exp;
branches;
next	1.184;

1.184
date	2012.12.01.11.59.44;	author krw;	state Exp;
branches;
next	1.183;

1.183
date	2012.11.29.14.13.31;	author krw;	state Exp;
branches;
next	1.182;

1.182
date	2012.11.27.15.51.48;	author krw;	state Exp;
branches;
next	1.181;

1.181
date	2012.11.25.12.49.56;	author krw;	state Exp;
branches;
next	1.180;

1.180
date	2012.11.24.18.06.14;	author krw;	state Exp;
branches;
next	1.179;

1.179
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2012.11.16.16.46.18;	author krw;	state Exp;
branches;
next	1.177;

1.177
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.176;

1.176
date	2012.11.15.10.32.59;	author krw;	state Exp;
branches;
next	1.175;

1.175
date	2012.11.14.18.10.45;	author krw;	state Exp;
branches;
next	1.174;

1.174
date	2012.11.14.18.09.01;	author krw;	state Exp;
branches;
next	1.173;

1.173
date	2012.11.14.15.47.41;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2012.11.11.16.36.13;	author krw;	state Exp;
branches;
next	1.171;

1.171
date	2012.11.11.14.33.20;	author krw;	state Exp;
branches;
next	1.170;

1.170
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.169;

1.169
date	2012.11.07.15.40.13;	author krw;	state Exp;
branches;
next	1.168;

1.168
date	2012.11.07.15.20.28;	author krw;	state Exp;
branches;
next	1.167;

1.167
date	2012.11.07.15.07.02;	author krw;	state Exp;
branches;
next	1.166;

1.166
date	2012.11.04.03.36.39;	author krw;	state Exp;
branches;
next	1.165;

1.165
date	2012.11.04.03.25.31;	author krw;	state Exp;
branches;
next	1.164;

1.164
date	2012.11.03.16.54.34;	author krw;	state Exp;
branches;
next	1.163;

1.163
date	2012.11.02.17.29.37;	author krw;	state Exp;
branches;
next	1.162;

1.162
date	2012.10.31.20.13.33;	author krw;	state Exp;
branches;
next	1.161;

1.161
date	2012.10.31.18.21.03;	author krw;	state Exp;
branches;
next	1.160;

1.160
date	2012.10.31.15.50.47;	author krw;	state Exp;
branches;
next	1.159;

1.159
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.158;

1.158
date	2012.10.27.23.08.53;	author krw;	state Exp;
branches;
next	1.157;

1.157
date	2012.10.10.17.44.43;	author krw;	state Exp;
branches;
next	1.156;

1.156
date	2012.09.18.09.34.09;	author krw;	state Exp;
branches;
next	1.155;

1.155
date	2012.09.17.20.30.17;	author krw;	state Exp;
branches;
next	1.154;

1.154
date	2012.09.01.19.02.27;	author krw;	state Exp;
branches;
next	1.153;

1.153
date	2012.08.31.02.36.11;	author krw;	state Exp;
branches;
next	1.152;

1.152
date	2012.08.26.23.33.29;	author krw;	state Exp;
branches;
next	1.151;

1.151
date	2012.08.22.00.14.42;	author tedu;	state Exp;
branches;
next	1.150;

1.150
date	2012.08.21.00.29.32;	author krw;	state Exp;
branches;
next	1.149;

1.149
date	2012.08.18.18.14.41;	author krw;	state Exp;
branches;
next	1.148;

1.148
date	2012.08.18.15.27.56;	author krw;	state Exp;
branches;
next	1.147;

1.147
date	2012.08.18.00.20.01;	author krw;	state Exp;
branches;
next	1.146;

1.146
date	2012.07.09.16.21.21;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2012.06.24.16.01.18;	author krw;	state Exp;
branches;
next	1.144;

1.144
date	2012.06.22.00.08.43;	author krw;	state Exp;
branches;
next	1.143;

1.143
date	2012.06.20.21.53.51;	author kettenis;	state Exp;
branches;
next	1.142;

1.142
date	2011.12.10.15.55.43;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2011.05.11.14.38.36;	author krw;	state Exp;
branches;
next	1.140;

1.140
date	2011.04.17.20.06.08;	author phessler;	state Exp;
branches;
next	1.139;

1.139
date	2011.04.04.11.14.52;	author krw;	state Exp;
branches;
next	1.138;

1.138
date	2011.03.27.12.15.46;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2010.10.15.09.51.15;	author jsg;	state Exp;
branches;
next	1.136;

1.136
date	2010.09.24.13.44.14;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2010.06.26.20.48.45;	author krw;	state Exp;
branches;
next	1.134;

1.134
date	2010.06.02.09.57.16;	author phessler;	state Exp;
branches;
next	1.133;

1.133
date	2010.03.25.18.37.36;	author stevesk;	state Exp;
branches;
next	1.132;

1.132
date	2009.11.12.14.18.45;	author jsg;	state Exp;
branches;
next	1.131;

1.131
date	2009.07.19.00.18.02;	author stevesk;	state Exp;
branches;
next	1.130;

1.130
date	2009.06.12.20.07.35;	author stevesk;	state Exp;
branches;
next	1.129;

1.129
date	2009.06.06.04.02.42;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2009.06.03.02.05.34;	author stevesk;	state Exp;
branches;
next	1.127;

1.127
date	2009.05.25.00.17.40;	author stevesk;	state Exp;
branches;
next	1.126;

1.126
date	2009.05.20.20.37.43;	author thib;	state Exp;
branches;
next	1.125;

1.125
date	2009.03.31.01.31.26;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2009.03.10.23.19.36;	author krw;	state Exp;
branches;
next	1.123;

1.123
date	2009.02.01.12.10.14;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2009.01.28.17.05.53;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2009.01.10.16.33.47;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2008.06.07.03.22.26;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2008.05.26.03.11.48;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2008.05.09.05.19.14;	author reyk;	state Exp;
branches;
next	1.117;

1.117
date	2008.03.12.13.31.22;	author hugh;	state Exp;
branches;
next	1.116;

1.116
date	2007.10.16.20.19.26;	author sobrado;	state Exp;
branches;
next	1.115;

1.115
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2007.08.14.15.29.18;	author stevesk;	state Exp;
branches;
next	1.113;

1.113
date	2007.07.18.14.19.48;	author stevesk;	state Exp;
branches;
next	1.112;

1.112
date	2007.06.02.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.111;

1.111
date	2007.02.25.18.10.43;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2007.02.25.16.27.20;	author stevesk;	state Exp;
branches;
next	1.109;

1.109
date	2007.02.13.21.54.22;	author stevesk;	state Exp;
branches;
next	1.108;

1.108
date	2007.02.13.15.21.59;	author stevesk;	state Exp;
branches;
next	1.107;

1.107
date	2007.01.29.13.12.56;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2007.01.27.22.05.24;	author krw;	state Exp;
branches;
next	1.105;

1.105
date	2007.01.25.01.21.04;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2007.01.16.20.22.20;	author krw;	state Exp;
branches;
next	1.103;

1.103
date	2007.01.11.02.36.29;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2007.01.04.22.30.57;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2007.01.04.22.17.48;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2006.12.28.20.04.22;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2006.12.28.01.32.10;	author stevesk;	state Exp;
branches;
next	1.98;

1.98
date	2006.12.28.01.10.46;	author stevesk;	state Exp;
branches;
next	1.97;

1.97
date	2006.12.28.00.51.19;	author stevesk;	state Exp;
branches;
next	1.96;

1.96
date	2006.12.27.20.56.33;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2006.12.26.15.03.16;	author moritz;	state Exp;
branches;
next	1.93;

1.93
date	2006.12.18.18.08.12;	author stevesk;	state Exp;
branches;
next	1.92;

1.92
date	2006.12.17.18.09.32;	author stevesk;	state Exp;
branches;
next	1.91;

1.91
date	2006.12.15.14.56.38;	author stevesk;	state Exp;
branches;
next	1.90;

1.90
date	2006.11.27.20.52.30;	author stevesk;	state Exp;
branches;
next	1.89;

1.89
date	2006.09.24.14.54.54;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.31.10.12.18;	author deraadt;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2006.08.29.03.55.08;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2006.06.16.16.17.16;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.01.16.37.54;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2006.05.31.02.21.49;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.08.17.25.59;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.06.10.45.56;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2005.10.26.15.42.04;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2005.08.27.06.40.18;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2005.08.25.19.08.50;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2005.08.07.01.35.11;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.02.02.34.03;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.16.14.09.51;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.13.23.31.32;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2005.07.13.23.25.55;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2005.07.09.14.36.15;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.08.00.57.36;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.07.20.03.40;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.07.16.24.24;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.07.13.33.35;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.29.08.46.10;	author marius;	state Exp;
branches;
next	1.67;

1.67
date	2005.04.08.14.21.36;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.02.20.26.10;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.02.20.23.23;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.02.16.41.09;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.06.17.10.13;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2004.12.05.18.35.51;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.25.11.05.10;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2004.09.15.23.33.41;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.15.18.15.18;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.30.07.43.32;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2004.07.07.17.00.55;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.23.05.15.21;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.22.23.05.28;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.22.01.33.51;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.03.18.59.44;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.13.07.19.32;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.08.16.16.33;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.07.23.05.19;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.06.22.29.15;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.05.23.07.47;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.05.22.21.03;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.05.14.29.16;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.05.13.21.49;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.05.11.40.46;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.05.11.19.07;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.05.10.51.23;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.04.12.52.05;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.14.20.14.49;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.13.18.04.09;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.08.15.36.38;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.08.01.13.30;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.07.20.18.48;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.07.20.14.46;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.05.23.57.16;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.02.18.49.21;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.02.15.58.41;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.02.15.52.40;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.02.15.41.44;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.02.15.34.03;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.02.13.39.44;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.02.13.00.02;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.02.12.56.30;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.02.12.46.44;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.02.12.40.31;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.24.17.26.43;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.24.15.35.56;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.24.14.49.08;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.24.14.36.17;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.24.13.36.13;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.24.13.21.32;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.24.13.08.26;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.24.12.41.28;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.24.12.34.26;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.24.11.35.39;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.23.20.09.02;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.10.13.12.48;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.14.03.48;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.07.13.59.45;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.07.13.26.35;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.05.13.39.32;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.05.13.33.22;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.01.18.26;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;

1.88.2.1
date	2006.12.26.22.39.05;	author moritz;	state Exp;
branches;
next	;


desc
@@


1.487
log
@Default routes supplied via DHO_CLASSLESS[_MS]_STATIC_ROUTES
should have the same add_route() logic applied to them as
the one supplied via DHO_ROUTERS. i.e. add the /32 route
if needed, create direct route if gateway address is the
same as interface address.

Simplify logic by using the canonical rtstatic[] version
of static routes created by lease_as_proposal().
@
text
@/*	$OpenBSD: dhclient.c,v 1.486 2017/07/26 18:16:21 jca Exp $	*/

/*
 * Copyright 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.    All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 *
 * This client was substantially modified and enhanced by Elliot Poger
 * for use on Linux while he was working on the MosquitoNet project at
 * Stanford.
 *
 * The current version owes much to Elliot's Linux enhancements, but
 * was substantially reorganized and partially rewritten by Ted Lemon
 * so as to use the same networking framework that the Internet Software
 * Consortium DHCP server uses.   Much system-specific configuration code
 * was moved into a shell script so that as support for more operating
 * systems is added, it will not be necessary to port and maintain
 * system-specific configuration code to these operating systems - instead,
 * the shell script can invoke the native tools to accomplish the same
 * purpose.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_ioctl.h>

#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <imsg.h>
#include <limits.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <resolv.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"
#include "privsep.h"

char *path_dhclient_conf = _PATH_DHCLIENT_CONF;
char *path_dhclient_db = NULL;

char path_option_db[PATH_MAX];

int log_perror = 1;
int nullfd = -1;
int daemonize = 1;
int unknown_ok = 1;

volatile sig_atomic_t quit;

const struct in_addr inaddr_any = { INADDR_ANY };
const struct in_addr inaddr_broadcast = { INADDR_BROADCAST };

struct client_config *config;
struct imsgbuf *unpriv_ibuf;

struct proposal {
	uint8_t		rtstatic[RTSTATIC_LEN];
	uint8_t		rtsearch[RTSEARCH_LEN];
	uint8_t		rtdns[RTDNS_LEN];
	struct in_addr	ifa;
	struct in_addr	netmask;
	unsigned int	rtstatic_len;
	unsigned int	rtsearch_len;
	unsigned int	rtdns_len;
	int		mtu;
	int		addrs;
	int		inits;
};

void		 sighdlr(int);
void		 usage(void);
int		 res_hnok(const char *dn);
int		 res_hnok_list(const char *dn);
int		 addressinuse(char *, struct in_addr, char *);

void		 fork_privchld(struct interface_info *, int, int);
void		 get_ifname(struct interface_info *, int, char *);
int		 get_ifa_family(char *, int);
void		 interface_link_forceup(char *, int);
int		 interface_status(char *);
void		 get_hw_address(struct interface_info *);

struct client_lease *apply_defaults(struct client_lease *);
struct client_lease *clone_lease(struct client_lease *);
void		 apply_ignore_list(char *);

void set_lease_times(struct client_lease *);

void state_preboot(struct interface_info *);
void state_reboot(struct interface_info *);
void state_init(struct interface_info *);
void state_selecting(struct interface_info *);
void state_bound(struct interface_info *);
void state_panic(struct interface_info *);

void send_discover(struct interface_info *);
void send_request(struct interface_info *);
void send_decline(struct interface_info *);

void bind_lease(struct interface_info *);

void make_discover(struct interface_info *, struct client_lease *);
void make_request(struct interface_info *, struct client_lease *);
void make_decline(struct interface_info *, struct client_lease *);

void rewrite_client_leases(struct interface_info *);
void rewrite_option_db(char *, struct client_lease *, struct client_lease *);
char *lease_as_string(char *, char *, struct client_lease *);
struct proposal *lease_as_proposal(struct client_lease *);
void append_statement(char *, size_t, char *, char *);

struct client_lease *packet_to_lease(struct interface_info *,
    struct option_data *);
void go_daemon(void);
int rdaemon(int);
void	take_charge(struct interface_info *, int);
void	set_default_client_identifier(struct interface_info *);
struct client_lease *get_recorded_lease(struct interface_info *);

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define	ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

static FILE *leaseFile;
static FILE *optionDB;

void
sighdlr(int sig)
{
	quit = sig;
}

int
get_ifa_family(char *cp, int n)
{
	struct sockaddr		*sa;
	unsigned int		 i;

	for (i = 1; i; i <<= 1) {
		if ((i & n) != 0) {
			sa = (struct sockaddr *)cp;
			if (i == RTA_IFA)
				return sa->sa_family;
			ADVANCE(cp, sa);
		}
	}

	return AF_UNSPEC;
}

void
interface_link_forceup(char *name, int ioctlfd)
{
	struct ifreq	 ifr;

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(ioctlfd, SIOCGIFFLAGS, (caddr_t)&ifr) == -1) {
		log_warn("SIOCGIFFLAGS");
		return;
	}

	/* Force it up if it isn't already. */
	if ((ifr.ifr_flags & IFF_UP) == 0) {
		ifr.ifr_flags |= IFF_UP;
		if (ioctl(ioctlfd, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
			log_warn("SIOCSIFFLAGS");
			return;
		}
	}
}

int
interface_status(char *name)
{
	struct ifaddrs	*ifap, *ifa;
	struct if_data	*ifdata;

	if (getifaddrs(&ifap) != 0)
		fatalx("getifaddrs failed");

	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT))
			continue;

		if (strcmp(name, ifa->ifa_name) != 0)
			continue;

		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		if ((ifa->ifa_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			return 0;

		ifdata = ifa->ifa_data;

		return LINK_STATE_IS_UP(ifdata->ifi_link_state);
	}

	return 0;
}

void
get_hw_address(struct interface_info *ifi)
{
	struct ifaddrs		*ifap, *ifa;
	struct sockaddr_dl	*sdl;
	struct if_data		*ifdata;
	int			 found;

	if (getifaddrs(&ifap) != 0)
		fatalx("getifaddrs failed");

	found = 0;
	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT))
			continue;

		if (strcmp(ifi->name, ifa->ifa_name) != 0)
			continue;
		found = 1;

		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != ETHER_ADDR_LEN)
			continue;

		ifdata = ifa->ifa_data;
		ifi->rdomain = ifdata->ifi_rdomain;

		memcpy(ifi->hw_address.ether_addr_octet, LLADDR(sdl),
		    ETHER_ADDR_LEN);
		ifi->flags |= IFI_VALID_LLADDR;
	}

	if (found == 0)
		fatalx("%s: no such interface", ifi->name);

	freeifaddrs(ifap);
}

void
routehandler(struct interface_info *ifi, int routefd)
{
	struct ether_addr		 hw;
	struct rt_msghdr		*rtm;
	struct if_msghdr		*ifm;
	struct if_announcemsghdr	*ifan;
	struct ifa_msghdr		*ifam;
	char				*errmsg, *rtmmsg;
	ssize_t				 n;
	int				 linkstat, rslt;

	rtmmsg = calloc(1, 2048);
	if (rtmmsg == NULL)
		fatalx("No memory for rtmmsg");

	do {
		n = read(routefd, rtmmsg, 2048);
	} while (n == -1 && errno == EINTR);
	if (n == -1)
		goto done;

	rtm = (struct rt_msghdr *)rtmmsg;
	if ((size_t)n < sizeof(rtm->rtm_msglen) || n < rtm->rtm_msglen ||
	    rtm->rtm_version != RTM_VERSION)
		goto done;

	switch (rtm->rtm_type) {
	case RTM_PROPOSAL:
		if (rtm->rtm_index != ifi->index ||
		    rtm->rtm_priority != RTP_PROPOSAL_DHCLIENT)
			goto done;
		if ((rtm->rtm_flags & RTF_PROTO3) != 0) {
			if (rtm->rtm_seq == (int32_t)ifi->xid) {
				ifi->flags |= IFI_IN_CHARGE;
			} else if ((ifi->flags & IFI_IN_CHARGE) != 0) {
				rslt = asprintf(&errmsg, "yielding "
				    "responsibility for %s",
				    ifi->name);
				goto die;
			}
			goto done;
		}
		break;
	case RTM_DESYNC:
		log_warnx("route socket buffer overflow");
		break;
	case RTM_IFINFO:
		ifm = (struct if_msghdr *)rtm;
		if (ifm->ifm_index != ifi->index)
			break;
		if ((rtm->rtm_flags & RTF_UP) == 0) {
			rslt = asprintf(&errmsg, "%s down", ifi->name);
			goto die;
		}

		if ((ifi->flags & IFI_VALID_LLADDR) != 0) {
			memcpy(&hw, &ifi->hw_address, sizeof(hw));
			get_hw_address(ifi);
			if (memcmp(&hw, &ifi->hw_address, sizeof(hw))) {
				log_warnx("LLADDR changed; restarting");
				sendhup();
				goto done;
			}
		}

		linkstat = interface_status(ifi->name);
		if (linkstat != ifi->linkstat) {
#ifdef DEBUG
			log_debug("link state %s -> %s",
			    (ifi->linkstat != 0) ? "up" : "down",
			    (linkstat != 0) ? "up" : "down");
#endif	/* DEBUG */
			ifi->linkstat = linkstat;
			if (ifi->linkstat != 0) {
				if (ifi->state == S_PREBOOT) {
					state_preboot(ifi);
					get_hw_address(ifi);
				} else {
					ifi->state = S_REBOOTING;
					state_reboot(ifi);
				}
			} else {
				/* No need to wait for anything but link. */
				cancel_timeout(ifi);
			}
		}
		break;
	case RTM_IFANNOUNCE:
		ifan = (struct if_announcemsghdr *)rtm;
		if (ifan->ifan_what == IFAN_DEPARTURE &&
		    ifan->ifan_index == ifi->index) {
			rslt = asprintf(&errmsg, "%s departured", ifi->name);
			goto die;
		}
		break;
	case RTM_NEWADDR:
	case RTM_DELADDR:
		/* Need to check if it is time to write resolv.conf. */
		ifam = (struct ifa_msghdr *)rtm;
		if (ifam->ifam_index != ifi->index)
			goto done;
		if (get_ifa_family((char *)ifam + ifam->ifam_hdrlen,
		    ifam->ifam_addrs) != AF_INET)
			goto done;
		break;
	default:
		break;
	}

	/* Something has happened. Try to write out the resolv.conf. */
	if (ifi->active != NULL && ifi->active->resolv_conf != NULL &&
	    (ifi->flags & IFI_IN_CHARGE) != 0)
		write_resolv_conf(ifi->active->resolv_conf,
		    strlen(ifi->active->resolv_conf));

done:
	free(rtmmsg);
	return;

die:
	if (rslt == -1)
		fatalx("no memory for errmsg");
	fatalx("%s", errmsg);
}

char **saved_argv;

int
main(int argc, char *argv[])
{
	struct ieee80211_nwid	 nwid;
	struct ifreq		 ifr;
	struct stat		 sb;
	const char		*tail_path = "/etc/resolv.conf.tail";
	struct interface_info	*ifi;
	struct passwd		*pw;
	struct client_lease	*lp, *nlp;
	char			*ignore_list = NULL;
	ssize_t			 tailn;
	int			 fd, socket_fd[2];
	int			 rtfilter, ioctlfd, routefd, tailfd;
	int			 ch, q_flag, d_flag;

	saved_argv = argv;

	if (isatty(STDERR_FILENO) != 0)
		log_perror = 1; /* log to stderr until daemonized */
	else
		log_perror = 0; /* can't log to stderr */

	log_init(log_perror, LOG_DAEMON);
	log_setverbose(1);

	q_flag = d_flag = 0;
	while ((ch = getopt(argc, argv, "c:di:l:L:qu")) != -1)
		switch (ch) {
		case 'c':
			path_dhclient_conf = optarg;
			break;
		case 'd':
			d_flag = 1;
			break;
		case 'i':
			ignore_list = optarg;
			break;
		case 'l':
			path_dhclient_db = optarg;
			if (lstat(path_dhclient_db, &sb) != -1) {
				if (S_ISREG(sb.st_mode) == 0)
					fatalx("'%s' is not a regular file",
					    path_dhclient_db);
			}
			break;
		case 'L':
			strlcat(path_option_db, optarg, PATH_MAX);
			if (lstat(path_option_db, &sb) != -1) {
				if (S_ISREG(sb.st_mode) == 0)
					fatalx("'%s' is not a regular file",
					    path_option_db);
			}
			break;
		case 'q':
			q_flag = 1;
			break;
		case 'u':
			unknown_ok = 0;
			break;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc != 1 || (q_flag != 0 && d_flag != 0))
		usage();

	if (d_flag != 0)
		daemonize = 0;

	if (q_flag != 0)
		log_perror = 0;

	log_init(log_perror, LOG_DAEMON);

	ifi = calloc(1, sizeof(struct interface_info));
	if (ifi == NULL)
		fatalx("ifi calloc");
	if ((ioctlfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("Can't create socket to do ioctl");
	get_ifname(ifi, ioctlfd, argv[0]);
	ifi->index = if_nametoindex(ifi->name);
	if (ifi->index == 0)
		fatalx("%s: no such interface", ifi->name);
	get_hw_address(ifi);

	tzset();

	/* Get the ssid if present. */
	memset(&ifr, 0, sizeof(ifr));
	memset(&nwid, 0, sizeof(nwid));
	ifr.ifr_data = (caddr_t)&nwid;
	strlcpy(ifr.ifr_name, ifi->name, sizeof(ifr.ifr_name));
	if (ioctl(ioctlfd, SIOCG80211NWID, (caddr_t)&ifr) == 0) {
		memset(ifi->ssid, 0, sizeof(ifi->ssid));
		memcpy(ifi->ssid, nwid.i_nwid, nwid.i_len);
		ifi->ssid_len = nwid.i_len;
	}

	/* Put us into the correct rdomain */
	if (setrtable(ifi->rdomain) == -1)
		fatal("setting routing table to %u", ifi->rdomain);

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    PF_UNSPEC, socket_fd) == -1)
		fatal("socketpair");

	if ((nullfd = open(_PATH_DEVNULL, O_RDWR, 0)) == -1)
		fatal("cannot open %s", _PATH_DEVNULL);

	fork_privchld(ifi, socket_fd[0], socket_fd[1]);

	close(socket_fd[0]);
	if ((unpriv_ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		fatalx("no memory for unpriv_ibuf");
	imsg_init(unpriv_ibuf, socket_fd[1]);

	config = calloc(1, sizeof(struct client_config));
	if (config == NULL)
		fatalx("config calloc");

	read_client_conf(ifi->name);

	/*
	 * Set default client identifier, if needed, *before* reading
	 * the leases file! Changes to the lladdr will trigger a restart
	 * and go through here again.
	 */
	set_default_client_identifier(ifi);

	if ((pw = getpwnam("_dhcp")) == NULL)
		fatalx("no such user: _dhcp");

	if (path_dhclient_db == NULL && asprintf(&path_dhclient_db, "%s.%s",
	    _PATH_DHCLIENT_DB, ifi->name) == -1)
		fatalx("asprintf");

	/* 2nd stage (post fork) config setup. */
	if (ignore_list != NULL)
		apply_ignore_list(ignore_list);

	tailfd = open(tail_path, O_RDONLY);
	if (tailfd == -1) {
		if (errno != ENOENT)
			fatal("Cannot open %s", tail_path);
	} else if (fstat(tailfd, &sb) == -1) {
		fatal("Cannot stat %s", tail_path);
	} else {
		if (sb.st_size > 0 && sb.st_size < LLONG_MAX) {
			config->resolv_tail = calloc(1, sb.st_size + 1);
			if (config->resolv_tail == NULL) {
				fatalx("no memory for %s contents", tail_path);
			}
			tailn = read(tailfd, config->resolv_tail, sb.st_size);
			if (tailn == -1)
				fatal("Couldn't read %s", tail_path);
			else if (tailn == 0)
				fatalx("Got no data from %s", tail_path);
			else if (tailn != sb.st_size)
				fatalx("Short read of %s", tail_path);
		}
		close(tailfd);
	}

	/*
	 * Do the initial status check and possible force up before creating
	 * the routing socket. If we bounce the interface down and up while
	 * the routing socket is listening, the RTM_IFINFO message with the
	 * RTF_UP flag reset will cause premature exit.
	 */
	ifi->linkstat = interface_status(ifi->name);
	if (ifi->linkstat == 0)
		interface_link_forceup(ifi->name, ioctlfd);
	close(ioctlfd);
	ioctlfd = -1;

	if ((routefd = socket(PF_ROUTE, SOCK_RAW, AF_INET)) == -1)
		fatal("socket(PF_ROUTE, SOCK_RAW)");

	rtfilter = ROUTE_FILTER(RTM_PROPOSAL) | ROUTE_FILTER(RTM_IFINFO) |
	    ROUTE_FILTER(RTM_NEWADDR) | ROUTE_FILTER(RTM_DELADDR) |
	    ROUTE_FILTER(RTM_IFANNOUNCE);

	if (setsockopt(routefd, PF_ROUTE, ROUTE_MSGFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)
		fatal("setsockopt(ROUTE_MSGFILTER)");
	if (setsockopt(routefd, AF_ROUTE, ROUTE_TABLEFILTER, &ifi->rdomain,
	    sizeof(ifi->rdomain)) == -1)
		fatal("setsockopt(ROUTE_TABLEFILTER)");

	take_charge(ifi, routefd);

	if ((fd = open(path_dhclient_db,
	    O_RDONLY|O_EXLOCK|O_CREAT|O_NOFOLLOW, 0640)) == -1)
		fatal("can't open and lock %s", path_dhclient_db);
	read_client_leases(ifi->name, &ifi->leases);
	if ((leaseFile = fopen(path_dhclient_db, "w")) == NULL)
		fatal("can't open %s", path_dhclient_db);
	rewrite_client_leases(ifi);
	close(fd);

	/* Add the static leases to the end of the list of available leases. */
	TAILQ_FOREACH_SAFE(lp, &config->static_leases, next, nlp) {
		TAILQ_REMOVE(&config->static_leases, lp, next);
		lp->is_static = 1;
		TAILQ_INSERT_TAIL(&ifi->leases, lp, next);
	}

	if (strlen(path_option_db) != 0) {
		if ((optionDB = fopen(path_option_db, "a")) == NULL)
			fatal("can't open %s", path_option_db);
	}

	/* Register the interface. */
	ifi->ufdesc = get_udp_sock(ifi->rdomain);
	ifi->bfdesc = get_bpf_sock(ifi->name);
	ifi->rbuf_max = configure_bpf_sock(ifi->bfdesc);
	ifi->rbuf = malloc(ifi->rbuf_max);
	if (ifi->rbuf == NULL)
		fatalx("Can't allocate %lu bytes for bpf input buffer.",
		    (unsigned long)ifi->rbuf_max);
	ifi->rbuf_offset = 0;
	ifi->rbuf_len = 0;

	if (chroot(_PATH_VAREMPTY) == -1)
		fatalx("chroot");
	if (chdir("/") == -1)
		fatalx("chdir(\"/\")");

	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
		fatalx("setresgid");
	if (setgroups(1, &pw->pw_gid) == -1)
		fatalx("setgroups");
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
		fatalx("setresuid");

	endpwent();

	if (daemonize != 0) {
		if (pledge("stdio inet dns route proc", NULL) == -1)
			fatalx("pledge");
	} else {
		if (pledge("stdio inet dns route", NULL) == -1)
			fatalx("pledge");
	}

	setproctitle("%s", ifi->name);
	time(&ifi->startup_time);

	if (ifi->linkstat != 0) {
		ifi->state = S_REBOOTING;
		state_reboot(ifi);
	} else {
		ifi->state = S_PREBOOT;
		state_preboot(ifi);
	}

	dispatch(ifi, routefd);

	/* not reached */
	return 0;
}

void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr,
	    "usage: %s [-d | -q] [-u] [-c file] [-i options] [-L file] "
	    "[-l file] interface\n", __progname);
	exit(1);
}

void
state_preboot(struct interface_info *ifi)
{
	static int	 preamble;
	time_t		 cur_time;
	int		 interval;

	time(&cur_time);

	interval = cur_time - ifi->startup_time;

	ifi->linkstat = interface_status(ifi->name);

	if (log_perror != 0 && interval > 3) {
		if (preamble == 0 && ifi->linkstat == 0) {
			fprintf(stderr, "%s: no link ....", ifi->name);
			preamble = 1;
		}
		if (preamble != 0) {
			if (ifi->linkstat != 0)
				fprintf(stderr, " got link\n");
			else if (interval > config->link_timeout)
				fprintf(stderr, " sleeping\n");
			else
				fprintf(stderr, ".");
			fflush(stderr);
		}
	}

	if (ifi->linkstat != 0) {
		ifi->state = S_REBOOTING;
		set_timeout(ifi, 1, state_reboot);
	} else {
		if (interval > config->link_timeout)
			go_daemon();
		ifi->state = S_PREBOOT;
		set_timeout(ifi, 1, state_preboot);
	}
}

/*
 * Called when the interface link becomes active.
 */
void
state_reboot(struct interface_info *ifi)
{
	cancel_timeout(ifi);

	/*
	 * If there is no recorded lease or the lease is BOOTP then
	 * go straight to INIT and try to DISCOVER a new lease.
	 */
	ifi->active = get_recorded_lease(ifi);
	if (ifi->active == NULL || BOOTP_LEASE(ifi->active)) {
		ifi->state = S_INIT;
		state_init(ifi);
		return;
	}

	ifi->xid = arc4random();
	make_request(ifi, ifi->active);

	ifi->destination.s_addr = INADDR_BROADCAST;
	time(&ifi->first_sending);
	ifi->interval = 0;

	send_request(ifi);
}

/*
 * Called when a lease has completely expired and we've been unable to
 * renew it.
 */
void
state_init(struct interface_info *ifi)
{
	ifi->xid = arc4random();
	make_discover(ifi, ifi->active);

	ifi->destination.s_addr = INADDR_BROADCAST;
	ifi->state = S_SELECTING;
	time(&ifi->first_sending);
	ifi->interval = 0;

	send_discover(ifi);
}

/*
 * Called when one or more DHCPOFFER packets have been received and a
 * configurable period of time has passed.
 */
void
state_selecting(struct interface_info *ifi)
{
	struct option_data	*option;

	cancel_timeout(ifi);

	if (ifi->offer == NULL) {
		state_panic(ifi);
		return;
	}

	/* If it was a BOOTREPLY, we can just take the lease right now. */
	if (BOOTP_LEASE(ifi->offer)) {
		/*
		 * Set (unsigned 32 bit) options
		 *
		 * DHO_DHCP_LEASE_TIME (12000 seconds),
		 * DHO_RENEWAL_TIME (8000 seconds)
		 * DHO_REBINDING_TIME (10000 seconds)
		 *
		 * so bind_lease() can set the lease times. Note that the
		 * values must be big-endian.
		 */
		option = &ifi->offer->options[DHO_DHCP_LEASE_TIME];
		option->data = malloc(4);
		if (option->data) {
			option->len = 4;
			memcpy(option->data, "\x00\x00\x2e\xe0", 4);
		}
		option = &ifi->offer->options[DHO_DHCP_RENEWAL_TIME];
		option->data = malloc(4);
		if (option->data) {
			option->len = 4;
			memcpy(option->data, "\x00\x00\x1f\x40", 4);
		}
		option = &ifi->offer->options[DHO_DHCP_REBINDING_TIME];
		option->data = malloc(4);
		if (option->data) {
			option->len = 4;
			memcpy(option->data, "\x00\x00\x27\x10", 4);
		}

		ifi->state = S_REQUESTING;
		bind_lease(ifi);

		return;
	}

	ifi->destination.s_addr = INADDR_BROADCAST;
	ifi->state = S_REQUESTING;
	time(&ifi->first_sending);

	ifi->interval = 0;

	/*
	 * Make a DHCPREQUEST packet from the lease we picked. Keep
	 * the current xid, as all offers should have had the same
	 * one.
	 */
	make_request(ifi, ifi->offer);

	/* Toss the lease we picked - we'll get it back in a DHCPACK. */
	free_client_lease(ifi->offer);

	send_request(ifi);
}

void
dhcpoffer(struct interface_info *ifi, struct option_data *options, char *info)
{
	struct client_lease	*lease;
	time_t			 stop_selecting;

	if (ifi->state != S_SELECTING) {
#ifdef DEBUG
		log_debug("Unexpected %s. State #%d.", info, ifi->state);
#endif	/* DEBUG */
		return;
	}

	log_info("%s", info);

	lease = packet_to_lease(ifi, options);
	if (lease != NULL) {
		if (ifi->offer == NULL) {
			ifi->offer = lease;
		} else if (lease->address.s_addr ==
		    ifi->requested_address.s_addr) {
			free_client_lease(ifi->offer);
			ifi->offer = lease;
		}
		if (ifi->offer != lease) {
			make_decline(ifi, lease);
			send_decline(ifi);
			free_client_lease(lease);
		}
	}

	/* Figure out when we're supposed to stop selecting. */
	stop_selecting = ifi->first_sending + config->select_interval;
	if (stop_selecting <= time(NULL))
		state_selecting(ifi);
	else
		set_timeout(ifi, stop_selecting, state_selecting);
}

void
dhcpack(struct interface_info *ifi, struct option_data *options, char *info)
{
	struct client_lease	*lease;

	if (ifi->state != S_REBOOTING &&
	    ifi->state != S_REQUESTING &&
	    ifi->state != S_RENEWING &&
	    ifi->state != S_REBINDING) {
#ifdef DEBUG
		log_debug("Unexpected %s. State #%d", info, ifi->state);
#endif	/* DEBUG */
		return;
	}

	log_info("%s", info);

	lease = packet_to_lease(ifi, options);
	if (lease == NULL) {
		ifi->state = S_INIT;
		state_init(ifi);
		return;
	}

	ifi->offer = lease;
	memcpy(ifi->offer->ssid, ifi->ssid, sizeof(ifi->offer->ssid));
	ifi->offer->ssid_len = ifi->ssid_len;

	/* Stop resending DHCPREQUEST. */
	cancel_timeout(ifi);

	bind_lease(ifi);
}

void
dhcpnak(struct interface_info *ifi, struct option_data *options, char *info)
{
	if (ifi->state != S_REBOOTING &&
	    ifi->state != S_REQUESTING &&
	    ifi->state != S_RENEWING &&
	    ifi->state != S_REBINDING) {
#ifdef DEBUG
		log_debug("Unexpected %s. State #%d", info, ifi->state);
#endif	/* DEBUG */
		return;
	}

	if (ifi->active == NULL) {
#ifdef DEBUG
		log_debug("Unexpected %s. No active lease.", info);
#endif	/* DEBUG */
		return;
	}

	log_info("%s", info);

	/* XXX Do we really want to remove a NAK'd lease from the database? */
	if (ifi->active->is_static == 0) {
		TAILQ_REMOVE(&ifi->leases, ifi->active, next);
		free_client_lease(ifi->active);
	}

	ifi->active = NULL;

	/* Stop sending DHCPREQUEST packets. */
	cancel_timeout(ifi);

	ifi->state = S_INIT;
	state_init(ifi);
}

void
bind_lease(struct interface_info *ifi)
{
	struct option_data	*options;
	struct client_lease	*lease, *pl;
	struct proposal		*active_proposal = NULL;
	struct proposal		*offered_proposal = NULL;
	struct proposal		*effective_proposal = NULL;
	time_t			 cur_time;
	int			 seen;

	/*
	 * Clear out any old resolv_conf in case the lease has been here
	 * before (e.g. static lease).
	 */
	free(ifi->offer->resolv_conf);
	ifi->offer->resolv_conf = NULL;

	lease = apply_defaults(ifi->offer);
	options = lease->options;

	set_lease_times(lease);

	ifi->offer->expiry = lease->expiry;
	ifi->offer->renewal = lease->renewal;
	ifi->offer->rebind = lease->rebind;

	/*
	 * A duplicate proposal once we are responsible & S_RENEWING means we
	 * don't need to change the interface, routing table or resolv.conf.
	 */
	if ((ifi->flags & IFI_IN_CHARGE) && ifi->state == S_RENEWING) {
		active_proposal = lease_as_proposal(ifi->active);
		offered_proposal = lease_as_proposal(ifi->offer);
		if (memcmp(active_proposal, offered_proposal,
		    sizeof(*active_proposal)) == 0) {
			ifi->offer->resolv_conf = ifi->active->resolv_conf;
			ifi->active->resolv_conf = NULL;
			ifi->active = ifi->offer;
			ifi->offer = NULL;
			goto newlease;
		}
	}

	ifi->offer->resolv_conf = resolv_conf_contents(ifi->name,
	    &options[DHO_DOMAIN_NAME], &options[DHO_DOMAIN_NAME_SERVERS],
	    &options[DHO_DOMAIN_SEARCH]);

	/* Replace the old active lease with the accepted offer. */
	ifi->active = ifi->offer;
	ifi->offer = NULL;

	set_mtu(&options[DHO_INTERFACE_MTU]);

	set_address(ifi->name, ifi->active->address, &options[DHO_SUBNET_MASK]);

	effective_proposal = lease_as_proposal(lease);
	set_routes(effective_proposal->ifa, effective_proposal->netmask,
	    effective_proposal->rtstatic, effective_proposal->rtstatic_len);

newlease:
	log_info("bound to %s -- renewal in %lld seconds.",
	    inet_ntoa(ifi->active->address),
	    (long long)(ifi->active->renewal - time(NULL)));
	go_daemon();
	rewrite_option_db(ifi->name, ifi->active, lease);
	free_client_lease(lease);
	free(active_proposal);
	free(offered_proposal);
	free(effective_proposal);

	/*
	 * Remove previous dynamic lease(es) for this address, and any expired
	 * dynamic leases.
	 */
	seen = 0;
	time(&cur_time);
	TAILQ_FOREACH_SAFE(lease, &ifi->leases, next, pl) {
		if (lease->is_static != 0)
			break;
		if (ifi->active == NULL)
			continue;
		if (ifi->active->ssid_len != lease->ssid_len)
			continue;
		if (memcmp(ifi->active->ssid, lease->ssid, lease->ssid_len)
		    != 0)
			continue;
		if (ifi->active == lease)
			seen = 1;
		else if (lease->expiry <= cur_time || lease->address.s_addr ==
		    ifi->active->address.s_addr) {
			TAILQ_REMOVE(&ifi->leases, lease, next);
			free_client_lease(lease);
		}
	}
	if (ifi->active->is_static == 0 && seen == 0)
		TAILQ_INSERT_HEAD(&ifi->leases, ifi->active,  next);

	/* Write out new leases file. */
	rewrite_client_leases(ifi);

	ifi->state = S_BOUND;

	/* Set timeout to start the renewal process. */
	set_timeout(ifi, ifi->active->renewal - cur_time, state_bound);
}

/*
 * Called when we've successfully bound to a particular lease, but the renewal
 * time on that lease has expired.  We are expected to unicast a DHCPREQUEST to
 * the server that gave us our original lease.
 */
void
state_bound(struct interface_info *ifi)
{
	struct option_data	*opt;
	struct in_addr		*dest;

	ifi->xid = arc4random();
	make_request(ifi, ifi->active);

	dest = &ifi->destination;
	opt = &ifi->active->options[DHO_DHCP_SERVER_IDENTIFIER];

	if (opt->len == sizeof(*dest))
		dest->s_addr = ((struct in_addr *)opt->data)->s_addr;
	else
		dest->s_addr = INADDR_BROADCAST;

	time(&ifi->first_sending);
	ifi->interval = 0;
	ifi->state = S_RENEWING;

	send_request(ifi);
}

int
addressinuse(char *name, struct in_addr address, char *ifname)
{
	struct ifaddrs		*ifap, *ifa;
	struct sockaddr_in	*sin;
	int			 used = 0;

	if (getifaddrs(&ifap) != 0) {
		log_warn("addressinuse: getifaddrs");
		return 0;
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr == NULL ||
		    ifa->ifa_addr->sa_family != AF_INET)
			continue;

		sin = (struct sockaddr_in *)ifa->ifa_addr;
		if (memcmp(&address, &sin->sin_addr, sizeof(address)) == 0) {
			strlcpy(ifname, ifa->ifa_name, IF_NAMESIZE);
			used = 1;
			if (strncmp(ifname, name, IF_NAMESIZE) != 0)
				break;
		}
	}

	freeifaddrs(ifap);
	return used;
}

/*
 * Allocate a client_lease structure and initialize it from the
 * parameters in the received packet.
 *
 * Return NULL and decline the lease if a valid lease cannot be
 * constructed.
 */
struct client_lease *
packet_to_lease(struct interface_info *ifi, struct option_data *options)
{
	char			 ifname[IF_NAMESIZE];
	struct dhcp_packet	*packet = &ifi->recv_packet;
	struct client_lease	*lease;
	char			*pretty, *buf, *name;
	int			 i;

	lease = calloc(1, sizeof(struct client_lease));
	if (lease == NULL) {
		log_warnx("lease declined: no memory for lease.");
		return NULL;
	}

	/* Copy the lease options. */
	for (i = 0; i < DHO_COUNT; i++) {
		if (options[i].len == 0)
			continue;
		name = code_to_name(i);
		if (unknown_ok == 0 && strncmp("option-", name, 7) != 0) {
			log_warnx("lease declined: unknown option %d", i);
			goto decline;
		}
		pretty = pretty_print_option(i, &options[i], 0);
		if (strlen(pretty) == 0)
			continue;
		switch (i) {
		case DHO_DOMAIN_SEARCH:
			/* Must decode the option into text to check names. */
			buf = pretty_print_domain_search(options[i].data,
			    options[i].len);
			if (buf == NULL || res_hnok_list(buf) == 0) {
				log_warnx("Ignoring %s in offer: invalid host "
				    "name(s)", name);
				continue;
			}
			break;
		case DHO_DOMAIN_NAME:
			/*
			 * Allow deviant but historically blessed
			 * practice of supplying multiple domain names
			 * with DHO_DOMAIN_NAME. Thus allowing multiple
			 * entries in the resolv.conf 'search' statement.
			 */
			if (res_hnok_list(pretty) == 0) {
				log_warnx("Ignoring %s in offer: invalid host "
				    "name(s)", name);
				continue;
			}
			break;
		case DHO_HOST_NAME:
		case DHO_NIS_DOMAIN:
			if (res_hnok(pretty) == 0) {
				log_warnx("Ignoring %s in offer: invalid host "
				    "name", name);
				continue;
			}
			break;
		default:
			break;
		}
		lease->options[i] = options[i];
		options[i].data = NULL;
		options[i].len = 0;
	}

	/*
	 * If this lease doesn't supply a required parameter, decline it.
	 */
	for (i = 0; i < config->required_option_count; i++) {
		if (lease->options[config->required_options[i]].len == 0) {
			name = code_to_name(i);
			log_warnx("lease declined: %s required but missing",
			    name);
			goto decline;
		}
	}

	/*
	 * If this lease is trying to sell us an address we are already
	 * using, decline it.
	 */
	lease->address.s_addr = packet->yiaddr.s_addr;
	memset(ifname, 0, sizeof(ifname));
	if (addressinuse(ifi->name, lease->address, ifname) != 0 &&
	    strncmp(ifname, ifi->name, IF_NAMESIZE) != 0) {
		log_warnx("lease declined: %s already configured on %s",
		    inet_ntoa(lease->address), ifname);
		goto decline;
	}

	/* Save the siaddr (a.k.a. next-server) info. */
	lease->next_server.s_addr = packet->siaddr.s_addr;

	/* If the server name was filled out, copy it. */
	if ((lease->options[DHO_DHCP_OPTION_OVERLOAD].len == 0 ||
	    (lease->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2) == 0) &&
	    packet->sname[0]) {
		lease->server_name = malloc(DHCP_SNAME_LEN + 1);
		if (lease->server_name == NULL) {
			log_warnx("lease declined:: no memory for SNAME.");
			goto decline;
		}
		memcpy(lease->server_name, packet->sname, DHCP_SNAME_LEN);
		lease->server_name[DHCP_SNAME_LEN] = '\0';
		if (res_hnok(lease->server_name) == 0) {
			log_warnx("lease declined: invalid host name in SNAME");
			goto decline;
		}
	}

	/* If the file name was filled out, copy it. */
	if ((lease->options[DHO_DHCP_OPTION_OVERLOAD].len == 0 ||
	    (lease->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1) == 0) &&
	    packet->file[0]) {
		/* Don't count on the NUL terminator. */
		lease->filename = malloc(DHCP_FILE_LEN + 1);
		if (lease->filename == NULL) {
			log_warnx("lease declined: no memory for filename.");
			goto decline;
		}
		memcpy(lease->filename, packet->file, DHCP_FILE_LEN);
		lease->filename[DHCP_FILE_LEN] = '\0';
	}
	return lease;

decline:
	make_decline(ifi, lease);
	send_decline(ifi);
	free_client_lease(lease);
	return NULL;
}

/*
 * Send out a DHCPDISCOVER packet, and set a timeout to send out another
 * one after the right interval has expired.  If we don't get an offer by
 * the time we reach the panic interval, call the panic function.
 */
void
send_discover(struct interface_info *ifi)
{
	struct dhcp_packet	*packet = &ifi->sent_packet;
	time_t			 cur_time;
	ssize_t			 rslt;
	int			 interval;

	time(&cur_time);

	/* Figure out how long it's been since we started transmitting. */
	interval = cur_time - ifi->first_sending;

	if (interval > config->timeout) {
		state_panic(ifi);
		return;
	}

	/*
	 * If we're supposed to increase the interval, do so.  If it's
	 * currently zero (i.e., we haven't sent any packets yet), set
	 * it to initial_interval; otherwise, add to it a random
	 * number between zero and two times itself.  On average, this
	 * means that it will double with every transmission.
	 */
	if (ifi->interval == 0)
		ifi->interval = config->initial_interval;
	else {
		ifi->interval += arc4random_uniform(2 * ifi->interval);
	}

	/* Don't backoff past cutoff. */
	if (ifi->interval > config->backoff_cutoff)
		ifi->interval = config->backoff_cutoff;

	/*
	 * If the backoff would take us to the panic timeout, just use that
	 * as the interval.
	 */
	if (cur_time + ifi->interval >
	    ifi->first_sending + config->timeout)
		ifi->interval = (ifi->first_sending +
		    config->timeout) - cur_time + 1;

	/* Record the number of seconds since we started sending. */
	if (interval < UINT16_MAX)
		packet->secs = htons(interval);
	else
		packet->secs = htons(UINT16_MAX);
	ifi->secs = packet->secs;

	log_info("DHCPDISCOVER on %s - interval %lld", ifi->name,
	    (long long)ifi->interval);

	rslt = send_packet(ifi, inaddr_any, inaddr_broadcast);
	if (rslt == -1 && errno == EAFNOSUPPORT) {
		log_warnx("dhclient cannot be used on %s", ifi->name);
		quit = INTERNALSIG;
	} else
		set_timeout(ifi, ifi->interval, send_discover);
}

/*
 * Called if we haven't received any offers in a preset amount of time. When
 * this happens, we try to use existing leases that haven't yet expired.
 */
void
state_panic(struct interface_info *ifi)
{
	log_info("No acceptable DHCPOFFERS received.");

	ifi->offer = get_recorded_lease(ifi);
	if (ifi->offer) {
		ifi->state = S_REQUESTING;
		bind_lease(ifi);
		return;
	}

	/*
	 * No leases were available, or what was available didn't work
	 */
	log_info("No working leases in persistent database - sleeping.");
	ifi->state = S_INIT;
	set_timeout(ifi, config->retry_interval, state_init);
	go_daemon();
}

void
send_request(struct interface_info *ifi)
{
	struct sockaddr_in	 destination;
	struct in_addr		 from;
	struct dhcp_packet	*packet = &ifi->sent_packet;
	time_t			 cur_time;
	int			 interval;

	time(&cur_time);

	/* Figure out how long it's been since we started transmitting. */
	interval = cur_time - ifi->first_sending;

	/*
	 * If we're in the INIT-REBOOT state and we've been trying longer
	 * than reboot_timeout, go to INIT state and DISCOVER an address.
	 *
	 * In the INIT-REBOOT state, if we don't get an ACK, it
	 * means either that we're on a network with no DHCP server,
	 * or that our server is down.  In the latter case, assuming
	 * that there is a backup DHCP server, DHCPDISCOVER will get
	 * us a new address, but we could also have successfully
	 * reused our old address.  In the former case, we're hosed
	 * anyway.  This is not a win-prone situation.
	 */
	if (ifi->state == S_REBOOTING && interval >
	    config->reboot_timeout) {
		ifi->state = S_INIT;
		cancel_timeout(ifi);
		state_init(ifi);
		return;
	}

	/*
	 * If the lease has expired, relinquish the address and go back to the
	 * INIT state.
	 */
	if (ifi->state != S_REQUESTING &&
	    cur_time > ifi->active->expiry) {
		if (ifi->active)
			delete_address(ifi->active->address);
		ifi->state = S_INIT;
		state_init(ifi);
		return;
	}

	/* Do the exponential backoff. */
	if (ifi->interval == 0) {
		if (ifi->state == S_REBOOTING)
			ifi->interval = config->reboot_timeout;
		else
			ifi->interval = config->initial_interval;
	} else
		ifi->interval += arc4random_uniform(2 * ifi->interval);

	/* Don't backoff past cutoff. */
	if (ifi->interval > config->backoff_cutoff)
		ifi->interval = config->backoff_cutoff;

	/*
	 * If the backoff would take us to the expiry time, just set the
	 * timeout to the expiry time.
	 */
	if (ifi->state != S_REQUESTING && cur_time + ifi->interval >
	    ifi->active->expiry)
		ifi->interval = ifi->active->expiry - cur_time + 1;

	/*
	 * If the reboot timeout has expired, or the lease rebind time has
	 * elapsed, or if we're not yet bound, broadcast the DHCPREQUEST rather
	 * than unicasting.
	 */
	memset(&destination, 0, sizeof(destination));
	if (ifi->state == S_REQUESTING ||
	    ifi->state == S_REBOOTING ||
	    cur_time > ifi->active->rebind ||
	    interval > config->reboot_timeout)
		destination.sin_addr.s_addr = INADDR_BROADCAST;
	else
		destination.sin_addr.s_addr = ifi->destination.s_addr;

	if (ifi->state != S_REQUESTING)
		from.s_addr = ifi->active->address.s_addr;
	else
		from.s_addr = INADDR_ANY;

	/* Record the number of seconds since we started sending. */
	if (ifi->state == S_REQUESTING)
		packet->secs = ifi->secs;
	else {
		if (interval < UINT16_MAX)
			packet->secs = htons(interval);
		else
			packet->secs = htons(UINT16_MAX);
	}

	log_info("DHCPREQUEST on %s to %s", ifi->name,
	    inet_ntoa(destination.sin_addr));

	send_packet(ifi, from, destination.sin_addr);

	set_timeout(ifi, ifi->interval, send_request);
}

void
send_decline(struct interface_info *ifi)
{
	log_info("DHCPDECLINE on %s", ifi->name);

	send_packet(ifi, inaddr_any, inaddr_broadcast);
}

void
make_discover(struct interface_info *ifi, struct client_lease *lease)
{
	struct option_data	 options[DHO_COUNT];
	struct dhcp_packet	*packet = &ifi->sent_packet;
	unsigned char		 discover = DHCPDISCOVER;
	int			 i;

	memset(options, 0, sizeof(options));
	memset(packet, 0, sizeof(*packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPDISCOVER */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i].data = &discover;
	options[i].len = sizeof(discover);

	/* Request the options we want */
	i  = DHO_DHCP_PARAMETER_REQUEST_LIST;
	options[i].data = config->requested_options;
	options[i].len = config->requested_option_count;

	/* If we had an address, try to get it again. */
	if (lease != NULL) {
		ifi->requested_address = lease->address;
		i = DHO_DHCP_REQUESTED_ADDRESS;
		options[i].data = (char *)&lease->address;
		options[i].len = sizeof(lease->address);
	} else
		ifi->requested_address.s_addr = INADDR_ANY;

	/* Send any options requested in the config file. */
	for (i = 0; i < DHO_COUNT; i++)
		if (options[i].data == NULL &&
		    config->send_options[i].data != NULL) {
			options[i].data = config->send_options[i].data;
			options[i].len = config->send_options[i].len;
		}

	/*
	 * Set up the option buffer to fit in a 576-byte UDP packet, which
	 * RFC 791 says is the largest packet that *MUST* be accepted
	 * by any host.
	 */
	i = pack_options(ifi->sent_packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || packet->options[i] != DHO_END)
		fatalx("options do not fit in DHCPDISCOVER packet.");
	ifi->sent_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ifi->sent_packet_length < BOOTP_MIN_LEN)
		ifi->sent_packet_length = BOOTP_MIN_LEN;

	packet->op = BOOTREQUEST;
	packet->htype = HTYPE_ETHER ;
	packet->hlen = ETHER_ADDR_LEN;
	packet->hops = 0;
	packet->xid = ifi->xid;
	packet->secs = 0; /* filled in by send_discover. */
	packet->flags = 0;

	packet->ciaddr.s_addr = INADDR_ANY;
	packet->yiaddr.s_addr = INADDR_ANY;
	packet->siaddr.s_addr = INADDR_ANY;
	packet->giaddr.s_addr = INADDR_ANY;

	memcpy(&packet->chaddr, ifi->hw_address.ether_addr_octet,
	    ETHER_ADDR_LEN);
}

void
make_request(struct interface_info *ifi, struct client_lease * lease)
{
	struct option_data	 options[DHO_COUNT];
	struct dhcp_packet	*packet = &ifi->sent_packet;
	unsigned char		 request = DHCPREQUEST;
	int			 i;

	memset(options, 0, sizeof(options));
	memset(packet, 0, sizeof(*packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPREQUEST */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i].data = &request;
	options[i].len = sizeof(request);

	/* Request the options we want */
	i = DHO_DHCP_PARAMETER_REQUEST_LIST;
	options[i].data = config->requested_options;
	options[i].len = config->requested_option_count;

	/*
	 * If we are requesting an address that hasn't yet been assigned
	 * to us, use the DHCP Requested Address option.
	 */
	if (ifi->state == S_REQUESTING) {
		/* Send back the server identifier. */
		i = DHO_DHCP_SERVER_IDENTIFIER;
		options[i].data = lease->options[i].data;
		options[i].len = lease->options[i].len;
	}
	if (ifi->state == S_REQUESTING ||
	    ifi->state == S_REBOOTING) {
		ifi->requested_address = lease->address;
		i = DHO_DHCP_REQUESTED_ADDRESS;
		options[i].data = (char *)&lease->address.s_addr;
		options[i].len = sizeof(in_addr_t);
	}

	/* Send any options requested in the config file. */
	for (i = 0; i < DHO_COUNT; i++)
		if (options[i].data == NULL &&
		    config->send_options[i].data != NULL) {
			options[i].data = config->send_options[i].data;
			options[i].len = config->send_options[i].len;
		}

	/*
	 * Set up the option buffer to fit in a 576-byte UDP packet, which
	 * RFC 791 says is the largest packet that *MUST* be accepted
	 * by any host.
	 */
	i = pack_options(ifi->sent_packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || packet->options[i] != DHO_END)
		fatalx("options do not fit in DHCPREQUEST packet.");
	ifi->sent_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ifi->sent_packet_length < BOOTP_MIN_LEN)
		ifi->sent_packet_length = BOOTP_MIN_LEN;

	packet->op = BOOTREQUEST;
	packet->htype = HTYPE_ETHER ;
	packet->hlen = ETHER_ADDR_LEN;
	packet->hops = 0;
	packet->xid = ifi->xid;
	packet->secs = 0; /* Filled in by send_request. */
	packet->flags = 0;

	/*
	 * If we own the address we're requesting, put it in ciaddr. Otherwise
	 * set ciaddr to zero.
	 */
	if (ifi->state == S_BOUND ||
	    ifi->state == S_RENEWING ||
	    ifi->state == S_REBINDING)
		packet->ciaddr.s_addr = lease->address.s_addr;
	else
		packet->ciaddr.s_addr = INADDR_ANY;

	packet->yiaddr.s_addr = INADDR_ANY;
	packet->siaddr.s_addr = INADDR_ANY;
	packet->giaddr.s_addr = INADDR_ANY;

	memcpy(&packet->chaddr, ifi->hw_address.ether_addr_octet,
	    ETHER_ADDR_LEN);
}

void
make_decline(struct interface_info *ifi, struct client_lease *lease)
{
	struct option_data	 options[DHO_COUNT];
	struct dhcp_packet	*packet = &ifi->sent_packet;
	unsigned char		 decline = DHCPDECLINE;
	int			 i;

	memset(options, 0, sizeof(options));
	memset(packet, 0, sizeof(*packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPDECLINE */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i].data = &decline;
	options[i].len = sizeof(decline);

	/* Send back the server identifier. */
	i = DHO_DHCP_SERVER_IDENTIFIER;
	options[i].data = lease->options[i].data;
	options[i].len = lease->options[i].len;

	/* Send back the address we're declining. */
	i = DHO_DHCP_REQUESTED_ADDRESS;
	options[i].data = (char *)&lease->address.s_addr;
	options[i].len = sizeof(in_addr_t);

	/* Send the uid if the user supplied one. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (config->send_options[i].len != 0) {
		options[i].data = config->send_options[i].data;
		options[i].len = config->send_options[i].len;
	}

	/*
	 * Set up the option buffer to fit in a 576-byte UDP packet, which
	 * RFC 791 says is the largest packet that *MUST* be accepted
	 * by any host.
	 */
	i = pack_options(ifi->sent_packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || packet->options[i] != DHO_END)
		fatalx("options do not fit in DHCPDECLINE packet.");
	ifi->sent_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ifi->sent_packet_length < BOOTP_MIN_LEN)
		ifi->sent_packet_length = BOOTP_MIN_LEN;

	packet->op = BOOTREQUEST;
	packet->htype = HTYPE_ETHER ;
	packet->hlen = ETHER_ADDR_LEN;
	packet->hops = 0;
	packet->xid = ifi->xid;
	packet->secs = 0;
	packet->flags = 0;

	/* ciaddr must always be zero. */
	packet->ciaddr.s_addr = INADDR_ANY;
	packet->yiaddr.s_addr = INADDR_ANY;
	packet->siaddr.s_addr = INADDR_ANY;
	packet->giaddr.s_addr = INADDR_ANY;

	memcpy(&packet->chaddr, ifi->hw_address.ether_addr_octet,
	    ETHER_ADDR_LEN);
}

void
free_client_lease(struct client_lease *lease)
{
	int	 i;

	/* Static leases are forever. */
	if (lease == NULL || lease->is_static)
		return;

	free(lease->server_name);
	free(lease->filename);
	free(lease->resolv_conf);
	for (i = 0; i < DHO_COUNT; i++)
		free(lease->options[i].data);

	free(lease);
}

void
rewrite_client_leases(struct interface_info *ifi)
{
	struct client_lease	*lp;
	char			*leasestr;
	time_t			 cur_time;

	if (leaseFile == NULL)
		fatalx("lease file not open");

	rewind(leaseFile);

	/*
	 * The leases file is kept in chronological order, with the
	 * most recently bound lease last. When the file was read
	 * leases that were not expired were added to the head of the
	 * TAILQ ifi->leases as they were read. Therefore write out
	 * the leases in ifi->leases in reverse order to recreate
	 * the chonological order required.
	 */
	time(&cur_time);
	TAILQ_FOREACH_REVERSE(lp, &ifi->leases, client_lease_tq, next) {
		/* Don't write out static leases from dhclient.conf. */
		if (lp->is_static != 0)
			continue;
		if (lp->expiry <= cur_time)
			continue;
		leasestr = lease_as_string(ifi->name, "lease", lp);
		if (leasestr != NULL)
			fprintf(leaseFile, "%s", leasestr);
		else
			log_warnx("cannot make lease into string");
	}

	fflush(leaseFile);
	ftruncate(fileno(leaseFile), ftello(leaseFile));
	fsync(fileno(leaseFile));
}

void
rewrite_option_db(char *name, struct client_lease *offered,
    struct client_lease *effective)
{
	char	*leasestr;

	if (optionDB == NULL)
		return;

	rewind(optionDB);

	leasestr = lease_as_string(name, "offered", offered);
	if (leasestr != NULL)
		fprintf(optionDB, "%s", leasestr);
	else
		log_warnx("cannot make offered lease into string");

	leasestr = lease_as_string(name, "effective", effective);
	if (leasestr != NULL)
		fprintf(optionDB, "%s", leasestr);
	else
		log_warnx("cannot make effective lease into string");

	fflush(optionDB);
	ftruncate(fileno(optionDB), ftello(optionDB));
	fsync(fileno(optionDB));
}

void
append_statement(char *string, size_t sz, char *s1, char *s2)
{
	strlcat(string, s1, sz);
	strlcat(string, s2, sz);
	strlcat(string, ";\n", sz);
}

struct proposal *
lease_as_proposal(struct client_lease *lease)
{
	struct proposal		*proposal;
	struct option_data	*opt;
	char			*buf;

	proposal = calloc(1, sizeof(*proposal));
	if (proposal == NULL)
		fatal("No memory for lease_as_proposal");

	proposal->ifa = lease->address;
	proposal->addrs |= RTA_IFA;

	opt = &lease->options[DHO_INTERFACE_MTU];
	if (opt->len == sizeof(uint16_t)) {
		memcpy(&proposal->mtu, opt->data, sizeof(proposal->mtu));
		proposal->mtu = ntohs(proposal->mtu);
		proposal->inits |= RTV_MTU;
	}

	opt = &lease->options[DHO_SUBNET_MASK];
	if (opt->len == sizeof(proposal->netmask)) {
		proposal->addrs |= RTA_NETMASK;
		proposal->netmask.s_addr = ((struct in_addr *)opt->data)->s_addr;
	}

	if (lease->options[DHO_CLASSLESS_STATIC_ROUTES].len != 0) {
		opt = &lease->options[DHO_CLASSLESS_STATIC_ROUTES];
		/* XXX */
		if (opt->len < sizeof(proposal->rtstatic)) {
			proposal->rtstatic_len = opt->len;
			memcpy(&proposal->rtstatic, opt->data, opt->len);
			proposal->addrs |= RTA_STATIC;
		} else
			log_warnx("CLASSLESS_STATIC_ROUTES too long");
	} else if (lease->options[DHO_CLASSLESS_MS_STATIC_ROUTES].len != 0) {
		opt = &lease->options[DHO_CLASSLESS_MS_STATIC_ROUTES];
		/* XXX */
		if (opt->len < sizeof(proposal->rtstatic)) {
			proposal->rtstatic_len = opt->len;
			memcpy(&proposal->rtstatic[1], opt->data, opt->len);
			proposal->addrs |= RTA_STATIC;
		} else
			log_warnx("MS_CLASSLESS_STATIC_ROUTES too long");
	} else {
		opt = &lease->options[DHO_ROUTERS];
		if (opt->len >= sizeof(struct in_addr)) {
			proposal->rtstatic_len = 1 + sizeof(struct in_addr);
			proposal->rtstatic[0] = 0;
			memcpy(&proposal->rtstatic[1], opt->data,
			    sizeof(struct in_addr));
			proposal->addrs |= RTA_STATIC;
		}
	}

	if (lease->options[DHO_DOMAIN_SEARCH].len != 0) {
		opt = &lease->options[DHO_DOMAIN_SEARCH];
		buf = pretty_print_domain_search(opt->data, opt->len);
		if (buf == NULL )
			log_warnx("DOMAIN_SEARCH too long");
		else {
			proposal->rtsearch_len = strlen(buf);
			memcpy(proposal->rtsearch, buf, proposal->rtsearch_len);
			proposal->addrs |= RTA_SEARCH;
		}
	} else if (lease->options[DHO_DOMAIN_NAME].len != 0) {
		opt = &lease->options[DHO_DOMAIN_NAME];
		if (opt->len < sizeof(proposal->rtsearch)) {
			proposal->rtsearch_len = opt->len;
			memcpy(proposal->rtsearch, opt->data, opt->len);
			proposal->addrs |= RTA_SEARCH;
		} else
			log_warnx("DOMAIN_NAME too long");
	}
	if (lease->options[DHO_DOMAIN_NAME_SERVERS].len != 0) {
		int servers;
		opt = &lease->options[DHO_DOMAIN_NAME_SERVERS];
		servers = opt->len / sizeof(struct in_addr);
		if (servers > MAXNS)
			servers = MAXNS;
		if (servers > 0) {
			proposal->addrs |= RTA_DNS;
			proposal->rtdns_len = opt->len;
			memcpy(proposal->rtdns, opt->data, opt->len);
		}
	}

	return proposal;
}

char *
lease_as_string(char *ifname, char *type, struct client_lease *lease)
{
	static char		 string[8192];
	char			 timebuf[27];	/* 6 2017/04/08 05:47:50 UTC; */
	struct option_data	*opt;
	char			*buf, *name;
	size_t			 rslt;
	int			 i;

	memset(string, 0, sizeof(string));

	strlcat(string, type, sizeof(string));
	strlcat(string, " {\n", sizeof(string));
	strlcat(string, BOOTP_LEASE(lease) ? "  bootp;\n" : "", sizeof(string));

	buf = pretty_print_string(ifname, strlen(ifname), 1);
	if (buf == NULL)
		return NULL;
	append_statement(string, sizeof(string), "  interface ", buf);

	append_statement(string, sizeof(string), "  fixed-address ",
	    inet_ntoa(lease->address));
	append_statement(string, sizeof(string), "  next-server ",
	    inet_ntoa(lease->next_server));

	if (lease->filename != NULL) {
		buf = pretty_print_string(lease->filename,
		    strlen(lease->filename), 1);
		if (buf == NULL)
			return NULL;
		append_statement(string, sizeof(string), "  filename ", buf);
	}
	if (lease->server_name != NULL) {
		buf = pretty_print_string(lease->server_name,
		    strlen(lease->server_name), 1);
		if (buf == NULL)
			return NULL;
		append_statement(string, sizeof(string), "  server-name ",
		    buf);
	}
	if (lease->ssid_len != 0) {
		buf = pretty_print_string(lease->ssid, lease->ssid_len, 1);
		if (buf == NULL)
			return NULL;
		append_statement(string, sizeof(string), "  ssid ", buf);
	}

	for (i = 0; i < DHO_COUNT; i++) {
		opt = &lease->options[i];
		if (opt->len == 0)
			continue;
		name = code_to_name(i);

		buf = pretty_print_option(i, opt, 1);
		if (buf == NULL)
			return NULL;
		strlcat(string, "  option ", sizeof(string));
		strlcat(string, name, sizeof(string));
		append_statement(string, sizeof(string), " ", buf);
	}

	rslt = strftime(timebuf, sizeof(timebuf), DB_TIMEFMT,
	    gmtime(&lease->renewal));
	if (rslt == 0)
		return NULL;
	append_statement(string, sizeof(string), "  renew ", timebuf);

	rslt = strftime(timebuf, sizeof(timebuf), DB_TIMEFMT,
	    gmtime(&lease->rebind));
	if (rslt == 0)
		return NULL;
	append_statement(string, sizeof(string), "  rebind ", timebuf);

	rslt = strftime(timebuf, sizeof(timebuf), DB_TIMEFMT,
	    gmtime(&lease->expiry));
	if (rslt == 0)
		return NULL;
	append_statement(string, sizeof(string), "  expire ", timebuf);

	rslt = strlcat(string, "}\n", sizeof(string));
	if (rslt >= sizeof(string))
		return NULL;

	return  string ;
}

void
go_daemon(void)
{
	static int	 state = 0;

	if (daemonize == 0 || state != 0)
		return;

	state = 1;

	/* Stop logging to stderr. */
	log_perror = 0;
	log_init(0, LOG_DAEMON);
	log_setverbose(0);

	if (rdaemon(nullfd) == -1)
		fatal("Cannot daemonize");

	signal(SIGHUP, sighdlr);
	signal(SIGPIPE, SIG_IGN);
}

int
rdaemon(int devnull)
{
	if (devnull == -1) {
		errno = EBADF;
		return -1;
	}
	if (fcntl(devnull, F_GETFL) == -1)
		return -1;

	switch (fork()) {
	case -1:
		return -1;
	case 0:
		break;
	default:
		_exit(0);
	}

	if (setsid() == -1)
		return -1;

	(void)dup2(devnull, STDIN_FILENO);
	(void)dup2(devnull, STDOUT_FILENO);
	(void)dup2(devnull, STDERR_FILENO);
	if (devnull > 2)
		(void)close(devnull);

	return 0;
}

int
res_hnok(const char *name)
{
	const char	*dn = name;
	int		 pch = '.', ch = (unsigned char)*dn++;
	int		 warn = 0;

	while (ch != '\0') {
		int nch = (unsigned char)*dn++;

		if (ch == '.') {
			;
		} else if (pch == '.' || nch == '.' || nch == '\0') {
			if (isalnum(ch) == 0)
				return 0;
		} else if (isalnum(ch) == 0 && ch != '-' && ch != '_') {
			return 0;
		} else if (ch == '_' && warn == 0) {
			log_warnx("warning: hostname %s contains an "
			    "underscore which violates RFC 952", name);
			warn++;
		}
		pch = ch, ch = nch;
	}
	return 1;
}

/*
 * resolv_conf(5) says a max of DHCP_DOMAIN_SEARCH_CNT domains and total
 * length of DHCP_DOMAIN_SEARCH_LEN bytes are acceptable for the 'search'
 * statement.
 */
int
res_hnok_list(const char *names)
{
	char	*dupnames, *hn, *inputstring;
	int	 count;

	if (strlen(names) >= DHCP_DOMAIN_SEARCH_LEN)
		return 0;

	dupnames = inputstring = strdup(names);
	if (inputstring == NULL)
		fatalx("Cannot copy domain name list");

	count = 0;
	while ((hn = strsep(&inputstring, " \t")) != NULL) {
		if (strlen(hn) == 0)
			continue;
		if (res_hnok(hn) == 0)
			break;
		count++;
		if (count > DHCP_DOMAIN_SEARCH_CNT)
			break;
	}

	free(dupnames);

	return count > 0 && count < 7 && hn == NULL;
}

void
fork_privchld(struct interface_info *ifi, int fd, int fd2)
{
	struct pollfd	 pfd[1];
	struct imsgbuf	*priv_ibuf;
	ssize_t		 n;
	int		 ioctlfd, routefd, nfds, got_imsg_hup = 0;

	switch (fork()) {
	case -1:
		fatalx("cannot fork");
		break;
	case 0:
		break;
	default:
		return;
	}

	if (chdir("/") == -1)
		fatalx("chdir(\"/\")");

	setproctitle("%s [priv]", ifi->name);

	go_daemon();

	close(fd2);

	if ((priv_ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		fatalx("no memory for priv_ibuf");

	imsg_init(priv_ibuf, fd);

	if ((ioctlfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("socket open failed");
	if ((routefd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		fatal("opening socket to flush routes");

	while (quit == 0) {
		pfd[0].fd = priv_ibuf->fd;
		pfd[0].events = POLLIN;
		if ((nfds = poll(pfd, 1, INFTIM)) == -1) {
			if (errno != EINTR) {
				log_warn("poll error");
				quit = INTERNALSIG;
			}
			continue;
		}

		if (nfds == 0 || (pfd[0].revents & POLLIN) == 0)
			continue;

		if ((n = imsg_read(priv_ibuf)) == -1 && errno != EAGAIN) {
			log_warn("imsg_read(priv_ibuf)");
			quit = INTERNALSIG;
			continue;
		}

		if (n == 0) {
			/* Connection closed - other end should log message. */
			quit = INTERNALSIG;
			continue;
		}

		got_imsg_hup = dispatch_imsg(ifi->name, ifi->rdomain, ioctlfd,
		    routefd, priv_ibuf);
		if (got_imsg_hup != 0)
			quit = SIGHUP;
	}
	close(routefd);
	close(ioctlfd);

	imsg_clear(priv_ibuf);
	close(fd);

	if (quit == SIGHUP) {
		if (got_imsg_hup == 0)
			log_warnx("%s; restarting.", strsignal(quit));
		signal(SIGHUP, SIG_IGN); /* will be restored after exec */
		execvp(saved_argv[0], saved_argv);
		fatal("RESTART FAILED: '%s'", saved_argv[0]);
	}

	if (quit != INTERNALSIG)
		fatalx("%s", strsignal(quit));

	exit(1);
}

void
get_ifname(struct interface_info *ifi, int ioctlfd, char *arg)
{
	struct ifgroupreq	 ifgr;
	struct ifg_req		*ifg;
	unsigned int		 len;

	if (strcmp(arg, "egress") == 0) {
		memset(&ifgr, 0, sizeof(ifgr));
		strlcpy(ifgr.ifgr_name, "egress", sizeof(ifgr.ifgr_name));
		if (ioctl(ioctlfd, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
			if (errno == ENOENT)
				fatalx("no interface in group egress found");
			fatal("ioctl SIOCGIFGMEMB");
		}
		len = ifgr.ifgr_len;
		if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
			fatalx("get_ifname");
		if (ioctl(ioctlfd, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
			fatal("ioctl SIOCGIFGMEMB");

		arg = NULL;
		for (ifg = ifgr.ifgr_groups;
		    ifg && len >= sizeof(struct ifg_req); ifg++) {
			len -= sizeof(struct ifg_req);
			if (arg != NULL)
				fatalx("too many interfaces in group egress");
			arg = ifg->ifgrq_member;
		}

		if (strlcpy(ifi->name, arg, IFNAMSIZ) >= IFNAMSIZ)
			fatal("Interface name too long");

		free(ifgr.ifgr_groups);
	} else if (strlcpy(ifi->name, arg, IFNAMSIZ) >= IFNAMSIZ)
		fatalx("Interface name too long");
}

struct client_lease *
apply_defaults(struct client_lease *lease)
{
	struct client_lease	*newlease;
	int			 i, j;

	newlease = clone_lease(lease);
	if (newlease == NULL)
		fatalx("Unable to clone lease");

	if (config->filename != NULL) {
		free(newlease->filename);
		newlease->filename = strdup(config->filename);
	}
	if (config->server_name != NULL) {
		free(newlease->server_name);
		newlease->server_name = strdup(config->server_name);
	}
	if (config->address.s_addr != INADDR_ANY)
		newlease->address.s_addr = config->address.s_addr;
	if (config->next_server.s_addr != INADDR_ANY)
		newlease->next_server.s_addr = config->next_server.s_addr;

	for (i = 0; i < DHO_COUNT; i++) {
		for (j = 0; j < config->ignored_option_count; j++) {
			if (config->ignored_options[j] == i) {
				free(newlease->options[i].data);
				newlease->options[i].data = NULL;
				newlease->options[i].len = 0;
				break;
			}
		}
		if (j < config->ignored_option_count)
			continue;

		switch (config->default_actions[i]) {
		case ACTION_SUPERSEDE:
			free(newlease->options[i].data);
			newlease->options[i].len = config->defaults[i].len;
			newlease->options[i].data = calloc(1,
			    config->defaults[i].len);
			if (newlease->options[i].data == NULL)
				goto cleanup;
			memcpy(newlease->options[i].data,
			    config->defaults[i].data, config->defaults[i].len);
			break;

		case ACTION_PREPEND:
			free(newlease->options[i].data);
			newlease->options[i].len = config->defaults[i].len +
			    lease->options[i].len;
			newlease->options[i].data = calloc(1,
			    newlease->options[i].len);
			if (newlease->options[i].data == NULL)
				goto cleanup;
			memcpy(newlease->options[i].data,
			    config->defaults[i].data, config->defaults[i].len);
			memcpy(newlease->options[i].data +
			    config->defaults[i].len, lease->options[i].data,
			    lease->options[i].len);
			break;

		case ACTION_APPEND:
			free(newlease->options[i].data);
			newlease->options[i].len = config->defaults[i].len +
			    lease->options[i].len;
			newlease->options[i].data = calloc(1,
			    newlease->options[i].len);
			if (newlease->options[i].data == NULL)
				goto cleanup;
			memcpy(newlease->options[i].data,
			    lease->options[i].data, lease->options[i].len);
			memcpy(newlease->options[i].data +
			    lease->options[i].len, config->defaults[i].data,
			    config->defaults[i].len);
			break;

		case ACTION_DEFAULT:
			if ((newlease->options[i].len == 0) &&
			    (config->defaults[i].len != 0)) {
				newlease->options[i].len =
				    config->defaults[i].len;
				newlease->options[i].data = calloc(1,
				    config->defaults[i].len);
				if (newlease->options[i].data == NULL)
					goto cleanup;
				memcpy(newlease->options[i].data,
				    config->defaults[i].data,
				    config->defaults[i].len);
			}
			break;

		default:
			break;
		}
	}

	if (newlease->options[DHO_STATIC_ROUTES].len != 0) {
		log_warnx("DHO_STATIC_ROUTES (option 33) not supported");
		free(newlease->options[DHO_STATIC_ROUTES].data);
		newlease->options[DHO_STATIC_ROUTES].data = NULL;
		newlease->options[DHO_STATIC_ROUTES].len = 0;
	}

	/*
	 * RFC 3442 says client *MUST* ignore DHO_ROUTERS
	 * when DHO_CLASSLESS_[MS_]_ROUTES present.
	 */
	if ((newlease->options[DHO_CLASSLESS_MS_STATIC_ROUTES].len != 0) ||
	    (newlease->options[DHO_CLASSLESS_STATIC_ROUTES].len != 0)) {
		free(newlease->options[DHO_ROUTERS].data);
		newlease->options[DHO_ROUTERS].data = NULL;
		newlease->options[DHO_ROUTERS].len = 0;
	}

	return newlease;

cleanup:
	if (newlease != NULL) {
		newlease->is_static = 0;
		free_client_lease(newlease);
	}

	fatalx("Unable to apply defaults");
	/* NOTREACHED */

	return NULL;
}

struct client_lease *
clone_lease(struct client_lease *oldlease)
{
	struct client_lease	*newlease;
	int			 i;

	newlease = calloc(1, sizeof(struct client_lease));
	if (newlease == NULL)
		goto cleanup;

	newlease->expiry = oldlease->expiry;
	newlease->renewal = oldlease->renewal;
	newlease->rebind = oldlease->rebind;
	newlease->is_static = oldlease->is_static;
	newlease->address = oldlease->address;
	newlease->next_server = oldlease->next_server;
	memcpy(newlease->ssid, oldlease->ssid, sizeof(newlease->ssid));
	newlease->ssid_len = oldlease->ssid_len;

	if (oldlease->server_name != NULL) {
		newlease->server_name = strdup(oldlease->server_name);
		if (newlease->server_name == NULL)
			goto cleanup;
	}
	if (oldlease->filename != NULL) {
		newlease->filename = strdup(oldlease->filename);
		if (newlease->filename == NULL)
			goto cleanup;
	}
	if (oldlease->resolv_conf != NULL) {
		newlease->resolv_conf = strdup(oldlease->resolv_conf);
		if (newlease->resolv_conf == NULL)
			goto cleanup;
	}

	for (i = 0; i < DHO_COUNT; i++) {
		if (oldlease->options[i].len == 0)
			continue;
		newlease->options[i].len = oldlease->options[i].len;
		newlease->options[i].data = calloc(1,
		    newlease->options[i].len);
		if (newlease->options[i].data == NULL)
			goto cleanup;
		memcpy(newlease->options[i].data, oldlease->options[i].data,
		    newlease->options[i].len);
	}

	return newlease;

cleanup:
	if (newlease != NULL) {
		newlease->is_static = 0;
		free_client_lease(newlease);
	}

	return NULL;
}

/*
 * Apply the list of options to be ignored that was provided on the
 * command line. This will override any ignore list obtained from
 * dhclient.conf.
 */
void
apply_ignore_list(char *ignore_list)
{
	uint8_t		 list[DHO_COUNT];
	char		*p;
	int		 ix, i, j;

	memset(list, 0, sizeof(list));
	ix = 0;

	for (p = strsep(&ignore_list, ", "); p != NULL;
	    p = strsep(&ignore_list, ", ")) {
		if (*p == '\0')
			continue;

		i = name_to_code(p);
		if (i == DHO_END) {
			log_info("Invalid option name: '%s'", p);
			return;
		}

		/* Avoid storing duplicate options in the list. */
		for (j = 0; j < ix && list[j] != i; j++)
			;
		if (j == ix)
			list[ix++] = i;
	}

	config->ignored_option_count = ix;
	memcpy(config->ignored_options, list, sizeof(config->ignored_options));
}

void
set_lease_times(struct client_lease *lease)
{
	time_t		 cur_time, time_max;
	uint32_t	 uint32val;

	time(&cur_time);

	time_max = LLONG_MAX - cur_time;
	if (time_max > UINT32_MAX)
		time_max = UINT32_MAX;

	/*
	 * Take the server-provided times if available.  Otherwise
	 * figure them out according to the spec.
	 *
	 * expiry  == time to discard lease.
	 * renewal == time to renew lease from server that provided it.
	 * rebind  == time to renew lease from any server.
	 *
	 * 0 <= renewal <= rebind <= expiry <= time_max
	 * &&
	 * expiry >= MIN(time_max, 60)
	 */

	lease->expiry = 43200;	/* Default to 12 hours */
	if (lease->options[DHO_DHCP_LEASE_TIME].len == sizeof(uint32val)) {
		memcpy(&uint32val, lease->options[DHO_DHCP_LEASE_TIME].data,
		    sizeof(uint32val));
		lease->expiry = ntohl(uint32val);
		if (lease->expiry < 60)
			lease->expiry = 60;
	}
	if (lease->expiry > time_max)
		lease->expiry = time_max;

	lease->renewal = lease->expiry / 2;
	if (lease->options[DHO_DHCP_RENEWAL_TIME].len == sizeof(uint32val)) {
		memcpy(&uint32val, lease->options[DHO_DHCP_RENEWAL_TIME].data,
		    sizeof(uint32val));
		lease->renewal = ntohl(uint32val);
		if (lease->renewal > lease->expiry)
			lease->renewal = lease->expiry;
	}

	lease->rebind = (lease->expiry * 7) / 8;
	if (lease->options[DHO_DHCP_REBINDING_TIME].len == sizeof(uint32val)) {
		memcpy(&uint32val,
		    lease->options[DHO_DHCP_REBINDING_TIME].data,
		    sizeof(uint32val));
		lease->rebind = ntohl(uint32val);
		if (lease->rebind > lease->expiry)
			lease->rebind = lease->expiry;
	}
	if (lease->rebind < lease->renewal)
		lease->rebind = lease->renewal;

	/* Convert lease lengths to times. */
	lease->expiry += cur_time;
	lease->renewal += cur_time;
	lease->rebind += cur_time;
}

void
take_charge(struct interface_info *ifi, int routefd)
{
	struct pollfd		 fds[1];
	struct rt_msghdr	 rtm;
	time_t			 start_time, cur_time;
	int			 retries;

	if (time(&start_time) == -1)
		fatal("time");

	/*
	 * Send RTM_PROPOSAL with RTF_PROTO3 set.
	 *
	 * When it comes back, we're in charge and other dhclients are
	 * dead processes walking.
	 */
	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_PROPOSAL;
	rtm.rtm_msglen = sizeof(rtm);
	rtm.rtm_tableid = ifi->rdomain;
	rtm.rtm_index = ifi->index;
	rtm.rtm_seq = ifi->xid = arc4random();
	rtm.rtm_priority = RTP_PROPOSAL_DHCLIENT;
	rtm.rtm_addrs = 0;
	rtm.rtm_flags = RTF_UP | RTF_PROTO3;

	retries = 0;
	while ((ifi->flags & IFI_IN_CHARGE) == 0) {
		if (write(routefd, &rtm, sizeof(rtm)) == -1)
			fatal("tried to take charge");
		time(&cur_time);
		if ((cur_time - start_time) > 3) {
			if (++retries <= 3) {
				if (time(&start_time) == -1)
					fatal("time");
			} else {
				fatalx("failed to take charge of %s",
				    ifi->name);
			}
		}
		fds[0].fd = routefd;
		fds[0].events = POLLIN;
		if (poll(fds, 1, 3) == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			fatal("routefd poll");
		}
		if ((fds[0].revents & (POLLIN | POLLHUP)) != 0)
			routehandler(ifi, routefd);
	}
}

struct client_lease *
get_recorded_lease(struct interface_info *ifi)
{
	char			 ifname[IF_NAMESIZE];
	time_t			 cur_time;
	struct client_lease	*lp;
	int			 i;

	time(&cur_time);

	/* Run through the list of leases and see if one can be used. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	TAILQ_FOREACH(lp, &ifi->leases, next) {
		if (lp->ssid_len != ifi->ssid_len)
			continue;
		if (memcmp(lp->ssid, ifi->ssid, lp->ssid_len) != 0)
			continue;
		if ((lp->options[i].len != 0) && ((lp->options[i].len !=
		    config->send_options[i].len) ||
		    memcmp(lp->options[i].data, config->send_options[i].data,
		    lp->options[i].len)))
			continue;
		if (addressinuse(ifi->name, lp->address, ifname) != 0 &&
		    strncmp(ifname, ifi->name, IF_NAMESIZE) != 0)
			continue;
		if (lp->is_static == 0 && lp->expiry <= cur_time)
			continue;

		if (lp->is_static != 0)
			set_lease_times(lp);
		break;
	}

	return lp;
}

void
set_default_client_identifier(struct interface_info *ifi)
{
	struct option_data	*opt;

	/*
	 * Check both len && data so
	 *
	 *     send dhcp-client-identifier "";
	 *
	 * can be used to suppress sending the default client
	 * identifier.
	 */
	opt = &config->send_options[DHO_DHCP_CLIENT_IDENTIFIER];
	if (opt->len == 0 && opt->data == NULL) {
		opt->data = calloc(1, ETHER_ADDR_LEN + 1);
		if (opt->data == NULL)
			fatalx("no memory for default client identifier");
		opt->data[0] = HTYPE_ETHER;
		memcpy(&opt->data[1], ifi->hw_address.ether_addr_octet,
		    ETHER_ADDR_LEN);
		opt->len = ETHER_ADDR_LEN + 1;
	}
}
@


1.486
log
@Check the option length, not its address (which will never be NULL)

Spotted by clang, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.485 2017/07/26 16:53:22 krw Exp $	*/
d989 1
d1038 3
a1040 5
	set_routes(ifi->active->address,
	    &options[DHO_CLASSLESS_STATIC_ROUTES],
	    &options[DHO_CLASSLESS_MS_STATIC_ROUTES],
	    &options[DHO_ROUTERS],
	    &options[DHO_SUBNET_MASK]);
d1051 1
@


1.485
log
@Local declaration beautification.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.484 2017/07/26 14:11:25 krw Exp $	*/
d1881 1
a1881 1
	if (&lease->options[DHO_DOMAIN_NAME_SERVERS].len != 0) {
@


1.484
log
@Stray u_int16_t -> uint16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.483 2017/07/24 18:13:19 krw Exp $	*/
d214 1
a214 1
	struct ifreq ifr;
d236 2
a237 2
	struct ifaddrs *ifap, *ifa;
	struct if_data *ifdata;
d268 4
a271 4
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_dl *sdl;
	struct if_data *ifdata;
	int found;
d1809 1
a1809 1
	struct proposal	*proposal;
@


1.483
log
@Throw DHO_STATIC_ROUTES to the floor! Roughly! Ensure
they don't appear in effective leases at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.482 2017/07/24 17:15:41 krw Exp $	*/
d1821 1
a1821 1
	if (opt->len == sizeof(u_int16_t)) {
@


1.482
log
@Shuffle some declarations and functions into the only
files they are used in. Tweak a bunch of whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.481 2017/07/24 16:17:35 krw Exp $	*/
a1040 1
	    &options[DHO_STATIC_ROUTES],
d2321 6
d2329 2
a2330 5
	 * RFC 3442 says client *MUST* ignore both DHO_ROUTERS and
	 * DHO_STATIC_ROUTES when DHO_CLASSLESS_[MS_]_ROUTES present.
	 *
	 * Remove them from 'newlease' so that -L will not show them
	 * as part of the effective lease.
a2336 4

		free(newlease->options[DHO_STATIC_ROUTES].data);
		newlease->options[DHO_STATIC_ROUTES].data = NULL;
		newlease->options[DHO_STATIC_ROUTES].len = 0;
@


1.481
log
@Tweak some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.480 2017/07/24 13:51:43 krw Exp $	*/
d64 2
d139 3
d209 97
@


1.480
log
@Move invocations of flush_routes() and delete_addresses() from
bind_lease() into set_routes() and set_address() respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.479 2017/07/24 13:16:06 krw Exp $	*/
d1122 1
a1122 1
	 * If this lease doesn't supply a required parameter, blow it off.
d1135 1
a1135 1
	 * using, blow it off.
d1166 1
a1166 1
	/* Ditto for the filename. */
d1228 4
a1231 2
	/* If the backoff would take us to the panic timeout, just use that
	   as the interval. */
d1298 1
a1298 1
	 * XXX In the INIT-REBOOT state, if we don't get an ACK, it
a2507 1
	 *
@


1.479
log
@ROUNDUP() adjustment missed by great ROUNDUP() roundup.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.478 2017/07/22 17:55:20 krw Exp $	*/
a930 4
	/* Deleting the addresses also clears out arp entries. */
	delete_addresses(ifi->name);
	flush_routes();

d933 1
a933 1
	set_address(ifi->active->address, &options[DHO_SUBNET_MASK]);
@


1.478
log
@Add set_routes() and move bind_lease() route magic
into it. Swap parameter order in add_default_route() to
be consistant with other add_*_route() functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.477 2017/07/22 15:34:22 krw Exp $	*/
d175 2
a176 2
#define ROUNDUP(a)	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : \
    sizeof(long))
@


1.477
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.476 2017/07/22 15:28:56 krw Exp $	*/
a882 2
	struct in_addr		 gateway, mask;
	struct option_data	*opt;
d935 1
a935 2
	opt = &options[DHO_INTERFACE_MTU];
	set_mtu(opt);
d937 1
a937 2
	opt = &options[DHO_SUBNET_MASK];
	set_address(ifi->active->address, opt);
d939 6
a944 35
	if (options[DHO_CLASSLESS_STATIC_ROUTES].len != 0) {
		add_classless_static_routes(
		    &options[DHO_CLASSLESS_STATIC_ROUTES],
		    ifi->active->address);
	} else if (options[DHO_CLASSLESS_MS_STATIC_ROUTES].len != 0) {
		add_classless_static_routes(
		    &options[DHO_CLASSLESS_MS_STATIC_ROUTES],
		    ifi->active->address);
	} else {
		opt = &options[DHO_ROUTERS];
		if (opt->len >= sizeof(gateway)) {
			/* XXX Only use FIRST router address for now. */
			gateway.s_addr = ((struct in_addr *)opt->data)->s_addr;

			/*
			 * To be compatible with ISC DHCP behavior on Linux, if
			 * we were given a /32 IP assignment, then add a /32
			 * direct route for the gateway to make it routable.
			 */
			opt = &options[DHO_SUBNET_MASK];
			if (opt->len == sizeof(mask)) {
				mask.s_addr = ((struct in_addr *)
				    opt->data)->s_addr;
				if (mask.s_addr == INADDR_BROADCAST) {
					add_direct_route(gateway, mask,
					    ifi->active->address);
				}
			}

			add_default_route(ifi->active->address, gateway);
		}
		if (options[DHO_STATIC_ROUTES].len != 0)
			add_static_routes(&options[DHO_STATIC_ROUTES],
			    ifi->active->address);
	}
@


1.476
log
@Oops. Missed chunk keeping /32 netmask magic.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.475 2017/07/22 14:56:27 krw Exp $	*/
d968 1
a968 1
				    ifi->active->address);
@


1.475
log
@Rename *_add_address to *_set_address to reflect that the
lease address replaces all current addresses. Shuffle some
code from bind_lease() into set_mtu()/set_address() to
shrink  bind_lease().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.474 2017/07/21 18:57:55 krw Exp $	*/
d962 6
a967 2
			if (mask.s_addr == INADDR_BROADCAST) {
				add_direct_route(gateway, mask,
d969 1
@


1.474
log
@s/set_interface_mtu/set_mtu/g
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.473 2017/07/21 18:43:05 krw Exp $	*/
d938 1
a938 10
	if (opt->len == sizeof(uint16_t)) {
		uint16_t mtu;
		memcpy(&mtu, opt->data, sizeof(mtu));
		mtu = ntohs(mtu);
		/* "The minimum legal value for the MTU is 68." */
		if (mtu < 68)
			log_warnx("mtu size %u < 68: ignored", mtu);
		else
			set_mtu(mtu);
	}
d941 1
a941 4
	if (opt->len == sizeof(mask))
		mask.s_addr = ((struct in_addr *)opt->data)->s_addr;
	else
		mask.s_addr = INADDR_ANY;
a942 5
        /*
	 * Add address and default route last, so we know when the binding
	 * is done by the RTM_NEWADDR message being received.
	 */
	add_address(ifi->active->address, mask);
@


1.473
log
@whitespace botch.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.472 2017/07/20 17:44:13 krw Exp $	*/
d946 1
a946 1
			set_interface_mtu(mtu);
@


1.472
log
@Restore RTM_DELADDR/RTM_NEWADDR monitoring to the
minimum required to ensure that resolv.conf is
written out on startup/HUP.

Noticed by and fix tested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.471 2017/07/17 16:13:13 krw Exp $	*/
d198 1
a198 1
				    return sa->sa_family;
@


1.471
log
@Nuke findproto() and get_ifa(). They are unused now that
RTM_DELADDR and RTM_NEWADDR are no longer of interest.

Pointed out by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.470 2017/07/17 15:05:03 krw Exp $	*/
d136 1
d188 18
d213 1
d302 10
d517 1
@


1.470
log
@Remove some magic formerly used to detect the presence of another
dhclient taking control of the interface.

In particular do not exit when addresses are manually added to or
deleted from the interface dhclient(8) is concerned about. Note that
such changes will still be removed whenever dhclient(8) is re-started
or gets a different lease during renewal.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.469 2017/07/14 16:21:03 krw Exp $	*/
a128 2
int		 findproto(char *, int);
struct sockaddr	*get_ifa(char *, int);
a184 49
}

int
findproto(char *cp, int n)
{
	struct sockaddr		*sa;
	unsigned int		 i;

	if (n == 0)
		return -1;
	for (i = 1; i; i <<= 1) {
		if ((i & n) != 0) {
			sa = (struct sockaddr *)cp;
			switch (i) {
			case RTA_IFA:
			case RTA_DST:
			case RTA_GATEWAY:
			case RTA_NETMASK:
				if (sa->sa_family == AF_INET)
					return AF_INET;
				if (sa->sa_family == AF_INET6)
					return AF_INET6;
				break;
			case RTA_IFP:
				break;
			}
			ADVANCE(cp, sa);
		}
	}
	return -1;
}

struct sockaddr *
get_ifa(char *cp, int n)
{
	struct sockaddr		*sa;
	unsigned int		 i;

	if (n == 0)
		return NULL;
	for (i = 1; i; i <<= 1)
		if ((i & n) != 0) {
			sa = (struct sockaddr *)cp;
			if (i == RTA_IFA)
				return sa;
			ADVANCE(cp, sa);
		}

	return NULL;
@


1.469
log
@Replace remaining "!var" expressions with
"<var> == 0", "!(<var> & FLAG)" with
"(<var> & FLAG) == 0", "!<func()>"
with "<func()> == 0" and "!<define>" with
"<define> == 0". And the positive cases
as well.

A few stray == NULL and != NULL as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.468 2017/07/14 14:03:15 krw Exp $	*/
a240 2
	char				 ntoabuf[INET_ADDRSTRLEN];
	struct in_addr			 a;
a241 2
	struct sockaddr			*sa;
	struct ifa_msghdr		*ifam;
a280 83
	case RTM_NEWADDR:
		ifam = (struct ifa_msghdr *)rtm;
		if (ifam->ifam_index != ifi->index)
			break;
		if (findproto((char *)ifam + ifam->ifam_hdrlen,
		    ifam->ifam_addrs) != AF_INET)
			break;
		sa = get_ifa((char *)ifam + ifam->ifam_hdrlen,
		    ifam->ifam_addrs);
		if (sa == NULL)
			goto done;

		memcpy(&a, &((struct sockaddr_in *)sa)->sin_addr, sizeof(a));
		if (a.s_addr == INADDR_ANY)
			break;

		/*
		 * If we are in the process of adding a new address, ignore
		 * messages generated by that process.
		 */
		if (a.s_addr == adding.s_addr) {
			adding.s_addr = INADDR_ANY;
			log_info("bound to %s -- renewal in %lld seconds.",
			    inet_ntoa(ifi->active->address),
			    (long long)(ifi->active->renewal -
			    time(NULL)));
			ifi->flags |= IFI_IS_RESPONSIBLE;
			go_daemon();
			break;
		}
		if ((ifi->flags & IFI_IS_RESPONSIBLE) == 0)
			/* We're not responsible yet! */
			break;
		if (adding.s_addr != INADDR_ANY) {
			strlcpy(ntoabuf, inet_ntoa(a), sizeof(ntoabuf));
			rslt = asprintf(&errmsg, "%s, not %s, added to %s",
			    ntoabuf, inet_ntoa(adding), ifi->name);
		} else
			rslt = asprintf(&errmsg, "%s added to %s",
			    inet_ntoa(a), ifi->name);
		goto die;
	case RTM_DELADDR:
		ifam = (struct ifa_msghdr *)rtm;
		if (ifam->ifam_index != ifi->index)
			break;
		if (findproto((char *)ifam + ifam->ifam_hdrlen,
		    ifam->ifam_addrs) != AF_INET)
			break;
		sa = get_ifa((char *)ifam + ifam->ifam_hdrlen,
		    ifam->ifam_addrs);
		if (sa == NULL)
			goto done;

		memcpy(&a, &((struct sockaddr_in *)sa)->sin_addr, sizeof(a));
		if (a.s_addr == INADDR_ANY)
			break;

		/*
		 * If we are in the process of deleting an address, ignore
		 * messages generated by that process.
		 */
		if (a.s_addr == deleting.s_addr) {
			deleting.s_addr = INADDR_ANY;
			break;
		}
		if ((ifi->flags & IFI_IS_RESPONSIBLE) == 0)
			/* We're not responsible yet! */
			break;
		if (adding.s_addr == INADDR_ANY && ifi->active &&
		    a.s_addr == ifi->active->address.s_addr) {
			log_warnx("Active address (%s) deleted; exiting",
			    inet_ntoa(ifi->active->address));
			quit = INTERNALSIG;
			goto done;
		}
		if (deleting.s_addr != INADDR_ANY) {
			strlcpy(ntoabuf, inet_ntoa(a), sizeof(ntoabuf));
			rslt = asprintf(&errmsg, "%s, not %s, deleted from %s",
			    ntoabuf, inet_ntoa(deleting), ifi->name);
		} else
			rslt = asprintf(&errmsg, "%s deleted from %s",
			    inet_ntoa(a), ifi->name);
		goto die;
d339 1
a339 1
	    (ifi->flags & IFI_IS_RESPONSIBLE) != 0)
d537 1
a537 2
	rtfilter = ROUTE_FILTER(RTM_PROPOSAL) | ROUTE_FILTER(RTM_NEWADDR) |
	    ROUTE_FILTER(RTM_DELADDR) | ROUTE_FILTER(RTM_IFINFO) |
a678 3
	deleting.s_addr = INADDR_ANY;
	adding.s_addr = INADDR_ANY;

d932 1
a932 1
	if ((ifi->flags & IFI_IS_RESPONSIBLE) && ifi->state == S_RENEWING) {
d938 4
a941 7
			    ifi->active->resolv_conf = NULL;
			    ifi->active = ifi->offer;
			    ifi->offer = NULL;
			    log_info("bound to %s -- renewal in %lld seconds.",
				inet_ntoa(ifi->active->address),
				(long long)(ifi->active->renewal - time(NULL)));
			    goto newlease;
d1012 4
@


1.468
log
@Replace remaining "!<pointer>" expressions with
"<pointer> == NULL". And of course "<pointer>"
expressions with "<pointer> != NULL".
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.467 2017/07/14 13:47:09 krw Exp $	*/
d198 1
a198 1
		if (i & n) {
d228 1
a228 1
		if (i & n) {
d380 1
a380 1
		if (ifi->flags & IFI_VALID_LLADDR) {
d394 2
a395 2
			    ifi->linkstat ? "up" : "down",
			    linkstat ? "up" : "down");
d398 1
a398 1
			if (ifi->linkstat) {
d425 2
a426 2
	if (ifi->active && ifi->active->resolv_conf &&
	    ifi->flags & IFI_IS_RESPONSIBLE)
d460 1
a460 1
	if (isatty(STDERR_FILENO))
d483 1
a483 1
				if (!S_ISREG(sb.st_mode))
d491 1
a491 1
				if (!S_ISREG(sb.st_mode))
d509 1
a509 1
	if (argc != 1 || (q_flag && d_flag))
d512 1
a512 1
	if (d_flag)
d515 1
a515 1
	if (q_flag)
d583 1
a583 1
	if (ignore_list)
d683 1
a683 1
	if (daemonize) {
d694 1
a694 1
	if (ifi->linkstat) {
d732 2
a733 2
	if (log_perror && interval > 3) {
		if (!preamble && !ifi->linkstat) {
d737 2
a738 2
		if (preamble) {
			if (ifi->linkstat)
d748 1
a748 1
	if (ifi->linkstat) {
d977 1
a977 1
	if (!ifi->active->is_static) {
d1074 1
a1074 1
	if (options[DHO_CLASSLESS_STATIC_ROUTES].len) {
d1078 1
a1078 1
	} else if (options[DHO_CLASSLESS_MS_STATIC_ROUTES].len) {
d1100 1
a1100 1
		if (options[DHO_STATIC_ROUTES].len)
d1118 1
a1118 1
		if (lease->is_static)
d1135 1
a1135 1
	if (!ifi->active->is_static && !seen)
d1233 1
a1233 1
		if (!unknown_ok && strncmp("option-", name, 7) != 0) {
d1245 1
a1245 1
			if (buf == NULL || !res_hnok_list(buf)) {
d1258 1
a1258 1
			if (!res_hnok_list(pretty)) {
d1266 1
a1266 1
			if (!res_hnok(pretty)) {
d1284 1
a1284 1
		if (!lease->options[config->required_options[i]].len) {
d1298 1
a1298 1
	if (addressinuse(ifi->name, lease->address, ifname) &&
d1309 2
a1310 2
	if ((!lease->options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(lease->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)) &&
d1319 1
a1319 1
		if (!res_hnok(lease->server_name)) {
d1326 2
a1327 2
	if ((!lease->options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(lease->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)) &&
d1377 1
a1377 1
	if (!ifi->interval)
d1485 1
a1485 1
	if (!ifi->interval) {
d1572 1
a1572 1
	if (lease) {
d1733 1
a1733 1
	if (config->send_options[i].len) {
d1794 1
a1794 1
	if (!leaseFile)	/* XXX */
d1810 1
a1810 1
		if (lp->is_static)
d1815 1
a1815 1
		if (leasestr)
d1832 1
a1832 1
	if (!optionDB)
d1838 1
a1838 1
	if (leasestr)
d1844 1
a1844 1
	if (leasestr)
d1889 1
a1889 1
	if (lease->options[DHO_CLASSLESS_STATIC_ROUTES].len) {
d1898 1
a1898 1
	} else if (lease->options[DHO_CLASSLESS_MS_STATIC_ROUTES].len) {
d1918 1
a1918 1
	if (lease->options[DHO_DOMAIN_SEARCH].len) {
d1928 1
a1928 1
	} else if (lease->options[DHO_DOMAIN_NAME].len) {
d1937 1
a1937 1
	if (&lease->options[DHO_DOMAIN_NAME_SERVERS].len) {
d1979 1
a1979 1
	if (lease->filename) {
d1986 1
a1986 1
	if (lease->server_name) {
d2045 1
a2045 1
	if (!daemonize || state)
d2106 1
a2106 1
			if (!isalnum(ch))
d2108 1
a2108 1
		} else if (!isalnum(ch) && ch != '-' && ch != '_') {
d2202 1
a2202 1
		if (nfds == 0 || !(pfd[0].revents & POLLIN))
d2219 1
a2219 1
		if (got_imsg_hup)
d2229 1
a2229 1
		if (!got_imsg_hup)
d2267 1
a2267 1
			if (arg)
d2290 1
a2290 1
	if (config->filename) {
d2294 1
a2294 1
	if (config->server_name) {
d2399 1
a2399 1
	if (newlease) {
d2429 1
a2429 1
	if (oldlease->server_name) {
d2434 1
a2434 1
	if (oldlease->filename) {
d2439 1
a2439 1
	if (oldlease->resolv_conf) {
d2460 1
a2460 1
	if (newlease) {
d2618 1
a2618 1
		if ((fds[0].revents & (POLLIN | POLLHUP)))
d2645 1
a2645 1
		if (addressinuse(ifi->name, lp->address, ifname) &&
d2651 1
a2651 1
		if (lp->is_static)
@


1.467
log
@Pour the few relevant bits of the current lease and the offered
renewal lease into canonical forms and compare those rather than the
leases themselves. Eliminates spurious interface and route
manipulation when irrelevant aspects of the leases are changed by the
DHCP server.

Problem found by Paul de Weerd when his DHCP server returned
renewed leases differing only by a decremented dhcp-lease-time option.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.466 2017/07/10 17:13:24 krw Exp $	*/
d663 1
a663 1
	if (!ifi->rbuf)
d967 1
a967 1
	if (!ifi->active) {
d1313 1
a1313 1
		if (!lease->server_name) {
d1331 1
a1331 1
		if (!lease->filename) {
d1582 2
a1583 2
		if (!options[i].data &&
		    config->send_options[i].data) {
d1659 2
a1660 1
		if (!options[i].data && config->send_options[i].data) {
@


1.466
log
@Take some of the mystery out of who does what by
renaming "if_register_bpf()" to "get_bpf_sock()",
"if_register_send()" to "get_udp_sock()" and
"if_register_receive()" to "configure_bpf_sock()".

Pull back interface_info knowledge and just pass
the interface name, rdomain and bpf socket fd as
required.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.465 2017/07/10 14:11:47 krw Exp $	*/
d114 14
a142 1
int compare_lease(struct client_lease *, struct client_lease *);
d165 1
d998 2
d1020 1
a1020 1
	 * A duplicate lease once we are responsible & S_RENEWING means we
d1023 14
a1036 10
	if ((ifi->flags & IFI_IS_RESPONSIBLE) && ifi->state == S_RENEWING &&
	    compare_lease(ifi->active, ifi->offer) == 0) {
		ifi->offer->resolv_conf = ifi->active->resolv_conf;
		ifi->active->resolv_conf = NULL;
		ifi->active = ifi->offer;
		ifi->offer = NULL;
		log_info("bound to %s -- renewal in %lld seconds.",
		    inet_ntoa(ifi->active->address),
		    (long long)(ifi->active->renewal - time(NULL)));
		goto newlease;
d1108 2
d1861 91
a2564 41
}

int
compare_lease(struct client_lease *active, struct client_lease *new)
{
	int	 i;

	if (active == new)
		return 0;

	if (!new || !active)
		return 1;

	if (active->address.s_addr != new->address.s_addr ||
	    active->is_static != new->is_static ||
	    BOOTP_LEASE(active) != BOOTP_LEASE(new))
		return 1;

	if (active->server_name != new->server_name) {
		if (!active->server_name || !new->server_name)
			return 1;
		if (strcmp(active->server_name, new->server_name) != 0)
			return 1;
	}

	if (active->filename != new->filename) {
		if (!active->filename || !new->filename)
			return 1;
		if (strcmp(active->filename, new->filename) != 0)
			return 1;
	}

	for (i = 0; i < DHO_COUNT; i++) {
		if (active->options[i].len != new->options[i].len)
			return 1;
		if (memcmp(active->options[i].data, new->options[i].data,
		    active->options[i].len))
			return 1;
	}

	return 0;
@


1.465
log
@Use ioctlfd/routefd sockets rather than rolling one's own
for resolving 'egress' and adding a route. Move creation
of main()'s ioctlfd up so it can be used for the
'egress' resolution.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.464 2017/07/10 00:47:47 krw Exp $	*/
d645 9
a653 2
	if_register_receive(ifi);
	if_register_send(ifi);
@


1.464
log
@Use a modern spacious idiom on all function local variable
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.463 2017/07/09 19:19:58 krw Exp $	*/
d123 1
a123 1
void		 get_ifname(struct interface_info *, char *);
d509 3
a511 1
	get_ifname(ifi, argv[0]);
a519 2
	if ((ioctlfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatalx("Can't create socket to do ioctl");
d2122 1
a2122 1
get_ifname(struct interface_info *ifi, char *arg)
a2126 1
	int			 s;
a2128 3
		s = socket(AF_INET, SOCK_DGRAM, 0);
		if (s == -1)
			fatalx("socket error");
d2131 1
a2131 1
		if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
d2139 1
a2139 1
		if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
a2154 1
		close(s);
@


1.463
log
@Be consistent. "return (e);" -> "return e;"
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.462 2017/07/09 12:38:47 krw Exp $	*/
d178 2
a179 2
	struct sockaddr *sa;
	unsigned int i;
d208 2
a209 2
	struct sockaddr *sa;
	unsigned int i;
d701 3
a703 3
	static int preamble;
	time_t cur_time;
	int interval;
d795 1
a795 1
	struct option_data *option;
d863 2
a864 2
	struct client_lease *lease;
	time_t stop_selecting;
d902 1
a902 1
	struct client_lease *lease;
d973 6
a978 6
	struct in_addr gateway, mask;
	struct option_data *opt;
	struct option_data *options;
	struct client_lease *lease, *pl;
	time_t cur_time;
	int seen;
d1126 2
a1127 2
	struct option_data *opt;
	struct in_addr *dest;
d1150 3
a1152 3
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_in *sin;
	int used = 0;
d1187 5
a1191 5
	struct dhcp_packet *packet = &ifi->recv_packet;
	char ifname[IF_NAMESIZE];
	struct client_lease *lease;
	char *pretty, *buf, *name;
	int i;
d1326 4
a1329 4
	struct dhcp_packet *packet = &ifi->sent_packet;
	time_t cur_time;
	ssize_t rslt;
	int interval;
d1411 5
a1415 5
	struct dhcp_packet *packet = &ifi->sent_packet;
	struct sockaddr_in destination;
	struct in_addr from;
	time_t cur_time;
	int interval;
d1742 1
a1742 1
	int i;
d1760 3
a1762 3
	struct client_lease *lp;
	char *leasestr;
	time_t cur_time;
d1800 1
a1800 1
	char *leasestr;
d1835 6
a1840 6
	static char string[8192];
	char timebuf[27];	/* to hold "6 2017/04/08 05:47:50 UTC;" */
	struct option_data *opt;
	char *buf, *name;
	size_t rslt;
	int i;
d1922 1
a1922 1
	static int state = 0;
d1975 3
a1977 3
	const char *dn = name;
	int pch = '.', ch = (unsigned char)*dn++;
	int warn = 0;
d2007 2
a2008 2
	char *dupnames, *hn, *inputstring;
	int count;
d2124 4
a2127 4
	struct ifgroupreq ifgr;
	struct ifg_req *ifg;
	unsigned int len;
	int s;
d2167 2
a2168 2
	struct client_lease *newlease;
	int i, j;
d2297 2
a2298 2
	struct client_lease *newlease;
	int i;
d2360 3
a2362 3
	uint8_t	 list[DHO_COUNT];
	char	*p;
	int	 ix, i, j;
d2455 1
a2455 1
	int i;
d2587 1
a2587 1
	struct option_data *opt;
@


1.462
log
@Whitespace tweaks to assuage auto-indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.461 2017/07/08 20:38:31 krw Exp $	*/
d202 1
a202 1
	return (-1);
d212 1
a212 1
		return (NULL);
d217 1
a217 1
				return (sa);
d221 1
a221 1
	return (NULL);
d684 1
a684 1
	return (0);
d1156 1
a1156 1
		return (0);
d1174 1
a1174 1
	return (used);
d1850 1
a1850 1
		return (NULL);
d1862 1
a1862 1
			return (NULL);
d1869 1
a1869 1
			return (NULL);
d1876 1
a1876 1
			return (NULL);
d1888 1
a1888 1
			return (NULL);
d1897 1
a1897 1
		return (NULL);
d1903 1
a1903 1
		return (NULL);
d1909 1
a1909 1
		return (NULL);
d1914 1
a1914 1
		return (NULL);
d1916 1
a1916 1
	return (string);
d1946 1
a1946 1
		return (-1);
d1949 1
a1949 1
		return (-1);
d1953 1
a1953 1
		return (-1);
d1961 1
a1961 1
		return (-1);
d1969 1
a1969 1
	return (0);
d1986 1
a1986 1
				return (0);
d1988 1
a1988 1
			return (0);
d1996 1
a1996 1
	return (1);
d2011 1
a2011 1
		return (0);
d2030 1
a2030 1
	return (count > 0 && count < 7 && hn == NULL);
d2280 1
a2280 1
	return (newlease);
d2291 1
a2291 1
	return (NULL);
d2341 1
a2341 1
	return (newlease);
d2349 1
a2349 1
	return (NULL);
d2458 1
a2458 1
		return (0);
d2461 1
a2461 1
		return (1);
d2466 1
a2466 1
		return (1);
d2470 1
a2470 1
			return (1);
d2472 1
a2472 1
			return (1);
d2477 1
a2477 1
			return (1);
d2479 1
a2479 1
			return (1);
d2484 1
a2484 1
			return (1);
d2487 1
a2487 1
			return (1);
d2490 1
a2490 1
	return (0);
d2581 1
a2581 1
	return (lp);
@


1.461
log
@Fold tables.c into options.c and stop exporting the one
table (dhcp_options) involved. Provide functions
code_to_name(), name_to_code(), code_to_format() and
replace direct access to dhcp_options with them. Eliminate
unneeded 'struct option'.

Unhook tables.c from Makefile.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.460 2017/07/08 00:36:10 krw Exp $	*/
d162 2
a163 2
#define	ROUNDUP(a) \
	    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
@


1.460
log
@Always use uintNN_t instead of sometimes u_intNN_t
and sometimes uintNN_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.459 2017/07/07 16:58:45 krw Exp $	*/
d1190 1
a1190 1
	char *pretty, *buf;
d1203 2
a1204 2
		if (!unknown_ok && strncmp("option-",
		    dhcp_options[i].name, 7) != 0) {
d1218 1
a1218 1
				    "name(s)", dhcp_options[i].name);
d1231 1
a1231 1
				    "name(s)", dhcp_options[i].name);
d1239 1
a1239 1
				    "name", dhcp_options[i].name);
d1256 1
d1258 1
a1258 1
			    dhcp_options[i].name);
d1833 1
a1833 1
lease_as_string(char *name, char *type, struct client_lease *lease)
d1838 1
a1838 1
	char *buf;
d1848 1
a1848 1
	buf = pretty_print_string(name, strlen(name), 1);
d1884 1
d1890 1
a1890 1
		strlcat(string, dhcp_options[i].name, sizeof(string));
d2372 1
a2372 4
		for (i = 1; i < DHO_END; i++)
			if (!strcasecmp(dhcp_options[i].name, p))
				break;

@


1.459
log
@Replace the many occurances of '256' with a new #define
DHO_COUNT.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.458 2017/07/07 15:39:30 krw Exp $	*/
d1025 2
a1026 2
	if (opt->len == sizeof(u_int16_t)) {
		u_int16_t mtu;
d2358 3
a2360 3
	u_int8_t list[DHO_COUNT];
	char *p;
	int ix, i, j;
d2393 2
a2394 2
	time_t cur_time, time_max;
	u_int32_t uint32val;
@


1.458
log
@dispatch_imsg() only needs to know name and rdomain.

No more struct interface_info knowledge in privsep.[ch]
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.457 2017/07/07 14:53:06 krw Exp $	*/
d1200 1
a1200 1
	for (i = 0; i < 256; i++) {
d1523 1
a1523 1
	struct option_data	 options[256];
d1551 1
a1551 1
	for (i = 0; i < 256; i++)
d1591 1
a1591 1
	struct option_data	 options[256];
d1628 1
a1628 1
	for (i = 0; i < 256; i++)
d1677 1
a1677 1
	struct option_data	 options[256];
d1750 1
a1750 1
	for (i = 0; i < 256; i++)
d1879 1
a1879 1
	for (i = 0; i < 256; i++) {
d2185 1
a2185 1
	for (i = 0; i < 256; i++) {
d2327 1
a2327 1
	for (i = 0; i < 256; i++) {
d2358 1
a2358 1
	u_int8_t list[256];
d2483 1
a2483 1
	for (i = 0; i < 256; i++) {
@


1.457
log
@Rename cons_options() to pack_options(), and do_packet() to
unpack_options(). Store the unpacked options in a static
variable. Move remaining raw packet processing from unpack_options()
to packethandler().

No more struct interface_info knowledge in options.c
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.456 2017/07/06 16:56:52 krw Exp $	*/
d2094 2
a2095 1
		got_imsg_hup = dispatch_imsg(ifi, ioctlfd, routefd, priv_ibuf);
@


1.456
log
@cons_options() only needs to know a buffer and a length to
pack options into. Not all the gory details of interface_info.

Move some of the raw packet processing out of options.c's
do_packet() and into the more obvious dispatch.c's
packethandler().

Mention that RFC791 is why we use 576-byte UDP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.455 2017/07/05 16:17:42 krw Exp $	*/
d1563 1
a1563 1
	i = cons_options(ifi->sent_packet.options, 576 - DHCP_FIXED_LEN,
d1639 1
a1639 1
	i = cons_options(ifi->sent_packet.options, 576 - DHCP_FIXED_LEN,
d1712 1
a1712 1
	i = cons_options(ifi->sent_packet.options, 576 - DHCP_FIXED_LEN,
@


1.455
log
@Remove knowledge of struct interface_info from clparse.c. Just
pass the interface name and the TAILQ to put static leases into.

Add a TAILQ for static leases to struct client_config to hold the
static leases until it's time to add them to ifi.

Add add_lease() to add leases to a TAILQ while checking for
leases that are superseded by the new lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.454 2017/07/01 23:27:55 krw Exp $	*/
d1523 4
a1526 4
	struct option_data options[256];
	struct dhcp_packet *packet = &ifi->sent_packet;
	unsigned char discover = DHCPDISCOVER;
	int i;
d1558 7
a1564 2
	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(ifi, options);
d1591 4
a1594 4
	struct option_data options[256];
	struct dhcp_packet *packet = &ifi->sent_packet;
	unsigned char request = DHCPREQUEST;
	int i;
d1634 7
a1640 2
	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(ifi, options);
d1677 4
a1680 4
	struct option_data options[256];
	struct dhcp_packet *packet = &ifi->sent_packet;
	unsigned char decline = DHCPDECLINE;
	int i;
d1707 7
a1713 2
	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(ifi, options);
@


1.454
log
@Eliminate multiple socket openings/closings and pass
fd'd from main loops as required. One socket to do
ioctl's per process (called ioctlfd) and one socket to
do route messages per socket (called routefd).

Clean up local variable declaration lists in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.453 2017/06/29 13:55:53 krw Exp $	*/
d437 1
a550 1
	TAILQ_INIT(&config->reject_list);
d552 1
a552 3
	TAILQ_INIT(&ifi->leases);

	read_client_conf(ifi);
d626 1
a626 1
	read_client_leases(ifi);
d632 7
d1762 1
a1762 1
	TAILQ_FOREACH_REVERSE(lp, &ifi->leases, _leases, next) {
@


1.453
log
@delete_addresses(), interface_status(), addressinuse(),
lease_as_string() and rewrite_option_db() only use the
interface name, so supply just the name.

Tweak interface_link_forceup() to use the same param
name as other functions taking the interface name.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.452 2017/06/28 16:31:52 krw Exp $	*/
a104 1
int routefd = -1;
d158 1
a158 1
void	take_charge(struct interface_info *);
d225 1
a225 1
routehandler(struct interface_info *ifi)
d227 11
a237 11
	char ntoabuf[INET_ADDRSTRLEN];
	struct in_addr a;
	struct sockaddr *sa;
	struct ifa_msghdr *ifam;
	struct ether_addr hw;
	struct rt_msghdr *rtm;
	struct if_msghdr *ifm;
	struct if_announcemsghdr *ifan;
	char *errmsg, *rtmmsg;
	ssize_t n;
	int linkstat, rslt;
a427 2
int sock;

d431 11
a441 10
	const char *tail_path = "/etc/resolv.conf.tail";
	struct interface_info *ifi;
	struct ifreq ifr;
	struct ieee80211_nwid nwid;
	struct stat sb;
	int	 ch, fd, socket_fd[2];
	struct passwd *pw;
	char *ignore_list = NULL;
	ssize_t tailn;
	int rtfilter, tailfd, q_flag, d_flag;
d517 2
a518 2
	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatalx("Can't create socket to get ssid");
d523 1
a523 1
	if (ioctl(sock, SIOCG80211NWID, (caddr_t)&ifr) == 0) {
d605 3
a607 1
		interface_link_forceup(ifi->name);
d623 1
a623 1
	take_charge(ifi);
d676 1
a676 1
	dispatch(ifi);
d2014 4
a2017 4
	struct pollfd pfd[1];
	struct imsgbuf *priv_ibuf;
	ssize_t n;
	int nfds, got_imsg_hup = 0;
d2043 5
d2074 1
a2074 1
		got_imsg_hup = dispatch_imsg(ifi, priv_ibuf);
d2078 2
d2474 1
a2474 1
take_charge(struct interface_info *ifi)
d2476 4
a2479 4
	struct	pollfd fds[1];
	struct	rt_msghdr rtm;
	time_t	start_time, cur_time;
	int	retries;
d2524 1
a2524 1
			routehandler(ifi);
@


1.452
log
@Only pass required fields of interface_info to priv_* functions
and friends. i.e. ifi->name, ifi->rdomain, or both.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.451 2017/06/28 14:35:43 krw Exp $	*/
d121 1
a121 1
int		 addressinuse(struct interface_info *, struct in_addr, char *);
d151 2
a152 3
void rewrite_option_db(struct interface_info *, struct client_lease *,
    struct client_lease *);
char *lease_as_string(struct interface_info *, char *, struct client_lease *);
d377 1
a377 1
		linkstat = interface_status(ifi);
d605 1
a605 1
	ifi->linkstat = interface_status(ifi);
d704 1
a704 1
	ifi->linkstat = interface_status(ifi);
d1016 1
a1016 1
	delete_addresses(ifi);
d1074 1
a1074 1
	rewrite_option_db(ifi, ifi->active, lease);
d1143 1
a1143 1
addressinuse(struct interface_info *ifi, struct in_addr address, char *ifname)
d1163 1
a1163 1
			if (strncmp(ifname, ifi->name, IF_NAMESIZE) != 0)
d1263 1
a1263 1
	if (addressinuse(ifi, lease->address, ifname) &&
d1763 1
a1763 1
		leasestr = lease_as_string(ifi, "lease", lp);
d1776 1
a1776 1
rewrite_option_db(struct interface_info *ifi, struct client_lease *offered,
d1786 1
a1786 1
	leasestr = lease_as_string(ifi, "offered", offered);
d1792 1
a1792 1
	leasestr = lease_as_string(ifi, "effective", effective);
d1812 1
a1812 2
lease_as_string(struct interface_info *ifi, char *type,
    struct client_lease *lease)
d1827 1
a1827 1
	buf = pretty_print_string(ifi->name, strlen(ifi->name), 1);
d2543 1
a2543 1
		if (addressinuse(ifi, lp->address, ifname) &&
@


1.451
log
@Stop trying to clean up addresses, routes and "-L" file
whenever dhclient dies. Eliminates differences in handling
and thus need to intercept signals INT, TERM, USR1,
USR2. Eliminates need for 'zapzombies' field and thus
entire struct imsg_flushroutes. Eliminates need for 'imsg'
parameter to and associated logic in priv_flush_routes().

Address, routes and '-L' file are still cleaned out when
binding a lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.450 2017/06/28 12:53:46 krw Exp $	*/
d1008 1
a1008 1
	ifi->offer->resolv_conf = resolv_conf_contents(ifi,
@


1.450
log
@Consistently use socket(..., AF_INET) for routing
sockets to cut down on unwanted IPv6 messages.

suggested by & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.449 2017/06/27 13:24:49 krw Exp $	*/
a394 5
				/* Let monitoring programs see link loss. */
				if (optionDB) {
					rewind(optionDB);
					ftruncate(fileno(optionDB), 0);
				}
d636 1
a636 1
		if ((optionDB = fopen(path_option_db, "w")) == NULL)
a1916 1
	/* Catch stuff that might be trying to terminate the program. */
a1917 5
	signal(SIGINT, sighdlr);
	signal(SIGTERM, sighdlr);
	signal(SIGUSR1, sighdlr);
	signal(SIGUSR2, sighdlr);

d2019 1
a2019 1
	int nfds, rslt, got_imsg_hup = 0;
a2077 15

	if (strlen(path_option_db)) {
		/* Truncate the file so monitoring process see exit. */
		rslt = truncate(path_option_db, 0);
		if (rslt == -1)
			log_warn("Unable to truncate '%s'", path_option_db);
	}

	/*
	 * SIGTERM is used by system at shut down. Be nice and don't cleanup
	 * routes, possibly preventing NFS from properly shutting down.
	 */
	if (quit != SIGTERM) {
		priv_cleanup(ifi);
	}
@


1.449
log
@Nuke get_rdomain() and just snag the interface rdomain from the same
ifa we use to get the interface hw address. One less socket() and
ioctl()! MIssed cleanup from shift to just watching RTM_IFINFO
messages for rdomain switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.448 2017/06/25 00:38:38 krw Exp $	*/
d615 1
a615 1
	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) == -1)
@


1.448
log
@Oops. Revert unintentional/premature functional change. Deleting the
address configured by dhclient should cause exit, not restart. There
is no need to invoke sendhup(). Just exit and let the privileged child
follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.447 2017/06/24 23:32:57 krw Exp $	*/
a537 1
	ifi->rdomain = get_rdomain(ifi->name);
@


1.447
log
@Tweak handling of HUP and new LLADDR. Just use expose and use sighup()
function. Don't exit dispatch() loop on SIGHUP, wait for privileged
child to execvp() dhclient. Eliminate struct imsg_hup since its
contents were not being used except in priv_cleanup(). And
'active_addr' works just as well there.

Cleaner and eliminates some extraneous log entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.446 2017/06/24 10:09:26 krw Exp $	*/
a342 1
			/* Tell the priv process active_addr is gone. */
d345 1
a345 1
			sendhup();
@


1.446
log
@Use a local variable rather than a global flag to record
the reception of a IMSG_HUP message and trigger the
desired restart.

Nuke the now pointless IFI_HUP.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.445 2017/06/23 19:51:07 krw Exp $	*/
d230 1
a230 1
	struct in_addr a, b;
d346 2
a347 6
			memset(&b, 0, sizeof(b));
			add_address(b, b);
			/* No need to write resolv.conf now. */
			ifi->flags &= ~IFI_IS_RESPONSIBLE;
			quit = INTERNALSIG;
			break;
d374 1
a374 1
				quit = SIGHUP;
a2028 1
	struct imsg_hup imsg;
d2104 1
a2104 3
		memset(&imsg, 0, sizeof(imsg));
		imsg.addr = active_addr;
		priv_cleanup(ifi, &imsg);
@


1.445
log
@Once you have forked into two processes, setting a global flag
in one process does not mean the other process can see the
change. Nuke the pointless IFI_NEW_LLADDR.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.444 2017/06/23 16:09:38 krw Exp $	*/
d2037 1
a2037 1
	int nfds, rslt;
d2089 3
a2091 1
		dispatch_imsg(ifi, priv_ibuf);
d2115 1
a2115 1
		if (!(ifi->flags & IFI_HUP))
@


1.444
log
@Use a const char * for "/etc/resolv.conf.tail" instead of repeating the
text in various forms in different error messages. Also makes the error
messages consistent by always displaying the full path name.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.443 2017/06/21 16:39:05 krw Exp $	*/
a377 1
				ifi->flags |= IFI_NEW_LLADDR;
d2113 1
a2113 2
		if (!(ifi->flags & IFI_HUP) &&
		    (!(ifi->flags & IFI_NEW_LLADDR)))
@


1.443
log
@Teach get_recorded_lease() that static leases do not
expire.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.442 2017/06/21 15:49:27 krw Exp $	*/
d446 1
d589 1
a589 1
	tailfd = open("/etc/resolv.conf.tail", O_RDONLY);
d592 1
a592 1
			fatal("Cannot open /etc/resolv.conf.tail");
d594 1
a594 1
		fatal("Cannot stat /etc/resolv.conf.tail");
d599 1
a599 2
				fatalx("no memory for resolv.conf.tail "
				    "contents");
d603 1
a603 1
				fatal("Couldn't read resolv.conf.tail");
d605 1
a605 1
				fatalx("Got no data from resolv.conf.tail");
d607 1
a607 1
				fatalx("Short read of resolv.conf.tail");
@


1.442
log
@No need to manually check validity of ifi->active when
REBOOT'ing. It will be pointing to a recorded lease if
anything. So rely on get_recorded_lease() to return the
next valid candidate lease, which might be the lease
ifi->active was pointing at.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.441 2017/06/21 15:24:34 krw Exp $	*/
d2583 1
a2583 1
		else if (lp->expiry <= cur_time)
@


1.441
log
@Consistently use time(&var) idiom rather than tossing in a few
var = time(NULL). Flip "struct interface *" to be the first
parameter in set_timeout(), as in other functions taking the
state info.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.440 2017/06/21 12:37:24 krw Exp $	*/
d752 1
a752 2
	char ifname[IF_NAMESIZE];
	time_t cur_time;
a753 1
	cancel_timeout(ifi);
d757 6
a762 12
	time(&cur_time);
	if (ifi->active) {
		if (ifi->active->expiry <= cur_time)
			ifi->active = NULL;
		else if (addressinuse(ifi, ifi->active->address, ifname) &&
		    strncmp(ifname, ifi->name, IF_NAMESIZE) != 0)
			ifi->active = NULL;
	} else
		ifi->active = get_recorded_lease(ifi);

	/*  No active lease, or the lease is BOOTP, go straight to INIT. */
	if (!ifi->active || BOOTP_LEASE(ifi->active)) {
@


1.440
log
@Allow familiar idiom free_client_lease(NULL).
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.439 2017/06/19 19:28:35 krw Exp $	*/
d737 1
a737 1
		set_timeout(1, state_reboot, ifi);
d742 1
a742 1
		set_timeout(1, state_preboot, ifi);
d780 1
a780 1
	ifi->first_sending = time(NULL);
d798 1
a798 1
	ifi->first_sending = time(NULL);
d859 1
a859 1
	ifi->first_sending = time(NULL);
d912 1
a912 1
		set_timeout(stop_selecting, state_selecting, ifi);
d1131 1
a1131 1
	set_timeout(ifi->active->renewal - cur_time, state_bound, ifi);
d1156 1
a1156 1
	ifi->first_sending = time(NULL);
d1395 1
a1395 1
		set_timeout(ifi->interval, send_discover, ifi);
d1419 1
a1419 1
	set_timeout(config->retry_interval, state_init, ifi);
d1525 1
a1525 1
	set_timeout(ifi->interval, send_request, ifi);
@


1.439
log
@Various KNF nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.438 2017/06/19 01:09:09 krw Exp $	*/
d1745 1
a1745 1
	if (lease->is_static)
@


1.438
log
@Erroneous host names in various options should be ignored
and not cause the lease to be declined. Restore inadvertantly
changed behaviour. Tweak logic to also ignore invalid
host names in domain-search.

Reported by Christer Solskogen via misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.437 2017/06/18 21:08:15 krw Exp $	*/
d429 1
a429 1
 done:
d433 1
a433 1
 die:
d1108 1
a1108 1
		       continue;
d1326 1
a1326 1
 decline:
d2123 1
a2123 1
		   (!(ifi->flags & IFI_NEW_LLADDR)))
@


1.437
log
@Move the timeout information into struct interface_info with
the rest of the dhcp state. One less struct (dhcp_timeout) to
worry about, one less field (ifi) to keep track of.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.436 2017/06/18 17:01:46 krw Exp $	*/
d1232 3
a1234 1
			if (buf == NULL)
a1235 4
			if (!res_hnok_list(buf)) {
				log_warnx("lease declined: invalid host "
				    "name(s) in %s", dhcp_options[i].name);
				goto decline;
d1246 3
a1248 3
				log_warnx("lease declined: invalid host "
				    "names in %s", dhcp_options[i].name);
				goto decline;
d1254 3
a1256 3
				log_warnx("lease declined: invalid host name "
				    "in %s", dhcp_options[i].name);
				goto decline;
@


1.436
log
@Convert last set_timeout() use to set_timeout_interval() and
then remove set_timeout() and rename set_timeout_interval() to
set_timeout().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.435 2017/06/18 16:37:19 krw Exp $	*/
d407 1
a407 1
				cancel_timeout();
d755 1
a755 1
	cancel_timeout();
d813 1
a813 1
	cancel_timeout();
d944 1
a944 1
	cancel_timeout();
d980 1
a980 1
	cancel_timeout();
d1454 1
a1454 1
		cancel_timeout();
@


1.435
log
@Drop (int) casts of (time_t - time_t) calculations that
are assigned to an int variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.434 2017/06/18 14:54:19 krw Exp $	*/
d737 1
a737 1
		set_timeout_interval(1, state_reboot, ifi);
d742 1
a742 1
		set_timeout_interval(1, state_preboot, ifi);
d1131 1
a1131 1
	set_timeout(ifi->active->renewal, state_bound, ifi);
d1397 1
a1397 1
		set_timeout_interval(ifi->interval, send_discover, ifi);
d1421 1
a1421 1
	set_timeout_interval(config->retry_interval, state_init, ifi);
d1527 1
a1527 1
	set_timeout_interval(ifi->interval, send_request, ifi);
@


1.434
log
@Nuke stray and misleading comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.433 2017/06/18 11:26:14 krw Exp $	*/
d715 1
a715 1
	interval = (int)(cur_time - ifi->startup_time);
d1437 1
a1437 1
	interval = (int)(cur_time - ifi->first_sending);
@


1.433
log
@Make 'DEBUG' compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.432 2017/06/17 20:23:17 krw Exp $	*/
d1728 1
a1728 1
	packet->secs = 0; /* Filled in by send_request. */
@


1.432
log
@Shuffle dhcp[offer|ack|nak]() functions together for easy reference.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.431 2017/06/17 17:10:26 krw Exp $	*/
d884 1
a884 1
		log_debug("Unexpected %s. State #%d.", info, client->state);
d925 1
a925 1
		log_debug("Unexpected %s. State #%d", info, client->state);
d957 1
a957 1
		log_debug("Unexpected %s. State #%d", info, client->state);
@


1.431
log
@Rename struct interface_info field 'new' to clearer 'offer'.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.430 2017/06/17 16:58:55 krw Exp $	*/
d877 39
d950 37
a1162 39
void
dhcpoffer(struct interface_info *ifi, struct option_data *options, char *info)
{
	struct client_lease *lease;
	time_t stop_selecting;

	if (ifi->state != S_SELECTING) {
#ifdef DEBUG
		log_debug("Unexpected %s. State #%d.", info, client->state);
#endif	/* DEBUG */
		return;
	}

	log_info("%s", info);

	lease = packet_to_lease(ifi, options);
	if (lease != NULL) {
		if (ifi->offer == NULL) {
			ifi->offer = lease;
		} else if (lease->address.s_addr ==
		    ifi->requested_address.s_addr) {
			free_client_lease(ifi->offer);
			ifi->offer = lease;
		}
		if (ifi->offer != lease) {
			make_decline(ifi, lease);
			send_decline(ifi);
			free_client_lease(lease);
		}
	}

	/* Figure out when we're supposed to stop selecting. */
	stop_selecting = ifi->first_sending + config->select_interval;
	if (stop_selecting <= time(NULL))
		state_selecting(ifi);
	else
		set_timeout(stop_selecting, state_selecting, ifi);
}

a1332 37
}

void
dhcpnak(struct interface_info *ifi, struct option_data *options, char *info)
{
	if (ifi->state != S_REBOOTING &&
	    ifi->state != S_REQUESTING &&
	    ifi->state != S_RENEWING &&
	    ifi->state != S_REBINDING) {
#ifdef DEBUG
		log_debug("Unexpected %s. State #%d", info, client->state);
#endif	/* DEBUG */
		return;
	}

	if (!ifi->active) {
#ifdef DEBUG
		log_debug("Unexpected %s. No active lease.", info);
#endif	/* DEBUG */
		return;
	}

	log_info("%s", info);

	/* XXX Do we really want to remove a NAK'd lease from the database? */
	if (!ifi->active->is_static) {
		TAILQ_REMOVE(&ifi->leases, ifi->active, next);
		free_client_lease(ifi->active);
	}

	ifi->active = NULL;

	/* Stop sending DHCPREQUEST packets. */
	cancel_timeout();

	ifi->state = S_INIT;
	state_init(ifi);
@


1.430
log
@We accept either the first offer received, or an offer for the
current address if one arrives inside select_timeout. So there
is no need to keep a list of received offers. Just keep the
best one and DECLINE the rest. Nuke now unused 'offered_leases'
TAILQ.

Also fixes the oddity that the *last* offer for the current
address is taken rather than the *first*.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.429 2017/06/17 15:53:03 krw Exp $	*/
d815 1
a815 1
	if (ifi->new == NULL) {
d821 1
a821 1
	if (BOOTP_LEASE(ifi->new)) {
d832 1
a832 1
		option = &ifi->new->options[DHO_DHCP_LEASE_TIME];
d838 1
a838 1
		option = &ifi->new->options[DHO_DHCP_RENEWAL_TIME];
d844 1
a844 1
		option = &ifi->new->options[DHO_DHCP_REBINDING_TIME];
d868 1
a868 1
	make_request(ifi, ifi->new);
d871 1
a871 1
	free_client_lease(ifi->new);
d900 3
a902 3
	ifi->new = lease;
	memcpy(ifi->new->ssid, ifi->ssid, sizeof(ifi->new->ssid));
	ifi->new->ssid_len = ifi->ssid_len;
d924 2
a925 2
	free(ifi->new->resolv_conf);
	ifi->new->resolv_conf = NULL;
d927 1
a927 1
	lease = apply_defaults(ifi->new);
d932 3
a934 3
	ifi->new->expiry = lease->expiry;
	ifi->new->renewal = lease->renewal;
	ifi->new->rebind = lease->rebind;
d941 2
a942 2
	    compare_lease(ifi->active, ifi->new) == 0) {
		ifi->new->resolv_conf = ifi->active->resolv_conf;
d944 2
a945 2
		ifi->active = ifi->new;
		ifi->new = NULL;
d952 1
a952 1
	ifi->new->resolv_conf = resolv_conf_contents(ifi,
d956 3
a958 3
	/* Replace the old active lease with the new one. */
	ifi->active = ifi->new;
	ifi->new = NULL;
d1104 2
a1105 2
		if (ifi->new == NULL) {
			ifi->new = lease;
d1108 2
a1109 2
			free_client_lease(ifi->new);
			ifi->new = lease;
d1111 1
a1111 1
		if (ifi->new != lease) {
a1406 2
	struct client_lease *lp;

d1409 2
a1410 3
	lp = get_recorded_lease(ifi);
	if (lp) {
		ifi->new = lp;
@


1.429
log
@DECLINE offers as they are deemed invalid. Decline them at the
first problem rather than continuing to look for other reasons
to decline them. Nuke is_invalid field since it is now unused.
More informative log message when a lease is determined to be
unacceptable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.428 2017/06/16 14:12:12 krw Exp $	*/
a566 1
	TAILQ_INIT(&ifi->offered_leases);
d811 1
a811 1
	struct client_lease *lease, *picked;
d815 1
a815 1
	if (TAILQ_EMPTY(&ifi->offered_leases)) {
a819 12
	picked = TAILQ_FIRST(&ifi->offered_leases);
	TAILQ_REMOVE(&ifi->offered_leases, picked, next);

	/* DECLINE the rest of the offers. */
	while (!TAILQ_EMPTY(&ifi->offered_leases)) {
		lease = TAILQ_FIRST(&ifi->offered_leases);
		TAILQ_REMOVE(&ifi->offered_leases, lease, next);
		make_decline(ifi, lease);
		send_decline(ifi);
		free_client_lease(lease);
	}

d821 1
a821 5
	if (BOOTP_LEASE(picked)) {
		struct option_data *option;

		ifi->new = picked;

d868 1
a868 1
	make_request(ifi, picked);
d871 1
a871 1
	free_client_lease(picked);
d1090 1
a1090 2
	struct dhcp_packet *packet = &ifi->recv_packet;
	struct client_lease *lease, *lp;
a1101 11
	/* If we've already seen this lease, don't record it again. */
	TAILQ_FOREACH(lp, &ifi->offered_leases, next) {
		if (!memcmp(&lp->address.s_addr, &packet->yiaddr,
		    sizeof(in_addr_t))) {
#ifdef DEBUG
			log_debug("Duplicate %s.", info);
#endif	/* DEBUG */
			return;
		}
	}

d1104 2
a1105 2
		if (TAILQ_EMPTY(&ifi->offered_leases)) {
			TAILQ_INSERT_HEAD(&ifi->offered_leases, lease, next);
d1108 7
a1114 5
			/* The expected lease - put it first. */
			TAILQ_INSERT_HEAD(&ifi->offered_leases, lease, next);
		} else {
			/* Put it at the end of the list. */
			TAILQ_INSERT_TAIL(&ifi->offered_leases, lease, next);
@


1.428
log
@Nuke 'is_bootp' field and just use a #define to check if the lease
has DHO_DHCP_MESSAGE_TYPE info.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.427 2017/06/15 17:06:17 krw Exp $	*/
d816 3
a818 6
	/* Take the first valid DHCPOFFER. */
	TAILQ_FOREACH_SAFE(picked, &ifi->offered_leases, next, lease) {
		if (picked->is_invalid == 0) {
			TAILQ_REMOVE(&ifi->offered_leases, picked, next);
			break;
		}
d820 4
a832 5
	if (!picked) {
		state_panic(ifi);
		return;
	}

d911 1
a911 5
	if (lease->is_invalid) {
		log_info("Unsatisfactory %s", info);
		make_decline(ifi, lease);
		send_decline(ifi);
		free_client_lease(lease);
d1132 12
a1146 11

	if (TAILQ_EMPTY(&ifi->offered_leases)) {
		TAILQ_INSERT_HEAD(&ifi->offered_leases, lease, next);
	} else if (lease->address.s_addr == ifi->requested_address.s_addr) {
		/* The expected lease - put it at the head of the list. */
		TAILQ_INSERT_HEAD(&ifi->offered_leases, lease, next);
	} else {
		/* Not the expected lease - put it at the end of the list. */
		TAILQ_INSERT_TAIL(&ifi->offered_leases, lease, next);
	}

d1185 4
a1188 1
 * parameters in the specified packet.
d1200 3
a1202 3
	if (!lease) {
		log_warnx("dhcpoffer: no memory to create lease.");
		return (NULL);
d1211 2
a1212 2
			log_warnx("dhcpoffer: unknown option %d", i);
			lease->is_invalid = 1;
d1224 5
a1228 3
			if (!res_hnok_list(buf))
				log_warnx("Bogus data for option %s",
				    dhcp_options[i].name);
d1238 3
a1240 3
				log_warnx("Bogus data for option %s",
				    dhcp_options[i].name);
				continue;
d1246 3
a1248 3
				log_warnx("Bogus data for option %s",
				    dhcp_options[i].name);
				continue;
d1264 1
a1264 1
			log_warnx("Missing required parameter %s",
d1266 1
a1266 1
			lease->is_invalid = 1;
d1278 1
a1278 1
		log_warnx("%s already configured on %s",
d1280 1
a1280 1
		lease->is_invalid = 1;
d1292 2
a1293 2
			log_warnx("dhcpoffer: no memory for server name.");
			lease->is_invalid = 1;
d1298 2
a1299 2
			log_warnx("Bogus server name %s", lease->server_name);
			lease->is_invalid = 1;
d1310 2
a1311 2
			log_warnx("dhcpoffer: no memory for filename.");
			lease->is_invalid = 1;
d1317 6
@


1.427
log
@Nuke unused parameter 'client_addr' from the 'handlers', i.e.
dhcpoffer(), dhcpack(), dhcpnak().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.426 2017/06/15 16:56:11 krw Exp $	*/
d770 2
a771 2
	/* If we don't remember an active lease, go straight to INIT. */
	if (!ifi->active || ifi->active->is_bootp) {
d838 1
a838 1
	if (!picked->options[DHO_DHCP_MESSAGE_TYPE].len) {
a1140 7
	/*
	 * If this lease was acquired through a BOOTREPLY, record that
	 * fact.
	 */
	if (!options[DHO_DHCP_MESSAGE_TYPE].len)
		lease->is_bootp = 1;

d1875 1
a1875 1
	strlcat(string, (lease->is_bootp) ? "  bootp;\n" : "", sizeof(string));
a2350 1
	newlease->is_bootp = oldlease->is_bootp;
d2511 1
a2511 1
	    active->is_bootp != new->is_bootp)
@


1.426
log
@Nuke unused parameter 'client_addr' from packet_to_lease().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.425 2017/06/14 20:27:08 krw Exp $	*/
d898 1
a898 2
dhcpack(struct interface_info *ifi, struct in_addr client_addr,
    struct option_data *options, char *info)
d1113 1
a1113 2
dhcpoffer(struct interface_info *ifi, struct in_addr client_addr,
    struct option_data *options, char *info)
d1329 1
a1329 2
dhcpnak(struct interface_info *ifi, struct in_addr client_addr,
    struct option_data *options, char *info)
@


1.425
log
@No need to be coy - call a "struct interface_info *" a
"struct interface_info *" and not a "void *".

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.424 2017/06/14 16:52:35 krw Exp $	*/
d156 1
a156 1
struct client_lease *packet_to_lease(struct interface_info *, struct in_addr,
d915 1
a915 1
	lease = packet_to_lease(ifi, client_addr, options);
d1141 1
a1141 1
	lease = packet_to_lease(ifi, client_addr, options);
d1204 1
a1204 2
packet_to_lease(struct interface_info *ifi, struct in_addr client_addr,
    struct option_data *options)
@


1.424
log
@Move active, new, offered_leases, leases from
client_state to interface_info.

Nuke empty struct client_state.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.423 2017/06/14 16:29:58 krw Exp $	*/
d133 10
a142 10
void state_preboot(void *);
void state_reboot(void *);
void state_init(void *);
void state_selecting(void *);
void state_bound(void *);
void state_panic(void *);

void send_discover(void *);
void send_request(void *);
void send_decline(void *);
d708 1
a708 1
state_preboot(void *xifi)
a709 1
	struct interface_info *ifi = xifi;
d751 1
a751 1
state_reboot(void *xifi)
a752 1
	struct interface_info *ifi = xifi;
d792 1
a792 1
state_init(void *xifi)
a793 2
	struct interface_info *ifi = xifi;

d810 1
a810 1
state_selecting(void *xifi)
a811 1
	struct interface_info *ifi = xifi;
d1090 1
a1090 1
state_bound(void *xifi)
a1091 1
	struct interface_info *ifi = xifi;
d1375 1
a1375 1
send_discover(void *xifi)
a1376 1
	struct interface_info *ifi = xifi;
d1439 1
a1439 1
state_panic(void *xifi)
a1440 1
	struct interface_info *ifi = xifi;
d1463 1
a1463 1
send_request(void *xifi)
a1464 1
	struct interface_info *ifi = xifi;
d1568 1
a1568 1
send_decline(void *xifi)
a1569 2
	struct interface_info *ifi = xifi;

@


1.423
log
@Move state, destination, interval, requested_address from
client_state to interface_info.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.422 2017/06/14 16:09:42 krw Exp $	*/
a232 1
	struct client_state *client = ifi->client;
d296 2
a297 2
			    inet_ntoa(client->active->address),
			    (long long)(client->active->renewal -
d341 2
a342 2
		if (adding.s_addr == INADDR_ANY && client->active &&
		    a.s_addr == client->active->address.s_addr) {
d345 1
a345 1
			    inet_ntoa(client->active->address));
d424 1
a424 1
	if (client->active && client->active->resolv_conf &&
d426 2
a427 2
		write_resolv_conf(client->active->resolv_conf,
		    strlen(client->active->resolv_conf));
d429 1
a429 1
done:
d433 1
a433 1
die:
d566 2
a567 5
	ifi->client = calloc(1, sizeof(struct client_state));
	if (ifi->client == NULL)
		fatalx("client calloc");
	TAILQ_INIT(&ifi->client->leases);
	TAILQ_INIT(&ifi->client->offered_leases);
a754 1
	struct client_state *client = ifi->client;
d763 4
a766 4
	if (client->active) {
		if (client->active->expiry <= cur_time)
			client->active = NULL;
		else if (addressinuse(ifi, client->active->address, ifname) &&
d768 1
a768 1
			client->active = NULL;
d770 1
a770 1
		client->active = get_recorded_lease(ifi);
d773 1
a773 1
	if (!client->active || client->active->is_bootp) {
d780 1
a780 1
	make_request(ifi, client->active);
a796 1
	struct client_state *client = ifi->client;
d799 1
a799 1
	make_discover(ifi, client->active);
a816 1
	struct client_state *client = ifi->client;
d822 1
a822 1
	TAILQ_FOREACH_SAFE(picked, &client->offered_leases, next, lease) {
d824 1
a824 1
			TAILQ_REMOVE(&client->offered_leases, picked, next);
d829 3
a831 3
	while (!TAILQ_EMPTY(&client->offered_leases)) {
		lease = TAILQ_FIRST(&client->offered_leases);
		TAILQ_REMOVE(&client->offered_leases, lease, next);
d846 1
a846 1
		client->new = picked;
d858 1
a858 1
		option = &client->new->options[DHO_DHCP_LEASE_TIME];
d864 1
a864 1
		option = &client->new->options[DHO_DHCP_RENEWAL_TIME];
d870 1
a870 1
		option = &client->new->options[DHO_DHCP_REBINDING_TIME];
a905 1
	struct client_state *client = ifi->client;
d931 3
a933 3
	client->new = lease;
	memcpy(client->new->ssid, ifi->ssid, sizeof(client->new->ssid));
	client->new->ssid_len = ifi->ssid_len;
a943 1
	struct client_state *client = ifi->client;
d955 2
a956 2
	free(client->new->resolv_conf);
	client->new->resolv_conf = NULL;
d958 1
a958 1
	lease = apply_defaults(client->new);
d963 3
a965 3
	client->new->expiry = lease->expiry;
	client->new->renewal = lease->renewal;
	client->new->rebind = lease->rebind;
d972 5
a976 5
	    compare_lease(client->active, client->new) == 0) {
		client->new->resolv_conf = client->active->resolv_conf;
		client->active->resolv_conf = NULL;
		client->active = client->new;
		client->new = NULL;
d978 2
a979 2
		    inet_ntoa(client->active->address),
		    (long long)(client->active->renewal - time(NULL)));
d983 1
a983 1
	client->new->resolv_conf = resolv_conf_contents(ifi,
d988 2
a989 2
	client->active = client->new;
	client->new = NULL;
d1017 1
a1017 1
	add_address(client->active->address, mask);
d1021 1
a1021 1
		    client->active->address);
d1025 1
a1025 1
		    client->active->address);
d1039 1
a1039 1
				    client->active->address);
d1042 1
a1042 1
			add_default_route(client->active->address, gateway);
d1046 1
a1046 1
			    client->active->address);
d1050 1
a1050 1
	rewrite_option_db(ifi, client->active, lease);
d1059 1
a1059 1
	TAILQ_FOREACH_SAFE(lease, &client->leases, next, pl) {
d1062 1
a1062 1
		if (client->active == NULL)
d1064 1
a1064 1
		if (client->active->ssid_len != lease->ssid_len)
d1066 1
a1066 1
		if (memcmp(client->active->ssid, lease->ssid, lease->ssid_len)
d1069 1
a1069 1
		if (client->active == lease)
d1072 2
a1073 2
		    client->active->address.s_addr) {
			TAILQ_REMOVE(&client->leases, lease, next);
d1077 2
a1078 2
	if (!client->active->is_static && !seen)
		TAILQ_INSERT_HEAD(&client->leases, client->active,  next);
d1086 1
a1086 1
	set_timeout(client->active->renewal, state_bound, ifi);
a1097 1
	struct client_state *client = ifi->client;
d1102 1
a1102 1
	make_request(ifi, client->active);
d1105 1
a1105 1
	opt = &client->active->options[DHO_DHCP_SERVER_IDENTIFIER];
a1122 1
	struct client_state *client = ifi->client;
d1137 1
a1137 1
	TAILQ_FOREACH(lp, &client->offered_leases, next) {
d1159 2
a1160 2
	if (TAILQ_EMPTY(&client->offered_leases)) {
		TAILQ_INSERT_HEAD(&client->offered_leases, lease, next);
d1163 1
a1163 1
		TAILQ_INSERT_HEAD(&client->offered_leases, lease, next);
d1166 1
a1166 1
		TAILQ_INSERT_TAIL(&client->offered_leases, lease, next);
a1340 2
	struct client_state *client = ifi->client;

d1351 1
a1351 1
	if (!client->active) {
d1361 3
a1363 3
	if (!client->active->is_static) {
		TAILQ_REMOVE(&client->leases, client->active, next);
		free_client_lease(client->active);
d1366 1
a1366 1
	client->active = NULL;
a1448 1
	struct client_state *client = ifi->client;
d1455 1
a1455 1
		client->new = lp;
a1473 1
	struct client_state *client = ifi->client;
d1510 3
a1512 3
	    cur_time > client->active->expiry) {
		if (client->active)
			delete_address(client->active->address);
d1536 2
a1537 2
	    client->active->expiry)
		ifi->interval = client->active->expiry - cur_time + 1;
d1547 1
a1547 1
	    cur_time > client->active->rebind ||
d1554 1
a1554 1
		from.s_addr = client->active->address.s_addr;
a1809 1
	struct client_state *client = ifi->client;
d1823 2
a1824 2
	 * TAILQ client->leases as they were read. Therefore write out
	 * the leases in client->leases in reverse order to recreate
d1828 1
a1828 1
	TAILQ_FOREACH_REVERSE(lp, &client->leases, _leases, next) {
a2621 1
	struct client_state	*client = ifi->client;
d2629 1
a2629 1
	TAILQ_FOREACH(lp, &client->leases, next) {
@


1.422
log
@Move xid, secs, first_sending, startup_time fields from
client_state to interface_info.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.421 2017/06/14 15:57:25 krw Exp $	*/
d394 1
a394 1
				if (client->state == S_PREBOOT) {
d398 1
a398 1
					client->state = S_REBOOTING;
d687 1
a687 1
		ifi->client->state = S_REBOOTING;
d690 1
a690 1
		ifi->client->state = S_PREBOOT;
a714 1
	struct client_state *client = ifi->client;
d742 1
a742 1
		client->state = S_REBOOTING;
d747 1
a747 1
		client->state = S_PREBOOT;
d779 1
a779 1
		client->state = S_INIT;
d787 1
a787 1
	client->destination.s_addr = INADDR_BROADCAST;
d789 1
a789 1
	client->interval = 0;
d807 2
a808 2
	client->destination.s_addr = INADDR_BROADCAST;
	client->state = S_SELECTING;
d810 1
a810 1
	client->interval = 0;
d884 1
a884 1
		client->state = S_REQUESTING;
d890 2
a891 2
	client->destination.s_addr = INADDR_BROADCAST;
	client->state = S_REQUESTING;
d894 1
a894 1
	client->interval = 0;
d916 4
a919 4
	if (client->state != S_REBOOTING &&
	    client->state != S_REQUESTING &&
	    client->state != S_RENEWING &&
	    client->state != S_REBINDING) {
d934 1
a934 1
		client->state = S_INIT;
d980 1
a980 1
	if ((ifi->flags & IFI_IS_RESPONSIBLE) && client->state == S_RENEWING &&
d1092 1
a1092 1
	client->state = S_BOUND;
d1114 1
a1114 1
	dest = &client->destination;
d1123 2
a1124 2
	client->interval = 0;
	client->state = S_RENEWING;
d1138 1
a1138 1
	if (client->state != S_SELECTING) {
d1172 1
a1172 1
	} else if (lease->address.s_addr == client->requested_address.s_addr) {
d1354 4
a1357 4
	if (client->state != S_REBOOTING &&
	    client->state != S_REQUESTING &&
	    client->state != S_RENEWING &&
	    client->state != S_REBINDING) {
d1384 1
a1384 1
	client->state = S_INIT;
a1396 1
	struct client_state *client = ifi->client;
d1419 2
a1420 2
	if (!client->interval)
		client->interval = config->initial_interval;
d1422 1
a1422 1
		client->interval += arc4random_uniform(2 * client->interval);
d1426 2
a1427 2
	if (client->interval > config->backoff_cutoff)
		client->interval = config->backoff_cutoff;
d1431 1
a1431 1
	if (cur_time + client->interval >
d1433 1
a1433 1
		client->interval = (ifi->first_sending +
d1444 1
a1444 1
	    (long long)client->interval);
d1451 1
a1451 1
		set_timeout_interval(client->interval, send_discover, ifi);
d1470 1
a1470 1
		client->state = S_REQUESTING;
d1479 1
a1479 1
	client->state = S_INIT;
d1512 1
a1512 1
	if (client->state == S_REBOOTING && interval >
d1514 1
a1514 1
		client->state = S_INIT;
d1524 1
a1524 1
	if (client->state != S_REQUESTING &&
d1528 1
a1528 1
		client->state = S_INIT;
d1534 3
a1536 3
	if (!client->interval) {
		if (client->state == S_REBOOTING)
			client->interval = config->reboot_timeout;
d1538 1
a1538 1
			client->interval = config->initial_interval;
d1540 1
a1540 1
		client->interval += arc4random_uniform(2 * client->interval);
d1543 2
a1544 2
	if (client->interval > config->backoff_cutoff)
		client->interval = config->backoff_cutoff;
d1550 1
a1550 1
	if (client->state != S_REQUESTING && cur_time + client->interval >
d1552 1
a1552 1
		client->interval = client->active->expiry - cur_time + 1;
d1560 2
a1561 2
	if (client->state == S_REQUESTING ||
	    client->state == S_REBOOTING ||
d1566 1
a1566 1
		destination.sin_addr.s_addr = client->destination.s_addr;
d1568 1
a1568 1
	if (client->state != S_REQUESTING)
d1574 1
a1574 1
	if (client->state == S_REQUESTING)
d1588 1
a1588 1
	set_timeout_interval(client->interval, send_request, ifi);
a1603 1
	struct client_state *client = ifi->client;
d1624 1
a1624 1
		client->requested_address = lease->address;
d1629 1
a1629 1
		client->requested_address.s_addr = INADDR_ANY;
a1666 1
	struct client_state *client = ifi->client;
d1689 1
a1689 1
	if (client->state == S_REQUESTING) {
d1695 3
a1697 3
	if (client->state == S_REQUESTING ||
	    client->state == S_REBOOTING) {
		client->requested_address = lease->address;
d1730 3
a1732 3
	if (client->state == S_BOUND ||
	    client->state == S_RENEWING ||
	    client->state == S_REBINDING)
@


1.421
log
@Start consolidating client_state into interface_info. First
fields to move: recv_packet, sent_packet and sent_packet_length.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.420 2017/06/14 15:39:55 krw Exp $	*/
d263 1
a263 1
			if (rtm->rtm_seq == (int32_t)client->xid) {
d684 1
a684 1
	time(&ifi->client->startup_time);
d722 1
a722 1
	interval = (int)(cur_time - client->startup_time);
d785 1
a785 1
	client->xid = arc4random();
d789 1
a789 1
	client->first_sending = time(NULL);
d805 1
a805 1
	client->xid = arc4random();
d810 1
a810 1
	client->first_sending = time(NULL);
d893 1
a893 1
	client->first_sending = time(NULL);
d1112 1
a1112 1
	client->xid = arc4random();
d1123 1
a1123 1
	client->first_sending = time(NULL);
d1169 1
a1169 1
	stop_selecting = client->first_sending + config->select_interval;
d1407 1
a1407 1
	interval = cur_time - client->first_sending;
d1434 3
a1436 3
	    client->first_sending + config->timeout)
		client->interval = (client->first_sending +
			 config->timeout) - cur_time + 1;
d1443 1
a1443 1
	client->secs = packet->secs;
d1500 1
a1500 1
	interval = (int)(cur_time - client->first_sending);
d1577 1
a1577 1
		packet->secs = client->secs;
d1654 1
a1654 1
	packet->xid = client->xid;
d1726 1
a1726 1
	packet->xid = client->xid;
a1751 1
	struct client_state *client = ifi->client;
d1794 1
a1794 1
	packet->xid = client->xid;
d2606 1
a2606 1
	rtm.rtm_seq = ifi->client->xid = arc4random();
@


1.420
log
@No need for two 'flags' fields. Consolidate into one, fixing
value of IFI_HUP while passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.419 2017/06/13 15:49:32 krw Exp $	*/
d1135 1
a1135 1
	struct dhcp_packet *packet = &client->recv_packet;
d1225 1
a1225 2
	struct client_state *client = ifi->client;
	struct dhcp_packet *packet = &client->recv_packet;
d1399 1
a1399 1
	struct dhcp_packet *packet = &client->sent_packet;
d1491 1
a1491 1
	struct dhcp_packet *packet = &client->sent_packet;
d1608 1
a1608 1
	struct dhcp_packet *packet = &client->sent_packet;
d1646 3
a1648 3
	client->sent_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->sent_packet_length < BOOTP_MIN_LEN)
		client->sent_packet_length = BOOTP_MIN_LEN;
d1672 1
a1672 1
	struct dhcp_packet *packet = &client->sent_packet;
d1718 3
a1720 3
	client->sent_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->sent_packet_length < BOOTP_MIN_LEN)
		client->sent_packet_length = BOOTP_MIN_LEN;
d1754 1
a1754 1
	struct dhcp_packet *packet = &client->sent_packet;
d1787 3
a1789 3
	client->sent_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->sent_packet_length < BOOTP_MIN_LEN)
		client->sent_packet_length = BOOTP_MIN_LEN;
@


1.419
log
@Rename 'packet' field to 'recv_packet' and 'bootrequest_packet'
field to 'sent_packet'. Also 'bootrequest_packet_length' to
'sent_packet_length'.

Adopt consistent idiom of a local variable 'packet' to point at
packet being manipulated.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.418 2017/05/26 14:57:41 krw Exp $	*/
d264 2
a265 2
				client->flags |= IN_CHARGE;
			} else if ((client->flags & IN_CHARGE) != 0) {
d300 1
a300 1
			client->flags |= IS_RESPONSIBLE;
d304 1
a304 1
		if ((client->flags & IS_RESPONSIBLE) == 0)
d339 1
a339 1
		if ((client->flags & IS_RESPONSIBLE) == 0)
d350 1
a350 1
			client->flags &= ~IS_RESPONSIBLE;
d426 1
a426 1
	    client->flags & IS_RESPONSIBLE)
d981 1
a981 1
	if ((client->flags & IS_RESPONSIBLE) && client->state == S_RENEWING &&
d2614 1
a2614 1
	while ((ifi->client->flags & IN_CHARGE) == 0) {
@


1.418
log
@Move logic to set default client-identifier into a
separate function so it can be used in multiple
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.417 2017/05/26 14:35:49 krw Exp $	*/
d1135 1
d1150 1
a1150 1
		if (!memcmp(&lp->address.s_addr, &client->packet.yiaddr,
d1226 1
d1305 1
a1305 1
	lease->address.s_addr = client->packet.yiaddr.s_addr;
d1315 1
a1315 1
	lease->next_server.s_addr = client->packet.siaddr.s_addr;
d1320 1
a1320 1
	    client->packet.sname[0]) {
d1326 1
a1326 2
		memcpy(lease->server_name, client->packet.sname,
		    DHCP_SNAME_LEN);
d1337 1
a1337 1
	    client->packet.file[0]) {
d1344 1
a1344 1
		memcpy(lease->filename, client->packet.file, DHCP_FILE_LEN);
d1400 1
d1441 1
a1441 1
		client->bootrequest_packet.secs = htons(interval);
d1443 2
a1444 2
		client->bootrequest_packet.secs = htons(UINT16_MAX);
	client->secs = client->bootrequest_packet.secs;
d1492 1
d1578 1
a1578 1
		client->bootrequest_packet.secs = client->secs;
d1581 1
a1581 1
			client->bootrequest_packet.secs = htons(interval);
d1583 1
a1583 1
			client->bootrequest_packet.secs = htons(UINT16_MAX);
d1609 1
a1609 1
	struct dhcp_packet *packet = &client->bootrequest_packet;
d1647 3
a1649 3
	client->bootrequest_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->bootrequest_packet_length < BOOTP_MIN_LEN)
		client->bootrequest_packet_length = BOOTP_MIN_LEN;
d1673 1
a1673 1
	struct dhcp_packet *packet = &client->bootrequest_packet;
d1719 3
a1721 3
	client->bootrequest_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->bootrequest_packet_length < BOOTP_MIN_LEN)
		client->bootrequest_packet_length = BOOTP_MIN_LEN;
d1755 1
a1755 1
	struct dhcp_packet *packet = &client->bootrequest_packet;
d1788 3
a1790 3
	client->bootrequest_packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->bootrequest_packet_length < BOOTP_MIN_LEN)
		client->bootrequest_packet_length = BOOTP_MIN_LEN;
@


1.417
log
@Whitespace rectification of a couple of mis-indentations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.416 2017/05/26 14:25:14 krw Exp $	*/
d161 1
a447 1
	struct option_data *opt;
a578 7
	 *
	 * Check both len && data so
	 *
	 *     send dhcp-client-identifier "";
	 *
	 * can be used to suppress sending the default client
	 * identifier.
d580 1
a580 10
	opt = &config->send_options[DHO_DHCP_CLIENT_IDENTIFIER];
	if (opt->len == 0 && opt->data == NULL) {
		opt->data = calloc(1, ETHER_ADDR_LEN + 1);
		if (opt->data == NULL)
			fatalx("no memory for default client identifier");
		opt->data[0] = HTYPE_ETHER;
		memcpy(&opt->data[1], ifi->hw_address.ether_addr_octet,
		    ETHER_ADDR_LEN);
		opt->len = ETHER_ADDR_LEN + 1;
	}
d2671 26
@


1.416
log
@Move the two loops through the leases file
looking for a valid recorded lease into a separate
function and thus make them consistent.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.415 2017/04/12 14:08:15 krw Exp $	*/
d2078 4
a2081 4
		} else if (!isalnum(ch) && ch != '-' && ch != '_')
				return (0);
		else if (ch == '_' && warn == 0) {
				log_warnx("warning: hostname %s contains an "
@


1.415
log
@RTM_PROTO3 messages should not trigger a resolv.conf check.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.414 2017/04/11 13:59:27 krw Exp $	*/
d161 1
a777 1
	struct client_lease *lp;
a778 1
	int i;
d791 2
a792 24
	}

	/* Run through the list of leases and see if one can be used. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	TAILQ_FOREACH(lp, &client->leases, next) {
		if (lp->ssid_len != ifi->ssid_len)
			continue;
		if (memcmp(lp->ssid, ifi->ssid, lp->ssid_len) != 0)
			continue;
		if ((lp->options[i].len != 0) && ((lp->options[i].len !=
		    config->send_options[i].len) ||
		    memcmp(lp->options[i].data, config->send_options[i].data,
		    lp->options[i].len)))
			continue;
		if (addressinuse(ifi, lp->address, ifname) &&
		    strncmp(ifname, ifi->name, IF_NAMESIZE) != 0)
			continue;
		if (client->active || lp->is_static)
			break;
		if (lp->expiry > cur_time) {
			client->active = lp;
			break;
		}
	}
a1479 1
	char ifname[IF_NAMESIZE];
a1480 1
	time_t cur_time;
a1481 1
	time(&cur_time);
d1484 2
a1485 20
	/* Run through the list of leases and see if one can be used. */
	time(&cur_time);
	TAILQ_FOREACH(lp, &client->leases, next) {
		if (lp->ssid_len != ifi->ssid_len)
			continue;
		if (memcmp(lp->ssid, ifi->ssid, lp->ssid_len) != 0)
			continue;
		if (addressinuse(ifi, lp->address, ifname) &&
		    strncmp(ifname, ifi->name, IF_NAMESIZE) != 0)
			continue;
		if (lp->is_static) {
			set_lease_times(lp);
			log_info("Trying static lease %s",
			    inet_ntoa(lp->address));
		} else if (lp->expiry <= cur_time) {
			continue;
		} else
			log_info("Trying recorded lease %s",
			    inet_ntoa(lp->address));

a1488 1

d2650 37
@


1.414
log
@Shuffle route/interface changing functions together into kroute.c. Try to
group related functions in kroute.c together and comment them a bit.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.413 2017/04/11 10:40:14 krw Exp $	*/
a262 1
				goto done;
d269 1
@


1.413
log
@Fold priv_write_file() into its only remaining user
priv_write_resolv_conf() and move the latter into kroute.c
with all its priv_ friends.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.412 2017/04/10 21:47:44 krw Exp $	*/
a108 3
struct in_addr deleting;
struct in_addr adding;

a124 4
char		*resolv_conf_contents(struct interface_info *ifi,
		     struct option_data *, struct option_data *,
		     struct option_data *);
void		 write_resolv_conf(u_int8_t *, size_t);
a129 5
void add_direct_route(struct in_addr, struct in_addr, struct in_addr);
void add_default_route(struct in_addr, struct in_addr);
void add_static_routes(struct option_data *, struct in_addr);
void add_classless_static_routes(struct option_data *, struct in_addr);

a2598 215
}

/*
 * Update resolv.conf.
 */
char *
resolv_conf_contents(struct interface_info *ifi,
    struct option_data *domainname, struct option_data *nameservers,
    struct option_data *domainsearch)
{
	char *dn, *ns, *nss[MAXNS], *contents, *courtesy, *p, *buf;
	size_t len;
	int i, rslt;

	memset(nss, 0, sizeof(nss));

	if (domainsearch->len) {
		buf = pretty_print_domain_search(domainsearch->data,
		    domainsearch->len);
		if (buf == NULL)
			dn = strdup("");
		else {
			rslt = asprintf(&dn, "search %s\n", buf);
			if (rslt == -1)
				dn = NULL;
		}
	} else if (domainname->len) {
		rslt = asprintf(&dn, "search %s\n",
		    pretty_print_option(DHO_DOMAIN_NAME, domainname, 0));
		if (rslt == -1)
			dn = NULL;
	} else
		dn = strdup("");
	if (dn == NULL)
		fatalx("no memory for domainname");

	if (nameservers->len) {
		ns = pretty_print_option(DHO_DOMAIN_NAME_SERVERS, nameservers,
		    0);
		for (i = 0; i < MAXNS; i++) {
			p = strsep(&ns, " ");
			if (p == NULL)
				break;
			if (*p == '\0')
				continue;
			rslt = asprintf(&nss[i], "nameserver %s\n", p);
			if (rslt == -1)
				fatalx("no memory for nameserver");
		}
	}

	len = strlen(dn);
	for (i = 0; i < MAXNS; i++)
		if (nss[i])
			len += strlen(nss[i]);

	if (len > 0 && config->resolv_tail)
		len += strlen(config->resolv_tail);

	if (len == 0) {
		free(dn);
		return (NULL);
	}

	rslt = asprintf(&courtesy, "# Generated by %s dhclient\n", ifi->name);
	if (rslt == -1)
		fatalx("no memory for courtesy line");
	len += strlen(courtesy);

	len++; /* Need room for terminating NUL. */
	contents = calloc(1, len);
	if (contents == NULL)
		fatalx("no memory for resolv.conf contents");

	strlcat(contents, courtesy, len);
	free(courtesy);

	strlcat(contents, dn, len);
	free(dn);

	for (i = 0; i < MAXNS; i++) {
		if (nss[i]) {
			strlcat(contents, nss[i], len);
			free(nss[i]);
		}
	}

	if (config->resolv_tail)
		strlcat(contents, config->resolv_tail, len);

	return (contents);
}

void
write_resolv_conf(u_int8_t *contents, size_t sz)
{
	int rslt;

	rslt = imsg_compose(unpriv_ibuf, IMSG_WRITE_RESOLV_CONF,
	    0, 0, -1, contents, sz);
	if (rslt == -1)
		log_warn("write_resolv_conf: imsg_compose");

	flush_unpriv_ibuf("write_resolv_conf");
}

/*
 * add_direct_route is the equivalent of
 *
 *     route add -net $dest -netmask $mask -cloning -iface $iface
 */
void
add_direct_route(struct in_addr dest, struct in_addr mask,
    struct in_addr iface)
{
	struct in_addr ifa = { INADDR_ANY };

	add_route(dest, mask, iface, ifa,
	    RTA_DST | RTA_NETMASK | RTA_GATEWAY, RTF_CLONING | RTF_STATIC);
}

/*
 * add_default_route is the equivalent of
 *
 *	route -q $rdomain add default -iface $router
 *
 *	or
 *
 *	route -q $rdomain add default $router
 */
void
add_default_route(struct in_addr addr, struct in_addr gateway)
{
	struct in_addr netmask, dest;
	int addrs, flags;

	memset(&netmask, 0, sizeof(netmask));
	memset(&dest, 0, sizeof(dest));
	addrs = RTA_DST | RTA_NETMASK;
	flags = 0;

	/*
	 * When 'addr' and 'gateway' are identical the desired behaviour is
	 * to emulate the '-iface' variant of 'route'. This is done by
	 * claiming there is no gateway address to use.
	 */
	if (memcmp(&gateway, &addr, sizeof(addr)) != 0) {
		addrs |= RTA_GATEWAY | RTA_IFA;
		flags |= RTF_GATEWAY | RTF_STATIC;
	}

	add_route(dest, netmask, gateway, addr, addrs, flags);
}

void
add_static_routes(struct option_data *static_routes, struct in_addr iface)
{
	struct in_addr		 dest, netmask, gateway;
	struct in_addr		 *addr;
	int			 i;

	netmask.s_addr = INADDR_ANY;	/* Not used for CLASSFULL! */

	for (i = 0; (i + 2*sizeof(*addr)) <= static_routes->len;
	    i += 2*sizeof(*addr)) {
		addr = (struct in_addr *)&static_routes->data[i];
		if (addr->s_addr == INADDR_ANY)
			continue; /* RFC 2132 says 0.0.0.0 is not allowed. */

		dest.s_addr = addr->s_addr;
		gateway.s_addr = (addr+1)->s_addr;

		/* XXX Order implies priority but we're ignoring that. */
		add_route(dest, netmask, gateway, iface,
		    RTA_DST | RTA_GATEWAY | RTA_IFA, RTF_GATEWAY | RTF_STATIC);
	}
}

void
add_classless_static_routes(struct option_data *opt, struct in_addr iface)
{
	struct in_addr	 dest, netmask, gateway;
	unsigned int	 i, bits, bytes;

	i = 0;
	while (i < opt->len) {
		bits = opt->data[i++];
		bytes = (bits + 7) / 8;

		if (bytes > sizeof(netmask))
			return;
		else if (i + bytes > opt->len)
			return;

		if (bits)
			netmask.s_addr = htonl(0xffffffff << (32 - bits));
		else
			netmask.s_addr = INADDR_ANY;

		memcpy(&dest, &opt->data[i], bytes);
		dest.s_addr = dest.s_addr & netmask.s_addr;
		i += bytes;

		if (i + sizeof(gateway) > opt->len)
			return;
		memcpy(&gateway, &opt->data[i], sizeof(gateway));
		i += sizeof(gateway);

		if (gateway.s_addr == INADDR_ANY)
			add_direct_route(dest, netmask, iface);
		else
			add_route(dest, netmask, gateway, iface,
			    RTA_DST | RTA_GATEWAY | RTA_NETMASK | RTA_IFA,
			    RTF_GATEWAY | RTF_STATIC);
	}
@


1.412
log
@Rework -L logic to use the idiom used in handling the leases file.
i.e. open FILE during program set up and use the FILE created for
the rest of the program lifetime after dropping privilege and
pledge()'ing. No need for passing messages to the priv process.

Tweak lease file handling a bit in passing.

Monitoring the -L file with external programs like sysutils/entr
still works.

Looks good to sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.411 2017/04/09 20:44:13 krw Exp $	*/
a2550 28
priv_write_file(char *path, int flags, mode_t mode,
    u_int8_t *contents, size_t sz)
{
	ssize_t n;
	int fd;

	fd = open(path, flags, mode);
	if (fd == -1) {
		log_warn("Couldn't open '%s'", path);
		return;
	}

	n = write(fd, contents, sz);
	if (n == -1)
		log_warn("Couldn't write contents to '%s'", path);
	else if ((size_t)n < sz)
		log_warnx("Short contents write to '%s' (%zd vs %zu)", path,
		    n, sz);

	if (fchown(fd, 0, 0) == -1)
		log_warn("fchown(fd, %d, %d) of '%s' failed", 0, 0, path);
	if (fchmod(fd, mode) == -1)
		log_warn("fchmod(fd, 0x%x) of '%s' failed", mode, path);

	close(fd);
}

void
a2714 22
}

void
priv_write_resolv_conf(struct interface_info *ifi, struct imsg *imsg)
{
	u_int8_t *contents;
	size_t sz;

	if (imsg->hdr.len < IMSG_HEADER_SIZE) {
		log_warnx("short IMSG_WRITE_RESOLV_CONF");
		return;
	}

	if (!resolv_conf_priority(ifi))
		return;

	contents = imsg->data;
	sz = imsg->hdr.len - IMSG_HEADER_SIZE;

	priv_write_file("/etc/resolv.conf",
	    O_WRONLY | O_CREAT | O_TRUNC,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, contents, sz);
@


1.411
log
@Seven casts, a couple of tweaks and CFLAGS+=-Wsign-compare for the
win.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.410 2017/04/08 20:16:04 krw Exp $	*/
a131 1
void		 write_option_db(u_int8_t *, size_t);
d179 1
d413 4
a416 2
				if (strlen(path_option_db))
					write_option_db("", 0);
a643 9
	if ((fd = open(path_dhclient_db,
	    O_RDONLY|O_EXLOCK|O_CREAT|O_NOFOLLOW, 0640)) == -1)
		fatal("can't open and lock %s", path_dhclient_db);
	read_client_leases(ifi);
	if ((leaseFile = fopen(path_dhclient_db, "w")) == NULL)
		fatal("can't open %s", path_dhclient_db);
	rewrite_client_leases(ifi);
	close(fd);

d670 14
a1908 1
	fflush(leaseFile);
a1941 1
	u_int8_t db[8192];
a1942 1
	size_t n;
d1944 1
a1944 1
	if (strlen(path_option_db) == 0)
d1947 1
a1947 1
	memset(db, 0, sizeof(db));
d1950 3
a1952 5
	if (leasestr) {
		n = strlcat(db, leasestr, sizeof(db));
		if (n >= sizeof(db))
			log_warnx("cannot fit offered lease into option db");
	} else
d1956 3
a1958 5
	if (leasestr) {
		n = strlcat(db, leasestr, sizeof(db));
		if (n >= sizeof(db))
			log_warnx("cannot fit effective lease into option db");
	} else
d1961 3
a1963 1
	write_option_db(db, strlen(db));
a2547 32
}

void
write_option_db(u_int8_t *contents, size_t sz)
{
	int rslt;

	rslt = imsg_compose(unpriv_ibuf, IMSG_WRITE_OPTION_DB,
	    0, 0, -1, contents, sz);
	if (rslt == -1)
		log_warn("write_option_db: imsg_compose");

	flush_unpriv_ibuf("write_option_db");
}

void
priv_write_option_db(struct imsg *imsg)
{
	u_int8_t *contents;
	size_t sz;

	if (imsg->hdr.len < IMSG_HEADER_SIZE) {
		log_warnx("short IMSG_WRITE_OPTION_DB");
		return;
	}

	contents = imsg->data;
	sz = imsg->hdr.len - IMSG_HEADER_SIZE;

	priv_write_file(path_option_db,
	    O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW,
	    S_IRUSR | S_IWUSR | S_IRGRP, contents, sz);
@


1.410
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.409 2017/04/08 17:00:10 krw Exp $	*/
d259 2
d263 1
a263 1
	if (n < sizeof(rtm->rtm_msglen) || n < rtm->rtm_msglen ||
d273 1
a273 1
			if (rtm->rtm_seq == client->xid) {
d625 1
a625 1
		if (sb.st_size > 0 && sb.st_size < SIZE_MAX) {
d2596 1
a2596 1
	else if (n < sz)
@


1.409
log
@Replace a mess of snprintf() dances with easier to read code using
strlcat(). Shorter, clearer, fewer signed vs unsigned questions.

Shrink static buffer for the string version of an option value from
32K to 8K. Since the string version of the entire lease is constructed
in a 8K buffer, bigger option values are pointless.

Use 8K of the saved space for a static buffer for pretty_print_string()
and use it rather scribbling intermediate values into the final
destination.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.408 2017/04/07 15:03:00 krw Exp $	*/
d2279 2
a2280 1
	int s, len;
d2871 1
a2871 1
	int		 bits, bytes, i;
@


1.408
log
@Simply decoding of domain search option. No intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.407 2017/04/04 15:15:48 krw Exp $	*/
d167 1
d1962 8
d1974 2
a1975 1
	static char leasestr[8192];
d1977 12
a1988 13
	char *p;
	size_t sz, rsltsz;
	int i, rslt;

	sz = sizeof(leasestr);
	p = leasestr;
	memset(p, 0, sz);

	rslt = snprintf(p, sz, "%s {\n"
	    "%s  interface \"%s\";\n  fixed-address %s;\n",
	    type, (lease->is_bootp) ? "  bootp;\n" : "", ifi->name,
	    inet_ntoa(lease->address));
	if (rslt == -1 || rslt >= sz)
d1990 1
a1990 2
	p += rslt;
	sz -= rslt;
d1992 3
a1994 1
	rslt = snprintf(p, sz, "  next-server %s;\n",
a1995 4
	if (rslt == -1 || rslt >= sz)
		return (NULL);
	p += rslt;
	sz -= rslt;
d1998 1
a1998 6
		rslt = snprintf(p, sz, "  filename ");
		if (rslt == -1 || rslt >= sz)
			return (NULL);
		p += rslt;
		sz -= rslt;
		rslt = pretty_print_string(p, sz, lease->filename,
d2000 1
a2000 6
		if (rslt == -1 || rslt >= sz)
			return (NULL);
		p += rslt;
		sz -= rslt;
		rslt = snprintf(p, sz, ";\n");
		if (rslt == -1 || rslt >= sz)
d2002 1
a2002 2
		p += rslt;
		sz -= rslt;
d2005 1
a2005 6
		rslt = snprintf(p, sz, "  server-name ");
		if (rslt == -1 || rslt >= sz)
			return (NULL);
		p += rslt;
		sz -= rslt;
		rslt = pretty_print_string(p, sz, lease->server_name,
d2007 1
a2007 6
		if (rslt == -1 || rslt >= sz)
			return (NULL);
		p += rslt;
		sz -= rslt;
		rslt = snprintf(p, sz, ";\n");
		if (rslt == -1 || rslt >= sz)
d2009 2
a2010 2
		p += rslt;
		sz -= rslt;
d2013 2
a2014 2
		rslt = snprintf(p, sz, "  ssid ");
		if (rslt == -1 || rslt >= sz)
d2016 1
a2016 13
		p += rslt;
		sz -= rslt;
		rslt = pretty_print_string(p, sz, lease->ssid,
		    lease->ssid_len, 1);
		if (rslt == -1 || rslt >= sz)
			return (NULL);
		p += rslt;
		sz -= rslt;
		rslt = snprintf(p, sz, ";\n");
		if (rslt == -1 || rslt >= sz)
			return (NULL);
		p += rslt;
		sz -= rslt;
d2024 2
a2025 3
		rslt = snprintf(p, sz, "  option %s %s;\n",
		    dhcp_options[i].name, pretty_print_option(i, opt,  1));
		if (rslt == -1 || rslt >= sz)
d2027 3
a2029 2
		p += rslt;
		sz -= rslt;
d2032 1
a2032 1
	rsltsz = strftime(p, sz, "  renew " DB_TIMEFMT ";\n",
d2034 1
a2034 1
	if (rsltsz == 0)
d2036 3
a2038 3
	p += rsltsz;
	sz -= rsltsz;
	rsltsz = strftime(p, sz, "  rebind " DB_TIMEFMT ";\n",
d2040 1
a2040 1
	if (rsltsz == 0)
d2042 3
a2044 3
	p += rsltsz;
	sz -= rsltsz;
	rsltsz = strftime(p, sz, "  expire " DB_TIMEFMT ";\n",
d2046 1
a2046 1
	if (rsltsz == 0)
d2048 4
a2051 4
	p += rsltsz;
	sz -= rsltsz;
	rslt = snprintf(p, sz, "}\n");
	if (rslt == -1 || rslt >= sz)
d2054 1
a2054 1
	return (leasestr);
@


1.407
log
@Send a RTM_PROPOSAL to clear out other dhclient instances on startup.

Replaces forcing interface link state down and up to generate
RTM_IFINFO messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.406 2017/04/04 13:01:20 krw Exp $	*/
d1269 1
a1269 1
	int i, sz;
d1292 2
a1293 1
			buf = calloc(1, DHCP_DOMAIN_SEARCH_LEN);
a1294 5
				fatalx("No memory to decode domain search");
			sz = pretty_print_domain_search(buf,
			    DHCP_DOMAIN_SEARCH_LEN,
			    options[i].data, options[i].len);
			if (strlen(buf) == 0)
d1296 1
a1296 1
			if (sz == -1 || !res_hnok_list(buf))
a1298 1
			free(buf);
d2705 1
a2705 1
	int i, rslt, sz;
d2710 2
a2711 1
		buf = calloc(1, DHCP_DOMAIN_SEARCH_LEN);
a2712 4
			fatalx("No memory to decode domain search");
		sz = pretty_print_domain_search(buf, DHCP_DOMAIN_SEARCH_LEN,
		    domainsearch->data, domainsearch->len);
		if (sz == -1)
a2718 1
		free(buf);
@


1.406
log
@Treat SSID's like the 0 to 32 bytes of uint8_t data that they really
are. Track and use the actual lengths and use memcpy()/memcmp()
instead of strcmp()/strdup().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.405 2017/03/08 20:54:30 krw Exp $	*/
d172 1
d265 16
d661 3
a663 2
	rtfilter = ROUTE_FILTER(RTM_NEWADDR) | ROUTE_FILTER(RTM_DELADDR) |
	    ROUTE_FILTER(RTM_IFINFO) | ROUTE_FILTER(RTM_IFANNOUNCE);
d672 2
d2980 55
@


1.405
log
@Shuffle, shuffle, shuffle.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.404 2017/03/08 15:34:44 krw Exp $	*/
d529 1
d779 3
a781 1
		if (strcmp(lp->ssid, ifi->ssid) != 0)
d963 1
d1093 6
a1098 2
		if (client->active && strcmp(client->active->ssid,
		    lease->ssid) != 0)
d1500 3
a1502 1
		if (strcmp(lp->ssid, ifi->ssid) != 0)
d2012 1
a2012 1
	if (strlen(lease->ssid)) {
d2019 1
a2019 1
		    strlen(lease->ssid), 1);
d2476 1
@


1.404
log
@Move a line of code to group together code that will be mediated
by #ifdef's.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.403 2017/03/08 14:55:21 krw Exp $	*/
a263 3
	case RTM_DESYNC:
		log_warnx("route socket buffer overflow");
		break;
d352 3
@


1.403
log
@Shuffle some functions around to group together functions that will
later be #ifdef'd in or out.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.402 2017/03/08 14:36:19 krw Exp $	*/
a1102 2
	client->state = S_BOUND;

d1105 2
@


1.402
log
@Split a declaration to make the later insertion of #ifdef easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.401 2017/03/08 14:28:44 krw Exp $	*/
a2317 95
/*
 * Update resolv.conf.
 */
char *
resolv_conf_contents(struct interface_info *ifi,
    struct option_data *domainname, struct option_data *nameservers,
    struct option_data *domainsearch)
{
	char *dn, *ns, *nss[MAXNS], *contents, *courtesy, *p, *buf;
	size_t len;
	int i, rslt, sz;

	memset(nss, 0, sizeof(nss));

	if (domainsearch->len) {
		buf = calloc(1, DHCP_DOMAIN_SEARCH_LEN);
		if (buf == NULL)
			fatalx("No memory to decode domain search");
		sz = pretty_print_domain_search(buf, DHCP_DOMAIN_SEARCH_LEN,
		    domainsearch->data, domainsearch->len);
		if (sz == -1)
			dn = strdup("");
		else {
			rslt = asprintf(&dn, "search %s\n", buf);
			if (rslt == -1)
				dn = NULL;
		}
		free(buf);
	} else if (domainname->len) {
		rslt = asprintf(&dn, "search %s\n",
		    pretty_print_option(DHO_DOMAIN_NAME, domainname, 0));
		if (rslt == -1)
			dn = NULL;
	} else
		dn = strdup("");
	if (dn == NULL)
		fatalx("no memory for domainname");

	if (nameservers->len) {
		ns = pretty_print_option(DHO_DOMAIN_NAME_SERVERS, nameservers,
		    0);
		for (i = 0; i < MAXNS; i++) {
			p = strsep(&ns, " ");
			if (p == NULL)
				break;
			if (*p == '\0')
				continue;
			rslt = asprintf(&nss[i], "nameserver %s\n", p);
			if (rslt == -1)
				fatalx("no memory for nameserver");
		}
	}

	len = strlen(dn);
	for (i = 0; i < MAXNS; i++)
		if (nss[i])
			len += strlen(nss[i]);

	if (len > 0 && config->resolv_tail)
		len += strlen(config->resolv_tail);

	if (len == 0) {
		free(dn);
		return (NULL);
	}

	rslt = asprintf(&courtesy, "# Generated by %s dhclient\n", ifi->name);
	if (rslt == -1)
		fatalx("no memory for courtesy line");
	len += strlen(courtesy);

	len++; /* Need room for terminating NUL. */
	contents = calloc(1, len);
	if (contents == NULL)
		fatalx("no memory for resolv.conf contents");

	strlcat(contents, courtesy, len);
	free(courtesy);

	strlcat(contents, dn, len);
	free(dn);

	for (i = 0; i < MAXNS; i++) {
		if (nss[i]) {
			strlcat(contents, nss[i], len);
			free(nss[i]);
		}
	}

	if (config->resolv_tail)
		strlcat(contents, config->resolv_tail, len);

	return (contents);
}

a2546 13
write_resolv_conf(u_int8_t *contents, size_t sz)
{
	int rslt;

	rslt = imsg_compose(unpriv_ibuf, IMSG_WRITE_RESOLV_CONF,
	    0, 0, -1, contents, sz);
	if (rslt == -1)
		log_warn("write_resolv_conf: imsg_compose");

	flush_unpriv_ibuf("write_resolv_conf");
}

void
a2559 22
priv_write_resolv_conf(struct interface_info *ifi, struct imsg *imsg)
{
	u_int8_t *contents;
	size_t sz;

	if (imsg->hdr.len < IMSG_HEADER_SIZE) {
		log_warnx("short IMSG_WRITE_RESOLV_CONF");
		return;
	}

	if (!resolv_conf_priority(ifi))
		return;

	contents = imsg->data;
	sz = imsg->hdr.len - IMSG_HEADER_SIZE;

	priv_write_file("/etc/resolv.conf",
	    O_WRONLY | O_CREAT | O_TRUNC,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, contents, sz);
}

void
d2606 193
a2948 63
}

void
set_lease_times(struct client_lease *lease)
{
	time_t cur_time, time_max;
	u_int32_t uint32val;

	time(&cur_time);

	time_max = LLONG_MAX - cur_time;
	if (time_max > UINT32_MAX)
		time_max = UINT32_MAX;

	/*
	 * Take the server-provided times if available.  Otherwise
	 * figure them out according to the spec.
	 *
	 * expiry  == time to discard lease.
	 * renewal == time to renew lease from server that provided it.
	 * rebind  == time to renew lease from any server.
	 *
	 * 0 <= renewal <= rebind <= expiry <= time_max
	 * &&
	 * expiry >= MIN(time_max, 60)
	 */

	lease->expiry = 43200;	/* Default to 12 hours */
	if (lease->options[DHO_DHCP_LEASE_TIME].len == sizeof(uint32val)) {
		memcpy(&uint32val, lease->options[DHO_DHCP_LEASE_TIME].data,
		    sizeof(uint32val));
		lease->expiry = ntohl(uint32val);
		if (lease->expiry < 60)
			lease->expiry = 60;
	}
	if (lease->expiry > time_max)
		lease->expiry = time_max;

	lease->renewal = lease->expiry / 2;
	if (lease->options[DHO_DHCP_RENEWAL_TIME].len == sizeof(uint32val)) {
		memcpy(&uint32val, lease->options[DHO_DHCP_RENEWAL_TIME].data,
		    sizeof(uint32val));
		lease->renewal = ntohl(uint32val);
		if (lease->renewal > lease->expiry)
			lease->renewal = lease->expiry;
	}

	lease->rebind = (lease->expiry * 7) / 8;
	if (lease->options[DHO_DHCP_REBINDING_TIME].len == sizeof(uint32val)) {
		memcpy(&uint32val,
		    lease->options[DHO_DHCP_REBINDING_TIME].data,
		    sizeof(uint32val));
		lease->rebind = ntohl(uint32val);
		if (lease->rebind > lease->expiry)
			lease->rebind = lease->expiry;
	}
	if (lease->rebind < lease->renewal)
		lease->rebind = lease->renewal;

	/* Convert lease lengths to times. */
	lease->expiry += cur_time;
	lease->renewal += cur_time;
	lease->rebind += cur_time;
@


1.401
log
@Shuffle some declarations. Both more style(9)'ish and make future diff
smaller.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.400 2017/03/08 14:19:00 krw Exp $	*/
d972 2
a973 1
	struct option_data *options, *opt;
@


1.400
log
@Add comments to #endif's to allow easy differentiation between many
incoming #ifdef's.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.399 2017/02/15 20:00:16 krw Exp $	*/
a236 1
	struct client_state *client = ifi->client;
d239 3
a241 2
	ssize_t n;
	int linkstat, rslt;
a244 1
	struct ifa_msghdr *ifam;
a245 1
	struct sockaddr *sa;
d247 2
@


1.399
log
@Use new log.[ch] functions in parse_warn().

Simplify the "^" placing logic and make it apply to log entries as
well as terminal output.

Since dhclient(8) can be re-exec'd for various reasons after going
daemon, make sure we don't try to log to stderr if it isn't a TTY.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.398 2017/02/14 22:46:53 krw Exp $	*/
d381 1
a381 1
#endif
d941 1
a941 1
#endif
d1153 1
a1153 1
#endif
d1165 1
a1165 1
#endif
d1378 1
a1378 1
#endif
d1385 1
a1385 1
#endif
@


1.398
log
@fatalx() prepends 'fatal in _progname:'. So eliminate redundant
'; exiting' suffix used by old style logging.

Eliminate an extra log message before fatal()'ing out with a summary
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.397 2017/02/12 15:53:15 krw Exp $	*/
d444 1
a444 1
	int rtfilter, tailfd;
d448 6
a453 1
	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */
d456 1
d463 1
a463 4
			if (log_perror == 0)
				usage();
			daemonize = 0;
			log_perror = 1;
d485 1
a485 4
			if (daemonize == 0)
				usage();
			daemonize = 1;
			log_perror = 0;
d497 1
a497 1
	if (argc != 1)
d499 8
@


1.397
log
@Eliminate most strerror() invocations by using log_warn() and fatal()
instead of log_warnx() and fatalx(). A few log_info() to log_warn()
for the same reason.

Suggested by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.396 2017/02/12 13:55:01 krw Exp $	*/
d425 1
a425 1
	fatalx("%s; exiting", errmsg);
d2262 1
a2262 1
		log_warnx("%s; exiting", strsignal(quit));
@


1.396
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.395 2017/02/12 13:15:50 krw Exp $	*/
d526 1
a526 2
		fatalx("setting routing table to %u: '%s'", ifi->rdomain,
		    strerror(errno));
d530 1
a530 1
		fatalx("socketpair: %s", strerror(errno));
d533 1
a533 1
		fatalx("cannot open %s: %s", _PATH_DEVNULL, strerror(errno));
d592 1
a592 2
			fatalx("Cannot open /etc/resolv.conf.tail: %s",
			    strerror(errno));
d594 1
a594 2
		fatalx("Cannot stat /etc/resolv.conf.tail: %s",
		    strerror(errno));
d600 1
a600 1
				    "contents: %s", strerror(errno));
d604 1
a604 2
				fatalx("Couldn't read resolv.conf.tail: %s",
				    strerror(errno));
d615 1
a615 2
		fatalx("can't open and lock %s: %s", path_dhclient_db,
		    strerror(errno));
d618 1
a618 1
		fatalx("can't open %s: %s", path_dhclient_db, strerror(errno));
d633 1
a633 1
		fatalx("socket(PF_ROUTE, SOCK_RAW): %s", strerror(errno));
d640 1
a640 1
		fatalx("setsockopt(ROUTE_MSGFILTER): %s", strerror(errno));
d643 1
a643 1
		fatalx("setsockopt(ROUTE_TABLEFILTER): %s", strerror(errno));
d1198 1
a1198 1
		log_warnx("addressinuse: getifaddrs: %s", strerror(errno));
d2066 1
a2066 1
		fatalx("Cannot daemonize: %s", strerror(errno));
d2208 1
a2208 1
				log_warnx("poll error: %s", strerror(errno));
d2218 1
a2218 1
			log_warnx("imsg_read(priv_ibuf): %s", strerror(errno));
d2239 1
a2239 2
			log_warnx("Unable to truncate '%s': %s",
			    path_option_db, strerror(errno));
d2258 1
a2258 2
		fatalx("RESTART FAILED: '%s': %s", saved_argv[0],
		    strerror(errno));
d2283 1
a2283 1
			fatalx("ioctl SIOCGIFGMEMB: %s", strerror(errno));
d2289 1
a2289 1
			fatalx("ioctl SIOCGIFGMEMB: %s", strerror(errno));
d2301 1
a2301 1
			fatalx("Interface name too long: %s", strerror(errno));
d2640 1
a2640 2
		log_warnx("write_resolv_conf: imsg_compose: %s",
		    strerror(errno));
d2653 1
a2653 2
		log_warnx("write_option_db: imsg_compose: %s",
		    strerror(errno));
d2708 1
a2708 1
		log_info("Couldn't open '%s': %s", path, strerror(errno));
d2714 1
a2714 2
		log_info("Couldn't write contents to '%s': %s", path,
		    strerror(errno));
d2716 1
a2716 1
		log_info("Short contents write to '%s' (%zd vs %zu)", path,
d2720 1
a2720 2
		log_info("fchown(fd, %d, %d) of '%s' failed (%s)",
		    0, 0, path, strerror(errno));
d2722 1
a2722 2
		log_info("fchmod(fd, 0x%x) of '%s' failed (%s)", mode,
		    path, strerror(errno));
@


1.395
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.394 2017/01/23 04:45:59 deraadt Exp $	*/
d699 2
a700 2
	    "usage: %s [-d | -q] [-u] [-c file] [-i options] [-L file] [-l file] "
	    "interface\n", __progname);
d811 2
a812 1
 * Called when a lease has completely expired and we've been unable to renew it.
d991 2
a992 2
	 * A duplicate lease once we are responsible & S_RENEWING means we don't
	 * need to change the interface, routing table or resolv.conf.
d1182 1
a1182 1
		/* The lease we expected - put it at the head of the list. */
d1185 1
a1185 1
		/* Not the lease we expected - put it at the end of the list. */
d1495 2
a1496 1
			log_info("Trying static lease %s", inet_ntoa(lp->address));
d1546 2
a1547 1
	if (client->state == S_REBOOTING && interval > config->reboot_timeout) {
d2229 1
a2229 1
			/* Connection closed -- other end should log message. */
d2244 2
a2245 2
			log_warnx("Unable to truncate '%s': %s", path_option_db,
			    strerror(errno));
d2320 3
a2322 2
resolv_conf_contents(struct interface_info *ifi, struct option_data *domainname,
    struct option_data *nameservers, struct option_data *domainsearch)
d2580 2
a2581 1
		newlease->options[i].data = calloc(1, newlease->options[i].len);
d2647 2
a2648 1
		log_warnx("write_resolv_conf: imsg_compose: %s", strerror(errno));
d2661 2
a2662 1
		log_warnx("write_option_db: imsg_compose: %s", strerror(errno));
d2745 2
a2746 1
add_direct_route(struct in_addr dest, struct in_addr mask, struct in_addr iface)
d2938 2
a2939 1
		memcpy(&uint32val, lease->options[DHO_DHCP_REBINDING_TIME].data,
@


1.394
log
@Keep socket open from startup, and reuse for SIOCGIFFLAGS later on,
rather than opening a fresh socket on the fly.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.393 2016/11/25 14:46:57 krw Exp $	*/
d93 1
d252 1
a252 1
		error("No memory for rtmmsg");
d265 1
a265 1
		warning("route socket buffer overflow");
d289 1
a289 1
			note("bound to %s -- renewal in %lld seconds.",
d338 1
a338 1
			warning("Active address (%s) deleted; exiting",
d368 1
a368 1
				warning("LLADDR changed; restarting");
d378 1
a378 1
			debug("link state %s -> %s",
d424 2
a425 2
		error("no memory for errmsg");
	error("%s; exiting", errmsg);
a440 1
	extern char *__progname;
d448 2
a449 7
	/* Initially, log errors to stderr as well as to syslogd. */
	openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
#ifdef DEBUG
	setlogmask(LOG_UPTO(LOG_DEBUG));
#else
	setlogmask(LOG_UPTO(LOG_INFO));
#endif
d469 1
a469 1
					error("'%s' is not a regular file",
d477 1
a477 1
					error("'%s' is not a regular file",
d502 1
a502 1
		error("ifi calloc");
d506 1
a506 1
		error("%s: no such interface", ifi->name);
d513 1
a513 1
		error("Can't create socket to get ssid");
d526 1
a526 1
		error("setting routing table to %u: '%s'", ifi->rdomain,
d531 1
a531 1
		error("socketpair: %s", strerror(errno));
d534 1
a534 1
		error("cannot open %s: %s", _PATH_DEVNULL, strerror(errno));
d540 1
a540 1
		error("no memory for unpriv_ibuf");
d545 1
a545 1
		error("config calloc");
d550 1
a550 1
		error("client calloc");
d572 1
a572 1
			error("no memory for default client identifier");
d580 1
a580 1
		error("no such user: _dhcp");
d584 1
a584 1
		error("asprintf");
d593 1
a593 1
			error("Cannot open /etc/resolv.conf.tail: %s",
d596 1
a596 1
		error("Cannot stat /etc/resolv.conf.tail: %s",
d602 1
a602 1
				error("no memory for resolv.conf.tail "
d607 1
a607 1
				error("Couldn't read resolv.conf.tail: %s",
d610 1
a610 1
				error("Got no data from resolv.conf.tail");
d612 1
a612 1
				error("Short read of resolv.conf.tail");
d619 1
a619 1
		error("can't open and lock %s: %s", path_dhclient_db,
d623 1
a623 1
		error("can't open %s: %s", path_dhclient_db, strerror(errno));
d638 1
a638 1
		error("socket(PF_ROUTE, SOCK_RAW): %s", strerror(errno));
d645 1
a645 1
		error("setsockopt(ROUTE_MSGFILTER): %s", strerror(errno));
d648 1
a648 1
		error("setsockopt(ROUTE_TABLEFILTER): %s", strerror(errno));
d655 1
a655 1
		error("chroot");
d657 1
a657 1
		error("chdir(\"/\")");
d660 1
a660 1
		error("setresgid");
d662 1
a662 1
		error("setgroups");
d664 1
a664 1
		error("setresuid");
d670 1
a670 1
			error("pledge");
d673 1
a673 1
			error("pledge");
d936 1
a936 1
		debug("Unexpected %s. State #%d", info, client->state);
d941 1
a941 1
	note("%s", info);
d945 1
a945 1
		note("Unsatisfactory %s", info);
d999 1
a999 1
		note("bound to %s -- renewal in %lld seconds.",
d1024 1
a1024 1
			warning("mtu size %u < 68: ignored", mtu);
d1148 1
a1148 1
		debug("Unexpected %s. State #%d.", info, client->state);
d1153 1
a1153 1
	note("%s", info);
d1160 1
a1160 1
			debug("Duplicate %s.", info);
d1202 1
a1202 1
		warning("addressinuse: getifaddrs: %s", strerror(errno));
d1240 1
a1240 1
		warning("dhcpoffer: no memory to create lease.");
d1250 1
a1250 1
			warning("dhcpoffer: unknown option %d", i);
d1261 1
a1261 1
				error("No memory to decode domain search");
d1268 1
a1268 1
				warning("Bogus data for option %s",
d1280 1
a1280 1
				warning("Bogus data for option %s",
d1288 1
a1288 1
				warning("Bogus data for option %s",
d1306 1
a1306 1
			warning("Missing required parameter %s",
d1320 1
a1320 1
		warning("%s already configured on %s",
d1334 1
a1334 1
			warning("dhcpoffer: no memory for server name.");
d1341 1
a1341 1
			warning("Bogus server name %s", lease->server_name);
d1353 1
a1353 1
			warning("dhcpoffer: no memory for filename.");
d1373 1
a1373 1
		debug("Unexpected %s. State #%d", info, client->state);
d1380 1
a1380 1
		debug("Unexpected %s. No active lease.", info);
d1385 1
a1385 1
	note("%s", info);
d1457 1
a1457 1
	note("DHCPDISCOVER on %s - interval %lld", ifi->name,
d1462 1
a1462 1
		warning("dhclient cannot be used on %s", ifi->name);
d1482 1
a1482 1
	note("No acceptable DHCPOFFERS received.");
d1494 1
a1494 1
			note("Trying static lease %s", inet_ntoa(lp->address));
d1498 1
a1498 1
			note("Trying recorded lease %s",
d1511 1
a1511 1
	note("No working leases in persistent database - sleeping.");
d1614 1
a1614 1
	note("DHCPREQUEST on %s to %s", ifi->name,
d1627 1
a1627 1
	note("DHCPDECLINE on %s", ifi->name);
d1674 1
a1674 1
		error("options do not fit in DHCPDISCOVER packet.");
d1746 1
a1746 1
		error("options do not fit in DHCPREQUEST packet.");
d1815 1
a1815 1
		error("options do not fit in DHCPDECLINE packet.");
d1865 1
a1865 1
		error("lease file not open");
d1889 1
a1889 1
			warning("cannot make lease into string");
d1914 1
a1914 1
			warning("cannot fit offered lease into option db");
d1916 1
a1916 1
		warning("cannot make offered lease into string");
d1922 1
a1922 1
			warning("cannot fit effective lease into option db");
d1924 1
a1924 1
		warning("cannot make effective lease into string");
d2064 2
d2068 1
a2068 1
		error("Cannot daemonize: %s", strerror(errno));
d2129 1
a2129 1
			warning("warning: hostname %s contains an "
d2154 1
a2154 1
		error("Cannot copy domain name list");
d2183 1
a2183 1
		error("cannot fork");
d2192 1
a2192 1
		error("chdir(\"/\")");
d2201 1
a2201 1
		error("no memory for priv_ibuf");
d2210 1
a2210 1
				warning("poll error: %s", strerror(errno));
d2220 1
a2220 1
			warning("imsg_read(priv_ibuf): %s", strerror(errno));
d2241 1
a2241 1
			warning("Unable to truncate '%s': %s", path_option_db,
d2258 1
a2258 1
			warning("%s; restarting.", strsignal(quit));
d2261 1
a2261 1
		error("RESTART FAILED: '%s': %s", saved_argv[0],
d2266 1
a2266 1
		warning("%s; exiting", strsignal(quit));
d2281 1
a2281 1
			error("socket error");
d2286 2
a2287 2
				error("no interface in group egress found");
			error("ioctl SIOCGIFGMEMB: %s", strerror(errno));
d2291 1
a2291 1
			error("get_ifname");
d2293 1
a2293 1
			error("ioctl SIOCGIFGMEMB: %s", strerror(errno));
d2300 1
a2300 1
				error("too many interfaces in group egress");
d2305 1
a2305 1
			error("Interface name too long: %s", strerror(errno));
d2310 1
a2310 1
		error("Interface name too long");
d2329 1
a2329 1
			error("No memory to decode domain search");
d2348 1
a2348 1
		error("no memory for domainname");
d2361 1
a2361 1
				error("no memory for nameserver");
d2380 1
a2380 1
		error("no memory for courtesy line");
d2386 1
a2386 1
		error("no memory for resolv.conf contents");
d2415 1
a2415 1
		error("Unable to clone lease");
d2531 1
a2531 1
	error("Unable to apply defaults");
d2619 1
a2619 1
			note("Invalid option name: '%s'", p);
d2642 1
a2642 1
		warning("write_resolv_conf: imsg_compose: %s", strerror(errno));
d2655 1
a2655 1
		warning("write_option_db: imsg_compose: %s", strerror(errno));
d2667 1
a2667 1
		warning("short IMSG_WRITE_RESOLV_CONF");
d2689 1
a2689 1
		warning("short IMSG_WRITE_OPTION_DB");
d2710 1
a2710 1
		note("Couldn't open '%s': %s", path, strerror(errno));
d2716 1
a2716 1
		note("Couldn't write contents to '%s': %s", path,
d2719 1
a2719 1
		note("Short contents write to '%s' (%zd vs %zu)", path,
d2723 1
a2723 1
		note("fchown(fd, %d, %d) of '%s' failed (%s)",
d2726 1
a2726 1
		note("fchmod(fd, 0x%x) of '%s' failed (%s)", mode,
@


1.393
log
@Nuke the DHO_ROUTERS and DHO_STATIC_ROUTES options from the effective
lease when DHO_CLASSLESS_[MS_]STATIC_ROUTES are present. RFC 3442 says
the client must ignore the former if the latter is present.

The information was already ignored but was still written to the
'effective' section of the pseudo-lease file created by the -L
option. This incorrectly implied that these options were 'effective'.

Problem noted by Ed Fochler. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.392 2016/10/06 16:29:17 krw Exp $	*/
d429 2
d444 1
a444 1
	int rtfilter, sock, tailfd;
a526 1
	close(sock);
@


1.392
log
@Add support for RFC 6842, which says the client MUST drop packets when
the server provides a client-identifier value and it doesn't match
the value the client sent.

So stop suppressing client-identifer info in the leases file and when
reading the leases file stop discarding leases that don't have current
client-identifier info. Don't use them, but keep them around in case
the client-identifier info changes back next time.

Also construct the default client-identifier (if needed) before reading
the leases file.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.391 2016/09/29 15:29:06 krw Exp $	*/
d2504 19
@


1.391
log
@Don't record non-existant client identifier in lease file.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.390 2016/09/27 15:17:58 jca Exp $	*/
d433 1
d510 1
d560 23
a759 1
	struct option_data *opt;
d761 1
a766 19
	get_hw_address(ifi);
	opt = &config->send_options[DHO_DHCP_CLIENT_IDENTIFIER];
	/*
	 * Check both len && data so
	 *     send dhcp-client-identifier "";
	 * can be used to suppress sending the default client
	 * identifier.
	 */
	if (opt->len == 0 && opt->data == NULL) {
		/* Build default client identifier. */
		opt->data = calloc(1, ETHER_ADDR_LEN + 1);
		if (opt->data != NULL) {
			opt->data[0] = HTYPE_ETHER;
			memcpy(&opt->data[1], ifi->hw_address.ether_addr_octet,
			    ETHER_ADDR_LEN);
			opt->len = ETHER_ADDR_LEN + 1;
		}
	}

d777 1
d781 5
d2019 1
a2019 6
		if (i == DHO_DHCP_CLIENT_IDENTIFIER) {
			/* Ignore any CLIENT_IDENTIFIER from server. */
			opt = &config->send_options[i];
		} else
			opt = &lease->options[i];

@


1.390
log
@Reintroduce rdaemon() - working properly this time

Thanks Ken for fixing my initial implementation.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.389 2016/09/16 23:35:45 krw Exp $	*/
d2010 1
a2010 1
		} else if (lease->options[i].len)
d2012 2
a2013 1
		else
@


1.389
log
@Revert use of rdaemon() until it doesn't break install/upgrade.

Problem cause deduced by kili@@, reproduced by & ok rpe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.388 2016/09/15 16:19:04 jca Exp $	*/
d170 1
d535 3
a557 3
	if ((nullfd = open(_PATH_DEVNULL, O_RDWR, 0)) == -1)
		error("cannot open %s: %s", _PATH_DEVNULL, strerror(errno));

d2061 2
a2062 11
	if (daemon(1, 0) == -1)
		error("daemon");

	/* we are chrooted, daemon(3) fails to open /dev/null */
	if (nullfd != -1) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
		close(nullfd);
		nullfd = -1;
	}
d2072 31
@


1.388
log
@Use rdaemon() in dhclient too.

dhclient already has code to pre-open /dev/null, in order to properly go
to the background after chroot(2).  Use rdaemon() like in tftpd,
ftp-proxy, dhcrelay and rtadvd.

No objection krw@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.387 2016/09/04 11:21:24 jca Exp $	*/
a169 1
int rdaemon(int);
d2060 11
a2070 2
	if (rdaemon(nullfd) == -1)
		error("rdaemon");
a2079 25
}

int
rdaemon(int devnull)
{

	switch (fork()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	if (setsid() == -1)
		return (-1);

	(void)dup2(devnull, STDIN_FILENO);
	(void)dup2(devnull, STDOUT_FILENO);
	(void)dup2(devnull, STDERR_FILENO);
	if (devnull > 2)
		(void)close(devnull);

	return (0);
@


1.387
log
@Use 'daemonize' instead of 'no_daemon', just like in dhcpd and dhcrelay.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.386 2016/09/02 15:44:25 mpi Exp $	*/
d170 1
d2061 2
a2062 11
	if (daemon(1, 0) == -1)
		error("daemon");

	/* we are chrooted, daemon(3) fails to open /dev/null */
	if (nullfd != -1) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
		close(nullfd);
		nullfd = -1;
	}
d2072 25
@


1.386
log
@Kill 'ifi' global.

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.385 2016/09/02 11:11:49 krw Exp $	*/
d102 1
a102 1
int no_daemon;
d460 2
a461 1
			no_daemon = log_perror = 1;
d483 1
a483 1
			if (no_daemon == 1)
d485 2
a486 1
			no_daemon = log_perror = 0;
d646 2
a647 2
	if (no_daemon) {
		if (pledge("stdio inet dns route", NULL) == -1)
d650 1
a650 1
		if (pledge("stdio inet dns route proc", NULL) == -1)
d2052 1
a2052 1
	if (no_daemon || state)
@


1.385
log
@Treat backoff_cutoff as a hard cutoff, not the midpoint in a range
from .5 to 1.5 ofthe value. This is how the man page describes it and
nobody can remember why it was not being used as a hard limit.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.384 2016/08/31 23:16:16 krw Exp $	*/
a113 1
struct interface_info *ifi;
d123 1
a123 1
int		 addressinuse(struct in_addr, char *);
d125 5
a129 4
void		 fork_privchld(int, int);
void		 get_ifname(char *);
char		*resolv_conf_contents(struct option_data  *,
		     struct option_data *, struct option_data *);
d145 21
a165 20
void state_preboot(void);
void state_reboot(void);
void state_init(void);
void state_selecting(void);
void state_bound(void);
void state_panic(void);

void send_discover(void);
void send_request(void);
void send_decline(void);

void bind_lease(void);

void make_discover(struct client_lease *);
void make_request(struct client_lease *);
void make_decline(struct client_lease *);

void rewrite_client_leases(void);
void rewrite_option_db(struct client_lease *, struct client_lease *);
char *lease_as_string(char *, struct client_lease *);
d167 2
a168 1
struct client_lease *packet_to_lease(struct in_addr, struct option_data *);
d233 1
a233 1
routehandler(void)
d383 1
a383 1
					state_preboot();
d387 1
a387 1
					state_reboot();
d431 1
d502 1
a502 1
	get_ifname(argv[0]);
d532 1
a532 1
	fork_privchld(socket_fd[0], socket_fd[1]);
d600 1
a600 1
	rewrite_client_leases();
d657 1
a657 1
		state_reboot();
d660 1
a660 1
		state_preboot();
d681 1
a681 1
state_preboot(void)
d683 1
d713 1
a713 1
		set_timeout_interval(1, state_reboot);
d718 1
a718 1
		set_timeout_interval(1, state_preboot);
d726 1
a726 1
state_reboot(void)
d728 1
d762 1
a762 1
		else if (addressinuse(client->active->address, ifname) &&
d771 1
a771 1
		if (addressinuse(lp->address, ifname) &&
d785 1
a785 1
		state_init();
d790 1
a790 1
	make_request(client->active);
d796 1
a796 1
	send_request();
d803 1
a803 1
state_init(void)
d805 1
d809 1
a809 1
	make_discover(client->active);
d816 1
a816 1
	send_discover();
d824 1
a824 1
state_selecting(void)
d826 1
d843 2
a844 2
		make_decline(lease);
		send_decline();
d849 1
a849 1
		state_panic();
d889 1
a889 1
		bind_lease();
d905 1
a905 1
	make_request(picked);
d910 1
a910 1
	send_request();
d914 2
a915 1
dhcpack(struct in_addr client_addr, struct option_data *options, char *info)
d932 1
a932 1
	lease = packet_to_lease(client_addr, options);
d935 2
a936 2
		make_decline(lease);
		send_decline();
d939 1
a939 1
		state_init();
d949 1
a949 1
	bind_lease();
d953 1
a953 1
bind_lease(void)
d994 1
a994 1
	client->new->resolv_conf = resolv_conf_contents(
d1061 1
a1061 1
	rewrite_option_db(client->active, lease);
d1090 1
a1090 1
	rewrite_client_leases();
d1093 1
a1093 1
	set_timeout(client->active->renewal, state_bound);
d1102 1
a1102 1
state_bound(void)
d1104 1
d1110 1
a1110 1
	make_request(client->active);
d1124 1
a1124 1
	send_request();
d1128 2
a1129 1
dhcpoffer(struct in_addr client_addr, struct option_data *options, char *info)
d1155 1
a1155 1
	lease = packet_to_lease(client_addr, options);
d1178 1
a1178 1
		state_selecting();
d1180 1
a1180 1
		set_timeout(stop_selecting, state_selecting);
d1184 1
a1184 1
addressinuse(struct in_addr address, char *ifname)
d1218 2
a1219 1
packet_to_lease(struct in_addr client_addr, struct option_data *options)
d1307 1
a1307 1
	if (addressinuse(lease->address, ifname) &&
d1352 2
a1353 1
dhcpnak(struct in_addr client_addr, struct option_data *options, char *info)
d1388 1
a1388 1
	state_init();
d1397 1
a1397 1
send_discover(void)
d1399 1
d1411 1
a1411 1
		state_panic();
d1454 1
a1454 1
		set_timeout_interval(client->interval, send_discover);
d1462 1
a1462 1
state_panic(void)
d1464 1
d1478 1
a1478 1
		if (addressinuse(lp->address, ifname) &&
d1492 1
a1492 1
		bind_lease();
d1502 1
a1502 1
	set_timeout_interval(config->retry_interval, state_init);
d1507 1
a1507 1
send_request(void)
d1509 1
d1536 1
a1536 1
		state_init();
d1549 1
a1549 1
		state_init();
d1608 1
a1608 1
	set_timeout_interval(client->interval, send_request);
d1612 1
a1612 1
send_decline(void)
d1614 2
d1622 1
a1622 1
make_discover(struct client_lease *lease)
d1686 1
a1686 1
make_request(struct client_lease * lease)
d1768 1
a1768 1
make_decline(struct client_lease *lease)
d1846 1
a1846 1
rewrite_client_leases(void)
d1874 1
a1874 1
		leasestr = lease_as_string("lease", lp);
d1887 2
a1888 1
rewrite_option_db(struct client_lease *offered, struct client_lease *effective)
d1899 1
a1899 1
	leasestr = lease_as_string("offered", offered);
d1907 1
a1907 1
	leasestr = lease_as_string("effective", effective);
d1919 2
a1920 1
lease_as_string(char *type, struct client_lease *lease)
d2142 1
a2142 1
fork_privchld(int fd, int fd2)
d2241 1
a2241 1
get_ifname(char *arg)
d2286 1
a2286 1
resolv_conf_contents(struct option_data  *domainname,
d2611 1
a2611 1
priv_write_resolv_conf(struct imsg *imsg)
@


1.384
log
@REQUEST packets are not just sent when an interface reboots. So don't short
circuit the waiting for ACK's by giving up after reboot_timeout.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.383 2016/08/31 13:55:08 krw Exp $	*/
d1417 1
a1417 2
		client->interval = (config->backoff_cutoff / 2) +
		    arc4random_uniform(config->backoff_cutoff);
d1549 1
a1549 2
		client->interval = (config->backoff_cutoff / 2) +
		    arc4random_uniform(client->interval);
@


1.383
log
@Use reboot_timeout (default: 1) instead of initial_interval (default: 3) when
the interface reboots. Thus the fallback from REQUEST to DISCOVER will take
place after the intended reboot_timeout seconds.

ok tedu@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.382 2016/08/31 12:57:31 mpi Exp $	*/
d1508 2
a1509 3
	 * If we're in the INIT-REBOOT or REQUESTING state and we're
	 * past the reboot timeout, go to INIT and see if we can
	 * DISCOVER an address.
d1519 1
a1519 3
	if ((client->state == S_REBOOTING ||
	    client->state == S_REQUESTING) &&
	    interval > config->reboot_timeout) {
@


1.382
log
@Remove the 'client' global and make it per-ifp.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.381 2016/08/23 09:26:02 mpi Exp $	*/
d1543 6
a1548 3
	if (!client->interval)
		client->interval = config->initial_interval;
	else
@


1.381
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.380 2016/08/16 21:57:51 krw Exp $	*/
a114 1
struct client_state *client;
d233 1
d541 2
a542 2
	client = calloc(1, sizeof(struct client_state));
	if (client == NULL)
d544 2
a545 2
	TAILQ_INIT(&client->leases);
	TAILQ_INIT(&client->offered_leases);
d650 1
a650 1
	time(&client->startup_time);
d653 1
a653 1
		client->state = S_REBOOTING;
d656 1
a656 1
		client->state = S_PREBOOT;
d680 1
d724 1
d800 2
d820 1
d909 1
d947 1
d1096 1
d1121 1
d1210 1
d1343 2
d1387 1
d1452 1
d1496 1
d1609 1
d1646 1
a1646 1
	i = cons_options(options);
d1673 1
d1718 1
a1718 1
	i = cons_options(options);
d1755 1
d1787 1
a1787 1
	i = cons_options(options);
d1833 1
@


1.380
log
@Track SSID in leases file and only consider leases from the current SSID when
starting up dhclient on wifi interfaces. In theory will preserve leases from
other SSID's and speed up obtaining a lease by not wasting time attempting
to re-acquire a lease from a different SSID.

Experimental feature from n2k16 needing some real world testing before g2k16.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.379 2016/07/23 15:53:19 stsp Exp $	*/
d362 1
a362 1
			get_hw_address();
d371 1
a371 1
		linkstat = interface_status(ifi->name);
d382 1
a382 1
					get_hw_address();
d547 1
a547 1
	read_client_conf();
d594 1
a594 1
	read_client_leases();
d606 1
a606 1
	ifi->linkstat = interface_status(ifi->name);
d624 2
a625 2
	if_register_receive();
	if_register_send();
d660 1
a660 1
	dispatch();
d688 1
a688 1
	ifi->linkstat = interface_status(ifi->name);
d732 1
a732 1
	get_hw_address();
d988 1
a988 1
	delete_addresses();
d1424 1
a1424 1
	rslt = send_packet(inaddr_any, inaddr_broadcast);
d1578 1
a1578 1
	send_packet(from, destination.sin_addr);
d1588 1
a1588 1
	send_packet(inaddr_any, inaddr_broadcast);
d2164 1
a2164 1
		dispatch_imsg(priv_ibuf);
d2185 1
a2185 1
		priv_cleanup(&imsg);
d2585 1
a2585 1
	if (!resolv_conf_priority())
@


1.379
log
@Back out the dhclient BPF change. There are DHCP servers out there which
send frames to the ethernet broadcast address, so this will need some more
thought and it's too late for 6.0.
Problem reported by Holger Mikolon.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.378 2016/07/22 13:23:38 krw Exp $	*/
d69 3
d429 2
d437 1
a437 1
	int rtfilter, tailfd;
d506 13
d762 2
d930 1
d1058 3
d1449 2
d1948 18
d2468 1
@


1.378
log
@Actually DECLINE and delete unused offers. Don't just say so in a comment.

In situations where >1 offer is received this will eliminate unbounded memory
growth and make us a more polite netizen. In some corner cases it might
prevent reuse of inappropriate older offers.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.377 2016/07/21 09:58:55 krw Exp $	*/
a605 1
	get_hw_address();
@


1.377
log
@Use explicit idiom when testing the result of strcmp() and strncmp().
i.e. == 0 and != 0 as appropriate. No intentional functional change.

Suggested by & ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.376 2016/07/20 19:40:04 deraadt Exp $	*/
d797 1
a797 1
	struct client_lease *picked;
d801 5
a805 10
	/* Take the first valid DHCPOFFER, discard the rest. */
	picked = NULL;
	while (!TAILQ_EMPTY(&client->offered_leases) && !picked) {
		picked = TAILQ_FIRST(&client->offered_leases);
		TAILQ_REMOVE(&client->offered_leases, picked, next);
		if (picked->is_invalid) {
			make_decline(picked);
			send_decline();
			free_client_lease(picked);
			picked = NULL;
d807 8
@


1.376
log
@Shrink priv_write_file() API so that it does less, and the callers ask
it to do less.  Discussion with guenther.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.375 2016/07/20 19:25:39 deraadt Exp $	*/
d739 1
a739 1
		    strncmp(ifname, ifi->name, IF_NAMESIZE))
d746 1
a746 1
		    strncmp(ifname, ifi->name, IF_NAMESIZE))
d1159 1
a1159 1
			if (strncmp(ifname, ifi->name, IF_NAMESIZE))
d1191 1
a1191 1
		    dhcp_options[i].name, 7)) {
d1261 1
a1261 1
	    strncmp(ifname, ifi->name, IF_NAMESIZE)) {
d1424 1
a1424 1
		    strncmp(ifname, ifi->name, IF_NAMESIZE))
d2165 1
a2165 1
	if (!strcmp(arg, "egress")) {
d2728 1
a2728 1
		if (strcmp(active->server_name, new->server_name))
d2735 1
a2735 1
		if (strcmp(active->filename, new->filename))
@


1.375
log
@As a general rule, fchown before fchmod is a safer order (because many
systems throw away bits upon chown).  Not in this case, but code gets
copied..
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.374 2016/07/19 17:23:20 krw Exp $	*/
d2545 2
a2546 2
	    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 0, 0, contents, sz);
d2564 2
a2565 2
	    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK | O_NOFOLLOW,
	    S_IRUSR | S_IWUSR | S_IRGRP, 0, 0, contents, sz);
d2569 1
a2569 1
priv_write_file(char *path, int flags, mode_t mode, uid_t uid, gid_t gid,
@


1.374
log
@Narrow the BPF read filter rules so only packets sent to the
interface's LLADDR pass. Rely on dhclient's existing ability to
detect and react to LLADDR changes.

This limits the number of packets that get dropped as a result of
dhclient setting BIOCSFILDROP on the bpf descriptor.

Problem with bridges and multiple dhclients noted by stsp@@.

ok mpi@@ stsp@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.373 2016/04/28 17:34:49 krw Exp $	*/
d2589 3
a2594 3
	if (fchown(fd, uid, gid) == -1)
		note("fchown(fd, %d, %d) of '%s' failed (%s)", uid,
		    gid, path, strerror(errno));
@


1.373
log
@If the attempt to broadcast a DCHPDISCOVER packet returns EAFNOSUPPORT,
don't bother to keep trying to get a lease. It ain't gonna happen. Just
print and error message and exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.372 2016/02/06 19:30:52 krw Exp $	*/
d606 1
@


1.372
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.371 2016/01/26 18:26:19 mmcc Exp $	*/
d1349 1
d1397 6
a1402 3
	send_packet(inaddr_any, inaddr_broadcast);

	set_timeout_interval(client->interval, send_discover);
@


1.371
log
@Use an unsigned int rather than an int when iterating through all 32
bits in the form:

for (i = 1; i; i <<= 1)

This avoids undefined operations when shifting into and out of the
highest-order bit.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.370 2015/12/12 14:48:17 krw Exp $	*/
a55 3
#include "dhcpd.h"
#include "privsep.h"

d58 1
d61 7
d69 5
d75 1
d77 1
d81 1
d83 1
d85 6
@


1.370
log
@Send DECLINE messages in response to ACK messages that turn out to
have inadequate or invalid leases. In particular leases for addresses
that are already configured on a different interface. After the
DECLINE, return to INIT state and start looking for a valid lease. This
conforms much closer to the relevant RFC's.

Avoids 'hanging' dhclient(8) during boot when the attempt to configure
the address fails without dhclient(8) realizing it.

Issue found and various fixes tested by mpi@@. Feedback from beck@@ and
reyk@@.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.369 2015/12/10 18:22:59 krw Exp $	*/
d163 1
a163 1
	int i;
d193 1
a193 1
	int i;
@


1.369
log
@Pledge.

Diff from Ricardo Mestre. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.368 2015/12/07 07:40:47 tb Exp $	*/
d59 2
d64 1
d70 1
d102 1
d685 1
d714 7
a720 2
	if (client->active && client->active->expiry <= cur_time)
		client->active = NULL;
d724 3
d776 1
a776 1
	struct client_lease *lp, *picked;
d780 4
a783 3
	/* Take the first DHCPOFFER, discard the rest. */
	picked = TAILQ_FIRST(&client->offered_leases);
	if (picked)
d785 6
a790 7

	while (!TAILQ_EMPTY(&client->offered_leases)) {
		lp = TAILQ_FIRST(&client->offered_leases);
		TAILQ_REMOVE(&client->offered_leases, lp, next);
		make_decline(lp);
		send_decline();
		free_client_lease(lp);
d873 2
d876 1
a876 1
	if (!lease) {
d878 5
a885 2
	note("%s", info);

d1076 2
a1089 4
	if (!lease) {
		note("Unsatisfactory %s", info);
		return;
	}
a1110 2
	note("%s", info);

d1117 30
d1154 1
d1161 1
a1161 1
		warning("dhcpoffer: no memory to record lease.");
d1172 1
a1172 2
			free_client_lease(lease);
			return (NULL);
d1227 3
a1229 2
			free_client_lease(lease);
			return (NULL);
d1233 4
d1238 7
d1256 1
a1256 2
			free_client_lease(lease);
			return (NULL);
d1263 1
a1263 2
			free(lease->server_name);
			lease->server_name = NULL;
d1275 1
a1275 2
			free_client_lease(lease);
			return (NULL);
d1388 1
d1398 3
@


1.368
log
@Convert to arc4random_uniform.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.367 2015/12/05 13:09:11 claudio Exp $	*/
d597 8
@


1.367
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.366 2015/11/12 18:46:14 krw Exp $	*/
d1289 1
a1289 2
		client->interval += (arc4random() >> 2) %
		    (2 * client->interval);
d1294 2
a1295 2
		client->interval = ((config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % config->backoff_cutoff));
d1412 1
a1412 2
		client->interval += ((arc4random() >> 2) %
		    (2 * client->interval));
d1416 2
a1417 2
		client->interval = ((config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % client->interval));
@


1.366
log
@When link loss is reported, cancel any active timeout and wait for
link to return.

Inadvertantly broken in r1.308.

Problem noted by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.365 2015/10/26 16:32:33 krw Exp $	*/
d2017 1
a2017 1
		if ((n = imsg_read(priv_ibuf)) == -1) {
@


1.365
log
@Give dhclient(8) the ability to use option 119, a.k.a. "Domain
Search" if supplied by the server.

Requested by a few. Original diff from Ray Lai via tech@@.

Tested & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.364 2015/09/08 17:19:20 krw Exp $	*/
d359 1
a359 1
			} else if (strlen(path_option_db)) {
d361 2
a362 1
				write_option_db("", 0);
@


1.364
log
@Correct strsep() usage to free() correct string. Spotted by and
original diff from Michael McConville via tech@@. Thanks!

ok millert@@ beck@@ guenther@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.363 2015/09/05 07:41:16 krw Exp $	*/
d102 1
a102 1
		     struct option_data *);
d908 2
a909 1
	    &options[DHO_DOMAIN_NAME], &options[DHO_DOMAIN_NAME_SERVERS]);
d1101 2
a1102 2
	char *pretty;
	int i;
d1124 15
d1936 3
a1938 2
 * resolv_conf(5) says a max of 6 domains and total length of 1024 bytes are
 * acceptable for the 'search' statement.
d1946 1
a1946 1
	if (strlen(names) >= 1024)
d1960 1
a1960 1
		if (count > 6)
d2115 1
a2115 1
    struct option_data *nameservers)
d2117 1
a2117 1
	char *dn, *ns, *nss[MAXNS], *contents, *courtesy, *p;
d2119 1
a2119 1
	int i, rslt;
d2123 15
a2137 1
	if (domainname->len) {
@


1.363
log
@Some whitespace bulking out a diff unnecessarily.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.362 2015/08/31 21:32:07 krw Exp $	*/
d1926 1
a1926 1
	char *hn, *inputstring;
d1932 1
a1932 1
	inputstring = strdup(names);
d1947 1
a1947 1
	free(inputstring);
@


1.362
log
@Support deviant but historically blessed practice of accepting
multiple domain names in dhcp option 15 (Domain Name). This allows
resolv.conf 'search' statements to be built with multiple entries.

Adhere to the limits stated in resolv.conf(5) - no more than 6
domains and less than 1024 characters total length.

Encountered in the wild and fix tested by beck@@. Feedback from
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.361 2015/05/18 14:59:42 krw Exp $	*/
d917 1
a917 1
 
@


1.361
log
@Stop rejecting leases with a subnet that overlaps a subnet already
present. The latest routing stack code can now handle these situations.

Much requested by beck@@ and others. Detailed discussion at s2k15
identified required routing changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.360 2015/04/16 15:14:30 gsoares Exp $	*/
d97 1
d1123 13
a1136 1
		case DHO_DOMAIN_NAME:
d1917 33
@


1.360
log
@Tweak error output.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.359 2015/02/15 01:56:42 tedu Exp $	*/
a1061 7

	/*
	 * Reject offers whose subnet is already configured on another
	 * interface.
	 */
	if (subnet_exists(lease))
		return;
@


1.359
log
@convert bcmp to memcmp
ok doug millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.358 2015/02/10 04:20:26 krw Exp $	*/
d470 1
a470 1
		error("'%s' is not an interface", ifi->name);
@


1.358
log
@Groundwork for better route support over multiple interfaces by
using RTM_IFA to bind routes to an interface. Keep the subnet route
conflict avoidance code for the time being.

diff from claudio@@ as part of larger routing magic diff.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.357 2015/02/07 10:08:06 krw Exp $	*/
d2478 1
a2478 1
	if (bcmp(&gateway, &addr, sizeof(addr)) != 0) {
@


1.357
log
@Add support for interface-mtu (option 26).

Original request+diff from matthew@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.356 2015/02/07 02:07:32 krw Exp $	*/
d111 1
a111 1
void add_static_routes(struct option_data *);
d967 2
a968 1
			add_static_routes(&options[DHO_STATIC_ROUTES]);
d2447 3
a2449 1
	add_route(dest, mask, iface,
d2479 1
a2479 1
		addrs |= RTA_GATEWAY;
d2483 1
a2483 1
	add_route(dest, netmask, gateway, addrs, flags);
d2487 1
a2487 1
add_static_routes(struct option_data *static_routes)
d2505 2
a2506 2
		add_route(dest, netmask, gateway,
		    RTA_DST | RTA_GATEWAY, RTF_GATEWAY | RTF_STATIC);
d2543 2
a2544 2
			add_route(dest, netmask, gateway,
			    RTA_DST | RTA_GATEWAY | RTA_NETMASK,
@


1.356
log
@GC unused parameters now that ifname and rdomain are not used in
constructing imsgs.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.355 2015/02/06 09:16:06 reyk Exp $	*/
d916 12
@


1.355
log
@The write_file() privsep interface was too permissive and
theoretically allowed the unprivileged child process to write to
arbitrary files.  Restrict it by replacing it with two specific
write_resolv_conf() and write_option_db() privsep interfaces where all
the critical decision has been moved to the parent.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.354 2015/02/06 06:47:29 krw Exp $	*/
d109 4
a112 4
void add_direct_route(int, struct in_addr, struct in_addr, struct in_addr);
void add_default_route(int, struct in_addr, struct in_addr);
void add_static_routes(int, struct option_data *);
void add_classless_static_routes(int, struct option_data *, struct in_addr);
d308 1
a308 1
			add_address(ifi->name, 0, b, b);
d914 2
a915 2
	delete_addresses(ifi->name, ifi->rdomain);
	flush_routes(ifi->name, ifi->rdomain);
d927 1
a927 1
	add_address(ifi->name, ifi->rdomain, client->active->address, mask);
d929 1
a929 1
		add_classless_static_routes(ifi->rdomain,
d933 1
a933 1
		add_classless_static_routes(ifi->rdomain,
d948 1
a948 1
				add_direct_route(ifi->rdomain, gateway, mask,
d952 1
a952 2
			add_default_route(ifi->rdomain, client->active->address,
			    gateway);
d955 1
a955 2
			add_static_routes(ifi->rdomain,
			    &options[DHO_STATIC_ROUTES]);
d1366 2
a1367 4
		if (client->active) {
			delete_address(ifi->name, ifi->rdomain,
			    client->active->address);
		}
d2365 1
a2365 1
	if (!resolv_conf_priority(ifi->rdomain))
d2432 1
a2432 1
add_direct_route(int rdomain, struct in_addr dest, struct in_addr mask, struct in_addr iface)
d2434 1
a2434 1
	add_route(rdomain, dest, mask, iface,
d2448 1
a2448 1
add_default_route(int rdomain, struct in_addr addr, struct in_addr gateway)
d2468 1
a2468 1
	add_route(rdomain, dest, netmask, gateway, addrs, flags);
d2472 1
a2472 1
add_static_routes(int rdomain, struct option_data *static_routes)
d2490 1
a2490 1
		add_route(rdomain, dest, netmask, gateway,
d2496 1
a2496 2
add_classless_static_routes(int rdomain, struct option_data *opt,
    struct in_addr iface)
d2526 1
a2526 1
			add_direct_route(rdomain, dest, netmask, iface);
d2528 1
a2528 1
			add_route(rdomain, dest, netmask, gateway,
@


1.354
log
@matthew@@ points out that it's a bad idea to rely on the non-privileged,
network-facing process to properly fill out the interface name and
rdomain on which operations are to be performed.

Instead, always use the interface name and rdomain discovered before
forking and dropping privs. Lets all the imsg structs to drop a
couple of members.

ok matthew@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.353 2015/02/05 23:56:06 krw Exp $	*/
d102 3
a104 2
void		 write_file(char *, int, mode_t, uid_t, gid_t, u_int8_t *,
		     size_t);
d360 1
a360 4
				write_file(path_option_db,
				    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC |
				    O_EXLOCK | O_NOFOLLOW, S_IRUSR | S_IWUSR |
				    S_IRGRP, 0, 0, "", 0);
d381 1
a381 4
		write_file("/etc/resolv.conf",
		    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 0, 0,
		    client->active->resolv_conf,
d1731 1
a1731 3
	write_file(path_option_db,
	    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK | O_NOFOLLOW,
	    S_IRUSR | S_IWUSR | S_IRGRP, 0, 0, db, strlen(db));
d2333 14
a2346 2
write_file(char *path, int flags, mode_t mode, uid_t uid, gid_t gid,
    u_int8_t *contents, size_t sz)
d2348 6
a2353 3
	struct iovec iov[2];
	struct imsg_write_file imsg;
	size_t rslt;
d2355 8
a2362 1
	memset(&imsg, 0, sizeof(imsg));
d2364 2
a2365 3
	rslt = strlcpy(imsg.path, path, sizeof(imsg.path));
	if (rslt >= sizeof(imsg.path)) {
		warning("write_file: path too long (%zu)", rslt);
d2369 10
a2378 5
	imsg.len = sz;
	imsg.flags = flags;
	imsg.mode = mode;
	imsg.uid = uid;
	imsg.gid = gid;
d2380 5
a2384 4
	iov[0].iov_base = &imsg;
	iov[0].iov_len = sizeof(imsg);
	iov[1].iov_base = contents;
	iov[1].iov_len = sz;
d2386 7
a2392 3
	rslt = imsg_composev(unpriv_ibuf, IMSG_WRITE_FILE, 0, 0, -1, iov, 2);
	if (rslt == -1)
		warning("write_file: imsg_composev: %s", strerror(errno));
d2394 3
a2396 1
	flush_unpriv_ibuf("write_file");
d2400 2
a2401 1
priv_write_file(struct imsg_write_file *imsg)
d2406 1
a2406 5
	if ((strcmp("/etc/resolv.conf", imsg->path) == 0) &&
	    !resolv_conf_priority(ifi->rdomain))
		return;

	fd = open(imsg->path, imsg->flags, imsg->mode);
d2408 1
a2408 1
		note("Couldn't open '%s': %s", imsg->path, strerror(errno));
d2412 1
a2412 1
	n = write(fd, imsg+1, imsg->len);
d2414 1
a2414 1
		note("Couldn't write contents to '%s': %s", imsg->path,
d2416 10
a2425 10
	else if (n < imsg->len)
		note("Short contents write to '%s' (%zd vs %zu)", imsg->path,
		    n, imsg->len);

	if (fchmod(fd, imsg->mode) == -1)
		note("fchmod(fd, 0x%x) of '%s' failed (%s)", imsg->mode,
		    imsg->path, strerror(errno));
	if (fchown(fd, imsg->uid, imsg->gid) == -1)
		note("fchown(fd, %d, %d) of '%s' failed (%s)", imsg->uid,
		    imsg->gid, imsg->path, strerror(errno));
@


1.353
log
@Use sizeof(struct X) rather than sizeof(*p) in calloc() invocations.
History indicates this is slightly less error prone.

Inconsistant usage pointed out by Benjamin Baier.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.352 2015/02/01 18:43:39 krw Exp $	*/
a1989 2
		strlcpy(imsg.ifname, ifi->name, sizeof(imsg.ifname));
		imsg.rdomain = ifi->rdomain;
a2354 1
	imsg.rdomain = ifi->rdomain;
d2380 1
a2380 1
	    !resolv_conf_priority(imsg->rdomain))
@


1.352
log
@free(NULL) works, so stop checking for non-zero length allocation
or non-NULLness before calling free().

This batch from Benjamin Baier.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.351 2015/01/31 23:18:29 krw Exp $	*/
d469 1
a469 1
	ifi = calloc(1, sizeof(*ifi));
d496 1
a496 1
	config = calloc(1, sizeof(*config));
d501 1
a501 1
	client = calloc(1, sizeof(*client));
@


1.351
log
@free(NULL) works, so stop checking for non-zero length allocation
or non-NULLness before calling free().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.350 2015/01/31 23:05:58 krw Exp $	*/
d880 2
a881 2
	 * If it's been here before (e.g. static lease), clear out any
	 * old resolv_conf.
d883 2
a884 4
	if (client->new->resolv_conf) {
		free(client->new->resolv_conf);
		client->new->resolv_conf = NULL;
	}
d2145 1
a2145 2
		if (newlease->filename)
			free(newlease->filename);
d2149 1
a2149 2
		if (newlease->server_name)
			free(newlease->server_name);
@


1.350
log
@Don't leak the "access protected, zero sized object" returned by
calloc(N, 0). Avoid the whole controversy by skipping zero length
options while cloning a lease.

Leak reported by Remco van den Berg via bugs@@. Additional testing
and diagnostic help from Benjamin Baier. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.349 2015/01/31 05:56:19 krw Exp $	*/
d1661 6
a1666 10
	if (lease->server_name)
		free(lease->server_name);
	if (lease->filename)
		free(lease->filename);
	if (lease->resolv_conf)
		free(lease->resolv_conf);
	for (i = 0; i < 256; i++) {
		if (lease->options[i].len)
			free(lease->options[i].data);
	}
d2175 1
a2175 2
			if (newlease->options[i].len != 0)
				free(newlease->options[i].data);
d2186 1
a2186 2
			if (newlease->options[i].len != 0)
				free(newlease->options[i].data);
d2201 1
a2201 2
			if (newlease->options[i].len != 0)
				free(newlease->options[i].data);
@


1.349
log
@Set is_static to 0 before trying to free a lease. Otherwise it
might leak. *Should* not be possible but better safe than sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.348 2015/01/30 14:30:54 krw Exp $	*/
d2291 2
@


1.348
log
@Don't leak incompletely cloned static lease. Should never happen
but better safe than sorry.

Noted and diff from Benjamin Baier. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.347 2015/01/16 06:39:56 deraadt Exp $	*/
d2245 2
a2246 1
	if (newlease)
d2248 1
@


1.347
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.346 2014/12/10 02:34:03 krw Exp $	*/
d2300 2
a2301 1
	if (newlease)
d2303 1
@


1.346
log
@Reusing the same field for different things in different contexts may
be clever, but it is definitely confusing. Use a flag IFI_VALID_LLADDR
to indicate that the ifi->hw_address field is valid, rather than
assuming ifi->linkstat does that. Add startup_time to record client
startup rather than using first_sending and hoping nobody else needs
it until link is complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.345 2014/12/10 01:05:13 krw Exp $	*/
d71 1
a71 1
char path_option_db[MAXPATHLEN];
d444 1
a444 1
			strlcat(path_option_db, optarg, MAXPATHLEN);
@


1.345
log
@The consensus is that RTM_IFINFO messages do not always carry the
latest information. So back off to using interface_status() to
directly query the interface when link status is in question. Partly
from Nathanael Rensen's original diff.

Also, while waiting for initial link, keep checking every second
rather than backing off to checking every (default) 60 seconds after
(default) 10 seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.344 2014/12/09 02:27:54 krw Exp $	*/
d330 1
a330 1
		if (ifi->linkstat) {
d602 1
d638 1
a638 4
	if (client->first_sending == 0)
		client->first_sending = cur_time;

	interval = (int)(cur_time - client->first_sending);
@


1.344
log
@Move the initial link status check and possible forceup back before
the routing socket initialization. Otherwise certain combinations
of UP/RUNNING/active will generate the deadly RTM_IFINFO with RTF_UP
== 0 and kill the client. Add comment to nail this section in place.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.343 2014/12/08 02:04:58 krw Exp $	*/
d341 1
a341 4
		linkstat =
		    LINK_STATE_IS_UP(ifm->ifm_data.ifi_link_state) ? 1 : 0;
		linkstat = linkstat || (ifi->flags & IFI_NOMEDIA);
		linkstat = linkstat && (ifm->ifm_flags & IFF_UP);
d353 3
a356 2
				client->state = S_REBOOTING;
				set_timeout_interval(1, state_reboot);
d642 2
d660 5
a664 2
	if (!ifi->linkstat) {
		if (interval > config->link_timeout) {
d666 2
a667 4
			set_timeout_interval(config->retry_interval,
			    state_preboot);
		} else
			set_timeout_interval(1, state_preboot);
@


1.343
log
@Try harder to avoid displaying "no link ... got link" when initial
link comes up and nothing has yet been displayed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.342 2014/12/07 22:45:39 krw Exp $	*/
d562 10
a583 4

	ifi->linkstat = interface_status(ifi->name);
	if (ifi->linkstat == 0)
		interface_link_forceup(ifi->name);
@


1.342
log
@Do not move from S_PREBOOT to S_REBOOT just because link_timeout
has expired. In S_REBOOT state_reboot() assumes link is present and
starts sending REQUEST/DISCOVER packets and doing the backoff dance
after retry_interval expires. Stay in S_PREBOOT until link appears.

Pointed out by and initial diff from Nathanael Rensen.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.341 2014/12/07 17:01:09 krw Exp $	*/
d639 1
a639 1
		if (!preamble) {
a640 1
			fflush(stderr);
d643 7
a649 8
		if (ifi->linkstat) {
			fprintf(stderr, " got link\n");
			fflush(stderr);
		} else if (interval > config->link_timeout) {
			fprintf(stderr, " sleeping\n");
			fflush(stderr);
		} else {
			fprintf(stderr, ".");
@


1.341
log
@Ensure we grab the interface LLADDR as soon as the link state is
noted as being up. Thus avoiding a premature exit if extra RTM_IFINFO
messages arrive before state_reboot() gets a chance to run.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.340 2014/12/07 15:28:23 krw Exp $	*/
a658 1
			client->state = S_REBOOTING;
d660 1
a660 1
			    state_reboot);
@


1.340
log
@Retract check for IFF_RUNNING when checking for link state. At least
some interfaces (e.g. em(4) in qemu) do not have this flag set in
the RTM_IFINFO message dhclient gets.

Problem found & fix tested by Nathanael Rensen. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.339 2014/12/05 15:47:05 krw Exp $	*/
d353 1
a353 1
				if (client->state == S_PREBOOT)
d355 2
@


1.339
log
@Move initial wait for network link into the state machine by adding
state S_PREBOOT and associated state_preboot() function.

This results in routing socket messages being processed even while
the link is being waited for. Thus the RTM_IFINFO message announcing
the link is ready can be reacted to immediately, rather than waiting
for the sleep(1)'ing process to wake up and look at the link state.

Some interfaces seem to lose the first packet sent when the RTM_IFINFO
message is reacted to so quickly, so temporarily leave in place an
explicit delay before sending the first packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.338 2014/11/30 00:09:30 krw Exp $	*/
d344 1
a344 3
		linkstat = linkstat &&
			((ifm->ifm_flags & (IFF_UP | IFF_RUNNING)) ==
			(IFF_UP | IFF_RUNNING));
@


1.338
log
@Don't check for hardware address change unless link was up. Delay
construction of default client identifier until link is up (i.e.
do it in state_reboot()).
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.337 2014/11/29 22:06:55 krw Exp $	*/
d116 1
d355 2
d358 1
a358 1
				state_reboot();
d407 1
a407 1
	int	 ch, fd, i = 0, socket_fd[2];
d509 1
a509 1
	read_client_conf();	/* Needed for config->link_timeout below! */
a510 23
	if (interface_status(ifi->name) == 0) {
		interface_link_forceup(ifi->name);
		/* Give it up to 4 seconds of silent grace to find link */
		i = -4;
	} else
		i = 0;

	while (!(ifi->linkstat = interface_status(ifi->name))) {
		if (i == 0)
			fprintf(stderr, "%s: no link ...", ifi->name);
		else if (i > 0)
			fprintf(stderr, ".");
		fflush(stderr);
		if (++i > config->link_timeout) {
			fprintf(stderr, " sleeping\n");
			goto dispatch;
		}
		sleep(1);
	}
	if (i > 0)
		fprintf(stderr, " got link\n");

 dispatch:
a516 4
	/* Register the interface. */
	if_register_receive();
	if_register_send();

d575 8
d599 2
a600 2
	client->state = S_REBOOTING;
	if (ifi->linkstat)
d602 4
a605 2
	else
		go_daemon();
d622 43
@


1.337
log
@Explicitly initialize client->state to S_REBOOTING rather than
relying on S_REBOOTING being 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.336 2014/11/27 23:04:12 krw Exp $	*/
d329 9
a337 7
		memcpy(&hw, &ifi->hw_address, sizeof(hw));
		get_hw_address();
		if (memcmp(&hw, &ifi->hw_address, sizeof(hw))) {
			warning("LLADDR changed; restarting");
			ifi->flags |= IFI_NEW_LLADDR;
			quit = SIGHUP;
			goto done;
a406 1
	struct option_data *opt;
a536 19
	get_hw_address();
	opt = &config->send_options[DHO_DHCP_CLIENT_IDENTIFIER];
	/*
	 * Check both len && data so
	 *     send dhcp-client-identifier "";
	 * can be used to suppress sending the default client
	 * identifier.
	 */
	if (opt->len == 0 && opt->data == NULL) {
		/* Build default client identifier. */
		opt->data = calloc(1, ETHER_ADDR_LEN + 1);
		if (opt->data != NULL) {
			opt->data[0] = HTYPE_ETHER;
			memcpy(&opt->data[1], ifi->hw_address.ether_addr_octet,
			    ETHER_ADDR_LEN);
			opt->len = ETHER_ADDR_LEN + 1;
		}
	}

d645 1
d651 19
@


1.336
log
@Use if_nametoindex() to get the interface index, and thereby check
the validity of the interface name as soon the actual name is known.
i.e. right after 'egress' is expanded. One less thing for
get_hw_address() to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.335 2014/11/25 17:03:03 krw Exp $	*/
d633 2
a634 2
	if (ifi->linkstat) {
		client->state = S_REBOOTING;
d636 1
a636 1
	} else
@


1.335
log
@r1.118 starting using LINK_STATE_IS_UP() to check the link status
info provided in RTM_IFINFO messages. But it didn't replicate the
checks for IFI_NOMEDIA and (IFF_UP | IFF_RUNNING) used in
interface_status() to set ifi->linkstat. So the test (LINK_STATE_IS_UP()
!= ifi->linkstat) was comparing kiwi fruit and hairballs.

Do the additional checks using info present in the RTM_IFINFO
message.  As a result interface_status() need not be called to
update ifi->linkstat. Thus avoiding opening/closing a socket and
some ioctls to re-obtain the info already provided in the RTM_IFINFO
message.

Using RTM_IFINFO data ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.334 2014/11/23 18:22:45 krw Exp $	*/
d471 3
@


1.334
log
@Rename discover_interface() to more meaningful get_hw_address().

Hoist one-time initialization of client identifier out of
get_hw_address() to the one-time initialization code in main().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.333 2014/11/20 19:27:28 krw Exp $	*/
d340 4
d350 1
a350 1
			ifi->linkstat = interface_status(ifi->name);
@


1.333
log
@A little too agressive reordering. Must initialize the client struct
before filling it in with read_client_conf(). Fixes seg fault when
lease {} statement is used.

Problem reported by Alessandro de Laurenzis via misc@@. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.332 2014/11/17 16:18:20 krw Exp $	*/
d330 1
a330 1
		discover_interface();
d401 1
d529 18
a546 2
	/* set up the interface */
	discover_interface();
@


1.332
log
@Further juggle startup code, putting config file reading after forking
the priv child but before getting hardware link. Reducing further the
possibly inappropriate information the priv child could read.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.331 2014/11/16 21:05:24 krw Exp $	*/
d491 6
a537 6

	client = calloc(1, sizeof(*client));
	if (client == NULL)
		error("client calloc");
	TAILQ_INIT(&client->leases);
	TAILQ_INIT(&client->offered_leases);
@


1.331
log
@Move some memory allocations/initialization and file reading to
after forking the privileged process, which should not be reading
those bits. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.330 2014/11/15 00:12:52 krw Exp $	*/
a464 5
	config = calloc(1, sizeof(*config));
	if (config == NULL)
		error("config calloc");
	TAILQ_INIT(&config->reject_list);

d475 16
a527 11

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    PF_UNSPEC, socket_fd) == -1)
		error("socketpair: %s", strerror(errno));

	fork_privchld(socket_fd[0], socket_fd[1]);

	close(socket_fd[0]);
	if ((unpriv_ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		error("no memory for unpriv_ibuf");
	imsg_init(unpriv_ibuf, socket_fd[1]);
@


1.330
log
@Make -q (quiet) and -d (don't daemonize) options mutually exclusive.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.329 2014/11/04 04:03:10 krw Exp $	*/
a464 5
	client = calloc(1, sizeof(*client));
	if (client == NULL)
		error("client calloc");
	TAILQ_INIT(&client->leases);
	TAILQ_INIT(&client->offered_leases);
a470 3
	if (path_dhclient_db == NULL && asprintf(&path_dhclient_db, "%s.%s",
	    _PATH_DHCLIENT_DB, ifi->name) == -1)
		error("asprintf");
d480 1
a480 30
	read_client_conf();
	if (ignore_list)
		apply_ignore_list(ignore_list);

	tailfd = open("/etc/resolv.conf.tail", O_RDONLY);
	if (tailfd == -1) {
		if (errno != ENOENT)
			error("Cannot open /etc/resolv.conf.tail: %s",
			    strerror(errno));
	} else if (fstat(tailfd, &sb) == -1) {
		error("Cannot stat /etc/resolv.conf.tail: %s",
		    strerror(errno));
	} else {
		if (sb.st_size > 0 && sb.st_size < SIZE_MAX) {
			config->resolv_tail = calloc(1, sb.st_size + 1);
			if (config->resolv_tail == NULL) {
				error("no memory for resolv.conf.tail "
				    "contents: %s", strerror(errno));
			}
			tailn = read(tailfd, config->resolv_tail, sb.st_size);
			if (tailn == -1)
				error("Couldn't read resolv.conf.tail: %s",
				    strerror(errno));
			else if (tailn == 0)
				error("Got no data from resolv.conf.tail");
			else if (tailn != sb.st_size)
				error("Short read of resolv.conf.tail");
		}
		close(tailfd);
	}
d528 41
@


1.329
log
@Of the 14 occurances of free_client_lease() only 2 deal with leases
that might be in the client->leases TAILQ. So don't traverse said
TAILQ in free_client_lease() trying see if the lease should be
TAILQ_REMOVE()'d. Instead use TAILQ_REMOVE() in the two places (one
of which is dubious) where it might be relevant. Be careful not to
TAILQ_REMOVE() a static lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.328 2014/11/04 01:20:27 guenther Exp $	*/
d421 3
a423 1
			no_daemon = 1;
d445 3
a447 1
			log_perror = 0;
d623 1
a623 1
	    "usage: %s [-dqu] [-c file] [-i options] [-L file] [-l file] "
@


1.328
log
@Instead of correcting things after the fact, use SOCK_NONBLOCK and SOCK_CLOEXEC
to create the socketpair() with non-blocking and close-on-exec set.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.327 2014/11/03 02:22:15 krw Exp $	*/
d918 2
a919 1
		    client->active->address.s_addr)
d921 1
d1151 6
a1156 1
	free_client_lease(client->active);
a1589 1
	struct client_lease *lp, *pl;
a1594 5

	TAILQ_FOREACH_SAFE(lp, &client->leases, next, pl) {
		if (lease == lp)
			TAILQ_REMOVE(&client->leases, lp, next);
	}
@


1.327
log
@No need to immediately remove an expired lease from the list of
leases. It will be ignored, so let the normal cleanup in bind_lease()
take care of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.326 2014/11/02 15:18:32 krw Exp $	*/
a105 1
void		 socket_nonblockmode(int);
d551 2
a552 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, socket_fd) == -1)
a553 4
	socket_nonblockmode(socket_fd[0]);
	fcntl(socket_fd[0], F_SETFD, FD_CLOEXEC);
	socket_nonblockmode(socket_fd[1]);
	fcntl(socket_fd[1], F_SETFD, FD_CLOEXEC);
a2237 14
}

void
socket_nonblockmode(int fd)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		error("fcntl F_GETF: %s", strerror(errno));

	flags |= O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		error("fcntl F_SETFL: %s", strerror(errno));
@


1.326
log
@Pesky whitespace and spurious parenthesis.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.325 2014/11/01 15:49:07 krw Exp $	*/
d642 1
a642 2
	if (client->active && client->active->expiry <= cur_time) {
		free_client_lease(client->active);
a643 1
	}
@


1.325
log
@Try to ensure that the various lease timeouts are sane. i.e., renew
is before rebind is before expiry. Don't allow lease expiry to be
set past the end of time, but do allow lease lengths >INT32_MAX.

Tweak default times to be more reliably in-line with RFCs.

Nuke getULong(), the last function in convert.c, since its last
uses were in this now re-written code.

Suspicions aroused while diagnosing the expiry problem weerd@@ found.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.324 2014/10/29 15:28:51 krw Exp $	*/
d1029 1
a1029 1
	else {
a1030 1
	}
d1339 1
a1339 1
 	 * If the reboot timeout has expired, or the lease rebind time has
d2388 1
a2388 1
 * 	route -q $rdomain add default $router
@


1.324
log
@Calling a function to htonl() a constant 32-bit value into a stack
variable and memcpy() that value into 4 bytes of malloc()'d space
seems roundabout.

Just memcpy() a four byte constant string into the malloc()'d space
as required and kill putULong(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.323 2014/10/27 19:54:31 krw Exp $	*/
a67 3
#define DEFAULT_LEASE_TIME	43200	/* 12 hours. */
#define TIME_MAX		2147483647

d2523 8
a2530 1
	time_t cur_time;
d2535 40
a2574 29
	 */
	if (lease->options[DHO_DHCP_LEASE_TIME].len == 4)
		lease->expiry =
		    getULong(lease->options[DHO_DHCP_LEASE_TIME].data);
	else
		lease->expiry = DEFAULT_LEASE_TIME;
	if (lease->options[DHO_DHCP_RENEWAL_TIME].len == 4)
		lease->renewal =
		    getULong(lease->options[DHO_DHCP_RENEWAL_TIME].data);
	else
		lease->renewal = lease->expiry / 2;
	if (lease->options[DHO_DHCP_REBINDING_TIME].len == 4)
		lease->rebind =
		    getULong(lease->options[DHO_DHCP_REBINDING_TIME].data);
	else
		lease->rebind = lease->renewal + lease->renewal / 2 +
		    lease->renewal / 4;

	/*
	 * A number that looks negative here is really just very large,
	 * because the lease expiry offset is unsigned.
	 */
	if (lease->expiry < 0)
		lease->expiry = TIME_MAX;
	/* XXX should be fixed by resetting the client state */
	if (lease->expiry < 60)
		lease->expiry = 60;

	time(&cur_time);
d2576 1
a2576 1
	/* Lease lengths can never be negative. */
a2577 2
	if (lease->expiry < cur_time)
		lease->expiry = TIME_MAX;
a2578 2
	if (lease->renewal < cur_time)
		lease->renewal = TIME_MAX;
a2579 2
	if (lease->rebind < cur_time)
		lease->rebind = TIME_MAX;
@


1.323
log
@Compare with/use UINT16_MAX rather than 65535. Less magic is more.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.322 2014/10/26 23:36:44 krw Exp $	*/
d730 8
a737 3
		 * Fake up DHO_DHCP_LEASE_TIME, DHO_RENEWAL_TIME and
		 * DHO_REBINDING_TIME options so bind_lease() can
		 * set the times.
d743 1
a743 1
			putULong(option->data, 12000);
d749 1
a749 1
			putULong(option->data, 8000);
d755 1
a755 1
			putULong(option->data, 10000);
@


1.322
log
@Allow the current lease to expire without causing dhclient to seg
fault when it tries to get a new one.

Problem spotted by weerd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.321 2014/10/17 13:21:44 krw Exp $	*/
d66 1
d1212 1
a1212 1
	if (interval < 65536)
d1215 1
a1215 1
		client->bootrequest_packet.secs = htons(65535);
d1360 1
a1360 1
		if (interval < 65536)
d1363 1
a1363 1
			client->bootrequest_packet.secs = htons(65535);
@


1.321
log
@Nuke 'increase' which was always set to 1. Replace the if/else that tested
its value with the body of the if. No functional change.

'increase' was orphaned when r1.139 eliminated support for 'medium'
statements in dhclient.conf.

Stumbled over while looking into a problem for weerd@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.320 2014/10/02 18:04:49 matthew Exp $	*/
d636 1
a636 1
	struct client_lease *lp, *pl;
d650 1
a650 1
	TAILQ_FOREACH_SAFE(lp, &client->leases, next, pl) {
d653 1
a653 3
		else if (lp->expiry <= cur_time)
			free_client_lease(lp);
		else {
d814 1
d909 4
a912 1
	/* Remove previous dynamic lease(es) for this address. */
d914 1
d920 1
a920 1
		else if (lease->address.s_addr ==
d1232 1
a1232 1
	struct client_lease *lp, *pl;
d1240 1
a1240 1
	TAILQ_FOREACH_SAFE(lp, &client->leases, next, pl) {
a1244 1
			free_client_lease(lp);
@


1.320
log
@dhclient: add support for RFC 3442 local subnet routes

If the classless-static-routes option specifies the router IP address
as 0.0.0.0, then that indicates the route is a "local subnet route"
that should be directly routable via the interface. This reuses the
"route add -net $dest -netmask $mask -cloning -iface $addr" trick
suggested by claudio@@ for r1.272.

Restores interoperability with Google Compute Engine after recent GCE
DHCP server changes.

ok krw, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.319 2014/08/11 18:41:13 tobias Exp $	*/
d1169 1
a1169 1
	int interval, increase = 1;
d1188 6
a1193 7
	if (increase) {
		if (!client->interval)
			client->interval = config->initial_interval;
		else {
			client->interval += (arc4random() >> 2) %
			    (2 * client->interval);
		}
d1195 4
a1198 7
		/* Don't backoff past cutoff. */
		if (client->interval > config->backoff_cutoff)
			client->interval = ((config->backoff_cutoff / 2)
				 + ((arc4random() >> 2) %
				    config->backoff_cutoff));
	} else if (!client->interval)
		client->interval = config->initial_interval;
@


1.319
log
@When parsing 32 bit values, verify that we received 4 bytes.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.318 2014/07/13 14:50:03 krw Exp $	*/
d111 1
d114 1
a114 1
void add_classless_static_routes(int, struct option_data *);
d876 2
a877 1
		    &options[DHO_CLASSLESS_STATIC_ROUTES]);
d880 2
a881 1
		    &options[DHO_CLASSLESS_MS_STATIC_ROUTES]);
d889 3
a891 5
			 * If we were given a /32 IP assignment, then make sure
			 * the gateway address is routable with equivalent of
			 *
			 *     route add -net $gw -netmask 255.255.255.255 \
			 *         -cloning -iface $addr
d894 2
a895 4
				add_route(ifi->rdomain, gateway, mask,
				    client->active->address,
				    RTA_DST | RTA_NETMASK | RTA_GATEWAY,
				    RTF_CLONING | RTF_STATIC);
d2370 12
d2438 3
a2440 1
void add_classless_static_routes(int rdomain, struct option_data *opt)
d2470 5
a2474 5
			continue; /* OBSD TCP/IP doesn't support this. */

		add_route(rdomain, dest, netmask, gateway,
		    RTA_DST | RTA_GATEWAY | RTA_NETMASK,
		    RTF_GATEWAY | RTF_STATIC);
@


1.318
log
@When renewing a lease, update client->active or you end up in a
tight renew loop. Caused by recent reshuffling of code in
bind_lease().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.317 2014/07/12 21:04:07 krw Exp $	*/
d2515 1
a2515 1
	if (lease->options[DHO_DHCP_LEASE_TIME].data)
d2520 1
a2520 1
	if (lease->options[DHO_DHCP_RENEWAL_TIME].len)
d2525 1
a2525 1
	if (lease->options[DHO_DHCP_REBINDING_TIME].len)
@


1.317
log
@Log a warning whenever RTM_DESYNC is seen. Thus giving entrail
investigators some clue why dhclient may have gotten confused when
some RTM_ messages vanish.

sthen@@ thinks this is a good start.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.316 2014/07/12 09:04:21 krw Exp $	*/
d843 2
d846 2
a847 2
		    inet_ntoa(client->new->address),
		    (long long)(client->new->renewal - time(NULL)));
@


1.316
log
@Bring back resolv.conf write reduction. Race was something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.315 2014/07/11 21:08:20 krw Exp $	*/
d231 3
@


1.315
log
@Sigh. Further torture finds a race. Back to drawing board for
reducing resolv.conf writing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.314 2014/07/11 20:41:41 krw Exp $	*/
d306 2
d373 2
a374 1
	if (client->active && client->active->resolv_conf)
d846 7
d867 1
a867 1
	add_address(ifi->name, ifi->rdomain, client->new->address, mask);
d889 1
a889 1
				    client->new->address,
d894 1
a894 1
			add_default_route(ifi->rdomain, client->new->address,
a901 8
	client->new->resolv_conf = resolv_conf_contents(
	    &options[DHO_DOMAIN_NAME], &options[DHO_DOMAIN_NAME_SERVERS]);
	if (client->new->resolv_conf)
		write_file("/etc/resolv.conf",
		    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 0, 0,
		    client->new->resolv_conf, strlen(client->new->resolv_conf));

a902 3
	/* Replace the old active lease with the new one. */
	client->active = client->new;
	client->new = NULL;
@


1.314
log
@Move updating resolv.conf contents and active lease to before address
manipulation starts. Thus making it more likely the correct resolv.conf
gets written.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.313 2014/07/11 20:19:30 krw Exp $	*/
a306 2
			/* No need to write out our resolv.conf. */
			client->flags &= ~IS_RESPONSIBLE;
d371 1
a371 2
	if (client->active && client->active->resolv_conf &&
	    client->flags & IS_RESPONSIBLE)
a842 7
	client->new->resolv_conf = resolv_conf_contents(
	    &options[DHO_DOMAIN_NAME], &options[DHO_DOMAIN_NAME_SERVERS]);

	/* Replace the old active lease with the new one. */
	client->active = client->new;
	client->new = NULL;

d892 8
d901 3
@


1.313
log
@Don't write out a new resolv.conf until the new address is added
and we become responsible for the interface. Don't write out a new
resolv.conf when our address has been deleted and we are no longer
responsible for the interface. Less writing is more better.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.312 2014/07/09 15:16:38 krw Exp $	*/
d846 7
a901 3
	client->new->resolv_conf = resolv_conf_contents(
	    &options[DHO_DOMAIN_NAME], &options[DHO_DOMAIN_NAME_SERVERS]);

a902 3
	/* Replace the old active lease with the new one. */
	client->active = client->new;
	client->new = NULL;
@


1.312
log
@Print sizeof() value and size_t variable with %zu rather than %zd.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.311 2014/05/23 17:36:59 krw Exp $	*/
d307 2
d373 2
a374 1
	if (client->active && client->active->resolv_conf)
a896 5
	if (client->new->resolv_conf)
		write_file("/etc/resolv.conf",
		    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 0, 0,
		    client->new->resolv_conf, strlen(client->new->resolv_conf));
@


1.311
log
@Make DEBUG a bit easier to use by calling setlogmask(LOG_UPTO(LOG_DEBUG))
when it is set, and the current setlogmask(LOG_UPTO(LOG_INFO)) when it
is not set.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.310 2014/05/23 15:26:22 krw Exp $	*/
d2353 1
a2353 1
		note("Short contents write to '%s' (%zd vs %zd)", imsg->path,
@


1.310
log
@A #define to rename another #define which is then used only once introduces
more obscurity than clarity. Nuke DHCPD_LOG_FACILITY and just use
LOG_DAEMON in openlog() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.309 2014/05/19 10:42:08 krw Exp $	*/
d405 3
d409 1
@


1.309
log
@Nuke some trailing whitespace that snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.308 2014/05/19 10:37:40 krw Exp $	*/
d404 1
a404 1
	openlog(__progname, LOG_PID | LOG_NDELAY, DHCPD_LOG_FACILITY);
@


1.308
log
@No point in trying to update the -L file on loss of link if no -L has
been specified. Eliminates spurious "Couldn't write ''" log messages.

Spotted while looking into Roman Gorelov's logs on another problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.307 2014/05/18 15:17:50 krw Exp $	*/
d805 2
a806 2
	int seen; 
	
@


1.307
log
@Don't add a lease to the leases TAILQ more than once. It tends to
make writing out the leases file go into an infinite loop until
/var is full.

Reported by Roman Gorelov via bugs@@

Fix tested & ok stsp@@ uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.306 2014/05/12 18:50:02 krw Exp $	*/
d347 1
a347 1
			} else {
@


1.306
log
@Don't exit on encountering RTM_NEWADDR or RTM_DELADDR routing messages
that lack the appropriate address info.

Simply ignore the message as is done for short or incorrectly
versioned messages

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.305 2014/05/11 14:00:52 krw Exp $	*/
d805 2
a806 1

d904 1
d908 3
a910 1
		if (client->active != lease && lease->address.s_addr ==
d914 1
a914 1
	if (!client->active->is_static)
@


1.305
log
@Tweak DHCPREQUEST log message to omit 'port N', since the port is not
set at that point, and is always set to 67 in send_packet().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.304 2014/05/11 12:40:37 krw Exp $	*/
d240 2
a241 4
		if (sa == NULL) {
			rslt = asprintf(&errmsg, "%s sa == NULL", ifi->name);
			goto die;
		}
d281 2
a282 4
		if (sa == NULL) {
			rslt = asprintf(&errmsg, "%s sa == NULL", ifi->name);
			goto die;
		}
@


1.304
log
@Rework/restore recorded lease handling. Actually use 'lease'
statements in dhclient.conf.

Recorded and static leases should now be bound to interfaces when
appropriate.

.... Ken
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.303 2014/05/05 18:02:49 krw Exp $	*/
d1360 2
a1361 2
	note("DHCPREQUEST on %s to %s port %hu", ifi->name,
	    inet_ntoa(destination.sin_addr), ntohs(destination.sin_port));
@


1.303
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.302 2014/05/05 14:44:18 krw Exp $	*/
d629 3
d636 18
d808 10
a817 1
	struct client_lease *lease;
d899 1
a900 3
newlease:
	if (client->active)
		free_client_lease(client->active);
d903 13
a920 3
	rewrite_option_db(client->active, lease);

	free_client_lease(lease);
d1226 1
a1226 1
	struct client_lease *loop = client->active;
a1231 7
	/*
	 * We may not have an active lease, but we may have some predefined
	 * leases that we can try.
	 */
	if (!client->active && !TAILQ_EMPTY(&client->leases))
		goto activate_next;

d1233 9
a1241 2
	while (client->active) {
		if (client->active->expiry > cur_time) {
d1243 1
a1243 1
			    inet_ntoa(client->active->address));
d1245 3
a1247 20
			/*
			 * If the old lease is still good and doesn't
			 * yet need renewal, go into BOUND state and
			 * timeout at the renewal time.
			 */
			if (cur_time < client->active->renewal) {
				client->state = S_BOUND;
				note("bound: renewal in %lld seconds.",
				    (long long)(client->active->renewal
				    - cur_time));
				set_timeout(client->active->renewal,
				    state_bound);
			} else {
				client->state = S_BOUND;
				note("bound: immediate renewal.");
				state_bound();
			}
			go_daemon();
			return;
		}
d1249 1
a1249 27
		/* If there are no other leases, give up. */
		if (TAILQ_EMPTY(&client->leases)) {
			TAILQ_INSERT_HEAD(&client->leases, client->active,
			    next);
			client->active = NULL;
			break;
		}

activate_next:
		/*
		 * Otherwise, put the active lease at the end of the lease
		 * list, and try another lease.
		 */
		if (client->active)
			TAILQ_INSERT_TAIL(&client->leases, client->active,
			    next);
		client->active = TAILQ_FIRST(&client->leases);
		TAILQ_REMOVE(&client->leases, client->active, next);

		/*
		 * If we already tried this lease, we've exhausted the set of
		 * leases, so we might as well give up for now.
		 */
		if (client->active == loop)
			break;
		else if (!loop)
			loop = client->active;
d1582 1
d1585 9
d1612 1
d1628 1
a1629 4
		/* Skip any leases that duplicate the active lease address. */
		if (client->active && lp->address.s_addr ==
		    client->active->address.s_addr)
			continue;
d1633 2
a1635 8
		if (leasestr)
			fprintf(leaseFile, "%s", leasestr);
		else
			warning("cannot make lease into string");
	}

	if (client->active) {
		leasestr = lease_as_string("lease", client->active);
@


1.302
log
@A couple of malloc()+memset(0) -> calloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.301 2014/05/04 21:07:50 krw Exp $	*/
d793 1
a793 1
	
d2112 1
a2112 1
		
d2275 1
a2275 1
		
@


1.301
log
@Factor out the code to set the expiry, renewal and rebinding times for
a lease. Will be reused in upcoming diff. No intentional behaviour
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.300 2014/04/30 15:11:00 krw Exp $	*/
d994 1
a994 1
	lease = malloc(sizeof(struct client_lease));
a998 2

	memset(lease, 0, sizeof(*lease));
@


1.300
log
@Preserve intended chronological order of leases in
dhclient.leases.<if> files by writing out in reverse the
reverse-chronological-order TAILQ client->leases.

Found while trying to restore static lease functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.299 2014/04/21 15:26:50 krw Exp $	*/
d116 1
a787 1
	time_t cur_time;
d792 5
a796 51
	/* Figure out the lease time. */
	if (options[DHO_DHCP_LEASE_TIME].data)
		client->new->expiry =
		    getULong(options[DHO_DHCP_LEASE_TIME].data);
	else
		client->new->expiry = DEFAULT_LEASE_TIME;

	/*
	 * A number that looks negative here is really just very large,
	 * because the lease expiry offset is unsigned.
	 */
	if (client->new->expiry < 0)
		client->new->expiry = TIME_MAX;
	/* XXX should be fixed by resetting the client state */
	if (client->new->expiry < 60)
		client->new->expiry = 60;

	/*
	 * Take the server-provided renewal time if there is one;
	 * otherwise figure it out according to the spec.
	 */
	if (options[DHO_DHCP_RENEWAL_TIME].len)
		client->new->renewal =
		    getULong(options[DHO_DHCP_RENEWAL_TIME].data);
	else
		client->new->renewal = client->new->expiry / 2;

	/* Same deal with the rebind time. */
	if (options[DHO_DHCP_REBINDING_TIME].len)
		client->new->rebind =
		    getULong(options[DHO_DHCP_REBINDING_TIME].data);
	else
		client->new->rebind = client->new->renewal +
		    client->new->renewal / 2 + client->new->renewal / 4;

	time(&cur_time);

	client->new->expiry += cur_time;
	/* Lease lengths can never be negative. */
	if (client->new->expiry < cur_time)
		client->new->expiry = TIME_MAX;
	client->new->renewal += cur_time;
	if (client->new->renewal < cur_time)
		client->new->renewal = TIME_MAX;
	client->new->rebind += cur_time;
	if (client->new->rebind < cur_time)
		client->new->rebind = TIME_MAX;

	lease->expiry = client->new->expiry;
	lease->renewal = client->new->renewal;
	lease->rebind = client->new->rebind;
d2501 50
@


1.299
log
@Ooops. Delete discarded offered leases from correct TAILQ. More than
one offer would cause infinite loop.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.298 2014/04/20 21:25:07 krw Exp $	*/
d1662 9
a1670 1
	TAILQ_FOREACH(lp, &client->leases, next) {
@


1.298
log
@Make -L even more useful to monitoring processes. Truncate and
refill the file rather than creating a new one, which preserves
an fd being monitored. And truncate file on losing link.

Things like sysutils/ertn should now be able to see new leases, lease
renewals and cable unplugs.

tweaks by and ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.297 2014/04/17 13:46:48 krw Exp $	*/
d684 1
a684 1
		TAILQ_REMOVE(&client->leases, lp, next);
a689 4
	/*
	 * If we just tossed all the leases we were offered, go back
	 *  to square one.
	 */
@


1.297
log
@Oops. INADDR_ANY != INADDR_BROADCAST. Fixes DHCPDISCOVERY and
DHCPDECLINE.

noted by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.296 2014/04/17 09:59:30 krw Exp $	*/
d351 5
d1963 2
a1964 1
		rslt = unlink(path_option_db);
d1966 2
a1967 2
			warning("Could not unlink '%s': %s",
			    path_option_db, strerror(errno));
@


1.296
log
@Eliminate a couple of always-NULL parameters. Eliminate some
pointless repetition of well-known info in log messages. Pass
around smaller bits of info. Make 'inaddr_any' a const struct
initialized with { INADDR_ANY }.

Tweaks and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.295 2014/04/16 18:46:41 krw Exp $	*/
d87 1
d1223 1
a1223 1
	send_packet(inaddr_any, inaddr_any);
d1425 1
a1425 1
	send_packet(inaddr_any, inaddr_any);
@


1.295
log
@Make dhclient -q even quieter. Make it immediately effective rather
than possibly emitting a couple of random memory allocation error
messages first.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.294 2014/04/16 13:57:58 krw Exp $	*/
d86 1
a86 2
struct in_addr inaddr_any;
struct sockaddr_in sockaddr_broadcast;
a466 7
	memset(&sockaddr_broadcast, 0, sizeof(sockaddr_broadcast));
	sockaddr_broadcast.sin_family = AF_INET;
	sockaddr_broadcast.sin_port = htons(REMOTE_PORT);
	sockaddr_broadcast.sin_addr.s_addr = INADDR_BROADCAST;
	sockaddr_broadcast.sin_len = sizeof(sockaddr_broadcast);
	inaddr_any.s_addr = INADDR_ANY;

d1219 1
a1219 3
	note("DHCPDISCOVER on %s to %s port %hu interval %lld",
	    ifi->name, inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port),
d1222 1
a1222 1
	send_packet(inaddr_any, &sockaddr_broadcast, NULL);
a1394 3
	destination.sin_port = htons(REMOTE_PORT);
	destination.sin_family = AF_INET;
	destination.sin_len = sizeof(destination);
d1414 1
a1414 1
	send_packet(from, &destination, NULL);
d1422 1
a1422 3
	note("DHCPDECLINE on %s to %s port %hu", ifi->name,
	    inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port));
d1424 1
a1424 1
	send_packet(inaddr_any, &sockaddr_broadcast, NULL);
@


1.294
log
@OpenSSL is not the only place with bloated code! Remove unused
function 'option_as_string()'.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.293 2014/02/09 20:45:56 krw Exp $	*/
d392 1
a392 1
	int	 ch, fd, quiet = 0, i = 0, socket_fd[2];
d433 1
a433 1
			quiet = 1;
a464 3

	if (quiet)
		log_perror = 0;
@


1.293
log
@Don't use imsg_flush(), roll a local flush_unpriv_ibuf() that loops
on EAGAIN, sets quit to INTERNALSIG on errors (unless quit is already
set to something else), and prints a consistant error message when
errors other than EPIPE and end of file are encountered.

Fixes failure to write resolv.conf when -L is used, and makes
add_address() and add_route() also wait until imsg is in pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.292 2014/02/08 18:12:17 krw Exp $	*/
d99 1
a99 1
char		*option_as_string(unsigned int code, unsigned char *data, int len);
a1906 39
}

char *
option_as_string(unsigned int code, unsigned char *data, int len)
{
	static char optbuf[32768]; /* XXX */
	char *op = optbuf;
	int opleft = sizeof(optbuf);
	unsigned char *dp = data;

	if (code > 255)
		error("option_as_string: bad code %u", code);

	for (; dp < data + len; dp++) {
		if (!isascii(*dp) || !isprint(*dp)) {
			if (dp + 1 != data + len || *dp != 0) {
				size_t oplen;
				snprintf(op, opleft, "\\%03o", *dp);
				oplen = strlen(op);
				op += oplen;
				opleft -= oplen;
			}
		} else if (*dp == '"' || *dp == '\'' || *dp == '$' ||
		    *dp == '`' || *dp == '\\') {
			*op++ = '\\';
			*op++ = *dp;
			opleft -= 2;
		} else {
			*op++ = *dp;
			opleft--;
		}
	}
	if (opleft < 1)
		goto toobig;
	*op = 0;
	return optbuf;
toobig:
	warning("dhcp option too large");
	return "<error>";
@


1.292
log
@Create dhclient lease files and dhcpd lease files with permissions 0640,
rather than 0000 and 0664 respectively.

ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.291 2014/02/07 18:42:17 krw Exp $	*/
d2422 1
a2422 4
	/* Do flush to maximize chances of keeping file current. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1)
		warning("write_file: imsg_flush: %s", strerror(errno));
@


1.291
log
@Create -L leases files with the same 0000 permissions as regular
leases.IF files.

Inconsistency pointed out by Jiri B.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.290 2014/02/07 18:12:17 krw Exp $	*/
d566 1
a566 1
	    O_RDONLY|O_EXLOCK|O_CREAT|O_NOFOLLOW, 0)) == -1)
d1736 1
a1736 1
	    0, 0, 0, db, strlen(db));
@


1.290
log
@Log failures to fchmod() or fchown() the file written in
priv_write_file().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.289 2014/02/07 13:38:55 krw Exp $	*/
d1736 1
a1736 1
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 0, 0, db, strlen(db));
@


1.289
log
@Nuke unused #define CLIENT_PATH. A remnant of dhclient-script.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.288 2014/01/25 05:21:23 krw Exp $	*/
d2452 6
a2457 2
	fchmod(fd, imsg->mode);
	fchown(fd, imsg->uid, imsg->gid);
@


1.288
log
@Correct parsing of dhclient.conf statements 'fixed-address' and
'next-server'. Modify new lease being cloned with their values
rather than overwriting original lease being cloned.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.287 2014/01/21 05:17:45 krw Exp $	*/
a66 1
#define	CLIENT_PATH 		"PATH=/usr/bin:/usr/sbin:/bin:/sbin"
@


1.287
log
@Allow dhclient.conf to specify 'fixed-address', 'next-server',
'filename' and 'server-name'. dhclient.conf can now override anything
in an offer or saved lease when creating the effective lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.286 2014/01/21 03:07:50 krw Exp $	*/
d2182 3
a2184 3
		if (lease->filename)
			free(lease->filename);
		lease->filename = strdup(config->filename);
d2187 3
a2189 3
		if (lease->server_name)
			free(lease->server_name);
		lease->server_name = strdup(config->server_name);
d2192 1
a2192 1
		lease->address.s_addr = config->address.s_addr;
d2194 1
a2194 1
		lease->next_server.s_addr = config->next_server.s_addr;
@


1.286
log
@Add parsing for options 121 (classless-static-routes) and 249
(classless-ms-static-routes). dhcpd can now specify and serve
these options and dhclient can recognize and use supersede, etc.
statements on them.

Based on a diff from Stefan Rinke. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.285 2014/01/20 09:16:36 deraadt Exp $	*/
d2180 15
@


1.285
log
@more %d type correctness; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.284 2014/01/20 02:54:07 deraadt Exp $	*/
d886 3
@


1.284
log
@%d cleanups, to other formats; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.283 2014/01/17 23:11:42 tobias Exp $	*/
d1228 1
a1228 1
	note("DHCPDISCOVER on %s to %s port %u interval %lld",
d1425 1
a1425 1
	note("DHCPREQUEST on %s to %s port %u", ifi->name,
d1436 1
a1436 1
	note("DHCPDECLINE on %s to %s port %u", ifi->name,
d1916 1
a1916 1
		error("option_as_string: bad code %d", code);
@


1.283
log
@Do not follow symlinks for -l and -L arguments.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.282 2014/01/16 21:41:22 tobias Exp $	*/
d482 1
a482 1
		error("setting routing table to %d: '%s'", ifi->rdomain,
d1228 1
a1228 1
	note("DHCPDISCOVER on %s to %s port %d interval %lld",
d1425 1
a1425 1
	note("DHCPREQUEST on %s to %s port %d", ifi->name,
d1436 1
a1436 1
	note("DHCPDECLINE on %s to %s port %d", ifi->name,
@


1.282
log
@Avoid size_t overflow while reading /etc/resolv.conf.tail.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.281 2013/12/30 03:36:17 krw Exp $	*/
d566 2
a567 1
	if ((fd = open(path_dhclient_db, O_RDONLY|O_EXLOCK|O_CREAT, 0)) == -1)
d1733 1
a1733 1
	    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
@


1.281
log
@Replace yet another hand-rolled list with a TAILQ. reject_list this
time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.280 2013/12/21 18:23:10 krw Exp $	*/
d62 1
d498 1
a498 1
		if (sb.st_size > 0) {
@


1.280
log
@Introduce pretty_print_string() and use for printing both text
valued options and previously snprintf()'d filename and servername
lease attributes.

Should fix "string constant too long" errors when reading back a
lease with filename or servername attributes with escaped characters.

Reported by Rivo Nurges.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.279 2013/12/15 03:15:47 krw Exp $	*/
d459 1
@


1.279
log
@Update timestamps in 'effective' lease before printing out the
lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.278 2013/12/14 05:07:09 krw Exp $	*/
d1764 12
a1775 1
		rslt = snprintf(p, sz, "  filename \"%s\";\n", lease->filename);
d1782 12
a1793 2
		rslt = snprintf(p, sz, "  server-name \"%s\";\n",
		    lease->server_name);
@


1.278
log
@When cloning leases remember to clone address, next_server and
resolv_conf fields. Makes 'effective' lease written by '-L' a bit
more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.277 2013/12/10 17:01:27 krw Exp $	*/
d846 4
@


1.277
log
@Rework [priv_]write_file() and associated struct imsg_write_file
to use imsg_composev() rather than allocating memory, copying data
into it, and then passing it to imsg_compose() to copy data again
into imsg buffer.

ok pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.276 2013/12/09 18:05:36 krw Exp $	*/
d2254 2
d2265 5
@


1.276
log
@Refactor processing of classless static routes option (121). Add
more data validation, reduce magic number count, shorter parameter
name, reduce mem*() usage, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.275 2013/12/08 22:49:02 krw Exp $	*/
d60 1
d2342 2
a2343 1
	struct imsg_write_file *imsg;
d2346 4
a2349 8
	imsg = calloc(1, sizeof(*imsg) + sz);
	if (imsg == NULL)
		error("no memory for imsg_write_file");
	imsg->rdomain = ifi->rdomain;

	rslt = strlcpy(imsg->path, path, MAXPATHLEN);
	if (rslt >= MAXPATHLEN) {
		free(imsg);
a2352 6
	memcpy(imsg->contents, contents, sz);
	imsg->len = sz;
	imsg->flags = flags;
	imsg->mode = mode;
	imsg->uid = uid;
	imsg->gid = gid;
d2354 13
a2366 2
	rslt = imsg_compose(unpriv_ibuf, IMSG_WRITE_FILE, 0, 0, -1, imsg,
	    sizeof(*imsg) + sz);
d2368 1
a2368 1
		warning("write_file: imsg_compose: %s", strerror(errno));
d2392 1
a2392 1
	n = write(fd, imsg->contents, imsg->len);
@


1.275
log
@Reduce in_addr memcpy() dances by simply using assignments where the source
variable has been copied to [cm]alloc'ed memory and thus properly aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.274 2013/12/06 23:40:48 krw Exp $	*/
d2460 1
a2460 2
void add_classless_static_routes(int rdomain,
    struct option_data *classless_static_routes)
d2466 2
a2467 2
	while (i < classless_static_routes->len) {
		bits = classless_static_routes->data[i];
d2469 4
a2472 1
		if (bytes > 4)
a2473 2
			
		i++;
a2474 1
		memset(&netmask, 0, sizeof(netmask));
d2477 2
d2480 1
a2480 2
		memset(&dest, 0, sizeof(dest));
		memcpy(&dest, &classless_static_routes->data[i], bytes);
d2484 3
a2486 2
		memcpy(&gateway, &classless_static_routes->data[i],
		    sizeof(gateway));
@


1.274
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.273 2013/12/05 21:32:59 krw Exp $	*/
d791 1
a791 1
	struct option_data *options;
d864 5
a868 4
	memset(&mask, 0, sizeof(mask));
	if (options[DHO_SUBNET_MASK].len == sizeof(mask)) {
		memcpy(&mask, options[DHO_SUBNET_MASK].data, sizeof(mask));
	}
d879 2
a880 2
		if (options[DHO_ROUTERS].len >= sizeof(gateway)) {
			memset(&gateway, 0, sizeof(gateway));
d882 1
a882 2
			memcpy(&gateway, options[DHO_ROUTERS].data,
			    sizeof(gateway));
d941 3
d947 7
a953 7
	if (client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 
	    sizeof(client->destination)) {
		memcpy(&client->destination,
		    client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
		    sizeof(client->destination));
	} else
		client->destination.s_addr = INADDR_BROADCAST;
d1088 1
a1088 1
	memcpy(&lease->address, &client->packet.yiaddr, sizeof(lease->address));
d1091 1
a1091 2
	memcpy(&lease->next_server, &client->packet.siaddr,
	    sizeof(lease->next_server));
d1489 5
a1493 4
	memset(&packet->ciaddr, 0, sizeof(packet->ciaddr));
	memset(&packet->yiaddr, 0, sizeof(packet->yiaddr));
	memset(&packet->siaddr, 0, sizeof(packet->siaddr));
	memset(&packet->giaddr, 0, sizeof(packet->giaddr));
d1566 8
a1573 6
	    client->state == S_REBINDING) {
		memcpy(&packet->ciaddr, &lease->address.s_addr,
		    sizeof(in_addr_t));
	} else {
		memset(&packet->ciaddr, 0, sizeof(packet->ciaddr));
	}
a1574 3
	memset(&packet->yiaddr, 0, sizeof(packet->yiaddr));
	memset(&packet->siaddr, 0, sizeof(packet->siaddr));
	memset(&packet->giaddr, 0, sizeof(packet->giaddr));
d1629 5
a1633 4
	memset(&packet->ciaddr, 0, sizeof(packet->ciaddr));
	memset(&packet->yiaddr, 0, sizeof(packet->yiaddr));
	memset(&packet->siaddr, 0, sizeof(packet->siaddr));
	memset(&packet->giaddr, 0, sizeof(packet->giaddr));
d2440 1
a2440 1
	u_int8_t		 *addr;
d2443 1
a2443 1
	memset(&netmask, 0, sizeof(netmask));	/* Not used for CLASSFULL! */
d2445 5
a2449 4
	for (i = 0; (i + 7) < static_routes->len; i += 8) {
		addr = &static_routes->data[i];
		memset(&dest, 0, sizeof(dest));
		memset(&gateway, 0, sizeof(gateway));
d2451 2
a2452 4
		memcpy(&dest, addr, sizeof(dest));
		if (dest.s_addr == INADDR_ANY)
			continue; /* RFC 2132 says 0.0.0.0 is not allowed. */
		memcpy(&gateway, addr+sizeof(dest), sizeof(gateway));
a2483 1
		memset(&gateway, 0, sizeof(gateway));
@


1.273
log
@Use destination size as size of memcpy(). Use <in_addr> rather than
<in_addr>.s_addr to shorten code.

ok deraadt@@ matthew@@ as part of larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.272 2013/12/04 22:14:33 matthew Exp $	*/
d207 1
a207 1
	struct hardware hw;
d1480 2
a1481 2
	packet->htype = ifi->hw_address.htype;
	packet->hlen = ifi->hw_address.hlen;
d1491 2
a1492 1
	memcpy(&packet->chaddr, ifi->hw_address.haddr, ifi->hw_address.hlen);
d1550 2
a1551 2
	packet->htype = ifi->hw_address.htype;
	packet->hlen = ifi->hw_address.hlen;
d1573 2
a1574 1
	memcpy(&packet->chaddr, ifi->hw_address.haddr, ifi->hw_address.hlen);
d1619 2
a1620 2
	packet->htype = ifi->hw_address.htype;
	packet->hlen = ifi->hw_address.hlen;
d1631 2
a1632 1
	memcpy(&packet->chaddr, ifi->hw_address.haddr, ifi->hw_address.hlen);
@


1.272
log
@When we receive a /32 IP address assignment, mimick ISC DHCP by adding
a direct route for the default gateway IP with equivalent to

    route add -net $gw -netmask 255.255.255.255 -cloning -iface $myip

so that the subsequent

    route add default $gw

can succeed.

Magic route(8) incantation thanks to claudio.
Tested successfully on Compute Engine.
Committing now so additional testing/discussion can happen in-tree.

Discussed with deraadt, krw, claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.271 2013/12/04 19:44:41 krw Exp $	*/
d865 2
a866 3
	if (options[DHO_SUBNET_MASK].len == sizeof(mask.s_addr)) {
		memcpy(&mask.s_addr, options[DHO_SUBNET_MASK].data,
		    sizeof(mask.s_addr));
d878 1
a878 1
		if (options[DHO_ROUTERS].len >= sizeof(gateway.s_addr)) {
d881 2
a882 2
			memcpy(&gateway.s_addr, options[DHO_ROUTERS].data,
			    sizeof(gateway.s_addr));
d944 3
a946 2
	if (client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy(&client->destination.s_addr,
d948 1
a948 1
		    sizeof(client->destination.s_addr));
d1085 1
a1085 2
	memcpy(&lease->address.s_addr, &client->packet.yiaddr,
	    sizeof(in_addr_t));
d1088 2
a1089 2
	memcpy(&lease->next_server.s_addr, &client->packet.siaddr,
	    sizeof(in_addr_t));
d2444 1
a2444 1
		memcpy(&dest.s_addr, addr, 4);
d2447 1
a2447 1
		memcpy(&gateway.s_addr, addr+4, 4);
d2480 3
a2482 2
		memcpy(&gateway, &classless_static_routes->data[i], 4);
		i += 4;
@


1.271
log
@Oops. Missed a chunk. Give up on classless static routes if
size of mask is > 4 bytes. Don't keep looping on the data
hoping it gets better.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.270 2013/12/04 19:39:50 krw Exp $	*/
d884 15
@


1.270
log
@More memcpy() stylistic repairs and size checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.269 2013/12/04 16:54:28 krw Exp $	*/
d2452 1
a2452 1
			continue;
@


1.269
log
@Be more careful to ensure memcpy'd data will fit.

Potential problems pointed out by matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.268 2013/11/20 17:22:46 deraadt Exp $	*/
d933 1
a933 1
		    client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len);
d2451 3
@


1.268
log
@cleanups for signed char vs ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.267 2013/11/11 21:00:01 krw Exp $	*/
d865 4
a868 2
	memcpy(&mask.s_addr, options[DHO_SUBNET_MASK].data,
	    options[DHO_SUBNET_MASK].len);
d879 1
a879 1
		if (options[DHO_ROUTERS].len) {
d883 1
a883 1
			    options[DHO_ROUTERS].len);
@


1.267
log
@Shuffle function prototypes and extern declarations around to
put local functions prototypes and variables in their .c files, and
cross-file functions into .h files. Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.266 2013/11/11 18:43:45 krw Exp $	*/
d1833 1
a1833 1
	int pch = '.', ch = *dn++;
d1837 1
a1837 1
		int nch = *dn++;
@


1.266
log
@Nuke 'cur_time' variable used only to assign time(NULL) to a field.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.265 2013/11/11 17:16:11 krw Exp $	*/
a95 1
int		 resolv_conf_priority(int);
d115 23
@


1.265
log
@Argh. Set 'to' address to INADDR_BROADCAST, not 'from' address,
when trying to send broadcast request to server.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.264 2013/11/11 15:39:20 krw Exp $	*/
a653 1
	time_t cur_time;
a678 2
	time(&cur_time);

d717 2
a718 1
	client->first_sending = cur_time;
@


1.264
log
@RFC 2131 and friends state that when renewing a lease the client
will begin by using unicast communications with the server, and
fall back to using broadcast packets if unicast fails.

We were not failing back, but instead doggedly sticking with unicast
attempts until the lease expired.

Instead, try unicast requests for the reboot timeout interval and
then switch to using broadcast requests.

Problem reported by Marc Peters and Dennis den Brok via misc@@.

ok dlg@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.263 2013/10/22 18:15:58 krw Exp $	*/
d1348 3
a1350 2
	 * If the lease rebind time has elapsed, or if we're not yet bound,
	 * broadcast the DHCPREQUEST rather than unicasting.
d1355 2
a1356 1
	    cur_time > client->active->rebind)
d1364 1
a1364 2
	if ((client->state != S_REQUESTING) &&
	    (interval <= config->reboot_timeout))
@


1.263
log
@Save 'next-server' (a.k.a. siaddr) info in leases file. Saving the
file name without the server address seems silly.

Tested & ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.262 2013/09/09 20:30:05 krw Exp $	*/
d1362 2
a1363 1
	if (client->state != S_REQUESTING)
@


1.262
log
@Calculate the lease time fields (expiry, renew, rebind) after
applying the option directives (ignore, default, supersede) from
dhclient.conf.

This allows the options dhcp-lease-time, dhcp-rebinding-time,
and dhcp-renewal-time to be controlled via dhclient.conf.

Also set BOOTP lease times by faking up these options rather than
crudely jamming in fixed times, allowing them to become configurable
via dhclient.conf.

Imperviousness of the time options pointed out by todd@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.261 2013/08/14 13:52:53 florian Exp $	*/
d1051 4
d1702 7
@


1.261
log
@Only skip address deleting/adding and route deleting/adding on
identical lease when we are in state S_RENEWING. Otherwise we can end
up without an IP address on the interface because dhclient thinks it's
still there and doesn't add it.
Found the hard way during suspend/resume.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.260 2013/07/15 14:03:01 krw Exp $	*/
d682 1
a682 1
	/* If it was a BOOTREPLY, we can just take the address right now. */
d684 2
d688 23
a710 5
		/* Make up some lease expiry times
		   XXX these should be configurable. */
		client->new->expiry = cur_time + 12000;
		client->new->renewal += cur_time + 8000;
		client->new->rebind += cur_time + 10000;
d713 1
a714 2
		/* Bind to the address we received. */
		bind_lease();
a739 1
	time_t cur_time;
d764 14
d779 1
a779 1
	if (client->new->options[DHO_DHCP_LEASE_TIME].data)
d781 1
a781 1
		    getULong(client->new->options[DHO_DHCP_LEASE_TIME].data);
d784 1
d799 1
a799 1
	if (client->new->options[DHO_DHCP_RENEWAL_TIME].len)
d801 1
a801 1
		    getULong(client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d806 1
a806 1
	if (client->new->options[DHO_DHCP_REBINDING_TIME].len)
d808 1
a808 1
		    getULong(client->new->options[DHO_DHCP_REBINDING_TIME].data);
a824 13

	bind_lease();
}

void
bind_lease(void)
{
	struct in_addr gateway, mask;
	struct option_data *options;
	struct client_lease *lease;

	lease = apply_defaults(client->new);
	options = lease->options;
@


1.260
log
@If a DHCPREQUEST returns a lease identical to the one currently bound to
the interface, skip the address deleting/adding and route deleting/adding
and simply update the timestamps.

Suggested by sthen@@. Tweaks from millert@@. ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.259 2013/07/06 03:13:34 krw Exp $	*/
d807 1
a807 1
	 * A duplicate lease once we are responsible means we don't
d810 1
a810 1
	if ((client->flags & IS_RESPONSIBLE) &&
@


1.259
log
@Tone down verbosity by putting the "Unexpected <blah>" messages under
#ifdef DEBUG. They were mostly for, well, debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.258 2013/07/05 22:13:10 krw Exp $	*/
d115 2
d803 17
a823 3
	lease = apply_defaults(client->new);
	options = lease->options;

d859 1
d2418 41
@


1.258
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.257 2013/06/18 17:02:41 krw Exp $	*/
d725 3
a727 1
		note("Unexpected %s. State #%d", info, client->state);
d892 3
a894 1
		note("Unexpected %s. State #%d.", info, client->state);
d1058 3
a1060 1
		note("Unexpected %s. State #%d", info, client->state);
d1065 3
a1067 1
		note("Unexpected %s. No active lease.", info);
@


1.257
log
@Don't use inet_ntoa() twice in one parameter list. You'll just print
one of the strings twice. Spotted by mpi@@, who also tweaked the
diff by pointing out INET_ADDRSTRLEN.

Should fix mysterious messages like "1.2.3.4, not 1.2.3.4, deleted
from ...".
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.256 2013/06/18 00:30:39 krw Exp $	*/
d1859 1
a1859 1
		} 
d1913 1
a1913 1
 
d2066 1
a2066 1
			newlease->options[i].data = calloc(1, 
d2085 1
a2085 1
			memcpy(newlease->options[i].data + 
d2101 1
a2101 1
			memcpy(newlease->options[i].data + 
d2111 1
a2111 1
				newlease->options[i].data = calloc(1, 
d2333 1
a2333 1
	add_route(rdomain, dest, netmask, gateway, addrs, flags); 
d2375 1
a2375 1
			netmask.s_addr = htonl(0xffffffff << (32 - bits)); 
@


1.256
log
@Split RTM_NEWADDR and RTM_DELADDR handling into separate cases
rather than 1 case with a check to see which messages it was. More
code duplication, easier to read. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.255 2013/06/17 19:51:41 krw Exp $	*/
d179 1
d240 5
a244 5
		if (adding.s_addr != INADDR_ANY)
			rslt = asprintf(&errmsg, "%s, not %s, added "
			    "to %s", inet_ntoa(a), inet_ntoa(adding),
			    ifi->name);
		else
d287 5
a291 5
		if (deleting.s_addr != INADDR_ANY)
			rslt = asprintf(&errmsg, "%s, not %s, deleted "
			    "from %s", inet_ntoa(a),
			    inet_ntoa(deleting), ifi->name);
		else
@


1.255
log
@Check calloc() return value. Plug leak of resulting memory.

Latter from dhill.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.254 2013/06/09 22:39:51 krw Exp $	*/
d205 42
d266 1
a266 1
		 * If we are in the process of binding a new lease, ignore
d269 24
a292 47
		if (rtm->rtm_type == RTM_NEWADDR) {
			if (a.s_addr == adding.s_addr) {
				adding.s_addr = INADDR_ANY;
				note("bound to %s -- renewal in %lld seconds.",
				    inet_ntoa(client->active->address),
				    (long long)(client->active->renewal -
				    time(NULL)));
				client->flags |= IS_RESPONSIBLE;
				go_daemon();
				break;
			}
			if ((client->flags & IS_RESPONSIBLE) == 0)
				/* We're not responsible yet! */
				break;
			if (adding.s_addr != INADDR_ANY)
				rslt = asprintf(&errmsg, "%s, not %s, added "
				    "to %s", inet_ntoa(a), inet_ntoa(adding),
				    ifi->name);
			else
				rslt = asprintf(&errmsg, "%s added to %s",
				    inet_ntoa(a), ifi->name);
		} else {
			if (a.s_addr == deleting.s_addr) {
				deleting.s_addr = INADDR_ANY;
				break;
			}
			if ((client->flags & IS_RESPONSIBLE) == 0)
				/* We're not responsible yet! */
				break;
			if (adding.s_addr == INADDR_ANY && client->active &&
			    a.s_addr == client->active->address.s_addr) {
				/* Tell the priv process active_addr is gone. */
				warning("Active address (%s) deleted; exiting",
				    inet_ntoa(client->active->address));
				memset(&b, 0, sizeof(b));
				add_address(ifi->name, 0, b, b);
				quit = INTERNALSIG;
				break;
			}
			if (deleting.s_addr != INADDR_ANY)
				rslt = asprintf(&errmsg, "%s, not %s, deleted "
				    "from %s", inet_ntoa(a),
				    inet_ntoa(deleting), ifi->name);
			else
				rslt = asprintf(&errmsg, "%s deleted from %s",
				    inet_ntoa(a), ifi->name);
		} 
@


1.254
log
@Make route adding interface more flexible by passing flags to be
used rather than deducing them. Use priv_add_route() to add
the 127.0.0.1 address when adding an address.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.253 2013/06/09 17:31:54 krw Exp $	*/
d2225 2
d2231 1
@


1.253
log
@Fix/clarify some comments. do memset()'s only when variable is going
to be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.252 2013/06/09 16:21:50 krw Exp $	*/
d2293 1
a2293 1
	int addrs;
d2298 1
d2305 1
a2305 1
	if (bcmp(&gateway, &addr, sizeof(addr)) != 0)
d2307 2
d2310 1
a2310 1
	add_route(rdomain, dest, netmask, gateway, addrs); 
d2320 1
a2320 1
	memset(&netmask, 0, sizeof(netmask));	/* Always 0 for class addrs. */
d2334 1
a2334 1
		    RTA_DST | RTA_GATEWAY);
d2367 2
a2368 1
		    RTA_DST | RTA_GATEWAY | RTA_NETMASK);
@


1.252
log
@Re-apply static route and classless static route support -- this time
passing the correct destination for the default route, '0.0.0.0', rather
than the new lease address.

Populating egress group works this time.

Problem found the hard way by Chris Smith.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.251 2013/06/09 15:06:34 krw Exp $	*/
a2287 2
 *
 * depending on the contents of the gateway parameter.
d2300 3
a2302 2
	 * Set gateway address if and only if non-zero addr supplied. A
	 * gateway address of 0 implies '-iface'.
@


1.251
log
@Re-apply route adding code refactoring -- it wasn't the problem that
broke populating the egress group.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.250 2013/06/09 00:30:06 krw Exp $	*/
d112 2
d795 15
a809 6
	if (options[DHO_ROUTERS].len) {
		memset(&gateway, 0, sizeof(gateway));
		/* XXX Only use FIRST router address for now. */
		memcpy(&gateway.s_addr, options[DHO_ROUTERS].data,
		    options[DHO_ROUTERS].len);
		add_default_route(ifi->rdomain, client->new->address, gateway);
d2294 2
a2295 4
	struct imsg_add_route	 imsg;
	int			 rslt;

	memset(&imsg, 0, sizeof(imsg));
d2297 3
a2299 3
	imsg.rdomain = rdomain;
	imsg.dest = addr;
	imsg.addrs = RTA_DST | RTA_NETMASK;
d2305 28
a2332 3
	if (bcmp(&gateway, &addr, sizeof(addr)) != 0) {
		imsg.gateway = gateway;
		imsg.addrs |= RTA_GATEWAY;
d2334 17
d2352 4
a2355 2
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ROUTE, 0, 0, -1, &imsg,
	   sizeof(imsg));
d2357 10
a2366 2
	if (rslt == -1)
		warning("add_route: imsg_compose: %s", strerror(errno));
@


1.250
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.249 2013/06/04 21:04:52 krw Exp $	*/
d111 2
d2267 39
@


1.249
log
@Add support for static routes option (33) and classless static
routes option (121).

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.248 2013/06/01 16:26:07 krw Exp $	*/
a110 4
void add_default_route(int, struct in_addr, struct in_addr);
void add_static_routes(int, struct option_data *);
void add_classless_static_routes(int, struct option_data *);

d791 6
a796 15
	if (options[DHO_CLASSLESS_STATIC_ROUTES].len) {
		add_classless_static_routes(ifi->rdomain,
		    &options[DHO_CLASSLESS_STATIC_ROUTES]);
	} else {
		if (options[DHO_ROUTERS].len) {
			memset(&gateway, 0, sizeof(gateway));
			/* XXX Only use FIRST router address for now. */
			memcpy(&gateway.s_addr, options[DHO_ROUTERS].data,
			    options[DHO_ROUTERS].len);
			add_default_route(ifi->rdomain, client->new->address,
			    gateway);
		}
		if (options[DHO_STATIC_ROUTES].len)
			add_static_routes(ifi->rdomain,
			    &options[DHO_STATIC_ROUTES]);
a2264 88
}

/*
 * add_default_route is the equivalent of
 *
 *	route -q $rdomain add default -iface $router
 *
 *	or
 *
 * 	route -q $rdomain add default $router
 *
 * depending on the contents of the gateway parameter.
 */
void
add_default_route(int rdomain, struct in_addr addr, struct in_addr gateway)
{
	struct in_addr netmask;
	int addrs;

	memset(&netmask, 0, sizeof(netmask));
	addrs = RTA_DST | RTA_NETMASK;

	/*
	 * Set gateway address if and only if non-zero addr supplied. A
	 * gateway address of 0 implies '-iface'.
	 */
	if (bcmp(&gateway, &addr, sizeof(addr)) != 0)
		addrs |= RTA_GATEWAY;

	add_route(rdomain, addr, netmask, gateway, addrs); 
}

void
add_static_routes(int rdomain, struct option_data *static_routes)
{
	struct in_addr		 dest, netmask, gateway;
	u_int8_t		 *addr;
	int			 i;

	memset(&netmask, 0, sizeof(netmask));	/* Always 0 for class addrs. */

	for (i = 0; (i + 7) < static_routes->len; i += 8) {
		addr = &static_routes->data[i];
		memset(&dest, 0, sizeof(dest));
		memset(&gateway, 0, sizeof(gateway));

		memcpy(&dest.s_addr, addr, 4);
		if (dest.s_addr == INADDR_ANY)
			continue; /* RFC 2132 says 0.0.0.0 is not allowed. */
		memcpy(&gateway.s_addr, addr+4, 4);

		/* XXX Order implies priority but we're ignoring that. */
		add_route(rdomain, dest, netmask, gateway,
		    RTA_DST | RTA_GATEWAY);
	}
}

void add_classless_static_routes(int rdomain,
    struct option_data *classless_static_routes)
{
	struct in_addr	 dest, netmask, gateway;
	int		 bits, bytes, i;

	i = 0;
	while (i < classless_static_routes->len) {
		bits = classless_static_routes->data[i];
		bytes = (bits + 7) / 8;
		i++;

		memset(&netmask, 0, sizeof(netmask));
		if (bits)
			netmask.s_addr = htonl(0xffffffff << (32 - bits)); 

		memset(&dest, 0, sizeof(dest));
		memcpy(&dest, &classless_static_routes->data[i], bytes);
		dest.s_addr = dest.s_addr & netmask.s_addr;
		i += bytes;

		memset(&gateway, 0, sizeof(gateway));
		memcpy(&gateway, &classless_static_routes->data[i], 4);
		i += 4;

		if (gateway.s_addr == INADDR_ANY)
			continue; /* OBSD TCP/IP doesn't support this. */

		add_route(rdomain, dest, netmask, gateway,
		    RTA_DST | RTA_GATEWAY | RTA_NETMASK);
	}
@


1.248
log
@Refactor the default route adding code to use a general route adding
function that will be reused for future work.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.247 2013/05/05 16:45:01 krw Exp $	*/
d112 2
d795 15
a809 6
	if (options[DHO_ROUTERS].len) {
		memset(&gateway, 0, sizeof(gateway));
		/* XXX Only use FIRST router address for now. */
		memcpy(&gateway.s_addr, options[DHO_ROUTERS].data,
		    options[DHO_ROUTERS].len);
		add_default_route(ifi->rdomain, client->new->address, gateway);
d2294 2
a2295 4
	struct imsg_add_route	 imsg;
	int			 rslt;

	memset(&imsg, 0, sizeof(imsg));
d2297 2
a2298 3
	imsg.rdomain = rdomain;
	imsg.dest = addr;
	imsg.addrs = RTA_DST | RTA_NETMASK;
d2304 28
a2331 3
	if (bcmp(&gateway, &addr, sizeof(addr)) != 0) {
		imsg.gateway = gateway;
		imsg.addrs |= RTA_GATEWAY;
d2333 17
d2351 4
a2354 2
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ROUTE, 0, 0, -1, &imsg,
	   sizeof(imsg));
d2356 10
a2365 2
	if (rslt == -1)
		warning("add_route: imsg_compose: %s", strerror(errno));
@


1.247
log
@Add a flag to struct client_state (IS_RESPONSIBLE) to record when
the first expected RTM_NEWADDR arrives, which signals that a lease
has been bound to the interface. Ignore RTM_NEWADDR and RTM_DELADDR
messages until the flag has been set.

Makes it more likely that the last dhclient started will be the
last dhclient standing. Fixes the problem reported by David Higgs,
where restarting an install in a vm consistantly caused the new
dhclient to be the one that dies.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.246 2013/05/02 16:35:27 krw Exp $	*/
d111 2
d2267 39
@


1.246
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.245 2013/05/02 14:48:35 krw Exp $	*/
d230 1
d234 3
d249 3
@


1.245
log
@Enough of the hand-rolling of queues. Turn client->leases and
client->offered_leases into TAILQs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.244 2013/04/27 17:54:24 krw Exp $	*/
d66 1
a66 1
#define DEFAULT_LEASE_TIME	43200	/* 12 hours... */
d490 1
a490 1
	/* Register the interface... */
d570 1
a570 27
 * Individual States:
 *
 * Each routine is called from the dhclient_state_machine() in one of
 * these conditions:
 * -> entering INIT state
 * -> recvpacket_flag == 0: timeout in this state
 * -> otherwise: received a packet in this state
 *
 * Return conditions as handled by dhclient_state_machine():
 * Returns 1, sendpacket_flag = 1: send packet, reset timer.
 * Returns 1, sendpacket_flag = 0: just reset the timer (wait for a milestone).
 * Returns 0: finish the nap which was interrupted for no good reason.
 *
 * Several per-interface variables are used to keep track of the process:
 *   active_lease: the lease that is being used on the interface
 *                 (null pointer if not configured yet).
 *   offered_leases: leases corresponding to DHCPOFFER messages that have
 *                   been sent to us by DHCP servers.
 *   acked_leases: leases corresponding to DHCPACK messages that have been
 *                 sent to us by DHCP servers.
 *   sendpacket: DHCP packet we're trying to send.
 *   destination: IP address to send sendpacket to
 * In addition, there are several relevant per-lease variables.
 *   T1_expiry, T2_expiry, lease_expiry: lease milestones
 * In the active lease, these control the process of renewing the lease;
 * In leases on the acked_leases list, this simply determines when we
 * can no longer legitimately use the lease.
a574 2
	/* Cancel all timeouts, since a link state change gets us here
	   and can happen anytime. */
d597 1
a597 2
 * Called when a lease has completely expired and we've
 * been unable to renew it.
d614 2
a615 2
 * state_selecting is called when one or more DHCPOFFER packets
 * have been received and a configurable period of time has passed.
a622 2
	/* Cancel state_selecting and send_discover timeouts, since either
	   one could have got us here. */
a665 1
	/* Go to the REQUESTING state. */
d717 4
a720 2
	/* A number that looks negative here is really just very large,
	   because the lease expiry offset is unsigned. */
d727 4
a730 2
	/* Take the server-provided renewal time if there is one;
	   otherwise figure it out according to the spec. */
d819 3
a821 4
 * state_bound is called when we've successfully bound to a particular
 * lease, but the renewal time on that lease has expired.   We are
 * expected to unicast a DHCPREQUEST to the server that gave us our
 * original lease.
a825 1
	/* T1 has expired. */
d878 4
a881 2
	/* If this lease was acquired through a BOOTREPLY, record that
	   fact. */
a899 3
	/* If the selecting interval has expired, go immediately to
	   state_selecting().  Otherwise, time out into
	   state_selecting at the select interval. */
d1028 1
a1028 1
	/* Stop sending DHCPREQUEST packets... */
d1104 2
a1105 3
 * state_panic gets called if we haven't received any offers in a preset
 * amount of time.   When this happens, we try to use existing leases
 * that haven't yet expired.
d1116 4
a1119 2
	/* We may not have an active lease, but we may have some
	   predefined leases that we can try. */
d1159 4
a1162 2
		/* Otherwise, put the active lease at the end of the
		   lease list, and try another lease.. */
d1169 4
a1172 3
		/* If we already tried this lease, we've exhausted the
		   set of leases, so we might as well give up for
		   now. */
d1201 13
a1213 10
	/* If we're in the INIT-REBOOT or REQUESTING state and we're
	   past the reboot timeout, go to INIT and see if we can
	   DISCOVER an address... */
	/* XXX In the INIT-REBOOT state, if we don't get an ACK, it
	   means either that we're on a network with no DHCP server,
	   or that our server is down.  In the latter case, assuming
	   that there is a backup DHCP server, DHCPDISCOVER will get
	   us a new address, but we could also have successfully
	   reused our old address.  In the former case, we're hosed
	   anyway.  This is not a win-prone situation. */
d1223 4
a1226 2
	/* If the lease has expired, relinquish the address and go back
	   to the INIT state. */
d1238 1
a1238 1
	/* Do the exponential backoff... */
d1250 4
a1253 2
	/* If the backoff would take us to the expiry time, just set the
	   timeout to the expiry time. */
d1258 4
a1261 2
	/* If the lease T2 time has elapsed, or if we're not yet bound,
	   broadcast the DHCPREQUEST rather than unicasting. */
d1388 4
a1391 2
	/* If we are requesting an address that hasn't yet been assigned
	   to us, use the DHCP Requested Address option. */
d1393 1
a1393 1
		/* Send back the server identifier... */
d1429 4
a1432 2
	/* If we own the address we're requesting, put it in ciaddr;
	   otherwise set ciaddr to zero. */
d1464 1
a1464 1
	/* Send back the server identifier... */
d1686 1
a1686 1
	/* Stop logging to stderr... */
d1701 1
a1701 3
	/*
	 * Catch stuff that might be trying to terminate the program.
	 */
a1921 1

@


1.244
log
@Use same parse_date() and date writing logic as in dhcpd. i.e.
strptime() rather than handrolling parsing. Change date format
in leases to same as dhcpd, fixing 'u' vs 'w' error made in
initial strftime() introduction.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.243 2013/04/25 06:43:20 otto Exp $	*/
d398 2
d649 1
a649 1
	struct client_lease *lp, *next, *picked;
d656 11
a666 13
	/* We have received one or more DHCPOFFER packets.   Currently,
	   the only criterion by which we judge leases is whether or
	   not we get a response when we arp for them. */
	picked = NULL;
	for (lp = client->offered_leases; lp; lp = next) {
		next = lp->next;
		if (!picked) {
			picked = lp;
		} else {
			make_decline(lp);
			send_decline();
			free_client_lease(lp);
		}
a667 1
	client->offered_leases = NULL;
a677 2
	picked->next = NULL;

d885 1
a885 1
	for (lp = client->offered_leases; lp; lp = lp->next) {
d916 5
a920 5
	/* If this is the lease we asked for, put it at the head of the
	   list, and don't mess with the arp request timeout. */
	if (lease->address.s_addr == client->requested_address.s_addr) {
		lease->next = client->offered_leases;
		client->offered_leases = lease;
d922 2
a923 10
		/* Put the lease at the end of the list. */
		lease->next = NULL;
		if (!client->offered_leases)
			client->offered_leases = lease;
		else {
			for (lp = client->offered_leases; lp->next;
			    lp = lp->next)
				;	/* nothing */
			lp->next = lease;
		}
a1142 1
	struct client_lease *lp;
d1150 1
a1150 1
	if (!client->active && client->leases)
d1181 3
a1183 2
		if (!client->leases) {
			client->leases = client->active;
d1191 5
a1195 7
		for (lp = client->leases; lp->next; lp = lp->next)
			;
		lp->next = client->active;
		if (lp->next)
			lp->next->next = NULL;
		client->active = client->leases;
		client->leases = client->leases->next;
d1549 1
a1549 1
	for (lp = client->leases; lp; lp = lp->next) {
@


1.243
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.242 2013/03/30 16:10:01 krw Exp $	*/
d1678 2
a1679 2
#define TIMEFMT "%u %Y/%m/%d %T;\n"
	rsltsz = strftime(p, sz, "  renew " TIMEFMT, gmtime(&lease->renewal));
d1684 2
a1685 1
	rsltsz = strftime(p, sz, "  rebind " TIMEFMT, gmtime(&lease->rebind));
d1690 2
a1691 1
	rsltsz = strftime(p, sz, "  expire " TIMEFMT, gmtime(&lease->expiry));
@


1.242
log
@Since deleting all the addresses on an interface removes all the
relevant entries from the arp cache, don't bother asking for/processing
arp entries in the route dumps. Thus allowing use of NET_RT_FLAGS
with RTF_GATEWAY and AF_INET, to ask for only the routes dhclient
wants to expunge rather than all routes in existance.

Greatly shrinks and simplifies the code. No intentional functional
change. Tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.241 2013/03/22 23:58:51 krw Exp $	*/
d1135 1
a1135 1
	note("DHCPDISCOVER on %s to %s port %d interval %d",
d1137 2
a1138 1
	    ntohs(sockaddr_broadcast.sin_port), client->interval);
@


1.241
log
@Ignore client-identifier option in leases from a server. They're not supposed
to be there! Instead, always record the client-identifier used to obtain
the lease. Ignore recorded leases that have a different client-identifier
than the one currently in force. If a client-identifier is not specified
in the dhclient.conf file, construct one from the network type and
MAC, like most other clients out there do these days.

Thus, if one plugs in a different USB network adapter, renewing the
previous lease (which upsets servers due to the MAC being different)
is skipped and DISCOVER is attempted at once.

Issue noted and fix tested by tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.240 2013/02/27 17:25:59 krw Exp $	*/
d799 1
d801 1
a801 1
	flush_routes_and_arp_cache(ifi->name, ifi->rdomain);
@


1.240
log
@Avoid alignment errors when processing routing messages by reading
the messages into dynamically allocated memory rather than a char
array on the stack.  Revealed by armish bus error when installing
latest snap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.239 2013/02/24 01:10:28 krw Exp $	*/
d1625 1
d1660 6
a1665 1
		if (lease->options[i].len == 0)
d1667 1
d1669 1
a1669 2
		    dhcp_options[i].name,
		    pretty_print_option(i, &lease->options[i], 1));
@


1.239
log
@When no acceptable offers are received within the allowed timeframe call
state_panic() instead of state_init().

state_init() immediately issues a new DISCOVER message and neither
checks dhclient.leases.IF nor daemonizes.

state_panic() looks for a lease in dhclient.leases.IF, and if none
are available, waits for 'retry' seconds before retarting the
DISCOVER process. Most importantly it calls go_daemon() to take the
process into the background, giving back the command prompt.

Reported by otto@@ and deraadt@@. ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.238 2013/02/19 23:40:25 krw Exp $	*/
a174 1
	char msg[2048];
d184 5
a188 1
	char *errmsg;
d191 1
a191 1
		n = read(routefd, &msg, sizeof(msg));
d194 1
a194 1
	rtm = (struct rt_msghdr *)msg;
d197 1
a197 1
		return;
d279 1
a279 1
			return;
d320 2
a327 1
	free(errmsg);
@


1.238
log
@Cancel any outstanding protocol timeout when a link goes away. When
the link comes back we will start from scratch with DISCOVER. Stops
pointless attempts to issue packets over a disconnected interface.

Noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.237 2013/02/18 15:57:08 krw Exp $	*/
d666 4
a669 2
	/* If we just tossed all the leases we were offered, go back
	   to square one. */
d671 1
a671 2
		client->state = S_INIT;
		state_init();
d1152 1
a1152 1
	note("No DHCPOFFERS received.");
@


1.237
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.236 2013/02/17 17:04:41 krw Exp $	*/
d291 3
@


1.236
log
@Suppress some pointless debugging message:

1) If the pipe to the priv process is closed while waiting for
something to happen in the non-priv dispatch() loop, assume the
priv process issued an error message and exit without additional
verbiage.

2) Ditto if the pipe to the priv process is closed when the flush
of IMSG_CLEANUP is attempted.

3) No need to report when SIOCDIFADDR fails because the address is
already gone.

Start to ensure the priv process always issues a useful message
before exiting by noting when it restarts due to the LLADDR having
changed.

Prodded by deraadt@@ to clean this up.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.235 2013/02/17 00:02:44 krw Exp $	*/
d245 2
d249 1
d274 1
d319 1
a319 1
	error("routehandler: %s", errmsg);
d1791 1
a1791 1
	struct imsg_cleanup imsg;
d1827 1
a1827 1
				break;
d1837 2
a1838 1
			break;
d1841 4
a1844 3
		if (n == 0) {	/* connection closed */
			warning("dispatch_imsg in main: pipe closed");
			break;
a1859 5
	memset(&imsg, 0, sizeof(imsg));
	strlcpy(imsg.ifname, ifi->name, sizeof(imsg.ifname));
	imsg.rdomain = ifi->rdomain;
	imsg.addr = active_addr;

d1864 5
a1868 1
	if (quit != SIGTERM)
d1870 1
d1873 3
a1875 1
		warning("Received SIGHUP; restarting.");
d1882 3
@


1.235
log
@Put the processes in the routing domain of the interface. Tweak
error message to show problematic table id and use clearer
verbiage suggested by sthen@@.

Should fix (another!) problem reported by Andreas Bartelt, who
noted that lease renewals did not work in a non-default routing
domain.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.234 2013/02/16 13:50:17 krw Exp $	*/
d270 1
@


1.234
log
@Remove accidentally committed debug statement ("Got RTM_IFINFO").
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.233 2013/02/15 19:52:38 krw Exp $	*/
d409 3
@


1.233
log
@Take more care to use the correct xid, rather than packet garbage.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.232 2013/02/15 15:00:17 krw Exp $	*/
a258 1
		note("Got RTM_IFINFO");
@


1.232
log
@Make code a tad less obscure by using sizeof() actual variable being
zeroed, rather than some other variable that may be the same type.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.231 2013/02/15 14:54:04 krw Exp $	*/
a597 3
	/* make_request doesn't initialize xid because it normally comes
	   from the DHCPDISCOVER, but we haven't sent a DHCPDISCOVER,
	   so pick an xid now. */
d599 1
a600 3
	/* Make a DHCPREQUEST packet, and set appropriate per-interface
	   flags. */
	make_request(client->active);
d615 1
a615 2
	/* Make a DHCPDISCOVER packet, and set appropriate per-interface
	   flags. */
d617 1
a617 1
	client->xid = client->bootrequest_packet.xid;
d691 5
a695 1
	/* Make a DHCPREQUEST packet from the lease we picked. */
a696 1
	client->xid = client->packet.xid;
d843 1
a844 1
	client->xid = client->packet.xid;
d1370 1
a1370 1
	packet->xid = arc4random();
@


1.231
log
@Even if no one uses it, record the seconds since we started in the
correct field.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.230 2013/02/15 14:40:03 krw Exp $	*/
d1377 4
a1380 4
	memset(&packet->ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&packet->yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&packet->siaddr, 0, sizeof(client->packet.siaddr));
	memset(&packet->giaddr, 0, sizeof(client->packet.giaddr));
@


1.230
log
@Unbreak DISCOVER by initializing xid from correct field.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.229 2013/02/14 22:18:12 krw Exp $	*/
d1117 1
a1117 1
		client->packet.secs = htons(interval);
d1119 2
a1120 2
		client->packet.secs = htons(65535);
	client->secs = client->packet.secs;
d1297 1
a1297 1
		client->packet.secs = client->secs;
d1300 1
a1300 1
			client->packet.secs = htons(interval);
d1302 1
a1302 1
			client->packet.secs = htons(65535);
@


1.229
log
@When an interface generates an RTM_IFINFO message, it may be as the
result of its LLADDR changing! Check said address and if it differs
from what we think it is, simulate a SIGHUP to restart, getting the
new address and a new lease for it.

Spotted by, fix tested by, and ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.228 2013/02/14 20:39:46 krw Exp $	*/
d623 1
a623 1
	client->xid = client->packet.xid;
@


1.228
log
@Don't rely on the packet buffer (client->packet) being preserved between
attempts to send DISCOVER or REQUEST packets. Some DHCP servers might
NAK the DISCOVER, or other nefarious packets arrive, between attempts
and overwrite the packet being sent. Create and use another buffer
for packets being sent.

Problem encountered by fgsch@@, who noticed that once the DISCOVER was
NAK'ed our dhclient sent a bunch of NAK's back to the server. Like it
thought they were DISCOVER messages.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.227 2013/02/13 19:32:52 krw Exp $	*/
d179 1
d259 1
d268 7
d473 4
@


1.227
log
@Restore previous behaviour of not cleaning up in response to SIGTERM.

SIGTERM is used to make processes go away during system shutdown and
NFS filesystems may be still be in use when it is received. So removing
routes to the NFS servers is a bad thing.

Problem discovered and fix tested by landry@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.226 2013/02/09 23:37:21 krw Exp $	*/
d1313 2
a1315 1
	struct option_data options[256];
d1319 1
a1319 1
	memset(&client->packet, 0, sizeof(client->packet));
d1350 1
a1350 1
	if (i == -1 || client->packet.options[i] != DHO_END)
d1352 17
a1368 18
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = arc4random();
	client->packet.secs = 0; /* filled in by send_discover. */
	client->packet.flags = 0;

	memset(&client->packet.ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
d1374 2
a1376 1
	struct option_data options[256];
d1380 1
a1380 1
	memset(&client->packet, 0, sizeof(client->packet));
d1417 1
a1417 1
	if (i == -1 || client->packet.options[i] != DHO_END)
d1419 11
a1429 11
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = client->xid;
	client->packet.secs = 0; /* Filled in by send_request. */
	client->packet.flags = 0;
d1436 1
a1436 1
		memcpy(&client->packet.ciaddr, &lease->address.s_addr,
d1439 1
a1439 2
		memset(&client->packet.ciaddr, 0,
		    sizeof(client->packet.ciaddr));
d1442 4
a1445 5
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
d1452 1
d1457 1
a1457 1
	memset(&client->packet, 0, sizeof(client->packet));
d1483 1
a1483 1
	if (i == -1 || client->packet.options[i] != DHO_END)
d1485 11
a1495 11
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = client->xid;
	client->packet.secs = 0; /* Filled in by send_request. */
	client->packet.flags = 0;
d1498 5
a1502 6
	memset(&client->packet.ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
@


1.226
log
@As tedu@@ pointed out a while ago, it makes little sense to discard
an option list if it contains duplicate option names. Just ignore
the duplicates.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.225 2013/02/02 20:20:42 krw Exp $	*/
d1847 6
a1852 1
	priv_cleanup(&imsg);
@


1.225
log
@Expunge unused variables and pointless construction of same in
bind_lease().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.224 2013/02/02 04:18:29 krw Exp $	*/
d2171 4
a2174 7
		for (j = 0; j < ix; j++) {
			if (list[j] == i) {
				note("Duplicate option name: '%s'", p);
				return;
			}
		}
		list[ix++] = i;
@


1.224
log
@Fix resolv.conf magic. Add identifying comment to generated resolv.conf
so it is easy to see which interface generated it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.223 2013/02/02 02:47:16 krw Exp $	*/
a772 1
	char *domainname, *nameservers;
a783 17
	if (options[DHO_DOMAIN_NAME].len)
		domainname = strdup(pretty_print_option(
		    DHO_DOMAIN_NAME, &options[DHO_DOMAIN_NAME], 0));
	else
		domainname = strdup("");
	if (domainname == NULL)
		error("no memory for domainname");

	if (options[DHO_DOMAIN_NAME_SERVERS].len) {
		nameservers = strdup(pretty_print_option(
		    DHO_DOMAIN_NAME_SERVERS,
		    &options[DHO_DOMAIN_NAME_SERVERS], 0));
	} else
		nameservers = strdup("");
	if (nameservers == NULL)
		error("no memory for nameservers");

a803 3

	free(domainname);
	free(nameservers);
@


1.223
log
@Dereference correct pointer. Fix crash when checking whether resolv.conf
should be written. Bad cut 'n paste.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.222 2013/02/01 23:43:33 florian Exp $	*/
d294 1
a294 2
	if (client->active && client->active->resolv_conf &&
	    resolv_conf_priority(ifi->rdomain))
d1931 1
a1931 1
	char *dn, *ns, *nss[MAXNS], *contents, *p;
d1975 5
d1985 3
d2213 1
d2243 4
@


1.222
log
@do not leak dn if there is no resolv.conf contents; found by llvm
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.221 2013/02/01 20:46:04 florian Exp $	*/
d299 2
a300 1
		    client->new->resolv_conf, strlen(client->new->resolv_conf));
@


1.221
log
@always initialize cur_time; found by llvm
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.220 2013/02/01 20:07:30 krw Exp $	*/
d1970 2
a1971 1
	if (len == 0)
d1973 1
@


1.220
log
@Increment size of buffer to accomodate terminating NUL *after* using
same variable to determine if cumulative lengths of strings to be
put in buffer are > 0. Otherwise we always think here is something
to put in buffer.

Reported by florian@@ and his friend llvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.219 2013/02/01 15:24:55 krw Exp $	*/
d1151 1
a1159 1
	time(&cur_time);
@


1.219
log
@Handle a non-existant resolv.conf.tail without issuing an error
message. Handle an empty resolv.conf.tail without exiting. Don't
leak an fd if fstat() on resolv.conf.tail fails. Make fstat()
failure on successfully opened resolv.conf.tail a fatal error.

From Tim van der Molen. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.218 2013/02/01 01:33:44 krw Exp $	*/
d1962 1
a1962 1
	len = strlen(dn) + 1;
d1973 1
@


1.218
log
@Write out resolv.conf only if the default route is under the control
of the process binding the lease. Re-check the default route whenever
a routing message arrives that might mean the default route has
changed, and write out resolv.conf if appropriate.

Reduces the chances that the name servers in resolv.conf are
unreachable.

Problem most eloquently explained, and solution suggested by beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.217 2013/01/27 02:45:46 krw Exp $	*/
d407 3
a409 4
	if (tailfd != -1 && fstat(tailfd, &sb) != -1) {
		config->resolv_tail = calloc(1, sb.st_size + 1);
		if (config->resolv_tail == NULL) {
			error("no memory for resolv.conf.tail contents: %s",
d411 11
a421 3
		} else {
			tailn = read(tailfd, config->resolv_tail,
			    sb.st_size);
d431 1
a431 2
	} else
		note("/etc/resolv.conf.tail: %s", strerror(errno));
@


1.217
log
@Refactor code a bit. Calculate resolv.conf contents once when binding a
lease and reuse as required whenever resolv.conf is written. Use
write_file() rather than a custom message/functions to write out
resolv.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.216 2013/01/26 18:51:42 krw Exp $	*/
d96 1
d292 9
a795 8
	client->new->resolv_conf = resolv_conf_contents(
	    &options[DHO_DOMAIN_NAME], &options[DHO_DOMAIN_NAME_SERVERS]);
	if (client->new->resolv_conf)
		write_file("/etc/resolv.conf",
		    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 0, 0,
		    client->new->resolv_conf, strlen(client->new->resolv_conf));

d808 8
@


1.216
log
@Oops. Restore "no domain-name, no domain-name-seervers means don't
touch resolv.conf" behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.215 2013/01/26 05:07:21 krw Exp $	*/
d63 1
d101 2
a102 1
void		 new_resolv_conf(char *, char *, char *, char *);
d786 7
a792 2
	new_resolv_conf(ifi->name, domainname, nameservers,
	    config->resolv_tail);
d1520 2
d1911 3
a1913 3
void
new_resolv_conf(char *ifname, char *domainname, char *nameservers,
    char *resolv_tail)
d1915 3
a1917 3
	struct imsg_resolv_conf  imsg;
	char			*p;
	int			 rslt;
d1919 1
a1919 1
	memset(&imsg, 0, sizeof(imsg));
d1921 9
a1929 6
	/* Build string of contents of new resolv.conf. */
	if (domainname && strlen(domainname)) {
		strlcat(imsg.contents, "search ", MAXRESOLVCONFSIZE);
		strlcat(imsg.contents, domainname, MAXRESOLVCONFSIZE);
		strlcat(imsg.contents, "\n", MAXRESOLVCONFSIZE);
	}
d1931 13
a1943 7
	for (p = strsep(&nameservers, " "); p != NULL;
	    p = strsep(&nameservers, " ")) {
		if (*p == '\0')
			continue;
		strlcat(imsg.contents, "nameserver ", MAXRESOLVCONFSIZE);
		strlcat(imsg.contents, p, MAXRESOLVCONFSIZE);
		strlcat(imsg.contents, "\n", MAXRESOLVCONFSIZE);
d1946 4
a1949 5
	/* Don't touch resolv.conf if no domainname and no nameservers. */
	if (strlen(imsg.contents) == 0)
		return;

	strlcat(imsg.contents, resolv_tail, MAXRESOLVCONFSIZE);
d1951 2
a1952 2
	rslt = imsg_compose(unpriv_ibuf, IMSG_NEW_RESOLV_CONF, 0, 0, -1, &imsg,
	    sizeof(imsg));
d1954 2
a1955 3
	if (rslt == -1)
		warning("new_resolv_conf: imsg_compose: %s", strerror(errno));
}
d1957 3
a1959 5
void
priv_resolv_conf(struct imsg_resolv_conf *imsg)
{
	ssize_t n;
	int conffd;
d1961 2
a1962 2
	if (strlen(imsg->contents) == 0)
		return;
d1964 5
a1968 6
	conffd = open("/etc/resolv.conf",
	    O_WRONLY | O_CREAT | O_TRUNC | O_SYNC | O_EXLOCK,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
	if (conffd == -1) {
		note("Couldn't open resolv.conf: %s", strerror(errno));
		return;
d1971 2
a1972 10
	n = write(conffd, imsg->contents, strlen(imsg->contents));
	if (n == -1)
		note("Couldn't write contents to resolv.conf: %s",
		    strerror(errno));
	else if (n < strlen(imsg->contents))
		note("Short contents write to resolv.conf (%zd vs %zd)",
		    n, strlen(imsg->contents));

	fchmod(conffd, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
	fchown(conffd, 0, 0); /* root:wheel */
d1974 1
a1974 1
	close(conffd);
@


1.215
log
@Read /etc/resolv.conf.tail once on startup and save contents for
application during subsequent resolv.conf building.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.214 2013/01/22 06:02:52 krw Exp $	*/
d1927 4
@


1.214
log
@Whitespace nit. Better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.213 2013/01/18 08:07:32 jmc Exp $	*/
d100 1
a100 1
void		 new_resolv_conf(char *, char *, char *);
d308 2
a309 1
	int rtfilter;
d394 21
d784 2
a785 1
	new_resolv_conf(ifi->name, domainname, nameservers);
d1903 2
a1904 1
new_resolv_conf(char *ifname, char *domainname, char *nameservers)
d1928 2
d1940 2
a1941 3
	ssize_t n, tailn;
	int conffd, tailfd;
	char *buf;
a1961 33
	tailfd = open("/etc/resolv.conf.tail", O_RDONLY);
	if (tailfd != -1) {
		buf = calloc(1, MAXRESOLVCONFSIZE);
		if (buf == NULL) {
			note("Can't allocate buf for resolv.conf.tail: %s",
			    strerror(errno));
			close(tailfd);
			goto done;
		}

		tailn = read(tailfd, buf, MAXRESOLVCONFSIZE - 1);
		close(tailfd);

		if (tailn == -1)
			note("Couldn't read resolv.conf.tail: %s",
			    strerror(errno));
		else if (tailn == 0)
			note("Got no data from resolv.conf.tail");
		else if (tailn > 0) {
			n = write(conffd, buf, strlen(buf));
			if (n == -1)
				note("Couldn't write tail to resolv.conf: %s",
				    strerror(errno));
			else if (n == 0)
				note("Couldn't write tail to resolv.conf");
			else if (n < strlen(buf))
				note("Short tail write to resolv.conf "
				    "(%zd vs %zd)", n, strlen(buf));
		}
		free(buf);
	}

done:
@


1.213
log
@-L before -l;
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.212 2013/01/18 05:50:32 krw Exp $	*/
d2233 1
a2233 1
 }
@


1.212
log
@Add command line option '-L' that specifies an optional file into which
the most recent offer and effective leases will be written. Intended
to allow access to dhcp option information that was formerly
passed to dhclient-script.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.211 2013/01/17 23:41:07 krw Exp $	*/
d495 1
a495 1
	    "usage: %s [-dqu] [-c file] [-i options] [-l file] [-L file] "
@


1.211
log
@Try harder to clear out default routes on the interface being
configured. Only exempt default routes labelled as being the
property of another dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.210 2013/01/16 21:35:41 krw Exp $	*/
d71 2
d316 1
a316 1
	while ((ch = getopt(argc, argv, "c:di:l:qu")) != -1)
d335 8
d495 2
a496 2
	    "usage: %s [-dqu] [-c file] [-i options] [-l file] interface\n",
	    __progname);
a778 1
	free_client_lease(lease);
d790 3
d1517 1
a1517 1
		leasestr = lease_as_string(lp);
d1525 1
a1525 1
		leasestr = lease_as_string(client->active);
d1537 33
d1571 1
a1571 1
lease_as_string(struct client_lease *lease)
d1582 1
a1582 1
	rslt = snprintf(p, sz, "lease {\n"
d1584 1
a1584 1
	    (lease->is_bootp) ? "  bootp;\n" : "", ifi->name,
d1752 1
a1752 1
	int nfds;
d1807 7
@


1.210
log
@Unrevert last reversion. otto@@ pointed out that it wasn't asprintf()
causing a problem, it was accessing uninitialized pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.209 2013/01/16 11:02:09 krw Exp $	*/
d726 1
a726 1
	flush_routes_and_arp_cache(ifi->rdomain);
@


1.209
log
@Revert last. asprintf() breaks something.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.208 2013/01/16 06:11:21 krw Exp $	*/
d173 1
a173 1
	int linkstat;
d202 1
a202 1
			errmsg = "sa == NULL";
d224 7
a230 1
			errmsg = "interface address added";
d243 7
a249 1
			errmsg = "interface address deleted";
d257 1
a257 1
			errmsg = "interface down";
d280 1
a280 1
			errmsg = "interface departure";
d290 2
d293 1
d645 1
a645 1
dhcpack(struct in_addr client_addr, struct option_data *options)
d653 2
a654 1
	    client->state != S_REBINDING)
d656 1
d660 1
a660 1
		note("DHCPACK isn't satisfactory.");
d664 2
d814 1
a814 1
dhcpoffer(struct in_addr client_addr, struct option_data *options)
a817 5
	char *name = options[DHO_DHCP_MESSAGE_TYPE].len ? "DHCPOFFER" :
	    "BOOTREPLY";

	if (client->state != S_SELECTING)
		return;
d819 2
a820 3
	lease = packet_to_lease(client_addr, options);
	if (!lease) {
		note("%s isn't satisfactory.", name);
d829 1
a829 1
			debug("%s already seen.", name);
a830 1
			free_client_lease(lease);
d835 6
d874 2
d987 1
a987 1
dhcpnak(struct in_addr client_addr, struct option_data *options)
d992 2
a993 1
	    client->state != S_REBINDING)
d995 1
d998 1
a998 1
		note("DHCPNAK with no active lease.");
d1001 2
@


1.208
log
@Use the magic of asprintf() to produce more informative error
and log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.207 2013/01/16 05:16:02 krw Exp $	*/
d173 1
a173 1
	int linkstat, rslt;
d202 1
a202 1
			rslt = asprintf(&errmsg, "%s sa == NULL", ifi->name);
d224 1
a224 7
			if (adding.s_addr != INADDR_ANY)
				rslt = asprintf(&errmsg, "%s, not %s, added "
				    "to %s", inet_ntoa(a), inet_ntoa(adding),
				    ifi->name);
			else
				rslt = asprintf(&errmsg, "%s added to %s",
				    inet_ntoa(a), ifi->name);
d237 1
a237 7
			if (deleting.s_addr != INADDR_ANY)
				rslt = asprintf(&errmsg, "%s, not %s, deleted "
				    "from %s", inet_ntoa(a),
				    inet_ntoa(deleting), ifi->name);
			else
				rslt = asprintf(&errmsg, "%s deleted from %s",
				    inet_ntoa(a), ifi->name);
d245 1
a245 1
			rslt = asprintf(&errmsg, "%s down", ifi->name);
d268 1
a268 1
			rslt = asprintf(&errmsg, "%s departured", ifi->name);
a277 2
	if (rslt == -1)
		error("no memory for errmsg");
a278 1
	free(errmsg);
d630 1
a630 1
dhcpack(struct in_addr client_addr, struct option_data *options, char *info)
d638 1
a638 2
	    client->state != S_REBINDING) {
		note("Unexpected %s. State #%d", info, client->state);
a639 1
	}
d643 1
a643 1
		note("Unsatisfactory %s", info);
a646 2
	note("%s", info);

d795 1
a795 1
dhcpoffer(struct in_addr client_addr, struct option_data *options, char *info)
d799 5
d805 3
a807 2
	if (client->state != S_SELECTING) {
		note("Unexpected %s. State #%d.", info, client->state);
d816 1
a816 1
			debug("Duplicate %s.", info);
d818 1
a822 6
	lease = packet_to_lease(client_addr, options);
	if (!lease) {
		note("Unsatisfactory %s", info);
		return;
	}

a855 2
	note("%s", info);

d967 1
a967 1
dhcpnak(struct in_addr client_addr, struct option_data *options, char *info)
d972 1
a972 2
	    client->state != S_REBINDING) {
		note("Unexpected %s. State #%d", info, client->state);
a973 1
	}
d976 1
a976 1
		note("Unexpected %s. No active lease.", info);
a978 2

	note("%s", info);
@


1.207
log
@Don't tell the priviledged process to discard active_addr if there is
a pending address addition.

Should fix "routehandler: interface address added" messages and
premature exiting of dhclient seen by henniing@@ amoung others.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.206 2013/01/15 21:44:28 krw Exp $	*/
d173 1
a173 1
	int linkstat;
d202 1
a202 1
			errmsg = "sa == NULL";
d224 7
a230 1
			errmsg = "interface address added";
d243 7
a249 1
			errmsg = "interface address deleted";
d257 1
a257 1
			errmsg = "interface down";
d280 1
a280 1
			errmsg = "interface departure";
d290 2
d293 1
d645 1
a645 1
dhcpack(struct in_addr client_addr, struct option_data *options)
d653 2
a654 1
	    client->state != S_REBINDING)
d656 1
d660 1
a660 1
		note("DHCPACK isn't satisfactory.");
d664 2
d814 1
a814 1
dhcpoffer(struct in_addr client_addr, struct option_data *options)
a817 5
	char *name = options[DHO_DHCP_MESSAGE_TYPE].len ? "DHCPOFFER" :
	    "BOOTREPLY";

	if (client->state != S_SELECTING)
		return;
d819 2
a820 3
	lease = packet_to_lease(client_addr, options);
	if (!lease) {
		note("%s isn't satisfactory.", name);
d829 1
a829 1
			debug("%s already seen.", name);
a830 1
			free_client_lease(lease);
d835 6
d874 2
d987 1
a987 1
dhcpnak(struct in_addr client_addr, struct option_data *options)
d992 2
a993 1
	    client->state != S_REBINDING)
d995 1
d998 1
a998 1
		note("DHCPNAK with no active lease.");
d1001 2
@


1.206
log
@Add IMSG_WRITE_FILE and associated bits to allow the unprivileged
process to ask that a file be written by the privileged process.

Not yet used.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.205 2013/01/14 02:46:29 krw Exp $	*/
d230 1
a230 1
			if (client->active &&
@


1.205
log
@First convert packet to lease, which validates option data and
discards bad options. THEN check to see if any required options are
missing and reject both OFFER and ACK packets that lack required
options. Since it is the latter's lease we actual bind.

Move required option check into packet_to_lease() instead of
duplicating it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.204 2013/01/13 22:09:38 krw Exp $	*/
d99 2
d2100 58
@


1.204
log
@Make pretty_print_option() return "" rather than "<fmt error>" when
the option fails validation tests. Make pretty_print_option() bail
on all bad format strings, and on all incorrect option data lengths.

Check pretty_print_option() return value rather than repeating
validation with check_option(). Do res_hnok() check on host name,
domain name, and nis domain while creating lease from packet info.

As a result, nuke ipv4addrs() and check_option().

Ignore options that do not validate rather than summarily rejecting
offered lease. Treat all options whose names start with "option-"
as unknown rather than relying on a big switch on DHO_ names.

Started when reading dhclient(8) -u verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.203 2013/01/13 04:51:28 krw Exp $	*/
d641 1
a641 1
		note("packet_to_lease failed.");
a795 1
	int i;
d803 4
a806 7
	/* If this lease doesn't supply the minimum required parameters,
	   blow it off. */
	for (i = 0; i < config->required_option_count; i++) {
		if (!options[config->required_options[i]].len) {
			note("%s isn't satisfactory.", name);
			return;
		}
d810 2
a811 3
	for (lease = client->offered_leases;
	    lease; lease = lease->next) {
		if (!memcmp(&lease->address.s_addr, &client->packet.yiaddr,
d816 1
a820 6
	lease = packet_to_lease(client_addr, options);
	if (!lease) {
		note("packet_to_lease failed.");
		return;
	}

d912 10
@


1.203
log
@Check results of strdup() of domainname and nameservers options.

Original diff from lteo@@, tweaked by me. ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.202 2013/01/06 15:33:12 krw Exp $	*/
a93 2
int		 check_option(struct client_lease *l, int option);
int		 ipv4addrs(char * buf);
d882 1
a885 1

d895 19
a913 8
		if (options[i].len) {
			lease->options[i] = options[i];
			options[i].data = NULL;
			options[i].len = 0;
			if (!check_option(lease, i)) {
				warning("Invalid lease option - ignoring offer");
				free_client_lease(lease);
				return (NULL);
d915 3
d919 3
a1608 113
check_option(struct client_lease *l, int option)
{
	char *opbuf;
	char *sbuf;

	/* we use this, since this is what gets passed to dhclient-script */

	opbuf = pretty_print_option(option, &l->options[option], 0);

	sbuf = option_as_string(option, l->options[option].data,
	    l->options[option].len);

	switch (option) {
	case DHO_SUBNET_MASK:
	case DHO_SWAP_SERVER:
	case DHO_BROADCAST_ADDRESS:
	case DHO_DHCP_SERVER_IDENTIFIER:
	case DHO_ROUTER_SOLICITATION_ADDRESS:
	case DHO_DHCP_REQUESTED_ADDRESS:
		if (ipv4addrs(opbuf) == 0) {
			warning("Invalid IP address in option %s: %s",
			    dhcp_options[option].name, opbuf);
			return (0);
		}
		if (l->options[option].len != 4) { /* RFC 2132 */
			warning("warning: Only 1 IP address allowed in "
			    "%s option; length %d, must be 4",
			    dhcp_options[option].name,
			    l->options[option].len);
			l->options[option].len = 4;
		}
		return (1);
	case DHO_TIME_SERVERS:
	case DHO_NAME_SERVERS:
	case DHO_ROUTERS:
	case DHO_DOMAIN_NAME_SERVERS:
	case DHO_LOG_SERVERS:
	case DHO_COOKIE_SERVERS:
	case DHO_LPR_SERVERS:
	case DHO_IMPRESS_SERVERS:
	case DHO_RESOURCE_LOCATION_SERVERS:
	case DHO_NIS_SERVERS:
	case DHO_NTP_SERVERS:
	case DHO_NETBIOS_NAME_SERVERS:
	case DHO_NETBIOS_DD_SERVER:
	case DHO_FONT_SERVERS:
		if (ipv4addrs(opbuf) == 0) {
			warning("Invalid IP address in option %s: %s",
			    dhcp_options[option].name, opbuf);
			return (0);
		}
		return (1);
	case DHO_HOST_NAME:
	case DHO_DOMAIN_NAME:
	case DHO_NIS_DOMAIN:
		if (!res_hnok(sbuf)) {
			warning("Bogus Host Name option %d: %s (%s)", option,
			    sbuf, opbuf);
			l->options[option].len = 0;
			free(l->options[option].data);
		}
		return (1);
	case DHO_PAD:
	case DHO_TIME_OFFSET:
	case DHO_BOOT_SIZE:
	case DHO_MERIT_DUMP:
	case DHO_ROOT_PATH:
	case DHO_EXTENSIONS_PATH:
	case DHO_IP_FORWARDING:
	case DHO_NON_LOCAL_SOURCE_ROUTING:
	case DHO_POLICY_FILTER:
	case DHO_MAX_DGRAM_REASSEMBLY:
	case DHO_DEFAULT_IP_TTL:
	case DHO_PATH_MTU_AGING_TIMEOUT:
	case DHO_PATH_MTU_PLATEAU_TABLE:
	case DHO_INTERFACE_MTU:
	case DHO_ALL_SUBNETS_LOCAL:
	case DHO_PERFORM_MASK_DISCOVERY:
	case DHO_MASK_SUPPLIER:
	case DHO_ROUTER_DISCOVERY:
	case DHO_STATIC_ROUTES:
	case DHO_TRAILER_ENCAPSULATION:
	case DHO_ARP_CACHE_TIMEOUT:
	case DHO_IEEE802_3_ENCAPSULATION:
	case DHO_DEFAULT_TCP_TTL:
	case DHO_TCP_KEEPALIVE_INTERVAL:
	case DHO_TCP_KEEPALIVE_GARBAGE:
	case DHO_VENDOR_ENCAPSULATED_OPTIONS:
	case DHO_NETBIOS_NODE_TYPE:
	case DHO_NETBIOS_SCOPE:
	case DHO_X_DISPLAY_MANAGER:
	case DHO_DHCP_LEASE_TIME:
	case DHO_DHCP_OPTION_OVERLOAD:
	case DHO_DHCP_MESSAGE_TYPE:
	case DHO_DHCP_PARAMETER_REQUEST_LIST:
	case DHO_DHCP_MESSAGE:
	case DHO_DHCP_MAX_MESSAGE_SIZE:
	case DHO_DHCP_RENEWAL_TIME:
	case DHO_DHCP_REBINDING_TIME:
	case DHO_DHCP_CLASS_IDENTIFIER:
	case DHO_DHCP_CLIENT_IDENTIFIER:
	case DHO_DHCP_USER_CLASS_ID:
	case DHO_TFTP_SERVER:
	case DHO_END:
		return (1);
	default:
		if (!unknown_ok)
			warning("unknown dhcp option value 0x%x", option);
		return (unknown_ok);
	}
}

int
a1632 22
}

/* Does buf consist only of dotted decimal ipv4 addrs?
 * return how many if so,
 * otherwise, return 0
 */
int
ipv4addrs(char * buf)
{
	struct in_addr jnk;
	int count = 0;

	while (inet_aton(buf, &jnk) == 1){
		count++;
		while (*buf == '.' || isdigit(*buf))
			buf++;
		if (*buf == '\0')
			return (count);
		while (*buf ==  ' ')
			buf++;
	}
	return (0);
@


1.202
log
@Make buffer for lease_as_string() 8192 bytes. A pathological lease
string listing all possible option names turns out to be about 6900
characters long.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.201 2013/01/05 20:34:17 krw Exp $	*/
d721 3
d730 2
@


1.201
log
@Change write_client_lease() into lease_as_string() and modify
rewrite_client_leases() to use lease_as_string(), writing out
complete leases at a time.

While here replace hand formatting of dates with strftime(). This
will add leading zeros to months and days, but not affect the
ability of dhclient to parse the resulting files.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.200 2013/01/02 16:27:42 krw Exp $	*/
d1482 1
a1482 1
	static char leasestr[4096];
@


1.200
log
@Only check '-l' parameter for regular-fileness. Not built-in default
path.  And only error out if the file is successfully lstat()'d and
is not a regular file. i.e. aleady exists. Fixes (U)pdate. Removes
some accidentally duplicated code.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.199 2012/12/29 14:40:00 krw Exp $	*/
d1443 1
d1452 1
d1456 8
a1463 1
		write_client_lease(lp);
d1466 7
a1472 2
	if (client->active)
		write_client_lease(client->active);
d1479 2
a1480 2
void
write_client_lease(struct client_lease *lease)
d1482 33
a1514 2
	struct tm *t;
	int i;
d1516 11
a1526 4
	/* If the lease came from the config file, we don't need to stash
	   a copy in the lease database. */
	if (lease->is_static)
		return;
d1528 19
a1546 2
	if (!leaseFile)	/* XXX */
		error("lease file not open");
d1548 1
a1548 30
	fprintf(leaseFile, "lease {\n");
	if (lease->is_bootp)
		fprintf(leaseFile, "  bootp;\n");
	fprintf(leaseFile, "  interface \"%s\";\n", ifi->name);
	fprintf(leaseFile, "  fixed-address %s;\n", inet_ntoa(lease->address));
	if (lease->filename)
		fprintf(leaseFile, "  filename \"%s\";\n", lease->filename);
	if (lease->server_name)
		fprintf(leaseFile, "  server-name \"%s\";\n",
		    lease->server_name);
	for (i = 0; i < 256; i++)
		if (lease->options[i].len)
			fprintf(leaseFile, "  option %s %s;\n",
			    dhcp_options[i].name,
			    pretty_print_option(i, &lease->options[i], 1));

	t = gmtime(&lease->renewal);
	fprintf(leaseFile, "  renew %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
	    t->tm_hour, t->tm_min, t->tm_sec);
	t = gmtime(&lease->rebind);
	fprintf(leaseFile, "  rebind %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
	    t->tm_hour, t->tm_min, t->tm_sec);
	t = gmtime(&lease->expiry);
	fprintf(leaseFile, "  expire %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
	    t->tm_hour, t->tm_min, t->tm_sec);
	fprintf(leaseFile, "}\n");
	fflush(leaseFile);
@


1.199
log
@Make HUP to either one of the processes cause a restart that will
have dhclient re-read dhclient.conf and get a new lease. Constrain
the filename passed to '-l' (alternate dhclient.lease.if location)
to be a regular file for the moment.

Original suggestion from phessler@@. Feedback from deraadt@@ and
espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.198 2012/12/21 20:37:28 krw Exp $	*/
d312 5
a347 14

	if (lstat(path_dhclient_db, &sb) == -1)
		error("Cannot lstat() '%s': %s", path_dhclient_db,
		    strerror(errno));
	if (!S_ISREG(sb.st_mode))
		error("'%s' is not a regular file", path_dhclient_db);

	if (path_dhclient_conf) {
		if (lstat(path_dhclient_conf, &sb) == -1)
			error("Cannot lstat() '%s': %s", path_dhclient_conf,
			    strerror(errno));
		if (!S_ISREG(sb.st_mode))
			error("'%s' is not a regular file", path_dhclient_conf);
	}
@


1.198
log
@When binding to a new lease, wait for the RTM_NEWADDR message in
S_BOUND state, which prevents confusion when another DHCPACK arrives.

Problem found and fix tested by kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.197 2012/12/19 12:25:38 krw Exp $	*/
d115 1
a115 1
	quit = 1;
d281 2
d286 1
d293 2
d344 14
d412 1
d414 1
d1544 11
a1790 12
	/*
	 * Catch stuff that might be trying to terminate the program.
	 */

	signal(SIGHUP, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGTERM, sighdlr);
	signal(SIGUSR1, sighdlr);
	signal(SIGUSR2, sighdlr);

	signal(SIGPIPE, SIG_IGN);

d1818 3
d1827 8
@


1.197
log
@Don't attempt to delete an address that has already been deleted
by a new dhclient (or anyone else). Instead, use add_address(...,
INADDR_ANY, ...) to tell the privileged process that its active
address is gone. Thus the cleanup process doesn't try to delete it.

Eliminates extraneous log entries complaining that the address can't
be deleted. Narrows race window where old dhclient might delete the
address the new dhclient has just added.

Make rapid-fire starting of dhclient even more reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.196 2012/12/18 14:34:58 krw Exp $	*/
a220 1
				client->state = S_BOUND;
d740 2
@


1.196
log
@Don't clean up twice when the non-privileged process exits. Let the
privileged process now cleans up itself. Continuous rapid repeated
running of dhclient now more reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.195 2012/12/17 22:52:59 krw Exp $	*/
d171 1
a171 1
	struct in_addr a;
d229 7
@


1.195
log
@Don't daemonize until the RTM_NEWADDR message is received. Shuffle
things a bit so configuring the address and default route are done
last. This makes it much more likely that all the work is done when
the 'bound to ...' message is displayed.

Amoung other things fixes a problem with the install scripts, where
the first (hostname-associated) dhclient can exit so quickly the
interface doesn't yet have an address and a second (free-floating)
dhclient is therefore often run.

Noted by rpe@@, who also tested the fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.194 2012/12/16 03:15:46 lteo Exp $	*/
a271 1
	cleanup(client->active);
@


1.194
log
@Prevent a potential segfault that could occur if certain calloc() and
strdup() calls happen to return NULL.  If they do return NULL, error out
to be consistent with what most of the rest of the code does when memory
allocation fails.

feedback/ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.193 2012/12/15 13:26:28 krw Exp $	*/
d217 6
d493 2
d698 1
a698 8
	add_address(ifi->name, ifi->rdomain, client->new->address, mask);
	if (options[DHO_ROUTERS].len) {
		memset(&gateway, 0, sizeof(gateway));
		/* XXX Only use FIRST router address for now. */
		memcpy(&gateway.s_addr, options[DHO_ROUTERS].data,
		    options[DHO_ROUTERS].len);
		add_default_route(ifi->rdomain, client->new->address, gateway);
	}
d713 13
a740 6

	note("bound to %s -- renewal in %lld seconds.",
	    inet_ntoa(client->active->address),
	    (long long)(client->active->renewal - time(NULL)));
	client->state = S_BOUND;
	go_daemon();
@


1.193
log
@Nuke unused parameter 'ifname' to get_ifname().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.192 2012/12/10 10:39:01 jmc Exp $	*/
d1943 2
d1965 2
d1978 2
d1994 2
d2010 2
d2024 9
d2042 2
d2051 1
a2051 1
	if (oldlease->server_name)
d2053 4
a2056 1
	if (oldlease->filename)
d2058 3
d2065 2
d2072 6
@


1.192
log
@add -i to usage(); ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.191 2012/12/09 20:28:03 krw Exp $	*/
d99 1
a99 1
void		 get_ifname(char *, char *);
d323 1
a323 1
	get_ifname(ifi->name, argv[0]);
d1794 1
a1794 1
get_ifname(char *ifname, char *arg)
@


1.191
log
@Add a new option to the dhclient command line interface. '-i' takes
a list of option names, and any values provided for those options
in leases will be ignored.

Requested by phessler@@ and djm@@. Tested by phessler@@. Possible
non-optimality of ignoring list in case of error pointed out by
tedu@@.

ok phessler@@ todd@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.190 2012/12/05 18:11:33 krw Exp $	*/
d446 2
a447 1
	fprintf(stderr, "usage: %s [-dqu] [-c file] [-l file] interface\n",
@


1.190
log
@Archeological investigation shows dhclient-script did not overwrite
resolv.conf unless at least one of domain-name or domain-name-servers
were provided in the lease being bound.

Tweak priv_resolv_conf() to do the same. i.e. don't overwrite
resolv.conf with resolv.conf.tail when neither domain-name nor
domain-name-servers are provided in the lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.189 2012/12/05 03:14:10 krw Exp $	*/
d104 1
d276 1
d283 1
a283 1
	while ((ch = getopt(argc, argv, "c:dl:qu")) != -1)
d291 3
d344 2
d2056 43
@


1.189
log
@If there is no domain-name and no domain-name-servers provided in
the lease (or if they are 'ignore'd in dhclient.conf), and there
is no resolv,conf.tail then do not remove any existing resolv.conf.

Restores the behaviour ajacoutot@@ expected and todd@@ thinks makes
sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.188 2012/12/04 19:24:02 krw Exp $	*/
d1866 2
a1867 2
	ssize_t n;
	int conffd, tailfd, tailn;
d1870 1
a1870 17
	tailn = 0;
	buf = calloc(1, MAXRESOLVCONFSIZE);

	tailfd = open("/etc/resolv.conf.tail", O_RDONLY);

	if (tailfd != -1) {
		tailn = read(tailfd, buf, MAXRESOLVCONFSIZE - 1);
		close(tailfd);
		if (tailn == -1)
			note("Couldn't read resolv.conf.tail: %s",
			    strerror(errno));
		else if (tailn == 0)
			note("Got no data from resolv.conf.tail");
	}

	if (strlen(imsg->contents) == 0 && tailn < 1) {
		free(buf);
a1871 1
	}
a1877 1
		free(buf);
d1881 13
a1893 5
	n = 0;
	if (strlen(imsg->contents)) {
		n = write(conffd, imsg->contents, strlen(imsg->contents));
		if (n == -1)
			note("Couldn't write contents to resolv.conf: %s",
d1895 6
a1900 6
		else if (n == 0)
			note("Couldn't write contents to resolv.conf");
		else if (n < strlen(imsg->contents))
			note("Short contents write to resolv.conf (%zd vs %zd)",
			    n, strlen(imsg->contents));
	}
d1902 2
a1903 4
	if (tailn > 0) {
		n = write(conffd, buf, strlen(buf));
		if (n == -1)
			note("Couldn't write tail to resolv.conf: %s",
d1905 14
a1918 5
		else if (n == 0)
			note("Couldn't write tail to resolv.conf");
		else if (n < strlen(buf))
			note("Short tail write to resolv.conf "
			    "(%zd vs %zd)", n, strlen(buf));
d1921 1
a1924 1
	free(buf);
@


1.188
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.187 2012/12/03 22:36:16 krw Exp $	*/
d1870 20
d1895 1
d1899 1
d1912 4
a1915 12
	tailfd = open("/etc/resolv.conf.tail", O_RDONLY);

	n = tailn = 0;
	buf = calloc(1, MAXRESOLVCONFSIZE);

	if (tailfd == -1)
		note("Couldn't open resolv.conf.tail: %s", strerror(errno));
	else {
		tailn = read(tailfd, buf, MAXRESOLVCONFSIZE - 1);
		close(tailfd);
		if (tailn == -1)
			note("Couldn't read resolv.conf.tail: %s",
d1917 5
a1921 21
		else if (tailn == 0)
			note("Got no data from resolv.conf.tail");
		else {
			n = write(conffd, buf, strlen(buf));
			if (n == -1)
				note("Couldn't write tail to resolv.conf: %s",
				    strerror(errno));
			else if (n == 0)
				note("Couldn't write tail to resolv.conf");
			else if (n < strlen(buf))
				note("Short tail write to resolv.conf "
				    "(%zd vs %zd)", n, strlen(buf));
		}
		free(buf);
	}

	if ((strlen(imsg->contents) == 0) && (tailn < 1 || n < 1)) {
		note("No contents for resolv.conf");
		unlink("/etc/resolv.conf");
		close(conffd);
		return;
d1927 1
@


1.187
log
@Backout last. It breaks existing 'ifconfig down ; dhclient' usage.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.186 2012/12/03 22:19:47 krw Exp $	*/
d364 1
a364 1
		error("cannot open %s: %m", _PATH_DEVNULL);
d373 1
a373 1
		error("socketpair: %m");
d385 2
a386 1
		error("can't open and lock %s: %m", path_dhclient_db);
d389 1
a389 1
		error("can't open %s: %m", path_dhclient_db);
d394 1
a394 1
		error("socket(PF_ROUTE, SOCK_RAW): %m");
d401 1
a401 1
		error("setsockopt(ROUTE_MSGFILTER): %m");
d404 1
a404 1
		error("setsockopt(ROUTE_TABLEFILTER): %m");
d1753 1
a1753 1
				warning("poll error: %m");
d1763 1
a1763 1
			warning("imsg_read(priv_ibuf): %m");
d1801 1
a1801 1
			error("ioctl SIOCGIFGMEMB: %m");
d1807 1
a1807 1
			error("ioctl SIOCGIFGMEMB: %m");
d1819 1
a1819 1
			error("Interface name too long: %m");
d1860 1
a1860 1
		warning("new_resolv_conf: imsg_compose: %m");
d1874 1
a1874 1
		note("Couldn't open resolv.conf: %m");
d1881 2
a1882 1
			note("Couldn't write contents to resolv.conf: %m");
d1896 1
a1896 1
		note("Couldn't open resolv.conf.tail: %m");
d1901 2
a1902 1
			note("Couldn't read resolv.conf.tail: %m");
d1908 2
a1909 1
				note("Couldn't write tail to resolv.conf: %m");
d2047 1
a2047 1
		error("fcntl F_GETF: %m");
d2052 1
a2052 1
		error("fcntl F_SETFL: %m");
@


1.186
log
@Cleanup after a 'ifconfig down', but stick around so 'ifconfig up'
will get a new lease without having to restart dhclient. Also tweak
cleanup() to cancel any existing timeout, so one doesn't fire between
'down' and 'up'.

Makes sense to chris@@ beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.185 2012/12/02 17:03:19 krw Exp $	*/
d232 2
a233 3
			ifi->linkstat = 0;
			cleanup(client->active);
			return;
@


1.185
log
@Try harder to cleanup when exiting. In particular catch signals
SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUS2 and cleanup before exiting
when getting them. Cleanup meaning removing routes and the interface
address added.

Tweaks and feedback from phessler@@, sthen@@, otto@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.184 2012/12/01 11:59:44 krw Exp $	*/
d232 3
a234 2
			errmsg = "interface down";
			goto die;
@


1.184
log
@Make privileged process daemonize too. Using same function as the
non-privileged process, go_daemon().

As pointed out by kettenis@@, otherwise it is still attached to a
controlling terminal and subject to the dangers thereof. Prep for
having the privileged process pay attention to signals.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.183 2012/11/29 14:13:31 krw Exp $	*/
d77 2
d90 1
d111 6
d265 1
a265 1
	flush_routes_and_arp_cache(ifi->rdomain);
d1705 1
d1735 13
a1747 1
	for (;;) {
d1751 5
a1755 2
			if (errno != EINTR)
				error("poll error: %m");
d1761 4
a1764 2
		if ((n = imsg_read(priv_ibuf)) == -1)
			error("imsg_read(priv_ibuf): %m");
d1766 4
a1769 2
		if (n == 0)	/* connection closed */
			error("dispatch_imsg in main: pipe closed");
d1773 9
@


1.183
log
@Nobody looks at the result of fork_privchld(), so make it return
void and not int/pid_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.182 2012/11/27 15:51:48 krw Exp $	*/
d1716 1
a1716 5
	if (!no_daemon) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
	}
a1717 1
	close(nullfd);
@


1.182
log
@Clean up parsing of option lists. Part 6.

Treat 'ignore' option lists the same as 'request' and 'require'
option lists. i.e.  keep a list of the options rather than using
an ACTION flag. So overriding a previous ignore list will not leave
breadcrumbs and incorrect ACTIONs lying around.

The list will be applied when the new lease is created, and will
override any ACTION specified for the option.

Mention in dhclient.conf(5) that each request/require/ignore statement
will override any previous one.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.181 2012/11/25 12:49:56 krw Exp $	*/
d95 1
a95 1
pid_t		 fork_privchld(int, int);
d1693 1
a1693 1
int
d1708 1
a1708 1
		return (0);
@


1.181
log
@Clean up parsing of option lists. Part 1.

1) Add config->required_options_count so that syntactically incorrect
request statement in dhclient.conf is completely ignored.
2) Pass size of buffer being filled instead of assuming 256.
3) Always zero (a.k.a. DHO_PAD) the passed in buffer.
4) Check for out of bounds index before using it, not after.

Add TOK_IGNORE to syntax in comment.

No intentional functional change other than catching bad request
statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.180 2012/11/24 18:06:14 krw Exp $	*/
d1899 1
a1899 1
	int i;
d1904 11
a1915 7
		case ACTION_IGNORE:
			if (newlease->options[i].len != 0)
				free(newlease->options[i].data);
			newlease->options[i].data = NULL;
			newlease->options[i].len = 0;
			break;

@


1.180
log
@Don't segfault if no subnet-mask is provided, or is marked 'ignore'
in dhclient.conf.

Always zero out stack masks rather than using stack garbage when
no subnet-mask is provided.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.179 2012/11/23 15:25:47 krw Exp $	*/
d758 1
a758 1
	for (i = 0; config->required_options[i]; i++) {
@


1.179
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.178 2012/11/16 16:46:18 krw Exp $	*/
d669 1
@


1.178
log
@Call discover_interface() before forking, so both processes will know
the interface index, hardware address, etc. as well as the interface
name.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.177 2012/11/15 14:54:18 krw Exp $	*/
a71 1
int privfd;
d86 1
d100 1
d263 1
a263 1
	int	 ch, fd, quiet = 0, i = 0, pipe_fd[2];
a359 3
	if (pipe(pipe_fd) == -1)
		error("pipe");

d363 11
a373 4
	fork_privchld(pipe_fd[0], pipe_fd[1]);

	close(pipe_fd[0]);
	privfd = pipe_fd[1];
d1696 2
d1724 5
d1730 1
a1730 1
		pfd[0].fd = fd;
d1732 1
a1732 1
		if ((nfds = poll(pfd, 1, INFTIM)) == -1)
d1734 2
a1735 1
				error("poll error");
d1740 7
a1746 1
		dispatch_imsg(fd);
a1795 2
#define MAXRESOLVCONFSIZE 2048

d1799 3
a1801 4
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;
	char		*contents, *p;
d1803 1
a1803 1
	contents = calloc(1, MAXRESOLVCONFSIZE);
d1807 3
a1809 3
		strlcat(contents, "search ", MAXRESOLVCONFSIZE);
		strlcat(contents, domainname, MAXRESOLVCONFSIZE);
		strlcat(contents, "\n", MAXRESOLVCONFSIZE);
d1816 3
a1818 3
		strlcat(contents, "nameserver ", MAXRESOLVCONFSIZE);
		strlcat(contents, p, MAXRESOLVCONFSIZE);
		strlcat(contents, "\n", MAXRESOLVCONFSIZE);
d1821 2
a1822 6
	hdr.code = IMSG_NEW_RESOLV_CONF;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + strlen(contents);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));
d1824 2
a1825 7
	len = strlen(contents);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, contents, len);

	buf_close(privfd, buf);

	free(contents);
d1829 1
a1829 1
priv_resolv_conf(char *contents)
d1843 2
a1844 2
	if (contents) {
		n = write(conffd, contents, strlen(contents));
d1849 1
a1849 1
		else if (n < strlen(contents))
d1851 1
a1851 1
			    n, strlen(contents));
d1881 1
a1881 1
	if ((!contents || strlen(contents) == 0) && (tailn < 1 || n < 1)) {
d1997 14
@


1.177
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.176 2012/11/15 10:32:59 krw Exp $	*/
d362 3
a389 3

	/* set up the interface */
	discover_interface();
@


1.176
log
@If '-d' is specified to keep dhclient from daemonizing, don't
redirect privileged child's STDIN/OUT/ERROR to /dev/null. This was
already avoided for the unprivileged process. Makes printf/note
debugging easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.175 2012/11/14 18:10:45 krw Exp $	*/
d56 3
a60 1
#include <ctype.h>
a62 3

#include "dhcpd.h"
#include "privsep.h"
@


1.175
log
@Oops. Commit the one that actually compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.174 2012/11/14 18:09:01 krw Exp $	*/
d1709 6
a1714 3
	dup2(nullfd, STDIN_FILENO);
	dup2(nullfd, STDOUT_FILENO);
	dup2(nullfd, STDERR_FILENO);
@


1.174
log
@When copying option.data, use option.len to specify the amount of
data to copy, rather than a static value that *may* be incorrect.
e.g. when option.data is NULL. Allows 'ignore subnet-mask;' to work.

Prompted by a different but similar problem found by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.173 2012/11/14 15:47:41 krw Exp $	*/
d728 1
a728 1
		    client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len));
@


1.173
log
@Remove useless _new_ and _old_ from various function names to make
them shorter and eliminate implications about what the function
does. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.172 2012/11/11 16:36:13 krw Exp $	*/
d665 2
a666 1
	memcpy(&mask.s_addr, options[DHO_SUBNET_MASK].data, sizeof(in_addr_t));
d672 1
a672 1
		    sizeof(in_addr_t));
d728 1
a728 1
		    sizeof(in_addr_t));
@


1.172
log
@Fix dhclient.conf 'default' directive which was also broken in code
refactoring. i.e. use specified value if server has provided no
data.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.171 2012/11/11 14:33:20 krw Exp $	*/
d659 1
a659 1
	delete_old_addresses(ifi->name, ifi->rdomain);
d666 1
a666 1
	add_new_address(ifi->name, ifi->rdomain, client->new->address, mask);
d1104 1
a1104 1
			delete_old_address(ifi->name, ifi->rdomain,
d1819 1
a1819 1
priv_new_resolv_conf(char *contents)
@


1.171
log
@supersede/append/prepend actions should work even if the dhcp server
doesn't send any data for the affected option. This was broken when
the supersede/append/prepend/ignore logic was refactored.

Reported by and fix tested by johnw via misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.170 2012/11/08 21:32:55 krw Exp $	*/
d1937 13
@


1.170
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.169 2012/11/07 15:40:13 krw Exp $	*/
a1892 3
		if (newlease->options[i].len == 0)
			continue;

d1895 2
a1896 1
			free(newlease->options[i].data);
d1902 2
a1903 1
			free(newlease->options[i].data);
d1912 2
a1913 1
			free(newlease->options[i].data);
d1926 2
a1927 1
			free(newlease->options[i].data);
@


1.169
log
@Always memcpy() into/out of option data rather than hoping the char *
will be always be aligned. Don't pass around pointers into option
data - use variable that has the memcpy()'d data.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.168 2012/11/07 15:20:28 krw Exp $	*/
d79 2
a80 3
struct iaddr iaddr_broadcast = { 4, { 255, 255, 255, 255 } };
struct iaddr iaddr_deleting;
struct iaddr iaddr_adding;
a155 1
struct iaddr defaddr = { 4 };
d160 3
a163 1
	char msg[2048];
a168 2
	struct iaddr a;
	ssize_t n;
d196 2
a197 4
		if ((a.len = sizeof(struct in_addr)) > sizeof(a.iabuf))
			error("king bula sez: len mismatch");
		memcpy(a.iabuf, &((struct sockaddr_in *)sa)->sin_addr, a.len);
		if (addr_eq(a, defaddr))
d205 2
a206 2
			if (addr_eq(a, iaddr_adding)) {
				iaddr_adding = defaddr;
d211 2
a212 2
			if (addr_eq(a, iaddr_deleting)) {
				iaddr_deleting = defaddr;
d481 1
a481 1
	client->destination = iaddr_broadcast;
d499 1
a499 1
	client->destination = iaddr_broadcast;
d567 1
a567 1
	client->destination = iaddr_broadcast;
d583 1
a583 1
dhcpack(struct iaddr client_addr, struct option_data *options)
d654 1
a654 1
	struct iaddr gateway;
a656 1
	in_addr_t mask;
d665 1
a665 1
	memcpy(&mask, options[DHO_SUBNET_MASK].data, sizeof(mask));
d670 1
a670 2
		gateway.len = sizeof(in_addr_t);
		memcpy(gateway.iabuf, options[DHO_ROUTERS].data,
d705 1
a705 1
	    piaddr(client->active->address),
d725 1
a725 1
		memcpy(client->destination.iabuf,
d727 1
a727 2
		    4);
		client->destination.len = 4;
d729 1
a729 1
		client->destination = iaddr_broadcast;
d739 1
a739 1
dhcpoffer(struct iaddr client_addr, struct option_data *options)
d762 2
a763 3
		if (lease->address.len == sizeof(client->packet.yiaddr) &&
		    !memcmp(lease->address.iabuf,
		    &client->packet.yiaddr, lease->address.len)) {
d794 1
a794 1
	if (addr_eq(lease->address, client->requested_address)) {
d825 1
a825 1
packet_to_lease(struct iaddr client_addr, struct option_data *options)
d853 2
a854 3
	lease->address.len = sizeof(client->packet.yiaddr);
	memcpy(lease->address.iabuf, &client->packet.yiaddr,
	    lease->address.len);
d894 1
a894 1
dhcpnak(struct iaddr client_addr, struct option_data *options)
d1008 1
a1008 1
			    piaddr(client->active->address));
d1138 1
a1138 2
		memcpy(&destination.sin_addr.s_addr, client->destination.iabuf,
		    sizeof(destination.sin_addr.s_addr));
d1144 1
a1144 1
		memcpy(&from, client->active->address.iabuf, sizeof(from));
d1200 2
a1201 2
		options[i].data = lease->address.iabuf;
		options[i].len = lease->address.len;
d1203 1
a1203 1
		client->requested_address.len = 0;
d1269 3
a1271 4
		options[i].data = lease->address.iabuf;
		options[i].len = lease->address.len;
	} else
		client->requested_address.len = 0;
d1301 2
a1302 2
		memcpy(&client->packet.ciaddr,
		    lease->address.iabuf, lease->address.len);
d1337 2
a1338 2
	options[i].data = lease->address.iabuf;
	options[i].len = lease->address.len;
d1400 2
a1401 2
		if (client->active && addr_eq(lp->address, 
		    client->active->address))
d1432 1
a1432 1
	fprintf(leaseFile, "  fixed-address %s;\n", piaddr(lease->address));
@


1.168
log
@Use memset() consistently rather than tossing in a few bzero()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.167 2012/11/07 15:07:02 krw Exp $	*/
d661 1
a661 1
	in_addr_t *mask = NULL;
d670 1
a670 1
	mask = (in_addr_t *)options[DHO_SUBNET_MASK].data;
@


1.167
log
@Use memcpy() consistently rather than tossing in a few bcopy()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.166 2012/11/04 03:36:39 krw Exp $	*/
d673 1
a673 1
		bzero(&gateway, sizeof(gateway));
d1750 1
a1750 1
		bzero(&ifgr, sizeof(ifgr));
@


1.166
log
@No need to pass interface name around when flushing routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.165 2012/11/04 03:25:31 krw Exp $	*/
d676 2
a677 2
		bcopy(options[DHO_ROUTERS].data,
		    gateway.iabuf, sizeof(in_addr_t));
@


1.165
log
@No need to pass interface name around when creating routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.164 2012/11/03 16:54:34 krw Exp $	*/
d260 1
a260 1
	flush_routes_and_arp_cache(ifi->name, ifi->rdomain);
d665 1
a665 1
	flush_routes_and_arp_cache(ifi->name, ifi->rdomain);
@


1.164
log
@Various fixes/tweaks for resolv.conf handling:

1) Don't leak a file descriptor if there are no contents for
resolv.conf.
2) Allow for only resolv.conf.tail to go into resolv.conf.
3) Don't need to pass around interface name when creating resolv.conf.
4) Don't leave 0 length resolv.conf lying around if there are no
contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.163 2012/11/02 17:29:37 krw Exp $	*/
d678 1
a678 2
		add_default_route(ifi->name, ifi->rdomain,
		    client->new->address, gateway);
@


1.163
log
@Don't add a 'nameserver' line to resolv.conf if the nameserver in
question is the empty string.

Spotted by Joerg Zinke.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.162 2012/10/31 20:13:33 krw Exp $	*/
a1815 1
	    sizeof(len) + strlen(ifname) +
a1820 4
	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

d1831 1
a1831 1
priv_new_resolv_conf(char *ifname, char *contents)
d1845 10
a1854 8
	n = write(conffd, contents, strlen(contents));
	if (n == -1)
		note("Couldn't write contents to resolv.conf: %m");
	else if (n == 0)
		note("Couldn't write contents to resolv.conf");
	else if (n < strlen(contents))
		note("Short contents write to resolv.conf (%zd vs %zd)", n,
		    strlen(contents));
d1858 1
a1858 1
	tailn = 0;
d1883 1
a1883 1
	if (strlen(contents) == 0 && tailn == 0) {
d1885 2
@


1.162
log
@Delete some leftover debug code and the array it rode in on.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.161 2012/10/31 18:21:03 krw Exp $	*/
d1807 2
@


1.161
log
@chris@@ spotted a '2038' where a '2048' was meant and pointed out
that a macro (which I called MAXRESOLVCONSIZE) would make things
easier to read and reduce such typos. Make it so.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.160 2012/10/31 15:50:47 krw Exp $	*/
d171 1
a171 1
	char *errmsg, buf[64];
a212 2
			snprintf(buf, sizeof(buf), "%s: %s",
			    "new address not one we set", piaddr(a));
a218 2
			snprintf(buf, sizeof(buf), "%s: %s",
			    "new address not one we set", piaddr(a));
@


1.160
log
@Forcibly delete all existing ipv4 addresses from an interface when
binding a lease to that interface. This fixes issues sthen@@ found
with unexpectedly persistant addresses and failures of dhclient
when switching an interface repeatedly between different networks.

This crude but predictable behaviour may be toned down once it
is figured out what we want to do with mixed static/dynamic
configurations on an interface.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.159 2012/10/30 18:39:44 krw Exp $	*/
d1790 2
d1800 1
a1800 1
	contents = calloc(1, 2048);
d1804 3
a1806 3
		strlcat(contents, "search ", 2048);
		strlcat(contents, domainname, 2048);
		strlcat(contents, "\n", 2048);
d1811 3
a1813 3
		strlcat(contents, "nameserver ", 2048);
		strlcat(contents, p, 2038);
		strlcat(contents, "\n", 2048);
d1864 1
a1864 1
	buf = calloc(1, 2048);
d1869 1
a1869 1
		tailn = read(tailfd, buf, 2047);
@


1.159
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.158 2012/10/27 23:08:53 krw Exp $	*/
d668 1
a668 5
	if (client->active) {
		delete_old_address(ifi->name, ifi->rdomain,
		    client->active->address);
	}

@


1.158
log
@Change dhclient.conf directive 'ignore' to take a list of option names
rather than list of option declarations. e.g. 'ignore routers;'
instead of 'ignore routers 1.2.3.4;' The value in the declaration
was being ignored anyway.

While there clean up the related code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.157 2012/10/10 17:44:43 krw Exp $	*/
d80 3
d97 1
a97 1
int		 fork_privchld(int, int);
d99 3
a106 1
time_t	scripttime;
a167 1
	struct client_lease *l;
d184 1
d204 15
a218 5
		/* state_panic() can try unexpired existing leases */
		if (client->active && addr_eq(a, client->active->address))
			break;
		for (l = client->leases; l != NULL; l = l->next)
			if (addr_eq(a, l->address))
d220 5
a224 19
		if (l != NULL)
			/* new addr is the one we set */
			break;

		snprintf(buf, sizeof(buf), "%s: %s",
		    "new address not one we set", piaddr(a));
		errmsg = buf;
		goto die;
	case RTM_DELADDR:
		ifam = (struct ifa_msghdr *)rtm;
		if (ifam->ifam_index != ifi->index)
			break;
		if (findproto((char *)ifam + ifam->ifam_hdrlen,
		    ifam->ifam_addrs) != AF_INET)
			break;
		/* XXX check addrs like RTM_NEWADDR instead of this? */
		if (scripttime == 0 || time(NULL) < scripttime + 10)
			break;
		errmsg = "interface address deleted";
d264 1
a264 2
	script_init("FAIL");
	script_go();
d393 3
d662 44
a705 8
	/* Run the client script with the new parameters. */
	script_init((client->state == S_REQUESTING ? "BOUND" :
	    (client->state == S_RENEWING ? "RENEW" :
	    (client->state == S_REBOOTING ? "REBOOT" : "REBIND"))));
	if (client->active && client->state != S_REBOOTING)
		script_write_params("old_", client->active);
	script_write_params("new_", client->new);
	script_go();
a950 2
	/* If we're past the panic timeout, call the script and tell it
	   we haven't found anything for this interface yet. */
d1005 1
a1005 2
 * that haven't yet expired, and failing that, we call the client script
 * and hope it can do something.
d1027 17
a1043 23
			/* Run the client script with the existing
			   parameters. */
			script_init("TIMEOUT");
			script_write_params("new_", client->active);

			/* If the old lease is still good and doesn't
			   yet need renewal, go into BOUND state and
			   timeout at the renewal time. */
			if (!script_go()) {
				if (cur_time < client->active->renewal) {
					client->state = S_BOUND;
					note("bound: renewal in %lld seconds.",
					    (long long)(client->active->renewal
					    - cur_time));
					set_timeout(client->active->renewal,
					    state_bound);
				} else {
					client->state = S_BOUND;
					note("bound: immediate renewal.");
					state_bound();
				}
				go_daemon();
				return;
d1045 2
d1076 3
a1078 3
	/* No leases were available, or what was available didn't work, so
	   tell the shell script that we failed to allocate an address,
	   and try again later. */
a1079 2
	script_init("FAIL");
	script_go();
d1121 4
a1124 5
		/* Run the client script with the new parameters. */
		script_init("EXPIRE");
		script_write_params("old_", client->active);
		script_go();

a1480 352
script_init(char *reason)
{
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;

	hdr.code = IMSG_SCRIPT_INIT;
	hdr.len = sizeof(struct imsg_hdr) + sizeof(size_t) + strlen(reason);

	buf = buf_open(hdr.len);

	buf_add(buf, &hdr, sizeof(hdr));
	len = strlen(reason);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, reason, len);

	buf_close(privfd, buf);
}

void
priv_script_init(char *reason)
{
	char *rdomain;

	client->scriptEnvsize = 100;
	if (client->scriptEnv == NULL)
		client->scriptEnv =
		    calloc(client->scriptEnvsize, sizeof(char *));
	if (client->scriptEnv == NULL)
		error("script_init: no memory for environment");

	client->scriptEnv[0] = strdup(CLIENT_PATH);
	if (client->scriptEnv[0] == NULL)
		error("script_init: no memory for environment");

	client->scriptEnv[1] = NULL;

	script_set_env("", "interface", ifi->name);

	if (asprintf(&rdomain, "-T %d", ifi->rdomain) == -1)
		error("script_init: no memory for environment");

	script_set_env("", "rdomain", rdomain);
	free(rdomain);

	script_set_env("", "reason", reason);
}

void
priv_script_write_params(char *prefix, struct client_lease *lease)
{
	char buf[256];
	struct option_data o;
	int i;

	script_set_env(prefix, "ip_address", piaddr(lease->address));

	if (lease->options[DHO_SUBNET_MASK].len &&
	    (lease->options[DHO_SUBNET_MASK].len <
	    sizeof(lease->address.iabuf))) {
		struct iaddr netmask, subnet, broadcast;

		memcpy(netmask.iabuf, lease->options[DHO_SUBNET_MASK].data,
		    lease->options[DHO_SUBNET_MASK].len);
		netmask.len = lease->options[DHO_SUBNET_MASK].len;

		subnet = subnet_number(lease->address, netmask);
		if (subnet.len) {
			script_set_env(prefix, "network_number",
			    piaddr(subnet));
			if (!lease->options[DHO_BROADCAST_ADDRESS].len) {
				broadcast = broadcast_addr(subnet, netmask);
				if (broadcast.len)
					script_set_env(prefix,
					    "broadcast_address",
					    piaddr(broadcast));
			}
		}
	}

	if (lease->filename)
		script_set_env(prefix, "filename", lease->filename);
	if (lease->server_name)
		script_set_env(prefix, "server_name",
		    lease->server_name);

	for (i = 0; i < 256; i++) {
		if (!dhcp_option_ev_name(buf, sizeof(buf), &dhcp_options[i]))
			continue;

		switch (config->default_actions[i]) {
		case ACTION_IGNORE:
			 break;

		case ACTION_DEFAULT:
			if (lease->options[i].len)
				script_set_env(prefix, buf,
				    pretty_print_option(i, &lease->options[i],
					0));
			else if (config->defaults[i].len)
				script_set_env(prefix, buf,
				    pretty_print_option(i, &config->defaults[i],
					0));
			break;

		case ACTION_SUPERSEDE:
			if (config->defaults[i].len)
				script_set_env(prefix, buf,
				    pretty_print_option(i, &config->defaults[i],
					0));
			break;

		case ACTION_PREPEND:
			o.len = config->defaults[i].len + lease->options[i].len;
			if (o.len > 0) {
				o.data = calloc(1, o.len);
				if (o.data == NULL)
					error("no space to prepend '%s' to %s",
					    config->defaults[i].data,
					    dhcp_options[i].name);
				memcpy(o.data, config->defaults[i].data,
				    config->defaults[i].len);
				memcpy(o.data + config->defaults[i].len,
				    lease->options[i].data,
				    lease->options[i].len);
				script_set_env(prefix, buf,
				    pretty_print_option(i, &o, 0));
				free(o.data);
			}
			break;

		case ACTION_APPEND:
			o.len = config->defaults[i].len + lease->options[i].len;
			if (o.len > 0) {
				o.data = calloc(1, o.len);
				if (o.data == NULL)
					error("no space to append '%s' to %s",
					    config->defaults[i].data,
					    dhcp_options[i].name);
				memcpy(o.data, lease->options[i].data,
				    lease->options[i].len);
				memcpy(o.data + lease->options[i].len,
				    config->defaults[i].data,
				    config->defaults[i].len);
				script_set_env(prefix, buf,
				    pretty_print_option(i, &o, 0));
				free(o.data);
			}
			break;
		}
	}

	snprintf(buf, sizeof(buf), "%d", (int)lease->expiry);
	script_set_env(prefix, "expiry", buf);
}

void
script_write_params(char *prefix, struct client_lease *lease)
{
	size_t		 fn_len = 0, sn_len = 0, pr_len = 0;
	struct imsg_hdr	 hdr;
	struct buf	*buf;
	int		 i;

	if (lease->filename != NULL)
		fn_len = strlen(lease->filename);
	if (lease->server_name != NULL)
		sn_len = strlen(lease->server_name);
	if (prefix != NULL)
		pr_len = strlen(prefix);

	hdr.code = IMSG_SCRIPT_WRITE_PARAMS;
	hdr.len = sizeof(hdr) + sizeof(struct client_lease) +
	    sizeof(size_t) + fn_len + sizeof(size_t) + sn_len +
	    sizeof(size_t) + pr_len;

	for (i = 0; i < 256; i++)
		hdr.len += sizeof(int) + lease->options[i].len;

	scripttime = time(NULL);

	buf = buf_open(hdr.len);

	buf_add(buf, &hdr, sizeof(hdr));
	buf_add(buf, lease, sizeof(struct client_lease));
	buf_add(buf, &fn_len, sizeof(fn_len));
	buf_add(buf, lease->filename, fn_len);
	buf_add(buf, &sn_len, sizeof(sn_len));
	buf_add(buf, lease->server_name, sn_len);
	buf_add(buf, &pr_len, sizeof(pr_len));
	buf_add(buf, prefix, pr_len);

	for (i = 0; i < 256; i++) {
		buf_add(buf, &lease->options[i].len,
		    sizeof(lease->options[i].len));
		buf_add(buf, lease->options[i].data,
		    lease->options[i].len);
	}

	buf_close(privfd, buf);
}

int
script_go(void)
{
	struct imsg_hdr	 hdr;
	struct buf	*buf;
	int		 ret;

	scripttime = time(NULL);

	hdr.code = IMSG_SCRIPT_GO;
	hdr.len = sizeof(struct imsg_hdr);

	buf = buf_open(hdr.len);

	buf_add(buf, &hdr, sizeof(hdr));
	buf_close(privfd, buf);

	bzero(&hdr, sizeof(hdr));
	buf_read(privfd, &hdr, sizeof(hdr));
	if (hdr.code != IMSG_SCRIPT_GO_RET)
		error("unexpected msg type %u", hdr.code);
	if (hdr.len != sizeof(hdr) + sizeof(int))
		error("received corrupted message");
	buf_read(privfd, &ret, sizeof(ret));

	return (ret);
}

int
priv_script_go(void)
{
	char *scriptName, *argv[2], **envp;
	int pid, wpid, wstatus;

	scripttime = time(NULL);

	scriptName = config->script_name;
	envp = client->scriptEnv;

	argv[0] = scriptName;
	argv[1] = NULL;

	pid = fork();
	if (pid < 0) {
		error("fork: %m");
		wstatus = 0;
	} else if (pid) {
		do {
			wpid = wait(&wstatus);
		} while (wpid != pid && wpid > 0);
		if (wpid < 0) {
			error("wait: %m");
			wstatus = 0;
		}
	} else {
		execve(scriptName, argv, envp);
		error("execve (%s, ...): %m", scriptName);
	}

	script_flush_env();

	return (WEXITSTATUS(wstatus));
}

void
script_set_env(const char *prefix, const char *name, const char *value)
{
	int i, j, namelen;

	namelen = strlen(name);

	for (i = 0; client->scriptEnv[i]; i++)
		if (strncmp(client->scriptEnv[i], name, namelen) == 0 &&
		    client->scriptEnv[i][namelen] == '=')
			break;

	if (client->scriptEnv[i])
		/* Reuse the slot. */
		free(client->scriptEnv[i]);
	else {
		/* New variable.  Expand if necessary. */
		if (i >= client->scriptEnvsize - 1) {
			char **newscriptEnv;
			int newscriptEnvsize = client->scriptEnvsize + 50;

			newscriptEnv = realloc(client->scriptEnv,
			    newscriptEnvsize);
			if (newscriptEnv == NULL) {
				free(client->scriptEnv);
				client->scriptEnv = NULL;
				client->scriptEnvsize = 0;
				error("script_set_env: no memory for variable");
			}
			client->scriptEnv = newscriptEnv;
			client->scriptEnvsize = newscriptEnvsize;
		}
		/* need to set the NULL pointer at end of array beyond
		   the new slot. */
		client->scriptEnv[i + 1] = NULL;
	}
	/* Allocate space and format the variable in the appropriate slot. */
	client->scriptEnv[i] = malloc(strlen(prefix) + strlen(name) + 1 +
	    strlen(value) + 1);
	if (client->scriptEnv[i] == NULL)
		error("script_set_env: no memory for variable assignment");

	/* No `` or $() command substitution allowed in environment values! */
	for (j = 0; j < strlen(value); j++)
		switch (value[j]) {
		case '`':
		case '$':
			error("illegal character (%c) in value '%s'", value[j],
			    value);
			/* not reached */
		}
	snprintf(client->scriptEnv[i], strlen(prefix) + strlen(name) +
	    1 + strlen(value) + 1, "%s%s=%s", prefix, name, value);
}

void
script_flush_env(void)
{
	int i;

	for (i = 0; client->scriptEnv[i]; i++) {
		free(client->scriptEnv[i]);
		client->scriptEnv[i] = NULL;
	}
	client->scriptEnvsize = 0;
}

int
dhcp_option_ev_name(char *buf, size_t buflen, const struct option *option)
{
	int i;

	for (i = 0; option->name[i]; i++) {
		if (i + 1 == buflen)
			return 0;
		if (option->name[i] == '-')
			buf[i] = '_';
		else
			buf[i] = option->name[i];
	}

	buf[i] = 0;
	return 1;
}

void
d1788 202
@


1.157
log
@Revert r1.155. Routing breaks if dhclient-script flushes the
interface's routes when the interface is down.

Prevents floods of RTM_MISS messages on 'ifconfig down'. And might
fix the vpn related failures pirofti@@ is seeing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.156 2012/09/18 09:34:09 krw Exp $	*/
d1433 1
a1433 2
			    pretty_print_option(i, lease->options[i].data,
			    lease->options[i].len, 1, 1));
d1503 3
a1505 3
	u_int8_t dbuf[1500];
	int i, len = 0;
	char tbuf[128];
d1537 1
d1539 17
a1555 1
		u_int8_t *dp = NULL;
d1557 13
a1569 26
		if (config->defaults[i].len) {
			if (lease->options[i].len) {
				switch (config->default_actions[i]) {
				case ACTION_IGNORE:
					/* handled below */
					break;
				case ACTION_DEFAULT:
					dp = lease->options[i].data;
					len = lease->options[i].len;
					break;
				case ACTION_SUPERSEDE:
supersede:
					dp = config->defaults[i].data;
					len = config->defaults[i].len;
					break;
				case ACTION_PREPEND:
					len = config->defaults[i].len +
					    lease->options[i].len;
					if (len >= sizeof(dbuf)) {
						warning("no space to %s %s",
						    "prepend option",
						    dhcp_options[i].name);
						goto supersede;
					}
					dp = dbuf;
					memcpy(dp,
d1571 18
a1588 20
					    config->defaults[i].len);
					memcpy(dp +
					    config->defaults[i].len,
					    lease->options[i].data,
					    lease->options[i].len);
					dp[len] = '\0';
					break;
				case ACTION_APPEND:
					len = config->defaults[i].len +
					    lease->options[i].len;
					if (len >= sizeof(dbuf)) {
						warning("no space to %s %s",
						    "append option",
						    dhcp_options[i].name);
						goto supersede;
					}
					dp = dbuf;
					memcpy(dp, lease->options[i].data,
					    lease->options[i].len);
					memcpy(dp + lease->options[i].len,
d1590 9
a1598 6
					    config->defaults[i].len);
					dp[len] = '\0';
				}
			} else {
				dp = config->defaults[i].data;
				len = config->defaults[i].len;
d1600 1
a1600 5
		} else if (lease->options[i].len) {
			len = lease->options[i].len;
			dp = lease->options[i].data;
		} else {
			len = 0;
d1602 1
a1602 5
		if (len && config->default_actions[i] == ACTION_IGNORE) {
			len = 0;
		}
		if (len) {
			char name[256];
d1604 2
a1605 8
			if (dhcp_option_ev_name(name, sizeof(name),
			    &dhcp_options[i]))
				script_set_env(prefix, name,
				    pretty_print_option(i, dp, len, 0, 0));
		}
	}
	snprintf(tbuf, sizeof(tbuf), "%d", (int)lease->expiry);
	script_set_env(prefix, "expiry", tbuf);
d1837 1
a1837 2
	opbuf = pretty_print_option(option, l->options[option].data,
	    l->options[option].len, 0, 0);
@


1.156
log
@Don't accept leases that offer a subnet that is already configured
on an interface. Crude hammer that may be refined as needed.

Feedback from tedu@@, beck@@, sthen@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.155 2012/09/17 20:30:17 krw Exp $	*/
a245 4
			} else if (client->active) {
				script_init("FAIL");
				script_write_params("old_", client->active);
				script_go();
a263 1
	script_write_params("old_", client->active);
a264 1
	sleep(2);
@


1.155
log
@When a link is lost, call dhclient-script with reason "FAIL". This
does the resolv.conf dance and removes 'dead' routes, rather than
leaving these droppings behind.

When dhclient is exiting after calling dhclient-script with "FAIL",
give the script a couple of seconds to finish. Also pass the lease
parameters (old_*) to dhclient-script so routes can be cleaned up
in this path too.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.154 2012/09/01 19:02:27 krw Exp $	*/
d760 7
@


1.154
log
@Nuke a static global I can't get my head around - interfaces_invalidated.
Since reinitialize_interface() was simply setting interfaces_invalidated
to 0, nuke it too!

Always update ifi->linkstat in dispatch() loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.153 2012/08/31 02:36:11 krw Exp $	*/
d246 4
d268 1
d270 1
@


1.153
log
@Nuke a bunch of annoying "/* Send a packet. */" comments above
invocations to send_packet(), and similiar combinations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.152 2012/08/26 23:33:29 krw Exp $	*/
a683 1
	reinitialize_interface();
a1004 1
				reinitialize_interface();
@


1.152
log
@Junk global cur_time, and use time(NULL) or local variables where
time is checked multiple times. Add a set_timeout_interval() function
to allow setting a timeout based on an interval from current time.

Fixes issues with initial startup where the global cur_time was
always old and caused initial DHCPDISCOVER or DHCPREQUEST packets
to be sent multiple times. And probably other timeout related
oddities.

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.151 2012/08/22 00:14:42 tedu Exp $	*/
a489 1
	/* Send out the first DHCPREQUEST packet. */
a508 2
	/* Add an immediate timeout to cause the first DHCPDISCOVER packet
	   to go out. */
a583 1
	/* Add an immediate timeout to send the first DHCPREQUEST packet. */
a712 1
	/* Send the first packet immediately. */
a953 1
	/* Send out a packet. */
a1145 1
	/* Send out a packet. */
a1157 1
	/* Send out a packet. */
@


1.151
log
@add ignore keyword to conf file, allowing one to ignore unwanted info
from the server without necessarily speciyfing a supersede value
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.150 2012/08/21 00:29:32 krw Exp $	*/
a68 2
time_t cur_time;

d221 1
a221 1
		if (scripttime == 0 || cur_time < scripttime + 10)
a325 1
	time(&cur_time);
d487 1
a487 1
	client->first_sending = cur_time;
d507 1
a507 1
	client->first_sending = cur_time;
d523 1
d555 2
d595 1
d644 2
d686 1
a686 1
	    (long long)(client->active->renewal - cur_time));
d713 1
a713 1
	client->first_sending = cur_time;
d790 1
a790 1
	if (stop_selecting <= cur_time)
d903 1
d906 2
d962 1
a962 1
	set_timeout(cur_time + client->interval, send_discover);
d976 1
d986 1
d1000 1
a1000 2
				if (cur_time <
				    client->active->renewal) {
d1052 1
a1052 1
	set_timeout(cur_time + config->retry_interval, state_init);
d1061 1
d1064 2
d1067 1
a1067 1
	interval = cur_time - client->first_sending;
d1155 1
a1155 1
	set_timeout(cur_time + client->interval, send_request);
@


1.150
log
@Don't abandon time_t precision for intervals. Use (long long) and %lld when
printing, rather than (int) and %d. Follows idiom used for 64-bit size_t and
off_t.

Suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.149 2012/08/18 18:14:41 krw Exp $	*/
d1537 3
d1593 3
@


1.149
log
@Don't store a time_t into an int. Make the variable time_t.

Part of larger time_t rectification diff from guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.148 2012/08/18 15:27:56 krw Exp $	*/
d681 1
a681 1
	note("bound to %s -- renewal in %d seconds.",
d683 1
a683 1
	    (int)(client->active->renewal - cur_time));
d995 3
a997 3
					note("bound: renewal in %d seconds.",
					    (int)(client->active->renewal -
					    cur_time));
@


1.148
log
@Don't try to printf() a time_t value with %d. Cast to (int) just
in case time_t ever changes size. Values in these cases are intervals,
i.e. (time_t - time_t) so int/%d will be fine.

Part of larger time_t rectification diff from guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.147 2012/08/18 00:20:01 krw Exp $	*/
d723 1
a723 1
	int stop_selecting;
@


1.147
log
@Update global cur_time after exiting poll() and before calling the
state engine for packet processing. Time may have passed! Use cur_time
in routing message processing.

Makes sense to todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.146 2012/07/09 16:21:21 krw Exp $	*/
d683 1
a683 1
	    client->active->renewal - cur_time);
d996 2
a997 2
					    client->active->renewal -
					    cur_time);
@


1.146
log
@Terminate with extreme prejudice the multiple timeout queuing
mechanism that was a holdover from when dhclient handled multiple
interfaces at once. There is only one timeout possible at a time.

Also move calculation of current time to just before check to see
if the timeout has expired.

ok beck@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.145 2012/06/24 16:01:18 krw Exp $	*/
a165 1
	time_t t = time(NULL);
d223 1
a223 1
		if (scripttime == 0 || t < scripttime + 10)
@


1.145
log
@Nuke interface_link_status() (check media status only) and use
interface_status() (check IFF_UP|IFF_RUNNING and media status). The
interface is forced up when dhclient starts so the flags should be
correct.

Thanks to guenther@@ for pointing out the original raison d'etre of
the difference between the two.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.144 2012/06/22 00:08:43 krw Exp $	*/
d473 1
a473 5
	cancel_timeout(state_init);
	cancel_timeout(state_selecting);
	cancel_timeout(state_bound);
	cancel_timeout(send_discover);
	cancel_timeout(send_request);
d530 1
a530 2
	cancel_timeout(state_selecting);
	cancel_timeout(send_discover);
d612 1
a612 1
	cancel_timeout(send_request);
d679 2
a680 2
	/* Set up a timeout to start the renewal process. */
	add_timeout(client->active->renewal, state_bound);
d791 1
a791 2
		add_timeout(stop_selecting, state_selecting);
		cancel_timeout(send_discover);
d887 1
a887 1
	cancel_timeout(send_request);
d957 1
a957 1
	add_timeout(cur_time + client->interval, send_discover);
d999 1
a999 1
					add_timeout(client->active->renewal,
d1046 1
a1046 1
	add_timeout(cur_time + config->retry_interval, state_init);
d1074 1
a1074 1
		cancel_timeout(send_request);
d1146 1
a1146 1
	add_timeout(cur_time + client->interval, send_request);
@


1.144
log
@Set state to S_REBOOTING when calling state_reboot() and set state
inside state_reboot() to S_INIT when calling state_init(). Rather
than the other way around. Makes for more consistant idiom and
might reduce state confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.143 2012/06/20 21:53:51 kettenis Exp $	*/
d245 1
a245 1
			ifi->linkstat = interface_link_status(ifi->name);
d350 1
a350 1
	while (!(ifi->linkstat = interface_link_status(ifi->name))) {
@


1.143
log
@Cancel all timeouts in state_reboot(), since we can get there from any state
if a link state change happens.  Fixes a problem where we'd continue to send
(corrupted) discover packets after binding.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.142 2011/12/10 15:55:43 krw Exp $	*/
d247 1
a247 1
				client->state = S_INIT;
d418 1
a418 1
		client->state = S_INIT;
d481 1
a484 3

	/* We are in the rebooting state. */
	client->state = S_REBOOTING;
@


1.142
log
@Tweak leases file handling.

1) Write out new leases file every time a lease is obtained. i.e. don't
append 20 leases before cleaning it up.

2) Write new leases file after calling dhclient-script to implement
new info. Gets interface configured first, and makes it more likely
the leases file reflects most current configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.141 2011/05/11 14:38:36 krw Exp $	*/
d471 8
@


1.141
log
@Make dhclient more friendly to sequential option processing by
always starting DHCP packet options with DHO_DHCP_MESSAGE_TYPE. Now
DHCP-specific options always come after the option identifying the
packet as DHCP rather than BOOTP. Makes at least Nortel NetIP DHCP
server happier. Clean up some code and parameter passing.

Closes PR#6543, as confirmed by original submitter and patch
tester Len Zaifman. Thanks!

ok matthew@@ (who hates the ISC-like code)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.140 2011/04/17 20:06:08 phessler Exp $	*/
a659 3
	/* Write out the new lease. */
	write_client_lease(client->new, 0);

d675 3
d1384 7
a1390 2
	for (lp = client->leases; lp; lp = lp->next)
		write_client_lease(lp, 1);
d1392 1
a1392 1
		write_client_lease(client->active, 1);
d1400 1
a1400 1
write_client_lease(struct client_lease *lease, int rewrite)
a1401 1
	static int leases_written;
a1403 7

	if (!rewrite) {
		if (leases_written++ > 20) {
			rewrite_client_leases();
			leases_written = 0;
		}
	}
@


1.140
log
@by default we ignore unknown dhcp server options, so don't bother
warning unless we ask dhclient to reject leases with unknown options

OK krw@@
(this was lost in my tree for even longer)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.139 2011/04/04 11:14:52 krw Exp $	*/
d1198 1
a1198 2
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
d1266 1
a1266 2
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
d1333 1
a1333 2
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
@


1.139
log
@Dump some useless calls to dhclient-script. i.e. MEDIUM, PREINIT,
ARPSEND, ARPCHECK. Drop support for 'media', 'medium' and 'alias'
specifications in dhclient.conf. Old leases still parse but these
options now have no effect.

Be more polite and decline all offers we don't accept. Fix a IMSG
length check.

Many expressions of support at various bars.

ok henning@@ deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.138 2011/03/27 12:15:46 krw Exp $	*/
d1941 2
a1942 1
		warning("unknown dhcp option value 0x%x", option);
@


1.138
log
@Fix interval handling. Start at initial_interval instead of
exponentially backed off initial_interval. Don't hallucinate that
we can send ARP packets without waiting. Don't claim to be waiting
for ARP packets when not doing so. Correctly detect expiry of
selecting period. Speeds up negotiations.

Tested on various dhcp servers by Martin Pelika, ian@@, and David
Coppa. And works at Starbucks and a mall for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.137 2010/10/15 09:51:15 jsg Exp $	*/
d208 1
a208 2
		if (l != NULL || (client->alias &&
		    addr_eq(a, client->alias->address)))
d266 1
a266 3
	script_init("FAIL", NULL);
	if (client->alias)
		script_write_params("alias_", client->alias);
a387 5
	priv_script_init("PREINIT", NULL);
	if (client->alias)
		priv_script_write_params("alias_", client->alias);
	priv_script_go();

a491 3
	/* Zap the medium list... */
	client->medium = NULL;

a536 3

		/* Check to see if we got an ARPREPLY for the address
		   in this particular lease. */
a537 12
			script_init("ARPCHECK", lp->medium);
			script_write_params("check_", lp);

			/* If the ARPCHECK code detects another
			   machine using the offered address, it exits
			   nonzero.  We need to send a DHCPDECLINE and
			   toss the lease. */
			if (script_go()) {
				make_decline(lp);
				send_decline();
				goto freeit;
			}
a538 1
			picked->next = NULL;
d540 2
a541 1
freeit:
d555 2
a659 3
	/* Remember the medium. */
	client->new->medium = client->medium;

d666 1
a666 2
	    (client->state == S_REBOOTING ? "REBOOT" : "REBIND"))),
	    client->new->medium);
a669 2
	if (client->alias)
		script_write_params("alias_", client->alias);
d723 1
a723 1
	int arp_timeout_needed, stop_selecting;
a762 13
	/* Record the medium under which this lease was offered. */
	lease->medium = client->medium;

	/* Send out an ARP Request for the offered IP address. */
	script_init("ARPSEND", lease->medium);
	script_write_params("check_", lease);
	/* If the script can't send an ARP request without waiting,
	   we'll be waiting when we do the ARPCHECK, so don't wait now. */
	if (script_go())
		arp_timeout_needed = 0;
	else
		arp_timeout_needed = 2;

a771 8
		/* If we already have an offer, and arping for this
		   offer would take us past the selection timeout,
		   then don't extend the timeout - just hope for the
		   best. */
		if (client->offered_leases &&
		    (cur_time + arp_timeout_needed) > stop_selecting)
			arp_timeout_needed = 0;

a783 6
	/* If we're supposed to stop selecting before we've had time
	   to wait for the ARPREPLY, add some delay to wait for
	   the ARPREPLY. */
	if (stop_selecting - cur_time < arp_timeout_needed)
		stop_selecting = cur_time + arp_timeout_needed;

a912 24
	/* If we're selecting media, try the whole list before doing
	   the exponential backoff, but if we've already received an
	   offer, stop looping, because we obviously have it right. */
	if (!client->offered_leases && config->media) {
		int fail = 0;
again:
		if (client->medium) {
			client->medium = client->medium->next;
			increase = 0;
		}
		if (!client->medium) {
			if (fail)
				error("No valid media types for %s!", ifi->name);
			client->medium = config->media;
			increase = 1;
		}

		note("Trying medium \"%s\" %d", client->medium->string,
		    increase);
		script_init("MEDIUM", client->medium);
		if (script_go())
			goto again;
	}

d986 1
a986 2
			script_init("TIMEOUT",
			    client->active->medium);
a987 3
			if (client->alias)
				script_write_params("alias_",
				    client->alias);
d1043 1
a1043 3
	script_init("FAIL", NULL);
	if (client->alias)
		script_write_params("alias_", client->alias);
a1072 1
cancel:
a1078 15
	/* If we're in the reboot state, make sure the media is set up
	   correctly. */
	if (client->state == S_REBOOTING &&
	    !client->medium &&
	    client->active->medium) {
		script_init("MEDIUM", client->active->medium);

		/* If the medium we chose won't fly, go to INIT state. */
		if (script_go())
			goto cancel;

		/* Record the medium. */
		client->medium = client->active->medium;
	}

d1084 1
a1084 1
		script_init("EXPIRE", NULL);
a1085 9
		if (client->alias)
			script_write_params("alias_", client->alias);
		script_go();

		/* Now do a preinit on the interface so that we can
		   discover a new address. */
		script_init("PREINIT", NULL);
		if (client->alias)
			script_write_params("alias_", client->alias);
a1428 2
	if (lease->medium)
		fprintf(leaseFile, "  medium \"%s\";\n", lease->medium->string);
d1453 1
a1453 1
script_init(char *reason, struct string_list *medium)
d1455 1
a1455 1
	size_t		 len, mediumlen = 0;
a1458 3
	if (medium != NULL && medium->string != NULL)
		mediumlen = strlen(medium->string);

d1460 1
a1460 3
	hdr.len = sizeof(struct imsg_hdr) +
	    sizeof(size_t) + mediumlen +
	    sizeof(size_t) + strlen(reason);
a1464 3
	buf_add(buf, &mediumlen, sizeof(mediumlen));
	if (mediumlen > 0)
		buf_add(buf, medium->string, mediumlen);
d1473 1
a1473 1
priv_script_init(char *reason, char *medium)
a1496 3

	if (medium)
		script_set_env("", "medium", medium);
@


1.137
log
@Add and ignore DHCP option 66/0x42 TFTP server name.
ok krw@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.136 2010/09/24 13:44:14 claudio Exp $	*/
d498 1
a498 1
	client->interval = config->initial_interval;
d521 1
a521 1
	client->interval = config->initial_interval;
d602 1
a602 1
	client->interval = config->initial_interval;
d741 1
a741 1
	client->interval = config->initial_interval;
d844 1
a844 1
	if (stop_selecting <= 0)
@


1.136
log
@Make it possible to use "dhclient egress" to refetch a lease without
rememberingwhich interface dhclient was actually active on.
Requested by deraadt, OK deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.135 2010/06/26 20:48:45 krw Exp $	*/
d2062 1
@


1.135
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.134 2010/06/02 09:57:16 phessler Exp $	*/
d56 2
d97 1
d323 1
a323 2
	if (strlcpy(ifi->name, argv[0], IFNAMSIZ) >= IFNAMSIZ)
		error("Interface name too long");
d2197 42
@


1.134
log
@Have dhclient obey the interface's rdomain, instead of doing routes on
rdomain 0.

OK krw@@, claudio@@
sharp stick prodding from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.133 2010/03/25 18:37:36 stevesk Exp $	*/
d371 1
a371 1
			error("no such user: _dhcp");
@


1.133
log
@be more strict in check_option().

ISC dhclient had a buffer overflow:
http://www.kb.cert.org/vuls/id/410676

and while our dhclient is not vulnerable to that, it got us looking at
how the subnet mask option is handled.  this limits specific ip
address options to length 4 in conformance with RFC 2132.  discussion
started by william@@ and with input from krw@@

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.132 2009/11/12 14:18:45 jsg Exp $	*/
d339 3
d1595 2
d1611 6
@


1.132
log
@Make sure we have enough space for the trailing \0 on prepend/append
of dhcp options.

found by parfait.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.131 2009/07/19 00:18:02 stevesk Exp $	*/
d1961 18
a1987 2
	case DHO_SWAP_SERVER:
	case DHO_BROADCAST_ADDRESS:
d1993 3
a1995 3
	case DHO_DHCP_SERVER_IDENTIFIER:
		if (!ipv4addrs(opbuf)) {
			warning("Invalid IP address in option: %s", opbuf);
a2026 1
	case DHO_ROUTER_SOLICITATION_ADDRESS:
a2037 1
	case DHO_DHCP_REQUESTED_ADDRESS:
@


1.131
log
@use addr_eq() where we can; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.130 2009/06/12 20:07:35 stevesk Exp $	*/
d1668 1
a1668 1
					if (len > sizeof(dbuf)) {
d1687 1
a1687 1
					if (len > sizeof(dbuf)) {
@


1.130
log
@state_panic() tries the active then other valid leases by setting the
interface to each address and trying to ping the gateway.  This will
trigger an RTM_NEWADDR message.

routehandler() only checks for the active and alias address in
RTM_NEWADDR messages, so we can exit when state_panic() and the
message address is on client->leases.  routehandler() needs to also
check client->leases.

testing krw, 'I say commit' krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.129 2009/06/06 04:02:42 krw Exp $	*/
d806 1
a806 4
	if (lease->address.len == client->requested_address.len &&
	    !memcmp(lease->address.iabuf,
	    client->requested_address.iabuf,
	    client->requested_address.len)) {
@


1.129
log
@Nuke debug() unless DEBUG is defined. Elminates debug output from
normal operations.

Prodded by deraadt@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.128 2009/06/03 02:05:34 stevesk Exp $	*/
d199 4
a202 1
		for (l = client->active; l != NULL; l = l->next)
a204 1

d221 1
@


1.128
log
@remove unneeded ARGSUSED; ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.127 2009/05/25 00:17:40 stevesk Exp $	*/
d235 1
d239 1
d767 1
d769 1
@


1.127
log
@log the reason before we die in routehandler(); ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.126 2009/05/20 20:37:43 thib Exp $	*/
a152 1
/* ARGSUSED */
@


1.126
log
@Do not fall back to using nobody if _user is missing, but
error out.

Add a new user _rwalld for rpc.rwalld, and use that instead
of nobody, also unconditionally drop to _rwalld not only
if rpc.rwalld was started with euid 0 (as root).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.124 2009/03/10 23:19:36 krw Exp $	*/
d168 1
d189 2
a190 1
		if (sa == NULL)
d192 1
d209 3
d222 1
d228 2
a229 1
		if ((rtm->rtm_flags & RTF_UP) == 0)
d231 1
d249 2
a250 1
		    ifan->ifan_index == ifi->index)
d252 1
d264 1
a264 1
	exit(1);
@


1.125
log
@claudio has spent too much time with the mbuf macros.

switch the rtsocket message filter specification so you can or the macros
converting the routing socket message types into the mask used by the
filter. ie:

-       ROUTE_SETFILTER(rtfilter, RTM_NEWADDR);
-       ROUTE_SETFILTER(rtfilter, RTM_DELADDR);
-       ROUTE_SETFILTER(rtfilter, RTM_IFINFO);
-       ROUTE_SETFILTER(rtfilter, RTM_IFANNOUNCE);
+       rtfilter = ROUTE_FILTER(RTM_NEWADDR) | ROUTE_FILTER(RTM_DELADDR) |
+           ROUTE_FILTER(RTM_IFINFO) | ROUTE_FILTER(RTM_IFANNOUNCE);

there's a manpage change coming.

ok claudio@@
@
text
@d352 2
a353 5
	if ((pw = getpwnam("_dhcp")) == NULL) {
		warning("no such user: _dhcp, falling back to \"nobody\"");
		if ((pw = getpwnam("nobody")) == NULL)
			error("no such user: nobody");
	}
@


1.124
log
@Add 6-byte MAC address to the log entries for DHCP ACK/NAK/OFFER.
Log the packets before checking the client state. Makes it easy to
find MACs for 'surprise' DHCP servers.

Positive comments from mbalmer@@, jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.123 2009/02/01 12:10:14 miod Exp $	*/
d382 2
a383 4
	ROUTE_SETFILTER(rtfilter, RTM_NEWADDR);
	ROUTE_SETFILTER(rtfilter, RTM_DELADDR);
	ROUTE_SETFILTER(rtfilter, RTM_IFINFO);
	ROUTE_SETFILTER(rtfilter, RTM_IFANNOUNCE);
@


1.123
log
@Let this compile with gcc2.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.122 2009/01/28 17:05:53 dlg Exp $	*/
a604 3
	if (client->xid != client->packet.xid)
		return;

a610 2
	note("DHCPACK from %s", piaddr(client_addr));

a741 3
	if (client->xid != client->packet.xid)
		return;

a744 2
	note("%s from %s", name, piaddr(client_addr));

a914 3
	if (client->xid != client->packet.xid)
		return;

a919 2

	note("DHCPNAK from %s", piaddr(client_addr));
@


1.122
log
@use claudios new rtsocket filters to restrict which messages on the route
socket dhclient will get.

ja ja claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.121 2009/01/10 16:33:47 claudio Exp $	*/
d262 1
a266 1
	int rtfilter;
@


1.121
log
@Use the kernel set ifam_hdrlen so that ABI changes won't cause older
binaries to stop working.
OK krw@@, michele@@, henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.120 2008/06/07 03:22:26 deraadt Exp $	*/
d266 1
d381 9
@


1.120
log
@stop spurious "got link" which nooone noticed, but everyone should have; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.119 2008/05/26 03:11:48 deraadt Exp $	*/
d183 2
a184 1
		if (findproto((char *)(ifam + 1), ifam->ifam_addrs) != AF_INET)
d186 2
a187 1
		sa = get_ifa((char *)(ifam + 1), ifam->ifam_addrs);
d211 2
a212 1
		if (findproto((char *)(ifam + 1), ifam->ifam_addrs) != AF_INET)
@


1.119
log
@If an interface has no link at startup, try to force it up, and then
give it about 4 seconds of (silent) grace period before doing the verbose
search for a link...
tested by various developers who got burned a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.118 2008/05/09 05:19:14 reyk Exp $	*/
d341 1
a341 1
	if (i >= 0)
@


1.118
log
@- don't give up when the link is not available on startup: dhclient
goes to background and listens on the routing socket for link to come
up before it retries.
- renew the lease whenever the link was lost and becomes active again.
- listen for link state changes on non-ethernet devices like wireless,
the link state becomes active when the wireless has been associated to
the AP and becomes active. this helps to automatically renew the lease
when the user is roaming.

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.117 2008/03/12 13:31:22 hugh Exp $	*/
d322 14
a335 3
	if (!(ifi->linkstat = interface_link_status(ifi->name))) {
		fprintf(stderr, "%s: no link ...", ifi->name);
		if (config->link_timeout == 0) {
a338 1
		fflush(stderr);
d340 2
a341 9
		while (!(ifi->linkstat = interface_link_status(ifi->name))) {
			fprintf(stderr, ".");
			fflush(stderr);
			if (++i > config->link_timeout) {
				fprintf(stderr, " sleeping\n");
				goto dispatch;
			}
			sleep(1);
		}
a342 1
	}
@


1.117
log
@Code was not passing script exit status; fix with macro.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.116 2007/10/16 20:19:26 sobrado Exp $	*/
d157 1
d220 13
d322 1
a322 3
	if (!interface_link_status(ifi->name)) {
		int linkstat = interface_link_forceup(ifi->name);

d325 2
a326 4
			fprintf(stderr, " giving up\n");
			if (linkstat == 0)
				interface_link_forcedown(ifi->name);
			exit(1);
d330 1
a330 1
		while (!interface_link_status(ifi->name)) {
d334 2
a335 4
				fprintf(stderr, " giving up\n");
				if (linkstat == 0)
					interface_link_forcedown(ifi->name);
				exit(1);
d342 1
d395 5
a399 2
	client->state = S_INIT;
	state_reboot();
@


1.116
log
@sync the synopsis and usage of commands

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.115 2007/09/02 15:19:23 deraadt Exp $	*/
d1810 1
a1810 1
	return (wstatus & 0xff);
@


1.115
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.114 2007/08/14 15:29:18 stevesk Exp $	*/
d400 2
a401 2
	fprintf(stderr, "usage: %s [-dqu] ", __progname);
	fprintf(stderr, "[-c conffile] [-l leasefile] interface\n");
@


1.114
log
@make default_lease_time a #define; ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.113 2007/07/18 14:19:48 stevesk Exp $	*/
d1574 1
a1574 1
		    malloc(client->scriptEnvsize * sizeof(char *));
@


1.113
log
@eliminate duplicate code to open lease file and just open at
startup; ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.112 2007/06/02 01:29:11 pvalchev Exp $	*/
d63 3
a65 1
#define	CLIENT_PATH "PATH=/usr/bin:/usr/sbin:/bin:/sbin"
a67 1
time_t default_lease_time = 43200; /* 12 hours... */
a82 2
#define TIME_MAX 2147483647

d605 1
a605 1
		client->new->expiry = default_lease_time;
@


1.112
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.111 2007/02/25 18:10:43 krw Exp $	*/
d102 1
d355 2
a1462 2
FILE *leaseFile;

d1468 5
a1472 8
	if (!leaseFile) {
		leaseFile = fopen(path_dhclient_db, "w");
		if (!leaseFile)
			error("can't create %s: %m", path_dhclient_db);
	} else {
		fflush(leaseFile);
		rewind(leaseFile);
	}
d1503 2
a1504 5
	if (!leaseFile) {	/* XXX */
		leaseFile = fopen(path_dhclient_db, "w");
		if (!leaseFile)
			error("can't create %s: %m", path_dhclient_db);
	}
@


1.111
log
@No point in using zero'd fields in the parsed options. Use the options
in the lease, whence the parsed info was moved.

Fixes "Bogus servername" messages when processing an offer and stops
bogus filename info from being stored in the lease. Found while
testing a Tucson hotel's dhcp service.

ok @@stevesk "looks good" henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.110 2007/02/25 16:27:20 stevesk Exp $	*/
d2091 1
d2093 3
a2095 2
				op += 4;
				opleft -= 4;
@


1.110
log
@remove unused/dangling prototypes and comment reference;
from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.109 2007/02/13 21:54:22 stevesk Exp $	*/
d857 2
a858 2
	if ((!options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)) &&
d877 2
a878 2
	if ((!options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)) &&
@


1.109
log
@move includes only needed in dhclient.c; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.108 2007/02/13 15:21:59 stevesk Exp $	*/
a570 4
/*
 * state_requesting is called when we receive a DHCPACK message after
 * having sent out one or more DHCPREQUEST packets.
 */
@


1.108
log
@error check socket() return; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.107 2007/01/29 13:12:56 krw Exp $	*/
d57 2
@


1.107
log
@Don't malloc memory to store option data in leases, just appropriate
the malloc'd memory from the parsed option buffer since it would be
thrown away after the copy anyway.

'looks sane' millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.106 2007/01/27 22:05:24 krw Exp $	*/
d360 2
a361 1
	routefd = socket(PF_ROUTE, SOCK_RAW, 0);
@


1.106
log
@We only poll on the bpf fd and the routing socket fd. No need for
complex list code to keep track. So nuke it.

Also eliminate unnecessary variable ('dead') that means 'rfdesc is
closed'. Just set rfdesc to -1 when it is closed and use that.

As suggested by millert@@ and claudio@@, don't bother setting revents
members to zero since poll() does that.

Np functional change, just less code.

'looks good' claudio@@  'I like where this is going' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.105 2007/01/25 01:21:04 krw Exp $	*/
d842 3
a844 12
			lease->options[i].data = malloc(options[i].len + 1);
			if (!lease->options[i].data) {
				warning("dhcpoffer: no memory for option %d", i);
				free_client_lease(lease);
				return (NULL);
			} else {
				memcpy(lease->options[i].data, options[i].data,
				    options[i].len);
				lease->options[i].len = options[i].len;
				lease->options[i].data[lease->options[i].len] =
				    0;
			}
a845 1
				/* ignore a bogus lease offer */
@


1.105
log
@Cleanup some more code. Eliminate dhcp(), bootp(), parse_options() by
moving the minimal code into do_packet(). Eliminate repeated code for
checking the client hardware address and the reject list by putting
those checks into do_packet as well.

No functional change, just much easier to read.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.104 2007/01/16 20:22:20 krw Exp $	*/
d74 1
a74 1
int routefd;
a87 1
void		 routehandler(struct protocol *);
d153 1
a153 1
routehandler(struct protocol *p)
d360 1
a360 2
	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) != -1)
		add_protocol("AF_ROUTE", routefd, routehandler);
@


1.104
log
@More cleanup. Eliminate 'struct packet' by cleverly passing as
parameters just those things actually needed and using existing
structs and information. No functional change.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.103 2007/01/11 02:36:29 krw Exp $	*/
d579 1
a579 6
	/* If we're not receptive to an offer right now, or if the offer
	   has an unrecognizable transaction id, then just drop it. */
	if (client->xid != client->packet.xid ||
	    (ifi->hw_address.hlen != client->packet.hlen) ||
	    (memcmp(ifi->hw_address.haddr,
	    client->packet.chaddr, client->packet.hlen)))
a712 56
bootp(struct iaddr client_addr, struct option_data *options)
{
	struct iaddrlist *ap;

	if (client->packet.op != BOOTREPLY)
		return;

	/* If there's a reject list, make sure this packet's sender isn't
	   on it. */
	for (ap = config->reject_list;
	    ap; ap = ap->next) {
		if (addr_eq(client_addr, ap->addr)) {
			note("BOOTREPLY from %s rejected.", piaddr(ap->addr));
			return;
		}
	}
	dhcpoffer(client_addr, options);
}

void
dhcp(struct iaddr client_addr, struct option_data *options)
{
	struct iaddrlist *ap;
	void (*handler)(struct iaddr, struct option_data *);
	char *type;

	switch (options[DHO_DHCP_MESSAGE_TYPE].data[0]) {
	case DHCPOFFER:
		handler = dhcpoffer;
		type = "DHCPOFFER";
		break;
	case DHCPNAK:
		handler = dhcpnak;
		type = "DHCPNACK";
		break;
	case DHCPACK:
		handler = dhcpack;
		type = "DHCPACK";
		break;
	default:
		return;
	}

	/* If there's a reject list, make sure this packet's sender isn't
	   on it. */
	for (ap = config->reject_list;
	    ap; ap = ap->next) {
		if (addr_eq(client_addr, ap->addr)) {
			note("%s from %s rejected.", type, piaddr(ap->addr));
			return;
		}
	}
	(*handler)(client_addr, options);
}

void
d721 4
a724 7
	/* If we're not receptive to an offer right now, or if the offer
	   has an unrecognizable transaction id, then just drop it. */
	if (client->state != S_SELECTING ||
	    client->xid != client->packet.xid ||
	    (ifi->hw_address.hlen != client->packet.hlen) ||
	    (memcmp(ifi->hw_address.haddr,
	    client->packet.chaddr, client->packet.hlen)))
a728 1

d909 1
a909 6
	/* If we're not receptive to an offer right now, or if the offer
	   has an unrecognizable transaction id, then just drop it. */
	if (client->xid != client->packet.xid ||
	    (ifi->hw_address.hlen != client->packet.hlen) ||
	    (memcmp(ifi->hw_address.haddr,
	    client->packet.chaddr, client->packet.hlen)))
@


1.103
log
@Since bootp_packet_handler is always set to do_packet before we
process any packets, eliminate that abstraction and just call
do_packet directly.

No functional change.

ok stevesk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.102 2007/01/04 22:30:57 krw Exp $	*/
d575 1
a575 1
dhcpack(struct packet *packet)
d593 1
a593 1
	note("DHCPACK from %s", piaddr(packet->client_addr));
d595 1
a595 1
	lease = packet_to_lease(packet);
d718 1
a718 1
bootp(struct packet *packet)
d729 1
a729 1
		if (addr_eq(packet->client_addr, ap->addr)) {
d734 1
a734 1
	dhcpoffer(packet);
d738 1
a738 1
dhcp(struct packet *packet)
d741 1
a741 1
	void (*handler)(struct packet *);
d744 1
a744 1
	switch (packet->packet_type) {
d765 1
a765 1
		if (addr_eq(packet->client_addr, ap->addr)) {
d770 1
a770 1
	(*handler)(packet);
d774 1
a774 1
dhcpoffer(struct packet *packet)
d779 2
a780 2
	char *name = packet->options[DHO_DHCP_MESSAGE_TYPE].len ?
	    "DHCPOFFER" : "BOOTREPLY";
d791 1
a791 1
	note("%s from %s", name, piaddr(packet->client_addr));
d797 1
a797 1
		if (!packet->options[config->required_options[i]].len) {
d814 1
a814 1
	lease = packet_to_lease(packet);
d822 1
a822 1
	if (!packet->options[DHO_DHCP_MESSAGE_TYPE].len)
d892 1
a892 1
packet_to_lease(struct packet *packet)
d908 2
a909 3
		if (packet->options[i].len) {
			lease->options[i].data =
			    malloc(packet->options[i].len + 1);
d915 3
a917 5
				memcpy(lease->options[i].data,
				    packet->options[i].data,
				    packet->options[i].len);
				lease->options[i].len =
				    packet->options[i].len;
d935 2
a936 2
	if ((!packet->options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)) &&
d955 2
a956 2
	if ((!packet->options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)) &&
d965 1
a965 2
		memcpy(lease->filename, client->packet.file,
		    DHCP_FILE_LEN);
d972 1
a972 1
dhcpnak(struct packet *packet)
d988 1
a988 1
	note("DHCPNAK from %s", piaddr(packet->client_addr));
@


1.102
log
@Eliminate the 'len' parameter from send_packet() since it always
contains the global value client->packet_length. Use
client->packet_length. No functional change.

Suggested by stevesk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.101 2007/01/04 22:17:48 krw Exp $	*/
a384 2

	bootp_packet_handler = do_packet;
@


1.101
log
@Another round of cleanup. There is only one instance of struct
dhcp_packet and it is contained in the global *client. So don't pass
around pointers to a struct that contains a pointer to the dhcp_packet
instance. Just use the global client->packet. Eliminate unused struct
packet members and parameter lists accordingly.

No functional change.

Suggestions by stevesk@@. ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.100 2006/12/28 20:04:22 deraadt Exp $	*/
d1097 1
a1097 2
	send_packet(client->packet_length, inaddr_any, &sockaddr_broadcast,
	    NULL);
d1317 1
a1317 1
	send_packet(client->packet_length, from, &destination, NULL);
d1330 1
a1330 2
	send_packet(client->packet_length, inaddr_any, &sockaddr_broadcast,
	    NULL);
@


1.100
log
@please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.99 2006/12/28 01:32:10 stevesk Exp $	*/
d583 2
a584 2
	if (client->xid != packet->raw->xid ||
	    (ifi->hw_address.hlen != packet->raw->hlen) ||
d586 1
a586 1
	    packet->raw->chaddr, packet->raw->hlen)))
d724 1
a724 1
	if (packet->raw->op != BOOTREPLY)
d787 2
a788 2
	    client->xid != packet->raw->xid ||
	    (ifi->hw_address.hlen != packet->raw->hlen) ||
d790 1
a790 1
	    packet->raw->chaddr, packet->raw->hlen)))
d808 1
a808 1
		if (lease->address.len == sizeof(packet->raw->yiaddr) &&
d810 1
a810 1
		    &packet->raw->yiaddr, lease->address.len)) {
d935 3
a937 2
	lease->address.len = sizeof(packet->raw->yiaddr);
	memcpy(lease->address.iabuf, &packet->raw->yiaddr, lease->address.len);
d942 1
a942 1
	    packet->raw->sname[0]) {
d949 2
a950 1
		memcpy(lease->server_name, packet->raw->sname, DHCP_SNAME_LEN);
d962 1
a962 1
	    packet->raw->file[0]) {
d970 2
a971 1
		memcpy(lease->filename, packet->raw->file, DHCP_FILE_LEN);
d982 2
a983 2
	if (client->xid != packet->raw->xid ||
	    (ifi->hw_address.hlen != packet->raw->hlen) ||
d985 1
a985 1
	    packet->raw->chaddr, packet->raw->hlen)))
d1097 2
a1098 2
	(void)send_packet(&client->packet, client->packet_length,
	    inaddr_any, &sockaddr_broadcast, NULL);
d1318 1
a1318 2
	(void) send_packet(&client->packet, client->packet_length,
	    from, &destination, NULL);
d1331 2
a1332 2
	(void) send_packet(&client->packet, client->packet_length,
	    inaddr_any, &sockaddr_broadcast, NULL);
@


1.99
log
@parenthesis not needed here; consistent with usage in other areas.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.98 2006/12/28 01:10:46 stevesk Exp $	*/
d2212 1
@


1.98
log
@small knf (extra space, newline)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.97 2006/12/28 00:51:19 stevesk Exp $	*/
d1387 4
a1390 4
	memset(&(client->packet.ciaddr), 0, sizeof(client->packet.ciaddr));
	memset(&(client->packet.yiaddr), 0, sizeof(client->packet.yiaddr));
	memset(&(client->packet.siaddr), 0, sizeof(client->packet.siaddr));
	memset(&(client->packet.giaddr), 0, sizeof(client->packet.giaddr));
@


1.97
log
@no extra "\n" in note(); ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.96 2006/12/27 20:56:33 krw Exp $	*/
d1230 1
a1230 1
	    client->active->medium ) {
a1394 1

a2164 1

@


1.96
log
@Since we only have the single global struct interface_info, we
obviously have single global struct client_state and struct
client_config nested inside interface_info and client_state
respectively.

Pull them out to their own global variables and eliminate a bunch
(i.e. hundreds) of multi-level dereferences. Make it much nicer to
read.

No functional change.

"makes sense" henning@@

Testing stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.95 2006/12/26 21:19:52 krw Exp $	*/
d994 1
a994 1
		note("DHCPNAK with no active lease.\n");
d1186 1
a1186 1
	note("No working leases in persistent database - sleeping.\n");
@


1.95
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.94 2006/12/26 15:03:16 moritz Exp $	*/
d82 3
a84 1
struct interface_info	*ifi;
d193 1
a193 1
		for (l = ifi->client->active; l != NULL; l = l->next)
d197 2
a198 2
		if (l != NULL || (ifi->client->alias &&
		    addr_eq(a, ifi->client->alias->address)))
d232 2
a233 2
	if (ifi->client->alias)
		script_write_params("alias_", ifi->client->alias);
d279 6
a284 6
	ifi->client = calloc(1, sizeof(*(ifi->client)));
	if (ifi->client == NULL)
		error("ifi->client calloc");
	ifi->client->config = calloc(1, sizeof(*(ifi->client->config)));
	if (ifi->client->config == NULL)
		error("ifi->client->config calloc");
d311 1
a311 1
		if (ifi->client->config->link_timeout == 0) {
d322 1
a322 1
			if (++i > ifi->client->config->link_timeout) {
d357 2
a358 2
	if (ifi->client->alias)
		priv_script_write_params("alias_", ifi->client->alias);
d383 1
a383 1
	ifi->client->state = S_INIT;
d437 1
a437 1
	if (!ifi->client->active || ifi->client->active->is_bootp) {
d443 1
a443 1
	ifi->client->state = S_REBOOTING;
d448 1
a448 1
	ifi->client->xid = arc4random();
d452 4
a455 4
	make_request(ifi->client->active);
	ifi->client->destination = iaddr_broadcast;
	ifi->client->first_sending = cur_time;
	ifi->client->interval = ifi->client->config->initial_interval;
d458 1
a458 1
	ifi->client->medium = NULL;
d473 6
a478 6
	make_discover(ifi->client->active);
	ifi->client->xid = ifi->client->packet.xid;
	ifi->client->destination = iaddr_broadcast;
	ifi->client->state = S_SELECTING;
	ifi->client->first_sending = cur_time;
	ifi->client->interval = ifi->client->config->initial_interval;
d503 1
a503 1
	for (lp = ifi->client->offered_leases; lp; lp = next) {
d528 1
a528 1
	ifi->client->offered_leases = NULL;
d533 1
a533 1
		ifi->client->state = S_INIT;
d540 1
a540 1
		ifi->client->new = picked;
d544 3
a546 3
		ifi->client->new->expiry = cur_time + 12000;
		ifi->client->new->renewal += cur_time + 8000;
		ifi->client->new->rebind += cur_time + 10000;
d548 1
a548 1
		ifi->client->state = S_REQUESTING;
d556 4
a559 4
	ifi->client->destination = iaddr_broadcast;
	ifi->client->state = S_REQUESTING;
	ifi->client->first_sending = cur_time;
	ifi->client->interval = ifi->client->config->initial_interval;
d563 1
a563 1
	ifi->client->xid = ifi->client->packet.xid;
d583 1
a583 1
	if (ifi->client->xid != packet->raw->xid ||
d589 4
a592 4
	if (ifi->client->state != S_REBOOTING &&
	    ifi->client->state != S_REQUESTING &&
	    ifi->client->state != S_RENEWING &&
	    ifi->client->state != S_REBINDING)
d603 1
a603 1
	ifi->client->new = lease;
d609 3
a611 3
	if (ifi->client->new->options[DHO_DHCP_LEASE_TIME].data)
		ifi->client->new->expiry =
		    getULong(ifi->client->new->options[DHO_DHCP_LEASE_TIME].data);
d613 1
a613 1
		ifi->client->new->expiry = default_lease_time;
d616 2
a617 2
	if (ifi->client->new->expiry < 0)
		ifi->client->new->expiry = TIME_MAX;
d619 2
a620 2
	if (ifi->client->new->expiry < 60)
		ifi->client->new->expiry = 60;
d624 3
a626 3
	if (ifi->client->new->options[DHO_DHCP_RENEWAL_TIME].len)
		ifi->client->new->renewal =
		    getULong(ifi->client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d628 1
a628 1
		ifi->client->new->renewal = ifi->client->new->expiry / 2;
d631 3
a633 3
	if (ifi->client->new->options[DHO_DHCP_REBINDING_TIME].len)
		ifi->client->new->rebind =
		    getULong(ifi->client->new->options[DHO_DHCP_REBINDING_TIME].data);
d635 2
a636 2
		ifi->client->new->rebind = ifi->client->new->renewal +
		    ifi->client->new->renewal / 2 + ifi->client->new->renewal / 4;
d638 1
a638 1
	ifi->client->new->expiry += cur_time;
d640 8
a647 8
	if (ifi->client->new->expiry < cur_time)
		ifi->client->new->expiry = TIME_MAX;
	ifi->client->new->renewal += cur_time;
	if (ifi->client->new->renewal < cur_time)
		ifi->client->new->renewal = TIME_MAX;
	ifi->client->new->rebind += cur_time;
	if (ifi->client->new->rebind < cur_time)
		ifi->client->new->rebind = TIME_MAX;
d656 1
a656 1
	ifi->client->new->medium = ifi->client->medium;
d659 1
a659 1
	write_client_lease(ifi->client->new, 0);
d662 9
a670 9
	script_init((ifi->client->state == S_REQUESTING ? "BOUND" :
	    (ifi->client->state == S_RENEWING ? "RENEW" :
	    (ifi->client->state == S_REBOOTING ? "REBOOT" : "REBIND"))),
	    ifi->client->new->medium);
	if (ifi->client->active && ifi->client->state != S_REBOOTING)
		script_write_params("old_", ifi->client->active);
	script_write_params("new_", ifi->client->new);
	if (ifi->client->alias)
		script_write_params("alias_", ifi->client->alias);
d674 4
a677 4
	if (ifi->client->active)
		free_client_lease(ifi->client->active);
	ifi->client->active = ifi->client->new;
	ifi->client->new = NULL;
d680 1
a680 1
	add_timeout(ifi->client->active->renewal, state_bound);
d683 3
a685 3
	    piaddr(ifi->client->active->address),
	    ifi->client->active->renewal - cur_time);
	ifi->client->state = S_BOUND;
d700 2
a701 2
	make_request(ifi->client->active);
	ifi->client->xid = ifi->client->packet.xid;
d703 3
a705 3
	if (ifi->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy(ifi->client->destination.iabuf,
		    ifi->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
d707 1
a707 1
		ifi->client->destination.len = 4;
d709 1
a709 1
		ifi->client->destination = iaddr_broadcast;
d711 3
a713 3
	ifi->client->first_sending = cur_time;
	ifi->client->interval = ifi->client->config->initial_interval;
	ifi->client->state = S_RENEWING;
d729 1
a729 1
	for (ap = ifi->client->config->reject_list;
d765 1
a765 1
	for (ap = ifi->client->config->reject_list;
d786 2
a787 2
	if (ifi->client->state != S_SELECTING ||
	    ifi->client->xid != packet->raw->xid ||
d798 2
a799 2
	for (i = 0; ifi->client->config->required_options[i]; i++) {
		if (!packet->options[ifi->client->config->required_options[i]].len) {
d806 1
a806 1
	for (lease = ifi->client->offered_leases;
d828 1
a828 1
	lease->medium = ifi->client->medium;
d841 1
a841 2
	stop_selecting =
	    ifi->client->first_sending + ifi->client->config->select_interval;
d845 1
a845 1
	if (lease->address.len == ifi->client->requested_address.len &&
d847 4
a850 4
	    ifi->client->requested_address.iabuf,
	    ifi->client->requested_address.len)) {
		lease->next = ifi->client->offered_leases;
		ifi->client->offered_leases = lease;
d856 1
a856 1
		if (ifi->client->offered_leases &&
d862 2
a863 2
		if (!ifi->client->offered_leases)
			ifi->client->offered_leases = lease;
d865 1
a865 1
			for (lp = ifi->client->offered_leases; lp->next;
d979 1
a979 1
	if (ifi->client->xid != packet->raw->xid ||
d985 4
a988 4
	if (ifi->client->state != S_REBOOTING &&
	    ifi->client->state != S_REQUESTING &&
	    ifi->client->state != S_RENEWING &&
	    ifi->client->state != S_REBINDING)
d993 1
a993 1
	if (!ifi->client->active) {
d998 2
a999 2
	free_client_lease(ifi->client->active);
	ifi->client->active = NULL;
d1004 1
a1004 1
	ifi->client->state = S_INIT;
d1019 1
a1019 1
	interval = cur_time - ifi->client->first_sending;
d1023 1
a1023 1
	if (interval > ifi->client->config->timeout) {
d1031 1
a1031 2
	if (!ifi->client->offered_leases &&
	    ifi->client->config->media) {
d1034 2
a1035 2
		if (ifi->client->medium) {
			ifi->client->medium = ifi->client->medium->next;
d1038 1
a1038 1
		if (!ifi->client->medium) {
d1041 1
a1041 1
			ifi->client->medium = ifi->client->config->media;
d1045 1
a1045 1
		note("Trying medium \"%s\" %d", ifi->client->medium->string,
d1047 1
a1047 1
		script_init("MEDIUM", ifi->client->medium);
d1060 2
a1061 3
		if (!ifi->client->interval)
			ifi->client->interval =
			    ifi->client->config->initial_interval;
d1063 2
a1064 2
			ifi->client->interval += (arc4random() >> 2) %
			    (2 * ifi->client->interval);
d1068 2
a1069 4
		if (ifi->client->interval >
		    ifi->client->config->backoff_cutoff)
			ifi->client->interval =
				((ifi->client->config->backoff_cutoff / 2)
d1071 3
a1073 4
				    ifi->client->config->backoff_cutoff));
	} else if (!ifi->client->interval)
		ifi->client->interval =
			ifi->client->config->initial_interval;
d1077 4
a1080 5
	if (cur_time + ifi->client->interval >
	    ifi->client->first_sending + ifi->client->config->timeout)
		ifi->client->interval =
			(ifi->client->first_sending +
			 ifi->client->config->timeout) - cur_time + 1;
d1084 1
a1084 1
		ifi->client->packet.secs = htons(interval);
d1086 2
a1087 2
		ifi->client->packet.secs = htons(65535);
	ifi->client->secs = ifi->client->packet.secs;
d1091 1
a1091 1
	    ntohs(sockaddr_broadcast.sin_port), ifi->client->interval);
d1094 1
a1094 1
	(void)send_packet(&ifi->client->packet, ifi->client->packet_length,
d1097 1
a1097 1
	add_timeout(cur_time + ifi->client->interval, send_discover);
d1109 1
a1109 1
	struct client_lease *loop = ifi->client->active;
d1116 1
a1116 1
	if (!ifi->client->active && ifi->client->leases)
d1120 2
a1121 2
	while (ifi->client->active) {
		if (ifi->client->active->expiry > cur_time) {
d1123 1
a1123 1
			    piaddr(ifi->client->active->address));
d1127 3
a1129 3
			    ifi->client->active->medium);
			script_write_params("new_", ifi->client->active);
			if (ifi->client->alias)
d1131 1
a1131 1
				    ifi->client->alias);
d1138 2
a1139 2
				    ifi->client->active->renewal) {
					ifi->client->state = S_BOUND;
d1141 1
a1141 1
					    ifi->client->active->renewal -
d1143 1
a1143 1
					add_timeout(ifi->client->active->renewal,
d1146 1
a1146 1
					ifi->client->state = S_BOUND;
d1157 3
a1159 3
		if (!ifi->client->leases) {
			ifi->client->leases = ifi->client->active;
			ifi->client->active = NULL;
d1166 1
a1166 1
		for (lp = ifi->client->leases; lp->next; lp = lp->next)
d1168 1
a1168 1
		lp->next = ifi->client->active;
d1171 2
a1172 2
		ifi->client->active = ifi->client->leases;
		ifi->client->leases = ifi->client->leases->next;
d1177 1
a1177 1
		if (ifi->client->active == loop)
d1180 1
a1180 1
			loop = ifi->client->active;
d1188 2
a1189 2
	if (ifi->client->alias)
		script_write_params("alias_", ifi->client->alias);
d1191 2
a1192 2
	ifi->client->state = S_INIT;
	add_timeout(cur_time + ifi->client->config->retry_interval, state_init);
d1204 1
a1204 1
	interval = cur_time - ifi->client->first_sending;
d1216 3
a1218 3
	if ((ifi->client->state == S_REBOOTING ||
	    ifi->client->state == S_REQUESTING) &&
	    interval > ifi->client->config->reboot_timeout) {
d1220 1
a1220 1
		ifi->client->state = S_INIT;
d1228 4
a1231 4
	if (ifi->client->state == S_REBOOTING &&
	    !ifi->client->medium &&
	    ifi->client->active->medium ) {
		script_init("MEDIUM", ifi->client->active->medium);
d1238 1
a1238 1
		ifi->client->medium = ifi->client->active->medium;
d1243 2
a1244 2
	if (ifi->client->state != S_REQUESTING &&
	    cur_time > ifi->client->active->expiry) {
d1247 3
a1249 3
		script_write_params("old_", ifi->client->active);
		if (ifi->client->alias)
			script_write_params("alias_", ifi->client->alias);
d1255 2
a1256 2
		if (ifi->client->alias)
			script_write_params("alias_", ifi->client->alias);
d1259 1
a1259 1
		ifi->client->state = S_INIT;
d1265 2
a1266 2
	if (!ifi->client->interval)
		ifi->client->interval = ifi->client->config->initial_interval;
d1268 2
a1269 2
		ifi->client->interval += ((arc4random() >> 2) %
		    (2 * ifi->client->interval));
d1272 3
a1274 5
	if (ifi->client->interval >
	    ifi->client->config->backoff_cutoff)
		ifi->client->interval =
		    ((ifi->client->config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % ifi->client->interval));
d1278 3
a1280 5
	if (ifi->client->state != S_REQUESTING &&
	    cur_time + ifi->client->interval >
	    ifi->client->active->expiry)
		ifi->client->interval =
		    ifi->client->active->expiry - cur_time + 1;
d1285 3
a1287 3
	if (ifi->client->state == S_REQUESTING ||
	    ifi->client->state == S_REBOOTING ||
	    cur_time > ifi->client->active->rebind)
d1290 1
a1290 2
		memcpy(&destination.sin_addr.s_addr,
		    ifi->client->destination.iabuf,
d1296 2
a1297 3
	if (ifi->client->state != S_REQUESTING)
		memcpy(&from, ifi->client->active->address.iabuf,
		    sizeof(from));
d1302 2
a1303 2
	if (ifi->client->state == S_REQUESTING)
		ifi->client->packet.secs = ifi->client->secs;
d1306 1
a1306 1
			ifi->client->packet.secs = htons(interval);
d1308 1
a1308 1
			ifi->client->packet.secs = htons(65535);
d1315 1
a1315 1
	(void) send_packet(&ifi->client->packet, ifi->client->packet_length,
d1318 1
a1318 1
	add_timeout(cur_time + ifi->client->interval, send_request);
d1329 1
a1329 1
	(void) send_packet(&ifi->client->packet, ifi->client->packet_length,
d1341 1
a1341 1
	memset(&ifi->client->packet, 0, sizeof(ifi->client->packet));
d1350 2
a1351 2
	options[i].data = ifi->client->config->requested_options;
	options[i].len = ifi->client->config->requested_option_count;
d1355 1
a1355 1
		ifi->client->requested_address = lease->address;
d1360 1
a1360 1
		ifi->client->requested_address.len = 0;
d1365 3
a1367 5
		    ifi->client->config->send_options[i].data) {
			options[i].data =
			    ifi->client->config->send_options[i].data;
			options[i].len =
			    ifi->client->config->send_options[i].len;
d1371 1
a1371 1
	i = cons_options(ifi->client->packet.options, 576 - DHCP_FIXED_LEN,
d1373 1
a1373 1
	if (i == -1 || ifi->client->packet.options[i] != DHO_END)
d1375 18
a1392 22
	ifi->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ifi->client->packet_length < BOOTP_MIN_LEN)
		ifi->client->packet_length = BOOTP_MIN_LEN;

	ifi->client->packet.op = BOOTREQUEST;
	ifi->client->packet.htype = ifi->hw_address.htype;
	ifi->client->packet.hlen = ifi->hw_address.hlen;
	ifi->client->packet.hops = 0;
	ifi->client->packet.xid = arc4random();
	ifi->client->packet.secs = 0; /* filled in by send_discover. */
	ifi->client->packet.flags = 0;

	memset(&(ifi->client->packet.ciaddr),
	    0, sizeof(ifi->client->packet.ciaddr));
	memset(&(ifi->client->packet.yiaddr),
	    0, sizeof(ifi->client->packet.yiaddr));
	memset(&(ifi->client->packet.siaddr),
	    0, sizeof(ifi->client->packet.siaddr));
	memset(&(ifi->client->packet.giaddr),
	    0, sizeof(ifi->client->packet.giaddr));
	memcpy(ifi->client->packet.chaddr,
	    ifi->hw_address.haddr, ifi->hw_address.hlen);
d1404 1
a1404 1
	memset(&ifi->client->packet, 0, sizeof(ifi->client->packet));
d1413 2
a1414 2
	options[i].data = ifi->client->config->requested_options;
	options[i].len = ifi->client->config->requested_option_count;
d1418 1
a1418 1
	if (ifi->client->state == S_REQUESTING) {
d1424 3
a1426 3
	if (ifi->client->state == S_REQUESTING ||
	    ifi->client->state == S_REBOOTING) {
		ifi->client->requested_address = lease->address;
d1431 1
a1431 1
		ifi->client->requested_address.len = 0;
d1435 3
a1437 6
		if (!options[i].data &&
		    ifi->client->config->send_options[i].data) {
			options[i].data =
			    ifi->client->config->send_options[i].data;
			options[i].len =
			    ifi->client->config->send_options[i].len;
d1441 1
a1441 1
	i = cons_options(ifi->client->packet.options, 576 - DHCP_FIXED_LEN,
d1443 1
a1443 1
	if (i == -1 || ifi->client->packet.options[i] != DHO_END)
d1445 11
a1455 11
	ifi->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ifi->client->packet_length < BOOTP_MIN_LEN)
		ifi->client->packet_length = BOOTP_MIN_LEN;

	ifi->client->packet.op = BOOTREQUEST;
	ifi->client->packet.htype = ifi->hw_address.htype;
	ifi->client->packet.hlen = ifi->hw_address.hlen;
	ifi->client->packet.hops = 0;
	ifi->client->packet.xid = ifi->client->xid;
	ifi->client->packet.secs = 0; /* Filled in by send_request. */
	ifi->client->packet.flags = 0;
d1459 4
a1462 4
	if (ifi->client->state == S_BOUND ||
	    ifi->client->state == S_RENEWING ||
	    ifi->client->state == S_REBINDING) {
		memcpy(&ifi->client->packet.ciaddr,
d1465 2
a1466 2
		memset(&ifi->client->packet.ciaddr, 0,
		    sizeof(ifi->client->packet.ciaddr));
d1469 5
a1473 8
	memset(&ifi->client->packet.yiaddr, 0,
	    sizeof(ifi->client->packet.yiaddr));
	memset(&ifi->client->packet.siaddr, 0,
	    sizeof(ifi->client->packet.siaddr));
	memset(&ifi->client->packet.giaddr, 0,
	    sizeof(ifi->client->packet.giaddr));
	memcpy(ifi->client->packet.chaddr,
	    ifi->hw_address.haddr, ifi->hw_address.hlen);
d1484 1
a1484 1
	memset(&ifi->client->packet, 0, sizeof(ifi->client->packet));
d1503 3
a1505 3
	if (ifi->client->config->send_options[i].len) {
		options[i].data = ifi->client->config->send_options[i].data;
		options[i].len = ifi->client->config->send_options[i].len;
d1509 1
a1509 1
	i = cons_options(ifi->client->packet.options, 576 - DHCP_FIXED_LEN,
d1511 1
a1511 1
	if (i == -1 || ifi->client->packet.options[i] != DHO_END)
d1513 11
a1523 11
	ifi->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ifi->client->packet_length < BOOTP_MIN_LEN)
		ifi->client->packet_length = BOOTP_MIN_LEN;

	ifi->client->packet.op = BOOTREQUEST;
	ifi->client->packet.htype = ifi->hw_address.htype;
	ifi->client->packet.hlen = ifi->hw_address.hlen;
	ifi->client->packet.hops = 0;
	ifi->client->packet.xid = ifi->client->xid;
	ifi->client->packet.secs = 0; /* Filled in by send_request. */
	ifi->client->packet.flags = 0;
d1526 6
a1531 10
	memset(&ifi->client->packet.ciaddr, 0,
	    sizeof(ifi->client->packet.ciaddr));
	memset(&ifi->client->packet.yiaddr, 0,
	    sizeof(ifi->client->packet.yiaddr));
	memset(&ifi->client->packet.siaddr, 0,
	    sizeof(ifi->client->packet.siaddr));
	memset(&ifi->client->packet.giaddr, 0,
	    sizeof(ifi->client->packet.giaddr));
	memcpy(ifi->client->packet.chaddr,
	    ifi->hw_address.haddr, ifi->hw_address.hlen);
d1566 1
a1566 1
	for (lp = ifi->client->leases; lp; lp = lp->next)
d1568 2
a1569 2
	if (ifi->client->active)
		write_client_lease(ifi->client->active, 1);
a1666 2
	struct client_state *client = ifi->client;

d1728 1
a1728 1
		if (ifi->client->config->defaults[i].len) {
d1730 1
a1730 1
				switch (ifi->client->config->default_actions[i]) {
d1737 2
a1738 2
					dp = ifi->client->config->defaults[i].data;
					len = ifi->client->config->defaults[i].len;
d1741 1
a1741 1
					len = ifi->client->config->defaults[i].len +
d1751 2
a1752 2
					    ifi->client->config->defaults[i].data,
					    ifi->client->config->defaults[i].len);
d1754 1
a1754 1
					    ifi->client->config->defaults[i].len,
d1760 1
a1760 1
					len = ifi->client->config->defaults[i].len +
d1769 1
a1769 2
					memcpy(dp,
					    lease->options[i].data,
d1772 2
a1773 2
					    ifi->client->config->defaults[i].data,
					    ifi->client->config->defaults[i].len);
d1777 2
a1778 2
				dp = ifi->client->config->defaults[i].data;
				len = ifi->client->config->defaults[i].len;
d1881 2
a1882 2
	scriptName = ifi->client->config->script_name;
	envp = ifi->client->scriptEnv;
a1911 1
	struct client_state *client = ifi->client;
a1966 1
	struct client_state *client = ifi->client;
@


1.94
log
@There must be no alias address set, so check ifi->client->alias
for NULL before dereferencing it. OK henning@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.93 2006/12/18 18:08:12 stevesk Exp $	*/
d360 1
a360 1
		add_protocol("AF_ROUTE", routefd, routehandler, ifi);
d363 1
a363 1
	discover_interfaces(ifi);
d382 1
a382 1
	state_reboot(ifi);
d432 1
a432 1
state_reboot(void *ipp)
a433 2
	struct interface_info *ip = ipp;

d435 2
a436 2
	if (!ip->client->active || ip->client->active->is_bootp) {
		state_init(ip);
d441 1
a441 1
	ip->client->state = S_REBOOTING;
d446 1
a446 1
	ip->client->xid = arc4random();
d450 4
a453 4
	make_request(ip, ip->client->active);
	ip->client->destination = iaddr_broadcast;
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
d456 1
a456 1
	ip->client->medium = NULL;
d459 1
a459 1
	send_request(ip);
d467 1
a467 1
state_init(void *ipp)
a468 2
	struct interface_info *ip = ipp;

d471 6
a476 6
	make_discover(ip, ip->client->active);
	ip->client->xid = ip->client->packet.xid;
	ip->client->destination = iaddr_broadcast;
	ip->client->state = S_SELECTING;
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
d480 1
a480 1
	send_discover(ip);
d488 1
a488 1
state_selecting(void *ipp)
a489 1
	struct interface_info *ip = ipp;
d494 2
a495 2
	cancel_timeout(state_selecting, ip);
	cancel_timeout(send_discover, ip);
d501 1
a501 1
	for (lp = ip->client->offered_leases; lp; lp = next) {
d515 2
a516 2
				make_decline(ip, lp);
				send_decline(ip);
d526 1
a526 1
	ip->client->offered_leases = NULL;
d531 2
a532 2
		ip->client->state = S_INIT;
		state_init(ip);
d538 1
a538 1
		ip->client->new = picked;
d542 3
a544 3
		ip->client->new->expiry = cur_time + 12000;
		ip->client->new->renewal += cur_time + 8000;
		ip->client->new->rebind += cur_time + 10000;
d546 1
a546 1
		ip->client->state = S_REQUESTING;
d549 1
a549 1
		bind_lease(ip);
d554 4
a557 4
	ip->client->destination = iaddr_broadcast;
	ip->client->state = S_REQUESTING;
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
d560 2
a561 2
	make_request(ip, picked);
	ip->client->xid = ip->client->packet.xid;
d567 1
a567 1
	send_request(ip);
a576 1
	struct interface_info *ip = packet->interface;
d581 3
a583 3
	if (packet->interface->client->xid != packet->raw->xid ||
	    (packet->interface->hw_address.hlen != packet->raw->hlen) ||
	    (memcmp(packet->interface->hw_address.haddr,
d587 4
a590 4
	if (ip->client->state != S_REBOOTING &&
	    ip->client->state != S_REQUESTING &&
	    ip->client->state != S_RENEWING &&
	    ip->client->state != S_REBINDING)
d601 1
a601 1
	ip->client->new = lease;
d604 1
a604 1
	cancel_timeout(send_request, ip);
d607 3
a609 3
	if (ip->client->new->options[DHO_DHCP_LEASE_TIME].data)
		ip->client->new->expiry =
		    getULong(ip->client->new->options[DHO_DHCP_LEASE_TIME].data);
d611 1
a611 1
		ip->client->new->expiry = default_lease_time;
d614 2
a615 2
	if (ip->client->new->expiry < 0)
		ip->client->new->expiry = TIME_MAX;
d617 2
a618 2
	if (ip->client->new->expiry < 60)
		ip->client->new->expiry = 60;
d622 3
a624 3
	if (ip->client->new->options[DHO_DHCP_RENEWAL_TIME].len)
		ip->client->new->renewal =
		    getULong(ip->client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d626 1
a626 1
		ip->client->new->renewal = ip->client->new->expiry / 2;
d629 3
a631 3
	if (ip->client->new->options[DHO_DHCP_REBINDING_TIME].len)
		ip->client->new->rebind =
		    getULong(ip->client->new->options[DHO_DHCP_REBINDING_TIME].data);
d633 2
a634 2
		ip->client->new->rebind = ip->client->new->renewal +
		    ip->client->new->renewal / 2 + ip->client->new->renewal / 4;
d636 1
a636 1
	ip->client->new->expiry += cur_time;
d638 8
a645 8
	if (ip->client->new->expiry < cur_time)
		ip->client->new->expiry = TIME_MAX;
	ip->client->new->renewal += cur_time;
	if (ip->client->new->renewal < cur_time)
		ip->client->new->renewal = TIME_MAX;
	ip->client->new->rebind += cur_time;
	if (ip->client->new->rebind < cur_time)
		ip->client->new->rebind = TIME_MAX;
d647 1
a647 1
	bind_lease(ip);
d651 1
a651 1
bind_lease(struct interface_info *ip)
d654 1
a654 1
	ip->client->new->medium = ip->client->medium;
d657 1
a657 1
	write_client_lease(ip, ip->client->new, 0);
d660 9
a668 9
	script_init((ip->client->state == S_REQUESTING ? "BOUND" :
	    (ip->client->state == S_RENEWING ? "RENEW" :
	    (ip->client->state == S_REBOOTING ? "REBOOT" : "REBIND"))),
	    ip->client->new->medium);
	if (ip->client->active && ip->client->state != S_REBOOTING)
		script_write_params("old_", ip->client->active);
	script_write_params("new_", ip->client->new);
	if (ip->client->alias)
		script_write_params("alias_", ip->client->alias);
d672 4
a675 4
	if (ip->client->active)
		free_client_lease(ip->client->active);
	ip->client->active = ip->client->new;
	ip->client->new = NULL;
d678 1
a678 1
	add_timeout(ip->client->active->renewal, state_bound, ip);
d681 4
a684 4
	    piaddr(ip->client->active->address),
	    ip->client->active->renewal - cur_time);
	ip->client->state = S_BOUND;
	reinitialize_interfaces();
d695 1
a695 1
state_bound(void *ipp)
a696 2
	struct interface_info *ip = ipp;

d698 2
a699 2
	make_request(ip, ip->client->active);
	ip->client->xid = ip->client->packet.xid;
d701 3
a703 3
	if (ip->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy(ip->client->destination.iabuf,
		    ip->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
d705 1
a705 1
		ip->client->destination.len = 4;
d707 1
a707 1
		ip->client->destination = iaddr_broadcast;
d709 3
a711 3
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
	ip->client->state = S_RENEWING;
d714 1
a714 1
	send_request(ip);
d727 1
a727 1
	for (ap = packet->interface->client->config->reject_list;
d763 1
a763 1
	for (ap = packet->interface->client->config->reject_list;
a775 1
	struct interface_info *ip = packet->interface;
d784 4
a787 4
	if (ip->client->state != S_SELECTING ||
	    packet->interface->client->xid != packet->raw->xid ||
	    (packet->interface->hw_address.hlen != packet->raw->hlen) ||
	    (memcmp(packet->interface->hw_address.haddr,
d796 2
a797 2
	for (i = 0; ip->client->config->required_options[i]; i++) {
		if (!packet->options[ip->client->config->required_options[i]].len) {
d804 1
a804 1
	for (lease = ip->client->offered_leases;
d826 1
a826 1
	lease->medium = ip->client->medium;
d840 1
a840 1
	    ip->client->first_sending + ip->client->config->select_interval;
d844 1
a844 1
	if (lease->address.len == ip->client->requested_address.len &&
d846 4
a849 4
	    ip->client->requested_address.iabuf,
	    ip->client->requested_address.len)) {
		lease->next = ip->client->offered_leases;
		ip->client->offered_leases = lease;
d855 1
a855 1
		if (ip->client->offered_leases &&
d861 2
a862 2
		if (!ip->client->offered_leases)
			ip->client->offered_leases = lease;
d864 1
a864 1
			for (lp = ip->client->offered_leases; lp->next;
d881 1
a881 1
		state_selecting(ip);
d883 2
a884 2
		add_timeout(stop_selecting, state_selecting, ip);
		cancel_timeout(send_discover, ip);
a975 2
	struct interface_info *ip = packet->interface;

d978 3
a980 3
	if (packet->interface->client->xid != packet->raw->xid ||
	    (packet->interface->hw_address.hlen != packet->raw->hlen) ||
	    (memcmp(packet->interface->hw_address.haddr,
d984 4
a987 4
	if (ip->client->state != S_REBOOTING &&
	    ip->client->state != S_REQUESTING &&
	    ip->client->state != S_RENEWING &&
	    ip->client->state != S_REBINDING)
d992 1
a992 1
	if (!ip->client->active) {
d997 2
a998 2
	free_client_lease(ip->client->active);
	ip->client->active = NULL;
d1001 1
a1001 1
	cancel_timeout(send_request, ip);
d1003 2
a1004 2
	ip->client->state = S_INIT;
	state_init(ip);
d1013 1
a1013 1
send_discover(void *ipp)
a1014 1
	struct interface_info *ip = ipp;
d1018 1
a1018 1
	interval = cur_time - ip->client->first_sending;
d1022 2
a1023 2
	if (interval > ip->client->config->timeout) {
		state_panic(ip);
d1030 2
a1031 2
	if (!ip->client->offered_leases &&
	    ip->client->config->media) {
d1034 2
a1035 2
		if (ip->client->medium) {
			ip->client->medium = ip->client->medium->next;
d1038 1
a1038 1
		if (!ip->client->medium) {
d1040 2
a1041 2
				error("No valid media types for %s!", ip->name);
			ip->client->medium = ip->client->config->media;
d1045 1
a1045 1
		note("Trying medium \"%s\" %d", ip->client->medium->string,
d1047 1
a1047 1
		script_init("MEDIUM", ip->client->medium);
d1060 3
a1062 3
		if (!ip->client->interval)
			ip->client->interval =
			    ip->client->config->initial_interval;
d1064 2
a1065 2
			ip->client->interval += (arc4random() >> 2) %
			    (2 * ip->client->interval);
d1069 4
a1072 4
		if (ip->client->interval >
		    ip->client->config->backoff_cutoff)
			ip->client->interval =
				((ip->client->config->backoff_cutoff / 2)
d1074 4
a1077 4
				    ip->client->config->backoff_cutoff));
	} else if (!ip->client->interval)
		ip->client->interval =
			ip->client->config->initial_interval;
d1081 5
a1085 5
	if (cur_time + ip->client->interval >
	    ip->client->first_sending + ip->client->config->timeout)
		ip->client->interval =
			(ip->client->first_sending +
			 ip->client->config->timeout) - cur_time + 1;
d1089 1
a1089 1
		ip->client->packet.secs = htons(interval);
d1091 2
a1092 2
		ip->client->packet.secs = htons(65535);
	ip->client->secs = ip->client->packet.secs;
d1095 2
a1096 2
	    ip->name, inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port), ip->client->interval);
d1099 1
a1099 1
	(void)send_packet(ip, &ip->client->packet, ip->client->packet_length,
d1102 1
a1102 1
	add_timeout(cur_time + ip->client->interval, send_discover, ip);
d1112 1
a1112 1
state_panic(void *ipp)
d1114 1
a1114 2
	struct interface_info *ip = ipp;
	struct client_lease *loop = ip->client->active;
d1121 1
a1121 1
	if (!ip->client->active && ip->client->leases)
d1125 2
a1126 2
	while (ip->client->active) {
		if (ip->client->active->expiry > cur_time) {
d1128 1
a1128 1
			    piaddr(ip->client->active->address));
d1132 3
a1134 3
			    ip->client->active->medium);
			script_write_params("new_", ip->client->active);
			if (ip->client->alias)
d1136 1
a1136 1
				    ip->client->alias);
d1143 2
a1144 2
				    ip->client->active->renewal) {
					ip->client->state = S_BOUND;
d1146 1
a1146 1
					    ip->client->active->renewal -
d1148 2
a1149 2
					add_timeout(ip->client->active->renewal,
					    state_bound, ip);
d1151 1
a1151 1
					ip->client->state = S_BOUND;
d1153 1
a1153 1
					state_bound(ip);
d1155 1
a1155 1
				reinitialize_interfaces();
d1162 3
a1164 3
		if (!ip->client->leases) {
			ip->client->leases = ip->client->active;
			ip->client->active = NULL;
d1171 1
a1171 1
		for (lp = ip->client->leases; lp->next; lp = lp->next)
d1173 1
a1173 1
		lp->next = ip->client->active;
d1176 2
a1177 2
		ip->client->active = ip->client->leases;
		ip->client->leases = ip->client->leases->next;
d1182 1
a1182 1
		if (ip->client->active == loop)
d1185 1
a1185 1
			loop = ip->client->active;
d1193 2
a1194 2
	if (ip->client->alias)
		script_write_params("alias_", ip->client->alias);
d1196 2
a1197 3
	ip->client->state = S_INIT;
	add_timeout(cur_time + ip->client->config->retry_interval, state_init,
	    ip);
d1202 1
a1202 1
send_request(void *ipp)
a1203 1
	struct interface_info *ip = ipp;
d1209 1
a1209 1
	interval = cur_time - ip->client->first_sending;
d1221 3
a1223 3
	if ((ip->client->state == S_REBOOTING ||
	    ip->client->state == S_REQUESTING) &&
	    interval > ip->client->config->reboot_timeout) {
d1225 3
a1227 3
		ip->client->state = S_INIT;
		cancel_timeout(send_request, ip);
		state_init(ip);
d1233 4
a1236 4
	if (ip->client->state == S_REBOOTING &&
	    !ip->client->medium &&
	    ip->client->active->medium ) {
		script_init("MEDIUM", ip->client->active->medium);
d1243 1
a1243 1
		ip->client->medium = ip->client->active->medium;
d1248 2
a1249 2
	if (ip->client->state != S_REQUESTING &&
	    cur_time > ip->client->active->expiry) {
d1252 3
a1254 3
		script_write_params("old_", ip->client->active);
		if (ip->client->alias)
			script_write_params("alias_", ip->client->alias);
d1260 2
a1261 2
		if (ip->client->alias)
			script_write_params("alias_", ip->client->alias);
d1264 2
a1265 2
		ip->client->state = S_INIT;
		state_init(ip);
d1270 2
a1271 2
	if (!ip->client->interval)
		ip->client->interval = ip->client->config->initial_interval;
d1273 2
a1274 2
		ip->client->interval += ((arc4random() >> 2) %
		    (2 * ip->client->interval));
d1277 5
a1281 5
	if (ip->client->interval >
	    ip->client->config->backoff_cutoff)
		ip->client->interval =
		    ((ip->client->config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % ip->client->interval));
d1285 5
a1289 5
	if (ip->client->state != S_REQUESTING &&
	    cur_time + ip->client->interval >
	    ip->client->active->expiry)
		ip->client->interval =
		    ip->client->active->expiry - cur_time + 1;
d1294 3
a1296 3
	if (ip->client->state == S_REQUESTING ||
	    ip->client->state == S_REBOOTING ||
	    cur_time > ip->client->active->rebind)
d1300 1
a1300 1
		    ip->client->destination.iabuf,
d1306 2
a1307 2
	if (ip->client->state != S_REQUESTING)
		memcpy(&from, ip->client->active->address.iabuf,
d1313 2
a1314 2
	if (ip->client->state == S_REQUESTING)
		ip->client->packet.secs = ip->client->secs;
d1317 1
a1317 1
			ip->client->packet.secs = htons(interval);
d1319 1
a1319 1
			ip->client->packet.secs = htons(65535);
d1322 1
a1322 1
	note("DHCPREQUEST on %s to %s port %d", ip->name,
d1326 1
a1326 1
	(void) send_packet(ip, &ip->client->packet, ip->client->packet_length,
d1329 1
a1329 1
	add_timeout(cur_time + ip->client->interval, send_request, ip);
d1333 1
a1333 1
send_decline(void *ipp)
d1335 1
a1335 3
	struct interface_info *ip = ipp;

	note("DHCPDECLINE on %s to %s port %d", ip->name,
d1340 1
a1340 1
	(void) send_packet(ip, &ip->client->packet, ip->client->packet_length,
d1345 1
a1345 1
make_discover(struct interface_info *ip, struct client_lease *lease)
d1352 1
a1352 1
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));
d1361 2
a1362 2
	options[i].data = ip->client->config->requested_options;
	options[i].len = ip->client->config->requested_option_count;
d1366 1
a1366 1
		ip->client->requested_address = lease->address;
d1371 1
a1371 1
		ip->client->requested_address.len = 0;
d1376 1
a1376 1
		    ip->client->config->send_options[i].data) {
d1378 1
a1378 1
			    ip->client->config->send_options[i].data;
d1380 1
a1380 1
			    ip->client->config->send_options[i].len;
d1384 1
a1384 1
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
d1386 1
a1386 1
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
d1388 22
a1409 22
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = arc4random();
	ip->client->packet.secs = 0; /* filled in by send_discover. */
	ip->client->packet.flags = 0;

	memset(&(ip->client->packet.ciaddr),
	    0, sizeof(ip->client->packet.ciaddr));
	memset(&(ip->client->packet.yiaddr),
	    0, sizeof(ip->client->packet.yiaddr));
	memset(&(ip->client->packet.siaddr),
	    0, sizeof(ip->client->packet.siaddr));
	memset(&(ip->client->packet.giaddr),
	    0, sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
d1414 1
a1414 1
make_request(struct interface_info *ip, struct client_lease * lease)
d1421 1
a1421 1
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));
d1430 2
a1431 2
	options[i].data = ip->client->config->requested_options;
	options[i].len = ip->client->config->requested_option_count;
d1435 1
a1435 1
	if (ip->client->state == S_REQUESTING) {
d1441 3
a1443 3
	if (ip->client->state == S_REQUESTING ||
	    ip->client->state == S_REBOOTING) {
		ip->client->requested_address = lease->address;
d1448 1
a1448 1
		ip->client->requested_address.len = 0;
d1453 1
a1453 1
		    ip->client->config->send_options[i].data) {
d1455 1
a1455 1
			    ip->client->config->send_options[i].data;
d1457 1
a1457 1
			    ip->client->config->send_options[i].len;
d1461 1
a1461 1
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
d1463 1
a1463 1
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
d1465 11
a1475 11
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = ip->client->xid;
	ip->client->packet.secs = 0; /* Filled in by send_request. */
	ip->client->packet.flags = 0;
d1479 4
a1482 4
	if (ip->client->state == S_BOUND ||
	    ip->client->state == S_RENEWING ||
	    ip->client->state == S_REBINDING) {
		memcpy(&ip->client->packet.ciaddr,
d1485 2
a1486 2
		memset(&ip->client->packet.ciaddr, 0,
		    sizeof(ip->client->packet.ciaddr));
d1489 8
a1496 8
	memset(&ip->client->packet.yiaddr, 0,
	    sizeof(ip->client->packet.yiaddr));
	memset(&ip->client->packet.siaddr, 0,
	    sizeof(ip->client->packet.siaddr));
	memset(&ip->client->packet.giaddr, 0,
	    sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
d1500 1
a1500 1
make_decline(struct interface_info *ip, struct client_lease *lease)
d1507 1
a1507 1
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));
d1526 3
a1528 3
	if (ip->client->config->send_options[i].len) {
		options[i].data = ip->client->config->send_options[i].data;
		options[i].len = ip->client->config->send_options[i].len;
d1532 1
a1532 1
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
d1534 1
a1534 1
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
d1536 11
a1546 11
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = ip->client->xid;
	ip->client->packet.secs = 0; /* Filled in by send_request. */
	ip->client->packet.flags = 0;
d1549 10
a1558 10
	memset(&ip->client->packet.ciaddr, 0,
	    sizeof(ip->client->packet.ciaddr));
	memset(&ip->client->packet.yiaddr, 0,
	    sizeof(ip->client->packet.yiaddr));
	memset(&ip->client->packet.siaddr, 0,
	    sizeof(ip->client->packet.siaddr));
	memset(&ip->client->packet.giaddr, 0,
	    sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
d1594 1
a1594 1
		write_client_lease(ifi, lp, 1);
d1596 1
a1596 1
		write_client_lease(ifi, ifi->client->active, 1);
d1604 1
a1604 2
write_client_lease(struct interface_info *ip, struct client_lease *lease,
    int rewrite)
d1631 1
a1631 1
	fprintf(leaseFile, "  interface \"%s\";\n", ip->name);
a1719 1
	struct interface_info *ip = ifi;
d1757 1
a1757 1
		if (ip->client->config->defaults[i].len) {
d1759 1
a1759 1
				switch (ip->client->config->default_actions[i]) {
d1766 2
a1767 2
					dp = ip->client->config->defaults[i].data;
					len = ip->client->config->defaults[i].len;
d1770 1
a1770 1
					len = ip->client->config->defaults[i].len +
d1780 2
a1781 2
					    ip->client->config->defaults[i].data,
					    ip->client->config->defaults[i].len);
d1783 1
a1783 1
					    ip->client->config->defaults[i].len,
d1789 1
a1789 1
					len = ip->client->config->defaults[i].len +
d1802 2
a1803 2
					    ip->client->config->defaults[i].data,
					    ip->client->config->defaults[i].len);
d1807 2
a1808 2
				dp = ip->client->config->defaults[i].data;
				len = ip->client->config->defaults[i].len;
@


1.93
log
@this is clearer and consistent with other areas; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.92 2006/12/17 18:09:32 stevesk Exp $	*/
d195 2
a196 1
		if (l != NULL || addr_eq(a, ifi->client->alias->address))
@


1.92
log
@remove ASSERT_STATE() macro which is a NOOP, no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.91 2006/12/15 14:56:38 stevesk Exp $	*/
d1491 1
a1499 1
		ip->client->packet.flags = 0;
a1502 1
		ip->client->packet.flags = 0;
@


1.91
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.90 2006/11/27 20:52:30 stevesk Exp $	*/
a79 6
/*
 * ASSERT_STATE() does nothing now; it used to be
 * assert (state_is == state_shouldbe).
 */
#define ASSERT_STATE(state_is, state_shouldbe) {}

a471 2
	ASSERT_STATE(state, S_INIT);

a495 2
	ASSERT_STATE(state, S_SELECTING);

a702 2

	ASSERT_STATE(state, S_BOUND);
@


1.90
log
@correct comment
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.89 2006/09/24 14:54:54 krw Exp $	*/
d945 1
a945 1
			if (!check_option(lease,i)) {
d968 1
a968 1
		lease->server_name[DHCP_SNAME_LEN]='\0';
d988 1
a988 1
		lease->filename[DHCP_FILE_LEN]='\0';
@


1.89
log
@No point in checking for a NULL ifi after we've used it. Plus ifi is
set once in main() and used everywhere without further checks.

From Matthew R. Dempsky via tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.88 2006/08/31 10:12:18 deraadt Exp $	*/
d1078 3
a1080 3
	 * it to one; otherwise, add to it a random number between zero
	 * and two times itself.  On average, this means that it will
	 * double with every transmission.
@


1.88
log
@adjust link detection further:  if no link, bring interface up and check
for link for 10 seconds.  otherwise, if there was link, no problem!
ok henning, claudio, tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.87 2006/08/29 03:55:08 deraadt Exp $	*/
a186 2
		if (ifi == NULL)
			goto die;
@


1.88.2.1
log
@MFC:
Fix by moritz@@

There must be no alias address set, so check ifi->client->alias
for NULL before dereferencing it. OK henning@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.88 2006/08/31 10:12:18 deraadt Exp $	*/
d203 1
a203 2
		if (l != NULL || (ifi->client->alias &&
		    addr_eq(a, ifi->client->alias->address)))
@


1.87
log
@some net if devices do not media negotiate (for link) until brought up.
(for some drivers, this is a bug.  for others, it is part of how they work)
therefore before doing the 10-second link test, we must bring the if up.
ok krw, tested marco ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.86 2006/06/16 16:17:16 reyk Exp $	*/
d246 1
a246 1
	int	 ch, fd, quiet = 0, i = 0, pipe_fd[2], linkstat;
d312 2
a313 1
	linkstat = interface_link_forceup(ifi->name);
a314 1
	if (!interface_link_status(ifi->name)) {
@


1.86
log
@always change the working directory of the priv child to the root
directory ("/"). this fixes a problem when dhclient was called in a
working directory like "/mnt" and the user tried to unmount this
directory while dhclient was still running. umount failed because the
device for "/mnt" was still busy and blocked by the running priv child
of dhclient.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.85 2006/06/01 16:37:54 krw Exp $	*/
d246 1
a246 1
	int	 ch, fd, quiet = 0, i = 0, pipe_fd[2];
d312 2
d318 2
d329 2
@


1.85
log
@Don't treat the addition of a dhclient.conf 'alias{}' address as an
external modification when the RTM_NEWADDR message arrives from the
routing socket. Now dhclient will not exit if 'alias{}' is specified
in dhclient.conf.

Mentioned many times, most recently by Matthias Bertschy on misc@@.

ok henning@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.84 2006/05/31 02:21:49 stevesk Exp $	*/
d2278 3
@


1.84
log
@Fix 'special value 0 requests that dhclient not wait for a link state
change before timing out' behaviour of the man page for link-timeout;
ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.83 2006/05/08 17:25:59 deraadt Exp $	*/
d203 2
a204 1
		if (l != NULL)	/* new addr is the one we set */
@


1.83
log
@add 'link-timeout n' seconds option to grammer, from fkr@@hazardous.org
default remains 10 seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.82 2006/03/06 10:45:56 djm Exp $	*/
d313 4
@


1.82
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.81 2005/10/26 15:42:04 henning Exp $	*/
d318 1
a318 1
			if (++i > 10) {
@


1.81
log
@put the 100% right r1.79 back in, that is still as right as it was the first
time. dale just had the same problem and made me look again.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.79 2005/08/25 19:08:50 henning Exp $	*/
d366 6
a371 4
	if (setgroups(1, &pw->pw_gid) ||
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
		error("can't drop privileges: %m");
@


1.80
log
@backout unapproved diff
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.78 2005/08/07 01:35:11 krw Exp $	*/
d2116 2
a2117 1
			return (0);
@


1.79
log
@when we get an invalid hostname in an option, bitching a moaning is ok,
but there is no point in refusing the lease based on that. so bitch and
moan and ignore that option but accept the lease.
yes, customer networks are sometimes interesting...
ok millert krw beck
@
text
@d2116 1
a2116 2
			l->options[option].len = 0;
			free(l->options[option].data);
@


1.78
log
@Simplify code by calling error() from inside buf_* functions rather
than always testing the return code and calling error() from the
caller.

From a diff by moritz@@, ok henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.77 2005/08/02 02:34:03 krw Exp $	*/
d2116 2
a2117 1
			return (0);
@


1.77
log
@Rip out code dealing with multiple/nested interfaces. Each instance of
dhclient is responsible for one interface. Simply skip interface
declarations for other interfaces and store all info in the one
interface structure.

tested by dlg@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.76 2005/07/16 14:09:51 krw Exp $	*/
a1687 1
	int		 errs;
d1697 1
a1697 2
	if ((buf = buf_open(hdr.len)) == NULL)
		error("buf_open: %m");
d1699 2
a1700 3
	errs = 0;
	errs += buf_add(buf, &hdr, sizeof(hdr));
	errs += buf_add(buf, &mediumlen, sizeof(mediumlen));
d1702 1
a1702 1
		errs += buf_add(buf, medium->string, mediumlen);
d1704 2
a1705 2
	errs += buf_add(buf, &len, sizeof(len));
	errs += buf_add(buf, reason, len);
d1707 1
a1707 5
	if (errs)
		error("buf_add: %m");

	if (buf_close(privfd, buf) == -1)
		error("buf_close: %m");
d1855 1
a1855 1
	int		 errs, i;
d1874 1
a1874 2
	if ((buf = buf_open(hdr.len)) == NULL)
		error("buf_open: %m");
d1876 8
a1883 9
	errs = 0;
	errs += buf_add(buf, &hdr, sizeof(hdr));
	errs += buf_add(buf, lease, sizeof(struct client_lease));
	errs += buf_add(buf, &fn_len, sizeof(fn_len));
	errs += buf_add(buf, lease->filename, fn_len);
	errs += buf_add(buf, &sn_len, sizeof(sn_len));
	errs += buf_add(buf, lease->server_name, sn_len);
	errs += buf_add(buf, &pr_len, sizeof(pr_len));
	errs += buf_add(buf, prefix, pr_len);
d1886 1
a1886 1
		errs += buf_add(buf, &lease->options[i].len,
d1888 1
a1888 1
		errs += buf_add(buf, lease->options[i].data,
d1892 1
a1892 5
	if (errs)
		error("buf_add: %m");

	if (buf_close(privfd, buf) == -1)
		error("buf_close: %m");
d1907 1
a1907 5
	if ((buf = buf_open(hdr.len)) == NULL)
		error("buf_open: %m");

	if (buf_add(buf, &hdr, sizeof(hdr)))
		error("buf_add: %m");
d1909 2
a1910 2
	if (buf_close(privfd, buf) == -1)
		error("buf_close: %m");
@


1.76
log
@Eliminate unnecessary 'code' field from struct option. Make
dhcp_options const.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.75 2005/07/13 23:31:32 deraadt Exp $	*/
d280 10
a289 2
	if ((ifi = calloc(1, sizeof(struct interface_info))) == NULL)
		error("calloc");
d1720 8
a1727 1
	struct interface_info *ip = ifi;
d1729 3
a1731 11
	if (ip) {
		ip->client->scriptEnvsize = 100;
		if (ip->client->scriptEnv == NULL)
			ip->client->scriptEnv =
			    malloc(ip->client->scriptEnvsize * sizeof(char *));
		if (ip->client->scriptEnv == NULL)
			error("script_init: no memory for environment");

		ip->client->scriptEnv[0] = strdup(CLIENT_PATH);
		if (ip->client->scriptEnv[0] == NULL)
			error("script_init: no memory for environment");
d1733 1
a1733 1
		ip->client->scriptEnv[1] = NULL;
d1735 1
a1735 1
		script_set_env(ip->client, "", "interface", ip->name);
d1737 2
a1738 2
		if (medium)
			script_set_env(ip->client, "", "medium", medium);
d1740 1
a1740 2
		script_set_env(ip->client, "", "reason", reason);
	}
d1751 1
a1751 2
	script_set_env(ip->client, prefix, "ip_address",
	    piaddr(lease->address));
d1764 1
a1764 1
			script_set_env(ip->client, prefix, "network_number",
d1769 1
a1769 1
					script_set_env(ip->client, prefix,
d1777 1
a1777 1
		script_set_env(ip->client, prefix, "filename", lease->filename);
d1779 1
a1779 1
		script_set_env(ip->client, prefix, "server_name",
d1848 1
a1848 1
				script_set_env(ip->client, prefix, name,
d1853 1
a1853 1
	script_set_env(ip->client, prefix, "expiry", tbuf);
d1943 1
a1943 3
	char *scriptName, *argv[2], **envp, *epp[3], reason[] = "REASON=NBI";
	static char client_path[] = CLIENT_PATH;
	struct interface_info *ip = ifi;
d1948 2
a1949 10
	if (ip) {
		scriptName = ip->client->config->script_name;
		envp = ip->client->scriptEnv;
	} else {
		scriptName = top_level_config.script_name;
		epp[0] = reason;
		epp[1] = client_path;
		epp[2] = NULL;
		envp = epp;
	}
d1971 1
a1971 2
	if (ip)
		script_flush_env(ip->client);
d1977 1
a1977 2
script_set_env(struct client_state *client, const char *prefix,
    const char *name, const char *value)
d1979 1
d2033 1
a2033 1
script_flush_env(struct client_state *client)
d2035 1
@


1.75
log
@minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.74 2005/07/13 23:25:55 krw Exp $	*/
d2051 1
a2051 1
dhcp_option_ev_name(char *buf, size_t buflen, struct option *option)
@


1.74
log
@Repair/rationalize option handling to ensure valid option section is
always sent. Fold store_options into cons_options. Eliminate priority
list of options.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.73 2005/07/09 14:36:15 krw Exp $	*/
d72 3
a87 4
int		no_daemon;
int		unknown_ok = 1;
int		routefd;

d245 3
a247 4
	extern char		*__progname;
	int			 ch, fd, quiet = 0, i = 0;
	int			 pipe_fd[2];
	struct passwd		*pw;
a416 1

d565 4
a568 3
/* state_requesting is called when we receive a DHCPACK message after
   having sent out one or more DHCPREQUEST packets. */

d604 2
a605 2
		ip->client->new->expiry = getULong(
		    ip->client->new->options[DHO_DHCP_LEASE_TIME].data);
d619 2
a620 2
		ip->client->new->renewal = getULong(
		    ip->client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d626 2
a627 2
		ip->client->new->rebind = getULong(
		    ip->client->new->options[DHO_DHCP_REBINDING_TIME].data);
d702 3
a704 2
		memcpy(ip->client->destination.iabuf, ip->client->active->
		    options[DHO_DHCP_SERVER_IDENTIFIER].data, 4);
d798 1
a798 2
		if (!packet->options[ip->client->config->
		    required_options[i]].len) {
d889 4
a892 3
/* Allocate a client_lease structure and initialize it from the parameters
   in the specified packet. */

d1010 5
a1014 4
/* Send out a DHCPDISCOVER packet, and set a timeout to send out another
   one after the right interval has expired.  If we don't get an offer by
   the time we reach the panic interval, call the panic function. */

d1153 1
a1153 2
					add_timeout(
					    ip->client->active->renewal,
d1781 1
a1781 2
				switch (
				    ip->client->config->default_actions[i]) {
d1788 2
a1789 4
					dp = ip->client->
						config->defaults[i].data;
					len = ip->client->
						config->defaults[i].len;
d1792 1
a1792 2
					len = ip->client->
					    config->defaults[i].len +
d1802 6
a1807 8
						ip->client->
						config->defaults[i].data,
						ip->client->
						config->defaults[i].len);
					memcpy(dp + ip->client->
						config->defaults[i].len,
						lease->options[i].data,
						lease->options[i].len);
d1811 1
a1811 2
					len = ip->client->
					    config->defaults[i].len +
d1821 2
a1822 2
						lease->options[i].data,
						lease->options[i].len);
d1824 2
a1825 4
						ip->client->
						config->defaults[i].data,
						ip->client->
						config->defaults[i].len);
d1829 2
a1830 4
				dp = ip->client->
					config->defaults[i].data;
				len = ip->client->
					config->defaults[i].len;
d2026 1
a2026 1
	for (j=0; j < strlen(value); j++)
d2131 1
a2131 1
		return (1)  ;
@


1.73
log
@Clean out a few more unused/uninitialized variables.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.72 2005/07/08 00:57:36 krw Exp $	*/
d1393 6
a1398 2
	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(&ip->client->packet, options);
d1470 6
a1475 2
	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(&ip->client->packet, options);
d1542 6
a1547 2
	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(&ip->client->packet, options);
@


1.72
log
@Eliminate unused code and associated parameters.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.71 2005/07/07 20:03:40 krw Exp $	*/
a84 1
int		log_priority;
@


1.71
log
@Eliminate unused code and associated parameter.

ok deraadt@@ millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.70 2005/07/07 16:24:24 krw Exp $	*/
d1395 1
a1395 2
	ip->client->packet_length = cons_options(&ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
d1468 1
a1468 2
	ip->client->packet_length = cons_options(&ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
d1536 1
a1536 2
	ip->client->packet_length = cons_options(&ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
@


1.70
log
@Eliminate tree_cache structure in favour of option_data. Eliminate
redundant level of indirection in building and using option_data
arrays while constructing outgoing packets. Make option_data len field
unsigned.

ok henning@@. 'cool!' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.69 2005/07/07 13:33:35 krw Exp $	*/
d1395 1
a1395 1
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
d1469 1
a1469 1
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
d1538 1
a1538 1
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
@


1.69
log
@Expunge two unused fields (buf_size, timeout) in tree_cache structure.

ok millert@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.68 2005/05/29 08:46:10 marius Exp $	*/
d1359 1
a1359 2
	struct tree_cache *options[256];
	struct tree_cache option_elements[256];
a1361 1
	memset(option_elements, 0, sizeof(option_elements));
d1367 2
a1368 3
	options[i] = &option_elements[i];
	options[i]->value = &discover;
	options[i]->len = sizeof(discover);
d1372 2
a1373 3
	options[i] = &option_elements[i];
	options[i]->value = ip->client->config->requested_options;
	options[i]->len = ip->client->config->requested_option_count;
d1379 2
a1380 3
		options[i] = &option_elements[i];
		options[i]->value = lease->address.iabuf;
		options[i]->len = lease->address.len;
d1386 1
a1386 1
		if (!options[i] &&
d1388 1
a1388 2
			options[i] = &option_elements[i];
			options[i]->value =
d1390 1
a1390 1
			options[i]->len =
d1425 1
a1425 2
	struct tree_cache *options[256];
	struct tree_cache option_elements[256];
d1433 2
a1434 3
	options[i] = &option_elements[i];
	options[i]->value = &request;
	options[i]->len = sizeof(request);
d1438 2
a1439 3
	options[i] = &option_elements[i];
	options[i]->value = ip->client->config->requested_options;
	options[i]->len = ip->client->config->requested_option_count;
d1446 2
a1447 3
		options[i] = &option_elements[i];
		options[i]->value = lease->options[i].data;
		options[i]->len = lease->options[i].len;
d1453 2
a1454 3
		options[i] = &option_elements[i];
		options[i]->value = lease->address.iabuf;
		options[i]->len = lease->address.len;
d1460 1
a1460 1
		if (!options[i] &&
d1462 1
a1462 2
			options[i] = &option_elements[i];
			options[i]->value =
d1464 1
a1464 1
			options[i]->len =
d1508 1
a1508 3
	struct tree_cache *options[256], message_type_tree;
	struct tree_cache requested_address_tree;
	struct tree_cache server_id_tree, client_id_tree;
d1517 2
a1518 3
	options[i] = &message_type_tree;
	options[i]->value = &decline;
	options[i]->len = sizeof(decline);
d1522 2
a1523 3
	options[i] = &server_id_tree;
	options[i]->value = lease->options[i].data;
	options[i]->len = lease->options[i].len;
d1527 2
a1528 3
	options[i] = &requested_address_tree;
	options[i]->value = lease->address.iabuf;
	options[i]->len = lease->address.len;
d1533 2
a1534 3
		options[i] = &client_id_tree;
		options[i]->value = ip->client->config->send_options[i].data;
		options[i]->len = ip->client->config->send_options[i].len;
a1535 1

@


1.68
log
@robustness against malformed snames.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.67 2005/04/08 14:21:36 henning Exp $	*/
a1371 2
	options[i]->buf_size = sizeof(discover);
	options[i]->timeout = 0xFFFFFFFF;
a1377 3
	options[i]->buf_size =
		ip->client->config->requested_option_count;
	options[i]->timeout = 0xFFFFFFFF;
a1385 2
		options[i]->buf_size = lease->address.len;
		options[i]->timeout = 0xFFFFFFFF;
a1397 3
			options[i]->buf_size =
			    ip->client->config->send_options[i].len;
			options[i]->timeout = 0xFFFFFFFF;
a1442 2
	options[i]->buf_size = sizeof(request);
	options[i]->timeout = 0xFFFFFFFF;
a1448 3
	options[i]->buf_size =
		ip->client->config->requested_option_count;
	options[i]->timeout = 0xFFFFFFFF;
a1457 2
		options[i]->buf_size = lease->options[i].len;
		options[i]->timeout = 0xFFFFFFFF;
a1465 2
		options[i]->buf_size = lease->address.len;
		options[i]->timeout = 0xFFFFFFFF;
a1477 3
			options[i]->buf_size =
			    ip->client->config->send_options[i].len;
			options[i]->timeout = 0xFFFFFFFF;
a1533 2
	options[i]->buf_size = sizeof(decline);
	options[i]->timeout = 0xFFFFFFFF;
a1539 2
	options[i]->buf_size = lease->options[i].len;
	options[i]->timeout = 0xFFFFFFFF;
a1545 2
	options[i]->buf_size = lease->address.len;
	options[i]->timeout = 0xFFFFFFFF;
a1552 2
		options[i]->buf_size = ip->client->config->send_options[i].len;
		options[i]->timeout = 0xFFFFFFFF;
@


1.67
log
@protect read() on rtsock against interruptions by signal, foudn with djm
while looking for sth else
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.66 2005/04/02 20:26:10 deraadt Exp $	*/
d952 4
a955 4
		if (!res_hnok(lease->server_name) ) {
			warning("Bogus server name %s",  lease->server_name );
			free_client_lease(lease);
			return (NULL);
a956 1

@


1.66
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.65 2005/04/02 20:23:23 henning Exp $	*/
d173 4
a176 1
	n = read(routefd, &msg, sizeof(msg));
@


1.65
log
@fix indentation both, michael knudsen
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.64 2005/04/02 16:41:09 henning Exp $	*/
d2261 1
a2261 1
				"underscore which violates RFC 952", name);
@


1.64
log
@allow _ in hostnames, but complain since this is not legal, but there is
no point in punishing openbsd users in fucked up networks
From: Michael Knudsen <e@@molioner.dk> with input from theo and me
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.63 2005/02/06 17:10:13 krw Exp $	*/
d2262 1
a2262 1
				warn++;
@


1.63
log
@"no link .got link" => "no link .... got link". i.e. always display
complete ellipsis ('...') and a following space.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.62 2004/12/05 18:35:51 deraadt Exp $	*/
d56 2
a60 13
#define	PERIOD 0x2e
#define	hyphenchar(c) ((c) == 0x2d)
#define	bslashchar(c) ((c) == 0x5c)
#define	periodchar(c) ((c) == PERIOD)
#define	asterchar(c) ((c) == 0x2a)
#define	alphachar(c) (((c) >= 0x41 && (c) <= 0x5a) || \
	    ((c) >= 0x61 && (c) <= 0x7a))
#define	digitchar(c) ((c) >= 0x30 && (c) <= 0x39)

#define	borderchar(c) (alphachar(c) || digitchar(c))
#define	middlechar(c) (borderchar(c) || hyphenchar(c))
#define	domainchar(c) ((c) > 0x20 && (c) < 0x7f)

d2243 1
a2243 1
res_hnok(const char *dn)
d2245 3
a2247 1
	int pch = PERIOD, ch = *dn++;
d2252 1
a2252 1
		if (periodchar(ch)) {
d2254 2
a2255 2
		} else if (periodchar(pch)) {
			if (!borderchar(ch))
d2257 1
a2257 5
		} else if (periodchar(nch) || nch == '\0') {
			if (!borderchar(ch))
				return (0);
		} else {
			if (!middlechar(ch))
d2259 4
d2281 1
a2281 1
		while (periodchar(*buf) || digitchar(*buf))
@


1.62
log
@extend window of "ignoring route messages on the socket" for 10 seconds
instead of 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.61 2004/11/25 11:05:10 claudio Exp $	*/
d315 1
a315 1
		fprintf(stderr, "%s: no link ", ifi->name);
d327 1
a327 1
		fprintf(stderr, "got link\n");
@


1.61
log
@Ignore 0.0.0.0 in RTM_NEWADDR messages as these messages are generated by
dhclient. This fixes the dhclient exiting problem reported by Steve Shockley.
This is a fast fix for the problem acctually the dhclient-script needs to be
replaced. OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.60 2004/09/15 23:33:41 deraadt Exp $	*/
d223 1
a223 1
		if (scripttime == 0 || t < scripttime + 3)
@


1.60
log
@use ftello() instead of ftell() where better
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.59 2004/09/15 18:15:18 henning Exp $	*/
d167 1
d206 2
a216 1
		break;
@


1.59
log
@no \n in error() calls and minor KNF, from Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.58 2004/08/30 07:43:32 otto Exp $	*/
d168 1
d1658 1
a1658 1
	ftruncate(fileno(leaseFile), ftell(leaseFile));
@


1.58
log
@Avoid spinning if the server gives us a bogus zero lease time, by
enforcing a minimum lease time of 60s. ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.57 2004/07/07 17:00:55 deraadt Exp $	*/
d1770 1
a1770 1
		ip->client->scriptEnv[0]=strdup(CLIENT_PATH);
a2032 1
		exit(0);
d2307 1
a2307 1
		error("option_as_string: bad code %d\n", code);
@


1.57
log
@make the shell script execution window 3 seconds.  i really need to find
a better solution...
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.56 2004/06/23 05:15:21 deraadt Exp $	*/
d620 3
@


1.56
log
@better dead detect window code; still crap
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.55 2004/06/22 23:05:28 deraadt Exp $	*/
d220 1
a220 1
		if (scripttime == 0 || t < scripttime + 1)
@


1.55
log
@horrid horrid horrid.  we have a race window where we, ourselves, do an
address deletion.  yesterday we stopped ignoring deletions.  but now
dhclient does not see itself coming up, and voila, we get more and processes.
so now make a 5-second window where we ignore delete messages, but terminate
if we get them at any other time.  a very relucant ok from henning who is
actively searching for a final solution to this problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.54 2004/06/22 01:33:51 henning Exp $	*/
d177 1
d220 3
a222 4
		if (scripttime && time(NULL) > scripttime &&
		    time(NULL) < scripttime + 5)
			goto die;
		break;
d1929 2
@


1.54
log
@do not exit on RTM_DELADDR, dhclient can cause this itself under some rare
circumstances. instead, exit on RTM_NEWADDR if, and only if, the new IP
address is not a lease we got. theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.53 2004/06/03 18:59:44 henning Exp $	*/
d117 2
d219 3
a221 1
		/* goto die; */
d1964 2
d1996 2
@


1.53
log
@fall back to "nobody" when the _dhcp user is not available, theo bob ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.52 2004/05/13 07:19:32 henning Exp $	*/
d103 9
a111 8
int	 findproto(char *, int);
void	 routehandler(struct protocol *);
void	 usage(void);
int	 check_option(struct client_lease *l, int option);
int	 ipv4addrs(char * buf);
int	 res_hnok(const char *dn);
char	*option_as_string(unsigned int code, unsigned char *data, int len);
int	 fork_privchld(int, int);
d147 19
d174 3
d192 18
a209 1
		/* goto die; */
d217 1
a217 1
		goto die;
@


1.52
log
@when trying to rewrite the lease file, and if the lease file is already
opened, do not close and re-open it, which of course fails once we're chrooted
and privilege revoked, but rewind the file and truncate later on as needed.
makes wilfried@@ and Ben Lovett happy (aka, they tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.51 2004/05/08 16:16:33 henning Exp $	*/
d286 5
a290 2
	if ((pw = getpwnam("_dhcp")) == NULL)
		error("no such user: _dhcp");
@


1.51
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.50 2004/05/07 23:05:19 krw Exp $	*/
d1592 8
a1599 5
	if (leaseFile)
		fclose(leaseFile);
	leaseFile = fopen(path_dhclient_db, "w");
	if (!leaseFile)
		error("can't create %s: %m", path_dhclient_db);
d1607 2
@


1.50
log
@Error out on attempts to inject command or variable substitution
into dhclient-script environment variables.

Inspiration from todd@@.

ok henning@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.49 2004/05/06 22:29:15 deraadt Exp $	*/
d1985 1
a1985 1
	int i, namelen;
d2025 2
a2026 2
	for (i=0; i < strlen(value); i++)
		switch (value[i]) {
d2029 1
a2029 1
			error("illegal character (%c) in value '%s'", value[i],
@


1.49
log
@remove more unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.48 2004/05/05 23:07:47 deraadt Exp $	*/
d2024 9
@


1.48
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.47 2004/05/05 22:21:03 deraadt Exp $	*/
a93 1
#if !defined (TIME_MAX)
a94 1
#endif
d412 4
a415 3
/* Called when a lease has completely expired and we've been unable to
   renew it. */

d437 4
a440 3
/* state_selecting is called when one or more DHCPOFFER packets have been
   received and a configurable period of time has passed. */

a444 1

a1329 1
	options[i]->tree = NULL;
a1338 1
	options[i]->tree = NULL;
a1348 1
		options[i]->tree = NULL;
a1363 1
			options[i]->tree = NULL;
a1410 1
	options[i]->tree = NULL;
a1419 1
	options[i]->tree = NULL;
a1430 1
		options[i]->tree = NULL;
a1440 1
		options[i]->tree = NULL;
a1455 1
			options[i]->tree = NULL;
a1513 1
	options[i]->tree = NULL;
a1521 1
	options[i]->tree = NULL;
a1529 1
	options[i]->tree = NULL;
a1538 1
		options[i]->tree = NULL;
@


1.47
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.46 2004/05/05 14:29:16 deraadt Exp $	*/
d1508 3
a1511 5
	struct tree_cache *options[256];
	struct tree_cache message_type_tree;
	struct tree_cache requested_address_tree;
	struct tree_cache server_id_tree;
	struct tree_cache client_id_tree;
d1624 2
a1626 2
	struct tm *t;
	static int leases_written;
d1684 1
a1687 2
	size_t		 len;
	size_t		 mediumlen = 0;
d1747 1
a1747 1
	int i;
d1749 1
a1749 1
	int len = 0;
a1750 1
	struct interface_info *ip = ifi;
d1760 1
a1760 2
		memcpy(netmask.iabuf,
		    lease->options[DHO_SUBNET_MASK].data,
d1858 1
d1860 1
a1860 1
						 &dhcp_options[i]))
d1872 1
a1875 1
	size_t		 fn_len = 0, sn_len = 0, pr_len= 0;
d1886 1
a1886 2
	    sizeof(size_t) + fn_len +
	    sizeof(size_t) + sn_len +
d1952 1
a1952 5
	char *scriptName;
	char *argv[2];
	char **envp;
	char *epp[3];
	char reason[] = "REASON=NBI";
d1954 1
a1955 1
	struct interface_info *ip = ifi;
d2016 1
d2255 3
a2257 6
		if (!isascii(*dp) ||
		    !isprint(*dp)) {
			if (dp + 1 != data + len ||
			    *dp != 0) {
				snprintf(op, opleft,
				    "\\%03o", *dp);
d2261 2
a2262 5
		} else if (*dp == '"' ||
		    *dp == '\'' ||
		    *dp == '$' ||
		    *dp == '`' ||
		    *dp == '\\') {
a2279 1

d2283 2
a2284 2
	int			 nfds;
	struct pollfd		 pfd[1];
a2315 1

@


1.46
log
@must simulate daemon because already inside the jail; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.45 2004/05/05 13:21:49 henning Exp $	*/
d2121 18
a2138 18
	case DHO_SUBNET_MASK :
	case DHO_TIME_SERVERS :
	case DHO_NAME_SERVERS :
	case DHO_ROUTERS :
	case DHO_DOMAIN_NAME_SERVERS :
	case DHO_LOG_SERVERS :
	case DHO_COOKIE_SERVERS :
	case DHO_LPR_SERVERS :
	case DHO_IMPRESS_SERVERS :
	case DHO_RESOURCE_LOCATION_SERVERS :
	case DHO_SWAP_SERVER :
	case DHO_BROADCAST_ADDRESS :
	case DHO_NIS_SERVERS :
	case DHO_NTP_SERVERS :
	case DHO_NETBIOS_NAME_SERVERS :
	case DHO_NETBIOS_DD_SERVER :
	case DHO_FONT_SERVERS :
	case DHO_DHCP_SERVER_IDENTIFIER :
d2144 3
a2146 3
	case DHO_HOST_NAME :
	case DHO_DOMAIN_NAME :
	case DHO_NIS_DOMAIN :
d2153 43
a2195 43
	case DHO_PAD :
	case DHO_TIME_OFFSET :
	case DHO_BOOT_SIZE :
	case DHO_MERIT_DUMP :
	case DHO_ROOT_PATH :
	case DHO_EXTENSIONS_PATH :
	case DHO_IP_FORWARDING :
	case DHO_NON_LOCAL_SOURCE_ROUTING :
	case DHO_POLICY_FILTER :
	case DHO_MAX_DGRAM_REASSEMBLY :
	case DHO_DEFAULT_IP_TTL :
	case DHO_PATH_MTU_AGING_TIMEOUT :
	case DHO_PATH_MTU_PLATEAU_TABLE :
	case DHO_INTERFACE_MTU :
	case DHO_ALL_SUBNETS_LOCAL :
	case DHO_PERFORM_MASK_DISCOVERY :
	case DHO_MASK_SUPPLIER :
	case DHO_ROUTER_DISCOVERY :
	case DHO_ROUTER_SOLICITATION_ADDRESS :
	case DHO_STATIC_ROUTES :
	case DHO_TRAILER_ENCAPSULATION :
	case DHO_ARP_CACHE_TIMEOUT :
	case DHO_IEEE802_3_ENCAPSULATION :
	case DHO_DEFAULT_TCP_TTL :
	case DHO_TCP_KEEPALIVE_INTERVAL :
	case DHO_TCP_KEEPALIVE_GARBAGE :
	case DHO_VENDOR_ENCAPSULATED_OPTIONS :
	case DHO_NETBIOS_NODE_TYPE :
	case DHO_NETBIOS_SCOPE :
	case DHO_X_DISPLAY_MANAGER :
	case DHO_DHCP_REQUESTED_ADDRESS :
	case DHO_DHCP_LEASE_TIME :
	case DHO_DHCP_OPTION_OVERLOAD :
	case DHO_DHCP_MESSAGE_TYPE :
	case DHO_DHCP_PARAMETER_REQUEST_LIST :
	case DHO_DHCP_MESSAGE :
	case DHO_DHCP_MAX_MESSAGE_SIZE :
	case DHO_DHCP_RENEWAL_TIME :
	case DHO_DHCP_REBINDING_TIME :
	case DHO_DHCP_CLASS_IDENTIFIER :
	case DHO_DHCP_CLIENT_IDENTIFIER :
	case DHO_DHCP_USER_CLASS_ID :
	case DHO_END :
@


1.45
log
@open the lease file after the priv child was forked off so it doesn't have
a copy of this fd
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.44 2004/05/05 11:40:46 henning Exp $	*/
d82 1
d285 3
d2095 9
d2312 4
@


1.44
log
@routefd needs to be opened slightly later
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.43 2004/05/05 11:19:07 henning Exp $	*/
a266 5
	if ((fd = open(path_dhclient_db, O_RDONLY|O_EXLOCK|O_CREAT, 0)) == -1)
		error("can't open and lock %s: %m", path_dhclient_db);
	read_client_leases();
	rewrite_client_leases();
	close(fd);
d294 6
@


1.43
log
@use tzset() before chrooting
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.42 2004/05/05 10:51:23 henning Exp $	*/
a299 3
	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) != -1)
		add_protocol("AF_ROUTE", routefd, routehandler, ifi);

d304 3
@


1.42
log
@open bpf and routefd a little later, after forking the priv child so it
doesn't get copies of those fds
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.41 2004/05/04 22:23:01 mickey Exp $	*/
d215 1
a215 1
	openlog(__progname, LOG_NDELAY, DHCPD_LOG_FACILITY);
d256 1
a256 1
	/* Get the current time... */
@


1.41
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.40 2004/05/04 20:28:40 deraadt Exp $	*/
a288 11
	priv_script_init("PREINIT", NULL);
	if (ifi->client->alias)
		priv_script_write_params("alias_", ifi->client->alias);
	priv_script_go();

	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) != -1)
		add_protocol("AF_ROUTE", routefd, routehandler, ifi);

	/* set up the interface */
	discover_interfaces(ifi);

d299 11
@


1.40
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.39 2004/05/04 18:58:50 deraadt Exp $	*/
d855 1
a855 1
		warn("dhcpoffer: no memory to record lease.");
d867 1
a867 1
				warn("dhcpoffer: no memory for option %d", i);
d881 1
a881 1
				warn("Invalid lease option - ignoring offer");
d897 1
a897 1
			warn("dhcpoffer: no memory for server name.");
d904 1
a904 1
			warn("Bogus server name %s",  lease->server_name );
d918 1
a918 1
			warn("dhcpoffer: no memory for filename.");
d1806 1
a1806 1
						warn("no space to %s %s",
d1828 1
a1828 1
						warn("no space to %s %s",
d2126 1
a2126 1
			warn("Invalid IP address in option: %s", opbuf);
d2134 1
a2134 1
			warn("Bogus Host Name option %d: %s (%s)", option,
d2184 1
a2184 1
		warn("unknown dhcp option value 0x%x", option);
d2276 1
a2276 1
	warn("dhcp option too large");
@


1.39
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.38 2004/05/04 12:52:05 henning Exp $	*/
a75 2
time_t max_lease_time = 86400; /* 24 hours... */
struct tree_cache *global_options[256];
a83 1
struct iaddr iaddr_any = { 4, { 0, 0, 0, 0 } };
a1307 14
send_release(void *ipp)
{
	struct interface_info *ip = ipp;

	note("DHCPRELEASE on %s to %s port %d", ip->name,
	    inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port));

	/* Send out a packet. */
	(void) send_packet(ip, &ip->client->packet, ip->client->packet_length,
	    inaddr_any, &sockaddr_broadcast, NULL);
}

void
a1580 56
make_release(struct interface_info *ip, struct client_lease *lease)
{
	unsigned char request = DHCPRELEASE;
	struct tree_cache *options[256];
	struct tree_cache message_type_tree;
	struct tree_cache server_id_tree;
	int i;

	memset(options, 0, sizeof(options));
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPRELEASE */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i] = &message_type_tree;
	options[i]->value = &request;
	options[i]->len = sizeof(request);
	options[i]->buf_size = sizeof(request);
	options[i]->timeout = 0xFFFFFFFF;
	options[i]->tree = NULL;

	/* Send back the server identifier... */
	i = DHO_DHCP_SERVER_IDENTIFIER;
	options[i] = &server_id_tree;
	options[i]->value = lease->options[i].data;
	options[i]->len = lease->options[i].len;
	options[i]->buf_size = lease->options[i].len;
	options[i]->timeout = 0xFFFFFFFF;
	options[i]->tree = NULL;

	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = arc4random();
	ip->client->packet.secs = 0;
	ip->client->packet.flags = 0;

	memset(&ip->client->packet.ciaddr, 0,
	    sizeof(ip->client->packet.ciaddr));
	memset(&ip->client->packet.yiaddr, 0,
	    sizeof(ip->client->packet.yiaddr));
	memset(&ip->client->packet.siaddr, 0,
	    sizeof(ip->client->packet.siaddr));
	memset(&ip->client->packet.giaddr, 0,
	    sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
}

void
a1676 3

char scriptName[256];
FILE *scriptFile;
@


1.38
log
@privilege seperate dhclient.
the privileged child's duty is the dhclient-script env setup & exection.
the parent process now chroots to /var/empty and drops privileges to _dhcp
mostly hacked at vancouver airport
with some feedback from krw@@ and otto@@, tested to not break installs by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.37 2004/04/14 20:14:49 henning Exp $	*/
d202 1
a202 1
	script_init(ifi, "FAIL", NULL);
d204 2
a205 2
		script_write_params(ifi, "alias_", ifi->client->alias);
	script_go(ifi);
d463 2
a464 2
			script_init(ip, "ARPCHECK", lp->medium);
			script_write_params(ip, "check_", lp);
d470 1
a470 1
			if (script_go(ip)) {
d613 1
a613 1
	script_init(ip, (ip->client->state == S_REQUESTING ? "BOUND" :
d618 2
a619 2
		script_write_params(ip, "old_", ip->client->active);
	script_write_params(ip, "new_", ip->client->new);
d621 2
a622 2
		script_write_params(ip, "alias_", ip->client->alias);
	script_go(ip);
d787 2
a788 2
	script_init(ip, "ARPSEND", lease->medium);
	script_write_params(ip, "check_", lease);
d791 1
a791 1
	if (script_go(ip))
d975 1
a975 4

	int result;
	int interval;
	int increase = 1;
d1007 2
a1008 2
		script_init(ip, "MEDIUM", ip->client->medium);
		if (script_go(ip))
d1059 2
a1060 2
	result = send_packet(ip, NULL, &ip->client->packet,
	    ip->client->packet_length, inaddr_any, &sockaddr_broadcast, NULL);
a1074 1

d1092 1
a1092 1
			script_init(ip, "TIMEOUT",
d1094 1
a1094 1
			script_write_params(ip, "new_", ip->client->active);
d1096 1
a1096 1
				script_write_params(ip, "alias_",
d1102 1
a1102 1
			if (!script_go(ip)) {
d1154 1
a1154 1
	script_init(ip, "FAIL", NULL);
d1156 2
a1157 2
		script_write_params(ip, "alias_", ip->client->alias);
	script_go(ip);
a1167 3

	int result;
	int interval;
d1170 1
d1200 1
a1200 1
		script_init(ip, "MEDIUM", ip->client->active->medium);
d1203 1
a1203 1
		if (script_go(ip))
d1215 2
a1216 2
		script_init(ip, "EXPIRE", NULL);
		script_write_params(ip, "old_", ip->client->active);
d1218 2
a1219 2
			script_write_params(ip, "alias_", ip->client->alias);
		script_go(ip);
d1223 1
a1223 1
		script_init(ip, "PREINIT", NULL);
d1225 2
a1226 2
			script_write_params(ip, "alias_", ip->client->alias);
		script_go(ip);
d1290 2
a1291 2
	result = send_packet(ip, NULL, &ip->client->packet,
	    ip->client->packet_length, from, &destination, NULL);
a1299 1
	int result;
d1306 2
a1307 2
	result = send_packet(ip, NULL, &ip->client->packet,
	    ip->client->packet_length, inaddr_any, &sockaddr_broadcast, NULL);
a1314 2
	int result;

d1320 2
a1321 2
	result = send_packet(ip, NULL, &ip->client->packet,
	    ip->client->packet_length, inaddr_any, &sockaddr_broadcast, NULL);
a1327 2
	int i;

d1330 1
a1413 2
	int i;

d1416 1
a1520 2
	int i;

d1526 1
a1600 2
	int i;

d1604 1
d1755 1
a1755 1
script_init(struct interface_info *ip, char *reason, struct string_list *medium)
d1945 1
a1945 2
script_write_params(struct interface_info *ip, char *prefix,
    struct client_lease *lease)
d1996 1
a1996 1
script_go(struct interface_info *ip)
@


1.37
log
@prototypes fixup
@
text
@d1 1
a1 3
/*	$OpenBSD: dhclient.c,v 1.36 2004/04/13 18:04:09 henning Exp $	*/

/* DHCP Client. */
d57 1
d83 1
d114 1
d214 2
d292 1
a292 1
	script_init(ifi, "PREINIT", NULL);
d294 2
a295 2
		script_write_params(ifi, "alias_", ifi->client->alias);
	script_go(ifi);
d303 25
d1770 38
d1825 1
a1825 2
			script_set_env(ip->client, "", "medium",
			    medium->string);
d1832 1
a1832 2
script_write_params(struct interface_info *ip, char *prefix,
    struct client_lease *lease)
d1838 1
d1957 52
d2012 30
d2049 1
d2369 35
@


1.36
log
@unfortunately we have to wait a little if the nic does not have a link and
check again, theo help & ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.35 2004/04/08 15:36:38 henning Exp $	*/
d107 2
@


1.35
log
@fix usage(), jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.34 2004/04/08 01:13:30 henning Exp $	*/
d210 1
a210 1
	int			 ch, fd, quiet = 0;
d271 20
a290 7
	if (interface_link_status(ifi->name)) {
		script_init(ifi, "PREINIT", NULL);
		if (ifi->client->alias)
			script_write_params(ifi, "alias_", ifi->client->alias);
		script_go(ifi);
	} else
		error("no link on interface %s", ifi->name);
@


1.34
log
@-l can overwrite the path to the leases file, noticed by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.33 2004/04/07 20:18:48 henning Exp $	*/
d301 1
a301 1
	fprintf(stderr, "usage: %s [-dDqu] ", __progname);
@


1.33
log
@remove -D option which had no effect whatsover
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.32 2004/04/07 20:14:46 henning Exp $	*/
d81 1
a81 1
char *path_dhclient_db;
d247 2
a248 2
	if (asprintf(&path_dhclient_db, "%s.%s", _PATH_DHCLIENT_DB,
	    ifi->name) == -1)
@


1.32
log
@since we removed all the multiple interfaces crap, we now need a lease
file per interface, and not one for all. Use /var/db/dhclient.leases.IFNAME
discussed with pb@@ quite some time ago, ok tdeval@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.31 2004/03/05 23:57:16 deraadt Exp $	*/
a101 1
int		save_scripts;
d216 1
a216 1
	while ((ch = getopt(argc, argv, "c:dDl:qu")) != -1)
a222 3
			break;
		case 'D':
			save_scripts = 1;
@


1.31
log
@remove even more goo
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.30 2004/03/02 18:49:21 deraadt Exp $	*/
d81 1
a81 1
char *path_dhclient_db = _PATH_DHCLIENT_DB;
d249 5
a253 1
	strlcpy(ifi->name, argv[0], IFNAMSIZ);
@


1.30
log
@more pruning; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.29 2004/03/02 15:58:41 henning Exp $	*/
a303 5
}

void
cleanup(void)
{
@


1.29
log
@use daemon(3) instead of homebrown gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.28 2004/03/02 15:52:40 henning Exp $	*/
d646 1
a646 1
	     ap; ap = ap->next) {
d682 1
a682 1
	     ap; ap = ap->next) {
d725 1
a725 1
	     lease; lease = lease->next) {
d845 1
a845 1
			        /* ignore a bogus lease offer */
d880 1
a880 1
		        /* Don't count on the NUL terminator. */
@


1.28
log
@zap unused and empty functions and some glorious very much needed comments
that explain us that "if (foo > 255) { error() } " ensures that foo is not
bigger than 255
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.27 2004/03/02 15:41:44 henning Exp $	*/
a2010 1
	int pid;
d2012 1
a2012 2
	/* Don't become a daemon if the user requested otherwise. */
	if (no_daemon)
a2014 3
	/* Only do it once. */
	if (state)
		return;
d2020 2
a2021 13
	/* Become a daemon... */
	if ((pid = fork()) < 0)
		error("Can't fork daemon: %m");
	else if (pid)
		exit(0);
	/* Become session leader and get pid... */
	pid = setsid();

	/* Close standard I/O descriptors. */
	close(0);
	close(1);
	close(2);

@


1.27
log
@zap interface flags
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.26 2004/03/02 15:34:03 henning Exp $	*/
a634 11
int
commit_leases(void)
{
	return (0);
}

void
db_startup(void)
{
}

a1709 3
	/* Note: the following is not a Y2K bug - it's a Y1.9K bug.   Until
	   somebody invents a time machine, I think we can safely disregard
	   it. */
a1725 3
/* Variables holding name of script and file pointer for writing to
   script.   Needless to say, this is not reentrant - only one script
   can be invoked at a time. */
a1767 7
	/* For the benefit of Linux (and operating systems which may
	   have similar needs), compute the network address based on
	   the supplied ip address and netmask, if provided.  Also
	   compute the broadcast address (the host address all ones
	   broadcast address, not the host address all zeroes
	   broadcast address). */

a2072 4
		/* These should be a list of one or more IP addresses,
		 * separated by spaces. If they aren't, this lease is not
		 * valid.
		 */
a2080 1
		/* This has to be a valid internet domain name */
a2129 1
		/* do nothing */
a2184 2
/* Format the specified option as a string */

a2192 1
	/* Code should be between 0 and 255. */
@


1.26
log
@use arc4random(), markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.25 2004/03/02 13:39:44 henning Exp $	*/
a249 1
	ifi->flags = INTERFACE_REQUESTED;
@


1.25
log
@we deal with one interface at a time, so remove the interface list gunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.24 2004/03/02 13:00:02 henning Exp $	*/
a285 2
	srandom(arc4random());

d359 1
a359 1
	ip->client->xid = random();
d1001 1
a1001 1
			ip->client->interval += (random() >> 2) %
d1010 1
a1010 1
				 + ((random () >> 2) %
d1217 1
a1217 1
		ip->client->interval += ((random () >> 2) %
d1225 1
a1225 1
		    ((random () >> 2) % ip->client->interval));
d1624 1
a1624 1
	ip->client->packet.xid = random();
@


1.24
log
@if our interface vanishes (pcmcia and such), exit.
fixes PR3648, test & ok pb
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.23 2004/03/02 12:56:30 henning Exp $	*/
d106 2
a113 13

struct interface_info *
isours(u_int16_t index)
{
	struct interface_info *ip;

	for (ip = interfaces; ip; ip = ip->next)
		if (index == ip->index)
			return (ip);

	return (NULL);
}

a155 1
	struct interface_info *ip;
d167 1
a167 1
		if ((ip = isours(ifam->ifam_index)) == NULL)
d175 1
a175 1
		if ((ip = isours(ifam->ifam_index)) == NULL)
d183 1
a183 1
		if ((ip = isours(ifm->ifm_index)) == NULL)
d191 1
a191 1
		    (ip = isours(ifan->ifan_index)) != NULL)
d200 4
a203 4
	script_init(ip, "FAIL", NULL);
	if (ip->client->alias)
		script_write_params(ip, "alias_", ip->client->alias);
	script_go(ip);
d211 1
a211 2
	struct interface_info	*ip = NULL;
	int			 ch, fd, seed, quiet = 0;
d247 1
a247 1
	if ((ip = calloc(1, sizeof(struct interface_info))) == NULL)
d249 2
a250 3
	strlcpy(ip->name, argv[0], IFNAMSIZ);
	ip->flags = INTERFACE_REQUESTED;
	interfaces = ip;
d272 5
a276 5
	if (interface_link_status(ip->name)) {
		script_init(ip, "PREINIT", NULL);
		if (ip->client->alias)
			script_write_params(ip, "alias_", ip->client->alias);
		script_go(ip);
d278 1
a278 1
		error("no link on interface %s", ip->name);
d281 1
a281 1
		add_protocol("AF_ROUTE", routefd, routehandler, interfaces);
d283 2
a284 2
	/* set up the interfaces. */
	discover_interfaces(ip);
d286 1
a286 13
	/* Make up a seed for the random number generator from current
	   time plus the sum of the last four bytes of each
	   interface's hardware address interpreted as an integer.
	   Not much entropy, but we're booting, so we're not likely to
	   find anything better. */
	seed = 0; /* Unfortunately, what's on the stack isn't random. :') */
	for (ip = interfaces; ip; ip = ip->next) {
		int junk;
		memcpy(&junk, &ip->hw_address.haddr[ip->hw_address.hlen -
		    sizeof(seed)], sizeof(seed));
		seed += junk;
	}
	srandom(seed + cur_time);
d288 2
a289 5
	/* Start a configuration state machine for each interface. */
	for (ip = interfaces; ip; ip = ip->next) {
		ip->client->state = S_INIT;
		state_reboot(ip);
	}
a290 1
	/* Set up the bootp packet handler... */
a292 1
	/* Start dispatching packets and timeouts... */
d295 1
a295 1
	/*NOTREACHED*/
a1662 1
	struct interface_info *ip;
d1671 4
a1674 8
	/* Write out all the leases attached to configured interfaces that
	   we know about. */
	for (ip = interfaces; ip; ip = ip->next) {
		for (lp = ip->client->leases; lp; lp = lp->next)
			write_client_lease(ip, lp, 1);
		if (ip->client->active)
			write_client_lease(ip, ip->client->active, 1);
	}
@


1.23
log
@remove dummy_interfaces and fallback_interface gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.22 2004/03/02 12:46:44 henning Exp $	*/
d166 1
d198 6
@


1.22
log
@our interface discovery is so quiet now (nonexistant) that we don't need a
quiet_interface_discovery flag any more
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.21 2004/03/02 12:40:31 henning Exp $	*/
d1295 3
a1297 9
	if (destination.sin_addr.s_addr != INADDR_BROADCAST &&
	    fallback_interface)
		result = send_packet(fallback_interface, NULL,
		    &ip->client->packet, ip->client->packet_length, from,
		    &destination, NULL);
	else
		/* Send out a packet. */
		result = send_packet(ip, NULL, &ip->client->packet,
		    ip->client->packet_length, from, &destination, NULL);
a1704 8
	/* Write out any leases that are attached to interfaces that aren't
	   currently configured. */
	for (ip = dummy_interfaces; ip; ip = ip->next) {
		for (lp = ip->client->leases; lp; lp = lp->next)
			write_client_lease(ip, lp, 1);
		if (ip->client->active)
			write_client_lease(ip, ip->client->active, 1);
	}
@


1.21
log
@since we're dealing with one interface and not quite a few ones we can give
this one onterface as parameter to discove_interfaces and get rid of quite
some of the multiple-interface-discover logic
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.20 2004/02/24 17:26:43 henning Exp $	*/
a238 1
			quiet_interface_discovery = 1;
@


1.20
log
@whack unused token ring code and a few empty functions
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.19 2004/02/24 15:35:56 henning Exp $	*/
d292 1
a292 1
	discover_interfaces();
@


1.19
log
@get rid of tons of structs we never use, a lot of new_someotherjunk functions
in alloc.c we never call, and a shitload of genius comments like
char *script_name; /* name of script */
char *server_name; /* name of server */
etc etc etc...
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.18 2004/02/24 14:49:08 henning Exp $	*/
d1412 1
a1412 5

	if (can_receive_unicast_unconfigured(ip))
		ip->client->packet.flags = 0;
	else
		ip->client->packet.flags = htons(BOOTP_BROADCAST);
d1522 1
a1522 4
		if (can_receive_unicast_unconfigured(ip))
			ip->client->packet.flags = 0;
		else
			ip->client->packet.flags = htons(BOOTP_BROADCAST);
@


1.18
log
@discover_interfaces doesn't run in multiple modes any more - kill unreachable
code, partitally server-only
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.17 2004/02/24 14:36:17 henning Exp $	*/
a664 6
{
	return (0);
}

int
write_lease(struct lease *lease)
@


1.17
log
@kill debug crap
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.16 2004/02/24 13:36:13 henning Exp $	*/
d292 1
a292 1
	discover_interfaces(DISCOVER_REQUESTED);
@


1.16
log
@remove dynamic port gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.15 2004/02/24 13:21:32 henning Exp $	*/
a272 1
	/* Parse the dhclient.conf file. */
d274 1
a274 4

	/* Lock the leases file */
	fd = open(path_dhclient_db, O_RDONLY | O_EXLOCK | O_CREAT, 0);
	if (fd < 0)
a275 2

	/* Parse the lease database. */
a276 2

	/* Rewrite the lease database... */
a277 2

	/* Close and unlock */
d288 1
a288 2
	routefd = socket(PF_ROUTE, SOCK_RAW, 0);
	if (routefd != -1)
d530 1
a530 4
	    packet->raw->chaddr, packet->raw->hlen))) {
#ifdef DEBUG
		debug("DHCPACK in wrong transaction.");
#endif
a531 1
	}
d536 1
a536 4
	    ip->client->state != S_REBINDING) {
#ifdef DEBUG
		debug("DHCPACK in wrong state.");
#endif
a537 1
	}
a745 4
#ifdef DEBUG_PACKET
	dump_packet(packet);
#endif

d752 1
a752 4
	    packet->raw->chaddr, packet->raw->hlen))) {
#ifdef DEBUG
		debug("%s in wrong transaction.", name);
#endif
a753 1
	}
d948 1
a948 4
	    packet->raw->chaddr, packet->raw->hlen))) {
#ifdef DEBUG
		debug("DHCPNAK in wrong transaction.");
#endif
a949 1
	}
d954 1
a954 4
	    ip->client->state != S_REBINDING) {
#ifdef DEBUG
		debug("DHCPNAK in wrong state.");
#endif
a955 1
	}
a1433 5

#ifdef DEBUG_PACKET
	dump_packet(sendpkt);
	dump_raw((unsigned char *)ip->client->packet, sendpkt->packet_length);
#endif
a1545 5

#ifdef DEBUG_PACKET
	dump_packet(sendpkt);
	dump_raw((unsigned char *)ip->client->packet, sendpkt->packet_length);
#endif
a1626 5

#ifdef DEBUG_PACKET
	dump_packet(sendpkt);
	dump_raw((unsigned char *)ip->client->packet, sendpkt->packet_length);
#endif
a1683 6

#ifdef DEBUG_PACKET
	dump_packet(sendpkt);
	dump_raw((unsigned char *)ip->client->packet,
	    ip->client->packet_length);
#endif
@


1.15
log
@cut unreachable code
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.14 2004/02/24 13:08:26 henning Exp $	*/
a99 2
u_int16_t	local_port;
u_int16_t	remote_port;
a215 1
	struct servent		*ent;
a262 10
	/* Default to the DHCP/BOOTP port. */
	if (!local_port) {
		ent = getservbyname("dhcpc", "udp");
		if (!ent)
			local_port = htons(68);
		else
			local_port = ent->s_port;
	}
	remote_port = htons(ntohs(local_port) - 1);	/* XXX */

d268 1
a268 1
	sockaddr_broadcast.sin_port = remote_port;
d1314 1
a1314 1
	destination.sin_port = remote_port;
@


1.14
log
@cut more crap - no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.13 2004/02/24 12:41:28 henning Exp $	*/
a82 2
int interfaces_requested = 0;

a104 1
int		onetry = 0;
a260 1
	interfaces_requested = 1;
a302 3
	if (!interfaces_requested)
		error("no interface given");

a1211 2
	if (onetry)
		exit(1);
@


1.13
log
@kill pidfile gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.12 2004/02/24 12:34:26 henning Exp $	*/
d97 4
@


1.12
log
@teach dhclient about another invention of the last century: getopt(3)
also fix usage() that was a big lie
pb sez ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.11 2004/02/24 11:35:39 henning Exp $	*/
a81 1
char *path_dhclient_pid = _PATH_DHCLIENT_PID;
d98 14
a111 7
u_int16_t local_port;
u_int16_t remote_port;
int log_priority;
int no_daemon;
int save_scripts;
int onetry = 0;
int unknown_ok = 1;
a112 11
void	usage(void);

static int check_option(struct client_lease *l, int option);

static int ipv4addrs(char * buf);

static int res_hnok(const char *dn);

char *option_as_string(unsigned int code, unsigned char *data, int len);

int routefd;
d2172 1
a2172 2
	if (no_daemon) {
		write_client_pid_file();
a2173 1
	}
a2195 23
	write_client_pid_file();
}

void
write_client_pid_file()
{
	FILE *pf;
	int pfdesc;

	pfdesc = open(path_dhclient_pid, O_CREAT | O_TRUNC | O_WRONLY, 0644);

	if (pfdesc < 0) {
		warn("Can't create %s: %m", path_dhclient_pid);
		return;
	}

	pf = fdopen(pfdesc, "w");
	if (!pf)
		warn("Can't fdopen %s: %m", path_dhclient_pid);
	else {
		fprintf(pf, "%ld\n", (long)getpid());
		fclose(pf);
	}
@


1.11
log
@remove ill-advised interface discovery-scan, and require an interface to be
always given.
theo agrees with removal, pb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.10 2004/02/23 20:09:02 deraadt Exp $	*/
d6 1
d107 1
a107 1
static void usage(char *);
d221 4
a224 12
	int i, fd;
	struct servent *ent;
	struct interface_info *ip = NULL;
	int seed;
	int quiet = 0;
	char *s;

	s = strrchr(argv[0], '/');
	if (!s)
		s = argv[0];
	else
		s++;
d227 1
a227 1
	openlog(s, LOG_NDELAY, DHCPD_LOG_FACILITY);
d230 6
a235 8
	for (i = 1; i < argc; i++) {
		if (!strcmp(argv[i], "-p")) {
			if (++i == argc)
				usage(s);
			local_port = htons(atoi(argv[i]));
			debug("binding to user-specified port %d",
			    ntohs(local_port));
		} else if (!strcmp(argv[i], "-d")) {
d237 2
a238 1
		} else if (!strcmp(argv[i], "-D")) {
d240 5
a244 13
		} else if (!strcmp(argv[i], "-cf")) {
			if (++i == argc)
				usage(s);
			path_dhclient_conf = argv[i];
		} else if (!strcmp(argv[i], "-pf")) {
			if (++i == argc)
				usage(s);
			path_dhclient_pid = argv[i];
		} else if (!strcmp(argv[i], "-lf")) {
			if (++i == argc)
				usage(s);
			path_dhclient_db = argv[i];
		} else if (!strcmp(argv[i], "-q")) {
d247 2
a248 1
		} else if (!strcmp(argv[i], "-u")) {
d250 3
a252 12
		} else if (!strcmp(argv[i], "-1")) {
			onetry = 1;
		} else if (argv[i][0] == '-') {
			usage(s);
		} else {
			if ((ip = calloc(1, sizeof(struct interface_info))) ==
			    NULL)
				error("calloc");
			strlcpy(ip->name, argv[i], IFNAMSIZ);
			ip->flags = INTERFACE_REQUESTED;
			interfaces_requested = 1;
			interfaces = ip;
d254 13
a266 1
	}
d356 2
a357 2
static void
usage(char *appname)
d359 5
a363 2
	warn("Usage: %s [-c1u] [-p <port>] [-lf lease-file]", appname);
	error("       [-pf pidfile] [interface]");
@


1.10
log
@remove time_t related crud; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.9 2004/02/10 13:12:48 henning Exp $	*/
d222 1
a222 1
	struct interface_info *ip;
a225 1
	int ifs = 0;
d270 7
a276 11
		    struct interface_info *tmp =
			dmalloc(sizeof(*tmp), "specified_interface");
		    if (!tmp)
			error("Insufficient memory to %s %s",
			    "record interface", argv[i]);
		    memset(tmp, 0, sizeof(*tmp));
		    strlcpy(tmp->name, argv[i], IFNAMSIZ);
		    tmp->next = interfaces;
		    tmp->flags = INTERFACE_REQUESTED;
		    interfaces_requested = 1;
		    interfaces = tmp;
a302 3
	/* Discover all the network interfaces. */
	discover_interfaces(DISCOVER_UNCONFIGURED);

d320 2
a321 29
	/* If no broadcast interfaces were discovered, call the script
	   and tell it so. */
	if (!interfaces) {
		script_init(NULL, "NBI", NULL);
		script_go(NULL);

		note("No broadcast interfaces found - exiting.");
		/* Nothing more to do. */
		exit(0);
	} else {
		/* Call the script with the list of interfaces. */
		for (ip = interfaces; ip; ip = ip->next) {
			/* If interfaces were specified, don't configure
			   interfaces that weren't specified! */
			if (interfaces_requested &&
			    ((ip->flags & (INTERFACE_REQUESTED |
					     INTERFACE_AUTOMATIC)) !=
			     INTERFACE_REQUESTED))
				continue;
			if (!interface_link_status(ip->name))
				continue;
			ifs++;
			script_init(ip, "PREINIT", NULL);
			if (ip->client->alias)
				script_write_params(ip, "alias_",
						     ip->client->alias);
			script_go(ip);
		}
	}
d323 7
a329 4
	if (ifs == 0) {
		note("No active interfaces found - exiting.");
		exit(0);
	}
d335 2
a336 6
	/* At this point, all the interfaces that the script thinks
	   are relevant should be running, so now we once again call
	   discover_interfaces(), and this time ask it to actually set
	   up the interfaces. */
	discover_interfaces(interfaces_requested ? DISCOVER_REQUESTED :
	    DISCOVER_RUNNING);
@


1.9
log
@at startup, before sending several DHCPDISCOVER and waiting ages for answers,
check the link state of the interface(s) in question and don't try on
intrfaces that for sure have no link. interfaces with unknown linkstates are
treated as if they had a link, not all drivers are capable of reporting
linkstate upstream, and for some media there is no such thing as a link state.
saves quite sme time when booting notebooks configured for dhcp without
teh cable inserted...
note that this is the not yet active copy of dhclient
ok grange@@ mcbride@@ pb@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.8 2004/02/07 14:03:48 henning Exp $	*/
d74 3
a76 3
TIME cur_time;
TIME default_lease_time = 43200; /* 12 hours... */
TIME max_lease_time = 86400; /* 24 hours... */
d299 1
a299 1
	GET_TIME(&cur_time);
@


1.8
log
@zap stupid message
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.7 2004/02/07 13:59:45 henning Exp $	*/
d226 1
d347 3
d356 5
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.6 2004/02/07 13:26:35 henning Exp $	*/
a105 7
static char copyright[] =
"Copyright 1995, 1996, 1997, 1998, 1999 The Internet Software Consortium.";
static char arr[] = "All rights reserved.";
static char message[] = "Internet Software Consortium DHCP Client";
static char contrib[] = "Please contribute if you find this software useful.";
static char url[] = "For info, please visit http://www.isc.org/dhcp-contrib.html";

a397 8
	note("%s", message);
	note("%s", copyright);
	note("%s", arr);
	note("%s", "");
	note("%s", contrib);
	note("%s", url);
	note("%s", "");

@


1.6
log
@more KNF From: Emil Mikulic <emikulic@@dmr.ath.cx>
great job.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.5 2004/02/05 13:39:32 henning Exp $	*/
d59 12
a70 12
#define PERIOD 0x2e
#define hyphenchar(c) ((c) == 0x2d)
#define bslashchar(c) ((c) == 0x5c)
#define periodchar(c) ((c) == PERIOD)
#define asterchar(c) ((c) == 0x2a)
#define alphachar(c) (((c) >= 0x41 && (c) <= 0x5a) \
                  || ((c) >= 0x61 && (c) <= 0x7a))
#define digitchar(c) ((c) >= 0x30 && (c) <= 0x39)

#define borderchar(c) (alphachar(c) || digitchar(c))
#define middlechar(c) (borderchar(c) || hyphenchar(c))
#define domainchar(c) ((c) > 0x20 && (c) < 0x7f)
d72 1
a72 1
#define CLIENT_PATH "PATH=/usr/bin:/usr/sbin:/bin:/sbin"
d130 1
a130 1
	for(ip = interfaces; ip; ip = ip->next) {
d133 1
a133 1
	}
d137 3
a139 3
#define ROUNDUP(a) \
        ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))
d274 12
a285 12
 		} else if (argv[i][0] == '-') {
 		    usage(s);
 		} else {
 		    struct interface_info *tmp =
 			dmalloc(sizeof(*tmp), "specified_interface");
 		    if (!tmp)
 			error("Insufficient memory to %s %s",
 			    "record interface", argv[i]);
 		    memset(tmp, 0, sizeof(*tmp));
 		    strlcpy(tmp->name, argv[i], IFNAMSIZ);
 		    tmp->next = interfaces;
 		    tmp->flags = INTERFACE_REQUESTED;
d287 2
a288 2
 		    interfaces = tmp;
 		}
d378 1
a378 1
	for(ip = interfaces; ip; ip = ip->next) {
d387 1
a387 1
	for(ip = interfaces; ip; ip = ip->next) {
d1172 2
a1173 3
	      ip->name,
	      inet_ntoa(sockaddr_broadcast.sin_addr),
	      ntohs(sockaddr_broadcast.sin_port), ip->client->interval);
d1693 6
a1698 6
        options[i] = &server_id_tree;
        options[i]->value = lease->options[i].data;
        options[i]->len = lease->options[i].len;
        options[i]->buf_size = lease->options[i].len;
        options[i]->timeout = 0xFFFFFFFF;
        options[i]->tree = NULL;
d1777 6
a1782 6
        options[i] = &server_id_tree;
        options[i]->value = lease->options[i].data;
        options[i]->len = lease->options[i].len;
        options[i]->buf_size = lease->options[i].len;
        options[i]->timeout = 0xFFFFFFFF;
        options[i]->tree = NULL;
d1812 1
a1812 1
		  ip->client->packet_length);
d1945 1
a1945 1
			error("script_init: no memory for environment initialization");
d1949 1
a1949 1
			error("script_init: no memory for environment initialization");
d2016 1
a2016 1
				switch(
d2023 1
a2023 1
				      supersede:
d2031 2
a2032 2
					       config->defaults[i].len +
					       lease->options[i].len;
d2035 2
a2036 2
						      "prepend option",
						      dhcp_options[i].name);
d2053 2
a2054 2
					       config->defaults[i].len +
					       lease->options[i].len;
d2057 2
a2058 2
						      "append option",
						      dhcp_options[i].name);
d2167 1
a2167 1
		          newscriptEnvsize);
d2182 2
a2183 2
	client->scriptEnv[i] = malloc(strlen(prefix) + strlen(name) + 1
          + strlen(value) + 1);
d2187 2
a2188 2
	snprintf(client->scriptEnv[i], strlen(prefix) +  strlen(name)
	  + 1 + strlen(value) + 1, "%s%s=%s", prefix, name, value);
d2250 3
a2252 3
        close(0);
        close(1);
        close(2);
d2293 1
a2293 1
	switch(option) {
d2375 1
a2375 1
		return(1);
d2378 1
a2378 1
		return(unknown_ok);
d2422 1
a2422 1
			return(count);
d2426 1
a2426 1
	return(0);
@


1.5
log
@isours() returns a pointer and thus should be checked against NULL not 0
From: Emil Mikulic <emikulic@@dmr.ath.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.4 2004/02/05 13:33:22 henning Exp $	*/
d60 1
a60 1
#define        hyphenchar(c) ((c) == 0x2d)
d70 1
a70 1
#define        domainchar(c) ((c) > 0x20 && (c) < 0x7f)
d72 1
a72 1
#define	CLIENT_PATH	"PATH=/usr/bin:/usr/sbin:/bin:/sbin"
d92 4
a95 2
/* ASSERT_STATE() does nothing now; it used to be
   assert (state_is == state_shouldbe). */
d115 1
a115 1
static int check_option (struct client_lease *l, int option);
d121 1
a121 1
char *option_as_string (unsigned int code, unsigned char *data, int len);
d123 1
a123 1
int  routefd;
d181 1
a181 1
	n = read(routefd, &msg, sizeof msg);
d257 1
a257 1
				usage (s);
d261 1
a261 1
				usage (s);
d265 1
a265 1
				usage (s);
d275 1
a275 1
 		    usage (s);
d278 1
a278 1
 			dmalloc (sizeof *tmp, "specified_interface");
d280 3
a282 3
 			error ("Insufficient memory to %s %s",
 			       "record interface", argv[i]);
 		    memset(tmp, 0, sizeof *tmp);
d303 1
a303 1
  
d311 1
a311 1
	sockaddr_broadcast.sin_len = sizeof sockaddr_broadcast;
d333 1
a333 1
 
d381 1
a381 1
		    sizeof seed], sizeof seed);
d403 1
a403 1
usage (char *appname)
d417 2
a418 1
void cleanup ()
d422 3
a424 2
/* Individual States:
 * 
d427 3
a429 3
 *->entering INIT state
 *->recvpacket_flag == 0: timeout in this state
 *->otherwise: received a packet in this state
d440 1
a440 1
 *		     been sent to us by DHCP servers.
d442 1
a442 1
 *		   sent to us by DHCP servers.
d453 1
a453 1
state_reboot (void *ipp)
d459 1
a459 1
		state_init (ip);
d497 1
a497 1
	make_discover (ip, ip->client->active);
d543 1
a543 1
			if (script_go (ip)) {
d561 1
a561 1
		state_init (ip);
d597 1
a597 1
}  
d607 1
a607 1
	
d614 2
a615 2
#if defined (DEBUG)
		debug ("DHCPACK in wrong transaction.");
d624 2
a625 2
#if defined (DEBUG)
		debug ("DHCPACK in wrong state.");
d630 1
a630 1
	note("DHCPACK from %s", piaddr (packet->client_addr));
d699 2
a700 2
		script_write_params (ip, "old_", ip->client->active);
	script_write_params (ip, "new_", ip->client->new);
d702 2
a703 2
		script_write_params (ip, "alias_", ip->client->alias);
	script_go (ip);
d707 1
a707 1
		free_client_lease (ip->client->active);
d712 1
a712 1
	add_timeout (ip->client->active->renewal, state_bound, ip);
d714 2
a715 2
	note ("bound to %s -- renewal in %d seconds.",
	    piaddr (ip->client->active->address),
d720 1
a720 6
}  

/* state_bound is called when we've successfully bound to a particular
   lease, but the renewal time on that lease has expired.   We are
   expected to unicast a DHCPREQUEST to the server that gave us our
   original lease. */
d722 6
d729 1
a729 1
state_bound (void *ipp)
d752 1
a752 1
}  
d787 1
a787 1
	}	
d819 1
a819 1
		if (addr_eq (packet->client_addr, ap->addr)) {
d834 3
a836 3
	char *name =
	    (packet->options[DHO_DHCP_MESSAGE_TYPE].len ? "DHCPOFFER" : "BOOTREPLY");
	
d838 2
a839 2
	dump_packet (packet);
#endif	
d848 2
a849 2
#if defined (DEBUG)
		debug ("%s in wrong transaction.", name);
d870 2
a871 2
		if (lease->address.len == sizeof packet->raw->yiaddr &&
		    !memcmp (lease->address.iabuf,
d873 1
a873 1
			debug ("%s already seen.", name);
d878 1
a878 1
	lease = packet_to_lease (packet);
d895 1
a895 1
	/* If the script can't send an ARP request without waiting, 
d904 1
a904 1
	    (ip->client->first_sending + ip->client->config->select_interval);
d945 1
a945 1
		state_selecting (ip);
d947 2
a948 2
		add_timeout (stop_selecting, state_selecting, ip);
		cancel_timeout (send_discover, ip);
d968 1
a968 1
	memset(lease, 0, sizeof *lease);
d976 1
a976 1
				warn ("dhcpoffer: no memory for option %d", i);
d990 1
a990 1
				warn ("Invalid lease option - ignoring offer");
d1009 1
a1009 1
		} 
d1016 2
a1017 2
		}		
		
d1048 2
a1049 2
#if defined (DEBUG)
		debug ("DHCPNAK in wrong transaction.");
d1058 2
a1059 2
#if defined (DEBUG)
		debug ("DHCPNAK in wrong state.");
d1064 1
a1064 1
	note("DHCPNAK from %s", piaddr (packet->client_addr));
d1100 1
a1100 1
		state_panic (ip);
d1114 1
a1114 1
		} 
d1121 1
a1121 1
			
d1125 1
a1125 1
		if (script_go (ip))
d1129 7
a1135 5
	/* If we're supposed to increase the interval, do so.  If it's
	   currently zero (i.e., we haven't sent any packets yet), set
	   it to one; otherwise, add to it a random number between
	   zero and two times itself.  On average, this means that it
	   will double with every transmission. */
d1139 1
a1139 1
				ip->client->config->initial_interval;
d1141 2
a1142 3
			ip->client->interval +=
				((random () >> 2) %
				 (2 * ip->client->interval));
d1155 1
a1155 1
		
d1166 1
a1166 1
		ip->client->packet.secs = htons (interval);
d1168 1
a1168 1
		ip->client->packet.secs = htons (65535);
d1171 1
a1171 1
	note ("DHCPDISCOVER on %s to %s port %d interval %d",
d1173 2
a1174 2
	      inet_ntoa (sockaddr_broadcast.sin_addr),
	      ntohs (sockaddr_broadcast.sin_port), ip->client->interval);
d1183 6
a1188 5
/* state_panic gets called if we haven't received any offers in a preset
   amount of time.   When this happens, we try to use existing leases that
   haven't yet expired, and failing that, we call the client script and
   hope it can do something. */

d1190 1
a1190 1
state_panic (void *ipp)
d1221 1
a1221 1
			if (!script_go (ip)) {
d1225 1
a1225 1
					note ("bound: renewal in %d seconds.",
d1278 1
a1278 1
	script_go (ip);
d1341 1
a1341 1
			script_write_params (ip, "alias_", ip->client->alias);
d1362 1
a1362 1
	
d1388 1
a1388 1
		    sizeof destination.sin_addr.s_addr);
d1391 1
a1391 1
	destination.sin_len = sizeof destination;
d1394 2
a1395 1
		memcpy(&from, ip->client->active->address.iabuf, sizeof from);
d1404 1
a1404 1
			ip->client->packet.secs = htons (interval);
d1406 1
a1406 1
			ip->client->packet.secs = htons (65535);
d1410 1
a1410 1
	    inet_ntoa (destination.sin_addr), ntohs(destination.sin_port));
d1419 1
a1419 1
		result = send_packet (ip, NULL, &ip->client->packet,
d1432 2
a1433 2
	    inet_ntoa (sockaddr_broadcast.sin_addr),
	    ntohs (sockaddr_broadcast.sin_port));
d1448 2
a1449 2
	    inet_ntoa (sockaddr_broadcast.sin_addr),
	    ntohs (sockaddr_broadcast.sin_port));
d1466 1
a1466 1
	memset(options, 0, sizeof options);
d1473 2
a1474 2
	options[i]->len = sizeof discover;
	options[i]->buf_size = sizeof discover;
d1535 1
a1535 1
	    0, sizeof ip->client->packet.ciaddr);
d1537 1
a1537 1
	    0, sizeof ip->client->packet.yiaddr);
d1539 1
a1539 1
	    0, sizeof ip->client->packet.siaddr);
d1541 1
a1541 1
	    0, sizeof ip->client->packet.giaddr);
d1561 1
a1561 1
	memset(options, 0, sizeof options);
d1568 2
a1569 2
	options[i]->len = sizeof request;
	options[i]->buf_size = sizeof request;
d1646 1
a1646 1
		    sizeof ip->client->packet.ciaddr);
d1650 1
a1650 1
			ip->client->packet.flags = htons (BOOTP_BROADCAST);
d1653 7
a1659 7
	memset (&ip->client->packet.yiaddr, 0,
	    sizeof ip->client->packet.yiaddr);
	memset (&ip->client->packet.siaddr, 0,
	    sizeof ip->client->packet.siaddr);
	memset (&ip->client->packet.giaddr, 0,
	    sizeof ip->client->packet.giaddr);
	memcpy (ip->client->packet.chaddr,
d1680 2
a1681 2
	memset(options, 0, sizeof options);
	memset(&ip->client->packet, 0, sizeof (ip->client->packet));
d1687 2
a1688 2
	options[i]->len = sizeof decline;
	options[i]->buf_size = sizeof decline;
d1723 1
a1723 1
	ip->client->packet_length = cons_options (NULL, &ip->client->packet, 0,
d1737 9
a1745 9
	memset (&ip->client->packet.ciaddr, 0,
	    sizeof ip->client->packet.ciaddr);
	memset (&ip->client->packet.yiaddr, 0,
	    sizeof ip->client->packet.yiaddr);
	memset (&ip->client->packet.siaddr, 0,
	    sizeof ip->client->packet.siaddr);
	memset (&ip->client->packet.giaddr, 0,
	    sizeof ip->client->packet.giaddr);
	memcpy (ip->client->packet.chaddr,
d1764 1
a1764 1
	memset(options, 0, sizeof options);
d1771 2
a1772 2
	options[i]->len = sizeof request;
	options[i]->buf_size = sizeof request;
d1799 9
a1807 9
	memset (&ip->client->packet.ciaddr, 0,
	    sizeof ip->client->packet.ciaddr);
	memset (&ip->client->packet.yiaddr, 0,
	    sizeof ip->client->packet.yiaddr);
	memset (&ip->client->packet.siaddr, 0,
	    sizeof ip->client->packet.siaddr);
	memset (&ip->client->packet.giaddr, 0,
	    sizeof ip->client->packet.giaddr);
	memcpy (ip->client->packet.chaddr,
d1823 1
a1823 1
		free (lease->server_name);
d1825 1
a1825 1
		free (lease->filename);
d1828 1
a1828 1
			free (lease->options[i].data);
d1830 1
a1830 1
	free (lease);
d1851 1
a1851 1
			write_client_lease (ip, lp, 1);
d1853 1
a1853 1
			write_client_lease (ip, ip->client->active, 1);
d1877 1
a1877 1
			rewrite_client_leases ();
d1915 1
a1915 1
	t = gmtime (&lease->renewal);
d1919 1
a1919 1
	t = gmtime (&lease->rebind);
d1923 1
a1923 1
	t = gmtime (&lease->expiry);
d1947 1
a1947 1
		
d1965 1
a1965 1
script_write_params (struct interface_info *ip, char *prefix,
d1985 1
a1985 1
	    sizeof lease->address.iabuf)) {
d1988 1
a1988 1
		memcpy (netmask.iabuf,
d1993 1
a1993 1
		subnet = subnet_number (lease->address, netmask);
d1996 1
a1996 1
			    piaddr(subnet));   
d1998 2
a1999 2
				broadcast = broadcast_addr (subnet, netmask);
				if (broadcast.len) 
d2002 1
a2002 1
					    piaddr(broadcast));   
d2025 1
a2025 1
					dp = ip->client ->
d2027 1
a2027 1
					len = ip->client ->
d2031 1
a2031 1
					len = (ip->client ->
d2033 3
a2035 3
					       lease->options[i].len);
					if (len > sizeof dbuf) {
						warn ("no space to %s %s",
d2041 1
a2041 1
					memcpy (dp,
d2046 1
a2046 1
					memcpy (dp + ip->client->
d2050 1
a2050 1
					dp[len] = '\0';	
d2053 1
a2053 1
					len = (ip->client ->
d2055 3
a2057 3
					       lease->options[i].len);
					if (len > sizeof dbuf) {
						warn ("no space to %s %s",
d2063 1
a2063 1
					memcpy (dp,
d2066 1
a2066 1
					memcpy (dp + lease->options[i].len,
d2074 1
a2074 1
				dp = ip->client ->
d2076 1
a2076 1
				len = ip->client ->
d2087 2
a2088 2
			if (dhcp_option_ev_name (name, sizeof name,
						 &dhcp_options[i])) 
d2090 1
a2090 1
				  pretty_print_option (i, dp, len, 0, 0));
d2093 2
a2094 2
	snprintf(tbuf, sizeof(tbuf), "%d", (int) lease->expiry);
	script_set_env(ip->client, prefix, "expiry", tbuf); 
d2107 1
a2107 1
	
d2110 1
a2110 1
		envp = ip->client ->scriptEnv;
d2128 1
a2128 1
			wpid = wait (&wstatus);
d2137 1
a2137 1
		exit (0);
d2153 1
a2153 1
	
d2187 1
a2187 1
	
d2196 1
a2196 1
	
d2221 1
a2221 1
  
d2230 1
a2230 1
		write_client_pid_file ();
d2244 1
a2244 1
		error ("Can't fork daemon: %m");
d2246 1
a2246 1
		exit (0);
d2271 1
a2271 1
	pf = fdopen (pfdesc, "w");
d2275 1
a2275 1
		fprintf(pf, "%ld\n", (long)getpid ());
d2285 1
a2285 1
	
d2287 1
a2287 1
	
d2293 1
a2293 1
	
d2311 1
a2311 1
	case DHO_FONT_SERVERS : 
d2319 1
a2319 1
			return(0);
d2321 1
a2321 1
		return(1)  ;
d2329 1
a2329 1
			return(0);
d2331 1
a2331 1
		return(1);
d2387 1
a2387 1
	
d2390 1
a2390 1
		
d2408 2
a2409 2
/* Does buf consist only of dotted decimal ipv4 addrs? 
 * return how many if so, 
d2417 1
a2417 1
	
d2420 1
a2420 1
		while (periodchar(*buf) || digitchar(*buf)) 
d2422 1
a2422 1
		if (*buf == '\0')	
d2443 1
a2443 1
		error ("option_as_string: bad code %d\n", code);
d2446 2
a2447 2
		if (!isascii (*dp) ||
		    !isprint (*dp)) {
d2473 2
a2474 2
	warn ("dhcp option too large");
	return "<error>";			  
@


1.4
log
@plug memory leak; PR3668 Emil Mikulic <emikulic@@dmr.ath.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.3 2004/02/04 12:16:56 henning Exp $	*/
d196 1
a196 1
		if ((ip = isours(ifam->ifam_index)) == 0)
d204 1
a204 1
		if ((ip = isours(ifm->ifm_index)) == 0)
@


1.3
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1934 3
a1936 2
		ip->client->scriptEnv =
		    malloc(ip->client->scriptEnvsize * sizeof(char *));
@


1.2
log
@8579 lines of KNF, ANSO and zap-junk diff without the resulting binary
changing by a single byte.
partly from theo
@
text
@d1 1
a1 1
/* dhclient.c
d3 1
a3 1
   DHCP Client. */
@


1.1
log
@this is where dhclient will start surgery
@
text
@d72 2
d77 1
a77 1
struct tree_cache *global_options [256];
d106 4
a109 4
static char arr [] = "All rights reserved.";
static char message [] = "Internet Software Consortium DHCP Client";
static char contrib [] = "Please contribute if you find this software useful.";
static char url [] = "For info, please visit http://www.isc.org/dhcp-contrib.html";
d111 1
a111 1
static void usage PROTO ((char *));
d215 1
a215 1
	script_init(ip, "FAIL", (struct string_list *)0);
d222 2
a223 3
int main (argc, argv)
	int argc;
	char **argv;
d232 1
a232 1
	s = strrchr (argv [0], '/');
d234 1
a234 1
		s = argv [0];
d239 2
a240 5
	openlog (s, LOG_NDELAY, DHCPD_LOG_FACILITY);

#if !(defined (DEBUG) || defined (SYSLOG_4_2) || defined (__CYGWIN32__))
	setlogmask (LOG_UPTO (LOG_INFO));
#endif	
d243 1
a243 1
		if (!strcmp (argv [i], "-p")) {
d245 2
a246 2
				usage (s);
			local_port = htons(atoi(argv [i]));
d248 2
a249 2
			       ntohs(local_port));
		} else if (!strcmp (argv [i], "-d")) {
d251 1
a251 1
		} else if (!strcmp (argv [i], "-D")) {
d253 1
a253 1
		} else if (!strcmp (argv [i], "-cf")) {
d256 2
a257 2
			path_dhclient_conf = argv [i];
		} else if (!strcmp (argv [i], "-pf")) {
d260 2
a261 2
			path_dhclient_pid = argv [i];
		} else if (!strcmp (argv [i], "-lf")) {
d264 2
a265 2
			path_dhclient_db = argv [i];
		} else if (!strcmp (argv [i], "-q")) {
d268 1
a268 1
		} else if (!strcmp (argv [i], "-u")) {
d270 1
a270 1
		} else if (!strcmp (argv [i], "-1")) {
d272 1
a272 1
 		} else if (argv [i][0] == '-') {
d276 1
a276 2
 			((struct interface_info *)
 			 dmalloc (sizeof *tmp, "specified_interface"));
d279 3
a281 3
 			       "record interface", argv [i]);
 		    memset (tmp, 0, sizeof *tmp);
 		    strlcpy (tmp->name, argv [i], IFNAMSIZ);
d335 2
a336 3
		script_init((struct interface_info *)0, "NBI",
			     (struct string_list *)0);
		script_go((struct interface_info *)0);
d351 1
a351 1
			script_init(ip, "PREINIT", (struct string_list *)0);
d367 2
a368 3
	discover_interfaces(interfaces_requested
			     ? DISCOVER_REQUESTED
			     : DISCOVER_RUNNING);
d378 2
a379 3
		memcpy(&junk,
			&ip->hw_address.haddr [ip->hw_address.hlen -
						 sizeof seed], sizeof seed);
d397 1
a397 1
	return 0;
d400 2
a401 2
static void usage (appname)
	char *appname;
d448 2
a449 2
void state_reboot (ipp)
	void *ipp;
d454 1
a454 2
	if (!ip->client->active ||
	    ip->client->active->is_bootp) {
d465 1
a465 1
	ip->client->xid = random ();
d469 1
a469 1
	make_request (ip, ip->client->active);
d475 1
a475 1
	ip->client->medium = (struct string_list *)0;
d478 1
a478 1
	send_request (ip);
d484 2
a485 2
void state_init (ipp)
	void *ipp;
d502 1
a502 1
	send_discover (ip);
d508 2
a509 2
void state_selecting (ipp)
	void *ipp;
d519 2
a520 2
	cancel_timeout (state_selecting, ip);
	cancel_timeout (send_discover, ip);
d525 1
a525 1
	picked = (struct client_lease *)0;
d532 2
a533 2
			script_init (ip, "ARPCHECK", lp->medium);
			script_write_params (ip, "check_", lp);
d540 2
a541 2
				make_decline (ip, lp);
				send_decline (ip);
d545 1
a545 1
			picked->next = (struct client_lease *)0;
d547 2
a548 2
		      freeit:
			free_client_lease (lp);
d551 1
a551 1
	ip->client->offered_leases = (struct client_lease *)0;
d562 1
a562 1
	if (!picked->options [DHO_DHCP_MESSAGE_TYPE].len) {
d574 1
a574 1
		bind_lease (ip);
d585 1
a585 1
	make_request (ip, picked);
d589 1
a589 1
	free_client_lease (picked);
d592 1
a592 1
	send_request (ip);
d598 2
a599 2
void dhcpack (packet)
	struct packet *packet;
d607 3
a609 4
	    (packet->interface->hw_address.hlen !=
	     packet->raw->hlen) ||
	    (memcmp (packet->interface->hw_address.haddr,
		     packet->raw->chaddr, packet->raw->hlen))) {
d626 1
a626 1
	note ("DHCPACK from %s", piaddr (packet->client_addr));
d628 1
a628 1
	lease = packet_to_lease (packet);
d630 1
a630 1
		note ("packet_to_lease failed.");
d637 1
a637 1
	cancel_timeout (send_request, ip);
d640 3
a642 4
	if (ip->client->new->options [DHO_DHCP_LEASE_TIME].data)
		ip->client->new->expiry =
			getULong (ip->client ->
				  new->options [DHO_DHCP_LEASE_TIME].data);
d652 3
a654 4
	if (ip->client->new->options [DHO_DHCP_RENEWAL_TIME].len)
		ip->client->new->renewal =
			getULong (ip->client ->
				  new->options [DHO_DHCP_RENEWAL_TIME].data);
d656 1
a656 2
		ip->client->new->renewal =
			ip->client->new->expiry / 2;
d659 3
a661 4
	if (ip->client->new->options [DHO_DHCP_REBINDING_TIME].len)
		ip->client->new->rebind =
			getULong (ip->client->new ->
				  options [DHO_DHCP_REBINDING_TIME].data);
d663 2
a664 4
		ip->client->new->rebind =
			ip->client->new->renewal +
				ip->client->new->renewal / 2 +
					ip->client->new->renewal / 4;
d677 1
a677 1
	bind_lease (ip);
d680 2
a681 2
void bind_lease (ip)
	struct interface_info *ip;
d687 1
a687 1
	write_client_lease (ip, ip->client->new, 0);
d690 4
a693 7
	script_init (ip, (ip->client->state == S_REQUESTING
			  ? "BOUND"
			  : (ip->client->state == S_RENEWING
			     ? "RENEW"
			     : (ip->client->state == S_REBOOTING
				? "REBOOT" : "REBIND"))),
		     ip->client->new->medium);
d705 1
a705 1
	ip->client->new = (struct client_lease *)0;
d708 1
a708 2
	add_timeout (ip->client->active->renewal,
		     state_bound, ip);
d711 2
a712 2
	      piaddr (ip->client->active->address),
	      ip->client->active->renewal - cur_time);
d714 2
a715 2
	reinitialize_interfaces ();
	go_daemon ();
d723 2
a724 2
void state_bound (ipp)
	void *ipp;
d731 1
a731 1
	make_request (ip, ip->client->active);
d734 3
a736 5
	if (ip->client->active ->
	    options [DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy (ip->client->destination.iabuf,
			ip->client->active ->
			options [DHO_DHCP_SERVER_IDENTIFIER].data, 4);
d746 1
a746 1
	send_request (ip);
d749 2
a750 1
int commit_leases ()
d752 1
a752 1
	return 0;
d755 2
a756 2
int write_lease (lease)
	struct lease *lease;
d758 1
a758 1
	return 0;
d761 2
a762 1
void db_startup ()
d766 2
a767 2
void bootp (packet)
	struct packet *packet;
d778 2
a779 3
		if (addr_eq (packet->client_addr, ap->addr)) {
			note ("BOOTREPLY from %s rejected.",
			      piaddr (ap->addr));
d782 2
a783 4
	}
	
	dhcpoffer (packet);

d786 2
a787 2
void dhcp (packet)
	struct packet *packet;
d790 1
a790 1
	void (*handler) PROTO ((struct packet *));
d794 1
a794 1
	      case DHCPOFFER:
d798 1
a798 2

	      case DHCPNAK:
d802 1
a802 2

	      case DHCPACK:
d806 1
a806 2

	      default:
d815 1
a815 2
			note ("%s from %s rejected.",
			      type, piaddr (ap->addr));
d819 1
a819 1
	(*handler) (packet);
d822 2
a823 2
void dhcpoffer (packet)
	struct packet *packet;
d829 2
a830 2
	char *name = (packet->options [DHO_DHCP_MESSAGE_TYPE].len
		      ? "DHCPOFFER" : "BOOTREPLY");
d840 3
a842 4
	    (packet->interface->hw_address.hlen !=
	     packet->raw->hlen) ||
	    (memcmp (packet->interface->hw_address.haddr,
		     packet->raw->chaddr, packet->raw->hlen))) {
d849 1
a849 1
	note ("%s from %s", name, piaddr (packet->client_addr));
d854 4
a857 4
	for (i = 0; ip->client->config->required_options [i]; i++) {
		if (!packet->options [ip->client->config ->
					required_options [i]].len) {
			note ("%s isn't satisfactory.", name);
d867 1
a867 1
			     &packet->raw->yiaddr, lease->address.len)) {
d875 1
a875 1
		note ("packet_to_lease failed.");
d881 1
a881 1
	if (!packet->options [DHO_DHCP_MESSAGE_TYPE].len)
d888 2
a889 2
	script_init (ip, "ARPSEND", lease->medium);
	script_write_params (ip, "check_", lease);
d892 1
a892 1
	if (script_go (ip))
d898 2
a899 2
	stop_selecting = (ip->client->first_sending +
			  ip->client->config->select_interval);
d904 3
a906 3
	    !memcmp (lease->address.iabuf,
		     ip->client->requested_address.iabuf,
		     ip->client->requested_address.len)) {
d919 1
a919 1
		lease->next = (struct client_lease *)0;
d924 2
a925 2
			     lp = lp->next)
				;
d950 2
a951 2
struct client_lease *packet_to_lease (packet)
	struct packet *packet;
d956 1
a956 1
	lease = (struct client_lease *)malloc (sizeof (struct client_lease));
d959 2
a960 2
		warn ("dhcpoffer: no memory to record lease.");
		return (struct client_lease *)0;
d963 1
a963 1
	memset (lease, 0, sizeof *lease);
d967 7
a973 9
		if (packet->options [i].len) {
			lease->options [i].data =
				(unsigned char *)
					malloc (packet->options [i].len + 1);
			if (!lease->options [i].data) {
				warn ("dhcpoffer: no memory for option %d",
				      i);
				free_client_lease (lease);
				return (struct client_lease *)0;
d975 7
a981 7
				memcpy (lease->options [i].data,
					packet->options [i].data,
					packet->options [i].len);
				lease->options [i].len =
					packet->options [i].len;
				lease->options [i].data
					[lease->options [i].len] = 0;
d986 1
a986 1
				free_client_lease (lease);
d992 2
a993 3
	lease->address.len = sizeof (packet->raw->yiaddr);
	memcpy (lease->address.iabuf, &packet->raw->yiaddr,
		lease->address.len);
d996 4
a999 4
	if ((!packet->options [DHO_DHCP_OPTION_OVERLOAD].len ||
	     !(packet->options [DHO_DHCP_OPTION_OVERLOAD].data [0] & 2)) &&
	    packet->raw->sname [0]) {
		lease->server_name = malloc (DHCP_SNAME_LEN + 1);
d1001 3
a1003 3
			warn ("dhcpoffer: no memory for server name.");
			free_client_lease (lease);
			return (struct client_lease *)0;
d1007 4
a1010 4
		if (! res_hnok (lease->server_name) ) {
			warn ("Bogus server name %s",  lease->server_name );
			free_client_lease (lease);
			return (struct client_lease *)0;
d1016 3
a1018 3
	if ((!packet->options [DHO_DHCP_OPTION_OVERLOAD].len ||
	     !(packet->options [DHO_DHCP_OPTION_OVERLOAD].data [0] & 1)) &&
	    packet->raw->file [0]) {
d1022 3
a1024 3
			warn ("dhcpoffer: no memory for filename.");
			free_client_lease (lease);
			return (struct client_lease *)0;
d1030 1
a1030 1
}	
d1032 2
a1033 2
void dhcpnak (packet)
	struct packet *packet;
d1040 3
a1042 4
	    (packet->interface->hw_address.hlen !=
	     packet->raw->hlen) ||
	    (memcmp (packet->interface->hw_address.haddr,
		     packet->raw->chaddr, packet->raw->hlen))) {
d1059 1
a1059 1
	note ("DHCPNAK from %s", piaddr (packet->client_addr));
d1062 1
a1062 1
		note ("DHCPNAK with no active lease.\n");
d1066 2
a1067 2
	free_client_lease (ip->client->active);
	ip->client->active = (struct client_lease *)0;
d1070 1
a1070 1
	cancel_timeout (send_request, ip);
d1073 1
a1073 1
	state_init (ip);
d1080 2
a1081 2
void send_discover (ipp)
	void *ipp;
d1105 1
a1105 1
	      again:
d1107 1
a1107 2
			ip->client->medium =
				ip->client->medium->next;
d1112 2
a1113 4
				error ("No valid media types for %s!",
				       ip->name);
			ip->client->medium =
				ip->client->config->media;
d1117 4
a1120 4
		note ("Trying medium \"%s\" %d",
		      ip->client->medium->string, increase);
		script_init (ip, "MEDIUM", ip->client->medium);
		if (script_go (ip)) {
a1121 1
		}
d1171 2
a1172 5
	result = send_packet (ip, (struct packet *)0,
			      &ip->client->packet,
			      ip->client->packet_length,
			      inaddr_any, &sockaddr_broadcast,
			      (struct hardware *)0);
d1174 1
a1174 1
	add_timeout (cur_time + ip->client->interval, send_discover, ip);
d1182 2
a1183 2
void state_panic (ipp)
	void *ipp;
d1190 1
a1190 1
	note ("No DHCPOFFERS received.");
d1200 2
a1201 2
			note ("Trying recorded lease %s",
			      piaddr (ip->client->active->address));
d1204 3
a1206 4
			script_init (ip, "TIMEOUT",
				     ip->client->active->medium);
			script_write_params (ip, "new_",
					     ip->client->active);
d1208 2
a1209 2
				script_write_params (ip, "alias_",
						     ip->client->alias);
d1219 5
a1223 5
					      ip->client->active->renewal
					      - cur_time);
					add_timeout ((ip->client ->
						      active->renewal),
						     state_bound, ip);
d1226 2
a1227 2
					note ("bound: immediate renewal.");
					state_bound (ip);
d1229 2
a1230 2
				reinitialize_interfaces ();
				go_daemon ();
d1238 1
a1238 1
			ip->client->active = (struct client_lease *)0;
d1242 1
a1242 1
	activate_next:
d1248 2
a1249 3
		if (lp->next) {
			lp->next->next = (struct client_lease *)0;
		}
d1267 2
a1268 2
	note ("No working leases in persistent database - sleeping.\n");
	script_init (ip, "FAIL", (struct string_list *)0);
d1270 1
a1270 1
		script_write_params (ip, "alias_", ip->client->alias);
d1273 3
a1275 3
	add_timeout (cur_time + ip->client->config->retry_interval,
		     state_init, ip);
	go_daemon ();
d1278 2
a1279 2
void send_request (ipp)
	void *ipp;
d1302 1
a1302 1
	     ip->client->state == S_REQUESTING) &&
d1304 1
a1304 1
	cancel:
d1306 2
a1307 2
		cancel_timeout (send_request, ip);
		state_init (ip);
d1316 1
a1316 1
		script_init (ip, "MEDIUM", ip->client->active->medium);
d1319 1
a1319 1
		if (script_go (ip))
d1331 2
a1332 2
		script_init (ip, "EXPIRE", (struct string_list *)0);
		script_write_params (ip, "old_", ip->client->active);
d1334 2
a1335 3
			script_write_params (ip, "alias_",
					     ip->client->alias);
		script_go (ip);
d1339 1
a1339 1
		script_init (ip, "PREINIT", (struct string_list *)0);
d1341 2
a1342 3
			script_write_params (ip, "alias_",
					     ip->client->alias);
		script_go (ip);
d1345 1
a1345 1
		state_init (ip);
d1351 4
a1354 7
		ip->client->interval =
			ip->client->config->initial_interval;
	else {
		ip->client->interval +=
			((random () >> 2) %
			 (2 * ip->client->interval));
	}
d1360 2
a1361 3
			((ip->client->config->backoff_cutoff / 2)
			 + ((random () >> 2)
			    % ip->client->interval));
d1369 1
a1369 1
			ip->client->active->expiry - cur_time + 1;
d1379 3
a1381 3
		memcpy (&destination.sin_addr.s_addr,
			ip->client->destination.iabuf,
			sizeof destination.sin_addr.s_addr);
d1387 1
a1387 2
		memcpy (&from, ip->client->active->address.iabuf,
			sizeof from);
d1401 2
a1402 3
	note ("DHCPREQUEST on %s to %s port %d", ip->name,
	      inet_ntoa (destination.sin_addr),
	      ntohs (destination.sin_port));
d1406 3
a1408 6
		result = send_packet (fallback_interface,
				      (struct packet *)0,
				      &ip->client->packet,
				      ip->client->packet_length,
				      from, &destination,
				      (struct hardware *)0);
d1411 2
a1412 5
		result = send_packet (ip, (struct packet *)0,
				      &ip->client->packet,
				      ip->client->packet_length,
				      from, &destination,
				      (struct hardware *)0);
d1414 1
a1414 2
	add_timeout (cur_time + ip->client->interval,
		     send_request, ip);
d1417 2
a1418 2
void send_decline (ipp)
	void *ipp;
a1420 1

d1423 3
a1425 3
	note ("DHCPDECLINE on %s to %s port %d", ip->name,
	      inet_ntoa (sockaddr_broadcast.sin_addr),
	      ntohs (sockaddr_broadcast.sin_port));
d1428 2
a1429 5
	result = send_packet (ip, (struct packet *)0,
			      &ip->client->packet,
			      ip->client->packet_length,
			      inaddr_any, &sockaddr_broadcast,
			      (struct hardware *)0);
d1432 2
a1433 2
void send_release (ipp)
	void *ipp;
d1439 3
a1441 3
	note ("DHCPRELEASE on %s to %s port %d", ip->name,
	      inet_ntoa (sockaddr_broadcast.sin_addr),
	      ntohs (sockaddr_broadcast.sin_port));
d1444 2
a1445 5
	result = send_packet (ip, (struct packet *)0,
			      &ip->client->packet,
			      ip->client->packet_length,
			      inaddr_any, &sockaddr_broadcast,
			      (struct hardware *)0);
d1448 2
a1449 3
void make_discover (ip, lease)
	struct interface_info *ip;
	struct client_lease *lease;
d1454 2
a1455 2
	struct tree_cache *options [256];
	struct tree_cache option_elements [256];
d1457 3
a1459 3
	memset (option_elements, 0, sizeof option_elements);
	memset (options, 0, sizeof options);
	memset (&ip->client->packet, 0, sizeof (ip->client->packet));
d1463 6
a1468 6
	options [i] = &option_elements [i];
	options [i]->value = &discover;
	options [i]->len = sizeof discover;
	options [i]->buf_size = sizeof discover;
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1472 4
a1475 4
	options [i] = &option_elements [i];
	options [i]->value = ip->client->config->requested_options;
	options [i]->len = ip->client->config->requested_option_count;
	options [i]->buf_size =
d1477 2
a1478 2
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1484 7
a1490 7
		options [i] = &option_elements [i];
		options [i]->value = lease->address.iabuf;
		options [i]->len = lease->address.len;
		options [i]->buf_size = lease->address.len;
		options [i]->timeout = 0xFFFFFFFF;
		options [i]->tree = (struct tree *)0;
	} else {
a1491 1
	}
d1494 12
a1505 12
	for (i = 0; i < 256; i++) {
		if (!options [i] &&
		    ip->client->config->send_options [i].data) {
			options [i] = &option_elements [i];
			options [i]->value = ip->client->config ->
				send_options [i].data;
			options [i]->len = ip->client->config ->
				send_options [i].len;
			options [i]->buf_size = ip->client->config ->
				send_options [i].len;
			options [i]->timeout = 0xFFFFFFFF;
			options [i]->tree = (struct tree *)0;
a1506 1
	}
d1509 2
a1510 3
	ip->client->packet_length =
		cons_options ((struct packet *)0, &ip->client->packet, 0,
			      options, 0, 0, 0, (u_int8_t *)0, 0);
d1518 1
a1518 1
	ip->client->packet.xid = arc4random ();
d1521 1
a1521 1
	if (can_receive_unicast_unconfigured (ip))
d1524 1
a1524 1
		ip->client->packet.flags = htons (BOOTP_BROADCAST);
d1526 10
a1535 10
	memset (&(ip->client->packet.ciaddr),
		0, sizeof ip->client->packet.ciaddr);
	memset (&(ip->client->packet.yiaddr),
		0, sizeof ip->client->packet.yiaddr);
	memset (&(ip->client->packet.siaddr),
		0, sizeof ip->client->packet.siaddr);
	memset (&(ip->client->packet.giaddr),
		0, sizeof ip->client->packet.giaddr);
	memcpy (ip->client->packet.chaddr,
		ip->hw_address.haddr, ip->hw_address.hlen);
d1538 2
a1539 3
	dump_packet (sendpkt);
	dump_raw ((unsigned char *)ip->client->packet,
		  sendpkt->packet_length);
d1544 2
a1545 3
void make_request (ip, lease)
	struct interface_info *ip;
	struct client_lease *lease;
d1550 2
a1551 2
	struct tree_cache *options [256];
	struct tree_cache option_elements [256];
d1553 2
a1554 2
	memset (options, 0, sizeof options);
	memset (&ip->client->packet, 0, sizeof (ip->client->packet));
d1558 6
a1563 6
	options [i] = &option_elements [i];
	options [i]->value = &request;
	options [i]->len = sizeof request;
	options [i]->buf_size = sizeof request;
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1567 4
a1570 4
	options [i] = &option_elements [i];
	options [i]->value = ip->client->config->requested_options;
	options [i]->len = ip->client->config->requested_option_count;
	options [i]->buf_size =
d1572 2
a1573 2
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1580 6
a1585 6
		options [i] = &option_elements [i];
		options [i]->value = lease->options [i].data;
		options [i]->len = lease->options [i].len;
		options [i]->buf_size = lease->options [i].len;
		options [i]->timeout = 0xFFFFFFFF;
		options [i]->tree = (struct tree *)0;
d1591 7
a1597 7
		options [i] = &option_elements [i];
		options [i]->value = lease->address.iabuf;
		options [i]->len = lease->address.len;
		options [i]->buf_size = lease->address.len;
		options [i]->timeout = 0xFFFFFFFF;
		options [i]->tree = (struct tree *)0;
	} else {
a1598 1
	}
d1601 12
a1612 12
	for (i = 0; i < 256; i++) {
		if (!options [i] &&
		    ip->client->config->send_options [i].data) {
			options [i] = &option_elements [i];
			options [i]->value = ip->client->config ->
				send_options [i].data;
			options [i]->len = ip->client->config ->
				send_options [i].len;
			options [i]->buf_size = ip->client->config ->
				send_options [i].len;
			options [i]->timeout = 0xFFFFFFFF;
			options [i]->tree = (struct tree *)0;
a1613 1
	}
d1616 2
a1617 3
	ip->client->packet_length =
		cons_options ((struct packet *)0, &ip->client->packet, 0,
			      options, 0, 0, 0, (u_int8_t *)0, 0);
d1633 2
a1634 2
		memcpy (&ip->client->packet.ciaddr,
			lease->address.iabuf, lease->address.len);
d1637 3
a1639 3
		memset (&ip->client->packet.ciaddr, 0,
			sizeof ip->client->packet.ciaddr);
		if (can_receive_unicast_unconfigured (ip))
d1646 1
a1646 1
		sizeof ip->client->packet.yiaddr);
d1648 1
a1648 1
		sizeof ip->client->packet.siaddr);
d1650 1
a1650 1
		sizeof ip->client->packet.giaddr);
d1652 1
a1652 1
		ip->hw_address.haddr, ip->hw_address.hlen);
d1655 2
a1656 2
	dump_packet (sendpkt);
	dump_raw ((unsigned char *)ip->client->packet, sendpkt->packet_length);
d1660 2
a1661 3
void make_decline (ip, lease)
	struct interface_info *ip;
	struct client_lease *lease;
d1666 1
a1666 1
	struct tree_cache *options [256];
d1672 2
a1673 2
	memset (options, 0, sizeof options);
	memset (&ip->client->packet, 0, sizeof (ip->client->packet));
d1677 6
a1682 6
	options [i] = &message_type_tree;
	options [i]->value = &decline;
	options [i]->len = sizeof decline;
	options [i]->buf_size = sizeof decline;
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1686 6
a1691 6
        options [i] = &server_id_tree;
        options [i]->value = lease->options [i].data;
        options [i]->len = lease->options [i].len;
        options [i]->buf_size = lease->options [i].len;
        options [i]->timeout = 0xFFFFFFFF;
        options [i]->tree = (struct tree *)0;
d1695 6
a1700 6
	options [i] = &requested_address_tree;
	options [i]->value = lease->address.iabuf;
	options [i]->len = lease->address.len;
	options [i]->buf_size = lease->address.len;
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1704 7
a1710 10
	if (ip->client->config->send_options [i].len) {
		options [i] = &client_id_tree;
		options [i]->value = ip->client->config ->
			send_options [i].data;
		options [i]->len = ip->client->config ->
			send_options [i].len;
		options [i]->buf_size = ip->client->config ->
			send_options [i].len;
		options [i]->timeout = 0xFFFFFFFF;
		options [i]->tree = (struct tree *)0;
d1715 2
a1716 3
	ip->client->packet_length =
		cons_options ((struct packet *)0, &ip->client->packet, 0,
			      options, 0, 0, 0, (u_int8_t *)0, 0);
d1730 1
a1730 1
		sizeof ip->client->packet.ciaddr);
d1732 1
a1732 1
		sizeof ip->client->packet.yiaddr);
d1734 1
a1734 1
		sizeof ip->client->packet.siaddr);
d1736 1
a1736 1
		sizeof ip->client->packet.giaddr);
d1738 1
a1738 1
		ip->hw_address.haddr, ip->hw_address.hlen);
d1741 2
a1742 2
	dump_packet (sendpkt);
	dump_raw ((unsigned char *)ip->client->packet, sendpkt->packet_length);
d1746 2
a1747 3
void make_release (ip, lease)
	struct interface_info *ip;
	struct client_lease *lease;
d1752 1
a1752 1
	struct tree_cache *options [256];
d1756 2
a1757 2
	memset (options, 0, sizeof options);
	memset (&ip->client->packet, 0, sizeof (ip->client->packet));
d1761 6
a1766 6
	options [i] = &message_type_tree;
	options [i]->value = &request;
	options [i]->len = sizeof request;
	options [i]->buf_size = sizeof request;
	options [i]->timeout = 0xFFFFFFFF;
	options [i]->tree = (struct tree *)0;
d1770 6
a1775 6
        options [i] = &server_id_tree;
        options [i]->value = lease->options [i].data;
        options [i]->len = lease->options [i].len;
        options [i]->buf_size = lease->options [i].len;
        options [i]->timeout = 0xFFFFFFFF;
        options [i]->tree = (struct tree *)0;
d1778 2
a1779 3
	ip->client->packet_length =
		cons_options ((struct packet *)0, &ip->client->packet, 0,
			      options, 0, 0, 0, (u_int8_t *)0, 0);
d1787 1
a1787 1
	ip->client->packet.xid = random ();
d1792 1
a1792 1
		sizeof ip->client->packet.ciaddr);
d1794 1
a1794 1
		sizeof ip->client->packet.yiaddr);
d1796 1
a1796 1
		sizeof ip->client->packet.siaddr);
d1798 1
a1798 1
		sizeof ip->client->packet.giaddr);
d1800 1
a1800 1
		ip->hw_address.haddr, ip->hw_address.hlen);
d1803 2
a1804 2
	dump_packet (sendpkt);
	dump_raw ((unsigned char *)ip->client->packet,
d1809 2
a1810 2
void free_client_lease (lease)
	struct client_lease *lease;
d1819 2
a1820 2
		if (lease->options [i].len)
			free (lease->options [i].data);
d1827 2
a1828 1
void rewrite_client_leases ()
d1834 2
a1835 2
		fclose (leaseFile);
	leaseFile = fopen (path_dhclient_db, "w");
d1837 1
a1837 1
		error ("can't create %s: %m", path_dhclient_db);
d1842 1
a1842 1
		for (lp = ip->client->leases; lp; lp = lp->next) {
a1843 1
		}
d1851 2
a1852 3
		for (lp = ip->client->leases; lp; lp = lp->next) {
			write_client_lease (ip, lp, 1);
		}
d1854 1
a1854 1
			write_client_lease (ip, ip->client->active, 1);
d1856 1
a1856 1
	fflush (leaseFile);
d1859 3
a1861 4
void write_client_lease (ip, lease, rewrite)
	struct interface_info *ip;
	struct client_lease *lease;
	int rewrite;
d1880 1
a1880 1
		leaseFile = fopen (path_dhclient_db, "w");
d1882 1
a1882 1
			error ("can't create %s: %m", path_dhclient_db);
d1885 1
a1885 1
	fprintf (leaseFile, "lease {\n");
d1887 3
a1889 4
		fprintf (leaseFile, "  bootp;\n");
	fprintf (leaseFile, "  interface \"%s\";\n", ip->name);
	fprintf (leaseFile, "  fixed-address %s;\n",
		 piaddr (lease->address));
d1891 1
a1891 2
		fprintf (leaseFile, "  filename \"%s\";\n",
			 lease->filename);
d1893 2
a1894 2
		fprintf (leaseFile, "  server-name \"%s\";\n",
			 lease->server_name);
d1896 7
a1902 12
		fprintf (leaseFile, "  medium \"%s\";\n",
			 lease->medium->string);
	for (i = 0; i < 256; i++) {
		if (lease->options [i].len) {
			fprintf (leaseFile,
				 "  option %s %s;\n",
				 dhcp_options [i].name,
				 pretty_print_option
				 (i, lease->options [i].data,
				  lease->options [i].len, 1, 1));
		}
	}
d1908 3
a1910 5
	fprintf (leaseFile,
		 "  renew %d %d/%d/%d %02d:%02d:%02d;\n",
		 t->tm_wday, t->tm_year + 1900,
		 t->tm_mon + 1, t->tm_mday,
		 t->tm_hour, t->tm_min, t->tm_sec);
d1912 3
a1914 5
	fprintf (leaseFile,
		 "  rebind %d %d/%d/%d %02d:%02d:%02d;\n",
		 t->tm_wday, t->tm_year + 1900,
		 t->tm_mon + 1, t->tm_mday,
		 t->tm_hour, t->tm_min, t->tm_sec);
d1916 5
a1920 7
	fprintf (leaseFile,
		 "  expire %d %d/%d/%d %02d:%02d:%02d;\n",
		 t->tm_wday, t->tm_year + 1900,
		 t->tm_mon + 1, t->tm_mday,
		 t->tm_hour, t->tm_min, t->tm_sec);
	fprintf (leaseFile, "}\n");
	fflush (leaseFile);
d1926 1
a1926 1
char scriptName [256];
d1929 2
a1930 4
void script_init (ip, reason, medium)
	struct interface_info *ip;
	char *reason;
	struct string_list *medium;
d1934 2
a1935 2
		ip->client->scriptEnv = malloc(ip->client->scriptEnvsize 
	          * sizeof(char *));
d1937 1
a1937 1
			error ("script_init: no memory for environment initialization");
d1941 1
a1941 1
			error ("script_init: no memory for environment initialization");
d1943 1
a1943 1
		ip->client->scriptEnv[1]=NULL;
d1949 1
a1949 1
			  medium->string);
d1955 3
a1957 4
void script_write_params (ip, prefix, lease)
	struct interface_info *ip;
	char *prefix;
	struct client_lease *lease;
d1960 1
a1960 1
	u_int8_t dbuf [1500];
d1965 1
a1965 1
	  piaddr(lease->address));
d1974 3
a1976 3
	if (lease->options [DHO_SUBNET_MASK].len &&
	    (lease->options [DHO_SUBNET_MASK].len <
	     sizeof lease->address.iabuf)) {
d1980 3
a1982 3
			lease->options [DHO_SUBNET_MASK].data,
			lease->options [DHO_SUBNET_MASK].len);
		netmask.len = lease->options [DHO_SUBNET_MASK].len;
d1987 2
a1988 2
			  piaddr(subnet));   
			if (!lease->options [DHO_BROADCAST_ADDRESS].len) {
d1992 2
a1993 2
					  "broadcast_address",
					  piaddr(broadcast));   
d1999 1
a1999 2
		script_set_env(ip->client, prefix, "filename",
		  lease->filename);
d2002 1
a2002 1
		  lease->server_name);
d2006 7
a2012 7
		if (ip->client->config->defaults [i].len) {
			if (lease->options [i].len) {
				switch (ip->client ->
					config->default_actions [i]) {
				      case ACTION_DEFAULT:
					dp = lease->options [i].data;
					len = lease->options [i].len;
d2014 1
a2014 1
				      case ACTION_SUPERSEDE:
d2017 1
a2017 1
						config->defaults [i].data;
d2019 1
a2019 1
						config->defaults [i].len;
d2021 1
a2021 1
				      case ACTION_PREPEND:
d2023 2
a2024 2
					       config->defaults [i].len +
					       lease->options [i].len);
d2028 1
a2028 1
						      dhcp_options [i].name);
d2034 1
a2034 1
						config->defaults [i].data,
d2036 1
a2036 1
						config->defaults [i].len);
d2038 4
a2041 4
						config->defaults [i].len,
						lease->options [i].data,
						lease->options [i].len);
					dp [len] = '\0';	
d2043 1
a2043 1
				      case ACTION_APPEND:
d2045 2
a2046 2
					       config->defaults [i].len +
					       lease->options [i].len);
d2050 1
a2050 1
						      dhcp_options [i].name);
d2055 3
a2057 3
						lease->options [i].data,
						lease->options [i].len);
					memcpy (dp + lease->options [i].len,
d2059 1
a2059 1
						config->defaults [i].data,
d2061 2
a2062 2
						config->defaults [i].len);
					dp [len] = '\0';
d2066 1
a2066 1
					config->defaults [i].data;
d2068 1
a2068 1
					config->defaults [i].len;
d2070 3
a2072 3
		} else if (lease->options [i].len) {
			len = lease->options [i].len;
			dp = lease->options [i].data;
d2077 1
a2077 1
			char name [256];
d2079 1
a2079 1
						 &dhcp_options [i])) 
d2088 2
a2089 2
int script_go (ip)
	struct interface_info *ip;
d2092 1
a2092 1
	char *argv [2];
d2094 3
a2096 3
	char *epp [3];
	char reason [] = "REASON=NBI";
	static char client_path [] = CLIENT_PATH;
d2104 3
a2106 3
		epp [0] = reason;
		epp [1] = client_path;
		epp [2] = (char *)0;
d2110 2
a2111 2
	argv [0] = scriptName;
	argv [1] = (char *)0;
d2113 1
a2113 1
	pid = fork ();
d2115 1
a2115 1
		error ("fork: %m");
d2122 1
a2122 1
			error ("wait: %m");
d2126 2
a2127 2
		execve (scriptName, argv, envp);
		error ("execve (%s, ...): %m", scriptName);
d2131 1
a2131 1
	if (ip) {
d2133 2
a2134 2
	}
	return wstatus & 0xff;
d2137 3
a2139 5
void script_set_env (client, prefix, name, value)
	struct client_state *client;
	const char *prefix;
	const char *name;
	const char *value;
d2145 1
a2145 1
	for (i = 0; client->scriptEnv[i]; i++) {
d2149 2
a2150 2
	}
	if (client->scriptEnv[i]) {
d2153 1
a2153 1
	} else {
d2183 2
a2184 1
void script_flush_env(struct client_state *client)
d2195 2
a2196 4
int dhcp_option_ev_name (buf, buflen, option)
	char *buf;
	size_t buflen;
	struct option *option;
d2200 1
a2200 1
	for (i = 0; option->name [i]; i++) {
d2203 2
a2204 2
		if (option->name [i] == '-')
			buf [i] = '_';
d2206 1
a2206 1
			buf [i] = option->name [i];
d2209 1
a2209 1
	buf [i] = 0;
d2213 2
a2214 1
void go_daemon ()
d2234 1
a2234 1
	if ((pid = fork ()) < 0)
d2239 1
a2239 1
	pid = setsid ();
d2246 1
a2246 1
	write_client_pid_file ();
d2249 2
a2250 1
void write_client_pid_file ()
d2255 1
a2255 1
	pfdesc = open (path_dhclient_pid, O_CREAT | O_TRUNC | O_WRONLY, 0644);
d2258 1
a2258 1
		warn ("Can't create %s: %m", path_dhclient_pid);
d2264 1
a2264 1
		warn ("Can't fdopen %s: %m", path_dhclient_pid);
d2266 2
a2267 2
		fprintf (pf, "%ld\n", (long)getpid ());
		fclose (pf);
d2271 3
a2273 1
int check_option (struct client_lease *l, int option) {
d2375 1
a2375 2
res_hnok(dn)
	const char *dn;
d2403 3
a2405 1
int ipv4addrs(char * buf) {
d2424 2
a2425 1
char *option_as_string (unsigned int code, unsigned char *data, int len)
d2427 1
a2427 1
	static char optbuf [32768]; /* XXX */
d2463 1
a2463 1
 toobig:
@

