head	1.185;
access;
symbols
	OPENBSD_6_1:1.161.0.4
	OPENBSD_6_1_BASE:1.161
	OPENBSD_6_0:1.154.0.6
	OPENBSD_6_0_BASE:1.154
	OPENBSD_5_9:1.154.0.2
	OPENBSD_5_9_BASE:1.154
	OPENBSD_5_8:1.150.0.4
	OPENBSD_5_8_BASE:1.150
	OPENBSD_5_7:1.149.0.2
	OPENBSD_5_7_BASE:1.149
	OPENBSD_5_6:1.139.0.4
	OPENBSD_5_6_BASE:1.139
	OPENBSD_5_5:1.136.0.4
	OPENBSD_5_5_BASE:1.136
	OPENBSD_5_4:1.121.0.2
	OPENBSD_5_4_BASE:1.121
	OPENBSD_5_3:1.111.0.2
	OPENBSD_5_3_BASE:1.111
	OPENBSD_5_2:1.76.0.4
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.2
	OPENBSD_5_0:1.73.0.2
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.71.0.4
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.71.0.2
	OPENBSD_4_8_BASE:1.71
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.69.0.4
	OPENBSD_4_6_BASE:1.69
	OPENBSD_4_5:1.67.0.4
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.67.0.2
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.65.0.6
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.65.0.4
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.65.0.2
	OPENBSD_4_1_BASE:1.65
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.47.0.4
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.47.0.2
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.33.0.4
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26;
locks; strict;
comment	@ * @;


1.185
date	2017.06.17.16.58.55;	author krw;	state Exp;
branches;
next	1.184;
commitid	l7JlcHqNJUIfaJjc;

1.184
date	2017.06.17.15.53.03;	author krw;	state Exp;
branches;
next	1.183;
commitid	S5as0pLhDvUkyD87;

1.183
date	2017.06.16.14.12.12;	author krw;	state Exp;
branches;
next	1.182;
commitid	sjpyGq49Fw7RSSLS;

1.182
date	2017.06.15.17.06.17;	author krw;	state Exp;
branches;
next	1.181;
commitid	3Bd8xw2tLnMI6fM7;

1.181
date	2017.06.14.20.27.08;	author krw;	state Exp;
branches;
next	1.180;
commitid	Do2Wb0ASjzojBK6g;

1.180
date	2017.06.14.16.52.35;	author krw;	state Exp;
branches;
next	1.179;
commitid	qdJehrUm6vQEMjRB;

1.179
date	2017.06.14.16.29.58;	author krw;	state Exp;
branches;
next	1.178;
commitid	tsqEu09O9dSQSutt;

1.178
date	2017.06.14.16.09.42;	author krw;	state Exp;
branches;
next	1.177;
commitid	d5OX3PwMWtaAMnZV;

1.177
date	2017.06.14.15.57.25;	author krw;	state Exp;
branches;
next	1.176;
commitid	xleVcb5KQcOBndeE;

1.176
date	2017.06.14.15.39.55;	author krw;	state Exp;
branches;
next	1.175;
commitid	leRXJH8PurJqMWtQ;

1.175
date	2017.06.13.16.02.46;	author krw;	state Exp;
branches;
next	1.174;
commitid	v4eQ1kyRIWPSq2SD;

1.174
date	2017.06.13.15.49.32;	author krw;	state Exp;
branches;
next	1.173;
commitid	OYT2CturRpIwAbZo;

1.173
date	2017.06.10.18.03.50;	author krw;	state Exp;
branches;
next	1.172;
commitid	hRQl7DZ4CgL5c6vi;

1.172
date	2017.06.10.17.56.29;	author krw;	state Exp;
branches;
next	1.171;
commitid	1dqLY8Cw6CA1ZYDX;

1.171
date	2017.04.18.13.59.09;	author krw;	state Exp;
branches;
next	1.170;
commitid	cFUzT9OoC4hYJl7A;

1.170
date	2017.04.11.10.40.14;	author krw;	state Exp;
branches;
next	1.169;
commitid	fZH0FasjbItTtOXw;

1.169
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.168;
commitid	KIdulj0iLtM6kXff;

1.168
date	2017.04.08.18.54.52;	author krw;	state Exp;
branches;
next	1.167;
commitid	8EYpknlzUTHDPTPW;

1.167
date	2017.04.08.17.00.10;	author krw;	state Exp;
branches;
next	1.166;
commitid	NmYVWunprpEm8q1k;

1.166
date	2017.04.07.15.03.00;	author krw;	state Exp;
branches;
next	1.165;
commitid	IJyiLQCmbwzmKm5U;

1.165
date	2017.04.05.18.22.30;	author krw;	state Exp;
branches;
next	1.164;
commitid	wE6Aq0gXfIxsFOYi;

1.164
date	2017.04.04.15.15.48;	author krw;	state Exp;
branches;
next	1.163;
commitid	hBAWRbZZAV0xgcf3;

1.163
date	2017.04.04.13.01.20;	author krw;	state Exp;
branches;
next	1.162;
commitid	XnNlR4VEiZFpMvjG;

1.162
date	2017.04.03.19.59.39;	author krw;	state Exp;
branches;
next	1.161;
commitid	FEe0akNwKUViXksW;

1.161
date	2017.03.08.20.33.20;	author krw;	state Exp;
branches;
next	1.160;
commitid	xpKfrdDMJe8Z9tfc;

1.160
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.159;
commitid	IDlzr3qamZK5lxzj;

1.159
date	2017.02.11.16.12.36;	author krw;	state Exp;
branches;
next	1.158;
commitid	eWsyZlm9X0T2fxXC;

1.158
date	2016.09.02.15.44.26;	author mpi;	state Exp;
branches;
next	1.157;
commitid	GuoxNV4NXpbUVBHj;

1.157
date	2016.08.31.12.57.31;	author mpi;	state Exp;
branches;
next	1.156;
commitid	dRGzj71S05fFJodM;

1.156
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.155;
commitid	Tm7CrlqCKqgQoJ7P;

1.155
date	2016.08.16.21.57.51;	author krw;	state Exp;
branches;
next	1.154;
commitid	fX275BVALtbId2xm;

1.154
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.153;
commitid	5ELOU0S0Zl3aCrHG;

1.153
date	2015.12.12.14.48.17;	author krw;	state Exp;
branches;
next	1.152;
commitid	skRihYvealiyczYj;

1.152
date	2015.10.26.16.32.33;	author krw;	state Exp;
branches;
next	1.151;
commitid	Y03Zu0zFPhi0Triz;

1.151
date	2015.08.19.17.52.10;	author krw;	state Exp;
branches;
next	1.150;
commitid	8Se7zB6BBBqOYS0w;

1.150
date	2015.05.18.14.59.42;	author krw;	state Exp;
branches;
next	1.149;
commitid	TDloDnGAJKxV5TnQ;

1.149
date	2015.02.10.04.20.26;	author krw;	state Exp;
branches;
next	1.148;
commitid	TKehEr2jJpb2ARar;

1.148
date	2015.02.07.02.07.32;	author krw;	state Exp;
branches;
next	1.147;
commitid	WadF2oct8H7f0Oaz;

1.147
date	2015.01.16.06.39.56;	author deraadt;	state Exp;
branches;
next	1.146;
commitid	Uu5nFG3wCl0LACBb;

1.146
date	2014.12.10.02.34.03;	author krw;	state Exp;
branches;
next	1.145;
commitid	ctbVz96wZgUYQsW7;

1.145
date	2014.12.05.15.47.05;	author krw;	state Exp;
branches;
next	1.144;
commitid	SbDeDj1TfxdJZP9f;

1.144
date	2014.11.23.18.22.45;	author krw;	state Exp;
branches;
next	1.143;
commitid	A0DT3bmZICMqss1d;

1.143
date	2014.11.23.14.02.21;	author krw;	state Exp;
branches;
next	1.142;
commitid	TQpXaDPB2gC7POWf;

1.142
date	2014.11.01.15.49.07;	author krw;	state Exp;
branches;
next	1.141;
commitid	w5Quqsm7xyo3zcuD;

1.141
date	2014.10.29.15.28.51;	author krw;	state Exp;
branches;
next	1.140;
commitid	JuTrpYbMuawgGoRl;

1.140
date	2014.10.27.17.01.28;	author krw;	state Exp;
branches;
next	1.139;
commitid	Yg7bk47z8kd8w06x;

1.139
date	2014.05.23.15.26.22;	author krw;	state Exp;
branches;
next	1.138;

1.138
date	2014.04.30.15.11.00;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2014.04.17.09.59.30;	author krw;	state Exp;
branches;
next	1.136;

1.136
date	2014.02.09.20.45.56;	author krw;	state Exp;
branches;
next	1.135;

1.135
date	2014.01.21.05.17.45;	author krw;	state Exp;
branches;
next	1.134;

1.134
date	2014.01.21.03.07.50;	author krw;	state Exp;
branches;
next	1.133;

1.133
date	2014.01.19.10.06.09;	author krw;	state Exp;
branches;
next	1.132;

1.132
date	2014.01.19.08.25.54;	author krw;	state Exp;
branches;
next	1.131;

1.131
date	2014.01.19.04.36.04;	author krw;	state Exp;
branches;
next	1.130;

1.130
date	2014.01.13.02.38.52;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2014.01.12.04.17.36;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2013.12.30.03.36.17;	author krw;	state Exp;
branches;
next	1.127;

1.127
date	2013.12.21.18.23.10;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2013.12.12.00.22.06;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2013.11.19.15.12.23;	author mikeb;	state Exp;
branches;
next	1.123;

1.123
date	2013.11.11.21.00.01;	author krw;	state Exp;
branches;
next	1.122;

1.122
date	2013.10.22.18.15.58;	author krw;	state Exp;
branches;
next	1.121;

1.121
date	2013.06.09.22.39.51;	author krw;	state Exp;
branches;
next	1.120;

1.120
date	2013.06.09.15.06.34;	author krw;	state Exp;
branches;
next	1.119;

1.119
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.118;

1.118
date	2013.06.01.16.26.07;	author krw;	state Exp;
branches;
next	1.117;

1.117
date	2013.05.05.16.45.01;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.115;

1.115
date	2013.05.02.14.48.35;	author krw;	state Exp;
branches;
next	1.114;

1.114
date	2013.04.27.17.54.24;	author krw;	state Exp;
branches;
next	1.113;

1.113
date	2013.04.05.19.19.05;	author krw;	state Exp;
branches;
next	1.112;

1.112
date	2013.03.30.16.10.01;	author krw;	state Exp;
branches;
next	1.111;

1.111
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2013.02.17.17.36.31;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2013.02.14.20.39.46;	author krw;	state Exp;
branches;
next	1.108;

1.108
date	2013.02.03.21.04.19;	author krw;	state Exp;
branches;
next	1.107;

1.107
date	2013.01.27.02.45.46;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2013.01.26.05.07.21;	author krw;	state Exp;
branches;
next	1.105;

1.105
date	2013.01.26.04.11.39;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2013.01.18.05.50.32;	author krw;	state Exp;
branches;
next	1.103;

1.103
date	2013.01.17.23.41.07;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2013.01.16.21.35.41;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2013.01.16.11.02.09;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2013.01.16.06.11.21;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2013.01.05.20.34.17;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2012.12.19.12.25.38;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2012.12.04.19.24.03;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2012.12.02.17.03.19;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2012.11.27.15.51.48;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2012.11.25.12.49.56;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2012.11.14.15.47.41;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2012.11.07.17.42.52;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2012.11.07.15.40.13;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2012.11.06.00.05.11;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2012.11.04.03.36.39;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2012.11.04.03.25.31;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.03.16.54.34;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2012.10.31.15.50.47;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.27.23.08.53;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2012.09.18.09.34.09;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2012.09.01.19.08.42;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2012.08.26.23.33.30;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2012.08.22.00.14.42;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2012.08.18.00.23.30;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2012.07.09.16.21.21;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2012.06.24.16.01.18;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2011.12.10.15.55.43;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2011.05.11.14.38.36;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.04.11.14.52;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.02.22.03.27;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.02.09.57.16;	author phessler;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.06.04.02.42;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.10.23.19.36;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2008.05.26.03.11.48;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.09.05.19.14;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.25.16.27.20;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.27.22.05.24;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2007.01.25.01.21.04;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.16.20.22.20;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.11.02.36.29;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.04.22.30.57;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.04.22.17.48;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.04.19.12.41;	author stevesk;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.27.20.56.33;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2006.12.22.03.18.14;	author stevesk;	state Exp;
branches;
next	1.54;

1.54
date	2006.12.16.15.13.45;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.27.19.32.17;	author stevesk;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.27.16.14.07;	author stevesk;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.21.15.04.59;	author stevesk;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.21.00.10.06;	author stevesk;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.29.03.55.09;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.08.17.25.59;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.05.16.23.30;	author moritz;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.02.02.34.03;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.17.19.33.55;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.16.18.38.45;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.16.14.09.51;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.13.23.25.55;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.11.18.09.09;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.09.16.16.11;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.09.14.36.15;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.09.01.06.00;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.08.14.15.23;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.08.00.57.36;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.07.20.03.40;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.07.16.24.24;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.06.22.29.15;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.04.12.52.05;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.14.20.22.27;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.14.20.15.47;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.05.23.57.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.02.18.49.21;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.02.15.41.44;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.02.13.39.44;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.02.12.56.30;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.02.12.46.44;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.02.12.40.31;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.25.14.22.12;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.24.17.26.43;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.24.17.02.40;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.24.15.35.56;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.24.14.49.08;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.24.13.36.13;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.24.13.21.32;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.24.13.08.26;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.24.12.41.28;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.23.20.16.00;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.23.20.09.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.23.19.51.15;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.23.19.19.12;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.23.18.21.15;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.10.13.12.48;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.13.26.35;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.01.18.26;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.185
log
@We accept either the first offer received, or an offer for the
current address if one arrives inside select_timeout. So there
is no need to keep a list of received offers. Just keep the
best one and DECLINE the rest. Nuke now unused 'offered_leases'
TAILQ.

Also fixes the oddity that the *last* offer for the current
address is taken rather than the *first*.
@
text
@/*	$OpenBSD: dhcpd.h,v 1.184 2017/06/17 15:53:03 krw Exp $	*/

/*
 * Copyright (c) 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.    All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#define	LOCAL_PORT	68
#define	REMOTE_PORT	67
#define	INTERNALSIG	INT_MAX
#define DB_TIMEFMT	"%w %Y/%m/%d %T UTC"
#define BAD_DB_TIMEFMT	"%u %Y/%m/%d %T"
#define OLD_DB_TIMEFMT	"%w %Y/%m/%d %T"

struct option {
	char *name;
	char *format;
};

struct option_data {
	unsigned int	 len;
	u_int8_t	*data;
};

struct reject_elem {
	TAILQ_ENTRY(reject_elem) next;
	struct in_addr		 addr;
};

struct client_lease {
	TAILQ_ENTRY(client_lease) next;
	time_t			 expiry, renewal, rebind;
	struct in_addr		 address;
	struct in_addr		 next_server;
	char			*server_name;
	char			*filename;
	char			*resolv_conf;
	char			 ssid[32];
	uint8_t			 ssid_len;
	unsigned int		 is_static;
	struct option_data	 options[256];
};
#define BOOTP_LEASE(l)	((l)->options[DHO_DHCP_MESSAGE_TYPE].len == 0)

/* Possible states in which the client can be. */
enum dhcp_state {
	S_PREBOOT,
	S_REBOOTING,
	S_INIT,
	S_SELECTING,
	S_REQUESTING,
	S_BOUND,
	S_RENEWING,
	S_REBINDING
};

struct client_config {
	struct option_data	defaults[256];
	enum {
		ACTION_DEFAULT,
		ACTION_SUPERSEDE,
		ACTION_PREPEND,
		ACTION_APPEND
	} default_actions[256];

	struct in_addr		 address;
	struct in_addr		 next_server;
	struct option_data	 send_options[256];
	u_int8_t		 required_options[256];
	u_int8_t		 requested_options[256];
	u_int8_t		 ignored_options[256];
	int			 requested_option_count;
	int			 required_option_count;
	int			 ignored_option_count;
	time_t			 timeout;
	time_t			 initial_interval;
	time_t			 link_timeout;
	time_t			 retry_interval;
	time_t			 select_interval;
	time_t			 reboot_timeout;
	time_t			 backoff_cutoff;
	TAILQ_HEAD(, reject_elem) reject_list;
	char			*resolv_tail;
	char			*filename;
	char			*server_name;
};

struct interface_info {
	struct ether_addr	 hw_address;
	char			 name[IFNAMSIZ];
	char			 ssid[32];
	uint8_t			 ssid_len;
	struct client_state	*client;
	int			 bfdesc; /* bpf - reading & broadcast writing*/
	int			 ufdesc; /* udp - unicast writing */
	unsigned char		*rbuf;
	size_t			 rbuf_max;
	size_t			 rbuf_offset;
	size_t			 rbuf_len;
	int			 errors;
	u_int16_t		 index;
	int			 linkstat;
	int			 rdomain;
	int			 flags;
#define	IFI_VALID_LLADDR	0x01
#define IFI_NEW_LLADDR		0x02
#define IFI_HUP			0x04
#define IFI_IS_RESPONSIBLE	0x08
#define IFI_IN_CHARGE		0x10
	struct dhcp_packet	 recv_packet;
	struct dhcp_packet	 sent_packet;
	int			 sent_packet_length;
	u_int32_t		 xid;
	u_int16_t		 secs;
	time_t			 first_sending;
	time_t			 startup_time;
	enum dhcp_state		 state;
	struct in_addr		 destination;
	time_t			 interval;
	struct in_addr		 requested_address;
	struct client_lease	*active;
	struct client_lease	*new;
	TAILQ_HEAD(_leases, client_lease) leases;
};

struct dhcp_timeout {
	time_t			when;
	void			(*func)(struct interface_info *);
	struct interface_info	*ifi;
};

#define	_PATH_RESOLV_CONF	"/etc/resolv.conf"
#define	_PATH_DHCLIENT_CONF	"/etc/dhclient.conf"
#define	_PATH_DHCLIENT_DB	"/var/db/dhclient.leases"

/* External definitions. */

extern struct client_config *config;
extern struct imsgbuf *unpriv_ibuf;
extern volatile sig_atomic_t quit;
extern struct in_addr deleting;
extern struct in_addr adding;
extern struct in_addr active_addr;

/* options.c */
int cons_options(struct interface_info *, struct option_data *);
char *pretty_print_option(unsigned int, struct option_data *, int);
char *pretty_print_domain_search(unsigned char *, size_t);
char *pretty_print_string(unsigned char *, size_t, int);
char *pretty_print_classless_routes(unsigned char *, size_t);
void do_packet(struct interface_info *, unsigned int, struct in_addr,
    struct ether_addr *);

/* conflex.c */
extern int lexline, lexchar;
extern char *token_line, *tlname;
void new_parse(char *);
int next_token(char **, FILE *);
int peek_token(char **, FILE *);

/* parse.c */
void skip_to_semi(FILE *);
int parse_semi(FILE *);
char *parse_string(FILE *, unsigned int *);
int parse_ip_addr(FILE *, struct in_addr *);
int parse_cidr(FILE *, unsigned char *);
void parse_ethernet(FILE *, struct ether_addr *);
void parse_lease_time(FILE *, time_t *);
int parse_decimal(FILE *, unsigned char *, char);
int parse_hex(FILE *, unsigned char *);
time_t parse_date(FILE *);
void parse_warn(char *);

/* bpf.c */
void if_register_send(struct interface_info *);
void if_register_receive(struct interface_info *);
ssize_t send_packet(struct interface_info *, struct in_addr, struct in_addr);
ssize_t receive_packet(struct interface_info *, struct sockaddr_in *,
    struct ether_addr *);

/* dispatch.c */
void dispatch(struct interface_info *);
void set_timeout(time_t, void (*)(struct interface_info *),
    struct interface_info *);
void set_timeout_interval(time_t, void (*)(struct interface_info *),
    struct interface_info *);
void cancel_timeout(void);
void interface_link_forceup(char *);
int interface_status(struct interface_info *);
int get_rdomain(char *);
void get_hw_address(struct interface_info *);

/* tables.c */
extern const struct option dhcp_options[256];

/* dhclient.c */
extern char *path_dhclient_conf;
extern char *path_dhclient_db;
extern int log_perror;
extern int routefd;

void dhcpoffer(struct interface_info *, struct option_data *, char *);
void dhcpack(struct interface_info *, struct option_data *,char *);
void dhcpnak(struct interface_info *, struct option_data *,char *);

void free_client_lease(struct client_lease *);

void routehandler(struct interface_info *);

/* packet.c */
void assemble_eh_header(struct interface_info *, struct ether_header *);
ssize_t decode_hw_header(unsigned char *, u_int32_t, struct ether_addr *);
ssize_t decode_udp_ip_header(unsigned char *, u_int32_t, struct sockaddr_in *);
u_int32_t checksum(unsigned char *, u_int32_t, u_int32_t);
u_int32_t wrapsum(u_int32_t);

/* clparse.c */
void read_client_conf(struct interface_info *);
void read_client_leases(struct interface_info *);

/* kroute.c */
void delete_addresses(struct interface_info *);
void delete_address(struct in_addr);

void set_interface_mtu(int);
void add_address(struct in_addr, struct in_addr);

void flush_routes(void);

void add_route(struct in_addr, struct in_addr, struct in_addr, struct in_addr,
    int, int);

int resolv_conf_priority(struct interface_info *);

void flush_unpriv_ibuf(const char *);
@


1.184
log
@DECLINE offers as they are deemed invalid. Decline them at the
first problem rather than continuing to look for other reasons
to decline them. Nuke is_invalid field since it is now unused.
More informative log message when a lease is determined to be
unacceptable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.183 2017/06/16 14:12:12 krw Exp $	*/
a156 1
	TAILQ_HEAD(, client_lease) offered_leases;
@


1.183
log
@Nuke 'is_bootp' field and just use a #define to check if the lease
has DHO_DHCP_MESSAGE_TYPE info.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.182 2017/06/15 17:06:17 krw Exp $	*/
a74 1
	unsigned int		 is_invalid;
@


1.182
log
@Nuke unused parameter 'client_addr' from the 'handlers', i.e.
dhcpoffer(), dhcpack(), dhcpnak().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.181 2017/06/14 20:27:08 krw Exp $	*/
a74 1
	unsigned int		 is_bootp;
d78 1
@


1.181
log
@No need to be coy - call a "struct interface_info *" a
"struct interface_info *" and not a "void *".

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.180 2017/06/14 16:52:35 krw Exp $	*/
d238 3
a240 6
void dhcpoffer(struct interface_info *, struct in_addr, struct option_data *,
    char *);
void dhcpack(struct interface_info *, struct in_addr, struct option_data *,
    char *);
void dhcpnak(struct interface_info *, struct in_addr, struct option_data *,
    char *);
@


1.180
log
@Move active, new, offered_leases, leases from
client_state to interface_info.

Nuke empty struct client_state.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.179 2017/06/14 16:29:58 krw Exp $	*/
d163 3
a165 3
	time_t	 when;
	void	 (*func)(void *);
	void	*arg;
d219 4
a222 2
void set_timeout(time_t, void (*)(void *), void *);
void set_timeout_interval(time_t, void (*)(void *), void *);
@


1.179
log
@Move state, destination, interval, requested_address from
client_state to interface_info.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.178 2017/06/14 16:09:42 krw Exp $	*/
a122 7
struct client_state {
	struct client_lease	*active;
	struct client_lease	*new;
	TAILQ_HEAD(, client_lease) offered_leases;
	TAILQ_HEAD(_leases, client_lease) leases;
};

d156 4
@


1.178
log
@Move xid, secs, first_sending, startup_time fields from
client_state to interface_info.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.177 2017/06/14 15:57:25 krw Exp $	*/
a127 4
	enum dhcp_state		 state;
	struct in_addr		 destination;
	time_t			 interval;
	struct in_addr		 requested_address;
d159 4
@


1.177
log
@Start consolidating client_state into interface_info. First
fields to move: recv_packet, sent_packet and sent_packet_length.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.176 2017/06/14 15:39:55 krw Exp $	*/
a129 4
	u_int32_t		 xid;
	u_int16_t		 secs;
	time_t			 first_sending;
	time_t			 startup_time;
d159 4
@


1.176
log
@No need for two 'flags' fields. Consolidate into one, fixing
value of IFI_HUP while passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.175 2017/06/13 16:02:46 krw Exp $	*/
a134 3
	struct dhcp_packet	 recv_packet;
	struct dhcp_packet	 sent_packet;
	int			 sent_packet_length;
d160 3
@


1.175
log
@Kill unused #define IFI_NOMEDIA.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.174 2017/06/13 15:49:32 krw Exp $	*/
a129 3
	int			 flags;
#define IS_RESPONSIBLE	0x1
#define IN_CHARGE	0x2
d142 4
a145 4
	struct ether_addr	hw_address;
	char		 name[IFNAMSIZ];
	char		 ssid[32];
	uint8_t		 ssid_len;
d147 16
a162 14
	int		 bfdesc; /* bpf - reading & broadcast writing*/
	int		 ufdesc; /* udp - unicast writing */
	unsigned char	*rbuf;
	size_t		 rbuf_max;
	size_t		 rbuf_offset;
	size_t		 rbuf_len;
	int		 errors;
	u_int16_t	 index;
	int		 linkstat;
	int		 rdomain;
	int		 flags;
#define	IFI_VALID_LLADDR	0x00000001
#define IFI_NEW_LLADDR		0x00000002
#define IFI_HUP			0x00000003
@


1.174
log
@Rename 'packet' field to 'recv_packet' and 'bootrequest_packet'
field to 'sent_packet'. Also 'bootrequest_packet_length' to
'sent_packet_length'.

Adopt consistent idiom of a local variable 'packet' to point at
packet being manipulated.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.173 2017/06/10 18:03:50 krw Exp $	*/
d163 1
a163 2
#define IFI_NOMEDIA		0x00000004
#define IFI_HUP			0x00000008
@


1.173
log
@Nuke unused field bootp_policy and associated enum{}.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.172 2017/06/10 17:56:29 krw Exp $	*/
d138 3
a140 3
	struct dhcp_packet	 packet;
	struct dhcp_packet	 bootrequest_packet;
	int			 bootrequest_packet_length;
@


1.172
log
@Nuke unused global warnings_occurred.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.171 2017/04/18 13:59:09 krw Exp $	*/
a116 2
	enum { IGNORE, ACCEPT, PREFER }
				 bootp_policy;
@


1.171
log
@Tweak parameters to decode_*, add a check or two, and thus gain most of the
sanity improvements reyk@@ recently put into dhcrelay to ensure no more than
the captured packet is processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.170 2017/04/11 10:40:14 krw Exp $	*/
a204 1
extern int warnings_occurred;
@


1.170
log
@Fold priv_write_file() into its only remaining user
priv_write_resolv_conf() and move the latter into kroute.c
with all its priv_ friends.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.169 2017/04/08 20:16:04 krw Exp $	*/
d257 2
a258 3
ssize_t decode_hw_header(unsigned char *, int, struct ether_addr *);
ssize_t decode_udp_ip_header(unsigned char *, int, struct sockaddr_in *,
    u_int32_t);
@


1.169
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.168 2017/04/08 18:54:52 krw Exp $	*/
d175 1
@


1.168
log
@Replace another snprintf() dance with easier to read code using
strlcat(). Shorter, clearer, fewer signed vs unsigned questions.

Use an 8K static buffer for pretty_print_classless() and use it
rather scribbling intermediate values into the final destination.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.167 2017/04/08 17:00:10 krw Exp $	*/
d207 1
a207 1
char *parse_string(FILE *, int *);
d258 2
a259 2
    int);
u_int32_t checksum(unsigned char *, unsigned, u_int32_t);
@


1.167
log
@Replace a mess of snprintf() dances with easier to read code using
strlcat(). Shorter, clearer, fewer signed vs unsigned questions.

Shrink static buffer for the string version of an option value from
32K to 8K. Since the string version of the entire lease is constructed
in a 8K buffer, bigger option values are pointless.

Use 8K of the saved space for a static buffer for pretty_print_string()
and use it rather scribbling intermediate values into the final
destination.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.166 2017/04/07 15:03:00 krw Exp $	*/
d192 1
a192 2
int pretty_print_classless_routes(unsigned char *, size_t, unsigned char *,
    size_t);
@


1.166
log
@Simply decoding of domain search option. No intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.165 2017/04/05 18:22:30 krw Exp $	*/
d191 1
a191 1
int pretty_print_string(unsigned char *, size_t, unsigned char *, size_t, int);
@


1.165
log
@Shuffle sendhup() into dispatch.c, the only place it is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.164 2017/04/04 15:15:48 krw Exp $	*/
d190 1
a192 2
    size_t);
int pretty_print_domain_search(unsigned char *, size_t, unsigned char *,
@


1.164
log
@Send a RTM_PROPOSAL to clear out other dhclient instances on startup.

Replaces forcing interface link state down and up to generate
RTM_IFINFO messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.163 2017/04/04 13:01:20 krw Exp $	*/
a280 2

void sendhup(struct client_lease *);
@


1.163
log
@Treat SSID's like the 0 to 32 bytes of uint8_t data that they really
are. Track and use the actual lengths and use memcpy()/memcmp()
instead of strcmp()/strdup().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.162 2017/04/03 19:59:39 krw Exp $	*/
d134 1
@


1.162
log
@Change parse_string() to take an optional integer pointer that can
be used to return the final size of the parsed (i.e. un-vis'ed)
string. Use same, plus memcpy() to ensure entire final string is
copied to intended destination even if there are embedded NULs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.161 2017/03/08 20:33:20 krw Exp $	*/
d72 2
a73 1
	char			 ssid[33];
d148 2
a149 1
	char		 ssid[33];
@


1.161
log
@Shuffle, shuffle, shuffle.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.160 2017/02/12 13:15:50 krw Exp $	*/
d206 1
a206 1
char *parse_string(FILE *);
@


1.160
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.159 2017/02/11 16:12:36 krw Exp $	*/
d179 1
a182 1
extern volatile sig_atomic_t quit;
d277 2
a279 2

int resolv_conf_priority(struct interface_info *);
@


1.159
log
@Move parse_warning() into parse.c to prepare to replace errwarn.c
with standard daemon log.[ch].

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.158 2016/09/02 15:44:26 mpi Exp $	*/
a194 9
/* errwarn.c */
extern int warnings_occurred;
void error(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
void warning(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
void note(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
#ifdef DEBUG
void debug(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
#endif

d203 1
@


1.158
log
@Kill 'ifi' global.

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.157 2016/08/31 12:57:31 mpi Exp $	*/
a202 1
void parse_warn(char *);
d222 1
@


1.157
log
@Remove the 'client' global and make it per-ifp.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.156 2016/08/23 09:26:02 mpi Exp $	*/
d168 2
a169 1
	void	 (*func)(void);
d233 2
a234 2
void set_timeout(time_t, void (*)(void));
void set_timeout_interval(time_t, void (*)(void));
d250 6
a255 3
void dhcpoffer(struct in_addr, struct option_data *, char *);
void dhcpack(struct in_addr, struct option_data *, char *);
void dhcpnak(struct in_addr, struct option_data *, char *);
d259 1
a259 1
void routehandler(void);
@


1.156
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.155 2016/08/16 21:57:51 krw Exp $	*/
d148 1
a175 1
extern struct client_state *client;
d184 1
a184 1
int cons_options(struct option_data *);
@


1.155
log
@Track SSID in leases file and only consider leases from the current SSID when
starting up dhclient on wifi interfaces. In theory will preserve leases from
other SSID's and speed up obtaining a lease by not wasting time attempting
to re-acquire a lease from a different SSID.

Experimental feature from n2k16 needing some real world testing before g2k16.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.154 2016/02/06 19:30:52 krw Exp $	*/
a174 1
extern struct interface_info *ifi;
d191 2
a192 1
void do_packet(unsigned int, struct in_addr, struct ether_addr *);
d224 5
a228 4
void if_register_send(void);
void if_register_receive(void);
ssize_t send_packet(struct in_addr, struct in_addr);
ssize_t receive_packet(struct sockaddr_in *, struct ether_addr *);
d231 1
a231 1
void dispatch(void);
d236 1
a236 1
int interface_status(char *);
d238 1
a238 1
void get_hw_address(void);
d258 1
a258 1
void assemble_eh_header(struct ether_header *);
d266 2
a267 2
void read_client_conf(void);
void read_client_leases(void);
d270 1
a270 1
void delete_addresses(void);
d283 1
a283 1
int resolv_conf_priority(void);
@


1.154
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.153 2015/12/12 14:48:17 krw Exp $	*/
d72 1
d147 1
@


1.153
log
@Send DECLINE messages in response to ACK messages that turn out to
have inadequate or invalid leases. In particular leases for addresses
that are already configured on a different interface. After the
DECLINE, return to INIT state and start looking for a valid lease. This
conforms much closer to the relevant RFC's.

Avoids 'hanging' dhclient(8) during boot when the attempt to configure
the address fails without dhclient(8) realizing it.

Issue found and various fixes tested by mpi@@. Feedback from beck@@ and
reyk@@.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.152 2015/10/26 16:32:33 krw Exp $	*/
a40 33

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "dhcp.h"
@


1.152
log
@Give dhclient(8) the ability to use option 119, a.k.a. "Domain
Search" if supplied by the server.

Requested by a few. Original diff from Ray Lai via tech@@.

Tested & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.151 2015/08/19 17:52:10 krw Exp $	*/
d105 3
a107 2
	unsigned int		 is_static : 1;
	unsigned int		 is_bootp : 1;
@


1.151
log
@Missing prototypes. Noted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.150 2015/05/18 14:59:42 krw Exp $	*/
d219 2
@


1.150
log
@Stop rejecting leases with a subnet that overlaps a subnet already
present. The latest routing stack code can now handle these situations.

Much requested by beck@@ and others. Detailed discussion at s2k15
identified required routing changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.149 2015/02/10 04:20:26 krw Exp $	*/
d218 2
@


1.149
log
@Groundwork for better route support over multiple interfaces by
using RTM_IFA to bind routes to an interface. Keep the subnet route
conflict avoidance code for the time being.

diff from claudio@@ as part of larger routing magic diff.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.148 2015/02/07 02:07:32 krw Exp $	*/
a263 1
int subnet_exists(struct client_lease *);
@


1.148
log
@GC unused parameters now that ifname and rdomain are not used in
constructing imsgs.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.147 2015/01/16 06:39:56 deraadt Exp $	*/
d304 2
a305 1
void add_route(struct in_addr, struct in_addr, struct in_addr, int, int);
@


1.147
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.146 2014/12/10 02:34:03 krw Exp $	*/
d296 2
a297 2
void delete_addresses(char *, int);
void delete_address(char *, int, struct in_addr);
d299 2
a300 1
void add_address(char *, int, struct in_addr, struct in_addr);
d302 1
a302 1
void flush_routes(char *, int);
d304 1
a304 1
void add_route(int, struct in_addr, struct in_addr, struct in_addr, int, int);
d308 1
a308 1
int resolv_conf_priority(int);
@


1.146
log
@Reusing the same field for different things in different contexts may
be clever, but it is definitely confusing. Use a flag IFI_VALID_LLADDR
to indicate that the ifi->hw_address field is valid, rather than
assuming ifi->linkstat does that. Add startup_time to record client
startup rather than using first_sending and hoping nobody else needs
it until link is complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.145 2014/12/05 15:47:05 krw Exp $	*/
d68 1
@


1.145
log
@Move initial wait for network link into the state machine by adding
state S_PREBOOT and associated state_preboot() function.

This results in routing socket messages being processed even while
the link is being waited for. Thus the RTM_IFINFO message announcing
the link is ready can be reacted to immediately, rather than waiting
for the sleep(1)'ing process to wake up and look at the link state.

Some interfaces seem to lose the first packet sent when the RTM_IFINFO
message is reacted to so quickly, so temporarily leave in place an
explicit delay before sending the first packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.144 2014/11/23 18:22:45 krw Exp $	*/
d166 1
d188 4
a191 3
#define IFI_NEW_LLADDR	0x00000001
#define IFI_HUP		0x00000002
#define IFI_NOMEDIA	0x00000004
@


1.144
log
@Rename discover_interface() to more meaningful get_hw_address().

Hoist one-time initialization of client identifier out of
get_hw_address() to the one-time initialization code in main().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.143 2014/11/23 14:02:21 krw Exp $	*/
d111 1
@


1.143
log
@Cleanup some struct interface_info fields. Make 'nomedia' a flag. Replace
the two copies of the bpf socket descriptor (rfdesc, wfdesc) with
just one (bfdesc). No need to keep a struct ifreq (ifp) since it's
only used once and can be constructed there and discarded. Nuke
unused 'primary_address' member.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.142 2014/11/01 15:49:07 krw Exp $	*/
a251 1
void discover_interface(void);
d259 1
@


1.142
log
@Try to ensure that the various lease timeouts are sane. i.e., renew
is before rebind is before expiry. Don't allow lease expiry to be
set past the end of time, but do allow lease lengths >INT32_MAX.

Tweak default times to be more reliably in-line with RFCs.

Nuke getULong(), the last function in convert.c, since its last
uses were in this now re-written code.

Suspicions aroused while diagnosing the expiry problem weerd@@ found.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.141 2014/10/29 15:28:51 krw Exp $	*/
a173 1
	struct in_addr	 primary_address;
d175 2
a176 3
	int		 rfdesc;
	int		 wfdesc;
	int		 ufdesc; /* unicast */
a180 2
	struct ifreq	*ifp;
	int		 noifmedia;
d188 1
@


1.141
log
@Calling a function to htonl() a constant 32-bit value into a stack
variable and memcpy() that value into 4 bytes of malloc()'d space
seems roundabout.

Just memcpy() a four byte constant string into the malloc()'d space
as required and kill putULong(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.140 2014/10/27 17:01:28 krw Exp $	*/
a266 3

/* convert.c */
u_int32_t getULong(unsigned char *);
@


1.140
log
@Nuke getLong(), getShort(), getUShort(). Two line functions (memcpy();
ntoh[ls]()) obscure rather than simplify things. Especially when
they are used only once. Just use the expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.139 2014/05/23 15:26:22 krw Exp $	*/
a269 1
void putULong(unsigned char *, u_int32_t);
@


1.139
log
@A #define to rename another #define which is then used only once introduces
more obscurity than clarity. Nuke DHCPD_LOG_FACILITY and just use
LOG_DAEMON in openlog() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.138 2014/04/30 15:11:00 krw Exp $	*/
a269 3
int32_t getLong(unsigned char *);
u_int16_t getUShort(unsigned char *);
int16_t getShort(unsigned char *);
@


1.138
log
@Preserve intended chronological order of leases in
dhclient.leases.<if> files by writing out in reverse the
reverse-chronological-order TAILQ client->leases.

Found while trying to restore static lease functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.137 2014/04/17 09:59:30 krw Exp $	*/
a200 1
#define	DHCPD_LOG_FACILITY	LOG_DAEMON
@


1.137
log
@Eliminate a couple of always-NULL parameters. Eliminate some
pointless repetition of well-known info in log messages. Pass
around smaller bits of info. Make 'inaddr_any' a const struct
initialized with { INADDR_ANY }.

Tweaks and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.136 2014/02/09 20:45:56 krw Exp $	*/
d157 1
a157 1
	TAILQ_HEAD(, client_lease) leases;
@


1.136
log
@Don't use imsg_flush(), roll a local flush_unpriv_ibuf() that loops
on EAGAIN, sets quit to INTERNALSIG on errors (unless quit is already
set to something else), and prints a consistant error message when
errors other than EPIPE and end of file are encountered.

Fixes failure to write resolv.conf when -L is used, and makes
add_address() and add_route() also wait until imsg is in pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.135 2014/01/21 05:17:45 krw Exp $	*/
d252 1
a252 1
ssize_t send_packet(struct in_addr, struct sockaddr_in *, struct ether_addr *);
d291 1
a291 1
void assemble_eh_header(struct ether_header *, struct ether_addr *);
@


1.135
log
@Allow dhclient.conf to specify 'fixed-address', 'next-server',
'filename' and 'server-name'. dhclient.conf can now override anything
in an offer or saved lease when creating the effective lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.134 2014/01/21 03:07:50 krw Exp $	*/
d315 2
@


1.134
log
@Add parsing for options 121 (classless-static-routes) and 249
(classless-ms-static-routes). dhcpd can now specify and serve
these options and dhclient can recognize and use supersede, etc.
statements on them.

Based on a diff from Stefan Rinke. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.133 2014/01/19 10:06:09 krw Exp $	*/
d129 2
d149 2
@


1.133
log
@Nuke unused functions putLong(), putUShort(), putShort().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.132 2014/01/19 08:25:54 krw Exp $	*/
d238 1
@


1.132
log
@Redo the parsing of numbers to improve the error messages and
make the code more readable. And prepare for some new things
that will need to be parsed.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.131 2014/01/19 04:36:04 krw Exp $	*/
a269 3
void putLong(unsigned char *, int32_t);
void putUShort(unsigned char *, unsigned int);
void putShort(unsigned char *, int);
@


1.131
log
@Rename parse_hardware_param() to parse_ethernet() to reflect what
it actually does.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.130 2014/01/13 02:38:52 krw Exp $	*/
d240 2
a241 1
void convert_num(unsigned char *, char *, int, int);
@


1.130
log
@warning(), note(), debug(), parse_warn() always return 0, which no
caller checks or saves. So just void them all.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.129 2014/01/12 04:17:36 krw Exp $	*/
d238 1
a238 1
void parse_hardware_param(FILE *, struct ether_addr *);
@


1.129
log
@Since the return value of read_client_conf() is not checked, don't
bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.128 2013/12/30 03:36:17 krw Exp $	*/
d219 2
a220 2
int warning(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int note(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
d222 1
a222 1
int debug(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
d224 1
a224 1
int parse_warn(char *);
@


1.128
log
@Replace yet another hand-rolled list with a TAILQ. reject_list this
time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.127 2013/12/21 18:23:10 krw Exp $	*/
d296 1
a296 1
int read_client_conf(void);
@


1.127
log
@Introduce pretty_print_string() and use for printing both text
valued options and previously snprintf()'d filename and servername
lease attributes.

Should fix "string constant too long" errors when reading back a
lease with filename or servername attributes with escaped characters.

Reported by Rivo Nurges.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.126 2013/12/12 00:22:06 krw Exp $	*/
d92 1
a92 1
	struct reject_elem	*next;
d145 1
a145 1
	struct reject_elem	*reject_list;
@


1.126
log
@Assemble outgoing packets using iovec to combine the (optional)
ethernet header, the ip header, the udp header and the packet.
Rather than manually concatenating the headers and then using iovec
to bundle in the packet. Eliminates some memcpy()s and convoluted
data copying.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.125 2013/12/06 23:40:48 krw Exp $	*/
d213 1
@


1.125
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.124 2013/11/19 15:12:23 mikeb Exp $	*/
d287 1
a287 3
void assemble_hw_header(unsigned char *, int *, struct ether_addr *);
void assemble_udp_ip_header(unsigned char *, int *, u_int32_t, u_int32_t,
    unsigned int, unsigned char *, int);
d291 2
@


1.124
log
@include queue.h directly instead of relying on if.h to provide it;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.123 2013/11/11 21:00:01 krw Exp $	*/
a95 6
struct hardware {
	u_int8_t htype;
	u_int8_t hlen;
	u_int8_t haddr[16];
};

d169 1
a169 1
	struct hardware	 hw_address;
d213 1
a213 1
void do_packet(unsigned int, struct in_addr, struct hardware *);
d237 1
a237 1
void parse_hardware_param(FILE *, struct hardware *);
d245 2
a246 2
ssize_t send_packet(struct in_addr, struct sockaddr_in *, struct hardware *);
ssize_t receive_packet(struct sockaddr_in *, struct hardware *);
d287 1
a287 1
void assemble_hw_header(unsigned char *, int *, struct hardware *);
d290 1
a290 1
ssize_t decode_hw_header(unsigned char *, int, struct hardware *);
@


1.123
log
@Shuffle function prototypes and extern declarations around to
put local functions prototypes and variables in their .c files, and
cross-file functions into .h files. Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.122 2013/10/22 18:15:58 krw Exp $	*/
d48 1
@


1.122
log
@Save 'next-server' (a.k.a. siaddr) info in leases file. Saving the
file name without the server address seems silly.

Tested & ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.121 2013/06/09 22:39:51 krw Exp $	*/
a243 1
int parse_numeric_aggregate(FILE *, unsigned char *, int, int, int);
a247 1
int if_register_bpf(void);
a255 1
void got_one(void);
a279 1
extern char path_option_db[MAXPATHLEN];
a286 16
void send_discover(void);
void send_request(void);
void send_decline(void);

void state_reboot(void);
void state_init(void);
void state_selecting(void);
void state_bound(void);
void state_panic(void);

void bind_lease(void);

void make_discover(struct client_lease *);
void make_request(struct client_lease *);
void make_decline(struct client_lease *);

a287 6
void rewrite_client_leases(void);
void rewrite_option_db(struct client_lease *, struct client_lease *);
char *lease_as_string(char *, struct client_lease *);

struct client_lease *packet_to_lease(struct in_addr, struct option_data *);
void go_daemon(void);
a290 2
void sendhup(struct client_lease *);

a301 8
void parse_client_statement(FILE *);
int parse_X(FILE *, u_int8_t *, int);
int parse_option_list(FILE *, u_int8_t *, size_t);
void parse_interface_declaration(FILE *);
void parse_client_lease_statement(FILE *, int);
void parse_client_lease_declaration(FILE *, struct client_lease *);
int parse_option_decl(FILE *, struct option_data *);
void parse_reject_statement(FILE *);
d312 4
@


1.121
log
@Make route adding interface more flexible by passing flags to be
used rather than deducing them. Use priv_add_route() to add
the 127.0.0.1 address when adding an address.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.120 2013/06/09 15:06:34 krw Exp $	*/
d105 1
@


1.120
log
@Re-apply route adding code refactoring -- it wasn't the problem that
broke populating the egress group.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.119 2013/06/09 00:30:06 krw Exp $	*/
d346 1
a346 1
void add_route(int, struct in_addr, struct in_addr, struct in_addr, int);
@


1.119
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.117 2013/05/05 16:45:01 krw Exp $	*/
d346 1
a346 1
void add_default_route(int, struct in_addr, struct in_addr);
@


1.118
log
@Refactor the default route adding code to use a general route adding
function that will be reused for future work.

ok claudio@@
@
text
@d346 1
a346 1
void add_route(int, struct in_addr, struct in_addr, struct in_addr, int);
@


1.117
log
@Add a flag to struct client_state (IS_RESPONSIBLE) to record when
the first expected RTM_NEWADDR arrives, which signals that a lease
has been bound to the interface. Ignore RTM_NEWADDR and RTM_DELADDR
messages until the flag has been set.

Makes it more likely that the last dhclient started will be the
last dhclient standing. Fixes the problem reported by David Higgs,
where restarting an install in a vm consistantly caused the new
dhclient to be the one that dies.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.116 2013/05/02 16:35:27 krw Exp $	*/
d346 1
a346 1
void add_default_route(int, struct in_addr, struct in_addr);
@


1.116
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.115 2013/05/02 14:48:35 krw Exp $	*/
d160 2
@


1.115
log
@Enough of the hand-rolling of queues. Turn client->leases and
client->offered_leases into TAILQs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.114 2013/04/27 17:54:24 krw Exp $	*/
d201 1
a201 1
/* External definitions... */
@


1.114
log
@Use same parse_date() and date writing logic as in dhcpd. i.e.
strptime() rather than handrolling parsing. Change date format
in leases to same as dhcpd, fixing 'u' vs 'w' error made in
initial strftime() introduction.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.113 2013/04/05 19:19:05 krw Exp $	*/
d102 1
a102 1
	struct client_lease	*next;
d156 2
a157 2
	struct client_lease	*offered_leases;
	struct client_lease	*leases;
@


1.113
log
@Nuke parameter to do_packet() not used since 2006. From dhill.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.112 2013/03/30 16:10:01 krw Exp $	*/
d76 3
@


1.112
log
@Since deleting all the addresses on an interface removes all the
relevant entries from the arp cache, don't bother asking for/processing
arp entries in the route dumps. Thus allowing use of NET_RT_FLAGS
with RTF_GATEWAY and AF_INET, to ask for only the routes dhclient
wants to expunge rather than all routes in existance.

Greatly shrinks and simplifies the code. No intentional functional
change. Tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.111 2013/02/18 15:57:08 krw Exp $	*/
d212 1
a212 1
void do_packet(int, unsigned int, struct in_addr, struct hardware *);
@


1.111
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.110 2013/02/17 17:36:31 krw Exp $	*/
d339 1
a339 1
void flush_routes_and_arp_cache(char *, int);
@


1.110
log
@Using the value SIGQUIT to cause the dispatch loops to exit produced
universal revulsion and no little confusion.  #define our own value,
currently INT_MAX, which should not overlap any likely signal value.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.109 2013/02/14 20:39:46 krw Exp $	*/
d184 3
d311 1
a311 1
void cleanup(struct client_lease *);
@


1.109
log
@Don't rely on the packet buffer (client->packet) being preserved between
attempts to send DISCOVER or REQUEST packets. Some DHCP servers might
NAK the DISCOVER, or other nefarious packets arrive, between attempts
and overwrite the packet being sent. Create and use another buffer
for packets being sent.

Problem encountered by fgsch@@, who noticed that once the DISCOVER was
NAK'ed our dhclient sent a bunch of NAK's back to the server. Like it
thought they were DISCOVER messages.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.108 2013/02/03 21:04:19 krw Exp $	*/
d75 1
@


1.108
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.107 2013/01/27 02:45:46 krw Exp $	*/
d161 2
a162 1
	int			 packet_length;
@


1.107
log
@Refactor code a bit. Calculate resolv.conf contents once when binding a
lease and reuse as required whenever resolv.conf is written. Use
write_file() rather than a custom message/functions to write out
resolv.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.106 2013/01/26 05:07:21 krw Exp $	*/
d314 1
a314 1
    unsigned char *, int);
@


1.106
log
@Read /etc/resolv.conf.tail once on startup and save contents for
application during subsequent resolv.conf building.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.105 2013/01/26 04:11:39 krw Exp $	*/
d103 1
@


1.105
log
@Whitespace tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.104 2013/01/18 05:50:32 krw Exp $	*/
d145 1
@


1.104
log
@Add command line option '-L' that specifies an optional file into which
the most recent offer and effective leases will be written. Intended
to allow access to dhcp option information that was formerly
passed to dhclient-script.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.103 2013/01/17 23:41:07 krw Exp $	*/
d87 2
a88 2
	struct reject_elem *next;
	struct in_addr addr;
d148 13
a160 13
	struct client_lease	 *active;
	struct client_lease	 *new;
	struct client_lease	 *offered_leases;
	struct client_lease	 *leases;
	enum dhcp_state		  state;
	struct in_addr		  destination;
	u_int32_t		  xid;
	u_int16_t		  secs;
	time_t			  first_sending;
	time_t			  interval;
	struct dhcp_packet	  packet;
	int			  packet_length;
	struct in_addr		  requested_address;
d164 16
a179 16
	struct hardware		 hw_address;
	struct in_addr		 primary_address;
	char			 name[IFNAMSIZ];
	int			 rfdesc;
	int			 wfdesc;
	int			 ufdesc; /* unicast */
	unsigned char		*rbuf;
	size_t			 rbuf_max;
	size_t			 rbuf_offset;
	size_t			 rbuf_len;
	struct ifreq		*ifp;
	int			 noifmedia;
	int			 errors;
	u_int16_t		 index;
	int			 linkstat;
	int			 rdomain;
d183 2
a184 2
	time_t		 when;
	void		 (*func)(void);
@


1.103
log
@Try harder to clear out default routes on the interface being
configured. Only exempt default routes labelled as being the
property of another dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.102 2013/01/16 21:35:41 krw Exp $	*/
d270 1
d296 2
a297 1
char *lease_as_string(struct client_lease *);
@


1.102
log
@Unrevert last reversion. otto@@ pointed out that it wasn't asprintf()
causing a problem, it was accessing uninitialized pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.101 2013/01/16 11:02:09 krw Exp $	*/
d330 1
a330 1
void flush_routes_and_arp_cache(int);
@


1.101
log
@Revert last. asprintf() breaks something.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.100 2013/01/16 06:11:21 krw Exp $	*/
d273 3
a275 3
void dhcpoffer(struct in_addr, struct option_data *);
void dhcpack(struct in_addr, struct option_data *);
void dhcpnak(struct in_addr, struct option_data *);
@


1.100
log
@Use the magic of asprintf() to produce more informative error
and log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.99 2013/01/05 20:34:17 krw Exp $	*/
d273 3
a275 3
void dhcpoffer(struct in_addr, struct option_data *, char *);
void dhcpack(struct in_addr, struct option_data *, char *);
void dhcpnak(struct in_addr, struct option_data *, char *);
@


1.99
log
@Change write_client_lease() into lease_as_string() and modify
rewrite_client_leases() to use lease_as_string(), writing out
complete leases at a time.

While here replace hand formatting of dates with strftime(). This
will add leading zeros to months and days, but not affect the
ability of dhclient to parse the resulting files.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.98 2012/12/19 12:25:38 krw Exp $	*/
d273 3
a275 3
void dhcpoffer(struct in_addr, struct option_data *);
void dhcpack(struct in_addr, struct option_data *);
void dhcpnak(struct in_addr, struct option_data *);
@


1.98
log
@Don't attempt to delete an address that has already been deleted
by a new dhclient (or anyone else). Instead, use add_address(...,
INADDR_ANY, ...) to tell the privileged process that its active
address is gone. Thus the cleanup process doesn't try to delete it.

Eliminates extraneous log entries complaining that the address can't
be deleted. Narrows race window where old dhclient might delete the
address the new dhclient has just added.

Make rapid-fire starting of dhclient even more reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.97 2012/12/04 19:24:03 krw Exp $	*/
d295 1
a295 1
void write_client_lease(struct client_lease *);
@


1.97
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.96 2012/12/02 17:03:19 krw Exp $	*/
d200 1
@


1.96
log
@Try harder to cleanup when exiting. In particular catch signals
SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUS2 and cleanup before exiting
when getting them. Cleanup meaning removing routes and the interface
address added.

Tweaks and feedback from phessler@@, sthen@@, otto@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.95 2012/11/27 15:51:48 krw Exp $	*/
d214 1
a214 1
int parse_warn(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
@


1.95
log
@Clean up parsing of option lists. Part 6.

Treat 'ignore' option lists the same as 'request' and 'require'
option lists. i.e.  keep a list of the options rather than using
an ACTION flag. So overriding a previous ignore list will not leave
breadcrumbs and incorrect ACTIONs lying around.

The list will be applied when the new lease is created, and will
override any ACTION specified for the option.

Mention in dhclient.conf(5) that each request/require/ignore statement
will override any previous one.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.94 2012/11/25 12:49:56 krw Exp $	*/
d199 1
d300 2
@


1.94
log
@Clean up parsing of option lists. Part 1.

1) Add config->required_options_count so that syntactically incorrect
request statement in dhclient.conf is completely ignored.
2) Pass size of buffer being filled instead of assuming 256.
3) Always zero (a.k.a. DHO_PAD) the passed in buffer.
4) Check for out of bounds index before using it, not after.

Add TOK_IGNORE to syntax in comment.

No intentional functional change other than catching bad request
statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.93 2012/11/23 15:25:47 krw Exp $	*/
a122 1
		ACTION_IGNORE,
d131 1
d134 1
@


1.93
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.92 2012/11/14 15:47:41 krw Exp $	*/
d133 1
d312 1
a312 1
int parse_option_list(FILE *, u_int8_t *);
@


1.92
log
@Remove useless _new_ and _old_ from various function names to make
them shorter and eliminate implications about what the function
does. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.91 2012/11/08 21:32:55 krw Exp $	*/
d194 1
a194 1
extern int privfd;
a297 2
void priv_resolv_conf(char *);

a320 1
void priv_delete_address(char *, int, struct in_addr);
a322 1
void priv_add_address(char *, int, struct in_addr, struct in_addr);
a324 1
void priv_flush_routes_and_arp_cache(int);
a326 1
void priv_add_default_route(int, struct in_addr, struct in_addr);
@


1.91
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.90 2012/11/07 17:42:52 krw Exp $	*/
d298 1
a298 1
void priv_new_resolv_conf(char *);
d321 3
a323 3
void delete_old_addresses(char *, int);
void delete_old_address(char *, int, struct in_addr);
void priv_delete_old_address(char *, int, struct in_addr);
d325 2
a326 2
void add_new_address(char *, int, struct in_addr, struct in_addr);
void priv_add_new_address(char *, int, struct in_addr, struct in_addr);
@


1.90
log
@Nuke unused struct and function declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.89 2012/11/07 15:40:13 krw Exp $	*/
d86 3
a88 8
struct iaddr {
	int len;
	unsigned char iabuf[16];
};

struct iaddrlist {
	struct iaddrlist *next;
	struct iaddr addr;
d100 1
a100 1
	struct iaddr		 address;
d142 1
a142 1
	struct iaddrlist	*reject_list;
d151 1
a151 1
	struct iaddr		  destination;
d158 1
a158 1
	struct iaddr		  requested_address;
d195 2
a196 2
extern struct iaddr iaddr_deleting;
extern struct iaddr iaddr_adding;
d201 1
a201 1
void do_packet(int, unsigned int, struct iaddr, struct hardware *);
d224 1
a224 1
int parse_ip_addr(FILE *, struct iaddr *);
a262 4
/* inet.c */
int addr_eq(struct iaddr, struct iaddr);
char *piaddr(struct iaddr);

d269 3
a271 3
void dhcpoffer(struct iaddr, struct option_data *);
void dhcpack(struct iaddr, struct option_data *);
void dhcpnak(struct iaddr, struct option_data *);
d293 1
a293 1
struct client_lease *packet_to_lease(struct iaddr, struct option_data *);
d322 2
a323 2
void delete_old_address(char *, int, struct iaddr);
void priv_delete_old_address(char *, int, struct iaddr);
d325 2
a326 2
void add_new_address(char *, int, struct iaddr, in_addr_t);
void priv_add_new_address(char *, int, struct iaddr, in_addr_t);
d331 2
a332 2
void add_default_route(int, struct iaddr, struct iaddr);
void priv_add_default_route(int, struct iaddr, struct iaddr);
@


1.89
log
@Always memcpy() into/out of option data rather than hoping the char *
will be always be aligned. Don't pass around pointers into option
data - use variable that has the memcpy()'d data.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.88 2012/11/06 00:05:11 krw Exp $	*/
a85 5
struct string_list {
	struct string_list	*next;
	char			string[1];	/* Actually bigger. */
};

a326 1
void parse_string_list(FILE *, struct string_list **, int);
@


1.88
log
@Kill two unused functions, subnet_number() and broadcast_addr().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.87 2012/11/04 03:36:39 krw Exp $	*/
d340 1
a340 1
void add_new_address(char *, int, struct iaddr, in_addr_t *);
@


1.87
log
@No need to pass interface name around when flushing routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.86 2012/11/04 03:25:31 krw Exp $	*/
a273 2
struct iaddr subnet_number(struct iaddr, struct iaddr);
struct iaddr broadcast_addr(struct iaddr, struct iaddr);
@


1.86
log
@No need to pass interface name around when creating routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.85 2012/11/03 16:54:34 krw Exp $	*/
d345 2
a346 2
void flush_routes_and_arp_cache(char *, int);
void priv_flush_routes_and_arp_cache(char *, int);
@


1.85
log
@Various fixes/tweaks for resolv.conf handling:

1) Don't leak a file descriptor if there are no contents for
resolv.conf.
2) Allow for only resolv.conf.tail to go into resolv.conf.
3) Don't need to pass around interface name when creating resolv.conf.
4) Don't leave 0 length resolv.conf lying around if there are no
contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.84 2012/10/31 15:50:47 krw Exp $	*/
d348 2
a349 2
void add_default_route(char *, int, struct iaddr, struct iaddr);
void priv_add_default_route(char *, int, struct iaddr, struct iaddr);
@


1.84
log
@Forcibly delete all existing ipv4 addresses from an interface when
binding a lease to that interface. This fixes issues sthen@@ found
with unexpectedly persistant addresses and failures of dhclient
when switching an interface repeatedly between different networks.

This crude but predictable behaviour may be toned down once it
is figured out what we want to do with mixed static/dynamic
configurations on an interface.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.83 2012/10/30 18:39:44 krw Exp $	*/
d314 1
a314 1
void priv_new_resolv_conf(char *, char *);
@


1.83
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.82 2012/10/27 23:08:53 krw Exp $	*/
d337 4
a340 3
/* route.c */
void delete_old_address (char *, int, struct iaddr);
void priv_delete_old_address (char *, int, struct iaddr);
d342 2
a343 2
void add_new_address (char *, int, struct iaddr, in_addr_t *);
void priv_add_new_address (char *, int, struct iaddr, in_addr_t);
@


1.82
log
@Change dhclient.conf directive 'ignore' to take a list of option names
rather than list of option declarations. e.g. 'ignore routers;'
instead of 'ignore routers 1.2.3.4;' The value in the declaration
was being ignored anyway.

While there clean up the related code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.81 2012/09/18 09:34:09 krw Exp $	*/
a149 1
	char			*script_name;
a168 2
	char			**scriptEnv;
	int			  scriptEnvsize;
d190 1
a190 1
struct timeout {
a196 1
#define	_PATH_DHCLIENT_SCRIPT	"/sbin/dhclient-script"
d204 3
d255 1
a256 1
int interface_link_forceup(char *);
a308 11
void	 priv_script_init(char *);
void	 priv_script_write_params(char *, struct client_lease *);
int	 priv_script_go(void);

void script_init(char *);
void script_write_params(char *, struct client_lease *);
int script_go(void);
void script_set_env(const char *, const char *, const char *);
void script_flush_env(void);
int dhcp_option_ev_name(char *, size_t, const struct option *);

d314 2
d336 13
@


1.81
log
@Don't accept leases that offer a subnet that is already configured
on an interface. Crude hammer that may be refined as needed.

Feedback from tedu@@, beck@@, sthen@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.80 2012/09/01 19:08:42 krw Exp $	*/
d211 1
a211 1
char *pretty_print_option(unsigned int, unsigned char *, int, int, int);
@


1.80
log
@Oops. Missed a reinitialize_interface() declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.79 2012/08/26 23:33:30 krw Exp $	*/
d259 1
@


1.79
log
@Junk global cur_time, and use time(NULL) or local variables where
time is checked multiple times. Add a set_timeout_interval() function
to allow setting a timeout based on an interval from current time.

Fixes issues with initial startup where the global cur_time was
always old and caused initial DHCPDISCOVER or DHCPREQUEST packets
to be sent multiple times. And probably other timeout related
oddities.

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.78 2012/08/22 00:14:42 tedu Exp $	*/
a250 1
void reinitialize_interface(void);
@


1.78
log
@add ignore keyword to conf file, allowing one to ignore unwanted info
from the server without necessarily speciyfing a supersede value
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.77 2012/08/18 00:23:30 krw Exp $	*/
d255 1
a282 1
extern time_t cur_time;
@


1.77
log
@Remove unused field 'next' from struct timeout. There's only one
timeout now, not a list.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.76 2012/07/09 16:21:21 krw Exp $	*/
d133 1
@


1.76
log
@Terminate with extreme prejudice the multiple timeout queuing
mechanism that was a holdover from when dhclient handled multiple
interfaces at once. There is only one timeout possible at a time.

Also move calculation of current time to just before check to see
if the timeout has expired.

ok beck@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.75 2012/06/24 16:01:18 krw Exp $	*/
a192 1
	struct timeout	*next;
@


1.75
log
@Nuke interface_link_status() (check media status only) and use
interface_status() (check IFF_UP|IFF_RUNNING and media status). The
interface is forced up when dhclient starts so the flags should be
correct.

Thanks to guenther@@ for pointing out the original raison d'etre of
the difference between the two.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.74 2011/12/10 15:55:43 krw Exp $	*/
d254 2
a255 2
void add_timeout(time_t, void (*)(void));
void cancel_timeout(void (*)(void));
@


1.74
log
@Tweak leases file handling.

1) Write out new leases file every time a lease is obtained. i.e. don't
append 20 leases before cleaning it up.

2) Write new leases file after calling dhclient-script to implement
new info. Gets interface configured first, and makes it more likely
the leases file reflects most current configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.73 2011/05/11 14:38:36 krw Exp $	*/
a255 1
int interface_link_status(char *);
@


1.73
log
@Make dhclient more friendly to sequential option processing by
always starting DHCP packet options with DHO_DHCP_MESSAGE_TYPE. Now
DHCP-specific options always come after the option identifying the
packet as DHCP rather than BOOTP. Makes at least Nortel NetIP DHCP
server happier. Clean up some code and parameter passing.

Closes PR#6543, as confirmed by original submitter and patch
tester Len Zaifman. Thanks!

ok matthew@@ (who hates the ISC-like code)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.72 2011/04/04 11:14:52 krw Exp $	*/
d309 1
a309 1
void write_client_lease(struct client_lease *, int);
@


1.72
log
@Dump some useless calls to dhclient-script. i.e. MEDIUM, PREINIT,
ARPSEND, ARPCHECK. Drop support for 'media', 'medium' and 'alias'
specifications in dhclient.conf. Old leases still parse but these
options now have no effect.

Be more polite and decline all offers we don't accept. Fix a IMSG
length check.

Many expressions of support at various bars.

ok henning@@ deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.71 2010/07/02 22:03:27 deraadt Exp $	*/
d210 1
a210 1
int cons_options(unsigned char *, const int, struct option_data *);
@


1.71
log
@garbage collect an unused function; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.70 2010/06/02 09:57:16 phessler Exp $	*/
a112 1
	struct string_list	*medium;
a148 1
	struct string_list	*media;
a151 1
	struct string_list	*medium;
a159 1
	struct client_lease	 *alias;
a165 1
	struct string_list	 *medium;
d311 1
a311 1
void	 priv_script_init(char *, char *);
d315 1
a315 1
void script_init(char *, struct string_list *);
@


1.70
log
@Have dhclient obey the interface's rdomain, instead of doing routes on
rdomain 0.

OK krw@@, claudio@@
sharp stick prodding from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.69 2009/06/06 04:02:42 krw Exp $	*/
a263 1
void interface_link_forcedown(char *);
@


1.69
log
@Nuke debug() unless DEBUG is defined. Elminates debug output from
normal operations.

Prodded by deraadt@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.68 2009/03/10 23:19:36 krw Exp $	*/
d194 1
d265 1
@


1.68
log
@Add 6-byte MAC address to the log entries for DHCP ACK/NAK/OFFER.
Log the packets before checking the client state. Makes it easy to
find MACs for 'surprise' DHCP servers.

Positive comments from mbalmer@@, jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.67 2008/05/26 03:11:48 deraadt Exp $	*/
d223 1
d225 1
@


1.67
log
@If an interface has no link at startup, try to force it up, and then
give it about 4 seconds of (silent) grace period before doing the verbose
search for a link...
tested by various developers who got burned a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.66 2008/05/09 05:19:14 reyk Exp $	*/
d54 1
@


1.66
log
@- don't give up when the link is not available on startup: dhclient
goes to background and listens on the routing socket for link to come
up before it retries.
- renew the lease whenever the link was lost and becomes active again.
- listen for link state changes on non-ethernet devices like wireless,
the link state becomes active when the wireless has been associated to
the AP and becomes active. this helps to automatically renew the lease
when the user is roaming.

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.65 2007/02/25 16:27:20 stevesk Exp $	*/
d258 1
@


1.65
log
@remove unused/dangling prototypes and comment reference;
from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.64 2007/01/27 22:05:24 krw Exp $	*/
d192 1
@


1.64
log
@We only poll on the bpf fd and the routing socket fd. No need for
complex list code to keep track. So nuke it.

Also eliminate unnecessary variable ('dead') that means 'rfdesc is
closed'. Just set rfdesc to -1 when it is closed and use that.

As suggested by millert@@ and claudio@@, don't bother setting revents
members to zero since poll() does that.

Np functional change, just less code.

'looks good' claudio@@  'I like where this is going' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.63 2007/01/25 01:21:04 krw Exp $	*/
a296 1
void state_requesting(void);
a316 1
void client_envadd(const char *, const char *, const char *, ...);
a322 1
void client_location_changed(void);
@


1.63
log
@Cleanup some more code. Eliminate dhcp(), bootp(), parse_options() by
moving the minimal code into do_packet(). Eliminate repeated code for
checking the client hardware address and the reject list by putting
those checks into do_packet as well.

No functional change, just much easier to read.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.62 2007/01/16 20:22:20 krw Exp $	*/
a190 1
	int			 dead;
a199 6
struct protocol {
	struct protocol	*next;
	int fd;
	void (*handler)(struct protocol *);
};

d253 1
a253 1
void got_one(struct protocol *);
a255 2
void add_protocol(char *, int, void (*)(struct protocol *));
void remove_protocol(struct protocol *);
d284 1
d326 2
@


1.62
log
@More cleanup. Eliminate 'struct packet' by cleverly passing as
parameters just those things actually needed and using existing
structs and information. No functional change.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.61 2007/01/11 02:36:29 krw Exp $	*/
a171 1
	int			  options_valid;
a333 3

void bootp(struct iaddr, struct option_data *);
void dhcp(struct iaddr, struct option_data *);
@


1.61
log
@Since bootp_packet_handler is always set to do_packet before we
process any packets, eliminate that abstraction and just call
do_packet directly.

No functional change.

ok stevesk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.60 2007/01/04 22:30:57 krw Exp $	*/
a99 7
struct packet {
	int			 packet_type;
	int			 options_valid;
	struct iaddr		 client_addr;
	struct option_data	 options[256];
};

d172 1
d295 3
a297 3
void dhcpoffer(struct packet *);
void dhcpack(struct packet *);
void dhcpnak(struct packet *);
d332 1
a332 1
struct client_lease *packet_to_lease(struct packet *);
d336 2
a337 2
void bootp(struct packet *);
void dhcp(struct packet *);
@


1.60
log
@Eliminate the 'len' parameter from send_packet() since it always
contains the global value client->packet_length. Use
client->packet_length. No functional change.

Suggested by stevesk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.59 2007/01/04 22:17:48 krw Exp $	*/
a263 2
extern void (*bootp_packet_handler)(int, unsigned int, struct iaddr,
    struct hardware *);
@


1.59
log
@Another round of cleanup. There is only one instance of struct
dhcp_packet and it is contained in the global *client. So don't pass
around pointers to a struct that contains a pointer to the dhcp_packet
instance. Just use the global client->packet. Eliminate unused struct
packet members and parameter lists accordingly.

No functional change.

Suggestions by stevesk@@. ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.58 2007/01/04 19:12:41 stevesk Exp $	*/
d260 1
a260 2
ssize_t send_packet(size_t, struct in_addr, struct sockaddr_in *,
    struct hardware *);
@


1.58
log
@<sys/un.h> not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.57 2006/12/27 20:56:33 krw Exp $	*/
a100 2
	struct dhcp_packet	*raw;
	int			 packet_length;
a102 1
	int			 client_port;
a103 1
	struct hardware		*haddr;
d228 1
a228 2
void do_packet(struct dhcp_packet *, int, unsigned int, struct iaddr,
    struct hardware *);
d260 1
a260 3
ssize_t send_packet(struct dhcp_packet *, size_t,
    struct in_addr, struct sockaddr_in *, struct hardware *);
ssize_t receive_packet(unsigned char *, size_t, struct sockaddr_in *,
d262 1
d265 2
a266 2
extern void (*bootp_packet_handler)(struct dhcp_packet *, int, unsigned int,
    struct iaddr, struct hardware *);
@


1.57
log
@Since we only have the single global struct interface_info, we
obviously have single global struct client_state and struct
client_config nested inside interface_info and client_state
respectively.

Pull them out to their own global variables and eliminate a bunch
(i.e. hundreds) of multi-level dereferences. Make it much nicer to
read.

No functional change.

"makes sense" henning@@

Testing stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.56 2006/12/26 21:19:52 krw Exp $	*/
a46 1
#include <sys/un.h>
@


1.56
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.55 2006/12/22 03:18:14 stevesk Exp $	*/
a184 1
	struct client_config	 *config;
a200 1
	struct client_state	*client;
d227 2
@


1.55
log
@delete prototypes for functions that don't exist
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.54 2006/12/16 15:13:45 stevesk Exp $	*/
a107 1
	struct interface_info	*interface;
a190 1
	struct interface_info	*next;
d212 1
a212 2
	void		 (*func)(void *);
	void		*what;
a218 1
	void *local;
d228 2
d233 2
a234 2
void do_packet(struct interface_info *, struct dhcp_packet *,
    int, unsigned int, struct iaddr, struct hardware *);
d263 4
a266 4
int if_register_bpf(struct interface_info *);
void if_register_send(struct interface_info *);
void if_register_receive(struct interface_info *);
ssize_t send_packet(struct interface_info *, struct dhcp_packet *, size_t,
d268 2
a269 2
ssize_t receive_packet(struct interface_info *, unsigned char *, size_t,
    struct sockaddr_in *, struct hardware *);
d272 4
a275 4
extern void (*bootp_packet_handler)(struct interface_info *,
    struct dhcp_packet *, int, unsigned int, struct iaddr, struct hardware *);
void discover_interfaces(struct interface_info *);
void reinitialize_interfaces(void);
d278 3
a280 3
void add_timeout(time_t, void (*)(void *), void *);
void cancel_timeout(void (*)(void *), void *);
void add_protocol(char *, int, void (*)(struct protocol *), void *);
d315 16
a330 16
void send_discover(void *);
void send_request(void *);
void send_decline(void *);

void state_reboot(void *);
void state_init(void *);
void state_selecting(void *);
void state_requesting(void *);
void state_bound(void *);
void state_panic(void *);

void bind_lease(struct interface_info *);

void make_discover(struct interface_info *, struct client_lease *);
void make_request(struct interface_info *, struct client_lease *);
void make_decline(struct interface_info *, struct client_lease *);
d334 1
a334 1
void write_client_lease(struct interface_info *, struct client_lease *, int);
d356 1
a356 2
void assemble_hw_header(struct interface_info *, unsigned char *,
    int *, struct hardware *);
d371 1
a371 2
void parse_client_lease_declaration(FILE *, struct client_lease *,
    struct interface_info **);
@


1.54
log
@make /sbin/dhclient-script consistent with other paths; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.53 2006/11/27 19:32:17 stevesk Exp $	*/
a364 6

/* ethernet.c */
void assemble_ethernet_header(struct interface_info *, unsigned char *,
    int *, struct hardware *);
ssize_t decode_ethernet_header(struct interface_info *, unsigned char *,
    int, struct hardware *);
@


1.53
log
@Recognize when we are sending to a unicast destination IP address and
instead of using BPF, which currently will always set the destination
MAC to broadcast, send using a SOCK_RAW socket and sendmsg() so the
frame has a unicast destination MAC.

Fixes an issue when using a bootp forwarder where unicast DHCPREQUESTs
are dropped at the router/gateway until we reach T2/REBINDING and
change the destination IP to broadcast.

ok henning@@ (but doesn't like using a raw socket for this)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.52 2006/11/27 16:14:07 stevesk Exp $	*/
d227 1
@


1.52
log
@remove invalid comment
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.51 2006/11/21 15:04:59 stevesk Exp $	*/
d198 1
@


1.51
log
@remove unused #defines, no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.50 2006/11/21 00:10:06 stevesk Exp $	*/
a223 1
/* Default path to dhcpd config file. */
@


1.50
log
@re-order includes and eliminate duplicates, no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.49 2006/08/29 03:55:09 deraadt Exp $	*/
a227 3

#define	MAX_TIME 0x7fffffff
#define	MIN_TIME 0
@


1.49
log
@some net if devices do not media negotiate (for link) until brought up.
(for some drivers, this is a bug.  for others, it is part of how they work)
therefore before doing the 10-second link test, we must bring the if up.
ok krw, tested marco ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.48 2006/05/08 17:25:59 deraadt Exp $	*/
a42 1

a62 1
#include <unistd.h>
@


1.48
log
@add 'link-timeout n' seconds option to grammer, from fkr@@hazardous.org
default remains 10 seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.47 2005/08/05 16:23:30 moritz Exp $	*/
d289 2
@


1.47
log
@remove duplicate privsep prototypes and put all
of them into privsep.h. ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.46 2005/08/02 02:34:03 krw Exp $	*/
d159 1
@


1.46
log
@Rip out code dealing with multiple/nested interfaces. Each instance of
dhclient is responsible for one interface. Simply skip interface
declarations for other interfaces and store all info in the one
interface structure.

tested by dlg@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.45 2005/07/17 19:33:55 krw Exp $	*/
a385 7

/* privsep.c */
struct buf	*buf_open(size_t);
int		 buf_add(struct buf *, void *, size_t);
int		 buf_close(int, struct buf *);
ssize_t		 buf_read(int, void *, size_t);
void		 dispatch_imsg(int);
@


1.45
log
@Insist on correct hardware addresses in dhclient.conf and
dhclient.leases.<if> files. Simplify parse_numeric_aggregate() as
a result, rendering tree.c and tree.h redundant.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.44 2005/07/16 18:38:45 krw Exp $	*/
a313 2
extern struct client_config top_level_config;

d346 3
a348 5
void client_envadd(struct client_state *,
    const char *, const char *, const char *, ...);
void script_set_env(struct client_state *, const char *, const char *,
    const char *);
void script_flush_env(struct client_state *);
d376 1
a376 2
void parse_client_statement(FILE *, struct interface_info *,
    struct client_config *);
d379 1
a379 4
void parse_interface_declaration(FILE *, struct client_config *);
struct interface_info *interface_or_dummy(char *);
void make_client_state(struct interface_info *);
void make_client_config(struct interface_info *, struct client_config *);
d385 1
a385 1
void parse_reject_statement(FILE *, struct client_config *);
@


1.44
log
@Rejig struct string_list to use char array rather than char pointer, and
eliminate new_parse_string. alloc.c becomes redundant. Junk a couple of
unused fields (env, envc) in struct client_state.

suggestions by & ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.43 2005/07/16 14:09:51 krw Exp $	*/
a73 1
#include "tree.h"
d78 5
d263 1
a263 2
unsigned char *parse_numeric_aggregate(FILE *, unsigned char *, int *,
    int, int, int);
a265 3

/* tree.c */
pair cons(caddr_t, pair);
@


1.43
log
@Eliminate unnecessary 'code' field from struct option. Make
dhcp_options const.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.42 2005/07/13 23:25:55 krw Exp $	*/
d86 1
a86 1
	char			*string;
a185 2
	struct string_list	 *env;
	int			  envc;
a265 3

/* alloc.c */
struct string_list	*new_string_list(size_t size);
@


1.42
log
@Repair/rationalize option handling to ensure valid option section is
always sent. Fold store_options into cons_options. Eliminate priority
list of options.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.41 2005/07/11 18:09:09 krw Exp $	*/
d295 1
a295 1
extern struct option dhcp_options[256];
d358 1
a358 1
int dhcp_option_ev_name(char *, size_t, struct option *);
d396 1
a396 1
struct option *parse_option_decl(FILE *, struct option_data *);
@


1.41
log
@Expunge unused hashing code and variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.40 2005/07/09 16:16:11 krw Exp $	*/
d234 1
a234 1
int cons_options(struct dhcp_packet *, struct option_data *);
a295 1
extern unsigned char dhcp_option_default_priority_list[256];
@


1.40
log
@Clean out a few more unused/uninitialized variables.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.39 2005/07/09 14:36:15 krw Exp $	*/
a222 14
#define DEFAULT_HASH_SIZE 97

struct hash_bucket {
	struct hash_bucket *next;
	unsigned char *name;
	int len;
	unsigned char *value;
};

struct hash_table {
	int hash_count;
	struct hash_bucket *buckets[DEFAULT_HASH_SIZE];
};

a270 2
struct hash_table	*new_hash_table(int);
struct hash_bucket	*new_hash_bucket(void);
a293 5
/* hash.c */
struct hash_table *new_hash(void);
void add_hash(struct hash_table *, unsigned char *, int, unsigned char *);
unsigned char *hash_lookup(struct hash_table *, unsigned char *, int);

a296 2
extern struct universe dhcp_universe;
void initialize_dhcp_universe(void);
@


1.39
log
@Clean out a few more unused/uninitialized variables.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.38 2005/07/09 01:06:00 krw Exp $	*/
a263 3
extern char comments[4096];
extern int comment_index;
extern int eol_token;
@


1.38
log
@Since we never add more than the default dhcp_universe, expunge the
code to handle mulitple 'vendor' universes. Don't bother with a
specific error message about 'vendor'. An unsupported option is an
unsupported option, and a '.' in an option name is a syntax error.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.37 2005/07/08 14:15:23 krw Exp $	*/
a343 1
extern int log_priority;
@


1.37
log
@More dead and moribund code removal/cleanup. This time unused parameters
and associated code for store_options().

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.36 2005/07/08 00:57:36 krw Exp $	*/
a320 1
extern struct hash_table universe_hash;
d322 1
a322 1
void initialize_universes(void);
@


1.36
log
@Eliminate unused code and associated parameters.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.35 2005/07/07 20:03:40 krw Exp $	*/
d320 1
a320 2
extern unsigned char dhcp_option_default_priority_list[];
extern int sizeof_dhcp_option_default_priority_list;
@


1.35
log
@Eliminate unused code and associated parameter.

ok deraadt@@ millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.34 2005/07/07 16:24:24 krw Exp $	*/
d248 2
a249 4
int cons_options(struct dhcp_packet *, int,
    struct option_data *, int, int, int, u_int8_t *, int);
char *pretty_print_option(unsigned int,
    unsigned char *, int, int, int);
@


1.34
log
@Eliminate tree_cache structure in favour of option_data. Eliminate
redundant level of indirection in building and using option_data
arrays while constructing outgoing packets. Make option_data len field
unsigned.

ok henning@@. 'cool!' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.33 2004/05/06 22:29:15 deraadt Exp $	*/
d248 1
a248 1
int cons_options(struct packet *, struct dhcp_packet *, int,
@


1.33
log
@remove more unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.32 2004/05/04 22:23:01 mickey Exp $	*/
d80 1
a80 1
	int		 len;
d249 1
a249 1
    struct tree_cache **, int, int, int, u_int8_t *, int);
@


1.32
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.31 2004/05/04 20:28:40 deraadt Exp $	*/
a108 1
	int			 got_requested_address;
a285 1
int tree_evaluate(struct tree_cache *);
@


1.31
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.30 2004/05/04 18:58:50 deraadt Exp $	*/
d259 1
a259 1
int warn(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
@


1.30
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.29 2004/05/04 12:52:05 henning Exp $	*/
a277 1
char *parse_host_name(FILE *);
a287 1
struct dns_host_entry *enter_dns_host(char *);
a293 1
void			 free_hash_bucket(struct hash_bucket *);
a319 1
void delete_hash_entry(struct hash_table *, unsigned char *, int);
a325 1
extern char *hardware_types[256];
a341 1
struct iaddr ip_addr(struct iaddr, struct iaddr, u_int32_t);
a342 1
u_int32_t host_addr(struct iaddr, struct iaddr);
a360 1
void send_release(void *);
a374 1
void make_release(struct interface_info *, struct client_lease *);
@


1.29
log
@privilege seperate dhclient.
the privileged child's duty is the dhclient-script env setup & exection.
the parent process now chroots to /var/empty and drops privileges to _dhcp
mostly hacked at vancouver airport
with some feedback from krw@@ and otto@@, tested to not break installs by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.28 2004/04/14 20:22:27 henning Exp $	*/
d293 4
a296 4
struct string_list	*new_string_list(size_t size, char * name);
struct hash_table	*new_hash_table(int, char *);
struct hash_bucket	*new_hash_bucket(char *);
void			 free_hash_bucket(struct hash_bucket *, char *);
d302 2
a303 3
ssize_t send_packet(struct interface_info *,
    struct packet *, struct dhcp_packet *, size_t, struct in_addr,
    struct sockaddr_in *, struct hardware *);
d393 3
a395 4
void script_init(struct interface_info *, char *, struct string_list *);
void script_write_params(struct interface_info *,
    char *, struct client_lease *);
int script_go(struct interface_info *);
d413 5
a417 6
void assemble_udp_ip_header(struct interface_info *, unsigned char *,
    int *, u_int32_t, u_int32_t, unsigned int, unsigned char *, int);
ssize_t decode_hw_header(struct interface_info *, unsigned char *,
    int, struct hardware *);
ssize_t decode_udp_ip_header(struct interface_info *, unsigned char *,
    int, struct sockaddr_in *, unsigned char *, int);
@


1.28
log
@get rif of the few dmalloc/dfree occurances that were left
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.27 2004/04/14 20:15:47 henning Exp $	*/
d390 4
d445 7
@


1.27
log
@turns out more is obsolete now
inspired by diff from Emil Mikulic <emikulic@@dmr.ath.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.26 2004/03/05 23:57:16 deraadt Exp $	*/
a292 2
void			*dmalloc(int, char *);
void			 dfree(void *, char *);
@


1.26
log
@remove even more goo
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.25 2004/03/02 18:49:21 deraadt Exp $	*/
d293 6
a298 12
void *dmalloc(int, char *);
void dfree(void *, char *);
struct tree *new_tree(char *);
struct tree_cache *new_tree_cache(char *);
struct hash_table *new_hash_table(int, char *);
struct hash_bucket *new_hash_bucket(char *);
struct string_list *new_string_list(size_t size, char * name);
void free_hash_bucket(struct hash_bucket *, char *);
void free_hash_table(struct hash_table *, char *);
void free_tree_cache(struct tree_cache *, char *);
void free_tree(struct tree *, char *);
void free_string_list(struct string_list *, char *);
@


1.25
log
@more pruning; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.24 2004/03/02 15:41:44 henning Exp $	*/
a414 1
void cleanup(void);
@


1.24
log
@zap interface flags
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.23 2004/03/02 13:39:44 henning Exp $	*/
a64 2
#include <setjmp.h>
#include <signal.h>
@


1.23
log
@we deal with one interface at a time, so remove the interface list gunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.22 2004/03/02 12:56:30 henning Exp $	*/
a204 3
	u_int32_t		 flags;
#define INTERFACE_REQUESTED 1
#define INTERFACE_AUTOMATIC 2
@


1.22
log
@remove dummy_interfaces and fallback_interface gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.21 2004/03/02 12:46:44 henning Exp $	*/
a321 2
extern struct interface_info *interfaces;
extern struct protocol *protocols;
a323 1
extern struct timeout *timeouts;
@


1.21
log
@our interface discovery is so quiet now (nonexistant) that we don't need a
quiet_interface_discovery flag any more
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.20 2004/03/02 12:40:31 henning Exp $	*/
d322 1
a322 2
extern struct interface_info *interfaces,
    *dummy_interfaces, *fallback_interface;
@


1.20
log
@since we're dealing with one interface and not quite a few ones we can give
this one onterface as parameter to discove_interfaces and get rid of quite
some of the multiple-interface-discover logic
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.19 2004/02/25 14:22:12 henning Exp $	*/
a324 1
extern int quiet_interface_discovery;
@


1.19
log
@doesn't quite make sense to have a wrapper to a wrapper to the incredible
amount of ~ 20 lines of code in their own file...
and another one bites the dust
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.18 2004/02/24 17:26:43 henning Exp $	*/
d329 1
a329 1
void discover_interfaces(void);
@


1.18
log
@whack unused token ring code and a few empty functions
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.17 2004/02/24 17:02:40 henning Exp $	*/
a427 2
u_int32_t checksum(unsigned char *, unsigned, u_int32_t);
u_int32_t wrapsum(u_int32_t);
@


1.17
log
@zap more unused crap
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.16 2004/02/24 15:35:56 henning Exp $	*/
a312 1
void if_reinitialize_send(struct interface_info *);
d314 1
a317 2
void if_reinitialize_receive(struct interface_info *);
void if_register_receive(struct interface_info *);
a319 3
int can_unicast_without_arp(void);
int can_receive_unicast_unconfigured(struct interface_info *);
void maybe_setup_fallback(void);
@


1.16
log
@get rid of tons of structs we never use, a lot of new_someotherjunk functions
in alloc.c we never call, and a shitload of genius comments like
char *script_name; /* name of script */
char *server_name; /* name of server */
etc etc etc...
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.15 2004/02/24 14:49:08 henning Exp $	*/
a76 2
#include "hash.h"
#include "inet.h"
d91 10
d229 14
a253 2
void parse_options(struct packet *);
void parse_option_buffer(struct packet *, unsigned char *, int);
a255 2
int store_options(unsigned char *, int, struct tree_cache **,
    unsigned char *, int, int, int, int);
d293 2
a295 7
struct tree_cache *tree_cache(struct tree *);
struct tree *tree_host_lookup(char *);
struct dns_host_entry *enter_dns_host(char *);
struct tree *tree_const(unsigned char *, int);
struct tree *tree_concat(struct tree *, struct tree *);
struct tree *tree_limit(struct tree *, int);
int tree_evaluate(struct tree_cache *);
a309 6

/* print.c */
char *print_hw_addr(int, int, unsigned char *);
void dump_raw(unsigned char *, int);
void dump_packet(struct packet *);
void hash_dump(struct hash_table *);
@


1.15
log
@discover_interfaces doesn't run in multiple modes any more - kill unreachable
code, partitally server-only
@
text
@d1 1
a1 3
/*	$OpenBSD: dhcpd.h,v 1.14 2004/02/24 13:36:13 henning Exp $	*/

/* Definitions for dhcpd... */
d4 1
d84 2
a85 2
	int len;
	u_int8_t *data;
d89 2
a90 9
	struct string_list *next;
	char *string;
};

/* A name server, from /etc/resolv.conf. */
struct name_server {
	struct name_server *next;
	struct sockaddr_in addr;
	time_t rcdate;
a92 8
/* A domain search list element. */
struct domain_search_list {
	struct domain_search_list *next;
	char *domain;
	time_t rcdate;
};

/* A dhcp packet and the pointers to its option values. */
d94 10
a103 14
	struct dhcp_packet *raw;
	int packet_length;
	int packet_type;
	int options_valid;
	int client_port;
	struct iaddr client_addr;
	struct interface_info *interface;	/* Interface on which packet
						   was received. */
	struct hardware *haddr;		/* Physical link address
					   of local sender (maybe gateway). */
	struct shared_network *shared_network;
	struct option_data options[256];
	int got_requested_address;	/* True if client sent the
					   dhcp-requested-address option. */
a111 143
/* A dhcp lease declaration structure. */
struct lease {
	struct lease *next;
	struct lease *prev;
	struct lease *n_uid, *n_hw;
	struct lease *waitq_next;

	struct iaddr ip_addr;
	time_t starts, ends, timestamp;
	unsigned char *uid;
	int uid_len;
	int uid_max;
	unsigned char uid_buf[32];
	char *hostname;
	char *client_hostname;
	struct host_decl *host;
	struct subnet *subnet;
	struct shared_network *shared_network;
	struct hardware hardware_addr;

	int flags;
#       define STATIC_LEASE		1
#       define BOOTP_LEASE		2
#	define DYNAMIC_BOOTP_OK		4
#	define PERSISTENT_FLAGS		(DYNAMIC_BOOTP_OK)
#	define EPHEMERAL_FLAGS		(BOOTP_LEASE)
#	define MS_NULL_TERMINATION	8
#	define ABANDONED_LEASE		16

	struct lease_state *state;
	u_int8_t releasing;
};

struct lease_state {
	struct lease_state *next;

	struct interface_info *ip;

	time_t offered_expiry;

	struct tree_cache *options[256];
	u_int32_t expiry, renewal, rebind;
	char filename[DHCP_FILE_LEN];
	char *server_name;

	struct iaddr from;

	int max_message_size;
	u_int8_t *prl;
	int prl_len;
	int got_requested_address;	/* True if client sent the
					   dhcp-requested-address option. */
	int got_server_identifier;	/* True if client sent the
					   dhcp-server-identifier option. */
	struct shared_network *shared_network;	/* Shared network of interface
						   on which request arrived. */

	u_int32_t xid;
	u_int16_t secs;
	u_int16_t bootp_flags;
	struct in_addr ciaddr;
	struct in_addr giaddr;
	u_int8_t hops;
	u_int8_t offer;
};

#define ROOT_GROUP	0
#define HOST_DECL	1
#define SHARED_NET_DECL	2
#define SUBNET_DECL	3
#define CLASS_DECL	4
#define GROUP_DECL	5

/* Group of declarations that share common parameters. */
struct group {
	struct group *next;

	struct subnet *subnet;
	struct shared_network *shared_network;

	time_t default_lease_time;
	time_t max_lease_time;
	time_t bootp_lease_cutoff;
	time_t bootp_lease_length;

	char *filename;
	char *server_name;
	struct iaddr next_server;

	int boot_unknown_clients;
	int dynamic_bootp;
	int allow_bootp;
	int allow_booting;
	int one_lease_per_client;
	int get_lease_hostnames;
	int use_host_decl_names;
	int use_lease_addr_for_default_route;
	int authoritative;
	int always_reply_rfc1048;

	struct tree_cache *options[256];
};

/* A dhcp host declaration structure. */
struct host_decl {
	struct host_decl *n_ipaddr;
	char *name;
	struct hardware interface;
	struct tree_cache *fixed_addr;
	struct group *group;
};

struct shared_network {
	struct shared_network *next;
	char *name;
	struct subnet *subnets;
	struct interface_info *interface;
	struct lease *leases;
	struct lease *insertion_point;
	struct lease *last_lease;

	struct group *group;
};

struct subnet {
	struct subnet *next_subnet;
	struct subnet *next_sibling;
	struct shared_network *shared_network;
	struct interface_info *interface;
	struct iaddr interface_address;
	struct iaddr net;
	struct iaddr netmask;

	struct group *group;
};

struct class {
	char *name;

	struct group *group;
};

/* DHCP client lease structure... */
d113 9
a121 11
	struct client_lease *next;		      /* Next lease in list. */
	time_t expiry, renewal, rebind;			  /* Lease timeouts. */
	struct iaddr address;			    /* Address being leased. */
	char *server_name;			     /* Name of boot server. */
	char *filename;		     /* Name of file we're supposed to boot. */
	struct string_list *medium;			  /* Network medium. */

	unsigned int is_static : 1;    /* If set, lease is from config file. */
	unsigned int is_bootp : 1;  /* If set, lease was aquired with BOOTP. */

	struct option_data options[256];     /* Options supplied with lease. */
a134 1
/* Configuration information from the config file... */
d136 1
a136 1
	struct option_data defaults[256]; /* Default values for options. */
d138 4
a141 5
		ACTION_DEFAULT,		/* Use server value if present,
					   otherwise default. */
		ACTION_SUPERSEDE,	/* Always use default. */
		ACTION_PREPEND,		/* Prepend default to server. */
		ACTION_APPEND		/* Append default to server. */
d144 16
a159 30
	struct option_data send_options[256]; /* Send these to server. */
	u_int8_t required_options[256]; /* Options server must supply. */
	u_int8_t requested_options[256]; /* Options to request from server. */
	int requested_option_count;	/* Number of requested options. */
	time_t timeout;			/* Start to panic if we don't get a
					   lease in this time period when
					   SELECTING. */
	time_t initial_interval;	/* All exponential backoff intervals
					   start here. */
	time_t retry_interval;		/* If the protocol failed to produce
					   an address before the timeout,
					   try the protocol again after this
					   many seconds. */
	time_t select_interval;		/* Wait this many seconds from the
					   first DHCPDISCOVER before
					   picking an offered lease. */
	time_t reboot_timeout;		/* When in INIT-REBOOT, wait this
					   long before giving up and going
					   to INIT. */
	time_t backoff_cutoff;		/* When doing exponential backoff,
					   never back off to an interval
					   longer than this amount. */
	struct string_list *media;	/* Possible network media values. */
	char *script_name;		/* Name of config script. */
	enum { IGNORE, ACCEPT, PREFER } bootp_policy;
					/* Ignore, accept or prefer BOOTP
					   responses. */
	struct string_list *medium;	/* Current network medium. */

	struct iaddrlist *reject_list;	/* Servers to reject. */
a161 1
/* Per-interface state used in the dhcp client... */
d163 20
a182 26
	struct client_lease *active;		  /* Currently active lease. */
	struct client_lease *new;			       /* New lease. */
	struct client_lease *offered_leases;	    /* Leases offered to us. */
	struct client_lease *leases;		/* Leases we currently hold. */
	struct client_lease *alias;			     /* Alias lease. */

	enum dhcp_state state;		/* Current state for this interface. */
	struct iaddr destination;		    /* Where to send packet. */
	u_int32_t xid;					  /* Transaction ID. */
	u_int16_t secs;			    /* secs value from DHCPDISCOVER. */
	time_t first_sending;			/* When was first copy sent? */
	time_t interval;		      /* What's the current resend interval? */
	struct string_list *medium;		   /* Last media type tried. */

	struct dhcp_packet packet;		    /* Outgoing DHCP packet. */
	int packet_length;	       /* Actual length of generated packet. */

	struct iaddr requested_address;	    /* Address we would like to get. */

	struct client_config *config;	    /* Information from config file. */

	char **scriptEnv;  /* Client script env */
	int scriptEnvsize; /* size of the env table */

	struct string_list *env;	       /* Client script environment. */
	int envc;			/* Number of entries in environment. */
a184 2
/* Information about each network interface. */

d186 12
a197 16
	struct interface_info *next;	/* Next interface in list... */
	struct shared_network *shared_network;
				/* Networks connected to this interface. */
	struct hardware hw_address;	/* Its physical address. */
	struct in_addr primary_address;	/* Primary interface address. */
	char name[IFNAMSIZ];		/* Its name... */
	int rfdesc;			/* Its read file descriptor. */
	int wfdesc;			/* Its write file descriptor, if
					   different. */
	unsigned char *rbuf;		/* Read buffer, if required. */
	size_t rbuf_max;		/* Size of read buffer. */
	size_t rbuf_offset;		/* Current offset into buffer. */
	size_t rbuf_len;		/* Length of data in buffer. */

	struct ifreq *ifp;		/* Pointer to ifreq struct. */
	u_int32_t flags;		/* Control flags... */
d200 5
a204 13

	/* Only used by DHCP client code. */
	struct client_state *client;
	int noifmedia;
	int errors;
	int dead;
	u_int16_t index;
};

struct hardware_link {
	struct hardware_link *next;
	char name[IFNAMSIZ];
	struct hardware address;
d208 4
a211 4
	struct timeout *next;
	time_t when;
	void (*func)(void *);
	void *what;
d215 1
a215 1
	struct protocol *next;
a220 14
/* Bitmask of dhcp option codes. */
typedef unsigned char option_mask[16];

/* DHCP Option mask manipulation macros... */
#define OPTION_ZERO(mask)	(memset(mask, 0, 16))
#define OPTION_SET(mask, bit)	(mask[bit >> 8] |= (1 << (bit & 7)))
#define OPTION_CLR(mask, bit)	(mask[bit >> 8] &= ~(1 << (bit & 7)))
#define OPTION_ISSET(mask, bit)	(mask[bit >> 8] & (1 << (bit & 7)))
#define OPTION_ISCLR(mask, bit)	(!OPTION_ISSET(mask, bit))

/* An option occupies its length plus two header bytes (code and
    length) for every 255 bytes that must be stored. */
#define OPTION_SPACE(x)		((x) + 2 * ((x) / 255 + 1))

d222 3
a224 4
#define _PATH_DHCLIENT_CONF	"/etc/dhclient.conf"
#define _PATH_DHCLIENT_DB	"/var/db/dhclient.leases"
#define _PATH_RESOLV_CONF	"/etc/resolv.conf"
#define DHCPD_LOG_FACILITY	LOG_DAEMON
d226 2
a227 2
#define MAX_TIME 0x7fffffff
#define MIN_TIME 0
a231 1

a286 2
struct packet *new_packet(char *);
struct dhcp_packet *new_dhcp_packet(char *);
a290 10
struct lease *new_lease(char *);
struct lease *new_leases(int, char *);
struct subnet *new_subnet(char *);
struct class *new_class(char *);
struct shared_network *new_shared_network(char *);
struct group *new_group(char *);
struct protocol *new_protocol(char *);
struct lease_state *new_lease_state(char *);
struct domain_search_list *new_domain_search_list(char *);
struct name_server *new_name_server(char *);
a291 9
void free_name_server(struct name_server *, char *);
void free_domain_search_list(struct domain_search_list *, char *);
void free_lease_state(struct lease_state *, char *);
void free_protocol(struct protocol *, char *);
void free_group(struct group *, char *);
void free_shared_network(struct shared_network *, char *);
void free_class(struct class *, char *);
void free_subnet(struct subnet *, char *);
void free_lease(struct lease *, char *);
a294 2
void free_packet(struct packet *, char *);
void free_dhcp_packet(struct dhcp_packet *, char *);
a299 1
void print_lease(struct lease *);
a327 1
struct interface_info *setup_fallback(void);
@


1.14
log
@remove dynamic port gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.13 2004/02/24 13:21:32 henning Exp $	*/
a204 8
/* Possible modes in which discover_interfaces can run. */

#define DISCOVER_RUNNING	0
#define DISCOVER_SERVER		1
#define DISCOVER_UNCONFIGURED	2
#define DISCOVER_RELAY		3
#define DISCOVER_REQUESTED	4

d569 1
a569 1
void discover_interfaces(int);
@


1.13
log
@cut unreachable code
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.12 2004/02/24 13:08:26 henning Exp $	*/
d81 3
a624 1
extern u_int16_t local_port;
@


1.12
log
@cut more crap - no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.11 2004/02/24 12:41:28 henning Exp $	*/
a620 1
extern int interfaces_requested;
@


1.11
log
@kill pidfile gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.10 2004/02/23 20:16:00 henning Exp $	*/
d44 1
a44 1
#include <netinet/in.h>
d46 3
d50 7
d58 5
d64 5
a68 1
#include <fcntl.h>
d70 1
a70 1
#include <unistd.h>
d72 1
a72 3
#include <stdlib.h>
#include <sys/stat.h>
#include <ctype.h>
d74 1
a75 1
#include "osdep.h"
@


1.10
log
@goodbye VOIDPTR
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.9 2004/02/23 20:09:02 deraadt Exp $	*/
a426 1
#define _PATH_DHCLIENT_PID	"/var/run/dhclient.pid"
a428 3
#define _PATH_DHCRELAY_PID	"/var/run/dhcrelay.pid"
#define _PATH_DHCLIENT_PID	"/var/run/dhclient.pid"
#define _PATH_DHCLIENT_DB	"/var/db/dhclient.leases"
a603 1
extern char *path_dhclient_pid;
a651 1
void write_client_pid_file(void);
@


1.9
log
@remove time_t related crud; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.8 2004/02/23 19:51:15 henning Exp $	*/
d495 2
a496 2
VOIDPTR dmalloc(int, char *);
void dfree(VOIDPTR, char *);
@


1.8
log
@remove prototypes we don't implement
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.7 2004/02/23 19:19:12 henning Exp $	*/
d78 1
a78 1
	TIME rcdate;
d85 1
a85 1
	TIME rcdate;
d120 1
a120 1
	TIME starts, ends, timestamp;
d150 1
a150 1
	TIME offered_expiry;
d200 4
a203 4
	TIME default_lease_time;
	TIME max_lease_time;
	TIME bootp_lease_cutoff;
	TIME bootp_lease_length;
d265 1
a265 1
	TIME expiry, renewal, rebind;			  /* Lease timeouts. */
d303 1
a303 1
	TIME timeout;			/* Start to panic if we don't get a
d306 1
a306 1
	TIME initial_interval;		/* All exponential backoff intervals
d308 1
a308 1
	TIME retry_interval;		/* If the protocol failed to produce
d312 1
a312 1
	TIME select_interval;		/* Wait this many seconds from the
d315 1
a315 1
	TIME reboot_timeout;		/* When in INIT-REBOOT, wait this
d318 1
a318 1
	TIME backoff_cutoff;		/* When doing exponential backoff,
d343 2
a344 2
	TIME first_sending;			/* When was first copy sent? */
	TIME interval;		      /* What's the current resend interval? */
d399 1
a399 1
	TIME when;
d478 1
a478 1
void parse_lease_time(FILE *, TIME *);
d482 1
a482 1
TIME parse_date(FILE *);
d566 1
a566 1
void add_timeout(TIME, void (*)(void *), void *);
d610 1
a610 1
extern TIME cur_time;
@


1.7
log
@remove allocation/storage/search code for subnets, shared networks, and
leases - it is server-only code.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.6 2004/02/23 18:21:15 henning Exp $	*/
a460 12
/* dhcpd.c */
extern TIME cur_time;
extern struct group root_group;

extern u_int16_t local_port;
extern u_int16_t remote_port;
extern int log_priority;
extern int log_perror;

int main(int, char **);
void cleanup(void);

d471 1
a471 5
/* confpars.c */
int readconf(void);
void read_leases(void);
int parse_statement(FILE *, struct group *, int, struct host_decl *, int);
void parse_allow_deny(FILE *, struct group *, int);
a472 1
int parse_boolean(FILE *);
d474 1
a474 2
int parse_lbrace(FILE *);
void parse_host_declaration(FILE *, struct group *);
d476 2
a477 1
void parse_class_declaration(FILE *, struct group *, int);
a478 12
void parse_shared_net_declaration(FILE *, struct group *);
void parse_subnet_declaration(FILE *, struct shared_network *);
void parse_group_declaration(FILE *, struct group *);
void parse_hardware_param(FILE *, struct hardware *);
char *parse_string(FILE *);
struct tree *parse_ip_addr_or_hostname(FILE *, int);
struct tree_cache *parse_fixed_addr_param(FILE *);
void parse_option_param(FILE *, struct group *);
TIME parse_timestamp(FILE *);
struct lease *parse_lease_declaration(FILE *);
void parse_address_range(FILE *, struct subnet *);
TIME parse_date(FILE *);
d482 1
a493 19
/* dhcp.c */
extern int outstanding_pings;

void dhcp(struct packet *);
void dhcpdiscover(struct packet *);
void dhcprequest(struct packet *);
void dhcprelease(struct packet *);
void dhcpdecline(struct packet *);
void dhcpinform(struct packet *);
void nak_lease(struct packet *, struct iaddr *cip);
void ack_lease(struct packet *, struct lease *, unsigned int, TIME);
void dhcp_reply(struct lease *);
struct lease *find_lease(struct packet *, struct shared_network *, int *);
struct lease *mockup_lease(struct packet *, struct shared_network *,
    struct host_decl *);

/* bootp.c */
void bootp(struct packet *);

d610 4
d660 3
a662 5
/* db.c */
int write_lease(struct lease *);
int commit_leases(void);
void db_startup(void);
void new_lease_file(void);
a681 42
/* tr.c */
void assemble_tr_header(struct interface_info *, unsigned char *,
    int *, struct hardware *);
ssize_t decode_tr_header(struct interface_info *,
    unsigned char *, int, struct hardware *);

/* dhxpxlt.c */
void convert_statement(FILE *);
void convert_host_statement(FILE *, jrefproto);
void convert_host_name(FILE *, jrefproto);
void convert_class_statement(FILE *, jrefproto, int);
void convert_class_decl(FILE *, jrefproto);
void convert_lease_time(FILE *, jrefproto, char *);
void convert_shared_net_statement(FILE *, jrefproto);
void convert_subnet_statement(FILE *, jrefproto);
void convert_subnet_decl(FILE *, jrefproto);
void convert_host_decl(FILE *, jrefproto);
void convert_hardware_decl(FILE *, jrefproto);
void convert_hardware_addr(FILE *, jrefproto);
void convert_filename_decl(FILE *, jrefproto);
void convert_servername_decl(FILE *, jrefproto);
void convert_ip_addr_or_hostname(FILE *, jrefproto, int);
void convert_fixed_addr_decl(FILE *, jrefproto);
void convert_option_decl(FILE *, jrefproto);
void convert_timestamp(FILE *, jrefproto);
void convert_lease_statement(FILE *, jrefproto);
void convert_address_range(FILE *, jrefproto);
void convert_date(FILE *, jrefproto, char *);
void convert_numeric_aggregate(FILE *, jrefproto, int, int, int, int);
void indent(int);

/* route.c */
void add_route_direct(struct interface_info *, struct in_addr);
void add_route_net(struct interface_info *, struct in_addr, struct in_addr);
void add_route_default_gateway(struct interface_info *, struct in_addr);
void remove_routes(struct in_addr);
void remove_if_route(struct interface_info *, struct in_addr);
void remove_all_if_routes(struct interface_info *);
void set_netmask(struct interface_info *, struct in_addr);
void set_broadcast_addr(struct interface_info *, struct in_addr);
void set_ip_address(struct interface_info *, struct in_addr);

a697 1
int parse_ip_addr(FILE *, struct iaddr *);
a698 22

/* dhcrelay.c */
void relay(struct interface_info *, struct dhcp_packet *, int,
    unsigned int, struct iaddr, struct hardware *);

/* icmp.c */
void icmp_startup(int, void (*)(struct iaddr, u_int8_t *, int));
int icmp_echorequest(struct iaddr *);
void icmp_echoreply(struct protocol *);

/* dns.c */
void dns_startup(void);
int ns_inaddr_lookup(u_int16_t, struct iaddr);
void dns_packet(struct protocol *);

/* resolv.c */
extern char path_resolv_conf[];
struct name_server *name_servers;
struct domain_search_list *domains;

void read_resolv_conf(TIME);
struct sockaddr_in *pick_name_server (void);
@


1.6
log
@dhclient always uses bpf on openbsd no matter what, it works, and we don't
need to fallback to their raw socket code
suddenly dhclient is so fast...
pb tested and sez ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.5 2004/02/10 13:12:48 henning Exp $	*/
a540 30
/* memory.c */
void enter_host(struct host_decl *);
struct host_decl *find_hosts_by_haddr(int, unsigned char *, int);
struct host_decl *find_hosts_by_uid(unsigned char *, int);
struct subnet *find_host_for_network(struct host_decl **, struct iaddr *,
    struct shared_network *);
void new_address_range(struct iaddr, struct iaddr, struct subnet *, int);
extern struct subnet *find_grouped_subnet(struct shared_network *,
    struct iaddr);
extern struct subnet *find_subnet(struct iaddr);
void enter_shared_network(struct shared_network *);
int subnet_inner_than(struct subnet *, struct subnet *, int);
void enter_subnet(struct subnet *);
void enter_lease(struct lease *);
int supersede_lease(struct lease *, struct lease *, int);
void release_lease(struct lease *);
void abandon_lease(struct lease *, char *);
struct lease *find_lease_by_uid(unsigned char *, int);
struct lease *find_lease_by_hw_addr(unsigned char *, int);
struct lease *find_lease_by_ip_addr(struct iaddr);
void uid_hash_add(struct lease *);
void uid_hash_delete(struct lease *);
void hw_hash_add(struct lease *);
void hw_hash_delete(struct lease *);
struct class *add_class(int, char *);
struct class *find_class(int, unsigned char *, int);
struct group *clone_group(struct group *, char *);
void write_leases(void);
void dump_subnets(void);

a611 1
int locate_network(struct packet *);
@


1.5
log
@at startup, before sending several DHCPDISCOVER and waiting ages for answers,
check the link state of the interface(s) in question and don't try on
intrfaces that for sure have no link. interfaces with unknown linkstates are
treated as if they had a link, not all drivers are capable of reporting
linkstate upstream, and for some media there is no such thing as a link state.
saves quite sme time when booting notebooks configured for dhcp without
teh cable inserted...
note that this is the not yet active copy of dhclient
ok grange@@ mcbride@@ pb@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.4 2004/02/07 13:26:35 henning Exp $	*/
a614 36
/* socket.c */
#if defined(USE_SOCKET_SEND) || defined(USE_SOCKET_RECEIVE) \
	|| defined(USE_SOCKET_FALLBACK)
int if_register_socket(struct interface_info *);
#endif

#if defined(USE_SOCKET_FALLBACK) && !defined(USE_SOCKET_SEND)
void if_reinitialize_fallback(struct interface_info *);
void if_register_fallback(struct interface_info *);
ssize_t send_fallback(struct interface_info *,
    struct packet *, struct dhcp_packet *, size_t, struct in_addr,
    struct sockaddr_in *, struct hardware *);
#endif

#ifdef USE_SOCKET_SEND
void if_reinitialize_send(struct interface_info *);
void if_register_send(struct interface_info *);
ssize_t send_packet(struct interface_info *,
    struct packet *, struct dhcp_packet *, size_t, struct in_addr,
    struct sockaddr_in *, struct hardware *);
#endif
#ifdef USE_SOCKET_FALLBACK
void fallback_discard(struct protocol *);
#endif
#ifdef USE_SOCKET_RECEIVE
void if_reinitialize_receive(struct interface_info *);
void if_register_receive(struct interface_info *);
ssize_t receive_packet(struct interface_info *, unsigned char *, size_t,
    struct sockaddr_in *, struct hardware *);
#endif
#ifdef USE_SOCKET_SEND
int can_unicast_without_arp(void);
int can_receive_unicast_unconfigured(struct interface_info *);
void maybe_setup_fallback(void);
#endif

a615 1
#if defined(USE_BPF_SEND) || defined(USE_BPF_RECEIVE)
a616 2
#endif
#ifdef USE_BPF_SEND
a621 2
#endif
#ifdef USE_BPF_RECEIVE
a625 14
#endif
#ifdef USE_BPF_SEND
int can_unicast_without_arp(void);
int can_receive_unicast_unconfigured(struct interface_info *);
void maybe_setup_fallback(void);
#endif

/* raw.c */
#ifdef USE_RAW_SEND
void if_reinitialize_send(struct interface_info *);
void if_register_send(struct interface_info *);
ssize_t send_packet(struct interface_info *,
    struct packet *, struct dhcp_packet *, size_t, struct in_addr,
    struct sockaddr_in *, struct hardware *);
a628 1
#endif
@


1.4
log
@more KNF From: Emil Mikulic <emikulic@@dmr.ath.cx>
great job.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.3 2004/02/04 12:16:56 henning Exp $	*/
d704 1
@


1.3
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 1
a101 1
	struct option_data options [256];
d109 1
a109 1
	u_int8_t haddr [16];
d124 1
a124 1
	unsigned char uid_buf [32];
d152 1
a152 1
	struct tree_cache *options [256];
d154 1
a154 1
	char filename [DHCP_FILE_LEN];
d178 1
a178 1
#define	ROOT_GROUP	0
d183 1
a183 1
#define	GROUP_DECL	5
d206 1
a206 1
	char *server_name;	
d220 1
a220 1
	struct tree_cache *options [256];
d272 1
a272 1
	unsigned int is_bootp: 1;   /* If set, lease was aquired with BOOTP. */
d274 1
a274 1
	struct option_data options [256];    /* Options supplied with lease. */
d282 1
a282 1
	S_REQUESTING, 
d290 1
a290 1
	struct option_data defaults [256]; /* Default values for options. */
d297 1
a297 1
	} default_actions [256];
d299 3
a301 3
	struct option_data send_options [256]; /* Send these to server. */
	u_int8_t required_options [256]; /* Options server must supply. */
	u_int8_t requested_options [256]; /* Options to request from server. */
d369 1
a369 1
	char name [IFNAMSIZ];		/* Its name... */
d388 1
a388 1
	u_int16_t	index;
d393 1
a393 1
	char name [IFNAMSIZ];
d407 1
a407 1
	void (*handler) (struct protocol *);
d412 1
a412 1
typedef unsigned char option_mask [16];
d415 5
a419 5
#define OPTION_ZERO(mask)	(memset (mask, 0, 16))
#define OPTION_SET(mask, bit)	(mask [bit >> 8] |= (1 << (bit & 7)))
#define OPTION_CLR(mask, bit)	(mask [bit >> 8] &= ~(1 << (bit & 7)))
#define OPTION_ISSET(mask, bit)	(mask [bit >> 8] & (1 << (bit & 7)))
#define OPTION_ISCLR(mask, bit)	(!OPTION_ISSET (mask, bit))
d442 10
a451 12
void parse_options (struct packet *);
void parse_option_buffer (struct packet *, unsigned char *, int);
int cons_options (struct packet *, struct dhcp_packet *, int,
			 struct tree_cache **, int, int, int,
			 u_int8_t *, int);
int store_options (unsigned char *, int, struct tree_cache **,
			   unsigned char *, int, int, int, int);
char *pretty_print_option (unsigned int,
				  unsigned char *, int, int, int);
void do_packet (struct interface_info *,
		       struct dhcp_packet *, int,
		       unsigned int, struct iaddr, struct hardware *);
d455 5
a459 5
void error (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int warn (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int note (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int debug (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int parse_warn (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
d470 2
a471 2
int main (int, char **);
void cleanup (void);
d476 1
a476 1
extern char comments [4096];
d479 3
a481 3
void new_parse (char *);
int next_token (char **, FILE *);
int peek_token (char **, FILE *);
d484 27
a510 29
int readconf (void);
void read_leases (void);
int parse_statement (FILE *,
			    struct group *, int, struct host_decl *, int);
void parse_allow_deny (FILE *, struct group *, int);
void skip_to_semi (FILE *);
int parse_boolean (FILE *);
int parse_semi (FILE *);
int parse_lbrace (FILE *);
void parse_host_declaration (FILE *, struct group *);
char *parse_host_name (FILE *);
void parse_class_declaration (FILE *, struct group *, int);
void parse_lease_time (FILE *, TIME *);
void parse_shared_net_declaration (FILE *, struct group *);
void parse_subnet_declaration (FILE *, struct shared_network *);
void parse_group_declaration (FILE *, struct group *);
void parse_hardware_param (FILE *, struct hardware *);
char *parse_string (FILE *);
struct tree *parse_ip_addr_or_hostname (FILE *, int);
struct tree_cache *parse_fixed_addr_param (FILE *);
void parse_option_param (FILE *, struct group *);
TIME parse_timestamp (FILE *);
struct lease *parse_lease_declaration (FILE *);
void parse_address_range (FILE *, struct subnet *);
TIME parse_date (FILE *);
unsigned char *parse_numeric_aggregate (FILE *,
					       unsigned char *, int *,
					       int, int, int);
void convert_num (unsigned char *, char *, int, int);
d513 8
a520 8
pair cons (caddr_t, pair);
struct tree_cache *tree_cache (struct tree *);
struct tree *tree_host_lookup (char *);
struct dns_host_entry *enter_dns_host (char *);
struct tree *tree_const (unsigned char *, int);
struct tree *tree_concat (struct tree *, struct tree *);
struct tree *tree_limit (struct tree *, int);
int tree_evaluate (struct tree_cache *);
d525 12
a536 14
void dhcp (struct packet *);
void dhcpdiscover (struct packet *);
void dhcprequest (struct packet *);
void dhcprelease (struct packet *);
void dhcpdecline (struct packet *);
void dhcpinform (struct packet *);
void nak_lease (struct packet *, struct iaddr *cip);
void ack_lease (struct packet *, struct lease *, unsigned int, TIME);
void dhcp_reply (struct lease *);
struct lease *find_lease (struct packet *,
				 struct shared_network *, int *);
struct lease *mockup_lease (struct packet *,
				   struct shared_network *,
				   struct host_decl *);
d539 1
a539 1
void bootp (struct packet *);
d542 28
a569 30
void enter_host (struct host_decl *);
struct host_decl *find_hosts_by_haddr (int, unsigned char *, int);
struct host_decl *find_hosts_by_uid (unsigned char *, int);
struct subnet *find_host_for_network (struct host_decl **,
					     struct iaddr *,
					     struct shared_network *);
void new_address_range (struct iaddr, struct iaddr,
			       struct subnet *, int);
extern struct subnet *find_grouped_subnet (struct shared_network *,
						  struct iaddr);
extern struct subnet *find_subnet (struct iaddr);
void enter_shared_network (struct shared_network *);
int subnet_inner_than (struct subnet *, struct subnet *, int);
void enter_subnet (struct subnet *);
void enter_lease (struct lease *);
int supersede_lease (struct lease *, struct lease *, int);
void release_lease (struct lease *);
void abandon_lease (struct lease *, char *);
struct lease *find_lease_by_uid (unsigned char *, int);
struct lease *find_lease_by_hw_addr (unsigned char *, int);
struct lease *find_lease_by_ip_addr (struct iaddr);
void uid_hash_add (struct lease *);
void uid_hash_delete (struct lease *);
void hw_hash_add (struct lease *);
void hw_hash_delete (struct lease *);
struct class *add_class (int, char *);
struct class *find_class (int, unsigned char *, int);
struct group *clone_group (struct group *, char *);
void write_leases (void);
void dump_subnets (void);
d572 35
a606 35
VOIDPTR dmalloc (int, char *);
void dfree (VOIDPTR, char *);
struct packet *new_packet (char *);
struct dhcp_packet *new_dhcp_packet (char *);
struct tree *new_tree (char *);
struct tree_cache *new_tree_cache (char *);
struct hash_table *new_hash_table (int, char *);
struct hash_bucket *new_hash_bucket (char *);
struct lease *new_lease (char *);
struct lease *new_leases (int, char *);
struct subnet *new_subnet (char *);
struct class *new_class (char *);
struct shared_network *new_shared_network (char *);
struct group *new_group (char *);
struct protocol *new_protocol (char *);
struct lease_state *new_lease_state (char *);
struct domain_search_list *new_domain_search_list (char *);
struct name_server *new_name_server (char *);
struct string_list *new_string_list (size_t size, char * name);
void free_name_server (struct name_server *, char *);
void free_domain_search_list (struct domain_search_list *, char *);
void free_lease_state (struct lease_state *, char *);
void free_protocol (struct protocol *, char *);
void free_group (struct group *, char *);
void free_shared_network (struct shared_network *, char *);
void free_class (struct class *, char *);
void free_subnet (struct subnet *, char *);
void free_lease (struct lease *, char *);
void free_hash_bucket (struct hash_bucket *, char *);
void free_hash_table (struct hash_table *, char *);
void free_tree_cache (struct tree_cache *, char *);
void free_packet (struct packet *, char *);
void free_dhcp_packet (struct dhcp_packet *, char *);
void free_tree (struct tree *, char *);
void free_string_list (struct string_list *, char *);
d609 5
a613 5
char *print_hw_addr (int, int, unsigned char *);
void print_lease (struct lease *);
void dump_raw (unsigned char *, int);
void dump_packet (struct packet *);
void hash_dump (struct hash_table *);
d616 3
a618 3
#if defined (USE_SOCKET_SEND) || defined (USE_SOCKET_RECEIVE) \
	|| defined (USE_SOCKET_FALLBACK)
int if_register_socket (struct interface_info *);
d621 6
a626 7
#if defined (USE_SOCKET_FALLBACK) && !defined (USE_SOCKET_SEND)
void if_reinitialize_fallback (struct interface_info *);
void if_register_fallback (struct interface_info *);
ssize_t send_fallback (struct interface_info *,
			      struct packet *, struct dhcp_packet *, size_t, 
			      struct in_addr,
			      struct sockaddr_in *, struct hardware *);
d630 5
a634 6
void if_reinitialize_send (struct interface_info *);
void if_register_send (struct interface_info *);
ssize_t send_packet (struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t, 
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *);
d636 2
a637 2
#if defined (USE_SOCKET_FALLBACK)
void fallback_discard (struct protocol *);
d640 9
a648 10
void if_reinitialize_receive (struct interface_info *);
void if_register_receive (struct interface_info *);
ssize_t receive_packet (struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *);
#endif
#if defined (USE_SOCKET_SEND)
int can_unicast_without_arp (void);
int can_receive_unicast_unconfigured (struct interface_info *);
void maybe_setup_fallback (void);
d652 2
a653 2
#if defined (USE_BPF_SEND) || defined (USE_BPF_RECEIVE)
int if_register_bpf  (struct interface_info *);
d656 5
a660 6
void if_reinitialize_send (struct interface_info *);
void if_register_send (struct interface_info *);
ssize_t send_packet (struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *);
d663 9
a671 10
void if_reinitialize_receive (struct interface_info *);
void if_register_receive (struct interface_info *);
ssize_t receive_packet (struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *);
#endif
#if defined (USE_BPF_SEND)
int can_unicast_without_arp (void);
int can_receive_unicast_unconfigured (struct interface_info *);
void maybe_setup_fallback (void);
d676 8
a683 9
void if_reinitialize_send (struct interface_info *);
void if_register_send (struct interface_info *);
ssize_t send_packet (struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *);
int can_unicast_without_arp (void);
int can_receive_unicast_unconfigured (struct interface_info *);
void maybe_setup_fallback (void);
d688 1
a688 1
	*dummy_interfaces, *fallback_interface;
d691 2
a692 4
extern void (*bootp_packet_handler) (struct interface_info *,
					    struct dhcp_packet *, int,
					    unsigned int,
					    struct iaddr, struct hardware *);
d694 10
a703 11
void discover_interfaces (int);
struct interface_info *setup_fallback (void);
void reinitialize_interfaces (void);
void dispatch (void);
int locate_network (struct packet *);
void got_one (struct protocol *);
void add_timeout (TIME, void (*)(void *), void *);
void cancel_timeout (void (*) (void *), void *);
void add_protocol (char *, int, void (*)(struct protocol *), void *);

void remove_protocol (struct protocol *);
d706 4
a709 5
struct hash_table *new_hash (void);
void add_hash (struct hash_table *, unsigned char *,
		      int, unsigned char *);
void delete_hash_entry (struct hash_table *, unsigned char *, int);
unsigned char *hash_lookup (struct hash_table *, unsigned char *, int);
d712 2
a713 2
extern struct option dhcp_options [256];
extern unsigned char dhcp_option_default_priority_list [];
d715 1
a715 1
extern char *hardware_types [256];
d718 1
a718 1
void initialize_universes (void);
d721 8
a728 8
u_int32_t getULong (unsigned char *);
int32_t getLong (unsigned char *);
u_int16_t getUShort (unsigned char *);
int16_t getShort (unsigned char *);
void putULong (unsigned char *, u_int32_t);
void putLong (unsigned char *, int32_t);
void putUShort (unsigned char *, unsigned int);
void putShort (unsigned char *, int);
d731 6
a736 6
struct iaddr subnet_number (struct iaddr, struct iaddr);
struct iaddr ip_addr (struct iaddr, struct iaddr, u_int32_t);
struct iaddr broadcast_addr (struct iaddr, struct iaddr);
u_int32_t host_addr (struct iaddr, struct iaddr);
int addr_eq (struct iaddr, struct iaddr);
char *piaddr (struct iaddr);
d746 35
a780 37
void dhcpoffer (struct packet *);
void dhcpack (struct packet *);
void dhcpnak (struct packet *);

void send_discover (void *);
void send_request (void *);
void send_release (void *);
void send_decline (void *);

void state_reboot (void *);
void state_init (void *);
void state_selecting (void *);
void state_requesting (void *);
void state_bound (void *);
void state_panic (void *);

void bind_lease (struct interface_info *);

void make_discover (struct interface_info *, struct client_lease *);
void make_request (struct interface_info *, struct client_lease *);
void make_decline (struct interface_info *, struct client_lease *);
void make_release (struct interface_info *, struct client_lease *);

void free_client_lease (struct client_lease *);
void rewrite_client_leases (void);
void write_client_lease (struct interface_info *,
				 struct client_lease *, int);

void script_init (struct interface_info *, char *,
			 struct string_list *);
void script_write_params (struct interface_info *,
				 char *, struct client_lease *);
int script_go (struct interface_info *);
void client_envadd (struct client_state *,
			   const char *, const char *, const char *, ...);
void script_set_env (struct client_state *, const char *, const char *,
		     const char *);
d782 1
a782 1
int dhcp_option_ev_name (char *, size_t, struct option *);
d784 4
a787 4
struct client_lease *packet_to_lease (struct packet *);
void go_daemon (void);
void write_client_pid_file (void);
void client_location_changed (void);
d790 4
a793 4
int write_lease (struct lease *);
int commit_leases (void);
void db_startup (void);
void new_lease_file (void);
d796 10
a805 12
u_int32_t checksum (unsigned char *, unsigned, u_int32_t);
u_int32_t wrapsum (u_int32_t);
void assemble_hw_header (struct interface_info *, unsigned char *,
				int *, struct hardware *);
void assemble_udp_ip_header (struct interface_info *, unsigned char *,
				    int *, u_int32_t, u_int32_t, unsigned int,
				    unsigned char *, int);
ssize_t decode_hw_header (struct interface_info *, unsigned char *,
				 int, struct hardware *);
ssize_t decode_udp_ip_header (struct interface_info *, unsigned char *,
				     int, struct sockaddr_in *,
				     unsigned char *, int);
d808 4
a811 5
void assemble_ethernet_header (struct interface_info *, unsigned char *,
				      int *, struct hardware *);
ssize_t decode_ethernet_header (struct interface_info *,
				       unsigned char *,
				       int, struct hardware *);
d814 4
a817 5
void assemble_tr_header (struct interface_info *, unsigned char *,
				int *, struct hardware *);
ssize_t decode_tr_header (struct interface_info *,
				 unsigned char *,
				 int, struct hardware *);
d820 23
a842 23
void convert_statement (FILE *);
void convert_host_statement (FILE *, jrefproto);
void convert_host_name (FILE *, jrefproto);
void convert_class_statement (FILE *, jrefproto, int);
void convert_class_decl (FILE *, jrefproto);
void convert_lease_time (FILE *, jrefproto, char *);
void convert_shared_net_statement (FILE *, jrefproto);
void convert_subnet_statement (FILE *, jrefproto);
void convert_subnet_decl (FILE *, jrefproto);
void convert_host_decl (FILE *, jrefproto);
void convert_hardware_decl (FILE *, jrefproto);
void convert_hardware_addr (FILE *, jrefproto);
void convert_filename_decl (FILE *, jrefproto);
void convert_servername_decl (FILE *, jrefproto);
void convert_ip_addr_or_hostname (FILE *, jrefproto, int);
void convert_fixed_addr_decl (FILE *, jrefproto);
void convert_option_decl (FILE *, jrefproto);
void convert_timestamp (FILE *, jrefproto);
void convert_lease_statement (FILE *, jrefproto);
void convert_address_range (FILE *, jrefproto);
void convert_date (FILE *, jrefproto, char *);
void convert_numeric_aggregate (FILE *, jrefproto, int, int, int, int);
void indent (int);
d845 9
a853 11
void add_route_direct (struct interface_info *, struct in_addr);
void add_route_net (struct interface_info *, struct in_addr,
			   struct in_addr);
void add_route_default_gateway (struct interface_info *, 
				       struct in_addr);
void remove_routes (struct in_addr);
void remove_if_route (struct interface_info *, struct in_addr);
void remove_all_if_routes (struct interface_info *);
void set_netmask (struct interface_info *, struct in_addr);
void set_broadcast_addr (struct interface_info *, struct in_addr);
void set_ip_address (struct interface_info *, struct in_addr);
d856 17
a872 18
int read_client_conf (void);
void read_client_leases (void);
void parse_client_statement (FILE *, struct interface_info *,
				    struct client_config *);
int parse_X (FILE *, u_int8_t *, int);
int parse_option_list (FILE *, u_int8_t *);
void parse_interface_declaration (FILE *, struct client_config *);
struct interface_info *interface_or_dummy (char *);
void make_client_state (struct interface_info *);
void make_client_config (struct interface_info *,
				struct client_config *);
void parse_client_lease_statement (FILE *, int);
void parse_client_lease_declaration (FILE *, struct client_lease *,
					    struct interface_info **);
struct option *parse_option_decl (FILE *, struct option_data *);
void parse_string_list (FILE *, struct string_list **, int);
int parse_ip_addr (FILE *, struct iaddr *);
void parse_reject_statement (FILE *, struct client_config *);
d875 2
a876 2
void relay (struct interface_info *, struct dhcp_packet *, int,
		   unsigned int, struct iaddr, struct hardware *);
d879 3
a881 3
void icmp_startup (int, void (*)(struct iaddr, u_int8_t *, int));
int icmp_echorequest (struct iaddr *);
void icmp_echoreply (struct protocol *);
d884 3
a886 3
void dns_startup (void);
int ns_inaddr_lookup (u_int16_t, struct iaddr);
void dns_packet (struct protocol *);
d889 1
a889 1
extern char path_resolv_conf [];
d893 1
a893 1
void read_resolv_conf (TIME);
@


1.2
log
@8579 lines of KNF, ANSO and zap-junk diff without the resulting binary
changing by a single byte.
partly from theo
@
text
@d1 1
a1 1
/* dhcpd.h
d3 1
a3 1
   Definitions for dhcpd... */
@


1.1
log
@this is where dhclient will start surgery
@
text
@a42 1
#ifndef __CYGWIN32__
a48 4
#else
#define fd_set cygwin_fd_set
#include <sys/types.h>
#endif
a57 1
#include "cdefs.h"
a62 1
#include "sysconf.h"
d400 1
a400 1
	void (*func) PROTO ((void *));
d407 1
a407 1
	void (*handler) PROTO ((struct protocol *));
a425 20
#ifdef DEBUG
#undef _PATH_DHCPD_CONF
#define _PATH_DHCPD_CONF	"dhcpd.conf"
#undef _PATH_DHCPD_DB
#define _PATH_DHCPD_DB		"dhcpd.leases"
#else
#ifndef _PATH_DHCPD_CONF
#define _PATH_DHCPD_CONF	"/etc/dhcpd.conf"
#endif

#ifndef _PATH_DHCPD_DB
#define _PATH_DHCPD_DB		"/etc/dhcpd.leases"
#endif

#ifndef _PATH_DHCPD_PID
#define _PATH_DHCPD_PID		"/var/run/dhcpd.pid"
#endif
#endif

#ifndef _PATH_DHCLIENT_CONF
a426 3
#endif

#ifndef _PATH_DHCLIENT_PID
d428 1
a428 7
#endif

#ifndef _PATH_DHCLIENT_DB
#define _PATH_DHCLIENT_DB	"/etc/dhclient.leases"
#endif

#ifndef _PATH_RESOLV_CONF
a429 3
#endif

#ifndef _PATH_DHCRELAY_PID
d431 2
a432 3
#endif

#ifndef DHCPD_LOG_FACILITY
a433 1
#endif
d442 3
a444 3
void parse_options PROTO ((struct packet *));
void parse_option_buffer PROTO ((struct packet *, unsigned char *, int));
int cons_options PROTO ((struct packet *, struct dhcp_packet *, int,
d446 6
a451 6
			 u_int8_t *, int));
int store_options PROTO ((unsigned char *, int, struct tree_cache **,
			   unsigned char *, int, int, int, int));
char *pretty_print_option PROTO ((unsigned int,
				  unsigned char *, int, int, int));
void do_packet PROTO ((struct interface_info *,
d453 1
a453 1
		       unsigned int, struct iaddr, struct hardware *));
d472 2
a473 8
extern char *path_dhcpd_conf;
extern char *path_dhcpd_db;
extern char *path_dhcpd_pid;

int main PROTO ((int, char **));
void cleanup PROTO ((void));
void lease_pinged PROTO ((struct iaddr, u_int8_t *, int));
void lease_ping_timeout PROTO ((void *));
d481 3
a483 3
void new_parse PROTO ((char *));
int next_token PROTO ((char **, FILE *));
int peek_token PROTO ((char **, FILE *));
d486 26
a511 26
int readconf PROTO ((void));
void read_leases PROTO ((void));
int parse_statement PROTO ((FILE *,
			    struct group *, int, struct host_decl *, int));
void parse_allow_deny PROTO ((FILE *, struct group *, int));
void skip_to_semi PROTO ((FILE *));
int parse_boolean PROTO ((FILE *));
int parse_semi PROTO ((FILE *));
int parse_lbrace PROTO ((FILE *));
void parse_host_declaration PROTO ((FILE *, struct group *));
char *parse_host_name PROTO ((FILE *));
void parse_class_declaration PROTO ((FILE *, struct group *, int));
void parse_lease_time PROTO ((FILE *, TIME *));
void parse_shared_net_declaration PROTO ((FILE *, struct group *));
void parse_subnet_declaration PROTO ((FILE *, struct shared_network *));
void parse_group_declaration PROTO ((FILE *, struct group *));
void parse_hardware_param PROTO ((FILE *, struct hardware *));
char *parse_string PROTO ((FILE *));
struct tree *parse_ip_addr_or_hostname PROTO ((FILE *, int));
struct tree_cache *parse_fixed_addr_param PROTO ((FILE *));
void parse_option_param PROTO ((FILE *, struct group *));
TIME parse_timestamp PROTO ((FILE *));
struct lease *parse_lease_declaration PROTO ((FILE *));
void parse_address_range PROTO ((FILE *, struct subnet *));
TIME parse_date PROTO ((FILE *));
unsigned char *parse_numeric_aggregate PROTO ((FILE *,
d513 2
a514 2
					       int, int, int));
void convert_num PROTO ((unsigned char *, char *, int, int));
d517 8
a524 8
pair cons PROTO ((caddr_t, pair));
struct tree_cache *tree_cache PROTO ((struct tree *));
struct tree *tree_host_lookup PROTO ((char *));
struct dns_host_entry *enter_dns_host PROTO ((char *));
struct tree *tree_const PROTO ((unsigned char *, int));
struct tree *tree_concat PROTO ((struct tree *, struct tree *));
struct tree *tree_limit PROTO ((struct tree *, int));
int tree_evaluate PROTO ((struct tree_cache *));
d529 12
a540 12
void dhcp PROTO ((struct packet *));
void dhcpdiscover PROTO ((struct packet *));
void dhcprequest PROTO ((struct packet *));
void dhcprelease PROTO ((struct packet *));
void dhcpdecline PROTO ((struct packet *));
void dhcpinform PROTO ((struct packet *));
void nak_lease PROTO ((struct packet *, struct iaddr *cip));
void ack_lease PROTO ((struct packet *, struct lease *, unsigned int, TIME));
void dhcp_reply PROTO ((struct lease *));
struct lease *find_lease PROTO ((struct packet *,
				 struct shared_network *, int *));
struct lease *mockup_lease PROTO ((struct packet *,
d542 1
a542 1
				   struct host_decl *));
d545 1
a545 1
void bootp PROTO ((struct packet *));
d548 4
a551 4
void enter_host PROTO ((struct host_decl *));
struct host_decl *find_hosts_by_haddr PROTO ((int, unsigned char *, int));
struct host_decl *find_hosts_by_uid PROTO ((unsigned char *, int));
struct subnet *find_host_for_network PROTO ((struct host_decl **,
d553 25
a577 25
					     struct shared_network *));
void new_address_range PROTO ((struct iaddr, struct iaddr,
			       struct subnet *, int));
extern struct subnet *find_grouped_subnet PROTO ((struct shared_network *,
						  struct iaddr));
extern struct subnet *find_subnet PROTO ((struct iaddr));
void enter_shared_network PROTO ((struct shared_network *));
int subnet_inner_than PROTO ((struct subnet *, struct subnet *, int));
void enter_subnet PROTO ((struct subnet *));
void enter_lease PROTO ((struct lease *));
int supersede_lease PROTO ((struct lease *, struct lease *, int));
void release_lease PROTO ((struct lease *));
void abandon_lease PROTO ((struct lease *, char *));
struct lease *find_lease_by_uid PROTO ((unsigned char *, int));
struct lease *find_lease_by_hw_addr PROTO ((unsigned char *, int));
struct lease *find_lease_by_ip_addr PROTO ((struct iaddr));
void uid_hash_add PROTO ((struct lease *));
void uid_hash_delete PROTO ((struct lease *));
void hw_hash_add PROTO ((struct lease *));
void hw_hash_delete PROTO ((struct lease *));
struct class *add_class PROTO ((int, char *));
struct class *find_class PROTO ((int, unsigned char *, int));
struct group *clone_group PROTO ((struct group *, char *));
void write_leases PROTO ((void));
void dump_subnets PROTO ((void));
d580 35
a614 35
VOIDPTR dmalloc PROTO ((int, char *));
void dfree PROTO ((VOIDPTR, char *));
struct packet *new_packet PROTO ((char *));
struct dhcp_packet *new_dhcp_packet PROTO ((char *));
struct tree *new_tree PROTO ((char *));
struct tree_cache *new_tree_cache PROTO ((char *));
struct hash_table *new_hash_table PROTO ((int, char *));
struct hash_bucket *new_hash_bucket PROTO ((char *));
struct lease *new_lease PROTO ((char *));
struct lease *new_leases PROTO ((int, char *));
struct subnet *new_subnet PROTO ((char *));
struct class *new_class PROTO ((char *));
struct shared_network *new_shared_network PROTO ((char *));
struct group *new_group PROTO ((char *));
struct protocol *new_protocol PROTO ((char *));
struct lease_state *new_lease_state PROTO ((char *));
struct domain_search_list *new_domain_search_list PROTO ((char *));
struct name_server *new_name_server PROTO ((char *));
struct string_list *new_string_list PROTO ((size_t size, char * name));
void free_name_server PROTO ((struct name_server *, char *));
void free_domain_search_list PROTO ((struct domain_search_list *, char *));
void free_lease_state PROTO ((struct lease_state *, char *));
void free_protocol PROTO ((struct protocol *, char *));
void free_group PROTO ((struct group *, char *));
void free_shared_network PROTO ((struct shared_network *, char *));
void free_class PROTO ((struct class *, char *));
void free_subnet PROTO ((struct subnet *, char *));
void free_lease PROTO ((struct lease *, char *));
void free_hash_bucket PROTO ((struct hash_bucket *, char *));
void free_hash_table PROTO ((struct hash_table *, char *));
void free_tree_cache PROTO ((struct tree_cache *, char *));
void free_packet PROTO ((struct packet *, char *));
void free_dhcp_packet PROTO ((struct dhcp_packet *, char *));
void free_tree PROTO ((struct tree *, char *));
void free_string_list PROTO ((struct string_list *, char *));
d617 5
a621 5
char *print_hw_addr PROTO ((int, int, unsigned char *));
void print_lease PROTO ((struct lease *));
void dump_raw PROTO ((unsigned char *, int));
void dump_packet PROTO ((struct packet *));
void hash_dump PROTO ((struct hash_table *));
d626 1
a626 1
int if_register_socket PROTO ((struct interface_info *));
d630 3
a632 3
void if_reinitialize_fallback PROTO ((struct interface_info *));
void if_register_fallback PROTO ((struct interface_info *));
ssize_t send_fallback PROTO ((struct interface_info *,
d635 1
a635 1
			      struct sockaddr_in *, struct hardware *));
d639 3
a641 3
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
d644 1
a644 1
			    struct sockaddr_in *, struct hardware *));
d647 1
a647 1
void fallback_discard PROTO ((struct protocol *));
d650 3
a652 3
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
d654 1
a654 1
			       struct sockaddr_in *, struct hardware *));
d657 3
a659 3
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
d664 1
a664 1
int if_register_bpf PROTO ( (struct interface_info *));
d667 3
a669 3
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
d672 1
a672 1
			    struct sockaddr_in *, struct hardware *));
d675 3
a677 3
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
d679 1
a679 1
			       struct sockaddr_in *, struct hardware *));
d682 3
a684 75
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

/* lpf.c */
#if defined (USE_LPF_SEND) || defined (USE_LPF_RECEIVE)
int if_register_lpf PROTO ( (struct interface_info *));
#endif
#ifdef USE_LPF_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#ifdef USE_LPF_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_LPF_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

/* nit.c */
#if defined (USE_NIT_SEND) || defined (USE_NIT_RECEIVE)
int if_register_nit PROTO ( (struct interface_info *));
#endif

#ifdef USE_NIT_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#ifdef USE_NIT_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_NIT_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

#ifdef USE_DLPI_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#ifdef USE_DLPI_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_DLPI_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
d689 3
a691 3
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
d694 4
a697 4
			    struct sockaddr_in *, struct hardware *));
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
d705 1
a705 1
extern void (*bootp_packet_handler) PROTO ((struct interface_info *,
d708 1
a708 1
					    struct iaddr, struct hardware *));
d710 9
a718 10
void discover_interfaces PROTO ((int));
struct interface_info *setup_fallback PROTO ((void));
void reinitialize_interfaces PROTO ((void));
void dispatch PROTO ((void));
int locate_network PROTO ((struct packet *));
void got_one PROTO ((struct protocol *));
void add_timeout PROTO ((TIME, void (*) PROTO ((void *)), void *));
void cancel_timeout PROTO ((void (*) PROTO ((void *)), void *));
void add_protocol PROTO ((char *, int,
			  void (*) PROTO ((struct protocol *)), void *));
d720 1
a720 1
void remove_protocol PROTO ((struct protocol *));
d723 5
a727 5
struct hash_table *new_hash PROTO ((void));
void add_hash PROTO ((struct hash_table *, unsigned char *,
		      int, unsigned char *));
void delete_hash_entry PROTO ((struct hash_table *, unsigned char *, int));
unsigned char *hash_lookup PROTO ((struct hash_table *, unsigned char *, int));
d736 1
a736 1
void initialize_universes PROTO ((void));
d739 8
a746 8
u_int32_t getULong PROTO ((unsigned char *));
int32_t getLong PROTO ((unsigned char *));
u_int16_t getUShort PROTO ((unsigned char *));
int16_t getShort PROTO ((unsigned char *));
void putULong PROTO ((unsigned char *, u_int32_t));
void putLong PROTO ((unsigned char *, int32_t));
void putUShort PROTO ((unsigned char *, unsigned int));
void putShort PROTO ((unsigned char *, int));
d749 6
a754 6
struct iaddr subnet_number PROTO ((struct iaddr, struct iaddr));
struct iaddr ip_addr PROTO ((struct iaddr, struct iaddr, u_int32_t));
struct iaddr broadcast_addr PROTO ((struct iaddr, struct iaddr));
u_int32_t host_addr PROTO ((struct iaddr, struct iaddr));
int addr_eq PROTO ((struct iaddr, struct iaddr));
char *piaddr PROTO ((struct iaddr));
d764 35
a798 35
void dhcpoffer PROTO ((struct packet *));
void dhcpack PROTO ((struct packet *));
void dhcpnak PROTO ((struct packet *));

void send_discover PROTO ((void *));
void send_request PROTO ((void *));
void send_release PROTO ((void *));
void send_decline PROTO ((void *));

void state_reboot PROTO ((void *));
void state_init PROTO ((void *));
void state_selecting PROTO ((void *));
void state_requesting PROTO ((void *));
void state_bound PROTO ((void *));
void state_panic PROTO ((void *));

void bind_lease PROTO ((struct interface_info *));

void make_discover PROTO ((struct interface_info *, struct client_lease *));
void make_request PROTO ((struct interface_info *, struct client_lease *));
void make_decline PROTO ((struct interface_info *, struct client_lease *));
void make_release PROTO ((struct interface_info *, struct client_lease *));

void free_client_lease PROTO ((struct client_lease *));
void rewrite_client_leases PROTO ((void));
void write_client_lease PROTO ((struct interface_info *,
				 struct client_lease *, int));

void script_init PROTO ((struct interface_info *, char *,
			 struct string_list *));
void script_write_params PROTO ((struct interface_info *,
				 char *, struct client_lease *));
int script_go PROTO ((struct interface_info *));
void client_envadd PROTO ((struct client_state *,
			   const char *, const char *, const char *, ...));
d804 4
a807 5
struct client_lease *packet_to_lease PROTO ((struct packet *));
void go_daemon PROTO ((void));
void write_client_pid_file PROTO ((void));
void status_message PROTO ((struct sysconf_header *, void *));
void client_location_changed PROTO ((void));
d810 4
a813 4
int write_lease PROTO ((struct lease *));
int commit_leases PROTO ((void));
void db_startup PROTO ((void));
void new_lease_file PROTO ((void));
d816 5
a820 5
u_int32_t checksum PROTO ((unsigned char *, unsigned, u_int32_t));
u_int32_t wrapsum PROTO ((u_int32_t));
void assemble_hw_header PROTO ((struct interface_info *, unsigned char *,
				int *, struct hardware *));
void assemble_udp_ip_header PROTO ((struct interface_info *, unsigned char *,
d822 4
a825 4
				    unsigned char *, int));
ssize_t decode_hw_header PROTO ((struct interface_info *, unsigned char *,
				 int, struct hardware *));
ssize_t decode_udp_ip_header PROTO ((struct interface_info *, unsigned char *,
d827 1
a827 1
				     unsigned char *, int));
d830 3
a832 3
void assemble_ethernet_header PROTO ((struct interface_info *, unsigned char *,
				      int *, struct hardware *));
ssize_t decode_ethernet_header PROTO ((struct interface_info *,
d834 1
a834 1
				       int, struct hardware *));
d837 3
a839 3
void assemble_tr_header PROTO ((struct interface_info *, unsigned char *,
				int *, struct hardware *));
ssize_t decode_tr_header PROTO ((struct interface_info *,
d841 1
a841 1
				 int, struct hardware *));
d844 23
a866 23
void convert_statement PROTO ((FILE *));
void convert_host_statement PROTO ((FILE *, jrefproto));
void convert_host_name PROTO ((FILE *, jrefproto));
void convert_class_statement PROTO ((FILE *, jrefproto, int));
void convert_class_decl PROTO ((FILE *, jrefproto));
void convert_lease_time PROTO ((FILE *, jrefproto, char *));
void convert_shared_net_statement PROTO ((FILE *, jrefproto));
void convert_subnet_statement PROTO ((FILE *, jrefproto));
void convert_subnet_decl PROTO ((FILE *, jrefproto));
void convert_host_decl PROTO ((FILE *, jrefproto));
void convert_hardware_decl PROTO ((FILE *, jrefproto));
void convert_hardware_addr PROTO ((FILE *, jrefproto));
void convert_filename_decl PROTO ((FILE *, jrefproto));
void convert_servername_decl PROTO ((FILE *, jrefproto));
void convert_ip_addr_or_hostname PROTO ((FILE *, jrefproto, int));
void convert_fixed_addr_decl PROTO ((FILE *, jrefproto));
void convert_option_decl PROTO ((FILE *, jrefproto));
void convert_timestamp PROTO ((FILE *, jrefproto));
void convert_lease_statement PROTO ((FILE *, jrefproto));
void convert_address_range PROTO ((FILE *, jrefproto));
void convert_date PROTO ((FILE *, jrefproto, char *));
void convert_numeric_aggregate PROTO ((FILE *, jrefproto, int, int, int, int));
void indent PROTO ((int));
d869 11
a879 11
void add_route_direct PROTO ((struct interface_info *, struct in_addr));
void add_route_net PROTO ((struct interface_info *, struct in_addr,
			   struct in_addr));
void add_route_default_gateway PROTO ((struct interface_info *, 
				       struct in_addr));
void remove_routes PROTO ((struct in_addr));
void remove_if_route PROTO ((struct interface_info *, struct in_addr));
void remove_all_if_routes PROTO ((struct interface_info *));
void set_netmask PROTO ((struct interface_info *, struct in_addr));
void set_broadcast_addr PROTO ((struct interface_info *, struct in_addr));
void set_ip_address PROTO ((struct interface_info *, struct in_addr));
d882 18
a899 18
int read_client_conf PROTO ((void));
void read_client_leases PROTO ((void));
void parse_client_statement PROTO ((FILE *, struct interface_info *,
				    struct client_config *));
int parse_X PROTO ((FILE *, u_int8_t *, int));
int parse_option_list PROTO ((FILE *, u_int8_t *));
void parse_interface_declaration PROTO ((FILE *, struct client_config *));
struct interface_info *interface_or_dummy PROTO ((char *));
void make_client_state PROTO ((struct interface_info *));
void make_client_config PROTO ((struct interface_info *,
				struct client_config *));
void parse_client_lease_statement PROTO ((FILE *, int));
void parse_client_lease_declaration PROTO ((FILE *, struct client_lease *,
					    struct interface_info **));
struct option *parse_option_decl PROTO ((FILE *, struct option_data *));
void parse_string_list PROTO ((FILE *, struct string_list **, int));
int parse_ip_addr PROTO ((FILE *, struct iaddr *));
void parse_reject_statement PROTO ((FILE *, struct client_config *));
d902 2
a903 2
void relay PROTO ((struct interface_info *, struct dhcp_packet *, int,
		   unsigned int, struct iaddr, struct hardware *));
d906 3
a908 4
void icmp_startup PROTO ((int, void (*) PROTO ((struct iaddr,
						u_int8_t *, int))));
int icmp_echorequest PROTO ((struct iaddr *));
void icmp_echoreply PROTO ((struct protocol *));
d911 3
a913 3
void dns_startup PROTO ((void));
int ns_inaddr_lookup PROTO ((u_int16_t, struct iaddr));
void dns_packet PROTO ((struct protocol *));
d920 2
a921 12
void read_resolv_conf PROTO ((TIME));
struct sockaddr_in *pick_name_server PROTO ((void));

/* inet_addr.c */
#ifdef NEED_INET_ATON
int inet_aton PROTO ((const char *, struct in_addr *));
#endif

/* sysconf.c */
void sysconf_startup PROTO ((void (*) (struct sysconf_header *, void *)));
void sysconf_restart PROTO ((void *));
void sysconf_message PROTO ((struct protocol *proto));
@

