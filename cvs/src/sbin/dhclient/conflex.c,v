head	1.37;
access;
symbols
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.33.0.6
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.20
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.18
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.16
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.37
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.36;
commitid	KIdulj0iLtM6kXff;

1.36
date	2017.04.03.18.23.36;	author krw;	state Exp;
branches;
next	1.35;
commitid	0diNNQhqbwkZVgen;

1.35
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.34;
commitid	IDlzr3qamZK5lxzj;

1.34
date	2016.08.16.21.57.51;	author krw;	state Exp;
branches;
next	1.33;
commitid	fX275BVALtbId2xm;

1.33
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.32;
commitid	5ELOU0S0Zl3aCrHG;

1.32
date	2015.05.18.17.51.21;	author krw;	state Exp;
branches;
next	1.31;
commitid	SjQKXPdyGuKrZRc7;

1.31
date	2015.05.02.14.29.32;	author krw;	state Exp;
branches;
next	1.30;
commitid	JcR9NePskWu9skGw;

1.30
date	2015.05.02.12.37.35;	author krw;	state Exp;
branches;
next	1.29;
commitid	Fd1cG6Ltt63O8Ell;

1.29
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.19.03.54.25;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.18.01.41.28;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2013.12.18.00.37.59;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2013.12.05.22.31.35;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.12.04.59.00;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.22.18.15.58;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.09.01.51.58;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.04.13.00.07;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2012.11.07.15.20.28;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.22.00.14.42;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2011.12.10.17.36.40;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.17.17.41.56;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.08.17.25.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.18.19.17.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.02.18.26.49;	author moritz;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.26.19.14.57;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.09.16.16.11;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.15.19.02.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.24.13.08.26;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.11.35.59;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.01.50.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.01.18.26;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@/*	$OpenBSD: conflex.c,v 1.36 2017/04/03 18:23:36 krw Exp $	*/

/* Lexical scanner for dhclient config file. */

/*
 * Copyright (c) 1995, 1996, 1997 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/queue.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <ctype.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "dhctoken.h"
#include "log.h"

int lexline;
int lexchar;
char *token_line;
char *prev_line;
char *cur_line;
char *tlname;

static char line1[81];
static char line2[81];
static int lpos;
static int line;
static int tlpos;
static int tline;
static int token;
static int ugflag;
static char *tval;
static char tokbuf[1500];

static int get_char(FILE *);
static int get_token(FILE *);
static void skip_to_eol(FILE *);
static int read_string(FILE *);
static int read_num_or_name(int, FILE *);
static int intern(char *, int);

void
new_parse(char *name)
{
	/*
	 * Initialize all parsing state, as we are starting to parse a
	 * new file, 'name'.
	 */

	memset(line1, 0, sizeof(line1));
	memset(line2, 0, sizeof(line2));
	memset(tokbuf, 0, sizeof(tokbuf));

	lpos = line = 1;
	tlpos = tline = token = ugflag = 0;
	tval = NULL;

	lexline = lexchar = 0;
	cur_line = line1;
	prev_line = line2;
	token_line = cur_line;
	tlname = name;

	warnings_occurred = 0;
}

static int
get_char(FILE *cfile)
{
	int c = getc(cfile);
	if (!ugflag) {
		if (c == '\n') {
			if (cur_line == line1) {
				cur_line = line2;
				prev_line = line1;
			} else {
				cur_line = line1;
				prev_line = line2;
			}
			line++;
			lpos = 1;
			cur_line[0] = 0;
		} else if (c != EOF) {
			if (lpos < sizeof(line1)) {
				cur_line[lpos - 1] = c;
				cur_line[lpos] = 0;
			}
			lpos++;
		}
	} else
		ugflag = 0;
	return (c);
}

static int
get_token(FILE *cfile)
{
	int		c, ttok;
	static char	tb[2];
	int		l, p, u;

	u = ugflag;

	do {
		l = line;
		p = lpos - u;
		u = 0;

		c = get_char(cfile);

		if (isascii(c) && isspace(c))
			continue;
		if (c == '#') {
			skip_to_eol(cfile);
			continue;
		}
		lexline = l;
		lexchar = p;
		if (c == '"') {
			ttok = read_string(cfile);
			break;
		} else if (c == '-' || (isascii(c) && isalnum(c))) {
			ttok = read_num_or_name(c, cfile);
			break;
		} else {
			tb[0] = c;
			tb[1] = 0;
			tval = tb;
			ttok = c;
			break;
		}
	} while (1);
	return (ttok);
}

int
next_token(char **rval, FILE *cfile)
{
	int	rv;

	if (token) {
		if (lexline != tline)
			token_line = cur_line;
		lexchar = tlpos;
		lexline = tline;
		rv = token;
		token = 0;
	} else {
		rv = get_token(cfile);
		token_line = cur_line;
	}
	if (rval)
		*rval = tval;

	return (rv);
}

int
peek_token(char **rval, FILE *cfile)
{
	int	x;

	if (!token) {
		tlpos = lexchar;
		tline = lexline;
		token = get_token(cfile);
		if (lexline != tline)
			token_line = prev_line;
		x = lexchar;
		lexchar = tlpos;
		tlpos = x;
		x = lexline;
		lexline = tline;
		tline = x;
	}
	if (rval)
		*rval = tval;

	return (token);
}

static void
skip_to_eol(FILE *cfile)
{
	int	c;

	do {
		c = get_char(cfile);
		if (c == EOF)
			return;
		if (c == '\n')
			return;
	} while (1);
}

static int
read_string(FILE *cfile)
{
	int i, c, bs;

	/*
	 * Read in characters until an un-escaped '"' is encountered.
	 */
	bs = i = 0;
	while ((c = get_char(cfile)) != EOF) {
		if (c == '"' && bs == 0)
			break;

		tokbuf[i++] = c;
		if (bs)
			bs = 0;
		else if (c == '\\')
			bs = 1;

		if (i == sizeof(tokbuf) - 1)
			break;
	}
	if (bs == 1)
		i--;

	if (c == EOF)
		parse_warn("eof in string constant");
	else if (c != '"')
		parse_warn("string constant too long");

	tokbuf[i] = '\0';
	tval = tokbuf;

	return (TOK_STRING);
}

static int
read_num_or_name(int c, FILE *cfile)
{
	unsigned int i, xdigits;
	int rv;

	xdigits = isxdigit(c) ? 1 : 0;

	tokbuf[0] = c;
	for (i = 1; i < sizeof(tokbuf); i++) {
		c = get_char(cfile);
		if (!isascii(c) || (c != '-' && c != '_' && !isalnum(c))) {
			ungetc(c, cfile);
			ugflag = 1;
			break;
		}
		if (isxdigit(c))
			xdigits++;
		tokbuf[i] = c;
	}
	if (i == sizeof(tokbuf)) {
		parse_warn("token larger than internal buffer");
		i--;
		c = tokbuf[i];
		if (isxdigit(c))
			xdigits--;
	}
	tokbuf[i] = 0;
	tval = tokbuf;

	c = (unsigned int)tokbuf[0];

	if (c == '-')
		rv = TOK_NUMBER;
	else
		rv = intern(tval, TOK_NUMBER_OR_NAME);

	if (rv == TOK_NUMBER_OR_NAME && xdigits != i)
		rv = TOK_NAME;

	return (rv);
}

static const struct keywords {
	const char	*k_name;
	int		k_val;
} keywords[] = {
	{ "alias",				TOK_ALIAS },
	{ "append",				TOK_APPEND },
	{ "backoff-cutoff",			TOK_BACKOFF_CUTOFF },
	{ "bootp",				TOK_BOOTP },
	{ "default",				TOK_DEFAULT },
	{ "deny",				TOK_DENY },
	{ "ethernet",				TOK_ETHERNET },
	{ "expire",				TOK_EXPIRE },
	{ "filename",				TOK_FILENAME },
	{ "fixed-address",			TOK_FIXED_ADDR },
	{ "hardware",				TOK_HARDWARE },
	{ "ignore",				TOK_IGNORE },
	{ "initial-interval",			TOK_INITIAL_INTERVAL },
	{ "interface",				TOK_INTERFACE },
	{ "lease",				TOK_LEASE },
	{ "link-timeout",			TOK_LINK_TIMEOUT },
	{ "media",				TOK_MEDIA },
	{ "medium",				TOK_MEDIUM },
	{ "next-server",			TOK_NEXT_SERVER },
	{ "option",				TOK_OPTION },
	{ "prepend",				TOK_PREPEND },
	{ "rebind",				TOK_REBIND },
	{ "reboot",				TOK_REBOOT },
	{ "reject",				TOK_REJECT },
	{ "renew",				TOK_RENEW },
	{ "request",				TOK_REQUEST },
	{ "require",				TOK_REQUIRE },
	{ "retry",				TOK_RETRY },
	{ "select-timeout",			TOK_SELECT_TIMEOUT },
	{ "send",				TOK_SEND },
	{ "server-name",			TOK_SERVER_NAME },
	{ "ssid",				TOK_SSID },
	{ "supersede",				TOK_SUPERSEDE },
	{ "timeout",				TOK_TIMEOUT }
};

int	kw_cmp(const void *k, const void *e);

int
kw_cmp(const void *k, const void *e)
{
	return (strcasecmp(k, ((const struct keywords *)e)->k_name));
}

static int
intern(char *atom, int dfv)
{
	const struct keywords *p;

	p = bsearch(atom, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);
	if (p)
		return (p->k_val);
	return (dfv);
}
@


1.36
log
@Simplify read_string() to just read the characters between the '"'s.
Push the un-vising up to parse_string(). This allows both the actual
string and the un-vised version to be available as desired. Use
memcpy() instead of strdup() to copy un-vised string since it may
legitimately contain NUL.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.35 2017/02/12 13:15:50 krw Exp $	*/
d282 2
a283 1
	int i, rv, xdigits;
@


1.35
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.34 2016/08/16 21:57:51 krw Exp $	*/
a57 1
#include <vis.h>
a80 1
static char visbuf[1500];
d249 1
a249 2
	 * Read in characters until an un-escaped '"' is encountered. And
	 * then unvis the data that was read.
a251 1
	memset(visbuf, 0, sizeof(visbuf));
d256 1
a256 1
		visbuf[i++] = c;
d262 1
a262 1
		if (i == sizeof(visbuf) - 1)
d266 1
a266 2
		visbuf[--i] = '\0';
	i = strnunvis(tokbuf, visbuf, sizeof(tokbuf));
d270 1
a270 1
	else if (i == -1 || i >= sizeof(tokbuf))
d273 1
@


1.34
log
@Track SSID in leases file and only consider leases from the current SSID when
starting up dhclient on wifi interfaces. In theory will preserve leases from
other SSID's and speed up obtaining a lease by not wasting time attempting
to re-acquire a lease from a different SSID.

Experimental feature from n2k16 needing some real world testing before g2k16.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.33 2016/02/06 19:30:52 krw Exp $	*/
d63 1
@


1.33
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.32 2015/05/18 17:51:21 krw Exp $	*/
d359 1
@


1.32
log
@Tweak parsing so that hostnames starting with 0-9 are accepted.

Reported long ago by matthieu@@. Also Jacob Berkman via the lists.

Tests and suggestions from Jacob and Matthieu.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.31 2015/05/02 14:29:32 krw Exp $	*/
d43 18
a62 2

#include <vis.h>
@


1.31
log
@Hoist common assignments out of a series of if/if-else statements
in get_token(). Simplifies code and shrinks future diff.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.30 2015/05/02 12:37:35 krw Exp $	*/
a70 1
static int read_number(int, FILE *);
d154 1
a154 5
		}
		if ((isascii(c) && isdigit(c)) || c == '-') {
			ttok = read_number(c, cfile);
			break;
		} else if (isascii(c) && isalpha(c)) {
d267 1
a267 1
read_number(int c, FILE *cfile)
d269 3
a271 1
	int	seenx = 0, i = 0, token = TOK_NUMBER;
d273 2
a274 2
	tokbuf[i++] = c;
	for (; i < sizeof(tokbuf); i++) {
d276 1
a276 3
		if (!seenx && c == 'x')
			seenx = 1;
		else if (!isascii(c) || !isxdigit(c)) {
d281 2
d286 1
a286 1
		parse_warn("numeric token larger than internal buffer");
d288 3
d295 1
a295 2
	return (token);
}
d297 4
a300 5
static int
read_num_or_name(int c, FILE *cfile)
{
	int	i = 0;
	int	rv = TOK_NUMBER_OR_NAME;
d302 2
a303 18
	tokbuf[i++] = c;
	for (; i < sizeof(tokbuf); i++) {
		c = get_char(cfile);
		if (!isascii(c) || (c != '-' && c != '_' && !isalnum(c))) {
			ungetc(c, cfile);
			ugflag = 1;
			break;
		}
		if (!isxdigit(c))
			rv = TOK_NAME;
		tokbuf[i] = c;
	}
	if (i == sizeof(tokbuf)) {
		parse_warn("token larger than internal buffer");
		i--;
	}
	tokbuf[i] = 0;
	tval = tokbuf;
d305 1
a305 1
	return (intern(tval, rv));
@


1.30
log
@Correct switch between current and previous line buffers when
encountering a carriage return in the input.

Found by jsg@@ a long time ago in a respository far, far away.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.29 2014/05/05 18:02:49 krw Exp $	*/
d150 2
a152 2
			lexline = l;
			lexchar = p;
a156 2
			lexline = l;
			lexchar = p;
a159 2
			lexline = l;
			lexchar = p;
a162 2
			lexline = l;
			lexchar = p;
@


1.29
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.28 2014/01/19 03:54:25 krw Exp $	*/
d110 2
a111 2
				cur_line = line2;
				prev_line = line1;
@


1.28
log
@Adjust lexchar position by ugflag once only.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.27 2014/01/18 01:41:28 krw Exp $	*/
d136 1
a136 1
	
@


1.27
log
@If ugflag (indicating a character from the file being parsed has been
unget()'ed) is set, then properly set the lexchar position back one in
get_token() so more error messages put the '^' in the proper spot.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.26 2013/12/18 00:37:59 krw Exp $	*/
d133 1
a133 1
	int		l, p;
d135 2
d139 2
a140 1
		p = lpos - ugflag;
@


1.26
log
@Code existed to print non-printable characters in strings written
to the leases file. No code existed to correctly read back the
strings so written.

Redo both sides and use vis()/strnunvis() instead of handrolling
more parsing. As a side-effect allow embedded NUL characters rather
than skipping them.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.25 2013/12/05 22:31:35 krw Exp $	*/
d137 1
a137 1
		p = lpos;
@


1.25
log
@Stop pretending we still support FDDI or token ring hardware types.

idea ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.24 2013/11/12 04:59:00 deraadt Exp $	*/
d46 2
d65 1
d241 4
d246 6
a251 2
	do {
		c = get_char(cfile);
d257 6
a262 4
		if (c != '"' && c != EOF && bs == 0)
			tokbuf[i++] = c;

	} while (i < (sizeof(tokbuf) - 1) && c != EOF && c != '"');
d266 2
a267 2
	else if (c != '"')
		parse_warn("string constant larger than internal buffer");
a268 1
	tokbuf[i] = 0;
@


1.24
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.23 2013/10/22 18:15:58 krw Exp $	*/
a328 1
	{ "fddi",				TOK_FDDI },
d353 1
a353 2
	{ "timeout",				TOK_TIMEOUT },
	{ "token-ring",				TOK_TOKEN_RING }
@


1.23
log
@Save 'next-server' (a.k.a. siaddr) info in leases file. Saving the
file name without the server address seems silly.

Tested & ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.22 2013/06/09 01:51:58 krw Exp $	*/
d357 2
@


1.22
log
@Add back backslash fixes caught in rollback.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.21 2013/06/09 00:30:06 krw Exp $	*/
d340 1
@


1.21
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.20 2013/06/04 13:00:07 krw Exp $	*/
d236 1
a236 1
	int	i, c, bs = 0;
d238 2
a239 1
	for (i = 0; i < sizeof(tokbuf); i++) {
d241 1
a241 5
		if (c == EOF) {
			parse_warn("eof in string constant");
			break;
		}
		if (bs) {
d243 1
a243 2
			tokbuf[i] = c;
		} else if (c == '\\')
d245 9
a253 10
		else if (c == '"')
			break;
		else
			tokbuf[i] = c;
	}
	/*
	 * Normally, I'd feel guilty about this, but we're talking about
	 * strings that'll fit in a DHCP packet here.
	 */
	if (i == sizeof(tokbuf)) {
d255 1
a255 2
		i--;
	}
d258 1
@


1.20
log
@Fix "\" escape handling in read_string().

Problem noted, fix tested and ok sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.19 2013/05/02 16:35:27 krw Exp $	*/
d236 1
a236 1
	int i, c, bs;
d238 1
a238 2
	bs = i = 0;
	do {
d240 5
a244 1
		if (bs)
d246 2
a247 1
		else if (c == '\\')
d249 10
a258 9

		if (c != '"' && c != EOF && bs == 0)
			tokbuf[i++] = c;

	} while (i < (sizeof(tokbuf) - 1) && c != EOF && c != '"');

	if (c == EOF)
		parse_warn("eof in string constant");
	else if (c != '"')
d260 2
a261 1

a263 1

@


1.19
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.18 2012/11/15 14:54:18 krw Exp $	*/
d236 1
a236 1
	int	i, c, bs = 0;
d238 2
a239 1
	for (i = 0; i < sizeof(tokbuf); i++) {
d241 1
a241 5
		if (c == EOF) {
			parse_warn("eof in string constant");
			break;
		}
		if (bs) {
d243 1
a243 2
			tokbuf[i] = c;
		} else if (c == '\\')
d245 9
a253 10
		else if (c == '"')
			break;
		else
			tokbuf[i] = c;
	}
	/*
	 * Normally, I'd feel guilty about this, but we're talking about
	 * strings that'll fit in a DHCP packet here.
	 */
	if (i == sizeof(tokbuf)) {
d255 1
a255 2
		i--;
	}
d258 1
@


1.18
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.17 2012/11/07 15:20:28 krw Exp $	*/
d3 1
a3 1
/* Lexical scanner for dhclient config file... */
d256 1
a256 1
	 * strings that'll fit in a DHCP packet here...
@


1.17
log
@Use memset() consistently rather than tossing in a few bzero()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.16 2012/10/30 18:39:44 krw Exp $	*/
a41 2

#include <ctype.h>
@


1.16
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.15 2012/08/22 00:14:42 tedu Exp $	*/
d82 3
a84 3
	bzero(line1, sizeof(line1));
	bzero(line2, sizeof(line2));
	bzero(tokbuf, sizeof(tokbuf));
@


1.15
log
@add ignore keyword to conf file, allowing one to ignore unwanted info
from the server without necessarily speciyfing a supersede value
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.14 2011/12/10 17:36:40 krw Exp $	*/
a355 1
	{ "script",				TOK_SCRIPT },
@


1.14
log
@Try harder to re-initialize parsing state so nothing accidentally
carries over when a new file (i.e. leases after config) is parsed.
May help with mysterious "Corrupt lease file" messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.13 2006/12/17 17:41:56 stevesk Exp $	*/
d340 1
@


1.13
log
@fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.12 2006/05/08 17:25:59 deraadt Exp $	*/
d77 9
a85 1
	tlname = name;
d87 4
d94 2
a95 1
	cur_line[0] = prev_line[0] = 0;
@


1.12
log
@add 'link-timeout n' seconds option to grammer, from fkr@@hazardous.org
default remains 10 seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.11 2006/04/18 19:17:54 deraadt Exp $	*/
d3 1
a3 1
/* Lexical scanner for dhcpd config file... */
@


1.11
log
@cleanup keyword lookup for the lexer, and remove keywords not valid in
either dhclient or dhcpd context; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.10 2005/08/02 18:26:49 moritz Exp $	*/
d330 1
@


1.10
log
@add missing break; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.9 2005/07/26 19:14:57 krw Exp $	*/
d253 1
a253 1
	return (STRING);
d259 1
a259 1
	int	seenx = 0, i = 0, token = NUMBER;
d287 1
a287 1
	int	rv = NUMBER_OR_NAME;
d298 1
a298 1
			rv = NAME;
d311 45
d359 1
a359 2
	if (!isascii(atom[0]))
		return (dfv);
d361 4
a364 207
	switch (tolower(atom[0])) {
	case 'a':
		if (!strcasecmp(atom + 1, "lways-reply-rfc1048"))
			return (ALWAYS_REPLY_RFC1048);
		if (!strcasecmp(atom + 1, "ppend"))
			return (APPEND);
		if (!strcasecmp(atom + 1, "llow"))
			return (ALLOW);
		if (!strcasecmp(atom + 1, "lias"))
			return (ALIAS);
		if (!strcasecmp(atom + 1, "bandoned"))
			return (ABANDONED);
		if (!strcasecmp(atom + 1, "uthoritative"))
			return (AUTHORITATIVE);
		break;
	case 'b':
		if (!strcasecmp(atom + 1, "ackoff-cutoff"))
			return (BACKOFF_CUTOFF);
		if (!strcasecmp(atom + 1, "ootp"))
			return (BOOTP);
		if (!strcasecmp(atom + 1, "ooting"))
			return (BOOTING);
		if (!strcasecmp(atom + 1, "oot-unknown-clients"))
			return (BOOT_UNKNOWN_CLIENTS);
		break;
	case 'c':
		if (!strcasecmp(atom + 1, "lass"))
			return (CLASS);
		if (!strcasecmp(atom + 1, "iaddr"))
			return (CIADDR);
		if (!strcasecmp(atom + 1, "lient-identifier"))
			return (CLIENT_IDENTIFIER);
		if (!strcasecmp(atom + 1, "lient-hostname"))
			return (CLIENT_HOSTNAME);
		break;
	case 'd':
		if (!strcasecmp(atom + 1, "omain"))
			return (DOMAIN);
		if (!strcasecmp(atom + 1, "eny"))
			return (DENY);
		if (!strncasecmp(atom + 1, "efault", 6)) {
			if (!atom[7])
				return (DEFAULT);
			if (!strcasecmp(atom + 7, "-lease-time"))
				return (DEFAULT_LEASE_TIME);
			break;
		}
		if (!strncasecmp(atom + 1, "ynamic-bootp", 12)) {
			if (!atom[13])
				return (DYNAMIC_BOOTP);
			if (!strcasecmp(atom + 13, "-lease-cutoff"))
				return (DYNAMIC_BOOTP_LEASE_CUTOFF);
			if (!strcasecmp(atom + 13, "-lease-length"))
				return (DYNAMIC_BOOTP_LEASE_LENGTH);
			break;
		}
		break;
	case 'e':
		if (!strcasecmp(atom + 1, "thernet"))
			return (ETHERNET);
		if (!strcasecmp(atom + 1, "nds"))
			return (ENDS);
		if (!strcasecmp(atom + 1, "xpire"))
			return (EXPIRE);
		break;
	case 'f':
		if (!strcasecmp(atom + 1, "ilename"))
			return (FILENAME);
		if (!strcasecmp(atom + 1, "ixed-address"))
			return (FIXED_ADDR);
		if (!strcasecmp(atom + 1, "ddi"))
			return (FDDI);
		break;
	case 'g':
		if (!strcasecmp(atom + 1, "iaddr"))
			return (GIADDR);
		if (!strcasecmp(atom + 1, "roup"))
			return (GROUP);
		if (!strcasecmp(atom + 1, "et-lease-hostnames"))
			return (GET_LEASE_HOSTNAMES);
		break;
	case 'h':
		if (!strcasecmp(atom + 1, "ost"))
			return (HOST);
		if (!strcasecmp(atom + 1, "ardware"))
			return (HARDWARE);
		if (!strcasecmp(atom + 1, "ostname"))
			return (HOSTNAME);
		break;
	case 'i':
		if (!strcasecmp(atom + 1, "nitial-interval"))
			return (INITIAL_INTERVAL);
		if (!strcasecmp(atom + 1, "nterface"))
			return (INTERFACE);
		break;
	case 'l':
		if (!strcasecmp(atom + 1, "ease"))
			return (LEASE);
		break;
	case 'm':
		if (!strcasecmp(atom + 1, "ax-lease-time"))
			return (MAX_LEASE_TIME);
		if (!strncasecmp(atom + 1, "edi", 3)) {
			if (!strcasecmp(atom + 4, "a"))
				return (MEDIA);
			if (!strcasecmp(atom + 4, "um"))
				return (MEDIUM);
			break;
		}
		break;
	case 'n':
		if (!strcasecmp(atom + 1, "ameserver"))
			return (NAMESERVER);
		if (!strcasecmp(atom + 1, "etmask"))
			return (NETMASK);
		if (!strcasecmp(atom + 1, "ext-server"))
			return (NEXT_SERVER);
		if (!strcasecmp(atom + 1, "ot"))
			return (TOKEN_NOT);
		break;
	case 'o':
		if (!strcasecmp(atom + 1, "ption"))
			return (OPTION);
		if (!strcasecmp(atom + 1, "ne-lease-per-client"))
			return (ONE_LEASE_PER_CLIENT);
		break;
	case 'p':
		if (!strcasecmp(atom + 1, "repend"))
			return (PREPEND);
		if (!strcasecmp(atom + 1, "acket"))
			return (PACKET);
		break;
	case 'r':
		if (!strcasecmp(atom + 1, "ange"))
			return (RANGE);
		if (!strcasecmp(atom + 1, "equest"))
			return (REQUEST);
		if (!strcasecmp(atom + 1, "equire"))
			return (REQUIRE);
		if (!strcasecmp(atom + 1, "etry"))
			return (RETRY);
		if (!strcasecmp(atom + 1, "enew"))
			return (RENEW);
		if (!strcasecmp(atom + 1, "ebind"))
			return (REBIND);
		if (!strcasecmp(atom + 1, "eboot"))
			return (REBOOT);
		if (!strcasecmp(atom + 1, "eject"))
			return (REJECT);
		break;
	case 's':
		if (!strcasecmp(atom + 1, "earch"))
			return (SEARCH);
		if (!strcasecmp(atom + 1, "tarts"))
			return (STARTS);
		if (!strcasecmp(atom + 1, "iaddr"))
			return (SIADDR);
		if (!strcasecmp(atom + 1, "ubnet"))
			return (SUBNET);
		if (!strcasecmp(atom + 1, "hared-network"))
			return (SHARED_NETWORK);
		if (!strcasecmp(atom + 1, "erver-name"))
			return (SERVER_NAME);
		if (!strcasecmp(atom + 1, "erver-identifier"))
			return (SERVER_IDENTIFIER);
		if (!strcasecmp(atom + 1, "elect-timeout"))
			return (SELECT_TIMEOUT);
		if (!strcasecmp(atom + 1, "end"))
			return (SEND);
		if (!strcasecmp(atom + 1, "cript"))
			return (SCRIPT);
		if (!strcasecmp(atom + 1, "upersede"))
			return (SUPERSEDE);
		break;
	case 't':
		if (!strcasecmp(atom + 1, "imestamp"))
			return (TIMESTAMP);
		if (!strcasecmp(atom + 1, "imeout"))
			return (TIMEOUT);
		if (!strcasecmp(atom + 1, "oken-ring"))
			return (TOKEN_RING);
		break;
	case 'u':
		if (!strncasecmp(atom + 1, "se", 2)) {
			if (!strcasecmp(atom + 3, "r-class"))
				return (USER_CLASS);
			if (!strcasecmp(atom + 3, "-host-decl-names"))
				return (USE_HOST_DECL_NAMES);
			if (!strcasecmp(atom + 3,
					 "-lease-addr-for-default-route"))
				return (USE_LEASE_ADDR_FOR_DEFAULT_ROUTE);
			break;
		}
		if (!strcasecmp(atom + 1, "id"))
			return (UID);
		if (!strcasecmp(atom + 1, "nknown-clients"))
			return (UNKNOWN_CLIENTS);
		break;
	case 'v':
		if (!strcasecmp(atom + 1, "endor-class"))
			return (VENDOR_CLASS);
		break;
	case 'y':
		if (!strcasecmp(atom + 1, "iaddr"))
			return (YIADDR);
		break;
	}
@


1.9
log
@Fix buffer overflows in dhcpd and dhclient. Closes PR#4306.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.8 2005/07/09 16:16:11 krw Exp $	*/
d341 1
@


1.8
log
@Clean out a few more unused/uninitialized variables.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.7 2004/09/15 19:02:38 deraadt Exp $	*/
d103 1
a103 1
			if (lpos <= 81) {
@


1.7
log
@variable set but not used
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.6 2004/02/24 13:08:26 henning Exp $	*/
a53 1
int eol_token;
d127 1
a127 1
		if (!(c == '\n' && eol_token) && isascii(c) && isspace(c))
@


1.6
log
@cut more crap - no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.5 2004/02/07 11:35:59 henning Exp $	*/
d120 1
a120 1
	int		l, p, u;
a124 1
		u = ugflag;
@


1.5
log
@more style fixes from Emil Mikulic <emikulic@@dmr.ath.cx>
Thank you very much for this excellent work, it helps a lot.
binary unchanged.
I am still convinced dhclient can be made readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: conflex.c,v 1.4 2004/02/04 12:16:56 henning Exp $	*/
d92 1
a92 1
		if (c == EOL) {
d219 1
a219 1
		if (c == EOL)
@


1.4
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 2
a46 1
#include <ctype.h>
d90 1
a90 1
	int	c = getc (cfile);
d112 1
a112 1
	return c;
d127 1
a127 1
		c = get_char (cfile);
d161 1
a161 1
	return ttok;
d245 4
a248 2
	/* Normally, I'd feel guilty about this, but we're talking about
	   strings that'll fit in a DHCP packet here... */
d251 1
a251 1
		--i;
d277 1
a277 1
		--i;
d305 1
a305 1
		--i;
d317 1
a317 1
		return dfv;
d420 1
a420 1
		if (!strncasecmp (atom + 1, "edi", 3)) {
d501 1
a501 1
		if (!strncasecmp (atom + 1, "se", 2)) {
@


1.3
log
@more KNF
@
text
@d1 1
a1 1
/* conflex.c
d3 1
a3 1
   Lexical scanner for dhcpd config file... */
@


1.2
log
@8579 lines of KNF, ANSO and zap-junk diff without the resulting binary
changing by a single byte.
partly from theo
@
text
@d92 1
a92 1
			if (cur_line == line1) {	
d111 1
a111 1
	return c;		
d115 1
a115 1
get_token (FILE *cfile)
d273 1
a273 1
		parse_warn ("numeric token larger than internal buffer");
d283 1
a283 1
read_num_or_name (int c, FILE *cfile)
d316 1
a316 1
	switch(tolower(atom[0])) {
@


1.1
log
@this is where dhclient will start surgery
@
text
@d55 2
a56 2
static char line1 [81];
static char line2 [81];
d64 1
a64 1
static char tokbuf [1500];
d66 7
a72 13
#ifdef OLD_LEXER
char comments [4096];
int comment_index;
#endif


static int get_char PROTO ((FILE *));
static int get_token PROTO ((FILE *));
static void skip_to_eol PROTO ((FILE *));
static int read_string PROTO ((FILE *));
static int read_number PROTO ((int, FILE *));
static int read_num_or_name PROTO ((int, FILE *));
static int intern PROTO ((char *, int));
d74 2
a75 2
void new_parse (name)
	char *name;
d82 1
a82 1
	cur_line [0] = prev_line [0] = 0;
d86 2
a87 2
static int get_char (cfile)
	FILE *cfile;
d89 1
a89 1
	int c = getc (cfile);
d101 1
a101 1
			cur_line [0] = 0;
d104 2
a105 2
				cur_line [lpos - 1] = c;
				cur_line [lpos] = 0;
d114 2
a115 2
static int get_token (cfile)
	FILE *cfile;
d117 3
a119 4
	int c;
	int ttok;
	static char tb [2];
	int l, p, u;
d128 1
a128 1
		if (!(c == '\n' && eol_token) && isascii (c) && isspace (c))
d131 1
a131 1
			skip_to_eol (cfile);
d137 1
a137 1
			ttok = read_string (cfile);
d140 1
a140 1
		if ((isascii (c) && isdigit (c)) || c == '-') {
d143 1
a143 1
			ttok = read_number (c, cfile);
d145 1
a145 1
		} else if (isascii (c) && isalpha (c)) {
d148 1
a148 1
			ttok = read_num_or_name (c, cfile);
d153 2
a154 2
			tb [0] = c;
			tb [1] = 0;
d163 2
a164 3
int next_token (rval, cfile)
	char **rval;
	FILE *cfile;
d166 1
a166 1
	int rv;
d176 1
a176 1
		rv = get_token (cfile);
d181 2
a182 4
#ifdef DEBUG_TOKENS
	fprintf (stderr, "%s:%d ", tval, rv);
#endif
	return rv;
d185 2
a186 3
int peek_token (rval, cfile)
	char **rval;
	FILE *cfile;
d188 1
a188 1
	int x;
d193 1
a193 1
		token = get_token (cfile);
d196 6
a201 2
		x = lexchar; lexchar = tlpos; tlpos = x;
		x = lexline; lexline = tline; tline = x;
d205 2
a206 4
#ifdef DEBUG_TOKENS
	fprintf (stderr, "(%s:%d) ", tval, token);
#endif
	return token;
d209 2
a210 2
static void skip_to_eol (cfile)
	FILE *cfile;
d212 2
a213 1
	int c;
d215 1
a215 1
		c = get_char (cfile);
d223 2
a224 2
static int read_string (cfile)
	FILE *cfile;
d226 1
a226 3
	int i;
	int bs = 0;
	int c;
d228 2
a229 2
	for (i = 0; i < sizeof tokbuf; i++) {
		c = get_char (cfile);
d231 1
a231 1
			parse_warn ("eof in string constant");
d236 1
a236 1
			tokbuf [i] = c;
d242 1
a242 1
			tokbuf [i] = c;
d246 2
a247 2
	if (i == sizeof tokbuf) {
		parse_warn ("string constant larger than internal buffer");
d250 1
a250 1
	tokbuf [i] = 0;
d252 1
a252 1
	return STRING;
d255 2
a256 3
static int read_number (c, cfile)
	int c;
	FILE *cfile;
d258 1
a258 3
	int seenx = 0;
	int i = 0;
	int token = NUMBER;
d260 4
a263 4
	tokbuf [i++] = c;
	for (; i < sizeof tokbuf; i++) {
		c = get_char (cfile);
		if (!seenx && c == 'x') {
d265 2
a266 2
		} else if (!isascii (c) || !isxdigit (c)) {
			ungetc (c, cfile);
d270 1
a270 1
		tokbuf [i] = c;
d272 1
a272 1
	if (i == sizeof tokbuf) {
d276 1
a276 1
	tokbuf [i] = 0;
d278 2
a279 1
	return token;
d282 2
a283 3
static int read_num_or_name (c, cfile)
	int c;
	FILE *cfile;
d285 8
a292 8
	int i = 0;
	int rv = NUMBER_OR_NAME;
	tokbuf [i++] = c;
	for (; i < sizeof tokbuf; i++) {
		c = get_char (cfile);
		if (!isascii (c) ||
		    (c != '-' && c != '_' && !isalnum (c))) {
			ungetc (c, cfile);
d296 1
a296 1
		if (!isxdigit (c))
d298 1
a298 1
		tokbuf [i] = c;
d300 2
a301 2
	if (i == sizeof tokbuf) {
		parse_warn ("token larger than internal buffer");
d304 1
a304 1
	tokbuf [i] = 0;
d306 2
a307 1
	return intern (tval, rv);
d310 2
a311 3
static int intern (atom, dfv)
	char *atom;
	int dfv;
d313 1
a313 1
	if (!isascii (atom [0]))
d316 101
a416 101
	switch (tolower (atom [0])) {
	      case 'a':
		if (!strcasecmp (atom + 1, "lways-reply-rfc1048"))
			return ALWAYS_REPLY_RFC1048;
		if (!strcasecmp (atom + 1, "ppend"))
			return APPEND;
		if (!strcasecmp (atom + 1, "llow"))
			return ALLOW;
		if (!strcasecmp (atom + 1, "lias"))
			return ALIAS;
		if (!strcasecmp (atom + 1, "bandoned"))
			return ABANDONED;
		if (!strcasecmp (atom + 1, "uthoritative"))
			return AUTHORITATIVE;
		break;
	      case 'b':
		if (!strcasecmp (atom + 1, "ackoff-cutoff"))
			return BACKOFF_CUTOFF;
		if (!strcasecmp (atom + 1, "ootp"))
			return BOOTP;
		if (!strcasecmp (atom + 1, "ooting"))
			return BOOTING;
		if (!strcasecmp (atom + 1, "oot-unknown-clients"))
			return BOOT_UNKNOWN_CLIENTS;
	      case 'c':
		if (!strcasecmp (atom + 1, "lass"))
			return CLASS;
		if (!strcasecmp (atom + 1, "iaddr"))
			return CIADDR;
		if (!strcasecmp (atom + 1, "lient-identifier"))
			return CLIENT_IDENTIFIER;
		if (!strcasecmp (atom + 1, "lient-hostname"))
			return CLIENT_HOSTNAME;
		break;
	      case 'd':
		if (!strcasecmp (atom + 1, "omain"))
			return DOMAIN;
		if (!strcasecmp (atom + 1, "eny"))
			return DENY;
		if (!strncasecmp (atom + 1, "efault", 6)) {
			if (!atom [7])
				return DEFAULT;
			if (!strcasecmp (atom + 7, "-lease-time"))
				return DEFAULT_LEASE_TIME;
			break;
		}
		if (!strncasecmp (atom + 1, "ynamic-bootp", 12)) {
			if (!atom [13])
				return DYNAMIC_BOOTP;
			if (!strcasecmp (atom + 13, "-lease-cutoff"))
				return DYNAMIC_BOOTP_LEASE_CUTOFF;
			if (!strcasecmp (atom + 13, "-lease-length"))
				return DYNAMIC_BOOTP_LEASE_LENGTH;
			break;
		}
		break;
	      case 'e':
		if (!strcasecmp (atom + 1, "thernet"))
			return ETHERNET;
		if (!strcasecmp (atom + 1, "nds"))
			return ENDS;
		if (!strcasecmp (atom + 1, "xpire"))
			return EXPIRE;
		break;
	      case 'f':
		if (!strcasecmp (atom + 1, "ilename"))
			return FILENAME;
		if (!strcasecmp (atom + 1, "ixed-address"))
			return FIXED_ADDR;
		if (!strcasecmp (atom + 1, "ddi"))
			return FDDI;
		break;
	      case 'g':
		if (!strcasecmp (atom + 1, "iaddr"))
			return GIADDR;
		if (!strcasecmp (atom + 1, "roup"))
			return GROUP;
		if (!strcasecmp (atom + 1, "et-lease-hostnames"))
			return GET_LEASE_HOSTNAMES;
		break;
	      case 'h':
		if (!strcasecmp (atom + 1, "ost"))
			return HOST;
		if (!strcasecmp (atom + 1, "ardware"))
			return HARDWARE;
		if (!strcasecmp (atom + 1, "ostname"))
			return HOSTNAME;
		break;
	      case 'i':
		if (!strcasecmp (atom + 1, "nitial-interval"))
			return INITIAL_INTERVAL;
		if (!strcasecmp (atom + 1, "nterface"))
			return INTERFACE;
		break;
	      case 'l':
		if (!strcasecmp (atom + 1, "ease"))
			return LEASE;
		break;
	      case 'm':
		if (!strcasecmp (atom + 1, "ax-lease-time"))
			return MAX_LEASE_TIME;
d418 78
a495 78
			if (!strcasecmp (atom + 4, "a"))
				return MEDIA;
			if (!strcasecmp (atom + 4, "um"))
				return MEDIUM;
			break;
		}
		break;
	      case 'n':
		if (!strcasecmp (atom + 1, "ameserver"))
			return NAMESERVER;
		if (!strcasecmp (atom + 1, "etmask"))
			return NETMASK;
		if (!strcasecmp (atom + 1, "ext-server"))
			return NEXT_SERVER;
		if (!strcasecmp (atom + 1, "ot"))
			return TOKEN_NOT;
		break;
	      case 'o':
		if (!strcasecmp (atom + 1, "ption"))
			return OPTION;
		if (!strcasecmp (atom + 1, "ne-lease-per-client"))
			return ONE_LEASE_PER_CLIENT;
		break;
	      case 'p':
		if (!strcasecmp (atom + 1, "repend"))
			return PREPEND;
		if (!strcasecmp (atom + 1, "acket"))
			return PACKET;
		break;
	      case 'r':
		if (!strcasecmp (atom + 1, "ange"))
			return RANGE;
		if (!strcasecmp (atom + 1, "equest"))
			return REQUEST;
		if (!strcasecmp (atom + 1, "equire"))
			return REQUIRE;
		if (!strcasecmp (atom + 1, "etry"))
			return RETRY;
		if (!strcasecmp (atom + 1, "enew"))
			return RENEW;
		if (!strcasecmp (atom + 1, "ebind"))
			return REBIND;
		if (!strcasecmp (atom + 1, "eboot"))
			return REBOOT;
		if (!strcasecmp (atom + 1, "eject"))
			return REJECT;
		break;
	      case 's':
		if (!strcasecmp (atom + 1, "earch"))
			return SEARCH;
		if (!strcasecmp (atom + 1, "tarts"))
			return STARTS;
		if (!strcasecmp (atom + 1, "iaddr"))
			return SIADDR;
		if (!strcasecmp (atom + 1, "ubnet"))
			return SUBNET;
		if (!strcasecmp (atom + 1, "hared-network"))
			return SHARED_NETWORK;
		if (!strcasecmp (atom + 1, "erver-name"))
			return SERVER_NAME;
		if (!strcasecmp (atom + 1, "erver-identifier"))
			return SERVER_IDENTIFIER;
		if (!strcasecmp (atom + 1, "elect-timeout"))
			return SELECT_TIMEOUT;
		if (!strcasecmp (atom + 1, "end"))
			return SEND;
		if (!strcasecmp (atom + 1, "cript"))
			return SCRIPT;
		if (!strcasecmp (atom + 1, "upersede"))
			return SUPERSEDE;
		break;
	      case 't':
		if (!strcasecmp (atom + 1, "imestamp"))
			return TIMESTAMP;
		if (!strcasecmp (atom + 1, "imeout"))
			return TIMEOUT;
		if (!strcasecmp (atom + 1, "oken-ring"))
			return TOKEN_RING;
d497 1
a497 1
	      case 'u':
d499 5
a503 5
			if (!strcasecmp (atom + 3, "r-class"))
				return USER_CLASS;
			if (!strcasecmp (atom + 3, "-host-decl-names"))
				return USE_HOST_DECL_NAMES;
			if (!strcasecmp (atom + 3,
d505 1
a505 1
				return USE_LEASE_ADDR_FOR_DEFAULT_ROUTE;
d508 4
a511 4
		if (!strcasecmp (atom + 1, "id"))
			return UID;
		if (!strcasecmp (atom + 1, "nknown-clients"))
			return UNKNOWN_CLIENTS;
d513 3
a515 3
	      case 'v':
		if (!strcasecmp (atom + 1, "endor-class"))
			return VENDOR_CLASS;
d517 3
a519 3
	      case 'y':
		if (!strcasecmp (atom + 1, "iaddr"))
			return YIADDR;
d522 1
a522 1
	return dfv;
@

