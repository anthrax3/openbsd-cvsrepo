head	1.58;
access;
symbols
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.8
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.6
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.10
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.8
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.58
date	2017.07.21.18.57.55;	author krw;	state Exp;
branches;
next	1.57;
commitid	jKsjPeE2L2H4ksIK;

1.57
date	2017.07.14.16.21.03;	author krw;	state Exp;
branches;
next	1.56;
commitid	MneUE6JB4herdkKT;

1.56
date	2017.07.10.14.11.47;	author krw;	state Exp;
branches;
next	1.55;
commitid	zPfpB13LVx1r8eha;

1.55
date	2017.07.07.15.39.30;	author krw;	state Exp;
branches;
next	1.54;
commitid	mAXBZAHTo5c00SKV;

1.54
date	2017.07.02.09.11.13;	author krw;	state Exp;
branches;
next	1.53;
commitid	dsBHBUGhFvB0Vfsu;

1.53
date	2017.07.01.23.27.56;	author krw;	state Exp;
branches;
next	1.52;
commitid	UWIW511YvInk5uK6;

1.52
date	2017.06.28.16.31.52;	author krw;	state Exp;
branches;
next	1.51;
commitid	78CHyOkgKoAWELkJ;

1.51
date	2017.06.28.14.35.43;	author krw;	state Exp;
branches;
next	1.50;
commitid	3nygEKTzwCipdpn4;

1.50
date	2017.06.24.23.32.57;	author krw;	state Exp;
branches;
next	1.49;
commitid	kMjmTgmAjjj8SVH3;

1.49
date	2017.06.24.10.09.26;	author krw;	state Exp;
branches;
next	1.48;
commitid	9Mm9vI6emJNtny4z;

1.48
date	2017.06.23.16.18.02;	author krw;	state Exp;
branches;
next	1.47;
commitid	NZxzlReUkKpubgaw;

1.47
date	2017.06.23.15.40.56;	author krw;	state Exp;
branches;
next	1.46;
commitid	2V1Vp5y5sN8YqgCW;

1.46
date	2017.04.10.21.47.44;	author krw;	state Exp;
branches;
next	1.45;
commitid	ubZF40SEC22PLlgj;

1.45
date	2017.03.08.19.43.42;	author krw;	state Exp;
branches;
next	1.44;
commitid	X7sEtrF3eRfzuAcx;

1.44
date	2017.02.12.15.53.15;	author krw;	state Exp;
branches;
next	1.43;
commitid	YTCiHbXKpxvNuYuw;

1.43
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.42;
commitid	IDlzr3qamZK5lxzj;

1.42
date	2016.09.02.15.44.26;	author mpi;	state Exp;
branches;
next	1.41;
commitid	GuoxNV4NXpbUVBHj;

1.41
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.40;
commitid	Tm7CrlqCKqgQoJ7P;

1.40
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.39;
commitid	5ELOU0S0Zl3aCrHG;

1.39
date	2015.02.07.10.08.06;	author krw;	state Exp;
branches;
next	1.38;
commitid	DyjrY1dcWE4nZyJh;

1.38
date	2015.02.06.09.16.06;	author reyk;	state Exp;
branches;
next	1.37;
commitid	vYyCsIthQQMdADc1;

1.37
date	2014.10.27.13.36.21;	author krw;	state Exp;
branches;
next	1.36;
commitid	18JJKpLCJZeJyulS;

1.36
date	2014.02.09.14.21.17;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.20.09.16.36;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.09.15.06.34;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.01.16.26.07;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.30.16.10.01;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.27.02.45.46;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.15.21.44.28;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2012.12.29.14.40.01;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.04.19.24.03;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.02.17.03.19;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.14.15.47.41;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2012.11.04.03.44.48;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.04.03.36.39;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.04.03.25.31;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.03.16.54.34;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.04.11.14.52;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.06.04.02.42;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.15.15.22.27;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.14.23.19.26;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.07.13.19.40;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.08.14.33.46;	author moritz;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.07.01.35.11;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.04.14.21.04;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.02.15.04.25;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.10.18.34.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.04.19.56.18;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.04.18.51.18;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.04.18.49.52;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.04.18.14.51;	author canacar;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.04.12.52.05;	author henning;	state Exp;
branches;
next	;


desc
@@


1.58
log
@s/set_interface_mtu/set_mtu/g
@
text
@/*	$OpenBSD: privsep.c,v 1.57 2017/07/14 16:21:03 krw Exp $ */

/*
 * Copyright (c) 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE, ABUSE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <errno.h>
#include <imsg.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"
#include "privsep.h"

int
dispatch_imsg(char *name, int rdomain, int ioctlfd, int routefd,
    struct imsgbuf *ibuf)
{
	struct imsg	imsg;
	ssize_t		n;

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("dispatch_imsg: imsg_get failure");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DELETE_ADDRESS:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_delete_address))
				log_warnx("bad IMSG_DELETE_ADDRESS");
			else
				priv_delete_address(name, ioctlfd, imsg.data);
			break;

		case IMSG_ADD_ADDRESS:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_add_address))
				log_warnx("bad IMSG_ADD_ADDRESS");
			else
				priv_add_address(name, ioctlfd, imsg.data);
			break;

		case IMSG_FLUSH_ROUTES:
			if (imsg.hdr.len != IMSG_HEADER_SIZE)
				log_warnx("bad IMSG_FLUSH_ROUTES");
			else
				priv_flush_routes(name, routefd, rdomain);
			break;

		case IMSG_ADD_ROUTE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_add_route))
				log_warnx("bad IMSG_ADD_ROUTE");
			else
				priv_add_route(rdomain, routefd, imsg.data);
			break;

		case IMSG_SET_MTU:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_set_mtu))
				log_warnx("bad IMSG_SET_MTU");
			else
				priv_set_mtu(name, ioctlfd, imsg.data);
			break;

		case IMSG_WRITE_RESOLV_CONF:
			if (imsg.hdr.len <= IMSG_HEADER_SIZE)
				log_warnx("short IMSG_WRITE_RESOLV_CONF");
			else if (resolv_conf_priority(rdomain, routefd) != 0)
				priv_write_resolv_conf(imsg.data,
				    imsg.hdr.len - IMSG_HEADER_SIZE);
			break;

		case IMSG_HUP:
			if (imsg.hdr.len != IMSG_HEADER_SIZE)
				log_warnx("bad IMSG_HUP");
			else {
				imsg_free(&imsg);
				return 1;
			}
			break;

		default:
			log_warnx("received unknown message, code %u",
			    imsg.hdr.type);
		}

		imsg_free(&imsg);
	}
	return 0;
}
@


1.57
log
@Replace remaining "!var" expressions with
"<var> == 0", "!(<var> & FLAG)" with
"(<var> & FLAG) == 0", "!<func()>"
with "<func()> == 0" and "!<define>" with
"<define> == 0". And the positive cases
as well.

A few stray == NULL and != NULL as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.56 2017/07/10 14:11:47 krw Exp $ */
d84 1
a84 1
		case IMSG_SET_INTERFACE_MTU:
d86 2
a87 2
			    sizeof(struct imsg_set_interface_mtu))
				log_warnx("bad IMSG_SET_INTERFACE_MTU");
d89 1
a89 2
				priv_set_interface_mtu(name, ioctlfd,
				    imsg.data);
@


1.56
log
@Use ioctlfd/routefd sockets rather than rolling one's own
for resolving 'egress' and adding a route. Move creation
of main()'s ioctlfd up so it can be used for the
'egress' resolution.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.55 2017/07/07 15:39:30 krw Exp $ */
d96 1
a96 1
			else if (resolv_conf_priority(rdomain, routefd))
@


1.55
log
@dispatch_imsg() only needs to know name and rdomain.

No more struct interface_info knowledge in privsep.[ch]
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.54 2017/07/02 09:11:13 krw Exp $ */
d81 1
a81 1
				priv_add_route(rdomain, imsg.data);
@


1.54
log
@Unbreak tree by putting revised resolv_conf_priority() declaration in
correct place and passing the invocation the correct parameters.

Noticed by & initial diff from matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.53 2017/07/01 23:27:56 krw Exp $ */
d39 1
a39 1
dispatch_imsg(struct interface_info *ifi, int ioctlfd, int routefd,
d58 1
a58 2
				priv_delete_address(ifi->name, ioctlfd,
				    imsg.data);
d66 1
a66 1
				priv_add_address(ifi->name, ioctlfd, imsg.data);
d73 1
a73 2
				priv_flush_routes(ifi->name, routefd,
				    ifi->rdomain);
d81 1
a81 1
				priv_add_route(ifi->rdomain, imsg.data);
d89 1
a89 1
				priv_set_interface_mtu(ifi->name, ioctlfd,
d96 1
a96 1
			else if (resolv_conf_priority(ifi->rdomain, routefd))
@


1.53
log
@Eliminate multiple socket openings/closings and pass
fd'd from main loops as required. One socket to do
ioctl's per process (called ioctlfd) and one socket to
do route messages per socket (called routefd).

Clean up local variable declaration lists in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.52 2017/06/28 16:31:52 krw Exp $ */
d98 1
a98 1
			else if (resolv_conf_priority(ifi->rdomain))
@


1.52
log
@Only pass required fields of interface_info to priv_* functions
and friends. i.e. ifi->name, ifi->rdomain, or both.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.51 2017/06/28 14:35:43 krw Exp $ */
d39 2
a40 1
dispatch_imsg(struct interface_info *ifi, struct imsgbuf *ibuf)
d42 2
a43 2
	struct imsg			 imsg;
	ssize_t				 n;
d58 2
a59 1
				priv_delete_address(ifi->name, imsg.data);
d67 1
a67 1
				priv_add_address(ifi->name, imsg.data);
d74 2
a75 1
				priv_flush_routes(ifi->name, ifi->rdomain);
d91 2
a92 1
				priv_set_interface_mtu(ifi->name, imsg.data);
d98 2
a99 2
			else
				priv_write_resolv_conf(ifi->rdomain, imsg.data,
@


1.51
log
@Stop trying to clean up addresses, routes and "-L" file
whenever dhclient dies. Eliminates differences in handling
and thus need to intercept signals INT, TERM, USR1,
USR2. Eliminates need for 'zapzombies' field and thus
entire struct imsg_flushroutes. Eliminates need for 'imsg'
parameter to and associated logic in priv_flush_routes().

Address, routes and '-L' file are still cleaned out when
binding a lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.50 2017/06/24 23:32:57 krw Exp $ */
d57 1
a57 1
				priv_delete_address(ifi, imsg.data);
d65 1
a65 1
				priv_add_address(ifi, imsg.data);
d72 1
a72 1
				priv_flush_routes(ifi);
d80 1
a80 1
				priv_add_route(ifi, imsg.data);
d88 1
a88 1
				priv_set_interface_mtu(ifi, imsg.data);
d95 1
a95 1
				priv_write_resolv_conf(ifi, imsg.data,
@


1.50
log
@Tweak handling of HUP and new LLADDR. Just use expose and use sighup()
function. Don't exit dispatch() loop on SIGHUP, wait for privileged
child to execvp() dhclient. Eliminate struct imsg_hup since its
contents were not being used except in priv_cleanup(). And
'active_addr' works just as well there.

Cleaner and eliminates some extraneous log entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.49 2017/06/24 10:09:26 krw Exp $ */
d69 1
a69 2
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_flush_routes))
d72 1
a72 1
				priv_flush_routes(ifi, imsg.data);
@


1.49
log
@Use a local variable rather than a global flag to record
the reception of a IMSG_HUP message and trigger the
desired restart.

Nuke the now pointless IFI_HUP.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.48 2017/06/23 16:18:02 krw Exp $ */
d101 1
a101 2
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_hup))
@


1.48
log
@Oops. Remove extraneous 'return' and some braces from
priv_write_resolv_conf() code that was moved into the
dispatch loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.47 2017/06/23 15:40:56 krw Exp $ */
d38 1
a38 1
void
d105 2
a106 2
				ifi->flags |= IFI_HUP;
				quit = SIGHUP;
d117 1
@


1.47
log
@Take reyk's imsg resolv.conf improvements of a while ago to their
logical conclusion.

Nuke _PATH_RESOLV_CONF since the value is only meant to be
known inside priv_write_resolv_conf(). Just use a local const char *.

Bring priv_write_resolv_conf() into line with other priv_ functions
invoked from the dispatch loop. i.e. don't pass it the imsg, just pass
a pointer to the data and a size after ensuring there is data to pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.46 2017/04/10 21:47:44 krw Exp $ */
d93 1
a93 1
			if (imsg.hdr.len <= IMSG_HEADER_SIZE) {
d95 1
a95 2
				return;
			} else
@


1.46
log
@Rework -L logic to use the idiom used in handling the leases file.
i.e. open FILE during program set up and use the FILE created for
the rest of the program lifetime after dropping privilege and
pledge()'ing. No need for passing messages to the priv process.

Tweak lease file handling a bit in passing.

Monitoring the -L file with external programs like sysutils/entr
still works.

Looks good to sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.45 2017/03/08 19:43:42 krw Exp $ */
d93 6
a98 1
			priv_write_resolv_conf(ifi, &imsg);
@


1.45
log
@Shuffle another bit of code closer to its friends.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.44 2017/02/12 15:53:15 krw Exp $ */
a103 4
			break;

		case IMSG_WRITE_OPTION_DB:
			priv_write_option_db(&imsg);
@


1.44
log
@Eliminate most strerror() invocations by using log_warn() and fatal()
instead of log_warnx() and fatalx(). A few log_info() to log_warn()
for the same reason.

Suggested by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.43 2017/02/12 13:15:50 krw Exp $ */
d92 4
a105 3
		case IMSG_WRITE_RESOLV_CONF:
			priv_write_resolv_conf(ifi, &imsg);
			break;
@


1.43
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.42 2016/09/02 15:44:26 mpi Exp $ */
d46 1
a46 2
			fatalx("dispatch_imsg: imsg_get failure: %s",
			    strerror(errno));
@


1.42
log
@Kill 'ifi' global.

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.41 2016/08/23 09:26:02 mpi Exp $ */
d35 1
d46 1
a46 1
			error("dispatch_imsg: imsg_get failure: %s",
d56 1
a56 1
				warning("bad IMSG_DELETE_ADDRESS");
d64 1
a64 1
				warning("bad IMSG_ADD_ADDRESS");
d72 1
a72 1
				warning("bad IMSG_FLUSH_ROUTES");
d80 1
a80 1
				warning("bad IMSG_ADD_ROUTE");
d88 1
a88 1
				warning("bad IMSG_SET_INTERFACE_MTU");
d96 1
a96 1
				warning("bad IMSG_HUP");
d111 1
a111 1
			warning("received unknown message, code %u",
@


1.41
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.40 2016/02/06 19:30:52 krw Exp $ */
d103 1
a103 1
			priv_write_resolv_conf(&imsg);
@


1.40
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.39 2015/02/07 10:08:06 krw Exp $ */
d38 1
a38 1
dispatch_imsg(struct imsgbuf *ibuf)
d57 1
a57 1
				priv_delete_address(imsg.data);
d65 1
a65 1
				priv_add_address(imsg.data);
d73 1
a73 1
				priv_flush_routes(imsg.data);
d81 1
a81 1
				priv_add_route(imsg.data);
d89 1
a89 1
				priv_set_interface_mtu(imsg.data);
@


1.39
log
@Add support for interface-mtu (option 26).

Original request+diff from matthew@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.38 2015/02/06 09:16:06 reyk Exp $ */
d19 15
a35 3

#include <sys/queue.h>
#include <sys/uio.h>
@


1.38
log
@The write_file() privsep interface was too permissive and
theoretically allowed the unprivileged child process to write to
arbitrary files.  Restrict it by replacing it with two specific
write_resolv_conf() and write_option_db() privsep interfaces where all
the critical decision has been moved to the parent.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.37 2014/10/27 13:36:21 krw Exp $ */
d70 8
@


1.37
log
@Zap extraneous whitespace and a stuttered extra 'break;'.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.36 2014/02/09 14:21:17 krw Exp $ */
a28 1
	struct imsg_write_file		*wfimsg;
a29 1
	size_t				 len;
d82 5
a86 16
		case IMSG_WRITE_FILE:
			if (imsg.hdr.len < IMSG_HEADER_SIZE +
			    sizeof(struct imsg_write_file))
				warning("short IMSG_WRITE_FILE");
			else {
				wfimsg = (struct imsg_write_file *)imsg.data;
				len = imsg.hdr.len;
				len -= IMSG_HEADER_SIZE;
				len -= sizeof(struct imsg_write_file);
				len -= wfimsg->len;
				if (len == 0)
					priv_write_file(wfimsg);
				else
					warning("bad IMSG_WRITE_FILE (%zu)",
					    len);
			}
@


1.36
log
@Missing {} around multi-statement else. Malformed IMSG_HUP messages should
not cause privileged process to exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.35 2014/01/20 09:16:36 deraadt Exp $ */
d88 1
a88 1
 			else {
d100 1
a100 1
 			break;
@


1.35
log
@more %d type correctness; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.34 2013/06/09 15:06:34 krw Exp $ */
d78 1
a78 1
			else
d81 1
@


1.34
log
@Re-apply route adding code refactoring -- it wasn't the problem that
broke populating the egress group.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.33 2013/06/09 00:30:06 krw Exp $ */
d102 1
a102 1
			warning("received unknown message, code %d",
@


1.33
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.32 2013/06/01 16:26:07 krw Exp $ */
d66 1
a66 1
		case IMSG_ADD_DEFAULT_ROUTE:
d68 2
a69 2
			    sizeof(struct imsg_add_default_route))
				warning("bad IMSG_ADD_DEFAULT_ROUTE");
d71 1
a71 1
				priv_add_default_route(imsg.data);
@


1.32
log
@Refactor the default route adding code to use a general route adding
function that will be reused for future work.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.31 2013/03/30 16:10:01 krw Exp $ */
d66 1
a66 1
		case IMSG_ADD_ROUTE:
d68 2
a69 2
			    sizeof(struct imsg_add_route))
				warning("bad IMSG_ADD_ROUTE");
d71 1
a71 1
				priv_add_route(imsg.data);
@


1.31
log
@Since deleting all the addresses on an interface removes all the
relevant entries from the arp cache, don't bother asking for/processing
arp entries in the route dumps. Thus allowing use of NET_RT_FLAGS
with RTF_GATEWAY and AF_INET, to ask for only the routes dhclient
wants to expunge rather than all routes in existance.

Greatly shrinks and simplifies the code. No intentional functional
change. Tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.30 2013/02/18 15:57:08 krw Exp $ */
d66 1
a66 1
		case IMSG_ADD_DEFAULT_ROUTE:
d68 2
a69 2
			    sizeof(struct imsg_add_default_route))
				warning("bad IMSG_ADD_DEFAULT_ROUTE");
d71 1
a71 1
				priv_add_default_route(imsg.data);
@


1.30
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.29 2013/01/27 02:45:46 krw Exp $ */
d63 1
a63 1
				priv_flush_routes_and_arp_cache(imsg.data);
@


1.29
log
@Refactor code a bit. Calculate resolv.conf contents once when binding a
lease and reuse as required whenever resolv.conf is written. Use
write_file() rather than a custom message/functions to write out
resolv.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.28 2013/01/15 21:44:28 krw Exp $ */
d74 1
a74 1
		case IMSG_CLEANUP:
d76 2
a77 2
			    sizeof(struct imsg_cleanup))
				warning("bad IMSG_CLEANUP");
d79 1
@


1.28
log
@Add IMSG_WRITE_FILE and associated bits to allow the unprivileged
process to ask that a file be written by the privileged process.

Not yet used.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.27 2012/12/29 14:40:01 krw Exp $ */
d28 4
a31 4
	struct imsg		imsg;
	struct imsg_write_file *wfimsg;
	ssize_t			n;
	size_t			len;
a71 8
			break;

		case IMSG_NEW_RESOLV_CONF:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct imsg_resolv_conf))
				warning("bad IMSG_NEW_RESOLV_CONF");
			else
				priv_resolv_conf(imsg.data);
@


1.27
log
@Make HUP to either one of the processes cause a restart that will
have dhclient re-read dhclient.conf and get a new lease. Constrain
the filename passed to '-l' (alternate dhclient.lease.if location)
to be a regular file for the moment.

Original suggestion from phessler@@. Feedback from deraadt@@ and
espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.26 2012/12/04 19:24:03 krw Exp $ */
d28 4
a31 2
	struct imsg	 imsg;
	ssize_t		 n;
d89 18
@


1.26
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.25 2012/12/02 17:03:19 krw Exp $ */
d85 1
a85 1
				priv_cleanup(imsg.data);
@


1.25
log
@Try harder to cleanup when exiting. In particular catch signals
SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUS2 and cleanup before exiting
when getting them. Cleanup meaning removing routes and the interface
address added.

Tweaks and feedback from phessler@@, sthen@@, otto@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.24 2012/11/23 15:25:47 krw Exp $ */
d33 2
a34 1
			error("dispatch_imsg: imsg_get failure: %m");
@


1.24
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.23 2012/11/14 15:47:41 krw Exp $ */
d77 8
@


1.23
log
@Remove useless _new_ and _old_ from various function names to make
them shorter and eliminate implications about what the function
does. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.22 2012/11/08 21:32:55 krw Exp $ */
d22 2
a23 70
struct buf *
buf_open(size_t len)
{
	struct buf	*buf;

	if ((buf = calloc(1, sizeof(struct buf))) == NULL)
		error("buf_open: %m");
	if ((buf->buf = malloc(len)) == NULL) {
		free(buf);
		error("buf_open: %m");
	}
	buf->size = len;

	return (buf);
}

void
buf_add(struct buf *buf, void *data, size_t len)
{
	if (len == 0)
		return;

	if (buf->wpos + len > buf->size)
		error("buf_add: %m");

	memcpy(buf->buf + buf->wpos, data, len);
	buf->wpos += len;
}

void
buf_close(int sock, struct buf *buf)
{
	ssize_t	n;

	do {
		n = write(sock, buf->buf + buf->rpos, buf->size - buf->rpos);
		if (n == 0)			/* connection closed */
			error("buf_close (connection closed)");
		if (n != -1 && n < buf->size - buf->rpos)
			error("buf_close (short write): %m");

	} while (n == -1 && (errno == EAGAIN || errno == EINTR));

	if (n == -1)
		error("buf_close: %m");

	free(buf->buf);
	free(buf);
}

void
buf_read(int sock, void *buf, size_t nbytes)
{
	ssize_t	n;

	do {
		n = read(sock, buf, nbytes);
		if (n == 0) {			/* connection closed */
#ifdef DEBUG
			debug("buf_read (connection closed)");
#endif
			exit(1);
		}
		if (n != -1 && n < nbytes)
			error("buf_read (short read): %m");
	} while (n == -1 && (errno == EINTR || errno == EAGAIN));

	if (n == -1)
		error("buf_read: %m");
}
d26 1
a26 1
dispatch_imsg(int fd)
d28 2
a29 203
	struct imsg_hdr		 hdr;
	struct in_addr		*addr, *mask, *gateway;
	char			*ifname, *contents;
	size_t			 totlen, len;
	int			 rdomain;

	buf_read(fd, &hdr, sizeof(hdr));

	switch (hdr.code) {
	case IMSG_DELETE_ADDRESS:
		totlen = sizeof(hdr);
		ifname = NULL;
		addr = NULL;
		if (hdr.len < totlen + sizeof(len))
			error("IMSG_DELETE_ADDRESS missing ifname length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_DELETE_ADDRESS invalid ifname length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_DELETE_ADDRESS short ifname");
			if ((ifname = calloc(1, len + 1)) == NULL)
				error("%m");
			buf_read(fd, ifname, len);
			totlen += len;
		} else
			error("IMSG_DELETE_ADDRESS ifname missing");

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_DELETE_ADDRESS missing rdomain length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_DELETE_ADDRESS invalid rdomain length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_DELETE_ADDRESS short rdomain");
			buf_read(fd, &rdomain, len);
			totlen += len;
		} else
			error("IMSG_DELETE_ADDRESS rdomain missing");

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_DELETE_ADDRESS missing addr length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_DELETE_ADDRESS invalid addr");
		} else if (len == sizeof(*addr)) {
			if ((addr = calloc(1, len)) == NULL)
				error("%m");
			buf_read(fd, addr, len);
			totlen += len;
		} else {
			error("IMSG_DELETE_ADDRESS addr missing %zu", len);
		}

		priv_delete_address(ifname, rdomain, *addr);
		free(ifname);
		free(addr);
		break;

	case IMSG_ADD_ADDRESS:
		totlen = sizeof(hdr);
		ifname = NULL;
		addr = NULL;
		mask = NULL;
		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_ADDRESS missing ifname length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_ADDRESS invalid ifname length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_ADD_ADDRESS short ifname");
			if ((ifname = calloc(1, len + 1)) == NULL)
				error("%m");
			buf_read(fd, ifname, len);
			totlen += len;
		} else
			error("IMSG_ADD_ADDRESS ifname missing");

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_ADDRESS missing rdomain length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_ADDRESS invalid rdomain length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_ADD_ADDRESS short rdomain");
			buf_read(fd, &rdomain, len);
			totlen += len;
		} else
			error("IMSG_ADD_ADDRESS rdomain missing");

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_ADDRESS missing addr length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_ADDRESS invalid addr");
		} else if (len == sizeof(*addr)) {
			if ((addr = calloc(1, len)) == NULL)
				error("%m");
			buf_read(fd, addr, len);
			totlen += len;
		} else {
			error("IMSG_ADD_ADDRESS addr missing %zu", len);
		}

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_ADDRESS missing mask length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		mask = NULL;
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_ADDRESS invalid mask");
		} else if (len == sizeof(*mask)) {
			if ((mask = calloc(1, len)) == NULL)
				error("%m");
			buf_read(fd, mask, len);
			totlen += len;
		} else {
			error("IMSG_ADD_ADDRESS mask missing %zu", len);
		}

		priv_add_address(ifname, rdomain, *addr, *mask);
		free(ifname);
		free(addr);
		free(mask);
		break;

	case IMSG_FLUSH_ROUTES:
		totlen = sizeof(hdr);
		if (hdr.len < totlen + sizeof(len))
			error("IMSG_FLUSH_ROUTES missing rdomain length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_FLUSH_ROUTES invalid rdomain length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_FLUSH_ROUTES short rdomain");
			buf_read(fd, &rdomain, len);
			totlen += len;
		} else
			error("IMSG_FLUSH_ROUTES rdomain missing");

		priv_flush_routes_and_arp_cache(rdomain);
		break;

	case IMSG_ADD_DEFAULT_ROUTE:
		totlen = sizeof(hdr);
		addr = NULL;
		gateway = NULL;
		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_DEFAULT_ROUTE missing rdomain length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_DEFAULT_ROUTE invalid rdomain length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_FLUSH_ROUTES short rdomain");
			buf_read(fd, &rdomain, len);
			totlen += len;
		} else
			error("IMSG_ADD_DEFAULT_ROUTE rdomain missing");

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_DEFAULT_ROUTE missing addr length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_DEFAULT_ROUTE invalid addr");
		} else if (len == sizeof(*addr)) {
			if ((addr = calloc(1, len)) == NULL)
				error("%m");
			buf_read(fd, addr, len);
			totlen += len;
		} else {
			error("IMSG_ADD_DEFAULT_ROUTE addr missing %zu",
			    len);
		}

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_ADD_DEFAULT_ROUTE missing gateway length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_DEFAULT_ROUTE invalid gateway");
		} else if (len == sizeof(*gateway)) {
			if ((gateway = calloc(1, len)) == NULL)
				error("%m");
			buf_read(fd, gateway, len);
			totlen += len;
		} else {
			error("IMSG_ADD_DEFAULT_ROUTE gateway missing %zu",
			    len);
		}
d31 51
a81 21
		priv_add_default_route(rdomain, *addr, *gateway);
		free(addr);
		free(gateway);
		break;
	case IMSG_NEW_RESOLV_CONF:
		totlen = sizeof(hdr);
		contents = NULL;

		if (hdr.len < totlen + sizeof(len))
			error("IMSG_NEW_RESOLV_CONF missing contents length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_NEW_RESOLV_CONF invalid contents length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_NEW_RESOLV_CONF short contents");
			if ((contents = calloc(1, len + 1)) == NULL)
				error("%m");
			buf_read(fd, contents, len);
			totlen += len;
d84 1
a84 5
		priv_resolv_conf(contents);
		free(contents);
		break;
	default:
		error("received unknown message, code %d", hdr.code);
@


1.22
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2012/11/04 03:44:48 krw Exp $ */
d154 1
a154 1
		priv_delete_old_address(ifname, rdomain, *addr);
d225 1
a225 1
		priv_add_new_address(ifname, rdomain, *addr, *mask);
d323 1
a323 1
		priv_new_resolv_conf(contents);
@


1.21
log
@Use consistant initialization idiom to reduce confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2012/11/04 03:36:39 krw Exp $ */
d97 1
a97 1
	in_addr_t		*mask;
a99 1
	struct iaddr		*addr, *gateway;
@


1.20
log
@No need to pass interface name around when flushing routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2012/11/04 03:25:31 krw Exp $ */
d254 1
a288 1
		gateway = NULL;
@


1.19
log
@No need to pass interface name around when creating routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2012/11/03 16:54:34 krw Exp $ */
a233 18
		ifname = NULL;
		addr = NULL;
		if (hdr.len < totlen + sizeof(len))
			error("IMSG_FLUSH_ROUTES missing ifname length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_FLUSH_ROUTES invalid ifname length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_FLUSH_ROUTES short ifname");
			if ((ifname = calloc(1, len + 1)) == NULL)
				error("%m");
			buf_read(fd, ifname, len);
			totlen += len;
		} else
			error("IMSG_FLUSH_ROUTES ifname missing");

d248 1
a248 2
		priv_flush_routes_and_arp_cache(ifname, rdomain);
		free(ifname);
@


1.18
log
@Various fixes/tweaks for resolv.conf handling:

1) Don't leak a file descriptor if there are no contents for
resolv.conf.
2) Allow for only resolv.conf.tail to go into resolv.conf.
3) Don't need to pass around interface name when creating resolv.conf.
4) Don't leave 0 length resolv.conf lying around if there are no
contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2012/10/30 18:39:44 krw Exp $ */
a271 1
		ifname = NULL;
a273 16
			error("IMSG_ADD_DEFAULT_ROUTE missing ifname length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_ADD_DEFAULT_ROUTE invalid ifname length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_ADD_DEFAULT_ROUTE short ifname");
			if ((ifname = calloc(1, len + 1)) == NULL)
				error("%m");
			buf_read(fd, ifname, len);
			totlen += len;
		} else
			error("IMSG_ADD_DEFAULT_ROUTE ifname missing");

		if (hdr.len < totlen + sizeof(len))
d320 1
a320 2
		priv_add_default_route(ifname, rdomain, *addr, *gateway);
		free(ifname);
a325 1
		ifname = NULL;
a343 1
		free(ifname);
@


1.17
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2011/04/04 11:14:52 krw Exp $ */
a345 15
		if (hdr.len < totlen + sizeof(len))
			error("IMSG_NEW_RESOLV_CONF missing ifname length");
		buf_read(fd, &len, sizeof(len));
		totlen += sizeof(len);
		if (len == SIZE_T_MAX) {
			error("IMSG_NEW_RESOLV_CONF invalid ifname length");
		} else if (len > 0) {
			if (hdr.len < totlen + len)
				error("IMSG_NEW_RESOLV_CONF short ifname");
			if ((ifname = calloc(1, len + 1)) == NULL)
				error("%m");
			buf_read(fd, ifname, len);
			totlen += len;
		} else
			error("IMSG_NEW_RESOLV_CONF ifname missing");
d360 1
a360 2
		} else
			error("IMSG_NEW_RESOLV_CONF contents missing");
d362 1
a362 1
		priv_new_resolv_conf(ifname, contents);
@


1.16
log
@Dump some useless calls to dhclient-script. i.e. MEDIUM, PREINIT,
ARPSEND, ARPCHECK. Drop support for 'media', 'medium' and 'alias'
specifications in dhclient.conf. Old leases still parse but these
options now have no effect.

Be more polite and decline all offers we don't accept. Fix a IMSG
length check.

Many expressions of support at various bars.

ok henning@@ deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2009/06/06 04:02:42 krw Exp $ */
d97 5
a101 7
	char			*reason, *filename,
				*servername, *prefix;
	size_t			 reason_len, filename_len,
				 servername_len, prefix_len, totlen;
	struct client_lease	 lease;
	int			 ret, i, optlen;
	struct buf		*buf;
d106 14
a119 9
	case IMSG_SCRIPT_INIT:
		if (hdr.len < sizeof(hdr) + sizeof(size_t))
			error("corrupted message received");
		buf_read(fd, &reason_len, sizeof(reason_len));
		if (hdr.len < reason_len + sizeof(hdr) + sizeof(size_t) ||
		    reason_len == SIZE_T_MAX)
			error("corrupted message received");
		if (reason_len > 0) {
			if ((reason = calloc(1, reason_len + 1)) == NULL)
d121 2
a122 1
			buf_read(fd, reason, reason_len);
d124 1
a124 1
			reason = NULL;
d126 32
a157 2
		priv_script_init(reason);
		free(reason);
d159 71
a229 70
	case IMSG_SCRIPT_WRITE_PARAMS:
		bzero(&lease, sizeof lease);
		totlen = sizeof(hdr) + sizeof(lease) + sizeof(size_t);
		if (hdr.len < totlen)
			error("corrupted message received");
		buf_read(fd, &lease, sizeof(lease));

		buf_read(fd, &filename_len, sizeof(filename_len));
		totlen += filename_len + sizeof(size_t);
		if (hdr.len < totlen || filename_len == SIZE_T_MAX)
			error("corrupted message received");
		if (filename_len > 0) {
			if ((filename = calloc(1, filename_len + 1)) == NULL)
				error("%m");
			buf_read(fd, filename, filename_len);
		} else
			filename = NULL;

		buf_read(fd, &servername_len, sizeof(servername_len));
		totlen += servername_len + sizeof(size_t);
		if (hdr.len < totlen || servername_len == SIZE_T_MAX)
			error("corrupted message received");
		if (servername_len > 0) {
			if ((servername =
			    calloc(1, servername_len + 1)) == NULL)
				error("%m");
			buf_read(fd, servername, servername_len);
		} else
			servername = NULL;

		buf_read(fd, &prefix_len, sizeof(prefix_len));
		totlen += prefix_len;
		if (hdr.len < totlen || prefix_len == SIZE_T_MAX)
			error("corrupted message received");
		if (prefix_len > 0) {
			if ((prefix = calloc(1, prefix_len + 1)) == NULL)
				error("%m");
			buf_read(fd, prefix, prefix_len);
		} else
			prefix = NULL;

		for (i = 0; i < 256; i++) {
			totlen += sizeof(optlen);
			if (hdr.len < totlen)
				error("corrupted message received");
			buf_read(fd, &optlen, sizeof(optlen));
			lease.options[i].data = NULL;
			lease.options[i].len = optlen;
			if (optlen > 0) {
				totlen += optlen;
				if (hdr.len < totlen || optlen == SIZE_T_MAX)
					error("corrupted message received");
				lease.options[i].data =
				    calloc(1, optlen + 1);
				if (lease.options[i].data == NULL)
				    error("%m");
				buf_read(fd, lease.options[i].data, optlen);
			}
		}
		lease.server_name = servername;
		lease.filename = filename;

		priv_script_write_params(prefix, &lease);

		free(servername);
		free(filename);
		free(prefix);
		for (i = 0; i < 256; i++)
			if (lease.options[i].len > 0)
				free(lease.options[i].data);
d231 150
a380 13
	case IMSG_SCRIPT_GO:
		if (hdr.len != sizeof(hdr))
			error("corrupted message received");

		ret = priv_script_go();

		hdr.code = IMSG_SCRIPT_GO_RET;
		hdr.len = sizeof(struct imsg_hdr) + sizeof(int);
		if ((buf = buf_open(hdr.len)) == NULL)
			error("buf_open: %m");
		buf_add(buf, &hdr, sizeof(hdr));
		buf_add(buf, &ret, sizeof(ret));
		buf_close(fd, buf);
@


1.15
log
@Nuke debug() unless DEBUG is defined. Elminates debug output from
normal operations.

Prodded by deraadt@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2007/02/15 15:22:27 stevesk Exp $ */
d97 1
a97 1
	char			*medium, *reason, *filename,
d99 1
a99 1
	size_t			 medium_len, reason_len, filename_len,
a110 11
		buf_read(fd, &medium_len, sizeof(medium_len));
		if (hdr.len < medium_len + sizeof(size_t) + sizeof(hdr)
		    + sizeof(size_t) || medium_len == SIZE_T_MAX)
			error("corrupted message received");
		if (medium_len > 0) {
			if ((medium = calloc(1, medium_len + 1)) == NULL)
				error("%m");
			buf_read(fd, medium, medium_len);
		} else
			medium = NULL;

d112 1
a112 1
		if (hdr.len < medium_len + reason_len + sizeof(hdr) ||
d122 1
a122 1
		priv_script_init(reason, medium);
a123 1
		free(medium);
@


1.14
log
@make read connection closed message a debug(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2007/02/14 23:19:26 deraadt Exp $ */
d80 1
d82 1
@


1.13
log
@spacing and a typo that fell out of the read
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2005/10/07 13:19:40 pedro Exp $ */
d79 4
a82 2
		if (n == 0)			/* connection closed */
			error("buf_read (connection closed)");
@


1.12
log
@Don't display errno message when errno isn't set.
Okay deraadt@@, moritz@@, help and okay henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2005/08/08 14:33:46 moritz Exp $ */
d79 1
a79 1
		if (n == 0) 			/* connection closed */
@


1.11
log
@re-add write() error check in buf_close(). ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2005/08/07 01:35:11 krw Exp $ */
d58 2
a59 4
		if (n == 0) {			/* connection closed */
			errno = 0;
			error("buf_close (connection closed): %m");
		}
d79 2
a80 2
		if (n == 0)
			error("buf_read (connection closed): %m");
@


1.10
log
@Simplify code by calling error() from inside buf_* functions rather
than always testing the return code and calling error() from the
caller.

From a diff by moritz@@, ok henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2005/08/04 14:21:04 henning Exp $ */
d66 3
@


1.9
log
@buf_* was taken from the framework I wrote for bgpd (also used by ntpd, ospfd
and some more). Here, however, we have a blocking socket for the IPC.
buf_close (writes out) and buf_read can be simplified due to that, and they
can just error out on short writes/reads. ok krw moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2005/06/02 15:04:25 cloder Exp $ */
d28 1
a28 1
		return (NULL);
d31 1
a31 1
		return (NULL);
d38 1
a38 1
int
d42 1
a42 1
		return (0);
d45 1
a45 1
		return (-1);
a48 1
	return (0);
d51 1
a51 1
int
d60 1
a60 1
			return (-1);
d63 1
a63 1
			error("short write");
a68 1
	return (n);
d71 1
a71 1
ssize_t
d79 1
a79 1
			error("connection closed");
d81 1
a81 1
			error("short read");
a85 2

	return (n);
d213 3
a215 6
		if (buf_add(buf, &hdr, sizeof(hdr)))
			error("buf_add: %m");
		if (buf_add(buf, &ret, sizeof(ret)))
			error("buf_add: %m");
		if (buf_close(fd, buf) == -1)
			error("buf_close: %m");
@


1.8
log
@Make buf_add a no-op if length == 0. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2004/05/10 18:34:42 deraadt Exp $ */
a58 2
		if (n != -1)
			buf->rpos += n;
d63 3
a67 4
	if (buf->rpos < buf->size)
		error("short write: wanted %lu got %ld bytes",
		    (unsigned long)buf->size, (long)buf->rpos);

d76 1
a76 2
	ssize_t	n, r = 0;
	char *p = buf;
d79 1
a79 1
		n = read(sock, p, nbytes);
d82 2
a83 5
		if (n != -1) {
			r += n;
			p += n;
			nbytes -= n;
		}
d89 1
a89 5
	if (r < nbytes)
		error("short read: wanted %lu got %ld bytes",
		    (unsigned long)nbytes, (long)r);

	return (r);
@


1.7
log
@missing casts spotted by 64 bit cc
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2004/05/04 19:56:18 henning Exp $ */
d41 3
@


1.6
log
@use SIZE_T_MAX, canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2004/05/04 18:58:50 deraadt Exp $ */
d65 2
a66 2
		error("short write: wanted %u got %d bytes", buf->size,
		    buf->rpos);
d94 2
a95 1
		error("short read: wanted %u got %d bytes", nbytes, r);
@


1.5
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2004/05/04 18:51:18 henning Exp $ */
d119 1
a119 1
		    + sizeof(size_t) || medium_len == UINT_MAX)
d130 1
a130 1
		    reason_len == UINT_MAX)
d152 1
a152 1
		if (hdr.len < totlen || filename_len == UINT_MAX)
d163 1
a163 1
		if (hdr.len < totlen || servername_len == UINT_MAX)
d175 1
a175 1
		if (hdr.len < totlen || prefix_len == UINT_MAX)
d193 1
a193 1
				if (hdr.len < totlen || optlen == UINT_MAX)
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a69 1

d77 1
d80 1
a80 1
		n = read(sock, buf, nbytes);
d85 1
a85 1
			buf += n;
d144 1
a212 1

@


1.3
log
@prevent the len params from overflowing, catched by & ok canacar
@
text
@d1 2
@


1.2
log
@Fix memory leak, ok henning@@
@
text
@d117 1
a117 1
		    + sizeof(size_t))
d127 2
a128 1
		if (hdr.len < medium_len + reason_len + sizeof(hdr))
d149 1
a149 1
		if (hdr.len < totlen)
d160 1
a160 1
		if (hdr.len < totlen)
d172 1
a172 1
		if (hdr.len < totlen)
d190 1
a190 1
				if (hdr.len < totlen)
@


1.1
log
@privilege seperate dhclient.
the privileged child's duty is the dhclient-script env setup & exection.
the parent process now chroots to /var/empty and drops privileges to _dhcp
mostly hacked at vancouver airport
with some feedback from krw@@ and otto@@, tested to not break installs by krw@@
@
text
@d66 3
d231 1
a231 1
}@

