head	1.110;
access;
symbols
	OPENBSD_6_1:1.105.0.4
	OPENBSD_6_1_BASE:1.105
	OPENBSD_6_0:1.95.0.4
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.94.0.2
	OPENBSD_5_9_BASE:1.94
	OPENBSD_5_8:1.92.0.4
	OPENBSD_5_8_BASE:1.92
	OPENBSD_5_7:1.91.0.2
	OPENBSD_5_7_BASE:1.91
	OPENBSD_5_6:1.87.0.4
	OPENBSD_5_6_BASE:1.87
	OPENBSD_5_5:1.83.0.4
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.53.0.2
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.38.0.6
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.6
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.4
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.10
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.8
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.6
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12;
locks; strict;
comment	@ * @;


1.110
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.109;
commitid	KIdulj0iLtM6kXff;

1.109
date	2017.04.04.13.01.20;	author krw;	state Exp;
branches;
next	1.108;
commitid	XnNlR4VEiZFpMvjG;

1.108
date	2017.04.03.19.59.39;	author krw;	state Exp;
branches;
next	1.107;
commitid	FEe0akNwKUViXksW;

1.107
date	2017.04.03.15.34.46;	author krw;	state Exp;
branches;
next	1.106;
commitid	H7YONChEP2colYND;

1.106
date	2017.04.03.14.16.34;	author krw;	state Exp;
branches;
next	1.105;
commitid	inVYrBC2E4aM7oYT;

1.105
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.104;
commitid	WchZmaQT4LJ4im5M;

1.104
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.103;
commitid	IDlzr3qamZK5lxzj;

1.103
date	2016.10.06.16.29.17;	author krw;	state Exp;
branches;
next	1.102;
commitid	dTOGnqxN6bqeD6hy;

1.102
date	2016.09.30.13.20.57;	author krw;	state Exp;
branches;
next	1.101;
commitid	4w5PHEOcfhiLlAHm;

1.101
date	2016.09.01.13.27.04;	author krw;	state Exp;
branches;
next	1.100;
commitid	sh41z6rkAV3iSIdo;

1.100
date	2016.09.01.10.29.16;	author krw;	state Exp;
branches;
next	1.99;
commitid	59fXCGUcT8ZgtrTH;

1.99
date	2016.08.31.12.57.31;	author mpi;	state Exp;
branches;
next	1.98;
commitid	dRGzj71S05fFJodM;

1.98
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.97;
commitid	Tm7CrlqCKqgQoJ7P;

1.97
date	2016.08.16.21.57.51;	author krw;	state Exp;
branches;
next	1.96;
commitid	fX275BVALtbId2xm;

1.96
date	2016.07.31.18.55.16;	author krw;	state Exp;
branches;
next	1.95;
commitid	8y3qjAKyuLYYSq4K;

1.95
date	2016.06.03.02.31.17;	author tedu;	state Exp;
branches;
next	1.94;
commitid	xFTKYa3lWvjefHXE;

1.94
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.93;
commitid	5ELOU0S0Zl3aCrHG;

1.93
date	2015.10.26.16.32.33;	author krw;	state Exp;
branches;
next	1.92;
commitid	Y03Zu0zFPhi0Triz;

1.92
date	2015.05.18.17.51.21;	author krw;	state Exp;
branches;
next	1.91;
commitid	SjQKXPdyGuKrZRc7;

1.91
date	2015.02.01.18.43.39;	author krw;	state Exp;
branches;
next	1.90;
commitid	MGxD3aLHy6xeOkpL;

1.90
date	2014.11.03.22.06.39;	author krw;	state Exp;
branches;
next	1.89;
commitid	sY6lsz32MlyrgrUl;

1.89
date	2014.11.02.15.18.32;	author krw;	state Exp;
branches;
next	1.88;
commitid	mfa2z1UxKtO5K6t8;

1.88
date	2014.10.27.13.36.21;	author krw;	state Exp;
branches;
next	1.87;
commitid	18JJKpLCJZeJyulS;

1.87
date	2014.05.12.13.12.41;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2014.05.11.12.40.37;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2014.05.05.14.44.18;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.25.05.21.23;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2014.01.21.05.17.45;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2014.01.21.03.07.50;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2014.01.20.01.12.17;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2014.01.20.00.36.52;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.19.21.10.04;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.19.08.25.54;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2014.01.19.04.36.04;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2014.01.18.01.19.01;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2014.01.18.01.03.56;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2014.01.18.00.51.55;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2014.01.17.22.48.10;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2014.01.13.23.42.18;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.13.21.36.46;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2014.01.13.21.04.19;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.12.04.17.36;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.10.01.25.03;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.10.01.07.58;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2013.12.30.03.36.17;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2013.12.28.21.48.04;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2013.12.22.02.37.25;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2013.11.11.21.00.01;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.22.18.15.58;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.09.16.21.50;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2013.06.04.21.04.51;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.02.14.48.35;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2013.03.22.23.58.51;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.21.12.41.12;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.02.09.23.37.21;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2013.02.01.20.44.00;	author florian;	state Exp;
branches;
next	1.51;

1.51
date	2013.01.02.01.06.57;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2012.12.04.19.24.02;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.27.18.52.39;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2012.11.27.15.51.48;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2012.11.27.14.14.16;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2012.11.25.16.45.31;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.25.14.56.55;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.25.12.49.56;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2012.10.27.23.08.53;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2012.08.26.23.33.29;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2012.08.22.00.14.42;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.10.17.15.27;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.04.11.14.52;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.19.00.18.02;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2009.05.27.15.04.34;	author stevesk;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.14.23.19.26;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.27.20.56.33;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.16.15.13.45;	author stevesk;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.15.14.56.38;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.08.17.25.59;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.20.15.54.34;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.18.19.17.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.02.02.34.03;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.16.18.38.45;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.16.14.09.51;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.15.22.33.04;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.11.18.24.08;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.11.18.09.09;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.11.17.57.26;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.09.01.06.00;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.15.18.15.18;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.24.15.06.03;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.04.23.33.49;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.13.07.35.17;	author wilfried;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.02.18.49.21;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.02.15.41.44;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.02.13.39.44;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.02.12.56.30;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.24.13.21.32;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.07.21.10.26;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.07.11.35.59;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.04.01.50.22;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.01.25.34;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.01.18.26;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.110
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@/*	$OpenBSD: clparse.c,v 1.109 2017/04/04 13:01:20 krw Exp $	*/

/* Parser for dhclient config and lease files. */

/*
 * Copyright (c) 1997 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <net/if.h>
#include <net/if_arp.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "dhctoken.h"
#include "log.h"

void parse_client_statement(FILE *, struct interface_info *);
int parse_X(FILE *, u_int8_t *, int);
int parse_option_list(FILE *, u_int8_t *, size_t);
void parse_interface_declaration(FILE *, struct interface_info *);
void parse_client_lease_statement(FILE *, unsigned int,
    struct interface_info *);
void parse_client_lease_declaration(FILE *, struct client_lease *,
    struct interface_info *);
int parse_option_decl(FILE *, struct option_data *);
void parse_reject_statement(FILE *);

/*
 * client-conf-file :== client-declarations EOF
 * client-declarations :== <nil>
 *			 | client-declaration
 *			 | client-declarations client-declaration
 */
void
read_client_conf(struct interface_info *ifi)
{
	FILE *cfile;
	int token;

	new_parse(path_dhclient_conf);

	/* Set some defaults. */
	config->link_timeout = 10;	/* secs before going daemon w/o link */
	config->timeout = 30;		/* secs to wait for an OFFER */
	config->select_interval = 0;	/* secs to wait for other OFFERs */
	config->reboot_timeout = 1;	/* secs before giving up on reboot */
	config->retry_interval = 1;	/* secs before asking for OFFER */
	config->backoff_cutoff = 10;	/* max secs between packet retries */
	config->initial_interval = 1;	/* secs before 1st retry */

	config->bootp_policy = ACCEPT;
	config->requested_options
	    [config->requested_option_count++] = DHO_SUBNET_MASK;
	config->requested_options
	    [config->requested_option_count++] = DHO_BROADCAST_ADDRESS;
	config->requested_options
	    [config->requested_option_count++] = DHO_TIME_OFFSET;
	/* RFC 3442 says CLASSLESS_STATIC_ROUTES must be before ROUTERS! */
	config->requested_options
	    [config->requested_option_count++] = DHO_CLASSLESS_STATIC_ROUTES;
	config->requested_options
	    [config->requested_option_count++] = DHO_ROUTERS;
	config->requested_options
	    [config->requested_option_count++] = DHO_DOMAIN_NAME;
	config->requested_options
	    [config->requested_option_count++] = DHO_DOMAIN_SEARCH;
	config->requested_options
	    [config->requested_option_count++] = DHO_DOMAIN_NAME_SERVERS;
	config->requested_options
	    [config->requested_option_count++] = DHO_HOST_NAME;
	config->requested_options
	    [config->requested_option_count++] = DHO_BOOTFILE_NAME;
	config->requested_options
	    [config->requested_option_count++] = DHO_TFTP_SERVER;

	if ((cfile = fopen(path_dhclient_conf, "r")) != NULL) {
		do {
			token = peek_token(NULL, cfile);
			if (token == EOF)
				break;
			parse_client_statement(cfile, ifi);
		} while (1);
		fclose(cfile);
	}
}

/*
 * lease-file :== client-lease-statements EOF
 * client-lease-statements :== <nil>
 *		     | client-lease-statements LEASE client-lease-statement
 */
void
read_client_leases(struct interface_info *ifi)
{
	FILE	*cfile;
	int	 token;

	new_parse(path_dhclient_db);

	/* Open the lease file.   If we can't open it, just return -
	   we can safely trust the server to remember our state. */
	if ((cfile = fopen(path_dhclient_db, "r")) == NULL)
		return;
	do {
		token = next_token(NULL, cfile);
		if (token == EOF)
			break;
		if (token != TOK_LEASE) {
			log_warnx("Corrupt lease file - possible data loss!");
			break;
		}
		parse_client_lease_statement(cfile, 0, ifi);
	} while (1);
	fclose(cfile);
}

/*
 * client-declaration :==
 *	TOK_SEND option-decl |
 *	TOK_DEFAULT option-decl |
 *	TOK_SUPERSEDE option-decl |
 *	TOK_APPEND option-decl |
 *	TOK_PREPEND option-decl |
 *	TOK_MEDIA string-list |
 *	hardware-declaration |
 *	TOK_REQUEST option-list |
 *	TOK_REQUIRE option-list |
 *	TOK_IGNORE option-list |
 *	TOK_TIMEOUT number |
 *	TOK_RETRY number |
 *	TOK_SELECT_TIMEOUT number |
 *	TOK_REBOOT number |
 *	TOK_BACKOFF_CUTOFF number |
 *	TOK_INITIAL_INTERVAL number |
 *	interface-declaration |
 *	TOK_LEASE client-lease-statement |
 *	TOK_ALIAS client-lease-statement |
 *	TOK_REJECT reject-statement
 */
void
parse_client_statement(FILE *cfile, struct interface_info *ifi)
{
	u_int8_t optlist[256];
	char *string;
	int code, count, token;

	token = next_token(NULL, cfile);

	switch (token) {
	case TOK_SEND:
		parse_option_decl(cfile, &config->send_options[0]);
		break;
	case TOK_DEFAULT:
		code = parse_option_decl(cfile, &config->defaults[0]);
		if (code != -1)
			config->default_actions[code] = ACTION_DEFAULT;
		break;
	case TOK_SUPERSEDE:
		code = parse_option_decl(cfile, &config->defaults[0]);
		if (code != -1)
			config->default_actions[code] = ACTION_SUPERSEDE;
		break;
	case TOK_APPEND:
		code = parse_option_decl(cfile, &config->defaults[0]);
		if (code != -1)
			config->default_actions[code] = ACTION_APPEND;
		break;
	case TOK_PREPEND:
		code = parse_option_decl(cfile, &config->defaults[0]);
		if (code != -1)
			config->default_actions[code] = ACTION_PREPEND;
		break;
	case TOK_HARDWARE:
		parse_ethernet(cfile, &ifi->hw_address);
		break;
	case TOK_REQUEST:
		count = parse_option_list(cfile, optlist, sizeof(optlist));
		if (count != -1) {
			config->requested_option_count = count;
			memcpy(config->requested_options, optlist,
			    sizeof(config->requested_options));
		}
		break;
	case TOK_REQUIRE:
		count = parse_option_list(cfile, optlist, sizeof(optlist));
		if (count != -1) {
			config->required_option_count = count;
			memcpy(config->required_options, optlist,
			    sizeof(config->required_options));
		}
		break;
	case TOK_IGNORE:
		count = parse_option_list(cfile, optlist, sizeof(optlist));
		if (count != -1) {
			config->ignored_option_count = count;
			memcpy(config->ignored_options, optlist,
			    sizeof(config->ignored_options));
		}
		break;
	case TOK_LINK_TIMEOUT:
		parse_lease_time(cfile, &config->link_timeout);
		break;
	case TOK_TIMEOUT:
		parse_lease_time(cfile, &config->timeout);
		break;
	case TOK_RETRY:
		parse_lease_time(cfile, &config->retry_interval);
		break;
	case TOK_SELECT_TIMEOUT:
		parse_lease_time(cfile, &config->select_interval);
		break;
	case TOK_REBOOT:
		parse_lease_time(cfile, &config->reboot_timeout);
		break;
	case TOK_BACKOFF_CUTOFF:
		parse_lease_time(cfile, &config->backoff_cutoff);
		break;
	case TOK_INITIAL_INTERVAL:
		parse_lease_time(cfile, &config->initial_interval);
		break;
	case TOK_INTERFACE:
		parse_interface_declaration(cfile, ifi);
		break;
	case TOK_LEASE:
		parse_client_lease_statement(cfile, 1, ifi);
		break;
	case TOK_ALIAS:
	case TOK_MEDIA:
		/* Deprecated and ignored. */
		skip_to_semi(cfile);
		break;
	case TOK_REJECT:
		parse_reject_statement(cfile);
		break;
	case TOK_FILENAME:
		string = parse_string(cfile, NULL);
		free(config->filename);
		config->filename = string;
		parse_semi(cfile);
		break;
	case TOK_SERVER_NAME:
		string = parse_string(cfile, NULL);
		free(config->server_name);
		config->server_name = string;
		parse_semi(cfile);
		break;
	case TOK_FIXED_ADDR:
		if (parse_ip_addr(cfile, &config->address))
			parse_semi(cfile);
		break;
	case TOK_NEXT_SERVER:
		if (parse_ip_addr(cfile, &config->next_server))
			parse_semi(cfile);
		break;
	default:
		parse_warn("expecting statement.");
		if (token != ';')
			skip_to_semi(cfile);
		break;
	}
}

int
parse_X(FILE *cfile, u_int8_t *buf, int max)
{
	int	 token;
	char	*val;
	int	 len;

	token = peek_token(&val, cfile);
	if (token == TOK_NUMBER_OR_NAME) {
		len = 0;
		for (token = ':'; token == ':';
		     token = next_token(NULL, cfile)) {
			if (!parse_hex(cfile, &buf[len]))
				break;
			if (++len == max)
				break;
			if (peek_token(NULL, cfile) == ';')
				return (len);
		}
		if (token != ':') {
			parse_warn("expecting ':'.");
			skip_to_semi(cfile);
			return (-1);
		} else {
			parse_warn("expecting hex value.");
			skip_to_semi(cfile);
			return (-1);
		}
	} else if (token == TOK_STRING) {
		token = next_token(&val, cfile);
		len = strlen(val);
		if (len + 1 > max) {
			parse_warn("string constant too long.");
			skip_to_semi(cfile);
			return (-1);
		}
		memcpy(buf, val, len + 1);
	} else {
		token = next_token(NULL, cfile);
		parse_warn("expecting string or hex data.");
		if (token != ';')
			skip_to_semi(cfile);
		return (-1);
	}
	return (len);
}

/*
 * option-list :== option_name |
 *		   option_list COMMA option_name
 */
int
parse_option_list(FILE *cfile, u_int8_t *list, size_t sz)
{
	unsigned int	 ix, j;
	int		 i;
	int		 token;
	char		*val;

	memset(list, DHO_PAD, sz);
	ix = 0;
	do {
		token = next_token(&val, cfile);
		if (token == ';' && ix == 0) {
			/* Empty list. */
			return (0);
		}
		if (!is_identifier(token)) {
			parse_warn("expecting option name.");
			goto syntaxerror;
		}
		/*
		 * 0 (DHO_PAD) and 255 (DHO_END) are not valid in option
		 * lists.  They are not really options and it makes no sense
		 * to request, require or ignore them.
		 */
		for (i = 1; i < DHO_END; i++)
			if (!strcasecmp(dhcp_options[i].name, val))
				break;

		if (i == DHO_END) {
			parse_warn("expecting option name.");
			goto syntaxerror;
		}
		if (ix == sz) {
			parse_warn("too many options.");
			goto syntaxerror;
		}
		/* Avoid storing duplicate options in the list. */
		for (j = 0; j < ix && list[j] != i; j++)
			;
		if (j == ix)
			list[ix++] = i;
		token = peek_token(NULL, cfile);
		if (token == ',')
			token = next_token(NULL, cfile);
	} while (token == ',');

	if (parse_semi(cfile))
		return (ix);

syntaxerror:
	if (token != ';')
		skip_to_semi(cfile);
	return (-1);
}

/*
 * interface-declaration :==
 *	INTERFACE string LBRACE client-declarations RBRACE
 */
void
parse_interface_declaration(FILE *cfile, struct interface_info *ifi)
{
	char *val;
	int token;

	token = next_token(&val, cfile);
	if (token != TOK_STRING) {
		parse_warn("expecting string.");
		if (token != ';')
			skip_to_semi(cfile);
		return;
	}

	if (strcmp(ifi->name, val) != 0) {
		skip_to_semi(cfile);
		return;
	}

	token = next_token(&val, cfile);
	if (token != '{') {
		parse_warn("expecting '{'.");
		if (token != ';')
			skip_to_semi(cfile);
		return;
	}

	do {
		token = peek_token(&val, cfile);
		if (token == EOF) {
			parse_warn("unterminated interface declaration.");
			return;
		}
		if (token == '}')
			break;
		parse_client_statement(cfile, ifi);
	} while (1);
	token = next_token(&val, cfile);
}

/*
 * client-lease-statement :==
 *	RBRACE client-lease-declarations LBRACE
 *
 *	client-lease-declarations :==
 *		<nil> |
 *		client-lease-declaration |
 *		client-lease-declarations client-lease-declaration
 */
void
parse_client_lease_statement(FILE *cfile, unsigned int is_static,
    struct interface_info *ifi)
{
	struct client_state	*client = ifi->client;
	struct client_lease	*lease, *lp, *pl;
	int			 token;

	token = next_token(NULL, cfile);
	if (token != '{') {
		parse_warn("expecting '{'.");
		if (token != ';')
			skip_to_semi(cfile);
		return;
	}

	lease = calloc(1, sizeof(struct client_lease));
	if (!lease)
		fatalx("no memory for lease.");

	do {
		token = peek_token(NULL, cfile);
		if (token == EOF) {
			parse_warn("unterminated lease declaration.");
			free_client_lease(lease);
			return;
		}
		if (token == '}')
			break;
		parse_client_lease_declaration(cfile, lease, ifi);
	} while (1);
	token = next_token(NULL, cfile);

	/*
	 * The new lease will supersede a lease which is of the same type
	 * AND the same ssid AND the same Client Identifier AND the same
	 * IP address.
	 */
	TAILQ_FOREACH_SAFE(lp, &client->leases, next, pl) {
		if (lp->is_static != is_static)
			continue;
		if (lp->ssid_len != lease->ssid_len)
			continue;
		if (memcmp(lp->ssid, lease->ssid, lp->ssid_len) != 0)
			continue;
		if ((lease->options[DHO_DHCP_CLIENT_IDENTIFIER].len != 0) &&
		    ((lp->options[DHO_DHCP_CLIENT_IDENTIFIER].len !=
		    lease->options[DHO_DHCP_CLIENT_IDENTIFIER].len) ||
		    memcmp(lp->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
		    lease->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
		    lp->options[DHO_DHCP_CLIENT_IDENTIFIER].len)))
			continue;
		if (lp->address.s_addr != lease->address.s_addr)
			continue;

		TAILQ_REMOVE(&client->leases, lp, next);
		lp->is_static = 0;	/* Else it won't be freed. */
		free_client_lease(lp);
	}

	/*
	 * If the lease is marked as static before now it will leak on parse
	 * errors because free_client_lease() ignores attempts to free static
	 * leases.
	 */
	lease->is_static = is_static;
	if (is_static)
		TAILQ_INSERT_TAIL(&client->leases, lease, next);
	else
		TAILQ_INSERT_HEAD(&client->leases, lease,  next);
}

/*
 * client-lease-declaration :==
 *	BOOTP |
 *	INTERFACE string |
 *	FIXED_ADDR ip_address |
 *	FILENAME string |
 *	SERVER_NAME string |
 *	OPTION option-decl |
 *	RENEW time-decl |
 *	REBIND time-decl |
 *	EXPIRE time-decl
 */
void
parse_client_lease_declaration(FILE *cfile, struct client_lease *lease,
    struct interface_info *ifi)
{
	char *val;
	unsigned int len;
	int token;

	token = next_token(&val, cfile);

	switch (token) {
	case TOK_BOOTP:
		lease->is_bootp = 1;
		break;
	case TOK_INTERFACE:
		token = next_token(&val, cfile);
		if (token != TOK_STRING) {
			parse_warn("expecting string.");
			if (token != ';')
				skip_to_semi(cfile);
			return;
		}
		if (strcmp(ifi->name, val) != 0) {
			if (lease->is_static == 0)
				parse_warn("wrong interface name.");
			skip_to_semi(cfile);
			return;
		}
		break;
	case TOK_FIXED_ADDR:
		if (!parse_ip_addr(cfile, &lease->address))
			return;
		break;
	case TOK_NEXT_SERVER:
		if (!parse_ip_addr(cfile, &lease->next_server))
			return;
		break;
	case TOK_MEDIUM:
		skip_to_semi(cfile);
		return;
	case TOK_FILENAME:
		lease->filename = parse_string(cfile, NULL);
		break;
	case TOK_SERVER_NAME:
		lease->server_name = parse_string(cfile, NULL);
		break;
	case TOK_SSID:
		val = parse_string(cfile, &len);
		if (val && len <= sizeof(lease->ssid)) {
			memset(lease->ssid, 0, sizeof(lease->ssid));
			memcpy(lease->ssid, val, len);
			lease->ssid_len = len;
		}
		free(val);
		break;
	case TOK_RENEW:
		lease->renewal = parse_date(cfile);
		return;
	case TOK_REBIND:
		lease->rebind = parse_date(cfile);
		return;
	case TOK_EXPIRE:
		lease->expiry = parse_date(cfile);
		return;
	case TOK_OPTION:
		parse_option_decl(cfile, lease->options);
		return;
	default:
		parse_warn("expecting lease declaration.");
		if (token != ';')
			skip_to_semi(cfile);
		return;
	}

	parse_semi(cfile);
}

int
parse_option_decl(FILE *cfile, struct option_data *options)
{
	char		*val;
	int		 token;
	u_int8_t	 buf[4];
	u_int8_t	 cidr[5];
	u_int8_t	 hunkbuf[1024];
	unsigned int	 hunkix = 0;
	char		*fmt;
	struct in_addr	 ip_addr;
	u_int8_t	*dp;
	int		 len, code;
	int		 nul_term = 0;

	token = next_token(&val, cfile);
	if (!is_identifier(token)) {
		parse_warn("expecting identifier.");
		if (token != ';')
			skip_to_semi(cfile);
		return (-1);
	}

	/* Look up the actual option info. */
	fmt = NULL;
	for (code = 0; code < 256; code++)
		if (strcmp(dhcp_options[code].name, val) == 0)
			break;

	if (code > 255) {
		parse_warn("unknown option name.");
		skip_to_semi(cfile);
		return (-1);
	}

	/* Parse the option data. */
	do {
		for (fmt = dhcp_options[code].format; *fmt; fmt++) {
			if (*fmt == 'A')
				break;
			switch (*fmt) {
			case 'X':
				len = parse_X(cfile, &hunkbuf[hunkix],
				    sizeof(hunkbuf) - hunkix);
				if (len == -1)
					return (-1);
				hunkix += len;
				break;
			case 't': /* Text string. */
				val = parse_string(cfile, &len);
				if (val == NULL)
					return (-1);
				if (hunkix + len + 1 > sizeof(hunkbuf)) {
					parse_warn("option data buffer "
					    "overflow");
					skip_to_semi(cfile);
					return (-1);
				}
				memcpy(&hunkbuf[hunkix], val, len + 1);
				nul_term = 1;
				hunkix += len;
				free(val);
				break;
			case 'I': /* IP address. */
				if (!parse_ip_addr(cfile, &ip_addr))
					return (-1);
				len = sizeof(ip_addr);
				dp = (u_int8_t *)&ip_addr;
alloc:
				if (hunkix + len > sizeof(hunkbuf)) {
					parse_warn("option data buffer "
					    "overflow");
					skip_to_semi(cfile);
					return (-1);
				}
				memcpy(&hunkbuf[hunkix], dp, len);
				hunkix += len;
				break;
			case 'l':	/* Signed 32-bit integer. */
				if (!parse_decimal(cfile, buf, *fmt)) {
					parse_warn("expecting signed 32-bit "
					    "integer.");
					skip_to_semi(cfile);
					return (-1);
				}
				len = 4;
				dp = buf;
				goto alloc;
			case 'L':	/* Unsigned 32-bit integer. */
				if (!parse_decimal(cfile, buf, *fmt)) {
					parse_warn("expecting unsigned 32-bit "
					    "integer.");
					skip_to_semi(cfile);
					return (-1);
				}
				len = 4;
				dp = buf;
				goto alloc;
			case 'S':	/* Unsigned 16-bit integer. */
				if (!parse_decimal(cfile, buf, *fmt)) {
					parse_warn("expecting unsigned 16-bit "
					    "integer.");
					skip_to_semi(cfile);
					return (-1);
				}
				len = 2;
				dp = buf;
				goto alloc;
			case 'B':	/* Unsigned 8-bit integer. */
				if (!parse_decimal(cfile, buf, *fmt)) {
					parse_warn("expecting unsigned 8-bit "
					    "integer.");
					skip_to_semi(cfile);
					return (-1);
				}
				len = 1;
				dp = buf;
				goto alloc;
			case 'f': /* Boolean flag. */
				token = next_token(&val, cfile);
				if (!is_identifier(token)) {
					parse_warn("expecting identifier.");
bad_flag:
					if (token != ';')
						skip_to_semi(cfile);
					return (-1);
				}
				if (!strcasecmp(val, "true") ||
				    !strcasecmp(val, "on"))
					buf[0] = 1;
				else if (!strcasecmp(val, "false") ||
				    !strcasecmp(val, "off"))
					buf[0] = 0;
				else {
					parse_warn("expecting boolean.");
					goto bad_flag;
				}
				len = 1;
				dp = buf;
				goto alloc;
			case 'C':
				if (!parse_cidr(cfile, cidr))
					return (-1);
				len = 1 + (cidr[0] + 7) / 8;
				dp = cidr;
				goto alloc;
			default:
				log_warnx("Bad format %c in "
				    "parse_option_param.", *fmt);
				skip_to_semi(cfile);
				return (-1);
			}
		}
		token = peek_token(NULL, cfile);
		if (*fmt == 'A' && token == ',')
			token = next_token(NULL, cfile);
	} while (*fmt == 'A' && token == ',');

	if (!parse_semi(cfile))
		return (-1);

	options[code].data = malloc(hunkix + nul_term);
	if (!options[code].data)
		fatalx("out of memory allocating option data.");
	memcpy(options[code].data, hunkbuf, hunkix + nul_term);
	options[code].len = hunkix;
	return (code);
}

void
parse_reject_statement(FILE *cfile)
{
	struct reject_elem *elem;
	struct in_addr addr;
	int token;

	do {
		if (!parse_ip_addr(cfile, &addr))
			return;

		elem = malloc(sizeof(struct reject_elem));
		if (!elem)
			fatalx("no memory for reject address!");

		elem->addr = addr;
		TAILQ_INSERT_TAIL(&config->reject_list, elem, next);

		token = peek_token(NULL, cfile);
		if (token == ',')
			token = next_token(NULL, cfile);
	} while (token == ',');

	parse_semi(cfile);
}
@


1.109
log
@Treat SSID's like the 0 to 32 bytes of uint8_t data that they really
are. Track and use the actual lengths and use memcpy()/memcmp()
instead of strcmp()/strdup().
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.108 2017/04/03 19:59:39 krw Exp $	*/
d67 2
a68 1
void parse_client_lease_statement(FILE *, int, struct interface_info *);
d363 4
a366 3
	int	 ix, i, j;
	int	 token;
	char	*val;
d470 1
a470 1
parse_client_lease_statement(FILE *cfile, int is_static,
d558 2
a559 1
	int len, token;
d638 1
a638 1
	int		 hunkix = 0;
@


1.108
log
@Change parse_string() to take an optional integer pointer that can
be used to return the final size of the parsed (i.e. un-vis'ed)
string. Use same, plus memcpy() to ensure entire final string is
copied to intended destination even if there are embedded NULs.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.107 2017/04/03 15:34:46 krw Exp $	*/
d508 3
a510 1
		if (strcmp(lp->ssid, ifi->ssid) != 0)
d601 1
@


1.107
log
@Tweak parse_string() to not consume the ';'. Simplifies/shortens
some logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.106 2017/04/03 14:16:34 krw Exp $	*/
d281 1
a281 1
		string = parse_string(cfile);
d287 1
a287 1
		string = parse_string(cfile);
d554 1
a554 1
	int token;
d589 1
a589 1
		lease->filename = parse_string(cfile);
d592 1
a592 1
		lease->server_name = parse_string(cfile);
d595 5
a599 3
		val = parse_string(cfile);
		if (val)
			strlcpy(lease->ssid, val, sizeof(lease->ssid));
d673 1
a673 1
				val = parse_string(cfile);
a675 1
				len = strlen(val);
@


1.106
log
@Tweak 'expecting' parse_warn() messages to be more consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.105 2017/02/12 13:55:01 krw Exp $	*/
d284 1
d290 1
d590 1
a590 1
		return;
d593 1
a593 1
		return;
d599 1
a599 1
		return;
d671 2
a672 5
				token = next_token(&val, cfile);
				if (token != TOK_STRING) {
					parse_warn("expecting string.");
					if (token != ';')
						skip_to_semi(cfile);
a673 1
				}
d684 1
@


1.105
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.104 2017/02/12 13:15:50 krw Exp $	*/
d299 1
a299 1
		parse_warn("expecting a statement.");
d330 1
a330 1
			parse_warn("expecting hex octet.");
d345 1
a345 1
		parse_warn("expecting string or hexadecimal data");
d424 1
a424 1
		parse_warn("expecting interface name (in quotes).");
d437 1
a437 1
		parse_warn("expecting left brace.");
d475 1
a475 1
		parse_warn("expecting left brace.");
d563 1
a563 1
			parse_warn("expecting interface name (in quotes).");
d637 1
a637 1
		parse_warn("expecting identifier after option keyword.");
@


1.104
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.103 2016/10/06 16:29:17 krw Exp $	*/
d466 2
a467 1
parse_client_lease_statement(FILE *cfile, int is_static, struct interface_info *ifi)
d771 2
a772 2
				log_warnx("Bad format %c in parse_option_param.",
				    *fmt);
@


1.103
log
@Add support for RFC 6842, which says the client MUST drop packets when
the server provides a client-identifier value and it doesn't match
the value the client sent.

So stop suppressing client-identifer info in the leases file and when
reading the leases file stop discarding leases that don't have current
client-identifier info. Don't use them, but keep them around in case
the client-identifier info changes back next time.

Also construct the default client-identifier (if needed) before reading
the leases file.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.102 2016/09/30 13:20:57 krw Exp $	*/
d61 1
d154 1
a154 1
			warning("Corrupt lease file - possible data loss!");
d482 1
a482 1
		error("no memory for lease.");
d770 1
a770 1
				warning("Bad format %c in parse_option_param.",
d786 1
a786 1
		error("out of memory allocating option data.");
d805 1
a805 1
			error("no memory for reject address!");
@


1.102
log
@Zap stray whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.101 2016/09/01 13:27:04 krw Exp $	*/
a468 1
	struct option_data	*opt1, *opt2;
d497 3
a499 15
	 * If the new lease is for an obsolete client-identifier, toss it.
	 */
	opt1 = &lease->options[DHO_DHCP_CLIENT_IDENTIFIER];
	opt2 = &config->send_options[DHO_DHCP_CLIENT_IDENTIFIER];
	if (opt1->len && opt2->len && (opt1->len != opt2->len ||
	    memcmp(opt1->data, opt2->data, opt1->len))) {
		note("Obsolete client identifier (%s) in recorded lease",
		    pretty_print_option(DHO_DHCP_CLIENT_IDENTIFIER, opt1, 0));
		free_client_lease(lease);
		return;
	}

	/*
	 * The new lease will supersede a lease of the same type and for
	 * the same address or the same SSID.
d504 15
a518 6
		if ((strcmp(lp->ssid, ifi->ssid) == 0) ||
		    (lp->address.s_addr == lease->address.s_addr)) {
			TAILQ_REMOVE(&client->leases, lp, next);
			lp->is_static = 0;	/* Else it won't be freed. */
			free_client_lease(lp);
		}
@


1.101
log
@Cut back the default values for the various timeout/interval values. We no
longer live in a 10Mb/sec shared media world with 1Mhz Vaxen DHCP servers.

ok benno@@ otto@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.100 2016/09/01 10:29:16 krw Exp $	*/
d505 1
a505 1
		    pretty_print_option( DHO_DHCP_CLIENT_IDENTIFIER, opt1, 0));
@


1.100
log
@Informative comments describing the various timing fields (initial_interval,
reboot_timeout, etc.) when setting them to their defaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.99 2016/08/31 12:57:31 mpi Exp $	*/
d88 1
a88 1
	config->timeout = 60;		/* secs to wait for an OFFER */
d91 3
a93 3
	config->retry_interval = 300;	/* secs before asking for OFFER */
	config->backoff_cutoff = 15;	/* max secs between packet retries */
	config->initial_interval = 3;	/* secs before 1st retry */
@


1.99
log
@Remove the 'client' global and make it per-ifp.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.98 2016/08/23 09:26:02 mpi Exp $	*/
d87 8
a94 7
	config->link_timeout = 10;
	config->timeout = 60;
	config->select_interval = 0;
	config->reboot_timeout = 1;
	config->retry_interval = 300;
	config->backoff_cutoff = 15;
	config->initial_interval = 3;
@


1.98
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.97 2016/08/16 21:57:51 krw Exp $	*/
d466 1
@


1.97
log
@Track SSID in leases file and only consider leases from the current SSID when
starting up dhclient on wifi interfaces. In theory will preserve leases from
other SSID's and speed up obtaining a lease by not wasting time attempting
to re-acquire a lease from a different SSID.

Experimental feature from n2k16 needing some real world testing before g2k16.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.96 2016/07/31 18:55:16 krw Exp $	*/
d62 1
a62 1
void parse_client_statement(FILE *);
d65 4
a68 3
void parse_interface_declaration(FILE *);
void parse_client_lease_statement(FILE *, int);
void parse_client_lease_declaration(FILE *, struct client_lease *);
d79 1
a79 1
read_client_conf(void)
d124 1
a124 1
			parse_client_statement(cfile);
d136 1
a136 1
read_client_leases(void)
d155 1
a155 1
		parse_client_lease_statement(cfile, 0);
d184 1
a184 1
parse_client_statement(FILE *cfile)
d265 1
a265 1
		parse_interface_declaration(cfile);
d268 1
a268 1
		parse_client_lease_statement(cfile, 1);
d415 1
a415 1
parse_interface_declaration(FILE *cfile)
d449 1
a449 1
		parse_client_statement(cfile);
d464 1
a464 1
parse_client_lease_statement(FILE *cfile, int is_static)
d491 1
a491 1
		parse_client_lease_declaration(cfile, lease);
d548 2
a549 1
parse_client_lease_declaration(FILE *cfile, struct client_lease *lease)
@


1.96
log
@Ask for DHO_BOOTFILE_NAME and DHO_TFTP_SERVER by default. May prove
useful to autoinstall in the future and in the meantime can provide
information on what the dhcp server has done with the desired server
name and file name info.

Original diff from Patrik Lundin via tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.95 2016/06/03 02:31:17 tedu Exp $	*/
d509 1
a509 1
	 * the same address.
d512 4
a515 2
		if (lp->address.s_addr == lease->address.s_addr &&
		    lp->is_static == is_static) {
d589 6
@


1.95
log
@The networks I use are sufficiently fast that a 10 second "reboot" timeout
is not necessary, and in fact quite annoying when I swtich networks and
want to get back to the init state quickly. Default instead to 1 second.
The very few users who encounter problems may edit dhclient.conf.
ok benno
krw does not object
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.94 2016/02/06 19:30:52 krw Exp $	*/
d113 4
@


1.94
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.93 2015/10/26 16:32:33 krw Exp $	*/
d89 1
a89 1
	config->reboot_timeout = 10;
@


1.93
log
@Give dhclient(8) the ability to use option 119, a.k.a. "Domain
Search" if supplied by the server.

Requested by a few. Original diff from Ray Lai via tech@@.

Tested & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.92 2015/05/18 17:51:21 krw Exp $	*/
d43 16
@


1.92
log
@Tweak parsing so that hostnames starting with 0-9 are accepted.

Reported long ago by matthieu@@. Also Jacob Berkman via the lists.

Tests and suggestions from Jacob and Matthieu.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.91 2015/02/01 18:43:39 krw Exp $	*/
d91 2
@


1.91
log
@free(NULL) works, so stop checking for non-zero length allocation
or non-NULLness before calling free().

This batch from Benjamin Baier.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.90 2014/11/03 22:06:39 krw Exp $	*/
d289 1
a289 1
	if (token == TOK_NUMBER_OR_NAME || token == TOK_NUMBER) {
@


1.90
log
@Don't leak static leases when the 'lease {}' parsing fails or one static
lease supersedes an earlier one.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.89 2014/11/02 15:18:32 krw Exp $	*/
d257 1
a257 2
		if (config->filename)
			free(config->filename);
d262 1
a262 2
		if (config->server_name)
			free(config->server_name);
@


1.89
log
@Pesky whitespace and spurious parenthesis.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.88 2014/10/27 13:36:21 krw Exp $	*/
a460 1
	lease->is_static = is_static;
d493 1
a493 1
		    lp->is_static == lease->is_static) {
d495 1
d500 6
@


1.88
log
@Zap extraneous whitespace and a stuttered extra 'break;'.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.87 2014/05/12 13:12:41 krw Exp $	*/
d666 1
a666 1
 			case 'l':	/* Signed 32-bit integer. */
@


1.87
log
@Since all static leases are in one file, /etc/dhclient.conf, there is no
'wrong interface' specification. So display that error message only for
non-static leases. i.e. when reading /var/db/dhclient.leases.<if>.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.86 2014/05/11 12:40:37 krw Exp $	*/
d132 1
a132 1
	       	parse_client_lease_statement(cfile, 0);
@


1.86
log
@Rework/restore recorded lease handling. Actually use 'lease'
statements in dhclient.conf.

Recorded and static leases should now be bound to interfaces when
appropriate.

.... Ken
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.85 2014/05/05 18:02:49 krw Exp $	*/
d539 2
a540 1
			parse_warn("wrong interface name.");
@


1.85
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.84 2014/05/05 14:44:18 krw Exp $	*/
d489 2
a490 4
	 * The new lease may supersede a lease that's not the active
	 * lease but is still on the lease list, so scan the lease list
	 * looking for a lease with the same address, and if we find it,
	 * toss it.
d493 2
a494 1
		if (lp->address.s_addr == lease->address.s_addr) {
d500 4
a503 37
	/*
	 * If this is a preloaded lease, just put it on the list of
	 * recorded leases - don't make it the active lease.
	 */
	if (is_static) {
		TAILQ_INSERT_HEAD(&client->leases, lease, next);
		return;
	}

	/*
	 * The last lease in the lease file on a particular interface is
	 * the active lease for that interface.    Of course, we don't
	 * know what the last lease in the file is until we've parsed
	 * the whole file, so at this point, we assume that the lease we
	 * just parsed is the active lease for its interface.   If
	 * there's already an active lease for the interface, and this
	 * lease is for the same ip address, then we just toss the old
	 * active lease and replace it with this one.   If this lease is
	 * for a different address, then if the old active lease has
	 * expired, we dump it; if not, we put it on the list of leases
	 * for this interface which are still valid but no longer
	 * active.
	 */
	if (client->active) {
		if (client->active->expiry < time(NULL))
			free_client_lease(client->active);
		else if (client->active->address.s_addr ==
		    lease->address.s_addr)
			free_client_lease(client->active);
		else {
			TAILQ_INSERT_HEAD(&client->leases, client->active,
			    next);
		}
	}
	client->active = lease;

	/* Phew. */
@


1.84
log
@A couple of malloc()+memset(0) -> calloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.83 2014/01/25 05:21:23 krw Exp $	*/
d168 1
a168 1
	
@


1.83
log
@Correct parsing of dhclient.conf statements 'fixed-address' and
'next-server'. Modify new lease being cloned with their values
rather than overwriting original lease being cloned.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.82 2014/01/21 05:17:45 krw Exp $	*/
d457 1
a457 1
	lease = malloc(sizeof(struct client_lease));
d460 1
a460 1
	memset(lease, 0, sizeof(*lease));
a461 1

@


1.82
log
@Allow dhclient.conf to specify 'fixed-address', 'next-server',
'filename' and 'server-name'. dhclient.conf can now override anything
in an offer or saved lease when creating the effective lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.81 2014/01/21 03:07:50 krw Exp $	*/
d268 2
a269 1
		parse_ip_addr(cfile, &config->address);
d272 2
a273 1
		parse_ip_addr(cfile, &config->next_server);
@


1.81
log
@Add parsing for options 121 (classless-static-routes) and 249
(classless-ms-static-routes). dhcpd can now specify and serve
these options and dhclient can recognize and use supersede, etc.
statements on them.

Based on a diff from Stefan Rinke. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.80 2014/01/20 01:12:17 krw Exp $	*/
d164 1
d254 18
@


1.80
log
@Don't silently skip the next statement when encountering an
invalid IP in a reject statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.79 2014/01/20 00:36:52 krw Exp $	*/
d603 1
d740 6
@


1.79
log
@Cast pointer to (u_int8_t *) when assigning it to a u_int8_t *
variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.78 2014/01/19 21:10:04 krw Exp $	*/
d771 1
a771 2
		if (!parse_ip_addr(cfile, &addr)) {
			skip_to_semi(cfile);
a772 1
		}
@


1.78
log
@We don't have any (and I can't find elsewhere) signed 16 bit or
signed 8 bit dhcp option types. So nuke getShort() and all 's' and
'b' format support. While here use '%u'/'%lu' and not
'%d'/'%ld' to snprintf() unsigned values.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.77 2014/01/19 08:25:54 krw Exp $	*/
d667 1
a667 1
				dp = (char *)&ip_addr;
@


1.77
log
@Redo the parsing of numbers to improve the error messages and
make the code more readable. And prepare for some new things
that will need to be parsed.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.76 2014/01/19 04:36:04 krw Exp $	*/
a697 10
			case 's':	/* Signed 16-bit integer. */
				if (!parse_decimal(cfile, buf, *fmt)) {
					parse_warn("expecting signed 16-bit "
					    "integer.");
					skip_to_semi(cfile);
					return (-1);
				}
				len = 2;
				dp = buf;
				goto alloc;
a705 10
				dp = buf;
				goto alloc;
			case 'b':	/* Signed 8-bit integer. */
				if (!parse_decimal(cfile, buf, *fmt)) {
					parse_warn("expecting signed 8-bit "
					    "integer.");
					skip_to_semi(cfile);
					return (-1);
				}
				len = 1;
@


1.76
log
@Rename parse_hardware_param() to parse_ethernet() to reflect what
it actually does.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.75 2014/01/18 01:19:01 krw Exp $	*/
d272 18
a289 19
		do {
			token = next_token(&val, cfile);
			if (token != TOK_NUMBER && token !=
			    TOK_NUMBER_OR_NAME) {
				parse_warn("expecting hexadecimal constant.");
				if (token != ';')
					skip_to_semi(cfile);
				return (-1);
			}
			convert_num(&buf[len], val, 16, 8);
			if (len++ > max) {
				parse_warn("hexadecimal constant too long.");
				skip_to_semi(cfile);
				return (-1);
			}
			token = peek_token(&val, cfile);
			if (token == ':')
				token = next_token(&val, cfile);
		} while (token == ':');
d300 1
d678 10
d689 4
a692 7
			case 'l':	/* Signed 32-bit integer. */
				token = next_token(&val, cfile);
				if (token != TOK_NUMBER) {
need_number:
					parse_warn("expecting number.");
					if (token != ';')
						skip_to_semi(cfile);
a694 1
				convert_num(buf, val, 0, 32);
d699 9
d709 6
a714 4
				token = next_token(&val, cfile);
				if (token != TOK_NUMBER)
					goto need_number;
				convert_num(buf, val, 0, 16);
d719 9
d729 6
a734 4
				token = next_token(&val, cfile);
				if (token != TOK_NUMBER)
					goto need_number;
				convert_num(buf, val, 0, 8);
a791 1
			parse_warn("expecting IP address.");
@


1.75
log
@Remove superfluous assignment to local variable 'val' just before
exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.74 2014/01/18 01:03:56 krw Exp $	*/
d193 1
a193 1
		parse_hardware_param(cfile, &ifi->hw_address);
@


1.74
log
@Make parse_warn() messages consistantly use 'expecting' rather
than occasionally 'expected'. End all with a '.'.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.73 2014/01/18 00:51:55 krw Exp $	*/
a290 1
		val = (char *)buf;
@


1.73
log
@Never silently consume the following statement when unexpectedly
encountering a ';'. I.e. when checking the token type, 'skip_to_semi()'
after 'parse_warn()' only when the parsed token wasn't a ';'.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.72 2014/01/17 22:48:10 krw Exp $	*/
d330 1
a330 1
			parse_warn("expected option name.");
d343 1
a343 1
			parse_warn("unexpected option name.");
@


1.72
log
@Make parse_X return -1 when it encounters a parsing error. Enables
recognition of zero length value vs parsing error. This lets us avoid
the erroneous consumption of the semicolon ending the 'X' value, and
the resulting accidental consumption of the following line in the file
being parsed.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.71 2014/01/13 23:42:18 krw Exp $	*/
d164 1
a164 1
	int code, count;
d166 3
a168 1
	switch (next_token(NULL, cfile)) {
d256 2
a257 1
		skip_to_semi(cfile);
d277 2
a278 1
				skip_to_semi(cfile);
d303 2
a304 1
		skip_to_semi(cfile);
d364 2
a365 1
	skip_to_semi(cfile);
d382 2
a383 1
		skip_to_semi(cfile);
d395 2
a396 1
		skip_to_semi(cfile);
d432 2
a433 1
		skip_to_semi(cfile);
d539 3
a541 1
	switch (next_token(&val, cfile)) {
d549 2
a550 1
			skip_to_semi(cfile);
d590 2
a591 1
		skip_to_semi(cfile);
d649 2
a650 1
					skip_to_semi(cfile);
@


1.71
log
@peek_token() a bit more to replace a bunch of manual checks with
the perfectly adequate parse_semi(). And some blocks didn't even
need to peek.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.70 2014/01/13 21:36:46 krw Exp $	*/
d275 1
a275 1
				return (0);
d281 1
a281 1
				return (0);
d294 1
a294 1
			return (0);
d300 1
a300 1
		return (0);
d628 2
@


1.70
log
@Don't eat another token looking for a ';' after skip_to_semi() has
been invoked. Fixes silent loss of the statement following a broken or
inapplicable 'interface' declaration in a lease, or an unrecognized
lease attribute.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.69 2014/01/13 21:04:19 krw Exp $	*/
d350 3
a352 1
		token = next_token(&val, cfile);
d354 3
a356 5
	if (token != ';') {
		parse_warn("expecting semicolon.");
		goto syntaxerror;
	}
	return (ix);
d581 2
a582 5
	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
	}
d724 3
a726 1
		token = next_token(&val, cfile);
d729 1
a729 3
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
a730 1
	}
d761 3
a763 1
		token = next_token(NULL, cfile);
d766 1
a766 4
	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
	}
@


1.69
log
@No need to 'clear the peek buffer' when closing a file. The next
file opener will call new_parse() to initialize that amoung
other things. Nuke extraneous blank line in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.68 2014/01/12 04:17:36 krw Exp $	*/
d539 1
a539 1
			break;
d544 1
a544 1
			break;
d579 1
a579 1
		break;
@


1.68
log
@Since the return value of read_client_conf() is not checked, don't
bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.67 2014/01/10 01:25:03 krw Exp $	*/
a102 1
		token = next_token(NULL, cfile); /* Clear the peek buffer */
a132 1

@


1.67
log
@skip_to_semi() is gilding the lily when the next statement breaks out
of the loop and closes the file being parsed. And the previous
statement warns the user the leases file being parsed has been
determined to be corrupt. Eliminate further gilding in the form of an
'else' after the same 'if' clause includes the 'break'.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.66 2014/01/10 01:07:58 krw Exp $	*/
d61 1
a61 1
int
a105 2

	return (!warnings_occurred);
@


1.66
log
@KNF (UNF?). Split annoying long line.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.65 2013/12/30 03:36:17 krw Exp $	*/
a132 1
			skip_to_semi(cfile);
d134 2
a135 2
		} else
			parse_client_lease_statement(cfile, 0);
@


1.65
log
@Replace yet another hand-rolled list with a TAILQ. reject_list this
time.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.64 2013/12/28 21:48:04 krw Exp $	*/
d276 2
a277 1
			if (token != TOK_NUMBER && token != TOK_NUMBER_OR_NAME) {
@


1.64
log
@Remove unused variable 'token'. Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.63 2013/12/22 02:37:25 krw Exp $	*/
d751 1
a751 1
	struct reject_elem *list;
d762 6
a767 7
		list = malloc(sizeof(struct reject_elem));
		if (!list)
			error("no memory for reject list!");

		list->addr = addr;
		list->next = config->reject_list;
		config->reject_list = list;
@


1.63
log
@Don't look for two semi-colons when encountering an unrecognized
statement in dhclient.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.62 2013/11/11 21:00:01 krw Exp $	*/
d169 1
a169 1
	int token, code, count;
@


1.62
log
@Shuffle function prototypes and extern declarations around to
put local functions prototypes and variables in their .c files, and
cross-file functions into .h files. Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.61 2013/10/22 18:15:58 krw Exp $	*/
d174 1
a174 1
		return;
d179 1
a179 1
		return;
d184 1
a184 1
		return;
d189 1
a189 1
		return;
d194 1
a194 4
		return;
	case TOK_MEDIA:
		skip_to_semi(cfile);
		return;
d197 1
a197 1
		return;
d205 1
a205 1
		return;
d213 1
a213 1
		return;
d221 1
a221 1
		return;
d224 1
a224 1
		return;
d227 1
a227 1
		return;
d230 1
a230 1
		return;
d233 1
a233 1
		return;
d236 1
a236 1
		return;
d239 1
a239 1
		return;
d242 1
a242 1
		return;
d245 1
a245 1
		return;
d248 1
a248 1
		return;
d250 2
d253 1
a253 1
		return;
d256 1
a256 1
		return;
a260 5
	}
	token = next_token(NULL, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
@


1.61
log
@Save 'next-server' (a.k.a. siaddr) info in leases file. Saving the
file name without the server address seems silly.

Tested & ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.60 2013/06/09 16:21:50 krw Exp $	*/
d45 9
@


1.60
log
@Re-apply static route and classless static route support -- this time
passing the correct destination for the default route, '0.0.0.0', rather
than the new lease address.

Populating egress group works this time.

Problem found the hard way by Chris Smith.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.59 2013/06/09 00:30:06 krw Exp $	*/
d550 4
@


1.59
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.58 2013/06/04 21:04:51 krw Exp $	*/
d75 3
@


1.58
log
@Add support for static routes option (33) and classless static
routes option (121).

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.57 2013/05/02 16:35:27 krw Exp $	*/
a74 3
	/* RFC 3442 says CLASSLESS_STATIC_ROUTES must be before ROUTERS! */
	config->requested_options
	    [config->requested_option_count++] = DHO_CLASSLESS_STATIC_ROUTES;
@


1.57
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.56 2013/05/02 14:48:35 krw Exp $	*/
d75 3
@


1.56
log
@Enough of the hand-rolling of queues. Turn client->leases and
client->offered_leases into TAILQs.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.55 2013/03/22 23:58:51 krw Exp $	*/
d3 1
a3 1
/* Parser for dhclient config and lease files... */
d60 1
a60 1
	/* Set some defaults... */
d616 1
a616 1
	/* Parse the option data... */
d627 1
a627 1
			case 't': /* Text string... */
d660 2
a661 2
			case 'L':	/* Unsigned 32-bit integer... */
			case 'l':	/* Signed 32-bit integer... */
@


1.55
log
@Ignore client-identifier option in leases from a server. They're not supposed
to be there! Instead, always record the client-identifier used to obtain
the lease. Ignore recorded leases that have a different client-identifier
than the one currently in force. If a client-identifier is not specified
in the dhclient.conf file, construct one from the network type and
MAC, like most other clients out there do these days.

Thus, if one plugs in a different USB network adapter, renewing the
previous lease (which upsets servers due to the MAC being different)
is skipped and DISCOVER is attempted at once.

Issue noted and fix tested by tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.54 2013/03/21 12:41:12 krw Exp $	*/
d464 1
a464 2
	pl = NULL;
	for (lp = client->leases; lp; lp = lp->next) {
d466 1
a466 4
			if (pl)
				pl->next = lp->next;
			else
				client->leases = lp->next;
d468 1
a468 3
			break;
		} else
			pl = lp;
d476 1
a476 2
		lease->next = client->leases;
		client->leases = lease;
d501 2
a502 2
			client->active->next = client->leases;
			client->leases = client->active;
@


1.54
log
@Free lease with free_client_lease() rather than free().
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.53 2013/02/09 23:37:21 krw Exp $	*/
d416 1
d444 13
@


1.53
log
@As tedu@@ pointed out a while ago, it makes little sense to discard
an option list if it contains duplicate option names. Just ignore
the duplicates.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.52 2013/02/01 20:44:00 florian Exp $	*/
d435 1
a435 1
			free(lease);
@


1.52
log
@do not leak lease in error path; found by llvm
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.51 2013/01/02 01:06:57 krw Exp $	*/
d344 4
a347 7
		for (j = 0; j < ix; j++) {
			if (list[j] == i) {
				parse_warn("option in list more than once.");
				goto syntaxerror;
			}
		}
		list[ix++] = i;
@


1.51
log
@Delete misleading comment and a pointless check of !ifi. Since ifi
is either successfully calloc'd or dhclient dies early.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.50 2012/12/04 19:24:02 krw Exp $	*/
d438 1
@


1.50
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.49 2012/11/27 18:52:39 krw Exp $	*/
a444 8

	/* If the lease declaration didn't include an interface
	 * declaration that we recognized, it's of no use to us.
	 */
	if (!ifi) {
		free_client_lease(lease);
		return;
	}
@


1.49
log
@Clean up parsing of option lists. Part 7 (and final).

Allow 'request ;', 'require ;' and 'ignore ;' as requests to create
empty lists of options. Thus enabling the removal of built-in lists
or the removal of global lists inside an 'interface' declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.48 2012/11/27 15:51:48 krw Exp $	*/
d336 1
a336 1
			parse_warn("%s: unexpected option name.", val);
d340 1
a340 1
			parse_warn("%s: too many options.", val);
d346 1
a346 2
				parse_warn("%s: option in list more than once.",
				    val);
d543 1
a543 2
			parse_warn("wrong interface name. Expecting '%s'.",
			   ifi->name);
d614 1
a614 1
		parse_warn("no option named %s", val);
d639 1
a639 1
					parse_warn("option data buffer %s",
@


1.48
log
@Clean up parsing of option lists. Part 6.

Treat 'ignore' option lists the same as 'request' and 'require'
option lists. i.e.  keep a list of the options rather than using
an ACTION flag. So overriding a previous ignore list will not leave
breadcrumbs and incorrect ACTIONs lying around.

The list will be applied when the new lease is created, and will
override any ACTION specified for the option.

Mention in dhclient.conf(5) that each request/require/ignore statement
will override any previous one.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.47 2012/11/27 14:14:16 krw Exp $	*/
d191 1
a191 1
		if (count > 0) {
d199 1
a199 1
		if (count > 0) {
d207 1
a207 1
		if (count > 0) {
d318 4
d324 1
a324 2
			skip_to_semi(cfile);
			return (0);
d337 1
a337 2
			skip_to_semi(cfile);
			return (0);
d341 1
a341 2
			skip_to_semi(cfile);
			return (0);
d348 1
a348 2
				skip_to_semi(cfile);
				return (0);
d356 1
a356 2
		skip_to_semi(cfile);
		return (0);
d359 4
@


1.47
log
@Clean up parsing of option lists. Part 5.

Don't toss away an existing request/require list unless the new
list is successfully parsed.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.46 2012/11/25 16:45:31 krw Exp $	*/
d157 1
a157 1
	int token, code, count, i;
a172 5
	case TOK_IGNORE:
		count = parse_option_list(cfile, optlist, sizeof(optlist));
		for (i = 0; i < count; i++)
			config->default_actions[optlist[i]] = ACTION_IGNORE;
		return;
d203 8
@


1.46
log
@Clean up parsing of option lists. Part 3.

Storing an option in a list more than once is silly, wastes space
and is possibly confusing to sensitive dhcp servers. Make it a
syntax error to attempt to store an option in a list more than once.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.45 2012/11/25 14:56:55 krw Exp $	*/
d156 1
a156 1
	u_int8_t ignorelist[256];
d174 1
a174 2
		count = parse_option_list(cfile, ignorelist,
		    sizeof(ignorelist));
d176 1
a176 1
			config->default_actions[ignorelist[i]] = ACTION_IGNORE;
d195 6
a200 3
		config->requested_option_count = parse_option_list(cfile,
		    config->requested_options,
		    sizeof(config->requested_options));
d203 6
a208 3
		config->required_option_count = parse_option_list(cfile,
		    config->required_options,
		    sizeof(config->required_options));
@


1.45
log
@Clean up parsing of option lists. Part 2.

DHO_PAD ("pad") and DHO_END ("option-end") are not really options
and it makes no sense to require, request, or ignore them. And
probably would confuse some sensitive dhcp servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.44 2012/11/25 12:49:56 krw Exp $	*/
d302 1
a302 1
	int	 ix, i;
d333 9
@


1.44
log
@Clean up parsing of option lists. Part 1.

1) Add config->required_options_count so that syntactically incorrect
request statement in dhclient.conf is completely ignored.
2) Pass size of buffer being filled instead of assuming 256.
3) Always zero (a.k.a. DHO_PAD) the passed in buffer.
4) Check for out of bounds index before using it, not after.

Add TOK_IGNORE to syntax in comment.

No intentional functional change other than catching bad request
statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.43 2012/11/08 21:32:55 krw Exp $	*/
d315 6
a320 1
		for (i = 0; i < 256; i++)
d324 1
a324 1
		if (i == 256) {
@


1.43
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.42 2012/10/30 18:39:44 krw Exp $	*/
d141 1
d174 2
a175 1
		count = parse_option_list(cfile, ignorelist);
d196 3
a198 2
		config->requested_option_count =
			parse_option_list(cfile, config->requested_options);
d201 2
a202 1
		memset(config->required_options, 0,
a203 1
		parse_option_list(cfile, config->required_options);
d300 1
a300 1
parse_option_list(FILE *cfile, u_int8_t *list)
d306 1
d324 1
a324 2
		list[ix++] = i;
		if (ix == 256) {
d329 1
@


1.42
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.41 2012/10/27 23:08:53 krw Exp $	*/
d434 1
a434 1
		if (addr_eq(lp->address, lease->address)) {
d472 2
a473 1
		else if (addr_eq(client->active->address, lease->address))
d567 1
a567 1
	struct iaddr	 ip_addr;
d624 2
a625 2
				len = ip_addr.len;
				dp = ip_addr.iabuf;
d717 2
a718 2
	struct iaddrlist *list;
	struct iaddr addr;
d728 1
a728 1
		list = malloc(sizeof(struct iaddrlist));
@


1.41
log
@Change dhclient.conf directive 'ignore' to take a list of option names
rather than list of option declarations. e.g. 'ignore routers;'
instead of 'ignore routers 1.2.3.4;' The value in the declaration
was being ignored anyway.

While there clean up the related code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.40 2012/08/26 23:33:29 krw Exp $	*/
a68 1
	config->script_name = _PATH_DHCLIENT_SCRIPT;
a146 1
 *	TOK_SCRIPT string |
a221 3
		return;
	case TOK_SCRIPT:
		config->script_name = parse_string(cfile);
@


1.40
log
@Junk global cur_time, and use time(NULL) or local variables where
time is checked multiple times. Add a set_timeout_interval() function
to allow setting a timeout based on an interval from current time.

Fixes issues with initial startup where the global cur_time was
always old and caused initial DHCPDISCOVER or DHCPREQUEST packets
to be sent multiple times. And probably other timeout related
oddities.

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.39 2012/08/22 00:14:42 tedu Exp $	*/
d157 2
a158 1
	int token, code;
d175 3
a177 3
		code = parse_option_decl(cfile, &config->defaults[0]);
		if (code != -1)
			config->default_actions[code] = ACTION_IGNORE;
@


1.39
log
@add ignore keyword to conf file, allowing one to ignore unwanted info
from the server without necessarily speciyfing a supersede value
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.38 2011/12/10 17:15:27 krw Exp $	*/
d474 1
a474 1
		if (client->active->expiry < cur_time)
@


1.38
log
@Tweak parsing. No need to declare, assign and then ignore the token
value when only the token id is required.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.37 2011/04/04 11:14:52 krw Exp $	*/
d172 5
@


1.37
log
@Dump some useless calls to dhclient-script. i.e. MEDIUM, PREINIT,
ARPSEND, ARPCHECK. Drop support for 'media', 'medium' and 'alias'
specifications in dhclient.conf. Old leases still parse but these
options now have no effect.

Be more polite and decline all offers we don't accept. Fix a IMSG
length check.

Many expressions of support at various bars.

ok henning@@ deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.36 2009/07/19 00:18:02 stevesk Exp $	*/
a55 1
	char *val;
d87 1
a87 1
			token = peek_token(&val, cfile);
d92 1
a92 1
		token = next_token(&val, cfile); /* Clear the peek buffer */
a107 1
	char	*val;
d117 1
a117 1
		token = next_token(&val, cfile);
a156 1
	char *val;
d159 1
a159 1
	switch (next_token(&val, cfile)) {
d239 1
a239 1
	token = next_token(&val, cfile);
a390 1
	char			*val;
d392 1
a392 1
	token = next_token(&val, cfile);
d406 1
a406 1
		token = peek_token(&val, cfile);
d415 1
a415 1
	token = next_token(&val, cfile);
a716 1
	char *val;
d734 1
a734 1
		token = next_token(&val, cfile);
@


1.36
log
@use addr_eq() where we can; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.35 2009/05/27 15:04:34 stevesk Exp $	*/
d187 1
a187 1
		parse_string_list(cfile, &config->media, 1);
d232 1
a232 1
		parse_client_lease_statement(cfile, 2);
a428 6
	/* If this is an alias lease, it doesn't need to be sorted in. */
	if (is_static == 2) {
		client->alias = lease;
		return;
	}

d528 1
a528 1
		parse_string_list(cfile, &lease->medium, 0);
a713 44
}

void
parse_string_list(FILE *cfile, struct string_list **lp, int multiple)
{
	int			 token;
	char			*val;
	struct string_list	*cur, *tmp;

	/* Find the last medium in the media list. */
	if (*lp)
		for (cur = *lp; cur->next; cur = cur->next)
			;	/* nothing */
	else
		cur = NULL;

	do {
		token = next_token(&val, cfile);
		if (token != TOK_STRING) {
			parse_warn("Expecting media options.");
			skip_to_semi(cfile);
			return;
		}

		tmp = malloc(sizeof(struct string_list) + strlen(val));
		if (tmp == NULL)
			error("no memory for string list entry.");
		strlcpy(tmp->string, val, strlen(val) + 1);
		tmp->next = NULL;

		/* Store this medium at the end of the media list. */
		if (cur)
			cur->next = tmp;
		else
			*lp = tmp;
		cur = tmp;

		token = next_token(&val, cfile);
	} while (multiple && token == ',');

	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
	}
@


1.35
log
@add missing else; from ISC.
this fixes an old, old bug that could cause lease entries to be lost
when initially loading client leases.  found while looking for another
issue.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.34 2007/02/14 23:19:26 deraadt Exp $	*/
d443 1
a443 3
		if (lp->address.len == lease->address.len &&
		    !memcmp(lp->address.iabuf, lease->address.iabuf,
		    lease->address.len)) {
d481 1
a481 4
		else if (client->active->address.len ==
		    lease->address.len &&
		    !memcmp(client->active->address.iabuf,
		    lease->address.iabuf, lease->address.len))
@


1.34
log
@spacing and a typo that fell out of the read
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.33 2006/12/27 20:56:33 krw Exp $	*/
d452 2
a453 1
		}
@


1.33
log
@Since we only have the single global struct interface_info, we
obviously have single global struct client_state and struct
client_config nested inside interface_info and client_state
respectively.

Pull them out to their own global variables and eliminate a bunch
(i.e. hundreds) of multi-level dereferences. Make it much nicer to
read.

No functional change.

"makes sense" henning@@

Testing stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.32 2006/12/26 21:19:52 krw Exp $	*/
d138 1
a138 1
 *	TOK_APPEND option-decl 
@


1.32
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.31 2006/12/16 15:13:45 stevesk Exp $	*/
a54 1
	struct client_config *config = ifi->client->config;
a158 1
	struct client_config *config = ifi->client->config;
d431 1
a431 1
		ifi->client->alias = lease;
d442 1
a442 1
	for (lp = ifi->client->leases; lp; lp = lp->next) {
d449 1
a449 1
				ifi->client->leases = lp->next;
d460 2
a461 2
		lease->next = ifi->client->leases;
		ifi->client->leases = lease;
d479 4
a482 4
	if (ifi->client->active) {
		if (ifi->client->active->expiry < cur_time)
			free_client_lease(ifi->client->active);
		else if (ifi->client->active->address.len ==
d484 1
a484 1
		    !memcmp(ifi->client->active->address.iabuf,
d486 1
a486 1
			free_client_lease(ifi->client->active);
d488 2
a489 2
			ifi->client->active->next = ifi->client->leases;
			ifi->client->leases = ifi->client->active;
d492 1
a492 1
	ifi->client->active = lease;
a772 1
	struct client_config *config = ifi->client->config;
@


1.31
log
@make /sbin/dhclient-script consistent with other paths; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.30 2006/12/15 14:56:38 stevesk Exp $	*/
a45 2
extern struct interface_info *ifi;

a394 1
	struct interface_info	*ip = ifi;
d419 1
a419 1
		parse_client_lease_declaration(cfile, lease, &ip);
d426 1
a426 1
	if (!ip) {
d433 1
a433 1
		ip->client->alias = lease;
d444 1
a444 1
	for (lp = ip->client->leases; lp; lp = lp->next) {
d451 1
a451 1
				ip->client->leases = lp->next;
d462 2
a463 2
		lease->next = ip->client->leases;
		ip->client->leases = lease;
d481 4
a484 4
	if (ip->client->active) {
		if (ip->client->active->expiry < cur_time)
			free_client_lease(ip->client->active);
		else if (ip->client->active->address.len ==
d486 1
a486 1
		    !memcmp(ip->client->active->address.iabuf,
d488 1
a488 1
			free_client_lease(ip->client->active);
d490 2
a491 2
			ip->client->active->next = ip->client->leases;
			ip->client->leases = ip->client->active;
d494 1
a494 1
	ip->client->active = lease;
d512 1
a512 2
parse_client_lease_declaration(FILE *cfile, struct client_lease *lease,
    struct interface_info **ipp)
a533 1
		*ipp = ifi;
@


1.30
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.29 2006/05/08 17:25:59 deraadt Exp $	*/
a47 2
char client_script_name[] = "/sbin/dhclient-script";

d73 1
a73 1
	config->script_name = client_script_name;
@


1.29
log
@add 'link-timeout n' seconds option to grammer, from fkr@@hazardous.org
default remains 10 seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.28 2006/04/20 15:54:34 deraadt Exp $	*/
d603 1
a603 1
	for (code=0; code < 256; code++)
@


1.28
log
@adjust comments as to what keywords are legal; from fkr
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.27 2006/04/18 19:17:54 deraadt Exp $	*/
d67 1
d206 3
@


1.27
log
@cleanup keyword lookup for the lexer, and remove keywords not valid in
either dhclient or dhcpd context; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.26 2005/08/02 02:34:03 krw Exp $	*/
d139 6
a144 5
 *	SEND option-decl |
 *	DEFAULT option-decl |
 *	SUPERSEDE option-decl |
 *	PREPEND option-decl |
 *	APPEND option-decl |
d146 9
a154 7
 *	REQUEST option-list |
 *	REQUIRE option-list |
 *	TIMEOUT number |
 *	RETRY number |
 *	REBOOT number |
 *	SELECT_TIMEOUT number |
 *	SCRIPT string |
d156 3
a158 2
 *	LEASE client-lease-statement |
 *	ALIAS client-lease-statement
@


1.26
log
@Rip out code dealing with multiple/nested interfaces. Each instance of
dhclient is responsible for one interface. Simply skip interface
declarations for other interfaces and store all info in the one
interface structure.

tested by dlg@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.25 2005/07/16 18:38:45 krw Exp $	*/
d126 1
a126 1
		if (token != LEASE) {
d164 1
a164 1
	case SEND:
d167 1
a167 1
	case DEFAULT:
d172 1
a172 1
	case SUPERSEDE:
d177 1
a177 1
	case APPEND:
d182 1
a182 1
	case PREPEND:
d187 1
a187 1
	case MEDIA:
d190 1
a190 1
	case HARDWARE:
d193 1
a193 1
	case REQUEST:
d197 1
a197 1
	case REQUIRE:
d202 1
a202 1
	case TIMEOUT:
d205 1
a205 1
	case RETRY:
d208 1
a208 1
	case SELECT_TIMEOUT:
d211 1
a211 1
	case REBOOT:
d214 1
a214 1
	case BACKOFF_CUTOFF:
d217 1
a217 1
	case INITIAL_INTERVAL:
d220 1
a220 1
	case SCRIPT:
d223 1
a223 1
	case INTERFACE:
d226 1
a226 1
	case LEASE:
d229 1
a229 1
	case ALIAS:
d232 1
a232 1
	case REJECT:
d241 1
a241 1
	if (token != SEMI) {
d255 1
a255 1
	if (token == NUMBER_OR_NAME || token == NUMBER) {
d259 1
a259 1
			if (token != NUMBER && token != NUMBER_OR_NAME) {
d271 1
a271 1
			if (token == COLON)
d273 1
a273 1
		} while (token == COLON);
d275 1
a275 1
	} else if (token == STRING) {
d327 2
a328 2
	} while (token == COMMA);
	if (token != SEMI) {
d347 1
a347 1
	if (token != STRING) {
d359 1
a359 1
	if (token != LBRACE) {
d371 1
a371 1
		if (token == RBRACE)
d396 1
a396 1
	if (token != LBRACE) {
d414 1
a414 1
		if (token == RBRACE)
d516 1
a516 1
	case BOOTP:
d519 1
a519 1
	case INTERFACE:
d521 1
a521 1
		if (token != STRING) {
d534 1
a534 1
	case FIXED_ADDR:
d538 1
a538 1
	case MEDIUM:
d541 1
a541 1
	case FILENAME:
d544 1
a544 1
	case SERVER_NAME:
d547 1
a547 1
	case RENEW:
d550 1
a550 1
	case REBIND:
d553 1
a553 1
	case EXPIRE:
d556 1
a556 1
	case OPTION:
d565 1
a565 1
	if (token != SEMI) {
d588 1
a588 1
		if (token != SEMI)
d618 1
a618 1
				if (token != STRING) {
d652 1
a652 1
				if (token != NUMBER) {
d655 1
a655 1
					if (token != SEMI)
d666 1
a666 1
				if (token != NUMBER)
d675 1
a675 1
				if (token != NUMBER)
d686 1
a686 1
					if (token != SEMI)
d711 1
a711 1
	} while (*fmt == 'A' && token == COMMA);
d713 1
a713 1
	if (token != SEMI) {
d743 1
a743 1
		if (token != STRING) {
d763 1
a763 1
	} while (multiple && token == COMMA);
d765 1
a765 1
	if (token != SEMI) {
d796 1
a796 1
	} while (token == COMMA);
d798 1
a798 1
	if (token != SEMI) {
@


1.25
log
@Rejig struct string_list to use char array rather than char pointer, and
eliminate new_parse_string. alloc.c becomes redundant. Junk a couple of
unused fields (env, envc) in struct client_state.

suggestions by & ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.24 2005/07/16 14:09:51 krw Exp $	*/
a45 2
struct client_config top_level_config;
struct interface_info *dummy_interfaces;
d59 4
a62 4
	FILE			*cfile;
	char			*val;
	int			 token;
	struct client_config	*config;
a65 3
	/* Initialize the top level client configuration. */
	memset(&top_level_config, 0, sizeof(top_level_config));

d67 22
a88 23
	top_level_config.timeout = 60;
	top_level_config.select_interval = 0;
	top_level_config.reboot_timeout = 10;
	top_level_config.retry_interval = 300;
	top_level_config.backoff_cutoff = 15;
	top_level_config.initial_interval = 3;
	top_level_config.bootp_policy = ACCEPT;
	top_level_config.script_name = client_script_name;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] = DHO_SUBNET_MASK;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] = DHO_BROADCAST_ADDRESS;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] = DHO_TIME_OFFSET;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] = DHO_ROUTERS;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] = DHO_DOMAIN_NAME;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] =
	    DHO_DOMAIN_NAME_SERVERS;
	top_level_config.requested_options
	    [top_level_config.requested_option_count++] = DHO_HOST_NAME;
d95 1
a95 1
			parse_client_statement(cfile, NULL, &top_level_config);
a100 22
	/*
	 * Set up state and config structures for clients that don't
	 * have per-interface configuration declarations.
	 */
	config = NULL;
	if (!ifi->client) {
		ifi->client = malloc(sizeof(struct client_state));
		if (!ifi->client)
			error("no memory for client state.");
		memset(ifi->client, 0, sizeof(*(ifi->client)));
	}
	if (!ifi->client->config) {
		if (!config) {
			config = malloc(sizeof(struct client_config));
			if (!config)
				error("no memory for client config.");
			memcpy(config, &top_level_config,
				sizeof(top_level_config));
		}
		ifi->client->config = config;
	}

d157 1
a157 2
parse_client_statement(FILE *cfile, struct interface_info *ip,
    struct client_config *config)
d159 3
a161 2
	int		 token, code;
	char		*val;
d191 1
a191 7
		if (ip)
			parse_hardware_param(cfile, &ip->hw_address);
		else {
			parse_warn("hardware address parameter %s",
				    "not allowed here.");
			skip_to_semi(cfile);
		}
d224 1
a224 3
		if (ip)
			parse_warn("nested interface declaration.");
		parse_interface_declaration(cfile, config);
d233 1
a233 1
		parse_reject_statement(cfile, config);
d341 1
a341 1
parse_interface_declaration(FILE *cfile, struct client_config *outer_config)
d343 2
a344 3
	int			 token;
	char			*val;
	struct interface_info	*ip;
d353 4
a356 7
	ip = interface_or_dummy(val);

	if (!ip->client)
		make_client_state(ip);

	if (!ip->client->config)
		make_client_config(ip, outer_config);
d373 1
a373 1
		parse_client_statement(cfile, ip, ip->client->config);
a377 47
struct interface_info *
interface_or_dummy(char *name)
{
	struct interface_info	*ip;

	/* Find the interface (if any) that matches the name. */
	if (!strcmp(ifi->name, name))
		return (ifi);

	/* If it's not a real interface, see if it's on the dummy list. */
	for (ip = dummy_interfaces; ip; ip = ip->next)
		if (!strcmp(ip->name, name))
			return (ip);

	/*
	 * If we didn't find an interface, make a dummy interface as a
	 * placeholder.
	 */
	ip = malloc(sizeof(*ip));
	if (!ip)
		error("Insufficient memory to record interface %s", name);
	memset(ip, 0, sizeof(*ip));
	strlcpy(ip->name, name, IFNAMSIZ);
	ip->next = dummy_interfaces;
	dummy_interfaces = ip;
	return (ip);
}

void
make_client_state(struct interface_info *ip)
{
	ip->client = malloc(sizeof(*(ip->client)));
	if (!ip->client)
		error("no memory for state on %s", ip->name);
	memset(ip->client, 0, sizeof(*(ip->client)));
}

void
make_client_config(struct interface_info *ip, struct client_config *config)
{
	ip->client->config = malloc(sizeof(struct client_config));
	if (!ip->client->config)
		error("no memory for config for %s", ip->name);
	memset(ip->client->config, 0, sizeof(*(ip->client->config)));
	memcpy(ip->client->config, config, sizeof(*config));
}

d391 1
a391 1
	struct interface_info	*ip;
a407 2
	ip = NULL;

a427 4
	/* Make sure there's a client state structure... */
	if (!ip->client)
		make_client_state(ip);

d512 2
a513 3
	int			 token;
	char			*val;
	struct interface_info	*ip;
d526 7
a532 2
		ip = interface_or_dummy(val);
		*ipp = ip;
d772 1
a772 1
parse_reject_statement(FILE *cfile, struct client_config *config)
d774 5
a778 4
	int			 token;
	char			*val;
	struct iaddr		 addr;
	struct iaddrlist	*list;
@


1.24
log
@Eliminate unnecessary 'code' field from struct option. Make
dhcp_options const.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.23 2005/07/15 22:33:04 krw Exp $	*/
d838 1
a838 1
		tmp = new_string_list(strlen(val) + 1);
@


1.23
log
@Fix handling of comma separated option value lists, broken in r1.20.

Found and fix tested by Moritz Jodeit.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.22 2005/07/11 18:24:08 deraadt Exp $	*/
d188 1
a188 1
	int		 token;
a189 1
	struct option	*option;
d196 3
a198 3
		option = parse_option_decl(cfile, &config->defaults[0]);
		if (option)
			config->default_actions[option->code] = ACTION_DEFAULT;
d201 3
a203 4
		option = parse_option_decl(cfile, &config->defaults[0]);
		if (option)
			config->default_actions[option->code] =
			    ACTION_SUPERSEDE;
d206 3
a208 3
		option = parse_option_decl(cfile, &config->defaults[0]);
		if (option)
			config->default_actions[option->code] = ACTION_APPEND;
d211 3
a213 3
		option = parse_option_decl(cfile, &config->defaults[0]);
		if (option)
			config->default_actions[option->code] = ACTION_PREPEND;
d660 1
a660 1
struct option *
d679 1
a679 1
		return (NULL);
d691 1
a691 1
		return (NULL);
d710 1
a710 1
					return (NULL);
d717 1
a717 1
					return (NULL);
d725 1
a725 1
					return (NULL);
d733 1
a733 1
					return (NULL);
d746 1
a746 1
					return (NULL);
d777 1
a777 1
					return (NULL);
d796 1
a796 1
				return (NULL);
d805 1
a805 1
		return (NULL);
d813 1
a813 1
	return (&dhcp_options[code]);
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.21 2005/07/11 18:09:09 krw Exp $	*/
d687 1
a687 2
		if (strcmp(dhcp_options[code].name, val) == 0) {
			fmt = dhcp_options[code].format;
a688 1
		}
d690 1
a690 1
	if (!fmt) {
d698 1
a698 1
		for (; *fmt; fmt++) {
@


1.21
log
@Expunge unused hashing code and variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.20 2005/07/11 17:57:26 krw Exp $	*/
d690 1
a690 1
		}	
@


1.20
log
@Dispense with the overhead of creating a hash just to lookup the
option name. Just iterate over the 256 option names. Only the first 80
or so are used anyway. Eliminating now unused hash code will follow.

ok henning@@ millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.19 2005/07/09 01:06:00 krw Exp $	*/
a66 3

	/* Set up the initial dhcp option universe. */
	initialize_dhcp_universe();
@


1.19
log
@Since we never add more than the default dhcp_universe, expunge the
code to handle mulitple 'vendor' universes. Don't bother with a
specific error message about 'vendor'. An unsupported option is an
unsupported option, and a '.' in an option name is a syntax error.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.18 2004/09/15 18:15:18 henning Exp $	*/
a673 1
	struct option	*option;
d676 1
a676 1
	int		 len;
d687 7
a693 3
	/* Look up the actual option info... */
	option = (struct option *)hash_lookup(dhcp_universe.hash,
	    (unsigned char *)val, 0);
d695 1
a695 2
	/* If we didn't get an option structure, it's an undefined option. */
	if (!option) {
d703 1
a703 1
		for (fmt = option->format; *fmt; fmt++) {
d815 2
a816 2
	options[option->code].data = malloc(hunkix + nul_term);
	if (!options[option->code].data)
d818 3
a820 3
	memcpy(options[option->code].data, hunkbuf, hunkix + nul_term);
	options[option->code].len = hunkix;
	return (option);
@


1.18
log
@no \n in error() calls and minor KNF, from Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.17 2004/08/24 15:06:03 henning Exp $	*/
d69 1
a69 1
	initialize_universes();
a672 1
	char		*vendor;
a673 1
	struct universe	*universe;
a686 34
	if ((vendor = strdup(val)) == NULL)
		error("no memory for vendor information.");

	token = peek_token(&val, cfile);
	if (token == DOT) {
		/* Go ahead and take the DOT token... */
		token = next_token(&val, cfile);

		/* The next token should be an identifier... */
		token = next_token(&val, cfile);
		if (!is_identifier(token)) {
			parse_warn("expecting identifier after '.'");
			if (token != SEMI)
				skip_to_semi(cfile);
			return (NULL);
		}

		/* Look up the option name hash table for the specified
		   vendor. */
		universe = ((struct universe *)hash_lookup(&universe_hash,
		    (unsigned char *)vendor, 0));
		/* If it's not there, we can't parse the rest of the
		   declaration. */
		if (!universe) {
			parse_warn("no vendor named %s.", vendor);
			skip_to_semi(cfile);
			return (NULL);
		}
	} else {
		/* Use the default hash table, which contains all the
		   standard dhcp option names. */
		val = vendor;
		universe = &dhcp_universe;
	}
d689 1
a689 1
	option = (struct option *)hash_lookup(universe->hash,
d694 1
a694 5
		if (val == vendor)
			parse_warn("no option named %s", val);
		else
			parse_warn("no option named %s for vendor %s",
				    val, vendor);
a697 3

	/* Free the initial identifier token. */
	free(vendor);
@


1.17
log
@revert r1.16, dhclient has to work without a config file at least on the
install media, theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.16 2004/07/04 23:33:49 henning Exp $	*/
d456 1
a456 1
		error("no memory for state on %s\n", ip->name);
d465 1
a465 1
		error("no memory for config for %s\n", ip->name);
d496 1
a496 1
		error("no memory for lease.\n");
@


1.16
log
@properly bitch when we cannot open the config file, basically resembling
a diff from Damir Horvat <damir@@x-si.org> which didn't apply cleanly
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.15 2004/05/13 07:35:17 wilfried Exp $	*/
d99 10
a108 12
	if ((cfile = fopen(path_dhclient_conf, "r")) == NULL)
		error("can't open config file %s: %m",
		    path_dhclient_conf);

	do {
		token = peek_token(&val, cfile);
		if (token == EOF)
			break;
		parse_client_statement(cfile, NULL, &top_level_config);
	} while (1);
	token = next_token(&val, cfile); /* Clear the peek buffer */
	fclose(cfile);
@


1.15
log
@don't leave this file open, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.14 2004/05/04 22:23:01 mickey Exp $	*/
d99 12
a110 10
	if ((cfile = fopen(path_dhclient_conf, "r")) != NULL) {
		do {
			token = peek_token(&val, cfile);
			if (token == EOF)
				break;
			parse_client_statement(cfile, NULL, &top_level_config);
		} while (1);
		token = next_token(&val, cfile); /* Clear the peek buffer */
		fclose(cfile);
	}
@


1.14
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.13 2004/05/04 18:58:50 deraadt Exp $	*/
d165 1
@


1.13
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.12 2004/03/02 18:49:21 deraadt Exp $	*/
d158 1
a158 1
			warn("Corrupt lease file - possible data loss!");
d840 1
a840 1
				warn("Bad format %c in parse_option_param.",
@


1.12
log
@more pruning; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.11 2004/03/02 15:41:44 henning Exp $	*/
d885 1
a885 1
		tmp = new_string_list(strlen(val) + 1, "parse tmp");
@


1.11
log
@zap interface flags
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.10 2004/03/02 13:39:44 henning Exp $	*/
d541 1
a541 1
			     lease->address.len)) {
d841 1
a841 1
				     *fmt);
@


1.10
log
@we deal with one interface at a time, so remove the interface list gunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.9 2004/03/02 12:56:30 henning Exp $	*/
a400 2

	ip->flags &= ~INTERFACE_AUTOMATIC;
@


1.9
log
@remove dummy_interfaces and fallback_interface gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.8 2004/02/24 13:21:32 henning Exp $	*/
d48 1
a64 1
	struct interface_info	*ip;
d115 13
a127 16
	for (ip = interfaces; ip; ip = ip->next) {
		if (!ip->client) {
			ip->client = malloc(sizeof(struct client_state));
			if (!ip->client)
				error("no memory for client state.");
			memset(ip->client, 0, sizeof(*(ip->client)));
		}
		if (!ip->client->config) {
			if (!config) {
				config = malloc(sizeof(struct client_config));
				if (!config)
					error("no memory for client config.");
				memcpy(config, &top_level_config,
					sizeof(top_level_config));
			}
			ip->client->config = config;
d129 1
d430 2
a431 3
	for (ip = interfaces; ip; ip = ip->next)
		if (!strcmp(ip->name, name))
			break;
d434 3
a436 4
	if (!ip)
		for (ip = dummy_interfaces; ip; ip = ip->next)
			if (!strcmp(ip->name, name))
				break;
d442 7
a448 10
	if (!ip) {
		ip = malloc(sizeof(*ip));
		if (!ip)
			error("Insufficient memory to record interface %s",
			    name);
		memset(ip, 0, sizeof(*ip));
		strlcpy(ip->name, name, IFNAMSIZ);
		ip->next = dummy_interfaces;
		dummy_interfaces = ip;
	}
@


1.8
log
@cut unreachable code
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.7 2004/02/07 21:10:26 henning Exp $	*/
d47 1
@


1.7
log
@it's a little sad that this beast has only one asprintf, and that one
just mimics a strdup... so make it a strdup. spotted by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.6 2004/02/07 11:35:59 henning Exp $	*/
a403 1
	interfaces_requested = 1;
@


1.6
log
@more style fixes from Emil Mikulic <emikulic@@dmr.ath.cx>
Thank you very much for this excellent work, it helps a lot.
binary unchanged.
I am still convinced dhclient can be made readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: clparse.c,v 1.5 2004/02/04 12:16:56 henning Exp $	*/
d697 1
a697 1
	if (asprintf(&vendor, "%s", val) == -1)
@


1.5
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 6
a55 5
/* client-conf-file :== client-declarations EOF
   client-declarations :== <nil>
			 | client-declaration
			 | client-declarations client-declaration */

d71 1
a71 1
	memset(&top_level_config, 0, sizeof top_level_config);
d109 4
a112 2
	/* Set up state and config structures for clients that don't
	   have per-interface configuration declarations. */
d119 1
a119 1
			memset(ip->client, 0, sizeof *(ip->client));
d136 5
a140 4
/* lease-file :== client-lease-statements EOF
   client-lease-statements :== <nil>
		     | client-lease-statements LEASE client-lease-statement */

d168 19
a186 18
/* client-declaration :== 
	SEND option-decl |
	DEFAULT option-decl |
	SUPERSEDE option-decl |
	PREPEND option-decl |
	APPEND option-decl |
	hardware-declaration |
	REQUEST option-list |
	REQUIRE option-list |
	TIMEOUT number |
	RETRY number |
	REBOOT number |
	SELECT_TIMEOUT number |
	SCRIPT string |
	interface-declaration |
	LEASE client-lease-statement |
	ALIAS client-lease-statement */

a219 1

d311 1
a311 1
			token = peek_token (&val, cfile);
d333 4
a336 3
/* option-list :== option_name |
   		   option_list COMMA option_name */

d377 4
a380 3
/* interface-declaration :==
   	INTERFACE string LBRACE client-declarations RBRACE */

d433 1
a433 1
		if (!strcmp (ip->name, name))
d439 1
a439 1
			if (!strcmp (ip->name, name))
d442 4
a445 2
	/* If we didn't find an interface, make a dummy interface as
	   a placeholder. */
d447 1
a447 1
		ip = malloc(sizeof *ip);
d451 1
a451 1
		memset(ip, 0, sizeof *ip);
d462 1
a462 1
	ip->client = malloc(sizeof *(ip->client));
d465 1
a465 1
	memset(ip->client, 0, sizeof *(ip->client));
d474 2
a475 2
	memset(ip->client->config, 0, sizeof *(ip->client->config));
	memcpy(ip->client->config, config, sizeof *config);
d478 9
a486 9
/* client-lease-statement :==
	RBRACE client-lease-declarations LBRACE

	client-lease-declarations :==
		<nil> |
		client-lease-declaration |
		client-lease-declarations client-lease-declaration */


d505 1
a505 1
	memset(lease, 0, sizeof *lease);
d523 2
a524 1
	   declaration that we recognized, it's of no use to us. */
d540 6
a545 4
	/* The new lease may supersede a lease that's not the
	   active lease but is still on the lease list, so scan the
	   lease list looking for a lease with the same address, and
	   if we find it, toss it. */
d560 4
a563 2
	/* If this is a preloaded lease, just put it on the list of recorded
	   leases - don't make it the active lease. */
d570 14
a583 11
	/* The last lease in the lease file on a particular interface is
	   the active lease for that interface.    Of course, we don't know
	   what the last lease in the file is until we've parsed the whole
	   file, so at this point, we assume that the lease we just parsed
	   is the active lease for its interface.   If there's already
	   an active lease for the interface, and this lease is for the same
	   ip address, then we just toss the old active lease and replace
	   it with this one.   If this lease is for a different address,
	   then if the old active lease has expired, we dump it; if not,
	   we put it on the list of leases for this interface which are
	   still valid but no longer active. */
d599 1
a599 1
	/* phew. */
d602 12
a613 11
/* client-lease-declaration :==
	BOOTP |
	INTERFACE string |
	FIXED_ADDR ip_address |
	FILENAME string |
	SERVER_NAME string |
	OPTION option-decl |
	RENEW time-decl |
	REBIND time-decl |
	EXPIRE time-decl */

d622 1
a622 1
	switch (next_token (&val, cfile)) {
d700 1
a700 1
	token = peek_token (&val, cfile);
d707 1
a707 1
		if (!is_identifier (token)) {
d758 1
a758 1
				    sizeof hunkbuf - hunkix);
d769 1
a769 1
				if (hunkix + len + 1 > sizeof hunkbuf) {
d780 1
a780 1
				if (!parse_ip_addr (cfile, &ip_addr))
d785 1
a785 1
				if (hunkix + len > sizeof hunkbuf) {
d839 1
a839 1
				    !strcasecmp (val, "off"))
d925 1
a925 1
		if (!parse_ip_addr (cfile, &addr)) {
@


1.4
log
@more KNF
@
text
@d1 1
a1 1
/* clparse.c
d3 1
a3 1
   Parser for dhclient config and lease files... */
@


1.3
log
@asprintf
@
text
@d261 1
a261 1
		parse_interface_declaration (cfile, config);
d333 1
a333 1
parse_option_list (FILE *cfile, u_int8_t *list)
d441 2
a442 2
			error ("Insufficient memory to record interface %s",
			       name);
d496 1
a496 1
		error ("no memory for lease.\n");
d556 1
a556 1
		
d575 1
a575 1
			free_client_lease (ip->client->active);
d605 1
a605 1
	switch(next_token (&val, cfile)) {
d671 1
a671 1
	int 		 nul_term = 0;
d682 1
a682 1
	
d743 1
a743 1
				break;	
d769 1
a769 1
					parse_warn ("option data buffer %s",
d774 1
a774 1
				memcpy (&hunkbuf[hunkix], dp, len);
d787 1
a787 1
				convert_num (buf, val, 0, 32);
d856 1
a856 1
parse_string_list (FILE *cfile, struct string_list **lp, int multiple)
d877 1
a877 1
		tmp = new_string_list(strlen(val) + 1, "parse tmp"); 
d879 2
a880 2
			error ("no memory for string list entry.");
		strlcpy (tmp->string, val, strlen(val) + 1);
d929 1
a929 1
}	
@


1.2
log
@8579 lines of KNF, ANSO and zap-junk diff without the resulting binary
changing by a single byte.
partly from theo
@
text
@d680 1
a680 3
	/* XXXFIX asprintf */
	vendor = malloc(strlen(val) + 1);
	if (!vendor)
d682 1
a682 1
	strlcpy(vendor, val, strlen(val) + 1);
a876 1
		/* XXXFIX asprintf */
@


1.1
log
@this is where dhclient will start surgery
@
text
@d48 1
a48 1
char client_script_name [] = "/sbin/dhclient-script";
d55 2
a56 1
int read_client_conf ()
d58 5
a62 5
	FILE *cfile;
	char *val;
	int token;
	struct client_config *config;
	struct interface_info *ip;
d64 1
a64 1
	new_parse (path_dhclient_conf);
d67 1
a67 1
	initialize_universes ();
d70 1
a70 1
	memset (&top_level_config, 0, sizeof top_level_config);
d82 1
a82 2
		[top_level_config.requested_option_count++] =
			DHO_SUBNET_MASK;
d84 1
a84 2
		[top_level_config.requested_option_count++] =
			DHO_BROADCAST_ADDRESS;
d86 1
a86 2
		[top_level_config.requested_option_count++] =
			DHO_TIME_OFFSET;
d88 1
a88 2
		[top_level_config.requested_option_count++] =
			DHO_ROUTERS;
d90 1
a90 2
		[top_level_config.requested_option_count++] =
			DHO_DOMAIN_NAME;
d92 2
a93 2
		[top_level_config.requested_option_count++] =
			DHO_DOMAIN_NAME_SERVERS;
d95 1
a95 2
		[top_level_config.requested_option_count++] =
			DHO_HOST_NAME;
d97 1
a97 1
	if ((cfile = fopen (path_dhclient_conf, "r")) != NULL) {
d99 1
a99 1
			token = peek_token (&val, cfile);
d102 1
a102 3
			parse_client_statement (cfile,
						(struct interface_info *)0,
						&top_level_config);
d104 2
a105 2
		token = next_token (&val, cfile); /* Clear the peek buffer */
		fclose (cfile);
d110 7
a116 8
	config = (struct client_config *)0;
	for (ip = interfaces; ip; ip = ip -> next) {
		if (!ip -> client) {
			ip -> client = (struct client_state *)
				malloc (sizeof (struct client_state));
			if (!ip -> client)
				error ("no memory for client state.");
			memset (ip -> client, 0, sizeof *(ip -> client));
d118 1
a118 1
		if (!ip -> client -> config) {
d120 1
a120 2
				config = (struct client_config *)
					malloc (sizeof (struct client_config));
d122 3
a124 3
					error ("no memory for client config.");
				memcpy (config, &top_level_config,
					sizeof top_level_config);
d126 1
a126 1
			ip -> client -> config = config;
d130 1
a130 1
	return !warnings_occurred;
d137 2
a138 1
void read_client_leases ()
d140 3
a142 3
	FILE *cfile;
	char *val;
	int token;
d144 1
a144 1
	new_parse (path_dhclient_db);
d148 1
a148 1
	if ((cfile = fopen (path_dhclient_db, "r")) == NULL)
d151 1
a151 1
		token = next_token (&val, cfile);
d155 2
a156 2
			warn ("Corrupt lease file - possible data loss!");
			skip_to_semi (cfile);
d159 1
a159 1
			parse_client_lease_statement (cfile, 0);
d182 11
a192 12
void parse_client_statement (cfile, ip, config)
	FILE *cfile;
	struct interface_info *ip;
	struct client_config *config;
{
	int token;
	char *val;
	struct option *option;

	switch (next_token (&val, cfile)) {
	      case SEND:
		parse_option_decl (cfile, &config -> send_options [0]);
d194 2
a195 3

	      case DEFAULT:
		option = parse_option_decl (cfile, &config -> defaults [0]);
d197 1
a197 2
			config -> default_actions [option -> code] =
				ACTION_DEFAULT;
d199 2
a200 3

	      case SUPERSEDE:
		option = parse_option_decl (cfile, &config -> defaults [0]);
d202 2
a203 2
			config -> default_actions [option -> code] =
				ACTION_SUPERSEDE;
d205 2
a206 3

	      case APPEND:
		option = parse_option_decl (cfile, &config -> defaults [0]);
d208 1
a208 2
			config -> default_actions [option -> code] =
				ACTION_APPEND;
d210 2
a211 3

	      case PREPEND:
		option = parse_option_decl (cfile, &config -> defaults [0]);
d213 1
a213 2
			config -> default_actions [option -> code] =
				ACTION_PREPEND;
d216 2
a217 2
	      case MEDIA:
		parse_string_list (cfile, &config -> media, 1);
d219 5
a223 6

	      case HARDWARE:
		if (ip) {
			parse_hardware_param (cfile, &ip -> hw_address);
		} else {
			parse_warn ("hardware address parameter %s",
d225 1
a225 1
			skip_to_semi (cfile);
d228 3
a230 4

	      case REQUEST:
		config -> requested_option_count =
			parse_option_list (cfile, config -> requested_options);
d232 4
a235 5

	      case REQUIRE:
		memset (config -> required_options, 0,
			sizeof config -> required_options);
		parse_option_list (cfile, config -> required_options);
d237 2
a238 3

	      case TIMEOUT:
		parse_lease_time (cfile, &config -> timeout);
d240 2
a241 3

	      case RETRY:
		parse_lease_time (cfile, &config -> retry_interval);
d243 2
a244 3

	      case SELECT_TIMEOUT:
		parse_lease_time (cfile, &config -> select_interval);
d246 2
a247 3

	      case REBOOT:
		parse_lease_time (cfile, &config -> reboot_timeout);
d249 2
a250 3

	      case BACKOFF_CUTOFF:
		parse_lease_time (cfile, &config -> backoff_cutoff);
d252 2
a253 3

	      case INITIAL_INTERVAL:
		parse_lease_time (cfile, &config -> initial_interval);
d255 2
a256 3

	      case SCRIPT:
		config -> script_name = parse_string (cfile);
d258 1
a258 2

	      case INTERFACE:
d260 1
a260 1
			parse_warn ("nested interface declaration.");
d263 2
a264 3

	      case LEASE:
		parse_client_lease_statement (cfile, 1);
d266 2
a267 3

	      case ALIAS:
		parse_client_lease_statement (cfile, 2);
d269 2
a270 3

	      case REJECT:
		parse_reject_statement (cfile, config);
d272 3
a274 4

	      default:
		parse_warn ("expecting a statement.");
		skip_to_semi (cfile);
d277 1
a277 1
	token = next_token (&val, cfile);
d279 2
a280 2
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
d284 2
a285 4
int parse_X (cfile, buf, max)
	FILE *cfile;
	u_int8_t *buf;
	int max;
d287 3
a289 3
	int token;
	char *val;
	int len;
d291 1
a291 1
	token = peek_token (&val, cfile);
d295 1
a295 1
			token = next_token (&val, cfile);
d297 3
a299 3
				parse_warn ("expecting hexadecimal constant.");
				skip_to_semi (cfile);
				return 0;
d301 1
a301 1
			convert_num (&buf [len], val, 16, 8);
d303 3
a305 3
				parse_warn ("hexadecimal constant too long.");
				skip_to_semi (cfile);
				return 0;
d309 1
a309 1
				token = next_token (&val, cfile);
d313 2
a314 2
		token = next_token (&val, cfile);
		len = strlen (val);
d316 3
a318 3
			parse_warn ("string constant too long.");
			skip_to_semi (cfile);
			return 0;
d320 1
a320 1
		memcpy (buf, val, len + 1);
d322 3
a324 3
		parse_warn ("expecting string or hexadecimal data");
		skip_to_semi (cfile);
		return 0;
d326 1
a326 1
	return len;
d332 6
a337 7
int parse_option_list (cfile, list)
	FILE *cfile;
	u_int8_t *list;
{
	int ix, i;
	int token;
	char *val;
d341 5
a345 5
		token = next_token (&val, cfile);
		if (!is_identifier (token)) {
			parse_warn ("expected option name.");
			skip_to_semi (cfile);
			return 0;
d347 2
a348 2
		for (i = 0; i < 256; i++) {
			if (!strcasecmp (dhcp_options [i].name, val))
d350 1
a350 1
		}
d352 3
a354 3
			parse_warn ("%s: unexpected option name.", val);
			skip_to_semi (cfile);
			return 0;
d356 1
a356 1
		list [ix++] = i;
d358 3
a360 3
			parse_warn ("%s: too many options.", val);
			skip_to_semi (cfile);
			return 0;
d362 1
a362 1
		token = next_token (&val, cfile);
d365 3
a367 3
		parse_warn ("expecting semicolon.");
		skip_to_semi (cfile);
		return 0;
d369 1
a369 1
	return ix;
d375 2
a376 3
void parse_interface_declaration (cfile, outer_config)
	FILE *cfile;
	struct client_config *outer_config;
d378 3
a380 4
	int token;
	char *val;

	struct interface_info *ip;
d382 1
a382 1
	token = next_token (&val, cfile);
d384 2
a385 2
		parse_warn ("expecting interface name (in quotes).");
		skip_to_semi (cfile);
d389 1
a389 1
	ip = interface_or_dummy (val);
d391 2
a392 2
	if (!ip -> client)
		make_client_state (ip);
d394 2
a395 2
	if (!ip -> client -> config)
		make_client_config (ip, outer_config);
d397 1
a397 1
	ip -> flags &= ~INTERFACE_AUTOMATIC;
d400 1
a400 1
	token = next_token (&val, cfile);
d402 2
a403 2
		parse_warn ("expecting left brace.");
		skip_to_semi (cfile);
d408 1
a408 1
		token = peek_token (&val, cfile);
d410 1
a410 1
			parse_warn ("unterminated interface declaration.");
d415 1
a415 1
		parse_client_statement (cfile, ip, ip -> client -> config);
d417 1
a417 1
	token = next_token (&val, cfile);
d420 2
a421 2
struct interface_info *interface_or_dummy (name)
	char *name;
d423 1
a423 1
	struct interface_info *ip;
d426 2
a427 2
	for (ip = interfaces; ip; ip = ip -> next) {
		if (!strcmp (ip -> name, name))
a428 1
	}
d431 3
a433 3
	if (!ip) {
		for (ip = dummy_interfaces; ip; ip = ip -> next) {
			if (!strcmp (ip -> name, name))
a434 2
		}
	}
d439 1
a439 1
		ip = ((struct interface_info *)malloc (sizeof *ip));
d443 3
a445 3
		memset (ip, 0, sizeof *ip);
		strlcpy (ip -> name, name, IFNAMSIZ);
		ip -> next = dummy_interfaces;
d448 1
a448 1
	return ip;
d451 2
a452 2
void make_client_state (ip)
	struct interface_info *ip;
d454 14
a467 19
	ip -> client =
		((struct client_state *)malloc (sizeof *(ip -> client)));
	if (!ip -> client)
		error ("no memory for state on %s\n", ip -> name);
	memset (ip -> client, 0, sizeof *(ip -> client));
}

void make_client_config (ip, config)
	struct interface_info *ip;
	struct client_config *config;
{
	ip -> client -> config =
		((struct client_config *)
		 malloc (sizeof (struct client_config)));
	if (!ip -> client -> config)
		error ("no memory for config for %s\n", ip -> name);
	memset (ip -> client -> config, 0,
		sizeof *(ip -> client -> config));
	memcpy (ip -> client -> config, config, sizeof *config);
d479 7
a485 8
void parse_client_lease_statement (cfile, is_static)
	FILE *cfile;
	int is_static;
{
	struct client_lease *lease, *lp, *pl;
	struct interface_info *ip;
	int token;
	char *val;
d487 1
a487 1
	token = next_token (&val, cfile);
d489 2
a490 2
		parse_warn ("expecting left brace.");
		skip_to_semi (cfile);
d494 1
a494 1
	lease = (struct client_lease *)malloc (sizeof (struct client_lease));
d497 2
a498 2
	memset (lease, 0, sizeof *lease);
	lease -> is_static = is_static;
d500 1
a500 1
	ip = (struct interface_info *)0;
d503 1
a503 1
		token = peek_token (&val, cfile);
d505 1
a505 1
			parse_warn ("unterminated lease declaration.");
d510 1
a510 1
		parse_client_lease_declaration (cfile, lease, &ip);
d512 1
a512 1
	token = next_token (&val, cfile);
d517 1
a517 1
		free_client_lease (lease);
d522 2
a523 2
	if (!ip -> client)
		make_client_state (ip);
d527 1
a527 1
		ip -> client -> alias = lease;
d535 5
a539 5
	pl = (struct client_lease *)0;
	for (lp = ip -> client -> leases; lp; lp = lp -> next) {
		if (lp -> address.len == lease -> address.len &&
		    !memcmp (lp -> address.iabuf, lease -> address.iabuf,
			     lease -> address.len)) {
d541 1
a541 1
				pl -> next = lp -> next;
d543 2
a544 2
				ip -> client -> leases = lp -> next;
			free_client_lease (lp);
d552 2
a553 2
		lease -> next = ip -> client -> leases;
		ip -> client -> leases = lease;
d568 8
a575 9
	if (ip -> client -> active) {
		if (ip -> client -> active -> expiry < cur_time)
			free_client_lease (ip -> client -> active);
		else if (ip -> client -> active -> address.len ==
			 lease -> address.len &&
			 !memcmp (ip -> client -> active -> address.iabuf,
				  lease -> address.iabuf,
				  lease -> address.len))
			free_client_lease (ip -> client -> active);
d577 2
a578 3
			ip -> client -> active -> next =
				ip -> client -> leases;
			ip -> client -> leases = ip -> client -> active;
d581 1
a581 1
	ip -> client -> active = lease;
d597 11
a607 12
void parse_client_lease_declaration (cfile, lease, ipp)
	FILE *cfile;
	struct client_lease *lease;
	struct interface_info **ipp;
{
	int token;
	char *val;
	struct interface_info *ip;

	switch (next_token (&val, cfile)) {
	      case BOOTP:
		lease -> is_bootp = 1;
d609 2
a610 3

	      case INTERFACE:
		token = next_token (&val, cfile);
d612 2
a613 2
			parse_warn ("expecting interface name (in quotes).");
			skip_to_semi (cfile);
d616 1
a616 1
		ip = interface_or_dummy (val);
d619 2
a620 3

	      case FIXED_ADDR:
		if (!parse_ip_addr (cfile, &lease -> address))
d623 2
a624 3

	      case MEDIUM:
		parse_string_list (cfile, &lease -> medium, 0);
d626 2
a627 3

	      case FILENAME:
		lease -> filename = parse_string (cfile);
d629 2
a630 3

	      case SERVER_NAME:
		lease -> server_name = parse_string (cfile);
d632 2
a633 3

	      case RENEW:
		lease -> renewal = parse_date (cfile);
d635 2
a636 3

	      case REBIND:
		lease -> rebind = parse_date (cfile);
d638 2
a639 3

	      case EXPIRE:
		lease -> expiry = parse_date (cfile);
d641 2
a642 3

	      case OPTION:
		parse_option_decl (cfile, lease -> options);
d644 3
a646 4

	      default:
		parse_warn ("expecting lease declaration.");
		skip_to_semi (cfile);
d649 1
a649 1
	token = next_token (&val, cfile);
d651 2
a652 2
		parse_warn ("expecting semicolon.");
		skip_to_semi (cfile);
d656 20
a675 21
struct option *parse_option_decl (cfile, options)
	FILE *cfile;
	struct option_data *options;
{
	char *val;
	int token;
	u_int8_t buf [4];
	u_int8_t hunkbuf [1024];
	int hunkix = 0;
	char *vendor;
	char *fmt;
	struct universe *universe;
	struct option *option;
	struct iaddr ip_addr;
	u_int8_t *dp;
	int len;
	int nul_term = 0;

	token = next_token (&val, cfile);
	if (!is_identifier (token)) {
		parse_warn ("expecting identifier after option keyword.");
d677 2
a678 2
			skip_to_semi (cfile);
		return (struct option *)0;
d680 2
a681 1
	vendor = malloc (strlen (val) + 1);
d683 2
a684 2
		error ("no memory for vendor information.");
	strlcpy (vendor, val, strlen(val) + 1);
d688 1
a688 1
		token = next_token (&val, cfile);
d691 1
a691 1
		token = next_token (&val, cfile);
d693 1
a693 1
			parse_warn ("expecting identifier after '.'");
d695 2
a696 2
				skip_to_semi (cfile);
			return (struct option *)0;
d701 2
a702 3
		universe = ((struct universe *)
			    hash_lookup (&universe_hash,
					 (unsigned char *)vendor, 0));
d706 3
a708 3
			parse_warn ("no vendor named %s.", vendor);
			skip_to_semi (cfile);
			return (struct option *)0;
d718 2
a719 2
	option = (struct option *)hash_lookup (universe -> hash,
					       (unsigned char *)val, 0);
d724 1
a724 1
			parse_warn ("no option named %s", val);
d726 1
a726 1
			parse_warn ("no option named %s for vendor %s",
d728 2
a729 2
		skip_to_semi (cfile);
		return (struct option *)0;
d733 1
a733 1
	free (vendor);
d737 1
a737 1
		for (fmt = option -> format; *fmt; fmt++) {
d741 3
a743 3
			      case 'X':
				len = parse_X (cfile, &hunkbuf [hunkix],
					       sizeof hunkbuf - hunkix);
d745 3
a747 4
				break;
					
			      case 't': /* Text string... */
				token = next_token (&val, cfile);
d749 3
a751 3
					parse_warn ("expecting string.");
					skip_to_semi (cfile);
					return (struct option *)0;
d753 1
a753 1
				len = strlen (val);
d755 4
a758 4
					parse_warn ("option data buffer %s",
						    "overflow");
					skip_to_semi (cfile);
					return (struct option *)0;
d760 1
a760 1
				memcpy (&hunkbuf [hunkix], val, len + 1);
d764 1
a764 2

			      case 'I': /* IP address. */
d766 1
a766 1
					return (struct option *)0;
d769 1
a769 2

			      alloc:
d772 3
a774 3
						    "overflow");
					skip_to_semi (cfile);
					return (struct option *)0;
d776 1
a776 1
				memcpy (&hunkbuf [hunkix], dp, len);
d779 3
a781 4

			      case 'L': /* Unsigned 32-bit integer... */
			      case 'l':	/* Signed 32-bit integer... */
				token = next_token (&val, cfile);
d783 2
a784 2
				      need_number:
					parse_warn ("expecting number.");
d786 2
a787 2
						skip_to_semi (cfile);
					return (struct option *)0;
d793 3
a795 4

			      case 's':	/* Signed 16-bit integer. */
			      case 'S':	/* Unsigned 16-bit integer. */
				token = next_token (&val, cfile);
d798 1
a798 1
				convert_num (buf, val, 0, 16);
d802 3
a804 4

			      case 'b':	/* Signed 8-bit integer. */
			      case 'B':	/* Unsigned 8-bit integer. */
				token = next_token (&val, cfile);
d807 1
a807 1
				convert_num (buf, val, 0, 8);
d811 5
a815 6

			      case 'f': /* Boolean flag. */
				token = next_token (&val, cfile);
				if (!is_identifier (token)) {
					parse_warn ("expecting identifier.");
				      bad_flag:
d817 2
a818 2
						skip_to_semi (cfile);
					return (struct option *)0;
d820 6
a825 6
				if (!strcasecmp (val, "true")
				    || !strcasecmp (val, "on"))
					buf [0] = 1;
				else if (!strcasecmp (val, "false")
					 || !strcasecmp (val, "off"))
					buf [0] = 0;
d827 1
a827 1
					parse_warn ("expecting boolean.");
d833 5
a837 6

			      default:
				warn ("Bad format %c in parse_option_param.",
				      *fmt);
				skip_to_semi (cfile);
				return (struct option *)0;
d840 1
a840 1
		token = next_token (&val, cfile);
d844 19
a862 22
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
		return (struct option *)0;
	}

	options [option -> code].data =
		(unsigned char *)malloc (hunkix + nul_term);
	if (!options [option -> code].data)
		error ("out of memory allocating option data.");
	memcpy (options [option -> code].data, hunkbuf, hunkix + nul_term);
	options [option -> code].len = hunkix;
	return option;
}

void parse_string_list (cfile, lp, multiple)
	FILE *cfile;
	struct string_list **lp;
	int multiple;
{
	int token;
	char *val;
	struct string_list *cur, *tmp;
d865 5
a869 6
	if (*lp) {
		for (cur = *lp; cur -> next; cur = cur -> next)
			;
	} else {
		cur = (struct string_list *)0;
	}
d872 1
a872 1
		token = next_token (&val, cfile);
d874 2
a875 2
			parse_warn ("Expecting media options.");
			skip_to_semi (cfile);
d879 1
a879 5
#ifdef OH_THE_HORROR
		tmp = (struct string_list *)malloc (strlen (val) + 1 +
						    sizeof
						    (struct string_list *));
#endif
d883 2
a884 3

		strlcpy (tmp -> string, val, strlen(val) + 1);
		tmp -> next = NULL;
d888 1
a888 1
			cur -> next = tmp;
d893 1
a893 1
		token = next_token (&val, cfile);
d897 2
a898 2
		parse_warn ("expecting semicolon.");
		skip_to_semi (cfile);
d902 2
a903 3
void parse_reject_statement (cfile, config)
	FILE *cfile;
	struct client_config *config;
d905 4
a908 4
	int token;
	char *val;
	struct iaddr addr;
	struct iaddrlist *list;
d912 2
a913 2
			parse_warn ("expecting IP address.");
			skip_to_semi (cfile);
d917 1
a917 1
		list = (struct iaddrlist *)malloc (sizeof (struct iaddrlist));
d919 1
a919 1
			error ("no memory for reject list!");
d921 3
a923 3
		list -> addr = addr;
		list -> next = config -> reject_list;
		config -> reject_list = list;
d925 1
a925 1
		token = next_token (&val, cfile);
d929 2
a930 2
		parse_warn ("expecting semicolon.");
		skip_to_semi (cfile);
@

