head	1.54;
access;
symbols
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.54
date	2017.06.29.21.37.43;	author krw;	state Exp;
branches;
next	1.53;
commitid	WL1sg0AgPbdbSW2T;

1.53
date	2017.06.22.15.08.53;	author krw;	state Exp;
branches;
next	1.52;
commitid	aPDtVVkdtIVobSi9;

1.52
date	2017.06.19.19.28.35;	author krw;	state Exp;
branches;
next	1.51;
commitid	ueq2M4294OXNv6H1;

1.51
date	2017.06.10.17.56.29;	author krw;	state Exp;
branches;
next	1.50;
commitid	1dqLY8Cw6CA1ZYDX;

1.50
date	2017.04.09.20.44.13;	author krw;	state Exp;
branches;
next	1.49;
commitid	Qbefa1v9yY6ObGzy;

1.49
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.48;
commitid	KIdulj0iLtM6kXff;

1.48
date	2017.04.03.19.59.39;	author krw;	state Exp;
branches;
next	1.47;
commitid	FEe0akNwKUViXksW;

1.47
date	2017.04.03.18.23.36;	author krw;	state Exp;
branches;
next	1.46;
commitid	0diNNQhqbwkZVgen;

1.46
date	2017.04.03.15.34.46;	author krw;	state Exp;
branches;
next	1.45;
commitid	H7YONChEP2colYND;

1.45
date	2017.04.03.14.16.34;	author krw;	state Exp;
branches;
next	1.44;
commitid	inVYrBC2E4aM7oYT;

1.44
date	2017.04.02.20.57.22;	author krw;	state Exp;
branches;
next	1.43;
commitid	48ZwoEy89E1YfzJ9;

1.43
date	2017.02.15.20.00.16;	author krw;	state Exp;
branches;
next	1.42;
commitid	hD8qJgE1mUGpmAxx;

1.42
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.41;
commitid	IDlzr3qamZK5lxzj;

1.41
date	2017.02.11.16.12.36;	author krw;	state Exp;
branches;
next	1.40;
commitid	eWsyZlm9X0T2fxXC;

1.40
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.39;
commitid	5ELOU0S0Zl3aCrHG;

1.39
date	2015.05.18.17.51.21;	author krw;	state Exp;
branches;
next	1.38;
commitid	SjQKXPdyGuKrZRc7;

1.38
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.21.03.07.50;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.19.21.10.04;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.19.08.25.54;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.19.04.36.04;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.18.01.03.56;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.18.00.51.55;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2014.01.13.23.42.18;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.13.20.56.24;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.10.01.38.15;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.12.05.22.31.35;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.20.17.22.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.11.21.00.01;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2013.04.27.17.54.24;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.02.02.37.41;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.10.17.15.27;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.26.21.14.10;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.08.13.34.38;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.22.21.35.56;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.22.18.07.52;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.21.17.29.27;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.18.19.17.54;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.17.19.33.55;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.16.16.19.23;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.05.23.07.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.04.21.48.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.24.13.08.26;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.23.20.09.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.13.59.45;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.13.26.35;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.06.11.33.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Nuke undocumented long-deprecated and/or unsupported lease
fields 'hardware', 'alias', 'media', 'medium', 'ethernet'.

Also remove now-unused parse_ethernet().

Making these parsing failures will smoke out anybody with
leases or conf files from the last century.
@
text
@/*	$OpenBSD: parse.c,v 1.53 2017/06/22 15:08:53 krw Exp $	*/

/* Common parser code for dhcpd and dhclient. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/queue.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <vis.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "dhctoken.h"
#include "log.h"

/*
 * Skip to the semicolon ending the current statement.   If we encounter
 * braces, the matching closing brace terminates the statement.   If we
 * encounter a right brace but haven't encountered a left brace, return
 * leaving the brace in the token buffer for the caller.   If we see a
 * semicolon and haven't seen a left brace, return.   This lets us skip
 * over:
 *
 *	statement;
 *	statement foo bar { }
 *	statement foo bar { statement { } }
 *	statement}
 *
 *	...et cetera.
 */
void
skip_to_semi(FILE *cfile)
{
	int		 token;
	int		 brace_count = 0;

	do {
		token = peek_token(NULL, cfile);
		if (token == '}') {
			if (brace_count) {
				if (!--brace_count) {
					token = next_token(NULL, cfile);
					return;
				}
			} else
				return;
		} else if (token == '{') {
			brace_count++;
		} else if (token == ';' && !brace_count) {
			token = next_token(NULL, cfile);
			return;
		} else if (token == '\n') {
			/*
			 * EOL only happens when parsing
			 * /etc/resolv.conf, and we treat it like a
			 * semicolon because the resolv.conf file is
			 * line-oriented.
			 */
			token = next_token(NULL, cfile);
			return;
		}
		token = next_token(NULL, cfile);
	} while (token != EOF);
}

int
parse_semi(FILE *cfile)
{
	int token;

	token = next_token(NULL, cfile);
	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
		return (0);
	}
	return (1);
}

char *
parse_string(FILE *cfile, unsigned int *len)
{
	static char unvisbuf[1500];
	char *val, *s;
	int i, token;

	token = next_token(&val, cfile);
	if (token != TOK_STRING) {
		parse_warn("expecting string.");
		if (token != ';')
			skip_to_semi(cfile);
		return (NULL);
	}

	i = strnunvis(unvisbuf, val, sizeof(unvisbuf));
	if (i == -1) {
		parse_warn("could not unvis string");
		return (NULL);
	}
	s = malloc(i+1);
	if (!s)
		fatalx("no memory for string %s.", val);
	memcpy(s, unvisbuf, i+1);	/* copy terminating NUL */
	if (len != NULL)
		*len = i;

	return (s);
}

/* cidr :== ip-address "/" bit-count
 * ip-address :== NUMBER [ DOT NUMBER [ DOT NUMBER [ DOT NUMBER ] ] ]
 * bit-count :== 0..32
 */
int
parse_cidr(FILE *cfile, unsigned char *cidr)
{
	struct in_addr addr;
	int token;
	int len;

	token = '.';
	len = 0;
	for (token = '.'; token == '.'; token = next_token(NULL, cfile)) {
		if (!parse_decimal(cfile, cidr + 1 + len, 'B'))
			break;
		if (++len == sizeof(addr)) {
			token = next_token(NULL, cfile);
			break;
		}
	}

	if (!len) {
		parse_warn("expecting decimal value.");
		skip_to_semi(cfile);
		return (0);
	} else if (token != '/') {
		parse_warn("expecting '/'.");
		skip_to_semi(cfile);
		return (0);
	} else if (!parse_decimal(cfile, cidr, 'B') || *cidr > 32) {
		parse_warn("expecting decimal value <= 32.");
		skip_to_semi(cfile);
		return (0);
	}

	return (1);
}

int
parse_ip_addr(FILE *cfile, struct in_addr *addr)
{
	struct in_addr buf;
	int len, token;

	token = '.';
	len = 0;
	for (token = '.'; token == '.'; token = next_token(NULL, cfile)) {
		if (!parse_decimal(cfile, (unsigned char *)&buf + len, 'B'))
			break;
		if (++len == sizeof(buf))
			break;
	}

	if (len == 4) {
		memcpy(addr, &buf, sizeof(*addr));
		return (1);
	} else if (token != '.') {
		parse_warn("expecting '.'.");
		skip_to_semi(cfile);
		return (0);
	} else {
		parse_warn("expecting decimal value.");
		skip_to_semi(cfile);
		return (0);
	}
}

/*
 * lease-time :== NUMBER SEMI
 */
void
parse_lease_time(FILE *cfile, time_t *timep)
{
	u_int32_t value;

	if (!parse_decimal(cfile, (char *)&value, 'L')) {
		parse_warn("expecting unsigned 32-bit decimal value.");
		skip_to_semi(cfile);
		return;
	}

	*timep = betoh32(value);

	parse_semi(cfile);
}

int
parse_decimal(FILE *cfile, unsigned char *buf, char fmt)
{
	char *val;
	const char *errstr;
	int bytes, token;
	long long numval, low, high;

	token = next_token(&val, cfile);

	switch (fmt) {
	case 'l':	/* Signed 32-bit integer. */
		low = INT32_MIN;
		high = INT32_MAX;
		bytes = 4;
		break;
	case 'L':	/* Unsigned 32-bit integer. */
		low = 0;
		high = UINT32_MAX;
		bytes = 4;
		break;
	case 'S':	/* Unsigned 16-bit integer. */
		low = 0;
		high = UINT16_MAX;
		bytes = 2;
		break;
	case 'B':	/* Unsigned 8-bit integer. */
		low = 0;
		high = UINT8_MAX;
		bytes = 1;
		break;
	default:
		return (0);
	}

	numval = strtonum(val, low, high, &errstr);
	if (errstr)
		return (0);

	numval = htobe64(numval);
	memcpy(buf, (char *)&numval + (sizeof(numval) - bytes), bytes);

	return (1);
}

int
parse_hex(FILE *cfile, unsigned char *buf)
{
	char *val, *ep;
	int token;
	unsigned long ulval;

	token = next_token(&val, cfile);

	errno = 0;
	ulval = strtoul(val, &ep, 16);
	if ((val[0] == '\0' || *ep != '\0') ||
	    (errno == ERANGE && ulval == ULONG_MAX) ||
	    (ulval > UINT8_MAX))
		return (0);

	buf[0] = ulval;

	return (1);
}

/*
 * date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER
 *		NUMBER COLON NUMBER COLON NUMBER UTC SEMI
 *
 * Dates are always in UTC; first number is day of week; next is
 * year/month/day; next is hours:minutes:seconds on a 24-hour
 * clock.
 */
time_t
parse_date(FILE *cfile)
{
	struct tm tm;
	char timestr[26]; /* "w yyyy/mm/dd hh:mm:ss UTC" */
	char *val, *p;
	size_t n;
	time_t guess;
	int token;

	memset(timestr, 0, sizeof(timestr));

	do {
		token = peek_token(NULL, cfile);
		switch (token) {
		case TOK_NAME:
		case TOK_NUMBER:
		case TOK_NUMBER_OR_NAME:
		case '/':
		case ':':
			token = next_token(&val, cfile);
			n = strlcat(timestr, val, sizeof(timestr));
			if (n >= sizeof(timestr)) {
				/* XXX Will break after year 9999! */
				parse_warn("time string too long");
				skip_to_semi(cfile);
				return (0);
			}
			break;
		case';':
			break;
		default:
			parse_warn("invalid time string");
			skip_to_semi(cfile);
			return (0);
		}
	} while (token != ';');

	parse_semi(cfile);

	memset(&tm, 0, sizeof(tm));	/* 'cuz strptime ignores tm_isdt. */
	p = strptime(timestr, DB_TIMEFMT, &tm);
	if (p == NULL || *p != '\0') {
		parse_warn("unparseable time string");
		return (0);
	}

	guess = timegm(&tm);
	if (guess == -1) {
		parse_warn("time could not be represented");
		return (0);
	}

	return (guess);
}

void
parse_warn(char *msg)
{
	static char spaces[81];
	unsigned int i;

	log_warnx("%s line %d: %s", tlname, lexline, msg);
	log_warnx("%s", token_line);
	if ((unsigned int)lexchar < sizeof(spaces)) {
		memset(spaces, 0, sizeof(spaces));
		for (i = 0; (int)i < lexchar - 1; i++) {
			if (token_line[i] == '\t')
				spaces[i] = '\t';
			else
				spaces[i] = ' ';
		}
	}
	log_warnx("%s^", spaces);
}
@


1.53
log
@Drop support for old (>4yr) timestamp formats in leases
files.

ok tb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.52 2017/06/19 19:28:35 krw Exp $	*/
a225 37
	}
}

/*
 * ETHERNET :== 'ethernet' NUMBER:NUMBER:NUMBER:NUMBER:NUMBER:NUMBER
 */
void
parse_ethernet(FILE *cfile, struct ether_addr *hardware)
{
	struct ether_addr buf;
	int len, token;

	token = next_token(NULL, cfile);
	if (token != TOK_ETHERNET) {
		parse_warn("expecting 'ethernet'.");
		if (token != ';')
			skip_to_semi(cfile);
		return;
	}

	len = 0;
	for (token = ':'; token == ':'; token = next_token(NULL, cfile)) {
		if (!parse_hex(cfile, &buf.ether_addr_octet[len]))
			break;
		if (++len == sizeof(buf.ether_addr_octet))
			break;
	}

	if (len == 6) {
		if (parse_semi(cfile))
			memcpy(hardware, &buf, sizeof(*hardware));
	} else if (token != ':') {
		parse_warn("expecting ':'.");
		skip_to_semi(cfile);
	} else {
		parse_warn("expecting hex value.");
		skip_to_semi(cfile);
@


1.52
log
@Various KNF nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.51 2017/06/10 17:56:29 krw Exp $	*/
d402 2
a403 8
		p = strptime(timestr, OLD_DB_TIMEFMT, &tm);
		if (p == NULL || *p != '\0') {
			p = strptime(timestr, BAD_DB_TIMEFMT, &tm);
			if (p == NULL || *p != '\0') {
				parse_warn("unparseable time string");
				return (0);
			}
		}
@


1.51
log
@Nuke unused global warnings_occurred.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.50 2017/04/09 20:44:13 krw Exp $	*/
d256 1
a256 1
		    memcpy(hardware, &buf, sizeof(*hardware));
@


1.50
log
@Seven casts, a couple of tweaks and CFLAGS+=-Wsign-compare for the
win.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.49 2017/04/08 20:16:04 krw Exp $	*/
a420 2
int warnings_occurred;

a438 2

	warnings_occurred = 1;
@


1.49
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.48 2017/04/03 19:59:39 krw Exp $	*/
d431 1
a431 1
	if (lexchar < sizeof(spaces)) {
d433 1
a433 1
		for (i = 0; i < lexchar - 1; i++) {
@


1.48
log
@Change parse_string() to take an optional integer pointer that can
be used to return the final size of the parsed (i.e. un-vis'ed)
string. Use same, plus memcpy() to ensure entire final string is
copied to intended destination even if there are embedded NULs.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.47 2017/04/03 18:23:36 krw Exp $	*/
d132 1
a132 1
parse_string(FILE *cfile, int *len)
d427 1
a427 1
	int i;
@


1.47
log
@Simplify read_string() to just read the characters between the '"'s.
Push the un-vising up to parse_string(). This allows both the actual
string and the un-vised version to be available as desired. Use
memcpy() instead of strdup() to copy un-vised string since it may
legitimately contain NUL.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.46 2017/04/03 15:34:46 krw Exp $	*/
d132 1
a132 1
parse_string(FILE *cfile)
d155 2
@


1.46
log
@Tweak parse_string() to not consume the ';'. Simplifies/shortens
some logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.45 2017/04/03 14:16:34 krw Exp $	*/
d60 1
d134 1
d136 1
a136 1
	int token;
d145 7
a151 1
	s = strdup(val);
d154 1
@


1.45
log
@Tweak 'expecting' parse_warn() messages to be more consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.44 2017/04/02 20:57:22 krw Exp $	*/
a129 3
/*
 * string-parameter :== STRING SEMI
 */
a146 4
	if (!parse_semi(cfile)) {
		free(s);
		return (NULL);
	}
@


1.44
log
@Change parse_string() warning from "filename must be a string" to
"expecting a string". Things other than filenames are parsed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.43 2017/02/15 20:00:16 krw Exp $	*/
d141 1
a141 1
		parse_warn("expecting a string");
d180 1
a180 1
		parse_warn("expecting CIDR subnet.");
d188 1
a188 1
		parse_warn("Expecting CIDR prefix length.");
d219 1
a219 1
		parse_warn("expecting decimal octet.");
d257 1
a257 1
		parse_warn("expecting hex octet.");
@


1.43
log
@Use new log.[ch] functions in parse_warn().

Simplify the "^" placing logic and make it apply to log entries as
well as terminal output.

Since dhclient(8) can be re-exec'd for various reasons after going
daemon, make sure we don't try to log to stderr if it isn't a TTY.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.42 2017/02/12 13:15:50 krw Exp $	*/
d141 1
a141 1
		parse_warn("filename must be a string");
@


1.42
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.41 2017/02/11 16:12:36 krw Exp $	*/
a422 3
	static char mbuf[1024];
	struct iovec iov[6];
	size_t iovcnt;
d425 9
a433 31
	snprintf(mbuf, sizeof(mbuf), "%s line %d: %s", tlname, lexline, msg);

#ifndef DEBUG
	syslog(LOG_ERR, "%s", mbuf);
	syslog(LOG_ERR, "%s", token_line);
	if (lexchar < 81)
		syslog(LOG_ERR, "%*c", lexchar, '^');
#endif

	if (log_perror) {
		iov[0].iov_base = mbuf;
		iov[0].iov_len = strlen(mbuf);
		iov[1].iov_base = "\n";
		iov[1].iov_len = 1;
		iov[2].iov_base = token_line;
		iov[2].iov_len = strlen(token_line);
		iov[3].iov_base = "\n";
		iov[3].iov_len = 1;
		iovcnt = 4;
		if (lexchar < 81) {
			for (i = 0; i < lexchar; i++) {
				if (token_line[i] == '\t')
					spaces[i] = '\t';
				else
					spaces[i] = ' ';
			}
			iov[4].iov_base = spaces;
			iov[4].iov_len = lexchar - 1;
			iov[5].iov_base = "^\n";
			iov[5].iov_len = 2;
			iovcnt += 2;
a434 1
		writev(STDERR_FILENO, iov, iovcnt);
d436 2
@


1.41
log
@Move parse_warning() into parse.c to prepare to replace errwarn.c
with standard daemon log.[ch].

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.40 2016/02/06 19:30:52 krw Exp $	*/
d64 1
d148 1
a148 1
		error("no memory for string %s.", val);
d417 2
d423 1
a423 1
	extern char mbuf[1024];
@


1.40
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.39 2015/05/18 17:51:21 krw Exp $	*/
d58 2
d414 46
@


1.39
log
@Tweak parsing so that hostnames starting with 0-9 are accepted.

Reported long ago by matthieu@@. Also Jacob Berkman via the lists.

Tests and suggestions from Jacob and Matthieu.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.38 2014/05/05 18:02:49 krw Exp $	*/
d43 13
d57 1
d59 1
@


1.38
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.37 2014/01/21 03:07:50 krw Exp $	*/
d354 1
@


1.37
log
@Add parsing for options 121 (classless-static-routes) and 249
(classless-ms-static-routes). dhcpd can now specify and serve
these options and dhclient can recognize and use supersede, etc.
statements on them.

Based on a diff from Stefan Rinke. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.36 2014/01/19 21:10:04 krw Exp $	*/
d144 1
a144 1
parse_cidr(FILE *cfile, unsigned char *cidr)  
d257 1
a257 1
	
d272 1
a272 1
	
d314 1
a314 1
	
d325 1
a325 1
	
@


1.36
log
@We don't have any (and I can't find elsewhere) signed 16 bit or
signed 8 bit dhcp option types. So nuke getShort() and all 's' and
'b' format support. While here use '%u'/'%lu' and not
'%d'/'%ld' to snprintf() unsigned values.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.35 2014/01/19 08:25:54 krw Exp $	*/
d137 39
@


1.35
log
@Redo the parsing of numbers to improve the error messages and
make the code more readable. And prepare for some new things
that will need to be parsed.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.34 2014/01/19 04:36:04 krw Exp $	*/
a244 5
	case 's':	/* Signed 16-bit integer. */
		low = INT16_MIN;
		high = INT16_MAX;
		bytes = 2;
		break;
a248 5
		break;
	case 'b':	/* Signed 8-bit integer. */
		low = INT8_MIN;
		high = INT8_MAX;
		bytes = 1;
@


1.34
log
@Rename parse_hardware_param() to parse_ethernet() to reflect what
it actually does.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.33 2014/01/18 01:03:56 krw Exp $	*/
d43 2
a47 2
int parse_numeric_aggregate(FILE *, unsigned char *, int, int, int);

d142 24
a165 1
	return (parse_numeric_aggregate(cfile, (char *)addr, 4, '.', 10));
d174 2
a175 1
	int token;
d185 7
a191 3
	if (parse_numeric_aggregate(cfile, hardware->ether_addr_octet,
	    ETHER_ADDR_LEN, ':', 16) == 0)
		return;
d193 10
a202 1
	parse_semi(cfile);
d211 1
a211 3
	char *val;
	uint32_t value;
	int token;
d213 3
a215 5
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("expecting numeric lease time.");
		if (token != ';')
			skip_to_semi(cfile);
d218 2
a219 3
	convert_num((unsigned char *)&value, val, 10, 32);
	/* Unswap the number - convert_num returns stuff in NBO. */
	*timep = ntohl(value);
a223 4
/*
 * Parse a sequence of numbers separated by the token specified in separator.
 * Exactly max numbers are expected.
 */
d225 1
a225 2
parse_numeric_aggregate(FILE *cfile, unsigned char *buf, int max, int separator,
    int base)
d228 3
a230 1
	int token, count;
d232 35
a266 15
	if (buf == NULL || max == 0)
		error("no space for numeric aggregate");

	for (count = 0; count < max; count++, buf++) {
		if (count && (peek_token(&val, cfile) == separator))
			token = next_token(&val, cfile);

		token = next_token(&val, cfile);

		if (token == TOK_NUMBER || (base == 16 && token ==
			TOK_NUMBER_OR_NAME))
			/* XXX Need to check if conversion was successful. */
			convert_num(buf, val, base, 8);
		else
			break;
d269 2
a270 2
	if (count < max) {
		parse_warn("numeric aggregate too short.");
d272 3
a274 1
	}
d279 2
a280 2
void
convert_num(unsigned char *buf, char *str, int base, int size)
d282 5
a286 8
	int negative = 0, tval, max;
	u_int32_t val = 0;
	char *ptr = str;

	if (*ptr == '-') {
		negative = 1;
		ptr++;
	}
d288 6
a293 15
	/* If base wasn't specified, figure it out from the data. */
	if (!base) {
		if (ptr[0] == '0') {
			if (ptr[1] == 'x') {
				base = 16;
				ptr += 2;
			} else if (isascii((unsigned char)ptr[1]) &&
			    isdigit((unsigned char)ptr[1])) {
				base = 8;
				ptr += 1;
			} else
				base = 10;
		} else
			base = 10;
	}
d295 3
a297 72
	do {
		tval = *ptr++;
		/* XXX assumes ASCII. */
		if (tval >= 'a')
			tval = tval - 'a' + 10;
		else if (tval >= 'A')
			tval = tval - 'A' + 10;
		else if (tval >= '0')
			tval -= '0';
		else {
			warning("Bogus number: %s.", str);
			break;
		}
		if (tval >= base) {
			warning("Bogus number: %s: digit %d not in base %d",
			    str, tval, base);
			break;
		}
		val = val * base + tval;
	} while (*ptr);

	if (negative)
		max = (1 << (size - 1));
	else
		max = (1 << (size - 1)) + ((1 << (size - 1)) - 1);
	if (val > max) {
		switch (base) {
		case 8:
			warning("value %s%o exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		case 16:
			warning("value %s%x exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		default:
			warning("value %s%u exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		}
	}

	if (negative)
		switch (size) {
		case 8:
			*buf = -(unsigned long)val;
			break;
		case 16:
			putShort(buf, -(unsigned long)val);
			break;
		case 32:
			putLong(buf, -(unsigned long)val);
			break;
		default:
			warning("Unexpected integer size: %d", size);
			break;
		}
	else
		switch (size) {
		case 8:
			*buf = (u_int8_t)val;
			break;
		case 16:
			putUShort(buf, (u_int16_t)val);
			break;
		case 32:
			putULong(buf, val);
			break;
		default:
			warning("Unexpected integer size: %d", size);
			break;
		}
@


1.33
log
@Make parse_warn() messages consistantly use 'expecting' rather
than occasionally 'expected'. End all with a '.'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.32 2014/01/18 00:51:55 krw Exp $	*/
d146 1
a146 2
 * hardware-parameter :== HARDWARE ETHERNET csns SEMI
 * csns :== NUMBER | csns COLON NUMBER
d149 1
a149 1
parse_hardware_param(FILE *cfile, struct ether_addr *hardware)
@


1.32
log
@Never silently consume the following statement when unexpectedly
encountering a ';'. I.e. when checking the token type, 'skip_to_semi()'
after 'parse_warn()' only when the parsed token wasn't a ';'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.31 2014/01/13 23:42:18 krw Exp $	*/
d105 1
a105 1
		parse_warn("semicolon expected.");
d156 1
a156 1
		parse_warn("expecting 'ethernet'");
d181 1
a181 1
		parse_warn("Expecting numeric lease time");
@


1.31
log
@peek_token() a bit more to replace a bunch of manual checks with
the perfectly adequate parse_semi(). And some blocks didn't even
need to peek.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.30 2014/01/13 20:56:24 krw Exp $	*/
d124 2
a125 1
		skip_to_semi(cfile);
d157 2
a158 1
		skip_to_semi(cfile);
d182 2
a183 1
		skip_to_semi(cfile);
@


1.30
log
@Don't eat two tokens when encountering a non-terminal '}'. Avoids
possibly ignoring entire rest of dhclient.conf or dhclient.leases.if
looking for a mistakenly consumed '}'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.29 2014/01/10 01:38:15 krw Exp $	*/
d164 1
a164 5
	token = next_token(NULL, cfile);
	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
	}
@


1.29
log
@Yet another annoyingly long line.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.28 2013/12/06 23:40:48 krw Exp $	*/
d73 2
a74 2
				token = next_token(NULL, cfile);
				if (!--brace_count)
d76 1
@


1.28
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.27 2013/12/05 22:31:35 krw Exp $	*/
d213 2
a214 1
		if (token == TOK_NUMBER || (base == 16 && token == TOK_NUMBER_OR_NAME))
@


1.27
log
@Stop pretending we still support FDDI or token ring hardware types.

idea ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.26 2013/11/20 17:22:46 deraadt Exp $	*/
d148 1
a148 1
parse_hardware_param(FILE *cfile, struct hardware *hardware)
d153 2
a154 7
	switch (token) {
	case TOK_ETHERNET:
		hardware->htype = HTYPE_ETHER;
		hardware->hlen = 6;
		break;
	default:
		parse_warn("expecting a network hardware type");
d159 2
a160 2
	if (parse_numeric_aggregate(cfile, hardware->haddr, hardware->hlen,
	    ':', 16) == 0)
@


1.26
log
@cleanups for signed char vs ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.25 2013/11/11 21:00:01 krw Exp $	*/
a155 8
		hardware->hlen = 6;
		break;
	case TOK_TOKEN_RING:
		hardware->htype = HTYPE_IEEE802;
		hardware->hlen = 6;
		break;
	case TOK_FDDI:
		hardware->htype = HTYPE_FDDI;
@


1.25
log
@Shuffle function prototypes and extern declarations around to
put local functions prototypes and variables in their .c files, and
cross-file functions into .h files. Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.24 2013/05/02 16:35:27 krw Exp $	*/
d259 2
a260 1
			} else if (isascii(ptr[1]) && isdigit(ptr[1])) {
@


1.24
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.23 2013/04/27 17:54:24 krw Exp $	*/
d45 2
@


1.23
log
@Use same parse_date() and date writing logic as in dhcpd. i.e.
strptime() rather than handrolling parsing. Change date format
in leases to same as dhcpd, fixing 'u' vs 'w' error made in
initial strftime() introduction.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.22 2013/04/02 02:37:41 guenther Exp $	*/
d268 1
a268 1
		/* XXX assumes ASCII... */
@


1.22
log
@Don't assume sizeof(time_t)==4

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.21 2012/11/08 21:32:55 krw Exp $	*/
d342 1
a342 1
 *		NUMBER COLON NUMBER COLON NUMBER SEMI
d344 1
a344 1
 * Dates are always in GMT; first number is day of week; next is
a350 3
	static int months[11] = { 31, 59, 90, 120, 151, 181,
	    212, 243, 273, 304, 334 };
	int guess, token;
d352 5
a356 1
	char *val;
d358 1
a358 9
	/* Day of week... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric day of week expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_wday = atoi(val);
d360 20
a379 5
	/* Year... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric year expected.");
		if (token != ';')
d381 3
a383 5
		return (0);
	}
	tm.tm_year = atoi(val);
	if (tm.tm_year > 1900)
		tm.tm_year -= 1900;
d385 1
a385 8
	/* Slash separating year from month... */
	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("expected slash separating year from month.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
d387 11
a397 74
	/* Month... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric month expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_mon = atoi(val) - 1;

	/* Slash separating month from day... */
	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("expected slash separating month from day.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Day... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric day of month expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_mday = atoi(val);

	/* Hour... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric hour expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_hour = atoi(val);

	/* Colon separating hour from minute... */
	token = next_token(&val, cfile);
	if (token != ':') {
		parse_warn("expected colon separating hour from minute.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Minute... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric minute expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_min = atoi(val);

	/* Colon separating minute from second... */
	token = next_token(&val, cfile);
	if (token != ':') {
		parse_warn("expected colon separating minute from second.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Second... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric second expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
a398 5
	tm.tm_sec = atoi(val);
	tm.tm_isdst = 0;

	/* XXX: We assume that mktime does not use tm_yday. */
	tm.tm_yday = 0;
d400 3
a402 5
	/* Make sure the date ends in a semicolon... */
	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
a405 20
	/* Guess the time value... */
	guess = ((((((365 * (tm.tm_year - 70) +	/* Days in years since '70 */
	    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
	    (tm.tm_mon			/* Days in months this year */
	    ? months[tm.tm_mon - 1] : 0) +
	    (tm.tm_mon > 1 &&		/* Leap day this year */
	    !((tm.tm_year - 72) & 3)) +
	    tm.tm_mday - 1) * 24) +	/* Day of month */
	    tm.tm_hour) * 60) + tm.tm_min) * 60) + tm.tm_sec;

	/*
	 * This guess could be wrong because of leap seconds or other
	 * weirdness we don't know about that the system does.   For
	 * now, we're just going to accept the guess, but at some point
	 * it might be nice to do a successive approximation here to get
	 * an exact value.   Even if the error is small, if the server
	 * is restarted frequently (and thus the lease database is
	 * reread), the error could accumulate into something
	 * significant.
	 */
@


1.21
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.20 2011/12/10 17:15:27 krw Exp $	*/
d188 1
d197 1
a197 1
	convert_num((unsigned char *)timep, val, 10, 32);
d199 1
a199 1
	*timep = ntohl(*timep);	/* XXX */
@


1.20
log
@Tweak parsing. No need to declare, assign and then ignore the token
value when only the token id is required.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.19 2010/06/26 21:14:10 krw Exp $	*/
d136 1
a136 1
parse_ip_addr(FILE *cfile, struct iaddr *addr)
d138 1
a138 3
	addr->len = 4;
	return (parse_numeric_aggregate(cfile, addr->iabuf, addr->len, '.',
	    10));
@


1.19
log
@malloc/strlcpy -> strdup. Apparently I forgot to commit this one with
the similar changes to dhcpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.18 2007/01/08 13:34:38 krw Exp $	*/
a64 1
	char		*val;
d68 1
a68 1
		token = peek_token(&val, cfile);
d71 1
a71 1
				token = next_token(&val, cfile);
d79 1
a79 1
			token = next_token(&val, cfile);
d88 1
a88 1
			token = next_token(&val, cfile);
d91 1
a91 1
		token = next_token(&val, cfile);
a98 1
	char *val;
d100 1
a100 1
	token = next_token(&val, cfile);
a150 1
	char *val;
d152 1
a152 1
	token = next_token(&val, cfile);
d176 1
a176 1
	token = next_token(&val, cfile);
@


1.18
log
@Don't leak strings.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.17 2006/11/22 21:35:56 stevesk Exp $	*/
d126 1
a126 1
	s = malloc(strlen(val) + 1);
a128 1
	strlcpy(s, val, strlen(val) + 1);
@


1.17
log
@sync dhclient and dhcpd parse.c areas where we can.
mainly formatting, whitespace; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.16 2006/11/22 18:07:52 stevesk Exp $	*/
d131 2
a132 1
	if (!parse_semi(cfile))
d134 1
@


1.16
log
@fix some warning messages and comments in parse_date(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.15 2006/11/21 17:29:27 stevesk Exp $	*/
d46 2
a47 1
/* Skip to the semicolon ending the current statement.   If we encounter
d64 3
a66 2
	int brace_count = 0, token;
	char *val;
d202 1
a202 1
	*timep = ntohl(*timep); /* XXX */
d482 7
a488 9
		    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
		    (tm.tm_mon			/* Days in months this year */
		    ? months[tm.tm_mon - 1]
		    : 0) +
		    (tm.tm_mon > 1 &&		/* Leap day this year */
		    !((tm.tm_year - 72) & 3)) +
		    tm.tm_mday - 1) * 24) +	/* Day of month */
		    tm.tm_hour) * 60) +
		    tm.tm_min) * 60) + tm.tm_sec;
@


1.15
log
@remove spurious ; after bracket, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.14 2006/04/18 19:17:54 deraadt Exp $	*/
d408 1
a408 1
	/* Month... */
d450 1
a450 1
		parse_warn("expected colon separating hour from minute.");
d456 1
a456 1
	/* Minute... */
d459 1
a459 1
		parse_warn("numeric minute expected.");
@


1.14
log
@cleanup keyword lookup for the lexer, and remove keywords not valid in
either dhclient or dhcpd context; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.13 2005/07/17 19:33:55 krw Exp $	*/
d230 1
a230 1
	};
@


1.13
log
@Insist on correct hardware addresses in dhclient.conf and
dhclient.leases.<if> files. Simplify parse_numeric_aggregate() as
a result, rendering tree.c and tree.h redundant.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.12 2005/07/16 16:19:23 krw Exp $	*/
d68 1
a68 1
		if (token == RBRACE) {
d75 1
a75 1
		} else if (token == LBRACE) {
d77 1
a77 1
		} else if (token == SEMI && !brace_count) {
d101 1
a101 1
	if (token != SEMI) {
d119 1
a119 1
	if (token != STRING) {
d138 1
a138 1
	return (parse_numeric_aggregate(cfile, addr->iabuf, addr->len, DOT,
d154 1
a154 1
	case ETHERNET:
d158 1
a158 1
	case TOKEN_RING:
d162 1
a162 1
	case FDDI:
d173 1
a173 1
	    COLON, 16) == 0)
d177 1
a177 1
	if (token != SEMI) {
d193 1
a193 1
	if (token != NUMBER) {
d225 1
a225 1
		if (token == NUMBER || (base == 16 && token == NUMBER_OR_NAME))
d360 1
a360 1
	if (token != NUMBER) {
d362 1
a362 1
		if (token != SEMI)
d370 1
a370 1
	if (token != NUMBER) {
d372 1
a372 1
		if (token != SEMI)
d382 1
a382 1
	if (token != SLASH) {
d384 1
a384 1
		if (token != SEMI)
d391 1
a391 1
	if (token != NUMBER) {
d393 1
a393 1
		if (token != SEMI)
d401 1
a401 1
	if (token != SLASH) {
d403 1
a403 1
		if (token != SEMI)
d410 1
a410 1
	if (token != NUMBER) {
d412 1
a412 1
		if (token != SEMI)
d420 1
a420 1
	if (token != NUMBER) {
d422 1
a422 1
		if (token != SEMI)
d430 1
a430 1
	if (token != COLON) {
d432 1
a432 1
		if (token != SEMI)
d439 1
a439 1
	if (token != NUMBER) {
d441 1
a441 1
		if (token != SEMI)
d449 1
a449 1
	if (token != COLON) {
d451 1
a451 1
		if (token != SEMI)
d458 1
a458 1
	if (token != NUMBER) {
d460 1
a460 1
		if (token != SEMI)
d472 1
a472 1
	if (token != SEMI) {
@


1.12
log
@NULL is not a time_t. From brooks at freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.11 2004/05/05 23:07:47 deraadt Exp $	*/
d138 2
a139 4
	if (parse_numeric_aggregate(cfile, addr->iabuf,
	    &addr->len, DOT, 10, 8))
		return (1);
	return (0);
d149 1
a149 2
	unsigned char *t;
	int token, hlen;
d156 1
d160 1
d164 1
d172 2
a173 12
	/*
	 * Parse the hardware address information.   Technically, it
	 * would make a lot of sense to restrict the length of the data
	 * we'll accept here to the length of a particular hardware
	 * address type.   Unfortunately, there are some broken clients
	 * out there that put bogus data in the chaddr buffer, and we
	 * accept that data in the lease file rather than simply failing
	 * on such clients.   Yuck.
	 */
	hlen = 0;
	t = parse_numeric_aggregate(cfile, NULL, &hlen, COLON, 16, 8);
	if (!t)
a174 12
	if (hlen > sizeof(hardware->haddr)) {
		free(t);
		parse_warn("hardware address too long");
	} else {
		hardware->hlen = hlen;
		memcpy((unsigned char *)&hardware->haddr[0], t,
		    hardware->hlen);
		if (hlen < sizeof(hardware->haddr))
			memset(&hardware->haddr[hlen], 0,
			    sizeof(hardware->haddr) - hlen);
		free(t);
	}
d206 2
a207 6
 * No BNF for numeric aggregates - that's defined by the caller.  What
 * this function does is to parse a sequence of numbers separated by the
 * token specified in separator.  If max is zero, any number of numbers
 * will be parsed; otherwise, exactly max numbers are expected.  Base
 * and size tell us how to internalize the numbers once they've been
 * tokenized.
d209 3
a211 3
unsigned char *
parse_numeric_aggregate(FILE *cfile, unsigned char *buf, int *max,
    int separator, int base, int size)
d213 2
a214 11
	unsigned char *bufp = buf, *s = NULL;
	int token, count = 0;
	char *val, *t;
	pair c = NULL;

	if (!bufp && *max) {
		bufp = malloc(*max * size / 8);
		if (!bufp)
			error("can't allocate space for numeric aggregate");
	} else
		s = bufp;
d216 5
a220 13
	do {
		if (count) {
			token = peek_token(&val, cfile);
			if (token != separator) {
				if (!*max)
					break;
				if (token != RBRACE && token != LBRACE)
					token = next_token(&val, cfile);
				parse_warn("too few numbers.");
				if (token != SEMI)
					skip_to_semi(cfile);
				return (NULL);
			}
d222 1
a222 1
		}
d225 4
a228 2
		if (token == EOF) {
			parse_warn("unexpected end of file");
d230 1
a230 1
		}
d232 4
a235 22
		/* Allow NUMBER_OR_NAME if base is 16. */
		if (token != NUMBER &&
		    (base != 16 || token != NUMBER_OR_NAME)) {
			parse_warn("expecting numeric value.");
			skip_to_semi(cfile);
			return (NULL);
		}
		/*
		 * If we can, convert the number now; otherwise, build a
		 * linked list of all the numbers.
		 */
		if (s) {
			convert_num(s, val, base, size);
			s += size / 8;
		} else {
			t = malloc(strlen(val) + 1);
			if (!t)
				error("no temp space for number.");
			strlcpy(t, val, strlen(val) + 1);
			c = cons(t, c);
		}
	} while (++count != *max);
d237 1
a237 18
	/* If we had to cons up a list, convert it now. */
	if (c) {
		bufp = malloc(count * size / 8);
		if (!bufp)
			error("can't allocate space for numeric aggregate.");
		s = bufp + count - size / 8;
		*max = count;
	}
	while (c) {
		pair cdr = c->cdr;
		convert_num(s, (char *)c->car, base, size);
		s -= size / 8;
		/* Free up temp space. */
		free(c->car);
		free(c);
		c = cdr;
	}
	return (bufp);
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.10 2004/05/04 22:23:01 mickey Exp $	*/
d440 1
a440 1
		return (NULL);
d450 1
a450 1
		return (NULL);
d462 1
a462 1
		return (NULL);
d471 1
a471 1
		return (NULL);
d481 1
a481 1
		return (NULL);
d490 1
a490 1
		return (NULL);
d500 1
a500 1
		return (NULL);
d510 1
a510 1
		return (NULL);
d519 1
a519 1
		return (NULL);
d529 1
a529 1
		return (NULL);
d538 1
a538 1
		return (NULL);
d551 1
a551 1
		return (NULL);
@


1.10
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.9 2004/05/04 21:48:16 deraadt Exp $	*/
d63 1
a63 2
	int brace_count = 0;
	int token;
d115 1
a115 1
	char *val;
a116 1
	char *s;
d190 2
a191 2
		memcpy((unsigned char *)&hardware->haddr[0],
		    t, hardware->hlen);
d428 3
a431 1
	int guess;
a432 3
	int token;
	static int months[11] = { 31, 59, 90, 120, 151, 181,
	    212, 243, 273, 304, 334 };
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.8 2004/05/04 20:28:40 deraadt Exp $	*/
d355 1
a355 1
			warn("Bogus number: %s.", str);
d359 1
a359 1
			warn("Bogus number: %s: digit %d not in base %d",
d373 1
a373 1
			warn("value %s%o exceeds max (%d) for precision.",
d377 1
a377 1
			warn("value %s%x exceeds max (%d) for precision.",
d381 1
a381 1
			warn("value %s%u exceeds max (%d) for precision.",
d399 1
a399 1
			warn("Unexpected integer size: %d", size);
d414 1
a414 1
			warn("Unexpected integer size: %d", size);
@


1.8
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.7 2004/02/24 13:08:26 henning Exp $	*/
d63 1
a65 1
	int brace_count = 0;
d153 2
a155 3
	int token;
	int hlen;
	unsigned char *t;
a240 2
	char *val;
	int token;
d242 2
a243 2
	char *t;
	int count = 0;
d321 2
a323 4
	int negative = 0;
	u_int32_t val = 0;
	int tval;
	int max;
@


1.7
log
@cut more crap - no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.6 2004/02/23 20:09:02 deraadt Exp $	*/
a132 57
	return (s);
}

/*
 * hostname :== identifier | hostname DOT identifier
 */
char *
parse_host_name(FILE *cfile)
{
	char *val;
	int token;
	int len = 0;
	char *s;
	char *t;
	pair c = NULL;

	/* Read a dotted hostname... */
	do {
		/* Read a token, which should be an identifier. */
		token = next_token(&val, cfile);
		if (!is_identifier(token) && token != NUMBER) {
			parse_warn("expecting an identifier in hostname");
			skip_to_semi(cfile);
			return (NULL);
		}
		/* Store this identifier... */
		if (!(s = malloc(strlen(val) + 1)))
			error("can't allocate temp space for hostname.");
		strlcpy(s, val, strlen(val) + 1);
		c = cons((caddr_t)s, c);
		len += strlen(s) + 1;
		/*
		 * Look for a dot; if it's there, keep going, otherwise
		 * we're done.
		 */
		token = peek_token(&val, cfile);
		if (token == DOT)
			token = next_token(&val, cfile);
	} while (token == DOT);

	/* Assemble the hostname together into a string. */
	if (!(s = malloc(len)))
		error("can't allocate space for hostname.");
	t = s + len;
	*--t = '\0';
	while (c) {
		pair cdr = c->cdr;
		int l = strlen((char *)c->car);
		t -= l;
		memcpy(t, (char *)c->car, l);
		/* Free up temp space. */
		free(c->car);
		free(c);
		c = cdr;
		if (t != s)
			*--t = '.';
	}
@


1.6
log
@remove time_t related crud; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.5 2004/02/07 13:59:45 henning Exp $	*/
d81 1
a81 1
		} else if (token == EOL) {
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.4 2004/02/07 13:26:35 henning Exp $	*/
d269 1
a269 1
parse_lease_time(FILE *cfile, TIME *timep)
d489 1
a489 1
TIME
@


1.4
log
@more KNF From: Emil Mikulic <emikulic@@dmr.ath.cx>
great job.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.3 2004/02/06 11:33:22 henning Exp $	*/
d621 7
a627 7
		      (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
		      (tm.tm_mon		/* Days in months this year */
		       ? months[tm.tm_mon - 1]
		       : 0) +
		      (tm.tm_mon > 1 &&		/* Leap day this year */
		       !((tm.tm_year - 72) & 3)) +
		      tm.tm_mday - 1) * 24) +	/* Day of month */
d629 1
a629 1
		  tm.tm_min) * 60) + tm.tm_sec;
@


1.3
log
@more Knall & Rauch -> ANSI C, KNF and stuff that makes this a bit more
readable. no effect on the binary.
From: Emil Mikulic <emikulic@@dmr.ath.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.2 2004/02/04 12:16:56 henning Exp $	*/
d126 1
a126 1
	s = (char *)malloc(strlen(val) + 1);
d159 1
a159 1
		if (!(s = (char *)malloc(strlen(val) + 1)))
d174 1
a174 1
	if (!(s = (char *)malloc(len)))
d307 1
a307 1
		bufp = (unsigned char *)malloc(*max * size / 8);
d350 1
a350 1
			t = (char *)malloc(strlen(val) + 1);
d360 1
a360 1
		bufp = (unsigned char *)malloc(count * size / 8);
d623 1
a623 1
		       ? months [tm.tm_mon - 1]
@


1.2
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 15
a61 15
   braces, the matching closing brace terminates the statement.   If we
   encounter a right brace but haven't encountered a left brace, return
   leaving the brace in the token buffer for the caller.   If we see a
   semicolon and haven't seen a left brace, return.   This lets us skip
   over:

   	statement;
	statement foo bar { }
	statement foo bar { statement { } }
	statement}
 
	...et cetera. */

void skip_to_semi (cfile)
	FILE *cfile;
d68 1
a68 1
		token = peek_token (&val, cfile);
d71 1
a71 1
				token = next_token (&val, cfile);
d79 1
a79 1
			token = next_token (&val, cfile);
d82 7
a88 4
			/* EOL only happens when parsing /etc/resolv.conf,
			   and we treat it like a semicolon because the
			   resolv.conf file is line-oriented. */
			token = next_token (&val, cfile);
d91 1
a91 1
		token = next_token (&val, cfile);
d95 2
a96 2
int parse_semi (cfile)
	FILE *cfile;
d101 1
a101 1
	token = next_token (&val, cfile);
d103 3
a105 3
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
		return 0;
d107 1
a107 1
	return 1;
d110 5
a114 4
/* string-parameter :== STRING SEMI */

char *parse_string (cfile)
	FILE *cfile;
d120 1
a120 1
	token = next_token (&val, cfile);
d122 3
a124 3
		parse_warn ("filename must be a string");
		skip_to_semi (cfile);
		return (char *)0;
d126 1
a126 1
	s = (char *)malloc (strlen (val) + 1);
d128 2
a129 2
		error ("no memory for string %s.", val);
	strlcpy (s, val, strlen(val) + 1);
d131 3
a133 3
	if (!parse_semi (cfile))
		return (char *)0;
	return s;
d136 5
a140 4
/* hostname :== identifier | hostname DOT identifier */

char *parse_host_name (cfile)
	FILE *cfile;
d147 2
a148 2
	pair c = (pair)0;
	
d152 5
a156 5
		token = next_token (&val, cfile);
		if (!is_identifier (token) && token != NUMBER) {
			parse_warn ("expecting an identifier in hostname");
			skip_to_semi (cfile);
			return (char *)0;
d159 10
a168 8
		if (!(s = (char *)malloc (strlen (val) + 1)))
			error ("can't allocate temp space for hostname.");
		strlcpy (s, val, strlen(val) + 1);
		c = cons ((caddr_t)s, c);
		len += strlen (s) + 1;
		/* Look for a dot; if it's there, keep going, otherwise
		   we're done. */
		token = peek_token (&val, cfile);
d170 1
a170 1
			token = next_token (&val, cfile);
d174 2
a175 2
	if (!(s = (char *)malloc (len)))
		error ("can't allocate space for hostname.");
d177 1
a177 1
	*--t = 0;
d179 2
a180 2
		pair cdr = c -> cdr;
		int l = strlen ((char *)(c -> car));
d182 1
a182 1
		memcpy (t, (char *)(c -> car), l);
d184 2
a185 2
		free (c -> car);
		free (c);
d190 1
a190 1
	return s;
d193 2
a194 3
int parse_ip_addr (cfile, addr)
	FILE *cfile;
	struct iaddr *addr;
d196 13
a208 13
	addr -> len = 4;
	if (parse_numeric_aggregate (cfile, addr -> iabuf,
				     &addr -> len, DOT, 10, 8))
		return 1;
	return 0;
}	

/* hardware-parameter :== HARDWARE ETHERNET csns SEMI
   csns :== NUMBER | csns COLON NUMBER */

void parse_hardware_param (cfile, hardware)
	FILE *cfile;
	struct hardware *hardware;
d215 1
a215 1
	token = next_token (&val, cfile);
d217 2
a218 2
	      case ETHERNET:
		hardware -> htype = HTYPE_ETHER;
d220 2
a221 2
	      case TOKEN_RING:
		hardware -> htype = HTYPE_IEEE802;
d223 2
a224 2
	      case FDDI:
		hardware -> htype = HTYPE_FDDI;
d226 3
a228 3
	      default:
		parse_warn ("expecting a network hardware type");
		skip_to_semi (cfile);
d232 9
a240 7
	/* Parse the hardware address information.   Technically,
	   it would make a lot of sense to restrict the length of the
	   data we'll accept here to the length of a particular hardware
	   address type.   Unfortunately, there are some broken clients
	   out there that put bogus data in the chaddr buffer, and we accept
	   that data in the lease file rather than simply failing on such
	   clients.   Yuck. */
d242 1
a242 2
	t = parse_numeric_aggregate (cfile, (unsigned char *)0, &hlen,
				     COLON, 16, 8);
d245 3
a247 3
	if (hlen > sizeof hardware -> haddr) {
		free (t);
		parse_warn ("hardware address too long");
d249 7
a255 7
		hardware -> hlen = hlen;
		memcpy ((unsigned char *)&hardware -> haddr [0],
			t, hardware -> hlen);
		if (hlen < sizeof hardware -> haddr)
			memset (&hardware -> haddr [hlen], 0,
				(sizeof hardware -> haddr) - hlen);
		free (t);
d257 2
a258 2
	
	token = next_token (&val, cfile);
d260 2
a261 2
		parse_warn ("expecting semicolon.");
		skip_to_semi (cfile);
d265 5
a269 5
/* lease-time :== NUMBER SEMI */

void parse_lease_time (cfile, timep)
	FILE *cfile;
	TIME *timep;
d274 1
a274 1
	token = next_token (&val, cfile);
d276 2
a277 2
		parse_warn ("Expecting numeric lease time");
		skip_to_semi (cfile);
d280 1
a280 1
	convert_num ((unsigned char *)timep, val, 10, 32);
d282 1
a282 1
	*timep = ntohl (*timep); /* XXX */
d284 1
a284 1
	parse_semi (cfile);
d287 11
a297 15
/* No BNF for numeric aggregates - that's defined by the caller.  What
   this function does is to parse a sequence of numbers separated by
   the token specified in separator.  If max is zero, any number of
   numbers will be parsed; otherwise, exactly max numbers are
   expected.  Base and size tell us how to internalize the numbers
   once they've been tokenized. */

unsigned char *parse_numeric_aggregate (cfile, buf,
					max, separator, base, size)
	FILE *cfile;
	unsigned char *buf;
	int *max;
	int separator;
	int base;
	int size;
d304 1
a304 1
	pair c = (pair)0;
d307 1
a307 1
		bufp = (unsigned char *)malloc (*max * size / 8);
d309 1
a309 1
			error ("can't allocate space for numeric aggregate");
d315 1
a315 1
			token = peek_token (&val, cfile);
d320 2
a321 2
					token = next_token (&val, cfile);
				parse_warn ("too few numbers.");
d323 2
a324 2
					skip_to_semi (cfile);
				return (unsigned char *)0;
d326 1
a326 1
			token = next_token (&val, cfile);
d328 1
a328 1
		token = next_token (&val, cfile);
d331 1
a331 1
			parse_warn ("unexpected end of file");
d338 8
a345 6
			parse_warn ("expecting numeric value.");
			skip_to_semi (cfile);
			return (unsigned char *)0;
		}
		/* If we can, convert the number now; otherwise, build
		   a linked list of all the numbers. */
d347 1
a347 1
			convert_num (s, val, base, size);
d350 1
a350 1
			t = (char *)malloc (strlen (val) + 1);
d352 3
a354 3
				error ("no temp space for number.");
			strlcpy (t, val, strlen(val)+1);
			c = cons (t, c);
d360 1
a360 1
		bufp = (unsigned char *)malloc (count * size / 8);
d362 1
a362 1
			error ("can't allocate space for numeric aggregate.");
d367 2
a368 2
		pair cdr = c -> cdr;
		convert_num (s, (char *)(c -> car), base, size);
d371 2
a372 2
		free (c -> car);
		free (c);
d375 1
a375 1
	return bufp;
d378 2
a379 5
void convert_num (buf, str, base, size)
	unsigned char *buf;
	char *str;
	int base;
	int size;
d389 1
a389 1
		++ptr;
d394 2
a395 2
		if (ptr [0] == '0') {
			if (ptr [1] == 'x') {
d398 1
a398 1
			} else if (isascii (ptr [1]) && isdigit (ptr [1])) {
d401 1
a401 1
			} else {
d403 1
a403 2
			}
		} else {
a404 1
		}
d417 1
a417 1
			warn ("Bogus number: %s.", str);
d421 2
a422 2
			warn ("Bogus number: %s: digit %d not in base %d",
			      str, tval, base);
d434 11
a444 11
		      case 8:
			warn ("value %s%o exceeds max (%d) for precision.",
			      negative ? "-" : "", val, max);
			break;
		      case 16:
			warn ("value %s%x exceeds max (%d) for precision.",
			      negative ? "-" : "", val, max);
			break;
		      default:
			warn ("value %s%u exceeds max (%d) for precision.",
			      negative ? "-" : "", val, max);
d449 1
a449 1
	if (negative) {
d451 1
a451 1
		      case 8:
d454 2
a455 2
		      case 16:
			putShort (buf, -(unsigned long)val);
d457 2
a458 2
		      case 32:
			putLong (buf, -(unsigned long)val);
d460 2
a461 2
		      default:
			warn ("Unexpected integer size: %d", size);
d464 1
a464 1
	} else {
d466 1
a466 1
		      case 8:
d469 2
a470 2
		      case 16:
			putUShort (buf, (u_int16_t)val);
d472 2
a473 2
		      case 32:
			putULong (buf, val);
d475 2
a476 2
		      default:
			warn ("Unexpected integer size: %d", size);
a478 1
	}
d481 10
a490 9
/* date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER 
   		NUMBER COLON NUMBER COLON NUMBER SEMI

   Dates are always in GMT; first number is day of week; next is
   year/month/day; next is hours:minutes:seconds on a 24-hour
   clock. */

TIME parse_date (cfile)
	FILE *cfile;
d496 2
a497 2
	static int months [11] = { 31, 59, 90, 120, 151, 181,
					  212, 243, 273, 304, 334 };
d500 1
a500 1
	token = next_token (&val, cfile);
d502 1
a502 1
		parse_warn ("numeric day of week expected.");
d504 2
a505 2
			skip_to_semi (cfile);
		return (TIME)0;
d507 1
a507 1
	tm.tm_wday = atoi (val);
d510 1
a510 1
	token = next_token (&val, cfile);
d512 1
a512 1
		parse_warn ("numeric year expected.");
d514 2
a515 2
			skip_to_semi (cfile);
		return (TIME)0;
d517 1
a517 1
	tm.tm_year = atoi (val);
d522 1
a522 1
	token = next_token (&val, cfile);
d524 1
a524 1
		parse_warn ("expected slash separating year from month.");
d526 2
a527 2
			skip_to_semi (cfile);
		return (TIME)0;
d531 1
a531 1
	token = next_token (&val, cfile);
d533 1
a533 1
		parse_warn ("numeric month expected.");
d535 2
a536 2
			skip_to_semi (cfile);
		return (TIME)0;
d538 1
a538 1
	tm.tm_mon = atoi (val) - 1;
d541 1
a541 1
	token = next_token (&val, cfile);
d543 1
a543 1
		parse_warn ("expected slash separating month from day.");
d545 2
a546 2
			skip_to_semi (cfile);
		return (TIME)0;
d550 1
a550 1
	token = next_token (&val, cfile);
d552 1
a552 1
		parse_warn ("numeric day of month expected.");
d554 2
a555 2
			skip_to_semi (cfile);
		return (TIME)0;
d557 1
a557 1
	tm.tm_mday = atoi (val);
d560 1
a560 1
	token = next_token (&val, cfile);
d562 1
a562 1
		parse_warn ("numeric hour expected.");
d564 2
a565 2
			skip_to_semi (cfile);
		return (TIME)0;
d567 1
a567 1
	tm.tm_hour = atoi (val);
d570 1
a570 1
	token = next_token (&val, cfile);
d572 1
a572 1
		parse_warn ("expected colon separating hour from minute.");
d574 2
a575 2
			skip_to_semi (cfile);
		return (TIME)0;
d579 1
a579 1
	token = next_token (&val, cfile);
d581 1
a581 1
		parse_warn ("numeric minute expected.");
d583 2
a584 2
			skip_to_semi (cfile);
		return (TIME)0;
d586 1
a586 1
	tm.tm_min = atoi (val);
d589 1
a589 1
	token = next_token (&val, cfile);
d591 1
a591 1
		parse_warn ("expected colon separating hour from minute.");
d593 2
a594 2
			skip_to_semi (cfile);
		return (TIME)0;
d598 1
a598 1
	token = next_token (&val, cfile);
d600 1
a600 1
		parse_warn ("numeric minute expected.");
d602 2
a603 2
			skip_to_semi (cfile);
		return (TIME)0;
d605 1
a605 1
	tm.tm_sec = atoi (val);
d608 1
a608 1
	/* XXX */ /* We assume that mktime does not use tm_yday. */
d612 1
a612 1
	token = next_token (&val, cfile);
d614 3
a616 3
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
		return 0;
d631 11
a641 10
	/* This guess could be wrong because of leap seconds or other
	   weirdness we don't know about that the system does.   For
	   now, we're just going to accept the guess, but at some point
	   it might be nice to do a successive approximation here to
	   get an exact value.   Even if the error is small, if the
	   server is restarted frequently (and thus the lease database
	   is reread), the error could accumulate into something
	   significant. */

	return guess;
@


1.1
log
@this is where dhclient will start surgery
@
text
@d1 1
a1 1
/* parse.c
d3 1
a3 1
   Common parser code for dhcpd and dhclient. */
@

