head	1.38;
access;
symbols
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.12
	OPENBSD_5_0:1.13.0.10
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.8
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.38
date	2017.07.09.19.19.58;	author krw;	state Exp;
branches;
next	1.37;
commitid	0BGOuT2HbB9sCm2t;

1.37
date	2017.07.08.00.36.10;	author krw;	state Exp;
branches;
next	1.36;
commitid	fG77ONbQ8YTfWdI4;

1.36
date	2017.07.07.15.14.47;	author krw;	state Exp;
branches;
next	1.35;
commitid	f8meVC01qYNRWhNX;

1.35
date	2017.04.18.13.59.09;	author krw;	state Exp;
branches;
next	1.34;
commitid	cFUzT9OoC4hYJl7A;

1.34
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.33;
commitid	KIdulj0iLtM6kXff;

1.33
date	2017.03.08.14.19.00;	author krw;	state Exp;
branches;
next	1.32;
commitid	H8xvWxW8Df1Sly9w;

1.32
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.31;
commitid	IDlzr3qamZK5lxzj;

1.31
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.30;
commitid	Tm7CrlqCKqgQoJ7P;

1.30
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.29;
commitid	5ELOU0S0Zl3aCrHG;

1.29
date	2016.02.03.14.48.36;	author krw;	state Exp;
branches;
next	1.28;
commitid	IE5ZAwOumxPJ0eHN;

1.28
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.27;
commitid	RKMpGS78lskgSHj4;

1.27
date	2014.07.28.16.40.32;	author tobias;	state Exp;
branches;
next	1.26;
commitid	9DpOO6mtcRw7JbT5;

1.26
date	2014.04.17.09.59.30;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.20.09.16.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.12.12.00.22.06;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2013.12.11.00.31.12;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.12.05.21.32.59;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2013.12.05.21.03.40;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.12.04.19.39.50;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.24.01.26.30;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.02.03.21.04.19;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.05.13.41.56;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.06.04.02.42;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.28.01.10.46;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.22.03.18.14;	author stevesk;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.25.14.22.12;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.24.13.36.13;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.24.00.34.40;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.23.18.27.37;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.13.26.35;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.06.11.33.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Be consistent. "return (e);" -> "return e;"
@
text
@/*	$OpenBSD: packet.c,v 1.37 2017/07/08 00:36:10 krw Exp $	*/

/* Packet assembly code, originally contributed by Archie Cobbs. */

/*
 * Copyright (c) 1995, 1996, 1999 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/queue.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/if_ether.h>

#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"

uint32_t
checksum(unsigned char *buf, uint32_t nbytes, uint32_t sum)
{
	unsigned int i;

	/* Checksum all the pairs of bytes first. */
	for (i = 0; i < (nbytes & ~1U); i += 2) {
		sum += (uint16_t)ntohs(*((uint16_t *)(buf + i)));
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	/*
	 * If there's a single byte left over, checksum it, too.
	 * Network byte order is big-endian, so the remaining byte is
	 * the high byte.
	 */
	if (i < nbytes) {
		sum += buf[i] << 8;
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	return sum;
}

uint32_t
wrapsum(uint32_t sum)
{
	sum = ~sum & 0xFFFF;
	return htons(sum);
}

void
assemble_eh_header(struct ether_addr shost, struct ether_header *eh)
{
	memset(eh->ether_dhost, 0xff, sizeof(eh->ether_dhost));

	memcpy(eh->ether_shost, shost.ether_addr_octet,
	    sizeof(eh->ether_shost));

	eh->ether_type = htons(ETHERTYPE_IP);
}

ssize_t
decode_hw_header(unsigned char *buf, uint32_t buflen, struct ether_addr *from)
{
	struct ether_header eh;

	if (buflen < sizeof(eh))
		return -1;

	memcpy(&eh, buf, sizeof(eh));

	memcpy(from->ether_addr_octet, eh.ether_shost, ETHER_ADDR_LEN);

	return sizeof(eh);
}

ssize_t
decode_udp_ip_header(unsigned char *buf, uint32_t buflen,
    struct sockaddr_in *from)
{
	static int	 ip_packets_seen;
	static int	 ip_packets_bad_checksum;
	static int	 udp_packets_seen;
	static int	 udp_packets_bad_checksum;
	static int	 udp_packets_length_checked;
	static int	 udp_packets_length_overflow;
	struct ip	*ip;
	struct udphdr	*udp;
	unsigned char	*data;
	int		 len;
	uint32_t	 ip_len;
	uint32_t	 sum, usum;

	/* Assure that an entire IP header is within the buffer. */
	if (sizeof(*ip) > buflen)
		return -1;
	ip_len = (*buf & 0xf) << 2;
	if (ip_len > buflen)
		return -1;
	ip = (struct ip *)(buf);
	ip_packets_seen++;

	/* Check the IP header checksum - it should be zero. */
	if (wrapsum(checksum((unsigned char *)ip, ip_len, 0)) != 0) {
		ip_packets_bad_checksum++;
		if (ip_packets_seen > 4 && ip_packets_bad_checksum != 0 &&
		    (ip_packets_seen / ip_packets_bad_checksum) < 2) {
			log_info("%d bad IP checksums seen in %d packets",
			    ip_packets_bad_checksum, ip_packets_seen);
			ip_packets_seen = ip_packets_bad_checksum = 0;
		}
		return -1;
	}

	memcpy(&from->sin_addr, &ip->ip_src, sizeof(from->sin_addr));

#ifdef DEBUG
	if (ntohs(ip->ip_len) != buflen)
		log_debug("ip length %hu disagrees with bytes received %d.",
		    ntohs(ip->ip_len), buflen);
#endif	/* DEBUG */

	/* Assure that the entire IP packet is within the buffer. */
	if (ntohs(ip->ip_len) > buflen)
		return -1;

	/* Assure that the UDP header is within the buffer. */
	if (ip_len + sizeof(*udp) > buflen)
		return -1;
	udp = (struct udphdr *)(buf + ip_len);
	udp_packets_seen++;

	/* Assure that the entire UDP packet is within the buffer. */
	if (ip_len + ntohs(udp->uh_ulen) > buflen)
		return -1;
	data = buf + ip_len + sizeof(*udp);

	/*
	 * Compute UDP checksums, including the ``pseudo-header'', the
	 * UDP header and the data. If the UDP checksum field is zero,
	 * we're not supposed to do a checksum.
	 */
	udp_packets_length_checked++;
	len = ntohs(udp->uh_ulen) - sizeof(*udp);
	if ((len < 0) || (len + data > buf + buflen)) {
		udp_packets_length_overflow++;
		if (udp_packets_length_checked > 4 &&
		    udp_packets_length_overflow != 0 &&
		    (udp_packets_length_checked /
		    udp_packets_length_overflow) < 2) {
			log_info("%d udp packets in %d too long - dropped",
			    udp_packets_length_overflow,
			    udp_packets_length_checked);
			udp_packets_length_overflow =
			    udp_packets_length_checked = 0;
		}
		return -1;
	}
#ifdef DEBUG
	if (len + data != buf + buflen)
		log_debug("accepting packet with data after udp payload.");
#endif	/* DEBUG */

	usum = udp->uh_sum;
	udp->uh_sum = 0;

	sum = wrapsum(checksum((unsigned char *)udp, sizeof(*udp),
	    checksum(data, len, checksum((unsigned char *)&ip->ip_src,
	    2 * sizeof(ip->ip_src),
	    IPPROTO_UDP + (uint32_t)ntohs(udp->uh_ulen)))));

	udp_packets_seen++;
	if (usum && usum != sum) {
		udp_packets_bad_checksum++;
		if (udp_packets_seen > 4 && udp_packets_bad_checksum != 0 &&
		    (udp_packets_seen / udp_packets_bad_checksum) < 2) {
			log_info("%d bad udp checksums in %d packets",
			    udp_packets_bad_checksum, udp_packets_seen);
			udp_packets_seen = udp_packets_bad_checksum = 0;
		}
		return -1;
	}

	memcpy(&from->sin_port, &udp->uh_sport, sizeof(udp->uh_sport));

	return ip_len + sizeof(*udp);
}
@


1.37
log
@Always use uintNN_t instead of sometimes u_intNN_t
and sometimes uintNN_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.36 2017/07/07 15:14:47 krw Exp $	*/
d85 1
a85 1
	return (sum);
d92 1
a92 1
	return (htons(sum));
d112 1
a112 1
		return (-1);
d118 1
a118 1
	return (sizeof(eh));
d140 1
a140 1
		return (-1);
d143 1
a143 1
		return (-1);
d156 1
a156 1
		return (-1);
d169 1
a169 1
		return (-1);
d173 1
a173 1
		return (-1);
d179 1
a179 1
		return (-1);
d201 1
a201 1
		return (-1);
d225 1
a225 1
		return (-1);
d230 1
a230 1
	return (ip_len + sizeof(*udp));
@


1.36
log
@assemble_eh_header() needs only to know about hw_addr.

No more struct interface_info knowledge in packet.c
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.35 2017/04/18 13:59:09 krw Exp $	*/
d62 2
a63 2
u_int32_t
checksum(unsigned char *buf, u_int32_t nbytes, u_int32_t sum)
d69 1
a69 1
		sum += (u_int16_t)ntohs(*((u_int16_t *)(buf + i)));
d88 2
a89 2
u_int32_t
wrapsum(u_int32_t sum)
d107 1
a107 1
decode_hw_header(unsigned char *buf, u_int32_t buflen, struct ether_addr *from)
d122 1
a122 1
decode_udp_ip_header(unsigned char *buf, u_int32_t buflen,
d125 12
a136 12
	struct ip *ip;
	struct udphdr *udp;
	unsigned char *data;
	u_int32_t ip_len;
	u_int32_t sum, usum;
	static int ip_packets_seen;
	static int ip_packets_bad_checksum;
	static int udp_packets_seen;
	static int udp_packets_bad_checksum;
	static int udp_packets_length_checked;
	static int udp_packets_length_overflow;
	int len;
d214 1
a214 1
	    IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)))));
@


1.35
log
@Tweak parameters to decode_*, add a check or two, and thus gain most of the
sanity improvements reyk@@ recently put into dhcrelay to ensure no more than
the captured packet is processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.34 2017/04/08 20:16:04 krw Exp $	*/
d96 1
a96 1
assemble_eh_header(struct interface_info *ifi, struct ether_header *eh)
d100 1
a100 1
	memcpy(eh->ether_shost, ifi->hw_address.ether_addr_octet,
@


1.34
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.33 2017/03/08 14:19:00 krw Exp $	*/
d107 1
a107 1
decode_hw_header(unsigned char *buf, int bufix, struct ether_addr *from)
d111 4
a114 1
	memcpy(&eh, buf + bufix, ETHER_HDR_LEN);
d122 2
a123 2
decode_udp_ip_header(unsigned char *buf, int bufix, struct sockaddr_in *from,
    u_int32_t buflen)
d141 1
a141 1
	ip_len = (buf[bufix] & 0xf) << 2;
d144 1
a144 1
	ip = (struct ip *)(buf + bufix);
d148 1
a148 1
	if (wrapsum(checksum(buf + bufix, ip_len, 0)) != 0) {
d174 1
a174 1
	udp = (struct udphdr *)(buf + bufix + ip_len);
d180 1
a180 1
	data = buf + bufix + ip_len + sizeof(*udp);
d189 1
a189 1
	if ((len < 0) || (len + data > buf + bufix + buflen)) {
d204 1
a204 1
	if (len + data != buf + bufix + buflen)
@


1.33
log
@Add comments to #endif's to allow easy differentiation between many
incoming #ifdef's.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.32 2017/02/12 13:15:50 krw Exp $	*/
d63 1
a63 1
checksum(unsigned char *buf, unsigned nbytes, u_int32_t sum)
d65 1
a65 1
	int i;
d120 1
a120 1
    int buflen)
@


1.32
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.31 2016/08/23 09:26:02 mpi Exp $	*/
d162 1
a162 1
#endif
d203 1
a203 1
#endif
@


1.31
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.30 2016/02/06 19:30:52 krw Exp $	*/
d60 1
d149 1
a149 1
			note("%d bad IP checksums seen in %d packets",
d160 1
a160 1
		debug("ip length %hu disagrees with bytes received %d.",
d192 1
a192 1
			note("%d udp packets in %d too long - dropped",
d202 1
a202 1
		debug("accepting packet with data after udp payload.");
d218 1
a218 1
			note("%d bad udp checksums in %d packets",
@


1.30
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.29 2016/02/03 14:48:36 krw Exp $	*/
d95 1
a95 1
assemble_eh_header(struct ether_header *eh)
@


1.29
log
@be very careful accepting packets via bpf. First check that the
fixed part of the IP header is completely present before using its
header length field.  Then use the data in the IP header to ensure
the entire IP packet is present. Then check that the entire UDP header
is present. Then use the data in the UDP header to ensure all the
data it thinks is present is actually present.

Started when tj@@ and a few others noticed ISC "DHCP CVE-2015-8605:
UDP payload length not properly checked".

ok sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.28 2014/10/25 03:18:13 lteo Exp $	*/
d43 4
a46 1
#include "dhcpd.h"
d48 1
d51 9
@


1.28
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.27 2014/07/28 16:40:32 tobias Exp $	*/
d111 1
a111 1
	u_int32_t ip_len = (buf[bufix] & 0xf) << 2;
d121 6
d128 1
a128 1
	udp = (struct udphdr *)(buf + bufix + ip_len);
a130 1
	ip_packets_seen++;
d142 2
d150 14
a163 1
	memcpy(&from->sin_addr, &ip->ip_src, sizeof(from->sin_addr));
d170 1
a170 1
	data = buf + bufix + ip_len + sizeof(*udp);
a171 1
	udp_packets_length_checked++;
@


1.27
log
@merge dhcpd's packet.c revision 1.7:

Fix very hard to reach DoS attack vector, which would involve more than
8 billion network packets.  Mixture of many many malformed and proper
packets could result in a division by zero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.26 2014/04/17 09:59:30 krw Exp $	*/
a44 1
#include <netinet/in_systm.h>
@


1.26
log
@Eliminate a couple of always-NULL parameters. Eliminate some
pointless repetition of well-known info in log messages. Pass
around smaller bits of info. Make 'inaddr_any' a const struct
initialized with { INADDR_ANY }.

Tweaks and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.25 2014/01/20 09:16:36 deraadt Exp $	*/
d129 1
a129 1
		if (ip_packets_seen > 4 &&
d157 1
d184 1
a184 1
		if (udp_packets_seen > 4 &&
@


1.25
log
@more %d type correctness; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.24 2013/12/12 00:22:06 krw Exp $	*/
d83 1
a83 1
assemble_eh_header(struct ether_header *eh, struct ether_addr *to)
d85 1
a85 5
	if (to != NULL)
		memcpy(eh->ether_dhost, to->ether_addr_octet,
		    sizeof(eh->ether_dhost));
	else
		memset(eh->ether_dhost, 0xff, sizeof(eh->ether_dhost));
@


1.24
log
@Assemble outgoing packets using iovec to combine the (optional)
ethernet header, the ip header, the udp header and the packet.
Rather than manually concatenating the headers and then using iovec
to bundle in the packet. Eliminates some memcpy()s and convoluted
data copying.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.23 2013/12/11 00:31:12 krw Exp $	*/
d144 1
a144 1
		debug("ip length %d disagrees with bytes received %d.",
@


1.23
log
@Stray memcpy() using src size.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.22 2013/12/06 23:40:48 krw Exp $	*/
a48 3
u_int32_t	checksum(unsigned char *, unsigned, u_int32_t);
u_int32_t	wrapsum(u_int32_t);

d83 1
a83 1
assemble_hw_header(unsigned char *buf, int *bufix, struct ether_addr *to)
a84 2
	struct ether_header eh;

d86 2
a87 2
		memcpy(eh.ether_dhost, to->ether_addr_octet,
		    sizeof(eh.ether_dhost));
d89 1
a89 17
		memset(eh.ether_dhost, 0xff, sizeof(eh.ether_dhost));

	memcpy(eh.ether_shost, ifi->hw_address.ether_addr_octet,
	    sizeof(eh.ether_shost));

	eh.ether_type = htons(ETHERTYPE_IP);

	memcpy(&buf[*bufix], &eh, ETHER_HDR_LEN);
	*bufix += ETHER_HDR_LEN;
}

void
assemble_udp_ip_header(unsigned char *buf, int *bufix, u_int32_t from,
    u_int32_t to, unsigned int port, unsigned char *data, int len)
{
	struct ip ip;
	struct udphdr udp;
d91 2
a92 25
	ip.ip_v = 4;
	ip.ip_hl = 5;
	ip.ip_tos = IPTOS_LOWDELAY;
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + len);
	ip.ip_id = 0;
	ip.ip_off = 0;
	ip.ip_ttl = 128;
	ip.ip_p = IPPROTO_UDP;
	ip.ip_sum = 0;
	ip.ip_src.s_addr = from;
	ip.ip_dst.s_addr = to;

	ip.ip_sum = wrapsum(checksum((unsigned char *)&ip, sizeof(ip), 0));
	memcpy(&buf[*bufix], &ip, sizeof(ip));
	*bufix += sizeof(ip);

	udp.uh_sport = htons(LOCAL_PORT);	/* XXX */
	udp.uh_dport = port;			/* XXX */
	udp.uh_ulen = htons(sizeof(udp) + len);
	memset(&udp.uh_sum, 0, sizeof(udp.uh_sum));

	udp.uh_sum = wrapsum(checksum((unsigned char *)&udp, sizeof(udp),
	    checksum(data, len, checksum((unsigned char *)&ip.ip_src,
	    2 * sizeof(ip.ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp.uh_ulen)))));
d94 1
a94 2
	memcpy(&buf[*bufix], &udp, sizeof(udp));
	*bufix += sizeof(udp);
@


1.22
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.21 2013/12/05 21:32:59 krw Exp $	*/
d149 1
a149 1
	memcpy(from->ether_addr_octet, eh.ether_shost, sizeof(eh.ether_shost));
@


1.21
log
@Use destination size as size of memcpy(). Use <in_addr> rather than
<in_addr>.s_addr to shorten code.

ok deraadt@@ matthew@@ as part of larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.20 2013/12/05 21:03:40 krw Exp $	*/
d86 1
a86 1
assemble_hw_header(unsigned char *buf, int *bufix, struct hardware *to)
d90 3
a92 2
	if (to != NULL && to->hlen == 6) /* XXX */
		memcpy(eh.ether_dhost, to->haddr, sizeof(eh.ether_dhost));
d95 3
a97 5
	if (ifi->hw_address.hlen == sizeof(eh.ether_shost))
		memcpy(eh.ether_shost, ifi->hw_address.haddr,
		    sizeof(eh.ether_shost));
	else
		memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));
d143 1
a143 1
decode_hw_header(unsigned char *buf, int bufix, struct hardware *from)
d149 1
a149 3
	memcpy(from->haddr, eh.ether_shost, sizeof(eh.ether_shost));
	from->htype = ARPHRD_ETHER;
	from->hlen = sizeof(eh.ether_shost);
@


1.20
log
@Nuke local #define ETHER_HEADER_SIZE and use the identical value'd
ETHER_HDR_LEN from if_ether.h. dhclient change ok matthew@@ as part
of larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.19 2013/12/04 19:39:50 krw Exp $	*/
d244 1
a244 1
	memcpy(&from->sin_port, &udp->uh_sport, sizeof(from->sin_port));
@


1.19
log
@More memcpy() stylistic repairs and size checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.18 2013/05/02 16:35:27 krw Exp $	*/
a48 2
#define ETHER_HEADER_SIZE (ETHER_ADDR_LEN * 2 + sizeof(u_int16_t))

d102 2
a103 2
	memcpy(&buf[*bufix], &eh, ETHER_HEADER_SIZE);
	*bufix += ETHER_HEADER_SIZE;
d148 1
a148 1
	memcpy(&eh, buf + bufix, ETHER_HEADER_SIZE);
@


1.18
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.17 2013/04/24 01:26:30 krw Exp $	*/
d198 1
a198 1
	memcpy(&from->sin_addr, &ip->ip_src, 4);
d246 1
a246 1
	memcpy(&from->sin_port, &udp->uh_sport, sizeof(udp->uh_sport));
@


1.17
log
@Follow ISC and freebsd by increasing ip_ttl on packets from 16 to
128, so people living many hops from their dhcp server can still
get leases.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.16 2013/02/03 21:04:19 krw Exp $	*/
d59 1
a59 1
	/* Checksum all the pairs of bytes first... */
@


1.16
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.15 2013/01/05 13:41:56 krw Exp $	*/
d121 1
a121 1
	ip.ip_ttl = 16;
@


1.15
log
@Apply same fix to UDP length check as was just committed in dhcpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.14 2012/11/15 14:54:18 krw Exp $	*/
d161 1
a161 1
    unsigned char *data, int buflen)
d165 1
d174 1
a174 1
	int len = 0;
d202 1
a202 1
	 * UDP header and the data.   If the UDP checksum field is zero,
d205 13
a217 16
	if (!data) {
		data = buf + bufix + ip_len + sizeof(*udp);
		len = ntohs(udp->uh_ulen) - sizeof(*udp);
		udp_packets_length_checked++;
		if ((len < 0) || (len + data > buf + bufix + buflen)) {
			udp_packets_length_overflow++;
			if (udp_packets_length_checked > 4 &&
			    (udp_packets_length_checked /
			    udp_packets_length_overflow) < 2) {
				note("%d udp packets in %d too long - dropped",
				    udp_packets_length_overflow,
				    udp_packets_length_checked);
				udp_packets_length_overflow =
				    udp_packets_length_checked = 0;
			}
			return (-1);
d219 2
d222 2
a223 2
		if (len + data != buf + bufix + buflen)
			debug("accepting packet with data after udp payload.");
a224 1
	}
@


1.14
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.13 2009/06/06 04:02:42 krw Exp $	*/
d208 1
a208 1
		if (len + data > buf + bufix + buflen) {
@


1.13
log
@Nuke debug() unless DEBUG is defined. Elminates debug output from
normal operations.

Prodded by deraadt@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.12 2006/12/28 01:10:46 stevesk Exp $	*/
a47 1
#include <netinet/if_ether.h>
@


1.12
log
@small knf (extra space, newline)
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2006/12/26 21:19:52 krw Exp $	*/
d192 1
d196 1
d222 1
d225 1
@


1.11
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2006/12/22 03:18:14 stevesk Exp $	*/
d89 1
a89 1
assemble_hw_header( unsigned char *buf, int *bufix, struct hardware *to)
@


1.10
log
@delete prototypes for functions that don't exist
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2004/05/04 18:58:50 deraadt Exp $	*/
d89 1
a89 2
assemble_hw_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, struct hardware *to)
d97 2
a98 2
	if (interface->hw_address.hlen == sizeof(eh.ether_shost))
		memcpy(eh.ether_shost, interface->hw_address.haddr,
@


1.9
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2004/02/25 14:22:12 henning Exp $	*/
a53 5

void	assemble_ethernet_header(struct interface_info *, unsigned char *,
	    int *, struct hardware *);
ssize_t	decode_ethernet_header(struct interface_info *, unsigned char *,
	    int bufix, struct hardware *);
@


1.8
log
@doesn't quite make sense to have a wrapper to a wrapper to the incredible
amount of ~ 20 lines of code in their own file...
and another one bites the dust
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2004/02/24 13:36:13 henning Exp $	*/
d116 2
a117 3
assemble_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, u_int32_t from, u_int32_t to, unsigned int port,
    unsigned char *data, int len)
d153 1
a153 2
decode_hw_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct hardware *from)
d167 2
a168 2
decode_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct sockaddr_in *from, unsigned char *data, int buflen)
@


1.7
log
@remove dynamic port gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2004/02/24 00:34:40 henning Exp $	*/
d48 11
a59 3
/*
 * Compute the easy part of the checksum on a range of bytes.
 */
a85 3
/*
 * Finish computing the sum, and then put it into network byte order.
 */
a92 5
/*
 * Assemble a hardware header...
 *
 * XXX currently only supports ethernet; doesn't check for other types.
 */
d97 16
a112 1
	assemble_ethernet_header(interface, buf, bufix, to);
a114 3
/*
 * UDP header and IP header assembled together for convenience.
 */
a122 1
	/* Fill out the IP header */
a138 1
	/* Fill out the UDP header */
a152 3
/*
 * Decode a hardware header...
 */
d157 9
a165 1
	return (decode_ethernet_header(interface, buf, bufix, from));
a167 3
/*
 * UDP header and IP header decoded together for convenience.
 */
@


1.6
log
@cut debug crap
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2004/02/23 18:27:37 henning Exp $	*/
d129 1
a129 1
	udp.uh_sport = local_port;		/* XXX */
@


1.5
log
@no token ring
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2004/02/07 13:26:35 henning Exp $	*/
a56 4
#ifdef DEBUG_CHECKSUM
	debug("checksum (%x %d %x)", buf, nbytes, sum);
#endif

a58 3
#ifdef DEBUG_CHECKSUM_VERBOSE
		debug("sum = %x", sum);
#endif
a59 1
		/* Add carry. */
a69 3
#ifdef DEBUG_CHECKSUM_VERBOSE
		debug("sum = %x", sum);
#endif
a70 1
		/* Add carry. */
a83 4
#ifdef DEBUG_CHECKSUM
	debug("wrapsum (%x)", sum);
#endif

a84 7
#ifdef DEBUG_CHECKSUM_VERBOSE
	debug("sum = %x", sum);
#endif

#ifdef DEBUG_CHECKSUM
	debug("wrapsum returns %x", htons(sum));
#endif
a123 1
	/* Checksum the IP header... */
a124 2

	/* Copy the ip header into the buffer... */
a133 4
	/*
	 * Compute UDP checksums, including the ``pseudo-header'', the
	 * UDP header and the data.
	 */
d136 2
a137 2
		2 * sizeof(ip.ip_src),
		IPPROTO_UDP + (u_int32_t)ntohs(udp.uh_ulen)))));
a138 1
	/* Copy the udp header into the buffer... */
a187 1
	/* Check the IP packet length. */
a191 1
	/* Copy out the IP source address... */
d225 2
a226 2
		2 * sizeof(ip->ip_src),
		IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)))));
a239 1
	/* Copy out the port... */
@


1.4
log
@more KNF From: Emil Mikulic <emikulic@@dmr.ath.cx>
great job.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2004/02/06 11:33:22 henning Exp $	*/
d120 1
a120 7
#ifdef HAVE_TR_SUPPORT
	if (interface->hw_address.htype == HTYPE_IEEE802)
		assemble_tr_header(interface, buf, bufix, to);
	else
#endif
		assemble_ethernet_header(interface, buf, bufix, to);

d181 1
a181 6
#ifdef HAVE_TR_SUPPORT
	if (interface->hw_address.htype == HTYPE_IEEE802)
		return (decode_tr_header(interface, buf, bufix, from));
	else
#endif
		return (decode_ethernet_header(interface, buf, bufix, from));
@


1.3
log
@more Knall & Rauch -> ANSI C, KNF and stuff that makes this a bit more
readable. no effect on the binary.
From: Emil Mikulic <emikulic@@dmr.ath.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.2 2004/02/04 12:16:56 henning Exp $	*/
d270 1
a270 1
		IPPROTO_UDP + (u_int32_t)ntohs(udp -> uh_ulen)))));
@


1.2
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 5
a53 6
/* Compute the easy part of the checksum on a range of bytes. */

u_int32_t checksum (buf, nbytes, sum)
	unsigned char *buf;
	unsigned nbytes;
	u_int32_t sum;
d58 1
a58 1
	debug ("checksum (%x %d %x)", buf, nbytes, sum);
d64 1
a64 1
		debug ("sum = %x", sum);
d66 1
a66 1
		sum += (u_int16_t) ntohs(*((u_int16_t *)(buf + i)));
d70 1
a70 1
	}	
d72 5
a76 2
	/* If there's a single byte left over, checksum it, too.   Network
	   byte order is big-endian, so the remaining byte is the high byte. */
d79 1
a79 1
		debug ("sum = %x", sum);
d81 1
a81 1
		sum += buf [i] << 8;
d86 2
a87 2
	
	return sum;
d90 5
a94 4
/* Finish computing the sum, and then put it into network byte order. */

u_int32_t wrapsum (sum)
	u_int32_t sum;
d97 1
a97 1
	debug ("wrapsum (%x)", sum);
d102 1
a102 1
	debug ("sum = %x", sum);
d104 1
a104 1
	
d106 1
a106 1
	debug ("wrapsum returns %x", htons (sum));
d108 1
a108 1
	return htons(sum);
d111 8
a118 8
/* Assemble an hardware header... */
/* XXX currently only supports ethernet; doesn't check for other types. */

void assemble_hw_header (interface, buf, bufix, to)
	struct interface_info *interface;
	unsigned char *buf;
	int *bufix;
	struct hardware *to;
d120 3
a122 3
#if defined (HAVE_TR_SUPPORT)
	if (interface -> hw_address.htype == HTYPE_IEEE802)
		assemble_tr_header (interface, buf, bufix, to);
d125 1
a125 1
		assemble_ethernet_header (interface, buf, bufix, to);
d129 7
a135 12
/* UDP header and IP header assembled together for convenience. */

void assemble_udp_ip_header (interface, buf, bufix,
			     from, to, port, data, len)
	struct interface_info *interface;
	unsigned char *buf;
	int *bufix;
	u_int32_t from;
	u_int32_t to;
	unsigned int port;
	unsigned char *data;
	int len;
d152 1
a152 1
	
d154 2
a155 2
	ip.ip_sum = wrapsum (checksum ((unsigned char *)&ip, sizeof ip, 0));
	
d157 2
a158 2
	memcpy (&buf [*bufix], &ip, sizeof ip);
	*bufix += sizeof ip;
d164 1
a164 1
	memset (&udp.uh_sum, 0, sizeof udp.uh_sum);
d166 8
a173 12
	/* Compute UDP checksums, including the ``pseudo-header'', the UDP
	   header and the data. */

	udp.uh_sum =
		wrapsum (checksum ((unsigned char *)&udp, sizeof udp,
				   checksum (data, len, 
					     checksum ((unsigned char *)
						       &ip.ip_src,
						       2 * sizeof ip.ip_src,
						       IPPROTO_UDP +
						       (u_int32_t)
						       ntohs (udp.uh_ulen)))));
d176 2
a177 2
	memcpy (&buf [*bufix], &udp, sizeof udp);
	*bufix += sizeof udp;
d180 6
a185 7
/* Decode a hardware header... */

ssize_t decode_hw_header (interface, buf, bufix, from)
     struct interface_info *interface;
     unsigned char *buf;
     int bufix;
     struct hardware *from;
d187 3
a189 3
#if defined (HAVE_TR_SUPPORT)
	if (interface -> hw_address.htype == HTYPE_IEEE802)
		return decode_tr_header (interface, buf, bufix, from);
d192 1
a192 1
		return decode_ethernet_header (interface, buf, bufix, from);
d195 68
a262 1
/* UDP header and IP header decoded together for convenience. */
d264 19
a282 92
ssize_t decode_udp_ip_header (interface, buf, bufix, from, data, buflen)
	struct interface_info *interface;
	unsigned char *buf;
	int bufix;
	struct sockaddr_in *from;
	unsigned char *data;
	int buflen;
{
  struct ip *ip;
  struct udphdr *udp;
  u_int32_t ip_len = (buf [bufix] & 0xf) << 2;
  u_int32_t sum, usum;
  static int ip_packets_seen;
  static int ip_packets_bad_checksum;
  static int udp_packets_seen;
  static int udp_packets_bad_checksum;
  static int udp_packets_length_checked;
  static int udp_packets_length_overflow;
  int len = 0;

  ip = (struct ip *)(buf + bufix);
  udp = (struct udphdr *)(buf + bufix + ip_len);

  /* Check the IP header checksum - it should be zero. */
  ++ip_packets_seen;
  if (wrapsum (checksum (buf + bufix, ip_len, 0))) {
	  ++ip_packets_bad_checksum;
	  if (ip_packets_seen > 4 &&
	      (ip_packets_seen / ip_packets_bad_checksum) < 2) {
		  note ("%d bad IP checksums seen in %d packets",
			ip_packets_bad_checksum, ip_packets_seen);
		  ip_packets_seen = ip_packets_bad_checksum = 0;
	  }
	  return -1;
  }

  /* Check the IP packet length. */
  if (ntohs (ip -> ip_len) != buflen)
	  debug ("ip length %d disagrees with bytes received %d.",
		 ntohs (ip -> ip_len), buflen);

  /* Copy out the IP source address... */
  memcpy (&from -> sin_addr, &ip -> ip_src, 4);

  /* Compute UDP checksums, including the ``pseudo-header'', the UDP
     header and the data.   If the UDP checksum field is zero, we're
     not supposed to do a checksum. */

  if (!data) {
	  data = buf + bufix + ip_len + sizeof *udp;
	  len = ntohs (udp -> uh_ulen) - sizeof *udp;
	  ++udp_packets_length_checked;
	  if (len + data > buf + bufix + buflen) {
		  ++udp_packets_length_overflow;
		  if (udp_packets_length_checked > 4 &&
		      (udp_packets_length_checked /
		       udp_packets_length_overflow) < 2) {
			  note ("%d udp packets in %d too long - dropped",
				udp_packets_length_overflow,
				udp_packets_length_checked);
			  udp_packets_length_overflow =
				  udp_packets_length_checked = 0;
		  }
		  return -1;
	  }
	  if (len + data != buf + bufix + buflen)
		  debug ("accepting packet with data after udp payload.");
  }

  usum = udp -> uh_sum;
  udp -> uh_sum = 0;

  sum = wrapsum (checksum ((unsigned char *)udp, sizeof *udp,
			   checksum (data, len,
				     checksum ((unsigned char *)
					       &ip -> ip_src,
					       2 * sizeof ip -> ip_src,
					       IPPROTO_UDP +
					       (u_int32_t)
					       ntohs (udp -> uh_ulen)))));

  udp_packets_seen++;
  if (usum && usum != sum) {
	  udp_packets_bad_checksum++;
	  if (udp_packets_seen > 4 &&
	      (udp_packets_seen / udp_packets_bad_checksum) < 2) {
		  note ("%d bad udp checksums in %d packets",
			udp_packets_bad_checksum, udp_packets_seen);
		  udp_packets_seen = udp_packets_bad_checksum = 0;
	  }
	  return -1;
  }
d284 2
a285 2
  /* Copy out the port... */
  memcpy (&from -> sin_port, &udp -> uh_sport, sizeof udp -> uh_sport);
d287 1
a287 1
  return ip_len + sizeof *udp;
@


1.1
log
@this is where dhclient will start surgery
@
text
@d1 1
a1 1
/* packet.c
d3 1
a3 1
   Packet assembly code, originally contributed by Archie Cobbs. */
@

