head	1.146;
access;
symbols
	OPENBSD_6_2:1.146.0.4
	OPENBSD_6_2_BASE:1.146
	OPENBSD_6_1:1.117.0.4
	OPENBSD_6_1_BASE:1.117
	OPENBSD_6_0:1.106.0.4
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.102.0.4
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.100.0.2
	OPENBSD_5_7_BASE:1.100
	OPENBSD_5_6:1.90.0.4
	OPENBSD_5_6_BASE:1.90
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.81.0.2
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.6
	OPENBSD_5_0:1.49.0.4
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22;
locks; strict;
comment	@ * @;


1.146
date	2017.09.20.22.05.10;	author krw;	state Exp;
branches;
next	1.145;
commitid	UNNoETHonftDFud6;

1.145
date	2017.09.20.18.28.14;	author krw;	state Exp;
branches;
next	1.144;
commitid	lF1Bh4R6j4Dc6sIb;

1.144
date	2017.09.20.15.31.29;	author krw;	state Exp;
branches;
next	1.143;
commitid	FwKNz5tXEDB4QxU2;

1.143
date	2017.09.19.12.33.52;	author krw;	state Exp;
branches;
next	1.142;
commitid	TQlInqqeUUvUQnsZ;

1.142
date	2017.09.17.21.20.23;	author krw;	state Exp;
branches;
next	1.141;
commitid	qFZJVVBgDTJjGV1b;

1.141
date	2017.09.14.00.10.17;	author krw;	state Exp;
branches;
next	1.140;
commitid	3JGrbAkWeCalk5Am;

1.140
date	2017.08.31.17.01.48;	author krw;	state Exp;
branches;
next	1.139;
commitid	Io9PJ6ZdGzFnk3Lv;

1.139
date	2017.08.13.17.57.32;	author krw;	state Exp;
branches;
next	1.138;
commitid	oOY5ImcWRP40TSDp;

1.138
date	2017.08.12.17.36.21;	author krw;	state Exp;
branches;
next	1.137;
commitid	Rw81GK9L9X0uBBwE;

1.137
date	2017.08.09.19.57.54;	author krw;	state Exp;
branches;
next	1.136;
commitid	uK2NOPC0bxwOutY4;

1.136
date	2017.08.09.19.35.59;	author krw;	state Exp;
branches;
next	1.135;
commitid	0dwyqBLlzutwh6ER;

1.135
date	2017.07.24.17.15.41;	author krw;	state Exp;
branches;
next	1.134;
commitid	FSXpMhxAeFtIckUQ;

1.134
date	2017.07.14.16.21.03;	author krw;	state Exp;
branches;
next	1.133;
commitid	MneUE6JB4herdkKT;

1.133
date	2017.07.14.13.08.41;	author krw;	state Exp;
branches;
next	1.132;
commitid	cZhXKfv55pKDALkC;

1.132
date	2017.07.07.14.53.07;	author krw;	state Exp;
branches;
next	1.131;
commitid	9W4HKbFTwzuS5o2J;

1.131
date	2017.07.06.16.56.52;	author krw;	state Exp;
branches;
next	1.130;
commitid	gkJDzWHD0LTQO3CJ;

1.130
date	2017.07.01.23.27.56;	author krw;	state Exp;
branches;
next	1.129;
commitid	UWIW511YvInk5uK6;

1.129
date	2017.06.29.13.55.53;	author krw;	state Exp;
branches;
next	1.128;
commitid	slBDG7uu1EsDqTzi;

1.128
date	2017.06.27.13.24.49;	author krw;	state Exp;
branches;
next	1.127;
commitid	ZE4BYkFcC5NFyvgl;

1.127
date	2017.06.24.23.32.57;	author krw;	state Exp;
branches;
next	1.126;
commitid	kMjmTgmAjjj8SVH3;

1.126
date	2017.06.21.15.24.34;	author krw;	state Exp;
branches;
next	1.125;
commitid	7HePkhlUwc4gu0vl;

1.125
date	2017.06.19.19.28.35;	author krw;	state Exp;
branches;
next	1.124;
commitid	ueq2M4294OXNv6H1;

1.124
date	2017.06.18.21.08.15;	author krw;	state Exp;
branches;
next	1.123;
commitid	03NUXBjegTBXfm4K;

1.123
date	2017.06.18.17.01.46;	author krw;	state Exp;
branches;
next	1.122;
commitid	0RASdOJOvRipKjqj;

1.122
date	2017.06.14.20.27.08;	author krw;	state Exp;
branches;
next	1.121;
commitid	Do2Wb0ASjzojBK6g;

1.121
date	2017.06.14.16.52.35;	author krw;	state Exp;
branches;
next	1.120;
commitid	qdJehrUm6vQEMjRB;

1.120
date	2017.05.28.14.37.48;	author krw;	state Exp;
branches;
next	1.119;
commitid	zYEKgmhNZ9WzXnUj;

1.119
date	2017.04.05.18.22.30;	author krw;	state Exp;
branches;
next	1.118;
commitid	wE6Aq0gXfIxsFOYi;

1.118
date	2017.04.04.15.15.48;	author krw;	state Exp;
branches;
next	1.117;
commitid	hBAWRbZZAV0xgcf3;

1.117
date	2017.03.08.15.46.36;	author krw;	state Exp;
branches;
next	1.116;
commitid	dwDk77RGwF1riiUD;

1.116
date	2017.02.14.22.46.53;	author krw;	state Exp;
branches;
next	1.115;
commitid	bri6pdd6g2CmmzEv;

1.115
date	2017.02.12.15.53.15;	author krw;	state Exp;
branches;
next	1.114;
commitid	YTCiHbXKpxvNuYuw;

1.114
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.113;
commitid	WchZmaQT4LJ4im5M;

1.113
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.112;
commitid	IDlzr3qamZK5lxzj;

1.112
date	2017.01.23.04.45.59;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	hQYURPGr4b7LJN3W;

1.111
date	2016.10.06.16.29.17;	author krw;	state Exp;
branches;
next	1.110;
commitid	dTOGnqxN6bqeD6hy;

1.110
date	2016.09.29.00.40.08;	author krw;	state Exp;
branches;
next	1.109;
commitid	ye0CfDNlPiXO84bL;

1.109
date	2016.09.02.15.44.26;	author mpi;	state Exp;
branches;
next	1.108;
commitid	GuoxNV4NXpbUVBHj;

1.108
date	2016.08.31.12.57.31;	author mpi;	state Exp;
branches;
next	1.107;
commitid	dRGzj71S05fFJodM;

1.107
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.106;
commitid	Tm7CrlqCKqgQoJ7P;

1.106
date	2016.07.21.09.58.55;	author krw;	state Exp;
branches;
next	1.105;
commitid	PqPfLTbAliUfPkYk;

1.105
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.104;
commitid	5ELOU0S0Zl3aCrHG;

1.104
date	2015.12.19.01.16.33;	author krw;	state Exp;
branches;
next	1.103;
commitid	h1uSE1AeXcK9td68;

1.103
date	2015.12.03.20.54.13;	author krw;	state Exp;
branches;
next	1.102;
commitid	V7PSHhMWuLeuXYw0;

1.102
date	2015.05.18.14.59.42;	author krw;	state Exp;
branches;
next	1.101;
commitid	TDloDnGAJKxV5TnQ;

1.101
date	2015.04.16.15.14.31;	author gsoares;	state Exp;
branches;
next	1.100;
commitid	UfLCPtkHd0jUaFye;

1.100
date	2015.02.06.04.18.20;	author krw;	state Exp;
branches;
next	1.99;
commitid	PvrcCZH9No1qGtMN;

1.99
date	2014.12.10.02.34.03;	author krw;	state Exp;
branches;
next	1.98;
commitid	ctbVz96wZgUYQsW7;

1.98
date	2014.11.27.23.04.12;	author krw;	state Exp;
branches;
next	1.97;
commitid	ZQM9VieH9ikl0yoj;

1.97
date	2014.11.26.19.25.31;	author krw;	state Exp;
branches;
next	1.96;
commitid	EV4pKqOHKmDsANzr;

1.96
date	2014.11.26.17.34.36;	author krw;	state Exp;
branches;
next	1.95;
commitid	JsZvuUDorXzyF4oK;

1.95
date	2014.11.26.00.15.36;	author krw;	state Exp;
branches;
next	1.94;
commitid	m7GpbGtxrkcNfxzw;

1.94
date	2014.11.23.18.22.45;	author krw;	state Exp;
branches;
next	1.93;
commitid	A0DT3bmZICMqss1d;

1.93
date	2014.11.23.14.02.21;	author krw;	state Exp;
branches;
next	1.92;
commitid	TQpXaDPB2gC7POWf;

1.92
date	2014.11.16.12.12.01;	author krw;	state Exp;
branches;
next	1.91;
commitid	hLhY4BokXphwMPFP;

1.91
date	2014.11.13.00.33.35;	author krw;	state Exp;
branches;
next	1.90;
commitid	mCbKquB4oZKUWiBj;

1.90
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2014.02.18.01.46.58;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2014.02.09.20.45.56;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2013.12.08.22.49.02;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2013.12.05.21.32.59;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2013.12.04.19.39.50;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2013.11.16.19.34.43;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2013.11.11.21.00.01;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2013.07.06.01.12.20;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2013.07.05.22.13.10;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2013.05.10.18.59.22;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2013.04.05.19.19.05;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.22.23.58.51;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2013.02.17.17.36.31;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2013.02.17.17.04.41;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2013.02.14.22.18.12;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2013.02.13.19.32.52;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.18.06.05.54;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2012.12.29.14.40.00;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2012.12.04.19.24.03;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.24.18.06.14;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2012.11.07.15.20.28;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2012.11.07.15.07.02;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2012.11.04.23.40.59;	author stsp;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.02.14.23.49;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2012.10.30.18.39.44;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2012.10.11.08.05.05;	author sthen;	state Exp;
branches;
next	1.58;

1.58
date	2012.09.18.09.34.09;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.17.12.10.46;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2012.09.01.19.02.27;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2012.08.26.23.33.31;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2012.08.18.00.20.01;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2012.07.26.18.42.58;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.09.16.21.21;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2012.06.24.16.01.18;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2012.06.22.01.01.59;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.23.14.26.57;	author phessler;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.02.22.03.27;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.02.09.57.16;	author phessler;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.26.23.14.29;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.06.04.02.42;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.19.03.29.21;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.26.03.11.49;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.09.05.19.14;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.12.10.14.40;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.14.23.15.01;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.27.22.05.24;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.11.02.36.29;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.04.22.17.48;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.29.04.09.27;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.29.03.55.09;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.24.03.11.12;	author todd;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.21.04.07.03;	author david;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.15.18.15.18;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.22.01.10.49;	author canacar;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.05.23.07.47;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.04.21.48.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.07.16.27.08;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.02.18.49.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.02.13.39.44;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.02.12.56.30;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.02.12.46.44;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.02.12.43.09;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.02.12.40.31;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.02.12.19.14;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.24.17.26.43;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.24.15.35.56;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.24.14.49.08;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.24.11.35.39;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.23.20.09.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.23.19.19.12;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.23.18.29.33;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.23.18.21.15;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.10.13.12.48;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.07.11.40.17;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.11.35.59;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.01.18.26;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.26.19.15.50;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.146
log
@Fix some spacing. A couple of log_warx() -> log_warn() to
use standard error messages for malloc errors.
@
text
@/*	$OpenBSD: dispatch.c,v 1.145 2017/09/20 18:28:14 krw Exp $	*/

/*
 * Copyright 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.   All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <net/if.h>
#include <net/if_arp.h>
#include <net/if_media.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <arpa/inet.h>

#include <errno.h>
#include <ifaddrs.h>
#include <imsg.h>
#include <limits.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"
#include "privsep.h"


void packethandler(struct interface_info *ifi);
void flush_unpriv_ibuf(void);

/*
 * Loop waiting for packets, timeouts or routing messages.
 */
void
dispatch(struct interface_info *ifi, int routefd)
{
	struct pollfd		 fds[3];
	void			(*func)(struct interface_info *);
	time_t			 cur_time, howlong;
	int			 nfds, to_msec;

	while (quit == 0 || quit == SIGHUP) {
		if (quit == SIGHUP) {
			sendhup();
			to_msec = 100;
		} else if (ifi->timeout_func != NULL) {
			time(&cur_time);
			if (ifi->timeout <= cur_time) {
				func = ifi->timeout_func;
				cancel_timeout(ifi);
				(*(func))(ifi);
				continue;
			}
			/*
			 * Figure timeout in milliseconds, and check for
			 * potential overflow, so we can cram into an
			 * int for poll, while not polling with a
			 * negative timeout and blocking indefinitely.
			 */
			howlong = ifi->timeout - cur_time;
			if (howlong > INT_MAX / 1000)
				howlong = INT_MAX / 1000;
			to_msec = howlong * 1000;
		} else
			to_msec = -1;

		/*
		 * Set up the descriptors to be polled.
		 *
		 *  fds[0] == bpf socket for incoming packets
		 *  fds[1] == routing socket for incoming RTM messages
		 *  fds[2] == imsg socket to privileged process
		 */
		fds[0].fd = ifi->bfdesc;
		fds[1].fd = routefd;
		fds[2].fd = unpriv_ibuf->fd;
		fds[0].events = fds[1].events = fds[2].events = POLLIN;

		if (unpriv_ibuf->w.queued)
			fds[2].events |= POLLOUT;

		nfds = poll(fds, 3, to_msec);
		if (nfds == -1) {
			if (errno == EINTR)
				continue;
			log_warn("%s: poll(bfdesc, routefd, unpriv_ibuf)",
			    log_procname);
			quit = INTERNALSIG;
			continue;
		}

		if ((fds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {
			log_warnx("%s: bfdesc: ERR|HUP|NVAL", log_procname);
			quit = INTERNALSIG;
			continue;
		}
		if ((fds[1].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {
			log_warnx("%s: routefd: ERR|HUP|NVAL", log_procname);
			quit = INTERNALSIG;
			continue;
		}
		if ((fds[2].revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {
			log_warnx("%s: unpriv_ibuf: ERR|HUP|NVAL", log_procname);
			quit = INTERNALSIG;
			continue;
		}

		if (nfds == 0)
			continue;

		if ((fds[0].revents & POLLIN) != 0) {
			do {
				packethandler(ifi);
			} while (ifi->rbuf_offset < ifi->rbuf_len);
		}
		if ((fds[1].revents & POLLIN) != 0)
			routehandler(ifi, routefd);
		if ((fds[2].revents & POLLOUT) != 0)
			flush_unpriv_ibuf();
		if ((fds[2].revents & POLLIN) != 0)
			quit = INTERNALSIG;
	}

	if (quit != INTERNALSIG && quit != SIGHUP)
		fatalx("%s", strsignal(quit));
}

void
packethandler(struct interface_info *ifi)
{
	struct sockaddr_in	 from;
	struct ether_addr	 hfrom;
	struct in_addr		 ifrom;
	struct dhcp_packet	*packet = &ifi->recv_packet;
	struct reject_elem	*ap;
	struct option_data	*options;
	char			*type, *info;
	ssize_t			 result;
	void			(*handler)(struct interface_info *,
	    struct option_data *, char *);
	int			 i, rslt;

	result = receive_packet(ifi, &from, &hfrom);
	if (result == -1) {
		ifi->errors++;
		if (ifi->errors > 20)
			fatalx("too many receive_packet failures");
		return;
	}
	ifi->errors = 0;

	if (result == 0)
		return;

	ifrom.s_addr = from.sin_addr.s_addr;

	if (packet->hlen != ETHER_ADDR_LEN) {
#ifdef DEBUG
		log_debug("%s: discarding packet with hlen == %u", log_procname,
		    packet->hlen);
#endif	/* DEBUG */
		return;
	} else if (memcmp(&ifi->hw_address, packet->chaddr,
	    sizeof(ifi->hw_address))) {
#ifdef DEBUG
		log_debug("%s: discarding packet with chaddr == %s",
		    log_procname,
		    ether_ntoa((struct ether_addr *)packet->chaddr));
#endif	/* DEBUG */
		return;
	}

	if (ifi->xid != packet->xid) {
#ifdef DEBUG
		log_debug("%s: discarding packet with XID != %u (%u)",
		    log_procname, ifi->xid, packet->xid);
#endif	/* DEBUG */
		return;
	}

	TAILQ_FOREACH(ap, &config->reject_list, next)
	    if (ifrom.s_addr == ap->addr.s_addr) {
#ifdef DEBUG
		    log_debug("%s: discarding packet from address on reject "
			"list (%s)", log_procname, inet_ntoa(ifrom));
#endif	/* DEBUG */
		    return;
	    }

	options = unpack_options(&ifi->recv_packet);

	/*
	 * RFC 6842 says if the server sends a client identifier
	 * that doesn't match then the packet must be dropped.
	 */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if ((options[i].len != 0) &&
	    ((options[i].len != config->send_options[i].len) ||
	    memcmp(options[i].data, config->send_options[i].data,
	    options[i].len) != 0)) {
#ifdef DEBUG
		log_debug("%s: discarding packet with client-identifier %s'",
		    log_procname, pretty_print_option(i, &options[i], 0));
#endif	/* DEBUG */
		return;
	}

	type = "<unknown>";
	handler = NULL;

	i = DHO_DHCP_MESSAGE_TYPE;
	if (options[i].data != NULL) {
		/* Always try a DHCP packet, even if a bad option was seen. */
		switch (options[i].data[0]) {
		case DHCPOFFER:
			handler = dhcpoffer;
			type = "DHCPOFFER";
			break;
		case DHCPNAK:
			handler = dhcpnak;
			type = "DHCPNACK";
			break;
		case DHCPACK:
			handler = dhcpack;
			type = "DHCPACK";
			break;
		default:
#ifdef DEBUG
			log_debug("%s: discarding DHCP packet of unknown type "
			    "(%d)", log_procname, options[i].data[0]);
#endif	/* DEBUG */
			return;
		}
	} else if (packet->op == BOOTREPLY) {
		handler = dhcpoffer;
		type = "BOOTREPLY";
	} else {
#ifdef DEBUG
		log_debug("%s: discarding packet which is neither DHCP nor "
		    "BOOTP", log_procname);
#endif	/* DEBUG */
		return;
	}

	rslt = asprintf(&info, "%s from %s (%s)", type, inet_ntoa(ifrom),
	    ether_ntoa(&hfrom));
	if (rslt == -1)
		fatal("info string");

	if (handler != NULL)
		(*handler)(ifi, options, info);

	free(info);
}

/*
 * flush_unpriv_ibuf stuffs queued messages into the imsg socket.
 */
void
flush_unpriv_ibuf(void)
{
	while (unpriv_ibuf->w.queued) {
		if (msgbuf_write(&unpriv_ibuf->w) <= 0) {
			if (errno == EAGAIN)
				break;
			if (quit == 0)
				quit = INTERNALSIG;
			if (errno != EPIPE && errno != 0)
				log_warn("%s: msgbuf_write(unpriv_ibuf)",
				    log_procname);
			break;
		}
	}
}

void
set_timeout(struct interface_info *ifi, time_t secs,
    void (*where)(struct interface_info *))
{
	time(&ifi->timeout);
	ifi->timeout += secs;
	ifi->timeout_func = where;
}

void
cancel_timeout(struct interface_info *ifi)
{
	ifi->timeout = 0;
	ifi->timeout_func = NULL;
}

/*
 * Inform the [priv] process a HUP was received.
 */
void
sendhup(void)
{
	int rslt;

	rslt = imsg_compose(unpriv_ibuf, IMSG_HUP, 0, 0, -1, NULL, 0);
	if (rslt == -1)
		log_warn("%s: imsg_compose(IMSG_HUP)", log_procname);
}
@


1.145
log
@Make log messages more informative by using the
name of the function that failed and the significant
parameters. Distinguish between poll() errors and
problematic revents values.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.144 2017/09/20 15:31:29 krw Exp $	*/
d109 2
a110 2
					howlong = INT_MAX / 1000;
				to_msec = howlong * 1000;
@


1.144
log
@Remove stray %s/ifi->name from fatalx().
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.143 2017/09/19 12:33:52 krw Exp $	*/
d133 2
a134 1
			log_warn("%s: dispatch poll", log_procname);
d140 1
a140 1
			log_warnx("%s: bfdesc poll error", log_procname);
d145 1
a145 1
			log_warnx("%s: routefd poll error", log_procname);
d150 1
a150 1
			log_warnx("%s: unpriv_ibuf poll error", log_procname);
d190 2
a191 1
	if ((result = receive_packet(ifi, &from, &hfrom)) == -1) {
a194 2
		else
			log_warn("%s receive_packet failed", log_procname);
d349 1
a349 1
		log_warn("%s: sendhup: imsg_compose", log_procname);
@


1.143
log
@flush_unpriv_ibuf() is now used only once so no
need to complicate things by passing it a string
identifying where it was called. Tweak log
verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.142 2017/09/17 21:20:23 krw Exp $	*/
d192 1
a192 2
			fatalx("%s too many receive_packet failures",
			    ifi->name);
@


1.142
log
@Create global 'log_procname' and set it to '<ifname>' or
'<ifname> [priv]' as appropriate for the process doing the
setting. Use it as the prefix in all log_*() output. Makes
tracking messages for an interface or a process much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.141 2017/09/14 00:10:17 krw Exp $	*/
d76 1
a76 1
void flush_unpriv_ibuf(const char *);
d165 1
a165 1
			flush_unpriv_ibuf("dispatch");
d308 1
a308 1
flush_unpriv_ibuf(const char *who)
d317 2
a318 2
				log_warn("%s: %s: msgbuf_write", log_procname,
				    who);
@


1.141
log
@Strive to rationalize fatal[x]() usage and
verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.140 2017/08/31 17:01:48 krw Exp $	*/
d133 1
a133 1
			log_warn("dispatch poll");
d139 1
a139 1
			log_warnx("bfdesc poll error");
d144 1
a144 1
			log_warnx("routefd poll error");
d149 1
a149 1
			log_warnx("unpriv_ibuf poll error");
d195 1
a195 1
			log_warn("%s receive_packet failed", ifi->name);
d207 2
a208 2
		log_debug("Discarding packet with hlen != %s (%u)",
		    ifi->name, packet->hlen);
d214 2
a215 2
		log_debug("Discarding packet with chaddr != %s (%s)",
		    ifi->name,
d223 2
a224 2
		log_debug("Discarding packet with XID != %u (%u)", ifi->xid,
		    packet->xid);
d232 2
a233 2
		    log_debug("Discarding packet from address on reject "
			"list (%s)", inet_ntoa(ifrom));
d250 2
a251 2
		log_debug("Discarding packet with client-identifier "
		    "'%s'", pretty_print_option(i, &options[i], 0));
d277 2
a278 2
			log_debug("Discarding DHCP packet of unknown type "
			    "(%d)", options[i].data[0]);
d287 2
a288 1
		log_debug("Discarding packet which is neither DHCP nor BOOTP");
d317 2
a318 1
				log_warn("%s: msgbuf_write", who);
d350 1
a350 1
		log_warn("sendhup: imsg_compose");
@


1.140
log
@Don't delete v4 routes that are going to be
added back.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.139 2017/08/13 17:57:32 krw Exp $	*/
d295 1
a295 1
		fatalx("no memory for info string");
@


1.139
log
@Simplify HUP handling now that proper error
checks are done on the imsg socket to detect
closure, etc.

Die immediately if the priv process notices
the interface name can't be turned into an
index.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.138 2017/08/12 17:36:21 krw Exp $	*/
d50 1
@


1.138
log
@sig_atomic_t is not (necessarily) an int. Use
SIG_ATOMIC_MAX for INTERNALSIG instead of
INT_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.137 2017/08/09 19:57:54 krw Exp $	*/
a89 1
			log_warnx("%s; restarting", strsignal(quit));
d91 2
a92 3
		}

		if (ifi->timeout_func != NULL) {
d108 2
a109 2
				howlong = INT_MAX / 1000;
			to_msec = howlong * 1000;
d169 1
a169 1
	if (quit != INTERNALSIG)
@


1.137
log
@Stop obsessively flushing the imsg connection. Just
flush any queued messages on getting a POLLOUT.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.136 2017/08/09 19:35:59 krw Exp $	*/
d63 1
@


1.136
log
@Add some additional poll() error checking. Remove checks
for EAGAIN as that is not a possible poll() errno.

suggestions & ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.135 2017/07/24 17:15:41 krw Exp $	*/
d74 1
d303 19
a348 2

	flush_unpriv_ibuf("sendhup");
@


1.135
log
@Shuffle some declarations and functions into the only
files they are used in. Tweak a bunch of whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.134 2017/07/14 16:21:03 krw Exp $	*/
d84 1
a84 1
	int			 count, to_msec;
d128 3
a130 3
		count = poll(fds, 3, to_msec);
		if (count == -1) {
			if (errno == EAGAIN || errno == EINTR) {
d132 19
a150 5
			} else {
				log_warn("poll");
				quit = INTERNALSIG;
				continue;
			}
d153 4
a156 1
		if ((fds[0].revents & (POLLIN | POLLHUP)) != 0) {
d161 1
a161 1
		if ((fds[1].revents & (POLLIN | POLLHUP)) != 0)
d165 1
a165 2
		if ((fds[2].revents & (POLLIN | POLLHUP)) != 0) {
			/* Pipe to [priv] closed. Assume it emitted error. */
a166 1
		}
@


1.134
log
@Replace remaining "!var" expressions with
"<var> == 0", "!(<var> & FLAG)" with
"(<var> & FLAG) == 0", "!<func()>"
with "<func()> == 0" and "!<define>" with
"<define> == 0". And the positive cases
as well.

A few stray == NULL and != NULL as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.133 2017/07/14 13:08:41 krw Exp $	*/
a48 1
#include <net/if_dl.h>
a49 1
#include <net/if_types.h>
a74 43
void
get_hw_address(struct interface_info *ifi)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_dl *sdl;
	struct if_data *ifdata;
	int found;

	if (getifaddrs(&ifap) != 0)
		fatalx("getifaddrs failed");

	found = 0;
	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT))
			continue;

		if (strcmp(ifi->name, ifa->ifa_name) != 0)
			continue;
		found = 1;

		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != ETHER_ADDR_LEN)
			continue;

		ifdata = ifa->ifa_data;
		ifi->rdomain = ifdata->ifi_rdomain;

		memcpy(ifi->hw_address.ether_addr_octet, LLADDR(sdl),
		    ETHER_ADDR_LEN);
		ifi->flags |= IFI_VALID_LLADDR;
	}

	if (found == 0)
		fatalx("%s: no such interface", ifi->name);

	freeifaddrs(ifap);
}

a284 54
}

void
interface_link_forceup(char *name, int ioctlfd)
{
	struct ifreq ifr;

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(ioctlfd, SIOCGIFFLAGS, (caddr_t)&ifr) == -1) {
		log_warn("SIOCGIFFLAGS");
		return;
	}

	/* Force it up if it isn't already. */
	if ((ifr.ifr_flags & IFF_UP) == 0) {
		ifr.ifr_flags |= IFF_UP;
		if (ioctl(ioctlfd, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
			log_warn("SIOCSIFFLAGS");
			return;
		}
	}
}

int
interface_status(char *name)
{
	struct ifaddrs *ifap, *ifa;
	struct if_data *ifdata;

	if (getifaddrs(&ifap) != 0)
		fatalx("getifaddrs failed");

	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT))
			continue;

		if (strcmp(name, ifa->ifa_name) != 0)
			continue;

		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		if ((ifa->ifa_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			return 0;

		ifdata = ifa->ifa_data;

		return LINK_STATE_IS_UP(ifdata->ifi_link_state);
	}

	return 0;
@


1.133
log
@bpf(4) *may* deliver more than one captured packet at a time. So when
the bpf socket signals that it has data, call packethandler() in a
loop until no more bpf packets are available.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.132 2017/07/07 14:53:07 krw Exp $	*/
d114 1
a114 1
	if (!found)
d137 1
a137 1
		if (ifi->timeout_func) {
d184 1
a184 1
		if ((fds[0].revents & (POLLIN | POLLHUP))) {
d189 1
a189 1
		if ((fds[1].revents & (POLLIN | POLLHUP)))
d191 1
a191 1
		if (fds[2].revents & POLLOUT)
d193 1
a193 1
		if ((fds[2].revents & (POLLIN | POLLHUP))) {
d326 1
a326 1
	if (handler)
@


1.132
log
@Rename cons_options() to pack_options(), and do_packet() to
unpack_options(). Store the unpacked options in a static
variable. Move remaining raw packet processing from unpack_options()
to packethandler().

No more struct interface_info knowledge in options.c
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.131 2017/07/06 16:56:52 krw Exp $	*/
d184 5
a188 2
		if ((fds[0].revents & (POLLIN | POLLHUP)))
			packethandler(ifi);
@


1.131
log
@cons_options() only needs to know a buffer and a length to
pack options into. Not all the gory details of interface_info.

Move some of the raw packet processing out of options.c's
do_packet() and into the more obvious dispatch.c's
packethandler().

Mention that RFC791 is why we use 576-byte UDP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.130 2017/07/01 23:27:56 krw Exp $	*/
d208 2
d211 3
d264 63
a326 1
	do_packet(ifi, from.sin_port, ifrom, &hfrom);
@


1.130
log
@Eliminate multiple socket openings/closings and pass
fd'd from main loops as required. One socket to do
ioctl's per process (called ioctlfd) and one socket to
do route messages per socket (called routefd).

Clean up local variable declaration lists in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.129 2017/06/29 13:55:53 krw Exp $	*/
d56 2
d203 6
a208 4
	struct sockaddr_in from;
	struct ether_addr hfrom;
	struct in_addr ifrom;
	ssize_t result;
d225 33
@


1.129
log
@delete_addresses(), interface_status(), addressinuse(),
lease_as_string() and rewrite_option_db() only use the
interface name, so supply just the name.

Tweak interface_link_forceup() to use the same param
name as other functions taking the interface name.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.128 2017/06/27 13:24:49 krw Exp $	*/
d122 1
a122 1
dispatch(struct interface_info *ifi)
d124 4
a127 4
	int count, to_msec;
	struct pollfd fds[3];
	time_t cur_time, howlong;
	void (*func)(struct interface_info *);
d185 1
a185 1
			routehandler(ifi);
d226 1
a226 1
interface_link_forceup(char *name)
a228 1
	extern int sock;
d232 1
a232 1
	if (ioctl(sock, SIOCGIFFLAGS, (caddr_t)&ifr) == -1) {
d240 1
a240 1
		if (ioctl(sock, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
@


1.128
log
@Nuke get_rdomain() and just snag the interface rdomain from the same
ifa we use to get the interface hw address. One less socket() and
ioctl()! MIssed cleanup from shift to just watching RTM_IFINFO
messages for rdomain switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.127 2017/06/24 23:32:57 krw Exp $	*/
d226 1
a226 1
interface_link_forceup(char *ifname)
d232 1
a232 1
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
d249 1
a249 1
interface_status(struct interface_info *ifi)
d262 1
a262 1
		if (strcmp(ifi->name, ifa->ifa_name) != 0)
@


1.127
log
@Tweak handling of HUP and new LLADDR. Just use expose and use sighup()
function. Don't exit dispatch() loop on SIGHUP, wait for privileged
child to execvp() dhclient. Eliminate struct imsg_hup since its
contents were not being used except in priv_cleanup(). And
'active_addr' works just as well there.

Cleaner and eliminates some extraneous log entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.126 2017/06/21 15:24:34 krw Exp $	*/
d80 1
d104 3
a293 18
}

int
get_rdomain(char *name)
{
	int rv = 0, s;
	struct ifreq ifr;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("get_rdomain socket");

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFRDOMAIN, (caddr_t)&ifr) != -1)
		rv = ifr.ifr_rdomainid;

	close(s);
	return rv;
@


1.126
log
@Consistently use time(&var) idiom rather than tossing in a few
var = time(NULL). Flip "struct interface *" to be the first
parameter in set_timeout(), as in other functions taking the
state info.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.125 2017/06/19 19:28:35 krw Exp $	*/
a73 1
void sendhup(struct client_lease *);
d125 6
a130 1
	while (quit == 0) {
d190 1
a190 6
	if (quit == SIGHUP) {
		/* Tell [priv] process that HUP has occurred. */
		sendhup(ifi->active);
		log_warnx("%s; restarting", strsignal(quit));
		exit (0);
	} else if (quit != INTERNALSIG) {
a191 1
	}
d311 1
a311 1
 * Inform the [priv] process a HUP was received and it should restart.
d314 1
a314 1
sendhup(struct client_lease *active)
a315 1
	struct imsg_hup imsg;
d318 1
a318 7
	if (active)
		imsg.addr = active->address;
	else
		imsg.addr.s_addr = INADDR_ANY;

	rslt = imsg_compose(unpriv_ibuf, IMSG_HUP, 0, 0, -1,
	    &imsg, sizeof(imsg));
@


1.125
log
@Various KNF nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.124 2017/06/18 21:08:15 krw Exp $	*/
d279 2
a280 2
set_timeout(time_t secs, void (*where)(struct interface_info *),
    struct interface_info *ifi)
d282 2
a283 1
	ifi->timeout = time(NULL) + secs;
@


1.124
log
@Move the timeout information into struct interface_info with
the rest of the dhcp state. One less struct (dhcp_timeout) to
worry about, one less field (ifi) to keep track of.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.123 2017/06/18 17:01:46 krw Exp $	*/
d300 1
a300 1
	    fatal("get_rdomain socket");
d305 1
a305 1
	    rv = ifr.ifr_rdomainid;
@


1.123
log
@Convert last set_timeout() use to set_timeout_interval() and
then remove set_timeout() and rename set_timeout_interval() to
set_timeout().
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.122 2017/06/14 20:27:08 krw Exp $	*/
a72 2
struct dhcp_timeout timeout;

a124 1
	struct interface_info *arg;
d127 1
a127 1
		if (timeout.func) {
d129 4
a132 5
			if (timeout.when <= cur_time) {
				func = timeout.func;
				arg = timeout.ifi;
				cancel_timeout();
				(*(func))(arg);
d141 1
a141 1
			howlong = timeout.when - cur_time;
d282 2
a283 3
	timeout.when = time(NULL) + secs;
	timeout.func = where;
	timeout.ifi = ifi;
d287 1
a287 1
cancel_timeout(void)
d289 2
a290 3
	timeout.when = 0;
	timeout.func = NULL;
	timeout.ifi = NULL;
@


1.122
log
@No need to be coy - call a "struct interface_info *" a
"struct interface_info *" and not a "void *".

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.121 2017/06/14 16:52:35 krw Exp $	*/
d283 1
a283 10
set_timeout(time_t when, void (*where)(struct interface_info *),
    struct interface_info *ifi)
{
	timeout.when = when;
	timeout.func = where;
	timeout.ifi = ifi;
}

void
set_timeout_interval(time_t secs, void (*where)(struct interface_info *),
@


1.121
log
@Move active, new, offered_leases, leases from
client_state to interface_info.

Nuke empty struct client_state.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.120 2017/05/28 14:37:48 krw Exp $	*/
d126 2
a127 2
	void (*func)(void *);
	void *arg;
d134 1
a134 1
				arg = timeout.arg;
d158 1
a158 1
		*/
d283 2
a284 1
set_timeout(time_t when, void (*where)(void *), void *arg)
d288 1
a288 1
	timeout.arg = arg;
d292 2
a293 1
set_timeout_interval(time_t secs, void (*where)(void *), void *arg)
d297 1
a297 1
	timeout.arg = arg;
d305 1
a305 1
	timeout.arg = NULL;
@


1.120
log
@Elegant and reliable link status checking courtesy of mpi@@.

Less of unreliable ioctl(SIOCGIFMEDIA), more getifaddrs().

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.119 2017/04/05 18:22:30 krw Exp $	*/
a122 1
	struct client_state *client = ifi->client;
d192 1
a192 1
		sendhup(client->active);
@


1.119
log
@Shuffle sendhup() into dispatch.c, the only place it is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.118 2017/04/04 15:15:48 krw Exp $	*/
d254 13
a266 3
	struct ifreq ifr;
	struct ifmediareq ifmr;
	extern int sock;
d268 2
a269 6
	/* Get interface flags. */
	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, ifi->name, sizeof(ifr.ifr_name));
	if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {
		fatal("ioctl(SIOCGIFFLAGS) on %s", ifi->name);
	}
d271 3
a273 2
	if ((ifr.ifr_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		goto inactive;
d275 1
a275 14
	/* Next, check carrier on the interface if possible. */
	if (ifi->flags & IFI_NOMEDIA)
		goto active;
	memset(&ifmr, 0, sizeof(ifmr));
	strlcpy(ifmr.ifm_name, ifi->name, sizeof(ifmr.ifm_name));
	if (ioctl(sock, SIOCGIFMEDIA, (caddr_t)&ifmr) == -1) {
		/*
		 * EINVAL or ENOTTY simply means that the interface does not
		 * support the SIOCGIFMEDIA ioctl. We regard it alive.
		 */
#ifdef DEBUG
		if (errno != EINVAL && errno != ENOTTY)
			log_debug("ioctl(SIOCGIFMEDIA) on %s", ifi->name);
#endif	/* DEBUG */
d277 1
a277 2
		ifi->flags |= IFI_NOMEDIA;
		goto active;
a278 8
	if (ifmr.ifm_status & IFM_AVALID) {
		if (ifmr.ifm_status & IFM_ACTIVE)
			goto active;
		else
			goto inactive;
	}

	/* Assume 'active' if IFM_AVALID is not set. */
d280 1
a280 4
active:
	return (1);
inactive:
	return (0);
@


1.118
log
@Send a RTM_PROPOSAL to clear out other dhclient instances on startup.

Replaces forcing interface link state down and up to generate
RTM_IFINFO messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.117 2017/03/08 15:46:36 krw Exp $	*/
d76 1
d341 22
@


1.117
log
@Stray #endif w/o comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.116 2017/02/14 22:46:53 krw Exp $	*/
d236 1
a236 1
		log_warn("interface_link_forceup: SIOCGIFFLAGS failed");
d240 7
a246 11
	/* Force it down and up so others notice link state change. */
	ifr.ifr_flags &= ~IFF_UP;
	if (ioctl(sock, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
		log_warn("interface_link_forceup: SIOCSIFFLAGS DOWN failed");
		return;
	}

	ifr.ifr_flags |= IFF_UP;
	if (ioctl(sock, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
		log_warn("interface_link_forceup: SIOCSIFFLAGS UP failed");
		return;
@


1.116
log
@fatalx() prepends 'fatal in _progname:'. So eliminate redundant
'; exiting' suffix used by old style logging.

Eliminate an extra log message before fatal()'ing out with a summary
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.115 2017/02/12 15:53:15 krw Exp $	*/
d284 1
a284 1
#endif
@


1.115
log
@Eliminate most strerror() invocations by using log_warn() and fatal()
instead of log_warnx() and fatalx(). A few log_info() to log_warn()
for the same reason.

Suggested by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.114 2017/02/12 13:55:01 krw Exp $	*/
d196 1
a196 2
		log_warnx("%s; exiting", strsignal(quit));
		exit(1);
a208 1
		log_warn("%s receive_packet failed", ifi->name);
d210 2
a211 2
		if (ifi->errors > 20) {
			fatalx("%s too many receive_packet failures; exiting",
d213 2
a214 1
		}
@


1.114
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.113 2017/02/12 13:15:50 krw Exp $	*/
d172 1
a172 1
				log_warnx("poll: %s", strerror(errno));
d210 1
a210 2
		log_warnx("%s receive_packet failed: %s", ifi->name,
		    strerror(errno));
d237 1
a237 2
		log_info("interface_link_forceup: SIOCGIFFLAGS failed (%s)",
		    strerror(errno));
d244 1
a244 2
		log_info("interface_link_forceup: SIOCSIFFLAGS DOWN "
		    "failed (%s)", strerror(errno));
d250 1
a250 2
		log_info("interface_link_forceup: SIOCSIFFLAGS UP failed (%s)",
		    strerror(errno));
d266 1
a266 2
		fatalx("ioctl(SIOCGIFFLAGS) on %s: %s", ifi->name,
		    strerror(errno));
d284 1
a284 2
			log_debug("ioctl(SIOCGIFMEDIA) on %s: %s", ifi->name,
			    strerror(errno));
d336 1
a336 1
	    fatalx("get_rdomain socket: %s", strerror(errno));
@


1.113
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.112 2017/01/23 04:45:59 deraadt Exp $	*/
d246 2
a247 2
		log_info("interface_link_forceup: SIOCSIFFLAGS DOWN failed (%s)",
		    strerror(errno));
@


1.112
log
@Keep socket open from startup, and reuse for SIOCGIFFLAGS later on,
rather than opening a fresh socket on the fly.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.111 2016/10/06 16:29:17 krw Exp $	*/
d69 1
d85 1
a85 1
		error("getifaddrs failed");
d111 1
a111 1
		error("%s: no such interface", ifi->name);
d172 1
a172 1
				warning("poll: %s", strerror(errno));
d193 1
a193 1
		warning("%s; restarting", strsignal(quit));
d196 1
a196 1
		warning("%s; exiting", strsignal(quit));
d210 1
a210 1
		warning("%s receive_packet failed: %s", ifi->name,
d214 1
a214 1
			error("%s too many receive_packet failures; exiting",
d238 1
a238 1
		note("interface_link_forceup: SIOCGIFFLAGS failed (%s)",
d246 1
a246 1
		note("interface_link_forceup: SIOCSIFFLAGS DOWN failed (%s)",
d253 1
a253 1
		note("interface_link_forceup: SIOCSIFFLAGS UP failed (%s)",
d270 1
a270 1
		error("ioctl(SIOCGIFFLAGS) on %s: %s", ifi->name,
d289 1
a289 1
			debug("ioctl(SIOCGIFMEDIA) on %s: %s", ifi->name,
d342 1
a342 1
	    error("get_rdomain socket: %s", strerror(errno));
@


1.111
log
@Add support for RFC 6842, which says the client MUST drop packets when
the server provides a client-identifier value and it doesn't match
the value the client sent.

So stop suppressing client-identifer info in the leases file and when
reading the leases file stop discarding leases that don't have current
client-identifier info. Don't use them, but keep them around in case
the client-identifier info changes back next time.

Also construct the default client-identifier (if needed) before reading
the leases file.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.110 2016/09/29 00:40:08 krw Exp $	*/
d232 1
a232 4
	int sock;

	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		error("Can't create socket");
a238 1
		close(sock);
a246 1
		close(sock);
a253 1
		close(sock);
a255 2

	close(sock);
d263 1
a263 4
	int sock;

	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		error("Can't create socket");
a304 1
	close(sock);
a306 1
	close(sock);
@


1.110
log
@'ifname' --> 'ifi->name' so DEBUG compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.109 2016/09/02 15:44:26 mpi Exp $	*/
d89 1
a89 2
		    (ifa->ifa_flags & IFF_POINTOPOINT) ||
		    (!(ifa->ifa_flags & IFF_UP)))
@


1.109
log
@Kill 'ifi' global.

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.108 2016/08/31 12:57:31 mpi Exp $	*/
d300 1
a300 1
			debug("ioctl(SIOCGIFMEDIA) on %s: %s", ifname,
@


1.108
log
@Remove the 'client' global and make it per-ifp.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.107 2016/08/23 09:26:02 mpi Exp $	*/
d126 2
a127 1
	void (*func)(void);
d134 1
d136 1
a136 1
				(*(func))();
d181 1
a181 1
			routehandler();
d325 1
a325 1
set_timeout(time_t when, void (*where)(void))
d329 1
d333 1
a333 1
set_timeout_interval(time_t secs, void (*where)(void))
d337 1
d345 1
@


1.107
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.106 2016/07/21 09:58:55 krw Exp $	*/
d122 1
@


1.106
log
@Use explicit idiom when testing the result of strcmp() and strncmp().
i.e. == 0 and != 0 as appropriate. No intentional functional change.

Suggested by & ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.105 2016/02/06 19:30:52 krw Exp $	*/
d74 1
a74 1
void packethandler(void);
d77 1
a77 1
get_hw_address(void)
d120 1
a120 1
dispatch(void)
d176 1
a176 1
			packethandler();
d199 1
a199 1
packethandler(void)
d206 1
a206 1
	if ((result = receive_packet(&from, &hfrom)) == -1) {
d223 1
a223 1
	do_packet(from.sin_port, ifrom, &hfrom);
d265 1
a265 1
interface_status(char *ifname)
d276 1
a276 1
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
d278 1
a278 1
		error("ioctl(SIOCGIFFLAGS) on %s: %s", ifname,
d289 1
a289 1
	strlcpy(ifmr.ifm_name, ifname, sizeof(ifmr.ifm_name));
@


1.105
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.104 2015/12/19 01:16:33 krw Exp $	*/
d93 1
a93 1
		if (strcmp(ifi->name, ifa->ifa_name))
@


1.104
log
@Delete superfluous "continue;" just before end of loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.103 2015/12/03 20:54:13 krw Exp $	*/
a41 3
#include "dhcpd.h"
#include "privsep.h"

d43 3
d47 3
d52 5
d58 2
d61 10
@


1.103
log
@No need to continuously check the current rdomain of the interface
using the SIOCGIFRDOMAIN ioctl. If the rdomain is changed an
RTM_IFINFO message is generated on the old rdomain indicating the
interface is down. This will cause dhclient to exit, just like our
manual check did but even faster!

Should make pledging easier.

Behaviour confirmed by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.102 2015/05/18 14:59:42 krw Exp $	*/
a163 1
			continue;
@


1.102
log
@Stop rejecting leases with a subnet that overlaps a subnet already
present. The latest routing stack code can now handle these situations.

Much requested by beck@@ and others. Detailed discussion at s2k15
identified required routing changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.101 2015/04/16 15:14:31 gsoares Exp $	*/
a107 6
		if (ifi->rdomain != get_rdomain(ifi->name)) {
			warning("%s rdomain changed; exiting", ifi->name);
			quit = INTERNALSIG;
			continue;
		}

@


1.101
log
@Tweak error output.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.100 2015/02/06 04:18:20 krw Exp $	*/
a344 67
}

int
subnet_exists(struct client_lease *l)
{
	struct option_data *opt;
	struct ifaddrs *ifap, *ifa;
	struct in_addr mymask, myaddr, mynet, hismask, hisaddr, hisnet;
	int myrdomain, hisrdomain;

	opt = &l->options[DHO_SUBNET_MASK];
	if (opt->len == sizeof(mymask))
		mymask.s_addr = ((struct in_addr *)opt->data)->s_addr;
	else
		mymask.s_addr = INADDR_ANY;
	myaddr.s_addr = l->address.s_addr;
	mynet.s_addr = mymask.s_addr & myaddr.s_addr;

	myrdomain = get_rdomain(ifi->name);

	if (getifaddrs(&ifap) != 0)
		error("getifaddrs failed");

	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if (strcmp(ifi->name, ifa->ifa_name) == 0)
			continue;

		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;

		hisrdomain = get_rdomain(ifa->ifa_name);
		if (hisrdomain != myrdomain)
			continue;

		memcpy(&hismask,
		    &((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr,
		    sizeof(hismask));
		memcpy(&hisaddr,
		    &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr,
		    sizeof(hisaddr));
		hisnet.s_addr = hisaddr.s_addr & hismask.s_addr;

		if (hisnet.s_addr == INADDR_ANY)
			continue;

		/* Would his packets go out *my* interface? */
		if (mynet.s_addr == (hisaddr.s_addr & mymask.s_addr)) {
			note("interface %s already has the offered subnet!",
			    ifa->ifa_name);
			break;
		}

		/* Would my packets go out *his* interface? */
		if (hisnet.s_addr == (myaddr.s_addr & hismask.s_addr)) {
			note("interface %s already has the offered subnet!",
			    ifa->ifa_name);
			break;
		}
	}

	freeifaddrs(ifap);

	/* If ifa == NULL we scanned the list without finding a problem. */
	if (ifa == NULL)
		return (0);
	else
		return (1);
@


1.100
log
@Don't let errors leak the memory returned by getifaddrs().
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.99 2014/12/10 02:34:03 krw Exp $	*/
d91 1
a91 1
		error("%s: not found", ifi->name);
@


1.99
log
@Reusing the same field for different things in different contexts may
be clever, but it is definitely confusing. Use a flag IFI_VALID_LLADDR
to indicate that the ifi->hw_address field is valid, rather than
assuming ifi->linkstat does that. Add startup_time to record client
startup rather than using first_sending and hoping nobody else needs
it until link is complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.98 2014/11/27 23:04:12 krw Exp $	*/
d394 1
a394 1
			return (1);
d401 1
a401 1
			return (1);
d407 5
a411 1
	return (0);
@


1.98
log
@Use if_nametoindex() to get the interface index, and thereby check
the validity of the interface name as soon the actual name is known.
i.e. right after 'egress' is expanded. One less thing for
get_hw_address() to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.97 2014/11/26 19:25:31 krw Exp $	*/
d87 1
@


1.97
log
@Reset ifi->errors after a successful receive_packet(), rather than
incrementing sporadic errors until the limit is exceeded. i.e. only
exit dhclient when enough consecutive errors occur. Tweak error
messages.

Don't bother checking interface_status() when receive_packet()
fails. Let other status checks function on their own.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.96 2014/11/26 17:34:36 krw Exp $	*/
a84 1
		ifi->index = sdl->sdl_index;
@


1.96
log
@'ifi' is successfully calloc'd during initialization or dhclient
exits, so there is no need to constantly check if 'ifi' is NULL.
Similarly 'ifi->bfdesc' is successfully opened during initialization
or dhclient exits, so there is no point in constantly checking if
it has regressed to -1. Finally, no need to check 'ifi->linkstat'
before trying to read a packet. If there is a packet it should just
as well be read immediately rather than waiting for the link to
reappear and confuse things.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.95 2014/11/26 00:15:36 krw Exp $	*/
d194 1
a194 1
		warning("receive_packet failed on %s: %s", ifi->name,
d197 2
a198 4
		if ((!interface_status(ifi->name)) ||
		    ((ifi->flags & IFI_NOMEDIA) && ifi->errors > 20)) {
			/* our interface has gone away. */
			error("Interface %s no longer appears valid.",
d203 2
@


1.95
log
@Rename 'got_one()' to 'packethandler()'.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.94 2014/11/23 18:22:45 krw Exp $	*/
a107 5
		if (!ifi) {
			warning("No interface!");
			quit = INTERNALSIG;
			continue;
		}
a112 5
		if (ifi->bfdesc == -1) {
			warning("%s bpf socket gone; exiting", ifi->name);
			quit = INTERNALSIG;
			continue;
		}
d161 5
a165 9
		if ((fds[0].revents & (POLLIN | POLLHUP))) {
			if (ifi && ifi->linkstat && ifi->bfdesc != -1)
				packethandler();
		}
		if ((fds[1].revents & (POLLIN | POLLHUP))) {
			if (ifi)
				routehandler();
		}
		if (fds[2].revents & POLLOUT) {
a166 1
		}
@


1.94
log
@Rename discover_interface() to more meaningful get_hw_address().

Hoist one-time initialization of client identifier out of
get_hw_address() to the one-time initialization code in main().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.93 2014/11/23 14:02:21 krw Exp $	*/
d54 1
a54 1
void got_one(void);
d173 1
a173 1
				got_one();
d201 1
a201 1
got_one(void)
@


1.93
log
@Cleanup some struct interface_info fields. Make 'nomedia' a flag. Replace
the two copies of the bpf socket descriptor (rfdesc, wfdesc) with
just one (bfdesc). No need to keep a struct ifreq (ifp) since it's
only used once and can be constructed there and discarded. Nuke
unused 'primary_address' member.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.92 2014/11/16 12:12:01 krw Exp $	*/
d48 1
a55 4
/*
 * Use getifaddrs() to get a list of all the attached interfaces.  Find
 * our interface on the list and store the interesting information about it.
 */
d57 1
a57 1
discover_interface(void)
d60 1
a60 2
	struct option_data *opt;
	char *data;
d77 11
a87 32
		/*
		 * If we have the capability, extract & save link information.
		 */
		if (ifa->ifa_addr->sa_family == AF_LINK) {
			struct sockaddr_dl *foo =
			    (struct sockaddr_dl *)ifa->ifa_addr;

			if (foo->sdl_alen != ETHER_ADDR_LEN)
				continue;

			ifi->index = foo->sdl_index;
			memcpy(ifi->hw_address.ether_addr_octet, LLADDR(foo),
			    ETHER_ADDR_LEN);
			opt = &config->send_options[DHO_DHCP_CLIENT_IDENTIFIER];
			/*
			 * Check both len && data so
			 *     send dhcp-client-identifier "";
			 * can be used to suppress sending the default client
			 * identifier.
			 */
			if (opt->len == 0 && opt->data == NULL) {
				/* Build default client identifier. */
				data = calloc(1, ETHER_ADDR_LEN + 1);
				if (data != NULL) {
					data[0] = HTYPE_ETHER;
					memcpy(&data[1], LLADDR(foo),
					    ETHER_ADDR_LEN);
					opt->data = data;
					opt->len = ETHER_ADDR_LEN + 1;
				}
			}
		}
@


1.92
log
@Read your compiler output even when it succeeds. Add missing variable to
error print statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.91 2014/11/13 00:33:35 krw Exp $	*/
a62 1
	struct ifreq *tif;
d65 1
a65 1
	int len;
d70 1
d79 1
a112 8

		if (!ifi->ifp) {
			len = IFNAMSIZ + sizeof(struct sockaddr_storage);
			if ((tif = malloc(len)) == NULL)
				error("no space to remember ifp");
			strlcpy(tif->ifr_name, ifa->ifa_name, IFNAMSIZ);
			ifi->ifp = tif;
		}
d115 1
a115 1
	if (!ifi->ifp)
d143 1
a143 1
		if (ifi->rfdesc == -1) {
d177 1
a177 1
		fds[0].fd = ifi->rfdesc;
d197 1
a197 1
			if (ifi && ifi->linkstat && ifi->rfdesc != -1)
d238 1
a238 1
		    (ifi->noifmedia && ifi->errors > 20)) {
d313 1
a313 1
	if (ifi->noifmedia)
d328 1
a328 1
		ifi->noifmedia = 1;
@


1.91
log
@Tweak some comments and error messages. Put all "I can't handle
this" tests at the top of the dispatch loop. Use a 'continue' instead
of 'goto <label just after the while>'. No intended functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.90 2014/05/05 18:02:49 krw Exp $	*/
d151 1
a151 1
			warning("%s bpf socket gone; exiting");
@


1.90
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.89 2014/02/18 01:46:58 krw Exp $	*/
a139 5
		/*
		 * Call expired timeout, and then if there's still
		 * a timeout registered, time out the select call then.
		 */
another:
d141 1
a141 1
			warning("No interfaces available");
a144 1

d146 6
a151 3
			warning("Interface %s:"
			    " rdomain changed out from under us",
			    ifi->name);
d162 1
a162 1
				goto another;
d177 7
a183 7
		/* Set up the descriptors to be polled. */
		if (!ifi || ifi->rfdesc == -1) {
			warning("No live interface to poll on");
			quit = INTERNALSIG;
			continue;
		}

d185 1
a185 1
		fds[1].fd = routefd; /* Could be -1, which will be ignored. */
a191 1
		/* Wait for a packet or a timeout or unpriv_ibuf->fd. XXX */
a192 2

		/* Not likely to be transitory. */
@


1.89
log
@Do not create the default dhcp-client-identifier if an empty string
has been configured as the value.

i.e. 'send dhcp-client-identifier "";' in dhclient.conf will result in
no dhcp-client-identifier (option 61) being sent.

Useful for testing dhcp server behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.88 2014/02/09 20:45:56 krw Exp $	*/
d89 1
a89 1
				
d449 1
a449 1
		
@


1.88
log
@Don't use imsg_flush(), roll a local flush_unpriv_ibuf() that loops
on EAGAIN, sets quit to INTERNALSIG on errors (unless quit is already
set to something else), and prints a consistant error message when
errors other than EPIPE and end of file are encountered.

Fixes failure to write resolv.conf when -L is used, and makes
add_address() and add_route() also wait until imsg is in pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.87 2013/12/08 22:49:02 krw Exp $	*/
d94 7
a100 1
			if (opt->len == 0) {
@


1.87
log
@Reduce in_addr memcpy() dances by simply using assignments where the source
variable has been copied to [cm]alloc'ed memory and thus properly aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.86 2013/12/06 23:40:48 krw Exp $	*/
d212 1
a212 6
			if (msgbuf_write(&unpriv_ibuf->w) <= 0 &&
			    errno != EAGAIN) {
				warning("pipe write error to [priv]");
				quit = INTERNALSIG;
				continue;
			}
@


1.86
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.85 2013/12/05 21:32:59 krw Exp $	*/
d260 1
a260 1
	memcpy(&ifrom, &from.sin_addr, sizeof(ifrom));
d402 1
d407 5
a411 5
	memset(&mymask, 0, sizeof(mymask));
	if (l->options[DHO_SUBNET_MASK].len == sizeof(mymask)) {
		memcpy(&mymask, l->options[DHO_SUBNET_MASK].data,
		    sizeof(mymask));
	}
@


1.85
log
@Use destination size as size of memcpy(). Use <in_addr> rather than
<in_addr>.s_addr to shorten code.

ok deraadt@@ matthew@@ as part of larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.84 2013/12/04 19:39:50 krw Exp $	*/
d87 3
d91 2
a92 4
			ifi->hw_address.hlen = foo->sdl_alen;
			ifi->hw_address.htype = HTYPE_ETHER; /* XXX */
			memcpy(ifi->hw_address.haddr, LLADDR(foo),
			    foo->sdl_alen);
d96 1
a96 1
				data = calloc(1, foo->sdl_alen + 1);
d98 1
a98 1
					data[0] = ifi->hw_address.htype;
d100 1
a100 1
					    foo->sdl_alen);
d102 1
a102 1
					opt->len = foo->sdl_alen + 1;
d241 1
a241 1
	struct hardware hfrom;
@


1.84
log
@More memcpy() stylistic repairs and size checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.83 2013/11/16 19:34:43 krw Exp $	*/
d406 3
a408 3
	if (l->options[DHO_SUBNET_MASK].len == sizeof(mymask.s_addr)) {
		memcpy(&mymask.s_addr, l->options[DHO_SUBNET_MASK].data,
		    sizeof(mymask.s_addr));
@


1.83
log
@Fix msgbuf_write() usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.82 2013/11/11 21:00:01 krw Exp $	*/
d406 4
a409 2
	memcpy(&mymask.s_addr, l->options[DHO_SUBNET_MASK].data,
	    l->options[DHO_SUBNET_MASK].len);
@


1.82
log
@Shuffle function prototypes and extern declarations around to
put local functions prototypes and variables in their .c files, and
cross-file functions into .h files. Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.81 2013/07/06 01:12:20 krw Exp $	*/
d211 2
a212 1
			if (msgbuf_write(&unpriv_ibuf->w) == -1) {
@


1.81
log
@Zap leading whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.80 2013/07/05 22:13:10 krw Exp $	*/
d52 2
@


1.80
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.79 2013/05/10 18:59:22 krw Exp $	*/
d397 1
a397 1
 {
d453 1
a453 1
 }
@


1.79
log
@Fix subnet check. Check our rdomain against the rdomains of the other
interfaces and not against our own.

Problem noted, fix tested and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.78 2013/05/02 16:35:27 krw Exp $	*/
d366 1
a366 1
	timeout.when = time(NULL) + secs; 
@


1.78
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.77 2013/04/05 19:19:05 krw Exp $	*/
d420 1
a420 1
		hisrdomain = get_rdomain(ifi->name);
@


1.77
log
@Nuke parameter to do_packet() not used since 2006. From dhill.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.76 2013/03/22 23:58:51 krw Exp $	*/
d186 1
a186 1
		/* Wait for a packet or a timeout or unpriv_ibuf->fd ... XXX */
d189 1
a189 1
		/* Not likely to be transitory... */
d309 1
a309 1
	/* get interface flags */
a316 4
	/*
	 * if one of UP and RUNNING flags is dropped,
	 * the interface is not active.
	 */
d320 1
a320 1
	/* Next, check carrier on the interface, if possible */
d327 2
a328 2
		 * EINVAL or ENOTTY simply means that the interface
		 * does not support the SIOCGIFMEDIA ioctl. We regard it alive.
@


1.76
log
@Ignore client-identifier option in leases from a server. They're not supposed
to be there! Instead, always record the client-identifier used to obtain
the lease. Ignore recorded leases that have a different client-identifier
than the one currently in force. If a client-identifier is not specified
in the dhclient.conf file, construct one from the network type and
MAC, like most other clients out there do these days.

Thus, if one plugs in a different USB network adapter, renewing the
previous lease (which upsets servers due to the MAC being different)
is skipped and DISCOVER is attempted at once.

Issue noted and fix tested by tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.75 2013/02/18 15:57:08 krw Exp $	*/
d258 1
a258 1
	do_packet(result, from.sin_port, ifrom, &hfrom);
@


1.75
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.74 2013/02/17 17:36:31 krw Exp $	*/
d62 3
a64 1
	int len = IFNAMSIZ + sizeof(struct sockaddr_storage);
d88 14
a101 2
			memcpy(ifi->hw_address.haddr,
			    LLADDR(foo), foo->sdl_alen);
d103 1
d105 1
@


1.74
log
@Using the value SIGQUIT to cause the dispatch loops to exit produced
universal revulsion and no little confusion.  #define our own value,
currently INT_MAX, which should not overlap any likely signal value.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.73 2013/02/17 17:04:41 krw Exp $	*/
d206 9
a214 11
	/*
	 * SIGTERM is used by system at shut down. Be nice and don't cleanup
	 * routes, thus possibly preventing NFS from properly shutting down.
	 */
	if (client->active && quit != SIGTERM)
		cleanup(client->active);

	if (quit == SIGHUP)
		exit(0);

	exit(1);
@


1.73
log
@Suppress some pointless debugging message:

1) If the pipe to the priv process is closed while waiting for
something to happen in the non-priv dispatch() loop, assume the
priv process issued an error message and exit without additional
verbiage.

2) Ditto if the pipe to the priv process is closed when the flush
of IMSG_CLEANUP is attempted.

3) No need to report when SIOCDIFADDR fails because the address is
already gone.

Start to ensure the priv process always issues a useful message
before exiting by noting when it restarts due to the LLADDR having
changed.

Prodded by deraadt@@ to clean this up.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.72 2013/02/14 22:18:12 krw Exp $	*/
d122 1
a122 1
			quit = SIGQUIT;
d130 1
a130 1
			quit = SIGQUIT;
d158 1
a158 1
			quit = SIGQUIT;
d179 1
a179 1
				quit = SIGQUIT;
d195 1
a195 1
				quit = SIGQUIT;
d201 1
a201 1
			quit = SIGQUIT;
@


1.72
log
@When an interface generates an RTM_IFINFO message, it may be as the
result of its LLADDR changing! Check said address and if it differs
from what we think it is, simulate a SIGHUP to restart, getting the
new address and a new lease for it.

Spotted by, fix tested by, and ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.71 2013/02/13 19:32:52 krw Exp $	*/
d200 1
a200 1
			warning("lost connection to [priv]");
@


1.71
log
@Restore previous behaviour of not cleaning up in response to SIGTERM.

SIGTERM is used to make processes go away during system shutdown and
NFS filesystems may be still be in use when it is received. So removing
routes to the NFS servers is a bad thing.

Problem discovered and fix tested by landry@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.70 2013/01/18 06:05:54 krw Exp $	*/
a99 3
	/* Register the interface... */
	if_register_receive();
	if_register_send();
@


1.70
log
@Change a bunch of error()'s to warning()'s in the dispatch loop.
Set 'quit' to exit the loop in those situations, allowing more
cleanup() attempts in those error situations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.69 2012/12/29 14:40:00 krw Exp $	*/
d125 1
a125 1
			quit = SIGTERM;
d133 1
a133 1
			quit = SIGTERM;
d161 1
a161 1
			quit = SIGTERM;
d182 1
a182 1
				quit = SIGTERM;
d198 1
a198 1
				quit = SIGTERM;
d204 1
a204 1
			quit = SIGTERM;
d209 5
a213 1
	if (client->active)
@


1.69
log
@Make HUP to either one of the processes cause a restart that will
have dhclient re-read dhclient.conf and get a new lease. Constrain
the filename passed to '-l' (alternate dhclient.lease.if location)
to be a regular file for the moment.

Original suggestion from phessler@@. Feedback from deraadt@@ and
espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.68 2012/12/04 19:24:03 krw Exp $	*/
d123 5
a127 2
		if (!ifi)
			error("No interfaces available");
d129 2
a130 2
		if (ifi->rdomain != get_rdomain(ifi->name))
			error("Interface %s:"
d133 3
d159 5
a163 2
		if (!ifi || ifi->rfdesc == -1)
			error("No live interface to poll on");
d180 5
a184 2
			} else
				error("poll: %s", strerror(errno));
d196 5
a200 2
			if (msgbuf_write(&unpriv_ibuf->w) == -1)
				error("pipe write error to [priv]");
d203 3
a205 1
			error("lost connection to [priv]");
d209 1
a209 1
	if (quit == SIGHUP) {
d211 2
d214 1
a214 1
	}
@


1.68
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.67 2012/11/24 18:06:14 krw Exp $	*/
d117 1
a117 1
	do {
d190 7
a196 1
	} while (1);
@


1.67
log
@Don't segfault if no subnet-mask is provided, or is marked 'ignore'
in dhclient.conf.

Always zero out stack masks rather than using stack garbage when
no subnet-mask is provided.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.66 2012/11/23 15:25:47 krw Exp $	*/
d172 1
a172 1
				error("poll: %m");
d233 2
a234 1
		note("interface_link_forceup: SIOCGIFFLAGS failed (%m)");
d242 2
a243 1
		note("interface_link_forceup: SIOCSIFFLAGS DOWN failed (%m)");
d250 2
a251 1
		note("interface_link_forceup: SIOCSIFFLAGS UP failed (%m)");
d273 2
a274 1
		error("ioctl(SIOCGIFFLAGS) on %s: %m", ifname);
d296 2
a297 1
			debug("ioctl(SIOCGIFMEDIA) on %s: %m", ifname);
d348 1
a348 1
	    error("get_rdomain socket: %m");
@


1.66
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.65 2012/11/08 21:32:55 krw Exp $	*/
d361 1
d363 1
a363 1
	    sizeof(in_addr_t));
@


1.65
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.64 2012/11/07 15:20:28 krw Exp $	*/
d43 1
d158 1
a158 1
		fds[2].fd = privfd;
d161 4
a164 1
		/* Wait for a packet or a timeout or privfd ... XXX */
d182 4
@


1.64
log
@Use memset() consistently rather than tossing in a few bzero()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.63 2012/11/07 15:07:02 krw Exp $	*/
d190 1
a190 1
	struct iaddr ifrom;
d208 1
a208 2
	ifrom.len = 4;
	memcpy(ifrom.iabuf, &from.sin_addr, ifrom.len);
d350 1
a350 1
	in_addr_t mymask, myaddr, mynet, hismask, hisaddr, hisnet;
d353 4
a356 3
	memcpy(&mymask, l->options[DHO_SUBNET_MASK].data, 4);
	memcpy(&myaddr, l->address.iabuf, 4);
	mynet = mymask & myaddr;
d374 7
a380 5
		hismask = ((struct sockaddr_in *)ifa->ifa_netmask)->
		    sin_addr.s_addr;
		hisaddr = ((struct sockaddr_in *)ifa->ifa_addr)->
		    sin_addr.s_addr;
		hisnet = hisaddr & hismask;
d382 1
a382 1
		if (hisnet == 0)
d386 1
a386 1
		if (mynet == (hisaddr & mymask)) {
d393 1
a393 1
		if (hisnet == (myaddr & hismask)) {
@


1.63
log
@Use memcpy() consistently rather than tossing in a few bcopy()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.62 2012/11/04 23:40:59 stsp Exp $	*/
d338 1
a338 1
	bzero(&ifr, sizeof(ifr));
@


1.62
log
@Properly clear the UP flag while forcing the interface down/up
rather than setting all flags to zero. ok krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.61 2012/11/02 14:23:49 krw Exp $	*/
d354 2
a355 2
	bcopy(l->options[DHO_SUBNET_MASK].data, &mymask, 4);
	bcopy(l->address.iabuf, &myaddr, 4);
@


1.61
log
@Watch the non-privileged end of the pipe to the privileged child
process. So when the child dies, the parent exits immediately.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.60 2012/10/30 18:39:44 krw Exp $	*/
d232 1
a232 1
	ifr.ifr_flags &= !IFF_UP;
@


1.60
log
@Nuke dhclient-script and dhclient.conf 'script' directive. Do all
interface and route configuration via ioctl's and routing sockets.

This will break configurations using local enhancements of
dhclient-script, which will now require alternate arrangements.

Committing early to allow time to identify and develop required
alternatives.

Several proddings by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.59 2012/10/11 08:05:05 sthen Exp $	*/
d112 1
a112 1
	struct pollfd fds[2];
d157 2
a158 1
		fds[0].events = fds[1].events = POLLIN;
d160 2
a161 2
		/* Wait for a packet or a timeout... XXX */
		count = poll(fds, 2, to_msec);
d178 3
@


1.59
log
@Remove the new (as of r1.56) line of code which updates ifi->linkstat in
the dispatch loop again; in the case where two RTM_IFINFO link changes occur
immediately after each other (as in the case with trunk and probably vlan)
dhclient missed the state change of the second interface.

ok krw@@, who points out that dhcp packets received between the two
RTM_IFINFO messages would be lost, however the window is small (<0.4ms on
my laptop) and this is better than not noticing the link change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.58 2012/09/18 09:34:09 krw Exp $	*/
d50 1
a50 1
struct timeout timeout;
d210 1
a210 1
int
d222 9
d232 1
a232 1
		return (-1);
d235 3
a237 6
	if ((ifr.ifr_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
		ifr.ifr_flags |= IFF_UP;
		if (ioctl(sock, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
			close(sock);
			return (-1);
		}
d239 1
a239 1
		return (0);
d241 1
a242 1
	return (1);
d329 1
a329 1
	struct  ifreq ifr;
@


1.58
log
@Don't accept leases that offer a subnet that is already configured
on an interface. Crude hammer that may be refined as needed.

Feedback from tedu@@, beck@@, sthen@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.57 2012/09/17 12:10:46 krw Exp $	*/
a123 2
			
		ifi->linkstat = interface_status(ifi->name);
@


1.57
log
@De-obfuscate and update reality correspondance of some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.56 2012/09/01 19:02:27 krw Exp $	*/
d338 56
@


1.56
log
@Nuke a static global I can't get my head around - interfaces_invalidated.
Since reinitialize_interface() was simply setting interfaces_invalidated
to 0, nuke it too!

Always update ifi->linkstat in dispatch() loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.55 2012/08/26 23:33:31 krw Exp $	*/
d53 2
a54 4
 * Use getifaddrs() to get a list of all the attached interfaces.  For
 * each interface that's of type INET and not the loopback interface,
 * register that interface with the network I/O software, figure out
 * what subnet it's on, and add it to the list of interfaces.
d76 1
a76 2
		 * If we have the capability, extract link information
		 * and record it in a linked list.
d106 1
a106 3
 * Wait for packets to come in using poll().  When a packet comes in, call
 * receive_packet to receive the packet and possibly strip hardware addressing
 * information from it, and then call do_packet to try to do something with it.
@


1.55
log
@Junk global cur_time, and use time(NULL) or local variables where
time is checked multiple times. Add a set_timeout_interval() function
to allow setting a timeout based on an interval from current time.

Fixes issues with initial startup where the global cur_time was
always old and caused initial DHCPDISCOVER or DHCPREQUEST packets
to be sent multiple times. And probably other timeout related
oddities.

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.54 2012/08/18 00:20:01 krw Exp $	*/
a50 1
static int interfaces_invalidated;
a107 6
void
reinitialize_interface(void)
{
	interfaces_invalidated = 1;
}

d130 1
a130 2
		if (!ifi->linkstat)
			interfaces_invalidated = 0;
d182 1
a182 1
			if (ifi && !interfaces_invalidated)
a184 2

		interfaces_invalidated = 0;
@


1.54
log
@Update global cur_time after exiting poll() and before calling the
state engine for packet processing. Time may have passed! Use cur_time
in routing message processing.

Makes sense to todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.53 2012/07/26 18:42:58 krw Exp $	*/
d125 1
a125 1
	time_t howlong;
a176 3
		/* Time may have moved on while we polled! */
		time(&cur_time);

d319 7
@


1.53
log
@Make interface_status() assume that a link is up when IFM_AVALID
is not set. This is what the late interface_link_status() did.
Allows drivers who cannot tell what the link state is to get
dhcp leases.

Prodding by henning@@.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.52 2012/07/09 16:21:21 krw Exp $	*/
d176 3
@


1.52
log
@Terminate with extreme prejudice the multiple timeout queuing
mechanism that was a holdover from when dhclient handled multiple
interfaces at once. There is only one timeout possible at a time.

Also move calculation of current time to just before check to see
if the timeout has expired.

ok beck@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.51 2012/06/24 16:01:18 krw Exp $	*/
d304 6
a312 3
active:
	close(sock);
	return (1);
@


1.51
log
@Nuke interface_link_status() (check media status only) and use
interface_status() (check IFF_UP|IFF_RUNNING and media status). The
interface is forced up when dhclient starts so the flags should be
correct.

Thanks to guenther@@ for pointing out the original raison d'etre of
the difference between the two.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.50 2012/06/22 01:01:59 krw Exp $	*/
d50 1
a50 2
struct timeout *timeouts;
static struct timeout *free_timeouts;
d126 1
d130 1
a130 1
		 * Call any expired timeouts, and then if there's still
d145 6
a150 9
		if (timeouts) {
			struct timeout *t;

			if (timeouts->when <= cur_time) {
				t = timeouts;
				timeouts = timeouts->next;
				(*(t->func))();
				t->next = free_timeouts;
				free_timeouts = t;
a152 1

d159 1
a159 1
			howlong = timeouts->when - cur_time;
a176 3
		/* Get the current time... */
		time(&cur_time);

d313 1
a313 1
add_timeout(time_t when, void (*where)(void))
d315 2
a316 53
	struct timeout *t, *q;

	/* See if this timeout supersedes an existing timeout. */
	t = NULL;
	for (q = timeouts; q; q = q->next) {
		if (q->func == where) {
			if (t)
				t->next = q->next;
			else
				timeouts = q->next;
			break;
		}
		t = q;
	}

	/* If we didn't supersede a timeout, allocate a timeout
	   structure now. */
	if (!q) {
		if (free_timeouts) {
			q = free_timeouts;
			free_timeouts = q->next;
			q->func = where;
		} else {
			q = malloc(sizeof(struct timeout));
			if (!q)
				error("Can't allocate timeout structure!");
			q->func = where;
		}
	}

	q->when = when;

	/* Now sort this timeout into the timeout list. */

	/* Beginning of list? */
	if (!timeouts || timeouts->when > q->when) {
		q->next = timeouts;
		timeouts = q;
		return;
	}

	/* Middle of list? */
	for (t = timeouts; t->next; t = t->next) {
		if (t->next->when > q->when) {
			q->next = t->next;
			t->next = q;
			return;
		}
	}

	/* End of list. */
	t->next = q;
	q->next = NULL;
d320 1
a320 1
cancel_timeout(void (*where)(void))
d322 2
a323 20
	struct timeout *t, *q;

	/* Look for this timeout on the list, and unlink it if we find it. */
	t = NULL;
	for (q = timeouts; q; q = q->next) {
		if (q->func == where) {
			if (t)
				t->next = q->next;
			else
				timeouts = q->next;
			break;
		}
		t = q;
	}

	/* If we found the timeout, put it on the free list. */
	if (q) {
		q->next = free_timeouts;
		free_timeouts = q;
	}
@


1.50
log
@Two 'ioctl() < 0' -> 'ioctl() == -1'. guenther@@ says they're odd.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.49 2010/10/23 14:26:57 phessler Exp $	*/
a399 31
}

int
interface_link_status(char *ifname)
{
	struct ifmediareq ifmr;
	int sock;

	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		error("Can't create socket");

	memset(&ifmr, 0, sizeof(ifmr));
	strlcpy(ifmr.ifm_name, ifname, sizeof(ifmr.ifm_name));
	if (ioctl(sock, SIOCGIFMEDIA, (caddr_t)&ifmr) == -1) {
		/* EINVAL/ENOTTY -> link state unknown. treat as active */
#ifdef DEBUG
		if (errno != EINVAL && errno != ENOTTY)
			debug("ioctl(SIOCGIFMEDIA) on %s: %m", ifname);
#endif
		close(sock);
		return (1);
	}
	close(sock);

	if (ifmr.ifm_status & IFM_AVALID) {
		if (ifmr.ifm_status & IFM_ACTIVE)
			return (1);
		else
			return (0);
	}
	return (1);
@


1.49
log
@make sure an interface is registered before we start using it

found by clang

OK claudio@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.48 2010/07/03 04:44:51 guenther Exp $	*/
d276 1
a276 1
	if (ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {
d292 1
a292 1
	if (ioctl(sock, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
@


1.48
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.47 2010/07/02 22:03:27 deraadt Exp $	*/
d134 3
@


1.47
log
@garbage collect an unused function; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.46 2010/06/02 09:57:16 phessler Exp $	*/
d441 1
a441 1
	if (ioctl(s, SIOCGIFRTABLEID, (caddr_t)&ifr) != -1)
@


1.46
log
@Have dhclient obey the interface's rdomain, instead of doing routes on
rdomain 0.

OK krw@@, claudio@@
sharp stick prodding from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.45 2009/11/26 23:14:29 krw Exp $	*/
a257 27
}

void
interface_link_forcedown(char *ifname)
{
	struct ifreq ifr;
	int sock;

	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		error("Can't create socket");

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
	if (ioctl(sock, SIOCGIFFLAGS, (caddr_t)&ifr) == -1) {
		close(sock);
		return;
	}

	if ((ifr.ifr_flags & IFF_UP) == IFF_UP) {
		ifr.ifr_flags &= ~IFF_UP;
		if (ioctl(sock, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
			close(sock);
			return;
		}
	}

	close(sock);
@


1.45
log
@Silence dhclient by immediately exiting if the interface doesn't exist
or can't return important flags via ioctl. Excess verbiage pointed out
by deraadt@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.44 2009/06/06 04:02:42 krw Exp $	*/
d137 5
d455 18
@


1.44
log
@Nuke debug() unless DEBUG is defined. Elminates debug output from
normal operations.

Prodded by deraadt@@ a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.43 2009/02/19 03:29:21 krw Exp $	*/
d212 1
a212 1
			warning("Interface %s no longer appears valid.",
a213 3
			interfaces_invalidated = 1;
			close(ifi->rfdesc);
			ifi->rfdesc = -1;
d296 1
a296 2
		warning("ioctl(SIOCGIFFLAGS) on %s: %m", ifname);
		goto inactive;
@


1.43
log
@'(ifi->linkstat && ifi && ifi->rfdesc != -1)' is flawed. Swap the
first two terms so ifi is checked first.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.42 2008/05/26 03:11:49 deraadt Exp $	*/
d320 1
d323 1
d438 1
d441 1
@


1.42
log
@If an interface has no link at startup, try to force it up, and then
give it about 4 seconds of (silent) grace period before doing the verbose
search for a link...
tested by various developers who got burned a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.41 2008/05/09 05:19:14 reyk Exp $	*/
d185 1
a185 2
			if (ifi->linkstat &&
			    ifi && ifi->rfdesc != -1)
@


1.41
log
@- don't give up when the link is not available on startup: dhclient
goes to background and listens on the routing socket for link to come
up before it retries.
- renew the lease whenever the link was lost and becomes active again.
- listen for link state changes on non-ethernet devices like wireless,
the link state becomes active when the wireless has been associated to
the AP and becomes active. this helps to automatically renew the lease
when the user is roaming.

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.40 2007/11/12 10:14:40 dlg Exp $	*/
a53 2
static int interface_status(void);

d210 1
a210 1
		if ((!interface_status()) ||
d287 1
a287 1
interface_status(void)
a288 2
	char *ifname = ifi->name;
	int ifsock = ifi->rfdesc;
d291 4
d299 1
a299 1
	if (ioctl(ifsock, SIOCGIFFLAGS, &ifr) < 0) {
d316 1
a316 1
	if (ioctl(ifsock, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
d334 1
d337 1
@


1.40
log
@dont spew debug output when the SIOCGIFMEDIA ioctl errors with ENOTTY.

ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.39 2007/02/14 23:15:01 stevesk Exp $	*/
d136 3
d187 2
a188 1
			if (ifi && ifi->rfdesc != -1)
d328 3
a330 8
		switch (ifmr.ifm_active & IFM_NMASK) {
		case IFM_ETHER:
			if (ifmr.ifm_status & IFM_ACTIVE)
				goto active;
			else
				goto inactive;
			break;
		default:
a331 1
		}
d443 4
a446 6
		if ((ifmr.ifm_active & IFM_NMASK) == IFM_ETHER) {
			if (ifmr.ifm_status & IFM_ACTIVE)
				return (1);
			else
				return (0);
		}
@


1.39
log
@use errwarn functions vs. syslog(); ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.38 2007/01/27 22:05:24 krw Exp $	*/
a312 6
		if (errno != EINVAL) {
			debug("ioctl(SIOCGIFMEDIA) on %s: %m", ifname);

			ifi->noifmedia = 1;
			goto active;
		}
d314 1
a314 1
		 * EINVAL (or ENOTTY) simply means that the interface
d317 3
d436 2
a437 2
		/* EINVAL -> link state unknown. treat as active */
		if (errno != EINVAL)
@


1.38
log
@We only poll on the bpf fd and the routing socket fd. No need for
complex list code to keep track. So nuke it.

Also eliminate unnecessary variable ('dead') that means 'rfdesc is
closed'. Just set rfdesc to -1 when it is closed and use that.

As suggested by millert@@ and claudio@@, don't bother setting revents
members to zero since poll() does that.

Np functional change, just less code.

'looks good' claudio@@  'I like where this is going' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.37 2007/01/11 02:36:29 krw Exp $	*/
d296 1
a296 1
		syslog(LOG_ERR, "ioctl(SIOCGIFFLAGS) on %s: %m", ifname);
d314 1
a314 2
			syslog(LOG_DEBUG, "ioctl(SIOCGIFMEDIA) on %s: %m",
			    ifname);
d441 1
a441 2
			syslog(LOG_DEBUG, "ioctl(SIOCGIFMEDIA) on %s: %m",
			    ifname);
@


1.37
log
@Since bootp_packet_handler is always set to do_packet before we
process any packets, eliminate that abstraction and just call
do_packet directly.

No functional change.

ok stevesk
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.36 2007/01/04 22:17:48 krw Exp $	*/
a49 1
struct protocol *protocols;
a108 1
	add_protocol(ifi->name, ifi->rfdesc, got_one);
d126 2
a127 3
	int count, i, to_msec, nfds = 0;
	struct protocol *l;
	struct pollfd *fds;
a129 7
	for (l = protocols; l; l = l->next)
		nfds++;

	fds = malloc(nfds * sizeof(struct pollfd));
	if (fds == NULL)
		error("Can't allocate poll structures.");

d162 2
a163 8
		for (i = 0, l = protocols; l; l = l->next) {
			if (ifi && (l->handler != got_one || !ifi->dead)) {
				fds[i].fd = l->fd;
				fds[i].events = POLLIN;
				fds[i].revents = 0;
				i++;
			}
		}
d165 3
a167 2
		if (i == 0)
			error("No live interfaces to poll on - exiting.");
d170 4
a173 1
		count = poll(fds, nfds, to_msec);
a177 1
				time(&cur_time);
d183 8
a190 2
		/* Get the current time... */
		time(&cur_time);
a191 12
		i = 0;
		for (l = protocols; l; l = l->next) {
			if ((fds[i].revents & (POLLIN | POLLHUP))) {
				fds[i].revents = 0;
				if (ifi && (l->handler != got_one ||
				    !ifi->dead))
					(*(l->handler))(l);
				if (interfaces_invalidated)
					break;
			}
			i++;
		}
d197 1
a197 1
got_one(struct protocol *l)
a212 1
			ifi->dead = 1;
d214 2
a215 2
			close(l->fd);
			remove_protocol(l);
a424 34
	}
}

/* Add a protocol to the list of protocols... */
void
add_protocol(char *name, int fd, void (*handler)(struct protocol *))
{
	struct protocol *p;

	p = malloc(sizeof(*p));
	if (!p)
		error("can't allocate protocol struct for %s", name);

	p->fd = fd;
	p->handler = handler;
	p->next = protocols;
	protocols = p;
}

void
remove_protocol(struct protocol *proto)
{
	struct protocol *p, *next, *prev;

	prev = NULL;
	for (p = protocols; p; p = next) {
		next = p->next;
		if (p == proto) {
			if (prev)
				prev->next = p->next;
			else
				protocols = p->next;
			free(p);
		}
@


1.36
log
@Another round of cleanup. There is only one instance of struct
dhcp_packet and it is contained in the global *client. So don't pass
around pointers to a struct that contains a pointer to the dhcp_packet
instance. Just use the global client->packet. Eliminate unused struct
packet members and parameter lists accordingly.

No functional change.

Suggestions by stevesk@@. ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.35 2006/12/26 21:19:52 krw Exp $	*/
a53 2
void (*bootp_packet_handler)(int, unsigned int, struct iaddr,
    struct hardware *);
d121 3
a123 4
 * Wait for packets to come in using poll().  When a packet comes in,
 * call receive_packet to receive the packet and possibly strip hardware
 * addressing information from it, and then call through the
 * bootp_packet_handler hook to try to do something with it.
d242 2
a243 3
	if (bootp_packet_handler) {
		ifrom.len = 4;
		memcpy(ifrom.iabuf, &from.sin_addr, ifrom.len);
d245 1
a245 2
		(*bootp_packet_handler)(result, from.sin_port, ifrom, &hfrom);
	}
@


1.35
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.34 2006/08/29 04:09:27 deraadt Exp $	*/
d54 2
a55 2
void (*bootp_packet_handler)(struct dhcp_packet *, int, unsigned int,
    struct iaddr, struct hardware *);
a224 8
	union {
		/*
		 * Packet input buffer.  Must be as large as largest
		 * possible MTU.
		 */
		unsigned char packbuf[4095];
		struct dhcp_packet packet;
	} u;
d226 1
a226 2
	if ((result = receive_packet(u.packbuf, sizeof(u), &from, &hfrom)) ==
	    -1) {
d249 1
a249 2
		(*bootp_packet_handler)(&u.packet, result,
		    from.sin_port, ifrom, &hfrom);
@


1.34
log
@snuck in a typo, damnit
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.33 2006/08/29 03:55:09 deraadt Exp $	*/
d54 1
a54 2
void (*bootp_packet_handler)(struct interface_info *,
    struct dhcp_packet *, int, unsigned int,
d57 1
a57 1
static int interface_status(struct interface_info *ifinfo);
d66 1
a66 1
discover_interfaces(struct interface_info *iface)
d81 1
a81 1
		if (strcmp(iface->name, ifa->ifa_name))
d92 4
a95 4
			iface->index = foo->sdl_index;
			iface->hw_address.hlen = foo->sdl_alen;
			iface->hw_address.htype = HTYPE_ETHER; /* XXX */
			memcpy(iface->hw_address.haddr,
d98 1
a98 1
		if (!iface->ifp) {
d102 1
a102 1
			iface->ifp = tif;
d106 2
a107 2
	if (!iface->ifp)
		error("%s: not found", iface->name);
d110 3
a112 3
	if_register_receive(iface);
	if_register_send(iface);
	add_protocol(iface->name, iface->rfdesc, got_one, iface);
d117 1
a117 1
reinitialize_interfaces(void)
d155 1
a155 1
				(*(t->func))(t->what);
d176 1
a176 3
			struct interface_info *ip = l->local;

			if (ip && (l->handler != got_one || !ip->dead)) {
a203 2
			struct interface_info *ip;
			ip = l->local;
d206 2
a207 2
				if (ip && (l->handler != got_one ||
				    !ip->dead))
a232 1
	struct interface_info *ip = l->local;
d234 3
a236 3
	if ((result = receive_packet(ip, u.packbuf, sizeof(u), &from,
	    &hfrom)) == -1) {
		warning("receive_packet failed on %s: %s", ip->name,
d238 3
a240 3
		ip->errors++;
		if ((!interface_status(ip)) ||
		    (ip->noifmedia && ip->errors > 20)) {
d243 2
a244 2
			    ip->name);
			ip->dead = 1;
a247 1
			free(ip);
d258 1
a258 1
		(*bootp_packet_handler)(ip, &u.packet, result,
d320 1
a320 1
interface_status(struct interface_info *ifinfo)
d322 2
a323 2
	char *ifname = ifinfo->name;
	int ifsock = ifinfo->rfdesc;
d343 1
a343 1
	if (ifinfo->noifmedia)
d352 1
a352 1
			ifinfo->noifmedia = 1;
d359 1
a359 1
		ifinfo->noifmedia = 1;
d381 1
a381 1
add_timeout(time_t when, void (*where)(void *), void *what)
d388 1
a388 1
		if (q->func == where && q->what == what) {
a404 1
			q->what = what;
a409 1
			q->what = what;
d439 1
a439 1
cancel_timeout(void (*where)(void *), void *what)
d446 1
a446 1
		if (q->func == where && q->what == what) {
d465 1
a465 2
add_protocol(char *name, int fd, void (*handler)(struct protocol *),
    void *local)
a474 1
	p->local = local;
@


1.33
log
@some net if devices do not media negotiate (for link) until brought up.
(for some drivers, this is a bug.  for others, it is part of how they work)
therefore before doing the 10-second link test, we must bring the if up.
ok krw, tested marco ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.32 2005/05/24 03:11:12 todd Exp $	*/
d274 1
a274 1
	int sock, ret = 0;
@


1.32
log
@no more 'ifconfig $if 0.0.0.0 up' only 'ifconfig $if up' since dhclient
uses bpf exclusively

ok deraadt@@, henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.31 2004/09/21 04:07:03 david Exp $	*/
a222 1

d268 56
@


1.31
log
@spelling fixes; ok jmc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.30 2004/09/15 18:15:18 henning Exp $	*/
a69 1
	struct sockaddr_in foo;
d71 1
d98 6
a103 18
		} else if (ifa->ifa_addr->sa_family == AF_INET) {
			struct iaddr addr;

			memcpy(&foo, ifa->ifa_addr, sizeof(foo));
			if (foo.sin_addr.s_addr == htonl(INADDR_LOOPBACK))
				continue;
			if (!iface->ifp) {
				int len = IFNAMSIZ + ifa->ifa_addr->sa_len;
				if ((tif = malloc(len)) == NULL)
					error("no space to remember ifp");
				strlcpy(tif->ifr_name, ifa->ifa_name, IFNAMSIZ);
				memcpy(&tif->ifr_addr, ifa->ifa_addr,
				    ifa->ifa_addr->sa_len);
				iface->ifp = tif;
				iface->primary_address = foo.sin_addr;
			}
			addr.len = 4;
			memcpy(addr.iabuf, &foo.sin_addr.s_addr, addr.len);
@


1.30
log
@no \n in error() calls and minor KNF, from Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.29 2004/06/22 01:10:49 canacar Exp $	*/
d178 1
a178 1
			 * negative timeout and blocking indefinetely.
@


1.29
log
@handle interface removals in the poll loop. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.28 2004/05/05 23:07:47 deraadt Exp $	*/
d471 1
a471 1
	if ((sock = socket (AF_INET, SOCK_DGRAM, 0)) == -1)
@


1.28
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.27 2004/05/04 22:23:01 mickey Exp $	*/
d221 1
a221 1
			if ((fds[i].revents & POLLIN)) {
@


1.27
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.26 2004/05/04 21:48:16 deraadt Exp $	*/
d69 1
a70 1
	struct ifaddrs *ifap, *ifa;
@


1.26
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.25 2004/05/04 20:28:40 deraadt Exp $	*/
d255 1
a255 1
		warn("receive_packet failed on %s: %s", ip->name,
d261 1
a261 1
			warn("Interface %s no longer appears valid.",
@


1.25
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.24 2004/05/04 18:58:50 deraadt Exp $	*/
a148 1
	nfds = 0;
d164 1
d190 1
d210 1
a210 2
			}
			else
d298 1
d303 1
a303 1
	if ((ifr.ifr_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
d305 1
a305 1
	}
@


1.24
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.23 2004/04/07 16:27:08 henning Exp $	*/
d92 1
a125 1

d188 1
a188 3
		i = 0;

		for (l = protocols; l; l = l->next) {
@


1.23
log
@fix a logic botch in discover_interfaces that prevented dhclient to see
any but the first real interface
found yesterday evening at RATT when dhclient would not get me a lease on
wireless
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.22 2004/03/02 18:49:21 deraadt Exp $	*/
d244 1
a244 1
	size_t result;
@


1.22
log
@more pruning; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.21 2004/03/02 13:39:44 henning Exp $	*/
d83 1
a83 1
			break;
@


1.21
log
@we deal with one interface at a time, so remove the interface list gunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.18 2004/03/02 12:43:09 henning Exp $	*/
d55 2
a56 2
     struct dhcp_packet *, int, unsigned int,
     struct iaddr, struct hardware *);
d70 1
a71 1
	struct ifaddrs *ifap, *ifa;
d144 1
a145 1
	int nfds = 0;
a146 2
	int count;
	int i;
a147 1
	int to_msec;
d226 1
a226 1
				     !ip->dead))
d255 2
a256 2
	if ((result =
	    receive_packet(ip, u.packbuf, sizeof(u), &from, &hfrom)) == -1) {
d264 1
a264 1
			     ip->name);
d316 1
a443 1

d469 1
a470 1
	struct ifmediareq ifmr;
d487 1
a487 1
	if (ifmr.ifm_status & IFM_AVALID)
d494 1
a494 1

@


1.20
log
@remove dummy_interfaces and fallback_interface gunk
@
text
@a49 1
struct interface_info *interfaces;
@


1.19
log
@our interface discovery is so quiet now (nonexistant) that we don't need a
quiet_interface_discovery flag any more
@
text
@d50 1
a50 1
struct interface_info *interfaces, *dummy_interfaces, *fallback_interface;
@


1.18
log
@mixing memcpy and bcopy in the same function is highly confusing
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.17 2004/03/02 12:40:31 henning Exp $	*/
a59 2

int quiet_interface_discovery;
@


1.17
log
@since we're dealing with one interface and not quite a few ones we can give
this one onterface as parameter to discove_interfaces and get rid of quite
some of the multiple-interface-discover logic
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.16 2004/03/02 12:19:14 henning Exp $	*/
d103 1
a103 1
			bcopy(ifa->ifa_addr, &foo, sizeof(foo));
@


1.16
log
@do not record all these interfaces we don't care about
@
text
@d1 1
a1 3
/*	$OpenBSD: dispatch.c,v 1.15 2004/02/24 17:26:43 henning Exp $	*/

/* Network input dispatcher... */
a49 3
/* Most boxes has less than 16 interfaces, so this might be a good guess.  */
#define INITIAL_IFREQ_COUNT 16

d70 1
a70 1
discover_interfaces(void)
a71 2
	struct interface_info *tmp;
	struct interface_info *last, *next;
d85 1
a85 5
		for (tmp = interfaces; tmp; tmp = tmp->next)
			if (!strcmp(tmp->name, ifa->ifa_name))
				break;

		if (!tmp)
d95 4
a98 4
			tmp->index = foo->sdl_index;
			tmp->hw_address.hlen = foo->sdl_alen;
			tmp->hw_address.htype = HTYPE_ETHER; /* XXX */
			memcpy(tmp->hw_address.haddr,
d106 1
a106 1
			if (!tmp->ifp) {
d108 2
a109 3
				tif = malloc(len);
				if (!tif)
					error("no space to remember ifp.");
d113 2
a114 2
				tmp->ifp = tif;
				tmp->primary_address = foo.sin_addr;
d121 2
a122 33
	/*
	 * Now cycle through all the interfaces we found, looking for
	 * hardware addresses.
	 */

	/* Weed out the interfaces that did not have IP addresses. */
	last = NULL;
	for (tmp = interfaces; tmp; tmp = next) {
		next = tmp->next;
		if (!tmp->ifp || !(tmp->flags & INTERFACE_REQUESTED)) {
			if ((tmp->flags & INTERFACE_REQUESTED))
				error("%s: not found", tmp->name);
			if (!last)
				interfaces = interfaces->next;
			else
				last->next = tmp->next;

			/*
			 * Remember the interface in case we need to know
			 * about it later.
			 */
			tmp->next = dummy_interfaces;
			dummy_interfaces = tmp;
			continue;
		}
		last = tmp;

		memcpy(&foo, &tmp->ifp->ifr_addr, sizeof(tmp->ifp->ifr_addr));

		/* Register the interface... */
		if_register_receive(tmp);
		if_register_send(tmp);
	}
d124 4
a127 3
	/* Now register all the remaining interfaces as protocols. */
	for (tmp = interfaces; tmp; tmp = tmp->next)
		add_protocol(tmp->name, tmp->rfdesc, got_one, tmp);
@


1.15
log
@whack unused token ring code and a few empty functions
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.14 2004/02/24 15:35:56 henning Exp $	*/
d96 2
a97 11
		if (!tmp) {
			tmp = dmalloc(sizeof(*tmp), "discover_interfaces");
			if (!tmp)
				error("Insufficient memory to %s %s",
				    "record interface", ifa->ifa_name);
			strlcpy(tmp->name, ifa->ifa_name, sizeof(tmp->name));
			tmp->next = interfaces;
			tmp->flags = 0;
			tmp->noifmedia = tmp->dead = tmp->errors = 0;
			interfaces = tmp;
		}
@


1.14
log
@get rid of tons of structs we never use, a lot of new_someotherjunk functions
in alloc.c we never call, and a shitload of genius comments like
char *script_name; /* name of script */
char *server_name; /* name of server */
etc etc etc...
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.13 2004/02/24 14:49:08 henning Exp $	*/
a185 10
	struct interface_info *ip;

	for (ip = interfaces; ip; ip = ip->next) {
		if_reinitialize_receive(ip);
		if_reinitialize_send(ip);
	}

	if (fallback_interface)
		if_reinitialize_send(fallback_interface);

@


1.13
log
@discover_interfaces doesn't run in multiple modes any more - kill unreachable
code, partitally server-only
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.12 2004/02/24 11:35:39 henning Exp $	*/
d6 1
a180 19
}

struct interface_info *
setup_fallback(void)
{
	fallback_interface =
		 dmalloc(sizeof(*fallback_interface), "discover_interfaces");
	if (!fallback_interface)
		error("Insufficient memory to record fallback interface.");
	memset(fallback_interface, 0, sizeof(*fallback_interface));
	strlcpy(fallback_interface->name, "fallback", IFNAMSIZ);
	fallback_interface->shared_network =
	    new_shared_network("parse_statement");
	if (!fallback_interface->shared_network)
		error("No memory for shared subnet");
	memset(fallback_interface->shared_network, 0,
	    sizeof(struct shared_network));
	fallback_interface->shared_network->name = "fallback-net";
	return (fallback_interface);
@


1.12
log
@remove ill-advised interface discovery-scan, and require an interface to be
always given.
theo agrees with removal, pb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.11 2004/02/23 20:09:02 deraadt Exp $	*/
d74 1
a74 1
discover_interfaces(int state)
a77 1
	struct subnet *subnet;
a84 1
	/* Cycle through the list of interfaces looking for IP addresses. */
a85 7
		/*
		 * See if this is the sort of interface we want to deal
		 * with.  Skip loopback, point-to-point and down
		 * interfaces, except don't skip down interfaces if
		 * we're trying to get a list of configurable
		 * interfaces.
		 */
d88 1
a88 2
		    (!(ifa->ifa_flags & IFF_UP) &&
		    state != DISCOVER_UNCONFIGURED))
a90 1
		/* See if we've seen an interface that matches this one. */
a94 4
		/*
		 * If there isn't already an interface by this name,
		 * allocate one.
		 */
a121 1
			/* Get a pointer to the address... */
a122 2

			/* We don't want the loopback interface. */
a124 6

			/*
			 * If this is the first real IP address we've
			 * found, keep a pointer to ifreq structure in
			 * which we found it.
			 */
a135 2

			/* Grab the address... */
a145 7
	/*
	 * If we're just trying to get a list of interfaces that we might
	 * be able to configure, we can quit now.
	 */
	if (state == DISCOVER_UNCONFIGURED)
		return;

a149 4
		if ((tmp->flags & INTERFACE_AUTOMATIC) &&
		    state == DISCOVER_REQUESTED)
			tmp->flags &=
			    ~(INTERFACE_AUTOMATIC | INTERFACE_REQUESTED);
a168 23

		/* We must have a subnet declaration for each interface. */
		if (!tmp->shared_network && (state == DISCOVER_SERVER)) {
			warn("No subnet declaration for %s (%s).",
			    tmp->name, inet_ntoa(foo.sin_addr));
			warn("Please write a subnet declaration in your %s",
			    "dhcpd.conf file for the");
			error("network segment to which interface %s %s",
			    tmp->name, "is attached.");
		}

		/* Find subnets that don't have valid interface
		   addresses... */
		for (subnet = (tmp->shared_network ?
		    tmp->shared_network->subnets : NULL);
		     subnet; subnet = subnet->next_sibling)
			if (!subnet->interface_address.len) {
				/* Set the interface address for this subnet
				   to the first address we found. */
				subnet->interface_address.len = 4;
				memcpy(subnet->interface_address.iabuf,
					&foo.sin_addr.s_addr, 4);
			}
@


1.11
log
@remove time_t related crud; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.10 2004/02/23 19:19:12 henning Exp $	*/
a79 1
	int ir;
a85 12
	/*
	 * If we already have a list of interfaces, and we're running as
	 * a DHCP server, the interfaces were requested.
	 */
	if (interfaces && (state == DISCOVER_SERVER ||
	    state == DISCOVER_RELAY || state == DISCOVER_REQUESTED))
		ir = 0;
	else if (state == DISCOVER_UNCONFIGURED)
		ir = INTERFACE_REQUESTED | INTERFACE_AUTOMATIC;
	else
		ir = INTERFACE_REQUESTED;

d117 1
a117 1
			tmp->flags = ir;
d188 1
a188 1
			if ((tmp->flags & INTERFACE_REQUESTED) != ir)
@


1.10
log
@remove allocation/storage/search code for subnets, shared networks, and
leases - it is server-only code.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.9 2004/02/23 18:29:33 henning Exp $	*/
d367 1
a367 1
				GET_TIME(&cur_time);
d375 1
a375 1
		GET_TIME(&cur_time);
d503 1
a503 1
add_timeout(TIME when, void (*where)(void *), void *what)
@


1.9
log
@scrap dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.8 2004/02/23 18:21:15 henning Exp $	*/
a78 1
	struct shared_network *share;
a176 34

			/* If there's a registered subnet for this address,
			   connect it together... */
			if ((subnet = find_subnet(addr))) {
				/* If this interface has multiple aliases
				   on the same subnet, ignore all but the
				   first we encounter. */
				if (!subnet->interface) {
					subnet->interface = tmp;
					subnet->interface_address = addr;
				} else if (subnet->interface != tmp)
					warn("Multiple %s %s: %s %s",
					    "interfaces match the",
					    "same subnet",
					    subnet->interface->name,
					    tmp->name);
				share = subnet->shared_network;
				if (tmp->shared_network &&
				    tmp->shared_network != share)
					warn("Interface %s matches %s",
					    tmp->name,
					    "multiple shared networks");
				else
					tmp->shared_network = share;

				if (!share->interface)
					share->interface = tmp;
				else if (share->interface != tmp)
					warn("Multiple %s %s: %s %s",
					    "interfaces match the",
					    "same shared network",
					    share->interface->name,
					    tmp->name);
			}
a499 23
}

int
locate_network(struct packet *packet)
{
	struct iaddr ia;

	/* If this came through a gateway, find the corresponding subnet... */
	if (packet->raw->giaddr.s_addr) {
		struct subnet *subnet;
		ia.len = 4;
		memcpy(ia.iabuf, &packet->raw->giaddr, 4);
		subnet = find_subnet(ia);
		if (subnet)
			packet->shared_network = subnet->shared_network;
		else
			packet->shared_network = NULL;
	} else
		packet->shared_network = packet->interface->shared_network;

	if (packet->shared_network)
		return (1);
	return (0);
@


1.8
log
@dhclient always uses bpf on openbsd no matter what, it works, and we don't
need to fallback to their raw socket code
suddenly dhclient is so fast...
pb tested and sez ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.7 2004/02/10 13:12:48 henning Exp $	*/
a83 3
#ifdef ALIAS_NAMES_PERMUTED
	char *s;
#endif
@


1.7
log
@at startup, before sending several DHCPDISCOVER and waiting ages for answers,
check the link state of the interface(s) in question and don't try on
intrfaces that for sure have no link. interfaces with unknown linkstates are
treated as if they had a link, not all drivers are capable of reporting
linkstate upstream, and for some media there is no such thing as a link state.
saves quite sme time when booting notebooks configured for dhcp without
teh cable inserted...
note that this is the not yet active copy of dhclient
ok grange@@ mcbride@@ pb@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.6 2004/02/07 11:40:17 henning Exp $	*/
a290 2

	maybe_setup_fallback();
@


1.6
log
@whitespace police
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.5 2004/02/07 11:35:59 henning Exp $	*/
d685 32
@


1.5
log
@more style fixes from Emil Mikulic <emikulic@@dmr.ath.cx>
Thank you very much for this excellent work, it helps a lot.
binary unchanged.
I am still convinced dhclient can be made readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.4 2004/02/04 12:16:56 henning Exp $	*/
d236 2
a237 2
			tmp->flags &= ~(INTERFACE_AUTOMATIC |
					  INTERFACE_REQUESTED);
d419 1
a419 1
		        struct interface_info *ip;
d513 1
a513 1
			       ifname);
d525 1
a525 1
		switch(ifmr.ifm_active & IFM_NMASK) {
@


1.4
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 4
a48 1
#include <sys/ioctl.h>
a49 1
#include <net/if_media.h>
d67 6
a72 5
/* Use getifaddrs() to get a list of all the attached interfaces.
   For each interface that's of type INET and not the loopback interface,
   register that interface with the network I/O software, figure out what
   subnet it's on, and add it to the list of interfaces. */

d89 1
a89 1
		error ("getifaddrs failed");
d91 4
a94 2
	/* If we already have a list of interfaces, and we're running as
	   a DHCP server, the interfaces were requested. */
d105 7
a111 4
		/* See if this is the sort of interface we want to
		   deal with.  Skip loopback, point-to-point and down
		   interfaces, except don't skip down interfaces if we're
		   trying to get a list of configurable interfaces. */
d117 1
a117 1
		
d120 1
a120 1
			if (!strcmp (tmp->name, ifa->ifa_name))
d123 4
a126 2
		/* If there isn't already an interface by this name,
		   allocate one. */
d128 1
a128 2
			tmp = ((struct interface_info *)
			       dmalloc (sizeof *tmp, "discover_interfaces"));
d130 3
a132 3
				error ("Insufficient memory to %s %s",
				       "record interface", ifa->ifa_name);
			strlcpy (tmp->name, ifa->ifa_name, sizeof(tmp->name));
d139 4
a142 2
		/* If we have the capability, extract link information
		   and record it in a linked list. */
d144 2
a145 2
			struct sockaddr_dl *foo = ((struct sockaddr_dl *)
						   (ifa->ifa_addr));
d150 1
a150 1
			    LLADDR (foo), foo->sdl_alen);
d158 1
a158 1
			if (foo.sin_addr.s_addr == htonl (INADDR_LOOPBACK))
d161 5
a165 3
			/* If this is the first real IP address we've
			   found, keep a pointer to ifreq structure in
			   which we found it. */
d167 2
a168 2
				int len = (IFNAMSIZ + ifa->ifa_addr->sa_len);
				tif = (struct ifreq *)malloc (len);
d191 6
a196 7
				} else if (subnet->interface != tmp) {
					warn ("Multiple %s %s: %s %s", 
					      "interfaces match the",
					      "same subnet",
					      subnet->interface->name,
					      tmp->name);
				}
d199 5
a203 5
				    tmp->shared_network != share) {
					warn ("Interface %s matches %s",
					      tmp->name,
					      "multiple shared networks");
				} else {
a204 1
				}
d206 1
a206 1
				if (!share->interface) {
d208 6
a213 7
				} else if (share->interface != tmp) {
					warn ("Multiple %s %s: %s %s", 
					      "interfaces match the",
					      "same shared network",
					      share->interface->name,
					      tmp->name);
				}
d218 4
a221 2
	/* Now cycle through all the interfaces we found, looking for
	   hardware addresses. */
d223 4
a226 2
	/* If we're just trying to get a list of interfaces that we might
	   be able to configure, we can quit now. */
d231 1
a231 1
	last = (struct interface_info *)0;
d240 1
a240 1
				error ("%s: not found", tmp->name);
d246 4
a249 2
			/* Remember the interface in case we need to know
			   about it later. */
d256 1
a256 1
		memcpy (&foo, &tmp->ifp->ifr_addr, sizeof tmp->ifp->ifr_addr);
d261 1
a261 1
			    tmp->name, inet_ntoa (foo.sin_addr));
d272 1
a272 1
		     subnet; subnet = subnet->next_sibling) {
a279 1
		}
d288 1
a288 1
		add_protocol (tmp->name, tmp->rfdesc, got_one, tmp);
d299 1
a299 1
		 dmalloc(sizeof *fallback_interface, "discover_interfaces");
d302 1
a302 1
	memset(fallback_interface, 0, sizeof *fallback_interface);
d311 1
a311 1
	return fallback_interface;
d320 2
a321 2
		if_reinitialize_receive (ip);
		if_reinitialize_send (ip);
d325 1
a325 1
		if_reinitialize_send (fallback_interface);
d330 6
a335 5
/* Wait for packets to come in using poll().  When a packet comes in,
   call receive_packet to receive the packet and possibly strip hardware
   addressing information from it, and then call through the
   bootp_packet_handler hook to try to do something with it. */

d349 1
a349 1
		++nfds;
d351 1
a351 1
	fds = malloc((nfds) * sizeof (struct pollfd));
d353 1
a353 1
		error ("Can't allocate poll structures.");
d356 4
a359 3
		/* Call any expired timeouts, and then if there's
		   still a timeout registered, time out the select
		   call then. */
d366 1
a366 1
				(*(t->func)) (t->what);
d371 1
d374 3
a376 3
			 * potential overflow, so we can cram into an int
			 * for poll, while not polling with a negative 
			 * timeout and blocking indefinetely.
a377 1

d387 1
a387 1
		
d391 4
a394 4
				fds [i].fd = l->fd;
				fds [i].events = POLLIN;
				fds [i].revents = 0;
				++i;
d398 1
a398 1
		if (i == 0) 
d400 1
a400 1
		
d402 1
a402 1
		count = poll (fds, nfds, to_msec);
d407 1
a407 1
				GET_TIME (&cur_time);
d411 1
a411 1
				error ("poll: %m");
d415 1
a415 1
		GET_TIME (&cur_time);
d421 2
a422 2
			if ((fds [i].revents & POLLIN)) {
				fds [i].revents = 0;
d425 1
a425 1
					(*(l->handler)) (l);
d429 1
a429 1
			++i;
d444 5
a448 3
		unsigned char packbuf[4095]; /* Packet input buffer.
					 	 Must be as large as largest
						 possible MTU. */
d454 2
a455 2
	    receive_packet(ip, u.packbuf, sizeof u, &from, &hfrom)) == -1) {
		warn("receive_packet failed on %s: %s", ip->name, 
d458 1
a458 1
		if ((! interface_status(ip)) ||
d462 1
a462 1
			     ip->name); 
d486 1
a486 1
	char * ifname = ifinfo->name;
d490 1
a490 1
	
d495 1
a495 2
		syslog(LOG_ERR, "ioctl(SIOCGIFFLAGS) on %s: %m",
		       ifname);
d506 1
a506 1
	if (ifinfo->noifmedia) 
d518 1
a518 1
		 * EINVAL (or ENOTTY) simply means that the interface 
d537 1
a537 1
	return(0);
d539 1
a539 1
	return(1);
d551 2
a552 2
		memcpy (ia.iabuf, &packet->raw->giaddr, 4);
		subnet = find_subnet (ia);
d556 1
a556 1
			packet->shared_network = (struct shared_network *)0;
d558 1
a558 2
		packet->shared_network =
			packet->interface->shared_network;
d561 2
a562 2
		return 1;
	return 0;
d571 1
a571 1
	t = (struct timeout *)0;
d592 1
a592 1
			q = (struct timeout *)malloc (sizeof (struct timeout));
d594 1
a594 1
				error ("Can't allocate timeout structure!");
d622 1
a622 1
	q->next = (struct timeout *)0;
d631 1
a631 1
	t = (struct timeout *)0;
d657 1
a657 1
	p = (struct protocol *)malloc (sizeof *p);
d659 1
a659 1
		error ("can't allocate protocol struct for %s", name);
d674 1
a674 1
	prev = (struct protocol *)0;
d682 1
a682 1
			free (p);
@


1.3
log
@8579 lines of KNF, ANSO and zap-junk diff without the resulting binary
changing by a single byte.
partly from theo
@
text
@d1 1
a1 1
/* dispatch.c
d3 1
a3 1
   Network input dispatcher... */
@


1.2
log
@-we don't use SIOCGIFCONF any more, we use getifaddrs(). update comment.
-we don't need the socket any more either; remove.

ok deraadt@@
@
text
@a48 1

d57 3
a59 3
void (*bootp_packet_handler) PROTO ((struct interface_info *,
				     struct dhcp_packet *, int, unsigned int,
				     struct iaddr, struct hardware *));
d70 2
a71 2
void discover_interfaces (state)
	int state;
d91 1
a91 2
			   state == DISCOVER_RELAY ||
			   state == DISCOVER_REQUESTED))
d107 1
a107 1
		     state != DISCOVER_UNCONFIGURED))
d111 2
a112 2
		for (tmp = interfaces; tmp; tmp = tmp -> next)
			if (!strcmp (tmp -> name, ifa -> ifa_name))
d122 5
a126 5
				       "record interface", ifa -> ifa_name);
			strlcpy (tmp -> name, ifa -> ifa_name, sizeof(tmp->name));
			tmp -> next = interfaces;
			tmp -> flags = ir;
			tmp -> noifmedia = tmp -> dead = tmp->errors = 0;
d132 1
a132 1
		if (ifa -> ifa_addr->sa_family == AF_LINK) {
d134 7
a140 7
						   (ifa -> ifa_addr));
			tmp -> index = foo->sdl_index;
			tmp -> hw_address.hlen = foo -> sdl_alen;
			tmp -> hw_address.htype = HTYPE_ETHER; /* XXX */
			memcpy (tmp -> hw_address.haddr,
				LLADDR (foo), foo -> sdl_alen);
		} else if (ifa -> ifa_addr->sa_family == AF_INET) {
d153 2
a154 3
			if (!tmp -> ifp) {
				int len = (IFNAMSIZ +
					   ifa -> ifa_addr->sa_len);
d157 1
a157 1
					error ("no space to remember ifp.");
d161 2
a162 2
				tmp -> ifp = tif;
				tmp -> primary_address = foo.sin_addr;
d167 1
a167 2
			memcpy (addr.iabuf, &foo.sin_addr.s_addr,
				addr.len);
d171 1
a171 1
			if ((subnet = find_subnet (addr))) {
d175 4
a178 4
				if (!subnet -> interface) {
					subnet -> interface = tmp;
					subnet -> interface_address = addr;
				} else if (subnet -> interface != tmp) {
d182 2
a183 2
					      subnet -> interface -> name,
					      tmp -> name);
d185 3
a187 3
				share = subnet -> shared_network;
				if (tmp -> shared_network &&
				    tmp -> shared_network != share) {
d189 1
a189 1
					      tmp -> name,
d192 1
a192 1
					tmp -> shared_network = share;
d195 3
a197 3
				if (!share -> interface) {
					share -> interface = tmp;
				} else if (share -> interface != tmp) {
d201 2
a202 2
					      share -> interface -> name,
					      tmp -> name);
d219 2
a220 2
		next = tmp -> next;
		if ((tmp -> flags & INTERFACE_AUTOMATIC) &&
d222 1
a222 1
			tmp -> flags &= ~(INTERFACE_AUTOMATIC |
d224 3
a226 3
		if (!tmp -> ifp || !(tmp -> flags & INTERFACE_REQUESTED)) {
			if ((tmp -> flags & INTERFACE_REQUESTED) != ir)
				error ("%s: not found", tmp -> name);
d228 1
a228 1
				interfaces = interfaces -> next;
d230 1
a230 1
				last -> next = tmp -> next;
d234 1
a234 1
			tmp -> next = dummy_interfaces;
d240 1
a240 2
		memcpy (&foo, &tmp -> ifp -> ifr_addr,
			sizeof tmp -> ifp -> ifr_addr);
d243 7
a249 7
		if (!tmp -> shared_network && (state == DISCOVER_SERVER)) {
			warn ("No subnet declaration for %s (%s).",
			      tmp -> name, inet_ntoa (foo.sin_addr));
			warn ("Please write a subnet declaration in your %s",
			      "dhcpd.conf file for the");
			error ("network segment to which interface %s %s",
			       tmp -> name, "is attached.");
d254 4
a257 5
		for (subnet = (tmp -> shared_network
			       ? tmp -> shared_network -> subnets
			       : (struct subnet *)0);
		     subnet; subnet = subnet -> next_sibling) {
			if (!subnet -> interface_address.len) {
d260 2
a261 2
				subnet -> interface_address.len = 4;
				memcpy (subnet -> interface_address.iabuf,
d267 2
a268 2
		if_register_receive (tmp);
		if_register_send (tmp);
d272 2
a273 3
	for (tmp = interfaces; tmp; tmp = tmp -> next) {
		add_protocol (tmp -> name, tmp -> rfdesc, got_one, tmp);
	}
d277 1
a277 1
	maybe_setup_fallback ();
d280 2
a281 1
struct interface_info *setup_fallback ()
d284 1
a284 2
		((struct interface_info *)
		 dmalloc (sizeof *fallback_interface, "discover_interfaces"));
d286 10
a295 10
		error ("Insufficient memory to record fallback interface.");
	memset (fallback_interface, 0, sizeof *fallback_interface);
	strlcpy (fallback_interface -> name, "fallback", IFNAMSIZ);
	fallback_interface -> shared_network =
		new_shared_network ("parse_statement");
	if (!fallback_interface -> shared_network)
		error ("No memory for shared subnet");
	memset (fallback_interface -> shared_network, 0,
		sizeof (struct shared_network));
	fallback_interface -> shared_network -> name = "fallback-net";
d299 2
a300 1
void reinitialize_interfaces ()
d304 1
a304 1
	for (ip = interfaces; ip; ip = ip -> next) {
d320 2
a321 1
void dispatch ()
d332 1
a332 1
	for (l = protocols; l; l = l -> next) {
d334 2
a335 2
	}
	fds = (struct pollfd *)malloc ((nfds) * sizeof (struct pollfd));
d343 1
a343 1
	      another:
d346 1
a346 1
			if (timeouts -> when <= cur_time) {
d348 3
a350 3
				timeouts = timeouts -> next;
				(*(t -> func)) (t -> what);
				t -> next = free_timeouts;
d361 1
a361 1
			howlong = timeouts -> when - cur_time;
d371 2
a372 2
		for (l = protocols; l; l = l -> next) {
			struct interface_info *ip = l -> local;
d374 1
a374 1
				fds [i].fd = l -> fd;
d401 1
a401 1
		for (l = protocols; l; l = l -> next) {
d408 1
a408 1
					(*(l -> handler)) (l);
d419 2
a420 2
void got_one (l)
	struct protocol *l;
d427 1
a427 1
		unsigned char packbuf [4095]; /* Packet input buffer.
d432 1
a432 1
	struct interface_info *ip = l -> local;
d435 3
a437 3
	     receive_packet (ip, u.packbuf, sizeof u, &from, &hfrom)) == -1) {
		warn ("receive_packet failed on %s: %s", ip -> name, 
		      strerror(errno));
d439 2
a440 2
		if ((! interface_status(ip)) 
		    || (ip->noifmedia && ip->errors > 20)) {
d457 1
a457 1
		memcpy (ifrom.iabuf, &from.sin_addr, ifrom.len);
d459 2
a460 2
		(*bootp_packet_handler) (ip, &u.packet, result,
					 from.sin_port, ifrom, &hfrom);
d518 1
a518 1
 inactive:
d520 1
a520 1
 active:
d524 2
a525 2
int locate_network (packet)
	struct packet *packet;
d530 1
a530 1
	if (packet -> raw -> giaddr.s_addr) {
d533 1
a533 1
		memcpy (ia.iabuf, &packet -> raw -> giaddr, 4);
d536 1
a536 1
			packet -> shared_network = subnet -> shared_network;
d538 6
a543 6
			packet -> shared_network = (struct shared_network *)0;
	} else {
		packet -> shared_network =
			packet -> interface -> shared_network;
	}
	if (packet -> shared_network)
d548 2
a549 4
void add_timeout (when, where, what)
	TIME when;
	void (*where) PROTO ((void *));
	void *what;
d555 2
a556 2
	for (q = timeouts; q; q = q -> next) {
		if (q -> func == where && q -> what == what) {
d558 1
a558 1
				t -> next = q -> next;
d560 1
a560 1
				timeouts = q -> next;
d571 3
a573 3
			free_timeouts = q -> next;
			q -> func = where;
			q -> what = what;
d578 2
a579 2
			q -> func = where;
			q -> what = what;
d583 1
a583 1
	q -> when = when;
d588 2
a589 2
	if (!timeouts || timeouts -> when > q -> when) {
		q -> next = timeouts;
d595 4
a598 4
	for (t = timeouts; t -> next; t = t -> next) {
		if (t -> next -> when > q -> when) {
			q -> next = t -> next;
			t -> next = q;
d604 2
a605 2
	t -> next = q;
	q -> next = (struct timeout *)0;
d608 2
a609 3
void cancel_timeout (where, what)
	void (*where) PROTO ((void *));
	void *what;
d615 2
a616 2
	for (q = timeouts; q; q = q -> next) {
		if (q -> func == where && q -> what == what) {
d618 1
a618 1
				t -> next = q -> next;
d620 1
a620 1
				timeouts = q -> next;
d628 1
a628 1
		q -> next = free_timeouts;
d634 3
a636 5
void add_protocol (name, fd, handler, local)
	char *name;
	int fd;
	void (*handler) PROTO ((struct protocol *));
	void *local;
d644 3
a646 3
	p -> fd = fd;
	p -> handler = handler;
	p -> local = local;
d648 1
a648 1
	p -> next = protocols;
d652 2
a653 2
void remove_protocol (proto)
	struct protocol *proto;
d659 1
a659 1
		next = p -> next;
d662 1
a662 1
				prev -> next = p -> next;
d664 1
a664 1
				protocols = p -> next;
@


1.1
log
@this is where dhclient will start surgery
@
text
@d66 1
a66 1
/* Use the SIOCGIFCONF ioctl to get a list of all the attached interfaces.
a75 1
	int sock;
a85 4
	/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on. */
	if ((sock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		error ("Can't create addrlist socket");

a281 1
	close (sock);
@

