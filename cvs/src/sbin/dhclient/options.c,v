head	1.95;
access;
symbols
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.75.0.6
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.73.0.6
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.41.0.4
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.37.0.8
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.6
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.8
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.6
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.95
date	2017.07.07.16.58.45;	author krw;	state Exp;
branches;
next	1.94;
commitid	SZpYrtXCWLHh9BMf;

1.94
date	2017.07.07.14.53.07;	author krw;	state Exp;
branches;
next	1.93;
commitid	9W4HKbFTwzuS5o2J;

1.93
date	2017.07.06.16.56.52;	author krw;	state Exp;
branches;
next	1.92;
commitid	gkJDzWHD0LTQO3CJ;

1.92
date	2017.06.15.17.06.17;	author krw;	state Exp;
branches;
next	1.91;
commitid	3Bd8xw2tLnMI6fM7;

1.91
date	2017.06.14.16.09.42;	author krw;	state Exp;
branches;
next	1.90;
commitid	d5OX3PwMWtaAMnZV;

1.90
date	2017.06.14.15.57.25;	author krw;	state Exp;
branches;
next	1.89;
commitid	xleVcb5KQcOBndeE;

1.89
date	2017.06.13.15.49.32;	author krw;	state Exp;
branches;
next	1.88;
commitid	OYT2CturRpIwAbZo;

1.88
date	2017.04.09.20.44.13;	author krw;	state Exp;
branches;
next	1.87;
commitid	Qbefa1v9yY6ObGzy;

1.87
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.86;
commitid	KIdulj0iLtM6kXff;

1.86
date	2017.04.08.18.54.52;	author krw;	state Exp;
branches;
next	1.85;
commitid	8EYpknlzUTHDPTPW;

1.85
date	2017.04.08.17.00.10;	author krw;	state Exp;
branches;
next	1.84;
commitid	NmYVWunprpEm8q1k;

1.84
date	2017.04.07.15.03.01;	author krw;	state Exp;
branches;
next	1.83;
commitid	IJyiLQCmbwzmKm5U;

1.83
date	2017.03.26.21.33.36;	author krw;	state Exp;
branches;
next	1.82;
commitid	xX3gvwIAiPMUf8qC;

1.82
date	2017.03.08.14.19.00;	author krw;	state Exp;
branches;
next	1.81;
commitid	H8xvWxW8Df1Sly9w;

1.81
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.80;
commitid	WchZmaQT4LJ4im5M;

1.80
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.79;
commitid	IDlzr3qamZK5lxzj;

1.79
date	2016.10.06.16.29.17;	author krw;	state Exp;
branches;
next	1.78;
commitid	dTOGnqxN6bqeD6hy;

1.78
date	2016.09.02.15.44.26;	author mpi;	state Exp;
branches;
next	1.77;
commitid	GuoxNV4NXpbUVBHj;

1.77
date	2016.08.31.12.57.31;	author mpi;	state Exp;
branches;
next	1.76;
commitid	dRGzj71S05fFJodM;

1.76
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.75;
commitid	Tm7CrlqCKqgQoJ7P;

1.75
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.74;
commitid	5ELOU0S0Zl3aCrHG;

1.74
date	2015.10.26.16.32.33;	author krw;	state Exp;
branches;
next	1.73;
commitid	Y03Zu0zFPhi0Triz;

1.73
date	2014.10.27.17.01.28;	author krw;	state Exp;
branches;
next	1.72;
commitid	Yg7bk47z8kd8w06x;

1.72
date	2014.10.27.14.17.01;	author krw;	state Exp;
branches;
next	1.71;
commitid	ndH3javkN8mxgcQ6;

1.71
date	2014.10.27.13.36.21;	author krw;	state Exp;
branches;
next	1.70;
commitid	18JJKpLCJZeJyulS;

1.70
date	2014.07.28.16.45.35;	author tobias;	state Exp;
branches;
next	1.69;
commitid	WPRdWQrx6O0hbxVT;

1.69
date	2014.07.09.12.55.31;	author krw;	state Exp;
branches;
next	1.68;
commitid	sX43W7Hz9oMoboPT;

1.68
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.21.03.07.50;	author krw;	state Exp;
branches
	1.67.4.1;
next	1.66;

1.66
date	2014.01.19.21.10.04;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2013.12.30.03.36.17;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2013.12.22.04.47.57;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2013.12.22.03.20.05;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.21.18.23.10;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2013.12.18.00.37.59;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.14.16.06.42;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.12.13.22.37;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.12.01.40.35;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2013.07.11.01.34.00;	author krw;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2013.07.07.00.04.58;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2013.07.06.03.03.23;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2013.04.05.19.19.05;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2013.02.14.20.39.46;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2013.01.16.21.35.41;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2013.01.16.11.02.10;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.16.06.11.21;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.13.22.50.33;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.13.22.09.38;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.07.15.20.28;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2012.10.27.23.08.53;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2012.06.26.14.46.42;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2012.06.26.14.36.11;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.11.14.38.36;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.17.19.57.23;	author phessler;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.10.23.19.36;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.02.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.31.23.24.15;	author pvalchev;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.14.23.19.26;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.25.01.21.04;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.16.20.22.20;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.14.01.35.46;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.11.00.04.48;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.06.23.21.08;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.04.22.17.48;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.15.14.09.13;	author stevesk;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.22.20.30.52;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.16.16.31.05;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.15.10.40.27;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.13.23.33.04;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.13.23.25.55;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.09.14.36.16;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.08.14.15.23;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.08.00.57.36;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.07.20.03.40;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.07.16.24.24;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.26.03.17.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.02.01.18.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.21.04.07.04;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.15.18.15.18;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.06.22.29.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.14.20.22.27;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.02.18.49.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.24.17.02.40;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.13.59.45;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.13.26.35;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.06.11.33.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;

1.56.2.1
date	2014.07.29.18.23.07;	author tobias;	state Exp;
branches;
next	;
commitid	1AkdeqSw4ibPIUNI;

1.67.4.1
date	2014.07.29.18.21.30;	author tobias;	state Exp;
branches;
next	;
commitid	oaTl3MejDkG0oN5W;


desc
@@


1.95
log
@Replace the many occurances of '256' with a new #define
DHO_COUNT.
@
text
@/*	$OpenBSD: options.c,v 1.94 2017/07/07 14:53:07 krw Exp $	*/

/* DHCP options parsing and reassembly. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/queue.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <ctype.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vis.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"

int parse_option_buffer(struct option_data *, unsigned char *, int);
int expand_search_domain_name(unsigned char *, size_t, int *, unsigned char *);

/*
 * Parse options out of the specified buffer, storing addresses of
 * option values in options. Return 0 if errors, 1 if not.
 */
int
parse_option_buffer(struct option_data *options, unsigned char *buffer,
    int length)
{
	unsigned char *s, *t, *end = buffer + length;
	int len, code;

	for (s = buffer; *s != DHO_END && s < end; ) {
		code = s[0];

		/* Pad options don't have a length - just skip them. */
		if (code == DHO_PAD) {
			s++;
			continue;
		}

		/*
		 * All options other than DHO_PAD and DHO_END have a one-byte
		 * length field. It could be 0! Make sure that the length byte
		 * is present, and all the data is available.
		 */
		if (s + 1 < end) {
			len = s[1];
			if (s + 1 + len < end) {
				; /* option data is all there. */
			} else {
				log_warnx("option %s (%d) larger than buffer.",
				    dhcp_options[code].name, len);
				return (0);
			}
		} else {
			log_warnx("option %s has no length field.",
			    dhcp_options[code].name);
			return (0);
		}

		/*
		 * Strip trailing NULs from ascii ('t') options. They
		 * will be treated as DHO_PAD options. i.e. ignored. RFC 2132
		 * says "Options containing NVT ASCII data SHOULD NOT include
		 * a trailing NULL; however, the receiver of such options
		 * MUST be prepared to delete trailing nulls if they exist."
		 */
		if (dhcp_options[code].format[0] == 't') {
			while (len > 0 && s[len + 1] == '\0')
				len--;
		}

		/*
		 * If we haven't seen this option before, just make
		 * space for it and copy it there.
		 */
		if (!options[code].data) {
			if (!(t = calloc(1, len + 1)))
				fatalx("Can't allocate storage for option %s.",
				    dhcp_options[code].name);
			/*
			 * Copy and NUL-terminate the option (in case
			 * it's an ASCII string).
			 */
			memcpy(t, &s[2], len);
			t[len] = 0;
			options[code].len = len;
			options[code].data = t;
		} else {
			/*
			 * If it's a repeat, concatenate it to whatever
			 * we last saw.
			 */
			t = calloc(1, len + options[code].len + 1);
			if (!t)
				fatalx("Can't expand storage for option %s.",
				    dhcp_options[code].name);
			memcpy(t, options[code].data, options[code].len);
			memcpy(t + options[code].len, &s[2], len);
			options[code].len += len;
			t[options[code].len] = 0;
			free(options[code].data);
			options[code].data = t;
		}
		s += len + 2;
	}

	return (1);
}

/*
 * Pack as many options as fit in buflen bytes of buf. Return the
 * offset of the start of the last option copied. A caller can check
 * to see if it's DHO_END to decide if all the options were copied.
 */
int
pack_options(unsigned char *buf, int buflen, struct option_data *options)
{
	int ix, incr, length, bufix, code, lastopt = -1;

	memset(buf, 0, buflen);

	memcpy(buf, DHCP_OPTIONS_COOKIE, 4);
	if (options[DHO_DHCP_MESSAGE_TYPE].data) {
		memcpy(&buf[4], DHCP_OPTIONS_MESSAGE_TYPE, 3);
		buf[6] = options[DHO_DHCP_MESSAGE_TYPE].data[0];
		bufix = 7;
	} else
		bufix = 4;

	for (code = DHO_SUBNET_MASK; code < DHO_END; code++) {
		if (!options[code].data || code == DHO_DHCP_MESSAGE_TYPE)
			continue;

		length = options[code].len;
		if (bufix + length + 2*((length+254)/255) >= buflen)
			return (lastopt);

		lastopt = bufix;
		ix = 0;

		while (length) {
			incr = length > 255 ? 255 : length;

			buf[bufix++] = code;
			buf[bufix++] = incr;
			memcpy(buf + bufix, options[code].data + ix, incr);

			length -= incr;
			ix += incr;
			bufix += incr;
		}
	}

	if (bufix < buflen) {
		buf[bufix] = DHO_END;
		lastopt = bufix;
	}

	return (lastopt);
}

/*
 * Use vis() to encode characters of src and append encoded characters onto
 * dst. Also encode ", ', $, ` and \, to ensure resulting strings can be
 * represented as '"' delimited strings and safely passed to scripts. Surround
 * result with double quotes if emit_punct is true.
 */
char *
pretty_print_string(unsigned char *src, size_t srclen, int emit_punct)
{
	static char string[8196];
	char visbuf[5];
	unsigned char *origsrc = src;
	size_t rslt = 0;

	memset(string, 0, sizeof(string));

	if (emit_punct)
		rslt = strlcat(string, "\"", sizeof(string));

	for (; src < origsrc + srclen; src++) {
		if (*src && strchr("\"'$`\\", *src))
			vis(visbuf, *src, VIS_ALL | VIS_OCTAL, *src+1);
		else
			vis(visbuf, *src, VIS_OCTAL, *src+1);
		rslt = strlcat(string, visbuf, sizeof(string));
	}

	if (emit_punct)
		rslt = strlcat(string, "\"", sizeof(string));

	if (rslt >= sizeof(string))
		return (NULL);

	return (string);
}

/*
 * Must special case *_CLASSLESS_* route options due to the variable size
 * of the CIDR element in its CIA format.
 */
char *
pretty_print_classless_routes(unsigned char *src, size_t srclen)
{
	static char string[8196];
	char bitsbuf[5];	/* to hold "/nn " */
	struct in_addr net, gateway;
	unsigned int bytes;
	int bits, rslt;

	memset(string, 0, sizeof(string));

	while (srclen) {
		bits = *src;
		src++;
		srclen--;

		bytes = (bits + 7) / 8;
		if (srclen < (bytes + sizeof(gateway.s_addr)) ||
		    bytes > sizeof(net.s_addr))
			return (NULL);
		rslt = snprintf(bitsbuf, sizeof(bitsbuf), "/%d ", bits);
		if (rslt == -1 || (unsigned int)rslt >= sizeof(bitsbuf))
			return (NULL);

		memset(&net, 0, sizeof(net));
		memcpy(&net.s_addr, src, bytes);
		src += bytes;
		srclen -= bytes;

		memcpy(&gateway.s_addr, src, sizeof(gateway.s_addr));
		src += sizeof(gateway.s_addr);
		srclen -= sizeof(gateway.s_addr);

		if (strlen(string) > 0)
			strlcat(string, ", ", sizeof(string));
		strlcat(string, inet_ntoa(net), sizeof(string));
		strlcat(string, bitsbuf, sizeof(string));
		if (strlcat(string, inet_ntoa(gateway), sizeof(string)) >=
		    sizeof(string))
			return (NULL);
	}

	return (string);
}

int
expand_search_domain_name(unsigned char *src, size_t srclen, int *offset,
    unsigned char *domain_search)
{
	unsigned int i;
	int domain_name_len, label_len, pointer, pointed_len;
	char *cursor;

	cursor = domain_search + strlen(domain_search);
	domain_name_len = 0;

	i = *offset;
	while (i <= srclen) {
		label_len = src[i];
		if (label_len == 0) {
			/*
			 * A zero-length label marks the end of this
			 * domain name.
			 */
			*offset = i + 1;
			return (domain_name_len);
		} else if (label_len & 0xC0) {
			/* This is a pointer to another list of labels. */
			if (i + 1 >= srclen) {
				/* The pointer is truncated. */
				log_warnx("Truncated pointer in DHCP Domain "
				    "Search option.");
				return (-1);
			}

			pointer = ((label_len & ~(0xC0)) << 8) + src[i + 1];
			if (pointer >= *offset) {
				/*
				 * The pointer must indicates a prior
				 * occurance.
				 */
				log_warnx("Invalid forward pointer in DHCP "
				    "Domain Search option compression.");
				return (-1);
			}

			pointed_len = expand_search_domain_name(src, srclen,
			    &pointer, domain_search);
			domain_name_len += pointed_len;

			*offset = i + 2;
			return (domain_name_len);
		}
		if (i + label_len + 1 > srclen) {
			log_warnx("Truncated label in DHCP Domain Search "
			    "option.");
			return (-1);
		}
		/*
		 * Update the domain name length with the length of the
		 * current label, plus a trailing dot ('.').
		 */
		domain_name_len += label_len + 1;

		if (strlen(domain_search) + domain_name_len >=
		    DHCP_DOMAIN_SEARCH_LEN) {
			log_warnx("Domain search list too long.");
			return (-1);
		}

		/* Copy the label found. */
		memcpy(cursor, src + i + 1, label_len);
		cursor[label_len] = '.';

		/* Move cursor. */
		i += label_len + 1;
		cursor += label_len + 1;
	}

	log_warnx("Truncated DHCP Domain Search option.");

	return (-1);
}

/*
 * Must special case DHO_DOMAIN_SEARCH because it is encoded as described
 * in RFC 1035 section 4.1.4.
 */
char *
pretty_print_domain_search(unsigned char *src, size_t srclen)
{
	static char domain_search[DHCP_DOMAIN_SEARCH_LEN];
	unsigned int offset;
	int len, expanded_len, domains;
	unsigned char *cursor;

	memset(domain_search, 0, sizeof(domain_search));

	/* Compute expanded length. */
	expanded_len = len = 0;
	domains = 0;
	offset = 0;
	while (offset < srclen) {
		cursor = domain_search + strlen(domain_search);
		if (domain_search[0]) {
			*cursor = ' ';
			expanded_len++;
		}
		len = expand_search_domain_name(src, srclen, &offset,
		    domain_search);
		if (len == -1)
			return (NULL);
		domains++;
		expanded_len += len;
		if (domains > DHCP_DOMAIN_SEARCH_CNT)
			return (NULL);
	}

	return (domain_search);
}

/*
 * Format the specified option so that a human can easily read it.
 */
char *
pretty_print_option(unsigned int code, struct option_data *option,
    int emit_punct)
{
	static char optbuf[8192]; /* XXX */
	int hunksize = 0, numhunk = -1, numelem = 0;
	char fmtbuf[32], *op = optbuf, *buf;
	int i, j, k, opleft = sizeof(optbuf);
	unsigned char *data = option->data;
	unsigned char *dp = data;
	int len = option->len;
	int opcount = 0;
	struct in_addr foo;
	char comma;
	int32_t int32val;
	u_int32_t uint32val;
	u_int16_t uint16val;

	memset(optbuf, 0, sizeof(optbuf));

	/* Code should be between 0 and 255. */
	if (code > 255) {
		log_warnx("pretty_print_option: bad code %d", code);
		goto done;
	}

	if (emit_punct)
		comma = ',';
	else
		comma = ' ';

	/* Handle the princess class options with weirdo formats. */
	switch (code) {
	case DHO_CLASSLESS_STATIC_ROUTES:
	case DHO_CLASSLESS_MS_STATIC_ROUTES:
		buf = pretty_print_classless_routes(dp, len);
		if (buf == NULL)
			goto toobig;
		strlcat(optbuf, buf, sizeof(optbuf));
		goto done;
	default:
		break;
	}

	/* Figure out the size of the data. */
	for (i = 0; dhcp_options[code].format[i]; i++) {
		if (!numhunk) {
			log_warnx("%s: Excess information in format string: "
			    "%s", dhcp_options[code].name,
			    &(dhcp_options[code].format[i]));
			goto done;
		}
		numelem++;
		fmtbuf[i] = dhcp_options[code].format[i];
		switch (dhcp_options[code].format[i]) {
		case 'A':
			--numelem;
			fmtbuf[i] = 0;
			numhunk = 0;
			if (hunksize == 0) {
				log_warnx("%s: no size indicator before A"
				    " in format string: %s",
				    dhcp_options[code].name,
				    dhcp_options[code].format);
				goto done;
			}
			break;
		case 'X':
			for (k = 0; k < len; k++)
				if (!isascii(data[k]) ||
				    !isprint(data[k]))
					break;
			if (k == len) {
				fmtbuf[i] = 't';
				numhunk = -2;
			} else {
				hunksize++;
				comma = ':';
				numhunk = 0;
			}
			fmtbuf[i + 1] = 0;
			break;
		case 't':
			fmtbuf[i + 1] = 0;
			numhunk = -2;
			break;
		case 'I':
		case 'l':
		case 'L':
			hunksize += 4;
			break;
		case 'S':
			hunksize += 2;
			break;
		case 'B':
		case 'f':
			hunksize++;
			break;
		case 'e':
			break;
		default:
			log_warnx("%s: garbage in format string: %s",
			    dhcp_options[code].name,
			    &(dhcp_options[code].format[i]));
			goto done;
		}
	}

	/* Check for too few bytes. */
	if (hunksize > len) {
		log_warnx("%s: expecting at least %d bytes; got %d",
		    dhcp_options[code].name, hunksize, len);
		goto done;
	}
	/* Check for too many bytes. */
	if (numhunk == -1 && hunksize < len) {
		log_warnx("%s: expecting only %d bytes: got %d",
		    dhcp_options[code].name, hunksize, len);
		goto done;
	}

	/* If this is an array, compute its size. */
	if (!numhunk)
		numhunk = len / hunksize;
	/* See if we got an exact number of hunks. */
	if (numhunk > 0 && numhunk * hunksize != len) {
		log_warnx("%s: expecting %d bytes: got %d",
		    dhcp_options[code].name, numhunk * hunksize, len);
		goto done;
	}

	/* A one-hunk array prints the same as a single hunk. */
	if (numhunk < 0)
		numhunk = 1;

	/* Cycle through the array (or hunk) printing the data. */
	for (i = 0; i < numhunk; i++) {
		for (j = 0; j < numelem; j++) {
			switch (fmtbuf[j]) {
			case 't':
				buf = pretty_print_string(dp, len, emit_punct);
				if (buf == NULL)
					opcount = -1;
				else
					opcount = strlcat(op, buf, opleft);
				break;
			case 'I':
				memcpy(&foo.s_addr, dp, sizeof(foo.s_addr));
				opcount = snprintf(op, opleft, "%s",
				    inet_ntoa(foo));
				dp += sizeof(foo.s_addr);
				break;
			case 'l':
				memcpy(&int32val, dp, sizeof(int32val));
				opcount = snprintf(op, opleft, "%d",
				    ntohl(int32val));
				dp += sizeof(int32val);
				break;
			case 'L':
				memcpy(&uint32val, dp, sizeof(uint32val));
				opcount = snprintf(op, opleft, "%u",
				    ntohl(uint32val));
				dp += sizeof(uint32val);
				break;
			case 'S':
				memcpy(&uint16val, dp, sizeof(uint16val));
				opcount = snprintf(op, opleft, "%hu",
				    ntohs(uint16val));
				dp += sizeof(uint16val);
				break;
			case 'B':
				opcount = snprintf(op, opleft, "%u", *dp);
				dp++;
				break;
			case 'X':
				opcount = snprintf(op, opleft, "%x", *dp);
				dp++;
				break;
			case 'f':
				opcount = snprintf(op, opleft, "%s",
				    *dp ? "true" : "false");
				dp++;
				break;
			default:
				log_warnx("Unexpected format code %c",
				    fmtbuf[j]);
				goto toobig;
			}
			if (opcount >= opleft || opcount == -1)
				goto toobig;
			opleft -= opcount;
			op += opcount;
			if (j + 1 < numelem && comma != ':') {
				opcount = snprintf(op, opleft, " ");
				if (opcount >= opleft || opcount == -1)
					goto toobig;
				opleft -= opcount;
				op += opcount;
			}
		}
		if (i + 1 < numhunk) {
			opcount = snprintf(op, opleft, "%c", comma);
			if (opcount >= opleft || opcount == -1)
				goto toobig;
			opleft -= opcount;
			op += opcount;
		}
	}

done:
	return (optbuf);

toobig:
	memset(optbuf, 0, sizeof(optbuf));
	return (optbuf);
}

struct option_data *
unpack_options(struct dhcp_packet *packet)
{
	static struct option_data options[DHO_COUNT];
	int i;

	for (i = 0; i < DHO_COUNT; i++) {
		free(options[i].data);
		options[i].data = NULL;
		options[i].len = 0;
	}

	if (memcmp(&packet->options, DHCP_OPTIONS_COOKIE, 4) == 0) {
		/* Parse the BOOTP/DHCP options field. */
		parse_option_buffer(options, &packet->options[4],
		    sizeof(packet->options) - 4);

		/* DHCP packets can also use overload areas for options. */
		if (options[DHO_DHCP_MESSAGE_TYPE].data &&
		    options[DHO_DHCP_OPTION_OVERLOAD].data) {
			if (options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)
				parse_option_buffer(options,
				    (unsigned char *)packet->file,
				    sizeof(packet->file));
			if (options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)
				parse_option_buffer(options,
				    (unsigned char *)packet->sname,
				    sizeof(packet->sname));
		}
	}

	return options;
}
@


1.94
log
@Rename cons_options() to pack_options(), and do_packet() to
unpack_options(). Store the unpacked options in a static
variable. Move remaining raw packet processing from unpack_options()
to packethandler().

No more struct interface_info knowledge in options.c
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.93 2017/07/06 16:56:52 krw Exp $	*/
d633 1
a633 1
	static struct option_data options[256];
d636 1
a636 1
	for (i = 0; i < 256; i++) {
@


1.93
log
@cons_options() only needs to know a buffer and a length to
pack options into. Not all the gory details of interface_info.

Move some of the raw packet processing out of options.c's
do_packet() and into the more obvious dispatch.c's
packethandler().

Mention that RFC791 is why we use 576-byte UDP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.92 2017/06/15 17:06:17 krw Exp $	*/
d158 1
a158 1
 * Copy as many options as fit in buflen bytes of buf. Return the
d163 1
a163 1
cons_options(unsigned char *buf, int buflen, struct option_data *options)
d630 2
a631 3
void
do_packet(struct interface_info *ifi, unsigned int from_port,
    struct in_addr from, struct ether_addr *hfrom)
d633 2
a634 5
	struct dhcp_packet *packet = &ifi->recv_packet;
	struct option_data options[256];
	void (*handler)(struct interface_info *, struct option_data *, char *);
	char *type, *info;
	int i, rslt, options_valid = 1;
d636 5
a640 1
	memset(options, 0, sizeof(options));
d644 2
a645 2
		options_valid = parse_option_buffer(options,
		    &packet->options[4], sizeof(packet->options) - 4);
d647 2
a648 3
		/* Only DHCP packets have overload areas for options. */
		if (options_valid &&
		    options[DHO_DHCP_MESSAGE_TYPE].data &&
d651 1
a651 1
				options_valid = parse_option_buffer(options,
d654 2
a655 3
			if (options_valid &&
			    options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)
				options_valid = parse_option_buffer(options,
a658 16

		/*
		 * RFC 6842 says if the server sends a client identifier
		 * that doesn't match then the packet must be dropped.
		 */
		i = DHO_DHCP_CLIENT_IDENTIFIER;
		if ((options[i].len != 0) &&
		    ((options[i].len != config->send_options[i].len) ||
		    memcmp(options[i].data, config->send_options[i].data,
		    options[i].len) != 0)) {
#ifdef DEBUG
			log_debug("Discarding packet with client-identifier "
			    "'%s'", pretty_print_option(i, &options[i], 0));
#endif	/* DEBUG */
			goto done;
		}
d661 1
a661 47
	type = "<unknown>";
	handler = NULL;

	if (options[DHO_DHCP_MESSAGE_TYPE].data) {
		/* Always try a DHCP packet, even if a bad option was seen. */
		switch (options[DHO_DHCP_MESSAGE_TYPE].data[0]) {
		case DHCPOFFER:
			handler = dhcpoffer;
			type = "DHCPOFFER";
			break;
		case DHCPNAK:
			handler = dhcpnak;
			type = "DHCPNACK";
			break;
		case DHCPACK:
			handler = dhcpack;
			type = "DHCPACK";
			break;
		default:
#ifdef DEBUG
			log_debug("Discarding DHCP packet of unknown type "
			    "(%d)", options[DHO_DHCP_MESSAGE_TYPE].data[0]);
#endif	/* DEBUG */
			break;
		}
	} else if (options_valid && packet->op == BOOTREPLY) {
		handler = dhcpoffer;
		type = "BOOTREPLY";
	} else {
#ifdef DEBUG
		log_debug("Discarding packet which is neither DHCP nor BOOTP");
#endif	/* DEBUG */
	}

	rslt = asprintf(&info, "%s from %s (%s)", type, inet_ntoa(from),
	    ether_ntoa(hfrom));
	if (rslt == -1)
		fatalx("no memory for info string");

	if (handler)
		(*handler)(ifi, options, info);

	free(info);

done:
	for (i = 0; i < 256; i++)
		free(options[i].data);
@


1.92
log
@Nuke unused parameter 'client_addr' from the 'handlers', i.e.
dhcpoffer(), dhcpack(), dhcpnak().
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.91 2017/06/14 16:09:42 krw Exp $	*/
d163 1
a163 1
cons_options(struct interface_info *ifi, struct option_data *options)
a164 2
	unsigned char *buf = ifi->sent_packet.options;
	int buflen = 576 - DHCP_FIXED_LEN;
a635 1
	struct reject_elem *ap;
a638 33

	if (packet->hlen != ETHER_ADDR_LEN) {
#ifdef DEBUG
		log_debug("Discarding packet with hlen != %s (%u)",
		    ifi->name, packet->hlen);
#endif	/* DEBUG */
		return;
	} else if (memcmp(&ifi->hw_address, packet->chaddr,
	    sizeof(ifi->hw_address))) {
#ifdef DEBUG
		log_debug("Discarding packet with chaddr != %s (%s)",
		    ifi->name,
		    ether_ntoa((struct ether_addr *)packet->chaddr));
#endif	/* DEBUG */
		return;
	}

	if (ifi->xid != packet->xid) {
#ifdef DEBUG
		log_debug("Discarding packet with XID != %u (%u)", ifi->xid,
		    packet->xid);
#endif	/* DEBUG */
		return;
	}

	TAILQ_FOREACH(ap, &config->reject_list, next)
		if (from.s_addr == ap->addr.s_addr) {
#ifdef DEBUG
			log_debug("Discarding packet from address on reject "
			    "list (%s)", inet_ntoa(from));
#endif	/* DEBUG */
			return;
		}
@


1.91
log
@Move xid, secs, first_sending, startup_time fields from
client_state to interface_info.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.90 2017/06/14 15:57:25 krw Exp $	*/
d639 1
a639 2
	void (*handler)(struct interface_info *, struct in_addr,
	    struct option_data *, char *);
d755 1
a755 1
		(*handler)(ifi, from, options, info);
@


1.90
log
@Start consolidating client_state into interface_info. First
fields to move: recv_packet, sent_packet and sent_packet_length.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.89 2017/06/13 15:49:32 krw Exp $	*/
a635 1
	struct client_state *client = ifi->client;
d660 1
a660 1
	if (client->xid != packet->xid) {
d662 1
a662 1
		log_debug("Discarding packet with XID != %u (%u)", client->xid,
@


1.89
log
@Rename 'packet' field to 'recv_packet' and 'bootrequest_packet'
field to 'sent_packet'. Also 'bootrequest_packet_length' to
'sent_packet_length'.

Adopt consistent idiom of a local variable 'packet' to point at
packet being manipulated.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.88 2017/04/09 20:44:13 krw Exp $	*/
d165 1
a165 2
	struct client_state *client = ifi->client;
	unsigned char *buf = client->sent_packet.options;
d637 1
a637 1
	struct dhcp_packet *packet = &client->recv_packet;
@


1.88
log
@Seven casts, a couple of tweaks and CFLAGS+=-Wsign-compare for the
win.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.87 2017/04/08 20:16:04 krw Exp $	*/
d166 1
a166 1
	unsigned char *buf = client->bootrequest_packet.options;
d638 1
a638 1
	struct dhcp_packet *packet = &client->packet;
d662 1
a662 1
	if (client->xid != client->packet.xid) {
d665 1
a665 1
		    client->packet.xid);
@


1.87
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.86 2017/04/08 18:54:52 krw Exp $	*/
d273 1
a273 1
		if (rslt == -1 || rslt >= sizeof(bitsbuf))
d289 2
a290 2
		rslt = strlcat(string, inet_ntoa(gateway), sizeof(string));
		if (rslt >= sizeof(string))
@


1.86
log
@Replace another snprintf() dance with easier to read code using
strlcat(). Shorter, clearer, fewer signed vs unsigned questions.

Use an 8K static buffer for pretty_print_classless() and use it
rather scribbling intermediate values into the final destination.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.85 2017/04/08 17:00:10 krw Exp $	*/
d258 2
a259 1
	int bits, bytes, rslt;
d301 2
a302 1
	int domain_name_len, i, label_len, pointer, pointed_len;
d384 2
a385 1
	int offset, len, expanded_len, domains;
@


1.85
log
@Replace a mess of snprintf() dances with easier to read code using
strlcat(). Shorter, clearer, fewer signed vs unsigned questions.

Shrink static buffer for the string version of an option value from
32K to 8K. Since the string version of the entire lease is constructed
in a 8K buffer, bigger option values are pointless.

Use 8K of the saved space for a static buffer for pretty_print_string()
and use it rather scribbling intermediate values into the final
destination.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.84 2017/04/07 15:03:01 krw Exp $	*/
d252 2
a253 3
int
pretty_print_classless_routes(unsigned char *dst, size_t dstlen,
    unsigned char *src, size_t srclen)
d255 4
a258 3
	struct in_addr mask, gateway;
	int opcount = 0, total = 0, bits, bytes;
	char ntoabuf[INET_ADDRSTRLEN];
d260 3
a262 1
	while (srclen && dstlen) {
d266 1
d268 9
a276 4
		if (srclen < bytes || bytes > sizeof(mask.s_addr))
			break;
		memset(&mask, 0, sizeof(mask));
		memcpy(&mask.s_addr, src, bytes);
d279 1
a279 3
		strlcpy(ntoabuf, inet_ntoa(mask), sizeof(ntoabuf));
		if (srclen < sizeof(gateway.s_addr))
			break;
d283 8
a290 10
		opcount = snprintf(dst, dstlen, "%s%s/%u %s",
		    total ? ", " : "", ntoabuf, bits,
		    inet_ntoa(gateway));
		if (opcount == -1)
			return (-1);
		total += opcount;
		if (opcount >= dstlen)
			break;
		dst += opcount;
		dstlen -= opcount;
d293 1
a293 1
	return (total);
d448 2
a449 2
		opcount = pretty_print_classless_routes(op, opleft, dp, len);
		if (opcount >= opleft || opcount == -1)
d451 1
@


1.84
log
@Simply decoding of domain search option. No intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.83 2017/03/26 21:33:36 krw Exp $	*/
d218 2
a219 3
int
pretty_print_string(unsigned char *dst, size_t dstlen, unsigned char *src,
    size_t srclen, int emit_punct)
d221 1
d224 1
a224 1
	int opcount = 0, total = 0;
d226 4
a229 10
	if (emit_punct) {
		opcount = snprintf(dst, dstlen, "\"");
		if (opcount == -1)
			return (-1);
		total += opcount;
		if (opcount >= dstlen)
			goto done;
		dstlen -= opcount;
		dst += opcount;
	}
d236 1
a236 8
		opcount = snprintf(dst, dstlen, "%s", visbuf);
		if (opcount == -1)
			return (-1);
		total += opcount;
		if (opcount >= dstlen)
			goto done;
		dstlen -= opcount;
		dst += opcount;
d239 7
a245 12
	if (emit_punct) {
		opcount = snprintf(dst, dstlen, "\"");
		if (opcount == -1)
			return (-1);
		total += opcount;
		if (opcount >= dstlen)
			goto done;
		dstlen -= opcount;
		dst += opcount;
	}
done:
	return (total);
d413 1
a413 1
	static char optbuf[32768]; /* XXX */
d415 1
a415 1
	char fmtbuf[32], *op = optbuf;
d548 5
a552 2
				opcount = pretty_print_string(op, opleft,
				    dp, len, emit_punct);
@


1.83
log
@Fix dhclient vis/unvis of strings stored in the leases file.

Replaces incorrect manual emulation of vis() for single, double and
back quotes, dollar signs and back slashes. Just use vis() with
VIS_ALL for these characters.

Should fix problem reported by robert@@ with ssid's containing back
slash.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.82 2017/03/08 14:19:00 krw Exp $	*/
d392 2
a393 3
int
pretty_print_domain_search(unsigned char *dst, size_t dstlen,
    unsigned char *src, size_t srclen)
d395 1
d397 1
a397 1
	unsigned char *domain_search, *cursor;
d399 1
a399 3
	domain_search = calloc(1, DHCP_DOMAIN_SEARCH_LEN);
	if (domain_search == NULL)
		fatalx("Can't allocate storage for expanded domain-search\n");
d413 2
a414 4
		if (len == -1) {
			free(domain_search);
			return (-1);
		}
d417 2
a418 4
		if (domains > DHCP_DOMAIN_SEARCH_CNT) {
			free(domain_search);
			return (-1);
		}
d421 1
a421 4
	strlcat(dst, domain_search, dstlen);
	free(domain_search);

	return (0);
@


1.82
log
@Add comments to #endif's to allow easy differentiation between many
incoming #ifdef's.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.81 2017/02/12 13:55:01 krw Exp $	*/
d239 2
a240 2
			opcount = snprintf(dst, dstlen, "\\%c", *src);
		else {
d242 1
a242 2
			opcount = snprintf(dst, dstlen, "%s", visbuf);
		}
@


1.81
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.80 2017/02/12 13:15:50 krw Exp $	*/
d667 1
a667 1
#endif
d675 1
a675 1
#endif
d683 1
a683 1
#endif
d692 1
a692 1
#endif
d730 1
a730 1
#endif
d757 1
a757 1
#endif
d766 1
a766 1
#endif
@


1.80
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.79 2016/10/06 16:29:17 krw Exp $	*/
d483 2
a484 2
			log_warnx("%s: Excess information in format string: %s",
			    dhcp_options[code].name,
d617 2
a618 1
				log_warnx("Unexpected format code %c", fmtbuf[j]);
d672 2
a673 1
		log_debug("Discarding packet with chaddr != %s (%s)", ifi->name,
d690 2
a691 2
			log_debug("Discarding packet from address on reject list "
			    "(%s)", inet_ntoa(from));
d728 2
a729 2
			log_debug("Discarding packet with client-identifier '%s'",
			    pretty_print_option(i, &options[i], 0));
d755 2
a756 2
			log_debug("Discarding DHCP packet of unknown type (%d)",
				options[DHO_DHCP_MESSAGE_TYPE].data[0]);
@


1.79
log
@Add support for RFC 6842, which says the client MUST drop packets when
the server provides a client-identifier value and it doesn't match
the value the client sent.

So stop suppressing client-identifer info in the leases file and when
reading the leases file stop discarding leases that don't have current
client-identifier info. Don't use them, but keep them around in case
the client-identifier info changes back next time.

Also construct the default client-identifier (if needed) before reading
the leases file.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.78 2016/09/02 15:44:26 mpi Exp $	*/
d62 1
d97 1
a97 1
				warning("option %s (%d) larger than buffer.",
d102 1
a102 1
			warning("option %s has no length field.",
d125 1
a125 1
				error("Can't allocate storage for option %s.",
d142 1
a142 1
				error("Can't expand storage for option %s.",
d335 1
a335 1
				warning("Truncated pointer in DHCP Domain "
d346 1
a346 1
				warning("Invalid forward pointer in DHCP "
d359 1
a359 1
			warning("Truncated label in DHCP Domain Search "
d371 1
a371 1
			warning("Domain search list too long.");
d384 1
a384 1
	warning("Truncated DHCP Domain Search option.");
d402 1
a402 1
		error("Can't allocate storage for expanded domain-search\n");
d459 1
a459 1
		warning("pretty_print_option: bad code %d", code);
d483 1
a483 1
			warning("%s: Excess information in format string: %s",
d496 1
a496 1
				warning("%s: no size indicator before A"
d537 1
a537 1
			warning("%s: garbage in format string: %s",
d546 1
a546 1
		warning("%s: expecting at least %d bytes; got %d",
d552 1
a552 1
		warning("%s: expecting only %d bytes: got %d",
d562 1
a562 1
		warning("%s: expecting %d bytes: got %d",
d617 1
a617 1
				warning("Unexpected format code %c", fmtbuf[j]);
d664 1
a664 1
		debug("Discarding packet with hlen != %s (%u)",
d671 1
a671 1
		debug("Discarding packet with chaddr != %s (%s)", ifi->name,
d679 1
a679 1
		debug("Discarding packet with XID != %u (%u)", client->xid,
d688 1
a688 1
			debug("Discarding packet from address on reject list "
d726 1
a726 1
			debug("Discarding packet with client-identifier '%s'",
d753 1
a753 1
			debug("Discarding DHCP packet of unknown type (%d)",
d763 1
a763 1
		debug("Discarding packet which is neither DHCP nor BOOTP");
d770 1
a770 1
		error("no memory for info string");
@


1.78
log
@Kill 'ifi' global.

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.77 2016/08/31 12:57:31 mpi Exp $	*/
d714 16
d776 1
@


1.77
log
@Remove the 'client' global and make it per-ifp.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.76 2016/08/23 09:26:02 mpi Exp $	*/
d656 2
a657 1
	void (*handler)(struct in_addr, struct option_data *, char *);
d756 1
a756 1
		(*handler)(from, options, info);
@


1.76
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 2016/02/06 19:30:52 krw Exp $	*/
d162 1
a162 1
cons_options(struct option_data *options)
d164 1
d652 1
@


1.75
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.74 2015/10/26 16:32:33 krw Exp $	*/
d648 2
a649 2
do_packet(unsigned int from_port, struct in_addr from,
    struct ether_addr *hfrom)
@


1.74
log
@Give dhclient(8) the ability to use option 119, a.k.a. "Domain
Search" if supplied by the server.

Requested by a few. Original diff from Ray Lai via tech@@.

Tested & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.73 2014/10/27 17:01:28 krw Exp $	*/
d43 9
a51 1
#include "dhcpd.h"
d53 5
d59 3
@


1.73
log
@Nuke getLong(), getShort(), getUShort(). Two line functions (memcpy();
ntoh[ls]()) obscure rather than simplify things. Especially when
they are used only once. Just use the expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.72 2014/10/27 14:17:01 krw Exp $	*/
d48 1
d291 123
@


1.72
log
@htonl(ntohl(memcpy'd buf)) seems like the long way around to copy
an IPv4 address. Just memcpy() it.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.71 2014/10/27 13:36:21 krw Exp $	*/
d309 3
d444 4
a447 3
				opcount = snprintf(op, opleft, "%ld",
				    (long)getLong(dp));
				dp += 4;
d450 4
a453 3
				opcount = snprintf(op, opleft, "%lu",
				    (unsigned long)getULong(dp));
				dp += 4;
d456 4
a459 3
				opcount = snprintf(op, opleft, "%u",
				    getUShort(dp));
				dp += 2;
@


1.71
log
@Zap extraneous whitespace and a stuttered extra 'break;'.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.70 2014/07/28 16:45:35 tobias Exp $	*/
d435 1
a435 1
				foo.s_addr = htonl(getULong(dp));
d438 1
a438 1
				dp += 4;
@


1.70
log
@Fix memory exhaustion occurring on DHCP options with 0 length.

halex@@ and krw@@ pointed out that a NULL check before free can go, too.

ok deraadt@@, halex@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.69 2014/07/09 12:55:31 krw Exp $	*/
d259 1
a259 1
	
a467 1
 				break;
@


1.69
log
@Special case pretty printing of DHO_CLASSLESS_STATIC_ROUTES and
DHO_CLASSLESS_MS_STATIC_ROUTES. Remove 'C' (CIDR) pretty printing
outside of those special cases. Add a bunch of paranoia to protect
against confused/malicious dhcp servers.

Since 'C' is a variable size element it can't be handled by the
existing code, which is designed for fixed size elements.

Issue found by Someya Yuuichi, reported by yasuoka@@ who also provided
the first diff.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.68 2014/05/05 18:02:49 krw Exp $	*/
d613 1
a613 2
		if (options[i].len && options[i].data)
			free(options[i].data);
@


1.68
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.67 2014/01/21 03:07:50 krw Exp $	*/
d249 44
d323 12
a390 3
		case 'C':
			hunksize += 5;
			break;
a467 8
			case 'C':
				memset(&foo, 0, sizeof(foo));
				memcpy(&foo.s_addr, dp+1, (*dp + 7) / 8);
				opcount = snprintf(op, opleft, "%s/%u",
				    inet_ntoa(foo), *dp);
				if (opcount >= opleft || opcount == -1)
					goto toobig;
				dp += 1 + (*dp + 7) / 8;
@


1.67
log
@Add parsing for options 121 (classless-static-routes) and 249
(classless-ms-static-routes). dhcpd can now specify and serve
these options and dhclient can recognize and use supersede, etc.
statements on them.

Based on a diff from Stefan Rinke. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.66 2014/01/19 21:10:04 krw Exp $	*/
d417 1
a417 1
				memcpy(&foo.s_addr, dp+1, (*dp + 7) / 8); 
d419 1
a419 1
				    inet_ntoa(foo), *dp); 
@


1.67.4.1
log
@Fix memory exhaustion occurring on DHCP options with 0 length.

halex@@ and krw@@ pointed out that a NULL check before free can go, too.

ok deraadt@@, halex@@, krw@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.67 2014/01/21 03:07:50 krw Exp $	*/
d568 2
a569 1
		free(options[i].data);
@


1.66
log
@We don't have any (and I can't find elsewhere) signed 16 bit or
signed 8 bit dhcp option types. So nuke getShort() and all 's' and
'b' format support. While here use '%u'/'%lu' and not
'%d'/'%ld' to snprintf() unsigned values.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.65 2013/12/30 03:36:17 krw Exp $	*/
d335 3
d415 9
@


1.65
log
@Replace yet another hand-rolled list with a TAILQ. reject_list this
time.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.64 2013/12/22 04:47:57 krw Exp $	*/
a325 1
		case 's':
a328 1
		case 'b':
d390 1
a390 1
				opcount = snprintf(op, opleft, "%ld",
a393 5
			case 's':
				opcount = snprintf(op, opleft, "%d",
				    getShort(dp));
				dp += 2;
				break;
d395 1
a395 1
				opcount = snprintf(op, opleft, "%d",
a398 5
			case 'b':
				opcount = snprintf(op, opleft, "%d",
				    *(char *)dp);
				dp++;
				break;
d400 1
a400 1
				opcount = snprintf(op, opleft, "%d", *dp);
@


1.64
log
@Setting format id to 't' when it's already 't' is a waste of
time.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.63 2013/12/22 03:20:05 krw Exp $	*/
d491 1
a491 1
	for (ap = config->reject_list; ap; ap = ap->next)
@


1.63
log
@No need to change format id 'X' (ascii or hex) to 'x' (hex) while
pretty printing, when 'X' is not used in the next switch statement.
Just keep 'X'. Makes the code a touch less mysterious.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.62 2013/12/21 18:23:10 krw Exp $	*/
a317 1
			fmtbuf[i] = 't';
@


1.62
log
@Introduce pretty_print_string() and use for printing both text
valued options and previously snprintf()'d filename and servername
lease attributes.

Should fix "string constant too long" errors when reading back a
lease with filename or servername attributes with escaped characters.

Reported by Rivo Nurges.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.61 2013/12/18 00:37:59 krw Exp $	*/
a310 1
				fmtbuf[i] = 'x';
d416 1
a416 1
			case 'x':
@


1.61
log
@Code existed to print non-printable characters in strings written
to the leases file. No code existed to correctly read back the
strings so written.

Redo both sides and use vis()/strnunvis() instead of handrolling
more parsing. As a side-effect allow embedded NUL characters rather
than skipping them.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.60 2013/12/14 16:06:42 krw Exp $	*/
d194 55
d257 1
a257 1
	char fmtbuf[32], visbuf[5], *op = optbuf;
d379 2
a380 30
				if (emit_punct) {
					opcount = snprintf(op, opleft, "\"");
					if (opcount >= opleft || opcount == -1)
						goto toobig;
					opleft -= opcount;
					op += opcount;
				}
				for (; dp < data + len; dp++) {
					if (*dp && strchr("\"'$`\\", *dp))
						opcount = snprintf(op, opleft,
						    "\\%c", *dp);
					else {
						vis(visbuf, *dp, VIS_OCTAL,
						    *dp+1);
						opcount = snprintf(op, opleft,
						   "%s", visbuf);
					}
					if (opcount >= opleft || opcount == -1)
						goto toobig;
					opleft -= opcount;
					op += opcount;
				}
				if (emit_punct) {
					opcount = snprintf(op, opleft, "\"");
					if (opcount >= opleft || opcount == -1)
						goto toobig;
					opleft -= opcount;
					op += opcount;
				}
				opcount = 0; /* Already moved dp & op. */
@


1.60
log
@Start cleanup/fixup of pretty printing of option data. Use snprintf()
exclusively and thus simplify error checking/overflow detection.
Bail out when unknown format character found. Don't ignore last
character if it's unprintable. Print embedded NULs rather than
ignoring them.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.59 2013/12/12 13:22:37 krw Exp $	*/
d45 2
d202 1
a202 1
	char fmtbuf[32], *op = optbuf;
d332 1
a332 8
					if (!isascii(*dp) || !isprint(*dp)) {
						opcount = snprintf(op, opleft,
						    "\\%03o", *dp);
					} else if (*dp == '"' ||
					    *dp == '\'' ||
					    *dp == '$' ||
					    *dp == '`' ||
					    *dp == '\\') {
d335 3
a337 1
					} else {
d339 1
a339 1
						    "%c", *dp);
@


1.59
log
@Delete spurious blank line.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.58 2013/12/12 01:40:35 krw Exp $	*/
d205 1
a319 2
			int opcount;
			size_t oplen;
d323 5
a327 2
					*op++ = '"';
					opleft--;
d330 3
a332 11
					if (!isascii(*dp) ||
					    !isprint(*dp)) {
						if (dp + 1 != data + len ||
						    *dp != 0) {
							size_t oplen;
							snprintf(op, opleft,
							    "\\%03o", *dp);
							oplen = strlen(op);
							op += oplen;
							opleft -= oplen;
						}
d338 2
a339 3
						*op++ = '\\';
						*op++ = *dp;
						opleft -= 2;
d341 2
a342 2
						*op++ = *dp;
						opleft--;
d344 4
d350 5
a354 2
					*op++ = '"';
					opleft--;
d356 1
a356 2

				*op = 0;
d360 2
a361 3
				opcount = strlcpy(op, inet_ntoa(foo), opleft);
				if (opcount >= opleft)
					goto toobig;
a366 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
a371 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
a376 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
a381 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
a386 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
a390 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
a394 2
				if (opcount >= opleft || opcount == -1)
					goto toobig;
d398 2
a399 4
				opcount = strlcpy(op,
				    *dp ? "true" : "false", opleft);
				if (opcount >= opleft)
					goto toobig;
d404 1
d406 1
a406 4
			oplen = strlen(op);
			op += oplen;
			opleft -= oplen;
			if (opleft < 1)
d408 2
d411 5
a415 2
				*op++ = ' ';
				opleft--;
d419 5
a423 2
			*op++ = comma;
			opleft--;
a424 2
		if (opleft < 1)
			goto toobig;
@


1.58
log
@Eliminate (most) double decrements of remaining space in the pretty
print buffer. Use consistant idiom to increment pointer to data
being consumed, instead of hiding some increments.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.57 2013/12/06 23:40:48 krw Exp $	*/
a438 1

@


1.57
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.56 2013/07/11 01:34:00 krw Exp $	*/
a363 1
				opleft -= opcount;
a370 1
				opleft -= opcount;
a377 1
				opleft -= opcount;
a384 1
				opleft -= opcount;
a391 1
				opleft -= opcount;
d396 1
a396 1
				    *(char *)dp++);
d399 1
a399 1
				opleft -= opcount;
d402 1
a402 1
				opcount = snprintf(op, opleft, "%d", *dp++);
d405 1
a405 1
				opleft -= opcount;
d408 1
a408 1
				opcount = snprintf(op, opleft, "%x", *dp++);
d411 1
a411 1
				opleft -= opcount;
d415 1
a415 1
				    *dp++ ? "true" : "false", opleft);
d418 1
a418 1
				opleft -= opcount;
@


1.56
log
@Put more debug verbiage under DEBUG. Add a few more debug messages.
Make packet discarding decisions before parsing the packet's possible
options. No intended functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.55 2013/07/07 00:04:58 krw Exp $	*/
d457 1
a457 1
    struct hardware *hfrom)
d466 1
a466 1
	if (ifi->hw_address.hlen != packet->hlen) {
d472 2
a473 2
	} else if (memcmp(ifi->hw_address.haddr, packet->chaddr,
	    packet->hlen)) {
d555 2
a556 5
	if (hfrom->hlen == 6)
		rslt = asprintf(&info, "%s from %s (%s)", type, inet_ntoa(from),
		    ether_ntoa((struct ether_addr *)hfrom->haddr));
	else
		rslt = asprintf(&info, "%s from %s", type, inet_ntoa(from));
@


1.56.2.1
log
@Fix memory exhaustion occurring on DHCP options with 0 length.

halex@@ and krw@@ pointed out that a NULL check before free can go, too.

ok deraadt@@, halex@@, krw@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.56 2013/07/11 01:34:00 krw Exp $	*/
d569 2
a570 1
		free(options[i].data);
@


1.55
log
@Remove erroneous warnings -- we do not reject offers just because the
option buffer(s) end badly.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.54 2013/07/06 03:03:23 krw Exp $	*/
d466 12
a477 2
	if (packet->hlen > sizeof(packet->chaddr)) {
		note("Discarding packet with invalid hlen.");
d481 5
a485 6
	/*
	 * Silently drop the packet if the client hardware address in the
	 * packet is not the hardware address of the interface being managed.
	 */
	if ((ifi->hw_address.hlen != packet->hlen) ||
	    (memcmp(ifi->hw_address.haddr, packet->chaddr, packet->hlen)))
d487 10
d540 4
d549 4
a561 13

	if (client->xid != client->packet.xid) {
#ifdef DEBUG
		debug("XID mismatch on %s", info);
#endif
		handler = NULL;
	}

	for (ap = config->reject_list; ap && handler; ap = ap->next)
		if (from.s_addr == ap->addr.s_addr) {
			note("Rejected %s.", info);
			handler = NULL;
		}
@


1.54
log
@Fix a lie in one comment and zap a pointless sentence in another.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.53 2013/05/02 16:35:27 krw Exp $	*/
a78 1
				warning("rejecting bogus offer.");
a83 1
			warning("rejecting bogus offer.");
@


1.53
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.52 2013/04/05 19:19:05 krw Exp $	*/
d49 1
a49 2
 * option values in options and setting client->options_valid if
 * no errors are encountered.
d120 1
a120 2
			 * we last saw.   This is really only required
			 * for clients, but what the heck.
@


1.52
log
@Nuke parameter to do_packet() not used since 2006. From dhill.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.51 2013/02/14 20:39:46 krw Exp $	*/
d122 1
a122 1
			 * for clients, but what the heck...
d293 1
a293 1
	/* Check for too few bytes... */
d299 1
a299 1
	/* Check for too many bytes... */
@


1.51
log
@Don't rely on the packet buffer (client->packet) being preserved between
attempts to send DISCOVER or REQUEST packets. Some DHCP servers might
NAK the DISCOVER, or other nefarious packets arrive, between attempts
and overwrite the packet being sent. Create and use another buffer
for packets being sent.

Problem encountered by fgsch@@, who noticed that once the DISCOVER was
NAK'ed our dhclient sent a bunch of NAK's back to the server. Like it
thought they were DISCOVER messages.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.50 2013/01/16 21:35:41 krw Exp $	*/
d460 1
a460 1
do_packet(int len, unsigned int from_port, struct in_addr from,
@


1.50
log
@Unrevert last reversion. otto@@ pointed out that it wasn't asprintf()
causing a problem, it was accessing uninitialized pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.49 2013/01/16 11:02:10 krw Exp $	*/
d149 1
a149 1
	unsigned char *buf = client->packet.options;
@


1.49
log
@Revert last. asprintf() breaks something.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.48 2013/01/16 06:11:21 krw Exp $	*/
d466 3
a468 3
	void (*handler)(struct in_addr, struct option_data *);
	char *type;
	int i, options_valid = 1;
d506 1
a506 1
	type = "";
d532 12
a543 7
	if (handler && client->xid == client->packet.xid) {
		if (hfrom->hlen == 6)
			note("%s from %s (%s)", type, inet_ntoa(from),
			    ether_ntoa((struct ether_addr *)hfrom->haddr));
		else
			note("%s from %s", type, inet_ntoa(from));
	} else
d545 1
d549 1
a549 1
			note("%s from %s rejected.", type, inet_ntoa(from));
d554 3
a556 1
		(*handler)(from, options);
@


1.48
log
@Use the magic of asprintf() to produce more informative error
and log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.47 2013/01/13 22:50:33 krw Exp $	*/
d466 3
a468 3
	void (*handler)(struct in_addr, struct option_data *, char *);
	char *type, *info;
	int i, rslt, options_valid = 1;
d534 1
a534 2
			rslt = asprintf(&info, "%s from %s (%s)", type,
			    inet_ntoa(from),
d537 1
a537 4
			rslt = asprintf(&info, "%s from %s", type,
			    inet_ntoa(from));
		if (rslt == -1)
			error("no memory for info string");
d543 1
a543 1
			note("Rejected %s.", info);
d548 1
a548 3
		(*handler)(from, options, info);

	free(info);
@


1.47
log
@More informative error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.46 2013/01/13 22:09:38 krw Exp $	*/
d466 3
a468 3
	void (*handler)(struct in_addr, struct option_data *);
	char *type;
	int i, options_valid = 1;
d534 2
a535 1
			note("%s from %s (%s)", type, inet_ntoa(from),
d538 4
a541 1
			note("%s from %s", type, inet_ntoa(from));
d547 1
a547 1
			note("%s from %s rejected.", type, inet_ntoa(from));
d552 3
a554 1
		(*handler)(from, options);
@


1.46
log
@Make pretty_print_option() return "" rather than "<fmt error>" when
the option fails validation tests. Make pretty_print_option() bail
on all bad format strings, and on all incorrect option data lengths.

Check pretty_print_option() return value rather than repeating
validation with check_option(). Do res_hnok() check on host name,
domain name, and nis domain while creating lease from packet info.

As a result, nuke ipv4addrs() and check_option().

Ignore options that do not validate rather than summarily rejecting
offered lease. Treat all options whose names start with "option-"
as unknown rather than relying on a big switch on DHO_ names.

Started when reading dhclient(8) -u verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.45 2012/11/15 14:54:18 krw Exp $	*/
d301 2
a302 2
		warning("%s: %d extra bytes",
		    dhcp_options[code].name, len - hunksize);
@


1.45
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.44 2012/11/08 21:32:55 krw Exp $	*/
d212 2
d215 4
a218 2
	if (code > 255)
		error("pretty_print_option: bad code %d", code);
d231 1
a231 1
			break;
d245 1
a245 1
				return ("<fmt error>");
d289 1
a289 1
			break;
d297 1
a297 1
		return ("<error>");
d300 1
a300 1
	if (numhunk == -1 && hunksize < len)
d303 2
d310 5
a314 3
	if (numhunk > 0 && numhunk * hunksize < len)
		warning("%s: %d extra bytes at end of array",
		    dhcp_options[code].name, len - numhunk * hunksize);
d450 6
a456 3
 toobig:
	warning("dhcp option too large");
	return ("<error>");
@


1.44
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.43 2012/11/07 15:20:28 krw Exp $	*/
a41 2

#include <ctype.h>
@


1.43
log
@Use memset() consistently rather than tossing in a few bzero()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.42 2012/10/27 23:08:53 krw Exp $	*/
d451 1
a451 1
do_packet(int len, unsigned int from_port, struct iaddr from,
d456 2
a457 2
	struct iaddrlist *ap;
	void (*handler)(struct iaddr, struct option_data *);
d525 1
a525 1
			note("%s from %s (%s)", type, piaddr(from),
d528 1
a528 1
			note("%s from %s", type, piaddr(from));
d533 2
a534 2
		if (addr_eq(from, ap->addr)) {
			note("%s from %s rejected.", type, piaddr(from));
@


1.42
log
@Change dhclient.conf directive 'ignore' to take a list of option names
rather than list of option declarations. e.g. 'ignore routers;'
instead of 'ignore routers 1.2.3.4;' The value in the declaration
was being ignored anyway.

While there clean up the related code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.41 2012/06/26 14:46:42 krw Exp $	*/
d155 1
a155 1
	bzero(buf, buflen);
@


1.41
log
@Add some more paranoia and make code clearer. Check that the required
length field for the option is present before using it. Reject lease
if no length field is present.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.40 2012/06/26 14:36:11 krw Exp $	*/
d201 2
a202 2
pretty_print_option(unsigned int code, unsigned char *data, int len,
    int emit_commas, int emit_quotes)
d208 1
d210 1
d218 1
a218 1
	if (emit_commas)
d321 1
a321 1
				if (emit_quotes) {
d350 1
a350 1
				if (emit_quotes) {
@


1.40
log
@RFC 2132 says "Options containing NVT ASCII data SHOULD NOT include
a trailing NULL; however, the receiver of such options MUST be
prepared to delete trailing nulls if they exist."

So delete (all) trailing NUL's when parsing NVT ASCII options.
Should fix odd results when 'append'ing info to such options via
dhclient.conf.

FreeBSD commit to fix 'append' logic in a different way pointed out
by brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.39 2011/05/11 14:38:36 krw Exp $	*/
d71 3
a73 2
		 * All options other than DHO_PAD and DHO_END have a
		 * one-byte length field.
d75 1
a75 3
		if (s + 2 > end)
			len = 0;
		else
d77 11
a87 8

		/*
		 * If the option claims to extend beyond the end of the buffer
		 * then mark the options buffer bad.
		 */
		if (s + len + 2 > end) {
			warning("option %s (%d) larger than buffer.",
			    dhcp_options[code].name, len);
d100 2
a101 2
			for (len = s[1]; len > 0 && s[len + 1] == '\0'; len--)
				;
@


1.39
log
@Make dhclient more friendly to sequential option processing by
always starting DHCP packet options with DHO_DHCP_MESSAGE_TYPE. Now
DHCP-specific options always come after the option identifying the
packet as DHCP rather than BOOTP. Makes at least Nortel NetIP DHCP
server happier. Clean up some code and parameter passing.

Closes PR#6543, as confirmed by original submitter and patch
tester Len Zaifman. Thanks!

ok matthew@@ (who hates the ISC-like code)
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.38 2011/04/17 19:57:23 phessler Exp $	*/
d89 13
@


1.38
log
@fix a possible division by zero if a server sends us a broken option

hints for the proper fix, and OK claudio@@
(this was lost in my tree for far too long)
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.37 2009/03/10 23:19:36 krw Exp $	*/
d134 1
a134 1
cons_options(unsigned char *buf, const int buflen, struct option_data *options)
d136 2
d142 7
a148 3
	if (buflen > 3)
		memcpy(buf, DHCP_OPTIONS_COOKIE, 4);
	bufix = 4;
d151 1
a151 1
		if (!options[code].data)
@


1.37
log
@Add 6-byte MAC address to the log entries for DHCP ACK/NAK/OFFER.
Log the packets before checking the client state. Makes it easy to
find MACs for 'surprise' DHCP servers.

Positive comments from mbalmer@@, jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.36 2007/06/02 01:29:11 pvalchev Exp $	*/
d215 7
@


1.36
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.35 2007/05/31 23:24:15 pvalchev Exp $	*/
d492 9
@


1.35
log
@fix a funny memory miscalculation bug in options parsing
ok henning otto theo
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.34 2007/02/14 23:19:26 deraadt Exp $	*/
d300 1
d303 3
a305 2
							op += 4;
							opleft -= 4;
@


1.34
log
@spacing and a typo that fell out of the read
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.33 2007/01/25 01:21:04 krw Exp $	*/
d288 1
d394 3
a396 2
			op += strlen(op);
			opleft -= strlen(op);
@


1.33
log
@Cleanup some more code. Eliminate dhcp(), bootp(), parse_options() by
moving the minimal code into do_packet(). Eliminate repeated code for
checking the client hardware address and the reject list by putting
those checks into do_packet as well.

No functional change, just much easier to read.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.32 2007/01/16 20:22:20 krw Exp $	*/
d447 1
a447 1
		/* Only DHCP packets have overload areas for options. */ 
d495 1
a495 1
	if (handler)	
@


1.32
log
@More cleanup. Eliminate 'struct packet' by cleverly passing as
parameters just those things actually needed and using existing
structs and information. No functional change.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.31 2007/01/14 01:35:46 krw Exp $	*/
d47 1
a47 39
void	parse_options(struct option_data *);
void	parse_option_buffer(struct option_data *, unsigned char *, int);

/*
 * Parse all available options out of the specified packet.
 */
void
parse_options(struct option_data *options)
{
	/* If we don't see the magic cookie, there's nothing to parse. */
	if (memcmp(&client->packet.options, DHCP_OPTIONS_COOKIE, 4)) {
		client->options_valid = 1;
		return;
	}

	/*
	 * Go through the options field, up to the end of the packet or
	 * the End field.
	 */
	parse_option_buffer(options, &client->packet.options[4],
	    sizeof(client->packet.options) - 4);

	/*
	 * If we parsed a DHCP Option Overload option, parse more
	 * options out of the buffer(s) containing them.
	 */
	if (client->options_valid && options[DHO_DHCP_MESSAGE_TYPE].data &&
	    options[DHO_DHCP_OPTION_OVERLOAD].data) {
		if (options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)
			parse_option_buffer(options,
			    (unsigned char *)client->packet.file,
			    sizeof(client->packet.file));
		if (client->options_valid &&
		    options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)
			parse_option_buffer(options,
			    (unsigned char *)client->packet.sname,
			    sizeof(client->packet.sname));
	}
}
d54 1
a54 1
void
d87 1
a87 2
			client->options_valid = 0;
			return;
d124 2
a125 1
	client->options_valid = 1;
d420 1
d422 4
a425 1
	int i;
d427 1
a427 1
	if (client->packet.hlen > sizeof(client->packet.chaddr)) {
d432 33
a464 1
	memset(&options, 0, sizeof(options));
a465 1
	parse_options(options);
d467 30
a496 3
		dhcp(from, options);
	} else if (client->options_valid)
		bootp(from, options);
a497 1
	/* Free the data associated with the options. */
@


1.31
log
@Don't treat any packet with an invalid option buffer or an invalid
message type option of 0 as a BOOTP offer. Don't process any option
buffer after one is found to be corrupt. Don't process overflow
buffers in a BOOTP packet.  At least try to accept DHCP offers even if
a bad options buffer is encountered.

Brings code more into line with current ISC dhclient.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.30 2007/01/11 00:04:48 krw Exp $	*/
d47 2
a48 2
void	parse_options(struct packet *);
void	parse_option_buffer(struct packet *, unsigned char *, int);
d54 1
a54 1
parse_options(struct packet *packet)
a55 3
	/* Initially, zero all option pointers. */
	memset(packet->options, 0, sizeof(packet->options));

d58 1
a58 1
		packet->options_valid = 1;
d66 1
a66 1
	parse_option_buffer(packet, &client->packet.options[4],
d73 4
a76 5
	if (packet->options_valid &&
	    packet->options[DHO_DHCP_MESSAGE_TYPE].data &&
	    packet->options[DHO_DHCP_OPTION_OVERLOAD].data) {
		if (packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)
			parse_option_buffer(packet,
d79 3
a81 3
		if (packet->options_valid &&
		    packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)
			parse_option_buffer(packet,
d89 1
a89 1
 * option values in packet->options and setting packet->options_valid if
d93 2
a94 2
parse_option_buffer(struct packet *packet,
    unsigned char *buffer, int length)
d125 1
a125 1
			packet->options_valid = 0;
d132 1
a132 1
		if (!packet->options[code].data) {
d142 2
a143 2
			packet->options[code].len = len;
			packet->options[code].data = t;
d150 1
a150 1
			t = calloc(1, len + packet->options[code].len + 1);
d154 6
a159 8
			memcpy(t, packet->options[code].data,
				packet->options[code].len);
			memcpy(t + packet->options[code].len,
				&s[2], len);
			packet->options[code].len += len;
			t[packet->options[code].len] = 0;
			free(packet->options[code].data);
			packet->options[code].data = t;
d163 1
a163 1
	packet->options_valid = 1;
d458 1
a458 1
	struct packet tp;
d466 1
a466 2
	memset(&tp, 0, sizeof(tp));
	tp.client_addr = from;
d468 5
a472 6
	parse_options(&tp);
	if (tp.options[DHO_DHCP_MESSAGE_TYPE].data) {
		tp.packet_type = tp.options[DHO_DHCP_MESSAGE_TYPE].data[0];
		dhcp(&tp);
	} else if (tp.options_valid)
		bootp(&tp);
d476 2
a477 2
		if (tp.options[i].len && tp.options[i].data)
			free(tp.options[i].data);
@


1.30
log
@Reject all packets with an option claiming to extend past the end of
an option buffer. No longer accept the 6th such packet. From ISC.

ok ckuethe@@ stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.29 2007/01/06 23:21:08 krw Exp $	*/
d61 1
a61 1
		packet->options_valid = 0;
d77 1
d83 2
a84 1
		if (packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)
d476 1
a476 2
	if (tp.options_valid &&
	    tp.options[DHO_DHCP_MESSAGE_TYPE].data)
a477 1
	if (tp.packet_type)
d479 1
a479 1
	else
@


1.29
log
@Fix options parsing. Last commit lost the proper length of the
incoming packet.  But since we bzero() the packet buffer before
copying the incoming data into it, and the options are at the end, and
we use a fixed sized buffer, and 0's are ignored as pad options, and
proper option lists end with 0xff, it's simplier to always try to scan
the whole buffer.

Problem found by, and patch tested by kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.28 2007/01/04 22:17:48 krw Exp $	*/
a46 3
int bad_options = 0;
int bad_options_max = 5;

a108 4
		if (s + 2 > end) {
			len = 65536;
			goto bogus;
		}
d111 2
a112 2
		 * All other fields (except end, see above) have a
		 * one-byte length.
d114 4
a117 1
		len = s[1];
d120 2
a121 6
		 * If the length is outrageous, silently skip the rest,
		 * and mark the packet bad. Unfortunately some crappy
		 * dhcp servers always seem to give us garbage on the
		 * end of a packet. so rather than keep refusing, give
		 * up and try to take one after seeing a few without
		 * anything good.
d124 4
a127 15
		    bogus:
			bad_options++;
			warning("option %s (%d) %s.",
			    dhcp_options[code].name, len,
			    "larger than buffer");
			if (bad_options == bad_options_max) {
				packet->options_valid = 1;
				bad_options = 0;
				warning("Many bogus options seen in offers. "
				    "Taking this offer in spite of bogus "
				    "options - hope for the best!");
			} else {
				warning("rejecting bogus offer.");
				packet->options_valid = 0;
			}
@


1.28
log
@Another round of cleanup. There is only one instance of struct
dhcp_packet and it is contained in the global *client. So don't pass
around pointers to a struct that contains a pointer to the dhcp_packet
instance. Just use the global client->packet. Eliminate unused struct
packet members and parameter lists accordingly.

No functional change.

Suggestions by stevesk@@. ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.27 2006/12/26 21:19:52 krw Exp $	*/
d73 1
a73 1
	    client->packet_length - DHCP_FIXED_NON_UDP - 4);
@


1.27
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.26 2006/12/15 14:09:13 stevesk Exp $	*/
d63 1
a63 1
	if (memcmp(packet->raw->options, DHCP_OPTIONS_COOKIE, 4)) {
d72 2
a73 2
	parse_option_buffer(packet, &packet->raw->options[4],
	    packet->packet_length - DHCP_FIXED_NON_UDP - 4);
d83 2
a84 2
			    (unsigned char *)packet->raw->file,
			    sizeof(packet->raw->file));
d87 2
a88 2
			    (unsigned char *)packet->raw->sname,
			    sizeof(packet->raw->sname));
d478 2
a479 2
do_packet(struct dhcp_packet *packet, int len, unsigned int from_port,
    struct iaddr from, struct hardware *hfrom)
d484 1
a484 1
	if (packet->hlen > sizeof(packet->chaddr)) {
a489 3
	tp.raw = packet;
	tp.packet_length = len;
	tp.client_port = from_port;
a490 1
	tp.haddr = hfrom;
@


1.26
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.25 2005/08/22 20:30:52 krw Exp $	*/
d478 2
a479 2
do_packet(struct interface_info *interface, struct dhcp_packet *packet,
    int len, unsigned int from_port, struct iaddr from, struct hardware *hfrom)
a493 1
	tp.interface = interface;
@


1.25
log
@Fix problems with some Linksys DHCP servers (and probably others) by
not accidentally inserting two NULL characters after each option in
the DHCPREQUEST packet.

Thanks to Christian Jones for the problem report and tcpdump's, and to
Emmett Pate for finding a problematic Linksys model still in my local
stores.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.24 2005/07/16 16:31:05 henning Exp $	*/
d159 1
a159 1
			 * it's an ASCII string.
@


1.24
log
@back out last; breaks in cases where we want hex and the last byte is 0
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.22 2005/07/13 23:33:04 deraadt Exp $	*/
d225 1
a225 1
			bufix += 2 + incr;
@


1.23
log
@let pretty_print_option() handle trailing nul bytes correctly (i. e. don't
let a trailing nul byte force hex printing)
FreeBSD PR 83468 by Sean Winn <sean@@gothic.net.au>, via jmc@@
@
text
@d282 1
a282 5
	     /* If we found no bogus characters, or the bogus
		character we found is a trailing NUL, it's
		   okay to print this option as text. */

			if (k == len || (k + 1 == len && data [k] == 0)) {      
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.21 2005/07/13 23:25:55 krw Exp $	*/
d282 5
a286 1
			if (k == len) {
@


1.21
log
@Repair/rationalize option handling to ensure valid option section is
always sent. Fold store_options into cons_options. Eliminate priority
list of options.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.20 2005/07/09 14:36:16 krw Exp $	*/
d232 1
a232 1
	}	
@


1.20
log
@Clean out a few more unused/uninitialized variables.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.19 2005/07/08 14:15:23 krw Exp $	*/
a51 1
int	store_options(unsigned char *, int, struct option_data *, int);
d190 3
a192 3
 * cons options into a big buffer, and then split them out into the
 * three separate buffers if needed.  This allows us to cons up a set of
 * vendor options using the same routine.
d195 1
a195 1
cons_options(struct dhcp_packet *outpacket, struct option_data *options)
d197 1
a197 13
	unsigned char buffer[4096];
	int main_buffer_size, mainbufix, bufix;
	int option_size, length;

	main_buffer_size = 576 - DHCP_FIXED_LEN;

	/* Copy the options into the big buffer... */
	option_size = store_options( buffer, (main_buffer_size - 7), options,
	    main_buffer_size);

	/* Put the cookie up front... */
	memcpy(outpacket->options, DHCP_OPTIONS_COOKIE, 4);
	mainbufix = 4;
d199 1
a199 28
	/*
	 * If we're going to have to overload, store the overload option
	 * at the beginning.  If we can, though, just store the whole
	 * thing in the packet's option buffer and leave it at that.
	 */
	if (option_size <= main_buffer_size - mainbufix) {
		memcpy(&outpacket->options[mainbufix],
		    buffer, option_size);
		mainbufix += option_size;
		if (mainbufix < main_buffer_size)
			outpacket->options[mainbufix++] = DHO_END;
		length = DHCP_FIXED_NON_UDP + mainbufix;
	} else {
		outpacket->options[mainbufix++] = DHO_DHCP_OPTION_OVERLOAD;
		outpacket->options[mainbufix++] = 1;
		if (option_size >
		    main_buffer_size - mainbufix + DHCP_FILE_LEN)
			outpacket->options[mainbufix++] = 3;
		else
			outpacket->options[mainbufix++] = 1;

		memcpy(&outpacket->options[mainbufix],
		    buffer, main_buffer_size - mainbufix);
		bufix = main_buffer_size - mainbufix;
		length = DHCP_FIXED_NON_UDP + mainbufix;
	}
	return (length);
}
d201 3
a203 17
/*
 * Store all the requested options into the requested buffer.
 */
int
store_options(unsigned char *buffer, int buflen, struct option_data *options,
    int first_cutoff)
{
	int bufix = 0, i, ix;

	/*
	 * Copy out the options in the order that they appear in the
	 * priority list.
	 */
	for (i = 0; i < sizeof dhcp_option_default_priority_list; i++) {
		/* Code for next option to try to store. */
		int code = dhcp_option_default_priority_list[i];
		int optstart;
d205 1
a205 7
		/*
		 * Number of bytes left to store (some may already have
		 * been stored by a previous pass).
		 */
		int length;

		/* If no data is available for this option, skip it. */
a208 1
		/* We should now have a constant length for the option. */
d210 2
d213 1
a213 9
		/* Try to store the option. */

		/*
		 * If the option's length is more than 255, we must
		 * store it in multiple hunks.   Store 255-byte hunks
		 * first.  However, in any case, if the option data will
		 * cross a buffer boundary, split it across that
		 * boundary.
		 */
a215 1
		optstart = bufix;
d217 1
a217 10
			unsigned char incr = length > 255 ? 255 : length;

			/*
			 * If this hunk of the buffer will cross a
			 * boundary, only go up to the boundary in this
			 * pass.
			 */
			if (bufix < first_cutoff &&
			    bufix + incr > first_cutoff)
				incr = first_cutoff - bufix;
d219 3
a221 8
			/*
			 * If this option is going to overflow the
			 * buffer, skip it.
			 */
			if (bufix + 2 + incr > buflen) {
				bufix = optstart;
				break;
			}
a222 5
			/* Everything looks good - copy it in! */
			buffer[bufix] = code;
			buffer[bufix + 1] = incr;
			memcpy(buffer + bufix + 2, options[code].data + ix,
			    incr);
d228 7
a234 1
	return (bufix);
@


1.19
log
@More dead and moribund code removal/cleanup. This time unused parameters
and associated code for store_options().

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.18 2005/07/08 00:57:36 krw Exp $	*/
a44 1
#define DHCP_OPTION_DATA
@


1.18
log
@Eliminate unused code and associated parameters.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.17 2005/07/07 20:03:40 krw Exp $	*/
d53 1
a53 3
int	store_options(unsigned char *, int, struct option_data *,
	    unsigned char *, int, int, int);

d199 2
a200 2
	unsigned char priority_list[300], buffer[4096];
	int priority_len, main_buffer_size, mainbufix, bufix;
a204 11
	/* Preload the option priority list with mandatory options. */
	priority_len = 0;
	priority_list[priority_len++] = DHO_DHCP_MESSAGE_TYPE;
	priority_list[priority_len++] = DHO_DHCP_SERVER_IDENTIFIER;
	priority_list[priority_len++] = DHO_DHCP_LEASE_TIME;
	priority_list[priority_len++] = DHO_DHCP_MESSAGE;

	memcpy(&priority_list[priority_len], dhcp_option_default_priority_list,
	    sizeof_dhcp_option_default_priority_list);
	priority_len += sizeof_dhcp_option_default_priority_list;

d207 1
a207 1
	    priority_list, priority_len, main_buffer_size, main_buffer_size);
d247 1
a247 2
    unsigned char *priority_list, int priority_len, int first_cutoff,
    int second_cutoff)
d249 1
a249 4
	int bufix = 0, option_stored[256], i, ix;

	/* Zero out the stored-lengths array. */
	memset(option_stored, 0, sizeof(option_stored));
d253 1
a253 1
	 * priority list...
d255 1
a255 1
	for (i = 0; i < priority_len; i++) {
d257 1
a257 1
		int code = priority_list[i];
d267 1
a267 9
		if (!options[code].data) {
			continue;
		}

		/*
		 * The client could ask for things that are mandatory,
		 * in which case we should avoid storing them twice...
		 */
		if (option_stored[code])
a268 1
		option_stored[code] = 1;
a295 3
			else if (bufix < second_cutoff &&
			    bufix + incr > second_cutoff)
				incr = second_cutoff - bufix;
@


1.17
log
@Eliminate unused code and associated parameter.

ok deraadt@@ millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.16 2005/07/07 16:24:24 krw Exp $	*/
d54 1
a54 1
	    unsigned char *, int, int, int, int);
d199 1
a199 4
cons_options(struct dhcp_packet *outpacket,
    int mms, struct option_data *options,
    int overload, /* Overload flags that may be set. */
    int terminate, int bootpp, u_int8_t *prl, int prl_len)
d205 1
a205 9
	if (mms)
		main_buffer_size = mms - DHCP_FIXED_LEN;
	else if (bootpp)
		main_buffer_size = 64;
	else
		main_buffer_size = 576 - DHCP_FIXED_LEN;

	if (main_buffer_size > sizeof(buffer))
		main_buffer_size = sizeof(buffer);
d214 3
a216 18
	/*
	 * If the client has provided a list of options that it wishes
	 * returned, use it to prioritize.  Otherwise, prioritize based
	 * on the default priority list.
	 */
	if (prl) {
		if (prl_len + priority_len > sizeof(priority_list))
			prl_len = sizeof(priority_list) - priority_len;

		memcpy(&priority_list[priority_len], prl, prl_len);
		priority_len += prl_len;
		prl = priority_list;
	} else {
		memcpy(&priority_list[priority_len],
		    dhcp_option_default_priority_list,
		    sizeof_dhcp_option_default_priority_list);
		priority_len += sizeof_dhcp_option_default_priority_list;
	}
d219 2
a220 7
	option_size = store_options(
	    buffer,
	    (main_buffer_size - 7 + ((overload & 1) ? DHCP_FILE_LEN : 0) +
		((overload & 2) ? DHCP_SNAME_LEN : 0)),
	    options, priority_list, priority_len, main_buffer_size,
	    (main_buffer_size + ((overload & 1) ? DHCP_FILE_LEN : 0)),
	    terminate);
a250 25
		if (overload & 1) {
			if (option_size - bufix <= DHCP_FILE_LEN) {
				memcpy(outpacket->file,
				    &buffer[bufix], option_size - bufix);
				mainbufix = option_size - bufix;
				if (mainbufix < DHCP_FILE_LEN)
					outpacket->file[mainbufix++] = (char)DHO_END;
				while (mainbufix < DHCP_FILE_LEN)
					outpacket->file[mainbufix++] = (char)DHO_PAD;
			} else {
				memcpy(outpacket->file,
				    &buffer[bufix], DHCP_FILE_LEN);
				bufix += DHCP_FILE_LEN;
			}
		}
		if ((overload & 2) && option_size < bufix) {
			memcpy(outpacket->sname,
			    &buffer[bufix], option_size - bufix);

			mainbufix = option_size - bufix;
			if (mainbufix < DHCP_SNAME_LEN)
				outpacket->file[mainbufix++] = (char)DHO_END;
			while (mainbufix < DHCP_SNAME_LEN)
				outpacket->file[mainbufix++] = (char)DHO_PAD;
		}
d261 1
a261 1
    int second_cutoff, int terminate)
d263 1
a263 1
	int bufix = 0, option_stored[256], i, ix, tto;
a298 7
		/* Do we add a NUL? */
		if (terminate && dhcp_options[code].format[0] == 't') {
			length++;
			tto = 1;
		} else
			tto = 0;

d338 2
a339 7
			if (tto && incr == length) {
				memcpy(buffer + bufix + 2,
				    options[code].data + ix, incr - 1);
				buffer[bufix + 2 + incr - 1] = 0;
			} else
				memcpy(buffer + bufix + 2,
				    options[code].data + ix, incr);
@


1.16
log
@Eliminate tree_cache structure in favour of option_data. Eliminate
redundant level of indirection in building and using option_data
arrays while constructing outgoing packets. Make option_data len field
unsigned.

ok henning@@. 'cool!' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.15 2004/12/26 03:17:07 deraadt Exp $	*/
d199 1
a199 1
cons_options(struct packet *inpacket, struct dhcp_packet *outpacket,
a207 16
	/*
	 * If the client has provided a maximum DHCP message size, use
	 * that; otherwise, if it's BOOTP, only 64 bytes; otherwise use
	 * up to the minimum IP MTU size (576 bytes).
	 *
	 * XXX if a BOOTP client specifies a max message size, we will
	 * honor it.
	 */
	if (!mms &&
	    inpacket &&
	    inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].data &&
	    (inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].len >=
	    sizeof(u_int16_t)))
		mms = getUShort(
		    inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].data);

d230 1
a230 13
	if (inpacket &&
	    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].data) {
		int prlen =
		    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].len;
		if (prlen + priority_len > sizeof(priority_list))
			prlen = sizeof(priority_list) - priority_len;

		memcpy(&priority_list[priority_len],
		    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].data,
		    prlen);
		priority_len += prlen;
		prl = priority_list;
	} else if (prl) {
@


1.15
log
@snprintf return value paranoia; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.14 2004/11/02 01:18:45 deraadt Exp $	*/
d53 1
a53 1
int	store_options(unsigned char *, int, struct tree_cache **,
d200 1
a200 1
    int mms, struct tree_cache **options,
d343 1
a343 1
store_options(unsigned char *buffer, int buflen, struct tree_cache **options,
d368 1
a368 1
		if (!options[code]) {
d381 1
a381 1
		length = options[code]->len;
d431 1
a431 1
				    options[code]->value + ix, incr - 1);
d435 1
a435 1
				    options[code]->value + ix, incr);
@


1.14
log
@delint gunk approved by otto a while back
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.13 2004/09/21 04:07:04 david Exp $	*/
d603 1
a603 1
				if (opcount >= opleft)
d611 1
a611 1
				if (opcount >= opleft)
d619 1
a619 1
				if (opcount >= opleft)
d627 1
a627 1
				if (opcount >= opleft)
d635 1
a635 1
				if (opcount >= opleft)
d641 1
a641 1
				if (opcount >= opleft)
d647 1
a647 1
				if (opcount >= opleft)
@


1.13
log
@spelling fixes; ok jmc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.12 2004/09/15 18:15:18 henning Exp $	*/
d316 1
a316 1
					outpacket->file[mainbufix++] = DHO_END;
d318 1
a318 1
					outpacket->file[mainbufix++] = DHO_PAD;
d331 1
a331 1
				outpacket->file[mainbufix++] = DHO_END;
d333 1
a333 1
				outpacket->file[mainbufix++] = DHO_PAD;
@


1.12
log
@no \n in error() calls and minor KNF, from Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.11 2004/05/06 22:29:15 deraadt Exp $	*/
d129 1
a129 1
		 * and mark the packet bad. Unfortuntely some crappy
@


1.11
log
@remove more unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.10 2004/05/04 22:23:01 mickey Exp $	*/
d461 1
a461 1
		error("pretty_print_option: bad code %d\n", code);
@


1.10
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 2004/05/04 20:28:40 deraadt Exp $	*/
a378 4

		/* Find the value of the option... */
		if (!tree_evaluate(options[code]))
			continue;
@


1.9
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.8 2004/04/14 20:22:27 henning Exp $	*/
d138 1
a138 1
			warn("option %s (%d) %s.",
d144 3
a146 3
				warn("Many bogus options seen in offers.");
				warn("Taking this offer in spite of bogus");
				warn("options - hope for the best!");
d148 1
a148 1
				warn("rejecting bogus offer.");
d475 1
a475 1
			warn("%s: Excess information in format string: %s",
d526 1
a526 1
			warn("%s: garbage in format string: %s",
d535 1
a535 1
		warn("%s: expecting at least %d bytes; got %d",
d541 1
a541 1
		warn("%s: %d extra bytes",
d549 1
a549 1
		warn("%s: %d extra bytes at end of array",
d663 1
a663 1
				warn("Unexpected format code %c", fmtbuf[j]);
d684 1
a684 1
	warn("dhcp option too large");
@


1.8
log
@get rif of the few dmalloc/dfree occurances that were left
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.7 2004/03/02 18:49:21 deraadt Exp $	*/
d105 2
a106 4
	unsigned char *s, *t;
	unsigned char *end = buffer + length;
	int len;
	int code;
d204 3
a206 7
	unsigned char priority_list[300];
	int priority_len;
	unsigned char buffer[4096];	/* Really big buffer... */
	int main_buffer_size;
	int mainbufix, bufix;
	int option_size;
	int length;
d347 1
a347 5
	int bufix = 0;
	int option_stored[256];
	int i;
	int ix;
	int tto;
d456 3
a458 7
	int hunksize = 0;
	int numhunk = -1;
	int numelem = 0;
	char fmtbuf[32];
	int i, j, k;
	char *op = optbuf;
	int opleft = sizeof(optbuf);
a461 1

@


1.7
log
@more pruning; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.6 2004/02/24 17:02:40 henning Exp $	*/
d160 1
a160 1
			if (!(t = dmalloc(len + 1, "parse_option_buffer")))
d177 1
a177 2
			t = dmalloc(len + packet->options[code].len + 1,
			    "parse_option_buffer");
d187 1
a187 2
			dfree(packet->options[code].data,
			    "parse_option_buffer");
d735 1
a735 1
			dfree(tp.options[i].data, "do_packet");
@


1.6
log
@zap more unused crap
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.5 2004/02/07 13:59:45 henning Exp $	*/
d77 2
a78 1
			     packet->packet_length - DHCP_FIXED_NON_UDP - 4);
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.4 2004/02/07 13:26:35 henning Exp $	*/
d50 6
@


1.4
log
@more KNF From: Emil Mikulic <emikulic@@dmr.ath.cx>
great job.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.3 2004/02/06 11:33:22 henning Exp $	*/
d155 1
a155 1
				       dhcp_options[code].name);
d221 1
a221 1
	        sizeof(u_int16_t)))
d569 1
a569 1
		        int opcount;
@


1.3
log
@more Knall & Rauch -> ANSI C, KNF and stuff that makes this a bit more
readable. no effect on the binary.
From: Emil Mikulic <emikulic@@dmr.ath.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.2 2004/02/04 12:16:56 henning Exp $	*/
d108 1
a108 1
			++s;
d153 1
a153 2
			if (!(t = ((unsigned char *)dmalloc(len + 1,
			    "parse_option_buffer"))))
d170 2
a171 3
			t = ((unsigned char *)dmalloc(len +
			    packet->options[code].len + 1,
			    "parse_option_buffer"));
d177 1
a177 1
			memcpy(t + packet->options [code].len,
d221 1
a221 1
	        sizeof (u_int16_t)))
d349 1
a349 1
	int option_stored [256];
d390 1
a390 1
		length = options[code] -> len;
d393 1
a393 1
		if (terminate && dhcp_options[code].format [0] == 't') {
d493 1
a493 1
		      case 'A':
d498 1
a498 1
		      case 'X':
d514 1
a514 1
		      case 't':
d519 3
a521 3
		      case 'I':
		      case 'l':
		      case 'L':
d524 2
a525 2
		      case 's':
		      case 'S':
d528 3
a530 3
		      case 'b':
		      case 'B':
		      case 'f':
d533 1
a533 1
		      case 'e':
d535 1
a535 1
		      default:
d571 1
a571 1
			      case 't':
d606 1
a606 1
			      case 'I':
d614 1
a614 1
			      case 'l':
d622 1
a622 1
			      case 'L':
d630 1
a630 1
			      case 's':
d638 1
a638 1
			      case 'S':
d646 1
a646 1
			      case 'b':
d653 1
a653 1
			      case 'B':
d659 1
a659 1
			      case 'x':
d665 1
a665 1
			      case 'f':
d672 1
a672 1
			      default:
@


1.2
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 2
a46 1
#include <ctype.h>
d51 5
a55 4
/* Parse all available options out of the specified packet. */

void parse_options (packet)
	struct packet *packet;
d58 1
a58 1
	memset (packet -> options, 0, sizeof (packet -> options));
d61 2
a62 2
	if (memcmp (packet -> raw -> options, DHCP_OPTIONS_COOKIE, 4)) {
		packet -> options_valid = 0;
d66 20
a85 18
	/* Go through the options field, up to the end of the packet
	   or the End field. */
	parse_option_buffer (packet, &packet -> raw -> options [4],
			     packet -> packet_length - DHCP_FIXED_NON_UDP - 4);
	/* If we parsed a DHCP Option Overload option, parse more
	   options out of the buffer(s) containing them. */
	if (packet -> options_valid
	    && packet -> options [DHO_DHCP_OPTION_OVERLOAD].data) {
		if (packet -> options [DHO_DHCP_OPTION_OVERLOAD].data [0] & 1)
			parse_option_buffer (packet,
					     (unsigned char *)
					     packet -> raw -> file,
					     sizeof packet -> raw -> file);
		if (packet -> options [DHO_DHCP_OPTION_OVERLOAD].data [0] & 2)
			parse_option_buffer (packet,
					     (unsigned char *)
					     packet -> raw -> sname,
					     sizeof packet -> raw -> sname);
d89 8
a96 8
/* Parse options out of the specified buffer, storing addresses of option
   values in packet -> options and setting packet -> options_valid if no
   errors are encountered. */

void parse_option_buffer (packet, buffer, length)
	struct packet *packet;
	unsigned char *buffer;
	int length;
d104 1
a104 1
		code = s [0];
d115 14
a128 11
			
		/* All other fields (except end, see above) have a
		   one-byte length. */
		len = s [1];

		/* If the length is outrageous, silently skip the
		 * rest, and mark the packet bad. Unfortuntely
		 * some crappy dhcp servers always seem to give
		 * us garbage on the end of a packet. so rather than
		 * keep refusing, give up and try to take one after
		 * seeing a few without anything good.
d133 3
a135 3
			warn ("option %s (%d) %s.",
			      dhcp_options [code].name, len,
			      "larger than buffer");
d137 1
a137 1
				packet -> options_valid = 1;
d139 3
a141 3
				warn ("Many bogus options seen in offers.");
				warn ("Taking this offer in spite of bogus");
				warn ("options - hope for the best!");
d143 2
a144 2
				warn ("rejecting bogus offer.");
				packet -> options_valid = 0;
d148 17
a164 13
		/* If we haven't seen this option before, just make
		   space for it and copy it there. */
		if (!packet -> options [code].data) {
			if (!(t = ((unsigned char *)
				   dmalloc (len + 1, "parse_option_buffer"))))
				error ("Can't allocate storage for option %s.",
				       dhcp_options [code].name);
			/* Copy and NUL-terminate the option (in case it's an
			   ASCII string. */
			memcpy (t, &s [2], len);
			t [len] = 0;
			packet -> options [code].len = len;
			packet -> options [code].data = t;
d166 8
a173 6
			/* If it's a repeat, concatenate it to whatever
			   we last saw.   This is really only required
			   for clients, but what the heck... */
			t = ((unsigned char *)
			     dmalloc (len + packet -> options [code].len + 1,
				      "parse_option_buffer"));
d175 11
a185 11
				error ("Can't expand storage for option %s.",
				       dhcp_options [code].name);
			memcpy (t, packet -> options [code].data,
				packet -> options [code].len);
			memcpy (t + packet -> options [code].len,
				&s [2], len);
			packet -> options [code].len += len;
			t [packet -> options [code].len] = 0;
			dfree (packet -> options [code].data,
			       "parse_option_buffer");
			packet -> options [code].data = t;
d189 1
a189 1
	packet -> options_valid = 1;
d192 10
a201 15
/* cons options into a big buffer, and then split them out into the
   three separate buffers if needed.  This allows us to cons up a set
   of vendor options using the same routine. */

int cons_options (inpacket, outpacket, mms,
		  options, overload, terminate, bootpp, prl, prl_len)
	struct packet *inpacket;
	struct dhcp_packet *outpacket;
	int mms;
	struct tree_cache **options;
	int overload;	/* Overload flags that may be set. */
	int terminate;
	int bootpp;
	u_int8_t *prl;
	int prl_len;
d203 1
a203 1
	unsigned char priority_list [300];
d205 1
a205 1
	unsigned char buffer [4096];	/* Really big buffer... */
d211 8
a218 5
	/* If the client has provided a maximum DHCP message size,
	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise
	   use up to the minimum IP MTU size (576 bytes). */
	/* XXX if a BOOTP client specifies a max message size, we will
	   honor it. */
d221 6
a226 11
	    inpacket -> options [DHO_DHCP_MAX_MESSAGE_SIZE].data &&
	    (inpacket -> options [DHO_DHCP_MAX_MESSAGE_SIZE].len >=
	     sizeof (u_int16_t)))
		mms = getUShort (inpacket -> options
				 [DHO_DHCP_MAX_MESSAGE_SIZE].data);

	/* If the client has provided a maximum DHCP message size,
	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise
	   use up to the minimum IP MTU size (576 bytes). */
	/* XXX if a BOOTP client specifies a max message size, we will
	   honor it. */
d234 2
a235 2
	if (main_buffer_size > sizeof buffer)
		main_buffer_size = sizeof buffer;
d239 10
a248 9
	priority_list [priority_len++] = DHO_DHCP_MESSAGE_TYPE;
	priority_list [priority_len++] = DHO_DHCP_SERVER_IDENTIFIER;
	priority_list [priority_len++] = DHO_DHCP_LEASE_TIME;
	priority_list [priority_len++] = DHO_DHCP_MESSAGE;

	/* If the client has provided a list of options that it wishes
	   returned, use it to prioritize.  Otherwise, prioritize
	   based on the default priority list. */

d250 9
a258 9
	    inpacket -> options [DHO_DHCP_PARAMETER_REQUEST_LIST].data) {
		int prlen = (inpacket ->
			     options [DHO_DHCP_PARAMETER_REQUEST_LIST].len);
		if (prlen + priority_len > sizeof priority_list)
			prlen = (sizeof priority_list) - priority_len;

		memcpy (&priority_list [priority_len],
			(inpacket -> options
			 [DHO_DHCP_PARAMETER_REQUEST_LIST].data), prlen);
d262 4
a265 4
		if (prl_len + priority_len > sizeof priority_list)
			prl_len = (sizeof priority_list) - priority_len;
		
		memcpy (&priority_list [priority_len], prl, prl_len);
d269 3
a271 3
		memcpy (&priority_list [priority_len],
			dhcp_option_default_priority_list,
			sizeof_dhcp_option_default_priority_list);
d276 7
a282 9
	option_size = store_options (buffer,
				     (main_buffer_size - 7 +
				      ((overload & 1) ? DHCP_FILE_LEN : 0) +
				      ((overload & 2) ? DHCP_SNAME_LEN : 0)),
				     options, priority_list, priority_len,
				     main_buffer_size,
				     (main_buffer_size +
				      ((overload & 1) ? DHCP_FILE_LEN : 0)),
				     terminate);
d285 1
a285 1
	memcpy (outpacket -> options, DHCP_OPTIONS_COOKIE, 4);
d288 5
a292 4
	/* If we're going to have to overload, store the overload
	   option at the beginning.  If we can, though, just store the
	   whole thing in the packet's option buffer and leave it at
	   that. */
d294 2
a295 2
		memcpy (&outpacket -> options [mainbufix],
			buffer, option_size);
d298 1
a298 2
			outpacket -> options [mainbufix++]
				= DHO_END;
d301 5
a305 5
		outpacket -> options [mainbufix++] =
			DHO_DHCP_OPTION_OVERLOAD;
		outpacket -> options [mainbufix++] = 1;
		if (option_size > main_buffer_size - mainbufix + DHCP_FILE_LEN)
			outpacket -> options [mainbufix++] = 3;
d307 1
a307 1
			outpacket -> options [mainbufix++] = 1;
d309 2
a310 2
		memcpy (&outpacket -> options [mainbufix],
			buffer, main_buffer_size - mainbufix);
d315 2
a316 2
				memcpy (outpacket -> file,
					&buffer [bufix], option_size - bufix);
d319 1
a319 2
					outpacket -> file [mainbufix++]
						= DHO_END;
d321 1
a321 2
					outpacket -> file [mainbufix++]
						= DHO_PAD;
d323 2
a324 2
				memcpy (outpacket -> file,
					&buffer [bufix], DHCP_FILE_LEN);
d329 2
a330 2
			memcpy (outpacket -> sname,
				&buffer [bufix], option_size - bufix);
d334 1
a334 2
				outpacket -> file [mainbufix++]
					= DHO_END;
d336 1
a336 2
				outpacket -> file [mainbufix++]
					= DHO_PAD;
d339 1
a339 1
	return length;
d342 7
a348 11
/* Store all the requested options into the requested buffer. */

int store_options (buffer, buflen, options, priority_list, priority_len,
		   first_cutoff, second_cutoff, terminate)
	unsigned char *buffer;
	int buflen;
	struct tree_cache **options;
	unsigned char *priority_list;
	int priority_len;
	int first_cutoff, second_cutoff;
	int terminate;
d357 1
a357 1
	memset (option_stored, 0, sizeof option_stored);
d359 4
a362 2
	/* Copy out the options in the order that they appear in the
	   priority list... */
d365 1
a365 1
		int code = priority_list [i];
d368 4
a371 2
		/* Number of bytes left to store (some may already
		   have been stored by a previous pass). */
d375 1
a375 1
		if (!options [code]) {
d379 5
a383 3
		/* The client could ask for things that are mandatory,
		   in which case we should avoid storing them twice... */
		if (option_stored [code])
d385 1
a385 1
		option_stored [code] = 1;
d388 1
a388 1
		if (!tree_evaluate (options [code])) {
a389 1
		}
d392 1
a392 1
		length = options [code] -> len;
d395 1
a395 1
		if (terminate && dhcp_options [code].format [0] == 't') {
d398 1
a398 1
		} else {
a399 1
		}
d403 7
a409 5
		/* If the option's length is more than 255, we must store it
		   in multiple hunks.   Store 255-byte hunks first.  However,
		   in any case, if the option data will cross a buffer
		   boundary, split it across that boundary. */

d416 5
a420 3
			/* If this hunk of the buffer will cross a
			   boundary, only go up to the boundary in this
			   pass. */
d425 1
a425 1
				 bufix + incr > second_cutoff)
d428 4
a431 2
			/* If this option is going to overflow the buffer,
			   skip it. */
d438 2
a439 2
			buffer [bufix] = code;
			buffer [bufix + 1] = incr;
d441 6
a446 8
				memcpy (buffer + bufix + 2,
					options [code] -> value + ix,
					incr - 1);
				buffer [bufix + 2 + incr - 1] = 0;
			} else {
				memcpy (buffer + bufix + 2,
					options [code] -> value + ix, incr);
			}
d452 1
a452 1
	return bufix;
d455 6
a460 8
/* Format the specified option so that a human can easily read it. */

char *pretty_print_option (code, data, len, emit_commas, emit_quotes)
	unsigned int code;
	unsigned char *data;
	int len;
	int emit_commas;
	int emit_quotes;
d462 1
a462 1
	static char optbuf [32768]; /* XXX */
d466 1
a466 1
	char fmtbuf [32];
d477 1
a477 1
		error ("pretty_print_option: bad code %d\n", code);
d483 1
a483 1
	
d485 1
a485 1
	for (i = 0; dhcp_options [code].format [i]; i++) {
d487 3
a489 3
			warn ("%s: Excess information in format string: %s",
			      dhcp_options [code].name,
			      &(dhcp_options [code].format [i]));
d493 2
a494 2
		fmtbuf [i] = dhcp_options [code].format [i];
		switch (dhcp_options [code].format [i]) {
d497 1
a497 1
			fmtbuf [i] = 0;
d501 3
a503 3
			for (k = 0; k < len; k++) {
				if (!isascii (data [k]) ||
				    !isprint (data [k]))
a504 1
			}
d506 1
a506 1
				fmtbuf [i] = 't';
d509 1
a509 1
				fmtbuf [i] = 'x';
d514 1
a514 1
			fmtbuf [i + 1] = 0;
d517 2
a518 2
			fmtbuf [i] = 't';
			fmtbuf [i + 1] = 0;
d538 3
a540 3
			warn ("%s: garbage in format string: %s",
			      dhcp_options [code].name,
			      &(dhcp_options [code].format [i]));
d542 1
a542 1
		} 
d547 3
a549 4
		warn ("%s: expecting at least %d bytes; got %d",
		      dhcp_options [code].name,
		      hunksize, len);
		return "<error>";
d553 2
a554 3
		warn ("%s: %d extra bytes",
		      dhcp_options [code].name,
		      len - hunksize);
d561 2
a562 3
		warn ("%s: %d extra bytes at end of array",
		      dhcp_options [code].name,
		      len - numhunk * hunksize);
d572 1
a572 1
			switch (fmtbuf [j]) {
d579 2
a580 2
					if (!isascii (*dp) ||
					    !isprint (*dp)) {
d589 4
a592 4
						   *dp == '\'' ||
						   *dp == '$' ||
						   *dp == '`' ||
						   *dp == '\\') {
d605 1
a605 1
				
d609 3
a611 4
				foo.s_addr = htonl(getULong (dp));
				opcount = strlcpy(op, inet_ntoa (foo),
			          opleft);
				if (opcount >= opleft) 
d617 3
a619 3
				opcount = snprintf(op, opleft,"%ld",
				  (long)getLong (dp));
				if (opcount >= opleft) 
d626 2
a627 2
				  (unsigned long)getULong (dp));
				if (opcount >= opleft) 
d634 2
a635 2
				  getShort (dp));
				if (opcount >= opleft) 
d642 2
a643 2
				  getUShort (dp));
				if (opcount >= opleft) 
d649 3
a651 3
				opcount = snprintf(op, opleft, "%d", 
				  *(char *)dp++);
				if (opcount >= opleft) 
d657 1
a657 1
				if (opcount >= opleft) 
d663 1
a663 1
				if (opcount >= opleft) 
d667 4
a670 4
			      case 'f': 
				opcount = strlcpy(op, 
				  *dp++ ? "true" : "false", opleft);
				if (opcount >= opleft) 
d675 1
a675 1
				warn ("Unexpected format code %c", fmtbuf [j]);
d677 1
a677 1
			op += strlen (op);
d692 1
a692 1
		
d694 1
a694 1
	return optbuf;
d696 2
a697 2
	warn ("dhcp option too large");
	return "<error>";			  
d700 3
a702 7
void do_packet (interface, packet, len, from_port, from, hfrom)
	struct interface_info *interface;
	struct dhcp_packet *packet;
	int len;
	unsigned int from_port;
	struct iaddr from;
	struct hardware *hfrom;
d707 2
a708 2
	if (packet -> hlen > sizeof packet -> chaddr) {
		note ("Discarding packet with invalid hlen.");
d712 1
a712 1
	memset (&tp, 0, sizeof tp);
d719 2
a720 2
	
	parse_options (&tp);
d722 2
a723 3
	    tp.options [DHO_DHCP_MESSAGE_TYPE].data)
		tp.packet_type =
			tp.options [DHO_DHCP_MESSAGE_TYPE].data [0];
d725 1
a725 1
		dhcp (&tp);
d727 1
a727 1
		bootp (&tp);
d730 3
a732 4
	for (i = 0; i < 256; i++) {
		if (tp.options [i].len && tp.options [i].data)
			dfree (tp.options [i].data, "do_packet");
	}
a733 1

@


1.1
log
@this is where dhclient will start surgery
@
text
@d1 1
a1 1
/* options.c
d3 1
a3 1
   DHCP options parsing and reassembly. */
@

