head	1.69;
access;
symbols
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.47.0.4
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.20
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.18
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.16
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.12
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.14
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.10
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10;
locks; strict;
comment	@ * @;


1.69
date	2017.09.20.18.28.14;	author krw;	state Exp;
branches;
next	1.68;
commitid	lF1Bh4R6j4Dc6sIb;

1.68
date	2017.09.20.15.14.52;	author krw;	state Exp;
branches;
next	1.67;
commitid	TLc0DJYIC7F763E7;

1.67
date	2017.09.20.15.02.47;	author krw;	state Exp;
branches;
next	1.66;
commitid	s0Koup1EK8gTKFSA;

1.66
date	2017.09.19.13.09.15;	author krw;	state Exp;
branches;
next	1.65;
commitid	IcLhrd4zmKnjfSAv;

1.65
date	2017.09.17.21.20.23;	author krw;	state Exp;
branches;
next	1.64;
commitid	qFZJVVBgDTJjGV1b;

1.64
date	2017.09.14.00.10.17;	author krw;	state Exp;
branches;
next	1.63;
commitid	3JGrbAkWeCalk5Am;

1.63
date	2017.07.24.16.17.35;	author krw;	state Exp;
branches;
next	1.62;
commitid	nGCLYHNGfubVs4Qc;

1.62
date	2017.07.14.16.35.59;	author krw;	state Exp;
branches;
next	1.61;
commitid	GZzVp5wPmIbGBmWl;

1.61
date	2017.07.14.16.21.03;	author krw;	state Exp;
branches;
next	1.60;
commitid	MneUE6JB4herdkKT;

1.60
date	2017.07.10.17.13.24;	author krw;	state Exp;
branches;
next	1.59;
commitid	kBYEloYpDyLW1Mqg;

1.59
date	2017.07.10.00.47.47;	author krw;	state Exp;
branches;
next	1.58;
commitid	NbrwpC5tx5StmvcS;

1.58
date	2017.07.09.19.19.58;	author krw;	state Exp;
branches;
next	1.57;
commitid	0BGOuT2HbB9sCm2t;

1.57
date	2017.07.08.00.36.10;	author krw;	state Exp;
branches;
next	1.56;
commitid	fG77ONbQ8YTfWdI4;

1.56
date	2017.07.07.15.14.47;	author krw;	state Exp;
branches;
next	1.55;
commitid	f8meVC01qYNRWhNX;

1.55
date	2017.07.03.22.06.11;	author krw;	state Exp;
branches;
next	1.54;
commitid	DrUWEMr4zqBudRa5;

1.54
date	2017.06.27.15.56.15;	author krw;	state Exp;
branches;
next	1.53;
commitid	YvxBSRakMluf2SaU;

1.53
date	2017.06.19.19.28.35;	author krw;	state Exp;
branches;
next	1.52;
commitid	ueq2M4294OXNv6H1;

1.52
date	2017.06.14.15.57.25;	author krw;	state Exp;
branches;
next	1.51;
commitid	xleVcb5KQcOBndeE;

1.51
date	2017.06.13.15.49.32;	author krw;	state Exp;
branches;
next	1.50;
commitid	OYT2CturRpIwAbZo;

1.50
date	2017.04.19.05.36.12;	author natano;	state Exp;
branches;
next	1.49;
commitid	0scK6D05EyEW7eqZ;

1.49
date	2017.04.18.13.59.09;	author krw;	state Exp;
branches;
next	1.48;
commitid	cFUzT9OoC4hYJl7A;

1.48
date	2017.04.18.13.44.03;	author krw;	state Exp;
branches;
next	1.47;
commitid	VyeVA5lKqovjNMHY;

1.47
date	2017.02.12.15.53.15;	author krw;	state Exp;
branches;
next	1.46;
commitid	YTCiHbXKpxvNuYuw;

1.46
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.45;
commitid	WchZmaQT4LJ4im5M;

1.45
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.44;
commitid	IDlzr3qamZK5lxzj;

1.44
date	2016.08.31.12.57.31;	author mpi;	state Exp;
branches;
next	1.43;
commitid	dRGzj71S05fFJodM;

1.43
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.42;
commitid	Tm7CrlqCKqgQoJ7P;

1.42
date	2016.07.23.15.53.19;	author stsp;	state Exp;
branches;
next	1.41;
commitid	TTaHvvpnzgDyaXre;

1.41
date	2016.07.19.17.23.20;	author krw;	state Exp;
branches;
next	1.40;
commitid	okxVGQawE5SK5RDk;

1.40
date	2016.05.08.08.20.50;	author natano;	state Exp;
branches;
next	1.39;
commitid	m6ORkv5QobVmEZci;

1.39
date	2016.05.03.07.47.26;	author natano;	state Exp;
branches;
next	1.38;
commitid	GaHdPfTlwWV99MZx;

1.38
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.37;
commitid	5ELOU0S0Zl3aCrHG;

1.37
date	2014.12.03.18.47.03;	author krw;	state Exp;
branches;
next	1.36;
commitid	3idZRlsmoDadoTmk;

1.36
date	2014.11.23.14.02.21;	author krw;	state Exp;
branches;
next	1.35;
commitid	TQpXaDPB2gC7POWf;

1.35
date	2014.11.08.22.08.01;	author krw;	state Exp;
branches;
next	1.34;
commitid	MH3D2VE3VfYOFp6X;

1.34
date	2014.11.08.19.30.30;	author krw;	state Exp;
branches;
next	1.33;
commitid	E2cE51GymcZ2zEdm;

1.33
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.32;
commitid	RKMpGS78lskgSHj4;

1.32
date	2014.04.17.09.59.30;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.12.12.00.22.06;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.12.06.23.40.48;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.11.21.00.01;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.02.16.35.27;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.05.19.31.36;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2013.02.14.20.39.46;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2013.02.03.21.04.19;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.29.14.40.00;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.04.19.24.02;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.15.13.05.23;	author phessler;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.08.02.51.13;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.04.22.30.57;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.04.22.17.48;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.26.21.19.52;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.27.19.32.17;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.26.17.35.35;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.29.17.26.28;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.05.14.28.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.04.22.23.01;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.04.18.58.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.02.18.49.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.24.17.26.43;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.24.13.36.13;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.24.13.08.26;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.23.18.21.15;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.17.59.22;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.11.35.59;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.12.16.56;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.01.18.26;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.18.01.26.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Make log messages more informative by using the
name of the function that failed and the significant
parameters. Distinguish between poll() errors and
problematic revents values.
@
text
@/*	$OpenBSD: bpf.c,v 1.68 2017/09/20 15:14:52 krw Exp $	*/

/* BPF socket interface code, originally contributed by Archie Cobbs. */

/*
 * Copyright (c) 1995, 1996, 1998, 1999
 * The Internet Software Consortium.    All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <net/bpf.h>
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/if_ether.h>

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"

int
get_bpf_sock(char *name)
{
	struct ifreq	 ifr;
	int		sock;

	if ((sock = open("/dev/bpf", O_RDWR | O_CLOEXEC)) == -1)
		fatal("open(/dev/bpf)");

	/* Set the BPF device to point at this interface. */
	strlcpy(ifr.ifr_name, name, IFNAMSIZ);
	if (ioctl(sock, BIOCSETIF, &ifr) == -1)
		fatal("BIOCSETIF");

	return sock;
}

int
get_udp_sock(int rdomain)
{
	int	 sock, on = 1;

	/*
	 * Use raw socket for unicast send.
	 */
	if ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_UDP)) == -1)
		fatal("socket(AF_INET, SOCK_RAW)");
	if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &on,
	    sizeof(on)) == -1)
		fatal("setsockopt(IP_HDRINCL)");
	if (setsockopt(sock, IPPROTO_IP, SO_RTABLE, &rdomain,
	    sizeof(rdomain)) == -1)
		fatal("setsockopt(SO_RTABLE)");

	return sock;
}

/*
 * Packet filter program.
 *
 * N.B.: Changes to the filter program may require changes to the
 * constant offsets used in if_register_receive to patch the BPF program!
 */
struct bpf_insn dhcp_bpf_filter[] = {
	/* Make sure this is an IP packet. */
	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 12),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_IP, 0, 8),

	/* Make sure it's a UDP packet. */
	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, 23),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 6),

	/* Make sure this isn't a fragment. */
	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 20),
	BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 4, 0),

	/* Get the IP header length. */
	BPF_STMT(BPF_LDX + BPF_B + BPF_MSH, 14),

	/* Make sure it's to the right port. */
	BPF_STMT(BPF_LD + BPF_H + BPF_IND, 16),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),		/* patch */

	/* If we passed all the tests, ask for the whole packet. */
	BPF_STMT(BPF_RET+BPF_K, (unsigned int)-1),

	/* Otherwise, drop it. */
	BPF_STMT(BPF_RET+BPF_K, 0),
};

int dhcp_bpf_filter_len = sizeof(dhcp_bpf_filter) / sizeof(struct bpf_insn);

/*
 * Packet write filter program:
 * 'ip and udp and src port bootps and dst port (bootps or bootpc)'
 */
struct bpf_insn dhcp_bpf_wfilter[] = {
	BPF_STMT(BPF_LD + BPF_B + BPF_IND, 14),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, (IPVERSION << 4) + 5, 0, 12),

	/* Make sure this is an IP packet. */
	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 12),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_IP, 0, 10),

	/* Make sure it's a UDP packet. */
	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, 23),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 8),

	/* Make sure this isn't a fragment. */
	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 20),
	BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 6, 0),	/* patched */

	/* Get the IP header length. */
	BPF_STMT(BPF_LDX + BPF_B + BPF_MSH, 14),

	/* Make sure it's from the right port. */
	BPF_STMT(BPF_LD + BPF_H + BPF_IND, 14),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 68, 0, 3),

	/* Make sure it is to the right ports. */
	BPF_STMT(BPF_LD + BPF_H + BPF_IND, 16),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),

	/* If we passed all the tests, ask for the whole packet. */
	BPF_STMT(BPF_RET+BPF_K, (unsigned int)-1),

	/* Otherwise, drop it. */
	BPF_STMT(BPF_RET+BPF_K, 0),
};

int dhcp_bpf_wfilter_len = sizeof(dhcp_bpf_wfilter) / sizeof(struct bpf_insn);

int
configure_bpf_sock(int bfdesc)
{
	struct bpf_version	 v;
	struct bpf_program	 p;
	int			 flag = 1, sz;

	/* Make sure the BPF version is in range. */
	if (ioctl(bfdesc, BIOCVERSION, &v) == -1)
		fatal("BIOCVERSION");

	if (v.bv_major != BPF_MAJOR_VERSION ||
	    v.bv_minor < BPF_MINOR_VERSION)
		fatalx("kernel BPF version out of range - recompile "
		    "dhclient");

	/*
	 * Set immediate mode so that reads return as soon as a packet
	 * comes in, rather than waiting for the input buffer to fill
	 * with packets.
	 */
	if (ioctl(bfdesc, BIOCIMMEDIATE, &flag) == -1)
		fatal("BIOCIMMEDIATE");

	if (ioctl(bfdesc, BIOCSFILDROP, &flag) == -1)
		fatal("BIOCSFILDROP");

	/* Get the required BPF buffer length from the kernel. */
	if (ioctl(bfdesc, BIOCGBLEN, &sz) == -1)
		fatal("BIOCGBLEN");

	/* Set up the bpf filter program structure. */
	p.bf_len = dhcp_bpf_filter_len;
	p.bf_insns = dhcp_bpf_filter;

	/* Patch the server port into the BPF program.
	 *
	 * N.B.: changes to filter program may require changes to the
	 * insn number(s) used below!
	 */
	dhcp_bpf_filter[8].k = LOCAL_PORT;

	if (ioctl(bfdesc, BIOCSETF, &p) == -1)
		fatal("BIOCSETF");

	/* Set up the bpf write filter program structure. */
	p.bf_len = dhcp_bpf_wfilter_len;
	p.bf_insns = dhcp_bpf_wfilter;

	if (dhcp_bpf_wfilter[7].k == 0x1fff)
		dhcp_bpf_wfilter[7].k = htons(IP_MF|IP_OFFMASK);

	if (ioctl(bfdesc, BIOCSETWF, &p) == -1)
		fatal("BIOCSETWF");

	if (ioctl(bfdesc, BIOCLOCK, NULL) == -1)
		fatal("BIOCLOCK");

	return sz;
}

ssize_t
send_packet(struct interface_info *ifi, struct in_addr from, struct in_addr to,
    const char *desc)
{
	struct iovec		 iov[4];
	struct sockaddr_in	 dest;
	struct ether_header	 eh;
	struct ip		 ip;
	struct udphdr		 udp;
	struct msghdr		 msg;
	struct dhcp_packet	*packet = &ifi->sent_packet;
	ssize_t			 result;
	unsigned int		 iovcnt = 0, i, total;
	int			 len = ifi->sent_packet_length;

	memset(&dest, 0, sizeof(dest));
	dest.sin_family = AF_INET;
	dest.sin_port = htons(REMOTE_PORT);
	dest.sin_addr.s_addr = to.s_addr;

	if (to.s_addr == INADDR_BROADCAST) {
		assemble_eh_header(ifi->hw_address, &eh);
		iov[0].iov_base = &eh;
		iov[0].iov_len = sizeof(eh);
		iovcnt++;
	}

	ip.ip_v = 4;
	ip.ip_hl = 5;
	ip.ip_tos = IPTOS_LOWDELAY;
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + len);
	ip.ip_id = 0;
	ip.ip_off = 0;
	ip.ip_ttl = 128;
	ip.ip_p = IPPROTO_UDP;
	ip.ip_sum = 0;
	ip.ip_src.s_addr = from.s_addr;
	ip.ip_dst.s_addr = to.s_addr;
	ip.ip_sum = wrapsum(checksum((unsigned char *)&ip, sizeof(ip), 0));
	iov[iovcnt].iov_base = &ip;
	iov[iovcnt].iov_len = sizeof(ip);
	iovcnt++;

	udp.uh_sport = htons(LOCAL_PORT);
	udp.uh_dport = htons(REMOTE_PORT);
	udp.uh_ulen = htons(sizeof(udp) + len);
	udp.uh_sum = 0;
	udp.uh_sum = wrapsum(checksum((unsigned char *)&udp, sizeof(udp),
	    checksum((unsigned char *)packet, len,
	    checksum((unsigned char *)&ip.ip_src,
	    2 * sizeof(ip.ip_src),
	    IPPROTO_UDP + (uint32_t)ntohs(udp.uh_ulen)))));
	iov[iovcnt].iov_base = &udp;
	iov[iovcnt].iov_len = sizeof(udp);
	iovcnt++;

	iov[iovcnt].iov_base = packet;
	iov[iovcnt].iov_len = len;
	iovcnt++;

	total = 0;
	for (i = 0; i < iovcnt; i++)
		total += iov[i].iov_len;

	if (to.s_addr == INADDR_BROADCAST) {
		result = writev(ifi->bfdesc, iov, iovcnt);
		if (result == -1)
			log_warn("%s: writev(%s)", log_procname, desc);
		else if (result < total) {
			result = -1;
			log_warnx("%s, writev(%s): %zd of %u bytes",
			    log_procname, desc, result, total);
		}
	} else {
		memset(&msg, 0, sizeof(msg));
		msg.msg_name = (struct sockaddr *)&dest;
		msg.msg_namelen = sizeof(dest);
		msg.msg_iov = iov;
		msg.msg_iovlen = iovcnt;
		result = sendmsg(ifi->ufdesc, &msg, 0);
		if (result == -1)
			log_warn("%s: sendmsg(%s)", log_procname, desc);
		else if (result < total) {
			result = -1;
			log_warnx("%s, sendmsg(%s): %zd of %u bytes",
			    log_procname, desc, result, total);
		}
	}

	return result;
}

ssize_t
receive_packet(struct interface_info *ifi, struct sockaddr_in *from,
    struct ether_addr *hfrom)
{
	struct bpf_hdr		 hdr;
	struct dhcp_packet	*packet = &ifi->recv_packet;
	ssize_t			 length = 0;
	int			 offset = 0;

	/*
	 * All this complexity is because BPF doesn't guarantee that
	 * only one packet will be returned at a time.  We're getting
	 * what we deserve, though - this is a terrible abuse of the BPF
	 * interface.  Sigh.
	 */

	/* Process packets until we get one we can return or until we've
	 * done a read and gotten nothing we can return.
	 */
	do {
		/* If the buffer is empty, fill it. */
		if (ifi->rbuf_offset >= ifi->rbuf_len) {
			length = read(ifi->bfdesc, ifi->rbuf, ifi->rbuf_max);
			if (length == -1) {
				log_warn("%s: read(bfdesc)", log_procname);
				return length;
			} else if (length == 0)
				return length;
			ifi->rbuf_offset = 0;
			ifi->rbuf_len = length;
		}

		/*
		 * If there isn't room for a whole bpf header, something
		 * went wrong, but we'll ignore it and hope it goes
		 * away. XXX
		 */
		if (ifi->rbuf_len - ifi->rbuf_offset < sizeof(hdr)) {
			ifi->rbuf_offset = ifi->rbuf_len;
			continue;
		}

		/* Copy out a bpf header. */
		memcpy(&hdr, &ifi->rbuf[ifi->rbuf_offset], sizeof(hdr));

		/*
		 * If the bpf header plus data doesn't fit in what's
		 * left of the buffer, stick head in sand yet again.
		 */
		if (ifi->rbuf_offset + hdr.bh_hdrlen + hdr.bh_caplen >
		    ifi->rbuf_len) {
			ifi->rbuf_offset = ifi->rbuf_len;
			continue;
		}

		/*
		 * If the captured data wasn't the whole packet, or if
		 * the packet won't fit in the input buffer, all we can
		 * do is drop it.
		 */
		if (hdr.bh_caplen != hdr.bh_datalen) {
			ifi->rbuf_offset = BPF_WORDALIGN(
			    ifi->rbuf_offset + hdr.bh_hdrlen +
			    hdr.bh_caplen);
			continue;
		}

		/* Skip over the BPF header. */
		ifi->rbuf_offset += hdr.bh_hdrlen;

		/* Decode the physical header. */
		offset = decode_hw_header(ifi->rbuf + ifi->rbuf_offset,
		    hdr.bh_caplen, hfrom);

		/*
		 * If a physical layer checksum failed (dunno of any
		 * physical layer that supports this, but WTH), skip
		 * this packet.
		 */
		if (offset < 0) {
			ifi->rbuf_offset = BPF_WORDALIGN(
			    ifi->rbuf_offset + hdr.bh_caplen);
			continue;
		}
		ifi->rbuf_offset += offset;
		hdr.bh_caplen -= offset;

		/* Decode the IP and UDP headers. */
		offset = decode_udp_ip_header(ifi->rbuf + ifi->rbuf_offset,
		    hdr.bh_caplen, from);

		/* If the IP or UDP checksum was bad, skip the packet. */
		if (offset < 0) {
			ifi->rbuf_offset = BPF_WORDALIGN(
			    ifi->rbuf_offset + hdr.bh_caplen);
			continue;
		}
		ifi->rbuf_offset += offset;
		hdr.bh_caplen -= offset;

		/*
		 * If there's not enough room to stash the packet data,
		 * we have to skip it (this shouldn't happen in real
		 * life, though).
		 */
		if (hdr.bh_caplen > sizeof(*packet)) {
			ifi->rbuf_offset = BPF_WORDALIGN(
			    ifi->rbuf_offset + hdr.bh_caplen);
			continue;
		}

		/* Copy out the data in the packet. */
		memset(packet, DHO_END, sizeof(*packet));
		memcpy(packet, ifi->rbuf + ifi->rbuf_offset, hdr.bh_caplen);
		ifi->rbuf_offset = BPF_WORDALIGN(ifi->rbuf_offset +
		    hdr.bh_caplen);
		return hdr.bh_caplen;
	} while (length == 0);
	return  0 ;
}
@


1.68
log
@Make send_packet() log entries more informative by
providing the name of the packet type that causes
an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.67 2017/09/20 15:02:47 krw Exp $	*/
d339 2
a340 1
	int			 length = 0, offset = 0;
d356 5
a360 2
			if (length <= 0)
				return  length ;
@


1.67
log
@Nuke a few extraneous blanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.66 2017/09/19 13:09:15 krw Exp $	*/
d242 2
a243 1
send_packet(struct interface_info *ifi, struct in_addr from, struct in_addr to)
d308 1
a308 1
			log_warn("%s: writev(bfdesc)", log_procname);
d311 2
a312 2
			log_warnx("%s, writev(bfdesc): %zd of %u bytes",
			    log_procname, result, total);
d322 1
a322 1
			log_warn("%s: sendmsg(ufdesc)", log_procname);
d325 2
a326 2
			log_warnx("%s, sendmsg(ufdesc): %zd of %u bytes",
			    log_procname, result, total);
@


1.66
log
@Make send_packet() usage consistent. i.e. don't exit
if send_packet(DISCOVER) fails.

Distinguish between writev() and sendmsg() errors in
send_packet() log messages.

Check for short writes no matter how the packet is
output. Return failure in this occurs. Check results
of all send_packet() calls.

If send_packet() fails, don't log that the DHCP message
was sent.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.65 2017/09/17 21:20:23 krw Exp $	*/
d444 1
a444 1
		return  hdr.bh_caplen ;
@


1.65
log
@Create global 'log_procname' and set it to '<ifname>' or
'<ifname> [priv]' as appropriate for the process doing the
setting. Use it as the prefix in all log_*() output. Makes
tracking messages for an interface or a process much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.64 2017/09/14 00:10:17 krw Exp $	*/
d252 2
a253 1
	int			 iovcnt = 0, len = ifi->sent_packet_length;
d300 4
d306 7
d320 7
a328 2
	if (result == -1)
		log_warn("%s: send_packet", log_procname);
@


1.64
log
@Strive to rationalize fatal[x]() usage and
verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.63 2017/07/24 16:17:35 krw Exp $	*/
d311 2
a312 2
		log_warn("send_packet");
	return result ;
@


1.63
log
@Tweak some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.62 2017/07/14 16:35:59 krw Exp $	*/
d75 1
a75 1
		fatal("Can't open bpf");
d80 1
a80 1
		fatal("Can't attach interface %s to /dev/bpf", name);
d94 1
a94 1
		fatal("socket(SOCK_RAW)");
d189 1
a189 1
		fatal("Can't get BPF version");
d193 2
a194 2
		fatalx("Kernel BPF version out of range - recompile "
		    "dhclient!");
d202 1
a202 1
		fatal("Can't set immediate mode on bpf device");
d205 1
a205 1
		fatal("Can't set filter-drop mode on bpf device");
d209 1
a209 1
		fatal("Can't get bpf buffer length");
d223 1
a223 1
		fatal("Can't install packet filter program");
d233 1
a233 1
		fatal("Can't install write filter program");
d236 1
a236 1
		fatal("Cannot lock bpf");
@


1.62
log
@"ioctl() < 0" ==> "ioctl() == -1" as god and guenther@@
intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.61 2017/07/14 16:21:03 krw Exp $	*/
a67 3
/*
 * Returns a packet filter socket fd on the interface.
 */
d108 1
a108 1
 * XXX: Changes to the filter program may require changes to the
d217 1
a217 1
	 * XXX: changes to filter program may require changes to the
@


1.61
log
@Replace remaining "!var" expressions with
"<var> == 0", "!(<var> & FLAG)" with
"(<var> & FLAG) == 0", "!<func()>"
with "<func()> == 0" and "!<define>" with
"<define> == 0". And the positive cases
as well.

A few stray == NULL and != NULL as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.60 2017/07/10 17:13:24 krw Exp $	*/
d82 1
a82 1
	if (ioctl(sock, BIOCSETIF, &ifr) < 0)
d191 1
a191 1
	if (ioctl(bfdesc, BIOCVERSION, &v) < 0)
d204 1
a204 1
	if (ioctl(bfdesc, BIOCIMMEDIATE, &flag) < 0)
d207 1
a207 1
	if (ioctl(bfdesc, BIOCSFILDROP, &flag) < 0)
d211 1
a211 1
	if (ioctl(bfdesc, BIOCGBLEN, &sz) < 0)
d225 1
a225 1
	if (ioctl(bfdesc, BIOCSETF, &p) < 0)
d235 1
a235 1
	if (ioctl(bfdesc, BIOCSETWF, &p) < 0)
d238 2
a239 2
	if (ioctl(bfdesc, BIOCLOCK, NULL) < 0)
		fatalx("Cannot lock bpf");
@


1.60
log
@Take some of the mystery out of who does what by
renaming "if_register_bpf()" to "get_bpf_sock()",
"if_register_send()" to "get_udp_sock()" and
"if_register_receive()" to "configure_bpf_sock()".

Pull back interface_info knowledge and just pass
the interface name, rdomain and bpf socket fd as
required.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.59 2017/07/10 00:47:47 krw Exp $	*/
d431 1
a431 1
	} while (!length);
@


1.59
log
@Use a modern spacious idiom on all function local variable
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.58 2017/07/09 19:19:58 krw Exp $	*/
a67 2
void if_register_bpf(struct interface_info *ifi);

d69 1
a69 3
 * Called by get_interface_list for each interface that's discovered.
 * Opens a packet filter for each interface and adds it to the select
 * mask.
d71 2
a72 2
void
if_register_bpf(struct interface_info *ifi)
d75 1
a75 1
	int		 sock;
d81 1
a81 1
	strlcpy(ifr.ifr_name, ifi->name, IFNAMSIZ);
d83 1
a83 1
		fatal("Can't attach interface %s to /dev/bpf", ifi->name);
d85 1
a85 1
	ifi->bfdesc = sock;
d88 2
a89 2
void
if_register_send(struct interface_info *ifi)
d101 2
a102 2
	if (setsockopt(sock, IPPROTO_IP, SO_RTABLE, &ifi->rdomain,
	    sizeof(ifi->rdomain)) == -1)
d105 1
a105 1
	ifi->ufdesc = sock;
d183 2
a184 2
void
if_register_receive(struct interface_info *ifi)
a189 3
	/* Open a BPF device and hang it on this interface. */
	if_register_bpf(ifi);

d191 1
a191 1
	if (ioctl(ifi->bfdesc, BIOCVERSION, &v) < 0)
d204 1
a204 1
	if (ioctl(ifi->bfdesc, BIOCIMMEDIATE, &flag) < 0)
d207 1
a207 1
	if (ioctl(ifi->bfdesc, BIOCSFILDROP, &flag) < 0)
d211 1
a211 1
	if (ioctl(ifi->bfdesc, BIOCGBLEN, &sz) < 0)
a212 7
	ifi->rbuf_max = sz;
	ifi->rbuf = malloc(ifi->rbuf_max);
	if (!ifi->rbuf)
		fatalx("Can't allocate %lu bytes for bpf input buffer.",
		    (unsigned long)ifi->rbuf_max);
	ifi->rbuf_offset = 0;
	ifi->rbuf_len = 0;
d225 1
a225 1
	if (ioctl(ifi->bfdesc, BIOCSETF, &p) < 0)
d235 1
a235 1
	if (ioctl(ifi->bfdesc, BIOCSETWF, &p) < 0)
d238 1
a238 1
	if (ioctl(ifi->bfdesc, BIOCLOCK, NULL) < 0)
d240 2
@


1.58
log
@Be consistent. "return (e);" -> "return e;"
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.57 2017/07/08 00:36:10 krw Exp $	*/
d78 2
a79 2
	struct ifreq ifr;
	int sock;
d95 1
a95 1
	int sock, on = 1;
d190 3
a192 3
	struct bpf_version v;
	struct bpf_program p;
	int flag = 1, sz;
d259 9
a267 9
	struct sockaddr_in dest;
	struct ether_header eh;
	struct ip ip;
	struct udphdr udp;
	struct iovec iov[4];
	struct msghdr msg;
	struct dhcp_packet *packet = &ifi->sent_packet;
	ssize_t result;
	int iovcnt = 0, len = ifi->sent_packet_length;
d334 3
a336 3
	struct dhcp_packet *packet = &ifi->recv_packet;
	int length = 0, offset = 0;
	struct bpf_hdr hdr;
@


1.57
log
@Always use uintNN_t instead of sometimes u_intNN_t
and sometimes uintNN_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.56 2017/07/07 15:14:47 krw Exp $	*/
d327 1
a327 1
	return (result);
d353 1
a353 1
				return (length);
d442 1
a442 1
		return (hdr.bh_caplen);
d444 1
a444 1
	return (0);
@


1.56
log
@assemble_eh_header() needs only to know about hw_addr.

No more struct interface_info knowledge in packet.c
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.55 2017/07/03 22:06:11 krw Exp $	*/
d139 1
a139 1
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
d179 1
a179 1
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
d305 1
a305 1
	    IPPROTO_UDP + (u_int32_t)ntohs(udp.uh_ulen)))));
@


1.55
log
@sizeof(struct sockaddr_in) != sizeof(struct in_addr).

Fix construction of the unicast UDP packets being sent
out via sendmsg(). Accidentally broken in r1.32 (5.6)
when types were juggled.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.54 2017/06/27 15:56:15 krw Exp $	*/
d275 1
a275 1
		assemble_eh_header(ifi, &eh);
@


1.54
log
@Make if_register_bpf() the same as the other if_register_*() functions
by directly assigning the socket fd to ifi->bfdesc rather than
returning it and having the caller do the assignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.53 2017/06/19 19:28:35 krw Exp $	*/
d319 1
a319 1
		msg.msg_namelen = sizeof(to);
@


1.53
log
@Various KNF nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.52 2017/06/14 15:57:25 krw Exp $	*/
d68 1
a68 1
int if_register_bpf(struct interface_info *ifi);
d75 1
a75 1
int
d89 1
a89 1
	return (sock);
d195 1
a195 1
	ifi->bfdesc = if_register_bpf(ifi);
@


1.52
log
@Start consolidating client_state into interface_info. First
fields to move: recv_packet, sent_packet and sent_packet_length.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.51 2017/06/13 15:49:32 krw Exp $	*/
d398 1
a398 1
		   hdr.bh_caplen, hfrom);
d415 1
a415 1
		   hdr.bh_caplen, from);
@


1.51
log
@Rename 'packet' field to 'recv_packet' and 'bootrequest_packet'
field to 'sent_packet'. Also 'bootrequest_packet_length' to
'sent_packet_length'.

Adopt consistent idiom of a local variable 'packet' to point at
packet being manipulated.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.50 2017/04/19 05:36:12 natano Exp $	*/
d265 1
a265 1
	struct dhcp_packet *packet = &ifi->client->sent_packet;
d267 1
a267 1
	int iovcnt = 0, len = ifi->client->sent_packet_length;
d334 1
a334 1
	struct dhcp_packet *packet = &ifi->client->recv_packet;
@


1.50
log
@Switch base tools from /dev/bpf0 to /dev/bpf. Now that /dev/bpf has been
around for two releases, it should be safe to do so.

ok bluhm deraadt sthen tb yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.49 2017/04/18 13:59:09 krw Exp $	*/
a258 1
	struct client_state *client = ifi->client;
d265 1
a265 1
	unsigned char *data;
d267 1
a267 1
	int iovcnt = 0, len;
a280 3
	data = (unsigned char *)&client->bootrequest_packet;
	len = client->bootrequest_packet_length;

d302 2
a303 1
	    checksum(data, len, checksum((unsigned char *)&ip.ip_src,
d310 1
a310 1
	iov[iovcnt].iov_base = data;
d334 1
a334 1
	struct client_state *client = ifi->client;
d431 1
a431 1
		if (hdr.bh_caplen > sizeof(client->packet)) {
d438 2
a439 3
		memset(&client->packet, DHO_END, sizeof(client->packet));
		memcpy(&client->packet, ifi->rbuf + ifi->rbuf_offset,
		    hdr.bh_caplen);
@


1.49
log
@Tweak parameters to decode_*, add a check or two, and thus gain most of the
sanity improvements reyk@@ recently put into dhcrelay to ensure no more than
the captured packet is processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.48 2017/04/18 13:44:03 krw Exp $	*/
d81 1
a81 1
	if ((sock = open("/dev/bpf0", O_RDWR | O_CLOEXEC)) == -1)
d87 1
a87 1
		fatal("Can't attach interface %s to /dev/bpf0", ifi->name);
@


1.48
log
@After 11 years of pondering about it I think that brookdavis@@freebsd.org
had it correct. Don't BPF_WORDALIGN() the value for the number of
bytes read() into the buffer. This could theoretically cause the
processing of 1 - 3 more bytes than were read.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.47 2017/02/12 15:53:15 krw Exp $	*/
d400 2
a401 1
		offset = decode_hw_header(ifi->rbuf, ifi->rbuf_offset, hfrom);
d417 2
a418 2
		offset = decode_udp_ip_header(ifi->rbuf,
		    ifi->rbuf_offset, from, hdr.bh_caplen);
@


1.47
log
@Eliminate most strerror() invocations by using log_warn() and fatal()
instead of log_warnx() and fatalx(). A few log_info() to log_warn()
for the same reason.

Suggested by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.46 2017/02/12 13:55:01 krw Exp $	*/
d353 1
a353 1
		if (ifi->rbuf_offset == ifi->rbuf_len) {
d358 1
a358 1
			ifi->rbuf_len = BPF_WORDALIGN(length);
@


1.46
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.45 2017/02/12 13:15:50 krw Exp $	*/
d82 1
a82 1
		fatalx("Can't open bpf: %s", strerror(errno));
d87 1
a87 2
		fatalx("Can't attach interface %s to /dev/bpf0: %s",
		    ifi->name, strerror(errno));
d101 1
a101 1
		fatalx("socket(SOCK_RAW): %s", strerror(errno));
d104 1
a104 1
		fatalx("setsockopt(IP_HDRINCL): %s", strerror(errno));
d107 1
a107 1
		fatalx("setsockopt(SO_RTABLE): %s", strerror(errno));
d199 1
a199 1
		fatalx("Can't get BPF version: %s", strerror(errno));
d212 1
a212 2
		fatalx("Can't set immediate mode on bpf device: %s",
		    strerror(errno));
d215 1
a215 2
		fatalx("Can't set filter-drop mode on bpf device: %s",
		    strerror(errno));
d219 1
a219 1
		fatalx("Can't get bpf buffer length: %s", strerror(errno));
d240 1
a240 2
		fatalx("Can't install packet filter program: %s",
		    strerror(errno));
d250 1
a250 2
		fatalx("Can't install write filter program: %s",
		    strerror(errno));
d329 1
a329 1
		log_warnx("send_packet: %s", strerror(errno));
@


1.45
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.44 2016/08/31 12:57:31 mpi Exp $	*/
d204 2
a205 1
		fatalx("Kernel BPF version out of range - recompile dhclient!");
@


1.44
log
@Remove the 'client' global and make it per-ifp.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.43 2016/08/23 09:26:02 mpi Exp $	*/
d66 1
d82 1
a82 1
		error("Can't open bpf: %s", strerror(errno));
d87 1
a87 1
		error("Can't attach interface %s to /dev/bpf0: %s",
d102 1
a102 1
		error("socket(SOCK_RAW): %s", strerror(errno));
d105 1
a105 1
		error("setsockopt(IP_HDRINCL): %s", strerror(errno));
d108 1
a108 1
		error("setsockopt(SO_RTABLE): %s", strerror(errno));
d200 1
a200 1
		error("Can't get BPF version: %s", strerror(errno));
d204 1
a204 1
		error("Kernel BPF version out of range - recompile dhclient!");
d212 1
a212 1
		error("Can't set immediate mode on bpf device: %s",
d216 1
a216 1
		error("Can't set filter-drop mode on bpf device: %s",
d221 1
a221 1
		error("Can't get bpf buffer length: %s", strerror(errno));
d225 1
a225 1
		error("Can't allocate %lu bytes for bpf input buffer.",
d242 1
a242 1
		error("Can't install packet filter program: %s",
d253 1
a253 1
		error("Can't install write filter program: %s",
d257 1
a257 1
		error("Cannot lock bpf");
d333 1
a333 1
		warning("send_packet: %s", strerror(errno));
@


1.43
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.42 2016/07/23 15:53:19 stsp Exp $	*/
d262 1
d340 1
@


1.42
log
@Back out the dhclient BPF change. There are DHCP servers out there which
send frames to the ethernet broadcast address, so this will need some more
thought and it's too late for 6.0.
Problem reported by Holger Mikolon.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.41 2016/07/19 17:23:20 krw Exp $	*/
d67 1
a67 1
int if_register_bpf(void);
d75 1
a75 1
if_register_bpf(void)
d93 1
a93 1
if_register_send(void)
d188 1
a188 1
if_register_receive(void)
d195 1
a195 1
	ifi->bfdesc = if_register_bpf();
d260 1
a260 1
send_packet(struct in_addr from, struct in_addr to)
d278 1
a278 1
		assemble_eh_header(&eh);
d336 2
a337 1
receive_packet(struct sockaddr_in *from, struct ether_addr *hfrom)
@


1.41
log
@Narrow the BPF read filter rules so only packets sent to the
interface's LLADDR pass. Rely on dhclient's existing ability to
detect and react to LLADDR changes.

This limits the number of packets that get dropped as a result of
dhclient setting BIOCSFILDROP on the bpf descriptor.

Problem with bridges and multiple dhclients noted by stsp@@.

ok mpi@@ stsp@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.40 2016/05/08 08:20:50 natano Exp $	*/
a116 6
 *
 * Adapted from script shown by
 *
 * tcpdump -d 'ether dst 00:00:00:00:00:00 ip proto \udp dst port 67'
 *
 * NOTE: tcpdump shows absolute jumps and relative jumps are required here!
a118 13
	/*
	 * Make sure this is directed to our MAC.
	 *     a) compare last 4 octets
	 *     b) compare first 2 octets
	 *
	 * NOTE: MAC value must be patched in!
	 */

	BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 2),
	BPF_JUMP(BPF_JMP + BPF_JEQ +  BPF_K, 0x00000000, 0, 12), /* patch */
	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 0),
	BPF_JUMP(BPF_JMP + BPF_JEQ +  BPF_K, 0x0000, 0, 10), /* patch */

a192 2
	uint32_t bits;
	uint16_t bits16;
d238 1
a238 7
	memcpy(&bits, ((uint8_t *)&ifi->hw_address) + 2, sizeof(bits));
	dhcp_bpf_filter[1].k = ntohl(bits);

	memcpy(&bits16, ((uint8_t *)&ifi->hw_address), sizeof(bits16));
	dhcp_bpf_filter[3].k = ntohs(bits16);

	dhcp_bpf_filter[12].k = LOCAL_PORT;
@


1.40
log
@Use /dev/bpf0 instead of /dev/bpf (without loop though), as suggested by
sthen@@. to make remote upgrades without media less painful.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.39 2016/05/03 07:47:26 natano Exp $	*/
d117 6
d125 13
d212 2
d259 7
a265 1
	dhcp_bpf_filter[8].k = LOCAL_PORT;
@


1.39
log
@Move to /dev/bpf; ok tb jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.38 2016/02/06 19:30:52 krw Exp $	*/
d80 1
a80 1
	if ((sock = open("/dev/bpf", O_RDWR | O_CLOEXEC)) == -1)
d86 1
a86 1
		error("Can't attach interface %s to /dev/bpf: %s",
@


1.38
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.37 2014/12/03 18:47:03 krw Exp $	*/
a66 2
#define BPF_FORMAT "/dev/bpf%d"

a76 1
	char filename[50];
d78 1
a78 1
	int sock, b;
d80 2
a81 13
	/* Open a BPF device */
	for (b = 0; 1; b++) {
		snprintf(filename, sizeof(filename), BPF_FORMAT, b);
		sock = open(filename, O_RDWR | O_CLOEXEC, 0);
		if (sock < 0) {
			if (errno == EBUSY)
				continue;
			else
				error("Can't find free bpf: %s",
				    strerror(errno));
		} else
			break;
	}
d86 2
a87 2
		error("Can't attach interface %s to %s: %s",
		    ifi->name, filename, strerror(errno));
@


1.37
log
@Correct comment to state that the BPF program is patched in
if_register_receive.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.36 2014/11/23 14:02:21 krw Exp $	*/
a42 1
#include "dhcpd.h"
d44 3
a46 1
#include <sys/uio.h>
d49 3
d54 12
@


1.36
log
@Cleanup some struct interface_info fields. Make 'nomedia' a flag. Replace
the two copies of the bpf socket descriptor (rfdesc, wfdesc) with
just one (bfdesc). No need to keep a struct ifreq (ifp) since it's
only used once and can be constructed there and discarded. Nuke
unused 'primary_address' member.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.35 2014/11/08 22:08:01 krw Exp $	*/
d114 1
a114 1
 * constant offsets used in if_register_send to patch the BPF program!
@


1.35
log
@Use open(O_CLOEXEC) rather than open() + fcntl(FD_CLOEXEC). Inspired
by and ok guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.34 2014/11/08 19:30:30 krw Exp $	*/
d64 1
d82 3
a84 2
	if (ioctl(sock, BIOCSETIF, ifi->ifp) < 0)
		error("Can't attach interface %s to bpf device %s: %s",
a95 6
	 * If we're using the bpf API for sending and receiving, we
	 * don't need to register this interface twice.
	 */
	ifi->wfdesc = ifi->rfdesc;

	/*
d193 1
a193 1
	ifi->rfdesc = if_register_bpf();
d196 1
a196 1
	if (ioctl(ifi->rfdesc, BIOCVERSION, &v) < 0)
d208 1
a208 1
	if (ioctl(ifi->rfdesc, BIOCIMMEDIATE, &flag) < 0)
d212 1
a212 1
	if (ioctl(ifi->rfdesc, BIOCSFILDROP, &flag) < 0)
d217 1
a217 1
	if (ioctl(ifi->rfdesc, BIOCGBLEN, &sz) < 0)
d238 1
a238 1
	if (ioctl(ifi->rfdesc, BIOCSETF, &p) < 0)
d249 1
a249 1
	if (ioctl(ifi->rfdesc, BIOCSETWF, &p) < 0)
d253 1
a253 1
	if (ioctl(ifi->rfdesc, BIOCLOCK, NULL) < 0)
d318 1
a318 1
		result = writev(ifi->wfdesc, iov, iovcnt);
d352 1
a352 1
			length = read(ifi->rfdesc, ifi->rbuf, ifi->rbuf_max);
@


1.34
log
@Exhort user to recompile 'dhclient', not 'dhcpd', when bpf versions are
mismatched.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.33 2014/10/25 03:18:13 lteo Exp $	*/
d69 1
a69 1
		sock = open(filename, O_RDWR, 0);
a197 1
	fcntl(ifi->rfdesc, F_SETFD, FD_CLOEXEC);
@


1.33
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.32 2014/04/17 09:59:30 krw Exp $	*/
d206 1
a206 1
		error("Kernel BPF version out of range - recompile dhcpd!");
@


1.32
log
@Eliminate a couple of always-NULL parameters. Eliminate some
pointless repetition of well-known info in log messages. Pass
around smaller bits of info. Make 'inaddr_any' a const struct
initialized with { INADDR_ANY }.

Tweaks and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.31 2013/12/12 00:22:06 krw Exp $	*/
a47 1
#include <netinet/in_systm.h>
@


1.31
log
@Assemble outgoing packets using iovec to combine the (optional)
ethernet header, the ip header, the udp header and the packet.
Rather than manually concatenating the headers and then using iovec
to bundle in the packet. Eliminates some memcpy()s and convoluted
data copying.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.30 2013/12/06 23:40:48 krw Exp $	*/
d264 1
a264 2
send_packet(struct in_addr from, struct sockaddr_in *to,
    struct ether_addr *hto)
d266 1
d276 7
a282 2
	if (to->sin_addr.s_addr == INADDR_BROADCAST) {
		assemble_eh_header(&eh, hto);
d301 1
a301 1
	ip.ip_dst.s_addr = to->sin_addr.s_addr;
d308 1
a308 1
	udp.uh_dport = to->sin_port;
d323 1
a323 1
	if (to->sin_addr.s_addr == INADDR_BROADCAST) {
d327 2
a328 2
		msg.msg_name = (struct sockaddr *)to;
		msg.msg_namelen = sizeof(*to);
@


1.30
log
@Having stopped pretending we handle anything but ethernet packets,
replace the 'struct hardware' abstraction layer and use 'struct
ether_addr' where hardware addresses are of interest.

ok matthew@@, confirmed by reyk@@ not to impact DHCP-over-IPSec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.29 2013/11/11 21:00:01 krw Exp $	*/
d267 4
a270 3
#define IOVCNT		2
	unsigned char buf[256];
	struct iovec iov[IOVCNT];
d272 1
d274 1
a274 1
	int bufp = 0;
d277 4
a280 1
		assemble_hw_header(buf, &bufp, hto);
d283 34
a316 9
	assemble_udp_ip_header(buf, &bufp, from.s_addr,
	    to->sin_addr.s_addr, to->sin_port,
	    (unsigned char *)&client->bootrequest_packet,
	    client->bootrequest_packet_length);

	iov[0].iov_base = (char *)buf;
	iov[0].iov_len = bufp;
	iov[1].iov_base = (char *)&client->bootrequest_packet;
	iov[1].iov_len = client->bootrequest_packet_length;
d319 1
a319 1
		result = writev(ifi->wfdesc, iov, IOVCNT);
d325 1
a325 1
		msg.msg_iovlen = IOVCNT;
@


1.29
log
@Shuffle function prototypes and extern declarations around to
put local functions prototypes and variables in their .c files, and
cross-file functions into .h files. Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.28 2013/05/02 16:35:27 krw Exp $	*/
d265 1
a265 1
    struct hardware *hto)
d305 1
a305 1
receive_packet(struct sockaddr_in *from, struct hardware *hfrom)
@


1.28
log
@Bunch of comment/whitespace cleanup. Eliminate some misleading or
pointless ones, make multiline comments readable, nuke '...' in
favour of '.', etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.27 2013/04/05 19:31:36 krw Exp $	*/
d53 2
@


1.27
log
@send_packet() and writev() return ssize_t, not int. Use correct
type to store the returned value. From dhill.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.26 2013/02/14 20:39:46 krw Exp $	*/
d114 1
a114 1
 * Packet filter program...
d120 1
a120 1
	/* Make sure this is an IP packet... */
d124 1
a124 1
	/* Make sure it's a UDP packet... */
d128 1
a128 1
	/* Make sure this isn't a fragment... */
d132 1
a132 1
	/* Get the IP header length... */
d135 1
a135 1
	/* Make sure it's to the right port... */
d156 1
a156 1
	/* Make sure this is an IP packet... */
d160 1
a160 1
	/* Make sure it's a UDP packet... */
d164 1
a164 1
	/* Make sure this isn't a fragment... */
d168 1
a168 1
	/* Get the IP header length... */
d171 1
a171 1
	/* Make sure it's from the right port... */
d175 1
a175 1
	/* Make sure it is to the right ports ... */
d195 1
a195 1
	/* Open a BPF device and hang it on this interface... */
d199 1
a199 1
	/* Make sure the BPF version is in range... */
d235 1
a235 1
	/* Patch the server port into the BPF program...
d316 1
a316 1
	 * done a read and gotten nothing we can return...
d331 1
a331 1
		 * away... XXX
d338 1
a338 1
		/* Copy out a bpf header... */
d343 1
a343 1
		 * left of the buffer, stick head in sand yet again...
d363 1
a363 1
		/* Skip over the BPF header... */
d366 1
a366 1
		/* Decode the physical header... */
d382 1
a382 1
		/* Decode the IP and UDP headers... */
d386 1
a386 1
		/* If the IP or UDP checksum was bad, skip the packet... */
d406 1
a406 1
		/* Copy out the data in the packet... */
@


1.26
log
@Don't rely on the packet buffer (client->packet) being preserved between
attempts to send DISCOVER or REQUEST packets. Some DHCP servers might
NAK the DISCOVER, or other nefarious packets arrive, between attempts
and overwrite the packet being sent. Create and use another buffer
for packets being sent.

Problem encountered by fgsch@@, who noticed that once the DISCOVER was
NAK'ed our dhclient sent a bunch of NAK's back to the server. Like it
thought they were DISCOVER messages.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.25 2013/02/03 21:04:19 krw Exp $	*/
d269 2
a270 1
	int result, bufp = 0;
@


1.25
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.24 2012/12/29 14:40:00 krw Exp $	*/
d277 2
a278 2
	    (unsigned char *)&client->packet,
	    client->packet_length);
d282 2
a283 2
	iov[1].iov_base = (char *)&client->packet;
	iov[1].iov_len = client->packet_length;
@


1.24
log
@Make HUP to either one of the processes cause a restart that will
have dhclient re-read dhclient.conf and get a new lease. Constrain
the filename passed to '-l' (alternate dhclient.lease.if location)
to be a regular file for the moment.

Original suggestion from phessler@@. Feedback from deraadt@@ and
espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.23 2012/12/04 19:24:02 krw Exp $	*/
d383 1
a383 1
		    ifi->rbuf_offset, from, NULL, hdr.bh_caplen);
@


1.23
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.22 2012/11/15 14:54:18 krw Exp $	*/
d197 1
@


1.22
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.21 2012/01/15 13:05:23 phessler Exp $	*/
d73 2
a74 1
				error("Can't find free bpf: %m");
d81 2
a82 2
		error("Can't attach interface %s to bpf device %s: %m",
		    ifi->name, filename);
d102 1
a102 1
		error("socket(SOCK_RAW): %m");
d105 1
a105 1
		error("setsockopt(IP_HDRINCL): %m");
d108 1
a108 1
		error("setsockopt(SO_RTABLE): %m");
d200 1
a200 1
		error("Can't get BPF version: %m");
d212 2
a213 1
		error("Can't set immediate mode on bpf device: %m");
d216 2
a217 1
		error("Can't set filter-drop mode on bpf device: %m");
d221 1
a221 1
		error("Can't get bpf buffer length: %m");
d242 2
a243 1
		error("Can't install packet filter program: %m");
d253 2
a254 1
		error("Can't install write filter program: %m");
d296 1
a296 1
		warning("send_packet: %m");
@


1.21
log
@Make dhclient use the correct rdomain for all requests for leases, not
just the first one.

from Joel Knight
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.20 2007/01/08 02:51:13 krw Exp $	*/
a50 1
#include <netinet/if_ether.h>
@


1.20
log
@Initialize incoming packet buffer with DHO_END (0xff) rather than
DHO_PAD (0x00) so that option scanning will terminate on hitting
initialized data rather than scanning and ignoring trailing
DHO_PAD characters.

Suggested by & ok stevesk
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.19 2007/01/04 22:30:57 krw Exp $	*/
d106 4
@


1.19
log
@Eliminate the 'len' parameter from send_packet() since it always
contains the global value client->packet_length. Use
client->packet_length. No functional change.

Suggested by stevesk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.18 2007/01/04 22:17:48 krw Exp $	*/
d397 1
a397 1
		bzero(&client->packet, sizeof(client->packet));
@


1.18
log
@Another round of cleanup. There is only one instance of struct
dhcp_packet and it is contained in the global *client. So don't pass
around pointers to a struct that contains a pointer to the dhcp_packet
instance. Just use the global client->packet. Eliminate unused struct
packet members and parameter lists accordingly.

No functional change.

Suggestions by stevesk@@. ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.17 2006/12/26 21:19:52 krw Exp $	*/
d253 1
a253 1
send_packet(size_t len, struct in_addr from, struct sockaddr_in *to,
d269 1
a269 1
	    len);
d274 1
a274 1
	iov[1].iov_len = len;
@


1.17
log
@Our dhclient only handles one interface. Simplify code by using the
single, global, instance of 'struct interface_info' (ifi) rather than
passing around pointers to it.

"I agree" henning@@

Testing moritz@@ stevesk@@, ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.16 2006/11/27 19:32:17 stevesk Exp $	*/
d253 2
a254 2
send_packet(struct dhcp_packet *raw, size_t len, struct in_addr from,
    struct sockaddr_in *to, struct hardware *hto)
d267 3
a269 1
	    to->sin_addr.s_addr, to->sin_port, (unsigned char *)raw, len);
d273 1
a273 1
	iov[1].iov_base = (char *)raw;
d293 1
a293 2
receive_packet(unsigned char *buf, size_t len, struct sockaddr_in *from,
    struct hardware *hfrom)
d390 1
a390 1
		if (hdr.bh_caplen > len) {
d397 2
a398 1
		memcpy(buf, ifi->rbuf + ifi->rbuf_offset,
@


1.16
log
@Recognize when we are sending to a unicast destination IP address and
instead of using BPF, which currently will always set the destination
MAC to broadcast, send using a SOCK_RAW socket and sendmsg() so the
frame has a unicast destination MAC.

Fixes an issue when using a bootp forwarder where unicast DHCPREQUESTs
are dropped at the router/gateway until we reach T2/REBINDING and
change the destination IP to broadcast.

ok henning@@ (but doesn't like using a raw socket for this)
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.15 2005/11/26 17:35:35 reyk Exp $	*/
d61 1
a61 1
if_register_bpf(struct interface_info *info)
d80 1
a80 1
	if (ioctl(sock, BIOCSETIF, info->ifp) < 0)
d82 1
a82 1
		    info->name, filename);
d88 1
a88 1
if_register_send(struct interface_info *info)
d96 1
a96 1
	info->wfdesc = info->rfdesc;
d106 1
a106 1
	info->ufdesc = sock;
d185 1
a185 1
if_register_receive(struct interface_info *info)
d192 1
a192 1
	info->rfdesc = if_register_bpf(info);
d195 1
a195 1
	if (ioctl(info->rfdesc, BIOCVERSION, &v) < 0)
d207 1
a207 1
	if (ioctl(info->rfdesc, BIOCIMMEDIATE, &flag) < 0)
d210 1
a210 1
	if (ioctl(info->rfdesc, BIOCSFILDROP, &flag) < 0)
d214 1
a214 1
	if (ioctl(info->rfdesc, BIOCGBLEN, &sz) < 0)
d216 3
a218 3
	info->rbuf_max = sz;
	info->rbuf = malloc(info->rbuf_max);
	if (!info->rbuf)
d220 3
a222 3
		    (unsigned long)info->rbuf_max);
	info->rbuf_offset = 0;
	info->rbuf_len = 0;
d235 1
a235 1
	if (ioctl(info->rfdesc, BIOCSETF, &p) < 0)
d245 1
a245 1
	if (ioctl(info->rfdesc, BIOCSETWF, &p) < 0)
d248 1
a248 1
	if (ioctl(info->rfdesc, BIOCLOCK, NULL) < 0)
d253 2
a254 3
send_packet(struct interface_info *interface, struct dhcp_packet *raw,
    size_t len, struct in_addr from, struct sockaddr_in *to,
    struct hardware *hto)
d263 1
a263 1
		assemble_hw_header(interface, buf, &bufp, hto);
d275 1
a275 1
		result = writev(interface->wfdesc, iov, IOVCNT);
d282 1
a282 1
		result = sendmsg(interface->ufdesc, &msg, 0);
d291 2
a292 2
receive_packet(struct interface_info *interface, unsigned char *buf,
    size_t len, struct sockaddr_in *from, struct hardware *hfrom)
d309 2
a310 3
		if (interface->rbuf_offset == interface->rbuf_len) {
			length = read(interface->rfdesc, interface->rbuf,
			    interface->rbuf_max);
d313 2
a314 2
			interface->rbuf_offset = 0;
			interface->rbuf_len = BPF_WORDALIGN(length);
d322 2
a323 3
		if (interface->rbuf_len - interface->rbuf_offset <
		    sizeof(hdr)) {
			interface->rbuf_offset = interface->rbuf_len;
d328 1
a328 2
		memcpy(&hdr, &interface->rbuf[interface->rbuf_offset],
		    sizeof(hdr));
d334 3
a336 3
		if (interface->rbuf_offset + hdr.bh_hdrlen + hdr.bh_caplen >
		    interface->rbuf_len) {
			interface->rbuf_offset = interface->rbuf_len;
d346 2
a347 2
			interface->rbuf_offset = BPF_WORDALIGN(
			    interface->rbuf_offset + hdr.bh_hdrlen +
d353 1
a353 1
		interface->rbuf_offset += hdr.bh_hdrlen;
d356 1
a356 2
		offset = decode_hw_header(interface->rbuf,
		    interface->rbuf_offset, hfrom);
d364 2
a365 2
			interface->rbuf_offset = BPF_WORDALIGN(
			    interface->rbuf_offset + hdr.bh_caplen);
d368 1
a368 1
		interface->rbuf_offset += offset;
d372 2
a373 2
		offset = decode_udp_ip_header(interface->rbuf,
		    interface->rbuf_offset, from, NULL, hdr.bh_caplen);
d377 2
a378 2
			interface->rbuf_offset = BPF_WORDALIGN(
			    interface->rbuf_offset + hdr.bh_caplen);
d381 1
a381 1
		interface->rbuf_offset += offset;
d390 2
a391 2
			interface->rbuf_offset = BPF_WORDALIGN(
			    interface->rbuf_offset + hdr.bh_caplen);
d396 1
a396 1
		memcpy(buf, interface->rbuf + interface->rbuf_offset,
d398 1
a398 1
		interface->rbuf_offset = BPF_WORDALIGN(interface->rbuf_offset +
@


1.15
log
@enable the bpf filter-drop option in dhclient

ok henning@@, tested by many others (tech@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.14 2005/07/29 17:26:28 krw Exp $	*/
d90 2
d97 10
d257 1
d259 2
a260 1
	struct iovec iov[2];
d263 4
a266 2
	/* Assemble the headers... */
	assemble_hw_header(interface, buf, &bufp, hto);
a269 1
	/* Fire it off */
d275 12
a286 2
	result = writev(interface->wfdesc, iov, 2);
	if (result < 0)
@


1.14
log
@Fix erroneous use of '=' instead of '+' that caused infinite loops
when skipping packets. Use BPF_WORDALIGN() to properly skip packets.
From Brooks Davis at FreeBSD.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.13 2004/05/05 14:28:58 deraadt Exp $	*/
d197 3
@


1.13
log
@bpf write filter, and lock
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.12 2004/05/04 22:23:01 mickey Exp $	*/
d288 1
a288 1
			interface->rbuf_len = length;
d322 3
a324 1
			interface->rbuf_offset += hdr.bh_hdrlen = hdr.bh_caplen;
d341 2
a342 1
			interface->rbuf_offset += hdr.bh_caplen;
d354 2
a355 1
			interface->rbuf_offset += hdr.bh_caplen;
d367 2
a368 1
			interface->rbuf_offset += hdr.bh_caplen;
d375 2
a376 1
		interface->rbuf_offset += hdr.bh_caplen;
@


1.12
log
@do not overload libc function names causing linker troubles
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.11 2004/05/04 18:58:50 deraadt Exp $	*/
d132 40
d222 13
@


1.11
log
@more shrink and lint fixes; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.10 2004/03/02 18:49:21 deraadt Exp $	*/
d206 1
a206 1
		warn("send_packet: %m");
@


1.10
log
@more pruning; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.9 2004/02/24 17:26:43 henning Exp $	*/
d185 3
a187 3
send_packet(struct interface_info *interface, struct packet *packet,
    struct dhcp_packet *raw, size_t len, struct in_addr from,
    struct sockaddr_in *to, struct hardware *hto)
d195 1
a195 1
	assemble_udp_ip_header(interface, buf, &bufp, from.s_addr,
d277 2
a278 2
		offset = decode_hw_header(interface,
		    interface->rbuf, interface->rbuf_offset, hfrom);
d293 1
a293 1
		offset = decode_udp_ip_header(interface, interface->rbuf,
@


1.9
log
@whack unused token ring code and a few empty functions
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.8 2004/02/24 13:36:13 henning Exp $	*/
d63 2
a64 2
	int	sock, b;
	char	filename[50];
d121 1
a121 1
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),             /* patch */
d135 3
a137 3
	int			flag = 1, sz;
	struct bpf_version	v;
	struct bpf_program	p;
d189 3
a191 4
	int		bufp = 0;
	unsigned char	buf[256];
	struct iovec	iov[2];
	int		result;
d214 2
a215 3
	int		length = 0;
	int		offset = 0;
	struct bpf_hdr	hdr;
d316 1
a316 1
			hdr.bh_caplen);
@


1.8
log
@remove dynamic port gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.7 2004/02/24 13:08:26 henning Exp $	*/
a55 14
 * Reinitializes the specified interface after an address change.   This
 * is not required for packet-filter APIs.
 */
void
if_reinitialize_send(struct interface_info *info)
{
}

void
if_reinitialize_receive(struct interface_info *info)
{
}

/*
d73 1
a73 6
			else {
				if (!b)
					error("No bpf devices.%s%s%s",
					    "   Please read the README",
					    " section for your operating",
					    " system.");
a74 1
			}
a131 14
struct bpf_insn dhcp_bpf_tr_filter[] = {
        /* accept all token ring packets due to variable length header */
        /* if we want to get clever, insert the program here */

	/* If we passed all the tests, ask for the whole packet. */
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),

	/* Otherwise, drop it. */
	BPF_STMT(BPF_RET+BPF_K, 0),
};

int dhcp_bpf_tr_filter_len =
    sizeof(dhcp_bpf_tr_filter) / sizeof(struct bpf_insn);

a322 12
}

int
can_unicast_without_arp(void)
{
	return (1);
}

int
can_receive_unicast_unconfigured(struct interface_info *ip)
{
	return (1);
@


1.7
log
@cut more crap - no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.6 2004/02/23 18:21:15 henning Exp $	*/
d212 1
a212 1
	dhcp_bpf_filter[8].k = ntohs(local_port);
@


1.6
log
@dhclient always uses bpf on openbsd no matter what, it works, and we don't
need to fallback to their raw socket code
suddenly dhclient is so fast...
pb tested and sez ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.5 2004/02/07 17:59:22 henning Exp $	*/
d52 2
@


1.5
log
@shut it up a bit more
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.4 2004/02/07 11:35:59 henning Exp $	*/
a225 4
	if (!strcmp(interface->name, "fallback"))
		return (send_fallback(interface, packet, raw,
		    len, from, to, hto));

a366 13
}

void
maybe_setup_fallback(void)
{
	struct interface_info	*fbi;

	fbi = setup_fallback();
	if (fbi) {
		if_register_fallback(fbi);
		add_protocol("fallback", fallback_interface->wfdesc,
		    fallback_discard, fallback_interface);
	}
@


1.4
log
@more style fixes from Emil Mikulic <emikulic@@dmr.ath.cx>
Thank you very much for this excellent work, it helps a lot.
binary unchanged.
I am still convinced dhclient can be made readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.3 2004/02/04 12:16:56 henning Exp $	*/
a112 10

	if (!quiet_interface_discovery)
		note("Sending on   BPF/%s/%s%s%s",
		    info->name,
		    print_hw_addr(info->hw_address.htype,
		    info->hw_address.hlen,
		    info->hw_address.haddr),
		    (info->shared_network ? "/" : ""),
		    (info->shared_network ?
		    info->shared_network->name : ""));
a213 9
	if (!quiet_interface_discovery)
		note("Listening on BPF/%s/%s%s%s",
		    info->name,
		    print_hw_addr(info->hw_address.htype,
		    info->hw_address.hlen,
		    info->hw_address.haddr),
		    (info->shared_network ? "/" : ""),
		    (info->shared_network ?
		    info->shared_network->name : ""));
@


1.3
log
@$OpenBSD$, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a47 1

d53 4
a56 3
/* Reinitializes the specified interface after an address change.   This
   is not required for packet-filter APIs. */

d67 5
a71 4
/* Called by get_interface_list for each interface that's discovered.
   Opens a packet filter for each interface and adds it to the select
   mask. */

d108 4
a111 3
	/* If we're using the bpf API for sending and receiving,
	   we don't need to register this interface twice. */

d125 7
a131 5
/* Packet filter program...
   XXX Changes to the filter program may require changes to the constant
   offsets used in if_register_send to patch the BPF program! XXX */

struct bpf_insn dhcp_bpf_filter [] = {
d160 1
a160 1
struct bpf_insn dhcp_bpf_tr_filter [] = {
d172 1
a172 1
    (sizeof(dhcp_bpf_tr_filter) / sizeof(struct bpf_insn));
d192 5
a196 3
	/* Set immediate mode so that reads return as soon as a packet
	   comes in, rather than waiting for the input buffer to fill with
	   packets. */
d215 5
a219 3
        /* Patch the server port into the BPF  program...
	   XXX changes to filter program may require changes
	   to the insn number(s) used below! XXX */
a234 1

d263 1
a263 1
	return result;
d274 6
a279 4
	/* All this complexity is because BPF doesn't guarantee
	   that only one packet will be returned at a time.   We're
	   getting what we deserve, though - this is a terrible abuse
	   of the BPF interface. Sigh. */
d282 2
a283 2
	   done a read and gotten nothing we can return... */

d295 7
a301 3
		/* If there isn't room for a whole bpf header, something went
		   wrong, but we'll ignore it and hope it goes away... XXX */
		if (interface->rbuf_len - interface->rbuf_offset < sizeof hdr) {
d307 1
a307 1
		memcpy(&hdr, &interface->rbuf [interface->rbuf_offset],
d310 4
a313 2
		/* If the bpf header plus data doesn't fit in what's left
		   of the buffer, stick head in sand yet again... */
d320 5
a324 3
		/* If the captured data wasn't the whole packet, or if
		   the packet won't fit in the input buffer, all we
		   can do is drop it. */
d334 1
a334 1
		offset = decode_hw_header (interface,
d337 5
a341 3
		/* If a physical layer checksum failed (dunno of any
		   physical layer that supports this, but WTH), skip this
		   packet. */
d350 1
a350 1
		offset = decode_udp_ip_header (interface, interface->rbuf,
d361 5
a365 3
		/* If there's not enough room to stash the packet data,
		   we have to skip it (this shouldn't happen in real
		   life, though). */
d375 1
a375 1
		return hdr.bh_caplen;
@


1.2
log
@8579 lines of KNF, ANSO and zap-junk diff without the resulting binary
changing by a single byte.
partly from theo
@
text
@d1 1
a1 1
/* bpf.c
d3 1
a3 1
   BPF socket interface code, originally contributed by Archie Cobbs. */
@


1.1
log
@this is where dhclient will start surgery
@
text
@d56 2
a57 2
void if_reinitialize_send (info)
	struct interface_info *info;
d61 2
a62 2
void if_reinitialize_receive (info)
	struct interface_info *info;
d70 2
a71 2
int if_register_bpf (info)
	struct interface_info *info;
d73 2
a74 3
	int sock;
	char filename[50];
	int b;
d79 1
a79 1
		sock = open (filename, O_RDWR, 0);
d81 1
a81 1
			if (errno == EBUSY) {
d83 1
a83 1
			} else {
d85 5
a89 5
					error ("No bpf devices.%s%s%s",
					       "   Please read the README",
					       " section for your operating",
					       " system.");
				error ("Can't find free bpf: %m");
d91 1
a91 1
		} else {
a92 1
		}
d96 3
a98 3
	if (ioctl (sock, BIOCSETIF, info -> ifp) < 0)
		error ("Can't attach interface %s to bpf device %s: %m",
		       info -> name, filename);
d100 1
a100 1
	return sock;
d103 2
a104 2
void if_register_send (info)
	struct interface_info *info;
d109 1
a109 1
	info -> wfdesc = info -> rfdesc;
d112 8
a119 8
		note ("Sending on   BPF/%s/%s%s%s",
		      info -> name,
		      print_hw_addr (info -> hw_address.htype,
				     info -> hw_address.hlen,
				     info -> hw_address.haddr),
		      (info -> shared_network ? "/" : ""),
		      (info -> shared_network ?
		       info -> shared_network -> name : ""));
d128 2
a129 2
	BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 12),
	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_IP, 0, 8),
d132 2
a133 2
	BPF_STMT (BPF_LD + BPF_B + BPF_ABS, 23),
	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 6),
d140 1
a140 1
	BPF_STMT (BPF_LDX + BPF_B + BPF_MSH, 14),
d143 2
a144 2
	BPF_STMT (BPF_LD + BPF_H + BPF_IND, 16),
	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),             /* patch */
d153 1
a153 1
int dhcp_bpf_filter_len = sizeof dhcp_bpf_filter / sizeof (struct bpf_insn);
d166 2
a167 2
int dhcp_bpf_tr_filter_len = (sizeof dhcp_bpf_tr_filter /
			      sizeof (struct bpf_insn));
d169 2
a170 2
void if_register_receive (info)
	struct interface_info *info;
d172 3
a174 3
	int flag = 1, sz;
	struct bpf_version v;
	struct bpf_program p;
d177 1
a177 1
	info -> rfdesc = if_register_bpf (info);
d180 2
a181 2
	if (ioctl (info -> rfdesc, BIOCVERSION, &v) < 0)
		error ("Can't get BPF version: %m");
d185 1
a185 1
		error ("Kernel BPF version out of range - recompile dhcpd!");
d190 2
a191 2
	if (ioctl (info -> rfdesc, BIOCIMMEDIATE, &flag) < 0)
		error ("Can't set immediate mode on bpf device: %m");
d194 2
a195 2
	if (ioctl (info -> rfdesc, BIOCGBLEN, &sz) < 0)
		error ("Can't get bpf buffer length: %m");
d197 6
a202 6
	info -> rbuf = malloc (info -> rbuf_max);
	if (!info -> rbuf)
		error ("Can't allocate %lu bytes for bpf input buffer.",
		    (unsigned long) info -> rbuf_max);
	info -> rbuf_offset = 0;
	info -> rbuf_len = 0;
d211 1
a211 1
	dhcp_bpf_filter [8].k = ntohs (local_port);
d213 2
a214 2
	if (ioctl (info -> rfdesc, BIOCSETF, &p) < 0)
		error ("Can't install packet filter program: %m");
d216 8
a223 8
		note ("Listening on BPF/%s/%s%s%s",
		      info -> name,
		      print_hw_addr (info -> hw_address.htype,
				     info -> hw_address.hlen,
				     info -> hw_address.haddr),
		      (info -> shared_network ? "/" : ""),
		      (info -> shared_network ?
		       info -> shared_network -> name : ""));
d227 4
a230 8
ssize_t send_packet (interface, packet, raw, len, from, to, hto)
	struct interface_info *interface;
	struct packet *packet;
	struct dhcp_packet *raw;
	size_t len;
	struct in_addr from;
	struct sockaddr_in *to;
	struct hardware *hto;
d232 8
a239 8
	int bufp = 0;
	unsigned char buf [256];
	struct iovec iov [2];
	int result;

	if (!strcmp (interface -> name, "fallback"))
		return send_fallback (interface, packet, raw,
				      len, from, to, hto);
d242 3
a244 4
	assemble_hw_header (interface, buf, &bufp, hto);
	assemble_udp_ip_header (interface, buf, &bufp, from.s_addr,
				to -> sin_addr.s_addr, to -> sin_port,
				(unsigned char *)raw, len);
d247 4
a250 4
	iov [0].iov_base = (char *)buf;
	iov [0].iov_len = bufp;
	iov [1].iov_base = (char *)raw;
	iov [1].iov_len = len;
d252 1
a252 1
	result = writev(interface -> wfdesc, iov, 2);
d254 1
a254 1
		warn ("send_packet: %m");
d258 3
a260 6
ssize_t receive_packet (interface, buf, len, from, hfrom)
	struct interface_info *interface;
	unsigned char *buf;
	size_t len;
	struct sockaddr_in *from;
	struct hardware *hfrom;
d262 3
a264 3
	int length = 0;
	int offset = 0;
	struct bpf_hdr hdr;
d269 1
a269 1
	   of the BPF interface.   Sigh. */
d276 3
a278 4
		if (interface -> rbuf_offset == interface -> rbuf_len) {
			length = read (interface -> rfdesc,
				       interface -> rbuf,
				       interface -> rbuf_max);
d280 3
a282 3
				return length;
			interface -> rbuf_offset = 0;
			interface -> rbuf_len = length;
d287 2
a288 3
		if (interface -> rbuf_len -
		    interface -> rbuf_offset < sizeof hdr) {
			interface -> rbuf_offset = interface -> rbuf_len;
d293 2
a294 2
		memcpy (&hdr, &interface -> rbuf [interface -> rbuf_offset],
			sizeof hdr);
d298 3
a300 3
		if (interface -> rbuf_offset +
		    hdr.bh_hdrlen + hdr.bh_caplen > interface -> rbuf_len) {
			interface -> rbuf_offset = interface -> rbuf_len;
d308 1
a308 2
			interface -> rbuf_offset +=
				hdr.bh_hdrlen = hdr.bh_caplen;
d313 1
a313 1
		interface -> rbuf_offset += hdr.bh_hdrlen;
d317 1
a317 3
					   interface -> rbuf,
					   interface -> rbuf_offset,
					   hfrom);
d323 1
a323 1
			interface -> rbuf_offset += hdr.bh_caplen;
d326 1
a326 1
		interface -> rbuf_offset += offset;
d330 2
a331 6
		offset = decode_udp_ip_header (interface,
					       interface -> rbuf,
					       interface -> rbuf_offset,
					       from,
					       (unsigned char *)0,
					       hdr.bh_caplen);
d335 1
a335 1
			interface -> rbuf_offset += hdr.bh_caplen;
d338 1
a338 1
		interface -> rbuf_offset += offset;
d345 1
a345 1
			interface -> rbuf_offset += hdr.bh_caplen;
d350 1
a350 1
		memcpy (buf, interface -> rbuf + interface -> rbuf_offset,
d352 1
a352 1
		interface -> rbuf_offset += hdr.bh_caplen;
d355 1
a355 1
	return 0;
d358 2
a359 1
int can_unicast_without_arp ()
d361 1
a361 1
	return 1;
d364 2
a365 2
int can_receive_unicast_unconfigured (ip)
	struct interface_info *ip;
d367 1
a367 1
	return 1;
d370 2
a371 1
void maybe_setup_fallback ()
d373 3
a375 2
	struct interface_info *fbi;
	fbi = setup_fallback ();
d377 3
a379 3
		if_register_fallback (fbi);
		add_protocol ("fallback", fallback_interface -> wfdesc,
			      fallback_discard, fallback_interface);
@

