head	1.145;
access;
symbols
	OPENBSD_6_1:1.85.0.4
	OPENBSD_6_1_BASE:1.85
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.75.0.6
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40;
locks; strict;
comment	@ * @;


1.145
date	2017.09.08.13.49.00;	author krw;	state Exp;
branches;
next	1.144;
commitid	CWgspzzFJswDSQ6R;

1.144
date	2017.08.31.17.01.48;	author krw;	state Exp;
branches;
next	1.143;
commitid	Io9PJ6ZdGzFnk3Lv;

1.143
date	2017.08.29.13.21.30;	author krw;	state Exp;
branches;
next	1.142;
commitid	DF5M9Qv5Ozjx2LYr;

1.142
date	2017.08.26.18.52.56;	author krw;	state Exp;
branches;
next	1.141;
commitid	N5vpnWLlzYU0HMUK;

1.141
date	2017.08.26.15.36.25;	author krw;	state Exp;
branches;
next	1.140;
commitid	aSxOxq85iRg8ScEy;

1.140
date	2017.08.26.15.31.00;	author krw;	state Exp;
branches;
next	1.139;
commitid	K7lhiIwWZ9bBcGGm;

1.139
date	2017.08.18.15.06.11;	author krw;	state Exp;
branches;
next	1.138;
commitid	go8RiY20GnvQP02J;

1.138
date	2017.08.14.22.12.59;	author krw;	state Exp;
branches;
next	1.137;
commitid	X1TqQxYN09tBvtV8;

1.137
date	2017.08.12.16.57.38;	author krw;	state Exp;
branches;
next	1.136;
commitid	jGTi8EOBzAFijRJv;

1.136
date	2017.08.10.17.15.05;	author krw;	state Exp;
branches;
next	1.135;
commitid	jlDoPkMXimQCh050;

1.135
date	2017.08.09.19.57.54;	author krw;	state Exp;
branches;
next	1.134;
commitid	uK2NOPC0bxwOutY4;

1.134
date	2017.08.08.17.54.24;	author krw;	state Exp;
branches;
next	1.133;
commitid	1nTMhlFbQaELsZ7R;

1.133
date	2017.08.08.17.20.09;	author krw;	state Exp;
branches;
next	1.132;
commitid	zMQcHj1c1fM43KMy;

1.132
date	2017.08.06.22.05.16;	author krw;	state Exp;
branches;
next	1.131;
commitid	BV8L15eJrhGqz1k3;

1.131
date	2017.08.05.13.39.17;	author krw;	state Exp;
branches;
next	1.130;
commitid	mFp3JS3AVd8aCoxc;

1.130
date	2017.08.05.12.35.17;	author krw;	state Exp;
branches;
next	1.129;
commitid	MiblZ5ktpRO7eVny;

1.129
date	2017.08.05.12.08.33;	author krw;	state Exp;
branches;
next	1.128;
commitid	sohuOPL2515411W8;

1.128
date	2017.08.04.00.10.14;	author krw;	state Exp;
branches;
next	1.127;
commitid	KDcQR7y4TkqptGdP;

1.127
date	2017.08.03.14.53.22;	author krw;	state Exp;
branches;
next	1.126;
commitid	JXuCb9fMRD6ebaNq;

1.126
date	2017.08.03.00.33.07;	author krw;	state Exp;
branches;
next	1.125;
commitid	p9t3UF5kbIcjbRcO;

1.125
date	2017.08.02.13.07.48;	author krw;	state Exp;
branches;
next	1.124;
commitid	5ks94Ekycfyl5Sn0;

1.124
date	2017.07.30.15.26.46;	author krw;	state Exp;
branches;
next	1.123;
commitid	lr0mi3Mj4EhnFCwr;

1.123
date	2017.07.30.14.05.41;	author krw;	state Exp;
branches;
next	1.122;
commitid	iAU1SnznAtqZok6U;

1.122
date	2017.07.29.15.07.47;	author krw;	state Exp;
branches;
next	1.121;
commitid	fs7wm6LApZTZyE2c;

1.121
date	2017.07.27.12.52.58;	author krw;	state Exp;
branches;
next	1.120;
commitid	3073mD9qs0fROiAV;

1.120
date	2017.07.27.12.45.06;	author krw;	state Exp;
branches;
next	1.119;
commitid	RkpsTm8vUpdi2W1u;

1.119
date	2017.07.26.13.22.03;	author krw;	state Exp;
branches;
next	1.118;
commitid	m4AZr2ew2wCVwxae;

1.118
date	2017.07.24.18.13.19;	author krw;	state Exp;
branches;
next	1.117;
commitid	xjcyncKfDSt3Q91S;

1.117
date	2017.07.24.17.15.41;	author krw;	state Exp;
branches;
next	1.116;
commitid	FSXpMhxAeFtIckUQ;

1.116
date	2017.07.24.13.51.43;	author krw;	state Exp;
branches;
next	1.115;
commitid	jsqXn4fMPFV7qq60;

1.115
date	2017.07.24.11.00.01;	author friehm;	state Exp;
branches;
next	1.114;
commitid	LhKZV4SjfogJNr88;

1.114
date	2017.07.23.13.44.53;	author krw;	state Exp;
branches;
next	1.113;
commitid	Q8jsydlNiyf4AeZW;

1.113
date	2017.07.22.17.55.20;	author krw;	state Exp;
branches;
next	1.112;
commitid	1O4BY8IJfs1mMEfs;

1.112
date	2017.07.22.14.56.27;	author krw;	state Exp;
branches;
next	1.111;
commitid	z2BOCyb4irSflclb;

1.111
date	2017.07.21.18.57.55;	author krw;	state Exp;
branches;
next	1.110;
commitid	jKsjPeE2L2H4ksIK;

1.110
date	2017.07.17.17.53.59;	author krw;	state Exp;
branches;
next	1.109;
commitid	8jGWva9ff3xgYWwf;

1.109
date	2017.07.14.16.21.03;	author krw;	state Exp;
branches;
next	1.108;
commitid	MneUE6JB4herdkKT;

1.108
date	2017.07.14.14.03.15;	author krw;	state Exp;
branches;
next	1.107;
commitid	tlFMQdvTkGuWS3BL;

1.107
date	2017.07.10.14.11.47;	author krw;	state Exp;
branches;
next	1.106;
commitid	zPfpB13LVx1r8eha;

1.106
date	2017.07.10.00.47.47;	author krw;	state Exp;
branches;
next	1.105;
commitid	NbrwpC5tx5StmvcS;

1.105
date	2017.07.09.19.19.58;	author krw;	state Exp;
branches;
next	1.104;
commitid	0BGOuT2HbB9sCm2t;

1.104
date	2017.07.09.12.38.47;	author krw;	state Exp;
branches;
next	1.103;
commitid	VZSWvnhCdpuBNPDo;

1.103
date	2017.07.08.00.36.10;	author krw;	state Exp;
branches;
next	1.102;
commitid	fG77ONbQ8YTfWdI4;

1.102
date	2017.07.02.09.11.13;	author krw;	state Exp;
branches;
next	1.101;
commitid	dsBHBUGhFvB0Vfsu;

1.101
date	2017.07.01.23.27.56;	author krw;	state Exp;
branches;
next	1.100;
commitid	UWIW511YvInk5uK6;

1.100
date	2017.06.29.13.55.53;	author krw;	state Exp;
branches;
next	1.99;
commitid	slBDG7uu1EsDqTzi;

1.99
date	2017.06.28.16.31.52;	author krw;	state Exp;
branches;
next	1.98;
commitid	78CHyOkgKoAWELkJ;

1.98
date	2017.06.28.15.45.32;	author krw;	state Exp;
branches;
next	1.97;
commitid	c7fR80WLlkrdEx6m;

1.97
date	2017.06.28.15.23.19;	author krw;	state Exp;
branches;
next	1.96;
commitid	ZSEhAHX8EGwulPzo;

1.96
date	2017.06.28.14.35.43;	author krw;	state Exp;
branches;
next	1.95;
commitid	3nygEKTzwCipdpn4;

1.95
date	2017.06.28.11.53.08;	author krw;	state Exp;
branches;
next	1.94;
commitid	M6PpHkrfC8LwGkzG;

1.94
date	2017.06.25.00.44.49;	author krw;	state Exp;
branches;
next	1.93;
commitid	iOfEU7PhC5eJvuv5;

1.93
date	2017.06.24.23.32.57;	author krw;	state Exp;
branches;
next	1.92;
commitid	kMjmTgmAjjj8SVH3;

1.92
date	2017.06.23.15.40.56;	author krw;	state Exp;
branches;
next	1.91;
commitid	2V1Vp5y5sN8YqgCW;

1.91
date	2017.04.12.12.22.25;	author krw;	state Exp;
branches;
next	1.90;
commitid	O6J9KmASjKUOMrHk;

1.90
date	2017.04.11.13.59.27;	author krw;	state Exp;
branches;
next	1.89;
commitid	zUymlMql24I51JEz;

1.89
date	2017.04.11.10.40.14;	author krw;	state Exp;
branches;
next	1.88;
commitid	fZH0FasjbItTtOXw;

1.88
date	2017.04.09.20.44.13;	author krw;	state Exp;
branches;
next	1.87;
commitid	Qbefa1v9yY6ObGzy;

1.87
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.86;
commitid	KIdulj0iLtM6kXff;

1.86
date	2017.04.05.18.22.31;	author krw;	state Exp;
branches;
next	1.85;
commitid	wE6Aq0gXfIxsFOYi;

1.85
date	2017.03.08.15.07.32;	author krw;	state Exp;
branches;
next	1.84;
commitid	7X10TIqdvbVgYrdj;

1.84
date	2017.02.12.15.53.15;	author krw;	state Exp;
branches;
next	1.83;
commitid	YTCiHbXKpxvNuYuw;

1.83
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.82;
commitid	WchZmaQT4LJ4im5M;

1.82
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.81;
commitid	IDlzr3qamZK5lxzj;

1.81
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.80;
commitid	Tm7CrlqCKqgQoJ7P;

1.80
date	2016.07.21.09.58.55;	author krw;	state Exp;
branches;
next	1.79;
commitid	PqPfLTbAliUfPkYk;

1.79
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.78;
commitid	5ELOU0S0Zl3aCrHG;

1.78
date	2015.12.19.14.56.22;	author krw;	state Exp;
branches;
next	1.77;
commitid	HpoFuGWLuo7L4PWH;

1.77
date	2015.12.19.01.09.10;	author krw;	state Exp;
branches;
next	1.76;
commitid	pW1WqW8E6BMP0fMV;

1.76
date	2015.12.18.22.17.46;	author krw;	state Exp;
branches;
next	1.75;
commitid	mS25IJ8OlNlIc1Lj;

1.75
date	2015.02.10.04.20.26;	author krw;	state Exp;
branches;
next	1.74;
commitid	TKehEr2jJpb2ARar;

1.74
date	2015.02.08.01.20.40;	author krw;	state Exp;
branches;
next	1.73;
commitid	1gFDlNw9V7WtdiEL;

1.73
date	2015.02.07.10.08.06;	author krw;	state Exp;
branches;
next	1.72;
commitid	DyjrY1dcWE4nZyJh;

1.72
date	2015.02.07.02.07.32;	author krw;	state Exp;
branches;
next	1.71;
commitid	WadF2oct8H7f0Oaz;

1.71
date	2015.02.06.06.47.29;	author krw;	state Exp;
branches;
next	1.70;
commitid	NYRWhJb6ZVSnKVWu;

1.70
date	2015.01.31.03.13.04;	author krw;	state Exp;
branches;
next	1.69;
commitid	NkXCL9IMO1B1DiTY;

1.69
date	2015.01.30.14.14.53;	author krw;	state Exp;
branches;
next	1.68;
commitid	3QeVfD902FHLKJeU;

1.68
date	2014.10.27.13.36.21;	author krw;	state Exp;
branches;
next	1.67;
commitid	18JJKpLCJZeJyulS;

1.67
date	2014.07.14.18.16.27;	author miod;	state Exp;
branches;
next	1.66;
commitid	tde65FrKdvVWEhmG;

1.66
date	2014.07.09.15.16.38;	author krw;	state Exp;
branches;
next	1.65;
commitid	j471lw6pShGoXIJ5;

1.65
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2014.02.13.00.24.13;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2014.02.09.20.45.56;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2014.02.09.20.23.22;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2014.02.09.20.08.25;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.20.02.54.07;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.08.22.49.02;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.05.21.32.59;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2013.12.04.19.39.50;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2013.08.17.14.50.05;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2013.07.05.22.13.10;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.09.22.39.51;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.09.17.31.54;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2013.06.09.16.21.50;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.09.15.06.34;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.04.21.04.53;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2013.06.01.16.26.07;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.30.16.10.01;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.24.12.53.20;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.13.16.28.05;	author weerd;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.11.16.01.02;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.08.12.25.15;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.07.13.23.27;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2013.02.28.21.00.53;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2013.02.24.01.23.19;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2013.02.21.14.10.22;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2013.02.18.22.10.04;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2013.02.17.17.36.31;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2013.02.17.17.04.41;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.17.15.48.03;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.17.15.08.13;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.02.15.01.20.39;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.02.03.15.10.36;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2013.02.01.01.33.44;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.22.06.02.52;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.17.23.41.07;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.29.14.40.00;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.19.12.25.38;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.17.22.52.59;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.04.19.24.03;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.03.22.36.16;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.03.22.19.47;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.02.17.03.19;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.17.10.39.24;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2012.11.16.14.59.36;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.14.15.47.41;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.08.16.40.21;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.07.15.40.13;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.07.15.20.28;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.07.15.07.02;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.07.14.47.30;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.05.03.49.16;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.04.03.36.39;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.04.03.25.31;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.03.01.59.31;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.02.20.21.32;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.01.22.07.07;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.31.15.50.47;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2012.10.30.16.41.28;	author krw;	state Exp;
branches;
next	;


desc
@@


1.145
log
@Tweak route_in_rtstatic() to return the position of the
route if found. Cleans up some int vs unsigned int
confusion and makes the function more generally useful
for future changes.
@
text
@/*	$OpenBSD: kroute.c,v 1.144 2017/08/31 17:01:48 krw Exp $	*/

/*
 * Copyright 2012 Kenneth R Westerback <krw@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/sysctl.h>

#include <arpa/inet.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <errno.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <imsg.h>
#include <limits.h>
#include <resolv.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"
#include "privsep.h"

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

void		 get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		 add_route(struct in_addr, struct in_addr, struct in_addr, int);
void		 flush_routes(uint8_t *, unsigned int);
int		 delete_addresses(char *, struct in_addr, struct in_addr);
char		*get_routes(int, size_t *);
unsigned int	 route_in_rtstatic(struct rt_msghdr *, uint8_t *, unsigned int);

char *
get_routes(int rdomain, size_t *len)
{
	int		 mib[7];
	char		*buf, *bufp, *errmsg = NULL;
	size_t		 needed;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_STATIC | RTF_GATEWAY | RTF_LLINFO;
	mib[6] = rdomain;

	buf = NULL;
	errmsg = NULL;
	while (1) {
		if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
			errmsg = "sysctl size of routes:";
			break;
		}
		if (needed == 0) {
			free(buf);
			return NULL;
		}
		if ((bufp = realloc(buf, needed)) == NULL) {
			errmsg = "routes buf realloc:";
			break;
		}
		buf = bufp;
		if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			errmsg = "sysctl retrieval of routes:";
			break;
		}
		break;
	}

	if (errmsg != NULL) {
		log_warn("get_routes - %s (msize=%zu)", errmsg, needed);
		free(buf);
		buf = NULL;
	}

	*len = needed;
	return buf;
}

/*
 * [priv_]flush_routes do the equivalent of
 *
 *	route -q -T $rdomain -n flush -inet -iface $interface
 *	arp -dan
 */
void
flush_routes(uint8_t *rtstatic, unsigned int rtstatic_len)
{
	struct	imsg_flush_routes	 imsg;
	int				 rslt;

	if (rtstatic_len > sizeof(imsg.rtstatic))
		return;

	imsg.rtstatic_len = rtstatic_len;
	memcpy(&imsg.rtstatic, rtstatic, rtstatic_len);

	rslt = imsg_compose(unpriv_ibuf, IMSG_FLUSH_ROUTES, 0, 0, -1, &imsg,
	    sizeof(imsg));
	if (rslt == -1)
		log_warn("flush_routes: imsg_compose");
}

void
priv_flush_routes(int index, int routefd, int rdomain,
    struct imsg_flush_routes *imsg)
{
	static int			 seqno;
	char				*lim, *buf = NULL, *next;
	struct rt_msghdr		*rtm;
	size_t				 len;
	ssize_t				 rlen;
	unsigned int			 pos;

	buf = get_routes(rdomain, &len);
	if (buf == NULL)
		return;

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		if (rtm->rtm_index != index)
			continue;
		if (rtm->rtm_tableid != rdomain)
			continue;
		if ((rtm->rtm_flags & (RTF_GATEWAY|RTF_STATIC|RTF_LLINFO)) == 0)
			continue;
		if ((rtm->rtm_flags & (RTF_LOCAL|RTF_BROADCAST)) != 0)
			continue;

		/* Don't bother deleting a route we're going to add. */
		pos = route_in_rtstatic(rtm, imsg->rtstatic, imsg->rtstatic_len);
		if (pos < imsg->rtstatic_len)
			continue;

		rtm->rtm_type = RTM_DELETE;
		rtm->rtm_seq = seqno++;

		rlen = write(routefd, (char *)rtm, rtm->rtm_msglen);
		if (rlen == -1) {
			if (errno != ESRCH)
				log_warn("RTM_DELETE write");
		} else if (rlen < (int)rtm->rtm_msglen)
			log_warnx("short RTM_DELETE write (%zd)\n", rlen);
	}

	free(buf);
}

int
extract_classless_route(uint8_t *rtstatic, unsigned int rtstatic_len,
    in_addr_t *dest, in_addr_t *netmask, in_addr_t *gateway)
{
	unsigned int	 bits, bytes, len;

	if (rtstatic[0] > 32)
		return -1;

	bits = rtstatic[0];
	bytes = (bits + 7) / 8;
	len = 1 + bytes + sizeof(*gateway);
	if (len > rtstatic_len)
		return -1;

	memcpy(dest, &rtstatic[1], bytes);
	if (bits == 0)
		*netmask = INADDR_ANY;
	else
		*netmask = htonl(0xffffffff << (32 - bits));
	*dest &= *netmask;
	memcpy(gateway, &rtstatic[1 +  bytes], sizeof(*gateway));

	return len;
}

void
set_routes(struct in_addr addr, struct in_addr addrmask, uint8_t *rtstatic,
    unsigned int rtstatic_len)
{
	const struct in_addr	 any = { INADDR_ANY };
	struct in_addr		 dest, gateway, netmask;
	unsigned int		 i;
	int			 len;

	flush_routes(rtstatic, rtstatic_len);

	/* Add classless static routes. */
	i = 0;
	while (i < rtstatic_len) {
		len = extract_classless_route(&rtstatic[i], rtstatic_len - i,
		    &dest.s_addr, &netmask.s_addr, &gateway.s_addr);
		if (len <= 0)
			return;
		i += len;

		if (gateway.s_addr == INADDR_ANY) {
			/*
			 * DIRECT ROUTE
			 *
			 * route add -net $dest -netmask $netmask -cloning
			 *     -iface $addr
			 */
			add_route(dest, netmask, addr,
			    RTF_STATIC | RTF_CLONING);
		} else if (netmask.s_addr == INADDR_ANY) {
			/*
			 * DEFAULT ROUTE
			 */
			if (addrmask.s_addr == INADDR_BROADCAST) {
				/*
				 * DIRECT ROUTE TO DEFAULT GATEWAY
				 *
				 * To be compatible with ISC DHCP behavior on
				 * Linux, if we were given a /32 IP assignment
				 * then add a /32 direct route for the gateway
				 * to make it routable.
				 *
				 * route add -net $gateway -netmask $addrmask
				 *     -cloning -iface $addr
				 */
				add_route(gateway, addrmask, addr,
				    RTF_STATIC | RTF_CLONING);
			}

			if (memcmp(&gateway, &addr, sizeof(addr)) == 0) {
				/*
				 * DEFAULT ROUTE IS A DIRECT ROUTE
				 *
				 * route add default -iface $addr
				 */
				add_route(any, any, gateway, RTF_STATIC);
			} else {
				/*
				 * DEFAULT ROUTE IS VIA GATEWAY
				 *
				 * route add default $gateway
				 */
				add_route(any, any, gateway,
				    RTF_STATIC | RTF_GATEWAY);
			}
		} else {
			/*
			 * NON-DIRECT, NON-DEFAULT ROUTE
			 *
			 * route add -net $dest -netmask $netmask $gateway
			 */
			add_route(dest, netmask, gateway,
			    RTF_STATIC | RTF_GATEWAY);
		}
	}
}

/*
 * [priv_]add_route() add a single route to the routing table.
 */
void
add_route(struct in_addr dest, struct in_addr netmask, struct in_addr gateway,
    int flags)
{
	struct imsg_add_route	 imsg;
	int			 rslt;

	imsg.dest = dest;
	imsg.gateway = gateway;
	imsg.netmask = netmask;
	imsg.flags = flags;

	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ROUTE, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("add_route: imsg_compose");
}

void
priv_add_route(char *name, int rdomain, int routefd,
    struct imsg_add_route *imsg)
{
	char			 destbuf[INET_ADDRSTRLEN];
	char			 maskbuf[INET_ADDRSTRLEN];
	struct iovec		 iov[5];
	struct rt_msghdr	 rtm;
	struct sockaddr_in	 dest, gateway, mask;
	int			 index, iovcnt = 0;

	index = if_nametoindex(name);
	if (index == 0)
		return;

	/* Build RTM header */

	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_ADD;
	rtm.rtm_index = index;
	rtm.rtm_tableid = rdomain;
	rtm.rtm_priority = RTP_NONE;
	rtm.rtm_addrs =	RTA_DST | RTA_NETMASK | RTA_GATEWAY;
	rtm.rtm_flags = imsg->flags;

	rtm.rtm_msglen = sizeof(rtm);
	iov[iovcnt].iov_base = &rtm;
	iov[iovcnt++].iov_len = sizeof(rtm);

	/* Add the destination address. */
	memset(&dest, 0, sizeof(dest));
	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = imsg->dest.s_addr;

	rtm.rtm_msglen += sizeof(dest);
	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);

	/* Add the gateways address. */
	memset(&gateway, 0, sizeof(gateway));
	gateway.sin_len = sizeof(gateway);
	gateway.sin_family = AF_INET;
	gateway.sin_addr.s_addr = imsg->gateway.s_addr;

	rtm.rtm_msglen += sizeof(gateway);
	iov[iovcnt].iov_base = &gateway;
	iov[iovcnt++].iov_len = sizeof(gateway);

	/* Add the network mask. */
	memset(&mask, 0, sizeof(mask));
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = imsg->netmask.s_addr;

	rtm.rtm_msglen += sizeof(mask);
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);

	if (writev(routefd, iov, iovcnt) == -1) {
		if (errno != EEXIST || log_getverbose() != 0) {
			strlcpy(destbuf, inet_ntoa(imsg->dest),
			    sizeof(destbuf));
			strlcpy(maskbuf, inet_ntoa(imsg->netmask),
			    sizeof(maskbuf));
			log_warn("failed to add route (%s/%s via %s)",
			    destbuf, maskbuf, inet_ntoa(imsg->gateway));
		}
	}
}

/*
 * delete_addresses() deletes existing inet addresses on the named interface,
 * leaving in place newaddr/newnetmask.
 *
 * Return 1 if newaddr/newnetmask is seen while deleting addresses, 0 otherwise.
 */
int
delete_addresses(char *name, struct in_addr newaddr, struct in_addr newnetmask)
{
	struct in_addr		 addr, netmask;
	struct ifaddrs		*ifap, *ifa;
	int			 found = 0;

	if (getifaddrs(&ifap) != 0)
		fatal("delete_addresses getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_LOOPBACK) != 0 ||
		    (ifa->ifa_flags & IFF_POINTOPOINT) != 0 ||
		    ((ifa->ifa_flags & IFF_UP) == 0) ||
		    (ifa->ifa_addr->sa_family != AF_INET) ||
		    (strcmp(name, ifa->ifa_name) != 0))
			continue;

		memcpy(&addr,
		    &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr,
		    sizeof(addr));
		memcpy(&netmask,
		    &((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr,
		    sizeof(netmask));

		if (addr.s_addr == newaddr.s_addr &&
		    netmask.s_addr == newnetmask.s_addr)
			found = 1;
		else
			delete_address(addr);
	}

	freeifaddrs(ifap);
	return (found);
}

/*
 * [priv_]delete_address is the equivalent of
 *
 *	ifconfig <ifname> inet <addr> delete
 */
void
delete_address(struct in_addr addr)
{
	struct imsg_delete_address	 imsg;
	int				 rslt;

	imsg.addr = addr;

	rslt = imsg_compose(unpriv_ibuf, IMSG_DELETE_ADDRESS, 0, 0 , -1, &imsg,
	    sizeof(imsg));
	if (rslt == -1)
		log_warn("delete_address: imsg_compose");
}

void
priv_delete_address(char *name, int ioctlfd, struct imsg_delete_address *imsg)
{
	struct ifaliasreq	 ifaliasreq;
	struct sockaddr_in	*in;

	/*
	 * Delete specified address on specified interface.
	 */

	memset(&ifaliasreq, 0, sizeof(ifaliasreq));
	strncpy(ifaliasreq.ifra_name, name, sizeof(ifaliasreq.ifra_name));

	in = (struct sockaddr_in *)&ifaliasreq.ifra_addr;
	in->sin_family = AF_INET;
	in->sin_len = sizeof(ifaliasreq.ifra_addr);
	in->sin_addr.s_addr = imsg->addr.s_addr;

	/* SIOCDIFADDR will result in a RTM_DELADDR message we must catch! */
	if (ioctl(ioctlfd, SIOCDIFADDR, &ifaliasreq) == -1) {
		if (errno != EADDRNOTAVAIL)
			log_warn("SIOCDIFADDR failed (%s)",
			    inet_ntoa(imsg->addr));
	}
}

/*
 * [priv_]set_mtu is the equivalent of
 *
 *      ifconfig <if> mtu <mtu>
 */
void
set_mtu(int inits, uint16_t mtu)
{
	struct imsg_set_mtu	 imsg;
	int			 rslt;

	if ((inits & RTV_MTU) == 0)
		return;

	if (mtu < 68) {
		log_warnx("mtu size %u < 68: ignored", mtu);
		return;
	}
	imsg.mtu = mtu;

	rslt = imsg_compose(unpriv_ibuf, IMSG_SET_MTU, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("set_mtu: imsg_compose");
}

void
priv_set_mtu(char *name, int ioctlfd, struct imsg_set_mtu *imsg)
{
	struct ifreq	 ifr;

	memset(&ifr, 0, sizeof(ifr));

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_mtu = imsg->mtu;

	if (ioctl(ioctlfd, SIOCSIFMTU, &ifr) == -1)
		log_warn("SIOCSIFMTU failed (%d)", imsg->mtu);
}

/*
 * [priv_]set_address is the equivalent of
 *
 *	ifconfig <if> inet <addr> netmask <mask> broadcast <addr>
 */
void
set_address(char *name, struct in_addr addr, struct in_addr netmask)
{
	struct imsg_set_address	 imsg;
	int			 rslt;

	/* Deleting the addresses also clears out arp entries. */
	if (delete_addresses(name, addr, netmask) != 0)
		return;

	imsg.addr = addr;
	imsg.mask = netmask;

	rslt = imsg_compose(unpriv_ibuf, IMSG_SET_ADDRESS, 0, 0, -1, &imsg,
	    sizeof(imsg));
	if (rslt == -1)
		log_warn("set_address: imsg_compose");
}

void
priv_set_address(char *name, int ioctlfd, struct imsg_set_address *imsg)
{
	struct ifaliasreq	 ifaliasreq;
	struct sockaddr_in	*in;

	memset(&ifaliasreq, 0, sizeof(ifaliasreq));
	strncpy(ifaliasreq.ifra_name, name, sizeof(ifaliasreq.ifra_name));

	/* The actual address in ifra_addr. */
	in = (struct sockaddr_in *)&ifaliasreq.ifra_addr;
	in->sin_family = AF_INET;
	in->sin_len = sizeof(ifaliasreq.ifra_addr);
	in->sin_addr.s_addr = imsg->addr.s_addr;

	/* And the netmask in ifra_mask. */
	in = (struct sockaddr_in *)&ifaliasreq.ifra_mask;
	in->sin_family = AF_INET;
	in->sin_len = sizeof(ifaliasreq.ifra_mask);
	memcpy(&in->sin_addr, &imsg->mask, sizeof(in->sin_addr));

	/* No need to set broadcast address. Kernel can figure it out. */

	if (ioctl(ioctlfd, SIOCAIFADDR, &ifaliasreq) == -1)
		log_warn("SIOCAIFADDR failed (%s)", inet_ntoa(imsg->addr));
}

/*
 * [priv_]write_resolv_conf write out a new resolv.conf.
 */
void
write_resolv_conf(void)
{
	int	 rslt;

	rslt = imsg_compose(unpriv_ibuf, IMSG_WRITE_RESOLV_CONF,
	    0, 0, -1, NULL, 0);
	if (rslt == -1)
		log_warn("write_resolv_conf: imsg_compose");
}

void
priv_write_resolv_conf(char *contents)
{
	const char	*path = "/etc/resolv.conf";
	ssize_t		 n;
	size_t		 sz;
	int		 fd;

	if (contents == NULL)
		return;

	fd = open(path, O_WRONLY | O_CREAT | O_TRUNC,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

	if (fd == -1) {
		log_warn("Couldn't open '%s'", path);
		return;
	}

	sz = strlen(contents);
	n = write(fd, contents, sz);
	if (n == -1)
		log_warn("Couldn't write contents to '%s'", path);
	else if ((size_t)n < sz)
		log_warnx("Short contents write to '%s' (%zd vs %zu)",
		    path, n, sz);

	close(fd);
}

/*
 * default_route_index returns the index of the interface which the
 * default route is on.
 */
int
default_route_index(int rdomain, int routefd)
{
	struct iovec		 iov[3];
	struct sockaddr_in	 sin;
	struct {
		struct rt_msghdr	m_rtm;
		char			m_space[512];
	} m_rtmsg;
	pid_t			 pid;
	ssize_t			 len;
	int			 seq, iovcnt = 0;

	/* Build RTM header */

	memset(&m_rtmsg, 0, sizeof(m_rtmsg));

	m_rtmsg.m_rtm.rtm_version = RTM_VERSION;
	m_rtmsg.m_rtm.rtm_type = RTM_GET;
	m_rtmsg.m_rtm.rtm_seq = seq = arc4random();
	m_rtmsg.m_rtm.rtm_tableid = rdomain;
	m_rtmsg.m_rtm.rtm_addrs = RTA_DST | RTA_NETMASK;

	iov[iovcnt].iov_base = &m_rtmsg.m_rtm;
	iov[iovcnt++].iov_len = sizeof(m_rtmsg.m_rtm);

	/* Ask for route to 0.0.0.0/0 (a.k.a. the default route). */
	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;

	iov[iovcnt].iov_base = &sin;
	iov[iovcnt++].iov_len = sizeof(sin);
	iov[iovcnt].iov_base = &sin;
	iov[iovcnt++].iov_len = sizeof(sin);

	m_rtmsg.m_rtm.rtm_msglen = sizeof(m_rtmsg.m_rtm) + 2 * sizeof(sin);

	if (writev(routefd, iov, iovcnt) == -1) {
		if (errno != ESRCH)
			log_warn("RTM_GET of default route");
		goto done;
	}

	pid = getpid();

	do {
		len = read(routefd, &m_rtmsg, sizeof(m_rtmsg));
		if (len == -1) {
			log_warn("get default route read");
			goto done;
		} else if (len == 0) {
			log_warnx("no data from default route read");
			goto done;
		}
		if (m_rtmsg.m_rtm.rtm_version == RTM_VERSION &&
		    m_rtmsg.m_rtm.rtm_type == RTM_GET &&
		    m_rtmsg.m_rtm.rtm_pid == pid &&
		    m_rtmsg.m_rtm.rtm_seq == seq) {
			if (m_rtmsg.m_rtm.rtm_errno != 0) {
				log_warnx("default route read rtm: %s",
				    strerror(m_rtmsg.m_rtm.rtm_errno));
				goto done;
			}
			return m_rtmsg.m_rtm.rtm_index;
		}
	} while (1);

done:
	return 0;
}

/*
 * set_resolv_conf creates a string that are the resolv.conf contents
 * that should be used when the interface is determined to be the one to
 * create /etc/resolv.conf
 */
void
set_resolv_conf(char *name, uint8_t *rtsearch, unsigned int rtsearch_len,
    uint8_t *rtdns, unsigned int rtdns_len)
{
	char		*dn, *nss[MAXNS], *contents, *courtesy;
	struct in_addr	*addr;
	size_t		 len;
	unsigned int	 i, servers;
	int		 rslt;

	memset(nss, 0, sizeof(nss));
	len = 0;

	if (rtsearch_len != 0) {
		rslt = asprintf(&dn, "search %.*s\n", rtsearch_len,
		    rtsearch);
		if (rslt == -1)
			dn = NULL;
	} else
		dn = strdup("");
	if (dn == NULL)
		fatalx("no memory for domainname");
	len += strlen(dn);

	if (rtdns_len != 0) {
		addr = (struct in_addr *)rtdns;
		servers = rtdns_len / sizeof(addr->s_addr);
		if (servers > MAXNS)
			servers = MAXNS;
		for (i = 0; i < servers; i++) {
			rslt = asprintf(&nss[i], "nameserver %s\n",
			    inet_ntoa(*addr));
			if (rslt == -1)
				fatalx("no memory for nameserver");
			len += strlen(nss[i]);
			addr++;
		}
	}

	/*
	 * XXX historically dhclient-script did not overwrite
	 *     resolv.conf when neither search nor dns info
	 *     was provided. Is that really what we want?
	 */
	if (len > 0 && config->resolv_tail != NULL)
		len += strlen(config->resolv_tail);

	if (len == 0) {
		free(dn);
		contents = NULL;
		goto done;
	}

	rslt = asprintf(&courtesy, "# Generated by %s dhclient\n", name);
	if (rslt == -1)
		fatalx("no memory for courtesy line");
	len += strlen(courtesy);

	len++; /* Need room for terminating NUL. */
	contents = calloc(1, len);
	if (contents == NULL)
		fatalx("no memory for resolv.conf contents");

	strlcat(contents, courtesy, len);
	free(courtesy);

	strlcat(contents, dn, len);
	free(dn);

	for (i = 0; i < MAXNS; i++) {
		if (nss[i] != NULL) {
			strlcat(contents, nss[i], len);
			free(nss[i]);
		}
	}

	if (config->resolv_tail != NULL)
		strlcat(contents, config->resolv_tail, len);

done:
	rslt = imsg_compose(unpriv_ibuf, IMSG_SET_RESOLV_CONF,
	    0, 0, -1, contents, len);
	if (rslt == -1)
		log_warn("set_resolv_conf: imsg_compose");
}

/*
 * get_rtaddrs populates the rti_info with pointers to the
 * sockaddr's contained in a rtm message.
 */
void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

unsigned int
route_in_rtstatic(struct rt_msghdr *rtm, uint8_t *rtstatic,
    unsigned int rtstatic_len)
{
	struct sockaddr		*rti_info[RTAX_MAX];
	struct sockaddr		*dst, *netmask, *gateway;
	in_addr_t		 dstaddr, netmaskaddr, gatewayaddr;
	in_addr_t		 rtstaticdstaddr, rtstaticnetmaskaddr;
	in_addr_t		 rtstaticgatewayaddr;
	unsigned int		 i;
	int			 len;

	get_rtaddrs(rtm->rtm_addrs,
	    (struct sockaddr *)((char *)(rtm) + rtm->rtm_hdrlen),
	    rti_info);

	dst = rti_info[RTAX_DST];
	netmask = rti_info[RTAX_NETMASK];
	gateway = rti_info[RTAX_GATEWAY];

	if (dst == NULL || netmask == NULL || gateway == NULL)
		return rtstatic_len;

	if (dst->sa_family != AF_INET || netmask->sa_family != AF_INET ||
	    gateway->sa_family != AF_INET)
		return rtstatic_len;

	dstaddr = ((struct sockaddr_in *)dst)->sin_addr.s_addr;
	netmaskaddr = ((struct sockaddr_in *)netmask)->sin_addr.s_addr;
	gatewayaddr = ((struct sockaddr_in *)gateway)->sin_addr.s_addr;

	dstaddr &= netmaskaddr;
	i = 0;
	while (i < rtstatic_len)  {
		len = extract_classless_route(&rtstatic[i], rtstatic_len - i,
		    &rtstaticdstaddr, &rtstaticnetmaskaddr,
		    &rtstaticgatewayaddr);
		if (len <= 0)
			break;

		if (dstaddr == rtstaticdstaddr &&
		    netmaskaddr == rtstaticnetmaskaddr &&
		    gatewayaddr == rtstaticgatewayaddr)
			return i;

		i += len;
	}

	return rtstatic_len;
}
@


1.144
log
@Don't delete v4 routes that are going to be
added back.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.143 2017/08/29 13:21:30 krw Exp $	*/
d53 6
a58 6
void	get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void	add_route(struct in_addr, struct in_addr, struct in_addr, int);
void	flush_routes(uint8_t *, unsigned int);
int	delete_addresses(char *, struct in_addr, struct in_addr);
char	*get_routes(int, size_t *);
int	route_in_rtstatic(struct rt_msghdr *, uint8_t *, unsigned int);
d143 1
d164 2
a165 2
		if (route_in_rtstatic(rtm, imsg->rtstatic, imsg->rtstatic_len)
		    == 0)
d787 1
a787 1
int
d808 1
a808 1
		return 1;
d812 1
a812 1
		return 1;
a825 1
		i += len;
d830 3
a832 1
			return 0;
d835 1
a835 1
	return 1;
@


1.143
log
@Add a utility function extract_classless_route() and
use it to simplify logic at both places that process
RFC 3442 data.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.142 2017/08/26 18:52:56 krw Exp $	*/
d55 1
a55 1
void	flush_routes(void);
d58 1
d117 1
a117 1
flush_routes(void)
d119 8
a126 1
	int	 rslt;
d128 2
a129 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_FLUSH_ROUTES, 0, 0, -1, NULL, 0);
d135 2
a136 1
priv_flush_routes(int index, int routefd, int rdomain)
d162 5
d216 1
a216 1
	flush_routes();
d784 50
@


1.142
log
@Since we no longer try to uniquely label routes added
by dhclients, there is no need to retry adding a route
if the first attempt fails with EEXIST. And EUNREACHABLE
should be considered final since the address if any is
already configured.

Use log_getverbose() to allow logging of EEXIST errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.141 2017/08/26 15:36:25 krw Exp $	*/
d166 26
d198 2
a199 1
	unsigned int		 i, bits, bytes;
d206 3
a208 18
		bits = rtstatic[i++];
		bytes = (bits + 7) / 8;

		if (bytes > sizeof(netmask.s_addr))
			return;
		else if (i + bytes > rtstatic_len)
			return;

		if (bits != 0)
			netmask.s_addr = htonl(0xffffffff << (32 - bits));
		else
			netmask.s_addr = INADDR_ANY;

		memcpy(&dest, &rtstatic[i], bytes);
		dest.s_addr = dest.s_addr & netmask.s_addr;
		i += bytes;

		if (i + sizeof(gateway) > rtstatic_len)
d210 1
a210 2
		memcpy(&gateway.s_addr, &rtstatic[i], sizeof(gateway.s_addr));
		i += sizeof(gateway.s_addr);
@


1.141
log
@Remove inadvertantly included param names in
get_rtaddrs() prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.140 2017/08/26 15:31:00 krw Exp $	*/
d288 1
a288 1
	int			 i, index, iovcnt = 0;
d340 2
a341 5
	/* Check for EEXIST since other dhclient may not be done. */
	for (i = 0; i < 5; i++) {
		if (writev(routefd, iov, iovcnt) != -1)
			break;
		if (i == 4) {
d348 1
a348 2
		} else if (errno == EEXIST || errno == ENETUNREACH)
			sleep(1);
@


1.140
log
@Change currently unused populate_rti_info() with
the get_rtaddrs() everyone is using. Soon to be
used or deleted.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.139 2017/08/18 15:06:11 krw Exp $	*/
d53 1
a53 1
void	get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info);
@


1.139
log
@Truncating a file and then deciding not to change its
contents doesn't do what you think it does.

Restore "no dns servers, no search, means don't touch
resolv.conf" behaviour unintentionally changed at t2k17.

Noticed by ajacoutot@@ during an upgrade using a
non-OpenBSD dhcpd server that only provides the
options it is asked for.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.138 2017/08/14 22:12:59 krw Exp $	*/
d53 1
a53 1
void	populate_rti_info(struct sockaddr **, struct rt_msghdr *);
d746 1
a746 1
 * populate_rti_info populates the rti_info with pointers to the
d750 1
a750 1
populate_rti_info(struct sockaddr **rti_info, struct rt_msghdr *rtm)
d752 1
a752 4
	struct sockaddr	*sa;
	int		 i;

	sa = (struct sockaddr *)((char *)(rtm) + rtm->rtm_hdrlen);
d755 1
a755 1
		if (rtm->rtm_addrs & (1 << i)) {
@


1.138
log
@Try for consistency in sizeof() usage.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.137 2017/08/12 16:57:38 krw Exp $	*/
d556 3
d567 7
a573 9
	if (contents != NULL) {
		sz = strlen(contents);
		n = write(fd, contents, sz);
		if (n == -1)
			log_warn("Couldn't write contents to '%s'", path);
		else if ((size_t)n < sz)
			log_warnx("Short contents write to '%s' (%zd vs %zu)",
			    path, n, sz);
	}
d708 2
a709 1
		return;
d738 1
@


1.137
log
@Stop trying to outfox the routing table
by labelling dhclient routes. Just use
the route(8) logic when flushing routes.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.136 2017/08/10 17:15:05 krw Exp $	*/
d182 1
a182 1
		if (bytes > sizeof(struct in_addr))
d198 2
a199 2
		memcpy(&gateway, &rtstatic[i], sizeof(gateway));
		i += sizeof(gateway);
d684 1
a684 1
		servers = rtdns_len / sizeof(struct in_addr);
@


1.136
log
@Add IMSG_SET_RESOLV_CONF and keep the cached contents
in the priv process, so that they do not have to be
continually retransmitted. IMSG_WRITE_RESOLV_CONF
now just triggers a write of the cached info.

Simplifies a bunch of logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.135 2017/08/09 19:57:54 krw Exp $	*/
a52 2
int	create_route_label(struct sockaddr_rtlabel *);
int	check_route_label(struct sockaddr_rtlabel *);
a53 1
void	delete_route(int, struct rt_msghdr *);
d57 1
a57 8
char	*get_routes(int, int, size_t *);

#define	ROUTE_LABEL_NONE		1
#define	ROUTE_LABEL_NOT_DHCLIENT	2
#define	ROUTE_LABEL_DHCLIENT_OURS	3
#define	ROUTE_LABEL_DHCLIENT_UNKNOWN	4
#define	ROUTE_LABEL_DHCLIENT_LIVE	5
#define	ROUTE_LABEL_DHCLIENT_DEAD	6
d60 1
a60 1
get_routes(int rdomain, int flags, size_t *len)
d71 1
a71 1
	mib[5] = flags;
a109 35
 * check_route_label examines the label associated with a route and
 * returns a value indicating that there was no label (ROUTE_LABEL_NONE),
 * that the route was created by the current process
 * (ROUTE_LABEL_DHCLIENT_OURS), a dead process (ROUTE_LABEL_DHCLIENT_DEAD), or
 * an indeterminate process (ROUTE_LABEL_DHCLIENT_UNKNOWN).
 */
int
check_route_label(struct sockaddr_rtlabel *label)
{
	pid_t pid;

	if (label == NULL)
		return ROUTE_LABEL_NONE;

	if (strncmp("DHCLIENT ", label->sr_label, 9) != 0)
		return ROUTE_LABEL_NOT_DHCLIENT;

	pid = (pid_t)strtonum(label->sr_label + 9, 1, INT_MAX, NULL);
	if (pid <= 0)
		return ROUTE_LABEL_DHCLIENT_UNKNOWN;

	if (pid == getpid())
		return ROUTE_LABEL_DHCLIENT_OURS;

	if (kill(pid, 0) == -1) {
		if (errno == ESRCH)
			return ROUTE_LABEL_DHCLIENT_DEAD;
		else
			return ROUTE_LABEL_DHCLIENT_UNKNOWN;
	}

	return ROUTE_LABEL_DHCLIENT_LIVE;
}

/*
d112 1
a112 1
 *	route -q $rdomain -n flush -inet -iface $interface
d126 1
a126 1
priv_flush_routes(char *name, int routefd, int rdomain)
d128 1
a128 2
	char				 ifname[IF_NAMESIZE];
	struct sockaddr			*rti_info[RTAX_MAX];
a130 2
	struct sockaddr_in		*sa_in;
	struct sockaddr_rtlabel		*sa_rl;
d132 1
d134 1
a134 1
	buf = get_routes(rdomain, RTF_STATIC, &len);
d143 8
d152 2
a153 1
		populate_rti_info(rti_info, rtm);
d155 6
a160 25
		sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
		sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];

		switch (check_route_label(sa_rl)) {
		case ROUTE_LABEL_DHCLIENT_OURS:
		case ROUTE_LABEL_DHCLIENT_DEAD:
			delete_route(routefd, rtm);
			break;
		case ROUTE_LABEL_DHCLIENT_LIVE:
		case ROUTE_LABEL_DHCLIENT_UNKNOWN:
			/* Another dhclient's responsibility. */
			break;
		case ROUTE_LABEL_NONE:
		case ROUTE_LABEL_NOT_DHCLIENT:
			/* Delete default routes on our interface. */
			if (if_indextoname(rtm->rtm_index, ifname) &&
			    sa_in &&
			    sa_in->sin_addr.s_addr == INADDR_ANY &&
			    rtm->rtm_tableid == rdomain &&
			    strcmp(name, ifname) == 0)
				delete_route(routefd, rtm);
			break;
		default:
			break;
		}
a165 47
/*
 * delete_route deletes a single route from the routing table.
 */
void
delete_route(int s, struct rt_msghdr *rtm)
{
	static int	 seqno;
	ssize_t		 rlen;

	rtm->rtm_type = RTM_DELETE;
	rtm->rtm_seq = seqno++;

	rlen = write(s, (char *)rtm, rtm->rtm_msglen);
	if (rlen == -1) {
		if (errno != ESRCH)
			fatal("RTM_DELETE write");
	} else if (rlen < (int)rtm->rtm_msglen)
		fatalx("short RTM_DELETE write (%zd)\n", rlen);
}

/*
 * create_route_label constructs a short string that can be uses to label
 * a route so that subsequent route examinations can find routes added by
 * dhclient. The label includes the pid so that routes can be further
 * identified as coming from a particular dhclient instance.
 */
int
create_route_label(struct sockaddr_rtlabel *label)
{
	int	 len;

	memset(label, 0, sizeof(*label));

	label->sr_len = sizeof(label);
	label->sr_family = AF_UNSPEC;

	len = snprintf(label->sr_label, sizeof(label->sr_label), "DHCLIENT %d",
	    (int)getpid());

	if (len == -1 || (unsigned int)len >= sizeof(label->sr_label)) {
		log_warn("could not create route label");
		return 1;
	}

	return 0;
}

a287 1
	struct sockaddr_rtlabel	 label;
a338 8

	/* Add our label so we can identify the route as our creation. */
	if (create_route_label(&label) == 0) {
		rtm.rtm_addrs |= RTA_LABEL;
		rtm.rtm_msglen += sizeof(label);
		iov[iovcnt].iov_base = &label;
		iov[iovcnt++].iov_len = sizeof(label);
	}
@


1.135
log
@Stop obsessively flushing the imsg connection. Just
flush any queued messages on getting a POLLOUT.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.134 2017/08/08 17:54:24 krw Exp $	*/
d651 1
a651 1
write_resolv_conf(uint8_t *contents, size_t sz)
d656 1
a656 1
	    0, 0, -1, contents, sz);
d662 1
a662 1
priv_write_resolv_conf(uint8_t *contents, size_t sz)
d666 1
d677 9
a685 6
	n = write(fd, contents, sz);
	if (n == -1)
		log_warn("Couldn't write contents to '%s'", path);
	else if ((size_t)n < sz)
		log_warnx("Short contents write to '%s' (%zd vs %zu)",
		    path, n, sz);
d767 1
a767 1
 * resolv_conf_contents creates a string that are the resolv.conf contents
d771 2
a772 3
char *
resolv_conf_contents(char *name,
    uint8_t *rtsearch, unsigned int rtsearch_len,
d820 1
a820 1
		return NULL;
d849 4
a852 1
	return contents;
@


1.134
log
@Rename resolv_conf_priority() to default_route_index() to
reflect what it does.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.133 2017/08/08 17:20:09 krw Exp $	*/
a52 20
/*
 * flush_unpriv_ibuf makes sure queued messages are delivered to the
 * imsg socket.
 */
void
flush_unpriv_ibuf(const char *who)
{
	while (unpriv_ibuf->w.queued) {
		if (msgbuf_write(&unpriv_ibuf->w) <= 0) {
			if (errno == EAGAIN)
				break;
			if (quit == 0)
				quit = INTERNALSIG;
			if (errno != EPIPE && errno != 0)
				log_warn("%s: msgbuf_write", who);
			break;
		}
	}
}

a167 2

	flush_unpriv_ibuf("flush_routes");
a380 2

	flush_unpriv_ibuf("add_route");
a527 2

	flush_unpriv_ibuf("delete_address");
a579 2

	flush_unpriv_ibuf("set_mtu");
a617 2

	flush_unpriv_ibuf("set_address");
a658 2

	flush_unpriv_ibuf("write_resolv_conf");
@


1.133
log
@KNF some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.132 2017/08/06 22:05:16 krw Exp $	*/
d719 1
a719 1
 * resolv_conf_priority returns the index of the interface which the
d723 1
a723 1
resolv_conf_priority(int rdomain, int routefd)
@


1.132
log
@Simplify logic seeking/checking the interface over
which the current default route exits.

If the dhclient instance owns that interface it
owns resolv.conf and will overwrite it no matter
who created the default route.

Feedback & suggestions claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.131 2017/08/05 13:39:17 krw Exp $	*/
d482 4
a485 2
			strlcpy(destbuf, inet_ntoa(imsg->dest), sizeof(destbuf));
			strlcpy(maskbuf, inet_ntoa(imsg->netmask), sizeof(maskbuf));
@


1.131
log
@Factor out get_routes() to do the sysctl() dance
needed to get a set of routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.130 2017/08/05 12:35:17 krw Exp $	*/
d717 2
a718 2
 * resolv_conf_priority decides if the interface is the best one to
 * suppy the contents of the resolv.conf file.
d728 1
a728 3
	}			 m_rtmsg;
	struct sockaddr		*rti_info[RTAX_MAX];
	struct sockaddr_rtlabel *sa_rl;
d731 1
a731 3
	int			 seq, rslt, iovcnt = 0;

	rslt = 0;
a738 2
	m_rtmsg.m_rtm.rtm_msglen = sizeof(m_rtmsg.m_rtm);
	m_rtmsg.m_rtm.rtm_flags = RTF_STATIC | RTF_GATEWAY | RTF_UP;
d741 1
d746 1
a746 4
	/* Set destination & netmask addresses of all zeros. */

	m_rtmsg.m_rtm.rtm_addrs = RTA_DST | RTA_NETMASK;

d756 1
a756 1
	m_rtmsg.m_rtm.rtm_msglen += 2 * sizeof(sin);
d775 2
a776 3
		if (m_rtmsg.m_rtm.rtm_version != RTM_VERSION)
			continue;
		if (m_rtmsg.m_rtm.rtm_type == RTM_GET &&
d784 1
a784 1
			break;
a787 6
	populate_rti_info(rti_info, &m_rtmsg.m_rtm);

	sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
	if (check_route_label(sa_rl) == ROUTE_LABEL_DHCLIENT_OURS)
		rslt = 1;

d789 1
a789 1
	return rslt;
@


1.130
log
@Bring route creation into line with what route(8) does. In
particular stop providing RFA_IFA, and instead supply the
relevant interface index in the RTM_ADD message.

Various code simplifications as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.129 2017/08/05 12:08:33 krw Exp $	*/
d80 1
d89 50
d195 7
a201 39
	int			 mib[7];
	char			 ifname[IF_NAMESIZE];
	struct sockaddr		*rti_info[RTAX_MAX];
	char			*lim, *buf = NULL, *bufp, *next, *errmsg = NULL;
	struct rt_msghdr	*rtm;
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*sa_rl;
	size_t			 needed;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_STATIC;
	mib[6] = rdomain;

	while (1) {
		if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
			errmsg = "sysctl size of routes:";
			break;
		}
		if (needed == 0) {
			free(buf);
			return;
		}
		if ((bufp = realloc(buf, needed)) == NULL) {
			errmsg = "routes buf realloc:";
			break;
		}
		buf = bufp;
		if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			errmsg = "sysctl retrieval of routes:";
			break;
		}
		break;
	}
d203 2
a204 4
	if (errmsg != NULL) {
		log_warn("route cleanup failed - %s (msize=%zu)", errmsg,
		    needed);
		free(buf);
a205 1
	}
d207 1
a207 1
	lim = buf + needed;
@


1.129
log
@Don't delete the address/netmask that is about to be
added. Just skip both the delete and the add.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.128 2017/08/04 00:10:14 krw Exp $	*/
d77 1
a77 2
void	add_route(struct in_addr, struct in_addr, struct in_addr,
    struct in_addr, int, int);
d318 2
a319 3
			add_route(dest, netmask, addr, any,
			    RTA_DST | RTA_NETMASK | RTA_GATEWAY,
			    RTF_CLONING | RTF_STATIC);
d336 2
a337 3
				add_route(gateway, addrmask, addr, any,
				    RTA_DST | RTA_NETMASK | RTA_GATEWAY,
				    RTF_CLONING | RTF_STATIC);
d346 1
a346 3
				add_route(any, any, gateway, addr,
				    RTA_DST | RTA_NETMASK | RTA_GATEWAY | RTA_IFA,
				    RTF_STATIC);
d353 2
a354 3
				add_route(any, any, gateway, addr,
				    RTA_DST | RTA_NETMASK | RTA_GATEWAY | RTA_IFA,
				    RTF_GATEWAY | RTF_STATIC);
d362 2
a363 3
			add_route(dest, netmask, gateway, addr,
			    RTA_DST | RTA_NETMASK | RTA_GATEWAY | RTA_IFA,
			    RTF_GATEWAY | RTF_STATIC);
d372 2
a373 2
add_route(struct in_addr dest, struct in_addr netmask,
    struct in_addr gateway, struct in_addr ifa, int addrs, int flags)
a380 2
	imsg.ifa = ifa;
	imsg.addrs = addrs;
d392 2
a393 1
priv_add_route(int rdomain, int routefd, struct imsg_add_route *imsg)
a395 1
	char			 gatewaybuf[INET_ADDRSTRLEN];
d397 1
a397 2
	char			 ifabuf[INET_ADDRSTRLEN];
	struct iovec		 iov[6];
d399 1
a399 1
	struct sockaddr_in	 dest, gateway, mask, ifa;
d401 1
a401 1
	int			 i, iovcnt = 0;
d403 3
a405 4
	memset(destbuf, 0, sizeof(destbuf));
	memset(maskbuf, 0, sizeof(maskbuf));
	memset(gatewaybuf, 0, sizeof(gatewaybuf));
	memset(ifabuf, 0, sizeof(ifabuf));
d413 1
d416 1
a416 2
	rtm.rtm_msglen = sizeof(rtm);
	rtm.rtm_addrs = imsg->addrs;
d419 1
d423 29
a451 56
	if (imsg->addrs & RTA_DST) {
		strlcpy(destbuf, inet_ntoa(imsg->dest), sizeof(destbuf));
		memset(&dest, 0, sizeof(dest));

		dest.sin_len = sizeof(dest);
		dest.sin_family = AF_INET;
		dest.sin_addr.s_addr = imsg->dest.s_addr;

		rtm.rtm_msglen += sizeof(dest);

		iov[iovcnt].iov_base = &dest;
		iov[iovcnt++].iov_len = sizeof(dest);
	}

	if (imsg->addrs & RTA_GATEWAY) {
		strlcpy(gatewaybuf, inet_ntoa(imsg->gateway),
		    sizeof(gatewaybuf));
		memset(&gateway, 0, sizeof(gateway));

		gateway.sin_len = sizeof(gateway);
		gateway.sin_family = AF_INET;
		gateway.sin_addr.s_addr = imsg->gateway.s_addr;

		rtm.rtm_msglen += sizeof(gateway);

		iov[iovcnt].iov_base = &gateway;
		iov[iovcnt++].iov_len = sizeof(gateway);
	}

	if (imsg->addrs & RTA_NETMASK) {
		strlcpy(maskbuf, inet_ntoa(imsg->netmask), sizeof(maskbuf));
		memset(&mask, 0, sizeof(mask));

		mask.sin_len = sizeof(mask);
		mask.sin_family = AF_INET;
		mask.sin_addr.s_addr = imsg->netmask.s_addr;

		rtm.rtm_msglen += sizeof(mask);

		iov[iovcnt].iov_base = &mask;
		iov[iovcnt++].iov_len = sizeof(mask);
	}

	if (imsg->addrs & RTA_IFA) {
		strlcpy(ifabuf, inet_ntoa(imsg->ifa), sizeof(ifabuf));
		memset(&ifa, 0, sizeof(ifa));

		ifa.sin_len = sizeof(ifa);
		ifa.sin_family = AF_INET;
		ifa.sin_addr.s_addr = imsg->ifa.s_addr;

		rtm.rtm_msglen += sizeof(ifa);

		iov[iovcnt].iov_base = &ifa;
		iov[iovcnt++].iov_len = sizeof(ifa);
	}
d465 6
a470 4
		if (i == 4)
			log_warn("failed to add route (%s/%s via %s/%s)",
			    destbuf, maskbuf, gatewaybuf, ifabuf);
		else if (errno == EEXIST || errno == ENETUNREACH)
@


1.128
log
@Do not attempt to parse zero'd input buffer after
read() on routing socket fails. Just bail.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.127 2017/08/03 14:53:22 krw Exp $	*/
d80 1
a80 1
void	delete_addresses(char *);
d511 4
a514 2
 * delete_addresses deletes all existing inet addresses on the specified
 * interface.
d516 2
a517 2
void
delete_addresses(char *name)
d519 1
a519 1
	struct in_addr		 addr;
d521 1
d534 2
a535 1
		memcpy(&addr, &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr,
d537 9
a545 2

		delete_address(addr);
d549 1
d653 2
a654 1
	delete_addresses(name);
@


1.127
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.126 2017/08/03 00:33:07 krw Exp $	*/
d784 1
a784 1
			break;
d787 1
a787 1
			break;
@


1.126
log
@Flush static (RTF_STATIC) routes and not just
gateway (RTF_GATEWAY) routes. Thus catching and
flushing direct routes that could have been
added by dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.125 2017/08/02 13:07:48 krw Exp $	*/
d354 4
a357 4
				* DEFAULT ROUTE IS VIA GATEWAY
				*
				* route add default $gateway
				*/
@


1.125
log
@Delete duplicated switch {} case: block.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.124 2017/07/30 15:26:46 krw Exp $	*/
d159 1
a159 1
	mib[5] = RTF_GATEWAY;
@


1.124
log
@Use effective_proposal data to build resolv.conf contents.

Fix a missing != NULL, and add a comment on why no search
path and no dns servers means resolv.conf.tail is ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.123 2017/07/30 14:05:41 krw Exp $	*/
a204 3
			/* Always delete routes we labeled. */
			delete_route(routefd, rtm);
			break;
@


1.123
log
@Use effective_proposal data to set mtu and address.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.122 2017/07/29 15:07:47 krw Exp $	*/
d823 2
a824 2
    struct option_data *domainname, struct option_data *nameservers,
    struct option_data *domainsearch)
d826 2
a827 1
	char		*dn, *ns, *nss[MAXNS], *contents, *courtesy, *p, *buf;
d829 2
a830 1
	int		 i, rslt;
d833 1
d835 3
a837 13
	if (domainsearch->len != 0) {
		buf = pretty_print_domain_search(domainsearch->data,
		    domainsearch->len);
		if (buf == NULL)
			dn = strdup("");
		else {
			rslt = asprintf(&dn, "search %s\n", buf);
			if (rslt == -1)
				dn = NULL;
		}
	} else if (domainname->len != 0) {
		rslt = asprintf(&dn, "search %s\n",
		    pretty_print_option(DHO_DOMAIN_NAME, domainname, 0));
d844 1
d846 8
a853 10
	if (nameservers->len != 0) {
		ns = pretty_print_option(DHO_DOMAIN_NAME_SERVERS, nameservers,
		    0);
		for (i = 0; i < MAXNS; i++) {
			p = strsep(&ns, " ");
			if (p == NULL)
				break;
			if (*p == '\0')
				continue;
			rslt = asprintf(&nss[i], "nameserver %s\n", p);
d856 2
d861 6
a866 6
	len = strlen(dn);
	for (i = 0; i < MAXNS; i++)
		if (nss[i] != NULL)
			len += strlen(nss[i]);

	if (len > 0 && config->resolv_tail)
d897 1
a897 1
	if (config->resolv_tail)
@


1.122
log
@Default routes supplied via DHO_CLASSLESS[_MS]_STATIC_ROUTES
should have the same add_route() logic applied to them as
the one supplied via DHO_ROUTERS. i.e. add the /32 route
if needed, create direct route if gateway address is the
same as interface address.

Simplify logic by using the canonical rtstatic[] version
of static routes created by lease_as_proposal().
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.121 2017/07/27 12:52:58 krw Exp $	*/
d596 1
a596 1
set_mtu(struct option_data *mtu)
d601 1
a601 1
	if (mtu->len != sizeof(uint16_t))
d604 2
a605 4
	memcpy(&imsg.mtu, mtu->data, sizeof(uint16_t));
	imsg.mtu = ntohs(imsg.mtu);
	if (imsg.mtu < 68) {
		log_warnx("mtu size %u < 68: ignored", imsg.mtu);
d608 1
d638 1
a638 1
set_address(char *name, struct in_addr addr, struct option_data *mask)
d647 1
a647 4
	if (mask->len == sizeof(imsg.mask))
		imsg.mask.s_addr = ((struct in_addr *)mask->data)->s_addr;
	else
		imsg.mask.s_addr = INADDR_ANY;
@


1.121
log
@Kill extra whitespace that snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.120 2017/07/27 12:45:06 krw Exp $	*/
d281 2
a282 3
set_routes(struct in_addr addr, struct option_data *classless,
    struct option_data *msclassless, struct option_data *routers,
    struct option_data *subnet)
a285 1
	struct option_data	*opt;
a289 45
	if (classless->len != 0)
		opt = classless;
	else if (msclassless->len != 0)
		opt = msclassless;
	else {
		/* Add default route. */
		if (routers->len < sizeof(struct in_addr))
			return;

		/* XXX Only use FIRST router address for now. */
		gateway.s_addr = ((struct in_addr *)routers->data)->s_addr;

		opt = subnet;
		if (opt->len == sizeof(struct in_addr)) {
			netmask.s_addr = ((struct in_addr *)opt->data)->s_addr;
			if (netmask.s_addr == INADDR_BROADCAST) {
				/*
				 * To be compatible with ISC DHCP behavior on
				 * Linux, if we were given a /32 IP assignment
				 * then add a /32 direct route for the gateway
				 * to make it routable.
				 *
				 * route add -net $gateway -netmask $netmask
				 *     -cloning -iface $addr
				 */
				add_route(gateway, netmask, addr, any,
				    RTA_DST | RTA_NETMASK | RTA_GATEWAY,
				    RTF_CLONING | RTF_STATIC);
			}
		}

		if (memcmp(&gateway, &addr, sizeof(addr)) == 0) {
			/* route -q $rdomain add default -iface $addr */
			add_route(any, any, gateway, addr,
			    RTA_DST | RTA_NETMASK | RTA_GATEWAY | RTA_IFA,
			    RTF_STATIC);
		} else {
			/* route -q $rdomain add default $gateway */
			add_route(any, any, gateway, addr,
			    RTA_DST | RTA_NETMASK | RTA_GATEWAY | RTA_IFA,
			    RTF_GATEWAY | RTF_STATIC);
		}
		return;
	}

d292 2
a293 2
	while (i < opt->len) {
		bits = opt->data[i++];
d298 1
a298 1
		else if (i + bytes > opt->len)
d306 1
a306 1
		memcpy(&dest, &opt->data[i], bytes);
d310 1
a310 1
		if (i + sizeof(gateway) > opt->len)
d312 1
a312 1
		memcpy(&gateway, &opt->data[i], sizeof(gateway));
d317 2
d325 46
a370 2
		} else
			/* route add -net $dest -netmask $netmask $gateway */
d374 1
@


1.120
log
@Fold add_direct_route(), add_default_route() and
add_classless_static_routes() into set_routes(). One
less layer of abstraction and all five add_route()
invocations now in one place.

Clearly comment the route(8) command equivalents for each
add_route() invocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.119 2017/07/26 13:22:03 krw Exp $	*/
d364 1
a364 1
			 * route add -net $dest -netmask $netmask -cloning 
@


1.119
log
@Fix add_default_route() so -iface routes are actually
created when gateway == interface address.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.118 2017/07/24 18:13:19 krw Exp $	*/
a253 91
 * add_direct_route is the equivalent of
 *
 *     route add -net $dest -netmask $mask -cloning -iface $iface
 */
void
add_direct_route(struct in_addr dest, struct in_addr mask,
    struct in_addr iface)
{
	struct in_addr	 ifa = { INADDR_ANY };

	add_route(dest, mask, iface, ifa,
	    RTA_DST | RTA_NETMASK | RTA_GATEWAY, RTF_CLONING | RTF_STATIC);
}

/*
 * add_default_route is the equivalent of
 *
 *	route -q $rdomain add default -iface $router
 *
 *	or
 *
 *	route -q $rdomain add default $router
 */
void
add_default_route(struct in_addr gateway, struct in_addr addr)
{
	struct in_addr	 netmask, dest;
	int		 addrs, flags;

	memset(&netmask, 0, sizeof(netmask));
	memset(&dest, 0, sizeof(dest));
	addrs = RTA_DST | RTA_NETMASK | RTA_GATEWAY | RTA_IFA;
	flags = RTF_GATEWAY | RTF_STATIC;

	/*
	 * When 'addr' and 'gateway' are identical the desired behaviour is
	 * to emulate the '-iface' variant of 'route'. i.e. do *NOT* set
	 * the RTF_GATEWAY flag for the default route.
	 */
	if (memcmp(&gateway, &addr, sizeof(addr)) == 0)
		flags &= ~RTF_GATEWAY;

	add_route(dest, netmask, gateway, addr, addrs, flags);
}

/*
 *
 * add_classless_static_routes() accepts a list of static routes in the
 * format specified for DHCP options 121 (classless-static-routes) and
 * 249 (classless-ms-static-routes).
 */
void
add_classless_static_routes(struct option_data *opt, struct in_addr iface)
{
	struct in_addr	 dest, netmask, gateway;
	unsigned int	 i, bits, bytes;

	i = 0;
	while (i < opt->len) {
		bits = opt->data[i++];
		bytes = (bits + 7) / 8;

		if (bytes > sizeof(netmask))
			return;
		else if (i + bytes > opt->len)
			return;

		if (bits != 0)
			netmask.s_addr = htonl(0xffffffff << (32 - bits));
		else
			netmask.s_addr = INADDR_ANY;

		memcpy(&dest, &opt->data[i], bytes);
		dest.s_addr = dest.s_addr & netmask.s_addr;
		i += bytes;

		if (i + sizeof(gateway) > opt->len)
			return;
		memcpy(&gateway, &opt->data[i], sizeof(gateway));
		i += sizeof(gateway);

		if (gateway.s_addr == INADDR_ANY)
			add_direct_route(dest, netmask, iface);
		else
			add_route(dest, netmask, gateway, iface,
			    RTA_DST | RTA_GATEWAY | RTA_NETMASK | RTA_IFA,
			    RTF_GATEWAY | RTF_STATIC);
	}
}

/*
d285 4
a288 1
	struct in_addr	gateway, mask;
d292 42
a333 2
	if (classless->len != 0) {
		add_classless_static_routes(classless, addr);
d337 15
a351 4
	if (msclassless->len != 0) {
		add_classless_static_routes(msclassless, addr);
		return;
	}
d353 3
a355 3
	if (routers->len >= sizeof(gateway)) {
		/* XXX Only use FIRST router address for now. */
		gateway.s_addr = ((struct in_addr *)routers->data)->s_addr;
d357 4
a360 10
		/*
		 * To be compatible with ISC DHCP behavior on Linux, if
		 * we were given a /32 IP assignment, then add a /32
		 * direct route for the gateway to make it routable.
		 */
		if (subnet->len == sizeof(mask)) {
			mask.s_addr = ((struct in_addr *)subnet->data)->s_addr;
			if (mask.s_addr == INADDR_BROADCAST)
				add_direct_route(gateway, mask, addr);
		}
d362 13
a374 1
		add_default_route(gateway, addr);
@


1.118
log
@Throw DHO_STATIC_ROUTES to the floor! Roughly! Ensure
they don't appear in effective leases at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.117 2017/07/24 17:15:41 krw Exp $	*/
d285 2
a286 2
	addrs = RTA_DST | RTA_NETMASK;
	flags = 0;
d290 2
a291 2
	 * to emulate the '-iface' variant of 'route'. This is done by
	 * claiming there is no gateway address to use.
d293 2
a294 4
	if (memcmp(&gateway, &addr, sizeof(addr)) != 0) {
		addrs |= RTA_GATEWAY | RTA_IFA;
		flags |= RTF_GATEWAY | RTF_STATIC;
	}
@


1.117
log
@Shuffle some declarations and functions into the only
files they are used in. Tweak a bunch of whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.116 2017/07/24 13:51:43 krw Exp $	*/
d376 1
a376 1
    struct option_data *classfull, struct option_data *subnet)
a408 3

	if (classfull->len != 0) 
		log_warnx("DHO_STATIC_ROUTES (option 33) not supported");
@


1.116
log
@Move invocations of flush_routes() and delete_addresses() from
bind_lease() into set_routes() and set_address() respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.115 2017/07/24 11:00:01 friehm Exp $	*/
d77 2
@


1.115
log
@Unify ROUNDUP macros for parsing route messages.
Use the macro from route(8) / ospf6d(8) since it works also with argument 0.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.114 2017/07/23 13:44:53 krw Exp $	*/
d77 2
a78 1

d378 2
d673 1
a673 1
set_address(struct in_addr addr, struct option_data *mask)
d677 3
@


1.114
log
@Cease pretending to support option 33 (classFULL static routes). They
are dead to the internet. And the current code actually creates /32
routes since kernel magic for classfull routes died a while ago.

ok phessler@@ claudio@@ reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.113 2017/07/22 17:55:20 krw Exp $	*/
d50 2
a51 2
#define ROUNDUP(a)	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : \
    sizeof(long))
@


1.113
log
@Add set_routes() and move bind_lease() route magic
into it. Swap parameter order in add_default_route() to
be consistant with other add_*_route() functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.112 2017/07/22 14:56:27 krw Exp $	*/
a298 29
 * add_static_routes() accepts a list of static routes in the format
 * specified for DHCP option 33 (static-routes) and adds them to the
 * routing table.
 */
void
add_static_routes(struct option_data *static_routes, struct in_addr iface)
{
	struct in_addr		 dest, netmask, gateway;
	struct in_addr		 *addr;
	int			 i;

	netmask.s_addr = INADDR_ANY;	/* Not used for CLASSFULL! */

	for (i = 0; (i + 2*sizeof(*addr)) <= static_routes->len;
	     i += 2*sizeof(*addr)) {
		addr = (struct in_addr *)&static_routes->data[i];
		if (addr->s_addr == INADDR_ANY)
			continue; /* RFC 2132 says 0.0.0.0 is not allowed. */

		dest.s_addr = addr->s_addr;
		gateway.s_addr = (addr+1)->s_addr;

		/* XXX Order implies priority but we're ignoring that. */
		add_route(dest, netmask, gateway, iface,
		    RTA_DST | RTA_GATEWAY | RTA_IFA, RTF_GATEWAY | RTF_STATIC);
	}
}

/*
d405 2
a406 2
	if (classfull->len != 0)
		add_static_routes(classfull, addr);
@


1.112
log
@Rename *_add_address to *_set_address to reflect that the
lease address replaces all current addresses. Shuffle some
code from bind_lease() into set_mtu()/set_address() to
shrink  bind_lease().
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.111 2017/07/21 18:57:55 krw Exp $	*/
d275 1
a275 1
add_default_route(struct in_addr addr, struct in_addr gateway)
d397 39
@


1.111
log
@s/set_interface_mtu/set_mtu/g
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.110 2017/07/17 17:53:59 krw Exp $	*/
d617 1
a617 1
set_mtu(int mtu)
d622 9
a630 1
	imsg.mtu = mtu;
d655 1
a655 1
 * [priv_]add_address is the equivalent of
d660 1
a660 1
add_address(struct in_addr addr, struct in_addr mask)
d662 1
a662 1
	struct imsg_add_address	 imsg;
d666 4
a669 1
	imsg.mask = mask;
d671 1
a671 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ADDRESS, 0, 0, -1, &imsg,
d674 1
a674 1
		log_warn("add_address: imsg_compose");
d676 1
a676 1
	flush_unpriv_ibuf("add_address");
d680 1
a680 1
priv_add_address(char *name, int ioctlfd, struct imsg_add_address *imsg)
@


1.110
log
@Nuke unused variables 'deleting' and 'adding'.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.109 2017/07/14 16:21:03 krw Exp $	*/
d612 1
a612 1
 * [priv_]set_interface_mtu is the equivalent of
d617 1
a617 1
set_interface_mtu(int mtu)
d619 2
a620 2
	struct imsg_set_interface_mtu	 imsg;
	int				 rslt;
d624 1
a624 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_SET_INTERFACE_MTU, 0, 0, -1,
d627 1
a627 1
		log_warn("set_interface_mtu: imsg_compose");
d629 1
a629 1
	flush_unpriv_ibuf("set_interface_mtu");
d633 1
a633 2
priv_set_interface_mtu(char *name, int ioctlfd,
    struct imsg_set_interface_mtu *imsg)
@


1.109
log
@Replace remaining "!var" expressions with
"<var> == 0", "!(<var> & FLAG)" with
"(<var> & FLAG) == 0", "!<func()>"
with "<func()> == 0" and "!<define>" with
"<define> == 0". And the positive cases
as well.

A few stray == NULL and != NULL as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.108 2017/07/14 14:03:15 krw Exp $	*/
a72 3
struct in_addr deleting;
struct in_addr adding;

a574 3
	/* Note the address we are deleting for RTM_DELADDR filtering! */
	deleting.s_addr = addr.s_addr;

a656 3

	/* Note the address we are adding for RTM_NEWADDR filtering! */
	adding = addr;
@


1.108
log
@Replace remaining "!<pointer>" expressions with
"<pointer> == NULL". And of course "<pointer>"
expressions with "<pointer> != NULL".
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.107 2017/07/10 14:11:47 krw Exp $	*/
d185 1
a185 1
	if (errmsg) {
d352 1
a352 1
		if (bits)
d551 3
a553 3
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT) ||
		    (!(ifa->ifa_flags & IFF_UP)) ||
d747 1
a747 1
 * resolve_conf_priority decides if the interface is the best one to
d818 1
a818 1
			if (m_rtmsg.m_rtm.rtm_errno) {
d853 1
a853 1
	if (domainsearch->len) {
d863 1
a863 1
	} else if (domainname->len) {
d873 1
a873 1
	if (nameservers->len) {
d890 1
a890 1
		if (nss[i])
d918 1
a918 1
		if (nss[i]) {
@


1.107
log
@Use ioctlfd/routefd sockets rather than rolling one's own
for resolving 'egress' and adding a route. Move creation
of main()'s ioctlfd up so it can be used for the
'egress' resolution.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.106 2017/07/10 00:47:47 krw Exp $	*/
d101 1
a101 1
	if (!label)
@


1.106
log
@Use a modern spacious idiom on all function local variable
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.105 2017/07/09 19:19:58 krw Exp $	*/
d428 1
a428 1
priv_add_route(int rdomain, struct imsg_add_route *imsg)
d438 1
a438 4
	int			 s, i, iovcnt = 0;

	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		fatal("Routing Socket open failed");
d527 1
a527 1
		if (writev(s, iov, iovcnt) != -1)
a534 2

	close(s);
@


1.105
log
@Be consistent. "return (e);" -> "return e;"
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.104 2017/07/09 12:38:47 krw Exp $	*/
d133 1
a133 1
	int			 rslt;
d239 2
a240 2
	static int seqno;
	ssize_t rlen;
d262 1
a262 1
	struct in_addr ifa = { INADDR_ANY };
d280 2
a281 2
	struct in_addr netmask, dest;
	int addrs, flags;
d316 1
a316 1
	    i += 2*sizeof(*addr)) {
d384 1
a384 1
	int len;
d430 9
a438 7
	char destbuf[INET_ADDRSTRLEN], gatewaybuf[INET_ADDRSTRLEN];
	char maskbuf[INET_ADDRSTRLEN], ifabuf[INET_ADDRSTRLEN];
	struct rt_msghdr rtm;
	struct sockaddr_in dest, gateway, mask, ifa;
	struct sockaddr_rtlabel label;
	struct iovec iov[6];
	int s, i, iovcnt = 0;
d549 2
a550 2
	struct in_addr addr;
	struct ifaddrs *ifap, *ifa;
d630 2
a631 2
	struct imsg_set_interface_mtu imsg;
	int rslt;
d647 1
a647 1
	struct ifreq ifr;
d666 2
a667 2
	struct imsg_add_address imsg;
	int			rslt;
d716 1
a716 1
	int rslt;
d758 2
a759 1
	struct iovec iov[3];
d763 2
a764 3
	} m_rtmsg;
	struct sockaddr *rti_info[RTAX_MAX];
	struct sockaddr_in sin;
d766 3
a768 3
	pid_t pid;
	ssize_t len;
	int seq, rslt, iovcnt = 0;
d852 3
a854 3
	char *dn, *ns, *nss[MAXNS], *contents, *courtesy, *p, *buf;
	size_t len;
	int i, rslt;
d942 2
a943 2
	struct sockaddr *sa;
	int i;
@


1.104
log
@Whitespace tweaks to assuage auto-indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.103 2017/07/08 00:36:10 krw Exp $	*/
d102 1
a102 1
		return (ROUTE_LABEL_NONE);
d105 1
a105 1
		return (ROUTE_LABEL_NOT_DHCLIENT);
d109 1
a109 1
		return (ROUTE_LABEL_DHCLIENT_UNKNOWN);
d112 1
a112 1
		return (ROUTE_LABEL_DHCLIENT_OURS);
d116 1
a116 1
			return (ROUTE_LABEL_DHCLIENT_DEAD);
d118 1
a118 1
			return (ROUTE_LABEL_DHCLIENT_UNKNOWN);
d121 1
a121 1
	return (ROUTE_LABEL_DHCLIENT_LIVE);
d396 1
a396 1
		return (1);
d399 1
a399 1
	return (0);
d837 1
a837 1
	return (rslt);
d901 1
a901 1
		return (NULL);
d930 1
a930 1
	return (contents);
@


1.103
log
@Always use uintNN_t instead of sometimes u_intNN_t
and sometimes uintNN_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.102 2017/07/02 09:11:13 krw Exp $	*/
d50 2
a51 2
#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
@


1.102
log
@Unbreak tree by putting revised resolv_conf_priority() declaration in
correct place and passing the invocation the correct parameters.

Noticed by & initial diff from matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.101 2017/07/01 23:27:56 krw Exp $	*/
d712 1
a712 1
write_resolv_conf(u_int8_t *contents, size_t sz)
d725 1
a725 1
priv_write_resolv_conf(u_int8_t *contents, size_t sz)
d727 3
a729 3
	const char *path = "/etc/resolv.conf";
	ssize_t n;
	int fd;
@


1.101
log
@Eliminate multiple socket openings/closings and pass
fd'd from main loops as required. One socket to do
ioctl's per process (called ioctlfd) and one socket to
do route messages per socket (called routefd).

Clean up local variable declaration lists in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.100 2017/06/29 13:55:53 krw Exp $	*/
a79 1
int	resolv_conf_priority(int, int);
@


1.100
log
@delete_addresses(), interface_status(), addressinuse(),
lease_as_string() and rewrite_option_db() only use the
interface name, so supply just the name.

Tweak interface_link_forceup() to use the same param
name as other functions taking the interface name.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.99 2017/06/28 16:31:52 krw Exp $	*/
d80 1
a80 1
int	resolv_conf_priority(int);
d144 1
a144 1
priv_flush_routes(char *name, int rdomain)
d146 8
a153 9
	char ifname[IF_NAMESIZE];
	struct sockaddr *rti_info[RTAX_MAX];
	int mib[7];
	size_t needed;
	char *lim, *buf = NULL, *bufp, *next, *errmsg = NULL;
	struct rt_msghdr *rtm;
	struct sockaddr_in *sa_in;
	struct sockaddr_rtlabel *sa_rl;
	int s;
a192 3
	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		fatal("opening socket to flush routes");

d207 1
a207 1
			delete_route(s, rtm);
d210 1
a210 1
			delete_route(s, rtm);
d224 1
a224 1
				delete_route(s, rtm);
a230 1
	close(s);
d596 1
a596 1
priv_delete_address(char *name, struct imsg_delete_address *imsg)
d598 2
a599 3
	struct ifaliasreq ifaliasreq;
	struct sockaddr_in *in;
	int s;
a604 3
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("socket open failed");

d614 1
a614 1
	if (ioctl(s, SIOCDIFADDR, &ifaliasreq) == -1) {
a618 2

	close(s);
d643 2
a644 1
priv_set_interface_mtu(char *name, struct imsg_set_interface_mtu *imsg)
a646 1
	int s;
d653 1
a653 3
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("socket open failed");
	if (ioctl(s, SIOCSIFMTU, &ifr) == -1)
a654 1
	close(s);
d683 1
a683 1
priv_add_address(char *name, struct imsg_add_address *imsg)
d685 2
a686 6
	struct ifaliasreq ifaliasreq;
	struct sockaddr_in *in;
	int s;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("socket open failed");
d705 1
a705 1
	if (ioctl(s, SIOCAIFADDR, &ifaliasreq) == -1)
a706 2

	close(s);
d726 1
a726 1
priv_write_resolv_conf(int rdomain, u_int8_t *contents, size_t sz)
a731 3
	if (!resolv_conf_priority(rdomain))
		return;

d755 1
a755 1
resolv_conf_priority(int rdomain)
d767 1
a767 1
	int s, seq, rslt, iovcnt = 0;
a770 6
	s = socket(PF_ROUTE, SOCK_RAW, AF_INET);
	if (s == -1) {
		log_warn("default route socket");
		return (0);
	}

d800 1
a800 1
	if (writev(s, iov, iovcnt) == -1) {
d809 1
a809 1
		len = read(s, &m_rtmsg, sizeof(m_rtmsg));
a837 1
	close(s);
@


1.99
log
@Only pass required fields of interface_info to priv_* functions
and friends. i.e. ifi->name, ifi->rdomain, or both.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.98 2017/06/28 15:45:32 krw Exp $	*/
d551 1
a551 1
delete_addresses(struct interface_info *ifi)
d564 1
a564 1
		    (strcmp(ifi->name, ifa->ifa_name) != 0))
@


1.98
log
@delete_route() doesn't need any info from its struct interface_info
parameter as the route message already has the correct tableid. So
eliminate the useless parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.97 2017/06/28 15:23:19 krw Exp $	*/
d144 1
a144 1
priv_flush_routes(struct interface_info *ifi)
d162 1
a162 1
	mib[6] = ifi->rdomain;
d226 2
a227 2
			    rtm->rtm_tableid == ifi->rdomain &&
			    strcmp(ifi->name, ifname) == 0)
d434 1
a434 1
priv_add_route(struct interface_info *ifi, struct imsg_add_route *imsg)
d458 1
a458 1
	rtm.rtm_tableid = ifi->rdomain;
d601 1
a601 2
priv_delete_address(struct interface_info *ifi,
    struct imsg_delete_address *imsg)
d615 1
a615 1
	strncpy(ifaliasreq.ifra_name, ifi->name, sizeof(ifaliasreq.ifra_name));
d654 1
a654 2
priv_set_interface_mtu(struct interface_info *ifi,
    struct imsg_set_interface_mtu *imsg)
d661 1
a661 1
	strlcpy(ifr.ifr_name, ifi->name, sizeof(ifr.ifr_name));
d697 1
a697 1
priv_add_address(struct interface_info *ifi, struct imsg_add_address *imsg)
d707 1
a707 1
	strncpy(ifaliasreq.ifra_name, ifi->name, sizeof(ifaliasreq.ifra_name));
d746 1
a746 1
priv_write_resolv_conf(struct interface_info *ifi, u_int8_t *contents, size_t sz)
d752 1
a752 1
	if (!resolv_conf_priority(ifi->rdomain))
d877 1
a877 1
resolv_conf_contents(struct interface_info *ifi,
d935 1
a935 1
	rslt = asprintf(&courtesy, "# Generated by %s dhclient\n", ifi->name);
@


1.97
log
@resolv_conf_priority() is a function local to kroute.c, no
need to expose its definition in dhcpd.h. While here change
the parameter from struct interface_info to int and just pass
the only field used (rdomain).
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.96 2017/06/28 14:35:43 krw Exp $	*/
d79 1
a79 1
void	delete_route(struct interface_info *, int, struct rt_msghdr *);
d211 1
a211 1
			delete_route(ifi, s, rtm);
d214 1
a214 1
			delete_route(ifi, s, rtm);
d228 1
a228 1
				delete_route(ifi, s, rtm);
d243 1
a243 1
delete_route(struct interface_info *ifi, int s, struct rt_msghdr *rtm)
a248 1
	rtm->rtm_tableid = ifi->rdomain;
@


1.96
log
@Stop trying to clean up addresses, routes and "-L" file
whenever dhclient dies. Eliminates differences in handling
and thus need to intercept signals INT, TERM, USR1,
USR2. Eliminates need for 'zapzombies' field and thus
entire struct imsg_flushroutes. Eliminates need for 'imsg'
parameter to and associated logic in priv_flush_routes().

Address, routes and '-L' file are still cleaned out when
binding a lease.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.95 2017/06/28 11:53:08 krw Exp $	*/
d80 2
d755 1
a755 1
	if (!resolv_conf_priority(ifi))
d781 1
a781 1
resolv_conf_priority(struct interface_info *ifi)
d812 1
a812 1
	m_rtmsg.m_rtm.rtm_tableid = ifi->rdomain;
@


1.95
log
@Be consistent and always use socket(..., SOCK_DGRAM, ...) for
the sockets being used to issue ioctl()'s.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.94 2017/06/25 00:44:49 krw Exp $	*/
a72 1
struct in_addr active_addr;
a131 1
	struct imsg_flush_routes imsg;
d134 1
a134 4
	imsg.zapzombies = 1;

	rslt = imsg_compose(unpriv_ibuf, IMSG_FLUSH_ROUTES, 0, 0, -1,
	    &imsg, sizeof(imsg));
d142 1
a142 1
priv_flush_routes(struct interface_info *ifi, struct imsg_flush_routes *imsg)
d212 1
a212 2
			if (imsg->zapzombies)
				delete_route(ifi, s, rtm);
a727 21

	active_addr = imsg->addr;
}

/*
 * priv_cleanup removes dhclient installed routes and address.
 */
void
priv_cleanup(struct interface_info *ifi)
{
	struct imsg_flush_routes fimsg;
	struct imsg_delete_address dimsg;

	fimsg.zapzombies = 0;	/* Only zapzombies when binding a lease. */
	priv_flush_routes(ifi, &fimsg);

	if (active_addr.s_addr == INADDR_ANY)
		return;

	dimsg.addr = active_addr;
	priv_delete_address(ifi, &dimsg);
@


1.94
log
@priv_add_address() is no longer invoked to signal the deletion of the
active address. So no need to check for the magic INADDR_ANY address.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.93 2017/06/24 23:32:57 krw Exp $	*/
d617 1
a617 1
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
d671 1
a671 1
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
d710 1
a710 1
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
@


1.93
log
@Tweak handling of HUP and new LLADDR. Just use expose and use sighup()
function. Don't exit dispatch() loop on SIGHUP, wait for privileged
child to execvp() dhclient. Eliminate struct imsg_hup since its
contents were not being used except in priv_cleanup(). And
'active_addr' works just as well there.

Cleaner and eliminates some extraneous log entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.92 2017/06/23 15:40:56 krw Exp $	*/
a708 11

	if (imsg->addr.s_addr == INADDR_ANY) {
		/* Notification that the active_addr has been deleted. */
		active_addr.s_addr = INADDR_ANY;
		quit = INTERNALSIG;
		return;
	}

	/*
	 * Add specified address on specified interface.
	 */
@


1.92
log
@Take reyk's imsg resolv.conf improvements of a while ago to their
logical conclusion.

Nuke _PATH_RESOLV_CONF since the value is only meant to be
known inside priv_write_resolv_conf(). Just use a local const char *.

Bring priv_write_resolv_conf() into line with other priv_ functions
invoked from the dispatch loop. i.e. don't pass it the imsg, just pass
a pointer to the data and a size after ensuring there is data to pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.91 2017/04/12 12:22:25 krw Exp $	*/
d753 1
a753 1
priv_cleanup(struct interface_info *ifi, struct imsg_hup *imsg)
d761 1
a761 1
	if (imsg->addr.s_addr == INADDR_ANY)
d764 1
a764 1
	dimsg.addr = imsg->addr;
@


1.91
log
@Shuffle another function.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.90 2017/04/11 13:59:27 krw Exp $	*/
d785 1
a785 1
priv_write_resolv_conf(struct interface_info *ifi, struct imsg *imsg)
d787 1
a787 1
	u_int8_t *contents;
a788 1
	size_t sz;
a790 6

	if (imsg->hdr.len < IMSG_HEADER_SIZE) {
		log_warnx("short IMSG_WRITE_RESOLV_CONF");
		return;
	}

d794 1
a794 4
	contents = imsg->data;
	sz = imsg->hdr.len - IMSG_HEADER_SIZE;

	fd = open(_PATH_RESOLV_CONF, O_WRONLY | O_CREAT | O_TRUNC,
d798 1
a798 1
		log_warn("Couldn't open '%s'", _PATH_RESOLV_CONF);
d804 1
a804 1
		log_warn("Couldn't write contents to '%s'", _PATH_RESOLV_CONF);
d807 1
a807 1
		    _PATH_RESOLV_CONF, n, sz);
@


1.90
log
@Shuffle route/interface changing functions together into kroute.c. Try to
group related functions in kroute.c together and comment them a bit.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.89 2017/04/11 10:40:14 krw Exp $	*/
d53 20
a1031 20
	}
}

/*
 * flush_unpriv_ibuf makes sure queued messages are delivered to the
 * imsg socket.
 */
void
flush_unpriv_ibuf(const char *who)
{
	while (unpriv_ibuf->w.queued) {
		if (msgbuf_write(&unpriv_ibuf->w) <= 0) {
			if (errno == EAGAIN)
				break;
			if (quit == 0)
				quit = INTERNALSIG;
			if (errno != EPIPE && errno != 0)
				log_warn("%s: msgbuf_write", who);
			break;
		}
@


1.89
log
@Fold priv_write_file() into its only remaining user
priv_write_resolv_conf() and move the latter into kroute.c
with all its priv_ friends.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.88 2017/04/09 20:44:13 krw Exp $	*/
d38 1
d54 2
d70 36
a105 1
 * Do equivalent of
d223 173
d532 2
a533 1
 * Delete all existing inet addresses on interface.
d749 1
a749 1
 * priv_write_resolv_conf writes out a new resolv.conf.
d752 13
d802 4
d900 50
a949 4
int
create_route_label(struct sockaddr_rtlabel *label)
{
	int len;
d951 4
a954 4
	memset(label, 0, sizeof(*label));

	label->sr_len = sizeof(label);
	label->sr_family = AF_UNSPEC;
d956 2
a957 2
	len = snprintf(label->sr_label, sizeof(label->sr_label), "DHCLIENT %d",
	    (int)getpid());
d959 3
a961 3
	if (len == -1 || (unsigned int)len >= sizeof(label->sr_label)) {
		log_warn("could not create route label");
		return (1);
d964 4
a967 2
	return (0);
}
d969 17
a985 10
int
check_route_label(struct sockaddr_rtlabel *label)
{
	pid_t pid;

	if (!label)
		return (ROUTE_LABEL_NONE);

	if (strncmp("DHCLIENT ", label->sr_label, 9) != 0)
		return (ROUTE_LABEL_NOT_DHCLIENT);
d987 2
a988 3
	pid = (pid_t)strtonum(label->sr_label + 9, 1, INT_MAX, NULL);
	if (pid <= 0)
		return (ROUTE_LABEL_DHCLIENT_UNKNOWN);
d990 1
a990 11
	if (pid == getpid())
		return (ROUTE_LABEL_DHCLIENT_OURS);

	if (kill(pid, 0) == -1) {
		if (errno == ESRCH)
			return (ROUTE_LABEL_DHCLIENT_DEAD);
		else
			return (ROUTE_LABEL_DHCLIENT_UNKNOWN);
	}

	return (ROUTE_LABEL_DHCLIENT_LIVE);
d993 4
d1015 4
a1018 18
void
delete_route(struct interface_info *ifi, int s, struct rt_msghdr *rtm)
{
	static int seqno;
	ssize_t rlen;

	rtm->rtm_type = RTM_DELETE;
	rtm->rtm_tableid = ifi->rdomain;
	rtm->rtm_seq = seqno++;

	rlen = write(s, (char *)rtm, rtm->rtm_msglen);
	if (rlen == -1) {
		if (errno != ESRCH)
			fatal("RTM_DELETE write");
	} else if (rlen < (int)rtm->rtm_msglen)
		fatalx("short RTM_DELETE write (%zd)\n", rlen);
}

@


1.88
log
@Seven casts, a couple of tweaks and CFLAGS+=-Wsign-compare for the
win.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.87 2017/04/08 20:16:04 krw Exp $	*/
d21 1
d34 1
d534 41
@


1.87
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.86 2017/04/05 18:22:31 krw Exp $	*/
d641 2
a642 8
	if (len == -1) {
		log_warn("creating route label");
		return (1);
	}

	if (len >= sizeof(label->sr_label)) {
		log_warnx("creating route label: label too long (%d vs %zu)",
		    len, sizeof(label->sr_label));
@


1.86
log
@Shuffle sendhup() into dispatch.c, the only place it is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.85 2017/03/08 15:07:32 krw Exp $	*/
d547 1
a547 2
	u_int32_t seq;
	int s, rslt, iovcnt = 0;
@


1.85
log
@Move ROUNDUP() to top of file, outside of warring #ifdef's to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.84 2017/02/12 15:53:15 krw Exp $	*/
a512 22
}

/*
 * Inform the [priv] process a HUP was received and it should restart.
 */
void
sendhup(struct client_lease *active)
{
	struct imsg_hup imsg;
	int rslt;

	if (active)
		imsg.addr = active->address;
	else
		imsg.addr.s_addr = INADDR_ANY;

	rslt = imsg_compose(unpriv_ibuf, IMSG_HUP, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("sendhup: imsg_compose");

	flush_unpriv_ibuf("sendhup");
@


1.84
log
@Eliminate most strerror() invocations by using log_warn() and fatal()
instead of log_warnx() and fatalx(). A few log_info() to log_warn()
for the same reason.

Suggested by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.83 2017/02/12 13:55:01 krw Exp $	*/
d47 3
a710 3

#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
@


1.83
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.82 2017/02/12 13:15:50 krw Exp $	*/
d78 1
a78 1
		log_warnx("flush_routes: imsg_compose: %s", strerror(errno));
d128 2
a129 2
		log_warnx("route cleanup failed - %s %s (msize=%zu)",
		    errmsg, strerror(errno), needed);
d135 1
a135 1
		fatalx("opening socket to flush routes: %s", strerror(errno));
d197 1
a197 1
		log_warnx("add_route: imsg_compose: %s", strerror(errno));
d214 1
a214 1
		fatalx("Routing Socket open failed: %s", strerror(errno));
d306 2
a307 3
			log_warnx("failed to add route (%s/%s via %s/%s): %s",
			    destbuf, maskbuf, gatewaybuf, ifabuf,
			    strerror(errno));
d325 1
a325 1
		fatalx("delete_addresses getifaddrs: %s", strerror(errno));
d363 1
a363 1
		log_warnx("delete_address: imsg_compose: %s", strerror(errno));
d381 1
a381 1
		fatalx("socket open failed: %s", strerror(errno));
d394 2
a395 2
			log_warnx("SIOCDIFADDR failed (%s): %s",
			    inet_ntoa(imsg->addr), strerror(errno));
d417 1
a417 2
		log_warnx("set_interface_mtu: imsg_compose: %s",
		    strerror(errno));
d435 1
a435 1
		fatalx("socket open failed: %s", strerror(errno));
d437 1
a437 2
		log_warnx("SIOCSIFMTU failed (%d): %s", imsg->mtu,
		    strerror(errno));
d461 1
a461 1
		log_warnx("add_address: imsg_compose: %s", strerror(errno));
d485 1
a485 1
		fatalx("socket open failed: %s", strerror(errno));
d505 1
a505 2
		log_warnx("SIOCAIFADDR failed (%s): %s", inet_ntoa(imsg->addr),
		    strerror(errno));
d529 1
a529 1
		log_warnx("sendhup: imsg_compose: %s", strerror(errno));
d573 1
a573 1
		log_warnx("default route socket: %s", strerror(errno));
d608 1
a608 2
			log_warnx("RTM_GET of default route: %s",
			    strerror(errno));
d617 1
a617 2
			log_warnx("get default route read: %s",
			    strerror(errno));
d662 1
a662 1
		log_warnx("creating route label: %s", strerror(errno));
d737 1
a737 1
			fatalx("RTM_DELETE write: %s", strerror(errno));
d752 1
a752 2
				log_warnx("%s: msgbuf_write: %s", who,
				    strerror(errno));
@


1.82
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.81 2016/08/23 09:26:02 mpi Exp $	*/
d418 2
a419 1
		log_warnx("set_interface_mtu: imsg_compose: %s", strerror(errno));
d622 2
a623 1
			log_warnx("get default route read: %s", strerror(errno));
d673 2
a674 2
		log_warnx("creating route label: label too long (%d vs %zu)", len,
		    sizeof(label->sr_label));
@


1.81
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.80 2016/07/21 09:58:55 krw Exp $	*/
d44 1
d78 1
a78 1
		warning("flush_routes: imsg_compose: %s", strerror(errno));
d128 1
a128 1
		warning("route cleanup failed - %s %s (msize=%zu)",
d135 1
a135 1
		error("opening socket to flush routes: %s", strerror(errno));
d197 1
a197 1
		warning("add_route: imsg_compose: %s", strerror(errno));
d214 1
a214 1
		error("Routing Socket open failed: %s", strerror(errno));
d306 1
a306 1
			warning("failed to add route (%s/%s via %s/%s): %s",
d326 1
a326 1
		error("delete_addresses getifaddrs: %s", strerror(errno));
d364 1
a364 1
		warning("delete_address: imsg_compose: %s", strerror(errno));
d382 1
a382 1
		error("socket open failed: %s", strerror(errno));
d395 1
a395 1
			warning("SIOCDIFADDR failed (%s): %s",
d418 1
a418 1
		warning("set_interface_mtu: imsg_compose: %s", strerror(errno));
d436 1
a436 1
		error("socket open failed: %s", strerror(errno));
d438 1
a438 1
		warning("SIOCSIFMTU failed (%d): %s", imsg->mtu,
d463 1
a463 1
		warning("add_address: imsg_compose: %s", strerror(errno));
d487 1
a487 1
		error("socket open failed: %s", strerror(errno));
d507 1
a507 1
		warning("SIOCAIFADDR failed (%s): %s", inet_ntoa(imsg->addr),
d532 1
a532 1
		warning("sendhup: imsg_compose: %s", strerror(errno));
d576 1
a576 1
		warning("default route socket: %s", strerror(errno));
d611 1
a611 1
			warning("RTM_GET of default route: %s",
d621 1
a621 1
			warning("get default route read: %s", strerror(errno));
d624 1
a624 1
			warning("no data from default route read");
d633 1
a633 1
				warning("default route read rtm: %s",
d666 1
a666 1
		warning("creating route label: %s", strerror(errno));
d671 1
a671 1
		warning("creating route label: label too long (%d vs %zu)", len,
d741 1
a741 1
			error("RTM_DELETE write: %s", strerror(errno));
d743 1
a743 1
		error("short RTM_DELETE write (%zd)\n", rlen);
d756 1
a756 1
				warning("%s: msgbuf_write: %s", who,
@


1.80
log
@Use explicit idiom when testing the result of strcmp() and strncmp().
i.e. == 0 and != 0 as appropriate. No intentional functional change.

Suggested by & ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.79 2016/02/06 19:30:52 krw Exp $	*/
d51 1
a51 1
void	delete_route(int, struct rt_msghdr *);
d83 1
a83 1
priv_flush_routes(struct imsg_flush_routes *imsg)
d150 1
a150 1
			delete_route(s, rtm);
d154 1
a154 1
				delete_route(s, rtm);
d168 1
a168 1
				delete_route(s, rtm);
d202 1
a202 1
priv_add_route(struct imsg_add_route *imsg)
d319 1
a319 1
delete_addresses(void)
d369 2
a370 1
priv_delete_address(struct imsg_delete_address *imsg)
d423 2
a424 1
priv_set_interface_mtu(struct imsg_set_interface_mtu *imsg)
d468 1
a468 1
priv_add_address(struct imsg_add_address *imsg)
d540 1
a540 1
priv_cleanup(struct imsg_hup *imsg)
d546 1
a546 1
	priv_flush_routes(&fimsg);
d552 1
a552 1
	priv_delete_address(&dimsg);
d556 1
a556 1
resolv_conf_priority(void)
d728 1
a728 1
delete_route(int s, struct rt_msghdr *rtm)
@


1.79
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.78 2015/12/19 14:56:22 krw Exp $	*/
d332 1
a332 1
		    (strcmp(ifi->name, ifa->ifa_name)))
d684 1
a684 1
	if (strncmp("DHCLIENT ", label->sr_label, 9))
@


1.78
log
@Don't exit if a route can't be added. Just log particulars and
let someone else figure it out.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.77 2015/12/19 01:09:10 krw Exp $	*/
a18 3
#include "dhcpd.h"
#include "privsep.h"

d20 1
a21 1
#include <sys/uio.h>
d23 3
d27 1
d29 4
d34 2
d37 8
@


1.77
log
@Delete superfluous "close(s);return" just before "close(s);<function
exit>".
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.76 2015/12/18 22:17:46 krw Exp $	*/
d189 2
d200 5
d221 1
d235 2
d250 1
d264 1
d289 3
a291 2
		if (errno != EEXIST && errno != ENETUNREACH)
			error("failed to add default route: %s",
d293 2
a294 1
		sleep(1);
@


1.76
log
@Check ioctl() result with == -1, not < 0. Break long line.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.75 2015/02/10 04:20:26 krw Exp $	*/
a365 2
		close(s);
		return;
@


1.75
log
@Groundwork for better route support over multiple interfaces by
using RTM_IFA to bind routes to an interface. Keep the subnet route
conflict avoidance code for the time being.

diff from claudio@@ as part of larger routing magic diff.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.74 2015/02/08 01:20:40 krw Exp $	*/
d407 3
a409 2
	if (ioctl(s, SIOCSIFMTU, &ifr) < 0)
		warning("SIOCSIFMTU failed (%d): %s", imsg->mtu, strerror(errno));
@


1.74
log
@Get rid of a bunch of memset()'s where struct variables and arrays
are clearly properly initialized in the same area. Prompted by the
recent shrinkage of most imsg structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.73 2015/02/07 10:08:06 krw Exp $	*/
d165 2
a166 2
add_route(struct in_addr dest, struct in_addr netmask, struct in_addr gateway,
    int addrs, int flags)
d174 1
d190 1
a190 1
	struct sockaddr_in dest, gateway, mask;
d192 1
a192 1
	struct iovec iov[5];
d250 13
@


1.73
log
@Add support for interface-mtu (option 26).

Original request+diff from matthew@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.72 2015/02/07 02:07:32 krw Exp $	*/
a56 2
	memset(&imsg, 0, sizeof(imsg));

a147 1
			memset(ifname, 0, sizeof(ifname));
a170 2
	memset(&imsg, 0, sizeof(imsg));

a311 2
	memset(&imsg, 0, sizeof(imsg));

a369 2
	memset(&imsg, 0, sizeof(imsg));

a408 2
	memset(&imsg, 0, sizeof(imsg));

a478 2
	memset(&imsg, 0, sizeof(imsg));

d481 2
a500 1
	memset(&fimsg, 0, sizeof(fimsg));
a506 1
	memset(&dimsg, 0, sizeof(dimsg));
@


1.72
log
@GC unused parameters now that ifname and rdomain are not used in
constructing imsgs.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.71 2015/02/06 06:47:29 krw Exp $	*/
d363 41
@


1.71
log
@matthew@@ points out that it's a bad idea to rely on the non-privileged,
network-facing process to properly fill out the interface name and
rdomain on which operations are to be performed.

Instead, always use the interface name and rdomain discovered before
forking and dropping privs. Lets all the imsg structs to drop a
couple of members.

ok matthew@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.70 2015/01/31 03:13:04 krw Exp $	*/
d52 1
a52 1
flush_routes(char *ifname, int rdomain)
d168 2
a169 2
add_route(int rdomain, struct in_addr dest, struct in_addr netmask,
    struct in_addr gateway, int addrs, int flags)
d281 1
a281 1
delete_addresses(char *ifname, int rdomain)
d300 1
a300 1
		delete_address(ifi->name, ifi->rdomain, addr);
d312 1
a312 1
delete_address(char *ifname, int rdomain, struct in_addr addr)
d372 1
a372 2
add_address(char *ifname, int rdomain, struct in_addr addr,
    struct in_addr mask)
d484 1
a484 1
resolv_conf_priority(int domain)
d516 1
a516 1
	m_rtmsg.m_rtm.rtm_tableid = domain;
@


1.70
log
@Always free(buf) if errmsg is set while trying to flush routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.69 2015/01/30 14:14:53 krw Exp $	*/
d36 1
a36 1
void	delete_route(int, int, struct rt_msghdr *);
a58 2
	strlcpy(imsg.ifname, ifname, sizeof(imsg.ifname));
	imsg.rdomain = rdomain;
d88 1
a88 1
	mib[6] = imsg->rdomain;
d137 1
a137 1
			delete_route(s, imsg->rdomain, rtm);
d141 1
a141 1
				delete_route(s, imsg->rdomain, rtm);
d154 3
a156 3
			    rtm->rtm_tableid == imsg->rdomain &&
			    strcmp(imsg->ifname, ifname) == 0)
				delete_route(s, imsg->rdomain, rtm);
a175 1
	imsg.rdomain = rdomain;
d208 1
a208 1
	rtm.rtm_tableid = imsg->rdomain;
a321 2
	strlcpy(imsg.ifname, ifname, sizeof(imsg.ifname));
	imsg.rdomain = rdomain;
d347 1
a347 2
	strncpy(ifaliasreq.ifra_name, imsg->ifname,
	    sizeof(ifaliasreq.ifra_name));
a382 2
	strlcpy(imsg.ifname, ifname, sizeof(imsg.ifname));
	imsg.rdomain = rdomain;
d416 1
a416 2
	strncpy(ifaliasreq.ifra_name, imsg->ifname,
	    sizeof(ifaliasreq.ifra_name));
a451 2
	strlcpy(imsg.ifname, ifi->name, sizeof(imsg.ifname));
	imsg.rdomain = ifi->rdomain;
a472 1
	fimsg.rdomain = imsg->rdomain;
a479 2
	strlcpy(dimsg.ifname, imsg->ifname, sizeof(imsg->ifname));
	dimsg.rdomain = imsg->rdomain;
d657 1
a657 1
delete_route(int s, int rdomain, struct rt_msghdr *rtm)
d663 1
a663 1
	rtm->rtm_tableid = rdomain;
@


1.69
log
@Tweak error message to say 'realloc' since that's what's failing,
not 'malloc'.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.68 2014/10/27 13:36:21 krw Exp $	*/
a101 1
			free(buf);
a108 1
			free(buf);
d118 1
@


1.68
log
@Zap extraneous whitespace and a stuttered extra 'break;'.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.67 2014/07/14 18:16:27 miod Exp $	*/
d103 1
a103 1
			errmsg = "routes buf malloc:";
@


1.67
log
@Make sure to correctly exit the loop in priv_flush_routes() in case of
allocation failure; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.66 2014/07/09 15:16:38 krw Exp $	*/
d191 1
a191 1
 	flush_unpriv_ibuf("add_route");
d305 1
a305 1
 	}
@


1.66
log
@Print sizeof() value and size_t variable with %zu rather than %zd.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.65 2014/05/05 18:02:49 krw Exp $	*/
d104 1
a104 1
			continue;
d141 1
a141 1
			break;;
@


1.65
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.64 2014/02/13 00:24:13 krw Exp $	*/
d614 1
a614 1
		warning("creating route label: label too long (%d vs %zd)", len,
@


1.64
log
@Hard looping on EAGAIN is bad. Just fall out to outer event loop
when EAGAIN is encountered while trying to flush messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.63 2014/02/09 20:45:56 krw Exp $	*/
d220 1
a220 1
	
d233 1
a233 1
	
d536 1
a536 1
	
@


1.63
log
@Don't use imsg_flush(), roll a local flush_unpriv_ibuf() that loops
on EAGAIN, sets quit to INTERNALSIG on errors (unless quit is already
set to something else), and prints a consistant error message when
errors other than EPIPE and end of file are encountered.

Fixes failure to write resolv.conf when -L is used, and makes
add_address() and add_route() also wait until imsg is in pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.62 2014/02/09 20:23:22 krw Exp $	*/
d695 1
a695 1
				continue;
@


1.62
log
@Nuke a couple of extraneous blank lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.61 2014/02/09 20:08:25 krw Exp $	*/
d68 1
a68 4
	/* Do flush to maximize chances of cleaning up routes on exit. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1)
		warning("flush_routes: imsg_flush: %s", strerror(errno));
d190 2
d335 1
a335 4
	/* Do flush to quickly kill previous dhclient, if any. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1 && errno != EPIPE)
		warning("delete_address: imsg_flush: %s", strerror(errno));
d399 2
d472 1
a472 4
	/* Do flush so cleanup message gets through immediately. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1 && errno != EPIPE)
		warning("sendhup: imsg_flush: %s", strerror(errno));
d687 17
@


1.61
log
@Use correct function name in error message. 'cleanup' was renamed
'sendhup' a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.60 2014/01/20 02:54:07 deraadt Exp $	*/
a190 1

a400 1

@


1.60
log
@%d cleanups, to other formats; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.59 2013/12/08 22:49:02 krw Exp $	*/
d474 1
a474 1
		warning("cleanup: imsg_compose: %s", strerror(errno));
d479 1
a479 1
		warning("cleanup: imsg_flush: %s", strerror(errno));
@


1.59
log
@Reduce in_addr memcpy() dances by simply using assignments where the source
variable has been copied to [cm]alloc'ed memory and thus properly aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.58 2013/12/05 21:32:59 krw Exp $	*/
d682 1
a682 1
	int rlen;
d693 1
a693 1
		error("short RTM_DELETE write (%d)\n", rlen);
@


1.58
log
@Use destination size as size of memcpy(). Use <in_addr> rather than
<in_addr>.s_addr to shorten code.

ok deraadt@@ matthew@@ as part of larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.57 2013/12/04 19:39:50 krw Exp $	*/
a302 1
		memset(&addr, 0, sizeof(addr));
@


1.57
log
@More memcpy() stylistic repairs and size checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.56 2013/08/17 14:50:05 krw Exp $	*/
d304 2
a305 3
		memcpy(&addr,
		    &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr,
		    sizeof(in_addr_t));
d443 1
a443 1
	memcpy(&in->sin_addr.s_addr, &imsg->mask, sizeof(in->sin_addr.s_addr));
@


1.56
log
@Do not create a route to the bound address via 127.0.0.1. Our stack
should be able to correctly short-circuit packet routing to local
addresses without this. Requested by many over the years, most
recently chrisz@@.

Get it in early to see if anything does break.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.55 2013/07/05 22:13:10 krw Exp $	*/
d444 1
a444 1
	memcpy(&in->sin_addr.s_addr, &imsg->mask, sizeof(imsg->mask));
@


1.55
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.54 2013/06/09 22:39:51 krw Exp $	*/
a383 1
 *	route -q <rdomain> add <addr> 127.0.0.1
a411 1
	struct imsg_add_route rimsg;
a452 11

	/*
	 * Add the 127.0.0.1 route for the specified address.
	 */
	memset(&rimsg, 0, sizeof(rimsg));
	rimsg.dest.s_addr = imsg->addr.s_addr;
	rimsg.gateway.s_addr = inet_addr("127.0.0.1");
	rimsg.addrs = RTA_DST | RTA_GATEWAY;
	rimsg.flags = RTF_GATEWAY | RTF_STATIC;

	priv_add_route(&rimsg);
@


1.54
log
@Make route adding interface more flexible by passing flags to be
used rather than deducing them. Use priv_add_route() to add
the 127.0.0.1 address when adding an address.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.53 2013/06/09 17:31:54 krw Exp $	*/
d46 1
a46 1
 * Do equivalent of 
d158 1
a158 1
			    sa_in && 
d392 1
a392 1
 
d402 1
a402 1
 
@


1.53
log
@Fix/clarify some comments. do memset()'s only when variable is going
to be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.52 2013/06/09 16:21:50 krw Exp $	*/
d175 1
a175 1
    struct in_addr gateway, int addrs)
d187 1
d217 2
a229 1
		rtm.rtm_addrs |= RTA_DST;
a242 2
		rtm.rtm_flags |= RTF_GATEWAY | RTF_STATIC;
		rtm.rtm_addrs |= RTA_GATEWAY;
a255 1
		rtm.rtm_addrs |= RTA_NETMASK;
d413 1
a414 4
	struct rt_msghdr rtm;
	struct sockaddr_in dest, gateway;
	struct sockaddr_rtlabel label;
	struct iovec iov[4];
d416 1
a416 1
	int s, i, iovcnt = 0;
d459 5
d465 1
a465 67
	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		error("Routing Socket open failed: %s", strerror(errno));

	/* Build RTM header */

	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_ADD;
	rtm.rtm_tableid = imsg->rdomain;
	rtm.rtm_priority = RTP_NONE;
	rtm.rtm_msglen = sizeof(rtm);

	iov[iovcnt].iov_base = &rtm;
	iov[iovcnt++].iov_len = sizeof(rtm);
	
	/* Set destination address */

	memset(&dest, 0, sizeof(dest));

	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = imsg->addr.s_addr;

	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);

	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
	
	/* Set gateway address */

	memset(&gateway, 0, sizeof(gateway));

	gateway.sin_len = sizeof(gateway);
	gateway.sin_family = AF_INET;
	gateway.sin_addr.s_addr = inet_addr("127.0.0.1");

	rtm.rtm_flags |= RTF_GATEWAY;
	rtm.rtm_addrs |= RTA_GATEWAY;
	rtm.rtm_msglen += sizeof(gateway);

	iov[iovcnt].iov_base = &gateway;
	iov[iovcnt++].iov_len = sizeof(gateway);

	/* Add our label so we can identify the route as our creation. */
	if (create_route_label(&label) == 0) {
		rtm.rtm_addrs |= RTA_LABEL;
		rtm.rtm_msglen += sizeof(label);
		iov[iovcnt].iov_base = &label;
		iov[iovcnt++].iov_len = sizeof(label);
	}

	/* Check for EEXIST since other dhclient may not be done. */
	for (i = 0; i < 5; i++) {
		if (writev(s, iov, iovcnt) != -1)
			break;
		if (errno == ENETUNREACH) {
			/* Not our responsibility to ensure 127/8 exists. */
			break;
		} else if (errno != EEXIST)
			error("failed to add 127.0.0.1 route: %s",
			    strerror(errno));
		sleep(1);
	}

	close(s);
@


1.52
log
@Re-apply static route and classless static route support -- this time
passing the correct destination for the default route, '0.0.0.0', rather
than the new lease address.

Populating egress group works this time.

Problem found the hard way by Chris Smith.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.51 2013/06/09 15:06:34 krw Exp $	*/
a172 12
/*
 * [priv_]add_default_route is the equivalent of
 *
 *	route -q $rdomain -n flush -inet -iface $interface
 *
 * and one of
 *
 *	route -q $rdomain add default -iface $router
 * 	route -q $rdomain add default $router
 *
 * depending on the contents of the gateway parameter.
 */
d220 2
a221 3
	/* Set destination address. */

	memset(&dest, 0, sizeof(dest));
a222 1
	if (imsg->addrs & RTA_DST) {
d234 2
a235 4
	/*
	 * Set gateway address if and only if non-zero addr supplied. A
	 * gateway address of 0 implies '-iface'.
	 */
a236 2
	memset(&gateway, 0, sizeof(gateway));
	if (imsg->addrs & RTA_GATEWAY) {
d249 2
a250 2
	/* Add netmask. */
	memset(&mask, 0, sizeof(mask));
a251 1
	if (imsg->addrs & RTA_NETMASK) {
@


1.51
log
@Re-apply route adding code refactoring -- it wasn't the problem that
broke populating the egress group.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.50 2013/06/09 00:30:06 krw Exp $	*/
d232 1
a232 1
	/* Set destination address of all zeros. */
d236 4
a239 2
	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
d241 2
a242 2
	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);
d244 3
a246 2
	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
d254 1
a254 1
	if ((imsg->addrs & RTA_GATEWAY) != 0) {
d267 1
a267 1
	/* Add netmask of 0. */
d270 4
a273 3
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = imsg->netmask.s_addr;
d275 2
a276 2
	rtm.rtm_addrs |= RTA_NETMASK;
	rtm.rtm_msglen += sizeof(mask);
d278 3
a280 2
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);
@


1.50
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.49 2013/06/04 21:04:53 krw Exp $	*/
d186 2
a187 1
add_default_route(int rdomain, struct in_addr addr, struct in_addr gateway)
d189 2
a190 2
	struct imsg_add_default_route	 imsg;
	int				 rslt;
d195 1
a195 1
	imsg.addr = addr;
d197 2
d200 1
a200 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_DEFAULT_ROUTE, 0, 0, -1,
d204 1
a204 1
		warning("add_default_route: imsg_compose: %s", strerror(errno));
d208 1
a208 1
priv_add_default_route(struct imsg_add_default_route *imsg)
a215 4
	/*
	 * Add a default route via the specified address.
	 */

d251 1
a251 1
	if (bcmp(&imsg->gateway, &imsg->addr, sizeof(imsg->addr)) != 0) {
d269 1
@


1.49
log
@Add support for static routes option (33) and classless static
routes option (121).

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.48 2013/06/01 16:26:07 krw Exp $	*/
d186 1
a186 2
add_route(int rdomain, struct in_addr dest, struct in_addr netmask,
    struct in_addr gateway, int addrs)
d188 2
a189 2
	struct imsg_add_route	 imsg;
	int			 rslt;
d194 1
a194 1
	imsg.dest = dest;
a195 2
	imsg.netmask = netmask;
	imsg.addrs = addrs;
d197 1
a197 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ROUTE, 0, 0, -1,
d201 1
a201 1
		warning("add_route: imsg_compose: %s", strerror(errno));
d205 1
a205 1
priv_add_route(struct imsg_add_route *imsg)
d213 4
d233 1
a233 1
	/* Set destination address. */
d237 2
a238 4
	if (imsg->addrs & RTA_DST) {
		dest.sin_len = sizeof(dest);
		dest.sin_family = AF_INET;
		dest.sin_addr.s_addr = imsg->dest.s_addr;
d240 2
a241 2
		rtm.rtm_addrs |= RTA_DST;
		rtm.rtm_msglen += sizeof(dest);
d243 2
a244 3
		iov[iovcnt].iov_base = &dest;
		iov[iovcnt++].iov_len = sizeof(dest);
	}
d252 1
a252 1
	if (imsg->addrs & RTA_GATEWAY) {
d265 1
a265 1
	/* Add netmask. */
d268 2
a269 4
	if (imsg->addrs & RTA_NETMASK) {
		mask.sin_len = sizeof(mask);
		mask.sin_family = AF_INET;
		mask.sin_addr.s_addr = imsg->netmask.s_addr;
d271 2
a272 2
		rtm.rtm_addrs |= RTA_NETMASK;
		rtm.rtm_msglen += sizeof(mask);
d274 2
a275 3
		iov[iovcnt].iov_base = &mask;
		iov[iovcnt++].iov_len = sizeof(mask);
	}
@


1.48
log
@Refactor the default route adding code to use a general route adding
function that will be reused for future work.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.47 2013/03/30 16:10:01 krw Exp $	*/
d232 1
a232 1
	/* Set destination address of all zeros. */
d236 4
a239 2
	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
d241 2
a242 2
	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);
d244 3
a246 2
	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
d254 1
a254 1
	if ((imsg->addrs & RTA_GATEWAY) != 0) {
d267 1
a267 1
	/* Add netmask of 0. */
d270 4
a273 3
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = imsg->netmask.s_addr;
d275 2
a276 2
	rtm.rtm_addrs |= RTA_NETMASK;
	rtm.rtm_msglen += sizeof(mask);
d278 3
a280 2
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);
@


1.47
log
@Since deleting all the addresses on an interface removes all the
relevant entries from the arp cache, don't bother asking for/processing
arp entries in the route dumps. Thus allowing use of NET_RT_FLAGS
with RTF_GATEWAY and AF_INET, to ask for only the routes dhclient
wants to expunge rather than all routes in existance.

Greatly shrinks and simplifies the code. No intentional functional
change. Tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.46 2013/03/24 12:53:20 krw Exp $	*/
d186 2
a187 1
add_default_route(int rdomain, struct in_addr addr, struct in_addr gateway)
d189 2
a190 2
	struct imsg_add_default_route	 imsg;
	int				 rslt;
d195 1
a195 1
	imsg.addr = addr;
d197 2
d200 1
a200 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_DEFAULT_ROUTE, 0, 0, -1,
d204 1
a204 1
		warning("add_default_route: imsg_compose: %s", strerror(errno));
d208 1
a208 1
priv_add_default_route(struct imsg_add_default_route *imsg)
a215 4
	/*
	 * Add a default route via the specified address.
	 */

d251 1
a251 1
	if (bcmp(&imsg->gateway, &imsg->addr, sizeof(imsg->addr)) != 0) {
d269 1
@


1.46
log
@Simplify logic when processing route dump by using a helper function
delete_route(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2013/03/21 04:43:17 deraadt Exp $	*/
d52 1
a52 1
flush_routes_and_arp_cache(char *ifname, int rdomain)
d66 1
a66 2
		warning("flush_routes_and_arp_cache: imsg_compose: %s",
		    strerror(errno));
d71 1
a71 2
		warning("flush_routes_and_arp_cache: imsg_flush: %s",
		    strerror(errno));
d75 1
a75 1
priv_flush_routes_and_arp_cache(struct imsg_flush_routes *imsg)
a82 2
	struct sockaddr *sa;
	struct sockaddr_dl *sdl;
d90 3
a92 3
	mib[3] = 0;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
a134 4
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		if (sa->sa_family == AF_KEY || sa->sa_family == AF_INET6)
			continue;  /* Don't flush SPD or INET6 routes */

d138 2
d144 1
a144 1
			continue;
d148 1
a148 1
			continue;
d151 1
a151 3
			/* Never delete routes labelled by another dhclient. */
			continue;
		default:
d153 3
a155 32
		}

		if (rtm->rtm_flags & RTF_LLINFO) {
			if (rtm->rtm_flags & RTF_GATEWAY)
				continue;
			if (rtm->rtm_flags & RTF_PERMANENT_ARP)
				continue;
			sdl = (struct sockaddr_dl *)rti_info[RTAX_GATEWAY];
			if (sdl == NULL)
				continue;

			/* XXXX Check for AF_INET too? (arp ask for them) */
			/* XXXX Need 'retry' for proxy entries? (arp does) */

			if (sdl->sdl_family == AF_LINK) {
				switch (sdl->sdl_type) {
				case IFT_ETHER:
				case IFT_FDDI:
				case IFT_ISO88023:
				case IFT_ISO88024:
				case IFT_ISO88025:
				case IFT_CARP:
					delete_route(s, imsg->rdomain, rtm);
					break;
				default:
					break;
				}
			}
			continue;
		}

		if (rtm->rtm_flags & RTF_GATEWAY) {
d157 2
a158 4
			if (if_indextoname(rtm->rtm_index, ifname) == NULL)
				continue;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (sa_in && 
d161 1
a161 1
			    strcmp(imsg->ifname, ifname) == 0) {
d163 3
a165 2
				continue;
			}
d588 1
a588 1
	priv_flush_routes_and_arp_cache(&fimsg);
@


1.45
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.44 2013/03/13 16:28:05 weerd Exp $	*/
d36 1
d89 1
a89 1
	int s, seqno = 0, rlen;
d149 2
a150 1
			goto delete;
d153 1
a153 1
				goto delete;
d183 2
a184 2
					/* Delete it. */
					goto delete;
d200 4
a203 2
			    strcmp(imsg->ifname, ifname) == 0)
				goto delete;
a204 16

		continue;

delete:
		rtm->rtm_type = RTM_DELETE;
		rtm->rtm_seq = seqno;
		rtm->rtm_tableid = imsg->rdomain;

		rlen = write(s, next, rtm->rtm_msglen);
		if (rlen == -1) {
			if (errno != ESRCH)
				error("RTM_DELETE write: %s", strerror(errno));
		} else if (rlen < (int)rtm->rtm_msglen)
			error("short RTM_DELETE write (%d)\n", rlen);

		seqno++;
d808 18
@


1.44
log
@Make sure dhclient doesn't delete IPv6 routes.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.43 2013/03/11 16:01:02 krw Exp $	*/
d82 1
a82 1
	char *lim, *buf, *next, *errmsg;
d88 1
a88 1
	int s, seqno = 0, rlen, retry;
d98 1
a98 7
	buf = NULL;
	retry = 0;
	do {
		retry++;
		errmsg = NULL;
		if (buf)
			free(buf);
d101 1
a101 1
			continue;
d103 2
a104 1
		if (needed == 0)
d106 3
a108 1
		if ((buf = malloc(needed)) == NULL) {
d112 1
d114 3
d118 1
d120 2
a121 1
	} while (retry < 10 && errmsg != NULL);
d124 2
a125 2
		warning("route cleanup failed - %s %s (%d retries, msize=%zu)",
		    errmsg, strerror(errno), retry, needed);
@


1.43
log
@When binding a lease, check for and clear out any 'zombie' routes
left behind by dead dhclients. i.e. dhclients that no longer respond
to 'kill(pid, 0)'.

As a result, no need to handle the 127.0.0.1 route separately when
deleting an interface.

Appears to fix in passing a problem with routes vs link addresses
that sthen@@ was seeing.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2013/03/08 12:25:15 krw Exp $	*/
d136 2
a137 2
		if (sa->sa_family == AF_KEY)
			continue;  /* Don't flush SPD */
@


1.42
log
@Consolidate parsing of rtm address lists. Use RTAX_GATEWAY entry
to get ARP sockaddr_dl info, rather than re-parsing manually.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.41 2013/03/07 13:23:27 krw Exp $	*/
d60 1
d146 4
a150 1
		case ROUTE_LABEL_DHCLIENT_DEAD:
a379 1
 *	route -q <rdomain> delete <addr> 127.0.0.1
a410 3
	struct rt_msghdr rtm;
	struct sockaddr_in dest, gateway;
	struct iovec iov[3];
d412 1
a412 1
	int s, iovcnt = 0;
a439 55

	/*
	 * Delete the 127.0.0.1 route for the specified address.
	 */

	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		error("Routing Socket open failed: %s", strerror(errno));

	/* Build RTM header */

	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_DELETE;
	rtm.rtm_tableid = imsg->rdomain;
	rtm.rtm_priority = RTP_NONE;
	rtm.rtm_msglen = sizeof(rtm);

	iov[iovcnt].iov_base = &rtm;
	iov[iovcnt++].iov_len = sizeof(rtm);
	
	/* Set destination address */

	memset(&dest, 0, sizeof(dest));

	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = imsg->addr.s_addr;

	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);

	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
	
	/* Set gateway address */

	memset(&gateway, 0, sizeof(gateway));

	gateway.sin_len = sizeof(gateway);
	gateway.sin_family = AF_INET;
	gateway.sin_addr.s_addr = inet_addr("127.0.0.1");

	rtm.rtm_flags |= RTF_GATEWAY;
	rtm.rtm_addrs |= RTA_GATEWAY;
	rtm.rtm_msglen += sizeof(gateway);

	iov[iovcnt].iov_base = &gateway;
	iov[iovcnt++].iov_len = sizeof(gateway);

	/* ESRCH means the route does not exist to delete. */
	if ((writev(s, iov, iovcnt) == -1) && (errno != ESRCH))
		error("failed to delete 127.0.0.1: %s", strerror(errno));

	close(s);
d634 1
@


1.41
log
@Refactor code around route label creation and checking to make it easier
to read. No functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.40 2013/02/28 21:00:53 krw Exp $	*/
d35 1
a85 1
	struct sockaddr_inarp *sin;
d87 1
a87 1
	int s, seqno = 0, rlen, retry, i;
a127 3
#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

d138 1
a138 10
		memset(rti_info, 0, sizeof(rti_info));
		for (i = 0; i < RTAX_MAX; i++) {
			if (rtm->rtm_addrs & (1 << i)) {
				rti_info[i] = sa;
				sa = (struct sockaddr *)((char *)(sa) +
				    ROUNDUP(sa->sa_len));
			}
		}

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
d159 3
a165 4
			sin = (struct sockaddr_inarp *)(sa);
			sdl = (struct sockaddr_dl *)(ROUNDUP(sin->sin_len) +
			   (char *)sin);

a709 1
	struct sockaddr *sa;
d715 1
a715 1
	int i, s, rslt, iovcnt = 0;
d786 1
a786 9
	sa = (struct sockaddr *)((char *)&m_rtmsg + m_rtmsg.m_rtm.rtm_hdrlen);
	memset(rti_info, 0, sizeof(rti_info));
	for (i = 0; i < RTAX_MAX; i++) {
		if (m_rtmsg.m_rtm.rtm_addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		}
	}
d850 21
@


1.40
log
@Try 10 times to obtain the routing table via sysctl(), and if it
can't be done just abandon attempt to clean up the routing and arp
tables and carry on. Code adapted from itojun's route6d.c.

May address problem reported on misc@@ by Marc Peters.

Best we can do for now.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.39 2013/02/24 01:23:19 krw Exp $	*/
d29 1
d33 10
d80 1
a80 1
	char *lim, *buf, *next, *routelabel, *errmsg;
a127 3
	if (asprintf(&routelabel, "DHCLIENT %d", (int)getpid()) == -1)
		error("recreating route label: %s", strerror(errno));

d153 2
a154 1
		if (sa_rl) {
d156 4
a159 3
			if (strcmp(routelabel, sa_rl->sr_label) == 0)
				goto delete;

d161 3
a163 3
			if (strlen(sa_rl->sr_label) > 8 &&
			    strncmp("DHCLIENT ", sa_rl->sr_label, 9) == 0)
				continue;
a226 1
	free(routelabel);
d267 1
a267 1
	int s, len, i, iovcnt = 0;
d334 6
a339 16
	memset(&label, 0, sizeof(label));
	label.sr_len = sizeof(label);
	label.sr_family = AF_UNSPEC;
	len = snprintf(label.sr_label, sizeof(label.sr_label), "DHCLIENT %d",
	    getpid());
	if (len == -1)
		error("writing label for default route: %s", strerror(errno));
	if (len >= sizeof(label.sr_label))
		error("label for default route too long (%zd)",
		    sizeof(label.sr_label));

	rtm.rtm_addrs |= RTA_LABEL;
	rtm.rtm_msglen += sizeof(label);

	iov[iovcnt].iov_base = &label;
	iov[iovcnt++].iov_len = sizeof(label);
d549 1
a549 1
	int s, len, i, iovcnt = 0;
d639 6
a644 17
	memset(&label, 0, sizeof(label));

	label.sr_len = sizeof(label);
	label.sr_family = AF_UNSPEC;
	len = snprintf(label.sr_label, sizeof(label.sr_label), "DHCLIENT %d",
	    getpid());
	if (len == -1)
		error("writing label for host route: %s", strerror(errno));
	if (len >= sizeof(label.sr_label))
		error("label for host route too long (%zd)",
		    sizeof(label.sr_label));

	rtm.rtm_addrs |= RTA_LABEL;
	rtm.rtm_msglen += sizeof(label);

	iov[iovcnt].iov_base = &label;
	iov[iovcnt++].iov_len = sizeof(label);
a722 1
	char *routelabel;
d811 2
a812 7
	if (sa_rl) {
		if (asprintf(&routelabel, "DHCLIENT %d", (int)getpid()) == -1)
			error("recreating route label: %s", strerror(errno));
		if (strcmp(routelabel, sa_rl->sr_label) == 0)
			rslt = 1;
		free(routelabel);
	}
d817 55
@


1.39
log
@Don't log a complaint that a non-existant default route could not be
deleted. Be happy that the goal of no default route has been achieved.

Part of the cleaning up the logs prodding by deraadt@@.

ok guenther@@. error in first version pointed out by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.38 2013/02/21 14:10:22 krw Exp $	*/
d69 1
a69 1
	char *lim, *buf, *next, *routelabel;
d76 1
a76 1
	int s, seqno = 0, rlen, i;
d86 12
a97 2
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
		if (imsg->rdomain != 0 && errno == EINVAL)
d99 13
a111 1
		error("sysctl size of routes: %s", strerror(errno));
a112 9

	if (needed == 0)
		return;

	if ((buf = malloc(needed)) == NULL)
		error("no memory for sysctl routes");

	if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1)
		error("sysctl retrieval of routes: %s", strerror(errno));
@


1.38
log
@Use imsg_flush() to force delivery of IMSG_DELETE_ADDRESS to
privileged process. This ensures a quicker exit of any previous
copy of dhclient.

Prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.37 2013/02/18 22:10:04 krw Exp $	*/
d769 3
a771 1
		warning("RTM_GET of default route: %s", strerror(errno));
@


1.37
log
@Don't delete permanent arp cache entries when clearing the arp
cache. Issue pointed out by Don Nasco.

Deemed the correct thing to do by sthne@@, phessler@@ and chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.36 2013/02/18 15:57:08 krw Exp $	*/
a395 1

d398 5
@


1.36
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.35 2013/02/17 17:36:31 krw Exp $	*/
d145 2
@


1.35
log
@Using the value SIGQUIT to cause the dispatch loops to exit produced
universal revulsion and no little confusion.  #define our own value,
currently INT_MAX, which should not overlap any likely signal value.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.34 2013/02/17 17:04:41 krw Exp $	*/
d658 1
a658 1
 * [priv_]cleanup removes dhclient installed routes and address.
d661 1
a661 1
cleanup(struct client_lease *active)
d663 1
a663 1
	struct imsg_cleanup imsg;
d673 1
a673 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_CLEANUP, 0, 0, -1,
d684 3
d688 1
a688 1
priv_cleanup(struct imsg_cleanup *imsg)
@


1.34
log
@Suppress some pointless debugging message:

1) If the pipe to the priv process is closed while waiting for
something to happen in the non-priv dispatch() loop, assume the
priv process issued an error message and exit without additional
verbiage.

2) Ditto if the pipe to the priv process is closed when the flush
of IMSG_CLEANUP is attempted.

3) No need to report when SIOCDIFADDR fails because the address is
already gone.

Start to ensure the priv process always issues a useful message
before exiting by noting when it restarts due to the LLADDR having
changed.

Prodded by deraadt@@ to clean this up.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.33 2013/02/17 15:48:03 krw Exp $	*/
d536 1
a536 1
		quit = INT_MAX;
@


1.33
log
@Kill a magic number. 0 -> RTP_NONE for priority in constructing routing
messages. Prodded by otto@@. RTP_NONE's home pointed out by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2013/02/17 15:08:13 krw Exp $	*/
d427 3
a429 2
		warning("SIOCDIFADDR failed (%s): %s", inet_ntoa(imsg->addr),
		    strerror(errno));
d680 1
a680 1
	if (rslt == -1)
@


1.32
log
@dhclient-script did 'route -q $rdomain add $new_ip_address 127.0.0.1'.
i.e.  did not complain (-q) if 127/8 was unreachabel from $rdomain.
So don't pollute the log with new warnings about being unable to
create the route. Just complain if a truly unexpected error occurs.

Noted by Andreas Bartelt.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2013/02/15 01:20:39 krw Exp $	*/
d259 1
a259 1
	rtm.rtm_priority = 0;
d449 1
a449 1
	rtm.rtm_priority = 0;
d584 1
a584 1
	rtm.rtm_priority = 0;
@


1.31
log
@Don't leak routing socket fd if getting the default route fails.
e.g. with ESRCH.

Ask for default route in correct routing domain.

While here, tweak variable names to be consistant with other
functions using a routing socket.

Likely the cause of the periodic failures reported by Andreas Bartelt
via bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2013/02/03 15:10:36 krw Exp $	*/
a641 1
		/* XXX Why do some systems get ENETUNREACH? */
d643 1
a643 2
			note("failed to add 127.0.0.1 route: %s",
			    strerror(errno));
@


1.30
log
@Use RTM_GET rather than the sysctl/scan all routes dance to obtain
the current default route. Much less work for the routing system.

Suggested by claudio@@. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2013/02/01 01:33:44 krw Exp $	*/
d721 1
a721 1
	int i, fd, rslt, iovcnt = 0;
d725 2
a726 2
	fd = socket(PF_ROUTE, SOCK_RAW, AF_INET);
	if (fd == -1) {
d740 1
d760 3
a762 3
	if (writev(fd, iov, iovcnt) == -1) {
		warning("default route write: %s", strerror(errno));
		return (0);
d768 1
a768 1
		len = read(fd, &m_rtmsg, sizeof(m_rtmsg));
d810 1
a810 1
	close(fd);
@


1.29
log
@Write out resolv.conf only if the default route is under the control
of the process binding the lease. Re-check the default route whenever
a routing message arrives that might mean the default route has
changed, and write out resolv.conf if appropriate.

Reduces the chances that the name servers in resolv.conf are
unreachable.

Problem most eloquently explained, and solution suggested by beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2013/01/22 06:02:52 krw Exp $	*/
d708 5
d714 1
a714 4
	int mib[7];
	size_t needed;
	char *lim, *buf, *next, *routelabel;
	struct rt_msghdr *rtm;
d716 1
a716 1
	struct sockaddr_in *sa_in;
d718 12
a729 1
	int i, priority, mypriority;
d731 14
a744 7
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_GATEWAY;
	mib[6] = domain;
d746 1
a746 5
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
		if (domain != 0 && errno == EINVAL)
			return (1);
		error("sysctl size of routes: %s", strerror(errno));
	}
d748 3
a750 2
	if (needed == 0)
		return (1);
d752 4
a755 2
	if ((buf = malloc(needed)) == NULL)
		error("no memory for sysctl routes");
d757 1
a757 2
	if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1)
		error("sysctl retrieval of routes: %s", strerror(errno));
d759 4
a762 2
	if (asprintf(&routelabel, "DHCLIENT %d", (int)getpid()) == -1)
		error("recreating route label: %s", strerror(errno));
d764 1
a764 2
#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
d766 10
a775 7
	priority = mypriority = INT_MAX;
	lim = buf + needed;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		if ((rtm->rtm_flags & RTF_UP) == 0)
d777 7
a783 10
		if (rtm->rtm_flags & RTF_REJECT)
			continue;

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		memset(rti_info, 0, sizeof(rti_info));
		for (i = 0; i < RTAX_MAX; i++) {
			if (rtm->rtm_addrs & (1 << i)) {
				rti_info[i] = sa;
				sa = (struct sockaddr *)((char *)(sa) +
				    ROUNDUP(sa->sa_len));
d785 1
d787 1
d789 9
a797 6
		sa_in = (struct sockaddr_in *)rti_info[RTAX_DST];
		if (sa_in == NULL || sa_in->sin_addr.s_addr != INADDR_ANY)
			continue;
		sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
		if (sa_in == NULL || sa_in->sin_addr.s_addr != INADDR_ANY)
			continue;
d799 7
a805 6
		sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
		if (sa_rl && strcmp(routelabel, sa_rl->sr_label) == 0) {
			if (rtm->rtm_priority < mypriority)
				mypriority = rtm->rtm_priority;
		} else if (rtm->rtm_priority < priority)
			priority = rtm->rtm_priority;
d808 3
a810 4
	free(buf);
	free(routelabel);

	return (mypriority < priority);
@


1.28
log
@Whitespace nit. Better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2013/01/17 23:41:07 krw Exp $	*/
d703 84
@


1.27
log
@Try harder to clear out default routes on the interface being
configured. Only exempt default routes labelled as being the
property of another dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2012/12/29 14:40:00 krw Exp $	*/
d89 1
a89 1
		error("could not get routes");
d96 1
a96 1
		error("malloc");
@


1.26
log
@Make HUP to either one of the processes cause a restart that will
have dhclient re-read dhclient.conf and get a new lease. Constrain
the filename passed to '-l' (alternate dhclient.lease.if location)
to be a regular file for the moment.

Original suggestion from phessler@@. Feedback from deraadt@@ and
espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2012/12/19 12:25:38 krw Exp $	*/
d39 1
a39 1
flush_routes_and_arp_cache(int rdomain)
d46 1
d65 1
d73 1
d131 9
a139 3
		if (rti_info[RTAX_LABEL]) {
			sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
			if (strcmp(routelabel, sa_rl->sr_label))
d141 3
a143 1
		} else if (rtm->rtm_flags & RTF_LLINFO) {
d163 2
a165 2
				default:
					continue;
a167 1
		} else
d169 15
d185 1
@


1.25
log
@Don't attempt to delete an address that has already been deleted
by a new dhclient (or anyone else). Instead, use add_address(...,
INADDR_ANY, ...) to tell the privileged process that its active
address is gone. Thus the cleanup process doesn't try to delete it.

Eliminates extraneous log entries complaining that the address can't
be deleted. Narrows race window where old dhclient might delete the
address the new dhclient has just added.

Make rapid-fire starting of dhclient even more reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2012/12/17 22:52:59 krw Exp $	*/
d509 1
a509 1
		quit = 1;
@


1.24
log
@Don't daemonize until the RTM_NEWADDR message is received. Shuffle
things a bit so configuring the address and default route are done
last. This makes it much more likely that all the work is done when
the 'bound to ...' message is displayed.

Amoung other things fixes a problem with the install scripts, where
the first (hostname-associated) dhclient can exit so quickly the
interface doesn't yet have an address and a second (free-floating)
dhclient is therefore often run.

Noted by rpe@@, who also tested the fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2012/12/04 19:24:03 krw Exp $	*/
d505 7
@


1.23
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2012/12/03 22:36:16 krw Exp $	*/
d305 1
a305 1
		if (errno != EEXIST)
@


1.22
log
@Backout last. It breaks existing 'ifconfig down ; dhclient' usage.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2012/12/03 22:19:47 krw Exp $	*/
d51 2
a52 1
		warning("flush_routes_and_arp_cache: imsg_compose: %m");
d57 2
a58 1
		warning("flush_routes_and_arp_cache: imsg_flush: %m");
d96 1
a96 1
		error("sysctl retrieval of routes: %m");
d99 1
a99 1
		error("opening socket to flush routes: %m");
d102 1
a102 1
		error("recreating route label: %m");
d167 1
a167 1
				error("RTM_DELETE write: %m");
d207 1
a207 1
		warning("add_default_route: imsg_compose: %m");
d224 1
a224 1
		error("Routing Socket open failed: %m");
d290 1
a290 1
		error("writing label for default route: %m");
d306 2
a307 1
			error("failed to add default route: %m");
d324 1
a324 1
		error("delete_addresses getifaddrs: %m");
d370 1
a370 1
		warning("delete_address: imsg_compose: %m");
d388 1
a388 1
		error("socket open failed: %m");
d401 2
a402 1
		warning("SIOCDIFADDR failed (%s): %m", inet_ntoa(imsg->addr));
d414 1
a414 1
		error("Routing Socket open failed: %m");
d460 1
a460 1
		error("failed to delete 127.0.0.1: %m");
d492 1
a492 1
		warning("add_address: imsg_compose: %m");
d511 1
a511 1
		error("socket open failed: %m");
d532 2
a533 1
		warning("SIOCAIFADDR failed (%s): %m", inet_ntoa(imsg->addr));
d542 1
a542 1
		error("Routing Socket open failed: %m");
d594 1
a594 1
		error("writing label for host route: %m");
d611 2
a612 1
			note("failed to add 127.0.0.1 route: %m");
d615 2
a616 1
			error("failed to add 127.0.0.1 route: %m");
d644 1
a644 1
		warning("cleanup: imsg_compose: %m");
d649 1
a649 1
		warning("cleanup: imsg_flush: %m");
@


1.21
log
@Cleanup after a 'ifconfig down', but stick around so 'ifconfig up'
will get a new lease without having to restart dhclient. Also tweak
cleanup() to cancel any existing timeout, so one doesn't fire between
'down' and 'up'.

Makes sense to chris@@ beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2012/12/02 17:03:19 krw Exp $	*/
a626 2
	cancel_timeout();

d632 1
a632 1
		delete_address(ifi->name, ifi->rdomain, active->address);
@


1.20
log
@Try harder to cleanup when exiting. In particular catch signals
SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUS2 and cleanup before exiting
when getting them. Cleanup meaning removing routes and the interface
address added.

Tweaks and feedback from phessler@@, sthen@@, otto@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2012/11/23 15:25:47 krw Exp $	*/
d627 2
d634 1
a634 1
		imsg.addr = active->address;
@


1.19
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2012/11/17 10:39:24 krw Exp $	*/
d30 2
d614 49
@


1.18
log
@'deeleting' -> 'deleting' in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2012/11/16 14:59:36 krw Exp $	*/
d39 2
a40 14
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;

	hdr.code = IMSG_FLUSH_ROUTES;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + sizeof(rdomain);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);
d42 13
a54 1
	buf_close(privfd, buf);
d58 1
a58 1
priv_flush_routes_and_arp_cache(int rdomain)
d77 1
a77 1
	mib[6] = rdomain;
d80 1
a80 1
		if (rdomain != 0 && errno == EINVAL)
d158 1
a158 1
		rtm->rtm_tableid = rdomain;
d188 1
a188 2
add_default_route(int rdomain, struct in_addr addr,
    struct in_addr gateway)
d190 8
a197 24
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;

	hdr.code = IMSG_ADD_DEFAULT_ROUTE;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + sizeof(rdomain) +
	    sizeof(len) + sizeof(addr) +
	    sizeof(len) + sizeof(gateway);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);

	len = sizeof(addr);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, len);

	len = sizeof(gateway);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &gateway, len);
d199 5
a203 1
	buf_close(privfd, buf);
d207 1
a207 2
priv_add_default_route(int rdomain, struct in_addr addr,
    struct in_addr router)
d228 1
a228 1
	rtm.rtm_tableid = rdomain;
d254 1
a254 1
	if (bcmp(&router, &addr, sizeof(addr)) != 0) {
d257 1
a257 1
		gateway.sin_addr.s_addr = router.s_addr;
d349 4
a352 3
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;
d357 3
a359 20
	hdr.code = IMSG_DELETE_ADDRESS;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + strlen(ifname) +
	    sizeof(len) + sizeof(rdomain) +
	    sizeof(len) + sizeof(addr);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);

	len = sizeof(addr);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, len);
d361 5
a365 1
	buf_close(privfd, buf);
d369 1
a369 1
priv_delete_address(char *ifname, int rdomain, struct in_addr addr)
d386 2
a387 1
	strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d392 1
a392 1
	in->sin_addr.s_addr = addr.s_addr;
d396 1
a396 1
		warning("SIOCDIFADDR failed (%s): %m", inet_ntoa(addr));
d416 1
a416 1
	rtm.rtm_tableid = rdomain;
d429 1
a429 1
	dest.sin_addr.s_addr = addr.s_addr;
d469 4
a472 3
	struct buf	*buf;
	size_t		 len;
	struct imsg_hdr	 hdr;
d474 1
d477 7
a483 25
	hdr.code = IMSG_ADD_ADDRESS;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + strlen(ifname) +
	    sizeof(len) + sizeof(rdomain) +
	    sizeof(len) + sizeof(addr) +
	    sizeof(len) + sizeof(mask);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);

	len = sizeof(addr);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, len);

	len = sizeof(mask);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &mask, len);
d485 2
a486 1
	buf_close(privfd, buf);
d490 1
a490 2
priv_add_address(char *ifname, int rdomain, struct in_addr addr,
    struct in_addr mask)
d508 2
a509 1
	strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d515 1
a515 1
	in->sin_addr.s_addr = addr.s_addr;
d521 1
a521 1
	memcpy(&in->sin_addr.s_addr, &mask, sizeof(mask));
d526 1
a526 1
		warning("SIOCAIFADDR failed (%s): %m", inet_ntoa(addr));
d543 1
a543 1
	rtm.rtm_tableid = rdomain;
d556 1
a556 1
	dest.sin_addr.s_addr = addr.s_addr;
@


1.17
log
@Add missing 'break;' so that IFT_ETHER, etc. routes are deleted as
intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2012/11/15 14:54:18 krw Exp $	*/
d367 1
a367 1
	/* Note the address we are deeleting for RTM_DELADDR filtering! */
@


1.16
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2012/11/14 15:47:41 krw Exp $	*/
d148 1
a148 1
					;
@


1.15
log
@Remove useless _new_ and _old_ from various function names to make
them shorter and eliminate implications about what the function
does. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2012/11/08 21:32:55 krw Exp $	*/
d19 3
a22 3
#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
a26 1
#include <net/if.h>
a28 3

#include "dhcpd.h"
#include "privsep.h"
@


1.14
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2012/11/08 16:40:21 krw Exp $	*/
d331 1
a331 1
delete_old_addresses(char *ifname, int rdomain)
d337 1
a337 1
		error("delete_old_addresses getifaddrs: %m");
d352 1
a352 1
		delete_old_address(ifi->name, ifi->rdomain, addr);
d359 1
a359 1
 * [priv_]delete_old_address is the equivalent of
d365 1
a365 1
delete_old_address(char *ifname, int rdomain, struct in_addr addr)
d399 1
a399 1
priv_delete_old_address(char *ifname, int rdomain, struct in_addr addr)
d489 1
a489 1
 * [priv_]add_new_address is the equivalent of
d495 1
a495 1
add_new_address(char *ifname, int rdomain, struct in_addr addr,
d534 1
a534 1
priv_add_new_address(char *ifname, int rdomain, struct in_addr addr,
@


1.13
log
@Close routing socket fd leak when deleting old address.

Spotted by zinke@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2012/11/07 15:40:13 krw Exp $	*/
d192 2
a193 2
add_default_route(int rdomain, struct iaddr addr,
    struct iaddr gateway)
d224 2
a225 2
priv_add_default_route(int rdomain, struct iaddr addr,
    struct iaddr router)
d275 1
a275 1
		gateway.sin_addr.s_addr = inet_addr(piaddr(router));
d333 1
a333 1
	struct iaddr addr;
a338 3
	if (sizeof(struct in_addr) > sizeof(addr.iabuf))
		error("king bula sez: len mismatch in delete_old_addresses");

d348 3
a350 3
		addr.len = sizeof(struct in_addr);
		memcpy(addr.iabuf,
		    &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr, addr.len);
d365 1
a365 1
delete_old_address(char *ifname, int rdomain, struct iaddr addr)
d371 2
a372 2
	/* Note the address we are deleting for RTM_DELADDR filtering! */
	iaddr_deleting = addr;
d399 1
a399 1
priv_delete_old_address(char *ifname, int rdomain, struct iaddr addr)
a404 1
	in_addr_t bozo;
d421 1
a421 3

	bozo = inet_addr(piaddr(addr));
	memcpy(&in->sin_addr.s_addr, &bozo, sizeof(bozo));
d425 1
a425 1
		warning("SIOCDIFADDR failed (%s): %m", piaddr(addr));
d458 1
a458 1
	dest.sin_addr.s_addr = inet_addr(piaddr(addr));
d495 2
a496 1
add_new_address(char *ifname, int rdomain, struct iaddr addr, in_addr_t mask)
d502 1
a502 1
	iaddr_adding = addr;
d534 2
a535 2
priv_add_new_address(char *ifname, int rdomain, struct iaddr addr,
    in_addr_t mask)
a542 1
	in_addr_t bozo;
d559 1
a559 2
	bozo = inet_addr(piaddr(addr));
	memcpy(&in->sin_addr.s_addr, &bozo, sizeof(bozo));
d570 1
a570 1
		warning("SIOCAIFADDR failed (%s): %m", piaddr(addr));
d600 1
a600 1
	dest.sin_addr.s_addr = inet_addr(piaddr(addr));
@


1.12
log
@Always memcpy() into/out of option data rather than hoping the char *
will be always be aligned. Don't pass around pointers into option
data - use variable that has the memcpy()'d data.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2012/11/07 15:20:28 krw Exp $	*/
d490 2
@


1.11
log
@Use memset() consistently rather than tossing in a few bzero()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2012/11/07 15:07:02 krw Exp $	*/
d499 1
a499 1
add_new_address(char *ifname, int rdomain, struct iaddr addr, in_addr_t *mask)
a500 1
	in_addr_t	 nomask;
d512 1
a512 1
	    sizeof(len) + sizeof(*mask);
d529 1
a529 1
	len = sizeof(*mask);
d531 1
a531 6
	if (mask)
		buf_add(buf, mask, len);
	else {
		memset(&nomask, 0, sizeof(nomask));
		buf_add(buf, &nomask, len);
	}
@


1.10
log
@Use memcpy() consistently rather than tossing in a few bcopy()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2012/11/07 14:47:30 krw Exp $	*/
d117 1
a117 1
		bzero(rti_info, sizeof(rti_info));
d242 1
a242 1
	bzero(&rtm, sizeof(rtm));
d255 1
a255 1
	bzero(&dest, sizeof(dest));
d271 1
a271 1
	bzero(&gateway, sizeof(gateway));
d286 1
a286 1
	bzero(&mask, sizeof(mask));
d298 1
a298 1
	bzero(&label, sizeof(label));
d350 1
a350 1
		bzero(&addr, sizeof(addr));
d419 1
a419 1
	bzero(&ifaliasreq, sizeof(ifaliasreq));
d447 1
a447 1
	bzero(&rtm, sizeof(rtm));
d460 1
a460 1
	bzero(&dest, sizeof(dest));
d474 1
a474 1
	bzero(&gateway, sizeof(gateway));
d535 1
a535 1
		bzero(&nomask, sizeof(nomask));
d562 1
a562 1
	bzero(&ifaliasreq, sizeof(ifaliasreq));
d594 1
a594 1
	bzero(&rtm, sizeof(rtm));
d607 1
a607 1
	bzero(&dest, sizeof(dest));
d621 1
a621 1
	bzero(&gateway, sizeof(gateway));
d635 1
a635 1
	bzero(&label, sizeof(label));
@


1.9
log
@Kill some annoying extra spaces. No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2012/11/05 03:49:16 krw Exp $	*/
d427 1
a427 1
	bcopy(&bozo, &in->sin_addr.s_addr, sizeof(bozo));
d570 1
a570 1
	bcopy(&bozo, &in->sin_addr.s_addr, sizeof(bozo));
d576 1
a576 1
	bcopy(&mask, &in->sin_addr.s_addr, sizeof(mask));
@


1.8
log
@Some systems give ENETUNREACH when trying to add the 'standard'
host route, a.k.a. 'route add w.x.y.z 127.0.0.1'. Since dhclient-script
ignored the failure, ignore it here too until it can be explained
or we stop creating these routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2012/11/04 03:36:39 krw Exp $	*/
d422 1
a422 1
	in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
d566 1
a566 1
	in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
d573 1
a573 1
	in = (struct sockaddr_in *) &ifaliasreq.ifra_mask;
@


1.7
log
@No need to pass interface name around when flushing routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2012/11/04 03:25:31 krw Exp $	*/
d657 5
a661 1
		if (errno != EEXIST)
@


1.6
log
@No need to pass interface name around when creating routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2012/11/03 01:59:31 krw Exp $	*/
d41 1
a41 1
flush_routes_and_arp_cache(char *ifname, int rdomain)
a48 1
	    sizeof(len) + strlen(ifname) +
a53 4
	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

d62 1
a62 1
priv_flush_routes_and_arp_cache(char *ifname, int rdomain)
@


1.5
log
@While this identical idiom caused problems when building an ifaliasreq
to *add* an address, here (building an ifaliasreq to delete an
address) it worked fine. But change it to the bcopy() dance that
works in the adding case just to be consistant until a sparc64/gcc
guru is cornered in a bar with a full keg of guiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2012/11/02 20:21:32 krw Exp $	*/
a78 5
	unsigned int ifi_index;

	ifi_index = if_nametoindex(ifname);
	if (ifi_index == 0)
		error("No interface index found for '%s'", ifname);
d197 1
a197 1
add_default_route(char *ifname, int rdomain, struct iaddr addr,
a205 1
	    sizeof(len) + strlen(ifname) +
a212 4
	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

d229 1
a229 1
priv_add_default_route(char *ifname, int rdomain, struct iaddr addr,
@


1.4
log
@Avoid some misaligned access on sparc64 (at least) by bcopy()'ing
in_addr_t values into s_addr's rather than assigning them.

Possibly not the ideal solution, but at least dhclient will work
again on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2012/11/01 22:07:07 krw Exp $	*/
d423 1
d441 2
a442 1
	in->sin_addr.s_addr = inet_addr(piaddr(addr));
@


1.3
log
@KNF some leading spaces into tabs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2012/10/31 15:50:47 krw Exp $	*/
d565 1
d582 2
a583 1
	in->sin_addr.s_addr = inet_addr(piaddr(addr));
d589 1
a589 1
	in->sin_addr.s_addr = mask;
@


1.2
log
@Forcibly delete all existing ipv4 addresses from an interface when
binding a lease to that interface. This fixes issues sthen@@ found
with unexpectedly persistant addresses and failures of dhclient
when switching an interface repeatedly between different networks.

This crude but predictable behaviour may be toned down once it
is figured out what we want to do with mixed static/dynamic
configurations on an interface.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2012/10/30 16:41:28 krw Exp $	*/
d115 1
a115 1
        ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
d246 1
a246 1
        int s, len, i, iovcnt = 0;
d419 1
a419 1
        struct ifaliasreq ifaliasreq;
d423 2
a424 2
        struct sockaddr_in *in;
        int s, iovcnt = 0;
d433 2
a434 2
        bzero(&ifaliasreq, sizeof(ifaliasreq));
        strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d436 3
a438 3
        in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
        in->sin_family = AF_INET;
        in->sin_len = sizeof(ifaliasreq.ifra_addr);
d440 1
a440 1
        in->sin_addr.s_addr = inet_addr(piaddr(addr));
d443 1
a443 1
        if (ioctl(s, SIOCDIFADDR, &ifaliasreq) == -1) {
d559 1
a559 1
        struct ifaliasreq ifaliasreq;
d564 2
a565 2
        struct sockaddr_in *in;
        int s, len, i, iovcnt = 0;
d574 2
a575 2
        bzero(&ifaliasreq, sizeof(ifaliasreq));
        strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d578 4
a581 4
        in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
        in->sin_family = AF_INET;
        in->sin_len = sizeof(ifaliasreq.ifra_addr);
        in->sin_addr.s_addr = inet_addr(piaddr(addr));
d584 4
a587 4
        in = (struct sockaddr_in *) &ifaliasreq.ifra_mask;
        in->sin_family = AF_INET;
        in->sin_len = sizeof(ifaliasreq.ifra_mask);
        in->sin_addr.s_addr = mask;
d591 1
a591 1
        if (ioctl(s, SIOCAIFADDR, &ifaliasreq) == -1)
@


1.1
log
@New file holding functions to perform direct interface and routing
maninpulations. Inspired by similar files in bgpd, dvmrpd, ldpd, etc.
Necessary for imminent nuking of dhclient-script.

Not linked into build at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 2
d340 34
@

