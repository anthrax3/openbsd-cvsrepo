head	1.89;
access;
symbols
	OPENBSD_6_1:1.85.0.4
	OPENBSD_6_1_BASE:1.85
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.75.0.6
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40;
locks; strict;
comment	@ * @;


1.89
date	2017.04.11.10.40.14;	author krw;	state Exp;
branches;
next	1.88;
commitid	fZH0FasjbItTtOXw;

1.88
date	2017.04.09.20.44.13;	author krw;	state Exp;
branches;
next	1.87;
commitid	Qbefa1v9yY6ObGzy;

1.87
date	2017.04.08.20.16.04;	author krw;	state Exp;
branches;
next	1.86;
commitid	KIdulj0iLtM6kXff;

1.86
date	2017.04.05.18.22.31;	author krw;	state Exp;
branches;
next	1.85;
commitid	wE6Aq0gXfIxsFOYi;

1.85
date	2017.03.08.15.07.32;	author krw;	state Exp;
branches;
next	1.84;
commitid	7X10TIqdvbVgYrdj;

1.84
date	2017.02.12.15.53.15;	author krw;	state Exp;
branches;
next	1.83;
commitid	YTCiHbXKpxvNuYuw;

1.83
date	2017.02.12.13.55.01;	author krw;	state Exp;
branches;
next	1.82;
commitid	WchZmaQT4LJ4im5M;

1.82
date	2017.02.12.13.15.50;	author krw;	state Exp;
branches;
next	1.81;
commitid	IDlzr3qamZK5lxzj;

1.81
date	2016.08.23.09.26.02;	author mpi;	state Exp;
branches;
next	1.80;
commitid	Tm7CrlqCKqgQoJ7P;

1.80
date	2016.07.21.09.58.55;	author krw;	state Exp;
branches;
next	1.79;
commitid	PqPfLTbAliUfPkYk;

1.79
date	2016.02.06.19.30.52;	author krw;	state Exp;
branches;
next	1.78;
commitid	5ELOU0S0Zl3aCrHG;

1.78
date	2015.12.19.14.56.22;	author krw;	state Exp;
branches;
next	1.77;
commitid	HpoFuGWLuo7L4PWH;

1.77
date	2015.12.19.01.09.10;	author krw;	state Exp;
branches;
next	1.76;
commitid	pW1WqW8E6BMP0fMV;

1.76
date	2015.12.18.22.17.46;	author krw;	state Exp;
branches;
next	1.75;
commitid	mS25IJ8OlNlIc1Lj;

1.75
date	2015.02.10.04.20.26;	author krw;	state Exp;
branches;
next	1.74;
commitid	TKehEr2jJpb2ARar;

1.74
date	2015.02.08.01.20.40;	author krw;	state Exp;
branches;
next	1.73;
commitid	1gFDlNw9V7WtdiEL;

1.73
date	2015.02.07.10.08.06;	author krw;	state Exp;
branches;
next	1.72;
commitid	DyjrY1dcWE4nZyJh;

1.72
date	2015.02.07.02.07.32;	author krw;	state Exp;
branches;
next	1.71;
commitid	WadF2oct8H7f0Oaz;

1.71
date	2015.02.06.06.47.29;	author krw;	state Exp;
branches;
next	1.70;
commitid	NYRWhJb6ZVSnKVWu;

1.70
date	2015.01.31.03.13.04;	author krw;	state Exp;
branches;
next	1.69;
commitid	NkXCL9IMO1B1DiTY;

1.69
date	2015.01.30.14.14.53;	author krw;	state Exp;
branches;
next	1.68;
commitid	3QeVfD902FHLKJeU;

1.68
date	2014.10.27.13.36.21;	author krw;	state Exp;
branches;
next	1.67;
commitid	18JJKpLCJZeJyulS;

1.67
date	2014.07.14.18.16.27;	author miod;	state Exp;
branches;
next	1.66;
commitid	tde65FrKdvVWEhmG;

1.66
date	2014.07.09.15.16.38;	author krw;	state Exp;
branches;
next	1.65;
commitid	j471lw6pShGoXIJ5;

1.65
date	2014.05.05.18.02.49;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2014.02.13.00.24.13;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2014.02.09.20.45.56;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2014.02.09.20.23.22;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2014.02.09.20.08.25;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.20.02.54.07;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.08.22.49.02;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.05.21.32.59;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2013.12.04.19.39.50;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2013.08.17.14.50.05;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2013.07.05.22.13.10;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.09.22.39.51;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.09.17.31.54;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2013.06.09.16.21.50;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.09.15.06.34;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.09.00.30.06;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.04.21.04.53;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2013.06.01.16.26.07;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.30.16.10.01;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.24.12.53.20;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.13.16.28.05;	author weerd;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.11.16.01.02;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.08.12.25.15;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.07.13.23.27;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2013.02.28.21.00.53;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2013.02.24.01.23.19;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2013.02.21.14.10.22;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2013.02.18.22.10.04;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2013.02.18.15.57.08;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2013.02.17.17.36.31;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2013.02.17.17.04.41;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.17.15.48.03;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.17.15.08.13;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.02.15.01.20.39;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.02.03.15.10.36;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2013.02.01.01.33.44;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.22.06.02.52;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.17.23.41.07;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.29.14.40.00;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.19.12.25.38;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.17.22.52.59;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.04.19.24.03;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.03.22.36.16;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.03.22.19.47;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.02.17.03.19;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.23.15.25.47;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.17.10.39.24;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2012.11.16.14.59.36;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2012.11.15.14.54.18;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.14.15.47.41;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.08.21.32.55;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.08.16.40.21;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.07.15.40.13;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.07.15.20.28;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.07.15.07.02;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.07.14.47.30;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.05.03.49.16;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.04.03.36.39;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.04.03.25.31;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.03.01.59.31;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.02.20.21.32;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.01.22.07.07;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.31.15.50.47;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2012.10.30.16.41.28;	author krw;	state Exp;
branches;
next	;


desc
@@


1.89
log
@Fold priv_write_file() into its only remaining user
priv_write_resolv_conf() and move the latter into kroute.c
with all its priv_ friends.

No intentional functional change.
@
text
@/*	$OpenBSD: kroute.c,v 1.88 2017/04/09 20:44:13 krw Exp $	*/

/*
 * Copyright 2012 Kenneth R Westerback <krw@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/sysctl.h>

#include <arpa/inet.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <errno.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <imsg.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"
#include "privsep.h"

#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

struct in_addr active_addr;

int	create_route_label(struct sockaddr_rtlabel *);
int	check_route_label(struct sockaddr_rtlabel *);
void	populate_rti_info(struct sockaddr **, struct rt_msghdr *);
void	delete_route(struct interface_info *, int, struct rt_msghdr *);

#define	ROUTE_LABEL_NONE		1
#define	ROUTE_LABEL_NOT_DHCLIENT	2
#define	ROUTE_LABEL_DHCLIENT_OURS	3
#define	ROUTE_LABEL_DHCLIENT_UNKNOWN	4
#define	ROUTE_LABEL_DHCLIENT_LIVE	5
#define	ROUTE_LABEL_DHCLIENT_DEAD	6

/*
 * Do equivalent of
 *
 *	route -q $rdomain -n flush -inet -iface $interface
 *	arp -dan
 */
void
flush_routes(void)
{
	struct imsg_flush_routes imsg;
	int			 rslt;

	imsg.zapzombies = 1;

	rslt = imsg_compose(unpriv_ibuf, IMSG_FLUSH_ROUTES, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("flush_routes: imsg_compose");

	flush_unpriv_ibuf("flush_routes");
}

void
priv_flush_routes(struct interface_info *ifi, struct imsg_flush_routes *imsg)
{
	char ifname[IF_NAMESIZE];
	struct sockaddr *rti_info[RTAX_MAX];
	int mib[7];
	size_t needed;
	char *lim, *buf = NULL, *bufp, *next, *errmsg = NULL;
	struct rt_msghdr *rtm;
	struct sockaddr_in *sa_in;
	struct sockaddr_rtlabel *sa_rl;
	int s;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_GATEWAY;
	mib[6] = ifi->rdomain;

	while (1) {
		if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
			errmsg = "sysctl size of routes:";
			break;
		}
		if (needed == 0) {
			free(buf);
			return;
		}
		if ((bufp = realloc(buf, needed)) == NULL) {
			errmsg = "routes buf realloc:";
			break;
		}
		buf = bufp;
		if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			errmsg = "sysctl retrieval of routes:";
			break;
		}
		break;
	}

	if (errmsg) {
		log_warn("route cleanup failed - %s (msize=%zu)", errmsg,
		    needed);
		free(buf);
		return;
	}

	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		fatal("opening socket to flush routes");

	lim = buf + needed;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		populate_rti_info(rti_info, rtm);

		sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
		sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];

		switch (check_route_label(sa_rl)) {
		case ROUTE_LABEL_DHCLIENT_OURS:
			/* Always delete routes we labeled. */
			delete_route(ifi, s, rtm);
			break;
		case ROUTE_LABEL_DHCLIENT_DEAD:
			if (imsg->zapzombies)
				delete_route(ifi, s, rtm);
			break;
		case ROUTE_LABEL_DHCLIENT_LIVE:
		case ROUTE_LABEL_DHCLIENT_UNKNOWN:
			/* Another dhclient's responsibility. */
			break;
		case ROUTE_LABEL_NONE:
		case ROUTE_LABEL_NOT_DHCLIENT:
			/* Delete default routes on our interface. */
			if (if_indextoname(rtm->rtm_index, ifname) &&
			    sa_in &&
			    sa_in->sin_addr.s_addr == INADDR_ANY &&
			    rtm->rtm_tableid == ifi->rdomain &&
			    strcmp(ifi->name, ifname) == 0)
				delete_route(ifi, s, rtm);
			break;
		default:
			break;
		}
	}

	close(s);
	free(buf);
}

void
add_route(struct in_addr dest, struct in_addr netmask,
    struct in_addr gateway, struct in_addr ifa, int addrs, int flags)
{
	struct imsg_add_route	 imsg;
	int			 rslt;

	imsg.dest = dest;
	imsg.gateway = gateway;
	imsg.netmask = netmask;
	imsg.ifa = ifa;
	imsg.addrs = addrs;
	imsg.flags = flags;

	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ROUTE, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("add_route: imsg_compose");

	flush_unpriv_ibuf("add_route");
}

void
priv_add_route(struct interface_info *ifi, struct imsg_add_route *imsg)
{
	char destbuf[INET_ADDRSTRLEN], gatewaybuf[INET_ADDRSTRLEN];
	char maskbuf[INET_ADDRSTRLEN], ifabuf[INET_ADDRSTRLEN];
	struct rt_msghdr rtm;
	struct sockaddr_in dest, gateway, mask, ifa;
	struct sockaddr_rtlabel label;
	struct iovec iov[6];
	int s, i, iovcnt = 0;

	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		fatal("Routing Socket open failed");

	memset(destbuf, 0, sizeof(destbuf));
	memset(maskbuf, 0, sizeof(maskbuf));
	memset(gatewaybuf, 0, sizeof(gatewaybuf));
	memset(ifabuf, 0, sizeof(ifabuf));

	/* Build RTM header */

	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_ADD;
	rtm.rtm_tableid = ifi->rdomain;
	rtm.rtm_priority = RTP_NONE;
	rtm.rtm_msglen = sizeof(rtm);
	rtm.rtm_addrs = imsg->addrs;
	rtm.rtm_flags = imsg->flags;

	iov[iovcnt].iov_base = &rtm;
	iov[iovcnt++].iov_len = sizeof(rtm);

	if (imsg->addrs & RTA_DST) {
		strlcpy(destbuf, inet_ntoa(imsg->dest), sizeof(destbuf));
		memset(&dest, 0, sizeof(dest));

		dest.sin_len = sizeof(dest);
		dest.sin_family = AF_INET;
		dest.sin_addr.s_addr = imsg->dest.s_addr;

		rtm.rtm_msglen += sizeof(dest);

		iov[iovcnt].iov_base = &dest;
		iov[iovcnt++].iov_len = sizeof(dest);
	}

	if (imsg->addrs & RTA_GATEWAY) {
		strlcpy(gatewaybuf, inet_ntoa(imsg->gateway),
		    sizeof(gatewaybuf));
		memset(&gateway, 0, sizeof(gateway));

		gateway.sin_len = sizeof(gateway);
		gateway.sin_family = AF_INET;
		gateway.sin_addr.s_addr = imsg->gateway.s_addr;

		rtm.rtm_msglen += sizeof(gateway);

		iov[iovcnt].iov_base = &gateway;
		iov[iovcnt++].iov_len = sizeof(gateway);
	}

	if (imsg->addrs & RTA_NETMASK) {
		strlcpy(maskbuf, inet_ntoa(imsg->netmask), sizeof(maskbuf));
		memset(&mask, 0, sizeof(mask));

		mask.sin_len = sizeof(mask);
		mask.sin_family = AF_INET;
		mask.sin_addr.s_addr = imsg->netmask.s_addr;

		rtm.rtm_msglen += sizeof(mask);

		iov[iovcnt].iov_base = &mask;
		iov[iovcnt++].iov_len = sizeof(mask);
	}

	if (imsg->addrs & RTA_IFA) {
		strlcpy(ifabuf, inet_ntoa(imsg->ifa), sizeof(ifabuf));
		memset(&ifa, 0, sizeof(ifa));

		ifa.sin_len = sizeof(ifa);
		ifa.sin_family = AF_INET;
		ifa.sin_addr.s_addr = imsg->ifa.s_addr;

		rtm.rtm_msglen += sizeof(ifa);

		iov[iovcnt].iov_base = &ifa;
		iov[iovcnt++].iov_len = sizeof(ifa);
	}

	/* Add our label so we can identify the route as our creation. */
	if (create_route_label(&label) == 0) {
		rtm.rtm_addrs |= RTA_LABEL;
		rtm.rtm_msglen += sizeof(label);
		iov[iovcnt].iov_base = &label;
		iov[iovcnt++].iov_len = sizeof(label);
	}

	/* Check for EEXIST since other dhclient may not be done. */
	for (i = 0; i < 5; i++) {
		if (writev(s, iov, iovcnt) != -1)
			break;
		if (i == 4)
			log_warn("failed to add route (%s/%s via %s/%s)",
			    destbuf, maskbuf, gatewaybuf, ifabuf);
		else if (errno == EEXIST || errno == ENETUNREACH)
			sleep(1);
	}

	close(s);
}

/*
 * Delete all existing inet addresses on interface.
 */
void
delete_addresses(struct interface_info *ifi)
{
	struct in_addr addr;
	struct ifaddrs *ifap, *ifa;

	if (getifaddrs(&ifap) != 0)
		fatal("delete_addresses getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT) ||
		    (!(ifa->ifa_flags & IFF_UP)) ||
		    (ifa->ifa_addr->sa_family != AF_INET) ||
		    (strcmp(ifi->name, ifa->ifa_name) != 0))
			continue;

		memcpy(&addr, &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr,
		    sizeof(addr));

		delete_address(addr);
	}

	freeifaddrs(ifap);
}

/*
 * [priv_]delete_address is the equivalent of
 *
 *	ifconfig <ifname> inet <addr> delete
 */
void
delete_address(struct in_addr addr)
{
	struct imsg_delete_address	 imsg;
	int				 rslt;

	/* Note the address we are deleting for RTM_DELADDR filtering! */
	deleting.s_addr = addr.s_addr;

	imsg.addr = addr;

	rslt = imsg_compose(unpriv_ibuf, IMSG_DELETE_ADDRESS, 0, 0 , -1, &imsg,
	    sizeof(imsg));
	if (rslt == -1)
		log_warn("delete_address: imsg_compose");

	flush_unpriv_ibuf("delete_address");
}

void
priv_delete_address(struct interface_info *ifi,
    struct imsg_delete_address *imsg)
{
	struct ifaliasreq ifaliasreq;
	struct sockaddr_in *in;
	int s;

	/*
	 * Delete specified address on specified interface.
	 */

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		fatal("socket open failed");

	memset(&ifaliasreq, 0, sizeof(ifaliasreq));
	strncpy(ifaliasreq.ifra_name, ifi->name, sizeof(ifaliasreq.ifra_name));

	in = (struct sockaddr_in *)&ifaliasreq.ifra_addr;
	in->sin_family = AF_INET;
	in->sin_len = sizeof(ifaliasreq.ifra_addr);
	in->sin_addr.s_addr = imsg->addr.s_addr;

	/* SIOCDIFADDR will result in a RTM_DELADDR message we must catch! */
	if (ioctl(s, SIOCDIFADDR, &ifaliasreq) == -1) {
		if (errno != EADDRNOTAVAIL)
			log_warn("SIOCDIFADDR failed (%s)",
			    inet_ntoa(imsg->addr));
	}

	close(s);
}

/*
 * [priv_]set_interface_mtu is the equivalent of
 *
 *      ifconfig <if> mtu <mtu>
 */
void
set_interface_mtu(int mtu)
{
	struct imsg_set_interface_mtu imsg;
	int rslt;

	imsg.mtu = mtu;

	rslt = imsg_compose(unpriv_ibuf, IMSG_SET_INTERFACE_MTU, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("set_interface_mtu: imsg_compose");

	flush_unpriv_ibuf("set_interface_mtu");
}

void
priv_set_interface_mtu(struct interface_info *ifi,
    struct imsg_set_interface_mtu *imsg)
{
	struct ifreq ifr;
	int s;

	memset(&ifr, 0, sizeof(ifr));

	strlcpy(ifr.ifr_name, ifi->name, sizeof(ifr.ifr_name));
	ifr.ifr_mtu = imsg->mtu;

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		fatal("socket open failed");
	if (ioctl(s, SIOCSIFMTU, &ifr) == -1)
		log_warn("SIOCSIFMTU failed (%d)", imsg->mtu);
	close(s);
}

/*
 * [priv_]add_address is the equivalent of
 *
 *	ifconfig <if> inet <addr> netmask <mask> broadcast <addr>
 */
void
add_address(struct in_addr addr, struct in_addr mask)
{
	struct imsg_add_address imsg;
	int			rslt;

	/* Note the address we are adding for RTM_NEWADDR filtering! */
	adding = addr;

	imsg.addr = addr;
	imsg.mask = mask;

	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ADDRESS, 0, 0, -1, &imsg,
	    sizeof(imsg));
	if (rslt == -1)
		log_warn("add_address: imsg_compose");

	flush_unpriv_ibuf("add_address");
}

void
priv_add_address(struct interface_info *ifi, struct imsg_add_address *imsg)
{
	struct ifaliasreq ifaliasreq;
	struct sockaddr_in *in;
	int s;

	if (imsg->addr.s_addr == INADDR_ANY) {
		/* Notification that the active_addr has been deleted. */
		active_addr.s_addr = INADDR_ANY;
		quit = INTERNALSIG;
		return;
	}

	/*
	 * Add specified address on specified interface.
	 */

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		fatal("socket open failed");

	memset(&ifaliasreq, 0, sizeof(ifaliasreq));
	strncpy(ifaliasreq.ifra_name, ifi->name, sizeof(ifaliasreq.ifra_name));

	/* The actual address in ifra_addr. */
	in = (struct sockaddr_in *)&ifaliasreq.ifra_addr;
	in->sin_family = AF_INET;
	in->sin_len = sizeof(ifaliasreq.ifra_addr);
	in->sin_addr.s_addr = imsg->addr.s_addr;

	/* And the netmask in ifra_mask. */
	in = (struct sockaddr_in *)&ifaliasreq.ifra_mask;
	in->sin_family = AF_INET;
	in->sin_len = sizeof(ifaliasreq.ifra_mask);
	memcpy(&in->sin_addr, &imsg->mask, sizeof(in->sin_addr));

	/* No need to set broadcast address. Kernel can figure it out. */

	if (ioctl(s, SIOCAIFADDR, &ifaliasreq) == -1)
		log_warn("SIOCAIFADDR failed (%s)", inet_ntoa(imsg->addr));

	close(s);

	active_addr = imsg->addr;
}

/*
 * priv_cleanup removes dhclient installed routes and address.
 */
void
priv_cleanup(struct interface_info *ifi, struct imsg_hup *imsg)
{
	struct imsg_flush_routes fimsg;
	struct imsg_delete_address dimsg;

	fimsg.zapzombies = 0;	/* Only zapzombies when binding a lease. */
	priv_flush_routes(ifi, &fimsg);

	if (imsg->addr.s_addr == INADDR_ANY)
		return;

	dimsg.addr = imsg->addr;
	priv_delete_address(ifi, &dimsg);
}

/*
 * priv_write_resolv_conf writes out a new resolv.conf.
 */
void
priv_write_resolv_conf(struct interface_info *ifi, struct imsg *imsg)
{
	u_int8_t *contents;
	ssize_t n;
	size_t sz;
	int fd;


	if (imsg->hdr.len < IMSG_HEADER_SIZE) {
		log_warnx("short IMSG_WRITE_RESOLV_CONF");
		return;
	}

	if (!resolv_conf_priority(ifi))
		return;

	contents = imsg->data;
	sz = imsg->hdr.len - IMSG_HEADER_SIZE;

	fd = open(_PATH_RESOLV_CONF, O_WRONLY | O_CREAT | O_TRUNC,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

	if (fd == -1) {
		log_warn("Couldn't open '%s'", _PATH_RESOLV_CONF);
		return;
	}

	n = write(fd, contents, sz);
	if (n == -1)
		log_warn("Couldn't write contents to '%s'", _PATH_RESOLV_CONF);
	else if ((size_t)n < sz)
		log_warnx("Short contents write to '%s' (%zd vs %zu)",
		    _PATH_RESOLV_CONF, n, sz);

	close(fd);
}

int
resolv_conf_priority(struct interface_info *ifi)
{
	struct iovec iov[3];
	struct {
		struct rt_msghdr	m_rtm;
		char			m_space[512];
	} m_rtmsg;
	struct sockaddr *rti_info[RTAX_MAX];
	struct sockaddr_in sin;
	struct sockaddr_rtlabel *sa_rl;
	pid_t pid;
	ssize_t len;
	int s, seq, rslt, iovcnt = 0;

	rslt = 0;

	s = socket(PF_ROUTE, SOCK_RAW, AF_INET);
	if (s == -1) {
		log_warn("default route socket");
		return (0);
	}

	/* Build RTM header */

	memset(&m_rtmsg, 0, sizeof(m_rtmsg));

	m_rtmsg.m_rtm.rtm_version = RTM_VERSION;
	m_rtmsg.m_rtm.rtm_type = RTM_GET;
	m_rtmsg.m_rtm.rtm_msglen = sizeof(m_rtmsg.m_rtm);
	m_rtmsg.m_rtm.rtm_flags = RTF_STATIC | RTF_GATEWAY | RTF_UP;
	m_rtmsg.m_rtm.rtm_seq = seq = arc4random();
	m_rtmsg.m_rtm.rtm_tableid = ifi->rdomain;

	iov[iovcnt].iov_base = &m_rtmsg.m_rtm;
	iov[iovcnt++].iov_len = sizeof(m_rtmsg.m_rtm);

	/* Set destination & netmask addresses of all zeros. */

	m_rtmsg.m_rtm.rtm_addrs = RTA_DST | RTA_NETMASK;

	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;

	iov[iovcnt].iov_base = &sin;
	iov[iovcnt++].iov_len = sizeof(sin);
	iov[iovcnt].iov_base = &sin;
	iov[iovcnt++].iov_len = sizeof(sin);

	m_rtmsg.m_rtm.rtm_msglen += 2 * sizeof(sin);

	if (writev(s, iov, iovcnt) == -1) {
		if (errno != ESRCH)
			log_warn("RTM_GET of default route");
		goto done;
	}

	pid = getpid();

	do {
		len = read(s, &m_rtmsg, sizeof(m_rtmsg));
		if (len == -1) {
			log_warn("get default route read");
			break;
		} else if (len == 0) {
			log_warnx("no data from default route read");
			break;
		}
		if (m_rtmsg.m_rtm.rtm_version != RTM_VERSION)
			continue;
		if (m_rtmsg.m_rtm.rtm_type == RTM_GET &&
		    m_rtmsg.m_rtm.rtm_pid == pid &&
		    m_rtmsg.m_rtm.rtm_seq == seq) {
			if (m_rtmsg.m_rtm.rtm_errno) {
				log_warnx("default route read rtm: %s",
				    strerror(m_rtmsg.m_rtm.rtm_errno));
				goto done;
			}
			break;
		}
	} while (1);

	populate_rti_info(rti_info, &m_rtmsg.m_rtm);

	sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
	if (check_route_label(sa_rl) == ROUTE_LABEL_DHCLIENT_OURS)
		rslt = 1;

done:
	close(s);
	return (rslt);
}

int
create_route_label(struct sockaddr_rtlabel *label)
{
	int len;

	memset(label, 0, sizeof(*label));

	label->sr_len = sizeof(label);
	label->sr_family = AF_UNSPEC;

	len = snprintf(label->sr_label, sizeof(label->sr_label), "DHCLIENT %d",
	    (int)getpid());

	if (len == -1 || (unsigned int)len >= sizeof(label->sr_label)) {
		log_warn("could not create route label");
		return (1);
	}

	return (0);
}

int
check_route_label(struct sockaddr_rtlabel *label)
{
	pid_t pid;

	if (!label)
		return (ROUTE_LABEL_NONE);

	if (strncmp("DHCLIENT ", label->sr_label, 9) != 0)
		return (ROUTE_LABEL_NOT_DHCLIENT);

	pid = (pid_t)strtonum(label->sr_label + 9, 1, INT_MAX, NULL);
	if (pid <= 0)
		return (ROUTE_LABEL_DHCLIENT_UNKNOWN);

	if (pid == getpid())
		return (ROUTE_LABEL_DHCLIENT_OURS);

	if (kill(pid, 0) == -1) {
		if (errno == ESRCH)
			return (ROUTE_LABEL_DHCLIENT_DEAD);
		else
			return (ROUTE_LABEL_DHCLIENT_UNKNOWN);
	}

	return (ROUTE_LABEL_DHCLIENT_LIVE);
}

void
populate_rti_info(struct sockaddr **rti_info, struct rt_msghdr *rtm)
{
	struct sockaddr *sa;
	int i;

	sa = (struct sockaddr *)((char *)(rtm) + rtm->rtm_hdrlen);

	for (i = 0; i < RTAX_MAX; i++) {
		if (rtm->rtm_addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

void
delete_route(struct interface_info *ifi, int s, struct rt_msghdr *rtm)
{
	static int seqno;
	ssize_t rlen;

	rtm->rtm_type = RTM_DELETE;
	rtm->rtm_tableid = ifi->rdomain;
	rtm->rtm_seq = seqno++;

	rlen = write(s, (char *)rtm, rtm->rtm_msglen);
	if (rlen == -1) {
		if (errno != ESRCH)
			fatal("RTM_DELETE write");
	} else if (rlen < (int)rtm->rtm_msglen)
		fatalx("short RTM_DELETE write (%zd)\n", rlen);
}

void
flush_unpriv_ibuf(const char *who)
{
	while (unpriv_ibuf->w.queued) {
		if (msgbuf_write(&unpriv_ibuf->w) <= 0) {
			if (errno == EAGAIN)
				break;
			if (quit == 0)
				quit = INTERNALSIG;
			if (errno != EPIPE && errno != 0)
				log_warn("%s: msgbuf_write", who);
			break;
		}
	}
}
@


1.88
log
@Seven casts, a couple of tweaks and CFLAGS+=-Wsign-compare for the
win.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.87 2017/04/08 20:16:04 krw Exp $	*/
d21 1
d34 1
d534 41
@


1.87
log
@Reduce the overburden of signed vs unsigned comparisons by sprinkling
'int' -> 'unsigned int' (and visa versa) where obvious.

Steal a couple of 'unsigned' -> u_int32_t from reyk@@'s dhcrelay
tweaks.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.86 2017/04/05 18:22:31 krw Exp $	*/
d641 2
a642 8
	if (len == -1) {
		log_warn("creating route label");
		return (1);
	}

	if (len >= sizeof(label->sr_label)) {
		log_warnx("creating route label: label too long (%d vs %zu)",
		    len, sizeof(label->sr_label));
@


1.86
log
@Shuffle sendhup() into dispatch.c, the only place it is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.85 2017/03/08 15:07:32 krw Exp $	*/
d547 1
a547 2
	u_int32_t seq;
	int s, rslt, iovcnt = 0;
@


1.85
log
@Move ROUNDUP() to top of file, outside of warring #ifdef's to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.84 2017/02/12 15:53:15 krw Exp $	*/
a512 22
}

/*
 * Inform the [priv] process a HUP was received and it should restart.
 */
void
sendhup(struct client_lease *active)
{
	struct imsg_hup imsg;
	int rslt;

	if (active)
		imsg.addr = active->address;
	else
		imsg.addr.s_addr = INADDR_ANY;

	rslt = imsg_compose(unpriv_ibuf, IMSG_HUP, 0, 0, -1,
	    &imsg, sizeof(imsg));
	if (rslt == -1)
		log_warn("sendhup: imsg_compose");

	flush_unpriv_ibuf("sendhup");
@


1.84
log
@Eliminate most strerror() invocations by using log_warn() and fatal()
instead of log_warnx() and fatalx(). A few log_info() to log_warn()
for the same reason.

Suggested by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.83 2017/02/12 13:55:01 krw Exp $	*/
d47 3
a710 3

#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
@


1.83
log
@Adjust lines that are too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.82 2017/02/12 13:15:50 krw Exp $	*/
d78 1
a78 1
		log_warnx("flush_routes: imsg_compose: %s", strerror(errno));
d128 2
a129 2
		log_warnx("route cleanup failed - %s %s (msize=%zu)",
		    errmsg, strerror(errno), needed);
d135 1
a135 1
		fatalx("opening socket to flush routes: %s", strerror(errno));
d197 1
a197 1
		log_warnx("add_route: imsg_compose: %s", strerror(errno));
d214 1
a214 1
		fatalx("Routing Socket open failed: %s", strerror(errno));
d306 2
a307 3
			log_warnx("failed to add route (%s/%s via %s/%s): %s",
			    destbuf, maskbuf, gatewaybuf, ifabuf,
			    strerror(errno));
d325 1
a325 1
		fatalx("delete_addresses getifaddrs: %s", strerror(errno));
d363 1
a363 1
		log_warnx("delete_address: imsg_compose: %s", strerror(errno));
d381 1
a381 1
		fatalx("socket open failed: %s", strerror(errno));
d394 2
a395 2
			log_warnx("SIOCDIFADDR failed (%s): %s",
			    inet_ntoa(imsg->addr), strerror(errno));
d417 1
a417 2
		log_warnx("set_interface_mtu: imsg_compose: %s",
		    strerror(errno));
d435 1
a435 1
		fatalx("socket open failed: %s", strerror(errno));
d437 1
a437 2
		log_warnx("SIOCSIFMTU failed (%d): %s", imsg->mtu,
		    strerror(errno));
d461 1
a461 1
		log_warnx("add_address: imsg_compose: %s", strerror(errno));
d485 1
a485 1
		fatalx("socket open failed: %s", strerror(errno));
d505 1
a505 2
		log_warnx("SIOCAIFADDR failed (%s): %s", inet_ntoa(imsg->addr),
		    strerror(errno));
d529 1
a529 1
		log_warnx("sendhup: imsg_compose: %s", strerror(errno));
d573 1
a573 1
		log_warnx("default route socket: %s", strerror(errno));
d608 1
a608 2
			log_warnx("RTM_GET of default route: %s",
			    strerror(errno));
d617 1
a617 2
			log_warnx("get default route read: %s",
			    strerror(errno));
d662 1
a662 1
		log_warnx("creating route label: %s", strerror(errno));
d737 1
a737 1
			fatalx("RTM_DELETE write: %s", strerror(errno));
d752 1
a752 2
				log_warnx("%s: msgbuf_write: %s", who,
				    strerror(errno));
@


1.82
log
@Switch from 'legacy' errwarn.c to standard daemon logging functions.

No objections heard. Feedback from millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.81 2016/08/23 09:26:02 mpi Exp $	*/
d418 2
a419 1
		log_warnx("set_interface_mtu: imsg_compose: %s", strerror(errno));
d622 2
a623 1
			log_warnx("get default route read: %s", strerror(errno));
d673 2
a674 2
		log_warnx("creating route label: label too long (%d vs %zu)", len,
		    sizeof(label->sr_label));
@


1.81
log
@Make the 'ifi' global local to dhclient.c and pass it as an argument to
functions needing it.

This is the first step to support multiple interfaces in one dhclient(8)
instance.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.80 2016/07/21 09:58:55 krw Exp $	*/
d44 1
d78 1
a78 1
		warning("flush_routes: imsg_compose: %s", strerror(errno));
d128 1
a128 1
		warning("route cleanup failed - %s %s (msize=%zu)",
d135 1
a135 1
		error("opening socket to flush routes: %s", strerror(errno));
d197 1
a197 1
		warning("add_route: imsg_compose: %s", strerror(errno));
d214 1
a214 1
		error("Routing Socket open failed: %s", strerror(errno));
d306 1
a306 1
			warning("failed to add route (%s/%s via %s/%s): %s",
d326 1
a326 1
		error("delete_addresses getifaddrs: %s", strerror(errno));
d364 1
a364 1
		warning("delete_address: imsg_compose: %s", strerror(errno));
d382 1
a382 1
		error("socket open failed: %s", strerror(errno));
d395 1
a395 1
			warning("SIOCDIFADDR failed (%s): %s",
d418 1
a418 1
		warning("set_interface_mtu: imsg_compose: %s", strerror(errno));
d436 1
a436 1
		error("socket open failed: %s", strerror(errno));
d438 1
a438 1
		warning("SIOCSIFMTU failed (%d): %s", imsg->mtu,
d463 1
a463 1
		warning("add_address: imsg_compose: %s", strerror(errno));
d487 1
a487 1
		error("socket open failed: %s", strerror(errno));
d507 1
a507 1
		warning("SIOCAIFADDR failed (%s): %s", inet_ntoa(imsg->addr),
d532 1
a532 1
		warning("sendhup: imsg_compose: %s", strerror(errno));
d576 1
a576 1
		warning("default route socket: %s", strerror(errno));
d611 1
a611 1
			warning("RTM_GET of default route: %s",
d621 1
a621 1
			warning("get default route read: %s", strerror(errno));
d624 1
a624 1
			warning("no data from default route read");
d633 1
a633 1
				warning("default route read rtm: %s",
d666 1
a666 1
		warning("creating route label: %s", strerror(errno));
d671 1
a671 1
		warning("creating route label: label too long (%d vs %zu)", len,
d741 1
a741 1
			error("RTM_DELETE write: %s", strerror(errno));
d743 1
a743 1
		error("short RTM_DELETE write (%zd)\n", rlen);
d756 1
a756 1
				warning("%s: msgbuf_write: %s", who,
@


1.80
log
@Use explicit idiom when testing the result of strcmp() and strncmp().
i.e. == 0 and != 0 as appropriate. No intentional functional change.

Suggested by & ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.79 2016/02/06 19:30:52 krw Exp $	*/
d51 1
a51 1
void	delete_route(int, struct rt_msghdr *);
d83 1
a83 1
priv_flush_routes(struct imsg_flush_routes *imsg)
d150 1
a150 1
			delete_route(s, rtm);
d154 1
a154 1
				delete_route(s, rtm);
d168 1
a168 1
				delete_route(s, rtm);
d202 1
a202 1
priv_add_route(struct imsg_add_route *imsg)
d319 1
a319 1
delete_addresses(void)
d369 2
a370 1
priv_delete_address(struct imsg_delete_address *imsg)
d423 2
a424 1
priv_set_interface_mtu(struct imsg_set_interface_mtu *imsg)
d468 1
a468 1
priv_add_address(struct imsg_add_address *imsg)
d540 1
a540 1
priv_cleanup(struct imsg_hup *imsg)
d546 1
a546 1
	priv_flush_routes(&fimsg);
d552 1
a552 1
	priv_delete_address(&dimsg);
d556 1
a556 1
resolv_conf_priority(void)
d728 1
a728 1
delete_route(int s, struct rt_msghdr *rtm)
@


1.79
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.78 2015/12/19 14:56:22 krw Exp $	*/
d332 1
a332 1
		    (strcmp(ifi->name, ifa->ifa_name)))
d684 1
a684 1
	if (strncmp("DHCLIENT ", label->sr_label, 9))
@


1.78
log
@Don't exit if a route can't be added. Just log particulars and
let someone else figure it out.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.77 2015/12/19 01:09:10 krw Exp $	*/
a18 3
#include "dhcpd.h"
#include "privsep.h"

d20 1
a21 1
#include <sys/uio.h>
d23 3
d27 1
d29 4
d34 2
d37 8
@


1.77
log
@Delete superfluous "close(s);return" just before "close(s);<function
exit>".
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.76 2015/12/18 22:17:46 krw Exp $	*/
d189 2
d200 5
d221 1
d235 2
d250 1
d264 1
d289 3
a291 2
		if (errno != EEXIST && errno != ENETUNREACH)
			error("failed to add default route: %s",
d293 2
a294 1
		sleep(1);
@


1.76
log
@Check ioctl() result with == -1, not < 0. Break long line.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.75 2015/02/10 04:20:26 krw Exp $	*/
a365 2
		close(s);
		return;
@


1.75
log
@Groundwork for better route support over multiple interfaces by
using RTM_IFA to bind routes to an interface. Keep the subnet route
conflict avoidance code for the time being.

diff from claudio@@ as part of larger routing magic diff.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.74 2015/02/08 01:20:40 krw Exp $	*/
d407 3
a409 2
	if (ioctl(s, SIOCSIFMTU, &ifr) < 0)
		warning("SIOCSIFMTU failed (%d): %s", imsg->mtu, strerror(errno));
@


1.74
log
@Get rid of a bunch of memset()'s where struct variables and arrays
are clearly properly initialized in the same area. Prompted by the
recent shrinkage of most imsg structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.73 2015/02/07 10:08:06 krw Exp $	*/
d165 2
a166 2
add_route(struct in_addr dest, struct in_addr netmask, struct in_addr gateway,
    int addrs, int flags)
d174 1
d190 1
a190 1
	struct sockaddr_in dest, gateway, mask;
d192 1
a192 1
	struct iovec iov[5];
d250 13
@


1.73
log
@Add support for interface-mtu (option 26).

Original request+diff from matthew@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.72 2015/02/07 02:07:32 krw Exp $	*/
a56 2
	memset(&imsg, 0, sizeof(imsg));

a147 1
			memset(ifname, 0, sizeof(ifname));
a170 2
	memset(&imsg, 0, sizeof(imsg));

a311 2
	memset(&imsg, 0, sizeof(imsg));

a369 2
	memset(&imsg, 0, sizeof(imsg));

a408 2
	memset(&imsg, 0, sizeof(imsg));

a478 2
	memset(&imsg, 0, sizeof(imsg));

d481 2
a500 1
	memset(&fimsg, 0, sizeof(fimsg));
a506 1
	memset(&dimsg, 0, sizeof(dimsg));
@


1.72
log
@GC unused parameters now that ifname and rdomain are not used in
constructing imsgs.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.71 2015/02/06 06:47:29 krw Exp $	*/
d363 41
@


1.71
log
@matthew@@ points out that it's a bad idea to rely on the non-privileged,
network-facing process to properly fill out the interface name and
rdomain on which operations are to be performed.

Instead, always use the interface name and rdomain discovered before
forking and dropping privs. Lets all the imsg structs to drop a
couple of members.

ok matthew@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.70 2015/01/31 03:13:04 krw Exp $	*/
d52 1
a52 1
flush_routes(char *ifname, int rdomain)
d168 2
a169 2
add_route(int rdomain, struct in_addr dest, struct in_addr netmask,
    struct in_addr gateway, int addrs, int flags)
d281 1
a281 1
delete_addresses(char *ifname, int rdomain)
d300 1
a300 1
		delete_address(ifi->name, ifi->rdomain, addr);
d312 1
a312 1
delete_address(char *ifname, int rdomain, struct in_addr addr)
d372 1
a372 2
add_address(char *ifname, int rdomain, struct in_addr addr,
    struct in_addr mask)
d484 1
a484 1
resolv_conf_priority(int domain)
d516 1
a516 1
	m_rtmsg.m_rtm.rtm_tableid = domain;
@


1.70
log
@Always free(buf) if errmsg is set while trying to flush routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.69 2015/01/30 14:14:53 krw Exp $	*/
d36 1
a36 1
void	delete_route(int, int, struct rt_msghdr *);
a58 2
	strlcpy(imsg.ifname, ifname, sizeof(imsg.ifname));
	imsg.rdomain = rdomain;
d88 1
a88 1
	mib[6] = imsg->rdomain;
d137 1
a137 1
			delete_route(s, imsg->rdomain, rtm);
d141 1
a141 1
				delete_route(s, imsg->rdomain, rtm);
d154 3
a156 3
			    rtm->rtm_tableid == imsg->rdomain &&
			    strcmp(imsg->ifname, ifname) == 0)
				delete_route(s, imsg->rdomain, rtm);
a175 1
	imsg.rdomain = rdomain;
d208 1
a208 1
	rtm.rtm_tableid = imsg->rdomain;
a321 2
	strlcpy(imsg.ifname, ifname, sizeof(imsg.ifname));
	imsg.rdomain = rdomain;
d347 1
a347 2
	strncpy(ifaliasreq.ifra_name, imsg->ifname,
	    sizeof(ifaliasreq.ifra_name));
a382 2
	strlcpy(imsg.ifname, ifname, sizeof(imsg.ifname));
	imsg.rdomain = rdomain;
d416 1
a416 2
	strncpy(ifaliasreq.ifra_name, imsg->ifname,
	    sizeof(ifaliasreq.ifra_name));
a451 2
	strlcpy(imsg.ifname, ifi->name, sizeof(imsg.ifname));
	imsg.rdomain = ifi->rdomain;
a472 1
	fimsg.rdomain = imsg->rdomain;
a479 2
	strlcpy(dimsg.ifname, imsg->ifname, sizeof(imsg->ifname));
	dimsg.rdomain = imsg->rdomain;
d657 1
a657 1
delete_route(int s, int rdomain, struct rt_msghdr *rtm)
d663 1
a663 1
	rtm->rtm_tableid = rdomain;
@


1.69
log
@Tweak error message to say 'realloc' since that's what's failing,
not 'malloc'.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.68 2014/10/27 13:36:21 krw Exp $	*/
a101 1
			free(buf);
a108 1
			free(buf);
d118 1
@


1.68
log
@Zap extraneous whitespace and a stuttered extra 'break;'.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.67 2014/07/14 18:16:27 miod Exp $	*/
d103 1
a103 1
			errmsg = "routes buf malloc:";
@


1.67
log
@Make sure to correctly exit the loop in priv_flush_routes() in case of
allocation failure; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.66 2014/07/09 15:16:38 krw Exp $	*/
d191 1
a191 1
 	flush_unpriv_ibuf("add_route");
d305 1
a305 1
 	}
@


1.66
log
@Print sizeof() value and size_t variable with %zu rather than %zd.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.65 2014/05/05 18:02:49 krw Exp $	*/
d104 1
a104 1
			continue;
d141 1
a141 1
			break;;
@


1.65
log
@Zap trailing whitespace. Started by pointed comments from andre@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.64 2014/02/13 00:24:13 krw Exp $	*/
d614 1
a614 1
		warning("creating route label: label too long (%d vs %zd)", len,
@


1.64
log
@Hard looping on EAGAIN is bad. Just fall out to outer event loop
when EAGAIN is encountered while trying to flush messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.63 2014/02/09 20:45:56 krw Exp $	*/
d220 1
a220 1
	
d233 1
a233 1
	
d536 1
a536 1
	
@


1.63
log
@Don't use imsg_flush(), roll a local flush_unpriv_ibuf() that loops
on EAGAIN, sets quit to INTERNALSIG on errors (unless quit is already
set to something else), and prints a consistant error message when
errors other than EPIPE and end of file are encountered.

Fixes failure to write resolv.conf when -L is used, and makes
add_address() and add_route() also wait until imsg is in pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.62 2014/02/09 20:23:22 krw Exp $	*/
d695 1
a695 1
				continue;
@


1.62
log
@Nuke a couple of extraneous blank lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.61 2014/02/09 20:08:25 krw Exp $	*/
d68 1
a68 4
	/* Do flush to maximize chances of cleaning up routes on exit. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1)
		warning("flush_routes: imsg_flush: %s", strerror(errno));
d190 2
d335 1
a335 4
	/* Do flush to quickly kill previous dhclient, if any. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1 && errno != EPIPE)
		warning("delete_address: imsg_flush: %s", strerror(errno));
d399 2
d472 1
a472 4
	/* Do flush so cleanup message gets through immediately. */
	rslt = imsg_flush(unpriv_ibuf);
	if (rslt == -1 && errno != EPIPE)
		warning("sendhup: imsg_flush: %s", strerror(errno));
d687 17
@


1.61
log
@Use correct function name in error message. 'cleanup' was renamed
'sendhup' a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.60 2014/01/20 02:54:07 deraadt Exp $	*/
a190 1

a400 1

@


1.60
log
@%d cleanups, to other formats; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.59 2013/12/08 22:49:02 krw Exp $	*/
d474 1
a474 1
		warning("cleanup: imsg_compose: %s", strerror(errno));
d479 1
a479 1
		warning("cleanup: imsg_flush: %s", strerror(errno));
@


1.59
log
@Reduce in_addr memcpy() dances by simply using assignments where the source
variable has been copied to [cm]alloc'ed memory and thus properly aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.58 2013/12/05 21:32:59 krw Exp $	*/
d682 1
a682 1
	int rlen;
d693 1
a693 1
		error("short RTM_DELETE write (%d)\n", rlen);
@


1.58
log
@Use destination size as size of memcpy(). Use <in_addr> rather than
<in_addr>.s_addr to shorten code.

ok deraadt@@ matthew@@ as part of larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.57 2013/12/04 19:39:50 krw Exp $	*/
a302 1
		memset(&addr, 0, sizeof(addr));
@


1.57
log
@More memcpy() stylistic repairs and size checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.56 2013/08/17 14:50:05 krw Exp $	*/
d304 2
a305 3
		memcpy(&addr,
		    &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr,
		    sizeof(in_addr_t));
d443 1
a443 1
	memcpy(&in->sin_addr.s_addr, &imsg->mask, sizeof(in->sin_addr.s_addr));
@


1.56
log
@Do not create a route to the bound address via 127.0.0.1. Our stack
should be able to correctly short-circuit packet routing to local
addresses without this. Requested by many over the years, most
recently chrisz@@.

Get it in early to see if anything does break.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.55 2013/07/05 22:13:10 krw Exp $	*/
d444 1
a444 1
	memcpy(&in->sin_addr.s_addr, &imsg->mask, sizeof(imsg->mask));
@


1.55
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.54 2013/06/09 22:39:51 krw Exp $	*/
a383 1
 *	route -q <rdomain> add <addr> 127.0.0.1
a411 1
	struct imsg_add_route rimsg;
a452 11

	/*
	 * Add the 127.0.0.1 route for the specified address.
	 */
	memset(&rimsg, 0, sizeof(rimsg));
	rimsg.dest.s_addr = imsg->addr.s_addr;
	rimsg.gateway.s_addr = inet_addr("127.0.0.1");
	rimsg.addrs = RTA_DST | RTA_GATEWAY;
	rimsg.flags = RTF_GATEWAY | RTF_STATIC;

	priv_add_route(&rimsg);
@


1.54
log
@Make route adding interface more flexible by passing flags to be
used rather than deducing them. Use priv_add_route() to add
the 127.0.0.1 address when adding an address.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.53 2013/06/09 17:31:54 krw Exp $	*/
d46 1
a46 1
 * Do equivalent of 
d158 1
a158 1
			    sa_in && 
d392 1
a392 1
 
d402 1
a402 1
 
@


1.53
log
@Fix/clarify some comments. do memset()'s only when variable is going
to be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.52 2013/06/09 16:21:50 krw Exp $	*/
d175 1
a175 1
    struct in_addr gateway, int addrs)
d187 1
d217 2
a229 1
		rtm.rtm_addrs |= RTA_DST;
a242 2
		rtm.rtm_flags |= RTF_GATEWAY | RTF_STATIC;
		rtm.rtm_addrs |= RTA_GATEWAY;
a255 1
		rtm.rtm_addrs |= RTA_NETMASK;
d413 1
a414 4
	struct rt_msghdr rtm;
	struct sockaddr_in dest, gateway;
	struct sockaddr_rtlabel label;
	struct iovec iov[4];
d416 1
a416 1
	int s, i, iovcnt = 0;
d459 5
d465 1
a465 67
	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		error("Routing Socket open failed: %s", strerror(errno));

	/* Build RTM header */

	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_ADD;
	rtm.rtm_tableid = imsg->rdomain;
	rtm.rtm_priority = RTP_NONE;
	rtm.rtm_msglen = sizeof(rtm);

	iov[iovcnt].iov_base = &rtm;
	iov[iovcnt++].iov_len = sizeof(rtm);
	
	/* Set destination address */

	memset(&dest, 0, sizeof(dest));

	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = imsg->addr.s_addr;

	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);

	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
	
	/* Set gateway address */

	memset(&gateway, 0, sizeof(gateway));

	gateway.sin_len = sizeof(gateway);
	gateway.sin_family = AF_INET;
	gateway.sin_addr.s_addr = inet_addr("127.0.0.1");

	rtm.rtm_flags |= RTF_GATEWAY;
	rtm.rtm_addrs |= RTA_GATEWAY;
	rtm.rtm_msglen += sizeof(gateway);

	iov[iovcnt].iov_base = &gateway;
	iov[iovcnt++].iov_len = sizeof(gateway);

	/* Add our label so we can identify the route as our creation. */
	if (create_route_label(&label) == 0) {
		rtm.rtm_addrs |= RTA_LABEL;
		rtm.rtm_msglen += sizeof(label);
		iov[iovcnt].iov_base = &label;
		iov[iovcnt++].iov_len = sizeof(label);
	}

	/* Check for EEXIST since other dhclient may not be done. */
	for (i = 0; i < 5; i++) {
		if (writev(s, iov, iovcnt) != -1)
			break;
		if (errno == ENETUNREACH) {
			/* Not our responsibility to ensure 127/8 exists. */
			break;
		} else if (errno != EEXIST)
			error("failed to add 127.0.0.1 route: %s",
			    strerror(errno));
		sleep(1);
	}

	close(s);
@


1.52
log
@Re-apply static route and classless static route support -- this time
passing the correct destination for the default route, '0.0.0.0', rather
than the new lease address.

Populating egress group works this time.

Problem found the hard way by Chris Smith.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.51 2013/06/09 15:06:34 krw Exp $	*/
a172 12
/*
 * [priv_]add_default_route is the equivalent of
 *
 *	route -q $rdomain -n flush -inet -iface $interface
 *
 * and one of
 *
 *	route -q $rdomain add default -iface $router
 * 	route -q $rdomain add default $router
 *
 * depending on the contents of the gateway parameter.
 */
d220 2
a221 3
	/* Set destination address. */

	memset(&dest, 0, sizeof(dest));
a222 1
	if (imsg->addrs & RTA_DST) {
d234 2
a235 4
	/*
	 * Set gateway address if and only if non-zero addr supplied. A
	 * gateway address of 0 implies '-iface'.
	 */
a236 2
	memset(&gateway, 0, sizeof(gateway));
	if (imsg->addrs & RTA_GATEWAY) {
d249 2
a250 2
	/* Add netmask. */
	memset(&mask, 0, sizeof(mask));
a251 1
	if (imsg->addrs & RTA_NETMASK) {
@


1.51
log
@Re-apply route adding code refactoring -- it wasn't the problem that
broke populating the egress group.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.50 2013/06/09 00:30:06 krw Exp $	*/
d232 1
a232 1
	/* Set destination address of all zeros. */
d236 4
a239 2
	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
d241 2
a242 2
	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);
d244 3
a246 2
	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
d254 1
a254 1
	if ((imsg->addrs & RTA_GATEWAY) != 0) {
d267 1
a267 1
	/* Add netmask of 0. */
d270 4
a273 3
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = imsg->netmask.s_addr;
d275 2
a276 2
	rtm.rtm_addrs |= RTA_NETMASK;
	rtm.rtm_msglen += sizeof(mask);
d278 3
a280 2
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);
@


1.50
log
@Backout static/classless route handling and default route refactoring
since the former relies on the latter and the latter breaks 'egress'
group populating.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.49 2013/06/04 21:04:53 krw Exp $	*/
d186 2
a187 1
add_default_route(int rdomain, struct in_addr addr, struct in_addr gateway)
d189 2
a190 2
	struct imsg_add_default_route	 imsg;
	int				 rslt;
d195 1
a195 1
	imsg.addr = addr;
d197 2
d200 1
a200 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_DEFAULT_ROUTE, 0, 0, -1,
d204 1
a204 1
		warning("add_default_route: imsg_compose: %s", strerror(errno));
d208 1
a208 1
priv_add_default_route(struct imsg_add_default_route *imsg)
a215 4
	/*
	 * Add a default route via the specified address.
	 */

d251 1
a251 1
	if (bcmp(&imsg->gateway, &imsg->addr, sizeof(imsg->addr)) != 0) {
d269 1
@


1.49
log
@Add support for static routes option (33) and classless static
routes option (121).

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.48 2013/06/01 16:26:07 krw Exp $	*/
d186 1
a186 2
add_route(int rdomain, struct in_addr dest, struct in_addr netmask,
    struct in_addr gateway, int addrs)
d188 2
a189 2
	struct imsg_add_route	 imsg;
	int			 rslt;
d194 1
a194 1
	imsg.dest = dest;
a195 2
	imsg.netmask = netmask;
	imsg.addrs = addrs;
d197 1
a197 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_ROUTE, 0, 0, -1,
d201 1
a201 1
		warning("add_route: imsg_compose: %s", strerror(errno));
d205 1
a205 1
priv_add_route(struct imsg_add_route *imsg)
d213 4
d233 1
a233 1
	/* Set destination address. */
d237 2
a238 4
	if (imsg->addrs & RTA_DST) {
		dest.sin_len = sizeof(dest);
		dest.sin_family = AF_INET;
		dest.sin_addr.s_addr = imsg->dest.s_addr;
d240 2
a241 2
		rtm.rtm_addrs |= RTA_DST;
		rtm.rtm_msglen += sizeof(dest);
d243 2
a244 3
		iov[iovcnt].iov_base = &dest;
		iov[iovcnt++].iov_len = sizeof(dest);
	}
d252 1
a252 1
	if (imsg->addrs & RTA_GATEWAY) {
d265 1
a265 1
	/* Add netmask. */
d268 2
a269 4
	if (imsg->addrs & RTA_NETMASK) {
		mask.sin_len = sizeof(mask);
		mask.sin_family = AF_INET;
		mask.sin_addr.s_addr = imsg->netmask.s_addr;
d271 2
a272 2
		rtm.rtm_addrs |= RTA_NETMASK;
		rtm.rtm_msglen += sizeof(mask);
d274 2
a275 3
		iov[iovcnt].iov_base = &mask;
		iov[iovcnt++].iov_len = sizeof(mask);
	}
@


1.48
log
@Refactor the default route adding code to use a general route adding
function that will be reused for future work.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.47 2013/03/30 16:10:01 krw Exp $	*/
d232 1
a232 1
	/* Set destination address of all zeros. */
d236 4
a239 2
	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
d241 2
a242 2
	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);
d244 3
a246 2
	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
d254 1
a254 1
	if ((imsg->addrs & RTA_GATEWAY) != 0) {
d267 1
a267 1
	/* Add netmask of 0. */
d270 4
a273 3
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = imsg->netmask.s_addr;
d275 2
a276 2
	rtm.rtm_addrs |= RTA_NETMASK;
	rtm.rtm_msglen += sizeof(mask);
d278 3
a280 2
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);
@


1.47
log
@Since deleting all the addresses on an interface removes all the
relevant entries from the arp cache, don't bother asking for/processing
arp entries in the route dumps. Thus allowing use of NET_RT_FLAGS
with RTF_GATEWAY and AF_INET, to ask for only the routes dhclient
wants to expunge rather than all routes in existance.

Greatly shrinks and simplifies the code. No intentional functional
change. Tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.46 2013/03/24 12:53:20 krw Exp $	*/
d186 2
a187 1
add_default_route(int rdomain, struct in_addr addr, struct in_addr gateway)
d189 2
a190 2
	struct imsg_add_default_route	 imsg;
	int				 rslt;
d195 1
a195 1
	imsg.addr = addr;
d197 2
d200 1
a200 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_ADD_DEFAULT_ROUTE, 0, 0, -1,
d204 1
a204 1
		warning("add_default_route: imsg_compose: %s", strerror(errno));
d208 1
a208 1
priv_add_default_route(struct imsg_add_default_route *imsg)
a215 4
	/*
	 * Add a default route via the specified address.
	 */

d251 1
a251 1
	if (bcmp(&imsg->gateway, &imsg->addr, sizeof(imsg->addr)) != 0) {
d269 1
@


1.46
log
@Simplify logic when processing route dump by using a helper function
delete_route(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2013/03/21 04:43:17 deraadt Exp $	*/
d52 1
a52 1
flush_routes_and_arp_cache(char *ifname, int rdomain)
d66 1
a66 2
		warning("flush_routes_and_arp_cache: imsg_compose: %s",
		    strerror(errno));
d71 1
a71 2
		warning("flush_routes_and_arp_cache: imsg_flush: %s",
		    strerror(errno));
d75 1
a75 1
priv_flush_routes_and_arp_cache(struct imsg_flush_routes *imsg)
a82 2
	struct sockaddr *sa;
	struct sockaddr_dl *sdl;
d90 3
a92 3
	mib[3] = 0;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
a134 4
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		if (sa->sa_family == AF_KEY || sa->sa_family == AF_INET6)
			continue;  /* Don't flush SPD or INET6 routes */

d138 2
d144 1
a144 1
			continue;
d148 1
a148 1
			continue;
d151 1
a151 3
			/* Never delete routes labelled by another dhclient. */
			continue;
		default:
d153 3
a155 32
		}

		if (rtm->rtm_flags & RTF_LLINFO) {
			if (rtm->rtm_flags & RTF_GATEWAY)
				continue;
			if (rtm->rtm_flags & RTF_PERMANENT_ARP)
				continue;
			sdl = (struct sockaddr_dl *)rti_info[RTAX_GATEWAY];
			if (sdl == NULL)
				continue;

			/* XXXX Check for AF_INET too? (arp ask for them) */
			/* XXXX Need 'retry' for proxy entries? (arp does) */

			if (sdl->sdl_family == AF_LINK) {
				switch (sdl->sdl_type) {
				case IFT_ETHER:
				case IFT_FDDI:
				case IFT_ISO88023:
				case IFT_ISO88024:
				case IFT_ISO88025:
				case IFT_CARP:
					delete_route(s, imsg->rdomain, rtm);
					break;
				default:
					break;
				}
			}
			continue;
		}

		if (rtm->rtm_flags & RTF_GATEWAY) {
d157 2
a158 4
			if (if_indextoname(rtm->rtm_index, ifname) == NULL)
				continue;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (sa_in && 
d161 1
a161 1
			    strcmp(imsg->ifname, ifname) == 0) {
d163 3
a165 2
				continue;
			}
d588 1
a588 1
	priv_flush_routes_and_arp_cache(&fimsg);
@


1.45
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.44 2013/03/13 16:28:05 weerd Exp $	*/
d36 1
d89 1
a89 1
	int s, seqno = 0, rlen;
d149 2
a150 1
			goto delete;
d153 1
a153 1
				goto delete;
d183 2
a184 2
					/* Delete it. */
					goto delete;
d200 4
a203 2
			    strcmp(imsg->ifname, ifname) == 0)
				goto delete;
a204 16

		continue;

delete:
		rtm->rtm_type = RTM_DELETE;
		rtm->rtm_seq = seqno;
		rtm->rtm_tableid = imsg->rdomain;

		rlen = write(s, next, rtm->rtm_msglen);
		if (rlen == -1) {
			if (errno != ESRCH)
				error("RTM_DELETE write: %s", strerror(errno));
		} else if (rlen < (int)rtm->rtm_msglen)
			error("short RTM_DELETE write (%d)\n", rlen);

		seqno++;
d808 18
@


1.44
log
@Make sure dhclient doesn't delete IPv6 routes.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.43 2013/03/11 16:01:02 krw Exp $	*/
d82 1
a82 1
	char *lim, *buf, *next, *errmsg;
d88 1
a88 1
	int s, seqno = 0, rlen, retry;
d98 1
a98 7
	buf = NULL;
	retry = 0;
	do {
		retry++;
		errmsg = NULL;
		if (buf)
			free(buf);
d101 1
a101 1
			continue;
d103 2
a104 1
		if (needed == 0)
d106 3
a108 1
		if ((buf = malloc(needed)) == NULL) {
d112 1
d114 3
d118 1
d120 2
a121 1
	} while (retry < 10 && errmsg != NULL);
d124 2
a125 2
		warning("route cleanup failed - %s %s (%d retries, msize=%zu)",
		    errmsg, strerror(errno), retry, needed);
@


1.43
log
@When binding a lease, check for and clear out any 'zombie' routes
left behind by dead dhclients. i.e. dhclients that no longer respond
to 'kill(pid, 0)'.

As a result, no need to handle the 127.0.0.1 route separately when
deleting an interface.

Appears to fix in passing a problem with routes vs link addresses
that sthen@@ was seeing.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2013/03/08 12:25:15 krw Exp $	*/
d136 2
a137 2
		if (sa->sa_family == AF_KEY)
			continue;  /* Don't flush SPD */
@


1.42
log
@Consolidate parsing of rtm address lists. Use RTAX_GATEWAY entry
to get ARP sockaddr_dl info, rather than re-parsing manually.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.41 2013/03/07 13:23:27 krw Exp $	*/
d60 1
d146 4
a150 1
		case ROUTE_LABEL_DHCLIENT_DEAD:
a379 1
 *	route -q <rdomain> delete <addr> 127.0.0.1
a410 3
	struct rt_msghdr rtm;
	struct sockaddr_in dest, gateway;
	struct iovec iov[3];
d412 1
a412 1
	int s, iovcnt = 0;
a439 55

	/*
	 * Delete the 127.0.0.1 route for the specified address.
	 */

	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
		error("Routing Socket open failed: %s", strerror(errno));

	/* Build RTM header */

	memset(&rtm, 0, sizeof(rtm));

	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_type = RTM_DELETE;
	rtm.rtm_tableid = imsg->rdomain;
	rtm.rtm_priority = RTP_NONE;
	rtm.rtm_msglen = sizeof(rtm);

	iov[iovcnt].iov_base = &rtm;
	iov[iovcnt++].iov_len = sizeof(rtm);
	
	/* Set destination address */

	memset(&dest, 0, sizeof(dest));

	dest.sin_len = sizeof(dest);
	dest.sin_family = AF_INET;
	dest.sin_addr.s_addr = imsg->addr.s_addr;

	rtm.rtm_addrs |= RTA_DST;
	rtm.rtm_msglen += sizeof(dest);

	iov[iovcnt].iov_base = &dest;
	iov[iovcnt++].iov_len = sizeof(dest);
	
	/* Set gateway address */

	memset(&gateway, 0, sizeof(gateway));

	gateway.sin_len = sizeof(gateway);
	gateway.sin_family = AF_INET;
	gateway.sin_addr.s_addr = inet_addr("127.0.0.1");

	rtm.rtm_flags |= RTF_GATEWAY;
	rtm.rtm_addrs |= RTA_GATEWAY;
	rtm.rtm_msglen += sizeof(gateway);

	iov[iovcnt].iov_base = &gateway;
	iov[iovcnt++].iov_len = sizeof(gateway);

	/* ESRCH means the route does not exist to delete. */
	if ((writev(s, iov, iovcnt) == -1) && (errno != ESRCH))
		error("failed to delete 127.0.0.1: %s", strerror(errno));

	close(s);
d634 1
@


1.41
log
@Refactor code around route label creation and checking to make it easier
to read. No functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.40 2013/02/28 21:00:53 krw Exp $	*/
d35 1
a85 1
	struct sockaddr_inarp *sin;
d87 1
a87 1
	int s, seqno = 0, rlen, retry, i;
a127 3
#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

d138 1
a138 10
		memset(rti_info, 0, sizeof(rti_info));
		for (i = 0; i < RTAX_MAX; i++) {
			if (rtm->rtm_addrs & (1 << i)) {
				rti_info[i] = sa;
				sa = (struct sockaddr *)((char *)(sa) +
				    ROUNDUP(sa->sa_len));
			}
		}

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
d159 3
a165 4
			sin = (struct sockaddr_inarp *)(sa);
			sdl = (struct sockaddr_dl *)(ROUNDUP(sin->sin_len) +
			   (char *)sin);

a709 1
	struct sockaddr *sa;
d715 1
a715 1
	int i, s, rslt, iovcnt = 0;
d786 1
a786 9
	sa = (struct sockaddr *)((char *)&m_rtmsg + m_rtmsg.m_rtm.rtm_hdrlen);
	memset(rti_info, 0, sizeof(rti_info));
	for (i = 0; i < RTAX_MAX; i++) {
		if (m_rtmsg.m_rtm.rtm_addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		}
	}
d850 21
@


1.40
log
@Try 10 times to obtain the routing table via sysctl(), and if it
can't be done just abandon attempt to clean up the routing and arp
tables and carry on. Code adapted from itojun's route6d.c.

May address problem reported on misc@@ by Marc Peters.

Best we can do for now.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.39 2013/02/24 01:23:19 krw Exp $	*/
d29 1
d33 10
d80 1
a80 1
	char *lim, *buf, *next, *routelabel, *errmsg;
a127 3
	if (asprintf(&routelabel, "DHCLIENT %d", (int)getpid()) == -1)
		error("recreating route label: %s", strerror(errno));

d153 2
a154 1
		if (sa_rl) {
d156 4
a159 3
			if (strcmp(routelabel, sa_rl->sr_label) == 0)
				goto delete;

d161 3
a163 3
			if (strlen(sa_rl->sr_label) > 8 &&
			    strncmp("DHCLIENT ", sa_rl->sr_label, 9) == 0)
				continue;
a226 1
	free(routelabel);
d267 1
a267 1
	int s, len, i, iovcnt = 0;
d334 6
a339 16
	memset(&label, 0, sizeof(label));
	label.sr_len = sizeof(label);
	label.sr_family = AF_UNSPEC;
	len = snprintf(label.sr_label, sizeof(label.sr_label), "DHCLIENT %d",
	    getpid());
	if (len == -1)
		error("writing label for default route: %s", strerror(errno));
	if (len >= sizeof(label.sr_label))
		error("label for default route too long (%zd)",
		    sizeof(label.sr_label));

	rtm.rtm_addrs |= RTA_LABEL;
	rtm.rtm_msglen += sizeof(label);

	iov[iovcnt].iov_base = &label;
	iov[iovcnt++].iov_len = sizeof(label);
d549 1
a549 1
	int s, len, i, iovcnt = 0;
d639 6
a644 17
	memset(&label, 0, sizeof(label));

	label.sr_len = sizeof(label);
	label.sr_family = AF_UNSPEC;
	len = snprintf(label.sr_label, sizeof(label.sr_label), "DHCLIENT %d",
	    getpid());
	if (len == -1)
		error("writing label for host route: %s", strerror(errno));
	if (len >= sizeof(label.sr_label))
		error("label for host route too long (%zd)",
		    sizeof(label.sr_label));

	rtm.rtm_addrs |= RTA_LABEL;
	rtm.rtm_msglen += sizeof(label);

	iov[iovcnt].iov_base = &label;
	iov[iovcnt++].iov_len = sizeof(label);
a722 1
	char *routelabel;
d811 2
a812 7
	if (sa_rl) {
		if (asprintf(&routelabel, "DHCLIENT %d", (int)getpid()) == -1)
			error("recreating route label: %s", strerror(errno));
		if (strcmp(routelabel, sa_rl->sr_label) == 0)
			rslt = 1;
		free(routelabel);
	}
d817 55
@


1.39
log
@Don't log a complaint that a non-existant default route could not be
deleted. Be happy that the goal of no default route has been achieved.

Part of the cleaning up the logs prodding by deraadt@@.

ok guenther@@. error in first version pointed out by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.38 2013/02/21 14:10:22 krw Exp $	*/
d69 1
a69 1
	char *lim, *buf, *next, *routelabel;
d76 1
a76 1
	int s, seqno = 0, rlen, i;
d86 12
a97 2
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
		if (imsg->rdomain != 0 && errno == EINVAL)
d99 13
a111 1
		error("sysctl size of routes: %s", strerror(errno));
a112 9

	if (needed == 0)
		return;

	if ((buf = malloc(needed)) == NULL)
		error("no memory for sysctl routes");

	if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1)
		error("sysctl retrieval of routes: %s", strerror(errno));
@


1.38
log
@Use imsg_flush() to force delivery of IMSG_DELETE_ADDRESS to
privileged process. This ensures a quicker exit of any previous
copy of dhclient.

Prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.37 2013/02/18 22:10:04 krw Exp $	*/
d769 3
a771 1
		warning("RTM_GET of default route: %s", strerror(errno));
@


1.37
log
@Don't delete permanent arp cache entries when clearing the arp
cache. Issue pointed out by Don Nasco.

Deemed the correct thing to do by sthne@@, phessler@@ and chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.36 2013/02/18 15:57:08 krw Exp $	*/
a395 1

d398 5
@


1.36
log
@Rework log messages to be more useful. Rename
IMGS_CLEANUP/imsg_cleanup/cleanup to IMSG_HUP/imsg_hup/sendhup to
more accurately reflect intent of causing the privileged process
to initiate restart.

There should now be one and only one message logged at termination
or restart, logged by the process initiating the termination or
restart.

As part of fixing this, remove duplicate cleanup attempts and exit
after sending IMSG_HUP. These make logged messages more consistant and
fix issues with incorrect cleanups.

More prodding from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.35 2013/02/17 17:36:31 krw Exp $	*/
d145 2
@


1.35
log
@Using the value SIGQUIT to cause the dispatch loops to exit produced
universal revulsion and no little confusion.  #define our own value,
currently INT_MAX, which should not overlap any likely signal value.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.34 2013/02/17 17:04:41 krw Exp $	*/
d658 1
a658 1
 * [priv_]cleanup removes dhclient installed routes and address.
d661 1
a661 1
cleanup(struct client_lease *active)
d663 1
a663 1
	struct imsg_cleanup imsg;
d673 1
a673 1
	rslt = imsg_compose(unpriv_ibuf, IMSG_CLEANUP, 0, 0, -1,
d684 3
d688 1
a688 1
priv_cleanup(struct imsg_cleanup *imsg)
@


1.34
log
@Suppress some pointless debugging message:

1) If the pipe to the priv process is closed while waiting for
something to happen in the non-priv dispatch() loop, assume the
priv process issued an error message and exit without additional
verbiage.

2) Ditto if the pipe to the priv process is closed when the flush
of IMSG_CLEANUP is attempted.

3) No need to report when SIOCDIFADDR fails because the address is
already gone.

Start to ensure the priv process always issues a useful message
before exiting by noting when it restarts due to the LLADDR having
changed.

Prodded by deraadt@@ to clean this up.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.33 2013/02/17 15:48:03 krw Exp $	*/
d536 1
a536 1
		quit = INT_MAX;
@


1.33
log
@Kill a magic number. 0 -> RTP_NONE for priority in constructing routing
messages. Prodded by otto@@. RTP_NONE's home pointed out by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2013/02/17 15:08:13 krw Exp $	*/
d427 3
a429 2
		warning("SIOCDIFADDR failed (%s): %s", inet_ntoa(imsg->addr),
		    strerror(errno));
d680 1
a680 1
	if (rslt == -1)
@


1.32
log
@dhclient-script did 'route -q $rdomain add $new_ip_address 127.0.0.1'.
i.e.  did not complain (-q) if 127/8 was unreachabel from $rdomain.
So don't pollute the log with new warnings about being unable to
create the route. Just complain if a truly unexpected error occurs.

Noted by Andreas Bartelt.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2013/02/15 01:20:39 krw Exp $	*/
d259 1
a259 1
	rtm.rtm_priority = 0;
d449 1
a449 1
	rtm.rtm_priority = 0;
d584 1
a584 1
	rtm.rtm_priority = 0;
@


1.31
log
@Don't leak routing socket fd if getting the default route fails.
e.g. with ESRCH.

Ask for default route in correct routing domain.

While here, tweak variable names to be consistant with other
functions using a routing socket.

Likely the cause of the periodic failures reported by Andreas Bartelt
via bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2013/02/03 15:10:36 krw Exp $	*/
a641 1
		/* XXX Why do some systems get ENETUNREACH? */
d643 1
a643 2
			note("failed to add 127.0.0.1 route: %s",
			    strerror(errno));
@


1.30
log
@Use RTM_GET rather than the sysctl/scan all routes dance to obtain
the current default route. Much less work for the routing system.

Suggested by claudio@@. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2013/02/01 01:33:44 krw Exp $	*/
d721 1
a721 1
	int i, fd, rslt, iovcnt = 0;
d725 2
a726 2
	fd = socket(PF_ROUTE, SOCK_RAW, AF_INET);
	if (fd == -1) {
d740 1
d760 3
a762 3
	if (writev(fd, iov, iovcnt) == -1) {
		warning("default route write: %s", strerror(errno));
		return (0);
d768 1
a768 1
		len = read(fd, &m_rtmsg, sizeof(m_rtmsg));
d810 1
a810 1
	close(fd);
@


1.29
log
@Write out resolv.conf only if the default route is under the control
of the process binding the lease. Re-check the default route whenever
a routing message arrives that might mean the default route has
changed, and write out resolv.conf if appropriate.

Reduces the chances that the name servers in resolv.conf are
unreachable.

Problem most eloquently explained, and solution suggested by beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2013/01/22 06:02:52 krw Exp $	*/
d708 5
d714 1
a714 4
	int mib[7];
	size_t needed;
	char *lim, *buf, *next, *routelabel;
	struct rt_msghdr *rtm;
d716 1
a716 1
	struct sockaddr_in *sa_in;
d718 12
a729 1
	int i, priority, mypriority;
d731 14
a744 7
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_FLAGS;
	mib[5] = RTF_GATEWAY;
	mib[6] = domain;
d746 1
a746 5
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1) {
		if (domain != 0 && errno == EINVAL)
			return (1);
		error("sysctl size of routes: %s", strerror(errno));
	}
d748 3
a750 2
	if (needed == 0)
		return (1);
d752 4
a755 2
	if ((buf = malloc(needed)) == NULL)
		error("no memory for sysctl routes");
d757 1
a757 2
	if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1)
		error("sysctl retrieval of routes: %s", strerror(errno));
d759 4
a762 2
	if (asprintf(&routelabel, "DHCLIENT %d", (int)getpid()) == -1)
		error("recreating route label: %s", strerror(errno));
d764 1
a764 2
#define ROUNDUP(a) \
    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
d766 10
a775 7
	priority = mypriority = INT_MAX;
	lim = buf + needed;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		if ((rtm->rtm_flags & RTF_UP) == 0)
d777 7
a783 10
		if (rtm->rtm_flags & RTF_REJECT)
			continue;

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		memset(rti_info, 0, sizeof(rti_info));
		for (i = 0; i < RTAX_MAX; i++) {
			if (rtm->rtm_addrs & (1 << i)) {
				rti_info[i] = sa;
				sa = (struct sockaddr *)((char *)(sa) +
				    ROUNDUP(sa->sa_len));
d785 1
d787 1
d789 9
a797 6
		sa_in = (struct sockaddr_in *)rti_info[RTAX_DST];
		if (sa_in == NULL || sa_in->sin_addr.s_addr != INADDR_ANY)
			continue;
		sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
		if (sa_in == NULL || sa_in->sin_addr.s_addr != INADDR_ANY)
			continue;
d799 7
a805 6
		sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
		if (sa_rl && strcmp(routelabel, sa_rl->sr_label) == 0) {
			if (rtm->rtm_priority < mypriority)
				mypriority = rtm->rtm_priority;
		} else if (rtm->rtm_priority < priority)
			priority = rtm->rtm_priority;
d808 3
a810 4
	free(buf);
	free(routelabel);

	return (mypriority < priority);
@


1.28
log
@Whitespace nit. Better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2013/01/17 23:41:07 krw Exp $	*/
d703 84
@


1.27
log
@Try harder to clear out default routes on the interface being
configured. Only exempt default routes labelled as being the
property of another dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2012/12/29 14:40:00 krw Exp $	*/
d89 1
a89 1
		error("could not get routes");
d96 1
a96 1
		error("malloc");
@


1.26
log
@Make HUP to either one of the processes cause a restart that will
have dhclient re-read dhclient.conf and get a new lease. Constrain
the filename passed to '-l' (alternate dhclient.lease.if location)
to be a regular file for the moment.

Original suggestion from phessler@@. Feedback from deraadt@@ and
espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2012/12/19 12:25:38 krw Exp $	*/
d39 1
a39 1
flush_routes_and_arp_cache(int rdomain)
d46 1
d65 1
d73 1
d131 9
a139 3
		if (rti_info[RTAX_LABEL]) {
			sa_rl = (struct sockaddr_rtlabel *)rti_info[RTAX_LABEL];
			if (strcmp(routelabel, sa_rl->sr_label))
d141 3
a143 1
		} else if (rtm->rtm_flags & RTF_LLINFO) {
d163 2
a165 2
				default:
					continue;
a167 1
		} else
d169 15
d185 1
@


1.25
log
@Don't attempt to delete an address that has already been deleted
by a new dhclient (or anyone else). Instead, use add_address(...,
INADDR_ANY, ...) to tell the privileged process that its active
address is gone. Thus the cleanup process doesn't try to delete it.

Eliminates extraneous log entries complaining that the address can't
be deleted. Narrows race window where old dhclient might delete the
address the new dhclient has just added.

Make rapid-fire starting of dhclient even more reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2012/12/17 22:52:59 krw Exp $	*/
d509 1
a509 1
		quit = 1;
@


1.24
log
@Don't daemonize until the RTM_NEWADDR message is received. Shuffle
things a bit so configuring the address and default route are done
last. This makes it much more likely that all the work is done when
the 'bound to ...' message is displayed.

Amoung other things fixes a problem with the install scripts, where
the first (hostname-associated) dhclient can exit so quickly the
interface doesn't yet have an address and a second (free-floating)
dhclient is therefore often run.

Noted by rpe@@, who also tested the fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2012/12/04 19:24:03 krw Exp $	*/
d505 7
@


1.23
log
@Eliminate hand-rolled pseudo-strerror() %m strangeness by replacing
all occurances of %m with strerror(errno). And then nuking do_percentm()
and related buffer shuffling.

Also simplify parse_warn() so it takes a simple char * of the error,
and thus rely on pointing to error location in input for details.

Makes sense to beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2012/12/03 22:36:16 krw Exp $	*/
d305 1
a305 1
		if (errno != EEXIST)
@


1.22
log
@Backout last. It breaks existing 'ifconfig down ; dhclient' usage.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2012/12/03 22:19:47 krw Exp $	*/
d51 2
a52 1
		warning("flush_routes_and_arp_cache: imsg_compose: %m");
d57 2
a58 1
		warning("flush_routes_and_arp_cache: imsg_flush: %m");
d96 1
a96 1
		error("sysctl retrieval of routes: %m");
d99 1
a99 1
		error("opening socket to flush routes: %m");
d102 1
a102 1
		error("recreating route label: %m");
d167 1
a167 1
				error("RTM_DELETE write: %m");
d207 1
a207 1
		warning("add_default_route: imsg_compose: %m");
d224 1
a224 1
		error("Routing Socket open failed: %m");
d290 1
a290 1
		error("writing label for default route: %m");
d306 2
a307 1
			error("failed to add default route: %m");
d324 1
a324 1
		error("delete_addresses getifaddrs: %m");
d370 1
a370 1
		warning("delete_address: imsg_compose: %m");
d388 1
a388 1
		error("socket open failed: %m");
d401 2
a402 1
		warning("SIOCDIFADDR failed (%s): %m", inet_ntoa(imsg->addr));
d414 1
a414 1
		error("Routing Socket open failed: %m");
d460 1
a460 1
		error("failed to delete 127.0.0.1: %m");
d492 1
a492 1
		warning("add_address: imsg_compose: %m");
d511 1
a511 1
		error("socket open failed: %m");
d532 2
a533 1
		warning("SIOCAIFADDR failed (%s): %m", inet_ntoa(imsg->addr));
d542 1
a542 1
		error("Routing Socket open failed: %m");
d594 1
a594 1
		error("writing label for host route: %m");
d611 2
a612 1
			note("failed to add 127.0.0.1 route: %m");
d615 2
a616 1
			error("failed to add 127.0.0.1 route: %m");
d644 1
a644 1
		warning("cleanup: imsg_compose: %m");
d649 1
a649 1
		warning("cleanup: imsg_flush: %m");
@


1.21
log
@Cleanup after a 'ifconfig down', but stick around so 'ifconfig up'
will get a new lease without having to restart dhclient. Also tweak
cleanup() to cancel any existing timeout, so one doesn't fire between
'down' and 'up'.

Makes sense to chris@@ beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2012/12/02 17:03:19 krw Exp $	*/
a626 2
	cancel_timeout();

d632 1
a632 1
		delete_address(ifi->name, ifi->rdomain, active->address);
@


1.20
log
@Try harder to cleanup when exiting. In particular catch signals
SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUS2 and cleanup before exiting
when getting them. Cleanup meaning removing routes and the interface
address added.

Tweaks and feedback from phessler@@, sthen@@, otto@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2012/11/23 15:25:47 krw Exp $	*/
d627 2
d634 1
a634 1
		imsg.addr = active->address;
@


1.19
log
@Use the libutil imsg framework rather than a hand-rolled local
version. This is the last hand-rolled imsg implementation I could
spot. Doesn't seem to break sparc64.

Suggested by chris@@, tweaks from brad@@ and reyk@@.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2012/11/17 10:39:24 krw Exp $	*/
d30 2
d614 49
@


1.18
log
@'deeleting' -> 'deleting' in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2012/11/16 14:59:36 krw Exp $	*/
d39 2
a40 14
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;

	hdr.code = IMSG_FLUSH_ROUTES;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + sizeof(rdomain);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);
d42 13
a54 1
	buf_close(privfd, buf);
d58 1
a58 1
priv_flush_routes_and_arp_cache(int rdomain)
d77 1
a77 1
	mib[6] = rdomain;
d80 1
a80 1
		if (rdomain != 0 && errno == EINVAL)
d158 1
a158 1
		rtm->rtm_tableid = rdomain;
d188 1
a188 2
add_default_route(int rdomain, struct in_addr addr,
    struct in_addr gateway)
d190 8
a197 24
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;

	hdr.code = IMSG_ADD_DEFAULT_ROUTE;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + sizeof(rdomain) +
	    sizeof(len) + sizeof(addr) +
	    sizeof(len) + sizeof(gateway);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);

	len = sizeof(addr);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, len);

	len = sizeof(gateway);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &gateway, len);
d199 5
a203 1
	buf_close(privfd, buf);
d207 1
a207 2
priv_add_default_route(int rdomain, struct in_addr addr,
    struct in_addr router)
d228 1
a228 1
	rtm.rtm_tableid = rdomain;
d254 1
a254 1
	if (bcmp(&router, &addr, sizeof(addr)) != 0) {
d257 1
a257 1
		gateway.sin_addr.s_addr = router.s_addr;
d349 4
a352 3
	size_t		 len;
	struct imsg_hdr	 hdr;
	struct buf	*buf;
d357 3
a359 20
	hdr.code = IMSG_DELETE_ADDRESS;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + strlen(ifname) +
	    sizeof(len) + sizeof(rdomain) +
	    sizeof(len) + sizeof(addr);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);

	len = sizeof(addr);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, len);
d361 5
a365 1
	buf_close(privfd, buf);
d369 1
a369 1
priv_delete_address(char *ifname, int rdomain, struct in_addr addr)
d386 2
a387 1
	strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d392 1
a392 1
	in->sin_addr.s_addr = addr.s_addr;
d396 1
a396 1
		warning("SIOCDIFADDR failed (%s): %m", inet_ntoa(addr));
d416 1
a416 1
	rtm.rtm_tableid = rdomain;
d429 1
a429 1
	dest.sin_addr.s_addr = addr.s_addr;
d469 4
a472 3
	struct buf	*buf;
	size_t		 len;
	struct imsg_hdr	 hdr;
d474 1
d477 7
a483 25
	hdr.code = IMSG_ADD_ADDRESS;
	hdr.len = sizeof(hdr) +
	    sizeof(len) + strlen(ifname) +
	    sizeof(len) + sizeof(rdomain) +
	    sizeof(len) + sizeof(addr) +
	    sizeof(len) + sizeof(mask);

	buf = buf_open(hdr.len);
	buf_add(buf, &hdr, sizeof(hdr));

	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

	len = sizeof(rdomain);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &rdomain, len);

	len = sizeof(addr);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, len);

	len = sizeof(mask);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &mask, len);
d485 2
a486 1
	buf_close(privfd, buf);
d490 1
a490 2
priv_add_address(char *ifname, int rdomain, struct in_addr addr,
    struct in_addr mask)
d508 2
a509 1
	strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d515 1
a515 1
	in->sin_addr.s_addr = addr.s_addr;
d521 1
a521 1
	memcpy(&in->sin_addr.s_addr, &mask, sizeof(mask));
d526 1
a526 1
		warning("SIOCAIFADDR failed (%s): %m", inet_ntoa(addr));
d543 1
a543 1
	rtm.rtm_tableid = rdomain;
d556 1
a556 1
	dest.sin_addr.s_addr = addr.s_addr;
@


1.17
log
@Add missing 'break;' so that IFT_ETHER, etc. routes are deleted as
intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2012/11/15 14:54:18 krw Exp $	*/
d367 1
a367 1
	/* Note the address we are deeleting for RTM_DELADDR filtering! */
@


1.16
log
@Shuffle #include's to use the majority idiom everywhere - i.e. use
dhcpd.h to pull in most sys/net/netinet/etc. .h file. Eliminate
superfluous #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2012/11/14 15:47:41 krw Exp $	*/
d148 1
a148 1
					;
@


1.15
log
@Remove useless _new_ and _old_ from various function names to make
them shorter and eliminate implications about what the function
does. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2012/11/08 21:32:55 krw Exp $	*/
d19 3
a22 3
#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
a26 1
#include <net/if.h>
a28 3

#include "dhcpd.h"
#include "privsep.h"
@


1.14
log
@Remove confusing extra address abstraction 'struct iaddr'. Just use
'in_addr'. Remove many double conversions and other perversions.
piaddr() replaced with inet_ntoa(). dhclient is extremely unlikely
to support anything but ipv4/dhcp without a complete rewrite.

Joint work with chris@@.

Positive feedback from deraadt@@ zinke@@ phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2012/11/08 16:40:21 krw Exp $	*/
d331 1
a331 1
delete_old_addresses(char *ifname, int rdomain)
d337 1
a337 1
		error("delete_old_addresses getifaddrs: %m");
d352 1
a352 1
		delete_old_address(ifi->name, ifi->rdomain, addr);
d359 1
a359 1
 * [priv_]delete_old_address is the equivalent of
d365 1
a365 1
delete_old_address(char *ifname, int rdomain, struct in_addr addr)
d399 1
a399 1
priv_delete_old_address(char *ifname, int rdomain, struct in_addr addr)
d489 1
a489 1
 * [priv_]add_new_address is the equivalent of
d495 1
a495 1
add_new_address(char *ifname, int rdomain, struct in_addr addr,
d534 1
a534 1
priv_add_new_address(char *ifname, int rdomain, struct in_addr addr,
@


1.13
log
@Close routing socket fd leak when deleting old address.

Spotted by zinke@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2012/11/07 15:40:13 krw Exp $	*/
d192 2
a193 2
add_default_route(int rdomain, struct iaddr addr,
    struct iaddr gateway)
d224 2
a225 2
priv_add_default_route(int rdomain, struct iaddr addr,
    struct iaddr router)
d275 1
a275 1
		gateway.sin_addr.s_addr = inet_addr(piaddr(router));
d333 1
a333 1
	struct iaddr addr;
a338 3
	if (sizeof(struct in_addr) > sizeof(addr.iabuf))
		error("king bula sez: len mismatch in delete_old_addresses");

d348 3
a350 3
		addr.len = sizeof(struct in_addr);
		memcpy(addr.iabuf,
		    &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr, addr.len);
d365 1
a365 1
delete_old_address(char *ifname, int rdomain, struct iaddr addr)
d371 2
a372 2
	/* Note the address we are deleting for RTM_DELADDR filtering! */
	iaddr_deleting = addr;
d399 1
a399 1
priv_delete_old_address(char *ifname, int rdomain, struct iaddr addr)
a404 1
	in_addr_t bozo;
d421 1
a421 3

	bozo = inet_addr(piaddr(addr));
	memcpy(&in->sin_addr.s_addr, &bozo, sizeof(bozo));
d425 1
a425 1
		warning("SIOCDIFADDR failed (%s): %m", piaddr(addr));
d458 1
a458 1
	dest.sin_addr.s_addr = inet_addr(piaddr(addr));
d495 2
a496 1
add_new_address(char *ifname, int rdomain, struct iaddr addr, in_addr_t mask)
d502 1
a502 1
	iaddr_adding = addr;
d534 2
a535 2
priv_add_new_address(char *ifname, int rdomain, struct iaddr addr,
    in_addr_t mask)
a542 1
	in_addr_t bozo;
d559 1
a559 2
	bozo = inet_addr(piaddr(addr));
	memcpy(&in->sin_addr.s_addr, &bozo, sizeof(bozo));
d570 1
a570 1
		warning("SIOCAIFADDR failed (%s): %m", piaddr(addr));
d600 1
a600 1
	dest.sin_addr.s_addr = inet_addr(piaddr(addr));
@


1.12
log
@Always memcpy() into/out of option data rather than hoping the char *
will be always be aligned. Don't pass around pointers into option
data - use variable that has the memcpy()'d data.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2012/11/07 15:20:28 krw Exp $	*/
d490 2
@


1.11
log
@Use memset() consistently rather than tossing in a few bzero()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2012/11/07 15:07:02 krw Exp $	*/
d499 1
a499 1
add_new_address(char *ifname, int rdomain, struct iaddr addr, in_addr_t *mask)
a500 1
	in_addr_t	 nomask;
d512 1
a512 1
	    sizeof(len) + sizeof(*mask);
d529 1
a529 1
	len = sizeof(*mask);
d531 1
a531 6
	if (mask)
		buf_add(buf, mask, len);
	else {
		memset(&nomask, 0, sizeof(nomask));
		buf_add(buf, &nomask, len);
	}
@


1.10
log
@Use memcpy() consistently rather than tossing in a few bcopy()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2012/11/07 14:47:30 krw Exp $	*/
d117 1
a117 1
		bzero(rti_info, sizeof(rti_info));
d242 1
a242 1
	bzero(&rtm, sizeof(rtm));
d255 1
a255 1
	bzero(&dest, sizeof(dest));
d271 1
a271 1
	bzero(&gateway, sizeof(gateway));
d286 1
a286 1
	bzero(&mask, sizeof(mask));
d298 1
a298 1
	bzero(&label, sizeof(label));
d350 1
a350 1
		bzero(&addr, sizeof(addr));
d419 1
a419 1
	bzero(&ifaliasreq, sizeof(ifaliasreq));
d447 1
a447 1
	bzero(&rtm, sizeof(rtm));
d460 1
a460 1
	bzero(&dest, sizeof(dest));
d474 1
a474 1
	bzero(&gateway, sizeof(gateway));
d535 1
a535 1
		bzero(&nomask, sizeof(nomask));
d562 1
a562 1
	bzero(&ifaliasreq, sizeof(ifaliasreq));
d594 1
a594 1
	bzero(&rtm, sizeof(rtm));
d607 1
a607 1
	bzero(&dest, sizeof(dest));
d621 1
a621 1
	bzero(&gateway, sizeof(gateway));
d635 1
a635 1
	bzero(&label, sizeof(label));
@


1.9
log
@Kill some annoying extra spaces. No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2012/11/05 03:49:16 krw Exp $	*/
d427 1
a427 1
	bcopy(&bozo, &in->sin_addr.s_addr, sizeof(bozo));
d570 1
a570 1
	bcopy(&bozo, &in->sin_addr.s_addr, sizeof(bozo));
d576 1
a576 1
	bcopy(&mask, &in->sin_addr.s_addr, sizeof(mask));
@


1.8
log
@Some systems give ENETUNREACH when trying to add the 'standard'
host route, a.k.a. 'route add w.x.y.z 127.0.0.1'. Since dhclient-script
ignored the failure, ignore it here too until it can be explained
or we stop creating these routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2012/11/04 03:36:39 krw Exp $	*/
d422 1
a422 1
	in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
d566 1
a566 1
	in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
d573 1
a573 1
	in = (struct sockaddr_in *) &ifaliasreq.ifra_mask;
@


1.7
log
@No need to pass interface name around when flushing routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2012/11/04 03:25:31 krw Exp $	*/
d657 5
a661 1
		if (errno != EEXIST)
@


1.6
log
@No need to pass interface name around when creating routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2012/11/03 01:59:31 krw Exp $	*/
d41 1
a41 1
flush_routes_and_arp_cache(char *ifname, int rdomain)
a48 1
	    sizeof(len) + strlen(ifname) +
a53 4
	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

d62 1
a62 1
priv_flush_routes_and_arp_cache(char *ifname, int rdomain)
@


1.5
log
@While this identical idiom caused problems when building an ifaliasreq
to *add* an address, here (building an ifaliasreq to delete an
address) it worked fine. But change it to the bcopy() dance that
works in the adding case just to be consistant until a sparc64/gcc
guru is cornered in a bar with a full keg of guiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2012/11/02 20:21:32 krw Exp $	*/
a78 5
	unsigned int ifi_index;

	ifi_index = if_nametoindex(ifname);
	if (ifi_index == 0)
		error("No interface index found for '%s'", ifname);
d197 1
a197 1
add_default_route(char *ifname, int rdomain, struct iaddr addr,
a205 1
	    sizeof(len) + strlen(ifname) +
a212 4
	len = strlen(ifname);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, ifname, len);

d229 1
a229 1
priv_add_default_route(char *ifname, int rdomain, struct iaddr addr,
@


1.4
log
@Avoid some misaligned access on sparc64 (at least) by bcopy()'ing
in_addr_t values into s_addr's rather than assigning them.

Possibly not the ideal solution, but at least dhclient will work
again on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2012/11/01 22:07:07 krw Exp $	*/
d423 1
d441 2
a442 1
	in->sin_addr.s_addr = inet_addr(piaddr(addr));
@


1.3
log
@KNF some leading spaces into tabs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2012/10/31 15:50:47 krw Exp $	*/
d565 1
d582 2
a583 1
	in->sin_addr.s_addr = inet_addr(piaddr(addr));
d589 1
a589 1
	in->sin_addr.s_addr = mask;
@


1.2
log
@Forcibly delete all existing ipv4 addresses from an interface when
binding a lease to that interface. This fixes issues sthen@@ found
with unexpectedly persistant addresses and failures of dhclient
when switching an interface repeatedly between different networks.

This crude but predictable behaviour may be toned down once it
is figured out what we want to do with mixed static/dynamic
configurations on an interface.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2012/10/30 16:41:28 krw Exp $	*/
d115 1
a115 1
        ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
d246 1
a246 1
        int s, len, i, iovcnt = 0;
d419 1
a419 1
        struct ifaliasreq ifaliasreq;
d423 2
a424 2
        struct sockaddr_in *in;
        int s, iovcnt = 0;
d433 2
a434 2
        bzero(&ifaliasreq, sizeof(ifaliasreq));
        strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d436 3
a438 3
        in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
        in->sin_family = AF_INET;
        in->sin_len = sizeof(ifaliasreq.ifra_addr);
d440 1
a440 1
        in->sin_addr.s_addr = inet_addr(piaddr(addr));
d443 1
a443 1
        if (ioctl(s, SIOCDIFADDR, &ifaliasreq) == -1) {
d559 1
a559 1
        struct ifaliasreq ifaliasreq;
d564 2
a565 2
        struct sockaddr_in *in;
        int s, len, i, iovcnt = 0;
d574 2
a575 2
        bzero(&ifaliasreq, sizeof(ifaliasreq));
        strncpy(ifaliasreq.ifra_name, ifname, sizeof(ifaliasreq.ifra_name));
d578 4
a581 4
        in = (struct sockaddr_in *) &ifaliasreq.ifra_addr;
        in->sin_family = AF_INET;
        in->sin_len = sizeof(ifaliasreq.ifra_addr);
        in->sin_addr.s_addr = inet_addr(piaddr(addr));
d584 4
a587 4
        in = (struct sockaddr_in *) &ifaliasreq.ifra_mask;
        in->sin_family = AF_INET;
        in->sin_len = sizeof(ifaliasreq.ifra_mask);
        in->sin_addr.s_addr = mask;
d591 1
a591 1
        if (ioctl(s, SIOCAIFADDR, &ifaliasreq) == -1)
@


1.1
log
@New file holding functions to perform direct interface and routing
maninpulations. Inspired by similar files in bgpd, dvmrpd, ldpd, etc.
Necessary for imminent nuking of dhclient-script.

Not linked into build at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 2
d340 34
@

