head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.2
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.29.0.8
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.10
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.12
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.8
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.14
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.12
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.10
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.8
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9;
locks; strict;
comment	@ * @;


1.39
date	2016.08.14.22.35.54;	author guenther;	state Exp;
branches;
next	1.38;
commitid	4P0Tx3s8wy9JSCHK;

1.38
date	2016.05.28.17.16.39;	author tb;	state Exp;
branches;
next	1.37;
commitid	G1remNROahxZqOpm;

1.37
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Cz19p5I1S6mVZIjV;

1.36
date	2015.11.18.15.36.32;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	6yINf3Dx8zVr6fjW;

1.35
date	2015.10.11.04.37.23;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	uXrcflBnaIcuJEsu;

1.34
date	2015.03.20.01.53.05;	author millert;	state Exp;
branches;
next	1.33;
commitid	8wXOh16hq8cCiNNm;

1.33
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	pzd3OPiuZ6mCFBtc;

1.32
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	F55lwc3gS4GN2mLs;

1.31
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Uu5nFG3wCl0LACBb;

1.30
date	2014.10.11.03.48.49;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	OiAjgf86Jw3HVpev;

1.29
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.23.17.29.14;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.02.04.16.39;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.01.06.41.35;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.19.13.30.55;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.20.13.55.17;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.14.22.11.35;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.24.20.40.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.17.21.56.24;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.01.52.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.06.21.22.13.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.01.22.05.36.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.01.22.05.13.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.08.11.02.52.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.02.28.00.46.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.02.22.06.46.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.11.06.59.25;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.09.06.41.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.02.09.01.10.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.28.04.21.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.28.04.14.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.27.23.21.57;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.01.26.02.23.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Convert %q to %ll.  Cast off_t to long long for printf-style args.
Eliminate pointless casts to void* or off_t

ok krw@@
@
text
@/*	$OpenBSD: fsirand.c,v 1.38 2016/05/28 17:16:39 tb Exp $	*/

/*
 * Copyright (c) 1997 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/resource.h>
#include <sys/time.h>

#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

void usage(int);
int fsirand(char *);

extern char *__progname;

int printonly = 0, force = 0, ignorelabel = 0;

/*
 * Possible locations for the superblock.
 */
static const int sbtry[] = SBLOCKSEARCH;

int
main(int argc, char *argv[])
{
	int n, ex = 0;
	struct rlimit rl;

	while ((n = getopt(argc, argv, "bfp")) != -1) {
		switch (n) {
		case 'b':
			ignorelabel = 1;
			break;
		case 'p':
			printonly = 1;
			break;
		case 'f':
			force = 1;
			break;
		default:
			usage(1);
		}
	}
	if (argc - optind < 1)
		usage(1);

	/* Increase our data size to the max */
	if (getrlimit(RLIMIT_DATA, &rl) == 0) {
		rl.rlim_cur = rl.rlim_max;
		if (setrlimit(RLIMIT_DATA, &rl) < 0)
			warn("Can't set resource limit to max data size");
	} else
		warn("Can't get resource limit for data size");

	for (n = optind; n < argc; n++) {
		if (argc - optind != 1)
			(void)puts(argv[n]);
		ex += fsirand(argv[n]);
		if (n < argc - 1)
			putchar('\n');
	}

	exit(ex);
}

int
fsirand(char *device)
{
	struct ufs1_dinode *dp1 = NULL;
	struct ufs2_dinode *dp2 = NULL;
	static char *inodebuf;
	size_t ibufsize, isize;
	struct fs *sblock, *tmpsblock;
	ino_t inumber;
	daddr_t sblockloc, dblk;
	char sbuf[SBSIZE], sbuftmp[SBSIZE];
	int devfd, n, cg, i;
	char *devpath, *ib;
	u_int32_t bsize = DEV_BSIZE;
	struct disklabel label;

	if ((devfd = opendev(device, printonly ? O_RDONLY : O_RDWR,
	    0, &devpath)) < 0) {
		warn("Can't open %s", devpath);
		return (1);
	}

	/* Get block size (usually 512) from disklabel if possible */
	if (!ignorelabel) {
		if (ioctl(devfd, DIOCGDINFO, &label) < 0)
			warn("Can't read disklabel, using sector size of %d",
			    bsize);
		else
			bsize = label.d_secsize;
	}

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	/* Read in master superblock */
	(void)memset(&sbuf, 0, sizeof(sbuf));
	sblock = (struct fs *)&sbuf;

	for (i = 0; sbtry[i] != -1; i++) {
		sblockloc = sbtry[i];

		if (lseek(devfd, sblockloc, SEEK_SET) == -1) {
			warn("Can't seek to superblock (%lld) on %s",
			    (long long)sblockloc, devpath);
			return (1);
		}

		if ((n = read(devfd, sblock, SBSIZE)) != SBSIZE) {
			warnx("Can't read superblock on %s: %s", devpath,
			    (n < SBSIZE) ? "short read" : strerror(errno));
			return (1);
		}

		/* Find a suitable superblock */
		if (sblock->fs_magic != FS_UFS1_MAGIC &&
		    sblock->fs_magic != FS_UFS2_MAGIC)
			continue; /* Not a superblock */

		if (sblock->fs_magic == FS_UFS2_MAGIC &&
		    sblock->fs_sblockloc != sbtry[i])
		    	continue; /* Not a superblock */

		break;
	}

	if (sbtry[i] == -1) {
		warnx("Cannot find file system superblock");
		return (1);
	}

	/* Simple sanity checks on the superblock */
	if (sblock->fs_sbsize > SBSIZE) {
		warnx("Superblock size is preposterous");
		return (1);
	}

	if (sblock->fs_postblformat == FS_42POSTBLFMT) {
		warnx("Filesystem format is too old, sorry");
		return (1);
	}

	if (!force && !printonly && sblock->fs_clean != FS_ISCLEAN) {
		warnx("Filesystem is not clean, fsck %s first.", devpath);
		return (1);
	}

	/* Make sure backup superblocks are sane. */
	tmpsblock = (struct fs *)&sbuftmp;
	for (cg = 0; cg < sblock->fs_ncg; cg++) {
		dblk = fsbtodb(sblock, cgsblock(sblock, cg));
		if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
			warn("Can't seek to %lld", (long long)dblk * bsize);
			return (1);
		} else if ((n = read(devfd, tmpsblock, SBSIZE)) != SBSIZE) {
			warn("Can't read backup superblock %d on %s: %s",
			    cg + 1, devpath, (n < SBSIZE) ? "short read"
			    : strerror(errno));
			return (1);
		}
		if (tmpsblock->fs_magic != FS_UFS1_MAGIC &&
		    tmpsblock->fs_magic != FS_UFS2_MAGIC) {
			warnx("Bad magic number in backup superblock %d on %s",
			    cg + 1, devpath);
			return (1);
		}
		if (tmpsblock->fs_sbsize > SBSIZE) {
			warnx("Size of backup superblock %d on %s is preposterous",
			    cg + 1, devpath);
			return (1);
		}
	}

	/* XXX - should really cap buffer at 512kb or so */
	if (sblock->fs_magic == FS_UFS1_MAGIC)
		isize = sizeof(struct ufs1_dinode);
	else
		isize = sizeof(struct ufs2_dinode);

	if ((ib = reallocarray(inodebuf, sblock->fs_ipg, isize)) == NULL)
		errx(1, "Can't allocate memory for inode buffer");
	inodebuf = ib;
	ibufsize = sblock->fs_ipg * isize;

	if (printonly && (sblock->fs_id[0] || sblock->fs_id[1])) {
		if (sblock->fs_inodefmt >= FS_44INODEFMT && sblock->fs_id[0]) {
			time_t t = sblock->fs_id[0];	/* XXX 2038 */
			(void)printf("%s was randomized on %s", devpath,
			    ctime(&t));
		}
		(void)printf("fsid: %x %x\n", sblock->fs_id[0],
		    sblock->fs_id[1]);
	}

	/* Randomize fs_id unless old 4.2BSD filesystem */
	if ((sblock->fs_inodefmt >= FS_44INODEFMT) && !printonly) {
		/* Randomize fs_id and write out new sblock and backups */
		sblock->fs_id[0] = (u_int32_t)time(NULL);
		sblock->fs_id[1] = arc4random();

		if (lseek(devfd, SBOFF, SEEK_SET) == -1) {
			warn("Can't seek to superblock (%lld) on %s",
			    (long long)SBOFF, devpath);
			return (1);
		}
		if ((n = write(devfd, sblock, SBSIZE)) != SBSIZE) {
			warn("Can't write superblock on %s: %s", devpath,
			    (n < SBSIZE) ? "short write" : strerror(errno));
			return (1);
		}
	}

	/* For each cylinder group, randomize inodes and update backup sblock */
	for (cg = 0, inumber = 0; cg < sblock->fs_ncg; cg++) {
		/* Update superblock if appropriate */
		if ((sblock->fs_inodefmt >= FS_44INODEFMT) && !printonly) {
			dblk = fsbtodb(sblock, cgsblock(sblock, cg));
			if (lseek(devfd, (off_t)dblk * bsize,
			    SEEK_SET) < 0) {
				warn("Can't seek to %lld",
				    (long long)dblk * bsize);
				return (1);
			} else if ((n = write(devfd, sblock, SBSIZE)) !=
			    SBSIZE) {
				warn("Can't read backup superblock %d on %s: %s",
				    cg + 1, devpath, (n < SBSIZE) ? "short write"
				    : strerror(errno));
				return (1);
			}
		}

		/* Read in inodes, then print or randomize generation nums */
		dblk = fsbtodb(sblock, ino_to_fsba(sblock, inumber));
		if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
			warn("Can't seek to %lld", (long long)dblk * bsize);
			return (1);
		} else if ((n = read(devfd, inodebuf, ibufsize)) != ibufsize) {
			warnx("Can't read inodes: %s",
			    (n < ibufsize) ? "short read" : strerror(errno));
			return (1);
		}

		for (n = 0; n < sblock->fs_ipg; n++, inumber++) {
			if (sblock->fs_magic == FS_UFS1_MAGIC)
				dp1 = &((struct ufs1_dinode *)inodebuf)[n];
			else
				dp2 = &((struct ufs2_dinode *)inodebuf)[n];
			if (inumber >= ROOTINO) {
				if (printonly)
					(void)printf("ino %llu gen %x\n",
					    (unsigned long long)inumber,
					    sblock->fs_magic == FS_UFS1_MAGIC ?
					    dp1->di_gen : dp2->di_gen);
				else if (sblock->fs_magic == FS_UFS1_MAGIC)
					dp1->di_gen = arc4random();
				else
					dp2->di_gen = arc4random();
			}
		}

		/* Write out modified inodes */
		if (!printonly) {
			if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
				warn("Can't seek to %lld",
				    (long long)dblk * bsize);
				return (1);
			} else if ((n = write(devfd, inodebuf, ibufsize)) !=
				 ibufsize) {
				warnx("Can't write inodes: %s",
				    (n != ibufsize) ? "short write" :
				    strerror(errno));
				return (1);
			}
		}
	}
	(void)close(devfd);

	return(0);
}

void
usage(int ex)
{
	(void)fprintf(stderr, "usage: %s [-bfp] special ...\n",
	    __progname);
	exit(ex);
}
@


1.38
log
@Fix a pledge abort that can be triggered by using DIOCGDINFO on a file
that is not a disk device (e.g. fsirand -p /altroot) by removing the
first of the two pledges.  The program then runs with pledge "stdio"
right after the ioctl.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.37 2015/11/23 19:19:30 deraadt Exp $	*/
d134 3
a136 3
		if (lseek(devfd, (off_t)sblockloc, SEEK_SET) == -1) {
			warn("Can't seek to superblock (%qd) on %s", sblockloc,
			    devpath);
d140 1
a140 1
		if ((n = read(devfd, (void *)sblock, SBSIZE)) != SBSIZE) {
d183 2
a184 2
		if (lseek(devfd, (off_t)dblk * (off_t)bsize, SEEK_SET) < 0) {
			warn("Can't seek to %qd", (off_t)dblk * bsize);
d186 1
a186 1
		} else if ((n = read(devfd, (void *)tmpsblock, SBSIZE)) != SBSIZE) {
d232 3
a234 3
		if (lseek(devfd, (off_t)SBOFF, SEEK_SET) == -1) {
			warn("Can't seek to superblock (%qd) on %s", SBOFF,
			    devpath);
d237 1
a237 1
		if ((n = write(devfd, (void *)sblock, SBSIZE)) != SBSIZE) {
d249 1
a249 1
			if (lseek(devfd, (off_t)dblk * (off_t)bsize,
d251 2
a252 1
				warn("Can't seek to %qd", (off_t)dblk * bsize);
d254 1
a254 1
			} else if ((n = write(devfd, (void *)sblock, SBSIZE)) !=
d265 2
a266 2
		if (lseek(devfd, (off_t)dblk * (off_t)bsize, SEEK_SET) < 0) {
			warn("Can't seek to %qd", (off_t)dblk * bsize);
d294 3
a296 3
			if (lseek(devfd, (off_t)dblk * (off_t)bsize, SEEK_SET) < 0) {
				warn("Can't seek to %qd",
				    (off_t)dblk * bsize);
@


1.37
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.35 2015/10/11 04:37:23 deraadt Exp $	*/
a107 3

	if (pledge("stdio rpath wpath disklabel", NULL) == -1)
		err(1, "pledge");
@


1.36
log
@opendev() should not use OPENDEV_PART; ok millert
@
text
@d109 3
@


1.35
log
@After the filesystem is opened, pledge "stdio"
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.34 2015/03/20 01:53:05 millert Exp $	*/
d110 1
a110 1
	    OPENDEV_PART, &devpath)) < 0) {
@


1.34
log
@Fix cut & pasto in warning message; from Andre Smagin
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.33 2015/02/07 02:09:13 deraadt Exp $	*/
d123 3
@


1.33
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.32 2015/01/20 18:22:21 deraadt Exp $	*/
d78 1
a78 1
			warn("Can't get resource limit to max data size");
@


1.32
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.31 2015/01/16 06:39:58 deraadt Exp $	*/
d59 1
a59 1
			ignorelabel++;
d62 1
a62 1
			printonly++;
d65 1
a65 1
			force++;
@


1.31
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.30 2014/10/11 03:48:49 deraadt Exp $	*/
d19 1
a19 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE */
@


1.30
log
@slightly more complicated reallocarray conversion.  always realloc* rather
than the silly test which realloc* does itself, and massage the inode
sizes more carefully
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.29 2013/06/11 16:42:04 deraadt Exp $	*/
d19 1
a19 1
#include <sys/types.h>
a22 1
#include <sys/param.h>
@


1.29
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.28 2013/04/23 17:29:14 deraadt Exp $	*/
d100 1
a100 2
	static size_t oldibufsize;
	size_t ibufsize;
d106 1
a106 1
	char *devpath;
d205 1
a205 1
		ibufsize = sizeof(struct ufs1_dinode) * sblock->fs_ipg;
d207 6
a212 9
		ibufsize = sizeof(struct ufs2_dinode) * sblock->fs_ipg;
	if (oldibufsize < ibufsize) {
		char *ib;

		if ((ib = realloc(inodebuf, ibufsize)) == NULL)
			errx(1, "Can't allocate memory for inode buffer");
		inodebuf = ib;
		oldibufsize = ibufsize;
	}
@


1.28
log
@handle big ino_t
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.27 2013/04/02 04:16:39 deraadt Exp $	*/
d104 1
a104 1
	daddr64_t sblockloc, dblk;
@


1.27
log
@handle time_t which is not u_int32_t
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.26 2010/05/18 04:41:14 dlg Exp $	*/
d282 2
a283 1
					(void)printf("ino %d gen %x\n", inumber,
@


1.26
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.25 2007/06/01 06:41:35 deraadt Exp $	*/
d219 2
a220 1
		if (sblock->fs_inodefmt >= FS_44INODEFMT && sblock->fs_id[0])
d222 2
a223 1
			    ctime((const time_t *)&(sblock->fs_id[0])));
@


1.25
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.24 2007/03/19 13:30:55 pedro Exp $	*/
d22 1
@


1.24
log
@Bits to make fsirand grok FFS2, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.23 2007/02/20 13:55:17 jmc Exp $	*/
d103 1
a103 1
	ufs2_daddr_t sblockloc, dblk;
@


1.23
log
@simplify synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.22 2004/09/14 22:11:35 deraadt Exp $	*/
a18 4
#ifndef lint
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.22 2004/09/14 22:11:35 deraadt Exp $";
#endif /* not lint */

d45 5
d96 3
a98 1
	static struct ufs1_dinode *inodebuf;
d103 1
a103 1
	daddr_t dblk;
d105 1
a105 1
	int devfd, n, cg;
d128 26
a153 3
	if (lseek(devfd, (off_t)SBOFF, SEEK_SET) == -1) {
		warn("Can't seek to superblock (%qd) on %s", SBOFF, devpath);
		return (1);
d155 3
a157 3
	if ((n = read(devfd, (void *)sblock, SBSIZE)) != SBSIZE) {
		warnx("Can't read superblock on %s: %s", devpath,
		    (n < SBSIZE) ? "short read" : strerror(errno));
a161 4
	if (sblock->fs_magic != FS_MAGIC) {
		warnx("Bad magic number in superblock");
		return (1);
	}
d166 1
d171 1
d190 2
a191 1
		if (tmpsblock->fs_magic != FS_MAGIC) {
d204 4
a207 1
	ibufsize = sizeof(struct ufs1_dinode) * sblock->fs_ipg;
d209 1
a209 1
		struct ufs1_dinode *ib;
d273 4
d280 4
a283 1
					    inodebuf[n].di_gen);
d285 1
a285 1
					inodebuf[n].di_gen = arc4random();
@


1.22
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.21 2004/08/08 19:04:25 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.21 2004/08/08 19:04:25 deraadt Exp $";
d277 1
a277 1
	(void)fprintf(stderr, "Usage: %s [ -b ] [ -f ] [ -p ] special [special ...]\n",
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.20 2003/09/24 20:40:19 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.20 2003/09/24 20:40:19 deraadt Exp $";
d99 1
a99 1
	ino_t inumber, maxino;
a133 1
	maxino = sblock->fs_ncg * sblock->fs_ipg;
@


1.20
log
@realloc fixes; ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.19 2003/08/25 23:28:15 tedu Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.19 2003/08/25 23:28:15 tedu Exp $";
d183 1
a183 1
		
@


1.19
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.18 2003/06/17 21:56:24 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.18 2003/06/17 21:56:24 millert Exp $";
d182 3
a184 1
		if ((inodebuf = realloc(inodebuf, ibufsize)) == NULL)
d186 1
@


1.18
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.17 2003/06/03 01:52:40 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.17 2003/06/03 01:52:40 millert Exp $";
d95 1
a95 1
	static struct dinode *inodebuf;
d180 1
a180 1
	ibufsize = sizeof(struct dinode) * sblock->fs_ipg;
@


1.17
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.16 2002/07/03 22:32:32 deraadt Exp $	*/
d10 7
a16 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.16 2002/07/03 22:32:32 deraadt Exp $";
@


1.16
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.15 2002/06/09 08:13:06 todd Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.15 2002/06/09 08:13:06 todd Exp $";
@


1.15
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.14 2002/02/16 21:27:35 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.14 2002/02/16 21:27:35 millert Exp $";
d61 1
a61 3
main(argc, argv)
	int	argc;
	char	*argv[];
d104 1
a104 2
fsirand(device)
	char *device;
d119 1
a119 1
	     OPENDEV_PART, &devpath)) < 0) {
d203 1
a203 1
			    sblock->fs_id[1]);
d229 2
a230 1
			if (lseek(devfd, (off_t)dblk * (off_t)bsize, SEEK_SET) < 0) {
d233 2
a234 1
			} else if ((n = write(devfd, (void *)sblock, SBSIZE)) != SBSIZE) {
d249 1
a249 1
			     (n < ibufsize) ? "short read" : strerror(errno));
d257 1
a257 1
						     inodebuf[n].di_gen);
d272 2
a273 2
				     (n != ibufsize) ? "short write" :
				     strerror(errno));
d284 1
a284 2
usage(ex)
	int ex;
d287 1
a287 1
		      __progname);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.13 1998/06/21 22:13:55 millert Exp $	*/
d30 3
a32 3
#ifndef lint                                                              
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.13 1998/06/21 22:13:55 millert Exp $";
#endif /* not lint */                                                        
@


1.13
log
@Remove the advertising clause in my old license, it impedes free use
of the code as a large number of similar clauses makes it impossible
to write an ad for a product using the code...
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.12 1998/01/22 05:36:10 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.12 1998/01/22 05:36:10 millert Exp $";
d53 2
a54 2
void usage __P((int));
int fsirand __P((char *));
@


1.12
log
@Fix backup sblock sanity checking for real.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.11 1998/01/22 05:13:18 millert Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Todd C. Miller.
 * 4. The name of the author may not be used to endorse or promote products
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.11 1998/01/22 05:13:18 millert Exp $";
@


1.11
log
@Fix sanity check of backup sblocks as well as error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.10 1997/08/11 02:52:31 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.10 1997/08/11 02:52:31 millert Exp $";
d115 1
a115 1
	struct fs *sblock;
d172 1
a172 1
	sblock = (struct fs *)&sbuftmp;
d178 1
a178 1
		} else if ((n = read(devfd, (void *)sblock, SBSIZE)) != SBSIZE) {
d184 1
a184 1
		if (sblock->fs_magic != FS_MAGIC) {
d189 1
a189 1
		if (sblock->fs_sbsize > SBSIZE) {
a194 1
	sblock = (struct fs *)&sbuf;
@


1.10
log
@Add extra off_t casts for paranoia and because I don't have a large
filesystem to prove that it is *not* necesary.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.9 1997/02/28 00:46:33 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.9 1997/02/28 00:46:33 millert Exp $";
d178 1
a178 1
		} else if ((n = write(devfd, (void *)sblock, SBSIZE)) != SBSIZE) {
d180 1
a180 1
			    cg + 1, devpath, (n < SBSIZE) ? "short write"
d225 1
a225 1
			warn("Can't read superblock on %s: %s", devpath,
@


1.9
log
@Slightly more sane rlimit usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.8 1997/02/22 06:46:23 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.8 1997/02/22 06:46:23 millert Exp $";
d142 1
a142 1
	if (lseek(devfd, SBOFF, SEEK_SET) == -1) {
d175 1
a175 1
		if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
d219 1
a219 1
		if (lseek(devfd, SBOFF, SEEK_SET) == -1) {
d236 1
a236 1
			if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
d249 1
a249 1
		if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
d270 1
a270 1
			if (lseek(devfd, (off_t)dblk * bsize, SEEK_SET) < 0) {
@


1.8
log
@Use rlimit to set datasize to max.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.7 1997/02/11 06:59:25 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.7 1997/02/11 06:59:25 millert Exp $";
d89 7
a95 6
	/* Increase our max data size */
	if (getrlimit(RLIMIT_DATA, &rl) < 0)
		warn("getrlimit");
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_DATA, &rl) < 0)
		warn("setrlimit");
@


1.7
log
@We now has fs_id in struct fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.6 1997/02/09 06:41:08 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.6 1997/02/09 06:41:08 millert Exp $";
d41 1
d69 1
d88 7
@


1.6
log
@Fix casts to off_t, problem noted and fixed by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.5 1997/02/09 01:10:17 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.5 1997/02/09 01:10:17 millert Exp $";
a194 1
#ifdef HAVE_FS_ID
a219 1
#endif
a222 1
#ifdef HAVE_FS_ID
a235 1
#endif
@


1.5
log
@Get block size from disklabel.
Adds support for setting fs_id for when when we have that in struct fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.4 1997/01/28 04:21:25 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.4 1997/01/28 04:21:25 millert Exp $";
d165 2
a166 2
		if (lseek(devfd, (off_t)(dblk * bsize), SEEK_SET) < 0) {
			warn("Can't seek to %qd", (off_t)(dblk * bsize));
d229 2
a230 2
			if (lseek(devfd, (off_t)(dblk * bsize), SEEK_SET) < 0) {
				warn("Can't seek to %qd", (off_t)(dblk * bsize));
d243 2
a244 2
		if (lseek(devfd, (off_t)(dblk * bsize), SEEK_SET) < 0) {
			warn("Can't seek to %qd", (off_t)(dblk * bsize));
d264 1
a264 1
			if (lseek(devfd, (off_t)(dblk * bsize), SEEK_SET) < 0) {
d266 1
a266 1
				    (off_t)(dblk * bsize));
@


1.4
log
@Only print the partition if doing multiple devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.3 1997/01/28 04:14:55 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.3 1997/01/28 04:14:55 millert Exp $";
d37 3
d41 1
a41 1
#include <sys/types.h>
d56 1
a56 1
void fsirand __P((char *));
d60 1
a60 1
int printonly = 0, force = 0;
d67 1
a67 1
	int n;
d69 1
a69 1
	while ((n = getopt(argc, argv, "fp")) != -1) {
d71 3
d90 1
a90 1
		fsirand(argv[n]);
d95 1
a95 1
	exit(0);
d98 1
a98 1
void
d107 3
a109 3
	static daddr_t dblk;
	char sbuf[SBSIZE];
	int devfd, n;
d111 2
a113 1
	/* Open device and read in superblock */
d115 13
a127 2
	     OPENDEV_PART, &devpath)) < 0)
		err(1, "Can't open %s", devpath);
d129 1
d132 6
a137 4
	if (lseek(devfd, SBOFF, SEEK_SET) == -1)
		err(1, "Can't seek to superblock (%qd) on %s", SBOFF, devpath);
	if ((n = read(devfd, (void *)sblock, SBSIZE)) != SBSIZE)
		err(1, "Can't read superblock on %s: %s", devpath,
d139 3
d144 42
a185 7
	if (sblock->fs_magic != FS_MAGIC)
		errx(1, "Wrong magic number in superblock");
	if (sblock->fs_sbsize > SBSIZE)
		errx(1, "Superblock size is preposterous");
	if (!force && !printonly && sblock->fs_clean != FS_ISCLEAN)
		errx(1, "Filesystem is not clean, fsck %s before running %s\n",
		     devpath, __progname);
d187 1
a187 1
	maxino = sblock->fs_ncg * sblock->fs_ipg;
d195 46
a240 2
	/* Randomize inodes a cylinder group at a time */
	for (inumber = 0; inumber < maxino;) {
d243 3
a245 4
		/* XXX - don't use DEV_BSIZE, get value from disklabel! */
		if (lseek(devfd, (off_t)(dblk * DEV_BSIZE), SEEK_SET) < 0) {
			warn("Can't seek to %qd", (off_t)(dblk * DEV_BSIZE));
			return;
d249 1
a249 1
			return;
d264 1
a264 2
			/* XXX - don't use DEV_BSIZE, get from disklabel! */
			if (lseek(devfd, (off_t)(dblk * DEV_BSIZE), SEEK_SET) < 0) {
d266 2
a267 2
				    (off_t)(dblk * DEV_BSIZE));
				return;
d270 1
a270 1
				errx(1, "Can't write inodes: %s",
d273 1
a273 1
				return;
d278 2
d286 1
a286 1
	(void)fprintf(stderr, "Usage: %s [ -p ] special [special ...]\n",
@


1.3
log
@Revert back to old fsirand but do things a cylinder group at a time
and allow multiple devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.2 1997/01/27 23:21:57 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.2 1997/01/27 23:21:57 millert Exp $";
d82 2
a109 1
	(void)puts(devpath);
@


1.2
log
@Faster fsirand based in part on code from fsck_ffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsirand.c,v 1.1 1997/01/26 02:23:23 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fsirand.c,v 1.1 1997/01/26 02:23:23 millert Exp $";
a51 3
#define	INOBUFSIZE	56*1024	/* size of buffer to read inodes (from fsck) */

void fsirand __P((int, struct fs *, int));
d53 1
d57 2
d64 1
a64 3
	struct fs *sblock;
	int devfd, n, force = 0, printonly = 0;
	char sbuf[SBSIZE], *devpath;
d78 1
a78 1
	if (argc - optind != 1)
d81 23
d105 1
a105 1
	if ((devfd = opendev(argv[optind], printonly ? O_RDONLY : O_RDWR,
d108 2
a126 25
	/* Do the work */
	fsirand(devfd, sblock, printonly);

	(void)close(devfd);

	exit(0);
}

void
fsirand(fd, sblock, printonly)
	int fd;
	struct fs *sblock;
	int printonly;
{
	size_t size, n;
	daddr_t dblk;
	static struct dinode *dp;
	ino_t inumber, lastinum, maxino;
	size_t readcnt, readpercg, fullcnt, inobufsize, partialcnt, partialsize;
	struct dinode *inodebuf;

	/* Initialize variables and allocate buffer */
	inumber = 0;
	lastinum = 0;
	readcnt = 0;
d128 5
a132 10
	inobufsize = blkroundup(sblock, INOBUFSIZE);
	fullcnt = inobufsize / sizeof(struct dinode);
	readpercg = sblock->fs_ipg / fullcnt;
	partialcnt = sblock->fs_ipg % fullcnt;
	partialsize = partialcnt * sizeof(struct dinode);
	if (partialcnt != 0) {
		readpercg++;
	} else {
		partialcnt = fullcnt;
		partialsize = inobufsize;
a133 2
	if ((inodebuf = (struct dinode *)malloc((unsigned)inobufsize)) == NULL)
		errx(1, "Can't allocate memory for inode buffer");
d135 12
a146 10
	/* Grab inodes a buffer's length at a time */
	while (lastinum < maxino) {
		readcnt++;
		dblk = fsbtodb(sblock, ino_to_fsba(sblock, lastinum));
		if (readcnt % readpercg == 0) {
			size = partialsize;
			lastinum += partialcnt;
		} else {
			size = inobufsize;
			lastinum += fullcnt;
a147 6
		/* XXX - don't use DEV_BSIZE, get value from disklabel! */
		if (lseek(fd, (off_t)(dblk * DEV_BSIZE), SEEK_SET) < 0)
			err(1, "Can't seek to %qd", (off_t)(dblk * DEV_BSIZE));
		else if ((n = read(fd, inodebuf, size)) != size)
			errx(1, "Can't read inodes: %s",
			     (n < size) ? "short read" : strerror(errno));
d149 1
a149 1
		for (dp = inodebuf, n = 0; inumber < lastinum; n++, inumber++)
d152 2
a153 2
					(void)printf("ino %d gen %x\n",
					    inumber, dp[n].di_gen);
d155 1
a155 1
					dp[n].di_gen = arc4random();
d157 3
d162 2
a163 2
			if (lseek(fd, (off_t)(dblk * DEV_BSIZE), SEEK_SET) < 0)
				err(1, "Can't seek to %qd",
d165 3
a167 1
			else if ((n = write(fd, inodebuf, size)) != size)
d169 1
a169 1
				     (n != size) ? "short write" :
d171 2
d175 1
a175 1
	(void)free(inodebuf);
d182 2
a183 1
	(void)fprintf(stderr, "Usage: %s [ -p ] special\n", __progname);
@


1.1
log
@ffs inode randomizer
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: $";
d52 3
d65 2
a66 7
	ino_t inumber, maxino;
	size_t ibufsize;
	struct dinode *inodebuf;
	static daddr_t dblk;
	char sbuf[SBSIZE];
	int devfd, n, printonly = 0, force = 0;
	char *devpath;
d104 38
a141 2
	ibufsize = sizeof(struct dinode) * INOPB(sblock);
	if ((inodebuf = malloc(ibufsize)) == NULL)
d144 11
a154 4
	maxino = sblock->fs_ncg * sblock->fs_ipg;
	for (inumber = 0; inumber < maxino;) {
		/* Read in inodes, then print or randomize generation nums */
		dblk = fsbtodb(sblock, ino_to_fsba(sblock, inumber));
d156 1
a156 1
		if (lseek(devfd, (off_t)(dblk * DEV_BSIZE), SEEK_SET) < 0)
d158 1
a158 1
		else if ((n = read(devfd, inodebuf, ibufsize)) != ibufsize)
d160 1
a160 1
			     (n < ibufsize) ? "short read" : strerror(errno));
d162 1
a162 1
		for (n = 0; n < INOPB(sblock); n++, inumber++) {
d165 2
a166 2
					(void)printf("ino %d gen %x\n", inumber,
						     inodebuf[n].di_gen);
d168 1
a168 1
					inodebuf[n].di_gen = arc4random();
a169 3
		}

		/* Write out modified inodes */
d172 1
a172 1
			if (lseek(devfd, (off_t)(dblk * DEV_BSIZE), SEEK_SET) < 0)
d175 1
a175 2
			else if ((n = write(devfd, inodebuf, ibufsize)) !=
				 ibufsize)
d177 1
a177 1
				     (n != ibufsize) ? "short write" :
d181 1
a181 3
	(void)close(devfd);

	exit(0);
@
