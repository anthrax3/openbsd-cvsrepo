head	1.71;
access;
symbols
	OPENBSD_6_1:1.71.0.2
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.66.0.2
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.60.0.6
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.54.0.6
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.4
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.4
	OPENBSD_5_0:1.52.0.2
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.50.0.6
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.4
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.48.0.6
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.20.0.6
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.19.0.6
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.4
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2017.02.06.17.15.56;	author tb;	state Exp;
branches;
next	1.70;
commitid	aHeXVj6rUotkFbI4;

1.70
date	2017.01.25.02.33.25;	author tb;	state Exp;
branches;
next	1.69;
commitid	7ObOAeBDG0vJSg6t;

1.69
date	2017.01.24.23.41.44;	author tb;	state Exp;
branches;
next	1.68;
commitid	1AZsx2aWmOOkFNty;

1.68
date	2016.09.10.16.53.30;	author natano;	state Exp;
branches;
next	1.67;
commitid	OheBN9SCINTycSAi;

1.67
date	2016.09.04.19.45.27;	author akfaew;	state Exp;
branches;
next	1.66;
commitid	MVKzu3mcP2hJoFFw;

1.66
date	2016.06.26.19.53.40;	author tedu;	state Exp;
branches;
next	1.65;
commitid	02ZwZf68RQfeMlX6;

1.65
date	2016.06.20.08.36.36;	author ajacoutot;	state Exp;
branches;
next	1.64;
commitid	SHyfGuxN28HGu3Sw;

1.64
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	nQEqvpt7rKDi6fz0;

1.63
date	2016.05.25.13.56.37;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	m6CJwhX11NbMjIyX;

1.62
date	2016.05.21.18.11.36;	author natano;	state Exp;
branches;
next	1.61;
commitid	h6HuALSffVqURa2m;

1.61
date	2015.11.23.23.26.59;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	CjEDU16GJWJcZLsP;

1.60
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	Uu5nFG3wCl0LACBb;

1.59
date	2014.09.08.01.47.05;	author guenther;	state Exp;
branches;
next	1.58;
commitid	QKTb36RFnfteZJPE;

1.58
date	2014.07.17.06.25.12;	author guenther;	state Exp;
branches;
next	1.57;
commitid	d65a7a1QljYPqUuT;

1.57
date	2014.07.15.11.25.22;	author jmc;	state Exp;
branches;
next	1.56;
commitid	YFDT8634jdE7SB4n;

1.56
date	2014.07.13.12.01.30;	author claudio;	state Exp;
branches;
next	1.55;
commitid	9vfE5xjkUJV75xpO;

1.55
date	2014.06.24.02.32.43;	author daniel;	state Exp;
branches;
next	1.54;
commitid	bo60fsdEa16WuTH4;

1.54
date	2013.04.21.11.05.14;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2012.05.29.20.01.32;	author landry;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.12.14.51.40;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.12.23.25.08;	author thib;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.17.17.18.32;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.16.20.19.27;	author sobrado;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.02.15.19.24;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.01.05.37.14;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.15.03.04.24;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.06.17.54.22;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.08.01.41.32;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.12.20.01.31;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.26.20.16.21;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.26.01.37.49;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.08.20.09.36;	author jaredy;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.13.21.45.50;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.15.15.15.16;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.16.21.27.47;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.01.06.17.31;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.05.20.48.59;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.20.03.09.55;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.06.14.14.48;	author gluk;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.17.19.42.28;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.21.27.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.18.01.37.27;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.16.22.45.37;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.24.17.03.16;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.12.01.30.24;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.05.31.17.34.42;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.02.01.18.49.08;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.06.18.09.57.04;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.05.28.21.28.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.03.10.04.27.42;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.03.09.19.28.01;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.03.02.09.38.28;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.01.15.23.41.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.12.23.08.38.49;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.12.23.07.46.53;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.12.09.13.25.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.12.04.21.29.29;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.12.04.09.45.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.03.01.04.44;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.09.09.19;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.08.46.13;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.31.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.21.22.17.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.32.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Postpone pledge call until after the getopt switch and hoist the call to
readlabelfs over it. This avoids a pledge abort due to the fact that the
ioctl DIOCGDINFO may not be allowed on the given file: mount /dev/tty /tmp.

ok benno
@
text
@/*	$OpenBSD: mount.c,v 1.70 2017/01/25 02:33:25 tb Exp $	*/
/*	$NetBSD: mount.c,v 1.24 1995/11/18 03:34:29 cgd Exp $	*/

/*
 * Copyright (c) 1980, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <err.h>
#include <errno.h>
#include <fstab.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#include "pathnames.h"

int	debug, verbose, skip;
char	**typelist = NULL;
enum { NONET_FILTER, NET_FILTER } filter = NONET_FILTER;

int	selected(const char *);
char   *catopt(char *, const char *);
char   *flags2opts(u_int32_t);
struct statfs
       *getmntpt(const char *);
int	hasopt(const char *, const char *);
void	maketypelist(char *);
void	mangle(char *, int *, const char **, int);
int	mountfs(const char *, const char *, const char *, const char *,
	    const char *, int);
void	prmount(struct statfs *);
int	disklabelcheck(struct fstab *);
__dead void	usage(void);

/* Map from mount options to printable formats. */
static struct opt {
	int o_opt;
	int o_silent;
	const char *o_name;
	const char *o_optname;
} optnames[] = {
	{ MNT_ASYNC,		0,	"asynchronous",		"async" },
	{ MNT_DEFEXPORTED,	1,	"exported to the world", "" },
	{ MNT_EXPORTED,		0,	"NFS exported",		"" },
	{ MNT_EXPORTANON,	1,	"anon uid mapping",	"" },
	{ MNT_EXRDONLY,		1,	"exported read-only",	"" },
	{ MNT_LOCAL,		0,	"local",		"" },
	{ MNT_NOATIME,		0,	"noatime",		"noatime" },
	{ MNT_NODEV,		0,	"nodev",		"nodev" },
	{ MNT_NOEXEC,		0,	"noexec",		"noexec" },
	{ MNT_NOSUID,		0,	"nosuid",		"nosuid" },
	{ MNT_NOPERM,		0,	"noperm",		"noperm" },
	{ MNT_WXALLOWED,	0,	"wxallowed",		"wxallowed" },
	{ MNT_QUOTA,		0,	"with quotas",		"" },
	{ MNT_RDONLY,		0,	"read-only",		"ro" },
	{ MNT_ROOTFS,		1,	"root file system",	"" },
	{ MNT_SYNCHRONOUS,	0,	"synchronous",		"sync" },
	{ MNT_SOFTDEP,		0,	"softdep",		"softdep" },
	{ 0,			0,	"",			"" }
};

int
main(int argc, char * const argv[])
{
	const char *mntonname, *vfstype;
	struct fstab *fs;
	struct statfs *mntbuf;
	FILE *mountdfp;
	pid_t pid;
	int all, ch, forceall, i, mntsize, rval, new;
	char *options, mntpath[PATH_MAX];

	all = forceall = 0;
	options = NULL;
	vfstype = "ffs";
	while ((ch = getopt(argc, argv, "AadfNo:rswt:uv")) != -1)
		switch (ch) {
		case 'A':
			all = forceall = 1;
			break;
		case 'a':
			all = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'f':
			if (!hasopt(options, "force"))
				options = catopt(options, "force");
			break;
		case 'N':
			filter = NET_FILTER;
			break;
		case 'o':
			if (*optarg)
				options = catopt(options, optarg);
			break;
		case 'r':
			if (!hasopt(options, "ro"))
				options = catopt(options, "ro");
			break;
		case 's':
			skip = 1;
			break;
		case 't':
			if (typelist != NULL)
				errx(1, "only one -t option may be specified.");
			maketypelist(optarg);
			vfstype = optarg;
			break;
		case 'u':
			if (!hasopt(options, "update"))
				options = catopt(options, "update");
			break;
		case 'v':
			verbose = 1;
			break;
		case 'w':
			if (!hasopt(options, "rw"))
				options = catopt(options, "rw");
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (typelist == NULL && argc == 2) {
		/*
		 * If -t flag has not been specified, and spec contains either
		 * a ':' or a '@@' then assume that an NFS filesystem is being
		 * specified ala Sun.  If not, check the disklabel for a
		 * known filesystem type.
		 */
		if (strpbrk(argv[0], ":@@") != NULL)
			vfstype = "nfs";
		else {
			char *labelfs = readlabelfs(argv[0], 0);
			if (labelfs != NULL)
				vfstype = labelfs;
		}
	}

	if (pledge("stdio rpath disklabel proc exec", NULL) == -1)
		err(1, "pledge");

#define	BADTYPE(type)							\
	(strcmp(type, FSTAB_RO) &&					\
	    strcmp(type, FSTAB_RW) && strcmp(type, FSTAB_RQ))

	rval = 0;
	new = 0;
	switch (argc) {
	case 0:
		if (all)
			while ((fs = getfsent()) != NULL) {
				if (BADTYPE(fs->fs_type))
					continue;
				switch (filter) {
				case NET_FILTER:
					if (!hasopt(fs->fs_mntops, "net"))
						continue;
					break;
				case NONET_FILTER:
					if (hasopt(fs->fs_mntops, "net"))
						continue;
					break;
				}
				if (!selected(fs->fs_vfstype))
					continue;
				if (hasopt(fs->fs_mntops, "noauto"))
					continue;
				if (disklabelcheck(fs))
					continue;
				if (mountfs(fs->fs_vfstype, fs->fs_spec,
				    fs->fs_file, options,
				    fs->fs_mntops, !forceall))
					rval = 1;
				else
					++new;
			}
		else {
			if ((mntsize = getmntinfo(&mntbuf, MNT_NOWAIT)) == 0)
				err(1, "getmntinfo");
			for (i = 0; i < mntsize; i++) {
				if (!selected(mntbuf[i].f_fstypename))
					continue;
				prmount(&mntbuf[i]);
			}
			return (rval);
		}
		break;
	case 1:
		if (typelist != NULL)
			usage();

		if (realpath(*argv, mntpath) == NULL && strpbrk(argv[0], ":@@") == NULL)
			err(1, "realpath %s", *argv);
		if (hasopt(options, "update")) {
			if ((mntbuf = getmntpt(mntpath)) == NULL)
				errx(1,
				    "unknown special file or file system %s.",
				    *argv);
			if ((mntbuf->f_flags & MNT_ROOTFS) &&
			    !strcmp(mntbuf->f_mntfromname, "root_device")) {
				/* Lookup fstab for name of root device. */
				fs = getfsfile(mntbuf->f_mntonname);
				if (fs == NULL)
					errx(1,
					    "can't find fstab entry for %s.",
					    *argv);
			} else {
				if ((fs = malloc(sizeof(*fs))) == NULL)
					err(1, NULL);
				fs->fs_vfstype = mntbuf->f_fstypename;
				fs->fs_spec = mntbuf->f_mntfromname;
			}
			/*
			 * It's an update, ignore the fstab file options.
			 * Get the current options, so we can change only
			 * the options which given via a command line.
			 */
			fs->fs_mntops = flags2opts(mntbuf->f_flags);
			mntonname = mntbuf->f_mntonname;
		} else {
			if ((fs = getfsfile(mntpath)) == NULL &&
			    (fs = getfsspec(mntpath)) == NULL &&
			    (fs = getfsspec(*argv)) == NULL)
				errx(1, "can't find fstab entry for %s.",
				    *argv);
			if (BADTYPE(fs->fs_type))
				errx(1, "%s has unknown file system type.",
				    *argv);
			mntonname = fs->fs_file;
		}
		rval = mountfs(fs->fs_vfstype, fs->fs_spec,
		    mntonname, options, fs->fs_mntops, skip);
		break;
	case 2:
		rval = mountfs(vfstype, argv[0], argv[1], options, NULL, 0);
		break;
	default:
		usage();
	}

	/*
	 * If the mount was successfully, and done by root, tell mountd the
	 * good news.  Pid checks are probably unnecessary, but don't hurt.
	 * XXX This should be done from kernel.
	 */
	if ((rval == 0 || new) && getuid() == 0 &&
	    (mountdfp = fopen(_PATH_MOUNTDPID, "r")) != NULL) {
		if (fscanf(mountdfp, "%d", &pid) == 1 &&
		    pid > 0 && kill(pid, SIGHUP) == -1 && errno != ESRCH)
			err(1, "signal mountd");
		(void)fclose(mountdfp);
	}

	return (rval);
}

int
hasopt(const char *mntopts, const char *option)
{
	int found;
	char *opt, *optbuf;

	if (mntopts == NULL)
		return (0);
	if ((optbuf = strdup(mntopts)) == NULL)
		err(1, NULL);
	found = 0;
	for (opt = optbuf; !found && opt != NULL; strsep(&opt, ","))
		found = !strncmp(opt, option, strlen(option));
	free(optbuf);
	return (found);
}

/*
 * Convert mount(2) flags to list of mount(8) options.
 */
char*
flags2opts(u_int32_t flags)
{
	char	*optlist;
	struct opt *p;

	optlist = NULL;
	for (p = optnames; p->o_opt; p++) {
		if (flags & p->o_opt && *p->o_optname)
			optlist = catopt(optlist, p->o_optname);
	}

	return(optlist);
}

int
mountfs(const char *vfstype, const char *spec, const char *name,
    const char *options, const char *mntopts, int skipmounted)
{
	char *cp;

	/* List of directories containing mount_xxx subcommands. */
	static const char *edirs[] = {
		_PATH_SBIN,
		_PATH_USRSBIN,
		NULL
	};
	const char **argv, **edir;
	struct statfs sf;
	pid_t pid;
	int argc, i, status, argvsize;
	char *optbuf, execname[PATH_MAX], mntpath[PATH_MAX];

	if (realpath(name, mntpath) == NULL) {
		warn("realpath %s", name);
		return (1);
	}

	name = mntpath;

	if (mntopts == NULL)
		mntopts = "";

	if (options == NULL) {
		if (*mntopts == '\0')
			options = "rw";
		else {
			options = mntopts;
			mntopts = "";
		}
	}

	/* options follows after mntopts, so they get priority over mntopts */
	if ((cp = strdup(mntopts)) == NULL)
		err(1, NULL);
	optbuf = catopt(cp, options);

	if (strcmp(name, "/") == 0) {
		if (!hasopt(optbuf, "update"))
			optbuf = catopt(optbuf, "update");
	} else if (skipmounted) {
		if (statfs(name, &sf) < 0) {
			warn("statfs %s", name);
			return (1);
		}
		/* XXX can't check f_mntfromname, thanks to mfs, etc. */
		if (strncmp(name, sf.f_mntonname, MNAMELEN) == 0 &&
		    strncmp(vfstype, sf.f_fstypename, MFSNAMELEN) == 0) {
			if (verbose) {
				printf("%s", sf.f_mntfromname);
				if (strncmp(sf.f_mntfromname,
				    sf.f_mntfromspec, MNAMELEN) != 0)
					printf(" (%s)", sf.f_mntfromspec);
				printf(" on %s type %.*s: %s\n",
				    sf.f_mntonname,
				    MFSNAMELEN, sf.f_fstypename,
				    "already mounted");
			}
			return (0);
		}
	}

	argvsize = 64;
	if((argv = reallocarray(NULL, argvsize, sizeof(char *))) == NULL)
		err(1, NULL);
	argc = 0;
	argv[argc++] = NULL;	/* this should be a full path name */
	mangle(optbuf, &argc, argv, argvsize - 4);
	argv[argc++] = spec;
	argv[argc++] = name;
	argv[argc] = NULL;

	if (debug) {
		(void)printf("exec: mount_%s", vfstype);
		for (i = 1; i < argc; i++)
			(void)printf(" %s", argv[i]);
		(void)printf("\n");
		free(optbuf);
		free(argv);
		return (0);
	}

	switch ((pid = fork())) {
	case -1:				/* Error. */
		warn("fork");
		free(optbuf);
		free(argv);
		return (1);
	case 0:					/* Child. */
		/* Go find an executable. */
		edir = edirs;
		do {
			(void)snprintf(execname,
			    sizeof(execname), "%s/mount_%s", *edir, vfstype);
			argv[0] = execname;
			execv(execname, (char * const *)argv);
			if (errno != ENOENT)
				warn("exec %s for %s", execname, name);
		} while (*++edir != NULL);

		if (errno == ENOENT)
			warn("no mount helper program found for %s", vfstype);
		_exit(1);
	default:				/* Parent. */
		free(optbuf);
		free(argv);

		if (waitpid(pid, &status, 0) < 0) {
			warn("waitpid");
			return (1);
		}

		if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				return (WEXITSTATUS(status));
		} else if (WIFSIGNALED(status)) {
			warnx("%s: %s", name, strsignal(WTERMSIG(status)));
			return (1);
		}

		if (verbose) {
			if (statfs(name, &sf) < 0) {
				warn("statfs %s", name);
				return (1);
			}
			prmount(&sf);
		}
		break;
	}

	return (0);
}

void
prmount(struct statfs *sf)
{
	int flags;
	struct opt *o;
	int f = 0;

	printf("%s", sf->f_mntfromname);
	if (verbose &&
	    strncmp(sf->f_mntfromname, sf->f_mntfromspec, MNAMELEN) != 0)
		printf(" (%s)", sf->f_mntfromspec);
	printf(" on %s type %.*s", sf->f_mntonname,
	    MFSNAMELEN, sf->f_fstypename);

	flags = sf->f_flags & MNT_VISFLAGMASK;
	if (verbose && !(flags & MNT_RDONLY))
		(void)printf("%s%s", !f++ ? " (" : ", ", "rw");
	for (o = optnames; flags && o->o_opt; o++)
		if (flags & o->o_opt) {
			if (!o->o_silent)
				(void)printf("%s%s", !f++ ? " (" : ", ",
				    o->o_name);
			flags &= ~o->o_opt;
		}
	if (flags)
		(void)printf("%sunknown flag%s %#x", !f++ ? " (" : ", ",
		    flags & (flags - 1) ? "s" : "", flags);


	if (verbose) {
		char buf[26];
		time_t t = sf->f_ctime;

		ctime_r(&t, buf);
		buf[24] = '\0';
		printf(", ctime=%s", buf);
	}

	/*
	 * Filesystem-specific options
	 * We only print the "interesting" values unless in verbose
	 * mode in order to keep the signal/noise ratio high.
	 */
	if (strcmp(sf->f_fstypename, MOUNT_NFS) == 0) {
		struct protoent *pr;
		struct nfs_args *nfs_args = &sf->mount_info.nfs_args;

		(void)printf("%s%s", !f++ ? " (" : ", ",
		    (nfs_args->flags & NFSMNT_NFSV3) ? "v3" : "v2");
		if (nfs_args->proto && (pr = getprotobynumber(nfs_args->proto)))
			(void)printf("%s%s", !f++ ? " (" : ", ", pr->p_name);
		else
			(void)printf("%s%s", !f++ ? " (" : ", ",
			    (nfs_args->sotype == SOCK_DGRAM) ? "udp" : "tcp");
		if (nfs_args->flags & NFSMNT_SOFT)
			(void)printf("%s%s", !f++ ? " (" : ", ", "soft");
		else if (verbose)
			(void)printf("%s%s", !f++ ? " (" : ", ", "hard");
		if (nfs_args->flags & NFSMNT_INT)
			(void)printf("%s%s", !f++ ? " (" : ", ", "intr");
		if (nfs_args->flags & NFSMNT_NOCONN)
			(void)printf("%s%s", !f++ ? " (" : ", ", "noconn");
		if (nfs_args->flags & NFSMNT_RDIRPLUS)
			(void)printf("%s%s", !f++ ? " (" : ", ", "rdirplus");
		if (verbose || nfs_args->wsize != NFS_WSIZE)
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "wsize", nfs_args->wsize);
		if (verbose || nfs_args->rsize != NFS_RSIZE)
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "rsize", nfs_args->rsize);
		if (verbose || nfs_args->readdirsize != NFS_READDIRSIZE)
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "rdirsize", nfs_args->readdirsize);
		if (verbose || nfs_args->timeo != 10) /* XXX */
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "timeo", nfs_args->timeo);
		if (verbose || nfs_args->retrans != NFS_RETRANS)
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "retrans", nfs_args->retrans);
		if (verbose || nfs_args->maxgrouplist != NFS_MAXGRPS)
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "maxgrouplist", nfs_args->maxgrouplist);
		if (verbose || nfs_args->readahead != NFS_DEFRAHEAD)
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "readahead", nfs_args->readahead);
		if (verbose) {
			(void)printf("%s%s=%d", !f++ ? " (" : ", ",
			    "acregmin", nfs_args->acregmin);
			(void)printf(", %s=%d",
			    "acregmax", nfs_args->acregmax);
			(void)printf(", %s=%d",
			    "acdirmin", nfs_args->acdirmin);
			(void)printf(", %s=%d",
			    "acdirmax", nfs_args->acdirmax);
		}
	} else if (strcmp(sf->f_fstypename, MOUNT_MFS) == 0) {
		int headerlen;
		long blocksize;
		char *header;

		header = getbsize(&headerlen, &blocksize);
		(void)printf("%s%s=%lu %s", !f++ ? " (" : ", ",
		    "size", sf->mount_info.mfs_args.size / blocksize, header);
	} else if (strcmp(sf->f_fstypename, MOUNT_MSDOS) == 0) {
		struct msdosfs_args *msdosfs_args = &sf->mount_info.msdosfs_args;

		if (verbose || msdosfs_args->uid || msdosfs_args->gid)
			(void)printf("%s%s=%u, %s=%u", !f++ ? " (" : ", ",
			    "uid", msdosfs_args->uid, "gid", msdosfs_args->gid);
		if (verbose || msdosfs_args->mask != 0755)
			(void)printf("%s%s=0%o", !f++ ? " (" : ", ",
			    "mask", msdosfs_args->mask);
		if (msdosfs_args->flags & MSDOSFSMNT_SHORTNAME)
			(void)printf("%s%s", !f++ ? " (" : ", ", "short");
		if (msdosfs_args->flags & MSDOSFSMNT_LONGNAME)
			(void)printf("%s%s", !f++ ? " (" : ", ", "long");
		if (msdosfs_args->flags & MSDOSFSMNT_NOWIN95)
			(void)printf("%s%s", !f++ ? " (" : ", ", "nowin95");
	} else if (strcmp(sf->f_fstypename, MOUNT_CD9660) == 0) {
		struct iso_args *iso_args = &sf->mount_info.iso_args;

		if (iso_args->flags & ISOFSMNT_NORRIP)
			(void)printf("%s%s", !f++ ? " (" : ", ", "norrip");
		if (iso_args->flags & ISOFSMNT_GENS)
			(void)printf("%s%s", !f++ ? " (" : ", ", "gens");
		if (iso_args->flags & ISOFSMNT_EXTATT)
			(void)printf("%s%s", !f++ ? " (" : ", ", "extatt");
	} else if (strcmp(sf->f_fstypename, MOUNT_TMPFS) == 0) {
		struct tmpfs_args *tmpfs_args = &sf->mount_info.tmpfs_args;

		if (verbose || tmpfs_args->ta_root_uid || tmpfs_args->ta_root_gid)
			(void)printf("%s%s=%u, %s=%u", !f++ ? " (" : ", ",
			    "uid", tmpfs_args->ta_root_uid, "gid", tmpfs_args->ta_root_gid);
		if (verbose || tmpfs_args->ta_root_mode != 040755)
			(void)printf("%s%s=%04o", !f++ ? " (" : ", ",
			    "mode", tmpfs_args->ta_root_mode & 07777);
		if (verbose || tmpfs_args->ta_size_max)
			(void)printf("%s%s=%lu", !f++ ? " (" : ", ",
			    "size", (unsigned long)tmpfs_args->ta_size_max);
		if (verbose || tmpfs_args->ta_nodes_max)
			(void)printf("%s%s=%lu", !f++ ? " (" : ", ",
			    "inodes", (unsigned long)tmpfs_args->ta_nodes_max);
	}
	(void)printf(f ? ")\n" : "\n");
}

struct statfs *
getmntpt(const char *name)
{
	struct statfs *mntbuf;
	int i, mntsize;

	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
	for (i = 0; i < mntsize; i++)
		if (strcmp(mntbuf[i].f_mntfromname, name) == 0 ||
		    strcmp(mntbuf[i].f_mntonname, name) == 0)
			return (&mntbuf[i]);
	return (NULL);
}

static enum { IN_LIST, NOT_IN_LIST } which;

int
selected(const char *type)
{
	char **av;

	/* If no type specified, it's always selected. */
	if (typelist == NULL)
		return (1);
	for (av = typelist; *av != NULL; ++av)
		if (!strncmp(type, *av, MFSNAMELEN))
			return (which == IN_LIST ? 1 : 0);
	return (which == IN_LIST ? 0 : 1);
}

void
maketypelist(char *fslist)
{
	int i;
	char *nextcp, **av;

	if ((fslist == NULL) || (fslist[0] == '\0'))
		errx(1, "empty type list");

	/*
	 * XXX
	 * Note: the syntax is "noxxx,yyy" for no xxx's and
	 * no yyy's, not the more intuitive "noxxx,noyyy".
	 */
	if (fslist[0] == 'n' && fslist[1] == 'o') {
		fslist += 2;
		which = NOT_IN_LIST;
	} else
		which = IN_LIST;

	/* Count the number of types. */
	for (i = 1, nextcp = fslist; (nextcp = strchr(nextcp, ',')); i++)
		++nextcp;

	/* Build an array of that many types. */
	if ((av = typelist = reallocarray(NULL, i + 1, sizeof(char *))) == NULL)
		err(1, NULL);
	av[0] = fslist;
	for (i = 1, nextcp = fslist; (nextcp = strchr(nextcp, ',')); i++) {
		*nextcp = '\0';
		av[i] = ++nextcp;
	}
	/* Terminate the array. */
	av[i] = NULL;
}

char *
catopt(char *s0, const char *s1)
{
	char *cp;

	if (s0 && *s0) {
		if (asprintf(&cp, "%s,%s", s0, s1) == -1)
			err(1, NULL);
	} else {
		if ((cp = strdup(s1)) == NULL)
			err(1, NULL);
	}

	free(s0);
	return cp;
}

void
mangle(char *options, int *argcp, const char **argv, int argcmax)
{
	char *p, *s;
	int argc;

	argcmax -= 2;
	argc = *argcp;
	for (s = options; argc <= argcmax && (p = strsep(&s, ",")) != NULL;)
		if (*p != '\0') {
			if (*p == '-') {
				argv[argc++] = p;
				p = strchr(p, '=');
				if (p) {
					*p = '\0';
					argv[argc++] = p + 1;
				}
			} else {
				argv[argc++] = "-o";
				argv[argc++] = p;
			}
		}

	*argcp = argc;
}

__dead void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: mount [-AadfNruvw] [-t type]\n"
	    "       mount [-dfrsuvw] special | node\n"
	    "       mount [-dfruvw] [-o options] [-t type] special node\n");
	exit(1);
}

int
disklabelcheck(struct fstab *fs)
{
	char *labelfs;

	if (strcmp(fs->fs_vfstype, "nfs") != 0 ||
	    strpbrk(fs->fs_spec, ":@@") == NULL) {
		labelfs = readlabelfs(fs->fs_spec, 0);
		if (labelfs == NULL ||
		    strcmp(labelfs, fs->fs_vfstype) == 0)
			return (0);
		if (strcmp(fs->fs_vfstype, "ufs") == 0 &&
		    strcmp(labelfs, "ffs") == 0) {
			warnx("%s: fstab uses outdated type 'ufs' -- fix please",
			    fs->fs_spec);
			return (0);
		}
		if (strcmp(fs->fs_vfstype, "mfs") == 0 &&
		    strcmp(labelfs, "ffs") == 0)
			return (0);
		warnx("%s: fstab type %s != disklabel type %s",
		    fs->fs_spec, fs->fs_vfstype, labelfs);
		return (1);
	}
	return (0);
}
@


1.70
log
@Some simple cleanup:

* check strdup for malloc failure
* remove obvious /* NOTREACHED */
* return instead of exit from main
* err(1, NULL) instead of err(1, "malloc")
* mark usage as __dead

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.69 2017/01/24 23:41:44 tb Exp $	*/
a111 3
	if (pledge("stdio rpath disklabel proc exec", NULL) == -1)
		err(1, "pledge");

d168 19
d280 1
a280 17
		/*
		 * If -t flag has not been specified, and spec contains either
		 * a ':' or a '@@' then assume that an NFS filesystem is being
		 * specified ala Sun.  If not, check the disklabel for a
		 * known filesystem type.
		 */
		if (typelist == NULL) {
			if (strpbrk(argv[0], ":@@") != NULL)
				vfstype = "nfs";
			else {
				char *labelfs = readlabelfs(argv[0], 0);
				if (labelfs != NULL)
					vfstype = labelfs;
			}
		}
		rval = mountfs(vfstype,
		    argv[0], argv[1], options, NULL, 0);
@


1.69
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.68 2016/09/10 16:53:30 natano Exp $	*/
a166 1
			/* NOTREACHED */
d214 1
a214 1
			exit(rval);
d237 2
a238 3
				fs = malloc(sizeof(*fs));
				if (fs == NULL)
					err(1, "malloc");
a283 1
		/* NOTREACHED */
d299 1
a299 1
	exit(rval);
d310 2
a311 1
	optbuf = strdup(mntopts);
d341 2
d375 3
a377 1
	optbuf = catopt(strdup(mntopts), options);
d406 1
a406 1
		err(1, "malloc");
a444 1
		/* NOTREACHED */
d677 1
a677 1
		err(1, "malloc");
d695 4
a698 2
	} else
		cp = strdup(s1);
d730 1
a730 1
void
a732 1

@


1.68
log
@Add a noperm mount flag for FFS to be used for building release sets
without root privileges. This is only the kernel/mount flag; additional
work in the build Makefile's will be necessary such that the files in
$DESTDIR are created with correct permissions.

tedu couldn't find anything wrong with it in a quick review
idea & ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.67 2016/09/04 19:45:27 akfaew Exp $	*/
d97 1
a97 1
	{ MNT_SOFTDEP,		0,	"softdep", 		"softdep" },
a763 1

@


1.67
log
@strlen + malloc + snprintf == asprintf

ok martijn@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.66 2016/06/26 19:53:40 tedu Exp $	*/
d91 1
@


1.66
log
@somebody forgot to look at format string warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.65 2016/06/20 08:36:36 ajacoutot Exp $	*/
a687 1
	size_t i;
d691 1
a691 2
		i = strlen(s0) + strlen(s1) + 1 + 1;
		if ((cp = malloc(i)) == NULL)
a692 1
		(void)snprintf(cp, i, "%s,%s", s0, s1);
d697 1
a697 1
	return (cp);
@


1.65
log
@Add a bit more verbosity to tmpfs mount(8) output.

ok millert@@
feedback/ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.64 2016/05/27 19:45:04 deraadt Exp $	*/
d611 1
a611 1
			    "size", tmpfs_args->ta_size_max);
d614 1
a614 1
			    "inodes", tmpfs_args->ta_nodes_max);
@


1.64
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.63 2016/05/25 13:56:37 deraadt Exp $	*/
d600 15
@


1.63
log
@remove knowledge of MNT_EXKERB
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.62 2016/05/21 18:11:36 natano Exp $	*/
d91 1
@


1.62
log
@Remove the -x flag from mount_msdos and always assume the execute bit
for readable directories, while making it subject to the mask option
(-m in mount_msdos), so it is still possible to mount with
non-executable directories, but with semantics that are easier to
comprehend.

This makes directory listings with default mount options work again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.61 2015/11/23 23:26:59 deraadt Exp $	*/
a82 1
	{ MNT_EXKERB,		1,	"kerberos uid mapping",	"" },
@


1.61
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.60 2015/01/16 06:39:59 deraadt Exp $	*/
a590 2
		if (msdosfs_args->flags & MSDOSFSMNT_ALLOWDIRX)
			(void)printf("%s%s", !f++ ? " (" : ", ", "direxec");
@


1.60
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.59 2014/09/08 01:47:05 guenther Exp $	*/
d110 3
@


1.59
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.58 2014/07/17 06:25:12 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d51 1
d109 1
a109 1
	char *options, mntpath[MAXPATHLEN];
d349 1
a349 1
	char *optbuf, execname[MAXPATHLEN], mntpath[MAXPATHLEN];
@


1.58
log
@Convert a couple calloc()s that were originally malloc()s to reallocarray()s.
The child after fork() should use _exit() instead of exit().
Fix comment typo.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.57 2014/07/15 11:25:22 jmc Exp $	*/
a597 7
	} else if (strcmp(sf->f_fstypename, MOUNT_PROCFS) == 0) {
		struct procfs_args *procfs_args = &sf->mount_info.procfs_args;

		if (verbose)
			(void)printf("version %d", procfs_args->version);
		if (procfs_args->flags & PROCFSMNT_LINUXCOMPAT)
			(void)printf("%s%s", !f++ ? " (" : ", ", "linux");
@


1.57
log
@add -N to usage()/SYNOPSIS and tweak previous;
rather than adding "net" to the -o list, claudio points out that
-o net and -o noauto are really noops, so remove "noauto";

help/ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.56 2014/07/13 12:01:30 claudio Exp $	*/
d398 1
a398 1
	if((argv = calloc(argvsize, sizeof(char *))) == NULL)
d437 1
a437 1
		exit(1);
d509 1
a509 1
	 * We only print the "interesting" values unless in verboser
d664 2
a665 2
	if ((av = typelist = calloc(i + 1, sizeof(char *))) == NULL)
		err(1, NULL);
@


1.56
log
@Introduce a -N option to mount and a 'net' mount option.
File systems marked with net will not be mounted by default.
mount -a -N will mount all those file systems instead.
This will be used to mark file systems needing network to work -- in
other words which depend on iscsid.
"Get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.55 2014/06/24 02:32:43 daniel Exp $	*/
d724 1
a724 1
	    "usage: mount [-Aadfruvw] [-t type]\n"
@


1.55
log
@remove the noaccesstime synonym for noatime which was previously added for BSD/OS compatibility.

ok deraadt@@, miod@@i, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.54 2013/04/21 11:05:14 jsing Exp $	*/
d57 1
d113 1
a113 1
	while ((ch = getopt(argc, argv, "Aadfo:rswt:uv")) != -1)
d128 3
d179 10
@


1.54
log
@When mount(1) is run in verbose mode, display f_mntfromspec if it differs
from f_mntfromname.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.53 2012/05/29 20:01:32 landry Exp $	*/
a86 1
	{ MNT_NOATIME,		0,	"noaccesstime",		"" },
@


1.53
log
@Make 'mount nfssrv:/path' without mount point work again :
- dont error out in realpath() check if argv contains @@ or : (ie, is
  a nfs remote path)
- relax getfsspec() call so that it succeeds for nfs remote paths too,
  not only for duid devices.
Now we behave like Linux & FreeBSD (at least)..
Prompted by a diff from giovanni@@ for xfce4-mount
ok jsing@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.52 2011/04/12 14:51:40 jsing Exp $	*/
d370 7
a376 3
			if (verbose)
				(void)printf("%s on %s type %.*s: %s\n",
				    sf.f_mntfromname, sf.f_mntonname,
d379 1
d463 5
a467 1
	(void)printf("%s on %s type %.*s", sf->f_mntfromname, sf->f_mntonname,
@


1.52
log
@Make mount work when the special is provided as a DUID.

Diff from Alexander Polakov.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.50 2009/10/27 23:59:33 deraadt Exp $	*/
d204 1
a204 1
		if (realpath(*argv, mntpath) == NULL)
d236 1
a236 2
			    (isduid(*argv, 0) == 0 ||
			    (fs = getfsspec(*argv)) == NULL))
@


1.51
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d235 3
a237 1
			    (fs = getfsspec(mntpath)) == NULL)
@


1.50
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.49 2009/05/12 23:25:08 thib Exp $	*/
d96 1
a96 1
	{ NULL,			0,	"",			"" }
@


1.49
log
@don't define _KERNEL. Theres no need and its gross.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.48 2007/11/17 17:18:32 krw Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mount.c	8.19 (Berkeley) 4/19/94";
#else
static char rcsid[] = "$OpenBSD: mount.c,v 1.48 2007/11/17 17:18:32 krw Exp $";
#endif
#endif /* not lint */
@


1.48
log
@Don't err() out if a fstab line refers to a non-existant mount point.
Just print an error message and allow processing to continue. This
fixes 'mount -a' so it mounts all the filesystems it can rather than
skipping all fstab entries after a non-existant mount point.

This also brings us more into line with NetBSD and FreeBSD behaviour.

ok deraadt@@ jsing@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.47 2007/10/16 20:19:27 sobrado Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.47 2007/10/16 20:19:27 sobrado Exp $";
a53 1
#define _KERNEL
a54 1
#undef _KERNEL
@


1.47
log
@sync the synopsis and usage of commands

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.46 2007/09/02 15:19:24 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.46 2007/09/02 15:19:24 deraadt Exp $";
d378 4
a381 2
		if (statfs(name, &sf) < 0)
			err(1, "statfs %s", name);
@


1.46
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.45 2007/06/01 05:37:14 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.45 2007/06/01 05:37:14 deraadt Exp $";
d715 3
a717 5
	    "usage: mount %s %s\n       mount %s\n       mount %s\n",
	    "[-dfruvw] [-o options] [-t ffs | external_type]",
	    "special node",
	    "[-Aadfruvw] [-t ffs | external_type]",
	    "[-dfrsuvw] special | node");
@


1.45
log
@remove crufty adosfs.  everytime we try to change a vfs layer interface,
adosfs has the issue and in an entirely different way.  noone uses this
code so this is hte best way to handle the problem
diff from pedro who went to sleep but we need to move ahead; ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.44 2006/12/15 03:04:24 krw Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.44 2006/12/15 03:04:24 krw Exp $";
d393 1
a393 1
	if((argv = malloc(argvsize * sizeof(char*))) == NULL)
d655 1
a655 1
	if ((av = typelist = malloc((i + 1) * sizeof(char *))) == NULL)
@


1.44
log
@Nuke GEMDOSFS. Unused part of unused atari port. Simplifies
MSDOSFS code. Eliminates -G option to mount_msdos.

Nit detection by gwk@@, tom@@, jmc@@.

ok weingart@@ tom@@ thib@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.43 2006/12/06 17:54:22 thib Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.43 2006/12/06 17:54:22 thib Exp $";
a562 9
	} else if (strcmp(sf->f_fstypename, MOUNT_ADOSFS) == 0) {
		struct adosfs_args *adosfs_args = &sf->mount_info.adosfs_args;

		if (verbose || adosfs_args->uid || adosfs_args->gid)
			(void)printf("%s%s=%u, %s=%u", !f++ ? " (" : ", ",
			    "uid", adosfs_args->uid, "gid", adosfs_args->gid);
		if (verbose || adosfs_args->mask != 0755)
			(void)printf("%s%s=0%o", !f++ ? " (" : ", ",
			    "mask", adosfs_args->mask);
@


1.43
log
@print readdirplus (rdplus) info for nfs mounts.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.42 2006/04/08 01:41:32 ray Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.42 2006/04/08 01:41:32 ray Exp $";
a586 2
		if (msdosfs_args->flags & MSDOSFSMNT_GEMDOSFS)
			(void)printf("%s%s", !f++ ? " (" : ", ", "gem");
@


1.42
log
@Memory leak on fork error plus change time variable to prevent
shadowing time(3) function.

From NetBSD from Coverity CID 1688.

OK jaredy@@ and moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.41 2006/03/12 20:01:31 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.41 2006/03/12 20:01:31 otto Exp $";
d522 2
@


1.41
log
@Add the -s flag, meaning: skip mount if the file system is
already mounted. This flag is very handy when mounting mfs
partitions. The -s flag will be used in an upcoming etc/rc diff.
ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.40 2005/05/26 20:16:21 fgsch Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.40 2005/05/26 20:16:21 fgsch Exp $";
d416 1
d491 1
a491 1
		time_t time = sf->f_ctime;
d493 1
a493 1
		ctime_r(&time, buf);
@


1.40
log
@remove traces from union et al; pedro@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.39 2005/05/26 01:37:49 pedro Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.39 2005/05/26 01:37:49 pedro Exp $";
d71 1
a71 1
int	debug, verbose;
d129 1
a129 1
	while ((ch = getopt(argc, argv, "Aadfo:rwt:uv")) != -1)
d152 3
d260 1
a260 1
		    mntonname, options, fs->fs_mntops, 0);
d727 1
a727 1
	    "[-dfruvw] special | node");
@


1.39
log
@remove reference to MNT_UNION
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.38 2005/04/08 20:09:36 jaredy Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.38 2005/04/08 20:09:36 jaredy Exp $";
d377 1
a377 1
		/* XXX can't check f_mntfromname, thanks to mfs, union, etc. */
@


1.38
log
@Sync with recent realpath(3) changes:  on failure, don't use the second
argument "resolved", since it is undefined.

ok and help millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.37 2004/11/13 21:45:50 miod Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.37 2004/11/13 21:45:50 miod Exp $";
a111 1
	{ MNT_UNION,		0,	"union",		"" },
@


1.37
log
@Let mount -a mount mfs systems shadowing a disk partition, if disklabel reports
the partition type as ffs. Makes people's life easier on platforms where
disklabel does not record partition types and hardcodes values for them,
such as sparc and sparc64.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.36 2004/09/15 15:15:16 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.36 2004/09/15 15:15:16 otto Exp $";
d219 1
a219 1
			err(1, "realpath %s", mntpath);
d351 1
a351 1
		warn("realpath %s", mntpath);
@


1.36
log
@print attr cache parameters in verbose mode. ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.35 2004/03/16 21:27:47 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.35 2004/03/16 21:27:47 otto Exp $";
d746 3
@


1.35
log
@Do not signal mountd when just showing mounts. Fixes PR 3695, although
mountd may still act on out of date mount info.
ok cedric@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.34 2003/10/01 06:17:31 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.34 2003/10/01 06:17:31 deraadt Exp $";
d540 10
@


1.34
log
@free without test
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.33 2003/08/05 20:48:59 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.33 2003/08/05 20:48:59 tedu Exp $";
d211 1
@


1.33
log
@print info about procfs now that it's there to look at
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.32 2003/07/29 18:38:36 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.32 2003/07/29 18:38:36 deraadt Exp $";
d675 1
a675 2
	if (s0)
		free(s0);
@


1.32
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.31 2003/06/02 20:06:15 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.31 2003/06/02 20:06:15 millert Exp $";
d584 7
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.30 2003/04/20 03:09:55 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.30 2003/04/20 03:09:55 tedu Exp $";
d291 1
a291 1
		     pid > 0 && kill(pid, SIGHUP) == -1 && errno != ESRCH)
d383 1
a383 1
			            MFSNAMELEN, sf.f_fstypename,
@


1.30
log
@print "direxec" when it's enabled on msdosfs.
from Thorsten Glaser
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.29 2002/11/06 14:14:48 gluk Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.29 2002/11/06 14:14:48 gluk Exp $";
@


1.29
log
@- make -u identical with "-o update". The same for -f,-r,-w.
- mount point may be specified with trailing slash in all cases
  (including fstab).
- mount doesn't look in fstab at "-o update". So update doesn't fails
  for fs which isn't listed in fstab.
- 'mount -o update' only changes options which supplied via command line
  and preserves options which currently in use.
- fix argv[] buffer overflow in mountfs/mangle.
- correct usage.
- Other improvements and fixes which I can't remember.

  Thanks to everyone who test this patch.

miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.28 2002/07/03 22:32:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.28 2002/07/03 22:32:33 deraadt Exp $";
d577 2
@


1.28
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.27 2002/06/09 08:13:07 todd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.27 2002/06/09 08:13:07 todd Exp $";
d80 1
d85 2
a86 2
void	mangle(char *, int *, const char **);
int	mountfs(const char *, const char *, const char *, int, const char *,
d90 1
a90 1
void	usage(void);
d97 1
d99 19
a117 19
	{ MNT_ASYNC,		0,	"asynchronous" },
	{ MNT_DEFEXPORTED,	1,	"exported to the world" },
	{ MNT_EXKERB,		1,	"kerberos uid mapping" },
	{ MNT_EXPORTED,		0,	"NFS exported" },
	{ MNT_EXPORTANON,	1,	"anon uid mapping" },
	{ MNT_EXRDONLY,		1,	"exported read-only" },
	{ MNT_LOCAL,		0,	"local" },
	{ MNT_NOATIME,		0,	"noatime" },
	{ MNT_NOATIME,		0,	"noaccesstime" },
	{ MNT_NODEV,		0,	"nodev" },
	{ MNT_NOEXEC,		0,	"noexec" },
	{ MNT_NOSUID,		0,	"nosuid" },
	{ MNT_QUOTA,		0,	"with quotas" },
	{ MNT_RDONLY,		0,	"read-only" },
	{ MNT_ROOTFS,		1,	"root file system" },
	{ MNT_SYNCHRONOUS,	0,	"synchronous" },
	{ MNT_SOFTDEP,		0,	"softdep" },
	{ MNT_UNION,		0,	"union" },
	{ NULL }
d128 2
a129 2
	int all, ch, forceall, i, init_flags, mntsize, rval;
	char *options;
d131 1
a131 1
	all = forceall = init_flags = 0;
d146 2
a147 1
			init_flags |= MNT_FORCE;
d154 2
a155 1
			init_flags |= MNT_RDONLY;
d164 2
a165 1
			init_flags |= MNT_UPDATE;
d171 2
a172 1
			init_flags &= ~MNT_RDONLY;
d187 1
d201 1
a201 1
				    fs->fs_file, init_flags, options,
d204 2
d216 1
a216 1
		exit(rval);
d221 4
a224 2
		if (init_flags & MNT_UPDATE) {
			if ((mntbuf = getmntpt(*argv)) == NULL)
d228 21
a248 5
			if ((fs = getfsfile(mntbuf->f_mntonname)) == NULL)
				errx(1, "can't find fstab entry for %s.",
				    *argv);
			/* If it's an update, ignore the fstab file options. */
			fs->fs_mntops = NULL;
d251 3
a253 4
			if ((fs = getfsfile(*argv)) == NULL &&
			    (fs = getfsspec(*argv)) == NULL)
				errx(1,
				    "%s: unknown special file or file system.",
d261 1
a261 1
		    mntonname, init_flags, options, fs->fs_mntops, 0);
a278 1

d280 1
a280 1
		    argv[0], argv[1], init_flags, options, NULL, 0);
d290 1
d292 1
a292 1
	if (rval == 0 && getuid() == 0 &&
d306 1
a306 1
	int negative, found;
d309 2
a310 5
	if (option[0] == 'n' && option[1] == 'o') {
		negative = 1;
		option += 2;
	} else
		negative = 0;
d313 2
a314 7
	for (opt = optbuf; (opt = strtok(opt, ",")) != NULL; opt = NULL) {
		if (opt[0] == 'n' && opt[1] == 'o') {
			if (!strcasecmp(opt + 2, option))
				found = negative;
		} else if (!strcasecmp(opt, option))
			found = !negative;
	}
d319 18
d338 1
a338 1
mountfs(const char *vfstype, const char *spec, const char *name, int flags,
d347 1
a347 1
	const char *argv[100], **edir;
d350 1
a350 1
	int argc, i, status;
a351 1
	char mountname[MAXPATHLEN];
d354 1
a354 1
		warn("realpath %s", name);
d362 1
d371 2
d375 6
a380 7
	if (strcmp(name, "/") == 0)
		flags |= MNT_UPDATE;
	else if (skipmounted) {
		if (statfs(name, &sf) < 0) {
			warn("statfs %s", name);
			return (1);
		}
a391 15
	if (flags & MNT_FORCE)
		optbuf = catopt(optbuf, "force");
	if (flags & MNT_RDONLY)
		optbuf = catopt(optbuf, "ro");
	/*
	 * XXX
	 * The mount_mfs (newfs) command uses -o to select the
	 * optimisation mode.  We don't pass the default "-o rw"
	 * for that reason.
	 */
	if (flags & MNT_UPDATE)
		optbuf = catopt(optbuf, "update");

	(void)snprintf(mountname,
	    sizeof(mountname), "mount_%s", vfstype);
d393 3
d397 2
a398 2
	argv[argc++] = mountname;
	mangle(optbuf, &argc, argv);
d408 2
d424 1
d436 1
d632 1
a632 1
	 * no yyy's, not the more intuitive "noyyy,noyyy".
d676 1
a676 1
mangle(char *options, int *argcp, const char **argv)
d681 1
d683 1
a683 1
	for (s = options; (p = strsep(&s, ",")) != NULL;)
d690 1
a690 1
					argv[argc++] = p+1;
d692 1
a692 1
			} else if (strcmp(p, "rw") != 0) {
d709 1
a709 1
	    "[-adfruvw] [-t ffs | external_type]",
@


1.27
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.26 2002/02/17 19:42:28 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.26 2002/02/17 19:42:28 millert Exp $";
d119 1
a119 3
main(argc, argv)
	int argc;
	char * const argv[];
d278 1
a278 2
hasopt(mntopts, option)
	const char *mntopts, *option;
d302 2
a303 3
mountfs(vfstype, spec, name, flags, options, mntopts, skipmounted)
	const char *vfstype, *spec, *name, *options, *mntopts;
	int flags, skipmounted;
d436 1
a436 2
prmount(sf)
	struct statfs *sf;
d562 1
a562 2
getmntpt(name)
	const char *name;
d578 1
a578 2
selected(type)
	const char *type;
d592 1
a592 2
maketypelist(fslist)
	char *fslist;
d628 1
a628 3
catopt(s0, s1)
	char *s0;
	const char *s1;
d647 1
a647 4
mangle(options, argcp, argv)
	char *options;
	int *argcp;
	const char **argv;
d672 1
a672 1
usage()
d676 5
a680 5
		"usage: mount %s %s\n       mount %s\n       mount %s\n",
		"[-dfruvw] [-o options] [-t ffs | external_type]",
			"special node",
		"[-adfruvw] [-t ffs | external_type]",
		"[-dfruvw] special | node");
d685 1
a685 2
disklabelcheck(fs)
	struct fstab *fs;
@


1.26
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.25 2002/02/16 21:27:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.25 2002/02/16 21:27:35 millert Exp $";
d461 1
a461 1
		(void)printf("%sunknown flag%s %#x", !f++ ? " (" : ", ", 
@


1.25
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.24 2002/01/18 01:37:27 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.24 2002/01/18 01:37:27 mickey Exp $";
d85 2
a86 2
int	mountfs __P((const char *, const char *, const char *,
			int, const char *, const char *, int));
@


1.24
log
@print out the ctime of a mount when verbose; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.23 2001/12/16 22:45:37 miod Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.23 2001/12/16 22:45:37 miod Exp $";
d78 2
a79 2
int	selected __P((const char *));
char   *catopt __P((char *, const char *));
d81 4
a84 4
       *getmntpt __P((const char *));
int	hasopt __P((const char *, const char *));
void	maketypelist __P((char *));
void	mangle __P((char *, int *, const char **));
d87 3
a89 3
void	prmount __P((struct statfs *));
int	disklabelcheck __P((struct fstab *));
void	usage __P((void));
@


1.23
log
@Provide a more useful error message if no mount_foo helper program can be
found.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.22 2001/06/24 17:03:16 csapuntz Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.22 2001/06/24 17:03:16 csapuntz Exp $";
d463 10
@


1.22
log
@

Get rid of NQNFS options
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.21 2001/03/12 01:30:24 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.21 2001/03/12 01:30:24 deraadt Exp $";
d407 1
a407 1
			warn("exec %s for %s", execname, name);
@


1.21
log
@typo; maurice@@maurice.wan.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.20 1999/05/31 17:34:42 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.20 1999/05/31 17:34:42 millert Exp $";
a60 1
#include <nfs/nqnfs.h>
a473 1
		    (nfs_args->flags & NFSMNT_NQNFS) ? "nqnfs" :
a508 8
		if (nfs_args->flags & NFSMNT_NQNFS) {
			if (verbose || nfs_args->leaseterm != NQ_DEFLEASE)
				(void)printf("%s%s=%d", !f++ ? " (" : ", ",
				    "leaseterm", nfs_args->leaseterm);
			if (verbose || nfs_args->deadthresh != NQ_DEADTHRESH)
				(void)printf("%s%s=%d", !f++ ? " (" : ", ",
				    "deadthresh", nfs_args->deadthresh);
		}
@


1.20
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.19 1998/02/01 18:49:08 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.19 1998/02/01 18:49:08 mickey Exp $";
d92 1
a92 1
/* Map from mount otions to printable formats. */
@


1.19
log
@add softdep displaying in mount listing
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.18 1997/06/18 09:57:04 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.18 1997/06/18 09:57:04 deraadt Exp $";
d53 1
d56 7
d66 1
d446 1
a446 1
	int f;
d452 3
a454 1
	for (f = 0, o = optnames; flags && o->o_opt; o++)
d464 99
d667 1
a667 1
		if (*p != '\0')
d679 1
@


1.18
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.17 1997/05/28 21:28:36 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.17 1997/05/28 21:28:36 deraadt Exp $";
d105 1
@


1.17
log
@complain if ufs is spotted in /etc/fstab
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.16 1997/03/10 04:27:42 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.16 1997/03/10 04:27:42 millert Exp $";
d261 1
a261 1
		if (fscanf(mountdfp, "%ld", &pid) == 1 &&
d381 1
a381 1
	switch (pid = fork()) {
d509 1
a509 1
	for (i = 1, nextcp = fslist; nextcp = strchr(nextcp, ','); i++)
d516 1
a516 1
	for (i = 1, nextcp = fslist; nextcp = strchr(nextcp, ','); i++) {
@


1.16
log
@Allow noaccesstime as a synonym for noatime.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.15 1997/03/09 19:28:01 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.15 1997/03/09 19:28:01 millert Exp $";
d597 6
@


1.15
log
@noatime changed to noaccesstime for consistency with BSD/OS.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.14 1997/03/02 09:38:28 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.14 1997/03/02 09:38:28 millert Exp $";
d96 1
@


1.14
log
@Add noatime option to not update atime on files in a filesystem (unless
ctime or mtime has changed).  Useful for laptops and news servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.13 1997/01/15 23:41:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.13 1997/01/15 23:41:15 millert Exp $";
d96 1
a96 1
	{ MNT_NOATIME,		0,	"noatime" },
@


1.13
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.12 1996/12/23 08:38:49 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.12 1996/12/23 08:38:49 downsj Exp $";
d96 1
@


1.12
log
@1 -> 0
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.11 1996/12/23 07:46:53 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.11 1996/12/23 07:46:53 downsj Exp $";
d123 1
a123 1
	while ((ch = getopt(argc, argv, "Aadfo:rwt:uv")) != EOF)
@


1.11
log
@readlabelfs()
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.10 1996/12/09 13:25:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.10 1996/12/09 13:25:26 deraadt Exp $";
d591 1
a591 1
		labelfs = readlabelfs(fs->fs_spec, 1);
@


1.10
log
@for -a option, refuse if disklabel type != fstab type
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.9 1996/12/04 21:29:29 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.9 1996/12/04 21:29:29 downsj Exp $";
d239 1
a239 1
				char *labelfs = readlabelfs(argv[0]);
d591 1
a591 1
		labelfs = readlabelfs(fs->fs_spec);
@


1.9
log
@fix
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.8 1996/12/04 09:45:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.8 1996/12/04 09:45:39 deraadt Exp $";
d80 1
d182 2
d582 20
@


1.8
log
@nice argv[0], please do not bite me
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.7 1996/12/03 01:04:44 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.7 1996/12/03 01:04:44 downsj Exp $";
d237 1
a237 1
				if (labelfs != "")
@


1.7
log
@readlabelfs() moves to libutil, and return value changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.6 1996/11/12 09:09:19 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.6 1996/11/12 09:09:19 downsj Exp $";
d305 1
a305 1
	char *optbuf, execname[MAXPATHLEN + 1], mntpath[MAXPATHLEN];
d358 3
d362 1
a362 1
	argv[argc++] = vfstype;
d376 1
a376 1
	switch (pid = vfork()) {
d378 1
a378 1
		warn("vfork");
a386 3
			(void)snprintf(mountname,
			    sizeof(mountname), "mount_%s", vfstype);
			argv[0] = mountname;
@


1.6
log
@fix
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.5 1996/11/12 08:46:13 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.5 1996/11/12 08:46:13 downsj Exp $";
d63 1
a81 2
char   *readlabelfs __P((char *));

d237 1
a237 1
				if (labelfs != NULL)
@


1.5
log
@Prelimary label-groking code for mount; makes -t close to obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.4 1996/06/23 14:31:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.4 1996/06/23 14:31:12 deraadt Exp $";
d233 8
a240 6
		if (typelist == NULL && strpbrk(argv[0], ":@@") != NULL)
			vfstype = "nfs";
		else {
			char *labelfs = readlabelfs(argv[0]);
			if (labelfs != NULL)
				vfstype = labelfs;
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.c,v 1.24 1995/11/18 03:34:29 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mount.c,v 1.24 1995/11/18 03:34:29 cgd Exp $";
d81 2
d230 2
a231 1
		 * specified ala Sun.
d235 6
@


1.3
log
@argv[0] for children is mount_XXX instead of simply XXX
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: mount.c,v 1.24 1995/11/18 03:34:29 cgd Exp $";
@


1.2
log
@from netbsd:
Recognize all mount flags exported from the kernel (but only print the
ones that we used to print).  Note unrecognized flags(s) when printing
mount list.
@
text
@d295 1
d373 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mount.c,v 1.23 1995/08/22 19:58:33 jtc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: mount.c,v 1.23 1995/08/22 19:58:33 jtc Exp $";
d83 1
d86 15
a100 10
	{ MNT_ASYNC,		"asynchronous" },
	{ MNT_EXPORTED,		"NFS exported" },
	{ MNT_LOCAL,		"local" },
	{ MNT_NODEV,		"nodev" },
	{ MNT_NOEXEC,		"noexec" },
	{ MNT_NOSUID,		"nosuid" },
	{ MNT_QUOTA,		"with quotas" },
	{ MNT_RDONLY,		"read-only" },
	{ MNT_SYNCHRONOUS,	"synchronous" },
	{ MNT_UNION,		"union" },
d424 3
a426 1
			(void)printf("%s%s", !f++ ? " (" : ", ", o->o_name);
d429 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
