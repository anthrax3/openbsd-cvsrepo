head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	ldattach_20071103:1.1.1.1
	mbalmer:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.11.26.11.18.43;	author mpi;	state Exp;
branches;
next	1.16;
commitid	w5BGwu0VUCmpZ1gz;

1.16
date	2015.01.15.00.48.10;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	1Hf1LpAl69ZwQUMK;

1.15
date	2014.08.10.02.09.35;	author guenther;	state Exp;
branches;
next	1.14;
commitid	xDZCv0CvLY92zdA0;

1.14
date	2009.10.31.02.53.11;	author ckuethe;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.28.05.14.00;	author ckuethe;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.06.18.21.23;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.12.03.52.48;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.11.23.12.15;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.10.18.28.58;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.10.00.25.03;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.09.23.15.55;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.09.21.06.10;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.28.11.22.12;	author mbalmer;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.05.17.33.28;	author mbalmer;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.13.19.32.34;	author mbalmer;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.03.15.33.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.03.15.22.54;	author mbalmer;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.03.15.22.54;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove leftovers of line disciplines that are no more.

ok mikeb@@
@
text
@/*	$OpenBSD: ldattach.c,v 1.16 2015/01/15 00:48:10 deraadt Exp $	*/

/*
 * Copyright (c) 2007, 2008 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Attach a line disciplines to a tty(4) device either from the commandline
 * or from init(8) (using entries in /etc/ttys).  Optionally pass the data
 * received on the tty(4) device to the master device of a pty(4) pair.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/limits.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <termios.h>
#include <unistd.h>
#include <util.h>

#include "atomicio.h"

__dead void	usage(void);
void		relay(int, int);
void		coroner(int);

volatile sig_atomic_t dying = 0;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-27dehmop] [-s baudrate] "
	    "[-t cond] discipline device\n", __progname);
	exit(1);
}

/* relay data between two file descriptors */
void
relay(int device, int pty)
{
	struct pollfd pfd[2];
	int nfds, n, nread;
	char buf[128];

	pfd[0].fd = device;
	pfd[1].fd = pty;

	while (!dying) {
		pfd[0].events = POLLRDNORM;
		pfd[1].events = POLLRDNORM;
		nfds = poll(pfd, 2, INFTIM);
		if (nfds == -1) {
			syslog(LOG_ERR, "polling error");
			exit(1);
		}
		if (nfds == 0)	/* should not happen */
			continue;

		if (pfd[1].revents & POLLHUP) {	/* slave device not connected */
			sleep(1);
			continue;
		}

		for (n = 0; n < 2; n++) {
			if (!(pfd[n].revents & POLLRDNORM))
				continue;

			nread = read(pfd[n].fd, buf, sizeof(buf));
			if (nread == -1) {
				syslog(LOG_ERR, "error reading from %s: %m",
				    n ? "pty" : "device");
				exit(1);
			}
			if (nread == 0) {
				syslog(LOG_ERR, "eof during read from %s: %m",
				     n ? "pty" : "device");
				exit(1);
			}
			atomicio(vwrite, pfd[1 - n].fd, buf, nread);
		}
	}
}

int
main(int argc, char *argv[])
{
	struct termios tty;
	struct tstamps tstamps;
	const char *errstr;
	sigset_t sigset;
	pid_t ppid;
	int ch, fd, master = -1, slave, pty = 0, ldisc, nodaemon = 0;
	int bits = 0, parity = 0, stop = 0, flowcl = 0, hupcl = 1;
	speed_t speed = 0;
	char devn[32], ptyn[32], *dev, *disc;

	tstamps.ts_set = tstamps.ts_clr = 0;

	if ((ppid = getppid()) == 1)
		nodaemon = 1;

	while ((ch = getopt(argc, argv, "27dehmops:t:")) != -1) {
		switch (ch) {
		case '2':
			stop = 2;
			break;
		case '7':
			bits = 7;
			break;
		case 'd':
			nodaemon = 1;
			break;
		case 'e':
			parity = 'e';
			break;
		case 'h':
			flowcl = 1;
			break;
		case 'm':
			hupcl = 0;
			break;
		case 'o':
			parity = 'o';
			break;
		case 'p':
			pty = 1;
			break;
		case 's':
			speed = (speed_t)strtonum(optarg, 0, UINT_MAX, &errstr);
			if (errstr) {
				if (ppid != 1)
					errx(1,  "speed is %s: %s", errstr,
					    optarg);
				else
					goto bail_out;
			}
			break;
		case 't':
			if (!strcasecmp(optarg, "dcd"))
				tstamps.ts_set |= TIOCM_CAR;
			else if (!strcasecmp(optarg, "!dcd"))
				tstamps.ts_clr |= TIOCM_CAR;
			else if (!strcasecmp(optarg, "cts"))
				tstamps.ts_set |= TIOCM_CTS;
			else if (!strcasecmp(optarg, "!cts"))
				tstamps.ts_clr |= TIOCM_CTS;
			else {
				if (ppid != 1)
					errx(1, "'%s' not supported for "
					    "timestamping", optarg);
				else
					goto bail_out;
			}
			break;
		default:
			if (ppid != -1)
				usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (ppid != 1 && argc != 2)
		usage();

	disc = *argv++;
	dev = *argv;
	if (strncmp(_PATH_DEV, dev, sizeof(_PATH_DEV) - 1)) {
		(void)snprintf(devn, sizeof(devn), "%s%s", _PATH_DEV, dev);
		dev = devn;
	}

	if (!strcmp(disc, "nmea")) {
		ldisc = NMEADISC;
		if (speed == 0)
			speed = B4800;	/* default is 4800 baud for nmea */
	} else if (!strcmp(disc, "msts")) {
		ldisc = MSTSDISC;
	} else if (!strcmp(disc, "endrun")) {
		ldisc = ENDRUNDISC;
	} else {
		syslog(LOG_ERR, "unknown line discipline %s", disc);
		goto bail_out;
	}

	if ((fd = open(dev, O_RDWR)) < 0) {
		syslog(LOG_ERR, "can't open %s", dev);
		goto bail_out;
	}

	/*
	 * Get the current line attributes, modify only values that are
	 * either requested on the command line or that are needed by
	 * the line discipline (e.g. nmea has a default baudrate of
	 * 4800 instead of 9600).
	 */
	if (tcgetattr(fd, &tty) < 0) {
		if (ppid != 1)
			warnx("tcgetattr");
		goto bail_out;
	}


	if (bits == 7) {
		tty.c_cflag &= ~CS8;
		tty.c_cflag |= CS7;
	} else if (bits == 8) {
		tty.c_cflag &= ~CS7;
		tty.c_cflag |= CS8;
	}

	if (parity != 0)
		tty.c_cflag |= PARENB;
	if (parity == 'o')
		tty.c_cflag |= PARODD;
	else
		tty.c_cflag &= ~PARODD;

	if (stop == 2)
		tty.c_cflag |= CSTOPB;
	else
		tty.c_cflag &= ~CSTOPB;

	if (flowcl)
		tty.c_cflag |= CRTSCTS;

	if (hupcl == 0)
		tty.c_cflag &= ~HUPCL;

	if (speed != 0)
		cfsetspeed(&tty, speed);

	/* setup common to all line disciplines */
	if (ioctl(fd, TIOCSDTR, 0) < 0)
		warn("TIOCSDTR");
	if (ioctl(fd, TIOCSETD, &ldisc) < 0) {
		syslog(LOG_ERR, "can't attach %s line discipline on %s", disc,
		    dev);
		goto bail_out;
	}

	/* line discpline specific setup */
	switch (ldisc) {
	case NMEADISC:
	case MSTSDISC:
	case ENDRUNDISC:
		if (ioctl(fd, TIOCSTSTAMP, &tstamps) < 0) {
			warnx("TIOCSTSTAMP");
			goto bail_out;
		}
		tty.c_cflag |= CLOCAL;
		tty.c_iflag = 0;
		tty.c_lflag = 0;
		tty.c_oflag = 0;
		tty.c_cc[VMIN] = 1;
		tty.c_cc[VTIME] = 0;
		break;
	}

	/* finally set the line attributes */
	if (tcsetattr(fd, TCSADRAIN, &tty) < 0) {
		if (ppid != 1)
			warnx("tcsetattr");
		goto bail_out;
	}

	/*
	 * open a pty(4) pair to pass the data if the -p option has been
	 * given on the commandline.
	 */
	if (pty) {
		if (openpty(&master, &slave, ptyn, NULL, NULL))
			errx(1, "can't open a pty");
		close(slave);
		printf("%s\n", ptyn);
		fflush(stdout);
	}
	if (nodaemon)
		openlog("ldattach", LOG_PID | LOG_CONS | LOG_PERROR,
		    LOG_DAEMON);
	else {
		openlog("ldattach", LOG_PID | LOG_CONS, LOG_DAEMON);
		if (daemon(0, 0))
			errx(1, "can't daemonize");
	}

	syslog(LOG_INFO, "attach %s on %s", disc, dev);
	signal(SIGHUP, coroner);
	signal(SIGTERM, coroner);

	if (master != -1) {
		syslog(LOG_INFO, "passing data to %s", ptyn);
		relay(fd, master);
	} else {
		sigemptyset(&sigset);

		while (!dying)
			sigsuspend(&sigset);
	}

bail_out:
	if (ppid == 1)
		sleep(30);	/* delay restart when called from init */

	return 0;
}

/* ARGSUSED */
void
coroner(int useless)
{
	dying = 1;
}
@


1.16
log
@I bet the reference to <sys/ttycom.h> near the ldisc list in tty(4)
led this program and the associated manual pages to including that
file directly, rather than the canonical include path of <sys/ioctl.h>
discussed with millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.15 2014/08/10 02:09:35 guenther Exp $	*/
d200 1
a200 4
	if (!strcmp(disc, "slip")) {
		bits = 8;		/* make sure we use 8 databits */
		ldisc = SLIPDISC;
	} else if (!strcmp(disc, "nmea")) {
a278 2
		/* FALLTHROUGH */
	case SLIPDISC:
@


1.15
log
@msts(4) appears to support TIOCSTSTAMP

From Maurice Janssen (maurice (at) z74.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.14 2009/10/31 02:53:11 ckuethe Exp $	*/
d30 1
a30 1
#include <sys/ttycom.h>
@


1.14
log
@If the nmea(4) or endrun(4) timing disciplines are selected ignore status
lines; this prevents poll(2) from saying the fd has data to be read, when
it only had a status line change. Prevents ldattach from exiting when
relaying data to gpsd while being driven by a gps with 1PPS.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.13 2009/10/28 05:14:00 ckuethe Exp $	*/
d275 1
@


1.13
log
@poll events must be reinitialized after each call to poll. fixes
ldattach exiting when relaying (nmea to gpsd, for example).
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.12 2009/05/06 18:21:23 stevesk Exp $	*/
d280 1
@


1.12
log
@endrun(4) - EndRun Technologies native time-of-day message timedelta
sensor.  Based on msts(4).  Tested with Praecis Ct
(http://www.endruntechnologies.com/network-time-source.htm).

help and feedback mbalmer
'no problem with this sensor going in' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.11 2008/06/12 03:52:48 mbalmer Exp $	*/
a72 1
	pfd[0].events = POLLRDNORM;
a73 1
	pfd[1].events = POLLRDNORM;
d76 2
d82 1
a82 1
		} 
@


1.11
log
@Initialize the tty in the same way for nmea and slip.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.10 2008/06/11 23:12:15 mbalmer Exp $	*/
d209 2
d275 1
@


1.10
log
@Explicit flush stdout after printing the pty name when -p is used.

found by ckuethe, help from otto.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.9 2008/06/10 18:28:58 mbalmer Exp $	*/
d277 1
a277 5
		/* tty.c_cc[VMIN] = tty.c_cc[VTIME] = 0; */
		tty.c_iflag = 0;
		tty.c_lflag = 0;
		tty.c_oflag = 0;
		break;
@


1.9
log
@sleep if the slave device of the pty(4) is not connected.

problem noticed by ckuethe, solution discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.8 2008/06/10 00:25:03 mbalmer Exp $	*/
d307 1
@


1.8
log
@correctly setup the tty line for NMEA devices, especially turn off echo
to the device.

found by ckuethe, fixed and tested with ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.7 2008/06/09 23:15:55 mbalmer Exp $	*/
d83 1
a83 1
		if (nfds == 0)
d86 5
d277 1
a277 1
		tty.c_cc[VMIN] = tty.c_cc[VTIME] = 0;
@


1.7
log
@Don't reverence slattach(8) or nmeaattach(8) in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.6 2008/06/09 21:06:10 mbalmer Exp $	*/
d272 4
@


1.6
log
@Add the '-p' option to ldattach(8) to pass data received from the device
to the master device of a pty(4) pair.  The name of the slave device is
written to standard output.

This is useful for applications like e.g. gpsd from the misc/gpsd port
that also use the serial data stream (e.g. nmea(4) as a time source and
gpsd to get at positional data).

help and ok deraadt, makes ckuethe happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.5 2008/02/28 11:22:12 mbalmer Exp $	*/
d20 3
a22 2
 * A replacement for slattach(8) and nmeaattach(8) that can be used from
 * the commandline or from init(8) (using entries in /etc/ttys).
@


1.5
log
@Log an error if a device can not be opened, only log line discipline attachment
when the line discipline has really been attached.  And a few manual tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.4 2008/01/05 17:33:28 mbalmer Exp $	*/
d24 1
d27 2
d35 1
d43 3
d48 1
d58 1
a58 1
	fprintf(stderr, "usage: %s [-27dehmo] [-s baudrate] "
d63 42
d113 2
a114 2
	int ch, fd, ldisc, nodaemon = 0;
	int  bits = 0, parity = 0, stop = 0, flowcl = 0, hupcl = 1;
d116 1
a116 1
	char devn[32], *dev, *disc;
d123 1
a123 1
	while ((ch = getopt(argc, argv, "27dehmos:t:")) != -1) {
d146 3
d190 1
a190 2
		(void)snprintf(devn, sizeof(devn),
		    "%s%s", _PATH_DEV, dev);
d259 1
a259 1
		syslog(LOG_ERR, "can't set the %s line discipline on %s", disc,
d288 18
a305 2
	if (!nodaemon && daemon(0, 0))
		errx(1, "can't daemonize");
d311 9
a319 3
	sigemptyset(&sigset);
	while (!dying)
		sigsuspend(&sigset);
@


1.4
log
@Add support for the Meinberg Standard Time String format that all Meinberg
radio clocks can transmit over serial ports.  This is implemented as a
line discipline similar to nmea(4) and provides a timedelta sensor.

See http://www.meinberg.de/english/specs/timestr.htm for details on the
MSTS format.

ldattach(8) is extended to support the "msts" line discipline and two stopbits
(which some radio clocks, e.g. the C51 use).  Do a "make includes" before your
next system build.

Initially from Maurice Janssen based on nmea(4).  "go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.3 2007/11/13 19:32:34 mbalmer Exp $	*/
d156 2
a157 2
	syslog(LOG_INFO, "attach %s on %s", disc, dev);
	if ((fd = open(dev, O_RDWR)) < 0)
d159 1
d239 1
@


1.3
log
@Do not set explicit com parameters for the tty, instead use the exisiting
ones and onl change what the user requests.  Do not artifically limit the
baudrates.

prodding and ok by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.2 2007/11/03 15:33:08 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Marc Balmer <mbalmer@@openbsd.org>
d50 1
a50 1
	fprintf(stderr, "usage: %s [-7dehmo] [-s baudrate] "
d64 1
a64 1
	int  bits = 0, parity = 0, flowcl = 0, hupcl = 1;
d73 1
a73 1
	while ((ch = getopt(argc, argv, "7dehmos:t:")) != -1) {
d75 3
d149 2
d187 5
@


1.2
log
@lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ldattach.c,v 1.1.1.1 2007/11/03 15:22:54 mbalmer Exp $	*/
d25 1
a60 1
	tcflag_t cflag = HUPCL | CS8;
d63 3
a65 2
	int ch, fd, ldisc, nodaemon = 0, parity = 0;
	speed_t speed = B4800;
d76 1
a76 2
			cflag &= ~CS8;
			cflag |= CS7;
d82 1
a82 4
			if (parity != 0)
				parity = 0;	/* -o -e */
			else
				parity = -1;	/* even */
d85 1
a85 1
			cflag |= CRTSCTS;
d88 1
a88 1
			cflag &= ~HUPCL;
d91 1
a91 4
			if (parity != 0)
				parity = 0;	/* -e -o */
			else
				parity = 1;	/* odd */
d94 1
a94 1
			speed = (speed_t)strtonum(optarg, 50, 230400, &errstr);
a137 3
	syslog(LOG_INFO, "attach %s on %s", disc, dev);
	if ((fd = open(dev, O_RDWR)) < 0)
		goto bail_out;
d139 2
a140 1
	if (!strcmp(disc, "slip"))
d142 1
a142 1
	else if (!strcmp(disc, "nmea"))
d144 3
a146 1
	else {
d151 3
a153 8
	switch (parity) {
	case -1:	/* even parity */
		cflag |= PARENB;
		break;
	case 1:		/* odd parity */
		cflag |= PARENB | PARODD;
		break;
	}
d155 7
a161 8
	tty.c_cflag = CREAD | cflag;
	tty.c_iflag = 0;
	tty.c_lflag = 0;
	tty.c_oflag = 0;
	tty.c_cc[VMIN] = 1;
	tty.c_cc[VTIME] = 0;
	cfsetspeed(&tty, speed);
	if (tcsetattr(fd, TCSADRAIN, &tty) < 0) {
d163 1
a163 1
			warnx("tcsetattr");
d167 25
d209 14
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
void 		coroner(int);
d63 3
a65 2
	int ch, fd, ldisc, nodaemon = 0, speed = B4800, parity = 0;
	char devname[32], *dev, *disc;
d100 1
a100 1
			speed = (int)strtonum(optarg, 50, 230400, &errstr);
d140 1
a140 1
		(void)snprintf(devname, sizeof(devname),
d142 1
a142 1
		dev = devname;
d165 1
a165 1
	
@


1.1.1.1
log
@ldattach(8) is a command to attach line discipline to a tty line.  It can
be used from the command line or from init(8) by adding an entry to the
/etc/ttys file.  ldattach(8) can be extended to support new line disciplines.

feedback many, ok deraadt, mikeb
@
text
@@
