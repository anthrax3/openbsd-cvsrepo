head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.2
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.59.0.2
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.4
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.6
	OPENBSD_5_0:1.45.0.4
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.10
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.6
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.39.0.6
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.4
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.36.0.4
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.65
date	2017.06.16.06.46.54;	author natano;	state Exp;
branches;
next	1.64;
commitid	4RpuYxrYL0nwiCwl;

1.64
date	2017.05.03.09.51.39;	author mestre;	state Exp;
branches;
next	1.63;
commitid	CaQOrlCeSyj26bDl;

1.63
date	2017.03.02.10.38.09;	author natano;	state Exp;
branches;
next	1.62;
commitid	EeVoCYFCx2tYicZQ;

1.62
date	2016.09.05.10.20.40;	author gsoares;	state Exp;
branches;
next	1.61;
commitid	ichdrDmWPEGVHHgT;

1.61
date	2016.09.04.12.30.01;	author nicm;	state Exp;
branches;
next	1.60;
commitid	0f3LNfhgqLVEtNGd;

1.60
date	2016.08.27.01.55.30;	author guenther;	state Exp;
branches;
next	1.59;
commitid	nMHwEPEA2Ox25Cu9;

1.59
date	2016.05.10.21.54.59;	author bluhm;	state Exp;
branches;
next	1.58;
commitid	WdDhLm0q8BHEgTMW;

1.58
date	2016.02.01.20.14.51;	author jca;	state Exp;
branches;
next	1.57;
commitid	ii7asfSIYNVuDD4Y;

1.57
date	2015.12.23.02.41.12;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	aEVgGIinmS09SDMm;

1.56
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.55;
commitid	82PdNqu2kKAuXPfA;

1.55
date	2015.11.18.19.25.07;	author tedu;	state Exp;
branches;
next	1.54;
commitid	gQ9IkaQR6vF4mt65;

1.54
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	0qPuuXwccpVXsXcV;

1.53
date	2015.07.14.19.14.05;	author millert;	state Exp;
branches;
next	1.52;
commitid	vTTR74DZ0Aj00get;

1.52
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Uu5nFG3wCl0LACBb;

1.51
date	2014.12.06.00.20.22;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	SbiNcodYrr1UuhgS;

1.50
date	2014.04.22.20.40.37;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2014.01.03.22.29.00;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2013.02.11.15.52.42;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2012.10.11.22.21.29;	author halex;	state Exp;
branches;
next	1.46;

1.46
date	2012.04.06.17.25.00;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.15.07.11.02;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.14.23.48.57;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2010.09.29.13.23.37;	author dcoppa;	state Exp;
branches;
next	1.42;

1.42
date	2010.08.07.10.22.28;	author phessler;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.03.14.26.54;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.22.00.25.22;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.19.18.43.56;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.12.13.30.46;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.13.13.53.23;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.16.01.11.09;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.30.23.58.52;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.30.18.09.44;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.11.21.58.37;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.10.23.27.54;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.16.21.27.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.09.07.04.45;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.19.17.57.37;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.20.18.42.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.06.00.19.31;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.22.20.24.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.09.03.18.11.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.07.06.07.54.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.06.03.16.20.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.05.04.06.37.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.04.13.15.26.46;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.03.03.01.15.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.14.10.37.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.25.18.18.58;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.03.25.23.12.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.22.08.38.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.07.31.18.29.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.12.10.16.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.12.06.45.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.01.03.44;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.65
log
@s/CPU_LIDSUSPEND/CPU_LIDACTION/
ok mlarkin
@
text
@/*	$OpenBSD: init.c,v 1.64 2017/05/03 09:51:39 mestre Exp $	*/
/*	$NetBSD: init.c,v 1.22 1996/05/15 23:29:33 jtc Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Donn Seeley at Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/reboot.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <sys/wait.h>
#include <machine/cpu.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <ttyent.h>
#include <unistd.h>
#include <util.h>

#ifdef SECURE
#include <pwd.h>
#include <readpassphrase.h>
#endif

#ifdef LOGIN_CAP
#include <login_cap.h>
#endif

#include "pathnames.h"

/*
 * Sleep times; used to prevent thrashing.
 */
#define	GETTY_SPACING		 5	/* N secs minimum getty spacing */
#define	GETTY_SLEEP		30	/* sleep N secs after spacing problem */
#define	WINDOW_WAIT		 3	/* wait N secs after starting window */
#define	STALL_TIMEOUT		30	/* wait N secs after warning */
#define	DEATH_WATCH		10	/* wait N secs for procs to die */

/*
 * User-based resource limits.
 */
#define RESOURCE_RC		"daemon"
#define RESOURCE_WINDOW		"default"
#define RESOURCE_GETTY		"default"

#ifndef DEFAULT_STATE
#define DEFAULT_STATE		runcom
#endif

void handle(sig_t, ...);
void delset(sigset_t *, ...);

void stall(char *, ...);
void warning(char *, ...);
void emergency(char *, ...);
void disaster(int);
void badsys(int);

typedef enum {
	invalid_state,
	single_user,
	runcom,
	read_ttys,
	multi_user,
	clean_ttys,
	catatonia,
	death,
	do_reboot,
	hard_death,
	nice_death
} state_t;
typedef state_t (*state_func_t)(void);

state_t f_single_user(void);
state_t f_runcom(void);
state_t f_read_ttys(void);
state_t f_multi_user(void);
state_t f_clean_ttys(void);
state_t f_catatonia(void);
state_t f_death(void);
state_t f_do_reboot(void);
state_t f_hard_death(void);
state_t f_nice_death(void);

state_func_t state_funcs[] = {
	NULL,
	f_single_user,
	f_runcom,
	f_read_ttys,
	f_multi_user,
	f_clean_ttys,
	f_catatonia,
	f_death,
	f_do_reboot,
	f_hard_death,
	f_nice_death
};

enum { AUTOBOOT, FASTBOOT } runcom_mode = AUTOBOOT;

void transition(state_t);
volatile sig_atomic_t requested_transition = DEFAULT_STATE;

void setctty(char *);

typedef struct init_session {
	int	se_index;		/* index of entry in ttys file */
	pid_t	se_process;		/* controlling process */
	time_t	se_started;		/* used to avoid thrashing */
	int	se_flags;		/* status of session */
#define	SE_SHUTDOWN	0x1		/* session won't be restarted */
#define	SE_PRESENT	0x2		/* session is in /etc/ttys */
#define	SE_DEVEXISTS	0x4		/* open does not result in ENODEV */
	char	*se_device;		/* filename of port */
	char	*se_getty;		/* what to run on that port */
	char	**se_getty_argv;	/* pre-parsed argument array */
	char	*se_window;		/* window system (started only once) */
	char	**se_window_argv;	/* pre-parsed argument array */
	struct	init_session *se_prev;
	struct	init_session *se_next;
	RB_ENTRY(init_session) se_entry;
} session_t;

static int cmp_sessions(session_t *, session_t *);
RB_HEAD(session_tree, init_session) session_tree = RB_INITIALIZER(session_tree);
RB_PROTOTYPE(session_tree, init_session, se_entry, cmp_sessions);
RB_GENERATE(session_tree, init_session, se_entry, cmp_sessions);

void free_session(session_t *);
session_t *new_session(session_t *, int, struct ttyent *);
session_t *sessions;

char **construct_argv(char *);
void start_window_system(session_t *);
void collect_child(pid_t);
pid_t start_getty(session_t *);
void transition_handler(int);
void alrm_handler(int);
void setsecuritylevel(int);
int getsecuritylevel(void);
int setupargv(session_t *, struct ttyent *);
int clang;

#ifdef LOGIN_CAP
void setprocresources(char *);
#else
#define setprocresources(p)
#endif

void clear_session_logs(session_t *);

void add_session(session_t *);
void del_session(session_t *);
session_t *find_session(pid_t);

/*
 * The mother of all processes.
 */
int
main(int argc, char *argv[])
{
	int c, fd;
	struct sigaction sa;
	sigset_t mask;

	/* Dispose of random users. */
	if (getuid() != 0) {
		(void)fprintf(stderr, "init: %s\n", strerror(EPERM));
		exit (1);
	}

	/* System V users like to reexec init. */
	if (getpid() != 1) {
		(void)fprintf(stderr, "init: already running\n");
		exit (1);
	}

	/*
	 * Paranoia.
	 */
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			(void)close(fd);
	}

	/*
	 * Note that this does NOT open a file...
	 * Does 'init' deserve its own facility number?
	 */
	openlog("init", LOG_CONS|LOG_ODELAY, LOG_AUTH);

	/*
	 * Create an initial session.
	 */
	if (setsid() < 0)
		warning("initial setsid() failed: %m");

	/*
	 * Establish an initial user so that programs running
	 * single user do not freak out and die (like passwd).
	 */
	if (setlogin("root") < 0)
		warning("setlogin() failed: %m");

	/*
	 * This code assumes that we always get arguments through flags,
	 * never through bits set in some random machine register.
	 */
	while ((c = getopt(argc, argv, "sf")) != -1)
		switch (c) {
		case 's':
			requested_transition = single_user;
			break;
		case 'f':
			runcom_mode = FASTBOOT;
			break;
		default:
			warning("unrecognized flag '-%c'", c);
			break;
		}

	if (optind != argc)
		warning("ignoring excess arguments");

	/*
	 * We catch or block signals rather than ignore them,
	 * so that they get reset on exec.
	 */
	handle(badsys, SIGSYS, 0);
	handle(disaster, SIGABRT, SIGFPE, SIGILL, SIGSEGV,
	    SIGBUS, SIGXCPU, SIGXFSZ, 0);
	handle(transition_handler, SIGHUP, SIGINT, SIGTERM, SIGTSTP,
            SIGUSR1, SIGUSR2, 0);
	handle(alrm_handler, SIGALRM, 0);
	sigfillset(&mask);
	delset(&mask, SIGABRT, SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGSYS,
	    SIGXCPU, SIGXFSZ, SIGHUP, SIGINT, SIGTERM, SIGUSR1, SIGUSR2,
	    SIGTSTP, SIGALRM, 0);
	sigprocmask(SIG_SETMASK, &mask, NULL);
	memset(&sa, 0, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sa.sa_handler = SIG_IGN;
	(void) sigaction(SIGTTIN, &sa, NULL);
	(void) sigaction(SIGTTOU, &sa, NULL);

	/*
	 * Start the state machine.
	 */
	transition(requested_transition);

	/*
	 * Should never reach here.
	 */
	exit(1);
}

/*
 * Associate a function with a signal handler.
 */
void
handle(sig_t handler, ...)
{
	int sig;
	struct sigaction sa;
	sigset_t mask_everything;
	va_list ap;

	va_start(ap, handler);

	memset(&sa, 0, sizeof sa);
	sa.sa_handler = handler;
	sigfillset(&mask_everything);

	while ((sig = va_arg(ap, int))) {
		sa.sa_mask = mask_everything;
		/* XXX SA_RESTART? */
		sa.sa_flags = sig == SIGCHLD ? SA_NOCLDSTOP : 0;
		sigaction(sig, &sa, NULL);
	}
	va_end(ap);
}

/*
 * Delete a set of signals from a mask.
 */
void
delset(sigset_t *maskp, ...)
{
	int sig;
	va_list ap;

	va_start(ap, maskp);
	while ((sig = va_arg(ap, int)))
		sigdelset(maskp, sig);
	va_end(ap);
}

/*
 * Log a message and sleep for a while (to give someone an opportunity
 * to read it and to save log or hardcopy output if the problem is chronic).
 * NB: should send a message to the session logger to avoid blocking.
 */
void
stall(char *message, ...)
{
	va_list ap;

	va_start(ap, message);
	vsyslog(LOG_ALERT, message, ap);
	va_end(ap);
	closelog();
	sleep(STALL_TIMEOUT);
}

/*
 * Like stall(), but doesn't sleep.
 * If cpp had variadic macros, the two functions could be #defines for another.
 * NB: should send a message to the session logger to avoid blocking.
 */
void
warning(char *message, ...)
{
	va_list ap;

	va_start(ap, message);
	vsyslog(LOG_ALERT, message, ap);
	va_end(ap);
	closelog();
}

/*
 * Log an emergency message.
 * NB: should send a message to the session logger to avoid blocking.
 */
void
emergency(char *message, ...)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	va_list ap;

	va_start(ap, message);
	vsyslog_r(LOG_EMERG, &sdata, message, ap);
	va_end(ap);
}

/*
 * Catch a SIGSYS signal.
 *
 * These may arise if a system does not support sysctl.
 * We tolerate up to 25 of these, then throw in the towel.
 */
void
badsys(int sig)
{
	static int badcount = 0;

	if (badcount++ < 25)
		return;
	disaster(sig);
}

/*
 * Catch an unexpected signal.
 */
void
disaster(int sig)
{
	emergency("fatal signal: %s", strsignal(sig));

	sleep(STALL_TIMEOUT);
	_exit(sig);		/* reboot */
}

/*
 * Get the security level of the kernel.
 */
int
getsecuritylevel(void)
{
#ifdef KERN_SECURELVL
	int name[2], curlevel;
	size_t len;

	name[0] = CTL_KERN;
	name[1] = KERN_SECURELVL;
	len = sizeof curlevel;
	if (sysctl(name, 2, &curlevel, &len, NULL, 0) == -1) {
		emergency("cannot get kernel security level: %s",
		    strerror(errno));
		return (-1);
	}
	return (curlevel);
#else
	return (-1);
#endif
}

/*
 * Set the security level of the kernel.
 */
void
setsecuritylevel(int newlevel)
{
#ifdef KERN_SECURELVL
	int name[2], curlevel;

	curlevel = getsecuritylevel();
	if (newlevel == curlevel)
		return;
	name[0] = CTL_KERN;
	name[1] = KERN_SECURELVL;
	if (sysctl(name, 2, NULL, NULL, &newlevel, sizeof newlevel) == -1) {
		emergency(
		    "cannot change kernel security level from %d to %d: %s",
		    curlevel, newlevel, strerror(errno));
		return;
	}
#ifdef SECURE
	warning("kernel security level changed from %d to %d",
	    curlevel, newlevel);
#endif
#endif
}

/*
 * Change states in the finite state machine.
 * The initial state is passed as an argument.
 */
void
transition(state_t s)
{
	for (;;)
		s = (*state_funcs[s])();
}

/*
 * Close out the accounting files for a login session.
 * NB: should send a message to the session logger to avoid blocking.
 */
void
clear_session_logs(session_t *sp)
{
	char *line = sp->se_device + sizeof(_PATH_DEV) - 1;

	if (logout(line))
		logwtmp(line, "", "");
}

/*
 * Start a session and allocate a controlling terminal.
 * Only called by children of init after forking.
 */
void
setctty(char *name)
{
	int fd;

	(void) revoke(name);
	sleep(2);			/* leave DTR low */
	if ((fd = open(name, O_RDWR)) == -1) {
		stall("can't open %s: %m", name);
		_exit(1);
	}
	if (login_tty(fd) == -1) {
		stall("can't get %s for controlling terminal: %m", name);
		_exit(1);
	}
}

/*
 * Bring the system up single user.
 */
state_t
f_single_user(void)
{
	pid_t pid, wpid;
	int status;
	sigset_t mask;
	char shell[PATH_MAX];		/* Allocate space here */
	char name[PATH_MAX];		/* Name (argv[0]) of shell */
	char *argv[2];
#ifdef SECURE
	struct ttyent *typ;
	struct passwd *pp;
	static const char banner[] =
		"Enter root password, or ^D to go multi-user\n";
	char *clear;
	char pbuf[1024];
#endif

	/* Init shell and name */
	strlcpy(shell, _PATH_BSHELL, sizeof shell);
	strlcpy(name, "-sh", sizeof name);

	/*
	 * If the kernel is in secure mode, downgrade it to insecure mode.
	 */
	if (getsecuritylevel() > 0)
		setsecuritylevel(0);

	if ((pid = fork()) == 0) {
		/*
		 * Start the single user session.
		 */
		setctty(_PATH_CONSOLE);

#ifdef SECURE
		/*
		 * Check the root password.
		 * We don't care if the console is 'on' by default;
		 * it's the only tty that can be 'off' and 'secure'.
		 */
		typ = getttynam("console");
		pp = getpwnam_shadow("root");
		if (typ && (typ->ty_status & TTY_SECURE) == 0 && pp &&
		    *pp->pw_passwd) {
			write(STDERR_FILENO, banner, sizeof banner - 1);
			for (;;) {
				int ok = 0;
				clear = readpassphrase("Password:", pbuf,
				    sizeof(pbuf), RPP_ECHO_OFF);
				if (clear == NULL || *clear == '\0')
					_exit(0);
				if (crypt_checkpass(clear, pp->pw_passwd) == 0)
					ok = 1;
				explicit_bzero(pbuf, sizeof(pbuf));
				if (ok)
					break;
				warning("single-user login failed\n");
			}
		}
		endttyent();
		endpwent();
#endif /* SECURE */

#ifdef DEBUGSHELL
		{
			char altshell[128], *cp = altshell;
			int num;

#define	SHREQUEST \
	"Enter pathname of shell or RETURN for sh: "

			(void)write(STDERR_FILENO,
			    SHREQUEST, sizeof(SHREQUEST) - 1);
			while ((num = read(STDIN_FILENO, cp, 1)) != -1 &&
			    num != 0 && *cp != '\n' && cp < &altshell[127])
				cp++;
			*cp = '\0';

			/* Copy in alternate shell */
			if (altshell[0] != '\0'){
				char *p;

				/* Binary to exec */
				strlcpy(shell, altshell, sizeof shell);

				/* argv[0] */
				p = strrchr(altshell, '/');
				if(p == NULL) p = altshell;
				else p++;

				name[0] = '-';
				strlcpy(&name[1], p, sizeof name -1);
			}
		}
#endif /* DEBUGSHELL */

		/*
		 * Unblock signals.
		 * We catch all the interesting ones,
		 * and those are reset to SIG_DFL on exec.
		 */
		sigemptyset(&mask);
		sigprocmask(SIG_SETMASK, &mask, NULL);

		/*
		 * Fire off a shell.
		 * If the default one doesn't work, try the Bourne shell.
		 */
		argv[0] = name;
		argv[1] = NULL;
		setenv("PATH", _PATH_STDPATH, 1);
		execv(shell, argv);
		emergency("can't exec %s for single user: %m", shell);

		argv[0] = "-sh";
		argv[1] = NULL;
		execv(_PATH_BSHELL, argv);
		emergency("can't exec %s for single user: %m", _PATH_BSHELL);
		sleep(STALL_TIMEOUT);
		_exit(1);
	}

	if (pid == -1) {
		/*
		 * We are seriously hosed.  Do our best.
		 */
		emergency("can't fork single-user shell, trying again");
		while (waitpid(-1, NULL, WNOHANG) > 0)
			continue;
		return single_user;
	}

	requested_transition = 0;
	do {
		if ((wpid = waitpid(-1, &status, WUNTRACED)) != -1)
			collect_child(wpid);
		if (wpid == -1) {
			if (errno == EINTR)
				continue;
			warning("wait for single-user shell failed: %m; restarting");
			return single_user;
		}
		if (wpid == pid && WIFSTOPPED(status)) {
			warning("init: shell stopped, restarting\n");
			kill(pid, SIGCONT);
			wpid = -1;
		}
	} while (wpid != pid && !requested_transition);

	if (requested_transition)
		return requested_transition;

	if (!WIFEXITED(status)) {
		if (WTERMSIG(status) == SIGKILL) {
			/*
			 *  reboot(8) killed shell?
			 */
			warning("single user shell terminated.");
			sleep(STALL_TIMEOUT);
			_exit(0);
		} else {
			warning("single user shell terminated, restarting");
			return single_user;
		}
	}

	runcom_mode = FASTBOOT;
	return runcom;
}

/*
 * Run the system startup script.
 */
state_t
f_runcom(void)
{
	pid_t pid, wpid;
	int status;
	char *argv[4];
	struct sigaction sa;

	if ((pid = fork()) == 0) {
		memset(&sa, 0, sizeof sa);
		sigemptyset(&sa.sa_mask);
		sa.sa_flags = 0;
		sa.sa_handler = SIG_IGN;
		(void) sigaction(SIGTSTP, &sa, NULL);
		(void) sigaction(SIGHUP, &sa, NULL);

		setctty(_PATH_CONSOLE);

		argv[0] = "sh";
		argv[1] = _PATH_RUNCOM;
		argv[2] = runcom_mode == AUTOBOOT ? "autoboot" : NULL;
		argv[3] = NULL;

		sigprocmask(SIG_SETMASK, &sa.sa_mask, NULL);

		setprocresources(RESOURCE_RC);

		execv(_PATH_BSHELL, argv);
		stall("can't exec %s for %s: %m", _PATH_BSHELL, _PATH_RUNCOM);
		_exit(1);	/* force single user mode */
	}

	if (pid == -1) {
		emergency("can't fork for %s on %s: %m",
			_PATH_BSHELL, _PATH_RUNCOM);
		while (waitpid(-1, NULL, WNOHANG) > 0)
			continue;
		sleep(STALL_TIMEOUT);
		return single_user;
	}

	/*
	 * Copied from single_user().  This is a bit paranoid.
	 */
	do {
		if ((wpid = waitpid(-1, &status, WUNTRACED)) != -1)
			collect_child(wpid);
		if (wpid == -1) {
			if (errno == EINTR)
				continue;
			warning("wait for %s on %s failed: %m; going to single user mode",
			    _PATH_BSHELL, _PATH_RUNCOM);
			return single_user;
		}
		if (wpid == pid && WIFSTOPPED(status)) {
			warning("init: %s on %s stopped, restarting\n",
			    _PATH_BSHELL, _PATH_RUNCOM);
			kill(pid, SIGCONT);
			wpid = -1;
		}
	} while (wpid != pid);

	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGTERM &&
	    requested_transition == catatonia) {
		/* /etc/rc executed /sbin/reboot; wait for the end quietly */
		sigset_t s;

		sigfillset(&s);
		for (;;)
			sigsuspend(&s);
	}

	if (!WIFEXITED(status)) {
		warning("%s on %s terminated abnormally, going to single user mode",
		    _PATH_BSHELL, _PATH_RUNCOM);
		return single_user;
	}

	if (WEXITSTATUS(status))
		return single_user;

	runcom_mode = AUTOBOOT;		/* the default */
	/* NB: should send a message to the session logger to avoid blocking. */
	logwtmp("~", "reboot", "");
	return read_ttys;
}

/*
 * Compare session keys.
 */
static int
cmp_sessions(session_t *sp1, session_t *sp2)
{
	if (sp1->se_process < sp2->se_process)
		return (-1);
	if (sp1->se_process > sp2->se_process)
		return (1);
	return (0);
}

/*
 * Add a new login session.
 */
void
add_session(session_t *sp)
{
	if (RB_INSERT(session_tree, &session_tree, sp) != NULL)
		emergency("insert %d: %s", sp->se_process, strerror(errno));
}

/*
 * Delete an old login session.
 */
void
del_session(session_t *sp)
{
	RB_REMOVE(session_tree, &session_tree, sp);
}

/*
 * Look up a login session by pid.
 */
session_t *
find_session(pid_t pid)
{
	struct init_session s;

	s.se_process = pid;
	return (RB_FIND(session_tree, &session_tree, &s));
}

/*
 * Construct an argument vector from a command line.
 */
char **
construct_argv(char *command)
{
	int argc = 0;
	char **argv = calloc((strlen(command) + 1) / 2 + 1, sizeof (char *));
	static const char separators[] = " \t";

	if (argv == NULL)
		return (0);

	if ((argv[argc++] = strtok(command, separators)) == 0) {
		free(argv);
		return (0);
	}
	while ((argv[argc++] = strtok(NULL, separators)))
		continue;
	return (argv);
}

/*
 * Deallocate a session descriptor.
 */
void
free_session(session_t *sp)
{
	free(sp->se_device);
	if (sp->se_getty) {
		free(sp->se_getty);
		free(sp->se_getty_argv);
	}
	if (sp->se_window) {
		free(sp->se_window);
		free(sp->se_window_argv);
	}
	free(sp);
}

/*
 * Allocate a new session descriptor.
 */
session_t *
new_session(session_t *sprev, int session_index, struct ttyent *typ)
{
	session_t *sp;

	if ((typ->ty_status & TTY_ON) == 0 ||
	    typ->ty_name == 0 ||
	    typ->ty_getty == 0)
		return (0);

	sp = calloc(1, sizeof (session_t));
	if (sp == NULL)
		err(1, "calloc");

	sp->se_flags = SE_PRESENT;
	sp->se_index = session_index;

	if (asprintf(&sp->se_device, "%s%s", _PATH_DEV, typ->ty_name) == -1)
		err(1, "asprintf");

	if (setupargv(sp, typ) == 0) {
		free_session(sp);
		return (0);
	}

	sp->se_next = NULL;
	if (sprev == NULL) {
		sessions = sp;
		sp->se_prev = NULL;
	} else {
		sprev->se_next = sp;
		sp->se_prev = sprev;
	}

	return (sp);
}

/*
 * Calculate getty and if useful window argv vectors.
 */
int
setupargv(session_t *sp, struct ttyent *typ)
{
	if (sp->se_getty) {
		free(sp->se_getty);
		free(sp->se_getty_argv);
	}
	if (asprintf(&sp->se_getty, "%s %s", typ->ty_getty, typ->ty_name) == -1)
		err(1, "asprintf");
	sp->se_getty_argv = construct_argv(sp->se_getty);
	if (sp->se_getty_argv == 0) {
		warning("can't parse getty for port %s", sp->se_device);
		free(sp->se_getty);
		sp->se_getty = NULL;
		return (0);
	}
	if (typ->ty_window) {
		free(sp->se_window);
		sp->se_window = strdup(typ->ty_window);
		if (sp->se_window == NULL) {
			warning("can't allocate window");
			return (0);
		}
		sp->se_window_argv = construct_argv(sp->se_window);
		if (sp->se_window_argv == NULL) {
			warning("can't parse window for port %s",
			    sp->se_device);
			free(sp->se_window);
			sp->se_window = NULL;
			return (0);
		}
	}
	return (1);
}

/*
 * Walk the list of ttys and create sessions for each active line.
 */
state_t
f_read_ttys(void)
{
	int session_index = 0;
	session_t *sp, *snext;
	struct ttyent *typ;

	/*
	 * Destroy any previous session state.
	 * There shouldn't be any, but just in case...
	 */
	for (sp = sessions; sp; sp = snext) {
		if (sp->se_process)
			clear_session_logs(sp);
		snext = sp->se_next;
		free_session(sp);
	}
	sessions = NULL;

	/*
	 * Allocate a session entry for each active port.
	 * Note that sp starts at 0.
	 */
	while ((typ = getttyent()))
		if ((snext = new_session(sp, ++session_index, typ)))
			sp = snext;

	endttyent();

	return multi_user;
}

/*
 * Start a window system running.
 */
void
start_window_system(session_t *sp)
{
	pid_t pid;
	sigset_t mask;

	if ((pid = fork()) == -1) {
		emergency("can't fork for window system on port %s: %m",
		    sp->se_device);
		/* hope that getty fails and we can try again */
		return;
	}

	if (pid)
		return;

	sigemptyset(&mask);
	sigprocmask(SIG_SETMASK, &mask, NULL);

	if (setsid() < 0)
		emergency("setsid failed (window) %m");

	setprocresources(RESOURCE_WINDOW);

	execv(sp->se_window_argv[0], sp->se_window_argv);
	stall("can't exec window system '%s' for port %s: %m",
	    sp->se_window_argv[0], sp->se_device);
	_exit(1);
}

/*
 * Start a login session running.
 * For first open, man-handle tty directly to determine if it
 * really exists. It is not efficient to spawn gettys on devices
 * that do not exist.
 */
pid_t
start_getty(session_t *sp)
{
	pid_t pid;
	sigset_t mask;
	time_t current_time = time(NULL);
	int p[2], new = 1;

	if (sp->se_flags & SE_DEVEXISTS)
		new = 0;

	if (new) {
		if (pipe(p) == -1)
			return (-1);
	}

	/*
	 * fork(), not vfork() -- we can't afford to block.
	 */
	if ((pid = fork()) == -1) {
		emergency("can't fork for getty on port %s: %m", sp->se_device);
		return (-1);
	}

	if (pid) {
		if (new) {
			char c;

			close(p[1]);
			if (read(p[0], &c, 1) != 1) {
				close(p[0]);
				return (-1);
			}
			close(p[0]);
			if (c == '1')
				sp->se_flags |= SE_DEVEXISTS;
			else
				sp->se_flags |= SE_SHUTDOWN;
		}
		return (pid);
	}
	if (new) {
		int fd;

		close(p[0]);
		fd = open(sp->se_device, O_RDONLY | O_NONBLOCK, 0666);
		if (fd == -1 && (errno == ENXIO || errno == ENOENT ||
		    errno == EISDIR)) {
			(void)write(p[1], "0", 1);
			close(p[1]);
			_exit(1);
		}
		(void)write(p[1], "1", 1);
		close(p[1]);
		close(fd);
		sleep(1);
	}

	if (current_time > sp->se_started &&
	    current_time - sp->se_started < GETTY_SPACING) {
		warning("getty repeating too quickly on port %s, sleeping",
		    sp->se_device);
		sleep(GETTY_SLEEP);
	}

	if (sp->se_window) {
		start_window_system(sp);
		sleep(WINDOW_WAIT);
	}

	sigemptyset(&mask);
	sigprocmask(SIG_SETMASK, &mask, NULL);

	setprocresources(RESOURCE_GETTY);

	execv(sp->se_getty_argv[0], sp->se_getty_argv);
	stall("can't exec getty '%s' for port %s: %m",
	    sp->se_getty_argv[0], sp->se_device);
	_exit(1);
}

/*
 * Collect exit status for a child.
 * If an exiting login, start a new login running.
 */
void
collect_child(pid_t pid)
{
	session_t *sp, *sprev, *snext;

	if (sessions == NULL)
		return;

	if ((sp = find_session(pid)) == NULL)
		return;

	clear_session_logs(sp);
	login_fbtab(sp->se_device + sizeof(_PATH_DEV) - 1, 0, 0);
	del_session(sp);
	sp->se_process = 0;

	if (sp->se_flags & SE_SHUTDOWN) {
		if ((sprev = sp->se_prev))
			sprev->se_next = sp->se_next;
		else
			sessions = sp->se_next;
		if ((snext = sp->se_next))
			snext->se_prev = sp->se_prev;
		free_session(sp);
		return;
	}

	if ((pid = start_getty(sp)) == -1) {
		/* serious trouble */
		requested_transition = clean_ttys;
		return;
	}

	sp->se_process = pid;
	sp->se_started = time(NULL);
	add_session(sp);
}

/*
 * Catch a signal and request a state transition.
 */
void
transition_handler(int sig)
{

	switch (sig) {
	case SIGHUP:
		requested_transition = clean_ttys;
		break;
	case SIGINT:
		requested_transition = do_reboot;
		break;
	case SIGTERM:
		requested_transition = death;
		break;
	case SIGUSR1:
		requested_transition = nice_death;
		break;
	case SIGUSR2:
		requested_transition = hard_death;
		break;
	case SIGTSTP:
		requested_transition = catatonia;
		break;
	default:
		requested_transition = 0;
		break;
	}
}

/*
 * Take the system multiuser.
 */
state_t
f_multi_user(void)
{
	pid_t pid;
	session_t *sp;

	/*
	 * If the administrator has not set the security level to -1
	 * to indicate that the kernel should not run multiuser in secure
	 * mode, and the run script has not set a higher level of security
	 * than level 1, then put the kernel into secure mode.
	 */
	if (requested_transition != catatonia) {
		if (getsecuritylevel() == 0)
			setsecuritylevel(1);
	}

	requested_transition = 0;

	for (sp = sessions; sp; sp = sp->se_next) {
		if (sp->se_process)
			continue;
		if ((pid = start_getty(sp)) == -1) {
			/* serious trouble */
			requested_transition = clean_ttys;
			break;
		}
		sp->se_process = pid;
		sp->se_started = time(NULL);
		add_session(sp);
	}

	while (!requested_transition)
		if ((pid = waitpid(-1, NULL, 0)) != -1)
			collect_child(pid);

	return requested_transition;
}

/*
 * This is an n-squared algorithm.  We hope it isn't run often...
 */
state_t
f_clean_ttys(void)
{
	session_t *sp, *sprev;
	struct ttyent *typ;
	int session_index = 0;
	int devlen;

	for (sp = sessions; sp; sp = sp->se_next)
		sp->se_flags &= ~SE_PRESENT;

	devlen = sizeof(_PATH_DEV) - 1;
	while ((typ = getttyent())) {
		++session_index;

		for (sprev = NULL, sp = sessions; sp; sprev = sp, sp = sp->se_next)
			if (strcmp(typ->ty_name, sp->se_device + devlen) == 0)
				break;

		if (sp) {
			sp->se_flags |= SE_PRESENT;
			if (sp->se_index != session_index) {
				warning("port %s changed utmp index from %d to %d",
				    sp->se_device, sp->se_index,
				    session_index);
				sp->se_index = session_index;
			}
			if ((typ->ty_status & TTY_ON) == 0 ||
			    typ->ty_getty == 0) {
				sp->se_flags |= SE_SHUTDOWN;
				kill(sp->se_process, SIGHUP);
				continue;
			}
			sp->se_flags &= ~SE_SHUTDOWN;
			if (setupargv(sp, typ) == 0) {
				warning("can't parse getty for port %s",
				    sp->se_device);
				sp->se_flags |= SE_SHUTDOWN;
				kill(sp->se_process, SIGHUP);
			}
			continue;
		}

		new_session(sprev, session_index, typ);
	}

	endttyent();

	for (sp = sessions; sp; sp = sp->se_next)
		if ((sp->se_flags & SE_PRESENT) == 0) {
			sp->se_flags |= SE_SHUTDOWN;
			kill(sp->se_process, SIGHUP);
		}

	return multi_user;
}

/*
 * Block further logins.
 */
state_t
f_catatonia(void)
{
	session_t *sp;

	for (sp = sessions; sp; sp = sp->se_next)
		sp->se_flags |= SE_SHUTDOWN;

	return multi_user;
}

/*
 * Note SIGALRM.
 */
void
alrm_handler(int sig)
{
	clang = 1;
}

int death_howto = RB_HALT;

/*
 * Reboot the system.
 */
state_t
f_do_reboot(void)
{
	death_howto = RB_AUTOBOOT;
	return nice_death;
}

/*
 * Bring the system down nicely, then we must powerdown because something
 * is very wrong.
 */
state_t
f_hard_death(void)
{
	death_howto |= RB_POWERDOWN;	
	return nice_death;
}

/*
 * Bring the system down to single user nicely, after run the shutdown script.
 */
state_t
f_nice_death(void)
{
	session_t *sp;
	int i;
	pid_t pid;
	static const int death_sigs[3] = { SIGHUP, SIGTERM, SIGKILL };
	int status;

#ifdef CPU_LIDACTION
	int mib[] = {CTL_MACHDEP, CPU_LIDACTION};
	int lidaction = 0;

	if ((death_howto & RB_POWERDOWN) &&
	    (sysctl(mib, 2, NULL, NULL, &lidaction,
		    sizeof(lidaction)) == -1) && (errno != EOPNOTSUPP))
			warning("cannot disable lid action");
#endif

	for (sp = sessions; sp; sp = sp->se_next) {
		sp->se_flags &= ~SE_PRESENT;
		sp->se_flags |= SE_SHUTDOWN;
		kill(sp->se_process, SIGHUP);
	}

	/* terminate the accounting process */
	acct(NULL);

	/* NB: should send a message to the session logger to avoid blocking. */
	logwtmp("~", "shutdown", "");

	if (access(_PATH_RUNCOM, R_OK) != -1) {
		struct sigaction sa;

		switch ((pid = fork())) {
		case -1:
			break;
		case 0:

			memset(&sa, 0, sizeof sa);
			sigemptyset(&sa.sa_mask);
			sa.sa_flags = 0;
			sa.sa_handler = SIG_IGN;
			(void) sigaction(SIGTSTP, &sa, NULL);
			(void) sigaction(SIGHUP, &sa, NULL);

			setctty(_PATH_CONSOLE);

			sigprocmask(SIG_SETMASK, &sa.sa_mask, NULL);

			execl(_PATH_BSHELL, "sh", _PATH_RUNCOM, "shutdown",
			    (char *)NULL);
			stall("can't exec %s for %s %s: %m", _PATH_BSHELL,
			    _PATH_RUNCOM, "shutdown");
			_exit(1);
		default:
			waitpid(pid, &status, 0);
			if (WIFEXITED(status) && WEXITSTATUS(status) == 2)
				death_howto |= RB_POWERDOWN;
		}
	}

	for (i = 0; i < 3; ++i) {
		if (kill(-1, death_sigs[i]) == -1 && errno == ESRCH)
			goto die;

		clang = 0;
		alarm(DEATH_WATCH);
		do {
			if ((pid = waitpid(-1, NULL, 0)) != -1)
				collect_child(pid);
		} while (clang == 0 && errno != ECHILD);

		if (errno == ECHILD)
			goto die;
	}

	warning("some processes would not die; ps axl advised");

die:
	reboot(death_howto);

	/* ... and if that fails.. oh well */
	return single_user;
}

/*
 * Bring the system down to single user.
 */
state_t
f_death(void)
{
	session_t *sp;
	int i;
	pid_t pid;
	static const int death_sigs[3] = { SIGHUP, SIGTERM, SIGKILL };

	/* terminate the accounting process */
	acct(NULL);

	for (sp = sessions; sp; sp = sp->se_next)
		sp->se_flags |= SE_SHUTDOWN;

	/* NB: should send a message to the session logger to avoid blocking. */
	logwtmp("~", "shutdown", "");

	for (i = 0; i < 3; ++i) {
		if (kill(-1, death_sigs[i]) == -1 && errno == ESRCH)
			return single_user;

		clang = 0;
		alarm(DEATH_WATCH);
		do {
			if ((pid = waitpid(-1, NULL, 0)) != -1)
				collect_child(pid);
		} while (clang == 0 && errno != ECHILD);

		if (errno == ECHILD)
			return single_user;
	}

	warning("some processes would not die; ps axl advised");

	return single_user;
}

#ifdef LOGIN_CAP
void
setprocresources(char *class)
{
	login_cap_t *lc;

	if ((lc = login_getclass(class)) != NULL) {
		setusercontext(lc, NULL, 0,
		    LOGIN_SETPRIORITY|LOGIN_SETRESOURCES|LOGIN_SETUMASK);
		login_close(lc);
	}
}
#endif
@


1.64
log
@Use the safe idiom of cleaning sensitive data from memory with explicit_bzero,
instead of relying on other methods, after readpassphrase. Some programs on
this diff won't benefit that much since it happens near the terminal path, but
someone might copy the unsafe idiom to another program and place it where it
may leak sensitive data.

Discussed aeons ago with tb@@, OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.63 2017/03/02 10:38:09 natano Exp $	*/
d1328 1
a1328 1
#ifdef CPU_LIDSUSPEND
@


1.63
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.62 2016/09/05 10:20:40 gsoares Exp $	*/
d564 2
a565 1
				clear = readpassphrase("Password:", pbuf, sizeof(pbuf), RPP_ECHO_OFF);
d570 1
a570 1
				memset(clear, 0, strlen(clear));
@


1.62
log
@replace obsolete getpass() by readpassphrase()
OK tedu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.61 2016/09/04 12:30:01 nicm Exp $	*/
d1328 2
a1329 2
	int lidsuspend_mib[] = {CTL_MACHDEP, CPU_LIDSUSPEND};
	int dontsuspend = 0;
d1332 3
a1334 3
	    (sysctl(lidsuspend_mib, 2, NULL, NULL, &dontsuspend,
		    sizeof(dontsuspend)) == -1) && (errno != EOPNOTSUPP))
			warning("cannot disable lid suspend");
@


1.61
log
@Use an RB tree instead of BDB to map process->session, ok tedu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.60 2016/08/27 01:55:30 guenther Exp $	*/
d61 1
d532 1
d564 1
a564 1
				clear = getpass("Password:");
@


1.60
log
@Pull in <sys/time.h> for struct timespec

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.59 2016/05/10 21:54:59 bluhm Exp $	*/
d40 1
a43 1
#include <db.h>
d47 1
d160 1
d163 5
a190 1
int start_session_db(void);
a193 1
DB *session_db;
d775 1
a775 3
 * Open the session database.
 *
 * NB: We could pass in the size here; is it necessary?
d777 2
a778 2
int
start_session_db(void)
d780 3
a782 4
	if (session_db && (*session_db->close)(session_db))
		emergency("session database close: %s", strerror(errno));
	if ((session_db = dbopen(NULL, O_RDWR, 0, DB_HASH, NULL)) == 0) {
		emergency("session database open: %s", strerror(errno));
a783 1
	}
d793 1
a793 9
	DBT key;
	DBT data;

	key.data = &sp->se_process;
	key.size = sizeof sp->se_process;
	data.data = &sp;
	data.size = sizeof sp;

	if ((*session_db->put)(session_db, &key, &data, 0))
d803 1
a803 7
	DBT key;

	key.data = &sp->se_process;
	key.size = sizeof sp->se_process;

	if ((*session_db->del)(session_db, &key, 0))
		emergency("delete %d: %s", sp->se_process, strerror(errno));
d812 4
a815 10
	DBT key;
	DBT data;
	session_t *ret;

	key.data = &pid;
	key.size = sizeof pid;
	if ((*session_db->get)(session_db, &key, &data, 0) != 0)
		return (0);
	memcpy(&ret, data.data, sizeof(ret));
	return (ret);
a956 2
	if (start_session_db())
		return single_user;
@


1.59
log
@Do not close the stdio file desciptors in init(8), but dup2(2) them
from /dev/null.  The code is taken from daemon(3).  Also move this
operation to the beginning.
OK millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.58 2016/02/01 20:14:51 jca Exp $	*/
d37 1
d39 1
a40 1
#include <sys/reboot.h>
@


1.58
log
@Remove variable unneeded since introduction of crypt_checkpass

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.57 2015/12/23 02:41:12 mmcc Exp $	*/
d195 1
a195 1
	int c;
d212 11
a281 7

	/*
	 * Paranoia.
	 */
	close(STDIN_FILENO);
	close(STDOUT_FILENO);
	close(STDERR_FILENO);
@


1.57
log
@Use NULL rather than 0 for pointers. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.56 2015/12/10 17:27:00 mmcc Exp $	*/
d520 1
a520 1
	char *clear, *password;
@


1.56
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.55 2015/11/18 19:25:07 tedu Exp $	*/
d697 2
a698 2
		argv[2] = runcom_mode == AUTOBOOT ? "autoboot" : 0;
		argv[3] = 0;
d900 2
a901 2
	sp->se_next = 0;
	if (sprev == 0) {
d903 1
a903 1
		sp->se_prev = 0;
d928 1
a928 1
		sp->se_getty = 0;
d970 1
a970 1
	sessions = 0;
d1241 1
a1241 1
		for (sprev = 0, sp = sessions; sp; sprev = sp, sp = sp->se_next)
@


1.55
log
@use _shadow getpwnam (and crypt_checkpass)
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.54 2015/08/20 22:02:21 deraadt Exp $	*/
d932 1
a932 2
		if (sp->se_window)
			free(sp->se_window);
@


1.54
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.53 2015/07/14 19:14:05 millert Exp $	*/
d546 1
a546 1
		pp = getpwnam("root");
d551 1
d553 1
a553 1
				if (clear == 0 || *clear == '\0')
d555 4
a558 3
				password = crypt(clear, pp->pw_passwd);
				memset(clear, 0, _PASSWORD_LEN);
				if (strcmp(password, pp->pw_passwd) == 0)
@


1.53
log
@Use volatile sig_atomic_t for requested_transition since it is
modified inside signal handlers.  Instead of returning a function
pointer, the state functions now return an enum for the next state.
This is used as an index into an array of function pointers to
do the actual state change in transition().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.52 2015/01/16 06:39:58 deraadt Exp $	*/
d837 1
a837 2
	char **argv = (char **) calloc((strlen(command) + 1) / 2 + 1,
	    sizeof (char *));
@


1.52
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.51 2014/12/06 00:20:22 bluhm Exp $	*/
d96 39
a134 18
/*
 * We really need a recursive typedef...
 * The following at least guarantees that the return type of (*state_t)()
 * is sufficiently wide to hold a function pointer.
 */
typedef long (*state_func_t)(void);
typedef state_func_t (*state_t)(void);

state_func_t single_user(void);
state_func_t runcom(void);
state_func_t read_ttys(void);
state_func_t multi_user(void);
state_func_t clean_ttys(void);
state_func_t catatonia(void);
state_func_t death(void);
state_func_t do_reboot(void);
state_func_t hard_death(void);
state_func_t nice_death(void);
d139 1
a139 1
state_t requested_transition = DEFAULT_STATE;
d466 1
a466 1
		s = (state_t) (*s)();
d506 2
a507 2
state_func_t
single_user(void)
d631 1
a631 1
		return (state_func_t) single_user;
d642 1
a642 1
			return (state_func_t) single_user;
d652 1
a652 1
		return (state_func_t) requested_transition;
d664 1
a664 1
			return (state_func_t) single_user;
d669 1
a669 1
	return (state_func_t) runcom;
d675 2
a676 2
state_func_t
runcom(void)
d713 1
a713 1
		return (state_func_t) single_user;
d727 1
a727 1
			return (state_func_t) single_user;
d750 1
a750 1
		return (state_func_t) single_user;
d754 1
a754 1
		return (state_func_t) single_user;
d759 1
a759 1
	return (state_func_t) read_ttys;
d953 2
a954 2
state_func_t
read_ttys(void)
d972 1
a972 1
		return (state_func_t) single_user;
d984 1
a984 1
	return (state_func_t) multi_user;
d1184 2
a1185 2
state_func_t
multi_user(void)
d1220 1
a1220 1
	return (state_func_t) requested_transition;
d1226 2
a1227 2
state_func_t
clean_ttys(void)
d1280 1
a1280 1
	return (state_func_t) multi_user;
d1286 2
a1287 2
state_func_t
catatonia(void)
d1294 1
a1294 1
	return (state_func_t) multi_user;
d1311 2
a1312 2
state_func_t
do_reboot(void)
d1315 1
a1315 1
	return nice_death();
d1322 2
a1323 2
state_func_t
hard_death(void)
d1326 1
a1326 1
	return nice_death();
d1332 2
a1333 2
state_func_t
nice_death(void)
d1415 1
a1415 1
	return (state_func_t) single_user;
d1421 2
a1422 2
state_func_t
death(void)
d1440 1
a1440 1
			return (state_func_t) single_user;
d1450 1
a1450 1
			return (state_func_t) single_user;
d1455 1
a1455 1
	return (state_func_t) single_user;
@


1.51
log
@Do not define the variable pid twice to avoid a compiler warning.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.50 2014/04/22 20:40:37 tedu Exp $	*/
d36 1
a36 1
#include <sys/param.h>
d491 2
a492 2
	char shell[MAXPATHLEN];		/* Allocate space here */
	char name[MAXPATHLEN];		/* Name (argv[0]) of shell */
@


1.50
log
@malloc/memset->calloc. with bonus null check. from peter malone.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.49 2014/01/03 22:29:00 millert Exp $	*/
a1342 1
		pid_t pid;
@


1.49
log
@Do not raise the securelevel when transitioning from catatonia to
multiuser since we are not actually going multiuser.  Fixes a problem
where the securelevel was raised for rc.shutdown even when reboot
was run from single user mode.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.48 2013/02/11 15:52:42 millert Exp $	*/
d863 3
a865 2
	sp = (session_t *) malloc(sizeof (session_t));
	memset(sp, 0, sizeof *sp);
@


1.48
log
@Ignore sysctl failure for CPU_LIDSUSPEND when errno is EOPNOTSUPP.
Just because CPU_LIDSUSPEND is defined in cpu.h does mean it is
actually supported by the hardware.  OK halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.47 2012/10/11 22:21:29 halex Exp $	*/
a1167 2
	requested_transition = 0;

d1174 6
a1179 2
	if (getsecuritylevel() == 0)
		setsecuritylevel(1);
@


1.47
log
@fix "disable lidsuspend on shutdown":
- pull in machine/cpu.h so we can actually see CPU_LIDSUSPEND if it's there
- fix the resulting compilation errors now that the code is actually used

"Just go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.46 2012/04/06 17:25:00 deraadt Exp $	*/
d1323 1
a1323 1
		    sizeof(dontsuspend)) < 0))
@


1.46
log
@no need to (unsigned) a small constant
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.45 2010/10/15 07:11:02 dlg Exp $	*/
d40 1
d1317 1
a1317 1
#if CPU_LIDSUSPEND
a1324 1
	}
@


1.45
log
@freebsd uses SIGINT to request a reboot, we may as well be consistent.

pointed out by kettenis@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.44 2010/10/14 23:48:57 dlg Exp $	*/
d1065 1
a1065 1
		sleep((unsigned) GETTY_SLEEP);
@


1.44
log
@add a SIGQUIT handler that does the same as USR1 and USR2, except it
reboots the machine instead just halting or powering down.

diff from Jonathan Matthew
manpage tweaks from jmc@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.43 2010/09/29 13:23:37 dcoppa Exp $	*/
d235 1
a235 1
	handle(transition_handler, SIGHUP, SIGQUIT, SIGTERM, SIGTSTP,
d240 1
a240 1
	    SIGXCPU, SIGXFSZ, SIGHUP, SIGQUIT, SIGTERM, SIGUSR1, SIGUSR2,
d1137 1
a1137 1
	case SIGQUIT:
@


1.43
log
@Add missing err.h include

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.42 2010/08/07 10:22:28 phessler Exp $	*/
d110 1
d235 2
a236 2
	handle(transition_handler, SIGHUP, SIGTERM, SIGTSTP, SIGUSR1,
	    SIGUSR2, 0);
d240 1
a240 1
	    SIGXCPU, SIGXFSZ, SIGHUP, SIGTERM, SIGUSR1, SIGUSR2,
d1137 3
d1282 10
@


1.42
log
@disable lidsuspend when we are powering down

"I like this" marco@@, "Sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.41 2009/10/27 23:59:33 deraadt Exp $	*/
d42 1
@


1.41
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.40 2007/09/03 14:26:54 deraadt Exp $	*/
d1300 11
@


1.40
log
@malloc(n * m) -> calloc(n, m); ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.39 2006/06/22 00:25:22 deraadt Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)init.c	8.2 (Berkeley) 4/28/95";
#else
static char rcsid[] = "$OpenBSD: init.c,v 1.39 2006/06/22 00:25:22 deraadt Exp $";
#endif
#endif /* not lint */
@


1.39
log
@accept SIGUSR2.  Like SIGUSR1, except it makes RB_POWERDOWN mandatory.
This will be used by kernel components which are trying to really really
power the system down.  suggested and tested by jason
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.38 2006/03/19 18:43:56 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.38 2006/03/19 18:43:56 otto Exp $";
d827 1
a827 1
	char **argv = (char **) malloc(((strlen(command) + 1) / 2 + 1) *
@


1.38
log
@Fix mem leaks in error path. From NetBSD's coverity analysis. ok pat@@
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.37 2005/11/12 13:30:46 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.37 2005/11/12 13:30:46 deraadt Exp $";
d123 1
d247 2
a248 1
	handle(transition_handler, SIGHUP, SIGTERM, SIGTSTP, SIGUSR1, 0);
d252 2
a253 1
	    SIGXCPU, SIGXFSZ, SIGHUP, SIGTERM, SIGUSR1, SIGTSTP, SIGALRM, 0);
d1155 3
d1290 13
a1312 1
	int howto = RB_HALT;
d1355 1
a1355 1
				howto |= RB_POWERDOWN;
d1377 1
a1377 1
	reboot(howto);
@


1.37
log
@use snprintf; dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.36 2005/03/13 13:53:23 markus Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.36 2005/03/13 13:53:23 markus Exp $";
d828 1
a828 1
	if ((argv[argc++] = strtok(command, separators)) == 0)
d830 5
@


1.36
log
@turn off accounting when switching to single user;
report bluhm at genua.de; ok henning, krw, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.35 2004/03/16 01:11:09 tedu Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.35 2004/03/16 01:11:09 tedu Exp $";
a859 1
	size_t len;
d872 2
a873 3
	len = sizeof(_PATH_DEV) + strlen(typ->ty_name);
	sp->se_device = malloc(len);
	(void) snprintf(sp->se_device, len, "%s%s", _PATH_DEV, typ->ty_name);
a897 2
	size_t len;

d902 2
a903 3
	len = strlen(typ->ty_getty) + strlen(typ->ty_name) + 2;
	sp->se_getty = malloc(len);
	(void) snprintf(sp->se_getty, len, "%s %s", typ->ty_getty, typ->ty_name);
@


1.35
log
@errno is not specified to be int, but something from errno.h.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.34 2003/10/30 23:58:52 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.34 2003/10/30 23:58:52 deraadt Exp $";
d1303 3
d1375 3
@


1.34
log
@malloc failures in init?  never.  but try to be reasonable for one dumb one
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.33 2003/07/29 18:38:36 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.33 2003/07/29 18:38:36 deraadt Exp $";
a425 1
	extern int errno;
@


1.33
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.32 2003/06/02 20:06:15 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.32 2003/06/02 20:06:15 millert Exp $";
d921 4
d926 1
a926 1
		if (sp->se_window_argv == 0) {
d930 1
a930 1
			sp->se_window = 0;
@


1.32
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.31 2003/03/30 18:09:44 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.31 2003/03/30 18:09:44 deraadt Exp $";
d245 1
a245 1
	       SIGBUS, SIGXCPU, SIGXFSZ, 0);
d250 1
a250 1
		SIGXCPU, SIGXFSZ, SIGHUP, SIGTERM, SIGUSR1, SIGTSTP, SIGALRM, 0);
d650 1
a650 1
		} else {	
d714 1
a714 1
				_PATH_BSHELL, _PATH_RUNCOM);
d719 1
a719 1
				_PATH_BSHELL, _PATH_RUNCOM);
d737 1
a737 1
			_PATH_BSHELL, _PATH_RUNCOM);
d825 2
a826 2
	char **argv = (char **) malloc(((strlen(command) + 1) / 2 + 1)
						* sizeof (char *));
d924 1
a924 1
				sp->se_device);
d981 1
a981 1
			sp->se_device);
d999 1
a999 1
		sp->se_window_argv[0], sp->se_device);
d1070 1
a1070 1
		        sp->se_device);
d1086 1
a1086 1
		sp->se_getty_argv[0], sp->se_device);
d1224 2
a1225 2
				       sp->se_device, sp->se_index,
				       session_index);
d1237 1
a1237 1
					sp->se_device);
d1341 1
a1341 1
		do
d1344 1
a1344 1
		while (clang == 0 && errno != ECHILD);
d1382 1
a1382 1
		do
d1385 1
a1385 1
		while (clang == 0 && errno != ECHILD);
@


1.31
log
@snprintf; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.30 2002/12/11 21:58:37 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: init.c,v 1.30 2002/12/11 21:58:37 millert Exp $";
@


1.30
log
@Minor cosmetic nits picked while reading though init.c:
o Use STD{IN,OUT,ERR}_FILENO, not 0-2
o Call exit() from main, not return() (code is never reached anyway)
o Change two cases of '!' into "== NULL"
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.29 2002/10/10 23:27:54 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.29 2002/10/10 23:27:54 millert Exp $";
d865 1
d878 3
a880 2
	sp->se_device = malloc(sizeof(_PATH_DEV) + strlen(typ->ty_name));
	(void) sprintf(sp->se_device, "%s%s", _PATH_DEV, typ->ty_name);
d905 1
d911 3
a913 2
	sp->se_getty = malloc(strlen(typ->ty_getty) + strlen(typ->ty_name) + 2);
	(void) sprintf(sp->se_getty, "%s %s", typ->ty_getty, typ->ty_name);
@


1.29
log
@Style nits.  Use STDERR_FILENO, not just 2.  Also use parens with
return; David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.28 2002/07/03 22:32:32 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.28 2002/07/03 22:32:32 deraadt Exp $";
d266 3
a268 3
	close(0);
	close(1);
	close(2);
d278 1
a278 1
	return (1);
d1099 1
a1099 1
	if (! sessions)
d1102 1
a1102 1
	if (! (sp = find_session(pid)))
@


1.28
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.27 2002/06/09 08:13:06 todd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.27 2002/06/09 08:13:06 todd Exp $";
d278 1
a278 1
	return 1;
d541 1
a541 1
			write(2, banner, sizeof banner - 1);
d817 1
a817 1
		return 0;
d819 1
a819 1
	return ret;
d834 1
a834 1
		return 0;
d837 1
a837 1
	return argv;
d869 1
a869 1
		return 0;
d894 1
a894 1
	return sp;
d1022 1
a1022 1
			return -1;
d1030 1
a1030 1
		return -1;
d1040 1
a1040 1
				return -1;
d1048 1
a1048 1
		return pid;
@


1.27
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.26 2002/05/22 08:21:02 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.26 2002/05/22 08:21:02 deraadt Exp $";
d186 1
a186 3
main(argc, argv)
	int argc;
	char **argv;
d362 1
d366 1
a366 1
	vsyslog(LOG_EMERG, message, ap);
a367 1
	closelog();
d377 1
a377 2
badsys(sig)
	int sig;
d390 1
a390 2
disaster(sig)
	int sig;
d402 1
a402 1
getsecuritylevel()
d426 1
a426 2
setsecuritylevel(newlevel)
	int newlevel;
d455 1
a455 2
transition(s)
	state_t s;
d466 1
a466 2
clear_session_logs(sp)
	session_t *sp;
d479 1
a479 2
setctty(name)
	char *name;
d484 1
a484 1
	sleep (2);			/* leave DTR low */
d499 1
a499 1
single_user()
d668 1
a668 1
runcom()
d760 1
a760 1
start_session_db()
a768 1
		
d775 1
a775 2
add_session(sp)
	session_t *sp;
d793 1
a793 2
del_session(sp)
	session_t *sp;
d826 1
a826 2
construct_argv(command)
	char *command;
d844 1
a844 2
free_session(sp)
	session_t *sp;
d862 1
a862 4
new_session(sprev, session_index, typ)
	session_t *sprev;
	int session_index;
	struct ttyent *typ;
d901 1
a901 3
setupargv(sp, typ)
	session_t *sp;
	struct ttyent *typ;
d937 1
a937 1
read_ttys()
d974 1
a974 2
start_window_system(sp)
	session_t *sp;
d1010 1
a1010 2
start_getty(sp)
	session_t *sp;
d1136 1
a1136 2
transition_handler(sig)
	int sig;
d1162 1
a1162 1
multi_user()
d1202 1
a1202 1
clean_ttys()
d1262 1
a1262 1
catatonia()
d1276 1
a1276 2
alrm_handler(sig)
	int sig;
d1285 1
a1285 1
nice_death()
d1363 1
a1363 1
death()
d1398 1
a1398 2
setprocresources(class)
	char *class;
@


1.26
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.25 2002/02/19 19:39:38 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.25 2002/02/19 19:39:38 millert Exp $";
d655 3
a657 3
		if (WTERMSIG(status) == SIGKILL) { 
			/* 
			 *  reboot(8) killed shell? 
d1026 1
a1026 1
 * that do not exist. 
d1193 1
a1193 1
	 * mode, and the run script has not set a higher level of security 
@


1.25
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.24 2002/02/16 21:27:35 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.24 2002/02/16 21:27:35 millert Exp $";
d524 2
a525 2
	strcpy(shell, _PATH_BSHELL);
	strcpy(name, "-sh");
d572 1
d585 1
a585 1
				strcpy(shell, altshell);
d593 1
a593 1
				strcpy(&name[1], p);
@


1.24
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.23 2001/11/05 07:39:16 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.23 2001/11/05 07:39:16 mpech Exp $";
d63 1
a72 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a286 1
#ifdef __STDC__
a287 4
#else
handle(va_alist)
	va_dcl
#endif
a292 2
#ifndef __STDC__
	sig_t handler;
a293 3
	va_start(ap);
	handler = va_arg(ap, sig_t);
#else
a294 1
#endif
a312 1
#ifdef __STDC__
a313 4
#else
delset(va_alist)
	va_dcl
#endif
a316 2
#ifndef __STDC__
	sigset_t *maskp;
a317 3
	va_start(ap);
	maskp = va_arg(ap, sigset_t *);
#else
a318 2
#endif

a329 1
#ifdef __STDC__
a330 4
#else
stall(va_alist)
	va_dcl
#endif
a332 2
#ifndef __STDC__
	char *message;
a333 3
	va_start(ap);
	message = va_arg(ap, char *);
#else
a334 2
#endif

a346 1
#ifdef __STDC__
a347 4
#else
warning(va_alist)
	va_dcl
#endif
a349 2
#ifndef __STDC__
	char *message;
a350 3
	va_start(ap);
	message = va_arg(ap, char *);
#else
a351 2
#endif

a361 1
#ifdef __STDC__
a362 4
#else
emergency(va_alist)
	va_dcl
#endif
a364 2
#ifndef __STDC__
	char *message;
a365 3
	va_start(ap);
	message = va_arg(ap, char *);
#else
a366 2
#endif

a817 1
#ifdef __STDC__
a818 4
#else
find_session(pid)
	pid_t pid;
#endif
a1113 1
#ifdef __STDC__
a1114 4
#else
collect_child(pid)
	pid_t pid;
#endif
@


1.23
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.22 2001/07/09 07:04:45 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.22 2001/07/09 07:04:45 deraadt Exp $";
d108 2
a109 2
void handle __P((sig_t, ...));
void delset __P((sigset_t *, ...));
d111 5
a115 5
void stall __P((char *, ...));
void warning __P((char *, ...));
void emergency __P((char *, ...));
void disaster __P((int));
void badsys __P((int));
d122 2
a123 2
typedef long (*state_func_t) __P((void));
typedef state_func_t (*state_t) __P((void));
d125 8
a132 8
state_func_t single_user __P((void));
state_func_t runcom __P((void));
state_func_t read_ttys __P((void));
state_func_t multi_user __P((void));
state_func_t clean_ttys __P((void));
state_func_t catatonia __P((void));
state_func_t death __P((void));
state_func_t nice_death __P((void));
d136 1
a136 1
void transition __P((state_t));
d139 1
a139 1
void setctty __P((char *));
d158 2
a159 2
void free_session __P((session_t *));
session_t *new_session __P((session_t *, int, struct ttyent *));
d162 9
a170 9
char **construct_argv __P((char *));
void start_window_system __P((session_t *));
void collect_child __P((pid_t));
pid_t start_getty __P((session_t *));
void transition_handler __P((int));
void alrm_handler __P((int));
void setsecuritylevel __P((int));
int getsecuritylevel __P((void));
int setupargv __P((session_t *, struct ttyent *));
d174 1
a174 1
void setprocresources __P((char *));
d179 1
a179 1
void clear_session_logs __P((session_t *));
d181 4
a184 4
int start_session_db __P((void));
void add_session __P((session_t *));
void del_session __P((session_t *));
session_t *find_session __P((pid_t));
@


1.22
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.21 2001/01/19 17:57:37 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.21 2001/01/19 17:57:37 deraadt Exp $";
d908 2
a909 2
	register int argc = 0;
	register char **argv = (char **) malloc(((strlen(command) + 1) / 2 + 1)
d925 1
a925 1
	register session_t *sp;
d946 1
a946 1
	register struct ttyent *typ;
d948 1
a948 1
	register session_t *sp;
d1026 2
a1027 2
	register session_t *sp, *snext;
	register struct ttyent *typ;
d1190 1
a1190 1
	register session_t *sp, *sprev, *snext;
d1259 1
a1259 1
	register session_t *sp;
d1298 4
a1301 4
	register session_t *sp, *sprev;
	register struct ttyent *typ;
	register int session_index = 0;
	register int devlen;
d1358 1
a1358 1
	register session_t *sp;
d1382 2
a1383 2
	register session_t *sp;
	register int i;
d1460 2
a1461 2
	register session_t *sp;
	register int i;
@


1.21
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.20 2000/08/20 18:42:39 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.20 2000/08/20 18:42:39 millert Exp $";
d1419 1
a1419 1
			    NULL);
@


1.20
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.18 2000/01/22 20:24:58 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.18 2000/01/22 20:24:58 deraadt Exp $";
d640 1
a640 1
					cp++;
@


1.19
log
@Add DEFAULT_STATE macro to allow ramdisk init to set default state to
single_user, not runcom (/etc/rc).
@
text
@d82 4
d97 7
d173 6
d763 2
d1082 2
d1170 2
d1490 15
@


1.18
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.17 1999/09/03 18:11:49 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.17 1999/09/03 18:11:49 deraadt Exp $";
d93 4
d126 1
a126 1
state_t requested_transition = runcom;
@


1.17
log
@have shutdown code run /etc/rc with arg of "shutdown"; rc.shutdown becomes  completely admin-editable
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.16 1999/07/06 07:54:44 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.16 1999/07/06 07:54:44 deraadt Exp $";
a453 1
	extern int errno;
@


1.16
log
@if SIGUSR1 is received, kill gettys, run /etc/rc.shutdown, and halt the machine
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.15 1998/06/03 16:20:24 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.15 1998/06/03 16:20:24 deraadt Exp $";
a1349 2
#define _PATH_RCSHUTDOWN        "/etc/rc.shutdown"

d1372 1
a1372 1
	if (access(_PATH_RCSHUTDOWN, R_OK) != -1) {
d1392 4
a1395 3
			execl(_PATH_BSHELL, "sh", _PATH_RCSHUTDOWN, NULL);
			stall("can't exec %s for %s: %m", _PATH_BSHELL,
			    _PATH_RCSHUTDOWN);
@


1.15
log
@zero sigaction before use
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.14 1998/05/04 06:37:02 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.14 1998/05/04 06:37:02 deraadt Exp $";
d57 1
d117 1
d236 1
a236 1
	handle(transition_handler, SIGHUP, SIGTERM, SIGTSTP, 0);
d240 1
a240 1
		SIGXCPU, SIGXFSZ, SIGHUP, SIGTERM, SIGTSTP, SIGALRM, 0);
d1214 3
d1348 79
@


1.14
log
@LETS_GET_BIG
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.13 1998/04/13 15:26:46 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.13 1998/04/13 15:26:46 millert Exp $";
d240 1
d289 1
d725 1
@


1.13
log
@Use _PATH_DEV, not "/dev/"
Make init(8) call login_fbtab() correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.12 1998/03/03 01:15:13 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.12 1998/03/03 01:15:13 deraadt Exp $";
a119 1
#ifndef LETS_GET_SMALL
a120 3
#else /* LETS_GET_SMALL */
state_t requested_transition = single_user;
#endif /* LETS_GET_SMALL */
a175 1
#ifndef LETS_GET_SMALL
a192 1
#endif /* LETS_GET_SMALL */
a206 1
#ifndef LETS_GET_SMALL
a225 3
#else /* LETS_GET_SMALL */
	requested_transition = single_user;
#endif /* LETS_GET_SMALL */
a707 1
#ifndef LETS_GET_SMALL
a708 3
#else /* LETS_GET_SMALL */
	return (state_func_t) single_user;
#endif /* LETS_GET_SMALL */
a710 1
#ifndef LETS_GET_SMALL
a1145 1
#endif /* LETS_GET_SMALL */
a1158 1
#ifndef LETS_GET_SMALL
a1191 1
#endif /* LETS_GET_SMALL */
a1202 1
#ifndef LETS_GET_SMALL
a1211 1
#endif /* LETS_GET_SMALL */
a1217 1
#ifndef LETS_GET_SMALL
a1330 1
#endif /* LETS_GET_SMALL */
a1341 1
#ifndef LETS_GET_SMALL
a1377 1
#endif /* LETS_GET_SMALL */
@


1.12
log
@sigset_t; jraynard
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.11 1997/09/14 10:37:45 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.11 1997/09/14 10:37:45 deraadt Exp $";
d1185 1
a1185 1
	login_fbtab(sp->se_device, 0, 0);
@


1.11
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.10 1997/06/25 18:18:58 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.10 1997/06/25 18:18:58 kstailey Exp $";
d287 1
a287 1
	int mask_everything;
@


1.10
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.9 1997/03/25 23:12:23 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.9 1997/03/25 23:12:23 deraadt Exp $";
d301 1
a301 1
	while (sig = va_arg(ap, int)) {
d332 1
a332 1
	while (sig = va_arg(ap, int))
d903 1
a903 1
	while (argv[argc++] = strtok(NULL, separators))
d1035 2
a1036 2
	while (typ = getttyent())
		if (snext = new_session(sp, ++session_index, typ))
d1190 1
a1190 1
		if (sprev = sp->se_prev)
d1194 1
a1194 1
		if (snext = sp->se_next)
d1294 1
a1294 1
	while (typ = getttyent()) {
@


1.9
log
@closelog() more often
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.8 1997/02/22 08:38:10 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.8 1997/02/22 08:38:10 millert Exp $";
d249 1
a249 1
	sigprocmask(SIG_SETMASK, &mask, (sigset_t *) 0);
d253 2
a254 2
	(void) sigaction(SIGTTIN, &sa, (struct sigaction *)0);
	(void) sigaction(SIGTTOU, &sa, (struct sigaction *)0);
d305 1
a305 1
		sigaction(sig, &sa, (struct sigaction *) 0);
d653 1
a653 1
		sigprocmask(SIG_SETMASK, &mask, (sigset_t *) 0);
d678 1
a678 1
		while (waitpid(-1, (int *) 0, WNOHANG) > 0)
d741 2
a742 2
		(void) sigaction(SIGTSTP, &sa, (struct sigaction *)0);
		(void) sigaction(SIGHUP, &sa, (struct sigaction *)0);
d751 1
a751 1
		sigprocmask(SIG_SETMASK, &sa.sa_mask, (sigset_t *) 0);
d761 1
a761 1
		while (waitpid(-1, (int *) 0, WNOHANG) > 0)
d903 1
a903 1
	while (argv[argc++] = strtok((char *) 0, separators))
d1065 1
a1065 1
	sigprocmask(SIG_SETMASK, &mask, (sigset_t *) 0);
d1088 1
a1088 1
	time_t current_time = time((time_t *) 0);
d1154 1
a1154 1
	sigprocmask(SIG_SETMASK, &mask, (sigset_t *) 0);
d1207 1
a1207 1
	sp->se_started = time((time_t *) 0);
d1268 1
a1268 1
		sp->se_started = time((time_t *) 0);
d1273 1
a1273 1
		if ((pid = waitpid(-1, (int *) 0, 0)) != -1)
d1389 1
a1389 1
			if ((pid = waitpid(-1, (int *)0, 0)) != -1)
@


1.8
log
@Update to lite2 -- man page is the only thing that changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.7 1996/07/31 18:29:38 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.7 1996/07/31 18:29:38 deraadt Exp $";
d362 1
d391 1
d418 1
@


1.7
log
@at session termination, login_fbtab devs back to root
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.6 1996/07/12 10:16:15 deraadt Exp $	*/
d48 1
a48 1
static char sccsid[] = "@@(#)init.c	8.1 (Berkeley) 7/15/93";
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.6 1996/07/12 10:16:15 deraadt Exp $";
@


1.6
log
@precheck getty devices for existance; if not there shut then down
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.5 1996/07/12 06:45:29 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.5 1996/07/12 06:45:29 deraadt Exp $";
d1182 1
@


1.5
log
@do not ask for password if none set; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.4 1996/07/12 01:03:44 weingart Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.4 1996/07/12 01:03:44 weingart Exp $";
d135 1
d1075 3
d1086 9
d1104 15
a1118 1
	if (pid)
d1120 17
@


1.4
log
@Fix netbsd pr bin/2620.  Fix dangling pointer while I am at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.3 1996/06/23 14:30:50 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.3 1996/06/23 14:30:50 deraadt Exp $";
d593 2
a594 1
		if (typ && (typ->ty_status & TTY_SECURE) == 0 && pp) {
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.22 1996/05/15 23:29:33 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: init.c,v 1.22 1996/05/15 23:29:33 jtc Exp $";
d558 2
a559 1
	char *shell = _PATH_BSHELL;
d569 4
d623 16
a638 2
			if (altshell[0] != '\0')
				shell = altshell;
d654 2
a655 2
		argv[0] = "-sh";
		argv[1] = 0;
d659 3
@


1.2
log
@libutil
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: init.c,v 1.22 1996/05/15 23:29:33 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: init.c,v 1.21 1995/10/05 06:11:24 mycroft Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: init.c,v 1.21 1995/10/05 06:11:24 mycroft Exp $";
d68 1
a80 7

/*
 * Until the mythical util.h arrives...
 */
extern int login_tty __P((int));
extern int logout __P((const char *));
extern void logwtmp __P((const char *, const char *, const char *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

