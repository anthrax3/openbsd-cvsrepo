head	1.28;
access;
symbols
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.24.0.4
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.28
date	2003.03.13.00.33.47;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2002.08.08.20.17.34;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.10.19.58.20;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.07.18.26.18;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.27.03.31.46;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.05.00.17.48;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.28.22.45.11;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.16.08.31.56;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.15.07.29.44;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.15.02.42.08;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.15.01.58.27;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.15.01.06.51;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.14.23.28.58;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.14.18.32.25;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.13.08.36.27;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.12.01.53.41;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.11.21.37.46;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.11.21.21.18;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.11.20.32.15;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.11.02.16.50;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.25.05.16.46;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.27.08.06.38;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.12.05.21.46.13;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.07.02.23.37.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.03.31.20.33.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.03.27.21.18.01;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.11.14.23.37.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@thought we had already deleted this
@
text
@/*	$OpenBSD: kernel.c,v 1.27 2002/08/08 20:17:34 aaron Exp $	*/

/*
 * Copyright 1997-2000 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * The following functions handle the interaction of the Photuris daemon
 * with the PF_ENCAP interface as used by OpenBSD's IPsec implementation.
 * This is the only file which needs to be changed for making Photuris
 * work with other kernel interfaces.
 * The SPI object here can actually hold two SPIs, one for encryption
 * and one for authentication.
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: kernel.c,v 1.27 2002/08/08 20:17:34 aaron Exp $";
#endif

#include <time.h>
#include <sys/time.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <poll.h>

#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ah.h>

#define _KERNEL_C_
#include "photuris.h"
#include "state.h"
#include "attributes.h"
#include "buffer.h"
#include "api.h"
#include "spi.h"
#include "kernel.h"
#include "log.h"
#include "server.h"
#ifdef DEBUG
#include "config.h"
#endif

#define POLL_TIMEOUT	500

#define SPITOINT(x) (((x)[0]<<24) + ((x)[1]<<16) + ((x)[2]<<8) + (x)[3])
#define KERNEL_XF_SET(x) kernel_xf_set(sd, buffer, BUFFER_SIZE, iov, cnt, x)

static int sd;		/* normal PFKEY socket */
static int regsd;	/* PFKEY socket for Register and Acquire */
static int pfkey_seq;
static pid_t pfkey_pid;

struct pfmsg {
	TAILQ_ENTRY(pfmsg) next;

	struct sadb_msg *smsg;
};

TAILQ_HEAD(pflist, pfmsg) pfqueue;

/*
 * Translate a Photuris ID into a data structure for the
 * corresponding Kernel transform.
 */

transform *
kernel_get_transform(int id)
{
     int i;

     for (i=sizeof(xf)/sizeof(transform)-1; i >= 0; i--)
	  if (xf[i].photuris_id == id)
	       return &xf[i];
     return NULL;
}

/*
 * Mark a transform as supported by the kernel
 */

void
kernel_transform_seen(int id, int type)
{
	int i;

	for (i=sizeof(xf)/sizeof(transform)-1; i >= 0; i--)
		if (xf[i].kernel_id == id && (xf[i].flags & type)) {
			LOG_DBG((LOG_KERNEL, 50,
				 "%s: %s algorithm %d", __func__
				 type == XF_ENC ? "enc" : "auth", id));
			xf[i].flags |= XF_SUP;
			return;
		}
}

/*
 * Parse the supported transforms returned in the SADB_REGISTER response
 */

void
kernel_transform_parse(struct sadb_supported *ssup)
{
	struct sadb_alg *salg = (struct sadb_alg *)(ssup + 1);
	int i, type;

	type = ssup->sadb_supported_exttype == SADB_EXT_SUPPORTED_AUTH ?
		XF_AUTH : XF_ENC;

	for (i = 0; i < ssup->sadb_supported_len - 1; i++, salg++)
		kernel_transform_seen(salg->sadb_alg_id, type);
}

/*
 * See if we know about this transform and if it is supported
 * by the kernel.
 */

int
kernel_known_transform(int id)
{
     transform *xf = kernel_get_transform(id);

     return (xf == NULL || !(xf->flags & XF_SUP)) ? -1 : 0;
}

/*
 * For ESP, we can specify an additional AH transform.
 * Not all combinations are possible.
 * Returns AT_ENC, when the ESP transform does not allow this AH.
 * Returns AT_AUTH, when the AH transform does not work with ESP.
 */

int
kernel_valid(attrib_t *enc, attrib_t *auth)
{
     transform *xf_enc, *xf_auth;

     xf_enc = kernel_get_transform(enc->id);
     xf_auth = kernel_get_transform(auth->id);

     if (xf_enc->flags & ESP_OLD)
	  return AT_ENC;
     if (!(xf_auth->flags & ESP_NEW))
	  return AT_AUTH;
     return (0);
}

/*
 * Check if the chosen authentication transform, satisfies the
 * selected flags.
 */

int
kernel_valid_auth(attrib_t *auth, u_int8_t *flag, u_int16_t size)
{
     int i, hmac = 0;
     transform *xf_auth = kernel_get_transform(auth->id);

     if (xf_auth == NULL)
	  return (-1); /* We don't know this attribute */

     for (i=0; i<size; i++) {
	  switch (flag[i]) {
	  case AT_HMAC:
	       hmac = 1;
	       break;
	  default:
	       break;
	  }
     }

     if (!hmac && !(xf_auth->flags & AH_OLD))
	  return (-1);
     if (hmac && !(xf_auth->flags & AH_NEW))
	  return (-1);

     return (0);
}

int
init_kernel(void)
{
	TAILQ_INIT(&pfqueue);
	
	if ((sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1)
		log_fatal("%s: socket(PF_KEY) for IPsec key engine", __func__);
	if ((regsd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1)
		log_fatal("%s: socket() for PFKEY register", __func__);

	pfkey_seq = 0;
	pfkey_pid = getpid();

	if (kernel_register(regsd) == -1)
		log_fatal("%s: PFKEY socket registration failed", __func__);

	return (1);
}

int
kernel_get_socket(void)
{
     return regsd;
}

void
kernel_set_socket_policy(int sd)
{
     int level;

     /*
      * Need to bypass system security policy, so I can send and
      * receive key management datagrams in the clear.
      */

     level = IPSEC_LEVEL_BYPASS;   /* Did I mention I'm privileged? */
     if (setsockopt(sd, IPPROTO_IP, IP_AUTH_LEVEL, (char *)&level,
		    sizeof (int)) == -1)
	  log_fatal("setsockopt: can not bypass IPsec authentication policy");
     if (setsockopt(sd, IPPROTO_IP, IP_ESP_TRANS_LEVEL,
			(char *)&level, sizeof (int)) == -1)
	  log_fatal("setsockopt: can not bypass IPsec ESP transport policy");
     if (setsockopt(sd, IPPROTO_IP, IP_ESP_NETWORK_LEVEL,
		    (char *)&level, sizeof (int)) == -1)
	  log_fatal("setsockopt: can not bypass IPsec ESP network policy");
}

struct sadb_ext *
pfkey_find_extension(struct sadb_ext *start, void *end, u_int16_t type)
{
	struct sadb_ext *p = start;

	while ((void *)p < end) {
		if (p->sadb_ext_type == type)
			return (p);
		p = (struct sadb_ext *)((u_char *)p + p->sadb_ext_len * 8);
	}
	
	return (NULL);
}

int
kernel_xf_set(int sd, char *buffer, int blen, struct iovec *iov,
	      int cnt, int len)
{
     struct sadb_msg *sres;
     int seq;

     sres = (struct sadb_msg *)iov[0].iov_base;
     seq = sres->sadb_msg_seq;

     if (writev(sd, iov, cnt) != len) {
	  perror("writev() in kernel_xf_set()");
	  return (0);
     }

     if (buffer)
	  return kernel_xf_read(sd, buffer, blen, seq);
     return (1);
}

void
kernel_queue_msg(struct sadb_msg *smsg)
{
	struct pfmsg *pfmsg;

	LOG_DBG((LOG_KERNEL, 50, "%s: queuing message type %d",
		__func__, smsg->sadb_msg_type));

	pfmsg = malloc(sizeof(*pfmsg));
	if (pfmsg == NULL) {
		log_error("%s: malloc", __func__);
		return;
	}

	pfmsg->smsg = malloc(smsg->sadb_msg_len * 8);
	if (pfmsg->smsg == NULL) {
		log_error("%s: malloc", __func__);
		free(pfmsg);
		return;
	}

	memcpy(pfmsg->smsg, smsg, smsg->sadb_msg_len * 8);

	TAILQ_INSERT_TAIL(&pfqueue, pfmsg, next);
}

int
kernel_xf_read(int sd, char *buffer, int blen, int seq)
{
	struct sadb_msg *sres = (struct sadb_msg *)buffer;
	int len, forus;

	/*
	 * Read in response from the kernel. If seq number and/or PID are
	 * given, we need to check PID and sequence number to see if it
	 * really is a message for us.
	 */
	do {
		struct pollfd pfd;

		pfd.fd = sd;
		pfd.events = POLLIN;
		pfd.revents = 0;

		if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {
			log_error("%s: poll", __func__);
			return (0);
		}

		if (!(pfd.revents & POLLIN)) {
			log_print("%s: no reply from pfkey", __func__);
			return (0);
		}

		if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {
			log_error("%s: read()", __func__);
			return (0);
		}
		len = sres->sadb_msg_len * 8;
		if (len >= BUFFER_SIZE) {
			log_print("%s: PFKEYV2 message len %d too big", 
			    __func__, len);
			return (0);
		}
		if (read(sd, sres, len) != len) {
			log_error("%s: read()", __func__);
			return (0);
		}
	
		forus = !(sres->sadb_msg_pid &&
			  sres->sadb_msg_pid != pfkey_pid) &&
			!(seq && sres->sadb_msg_seq != seq);

		if (!forus) {
			switch (sres->sadb_msg_type) {
			case SADB_ACQUIRE:
			case SADB_EXPIRE:
				kernel_queue_msg(sres);
				break;
			default:
				LOG_DBG((LOG_KERNEL, 50, 
				    "%s: skipping message type %d", __func__,
				    sres->sadb_msg_type));
				break;
			}
		}
	
	} while (!forus);

	if (sres->sadb_msg_errno) {
		LOG_DBG((LOG_KERNEL, 40, "%s: PFKEYV2 result: %s",
		    __func__, strerror(sres->sadb_msg_errno)));
		errno = sres->sadb_msg_errno;
		return (0);
	}

	return (1);
}

int
kernel_register(int sd)
{
     struct sadb_msg smsg, *sres;
     struct sadb_supported *ssup;
     struct sadb_ext *ext;
     void *end;
     int encfound, authfound;
     struct iovec iov[1];
     int cnt = 0;

     LOG_DBG((LOG_KERNEL, 20, "%s: fd %d", __func__, sd));

     encfound = authfound = 0;

     bzero(&smsg, sizeof(smsg));

     smsg.sadb_msg_len = sizeof(smsg) / 8;
     smsg.sadb_msg_version = PF_KEY_V2;
     smsg.sadb_msg_seq = pfkey_seq++;
     smsg.sadb_msg_pid = pfkey_pid;
     smsg.sadb_msg_type = SADB_REGISTER;
     iov[cnt].iov_base = &smsg;
     iov[cnt++].iov_len = sizeof(smsg);

     /* Register for ESP */
     smsg.sadb_msg_satype = SADB_SATYPE_ESP;
     if (!kernel_xf_set(regsd, buffer, BUFFER_SIZE, iov, cnt,
			smsg.sadb_msg_len*8)) {
	  log_error("%s: kernel_xf_set()", __func__);
	  return (-1);
     }

     sres = (struct sadb_msg *)buffer;
     ext = (struct sadb_ext *)(sres + 1);
     end = (u_char *)sres + sres->sadb_msg_len * 8;
     ssup = (struct sadb_supported *)
	     pfkey_find_extension(ext, end, SADB_EXT_SUPPORTED_AUTH);
     if (ssup) {
	     kernel_transform_parse(ssup);
	     authfound = 1;
     }
     ssup = (struct sadb_supported *)
	     pfkey_find_extension(ext, end, SADB_EXT_SUPPORTED_ENCRYPT);
     if (ssup) {
	     kernel_transform_parse(ssup);
	     encfound = 1;
     }

     /* Register for AH */
     smsg.sadb_msg_satype = SADB_SATYPE_AH;
     smsg.sadb_msg_seq = pfkey_seq++;
     if (!kernel_xf_set(regsd, buffer, BUFFER_SIZE, iov, cnt,
			smsg.sadb_msg_len*8)) {
	  log_error("%s: kernel_xf_set()", __func__);
	  return (-1);
     }

     ext = (struct sadb_ext *)(sres + 1);
     end = (u_char *)sres + sres->sadb_msg_len * 8;

     ssup = (struct sadb_supported *)
	     pfkey_find_extension(ext, end, SADB_EXT_SUPPORTED_AUTH);
     if (ssup) {
	     kernel_transform_parse(ssup);
	     authfound = 1;
     }
     ssup = (struct sadb_supported *)
	     pfkey_find_extension(ext, end, SADB_EXT_SUPPORTED_ENCRYPT);
     if (ssup) {
	     kernel_transform_parse(ssup);
	     encfound = 1;
     }

     if (!authfound || !encfound) {
	     log_print("%s: SADB_REGISTER without supported algs %s %s",
		       __func__, encfound == 0 ? "encryption" : "",
		       authfound == 0 ? "authentication" : "");
	     return (-1);
     }
	
     return (0);
}

u_int32_t
kernel_reserve_spi(char *src, char *dst, int options)
{
     u_int32_t spi;
     int proto;

     LOG_DBG((LOG_KERNEL, 40, "%s: %s %s %s", __func__, src,
	      options & IPSEC_OPT_ENC ? "ESP" : "",
	      options & IPSEC_OPT_AUTH ? "AH" : ""));

     if ((options & (IPSEC_OPT_ENC|IPSEC_OPT_AUTH)) !=
	 (IPSEC_OPT_ENC|IPSEC_OPT_AUTH)) {
	  switch(options & (IPSEC_OPT_ENC|IPSEC_OPT_AUTH)) {
	  case IPSEC_OPT_ENC:
	       proto = IPPROTO_ESP;
	       break;
	  default:
	       proto = IPPROTO_AH;
	       break;
	  }
	  return kernel_reserve_single_spi(src, dst, 0, proto);
     }

     if (!(spi = kernel_reserve_single_spi(src, dst, 0, IPPROTO_ESP)))
	  return spi;

     /* Try to get the same spi for ah and esp */
     while (!kernel_reserve_single_spi(src, dst, spi, IPPROTO_AH)) {
	  kernel_delete_spi(src, spi, IPPROTO_ESP);
	  if (!(spi = kernel_reserve_single_spi(src, dst, 0, IPPROTO_ESP)))
	       return spi;
     }

     return spi;
}

u_int32_t
kernel_reserve_single_spi(char *srcaddress, char *dstaddress, u_int32_t spi,
			  int proto)
{
     struct sadb_msg smsg, *sres;
     struct sadb_address sad1, sad2; /* src and dst */
     struct sadb_spirange sspi;
     struct sadb_sa *ssa;
     union sockaddr_union src, dst;
     struct iovec iov[6];
     int cnt = 0;

     bzero(&src, sizeof(union sockaddr_union));
     bzero(&dst, sizeof(union sockaddr_union));
     bzero(iov, sizeof(iov));

     bzero(&smsg, sizeof(smsg));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&sspi, sizeof(sspi));

     smsg.sadb_msg_len = sizeof(smsg) / 8;
     smsg.sadb_msg_version = PF_KEY_V2;
     smsg.sadb_msg_seq = pfkey_seq++;
     smsg.sadb_msg_pid = pfkey_pid;
     smsg.sadb_msg_type = SADB_GETSPI;
     smsg.sadb_msg_satype = proto == IPPROTO_AH ?
	  SADB_SATYPE_AH : SADB_SATYPE_ESP;
     iov[cnt].iov_base = &smsg;
     iov[cnt++].iov_len = sizeof(smsg);

     /* Source Address */
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
     sad1.sadb_address_len = (sizeof(sad1) + sizeof(struct sockaddr_in)) / 8;
     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);

     src.sin.sin_family = AF_INET;
     src.sin.sin_len = sizeof(struct sockaddr_in);
     src.sin.sin_addr.s_addr = inet_addr(dstaddress);

     iov[cnt].iov_base = &src;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);
     smsg.sadb_msg_len += sad1.sadb_address_len;

     /* Destination Address */
     sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
     sad2.sadb_address_len = (sizeof(sad2) + sizeof(struct sockaddr_in)) / 8;

     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);

     dst.sin.sin_family = AF_INET;
     dst.sin.sin_len = sizeof(struct sockaddr_in);
     dst.sin.sin_addr.s_addr = inet_addr(srcaddress);

     iov[cnt].iov_base = &dst;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);
     smsg.sadb_msg_len += sad2.sadb_address_len;

     sspi.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
     sspi.sadb_spirange_len = sizeof(sspi) / 8;
     if (spi) {
	  sspi.sadb_spirange_min = spi;
	  sspi.sadb_spirange_max = spi;
     } else {
	  sspi.sadb_spirange_min = 0x100;
	  sspi.sadb_spirange_max = -1;
     }
     iov[cnt].iov_base = &sspi;
     iov[cnt++].iov_len = sizeof(sspi);
     smsg.sadb_msg_len += sspi.sadb_spirange_len;

     /* get back SADB_EXT_SA */

     if (!KERNEL_XF_SET(smsg.sadb_msg_len*8)) {
	  log_error("%s: kernel_xf_set()", __func__);
	  return (0);
     }

     sres = (struct sadb_msg *)buffer;
     ssa = (struct sadb_sa *)(sres + 1);
     if (ssa->sadb_sa_exttype != SADB_EXT_SA) {
	  log_print(
	  	"%s: SADB_GETSPI did not return a SADB_EXT_SA struct: %d",
		__func__, ssa->sadb_sa_exttype);
	  return (0);
     }

     LOG_DBG((LOG_KERNEL, 40, "%s: %s, %08x -> %08x", __func__,
	      srcaddress, spi, ntohl(ssa->sadb_sa_spi)));

     return (ntohl(ssa->sadb_sa_spi));
}

int
kernel_add_lifetime(struct sadb_msg *sa, struct iovec *iov, int seconds)
{
	static struct sadb_lifetime slh, sls;
	int cnt = 0;

	bzero(&slh, sizeof(slh));
	bzero(&sls, sizeof(sls));

	slh.sadb_lifetime_len = sizeof(slh) / 8;
	slh.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
	slh.sadb_lifetime_allocations = 0;
	slh.sadb_lifetime_bytes = 10000000;   /* lots of bytes */
	slh.sadb_lifetime_addtime = seconds;
	sa->sadb_msg_len += slh.sadb_lifetime_len;

	iov[cnt].iov_base = &slh;
	iov[cnt++].iov_len = sizeof(slh);

	sls.sadb_lifetime_len = sizeof(sls) / 8;
	sls.sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
	sls.sadb_lifetime_allocations = 0;
	sls.sadb_lifetime_bytes = 9000000;   /* lots of bytes */
	sls.sadb_lifetime_addtime = seconds * 9 / 10;
	sa->sadb_msg_len += slh.sadb_lifetime_len;

	iov[cnt].iov_base = &sls;
	iov[cnt++].iov_len = sizeof(sls);

	return (cnt);
}

int
kernel_ah(attrib_t *ob, struct spiob *SPI, u_int8_t *secrets, int hmac)
{
     struct sadb_msg sa;
     struct sadb_address sad1;
     struct sadb_address sad2;
     struct sadb_sa sr;
     struct sadb_key sk;
     struct sockaddr_in src;
     struct sockaddr_in dst;
     struct iovec iov[20];
     int cnt = 0;
     transform *xf = kernel_get_transform(ob->id);
     time_t now = time(NULL);

     if (xf == NULL || !(xf->flags & XF_AUTH)) {
	  log_print("%s: %d is not an auth transform", __func__, ob->id);
	  return (-1);
     }

     bzero(&sa, sizeof(sa));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&sr, sizeof(sr));
     bzero(&sk, sizeof(sk));
     bzero(&src, sizeof(src));
     bzero(&dst, sizeof(dst));

     sa.sadb_msg_len = sizeof(sa) / 8;
     sa.sadb_msg_version = PF_KEY_V2;
     sa.sadb_msg_type = SPI->flags & SPI_OWNER ?
	  SADB_UPDATE : SADB_ADD;
     sa.sadb_msg_satype = SADB_SATYPE_AH;
     sa.sadb_msg_seq = pfkey_seq++;
     sa.sadb_msg_pid = pfkey_pid;
     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);

     /* Source Address */
     sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
     src.sin_family = AF_INET;
     src.sin_len = sizeof(struct sockaddr_in);
     src.sin_addr.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
				     SPI->address : SPI->local_address);
     sa.sadb_msg_len += sad1.sadb_address_len;

     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     iov[cnt].iov_base = &src;
     iov[cnt++].iov_len = sizeof(struct sockaddr);

     /* Destination Address */
     sad2.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
     sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
     dst.sin_family = AF_INET;
     dst.sin_len = sizeof(struct sockaddr_in);
     dst.sin_addr.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
				     SPI->local_address : SPI->address);
     sa.sadb_msg_len += sad2.sadb_address_len;

     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     iov[cnt].iov_base = &dst;
     iov[cnt++].iov_len = sizeof(struct sockaddr);

     sr.sadb_sa_len = sizeof(sr) / 8;
     sr.sadb_sa_exttype = SADB_EXT_SA;
     sr.sadb_sa_spi = htonl(SPITOINT(SPI->SPI));
     sr.sadb_sa_replay = !hmac ? 0 : 32;
     sr.sadb_sa_state = SADB_SASTATE_MATURE;
     sr.sadb_sa_auth = xf->kernel_id;
     sr.sadb_sa_encrypt = 0;
     if (!hmac)
	  sr.sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
     sa.sadb_msg_len += sr.sadb_sa_len;

     iov[cnt].iov_base = &sr;
     iov[cnt++].iov_len = sizeof(sr);

     cnt += kernel_add_lifetime(&sa, &iov[cnt], SPI->lifetime - now);

     sk.sadb_key_len = (sizeof(sk) + ob->klen + 7) / 8;
     sk.sadb_key_exttype = SADB_EXT_KEY_AUTH;
     sk.sadb_key_bits = ob->klen * 8;
     sa.sadb_msg_len += sk.sadb_key_len;

     iov[cnt].iov_base = &sk;
     iov[cnt++].iov_len = sizeof(sk);
     iov[cnt].iov_base = secrets;
     iov[cnt++].iov_len = ((ob->klen + 7) / 8) * 8;

     LOG_DBG((LOG_KERNEL, 35, "%s: %08x", __func__, ntohl(sr.sadb_sa_spi)));

     if (!KERNEL_XF_SET(sa.sadb_msg_len * 8)) {
	  log_error("%s: kernel_xf_set()", __func__);
	  return (-1);
     }
     return (ob->klen);
}

int
kernel_esp(attrib_t *ob, attrib_t *ob2, struct spiob *SPI, u_int8_t *secrets)
{
     struct sadb_msg sa;
     struct sadb_address sad1;
     struct sadb_address sad2;
     struct sadb_sa sr;
     struct sadb_key sk1;
     struct sadb_key sk2;
     struct sockaddr_in src;
     struct sockaddr_in dst;
     struct iovec iov[20];
     attrib_t *attenc, *attauth = NULL;
     u_int8_t *sec1, *sec2 = NULL;
     transform *xf_enc, *xf_auth = NULL;
     int cnt = 0;
     time_t now = time(NULL);

     if (ob->type & AT_AUTH) {
	  if (ob2 == NULL || ob2->type != AT_ENC) {
	       log_print("%s: No encryption after auth given", __func__);
	       return (-1);
	  }
	  attenc = ob2;
	  attauth = ob;
	  sec2 = secrets;
	  sec1 = secrets + ob->klen;
     } else if (ob->type == AT_ENC) {
	  attenc = ob;
	  sec1 = secrets;
	  if (ob2 != NULL && (ob2->type & AT_AUTH)) {
	       attauth = ob2;
	       sec2 = secrets + ob->klen;
	  }
     } else {
	  log_print("%s: No encryption transform given", __func__);
	  return (-1);
     }

     xf_enc = kernel_get_transform(attenc->id);
     if ((xf_enc->flags & ESP_OLD) && attauth != NULL) {
	  log_print("%s: Old ESP does not support AH", __func__);
	  return (-1);
     }

     if (attauth != NULL)
	  xf_auth = kernel_get_transform(attauth->id);

     bzero(&sa, sizeof(sa));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&sr, sizeof(sr));
     bzero(&sk1, sizeof(sk1));
     bzero(&sk2, sizeof(sk2));
     bzero(&src, sizeof(src));
     bzero(&dst, sizeof(dst));

     sa.sadb_msg_len = sizeof(sa) / 8;
     sa.sadb_msg_version = PF_KEY_V2;
     sa.sadb_msg_type = SPI->flags & SPI_OWNER ?
	  SADB_UPDATE : SADB_ADD;
     sa.sadb_msg_satype = SADB_SATYPE_ESP;
     sa.sadb_msg_seq = pfkey_seq++;
     sa.sadb_msg_pid = pfkey_pid;
     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);

     sr.sadb_sa_len = sizeof(sr) / 8;
     sr.sadb_sa_exttype = SADB_EXT_SA;
     sr.sadb_sa_spi = htonl(SPITOINT(SPI->SPI));
     sr.sadb_sa_replay = xf_enc->flags & ESP_OLD ? 0 : 32;
     sr.sadb_sa_state = SADB_SASTATE_MATURE;
     sr.sadb_sa_auth = attauth ? xf_auth->kernel_id : 0;
     sr.sadb_sa_encrypt = xf_enc->kernel_id;
     if (xf_enc->flags & ESP_OLD) {
	  sr.sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;
	  sr.sadb_sa_flags |= SADB_X_SAFLAGS_RANDOMPADDING;
	  sr.sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
     }
     sa.sadb_msg_len += sr.sadb_sa_len;

     iov[cnt].iov_base = &sr;
     iov[cnt++].iov_len = sizeof(sr);

     /* Source Address */
     sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
     src.sin_family = AF_INET;
     src.sin_len = sizeof(struct sockaddr_in);
     src.sin_addr.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
				     SPI->address : SPI->local_address);
     sa.sadb_msg_len += sad1.sadb_address_len;

     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     iov[cnt].iov_base = &src;
     iov[cnt++].iov_len = sizeof(struct sockaddr);

     /* Destination Address */
     sad2.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
     sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
     dst.sin_family = AF_INET;
     dst.sin_len = sizeof(struct sockaddr_in);
     dst.sin_addr.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
				     SPI->local_address : SPI->address);
     sa.sadb_msg_len += sad2.sadb_address_len;

     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     iov[cnt].iov_base = &dst;
     iov[cnt++].iov_len = sizeof(struct sockaddr);

     cnt += kernel_add_lifetime(&sa, &iov[cnt], SPI->lifetime - now);

     sk1.sadb_key_len = (sizeof(sk1) + attenc->klen + 7) / 8;
     sk1.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
     sk1.sadb_key_bits = attenc->klen * 8;
     sa.sadb_msg_len += sk1.sadb_key_len;

     iov[cnt].iov_base = &sk1;
     iov[cnt++].iov_len = sizeof(sk1);
     iov[cnt].iov_base = sec1;
     iov[cnt++].iov_len = ((attenc->klen + 7) / 8) * 8;

     if (attauth != NULL) {
	  sk2.sadb_key_len = (sizeof(sk2) + attauth->klen + 7) / 8;
	  sk2.sadb_key_exttype = SADB_EXT_KEY_AUTH;
	  sk2.sadb_key_bits = attauth->klen * 8;
	  sa.sadb_msg_len += sk2.sadb_key_len;

	  iov[cnt].iov_base = &sk2;
	  iov[cnt++].iov_len = sizeof(sk2);
	  iov[cnt].iov_base = sec2;
	  iov[cnt++].iov_len = ((attauth->klen + 7) / 8) * 8;
     }

     LOG_DBG((LOG_KERNEL, 35, "%s: %08x", __func__, ntohl(sr.sadb_sa_spi)));

     if (!KERNEL_XF_SET(sa.sadb_msg_len * 8)) {
	  log_error("%s: kernel_xf_set()", __func__);
	  return (-1);
     }

     return attenc->klen + (attauth ? attauth->klen : 0);
}

/*
 * Remove a single SPI from the kernel database.
 */

int
kernel_delete_spi(char *address, u_int32_t spi, int proto)
{
     struct sadb_msg sa;
     struct sadb_sa sr;
     struct sadb_address sad1;
     struct sadb_address sad2;
     union sockaddr_union src, dst;
     struct iovec iov[10];
     int cnt = 0;

     bzero(&sa, sizeof(sa));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&sr, sizeof(sr));
     bzero(&src, sizeof(src));
     bzero(&dst, sizeof(dst));

     sa.sadb_msg_version = PF_KEY_V2;
     sa.sadb_msg_type = SADB_DELETE;
     sa.sadb_msg_satype = proto == IPPROTO_ESP ?
	  SADB_SATYPE_ESP : SADB_SATYPE_AH;
     sa.sadb_msg_seq = pfkey_seq++;
     sa.sadb_msg_pid = pfkey_pid;

     /* Source Address */
     sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;

     src.sin.sin_family = AF_INET;
     src.sin.sin_len = sizeof(struct sockaddr_in);

     /* Destination Address */
     sad2.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
     sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;

     dst.sin.sin_family = AF_INET;
     dst.sin.sin_len = sizeof(struct sockaddr_in);
     dst.sin.sin_addr.s_addr = inet_addr(address);

     sr.sadb_sa_exttype = SADB_EXT_SA;
     sr.sadb_sa_spi = htonl(spi);
     sr.sadb_sa_len = sizeof(sr) / 8;

     sa.sadb_msg_len = 2 + sr.sadb_sa_len + sad2.sadb_address_len +
	  sad1.sadb_address_len;

     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);
     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     iov[cnt].iov_base = &src;
     iov[cnt++].iov_len = sizeof(struct sockaddr);
     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     iov[cnt].iov_base = &dst;
     iov[cnt++].iov_len = sizeof(struct sockaddr);
     iov[cnt].iov_base = &sr;
     iov[cnt++].iov_len = sizeof(sr);


     LOG_DBG((LOG_KERNEL, 30, "%s: %08x", __func__, spi));

     if (!KERNEL_XF_SET(sa.sadb_msg_len * 8) && errno != ESRCH) {
	  log_error("%s: kernel_xf_set()", __func__);
	  return (-1);
     }

     return (1);
}

/*
 * Creates the correspondings SPI's with the kernel and establishes
 * routing if necessary, i.e. when the SPIs were not created by
 * kernel notifies.
 */

int
kernel_insert_spi(struct stateob *st, struct spiob *SPI)
{
     u_int8_t *spi;
     u_int8_t *attributes;
     u_int16_t attribsize, ahsize, espsize;
     u_int8_t *secrets, *ah, *esp;
     attrib_t *attprop;
     int offset, proto = 0;

     spi = SPI->SPI;
     attributes = SPI->attributes;
     attribsize = SPI->attribsize;
     secrets = SPI->sessionkey;

     get_attrib_section(attributes, attribsize, &esp, &espsize,
			AT_ESP_ATTRIB);
     get_attrib_section(attributes, attribsize, &ah, &ahsize,
			AT_AH_ATTRIB);

     if (esp != NULL) {
	  int count = 0;
	  attrib_t *atesp = NULL, *atah = NULL;

	  while (count < espsize && (atesp == NULL || atah == NULL)) {
	       if ((attprop = getattrib(esp[count])) == NULL) {
		    log_print("%s: Unknown attribute %d for ESP",
		    	__func__, esp[count]);
		    return (-1);
	       }
	       if (atesp == NULL && attprop->type == AT_ENC)
		    atesp = attprop;
	       else if(atah == NULL && (attprop->type & AT_AUTH))
		    atah = attprop;

	       count += esp[count+1]+2;
	  }
	  if (atesp == NULL) {
	       log_print("%s: No encryption attribute in ESP section for SA(%08x, %s->%s)",
		    __func__, 
		    SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
	       return (-1);
	  }

	  offset = kernel_esp(atesp, atah, SPI, secrets);
	  if (offset == -1)
	       return (-1);
	  secrets += offset;
     }

     if (ah != NULL) {
	  int count = 0, hmac = 0;
	  attrib_t *atah = NULL;

	  while (count < ahsize) {
	       if ((attprop = getattrib(ah[count])) == NULL) {
		    log_print("%s: Unknown attribute %d for AH", __func__,
			      ah[count]);
		    return (-1);
	       }
	       if(atah == NULL && (attprop->type & AT_AUTH))
		    atah = attprop;
	       else if (attprop->type == 0) {
		    switch (attprop->id) {
		    case AT_HMAC:
			 hmac = 1;
			 break;
		    default:
			 break;
		    }
	       }

	       count += ah[count+1]+2;
	  }

	  if (atah == NULL) {
	       log_print("%s: No authentication attribute in AH section for SA(%08x, %s->%s)",
		    __func__,
			 SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
	       return (-1);
	  }

	  offset = kernel_ah(atah, SPI, secrets, hmac);
	  if (offset == -1)
	       return (-1);
	  secrets += offset;
     }

     if (esp != NULL) {
	  proto = IPPROTO_ESP;
	  SPI->flags |= SPI_ESP;
     } else {
	  proto = IPPROTO_AH;
	  SPI->flags &= ~SPI_ESP;
     }

    /*
     * Inform the kernel that we obtained the requested SA
     */
     kernel_notify_result(st, SPI, proto);

     /* Erase keys */
     bzero(SPI->sessionkey, SPI->sessionkeysize);
     free(SPI->sessionkey);
     SPI->sessionkey = NULL; SPI->sessionkeysize = 0;

     return (1);
}

/*
 * Deletes an SPI object, which means removing the SPIs from the
 * kernel database and the deletion of all routes which were
 * established on our behalf. Routes for SA's which were created by
 * kernel notifies also get removed, since they are not any longer
 * valid anyway.
 */

int
kernel_unlink_spi(struct spiob *ospi)
{
     u_int8_t *p, *ah, *esp;
     u_int16_t ahsize, espsize;

     if (!(ospi->flags & SPI_OWNER))
	  p = ospi->address;
     else
	  p = ospi->local_address;

     get_attrib_section(ospi->attributes, ospi->attribsize, &esp, &espsize,
			AT_ESP_ATTRIB);
     get_attrib_section(ospi->attributes, ospi->attribsize, &ah, &ahsize,
			AT_AH_ATTRIB);

     if (esp != NULL) {
	  if (kernel_delete_spi(p, SPITOINT(ospi->SPI), IPPROTO_ESP) == -1)
	       log_print("%s: kernel_delete_spi() failed", __func__);
     }
	
     if (ah != NULL) {
	  if (kernel_delete_spi(p, SPITOINT(ospi->SPI), IPPROTO_AH) == -1)
	       log_print("%s: kernel_delete_spi() failed", __func__);
     }

     return (1);
}

void
kernel_dispatch_notify(struct sadb_msg *sres)
{
	LOG_DBG((LOG_KERNEL, 60, "%s: Got PFKEYV2 message: type %d",
		__func__, sres->sadb_msg_type));

	switch (sres->sadb_msg_type) {
	case SADB_EXPIRE:
		LOG_DBG((LOG_KERNEL, 55, "%s: Got SA Expiration", __func__));
		kernel_handle_expire(sres);
		break;
	case SADB_ACQUIRE:
		LOG_DBG((LOG_KERNEL, 55, 
			 "%s: Got Notify SA Request (SADB_ACQUIRE): %d",
			 __func__, 
			 sres->sadb_msg_len * 8));
		LOG_DBG_BUF((LOG_KERNEL, 60, "acquire buf",
			     (u_char *)sres, sres->sadb_msg_len * 8));
	
		
		kernel_request_sa(sres);
		break;
	default:
		/* discard silently */
		return;
	}
}

void
kernel_handle_queue()
{
	struct pfmsg *pfmsg;

	while ((pfmsg = TAILQ_FIRST(&pfqueue))) {
		TAILQ_REMOVE(&pfqueue, pfmsg, next);

		kernel_dispatch_notify(pfmsg->smsg);

		free(pfmsg->smsg);
		free(pfmsg);
	}
}

/*
 * Handles Notifies from the kernel, which can include Requests for new
 * SAs, soft and hard expirations for already established SAs.
 */

void
kernel_handle_notify(int sd)
{
	struct sadb_msg *sres = (struct sadb_msg *)buffer;
	size_t len;

	if (!kernel_xf_read(regsd, buffer, BUFFER_SIZE, 0)) {
		LOG_DBG((LOG_KERNEL, 65, "%s: nothing to read", __func__));
		return;
	}

	len = sres->sadb_msg_len * 8;
	sres = malloc(len);
	if (!sres) {
		log_error("%s: malloc", __func__);
		return;
	}
	memcpy(sres, buffer, len);

	kernel_dispatch_notify(sres);

	free(sres);
}

struct sadb_msg *
pfkey_askpolicy(int seq)
{
	struct sadb_msg smsg;
	struct sadb_x_policy policy;
	struct iovec iov[2];
	int cnt = 0;

	bzero(&smsg, sizeof(smsg));

	/* Ask the kernel for the matching policy */
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = pfkey_seq++;
	smsg.sadb_msg_pid = pfkey_pid;
	smsg.sadb_msg_type = SADB_X_ASKPOLICY;
	iov[cnt].iov_base = &smsg;
	iov[cnt++].iov_len = sizeof(smsg);

	memset(&policy, 0, sizeof(policy));
	policy.sadb_x_policy_exttype = SADB_X_EXT_POLICY;
	policy.sadb_x_policy_len = sizeof(policy) / 8;
	policy.sadb_x_policy_seq = seq;
	iov[cnt].iov_base = &policy;
	iov[cnt++].iov_len = sizeof(policy);
	smsg.sadb_msg_len += sizeof(policy) / 8;

	if (!kernel_xf_set(regsd, buffer, BUFFER_SIZE, iov, cnt,
			   smsg.sadb_msg_len*8)) {
		log_error("%s: kernel_xf_set", __func__);
		return (NULL);
	}

	return ((struct sadb_msg *)buffer);
}

int
kernel_handle_expire(struct sadb_msg *sadb)
{
	struct sadb_sa *sa;
	struct sadb_address *dst;
	char dstbuf[NI_MAXHOST];
	struct stateob *st;
	time_t tm;
	struct sockaddr *dstaddr;
	struct sadb_lifetime *life;
	struct sadb_ext *ext = (struct sadb_ext *)(sadb + 1);
	struct spiob *spi;
	void *end;

	end = (struct sadb_ext *)((u_char *)sadb + sadb->sadb_msg_len * 8);

	sa = (struct sadb_sa *)pfkey_find_extension(ext, end, SADB_EXT_SA);
	if (sa == NULL) {
		log_print("%s: no SA extension found", __func__);
		return (-1);
	}

	dst = (struct sadb_address *)
		pfkey_find_extension(ext, end, SADB_EXT_ADDRESS_DST);
	if (dst == NULL) {
		log_print(
			  "%s: no destination address extension found",
			  __func__);
		return (-1);
	}
	dstaddr = (struct sockaddr *)(dst + 1);

	life = (struct sadb_lifetime *)
		pfkey_find_extension(ext, end, SADB_EXT_LIFETIME_HARD);
	if (life == NULL)
		life = (struct sadb_lifetime *)
			pfkey_find_extension(ext, end, SADB_EXT_LIFETIME_SOFT);
	if (life == NULL) {
		log_print(
			  "%s: no lifetime extension found",
			  __func__);
		return (-1);
	}

	switch (dstaddr->sa_family) {
	case AF_INET:
		if (inet_ntop (AF_INET, &((struct sockaddr_in *)dstaddr)->sin_addr,
			       dstbuf, sizeof(dstbuf)) == NULL) {
			log_error ("%s: inet_ntop failed", __func__);
			return (-1);
		}
		break;
	default:
		log_error(
			  "%s: unsupported address family %d",
			  __func__,
			  dstaddr->sa_family);
		return (-1);
	}

	LOG_DBG((LOG_KERNEL, 30, "%s: %s dst %s SPI %x sproto %d", __func__,
	    life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ? "SOFT"
	    : "HARD", dstbuf,
	    ntohl (sa->sadb_sa_spi), sadb->sadb_msg_satype));

	spi = spi_find(dstbuf, (u_char *)&sa->sadb_sa_spi);
	if (spi == NULL) {
		LOG_DBG((LOG_KERNEL, 35, 
			 "%s: can't find %s SPI %x", __func__,
			 dstbuf, ntohl(sa->sadb_sa_spi)));
		return (-1);
	}

	switch(life->sadb_lifetime_exttype) {
	case SADB_EXT_LIFETIME_HARD:
		LOG_DBG((LOG_KERNEL, 35, "%s: removing %s SPI %x", __func__,
				 dstbuf, ntohl(sa->sadb_sa_spi)));
		spi_unlink(spi);
		break;
	case SADB_EXT_LIFETIME_SOFT:
		life = (struct sadb_lifetime *)
			pfkey_find_extension(ext, end,
					     SADB_EXT_LIFETIME_CURRENT);
		if (life == NULL) {
			log_print("%s: no current lifetime", __func__);
			return (-1);
		}

		if (!life->sadb_lifetime_bytes) {
			LOG_DBG((LOG_KERNEL, 45, 
				 "%s: SPI %x not been used, skipping update",
				 __func__,
				 ntohl(sa->sadb_sa_spi)));
			return (0);
		}

		if (spi->flags & SPI_OWNER) {
			spi_update(global_socket,
				   (u_int8_t *)&sa->sadb_sa_spi);
			return (0);
		}

		/*
		 * Try to find an already established exchange which is
		 * still valid.
		 */

		st = state_find(dstbuf);

		tm = time(NULL);
		while (st != NULL &&
		       (st->lifetime <= tm || st->phase < SPI_UPDATE))
			st = state_find_next(st, dstbuf);

		if (st == NULL) {
			int type = spi->flags & SPI_ESP ?
				IPSEC_OPT_ENC : IPSEC_OPT_AUTH;

			LOG_DBG((LOG_KERNEL, 45, 
				 "%s: starting new exchange to %s",
				 __func__,
				 spi->address));
			kernel_new_exchange(spi->address, type);
		}

		break;
	default:
		log_print("%s: unknown extension type %d", __func__,
			  life->sadb_lifetime_exttype);
		return (-1);
	}

	return (0);
}

int
kernel_new_exchange(char *address, int type)
{
	struct stateob *st;

	/* No established exchange found, start a new one */
	if ((st = state_new()) == NULL) {
		log_print(
			  "%s: state_new() failed for remote ip %s", __func__,
			  address);
		return (-1);
	}

	/* Set up the state information */
	strncpy(st->address, address, sizeof(st->address) - 1);
	st->port = global_port;
	st->sport = 0;
	st->dport = 0;
	st->protocol = 0;

	st->flags = IPSEC_NOTIFY;

	st->flags |= type;

	if (start_exchange(global_socket, st, st->address,
			   st->port) == -1) {
		log_print("%s: start_exchange() - informing kernel of failure",
		    __func__);
		/* Inform kernel of our failure */
		kernel_notify_result(st, NULL, 0);
		state_value_reset(st);
		free(st);
		return (-1);
	} else
		state_insert(st);

	return (0);
}

/*
 * Tries to establish a new SA according to the information in a
 * REQUEST_SA notify message received from the kernel.
 */

int
kernel_request_sa(struct sadb_msg *sadb)
{
	struct stateob *st;
	time_t tm;
	struct sadb_address *dst, *src;
	struct sockaddr *dstaddr;
	struct sadb_ext *ext = (struct sadb_ext *)(sadb + 1);
	char srcbuf[NI_MAXHOST], dstbuf[NI_MAXHOST];
	void *end;

	memset(srcbuf, 0, sizeof(srcbuf));
	memset(dstbuf, 0, sizeof(dstbuf));

	end = (struct sadb_ext *)((u_char *)sadb + sadb->sadb_msg_len * 8);

	dst = (struct sadb_address *)
		pfkey_find_extension(ext, end, SADB_EXT_ADDRESS_DST);
	src = (struct sadb_address *)
		pfkey_find_extension(ext, end, SADB_EXT_ADDRESS_SRC);

	if (!dst)
		return (-1);

	dstaddr = (struct sockaddr *)(dst + 1);
	switch (dstaddr->sa_family) {
	case AF_INET:
		if (inet_ntop(AF_INET,
			      &((struct sockaddr_in *)dstaddr)->sin_addr,
			      dstbuf, sizeof(dstbuf)) == NULL) {
			log_error ("%s: inet_ntop failed", __func__);
			return (-1);
		}
		break;
	default:
		log_error("%s: unsupported address family %d", __func__,
			  dstaddr->sa_family);
		return (-1);
	}
	
	LOG_DBG((LOG_KERNEL, 20, "%s: dst: %s", __func__, dstbuf));

	/* Try to find an already established exchange which is still valid */
	st = state_find(dstbuf);

	tm = time(NULL);
	while (st != NULL && (st->lifetime <= tm || st->phase < SPI_UPDATE))
		st = state_find_next(st, dstbuf);

	if (st) {
		struct sockaddr_in sin;

		/*
		 * We need different attributes for this exchange, send
		 * an SPI_NEEDED message.
		 */

		packet_size = PACKET_BUFFER_SIZE;
		if (photuris_spi_needed(st, packet_buffer, &packet_size,
					st->uSPIattrib,
					st->uSPIattribsize) == -1) {
			log_print("%s: photuris_spi_update()", __func__);
			return (-1);
		}

		/* Send the packet */
		sin.sin_port = htons(st->port);
		sin.sin_family = AF_INET;
		sin.sin_addr.s_addr = inet_addr(st->address);
		
		if (sendto(global_socket, packet_buffer, packet_size, 0,
			   (struct sockaddr *)&sin, sizeof(sin)) != packet_size) {
			log_error("%s: sendto()", __func__);
		}
	} else {
		int type = sadb->sadb_msg_satype == SADB_SATYPE_ESP ?
			IPSEC_OPT_ENC : IPSEC_OPT_AUTH;

		return (kernel_new_exchange(dstbuf, type));
	}


	return (0);
}

/*
 * Report the established SA or either our failure to create an SA
 * to the kernel.
 * Passing a SPI of NULL means failure.
 */

void
kernel_notify_result(struct stateob *st, struct spiob *spi, int proto)
{

     /*     struct encap_msghdr em;

     bzero((char *)&em, sizeof(em));
     em.em_type = EMT_NOTIFY;
     em.em_msglen = EMT_NOTIFY_FLEN;
     em.em_version = PFENCAP_VERSION_1;
     em.em_not_type = NOTIFY_REQUEST_SA;
     if (spi != NULL) {
	  em.em_not_spi = htonl((spi->SPI[0]<<24) + (spi->SPI[1]<<16) +
				(spi->SPI[2]<<8) + spi->SPI[3]);
	  em.em_not_dst.s_addr = inet_addr(spi->address);
	  em.em_not_src.s_addr = inet_addr(spi->local_address);
	  em.em_not_sproto = proto;
     }
     if (st != NULL) {
	  em.em_not_dst.s_addr = inet_addr(st->address);
	  em.em_not_sport = st->sport;
	  em.em_not_dport = st->dport;
	  em.em_not_protocol = st->protocol;
     }

     if (!kernel_xf_set(&em))
     log_error("kernel_xf_set() in kernel_notify_result()"); */
}
@


1.27
log
@Fix structure allocation. The code incorrectly used sizeof(pointer) instead
of sizeof(*pointer). provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kernel.c,v 1.26 2002/06/10 19:58:20 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.26 2002/06/10 19:58:20 espie Exp $";
@


1.26
log
@kill __FUNCTION__
add __attribute__((format...)
Fix one bad call.

okay provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kernel.c,v 1.25 2002/06/09 08:13:08 todd Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.25 2002/06/09 08:13:08 todd Exp $";
d316 1
a316 1
	pfmsg = malloc(sizeof(pfmsg));
@


1.25
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: kernel.c,v 1.24 2001/07/07 18:26:18 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.24 2001/07/07 18:26:18 deraadt Exp $";
d135 2
a136 2
			LOG_DBG((LOG_KERNEL, 50, __FUNCTION__
				 ": %s algorithm %d",
d233 1
a233 1
		log_fatal(__FUNCTION__": socket(PF_KEY) for IPsec key engine");
d235 1
a235 1
		log_fatal(__FUNCTION__": socket() for PFKEY register");
d241 1
a241 1
		log_fatal(__FUNCTION__": PFKEY socket registration failed");
d313 2
a314 2
	LOG_DBG((LOG_KERNEL, 50, __FUNCTION__": queuing message type %d",
		 smsg->sadb_msg_type));
d318 1
a318 1
		log_error(__FUNCTION__": malloc");
d324 1
a324 1
		log_error(__FUNCTION__": malloc");
d353 1
a353 1
			log_error(__FUNCTION__": poll");
d358 1
a358 1
			log_print(__FUNCTION__": no reply from pfkey");
d363 1
a363 1
			log_error(__FUNCTION__": read()");
d368 2
a369 2
			log_print(__FUNCTION__
				  ": PFKEYV2 message len %d too big", len);
d373 1
a373 1
			log_error(__FUNCTION__": read()");
d388 3
a390 3
				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__
					 ": skipping message type %d",
					 sres->sadb_msg_type));
d398 2
a399 2
		LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",
			 strerror(sres->sadb_msg_errno)));
d418 1
a418 1
     LOG_DBG((LOG_KERNEL, 20, __FUNCTION__": fd %d", sd));
d436 1
a436 1
	  log_error(__FUNCTION__": kernel_xf_set()");
d461 1
a461 1
	  log_error(__FUNCTION__": kernel_xf_set()");
d482 2
a483 3
	     log_print(__FUNCTION__
		       ": SADB_REGISTER without supported algs %s %s",
		       encfound == 0 ? "encryption" : "",
d497 1
a497 1
     LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": %s %s %s", src,
d603 1
a603 1
	  log_error(__FUNCTION__": kernel_xf_set()");
d610 3
a612 3
	  log_print(__FUNCTION__
		    ": SADB_GETSPI did not return a SADB_EXT_SA struct: %d",
		    ssa->sadb_sa_exttype);
d616 1
a616 1
     LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": %s, %08x -> %08x",
d670 1
a670 1
	  log_print(__FUNCTION__": %d is not an auth transform", ob->id);
d746 1
a746 1
     LOG_DBG((LOG_KERNEL, 35, __FUNCTION__": %08x", ntohl(sr.sadb_sa_spi)));
d749 1
a749 1
	  log_error(__FUNCTION__": kernel_xf_set()");
d775 1
a775 1
	       log_print(__FUNCTION__": No encryption after auth given");
d790 1
a790 1
	  log_print(__FUNCTION__": No encryption transform given");
d796 1
a796 1
	  log_print(__FUNCTION__": Old ESP does not support AH");
d891 1
a891 1
     LOG_DBG((LOG_KERNEL, 35, __FUNCTION__": %08x", ntohl(sr.sadb_sa_spi)));
d894 1
a894 1
	  log_error(__FUNCTION__": kernel_xf_set()");
d966 1
a966 1
     LOG_DBG((LOG_KERNEL, 30, __FUNCTION__": %08x", spi));
d969 1
a969 1
	  log_error(__FUNCTION__": kernel_xf_set()");
d1008 2
a1009 2
		    log_print(__FUNCTION__": Unknown attribute %d for ESP",
			      esp[count]);
d1020 3
a1022 2
	       log_print(__FUNCTION__": No encryption attribute in ESP section for SA(%08x, %s->%s)",
			 SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
d1038 1
a1038 1
		    log_print(__FUNCTION__": Unknown attribute %d for AH",
d1058 2
a1059 1
	       log_print(__FUNCTION__": No authentication attribute in AH section for SA(%08x, %s->%s)",
d1117 1
a1117 1
	       log_print(__FUNCTION__": kernel_delete_spi() failed");
d1122 1
a1122 1
	       log_print(__FUNCTION__": kernel_delete_spi() failed");
d1131 2
a1132 2
	LOG_DBG((LOG_KERNEL, 60, __FUNCTION__": Got PFKEYV2 message: type %d",
		 sres->sadb_msg_type));
d1136 1
a1136 1
		LOG_DBG((LOG_KERNEL, 55, __FUNCTION__": Got SA Expiration"));
d1140 3
a1142 2
		LOG_DBG((LOG_KERNEL, 55, __FUNCTION__
			 ": Got Notify SA Request (SADB_ACQUIRE): %d",
d1183 1
a1183 1
		LOG_DBG((LOG_KERNEL, 65, __FUNCTION__": nothing to read"));
d1190 1
a1190 1
		log_error(__FUNCTION__": malloc");
d1229 1
a1229 1
		log_error(__FUNCTION__": kernel_xf_set");
d1254 1
a1254 1
		log_print(__FUNCTION__": no SA extension found");
d1261 3
a1263 2
		log_print(__FUNCTION__
			  ": no destination address extension found");
d1274 3
a1276 2
		log_print(__FUNCTION__
			  ": no lifetime extension found");
d1284 1
a1284 1
			log_error (__FUNCTION__": inet_ntop failed");
d1289 3
a1291 2
		log_error(__FUNCTION__
			  ": unsupported address family %d",
d1296 1
a1296 1
	LOG_DBG((LOG_KERNEL, 30, __FUNCTION__": %s dst %s SPI %x sproto %d",
d1303 2
a1304 2
		LOG_DBG((LOG_KERNEL, 35, __FUNCTION__
			 ": can't find %s SPI %x",
d1311 1
a1311 1
		LOG_DBG((LOG_KERNEL, 35, __FUNCTION__": removing %s SPI %x",
d1320 1
a1320 1
			log_print(__FUNCTION__": no current lifetime");
d1325 3
a1327 2
			LOG_DBG((LOG_KERNEL, 45, __FUNCTION__
				 ": SPI %x not been used, skipping update",
d1354 3
a1356 2
			LOG_DBG((LOG_KERNEL, 45, __FUNCTION__
				 ": starting new exchange to %s",
d1363 1
a1363 1
		log_print(__FUNCTION__": unknown extension type %d",
d1378 3
a1380 2
		log_print(__FUNCTION__
			  ": state_new() failed for remote ip %s", address);
d1397 2
a1398 1
		log_print(__FUNCTION__": start_exchange() - informing kernel of failure");
d1445 1
a1445 1
			log_error (__FUNCTION__": inet_ntop failed");
d1450 1
a1450 2
		log_error(__FUNCTION__
			  ": unsupported address family %d",
d1455 1
a1455 1
	LOG_DBG((LOG_KERNEL, 20, __FUNCTION__": dst: %s", dstbuf));
d1476 1
a1476 1
			log_print(__FUNCTION__": photuris_spi_update()");
d1487 1
a1487 1
			log_error(__FUNCTION__": sendto()");
@


1.24
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: kernel.c,v 1.23 2001/06/27 03:31:46 angelos Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.23 2001/06/27 03:31:46 angelos Exp $";
d109 1
a109 1
 * Translate a Photuris ID into a data structure for the 
d118 1
a118 1
     for (i=sizeof(xf)/sizeof(transform)-1; i >= 0; i--) 
d133 1
a133 1
	for (i=sizeof(xf)/sizeof(transform)-1; i >= 0; i--) 
d188 1
a188 1
     if (xf_enc->flags & ESP_OLD) 
d225 1
a225 1
} 
d232 1
a232 1
	if ((sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) 
d234 1
a234 1
	if ((regsd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) 
d242 1
a242 1
     
d376 2
a377 2
	  
		forus = !(sres->sadb_msg_pid && 
d394 1
a394 1
	     
d396 1
a396 1
 
d488 1
a488 1
	  
d502 1
a502 1
     if ((options & (IPSEC_OPT_ENC|IPSEC_OPT_AUTH)) != 
d517 1
a517 1
     
d554 1
a554 1
     smsg.sadb_msg_satype = proto == IPPROTO_AH ? 
d600 1
a600 1
     
d685 1
a685 1
     sa.sadb_msg_type = SPI->flags & SPI_OWNER ? 
d698 1
a698 1
     src.sin_addr.s_addr = inet_addr(SPI->flags & SPI_OWNER ? 
d845 1
a845 1
     src.sin_addr.s_addr = inet_addr(SPI->flags & SPI_OWNER ? 
d898 1
a898 1
     
d909 4
a912 4
     struct sadb_msg sa; 
     struct sadb_sa sr; 
     struct sadb_address sad1; 
     struct sadb_address sad2; 
d914 12
a925 12
     struct iovec iov[10]; 
     int cnt = 0; 
 
     bzero(&sa, sizeof(sa)); 
     bzero(&sad1, sizeof(sad1)); 
     bzero(&sad2, sizeof(sad2)); 
     bzero(&sr, sizeof(sr)); 
     bzero(&src, sizeof(src)); 
     bzero(&dst, sizeof(dst)); 
   
     sa.sadb_msg_version = PF_KEY_V2; 
     sa.sadb_msg_type = SADB_DELETE; 
d927 4
a930 4
	  SADB_SATYPE_ESP : SADB_SATYPE_AH; 
     sa.sadb_msg_seq = pfkey_seq++; 
     sa.sadb_msg_pid = pfkey_pid; 
 
d932 5
a936 2
     sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8; 
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC; 
a937 3
     src.sin.sin_family = AF_INET; 
     src.sin.sin_len = sizeof(struct sockaddr_in); 
  
d939 6
a944 2
     sad2.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8; 
     sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST; 
d946 1
a946 5
     dst.sin.sin_family = AF_INET; 
     dst.sin.sin_len = sizeof(struct sockaddr_in); 
     dst.sin.sin_addr.s_addr = inet_addr(address); 
 
     sr.sadb_sa_exttype = SADB_EXT_SA; 
d948 13
a960 13
     sr.sadb_sa_len = sizeof(sr) / 8; 
 
     sa.sadb_msg_len = 2 + sr.sadb_sa_len + sad2.sadb_address_len + 
	  sad1.sadb_address_len; 
    
     iov[cnt].iov_base = &sa; 
     iov[cnt++].iov_len = sizeof(sa); 
     iov[cnt].iov_base = &sad1; 
     iov[cnt++].iov_len = sizeof(sad1); 
     iov[cnt].iov_base = &src; 
     iov[cnt++].iov_len = sizeof(struct sockaddr); 
     iov[cnt].iov_base = &sad2; 
     iov[cnt++].iov_len = sizeof(sad2); 
d962 4
a965 4
     iov[cnt++].iov_len = sizeof(struct sockaddr); 
     iov[cnt].iov_base = &sr; 
     iov[cnt++].iov_len = sizeof(sr); 
    
d1066 1
a1066 1
	  secrets += offset; 
d1077 1
a1077 1
    /* 
d1108 1
a1108 1
     
d1113 1
a1113 1
     
d1118 1
a1118 1
	  
d1144 1
a1144 1
	  
d1150 1
a1150 1
		return; 
d1286 1
a1286 1
			  ": unsupported address family %d", 
d1402 1
a1402 1
 * Tries to establish a new SA according to the information in a 
d1407 1
a1407 1
kernel_request_sa(struct sadb_msg *sadb) 
d1442 1
a1442 1
			  ": unsupported address family %d", 
d1459 1
a1459 1
		/* 
d1464 1
a1464 1
		packet_size = PACKET_BUFFER_SIZE; 
d1473 2
a1474 2
		sin.sin_port = htons(st->port); 
		sin.sin_family = AF_INET; 
d1476 1
a1476 1
		    
d1510 1
a1510 1
	  em.em_not_spi = htonl((spi->SPI[0]<<24) + (spi->SPI[1]<<16) + 
d1515 1
a1515 1
     } 
@


1.23
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: kernel.c,v 1.22 2001/06/05 00:17:48 niklas Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.22 2001/06/05 00:17:48 niklas Exp $";
d1412 1
a1412 1
	struct sockaddr *dstaddr, *srcaddr;
@


1.22
log
@Make our pfkeyv2.h more RFC2367 compliant.  Also fix some backwards
compatibility problems in isakmpd, at least 2.8 stable can compile current
isakmpd now.  angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kernel.c,v 1.21 2001/01/28 22:45:11 niklas Exp $	*/
d36 1
a36 1
 * with the PF_ENCAP interface as used by OpenBSD's IPSec implementation.
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.21 2001/01/28 22:45:11 niklas Exp $";
d233 1
a233 1
		log_fatal(__FUNCTION__": socket(PF_KEY) for IPSec keyengine");
d265 1
a265 1
	  log_fatal("setsockopt: can not bypass ipsec authentication policy");
d268 1
a268 1
	  log_fatal("setsockopt: can not bypass ipsec esp transport policy");
d271 1
a271 1
	  log_fatal("setsockopt: can not bypass ipsec esp network policy");
@


1.21
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: kernel.c,v 1.20 2000/12/16 08:31:56 provos Exp $";
d1202 1
a1202 1
	struct sadb_policy policy;
d1218 3
a1220 3
	policy.sadb_policy_exttype = SADB_X_EXT_POLICY;
	policy.sadb_policy_len = sizeof(policy) / 8;
	policy.sadb_policy_seq = seq;
@


1.20
log
@when a used SA expires and the exchange is gone, start a new one.
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: kernel.c,v 1.19 2000/12/15 07:29:44 provos Exp $";
@


1.19
log
@return resource exhaustion message on memory allocation error. poll on
the pfkey fd so that we dont block when a message gets lossed.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.18 2000/12/15 02:42:08 provos Exp $";
d1157 1
a1157 1
	while (pfmsg = TAILQ_FIRST(&pfqueue)) {
d1238 2
d1294 8
a1303 7
		spi = spi_find(dstbuf, (u_char *)&sa->sadb_sa_spi);
		if (spi == NULL) {
			LOG_DBG((LOG_KERNEL, 35, __FUNCTION__
				 ": can't find %s SPI %x",
				 dstbuf, ntohl(sa->sadb_sa_spi)));
			return (-1);
		}
d1324 28
a1351 1
		spi_update(global_socket, (u_int8_t *)&sa->sadb_sa_spi);
d1362 37
d1425 10
a1434 14
	if (dst) {
		dstaddr = (struct sockaddr *)(dst + 1);
		switch (dstaddr->sa_family) {
		case AF_INET:
			if (inet_ntop (AF_INET, &((struct sockaddr_in *)dstaddr)->sin_addr,
				       dstbuf, sizeof(dstbuf)) == NULL) {
				log_error (__FUNCTION__": inet_ntop failed");
				return (-1);
			}
			break;
		default:
			log_error(__FUNCTION__
				  ": unsupported address family %d", 
				  dstaddr->sa_family);
d1437 5
a1441 3

		LOG_DBG((LOG_KERNEL, 20, __FUNCTION__": dst: %s", dstbuf));
	} else
d1443 3
d1454 1
a1454 31
	if (st == NULL) {
		/* No established exchange found, start a new one */
		if ((st = state_new()) == NULL) {
			log_print(__FUNCTION__
				  ": state_new() failed for remote ip %s",
				  dstbuf);
			return (-1);
		}
		/* Set up the state information */
		strncpy(st->address, dstbuf, sizeof(st->address) - 1);
		st->port = global_port;
		st->sport = 0;
		st->dport = 0;
		st->protocol = 0;

		st->flags = IPSEC_NOTIFY;

		st->flags |= sadb->sadb_msg_satype == SADB_SATYPE_ESP ?
			IPSEC_OPT_ENC : IPSEC_OPT_AUTH;

		if (start_exchange(global_socket, st, st->address,
				   st->port) == -1) {
			log_print(__FUNCTION__": start_exchange() - informing kernel of failure");
			/* Inform kernel of our failure */
			kernel_notify_result(st, NULL, 0);
			state_value_reset(st);
			free(st);
			return (-1);
		} else
			state_insert(st);
	} else {
d1479 5
d1485 1
@


1.18
log
@more cleanup; send SPI needed message if we have state but no SPI on
acquire.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.17 2000/12/15 01:58:27 provos Exp $";
d67 1
d88 2
d335 19
a353 2
     struct sadb_msg *sres = (struct sadb_msg *)buffer;
     int len, forus;
d355 19
a373 19
     /*
      * Read in response from the kernel. If seq number and/or PID are
      * given, we need to check PID and sequence number to see if it
      * really is a message for us.
      */
     do {
	  if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {
	       log_error(__FUNCTION__": read()");
	       return (0);
	  }
	  len = sres->sadb_msg_len * 8;
	  if (len >= BUFFER_SIZE) {
	       log_print(__FUNCTION__": PFKEYV2 message len %d too big", len);
	       return (0);
	  }
	  if (read(sd, sres, len) != len) {
	       log_error(__FUNCTION__": read()");
	       return (0);
	  }
d375 17
a391 16
	  forus = !(sres->sadb_msg_pid && sres->sadb_msg_pid != pfkey_pid) &&
		  !(seq && sres->sadb_msg_seq != seq);

	  if (!forus) {
		  switch (sres->sadb_msg_type) {
		  case SADB_ACQUIRE:
		  case SADB_EXPIRE:
			  kernel_queue_msg(sres);
			  break;
		  default:
			  LOG_DBG((LOG_KERNEL, 50, __FUNCTION__
				   ": skipping message type %d",
				    sres->sadb_msg_type));
			  break;
		  }
	  }
d393 1
a393 1
     } while (!forus);
d395 6
a400 6
     if (sres->sadb_msg_errno) {
	  LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",
		    strerror(sres->sadb_msg_errno)));
	  errno = sres->sadb_msg_errno;
	  return (0);
     }
d402 1
a402 1
     return (1);
d1114 1
a1114 1
	       log_print(__FUNCTION__": kernel_delete_spi()");
d1119 1
a1119 1
	       log_print(__FUNCTION__": kernel_delete_spi()");
@


1.17
log
@more cleanup. remove last vestiges of gmp.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.16 2000/12/15 01:06:51 provos Exp $";
d1362 1
a1362 1
	while (st != NULL && (st->lifetime <= tm || st->phase >= SPI_UPDATE))
d1396 2
d1402 18
@


1.16
log
@handle pfkey soft updates. only update when SA has been used.
@
text
@d2 1
a2 1
 * Copyright 1997,1998 Niels Provos <provos@@physnet.uni-hamburg.de>
d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.15 2000/12/14 23:28:58 provos Exp $";
@


1.15
log
@queue pfkey acquire and expire messages if we are currently waiting for
another pfkey transaction to return. some cleanup.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.14 2000/12/14 18:32:25 provos Exp $";
d78 1
a388 1
     struct sadb_alg *salg;
d391 1
a391 1
     int encfound, authfound, len;
d612 2
a613 3
	slh.sadb_lifetime_bytes = 1000000000;   /* lots of bytes */
	slh.sadb_lifetime_addtime = seconds + 60;
	slh.sadb_lifetime_usetime = seconds; /* first use */
d622 2
a623 3
	sls.sadb_lifetime_bytes = 900000000;   /* lots of bytes */
	sls.sadb_lifetime_addtime = (seconds + 60) * 9 / 10;
	sls.sadb_lifetime_usetime = seconds * 9 / 10; /* first use */
d1285 16
a1320 1
	struct sadb_msg *res;
a1380 1
		st->flags |= IPSEC_OPT_ENC;
d1382 2
a1383 4
		/* XXX - maybe see if we needs this
		if (em->em_not_satype & NOTIFY_SATYPE_AUTH)
			st->flags |= IPSEC_OPT_AUTH;
		*/
a1384 1
		/* XXX - handling of tunnel requests missing */
d1401 2
@


1.14
log
@setup soft lifetimes, handle hard expirations, deal with changed pfkey
supported extensions. some problems pointed out by
Hans-Joerg.Hoexer@@rommelwood.de
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.13 2000/12/13 08:36:27 provos Exp $";
d94 8
d224 6
a229 4
     if ((sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) 
	  log_fatal(__FUNCTION__": socket(PF_KEY) for IPSec keyengine");
     if ((regsd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) 
	  log_fatal(__FUNCTION__": socket() for PFKEY register");
d231 2
a232 2
     pfkey_seq = 0;
     pfkey_pid = getpid();
d234 2
a235 2
     if (kernel_register(regsd) == -1)
	  log_fatal(__FUNCTION__": PFKEY socket registration failed");
d237 1
a237 1
     return (1);
d302 26
d332 1
a332 1
     int len;
d341 1
a341 1
	       perror("read() in kernel_xf_read()");
d353 20
a372 4
     } while (seq && (sres->sadb_msg_seq != seq ||
		      (sres->sadb_msg_pid && sres->sadb_msg_pid != pfkey_pid)
		      ));
	      
a379 3
     if (sres->sadb_msg_pid && sres->sadb_msg_pid != pfkey_pid)
	     return (0);

d1106 42
d1156 2
a1157 2
     struct sadb_msg *sres = (struct sadb_msg *)buffer;
     size_t len;
d1159 4
a1162 2
     if (!kernel_xf_read(regsd, buffer, BUFFER_SIZE, 0))
	  return;
d1164 7
a1170 2
     LOG_DBG((LOG_KERNEL, 60, __FUNCTION__": Got PFKEYV2 message: type %d",
	      sres->sadb_msg_type));
d1172 3
a1174 24
     switch (sres->sadb_msg_type) {
     case SADB_EXPIRE:
	  LOG_DBG((LOG_KERNEL, 60, __FUNCTION__": Got SA Expiration"));
	  kernel_handle_expire(sres);
	  break;
     case SADB_ACQUIRE:
	  LOG_DBG((LOG_KERNEL, 60, __FUNCTION__
		   ": Got Notify SA Request (SADB_ACQUIRE): %d",
		   sres->sadb_msg_len * 8));
	  LOG_DBG_BUF((LOG_KERNEL, 60, "acquire buf",
		       (u_char *)sres, sres->sadb_msg_len * 8));
	  
	  len = sres->sadb_msg_len * 8;
	  sres = malloc(len);
	  if (sres) {
		  memcpy(sres, buffer, len);
		  kernel_request_sa(sres);
		  free(sres);
	  }
	  break;
     default:
	  /* discard silently */
	  return; 
	  }
@


1.13
log
@better debugging. reserve spis with the correct protocol.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.12 2000/12/12 01:53:41 provos Exp $";
a51 3
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/sysctl.h>
a55 1
#include <net/if_dl.h>
a56 3
#include <netns/ns.h>
#include <netiso/iso.h>
#include <netccitt/x25.h>
d67 1
a67 1
#define INET                     /* Needed for setting ipsec routes */
d117 24
a140 1
     int i;
d142 2
a143 5
     for (i=sizeof(xf)/sizeof(transform)-1; i >= 0; i--) 
	  if (xf[i].kernel_id == id && (xf[i].flags & type)) {
	       xf[i].flags |= XF_SUP;
	       return;
	  }
d340 3
a342 1
     int len;
d348 2
d360 1
a360 1
     /* Register for AH */
d368 17
a384 1
     /* Register for ESP */
d393 2
a394 14
     /* 
      * XXX - this might need changing in the case that the response
      * to register only includes the transforms matching the satype
      * in the message.
      */
     sres = (struct sadb_msg *)buffer;
     ssup = (struct sadb_supported *)(sres + 1);
     if (ssup->sadb_supported_exttype != SADB_EXT_SUPPORTED) {
	  log_print(__FUNCTION__
		    ": SADB_REGISTER did not return a SADB_EXT_SUPPORTED "
		    "struct: %d in kernel_register()",
		    ssup->sadb_supported_exttype);
	  return (-1);
     }
d396 19
a414 6
     len = ssup->sadb_supported_len * 8 - sizeof(*ssup);
     if (len != (ssup->sadb_supported_nauth + ssup->sadb_supported_nencrypt) *
	 sizeof(struct sadb_alg)) {
	  log_print(__FUNCTION__
		    ": SADB_SUPPORTED length mismatch in kernel_register()");
	  return (-1);
a415 6

     salg = (struct sadb_alg *)(ssup + 1);
     for (cnt = 0; cnt < ssup->sadb_supported_nauth; cnt++, salg++)
	  kernel_transform_seen(salg->sadb_alg_type, XF_AUTH);
     for (cnt = 0; cnt < ssup->sadb_supported_nencrypt; cnt++, salg++)
	  kernel_transform_seen(salg->sadb_alg_type, XF_ENC);
d552 34
a591 1
     struct sadb_lifetime sl;
d596 1
a596 1
     int len, cnt = 0;
a609 1
     bzero(&sl, sizeof(sl));
d621 1
a621 1
     len = iov[cnt++].iov_len = sizeof(sa);
d633 1
a633 1
     len += iov[cnt++].iov_len = sizeof(sad1);
d635 1
a635 1
     len += iov[cnt++].iov_len = sizeof(struct sockaddr);
d647 1
a647 1
     len += iov[cnt++].iov_len = sizeof(sad2);
d649 1
a649 1
     len += iov[cnt++].iov_len = sizeof(struct sockaddr);
d663 1
a663 9
     len += iov[cnt++].iov_len = sizeof(sr);

     sl.sadb_lifetime_len = sizeof(sl) / 8;
     sl.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
     sl.sadb_lifetime_allocations = 10;   /* 10 flows */
     sl.sadb_lifetime_bytes = 1000000000;   /* lots of bytes */
     sl.sadb_lifetime_addtime = SPI->lifetime + 60 - now;
     sl.sadb_lifetime_usetime = SPI->lifetime - now; /* first use */
     sa.sadb_msg_len += sl.sadb_lifetime_len;
d665 1
a665 2
     iov[cnt].iov_base = &sl;
     len += iov[cnt++].iov_len = sizeof(sl);
d673 1
a673 1
     len += iov[cnt++].iov_len = sizeof(sk);
d675 1
a675 1
     len += iov[cnt++].iov_len = ((ob->klen + 7) / 8) * 8;
d679 1
a679 1
     if (!KERNEL_XF_SET(len)) {
d683 1
a683 1
     return ob->klen;
a692 1
     struct sadb_lifetime sl;
a739 1
     bzero(&sl, sizeof(sl));
d798 1
a798 10
     sl.sadb_lifetime_len = sizeof(sl) / 8;
     sl.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
     sl.sadb_lifetime_allocations = 10;   /* 10 flows */
     sl.sadb_lifetime_bytes = 1000000000;   /* lots of bytes */
     sl.sadb_lifetime_addtime = SPI->lifetime + 60 - now;
     sl.sadb_lifetime_usetime = SPI->lifetime - now; /* first use */
     sa.sadb_msg_len += sl.sadb_lifetime_len;

     iov[cnt].iov_base = &sl;
     iov[cnt++].iov_len = sizeof(sl);
d1076 3
a1078 3
	  LOG_DBG((LOG_KERNEL, 40, __FUNCTION__
		   ": PFKEYV2 SA Expiration - not yet supported."));
	  return;
d1136 84
d1242 4
a1245 4
	dst = (struct sadb_address *)pfkey_find_extension(ext, end,
							  SADB_EXT_ADDRESS_DST);
	src = (struct sadb_address *)pfkey_find_extension(ext, end,
							  SADB_EXT_ADDRESS_SRC);
@


1.12
log
@listen to pfkeyv2 acquire messages and set up SAs accordingly.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.11 2000/12/11 21:37:46 provos Exp $";
d204 1
a204 1
	  log_fatal("socket(PF_KEY) for IPSec keyengine in init_kernel()");
d206 1
a206 1
	  log_fatal("socket() for PFKEY register in init_kernel()");
d212 1
a212 1
	  log_fatal("PFKEY socket registration failed in init_kernel()");
d297 1
a297 1
	       log_print("PFKEYV2 message len %d too big in kernel_xf_read()", len);
d301 1
a301 1
	       perror("read() in kernel_xf_read()");
d309 1
a309 1
	  LOG_DBG((LOG_KERNEL, 40, "kernel_xf_read: PFKEYV2 result: %s",
d331 1
a331 1
     LOG_DBG((LOG_KERNEL, 20, "kernel_register: fd %d", sd));
d347 1
a347 1
	  log_error("kernel_xf_set() in kernel_reserve_single_spi()");
d356 1
a356 1
	  log_error("kernel_xf_set() in kernel_reserve_single_spi()");
d368 2
a369 1
	  log_print("SADB_REGISTER did not return a SADB_EXT_SUPORTED "
d378 2
a379 1
	  log_print("SADB_SUPPORTED length mismatch in kernel_register()");
d398 3
a400 1
     LOG_DBG((LOG_KERNEL, 40, "kernel_reserve_spi: %s", src));
d407 1
d410 1
a439 3
     LOG_DBG((LOG_KERNEL, 40, "kernel_reserve_single_spi: %s, %08x",
	      srcaddress, spi));

d504 1
a504 1
	  log_error("kernel_xf_set() in kernel_reserve_single_spi()");
d511 2
a512 1
	  log_print("SADB_GETSPI did not return a SADB_EXT_SA struct: %d",
d517 4
a520 1
     return ntohl(ssa->sadb_sa_spi);
d540 1
a540 1
	  log_print("%d is not an auth transform in kernel_ah()", ob->id);
d626 1
a626 1
     LOG_DBG((LOG_KERNEL, 35, "kernel_ah: %08x", ntohl(sr.sadb_sa_spi)));
d629 1
a629 1
	  log_error("kernel_xf_set() in kernel_ah()");
d656 1
a656 1
	       log_print("No encryption after auth given in kernel_esp()");
d671 1
a671 1
	  log_print("No encryption transform given in kernel_esp()");
d677 1
a677 1
	  log_print("Old ESP does not support AH in kernel_esp()");
d711 1
a711 2
     if (xf_enc->flags & ESP_OLD)
     {
d782 1
a782 1
     LOG_DBG((LOG_KERNEL, 35, "kernel_esp: %08x", ntohl(sr.sadb_sa_spi)));
d785 1
a785 1
	  log_error("kernel_xf_set() in kernel_esp()");
d857 1
a857 1
     LOG_DBG((LOG_KERNEL, 30, "kernel_delete_spi: %08x", spi));
d860 1
a860 1
	  log_error("kernel_xf_set() in kernel_delete_spi()");
d899 1
a899 1
		    log_print("Unknown attribute %d for ESP in kernel_insert_spi()",
d911 2
a912 1
	       log_print("No encryption attribute in ESP section for SA(%08x, %s->%s) in kernel_insert()", SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
d928 1
a928 1
		    log_print("Unknown attribute %d for AH in kernel_insert_spi()",
d948 2
a949 1
	       log_print("No authentication attribute in AH section for SA(%08x, %s->%s) in kernel_insert()", SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
d1006 1
a1006 1
	       log_print("kernel_delete_spi() in kernel_unlink_spi()");
d1011 1
a1011 1
	       log_print("kernel_delete_spi() in kernel_unlink_spi()");
d1031 1
a1031 1
     LOG_DBG((LOG_KERNEL, 60, "Got PFKEYV2 message: type %d",
d1036 2
a1037 1
	  log_print("PFKEYV2 SA Expiration - not yet supported.");
d1040 2
a1041 1
	  LOG_DBG((LOG_KERNEL, 60, "Got Notify SA Request (SADB_ACQUIRE): %d",
d1154 2
a1155 1
			log_print("state_new() failed in kernel_request_sa() for remote ip %s",
@


1.11
log
@surpress some error messages
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.10 2000/12/11 21:21:18 provos Exp $";
d245 14
d1018 1
d1031 12
a1042 2
	  LOG_DBG((LOG_KERNEL, 60, "Got Notify SA Request (SADB_ACQUIRE)"));
	  kernel_request_sa(sres);
d1050 36
d1092 1
a1092 1
kernel_request_sa(void *em /*struct encap_msghdr *em*/) 
d1094 86
a1179 53
/*     struct stateob *st;
     time_t tm;
     char *address = inet_ntoa(em->em_not_dst);

     /#* Try to find an already established exchange which is still valid *#/
     st = state_find(address);

     tm = time(NULL);
     while (st != NULL && (st->lifetime <= tm || st->phase >= SPI_UPDATE))
	  st = state_find_next(st, address);

     if (st == NULL) {
	  /#* No established exchange found, start a new one *#/
	  if ((st = state_new()) == NULL) {
	       log_print("state_new() failed in kernel_request_sa() for remote ip %s",
			 address);
	       return (-1);
	  }
	  /#* Set up the state information *#/
	  strncpy(st->address, address, sizeof(st->address)-1);
	  st->port = global_port;
	  st->sport = em->em_not_sport;
	  st->dport = em->em_not_dport;
	  st->protocol = em->em_not_protocol;

	  /#*
	   * For states which were created by kernel notifies we wont
	   * set up routes since other keying daemons might habe beaten
	   * us in establishing SAs. The kernel has to decide which SA
	   * will actually be routed.
	   *#/
	  st->flags = IPSEC_NOTIFY;
	  if (em->em_not_satype & NOTIFY_SATYPE_CONF)
	       st->flags |= IPSEC_OPT_ENC;
	  if (em->em_not_satype & NOTIFY_SATYPE_AUTH)
	       st->flags |= IPSEC_OPT_AUTH;
	  /#* XXX - handling of tunnel requests missing *#/
	  if (start_exchange(global_socket, st, st->address, st->port) == -1) {
	       log_print("start_exchange() in kernel_request_sa() - informing kernel of failure");
	       /#* Inform kernel of our failure *#/
	       kernel_notify_result(st, NULL, 0);
	       state_value_reset(st);
	       free(st);
	       return (-1);
	  } else
	       state_insert(st);
     } else {
	  /#* 
	   * We need different attributes for this exchange, send
	   * an SPI_NEEDED message.
	   *#/
     }
*/
@


1.10
log
@proper logging.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.9 2000/12/11 20:32:15 provos Exp $";
d295 3
a297 2
	  log_print("kernel_xf_read: PFKEYV2 result: %s",
		    strerror(sres->sadb_msg_errno));
d839 1
a839 1
     if (!KERNEL_XF_SET(sa.sadb_msg_len * 8)) {
@


1.9
log
@remove lots of unnecssary code, on the way to new spd framework.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.8 2000/12/11 02:16:50 provos Exp $";
d87 1
a87 1
#include "errlog.h"
a92 8
#ifdef DEBUG
time_t now;

#define kernel_debug(x) {time(&now); printf("%.24s ", ctime(&now)); printf x;}
#else
#define kernel_debug(x)
#endif

d204 1
a204 1
	  crit_error(1, "socket(PF_KEY) for IPSec keyengine in init_kernel()");
d206 1
a206 1
	  crit_error(1, "socket() for PFKEY register in init_kernel()");
d212 1
a212 1
	  crit_error(0, "PFKEY socket registration failed in init_kernel()");
d236 1
a236 1
	  crit_error(1, "setsockopt: can not bypass ipsec authentication policy");
d239 1
a239 1
	  crit_error(1, "setsockopt: can not bypass ipsec esp transport policy");
d242 1
a242 1
	  crit_error(1, "setsockopt: can not bypass ipsec esp network policy");
d283 1
a283 1
	       log_error(0, "PFKEYV2 message len %d too big in kernel_xf_read()", len);
d295 1
a295 1
	  log_error(0, "kernel_xf_read: PFKEYV2 result: %s",
d316 1
a316 1
     kernel_debug(("kernel_register: fd %d\n", sd));
d332 1
a332 1
	  log_error(1, "kernel_xf_set() in kernel_reserve_single_spi()");
d341 1
a341 1
	  log_error(1, "kernel_xf_set() in kernel_reserve_single_spi()");
d353 1
a353 1
	  log_error(0, "SADB_REGISTER did not return a SADB_EXT_SUPORTED "
d362 1
a362 1
	  log_error(0, "SADB_SUPPORTED length mismatch in kernel_register()");
d381 1
a381 1
     kernel_debug(("kernel_reserve_spi: %s\n", src));
d419 2
a420 1
     kernel_debug(("kernel_reserve_single_spi: %s, %08x\n", srcaddress, spi));
d486 1
a486 1
	  log_error(1, "kernel_xf_set() in kernel_reserve_single_spi()");
d493 1
a493 1
	  log_error(0, "SADB_GETSPI did not return a SADB_EXT_SA struct: %d",
d518 1
a518 1
	  log_error(0, "%d is not an auth transform in kernel_ah()", ob->id);
d604 1
a604 1
     kernel_debug(("kernel_ah: %08x\n", ntohl(sr.sadb_sa_spi)));
d607 1
a607 1
	  log_error(1, "kernel_xf_set() in kernel_ah()");
d634 1
a634 1
	       log_error(0, "No encryption after auth given in kernel_esp()");
d649 1
a649 1
	  log_error(0, "No encryption transform given in kernel_esp()");
d655 1
a655 1
	  log_error(0, "Old ESP does not support AH in kernel_esp()");
d761 1
a761 1
     kernel_debug(("kernel_esp: %08x\n", ntohl(sr.sadb_sa_spi)));
d764 1
a764 1
	  log_error(1, "kernel_xf_set() in kernel_esp()");
d836 1
a836 1
     kernel_debug(("kernel_delete_spi: %08x\n", spi));
d839 1
a839 1
	  log_error(1, "kernel_xf_set() in kernel_delete_spi()");
d878 1
a878 1
		    log_error(0, "Unknown attribute %d for ESP in kernel_insert_spi()",
d890 1
a890 1
	       log_error(0, "No encryption attribute in ESP section for SA(%08x, %s->%s) in kernel_insert()", SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
d906 1
a906 1
		    log_error(0, "Unknown attribute %d for AH in kernel_insert_spi()",
d926 1
a926 1
	       log_error(0, "No authentication attribute in AH section for SA(%08x, %s->%s) in kernel_insert()", SPITOINT(SPI->SPI), SPI->local_address, SPI->address);
d983 1
a983 1
	       log_error(0, "kernel_delete_spi() in kernel_unlink_spi()");
d988 1
a988 1
	       log_error(0, "kernel_delete_spi() in kernel_unlink_spi()");
d1007 2
a1008 3
#ifdef DEBUG
     kernel_debug(("Got PFKEYV2 message: type %d\n", sres->sadb_msg_type));
#endif
d1012 1
a1012 1
	  log_error(0, "PFKEYV2 SA Expiration - not yet supported.\n");
d1015 1
a1015 3
#ifdef DEBUG
	  kernel_debug(("Got Notify SA Request (SADB_ACQUIRE)\n"));
#endif
d1046 1
a1046 1
	       log_error(0, "state_new() failed in kernel_request_sa() for remote ip %s",
d1070 1
a1070 1
	       log_error(0, "start_exchange() in kernel_request_sa() - informing kernel of failure");
d1119 1
a1119 1
     log_error(1, "kernel_xf_set() in kernel_notify_result()"); */
@


1.8
log
@make it use bignum.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.7 2000/08/25 05:16:46 angelos Exp $";
d173 1
a173 1
     return 0;
d188 1
a188 1
	  return -1; /* We don't know this attribute */
d201 1
a201 1
	  return -1;
d203 1
a203 1
	  return -1;
d205 1
a205 1
     return 0;
d222 1
a222 1
     return 1;
d265 1
a265 1
	  return 0;
d270 1
a270 1
     return 1;
d287 1
a287 1
	       return 0;
d292 1
a292 1
	       return 0;
d296 1
a296 1
	       return 0;
d305 1
a305 1
	  return 0;
d311 1
a311 1
     return 1;
d341 1
a341 1
	  return -1;
d350 1
a350 1
	  return -1;
d364 1
a364 1
	  return -1;
d371 1
a371 1
	  return -1;
d380 1
a380 1
     return 0;
d494 1
a494 1
	  return 0;
d502 1
a502 1
	  return 0;
d526 1
a526 1
	  return -1;
a582 2
     if (SPI->flags & SPI_TUNNEL)
	  sr.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
d611 1
a611 3
     kernel_debug(("kernel_ah: %08x. %s-Mode\n", 
		   ntohl(sr.sadb_sa_spi),
		   SPI->flags & SPI_TUNNEL ? "Tunnel" : "Transport"));
d615 1
a615 1
	  return -1;
d642 1
a642 1
	       return -1;
d657 1
a657 1
	  return -1;
d663 1
a663 1
	  return -1;
a701 2
     if (SPI->flags & SPI_TUNNEL)
	  sr.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
d768 1
a768 3
     kernel_debug(("kernel_esp: %08x. %s-Mode\n", 
		   ntohl(sr.sadb_sa_spi),
		   SPI->flags & SPI_TUNNEL ? "Tunnel" : "Transport"));
d772 1
a772 1
	  return -1;
a777 396
/* Group an ESP SPI with an AH SPI */

int
kernel_group_spi(char *address, u_int8_t *spi)
{
#ifndef OPENBSD_IPSEC_API_VERSION
     struct sadb_msg smsg;
     struct sadb_sa sa, sa2;
     struct sadb_address sad1, sad2;
     struct sadb_protocol sproto;
     union sockaddr_union dst1, dst2;
     struct iovec iov[8];
     int cnt = 0;
     u_int32_t SPI;

     SPI = SPITOINT(spi);

     bzero(&smsg, sizeof(smsg));
     bzero(&sa, sizeof(sa));
     bzero(&sa2, sizeof(sa2));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&dst1, sizeof(dst1));
     bzero(&dst2, sizeof(dst2));

     smsg.sadb_msg_version = PF_KEY_V2;
     smsg.sadb_msg_seq = pfkey_seq++;
     smsg.sadb_msg_pid = pfkey_pid;
     smsg.sadb_msg_type = SADB_X_GRPSPIS;
     smsg.sadb_msg_satype = SADB_SATYPE_ESP;
     smsg.sadb_msg_len = sizeof(smsg) / 8;

     iov[cnt].iov_base = &smsg;
     iov[cnt++].iov_len = sizeof(smsg);

     sa.sadb_sa_len = sizeof(sa) / 8;
     sa.sadb_sa_exttype = SADB_EXT_SA;
     sa.sadb_sa_spi = htonl(SPI);
     sa.sadb_sa_state = SADB_SASTATE_MATURE;
     smsg.sadb_msg_len += sa.sadb_sa_len;

     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);

     sa2.sadb_sa_len = sizeof(sa2) / 8;
     sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
     sa2.sadb_sa_spi = htonl(SPI);
     sa2.sadb_sa_state = SADB_SASTATE_MATURE;
     smsg.sadb_msg_len += sa2.sadb_sa_len;

     iov[cnt].iov_base = &sa2;
     iov[cnt++].iov_len = sizeof(sa2);

     sad1.sadb_address_len = (sizeof(sad1) + sizeof(struct sockaddr_in)) / 8;
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     dst1.sin.sin_family = AF_INET;
     dst1.sin.sin_len = sizeof(struct sockaddr_in);
     dst1.sin.sin_addr.s_addr = inet_addr(address);
     smsg.sadb_msg_len += sad1.sadb_address_len;
     iov[cnt].iov_base = &dst1;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     sad2.sadb_address_len = (sizeof(sad2) + sizeof(struct sockaddr_in)) / 8;
     sad2.sadb_address_exttype = SADB_X_EXT_DST2;
     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     dst2.sin.sin_family = AF_INET;
     dst2.sin.sin_len = sizeof(struct sockaddr_in);
     dst2.sin.sin_addr.s_addr = inet_addr(address);
     smsg.sadb_msg_len += sad2.sadb_address_len;
     iov[cnt].iov_base = &dst2;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     sproto.sadb_protocol_len = sizeof(sproto) / 8;
     sproto.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
     sproto.sadb_protocol_proto = SADB_SATYPE_AH;
     smsg.sadb_msg_len += sproto.sadb_protocol_len;
     iov[cnt].iov_base = &sproto;
     iov[cnt++].iov_len = sizeof(sproto);

     kernel_debug(("kernel_group_spi: %s, %08x\n", address, SPI));

     if (!KERNEL_XF_SET(smsg.sadb_msg_len*8)) {
	  log_error(1, "kernel_xf_set() in kernel_group_spi()");
	  return -1;
     }
#endif

     return 1;
}

int
kernel_bind_spis(struct spiob *spi1, struct spiob *spi2)
{
#ifndef OPENBSD_IPSEC_API_VERSION
     struct sadb_msg smsg;
     struct sadb_sa sa, sa2;
     struct sadb_address sad1, sad2;
     struct sadb_protocol sproto;
     union sockaddr_union dst1, dst2;
     struct iovec iov[8];
     int cnt = 0;
     u_int32_t inspi = SPITOINT(spi1->SPI);
     u_int32_t outspi = SPITOINT(spi2->SPI);

     bzero(&smsg, sizeof(smsg));
     bzero(&sa, sizeof(sa));
     bzero(&sa2, sizeof(sa2));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&dst1, sizeof(dst1));
     bzero(&dst2, sizeof(dst2));

     smsg.sadb_msg_version = PF_KEY_V2;
     smsg.sadb_msg_seq = pfkey_seq++;
     smsg.sadb_msg_pid = pfkey_pid;
     smsg.sadb_msg_type = SADB_X_BINDSA;
     smsg.sadb_msg_satype = spi1->flags & SPI_ESP ?
	  SADB_SATYPE_ESP : SADB_SATYPE_AH;
     smsg.sadb_msg_len = sizeof(smsg) / 8;

     iov[cnt].iov_base = &smsg;
     iov[cnt++].iov_len = sizeof(smsg);

     sa.sadb_sa_len = sizeof(sa) / 8;
     sa.sadb_sa_exttype = SADB_EXT_SA;
     sa.sadb_sa_spi = htonl(inspi);
     sa.sadb_sa_state = SADB_SASTATE_MATURE;
     smsg.sadb_msg_len += sa.sadb_sa_len;

     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);

     sa2.sadb_sa_len = sizeof(sa2) / 8;
     sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
     sa2.sadb_sa_spi = htonl(outspi);
     sa2.sadb_sa_state = SADB_SASTATE_MATURE;
     smsg.sadb_msg_len += sa2.sadb_sa_len;

     iov[cnt].iov_base = &sa2;
     iov[cnt++].iov_len = sizeof(sa2);

     sad1.sadb_address_len = (sizeof(sad1) + sizeof(struct sockaddr_in)) / 8;
     sad1.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     dst1.sin.sin_family = AF_INET;
     dst1.sin.sin_len = sizeof(struct sockaddr_in);
     dst1.sin.sin_addr.s_addr = inet_addr(spi1->local_address);
     smsg.sadb_msg_len += sad1.sadb_address_len;
     iov[cnt].iov_base = &dst1;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     sad2.sadb_address_len = (sizeof(sad2) + sizeof(struct sockaddr_in)) / 8;
     sad2.sadb_address_exttype = SADB_X_EXT_DST2;
     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     dst2.sin.sin_family = AF_INET;
     dst2.sin.sin_len = sizeof(struct sockaddr_in);
     dst2.sin.sin_addr.s_addr = inet_addr(spi2->address);
     smsg.sadb_msg_len += sad2.sadb_address_len;
     iov[cnt].iov_base = &dst2;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     sproto.sadb_protocol_len = sizeof(sproto) / 8;
     sproto.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
     sproto.sadb_protocol_proto = spi2->flags & SPI_ESP ?
	  SADB_SATYPE_ESP : SADB_SATYPE_AH;
     smsg.sadb_msg_len += sproto.sadb_protocol_len;
     iov[cnt].iov_base = &sproto;
     iov[cnt++].iov_len = sizeof(sproto);

     kernel_debug(("kernel_bind_spi: <%s, %08x> -> <%s, %08x>\n",
		   spi1->local_address, inspi, spi2->address, outspi));

     if (!KERNEL_XF_SET(smsg.sadb_msg_len*8)) {
	  log_error(1, "kernel_xf_set() in kernel_bind_spi()");
	  return -1;
     }
#endif

     return 1;
}

int
kernel_enable_spi(in_addr_t isrc, in_addr_t ismask, 
		  in_addr_t idst, in_addr_t idmask, 
		  char *address, u_int8_t *spi, int proto, int flags)
{
#ifndef OPENBSD_IPSEC_API_VERSION
     struct sadb_msg smsg;
     struct sadb_sa sa;
     struct sadb_address sad, sad1, sad2, sad3, sad4;
     union sockaddr_union dst, osrc, osmask, odst, odmask;
     struct iovec iov[12];
     u_int32_t SPI;
     int cnt = 0;
     SPI = SPITOINT(spi);

     bzero(&smsg, sizeof(smsg));
     bzero(&sa, sizeof(sa));
     bzero(&sad, sizeof(sad));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&sad3, sizeof(sad3));
     bzero(&sad4, sizeof(sad4));
     bzero(&dst, sizeof(dst));
     bzero(&osrc, sizeof(osrc));
     bzero(&osmask, sizeof(osmask));
     bzero(&odst, sizeof(odst));
     bzero(&odmask, sizeof(odmask));
     
     smsg.sadb_msg_len = sizeof(smsg) / 8;
     smsg.sadb_msg_version = PF_KEY_V2;
     smsg.sadb_msg_seq = pfkey_seq++;
     smsg.sadb_msg_pid = pfkey_pid;
     smsg.sadb_msg_type = SADB_X_ADDFLOW;
     smsg.sadb_msg_satype = proto == IPPROTO_ESP ?
	  SADB_SATYPE_ESP : SADB_SATYPE_AH;
     iov[cnt].iov_base = &smsg;
     iov[cnt++].iov_len = sizeof(smsg);

     sa.sadb_sa_len = sizeof(sa) / 8;
     sa.sadb_sa_exttype = SADB_EXT_SA;
     sa.sadb_sa_state = SADB_SASTATE_MATURE;
     sa.sadb_sa_spi = htonl(SPI);
     sa.sadb_sa_flags = flags;
     smsg.sadb_msg_len += sa.sadb_sa_len;
     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);

     sad.sadb_address_len = (sizeof(sad) + sizeof(struct sockaddr_in)) / 8;
     sad.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
     smsg.sadb_msg_len += sad.sadb_address_len;
     iov[cnt].iov_base = &sad;
     iov[cnt++].iov_len = sizeof(sad);

     dst.sin.sin_family = AF_INET;
     dst.sin.sin_len = sizeof(struct sockaddr_in);
     dst.sin.sin_addr.s_addr = inet_addr(address);
     iov[cnt].iov_base = &dst;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     sad1.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
     sad2.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
     sad3.sadb_address_exttype = SADB_X_EXT_DST_FLOW;
     sad4.sadb_address_exttype = SADB_X_EXT_DST_MASK;
     
     sad1.sadb_address_len = (sizeof(sad1) + sizeof(struct sockaddr_in)) / 8;
     sad2.sadb_address_len = (sizeof(sad2) + sizeof(struct sockaddr_in)) / 8;
     sad3.sadb_address_len = (sizeof(sad3) + sizeof(struct sockaddr_in)) / 8;
     sad4.sadb_address_len = (sizeof(sad4) + sizeof(struct sockaddr_in)) / 8;
     
     osrc.sin.sin_family = odst.sin.sin_family = AF_INET;
     osmask.sin.sin_family = odmask.sin.sin_family = AF_INET;
     osrc.sin.sin_len = odst.sin.sin_len = sizeof(struct sockaddr_in);
     osmask.sin.sin_len = sizeof(struct sockaddr_in);
     odmask.sin.sin_len = sizeof(struct sockaddr_in);
	    
     osrc.sin.sin_addr.s_addr = isrc;
     osmask.sin.sin_addr.s_addr = ismask;
     odst.sin.sin_addr.s_addr = idst;
     odmask.sin.sin_addr.s_addr = idmask;
     smsg.sadb_msg_len += sad1.sadb_address_len * 4;

     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     iov[cnt].iov_base = &osrc;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     iov[cnt].iov_base = &osmask;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     iov[cnt].iov_base = &sad3;
     iov[cnt++].iov_len = sizeof(sad3);
     iov[cnt].iov_base = &odst;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     iov[cnt].iov_base = &sad4;
     iov[cnt++].iov_len = sizeof(sad4);
     iov[cnt].iov_base = &odmask;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     kernel_debug(("kernel_enable_spi: %08x\n", SPI));

     if (!KERNEL_XF_SET(smsg.sadb_msg_len*8)) {
	  log_error(1, "kernel_xf_set() in kernel_enable_spi()");
	  return -1;
     }
#endif

     return 1;
}

int
kernel_disable_spi(in_addr_t isrc, in_addr_t ismask, 
		   in_addr_t idst, in_addr_t idmask, 
		   char *address, u_int8_t *spi, int proto, int flags)
{
#ifndef OPENBSD_IPSEC_API_VERSION
     struct sadb_msg smsg;
     struct sadb_sa sa;
     struct sadb_address sad1, sad2, sad3, sad4;
     union sockaddr_union osrc, osmask, odst, odmask;
     struct iovec iov[12];
     u_int32_t SPI;
     int cnt = 0;
     SPI = SPITOINT(spi);

     bzero(&smsg, sizeof(smsg));
     bzero(&sa, sizeof(sa));
     bzero(&sad1, sizeof(sad1));
     bzero(&sad2, sizeof(sad2));
     bzero(&sad3, sizeof(sad3));
     bzero(&sad4, sizeof(sad4));
     bzero(&osrc, sizeof(osrc));
     bzero(&osmask, sizeof(osmask));
     bzero(&odst, sizeof(odst));
     bzero(&odmask, sizeof(odmask));
     
     smsg.sadb_msg_len = sizeof(smsg) / 8;
     smsg.sadb_msg_version = PF_KEY_V2;
     smsg.sadb_msg_seq = pfkey_seq++;
     smsg.sadb_msg_pid = pfkey_pid;
     smsg.sadb_msg_type = SADB_X_DELFLOW;
     smsg.sadb_msg_satype = proto == IPPROTO_ESP ?
	  SADB_SATYPE_ESP : SADB_SATYPE_AH;
     iov[cnt].iov_base = &smsg;
     iov[cnt++].iov_len = sizeof(smsg);

     sa.sadb_sa_len = sizeof(sa) / 8;
     sa.sadb_sa_exttype = SADB_EXT_SA;
     sa.sadb_sa_state = SADB_SASTATE_MATURE;
     sa.sadb_sa_spi = htonl(SPI);
     sa.sadb_sa_flags = flags;
     smsg.sadb_msg_len += sa.sadb_sa_len;
     iov[cnt].iov_base = &sa;
     iov[cnt++].iov_len = sizeof(sa);

     sad1.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
     sad2.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
     sad3.sadb_address_exttype = SADB_X_EXT_DST_FLOW;
     sad4.sadb_address_exttype = SADB_X_EXT_DST_MASK;
     
     sad1.sadb_address_len = (sizeof(sad1) + sizeof(struct sockaddr_in)) / 8;
     sad2.sadb_address_len = (sizeof(sad2) + sizeof(struct sockaddr_in)) / 8;
     sad3.sadb_address_len = (sizeof(sad3) + sizeof(struct sockaddr_in)) / 8;
     sad4.sadb_address_len = (sizeof(sad4) + sizeof(struct sockaddr_in)) / 8;
     
     osrc.sin.sin_family = odst.sin.sin_family = AF_INET;
     osmask.sin.sin_family = odmask.sin.sin_family = AF_INET;
     osrc.sin.sin_len = odst.sin.sin_len = sizeof(struct sockaddr_in);
     osmask.sin.sin_len = sizeof(struct sockaddr_in);
     odmask.sin.sin_len = sizeof(struct sockaddr_in);
	    
     osrc.sin.sin_addr.s_addr = isrc;
     osmask.sin.sin_addr.s_addr = ismask;
     odst.sin.sin_addr.s_addr = idst;
     odmask.sin.sin_addr.s_addr = idmask;
     smsg.sadb_msg_len += sad1.sadb_address_len * 4;

     iov[cnt].iov_base = &sad1;
     iov[cnt++].iov_len = sizeof(sad1);
     iov[cnt].iov_base = &osrc;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     iov[cnt].iov_base = &sad2;
     iov[cnt++].iov_len = sizeof(sad2);
     iov[cnt].iov_base = &osmask;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     iov[cnt].iov_base = &sad3;
     iov[cnt++].iov_len = sizeof(sad3);
     iov[cnt].iov_base = &odst;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     iov[cnt].iov_base = &sad4;
     iov[cnt++].iov_len = sizeof(sad4);
     iov[cnt].iov_base = &odmask;
     iov[cnt++].iov_len = sizeof(struct sockaddr_in);

     kernel_debug(("kernel_disable_spi: %08x\n", SPI));

     if (!KERNEL_XF_SET(smsg.sadb_msg_len*8)) {
	  log_error(1, "kernel_xf_set() in kernel_disable_spi()");
	  return -1;
     }
#endif

     return 1;
}

d847 1
a847 1
	  return -1;
d850 1
a850 1
     return 1;
a865 1
     struct spiob *spi2;
d887 1
a887 1
		    return -1;
d898 1
a898 1
	       return -1;
a900 3
	  if (vpn_mode)
	       SPI->flags |= SPI_TUNNEL;
     
d903 1
a903 1
	       return -1;
d915 1
a915 1
		    return -1;
d934 1
a934 1
	       return -1;
a936 5
	  if (vpn_mode && esp == NULL)
	       SPI->flags |= SPI_TUNNEL;
	  else 
	       SPI->flags &= ~SPI_TUNNEL;

d939 1
a939 1
	       return -1;
a950 1
#if OPENBSD_IPSEC_API_VERSION == 1
a954 23
#else
     /* Group the SPIs for User */
     if (!(SPI->flags & SPI_OWNER) && ah != NULL && esp != NULL) {
	  if (kernel_group_spi(SPI->address, spi) == -1)
	       log_error(0, "kernel_group_spi() in kernel_insert_spi()");
     }

     if (!(SPI->flags & SPI_OWNER)) {
	  if (!(SPI->flags & SPI_NOTIFY) || vpn_mode) {
	       if (kernel_enable_spi(SPI->isrc, SPI->ismask,
				     SPI->idst, SPI->idmask,
				     SPI->address, spi, proto, 
				     SADB_X_SAFLAGS_REPLACEFLOW |
				     (vpn_mode ? /*ENABLE_FLAG_MODIFY*/ : 0)) == -1)
		    log_error(0, "kernel_enable_spi() in kernel_insert_spi()");
	  } else {
	       /* 
		* Inform the kernel that we obtained the requested SA
		*/
	       kernel_notify_result(st, SPI, proto);
	  }
     }
#endif
d956 1
a956 1
     /* Is this what people call perfect forward security ? */
d961 1
a961 17
     /* Bind the pair of SPI in the state object */
     if (SPI->flags & SPI_OWNER)
	  spi2 = spi_find(SPI->address, st->uSPI);
     else
	  spi2 = spi_find(SPI->local_address, st->oSPI);

     if (!spi2) {
	  log_error(0, "kernel_insert_spi(): can not find second SPI");
	  return 0;
     }

     if (SPI->flags & SPI_OWNER)
	  kernel_bind_spis(SPI, spi2);
     else
	  kernel_bind_spis(spi2, SPI);

     return 1;
a988 8
	  int flag = (vpn_mode ? /*ENABLE_FLAG_MODIFY*/ : 0);
	  if (!(ospi->flags & SPI_OWNER) && 
	      kernel_disable_spi(ospi->isrc, ospi->ismask,
				 ospi->idst, ospi->idmask,
				 ospi->address, ospi->SPI, 
				 IPPROTO_ESP, flag) == -1)
	       log_error(0, "kernel_disable_spi() in kernel_unlink_spi()");

a993 10
	  if (esp == NULL) {
	       int flag = (vpn_mode ? /*ENABLE_FLAG_MODIFY*/ : 0);
	       if (!(ospi->flags & SPI_OWNER) &&
		   kernel_disable_spi(ospi->isrc, ospi->ismask,
				      ospi->idst, ospi->idmask,
				      ospi->address, ospi->SPI, 
				      IPPROTO_AH, flag) == -1)
		    log_error(0, "kernel_disable_spi() in kernel_unlink_spi()");
	  }
	  
d998 1
a998 1
     return 1;
@


1.7
log
@Only play with flows if we have the "old" IPsec code (the new code to
be committed).
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.6 2000/01/27 08:06:38 angelos Exp $";
d298 4
a301 2
     } while ((seq && sres->sadb_msg_seq != seq) ||
	      (sres->sadb_msg_pid && sres->sadb_msg_pid != pfkey_pid));
d307 4
@


1.6
log
@Cheers from Canada (Montreal):

Use the new ESP/AH flags for "old" ESP/AH.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.5 1999/12/05 21:46:13 angelos Exp $";
d785 1
d868 1
d876 1
d961 1
d971 1
d1073 1
d1083 1
d1171 1
d1358 6
d1369 1
a1369 1
     
d1382 1
a1382 1
		    kernel_notify_result(st, SPI, proto);
d1385 2
a1386 1
	  
@


1.5
log
@Remove LOCALFLOW flag (thanks andreas)
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.4 1999/07/02 23:37:33 deraadt Exp $";
d536 1
a536 2
     sa.sadb_msg_satype = !hmac ?
	  SADB_X_SATYPE_AH_OLD : SADB_SATYPE_AH;
d579 2
d681 1
a681 2
     sa.sadb_msg_satype = xf_enc->flags & ESP_OLD ?
	  SADB_X_SATYPE_ESP_OLD : SADB_SATYPE_ESP;
d695 1
d697 3
@


1.4
log
@rename SADB_foo_X_bar to SADB_X_foo_bar
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.3 1999/03/31 20:33:45 niklas Exp $";
d1357 1
a1357 1
				     SADB_X_SAFLAGS_REPLACEFLOW | SADB_X_SAFLAGS_LOCALFLOW |
d1417 1
a1417 1
	  int flag = (vpn_mode ? /*ENABLE_FLAG_MODIFY*/ : 0) | SADB_X_SAFLAGS_LOCALFLOW;
d1431 1
a1431 2
	       int flag = (vpn_mode ? /*ENABLE_FLAG_MODIFY*/ : 0) | 
					SADB_X_SAFLAGS_LOCALFLOW;
@


1.3
log
@Use SADB_SAFLAGS_X_REPLACEFLOW
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.2 1999/03/27 21:18:01 provos Exp $";
d537 1
a537 1
	  SADB_SATYPE_X_AH_OLD : SADB_SATYPE_AH;
d579 1
a579 1
	  sr.sadb_sa_flags |= SADB_SAFLAGS_X_TUNNEL;
d681 1
a681 1
	  SADB_SATYPE_X_ESP_OLD : SADB_SATYPE_ESP;
d695 1
a695 1
	  sr.sadb_sa_flags |= SADB_SAFLAGS_X_HALFIV;
d697 1
a697 1
	  sr.sadb_sa_flags |= SADB_SAFLAGS_X_TUNNEL;
d820 1
a820 1
     sa2.sadb_sa_exttype = SADB_EXT_X_SA2;
d840 1
a840 1
     sad2.sadb_address_exttype = SADB_EXT_X_DST2;
d851 1
a851 1
     sproto.sadb_protocol_exttype = SADB_EXT_X_PROTOCOL;
d909 1
a909 1
     sa2.sadb_sa_exttype = SADB_EXT_X_SA2;
d929 1
a929 1
     sad2.sadb_address_exttype = SADB_EXT_X_DST2;
d940 1
a940 1
     sproto.sadb_protocol_exttype = SADB_EXT_X_PROTOCOL;
d1016 4
a1019 4
     sad1.sadb_address_exttype = SADB_EXT_X_SRC_FLOW;
     sad2.sadb_address_exttype = SADB_EXT_X_SRC_MASK;
     sad3.sadb_address_exttype = SADB_EXT_X_DST_FLOW;
     sad4.sadb_address_exttype = SADB_EXT_X_DST_MASK;
d1112 4
a1115 4
     sad1.sadb_address_exttype = SADB_EXT_X_SRC_FLOW;
     sad2.sadb_address_exttype = SADB_EXT_X_SRC_MASK;
     sad3.sadb_address_exttype = SADB_EXT_X_DST_FLOW;
     sad4.sadb_address_exttype = SADB_EXT_X_DST_MASK;
d1357 1
a1357 1
				     SADB_SAFLAGS_X_REPLACEFLOW | SADB_SAFLAGS_X_LOCALFLOW |
d1417 1
a1417 1
	  int flag = (vpn_mode ? /*ENABLE_FLAG_MODIFY*/ : 0) | SADB_SAFLAGS_X_LOCALFLOW;
d1432 1
a1432 1
					SADB_SAFLAGS_X_LOCALFLOW;
@


1.2
log
@convert the kernel module to PFKEYv2, support for binding incoming and
outgoing SA-pairs, fix a bug in SPI generation. the daemon registers
with pfkey but does not yet handle expiration or acquire messages. well,
there are NO acquire messages at the moment, so dynamic keyed vpn or
stuff does not work :-\ - all this done in canada. thanks again to
dugsong and linh for the ride. linh is sleeping now.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.1 1998/11/14 23:37:25 deraadt Exp $";
d1357 1
a1357 1
				     /* ENABLE_FLAG_REPLACE|*/ SADB_SAFLAGS_X_LOCALFLOW |
@


1.1
log
@move ipsec tools into .
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: kernel.c,v 1.11 1998/06/30 16:58:31 provos Exp $";
d48 1
d55 1
d75 1
a75 1
#include <net/encap.h>
d101 7
a107 1
static int sd;
d125 21
d149 3
a151 1
     return kernel_get_transform(id) == NULL ? -1 : 0;
d211 11
a221 2
     if ((sd = socket(AF_ENCAP, SOCK_RAW, AF_UNSPEC)) < 0) 
	  crit_error(1, "socket() for IPSec in init_kernel()");
d228 1
a228 1
     return sd;
d254 2
a255 1
kernel_xf_set(struct encap_msghdr *em)
d257 8
a264 1
     if (write(sd, (char *)em, em->em_msglen) != em->em_msglen)
d266 4
d274 1
a274 1
kernel_xf_read(struct encap_msghdr *em, int msglen)
d276 27
a302 2
     if (read(sd, (char *)em, msglen) != msglen) {
	  log_error(1, "read() in kernel_xf_read()");
d308 69
d378 1
a378 1
kernel_reserve_spi(char *srcaddress, int options)
d383 1
a383 1
     kernel_debug(("kernel_reserve_spi: %s\n", srcaddress));
d393 1
a393 1
	  return kernel_reserve_single_spi(srcaddress, 0, proto);
d396 1
a396 1
     if (!(spi = kernel_reserve_single_spi(srcaddress, 0, IPPROTO_ESP)))
d400 3
a402 3
     while (!kernel_reserve_single_spi(srcaddress, spi, IPPROTO_AH)) {
	  kernel_delete_spi(srcaddress, (u_int8_t *)&spi, IPPROTO_ESP);
	  if (!(spi = kernel_reserve_single_spi(srcaddress, 0, IPPROTO_ESP)))
d410 2
a411 1
kernel_reserve_single_spi(char *srcaddress, u_int32_t spi, int proto)
d413 7
a419 1
     struct encap_msghdr *em;
d423 60
a482 3
     bzero(buffer, EMT_RESERVESPI_FLEN);

     em = (struct encap_msghdr *)buffer;
d484 1
a484 3
     em->em_msglen = EMT_RESERVESPI_FLEN;
     em->em_version = PFENCAP_VERSION_1;
     em->em_type = EMT_RESERVESPI;
d486 1
a486 5
     em->em_gen_spi = spi;
     em->em_gen_dst.s_addr = inet_addr(srcaddress);
     em->em_gen_sproto = proto;
     
     if (!kernel_xf_set(em)) {
d491 5
a495 1
     if (!kernel_xf_read(em, EMT_RESERVESPI_FLEN))
d497 1
d499 1
a499 1
     return em->em_gen_spi;
d505 10
a514 3
     struct encap_msghdr *em;
     struct ah_old_xencap *xdo;
     struct ah_new_xencap *xdn;
d516 1
d523 82
a604 48
     em = (struct encap_msghdr *)buffer;

     if (!hmac) {
	  bzero(buffer, EMT_SETSPI_FLEN + 4 + ob->klen);

	  em->em_msglen = EMT_SETSPI_FLEN + AH_OLD_XENCAP_LEN + ob->klen;
	  
	  em->em_alg = XF_OLD_AH;

	  xdo = (struct ah_old_xencap *)(em->em_dat);
	  
	  xdo->amx_hash_algorithm = xf->kernel_id;
	  xdo->amx_keylen = ob->klen;
	
	  bcopy(secrets, xdo->amx_key, ob->klen);

     } else {
	  bzero(buffer, EMT_SETSPI_FLEN + AH_NEW_XENCAP_LEN + ob->klen);

	  em->em_msglen = EMT_SETSPI_FLEN + AH_NEW_XENCAP_LEN + ob->klen;

	  em->em_alg = XF_NEW_AH;

	  xdn = (struct ah_new_xencap *)(em->em_dat);

	  xdn->amx_hash_algorithm = xf->kernel_id;
	  xdn->amx_wnd = 16;
	  xdn->amx_keylen = ob->klen;

	  bcopy(secrets, xdn->amx_key, ob->klen);
     }
     
     em->em_version = PFENCAP_VERSION_1;
     em->em_type = EMT_SETSPI;
     em->em_spi = htonl((SPI->SPI[0]<<24) + (SPI->SPI[1]<<16) + 
			(SPI->SPI[2]<<8) + SPI->SPI[3]);
     em->em_src.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
				   SPI->address : SPI->local_address);
     em->em_dst.s_addr = inet_addr(SPI->flags & SPI_OWNER ? 
				   SPI->local_address : SPI->address);
	  
     if (SPI->flags & SPI_TUNNEL) {
	  em->em_osrc.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
					 SPI->address : SPI->local_address);
	  em->em_odst.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
					 SPI->local_address : SPI->address);
     }
     em->em_sproto = IPPROTO_AH;
d607 1
a607 1
		   em->em_spi, 
d610 1
a610 1
     if (!kernel_xf_set(em)) {
d620 10
a629 3
     struct encap_msghdr *em;
     struct esp_old_xencap *xdo;
     struct esp_new_xencap *xdn;
d632 3
a634 1
     transform *xf_enc, *xf_auth;
d666 96
a761 57
     em = (struct encap_msghdr *)buffer;

     if (xf_enc->flags & ESP_OLD) {
	  bzero(buffer, EMT_SETSPI_FLEN + ESP_OLD_XENCAP_LEN +4+attenc->klen);
	  
	  em->em_msglen = EMT_SETSPI_FLEN + ESP_OLD_XENCAP_LEN +4+attenc->klen;

	  em->em_alg = XF_OLD_ESP;

	  xdo = (struct esp_old_xencap *)(em->em_dat);

	  xdo->edx_enc_algorithm = xf_enc->kernel_id;
	  xdo->edx_ivlen = 4;
	  xdo->edx_keylen = attenc->klen;

	  bcopy(SPI->SPI, xdo->edx_data, 4);
	  bcopy(sec1, xdo->edx_data+4, attenc->klen);
     } else {
	  bzero(buffer, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + attenc->klen +
		(attauth ? attauth->klen : 0));

	  em->em_msglen = EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + 
	       attenc->klen + (attauth ? attauth->klen : 0);

	  em->em_alg = XF_NEW_ESP;

	  xdn = (struct esp_new_xencap *)(em->em_dat);

	  xdn->edx_enc_algorithm = xf_enc->kernel_id;
	  xdn->edx_hash_algorithm = attauth ? xf_auth->kernel_id : 0;
	  xdn->edx_ivlen = 0;
	  xdn->edx_confkeylen = attenc->klen;
	  xdn->edx_authkeylen = attauth ? attauth->klen : 0;
	  xdn->edx_wnd = 16;
	  xdn->edx_flags = attauth ? ESP_NEW_FLAG_AUTH : 0;

	  bcopy(sec1, xdn->edx_data, attenc->klen);
	  if (attauth != NULL)
	       bcopy(sec2, xdn->edx_data + attenc->klen, attauth->klen);
     }
     /* Common settings shared by ESP_OLD and ESP_NEW */

     em->em_version = PFENCAP_VERSION_1;
     em->em_type = EMT_SETSPI;
     em->em_spi = htonl((SPI->SPI[0]<<24) + (SPI->SPI[1]<<16) + 
			(SPI->SPI[2]<<8) + SPI->SPI[3]);
     em->em_src.s_addr = inet_addr(SPI->flags & SPI_OWNER ? 
				   SPI->address : SPI->local_address);
     em->em_dst.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
				   SPI->local_address : SPI->address);
     em->em_sproto = IPPROTO_ESP;
	
     if (SPI->flags & SPI_TUNNEL) {
	  em->em_osrc.s_addr = inet_addr(SPI->flags & SPI_OWNER ? 
					 SPI->address : SPI->local_address);
	  em->em_odst.s_addr = inet_addr(SPI->flags & SPI_OWNER ?
					 SPI->local_address : SPI->address);
d765 1
a765 1
		   em->em_spi,
d767 2
a768 2
     
     if (!kernel_xf_set(em)) {
d781 7
a787 2
     struct encap_msghdr *em;
     in_addr_t addr;
d790 66
a855 1
     SPI = (spi[0]<<24) + (spi[1]<<16) + (spi[2]<<8) + spi[3];
d859 4
a862 1
     addr = inet_addr(address);
d864 2
a865 1
     bzero(buffer, EMT_GRPSPIS_FLEN);
d867 85
a951 15
     em = (struct encap_msghdr *)buffer;
	  
     em->em_msglen = EMT_GRPSPIS_FLEN;
     em->em_version = PFENCAP_VERSION_1;
     em->em_type = EMT_GRPSPIS;

     em->em_rel_spi = htonl(SPI);
     em->em_rel_dst.s_addr = addr;
     em->em_rel_sproto = IPPROTO_ESP;
     em->em_rel_spi2 = htonl(SPI);
     em->em_rel_dst2.s_addr = addr;
     em->em_rel_sproto2 = IPPROTO_AH;
     
     if (!kernel_xf_set(em)) {
	  log_error(1, "kernel_xf_set() in kernel_group_spi()");
d963 5
a967 1
     struct encap_msghdr *em;
d969 2
d972 85
a1056 1
     SPI = (spi[0]<<24) + (spi[1]<<16) + (spi[2]<<8) + spi[3];
d1060 1
a1060 19
     bzero(buffer, EMT_ENABLESPI_FLEN);

     em = (struct encap_msghdr *)buffer;
     
     em->em_msglen = EMT_ENABLESPI_FLEN;
     em->em_version = PFENCAP_VERSION_1;
     em->em_type = EMT_ENABLESPI;

     em->em_ena_isrc.s_addr = isrc;
     em->em_ena_ismask.s_addr = ismask;
     em->em_ena_idst.s_addr = idst;
     em->em_ena_idmask.s_addr = idmask;

     em->em_ena_dst.s_addr = inet_addr(address);
     em->em_ena_spi = htonl(SPI);
     em->em_ena_sproto = proto;
     em->em_ena_flags = flags;

     if (!kernel_xf_set(em)) {
d1073 5
a1077 1
     struct encap_msghdr *em;
d1079 2
d1082 71
a1152 1
     SPI = (spi[0]<<24) + (spi[1]<<16) + (spi[2]<<8) + spi[3];
d1156 1
a1156 19
     bzero(buffer, EMT_DISABLESPI_FLEN);

     em = (struct encap_msghdr *)buffer;
     
     em->em_msglen = EMT_DISABLESPI_FLEN;
     em->em_version = PFENCAP_VERSION_1;
     em->em_type = EMT_DISABLESPI;

     em->em_ena_isrc.s_addr = isrc;
     em->em_ena_ismask.s_addr = ismask;
     em->em_ena_idst.s_addr = idst;
     em->em_ena_idmask.s_addr = idmask;

     em->em_ena_dst.s_addr = inet_addr(address);
     em->em_ena_spi = htonl(SPI);
     em->em_ena_sproto = proto;
     em->em_ena_flags = flags;
     
     if (!kernel_xf_set(em) && errno != ENOENT) {
d1169 1
a1169 1
kernel_delete_spi(char *address, u_int8_t *spi, int proto)
d1171 57
a1227 1
	struct encap_msghdr *em;
d1229 1
a1229 1
	bzero(buffer, EMT_DELSPI_FLEN);
d1231 4
a1234 1
	em = (struct encap_msghdr *)buffer;
d1236 1
a1236 16
	em->em_msglen = EMT_DELSPI_FLEN;
	em->em_version = PFENCAP_VERSION_1;
	em->em_type = EMT_DELSPI;
	em->em_gen_spi = htonl((spi[0]<<24) + (spi[1]<<16) + 
			   (spi[2]<<8) + spi[3]);
	em->em_gen_dst.s_addr = inet_addr(address);
	em->em_gen_sproto = proto;

	kernel_debug(("kernel_delete_spi: %08x\n", em->em_gen_spi));

	if (!kernel_xf_set(em)) {
	     log_error(1, "kernel_xf_set() in kernel_delete_spi()");
	     return -1;
	}

	return 1;
d1252 1
d1284 1
a1284 1
	       log_error(0, "No encryption attribute in ESP section for SA(%08x, %s->%s) in kernel_insert()", (SPI->SPI[0] << 24) + (SPI->SPI[1] << 16) + (SPI->SPI[2] << 8) + SPI->SPI[3], SPI->local_address, SPI->address);
d1323 1
a1323 1
	       log_error(0, "No authentication attribute in AH section for SA(%08x, %s->%s) in kernel_insert()", (SPI->SPI[0] << 24) + (SPI->SPI[1] << 16) + (SPI->SPI[2] << 8) + SPI->SPI[3], SPI->local_address, SPI->address);
d1338 1
a1338 1
     if (esp != NULL)
d1340 2
a1341 1
     else
d1343 2
d1352 1
a1352 1
     if (!(SPI->flags & SPI_OWNER)) 
d1357 2
a1358 2
				     ENABLE_FLAG_REPLACE|ENABLE_FLAG_LOCAL |
				     (vpn_mode ? ENABLE_FLAG_MODIFY : 0)) == -1)
d1364 1
a1364 1
	       kernel_notify_result(st, SPI, proto);
d1366 1
d1373 16
a1402 3
     int n, proto = 0;
     attrib_t *attprop;
     u_int32_t spi;
d1415 1
a1415 1

d1417 1
a1417 1
	  int flag = (vpn_mode ? ENABLE_FLAG_MODIFY : 0) | ENABLE_FLAG_LOCAL;
d1425 1
a1425 1
	  if (kernel_delete_spi(p, ospi->SPI, IPPROTO_ESP) == -1)
d1431 2
a1432 2
	       int flag = (vpn_mode ? ENABLE_FLAG_MODIFY : 0) | 
		    ENABLE_FLAG_LOCAL;
d1441 1
a1441 1
	  if (kernel_delete_spi(p, ospi->SPI, IPPROTO_AH) == -1)
d1456 1
a1456 7
     struct encap_msghdr em;
     int msglen;

     if ((msglen = recvfrom(sd, (char *)&em, sizeof(em),0, NULL,0)) == -1) {
	  log_error(1, "recvfrom() in kernel_handle_notify()");
	  return;
     }
d1458 1
a1458 2
     if (msglen != em.em_msglen) {
	  log_error(0, "message length incorrect in kernel_handle_notify(): got %d where it should be %d", msglen, em.em_msglen);
a1459 6
     }

     if (em.em_type != EMT_NOTIFY) {
	  log_error(0, "message type is not notify in kernel_handle_notify()");
	  return;
     }
d1462 1
a1462 1
     printf("Received EMT_NOTIFY message: subtype %d\n", em.em_not_type);
d1465 3
a1467 4
     switch (em.em_not_type) {
     case NOTIFY_SOFT_EXPIRE:
     case NOTIFY_HARD_EXPIRE:
	  log_error(0, "Notify is an SA Expiration - not yet supported.\n");
d1469 1
a1469 1
     case NOTIFY_REQUEST_SA:
d1471 1
a1471 2
	  printf("Notify SA Request for IP: %s, require %d\n",
		 inet_ntoa(em.em_not_dst), em.em_not_satype);
d1473 1
a1473 1
	  kernel_request_sa(&em);
d1476 3
a1478 3
	  log_error(0, "Unknown notify message in kernel_handle_notify");
	  return;
     }
d1487 1
a1487 1
kernel_request_sa(struct encap_msghdr *em) 
d1489 1
a1489 1
     struct stateob *st;
d1493 1
a1493 1
     /* Try to find an already established exchange which is still valid */
d1501 1
a1501 1
	  /* No established exchange found, start a new one */
d1507 1
a1507 1
	  /* Set up the state information */
d1514 1
a1514 1
	  /*
d1519 1
a1519 1
	   */
d1525 1
a1525 1
	  /* XXX - handling of tunnel requests missing */
d1528 1
a1528 1
	       /* Inform kernel of our failure */
d1536 1
a1536 1
	  /* 
d1539 1
a1539 1
	   */
d1541 1
d1553 2
a1554 1
     struct encap_msghdr em;
d1576 1
a1576 1
	  log_error(1, "kernel_xf_set() in kernel_notify_result()");
@

