head	1.9;
access;
symbols
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2003.03.13.00.33.47;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2002.06.10.19.58.20;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.07.18.26.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.28.22.45.12;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.01.58.27;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.11.21.21.18;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.11.02.16.50;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.11.14.23.37.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@thought we had already deleted this
@
text
@/*	$OpenBSD: modulus.c,v 1.8 2002/06/10 19:58:20 espie Exp $	*/

/*
 * Copyright 1997-2000 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * modulus.c:
 * functions for handling moduli
 */

#define _MODULUS_C_

#ifdef DEBUG
#include <stdio.h>
#endif

#include <stdlib.h>
#include <time.h>
#include <ssl/bn.h>
#include "config.h"
#include "modulus.h"
#include "log.h"

TAILQ_HEAD(modlist, moduli_cache) modhead;

void
mod_init(void)
{
	TAILQ_INIT(&modhead);
}

int
mod_insert(struct moduli_cache *ob)
{
	TAILQ_INSERT_TAIL(&modhead, ob, next);

	return (1);
}

int
mod_unlink(struct moduli_cache *ob)
{
	TAILQ_REMOVE(&modhead, ob, next);
	free(ob);

	return (0);
}

/*
 * Check moduli for primality:
 * check iter iterations, remain at max tm seconds here
 * tm == 0, check all.
 */

void
mod_check_prime(int iter, int tm)
{
	struct moduli_cache *p, *tmp = NULL, *next;
	time_t now;
	int flag;
	BN_CTX *ctx;

	ctx = BN_CTX_new();

	now = time(NULL);
	for (p = TAILQ_FIRST(&modhead);
	     p != NULL && (tm == 0 || (time(NULL) - now < tm)); p = next) {
		next = TAILQ_NEXT(p, next);

		if (p->iterations < MOD_PRIME_MAX &&
		    (p->status == MOD_UNUSED || p->status == MOD_COMPUTING)) {
			flag = BN_is_prime(p->modulus, iter, NULL, ctx, NULL);
			if (!flag)
				log_print("%s: found a non prime", __func__);

			tmp = mod_find_modulus(p->modulus);
			while (tmp != NULL) {
				if (!flag) {
					tmp->status = MOD_NOTPRIME;
					tmp->lifetime = now + 2*MOD_TIMEOUT;
				} else {
					tmp->iterations += iter;
					if (tmp->iterations >= MOD_PRIME_MAX)
						tmp->status = MOD_PRIME;
					else
						tmp->status = MOD_COMPUTING;
				}
				tmp = mod_find_modulus_next(tmp, p->modulus);
			}
#ifdef USE_DEBUG
			{
				char *hex, *msg;
				if (!flag)
					msg = "not prime.";
				else if (p->iterations >= MOD_PRIME_MAX)
					msg = "probably prime.";
				else
					msg = "undecided.";
				hex = BN_bn2hex(p->modulus);
				LOG_DBG((LOG_CRYPTO, 50, 
					 "%s: check prime: %s: %s",
					 __func__, hex, msg));
				free(hex);
			}
#endif
		}

		if (p->status == MOD_NOTPRIME && p->lifetime < now) {
			LOG_DBG((LOG_CRYPTO, 40, 
				 "%s: unlinking non prime modulus", __func__));
			mod_value_reset(tmp);
			mod_unlink(tmp);
		}
	}

	BN_CTX_free(ctx);
}

struct moduli_cache *
mod_new_modgen(BIGNUM *m, BIGNUM *g)
{
     struct moduli_cache *p;

     if((p = calloc(1, sizeof(struct moduli_cache)))==NULL)
	  return NULL;

     p->modulus = BN_new(); BN_copy(p->modulus, m);
     p->generator = BN_new(); BN_copy(p->generator, g);
     p->private_value = BN_new();

     /* XXX - change lifetime later */
     p->lifetime = time(NULL) + MOD_TIMEOUT;
     p->status = MOD_UNUSED;

     return p;
}

struct moduli_cache *
mod_new_modulus(BIGNUM *m)
{
     struct moduli_cache *tmp;

     BIGNUM *generator;
     generator = BN_new();
     tmp = mod_new_modgen(m, generator);
     BN_clear_free(generator);

     return (tmp);
}

int
mod_value_reset(struct moduli_cache *ob)
{
     BN_clear_free(ob->private_value);
     BN_clear_free(ob->modulus);
     BN_clear_free(ob->generator);

     if (ob->exchangevalue != NULL)
	  free(ob->exchangevalue);

     return (1);
}

/* Find a proper modulus and generator in the queue.
 * 0 matches everything.
 */

struct moduli_cache *
mod_find_modgen_next(struct moduli_cache *ob, BIGNUM *modulus,
		     BIGNUM *generator)
{
     if (ob != NULL)
	     ob = TAILQ_NEXT(ob, next);
     else
	     ob = TAILQ_FIRST(&modhead);

     for ( ; ob; ob = TAILQ_NEXT(ob, next)) {
          if ((BN_is_zero(generator) ||
	       !BN_cmp(ob->generator, generator)) &&
	      (BN_is_zero(modulus) || !BN_cmp(modulus, ob->modulus)))
		  break;
     }

     return (ob);
}

struct moduli_cache *
mod_find_modgen(BIGNUM *modulus, BIGNUM *generator)
{
     return (mod_find_modgen_next(NULL, modulus, generator));
}

struct moduli_cache *
mod_find_generator_next(struct moduli_cache *ob, BIGNUM *generator)
{
     struct moduli_cache *tmp;
     BIGNUM *modulus;

     modulus = BN_new();
     BN_zero(modulus);

     tmp = mod_find_modgen_next(ob, modulus, generator);

     BN_free(modulus);

     return (tmp);
}

struct moduli_cache *
mod_find_generator(BIGNUM *generator)
{
     struct moduli_cache *tmp;
     BIGNUM *modulus;

     modulus = BN_new();
     BN_zero(modulus);

     tmp = mod_find_modgen(modulus,generator);

     BN_free(modulus);

     return (tmp);
}

struct moduli_cache *
mod_find_modulus_next(struct moduli_cache *ob, BIGNUM *modulus)
{
     struct moduli_cache *tmp;
     BIGNUM *generator;

     generator = BN_new();
     BN_zero(generator);

     tmp = mod_find_modgen_next(ob, modulus, generator);

     BN_free(generator);

     return (tmp);
}

struct moduli_cache *
mod_find_modulus(BIGNUM *modulus)
{
     struct moduli_cache *tmp;
     BIGNUM *generator;

     generator = BN_new();
     BN_zero(generator);

     tmp = mod_find_modgen(modulus,generator);

     BN_free(generator);

     return (tmp);
}


void
mod_cleanup(void)
{
     struct moduli_cache *p;

     while ((p = TAILQ_FIRST(&modhead))) {
	     TAILQ_REMOVE(&modhead, p, next);
	     mod_value_reset(p);
	     free(p);
     }
}

@


1.8
log
@kill __FUNCTION__
add __attribute__((format...)
Fix one bad call.

okay provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: modulus.c,v 1.7 2002/06/09 08:13:08 todd Exp $	*/
@


1.7
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: modulus.c,v 1.6 2001/07/07 18:26:18 deraadt Exp $	*/
d100 1
a100 1
				log_print(__FUNCTION__": found a non prime");
d126 3
a128 3
				LOG_DBG((LOG_CRYPTO, 50, __FUNCTION__
					 ": check prime: %s: %s",
					 hex, msg));
d135 2
a136 2
			LOG_DBG((LOG_CRYPTO, 40, __FUNCTION__
				 ": unlinking non prime modulus"));
@


1.6
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: modulus.c,v 1.5 2001/01/28 22:45:12 niklas Exp $	*/
d75 1
a75 1
/* 
d116 1
a116 1
#ifdef USE_DEBUG 
d125 1
a125 1
				hex = BN_bn2hex(p->modulus); 
d127 1
a127 1
					 ": check prime: %s: %s", 
d129 1
a129 1
				free(hex); 
d132 1
a132 1
		}  
d164 3
a166 3
struct moduli_cache * 
mod_new_modulus(BIGNUM *m) 
{ 
d179 1
a179 1
{ 
d203 6
a208 6
     for ( ; ob; ob = TAILQ_NEXT(ob, next)) { 
          if ((BN_is_zero(generator) ||  
	       !BN_cmp(ob->generator, generator)) && 
	      (BN_is_zero(modulus) || !BN_cmp(modulus, ob->modulus))) 
		  break; 
     } 
d210 1
a210 1
     return (ob); 
d219 1
a219 1
struct moduli_cache *   
d223 2
a224 2
     BIGNUM *modulus;  
  
d228 1
a228 1
     tmp = mod_find_modgen_next(ob, modulus, generator);  
d230 8
a237 8
     BN_free(modulus);  
  
     return (tmp);  
}  

struct moduli_cache *  
mod_find_generator(BIGNUM *generator)  
{ 
d239 2
a240 2
     BIGNUM *modulus; 
 
d244 3
a246 1
     tmp = mod_find_modgen(modulus,generator); 
d248 6
a253 8
     BN_free(modulus); 
 
     return (tmp); 
} 

struct moduli_cache *  
mod_find_modulus_next(struct moduli_cache *ob, BIGNUM *modulus)  
{ 
d255 2
a256 2
     BIGNUM *generator; 
 
d260 3
a262 1
     tmp = mod_find_modgen_next(ob, modulus, generator); 
d264 2
a265 4
     BN_free(generator); 
 
     return (tmp); 
} 
d267 2
a268 2
struct moduli_cache * 
mod_find_modulus(BIGNUM *modulus) 
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
	struct moduli_cache *p, *tmp, *next;
@


1.4
log
@more cleanup. remove last vestiges of gmp.
@
text
@d1 2
@


1.3
log
@proper logging.
@
text
@d2 1
a2 1
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
d48 7
a54 1
static struct moduli_cache *modob = NULL;
d59 1
a59 12
     struct moduli_cache *tmp;

     ob->next = NULL;

     if(modob == NULL) {
	  modob = ob;
	  return 1;
     }
     
     tmp=modob;
     while(tmp->next!=NULL)
	  tmp = tmp->next;
d61 1
a61 2
     tmp->next = ob;
     return 1;
d67 2
a68 6
     struct moduli_cache *tmp;
     if(modob == ob) {
	  modob = ob->next;
	  free(ob);
	  return 1;
     }
d70 1
a70 8
     for(tmp=modob; tmp!=NULL; tmp=tmp->next) {
	  if(tmp->next==ob) {
	       tmp->next=ob->next;
	       free(ob);
	       return 1;
	  }
     }
     return 0;
d82 47
a128 46
     struct moduli_cache *p = modob, *tmp;
     time_t now;
     int flag;
     BN_CTX *ctx;

#ifdef DEBUG 
     char *hex; 
#endif 

     ctx = BN_CTX_new();

     now = time(NULL);
     while (p != NULL && (tm == 0 || (time(NULL) - now < tm))) {
	  if (p->iterations < MOD_PRIME_MAX &&
	      (p->status == MOD_UNUSED || p->status == MOD_COMPUTING)) {
#ifdef DEBUG 
	       hex = BN_bn2hex(p->modulus); 
	       printf(" Checking 0x%s for primality: ", hex);  
	       fflush(stdout); 
	       free(hex); 
#endif 
	       flag = BN_is_prime(p->modulus, iter, NULL, ctx, NULL);
	       if (!flag)
		    log_print("found a non prime in mod_check_prime()");

	       tmp = mod_find_modulus(p->modulus);
	       while (tmp != NULL) {
		    if (!flag) {
			 tmp->status = MOD_NOTPRIME;
			 tmp->lifetime = now + 2*MOD_TIMEOUT;
		    } else {
			 tmp->iterations += iter;
			 if (tmp->iterations >= MOD_PRIME_MAX)
			      tmp->status = MOD_PRIME;
			 else
			      tmp->status = MOD_COMPUTING;
		    }
		    tmp = mod_find_modulus_next(tmp, p->modulus);
	       }
#ifdef DEBUG
	       if (!flag)
		    printf("not prime\n");
	       else if (p->iterations >= MOD_PRIME_MAX)
		    printf("probably prime.\n");
	       else
		    printf("undecided.\n");
d130 1
a130 1
	  }  
d132 7
a138 12
	  if (p->status == MOD_NOTPRIME && p->lifetime < now) {
	       struct moduli_cache *tmp;
#ifdef DEBUG
	       printf("Unlinking non prime modulus.\n");
#endif
	       tmp = p;
	       p = p->next;
	       mod_value_reset(tmp);
	       mod_unlink(tmp);
	  }
	  p = p->next;
     }
d140 1
a140 1
     BN_CTX_free(ctx);
d172 1
a172 1
     return tmp;
d185 1
a185 1
     return 1;
d196 2
a197 4
     struct moduli_cache *tmp = ob; 

     if (tmp == NULL)
	  tmp = modob;
d199 1
a199 1
	  tmp = tmp->next;
d201 5
a205 6
     while(tmp!=NULL) { 
          if((BN_is_zero(generator) ||  
              !BN_cmp(tmp->generator, generator)) && 
             (BN_is_zero(modulus) || !BN_cmp(modulus, tmp->modulus))) 
               return tmp; 
          tmp = tmp->next; 
d207 2
a208 1
     return NULL; 
d214 1
a214 1
     return mod_find_modgen_next(NULL, modulus, generator);
d223 3
a225 1
     modulus = BN_new();                     /* Is set to zero by init */  
d227 2
a228 1
     BN_clear_free(modulus);  
d230 1
a230 1
     return tmp;  
d239 3
a241 1
     modulus = BN_new();                     /* Is set to zero by init */ 
d243 2
a244 1
     BN_clear_free(modulus); 
d246 1
a246 1
     return tmp; 
d255 3
a257 1
     generator = BN_new();                    /* Is set to zero by init */ 
d259 2
a260 1
     BN_clear_free(generator); 
d262 1
a262 1
     return tmp; 
d271 3
a273 1
     generator = BN_new();                    /* Is set to zero by init */
a274 1
     BN_clear_free(generator);
d276 3
a278 1
     return tmp;
d283 1
a283 1
mod_cleanup()
d286 5
a290 6
     struct moduli_cache *tmp = modob;
     while(tmp!=NULL) {
	  p = tmp;
	  mod_value_reset(tmp);
	  tmp = tmp->next;
	  free(p);
a291 1
     modob = NULL;
@


1.2
log
@make it use bignum.
@
text
@d46 1
a46 1
#include "errlog.h"
d122 1
a122 1
		    log_error(0, "found a non prime in mod_check_prime()");
@


1.1
log
@move ipsec tools into .
@
text
@d43 1
a43 1
#include <gmp.h>
d102 1
d108 2
d111 1
a111 1
     while(p != NULL && (tm == 0 || (time(NULL) - now < tm))) {
d115 1
a115 1
	       hex = mpz_get_str(NULL, 16, p->modulus); 
d120 1
a120 1
	       flag = mpz_probab_prime_p(p->modulus, iter);
d125 1
a125 1
	       while(tmp != NULL) {
d160 2
d165 1
a165 1
mod_new_modgen(mpz_t m, mpz_t g)
d172 3
a174 3
     mpz_init_set(p->modulus,m);
     mpz_init_set(p->generator,g);
     mpz_init(p->private_value);
d184 1
a184 1
mod_new_modulus(mpz_t m) 
d188 2
a189 2
     mpz_t generator;
     mpz_init(generator);
d191 1
a191 1
     mpz_clear(generator);
d199 3
a201 3
     mpz_clear(ob->private_value);
     mpz_clear(ob->modulus);
     mpz_clear(ob->generator);
d214 2
a215 1
mod_find_modgen_next(struct moduli_cache *ob, mpz_t modulus, mpz_t generator)
d225 3
a227 3
          if((!mpz_cmp_ui(generator,0) ||  
              !mpz_cmp(tmp->generator,generator)) && 
             (!mpz_cmp_ui(modulus,0) || !mpz_cmp(modulus,tmp->modulus))) 
d235 1
a235 1
mod_find_modgen(mpz_t modulus, mpz_t generator)
d241 1
a241 1
mod_find_generator_next(struct moduli_cache *ob, mpz_t generator)
d244 1
a244 1
     mpz_t modulus;  
d246 1
a246 1
     mpz_init(modulus);                     /* Is set to zero by init */  
d248 1
a248 1
     mpz_clear(modulus);  
d254 1
a254 1
mod_find_generator(mpz_t generator)  
d257 1
a257 1
     mpz_t modulus; 
d259 1
a259 1
     mpz_init(modulus);                     /* Is set to zero by init */ 
d261 1
a261 1
     mpz_clear(modulus); 
d267 1
a267 1
mod_find_modulus_next(struct moduli_cache *ob, mpz_t modulus)  
d270 1
a270 1
     mpz_t generator; 
d272 1
a272 1
     mpz_init(generator);                    /* Is set to zero by init */ 
d274 1
a274 1
     mpz_clear(generator); 
d280 1
a280 1
mod_find_modulus(mpz_t modulus) 
d283 1
a283 1
     mpz_t generator;
d285 1
a285 1
     mpz_init(generator);                    /* Is set to zero by init */
d287 1
a287 1
     mpz_clear(generator);
@

