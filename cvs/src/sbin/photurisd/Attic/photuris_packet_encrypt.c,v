head	1.6;
access;
symbols
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2003.03.13.00.33.47;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.28.22.45.14;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.50.39;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.11.21.21.18;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.11.14.23.37.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@thought we had already deleted this
@
text
@/*	$OpenBSD: photuris_packet_encrypt.c,v 1.5 2002/06/09 08:13:08 todd Exp $	*/

/*
 * Copyright 1997-2000 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * photuris_packet_encrypt:
 * encrypts packets with the privacy choice.
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: photuris_packet_encrypt.c,v 1.5 2002/06/09 08:13:08 todd Exp $";
#endif

#define _ENCRYPT_C_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <des.h>
#include "config.h"
#include "packets.h"
#include "state.h"
#include "attributes.h"
#include "encrypt.h"
#include "secrets.h"
#include "log.h"
#ifdef DEBUG
#include "config.h"
#endif

void
packet_mask(u_int8_t *packet, u_int16_t len, u_int8_t *key)
{
     int i;
     for (i=0; i<len; i++)
	  packet[i] ^= key[i];
}

int
packet_create_padding(struct stateob *st, u_int16_t size, u_int8_t *padd,
		      u_int16_t *rsize)
{
     u_int8_t padlength, i;

     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5:
     case DH_G_3_MD5:
     case DH_G_5_MD5:
	  padlength = (arc4random() & 0xf0) - (size%16);
	  if (padlength < 8)
	       padlength += 8;
	  break;
     default:
	  padlength = (arc4random() & 0xf0) - (size%16);
	  if (padlength < 8)
	       padlength += 8;
	  break;
     }

     if(*rsize < padlength)
          return -1;

     /* Pad the rest of the payload */
     for(i=1;i<=padlength;i++)
          padd[i-1] = i;

     *rsize = padlength;

     return 0;
}

int
packet_encrypt(struct stateob *st, u_int8_t *payload, u_int16_t payloadlen)
{
     des_cblock keys[4], *input;
     des_key_schedule key1,key2,key3;
     u_int8_t *pkey;
     u_int16_t order = 0;
     int i;

     input = (des_cblock *)payload;

     /* No encryption needed */
     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5:
     case DH_G_3_MD5:
     case DH_G_5_MD5:
#ifdef DEBUG
	  printf("[Packet encryption: None]\n");
#endif
	  pkey = calloc(payloadlen,sizeof(u_int8_t));
	  if(pkey == NULL) {
	       log_error("Not enough memory for privacy secret");
	       return -1;
	  }
	  if(compute_privacy_key(st, pkey,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 payloadlen*8, &order, 1) == -1)
	       return -1;
#ifdef DEBUG
	  {
	       int i;
	       char buffer[3000];
	       i = 3000;
	       bin2hex(buffer, &i, pkey, payloadlen);
	       printf("Encrypt key: %s\n", buffer );
	  }
#endif
	  packet_mask(payload, payloadlen, pkey);
	  return 0;
     case DH_G_2_DES_MD5:
     case DH_G_3_DES_MD5:
     case DH_G_5_DES_MD5:
#ifdef DEBUG
	  printf("[Packet encryption: DES]\n");
#endif
	  pkey = calloc(payloadlen + 8, sizeof(u_int8_t));
	  if(pkey == NULL) {
	       log_error("Not enough memory for privacy secret");
	       return -1;
	  }
	  /* XOR Mask */
	  if(compute_privacy_key(st, pkey,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 payloadlen*8, &order, 1) == -1)
	       return -1;
	  /* DES Key */
	  if(compute_privacy_key(st, pkey+payloadlen,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 64, &order, 1) == -1)
	       return -1;
#ifdef DEBUG
	  {
	       int i;
	       char buffer[3000];
	       i = 3000;
	       bin2hex(buffer, &i, pkey, payloadlen+8);
	       printf("Encrypt key: %s\n", buffer );
	  }
#endif
	  bcopy(pkey+payloadlen, &keys[0], 8);
	  des_set_odd_parity(&keys[0]);

	  /* Zero IV, we will mask the packet instead */
	  bzero(&keys[1], 8);

	  des_set_key(&keys[0], key1);

	  packet_mask(payload, payloadlen, pkey);

	  des_cbc_encrypt(input,input,payloadlen, key1,&keys[1], DES_ENCRYPT);
	  break;
     case DH_G_2_3DES_SHA1:
     case DH_G_3_3DES_SHA1:
     case DH_G_5_3DES_SHA1:
#ifdef DEBUG
	  printf("[Packet encryption: 3DES]\n");
#endif
	  pkey = calloc(payloadlen+24, sizeof(u_int8_t));
	  if(pkey == NULL) {
	       log_error("Not enough memory for owner privacy secret");
	       return -1;
	  }
	  /* XOR Mask */
	  if(compute_privacy_key(st, pkey,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 payloadlen*8, &order, 1) == -1)
	       return -1;
	  /* 3 DES Keys */
	  for (i=0; i<3; i++) {
	       if(compute_privacy_key(st, pkey+payloadlen + (i<<3),
				      payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				      64, &order, 1) == -1)
		    return -1;
	  }
#ifdef DEBUG
	  {
	       int i;
	       char buffer[3000];
	       i = 3000;
	       bin2hex(buffer, &i, pkey, payloadlen+24);
	       printf("Encrypt key: %s\n", buffer );
	  }
#endif
	  bcopy(pkey+payloadlen   , &keys[0], 8);
	  des_set_odd_parity(&keys[0]);
	  bcopy(pkey+payloadlen+8 , &keys[1], 8);
	  des_set_odd_parity(&keys[1]);
	  bcopy(pkey+payloadlen+16, &keys[2], 8);
	  des_set_odd_parity(&keys[2]);

	  /* Zero IV, we will make the packet instead */
	  bzero(&keys[3], 8);

	  des_set_key(&keys[0], key1);
	  des_set_key(&keys[1], key2);
	  des_set_key(&keys[2], key3);

	  packet_mask(payload, payloadlen, pkey);

	  des_ede3_cbc_encrypt(input, input, payloadlen,
			   key1, key2, key3, &keys[3], DES_ENCRYPT);
	  break;
     default:
          log_print("Unknown exchange scheme: %d\n",
                    *((u_int16_t *)st->scheme));
          return -1;
     }

     free(pkey);

     return 0;
}

int
packet_decrypt(struct stateob *st, u_int8_t *payload, u_int16_t *payloadlen)
{
     u_int8_t padlength, i;
     des_cblock keys[4], *input;
     des_key_schedule key1,key2,key3;
     u_int8_t *pkey;
     u_int16_t order = 0;

     input = (des_cblock *)payload;

     /* No encryption needed */
     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5:
     case DH_G_3_MD5:
     case DH_G_5_MD5:
#ifdef DEBUG
	  printf("[Packet decryption: None]\n");
#endif
	  pkey = calloc(*payloadlen, sizeof(u_int8_t));
	  if(pkey == NULL) {
	       log_error("Not enough memory for privacy secret");
	       return -1;
	  }
	  if(compute_privacy_key(st, pkey,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 *payloadlen*8, &order, 0) == -1)
	       return -1;
#ifdef DEBUG
	  {
	       int i = 3000;
	       char buffer[3000];
	       bin2hex(buffer, &i, pkey, *payloadlen);
	       printf("Decrypt key: %s\n", buffer );
	  }
#endif
	  packet_mask(payload, *payloadlen, pkey);
	  return 0;
     case DH_G_2_DES_MD5:
     case DH_G_3_DES_MD5:
     case DH_G_5_DES_MD5:
#ifdef DEBUG
	  printf("[Packet decryption: DES]\n");
#endif
	  pkey = calloc(*payloadlen+8, sizeof(u_int8_t));
	  if(pkey == NULL) {
	       log_error("Not enough memory for privacy secret");
	       return -1;
	  }
	  /* XOR Mask */
	  if(compute_privacy_key(st, pkey,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 *payloadlen*8, &order, 0) == -1)
	       return -1;
	  /* DES Key */
	  if(compute_privacy_key(st, pkey + *payloadlen,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 64, &order, 0) == -1)
	       return -1;
#ifdef DEBUG
	  {
	       int i = 3000;
	       char buffer[3000];
	       bin2hex(buffer, &i, pkey, *payloadlen + 8);
	       printf("Decrypt key: %s\n", buffer );
	  }
#endif
	  bcopy(pkey+*payloadlen, &keys[0], 8);
	  des_set_odd_parity(&keys[0]);

	  /* Zero IV, we will mask the packet instead */
	  bzero(&keys[1], 8);

	  des_set_key(&keys[0], key1);

	  des_cbc_encrypt(input,input,*payloadlen, key1,&keys[1], DES_DECRYPT);

	  packet_mask(payload, *payloadlen, pkey);
	  break;
     case DH_G_2_3DES_SHA1:
     case DH_G_3_3DES_SHA1:
     case DH_G_5_3DES_SHA1:
#ifdef DEBUG
	  printf("[Packet decryption: 3DES]\n");
#endif
	  pkey  = calloc(*payloadlen + 24, sizeof(u_int8_t));
	  if(pkey == NULL) {
	       log_error("Not enough memory for privacy secret");
	       return -1;
	  }
	  /* XOR Mask */
	  if(compute_privacy_key(st, pkey,
				 payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				 *payloadlen*8, &order, 0) == -1)
	       return -1;
	  /* 3 DES keys + 1 DES IV */
	  for (i=0; i<3; i++) {
	       if(compute_privacy_key(st, pkey + *payloadlen + (i<<3),
				      payload - 2*COOKIE_SIZE - 4 - SPI_SIZE,
				      64, &order, 0) == -1)
		    return -1;
	  }
#ifdef DEBUG
	  {
	       int i = 3000;
	       char buffer[3000];
	       bin2hex(buffer, &i, pkey, *payloadlen+24);
	       printf("Decrypt key: %s\n", buffer );
	  }
#endif
	  bcopy(pkey+*payloadlen   , &keys[0], 8);
	  des_set_odd_parity(&keys[0]);
	  bcopy(pkey+*payloadlen+8 , &keys[1], 8);
	  des_set_odd_parity(&keys[1]);
	  bcopy(pkey+*payloadlen+16, &keys[2], 8);
	  des_set_odd_parity(&keys[2]);

	  /* Zero IV, we will mask the packet instead */
	  bzero(&keys[3], 8);

	  des_set_key(&keys[0], key1);
	  des_set_key(&keys[1], key2);
	  des_set_key(&keys[2], key3);

	  des_ede3_cbc_encrypt(input, input, *payloadlen,
			   key1, key2, key3, &keys[3], DES_DECRYPT);

	  packet_mask(payload, *payloadlen, pkey);
	  break;
     default:
          log_error("Unknown exchange scheme: %d\n",
                    *((u_int16_t *)st->scheme));
          return -1;
     }

     padlength = *(payload+(*payloadlen)-1);

     /* Check the padding */

     if(padlength > 255 || padlength < 8)
	  return -1;

     *payloadlen = *payloadlen - padlength;

     for(i=1;i<=padlength;i++)
	  if(payload[*payloadlen+i-1] != i)
	       return -1;

     return 0;
}

@


1.5
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: photuris_packet_encrypt.c,v 1.4 2001/01/28 22:45:14 niklas Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: photuris_packet_encrypt.c,v 1.4 2001/01/28 22:45:14 niklas Exp $";
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 3
a39 3
#ifndef lint 
static char rcsid[] = "$OpenBSD: photuris_packet_encrypt.c,v 1.3 2000/12/15 02:50:39 provos Exp $";
#endif 
d42 2
a43 2
 
#include <stdio.h> 
d51 3
a53 3
#include "config.h" 
#include "packets.h" 
#include "state.h" 
d71 1
a71 1
packet_create_padding(struct stateob *st, u_int16_t size, u_int8_t *padd, 
d76 4
a79 4
     switch(ntohs(*((u_int16_t *)st->scheme))) { 
     case DH_G_2_MD5:    
     case DH_G_3_MD5:    
     case DH_G_5_MD5:    
d90 7
a96 7
 
     if(*rsize < padlength) 
          return -1; 
 
     /* Pad the rest of the payload */ 
     for(i=1;i<=padlength;i++) 
          padd[i-1] = i; 
d111 1
a111 1
     
d116 3
a118 3
     case DH_G_2_MD5:   
     case DH_G_3_MD5:   
     case DH_G_5_MD5:   
d127 1
a127 1
	  if(compute_privacy_key(st, pkey, 
d131 9
a139 9
#ifdef DEBUG 
	  {  
	       int i; 
	       char buffer[3000]; 
	       i = 3000; 
	       bin2hex(buffer, &i, pkey, payloadlen); 
	       printf("Encrypt key: %s\n", buffer ); 
	  } 
#endif 
d142 3
a144 3
     case DH_G_2_DES_MD5:   
     case DH_G_3_DES_MD5:   
     case DH_G_5_DES_MD5:   
d154 1
a154 1
	  if(compute_privacy_key(st, pkey, 
d159 1
a159 1
	  if(compute_privacy_key(st, pkey+payloadlen, 
d163 9
a171 9
#ifdef DEBUG 
	  {  
	       int i; 
	       char buffer[3000]; 
	       i = 3000; 
	       bin2hex(buffer, &i, pkey, payloadlen+8); 
	       printf("Encrypt key: %s\n", buffer ); 
	  } 
#endif 
d184 3
a186 3
     case DH_G_2_3DES_SHA1:   
     case DH_G_3_3DES_SHA1:   
     case DH_G_5_3DES_SHA1:   
d196 1
a196 1
	  if(compute_privacy_key(st, pkey, 
d202 1
a202 1
	       if(compute_privacy_key(st, pkey+payloadlen + (i<<3), 
d208 1
a208 1
	  { 
d235 4
a238 4
     default:   
          log_print("Unknown exchange scheme: %d\n",    
                    *((u_int16_t *)st->scheme));   
          return -1;   
d244 1
a244 1
}   
d259 3
a261 3
     case DH_G_2_MD5:   
     case DH_G_3_MD5:   
     case DH_G_5_MD5:   
d270 1
a270 1
	  if(compute_privacy_key(st, pkey, 
d274 8
a281 8
#ifdef DEBUG 
	  {  
	       int i = 3000; 
	       char buffer[3000]; 
	       bin2hex(buffer, &i, pkey, *payloadlen); 
	       printf("Decrypt key: %s\n", buffer ); 
	  } 
#endif 
d284 3
a286 3
     case DH_G_2_DES_MD5:   
     case DH_G_3_DES_MD5:   
     case DH_G_5_DES_MD5:   
d296 1
a296 1
	  if(compute_privacy_key(st, pkey, 
d301 1
a301 1
	  if(compute_privacy_key(st, pkey + *payloadlen, 
d305 8
a312 8
#ifdef DEBUG 
	  {  
	       int i = 3000; 
	       char buffer[3000]; 
	       bin2hex(buffer, &i, pkey, *payloadlen + 8); 
	       printf("Decrypt key: %s\n", buffer ); 
	  } 
#endif 
d325 3
a327 3
     case DH_G_2_3DES_SHA1:   
     case DH_G_3_3DES_SHA1:   
     case DH_G_5_3DES_SHA1:   
d337 1
a337 1
	  if(compute_privacy_key(st, pkey, 
d343 1
a343 1
	       if(compute_privacy_key(st, pkey + *payloadlen + (i<<3), 
d349 1
a349 1
	  { 
d375 4
a378 4
     default:   
          log_error("Unknown exchange scheme: %d\n",    
                    *((u_int16_t *)st->scheme));   
          return -1;   
d395 2
a396 2
}   
     
@


1.3
log
@update email address in copyright.
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: photuris_packet_encrypt.c,v 1.2 2000/12/11 21:21:18 provos Exp $";
@


1.2
log
@proper logging.
@
text
@d2 1
a2 1
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
d36 1
a36 1
static char rcsid[] = "$Id: photuris_packet_encrypt.c,v 1.1 1998/11/14 23:37:26 deraadt Exp $";
@


1.1
log
@move ipsec tools into .
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: photuris_packet_encrypt.c,v 1.2 1998/03/04 11:43:41 provos Exp $";
d55 1
a55 1
#include "errlog.h"
d122 1
a122 1
	       log_error(1, "Not enough memory for privacy secret");
d148 1
a148 1
	       log_error(1, "Not enough memory for privacy secret");
d190 1
a190 1
	       log_error(1, "Not enough memory for owner privacy secret");
d234 1
a234 1
          log_error(0, "Unknown exchange scheme: %d\n",    
d265 1
a265 1
	       log_error(1, "Not enough memory for privacy secret");
d290 1
a290 1
	       log_error(1, "Not enough memory for privacy secret");
d331 1
a331 1
	       log_error(1, "Not enough memory for privacy secret");
d374 1
a374 1
          log_error(0,"Unknown exchange scheme: %d\n",    
@

