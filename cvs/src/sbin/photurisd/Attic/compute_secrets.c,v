head	1.8;
access;
symbols
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2003.03.13.00.33.46;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2002.12.06.02.17.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.28.22.45.07;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.50.37;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.11.21.21.17;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.11.02.16.50;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.11.14.23.37.22;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@thought we had already deleted this
@
text
@/*	$OpenBSD: compute_secrets.c,v 1.7 2002/12/06 02:17:42 deraadt Exp $	*/

/*
 * Copyright 1997-2000 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * compute_secrets.c:
 * shared secret with diffie-hellman key exchange
 * cryptographic hashes for session keys
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: compute_secrets.c,v 1.7 2002/12/06 02:17:42 deraadt Exp $";
#endif

#define _SECRETS_C_

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ssl/bn.h>
#include <md5.h>
#include "state.h"
#include <sha1.h>
#include "config.h"
#include "identity.h"
#include "attributes.h"
#include "modulus.h"
#include "secrets.h"
#include "buffer.h"
#include "spi.h"
#include "exchange.h"
#include "scheme.h"
#include "log.h"

int privacykey(struct stateob *st, struct idxform *hash, u_int8_t *key,
	       u_int8_t *packet, u_int16_t bytes, u_int16_t *order, int owner);

int
compute_shared_secret(struct stateob *st,
		      u_int8_t **shared, size_t *sharedsize)
{
     struct moduli_cache *mod;
     int header, res;
     BIGNUM *tmp, *tex;
     BN_CTX *ctx;

     if ((mod = mod_find_modgen(st->modulus, st->generator)) == NULL) {
	  log_print("Can't find exchange information in cache in compute_shared_secret()");
	  return (-1);
     }

     /* Compute Diffie-Hellmann a^(xy) (mod n) */
     tex = BN_new();
     BN_varpre2bn(st->texchange, st->texchangesize, tex);

     tmp = BN_new();
     ctx = BN_CTX_new();
     BN_mod_exp(tmp, tex, mod->private_value, mod->modulus, ctx);
     BN_CTX_free(ctx);

     BN_clear_free(tex);

     *sharedsize = BUFFER_SIZE;
     res = BN_bn2varpre(tmp, buffer, sharedsize);
     BN_clear_free(tmp);

     if (res == -1)
          return -1;

     /* The shared secret is not used with the size part */
     if (buffer[0] == 255)
	  header = 4;
     else
	  header = 2;

     *sharedsize -= header;

     if ((*shared = calloc(*sharedsize,sizeof(u_int8_t))) == NULL) {
          log_print("Not enough memory for shared secret in compute_shared_secret()");
          return (-1);
     }
     bcopy(buffer + header, *shared, *sharedsize);

     return (0);
}

/*
 * Generate session keys for all attributes in given SPI.
 */

int
make_session_keys(struct stateob *st, struct spiob *spi)
{
     u_int8_t *p, *attributes, **secret;
     u_int16_t attribsize, *secretsize;
     u_int16_t i, count = 0;
     int bits;

     attributes = spi->attributes;
     attribsize = spi->attribsize;
     secret = &(spi->sessionkey);
     secretsize = &(spi->sessionkeysize);

     if (*secret != NULL)
	  return 0;           /* Already calculated */

     p = attributes;
     for (i = 0; i<attribsize; i += p[i+1] + 2) {
	  if (p[i] != AT_AH_ATTRIB && p[i] != AT_ESP_ATTRIB) {
	       bits = get_session_key_length(p+i);
	       if (bits == -1) {
		    log_print("Invalid attribute choice for SPI in make_session_keys()");
		    return -1;
	       }
	       count += bits & 7 ? (bits >> 3) + 1 : bits >> 3;
	  }
     }
     if ((*secret = calloc(count, sizeof(u_int8_t))) == NULL) {
	  log_error("calloc() in make_session_keys()");
	  return -1;
     }
     *secretsize = count;

     count = 0;
     p = *secret;
     for (i = 0; i<attribsize; i += attributes[i+1] + 2) {
	  if (attributes[i] != AT_AH_ATTRIB &&
	      attributes[i] != AT_ESP_ATTRIB) {
	       bits = compute_session_key(st, p, attributes+i,
					  spi->flags & SPI_OWNER,
					  &count);
	       if (bits == -1)
		    return -1;
	       if (bits > 0) {
#ifdef DEBUG
		    {
			 int d = BUFFER_SIZE;
			 printf("%s session key for AT %d: ",
				spi->flags & SPI_OWNER ?
				"Owner" : "User", (int)attributes[i]);
			 bin2hex(buffer, &d, p,
				 bits & 7 ? (bits >> 3) + 1 : bits >> 3);
			 printf("0x%s\n", buffer);
		    }
#endif /* DEBUG */
		
		    p += bits & 7 ? (bits >> 3) + 1 : bits >> 3;
	       }
	  }
     }

     return 0;
}

/*
 * Return length of requried session key in bits.
 * DES would be 64 bits.
 */

int
get_session_key_length(u_int8_t *attribute)
{
     attrib_t *ob;

     if ((ob = getattrib(*attribute)) == NULL) {
	  log_print("Unknown attribute %d in get_session_key_length()",
		    *attribute);
	  return -1;
     }

     return ob->klen << 3;
}

/*
 * Compute session keys for the attributes in the security association.
 * owner determines the direction of the spi session key.
 * order is the amount of bits we already used for other session keys.
 */

int
compute_session_key(struct stateob *st, u_int8_t *key,
		    u_int8_t *attribute, int owner,
		    u_int16_t *order)
{
     struct idxform *hash;
     u_int16_t size, i, n;
     u_int8_t digest[HASH_MAX];
     int bits;

     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5:
     case DH_G_3_MD5:
     case DH_G_2_DES_MD5:
     case DH_G_5_MD5:
     case DH_G_3_DES_MD5:
     case DH_G_5_DES_MD5:
     case DH_G_VAR_MD5:
     case DH_G_VAR_DES_MD5:
	  hash = get_hash(HASH_MD5);
	  break;
     case DH_G_2_3DES_SHA1:
     case DH_G_3_3DES_SHA1:
     case DH_G_5_3DES_SHA1:
     case DH_G_VAR_3DES_SHA1:
	  hash = get_hash(HASH_SHA1);
	  break;
     default:
	  log_print("Unknown scheme %d in compute_session_key()",
		    ntohs(*((u_int16_t *)st->scheme)));
	  return -1;
     }	
	

     if ((bits = get_session_key_length(attribute)) == -1)
	  return -1;
     if (bits == 0)
	  return 0;

     size = bits >> 3;
     if(bits & 0x7)
	  size++;

     /* As many shared secrets we used already */
     n = *order;

     hash->Init(hash->ctx);
     hash->Update(hash->ctx, st->icookie, COOKIE_SIZE);
     hash->Update(hash->ctx, st->rcookie, COOKIE_SIZE);
     if(owner) { /* Session key for Owner SPI */
	  hash->Update(hash->ctx,st->oSPIsecret,st->oSPIsecretsize);
	  hash->Update(hash->ctx,st->uSPIsecret,st->uSPIsecretsize);
     } else {    /* Session key for User SPI */
	  hash->Update(hash->ctx,st->uSPIsecret,st->uSPIsecretsize);
	  hash->Update(hash->ctx,st->oSPIsecret,st->oSPIsecretsize);
     }

     /* Message Verification field */
     hash->Update(hash->ctx, st->verification, st->versize);

     for (i=0; i<n; i++)
	  hash->Update(hash->ctx, st->shared, st->sharedsize);

     do {
	  bcopy(hash->ctx, hash->ctx2, hash->ctxsize);
	  hash->Update(hash->ctx2,st->shared, st->sharedsize);
	  bcopy(hash->ctx2, hash->ctx, hash->ctxsize);

	  hash->Final(digest, hash->ctx2);
	  /* One iteration more */
	  n++;

	  bcopy(digest, key, size>hash->hashsize ? hash->hashsize : size);
	  key += size>hash->hashsize ? hash->hashsize : size;

	  /* Unsigned integer arithmetic */
	  size -= size>hash->hashsize ? hash->hashsize : size;
     } while(size > 0);

     *order = n;

     return bits;
}

/*
 * Initializes the hash contexts for privacy key computation.
 */

int
init_privacy_key(struct stateob *st, int owner)
{
     void **ctx;
     struct idxform *hash;
     u_int8_t *first, *second;
     u_int16_t firstsize, secondsize;

     if (owner) {
	  ctx = &st->oSPIprivacyctx;
	  first = st->exchangevalue;
	  firstsize = st->exchangesize;
	  second = st->texchange;
	  secondsize = st->texchangesize;
     } else {
	  ctx = &st->uSPIprivacyctx;
	  first = st->texchange;
	  firstsize = st->texchangesize;
	  second = st->exchangevalue;
	  secondsize = st->exchangesize;
     }

     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5:
     case DH_G_3_MD5:
     case DH_G_5_MD5:
     case DH_G_2_DES_MD5:
     case DH_G_3_DES_MD5:
     case DH_G_5_DES_MD5:
	  hash = get_hash(HASH_MD5);
	  break;
     case DH_G_2_3DES_SHA1:
     case DH_G_3_3DES_SHA1:
     case DH_G_5_3DES_SHA1:
	  hash = get_hash(HASH_SHA1);
	  break;
     default:
          log_print("Unknown exchange scheme in init_privacy_key()");
          return -1;
     }

     if (hash == NULL)
	  return -1;

     if (*ctx != NULL)
	  free(*ctx);

     if ((*ctx = calloc(hash->ctxsize, sizeof(char))) == NULL) {
	  log_error("calloc() in init_privacy_key()");
	  return -1;
     }
     hash->Init(*ctx);
     hash->Update(*ctx, first, firstsize);
     hash->Update(*ctx, second, secondsize);
     return 1;
}

/*
 * order gives the number of iterations already done for keys
 */

int
compute_privacy_key(struct stateob *st, u_int8_t *key, u_int8_t *packet,
		    u_int16_t bits, u_int16_t *order, int owner)
{
     u_int16_t size;
     struct idxform *hash;

     size = bits >> 3;
     if(bits & 0x7)
          size++;

     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5:
     case DH_G_3_MD5:
     case DH_G_5_MD5:
     case DH_G_2_DES_MD5:
     case DH_G_3_DES_MD5:
     case DH_G_5_DES_MD5:
	  hash = get_hash(HASH_MD5);
	  break;
     case DH_G_2_3DES_SHA1:
     case DH_G_3_3DES_SHA1:
     case DH_G_5_3DES_SHA1:
	  hash = get_hash(HASH_SHA1);
	  break;
     default:
          log_print("Unknown exchange scheme in compute_privacy_key()");
          return -1;
     }

     if (hash == NULL)
	  return -1;

     return privacykey(st, hash, key, packet, size, order, owner);
}


int
privacykey(struct stateob *st, struct idxform *hash,
	   u_int8_t *key, u_int8_t *packet,
	   u_int16_t bytes, u_int16_t *order, int owner)
{
     u_int16_t i, n;
     u_int8_t digest[HASH_MAX];

     /* SPIprivacyctx contains the hashed exchangevalues */
     bcopy(owner ? st->oSPIprivacyctx : st->uSPIprivacyctx,
	   hash->ctx2, hash->ctxsize);
	
     hash->Update(hash->ctx2, packet, 2*COOKIE_SIZE + 4 + SPI_SIZE);

     /* As many shared secrets we used already */
     n = *order;
     for(i=0; i<n; i++)
	  hash->Update(hash->ctx2, st->shared, st->sharedsize);

     do {
	  bcopy(hash->ctx2, hash->ctx, hash->ctxsize);
	  hash->Update(hash->ctx, st->shared, st->sharedsize);
	  bcopy(hash->ctx, hash->ctx2, hash->ctxsize);
	
	  hash->Final(digest, hash->ctx);
          bcopy(digest, key, bytes>hash->hashsize ? hash->hashsize : bytes);
	  key += bytes>hash->hashsize ? hash->hashsize : bytes;

	  /* Unsigned integer arithmetic */
          bytes -= bytes>hash->hashsize ? hash->hashsize : bytes;
	
	  /* Increment the times we called Final */
	  i++;
     } while(bytes > 0);

     *order = i;
     return 0;
}

@


1.7
log
@unkown; torh@@bogus.net
@
text
@d1 1
a1 1
/*	$OpenBSD: compute_secrets.c,v 1.6 2002/06/09 08:13:08 todd Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: compute_secrets.c,v 1.6 2002/06/09 08:13:08 todd Exp $";
@


1.6
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: compute_secrets.c,v 1.5 2001/01/28 22:45:07 niklas Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: compute_secrets.c,v 1.5 2001/01/28 22:45:07 niklas Exp $";
d239 1
a239 1
	  log_print("Unkown scheme %d in compute_session_key()",
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 3
a40 3
#ifndef lint 
static char rcsid[] = "$OpenBSD: compute_secrets.c,v 1.4 2000/12/15 02:50:37 provos Exp $"; 
#endif 
d48 3
a50 3
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <arpa/inet.h> 
d66 1
a66 1
int privacykey(struct stateob *st, struct idxform *hash, u_int8_t *key, 
d70 1
a70 1
compute_shared_secret(struct stateob *st, 
d158 1
a158 1
	  if (attributes[i] != AT_AH_ATTRIB && 
d160 2
a161 2
	       bits = compute_session_key(st, p, attributes+i, 
					  spi->flags & SPI_OWNER, 
d167 1
a167 1
		    { 
d169 2
a170 2
			 printf("%s session key for AT %d: ", 
				spi->flags & SPI_OWNER ? 
d172 1
a172 1
			 bin2hex(buffer, &d, p, 
d177 1
a177 1
		    
d182 1
a182 1
     
d187 1
a187 1
 * Return length of requried session key in bits. 
d197 1
a197 1
	  log_print("Unknown attribute %d in get_session_key_length()", 
d212 1
a212 1
compute_session_key(struct stateob *st, u_int8_t *key, 
d222 8
a229 8
     case DH_G_2_MD5: 
     case DH_G_3_MD5:  
     case DH_G_2_DES_MD5:  
     case DH_G_5_MD5:  
     case DH_G_3_DES_MD5:  
     case DH_G_5_DES_MD5:  
     case DH_G_VAR_MD5: 
     case DH_G_VAR_DES_MD5: 
d232 2
a233 2
     case DH_G_2_3DES_SHA1:  
     case DH_G_3_3DES_SHA1:  
d235 1
a235 1
     case DH_G_VAR_3DES_SHA1: 
d242 2
a243 2
     }	  
	  
d264 2
a265 2
	  hash->Update(hash->ctx,st->uSPIsecret,st->uSPIsecretsize); 
	  hash->Update(hash->ctx,st->oSPIsecret,st->oSPIsecretsize); 
d288 2
a289 2
     } while(size > 0);  
     
d321 7
a327 7
     switch(ntohs(*((u_int16_t *)st->scheme))) {  
     case DH_G_2_MD5:  
     case DH_G_3_MD5:  
     case DH_G_5_MD5:  
     case DH_G_2_DES_MD5:  
     case DH_G_3_DES_MD5:  
     case DH_G_5_DES_MD5: 
d330 3
a332 3
     case DH_G_2_3DES_SHA1:  
     case DH_G_3_3DES_SHA1:  
     case DH_G_5_3DES_SHA1:  
d335 1
a335 1
     default:  
d337 2
a338 2
          return -1;  
     }  
d367 11
a377 11
     size = bits >> 3; 
     if(bits & 0x7) 
          size++; 

     switch(ntohs(*((u_int16_t *)st->scheme))) {  
     case DH_G_2_MD5:  
     case DH_G_3_MD5:  
     case DH_G_5_MD5:  
     case DH_G_2_DES_MD5:  
     case DH_G_3_DES_MD5:  
     case DH_G_5_DES_MD5:  
d380 3
a382 3
     case DH_G_2_3DES_SHA1:  
     case DH_G_3_3DES_SHA1:  
     case DH_G_5_3DES_SHA1:  
d385 1
a385 1
     default:  
d387 2
a388 2
          return -1;  
     }  
d398 3
a400 3
privacykey(struct stateob *st, struct idxform *hash, 
	   u_int8_t *key, u_int8_t *packet, 
	   u_int16_t bytes, u_int16_t *order, int owner) 
d404 1
a404 1
     
d406 1
a406 1
     bcopy(owner ? st->oSPIprivacyctx : st->uSPIprivacyctx, 
d408 4
a411 4
	  
     hash->Update(hash->ctx2, packet, 2*COOKIE_SIZE + 4 + SPI_SIZE); 
     
     /* As many shared secrets we used already */ 
d413 2
a414 2
     for(i=0; i<n; i++) 
	  hash->Update(hash->ctx2, st->shared, st->sharedsize); 
d420 1
a420 1
	  
d422 1
a422 1
          bcopy(digest, key, bytes>hash->hashsize ? hash->hashsize : bytes); 
d424 4
a427 4
 
	  /* Unsigned integer arithmetic */ 
          bytes -= bytes>hash->hashsize ? hash->hashsize : bytes; 
	  
d430 1
a430 1
     } while(bytes > 0);   
@


1.4
log
@update email address in copyright.
@
text
@d1 2
d39 1
a39 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.3 2000/12/11 21:21:17 provos Exp $"; 
@


1.3
log
@proper logging.
@
text
@d2 1
a2 1
 * Copyright 1997,1998 Niels Provos <provos@@physnet.uni-hamburg.de>
d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.2 2000/12/11 02:16:50 provos Exp $"; 
@


1.2
log
@make it use bignum.
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.1 1998/11/14 23:37:22 deraadt Exp $"; 
d62 1
a62 1
#include "errlog.h"
d77 1
a77 1
	  log_error(0, "Can't find exchange information in cache in compute_shared_secret()");
d108 1
a108 1
          log_error(0, "Not enough memory for shared secret in compute_shared_secret()");
d141 1
a141 1
		    log_error(0, "Invalid attribute choice for SPI in make_session_keys()");
d148 1
a148 1
	  log_error(1, "calloc() in make_session_keys()");
d195 1
a195 1
	  log_error(0, "Unknown attribute %d in get_session_key_length()", 
d237 1
a237 1
	  log_error(0, "Unkown scheme %d in compute_session_key()",
d334 1
a334 1
          log_error(0, "Unknown exchange scheme in init_privacy_key()");
d345 1
a345 1
	  log_error(1, "calloc() in init_privacy_key()");
d384 1
a384 1
          log_error(0, "Unknown exchange scheme in compute_privacy_key()");
@


1.1
log
@move ipsec tools into .
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.6 1998/06/30 16:58:45 provos Exp $"; 
d49 1
a49 1
#include <gmp.h>
d66 1
d69 1
a69 1
		      u_int8_t **shared, u_int16_t *sharedsize)
d72 3
a74 3
     int header;

     mpz_t tmp, bits, tex;
d76 1
a76 4
     mpz_init(tmp);
     mpz_init(bits);

     if((mod=mod_find_modgen(st->modulus, st->generator)) == NULL) {
d78 1
a78 1
	  return -1;
d82 2
d85 4
a88 2
     mpz_init_set_varpre(tex, st->texchange);
     mpz_powm(tmp, tex, mod->private_value, mod->modulus);
d90 1
a90 1
     mpz_clear(tex);
d92 3
a94 1
     varpre_get_number_bits(bits, scheme_get_mod(st->scheme));
d96 1
a96 2
     *sharedsize = BUFFER_SIZE;
     if(mpz_to_varpre(buffer, sharedsize, tmp, bits) == -1)   
a97 2
     mpz_clear(bits);
     mpz_clear(tmp);
d100 1
a100 3
     if (buffer[0] == 255 && buffer[1] == 255)
	  header = 8;
     else if (buffer[0] == 255)
d107 1
a107 1
     if((*shared = calloc(*sharedsize,sizeof(u_int8_t))) == NULL) {
d109 1
a109 1
          return -1;
d111 3
a113 2
     bcopy(buffer+header, *shared, *sharedsize);
     return 0;
@

