head	1.64;
access;
symbols
	OPENBSD_6_1:1.64.0.2
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11;
locks; strict;
comment	@ * @;


1.64
date	2017.03.28.16.56.39;	author reyk;	state Exp;
branches;
next	1.63;
commitid	hsmTeumOx0uadFGG;

1.63
date	2017.03.27.10.43.53;	author mikeb;	state Exp;
branches;
next	1.62;
commitid	3tQzvpAXTrEiRD3X;

1.62
date	2017.03.27.10.06.41;	author reyk;	state Exp;
branches;
next	1.61;
commitid	37oqp7mUEkdGuEb4;

1.61
date	2017.01.20.13.56.51;	author mikeb;	state Exp;
branches;
next	1.60;
commitid	pQN59BQ5IRfORbdG;

1.60
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.59;
commitid	uzjOUwLRoN7KbcZI;

1.59
date	2017.01.04.12.31.01;	author mikeb;	state Exp;
branches;
next	1.58;
commitid	TO4j3BY30CCpOBrn;

1.58
date	2016.09.03.09.20.07;	author vgross;	state Exp;
branches;
next	1.57;
commitid	Bw4TFBm7VKjvvnRJ;

1.57
date	2016.08.06.07.08.59;	author pascal;	state Exp;
branches;
next	1.56;
commitid	GNjWeIBBlWIjsK91;

1.56
date	2016.07.20.12.31.00;	author reyk;	state Exp;
branches
	1.56.2.1;
next	1.55;
commitid	4wa6T6DTLlsAy4OP;

1.55
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.54;
commitid	AL6SnrmnHkmPOpjv;

1.54
date	2015.12.09.21.41.49;	author naddy;	state Exp;
branches;
next	1.53;
commitid	CLwtYUTkBZ3FXV1w;

1.53
date	2015.11.04.12.40.49;	author mikeb;	state Exp;
branches;
next	1.52;
commitid	B4ca1ecJQ735kuxU;

1.52
date	2015.10.31.19.28.19;	author naddy;	state Exp;
branches;
next	1.51;
commitid	XYBkvC3PYNaA61fw;

1.51
date	2015.10.02.16.56.34;	author reyk;	state Exp;
branches;
next	1.50;
commitid	C6bHPhgpJo8TcskZ;

1.50
date	2015.08.21.11.59.28;	author reyk;	state Exp;
branches;
next	1.49;
commitid	CNs9dXqQUQ09vB19;

1.49
date	2015.08.19.14.12.43;	author reyk;	state Exp;
branches;
next	1.48;
commitid	AVPSAC8CcLDWTPgE;

1.48
date	2015.07.03.17.46.52;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	9SQ1m3rWI3r3MweN;

1.47
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.46;
commitid	GouatFiJVxwlAVIQ;

1.46
date	2015.02.08.04.50.32;	author reyk;	state Exp;
branches;
next	1.45;
commitid	jVCsun3nRn9HXgv1;

1.45
date	2015.01.19.14.42.42;	author mikeb;	state Exp;
branches;
next	1.44;
commitid	6zq5j7t9YeU29dry;

1.44
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	Uu5nFG3wCl0LACBb;

1.43
date	2015.01.12.11.24.58;	author mikeb;	state Exp;
branches;
next	1.42;
commitid	YXMcG9DTnOXFylDd;

1.42
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.41;
commitid	3Z7yItGpFsmshk0c;

1.41
date	2014.11.14.03.22.47;	author doug;	state Exp;
branches;
next	1.40;
commitid	qNkdsCnukYGH5AxP;

1.40
date	2014.08.27.10.28.57;	author reyk;	state Exp;
branches;
next	1.39;
commitid	kDDmioKYpauZKbXI;

1.39
date	2014.08.25.14.36.10;	author reyk;	state Exp;
branches;
next	1.38;
commitid	GmUlpWRlEvPnJtRg;

1.38
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2014.02.17.15.07.23;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2014.02.14.09.00.03;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.28.20.21.17;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.25.13.12.23;	author benno;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.25.15.01.56;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.25;

1.25
date	2012.06.29.15.05.49;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.08.08.53.14;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2012.03.24.00.40.25;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.18.08.45.43;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.17.17.16.43;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.23.16.39.38;	author mikeb;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.22.16.40.06;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.21.14.28.58;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.17.16.43.45;	author ckuethe;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.23.11.42.36;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.09.13.06.46;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.22.17.16.45;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.01.02.15.08;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.26.19.48.04;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.26.18.32.34;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.23.11.26.13;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.15.00.41.04;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.18.39.04;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.14.17.48;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;

1.56.2.1
date	2016.09.17.20.36.34;	author benno;	state Exp;
branches;
next	;
commitid	DmY5B1e5lZeyZmO7;


desc
@@


1.64
log
@Remove RSA from the list of keywords, lookup is now done in a table.

This lets us configure explicit old-style RSA again.

OK mikeb@@
@
text
@/*	$OpenBSD: parse.y,v 1.63 2017/03/27 10:43:53 mikeb Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004, 2005 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <openssl/pem.h>
#include <openssl/evp.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <netdb.h>
#include <event.h>

#include "iked.h"
#include "ikev2.h"
#include "eap.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file;
EVP_PKEY	*wrap_pubkey(FILE *);
EVP_PKEY	*find_pubkey(const char *);
int		 set_policy(char *, int, struct iked_policy *);
int		 set_policy_auth_method(const char *, EVP_PKEY *,
		     struct iked_policy *);
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

#define KEYSIZE_LIMIT	1024

static struct iked	*env = NULL;
static int		 debug = 0;
static int		 rules = 0;
static int		 passive = 0;
static int		 decouple = 0;
static char		*ocsp_url = NULL;

struct ipsec_xf {
	const char	*name;
	unsigned int	 id;
	unsigned int	 length;
	unsigned int	 keylength;
	unsigned int	 nonce;
	unsigned int	 noauth;
};

struct ipsec_transforms {
	const struct ipsec_xf *authxf;
	const struct ipsec_xf *prfxf;
	const struct ipsec_xf *encxf;
	const struct ipsec_xf *groupxf;
	const struct ipsec_xf *esnxf;
};

struct ipsec_mode {
	struct ipsec_transforms	*xfs;
	uint8_t			 ike_exch;
};

struct iked_transform ikev2_default_ike_transforms[] = {
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_AES_CBC, 256 },
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_AES_CBC, 192 },
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_AES_CBC, 128 },
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_3DES },
	{ IKEV2_XFORMTYPE_PRF,	IKEV2_XFORMPRF_HMAC_SHA2_256 },
	{ IKEV2_XFORMTYPE_PRF,	IKEV2_XFORMPRF_HMAC_SHA1 },
	{ IKEV2_XFORMTYPE_INTEGR, IKEV2_XFORMAUTH_HMAC_SHA2_256_128 },
	{ IKEV2_XFORMTYPE_INTEGR, IKEV2_XFORMAUTH_HMAC_SHA1_96 },
	{ IKEV2_XFORMTYPE_DH,	IKEV2_XFORMDH_MODP_2048 },
	{ IKEV2_XFORMTYPE_DH,	IKEV2_XFORMDH_MODP_1536 },
	{ IKEV2_XFORMTYPE_DH,	IKEV2_XFORMDH_MODP_1024 },
	{ 0 }
};
size_t ikev2_default_nike_transforms = ((sizeof(ikev2_default_ike_transforms) /
    sizeof(ikev2_default_ike_transforms[0])) - 1);

struct iked_transform ikev2_default_esp_transforms[] = {
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_AES_CBC, 256 },
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_AES_CBC, 192 },
	{ IKEV2_XFORMTYPE_ENCR, IKEV2_XFORMENCR_AES_CBC, 128 },
	{ IKEV2_XFORMTYPE_INTEGR, IKEV2_XFORMAUTH_HMAC_SHA2_256_128 },
	{ IKEV2_XFORMTYPE_INTEGR, IKEV2_XFORMAUTH_HMAC_SHA1_96 },
	{ IKEV2_XFORMTYPE_ESN,	IKEV2_XFORMESN_ESN },
	{ IKEV2_XFORMTYPE_ESN,	IKEV2_XFORMESN_NONE },
	{ 0 }
};
size_t ikev2_default_nesp_transforms = ((sizeof(ikev2_default_esp_transforms) /
    sizeof(ikev2_default_esp_transforms[0])) - 1);

const struct ipsec_xf authxfs[] = {
	{ "hmac-md5",		IKEV2_XFORMAUTH_HMAC_MD5_96,		16 },
	{ "hmac-sha1",		IKEV2_XFORMAUTH_HMAC_SHA1_96,		20 },
	{ "hmac-sha2-256",	IKEV2_XFORMAUTH_HMAC_SHA2_256_128,	32 },
	{ "hmac-sha2-384",	IKEV2_XFORMAUTH_HMAC_SHA2_384_192,	48 },
	{ "hmac-sha2-512",	IKEV2_XFORMAUTH_HMAC_SHA2_512_256,	64 },
	{ NULL }
};

const struct ipsec_xf prfxfs[] = {
	{ "hmac-md5",		IKEV2_XFORMPRF_HMAC_MD5,	16 },
	{ "hmac-sha1",		IKEV2_XFORMPRF_HMAC_SHA1,	20 },
	{ "hmac-sha2-256",	IKEV2_XFORMPRF_HMAC_SHA2_256,	32 },
	{ "hmac-sha2-384",	IKEV2_XFORMPRF_HMAC_SHA2_384,	48 },
	{ "hmac-sha2-512",	IKEV2_XFORMPRF_HMAC_SHA2_512,	64 },
	{ NULL }
};

const struct ipsec_xf *encxfs = NULL;

const struct ipsec_xf ikeencxfs[] = {
	{ "3des",		IKEV2_XFORMENCR_3DES,		24 },
	{ "3des-cbc",		IKEV2_XFORMENCR_3DES,		24 },
	{ "aes-128",		IKEV2_XFORMENCR_AES_CBC,	16, 16 },
	{ "aes-192",		IKEV2_XFORMENCR_AES_CBC,	24, 24 },
	{ "aes-256",		IKEV2_XFORMENCR_AES_CBC,	32, 32 },
	{ NULL }
};

const struct ipsec_xf ipsecencxfs[] = {
	{ "3des",		IKEV2_XFORMENCR_3DES,		24 },
	{ "3des-cbc",		IKEV2_XFORMENCR_3DES,		24 },
	{ "aes-128",		IKEV2_XFORMENCR_AES_CBC,	16, 16 },
	{ "aes-192",		IKEV2_XFORMENCR_AES_CBC,	24, 24 },
	{ "aes-256",		IKEV2_XFORMENCR_AES_CBC,	32, 32 },
	{ "aes-128-ctr",	IKEV2_XFORMENCR_AES_CTR,	16, 16, 4 },
	{ "aes-192-ctr",	IKEV2_XFORMENCR_AES_CTR,	24, 24, 4 },
	{ "aes-256-ctr",	IKEV2_XFORMENCR_AES_CTR,	32, 32, 4 },
	{ "aes-128-gcm",	IKEV2_XFORMENCR_AES_GCM_16,	16, 16, 4, 1 },
	{ "aes-192-gcm",	IKEV2_XFORMENCR_AES_GCM_16,	24, 24, 4, 1 },
	{ "aes-256-gcm",	IKEV2_XFORMENCR_AES_GCM_16,	32, 32, 4, 1 },
	{ "aes-128-gmac",	IKEV2_XFORMENCR_NULL_AES_GMAC,	16, 16, 4, 1 },
	{ "aes-192-gmac",	IKEV2_XFORMENCR_NULL_AES_GMAC,	24, 24, 4, 1 },
	{ "aes-256-gmac",	IKEV2_XFORMENCR_NULL_AES_GMAC,	32, 32, 4, 1 },
	{ "blowfish",		IKEV2_XFORMENCR_BLOWFISH,	20, 20 },
	{ "cast",		IKEV2_XFORMENCR_CAST,		16, 16 },
	{ "chacha20-poly1305",	IKEV2_XFORMENCR_CHACHA20_POLY1305,
								32, 32, 4, 1 },
	{ "null",		IKEV2_XFORMENCR_NULL,		0, 0 },
	{ NULL }
};

const struct ipsec_xf groupxfs[] = {
	{ "modp768",		IKEV2_XFORMDH_MODP_768 },
	{ "grp1",		IKEV2_XFORMDH_MODP_768 },
	{ "modp1024",		IKEV2_XFORMDH_MODP_1024 },
	{ "grp2",		IKEV2_XFORMDH_MODP_1024 },
	{ "ec2n155",		IKEV2_XFORMDH_EC2N_155 },
	{ "grp3",		IKEV2_XFORMDH_EC2N_155 },
	{ "ec2n185",		IKEV2_XFORMDH_EC2N_185 },
	{ "grp4",		IKEV2_XFORMDH_EC2N_185 },
	{ "modp1536",		IKEV2_XFORMDH_MODP_1536 },
	{ "grp5",		IKEV2_XFORMDH_MODP_1536 },
	{ "modp2048",		IKEV2_XFORMDH_MODP_2048 },
	{ "grp14",		IKEV2_XFORMDH_MODP_2048 },
	{ "modp3072",		IKEV2_XFORMDH_MODP_3072 },
	{ "grp15",		IKEV2_XFORMDH_MODP_3072 },
	{ "modp4096",		IKEV2_XFORMDH_MODP_4096 },
	{ "grp16",		IKEV2_XFORMDH_MODP_4096 },
	{ "modp6144",		IKEV2_XFORMDH_MODP_6144 },
	{ "grp17",		IKEV2_XFORMDH_MODP_6144 },
	{ "modp8192",		IKEV2_XFORMDH_MODP_8192 },
	{ "grp18",		IKEV2_XFORMDH_MODP_8192 },
	{ "ecp256",		IKEV2_XFORMDH_ECP_256 },
	{ "grp19",		IKEV2_XFORMDH_ECP_256 },
	{ "ecp384",		IKEV2_XFORMDH_ECP_384 },
	{ "grp20",		IKEV2_XFORMDH_ECP_384 },
	{ "ecp521",		IKEV2_XFORMDH_ECP_521 },
	{ "grp21",		IKEV2_XFORMDH_ECP_521 },
	{ "ecp192",		IKEV2_XFORMDH_ECP_192 },
	{ "grp25",		IKEV2_XFORMDH_ECP_192 },
	{ "ecp224",		IKEV2_XFORMDH_ECP_224 },
	{ "grp26",		IKEV2_XFORMDH_ECP_224 },
	{ "brainpool224",	IKEV2_XFORMDH_BRAINPOOL_P224R1 },
	{ "grp27",		IKEV2_XFORMDH_BRAINPOOL_P224R1 },
	{ "brainpool256",	IKEV2_XFORMDH_BRAINPOOL_P256R1 },
	{ "grp28",		IKEV2_XFORMDH_BRAINPOOL_P256R1 },
	{ "brainpool384",	IKEV2_XFORMDH_BRAINPOOL_P384R1 },
	{ "grp29",		IKEV2_XFORMDH_BRAINPOOL_P384R1 },
	{ "brainpool512",	IKEV2_XFORMDH_BRAINPOOL_P512R1 },
	{ "grp30",		IKEV2_XFORMDH_BRAINPOOL_P512R1 },
	{ "curve25519",		IKEV2_XFORMDH_X_CURVE25519 },
	{ NULL }
};

const struct ipsec_xf methodxfs[] = {
	{ "none",		IKEV2_AUTH_NONE },
	{ "rsa",		IKEV2_AUTH_RSA_SIG },
	{ "ecdsa256",		IKEV2_AUTH_ECDSA_256 },
	{ "ecdsa384",		IKEV2_AUTH_ECDSA_384 },
	{ "ecdsa521",		IKEV2_AUTH_ECDSA_521 },
	{ "rfc7427",		IKEV2_AUTH_SIG },
	{ "signature",		IKEV2_AUTH_SIG_ANY },
	{ NULL }
};

const struct ipsec_xf saxfs[] = {
	{ "esp",		IKEV2_SAPROTO_ESP },
	{ "ah",			IKEV2_SAPROTO_AH },
	{ NULL }
};

const struct ipsec_xf cpxfs[] = {
	{ "address", IKEV2_CFG_INTERNAL_IP4_ADDRESS,		AF_INET },
	{ "netmask", IKEV2_CFG_INTERNAL_IP4_NETMASK,		AF_INET },
	{ "name-server", IKEV2_CFG_INTERNAL_IP4_DNS,		AF_INET },
	{ "netbios-server", IKEV2_CFG_INTERNAL_IP4_NBNS,	AF_INET },
	{ "dhcp-server", IKEV2_CFG_INTERNAL_IP4_DHCP,		AF_INET },
	{ "address", IKEV2_CFG_INTERNAL_IP6_ADDRESS,		AF_INET6 },
	{ "name-server", IKEV2_CFG_INTERNAL_IP6_DNS,		AF_INET6 },
	{ "netbios-server", IKEV2_CFG_INTERNAL_IP6_NBNS,	AF_INET6 },
	{ "dhcp-server", IKEV2_CFG_INTERNAL_IP6_DHCP,		AF_INET6 },
	{ "protected-subnet", IKEV2_CFG_INTERNAL_IP4_SUBNET,	AF_INET },
	{ "protected-subnet", IKEV2_CFG_INTERNAL_IP6_SUBNET,	AF_INET6 },
	{ "access-server", IKEV2_CFG_INTERNAL_IP4_SERVER,	AF_INET },
	{ "access-server", IKEV2_CFG_INTERNAL_IP6_SERVER,	AF_INET6 },
	{ NULL }
};

const struct iked_lifetime deflifetime = {
	IKED_LIFETIME_BYTES,
	IKED_LIFETIME_SECONDS
};

struct ipsec_addr_wrap {
	struct sockaddr_storage	 address;
	uint8_t			 mask;
	int			 netaddress;
	sa_family_t		 af;
	unsigned int		 type;
	unsigned int		 action;
	char			*name;
	struct ipsec_addr_wrap	*next;
	struct ipsec_addr_wrap	*tail;
	struct ipsec_addr_wrap	*srcnat;
};

struct ipsec_hosts {
	struct ipsec_addr_wrap	*src;
	struct ipsec_addr_wrap	*dst;
	uint16_t		 sport;
	uint16_t		 dport;
};

struct ipsec_filters {
	char			*tag;
	unsigned int		 tap;
};

struct ipsec_addr_wrap	*host(const char *);
struct ipsec_addr_wrap	*host_v6(const char *, int);
struct ipsec_addr_wrap	*host_v4(const char *, int);
struct ipsec_addr_wrap	*host_dns(const char *, int);
struct ipsec_addr_wrap	*host_if(const char *, int);
struct ipsec_addr_wrap	*host_any(void);
void			 ifa_load(void);
int			 ifa_exists(const char *);
struct ipsec_addr_wrap	*ifa_lookup(const char *ifa_name);
struct ipsec_addr_wrap	*ifa_grouplookup(const char *);
void			 set_ipmask(struct ipsec_addr_wrap *, uint8_t);
const struct ipsec_xf	*parse_xf(const char *, unsigned int,
			    const struct ipsec_xf *);
const char		*print_xf(unsigned int, unsigned int,
			    const struct ipsec_xf *);
void			 copy_transforms(unsigned int, const struct ipsec_xf *,
			    const struct ipsec_xf *,
			    struct iked_transform *, size_t,
			    unsigned int *, struct iked_transform *, size_t);
int			 create_ike(char *, int, uint8_t, struct ipsec_hosts *,
			    struct ipsec_hosts *, struct ipsec_mode *,
			    struct ipsec_mode *, uint8_t,
			    uint8_t, char *, char *,
			    uint32_t, struct iked_lifetime *,
			    struct iked_auth *, struct ipsec_filters *,
			    struct ipsec_addr_wrap *);
int			 create_user(const char *, const char *);
int			 get_id_type(char *);
uint8_t			 x2i(unsigned char *);
int			 parsekey(unsigned char *, size_t, struct iked_auth *);
int			 parsekeyfile(char *, struct iked_auth *);

struct ipsec_transforms *ipsec_transforms;
struct ipsec_filters *ipsec_filters;

typedef struct {
	union {
		int64_t			 number;
		uint8_t			 ikemode;
		uint8_t			 dir;
		uint8_t			 satype;
		uint8_t			 proto;
		char			*string;
		uint16_t		 port;
		struct ipsec_hosts	*hosts;
		struct ipsec_hosts	 peers;
		struct ipsec_addr_wrap	*anyhost;
		struct ipsec_addr_wrap	*host;
		struct ipsec_addr_wrap	*cfg;
		struct {
			char		*srcid;
			char		*dstid;
		} ids;
		char			*id;
		uint8_t			 type;
		struct iked_lifetime	 lifetime;
		struct iked_auth	 ikeauth;
		struct iked_auth	 ikekey;
		struct ipsec_transforms	*transforms;
		struct ipsec_filters	*filters;
		struct ipsec_mode	*mode;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	FROM ESP AH IN PEER ON OUT TO SRCID DSTID PSK PORT
%token	FILENAME AUTHXF PRFXF ENCXF ERROR IKEV2 IKESA CHILDSA
%token	PASSIVE ACTIVE ANY TAG TAP PROTO LOCAL GROUP NAME CONFIG EAP USER
%token	IKEV1 FLOW SA TCPMD5 TUNNEL TRANSPORT COUPLE DECOUPLE SET
%token	INCLUDE LIFETIME BYTES INET INET6 QUICK SKIP DEFAULT
%token	IPCOMP OCSP IKELIFETIME
%token	<v.string>		STRING
%token	<v.number>		NUMBER
%type	<v.string>		string
%type	<v.satype>		satype
%type	<v.proto>		proto
%type	<v.number>		protoval
%type	<v.hosts>		hosts hosts_list
%type	<v.port>		port
%type	<v.number>		portval af
%type	<v.peers>		peers
%type	<v.anyhost>		anyhost
%type	<v.host>		host host_spec
%type	<v.ids>			ids
%type	<v.id>			id
%type	<v.transforms>		transforms
%type	<v.filters>		filters
%type	<v.ikemode>		ikeflags ikematch ikemode ipcomp
%type	<v.ikeauth>		ikeauth
%type	<v.ikekey>		keyspec
%type	<v.mode>		ike_sa child_sa
%type	<v.lifetime>		lifetime
%type	<v.number>		byte_spec time_spec ikelifetime
%type	<v.string>		name
%type	<v.cfg>			cfg ikecfg ikecfgvals
%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar set '\n'
		| grammar user '\n'
		| grammar ikev2rule '\n'
		| grammar varset '\n'
		| grammar otherrule skipline '\n'
		| grammar error '\n'		{ file->errors++; }
		;

comma		: ','
		| /* empty */
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

set		: SET ACTIVE	{ passive = 0; }
		| SET PASSIVE	{ passive = 1; }
		| SET COUPLE	{ decouple = 0; }
		| SET DECOUPLE	{ decouple = 1; }
		| SET OCSP STRING		{
			if ((ocsp_url = strdup($3)) == NULL) {
				yyerror("cannot set ocsp_url");
				YYERROR;
			}
		}
		;

user		: USER STRING STRING		{
			if (create_user($2, $3) == -1)
				YYERROR;
		}
		;

ikev2rule	: IKEV2 name ikeflags satype af proto hosts_list peers
		    ike_sa child_sa ids ikelifetime lifetime ikeauth ikecfg
		    filters {
			if (create_ike($2, $5, $6, $7, &$8, $9, $10, $4, $3,
			    $11.srcid, $11.dstid, $12, &$13, &$14,
			    $16, $15) == -1) {
				yyerror("create_ike failed");
				YYERROR;
			}
		}
		;

ikecfg		: /* empty */			{ $$ = NULL; }
		| ikecfgvals			{ $$ = $1; }
		;

ikecfgvals	: cfg				{ $$ = $1; }
		| ikecfgvals cfg		{
			if ($2 == NULL)
				$$ = $1;
			else if ($1 == NULL)
				$$ = $2;
			else {
				$1->tail->next = $2;
				$1->tail = $2->tail;
				$$ = $1;
			}
		}
		;

cfg		: CONFIG STRING host_spec	{
			const struct ipsec_xf	*xf;

			if ((xf = parse_xf($2, $3->af, cpxfs)) == NULL) {
				yyerror("not a valid ikecfg option");
				free($2);
				free($3);
				YYERROR;
			}
			$$ = $3;
			$$->type = xf->id;
			$$->action = IKEV2_CP_REPLY;	/* XXX */
		}
		;

name		: /* empty */			{ $$ = NULL; }
		| STRING			{
			$$ = $1;
		}

satype		: /* empty */			{ $$ = IKEV2_SAPROTO_ESP; }
		| ESP				{ $$ = IKEV2_SAPROTO_ESP; }
		| AH				{ $$ = IKEV2_SAPROTO_AH; }
		;

af		: /* empty */			{ $$ = AF_UNSPEC; }
		| INET				{ $$ = AF_INET; }
		| INET6				{ $$ = AF_INET6; }
		;

proto		: /* empty */			{ $$ = 0; }
		| PROTO protoval		{ $$ = $2; }
		| PROTO ESP			{ $$ = IPPROTO_ESP; }
		| PROTO AH			{ $$ = IPPROTO_AH; }
		;

protoval	: STRING			{
			struct protoent *p;

			p = getprotobyname($1);
			if (p == NULL) {
				yyerror("unknown protocol: %s", $1);
				YYERROR;
			}
			$$ = p->p_proto;
			free($1);
		}
		| NUMBER			{
			if ($1 > 255 || $1 < 0) {
				yyerror("protocol outside range");
				YYERROR;
			}
		}
		;

hosts_list	: hosts				{ $$ = $1; }
		| hosts_list comma hosts	{
			if ($3 == NULL)
				$$ = $1;
			else if ($1 == NULL)
				$$ = $3;
			else {
				$1->src->tail->next = $3->src;
				$1->src->tail = $3->src->tail;
				$1->dst->tail->next = $3->dst;
				$1->dst->tail = $3->dst->tail;
				$$ = $1;
			}
		}
		;

hosts		: FROM host port TO host port		{
			struct ipsec_addr_wrap *ipa;
			for (ipa = $5; ipa; ipa = ipa->next) {
				if (ipa->srcnat) {
					yyerror("no flow NAT support for"
					    " destination network: %s",
					    ipa->name);
					YYERROR;
				}
			}

			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, "hosts: calloc");

			$$->src = $2;
			$$->sport = $3;
			$$->dst = $5;
			$$->dport = $6;
		}
		| TO host port FROM host port		{
			struct ipsec_addr_wrap *ipa;
			for (ipa = $2; ipa; ipa = ipa->next) {
				if (ipa->srcnat) {
					yyerror("no flow NAT support for"
					    " destination network: %s",
					    ipa->name);
					YYERROR;
				}
			}
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, "hosts: calloc");

			$$->src = $5;
			$$->sport = $6;
			$$->dst = $2;
			$$->dport = $3;
		}
		;

port		: /* empty */				{ $$ = 0; }
		| PORT portval				{ $$ = $2; }
		;

portval		: STRING				{
			struct servent *s;

			if ((s = getservbyname($1, "tcp")) != NULL ||
			    (s = getservbyname($1, "udp")) != NULL) {
				$$ = s->s_port;
			} else {
				yyerror("unknown port: %s", $1);
				YYERROR;
			}
		}
		| NUMBER				{
			if ($1 > USHRT_MAX || $1 < 0) {
				yyerror("port outside range");
				YYERROR;
			}
			$$ = htons($1);
		}
		;

peers		: /* empty */				{
			$$.dst = NULL;
			$$.src = NULL;
		}
		| PEER anyhost LOCAL anyhost		{
			$$.dst = $2;
			$$.src = $4;
		}
		| LOCAL anyhost PEER anyhost		{
			$$.dst = $4;
			$$.src = $2;
		}
		| PEER anyhost				{
			$$.dst = $2;
			$$.src = NULL;
		}
		| LOCAL anyhost				{
			$$.dst = NULL;
			$$.src = $2;
		}
		;

anyhost		: host_spec			{ $$ = $1; }
		| ANY				{
			$$ = host_any();
		}

host_spec	: STRING			{
			if (($$ = host($1)) == NULL) {
				free($1);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($1);
		}
		| STRING '/' NUMBER		{
			char	*buf;

			if (asprintf(&buf, "%s/%lld", $1, $3) == -1)
				err(1, "host: asprintf");
			free($1);
			if (($$ = host(buf)) == NULL)	{
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		;

host		: host_spec			{ $$ = $1; }
		| host_spec '(' host_spec ')'   {
			if (($1->af != AF_UNSPEC) && ($3->af != AF_UNSPEC) &&
			    ($3->af != $1->af)) {
				yyerror("Flow NAT address family mismatch");
				YYERROR;
			}
			$$ = $1;
			$$->srcnat = $3;
		}
		| ANY				{
			$$ = host_any();
		}
		;

ids		: /* empty */			{
			$$.srcid = NULL;
			$$.dstid = NULL;
		}
		| SRCID id DSTID id		{
			$$.srcid = $2;
			$$.dstid = $4;
		}
		| SRCID id			{
			$$.srcid = $2;
			$$.dstid = NULL;
		}
		| DSTID id			{
			$$.srcid = NULL;
			$$.dstid = $2;
		}
		;

id		: STRING			{ $$ = $1; }
		;

transforms	:					{
			if ((ipsec_transforms = calloc(1,
			    sizeof(struct ipsec_transforms))) == NULL)
				err(1, "transforms: calloc");
		}
		    transforms_l			{
			$$ = ipsec_transforms;
		}
		| /* empty */				{
			$$ = NULL;
		}
		;

transforms_l	: transforms_l transform
		| transform
		;

transform	: AUTHXF STRING			{
			if (ipsec_transforms->authxf)
				yyerror("auth already set");
			else {
				ipsec_transforms->authxf = parse_xf($2, 0,
				    authxfs);
				if (!ipsec_transforms->authxf)
					yyerror("%s not a valid transform", $2);
			}
		}
		| ENCXF STRING			{
			if (ipsec_transforms->encxf)
				yyerror("enc already set");
			else {
				ipsec_transforms->encxf = parse_xf($2, 0,
				    encxfs);
				if (!ipsec_transforms->encxf)
					yyerror("%s not a valid transform",
					    $2);
			}
		}
		| PRFXF STRING			{
			if (ipsec_transforms->prfxf)
				yyerror("prf already set");
			else {
				ipsec_transforms->prfxf = parse_xf($2, 0,
				    prfxfs);
				if (!ipsec_transforms->prfxf)
					yyerror("%s not a valid transform",
					    $2);
			}
		}
		| GROUP STRING			{
			if (ipsec_transforms->groupxf)
				yyerror("group already set");
			else {
				ipsec_transforms->groupxf = parse_xf($2, 0,
				    groupxfs);
				if (!ipsec_transforms->groupxf)
					yyerror("%s not a valid transform",
					    $2);
			}
		}
		;

ike_sa		: /* empty */	{
			$$ = NULL;
		}
		| IKESA		{
			encxfs = ikeencxfs;
		} transforms	{
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, "ike_sa: calloc");
			$$->xfs = $3;
		}
		;

child_sa	: /* empty */	{
			$$ = NULL;
		}
		| CHILDSA	{
			encxfs = ipsecencxfs;
		} transforms	{
			if (($$ = calloc(1, sizeof(*$$))) == NULL)
				err(1, "child_sa: calloc");
			$$->xfs = $3;
		}
		;

ikeflags	: ikematch ikemode ipcomp	{ $$ = $1 | $2 | $3; }
		;

ikematch	: /* empty */			{ $$ = 0; }
		| QUICK				{ $$ = IKED_POLICY_QUICK; }
		| SKIP				{ $$ = IKED_POLICY_SKIP; }
		| DEFAULT			{ $$ = IKED_POLICY_DEFAULT; }
		;

ikemode		: /* empty */			{ $$ = IKED_POLICY_PASSIVE; }
		| PASSIVE			{ $$ = IKED_POLICY_PASSIVE; }
		| ACTIVE			{ $$ = IKED_POLICY_ACTIVE; }
		;

ipcomp		: /* empty */			{ $$ = 0; }
		| IPCOMP			{ $$ = IKED_POLICY_IPCOMP; }
		;

ikeauth		: /* empty */			{
			$$.auth_method = IKEV2_AUTH_SIG_ANY;	/* default */
			$$.auth_eap = 0;
			$$.auth_length = 0;
		}
		| PSK keyspec			{
			memcpy(&$$, &$2, sizeof($$));
			$$.auth_method = IKEV2_AUTH_SHARED_KEY_MIC;
			$$.auth_eap = 0;
		}
		| EAP STRING			{
			unsigned int i;

			for (i = 0; i < strlen($2); i++)
				if ($2[i] == '-')
					$2[i] = '_';

			if (strcasecmp("mschap_v2", $2) != 0) {
				yyerror("unsupported EAP method: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			$$.auth_method = IKEV2_AUTH_RSA_SIG;
			$$.auth_eap = EAP_TYPE_MSCHAP_V2;
			$$.auth_length = 0;
		}
		| STRING			{
			const struct ipsec_xf *xf;

			if ((xf = parse_xf($1, 0, methodxfs)) == NULL ||
			    xf->id == IKEV2_AUTH_NONE) {
				yyerror("not a valid authentication mode");
				free($1);
				YYERROR;
			}
			free($1);

			$$.auth_method = xf->id;
			$$.auth_eap = 0;
			$$.auth_length = 0;
		}
		;

byte_spec	: NUMBER			{
			$$ = $1;
		}
		| STRING			{
			uint64_t	 bytes = 0;
			char		 unit = 0;

			if (sscanf($1, "%llu%c", &bytes, &unit) != 2) {
				yyerror("invalid byte specification: %s", $1);
				YYERROR;
			}
			switch (toupper((unsigned char)unit)) {
			case 'K':
				bytes *= 1024;
				break;
			case 'M':
				bytes *= 1024 * 1024;
				break;
			case 'G':
				bytes *= 1024 * 1024 * 1024;
				break;
			default:
				yyerror("invalid byte unit");
				YYERROR;
			}
			$$ = bytes;
		}
		;

time_spec	: NUMBER			{
			$$ = $1;
		}
		| STRING			{
			uint64_t	 seconds = 0;
			char		 unit = 0;

			if (sscanf($1, "%llu%c", &seconds, &unit) != 2) {
				yyerror("invalid time specification: %s", $1);
				YYERROR;
			}
			switch (tolower((unsigned char)unit)) {
			case 'm':
				seconds *= 60;
				break;
			case 'h':
				seconds *= 60 * 60;
				break;
			default:
				yyerror("invalid time unit");
				YYERROR;
			}
			$$ = seconds;
		}
		;

lifetime	: /* empty */				{
			$$ = deflifetime;
		}
		| LIFETIME time_spec			{
			$$.lt_seconds = $2;
			$$.lt_bytes = deflifetime.lt_bytes;
		}
		| LIFETIME time_spec BYTES byte_spec	{
			$$.lt_seconds = $2;
			$$.lt_bytes = $4;
		}
		;

ikelifetime	: /* empty */				{
			$$ = 0;
		}
		| IKELIFETIME time_spec			{
			$$ = $2;
		}

keyspec		: STRING			{
			uint8_t		*hex;

			bzero(&$$, sizeof($$));

			hex = $1;
			if (strncmp(hex, "0x", 2) == 0) {
				hex += 2;
				if (parsekey(hex, strlen(hex), &$$) != 0) {
					free($1);
					YYERROR;
				}
			} else {
				if (strlen($1) > sizeof($$.auth_data)) {
					yyerror("psk too long");
					free($1);
					YYERROR;
				}
				strlcpy($$.auth_data, $1,
				    sizeof($$.auth_data));
				$$.auth_length = strlen($1);
			}
			free($1);
		}
		| FILENAME STRING		{
			if (parsekeyfile($2, &$$) != 0) {
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

filters		:					{
			if ((ipsec_filters = calloc(1,
			    sizeof(struct ipsec_filters))) == NULL)
				err(1, "filters: calloc");
		}
		    filters_l			{
			$$ = ipsec_filters;
		}
		| /* empty */				{
			$$ = NULL;
		}
		;

filters_l	: filters_l filter
		| filter
		;

filter		: TAG STRING
		{
			ipsec_filters->tag = $2;
		}
		| TAP STRING
		{
			const char	*errstr = NULL;
			size_t		 len;

			len = strcspn($2, "0123456789");
			if (strlen("enc") != len ||
			    strncmp("enc", $2, len) != 0) {
				yyerror("invalid tap interface name: %s", $2);
				free($2);
				YYERROR;
			}
			ipsec_filters->tap =
			    strtonum($2 + len, 0, UINT_MAX, &errstr);
			free($2);
			if (errstr != NULL) {
				yyerror("invalid tap interface unit: %s",
				    errstr);
				YYERROR;
			}
		}
		;

string		: string STRING
		{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				err(1, "string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string
		{
			char *s = $1;
			log_debug("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				err(1, "cannot store variable");
			free($1);
			free($3);
		}
		;

/*
 * ignore IKEv1/manual keying rules in ipsec.conf
 */
otherrule	: IKEV1
		| sarule
		| FLOW
		| TCPMD5
		;

/* manual keying SAs might start with the following keywords */
sarule		: SA
		| FROM
		| TO
		| TUNNEL
		| TRANSPORT
		;

/* ignore everything to the end of the line */
skipline	:
		{
			int	 c;

			while ((c = lgetc(0)) != '\n' && c != EOF)
				; /* nothing */
			if (c == '\n')
				lungetc(c);
		}
		;
%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;

	file->errors++;
	va_start(ap, fmt);
	fprintf(stderr, "%s: %d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "active",		ACTIVE },
		{ "ah",			AH },
		{ "any",		ANY },
		{ "auth",		AUTHXF },
		{ "bytes",		BYTES },
		{ "childsa",		CHILDSA },
		{ "config",		CONFIG },
		{ "couple",		COUPLE },
		{ "decouple",		DECOUPLE },
		{ "default",		DEFAULT },
		{ "dstid",		DSTID },
		{ "eap",		EAP },
		{ "enc",		ENCXF },
		{ "esp",		ESP },
		{ "file",		FILENAME },
		{ "flow",		FLOW },
		{ "from",		FROM },
		{ "group",		GROUP },
		{ "ike",		IKEV1 },
		{ "ikelifetime",	IKELIFETIME },
		{ "ikesa",		IKESA },
		{ "ikev2",		IKEV2 },
		{ "include",		INCLUDE },
		{ "inet",		INET },
		{ "inet6",		INET6 },
		{ "ipcomp",		IPCOMP },
		{ "lifetime",		LIFETIME },
		{ "local",		LOCAL },
		{ "name",		NAME },
		{ "ocsp",		OCSP },
		{ "passive",		PASSIVE },
		{ "peer",		PEER },
		{ "port",		PORT },
		{ "prf",		PRFXF },
		{ "proto",		PROTO },
		{ "psk",		PSK },
		{ "quick",		QUICK },
		{ "sa",			SA },
		{ "set",		SET },
		{ "skip",		SKIP },
		{ "srcid",		SRCID },
		{ "tag",		TAG },
		{ "tap",		TAP },
		{ "tcpmd5",		TCPMD5 },
		{ "to",			TO },
		{ "transport",		TRANSPORT },
		{ "tunnel",		TUNNEL },
		{ "user",		USER }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p) {
		if (debug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
		return (p->k_val);
	} else {
		if (debug > 1)
			fprintf(stderr, "string: %s\n", s);
		return (STRING);
	}
}

#define MAXPUSHBACK	128

unsigned char	*parsebuf;
int		 parseindex;
unsigned char	 pushback_buffer[MAXPUSHBACK];
int		 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	unsigned char	 buf[8096];
	unsigned char	*p, *val;
	int		 quotec, next, c;
	int		 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		warn("malloc");
		free(nfile);
		return (NULL);
	}
	if (TAILQ_FIRST(&files) == NULL && strcmp(nfile->name, "-") == 0) {
		nfile->stream = stdin;
		free(nfile->name);
		if ((nfile->name = strdup("stdin")) == NULL) {
			warn("strdup");
			free(nfile);
			return (NULL);
		}
	} else if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
		prev->errors += file->errors;
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
}

int
parse_config(const char *filename, struct iked *x_env)
{
	struct sym	*sym;
	int		 errors = 0;

	env = x_env;
	rules = 0;

	if ((file = pushfile(filename, 1)) == NULL)
		return (-1);

	decouple = passive = 0;

	if (env->sc_opts & IKED_OPT_PASSIVE)
		passive = 1;

	yyparse();
	errors = file->errors;
	popfile();

	env->sc_passive = passive ? 1 : 0;
	env->sc_decoupled = decouple ? 1 : 0;
	env->sc_ocsp_url = ocsp_url;

	if (!rules)
		log_warnx("%s: no valid configuration rules found",
		    filename);
	else
		log_debug("%s: loaded %d configuration rules",
		    filename, rules);

	/* Free macros and check which have not been used. */
	while ((sym = TAILQ_FIRST(&symhead))) {
		if (!sym->used)
			log_debug("warning: macro '%s' not "
			    "used\n", sym->nam);
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entry);
		free(sym);
	}

	return (errors ? -1 : 0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		err(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

uint8_t
x2i(unsigned char *s)
{
	char	ss[3];

	ss[0] = s[0];
	ss[1] = s[1];
	ss[2] = 0;

	if (!isxdigit(s[0]) || !isxdigit(s[1])) {
		yyerror("keys need to be specified in hex digits");
		return (-1);
	}
	return ((uint8_t)strtoul(ss, NULL, 16));
}

int
parsekey(unsigned char *hexkey, size_t len, struct iked_auth *auth)
{
	unsigned int	  i;

	bzero(auth, sizeof(*auth));
	if ((len / 2) > sizeof(auth->auth_data))
		return (-1);
	auth->auth_length = len / 2;

	for (i = 0; i < auth->auth_length; i++)
		auth->auth_data[i] = x2i(hexkey + 2 * i);

	return (0);
}

int
parsekeyfile(char *filename, struct iked_auth *auth)
{
	struct stat	 sb;
	int		 fd, ret;
	unsigned char	*hex;

	if ((fd = open(filename, O_RDONLY)) < 0)
		err(1, "open %s", filename);
	if (fstat(fd, &sb) < 0)
		err(1, "parsekeyfile: stat %s", filename);
	if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
		errx(1, "%s: key too %s", filename, sb.st_size ? "large" :
		    "small");
	if ((hex = calloc(sb.st_size, sizeof(unsigned char))) == NULL)
		err(1, "parsekeyfile: calloc");
	if (read(fd, hex, sb.st_size) < sb.st_size)
		err(1, "parsekeyfile: read");
	close(fd);
	ret = parsekey(hex, sb.st_size, auth);
	free(hex);
	return (ret);
}

int
get_id_type(char *string)
{
	struct in6_addr ia;

	if (string == NULL)
		return (IKEV2_ID_NONE);

	if (*string == '/')
		return (IKEV2_ID_ASN1_DN);
	else if (inet_pton(AF_INET, string, &ia) == 1)
		return (IKEV2_ID_IPV4);
	else if (inet_pton(AF_INET6, string, &ia) == 1)
		return (IKEV2_ID_IPV6);
	else if (strchr(string, '@@'))
		return (IKEV2_ID_UFQDN);
	else
		return (IKEV2_ID_FQDN);
}

EVP_PKEY *
wrap_pubkey(FILE *fp)
{
	EVP_PKEY	*key = NULL;
	struct rsa_st	*rsa = NULL;

	key = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
	if (key == NULL) {
		/* reading PKCS #8 failed, try PEM */
		rewind(fp);
		rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);
		fclose(fp);
		if (rsa == NULL)
			return (NULL);
		if ((key = EVP_PKEY_new()) == NULL) {
			RSA_free(rsa);
			return (NULL);
		}
		if (!EVP_PKEY_set1_RSA(key, rsa)) {
			RSA_free(rsa);
			EVP_PKEY_free(key);
			return (NULL);
		}
		/* Always free RSA *rsa */
		RSA_free(rsa);
	} else {
		fclose(fp);
	}

	return (key);
}

EVP_PKEY *
find_pubkey(const char *keyfile)
{
	FILE		*fp = NULL;
	if ((fp = fopen(keyfile, "r")) == NULL)
		return (NULL);

	return (wrap_pubkey(fp));
}

int
set_policy_auth_method(const char *peerid, EVP_PKEY *key,
    struct iked_policy *pol)
{
	struct rsa_st		*rsa;
	EC_KEY			*ec_key;
	u_int8_t		 method;
	u_int8_t		 cert_type;
	struct iked_auth	*ikeauth;

	method = IKEV2_AUTH_NONE;
	cert_type = IKEV2_CERT_NONE;

	if (key != NULL) {
		/* infer policy from key type */
		if ((rsa = EVP_PKEY_get1_RSA(key)) != NULL) {
			method = IKEV2_AUTH_RSA_SIG;
			cert_type = IKEV2_CERT_RSA_KEY;
			RSA_free(rsa);
		} else if ((ec_key = EVP_PKEY_get1_EC_KEY(key)) != NULL) {
			const EC_GROUP *group = EC_KEY_get0_group(ec_key);
			if (group == NULL) {
				EC_KEY_free(ec_key);
				return (-1);
			}
			switch (EC_GROUP_get_degree(group)) {
			case 256:
				method = IKEV2_AUTH_ECDSA_256;
				break;
			case 384:
				method = IKEV2_AUTH_ECDSA_384;
				break;
			case 521:
				method = IKEV2_AUTH_ECDSA_521;
				break;
			default:
				EC_KEY_free(ec_key);
				return (-1);
			}
			cert_type = IKEV2_CERT_ECDSA;
			EC_KEY_free(ec_key);
		}

		if (method == IKEV2_AUTH_NONE || cert_type == IKEV2_CERT_NONE)
			return (-1);
	} else {
		/* default to IKEV2_CERT_X509_CERT otherwise */
		method = IKEV2_AUTH_SIG;
		cert_type = IKEV2_CERT_X509_CERT;
	}

	ikeauth = &pol->pol_auth;

	if (ikeauth->auth_method == IKEV2_AUTH_SHARED_KEY_MIC) {
		if (key != NULL &&
		    method != IKEV2_AUTH_RSA_SIG)
			goto mismatch;
		return (0);
	}

	if (ikeauth->auth_method != IKEV2_AUTH_NONE &&
	    ikeauth->auth_method != IKEV2_AUTH_SIG_ANY &&
	    ikeauth->auth_method != method)
		goto mismatch;

	ikeauth->auth_method = method;
	pol->pol_certreqtype = cert_type;

	log_debug("%s: using %s for peer %s", __func__,
	    print_xf(method, 0, methodxfs), peerid);

	return (0);

 mismatch:
	log_warnx("%s: ikeauth policy mismatch, %s specified, but only %s "
	    "possible", __func__, print_xf(ikeauth->auth_method, 0, methodxfs),
	    print_xf(method, 0, methodxfs));
	return (-1);
}

int
set_policy(char *idstr, int type, struct iked_policy *pol)
{
	char		 keyfile[PATH_MAX];
	const char	*prefix = NULL;
	EVP_PKEY	*key;

	switch (type) {
	case IKEV2_ID_IPV4:
		prefix = "ipv4";
		break;
	case IKEV2_ID_IPV6:
		prefix = "ipv6";
		break;
	case IKEV2_ID_FQDN:
		prefix = "fqdn";
		break;
	case IKEV2_ID_UFQDN:
		prefix = "ufqdn";
		break;
	default:
		/* Unspecified ID or public key not supported for this type */
		log_debug("%s: unknown type = %d", __func__, type);
		return (-1);
	}

	lc_string(idstr);
	if ((size_t)snprintf(keyfile, sizeof(keyfile),
	    IKED_CA IKED_PUBKEY_DIR "%s/%s", prefix,
	    idstr) >= sizeof(keyfile)) {
		log_warnx("%s: public key path is too long", __func__);
		return (-1);
	}

	if ((key = find_pubkey(keyfile)) == NULL) {
		log_warnx("%s: could not find pubkey for %s", __func__,
		    keyfile);
	}

	if (set_policy_auth_method(keyfile, key, pol) < 0) {
		EVP_PKEY_free(key);
		log_warnx("%s: failed to set policy auth method for %s",
		    __func__, keyfile);
		return (-1);
	}

	if (key != NULL) {
		EVP_PKEY_free(key);
		log_debug("%s: found pubkey for %s", __func__, keyfile);
	}

	return (0);
}

struct ipsec_addr_wrap *
host(const char *s)
{
	struct ipsec_addr_wrap	*ipa = NULL;
	int			 mask, cont = 1;
	char			*p, *q, *ps;

	if ((p = strrchr(s, '/')) != NULL) {
		errno = 0;
		mask = strtol(p + 1, &q, 0);
		if (errno == ERANGE || !q || *q || mask > 128 || q == (p + 1))
			errx(1, "host: invalid netmask '%s'", p);
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: calloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else {
		if ((ps = strdup(s)) == NULL)
			err(1, "host: strdup");
		mask = -1;
	}

	/* Does interface with this name exist? */
	if (cont && (ipa = host_if(ps, mask)) != NULL)
		cont = 0;

	/* IPv4 address? */
	if (cont && (ipa = host_v4(s, mask == -1 ? 32 : mask)) != NULL)
		cont = 0;

	/* IPv6 address? */
	if (cont && (ipa = host_v6(ps, mask == -1 ? 128 : mask)) != NULL)
		cont = 0;

	/* dns lookup */
	if (cont && mask == -1 && (ipa = host_dns(s, mask)) != NULL)
		cont = 0;
	free(ps);

	if (ipa == NULL || cont == 1) {
		fprintf(stderr, "no IP address found for %s\n", s);
		return (NULL);
	}
	return (ipa);
}

struct ipsec_addr_wrap *
host_v6(const char *s, int prefixlen)
{
	struct ipsec_addr_wrap	*ipa = NULL;
	struct addrinfo		 hints, *res;
	char			 hbuf[NI_MAXHOST];

	bzero(&hints, sizeof(struct addrinfo));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, NULL, &hints, &res))
		return (NULL);
	if (res->ai_next)
		err(1, "host_v6: numeric hostname expanded to multiple item");

	ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (ipa == NULL)
		err(1, "host_v6: calloc");
	ipa->af = res->ai_family;
	memcpy(&ipa->address, res->ai_addr, sizeof(struct sockaddr_in6));
	if (prefixlen > 128)
		prefixlen = 128;
	ipa->next = NULL;
	ipa->tail = ipa;

	set_ipmask(ipa, prefixlen);
	if (getnameinfo(res->ai_addr, res->ai_addrlen,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST)) {
		errx(1, "could not get a numeric hostname");
	}

	if (prefixlen != 128) {
		ipa->netaddress = 1;
		if (asprintf(&ipa->name, "%s/%d", hbuf, prefixlen) == -1)
			err(1, "host_v6: asprintf");
	} else {
		if ((ipa->name = strdup(hbuf)) == NULL)
			err(1, "host_v6: strdup");
	}

	freeaddrinfo(res);

	return (ipa);
}

struct ipsec_addr_wrap *
host_v4(const char *s, int mask)
{
	struct ipsec_addr_wrap	*ipa = NULL;
	struct sockaddr_in	 ina;
	int			 bits = 32;

	bzero(&ina, sizeof(ina));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina.sin_addr,
		    sizeof(ina.sin_addr))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina.sin_addr) != 1)
			return (NULL);
	}

	ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (ipa == NULL)
		err(1, "host_v4: calloc");

	ina.sin_family = AF_INET;
	ina.sin_len = sizeof(ina);
	memcpy(&ipa->address, &ina, sizeof(ina));

	ipa->name = strdup(s);
	if (ipa->name == NULL)
		err(1, "host_v4: strdup");
	ipa->af = AF_INET;
	ipa->next = NULL;
	ipa->tail = ipa;

	set_ipmask(ipa, bits);
	if (strrchr(s, '/') != NULL)
		ipa->netaddress = 1;

	return (ipa);
}

struct ipsec_addr_wrap *
host_dns(const char *s, int mask)
{
	struct ipsec_addr_wrap	*ipa = NULL, *head = NULL;
	struct addrinfo		 hints, *res0, *res;
	int			 error;
	char			 hbuf[NI_MAXHOST];

	bzero(&hints, sizeof(struct addrinfo));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_ADDRCONFIG;
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error)
		return (NULL);

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET && res->ai_family != AF_INET6)
			continue;

		ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (ipa == NULL)
			err(1, "host_dns: calloc");
		switch (res->ai_family) {
		case AF_INET:
			memcpy(&ipa->address, res->ai_addr,
			    sizeof(struct sockaddr_in));
			break;
		case AF_INET6:
			memcpy(&ipa->address, res->ai_addr,
			    sizeof(struct sockaddr_in6));
			break;
		}
		error = getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
		if (error)
			err(1, "host_dns: getnameinfo");
		ipa->name = strdup(hbuf);
		if (ipa->name == NULL)
			err(1, "host_dns: strdup");
		ipa->af = res->ai_family;
		ipa->next = NULL;
		ipa->tail = ipa;
		if (head == NULL)
			head = ipa;
		else {
			head->tail->next = ipa;
			head->tail = ipa;
		}

		/*
		 * XXX for now, no netmask support for IPv6.
		 * but since there's no way to specify address family, once you
		 * have IPv6 address on a host, you cannot use dns/netmask
		 * syntax.
		 */
		if (ipa->af == AF_INET)
			set_ipmask(ipa, mask == -1 ? 32 : mask);
		else
			if (mask != -1)
				err(1, "host_dns: cannot apply netmask "
				    "on non-IPv4 address");
	}
	freeaddrinfo(res0);

	return (head);
}

struct ipsec_addr_wrap *
host_if(const char *s, int mask)
{
	struct ipsec_addr_wrap *ipa = NULL;

	if (ifa_exists(s))
		ipa = ifa_lookup(s);

	return (ipa);
}

struct ipsec_addr_wrap *
host_any(void)
{
	struct ipsec_addr_wrap	*ipa;

	ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (ipa == NULL)
		err(1, "host_any: calloc");
	ipa->af = AF_UNSPEC;
	ipa->netaddress = 1;
	ipa->tail = ipa;
	return (ipa);
}

/* interface lookup routintes */

struct ipsec_addr_wrap	*iftab;

void
ifa_load(void)
{
	struct ifaddrs		*ifap, *ifa;
	struct ipsec_addr_wrap	*n = NULL, *h = NULL;
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;

	if (getifaddrs(&ifap) < 0)
		err(1, "ifa_load: getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (!(ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6 ||
		    ifa->ifa_addr->sa_family == AF_LINK))
			continue;
		n = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (n == NULL)
			err(1, "ifa_load: calloc");
		n->af = ifa->ifa_addr->sa_family;
		if ((n->name = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
		if (n->af == AF_INET) {
			sa_in = (struct sockaddr_in *)ifa->ifa_addr;
			memcpy(&n->address, sa_in, sizeof(*sa_in));
			sa_in = (struct sockaddr_in *)ifa->ifa_netmask;
			n->mask = mask2prefixlen((struct sockaddr *)sa_in);
		} else if (n->af == AF_INET6) {
			sa_in6 = (struct sockaddr_in6 *)ifa->ifa_addr;
			memcpy(&n->address, sa_in6, sizeof(*sa_in6));
			sa_in6 = (struct sockaddr_in6 *)ifa->ifa_netmask;
			n->mask = mask2prefixlen6((struct sockaddr *)sa_in6);
		}
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	iftab = h;
	freeifaddrs(ifap);
}

int
ifa_exists(const char *ifa_name)
{
	struct ipsec_addr_wrap	*n;
	struct ifgroupreq	 ifgr;
	int			 s;

	if (iftab == NULL)
		ifa_load();

	/* check wether this is a group */
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "ifa_exists: socket");
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, ifa_name, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == 0) {
		close(s);
		return (1);
	}
	close(s);

	for (n = iftab; n; n = n->next) {
		if (n->af == AF_LINK && !strncmp(n->name, ifa_name,
		    IFNAMSIZ))
			return (1);
	}

	return (0);
}

struct ipsec_addr_wrap *
ifa_grouplookup(const char *ifa_name)
{
	struct ifg_req		*ifg;
	struct ifgroupreq	 ifgr;
	int			 s;
	size_t			 len;
	struct ipsec_addr_wrap	*n, *h = NULL, *hn;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "socket");
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, ifa_name, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
		close(s);
		return (NULL);
	}

	len = ifgr.ifgr_len;
	if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
		err(1, "calloc");
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
		err(1, "ioctl");

	for (ifg = ifgr.ifgr_groups; ifg && len >= sizeof(struct ifg_req);
	    ifg++) {
		len -= sizeof(struct ifg_req);
		if ((n = ifa_lookup(ifg->ifgrq_member)) == NULL)
			continue;
		if (h == NULL)
			h = n;
		else {
			for (hn = h; hn->next != NULL; hn = hn->next)
				;	/* nothing */
			hn->next = n;
			n->tail = hn;
		}
	}
	free(ifgr.ifgr_groups);
	close(s);

	return (h);
}

struct ipsec_addr_wrap *
ifa_lookup(const char *ifa_name)
{
	struct ipsec_addr_wrap	*p = NULL, *h = NULL, *n = NULL;
	struct sockaddr_in6	*in6;
	uint8_t			*s6;

	if (iftab == NULL)
		ifa_load();

	if ((n = ifa_grouplookup(ifa_name)) != NULL)
		return (n);

	for (p = iftab; p; p = p->next) {
		if (p->af != AF_INET && p->af != AF_INET6)
			continue;
		if (strncmp(p->name, ifa_name, IFNAMSIZ))
			continue;
		n = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (n == NULL)
			err(1, "ifa_lookup: calloc");
		memcpy(n, p, sizeof(struct ipsec_addr_wrap));
		if ((n->name = strdup(p->name)) == NULL)
			err(1, "ifa_lookup: strdup");
		switch (n->af) {
		case AF_INET:
			set_ipmask(n, 32);
			break;
		case AF_INET6:
			in6 = (struct sockaddr_in6 *)&n->address;
			s6 = (uint8_t *)&in6->sin6_addr.s6_addr;

			/* route/show.c and bgpd/util.c give KAME credit */
			if (IN6_IS_ADDR_LINKLOCAL(&in6->sin6_addr)) {
				uint16_t	 tmp16;

				/* for now we can not handle link local,
				 * therefore bail for now
				 */
				free(n);
				continue;

				memcpy(&tmp16, &s6[2], sizeof(tmp16));
				/* use this when we support link-local
				 * n->??.scopeid = ntohs(tmp16);
				 */
				s6[2] = 0;
				s6[3] = 0;
			}
			set_ipmask(n, 128);
			break;
		}

		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	return (h);
}

void
set_ipmask(struct ipsec_addr_wrap *address, uint8_t b)
{
	address->mask = b;
}

const struct ipsec_xf *
parse_xf(const char *name, unsigned int length, const struct ipsec_xf xfs[])
{
	int		i;

	for (i = 0; xfs[i].name != NULL; i++) {
		if (strncmp(name, xfs[i].name, strlen(name)))
			continue;
		if (length == 0 || length == xfs[i].length)
			return &xfs[i];
	}
	return (NULL);
}

const char *
print_xf(unsigned int id, unsigned int length, const struct ipsec_xf xfs[])
{
	int		i;

	for (i = 0; xfs[i].name != NULL; i++) {
		if (xfs[i].id == id) {
			if (length == 0 || length == xfs[i].length)
				return (xfs[i].name);
		}
	}
	return ("unknown");
}

size_t
keylength_xf(unsigned int saproto, unsigned int type, unsigned int id)
{
	int			 i;
	const struct ipsec_xf	*xfs;

	switch (type) {
	case IKEV2_XFORMTYPE_ENCR:
		if (saproto == IKEV2_SAPROTO_IKE)
			xfs = ikeencxfs;
		else
			xfs = ipsecencxfs;
		break;
	case IKEV2_XFORMTYPE_INTEGR:
		xfs = authxfs;
		break;
	default:
		return (0);
	}

	for (i = 0; xfs[i].name != NULL; i++) {
		if (xfs[i].id == id)
			return (xfs[i].length * 8);
	}
	return (0);
}

size_t
noncelength_xf(unsigned int type, unsigned int id)
{
	const struct ipsec_xf	*xfs = ipsecencxfs;
	int			 i;

	if (type != IKEV2_XFORMTYPE_ENCR)
		return (0);

	for (i = 0; xfs[i].name != NULL; i++)
		if (xfs[i].id == id)
			return (xfs[i].nonce * 8);
	return (0);
}

void
print_user(struct iked_user *usr)
{
	print_verbose("user \"%s\" \"%s\"\n", usr->usr_name, usr->usr_pass);
}

void
print_policy(struct iked_policy *pol)
{
	struct iked_proposal	*pp;
	struct iked_transform	*xform;
	struct iked_flow	*flow;
	struct iked_cfg		*cfg;
	unsigned int		 i, j;
	const struct ipsec_xf	*xfs = NULL;

	print_verbose("ikev2");

	if (pol->pol_name[0] != '\0')
		print_verbose(" \"%s\"", pol->pol_name);

	if (pol->pol_flags & IKED_POLICY_DEFAULT)
		print_verbose(" default");
	else if (pol->pol_flags & IKED_POLICY_QUICK)
		print_verbose(" quick");
	else if (pol->pol_flags & IKED_POLICY_SKIP)
		print_verbose(" skip");

	if (pol->pol_flags & IKED_POLICY_ACTIVE)
		print_verbose(" active");
	else
		print_verbose(" passive");

	print_verbose(" %s", print_xf(pol->pol_saproto, 0, saxfs));

	if (pol->pol_ipproto)
		print_verbose(" proto %s", print_proto(pol->pol_ipproto));

	if (pol->pol_af) {
		if (pol->pol_af == AF_INET)
			print_verbose(" inet");
		else
			print_verbose(" inet6");
	}

	RB_FOREACH(flow, iked_flows, &pol->pol_flows) {
		print_verbose(" from %s",
		    print_host((struct sockaddr *)&flow->flow_src.addr, NULL,
		    0));
		if (flow->flow_src.addr_af != AF_UNSPEC &&
		    flow->flow_src.addr_net)
			print_verbose("/%d", flow->flow_src.addr_mask);
		if (flow->flow_src.addr_port)
			print_verbose(" port %d",
			    ntohs(flow->flow_src.addr_port));

		print_verbose(" to %s",
		    print_host((struct sockaddr *)&flow->flow_dst.addr, NULL,
		    0));
		if (flow->flow_dst.addr_af != AF_UNSPEC &&
		    flow->flow_dst.addr_net)
			print_verbose("/%d", flow->flow_dst.addr_mask);
		if (flow->flow_dst.addr_port)
			print_verbose(" port %d",
			    ntohs(flow->flow_dst.addr_port));
	}

	if ((pol->pol_flags & IKED_POLICY_DEFAULT) == 0) {
		print_verbose(" local %s",
		    print_host((struct sockaddr *)&pol->pol_local.addr, NULL,
		    0));
		if (pol->pol_local.addr.ss_family != AF_UNSPEC &&
		    pol->pol_local.addr_net)
			print_verbose("/%d", pol->pol_local.addr_mask);

		print_verbose(" peer %s",
		    print_host((struct sockaddr *)&pol->pol_peer.addr, NULL,
		    0));
		if (pol->pol_peer.addr.ss_family != AF_UNSPEC &&
		    pol->pol_peer.addr_net)
			print_verbose("/%d", pol->pol_peer.addr_mask);
	}

	TAILQ_FOREACH(pp, &pol->pol_proposals, prop_entry) {
		if (!pp->prop_nxforms)
			continue;
		if (pp->prop_protoid == IKEV2_SAPROTO_IKE)
			print_verbose(" ikesa");
		else
			print_verbose(" childsa");

		for (j = 0; ikev2_xformtype_map[j].cm_type != 0; j++) {
			xfs = NULL;

			for (i = 0; i < pp->prop_nxforms; i++) {
				xform = pp->prop_xforms + i;

				if (xform->xform_type !=
				    ikev2_xformtype_map[j].cm_type)
					continue;

				if (xfs != NULL) {
					print_verbose(",");
				} else {
					switch (xform->xform_type) {
					case IKEV2_XFORMTYPE_INTEGR:
						print_verbose(" auth ");
						xfs = authxfs;
						break;
					case IKEV2_XFORMTYPE_ENCR:
						print_verbose(" enc ");
						if (pp->prop_protoid ==
						    IKEV2_SAPROTO_IKE)
							xfs = ikeencxfs;
						else
							xfs = ipsecencxfs;
						break;
					case IKEV2_XFORMTYPE_PRF:
						print_verbose(" prf ");
						xfs = prfxfs;
						break;
					case IKEV2_XFORMTYPE_DH:
						print_verbose(" group ");
						xfs = groupxfs;
						break;
					default:
						continue;
					}
				}

				print_verbose("%s", print_xf(xform->xform_id,
				    xform->xform_length / 8, xfs));
			}
		}
	}

	if (pol->pol_localid.id_length != 0)
		print_verbose(" srcid %s", pol->pol_localid.id_data);
	if (pol->pol_peerid.id_length != 0)
		print_verbose(" dstid %s", pol->pol_peerid.id_data);

	if (pol->pol_rekey)
		print_verbose(" ikelifetime %u", pol->pol_rekey);

	print_verbose(" lifetime %llu bytes %llu",
	    pol->pol_lifetime.lt_seconds, pol->pol_lifetime.lt_bytes);

	switch (pol->pol_auth.auth_method) {
	case IKEV2_AUTH_NONE:
		print_verbose (" none");
		break;
	case IKEV2_AUTH_SHARED_KEY_MIC:
		print_verbose(" psk 0x");
		for (i = 0; i < pol->pol_auth.auth_length; i++)
			print_verbose("%02x", pol->pol_auth.auth_data[i]);
		break;
	default:
		if (pol->pol_auth.auth_eap)
			print_verbose(" eap \"%s\"",
			    print_map(pol->pol_auth.auth_eap, eap_type_map));
		else
			print_verbose(" %s",
			    print_xf(pol->pol_auth.auth_method, 0, methodxfs));
	}

	for (i = 0; i < pol->pol_ncfg; i++) {
		cfg = &pol->pol_cfg[i];
		print_verbose(" config %s %s", print_xf(cfg->cfg_type,
		    cfg->cfg.address.addr_af, cpxfs),
		    print_host((struct sockaddr *)&cfg->cfg.address.addr, NULL,
		    0));
	}

	if (pol->pol_tag[0] != '\0')
		print_verbose(" tag \"%s\"", pol->pol_tag);

	if (pol->pol_tap != 0)
		print_verbose(" tap \"enc%u\"", pol->pol_tap);

	print_verbose("\n");
}

void
copy_transforms(unsigned int type, const struct ipsec_xf *xf,
    const struct ipsec_xf *xfs,
    struct iked_transform *dst, size_t ndst,
    unsigned int *n, struct iked_transform *src, size_t nsrc)
{
	unsigned int		 i;
	struct iked_transform	*a, *b;

	if (xf != NULL) {
		if (*n >= ndst)
			return;
		b = dst + (*n)++;

		b->xform_type = type;
		b->xform_id = xf->id;
		b->xform_keylength = xf->length * 8;
		b->xform_length = xf->keylength * 8;
		return;
	}

	for (i = 0; i < nsrc; i++) {
		a = src + i;
		if (a->xform_type != type)
			continue;
		if (*n >= ndst)
			return;
		b = dst + (*n)++;
		memcpy(b, a, sizeof(*b));
	}
}

int
create_ike(char *name, int af, uint8_t ipproto, struct ipsec_hosts *hosts,
    struct ipsec_hosts *peers, struct ipsec_mode *ike_sa,
    struct ipsec_mode *ipsec_sa, uint8_t saproto,
    uint8_t flags, char *srcid, char *dstid,
    uint32_t ikelifetime, struct iked_lifetime *lt,
    struct iked_auth *authtype, struct ipsec_filters *filter,
    struct ipsec_addr_wrap *ikecfg)
{
	char			 idstr[IKED_ID_SIZE];
	unsigned int		 idtype = IKEV2_ID_NONE;
	struct ipsec_addr_wrap	*ipa, *ipb, *ippn;
	struct iked_policy	 pol;
	struct iked_proposal	 prop[2];
	unsigned int		 j;
	struct iked_transform	 ikexforms[64], ipsecxforms[64];
	struct iked_flow	 flows[64];
	static unsigned int	 policy_id = 0;
	struct iked_cfg		*cfg;

	bzero(&pol, sizeof(pol));
	bzero(&prop, sizeof(prop));
	bzero(&ikexforms, sizeof(ikexforms));
	bzero(&ipsecxforms, sizeof(ipsecxforms));
	bzero(&flows, sizeof(flows));
	bzero(idstr, sizeof(idstr));

	pol.pol_id = ++policy_id;
	pol.pol_certreqtype = env->sc_certreqtype;
	pol.pol_af = af;
	pol.pol_saproto = saproto;
	pol.pol_ipproto = ipproto;
	pol.pol_flags = flags;
	memcpy(&pol.pol_auth, authtype, sizeof(struct iked_auth));

	if (name != NULL) {
		if (strlcpy(pol.pol_name, name,
		    sizeof(pol.pol_name)) >= sizeof(pol.pol_name)) {
			yyerror("name too long");
			return (-1);
		}
	} else {
		snprintf(pol.pol_name, sizeof(pol.pol_name),
		    "policy%d", policy_id);
	}

	if (srcid) {
		pol.pol_localid.id_type = get_id_type(srcid);
		pol.pol_localid.id_length = strlen(srcid);
		if (strlcpy((char *)pol.pol_localid.id_data,
		    srcid, IKED_ID_SIZE) >= IKED_ID_SIZE) {
			yyerror("srcid too long");
			return (-1);
		}
	}
	if (dstid) {
		pol.pol_peerid.id_type = get_id_type(dstid);
		pol.pol_peerid.id_length = strlen(dstid);
		if (strlcpy((char *)pol.pol_peerid.id_data,
		    dstid, IKED_ID_SIZE) >= IKED_ID_SIZE) {
			yyerror("dstid too long");
			return (-1);
		}
	}

	if (filter != NULL) {
		if (filter->tag)
			strlcpy(pol.pol_tag, filter->tag, sizeof(pol.pol_tag));
		pol.pol_tap = filter->tap;
	}

	if (peers == NULL) {
		if (pol.pol_flags & IKED_POLICY_ACTIVE) {
			yyerror("active mode requires peer specification");
			return (-1);
		}
		pol.pol_flags |= IKED_POLICY_DEFAULT|IKED_POLICY_SKIP;
	}

	if (peers && peers->src && peers->dst &&
	    (peers->src->af != AF_UNSPEC) && (peers->dst->af != AF_UNSPEC) &&
	    (peers->src->af != peers->dst->af))
		fatalx("create_ike: peer address family mismatch");

	if (peers && (pol.pol_af != AF_UNSPEC) &&
	    ((peers->src && (peers->src->af != AF_UNSPEC) &&
	    (peers->src->af != pol.pol_af)) ||
	    (peers->dst && (peers->dst->af != AF_UNSPEC) &&
	    (peers->dst->af != pol.pol_af))))
		fatalx("create_ike: policy address family mismatch");

	ipa = ipb = NULL;
	if (peers) {
		if (peers->src)
			ipa = peers->src;
		if (peers->dst)
			ipb = peers->dst;
		if (ipa == NULL && ipb == NULL) {
			if (hosts->src && hosts->src->next == NULL)
				ipa = hosts->src;
			if (hosts->dst && hosts->dst->next == NULL)
				ipb = hosts->dst;
		}
	}
	if (ipa == NULL && ipb == NULL) {
		yyerror("could not get local/peer specification");
		return (-1);
	}
	if (pol.pol_flags & IKED_POLICY_ACTIVE) {
		if (ipb == NULL || ipb->netaddress ||
		    (ipa != NULL && ipa->netaddress)) {
			yyerror("active mode requires local/peer address");
			return (-1);
		}
	}
	if (ipa) {
		memcpy(&pol.pol_local.addr, &ipa->address,
		    sizeof(ipa->address));
		pol.pol_local.addr_af = ipa->af;
		pol.pol_local.addr_mask = ipa->mask;
		pol.pol_local.addr_net = ipa->netaddress;
		if (pol.pol_af == AF_UNSPEC)
			pol.pol_af = ipa->af;
	}
	if (ipb) {
		memcpy(&pol.pol_peer.addr, &ipb->address,
		    sizeof(ipb->address));
		pol.pol_peer.addr_af = ipb->af;
		pol.pol_peer.addr_mask = ipb->mask;
		pol.pol_peer.addr_net = ipb->netaddress;
		if (pol.pol_af == AF_UNSPEC)
			pol.pol_af = ipb->af;
	}

	if (ikelifetime)
		pol.pol_rekey = ikelifetime;

	if (lt)
		pol.pol_lifetime = *lt;
	else
		pol.pol_lifetime = deflifetime;

	TAILQ_INIT(&pol.pol_proposals);
	RB_INIT(&pol.pol_flows);

	prop[0].prop_id = ++pol.pol_nproposals;
	prop[0].prop_protoid = IKEV2_SAPROTO_IKE;
	if (ike_sa == NULL || ike_sa->xfs == NULL) {
		prop[0].prop_nxforms = ikev2_default_nike_transforms;
		prop[0].prop_xforms = ikev2_default_ike_transforms;
	} else {
		j = 0;
		copy_transforms(IKEV2_XFORMTYPE_INTEGR,
		    ike_sa->xfs->authxf, authxfs,
		    ikexforms, nitems(ikexforms), &j,
		    ikev2_default_ike_transforms,
		    ikev2_default_nike_transforms);
		copy_transforms(IKEV2_XFORMTYPE_ENCR,
		    ike_sa->xfs->encxf, ikeencxfs,
		    ikexforms, nitems(ikexforms), &j,
		    ikev2_default_ike_transforms,
		    ikev2_default_nike_transforms);
		copy_transforms(IKEV2_XFORMTYPE_DH,
		    ike_sa->xfs->groupxf, groupxfs,
		    ikexforms, nitems(ikexforms), &j,
		    ikev2_default_ike_transforms,
		    ikev2_default_nike_transforms);
		copy_transforms(IKEV2_XFORMTYPE_PRF,
		    ike_sa->xfs->prfxf, prfxfs,
		    ikexforms, nitems(ikexforms), &j,
		    ikev2_default_ike_transforms,
		    ikev2_default_nike_transforms);
		prop[0].prop_nxforms = j;
		prop[0].prop_xforms = ikexforms;
	}
	TAILQ_INSERT_TAIL(&pol.pol_proposals, &prop[0], prop_entry);

	prop[1].prop_id = ++pol.pol_nproposals;
	prop[1].prop_protoid = saproto;
	if (ipsec_sa == NULL || ipsec_sa->xfs == NULL) {
		prop[1].prop_nxforms = ikev2_default_nesp_transforms;
		prop[1].prop_xforms = ikev2_default_esp_transforms;
	} else {
		j = 0;
		if (ipsec_sa->xfs->encxf && ipsec_sa->xfs->encxf->noauth &&
		    ipsec_sa->xfs->authxf) {
			yyerror("authentication is implicit for %s",
			    ipsec_sa->xfs->encxf->name);
			return (-1);
		}
		if (ipsec_sa->xfs->encxf == NULL ||
		    (ipsec_sa->xfs->encxf && !ipsec_sa->xfs->encxf->noauth))
			copy_transforms(IKEV2_XFORMTYPE_INTEGR,
			    ipsec_sa->xfs->authxf, authxfs,
			    ipsecxforms, nitems(ipsecxforms), &j,
			    ikev2_default_esp_transforms,
			    ikev2_default_nesp_transforms);
		copy_transforms(IKEV2_XFORMTYPE_ENCR,
		    ipsec_sa->xfs->encxf, ipsecencxfs,
		    ipsecxforms, nitems(ipsecxforms), &j,
		    ikev2_default_esp_transforms,
		    ikev2_default_nesp_transforms);
		copy_transforms(IKEV2_XFORMTYPE_DH,
		    ipsec_sa->xfs->groupxf, groupxfs,
		    ipsecxforms, nitems(ipsecxforms), &j,
		    ikev2_default_esp_transforms,
		    ikev2_default_nesp_transforms);
		copy_transforms(IKEV2_XFORMTYPE_ESN,
		    NULL, NULL,
		    ipsecxforms, nitems(ipsecxforms), &j,
		    ikev2_default_esp_transforms,
		    ikev2_default_nesp_transforms);
		prop[1].prop_nxforms = j;
		prop[1].prop_xforms = ipsecxforms;
	}
	TAILQ_INSERT_TAIL(&pol.pol_proposals, &prop[1], prop_entry);

	if (hosts == NULL || hosts->src == NULL || hosts->dst == NULL)
		fatalx("create_ike: no traffic selectors/flows");

	for (j = 0, ipa = hosts->src, ipb = hosts->dst; ipa && ipb;
	    ipa = ipa->next, ipb = ipb->next, j++) {
		if (j >= nitems(flows))
			fatalx("create_ike: too many flows");
		memcpy(&flows[j].flow_src.addr, &ipa->address,
		    sizeof(ipa->address));
		flows[j].flow_src.addr_af = ipa->af;
		flows[j].flow_src.addr_mask = ipa->mask;
		flows[j].flow_src.addr_net = ipa->netaddress;
		flows[j].flow_src.addr_port = hosts->sport;

		memcpy(&flows[j].flow_dst.addr, &ipb->address,
		    sizeof(ipb->address));
		flows[j].flow_dst.addr_af = ipb->af;
		flows[j].flow_dst.addr_mask = ipb->mask;
		flows[j].flow_dst.addr_net = ipb->netaddress;
		flows[j].flow_dst.addr_port = hosts->dport;

		ippn = ipa->srcnat;
		if (ippn) {
			memcpy(&flows[j].flow_prenat.addr, &ippn->address,
			    sizeof(ippn->address));
			flows[j].flow_prenat.addr_af = ippn->af;
			flows[j].flow_prenat.addr_mask = ippn->mask;
			flows[j].flow_prenat.addr_net = ippn->netaddress;
		} else {
			flows[j].flow_prenat.addr_af = 0;
		}

		flows[j].flow_ipproto = ipproto;

		if (RB_INSERT(iked_flows, &pol.pol_flows, &flows[j]) == NULL)
			pol.pol_nflows++;
		else
			warnx("create_ike: duplicate flow");
	}

	for (j = 0, ipa = ikecfg; ipa; ipa = ipa->next, j++) {
		if (j >= IKED_CFG_MAX)
			break;
		cfg = &pol.pol_cfg[j];
		pol.pol_ncfg++;

		cfg->cfg_action = ipa->action;
		cfg->cfg_type = ipa->type;
		memcpy(&cfg->cfg.address.addr, &ipa->address,
		    sizeof(ipa->address));
		cfg->cfg.address.addr_mask = ipa->mask;
		cfg->cfg.address.addr_net = ipa->netaddress;
		cfg->cfg.address.addr_af = ipa->af;
	}

	if (dstid) {
		strlcpy(idstr, dstid, sizeof(idstr));
		idtype = pol.pol_peerid.id_type;
	} else if (!pol.pol_peer.addr_net) {
		print_host((struct sockaddr *)&pol.pol_peer.addr, idstr,
		    sizeof(idstr));
		switch (pol.pol_peer.addr.ss_family) {
		case AF_INET:
			idtype = IKEV2_ID_IPV4;
			break;
		case AF_INET6:
			idtype = IKEV2_ID_IPV6;
			break;
		default:
			log_warnx("%s: unknown address family", __func__);
			break;
		}
	}

	/* Make sure that we know how to authenticate this peer */
	if (idtype && set_policy(idstr, idtype, &pol) < 0) {
		log_debug("%s: set_policy failed", __func__);
		return (-1);
	}

	config_setpolicy(env, &pol, PROC_IKEV2);
	config_setflow(env, &pol, PROC_IKEV2);

	rules++;
	return (0);
}

int
create_user(const char *user, const char *pass)
{
	struct iked_user	 usr;

	bzero(&usr, sizeof(usr));

	if (*user == '\0' || (strlcpy(usr.usr_name, user,
	    sizeof(usr.usr_name)) >= sizeof(usr.usr_name))) {
		yyerror("invalid user name");
		return (-1);
	}
	if (*pass == '\0' || (strlcpy(usr.usr_pass, pass,
	    sizeof(usr.usr_pass)) >= sizeof(usr.usr_pass))) {
		yyerror("invalid password");
		return (-1);
	}

	config_setuser(env, &usr, PROC_IKEV2);

	rules++;
	return (0);
}
@


1.63
log
@Factor out flows into separate configuration messages

We reach an imsg payload limit with just a few traffic selectors
so in order to load more we need to split them up and send separately.

Suggested and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2017/03/27 10:06:41 reyk Exp $	*/
d382 1
a382 1
%token	FROM ESP AH IN PEER ON OUT TO SRCID DSTID RSA PSK PORT
a1137 1
		{ "rsa",		RSA },
@


1.62
log
@Add support for RFC4754 (ECDSA) and RFC7427 authentication.

These modes provide stronger and more flexible ways for
authentication: while RSA public key auth relies on SHA-1 hashes, the
news modes use SHA2-256 and up to SHA2-512 hashes.

Original diff from markus@@ with patches from mikeb@@ and me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2017/01/20 13:56:51 mikeb Exp $	*/
d2862 1
@


1.61
log
@Check bounds of the flows array when configuring traffic selectors

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2017/01/05 12:42:18 krw Exp $	*/
d34 3
d65 5
a72 1
int		 check_pubkey(char *, int );
d252 1
d254 5
a258 4
	{ "dss",		IKEV2_AUTH_DSS_SIG },
	{ "ecdsa-256",		IKEV2_AUTH_ECDSA_256 },
	{ "ecdsa-384",		IKEV2_AUTH_ECDSA_384 },
	{ "ecdsa-521",		IKEV2_AUTH_ECDSA_521 },
d817 1
a817 6
			$$.auth_method = IKEV2_AUTH_RSA_SIG;
			$$.auth_eap = 0;
			$$.auth_length = 0;
		}
		| RSA				{
			$$.auth_method = IKEV2_AUTH_RSA_SIG;
d844 15
d1684 42
d1727 81
a1807 1
check_pubkey(char *idstr, int type)
d1810 2
a1811 2
	FILE		*fp = NULL;
	const char	*suffix = NULL;
d1815 1
a1815 1
		suffix = "ipv4";
d1818 1
a1818 1
		suffix = "ipv6";
d1821 1
a1821 1
		suffix = "fqdn";
d1824 1
a1824 1
		suffix = "ufqdn";
d1828 1
d1834 1
a1834 1
	    IKED_CA IKED_PUBKEY_DIR "%s/%s", suffix,
d1840 9
a1848 1
	if ((fp = fopen(keyfile, "r")) == NULL)
d1850 1
a1850 1
	fclose(fp);
d1852 4
a1855 1
	log_debug("%s: found public key file %s", __func__, keyfile);
d2497 10
a2506 6
	if (pol->pol_auth.auth_method == IKEV2_AUTH_SHARED_KEY_MIC) {
			print_verbose(" psk 0x");
			for (i = 0; i < pol->pol_auth.auth_length; i++)
				print_verbose("%02x",
				    pol->pol_auth.auth_data[i]);
	} else {
d2855 5
a2859 3
	/* Check if we have a raw public key for this peer */
	if (check_pubkey(idstr, idtype) != -1)
		pol.pol_certreqtype = IKEV2_CERT_RSA_KEY;
@


1.60
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2017/01/04 12:31:01 mikeb Exp $	*/
d458 2
a459 1
			    $16, $15) == -1)
d461 1
d2429 3
d2629 2
d2658 4
a2661 2
		pol.pol_nflows++;
		RB_INSERT(iked_flows, &pol.pol_flows, &flows[j]);
@


1.59
log
@Remove modular exponential groups specified in RFC5114

Brought up by doug@@, ok reyk, djm, doug
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2016/09/03 09:20:07 vgross Exp $	*/
d1516 4
a1519 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1578 1
a1578 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1583 1
@


1.58
log
@Add the missing bits to have NAT on enc(4) support in iked.

Ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2016/08/06 07:08:59 pascal Exp $	*/
a127 1
	{ IKEV2_XFORMTYPE_DH,	IKEV2_XFORMDH_MODP_2048_256 },
a227 6
	{ "modp1024-160",	IKEV2_XFORMDH_MODP_1024_160 },
	{ "grp22",		IKEV2_XFORMDH_MODP_1024_160 },
	{ "modp2048-224",	IKEV2_XFORMDH_MODP_2048_224 },
	{ "grp23",		IKEV2_XFORMDH_MODP_2048_224 },
	{ "modp2048-256",	IKEV2_XFORMDH_MODP_2048_256 },
	{ "grp24",		IKEV2_XFORMDH_MODP_2048_256 },
@


1.57
log
@Unbreak PSK authentication, broken by previous.

ok reyk@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2016/07/20 12:31:00 reyk Exp $	*/
d2421 1
a2421 1
	struct ipsec_addr_wrap	*ipa, *ipb;
d2642 11
@


1.56
log
@When parsing the configuration. initialize the auth structure
correctly, as parse.y's $$ is not zero-initialized.

Found by Rene Ammerlaan

OK markus@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2016/06/21 21:35:24 benno Exp $	*/
a825 1
			$$.auth_length = 0;
@


1.56.2.1
log
@During parsing of the iked(8) configuration, a variable is set to 0 by
mistake, disabling Pre-Shared key authentication.
MFC v 1.57 sbin/iked/parse.y from pascal@@
ok florian@@ pascal@@ tj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2016/07/20 12:31:00 reyk Exp $	*/
d826 1
@


1.55
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2015/12/09 21:41:49 naddy Exp $	*/
d814 1
d819 1
d825 2
@


1.54
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2015/11/04 12:40:49 mikeb Exp $	*/
d1008 1
d1010 7
@


1.53
log
@Support Chacha20-Poly1305 for Child SAs;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2015/10/31 19:28:19 naddy Exp $	*/
a179 1
	{ "des",		IKEV2_XFORMENCR_DES,		8 },
@


1.52
log
@RFC4754 specifies ECDSA-521 (sic), not -512.  ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2015/10/02 16:56:34 reyk Exp $	*/
d197 2
@


1.51
log
@Remove MD5 from the default proposals.  At least SHA1 seems to be the
minimum out there.  Even El Capitan announces 3DES and SHA1 instead of MD5.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2015/08/21 11:59:28 reyk Exp $	*/
d255 1
a255 1
	{ "ecdsa-512",		IKEV2_AUTH_ECDSA_512 },
@


1.50
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2015/08/19 14:12:43 reyk Exp $	*/
a125 1
	{ IKEV2_XFORMTYPE_PRF,	IKEV2_XFORMPRF_HMAC_MD5 },
a127 1
	{ IKEV2_XFORMTYPE_INTEGR, IKEV2_XFORMAUTH_HMAC_MD5_96 },
@


1.49
log
@spacing (no binary change, verified with checksums)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2015/07/03 17:46:52 mikeb Exp $	*/
d99 5
a103 5
	u_int		 id;
	u_int		 length;
	u_int		 keylength;
	u_int		 nonce;
	u_int		 noauth;
d116 1
a116 1
	u_int8_t		 ike_exch;
d291 1
a291 1
	u_int8_t		 mask;
d294 2
a295 2
	u_int			 type;
	u_int			 action;
d305 2
a306 2
	u_int16_t		 sport;
	u_int16_t		 dport;
d310 2
a311 2
	char	*tag;
	u_int	 tap;
d324 6
a329 4
void			 set_ipmask(struct ipsec_addr_wrap *, u_int8_t);
const struct ipsec_xf	*parse_xf(const char *, u_int, const struct ipsec_xf *);
const char		*print_xf(u_int, u_int, const struct ipsec_xf *);
void			 copy_transforms(u_int, const struct ipsec_xf *,
d332 8
a339 8
			    u_int *, struct iked_transform *, size_t);
int			 create_ike(char *, int, u_int8_t, struct ipsec_hosts *,
			     struct ipsec_hosts *, struct ipsec_mode *,
			     struct ipsec_mode *, u_int8_t,
			     u_int8_t, char *, char *,
			     u_int32_t, struct iked_lifetime *,
			     struct iked_auth *, struct ipsec_filters *,
			     struct ipsec_addr_wrap *);
d342 1
a342 1
u_int8_t		 x2i(unsigned char *);
d352 4
a355 4
		u_int8_t		 ikemode;
		u_int8_t		 dir;
		u_int8_t		 satype;
		u_int8_t		 proto;
d357 1
a357 1
		u_int16_t		 port;
d368 1
a368 1
		u_int8_t		 type;
d826 1
a826 1
			u_int	 i;
d849 1
a849 1
			u_int64_t	 bytes = 0;
d878 1
a878 1
			u_int64_t	 seconds = 0;
d921 1
a921 1
			u_int8_t	*hex;
d1145 4
a1148 4
u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;
d1240 4
a1243 4
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;
d1582 1
a1582 1
u_int8_t
d1595 1
a1595 1
	return ((u_int8_t)strtoul(ss, NULL, 16));
d1601 1
a1601 1
	u_int		  i;
d2053 1
a2053 1
	u_int8_t		*s6;
d2078 1
a2078 1
			s6 = (u_int8_t *)&in6->sin6_addr.s6_addr;
d2082 1
a2082 1
				u_int16_t	 tmp16;
d2115 1
a2115 1
set_ipmask(struct ipsec_addr_wrap *address, u_int8_t b)
d2121 1
a2121 1
parse_xf(const char *name, u_int length, const struct ipsec_xf xfs[])
d2135 1
a2135 1
print_xf(u_int id, u_int length, const struct ipsec_xf xfs[])
d2149 1
a2149 1
keylength_xf(u_int saproto, u_int type, u_int id)
d2176 1
a2176 1
noncelength_xf(u_int type, u_int id)
d2203 1
a2203 1
	u_int			 i, j;
d2369 1
a2369 1
copy_transforms(u_int type, const struct ipsec_xf *xf,
d2372 1
a2372 1
    u_int *n, struct iked_transform *src, size_t nsrc)
d2374 1
a2374 1
	u_int			 i;
d2401 1
a2401 1
create_ike(char *name, int af, u_int8_t ipproto, struct ipsec_hosts *hosts,
d2403 3
a2405 3
    struct ipsec_mode *ipsec_sa, u_int8_t saproto,
    u_int8_t flags, char *srcid, char *dstid,
    u_int32_t ikelifetime, struct iked_lifetime *lt,
d2410 1
a2410 1
	u_int			 idtype = IKEV2_ID_NONE;
d2414 1
a2414 1
	u_int			 j;
d2417 1
a2417 1
	static u_int		 policy_id = 0;
@


1.48
log
@Terminate 'config' keyword array with a NULL element.
Reported by trondd at kagu-tsuchi ! com, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2015/06/03 02:24:36 millert Exp $	*/
d460 2
a461 1
		    ike_sa child_sa ids ikelifetime lifetime ikeauth ikecfg filters {
d463 2
a464 1
			    $11.srcid, $11.dstid, $12, &$13, &$14, $16, $15) == -1)
d1169 2
a1170 1
			yyerror("reached end of file while parsing quoted string");
d2408 1
a2408 1
	u_int 			 idtype = IKEV2_ID_NONE;
@


1.47
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2015/02/08 04:50:32 reyk Exp $	*/
d280 2
a281 1
	{ "access-server", IKEV2_CFG_INTERNAL_IP6_SERVER,	AF_INET6 }
@


1.46
log
@Use AI_ADDRCONFIG when resolv hosts on startup.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2015/01/19 14:42:42 mikeb Exp $	*/
d1773 6
a1778 5
		asprintf(&ipa->name, "%s/%d", hbuf, prefixlen);
	} else
		ipa->name = strdup(hbuf);
	if (ipa->name == NULL)
		err(1, "host_v6: strdup");
@


1.45
log
@Remove unnecessary <netinet/ip_ipsp.h> includes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2015/01/16 06:39:58 deraadt Exp $	*/
d1834 1
@


1.44
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2015/01/12 11:24:58 mikeb Exp $	*/
a31 1
#include <netinet/ip_ipsp.h>
@


1.43
log
@Don't forget about protocol specification when configuring flows.

Tested by and OK claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2014/11/20 05:51:20 jsg Exp $	*/
d1656 1
a1656 1
	char		 keyfile[MAXPATHLEN];
@


1.42
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2014/11/14 03:22:47 doug Exp $	*/
d2625 2
@


1.41
log
@Add gcc printf format attributes to iked's parse.y and remove unused
yywarn() definition.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2014/08/27 10:28:57 reyk Exp $	*/
d1299 3
@


1.40
log
@Add support for Curve25519 using the public domain code that is found
in OpenSSH.  The "private use" DH group 1034 is based on the value
that was picked by strongswan recently.

OK mikeb@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2014/08/25 14:36:10 reyk Exp $	*/
d69 3
a71 2
int		 yyerror(const char *, ...);
int		 yywarn(const char *, ...);
a1053 13
	va_start(ap, fmt);
	fprintf(stderr, "%s: %d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
yywarn(const char *fmt, ...)
{
	va_list		 ap;

@


1.39
log
@Add support for DH groups 27-30 using the Brainpool curves which have
previously been added to LibreSSL's libcrypto.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2014/05/06 10:24:22 markus Exp $	*/
d248 1
@


1.38
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2014/02/17 15:07:23 markus Exp $	*/
d240 8
@


1.37
log
@basic OCSP support. enable with 'set ocsp "http://10.0.0.10:8888/"'
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2014/02/14 09:00:03 markus Exp $	*/
d324 2
a325 1
			     u_int8_t, char *, char *, struct iked_lifetime *,
d374 1
a374 1
%token	IPCOMP OCSP
d396 1
a396 1
%type	<v.number>		byte_spec time_spec
d450 1
a450 1
		    ike_sa child_sa ids lifetime ikeauth ikecfg filters {
d452 1
a452 1
			    $11.srcid, $11.dstid, &$12, &$13, $15, $14) == -1)
d899 7
d1095 1
d2324 3
d2397 2
a2398 1
    u_int8_t flags, char *srcid, char *dstid, struct iked_lifetime *lt,
d2523 3
@


1.36
log
@initial support for IPComp
still experimental and rekeying needs some work; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2014/01/22 00:21:16 henning Exp $	*/
d95 1
d373 1
a373 1
%token	IPCOMP
d434 6
d1096 1
d1471 1
@


1.35
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2013/11/28 20:21:17 markus Exp $	*/
d372 1
d389 1
a389 1
%type	<v.ikemode>		ikeflags ikematch ikemode
d756 1
a756 1
				err(1, "child_sa: calloc");
d773 1
a773 1
ikeflags	: ikematch ikemode		{ $$ = $1 | $2; }
d787 4
d1085 1
@


1.34
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1371 2
a1372 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
@


1.33
log
@support raw pubkey authentication w/o x509 certificates;
mostly by Michael Cardell Widerkrantz, reyk@@ and mikeb@@; ok mike@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2013/11/25 13:12:23 benno Exp $	*/
d2206 2
a2207 1
		    print_host(&flow->flow_src.addr, NULL, 0));
d2216 2
a2217 1
		    print_host(&flow->flow_dst.addr, NULL, 0));
d2228 2
a2229 1
		    print_host(&pol->pol_local.addr, NULL, 0));
d2235 2
a2236 1
		    print_host(&pol->pol_peer.addr, NULL, 0));
d2321 2
a2322 1
		    print_host(&cfg->cfg.address.addr, NULL, 0));
d2618 2
a2619 1
		print_host(&pol.pol_peer.addr, idstr, sizeof(idstr));
@


1.32
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2013/11/22 04:12:47 deraadt Exp $	*/
d66 1
d1629 42
d2369 2
d2382 1
d2385 1
d2608 22
@


1.31
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2013/03/21 04:30:14 deraadt Exp $	*/
d1120 1
a1120 1
char	*parsebuf;
d1122 1
a1122 1
char	 pushback_buffer[MAXPUSHBACK];
d1214 2
a1215 2
	char	 buf[8096];
	char	*p, *val;
d1238 1
a1238 1
				*p++ = (char)c;
d1283 1
a1283 1
			*p++ = (char)c;
@


1.30
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2013/01/08 10:38:19 reyk Exp $	*/
d828 1
a828 1
			switch (toupper(unit)) {
d857 1
a857 1
			switch (tolower(unit)) {
@


1.29
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2012/10/25 15:01:56 reyk Exp $	*/
a24 1
#include <sys/param.h>
@


1.28
log
@Move the arrays of default IKE and ESP transforms into parse.y instead
of generating them with genmap from ikev2.h.  They're only really
needed in parse.y and this diff also allows to simplify genmap.sh.
@
text
@d1 1
a1 2
/*	$OpenBSD: parse.y,v 1.27 2012/09/18 12:07:59 reyk Exp $	*/
/*	$vantronix: parse.y,v 1.22 2010/06/03 11:08:34 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.27
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2012/06/30 14:51:31 naddy Exp $	*/
d118 33
@


1.26
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2012/06/29 15:05:49 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.25
log
@Add missing ESN bits
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2012/05/08 08:53:14 mikeb Exp $	*/
d155 3
a157 1
	{ "aes-ctr",		IKEV2_XFORMENCR_AES_CTR,	16, 16, 4 },
@


1.24
log
@rename espxforms to ipsecxforms for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2012/03/24 00:40:25 jsg Exp $	*/
d111 1
@


1.23
log
@fix some leaks
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2011/05/27 12:01:02 reyk Exp $	*/
d2296 1
a2296 1
	struct iked_transform	 ikexforms[64], espxforms[64];
d2467 1
a2467 1
			    espxforms, nitems(espxforms), &j,
d2472 1
a2472 1
		    espxforms, nitems(espxforms), &j,
d2477 1
a2477 1
		    espxforms, nitems(espxforms), &j,
d2482 1
a2482 1
		    espxforms, nitems(espxforms), &j,
d2486 1
a2486 1
		prop[1].prop_xforms = espxforms;
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2011/04/18 08:45:43 reyk Exp $	*/
d1554 1
a1554 1
	int		 fd;
d1569 3
a1571 1
	return (parsekey(hex, sb.st_size, auth));
@


1.21
log
@When the kernel wants to acquire an SA for an unknown flow, lookup a
matching policy and init a new IKE SA.  This adds support for "acquire mode"
from static flows.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2011/01/21 11:56:00 reyk Exp $	*/
d152 3
a154 3
	{ "aes-192",		IKEV2_XFORMENCR_AES_CBC, 	24, 24 },
	{ "aes-256",		IKEV2_XFORMENCR_AES_CBC, 	32, 32 },
	{ "aes-ctr",		IKEV2_XFORMENCR_AES_CTR, 	16, 16, 4 },
d716 1
a716 1
		| IKESA 		{
d728 1
a728 1
		| CHILDSA 		{
d730 1
a730 1
		} transforms		{
@


1.20
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2011/01/17 17:16:43 mikeb Exp $	*/
d2125 1
a2125 1
	TAILQ_FOREACH(flow, &pol->pol_flows, flow_entry) {
d2414 1
a2414 1
	TAILQ_INIT(&pol.pol_flows);
d2508 1
a2508 1
		TAILQ_INSERT_TAIL(&pol.pol_flows, &flows[j], flow_entry);
@


1.19
log
@move mask2prefixlen functions to the util module;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2010/12/23 16:39:38 mikeb Exp $	*/
d285 1
a285 1
int			 create_ike(char *, u_int8_t, struct ipsec_hosts *,
d336 1
a336 1
%token	INCLUDE LIFETIME BYTES
d345 1
a345 1
%type	<v.number>		portval
d353 1
a353 1
%type	<v.ikemode>		ikemode
d405 1
a405 1
ikev2rule	: IKEV2 name ikemode satype proto hosts_list peers
d407 2
a408 2
			if (create_ike($2, $5, $6, &$7, $8, $9, $4, $3,
			    $10.srcid, $10.dstid, &$11, &$12, $14, $13) == -1)
d456 5
d737 9
d1030 1
d1043 2
d1054 1
d1058 1
d2103 5
d2118 7
d2147 4
a2150 4
		    print_host(&pol->pol_local, NULL, 0));
		if (pol->pol_local.ss_family != AF_UNSPEC &&
		    pol->pol_localnet)
			print_verbose("/%d", pol->pol_localmask);
d2153 4
a2156 4
		    print_host(&pol->pol_peer, NULL, 0));
		if (pol->pol_peer.ss_family != AF_UNSPEC &&
		    pol->pol_peernet)
			print_verbose("/%d", pol->pol_peermask);
d2283 1
a2283 1
create_ike(char *name, u_int8_t ipproto, struct ipsec_hosts *hosts,
d2286 1
a2286 1
    u_int8_t mode, char *srcid, char *dstid, struct iked_lifetime *lt,
d2303 1
d2306 1
a2306 1
	pol.pol_flags = mode;
d2350 1
a2350 1
		pol.pol_flags |= IKED_POLICY_DEFAULT;
d2356 8
a2363 1
		fatalx("create_ike: address family mismatch");
d2390 7
a2396 3
		memcpy(&pol.pol_local, &ipa->address, sizeof(pol.pol_local));
		pol.pol_localmask = ipa->mask;
		pol.pol_localnet = ipa->netaddress;
d2399 7
a2405 3
		memcpy(&pol.pol_peer, &ipb->address, sizeof(pol.pol_peer));
		pol.pol_peermask = ipb->mask;
		pol.pol_peernet = ipb->netaddress;
@


1.18
log
@pick netmask instead of address when we mean it; found by dhill, ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2010/12/22 16:40:06 reyk Exp $	*/
a273 2
u_int8_t		 mask2prefixlen(struct sockaddr_in *);
u_int8_t		 mask2prefixlen6(struct sockaddr_in6 *);
a1793 59
u_int8_t
mask2prefixlen(struct sockaddr_in *sa_in)
{
	in_addr_t ina = sa_in->sin_addr.s_addr;

	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

u_int8_t
mask2prefixlen6(struct sockaddr_in6 *sa_in6)
{
	u_int8_t	 l = 0, *ap, *ep;

	/*
	 * sin6_len is the size of the sockaddr so substract the offset of
	 * the possibly truncated sin6_addr struct.
	 */
	ap = (u_int8_t *)&sa_in6->sin6_addr;
	ep = (u_int8_t *)sa_in6 + sa_in6->sin6_len;
	for (; ap < ep; ap++) {
		/* this "beauty" is adopted from sbin/route/show.c ... */
		switch (*ap) {
		case 0xff:
			l += 8;
			break;
		case 0xfe:
			l += 7;
			return (l);
		case 0xfc:
			l += 6;
			return (l);
		case 0xf8:
			l += 5;
			return (l);
		case 0xf0:
			l += 4;
			return (l);
		case 0xe0:
			l += 3;
			return (l);
		case 0xc0:
			l += 2;
			return (l);
		case 0x80:
			l += 1;
			return (l);
		case 0x00:
			return (l);
		default:
			fatalx("non continguous inet6 netmask");
		}
	}

	return (l);
}

d1824 1
a1824 1
			n->mask = mask2prefixlen(sa_in);
d1829 1
a1829 1
			n->mask = mask2prefixlen6(sa_in6);
@


1.17
log
@Tweak the grammar a little bit by requiring a "bytes" keyword before the
bytes value ("lifetime 123 bytes 456" instead of "lifetime 123 456").
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2010/12/22 16:22:27 mikeb Exp $	*/
d1884 1
d1889 1
@


1.16
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2010/12/21 14:28:58 mikeb Exp $	*/
d338 1
a338 1
%token	INCLUDE LIFETIME
d771 1
a771 4
byte_spec	: /* empty */			{
			$$ = deflifetime.lt_bytes;
		}
		| NUMBER			{
d782 1
a782 1
			switch (unit) {
a783 1
			case 'k':
a786 1
			case 'm':
a789 1
			case 'g':
d811 1
a811 2
			switch (unit) {
			case 'M':
a814 1
			case 'H':
d826 1
a826 1
lifetime	: /* empty */			{
d829 1
a829 2
		| LIFETIME time_spec byte_spec	{
			$$.lt_bytes = $3;
d831 1
d833 5
d1013 1
d2245 2
a2246 2
	print_verbose(" lifetime %d %d", pol->pol_lifetime.lt_seconds,
	    pol->pol_lifetime.lt_bytes);
@


1.15
log
@Convert netmask from sockaddr to prefixlen correctly as noticed
by axel rau, axel dot rau at chaos1 dot de.  The actual convert
functions are taken from bgpd(8).  OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2010/11/17 16:43:45 ckuethe Exp $	*/
d238 5
d290 3
a292 2
			     u_int8_t, char *, char *, struct iked_auth *,
			     struct ipsec_filters *, struct ipsec_addr_wrap *);
d322 1
d338 1
a338 1
%token	INCLUDE
d359 2
d403 1
a403 1
				YYERROR;		
d408 1
a408 1
		    ike_sa child_sa ids ikeauth ikecfg filters {
d410 1
a410 1
			    $10.srcid, $10.dstid, &$11, $13, $12) == -1)
d757 1
a757 1
	
d771 71
d1032 1
d2247 3
d2316 1
a2316 1
    u_int8_t mode, char *srcid, char *dstid,
d2421 5
@


1.14
log
@Allow the -D command line flag to actually define macros.
ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2010/09/23 11:42:36 mikeb Exp $	*/
d269 2
d1717 59
d1785 2
d1803 3
a1805 5
			n->af = AF_INET;
			memcpy(&n->address, ifa->ifa_addr,
			    sizeof(struct sockaddr_in));
			memcpy(&n->mask, ifa->ifa_addr,
			    sizeof(struct sockaddr_in));
d1807 3
a1809 5
			n->af = AF_INET6;
			memcpy(&n->address, ifa->ifa_addr,
			    sizeof(struct sockaddr_in6));
			memcpy(&n->mask, ifa->ifa_addr,
			    sizeof(struct sockaddr_in6));
@


1.13
log
@support for aes-gcm

OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2010/09/09 13:06:46 mikeb Exp $	*/
a87 1
int		 cmdline_symset(char *);
@


1.12
log
@- allow esp proposals without integrity and ah proposals without
  encryption;

- add additional nonce length field, use that for the ciphers that
  require additional keying material;

- setup right flow direction depending on the mode: fixes up iked
  working as an initiator against charon.

tested by me and jsg.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2010/08/03 18:42:40 henning Exp $	*/
d104 1
d156 6
d2322 13
a2334 5
		copy_transforms(IKEV2_XFORMTYPE_INTEGR,
		    ipsec_sa->xfs->authxf, authxfs,
		    espxforms, nitems(espxforms), &j,
		    ikev2_default_esp_transforms,
		    ikev2_default_nesp_transforms);
@


1.11
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2010/07/22 17:16:45 jsg Exp $	*/
d103 1
d154 1
a154 1
	{ "aes-ctr",		IKEV2_XFORMENCR_AES_CTR, 	20, 20 },
d1958 15
@


1.10
log
@Don't deref a NULL pointer if tap or tag are not specified in the
config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2010/07/01 02:15:08 reyk Exp $	*/
d1131 2
a1132 1
				else if (next == '\n')
d1134 1
a1134 1
				else
@


1.9
log
@Add support for the tap extension (ikev2 ... tap "enc1") that will
tell the kernel to send all IPsec traffic for derived SAs to the
specified enc(4) interface instead of enc0.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2010/06/26 19:48:04 reyk Exp $	*/
d2202 5
a2206 3
	if (filter->tag)
		strlcpy(pol.pol_tag, filter->tag, sizeof(pol.pol_tag));
	pol.pol_tap = filter->tap;
@


1.8
log
@mixing any (AF_UNSPEC) with AF_INET/INET6 is not an address family mismatch
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2010/06/26 18:32:34 reyk Exp $	*/
d251 5
d277 1
a277 1
			     char *, struct ipsec_addr_wrap *);
d285 1
d310 1
d320 1
a320 1
%token	PASSIVE ACTIVE ANY TAG PROTO LOCAL GROUP NAME CONFIG EAP USER
d338 1
a342 1
%type	<v.string>		tag
d390 1
a390 1
		    ike_sa child_sa ids ikeauth ikecfg tag {
d786 18
a803 1
tag		: /* empty */
d805 1
a805 1
			$$ = NULL;
d807 1
a807 1
		| TAG STRING
d809 18
a826 1
			$$ = $2;
d956 1
d2108 3
d2151 2
a2152 1
    struct iked_auth *authtype, char *tag, struct ipsec_addr_wrap *ikecfg)
d2201 4
a2204 2
	if (tag)
		strlcpy(pol.pol_tag, tag, sizeof(pol.pol_tag));
@


1.7
log
@Include the Id type in the generated SA tag that is passed to the
kernel, just like isakmpd does it.  In difference to isakmpd, the Id
type is printed in capital letters, eg. FQDN/foo.example.com, because
it is using the existing print_map() API.  For consistency, rename a
few Id types in grammar and code from the RFC-names to the
OpenBSD-style names; including RFC822_ADDR to UFQDN, IPV4_ADDR to just
IPV4, DER_ASN1_DN to ASN1_DN etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2010/06/15 00:41:04 reyk Exp $	*/
d589 2
a590 1
			if ($3->af != $1->af) {
d2167 2
a2168 1
	    peers->src->af != peers->dst->af)
@


1.6
log
@rename the ec groups to either ec2n or ecp (eg. ec155 -> ec2n155 or
ec521 -> ecp521).  this matches the common naming for ec groups better.
@
text
@d1432 1
a1432 1
		return (IKEV2_ID_DER_ASN1_DN);
d1434 1
a1434 1
		return (IKEV2_ID_IPV4_ADDR);
d1436 1
a1436 1
		return (IKEV2_ID_IPV6_ADDR);
d1438 1
a1438 1
		return (IKEV2_ID_RFC822_ADDR);
@


1.5
log
@fix keyword sort order
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2010/06/14 18:39:04 reyk Exp $	*/
d165 4
a168 4
	{ "ec155",		IKEV2_XFORMDH_EC_155 },
	{ "grp3",		IKEV2_XFORMDH_EC_155 },
	{ "ec185",		IKEV2_XFORMDH_EC_185 },
	{ "grp4",		IKEV2_XFORMDH_EC_185 },
d181 6
a186 6
	{ "ec256",		IKEV2_XFORMDH_EC_256 },
	{ "grp19",		IKEV2_XFORMDH_EC_256 },
	{ "ec384",		IKEV2_XFORMDH_EC_384 },
	{ "grp20",		IKEV2_XFORMDH_EC_384 },
	{ "ec521",		IKEV2_XFORMDH_EC_521 },
	{ "grp21",		IKEV2_XFORMDH_EC_521 },
d193 4
a196 4
	{ "ec192",		IKEV2_XFORMDH_EC_192 },
	{ "grp25",		IKEV2_XFORMDH_EC_192 },
	{ "ec224",		IKEV2_XFORMDH_EC_224 },
	{ "grp26",		IKEV2_XFORMDH_EC_224 },
@


1.4
log
@the ikesa prf config option is currently broken
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2010/06/10 14:17:48 reyk Exp $	*/
d897 1
a898 1
		{ "ike",		IKEV1 },
d906 1
a906 1
/* XXX		{ "prf",		PRFXF }, */
@


1.3
log
@Add the -S flag which does the same as "set passive" but matches the
isakmpd flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2010/06/10 14:08:37 reyk Exp $	*/
d906 1
@


1.2
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d1262 3
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.146 2009/08/04 15:05:50 jsing Exp $	*/
d95 2
d314 1
a314 1
%token	IKEV1 FLOW SA TCPMD5 TUNNEL TRANSPORT
d343 1
d370 6
d887 2
d910 1
d1261 2
d1266 3
@

