head	1.61;
access;
symbols
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14;
locks; strict;
comment	@ * @;


1.61
date	2017.03.27.17.17.49;	author mikeb;	state Exp;
branches;
next	1.60;
commitid	Bk5vOJlj7LPPcjYU;

1.60
date	2017.03.27.10.21.19;	author reyk;	state Exp;
branches;
next	1.59;
commitid	luuYVyfWc8UoYDKf;

1.59
date	2017.03.13.18.48.16;	author mikeb;	state Exp;
branches;
next	1.58;
commitid	yVaAm7edeFc8tc7a;

1.58
date	2017.03.13.14.50.52;	author mikeb;	state Exp;
branches;
next	1.57;
commitid	uv0nHhZFFqaa33vB;

1.57
date	2017.01.20.13.49.48;	author mikeb;	state Exp;
branches;
next	1.56;
commitid	VvyGEicIAkgPmKnq;

1.56
date	2017.01.20.13.47.17;	author mikeb;	state Exp;
branches;
next	1.55;
commitid	QPo1SvDIRu4KNBVd;

1.55
date	2015.10.15.18.40.38;	author mmcc;	state Exp;
branches;
next	1.54;
commitid	rQFz7wM8cPpo2dCG;

1.54
date	2015.10.01.13.57.29;	author sthen;	state Exp;
branches;
next	1.53;
commitid	kAqiqUVYN2Yh67Hb;

1.53
date	2015.10.01.10.59.23;	author reyk;	state Exp;
branches;
next	1.52;
commitid	J33WGURgnlsCAOFp;

1.52
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.51;
commitid	CNs9dXqQUQ09vB19;

1.51
date	2015.08.19.14.12.43;	author reyk;	state Exp;
branches;
next	1.50;
commitid	AVPSAC8CcLDWTPgE;

1.50
date	2015.03.26.19.52.35;	author markus;	state Exp;
branches;
next	1.49;
commitid	OLM4J0heQ8InGopV;

1.49
date	2015.02.06.10.39.01;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	fN2B4abgRqE4hFJn;

1.48
date	2015.01.19.14.42.42;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	6zq5j7t9YeU29dry;

1.47
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Uu5nFG3wCl0LACBb;

1.46
date	2014.11.07.14.05.58;	author mikeb;	state Exp;
branches;
next	1.45;
commitid	NwAG6ws8zofUUdum;

1.45
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.06.09.21.50;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.06.07.45.17;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.06.07.24.37;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.05.15.21.20;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.28.11.21.02;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.10.16.08.02;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2014.02.17.11.00.14;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2014.02.14.09.00.03;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2014.02.12.12.59.44;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.24.05.58.52;	author mikeb;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.22.09.25.41;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.28.20.21.17;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2012.12.15.23.12.21;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.22.10.25.17;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2012.06.22.16.06.31;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2012.05.30.16.17.20;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.29.15.09.12;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.07.10.58.38;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.24.00.40.25;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.26.16.59.24;	author mikeb;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.17.18.49.35;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.12.14.26.26;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.22.17.53.54;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.30.12.54.24;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.22.09.12.18;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.28.15.45.04;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.03.16.59.35;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.27.05.49.05;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.27.01.03.22;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.26.19.54.19;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.26.19.48.04;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.26.18.32.34;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.14.23.14.09;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.14.21.12.56;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.14.14.03.15;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.12.05.32;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.14.11.33.55;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.10.08.29.47;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Don't cache the DH group in the policy

When tearing IKE SA down, the DH group referred by it is destroyed,
however it remains cached in the policy.  With the introduction of
IKE SA rekeying we have extended the life of this dangling pointer
by reusing it on new SAs.  So instead of caching the pointer in the
policy we can store the DH group ID and create a DH group on demand
using this parameter if it's specified.

With and OK reyk
@
text
@/*	$OpenBSD: ikev2_pld.c,v 1.60 2017/03/27 10:21:19 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2014 Hans-Joerg Hoexer
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include <openssl/sha.h>
#include <openssl/evp.h>

#include "iked.h"
#include "ikev2.h"
#include "eap.h"
#include "dh.h"

int	 ikev2_validate_pld(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *);
int	 ikev2_pld_payloads(struct iked *, struct iked_message *,
	    size_t, size_t, unsigned int);
int	 ikev2_validate_sa(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_sa_proposal *);
int	 ikev2_pld_sa(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_xform(struct iked_message *, size_t, size_t,
	    struct ikev2_transform *);
int	 ikev2_pld_xform(struct iked *, struct ikev2_sa_proposal *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_attr(struct iked_message *, size_t, size_t,
	    struct ikev2_attribute *);
int	 ikev2_pld_attr(struct iked *, struct ikev2_transform *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_ke(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_keyexchange *);
int	 ikev2_pld_ke(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_id(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_id *);
int	 ikev2_pld_id(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t, unsigned int);
int	 ikev2_validate_cert(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_cert *);
int	 ikev2_pld_cert(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_certreq(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_cert *);
int	 ikev2_pld_certreq(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_nonce(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *);
int	 ikev2_pld_nonce(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_notify(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_notify *);
int	 ikev2_pld_notify(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_delete(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_delete *);
int	 ikev2_pld_delete(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_ts(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_tsp *);
int	 ikev2_pld_ts(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t, unsigned int);
int	 ikev2_validate_auth(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_auth *);
int	 ikev2_pld_auth(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_pld_e(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t);
int	 ikev2_validate_cp(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct ikev2_cp *);
int	 ikev2_pld_cp(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);
int	 ikev2_validate_eap(struct iked_message *, size_t, size_t,
	    struct ikev2_payload *, struct eap_header *);
int	 ikev2_pld_eap(struct iked *, struct ikev2_payload *,
	    struct iked_message *, size_t, size_t);

int
ikev2_pld_parse(struct iked *env, struct ike_header *hdr,
    struct iked_message *msg, size_t offset)
{
	log_debug("%s: header ispi %s rspi %s"
	    " nextpayload %s version 0x%02x exchange %s flags 0x%02x"
	    " msgid %d length %u response %d", __func__,
	    print_spi(betoh64(hdr->ike_ispi), 8),
	    print_spi(betoh64(hdr->ike_rspi), 8),
	    print_map(hdr->ike_nextpayload, ikev2_payload_map),
	    hdr->ike_version,
	    print_map(hdr->ike_exchange, ikev2_exchange_map),
	    hdr->ike_flags,
	    betoh32(hdr->ike_msgid),
	    betoh32(hdr->ike_length),
	    msg->msg_response);

	if (ibuf_size(msg->msg_data) < betoh32(hdr->ike_length)) {
		log_debug("%s: short message", __func__);
		return (-1);
	}

	offset += sizeof(*hdr);

	return (ikev2_pld_payloads(env, msg, offset,
	    betoh32(hdr->ike_length), hdr->ike_nextpayload));
}

int
ikev2_validate_pld(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	/* We need at least the generic header. */
	if (left < sizeof(*pld)) {
		log_debug("%s: malformed payload: too short for generic "
		    "header (%zu < %zu)", __func__, left, sizeof(*pld));
		return (-1);
	}
	memcpy(pld, msgbuf + offset, sizeof(*pld));

	/*
	 * We need at least the specified number of bytes.
	 * pld_length is the full size of the payload including
	 * the generic payload header.
	 */
	pld_length = betoh16(pld->pld_length);
	if (left < pld_length) {
		log_debug("%s: malformed payload: shorter than specified "
		    "(%zu < %zu)", __func__, left, pld_length);
		return (-1);
	}
	/*
	 * Sanity check the specified payload size, it must
	 * be at last the size of the generic payload header.
	 */
	if (pld_length < sizeof(*pld)) {
		log_debug("%s: malformed payload: shorter than minimum "
		    "header size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld));
		return (-1);
	}

	return (0);
}

int
ikev2_pld_payloads(struct iked *env, struct iked_message *msg,
    size_t offset, size_t length, unsigned int payload)
{
	struct ikev2_payload	 pld;
	unsigned int		 e;
	int			 ret;
	uint8_t			*msgbuf = ibuf_data(msg->msg_data);
	size_t			 left;

	/* Check if message was decrypted in an E payload */
	e = msg->msg_e ? IKED_E : 0;

	while (payload != 0 && offset < length) {
		/* Bytes left in datagram. */
		left = length - offset;

		if (ikev2_validate_pld(msg, offset, left, &pld))
			return (-1);

		log_debug("%s: %spayload %s"
		    " nextpayload %s critical 0x%02x length %d",
		    __func__, e ? "decrypted " : "",
		    print_map(payload, ikev2_payload_map),
		    print_map(pld.pld_nextpayload, ikev2_payload_map),
		    pld.pld_reserved & IKEV2_CRITICAL_PAYLOAD,
		    betoh16(pld.pld_length));

		/* Skip over generic payload header. */
		offset += sizeof(pld);
		left -= sizeof(pld);
		ret = 0;

		switch (payload | e) {
		case IKEV2_PAYLOAD_SA:
		case IKEV2_PAYLOAD_SA | IKED_E:
			ret = ikev2_pld_sa(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_KE:
		case IKEV2_PAYLOAD_KE | IKED_E:
			ret = ikev2_pld_ke(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_IDi | IKED_E:
		case IKEV2_PAYLOAD_IDr | IKED_E:
			ret = ikev2_pld_id(env, &pld, msg, offset, left,
			    payload);
			break;
		case IKEV2_PAYLOAD_CERT | IKED_E:
			ret = ikev2_pld_cert(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_CERTREQ:
		case IKEV2_PAYLOAD_CERTREQ | IKED_E:
			ret = ikev2_pld_certreq(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_AUTH | IKED_E:
			ret = ikev2_pld_auth(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_NONCE:
		case IKEV2_PAYLOAD_NONCE | IKED_E:
			ret = ikev2_pld_nonce(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_NOTIFY:
		case IKEV2_PAYLOAD_NOTIFY | IKED_E:
			ret = ikev2_pld_notify(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_DELETE | IKED_E:
			ret = ikev2_pld_delete(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_TSi | IKED_E:
		case IKEV2_PAYLOAD_TSr | IKED_E:
			ret = ikev2_pld_ts(env, &pld, msg, offset, left,
			    payload);
			break;
		case IKEV2_PAYLOAD_SK:
			ret = ikev2_pld_e(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_CP | IKED_E:
			ret = ikev2_pld_cp(env, &pld, msg, offset, left);
			break;
		case IKEV2_PAYLOAD_EAP | IKED_E:
			ret = ikev2_pld_eap(env, &pld, msg, offset, left);
			break;
		default:
			print_hex(msgbuf, offset,
			    betoh16(pld.pld_length) - sizeof(pld));
			break;
		}

		if (ret != 0 && ikev2_msg_frompeer(msg)) {
			(void)ikev2_send_informational(env, msg);
			return (-1);
		}

		/* Encrypted payload must appear last */
		if (payload == IKEV2_PAYLOAD_SK)
			return (0);

		payload = pld.pld_nextpayload;
		offset += betoh16(pld.pld_length) - sizeof(pld);
	}

	return (0);
}

int
ikev2_validate_sa(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_sa_proposal *sap)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length, sap_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*sap)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*sap));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*sap)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*sap));
		return (-1);
	}
	memcpy(sap, msgbuf + offset, sizeof(*sap));

	sap_length = betoh16(sap->sap_length);
	if (sap_length < sizeof(*sap)) {
		log_debug("%s: malformed payload: shorter than minimum header "
		    "size (%zu < %zu)", __func__, sap_length, sizeof(*sap));
		return (-1);
	}
	if (left < sap_length) {
		log_debug("%s: malformed payload: too long for actual payload "
		    "size (%zu < %zu)", __func__, left, sap_length);
		return (-1);
	}
	/*
	 * NB: There might be more proposals, we parse only the first one.
	 * This condition must never be true.
	 */
	if (pld_length - sizeof(*pld) < sap_length) {
		log_debug("%s: payload malformed: SA payload length mismatches "
		    "proposal substructure length (%lu < %zu)", __func__,
		    pld_length - sizeof(*pld), sap_length);
		return (-1);
	}
	/*
	 * If there is only one proposal, sap_length must be the
	 * total payload size.
	 */
	if (!sap->sap_more && ((pld_length - sizeof(*pld)) != sap_length)) {
		log_debug("%s: payload malformed: SA payload length mismatches "
		    "single proposal substructure length (%lu != %zu)",
		    __func__, pld_length - sizeof(*pld), sap_length);
		return (-1);
	}
	/*
	 * If there are more than one proposal, there must be bytes
	 * left in the payload.
	 */
	if (sap->sap_more && ((pld_length - sizeof(*pld)) <= sap_length)) {
		log_debug("%s: payload malformed: SA payload too small for "
		    "further proposals (%zu <= %zu)", __func__,
		    pld_length - sizeof(*pld), sap_length);
		return (-1);
	}
	return (0);
}

/*
 * NB: This function parses both the SA header and the first proposal.
 * Additional proposals are ignored.
 */
int
ikev2_pld_sa(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct ikev2_sa_proposal	 sap;
	struct iked_proposal		*prop = NULL;
	uint32_t			 spi32;
	uint64_t			 spi = 0, spi64;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);
	struct iked_proposals		*props;
	size_t				 total;

	if (ikev2_validate_sa(msg, offset, left, pld, &sap))
		return (-1);

	if (sap.sap_more)
		log_debug("%s: more than one proposal specified", __func__);

	/* Assumed size of the first proposals, including SPI if present. */
	total = (betoh16(sap.sap_length) - sizeof(sap));

	props = &msg->msg_parent->msg_proposals;

	offset += sizeof(sap);
	left -= sizeof(sap);

	if (sap.sap_spisize) {
		if (left < sap.sap_spisize) {
			log_debug("%s: malformed payload: SPI larger than "
			    "actual payload (%zu < %d)", __func__, left,
			    sap.sap_spisize);
			return (-1);
		}
		if (total < sap.sap_spisize) {
			log_debug("%s: malformed payload: SPI larger than "
			    "proposal (%zu < %d)", __func__, total,
			    sap.sap_spisize);
			return (-1);
		}
		if (total < sap.sap_spisize) {
			log_debug("%s: malformed payload: SPI too large "
			    "(%zu < %d)", __func__, total, sap.sap_spisize);
			return (-1);
		}
		switch (sap.sap_spisize) {
		case 4:
			memcpy(&spi32, msgbuf + offset, 4);
			spi = betoh32(spi32);
			break;
		case 8:
			memcpy(&spi64, msgbuf + offset, 8);
			spi = betoh64(spi64);
			break;
		default:
			log_debug("%s: unsupported SPI size %d",
			    __func__, sap.sap_spisize);
			return (-1);
		}

		offset += sap.sap_spisize;
		left -= sap.sap_spisize;

		/* Assumed size of the proposal, now without SPI. */
		total -= sap.sap_spisize;
	}

	/*
	 * As we verified sanity of packet headers, this check will
	 * be always false, but just to be sure we keep it.
	 */
	if (left < total) {
		log_debug("%s: payload malformed: too long for payload "
		    "(%zu < %zu)", __func__, left, total);
		return (-1);
	}

	log_debug("%s: more %d reserved %d length %d"
	    " proposal #%d protoid %s spisize %d xforms %d spi %s",
	    __func__, sap.sap_more, sap.sap_reserved,
	    betoh16(sap.sap_length), sap.sap_proposalnr,
	    print_map(sap.sap_protoid, ikev2_saproto_map), sap.sap_spisize,
	    sap.sap_transforms, print_spi(spi, sap.sap_spisize));

	if (ikev2_msg_frompeer(msg)) {
		if ((msg->msg_parent->msg_prop = config_add_proposal(props,
		    sap.sap_proposalnr, sap.sap_protoid)) == NULL) {
			log_debug("%s: invalid proposal", __func__);
			return (-1);
		}
		prop = msg->msg_parent->msg_prop;
		prop->prop_peerspi.spi = spi;
		prop->prop_peerspi.spi_protoid = sap.sap_protoid;
		prop->prop_peerspi.spi_size = sap.sap_spisize;

		prop->prop_localspi.spi_protoid = sap.sap_protoid;
		prop->prop_localspi.spi_size = sap.sap_spisize;
	}

	/*
	 * Parse the attached transforms
	 */
	if (sap.sap_transforms &&
	    ikev2_pld_xform(env, &sap, msg, offset, total) != 0) {
		log_debug("%s: invalid proposal transforms", __func__);
		return (-1);
	}

	return (0);
}

int
ikev2_validate_xform(struct iked_message *msg, size_t offset, size_t total,
    struct ikev2_transform *xfrm)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 xfrm_length;

	if (total < sizeof(*xfrm)) {
		log_debug("%s: payload malformed: too short for header "
		    "(%zu < %zu)", __func__, total, sizeof(*xfrm));
		return (-1);
	}
	memcpy(xfrm, msgbuf + offset, sizeof(*xfrm));

	xfrm_length = betoh16(xfrm->xfrm_length);
	if (xfrm_length < sizeof(*xfrm)) {
		log_debug("%s: payload malformed: shorter than minimal header "
		    "(%zu < %zu)", __func__, xfrm_length, sizeof(*xfrm));
		return (-1);
	}
	if (total < xfrm_length) {
		log_debug("%s: malformed payload: too long for payload size "
		    "(%zu < %zu)", __func__, total, xfrm_length);
		return (-1);
	}

	return (0);
}

int
ikev2_pld_xform(struct iked *env, struct ikev2_sa_proposal *sap,
    struct iked_message *msg, size_t offset, size_t total)
{
	struct ikev2_transform		 xfrm;
	char				 id[BUFSIZ];
	int				 ret = 0;
	size_t				 xfrm_length;

	if (ikev2_validate_xform(msg, offset, total, &xfrm))
		return (-1);

	xfrm_length = betoh16(xfrm.xfrm_length);

	switch (xfrm.xfrm_type) {
	case IKEV2_XFORMTYPE_ENCR:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformencr_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_PRF:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformprf_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_INTEGR:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformauth_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_DH:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformdh_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_ESN:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformesn_map), sizeof(id));
		break;
	default:
		snprintf(id, sizeof(id), "<%d>", betoh16(xfrm.xfrm_id));
		break;
	}

	log_debug("%s: more %d reserved %d length %zu"
	    " type %s id %s",
	    __func__, xfrm.xfrm_more, xfrm.xfrm_reserved, xfrm_length,
	    print_map(xfrm.xfrm_type, ikev2_xformtype_map), id);

	/*
	 * Parse transform attributes, if available
	 */
	msg->msg_attrlength = 0;
	if (xfrm_length > sizeof(xfrm)) {
		if (ikev2_pld_attr(env, &xfrm, msg, offset + sizeof(xfrm),
		    xfrm_length - sizeof(xfrm)) != 0) {
			return (-1);
		}
	}

	if (ikev2_msg_frompeer(msg)) {
		if (config_add_transform(msg->msg_parent->msg_prop,
		    xfrm.xfrm_type, betoh16(xfrm.xfrm_id),
		    msg->msg_attrlength, msg->msg_attrlength) == NULL) {
			log_debug("%s: failed to add transform", __func__);
			return (-1);
		}
	}

	/* Next transform */
	offset += xfrm_length;
	total -= xfrm_length;
	if (xfrm.xfrm_more == IKEV2_XFORM_MORE)
		ret = ikev2_pld_xform(env, sap, msg, offset, total);
	else if (total != 0) {
		/* No more transforms but still some data left. */
		log_debug("%s: less data than specified, %zu bytes left",
		    __func__, total);
		ret = -1;
	}

	return (ret);
}

int
ikev2_validate_attr(struct iked_message *msg, size_t offset, size_t total,
    struct ikev2_attribute *attr)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);

	if (total < sizeof(*attr)) {
		log_debug("%s: payload malformed: too short for header "
		    "(%zu < %zu)", __func__, total, sizeof(*attr));
		return (-1);
	}
	memcpy(attr, msgbuf + offset, sizeof(*attr));

	return (0);
}

int
ikev2_pld_attr(struct iked *env, struct ikev2_transform *xfrm,
    struct iked_message *msg, size_t offset, size_t total)
{
	struct ikev2_attribute		 attr;
	unsigned int			 type;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);
	int				 ret = 0;
	size_t				 attr_length;

	if (ikev2_validate_attr(msg, offset, total, &attr))
		return (-1);

	type = betoh16(attr.attr_type) & ~IKEV2_ATTRAF_TV;

	log_debug("%s: attribute type %s length %d total %zu",
	    __func__, print_map(type, ikev2_attrtype_map),
	    betoh16(attr.attr_length), total);

	if (betoh16(attr.attr_type) & IKEV2_ATTRAF_TV) {
		/* Type-Value attribute */
		offset += sizeof(attr);
		total -= sizeof(attr);

		if (type == IKEV2_ATTRTYPE_KEY_LENGTH)
			msg->msg_attrlength = betoh16(attr.attr_length);
	} else {
		/* Type-Length-Value attribute */
		attr_length = betoh16(attr.attr_length);
		if (attr_length < sizeof(attr)) {
			log_debug("%s: payload malformed: shorter than "
			    "minimal header (%zu < %zu)", __func__,
			    attr_length, sizeof(attr));
			return (-1);
		}
		if (total < attr_length) {
			log_debug("%s: payload malformed: attribute larger "
			    "than actual payload (%zu < %zu)", __func__,
			    total, attr_length);
			return (-1);
		}
		print_hex(msgbuf, offset + sizeof(attr),
		    attr_length - sizeof(attr));
		offset += attr_length;
		total -= attr_length;
	}

	if (total > 0) {
		/* Next attribute */
		ret = ikev2_pld_attr(env, xfrm, msg, offset, total);
	}

	return (ret);
}

int
ikev2_validate_ke(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_keyexchange *kex)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*kex)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*kex));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*kex)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*kex));
		return (-1);
	}
	memcpy(kex, msgbuf + offset, sizeof(*kex));

	return (0);
}

int
ikev2_pld_ke(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct ikev2_keyexchange	 kex;
	uint8_t				*buf;
	size_t				 len;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);

	if (ikev2_validate_ke(msg, offset, left, pld, &kex))
		return (-1);

	log_debug("%s: dh group %s reserved %d", __func__,
	    print_map(betoh16(kex.kex_dhgroup), ikev2_xformdh_map),
	    betoh16(kex.kex_reserved));

	buf = msgbuf + offset + sizeof(kex);
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(kex);

	if (len == 0) {
		log_debug("%s: malformed payload: no KE data given", __func__);
		return (-1);
	}
	/* This will actually be caught by earlier checks. */
	if (left < len) {
		log_debug("%s: malformed payload: smaller than specified "
		     "(%zu < %zu)", __func__, left, len);
		return (-1);
	}

	print_hex(buf, 0, len);

	if (ikev2_msg_frompeer(msg)) {
		ibuf_release(msg->msg_parent->msg_ke);
		if ((msg->msg_parent->msg_ke = ibuf_new(buf, len)) == NULL) {
			log_debug("%s: failed to get exchange", __func__);
			return (-1);
		}
	}

	return (0);
}

int
ikev2_validate_id(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_id *id)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*id)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*id));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*id)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*id));
		return (-1);
	}
	memcpy(id, msgbuf + offset, sizeof(*id));

	return (0);
}

int
ikev2_pld_id(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left, unsigned int payload)
{
	uint8_t				*ptr;
	struct ikev2_id			 id;
	size_t				 len;
	struct iked_id			*idp, idb;
	struct iked_sa			*sa = msg->msg_sa;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);
	char				 idstr[IKED_ID_SIZE];

	if (ikev2_validate_id(msg, offset, left, pld, &id))
		return (-1);

	bzero(&idb, sizeof(idb));

	/* Don't strip the Id payload header */
	ptr = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld);

	idb.id_type = id.id_type;
	idb.id_offset = sizeof(id);
	if ((idb.id_buf = ibuf_new(ptr, len)) == NULL)
		return (-1);

	if (ikev2_print_id(&idb, idstr, sizeof(idstr)) == -1) {
		log_debug("%s: malformed id", __func__);
		return (-1);
	}

	log_debug("%s: id %s length %zu", __func__, idstr, len);

	if (!ikev2_msg_frompeer(msg)) {
		ibuf_release(idb.id_buf);
		return (0);
	}

	if (!((sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDr) ||
	    (!sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDi))) {
		log_debug("%s: unexpected id payload", __func__);
		return (0);
	}

	idp = &msg->msg_parent->msg_id;
	if (idp->id_type) {
		log_debug("%s: duplicate id payload", __func__);
		return (-1);
	}

	idp->id_buf = idb.id_buf;
	idp->id_offset = idb.id_offset;
	idp->id_type = idb.id_type;

	return (0);
}

int
ikev2_validate_cert(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_cert *cert)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*cert)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*cert));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*cert)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*cert));
		return (-1);
	}
	memcpy(cert, msgbuf + offset, sizeof(*cert));

	return (0);
}

int
ikev2_pld_cert(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct ikev2_cert		 cert;
	uint8_t				*buf;
	size_t				 len;
	struct iked_id			*certid;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);

	if (ikev2_validate_cert(msg, offset, left, pld, &cert))
		return (-1);
	offset += sizeof(cert);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(cert);

	log_debug("%s: type %s length %zu",
	    __func__, print_map(cert.cert_type, ikev2_cert_map), len);

	print_hex(buf, 0, len);

	if (!ikev2_msg_frompeer(msg))
		return (0);

	certid = &msg->msg_parent->msg_cert;
	if (certid->id_type) {
		log_debug("%s: duplicate cert payload", __func__);
		return (-1);
	}

	if ((certid->id_buf = ibuf_new(buf, len)) == NULL) {
		log_debug("%s: failed to save cert", __func__);
		return (-1);
	}
	certid->id_type = cert.cert_type;
	certid->id_offset = 0;

	return (0);
}

int
ikev2_validate_certreq(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_cert *cert)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*cert)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*cert));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*cert)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*cert));
		return (-1);
	}
	memcpy(cert, msgbuf + offset, sizeof(*cert));

	return (0);
}

int
ikev2_pld_certreq(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct iked_sa			*sa = msg->msg_sa;
	struct ikev2_cert		 cert;
	uint8_t				*buf;
	ssize_t				 len;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);

	if (ikev2_validate_certreq(msg, offset, left, pld, &cert))
		return (-1);
	offset += sizeof(cert);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(cert);

	log_debug("%s: type %s length %zd",
	    __func__, print_map(cert.cert_type, ikev2_cert_map), len);

	/* This will actually be caught by earlier checks. */
	if (len < 0) {
		log_debug("%s: invalid certificate request length", __func__);
		return (-1);
	}

	print_hex(buf, 0, len);

	if (!ikev2_msg_frompeer(msg))
		return (0);

	if (cert.cert_type == IKEV2_CERT_X509_CERT) {
		if (!len)
			return (0);
		if ((len % SHA_DIGEST_LENGTH) != 0) {
			log_debug("%s: invalid certificate request", __func__);
			return (-1);
		}
	}

	if (msg->msg_sa == NULL)
		return (-1);

	/* Optional certreq for PSK */
	if (sa->sa_hdr.sh_initiator)
		sa->sa_stateinit |= IKED_REQ_CERT;
	else
		sa->sa_statevalid |= IKED_REQ_CERT;

	ca_setreq(env, sa, &sa->sa_policy->pol_localid,
	    cert.cert_type, buf, len, PROC_CERT);

	return (0);
}

int
ikev2_validate_auth(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_auth *auth)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*auth)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*auth));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*auth)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*auth));
		return (-1);
	}
	memcpy(auth, msgbuf + offset, sizeof(*auth));

	return (0);
}

int
ikev2_pld_auth(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct ikev2_auth		 auth;
	struct iked_id			*idp;
	uint8_t				*buf;
	size_t				 len;
	struct iked_sa			*sa = msg->msg_sa;
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);

	if (ikev2_validate_auth(msg, offset, left, pld, &auth))
		return (-1);
	offset += sizeof(auth);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(auth);

	log_debug("%s: method %s length %zu",
	    __func__, print_map(auth.auth_method, ikev2_auth_map), len);

	print_hex(buf, 0, len);

	if (!ikev2_msg_frompeer(msg))
		return (0);

	/* The AUTH payload indicates if the responder wants EAP or not */
	if (!sa_stateok(sa, IKEV2_STATE_EAP))
		sa_state(env, sa, IKEV2_STATE_AUTH_REQUEST);

	idp = &msg->msg_parent->msg_auth;
	if (idp->id_type) {
		log_debug("%s: duplicate auth payload", __func__);
		return (-1);
	}

	ibuf_release(idp->id_buf);
	idp->id_type = auth.auth_method;
	idp->id_offset = 0;
	if ((idp->id_buf = ibuf_new(buf, len)) == NULL)
		return (-1);

	return (0);
}

int
ikev2_validate_nonce(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld)
{
	size_t		 pld_length;

	/* This will actually be caught by earlier checks. */
	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld));
		return (-1);
	}

	return (0);
}

int
ikev2_pld_nonce(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	size_t		 len;
	uint8_t		*buf;
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);

	if (ikev2_validate_nonce(msg, offset, left, pld))
		return (-1);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld);

	if (len == 0) {
		log_debug("%s: malformed payload: no NONCE given", __func__);
		return (-1);
	}
	/* This will actually be caught by earlier checks. */
	if (left < len) {
		log_debug("%s: malformed payload: smaller than specified "
		    "(%zu < %zu)", __func__, left, len);
		return (-1);
	}

	print_hex(buf, 0, len);

	if (ikev2_msg_frompeer(msg)) {
		ibuf_release(msg->msg_nonce);
		if ((msg->msg_nonce = ibuf_new(buf, len)) == NULL) {
			log_debug("%s: failed to get peer nonce", __func__);
			return (-1);
		}
		msg->msg_parent->msg_nonce = msg->msg_nonce;
	}

	return (0);
}

int
ikev2_validate_notify(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_notify *n)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*n)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*n));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*n)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*n));
		return (-1);
	}
	memcpy(n, msgbuf + offset, sizeof(*n));

	return (0);
}

int
ikev2_pld_notify(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct ikev2_notify	 n;
	uint8_t			*buf, md[SHA_DIGEST_LENGTH];
	size_t			 len;
	uint32_t		 spi32;
	uint64_t		 spi64;
	struct iked_spi		*rekey;
	uint16_t		 type;
	uint16_t		 group;
	uint16_t		 cpi;
	uint16_t		 signature_hash;
	uint8_t			 transform;

	if (ikev2_validate_notify(msg, offset, left, pld, &n))
		return (-1);
	type = betoh16(n.n_type);

	log_debug("%s: protoid %s spisize %d type %s",
	    __func__,
	    print_map(n.n_protoid, ikev2_saproto_map), n.n_spisize,
	    print_map(type, ikev2_n_map));

	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(n);
	if ((buf = ibuf_seek(msg->msg_data, offset + sizeof(n), len)) == NULL)
		return (-1);

	print_hex(buf, 0, len);

	if (!ikev2_msg_frompeer(msg))
		return (0);

	switch (type) {
	case IKEV2_N_NAT_DETECTION_SOURCE_IP:
	case IKEV2_N_NAT_DETECTION_DESTINATION_IP:
		if (len != sizeof(md)) {
			log_debug("%s: malformed payload: hash size mismatch"
			    " (%zu != %zu)", __func__, len, sizeof(md));
			return (-1);
		}
		if (ikev2_nat_detection(env, msg, md, sizeof(md), type) == -1)
			return (-1);
		if (memcmp(buf, md, len) != 0) {
			log_debug("%s: %s detected NAT, enabling "
			    "UDP encapsulation", __func__,
			    print_map(type, ikev2_n_map));

			/*
			 * Enable UDP encapsulation of ESP packages if
			 * the check detected NAT.
			 */
			if (msg->msg_sa != NULL)
				msg->msg_sa->sa_udpencap = 1;
		}
		print_hex(md, 0, sizeof(md));
		break;
	case IKEV2_N_AUTHENTICATION_FAILED:
		if (!msg->msg_e) {
			log_debug("%s: AUTHENTICATION_FAILED not encrypted",
			    __func__);
			return (-1);
		}
		/*
		 * If we are the responder, then we only accept
		 * AUTHENTICATION_FAILED from authenticated peers.
		 * If we are the initiator, the peer cannot be authenticated.
		 */
		if (!msg->msg_sa->sa_hdr.sh_initiator) {
			if (!sa_stateok(msg->msg_sa, IKEV2_STATE_VALID)) {
				log_debug("%s: ignoring AUTHENTICATION_FAILED"
				    " from unauthenticated initiator",
				    __func__);
				return (-1);
			}
		} else {
			if (sa_stateok(msg->msg_sa, IKEV2_STATE_VALID)) {
				log_debug("%s: ignoring AUTHENTICATION_FAILED"
				    " from authenticated responder",
				    __func__);
				return (-1);
			}
		}
		log_debug("%s: AUTHENTICATION_FAILED, closing SA", __func__);
		sa_state(env, msg->msg_sa, IKEV2_STATE_CLOSED);
		msg->msg_sa = NULL;
		break;
	case IKEV2_N_INVALID_KE_PAYLOAD:
		if (sa_stateok(msg->msg_sa, IKEV2_STATE_VALID) &&
		    !msg->msg_e) {
			log_debug("%s: INVALID_KE_PAYLOAD not encrypted",
			    __func__);
			return (-1);
		}
		if (len != sizeof(group)) {
			log_debug("%s: malformed payload: group size mismatch"
			    " (%zu != %zu)", __func__, len, sizeof(group));
			return (-1);
		}
		/* XXX chould also happen for PFS */
		if (!msg->msg_sa->sa_hdr.sh_initiator) {
			log_debug("%s: not an initiator", __func__);
			sa_state(env, msg->msg_sa, IKEV2_STATE_CLOSED);
			msg->msg_sa = NULL;
			return (-1);
		}
		memcpy(&group, buf, len);
		group = betoh16(group);
		if (group_getid(group) == NULL) {
			log_debug("%s: unable to select DH group %u", __func__,
			    group);
			return (-1);
		}
		msg->msg_policy->pol_peerdh = group;
		log_debug("%s: responder selected DH group %u", __func__,
		    group);
		sa_state(env, msg->msg_sa, IKEV2_STATE_CLOSED);
		msg->msg_sa = NULL;

		/*
		 * XXX should also happen for PFS so we have to check state.
		 */
		timer_set(env, &env->sc_inittmr, ikev2_init_ike_sa, NULL);
		timer_add(env, &env->sc_inittmr, IKED_INITIATOR_INITIAL);
		break;
	case IKEV2_N_NO_ADDITIONAL_SAS:
		if (!msg->msg_e) {
			log_debug("%s: NO_ADDITIONAL_SAS not encrypted",
			    __func__);
			return (-1);
		}
		/* This makes sense for Child SAs only atm */
		if (msg->msg_sa->sa_stateflags & IKED_REQ_CHILDSA) {
			ikev2_disable_rekeying(env, msg->msg_sa);
			msg->msg_sa->sa_stateflags &= ~IKED_REQ_CHILDSA;
		}
		break;
	case IKEV2_N_REKEY_SA:
		if (!msg->msg_e) {
			log_debug("%s: N_REKEY_SA not encrypted", __func__);
			return (-1);
		}
		if (len != n.n_spisize) {
			log_debug("%s: malformed notification", __func__);
			return (-1);
		}
		rekey = &msg->msg_parent->msg_rekey;
		if (rekey->spi != 0) {
			log_debug("%s: rekeying of multiple SAs not supported",
			    __func__);
			return (-1);
		}
		switch (n.n_spisize) {
		case 4:
			memcpy(&spi32, buf, len);
			rekey->spi = betoh32(spi32);
			break;
		case 8:
			memcpy(&spi64, buf, len);
			rekey->spi = betoh64(spi64);
			break;
		default:
			log_debug("%s: invalid spi size %d", __func__,
			    n.n_spisize);
			return (-1);
		}
		rekey->spi_size = n.n_spisize;
		rekey->spi_protoid = n.n_protoid;

		log_debug("%s: rekey %s spi %s", __func__,
		    print_map(n.n_protoid, ikev2_saproto_map),
		    print_spi(rekey->spi, n.n_spisize));
		break;
	case IKEV2_N_IPCOMP_SUPPORTED:
		if (!msg->msg_e) {
			log_debug("%s: N_IPCOMP_SUPPORTED not encrypted",
			    __func__);
			return (-1);
		}
		if (len < sizeof(cpi) + sizeof(transform)) {
			log_debug("%s: ignoring malformed ipcomp notification",
			    __func__);
			return (0);
		}
		memcpy(&cpi, buf, sizeof(cpi));
		memcpy(&transform, buf + sizeof(cpi), sizeof(transform));
		log_debug("%s: cpi 0x%x, transform %s, len %zu", __func__,
		    betoh16(cpi), print_map(transform, ikev2_ipcomp_map), len);
		/* we only support deflate */
		if ((msg->msg_policy->pol_flags & IKED_POLICY_IPCOMP) &&
		    (transform == IKEV2_IPCOMP_DEFLATE)) {
			msg->msg_sa->sa_ipcomp = transform;
			msg->msg_sa->sa_cpi_out = betoh16(cpi);
		}
		break;
	case IKEV2_N_COOKIE:
		if (msg->msg_e) {
			log_debug("%s: N_COOKIE encrypted",
			    __func__);
			return (-1);
		}
		if (len < IKED_COOKIE_MIN || len > IKED_COOKIE_MAX) {
			log_debug("%s: ignoring malformed cookie"
			    " notification: %zu", __func__, len);
			return (0);
		}
		log_debug("%s: received cookie, len %zu", __func__, len);
		print_hex(buf, 0, len);

		ibuf_release(msg->msg_cookie);
		if ((msg->msg_cookie = ibuf_new(buf, len)) == NULL) {
			log_debug("%s: failed to get peer cookie", __func__);
			return (-1);
		}
		msg->msg_parent->msg_cookie = msg->msg_cookie;
		break;
	case IKEV2_N_SIGNATURE_HASH_ALGORITHMS:
		if (msg->msg_e) {
			log_debug("%s: SIGNATURE_HASH_ALGORITHMS: encrypted",
			    __func__);
			return (-1);
		}
		if (msg->msg_sa == NULL ||
		    msg->msg_sa->sa_sigsha2) {
			log_debug("%s: SIGNATURE_HASH_ALGORITHMS: no SA or "
			    "duplicate notify", __func__);
			return (-1);
		}
		if (len < sizeof(signature_hash) ||
		    len % sizeof(signature_hash)) {
			log_debug("%s: malformed signature hash notification"
			     "(%zu bytes)", __func__, len);
			return (0);
		}
		while (len >= sizeof(signature_hash)) {
			memcpy(&signature_hash, buf, sizeof(signature_hash));
			signature_hash = betoh16(signature_hash);
			log_debug("%s: signature hash %s (%x)", __func__,
			    print_map(signature_hash, ikev2_sighash_map),
			    signature_hash);
			len -= sizeof(signature_hash);
			buf += sizeof(signature_hash);
			if (signature_hash == IKEV2_SIGHASH_SHA2_256)
				msg->msg_sa->sa_sigsha2 = 1;
		}
		break;
	}

	return (0);
}

int
ikev2_validate_delete(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_delete *del)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*del)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*del));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*del)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*del));
		return (-1);
	}
	memcpy(del, msgbuf + offset, sizeof(*del));

	return (0);
}

int
ikev2_pld_delete(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct iked_childsa	**peersas = NULL;
	struct iked_sa		*sa = msg->msg_sa;
	struct ikev2_delete	 del, *localdel;
	struct ibuf		*resp = NULL;
	uint64_t		*localspi = NULL;
	uint64_t		 spi64, spi = 0;
	uint32_t		 spi32;
	uint8_t			*buf, *msgbuf = ibuf_data(msg->msg_data);
	size_t			 found = 0, failed = 0;
	int			 cnt, i, len, sz, ret = -1;

	/* Skip if it's a response, then we don't have to deal with it */
	if (ikev2_msg_frompeer(msg) &&
	    msg->msg_parent->msg_response)
		return (0);

	if (ikev2_validate_delete(msg, offset, left, pld, &del))
		return (-1);
	cnt = betoh16(del.del_nspi);
	sz = del.del_spisize;

	log_debug("%s: proto %s spisize %d nspi %d",
	    __func__, print_map(del.del_protoid, ikev2_saproto_map),
	    sz, cnt);

	buf = msgbuf + offset + sizeof(del);
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(del);

	print_hex(buf, 0, len);

	switch (sz) {
	case 4:
	case 8:
		break;
	default:
		if (del.del_protoid != IKEV2_SAPROTO_IKE) {
			log_debug("%s: invalid SPI size", __func__);
			return (-1);
		}
		if (ikev2_msg_frompeer(msg)) {
			/* Send an empty informational response */
			if ((resp = ibuf_static()) == NULL)
				goto done;
			ret = ikev2_send_ike_e(env, sa, resp,
			    IKEV2_PAYLOAD_NONE,
			    IKEV2_EXCHANGE_INFORMATIONAL, 1);
			msg->msg_parent->msg_responded = 1;
			ibuf_release(resp);
			ikev2_ikesa_recv_delete(env, sa);
		} else {
			/*
			 * We're sending a delete message. Upper layer
			 * must deal with deletion of the IKE SA.
			 */
			ret = 0;
		}
		return (ret);
	}

	if ((len / sz) != cnt) {
		log_debug("%s: invalid payload length %d/%d != %d",
		    __func__, len, sz, cnt);
		return (-1);
	}

	if (ikev2_msg_frompeer(msg) &&
	    ((peersas = calloc(cnt, sizeof(struct iked_childsa *))) == NULL ||
	     (localspi = calloc(cnt, sizeof(uint64_t))) == NULL)) {
		log_warn("%s", __func__);
		goto done;
	}

	for (i = 0; i < cnt; i++) {
		switch (sz) {
		case 4:
			memcpy(&spi32, buf + (i * sz), sizeof(spi32));
			spi = betoh32(spi32);
			break;
		case 8:
			memcpy(&spi64, buf + (i * sz), sizeof(spi64));
			spi = betoh64(spi64);
			break;
		}

		log_debug("%s: spi %s", __func__, print_spi(spi, sz));

		if (peersas == NULL || sa == NULL)
			continue;

		if ((peersas[i] = childsa_lookup(sa, spi,
		    del.del_protoid)) == NULL) {
			log_warnx("%s: CHILD SA doesn't exist for spi %s",
			    __func__, print_spi(spi, del.del_spisize));
			continue;
		}

		if (ikev2_childsa_delete(env, sa, del.del_protoid, spi,
		    &localspi[i], 0) == -1)
			failed++;
		else
			found++;

		/*
		 * Flows are left in the require mode so that it would be
		 * possible to quickly negotiate a new Child SA
		 */
	}

	/* Parsed outgoing message? */
	if (!ikev2_msg_frompeer(msg))
		goto done;

	if (msg->msg_parent->msg_response) {
		ret = 0;
		goto done;
	}

	/* Response to the INFORMATIONAL with Delete payload */

	if ((resp = ibuf_static()) == NULL)
		goto done;

	if (found) {
		if ((localdel = ibuf_advance(resp, sizeof(*localdel))) == NULL)
			goto done;

		localdel->del_protoid = del.del_protoid;
		localdel->del_spisize = del.del_spisize;
		localdel->del_nspi = htobe16(found);

		for (i = 0; i < cnt; i++) {
			if (localspi[i] == 0)	/* happens if found < cnt */
				continue;
			switch (sz) {
			case 4:
				spi32 = htobe32(localspi[i]);
				if (ibuf_add(resp, &spi32, sizeof(spi32)) != 0)
					goto done;
				break;
			case 8:
				spi64 = htobe64(localspi[i]);
				if (ibuf_add(resp, &spi64, sizeof(spi64)) != 0)
					goto done;
				break;
			}
		}

		log_warnx("%s: deleted %zu spis", __func__, found);
	}

	if (found) {
		ret = ikev2_send_ike_e(env, sa, resp, IKEV2_PAYLOAD_DELETE,
		    IKEV2_EXCHANGE_INFORMATIONAL, 1);
		msg->msg_parent->msg_responded = 1;
	} else {
		/* XXX should we send an INVALID_SPI notification? */
		ret = 0;
	}

 done:
	free(localspi);
	free(peersas);
	ibuf_release(resp);
	return (ret);
}

int
ikev2_validate_ts(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_tsp *tsp)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*tsp)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*tsp));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*tsp)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*tsp));
		return (-1);
	}
	memcpy(tsp, msgbuf + offset, sizeof(*tsp));

	return (0);
}

int
ikev2_pld_ts(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left, unsigned int payload)
{
	struct ikev2_tsp		 tsp;
	struct ikev2_ts			 ts;
	size_t				 len, i;
	struct sockaddr_in		 s4;
	struct sockaddr_in6		 s6;
	uint8_t				 buf[2][128];
	uint8_t				*msgbuf = ibuf_data(msg->msg_data);

	if (ikev2_validate_ts(msg, offset, left, pld, &tsp))
		return (-1);
	offset += sizeof(tsp);

	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(tsp);

	log_debug("%s: count %d length %zu", __func__,
	    tsp.tsp_count, len);

	for (i = 0; i < tsp.tsp_count; i++) {
		memcpy(&ts, msgbuf + offset, sizeof(ts));

		log_debug("%s: type %s protoid %u length %d "
		    "startport %u endport %u", __func__,
		    print_map(ts.ts_type, ikev2_ts_map),
		    ts.ts_protoid, betoh16(ts.ts_length),
		    betoh16(ts.ts_startport),
		    betoh16(ts.ts_endport));

		switch (ts.ts_type) {
		case IKEV2_TS_IPV4_ADDR_RANGE:
			bzero(&s4, sizeof(s4));
			s4.sin_family = AF_INET;
			s4.sin_len = sizeof(s4);
			memcpy(&s4.sin_addr.s_addr,
			    msgbuf + offset + sizeof(ts), 4);
			print_host((struct sockaddr *)&s4,
			    (char *)buf[0], sizeof(buf[0]));
			memcpy(&s4.sin_addr.s_addr,
			    msgbuf + offset + sizeof(ts) + 4, 4);
			print_host((struct sockaddr *)&s4,
			    (char *)buf[1], sizeof(buf[1]));
			log_debug("%s: start %s end %s", __func__,
			    buf[0], buf[1]);
			break;
		case IKEV2_TS_IPV6_ADDR_RANGE:
			bzero(&s6, sizeof(s6));
			s6.sin6_family = AF_INET6;
			s6.sin6_len = sizeof(s6);
			memcpy(&s6.sin6_addr,
			    msgbuf + offset + sizeof(ts), 16);
			print_host((struct sockaddr *)&s6,
			    (char *)buf[0], sizeof(buf[0]));
			memcpy(&s6.sin6_addr,
			    msgbuf + offset + sizeof(ts) + 16, 16);
			print_host((struct sockaddr *)&s6,
			    (char *)buf[1], sizeof(buf[1]));
			log_debug("%s: start %s end %s", __func__,
			    buf[0], buf[1]);
			break;
		default:
			break;
		}

		offset += betoh16(ts.ts_length);
	}

	return (0);
}

int
ikev2_pld_e(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset)
{
	struct iked_sa		*sa = msg->msg_sa;
	struct ibuf		*e = NULL;
	uint8_t			*msgbuf = ibuf_data(msg->msg_data);
	struct iked_message	 emsg;
	uint8_t			*buf;
	size_t			 len;
	int			 ret = -1;

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld);

	if ((e = ibuf_new(buf, len)) == NULL)
		goto done;

	if (ikev2_msg_frompeer(msg)) {
		e = ikev2_msg_decrypt(env, msg->msg_sa, msg->msg_data, e);
	} else {
		sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
		e = ikev2_msg_decrypt(env, msg->msg_sa, msg->msg_data, e);
		sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
	}

	if (e == NULL)
		goto done;

	/*
	 * Parse decrypted payload
	 */
	bzero(&emsg, sizeof(emsg));
	memcpy(&emsg, msg, sizeof(*msg));
	emsg.msg_data = e;
	emsg.msg_e = 1;
	emsg.msg_parent = msg;
	TAILQ_INIT(&emsg.msg_proposals);

	ret = ikev2_pld_payloads(env, &emsg, 0, ibuf_size(e),
	    pld->pld_nextpayload);

 done:
	ibuf_release(e);

	return (ret);
}

int
ikev2_validate_cp(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_cp *cp)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*cp)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*cp));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*cp)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*cp));
		return (-1);
	}
	memcpy(cp, msgbuf + offset, sizeof(*cp));

	return (0);
}

int
ikev2_pld_cp(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct ikev2_cp		 cp;
	struct ikev2_cfg	*cfg;
	uint8_t			*buf;
	size_t			 len, i;
	uint8_t			*msgbuf = ibuf_data(msg->msg_data);
	struct iked_sa		*sa = msg->msg_sa;

	if (ikev2_validate_cp(msg, offset, left, pld, &cp))
		return (-1);
	offset += sizeof(cp);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(cp);

	log_debug("%s: type %s length %zu",
	    __func__, print_map(cp.cp_type, ikev2_cp_map), len);
	print_hex(buf, 0, len);

	for (i = 0; i < len;) {
		cfg = (struct ikev2_cfg *)(buf + i);

		log_debug("%s: %s 0x%04x length %d", __func__,
		    print_map(betoh16(cfg->cfg_type), ikev2_cfg_map),
		    betoh16(cfg->cfg_type),
		    betoh16(cfg->cfg_length));

		i += betoh16(cfg->cfg_length) + sizeof(*cfg);
	}

	if (!ikev2_msg_frompeer(msg))
		return (0);

	if (sa)
		sa->sa_cp = cp.cp_type;

	return (0);
}

int
ikev2_validate_eap(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct eap_header *hdr)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*hdr)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*hdr));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*hdr)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*hdr));
		return (-1);
	}
	memcpy(hdr, msgbuf + offset, sizeof(*hdr));

	return (0);
}

int
ikev2_pld_eap(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, size_t offset, size_t left)
{
	struct eap_header		 hdr;
	struct eap_message		*eap = NULL;
	struct iked_sa			*sa = msg->msg_sa;
	size_t				 len;

	if (ikev2_validate_eap(msg, offset, left, pld, &hdr))
		return (-1);
	len = betoh16(hdr.eap_length);

	if (len < sizeof(*eap)) {
		log_info("%s: %s id %d length %d", __func__,
		    print_map(hdr.eap_code, eap_code_map),
		    hdr.eap_id, betoh16(hdr.eap_length));
	} else {
		/* Now try to get the indicated length */
		if ((eap = ibuf_seek(msg->msg_data, offset, len)) == NULL) {
			log_debug("%s: invalid EAP length", __func__);
			return (-1);
		}

		log_info("%s: %s id %d length %d EAP-%s", __func__,
		    print_map(eap->eap_code, eap_code_map),
		    eap->eap_id, betoh16(eap->eap_length),
		    print_map(eap->eap_type, eap_type_map));

		if (eap_parse(env, sa, eap, msg->msg_response) == -1)
			return (-1);
	}

	return (0);
}
@


1.60
log
@Add support to reflect the responder IKEv2 COOKIE.

This fixes connecting to Azure VPN and other implementations that
implement the IKEv2 COOKIE mechanism on the responder side.  Azure
decides to send you a responder COOKIE after too many connection
attempts - we have to keep it and reflect it to establish a
connection.  This implementation is only for the initiator (client)
side, we do not support sending COOKIEs on the responder (server) side
yet.

OK patrick@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.59 2017/03/13 18:48:16 mikeb Exp $	*/
d1205 2
a1206 3
		if ((msg->msg_policy->pol_peerdh = group_get(group))
		    == NULL) {
			log_debug("%s: unable to select DH group %d", __func__,
d1210 2
a1211 1
		log_debug("%s: responder selected DH group %d", __func__,
@


1.59
log
@Resolve simultaneous IKE SA rekeying

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.58 2017/03/13 14:50:52 mikeb Exp $	*/
d1291 21
@


1.58
log
@Improve reporting of authentication errors

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.57 2017/01/20 13:49:48 mikeb Exp $	*/
d1405 1
a1405 1
			sa_state(env, sa, IKEV2_STATE_CLOSED);
@


1.57
log
@Include only found SPIs into the PAYLOAD_DELETE message

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.56 2017/01/20 13:47:17 mikeb Exp $	*/
d1153 30
@


1.56
log
@Minor formatting fix

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.55 2015/10/15 18:40:38 mmcc Exp $	*/
d1458 2
@


1.55
log
@Remove some unnecessary NULL-checks before free(). Change two bzero()
calls on pf data to explicit_bzero().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.54 2015/10/01 13:57:29 sthen Exp $	*/
d115 1
a115 1
	    " msgid %d length %d response %d", __func__,
@


1.54
log
@Don't reject an "empty" CERTREQ (one with no CA hashes), instead treat it as
if no CERTREQ were received. In conjunction with the previous iOS9 interop fix,
this may fix an interop problem seen by Denis Lapshin with BlackBerry OS 10.3.1
and one of a number with firebrick.co.uk's IKEv2 implementation diagnosed by
their developer Cliff Hones.  ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.53 2015/10/01 10:59:23 reyk Exp $	*/
d1485 2
a1486 4
	if (localspi)
		free(localspi);
	if (peersas)
		free(peersas);
@


1.53
log
@Fix interoperability with Apple iOS9: If we don't get a (valid)
CERTREQ but a CERT, respond with a local CERT that was selected based
on our own policy instead of leaving it out.  This seems to be valid
with the RFC that makes the CERTREQ optional and allows to ignore it
or to apply an own policy.

OK mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.52 2015/08/21 11:59:27 reyk Exp $	*/
d919 3
a921 1
		if (!len || (len % SHA_DIGEST_LENGTH) != 0) {
@


1.52
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.51 2015/08/19 14:12:43 reyk Exp $	*/
d934 1
a934 1
	ca_setreq(env, &sa->sa_hdr, &sa->sa_policy->pol_localid,
@


1.51
log
@spacing (no binary change, verified with checksums)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.50 2015/03/26 19:52:35 markus Exp $	*/
d49 1
a49 1
	    size_t, size_t, u_int);
d69 1
a69 1
	    struct iked_message *, size_t, size_t, u_int);
d93 1
a93 1
	    struct iked_message *, size_t, size_t, u_int);
d141 1
a141 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d179 1
a179 1
    size_t offset, size_t length, u_int payload)
d182 1
a182 1
	u_int			 e;
d184 1
a184 1
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
d285 1
a285 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d358 3
a360 3
	u_int32_t			 spi32;
	u_int64_t			 spi = 0, spi64;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d466 1
a466 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d575 1
a575 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d592 2
a593 2
	u_int				 type;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d646 1
a646 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d673 1
a673 1
	u_int8_t			*buf;
d675 1
a675 1
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d715 1
a715 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d739 1
a739 1
    struct iked_message *msg, size_t offset, size_t left, u_int payload)
d741 1
a741 1
	u_int8_t			*ptr;
d746 1
a746 1
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d798 1
a798 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d825 1
a825 1
	u_int8_t			*buf;
d828 1
a828 1
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d865 1
a865 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d893 1
a893 1
	u_int8_t			*buf;
d895 1
a895 1
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d944 1
a944 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d972 1
a972 1
	u_int8_t			*buf;
d975 1
a975 1
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d1034 2
a1035 2
	u_int8_t	*buf;
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d1072 1
a1072 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d1099 1
a1099 1
	u_int8_t		*buf, md[SHA_DIGEST_LENGTH];
d1101 2
a1102 2
	u_int32_t		 spi32;
	u_int64_t		 spi64;
d1104 5
a1108 5
	u_int16_t		 type;
	u_int16_t		 group;
	u_int16_t		 cpi;
	u_int16_t		 signature_hash;
	u_int8_t		 transform;
d1299 1
a1299 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d1329 4
a1332 4
	u_int64_t		*localspi = NULL;
	u_int64_t		 spi64, spi = 0;
	u_int32_t		 spi32;
	u_int8_t		*buf, *msgbuf = ibuf_data(msg->msg_data);
d1392 1
a1392 1
	     (localspi = calloc(cnt, sizeof(u_int64_t))) == NULL)) {
d1495 1
a1495 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d1519 1
a1519 1
    struct iked_message *msg, size_t offset, size_t left, u_int payload)
d1526 2
a1527 2
	u_int8_t			 buf[2][128];
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d1595 1
a1595 1
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
d1597 1
a1597 1
	u_int8_t		*buf;
d1641 1
a1641 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
d1669 1
a1669 1
	u_int8_t		*buf;
d1671 1
a1671 1
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
d1709 1
a1709 1
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
@


1.50
log
@initial support for RFC 7427 signatures, so we are no longer
restricted to SHA1 for RSA signatures. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.49 2015/02/06 10:39:01 deraadt Exp $	*/
d1183 4
a1186 1
		/* XXX chould also happen for PFS so we have to check state XXX*/
@


1.49
log
@unneeded getopt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.48 2015/01/19 14:42:42 mikeb Exp $	*/
d1107 1
d1255 30
@


1.48
log
@Remove unnecessary <netinet/ip_ipsp.h> includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.47 2015/01/16 06:39:58 deraadt Exp $	*/
a31 1
#include <getopt.h>
@


1.47
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.46 2014/11/07 14:05:58 mikeb Exp $	*/
a25 1
#include <netinet/ip_ipsp.h>
@


1.46
log
@Run eap_parse on the actual message and only when the length is right
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.45 2014/05/06 10:24:22 markus Exp $	*/
a19 1
#include <sys/param.h>
@


1.45
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.44 2014/05/06 09:21:50 markus Exp $	*/
d1728 3
a1731 3

	if (eap_parse(env, sa, &hdr, msg->msg_response) == -1)
		return (-1);
@


1.44
log
@don't sa_free() in the receive path (prevents use-after-free); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.43 2014/05/06 07:45:17 markus Exp $	*/
d1343 6
a1348 1
			return (ret);
a1349 1
		log_debug("%s: invalid SPI size", __func__);
@


1.43
log
@make sure some notify payloads are encrypted; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.42 2014/05/06 07:24:37 markus Exp $	*/
d1169 1
a1169 1
			sa_free(env, msg->msg_sa);
d1183 1
a1183 1
		sa_free(env, msg->msg_sa);
@


1.42
log
@initial support for PFS; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.41 2014/05/05 15:21:20 markus Exp $	*/
d1155 6
d1190 5
d1202 4
d1238 5
@


1.41
log
@validate the attribute length, too; from hshoexer; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.40 2014/04/28 11:21:02 reyk Exp $	*/
d1160 1
d1179 1
@


1.40
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.39 2014/04/10 16:08:02 reyk Exp $	*/
d619 6
@


1.39
log
@Add validation routines to ikev2_pld.c: For each payload type overall
header structure is checked for sanity before copying the header.
Always pass down the number of remaining bytes in the payload or
substructure so we can always ensure to not go beyond actual data.
Also remove the quick parsing step as it does not provide a real
benefit anymore.

From Hans-Joerg Hoexer

ok mikeb@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.38 2014/02/17 11:00:14 reyk Exp $	*/
d487 1
a487 1
		   "(%zu < %zu)", __func__, total, xfrm_length);
d1374 1
a1374 1
    	if (msg->msg_parent->msg_response) {
@


1.38
log
@Fix compiler warnings in the format strings: use %zd for ssize_t and
%zu for size_t.

From Andre de Oliveira
With input and OK from blambert@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.37 2014/02/14 09:00:03 markus Exp $	*/
d5 1
d49 2
d52 3
a54 1
	    off_t, size_t, u_int, int);
d56 3
a58 1
	    struct iked_message *, off_t);
d60 3
a62 1
	    struct iked_message *, off_t);
d64 3
a66 1
	    struct iked_message *, off_t, int);
d68 3
a70 1
	    struct iked_message *, off_t);
d72 3
a74 1
	    struct iked_message *, off_t, u_int);
d76 3
a78 1
	    struct iked_message *, off_t);
d80 3
a82 1
	    struct iked_message *, off_t);
d84 3
a86 1
	    struct iked_message *, off_t);
d88 3
a90 1
	    struct iked_message *, off_t);
d92 3
a94 1
	    struct iked_message *, off_t);
d96 3
a98 1
	    struct iked_message *, off_t, u_int);
d100 1
a100 1
	    struct iked_message *, off_t);
d102 3
a104 1
	    struct iked_message *, off_t);
d106 3
a108 1
	    struct iked_message *, off_t);
d110 1
a110 1
	    struct iked_message *, off_t);
d114 1
a114 1
    struct iked_message *msg, off_t offset)
d137 41
a177 1
	    betoh32(hdr->ike_length), hdr->ike_nextpayload, 0));
d182 1
a182 1
    off_t offset, size_t length, u_int payload, int quick)
d188 1
d193 3
a195 5
	if (quick)
		print_debug("%s: %spayloads", __func__,
		    e ? "decrypted " : "");
	else
		ikev2_pld_payloads(env, msg, offset, length, payload, 1);
d197 2
a198 2
	while (payload != 0 && offset < (off_t)length) {
		memcpy(&pld, msgbuf + offset, sizeof(pld));
d200 7
a206 11
		if (quick)
			print_debug(" %s",
			    print_map(payload, ikev2_payload_map));
		else
			log_debug("%s: %spayload %s"
			    " nextpayload %s critical 0x%02x length %d",
			    __func__, e ? "decrypted " : "",
			    print_map(payload, ikev2_payload_map),
			    print_map(pld.pld_nextpayload, ikev2_payload_map),
			    pld.pld_reserved & IKEV2_CRITICAL_PAYLOAD,
			    betoh16(pld.pld_length));
d208 1
d210 1
a212 3
		if (quick)
			goto next;

d216 1
a216 1
			ret = ikev2_pld_sa(env, &pld, msg, offset);
d220 1
a220 1
			ret = ikev2_pld_ke(env, &pld, msg, offset);
d224 2
a225 1
			ret = ikev2_pld_id(env, &pld, msg, offset, payload);
d228 1
a228 1
			ret = ikev2_pld_cert(env, &pld, msg, offset);
d232 1
a232 1
			ret = ikev2_pld_certreq(env, &pld, msg, offset);
d235 1
a235 1
			ret = ikev2_pld_auth(env, &pld, msg, offset);
d239 1
a239 1
			ret = ikev2_pld_nonce(env, &pld, msg, offset);
d243 1
a243 1
			ret = ikev2_pld_notify(env, &pld, msg, offset);
d246 1
a246 1
			ret = ikev2_pld_delete(env, &pld, msg, offset);
d250 2
a251 1
			ret = ikev2_pld_ts(env, &pld, msg, offset, payload);
d257 1
a257 1
			ret = ikev2_pld_cp(env, &pld, msg, offset);
d260 1
a260 1
			ret = ikev2_pld_eap(env, &pld, msg, offset);
a276 1
 next:
d281 25
a305 2
	if (quick)
		print_debug("\n");
d307 41
d351 4
d357 1
a357 1
    struct iked_message *msg, off_t offset)
d365 10
a377 1
	memcpy(&sap, msgbuf + offset, sizeof(sap));
d379 1
d382 17
d415 14
d457 1
a457 1
	    ikev2_pld_xform(env, &sap, msg, offset) != 0) {
d466 29
d496 1
a496 1
    struct iked_message *msg, off_t offset)
d500 5
a504 1
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
d506 1
a506 1
	memcpy(&xfrm, msgbuf + offset, sizeof(xfrm));
d534 1
a534 1
	log_debug("%s: more %d reserved %d length %d"
d536 1
a536 2
	    __func__, xfrm.xfrm_more, xfrm.xfrm_reserved,
	    betoh16(xfrm.xfrm_length),
d543 6
a548 3
	if ((u_int)betoh16(xfrm.xfrm_length) > sizeof(xfrm))
		ikev2_pld_attr(env, &xfrm, msg, offset + sizeof(xfrm),
		    betoh16(xfrm.xfrm_length) - sizeof(xfrm));
d560 2
a561 1
	offset += betoh16(xfrm.xfrm_length);
d563 23
a585 1
		ikev2_pld_xform(env, sap, msg, offset);
d592 1
a592 1
    struct iked_message *msg, off_t offset, int total)
d597 2
d600 2
a601 1
	memcpy(&attr, msgbuf + offset, sizeof(attr));
d605 1
a605 1
	log_debug("%s: attribute type %s length %d total %d",
d618 7
d626 3
a628 3
		    betoh16(attr.attr_length) - sizeof(attr));
		offset += betoh16(attr.attr_length);
		total -= betoh16(attr.attr_length);
d633 1
a633 1
		ikev2_pld_attr(env, xfrm, msg, offset, total);
d636 26
d667 1
a667 1
    struct iked_message *msg, off_t offset)
d674 2
a675 1
	memcpy(&kex, msgbuf + offset, sizeof(kex));
d684 11
d709 26
d736 1
a736 1
    struct iked_message *msg, off_t offset, u_int payload)
d746 3
a748 1
	memcpy(&id, msgbuf + offset, sizeof(id));
d792 26
d819 1
a819 1
    struct iked_message *msg, off_t offset)
d827 2
a828 1
	memcpy(&cert, msgbuf + offset, sizeof(cert));
d859 26
d886 1
a886 1
    struct iked_message *msg, off_t offset)
d894 2
a895 1
	memcpy(&cert, msgbuf + offset, sizeof(cert));
d904 1
d938 26
d965 1
a965 1
    struct iked_message *msg, off_t offset)
d974 2
a975 1
	memcpy(&auth, msgbuf + offset, sizeof(auth));
d1009 18
d1028 1
a1028 1
    struct iked_message *msg, off_t offset)
d1034 3
d1039 12
d1066 26
d1093 1
a1093 1
    struct iked_message *msg, off_t offset)
d1095 1
a1095 1
	struct ikev2_notify	*n;
d1106 1
a1106 1
	if ((n = ibuf_seek(msg->msg_data, offset, sizeof(*n))) == NULL)
d1108 1
a1108 1
	type = betoh16(n->n_type);
d1112 1
a1112 1
	    print_map(n->n_protoid, ikev2_saproto_map), n->n_spisize,
d1115 2
a1116 2
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(*n);
	if ((buf = ibuf_seek(msg->msg_data, offset + sizeof(*n), len)) == NULL)
d1127 5
d1134 1
a1134 1
		if (len != sizeof(md) || memcmp(buf, md, len) != 0) {
d1150 2
a1151 1
			log_debug("%s: malformed notification", __func__);
d1183 1
a1183 1
		if (len != n->n_spisize) {
d1193 1
a1193 1
		switch (n->n_spisize) {
d1204 1
a1204 1
			    n->n_spisize);
d1207 2
a1208 2
		rekey->spi_size = n->n_spisize;
		rekey->spi_protoid = n->n_protoid;
d1211 2
a1212 2
		    print_map(n->n_protoid, ikev2_saproto_map),
		    print_spi(rekey->spi, n->n_spisize));
d1216 1
a1216 1
			log_debug("%s: malformed ipcomp notification",
d1237 26
d1264 1
a1264 1
    struct iked_message *msg, off_t offset)
d1268 1
a1268 1
	struct ikev2_delete	*del, *localdel;
d1277 4
a1280 7
	/* Skip if it's a reply and we don't have to deal with it */
	if (ikev2_msg_frompeer(msg) && sa &&
	    (sa->sa_stateflags & IKED_REQ_INF)) {
		sa->sa_stateflags &= ~IKED_REQ_INF;
		if ((sa->sa_stateflags & IKED_REQ_DELETE) == 0)
			return (0);
	}
d1282 1
a1282 1
	if ((del = ibuf_seek(msg->msg_data, offset, sizeof(*del))) == NULL)
d1284 2
a1285 2
	cnt = betoh16(del->del_nspi);
	sz = del->del_spisize;
d1288 1
a1288 1
	    __func__, print_map(del->del_protoid, ikev2_saproto_map),
d1291 2
a1292 2
	buf = msgbuf + offset + sizeof(*del);
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(*del);
d1301 5
a1305 2
		if (ikev2_msg_frompeer(msg) &&
		    del->del_protoid == IKEV2_SAPROTO_IKE) {
d1318 1
a1318 1
		return (-1);
d1352 1
a1352 1
		    del->del_protoid)) == NULL) {
d1354 2
a1355 2
			    __func__, print_spi(spi, del->del_spisize));
			goto done;
d1358 1
a1358 1
		if (ikev2_childsa_delete(env, sa, del->del_protoid, spi,
d1374 1
a1374 3
	if (sa && (sa->sa_stateflags & IKED_REQ_DELETE)) {
		/* Finish rekeying */
		sa->sa_stateflags &= ~IKED_REQ_DELETE;
d1388 2
a1389 2
		localdel->del_protoid = del->del_protoid;
		localdel->del_spisize = del->del_spisize;
d1429 26
d1456 1
a1456 1
    struct iked_message *msg, off_t offset, u_int payload)
d1466 2
a1467 1
	memcpy(&tsp, msgbuf + offset, sizeof(tsp));
d1528 1
a1528 1
    struct iked_message *msg, off_t offset)
d1566 1
a1566 1
	    pld->pld_nextpayload, 0);
d1575 26
d1602 1
a1602 1
    struct iked_message *msg, off_t offset)
d1611 2
a1612 1
	memcpy(&cp, msgbuf + offset, sizeof(cp));
d1643 26
d1670 1
a1670 1
    struct iked_message *msg, off_t offset)
d1672 1
a1672 1
	struct eap_header		*hdr;
d1677 1
a1677 2
	if ((hdr = ibuf_seek(msg->msg_data, offset, sizeof(*hdr))) == NULL) {
		log_debug("%s: failed to get EAP header", __func__);
d1679 1
a1679 3
	}

	len = betoh16(hdr->eap_length);
d1683 2
a1684 2
		    print_map(hdr->eap_code, eap_code_map),
		    hdr->eap_id, betoh16(hdr->eap_length));
d1698 1
a1698 1
	if (eap_parse(env, sa, hdr, msg->msg_response) == -1)
@


1.37
log
@initial support for IPComp
still experimental and rekeying needs some work; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.36 2014/02/12 12:59:44 markus Exp $	*/
d456 1
a456 1
	log_debug("%s: id %s length %d", __func__, idstr, len);
d498 1
a498 1
	log_debug("%s: type %s length %d",
d538 1
a538 1
	log_debug("%s: type %s length %d",
d590 1
a590 1
	log_debug("%s: method %s length %d",
d766 1
a766 1
		log_debug("%s: cpi 0x%x, transform %s, len %d", __func__,
d927 1
a927 1
		log_warnx("%s: deleted %d spis", __func__, found);
d965 1
a965 1
	log_debug("%s: count %d length %d", __func__,
d1084 1
a1084 1
	log_debug("%s: type %s length %d",
@


1.36
log
@make sure to set the msg_responded flag on the original message; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.35 2014/01/24 05:58:52 mikeb Exp $	*/
d653 2
d757 17
@


1.35
log
@use a bit saner timer api
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.34 2014/01/22 09:25:41 markus Exp $	*/
d811 1
a811 1
			msg->msg_responded = 1;
d914 1
a914 1
		msg->msg_responded = 1;
@


1.34
log
@implement DPD similar to isakmpd, but only send DPD-messages 'on-demand'
(less aggressive, only if the ESP-SAs are actually used);
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.33 2013/12/03 13:55:39 markus Exp $	*/
d714 2
a715 3
		timer_initialize(env, &env->sc_inittmr, ikev2_init_ike_sa,
		    NULL);
		timer_register(env, &env->sc_inittmr, IKED_INITIATOR_INITIAL);
@


1.33
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.32 2013/11/28 20:21:17 markus Exp $	*/
d812 1
d915 1
@


1.32
log
@support raw pubkey authentication w/o x509 certificates;
mostly by Michael Cardell Widerkrantz, reyk@@ and mikeb@@; ok mike@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.31 2013/03/21 04:30:14 deraadt Exp $	*/
d965 1
a965 1
			print_host((struct sockaddr_storage *)&s4,
d969 1
a969 1
			print_host((struct sockaddr_storage *)&s4,
d980 1
a980 1
			print_host((struct sockaddr_storage *)&s6,
d984 1
a984 1
			print_host((struct sockaddr_storage *)&s6,
@


1.31
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.30 2013/01/08 10:38:19 reyk Exp $	*/
d529 1
a529 1
	size_t				 len;
d538 1
a538 1
	log_debug("%s: type %s signatures length %d",
d540 6
d551 5
a555 3
	if (!len || (len % SHA_DIGEST_LENGTH) != 0) {
		log_debug("%s: invalid certificate request", __func__);
		return (-1);
@


1.30
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.29 2012/12/15 23:12:21 reyk Exp $	*/
a19 1
#include <sys/types.h>
@


1.29
log
@Don't dereference NULL pointers (and some cleanup here).
@
text
@d1 1
a1 2
/*	$OpenBSD: ikev2_pld.c,v 1.28 2012/10/22 10:25:17 reyk Exp $	*/
/*	$vantronix: ikev2.c,v 1.101 2010/06/03 07:57:33 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.28
log
@Fix NAT-T support in iked, both on the initiator and the responder
side.  Also add a new command line option -t to optionally enforce
NAT-T with UDP encapsulation on port 4500.

Tested by mikeb@@ and me
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.27 2012/09/18 12:07:59 reyk Exp $	*/
d841 1
a841 1
		if (!ikev2_msg_frompeer(msg))
d867 1
a867 1
	if (ikev2_msg_frompeer(msg) && (sa->sa_stateflags & IKED_REQ_DELETE)) {
a925 1
	u_int8_t			*ptr;
a936 1
	ptr = msgbuf + offset;
@


1.27
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.26 2012/06/22 16:06:31 mikeb Exp $	*/
d669 1
a669 1
		if (ikev2_nat_detection(msg, md, sizeof(md), type) == -1)
@


1.26
log
@decouple timer initialization from timer_register
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.25 2012/05/30 16:17:20 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.25
log
@more timer changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.24 2012/05/29 15:09:12 mikeb Exp $	*/
d708 3
a710 2
		timer_register(env, &env->sc_inittmr, ikev2_init_ike_sa, NULL,
		    IKED_INITIATOR_INITIAL);
@


1.24
log
@improve timer framework; will be needed soon
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.23 2012/05/07 10:58:38 mikeb Exp $	*/
d708 1
a708 1
		timer_register(&env->sc_inittmr, env, ikev2_init_ike_sa, NULL,
@


1.23
log
@Sync up several defines with RFC 5996.  IANA has changed the existing
IKEv2 Payload Type "Encrypted" (E) to "Encrypted and Authenticated" (SK).
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.22 2012/03/24 00:40:25 jsg Exp $	*/
d708 2
a709 1
		timer_register_initiator(env, ikev2_init_ike_sa);
@


1.22
log
@fix some leaks
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.21 2011/01/26 16:59:24 mikeb Exp $	*/
d188 1
a188 1
		case IKEV2_PAYLOAD_E:
d209 1
a209 1
		if (payload == IKEV2_PAYLOAD_E)
@


1.21
log
@get rid of acquire flows completely, as they tend to pass traffic
when there's no sa established (as pointed out by reyk).  instead
use require mode feature to send acquires from the kernel.  this
allows us to get rid of the code that changes flow mode to acquire
and keep all installed flows in the tree and save up on some code
that deals with renegotiation.  also several entities were renamed
(iked_acqflows -> iked_activeflows, iked_ipsecsas -> iked_activesas,
ikev2_acquire -> ikev2_acquire_sa).   ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.20 2011/01/17 18:49:35 mikeb Exp $	*/
d863 1
a863 1
		return (0);
@


1.20
log
@Add initial acquire mode support and use it whenever Windows peers decide
to drop Child SA based on the inactivity timer.  In this case we instruct
the kernel to send us an acquire message upon receiving a packet for those
hosts and initiate a Child SA creation exchange ourselves.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.19 2011/01/12 14:26:26 mikeb Exp $	*/
d856 2
a857 2
		 * Change flows to acquire mode so that it would be possible
		 * to negotiate a new Child SA quickly
a858 2
		if (!peersas[i]->csa_rekey)
			ikev2_flows_delete(env, sa, del->del_protoid, 1);
@


1.19
log
@decouple flow deletion from the ikev2_childsa_delete;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.18 2010/12/22 17:53:54 reyk Exp $	*/
d855 4
d860 1
a860 1
			ikev2_flows_delete(env, sa, del->del_protoid);
@


1.18
log
@move and rename util.c:print_id() to ikev2.c:ikev2_print_id() because
it is too specific to be in util.c.  This will allow to link util.c
into ikectl later without all the other dependencies of pritn_id().
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.17 2010/12/22 16:22:27 mikeb Exp $	*/
d850 1
a850 2
		    &localspi[i], peersas[i]->csa_rekey ? 0 :
		    IKED_DEL_FLOWS) == -1)
d854 3
@


1.17
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.16 2010/09/30 12:54:24 mikeb Exp $	*/
d453 1
a453 1
	if (print_id(&idb, idstr, sizeof(idstr)) == -1) {
@


1.16
log
@check that there are transforms in the proposal before trying
to actually parse it.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.15 2010/09/22 09:12:18 mikeb Exp $	*/
d156 1
d266 1
a266 1
		if ((msg->msg_prop = config_add_proposal(props,
d271 6
a276 1
		prop = msg->msg_prop;
a277 1
		prop->prop_peerspi.spi = spi;
d343 3
a345 3
		if (config_add_transform(msg->msg_prop, xfrm.xfrm_type,
		    betoh16(xfrm.xfrm_id), msg->msg_attrlength,
		    msg->msg_attrlength) == NULL) {
d409 1
a409 2
	log_debug("%s: dh group %s reserved %d",
	    __func__,
d629 1
d685 32
a748 25
	case IKEV2_N_INVALID_KE_PAYLOAD:
		if (len != sizeof(group)) {
			log_debug("%s: malformed notification", __func__);
			return (-1);
		}
		if (!msg->msg_sa->sa_hdr.sh_initiator) {
			log_debug("%s: not an initiator", __func__);
			sa_free(env, msg->msg_sa);
			msg->msg_sa = NULL;
			return (-1);
		}
		memcpy(&group, buf, len);
		group = betoh16(group);
		if ((msg->msg_policy->pol_peerdh = group_get(group))
		    == NULL) {
			log_debug("%s: unable to select DH group %d", __func__,
			    group);
			return (-1);
		}
		log_debug("%s: responder selected DH group %d", __func__,
		    group);
		sa_free(env, msg->msg_sa);
		msg->msg_sa = NULL;
		timer_register_initiator(env, ikev2_init_ike_sa);
		break;
d758 2
d761 3
a763 1
	u_int64_t		 spi64, spi = 0, *localspi = NULL;
d765 11
a775 6
	size_t			 len, i, cnt, sz, found = 0, failed = 0;
	u_int8_t		*buf, firstpayload = 0;
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
	struct iked_sa		*sa = msg->msg_sa;
	struct ibuf		*resp = NULL;
	int			 ret = -1;
d782 1
a782 1
	log_debug("%s: protoid %s spisize %d nspi %d",
d798 7
d806 1
a806 1
			return (0);
d819 2
a820 1
	    (localspi = calloc(cnt, sizeof(u_int64_t))) == NULL) {
d822 1
a822 1
		return (-1);
a825 1
		/* XXX delete SAs */
d836 4
a839 2
		if (!ikev2_msg_frompeer(msg)) {
			log_debug("%s: spi %s", __func__, print_spi(spi, sz));
d841 6
d849 3
a851 2
		if (ikev2_childsa_delete(env, sa,
		    del->del_protoid, spi, &localspi[i], 0) == -1)
d857 1
d861 9
a876 1
		firstpayload = IKEV2_PAYLOAD_DELETE;
a881 3
			if (!localspi[i])
				continue;

d896 1
d900 2
a901 2
		ret = ikev2_send_ike_e(env, sa, resp,
		    firstpayload, IKEV2_EXCHANGE_INFORMATIONAL, 1);
d908 1
a908 1
	if (localspi != NULL)
d910 2
d1054 1
a1054 1
	log_debug("%s: type %s",
@


1.15
log
@support INVALID_KE_PAYLOAD notification sent by the responder in case
the initiator chose wrong D-H group.  in this case we throw away our
SA and start over with a proper group.

makes iked work as an initiator with strongswan/charon without any
specific "ikesa" (phase 1) configuration.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.14 2010/07/28 15:45:04 jsg Exp $	*/
d278 2
a279 1
	if (ikev2_pld_xform(env, &sap, msg, offset) != 0) {
@


1.14
log
@Change back to the pre rev 1.11 behaviour of not treating unexpected
id payloads as errors.  Lets interop with strongSwan which sends
both IDi and IDr work again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.13 2010/07/03 16:59:35 reyk Exp $	*/
a635 1
	u_int16_t		 type;
d639 3
a641 1
	
d710 25
@


1.13
log
@Better non-debug logging messages when a session is established/closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.12 2010/06/27 05:49:05 reyk Exp $	*/
d463 1
a463 1
		return (-1);
@


1.12
log
@When a peer requests a certificate from the local gateway, we first
lookup a cert from /etc/iked/certs/ that is signed by a requested CA.
As a second step we also compare the subjectAltName of any found
certificate now to match the local srcid; this allows to have multiple
certs for the same CA but different srcids in the certs/ directory but
enforces that the subjectAltName has to be set correctly.

requested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.11 2010/06/27 01:03:22 reyk Exp $	*/
d750 1
a750 1
			sa_state(env, sa, IKEV2_STATE_DELETE);
@


1.11
log
@Instead of modifying and fiddling with the IKE SA in the payload
parsing routines directly, first parse the message and save the parsed
elements in the temporary message struct before validating the
information and taking any other actions on the actual SA.  This needs
more testing, but is the cleaner and better approach.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.9 2010/06/26 19:48:04 reyk Exp $	*/
d556 2
a557 1
	ca_setreq(env, &sa->sa_hdr, cert.cert_type, buf, len, PROC_CERT);
@


1.10
log
@revert the files that have been accidentally committed with my
previous parse.y change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.8 2010/06/26 18:32:34 reyk Exp $	*/
d121 1
a121 1
	e = msg->msg_decrypted ? IKED_E : 0;
d233 1
a233 4
	if (msg->msg_decrypted)
		props = &msg->msg_decrypted->msg_proposals;
	else
		props = &msg->msg_proposals;
d414 2
a415 2
		ibuf_release(msg->msg_ke);
		if ((msg->msg_ke = ibuf_new(buf, len)) == NULL) {
a433 1
	struct ibuf			*authmsg;
d460 2
a461 5
	if (sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDr) {
		idp = &sa->sa_rid;
	} else if (!sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDi) {
		idp = &sa->sa_iid;
	} else {
d463 1
a463 1
		return (0);
d466 3
a468 7
	ibuf_release(idp->id_buf);
	idp->id_buf = idb.id_buf;
	idp->id_type = idb.id_type;

	if ((authmsg = ikev2_msg_auth(env, sa,
	    !sa->sa_hdr.sh_initiator)) == NULL) {
		log_debug("%s: failed to get response auth data", __func__);
d472 3
a474 1
	ca_setauth(env, sa, authmsg, PROC_CERT);
d486 1
a486 2
	struct iked_sa			*sa = msg->msg_sa;
	struct iked_id			*certid, *id;
d503 5
a507 8
	if (!sa->sa_hdr.sh_initiator) {
		certid = &sa->sa_icert;
		id = &sa->sa_iid;
	} else if (sa->sa_hdr.sh_initiator) {
		certid = &sa->sa_rcert;
		id = &sa->sa_rid;
	} else
		return (0);	/* ignore */
d514 1
a514 3

	ca_setcert(env, &msg->msg_sa->sa_hdr, id, cert.cert_type,
	    buf, len, PROC_CERT);
d566 1
a566 1
	struct iked_auth		 ikeauth;
a568 1
	struct ibuf			*authmsg;
a569 2
	struct iked_policy		*policy = sa->sa_policy;
	int				 ret = -1;
a585 17
	memcpy(&ikeauth, &policy->pol_auth, sizeof(ikeauth));

	if (policy->pol_auth.auth_eap && sa->sa_eapmsk != NULL) {
		/* The initiator EAP auth is a PSK derived from the MSK */
		ikeauth.auth_method = IKEV2_AUTH_SHARED_KEY_MIC;

		/* Copy session key as PSK */
		memcpy(ikeauth.auth_data, ibuf_data(sa->sa_eapmsk),
		    ibuf_size(sa->sa_eapmsk));
		ikeauth.auth_length = ibuf_size(sa->sa_eapmsk);
	}
	if (auth.auth_method != ikeauth.auth_method) {
		log_debug("%s: method %s required", __func__,
		    print_map(ikeauth.auth_method, ikev2_auth_map));
		return (-1);
	}

d590 3
a592 3
	if ((authmsg = ikev2_msg_auth(env, sa,
	    sa->sa_hdr.sh_initiator)) == NULL) {
		log_debug("%s: failed to get auth data", __func__);
d596 5
a600 2
	ret = ikev2_msg_authverify(env, sa, &ikeauth, buf, len,
	    authmsg);
d602 1
a602 25
	ibuf_release(authmsg);
	authmsg = NULL;

	if (ret != 0)
		goto done;

	if (sa->sa_eapmsk != NULL) {
		if ((authmsg = ikev2_msg_auth(env, sa,
		    !sa->sa_hdr.sh_initiator)) == NULL) {
			log_debug("%s: failed to get auth data", __func__);
			return (-1);
		}

		/* 2nd AUTH for EAP messages */
		if ((ret = ikev2_msg_authsign(env, sa,
		    &ikeauth, authmsg)) != 0)
			goto done;

		sa_state(env, sa, IKEV2_STATE_EAP_VALID);
	}

 done:
	ibuf_release(authmsg);

	return (ret);
d682 1
a682 4
		if (msg->msg_decrypted)
			rekey = &msg->msg_decrypted->msg_rekey;
		else
			rekey = &msg->msg_rekey;
d950 2
a951 1
	emsg.msg_decrypted = msg;
@


1.9
log
@mixing any (AF_UNSPEC) with AF_INET/INET6 is not an address family mismatch
@
text
@d437 1
d464 5
a468 2
	if (!((sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDr) ||
	    (!sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDi))) {
d470 1
a470 1
		return (-1);
d473 7
a479 3
	idp = &msg->msg_id;
	if (idp->id_type) {
		log_debug("%s: duplicate id payload", __func__);
d483 1
a483 4
	ibuf_release(idp->id_buf);
	idp->id_buf = idb.id_buf;
	idp->id_offset = idb.id_offset;
	idp->id_type = idb.id_type;
@


1.8
log
@Include the Id type in the generated SA tag that is passed to the
kernel, just like isakmpd does it.  In difference to isakmpd, the Id
type is printed in capital letters, eg. FQDN/foo.example.com, because
it is using the existing print_map() API.  For consistency, rename a
few Id types in grammar and code from the RFC-names to the
OpenBSD-style names; including RFC822_ADDR to UFQDN, IPV4_ADDR to just
IPV4, DER_ASN1_DN to ASN1_DN etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.7 2010/06/14 23:14:09 reyk Exp $	*/
a436 1
	struct ibuf			*authmsg;
d463 2
a464 5
	if (sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDr) {
		idp = &sa->sa_rid;
	} else if (!sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDi) {
		idp = &sa->sa_iid;
	} else {
d466 7
a472 1
		return (0);
d477 1
a478 8

	if ((authmsg = ikev2_msg_auth(env, sa,
	    !sa->sa_hdr.sh_initiator)) == NULL) {
		log_debug("%s: failed to get response auth data", __func__);
		return (-1);
	}

	ca_setauth(env, sa, authmsg, PROC_CERT);
@


1.7
log
@Initiator mode with certificates;  needs more work but works.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.6 2010/06/14 21:12:56 reyk Exp $	*/
d448 1
d452 1
a452 1
	if (print_id(&idb, sizeof(id), idstr, sizeof(idstr)) == -1) {
d457 1
a457 2
	log_debug("%s: id %s/%s length %d",
	    __func__, print_map(id.id_type, ikev2_id_map), idstr, len);
@


1.6
log
@Initial support for initiator mode which allows to run iked as a
"client" or to configure iked to iked (OpenBSD to OpenBSD) IKEv2 VPNs.

It currently only supports psk (pre-shared keys) and no certificates,
doesn't do any rekeying or SA timeouts, and needs more cleanup.  So it
is not quite production ready yet - but ready for simple tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.5 2010/06/14 14:03:15 reyk Exp $	*/
d513 1
a513 1
	if (!sa->sa_hdr.sh_initiator && !msg->msg_response) {
d516 1
a516 1
	} else if (sa->sa_hdr.sh_initiator && msg->msg_response) {
d538 1
d566 4
a569 1
	msg->msg_sa->sa_staterequire |= IKED_REQ_CERT;
d571 1
a571 2
	ca_setreq(env, &msg->msg_sa->sa_hdr, cert.cert_type,
	    buf, len, PROC_CERT);
@


1.5
log
@NAT detection again: make it work in initiator and responder mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.4 2010/06/14 12:05:32 reyk Exp $	*/
d975 1
d989 9
a997 2
	if ((e = ikev2_msg_decrypt(env, msg->msg_sa,
	    msg->msg_data, e)) == NULL)
@


1.4
log
@NAT detection with SPIr is always 0
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.3 2010/06/14 11:33:55 reyk Exp $	*/
d714 1
a714 2
		if (ikev2_nat_detection(msg, md, sizeof(md), type,
		    ikev2_msg_frompeer(msg)) == -1)
@


1.3
log
@restructure code a bit to move closer to initiator mode:
- split responder/initiator- specific code into different functions and use
shared functions for common stuff.
- first parse the received message and store information in the temporary
message struct instead of modifying the ike sa in the parsing code directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.2 2010/06/14 08:10:32 reyk Exp $	*/
d708 3
d715 1
a715 1
		    msg->msg_response) == -1)
@


1.2
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_pld.c,v 1.1 2010/06/10 08:29:47 reyk Exp $	*/
d231 6
a236 1
	struct iked_sa			*sa = msg->msg_sa;
d268 1
a268 1
		if ((msg->msg_prop = config_add_proposal(&msg->msg_proposals,
a285 14
	if (!ikev2_msg_frompeer(msg))
		return (0);

	/* XXX we need a better way to get this */
	if (ikev2_sa_negotiate(sa,
	    &msg->msg_policy->pol_proposals,
	    &msg->msg_proposals, msg->msg_decrypted ?
	    IKEV2_SAPROTO_ESP : IKEV2_SAPROTO_IKE) != 0) {
		log_debug("%s: no proposal chosen", __func__);
		msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
		return (-1);
	} else if (sa_stateok(sa, IKEV2_STATE_SA_INIT))
		sa_stateflags(sa, IKED_REQ_SA);

d417 2
a418 2
		if ((msg->msg_sa->sa_dhiexchange =
		    ibuf_new(buf, len)) == NULL) {
a664 2
	struct iked_sa	*sa = msg->msg_sa;
	struct ibuf	*peernonce;
d671 2
a672 1
		if ((peernonce = ibuf_new(buf, len)) == NULL) {
a674 10
		}

		log_debug("%s: updating peer nonce", __func__);

		if (sa->sa_hdr.sh_initiator) {
			ibuf_release(sa->sa_rnonce);
			sa->sa_rnonce = peernonce;
		} else {
			ibuf_release(sa->sa_inonce);
			sa->sa_inonce = peernonce;
@


1.1
log
@i don't like splitting source code in too many source files but ikev2.c
has grown too large, so split it in 3 files and rename a few functions
to organize the code a bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.2 2010/06/04 09:51:45 reyk Exp $	*/
d202 1
a202 1
		if (ret != 0 && !msg->msg_response) {
d262 1
a262 1
	if (!msg->msg_response) {
d281 1
a281 1
	if (msg->msg_response)
d348 1
a348 1
	if (!msg->msg_response) {
d425 1
a425 1
	if (!msg->msg_response) {
d468 1
a468 1
	if (msg->msg_response) {
d519 1
a519 1
	if (msg->msg_response)
d562 1
a562 1
	if (msg->msg_response)
d607 1
a607 1
	if (msg->msg_response)
d675 1
a675 1
	struct ibuf	*localnonce, *peernonce;
d681 1
a681 1
	if (!msg->msg_response) {
a685 9
		if ((localnonce =
		    ibuf_random(IKED_NONCE_SIZE)) == NULL) {
			log_debug("%s: failed to get local nonce", __func__);
			ibuf_release(peernonce);
			return (-1);
		}

		ibuf_release(sa->sa_inonce);
		ibuf_release(sa->sa_rnonce);
d687 1
a687 1
		log_debug("%s: updating nonces", __func__);
d690 1
a690 1
			sa->sa_inonce = localnonce;
d693 1
a694 1
			sa->sa_rnonce = localnonce;
d821 1
a821 1
		if (!msg->msg_response &&
d836 1
a836 1
	if (!msg->msg_response &&
d854 1
a854 1
		if (msg->msg_response) {
d866 1
a866 1
	if (msg->msg_response)
d1060 1
a1060 1
	if (msg->msg_response)
@

