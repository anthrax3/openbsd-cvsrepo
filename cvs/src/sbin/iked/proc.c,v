head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.30
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.29;
commitid	eA8b246voAapPTkX;

1.29
date	2015.12.07.16.05.56;	author reyk;	state Exp;
branches;
next	1.28;
commitid	N57bKZPTW9wbXnJY;

1.28
date	2015.12.07.12.46.37;	author reyk;	state Exp;
branches;
next	1.27;
commitid	8zCLewXZF0DAEoO0;

1.27
date	2015.12.05.13.09.46;	author claudio;	state Exp;
branches;
next	1.26;
commitid	pOVYglb4bj0794uz;

1.26
date	2015.11.23.19.28.34;	author reyk;	state Exp;
branches;
next	1.25;
commitid	m6hksQq6WXPE2kks;

1.25
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.24;
commitid	T3JBYxNT0thPuavp;

1.24
date	2015.10.22.15.55.18;	author reyk;	state Exp;
branches;
next	1.23;
commitid	9R73DxVDj9dmoXct;

1.23
date	2015.08.21.11.59.28;	author reyk;	state Exp;
branches;
next	1.22;
commitid	CNs9dXqQUQ09vB19;

1.22
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.12.16.03.35.49;	author millert;	state Exp;
branches;
next	1.20;
commitid	nQ60kcXwyMctmczv;

1.20
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.19;
commitid	RKMpGS78lskgSHj4;

1.19
date	2014.08.18.09.43.02;	author reyk;	state Exp;
branches;
next	1.18;
commitid	o804X3aJRVygt1Ju;

1.18
date	2014.07.12.14.15.04;	author reyk;	state Exp;
branches;
next	1.17;
commitid	9Lw1doh9INJVoqMv;

1.17
date	2014.05.08.13.11.16;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.06.06.40.03;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.04.10.35.24;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.18.21.29.20;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.14.07.18.05;	author blambert;	state Exp;
branches;
next	1.11;

1.11
date	2014.02.14.10.23.43;	author benno;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.15.12.30.19;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.09.11.27.08;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.05.12.59.31;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.16.09.27.35;	author mikeb;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: proc.c,v 1.29 2015/12/07 16:05:56 reyk Exp $	*/

/*
 * Copyright (c) 2010 - 2014 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <pwd.h>
#include <event.h>
#include <imsg.h>

#include "iked.h"

void	 proc_open(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, size_t);
void	 proc_close(struct privsep *);
int	 proc_ispeer(struct privsep_proc *, unsigned int, enum privsep_procid);
void	 proc_shutdown(struct privsep_proc *);
void	 proc_sig_handler(int, short, void *);
void	 proc_range(struct privsep *, enum privsep_procid, int *, int *);
int	 proc_dispatch_null(int, struct privsep_proc *, struct imsg *);

int
proc_ispeer(struct privsep_proc *procs, unsigned int nproc,
    enum privsep_procid type)
{
	unsigned int	i;

	for (i = 0; i < nproc; i++)
		if (procs[i].p_id == type)
			return (1);
	return (0);
}

void
proc_init(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc)
{
	unsigned int		 i, j, src, dst;
	struct privsep_pipes	*pp;

	/*
	 * Allocate pipes for all process instances (incl. parent)
	 *
	 * - ps->ps_pipes: N:M mapping
	 * N source processes connected to M destination processes:
	 * [src][instances][dst][instances], for example
	 * [PROC_RELAY][3][PROC_CA][3]
	 *
	 * - ps->ps_pp: per-process 1:M part of ps->ps_pipes
	 * Each process instance has a destination array of socketpair fds:
	 * [dst][instances], for example
	 * [PROC_PARENT][0]
	 */
	for (src = 0; src < PROC_MAX; src++) {
		/* Allocate destination array for each process */
		if ((ps->ps_pipes[src] = calloc(ps->ps_ninstances,
		    sizeof(struct privsep_pipes))) == NULL)
			fatal("proc_init: calloc");

		for (i = 0; i < ps->ps_ninstances; i++) {
			pp = &ps->ps_pipes[src][i];

			for (dst = 0; dst < PROC_MAX; dst++) {
				/* Allocate maximum fd integers */
				if ((pp->pp_pipes[dst] =
				    calloc(ps->ps_ninstances,
				    sizeof(int))) == NULL)
					fatal("proc_init: calloc");

				/* Mark fd as unused */
				for (j = 0; j < ps->ps_ninstances; j++)
					pp->pp_pipes[dst][j] = -1;
			}
		}
	}

	/*
	 * Setup and run the parent and its children
	 */
	privsep_process = PROC_PARENT;
	ps->ps_instances[PROC_PARENT] = 1;
	ps->ps_title[PROC_PARENT] = "parent";
	ps->ps_pid[PROC_PARENT] = getpid();
	ps->ps_pp = &ps->ps_pipes[privsep_process][0];

	for (i = 0; i < nproc; i++) {
		/* Default to 1 process instance */
		if (ps->ps_instances[procs[i].p_id] < 1)
			ps->ps_instances[procs[i].p_id] = 1;
		ps->ps_title[procs[i].p_id] = procs[i].p_title;
	}

	proc_open(ps, NULL, procs, nproc);

	/* Engage! */
	for (i = 0; i < nproc; i++)
		ps->ps_pid[procs[i].p_id] = (*procs[i].p_init)(ps, &procs[i]);
}

void
proc_kill(struct privsep *ps)
{
	pid_t		 pid;
	unsigned int	 i;

	if (privsep_process != PROC_PARENT)
		return;

	for (i = 0; i < PROC_MAX; i++) {
		if (ps->ps_pid[i] == 0)
			continue;
		killpg(ps->ps_pid[i], SIGTERM);
	}

	do {
		pid = waitpid(WAIT_ANY, NULL, 0);
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	proc_close(ps);
}

void
proc_open(struct privsep *ps, struct privsep_proc *p,
    struct privsep_proc *procs, size_t nproc)
{
	struct privsep_pipes	*pa, *pb;
	int			 fds[2];
	unsigned int		 i, j, src, proc;

	if (p == NULL)
		src = privsep_process; /* parent */
	else
		src = p->p_id;

	/*
	 * Open socket pairs for our peers
	 */
	for (proc = 0; proc < nproc; proc++) {
		procs[proc].p_ps = ps;
		procs[proc].p_env = ps->ps_env;
		if (procs[proc].p_cb == NULL)
			procs[proc].p_cb = proc_dispatch_null;

		for (i = 0; i < ps->ps_instances[src]; i++) {
			for (j = 0; j < ps->ps_instances[procs[proc].p_id];
			    j++) {
				pa = &ps->ps_pipes[src][i];
				pb = &ps->ps_pipes[procs[proc].p_id][j];

				/* Check if fds are already set by peer */
				if (pa->pp_pipes[procs[proc].p_id][j] != -1)
					continue;

				if (socketpair(AF_UNIX,
				    SOCK_STREAM | SOCK_NONBLOCK,
				    PF_UNSPEC, fds) == -1)
					fatal("socketpair");

				pa->pp_pipes[procs[proc].p_id][j] = fds[0];
				pb->pp_pipes[src][i] = fds[1];
			}
		}
	}
}

void
proc_listen(struct privsep *ps, struct privsep_proc *procs, size_t nproc)
{
	unsigned int		 i, dst, src, n, m;
	struct privsep_pipes	*pp;

	/*
	 * Close unused pipes
	 */
	for (src = 0; src < PROC_MAX; src++) {
		for (n = 0; n < ps->ps_instances[src]; n++) {
			/* Ingore current process */
			if (src == (unsigned int)privsep_process &&
			    n == ps->ps_instance)
				continue;

			pp = &ps->ps_pipes[src][n];

			for (dst = 0; dst < PROC_MAX; dst++) {
				if (src == dst)
					continue;
				for (m = 0; m < ps->ps_instances[dst]; m++) {
					if (pp->pp_pipes[dst][m] == -1)
						continue;

					/* Close and invalidate fd */
					close(pp->pp_pipes[dst][m]);
					pp->pp_pipes[dst][m] = -1;
				}
			}
		}
	}

	src = privsep_process;
	ps->ps_pp = pp = &ps->ps_pipes[src][ps->ps_instance];

	/*
	 * Listen on appropriate pipes
	 */
	for (i = 0; i < nproc; i++) {
		dst = procs[i].p_id;

		if (src == dst)
			fatal("proc_listen: cannot peer with oneself");

		if ((ps->ps_ievs[dst] = calloc(ps->ps_instances[dst],
		    sizeof(struct imsgev))) == NULL)
			fatal("proc_open");

		for (n = 0; n < ps->ps_instances[dst]; n++) {
			if (pp->pp_pipes[dst][n] == -1)
				continue;

			imsg_init(&(ps->ps_ievs[dst][n].ibuf),
			    pp->pp_pipes[dst][n]);
			ps->ps_ievs[dst][n].handler = proc_dispatch;
			ps->ps_ievs[dst][n].events = EV_READ;
			ps->ps_ievs[dst][n].proc = &procs[i];
			ps->ps_ievs[dst][n].data = &ps->ps_ievs[dst][n];
			procs[i].p_instance = n;

			event_set(&(ps->ps_ievs[dst][n].ev),
			    ps->ps_ievs[dst][n].ibuf.fd,
			    ps->ps_ievs[dst][n].events,
			    ps->ps_ievs[dst][n].handler,
			    ps->ps_ievs[dst][n].data);
			event_add(&(ps->ps_ievs[dst][n].ev), NULL);
		}
	}
}

void
proc_close(struct privsep *ps)
{
	unsigned int		 dst, n;
	struct privsep_pipes	*pp;

	if (ps == NULL)
		return;

	pp = ps->ps_pp;

	for (dst = 0; dst < PROC_MAX; dst++) {
		if (ps->ps_ievs[dst] == NULL)
			continue;

		for (n = 0; n < ps->ps_instances[dst]; n++) {
			if (pp->pp_pipes[dst][n] == -1)
				continue;

			/* Cancel the fd, close and invalidate the fd */
			event_del(&(ps->ps_ievs[dst][n].ev));
			imsg_clear(&(ps->ps_ievs[dst][n].ibuf));
			close(pp->pp_pipes[dst][n]);
			pp->pp_pipes[dst][n] = -1;
		}
		free(ps->ps_ievs[dst]);
	}
}

void
proc_shutdown(struct privsep_proc *p)
{
	struct privsep	*ps = p->p_ps;

	if (p->p_id == PROC_CONTROL && ps)
		control_cleanup(&ps->ps_csock);

	if (p->p_shutdown != NULL)
		(*p->p_shutdown)();

	proc_close(ps);

	log_info("%s exiting, pid %d", p->p_title, getpid());

	_exit(0);
}

void
proc_sig_handler(int sig, short event, void *arg)
{
	struct privsep_proc	*p = arg;

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		proc_shutdown(p);
		break;
	case SIGCHLD:
	case SIGHUP:
	case SIGPIPE:
	case SIGUSR1:
		/* ignore */
		break;
	default:
		fatalx("proc_sig_handler: unexpected signal");
		/* NOTREACHED */
	}
}

pid_t
proc_run(struct privsep *ps, struct privsep_proc *p,
    struct privsep_proc *procs, unsigned int nproc,
    void (*run)(struct privsep *, struct privsep_proc *, void *), void *arg)
{
	pid_t			 pid;
	struct passwd		*pw;
	const char		*root;
	struct control_sock	*rcs;
	unsigned int		 n;

	if (ps->ps_noaction)
		return (0);

	proc_open(ps, p, procs, nproc);

	/* Fork child handlers */
	switch (pid = fork()) {
	case -1:
		fatal("proc_run: cannot fork");
	case 0:
		log_procinit(p->p_title);

		/* Set the process group of the current process */
		setpgid(0, 0);
		break;
	default:
		return (pid);
	}

	pw = ps->ps_pw;

	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
		if (control_init(ps, &ps->ps_csock) == -1)
			fatalx(__func__);
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_init(ps, rcs) == -1)
				fatalx(__func__);
	}

	/* Change root directory */
	if (p->p_chroot != NULL)
		root = p->p_chroot;
	else
		root = pw->pw_dir;

	if (chroot(root) == -1)
		fatal("proc_run: chroot");
	if (chdir("/") == -1)
		fatal("proc_run: chdir(\"/\")");

	privsep_process = p->p_id;

	setproctitle("%s", p->p_title);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("proc_run: cannot drop privileges");

	/* Fork child handlers */
	for (n = 1; n < ps->ps_instances[p->p_id]; n++) {
		if (fork() == 0) {
			ps->ps_instance = p->p_instance = n;
			break;
		}
	}

#ifdef DEBUG
	log_debug("%s: %s %d/%d, pid %d", __func__, p->p_title,
	    ps->ps_instance + 1, ps->ps_instances[p->p_id], getpid());
#endif

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, proc_sig_handler, p);
	signal_set(&ps->ps_evsigterm, SIGTERM, proc_sig_handler, p);
	signal_set(&ps->ps_evsigchld, SIGCHLD, proc_sig_handler, p);
	signal_set(&ps->ps_evsighup, SIGHUP, proc_sig_handler, p);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, proc_sig_handler, p);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, proc_sig_handler, p);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsigchld, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_listen(ps, procs, nproc);

	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
		TAILQ_INIT(&ctl_conns);
		if (control_listen(&ps->ps_csock) == -1)
			fatalx(__func__);
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_listen(rcs) == -1)
				fatalx(__func__);
	}

	if (run != NULL)
		run(ps, p, arg);

	event_dispatch();

	proc_shutdown(p);

	return (0);
}

void
proc_dispatch(int fd, short event, void *arg)
{
	struct imsgev		*iev = arg;
	struct privsep_proc	*p = iev->proc;
	struct privsep		*ps = p->p_ps;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	int			 verbose;
	const char		*title;

	title = ps->ps_title[privsep_process];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal(__func__);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			fatal(__func__);
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal(__func__);
		if (n == 0)
			break;

#if DEBUG > 1
		log_debug("%s: %s %d got imsg %d peerid %d from %s %d",
		    __func__, title, ps->ps_instance + 1,
		    imsg.hdr.type, imsg.hdr.peerid, p->p_title, p->p_instance);
#endif

		/*
		 * Check the message with the program callback
		 */
		if ((p->p_cb)(fd, p, &imsg) == 0) {
			/* Message was handled by the callback, continue */
			imsg_free(&imsg);
			continue;
		}

		/*
		 * Generic message handling
		 */
		switch (imsg.hdr.type) {
		case IMSG_CTL_VERBOSE:
			IMSG_SIZE_CHECK(&imsg, &verbose);
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			log_warnx("%s: %s %d got invalid imsg %d peerid %d "
			    "from %s %d",
			    __func__, title, ps->ps_instance + 1,
			    imsg.hdr.type, imsg.hdr.peerid,
			    p->p_title, p->p_instance);
			fatalx(__func__);
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

int
proc_dispatch_null(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	return (-1);
}

/*
 * imsg helper functions
 */

void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, void *data, uint16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) == -1)
		return (ret);
	imsg_event_add(iev);
	return (ret);
}

int
imsg_composev_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, const struct iovec *iov, int iovcnt)
{
	int	ret;

	if ((ret = imsg_composev(&iev->ibuf, type, peerid,
	    pid, fd, iov, iovcnt)) == -1)
		return (ret);
	imsg_event_add(iev);
	return (ret);
}

void
proc_range(struct privsep *ps, enum privsep_procid id, int *n, int *m)
{
	if (*n == -1) {
		/* Use a range of all target instances */
		*n = 0;
		*m = ps->ps_instances[id];
	} else {
		/* Use only a single slot of the specified peer process */
		*m = *n + 1;
	}
}

int
proc_compose_imsg(struct privsep *ps, enum privsep_procid id, int n,
    uint16_t type, uint32_t peerid, int fd, void *data, uint16_t datalen)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++) {
		if (imsg_compose_event(&ps->ps_ievs[id][n],
		    type, peerid, 0, fd, data, datalen) == -1)
			return (-1);
	}

	return (0);
}

int
proc_compose(struct privsep *ps, enum privsep_procid id,
    uint16_t type, void *data, uint16_t datalen)
{
	return (proc_compose_imsg(ps, id, -1, type, -1, -1, data, datalen));
}

int
proc_composev_imsg(struct privsep *ps, enum privsep_procid id, int n,
    uint16_t type, uint32_t peerid, int fd, const struct iovec *iov, int iovcnt)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++)
		if (imsg_composev_event(&ps->ps_ievs[id][n],
		    type, peerid, 0, fd, iov, iovcnt) == -1)
			return (-1);

	return (0);
}

int
proc_composev(struct privsep *ps, enum privsep_procid id,
    uint16_t type, const struct iovec *iov, int iovcnt)
{
	return (proc_composev_imsg(ps, id, -1, type, -1, -1, iov, iovcnt));
}

int
proc_forward_imsg(struct privsep *ps, struct imsg *imsg,
    enum privsep_procid id, int n)
{
	return (proc_compose_imsg(ps, id, n, imsg->hdr.type,
	    imsg->hdr.peerid, imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg)));
}

struct imsgbuf *
proc_ibuf(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	return (&ps->ps_ievs[id][n].ibuf);
}

struct imsgev *
proc_iev(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	return (&ps->ps_ievs[id][n]);
}
@


1.29
log
@Add imsg "peerid" to debug messages (only within -DDEBUG).
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2015/12/05 17:30:34 claudio Exp $	*/
d498 1
a498 1
			log_verbose(verbose);
@


1.28
log
@Sync proc.c, use shorter proc_compose[v]()
@
text
@d477 1
a477 1
		log_debug("%s: %s %d got imsg %d from %s %d",
d479 1
a479 1
		    imsg.hdr.type, p->p_title, p->p_instance);
d501 2
a502 1
			log_warnx("%s: %s %d got invalid imsg %d from %s %d",
d504 2
a505 1
			    imsg.hdr.type, p->p_title, p->p_instance);
@


1.27
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.26 2015/11/23 19:28:34 reyk Exp $	*/
d20 1
a23 6
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
d33 1
d579 1
a579 1
    uint16_t type, int fd, void *data, uint16_t datalen)
d586 1
a586 1
		    type, -1, 0, fd, data, datalen) == -1)
d594 7
d602 1
a602 1
    uint16_t type, int fd, const struct iovec *iov, int iovcnt)
d609 1
a609 1
		    type, -1, 0, fd, iov, iovcnt) == -1)
d616 7
d627 1
a627 1
	    imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg)));
@


1.26
log
@Replace socket_set_blockmode() and fcntl(fd, F_SETFL, O_NONBLOCK) calls
with the SOCK_NONBLOCK flag to socket() and accept4().

OK claudio@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.25 2015/11/22 13:27:13 reyk Exp $	*/
d459 1
a459 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.25
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.24 2015/10/22 15:55:18 reyk Exp $	*/
d181 2
a182 1
				if (socketpair(AF_UNIX, SOCK_STREAM,
a184 3

				socket_set_blockmode(fds[0], BM_NONBLOCK);
				socket_set_blockmode(fds[1], BM_NONBLOCK);
@


1.24
log
@iked hereby pledges that it will run with restricted system
operations.  This adds pledge(2) too all processes, including the iked
parent process; the existing privsep design has been improved for
better pledgeability.  There haven't been any serious problems as it
was already sane (eg. by receiving the PFKEYv2 and UDP sockets via fd
passing).  The control socket moved to an independent process to
remove some abilities from the cert process.

Committed in agreement with many but nobody was brave enough to OK it.

Better testing will happen with having it in the tree.
"It's the truth" deraadt@@
"Let's see what happens" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.23 2015/08/21 11:59:28 reyk Exp $	*/
d356 2
d369 1
a369 1
			fatalx(p->p_title);
d372 1
a372 1
				fatalx(p->p_title);
d429 1
a429 1
			fatalx(p->p_title);
d432 1
a432 1
				fatalx(p->p_title);
d462 1
a462 1
			fatal(title);
d473 1
a473 1
			fatal(title);
d478 1
a478 1
			fatal(title);
d510 1
a510 1
			fatalx(title);
@


1.23
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.22 2015/01/16 06:39:58 deraadt Exp $	*/
d48 1
d168 2
d338 1
a338 1
    void (*init)(struct privsep *, struct privsep_proc *, void *), void *arg)
d433 2
a434 2
	if (init != NULL)
		init(ps, p, arg);
d513 6
@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.21 2014/12/16 03:35:49 millert Exp $	*/
d44 1
a44 1
int	 proc_ispeer(struct privsep_proc *, u_int, enum privsep_procid);
d50 2
a51 1
proc_ispeer(struct privsep_proc *procs, u_int nproc, enum privsep_procid type)
d53 1
a53 1
	u_int	i;
d62 1
a62 1
proc_init(struct privsep *ps, struct privsep_proc *procs, u_int nproc)
d64 1
a64 1
	u_int			 i, j, src, dst;
d130 1
a130 1
	u_int		 i;
d154 1
a154 1
	u_int			 i, j, src, proc;
d195 1
a195 1
	u_int			 i, dst, src, n, m;
d204 1
a204 1
			if (src == (u_int)privsep_process &&
d266 1
a266 1
	u_int			 dst, n;
d334 1
a334 1
    struct privsep_proc *procs, u_int nproc,
d341 1
a341 1
	u_int			 n;
d534 2
a535 2
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
d547 1
a547 1
imsg_composev_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
d574 1
a574 1
    u_int16_t type, int fd, void *data, u_int16_t datalen)
d590 1
a590 1
    u_int16_t type, int fd, const struct iovec *iov, int iovcnt)
@


1.21
log
@Replace setpgrp(0, getpid()) with setpgid(0, 0).  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.20 2014/10/25 03:18:13 lteo Exp $	*/
a19 1
#include <sys/param.h>
@


1.20
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.19 2014/08/18 09:43:02 reyk Exp $	*/
d354 1
a354 1
		setpgrp(0, getpid());
@


1.19
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but iked will ignore it
now instead of terminating the process.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2014/08/04 15:49:28 reyk Exp $	*/
a26 1
#include <netinet/in_systm.h>
@


1.18
log
@Sync msgbuf_write() changes from relayd.

Please note that proc.c should be kept identical in relayd, iked and
snmpd (currently without the includes).

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.17 2014/05/08 13:11:16 blambert Exp $	*/
a40 2
#include <openssl/ssl.h>

d164 1
a164 1
	 */	
d324 1
d411 1
d418 1
@


1.17
log
@match iked proc.c infrastructure with proc.c

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.16 2014/05/06 06:40:03 jsg Exp $	*/
d467 1
a467 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
@


1.16
log
@no need to include rand.h now the RAND_seed() calls are gone.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.15 2014/05/04 10:35:24 reyk Exp $	*/
d339 5
a343 4
	pid_t		 pid;
	struct passwd	*pw;
	const char	*root;
	u_int		 n;
d367 3
d425 3
@


1.15
log
@With the recent change by deraadt@@ to introduce kern.nosuidcoredump=3,
we don't need the horrible debug hack anymore that disabled privdrop
and chroot to get core dumps of privsep processes.  No functional
change for the normal binary, only if it is compiled with the
non-default -DDEBUG option.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.14 2014/04/22 12:00:03 reyk Exp $	*/
a40 1
#include <openssl/rand.h>
@


1.14
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.11 2014/04/20 14:48:29 reyk Exp $	*/
a374 1
#ifndef DEBUG
a378 9
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
	if (p->p_chroot != NULL) {
		if (chroot(root) == -1)
			fatal("proc_run: chroot");
		if (chdir("/") == -1)
			fatal("proc_run: chdir(\"/\")");
	}
#endif
a383 1
#ifndef DEBUG
a387 1
#endif
@


1.13
log
@round up some enemy sympathizers found calling RAND_seed().
ok beck reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.12 2014/04/14 07:18:05 blambert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
d22 2
d25 6
a30 2
#include <sys/wait.h>
#include <sys/socket.h>
d42 1
d46 4
a49 1
void	 proc_setup(struct privsep *);
d52 12
d66 1
a66 1
proc_init(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d68 2
a69 1
	u_int	 i;
d72 37
a108 1
	 * Called from parent
d111 1
d114 1
d116 8
a123 1
	proc_setup(ps);
d126 2
a127 4
	for (i = 0; i < nproc; i++, p++) {
		ps->ps_title[p->p_id] = p->p_title;
		ps->ps_pid[p->p_id] = (*p->p_init)(ps, p);
	}
d142 1
a142 1
		kill(ps->ps_pid[i], SIGTERM);
d148 2
d153 2
a154 1
proc_setup(struct privsep *ps)
d156 29
a184 1
	int	 i, j, sockpair[2];
d186 6
a191 11
	for (i = 0; i < PROC_MAX; i++)
		for (j = 0; j < PROC_MAX; j++) {
			if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
			    sockpair) == -1)
				fatal("sockpair");
			ps->ps_pipes[i][j] = sockpair[0];
			ps->ps_pipes[j][i] = sockpair[1];
			socket_set_blockmode(ps->ps_pipes[i][j],
			    BM_NONBLOCK);
			socket_set_blockmode(ps->ps_pipes[j][i],
			    BM_NONBLOCK);
d193 1
d197 1
a197 1
proc_config(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d199 2
a200 3
	u_int	 src, dst, i, j, k, found;

	src = privsep_process;
d203 1
a203 1
	 * close unused pipes
d205 19
a223 15
	for (i = 0; i < PROC_MAX; i++) {
		if (i != privsep_process) {
			for (j = 0; j < PROC_MAX; j++) {
				close(ps->ps_pipes[i][j]);
				ps->ps_pipes[i][j] = -1;
			}
		} else {
			for (j = found = 0; j < PROC_MAX; j++, found = 0) {
				for (k = 0; k < nproc; k++) {
					if (p[k].p_id == j)
						found++;
				}
				if (!found) {
					close(ps->ps_pipes[i][j]);
					ps->ps_pipes[i][j] = -1;
d229 3
d233 1
a233 1
	 * listen on appropriate pipes
d235 58
a292 17
	for (i = 0; i < nproc; i++, p++) {
		dst = p->p_id;
		p->p_ps = ps;
		p->p_env = ps->ps_env;

		imsg_init(&ps->ps_ievs[dst].ibuf,
		    ps->ps_pipes[src][dst]);
		ps->ps_ievs[dst].handler = proc_dispatch;
		ps->ps_ievs[dst].events = EV_READ;
		ps->ps_ievs[dst].data = p;
		ps->ps_ievs[dst].name = p->p_title;
		event_set(&ps->ps_ievs[dst].ev,
		    ps->ps_ievs[dst].ibuf.fd,
		    ps->ps_ievs[dst].events,
		    ps->ps_ievs[dst].handler,
		    ps->ps_ievs[dst].data);
		event_add(&ps->ps_ievs[dst].ev, NULL);
d304 7
a310 1
	log_info("%s exiting", p->p_title);
d338 1
a338 1
    void (*init)(struct privsep *, void *), void *arg)
d343 6
d350 1
d355 2
d364 1
a364 1
	if (p->p_id == PROC_CONTROL) {
d401 13
d428 1
a428 1
	proc_config(ps, procs, nproc);
d430 1
a430 1
	if (p->p_id == PROC_CONTROL) {
d437 1
a437 1
		init(ps, arg);
d449 2
a450 1
	struct privsep_proc	*p = (struct privsep_proc *)arg;
a451 1
	struct imsgev		*iev;
a458 1
	iev = &ps->ps_ievs[p->p_id];
d473 1
a473 1
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
d483 6
a503 1

d508 3
a510 2
			log_warnx("%s: %s got imsg %d", __func__, p->p_title,
			    imsg.hdr.type);
d518 4
d565 13
d579 1
a579 1
proc_compose_imsg(struct iked *env, enum privsep_procid id,
d582 10
a591 2
	return (imsg_compose_event(&env->sc_ps.ps_ievs[id],
	    type, -1, 0, fd, data, datalen));
d595 1
a595 1
proc_composev_imsg(struct iked *env, enum privsep_procid id,
d598 9
a606 2
	return (imsg_composev_event(&env->sc_ps.ps_ievs[id],
	    type, -1, 0, fd, iov, iovcnt));
d610 2
a611 2
proc_forward_imsg(struct iked *env, struct imsg *imsg,
    enum privsep_procid id)
d613 1
a613 1
	return (proc_compose_imsg(env, id, imsg->hdr.type,
d615 18
@


1.12
log
@Fix the following idiom in the following way:

        arc4random_buf(seed, sizeof(seed));
        RAND_seed(seed, sizeof(seed));
+       explicit_bzero(seed, sizeof(seed));

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.11 2014/02/14 10:23:43 benno Exp $	*/
a196 1
	u_int32_t	 seed[256];
a260 4

	arc4random_buf(seed, sizeof(seed));
	RAND_seed(seed, sizeof(seed));
	explicit_bzero(seed, sizeof(seed));
@


1.11
log
@remove unused function that distracts from cleaning up the imsg_flush() mess
ok krw, florian, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.10 2013/11/15 12:30:19 mikeb Exp $	*/
d265 1
@


1.10
log
@Cope with the EAGAIN API change for msgbuf_write()
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.9 2013/03/21 04:30:14 deraadt Exp $	*/
a413 6
}

void
proc_flush_imsg(struct iked *env, enum privsep_procid id)
{
	imsg_flush(&env->sc_ps.ps_ievs[id].ibuf);
@


1.9
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.8 2013/01/08 10:38:19 reyk Exp $	*/
d310 1
a310 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.8
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.7 2011/05/09 11:27:08 reyk Exp $	*/
d20 1
a20 1
#include <sys/types.h>
a22 1
#include <sys/param.h>
@


1.7
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.6 2011/05/09 11:15:18 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010,2011 Reyk Floeter <reyk@@openbsd.org>
@


1.6
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 2
/*	$OpenBSD: proc.c,v 1.5 2011/05/05 12:59:31 reyk Exp $	*/
/*	$vantronix: proc.c,v 1.11 2010/06/01 16:45:56 jsg Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.5
log
@Small tweak - add direct pointer to env instead of using an indirect one.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2011/05/05 12:55:52 reyk Exp $	*/
d25 1
d41 1
d46 1
a46 1
init_procs(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d50 3
d54 4
a57 1
	init_pipes(ps);
d59 1
d67 1
a67 1
kill_procs(struct privsep *ps)
d69 2
a70 1
	u_int	 i;
d80 4
d87 1
a87 1
init_pipes(struct privsep *ps)
d89 1
a89 1
	int	 i, j, fds[2];
d94 4
a97 4
			    fds) == -1)
				fatal("socketpair");
			ps->ps_pipes[i][j] = fds[0];
			ps->ps_pipes[j][i] = fds[1];
d106 1
a106 1
config_pipes(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d108 1
a108 1
	u_int	 i, j, k, found;
d110 5
a133 6
}

void
config_procs(struct privsep *ps, struct privsep_proc *p, u_int nproc)
{
	u_int	src, dst, i;
a138 1
		src = privsep_process;
d145 1
a145 1
		ps->ps_ievs[dst].handler = dispatch_proc;
d173 2
d178 1
a178 1
		proc_shutdown((struct privsep_proc *)arg);
d192 1
a192 1
run_proc(struct privsep *ps, struct privsep_proc *p,
d203 1
a203 1
		fatal("run_proc: cannot fork");
d225 1
a225 1
		fatal("run_proc: chroot");
d227 1
a227 1
		fatal("run_proc: chdir(\"/\")");
d232 1
a232 1
			fatal("run_proc: chroot");
d234 1
a234 1
			fatal("run_proc: chdir(\"/\")");
d239 1
d246 1
a246 1
		fatal("run_proc: cannot drop privileges");
d263 1
a263 2
	config_pipes(ps, procs, nproc);
	config_procs(ps, procs, nproc);
d285 1
a285 1
dispatch_proc(int fd, short event, void *arg)
d294 1
d296 1
d302 1
a302 1
			fatal(p->p_title);
d313 1
a313 1
			fatal(p->p_title);
d318 1
a318 1
			fatal(p->p_title);
d344 1
a344 1
			fatalx(p->p_title);
d349 73
@


1.4
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.3 2011/05/05 12:17:10 reyk Exp $	*/
d129 1
@


1.3
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.2 2010/09/16 09:27:35 mikeb Exp $	*/
d44 1
a44 1
init_procs(struct iked *env, struct privsep_proc *p, u_int nproc)
d49 1
a49 1
	init_pipes(env);
d52 2
a53 2
		env->sc_title[p->id] = p->title;
		env->sc_pid[p->id] = (*p->init)(env, p);
d58 1
a58 1
kill_procs(struct iked *env)
d66 1
a66 1
		if (env->sc_pid[i] == 0)
d68 1
a68 1
		kill(env->sc_pid[i], SIGTERM);
d73 1
a73 1
init_pipes(struct iked *env)
d82 3
a84 3
			env->sc_pipes[i][j] = fds[0];
			env->sc_pipes[j][i] = fds[1];
			socket_set_blockmode(env->sc_pipes[i][j],
d86 1
a86 1
			socket_set_blockmode(env->sc_pipes[j][i],
d92 1
a92 1
config_pipes(struct iked *env, struct privsep_proc *p, u_int nproc)
d99 2
a100 2
				close(env->sc_pipes[i][j]);
				env->sc_pipes[i][j] = -1;
d105 1
a105 1
					if (p[k].id == j)
d109 2
a110 2
					close(env->sc_pipes[i][j]);
					env->sc_pipes[i][j] = -1;
d118 1
a118 1
config_procs(struct iked *env, struct privsep_proc *p, u_int nproc)
d127 2
a128 2
		dst = p->id;
		p->env = env;
d130 12
a141 12
		imsg_init(&env->sc_ievs[dst].ibuf,
		    env->sc_pipes[src][dst]);
		env->sc_ievs[dst].handler = dispatch_proc;
		env->sc_ievs[dst].events = EV_READ;
		env->sc_ievs[dst].data = p;
		env->sc_ievs[dst].name = p->title;
		event_set(&env->sc_ievs[dst].ev,
		    env->sc_ievs[dst].ibuf.fd,
		    env->sc_ievs[dst].events,
		    env->sc_ievs[dst].handler,
		    env->sc_ievs[dst].data);
		event_add(&env->sc_ievs[dst].ev, NULL);
d148 1
a148 1
	struct iked	*env = p->env;
d150 2
a151 2
	if (p->id == PROC_CONTROL && env)
		control_cleanup(&env->sc_csock);
d153 1
a153 1
	log_info("%s exiting", p->title);
d177 1
a177 1
run_proc(struct iked *env, struct privsep_proc *p,
d179 1
a179 1
    void (*init)(struct iked *, void *), void *arg)
d195 1
a195 1
	pw = env->sc_pw;
d197 3
a199 3
	if (p->id == PROC_CONTROL) {
		if (control_init(env, &env->sc_csock) == -1)
			fatalx(p->title);
d203 2
a204 2
	if (p->chroot != NULL)
		root = p->chroot;
d215 1
a215 1
	if (p->chroot != NULL) {
d223 2
a224 2
	privsep_process = p->id;
	setproctitle("%s", p->title);
d235 11
a245 11
	signal_set(&env->sc_evsigint, SIGINT, proc_sig_handler, p);
	signal_set(&env->sc_evsigterm, SIGTERM, proc_sig_handler, p);
	signal_set(&env->sc_evsigchld, SIGCHLD, proc_sig_handler, p);
	signal_set(&env->sc_evsighup, SIGHUP, proc_sig_handler, p);
	signal_set(&env->sc_evsigpipe, SIGPIPE, proc_sig_handler, p);

	signal_add(&env->sc_evsigint, NULL);
	signal_add(&env->sc_evsigterm, NULL);
	signal_add(&env->sc_evsigchld, NULL);
	signal_add(&env->sc_evsighup, NULL);
	signal_add(&env->sc_evsigpipe, NULL);
d247 2
a248 2
	config_pipes(env, procs, nproc);
	config_procs(env, procs, nproc);
d253 1
a253 1
	if (p->id == PROC_CONTROL) {
d255 2
a256 2
		if (control_listen(&env->sc_csock) == -1)
			fatalx(p->title);
d260 1
a260 1
		init(env, arg);
d273 1
a273 1
	struct iked		*env = p->env;
d280 1
a280 1
	iev = &env->sc_ievs[p->id];
d285 1
a285 1
			fatal(p->title);
d296 1
a296 1
			fatal(p->title);
d301 1
a301 1
			fatal(p->title);
d308 1
a308 1
		if ((p->cb)(fd, p, &imsg) == 0) {
d325 1
a325 1
			log_warnx("%s: %s got imsg %d", __func__, p->title,
d327 1
a327 1
			fatalx(p->title);
@


1.2
log
@pass proper argument to the proc_sig_handler and check env for
NULL before dereferencing.  fixes an annoying crash.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d40 1
a40 1
void	 proc_shutdown(struct iked_proc *);
d44 1
a44 1
init_procs(struct iked *env, struct iked_proc *p, u_int nproc)
d48 1
a48 1
	iked_process = PROC_PARENT;
d62 1
a62 1
	if (iked_process != PROC_PARENT)
d92 1
a92 1
config_pipes(struct iked *env, struct iked_proc *p, u_int nproc)
d97 1
a97 1
		if (i != iked_process) {
d118 1
a118 1
config_procs(struct iked *env, struct iked_proc *p, u_int nproc)
d126 1
a126 1
		src = iked_process;
d146 1
a146 1
proc_shutdown(struct iked_proc *p)
d163 1
a163 1
		proc_shutdown((struct iked_proc *)arg);
d177 2
a178 2
run_proc(struct iked *env, struct iked_proc *p,
    struct iked_proc *procs, u_int nproc,
d223 1
a223 1
	iked_process = p->id;
d272 1
a272 1
	struct iked_proc	*p = (struct iked_proc *)arg;
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d150 1
a150 1
	if (p->id == PROC_CONTROL)
d235 5
a239 5
	signal_set(&env->sc_evsigint, SIGINT, proc_sig_handler, env);
	signal_set(&env->sc_evsigterm, SIGTERM, proc_sig_handler, env);
	signal_set(&env->sc_evsigchld, SIGCHLD, proc_sig_handler, env);
	signal_set(&env->sc_evsighup, SIGHUP, proc_sig_handler, env);
	signal_set(&env->sc_evsigpipe, SIGPIPE, proc_sig_handler, env);
@

