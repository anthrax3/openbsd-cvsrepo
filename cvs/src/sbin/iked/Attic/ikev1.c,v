head	1.19;
access;
symbols
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.19
date	2015.10.19.11.25.35;	author reyk;	state dead;
branches;
next	1.18;
commitid	HzcDW70HFbhaqvT8;

1.18
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.17;
commitid	CNs9dXqQUQ09vB19;

1.17
date	2015.02.06.10.39.01;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	fN2B4abgRqE4hFJn;

1.16
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2014.02.17.11.00.14;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.05.12.59.31;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.24.20.15.30;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.08.55.59;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.08.29.47;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@/*	$OpenBSD: ikev1.c,v 1.18 2015/08/21 11:59:27 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * XXX Either implement IKEv1,
 * XXX or find a way to pass IKEv1 messages to isakmpd,
 * XXX or remove this file and ikev1 from the iked tree.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include "iked.h"
#include "ikev2.h"

int	 ikev1_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 ikev1_dispatch_ikev2(int, struct privsep_proc *, struct imsg *);
int	 ikev1_dispatch_cert(int, struct privsep_proc *, struct imsg *);

void	 ikev1_msg_cb(int, short, void *);
void	 ikev1_recv(struct iked *, struct iked_message *);

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	ikev1_dispatch_parent },
	{ "ikev2",	PROC_IKEV2,	ikev1_dispatch_ikev2 },
	{ "certstore",	PROC_CERT,	ikev1_dispatch_cert }
};

pid_t
ikev1(struct privsep *ps, struct privsep_proc *p)
{
	return (proc_run(ps, p, procs, nitems(procs), NULL, NULL));
}

int
ikev1_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked		*env = p->p_env;

	switch (imsg->hdr.type) {
	case IMSG_CTL_RESET:
		log_debug("%s: config reload", __func__);
		return (0);
	case IMSG_CTL_COUPLE:
	case IMSG_CTL_DECOUPLE:
		return (0);
	case IMSG_CTL_ACTIVE:
	case IMSG_CTL_PASSIVE:
		return (0);
	case IMSG_UDP_SOCKET:
		return (config_getsocket(env, imsg, ikev1_msg_cb));
	case IMSG_COMPILE:
		return (0);
	default:
		break;
	}

	return (-1);
}

int
ikev1_dispatch_ikev2(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked		*env = p->p_env;
	struct iked_message	 msg;
	uint8_t			*buf;
	ssize_t			 len;

	switch (imsg->hdr.type) {
	case IMSG_IKE_MESSAGE:
		log_debug("%s: message", __func__);
		IMSG_SIZE_CHECK(imsg, &msg);
		memcpy(&msg, imsg->data, sizeof(msg));

		len = IMSG_DATA_SIZE(imsg) - sizeof(msg);
		buf = (uint8_t *)imsg->data + sizeof(msg);
		if (len <= 0 || (msg.msg_data = ibuf_new(buf, len)) == NULL) {
			log_debug("%s: short message", __func__);
			return (0);
		}

		log_debug("%s: message length %zd", __func__, len);

		ikev1_recv(env, &msg);
		ikev2_msg_cleanup(env, &msg);
		return (0);
	default:
		break;
	}

	return (-1);
}

int
ikev1_dispatch_cert(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	return (-1);
}

void
ikev1_msg_cb(int fd, short event, void *arg)
{
	struct iked_socket	*sock = arg;
	struct iked		*env = sock->sock_env;
	struct iked_message	 msg;
	struct ike_header	 hdr;
	uint8_t			 buf[IKED_MSGBUF_MAX];
	size_t			 len;
	struct iovec		 iov[2];

	msg.msg_peerlen = sizeof(msg.msg_peer);
	msg.msg_locallen = sizeof(msg.msg_local);

	if ((len = recvfromto(fd, buf, sizeof(buf), 0,
	    (struct sockaddr*)&msg.msg_peer, &msg.msg_peerlen,
	    (struct sockaddr*)&msg.msg_local, &msg.msg_locallen)) < 1)
		return;

	if ((size_t)len <= sizeof(hdr))
		return;
	memcpy(&hdr, buf, sizeof(hdr));

	if ((msg.msg_data = ibuf_new(buf, len)) == NULL)
		return;

	if (hdr.ike_version == IKEV2_VERSION) {
		iov[0].iov_base = &msg;
		iov[0].iov_len = sizeof(msg);
		iov[1].iov_base = buf;
		iov[1].iov_len = len;

		proc_composev_imsg(&env->sc_ps, PROC_IKEV2, -1,
		    IMSG_IKE_MESSAGE, -1, iov, 2);
		goto done;
	}

	ikev1_recv(env, &msg);

 done:
	ikev2_msg_cleanup(env, &msg);
}

void
ikev1_recv(struct iked *env, struct iked_message *msg)
{
	struct ike_header	*hdr;

	if (ibuf_size(msg->msg_data) <= sizeof(*hdr)) {
		log_debug("%s: short message", __func__);
		return;
	}

	hdr = (struct ike_header *)ibuf_data(msg->msg_data);

	log_debug("%s: header ispi %s rspi %s"
	    " nextpayload %u version 0x%02x exchange %u flags 0x%02x"
	    " msgid %u length %u", __func__,
	    print_spi(betoh64(hdr->ike_ispi), 8),
	    print_spi(betoh64(hdr->ike_rspi), 8),
	    hdr->ike_nextpayload,
	    hdr->ike_version,
	    hdr->ike_exchange,
	    hdr->ike_flags,
	    betoh32(hdr->ike_msgid),
	    betoh32(hdr->ike_length));

	log_debug("%s: IKEv1 not supported", __func__);
}
@


1.18
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.17 2015/02/06 10:39:01 deraadt Exp $	*/
@


1.17
log
@unneeded getopt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.16 2015/01/16 06:39:58 deraadt Exp $	*/
d93 1
a93 1
	u_int8_t		*buf;
d103 1
a103 1
		buf = (u_int8_t *)imsg->data + sizeof(msg);
d134 1
a134 1
	u_int8_t		 buf[IKED_MSGBUF_MAX];
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.15 2014/04/22 12:00:03 reyk Exp $	*/
a33 1
#include <getopt.h>
@


1.15
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.14 2014/02/17 11:00:14 reyk Exp $	*/
a24 1
#include <sys/param.h>
@


1.14
log
@Fix compiler warnings in the format strings: use %zd for ssize_t and
%zu for size_t.

From Andre de Oliveira
With input and OK from blambert@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.13 2013/03/21 04:30:14 deraadt Exp $	*/
d161 2
a162 2
		proc_composev_imsg(env, PROC_IKEV2, IMSG_IKE_MESSAGE, -1,
		    iov, 2);
@


1.13
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.12 2013/01/08 10:38:19 reyk Exp $	*/
d111 1
a111 1
		log_debug("%s: message length %d", __func__, len);
@


1.12
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.11 2012/09/18 12:07:59 reyk Exp $	*/
a25 1
#include <sys/types.h>
@


1.11
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 2
/*	$OpenBSD: ikev1.c,v 1.10 2011/05/09 11:15:18 reyk Exp $	*/
/*	$vantronix: ikev1.c,v 1.13 2010/05/28 15:34:35 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.10
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.9 2011/05/05 12:59:31 reyk Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.9
log
@Small tweak - add direct pointer to env instead of using an indirect one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.8 2011/05/05 12:55:52 reyk Exp $	*/
d63 1
a63 1
	return (run_proc(ps, p, procs, nitems(procs), NULL, NULL));
d163 1
a163 1
		imsg_composev_proc(env, PROC_IKEV2, IMSG_IKE_MESSAGE, -1,
@


1.8
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.7 2011/05/05 12:17:10 reyk Exp $	*/
d69 1
a69 1
	struct iked		*env = p->p_ps->ps_env;
d95 1
a95 1
	struct iked		*env = p->p_ps->ps_env;
@


1.7
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.6 2011/01/21 11:56:00 reyk Exp $	*/
d61 1
a61 1
ikev1(struct iked *env, struct privsep_proc *p)
d63 1
a63 1
	return (run_proc(env, p, procs, nitems(procs), NULL, NULL));
d69 1
a69 1
	struct iked		*env = p->env;
d95 1
a95 1
	struct iked		*env = p->env;
@


1.6
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.5 2010/06/24 20:15:30 reyk Exp $	*/
d47 3
a49 3
int	 ikev1_dispatch_parent(int, struct iked_proc *, struct imsg *);
int	 ikev1_dispatch_ikev2(int, struct iked_proc *, struct imsg *);
int	 ikev1_dispatch_cert(int, struct iked_proc *, struct imsg *);
d54 1
a54 1
static struct iked_proc procs[] = {
d61 1
a61 1
ikev1(struct iked *env, struct iked_proc *p)
d67 1
a67 1
ikev1_dispatch_parent(int fd, struct iked_proc *p, struct imsg *imsg)
d93 1
a93 1
ikev1_dispatch_ikev2(int fd, struct iked_proc *p, struct imsg *imsg)
d126 1
a126 1
ikev1_dispatch_cert(int fd, struct iked_proc *p, struct imsg *imsg)
@


1.5
log
@unbreak the ikectl log verbose/brief commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.4 2010/06/14 08:55:59 reyk Exp $	*/
d83 2
@


1.4
log
@cleanup messages and parsed information correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.3 2010/06/10 14:08:37 reyk Exp $	*/
d49 1
d56 2
a57 1
	{ "ikev2",	PROC_IKEV2,	ikev1_dispatch_ikev2 }
d120 6
@


1.3
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.2 2010/06/10 08:29:47 reyk Exp $	*/
d112 1
a112 1
		message_cleanup(env, &msg);
d161 1
a161 1
	message_cleanup(env, &msg);
@


1.2
log
@i don't like splitting source code in too many source files but ikev2.c
has grown too large, so split it in 3 files and rename a few functions
to organize the code a bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev1.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d72 6
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 2
a51 2
void	 ikev1_message_cb(int, short, void *);
void	 ikev1_message_recv(struct iked *, struct iked_message *);
d74 1
a74 1
		return (config_getsocket(env, imsg, ikev1_message_cb));
d105 1
a105 1
		ikev1_message_recv(env, &msg);
d116 1
a116 1
ikev1_message_cb(int fd, short event, void *arg)
d152 1
a152 1
	ikev1_message_recv(env, &msg);
d159 1
a159 1
ikev1_message_recv(struct iked *env, struct iked_message *msg)
@

