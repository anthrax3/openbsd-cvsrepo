head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2016.09.13.10.49.52;	author mikeb;	state Exp;
branches;
next	1.12;
commitid	LaSyibYeKfIItxxT;

1.12
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Uu5nFG3wCl0LACBb;

1.11
date	2014.01.24.05.58.52;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.22.16.06.31;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.30.16.17.20;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.29.15.09.12;	author mikeb;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.26.17.07.59;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.11.12.47.18;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Disable the timer event before attempting to change it

Report and fix by Nikolay Edigaryev <edigaryev at gmail ! com>,
thanks!  OK reyk@@
@
text
@/*	$OpenBSD: timer.c,v 1.12 2015/01/16 06:39:58 deraadt Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <ctype.h>
#include <event.h>

#include "iked.h"

void	 timer_callback(int, short, void *);

void
timer_set(struct iked *env, struct iked_timer *tmr,
    void (*cb)(struct iked *, void *), void *arg)
{
	if (evtimer_initialized(&tmr->tmr_ev) &&
	    evtimer_pending(&tmr->tmr_ev, NULL))
		evtimer_del(&tmr->tmr_ev);

	tmr->tmr_env = env;
	tmr->tmr_cb = cb;
	tmr->tmr_cbarg = arg;
	evtimer_set(&tmr->tmr_ev, timer_callback, tmr);
}

void
timer_add(struct iked *env, struct iked_timer *tmr, int timeout)
{
	struct timeval		 tv = { timeout };

	evtimer_add(&tmr->tmr_ev, &tv);
}

void
timer_del(struct iked *env, struct iked_timer *tmr)
{
	if (tmr->tmr_env == env && tmr->tmr_cb &&
	    evtimer_initialized(&tmr->tmr_ev))
		evtimer_del(&tmr->tmr_ev);
}

void
timer_callback(int fd, short event, void *arg)
{
	struct iked_timer	*tmr = arg;

	if (tmr->tmr_cb)
		tmr->tmr_cb(tmr->tmr_env, tmr->tmr_cbarg);
}
@


1.12
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.11 2014/01/24 05:58:52 mikeb Exp $	*/
d40 4
a53 4

	if (evtimer_initialized(&tmr->tmr_ev) &&
	    evtimer_pending(&tmr->tmr_ev, NULL))
		evtimer_del(&tmr->tmr_ev);
@


1.11
log
@use a bit saner timer api
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.10 2013/01/08 10:38:19 reyk Exp $	*/
a18 1
#include <sys/param.h>
@


1.10
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.9 2012/09/18 12:07:59 reyk Exp $	*/
d38 1
a38 1
timer_initialize(struct iked *env, struct iked_timer *tmr,
a46 9
int
timer_initialized(struct iked *env, struct iked_timer *tmr)
{
	if (tmr && tmr->tmr_env == env && tmr->tmr_cb &&
	    evtimer_initialized(&tmr->tmr_ev))
		return (1);
	return (0);
}

d48 1
a48 1
timer_register(struct iked *env, struct iked_timer *tmr, int timeout)
d60 1
a60 1
timer_deregister(struct iked *env, struct iked_timer *tmr)
d62 3
a64 1
	evtimer_del(&tmr->tmr_ev);
@


1.9
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.8 2012/06/22 16:06:31 mikeb Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.8
log
@decouple timer initialization from timer_register
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.7 2012/05/30 16:17:20 mikeb Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.7
log
@more timer changes
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.6 2012/05/29 15:09:12 mikeb Exp $	*/
d38 20
a57 2
timer_register(struct iked *env, struct iked_timer *tmr,
    void (*cb)(struct iked *, void *), void *arg, int timeout)
a64 4
	tmr->tmr_env = env;
	tmr->tmr_cb = cb;
	tmr->tmr_cbarg = arg;
	evtimer_set(&tmr->tmr_ev, timer_callback, tmr);
@


1.6
log
@improve timer framework; will be needed soon
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.5 2011/05/27 12:01:02 reyk Exp $	*/
d38 1
a38 1
timer_register(struct iked_timer *tmr, struct iked *env,
d43 4
d52 6
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.4 2011/01/26 17:07:59 reyk Exp $	*/
d35 1
a35 14
struct timer_cbarg {
	int		 tmr_active;
	struct event	 tmr_ev;
	struct iked	*tmr_env;
	struct timeval	 tmr_first;
	struct timeval	 tmr_last;
	struct timeval	 tmr_tv;
	int		(*tmr_initcb)(struct iked *, struct iked_policy *);
} timer_initiator;

void	 timer_initiator_cb(int, short, void *);

#define IKED_TIMER_INITIATOR_INITIAL	2
#define IKED_TIMER_INITIATOR_INTERVAL	60
d38 2
a39 2
timer_register_initiator(struct iked *env,
    int (*cb)(struct iked *, struct iked_policy *))
d41 1
a41 10
	struct timer_cbarg	*tmr;

	timer_unregister_initiator(env);

	if (env->sc_passive)
		return;

	tmr = &timer_initiator;
	gettimeofday(&tmr->tmr_first, NULL);
	gettimeofday(&tmr->tmr_last, NULL);
d44 4
a47 7
	tmr->tmr_initcb = cb;
	tmr->tmr_active = 1;
	evtimer_set(&tmr->tmr_ev, timer_initiator_cb, tmr);

	tmr->tmr_tv.tv_sec = IKED_TIMER_INITIATOR_INITIAL;
	tmr->tmr_tv.tv_usec = 0;
	evtimer_add(&tmr->tmr_ev, &tmr->tmr_tv);
d51 1
a51 1
timer_unregister_initiator(struct iked *env)
d53 1
a53 1
	struct timer_cbarg	*tmr;
d55 2
a56 37
	tmr = &timer_initiator;
	if (!tmr->tmr_active)
		return;

	event_del(&tmr->tmr_ev);
	bzero(tmr, sizeof(*tmr));
}

void
timer_initiator_cb(int fd, short event, void *arg)
{
	struct timer_cbarg	*tmr = arg;
	struct iked		*env = tmr->tmr_env;
	struct iked_policy	*pol;

	gettimeofday(&tmr->tmr_last, NULL);

	TAILQ_FOREACH(pol, &env->sc_policies, pol_entry) {
		if ((pol->pol_flags & IKED_POLICY_ACTIVE) == 0)
			continue;
		if (sa_peer_lookup(pol, &pol->pol_peer.addr) != NULL) {
			log_debug("%s: \"%s\" is already active",
			    __func__, pol->pol_name);
			continue;
		}

		log_debug("%s: initiating \"%s\"", __func__, pol->pol_name);

		if (tmr->tmr_initcb != NULL) {
			/* Ignore error but what should we do on failure? */
			(void)tmr->tmr_initcb(env, pol);
		}
	}

	tmr->tmr_tv.tv_sec = IKED_TIMER_INITIATOR_INTERVAL;
	tmr->tmr_tv.tv_usec = 0;
	evtimer_add(&tmr->tmr_ev, &tmr->tmr_tv);
@


1.4
log
@Don't initiate any connections in passive mode, not even for ACQUIRE messages
from the PFKEY socket.  This is needed for sasyncd.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.3 2011/01/21 11:56:00 reyk Exp $	*/
d37 1
a37 1
	struct event	 tmr_ev; 
@


1.3
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.2 2010/06/14 08:10:32 reyk Exp $	*/
d57 3
@


1.2
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: timer.c,v 1.1 2010/06/11 12:47:18 reyk Exp $	*/
d94 1
a94 1
	RB_FOREACH(pol, iked_policies, &env->sc_policies) {
d97 1
a97 1
		if (sa_peer_lookup(pol, &pol->pol_peer) != NULL) {
@


1.1
log
@add some infrastructure to support timers and initiator mode later.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
	void		(*tmr_initcb)(struct iked *, struct iked_policy *);
d52 1
a52 1
    void (*cb)(struct iked *, struct iked_policy *))
d105 4
a108 2
		if (tmr->tmr_initcb != NULL)
			tmr->tmr_initcb(env, pol);
@

