head	1.155;
access;
symbols
	OPENBSD_6_2:1.155.0.2
	OPENBSD_6_2_BASE:1.155
	OPENBSD_6_1:1.152.0.4
	OPENBSD_6_1_BASE:1.152
	OPENBSD_6_0:1.131.0.2
	OPENBSD_6_0_BASE:1.131
	OPENBSD_5_9:1.128.0.2
	OPENBSD_5_9_BASE:1.128
	OPENBSD_5_8:1.121.0.4
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.119.0.2
	OPENBSD_5_7_BASE:1.119
	OPENBSD_5_6:1.114.0.4
	OPENBSD_5_6_BASE:1.114
	OPENBSD_5_5:1.97.0.4
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.83.0.2
	OPENBSD_5_4_BASE:1.83
	OPENBSD_5_3:1.81.0.2
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.76.0.2
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23;
locks; strict;
comment	@ * @;


1.155
date	2017.06.01.15.23.43;	author sthen;	state Exp;
branches;
next	1.154;
commitid	D9q0zudmtzKLEI92;

1.154
date	2017.04.26.10.42.38;	author henning;	state Exp;
branches;
next	1.153;
commitid	4JCdLHI0iXkeq6jm;

1.153
date	2017.04.13.07.04.09;	author patrick;	state Exp;
branches;
next	1.152;
commitid	bo33yiQX6Rmx6w3D;

1.152
date	2017.03.30.15.48.30;	author patrick;	state Exp;
branches;
next	1.151;
commitid	t3qdbcdAzCAgyC9r;

1.151
date	2017.03.28.16.25.21;	author reyk;	state Exp;
branches;
next	1.150;
commitid	0xl3lsRZoTwI6hLF;

1.150
date	2017.03.28.16.15.33;	author reyk;	state Exp;
branches;
next	1.149;
commitid	jIX1Ikfrlk8lDTvF;

1.149
date	2017.03.27.17.17.49;	author mikeb;	state Exp;
branches;
next	1.148;
commitid	Bk5vOJlj7LPPcjYU;

1.148
date	2017.03.27.10.43.53;	author mikeb;	state Exp;
branches;
next	1.147;
commitid	3tQzvpAXTrEiRD3X;

1.147
date	2017.03.27.10.29.02;	author reyk;	state Exp;
branches;
next	1.146;
commitid	yfhMvs0gHdZ86p06;

1.146
date	2017.03.27.10.24.36;	author reyk;	state Exp;
branches;
next	1.145;
commitid	QtsiC6NORfrFiVfm;

1.145
date	2017.03.27.10.21.19;	author reyk;	state Exp;
branches;
next	1.144;
commitid	luuYVyfWc8UoYDKf;

1.144
date	2017.03.27.10.06.41;	author reyk;	state Exp;
branches;
next	1.143;
commitid	37oqp7mUEkdGuEb4;

1.143
date	2017.03.13.18.49.20;	author mikeb;	state Exp;
branches;
next	1.142;
commitid	QPmMphRu2IVU5ovk;

1.142
date	2017.03.13.18.48.16;	author mikeb;	state Exp;
branches;
next	1.141;
commitid	yVaAm7edeFc8tc7a;

1.141
date	2017.03.13.18.28.02;	author reyk;	state Exp;
branches;
next	1.140;
commitid	1RefuXbcgN5FeUER;

1.140
date	2017.03.13.17.41.14;	author reyk;	state Exp;
branches;
next	1.139;
commitid	9gRqWsDzrTZXxOb2;

1.139
date	2017.03.13.17.23.45;	author mikeb;	state Exp;
branches;
next	1.138;
commitid	iTSgtFdg16wtwocX;

1.138
date	2017.03.13.15.06.51;	author patrick;	state Exp;
branches;
next	1.137;
commitid	EkthUtnilpgGayvp;

1.137
date	2017.03.13.14.57.55;	author reyk;	state Exp;
branches;
next	1.136;
commitid	U1hvTbFj9hTbHufd;

1.136
date	2017.03.13.14.50.52;	author mikeb;	state Exp;
branches;
next	1.135;
commitid	uv0nHhZFFqaa33vB;

1.135
date	2017.03.13.14.33.33;	author patrick;	state Exp;
branches;
next	1.134;
commitid	7TWpCOFlqUFXFrnD;

1.134
date	2017.02.24.11.23.02;	author patrick;	state Exp;
branches;
next	1.133;
commitid	TNON4H1p9eGRYm6V;

1.133
date	2017.01.20.14.12.32;	author mikeb;	state Exp;
branches;
next	1.132;
commitid	JQSYxAkhAJdEX5y6;

1.132
date	2017.01.20.13.51.08;	author mikeb;	state Exp;
branches;
next	1.131;
commitid	84m4auv4kZhsriSj;

1.131
date	2016.06.02.07.14.26;	author patrick;	state Exp;
branches;
next	1.130;
commitid	Vy4sQ1u4j15cutqa;

1.130
date	2016.06.01.11.16.41;	author patrick;	state Exp;
branches;
next	1.129;
commitid	LPZMTPg26WvdrIfQ;

1.129
date	2016.06.01.10.52.28;	author patrick;	state Exp;
branches;
next	1.128;
commitid	2GwqvUmdQPDURen6;

1.128
date	2015.10.22.15.55.18;	author reyk;	state Exp;
branches;
next	1.127;
commitid	9R73DxVDj9dmoXct;

1.127
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.126;
commitid	HzcDW70HFbhaqvT8;

1.126
date	2015.10.15.18.40.38;	author mmcc;	state Exp;
branches;
next	1.125;
commitid	rQFz7wM8cPpo2dCG;

1.125
date	2015.10.02.16.13.43;	author reyk;	state Exp;
branches;
next	1.124;
commitid	8C9KpmqssU5QYlhy;

1.124
date	2015.10.01.10.59.23;	author reyk;	state Exp;
branches;
next	1.123;
commitid	J33WGURgnlsCAOFp;

1.123
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.122;
commitid	CNs9dXqQUQ09vB19;

1.122
date	2015.08.19.14.12.43;	author reyk;	state Exp;
branches;
next	1.121;
commitid	AVPSAC8CcLDWTPgE;

1.121
date	2015.07.07.19.13.31;	author markus;	state Exp;
branches;
next	1.120;
commitid	a1FLyyKqRzzs0TCl;

1.120
date	2015.03.26.19.52.35;	author markus;	state Exp;
branches;
next	1.119;
commitid	OLM4J0heQ8InGopV;

1.119
date	2015.02.06.10.39.01;	author deraadt;	state Exp;
branches;
next	1.118;
commitid	fN2B4abgRqE4hFJn;

1.118
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	Uu5nFG3wCl0LACBb;

1.117
date	2014.12.05.13.40.44;	author mikeb;	state Exp;
branches;
next	1.116;
commitid	TuGlBVkPD0u4ZvPr;

1.116
date	2014.11.07.14.12.57;	author mikeb;	state Exp;
branches;
next	1.115;
commitid	RWGetcohgd6oEuqg;

1.115
date	2014.11.07.14.02.32;	author mikeb;	state Exp;
branches;
next	1.114;
commitid	auhursM13zeUc6fY;

1.114
date	2014.07.09.12.05.01;	author markus;	state Exp;
branches;
next	1.113;
commitid	vVxwcvD37B30artE;

1.113
date	2014.05.13.14.24.35;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2014.05.09.06.37.24;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2014.05.09.06.29.46;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2014.05.07.12.57.13;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2014.05.07.10.52.47;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2014.05.06.14.10.53;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2014.05.06.09.48.40;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2014.05.06.08.17.58;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2014.05.06.07.24.37;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2014.05.06.07.08.10;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2014.04.29.11.51.13;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2014.04.28.11.21.02;	author reyk;	state Exp;
branches;
next	1.100;

1.100
date	2014.04.10.16.08.02;	author reyk;	state Exp;
branches;
next	1.99;

1.99
date	2014.03.12.14.28.09;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2014.03.12.11.57.54;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2014.02.26.14.09.15;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2014.02.21.20.52.38;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2014.02.18.13.10.48;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2014.02.17.15.53.46;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2014.02.17.11.00.14;	author reyk;	state Exp;
branches;
next	1.92;

1.92
date	2014.02.14.09.00.03;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2014.01.24.07.35.55;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2014.01.24.05.58.52;	author mikeb;	state Exp;
branches;
next	1.89;

1.89
date	2014.01.22.09.25.41;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2013.12.09.15.22.32;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2013.11.28.20.30.41;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2013.11.28.20.27.17;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2013.11.28.20.21.17;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2013.06.13.09.11.51;	author reyk;	state Exp;
branches;
next	1.82;

1.82
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2012.12.15.23.15.11;	author reyk;	state Exp;
branches;
next	1.79;

1.79
date	2012.10.23.14.32.45;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2012.10.22.10.25.17;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2012.07.05.08.37.22;	author mikeb;	state Exp;
branches;
next	1.75;

1.75
date	2012.07.03.11.19.27;	author mikeb;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.02.16.55.28;	author mikeb;	state Exp;
branches;
next	1.73;

1.73
date	2012.07.02.13.29.47;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2012.07.02.13.03.24;	author mikeb;	state Exp;
branches;
next	1.71;

1.71
date	2012.07.02.09.49.30;	author mikeb;	state Exp;
branches;
next	1.70;

1.70
date	2012.06.29.15.05.49;	author mikeb;	state Exp;
branches;
next	1.69;

1.69
date	2012.06.26.11.05.43;	author mikeb;	state Exp;
branches;
next	1.68;

1.68
date	2012.06.26.11.00.28;	author mikeb;	state Exp;
branches;
next	1.67;

1.67
date	2012.06.22.16.28.20;	author mikeb;	state Exp;
branches;
next	1.66;

1.66
date	2012.06.22.16.06.31;	author mikeb;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.30.16.17.20;	author mikeb;	state Exp;
branches;
next	1.64;

1.64
date	2012.05.30.09.39.35;	author mikeb;	state Exp;
branches;
next	1.63;

1.63
date	2012.05.30.09.18.13;	author mikeb;	state Exp;
branches;
next	1.62;

1.62
date	2012.05.29.15.09.12;	author mikeb;	state Exp;
branches;
next	1.61;

1.61
date	2012.05.23.16.23.01;	author mikeb;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.23.14.54.04;	author mikeb;	state Exp;
branches;
next	1.59;

1.59
date	2012.05.08.15.37.09;	author mikeb;	state Exp;
branches;
next	1.58;

1.58
date	2012.05.07.10.58.38;	author mikeb;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.05.01.28.06;	author mikeb;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.05.12.59.31;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2011.05.02.12.39.18;	author mikeb;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.18.09.54.41;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.18.08.45.43;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.15.13.10.49;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.28.18.21.37;	author mikeb;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.26.17.07.59;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.26.16.59.24;	author mikeb;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.26.16.35.17;	author mikeb;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.25.10.58.41;	author mikeb;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.24.17.44.28;	author mikeb;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.21.18.02.53;	author mikeb;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.21.17.01.33;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.21.16.51.38;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.21.13.19.35;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.21.13.09.46;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.21.11.37.02;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.17.18.57.42;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.17.18.49.35;	author mikeb;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.12.14.26.26;	author mikeb;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.12.14.23.53;	author mikeb;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.12.14.22.25;	author mikeb;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.23.15.11.19;	author mikeb;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.22.17.53.54;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.01.12.01.25;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.22.09.12.18;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.09.13.06.46;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.29.14.41.21;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.20.16.28.22;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.03.16.59.35;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.27.05.40.49;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.27.01.03.22;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.26.19.54.19;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.26.19.48.04;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.26.18.32.34;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.23.10.49.37;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.14.23.14.09;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.14.21.12.56;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.14.14.17.49;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.14.14.03.15;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.14.12.05.32;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.14.11.33.55;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.14.08.55.59;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.11.12.47.18;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.10.12.06.34;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.08.29.47;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.04.09.51.45;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.155
log
@Expand $eapid in iked tags, allowing PF rules to be written based on EAP
identity (username). OK mikeb@@
@
text
@/*	$OpenBSD: ikev2.c,v 1.154 2017/04/26 10:42:38 henning Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* roundup */
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include <openssl/sha.h>
#include <openssl/evp.h>
#include <openssl/x509.h>

#include "iked.h"
#include "ikev2.h"
#include "eap.h"
#include "dh.h"

void	 ikev2_run(struct privsep *, struct privsep_proc *, void *);
int	 ikev2_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 ikev2_dispatch_cert(int, struct privsep_proc *, struct imsg *);

struct iked_sa *
	 ikev2_getimsgdata(struct iked *, struct imsg *, struct iked_sahdr *,
	    uint8_t *, uint8_t **, size_t *);

void	 ikev2_recv(struct iked *, struct iked_message *);
int	 ikev2_ike_auth_compatible(struct iked_sa *, uint8_t, uint8_t);
int	 ikev2_ike_auth_recv(struct iked *, struct iked_sa *,
	    struct iked_message *);
int	 ikev2_ike_auth(struct iked *, struct iked_sa *);

void	 ikev2_init_recv(struct iked *, struct iked_message *,
	    struct ike_header *);
void	 ikev2_init_ike_sa_timeout(struct iked *, void *);
int	 ikev2_init_ike_sa_peer(struct iked *, struct iked_policy *,
	    struct iked_addr *, struct iked_message *);
int	 ikev2_init_ike_auth(struct iked *, struct iked_sa *);
int	 ikev2_init_auth(struct iked *, struct iked_message *);
int	 ikev2_init_done(struct iked *, struct iked_sa *);

void	 ikev2_resp_recv(struct iked *, struct iked_message *,
	    struct ike_header *);
int	 ikev2_resp_ike_sa_init(struct iked *, struct iked_message *);
int	 ikev2_resp_ike_auth(struct iked *, struct iked_sa *);
int	 ikev2_resp_ike_eap(struct iked *, struct iked_sa *, struct ibuf *);
int	 ikev2_send_auth_failed(struct iked *, struct iked_sa *);
int	 ikev2_send_error(struct iked *, struct iked_sa *,
	    struct iked_message *, uint8_t);

int	 ikev2_send_create_child_sa(struct iked *, struct iked_sa *,
	    struct iked_spi *, uint8_t);
int	 ikev2_ikesa_enable(struct iked *, struct iked_sa *, struct iked_sa *);
void	 ikev2_ikesa_delete(struct iked *, struct iked_sa *, int);
int	 ikev2_nonce_cmp(struct ibuf *, struct ibuf *);
int	 ikev2_init_create_child_sa(struct iked *, struct iked_message *);
int	 ikev2_resp_create_child_sa(struct iked *, struct iked_message *);
void	 ikev2_ike_sa_rekey(struct iked *, void *);
void	 ikev2_ike_sa_rekey_timeout(struct iked *, void *);
void	 ikev2_ike_sa_rekey_schedule(struct iked *, struct iked_sa *);
void	 ikev2_ike_sa_alive(struct iked *, void *);
void	 ikev2_ike_sa_keepalive(struct iked *, void *);

int	 ikev2_sa_initiator(struct iked *, struct iked_sa *,
	    struct iked_sa *, struct iked_message *);
int	 ikev2_sa_responder(struct iked *, struct iked_sa *, struct iked_sa *,
	    struct iked_message *);
int	 ikev2_sa_initiator_dh(struct iked_sa *, struct iked_message *,
	    unsigned int);
int	 ikev2_sa_responder_dh(struct iked_kex *, struct iked_proposals *,
	    struct iked_message *, unsigned int);
void	 ikev2_sa_cleanup_dh(struct iked_sa *);
int	 ikev2_sa_keys(struct iked *, struct iked_sa *, struct ibuf *);
int	 ikev2_sa_tag(struct iked_sa *, struct iked_id *);
int	 ikev2_set_sa_proposal(struct iked_sa *, struct iked_policy *,
	    unsigned int);

int	 ikev2_childsa_negotiate(struct iked *, struct iked_sa *,
	    struct iked_kex *, struct iked_proposals *, int, int, int);
int	 ikev2_childsa_delete_proposed(struct iked *, struct iked_sa *,
	    struct iked_proposals *);
int	 ikev2_match_proposals(struct iked_proposal *, struct iked_proposal *,
	    struct iked_transform **, int);
int	 ikev2_valid_proposal(struct iked_proposal *,
	    struct iked_transform **, struct iked_transform **, int *);

ssize_t	 ikev2_add_proposals(struct iked *, struct iked_sa *, struct ibuf *,
	    struct iked_proposals *, uint8_t, int, int);
ssize_t	 ikev2_add_cp(struct iked *, struct iked_sa *, struct ibuf *);
ssize_t	 ikev2_add_transform(struct ibuf *,
	    uint8_t, uint8_t, uint16_t, uint16_t);
ssize_t	 ikev2_add_ts(struct ibuf *, struct ikev2_payload **, ssize_t,
	    struct iked_sa *, int);
ssize_t	 ikev2_add_certreq(struct ibuf *, struct ikev2_payload **, ssize_t,
	    struct ibuf *, uint8_t);
ssize_t	 ikev2_add_ipcompnotify(struct iked *, struct ibuf *,
	    struct ikev2_payload **, ssize_t, struct iked_sa *);
ssize_t	 ikev2_add_ts_payload(struct ibuf *, unsigned int, struct iked_sa *);
int	 ikev2_add_data(struct ibuf *, void *, size_t);
int	 ikev2_add_buf(struct ibuf *buf, struct ibuf *);

int	 ikev2_ipcomp_enable(struct iked *, struct iked_sa *);
void	 ikev2_ipcomp_csa_free(struct iked *, struct iked_childsa *);

int	 ikev2_cp_setaddr(struct iked *, struct iked_sa *, sa_family_t);
int	 ikev2_cp_fixaddr(struct iked_sa *, struct iked_addr *,
	    struct iked_addr *);

ssize_t	ikev2_add_sighashnotify(struct ibuf *, struct ikev2_payload **,
	    ssize_t);
ssize_t ikev2_add_nat_detection(struct iked *, struct ibuf *,
	    struct ikev2_payload **, struct iked_message *, ssize_t);

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	ikev2_dispatch_parent },
	{ "certstore",	PROC_CERT,	ikev2_dispatch_cert }
};

pid_t
ikev2(struct privsep *ps, struct privsep_proc *p)
{
	return (proc_run(ps, p, procs, nitems(procs), ikev2_run, NULL));
}

void
ikev2_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	/*
	 * pledge in the ikev2 process:
	 * stdio - for malloc and basic I/O including events.
	 * inet - for sendto with specified peer address.
	 * recvfd - for PFKEYv2 and the listening UDP sockets.
	 * In theory, recvfd could be dropped after getting the fds once.
	 */
	if (pledge("stdio inet recvfd", NULL) == -1)
		fatal("pledge");
}

int
ikev2_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked		*env = p->p_env;

	switch (imsg->hdr.type) {
	case IMSG_CTL_RESET:
		return (config_getreset(env, imsg));
	case IMSG_CTL_COUPLE:
	case IMSG_CTL_DECOUPLE:
		return (config_getcoupled(env, imsg->hdr.type));
	case IMSG_CTL_ACTIVE:
	case IMSG_CTL_PASSIVE:
		if (config_getmode(env, imsg->hdr.type) == -1)
			return (0);	/* ignore error */
		if (env->sc_passive)
			timer_del(env, &env->sc_inittmr);
		else {
			timer_set(env, &env->sc_inittmr, ikev2_init_ike_sa,
			    NULL);
			timer_add(env, &env->sc_inittmr,
			    IKED_INITIATOR_INITIAL);
		}
		return (0);
	case IMSG_UDP_SOCKET:
		return (config_getsocket(env, imsg, ikev2_msg_cb));
	case IMSG_PFKEY_SOCKET:
		return (config_getpfkey(env, imsg));
	case IMSG_CFG_POLICY:
		return (config_getpolicy(env, imsg));
	case IMSG_CFG_FLOW:
		return (config_getflow(env, imsg));
	case IMSG_CFG_USER:
		return (config_getuser(env, imsg));
	case IMSG_COMPILE:
		return (config_getcompile(env, imsg));
	default:
		break;
	}

	return (-1);
}

int
ikev2_dispatch_cert(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked		*env = p->p_env;
	struct iked_sahdr	 sh;
	struct iked_sa		*sa;
	uint8_t			 type;
	uint8_t			*ptr;
	size_t			 len;
	struct iked_id		*id = NULL;
	int			 ignore = 0;

	switch (imsg->hdr.type) {
	case IMSG_CERTREQ:
		IMSG_SIZE_CHECK(imsg, &type);

		ptr = imsg->data;
		memcpy(&type, ptr, sizeof(type));
		ptr += sizeof(type);

		ibuf_release(env->sc_certreq);
		env->sc_certreqtype = type;
		env->sc_certreq = ibuf_new(ptr,
		    IMSG_DATA_SIZE(imsg) - sizeof(type));

		log_debug("%s: updated local CERTREQ type %s length %zu",
		    __func__, print_map(type, ikev2_cert_map),
		    ibuf_length(env->sc_certreq));

		break;
	case IMSG_CERTVALID:
	case IMSG_CERTINVALID:
		if (IMSG_DATA_SIZE(imsg) < sizeof(type) + sizeof(sh))
			fatalx("bad length imsg received");

		memcpy(&sh, imsg->data, sizeof(sh));
		memcpy(&type, (uint8_t *)imsg->data + sizeof(sh),
		    sizeof(type));

		/* Ignore invalid or unauthenticated SAs */
		if ((sa = sa_lookup(env,
		    sh.sh_ispi, sh.sh_rspi, sh.sh_initiator)) == NULL ||
		    sa->sa_state < IKEV2_STATE_EAP)
			break;

		if (imsg->hdr.type == IMSG_CERTVALID) {
			log_debug("%s: peer certificate is valid", __func__);
			sa_stateflags(sa, IKED_REQ_CERTVALID);
		} else {
			log_warnx("%s: peer certificate is invalid", __func__);
			ikev2_send_auth_failed(env, sa);
			break;
		}
		if (ikev2_ike_auth(env, sa) != 0)
			log_debug("%s: failed to send ike auth", __func__);
		break;
	case IMSG_CERT:
		if ((sa = ikev2_getimsgdata(env, imsg,
		    &sh, &type, &ptr, &len)) == NULL) {
			log_debug("%s: invalid cert reply", __func__);
			break;
		}

		/*
		 * Ignore the message if we already got a valid certificate.
		 * This might happen if the peer sent multiple CERTREQs.
		 */
		if (sa->sa_stateflags & IKED_REQ_CERT ||
		    type == IKEV2_CERT_NONE)
			ignore = 1;

		log_debug("%s: cert type %s length %zu, %s", __func__,
		    print_map(type, ikev2_cert_map), len,
		    ignore ? "ignored" : "ok");

		if (ignore)
			break;

		if (sh.sh_initiator)
			id = &sa->sa_icert;
		else
			id = &sa->sa_rcert;

		id->id_type = type;
		id->id_offset = 0;
		ibuf_release(id->id_buf);
		id->id_buf = NULL;

		if (len <= 0 || (id->id_buf = ibuf_new(ptr, len)) == NULL) {
			log_debug("%s: failed to get cert payload",
			    __func__);
			break;
		}

		sa_stateflags(sa, IKED_REQ_CERT);

		if (ikev2_ike_auth(env, sa) != 0)
			log_debug("%s: failed to send ike auth", __func__);
		break;
	case IMSG_AUTH:
		if ((sa = ikev2_getimsgdata(env, imsg,
		    &sh, &type, &ptr, &len)) == NULL) {
			log_debug("%s: invalid auth reply", __func__);
			break;
		}
		if (sa_stateok(sa, IKEV2_STATE_VALID)) {
			log_warnx("%s: ignoring AUTH in state %s", __func__,
			    print_map(sa->sa_state, ikev2_state_map));
			break;
		}

		log_debug("%s: AUTH type %d len %zu", __func__, type, len);

		id = &sa->sa_localauth;
		id->id_type = type;
		id->id_offset = 0;
		ibuf_release(id->id_buf);
		id->id_buf = NULL;

		if (type != IKEV2_AUTH_NONE) {
			if (len <= 0 ||
			    (id->id_buf = ibuf_new(ptr, len)) == NULL) {
				log_debug("%s: failed to get auth payload",
				    __func__);
				break;
			}
		}

		sa_stateflags(sa, IKED_REQ_AUTH);

		if (ikev2_ike_auth(env, sa) != 0)
			log_debug("%s: failed to send ike auth", __func__);
		break;
	default:
		return (-1);
	}

	return (0);
}

struct iked_sa *
ikev2_getimsgdata(struct iked *env, struct imsg *imsg, struct iked_sahdr *sh,
    uint8_t *type, uint8_t **buf, size_t *size)
{
	uint8_t		*ptr;
	size_t		 len;
	struct iked_sa	*sa;

	IMSG_SIZE_CHECK(imsg, sh);

	ptr = imsg->data;
	len = IMSG_DATA_SIZE(imsg) - sizeof(*sh) - sizeof(*type);
	memcpy(sh, ptr, sizeof(*sh));
	memcpy(type, ptr + sizeof(*sh), sizeof(*type));

	sa = sa_lookup(env, sh->sh_ispi, sh->sh_rspi, sh->sh_initiator);

	log_debug("%s: imsg %d rspi %s ispi %s initiator %d sa %s"
	    " type %d data length %zd",
	    __func__, imsg->hdr.type,
	    print_spi(sh->sh_rspi, 8),
	    print_spi(sh->sh_ispi, 8),
	    sh->sh_initiator,
	    sa == NULL ? "invalid" : "valid", *type, len);

	if (sa == NULL)
		return (NULL);

	*buf = ptr + sizeof(*sh) + sizeof(*type);
	*size = len;

	return (sa);
}

void
ikev2_recv(struct iked *env, struct iked_message *msg)
{
	struct ike_header	*hdr;
	struct iked_message	*m;
	struct iked_sa		*sa;
	unsigned int		 initiator, flag = 0;

	hdr = ibuf_seek(msg->msg_data, msg->msg_offset, sizeof(*hdr));

	if (hdr == NULL || ibuf_size(msg->msg_data) <
	    (betoh32(hdr->ike_length) - msg->msg_offset))
		return;

	initiator = (hdr->ike_flags & IKEV2_FLAG_INITIATOR) ? 0 : 1;
	msg->msg_response = (hdr->ike_flags & IKEV2_FLAG_RESPONSE) ? 1 : 0;
	msg->msg_sa = sa_lookup(env,
	    betoh64(hdr->ike_ispi), betoh64(hdr->ike_rspi),
	    initiator);
	msg->msg_msgid = betoh32(hdr->ike_msgid);
	if (policy_lookup(env, msg) != 0)
		return;

	log_info("%s: %s %s from %s %s to %s policy '%s' id %u, %ld bytes",
	    __func__, print_map(hdr->ike_exchange, ikev2_exchange_map),
	    msg->msg_response ? "response" : "request",
	    initiator ? "responder" : "initiator",
	    print_host((struct sockaddr *)&msg->msg_peer, NULL, 0),
	    print_host((struct sockaddr *)&msg->msg_local, NULL, 0),
	    msg->msg_policy->pol_name, msg->msg_msgid,
	    ibuf_length(msg->msg_data));
	log_debug("%s: ispi %s rspi %s", __func__,
	    print_spi(betoh64(hdr->ike_ispi), 8),
	    print_spi(betoh64(hdr->ike_rspi), 8));

	if ((sa = msg->msg_sa) == NULL)
		goto done;

	if (hdr->ike_exchange == IKEV2_EXCHANGE_CREATE_CHILD_SA)
		flag = IKED_REQ_CHILDSA;
	if (hdr->ike_exchange == IKEV2_EXCHANGE_INFORMATIONAL)
		flag = IKED_REQ_INF;

	if (msg->msg_response) {
		if (msg->msg_msgid > sa->sa_reqid)
			return;
		if (hdr->ike_exchange != IKEV2_EXCHANGE_INFORMATIONAL &&
		    !ikev2_msg_lookup(env, &sa->sa_requests, msg, hdr))
			return;
		if (flag) {
			if ((sa->sa_stateflags & flag) == 0)
				return;
			/*
			 * We have initiated this exchange, even if
			 * we are not the initiator of the IKE SA.
			 */
			initiator = 1;
		}
		/*
		 * There's no need to keep the request around anymore
		 */
		if ((m = ikev2_msg_lookup(env, &sa->sa_requests, msg, hdr)))
			ikev2_msg_dispose(env, &sa->sa_requests, m);
	} else {
		if (msg->msg_msgid < sa->sa_msgid)
			return;
		if (flag)
			initiator = 0;
		/*
		 * See if we have responded to this request before
		 */
		if ((m = ikev2_msg_lookup(env, &sa->sa_responses, msg, hdr))) {
			if (ikev2_msg_retransmit_response(env, sa, m)) {
				log_warn("%s: failed to retransmit a "
				    "response", __func__);
				sa_free(env, sa);
			}
			return;
		} else if (sa->sa_msgid_set && msg->msg_msgid == sa->sa_msgid) {
			/*
			 * Response is being worked on, most likely we're
			 * waiting for the CA process to get back to us
			 */
			return;
		}
		/*
		 * If it's a new request, make sure to update the peer's
		 * message ID and dispose of all previous responses.
		 * We need to set sa_msgid_set in order to distinguish between
		 * "last msgid was 0" and "msgid not set yet".
		 */
		sa->sa_msgid = msg->msg_msgid;
		sa->sa_msgid_set = 1;
		ikev2_msg_prevail(env, &sa->sa_responses, msg);
	}

	if (sa_address(sa, &sa->sa_peer, &msg->msg_peer) == -1 ||
	    sa_address(sa, &sa->sa_local, &msg->msg_local) == -1)
		return;

	sa->sa_fd = msg->msg_fd;

	log_debug("%s: updated SA to peer %s local %s", __func__,
	    print_host((struct sockaddr *)&sa->sa_peer.addr, NULL, 0),
	    print_host((struct sockaddr *)&sa->sa_local.addr, NULL, 0));

done:
	if (initiator)
		ikev2_init_recv(env, msg, hdr);
	else
		ikev2_resp_recv(env, msg, hdr);

	if (sa != NULL && sa->sa_state == IKEV2_STATE_CLOSED) {
		log_debug("%s: closing SA", __func__);
		sa_free(env, sa);
	}
}

int
ikev2_ike_auth_compatible(struct iked_sa *sa, uint8_t policy, uint8_t wire)
{
	if (wire == IKEV2_AUTH_SIG_ANY)		/* internal, not on wire */
		return (-1);
	if (policy == wire || policy == IKEV2_AUTH_NONE)
		return (0);
	switch (policy) {
	case IKEV2_AUTH_SIG_ANY:
		switch (wire) {
		case IKEV2_AUTH_SIG:
		case IKEV2_AUTH_RSA_SIG:
		case IKEV2_AUTH_ECDSA_256:
		case IKEV2_AUTH_ECDSA_384:
		case IKEV2_AUTH_ECDSA_521:
			return (0);
		}
		break;
	case IKEV2_AUTH_SIG:
	case IKEV2_AUTH_RSA_SIG:
	case IKEV2_AUTH_ECDSA_256:
	case IKEV2_AUTH_ECDSA_384:
	case IKEV2_AUTH_ECDSA_521:
		switch (wire) {
		/*
		 * XXX Maybe we need an indication saying:
		 * XXX Accept AUTH_SIG as long as its DSA?
		 */
		case IKEV2_AUTH_SIG:
			if (sa->sa_sigsha2)
				return (0);
		}
		break;
	}
	return (-1);
}

int
ikev2_ike_auth_recv(struct iked *env, struct iked_sa *sa,
    struct iked_message *msg)
{
	struct iked_id		*id, *certid;
	struct ibuf		*authmsg;
	struct iked_auth	 ikeauth;
	struct iked_policy	*policy = sa->sa_policy;
	int			 ret = -1;

	if (sa->sa_hdr.sh_initiator) {
		id = &sa->sa_rid;
		certid = &sa->sa_rcert;
	} else {
		id = &sa->sa_iid;
		certid = &sa->sa_icert;
	}
	/* try to relookup the policy based on the peerid */
	if (msg->msg_id.id_type && !sa->sa_hdr.sh_initiator) {
		struct iked_policy	*old = sa->sa_policy;

		sa->sa_policy = NULL;
		if (policy_lookup(env, msg) == 0 && msg->msg_policy &&
		    msg->msg_policy != old) {
			/* move sa to new policy */
			policy = sa->sa_policy = msg->msg_policy;
			TAILQ_REMOVE(&old->pol_sapeers, sa, sa_peer_entry);
			TAILQ_INSERT_TAIL(&policy->pol_sapeers,
			    sa, sa_peer_entry);
			if (old->pol_flags & IKED_POLICY_REFCNT)
				policy_unref(env, old);
			if (policy->pol_flags & IKED_POLICY_REFCNT)
				policy_ref(env, policy);
		} else {
			/* restore */
			msg->msg_policy = sa->sa_policy = old;
		}
	}

	if (msg->msg_id.id_type) {
		memcpy(id, &msg->msg_id, sizeof(*id));
		bzero(&msg->msg_id, sizeof(msg->msg_id));

		if (!sa->sa_hdr.sh_initiator) {
			if ((authmsg = ikev2_msg_auth(env, sa,
			    !sa->sa_hdr.sh_initiator)) == NULL) {
				log_debug("%s: failed to get response "
				    "auth data", __func__);
				return (-1);
			}

			ca_setauth(env, sa, authmsg, PROC_CERT);
			ibuf_release(authmsg);
		}
	}

	if (msg->msg_cert.id_type) {
		memcpy(certid, &msg->msg_cert, sizeof(*certid));
		bzero(&msg->msg_cert, sizeof(msg->msg_cert));

		ca_setcert(env, &sa->sa_hdr,
		    id, certid->id_type,
		    ibuf_data(certid->id_buf),
		    ibuf_length(certid->id_buf), PROC_CERT);
	}

	if (msg->msg_auth.id_type) {
		memcpy(&ikeauth, &policy->pol_auth, sizeof(ikeauth));

		if (policy->pol_auth.auth_eap && sa->sa_eapmsk != NULL) {
			/*
			 * The initiator EAP auth is a PSK derived
			 * from the EAP-specific MSK
			 */
			ikeauth.auth_method = IKEV2_AUTH_SHARED_KEY_MIC;

			/* Copy session key as PSK */
			memcpy(ikeauth.auth_data, ibuf_data(sa->sa_eapmsk),
			    ibuf_size(sa->sa_eapmsk));
			ikeauth.auth_length = ibuf_size(sa->sa_eapmsk);
		}

		if (ikev2_ike_auth_compatible(sa,
		    ikeauth.auth_method, msg->msg_auth.id_type) < 0) {
			log_warnx("%s: unexpected auth method %s, was "
			    "expecting %s", __func__,
			    print_map(msg->msg_auth.id_type, ikev2_auth_map),
			    print_map(ikeauth.auth_method, ikev2_auth_map));
			return (-1);
		}
		ikeauth.auth_method = msg->msg_auth.id_type;

		if ((authmsg = ikev2_msg_auth(env, sa,
		    sa->sa_hdr.sh_initiator)) == NULL) {
			log_debug("%s: failed to get auth data", __func__);
			return (-1);
		}

		ret = ikev2_msg_authverify(env, sa, &ikeauth,
		    ibuf_data(msg->msg_auth.id_buf),
		    ibuf_length(msg->msg_auth.id_buf),
		    authmsg);
		ibuf_release(authmsg);

		if (ret != 0) {
			log_debug("%s: ikev2_msg_authverify failed", __func__);
			ikev2_send_auth_failed(env, sa);
			return (-1);
		}

		if (sa->sa_eapmsk != NULL) {
			if ((authmsg = ikev2_msg_auth(env, sa,
			    !sa->sa_hdr.sh_initiator)) == NULL) {
				log_debug("%s: failed to get auth data",
				    __func__);
				return (-1);
			}

			/* XXX 2nd AUTH for EAP messages */
			ret = ikev2_msg_authsign(env, sa, &ikeauth, authmsg);
			ibuf_release(authmsg);

			if (ret != 0) {
				/* XXX */
				return (-1);
			}

			/* ikev2_msg_authverify verified AUTH */
			sa_stateflags(sa, IKED_REQ_AUTHVALID);
			sa_stateflags(sa, IKED_REQ_EAPVALID);

			sa_state(env, sa, IKEV2_STATE_EAP_SUCCESS);
		}
	}

	if (!TAILQ_EMPTY(&msg->msg_proposals)) {
		if (ikev2_sa_negotiate(&sa->sa_proposals,
		    &sa->sa_policy->pol_proposals, &msg->msg_proposals,
		    0) != 0) {
			log_info("%s: no proposal chosen", __func__);
			msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
			return (-1);
		} else
			sa_stateflags(sa, IKED_REQ_SA);
	}

	return ikev2_ike_auth(env, sa);
}

int
ikev2_ike_auth(struct iked *env, struct iked_sa *sa)
{
	struct iked_policy	*pol = sa->sa_policy;
	uint8_t			 certreqtype;

	/* Attempt state transition */
	if (sa->sa_state == IKEV2_STATE_EAP_SUCCESS)
		sa_state(env, sa, IKEV2_STATE_EAP_VALID);
	else if (sa->sa_state == IKEV2_STATE_AUTH_SUCCESS)
		sa_state(env, sa, IKEV2_STATE_VALID);

	if (sa->sa_hdr.sh_initiator) {
		if (sa_stateok(sa, IKEV2_STATE_AUTH_SUCCESS))
			return (ikev2_init_done(env, sa));
		else
			return (ikev2_init_ike_auth(env, sa));
	}

	/*
	 * If we have to send a local certificate but did not receive an
	 * optional CERTREQ, use our own certreq to find a local certificate.
	 * We could alternatively extract the CA from the peer certificate
	 * to find a matching local one.
	 */
	if (sa->sa_statevalid & IKED_REQ_CERT) {
		if ((sa->sa_stateflags & IKED_REQ_CERTREQ) == 0) {
			log_debug("%s: no CERTREQ, using default", __func__);
			if (pol->pol_certreqtype)
				certreqtype = pol->pol_certreqtype;
			else
				certreqtype = env->sc_certreqtype;
			return (ca_setreq(env, sa,
			    &pol->pol_localid, certreqtype,
			    ibuf_data(env->sc_certreq),
			    ibuf_size(env->sc_certreq), PROC_CERT));
		} else if ((sa->sa_stateflags & IKED_REQ_CERT) == 0)
			return (0);	/* ignored, wait for cert */
	}

	return (ikev2_resp_ike_auth(env, sa));
}

void
ikev2_init_recv(struct iked *env, struct iked_message *msg,
    struct ike_header *hdr)
{
	struct iked_sa		*sa;
	in_port_t		 port;
	struct iked_socket	*sock;
	struct iked_policy	*pol;

	if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1) {
		log_debug("%s: unknown SA", __func__);
		return;
	}
	sa = msg->msg_sa;

	switch (hdr->ike_exchange) {
	case IKEV2_EXCHANGE_IKE_SA_INIT:
		/* Update the SPIs */
		if ((sa = sa_new(env,
		    betoh64(hdr->ike_ispi), betoh64(hdr->ike_rspi), 1,
		    NULL)) == NULL || sa != msg->msg_sa) {
			log_debug("%s: invalid new SA", __func__);
			if (sa)
				sa_free(env, sa);
		}
		break;
	case IKEV2_EXCHANGE_IKE_AUTH:
	case IKEV2_EXCHANGE_CREATE_CHILD_SA:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		break;
	case IKEV2_EXCHANGE_INFORMATIONAL:
		break;
	default:
		log_debug("%s: unsupported exchange: %s", __func__,
		    print_map(hdr->ike_exchange, ikev2_exchange_map));
		return;
	}

	if (ikev2_pld_parse(env, hdr, msg, msg->msg_offset) != 0) {
		log_debug("%s: failed to parse message", __func__);
		return;
	}

	if (!ikev2_msg_frompeer(msg))
		return;

	if (sa->sa_udpencap && sa->sa_natt == 0 &&
	    (sock = ikev2_msg_getsocket(env,
	    sa->sa_local.addr_af, 1)) != NULL) {
		/*
		 * Update address information and use the NAT-T
		 * port and socket, if available.
		 */
		port = htons(socket_getport(
		    (struct sockaddr *)&sock->sock_addr));
		sa->sa_local.addr_port = port;
		sa->sa_peer.addr_port = port;
		(void)socket_af((struct sockaddr *)&sa->sa_local.addr, port);
		(void)socket_af((struct sockaddr *)&sa->sa_peer.addr, port);

		msg->msg_fd = sa->sa_fd = sock->sock_fd;
		msg->msg_sock = sock;
		sa->sa_natt = 1;

		log_debug("%s: NAT detected, updated SA to "
		    "peer %s local %s", __func__,
		    print_host((struct sockaddr *)&sa->sa_peer.addr, NULL, 0),
		    print_host((struct sockaddr *)&sa->sa_local.addr, NULL, 0));
	}

	switch (hdr->ike_exchange) {
	case IKEV2_EXCHANGE_IKE_SA_INIT:
		if (ibuf_length(msg->msg_cookie)) {
			pol = sa->sa_policy;
			if (ikev2_init_ike_sa_peer(env, pol,
			    &pol->pol_peer, msg) != 0)
				log_warnx("%s: failed to initiate a "
				    "IKE_SA_INIT exchange", __func__);
			break;
		}
		(void)ikev2_init_auth(env, msg);
		break;
	case IKEV2_EXCHANGE_IKE_AUTH:
		(void)ikev2_ike_auth_recv(env, sa, msg);
		break;
	case IKEV2_EXCHANGE_CREATE_CHILD_SA:
		(void)ikev2_init_create_child_sa(env, msg);
		break;
	case IKEV2_EXCHANGE_INFORMATIONAL:
		sa->sa_stateflags &= ~IKED_REQ_INF;
		break;
	default:
		log_debug("%s: exchange %s not implemented", __func__,
		    print_map(hdr->ike_exchange, ikev2_exchange_map));
		break;
	}
}

void
ikev2_init_ike_sa(struct iked *env, void *arg)
{
	struct iked_policy	*pol;

	TAILQ_FOREACH(pol, &env->sc_policies, pol_entry) {
		if ((pol->pol_flags & IKED_POLICY_ACTIVE) == 0)
			continue;
		if (!TAILQ_EMPTY(&pol->pol_sapeers)) {
			log_debug("%s: \"%s\" is already active",
			    __func__, pol->pol_name);
			continue;
		}

		log_debug("%s: initiating \"%s\"", __func__, pol->pol_name);

		if (ikev2_init_ike_sa_peer(env, pol, &pol->pol_peer, NULL))
			log_debug("%s: failed to initiate with peer %s",
			    __func__,
			    print_host((struct sockaddr *)&pol->pol_peer.addr,
			    NULL, 0));
	}

	timer_set(env, &env->sc_inittmr, ikev2_init_ike_sa, NULL);
	timer_add(env, &env->sc_inittmr, IKED_INITIATOR_INTERVAL);
}

void
ikev2_init_ike_sa_timeout(struct iked *env, void *arg)
{
	struct iked_sa	 *sa = arg;

	log_debug("%s: ispi %s rspi %s", __func__,
	    print_spi(sa->sa_hdr.sh_ispi, 8),
	    print_spi(sa->sa_hdr.sh_rspi, 8));

	sa_free(env, sa);
}

int
ikev2_init_ike_sa_peer(struct iked *env, struct iked_policy *pol,
    struct iked_addr *peer, struct iked_message *retry)
{
	struct sockaddr_storage		 ss;
	struct iked_message		 req;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ikev2_keyexchange	*ke;
	struct ikev2_notify		*n;
	struct iked_sa			*sa = NULL;
	struct ibuf			*buf, *cookie = NULL;
	struct group			*group;
	ssize_t				 len;
	int				 ret = -1;
	struct iked_socket		*sock;
	in_port_t			 port;

	if ((sock = ikev2_msg_getsocket(env, peer->addr_af, 0)) == NULL)
		return (-1);

	if (retry != NULL) {
		sa = retry->msg_sa;
		cookie = retry->msg_cookie;
		sa_state(env, sa, IKEV2_STATE_INIT);
	}

	/* Create a new initiator SA */
	if (sa == NULL &&
	    (sa = sa_new(env, 0, 0, 1, pol)) == NULL)
		return (-1);

	/* Pick peer's DH group if asked */
	if (pol->pol_peerdh > 0 && sa->sa_dhgroup == NULL &&
	    (sa->sa_dhgroup = group_get(pol->pol_peerdh)) == NULL) {
		log_warnx("%s: invalid peer DH group %u", __func__,
		    pol->pol_peerdh);
		goto closeonly;
	}
	sa->sa_reqid = 0;

	if (ikev2_sa_initiator(env, sa, NULL, NULL) == -1)
		goto closeonly;

	if (pol->pol_local.addr.ss_family == AF_UNSPEC) {
		if (socket_getaddr(sock->sock_fd, &ss) == -1)
			goto closeonly;
	} else
		memcpy(&ss, &pol->pol_local.addr, pol->pol_local.addr.ss_len);

	if ((buf = ikev2_msg_init(env, &req, &peer->addr, peer->addr.ss_len,
	    &ss, ss.ss_len, 0)) == NULL)
		goto done;

	/* Inherit the port from the 1st send socket */
	port = htons(socket_getport((struct sockaddr *)&sock->sock_addr));
	(void)socket_af((struct sockaddr *)&req.msg_local, port);
	(void)socket_af((struct sockaddr *)&req.msg_peer, port);

	req.msg_fd = sock->sock_fd;
	req.msg_sa = sa;
	req.msg_sock = sock;
	req.msg_msgid = ikev2_msg_id(env, sa);

	/* IKE header */
	if ((hdr = ikev2_add_header(buf, sa, req.msg_msgid,
	    cookie == NULL ? IKEV2_PAYLOAD_SA : IKEV2_PAYLOAD_NOTIFY,
	    IKEV2_EXCHANGE_IKE_SA_INIT, 0)) == NULL)
		goto done;

	/* Reflect COOKIE */
	if (cookie) {
		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;
		if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
			goto done;
		n->n_protoid = IKEV2_SAPROTO_NONE;
		n->n_spisize = 0;
		n->n_type = htobe16(IKEV2_N_COOKIE);
		if (ikev2_add_buf(buf, cookie) == -1)
			goto done;
		len = sizeof(*n) + ibuf_size(cookie);

		log_debug("%s: added cookie, len %zu", __func__,
		    ibuf_size(cookie));
		print_hex(ibuf_data(cookie), 0, ibuf_size(cookie));

		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_SA) == -1)
			goto done;
	}

	/* SA payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if ((len = ikev2_add_proposals(env, sa, buf, &pol->pol_proposals,
	    IKEV2_SAPROTO_IKE, sa->sa_hdr.sh_initiator, 0)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_KE) == -1)
		goto done;

	/* KE payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if ((ke = ibuf_advance(buf, sizeof(*ke))) == NULL)
		goto done;
	if ((group = sa->sa_dhgroup) == NULL) {
		log_debug("%s: invalid dh", __func__);
		goto done;
	}
	ke->kex_dhgroup = htobe16(group->id);
	if (ikev2_add_buf(buf, sa->sa_dhiexchange) == -1)
		goto done;
	len = sizeof(*ke) + dh_getlen(group);

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONCE) == -1)
		goto done;

	/* NONCE payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if (ikev2_add_buf(buf, sa->sa_inonce) == -1)
		goto done;
	len = ibuf_size(sa->sa_inonce);

	if ((env->sc_opts & IKED_OPT_NONATT) == 0) {
		if (ntohs(port) == IKED_NATT_PORT) {
			/* Enforce NAT-T on the initiator side */
			log_debug("%s: enforcing NAT-T", __func__);
			req.msg_natt = sa->sa_natt = 1;
		}
		if ((len = ikev2_add_nat_detection(env, buf, &pld, &req, len))
		    == -1)
			goto done;
	}

	if ((len = ikev2_add_sighashnotify(buf, &pld, len)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
		goto done;

	(void)ikev2_pld_parse(env, hdr, &req, 0);

	ibuf_release(sa->sa_1stmsg);
	if ((sa->sa_1stmsg = ibuf_dup(buf)) == NULL) {
		log_debug("%s: failed to copy 1st message", __func__);
		goto done;
	}

	if ((ret = ikev2_msg_send(env, &req)) == 0)
		sa_state(env, sa, IKEV2_STATE_SA_INIT);

	/* Setup exchange timeout. */
	timer_set(env, &sa->sa_timer, ikev2_init_ike_sa_timeout, sa);
	timer_add(env, &sa->sa_timer, IKED_IKE_SA_EXCHANGE_TIMEOUT);

 done:
	ikev2_msg_cleanup(env, &req);
 closeonly:
	if (ret == -1) {
		log_debug("%s: closing SA", __func__);
		sa_free(env, sa);
	}

	return (ret);
}

int
ikev2_init_auth(struct iked *env, struct iked_message *msg)
{
	struct iked_sa			*sa = msg->msg_sa;
	struct ibuf			*authmsg;

	if (sa == NULL)
		return (-1);

	if (ikev2_sa_initiator(env, sa, NULL, msg) == -1) {
		log_debug("%s: failed to get IKE keys", __func__);
		return (-1);
	}

	if ((authmsg = ikev2_msg_auth(env, sa,
	    !sa->sa_hdr.sh_initiator)) == NULL) {
		log_debug("%s: failed to get auth data", __func__);
		return (-1);
	}

	if (ca_setauth(env, sa, authmsg, PROC_CERT) == -1) {
		log_debug("%s: failed to get cert", __func__);
		return (-1);
	}

	return (ikev2_init_ike_auth(env, sa));
}

int
ikev2_init_ike_auth(struct iked *env, struct iked_sa *sa)
{
	struct iked_policy		*pol = sa->sa_policy;
	struct ikev2_payload		*pld;
	struct ikev2_cert		*cert;
	struct ikev2_auth		*auth;
	struct iked_id			*id, *certid;
	struct ibuf			*e = NULL;
	uint8_t				 firstpayload;
	int				 ret = -1;
	ssize_t				 len;

	if (!sa_stateok(sa, IKEV2_STATE_SA_INIT))
		return (0);

	if (!sa->sa_localauth.id_type) {
		log_debug("%s: no local auth", __func__);
		return (-1);
	}

	/* New encrypted message buffer */
	if ((e = ibuf_static()) == NULL)
		goto done;

	id = &sa->sa_iid;
	certid = &sa->sa_icert;

	/* ID payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	firstpayload = IKEV2_PAYLOAD_IDi;
	if (ibuf_cat(e, id->id_buf) != 0)
		goto done;
	len = ibuf_size(id->id_buf);

	/* CERT payload */
	if ((sa->sa_stateinit & IKED_REQ_CERT) &&
	    (certid->id_type != IKEV2_CERT_NONE)) {
		if (ikev2_next_payload(pld, len,
		    IKEV2_PAYLOAD_CERT) == -1)
			goto done;
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((cert = ibuf_advance(e, sizeof(*cert))) == NULL)
			goto done;
		cert->cert_type = certid->id_type;
		if (ibuf_cat(e, certid->id_buf) != 0)
			goto done;
		len = ibuf_size(certid->id_buf) + sizeof(*cert);

		/* CERTREQ payload(s) */
		if ((len = ikev2_add_certreq(e, &pld,
		    len, env->sc_certreq, env->sc_certreqtype)) == -1)
			goto done;

		if (env->sc_certreqtype != pol->pol_certreqtype &&
		    (len = ikev2_add_certreq(e, &pld,
		    len, NULL, pol->pol_certreqtype)) == -1)
			goto done;
	}

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_AUTH) == -1)
		goto done;

	/* AUTH payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((auth = ibuf_advance(e, sizeof(*auth))) == NULL)
		goto done;
	auth->auth_method = sa->sa_localauth.id_type;
	if (ibuf_cat(e, sa->sa_localauth.id_buf) != 0)
		goto done;
	len = ibuf_size(sa->sa_localauth.id_buf) + sizeof(*auth);

	/* CP payload */
	if (sa->sa_cp) {
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_CP) == -1)
			goto done;

		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((len = ikev2_add_cp(env, sa, e)) == -1)
			goto done;
	}

	/* compression */
	if ((pol->pol_flags & IKED_POLICY_IPCOMP) &&
	    (len = ikev2_add_ipcompnotify(env, e, &pld, len, sa)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_SA) == -1)
		goto done;

	/* SA payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_proposals(env, sa, e, &pol->pol_proposals, 0,
	    sa->sa_hdr.sh_initiator, 0)) == -1)
		goto done;

	if ((len = ikev2_add_ts(e, &pld, len, sa, 0)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_IKE_AUTH, firstpayload, 0);

 done:
	ibuf_release(e);

	return (ret);
}

int
ikev2_init_done(struct iked *env, struct iked_sa *sa)
{
	int		 ret;

	if (!sa_stateok(sa, IKEV2_STATE_VALID))
		return (0);	/* ignored */

	ret = ikev2_childsa_negotiate(env, sa, &sa->sa_kex, &sa->sa_proposals,
	    sa->sa_hdr.sh_initiator, 0, 0);
	if (ret == 0)
		ret = ikev2_childsa_enable(env, sa);
	if (ret == 0) {
		sa_state(env, sa, IKEV2_STATE_ESTABLISHED);
		/* Delete exchange timeout. */
		timer_del(env, &sa->sa_timer);
		timer_set(env, &sa->sa_timer, ikev2_ike_sa_alive, sa);
		timer_add(env, &sa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
		timer_set(env, &sa->sa_keepalive, ikev2_ike_sa_keepalive, sa);
		if (sa->sa_usekeepalive)
			timer_add(env, &sa->sa_keepalive,
			    IKED_IKE_SA_KEEPALIVE_TIMEOUT);
		timer_set(env, &sa->sa_rekey, ikev2_ike_sa_rekey, sa);
		if (sa->sa_policy->pol_rekey)
			ikev2_ike_sa_rekey_schedule(env, sa);
	}

	if (ret)
		ikev2_childsa_delete(env, sa, 0, 0, NULL, 1);
	return (ret);
}

int
ikev2_policy2id(struct iked_static_id *polid, struct iked_id *id, int srcid)
{
	struct ikev2_id		 hdr;
	struct iked_static_id	 localpid;
	char			 idstr[IKED_ID_SIZE];
	struct in_addr		 in4;
	struct in6_addr		 in6;
	X509_NAME		*name = NULL;
	uint8_t			*p;
	int			 len;

	/* Fixup the local Id if not specified */
	if (srcid && polid->id_type == 0) {
		polid = &localpid;
		bzero(polid, sizeof(*polid));

		/* Create a default local ID based on our FQDN */
		polid->id_type = IKEV2_ID_FQDN;
		if (gethostname((char *)polid->id_data,
		    sizeof(polid->id_data)) != 0)
			return (-1);
		polid->id_offset = 0;
		polid->id_length =
		    strlen((char *)polid->id_data); /* excluding NUL */
	}

	if (!polid->id_length)
		return (-1);

	/* Create an IKEv2 ID payload */
	bzero(&hdr, sizeof(hdr));
	hdr.id_type = id->id_type = polid->id_type;
	id->id_offset = sizeof(hdr);

	if ((id->id_buf = ibuf_new(&hdr, sizeof(hdr))) == NULL)
		return (-1);

	switch (id->id_type) {
	case IKEV2_ID_IPV4:
		if (inet_pton(AF_INET, (char *)polid->id_data, &in4) != 1 ||
		    ibuf_add(id->id_buf, &in4, sizeof(in4)) != 0) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			return (-1);
		}
		break;
	case IKEV2_ID_IPV6:
		if (inet_pton(AF_INET6, (char *)polid->id_data, &in6) != 1 ||
		    ibuf_add(id->id_buf, &in6, sizeof(in6)) != 0) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			return (-1);
		}
		break;
	case IKEV2_ID_ASN1_DN:
		/* policy has ID in string-format, convert to ASN1 */
		if ((name = ca_x509_name_parse(polid->id_data)) == NULL ||
		    (len = i2d_X509_NAME(name, NULL)) < 0 ||
		    (p = ibuf_reserve(id->id_buf, len)) == NULL ||
		    (i2d_X509_NAME(name, &p)) < 0) {
			if (name)
				X509_NAME_free(name);
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			return (-1);
		}
		X509_NAME_free(name);
		break;
	default:
		if (ibuf_add(id->id_buf,
		    polid->id_data, polid->id_length) != 0) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			return (-1);
		}
		break;
	}

	if (ikev2_print_id(id, idstr, sizeof(idstr)) == -1)
		return (-1);

	log_debug("%s: %s %s length %zu", __func__,
	    srcid ? "srcid" : "dstid",
	    idstr, ibuf_size(id->id_buf));

	return (0);
}

struct ike_header *
ikev2_add_header(struct ibuf *buf, struct iked_sa *sa,
    uint32_t msgid, uint8_t nextpayload,
    uint8_t exchange, uint8_t flags)
{
	struct ike_header	*hdr;

	if ((hdr = ibuf_advance(buf, sizeof(*hdr))) == NULL) {
		log_debug("%s: failed to add header", __func__);
		return (NULL);
	}

	hdr->ike_ispi = htobe64(sa->sa_hdr.sh_ispi);
	hdr->ike_rspi = htobe64(sa->sa_hdr.sh_rspi);
	hdr->ike_nextpayload = nextpayload;
	hdr->ike_version = IKEV2_VERSION;
	hdr->ike_exchange = exchange;
	hdr->ike_msgid = htobe32(msgid);
	hdr->ike_length = htobe32(sizeof(*hdr));
	hdr->ike_flags = flags;

	if (sa->sa_hdr.sh_initiator)
		hdr->ike_flags |= IKEV2_FLAG_INITIATOR;

	return (hdr);
}

int
ikev2_set_header(struct ike_header *hdr, size_t length)
{
	uint32_t	 hdrlength = sizeof(*hdr) + length;

	if (hdrlength > UINT32_MAX) {
		log_debug("%s: message too long", __func__);
		return (-1);
	}

	hdr->ike_length = htobe32(sizeof(*hdr) + length);

	return (0);
}

struct ikev2_payload *
ikev2_add_payload(struct ibuf *buf)
{
	struct ikev2_payload	*pld;

	if ((pld = ibuf_advance(buf, sizeof(*pld))) == NULL) {
		log_debug("%s: failed to add payload", __func__);
		return (NULL);
	}

	pld->pld_nextpayload = IKEV2_PAYLOAD_NONE;
	pld->pld_length = sizeof(*pld);

	return (pld);
}

ssize_t
ikev2_add_ts_payload(struct ibuf *buf, unsigned int type, struct iked_sa *sa)
{
	struct iked_policy	*pol = sa->sa_policy;
	struct ikev2_tsp	*tsp;
	struct ikev2_ts		*ts;
	struct iked_flow	*flow;
	struct iked_addr	*addr;
	struct iked_addr	 pooladdr;
	uint8_t			*ptr;
	size_t			 len = 0;
	uint32_t		 av[4], bv[4], mv[4];
	struct sockaddr_in	*in4;
	struct sockaddr_in6	*in6;

	if ((tsp = ibuf_advance(buf, sizeof(*tsp))) == NULL)
		return (-1);
	tsp->tsp_count = pol->pol_nflows;
	len = sizeof(*tsp);

	RB_FOREACH(flow, iked_flows, &pol->pol_flows) {
		if ((ts = ibuf_advance(buf, sizeof(*ts))) == NULL)
			return (-1);

		if (type == IKEV2_PAYLOAD_TSi) {
			if (sa->sa_hdr.sh_initiator)
				addr = &flow->flow_src;
			else
				addr = &flow->flow_dst;
		} else if (type == IKEV2_PAYLOAD_TSr) {
			if (sa->sa_hdr.sh_initiator)
				addr = &flow->flow_dst;
			else
				addr = &flow->flow_src;
		} else
			return (-1);

		/* patch remote address (if configured to 0.0.0.0) */
		if ((type == IKEV2_PAYLOAD_TSi && !sa->sa_hdr.sh_initiator) ||
		    (type == IKEV2_PAYLOAD_TSr && sa->sa_hdr.sh_initiator)) {
			if (ikev2_cp_fixaddr(sa, addr, &pooladdr) != -1)
				addr = &pooladdr;
		}

		ts->ts_protoid = flow->flow_ipproto;

		if (addr->addr_port) {
			ts->ts_startport = addr->addr_port;
			ts->ts_endport = addr->addr_port;
		} else {
			ts->ts_startport = 0;
			ts->ts_endport = 0xffff;
		}

		switch (addr->addr_af) {
		case AF_INET:
			ts->ts_type = IKEV2_TS_IPV4_ADDR_RANGE;
			ts->ts_length = htobe16(sizeof(*ts) + 8);

			if ((ptr = ibuf_advance(buf, 8)) == NULL)
				return (-1);

			in4 = (struct sockaddr_in *)&addr->addr;
			if (addr->addr_net) {
				/* Convert IPv4 network to address range */
				mv[0] = prefixlen2mask(addr->addr_mask);
				av[0] = in4->sin_addr.s_addr & mv[0];
				bv[0] = in4->sin_addr.s_addr | ~mv[0];
			} else
				av[0] = bv[0] = in4->sin_addr.s_addr;

			memcpy(ptr, &av[0], 4);
			memcpy(ptr + 4, &bv[0], 4);
			break;
		case AF_INET6:
			ts->ts_type = IKEV2_TS_IPV6_ADDR_RANGE;
			ts->ts_length = htobe16(sizeof(*ts) + 32);

			if ((ptr = ibuf_advance(buf, 32)) == NULL)
				return (-1);

			in6 = (struct sockaddr_in6 *)&addr->addr;

			memcpy(&av, &in6->sin6_addr.s6_addr, 16);
			memcpy(&bv, &in6->sin6_addr.s6_addr, 16);
			if (addr->addr_net) {
				/* Convert IPv6 network to address range */
				prefixlen2mask6(addr->addr_mask, mv);
				av[0] &= mv[0];
				av[1] &= mv[1];
				av[2] &= mv[2];
				av[3] &= mv[3];
				bv[0] |= ~mv[0];
				bv[1] |= ~mv[1];
				bv[2] |= ~mv[2];
				bv[3] |= ~mv[3];
			}

			memcpy(ptr, &av, 16);
			memcpy(ptr + 16, &bv, 16);
			break;
		}

		len += betoh16(ts->ts_length);
	}

	return (len);
}

ssize_t
ikev2_add_ts(struct ibuf *e, struct ikev2_payload **pld, ssize_t len,
    struct iked_sa *sa, int reverse)
{
	if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_TSi) == -1)
		return (-1);

	/* TSi payload */
	if ((*pld = ikev2_add_payload(e)) == NULL)
		return (-1);
	if ((len = ikev2_add_ts_payload(e, reverse ? IKEV2_PAYLOAD_TSr :
	    IKEV2_PAYLOAD_TSi, sa)) == -1)
		return (-1);

	if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_TSr) == -1)
		return (-1);

	/* TSr payload */
	if ((*pld = ikev2_add_payload(e)) == NULL)
		return (-1);
	if ((len = ikev2_add_ts_payload(e, reverse ? IKEV2_PAYLOAD_TSi :
	    IKEV2_PAYLOAD_TSr, sa)) == -1)
		return (-1);

	return (len);
}


ssize_t
ikev2_add_certreq(struct ibuf *e, struct ikev2_payload **pld, ssize_t len,
    struct ibuf *certreq, uint8_t type)
{
	struct ikev2_cert	*cert;

	if (type == IKEV2_CERT_NONE)
		return (len);

	if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_CERTREQ) == -1)
		return (-1);

	/* CERTREQ payload */
	if ((*pld = ikev2_add_payload(e)) == NULL)
		return (-1);

	if ((cert = ibuf_advance(e, sizeof(*cert))) == NULL)
		return (-1);

	cert->cert_type = type;
	len = sizeof(*cert);

	if (certreq != NULL && cert->cert_type == IKEV2_CERT_X509_CERT) {
		if (ikev2_add_buf(e, certreq) == -1)
			return (-1);
		len += ibuf_size(certreq);
	}

	log_debug("%s: type %s length %zd", __func__,
	    print_map(type, ikev2_cert_map), len);

	return (len);
}

ssize_t
ikev2_add_ipcompnotify(struct iked *env, struct ibuf *e,
    struct ikev2_payload **pld, ssize_t len, struct iked_sa *sa)
{
	struct iked_childsa		 csa;
	struct ikev2_notify		*n;
	uint8_t				*ptr;
	uint16_t			 cpi;
	uint32_t			 spi;
	uint8_t				 transform;

	/* we only support deflate */
	transform = IKEV2_IPCOMP_DEFLATE;

	bzero(&csa, sizeof(csa));
	csa.csa_saproto = IKEV2_SAPROTO_IPCOMP;
	csa.csa_ikesa = sa;
	csa.csa_local = &sa->sa_peer;
	csa.csa_peer = &sa->sa_local;

	if (pfkey_sa_init(env->sc_pfkey, &csa, &spi) == -1)
		return (-1);
	/*
	 * We get spi == 0 if the kernel does not support IPcomp,
	 * so just return the length of the current payload.
	 */
	if (spi == 0)
		return (len);
	cpi = htobe16((uint16_t)spi);
	if (*pld)
		if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
			return (-1);
	if ((*pld = ikev2_add_payload(e)) == NULL)
		return (-1);
	len = sizeof(*n) + sizeof(cpi) + sizeof(transform);
	if ((ptr = ibuf_advance(e, len)) == NULL)
		return (-1);
	n = (struct ikev2_notify *)ptr;
	n->n_protoid = 0;
	n->n_spisize = 0;
	n->n_type = htobe16(IKEV2_N_IPCOMP_SUPPORTED);
	ptr += sizeof(*n);
	memcpy(ptr, &cpi, sizeof(cpi));
	ptr += sizeof(cpi);
	memcpy(ptr, &transform, sizeof(transform));

	sa->sa_cpi_in = spi;	/* already on host byte order */
	log_debug("%s: sa_cpi_in 0x%04x", __func__, sa->sa_cpi_in);

	return (len);
}

ssize_t
ikev2_add_sighashnotify(struct ibuf *e, struct ikev2_payload **pld,
    ssize_t len)
{
	struct ikev2_notify		*n;
	uint8_t				*ptr;
	size_t				 i;
	uint16_t			 hash, signature_hashes[] = {
		IKEV2_SIGHASH_SHA2_256,
		IKEV2_SIGHASH_SHA2_384,
		IKEV2_SIGHASH_SHA2_512
	};

	if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
		return (-1);

	/* XXX signature_hashes are hardcoded for now */
	len = sizeof(*n) + nitems(signature_hashes) * sizeof(hash);

	/* NOTIFY payload */
	if ((*pld = ikev2_add_payload(e)) == NULL)
		return (-1);
	if ((ptr = ibuf_advance(e, len)) == NULL)
		return (-1);

	n = (struct ikev2_notify *)ptr;
	n->n_protoid = 0;
	n->n_spisize = 0;
	n->n_type = htobe16(IKEV2_N_SIGNATURE_HASH_ALGORITHMS);
	ptr += sizeof(*n);

	for (i = 0; i < nitems(signature_hashes); i++) {
		hash = htobe16(signature_hashes[i]);
		memcpy(ptr, &hash, sizeof(hash));
		ptr += sizeof(hash);
	}

	return (len);
}

int
ikev2_next_payload(struct ikev2_payload *pld, size_t length,
    uint8_t nextpayload)
{
	size_t	 pldlength = sizeof(*pld) + length;

	if (pldlength > UINT16_MAX) {
		log_debug("%s: payload too long", __func__);
		return (-1);
	}

	log_debug("%s: length %zu nextpayload %s",
	    __func__, pldlength, print_map(nextpayload, ikev2_payload_map));

	pld->pld_length = htobe16(pldlength);
	pld->pld_nextpayload = nextpayload;

	return (0);
}

ssize_t
ikev2_nat_detection(struct iked *env, struct iked_message *msg,
    void *ptr, size_t len, unsigned int type)
{
	EVP_MD_CTX		 ctx;
	struct ike_header	*hdr;
	uint8_t			 md[SHA_DIGEST_LENGTH];
	unsigned int		 mdlen = sizeof(md);
	struct iked_sa		*sa = msg->msg_sa;
	struct sockaddr_in	*in4;
	struct sockaddr_in6	*in6;
	ssize_t			 ret = -1;
	struct sockaddr		*src, *dst, *ss;
	uint64_t		 rspi, ispi;
	struct ibuf		*buf;
	int			 frompeer = 0;
	uint32_t		 rnd;

	if (ptr == NULL)
		return (mdlen);

	if (ikev2_msg_frompeer(msg)) {
		buf = msg->msg_parent->msg_data;
		if ((hdr = ibuf_seek(buf, 0, sizeof(*hdr))) == NULL)
			return (-1);
		ispi = hdr->ike_ispi;
		rspi = hdr->ike_rspi;
		frompeer = 1;
		src = (struct sockaddr *)&msg->msg_peer;
		dst = (struct sockaddr *)&msg->msg_local;
	} else {
		ispi = htobe64(sa->sa_hdr.sh_ispi);
		rspi = htobe64(sa->sa_hdr.sh_rspi);
		frompeer = 0;
		src = (struct sockaddr *)&msg->msg_local;
		dst = (struct sockaddr *)&msg->msg_peer;
	}

	EVP_MD_CTX_init(&ctx);
	EVP_DigestInit_ex(&ctx, EVP_sha1(), NULL);

	switch (type) {
	case IKEV2_N_NAT_DETECTION_SOURCE_IP:
		log_debug("%s: %s source %s %s %s", __func__,
		    frompeer ? "peer" : "local",
		    print_spi(betoh64(ispi), 8),
		    print_spi(betoh64(rspi), 8),
		    print_host(src, NULL, 0));
		ss = src;
		break;
	case IKEV2_N_NAT_DETECTION_DESTINATION_IP:
		log_debug("%s: %s destination %s %s %s", __func__,
		    frompeer ? "peer" : "local",
		    print_spi(betoh64(ispi), 8),
		    print_spi(betoh64(rspi), 8),
		    print_host(dst, NULL, 0));
		ss = dst;
		break;
	default:
		goto done;
	}

	EVP_DigestUpdate(&ctx, &ispi, sizeof(ispi));
	EVP_DigestUpdate(&ctx, &rspi, sizeof(rspi));

	switch (ss->sa_family) {
	case AF_INET:
		in4 = (struct sockaddr_in *)ss;
		EVP_DigestUpdate(&ctx, &in4->sin_addr.s_addr,
		    sizeof(in4->sin_addr.s_addr));
		EVP_DigestUpdate(&ctx, &in4->sin_port,
		    sizeof(in4->sin_port));
		break;
	case AF_INET6:
		in6 = (struct sockaddr_in6 *)ss;
		EVP_DigestUpdate(&ctx, &in6->sin6_addr.s6_addr,
		    sizeof(in6->sin6_addr.s6_addr));
		EVP_DigestUpdate(&ctx, &in6->sin6_port,
		    sizeof(in6->sin6_port));
		break;
	default:
		goto done;
	}

	if (env->sc_opts & IKED_OPT_NATT) {
		/* Enforce NAT-T/UDP-encapsulation by distorting the digest */
		rnd = arc4random();
		EVP_DigestUpdate(&ctx, &rnd, sizeof(rnd));
	}

	EVP_DigestFinal_ex(&ctx, md, &mdlen);

	if (len < mdlen)
		goto done;

	memcpy(ptr, md, mdlen);
	ret = mdlen;
 done:
	EVP_MD_CTX_cleanup(&ctx);

	return (ret);
}

ssize_t
ikev2_add_nat_detection(struct iked *env, struct ibuf *buf,
    struct ikev2_payload **pld, struct iked_message *msg, ssize_t len)
{
	struct ikev2_notify		*n;
	uint8_t			*ptr;

	/* *pld is NULL if there is no previous payload */
	if (*pld != NULL) {
		if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
			return (-1);
	}
	/* NAT-T notify payloads */
	if ((*pld = ikev2_add_payload(buf)) == NULL)
		return (-1);
	if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
		return (-1);
	n->n_type = htobe16(IKEV2_N_NAT_DETECTION_SOURCE_IP);
	len = ikev2_nat_detection(env, msg, NULL, 0, 0);
	if ((ptr = ibuf_advance(buf, len)) == NULL)
		return (-1);
	if ((len = ikev2_nat_detection(env, msg, ptr, len,
	    betoh16(n->n_type))) == -1)
		return (-1);
	len += sizeof(*n);

	if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
		return (-1);

	if ((*pld = ikev2_add_payload(buf)) == NULL)
		return (-1);
	if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
		return (-1);
	n->n_type = htobe16(IKEV2_N_NAT_DETECTION_DESTINATION_IP);
	len = ikev2_nat_detection(env, msg, NULL, 0, 0);
	if ((ptr = ibuf_advance(buf, len)) == NULL)
		return (-1);
	if ((len = ikev2_nat_detection(env, msg, ptr, len,
	    betoh16(n->n_type))) == -1)
		return (-1);
	len += sizeof(*n);
	return (len);
}

ssize_t
ikev2_add_cp(struct iked *env, struct iked_sa *sa, struct ibuf *buf)
{
	struct iked_policy	*pol = sa->sa_policy;
	struct ikev2_cp		*cp;
	struct ikev2_cfg	*cfg;
	struct iked_cfg		*ikecfg;
	unsigned int		 i;
	uint32_t		 mask4;
	size_t			 len;
	struct sockaddr_in	*in4;
	struct sockaddr_in6	*in6;
	uint8_t			 prefixlen;

	if ((cp = ibuf_advance(buf, sizeof(*cp))) == NULL)
		return (-1);
	len = sizeof(*cp);

	switch (sa->sa_cp) {
	case IKEV2_CP_REQUEST:
		cp->cp_type = IKEV2_CP_REPLY;
		break;
	case IKEV2_CP_REPLY:
	case IKEV2_CP_SET:
	case IKEV2_CP_ACK:
		/* Not yet supported */
		return (-1);
	}

	for (i = 0; i < pol->pol_ncfg; i++) {
		ikecfg = &pol->pol_cfg[i];
		if (ikecfg->cfg_action != cp->cp_type)
			continue;

		if ((cfg = ibuf_advance(buf, sizeof(*cfg))) == NULL)
			return (-1);

		cfg->cfg_type = htobe16(ikecfg->cfg_type);
		len += sizeof(*cfg);

		switch (ikecfg->cfg_type) {
		case IKEV2_CFG_INTERNAL_IP4_ADDRESS:
		case IKEV2_CFG_INTERNAL_IP4_NETMASK:
		case IKEV2_CFG_INTERNAL_IP4_DNS:
		case IKEV2_CFG_INTERNAL_IP4_NBNS:
		case IKEV2_CFG_INTERNAL_IP4_DHCP:
		case IKEV2_CFG_INTERNAL_IP4_SERVER:
			/* 4 bytes IPv4 address */
			in4 = (ikecfg->cfg.address.addr_mask != 32 &&
			    (ikecfg->cfg_type ==
			    IKEV2_CFG_INTERNAL_IP4_ADDRESS) &&
			    sa->sa_addrpool &&
			    sa->sa_addrpool->addr_af == AF_INET) ?
			    (struct sockaddr_in *)&sa->sa_addrpool->addr :
			    (struct sockaddr_in *)&ikecfg->cfg.address.addr;
			cfg->cfg_length = htobe16(4);
			if (ibuf_add(buf, &in4->sin_addr.s_addr, 4) == -1)
				return (-1);
			len += 4;
			break;
		case IKEV2_CFG_INTERNAL_IP4_SUBNET:
			/* 4 bytes IPv4 address + 4 bytes IPv4 mask + */
			in4 = (struct sockaddr_in *)&ikecfg->cfg.address.addr;
			mask4 = prefixlen2mask(ikecfg->cfg.address.addr_mask);
			cfg->cfg_length = htobe16(8);
			if (ibuf_add(buf, &in4->sin_addr.s_addr, 4) == -1)
				return (-1);
			if (ibuf_add(buf, &mask4, 4) == -1)
				return (-1);
			len += 8;
			break;
		case IKEV2_CFG_INTERNAL_IP6_DNS:
		case IKEV2_CFG_INTERNAL_IP6_NBNS:
		case IKEV2_CFG_INTERNAL_IP6_DHCP:
		case IKEV2_CFG_INTERNAL_IP6_SERVER:
			/* 16 bytes IPv6 address */
			in6 = (struct sockaddr_in6 *)&ikecfg->cfg.address;
			cfg->cfg_length = htobe16(16);
			if (ibuf_add(buf, &in6->sin6_addr.s6_addr, 16) == -1)
				return (-1);
			len += 16;
			break;
		case IKEV2_CFG_INTERNAL_IP6_ADDRESS:
		case IKEV2_CFG_INTERNAL_IP6_SUBNET:
			/* 16 bytes IPv6 address + 1 byte prefix length */
			in6 = (ikecfg->cfg.address.addr_mask != 128 &&
			    (ikecfg->cfg_type ==
			    IKEV2_CFG_INTERNAL_IP6_ADDRESS) &&
			    sa->sa_addrpool6 &&
			    sa->sa_addrpool6->addr_af == AF_INET6) ?
			    (struct sockaddr_in6 *)&sa->sa_addrpool6->addr :
			    (struct sockaddr_in6 *)&ikecfg->cfg.address.addr;
			cfg->cfg_length = htobe16(17);
			if (ibuf_add(buf, &in6->sin6_addr.s6_addr, 16) == -1)
				return (-1);
			if (ikecfg->cfg.address.addr_net)
				prefixlen = ikecfg->cfg.address.addr_mask;
			else
				prefixlen = 128;
			if (ibuf_add(buf, &prefixlen, 1) == -1)
				return (-1);
			len += 16 + 1;
			break;
		case IKEV2_CFG_APPLICATION_VERSION:
			/* Reply with an empty string (non-NUL terminated) */
			cfg->cfg_length = 0;
			break;
		}
	}

	return (len);
}

ssize_t
ikev2_add_proposals(struct iked *env, struct iked_sa *sa, struct ibuf *buf,
    struct iked_proposals *proposals, uint8_t protoid, int initiator,
    int sendikespi)
{
	struct ikev2_sa_proposal	*sap;
	struct iked_transform		*xform;
	struct iked_proposal		*prop;
	struct iked_childsa		 csa;
	ssize_t				 length = 0, saplength, xflen;
	uint64_t			 spi64;
	uint32_t			 spi32, spi;
	unsigned int			 i;

	TAILQ_FOREACH(prop, proposals, prop_entry) {
		if ((protoid && prop->prop_protoid != protoid) ||
		    (!protoid && prop->prop_protoid == IKEV2_SAPROTO_IKE))
			continue;

		if (protoid != IKEV2_SAPROTO_IKE && initiator) {
			bzero(&csa, sizeof(csa));
			csa.csa_ikesa = sa;
			csa.csa_saproto = prop->prop_protoid;
			csa.csa_local = &sa->sa_peer;
			csa.csa_peer = &sa->sa_local;

			if (pfkey_sa_init(env->sc_pfkey, &csa, &spi) == -1)
				return (-1);

			prop->prop_localspi.spi = spi;
			prop->prop_localspi.spi_size = 4;
			prop->prop_localspi.spi_protoid = prop->prop_protoid;
		}

		if ((sap = ibuf_advance(buf, sizeof(*sap))) == NULL) {
			log_debug("%s: failed to add proposal", __func__);
			return (-1);
		}

		if (sendikespi) {
			/* Special case for IKE SA rekeying */
			prop->prop_localspi.spi = initiator ?
			    sa->sa_hdr.sh_ispi : sa->sa_hdr.sh_rspi;
			prop->prop_localspi.spi_size = 8;
			prop->prop_localspi.spi_protoid = IKEV2_SAPROTO_IKE;
		}

		sap->sap_proposalnr = prop->prop_id;
		sap->sap_protoid = prop->prop_protoid;
		sap->sap_spisize = prop->prop_localspi.spi_size;
		sap->sap_transforms = prop->prop_nxforms;
		saplength = sizeof(*sap);

		switch (prop->prop_localspi.spi_size) {
		case 4:
			spi32 = htobe32(prop->prop_localspi.spi);
			if (ibuf_add(buf, &spi32, sizeof(spi32)) != 0)
				return (-1);
			saplength += 4;
			break;
		case 8:
			spi64 = htobe64(prop->prop_localspi.spi);
			if (ibuf_add(buf, &spi64, sizeof(spi64)) != 0)
				return (-1);
			saplength += 8;
			break;
		default:
			break;
		}

		for (i = 0; i < prop->prop_nxforms; i++) {
			xform = prop->prop_xforms + i;

			if ((xflen = ikev2_add_transform(buf,
			    i == prop->prop_nxforms - 1 ?
			    IKEV2_XFORM_LAST : IKEV2_XFORM_MORE,
			    xform->xform_type, xform->xform_id,
			    xform->xform_length)) == -1)
				return (-1);

			saplength += xflen;
		}

		sap->sap_length = htobe16(saplength);
		length += saplength;
	}

	log_debug("%s: length %zd", __func__, length);

	return (length);
}

ssize_t
ikev2_add_transform(struct ibuf *buf,
    uint8_t more, uint8_t type, uint16_t id, uint16_t length)
{
	struct ikev2_transform	*xfrm;
	struct ikev2_attribute	*attr;

	if ((xfrm = ibuf_advance(buf, sizeof(*xfrm))) == NULL) {
		log_debug("%s: failed to add transform", __func__);
		return (-1);
	}
	xfrm->xfrm_more = more;
	xfrm->xfrm_type = type;
	xfrm->xfrm_id = htobe16(id);

	if (length) {
		xfrm->xfrm_length = htobe16(sizeof(*xfrm) + sizeof(*attr));

		if ((attr = ibuf_advance(buf, sizeof(*attr))) == NULL) {
			log_debug("%s: failed to add attribute", __func__);
			return (-1);
		}
		attr->attr_type = htobe16(IKEV2_ATTRAF_TV |
		    IKEV2_ATTRTYPE_KEY_LENGTH);
		attr->attr_length = htobe16(length);
	} else
		xfrm->xfrm_length = htobe16(sizeof(*xfrm));

	return (betoh16(xfrm->xfrm_length));
}

int
ikev2_add_data(struct ibuf *buf, void *data, size_t length)
{
	void	*msgbuf;

	if ((msgbuf = ibuf_advance(buf, length)) == NULL) {
		log_debug("%s: failed", __func__);
		return (-1);
	}
	memcpy(msgbuf, data, length);

	return (0);
}

int
ikev2_add_buf(struct ibuf *buf, struct ibuf *data)
{
	void	*msgbuf;

	if ((msgbuf = ibuf_advance(buf, ibuf_size(data))) == NULL) {
		log_debug("%s: failed", __func__);
		return (-1);
	}
	memcpy(msgbuf, ibuf_data(data), ibuf_size(data));

	return (0);
}

void
ikev2_resp_recv(struct iked *env, struct iked_message *msg,
    struct ike_header *hdr)
{
	struct iked_sa		*sa;

	switch (hdr->ike_exchange) {
	case IKEV2_EXCHANGE_IKE_SA_INIT:
		if (msg->msg_sa != NULL) {
			log_debug("%s: SA already exists", __func__);
			return;
		}
		if ((msg->msg_sa = sa_new(env,
		    betoh64(hdr->ike_ispi), betoh64(hdr->ike_rspi),
		    0, msg->msg_policy)) == NULL) {
			log_debug("%s: failed to get new SA", __func__);
			return;
		}
		/* Setup exchange timeout. */
		timer_set(env, &msg->msg_sa->sa_timer,
		    ikev2_init_ike_sa_timeout, msg->msg_sa);
		timer_add(env, &msg->msg_sa->sa_timer,
		    IKED_IKE_SA_EXCHANGE_TIMEOUT);
		break;
	case IKEV2_EXCHANGE_IKE_AUTH:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		if (sa_stateok(msg->msg_sa, IKEV2_STATE_VALID)) {
			log_debug("%s: already authenticated", __func__);
			return;
		}
		break;
	case IKEV2_EXCHANGE_CREATE_CHILD_SA:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		break;
	case IKEV2_EXCHANGE_INFORMATIONAL:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		break;
	default:
		log_debug("%s: unsupported exchange: %s", __func__,
		    print_map(hdr->ike_exchange, ikev2_exchange_map));
		return;
	}

	if (ikev2_pld_parse(env, hdr, msg, msg->msg_offset) != 0) {
		log_debug("%s: failed to parse message", __func__);
		return;
	}

	if (!ikev2_msg_frompeer(msg))
		return;

	if ((sa = msg->msg_sa) == NULL)
		return;

	if (msg->msg_natt && sa->sa_natt == 0) {
		log_debug("%s: NAT-T message received, updated SA", __func__);
		sa->sa_natt = 1;
	}

	switch (hdr->ike_exchange) {
	case IKEV2_EXCHANGE_IKE_SA_INIT:
		if (ikev2_sa_responder(env, sa, NULL, msg) != 0) {
			log_debug("%s: failed to get IKE SA keys", __func__);
			sa_state(env, sa, IKEV2_STATE_CLOSED);
			return;
		}
		if (ikev2_resp_ike_sa_init(env, msg) != 0) {
			log_debug("%s: failed to send init response", __func__);
			sa_state(env, sa, IKEV2_STATE_CLOSED);
			return;
		}
		break;
	case IKEV2_EXCHANGE_IKE_AUTH:
		if (!sa_stateok(sa, IKEV2_STATE_SA_INIT)) {
			log_debug("%s: state mismatch", __func__);
			sa_state(env, sa, IKEV2_STATE_CLOSED);
			return;
		}

		if (!sa_stateok(sa, IKEV2_STATE_AUTH_REQUEST) &&
		    sa->sa_policy->pol_auth.auth_eap)
			sa_state(env, sa, IKEV2_STATE_EAP);

		if (ikev2_ike_auth_recv(env, sa, msg) != 0) {
			log_debug("%s: failed to send auth response", __func__);
			sa_state(env, sa, IKEV2_STATE_CLOSED);
			return;
		}
		break;
	case IKEV2_EXCHANGE_CREATE_CHILD_SA:
		if (ikev2_resp_create_child_sa(env, msg) != 0)
			ikev2_send_error(env, sa, msg, hdr->ike_exchange);
		break;
	case IKEV2_EXCHANGE_INFORMATIONAL:
		if (sa_stateok(sa, IKEV2_STATE_AUTH_REQUEST) &&
		    !msg->msg_responded && !msg->msg_error) {
			(void)ikev2_send_ike_e(env, sa, NULL,
			    IKEV2_PAYLOAD_NONE, IKEV2_EXCHANGE_INFORMATIONAL,
			    1);
			msg->msg_responded = 1;
		}
		break;
	default:
		break;
	}
}

int
ikev2_resp_ike_sa_init(struct iked *env, struct iked_message *msg)
{
	struct iked_message		 resp;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ikev2_keyexchange	*ke;
	struct iked_sa			*sa = msg->msg_sa;
	struct ibuf			*buf;
	struct group			*group;
	ssize_t				 len;
	int				 ret = -1;

	if (sa->sa_hdr.sh_initiator) {
		log_debug("%s: called by initiator", __func__);
		return (-1);
	}

	if ((buf = ikev2_msg_init(env, &resp,
	    &msg->msg_peer, msg->msg_peerlen,
	    &msg->msg_local, msg->msg_locallen, 1)) == NULL)
		goto done;

	resp.msg_sa = sa;
	resp.msg_fd = msg->msg_fd;
	resp.msg_natt = msg->msg_natt;
	resp.msg_msgid = 0;

	/* IKE header */
	if ((hdr = ikev2_add_header(buf, sa, resp.msg_msgid,
	    IKEV2_PAYLOAD_SA, IKEV2_EXCHANGE_IKE_SA_INIT,
	    IKEV2_FLAG_RESPONSE)) == NULL)
		goto done;

	/* SA payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if ((len = ikev2_add_proposals(env, sa, buf, &sa->sa_proposals,
	    IKEV2_SAPROTO_IKE, sa->sa_hdr.sh_initiator, 0)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_KE) == -1)
		goto done;

	/* KE payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if ((ke = ibuf_advance(buf, sizeof(*ke))) == NULL)
		goto done;
	if ((group = sa->sa_dhgroup) == NULL) {
		log_debug("%s: invalid dh", __func__);
		goto done;
	}
	ke->kex_dhgroup = htobe16(group->id);
	if (ikev2_add_buf(buf, sa->sa_dhrexchange) == -1)
		goto done;
	len = sizeof(*ke) + dh_getlen(group);

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONCE) == -1)
		goto done;

	/* NONCE payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if (ikev2_add_buf(buf, sa->sa_rnonce) == -1)
		goto done;
	len = ibuf_size(sa->sa_rnonce);

	if ((env->sc_opts & IKED_OPT_NONATT) == 0 &&
	    msg->msg_local.ss_family != AF_UNSPEC) {
		if ((len = ikev2_add_nat_detection(env, buf, &pld, &resp, len))
		    == -1)
			goto done;
	}
	if (sa->sa_statevalid & IKED_REQ_CERT) {
		/* CERTREQ payload(s) */
		if ((len = ikev2_add_certreq(buf, &pld,
		    len, env->sc_certreq, env->sc_certreqtype)) == -1)
			goto done;

		if (env->sc_certreqtype != sa->sa_policy->pol_certreqtype &&
		    (len = ikev2_add_certreq(buf, &pld,
		    len, NULL, sa->sa_policy->pol_certreqtype)) == -1)
			goto done;
	}

	if (sa->sa_sigsha2 &&
	    (len = ikev2_add_sighashnotify(buf, &pld, len)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
		goto done;

	(void)ikev2_pld_parse(env, hdr, &resp, 0);

	ibuf_release(sa->sa_2ndmsg);
	if ((sa->sa_2ndmsg = ibuf_dup(buf)) == NULL) {
		log_debug("%s: failed to copy 2nd message", __func__);
		goto done;
	}

	resp.msg_sa = NULL;	/* Don't save the response */
	ret = ikev2_msg_send(env, &resp);

 done:
	ikev2_msg_cleanup(env, &resp);

	return (ret);
}

int
ikev2_send_auth_failed(struct iked *env, struct iked_sa *sa)
{
	struct ikev2_notify		*n;
	struct ibuf			*buf = NULL;
	int				 ret = -1, exchange, response;

	/* Notify payload */
	if ((buf = ibuf_static()) == NULL)
		goto done;
	if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
		goto done;
	n->n_protoid = IKEV2_SAPROTO_IKE;
	n->n_spisize = 0;
	n->n_type = htobe16(IKEV2_N_AUTHENTICATION_FAILED);
	if (sa->sa_hdr.sh_initiator) {
		exchange = IKEV2_EXCHANGE_INFORMATIONAL;
		response = 0;
	} else {
		exchange = IKEV2_EXCHANGE_IKE_AUTH;
		response = 1;
	}
	ret = ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_NOTIFY,
	    exchange, response);
	if (exchange == IKEV2_EXCHANGE_INFORMATIONAL)
		sa->sa_stateflags |= IKED_REQ_INF;
 done:
	ibuf_release(buf);

	/* cleanup SA after timeout */
	sa_state(env, sa, IKEV2_STATE_CLOSING);
	timer_del(env, &sa->sa_timer);
	timer_set(env, &sa->sa_timer, ikev2_ike_sa_timeout, sa);
	timer_add(env, &sa->sa_timer, IKED_IKE_SA_DELETE_TIMEOUT);

	return (ret);
}

int
ikev2_send_error(struct iked *env, struct iked_sa *sa,
    struct iked_message *msg, uint8_t exchange)
{
	struct ikev2_notify		*n;
	struct ibuf			*buf = NULL;
	int				 ret = -1;

	switch (msg->msg_error) {
	case IKEV2_N_NO_PROPOSAL_CHOSEN:
		break;
	case 0:
		return (0);
	default:
		return (-1);
	}
	/* Notify payload */
	if ((buf = ibuf_static()) == NULL)
		goto done;
	if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
		goto done;
	n->n_protoid = 0;
	n->n_spisize = 0;
	n->n_type = htobe16(msg->msg_error);

	ret = ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_NOTIFY,
	    exchange, 1);
 done:
	ibuf_release(buf);
	return (ret);
}

int
ikev2_resp_ike_auth(struct iked *env, struct iked_sa *sa)
{
	struct ikev2_payload		*pld;
	struct ikev2_cert		*cert;
	struct ikev2_auth		*auth;
	struct iked_id			*id, *certid;
	struct ibuf			*e = NULL;
	uint8_t				 firstpayload;
	int				 ret = -1;
	ssize_t				 len;

	if (sa == NULL)
		return (-1);

	if (sa->sa_state == IKEV2_STATE_EAP)
		return (ikev2_resp_ike_eap(env, sa, NULL));

	if (!sa_stateok(sa, IKEV2_STATE_VALID))
		return (0);	/* ignore */

	if (ikev2_cp_setaddr(env, sa, AF_INET) < 0 ||
	    ikev2_cp_setaddr(env, sa, AF_INET6) < 0)
		return (-1);

	if (ikev2_childsa_negotiate(env, sa, &sa->sa_kex, &sa->sa_proposals,
	    sa->sa_hdr.sh_initiator, 0, 0) < 0)
		return (-1);

	/* New encrypted message buffer */
	if ((e = ibuf_static()) == NULL)
		goto done;

	if (!sa->sa_localauth.id_type) {
		/* Downgrade the state */
		sa_state(env, sa, IKEV2_STATE_AUTH_SUCCESS);
	}

	if (sa->sa_hdr.sh_initiator) {
		id = &sa->sa_iid;
		certid = &sa->sa_icert;
	} else {
		id = &sa->sa_rid;
		certid = &sa->sa_rcert;
	}

	if (sa->sa_state != IKEV2_STATE_EAP_VALID) {
		/* ID payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		firstpayload = IKEV2_PAYLOAD_IDr;
		if (ibuf_cat(e, id->id_buf) != 0)
			goto done;
		len = ibuf_size(id->id_buf);

		/* CERT payload */
		if ((sa->sa_statevalid & IKED_REQ_CERT) &&
		    (certid->id_type != IKEV2_CERT_NONE)) {
			if (ikev2_next_payload(pld, len,
			    IKEV2_PAYLOAD_CERT) == -1)
				goto done;

			if ((pld = ikev2_add_payload(e)) == NULL)
				goto done;
			if ((cert = ibuf_advance(e, sizeof(*cert))) == NULL)
				goto done;
			cert->cert_type = certid->id_type;
			if (ibuf_cat(e, certid->id_buf) != 0)
				goto done;
			len = ibuf_size(certid->id_buf) + sizeof(*cert);
		}

		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_AUTH) == -1)
			goto done;
	} else
		firstpayload = IKEV2_PAYLOAD_AUTH;

	/* AUTH payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((auth = ibuf_advance(e, sizeof(*auth))) == NULL)
		goto done;
	auth->auth_method = sa->sa_localauth.id_type;
	if (ibuf_cat(e, sa->sa_localauth.id_buf) != 0)
		goto done;
	len = ibuf_size(sa->sa_localauth.id_buf) + sizeof(*auth);

	/* CP payload */
	if (sa->sa_cp) {
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_CP) == -1)
			goto done;

		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((len = ikev2_add_cp(env, sa, e)) == -1)
			goto done;
	}

	/* compression */
	if (sa->sa_ipcomp &&
	    (len = ikev2_add_ipcompnotify(env, e, &pld, len, sa)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_SA) == -1)
		goto done;

	/* SA payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_proposals(env, sa, e, &sa->sa_proposals, 0,
	    sa->sa_hdr.sh_initiator, 0)) == -1)
		goto done;

	if ((len = ikev2_add_ts(e, &pld, len, sa, 0)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_IKE_AUTH, firstpayload, 1);
	if (ret == 0)
		ret = ikev2_childsa_enable(env, sa);
	if (ret == 0) {
		sa_state(env, sa, IKEV2_STATE_ESTABLISHED);
		/* Delete exchange timeout. */
		timer_del(env, &sa->sa_timer);
		timer_set(env, &sa->sa_timer, ikev2_ike_sa_alive, sa);
		timer_add(env, &sa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
		timer_set(env, &sa->sa_keepalive, ikev2_ike_sa_keepalive, sa);
		if (sa->sa_usekeepalive)
			timer_add(env, &sa->sa_keepalive,
			    IKED_IKE_SA_KEEPALIVE_TIMEOUT);
		timer_set(env, &sa->sa_rekey, ikev2_ike_sa_rekey, sa);
		if (sa->sa_policy->pol_rekey)
			ikev2_ike_sa_rekey_schedule(env, sa);
	}

 done:
	if (ret)
		ikev2_childsa_delete(env, sa, 0, 0, NULL, 1);
	ibuf_release(e);
	return (ret);
}

int
ikev2_resp_ike_eap(struct iked *env, struct iked_sa *sa, struct ibuf *eapmsg)
{
	struct ikev2_payload		*pld;
	struct ikev2_cert		*cert;
	struct ikev2_auth		*auth;
	struct iked_id			*id, *certid;
	struct ibuf			*e = NULL;
	uint8_t				 firstpayload;
	int				 ret = -1;
	ssize_t				 len = 0;

	/* Responder only */
	if (sa->sa_hdr.sh_initiator)
		return (-1);

	/* Check if "ca" has done it's job yet */
	if (!sa->sa_localauth.id_type)
		return (0);

	/* New encrypted message buffer */
	if ((e = ibuf_static()) == NULL)
		goto done;

	id = &sa->sa_rid;
	certid = &sa->sa_rcert;

	/* ID payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	firstpayload = IKEV2_PAYLOAD_IDr;
	if (ibuf_cat(e, id->id_buf) != 0)
		goto done;
	len = ibuf_size(id->id_buf);

	if ((sa->sa_statevalid & IKED_REQ_CERT) &&
	    (certid->id_type != IKEV2_CERT_NONE)) {
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_CERT) == -1)
			goto done;

		/* CERT payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((cert = ibuf_advance(e, sizeof(*cert))) == NULL)
			goto done;
		cert->cert_type = certid->id_type;
		if (ibuf_cat(e, certid->id_buf) != 0)
			goto done;
		len = ibuf_size(certid->id_buf) + sizeof(*cert);
	}

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_AUTH) == -1)
		goto done;

	/* AUTH payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((auth = ibuf_advance(e, sizeof(*auth))) == NULL)
		goto done;
	auth->auth_method = sa->sa_localauth.id_type;
	if (ibuf_cat(e, sa->sa_localauth.id_buf) != 0)
		goto done;
	len = ibuf_size(sa->sa_localauth.id_buf) + sizeof(*auth);

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_EAP) == -1)
		goto done;

	/* EAP payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = eap_identity_request(e)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_IKE_AUTH, firstpayload, 1);

 done:
	ibuf_release(e);

	return (ret);
}

int
ikev2_send_ike_e(struct iked *env, struct iked_sa *sa, struct ibuf *buf,
    uint8_t firstpayload, uint8_t exchange, int response)
{
	struct ikev2_payload		*pld;
	struct ibuf			*e = NULL;
	int				 ret = -1;

	/* New encrypted message buffer */
	if ((e = ibuf_static()) == NULL)
		goto done;

	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;

	if (buf) {
		if (ibuf_cat(e, buf) != 0)
			goto done;

		if (ikev2_next_payload(pld, ibuf_size(buf),
		    IKEV2_PAYLOAD_NONE) == -1)
			goto done;
	}

	ret = ikev2_msg_send_encrypt(env, sa, &e, exchange, firstpayload,
	    response);

 done:
	ibuf_release(e);

	return (ret);
}

int
ikev2_set_sa_proposal(struct iked_sa *sa, struct iked_policy *pol,
    unsigned int proto)
{
	struct iked_proposal		*prop, *copy;
	struct iked_transform		*xform;
	unsigned int			 i;

	/* create copy of the policy proposals */
	config_free_proposals(&sa->sa_proposals, proto);
	TAILQ_FOREACH(prop, &pol->pol_proposals, prop_entry) {
		if (proto != 0 && prop->prop_protoid != proto)
			continue;
		if ((copy = config_add_proposal(&sa->sa_proposals,
		    prop->prop_id, prop->prop_protoid)) == NULL)
			return (-1);
		for (i = 0; i < prop->prop_nxforms; i++) {
			xform = &prop->prop_xforms[i];
			if (config_add_transform(copy, xform->xform_type,
			    xform->xform_id, xform->xform_length,
			    xform->xform_keylength) == NULL)
				return (-1);
		}
	}
	return (0);
}

int
ikev2_send_create_child_sa(struct iked *env, struct iked_sa *sa,
    struct iked_spi *rekey, uint8_t protoid)
{
	struct iked_policy		*pol = sa->sa_policy;
	struct iked_childsa		*csa = NULL, *csb = NULL;
	struct ikev2_notify		*n;
	struct ikev2_payload		*pld = NULL;
	struct ikev2_keyexchange	*ke;
	struct group			*group;
	struct ibuf			*e = NULL, *nonce = NULL;
	uint8_t				*ptr;
	uint8_t				 firstpayload;
	uint32_t			 spi;
	ssize_t				 len = 0;
	int				 initiator, ret = -1;

	if (rekey)
		log_debug("%s: rekeying %s spi %s", __func__,
		    print_map(rekey->spi_protoid, ikev2_saproto_map),
		    print_spi(rekey->spi, rekey->spi_size));
	else
		log_debug("%s: creating new CHILD SAs", __func__);

	/* XXX cannot initiate multiple concurrent CREATE_CHILD_SA exchanges */
	if (sa->sa_stateflags & IKED_REQ_CHILDSA) {
		log_debug("%s: another CREATE_CHILD_SA exchange already active",
		    __func__);
		return (-1);
	}

	sa->sa_rekeyspi = 0;	/* clear rekey spi */
	initiator = sa->sa_hdr.sh_initiator ? 1 : 0;

	if (rekey &&
	    ((csa = childsa_lookup(sa, rekey->spi,
	    rekey->spi_protoid)) == NULL ||
	    (csb = csa->csa_peersa) == NULL)) {
		log_debug("%s: CHILD SA %s wasn't found", __func__,
		    print_spi(rekey->spi, rekey->spi_size));
		goto done;
	}

	/* Generate new nonce */
	if ((nonce = ibuf_random(IKED_NONCE_SIZE)) == NULL)
		goto done;

	/* Update initiator nonce */
	ibuf_release(sa->sa_inonce);
	sa->sa_inonce = nonce;

	if ((e = ibuf_static()) == NULL)
		goto done;

	/* compression */
	if ((pol->pol_flags & IKED_POLICY_IPCOMP) &&
	    (len = ikev2_add_ipcompnotify(env, e, &pld, 0, sa)) == -1)
		goto done;

	if (pld) {
		firstpayload = IKEV2_PAYLOAD_NOTIFY;
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_SA) == -1)
			goto done;
	} else
		firstpayload = IKEV2_PAYLOAD_SA;

	/* SA payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;

	/*
	 * We need to reset the sa_proposal. Otherwise it would be
	 * left over from the IKE_AUTH exchange and would not contain
	 * any DH groups (e.g. for ESP child SAs).
	 */
	if (ikev2_set_sa_proposal(sa, pol, protoid) < 0) {
		log_debug("%s: ikev2_set_sa_proposal failed", __func__);
		goto done;
	}

	if ((len = ikev2_add_proposals(env, sa, e, &sa->sa_proposals,
	    protoid, 1, 0)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONCE) == -1)
		goto done;

	/* NONCE payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if (ikev2_add_buf(e, nonce) == -1)
		goto done;
	len = ibuf_size(nonce);

	if (config_findtransform(&pol->pol_proposals, IKEV2_XFORMTYPE_DH,
	    protoid)) {
		log_debug("%s: enable PFS", __func__);
		ikev2_sa_cleanup_dh(sa);
		if (ikev2_sa_initiator_dh(sa, NULL, protoid) < 0) {
			log_debug("%s: failed to setup DH", __func__);
			goto done;
		}
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_KE) == -1)
			goto done;

		/* KE payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((ke = ibuf_advance(e, sizeof(*ke))) == NULL)
			goto done;
		if ((group = sa->sa_dhgroup) == NULL) {
			log_debug("%s: invalid dh", __func__);
			goto done;
		}
		ke->kex_dhgroup = htobe16(group->id);
		if (ikev2_add_buf(e, sa->sa_dhiexchange) == -1)
			goto done;
		len = sizeof(*ke) + dh_getlen(group);
	}

	if ((len = ikev2_add_ts(e, &pld, len, sa, !initiator)) == -1)
		goto done;

	if (rekey) {
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
			goto done;

		/* REKEY_SA notification */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((n = ibuf_advance(e, sizeof(*n))) == NULL)
			goto done;
		n->n_type = htobe16(IKEV2_N_REKEY_SA);
		n->n_protoid = rekey->spi_protoid;
		n->n_spisize = rekey->spi_size;
		if ((ptr = ibuf_advance(e, rekey->spi_size)) == NULL)
			goto done;
		len = rekey->spi_size;
		spi = htobe32((uint32_t)csa->csa_peerspi);
		memcpy(ptr, &spi, rekey->spi_size);
		len += sizeof(*n);
	}

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, firstpayload, 0);
	if (ret == 0) {
		if (rekey) {
			csa->csa_rekey = 1;
			csb->csa_rekey = 1;
			/*
			 * Remember the peer spi of the rekeyed
			 * SA for ikev2_init_create_child_sa().
			 */
			sa->sa_rekeyspi = csa->csa_peerspi;
		}
		sa->sa_stateflags |= IKED_REQ_CHILDSA;
	}

done:
	ibuf_release(e);
	return (ret);
}

void
ikev2_ike_sa_rekey(struct iked *env, void *arg)
{
	struct iked_sa			*sa = arg;
	struct iked_sa			*nsa = NULL;
	struct ikev2_payload		*pld = NULL;
	struct ikev2_keyexchange	*ke;
	struct group			*group;
	struct ibuf			*e = NULL, *nonce = NULL;
	ssize_t				 len = 0;
	int				 ret = -1;

	log_debug("%s: IKE SA %p ispi %s rspi %s", __func__, sa,
	    print_spi(sa->sa_hdr.sh_ispi, 8),
	    print_spi(sa->sa_hdr.sh_rspi, 8));

	if (sa->sa_nexti) {
		log_debug("%s: already rekeying", __func__);
		goto done;
	}

	if (sa->sa_stateflags & IKED_REQ_CHILDSA) {
		/*
		 * We cannot initiate multiple concurrent CREATE_CHILD_SA
		 * exchanges, so retry in one minute.
		 */
		timer_add(env, &sa->sa_rekey, 60);
		return;
	}

	/* We need to make sure the rekeying finishes in time */
	timer_set(env, &sa->sa_rekey, ikev2_ike_sa_rekey_timeout, sa);
	timer_add(env, &sa->sa_rekey, IKED_IKE_SA_REKEY_TIMEOUT);

	if ((nsa = sa_new(env, 0, 0, 1, sa->sa_policy)) == NULL) {
		log_debug("%s: failed to get new SA", __func__);
		goto done;
	}

	if (ikev2_sa_initiator(env, nsa, sa, NULL)) {
		log_debug("%s: failed to setup DH", __func__);
		goto done;
	}
	sa_state(env, nsa, IKEV2_STATE_AUTH_SUCCESS);
	nonce = nsa->sa_inonce;

	if ((e = ibuf_static()) == NULL)
		goto done;

	/* SA payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;

	/* just reuse the old IKE SA proposals */
	if ((len = ikev2_add_proposals(env, nsa, e, &sa->sa_proposals,
	    IKEV2_SAPROTO_IKE, 1, 1)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONCE) == -1)
		goto done;

	/* NONCE payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if (ikev2_add_buf(e, nonce) == -1)
		goto done;
	len = ibuf_size(nonce);

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_KE) == -1)
		goto done;

	/* KE payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((ke = ibuf_advance(e, sizeof(*ke))) == NULL)
		goto done;
	if ((group = nsa->sa_dhgroup) == NULL) {
		log_debug("%s: invalid dh", __func__);
		goto done;
	}
	ke->kex_dhgroup = htobe16(group->id);
	if (ikev2_add_buf(e, nsa->sa_dhiexchange) == -1)
		goto done;
	len = sizeof(*ke) + dh_getlen(group);

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, IKEV2_PAYLOAD_SA, 0);
	if (ret == 0) {
		sa->sa_stateflags |= IKED_REQ_CHILDSA;
		sa->sa_nexti = nsa;
		nsa = NULL;
	}
done:
	if (nsa)
		sa_free(env, nsa);
	ibuf_release(e);

	if (ret == 0)
		log_debug("%s: create child SA sent", __func__);
	else
		log_debug("%s: could not send create child SA", __func__);
	/* XXX should we try again in case of ret != 0 ? */
}

int
ikev2_nonce_cmp(struct ibuf *a, struct ibuf *b)
{
	size_t				alen, blen, len;
	int				ret;

	alen = ibuf_length(a);
	blen = ibuf_length(b);
	len = MIN(alen, blen);
	ret = memcmp(ibuf_data(a), ibuf_data(b), len);
	if (ret == 0)
		ret = (alen < blen ? -1 : 1);
	return (ret);
}

int
ikev2_init_create_child_sa(struct iked *env, struct iked_message *msg)
{
	struct iked_childsa		*csa = NULL;
	struct iked_proposal		*prop;
	struct iked_sa			*sa = msg->msg_sa;
	struct iked_sa			*nsa, *dsa;
	struct iked_spi			*spi;
	struct ikev2_delete		*del;
	struct ibuf			*buf = NULL;
	struct ibuf			*ni, *nr;
	uint32_t			 spi32;
	int				 pfs = 0, ret = -1;

	if (!ikev2_msg_frompeer(msg) ||
	    (sa->sa_stateflags & IKED_REQ_CHILDSA) == 0)
		return (0);

	if (msg->msg_prop == NULL ||
	    TAILQ_EMPTY(&msg->msg_proposals)) {
		log_debug("%s: no proposal specified", __func__);
		return (-1);
	}

	if (ikev2_sa_negotiate(&sa->sa_proposals, &sa->sa_proposals,
	    &msg->msg_proposals, 1) != 0) {
		log_debug("%s: no proposal chosen", __func__);
		return (-1);
	}

	TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
		if (prop->prop_protoid == msg->msg_prop->prop_protoid)
			break;
	}
	if (prop == NULL) {
		log_debug("%s: failed to find %s proposals", __func__,
		    print_map(msg->msg_prop->prop_protoid, ikev2_saproto_map));
		return (-1);
	}

	/* IKE SA rekeying */
	if (prop->prop_protoid == IKEV2_SAPROTO_IKE) {
		if (sa->sa_nexti == NULL) {
			log_debug("%s: missing IKE SA for rekeying", __func__);
			return (-1);
		}
		/* Update the responder SPI */
		/* XXX sa_new() is just a lookup, so nsa == sa->sa_nexti */
		spi = &msg->msg_prop->prop_peerspi;
		if ((nsa = sa_new(env, sa->sa_nexti->sa_hdr.sh_ispi,
		    spi->spi, 1, NULL)) == NULL || nsa != sa->sa_nexti) {
			log_debug("%s: invalid rekey SA", __func__);
			if (nsa)
				sa_free(env, nsa);
			sa_free(env, sa->sa_nexti);
			sa->sa_nexti = NULL;
			return (-1);
		}
		if (ikev2_sa_initiator(env, nsa, sa, msg) == -1) {
			log_debug("%s: failed to get IKE keys", __func__);
			return (-1);
		}
		sa->sa_stateflags &= ~IKED_REQ_CHILDSA;
		if (sa->sa_nextr) {
			/*
			 * Resolve simultaneous IKE SA rekeying by
			 * deleting the SA with the lowest NONCE.
			 */
			log_debug("%s: resolving simultaneous IKE SA rekeying",
			    __func__);
			/* ni: minimum nonce of sa_nexti */
			if (ikev2_nonce_cmp(sa->sa_nexti->sa_inonce,
			    sa->sa_nexti->sa_rnonce) < 0)
				ni = sa->sa_nexti->sa_inonce;
			else
				ni = sa->sa_nexti->sa_rnonce;
			/* nr: minimum nonce of sa_nextr */
			if (ikev2_nonce_cmp(sa->sa_nextr->sa_inonce,
			    sa->sa_nextr->sa_rnonce) < 0)
				nr = sa->sa_nextr->sa_inonce;
			else
				nr = sa->sa_nextr->sa_rnonce;
			/* delete SA with minumum nonce */
			if (ikev2_nonce_cmp(ni, nr) < 0) {
				dsa = sa->sa_nexti;
				nsa = sa->sa_nextr;
			} else {
				dsa = sa->sa_nextr;
				nsa = sa->sa_nexti;
			}
			/* Setup address, socket and NAT information */
			sa_state(env, dsa, IKEV2_STATE_CLOSING);
			sa_address(dsa, &dsa->sa_peer, &sa->sa_peer.addr);
			sa_address(dsa, &dsa->sa_local, &sa->sa_local.addr);
			dsa->sa_fd = sa->sa_fd;
			dsa->sa_natt = sa->sa_natt;
			dsa->sa_udpencap = sa->sa_udpencap;
			ikev2_ikesa_delete(env, dsa, dsa->sa_hdr.sh_initiator);
		}
		sa->sa_nexti = sa->sa_nextr = NULL;
		return (ikev2_ikesa_enable(env, sa, nsa));
	}

	/* Child SA rekeying */
	if (sa->sa_rekeyspi &&
	    (csa = childsa_lookup(sa, sa->sa_rekeyspi, prop->prop_protoid))
	    != NULL) {
		log_debug("%s: rekeying CHILD SA old %s spi %s", __func__,
		    print_spi(csa->csa_spi.spi, csa->csa_spi.spi_size),
		    print_spi(prop->prop_peerspi.spi,
		    prop->prop_peerspi.spi_size));
	}

	/* check KE payload for PFS */
	if (ibuf_length(msg->msg_ke)) {
		log_debug("%s: using PFS", __func__);
		if (ikev2_sa_initiator_dh(sa, msg, prop->prop_protoid) < 0) {
			log_debug("%s: failed to setup DH", __func__);
			return (ret);
		}
		if (sa->sa_dhpeer == NULL) {
			log_debug("%s: no peer DH", __func__);
			return (ret);
		}
		pfs = 1;
		/* XXX check group against policy ? */
		/* XXX should ikev2_sa_negotiate do this? */
	}

	/* Update responder's nonce */
	if (!ibuf_length(msg->msg_nonce)) {
		log_debug("%s: responder didn't send nonce", __func__);
		return (-1);
	}
	ibuf_release(sa->sa_rnonce);
	sa->sa_rnonce = ibuf_dup(msg->msg_nonce);

	if (csa && (ni = sa->sa_simult) != NULL) {
		log_debug("%s: resolving simultaneous CHILD SA rekeying",
		    __func__);
		/* set nr to minimum nonce for exchange initiated by peer */
		if (ikev2_nonce_cmp(sa->sa_inonce, sa->sa_rnonce) < 0)
			nr = sa->sa_inonce;
		else
			nr = sa->sa_rnonce;
		/*
		 * If the exchange initated by us has smaller nonce,
		 * then we have to delete our SAs.
		 */
		if (ikev2_nonce_cmp(ni, nr) < 0) {
			ret = ikev2_childsa_delete_proposed(env, sa,
			    &sa->sa_proposals);
			goto done;
		}
	}

	if (ikev2_childsa_negotiate(env, sa, &sa->sa_kex, &sa->sa_proposals, 1,
	    pfs, !csa)) {
		log_debug("%s: failed to get CHILD SAs", __func__);
		return (-1);
	}

	if (csa) {
		/* Child SA rekeying */

		if ((buf = ibuf_static()) == NULL)
			goto done;

		if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
			goto done;

		del->del_protoid = prop->prop_protoid;
		del->del_spisize = sizeof(spi32);
		del->del_nspi = htobe16(1);

		spi32 = htobe32(csa->csa_spi.spi);
		if (ibuf_add(buf, &spi32, sizeof(spi32)))
			goto done;

		if (ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
		    IKEV2_EXCHANGE_INFORMATIONAL, 0))
			goto done;

		sa->sa_stateflags |= IKED_REQ_INF;
	}

	ret = ikev2_childsa_enable(env, sa);

done:
	sa->sa_stateflags &= ~IKED_REQ_CHILDSA;
	ibuf_release(sa->sa_simult);
	sa->sa_simult = NULL;

	if (ret)
		ikev2_childsa_delete(env, sa, 0, 0, NULL, 1);
	else if (csa) {
		/* delete the rekeyed SA pair */
		ikev2_childsa_delete(env, sa, csa->csa_saproto,
		    csa->csa_peerspi, NULL, 0);
	}
	ibuf_release(buf);
	return (ret);
}

int
ikev2_ikesa_enable(struct iked *env, struct iked_sa *sa, struct iked_sa *nsa)
{
	struct iked_childsa		*csa, *nextcsa;
	struct iked_flow		*flow, *nextflow;
	struct iked_proposal		*prop, *nextprop;

	log_debug("%s: IKE SA %p ispi %s rspi %s replaced"
	    " by SA %p ispi %s rspi %s ",
	    __func__, sa,
	    print_spi(sa->sa_hdr.sh_ispi, 8),
	    print_spi(sa->sa_hdr.sh_rspi, 8),
	    nsa,
	    print_spi(nsa->sa_hdr.sh_ispi, 8),
	    print_spi(nsa->sa_hdr.sh_rspi, 8));

	/* Transfer socket and NAT information */
	nsa->sa_fd = sa->sa_fd;
	nsa->sa_natt = sa->sa_natt;
	nsa->sa_udpencap = sa->sa_udpencap;
	nsa->sa_usekeepalive = sa->sa_usekeepalive;

	/* Transfer old addresses */
	memcpy(&nsa->sa_local, &sa->sa_local, sizeof(nsa->sa_local));
	memcpy(&nsa->sa_peer, &sa->sa_peer, sizeof(nsa->sa_peer));

	/* Transfer all Child SAs and flows from the old IKE SA */
	for (flow = TAILQ_FIRST(&sa->sa_flows); flow != NULL;
	     flow = nextflow) {
		nextflow = TAILQ_NEXT(flow, flow_entry);
		TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
		TAILQ_INSERT_TAIL(&nsa->sa_flows, flow,
		    flow_entry);
		flow->flow_ikesa = nsa;
		flow->flow_local = &nsa->sa_local;
		flow->flow_peer = &nsa->sa_peer;
	}
	for (csa = TAILQ_FIRST(&sa->sa_childsas); csa != NULL;
	     csa = nextcsa) {
		nextcsa = TAILQ_NEXT(csa, csa_entry);
		TAILQ_REMOVE(&sa->sa_childsas, csa, csa_entry);
		TAILQ_INSERT_TAIL(&nsa->sa_childsas, csa,
		    csa_entry);
		csa->csa_ikesa = nsa;
		if (csa->csa_dir == IPSP_DIRECTION_IN) {
			csa->csa_local = &nsa->sa_peer;
			csa->csa_peer = &nsa->sa_local;
		} else {
			csa->csa_local = &nsa->sa_local;
			csa->csa_peer = &nsa->sa_peer;
		}
	}
	/* Transfer all non-IKE proposals */
	for (prop = TAILQ_FIRST(&sa->sa_proposals); prop != NULL;
	     prop = nextprop) {
		nextprop = TAILQ_NEXT(prop, prop_entry);
		if (prop->prop_protoid == IKEV2_SAPROTO_IKE)
			continue;
		TAILQ_REMOVE(&sa->sa_proposals, prop, prop_entry);
		TAILQ_INSERT_TAIL(&nsa->sa_proposals, prop,
		    prop_entry);
	}

	/* Preserve ID information */
	if (sa->sa_hdr.sh_initiator == nsa->sa_hdr.sh_initiator) {
		nsa->sa_iid = sa->sa_iid;
		nsa->sa_rid = sa->sa_rid;
		nsa->sa_icert = sa->sa_icert;
		nsa->sa_rcert = sa->sa_rcert;
	} else {
		/* initiator and responder role swapped */
		nsa->sa_iid = sa->sa_rid;
		nsa->sa_rid = sa->sa_iid;
		nsa->sa_icert = sa->sa_rcert;
		nsa->sa_rcert = sa->sa_icert;
	}
	/* duplicate the actual buffer */
	nsa->sa_iid.id_buf = ibuf_dup(nsa->sa_iid.id_buf);
	nsa->sa_rid.id_buf = ibuf_dup(nsa->sa_rid.id_buf);
	nsa->sa_icert.id_buf = ibuf_dup(nsa->sa_icert.id_buf);
	nsa->sa_rcert.id_buf = ibuf_dup(nsa->sa_rcert.id_buf);

	/* Transfer sa_addrpool address */
	if (sa->sa_addrpool) {
		RB_REMOVE(iked_addrpool, &env->sc_addrpool, sa);
		nsa->sa_addrpool = sa->sa_addrpool;
		sa->sa_addrpool = NULL;
		RB_INSERT(iked_addrpool, &env->sc_addrpool, nsa);
	}
	if (sa->sa_addrpool6) {
		RB_REMOVE(iked_addrpool6, &env->sc_addrpool6, sa);
		nsa->sa_addrpool6 = sa->sa_addrpool6;
		sa->sa_addrpool6 = NULL;
		RB_INSERT(iked_addrpool6, &env->sc_addrpool6, nsa);
	}
	/* Transfer other attributes */
	if (sa->sa_tag) {
		nsa->sa_tag = sa->sa_tag;
		sa->sa_tag = NULL;
	}

	log_debug("%s: activating new IKE SA", __func__);
	sa_state(env, nsa, IKEV2_STATE_ESTABLISHED);
	timer_set(env, &nsa->sa_timer, ikev2_ike_sa_alive, nsa);
	timer_add(env, &nsa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
	timer_set(env, &nsa->sa_keepalive, ikev2_ike_sa_keepalive, nsa);
	if (nsa->sa_usekeepalive)
		timer_add(env, &nsa->sa_keepalive,
		    IKED_IKE_SA_KEEPALIVE_TIMEOUT);
	timer_set(env, &nsa->sa_rekey, ikev2_ike_sa_rekey, nsa);
	if (nsa->sa_policy->pol_rekey)
		ikev2_ike_sa_rekey_schedule(env, nsa);
	nsa->sa_stateflags = nsa->sa_statevalid; /* XXX */

	/* unregister DPD keep alive timer & rekey first */
	if (sa->sa_state == IKEV2_STATE_ESTABLISHED) {
		timer_del(env, &sa->sa_rekey);
		timer_del(env, &sa->sa_keepalive);
		timer_del(env, &sa->sa_timer);
	}

	ikev2_ikesa_delete(env, sa, nsa->sa_hdr.sh_initiator);
	return (0);
}

void
ikev2_ikesa_delete(struct iked *env, struct iked_sa *sa, int initiator)
{
	struct ibuf			*buf = NULL;
	struct ikev2_delete		*del;

	if (initiator) {
		/* Send PAYLOAD_DELETE */
		if ((buf = ibuf_static()) == NULL)
			goto done;
		if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
			goto done;
		del->del_protoid = IKEV2_SAPROTO_IKE;
		del->del_spisize = 0;
		del->del_nspi = 0;
		if (ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
		    IKEV2_EXCHANGE_INFORMATIONAL, 0) == -1)
			goto done;
		log_debug("%s: sent delete, closing SA", __func__);
done:
		ibuf_release(buf);
		sa_state(env, sa, IKEV2_STATE_CLOSED);
	} else {
		sa_state(env, sa, IKEV2_STATE_CLOSING);
	}

	/* Remove IKE-SA after timeout, e.g. if we don't get a delete */
	timer_set(env, &sa->sa_timer, ikev2_ike_sa_timeout, sa);
	timer_add(env, &sa->sa_timer, IKED_IKE_SA_DELETE_TIMEOUT);
}

void
ikev2_ikesa_recv_delete(struct iked *env, struct iked_sa *sa)
{
	if (sa->sa_nexti) {
		/*
		 * We initiated rekeying, but since sa_nexti is still set
		 * we have to assume that the the peer did not receive our
		 * rekey message. So remove the initiated SA and -- if
		 * sa_nextr is set -- keep the responder SA instead.
		 */
		if (sa->sa_nextr) {
			log_debug("%s: resolving simultaneous IKE SA rekeying",
			    __func__);
			ikev2_ikesa_enable(env, sa, sa->sa_nextr);
		}
		sa_free(env, sa->sa_nexti);
		sa->sa_nextr = sa->sa_nexti = NULL;
	}
	sa_state(env, sa, IKEV2_STATE_CLOSED);
}

int
ikev2_resp_create_child_sa(struct iked *env, struct iked_message *msg)
{
	struct iked_childsa		*csa = NULL;
	struct iked_proposal		*prop;
	struct iked_proposals		 proposals;
	struct iked_kex			*kex, *kextmp = NULL;
	struct iked_sa			*nsa = NULL, *sa = msg->msg_sa;
	struct iked_spi			*spi, *rekey = &msg->msg_rekey;
	struct ikev2_keyexchange	*ke;
	struct ikev2_payload		*pld = NULL;
	struct ibuf			*e = NULL, *nonce = NULL;
	uint8_t				 firstpayload;
	ssize_t				 len = 0;
	int				 initiator, protoid, rekeying = 1;
	int				 ret = -1;
	int				 pfs = 0;

	initiator = sa->sa_hdr.sh_initiator ? 1 : 0;

	if (!ikev2_msg_frompeer(msg) || msg->msg_prop == NULL)
		return (0);

	TAILQ_INIT(&proposals);

	if ((protoid = rekey->spi_protoid) == 0) {
		/*
		 * If REKEY_SA notification is not present, then it's either
		 * IKE SA rekeying or the client wants to create additional
		 * CHILD SAs
		 */
		if (msg->msg_prop->prop_protoid == IKEV2_SAPROTO_IKE) {
			protoid = rekey->spi_protoid = IKEV2_SAPROTO_IKE;
			if (sa->sa_hdr.sh_initiator)
				rekey->spi = sa->sa_hdr.sh_rspi;
			else
				rekey->spi = sa->sa_hdr.sh_ispi;
			rekey->spi_size = 8;
		} else {
			protoid = msg->msg_prop->prop_protoid;
			rekeying = 0;
		}
	}

	if (rekeying)
		log_debug("%s: rekey %s spi %s", __func__,
		    print_map(rekey->spi_protoid, ikev2_saproto_map),
		    print_spi(rekey->spi, rekey->spi_size));
	else
		log_debug("%s: creating new %s SA", __func__,
		    print_map(protoid, ikev2_saproto_map));

	if (protoid == IKEV2_SAPROTO_IKE) {
		/* IKE SA rekeying */
		spi = &msg->msg_prop->prop_peerspi;

		if ((nsa = sa_new(env, spi->spi, 0, 0,
		    msg->msg_policy)) == NULL) {
			log_debug("%s: failed to get new SA", __func__);
			return (ret);
		}

		if (ikev2_sa_responder(env, nsa, sa, msg)) {
			log_debug("%s: failed to get IKE SA keys", __func__);
			return (ret);
		}

		sa_state(env, nsa, IKEV2_STATE_AUTH_SUCCESS);

		nonce = nsa->sa_rnonce;
		kex = &nsa->sa_kex;
	} else {
		/* Child SA creating/rekeying */

		if ((kex = kextmp = calloc(1, sizeof(*kextmp))) == NULL) {
			log_debug("%s: calloc kex", __func__);
			goto fail;
		}

		if (ikev2_sa_negotiate(&proposals,
		    &sa->sa_policy->pol_proposals, &msg->msg_proposals,
		    1) != 0) {
			log_info("%s: no proposal chosen", __func__);
			msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
			goto fail;
		}

		/* check KE payload for PFS */
		if (ibuf_length(msg->msg_parent->msg_ke)) {
			log_debug("%s: using PFS", __func__);
			if (ikev2_sa_responder_dh(kex, &proposals,
			    msg->msg_parent, protoid) < 0) {
				log_debug("%s: failed to setup DH", __func__);
				goto fail;
			}
			pfs = 1;
			/* XXX check group against policy ? */
		}

		/* Update peer SPI */
		TAILQ_FOREACH(prop, &proposals, prop_entry) {
			if (prop->prop_protoid == protoid)
				break;
		}
		if (prop == NULL) {
			log_debug("%s: failed to find %s proposals", __func__,
			    print_map(protoid, ikev2_saproto_map));
			goto fail;
		} else
			prop->prop_peerspi = msg->msg_prop->prop_peerspi;

		/* Set rekeying flags on Child SAs */
		if (rekeying) {
			if ((csa = childsa_lookup(sa, rekey->spi,
			    rekey->spi_protoid)) == NULL) {
				log_debug("%s: CHILD SA %s wasn't found",
				    __func__, print_spi(rekey->spi,
					rekey->spi_size));
				/* XXX send notification to peer */
				goto fail;
			}
			if (!csa->csa_loaded || !csa->csa_peersa ||
			    !csa->csa_peersa->csa_loaded) {
				log_debug("%s: SA is not loaded or no peer SA",
				    __func__);
				/* XXX send notification to peer */
				goto fail;
			}
			csa->csa_rekey = 1;
			csa->csa_peersa->csa_rekey = 1;
		}

		/* Update initiator's nonce */
		if (!ibuf_length(msg->msg_nonce)) {
			log_debug("%s: initiator didn't send nonce", __func__);
			goto fail;
		}
		ibuf_release(kex->kex_inonce);
		kex->kex_inonce = ibuf_dup(msg->msg_nonce);

		/* Generate new responder's nonce */
		if ((nonce = ibuf_random(IKED_NONCE_SIZE)) == NULL)
			goto fail;

		/* Update responder's nonce */
		ibuf_release(kex->kex_rnonce);
		kex->kex_rnonce = nonce;

		if (ikev2_childsa_negotiate(env, sa, kex, &proposals, 0,
		    pfs, !rekeying)) {
			log_debug("%s: failed to get CHILD SAs", __func__);
			goto fail;
		}

		if (rekeying && (sa->sa_stateflags & IKED_REQ_CHILDSA) &&
		    csa && (sa->sa_rekeyspi == csa->csa_peerspi)) {
			log_debug("%s: simultanous rekeying for CHILD SA %s/%s",
			    __func__,
			    print_spi(rekey->spi, rekey->spi_size),
			    print_spi(sa->sa_rekeyspi, rekey->spi_size));
			ibuf_release(sa->sa_simult);
			if (ikev2_nonce_cmp(kex->kex_inonce, nonce) < 0)
				sa->sa_simult = ibuf_dup(kex->kex_inonce);
			else
				sa->sa_simult = ibuf_dup(nonce);
		}
	}

	if ((e = ibuf_static()) == NULL)
		goto done;

	/* compression (unless IKE rekeying) */
	if (!nsa && sa->sa_ipcomp &&
	    (len = ikev2_add_ipcompnotify(env, e, &pld, 0, sa)) == -1)
		goto done;

	if (pld) {
		firstpayload = IKEV2_PAYLOAD_NOTIFY;
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_SA) == -1)
			goto done;
	} else
		firstpayload = IKEV2_PAYLOAD_SA;

	/* SA payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;

	if ((len = ikev2_add_proposals(env, nsa ? nsa : sa, e,
		nsa ? &nsa->sa_proposals : &proposals,
		protoid, 0, nsa ? 1 : 0)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONCE) == -1)
		goto done;

	/* NONCE payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if (ikev2_add_buf(e, nonce) == -1)
		goto done;
	len = ibuf_size(nonce);

	if (protoid == IKEV2_SAPROTO_IKE || pfs) {

		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_KE) == -1)
			goto done;

		/* KE payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((ke = ibuf_advance(e, sizeof(*ke))) == NULL)
			goto done;
		if (kex->kex_dhgroup == NULL) {
			log_debug("%s: invalid dh", __func__);
			goto done;
		}
		ke->kex_dhgroup = htobe16(kex->kex_dhgroup->id);
		if (ikev2_add_buf(e, kex->kex_dhrexchange) == -1)
			goto done;
		len = sizeof(*ke) + dh_getlen(kex->kex_dhgroup);
	}

	if (protoid != IKEV2_SAPROTO_IKE)
		if ((len = ikev2_add_ts(e, &pld, len, sa, initiator)) == -1)
			goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	if ((ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, firstpayload, 1)) == -1)
		goto done;

	if (protoid == IKEV2_SAPROTO_IKE) {
		/*
		 * If we also have initiated rekeying for this IKE SA, then
		 * sa_nexti is already set. In this case don't enable the new SA
		 * immediately, but record it in sa_nextr, until the exchange
		 * for sa_nexti completes in ikev2_init_create_child_sa() and
		 * the 'winner' can be selected by comparing nonces.
		 */
		if (sa->sa_nexti) {
			log_debug("%s: simultaneous IKE SA rekeying", __func__);
			sa->sa_nextr = nsa;
			ret = 0;
		} else
			ret = ikev2_ikesa_enable(env, sa, nsa);
	} else
		ret = ikev2_childsa_enable(env, sa);

 done:
	if (ret && protoid != IKEV2_SAPROTO_IKE)
		ikev2_childsa_delete(env, sa, 0, 0, NULL, 1);
	ibuf_release(e);
	config_free_proposals(&proposals, 0);
	config_free_kex(kextmp);
	return (ret);

 fail:
	config_free_proposals(&proposals, 0);
	config_free_kex(kextmp);
	return (-1);
}

void
ikev2_ike_sa_timeout(struct iked *env, void *arg)
{
	struct iked_sa			*sa = arg;

	log_debug("%s: closing SA", __func__);
	sa_free(env, sa);
}

void
ikev2_ike_sa_rekey_timeout(struct iked *env, void *arg)
{
	struct iked_sa			*sa = arg;

	log_debug("%s: closing SA", __func__);
	sa_free(env, sa);
}

void
ikev2_ike_sa_rekey_schedule(struct iked *env, struct iked_sa *sa)
{
	timer_add(env, &sa->sa_rekey, (sa->sa_policy->pol_rekey * 850 +
	    arc4random_uniform(100)) / 1000);
}

void
ikev2_ike_sa_alive(struct iked *env, void *arg)
{
	struct iked_sa			*sa = arg;
	struct iked_childsa		*csa = NULL;
	struct timeval			 tv;
	uint64_t			 last_used, diff;
	int				 foundin = 0, foundout = 0;

	/* check for incoming traffic on any child SA */
	TAILQ_FOREACH(csa, &sa->sa_childsas, csa_entry) {
		if (!csa->csa_loaded ||
		    csa->csa_saproto == IKEV2_SAPROTO_IPCOMP)
			continue;
		if (pfkey_sa_last_used(env->sc_pfkey, csa, &last_used) != 0)
			continue;
		gettimeofday(&tv, NULL);
		diff = (uint32_t)(tv.tv_sec - last_used);
		log_debug("%s: %s CHILD SA spi %s last used %llu second(s) ago",
		    __func__,
		    csa->csa_dir == IPSP_DIRECTION_IN ? "incoming" : "outgoing",
		    print_spi(csa->csa_spi.spi, csa->csa_spi.spi_size), diff);
		if (diff < IKED_IKE_SA_ALIVE_TIMEOUT) {
			if (csa->csa_dir == IPSP_DIRECTION_IN) {
				foundin = 1;
				break;
			} else {
				foundout = 1;
			}
		}
	}

	/* send probe if any outging SA has been used, but no incoming SA */
	if (!foundin && foundout) {
		log_debug("%s: sending alive check", __func__);
		ikev2_send_ike_e(env, sa, NULL, IKEV2_PAYLOAD_NONE,
		    IKEV2_EXCHANGE_INFORMATIONAL, 0);
		sa->sa_stateflags |= IKED_REQ_INF;
	}

	/* re-register */
	timer_add(env, &sa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
}

void
ikev2_ike_sa_keepalive(struct iked *env, void *arg)
{
	struct iked_sa			*sa = arg;
	uint8_t				 marker = 0xff;

	if (sendtofrom(sa->sa_fd, &marker, sizeof(marker), 0,
	    (struct sockaddr *)&sa->sa_peer.addr, sa->sa_peer.addr.ss_len,
	    (struct sockaddr *)&sa->sa_local.addr, sa->sa_local.addr.ss_len)
	    == -1)
		log_warn("%s: sendtofrom: peer %s local %s", __func__,
		    print_host((struct sockaddr *)&sa->sa_peer.addr, NULL, 0),
		    print_host((struct sockaddr *)&sa->sa_local.addr, NULL, 0));
	else
		log_debug("%s: peer %s local %s", __func__,
		    print_host((struct sockaddr *)&sa->sa_peer.addr, NULL, 0),
		    print_host((struct sockaddr *)&sa->sa_local.addr, NULL, 0));
	timer_add(env, &sa->sa_keepalive, IKED_IKE_SA_KEEPALIVE_TIMEOUT);
}

int
ikev2_send_informational(struct iked *env, struct iked_message *msg)
{
	struct iked_message		 resp;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ikev2_notify		*n;
	struct iked_sa			*sa = msg->msg_sa, sah;
	struct ibuf			*buf, *e = NULL;
	int				 ret = -1;

	if (msg->msg_error == 0)
		return (0);

	if ((buf = ikev2_msg_init(env, &resp,
	    &msg->msg_peer, msg->msg_peerlen,
	    &msg->msg_local, msg->msg_locallen, 0)) == NULL)
		goto done;

	/* New encrypted message buffer */
	if ((e = ibuf_static()) == NULL)
		goto done;

	/* NOTIFY payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;

	if ((n = ibuf_advance(e, sizeof(*n))) == NULL)
		goto done;
	n->n_protoid = IKEV2_SAPROTO_IKE;	/* XXX ESP etc. */
	n->n_spisize = 0;
	n->n_type = htobe16(msg->msg_error);

	switch (msg->msg_error) {
	case IKEV2_N_INVALID_IKE_SPI:
	case IKEV2_N_NO_PROPOSAL_CHOSEN:
		break;
	default:
		log_debug("%s: unsupported notification %s", __func__,
		    print_map(msg->msg_error, ikev2_n_map));
		goto done;
	}

	if (ikev2_next_payload(pld, sizeof(*n), IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	if (sa != NULL && msg->msg_e) {
		resp.msg_msgid = ikev2_msg_id(env, sa);

		/* IKE header */
		if ((hdr = ikev2_add_header(buf, sa, resp.msg_msgid,
		    IKEV2_PAYLOAD_SK, IKEV2_EXCHANGE_INFORMATIONAL,
		    0)) == NULL)
			goto done;

		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;

		/* Encrypt message and add as an E payload */
		if ((e = ikev2_msg_encrypt(env, sa, e)) == NULL) {
			log_debug("%s: encryption failed", __func__);
			goto done;
		}
		if (ibuf_cat(buf, e) != 0)
			goto done;
		if (ikev2_next_payload(pld, ibuf_size(e),
		    IKEV2_PAYLOAD_NOTIFY) == -1)
			goto done;

		if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
			goto done;

		/* Add integrity checksum (HMAC) */
		if (ikev2_msg_integr(env, sa, buf) != 0) {
			log_debug("%s: integrity checksum failed", __func__);
			goto done;
		}
	} else {
		if ((hdr = ibuf_seek(msg->msg_data, 0, sizeof(*hdr))) == NULL)
			goto done;

		bzero(&sah, sizeof(sah));
		sah.sa_hdr.sh_rspi = betoh64(hdr->ike_rspi);
		sah.sa_hdr.sh_ispi = betoh64(hdr->ike_ispi);
		sah.sa_hdr.sh_initiator =
		    hdr->ike_flags & IKEV2_FLAG_INITIATOR ? 0 : 1;

		resp.msg_msgid = ikev2_msg_id(env, &sah);

		/* IKE header */
		if ((hdr = ikev2_add_header(buf, &sah, resp.msg_msgid,
		    IKEV2_PAYLOAD_NOTIFY, IKEV2_EXCHANGE_INFORMATIONAL,
		    0)) == NULL)
			goto done;
		if (ibuf_cat(buf, e) != 0)
			goto done;
		if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
			goto done;
	}

	resp.msg_data = buf;
	resp.msg_fd = msg->msg_fd;
	TAILQ_INIT(&resp.msg_proposals);

	ret = ikev2_msg_send(env, &resp);

 done:
	ibuf_release(e);
	ikev2_msg_cleanup(env, &resp);

	return (ret);
}

ssize_t
ikev2_psk(struct iked_sa *sa, uint8_t *data, size_t length,
    uint8_t **pskptr)
{
	uint8_t		*psk;
	size_t		 psklen = -1;

	if (hash_setkey(sa->sa_prf, data, length) == NULL)
		return (-1);

	if ((psk = calloc(1, hash_keylength(sa->sa_prf))) == NULL)
		return (-1);

	hash_init(sa->sa_prf);
	hash_update(sa->sa_prf, IKEV2_KEYPAD, strlen(IKEV2_KEYPAD));
	hash_final(sa->sa_prf, psk, &psklen);

	*pskptr = psk;
	return (psklen);
}

int
ikev2_match_proposals(struct iked_proposal *local, struct iked_proposal *peer,
    struct iked_transform **xforms, int rekey)
{
	struct iked_transform	*tpeer, *tlocal;
	unsigned int		 i, j, type, score, requiredh = 0;
	uint8_t			 protoid = peer->prop_protoid;

	for (i = 0; i < peer->prop_nxforms; i++) {
		tpeer = peer->prop_xforms + i;
		for (j = 0; j < local->prop_nxforms; j++) {
			tlocal = local->prop_xforms + j;

			/*
			 * We require a DH group for ESP if there is any
			 * local proposal with DH enabled.
			 */
			if (rekey && requiredh == 0 &&
			    protoid == IKEV2_SAPROTO_ESP &&
			    tlocal->xform_type == IKEV2_XFORMTYPE_DH)
				requiredh = 1;

			/* Compare peer and local proposals */
			if (tpeer->xform_type != tlocal->xform_type ||
			    tpeer->xform_id != tlocal->xform_id ||
			    tpeer->xform_length != tlocal->xform_length)
				continue;
			if (tpeer->xform_type > IKEV2_XFORMTYPE_MAX)
				continue;
			type = tpeer->xform_type;

			if (xforms[type] == NULL || tlocal->xform_score <
			    xforms[type]->xform_score) {
				xforms[type] = tlocal;
			} else
				continue;

			print_debug("%s: xform %d <-> %d (%d): %s %s "
			    "(keylength %d <-> %d)", __func__,
			    peer->prop_id, local->prop_id, tlocal->xform_score,
			    print_map(type, ikev2_xformtype_map),
			    print_map(tpeer->xform_id, tpeer->xform_map),
			    tpeer->xform_keylength, tlocal->xform_keylength);
			if (tpeer->xform_length)
				print_debug(" %d", tpeer->xform_length);
			print_debug("\n");
		}
	}

	for (i = score = 0; i < IKEV2_XFORMTYPE_MAX; i++) {
		if (protoid == IKEV2_SAPROTO_IKE && xforms[i] == NULL &&
		    (i == IKEV2_XFORMTYPE_ENCR || i == IKEV2_XFORMTYPE_PRF ||
		     i == IKEV2_XFORMTYPE_INTEGR || i == IKEV2_XFORMTYPE_DH)) {
			score = 0;
			break;
		} else if (protoid == IKEV2_SAPROTO_AH && xforms[i] == NULL &&
		    (i == IKEV2_XFORMTYPE_INTEGR || i == IKEV2_XFORMTYPE_ESN)) {
			score = 0;
			break;
		} else if (protoid == IKEV2_SAPROTO_ESP && xforms[i] == NULL &&
		    (i == IKEV2_XFORMTYPE_ENCR || i == IKEV2_XFORMTYPE_ESN ||
		    (requiredh && i == IKEV2_XFORMTYPE_DH))) {
			score = 0;
			break;
		} else if (xforms[i] == NULL)
			continue;

		score += xforms[i]->xform_score;
	}

	return (score);
}

/*
 * The 'rekey' parameter indicates a CREATE_CHILD_SA exchange where
 * an extra group is necessary for PFS. For the initial IKE_AUTH exchange
 * the ESP SA proposal never includes an explicit DH group.
 */
int
ikev2_sa_negotiate(struct iked_proposals *result, struct iked_proposals *local,
    struct iked_proposals *peer, int rekey)
{
	struct iked_proposal	*ppeer = NULL, *plocal, *prop, vpeer, vlocal;
	struct iked_transform	 chosen[IKEV2_XFORMTYPE_MAX];
	struct iked_transform	*valid[IKEV2_XFORMTYPE_MAX];
	struct iked_transform	*match[IKEV2_XFORMTYPE_MAX];
	unsigned int		 i, score, chosen_score = 0;
	uint8_t			 protoid = 0;

	bzero(valid, sizeof(valid));
	bzero(&vlocal, sizeof(vlocal));
	bzero(&vpeer, sizeof(vpeer));

	if (TAILQ_EMPTY(peer)) {
		log_debug("%s: peer did not send %s proposals", __func__,
		    print_map(protoid, ikev2_saproto_map));
		return (-1);
	}

	TAILQ_FOREACH(plocal, local, prop_entry) {
		TAILQ_FOREACH(ppeer, peer, prop_entry) {
			if (ppeer->prop_protoid != plocal->prop_protoid)
				continue;
			bzero(match, sizeof(match));
			score = ikev2_match_proposals(plocal, ppeer, match,
			    rekey);
			log_debug("%s: score %d", __func__, score);
			if (score && (!chosen_score || score < chosen_score)) {
				chosen_score = score;
				for (i = 0; i < IKEV2_XFORMTYPE_MAX; i++) {
					if ((valid[i] = match[i]))
						memcpy(&chosen[i], match[i],
						    sizeof(chosen[0]));
				}
				memcpy(&vpeer, ppeer, sizeof(vpeer));
				memcpy(&vlocal, plocal, sizeof(vlocal));
			}
		}
		if (chosen_score != 0)
			break;
	}

	if (chosen_score == 0)
		return (-1);
	else if (result == NULL)
		return (0);

	(void)config_free_proposals(result, vpeer.prop_protoid);
	prop = config_add_proposal(result, vpeer.prop_id, vpeer.prop_protoid);

	if (vpeer.prop_localspi.spi_size) {
		prop->prop_localspi.spi_size = vpeer.prop_localspi.spi_size;
		prop->prop_peerspi = vpeer.prop_peerspi;
	}
	if (vlocal.prop_localspi.spi_size) {
		prop->prop_localspi.spi_size = vlocal.prop_localspi.spi_size;
		prop->prop_localspi.spi = vlocal.prop_localspi.spi;
	}

	for (i = 0; i < IKEV2_XFORMTYPE_MAX; i++) {
		if (valid[i] == NULL)
			continue;
		print_debug("%s: score %d: %s %s", __func__,
		    chosen[i].xform_score, print_map(i, ikev2_xformtype_map),
		    print_map(chosen[i].xform_id, chosen[i].xform_map));
		if (chosen[i].xform_length)
			print_debug(" %d", chosen[i].xform_length);
		print_debug("\n");

		if (config_add_transform(prop, chosen[i].xform_type,
		    chosen[i].xform_id, chosen[i].xform_length,
		    chosen[i].xform_keylength) == NULL)
			break;
	}

	return (0);
}

int
ikev2_sa_initiator_dh(struct iked_sa *sa, struct iked_message *msg,
    unsigned int proto)
{
	struct iked_policy	*pol = sa->sa_policy;
	struct iked_transform	*xform;

	if (sa->sa_dhgroup == NULL) {
		if ((xform = config_findtransform(&pol->pol_proposals,
		    IKEV2_XFORMTYPE_DH, proto)) == NULL) {
			log_debug("%s: did not find dh transform", __func__);
			return (-1);
		}
		if ((sa->sa_dhgroup =
		    group_get(xform->xform_id)) == NULL) {
			log_debug("%s: invalid dh %d", __func__,
			    xform->xform_id);
			return (-1);
		}
	}

	if (!ibuf_length(sa->sa_dhiexchange)) {
		if ((sa->sa_dhiexchange = ibuf_new(NULL,
		    dh_getlen(sa->sa_dhgroup))) == NULL) {
			log_debug("%s: failed to alloc dh exchange", __func__);
			return (-1);
		}
		if (dh_create_exchange(sa->sa_dhgroup,
		    sa->sa_dhiexchange->buf) == -1) {
			log_debug("%s: failed to get dh exchange", __func__);
			return (-1);
		}
	}

	/* Initial message */
	if (msg == NULL)
		return (0);

	if (!ibuf_length(sa->sa_dhrexchange)) {
		if (!ibuf_length(msg->msg_ke)) {
			log_debug("%s: invalid peer dh exchange", __func__);
			return (-1);
		}
		if ((ssize_t)ibuf_length(msg->msg_ke) !=
		    dh_getlen(sa->sa_dhgroup)) {
			log_debug("%s: invalid dh length, size %d", __func__,
			    dh_getlen(sa->sa_dhgroup) * 8);
			return (-1);
		}
		if ((sa->sa_dhrexchange = ibuf_dup(msg->msg_ke)) == NULL) {
			log_debug("%s: failed to copy dh exchange", __func__);
			return (-1);
		}
	}

	/* Set a pointer to the peer exchange */
	sa->sa_dhpeer = sa->sa_dhrexchange;
	return (0);
}

int
ikev2_sa_initiator(struct iked *env, struct iked_sa *sa,
    struct iked_sa *osa, struct iked_message *msg)
{
	struct iked_transform	*xform;

	if (ikev2_sa_initiator_dh(sa, msg, 0) < 0)
		return (-1);

	if (!ibuf_length(sa->sa_inonce)) {
		if ((sa->sa_inonce = ibuf_random(IKED_NONCE_SIZE)) == NULL) {
			log_debug("%s: failed to get local nonce", __func__);
			return (-1);
		}
	}

	/* Initial message */
	if (msg == NULL)
		return (0);

	if (!ibuf_length(sa->sa_rnonce)) {
		if (!ibuf_length(msg->msg_nonce)) {
			log_debug("%s: invalid peer nonce", __func__);
			return (-1);
		}
		if ((sa->sa_rnonce = ibuf_dup(msg->msg_nonce)) == NULL) {
			log_debug("%s: failed to get peer nonce", __func__);
			return (-1);
		}
	}

	/* XXX we need a better way to get this */
	if (ikev2_sa_negotiate(&sa->sa_proposals,
	    &msg->msg_policy->pol_proposals, &msg->msg_proposals, 0) != 0) {
		log_info("%s: no proposal chosen", __func__);
		msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
		return (-1);
	} else if (sa_stateok(sa, IKEV2_STATE_SA_INIT))
		sa_stateflags(sa, IKED_REQ_SA);

	if (sa->sa_encr == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_ENCR, 0)) == NULL) {
			log_debug("%s: did not find encr transform", __func__);
			return (-1);
		}
		if ((sa->sa_encr = cipher_new(xform->xform_type,
		    xform->xform_id, xform->xform_length)) == NULL) {
			log_debug("%s: failed to get encr", __func__);
			return (-1);
		}
	}

	if (sa->sa_prf == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_PRF, 0)) == NULL) {
			log_debug("%s: did not find prf transform", __func__);
			return (-1);
		}
		if ((sa->sa_prf =
		    hash_new(xform->xform_type, xform->xform_id)) == NULL) {
			log_debug("%s: failed to get prf", __func__);
			return (-1);
		}
	}

	if (sa->sa_integr == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_INTEGR, 0)) == NULL) {
			log_debug("%s: did not find integr transform",
			    __func__);
			return (-1);
		}
		if ((sa->sa_integr =
		    hash_new(xform->xform_type, xform->xform_id)) == NULL) {
			log_debug("%s: failed to get integr", __func__);
			return (-1);
		}
	}

	ibuf_release(sa->sa_2ndmsg);
	if ((sa->sa_2ndmsg = ibuf_dup(msg->msg_data)) == NULL) {
		log_debug("%s: failed to copy 2nd message", __func__);
		return (-1);
	}

	return (ikev2_sa_keys(env, sa, osa ? osa->sa_key_d : NULL));
}

int
ikev2_sa_responder_dh(struct iked_kex *kex, struct iked_proposals *proposals,
    struct iked_message *msg, unsigned int proto)
{
	struct iked_transform	*xform;

	if (kex->kex_dhgroup == NULL) {
		if ((xform = config_findtransform(proposals,
		    IKEV2_XFORMTYPE_DH, proto)) == NULL) {
			log_debug("%s: did not find dh transform", __func__);
			return (-1);
		}
		if ((kex->kex_dhgroup =
		    group_get(xform->xform_id)) == NULL) {
			log_debug("%s: invalid dh %d", __func__,
			    xform->xform_id);
			return (-1);
		}
	}

	if (!ibuf_length(kex->kex_dhrexchange)) {
		if ((kex->kex_dhrexchange = ibuf_new(NULL,
		    dh_getlen(kex->kex_dhgroup))) == NULL) {
			log_debug("%s: failed to alloc dh exchange", __func__);
			return (-1);
		}
		if (dh_create_exchange(kex->kex_dhgroup,
		    kex->kex_dhrexchange->buf) == -1) {
			log_debug("%s: failed to get dh exchange", __func__);
			return (-1);
		}
	}

	if (!ibuf_length(kex->kex_dhiexchange)) {
		if ((kex->kex_dhiexchange = ibuf_dup(msg->msg_ke)) == NULL ||
		    ((ssize_t)ibuf_length(kex->kex_dhiexchange) !=
		    dh_getlen(kex->kex_dhgroup))) {
			/* XXX send notification to peer */
			log_debug("%s: invalid dh, size %d", __func__,
			    dh_getlen(kex->kex_dhgroup) * 8);
			return (-1);
		}
	}

	/* Set a pointer to the peer exchange */
	kex->kex_dhpeer = kex->kex_dhiexchange;
	return (0);
}

int
ikev2_sa_responder(struct iked *env, struct iked_sa *sa, struct iked_sa *osa,
    struct iked_message *msg)
{
	struct iked_transform	*xform;

	sa_state(env, sa, IKEV2_STATE_SA_INIT);

	ibuf_release(sa->sa_1stmsg);
	if ((sa->sa_1stmsg = ibuf_dup(msg->msg_data)) == NULL) {
		log_debug("%s: failed to copy 1st message", __func__);
		return (-1);
	}

	if (!ibuf_length(sa->sa_rnonce) &&
	    (sa->sa_rnonce = ibuf_random(IKED_NONCE_SIZE)) == NULL) {
		log_debug("%s: failed to get local nonce", __func__);
		return (-1);
	}

	if (!ibuf_length(sa->sa_inonce) &&
	    ((ibuf_length(msg->msg_nonce) < IKED_NONCE_MIN) ||
	    (sa->sa_inonce = ibuf_dup(msg->msg_nonce)) == NULL)) {
		log_debug("%s: failed to get peer nonce", __func__);
		return (-1);
	}

	/* XXX we need a better way to get this */
	if (ikev2_sa_negotiate(&sa->sa_proposals,
	    &msg->msg_policy->pol_proposals, &msg->msg_proposals, 0) != 0) {
		log_info("%s: no proposal chosen", __func__);
		msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
		return (-1);
	} else if (sa_stateok(sa, IKEV2_STATE_SA_INIT))
		sa_stateflags(sa, IKED_REQ_SA);

	if (sa->sa_encr == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_ENCR, 0)) == NULL) {
			log_debug("%s: did not find encr transform", __func__);
			return (-1);
		}
		if ((sa->sa_encr = cipher_new(xform->xform_type,
		    xform->xform_id, xform->xform_length)) == NULL) {
			log_debug("%s: failed to get encr", __func__);
			return (-1);
		}
	}

	if (sa->sa_prf == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_PRF, 0)) == NULL) {
			log_debug("%s: did not find prf transform", __func__);
			return (-1);
		}
		if ((sa->sa_prf =
		    hash_new(xform->xform_type, xform->xform_id)) == NULL) {
			log_debug("%s: failed to get prf", __func__);
			return (-1);
		}
	}

	if (sa->sa_integr == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_INTEGR, 0)) == NULL) {
			log_debug("%s: did not find integr transform",
			    __func__);
			return (-1);
		}
		if ((sa->sa_integr =
		    hash_new(xform->xform_type, xform->xform_id)) == NULL) {
			log_debug("%s: failed to get integr", __func__);
			return (-1);
		}
	}

	if (ikev2_sa_responder_dh(&sa->sa_kex, &sa->sa_proposals, msg, 0) < 0)
		return (-1);

	return (ikev2_sa_keys(env, sa, osa ? osa->sa_key_d : NULL));
}

int
ikev2_sa_keys(struct iked *env, struct iked_sa *sa, struct ibuf *key)
{
	struct iked_hash	*prf, *integr;
	struct iked_cipher	*encr;
	struct group		*group;
	struct ibuf		*ninr, *dhsecret, *skeyseed, *s, *t;
	size_t			 nonceminlen, ilen, rlen, tmplen;
	uint64_t		 ispi, rspi;
	int			 ret = -1;

	ninr = dhsecret = skeyseed = s = t = NULL;

	if ((encr = sa->sa_encr) == NULL ||
	    (prf = sa->sa_prf) == NULL ||
	    (integr = sa->sa_integr) == NULL ||
	    (group = sa->sa_dhgroup) == NULL) {
		log_debug("%s: failed to get key input data", __func__);
		return (-1);
	}

	if (prf->hash_fixedkey)
		nonceminlen = prf->hash_fixedkey;
	else
		nonceminlen = IKED_NONCE_MIN;

	/* Nonces need a minimal size and should have an even length */
	if (ibuf_length(sa->sa_inonce) < nonceminlen ||
	    (ibuf_length(sa->sa_inonce) % 2) != 0 ||
	    ibuf_length(sa->sa_rnonce) < nonceminlen ||
	    (ibuf_length(sa->sa_rnonce) % 2) != 0) {
		log_debug("%s: invalid nonces", __func__);
		return (-1);
	}

	if (prf->hash_fixedkey) {
		/* Half of the key bits must come from Ni, and half from Nr */
		ilen = prf->hash_fixedkey / 2;
		rlen = prf->hash_fixedkey / 2;
	} else {
		/* Most PRF functions accept a variable-length key */
		ilen = ibuf_length(sa->sa_inonce);
		rlen = ibuf_length(sa->sa_rnonce);
	}

	/*
	 *  Depending on whether we're generating new keying material
	 *  or rekeying existing SA the algorithm is different. If the
	 *  "key" argument is not specified a concatenation of nonces
	 *  (Ni | Nr) is used as a PRF key, otherwise a "key" buffer
	 *  is used and PRF is performed on the concatenation of DH
	 *  exchange result and nonces (g^ir | Ni | Nr).  See sections
	 *  2.14 and 2.18 of RFC5996 for more information.
	 */

	/*
	 *  Generate g^ir
	 */
	if ((dhsecret = ibuf_new(NULL, dh_getlen(group))) == NULL) {
		log_debug("%s: failed to alloc dh secret", __func__);
		goto done;
	}
	if (dh_create_shared(group, dhsecret->buf,
	    sa->sa_dhpeer->buf) == -1) {
		log_debug("%s: failed to get dh secret"
		    " group %d len %d secret %zu exchange %zu", __func__,
		    group->id, dh_getlen(group), ibuf_length(dhsecret),
		    ibuf_length(sa->sa_dhpeer));
		goto done;
	}

	if (!key) {
		/*
		 * Set PRF key to generate SKEEYSEED = prf(Ni | Nr, g^ir)
		 */
		if ((ninr = ibuf_new(sa->sa_inonce->buf, ilen)) == NULL ||
		    ibuf_add(ninr, sa->sa_rnonce->buf, rlen) != 0) {
			log_debug("%s: failed to get nonce key buffer",
			    __func__);
			goto done;
		}
		key = ninr;
	} else {
		/*
		 * Set PRF key to generate SKEEYSEED = prf(key, g^ir | Ni | Nr)
		 */
		if (ibuf_add(dhsecret, sa->sa_inonce->buf, ilen) != 0 ||
		    ibuf_add(dhsecret, sa->sa_rnonce->buf, rlen) != 0) {
			log_debug("%s: failed to get nonce key buffer",
			    __func__);
			goto done;
		}
	}

	if ((hash_setkey(prf, key->buf, ibuf_length(key))) == NULL) {
		log_debug("%s: failed to set prf key", __func__);
		goto done;
	}

	if ((skeyseed = ibuf_new(NULL, hash_length(prf))) == NULL) {
		log_debug("%s: failed to get SKEYSEED buffer", __func__);
		goto done;
	}

	tmplen = 0;
	hash_init(prf);
	hash_update(prf, dhsecret->buf, ibuf_length(dhsecret));
	hash_final(prf, skeyseed->buf, &tmplen);

	log_debug("%s: SKEYSEED with %zu bytes", __func__, tmplen);
	print_hex(skeyseed->buf, 0, tmplen);

	if (ibuf_setsize(skeyseed, tmplen) == -1) {
		log_debug("%s: failed to set keymaterial length", __func__);
		goto done;
	}

	/*
	 * Now generate the key material
	 *
	 * S = Ni | Nr | SPIi | SPIr
	 */

	/* S = Ni | Nr | SPIi | SPIr */
	ilen = ibuf_length(sa->sa_inonce);
	rlen = ibuf_length(sa->sa_rnonce);
	ispi = htobe64(sa->sa_hdr.sh_ispi);
	rspi = htobe64(sa->sa_hdr.sh_rspi);

	if ((s = ibuf_new(sa->sa_inonce->buf, ilen)) == NULL ||
	    ibuf_add(s, sa->sa_rnonce->buf, rlen) != 0 ||
	    ibuf_add(s, &ispi, sizeof(ispi)) != 0 ||
	    ibuf_add(s, &rspi, sizeof(rspi)) != 0) {
		log_debug("%s: failed to set S buffer", __func__);
		goto done;
	}

	log_debug("%s: S with %zu bytes", __func__, ibuf_length(s));
	print_hex(s->buf, 0, ibuf_length(s));

	/*
	 * Get the size of the key material we need and the number
	 * of rounds we need to run the prf+ function.
	 */
	ilen = hash_length(prf) +	/* SK_d */
	    hash_keylength(integr) +	/* SK_ai */
	    hash_keylength(integr) +	/* SK_ar */
	    cipher_keylength(encr) +	/* SK_ei */
	    cipher_keylength(encr) +	/* SK_er */
	    hash_keylength(prf) +	/* SK_pi */
	    hash_keylength(prf);	/* SK_pr */

	if ((t = ikev2_prfplus(prf, skeyseed, s, ilen)) == NULL) {
		log_debug("%s: failed to get IKE SA key material", __func__);
		goto done;
	}

	/* ibuf_get() returns a new buffer from the next read offset */
	if ((sa->sa_key_d = ibuf_get(t, hash_length(prf))) == NULL ||
	    (sa->sa_key_iauth = ibuf_get(t, hash_keylength(integr))) == NULL ||
	    (sa->sa_key_rauth = ibuf_get(t, hash_keylength(integr))) == NULL ||
	    (sa->sa_key_iencr = ibuf_get(t, cipher_keylength(encr))) == NULL ||
	    (sa->sa_key_rencr = ibuf_get(t, cipher_keylength(encr))) == NULL ||
	    (sa->sa_key_iprf = ibuf_get(t, hash_length(prf))) == NULL ||
	    (sa->sa_key_rprf = ibuf_get(t, hash_length(prf))) == NULL) {
		log_debug("%s: failed to get SA keys", __func__);
		goto done;
	}

	log_debug("%s: SK_d with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_d));
	print_hex(sa->sa_key_d->buf, 0, ibuf_length(sa->sa_key_d));
	log_debug("%s: SK_ai with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_iauth));
	print_hex(sa->sa_key_iauth->buf, 0, ibuf_length(sa->sa_key_iauth));
	log_debug("%s: SK_ar with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_rauth));
	print_hex(sa->sa_key_rauth->buf, 0, ibuf_length(sa->sa_key_rauth));
	log_debug("%s: SK_ei with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_iencr));
	print_hex(sa->sa_key_iencr->buf, 0, ibuf_length(sa->sa_key_iencr));
	log_debug("%s: SK_er with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_rencr));
	print_hex(sa->sa_key_rencr->buf, 0, ibuf_length(sa->sa_key_rencr));
	log_debug("%s: SK_pi with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_iprf));
	print_hex(sa->sa_key_iprf->buf, 0, ibuf_length(sa->sa_key_iprf));
	log_debug("%s: SK_pr with %zu bytes", __func__,
	    ibuf_length(sa->sa_key_rprf));
	print_hex(sa->sa_key_rprf->buf, 0, ibuf_length(sa->sa_key_rprf));

	ret = 0;

 done:
	ibuf_release(ninr);
	ibuf_release(dhsecret);
	ibuf_release(skeyseed);
	ibuf_release(s);
	ibuf_release(t);

	return (ret);
}

void
ikev2_sa_cleanup_dh(struct iked_sa *sa)
{
	ibuf_release(sa->sa_dhiexchange);
	ibuf_release(sa->sa_dhrexchange);
	group_free(sa->sa_dhgroup);
	sa->sa_dhiexchange = NULL;
	sa->sa_dhrexchange = NULL;
	sa->sa_dhgroup = NULL;
}

struct ibuf *
ikev2_prfplus(struct iked_hash *prf, struct ibuf *key, struct ibuf *seed,
    size_t keymatlen)
{
	struct ibuf	*t = NULL, *t1 = NULL, *t2 = NULL;
	size_t		 rlen, i, hashlen = 0;
	uint8_t		 pad = 0;

	/*
	 * prf+ (K, S) = T1 | T2 | T3 | T4 | ...
	 *
	 * T1 = prf (K, S | 0x01)
	 * T2 = prf (K, T1 | S | 0x02)
	 * T3 = prf (K, T2 | S | 0x03)
	 * T4 = prf (K, T3 | S | 0x04)
	 */

	if ((hash_setkey(prf, ibuf_data(key), ibuf_size(key))) == NULL) {
		log_debug("%s: failed to set prf+ key", __func__);
		goto fail;
	}

	if ((t = ibuf_new(NULL, 0)) == NULL) {
		log_debug("%s: failed to get T buffer", __func__);
		goto fail;
	}

	rlen = roundup(keymatlen, hash_length(prf)) / hash_length(prf);
	if (rlen > 255)
		fatalx("ikev2_prfplus: key material too large");

	for (i = 0; i < rlen; i++) {
		if (t1 != NULL) {
			t2 = ibuf_new(t1->buf, ibuf_length(t1));
			ibuf_release(t1);
		} else
			t2 = ibuf_new(NULL, 0);
		t1 = ibuf_new(NULL, hash_length(prf));

		ibuf_add(t2, seed->buf, ibuf_length(seed));
		pad = i + 1;
		ibuf_add(t2, &pad, 1);

		hash_init(prf);
		hash_update(prf, t2->buf, ibuf_length(t2));
		hash_final(prf, t1->buf, &hashlen);

		if (hashlen != hash_length(prf))
			fatalx("ikev2_prfplus: hash length mismatch");

		ibuf_release(t2);
		ibuf_add(t, t1->buf, ibuf_length(t1));

		log_debug("%s: T%d with %zu bytes", __func__,
		    pad, ibuf_length(t1));
		print_hex(t1->buf, 0, ibuf_length(t1));
	}

	log_debug("%s: Tn with %zu bytes", __func__, ibuf_length(t));
	print_hex(t->buf, 0, ibuf_length(t));

	ibuf_release(t1);

	return (t);

 fail:
	ibuf_release(t1);
	ibuf_release(t);

	return (NULL);
}

int
ikev2_sa_tag(struct iked_sa *sa, struct iked_id *id)
{
	char	*format, *domain = NULL, *idrepl = NULL;
	char	 idstr[IKED_ID_SIZE];
	int	 ret = -1;
	size_t	 len;

	free(sa->sa_tag);
	sa->sa_tag = NULL;
	format = sa->sa_policy->pol_tag;

	len = IKED_TAG_SIZE;
	if ((sa->sa_tag = calloc(1, len)) == NULL) {
		log_debug("%s: calloc", __func__);
		goto fail;
	}
	if (strlcpy(sa->sa_tag, format, len) >= len) {
		log_debug("%s: tag too long", __func__);
		goto fail;
	}

	if (ikev2_print_id(id, idstr, sizeof(idstr)) == -1) {
		log_debug("%s: invalid id", __func__);
		goto fail;
	}

	/* ASN.1 DER IDs are too long, use the CN part instead */
	if ((id->id_type == IKEV2_ID_ASN1_DN) &&
	    (idrepl = strstr(idstr, "CN=")) != NULL) {
		domain = strstr(idrepl, "emailAddress=");
		idrepl[strcspn(idrepl, "/")] = '\0';
	} else
		idrepl = idstr;

	if (strstr(format, "$id") != NULL) {
		if (expand_string(sa->sa_tag, len, "$id", idrepl) != 0) {
			log_debug("%s: failed to expand tag", __func__);
			goto fail;
		}
	}

	if (strstr(format, "$eapid") != NULL && sa->sa_eapid != NULL) {
		if (expand_string(sa->sa_tag, len, "$eapid",
		    sa->sa_eapid) != 0) {
			log_debug("%s: failed to expand tag", __func__);
			goto fail;
		}
	}

	if (strstr(format, "$name") != NULL) {
		if (expand_string(sa->sa_tag, len, "$name",
		    sa->sa_policy->pol_name) != 0) {
			log_debug("%s: failed to expand tag", __func__);
			goto fail;
		}
	}

	if (strstr(format, "$domain") != NULL) {
		if (id->id_type == IKEV2_ID_FQDN)
			domain = strchr(idrepl, '.');
		else if (id->id_type == IKEV2_ID_UFQDN)
			domain = strchr(idrepl, '@@');
		else if (*idstr == '/' && domain != NULL)
			domain = strchr(domain, '@@');
		else
			domain = NULL;
		if (domain == NULL || strlen(domain) < 2) {
			log_debug("%s: no valid domain in ID %s",
			    __func__, idstr);
			goto fail;
		}
		domain++;
		if (expand_string(sa->sa_tag, len, "$domain", domain) != 0) {
			log_debug("%s: failed to expand tag", __func__);
			goto fail;
		}
	}

	log_debug("%s: %s (%zu)", __func__, sa->sa_tag, strlen(sa->sa_tag));

	ret = 0;
 fail:
	if (ret != 0) {
		free(sa->sa_tag);
		sa->sa_tag = NULL;
	}

	return (ret);
}

int
ikev2_childsa_delete_proposed(struct iked *env, struct iked_sa *sa,
    struct iked_proposals *proposals)
{
	struct ibuf			*buf = NULL;
	struct iked_proposal		*prop;
	struct ikev2_delete		*del;
	uint32_t			 spi32;
	uint8_t				 protoid = 0;
	int				 ret = -1, count;

	if (!sa_stateok(sa, IKEV2_STATE_VALID))
		return (-1);

	count = 0;
	TAILQ_FOREACH(prop, proposals, prop_entry) {
		if (ikev2_valid_proposal(prop, NULL, NULL, NULL) != 0)
			continue;
		protoid = prop->prop_protoid;
		count++;
	}
	if (count == 0)
		return (0);
	if ((buf = ibuf_static()) == NULL)
		return (-1);
	if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
		goto done;
	/* XXX we assume all have the same protoid */
	del->del_protoid = protoid;
	del->del_spisize = 4;
	del->del_nspi = htobe16(count);

	TAILQ_FOREACH(prop, proposals, prop_entry) {
		if (ikev2_valid_proposal(prop, NULL, NULL, NULL) != 0)
			continue;
		spi32 = htobe32(prop->prop_localspi.spi);
		if (ibuf_add(buf, &spi32, sizeof(spi32)))
			goto done;
	}

	if (ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
	    IKEV2_EXCHANGE_INFORMATIONAL, 0) == -1)
		goto done;
	sa->sa_stateflags |= IKED_REQ_INF;
	ret = 0;
 done:
	ibuf_release(buf);

	return (ret);
}

int
ikev2_childsa_negotiate(struct iked *env, struct iked_sa *sa,
    struct iked_kex *kex, struct iked_proposals *proposals, int initiator,
    int pfs, int acquired)
{
	struct iked_proposal	*prop;
	struct iked_transform	*xform, *encrxf = NULL, *integrxf = NULL;
	struct iked_childsa	*csa, *csb;
	struct iked_flow	*flow, *saflow, *flowa, *flowb;
	struct ibuf		*keymat = NULL, *seed = NULL, *dhsecret = NULL;
	struct group		*group;
	uint32_t		 spi = 0;
	unsigned int		 i;
	size_t			 ilen = 0;
	int			 esn, skip, ret = -1;

	if (!sa_stateok(sa, IKEV2_STATE_VALID))
		return (-1);

	if (ikev2_sa_tag(sa, IKESA_DSTID(sa)) == -1)
		return (-1);

	/* We need to determine the key material length first */
	TAILQ_FOREACH(prop, proposals, prop_entry) {
		if (prop->prop_protoid == IKEV2_SAPROTO_IKE)
			continue;
		log_debug("%s: proposal %d", __func__, prop->prop_id);
		for (i = 0; i < prop->prop_nxforms; i++) {
			xform = prop->prop_xforms + i;
			xform->xform_keylength =
			    keylength_xf(prop->prop_protoid,
			    xform->xform_type, xform->xform_id);

			switch (xform->xform_type) {
			case IKEV2_XFORMTYPE_ENCR:
			case IKEV2_XFORMTYPE_INTEGR:
				if (xform->xform_length)
					xform->xform_keylength =
					    xform->xform_length;
				xform->xform_keylength +=
				    noncelength_xf(xform->xform_type,
				    xform->xform_id);
				ilen += xform->xform_keylength / 8;
				break;
			}
		}
	}

	/* double key material length for inbound/outbound */
	ilen *= 2;

	log_debug("%s: key material length %zu", __func__, ilen);

	if ((seed = ibuf_new(NULL, 0)) == NULL) {
		log_debug("%s: failed to setup IKE SA key material", __func__);
		goto done;
	}
	if (pfs) {
		log_debug("%s: using PFS", __func__);
		if (kex->kex_dhpeer == NULL ||
		    ibuf_length(kex->kex_dhpeer) == 0 ||
		    (group = kex->kex_dhgroup) == NULL) {
			log_debug("%s: no dh group for pfs", __func__);
			goto done;
		}
		if ((dhsecret = ibuf_new(NULL, dh_getlen(group))) == NULL) {
			log_debug("%s: failed to alloc dh secret", __func__);
			goto done;
		}
		if (dh_create_shared(group, dhsecret->buf,
		    kex->kex_dhpeer->buf) == -1) {
			log_debug("%s: failed to get dh secret"
			    " group %d len %d secret %zu exchange %zu",
			    __func__, group->id, dh_getlen(group),
			    ibuf_length(dhsecret),
			    ibuf_length(kex->kex_dhpeer));
			goto done;
		}
		if (ibuf_cat(seed, dhsecret) != 0) {
			log_debug("%s: failed to set dh secret", __func__);
			goto done;
		}
	}
	if (ibuf_cat(seed, kex->kex_inonce) != 0 ||
	    ibuf_cat(seed, kex->kex_rnonce) != 0 ||
	    (keymat = ikev2_prfplus(sa->sa_prf,
	    sa->sa_key_d, seed, ilen)) == NULL) {
		log_debug("%s: failed to get IKE SA key material", __func__);
		goto done;
	}

	/* Create the new flows */
	TAILQ_FOREACH(prop, proposals, prop_entry) {
		if (ikev2_valid_proposal(prop, NULL, NULL, NULL) != 0)
			continue;

		RB_FOREACH(flow, iked_flows, &sa->sa_policy->pol_flows) {

			if ((flowa = calloc(1, sizeof(*flowa))) == NULL) {
				log_debug("%s: failed to get flow", __func__);
				goto done;
			}

			memcpy(flowa, flow, sizeof(*flow));
			flowa->flow_dir = IPSP_DIRECTION_OUT;
			flowa->flow_saproto = prop->prop_protoid;
			flowa->flow_local = &sa->sa_local;
			flowa->flow_peer = &sa->sa_peer;
			flowa->flow_ikesa = sa;
			ikev2_cp_fixaddr(sa, &flow->flow_dst, &flowa->flow_dst);

			skip = 0;
			TAILQ_FOREACH(saflow, &sa->sa_flows, flow_entry) {
				if (flow_equal(saflow, flowa)) {
					skip = 1;
					break;
				}
			}
			if (skip) {
				flow_free(flowa);
				continue;
			}

			if ((flowb = calloc(1, sizeof(*flowb))) == NULL) {
				log_debug("%s: failed to get flow", __func__);
				flow_free(flowa);
				goto done;
			}

			memcpy(flowb, flowa, sizeof(*flow));

			flowb->flow_dir = IPSP_DIRECTION_IN;
			memcpy(&flowb->flow_src, &flow->flow_dst,
			    sizeof(flow->flow_dst));
			memcpy(&flowb->flow_dst, &flow->flow_src,
			    sizeof(flow->flow_src));
			ikev2_cp_fixaddr(sa, &flow->flow_dst, &flowb->flow_src);

			TAILQ_INSERT_TAIL(&sa->sa_flows, flowa, flow_entry);
			TAILQ_INSERT_TAIL(&sa->sa_flows, flowb, flow_entry);
		}
	}

	/* create the CHILD SAs using the key material */
	TAILQ_FOREACH(prop, proposals, prop_entry) {
		if (ikev2_valid_proposal(prop, &encrxf, &integrxf, &esn) != 0)
			continue;

		spi = 0;

		if ((csa = calloc(1, sizeof(*csa))) == NULL) {
			log_debug("%s: failed to get CHILD SA", __func__);
			goto done;
		}

		csa->csa_saproto = prop->prop_protoid;
		csa->csa_ikesa = sa;
		csa->csa_spi.spi_protoid = prop->prop_protoid;
		csa->csa_esn = esn;
		csa->csa_acquired = acquired;

		/* Set up responder's SPIs */
		if (initiator) {
			csa->csa_dir = IPSP_DIRECTION_OUT;
			csa->csa_local = &sa->sa_local;
			csa->csa_peer = &sa->sa_peer;
			csa->csa_peerspi = prop->prop_localspi.spi;
			csa->csa_spi.spi = prop->prop_peerspi.spi;
			csa->csa_spi.spi_size = prop->prop_peerspi.spi_size;
		} else {
			csa->csa_dir = IPSP_DIRECTION_IN;
			csa->csa_local = &sa->sa_peer;
			csa->csa_peer = &sa->sa_local;

			if ((ret = pfkey_sa_init(env->sc_pfkey, csa,
			    &spi)) != 0)
				goto done;
			csa->csa_allocated = 1;

			csa->csa_peerspi = prop->prop_peerspi.spi;
			csa->csa_spi.spi = prop->prop_localspi.spi = spi;
			csa->csa_spi.spi_size = 4;
		}

		if (encrxf && (csa->csa_encrkey = ibuf_get(keymat,
		    encrxf->xform_keylength / 8)) == NULL) {
			log_debug("%s: failed to get CHILD SA encryption key",
			    __func__);
			childsa_free(csa);
			goto done;
		}
		if (integrxf && (csa->csa_integrkey = ibuf_get(keymat,
		    integrxf->xform_keylength / 8)) == NULL) {
			log_debug("%s: failed to get CHILD SA integrity key",
			    __func__);
			childsa_free(csa);
			goto done;
		}
		if (encrxf)
			csa->csa_encrid = encrxf->xform_id;
		if (integrxf)
			csa->csa_integrid = integrxf->xform_id;

		if ((csb = calloc(1, sizeof(*csb))) == NULL) {
			log_debug("%s: failed to get CHILD SA", __func__);
			childsa_free(csa);
			goto done;
		}

		memcpy(csb, csa, sizeof(*csb));

		/* Set up initiator's SPIs */
		csb->csa_spi.spi = csa->csa_peerspi;
		csb->csa_peerspi = csa->csa_spi.spi;
		csb->csa_allocated = csa->csa_allocated ? 0 : 1;
		csb->csa_dir = csa->csa_dir == IPSP_DIRECTION_IN ?
		    IPSP_DIRECTION_OUT : IPSP_DIRECTION_IN;
		csb->csa_local = csa->csa_peer;
		csb->csa_peer = csa->csa_local;

		if (encrxf && (csb->csa_encrkey = ibuf_get(keymat,
		    encrxf->xform_keylength / 8)) == NULL) {
			log_debug("%s: failed to get CHILD SA encryption key",
			    __func__);
			childsa_free(csa);
			childsa_free(csb);
			goto done;
		}
		if (integrxf && (csb->csa_integrkey = ibuf_get(keymat,
		    integrxf->xform_keylength / 8)) == NULL) {
			log_debug("%s: failed to get CHILD SA integrity key",
			    __func__);
			childsa_free(csa);
			childsa_free(csb);
			goto done;
		}

		TAILQ_INSERT_TAIL(&sa->sa_childsas, csa, csa_entry);
		TAILQ_INSERT_TAIL(&sa->sa_childsas, csb, csa_entry);

		csa->csa_peersa = csb;
		csb->csa_peersa = csa;
	}

	ret = 0;
 done:
	ibuf_release(dhsecret);
	ibuf_release(keymat);
	ibuf_release(seed);

	return (ret);
}

/* free a replaced IPCOMP SA */
void
ikev2_ipcomp_csa_free(struct iked *env, struct iked_childsa *csa)
{
	if (csa->csa_children)
		fatalx("ikev2_ipcomp_csa_free: has children");
	if (csa->csa_ikesa)
		TAILQ_REMOVE(&csa->csa_ikesa->sa_childsas, csa,
		    csa_entry);
	if (csa->csa_loaded) {
		log_debug("%s: csa %p loaded: calling pfkey_sa_delete",
		    __func__, csa);
		pfkey_sa_delete(env->sc_pfkey, csa);
		RB_REMOVE(iked_activesas, &env->sc_activesas, csa);
	}
	childsa_free(csa);
}

int
ikev2_ipcomp_enable(struct iked *env, struct iked_sa *sa)
{
	struct iked_childsa	*other, *nother, *csa = NULL, *csb = NULL;
	struct iked_flow	*flow, *flowa = NULL, *flowb = NULL;
	struct iked_flow	*nflow, *oflow;

	if ((csa = calloc(1, sizeof(*csa))) == NULL ||
	    (csb = calloc(1, sizeof(*csb))) == NULL ||
	    (flowa = calloc(1, sizeof(*flowa))) == NULL ||
	    (flowb = calloc(1, sizeof(*flowb))) == NULL) {
		free(csa);
		free(csb);
		free(flowa);
		free(flowb);
		return (-1);
	}

	/* switch ESP SAs to transport mode */
	TAILQ_FOREACH(other, &sa->sa_childsas, csa_entry) {
		if (!other->csa_rekey && !other->csa_loaded &&
		    other->csa_saproto == IKEV2_SAPROTO_ESP) {
			other->csa_transport = 1;
			if (other->csa_dir == IPSP_DIRECTION_OUT) {
				other->csa_parent = csa;
				csa->csa_children++;
			} else {
				other->csa_parent = csb;
				csb->csa_children++;
			}
		}
	}

	/* install IPCOMP SAs */
	csa->csa_ikesa = sa;
	csa->csa_saproto = IKEV2_SAPROTO_IPCOMP;
	csa->csa_spi.spi_size = 2;
	csa->csa_spi.spi = sa->sa_cpi_out;
	csa->csa_peerspi = sa->sa_cpi_in;
	csa->csa_dir = IPSP_DIRECTION_OUT;
	csa->csa_local = &sa->sa_local;
	csa->csa_peer = &sa->sa_peer;

	memcpy(csb, csa, sizeof(*csb));
	csb->csa_spi.spi = csa->csa_peerspi;
	csb->csa_peerspi = csa->csa_spi.spi;
	csb->csa_dir = IPSP_DIRECTION_IN;
	csb->csa_local = csa->csa_peer;
	csb->csa_peer = csa->csa_local;
	csb->csa_allocated = 1;

	/* remove old replaced IPCOMP SAs */
	TAILQ_FOREACH_SAFE(other, &sa->sa_childsas, csa_entry, nother) {
		if (other->csa_saproto != IKEV2_SAPROTO_IPCOMP ||
		    other->csa_children != 0)
			continue;
		if (other->csa_dir == csa->csa_dir &&
		    IKED_ADDR_EQ(other->csa_local, csa->csa_local) &&
		    IKED_ADDR_EQ(other->csa_peer, csa->csa_peer)) {
			log_debug("%s: csa %p replaces %p",
			    __func__, csa, other);
			ikev2_ipcomp_csa_free(env, other);
		} else if (other->csa_dir == csb->csa_dir &&
		    IKED_ADDR_EQ(other->csa_local, csb->csa_local) &&
		    IKED_ADDR_EQ(other->csa_peer, csb->csa_peer)) {
			log_debug("%s: csa %p replaces %p",
			    __func__, csb, other);
			ikev2_ipcomp_csa_free(env, other);
		}
	}

	TAILQ_INSERT_TAIL(&sa->sa_childsas, csa, csa_entry);
	TAILQ_INSERT_TAIL(&sa->sa_childsas, csb, csa_entry);

	csa->csa_peersa = csb;
	csb->csa_peersa = csa;

	/* redirect flows to IPCOMP */
	/* XXX expensive? should be merged into ikev2_childsa_negotiate() */
	TAILQ_FOREACH_SAFE(flow, &sa->sa_flows, flow_entry, nflow) {
		if (flow->flow_loaded || flow->flow_ipcomp ||
		    flow->flow_saproto != IKEV2_SAPROTO_ESP)
			continue;
		TAILQ_FOREACH(oflow, &sa->sa_flows, flow_entry)
			if (flow != oflow &&
			    IKED_ADDR_EQ(&oflow->flow_src, &flow->flow_src) &&
			    IKED_ADDR_EQ(&oflow->flow_dst, &flow->flow_dst) &&
			    oflow->flow_dir == flow->flow_dir &&
			    oflow->flow_saproto == IKEV2_SAPROTO_IPCOMP)
				break;
		if (oflow != NULL) {
			log_debug("%s: keeping oflow %p, indentical to flow %p",
			    __func__, oflow, flow);
			TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
			flow_free(flow);
		} else {
			log_debug("%s: flow %p saproto %d -> %d", __func__,
			    flow, flow->flow_saproto, IKEV2_SAPROTO_IPCOMP);
			flow->flow_saproto = IKEV2_SAPROTO_IPCOMP;
		}
	}

	/* setup ESP flows for gateways */
	flowa->flow_ipcomp = 1;
	flowa->flow_dir = IPSP_DIRECTION_OUT;
	flowa->flow_saproto = IKEV2_SAPROTO_ESP;
	flowa->flow_local = &sa->sa_local;
	flowa->flow_peer = &sa->sa_peer;
	memcpy(&flowa->flow_src, &sa->sa_local, sizeof(sa->sa_local));
	memcpy(&flowa->flow_dst, &sa->sa_peer, sizeof(sa->sa_peer));
	socket_setport((struct sockaddr *)&flowa->flow_src.addr, 0);
	socket_setport((struct sockaddr *)&flowa->flow_dst.addr, 0);
	flowa->flow_src.addr_port = flowa->flow_dst.addr_port = 0;
	flowa->flow_src.addr_mask = flowa->flow_dst.addr_mask =
	    (sa->sa_local.addr_af == AF_INET) ? 32 : 128;
	flowa->flow_ikesa = sa;

	/* skip if flow already exists */
	TAILQ_FOREACH(flow, &sa->sa_flows, flow_entry) {
		if (flow_equal(flow, flowa)) {
			free(flowa);
			free(flowb);
			goto done;
		}
	}

	memcpy(flowb, flowa, sizeof(*flowb));
	flowb->flow_dir = IPSP_DIRECTION_IN;
	memcpy(&flowb->flow_dst, &flowa->flow_src, sizeof(flowa->flow_src));
	memcpy(&flowb->flow_src, &flowa->flow_dst, sizeof(flowa->flow_dst));

	TAILQ_INSERT_TAIL(&sa->sa_flows, flowa, flow_entry);
	TAILQ_INSERT_TAIL(&sa->sa_flows, flowb, flow_entry);

 done:
	/* make sure IPCOMP CPIs are not reused */
	sa->sa_ipcomp = 0;
	sa->sa_cpi_in = sa->sa_cpi_out = 0;

	return (0);
}

int
ikev2_childsa_enable(struct iked *env, struct iked_sa *sa)
{
	struct iked_childsa	*csa, *ocsa;
	struct iked_flow	*flow, *oflow;

	if (sa->sa_ipcomp && sa->sa_cpi_in && sa->sa_cpi_out &&
	    ikev2_ipcomp_enable(env, sa) == -1)
		return (-1);

	TAILQ_FOREACH(csa, &sa->sa_childsas, csa_entry) {
		if (csa->csa_rekey || csa->csa_loaded)
			continue;

		if (pfkey_sa_add(env->sc_pfkey, csa, NULL) != 0) {
			log_debug("%s: failed to load CHILD SA spi %s",
			    __func__, print_spi(csa->csa_spi.spi,
			    csa->csa_spi.spi_size));
			return (-1);
		}

		if ((ocsa = RB_FIND(iked_activesas, &env->sc_activesas, csa))
		    != NULL) {
			log_debug("%s: replaced CHILD SA %p with %p spi %s",
			    __func__, ocsa, csa, print_spi(ocsa->csa_spi.spi,
			    ocsa->csa_spi.spi_size));
			ocsa->csa_loaded = 0;
			ocsa->csa_rekey = 1;	/* prevent re-loading */
			RB_REMOVE(iked_activesas, &env->sc_activesas, ocsa);
		}

		RB_INSERT(iked_activesas, &env->sc_activesas, csa);

		log_debug("%s: loaded CHILD SA spi %s", __func__,
		    print_spi(csa->csa_spi.spi, csa->csa_spi.spi_size));
	}

	TAILQ_FOREACH(flow, &sa->sa_flows, flow_entry) {
		if (flow->flow_loaded)
			continue;

		if (pfkey_flow_add(env->sc_pfkey, flow) != 0) {
			log_debug("%s: failed to load flow", __func__);
			return (-1);
		}

		if ((oflow = RB_FIND(iked_flows, &env->sc_activeflows, flow))
		    != NULL) {
			log_debug("%s: replaced old flow %p with %p",
			    __func__, oflow, flow);
			oflow->flow_loaded = 0;
			RB_REMOVE(iked_flows, &env->sc_activeflows, oflow);
		}

		RB_INSERT(iked_flows, &env->sc_activeflows, flow);

		log_debug("%s: loaded flow %p", __func__, flow);
	}

	return (0);
}

int
ikev2_childsa_delete(struct iked *env, struct iked_sa *sa, uint8_t saproto,
    uint64_t spi, uint64_t *spiptr, int cleanup)
{
	struct iked_childsa	*csa, *nextcsa = NULL;
	uint64_t		 peerspi = 0;
	int			 found = 0, ipcomp = 0;

	for (csa = TAILQ_FIRST(&sa->sa_childsas); csa != NULL; csa = nextcsa) {
		nextcsa = TAILQ_NEXT(csa, csa_entry);

		if ((saproto && csa->csa_saproto != saproto) ||
		    (spi && (csa->csa_spi.spi != spi &&
			     csa->csa_peerspi != spi)) ||
		    (cleanup && csa->csa_loaded))
			continue;

		if (csa->csa_loaded)
			RB_REMOVE(iked_activesas, &env->sc_activesas, csa);

		if (pfkey_sa_delete(env->sc_pfkey, csa) != 0)
			log_debug("%s: failed to delete CHILD SA spi %s",
			    __func__, print_spi(csa->csa_spi.spi,
			    csa->csa_spi.spi_size));
		else
			log_debug("%s: deleted CHILD SA spi %s", __func__,
			    print_spi(csa->csa_spi.spi,
			    csa->csa_spi.spi_size));
		found++;

		if (spi && csa->csa_spi.spi == spi)
			peerspi = csa->csa_peerspi;

		if (csa->csa_parent && csa->csa_parent->csa_children == 1)
			ipcomp = 1;
		TAILQ_REMOVE(&sa->sa_childsas, csa, csa_entry);
		childsa_free(csa);
	}

	/* lookup and delete matching IPcomp SAs */
	if (ipcomp) {
		for (csa = TAILQ_FIRST(&sa->sa_childsas); csa != NULL;
		    csa = nextcsa) {
			nextcsa = TAILQ_NEXT(csa, csa_entry);
			if (csa->csa_saproto == IKEV2_SAPROTO_IPCOMP &&
			    csa->csa_children == 0)
				ikev2_ipcomp_csa_free(env, csa);
		}
	}

	if (spiptr)
		*spiptr = peerspi;

	return (found ? 0 : -1);
}

int
ikev2_valid_proposal(struct iked_proposal *prop,
    struct iked_transform **exf, struct iked_transform **ixf, int *esn)
{
	struct iked_transform	*xform, *encrxf, *integrxf;
	unsigned int		 i, doesn = 0;

	switch (prop->prop_protoid) {
	case IKEV2_SAPROTO_ESP:
	case IKEV2_SAPROTO_AH:
		break;
	default:
		return (-1);
	}

	encrxf = integrxf = NULL;
	for (i = 0; i < prop->prop_nxforms; i++) {
		xform = prop->prop_xforms + i;
		if (xform->xform_type == IKEV2_XFORMTYPE_ENCR)
			encrxf = xform;
		else if (xform->xform_type == IKEV2_XFORMTYPE_INTEGR)
			integrxf = xform;
		else if (xform->xform_type == IKEV2_XFORMTYPE_ESN &&
		    xform->xform_id == IKEV2_XFORMESN_ESN)
			doesn = 1;
	}

	if (prop->prop_protoid == IKEV2_SAPROTO_IKE) {
		if (encrxf == NULL || integrxf == NULL)
			return (-1);
	} else if (prop->prop_protoid == IKEV2_SAPROTO_AH) {
		if (integrxf == NULL)
			return (-1);
	} else if (prop->prop_protoid == IKEV2_SAPROTO_ESP) {
		if (encrxf == NULL)
			return (-1);
	}

	if (exf)
		*exf = encrxf;
	if (ixf)
		*ixf = integrxf;
	if (esn)
		*esn = doesn;

	return (0);
}

/* return 0 if processed, -1 if busy */
int
ikev2_acquire_sa(struct iked *env, struct iked_flow *acquire)
{
	struct iked_flow	*flow;
	struct iked_sa		*sa;
	struct iked_policy	 pol, *p = NULL;

	if (env->sc_passive)
		return (0);

	/* First try to find an active flow with IKE SA */
	flow = RB_FIND(iked_flows, &env->sc_activeflows, acquire);
	if (!flow) {
		/* Otherwise try to find a matching policy */
		bzero(&pol, sizeof(pol));
		pol.pol_af = acquire->flow_peer->addr_af;
		memcpy(&pol.pol_peer, acquire->flow_peer,
		    sizeof(pol.pol_peer));

		RB_INIT(&pol.pol_flows);
		RB_INSERT(iked_flows, &pol.pol_flows, acquire);
		pol.pol_nflows = 1;

		if ((p = policy_test(env, &pol)) == NULL) {
			log_warnx("%s: flow wasn't found", __func__);
			return (0);
		}

		log_debug("%s: found matching policy '%s'", __func__,
		    p->pol_name);

		if (ikev2_init_ike_sa_peer(env, p,
		    acquire->flow_peer, NULL) != 0)
			log_warnx("%s: failed to initiate a "
			    "IKE_SA_INIT exchange", __func__);
	} else {
		log_debug("%s: found active flow", __func__);

		if ((sa = flow->flow_ikesa) == NULL) {
			log_warnx("%s: flow without SA", __func__);
			return (0);
		}
		if (sa->sa_stateflags & IKED_REQ_CHILDSA)
			return (-1);	/* busy, retry later */
		if (ikev2_send_create_child_sa(env, sa, NULL,
		    flow->flow_saproto) != 0)
			log_warnx("%s: failed to initiate a "
			    "CREATE_CHILD_SA exchange", __func__);
	}
	return (0);
}

void
ikev2_disable_rekeying(struct iked *env, struct iked_sa *sa)
{
	struct iked_childsa		*csa;

	TAILQ_FOREACH(csa, &sa->sa_childsas, csa_entry) {
		csa->csa_persistent = 1;
		csa->csa_rekey = 0;
	}

	(void)ikev2_childsa_delete(env, sa, 0, 0, NULL, 1);
}

/* return 0 if processed, -1 if busy */
int
ikev2_rekey_sa(struct iked *env, struct iked_spi *rekey)
{
	struct iked_childsa		*csa, key;
	struct iked_sa			*sa;

	key.csa_spi = *rekey;
	csa = RB_FIND(iked_activesas, &env->sc_activesas, &key);
	if (!csa)
		return (0);

	if (csa->csa_rekey)	/* See if it's already taken care of */
		return (0);
	if (csa->csa_acquired)	/* Don't rekey, wait for hard expire */
		return (0);
	if (csa->csa_saproto == IKEV2_SAPROTO_IPCOMP)	/* no rekey */
		return (0);
	if ((sa = csa->csa_ikesa) == NULL) {
		log_warnx("%s: SA %s doesn't have a parent SA", __func__,
		    print_spi(rekey->spi, rekey->spi_size));
		return (0);
	}
	if (!sa_stateok(sa, IKEV2_STATE_ESTABLISHED)) {
		log_warnx("%s: SA %s is not established", __func__,
		    print_spi(rekey->spi, rekey->spi_size));
		return (0);
	}
	if (sa->sa_stateflags & IKED_REQ_CHILDSA)
		return (-1);	/* busy, retry later */
	if (csa->csa_allocated)	/* Peer SPI died first, get the local one */
		rekey->spi = csa->csa_peerspi;
	if (ikev2_send_create_child_sa(env, sa, rekey, rekey->spi_protoid))
		log_warnx("%s: failed to initiate a CREATE_CHILD_SA exchange",
		    __func__);
	return (0);
}

/* return 0 if processed, -1 if busy */
int
ikev2_drop_sa(struct iked *env, struct iked_spi *drop)
{
	struct ibuf			*buf = NULL;
	struct iked_childsa		*csa, key;
	struct iked_sa			*sa;
	struct ikev2_delete		*del;
	uint32_t			 spi32;
	int				 acquired;

	key.csa_spi = *drop;
	csa = RB_FIND(iked_activesas, &env->sc_activesas, &key);
	if (!csa || csa->csa_rekey)
		return (0);

	sa = csa->csa_ikesa;
	if (csa->csa_saproto != IKEV2_SAPROTO_IPCOMP &&
	    sa && (sa->sa_stateflags & IKED_REQ_CHILDSA)) {
		/* XXXX might loop, should we add a counter? */
		log_debug("%s: parent SA busy", __func__);
		return (-1);	/* busy, retry later */
	}

	RB_REMOVE(iked_activesas, &env->sc_activesas, csa);
	csa->csa_loaded = 0;
	csa->csa_rekey = 1;	/* prevent re-loading */
	if (sa == NULL) {
		log_debug("%s: failed to find a parent SA", __func__);
		return (0);
	}
	if (csa->csa_saproto == IKEV2_SAPROTO_IPCOMP) {
		/* matching Child SAs (e.g. ESP) should have expired by now */
		if (csa->csa_children == 0)
			ikev2_ipcomp_csa_free(env, csa);
		return (0);
	}

	if (csa->csa_allocated)
		spi32 = htobe32(csa->csa_spi.spi);
	else
		spi32 = htobe32(csa->csa_peerspi);
	acquired = csa->csa_acquired;

	if (ikev2_childsa_delete(env, sa, csa->csa_saproto,
	    csa->csa_peerspi, NULL, 0))
		log_debug("%s: failed to delete CHILD SA %s", __func__,
		    print_spi(csa->csa_peerspi, drop->spi_size));

	/* Send PAYLOAD_DELETE */

	if ((buf = ibuf_static()) == NULL)
		return (0);
	if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
		goto done;
	del->del_protoid = drop->spi_protoid;
	del->del_spisize = 4;
	del->del_nspi = htobe16(1);
	if (ibuf_add(buf, &spi32, sizeof(spi32)))
		goto done;

	if (ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
	    IKEV2_EXCHANGE_INFORMATIONAL, 0) == -1)
		goto done;

	sa->sa_stateflags |= IKED_REQ_INF;

	/* Don't automatically re-initiate Child SAs that have been acquired */
	if (acquired)
		goto done;

	/* Initiate Child SA creation */
	if (ikev2_send_create_child_sa(env, sa, NULL, drop->spi_protoid))
		log_warnx("%s: failed to initiate a CREATE_CHILD_SA exchange",
		    __func__);

done:
	ibuf_release(buf);
	return (0);
}

int
ikev2_print_id(struct iked_id *id, char *idstr, size_t idstrlen)
{
	uint8_t				 buf[BUFSIZ], *ptr;
	struct sockaddr_in		*s4;
	struct sockaddr_in6		*s6;
	char				*str;
	ssize_t				 len;
	int				 i;
	const char			*type;

	bzero(buf, sizeof(buf));
	bzero(idstr, idstrlen);

	if (id->id_buf == NULL)
		return (-1);

	len = ibuf_size(id->id_buf);
	ptr = ibuf_data(id->id_buf);

	if (len <= id->id_offset)
		return (-1);

	len -= id->id_offset;
	ptr += id->id_offset;

	type = print_map(id->id_type, ikev2_id_map);

	if (strlcpy(idstr, type, idstrlen) >= idstrlen ||
	    strlcat(idstr, "/", idstrlen) >= idstrlen)
		return (-1);

	idstr += strlen(idstr);
	idstrlen -= strlen(idstr);

	switch (id->id_type) {
	case IKEV2_ID_IPV4:
		s4 = (struct sockaddr_in *)buf;
		s4->sin_family = AF_INET;
		s4->sin_len = sizeof(*s4);
		memcpy(&s4->sin_addr.s_addr, ptr, len);

		if (print_host((struct sockaddr *)s4,
		    idstr, idstrlen) == NULL)
			return (-1);
		break;
	case IKEV2_ID_FQDN:
	case IKEV2_ID_UFQDN:
		if (len >= (ssize_t)sizeof(buf))
			return (-1);

		if ((str = get_string(ptr, len)) == NULL)
			return (-1);

		if (strlcpy(idstr, str, idstrlen) >= idstrlen) {
			free(str);
			return (-1);
		}
		free(str);
		break;
	case IKEV2_ID_IPV6:
		s6 = (struct sockaddr_in6 *)buf;
		s6->sin6_family = AF_INET6;
		s6->sin6_len = sizeof(*s6);
		memcpy(&s6->sin6_addr, ptr, len);

		if (print_host((struct sockaddr *)s6,
		    idstr, idstrlen) == NULL)
			return (-1);
		break;
	case IKEV2_ID_ASN1_DN:
		if ((str = ca_asn1_name(ptr, len)) == NULL)
			return (-1);
		if (strlcpy(idstr, str, idstrlen) >= idstrlen) {
			free(str);
			return (-1);
		}
		free(str);
		break;
	default:
		/* XXX test */
		for (i = 0; i < ((ssize_t)idstrlen - 1) && i < len; i++)
			snprintf(idstr + i, idstrlen - i,
			    "%02x", ptr[i]);
		break;
	}

	return (0);
}

/*
 * If we have an IKEV2_CP_REQUEST for IKEV2_CFG_INTERNAL_IP4_ADDRESS and
 * if a network(pool) is configured, then select an address from that pool
 * and remember it in the sa_addrpool attribute.
 */
int
ikev2_cp_setaddr(struct iked *env, struct iked_sa *sa, sa_family_t family)
{
	struct iked_cfg		*ikecfg = NULL;
	struct iked_policy	*pol = sa->sa_policy;
	struct sockaddr_in	*in4 = NULL, *cfg4 = NULL;
	struct sockaddr_in6	*in6 = NULL, *cfg6 = NULL;
	struct iked_sa		 key;
	struct iked_addr	 addr;
	uint32_t		 mask, host, lower, upper, start, nhost;
	size_t			 i;

	switch (family) {
		case AF_INET:
			if (sa->sa_addrpool)
				return (0);
			break;
		case AF_INET6:
			if (sa->sa_addrpool6)
				return (0);
			break;
		default:
			return (-1);
	}
	if (pol->pol_ncfg == 0)
		return (0);
	/* check for an address pool config (address w/ prefixlen != 32) */
	bzero(&addr, sizeof(addr));
	for (i = 0; i < pol->pol_ncfg; i++) {
		ikecfg = &pol->pol_cfg[i];
		if (family == AF_INET &&
		    ikecfg->cfg_type == IKEV2_CFG_INTERNAL_IP4_ADDRESS &&
		    ikecfg->cfg.address.addr_mask != 32) {
			addr.addr_af = AF_INET;
			break;
		}
		if (family == AF_INET6 &&
		    ikecfg->cfg_type == IKEV2_CFG_INTERNAL_IP6_ADDRESS &&
		    ikecfg->cfg.address.addr_mask != 128) {
			addr.addr_af = AF_INET6;
			break;
		}
	}
	if (i == pol->pol_ncfg)
		return (0);

	/*
	 * failure: pool configured, but not requested.
	 * If we continue, we might end up with flows where 0.0.0.0 is NOT
	 * replaced with an address from the pool with ikev2_cp_fixaddr().
	 */
	if (sa->sa_cp != IKEV2_CP_REQUEST) {
		log_debug("%s: pool configured, but IKEV2_CP_REQUEST missing",
		    __func__);
		return (-1);
	}

	switch (addr.addr_af) {
	case AF_INET:
		cfg4 = (struct sockaddr_in *)&ikecfg->cfg.address.addr;
		in4 = (struct sockaddr_in *)&addr.addr;
		in4->sin_family = AF_INET;
		in4->sin_len = sizeof(*in4);
		mask = prefixlen2mask(ikecfg->cfg.address.addr_mask);
		lower = ntohl(cfg4->sin_addr.s_addr & ~mask);
		key.sa_addrpool = &addr;
		break;
	case AF_INET6:
		cfg6 = (struct sockaddr_in6 *)&ikecfg->cfg.address.addr;
		in6 = (struct sockaddr_in6 *)&addr.addr;
		in6->sin6_family = AF_INET6;
		in6->sin6_len = sizeof(*in6);
		/* truncate prefixlen to get a 32-bit space */
		mask = (ikecfg->cfg.address.addr_mask >= 96)
		    ? prefixlen2mask(ikecfg->cfg.address.addr_mask - 96)
		    : prefixlen2mask(0);
		memcpy(&lower, &cfg6->sin6_addr.s6_addr[12], sizeof(uint32_t));
		lower = ntohl(lower & ~mask);
		key.sa_addrpool6 = &addr;
		break;
	default:
		return (-1);
	}

	if (lower == 0)
		lower = 1;
	/* Note that start, upper and host are in HOST byte order */
	upper = ntohl(~mask);
	/* Randomly select start from [lower, upper-1] */
	start = arc4random_uniform(upper - lower) + lower;

	for (host = start;;) {
		log_debug("%s: mask %x start %x lower %x host %x upper %x",
		    __func__, mask, start, lower, host, upper);
		switch (addr.addr_af) {
		case AF_INET:
			in4->sin_addr.s_addr =
			    (cfg4->sin_addr.s_addr & mask) | htonl(host);
			break;
		case AF_INET6:
			memcpy(in6, cfg6, sizeof(*in6));
			nhost = htonl(host);
			memcpy(&in6->sin6_addr.s6_addr[12], &nhost,
			    sizeof(uint32_t));
			break;
		}
		if ((addr.addr_af == AF_INET &&
		    !RB_FIND(iked_addrpool, &env->sc_addrpool, &key)) ||
		    (addr.addr_af == AF_INET6 &&
		    !RB_FIND(iked_addrpool6, &env->sc_addrpool6, &key)))
			break;
		/* try next address */
		host++;
		/* but skip broadcast and network address */
		if (host >= upper || host < lower)
			host = lower;
		if (host == start) {
			log_warnx("%s: address pool exhausted", __func__);
			return (-1);		/* exhausted */
		}
	}

	switch (addr.addr_af) {
	case AF_INET:
		if (!key.sa_addrpool)
			return (-1);			/* cannot happen? */
		if ((sa->sa_addrpool = calloc(1, sizeof(addr))) == NULL)
			return (-1);
		memcpy(sa->sa_addrpool, &addr, sizeof(addr));
		RB_INSERT(iked_addrpool, &env->sc_addrpool, sa);
		break;
	case AF_INET6:
		if (!key.sa_addrpool6)
			return (-1);			/* cannot happen? */
		if ((sa->sa_addrpool6 = calloc(1, sizeof(addr))) == NULL)
			return (-1);
		memcpy(sa->sa_addrpool6, &addr, sizeof(addr));
		RB_INSERT(iked_addrpool6, &env->sc_addrpool6, sa);
		break;
	default:
		return (-1);
	}
	return (0);
}

/*
 * if 'addr' is 'UNSPECIFIED' replace it with sa_addrpool from
 * the ip-pool and store the result in 'patched'.
 */
int
ikev2_cp_fixaddr(struct iked_sa *sa, struct iked_addr *addr,
    struct iked_addr *patched)
{
	struct sockaddr_in	*in4;
	struct sockaddr_in6	*in6;

	switch (addr->addr_af) {
	case AF_INET:
		if (sa->sa_addrpool == NULL)
			return (-1);
		in4 = (struct sockaddr_in *)&addr->addr;
		if (in4->sin_addr.s_addr)
			return (-1);
		memcpy(patched, sa->sa_addrpool, sizeof(*patched));
		break;
	case AF_INET6:
		if (sa->sa_addrpool6 == NULL)
			return (-1);
		in6 = (struct sockaddr_in6 *)&addr->addr;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6->sin6_addr))
			return (-1);
		memcpy(patched, sa->sa_addrpool6, sizeof(*patched));
		break;
	}
	return (0);
}
@


1.154
log
@cope with IP address changes. before, we were trying to resend the msg
with the no-longer-available address over and over and over, requiring
iked to be restarted eventually. instead, on EADDRNOTAVAIL, schedule
SA deletion so a new one is set up shortly thereafter. ok reyk mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.153 2017/04/13 07:04:09 patrick Exp $	*/
d4558 8
@


1.153
log
@Add a NAT-T keepalive timer in case we are behind a NAT gateway.

See RFC 5996, section 2.23, NAT Traversal:
  In the case of a mismatching NAT_DETECTION_DESTINATION_IP hash, it
  means that the system receiving the NAT_DETECTION_DESTINATION_IP
  payload is behind a NAT and that system SHOULD start sending
  keepalive packets as defined in [UDPENCAPS].

With markus@@, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.152 2017/03/30 15:48:30 patrick Exp $	*/
a89 1
void	 ikev2_ike_sa_timeout(struct iked *env, void *);
@


1.152
log
@Only close the SA if an error happens before ikev2_msg_init() was called
to make sure we do not run ikev2_msg_cleanup() on an unitialized stack
variable.

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.151 2017/03/28 16:25:21 reyk Exp $	*/
d92 1
d1204 4
d2481 4
d3154 1
d3239 4
d3251 1
d3642 20
@


1.151
log
@Don't send informational responses before we're having the key material.

iked starts sending keepalive messages after authentication and after
successfully completing the handshake.  Other implementations, like
we've seen on Microsoft Azure, start sending keepalive messages right
after receiving the first SA_INIT message when they set up the key
material, even before we received the SA_INIT response to complete the
DH exchange.  The solution is to ignore early keepalive messages
before we're ready to encrypt our response, in the transition between
SA_INIT and AUTH.  The peer should still accept one or more missed
keepalives.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.150 2017/03/28 16:15:33 reyk Exp $	*/
d907 1
a907 1
		return (-1);
d912 1
a912 1
		goto done;
d916 1
a916 1
			goto done;
d1031 2
a1036 1
	ikev2_msg_cleanup(env, &req);
@


1.150
log
@Returning -1 in an imsg handler like ikev2_dispatch_cert aborts iked.

-1 means "I didn't handle or know this imsg", it should not be used to
indicate an application error in this context.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.149 2017/03/27 17:17:49 mikeb Exp $	*/
d2150 2
a2151 1
		if (!msg->msg_responded && !msg->msg_error) {
@


1.149
log
@Don't cache the DH group in the policy

When tearing IKE SA down, the DH group referred by it is destroyed,
however it remains cached in the policy.  With the introduction of
IKE SA rekeying we have extended the life of this dangling pointer
by reusing it on new SAs.  So instead of caching the pointer in the
policy we can store the DH group ID and create a DH group on demand
using this parameter if it's specified.

With and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.148 2017/03/27 10:43:53 mikeb Exp $	*/
d262 1
a262 1
			return (-1);
@


1.148
log
@Factor out flows into separate configuration messages

We reach an imsg payload limit with just a few traffic selectors
so in order to load more we need to split them up and send separately.

Suggested and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.147 2017/03/27 10:29:02 reyk Exp $	*/
d903 6
a908 2
	/* XXX free old sa_dhgroup ? */
	sa->sa_dhgroup = pol->pol_peerdh;
@


1.147
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.146 2017/03/27 10:24:36 reyk Exp $	*/
d198 2
@


1.146
log
@Fix another iked leak of SAs in pfkey_sa(), copy tags correctly.

Diff from markus@@
OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.145 2017/03/27 10:21:19 reyk Exp $	*/
d5305 1
a5305 1
	int			 	 acquired;
@


1.145
log
@Add support to reflect the responder IKEv2 COOKIE.

This fixes connecting to Azure VPN and other implementations that
implement the IKEv2 COOKIE mechanism on the responder side.  Azure
decides to send you a responder COOKIE after too many connection
attempts - we have to keep it and reflect it to establish a
connection.  This implementation is only for the initiator (client)
side, we do not support sending COOKIEs on the responder (server) side
yet.

OK patrick@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.144 2017/03/27 10:06:41 reyk Exp $	*/
d3210 5
@


1.144
log
@Add support for RFC4754 (ECDSA) and RFC7427 authentication.

These modes provide stronger and more flexible ways for
authentication: while RSA public key auth relies on SHA-1 hashes, the
news modes use SHA2-256 and up to SHA2-512 hashes.

Original diff from markus@@ with patches from mikeb@@ and me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.143 2017/03/13 18:49:20 mikeb Exp $	*/
d66 1
a66 1
	    struct iked_addr *);
d737 1
d803 8
d845 1
a845 1
		if (ikev2_init_ike_sa_peer(env, pol, &pol->pol_peer))
d870 1
a870 1
    struct iked_addr *peer)
d877 3
a879 2
	struct iked_sa			*sa;
	struct ibuf			*buf;
d889 6
d896 2
a897 1
	if ((sa = sa_new(env, 0, 0, 1, pol)) == NULL)
d903 1
d930 2
a931 1
	    IKEV2_PAYLOAD_SA, IKEV2_EXCHANGE_IKE_SA_INIT, 0)) == NULL)
d934 21
d5219 2
a5220 1
		if (ikev2_init_ike_sa_peer(env, p, acquire->flow_peer) != 0)
@


1.143
log
@Resolve simultaneous Child SA rekeying

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.142 2017/03/13 18:48:16 mikeb Exp $	*/
d326 1
d502 1
a502 1
ikev2_ike_auth_compatible(struct iked_sa *sa, uint8_t want, uint8_t have)
d504 3
a506 4
	if (want == have)
		return (0);
	if (sa->sa_sigsha2 &&
	    have == IKEV2_AUTH_SIG && want == IKEV2_AUTH_RSA_SIG)
d508 27
d622 4
a625 2
			log_warnx("%s: unexpected auth method %s", __func__,
			    print_map(msg->msg_auth.id_type, ikev2_auth_map));
d1209 1
d1217 1
d1230 1
d1239 1
@


1.142
log
@Resolve simultaneous IKE SA rekeying

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.141 2017/03/13 18:28:02 reyk Exp $	*/
d109 2
d2283 2
a2284 1
	else if (!sa_stateok(sa, IKEV2_STATE_VALID))
d2977 19
d3030 2
d3035 5
d3213 1
a3213 1
	struct iked_childsa		*csa;
d3363 13
d4485 51
d4951 1
a4951 1
	struct iked_childsa	*csa;
d4967 10
@


1.141
log
@Make sure that proposal contains a DH group when rekeying with PFS enabled

Via markus, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.140 2017/03/13 17:41:14 reyk Exp $	*/
d84 1
d2731 5
d2807 1
a2807 1
		sa->sa_next = nsa;
d2823 15
d2843 1
a2843 1
	struct iked_sa			*nsa;
d2847 1
d2879 1
a2879 1
		if (sa->sa_next == NULL) {
d2884 1
d2886 2
a2887 2
		if ((nsa = sa_new(env, sa->sa_next->sa_hdr.sh_ispi,
		    spi->spi, 1, NULL)) == NULL || nsa != sa->sa_next) {
d2891 2
a2892 2
			sa_free(env, sa->sa_next);
			sa->sa_next = NULL;
d2900 37
a2936 1
		sa->sa_next = NULL;
d3036 4
d3081 2
d3087 2
d3093 2
d3160 21
d3401 15
a3415 3
	if (protoid == IKEV2_SAPROTO_IKE)
		ret = ikev2_ikesa_enable(env, sa, nsa);
	else
@


1.140
log
@NAT-T improvements

Move repeated creation of the NAT-T payload into a function, remove
erroneous msg_offset, and improve NAT-T handling.

From and OK markus, OK mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.139 2017/03/13 17:23:45 mikeb Exp $	*/
d109 1
a109 1
	    struct iked_transform **);
d643 3
a645 2
		    &sa->sa_policy->pol_proposals, &msg->msg_proposals) != 0) {
			log_debug("%s: no proposal chosen", __func__);
d2840 1
a2840 1
	    &msg->msg_proposals) != 0) {
d3171 4
a3174 2
		    &sa->sa_policy->pol_proposals, &msg->msg_proposals) != 0) {
			log_debug("%s: no proposal chosen", __func__);
d3535 1
a3535 1
    struct iked_transform **xforms)
d3538 1
a3538 1
	unsigned int		 i, j, type, score;
d3545 11
d3593 2
a3594 1
		    (i == IKEV2_XFORMTYPE_ENCR || i == IKEV2_XFORMTYPE_ESN)) {
d3606 5
d3613 1
a3613 1
    struct iked_proposals *peer)
d3637 2
a3638 1
			score = ikev2_match_proposals(plocal, ppeer, match);
d3784 2
a3785 2
	    &msg->msg_policy->pol_proposals, &msg->msg_proposals) != 0) {
		log_debug("%s: no proposal chosen", __func__);
d3918 2
a3919 2
	    &msg->msg_policy->pol_proposals, &msg->msg_proposals) != 0) {
		log_debug("%s: no proposal chosen", __func__);
@


1.139
log
@Don't rekey acquired Child SAs

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.138 2017/03/13 15:06:51 patrick Exp $	*/
d137 2
a834 1
	struct ikev2_notify		*n;
a837 1
	uint8_t				*ptr;
d922 2
a923 28

		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
			goto done;

		/* NAT-T notify payloads */
		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;
		if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
			goto done;
		n->n_type = htobe16(IKEV2_N_NAT_DETECTION_SOURCE_IP);
		len = ikev2_nat_detection(env, &req, NULL, 0, 0);
		if ((ptr = ibuf_advance(buf, len)) == NULL)
			goto done;
		if ((len = ikev2_nat_detection(env, &req, ptr, len,
		    betoh16(n->n_type))) == -1)
			goto done;
		len += sizeof(*n);

		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
			goto done;

		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;
		if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
			goto done;
		n->n_type = htobe16(IKEV2_N_NAT_DETECTION_DESTINATION_IP);
		len = ikev2_nat_detection(env, &req, NULL, 0, 0);
		if ((ptr = ibuf_advance(buf, len)) == NULL)
a924 4
		if ((len = ikev2_nat_detection(env, &req, ptr, len,
		    betoh16(n->n_type))) == -1)
			goto done;
		len += sizeof(*n);
d1663 44
a2085 1
	struct ikev2_notify		*n;
a2088 1
	uint8_t				*ptr;
d2149 2
a2150 1
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
a2151 30

		/* NAT-T notify payloads */
		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;
		if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
			goto done;
		n->n_type = htobe16(IKEV2_N_NAT_DETECTION_SOURCE_IP);
		len = ikev2_nat_detection(env, &resp, NULL, 0, 0);
		if ((ptr = ibuf_advance(buf, len)) == NULL)
			goto done;
		if ((len = ikev2_nat_detection(env, &resp, ptr, len,
		    betoh16(n->n_type))) == -1)
			goto done;
		len += sizeof(*n);

		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
			goto done;

		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;
		if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
			goto done;
		n->n_type = htobe16(IKEV2_N_NAT_DETECTION_DESTINATION_IP);
		len = ikev2_nat_detection(env, &resp, NULL, 0, 0);
		if ((ptr = ibuf_advance(buf, len)) == NULL)
			goto done;
		if ((len = ikev2_nat_detection(env, &resp, ptr, len,
		    betoh16(n->n_type))) == -1)
			goto done;
		len += sizeof(*n);
a2152 1

@


1.138
log
@When setting up IPcomp flows for the networks 'A' and 'B' between
gateways 'a' and 'b', we replace the ESP flow "A->B ESP" with an
IPCOMP flow "A->B IPCOMP" and add a matching (transport mode) ESP
flow between the gateways "a->b ESP".  The later is now marked with
flow_ipcomp so it is not translated into "a->b IPCOMP" on rekeying.

When SAs get deleted we do an extra loop to figure out if matching
IPcomp SAs can now be removed, too.  This allows faster expiry of
unused IPcomp SAs.

Disable bytes lifetime for IP compression.

ok markus@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.137 2017/03/13 14:57:55 reyk Exp $	*/
d107 1
a107 1
	    struct iked_kex *, struct iked_proposals *, int, int);
d1144 1
a1144 1
	    sa->sa_hdr.sh_initiator, 0);
d2305 1
a2305 1
	    sa->sa_hdr.sh_initiator, 0) < 0)
d2933 1
a2933 1
	    pfs)) {
d3254 2
a3255 1
		if (ikev2_childsa_negotiate(env, sa, kex, &proposals, 0, pfs)) {
d4340 1
a4340 1
    int pfs)
d4496 1
d4985 2
d5018 1
d5051 1
d5075 4
@


1.137
log
@Fix and improve the IKE SA rekeying timeout, add a randomized jitter.

Diff from markus@@ with a small tweak from me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.136 2017/03/13 14:50:52 mikeb Exp $	*/
d4686 1
a4686 1
		if (flow->flow_loaded ||
d4709 1
d4806 1
a4806 1
	int			 found = 0;
d4833 2
d4839 11
d5021 4
a5024 1
	if (sa && (sa->sa_stateflags & IKED_REQ_CHILDSA))
d5026 1
@


1.136
log
@Improve reporting of authentication errors

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.135 2017/03/13 14:33:33 patrick Exp $	*/
d64 1
d87 2
d178 8
a185 3
		timer_set(env, &env->sc_inittmr, ikev2_init_ike_sa,
		    NULL);
		timer_add(env, &env->sc_inittmr, IKED_INITIATOR_INITIAL);
d812 12
d977 4
d1149 2
d1155 1
a1155 1
			timer_add(env, &sa->sa_rekey, sa->sa_policy->pol_rekey);
d1974 5
d2404 2
d2410 1
a2410 1
			timer_add(env, &sa->sa_rekey, sa->sa_policy->pol_rekey);
d2743 3
a2745 1
	log_debug("%s: called for IKE SA %p", __func__, sa);
d2756 4
d3064 1
a3064 1
		timer_add(env, &nsa->sa_rekey, nsa->sa_policy->pol_rekey);
d3354 16
d3884 1
@


1.135
log
@flow_cmp() must compare the same flow-attributes as the kernel,
otherwise we never can keep the in-daemon and the in-kernel idea
of flows in sync and iked ends up deleting flows that are still
in use.  Make use of flow_cmp() and a new flow_equal() instead
of handcrafting the compare in an if.

ok markus@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.134 2017/02/24 11:23:02 patrick Exp $	*/
d75 3
d246 2
a248 1

d602 1
d2018 2
a2019 1
		(void)ikev2_resp_create_child_sa(env, msg);
d2180 70
a2252 1
	struct ikev2_notify		*n;
a2285 16
	if (!sa_stateok(sa, IKEV2_STATE_VALID)) {
		/* Notify payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		firstpayload = IKEV2_PAYLOAD_NOTIFY;

		if ((n = ibuf_advance(e, sizeof(*n))) == NULL)
			goto done;
		n->n_protoid = IKEV2_SAPROTO_IKE;	/* XXX ESP etc. */
		n->n_spisize = 0;
		n->n_type = htobe16(IKEV2_N_AUTHENTICATION_FAILED);
		len = sizeof(*n);

		goto send;
	}

a2363 1
 send:
d3185 1
d3192 1
@


1.134
log
@In a scenario where a config reload happens during an IKE_AUTH exchange,
and we move an SA from one to another policy, we need to make sure to do
refcounting if the policies involved are already in the garbage collect
phase.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.133 2017/01/20 14:12:32 mikeb Exp $	*/
a4316 14
			skip = 0;
			TAILQ_FOREACH(saflow, &sa->sa_flows, flow_entry) {
				if (IKED_ADDR_EQ(&saflow->flow_src,
				    &flow->flow_src) &&
				    IKED_ADDR_EQ(&saflow->flow_dst,
				    &flow->flow_dst) &&
				    saflow->flow_saproto ==
				    prop->prop_protoid) {
					skip = 1;
					break;
				}
			}
			if (skip)
				continue;
d4331 12
d4574 2
a4575 1
			if (IKED_ADDR_EQ(&oflow->flow_src, &flow->flow_src) &&
d4608 1
a4608 4
		if (IKED_ADDR_EQ(&flow->flow_src, &flowa->flow_src) &&
		    IKED_ADDR_EQ(&flow->flow_dst, &flowa->flow_dst) &&
		    flow->flow_dir == flowa->flow_dir &&
		    flow->flow_saproto == flowa->flow_saproto) {
@


1.133
log
@Add a warning when the address pool is exhausted

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.132 2017/01/20 13:51:08 mikeb Exp $	*/
d523 4
@


1.132
log
@Verify the certificate imsg payload size

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.131 2016/06/02 07:14:26 patrick Exp $	*/
d5157 2
a5158 1
		if (host == start)
d5160 1
@


1.131
log
@Use the last 32-bits of the IPv6 address to dynamically assign
addresses from the pool, instead of the fourth byte, which usually
represents network bits.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.130 2016/06/01 11:16:41 patrick Exp $	*/
d225 3
@


1.130
log
@Implement a second address pool specifically for IPv6, so that
clients can be given an IPv4 and IPv6 address at the same time,
thus enabling dual stack usage.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.129 2016/06/01 10:52:28 patrick Exp $	*/
d5047 1
a5047 1
	uint32_t		 mask, host, lower, upper, start;
a5094 3
	/* truncate prefixlen in the v6 case */
	mask = prefixlen2mask(ikecfg->cfg.address.addr_mask);

d5101 1
d5110 6
a5115 1
		lower = cfg6->sin6_addr.s6_addr[3];
d5139 3
a5141 1
			in6->sin6_addr.s6_addr[3] = htonl(host);
@


1.129
log
@ikev2_cp_fixaddr() is called to replace unspecified (e.g. 0.0.0.0)
addresses by specified (e.g. 192.0.2.1) ones.  The function should
return if the address is already set.  The check was wrong for the
IPv6 case, as it returned if it's not set.  This caused the address
to never be fixed.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.128 2015/10/22 15:55:18 reyk Exp $	*/
d125 1
a125 1
int	 ikev2_cp_setaddr(struct iked *, struct iked_sa *);
d1742 3
a1744 3
			    sa->sa_addrpool &&
			    sa->sa_addrpool->addr_af == AF_INET6) ?
			    (struct sockaddr_in6 *)&sa->sa_addrpool->addr :
d2187 2
a2188 1
	if (ikev2_cp_setaddr(env, sa) < 0)
d2947 6
d5039 1
a5039 1
ikev2_cp_setaddr(struct iked *env, struct iked_sa *sa)
d5050 13
a5062 1
	if (sa->sa_addrpool || pol->pol_ncfg == 0)
d5068 2
a5069 1
		if (ikecfg->cfg_type == IKEV2_CFG_INTERNAL_IP4_ADDRESS &&
d5074 2
a5075 1
		if (ikecfg->cfg_type == IKEV2_CFG_INTERNAL_IP6_ADDRESS &&
d5105 1
d5113 1
a5125 2
	key.sa_addrpool = &addr;

d5139 4
a5142 1
		if (!RB_FIND(iked_addrpool, &env->sc_addrpool, &key))
d5152 19
a5170 3
	if (!key.sa_addrpool)
		return (-1);			/* cannot happen? */
	if ((sa->sa_addrpool = calloc(1, sizeof(addr))) == NULL)
d5172 1
a5172 2
	memcpy(sa->sa_addrpool, &addr, sizeof(addr));
	RB_INSERT(iked_addrpool, &env->sc_addrpool, sa);
a5186 3
	if (sa->sa_addrpool == NULL ||
	    sa->sa_addrpool->addr_af != addr->addr_af)
		return (-1);
d5189 2
d5194 1
d5197 2
d5202 1
a5204 1
	memcpy(patched, sa->sa_addrpool, sizeof(*patched));
@


1.128
log
@iked hereby pledges that it will run with restricted system
operations.  This adds pledge(2) too all processes, including the iked
parent process; the existing privsep design has been improved for
better pledgeability.  There haven't been any serious problems as it
was already sane (eg. by receiving the PFKEYv2 and UDP sockets via fd
passing).  The control socket moved to an independent process to
remove some abilities from the cert process.

Committed in agreement with many but nobody was brave enough to OK it.

Better testing will happen with having it in the tree.
"It's the truth" deraadt@@
"Let's see what happens" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.127 2015/10/19 11:25:35 reyk Exp $	*/
d5159 1
a5159 1
		if (IN6_IS_ADDR_UNSPECIFIED(&in6->sin6_addr))
@


1.127
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.126 2015/10/15 18:40:38 mmcc Exp $	*/
d48 1
d140 15
a154 1
	return (proc_run(ps, p, procs, nitems(procs), NULL, NULL));
@


1.126
log
@Remove some unnecessary NULL-checks before free(). Change two bzero()
calls on pf data to explicit_bzero().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.125 2015/10/02 16:13:43 reyk Exp $	*/
a48 1
int	 ikev2_dispatch_ikev1(int, struct privsep_proc *, struct imsg *);
a132 1
	{ "ikev1",	PROC_IKEV1,	ikev2_dispatch_ikev1 },
a170 33
	default:
		break;
	}

	return (-1);
}

int
ikev2_dispatch_ikev1(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked		*env = p->p_env;
	struct iked_message	 msg;
	uint8_t			*buf;
	ssize_t			 len;

	switch (imsg->hdr.type) {
	case IMSG_IKE_MESSAGE:
		log_debug("%s: message", __func__);
		IMSG_SIZE_CHECK(imsg, &msg);
		memcpy(&msg, imsg->data, sizeof(msg));

		len = IMSG_DATA_SIZE(imsg) - sizeof(msg);
		buf = (uint8_t *)imsg->data + sizeof(msg);
		if (len <= 0 || (msg.msg_data = ibuf_new(buf, len)) == NULL) {
			log_debug("%s: short message", __func__);
			return (0);
		}

		log_debug("%s: message length %zd", __func__, len);

		ikev2_recv(env, &msg);
		ikev2_msg_cleanup(env, &msg);
		return (0);
@


1.125
log
@If the policy certreqtype is 0, use the global one instead.
This fixes EAP (user-based auth) with IKEv2 in El Capitan.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.124 2015/10/01 10:59:23 reyk Exp $	*/
d4151 1
a4151 2
	if (sa->sa_tag != NULL)
		free(sa->sa_tag);
@


1.124
log
@Fix interoperability with Apple iOS9: If we don't get a (valid)
CERTREQ but a CERT, respond with a local CERT that was selected based
on our own policy instead of leaving it out.  This seems to be valid
with the RFC that makes the CERTREQ optional and allows to ignore it
or to apply an own policy.

OK mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.123 2015/08/21 11:59:27 reyk Exp $	*/
d656 1
d680 4
d685 1
a685 1
			    &pol->pol_localid, pol->pol_certreqtype,
@


1.123
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.122 2015/08/19 14:12:43 reyk Exp $	*/
d655 2
d669 18
@


1.122
log
@spacing (no binary change, verified with checksums)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.121 2015/07/07 19:13:31 markus Exp $	*/
d54 1
a54 1
	    u_int8_t *, u_int8_t **, size_t *);
d57 1
a57 1
int	 ikev2_ike_auth_compatible(struct iked_sa *, u_int8_t, u_int8_t);
d77 1
a77 1
	    struct iked_spi *, u_int8_t);
d90 2
a91 1
int	 ikev2_sa_initiator_dh(struct iked_sa *, struct iked_message *, u_int);
d93 1
a93 1
	    struct iked_message *, u_int);
d97 2
a98 1
int	 ikev2_set_sa_proposal(struct iked_sa *, struct iked_policy *, u_int);
d108 1
a108 1
	    struct iked_proposals *, u_int8_t, int, int);
d111 1
a111 1
	    u_int8_t, u_int8_t, u_int16_t, u_int16_t);
d115 1
a115 1
	    struct ibuf *, u_int8_t);
d118 1
a118 1
ssize_t	 ikev2_add_ts_payload(struct ibuf *, u_int, struct iked_sa *);
d185 1
a185 1
	u_int8_t		*buf;
d195 1
a195 1
		buf = (u_int8_t *)imsg->data + sizeof(msg);
d219 2
a220 2
	u_int8_t		 type;
	u_int8_t		*ptr;
d246 1
a246 1
		memcpy(&type, (u_int8_t *)imsg->data + sizeof(sh),
d350 1
a350 1
    u_int8_t *type, u_int8_t **buf, size_t *size)
d352 1
a352 1
	u_int8_t	*ptr;
d388 1
a388 1
	u_int			 initiator, flag = 0;
d501 1
a501 1
ikev2_ike_auth_compatible(struct iked_sa *sa, u_int8_t want, u_int8_t have)
d800 1
a800 1
	u_int8_t			*ptr;
d987 1
a987 1
	u_int8_t			 firstpayload;
d1129 1
a1129 1
	u_int8_t		*p;
d1207 2
a1208 2
    u_int32_t msgid, u_int8_t nextpayload,
    u_int8_t exchange, u_int8_t flags)
d1235 1
a1235 1
	u_int32_t	 hdrlength = sizeof(*hdr) + length;
d1264 1
a1264 1
ikev2_add_ts_payload(struct ibuf *buf, u_int type, struct iked_sa *sa)
d1272 1
a1272 1
	u_int8_t		*ptr;
d1274 1
a1274 1
	u_int32_t		 av[4], bv[4], mv[4];
d1402 1
a1402 1
    struct ibuf *certreq, u_int8_t type)
d1440 4
a1443 4
	u_int8_t			*ptr;
	u_int16_t			 cpi;
	u_int32_t			 spi;
	u_int8_t			 transform;
d1462 1
a1462 1
	cpi = htobe16((u_int16_t)spi);
d1491 1
a1491 1
	u_int8_t			*ptr;
d1493 1
a1493 1
	u_int16_t			 hash, signature_hashes[] = {
d1528 1
a1528 1
    u_int8_t nextpayload)
d1548 1
a1548 1
    void *ptr, size_t len, u_int type)
d1552 2
a1553 2
	u_int8_t		 md[SHA_DIGEST_LENGTH];
	u_int			 mdlen = sizeof(md);
d1559 1
a1559 1
	u_int64_t		 rspi, ispi;
d1562 1
a1562 1
	u_int32_t		 rnd;
d1656 2
a1657 2
	u_int			 i;
	u_int32_t		 mask4;
d1661 1
a1661 1
	u_int8_t		 prefixlen;
d1764 1
a1764 1
    struct iked_proposals *proposals, u_int8_t protoid, int initiator,
d1772 3
a1774 3
	u_int64_t			 spi64;
	u_int32_t			 spi32, spi;
	u_int				 i;
d1856 1
a1856 1
    u_int8_t more, u_int8_t type, u_int16_t id, u_int16_t length)
d2027 1
a2027 1
	u_int8_t			*ptr;
d2170 1
a2170 1
	u_int8_t			 firstpayload;
d2324 1
a2324 1
	u_int8_t			 firstpayload;
d2403 1
a2403 1
    u_int8_t firstpayload, u_int8_t exchange, int response)
d2436 1
a2436 1
    u_int proto)
d2440 1
a2440 1
	u_int				 i;
d2463 1
a2463 1
    struct iked_spi *rekey, u_int8_t protoid)
d2472 3
a2474 3
	u_int8_t			*ptr;
	u_int8_t			 firstpayload;
	u_int32_t			 spi;
d2599 1
a2599 1
		spi = htobe32((u_int32_t)csa->csa_peerspi);
d2733 1
a2733 1
	u_int32_t			 spi32;
d3004 1
a3004 1
	u_int8_t			 firstpayload;
d3241 1
a3241 1
	u_int64_t			 last_used, diff;
d3252 1
a3252 1
		diff = (u_int32_t)(tv.tv_sec - last_used);
d3393 2
a3394 2
ikev2_psk(struct iked_sa *sa, u_int8_t *data, size_t length,
    u_int8_t **pskptr)
d3396 1
a3396 1
	u_int8_t	*psk;
d3418 2
a3419 2
	u_int			 i, j, type, score;
	u_int8_t		 protoid = peer->prop_protoid;
d3482 2
a3483 2
	u_int			 i, score, chosen_score = 0;
	u_int8_t		 protoid = 0;
d3554 2
a3555 1
ikev2_sa_initiator_dh(struct iked_sa *sa, struct iked_message *msg, u_int proto)
d3704 1
a3704 1
    struct iked_message *msg, u_int proto)
d3840 1
a3840 1
	u_int64_t		 ispi, rspi;
d4052 1
a4052 1
	u_int8_t	 pad = 0;
d4213 2
a4214 2
	u_int32_t		 spi = 0;
	u_int			 i;
d4670 2
a4671 2
ikev2_childsa_delete(struct iked *env, struct iked_sa *sa, u_int8_t saproto,
    u_int64_t spi, u_int64_t *spiptr, int cleanup)
d4674 1
a4674 1
	u_int64_t		 peerspi = 0;
d4717 1
a4717 1
	u_int			 i, doesn = 0;
d4869 1
a4869 1
	u_int32_t			 spi32;
d4935 1
a4935 1
	u_int8_t			 buf[BUFSIZ], *ptr;
d5036 1
a5036 1
	u_int32_t		 mask, host, lower, upper, start;
@


1.121
log
@repair policy-ikesa-linking by replacing the broken RB_TREE w/TAILQ
(e.g. the policy might be used-after-free on 'ikectl reconfig')
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.120 2015/03/26 19:52:35 markus Exp $	*/
d536 2
a537 1
			TAILQ_INSERT_TAIL(&policy->pol_sapeers, sa, sa_peer_entry);
d2436 3
a2438 3
	struct iked_proposal	 	*prop, *copy;
	struct iked_transform	 	*xform;
	u_int			 	 i;
d2962 2
a2963 2
	struct ibuf                     *buf = NULL;
	struct ikev2_delete             *del;
d2996 1
a2996 1
	struct iked_kex		 	*kex, *kextmp = NULL;
d4258 2
a4259 1
		if (kex->kex_dhpeer == NULL || ibuf_length(kex->kex_dhpeer) == 0 ||
d4271 3
a4273 2
			    " group %d len %d secret %zu exchange %zu", __func__,
			    group->id, dh_getlen(group), ibuf_length(dhsecret),
@


1.120
log
@initial support for RFC 7427 signatures, so we are no longer
restricted to SHA1 for RSA signatures. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.119 2015/02/06 10:39:01 deraadt Exp $	*/
d476 2
a477 4
	if (sa_address(sa, &sa->sa_peer, &msg->msg_peer,
	    sa->sa_hdr.sh_initiator) == -1 ||
	    sa_address(sa, &sa->sa_local, &msg->msg_local,
	    sa->sa_hdr.sh_initiator) == -1)
d533 1
a533 12
			log_debug("%s: policy switch %p/%s to %p/%s",
			    __func__, old, old->pol_name,
			    msg->msg_policy, msg->msg_policy->pol_name);
			RB_REMOVE(iked_sapeers, &old->pol_sapeers, sa);
			if (RB_INSERT(iked_sapeers,
			    &msg->msg_policy->pol_sapeers, sa)) {
				/* failed, restore */
				log_debug("%s: conflicting sa", __func__);
				RB_INSERT(iked_sapeers, &old->pol_sapeers, sa);
				msg->msg_policy = old;
			} else
				policy_unref(env, old);
d535 2
d765 1
a765 1
		if (sa_peer_lookup(pol, &pol->pol_peer.addr) != NULL) {
a933 6
	memcpy(&sa->sa_polpeer, &pol->pol_peer, sizeof(sa->sa_polpeer));
	if (RB_INSERT(iked_sapeers, &pol->pol_sapeers, sa)) {
		log_debug("%s: conflicting sa", __func__);
		goto done;
	}

a2865 1
	int				 initiator;
a2874 23

	/*
	 * Transfer policy and address:
	 * - Remember if we initiated the original IKE-SA because of our policy.
	 * - Note that sa_address() will insert the new SA when we set sa_peer.
	 */
	initiator = !memcmp(&sa->sa_polpeer, &sa->sa_policy->pol_peer,
	    sizeof(sa->sa_polpeer));
	nsa->sa_policy = sa->sa_policy;
	RB_REMOVE(iked_sapeers, &sa->sa_policy->pol_sapeers, sa);
	sa->sa_policy = NULL;
	if (sa_address(nsa, &nsa->sa_peer, &sa->sa_peer.addr,
	    initiator) == -1 ||
	    sa_address(nsa, &nsa->sa_local, &sa->sa_local.addr,
	    initiator) == -1) {
		/* reinsert old SA :/ */
		sa->sa_policy = nsa->sa_policy;
		if (RB_FIND(iked_sapeers, &nsa->sa_policy->pol_sapeers, nsa))
			RB_REMOVE(iked_sapeers, &nsa->sa_policy->pol_sapeers, nsa);
		RB_INSERT(iked_sapeers, &sa->sa_policy->pol_sapeers, sa);
		nsa->sa_policy = NULL;
		return (-1);
	}
@


1.119
log
@unneeded getopt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.118 2015/01/16 06:39:58 deraadt Exp $	*/
d57 1
d127 3
d501 11
d597 2
a598 1
		if (msg->msg_auth.id_type != ikeauth.auth_method) {
d600 1
a600 1
			    print_map(ikeauth.auth_method, ikev2_auth_map));
d603 1
d928 3
d1500 40
d2147 4
@


1.118
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.117 2014/12/05 13:40:44 mikeb Exp $	*/
a32 1
#include <getopt.h>
@


1.117
log
@Store return value of i2d_X509_NAME in a signed integer to make
sure the negative error gets treated correctly and doesn't get
accidentally promoted to a huge unsigned value.

From Pedro Martelletto, thanks!  OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.116 2014/11/07 14:12:57 mikeb Exp $	*/
d19 1
a19 1
#include <sys/param.h>
@


1.116
log
@Fixup a few problems with EAP state transition

First of all we don't need to satisfy valid EAP state flags for
IKEV2_STATE_EAP as it's an initial EAP exchange state.  Then
when waiting for the "ca" process to construct our AUTH payload
we need to bail while sa_localauth is not available.  With this
change Win7 is able to establish the the tunnel again.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.115 2014/11/07 14:02:32 mikeb Exp $	*/
d1125 1
a1125 1
	size_t			 len;
@


1.115
log
@Repair initiator with PSK auth

Attempt state transition to VALID (or EAP_VALID) in the
ikev2_ike_auth after we have completed authentication
synchronously (PSK) or asynchronously (X.509 and RSA)
eliminating the need to do so in multiple places and
restoring the correct order for PSK.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.114 2014/07/09 12:05:01 markus Exp $	*/
a2278 3
	if (!sa_stateok(sa, IKEV2_STATE_EAP))
		return (0);

d2282 4
@


1.114
log
@expire IPcomp SAs too; ok mikeb (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.113 2014/05/13 14:24:35 markus Exp $	*/
a252 1
			sa_state(env, sa, IKEV2_STATE_VALID);
a331 2
		/* Switch in case we already have certvalid or authvalid */
		sa_state(env, sa, IKEV2_STATE_VALID);
d627 1
a627 1
			sa_state(env, sa, IKEV2_STATE_EAP_VALID);
d640 1
d647 6
@


1.113
log
@pass SA initiator not the exchange initator to sa_address(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.112 2014/05/09 06:37:24 markus Exp $	*/
a4482 1
	csa->csa_persistent = 1;
d4806 2
d4852 6
@


1.112
log
@get rid of redundant {csa,flow}_{src,dst}id pointers, so we don't need
to update it on rekey (fixes use-after-free); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.111 2014/05/09 06:29:46 markus Exp $	*/
d432 4
d476 4
a479 2
	if (sa_address(sa, &sa->sa_peer, &msg->msg_peer, initiator) == -1 ||
	    sa_address(sa, &sa->sa_local, &msg->msg_local, initiator) == -1)
@


1.111
log
@replace iked_transform pointer with xform id, since target of pointer
might be freed (e.g. on ike sa rekey); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.110 2014/05/07 12:57:13 markus Exp $	*/
a4173 1
	struct iked_id		*peerid, *localid;
d4184 1
a4184 9
	if (sa->sa_hdr.sh_initiator) {
		peerid = &sa->sa_rid;
		localid = &sa->sa_iid;
	} else {
		peerid = &sa->sa_iid;
		localid = &sa->sa_rid;
	}

	if (ikev2_sa_tag(sa, peerid) == -1)
a4282 2
			flowa->flow_srcid = localid;
			flowa->flow_dstid = peerid;
a4321 2
		csa->csa_srcid = localid;
		csa->csa_dstid = peerid;
a4470 7
	if (sa->sa_hdr.sh_initiator) {
		csa->csa_dstid = &sa->sa_rid;
		csa->csa_srcid = &sa->sa_iid;
	} else {
		csa->csa_dstid = &sa->sa_iid;
		csa->csa_srcid = &sa->sa_rid;
	}
a4539 7
	if (sa->sa_hdr.sh_initiator) {
		flowa->flow_dstid = &sa->sa_rid;
		flowa->flow_srcid = &sa->sa_iid;
	} else {
		flowa->flow_dstid = &sa->sa_iid;
		flowa->flow_srcid = &sa->sa_rid;
	}
@


1.110
log
@make authentication work with X509 certificates that don't have a
subject-altname, i.e. support IKEV2_ID_ASN1_DN correctly;
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.109 2014/05/07 10:52:47 markus Exp $	*/
d4375 4
a4378 2
		csa->csa_encrxf = encrxf;
		csa->csa_integrxf = integrxf;
@


1.109
log
@factor out ikev2_ike_auth() (state machine; used multiple times via callbacks)
from ikev2_ike_auth_recv() code (message parsing; used once); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.108 2014/05/06 14:10:53 markus Exp $	*/
d42 1
d1113 3
d1157 13
@


1.108
log
@change the create-child-sa responder code, so it does not store any
state in the ikesa structure. this way we can initiate a create-child-sa
and process requests for the peer at the same time. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.107 2014/05/06 10:24:22 markus Exp $	*/
d57 1
a57 1
int	 ikev2_ike_auth(struct iked *, struct iked_sa *,
d59 1
d257 1
a257 1
		if (ikev2_ike_auth(env, sa, NULL) != 0)
d300 1
a300 1
		if (ikev2_ike_auth(env, sa, NULL) != 0)
d335 1
a335 1
		if (ikev2_ike_auth(env, sa, NULL) != 0)
d494 1
a494 1
ikev2_ike_auth(struct iked *env, struct iked_sa *sa,
a502 3
	if (msg == NULL)
		goto done;

d636 6
a641 1
 done:
d726 1
a726 1
		(void)ikev2_ike_auth(env, sa, msg);
d1922 1
a1922 1
		if (ikev2_ike_auth(env, sa, msg) != 0) {
@


1.107
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.106 2014/05/06 09:48:40 markus Exp $	*/
d89 2
a90 1
int	 ikev2_sa_responder_dh(struct iked_sa *, struct iked_message *, u_int);
d96 2
a97 1
int	 ikev2_childsa_negotiate(struct iked *, struct iked_sa *, int, int);
d630 2
a631 2
		if (ikev2_sa_negotiate(sa, &sa->sa_policy->pol_proposals,
		    &msg->msg_proposals) != 0) {
d1083 2
a1084 1
	ret = ikev2_childsa_negotiate(env, sa, sa->sa_hdr.sh_initiator, 0);
d2106 2
a2107 1
	if (ikev2_childsa_negotiate(env, sa, sa->sa_hdr.sh_initiator, 0) == -1)
d2666 1
a2666 1
	if (ikev2_sa_negotiate(sa, &sa->sa_proposals,
d2742 2
a2743 1
	if (ikev2_childsa_negotiate(env, sa, 1, pfs)) {
d2941 2
a2947 1
	struct group			*group;
d2959 2
d3006 1
d3010 11
d3024 2
a3025 3
			ikev2_sa_cleanup_dh(sa);
			if (ikev2_sa_responder_dh(sa, msg->msg_parent,
			    protoid) < 0) {
d3027 1
a3027 1
				return (ret);
d3034 1
a3034 1
		TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
d3041 1
a3041 1
			return (-1);
d3052 1
a3052 1
				return (-1);
d3058 1
a3058 1
				return (-1);
d3067 1
a3067 1
			return (-1);
d3069 2
a3070 2
		ibuf_release(sa->sa_inonce);
		sa->sa_inonce = ibuf_dup(msg->msg_nonce);
d3074 1
a3074 1
			return (-1);
d3077 2
a3078 2
		ibuf_release(sa->sa_rnonce);
		sa->sa_rnonce = nonce;
d3080 1
a3080 1
		if (ikev2_childsa_negotiate(env, sa, 0, pfs)) {
d3082 1
a3082 1
			return (-1);
d3106 1
a3106 1
		nsa ? &nsa->sa_proposals : &sa->sa_proposals,
d3130 1
a3130 2
		if ((group = nsa ?
		    nsa->sa_dhgroup : sa->sa_dhgroup) == NULL) {
d3134 2
a3135 3
		ke->kex_dhgroup = htobe16(group->id);
		if (ikev2_add_buf(e, nsa ?
		    nsa->sa_dhrexchange : sa->sa_dhrexchange) == -1)
d3137 1
a3137 1
		len = sizeof(*ke) + dh_getlen(group);
d3160 2
d3163 5
d3419 1
a3419 1
ikev2_sa_negotiate(struct iked_sa *sa, struct iked_proposals *local,
d3463 1
a3463 1
	else if (sa == NULL)
d3466 2
a3467 3
	(void)config_free_proposals(&sa->sa_proposals, vpeer.prop_protoid);
	prop = config_add_proposal(&sa->sa_proposals, vpeer.prop_id,
	    vpeer.prop_protoid);
d3588 2
a3589 2
	if (ikev2_sa_negotiate(sa, &msg->msg_policy->pol_proposals,
	    &msg->msg_proposals) != 0) {
d3646 2
a3647 1
ikev2_sa_responder_dh(struct iked_sa *sa, struct iked_message *msg, u_int proto)
d3651 2
a3652 2
	if (sa->sa_dhgroup == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
d3657 1
a3657 1
		if ((sa->sa_dhgroup =
d3665 3
a3667 3
	if (!ibuf_length(sa->sa_dhrexchange)) {
		if ((sa->sa_dhrexchange = ibuf_new(NULL,
		    dh_getlen(sa->sa_dhgroup))) == NULL) {
d3671 2
a3672 2
		if (dh_create_exchange(sa->sa_dhgroup,
		    sa->sa_dhrexchange->buf) == -1) {
d3678 4
a3681 4
	if (!ibuf_length(sa->sa_dhiexchange)) {
		if ((sa->sa_dhiexchange = ibuf_dup(msg->msg_ke)) == NULL ||
		    ((ssize_t)ibuf_length(sa->sa_dhiexchange) !=
		    dh_getlen(sa->sa_dhgroup))) {
d3684 1
a3684 1
			    dh_getlen(sa->sa_dhgroup) * 8);
d3690 1
a3690 1
	sa->sa_dhpeer = sa->sa_dhiexchange;
d3721 2
a3722 2
	if (ikev2_sa_negotiate(sa, &msg->msg_policy->pol_proposals,
	    &msg->msg_proposals) != 0) {
d3769 1
a3769 1
	if (ikev2_sa_responder_dh(sa, msg, 0) < 0)
d4146 2
a4147 1
ikev2_childsa_negotiate(struct iked *env, struct iked_sa *sa, int initiator,
d4177 1
a4177 1
	TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
d4213 2
a4214 2
		if (sa->sa_dhpeer == NULL || ibuf_length(sa->sa_dhpeer) == 0 ||
		    (group = sa->sa_dhgroup) == NULL) {
d4223 1
a4223 1
		    sa->sa_dhpeer->buf) == -1) {
d4227 1
a4227 1
			    ibuf_length(sa->sa_dhpeer));
d4235 2
a4236 2
	if (ibuf_cat(seed, sa->sa_inonce) != 0 ||
	    ibuf_cat(seed, sa->sa_rnonce) != 0 ||
d4244 1
a4244 1
	TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
d4300 1
a4300 1
	TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
@


1.106
log
@cleanup IKE-SA tree handling (fixes repeated-insert & double-remove)

sa_new() always re-inserts an SA into the SA tree. in case of a key
collision it would try to free the new SA. While doing that it would
accidentially free the existing SA, since config_free_sa() does
RB_REMOVE() uncoditionally.  This change fixes this by:
a) moving the responsibility for RB_REMOVE() to CALLER of config_free_sa() and
b) by calling config_free_sa() instead of sa_free() from sa_new()
It also changes to code to NEVER re-add an SA to the tree. So
RB_INSERT() is ONLY called once per SA. The code also makes sure
that there is always a KEY defined for this tree (ispi).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.105 2014/05/06 08:17:58 markus Exp $	*/
d76 2
d80 1
d85 1
a85 1
	    struct iked_message *);
d793 1
a793 1
	if (ikev2_sa_initiator(env, sa, NULL) == -1)
d938 1
a938 1
	if (ikev2_sa_initiator(env, sa, msg) == -1) {
d1088 3
d2221 3
d2401 7
d2543 96
d2645 2
d2678 27
d2779 1
a2779 1
ikev2_resp_create_child_sa(struct iked *env, struct iked_message *msg)
d2784 152
d3134 3
a3136 54
	if (protoid == IKEV2_SAPROTO_IKE) {
		/* Transfer all Child SAs and flows from the old IKE SA */
		for (flow = TAILQ_FIRST(&sa->sa_flows); flow != NULL;
		     flow = nextflow) {
			nextflow = TAILQ_NEXT(flow, flow_entry);
			TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
			TAILQ_INSERT_TAIL(&nsa->sa_flows, flow,
			    flow_entry);
			flow->flow_ikesa = nsa;
		}
		for (csa = TAILQ_FIRST(&sa->sa_childsas); csa != NULL;
		     csa = nextcsa) {
			nextcsa = TAILQ_NEXT(csa, csa_entry);
			TAILQ_REMOVE(&sa->sa_childsas, csa, csa_entry);
			TAILQ_INSERT_TAIL(&nsa->sa_childsas, csa,
			    csa_entry);
			csa->csa_ikesa = nsa;
		}
		/* Transfer all non-IKE proposals */
		for (prop = TAILQ_FIRST(&sa->sa_proposals); prop != NULL;
		     prop = nextprop) {
			nextprop = TAILQ_NEXT(prop, prop_entry);
			if (prop->prop_protoid == IKEV2_SAPROTO_IKE)
				continue;
			TAILQ_REMOVE(&sa->sa_proposals, prop, prop_entry);
			TAILQ_INSERT_TAIL(&nsa->sa_proposals, prop,
			    prop_entry);
		}
		/* Preserve ID information */
		nsa->sa_iid = sa->sa_iid;
		nsa->sa_iid.id_buf = ibuf_dup(sa->sa_iid.id_buf);
		nsa->sa_rid = sa->sa_rid;
		nsa->sa_rid.id_buf = ibuf_dup(sa->sa_rid.id_buf);

		log_debug("%s: activating new IKE SA", __func__);
		sa_state(env, nsa, IKEV2_STATE_ESTABLISHED);
		timer_set(env, &nsa->sa_timer, ikev2_ike_sa_alive, nsa);
		timer_add(env, &nsa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
		nsa->sa_stateflags = sa->sa_statevalid; /* XXX */

		/* unregister DPD keep alive timer first */
		if (sa->sa_state == IKEV2_STATE_ESTABLISHED)
			timer_del(env, &sa->sa_timer);
		timer_set(env, &sa->sa_timer, ikev2_ike_sa_timeout, sa);
		timer_add(env, &sa->sa_timer, IKED_IKE_SA_REKEY_TIMEOUT);

		if (sa->sa_addrpool) {
			/* transfer sa_addrpool address */
			RB_REMOVE(iked_addrpool, &env->sc_addrpool, sa);
			nsa->sa_addrpool = sa->sa_addrpool;
			sa->sa_addrpool = NULL;
			RB_INSERT(iked_addrpool, &env->sc_addrpool, nsa);
		}
	} else
d3535 1
a3535 1
    struct iked_message *msg)
d3619 1
a3619 1
	return (ikev2_sa_keys(env, sa, NULL));
d4702 2
a4703 1
void
d4711 1
a4711 1
		return;
d4728 1
a4728 1
			return;
d4742 1
a4742 1
			return;
d4744 2
a4745 1

d4751 1
d4767 2
a4768 1
void
d4777 1
a4777 1
		return;
d4780 1
a4780 1
		return;
d4784 1
a4784 1
		return;
d4789 1
a4789 1
		return;
d4791 2
d4798 1
d4801 2
a4802 1
void
d4814 6
a4819 1
		return;
d4822 2
a4823 1
	if ((sa = csa->csa_ikesa) == NULL) {
d4825 1
a4825 1
		return;
d4841 1
a4841 1
		return;
d4863 1
a4863 1
	return;
@


1.105
log
@send the delete with the locally allocated SPI in ikev2_init_create_child_sa()
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.104 2014/05/06 07:24:37 markus Exp $	*/
d664 2
a665 1
			sa_free(env, sa);
@


1.104
log
@initial support for PFS; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.103 2014/05/06 07:08:10 markus Exp $	*/
d2614 1
a2614 1
		spi32 = htobe32(csa->csa_peerspi);
@


1.103
log
@retire IKED_REQ_DELETE and fix delete parsing; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.102 2014/04/29 11:51:13 markus Exp $	*/
d85 3
d90 1
d92 1
a92 1
int	 ikev2_childsa_negotiate(struct iked *, struct iked_sa *, int);
d786 1
d1077 1
a1077 1
	ret = ikev2_childsa_negotiate(env, sa, sa->sa_hdr.sh_initiator);
d2096 1
a2096 1
	if (ikev2_childsa_negotiate(env, sa, sa->sa_hdr.sh_initiator) == -1)
d2341 27
d2371 1
d2375 2
d2391 1
d2400 1
d2415 1
a2415 1
	if ((sa->sa_policy->pol_flags & IKED_POLICY_IPCOMP) &&
d2429 11
d2454 26
d2512 5
d2529 1
a2529 1
	struct iked_childsa		*csa;
a2533 1
	u_int64_t			 peerspi;
d2535 1
a2535 1
	int				 rekeying = 0, ret = -1;
d2541 2
a2542 1
	if (msg->msg_prop == NULL) {
d2547 6
a2552 1
	/* Update peer SPI */
d2563 8
a2570 2
	peerspi = prop->prop_peerspi.spi;
	prop->prop_peerspi.spi = msg->msg_prop->prop_peerspi.spi;
d2572 14
a2585 4
	if ((csa = childsa_lookup(sa, peerspi, prop->prop_protoid)) != NULL) {
		rekeying = 1;
		log_debug("%s: rekeying CHILD SA %s", __func__,
		    print_spi(peerspi, prop->prop_peerspi.spi_size));
d2596 1
a2596 1
	if (ikev2_childsa_negotiate(env, sa, 1)) {
d2601 1
a2601 1
	if (rekeying) {
a2644 1
	struct ikev2_notify		*n;
d2646 1
a2646 1
	struct ibuf			*buf = NULL, *e = NULL, *nonce = NULL;
a2647 2
	u_int64_t			 spi64;
	u_int32_t			 spi32;
d2652 1
d2707 1
d2709 6
a2714 6
			/* We do not support KE payload yet */
			if ((buf = ibuf_static()) == NULL)
				return (-1);
			if ((n = ibuf_advance(buf, sizeof(*n))) == NULL) {
				ibuf_release(buf);
				return (-1);
d2716 2
a2717 17
			n->n_protoid = protoid;
			n->n_spisize = rekey->spi_size;
			n->n_type = htobe16(IKEV2_N_NO_ADDITIONAL_SAS);
			switch (rekey->spi_size) {
			case 4:
				spi32 = htobe32(rekey->spi);
				ibuf_add(buf, &spi32, rekey->spi_size);
				break;
			case 8:
				spi64 = htobe64(rekey->spi);
				ibuf_add(buf, &spi64, rekey->spi_size);
				break;
			}
			ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_NOTIFY,
			    IKEV2_EXCHANGE_CREATE_CHILD_SA, 1);
			ibuf_release(buf);
			return (0);
d2767 1
a2767 1
		if (ikev2_childsa_negotiate(env, sa, 0)) {
d2807 2
a2808 1
	if (protoid == IKEV2_SAPROTO_IKE) {
d2817 2
a2818 1
		if ((group = nsa->sa_dhgroup) == NULL) {
d2823 2
a2824 1
		if (ikev2_add_buf(e, nsa->sa_dhrexchange) == -1)
d2827 3
a2829 1
	} else {
a2831 1
	}
d3156 2
a3157 1
	struct iked_transform	*chosen[IKEV2_XFORMTYPE_MAX];
d3162 1
a3162 1
	bzero(chosen, sizeof(chosen));
d3181 5
a3185 2
				for (i = 0; i < IKEV2_XFORMTYPE_MAX; i++)
					chosen[i] = match[i];
d3213 1
a3213 1
		if (chosen[i] == NULL)
d3216 4
a3219 4
		    chosen[i]->xform_score, print_map(i, ikev2_xformtype_map),
		    print_map(chosen[i]->xform_id, chosen[i]->xform_map));
		if (chosen[i]->xform_length)
			print_debug(" %d", chosen[i]->xform_length);
d3222 3
a3224 3
		if (config_add_transform(prop, chosen[i]->xform_type,
		    chosen[i]->xform_id, chosen[i]->xform_length,
		    chosen[i]->xform_keylength) == NULL)
d3232 1
a3232 2
ikev2_sa_initiator(struct iked *env, struct iked_sa *sa,
    struct iked_message *msg)
d3239 1
a3239 1
		    IKEV2_XFORMTYPE_DH)) == NULL) {
a3263 7
	if (!ibuf_length(sa->sa_inonce)) {
		if ((sa->sa_inonce = ibuf_random(IKED_NONCE_SIZE)) == NULL) {
			log_debug("%s: failed to get local nonce", __func__);
			return (-1);
		}
	}

a3267 11
	if (!ibuf_length(sa->sa_rnonce)) {
		if (!ibuf_length(msg->msg_nonce)) {
			log_debug("%s: invalid peer nonce", __func__);
			return (-1);
		}
		if ((sa->sa_rnonce = ibuf_dup(msg->msg_nonce)) == NULL) {
			log_debug("%s: failed to get peer nonce", __func__);
			return (-1);
		}
	}

d3287 33
d3332 1
a3332 1
		    IKEV2_XFORMTYPE_ENCR)) == NULL) {
d3345 1
a3345 1
		    IKEV2_XFORMTYPE_PRF)) == NULL) {
d3358 1
a3358 1
		    IKEV2_XFORMTYPE_INTEGR)) == NULL) {
d3380 47
d3464 1
a3464 1
		    IKEV2_XFORMTYPE_ENCR)) == NULL) {
d3477 1
a3477 1
		    IKEV2_XFORMTYPE_PRF)) == NULL) {
d3490 1
a3490 1
		    IKEV2_XFORMTYPE_INTEGR)) == NULL) {
d3502 2
a3503 39
	if (sa->sa_dhgroup == NULL) {
		if ((xform = config_findtransform(&sa->sa_proposals,
		    IKEV2_XFORMTYPE_DH)) == NULL) {
			log_debug("%s: did not find dh transform", __func__);
			return (-1);
		}
		if ((sa->sa_dhgroup =
		    group_get(xform->xform_id)) == NULL) {
			log_debug("%s: invalid dh", __func__);
			return (-1);
		}
	}

	if (!ibuf_length(sa->sa_dhrexchange)) {
		if ((sa->sa_dhrexchange = ibuf_new(NULL,
		    dh_getlen(sa->sa_dhgroup))) == NULL) {
			log_debug("%s: failed to alloc dh exchange", __func__);
			return (-1);
		}
		if (dh_create_exchange(sa->sa_dhgroup,
		    sa->sa_dhrexchange->buf) == -1) {
			log_debug("%s: failed to get dh exchange", __func__);
			return (-1);
		}
	}

	if (!ibuf_length(sa->sa_dhiexchange)) {
		if ((sa->sa_dhiexchange = ibuf_dup(msg->msg_ke)) == NULL ||
		    ((ssize_t)ibuf_length(sa->sa_dhiexchange) !=
		    dh_getlen(sa->sa_dhgroup))) {
			/* XXX send notification to peer */
			log_debug("%s: invalid dh, size %d", __func__,
			    dh_getlen(sa->sa_dhgroup) * 8);
			return (-1);
		}
	}

	/* Set a pointer to the peer exchange */
	sa->sa_dhpeer = sa->sa_dhiexchange;
d3711 11
d3879 2
a3880 1
ikev2_childsa_negotiate(struct iked *env, struct iked_sa *sa, int initiator)
d3887 2
a3888 1
	struct ibuf		*keymat = NULL, *seed = NULL;
d3939 29
a3967 1
	if ((seed = ibuf_dup(sa->sa_inonce)) == NULL ||
d4133 1
@


1.102
log
@make sure the state machine only advances if the AUTH payload has
been verified; with & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.101 2014/04/28 11:21:02 reyk Exp $	*/
a375 1
	int			 response;
d384 1
a384 1
	response = (hdr->ike_flags & IKEV2_FLAG_RESPONSE) ? 1 : 0;
d392 1
a392 1
	log_info("%s: %s from %s %s to %s policy '%s' id %u, %ld bytes",
d394 1
d412 1
a412 1
	if (response) {
d719 1
d2522 1
a2522 1
		sa->sa_stateflags |= IKED_REQ_INF | IKED_REQ_DELETE;
@


1.101
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.100 2014/04/10 16:08:02 reyk Exp $	*/
d241 1
a241 1
			sa_stateflags(sa, IKED_REQ_VALID);
d299 5
d322 2
d533 10
a542 5
		if ((authmsg = ikev2_msg_auth(env, sa,
		    !sa->sa_hdr.sh_initiator)) == NULL) {
			log_debug("%s: failed to get response "
			    "auth data", __func__);
			return (-1);
a543 3

		ca_setauth(env, sa, authmsg, PROC_CERT);
		ibuf_release(authmsg);
d590 4
a593 2
		if (ret != 0)
			goto done;
d612 4
a628 1

@


1.100
log
@Add validation routines to ikev2_pld.c: For each payload type overall
header structure is checked for sanity before copying the header.
Always pass down the number of remaining bytes in the payload or
substructure so we can always ensure to not go beyond actual data.
Also remove the quick parsing step as it does not provide a real
benefit anymore.

From Hans-Joerg Hoexer

ok mikeb@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.99 2014/03/12 14:28:09 markus Exp $	*/
d287 1
a287 1
		
@


1.99
log
@don't leak an ibuf for each expired SA; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.98 2014/03/12 11:57:54 markus Exp $	*/
d373 1
a373 1
	if (hdr == NULL || (ssize_t)ibuf_size(msg->msg_data) <
@


1.98
log
@unbreak config-address w/o pool; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.97 2014/02/26 14:09:15 markus Exp $	*/
a4396 5

	if ((buf = ibuf_static()) == NULL)
		goto done;
	if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
		goto done;
@


1.97
log
@don't policy_ref an activate policy (policy_ref/unref are assymetrical),
otherwise the policy list might get corrupted; from haesbaert
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.96 2014/02/21 20:52:38 markus Exp $	*/
d4565 1
a4565 1
	if (ikecfg == NULL)
@


1.96
log
@support rekeying for IPCOMP; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.95 2014/02/18 13:10:48 markus Exp $	*/
d513 2
a514 1
			}
a515 4
			if (policy != old) {
				policy_unref(env, old);
				policy_ref(env, policy);
			}
@


1.95
log
@check the error from ikev2_cp_setaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.94 2014/02/17 15:53:46 markus Exp $	*/
d109 2
a110 1
int	 ikev2_ipcomp_enable(struct iked_sa *);
d1401 3
a1403 2
	if (ikev2_next_payload(*pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
		return (-1);
d2329 1
a2329 1
	struct ikev2_payload		*pld;
d2332 1
d2365 12
d2421 1
a2421 1
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, IKEV2_PAYLOAD_SA, 0);
d2534 1
a2534 1
	struct ikev2_payload		*pld;
d2539 1
d2680 12
d2737 1
a2737 1
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, IKEV2_PAYLOAD_SA, 1)) == -1)
d3818 2
a3819 1
				    saflow->flow_saproto == prop->prop_protoid)
d3821 2
d3970 18
d3989 1
a3989 1
ikev2_ipcomp_enable(struct iked_sa *sa)
d3991 1
a3991 1
	struct iked_childsa	*other, *csa = NULL, *csb = NULL;
d3993 1
d4007 1
a4007 1
	TAILQ_FOREACH(other, &sa->sa_childsas, csa_entry)
d4009 1
a4009 1
		    other->csa_saproto == IKEV2_SAPROTO_ESP)
d4011 9
d4037 1
a4037 1
	csb->csa_allocated = 0;
d4047 20
d4074 2
a4075 1
	TAILQ_FOREACH(flow, &sa->sa_flows, flow_entry) {
d4079 16
a4094 3
		log_debug("%s: flow %p saproto %d -> %d", __func__,
		    flow, flow->flow_saproto, IKEV2_SAPROTO_IPCOMP);
		flow->flow_saproto = IKEV2_SAPROTO_IPCOMP;
d4111 3
a4115 1
	flowa->flow_src.addr_port = flowa->flow_dst.addr_port = 0;
d4118 12
d4138 1
d4153 1
a4153 1
	    ikev2_ipcomp_enable(sa) == -1)
@


1.94
log
@interpret 'config address net/prefix' as a pool of addresses and
randomly choose the address for CFG_REQUEST. this address will be used
to replace 0.0.0.0/32 in the specified flow. e.g.
> ikev2 passive esp from 192.168.1.0/24 to 0.0.0.0 \
>     config address 192.168.10.200/24
will assign an address between 192.168.10.200 and 192.168.10.254
and replace 0.0.0.0 with this address.
ok mikeb@@ on older version of this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.93 2014/02/17 11:00:14 reyk Exp $	*/
d2074 2
a2075 2
	if (sa->sa_cp)
		ikev2_cp_setaddr(env, sa);
@


1.93
log
@Fix compiler warnings in the format strings: use %zd for ssize_t and
%zu for size_t.

From Andre de Oliveira
With input and OK from blambert@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.92 2014/02/14 09:00:03 markus Exp $	*/
d111 4
d1208 1
d1237 7
d1593 7
a1599 1
			in4 = (struct sockaddr_in *)&ikecfg->cfg.address.addr;
d1630 7
a1636 1
			in6 = (struct sockaddr_in6 *)&ikecfg->cfg.address.addr;
d2074 3
d2757 8
d3809 1
d3824 1
d4423 141
@


1.92
log
@initial support for IPComp
still experimental and rekeying needs some work; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.91 2014/01/24 07:35:55 markus Exp $	*/
d180 1
a180 1
		log_debug("%s: message length %d", __func__, len);
d217 1
a217 1
		log_debug("%s: updated local CERTREQ type %s length %d",
d260 1
a260 1
		log_debug("%s: cert type %s length %d, %s", __func__,
d295 1
a295 1
		log_debug("%s: AUTH type %d len %d", __func__, type, len);
d341 1
a341 1
	    " type %d data length %d",
d1131 1
a1131 1
	log_debug("%s: %s %s length %d", __func__,
d1353 1
a1353 1
	log_debug("%s: type %s length %d", __func__,
d1421 1
a1421 1
	log_debug("%s: length %d nextpayload %s",
d1721 1
a1721 1
	log_debug("%s: length %d", __func__, length);
d2767 1
a2767 1
		log_debug("%s: %s CHILD SA spi %s last used %u second(s) ago",
d3382 1
a3382 1
		    " group %d len %d secret %d exchange %d", __func__,
d3426 1
a3426 1
	log_debug("%s: SKEYSEED with %d bytes", __func__, tmplen);
d3454 1
a3454 1
	log_debug("%s: S with %d bytes", __func__, ibuf_length(s));
d3486 1
a3486 1
	log_debug("%s: SK_d with %d bytes", __func__,
d3489 1
a3489 1
	log_debug("%s: SK_ai with %d bytes", __func__,
d3492 1
a3492 1
	log_debug("%s: SK_ar with %d bytes", __func__,
d3495 1
a3495 1
	log_debug("%s: SK_ei with %d bytes", __func__,
d3498 1
a3498 1
	log_debug("%s: SK_er with %d bytes", __func__,
d3501 1
a3501 1
	log_debug("%s: SK_pi with %d bytes", __func__,
d3504 1
a3504 1
	log_debug("%s: SK_pr with %d bytes", __func__,
d3573 1
a3573 1
		log_debug("%s: T%d with %d bytes", __func__,
d3578 1
a3578 1
	log_debug("%s: Tn with %d bytes", __func__, ibuf_length(t));
d3664 1
a3664 1
	log_debug("%s: %s (%d)", __func__, sa->sa_tag, strlen(sa->sa_tag));
d3733 1
a3733 1
	log_debug("%s: key material length %d", __func__, ilen);
@


1.91
log
@re-lookup the policy as soon as we have the ID of the peer (destid)
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.90 2014/01/24 05:58:52 mikeb Exp $	*/
d103 2
d109 2
d1017 5
d1359 51
d2138 5
d2760 3
d3903 99
d4006 4
@


1.90
log
@use a bit saner timer api
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.89 2014/01/22 09:25:41 markus Exp $	*/
d486 28
@


1.89
log
@implement DPD similar to isakmpd, but only send DPD-messages 'on-demand'
(less aggressive, only if the ESP-SAs are actually used);
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.88 2013/12/09 15:22:32 markus Exp $	*/
d134 1
a134 1
		timer_initialize(env, &env->sc_inittmr, ikev2_init_ike_sa,
d136 1
a136 1
		timer_register(env, &env->sc_inittmr, IKED_INITIATOR_INITIAL);
d702 2
a703 2
	timer_initialize(env, &env->sc_inittmr, ikev2_init_ike_sa, NULL);
	timer_register(env, &env->sc_inittmr, IKED_INITIATOR_INTERVAL);
d1023 2
a1024 2
		timer_initialize(env, &sa->sa_timer, ikev2_ike_sa_alive, sa);
		timer_register(env, &sa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
d2073 2
a2074 2
		timer_initialize(env, &sa->sa_timer, ikev2_ike_sa_alive, sa);
		timer_register(env, &sa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
d2628 2
a2629 2
		timer_initialize(env, &nsa->sa_timer, ikev2_ike_sa_alive, nsa);
		timer_register(env, &nsa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
d2634 3
a2636 3
			timer_deregister(env, &sa->sa_timer);
		timer_initialize(env, &sa->sa_timer, ikev2_ike_sa_timeout, sa);
		timer_register(env, &sa->sa_timer, IKED_IKE_SA_REKEY_TIMEOUT);
d2694 1
a2694 1
	timer_register(env, &sa->sa_timer, IKED_IKE_SA_ALIVE_TIMEOUT);
@


1.88
log
@distingush between sa_msgid not set and 0; otherwise we start
dropping messages if we usually are the initiator and the peer
initiates rekeying first.  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.87 2013/12/03 13:55:39 markus Exp $	*/
d79 1
d1021 1
a1021 1
	if (ret == 0)
d1023 3
d1787 8
d2071 1
a2071 1
	if (ret == 0)
d2073 3
a2181 2
	if (ibuf_cat(e, buf) != 0)
		goto done;
d2183 8
a2190 2
	if (ikev2_next_payload(pld, ibuf_size(buf), IKEV2_PAYLOAD_NONE) == -1)
		goto done;
d2628 2
d2632 3
d2654 41
@


1.87
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.86 2013/11/28 20:30:41 markus Exp $	*/
d426 1
a426 1
		} else if (msg->msg_msgid == sa->sa_msgid) {
d435 3
a437 1
		 * message ID and dispose of all previous responses
d440 1
@


1.86
log
@mark replaced flows as 'not loaded'; this can happen if both
sides negotiate the same flow, but only one flow is active
in the kernel; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.85 2013/11/28 20:27:17 markus Exp $	*/
d379 2
a380 2
	    print_host(&msg->msg_peer, NULL, 0),
	    print_host(&msg->msg_local, NULL, 0),
d448 2
a449 2
	    print_host(&sa->sa_peer.addr, NULL, 0),
	    print_host(&sa->sa_local.addr, NULL, 0));
d639 2
a640 1
		port = htons(socket_getport(&sock->sock_addr));
d652 2
a653 2
		    print_host(&sa->sa_peer.addr, NULL, 0),
		    print_host(&sa->sa_local.addr, NULL, 0));
d693 3
a695 1
			    __func__, print_host(&pol->pol_peer.addr, NULL, 0));
d745 1
a745 1
	port = htons(socket_getport(&sock->sock_addr));
d1347 1
a1347 1
	struct sockaddr_storage	*src, *dst, *ss;
d1363 2
a1364 2
		src = &msg->msg_peer;
		dst = &msg->msg_local;
d1369 2
a1370 2
		src = &msg->msg_local;
		dst = &msg->msg_peer;
d1400 1
a1400 1
	switch (ss->ss_family) {
d4074 1
a4074 1
		if (print_host((struct sockaddr_storage *)s4,
d4098 1
a4098 1
		if (print_host((struct sockaddr_storage *)s6,
@


1.85
log
@drop duplicate requests

otherwise IKE_AUTH requests might be accepted twice, leading to TWO
child-SAs with the same remote SPI, but different local SPIs, leading
to corrupt child-SA tables.

with & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.84 2013/11/28 20:21:17 markus Exp $	*/
d3739 1
a3739 1
	struct iked_flow	*flow;
d3765 8
@


1.84
log
@support raw pubkey authentication w/o x509 certificates;
mostly by Michael Cardell Widerkrantz, reyk@@ and mikeb@@; ok mike@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.83 2013/06/13 09:11:51 reyk Exp $	*/
d425 6
@


1.83
log
@Add support for protected-subnet config types.

From Ryan Slack
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.82 2013/03/21 04:30:14 deraadt Exp $	*/
d100 2
d197 1
d212 3
a214 2
		log_debug("%s: updated local CERTREQ signatures length %d",
		    __func__, ibuf_length(env->sc_certreq));
d247 15
d272 4
a275 7
		if (type != IKEV2_CERT_NONE) {
			if (len <= 0 ||
			    (id->id_buf = ibuf_new(ptr, len)) == NULL) {
				log_debug("%s: failed to get cert payload",
				    __func__);
				break;
			}
d277 1
a277 4

		log_debug("%s: cert type %d length %d", __func__,
		    id->id_type, ibuf_length(id->id_buf));

d937 9
a945 15
		if (env->sc_certreqtype) {
			if (ikev2_next_payload(pld, len,
			    IKEV2_PAYLOAD_CERTREQ) == -1)
				goto done;

			/* CERTREQ payload */
			if ((pld = ikev2_add_payload(e)) == NULL)
				goto done;
			if ((cert = ibuf_advance(e, sizeof(*cert))) == NULL)
				goto done;
			cert->cert_type = env->sc_certreqtype;
			if (ikev2_add_buf(e, env->sc_certreq) == -1)
				goto done;
			len = ibuf_size(env->sc_certreq) + sizeof(*cert);
		}
d1271 35
a1781 1
	struct ikev2_cert		*cert;
d1882 4
a1885 2
	if (env->sc_certreqtype && (sa->sa_statevalid & IKED_REQ_CERT)) {
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_CERTREQ) == -1)
d1888 3
a1890 7
		/* CERTREQ payload */
		if ((pld = ikev2_add_payload(buf)) == NULL)
			goto done;
		if ((cert = ibuf_advance(buf, sizeof(*cert))) == NULL)
			goto done;
		cert->cert_type = env->sc_certreqtype;
		if (ikev2_add_buf(buf, env->sc_certreq) == -1)
a1891 1
		len = ibuf_size(env->sc_certreq) + sizeof(*cert);
@


1.82
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.81 2013/01/08 10:38:19 reyk Exp $	*/
d1395 1
d1441 11
d1464 1
@


1.81
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.80 2012/12/15 23:15:11 reyk Exp $	*/
a19 1
#include <sys/types.h>
@


1.80
log
@Don't pass an uninitialized arg to ibuf_release(); initialize it to NULL.
@
text
@d1 1
a1 2
/*	$OpenBSD: ikev2.c,v 1.79 2012/10/23 14:32:45 reyk Exp $	*/
/*	$vantronix: ikev2.c,v 1.101 2010/06/03 07:57:33 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.79
log
@Add a cast for input to inet_pton() to silence a possible but harmless
compiler warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.78 2012/10/22 10:25:17 reyk Exp $	*/
d2128 1
a2128 1
	struct ibuf			*e, *nonce = NULL;
@


1.78
log
@Fix NAT-T support in iked, both on the initiator and the responder
side.  Also add a new command line option -t to optionally enforce
NAT-T with UDP encapsulation on port 4500.

Tested by mikeb@@ and me
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.77 2012/09/18 12:07:59 reyk Exp $	*/
d1048 1
a1048 1
		if (inet_pton(AF_INET, polid->id_data, &in4) != 1 ||
d1055 1
a1055 1
		if (inet_pton(AF_INET6, polid->id_data, &in6) != 1 ||
@


1.77
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.76 2012/07/05 08:37:22 mikeb Exp $	*/
a378 5
	log_debug("%s: updating msg, natt %d", __func__, msg->msg_natt);

	if (msg->msg_natt)
		sa->sa_natt = 1;

d430 1
a430 1
	log_debug("%s: updated SA peer %s local %s", __func__,
d575 2
d615 23
d701 1
a701 1
	if ((sock = ikev2_msg_getsocket(env, peer->addr_af)) == NULL)
d774 6
d789 1
a789 1
		len = ikev2_nat_detection(&req, NULL, 0, 0);
d792 1
a792 1
		if ((len = ikev2_nat_detection(&req, ptr, len,
d805 1
a805 1
		len = ikev2_nat_detection(&req, NULL, 0, 0);
d808 1
a808 1
		if ((len = ikev2_nat_detection(&req, ptr, len,
d1287 2
a1288 2
ikev2_nat_detection(struct iked_message *msg, void *ptr, size_t len,
    u_int type)
d1302 1
d1370 6
d1680 5
d1751 1
d1805 1
a1805 1
		len = ikev2_nat_detection(&resp, NULL, 0, 0);
d1808 1
a1808 1
		if ((len = ikev2_nat_detection(&resp, ptr, len,
d1821 1
a1821 1
		len = ikev2_nat_detection(&resp, NULL, 0, 0);
d1824 1
a1824 1
		if ((len = ikev2_nat_detection(&resp, ptr, len,
@


1.76
log
@when rekeying ike sa copy more info from the old one;
fixes the last known iked inter-op problem with windows 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.75 2012/07/03 11:19:27 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.75
log
@Improve the key derivation function to produce correct keying material
when rekeying IKE SA as specified in the section 2.18 of RFC5996. Makes
Windows 7 clients a bit happier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.74 2012/07/02 16:55:28 mikeb Exp $	*/
d2275 1
a2275 1
	struct iked_proposal		*prop;
d2491 15
d2509 1
@


1.74
log
@checking state flags make sense only when processing a response
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.73 2012/07/02 13:29:47 mikeb Exp $	*/
d84 1
a84 1
int	 ikev2_sa_responder(struct iked *, struct iked_sa *,
d86 1
a86 1
int	 ikev2_sa_keys(struct iked *, struct iked_sa *);
d1488 1
d1649 1
a1649 1
		if (ikev2_sa_responder(env, sa, msg) != 0) {
d2331 1
a2331 1
		if (ikev2_sa_responder(env, nsa, msg)) {
d2918 1
a2918 1
	return (ikev2_sa_keys(env, sa));
d2922 1
a2922 1
ikev2_sa_responder(struct iked *env, struct iked_sa *sa,
d3037 1
a3037 1
	return (ikev2_sa_keys(env, sa));
d3041 1
a3041 1
ikev2_sa_keys(struct iked *env, struct iked_sa *sa)
a3074 3
	/*
	 * First generate SKEEYSEED = prf(Ni | Nr, g^ir)
	 */
d3085 9
a3093 9
	if ((ninr = ibuf_new(sa->sa_inonce->buf, ilen)) == NULL ||
	    ibuf_add(ninr, sa->sa_rnonce->buf, rlen) != 0) {
		log_debug("%s: failed to get nonce key buffer", __func__);
		goto done;
	}
	if ((hash_setkey(prf, ninr->buf, ibuf_length(ninr))) == NULL) {
		log_debug("%s: failed to set prf key", __func__);
		goto done;
	}
d3095 3
d3108 28
@


1.73
log
@augment every sa_free call with a debugging log message
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.72 2012/07/02 13:03:24 mikeb Exp $	*/
d408 1
a408 3
		if (flag) {
			if ((sa->sa_stateflags & flag) == 0)
				return;
a409 1
		}
@


1.72
log
@Don't close IKE SA immediately after creating a new one when rekeying.
Instead set a timeout that will shut it down in case we don't get an SA
delete notification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.71 2012/07/02 09:49:30 mikeb Exp $	*/
d448 2
a449 1
	if (sa != NULL && sa->sa_state == IKEV2_STATE_CLOSED)
d451 1
d596 1
a596 1
			log_debug("%s: invalid new SA %p", __func__, sa);
d815 2
a816 1
	if (ret == -1)
d818 1
@


1.71
log
@a state machine is not worth the trouble when you've got a flag. doh!
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.70 2012/06/29 15:05:49 mikeb Exp $	*/
d80 1
a2490 1
		sa_state(env, sa, IKEV2_STATE_CLOSED);
d2492 3
d2499 2
a2500 6
	if (ret) {
		if (protoid == IKEV2_SAPROTO_IKE)
			sa_free(env, nsa);
		else
			ikev2_childsa_delete(env, sa, 0, 0, NULL, 1);
	}
d2503 9
@


1.70
log
@Add missing ESN bits
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.69 2012/06/26 11:05:43 mikeb Exp $	*/
a342 6
	enum {
		ST_START,
		ST_REQUEST,
		ST_RESPONSE,
		ST_FINISH
	}			 state = ST_START;
d347 1
a347 1
	int			 ignore = 0, response = 0;
d356 1
d383 4
a386 46
	do switch (state) {
	case ST_START:
		if (hdr->ike_exchange == IKEV2_EXCHANGE_CREATE_CHILD_SA)
			flag = IKED_REQ_CHILDSA;
		if (hdr->ike_exchange == IKEV2_EXCHANGE_INFORMATIONAL)
			flag = IKED_REQ_INF;
		if ((flag && (sa->sa_stateflags & flag)) ||
		    (!flag && initiator))
			state = ST_RESPONSE;
		else
			state = ST_REQUEST;
		break;
	case ST_REQUEST:
		if (msg->msg_msgid >= sa->sa_msgid) {
			if (flag)
				initiator = 0;
			state = ST_FINISH;
		} else if (flag) {
			flag = 0; /* Prevent endless looping */
			state = ST_RESPONSE;
		} else {
			ignore = 1;
			state = ST_FINISH;
		}
		break;
	case ST_RESPONSE:
		if (msg->msg_msgid < sa->sa_reqid &&
		    (hdr->ike_exchange != IKEV2_EXCHANGE_INFORMATIONAL &&
		     ikev2_msg_lookup(env, &sa->sa_requests, msg, hdr))) {
			response = 1;
			if (flag)
				initiator = 1;
			state = ST_FINISH;
		} else if (flag) {
			flag = 0; /* Prevent endless looping */
			state = ST_REQUEST;
		} else {
			ignore = 1;
			state = ST_FINISH;
		}
		break;
	case ST_FINISH:
		if (ignore)
			return;
		break;
	} while (state != ST_FINISH);
d389 10
d405 7
@


1.69
log
@close SA when IKE_SA_INIT or IKE_AUTH exchanges fail;
don't cache the response to IKE_SA_INIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.68 2012/06/26 11:00:28 mikeb Exp $	*/
d92 1
a92 1
	    struct iked_transform **, struct iked_transform **);
d3403 1
a3403 1
	int			 skip, ret = -1;
d3460 1
a3460 1
		if (ikev2_valid_proposal(prop, NULL, NULL) != 0)
d3511 1
a3511 1
		if (ikev2_valid_proposal(prop, &encrxf, &integrxf) != 0)
d3526 1
d3702 1
a3702 1
    struct iked_transform **exf, struct iked_transform **ixf)
d3705 1
a3705 1
	u_int			 i;
d3722 3
d3742 2
@


1.68
log
@compare exchange types as well when looking up a message;
proceed with a response only when the appropriate request
is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.67 2012/06/22 16:28:20 mikeb Exp $	*/
d1683 1
d1700 1
d1847 1
@


1.67
log
@Add initial support for retransmition timeouts and response retries.
This should still be considered an experimental work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.59 2012/05/08 15:37:09 mikeb Exp $	*/
a401 1
			/* Update if we've initiated this exchange */
d414 3
a416 1
		if (msg->msg_msgid < sa->sa_reqid) {
a417 1
			/* Update if we've initiated this exchange */
d439 1
a439 1
		if ((m = ikev2_msg_lookup(env, &sa->sa_requests, msg)))
d445 1
a445 1
		if ((m = ikev2_msg_lookup(env, &sa->sa_responses, msg))) {
@


1.66
log
@decouple timer initialization from timer_register
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.65 2012/05/30 16:17:20 mikeb Exp $	*/
d343 6
d350 1
d353 1
d365 1
d369 2
a370 2
	log_info("%s: %s from %s %s to %s policy '%s', %ld bytes", __func__,
	    print_map(hdr->ike_exchange, ikev2_exchange_map),
d374 1
a374 1
	    msg->msg_policy->pol_name,
d376 3
d388 31
a418 12
	switch (hdr->ike_exchange) {
	case IKEV2_EXCHANGE_CREATE_CHILD_SA:
		flag = IKED_REQ_CHILDSA;
		goto xchgcommon;

	case IKEV2_EXCHANGE_INFORMATIONAL:
		flag = IKED_REQ_INF;
	xchgcommon:
		if ((sa->sa_stateflags & flag)) {
			/* response */
			if (betoh32(hdr->ike_msgid) == sa->sa_reqid - 1)
				/* we initiated the exchange */
d420 4
a423 5
			else {
				if (flag == IKED_REQ_CHILDSA)
					ikev2_disable_rekeying(env, sa);
				goto errout;	/* unexpected id */
			}
d425 2
a426 7
			/* request */
			if (betoh32(hdr->ike_msgid) >= sa->sa_msgid) {
				/* we are responding */
				initiator = 0;
				sa->sa_msgid = betoh32(hdr->ike_msgid);
			} else
				goto errout;	/* unexpected id */
d429 5
d435 17
a451 9
	default:
		if (initiator) {
			if (betoh32(hdr->ike_msgid) != sa->sa_reqid - 1)
				goto errout;
		} else {
			if (betoh32(hdr->ike_msgid) < sa->sa_msgid)
				goto errout;
			else
				sa->sa_msgid = betoh32(hdr->ike_msgid);
d453 6
a458 8
		break;
	errout:
		sa->sa_stateflags &= ~flag;
		log_debug("%s: invalid sequence number %d "
		    "(SA msgid %d reqid %d)", __func__,
		    betoh32(hdr->ike_msgid), sa->sa_msgid,
		    sa->sa_reqid);
		return;
d629 3
d742 1
d745 1
a745 1
	if ((hdr = ikev2_add_header(buf, sa, ikev2_msg_id(env, sa, 0),
d1738 1
d1741 1
a1741 1
	if ((hdr = ikev2_add_header(buf, sa, 0,
d2097 2
a2098 2
	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    exchange, firstpayload, response);
d2580 2
d2583 1
a2583 2
		if ((hdr = ikev2_add_header(buf, sa,
		    ikev2_msg_id(env, sa, 0),
d2619 2
a2620 1
		sa = &sah;
d2623 1
a2623 2
		if ((hdr = ikev2_add_header(buf, &sah,
		    ikev2_msg_id(env, &sah, 0),
a2633 1
	resp.msg_sa = sa;
a2635 4

	sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
	(void)ikev2_pld_parse(env, hdr, &resp, 0);
	sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
@


1.65
log
@more timer changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.64 2012/05/30 09:39:35 mikeb Exp $	*/
d132 3
a134 2
		timer_register(env, &env->sc_inittmr, ikev2_init_ike_sa, NULL,
		    IKED_INITIATOR_INITIAL);
d649 2
a650 2
	timer_register(env, &env->sc_inittmr, ikev2_init_ike_sa, NULL,
	    IKED_INITIATOR_INTERVAL);
@


1.64
log
@when changing peer's address in the SA, remove the old entry from the
tree before doing the actual change, otherwise we won't remove anything
for real.  also add the newly created SA to the peer's tree so that
initiator timer will treat the ike policy as "in progress".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.63 2012/05/30 09:18:13 mikeb Exp $	*/
d132 1
a132 1
		timer_register(&env->sc_inittmr, env, ikev2_init_ike_sa, NULL,
d648 1
a648 1
	timer_register(&env->sc_inittmr, env, ikev2_init_ike_sa, NULL,
@


1.63
log
@pass a file descriptor in the msg_fd instead of a function argument
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.62 2012/05/29 15:09:12 mikeb Exp $	*/
d788 6
@


1.62
log
@improve timer framework; will be needed soon
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.61 2012/05/23 16:23:01 mikeb Exp $	*/
d791 1
a791 1
	if ((ret = ikev2_msg_send(env, req.msg_fd, &req)) == 0)
d1690 1
d1797 1
a1797 1
	ret = ikev2_msg_send(env, msg->msg_fd, &resp);
d2586 1
d2593 1
a2593 1
	ret = ikev2_msg_send(env, msg->msg_fd, &resp);
@


1.61
log
@remove hardcoded values for esp and let ikev2_add_proposals decide
which proposals to include if protocol is not specified explicitely;
allows iked to successfully negotiate ah.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.60 2012/05/23 14:54:04 mikeb Exp $	*/
d132 2
a133 1
		timer_register_initiator(env, ikev2_init_ike_sa);
d627 2
a628 2
int
ikev2_init_ike_sa(struct iked *env, struct iked_policy *pol)
d630 20
a649 1
	return (ikev2_init_ike_sa_peer(env, pol, &pol->pol_peer));
@


1.60
log
@factor out proposal matching code from ikev2_sa_negotiate and eliminate
the protoid argument as a first step towards successful ah negotiation;
make code a bit more readable while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.59 2012/05/08 15:37:09 mikeb Exp $	*/
d908 2
a909 2
	if ((len = ikev2_add_proposals(env, sa, e, &pol->pol_proposals,
	    IKEV2_SAPROTO_ESP, sa->sa_hdr.sh_initiator, 0)) == -1)
d1420 2
a1421 1
		if (prop->prop_protoid != protoid)
d1427 1
a1427 1
			csa.csa_saproto = protoid;
d1436 1
a1436 1
			prop->prop_localspi.spi_protoid = protoid;
d1899 2
a1900 2
	if ((len = ikev2_add_proposals(env, sa, e, &sa->sa_proposals,
	    IKEV2_SAPROTO_ESP, sa->sa_hdr.sh_initiator, 0)) == -1)
@


1.59
log
@When setting up NAT-T notify payloads, make sure to supply an
actual source address so that a valid hash can be generated.
Fixes a bug introduces some time ago that prevented iked from
initiating if NAT-T wasn't disabled (via -T) and local address
wasn't specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.58 2012/05/07 10:58:38 mikeb Exp $	*/
d89 2
d548 2
a549 3
		if (ikev2_sa_negotiate(sa,
		    &sa->sa_policy->pol_proposals,
		    &msg->msg_proposals, IKEV2_SAPROTO_ESP) != 0) {
d2601 61
d2663 1
a2663 1
    struct iked_proposals *peer, u_int8_t protoid)
d2666 1
a2666 1
	struct iked_transform	*tpeer, *tlocal;
d2668 2
a2669 2
	struct iked_transform	*chosen[IKEV2_XFORMTYPE_MAX];
	u_int			 type, i, j, match_score, chosen_score = 0;
a2681 3
		if (plocal->prop_protoid != protoid)
			continue;

a2682 3
			bzero(match, sizeof(match));
			match_score = 0;

d2685 5
a2689 74

			for (i = 0; i < ppeer->prop_nxforms; i++) {
				tpeer = ppeer->prop_xforms + i;
				for (j = 0; j < plocal->prop_nxforms; j++) {
					tlocal = plocal->prop_xforms + j;
					if (!(tpeer->xform_type ==
					    tlocal->xform_type &&
					    tpeer->xform_id ==
					    tlocal->xform_id &&
					    tpeer->xform_length ==
					    tlocal->xform_length))
						continue;
					if (tpeer->xform_type >
					    IKEV2_XFORMTYPE_MAX)
						continue;
					type = tpeer->xform_type;

					if (match[type] == NULL ||
					    tlocal->xform_score <
					    match[type]->xform_score) {
						match[type] = tlocal;
					} else
						continue;

					print_debug("%s: xform %d "
					    "<-> %d (%d): %s %s "
					    "(keylength %d <-> %d)", __func__,
					    ppeer->prop_id, plocal->prop_id,
					    tlocal->xform_score,
					    print_map(type,
					    ikev2_xformtype_map),
					    print_map(tpeer->xform_id,
					    tpeer->xform_map),
					    tpeer->xform_keylength,
					    tlocal->xform_keylength);
					if (tpeer->xform_length)
						print_debug(" %d",
						    tpeer->xform_length);
					print_debug("\n");
				}
			}

			for (i = match_score = 0;
			    i < IKEV2_XFORMTYPE_MAX; i++) {
				if (protoid == IKEV2_SAPROTO_IKE &&
				    (match[i] == NULL) && (
				    (i == IKEV2_XFORMTYPE_ENCR) ||
				    (i == IKEV2_XFORMTYPE_PRF) ||
				    (i == IKEV2_XFORMTYPE_INTEGR) ||
				    (i == IKEV2_XFORMTYPE_DH))) {
					match_score = 0;
					break;
				} else if (protoid == IKEV2_SAPROTO_AH &&
				    (match[i] == NULL) && (
				    (i == IKEV2_XFORMTYPE_INTEGR) ||
				    (i == IKEV2_XFORMTYPE_ESN))) {
					match_score = 0;
					break;
				} else if (protoid == IKEV2_SAPROTO_ESP &&
				    (match[i] == NULL) && (
				    (i == IKEV2_XFORMTYPE_ENCR) ||
				    (i == IKEV2_XFORMTYPE_ESN))) {
					match_score = 0;
					break;
				} else if (match[i] == NULL)
					continue;

				match_score += match[i]->xform_score;
			}

			log_debug("%s: score %d", __func__, match_score);
			if (match_score != 0 &&
			    (chosen_score == 0 || match_score < chosen_score)) {
				chosen_score = match_score;
d2705 3
a2707 2
	(void)config_free_proposals(&sa->sa_proposals, protoid);
	prop = config_add_proposal(&sa->sa_proposals, vpeer.prop_id, protoid);
d2721 2
a2722 3
		print_debug("%s: score %d: %s %s",
		    __func__, chosen[i]->xform_score,
		    print_map(i, ikev2_xformtype_map),
d2814 2
a2815 3
	if (ikev2_sa_negotiate(sa,
	    &msg->msg_policy->pol_proposals,
	    &msg->msg_proposals, IKEV2_SAPROTO_IKE) != 0) {
d2899 2
a2900 3
	if (ikev2_sa_negotiate(sa,
	    &msg->msg_policy->pol_proposals,
	    &msg->msg_proposals, IKEV2_SAPROTO_IKE) != 0) {
@


1.58
log
@Sync up several defines with RFC 5996.  IANA has changed the existing
IKEv2 Payload Type "Encrypted" (E) to "Encrypted and Authenticated" (SK).
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.57 2011/07/05 01:28:06 mikeb Exp $	*/
d635 1
d650 1
a650 2
	if ((sock = ikev2_msg_getsocket(env,
	    peer->addr_af)) == NULL)
d663 8
a670 3
	if ((buf = ikev2_msg_init(env, &req,
	    &peer->addr, peer->addr.ss_len,
	    &pol->pol_local.addr, pol->pol_local.addr.ss_len, 0)) == NULL)
@


1.57
log
@Fix IKEV2_N_NO_ADDITIONAL_SAS notification by including the SPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.56 2011/05/27 12:01:02 reyk Exp $	*/
d2507 1
a2507 1
		    IKEV2_PAYLOAD_E, IKEV2_EXCHANGE_INFORMATIONAL,
@


1.56
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.55 2011/05/09 11:15:18 reyk Exp $	*/
d2231 2
d2299 1
a2299 1
			n->n_spisize = 0;
d2301 10
@


1.55
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.54 2011/05/05 12:59:31 reyk Exp $	*/
d2637 2
a2638 1
					    "<-> %d (%d): %s %s (keylength %d <-> %d)", __func__,
@


1.54
log
@Small tweak - add direct pointer to env instead of using an indirect one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.53 2011/05/05 12:55:52 reyk Exp $	*/
d112 1
a112 1
	return (run_proc(ps, p, procs, nitems(procs), NULL, NULL));
@


1.53
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.52 2011/05/05 12:17:10 reyk Exp $	*/
d118 1
a118 1
	struct iked		*env = p->p_ps->ps_env;
d152 1
a152 1
	struct iked		*env = p->p_ps->ps_env;
d185 1
a185 1
	struct iked		*env = p->p_ps->ps_env;
@


1.52
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.51 2011/05/02 12:39:18 mikeb Exp $	*/
d110 1
a110 1
ikev2(struct iked *env, struct privsep_proc *p)
d112 1
a112 1
	return (run_proc(env, p, procs, nitems(procs), NULL, NULL));
d118 1
a118 1
	struct iked		*env = p->env;
d152 1
a152 1
	struct iked		*env = p->env;
d185 1
a185 1
	struct iked		*env = p->env;
@


1.51
log
@store the peer address as it was specified in the policy in the
tree that is used to figure out whether the policy is active or
not.  makes active sa lookup via policy work for nat traversal.
problem was reported and fix was tested by sthen, ok sthen, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.50 2011/04/18 09:54:41 reyk Exp $	*/
d50 3
a52 3
int	 ikev2_dispatch_parent(int, struct iked_proc *, struct imsg *);
int	 ikev2_dispatch_ikev1(int, struct iked_proc *, struct imsg *);
int	 ikev2_dispatch_cert(int, struct iked_proc *, struct imsg *);
d103 1
a103 1
static struct iked_proc procs[] = {
d110 1
a110 1
ikev2(struct iked *env, struct iked_proc *p)
d116 1
a116 1
ikev2_dispatch_parent(int fd, struct iked_proc *p, struct imsg *imsg)
d150 1
a150 1
ikev2_dispatch_ikev1(int fd, struct iked_proc *p, struct imsg *imsg)
d183 1
a183 1
ikev2_dispatch_cert(int fd, struct iked_proc *p, struct imsg *imsg)
@


1.50
log
@Improve the iked acquire mode peer <-> policy matching.  This change
picks the peer from the acquire message and allows to match masked
peers in the policies like "peer any" or "peer 10.0.0.0/8" instead of
requiring exactly matching peer specifications.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.49 2011/04/18 08:45:43 reyk Exp $	*/
d421 2
a422 2
	if (sa_address(sa, &sa->sa_peer, &msg->msg_peer) == -1 ||
	    sa_address(sa, &sa->sa_local, &msg->msg_local) == -1)
@


1.49
log
@When the kernel wants to acquire an SA for an unknown flow, lookup a
matching policy and init a new IKE SA.  This adds support for "acquire mode"
from static flows.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.48 2011/04/15 13:10:49 reyk Exp $	*/
d64 2
d628 7
d650 1
a650 1
	    pol->pol_peer.addr_af)) == NULL)
d664 1
a664 1
	    &pol->pol_peer.addr, pol->pol_peer.addr.ss_len,
d3700 1
a3700 1
		if (ikev2_init_ike_sa(env, p) != 0)
@


1.48
log
@remove unused function ikev2_flows_delete()
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.47 2011/01/28 18:21:37 mikeb Exp $	*/
d1077 1
a1077 1
	TAILQ_FOREACH(flow, &pol->pol_flows, flow_entry) {
d3381 1
a3381 1
		TAILQ_FOREACH(flow, &sa->sa_policy->pol_flows, flow_entry) {
d3566 1
a3566 1
		RB_INSERT(iked_activeflows, &env->sc_activeflows, flow);
d3665 1
d3670 2
a3671 1
	flow = RB_FIND(iked_activeflows, &env->sc_activeflows, acquire);
d3673 28
a3700 3
		log_warnx("%s: flow wasn't found", __func__);
		return;
	}
d3702 4
a3705 3
	if ((sa = flow->flow_ikesa) == NULL) {
		log_warnx("%s: flow without SA", __func__);
		return;
a3706 4

	if (ikev2_send_create_child_sa(env, sa, NULL, flow->flow_saproto))
		log_warnx("%s: failed to initiate a CREATE_CHILD_SA exchange",
		    __func__);
@


1.47
log
@improve behavior of drop_sa: always negotiating a new child sa;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.46 2011/01/26 17:07:59 reyk Exp $	*/
a3612 30

	return (found ? 0 : -1);
}

int
ikev2_flows_delete(struct iked *env, struct iked_sa *sa, u_int8_t saproto)
{
	struct iked_flow	*flow, *nextflow;
	int			 found = 0;

	for (flow = TAILQ_FIRST(&sa->sa_flows); flow != NULL; flow = nextflow) {
		nextflow = TAILQ_NEXT(flow, flow_entry);

		if (saproto && flow->flow_saproto != saproto)
			continue;

		if (flow->flow_loaded)
			RB_REMOVE(iked_activeflows, &env->sc_activeflows, flow);

		if (pfkey_flow_delete(env->sc_pfkey, flow) != 0)
			log_debug("%s: failed to delete flow %p", __func__,
			    flow);
		else
			log_debug("%s: deleted flow %p", __func__, flow);

		TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
		flow_free(flow);

		found++;
	}
@


1.46
log
@Don't initiate any connections in passive mode, not even for ACQUIRE messages
from the PFKEY socket.  This is needed for sasyncd.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.45 2011/01/26 16:59:24 mikeb Exp $	*/
a3762 1
	struct iked_proposal		*prop;
a3765 1
	int				 nprop = 0;
a3777 4
	TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
		nprop++;
	}

d3783 4
a3786 8
	/*
	 * If that was the only Child SA pair and we initiated the
	 * exchange, drop SA altogether and reinitiate
	 */
	if (nprop == 2 && sa->sa_hdr.sh_initiator) {
		del->del_protoid = IKEV2_SAPROTO_IKE;
		del->del_spisize = 0;
		del->del_nspi = 0;
d3788 4
a3791 2
		ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
		    IKEV2_EXCHANGE_INFORMATIONAL, 0);
d3793 1
a3793 2
		log_debug("%s: reinitiate IKE SA", __func__);
		sa_state(env, sa, IKEV2_STATE_CLOSED);
d3795 9
a3803 7
		sa_free(env, sa);
		timer_register_initiator(env, ikev2_init_ike_sa);
	} else {
		if (csa->csa_allocated)
			spi32 = htobe32(csa->csa_spi.spi);
		else
			spi32 = htobe32(csa->csa_peerspi);
d3805 3
a3807 4
		if (ikev2_childsa_delete(env, sa, csa->csa_saproto,
		    csa->csa_peerspi, NULL, 0))
			log_debug("%s: failed to delete CHILD SA %s", __func__,
			    print_spi(csa->csa_peerspi, drop->spi_size));
d3809 1
a3809 1
		/* Send PAYLOAD_DELETE */
d3811 4
a3814 14
		if ((buf = ibuf_static()) == NULL)
			return;
		if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
			goto done;
		del->del_protoid = drop->spi_protoid;
		del->del_spisize = 4;
		del->del_nspi = htobe16(1);
		if (ibuf_add(buf, &spi32, sizeof(spi32)))
			goto done;

		if (ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
		    IKEV2_EXCHANGE_INFORMATIONAL, 0) == 0)
			sa->sa_stateflags |= IKED_REQ_INF;
	}
@


1.45
log
@get rid of acquire flows completely, as they tend to pass traffic
when there's no sa established (as pointed out by reyk).  instead
use require mode feature to send acquires from the kernel.  this
allows us to get rid of the code that changes flow mode to acquire
and keep all installed flows in the tree and save up on some code
that deals with renegotiation.  also several entities were renamed
(iked_acqflows -> iked_activeflows, iked_ipsecsas -> iked_activesas,
ikev2_acquire -> ikev2_acquire_sa).   ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.44 2011/01/26 16:35:17 mikeb Exp $	*/
d128 1
a128 4
		if (env->sc_passive)
			timer_unregister_initiator(env);
		else
			timer_register_initiator(env, ikev2_init_ike_sa);
d3695 3
@


1.44
log
@enable child sas and do sa and flow transfer after succeeding with
all the preparation steps.  don't forget to change {flow,csa}_ikesa
pointers when transefing to a different ike sa.  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.43 2011/01/25 10:58:41 mikeb Exp $	*/
d3554 1
a3554 1
		RB_INSERT(iked_ipsecsas, &env->sc_ipsecsas, csa);
d3569 2
d3581 1
a3581 1
	struct iked_childsa	*csa, key, *nextcsa = NULL;
d3594 3
a3609 3
		key.csa_spi = csa->csa_spi;
		if (RB_FIND(iked_ipsecsas, &env->sc_ipsecsas, &key))
			RB_REMOVE(iked_ipsecsas, &env->sc_ipsecsas, csa);
d3621 1
a3621 2
ikev2_flows_delete(struct iked *env, struct iked_sa *sa, u_int8_t saproto,
    int acquire)
d3632 11
a3642 36
		/*
		 * If we're asked to put a flow into acquire mode for
		 * the first time then remove it and add back with an
		 * appropriate configuration, otherwise there's nothing
		 * to do.
		 */
		if (!acquire) {
			if (flow->flow_acquire)
				RB_REMOVE(iked_acqflows, &env->sc_acqflows,
				    flow);
			if (pfkey_flow_delete(env->sc_pfkey, flow) != 0)
				log_debug("%s: failed to delete flow %p",
				    __func__, flow);
			else
				log_debug("%s: deleted flow %p",
				    __func__, flow);
			TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
			flow_free(flow);
		} else if (!flow->flow_acquire) {
			if (pfkey_flow_delete(env->sc_pfkey, flow) != 0)
				log_debug("%s: failed to delete flow %p",
				    __func__, flow);
			else
				log_debug("%s: deleted flow %p",
				    __func__, flow);
			flow->flow_acquire = 1;
			if (pfkey_flow_add(env->sc_pfkey, flow) != 0)
				log_debug("%s: failed to load acquire flow",
				    __func__);
			else {
				RB_INSERT(iked_acqflows, &env->sc_acqflows,
				    flow);
				log_debug("%s: loaded acquire flow %p",
				    __func__, flow);
			}
		}
d3694 1
a3694 1
ikev2_acquire(struct iked *env, struct iked_flow *acquire)
d3699 2
a3700 2
	if ((flow = RB_FIND(iked_acqflows, &env->sc_acqflows,
	    acquire)) == NULL) {
a3721 2
		if (csa->csa_rekey)
			(void)pfkey_sa_add(env->sc_pfkey, csa, NULL);
d3735 2
a3736 1
	if ((csa = RB_FIND(iked_ipsecsas, &env->sc_ipsecsas, &key)) == NULL)
d3770 2
a3771 3
	if ((csa = RB_FIND(iked_ipsecsas, &env->sc_ipsecsas, &key)) == NULL) {
		log_debug("%s: failed to find CHILD SA %s", __func__,
		    print_spi(drop->spi, drop->spi_size));
d3773 1
a3773 2
	}
	RB_REMOVE(iked_ipsecsas, &env->sc_ipsecsas, csa);
a3815 4

		/* delete flows for the specified protocol */
		if (ikev2_flows_delete(env, sa, csa->csa_saproto, 0))
			log_debug("%s: failed to delete flows", __func__);
@


1.43
log
@fixup child sa deletion in drop_sa;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.42 2011/01/24 17:44:28 mikeb Exp $	*/
a2277 16
		/* Transfer all Child SAs and flows from the old IKE SA */
		for (flow = TAILQ_FIRST(&sa->sa_flows); flow != NULL;
		     flow = nextflow) {
			nextflow = TAILQ_NEXT(flow, flow_entry);
			TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
			TAILQ_INSERT_TAIL(&nsa->sa_flows, flow,
			    flow_entry);
		}
		for (csa = TAILQ_FIRST(&sa->sa_childsas); csa != NULL;
		     csa = nextcsa) {
			nextcsa = TAILQ_NEXT(csa, csa_entry);
			TAILQ_REMOVE(&sa->sa_childsas, csa, csa_entry);
			TAILQ_INSERT_TAIL(&nsa->sa_childsas, csa,
			    csa_entry);
		}

a2349 5

		if (ikev2_childsa_enable(env, sa)) {
			log_debug("%s: failed to enable CHILD SAs", __func__);
			goto done;
		}
d2399 22
a2420 2
	ret = ikev2_msg_send_encrypt(env, sa, &e,
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, IKEV2_PAYLOAD_SA, 1);
a2421 1
	if (ret == 0 && protoid == IKEV2_SAPROTO_IKE) {
d2425 2
a2426 1
	}
@


1.42
log
@fixup previous for the responder mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.41 2011/01/21 18:02:53 mikeb Exp $	*/
a3839 1
		/* delete peer's SPI */
d3841 1
a3841 1
		    csa->csa_peerspi, NULL, 1))
@


1.41
log
@repair rekeying by sending appropriate traffic selector;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.40 2011/01/21 17:01:33 reyk Exp $	*/
d2413 1
a2413 1
		if ((len = ikev2_add_ts(e, &pld, len, sa, !initiator)) == -1)
@


1.40
log
@don't use memcmp on comparing two iked_addrs but IKED_ADDR_EQ.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.39 2011/01/21 16:51:38 reyk Exp $	*/
d96 1
a96 1
	    struct iked_sa *);
d900 1
a900 1
	if ((len = ikev2_add_ts(e, &pld, len, sa)) == -1)
d1164 1
a1164 1
    struct iked_sa *sa)
d1172 2
a1173 1
	if ((len = ikev2_add_ts_payload(e, IKEV2_PAYLOAD_TSi, sa)) == -1)
d1182 2
a1183 1
	if ((len = ikev2_add_ts_payload(e, IKEV2_PAYLOAD_TSr, sa)) == -1)
d1890 1
a1890 1
	if ((len = ikev2_add_ts(e, &pld, len, sa)) == -1)
d2082 1
a2082 1
	if ((len = ikev2_add_ts(e, &pld, len, sa)) == -1)
d2413 1
a2413 1
		if ((len = ikev2_add_ts(e, &pld, len, sa)) == -1)
@


1.39
log
@- Fix traffic selector configuration that it is always "from $localnet
to $peernet" and not depending on the initiator/responder mode.
- Remove the flow hash calculated but not used anymore.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.38 2011/01/21 13:19:35 reyk Exp $	*/
d3386 4
a3389 4
				if (memcmp(&saflow->flow_src, &flow->flow_src,
				    sizeof(struct iked_addr)) == 0 &&
				    memcmp(&saflow->flow_dst, &flow->flow_dst,
				    sizeof(struct iked_addr)) == 0 &&
@


1.38
log
@Remove misleading error message.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.37 2011/01/21 13:09:46 reyk Exp $	*/
d95 3
a97 1
ssize_t	 ikev2_add_ts(struct ibuf *, u_int, struct iked_sa *);
d900 1
a900 16
	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_TSi) == -1)
		goto done;

	/* TSi payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSi, sa)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_TSr) == -1)
		goto done;

	/* TSr payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSr, sa)) == -1)
d1062 1
a1062 1
ikev2_add_ts(struct ibuf *buf, u_int type, struct iked_sa *sa)
d1084 11
a1094 5
		if (type == IKEV2_PAYLOAD_TSi)
			addr = &flow->flow_src;
		else if (type == IKEV2_PAYLOAD_TSr)
			addr = &flow->flow_dst;
		else
d1162 25
d1888 1
a1888 16
	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_TSi) == -1)
		goto done;

	/* TSi payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSi, sa)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_TSr) == -1)
		goto done;

	/* TSr payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSr, sa)) == -1)
d2080 1
a2080 18
	if (ikev2_next_payload(pld, len,
	    initiator ? IKEV2_PAYLOAD_TSi : IKEV2_PAYLOAD_TSr) == -1)
		goto done;

	/* TSi payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSi, sa)) == -1)
		goto done;

	if (ikev2_next_payload(pld, len,
	    initiator ? IKEV2_PAYLOAD_TSr : IKEV2_PAYLOAD_TSi) == -1)
		goto done;

	/* TSr payload */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSr, sa)) == -1)
d2411 1
a2411 18
		if (ikev2_next_payload(pld, len,
		    initiator ? IKEV2_PAYLOAD_TSr : IKEV2_PAYLOAD_TSi) == -1)
			goto done;

		/* TSi payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSi, sa)) == -1)
			goto done;

		if (ikev2_next_payload(pld, len,
		    initiator ? IKEV2_PAYLOAD_TSi : IKEV2_PAYLOAD_TSr) == -1)
			goto done;

		/* TSr payload */
		if ((pld = ikev2_add_payload(e)) == NULL)
			goto done;
		if ((len = ikev2_add_ts(e, IKEV2_PAYLOAD_TSr, sa)) == -1)
d2422 1
a3319 2
	EVP_MD_CTX		 ctx;
	u_int8_t		 md[SHA_DIGEST_LENGTH];
d3321 1
a3321 1
	u_int			 i, mdlen;
a3377 23
	/*
	 * Generate a hash of the negotiated flows to detect a possible
	 * IKEv2 traffic selector re-negotiation.
	 */
	EVP_DigestInit(&ctx, EVP_sha1());
	TAILQ_FOREACH(prop, &sa->sa_proposals, prop_entry) {
		if (ikev2_valid_proposal(prop, NULL, NULL) != 0)
			continue;

		TAILQ_FOREACH(flow, &sa->sa_policy->pol_flows, flow_entry) {
			/* Use the inbound flow to generate the hash */
			i = IPSP_DIRECTION_IN;
			EVP_DigestUpdate(&ctx, &i, sizeof(i));
			EVP_DigestUpdate(&ctx, &flow->flow_src,
			    sizeof(flow->flow_src));
			EVP_DigestUpdate(&ctx, &flow->flow_dst,
			    sizeof(flow->flow_dst));
		}
	}
	mdlen = sizeof(sa->sa_flowhash);
	EVP_DigestFinal(&ctx, md, &mdlen);
	memcpy(&sa->sa_flowhash, &md, sizeof(md));

d3402 1
a3402 2
			flowa->flow_dir = sa->sa_hdr.sh_initiator ?
			    IPSP_DIRECTION_OUT : IPSP_DIRECTION_IN;
d3418 1
a3418 2
			flowb->flow_dir = sa->sa_hdr.sh_initiator ?
			    IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;
d3827 1
d3829 1
@


1.37
log
@don't create child sas from empty proposals.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.36 2011/01/21 11:56:00 reyk Exp $	*/
d3817 1
a3817 3
	if ((csa = RB_FIND(iked_ipsecsas, &env->sc_ipsecsas, &key)) == NULL) {
		log_warnx("%s: SA %s is not registered as active", __func__,
		    print_spi(rekey->spi, rekey->spi_size));
d3819 1
a3819 1
	}
@


1.36
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.35 2011/01/21 11:37:02 reyk Exp $	*/
d2139 1
a2139 1
	struct iked_proposal		*prop, *mprop = msg->msg_prop;
d2151 1
a2151 1
	if (mprop == NULL) {
d2243 1
a2243 1
	if (!ikev2_msg_frompeer(msg))
d2252 1
a2252 2
		if (msg->msg_prop &&
		    msg->msg_prop->prop_protoid == IKEV2_SAPROTO_IKE) {
@


1.35
log
@split pfkey initialization into a privileged and unprivileged part to
prevent a possible crash.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.34 2011/01/17 18:57:42 reyk Exp $	*/
d139 2
d642 1
a642 1
	    pol->pol_peer.ss_family)) == NULL)
d656 2
a657 2
	    &pol->pol_peer, pol->pol_peer.ss_len,
	    &pol->pol_local, pol->pol_local.ss_len, 0)) == NULL)
@


1.34
log
@silence stupid gcc warning by initializing a variable with NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.33 2011/01/17 18:49:35 mikeb Exp $	*/
d134 1
a134 1
		return (config_getpfkey(env, imsg, pfkey_dispatch));
@


1.33
log
@Add initial acquire mode support and use it whenever Windows peers decide
to drop Child SA based on the inactivity timer.  In this case we instruct
the kernel to send us an acquire message upon receiving a packet for those
hosts and initiate a Child SA creation exchange ourselves.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.32 2011/01/12 14:26:26 mikeb Exp $	*/
d2021 1
a2021 1
	struct iked_childsa		*csa, *csb = NULL;
@


1.32
log
@decouple flow deletion from the ikev2_childsa_delete;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.31 2011/01/12 14:23:53 mikeb Exp $	*/
d74 2
a75 2
int	 ikev2_rekey_child_sa(struct iked *, struct iked_sa *,
	    struct iked_spi *);
d2018 2
a2019 2
ikev2_rekey_child_sa(struct iked *env, struct iked_sa *sa,
    struct iked_spi *rekey)
d2030 6
a2035 3
	log_debug("%s: rekey %s spi %s", __func__,
	    print_map(rekey->spi_protoid, ikev2_saproto_map),
	    print_spi(rekey->spi, rekey->spi_size));
d2039 2
a2040 1
	if ((csa = childsa_lookup(sa, rekey->spi,
d2042 1
a2042 1
	    (csb = csa->csa_peersa) == NULL) {
d2062 1
a2062 1
	    rekey->spi_protoid, 1, 0)) == -1)
d2095 3
a2097 2
	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NOTIFY) == -1)
		goto done;
d2099 15
a2113 14
	/* REKEY_SA notification */
	if ((pld = ikev2_add_payload(e)) == NULL)
		goto done;
	if ((n = ibuf_advance(e, sizeof(*n))) == NULL)
		goto done;
	n->n_type = htobe16(IKEV2_N_REKEY_SA);
	n->n_protoid = rekey->spi_protoid;
	n->n_spisize = rekey->spi_size;
	if ((ptr = ibuf_advance(e, rekey->spi_size)) == NULL)
		goto done;
	len = rekey->spi_size;
	spi = htobe32((u_int32_t)csa->csa_peerspi);
	memcpy(ptr, &spi, rekey->spi_size);
	len += sizeof(*n);
d2121 4
a2124 2
		csa->csa_rekey = 1;
		csb->csa_rekey = 1;
d2140 2
a2141 2
	struct ibuf			*buf;
	u_int64_t			 peerspi/* , localspi */;
d2143 1
a2143 1
	int				 ret = -1;
d2168 3
a2170 2
	if ((csa = childsa_lookup(sa, peerspi, prop->prop_protoid)) == NULL) {
		log_debug("%s: failed to find a CHILD SA %s", __func__,
a2171 1
		return (-1);
d2187 5
a2191 2
	if ((buf = ibuf_static()) == NULL)
		goto done;
d2193 2
a2194 2
	if ((del = ibuf_advance(buf, sizeof(*del))) == NULL)
		goto done;
d2196 3
a2198 3
	del->del_protoid = prop->prop_protoid;
	del->del_spisize = sizeof(spi32);
	del->del_nspi = htobe16(1);
d2200 3
a2202 3
	spi32 = htobe32(csa->csa_peerspi);
	if (ibuf_add(buf, &spi32, sizeof(spi32)))
		goto done;
d2204 3
a2206 3
	if (ikev2_send_ike_e(env, sa, buf, IKEV2_PAYLOAD_DELETE,
	    IKEV2_EXCHANGE_INFORMATIONAL, 0))
		goto done;
d2208 2
a2209 1
	sa->sa_stateflags |= IKED_REQ_INF | IKED_REQ_DELETE;
d2233 1
a2233 1
	struct ibuf			*buf, *e = NULL, *nonce = NULL;
d3674 2
a3675 1
ikev2_flows_delete(struct iked *env, struct iked_sa *sa, u_int8_t saproto)
d3685 38
a3722 6
		if (pfkey_flow_delete(env->sc_pfkey, flow) != 0)
			log_debug("%s: failed to delete flow %p",
			    __func__, flow);
		else
			log_debug("%s: deleted flow %p",
			    __func__, flow);
a3723 3

		TAILQ_REMOVE(&sa->sa_flows, flow, flow_entry);
		flow_free(flow);
d3773 22
d3835 1
a3835 1
	if (ikev2_rekey_child_sa(env, sa, rekey))
d3843 1
a3847 1
	struct ibuf			*buf;
d3901 1
a3901 1
		if (ikev2_flows_delete(env, sa, csa->csa_saproto))
@


1.31
log
@fixup bogus check;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.30 2011/01/12 14:22:25 mikeb Exp $	*/
d941 1
a941 1
		ikev2_childsa_delete(env, sa, 0, 0, NULL, IKED_DEL_NOTLOADED);
d1899 1
a1899 1
		ikev2_childsa_delete(env, sa, 0, 0, NULL, IKED_DEL_NOTLOADED);
d2205 1
a2205 1
		ikev2_childsa_delete(env, sa, 0, 0, NULL, IKED_DEL_NOTLOADED);
d2449 1
a2449 2
			ikev2_childsa_delete(env, sa, 0, 0, NULL,
			    IKED_DEL_NOTLOADED);
d3620 1
a3620 1
    u_int64_t spi, u_int64_t *spiptr, int flags)
a3622 1
	struct iked_flow	*flow, *nextflow;
d3632 1
a3632 1
		    ((flags & IKED_DEL_NOTLOADED) && !csa->csa_loaded))
d3658 8
a3665 2
	if ((flags & IKED_DEL_FLOWS) == 0)
		return (found ? 0 : -1);
d3742 1
a3742 1
	(void)ikev2_childsa_delete(env, sa, 0, 0, NULL, IKED_DEL_NOTLOADED);
d3832 1
a3832 2
		    csa->csa_peerspi, NULL, IKED_DEL_FLOWS |
		    IKED_DEL_NOTLOADED))
d3836 4
a3950 1
 
@


1.30
log
@don't forget to specify spi sizes;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.29 2010/12/23 15:11:19 mikeb Exp $	*/
d3651 1
a3651 2
		if (csa->csa_loaded ||
		    RB_FIND(iked_ipsecsas, &env->sc_ipsecsas, &key))
@


1.29
log
@always add a none payload, should fix ike sa rekeying for responders; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.28 2010/12/22 17:53:54 reyk Exp $	*/
d3499 1
d3512 1
@


1.28
log
@move and rename util.c:print_id() to ikev2.c:ikev2_print_id() because
it is too specific to be in util.c.  This will allow to link util.c
into ikectl later without all the other dependencies of pritn_id().
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.27 2010/12/22 16:22:27 mikeb Exp $	*/
d2431 1
d2433 2
a2434 3
		if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_NONE) == -1)
			goto done;
	}
@


1.27
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.26 2010/12/01 12:01:25 reyk Exp $	*/
d1004 1
a1004 1
	if (print_id(id, idstr, sizeof(idstr)) == -1)
d3268 1
a3268 1
	if (print_id(id, idstr, sizeof(idstr)) == -1) {
d3853 91
@


1.26
log
@Clarify the internal ibuf API: rename ibuf_copy() to ibuf_get() because
it returns a new buffer from the internal read offset like stdio get
functions do and not the same buffer when it is called multiple times.
Also rename the old ibuf_get() to ibuf_getdata() because it returns
a "special" data type and it matches the stdio get* conventions.

pointed out by mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.25 2010/09/22 09:12:18 mikeb Exp $	*/
d73 4
d85 2
a86 3
int	 ikev2_childsa_negotiate(struct iked *, struct iked_sa *,
	    struct iked_spi *);
int	 ikev2_childsa_enable(struct iked *, struct iked_sa *);
d91 1
a91 1
	    struct iked_proposals *, u_int8_t);
d134 1
a134 1
		return (config_getpfkey(env, imsg));
d233 1
a233 1
			log_debug("%s: invalid cert reply");
d336 1
a336 1
	u_int			 initiator;
d338 1
a338 1
	struct ike_header	*hdr;
d361 2
a362 2
	if ((sa = msg->msg_sa) != NULL) {
		log_debug("%s: updating msg, natt %d", __func__, msg->msg_natt);
d364 1
a364 2
		if (msg->msg_natt)
			sa->sa_natt = 1;
d366 2
a367 5
		if (betoh32(hdr->ike_msgid) < sa->sa_msgid) {
			log_debug("%s: invalid sequence number", __func__);
			return;
		} else
			sa->sa_msgid = betoh32(hdr->ike_msgid);
d369 4
a372 3
		if (sa_address(sa, &sa->sa_peer, &msg->msg_peer) == -1 ||
		    sa_address(sa, &sa->sa_local, &msg->msg_local) == -1)
			return;
d374 23
a396 1
		sa->sa_fd = msg->msg_fd;
d398 18
a415 3
		log_debug("%s: updated SA peer %s local %s", __func__,
		    print_host(&sa->sa_peer.addr, NULL, 0),
		    print_host(&sa->sa_local.addr, NULL, 0));
d418 11
d581 1
a581 1
			log_debug("%s: invalid new SA %p", sa);
d611 4
d629 1
a629 1
	struct ikev2_notify		 *n;
d668 1
a668 1
	if ((hdr = ikev2_add_header(buf, sa, 0,
d676 1
a676 1
	    IKEV2_SAPROTO_IKE)) == -1)
d792 1
a792 1
}	
d893 1
a893 1
	    IKEV2_SAPROTO_ESP)) == -1)
d934 1
a934 1
	ret = ikev2_childsa_negotiate(env, sa, NULL);
d940 2
d1373 2
a1374 1
    struct iked_proposals *proposals, u_int8_t protoid)
d1380 1
a1380 1
	ssize_t				 length = 0, saplength, ret, n;
a1384 1
	n = 0;
d1389 1
a1389 2
		if (protoid != IKEV2_SAPROTO_IKE &&
		    sa->sa_hdr.sh_initiator) {
d1409 7
d1442 1
a1442 1
			if ((ret = ikev2_add_transform(buf,
d1449 1
a1449 1
			saplength += ret;
d1646 1
a1646 1
	    IKEV2_SAPROTO_IKE)) == -1)
d1770 1
a1770 1
	if (ikev2_childsa_negotiate(env, sa, NULL) == -1)
d1865 1
a1865 1
	    IKEV2_SAPROTO_ESP)) == -1)
d1898 2
a1900 1

d2018 2
a2019 1
ikev2_resp_create_child_sa(struct iked *env, struct iked_message *msg)
d2021 2
d2024 3
a2026 3
	struct ibuf			*e = NULL, *nonce = NULL;
	u_int				 firstpayload;
	int				 ret = -1;
d2028 1
a2028 5
	struct iked_sa			*sa = msg->msg_sa;
	struct iked_spi			*rekey = &msg->msg_rekey;

	if (!ikev2_msg_frompeer(msg))
		return (0);
d2034 7
a2040 8
	if (rekey->spi_protoid == 0) {
		/* Default to IKE_SA if REKEY_SA was not notified */
		rekey->spi_protoid = IKEV2_SAPROTO_IKE;
		if (sa->sa_hdr.sh_initiator)
			rekey->spi = sa->sa_hdr.sh_rspi;
		else
			rekey->spi = sa->sa_hdr.sh_ispi;
		rekey->spi_size = 8;
d2043 3
a2045 2
	if (ikev2_childsa_negotiate(env, sa, rekey) == -1)
		return (-1);
d2047 3
a2049 4
	if (sa->sa_hdr.sh_initiator)
		nonce = sa->sa_inonce;
	else
		nonce = sa->sa_rnonce;
d2052 1
a2052 1
		return (-1);
a2056 1
	firstpayload = IKEV2_PAYLOAD_SA;
d2058 1
a2058 1
	    IKEV2_SAPROTO_ESP)) == -1)
d2071 2
a2072 1
	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_TSi) == -1)
d2081 2
a2082 1
	if (ikev2_next_payload(pld, len, IKEV2_PAYLOAD_TSr) == -1)
d2091 18
d2113 330
a2442 3
	    IKEV2_EXCHANGE_CREATE_CHILD_SA, firstpayload, 1);
	if (ret == 0)
		ret = ikev2_childsa_enable(env, sa);
d2445 7
d3330 1
a3330 2
ikev2_childsa_negotiate(struct iked *env, struct iked_sa *sa,
    struct iked_spi *rekey)
d3335 2
a3336 1
	struct iked_flow	*flow, *flowa, *flowb;
d3338 3
d3343 1
a3343 5
	int			 ret = -1;
	u_int32_t		 spi = 0, flowloaded = 0;
	struct iked_id		*peerid, *localid;
	EVP_MD_CTX		 ctx;
	u_int8_t		 md[SHA_DIGEST_LENGTH];
d3359 1
a3359 3
	sa_stateflags(sa, IKED_REQ_CHILDSA);

	/* We need to determinate the key material length first */
a3418 26

	/* Check the existing flows */
	if (rekey != NULL) {
		if (memcmp(&sa->sa_flowhash, &md, sizeof(md)) == 0) {
			flowloaded = 0;
			TAILQ_FOREACH(flow, &sa->sa_flows,
			    flow_entry) {
				/* Mark the flow as unloaded */
				if (flow->flow_peerspi == rekey->spi) {
					flow->flow_loaded = 0;
					flowloaded++;
				}
			}
			log_debug("%s: keeping %d flows",
			    __func__, flowloaded);
		}

		/* XXX Check ESP/AH/IKE */
		if (ikev2_childsa_delete(env, sa,
		    rekey->spi_protoid, rekey->spi, NULL, 1) == -1) {
			log_debug("%s: failed to disable old SA %s",
			    __func__, print_spi(rekey->spi, rekey->spi_size));
			return (-1);
		}
	}

d3427 12
a3452 5
			flowa->flow_peerspi = prop->prop_peerspi.spi;
			if (flowloaded)
				flowa->flow_loaded = 1;

			TAILQ_INSERT_TAIL(&sa->sa_flows, flowa, flow_entry);
d3456 1
d3469 1
d3474 1
a3474 1
	/* Create the CHILD SAs using the key material */
d3490 1
d3492 2
a3493 2
		if (sa->sa_hdr.sh_initiator) {
			/* Initiator -> Responder */
d3497 1
a3497 1
			csa->csa_peerspi = spi = prop->prop_localspi.spi;
a3499 1
			/* Responder <- Initiator */
d3504 2
a3505 2
			if ((ret = pfkey_sa_init(env->sc_pfkey,
			    csa, &spi)) != 0)
d3507 1
a3510 1
			csa->csa_allocated = 1;
a3529 2
		TAILQ_INSERT_TAIL(&sa->sa_childsas, csa, csa_entry);

d3532 1
d3537 2
d3551 1
d3559 1
d3564 1
d3566 3
d3586 1
a3586 1
		if (csa->csa_rekey)
d3591 2
a3592 1
			    __func__, print_spi(csa->csa_spi.spi, 4));
d3596 2
d3599 1
a3599 1
		    print_spi(csa->csa_spi.spi, 4));
d3602 2
a3603 2
	TAILQ_FOREACH(flow, &sa->sa_flows, flow_entry) { 
		if (flow->flow_rekey)
d3619 1
a3619 1
    u_int64_t spi, u_int64_t *spiptr, int rekey)
d3621 1
a3621 1
	struct iked_childsa	*csa, *nextcsa;
d3623 1
a3624 7
	u_int64_t		 localspi = 0;
	const char		*action;

	if (spiptr)
		*spiptr = 0;

	action = rekey ? "disable" : "delete";
d3629 4
a3632 2
		if (csa->csa_saproto != saproto ||
		    csa->csa_peerspi != spi)
a3634 2
		if (csa->csa_spi.spi != spi)
			localspi = csa->csa_spi.spi;
d3636 3
a3638 2
			log_debug("%s: failed to %s CHILD SA spi %s",
			    __func__, action, print_spi(csa->csa_spi.spi, 4));
d3640 3
a3642 2
			log_debug("%s: %sd CHILD SA spi %s", __func__,
			    action, print_spi(csa->csa_spi.spi, 4));
d3645 7
a3651 4
		if (rekey) {
			csa->csa_rekey = 1;
			continue;
		}
d3656 6
d3665 1
a3665 2
		if (flow->flow_saproto != saproto ||
		    flow->flow_peerspi != spi)
d3668 2
a3669 2
			log_debug("%s: failed to %s flow %p",
			    __func__, action, flow);
d3671 2
a3672 2
			log_debug("%s: %sd flow %p",
			    __func__, action, flow);
a3674 4
		if (rekey) {
			flow->flow_rekey = 1;
			continue;
		}
a3678 3
	if (spiptr)
		*spiptr = localspi;

d3723 129
@


1.25
log
@support INVALID_KE_PAYLOAD notification sent by the responder in case
the initiator chose wrong D-H group.  in this case we throw away our
SA and start over with a proper group.

makes iked work as an initiator with strongswan/charon without any
specific "ikesa" (phase 1) configuration.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.24 2010/09/09 13:06:46 mikeb Exp $	*/
d2715 8
a2722 7
	if ((sa->sa_key_d = ibuf_copy(t, hash_length(prf))) == NULL ||
	    (sa->sa_key_iauth = ibuf_copy(t, hash_keylength(integr))) == NULL ||
	    (sa->sa_key_rauth = ibuf_copy(t, hash_keylength(integr))) == NULL ||
	    (sa->sa_key_iencr = ibuf_copy(t, cipher_keylength(encr))) == NULL ||
	    (sa->sa_key_rencr = ibuf_copy(t, cipher_keylength(encr))) == NULL ||
	    (sa->sa_key_iprf = ibuf_copy(t, hash_length(prf))) == NULL ||
	    (sa->sa_key_rprf = ibuf_copy(t, hash_length(prf))) == NULL) {
d3121 1
a3121 1
		if (encrxf && (csa->csa_encrkey = ibuf_copy(keymat,
d3128 1
a3128 1
		if (integrxf && (csa->csa_integrkey = ibuf_copy(keymat,
d3154 1
a3154 1
		if (encrxf && (csb->csa_encrkey = ibuf_copy(keymat,
d3161 1
a3161 1
		if (integrxf && (csb->csa_integrkey = ibuf_copy(keymat,
@


1.24
log
@- allow esp proposals without integrity and ah proposals without
  encryption;

- add additional nonce length field, use that for the ciphers that
  require additional keying material;

- setup right flow direction depending on the mode: fixes up iked
  working as an initiator against charon.

tested by me and jsg.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.23 2010/07/29 14:41:21 jsg Exp $	*/
a63 1
int	 ikev2_init_ike_sa(struct iked *, struct iked_policy *);
d594 3
@


1.23
log
@some error cases returned 01 when they should have been returning -1
spotted by Mike Belopuhov.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.22 2010/07/20 16:28:22 deraadt Exp $	*/
d2260 7
a2266 1
				} else if (protoid != IKEV2_SAPROTO_IKE &&
a2268 1
				    (i == IKEV2_XFORMTYPE_INTEGR) ||
d2964 3
d3047 2
a3048 1
			flowa->flow_dir = IPSP_DIRECTION_IN;
d3068 2
a3069 1
			flowb->flow_dir = IPSP_DIRECTION_OUT;
d3118 8
a3125 3
		if ((csa->csa_encrkey = ibuf_copy(keymat,
		    encrxf->xform_keylength / 8)) == NULL ||
		    (csa->csa_integrkey = ibuf_copy(keymat,
d3127 2
a3128 1
			log_debug("%s: failed to get CHILD SA keys", __func__);
d3151 8
a3158 3
		if ((csb->csa_encrkey = ibuf_copy(keymat,
		    encrxf->xform_keylength / 8)) == NULL ||
		    (csb->csa_integrkey = ibuf_copy(keymat,
d3160 2
a3161 1
			log_debug("%s: failed to get CHILD SA keys", __func__);
d3298 1
a3298 2
		if (xform->xform_type ==
		    IKEV2_XFORMTYPE_ENCR)
d3300 1
a3300 2
		else if (xform->xform_type ==
		    IKEV2_XFORMTYPE_INTEGR)
d3303 11
a3313 3
	/* XXX support non-auth / non-enc proposals */
	if (encrxf == NULL || integrxf == NULL)
		return (-1);
@


1.22
log
@two iterators should be u_int; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.21 2010/07/03 16:59:35 reyk Exp $	*/
d2372 1
a2372 1
			return (01);
d2383 1
a2383 1
			return (01);
@


1.21
log
@Better non-debug logging messages when a session is established/closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.20 2010/06/27 05:40:49 reyk Exp $	*/
d1323 1
a1323 1
	ssize_t				 i, length = 0, saplength, ret, n;
d1326 1
d3263 1
a3263 1
	size_t			 i;
@


1.20
log
@fix possible double free of the initiator cert
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.19 2010/06/27 01:03:22 reyk Exp $	*/
d387 1
a387 1
	if (sa != NULL && sa->sa_state == IKEV2_STATE_DELETE)
d884 1
a884 1
		sa_state(env, sa, IKEV2_STATE_RUNNING);
d1513 1
a1513 1
			sa_state(env, sa, IKEV2_STATE_DELETE);
d1524 1
a1524 1
			sa_state(env, sa, IKEV2_STATE_DELETE);
d1832 1
a1832 1
		sa_state(env, sa, IKEV2_STATE_RUNNING);
@


1.19
log
@Instead of modifying and fiddling with the IKE SA in the payload
parsing routines directly, first parse the message and save the parsed
elements in the temporary message struct before validating the
information and taking any other actions on the actual SA.  This needs
more testing, but is the cleaner and better approach.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.17 2010/06/26 19:48:04 reyk Exp $	*/
d429 1
a429 1
		bzero(&msg->msg_id, sizeof(msg->msg_id));
d908 1
@


1.18
log
@revert the files that have been accidentally committed with my
previous parse.y change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.16 2010/06/26 18:32:34 reyk Exp $	*/
d59 2
a60 1
int	 ikev2_ike_auth(struct iked *, struct iked_sa *);
d67 1
a67 2
int	 ikev2_init_done(struct iked *, struct iked_sa *,
	    struct iked_message *);
d225 1
a225 1
		if (ikev2_ike_auth(env, sa) != 0)
d259 1
a259 1
		if (ikev2_ike_auth(env, sa) != 0)
d287 1
a287 1
		if (ikev2_ike_auth(env, sa) != 0)
d392 2
a393 1
ikev2_ike_auth(struct iked *env, struct iked_sa *sa)
d395 112
d509 1
a509 1
			return (ikev2_init_done(env, sa, NULL));
d561 1
a561 1
		(void)ikev2_init_done(env, sa, msg);
d873 1
a873 2
ikev2_init_done(struct iked *env, struct iked_sa *sa,
    struct iked_message *msg)
a876 12
	if (msg != NULL && !TAILQ_EMPTY(&msg->msg_proposals)) {
		if (ikev2_sa_negotiate(sa,
		    &sa->sa_policy->pol_proposals,
		    &msg->msg_proposals, IKEV2_SAPROTO_ESP) != 0) {
			log_debug("%s: no proposal chosen", __func__);
			msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
			sa_state(env, sa, IKEV2_STATE_DELETE);
			return (-1);
		} else
			sa_stateflags(sa, IKED_REQ_SA);
	}

d1151 1
a1151 4
		if (msg->msg_decrypted)
			buf = msg->msg_decrypted->msg_data;
		else
			buf = msg->msg_data;
a1526 13

		if (!TAILQ_EMPTY(&msg->msg_proposals)) {
			if (ikev2_sa_negotiate(sa,
			    &sa->sa_policy->pol_proposals,
			    &msg->msg_proposals, IKEV2_SAPROTO_ESP) != 0) {
				log_debug("%s: no proposal chosen", __func__);
				msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
				sa_state(env, sa, IKEV2_STATE_DELETE);
				return;
			} else
				sa_stateflags(sa, IKED_REQ_SA);
		}

d1531 1
a1531 1
		if (ikev2_resp_ike_auth(env, sa) != 0) {
d2086 1
a2086 1
	if (sa != NULL && msg->msg_decrypted) {
@


1.17
log
@mixing any (AF_UNSPEC) with AF_INET/INET6 is not an address family mismatch
@
text
@a763 15
	struct ibuf	*authmsg;

	if (msg->msg_id.id_type) {
		memcpy(&sa->sa_rid, &msg->msg_id, sizeof(sa->sa_rid));
		bzero(&msg->msg_id, sizeof(msg->msg_id));

		if ((authmsg = ikev2_msg_auth(env, sa, 0)) == NULL) {
			log_debug("%s: failed to get response auth data",
			    __func__);
			return (-1);
		}

		ca_setauth(env, sa, authmsg, PROC_CERT);
		return (0);
	}
@


1.16
log
@Include the Id type in the generated SA tag that is passed to the
kernel, just like isakmpd does it.  In difference to isakmpd, the Id
type is printed in capital letters, eg. FQDN/foo.example.com, because
it is using the existing print_map() API.  For consistency, rename a
few Id types in grammar and code from the RFC-names to the
OpenBSD-style names; including RFC822_ADDR to UFQDN, IPV4_ADDR to just
IPV4, DER_ASN1_DN to ASN1_DN etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.14 2010/06/14 23:14:09 reyk Exp $	*/
d764 15
@


1.15
log
@further cleanup of the dh code:
- remove dh_selftest(), this should go into regress somewhere
- remove any iked-specific dependencies from dh.c/dh.h which allows us to
use this code in other projects as well.
@
text
@d222 1
a222 1
			log_debug("%s: peer certificate is invalid", __func__);
d241 1
d273 1
d818 1
d824 1
a824 1
	case IKEV2_ID_IPV4_ADDR:
d831 1
a831 1
	case IKEV2_ID_IPV6_ADDR:
d847 1
a847 1
	if (print_id(id, sizeof(hdr), idstr, sizeof(idstr)) == -1)
d850 1
a850 1
	log_debug("%s: %s %s/%s length %d", __func__,
a851 1
	    print_map(id->id_type, ikev2_id_map),
d1430 1
d2762 1
a2762 2
	if (print_id(id, sizeof(struct ikev2_id),
	    idstr, sizeof(idstr)) == -1) {
d2768 2
a2769 1
	if (*idstr == '/' && (idrepl = strstr(idstr, "CN=")) != NULL) {
d2793 1
a2793 1
		else if (id->id_type == IKEV2_ID_RFC822_ADDR)
@


1.14
log
@Initiator mode with certificates;  needs more work but works.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.13 2010/06/14 21:12:56 reyk Exp $	*/
d2250 2
a2251 1
			log_debug("%s: invalid dh", __func__);
@


1.13
log
@Initial support for initiator mode which allows to run iked as a
"client" or to configure iked to iked (OpenBSD to OpenBSD) IKEv2 VPNs.

It currently only supports psk (pre-shared keys) and no certificates,
doesn't do any rekeying or SA timeouts, and needs more cleanup.  So it
is not quite production ready yet - but ready for simple tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.12 2010/06/14 14:17:49 reyk Exp $	*/
d59 1
d64 4
a67 2
int	 ikev2_init_ike_auth(struct iked *, struct iked_message *);
int	 ikev2_init_done(struct iked *, struct iked_message *);
d219 1
d221 1
a221 1
		} else
d223 1
d225 2
a226 4
		sa_stateflags(sa, IKED_REQ_VALID);

		if (ikev2_resp_ike_auth(env, sa) != 0)
			log_debug("%s: failed to send auth response", __func__);
d258 2
a259 2
		if (ikev2_resp_ike_auth(env, sa) != 0)
			log_debug("%s: failed to send auth response", __func__);
d285 2
a286 2
		if (ikev2_resp_ike_auth(env, sa) != 0)
			log_debug("%s: failed to send auth response", __func__);
d389 12
d443 1
a443 1
		(void)ikev2_init_ike_auth(env, msg);
d446 1
a446 1
		(void)ikev2_init_done(env, msg);
d598 1
a598 1
ikev2_init_ike_auth(struct iked *env, struct iked_message *msg)
a600 9
	struct iked_policy		*pol = sa->sa_policy;
	struct ikev2_payload		*pld;
	struct ikev2_cert		*cert;
	struct ikev2_auth		*auth;
	struct iked_id			*id, *certid;
	struct ibuf			*e = NULL;
	u_int8_t			 firstpayload;
	int				 ret = -1;
	ssize_t				 len;
d617 20
a636 2
	/* XXX this doesn't work with certificates */
	ca_setauth(env, sa, authmsg, PROC_CERT);
d639 1
a639 1
		return (0);	/* ignore */
d662 1
a662 1
	if ((sa->sa_staterequire & IKED_REQ_CERT) &&
d675 16
d758 2
a759 1
ikev2_init_done(struct iked *env, struct iked_message *msg)
a760 1
	struct iked_sa	*sa = msg->msg_sa;
d763 1
a763 1
	if (!TAILQ_EMPTY(&msg->msg_proposals)) {
d1561 1
a1561 1
	if (env->sc_certreqtype && (sa->sa_staterequire & IKED_REQ_CERT)) {
d1665 1
a1665 1
		if ((sa->sa_staterequire & IKED_REQ_CERT) &&
d1786 1
a1786 1
	if ((sa->sa_staterequire & IKED_REQ_CERT) &&
@


1.12
log
@fix EAP responder mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.11 2010/06/14 14:03:15 reyk Exp $	*/
d63 2
d85 2
a86 1
ssize_t	 ikev2_add_proposals(struct ibuf *, struct iked_proposals *, u_int8_t);
d400 8
d428 2
d431 2
d434 1
a437 2
	default:
		break;
a438 3

	if (sa->sa_state == IKEV2_STATE_DELETE)
		sa_free(env, sa);
d481 1
d485 1
a485 2
	    IKEV2_PAYLOAD_SA, IKEV2_EXCHANGE_IKE_SA_INIT,
	    IKEV2_FLAG_INITIATOR)) == NULL)
d491 1
a491 1
	if ((len = ikev2_add_proposals(buf, &pol->pol_proposals,
d571 2
a572 1
	ret = ikev2_msg_send(env, req.msg_fd, &req);
d583 165
d1176 2
a1177 2
ikev2_add_proposals(struct ibuf *buf, struct iked_proposals *proposals,
    u_int8_t protoid)
d1182 1
d1185 1
a1185 1
	u_int32_t			 spi32;
d1192 16
d1212 1
d1454 1
a1454 1
	if ((len = ikev2_add_proposals(buf, &sa->sa_proposals,
d1673 1
a1673 1
	if ((len = ikev2_add_proposals(e, &sa->sa_proposals,
d1868 1
a1868 1
	if ((len = ikev2_add_proposals(e, &sa->sa_proposals,
d2054 1
a2054 1
	struct iked_proposal	*ppeer = NULL, *plocal, *prop, values;
d2061 2
a2062 1
	bzero(&values, sizeof(values));
d2150 2
a2151 1
				memcpy(&values, ppeer, sizeof(values));
d2164 1
a2164 1
	prop = config_add_proposal(&sa->sa_proposals, values.prop_id, protoid);
d2166 7
a2172 4
	if (values.prop_localspi.spi_size) {
		prop->prop_peerspi = values.prop_peerspi;
		prop->prop_localspi.spi_size = values.prop_localspi.spi_size;
		prop->prop_localspi.spi = 0;
d2267 60
a2326 1
	return (0);
d2443 3
d2512 1
a2512 1
	    sa->sa_dhiexchange->buf) == -1) {
d2516 1
a2516 1
		    ibuf_length(sa->sa_dhiexchange));
d2803 1
a2804 1
		peerid = &sa->sa_iid;
d2955 1
a2955 1
		csa->csa_peerspi = prop->prop_peerspi.spi;
d2961 7
d2972 2
d2975 1
a2975 6
		} else {
			/* Responder <- Initiator */
			csa->csa_dir = IPSP_DIRECTION_IN;
			csa->csa_spi.spi = prop->prop_peerspi.spi;
			csa->csa_local = &sa->sa_peer;
			csa->csa_peer = &sa->sa_local;
d2997 3
a3001 6
		if (spi == 0) {
			if ((ret = pfkey_sa_init(env->sc_pfkey,
			    csa, &spi)) != 0)
				goto done;
			csa->csa_spi.spi = prop->prop_localspi.spi = spi;
		}
@


1.11
log
@NAT detection again: make it work in initiator and responder mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.10 2010/06/14 12:05:32 reyk Exp $	*/
d839 1
a839 1
		rspi = 0;
d845 1
a845 1
		rspi = 0;
d1193 11
a1203 9
		if (ikev2_sa_negotiate(sa,
		    &sa->sa_policy->pol_proposals,
		    &msg->msg_proposals, IKEV2_SAPROTO_ESP) != 0) {
			log_debug("%s: no proposal chosen", __func__);
			msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
			sa_state(env, sa, IKEV2_STATE_DELETE);
			return;
		} else
			sa_stateflags(sa, IKED_REQ_SA);
@


1.10
log
@NAT detection with SPIr is always 0
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.9 2010/06/14 11:33:55 reyk Exp $	*/
d345 1
a345 1
	    initiator ? "initiator" : "responder",
d521 1
a521 1
		len = ikev2_nat_detection(&req, NULL, 0, 0, 0);
d525 1
a525 1
		    betoh16(n->n_type), 0)) == -1)
d537 1
a537 1
		len = ikev2_nat_detection(&req, NULL, 0, 0, 0);
d541 1
a541 1
		    betoh16(n->n_type), 0)) == -1)
d813 1
a813 1
    u_int type, int response)
d823 1
a823 1
	struct sockaddr_storage	*ss;
d825 2
d831 6
a836 2
	if (!response || sa == NULL) {
		if ((hdr = ibuf_seek(msg->msg_data, 0, sizeof(*hdr))) == NULL)
d840 3
d846 3
d856 2
a857 6
		if (response)
			ss = &msg->msg_local;
		else
			ss = &msg->msg_peer;

		log_debug("%s: source %s %s %s", __func__,
d860 2
a861 1
		    print_host(ss, NULL, 0));
d864 2
a865 6
		if (response)
			ss = &msg->msg_peer;
		else
			ss = &msg->msg_local;

		log_debug("%s: destination %s %s %s", __func__,
d868 2
a869 1
		    print_host(ss, NULL, 0));
d1246 2
d1299 1
a1299 1
		len = ikev2_nat_detection(msg, NULL, 0, 0, 1);
d1302 2
a1303 2
		if ((len = ikev2_nat_detection(msg, ptr, len,
		    betoh16(n->n_type), 1)) == -1)
d1315 1
a1315 1
		len = ikev2_nat_detection(msg, NULL, 0, 0, 1);
d1318 2
a1319 2
		if ((len = ikev2_nat_detection(msg, ptr, len,
		    betoh16(n->n_type), 1)) == -1)
d1324 1
a1324 1
	if (env->sc_certreqtype) {
@


1.9
log
@restructure code a bit to move closer to initiator mode:
- split responder/initiator- specific code into different functions and use
shared functions for common stuff.
- first parse the received message and store information in the temporary
message struct instead of modifying the ike sa in the parsing code directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.8 2010/06/14 08:55:59 reyk Exp $	*/
d833 1
a833 1
		rspi = hdr->ike_rspi;
d836 1
a836 1
		rspi = htobe64(sa->sa_hdr.sh_rspi);
@


1.8
log
@cleanup messages and parsed information correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.7 2010/06/14 08:10:32 reyk Exp $	*/
a57 1
void	 ikev2_cb(int, short, void *);
d60 2
d64 2
d71 5
a75 3
int	 ikev2_policy2id(struct iked_static_id *, struct iked_id *, int);
int	 ikev2_sa_initiator(struct iked_sa *);
int	 ikev2_sa_keys(struct iked_sa *);
d343 1
a343 1
	log_info("%s: %s from %s to %s policy '%s', %ld bytes", __func__,
d345 1
d349 1
a349 39
	    ibuf_size(msg->msg_data));

	switch (hdr->ike_exchange) {
	case IKEV2_EXCHANGE_IKE_SA_INIT:
		if (msg->msg_sa != NULL) {
			log_debug("%s: SA already exists", __func__);
			return;
		}
		if ((msg->msg_sa = sa_new(env,
		    betoh64(hdr->ike_ispi), betoh64(hdr->ike_rspi),
		    initiator, msg->msg_policy)) == NULL) {
			log_debug("%s: failed to get new SA", __func__);
			return;
		}
		break;
	case IKEV2_EXCHANGE_IKE_AUTH:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		if (sa_stateok(msg->msg_sa, IKEV2_STATE_VALID)) {
			log_debug("%s: already authenticated", __func__);
			return;
		}
		break;
	case IKEV2_EXCHANGE_CREATE_CHILD_SA:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		break;
	case IKEV2_EXCHANGE_INFORMATIONAL:
		if (ikev2_msg_valid_ike_sa(env, hdr, msg) == -1)
			return;
		break;
	default:
		log_debug("%s: unsupported exchange: %s", __func__,
		    print_map(hdr->ike_exchange, ikev2_exchange_map));
		return;
	}

	if (msg->msg_sa != NULL) {
		sa = msg->msg_sa;
d351 1
d374 33
a416 45
		sa = msg->msg_sa;

		if (sa == NULL) {
			log_debug("%s: invalid sa", __func__);
			return;
		}

		sa_state(env, sa, IKEV2_STATE_SA_INIT);

		if ((sa->sa_rnonce =
		    ibuf_random(IKED_NONCE_SIZE)) == NULL) {
			log_debug("%s: failed to get local nonce", __func__);
			sa_free(env, sa);
			return;
		}
		if ((ibuf_length(sa->sa_inonce) < IKED_NONCE_MIN) ||
		    (ibuf_length(sa->sa_rnonce) < IKED_NONCE_MIN)) {
			log_debug("%s: invalid nonce", __func__);
			sa_free(env, sa);
			return;
		}
		if (ikev2_sa_keys(sa) != 0) {
			log_debug("%s: failed to get IKE SA keys", __func__);
			sa_free(env, sa);
			return;
		}


		if (ikev2_policy2id(&msg->msg_policy->pol_localid,
		    &sa->sa_rid, 1) != 0) {
			log_debug("%s: failed to get responder id", __func__);
			return;
		}
		ibuf_release(sa->sa_1stmsg);
		if ((sa->sa_1stmsg = ibuf_new(ibuf_data(msg->msg_data),
		    ibuf_size(msg->msg_data))) == NULL) {
			log_debug("%s: failed to copy 1st message", __func__);
			return;
		}

		if (ikev2_resp_ike_sa_init(env, msg) != 0) {
			log_debug("%s: failed to send init response", __func__);
			return;
		}
		break;
a417 11
		sa = msg->msg_sa;

		if (!sa_stateok(sa, IKEV2_STATE_AUTH_REQUEST) &&
		    sa->sa_policy->pol_auth.auth_eap)
			sa_state(env, sa, IKEV2_STATE_EAP);

		if (ikev2_resp_ike_auth(env, sa) != 0) {
			log_debug("%s: failed to send auth response", __func__);
			return;
		}
		break;
d419 2
a420 1
		(void)ikev2_resp_create_child_sa(env, msg);
d426 2
a427 2
	if (msg->msg_sa && msg->msg_sa->sa_state == IKEV2_STATE_DELETE)
		sa_free(env, msg->msg_sa);
d455 1
a455 1
	if (ikev2_sa_initiator(sa) == -1)
d1116 98
d1230 5
d1858 6
d1986 2
a1987 1
ikev2_sa_initiator(struct iked_sa *sa)
a1990 1
	struct group		*group;
a2003 1
	group = sa->sa_dhgroup;
d2007 1
a2007 1
		    dh_getlen(group))) == NULL) {
d2011 2
a2012 1
		if (dh_create_exchange(group, sa->sa_dhiexchange->buf) == -1) {
d2019 1
a2019 2
		if ((sa->sa_inonce =
		    ibuf_random(IKED_NONCE_SIZE)) == NULL) {
d2025 32
d2061 2
a2062 1
ikev2_sa_keys(struct iked_sa *sa)
a2064 7
	struct iked_hash	*prf, *integr;
	struct iked_cipher	*encr;
	struct group		*group;
	struct ibuf		*ninr, *dhsecret, *skeyseed, *s, *t;
	size_t			 nonceminlen, ilen, rlen, tmplen;
	u_int64_t		 ispi, rspi;
	int			 ret = -1;
d2066 30
a2095 1
	ninr = dhsecret = skeyseed = s = t = NULL;
a2108 1
	encr = sa->sa_encr;
a2121 1
	prf = sa->sa_prf;
a2135 1
	integr = sa->sa_integr;
a2147 7
		if ((ssize_t)ibuf_length(sa->sa_dhiexchange) !=
		    dh_getlen(sa->sa_dhgroup)) {
			/* XXX send notification to peer */
			log_debug("%s: dh mismatch %d", __func__,
			    dh_getlen(sa->sa_dhgroup) * 8);
			return (-1);
		}
a2148 1
	group = sa->sa_dhgroup;
d2152 1
a2152 1
		    dh_getlen(group))) == NULL) {
d2156 2
a2157 1
		if (dh_create_exchange(group, sa->sa_dhrexchange->buf) == -1) {
d2161 35
@


1.7
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.6 2010/06/11 12:47:18 reyk Exp $	*/
d157 1
a157 1
		message_cleanup(env, &msg);
d618 1
a618 1
	message_cleanup(env, &req);
d1298 1
a1298 1
	message_cleanup(env, &resp);
d1769 1
a1769 1
	message_cleanup(env, &resp);
@


1.6
log
@add some infrastructure to support timers and initiator mode later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.5 2010/06/10 14:08:37 reyk Exp $	*/
d60 2
a61 1
void	 ikev2_initiator(struct iked *, struct iked_policy *);
d69 1
d116 1
a116 1
			timer_register_initiator(env, ikev2_initiator);
d410 1
a410 1
	if (msg->msg_response)
d424 6
d442 1
d483 2
a484 2
void
ikev2_initiator(struct iked *env, struct iked_policy *pol)
d486 135
a620 2
	/* XXX */
	log_debug("%s: not implemented", __func__);
d1581 1
a1581 1
	if (msg->msg_response)
d1924 44
@


1.5
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.4 2010/06/10 12:06:34 reyk Exp $	*/
d60 1
d109 7
a115 1
		return (config_getmode(env, imsg->hdr.type));
d472 7
@


1.4
log
@Add another tree to lookup policy SAs by peer address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.3 2010/06/10 08:29:47 reyk Exp $	*/
d103 6
@


1.3
log
@i don't like splitting source code in too many source files but ikev2.c
has grown too large, so split it in 3 files and rename a few functions
to organize the code a bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.2 2010/06/04 09:51:45 reyk Exp $	*/
d379 2
a380 3
		if (msg->msg_peerlen > sizeof(sa->sa_peer)) {
			log_debug("%s: invalid peer address",
			    __func__);
d382 1
a382 23
		}
		sa->sa_peer.addr_af = msg->msg_peer.ss_family;
		sa->sa_peer.addr.ss_len = msg->msg_peerlen;
		sa->sa_peer.addr_port =
		    htons(socket_getport(&msg->msg_peer));
		socket_af((struct sockaddr *)&sa->sa_peer.addr,
		    sa->sa_peer.addr_port);
		memcpy(&sa->sa_peer.addr, &msg->msg_peer,
		    sizeof(sa->sa_peer.addr));

		if (msg->msg_locallen > sizeof(sa->sa_local)) {
			log_debug("%s: invalid local address",
			    __func__);
			return;
		}
		sa->sa_local.addr_af = msg->msg_local.ss_family;
		sa->sa_local.addr.ss_len = msg->msg_locallen;
		sa->sa_local.addr_port =
		    htons(socket_getport(&msg->msg_local));
		socket_af((struct sockaddr *)&sa->sa_local.addr,
		    sa->sa_local.addr_port);
		memcpy(&sa->sa_local.addr, &msg->msg_local,
		    sizeof(sa->sa_local.addr));
@


1.2
log
@Fix NAT-T detection to enable UDP encapsulation.  It was done before,
but not in the right order to run the IKEv2 NAT detection and check the
source port of the last IKE message which should be the NAT-T port 4500.

Tested with iked running on sparc64 and a NAT'ed windows box.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
a59 24
void	 ikev2_message_cb(int, short, void *);
void	 ikev2_message_recv(struct iked *, struct iked_message *);
int	 ikev2_message_valid_ike_sa(struct iked *, struct ike_header *,
	    struct iked_message *);
int	 ikev2_message_send(struct iked *, int, struct iked_message *);
int	 ikev2_message_send_encrypt(struct iked *, struct iked_sa *,
	    struct ibuf **, u_int8_t, u_int8_t, int);
u_int32_t
	 ikev2_message_id(struct iked *, struct iked_sa *, int);
struct ibuf *
	 ikev2_message_init(struct iked *, struct iked_message *,
	    struct sockaddr_storage *, socklen_t,
	    struct sockaddr_storage *, socklen_t, int);
struct ibuf
	*ikev2_message_auth(struct iked *, struct iked_sa *, int);
int	 ikev2_message_authverify(struct iked *, struct iked_sa *,
	    struct iked_auth *, u_int8_t *, size_t, struct ibuf *);

struct ibuf
	*ikev2_message_encrypt(struct iked *, struct iked_sa *, struct ibuf *);
struct ibuf *
	 ikev2_message_decrypt(struct iked *, struct iked_sa *,
	    struct ibuf *, struct ibuf *);
int	 ikev2_message_integr(struct iked *, struct iked_sa *, struct ibuf *);
a64 36
int	 ikev2_send_informational(struct iked *, struct iked_message *);

int	 ikev2_parse_message(struct iked *, struct ike_header *,
	    struct iked_message *, off_t);
int	 ikev2_parse_payloads(struct iked *, struct iked_message *,
	    off_t, size_t, u_int, int);
int	 ikev2_parse_sa(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_xform(struct iked *, struct ikev2_sa_proposal *,
	    struct iked_message *, off_t);
int	 ikev2_parse_attr(struct iked *, struct ikev2_transform *,
	    struct iked_message *, off_t, int);
int	 ikev2_parse_ke(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_id(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t, u_int);
int	 ikev2_parse_cert(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_certreq(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_nonce(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_notify(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_delete(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_ts(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t, u_int);
int	 ikev2_parse_auth(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_e(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_cp(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
int	 ikev2_parse_eap(struct iked *, struct ikev2_payload *,
	    struct iked_message *, off_t);
a66 2
int	 ikev2_sa_negotiate(struct iked_sa *, struct iked_proposals *,
	    struct iked_proposals *, u_int8_t);
a71 2
int	 ikev2_childsa_delete(struct iked *, struct iked_sa *,
	    u_int8_t, u_int64_t, u_int64_t *, int);
a74 8
struct ike_header *
	 ikev2_add_header(struct ibuf *, struct iked_sa *,
	    u_int32_t, u_int8_t, u_int8_t, u_int8_t);
int	 ikev2_set_header(struct ike_header *, size_t);
struct ikev2_payload *
	 ikev2_add_payload(struct ibuf *);
int	 ikev2_next_payload(struct ikev2_payload *, size_t,
	    u_int8_t);
a75 2
ssize_t	 ikev2_nat_detection(struct iked_message *, void *, size_t,
	    u_int, int);
d104 1
a104 1
		return (config_getsocket(env, imsg, ikev2_message_cb));
d141 1
a141 1
		ikev2_message_recv(env, &msg);
d304 1
a304 61
ikev2_message_cb(int fd, short event, void *arg)
{
	struct iked_socket	*sock = arg;
	struct iked		*env = sock->sock_env;
	struct iked_message	 msg;
	struct ike_header	 hdr;
	u_int32_t		 natt = 0x00000000;
	u_int8_t		 buf[IKED_MSGBUF_MAX];
	ssize_t			 len;
	off_t			 off;
	struct iovec		 iov[2];

	bzero(&msg, sizeof(msg));
	bzero(buf, sizeof(buf));

	msg.msg_peerlen = sizeof(msg.msg_peer);
	msg.msg_locallen = sizeof(msg.msg_local);
	memcpy(&msg.msg_local, &sock->sock_addr, sizeof(sock->sock_addr));

	if ((len = recvfromto(fd, buf, sizeof(buf), 0,
	    (struct sockaddr*)&msg.msg_peer, &msg.msg_peerlen,
	    (struct sockaddr*)&msg.msg_local, &msg.msg_locallen)) <
	    (ssize_t)sizeof(natt))
		return;

	if (socket_getport(&msg.msg_local) == IKED_NATT_PORT) {
		if (bcmp(&natt, buf, sizeof(natt)) != 0)
			return;
		msg.msg_natt = 1;
		off = sizeof(natt);
	} else
		off = 0;

	if ((size_t)(len - off) <= sizeof(hdr))
		return;
	memcpy(&hdr, buf + off, sizeof(hdr));

	if ((msg.msg_data = ibuf_new(buf + off, len - off)) == NULL)
		return;

	if (hdr.ike_version == IKEV1_VERSION) {
		iov[0].iov_base = &msg;
		iov[0].iov_len = sizeof(msg);
		iov[1].iov_base = buf;
		iov[1].iov_len = len;

		imsg_composev_proc(env, PROC_IKEV1, IMSG_IKE_MESSAGE, -1,
		    iov, 2);
		goto done;
	}
	TAILQ_INIT(&msg.msg_proposals);

	msg.msg_fd = fd;
	ikev2_message_recv(env, &msg);

 done:
	message_cleanup(env, &msg);
}

void
ikev2_message_recv(struct iked *env, struct iked_message *msg)
d344 1
a344 1
		if (ikev2_message_valid_ike_sa(env, hdr, msg) == -1)
d352 1
a352 1
		if (ikev2_message_valid_ike_sa(env, hdr, msg) == -1)
d356 1
a356 1
		if (ikev2_message_valid_ike_sa(env, hdr, msg) == -1)
d413 1
a413 1
	if (ikev2_parse_message(env, hdr, msg, msg->msg_offset) != 0) {
a484 73
ikev2_message_valid_ike_sa(struct iked *env, struct ike_header *oldhdr,
    struct iked_message *msg)
{
#if 0
	/* XXX Disabled, see comment below */
	struct iked_message		 resp;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ikev2_notify		*n;
	struct ibuf			*buf;
	struct iked_sa			 sa;
#endif

	if (msg->msg_sa != NULL && msg->msg_policy != NULL)
		return (0);

#if 0
	/*
	 * XXX Sending INVALID_IKE_SPIs notifications is disabled
	 * XXX because it is not mandatory and ignored by most
	 * XXX implementations.  We might want to enable it in
	 * XXX combination with a rate-limitation to avoid DoS situations.
	 */

	/* Fail without error message */
	if (msg->msg_response || msg->msg_policy == NULL)
		return (-1);

	/* Invalid IKE SA, return notification */
	if ((buf = ikev2_message_init(env, &resp,
	    &msg->msg_peer, msg->msg_peerlen,
	    &msg->msg_local, msg->msg_locallen, 1)) == NULL)
		goto done;

	bzero(&sa, sizeof(sa));
	if ((oldhdr->ike_flags & IKEV2_FLAG_INITIATOR) == 0)
		sa.sa_hdr.sh_initiator = 1;
	sa.sa_hdr.sh_ispi = betoh64(oldhdr->ike_ispi);
	sa.sa_hdr.sh_rspi = betoh64(oldhdr->ike_rspi);

	/* IKE header */
	if ((hdr = ikev2_add_header(buf, &sa, betoh32(oldhdr->ike_msgid),
	    IKEV2_PAYLOAD_NOTIFY, IKEV2_EXCHANGE_INFORMATIONAL,
	    IKEV2_FLAG_RESPONSE)) == NULL)
		goto done;

	/* SA payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
		goto done;
	n->n_protoid = IKEV2_SAPROTO_IKE;
	n->n_spisize = 0;
	n->n_type = htobe16(IKEV2_N_INVALID_IKE_SPI);

	if (ikev2_next_payload(pld, sizeof(*n), IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
		goto done;

	(void)ikev2_parse_message(env, hdr, &resp, 0);
	(void)ikev2_message_send(env, msg->msg_fd, &resp);

 done:
	message_cleanup(env, &resp);
#endif

	/* Always fail */
	return (-1);
}

int
a1029 326
struct ibuf *
ikev2_message_init(struct iked *env, struct iked_message *msg,
    struct sockaddr_storage *peer, socklen_t peerlen,
    struct sockaddr_storage *local, socklen_t locallen, int response)
{
	bzero(msg, sizeof(*msg));
	memcpy(&msg->msg_peer, peer, peerlen);
	msg->msg_peerlen = peerlen;
	memcpy(&msg->msg_local, local, locallen);
	msg->msg_locallen = locallen;
	msg->msg_response = response ? 1 : 0;
	msg->msg_fd = -1;
	msg->msg_data = ibuf_static();

	return (msg->msg_data);
}

int
ikev2_message_send(struct iked *env, int fd, struct iked_message *msg)
{
	struct ibuf	*buf = msg->msg_data;
	u_int32_t	 natt = 0x00000000;
	struct ike_header	*hdr;

	if (buf == NULL || (hdr = ibuf_seek(msg->msg_data,
	    msg->msg_offset, sizeof(*hdr))) == NULL)
		return (-1);

	log_info("%s: %s to %s from %s", __func__,
	    print_map(hdr->ike_exchange, ikev2_exchange_map),
	    print_host(&msg->msg_peer, NULL, 0),
	    print_host(&msg->msg_local, NULL, 0));

	if (msg->msg_natt || (msg->msg_sa && msg->msg_sa->sa_natt)) {
		if (ibuf_prepend(buf, &natt, sizeof(natt)) == -1) {
			log_debug("%s: failed to set NAT-T", __func__);
			return (-1);
		}
	}
	if ((sendto(fd, ibuf_data(buf), ibuf_size(buf), 0,
	    (struct sockaddr *)&msg->msg_peer, msg->msg_peerlen)) == -1) {
		log_warn("%s: sendto", __func__);
		return (-1);
	}

	return (0);
}

u_int32_t
ikev2_message_id(struct iked *env, struct iked_sa *sa, int response)
{
	if (response)
		return (sa->sa_msgid);

	if (++sa->sa_msgid == UINT32_MAX) {
		/* XXX we should close and renegotiate the connection now */
		log_debug("%s: IKEv2 message sequence overflow", __func__);
	}

	return (sa->sa_msgid);
}

struct ibuf *
ikev2_message_encrypt(struct iked *env, struct iked_sa *sa, struct ibuf *src)
{
	size_t			 len, ivlen, encrlen, integrlen, blocklen,
				    outlen;
	u_int8_t		*buf, pad = 0, *ptr;
	struct ibuf		*integr, *encr, *dst = NULL, *out = NULL;

	buf = ibuf_data(src);
	len = ibuf_size(src);

	log_debug("%s: decrypted length %d", __func__, len);
	print_hex(buf, 0, len);

	if (sa == NULL ||
	    sa->sa_encr == NULL ||
	    sa->sa_integr == NULL) {
		log_debug("%s: invalid SA", __func__);
		goto done;
	}

	if (sa->sa_hdr.sh_initiator) {
		encr = sa->sa_key_iencr;
		integr = sa->sa_key_iauth;
	} else {
		encr = sa->sa_key_rencr;
		integr = sa->sa_key_rauth;
	}

	blocklen = cipher_length(sa->sa_encr);
	ivlen = cipher_ivlength(sa->sa_encr);
	integrlen = hash_length(sa->sa_integr);
	encrlen = roundup(len + sizeof(pad), blocklen);
	pad = encrlen - (len + sizeof(pad));

	/*
	 * Pad the payload and encrypt it
	 */
	if (pad) {
		if ((ptr = ibuf_advance(src, pad)) == NULL)
			goto done;
		arc4random_buf(ptr, pad);
	}
	if (ibuf_add(src, &pad, sizeof(pad)) != 0)
		goto done;

	log_debug("%s: padded length %d", __func__, ibuf_size(src));
	print_hex(ibuf_data(src), 0, ibuf_size(src));

	cipher_setkey(sa->sa_encr, encr->buf, ibuf_length(encr));
	cipher_setiv(sa->sa_encr, NULL, 0);	/* new IV */
	cipher_init_encrypt(sa->sa_encr);

	if ((dst = ibuf_dup(sa->sa_encr->encr_iv)) == NULL)
		goto done;

	if ((out = ibuf_new(NULL,
	    cipher_outlength(sa->sa_encr, encrlen))) == NULL)
		goto done;

	outlen = ibuf_size(out);
	cipher_update(sa->sa_encr,
	    ibuf_data(src), encrlen, ibuf_data(out), &outlen);

	if (outlen && ibuf_add(dst, ibuf_data(out), outlen) != 0)
		goto done;

	outlen = cipher_outlength(sa->sa_encr, 0);
	cipher_final(sa->sa_encr, out->buf, &outlen);
	if (outlen)
		ibuf_add(dst, out->buf, outlen);

	if ((ptr = ibuf_advance(dst, integrlen)) == NULL)
		goto done;
	bzero(ptr, integrlen);

	log_debug("%s: length %d, padding %d, output length %d",
	    __func__, len + sizeof(pad), pad, ibuf_size(dst));
	print_hex(ibuf_data(dst), 0, ibuf_size(dst));

	ibuf_release(src);
	ibuf_release(out);
	return (dst);
 done:
	ibuf_release(src);
	ibuf_release(out);
	ibuf_release(dst);
	return (NULL);
}

int
ikev2_message_integr(struct iked *env, struct iked_sa *sa, struct ibuf *src)
{
	int			 ret = -1;
	size_t			 integrlen, tmplen;
	struct ibuf		*integr, *prf, *tmp = NULL;
	u_int8_t		*ptr;

	log_debug("%s: message length %d", __func__, ibuf_size(src));
	print_hex(ibuf_data(src), 0, ibuf_size(src));

	if (sa == NULL ||
	    sa->sa_integr == NULL) {
		log_debug("%s: invalid SA", __func__);
		return (-1);
	}

	if (sa->sa_hdr.sh_initiator) {
		integr = sa->sa_key_iauth;
		prf = sa->sa_key_iprf;
	} else {
		integr = sa->sa_key_rauth;
		prf = sa->sa_key_rprf;
	}

	integrlen = hash_length(sa->sa_integr);

	log_debug("%s: integrity checksum length %d", __func__,
	    integrlen);

	/*
	 * Validate packet checksum
	 */
	if ((tmp = ibuf_new(NULL, hash_keylength(sa->sa_integr))) == NULL)
		goto done;

	hash_setkey(sa->sa_integr, ibuf_data(integr), ibuf_size(integr));
	hash_init(sa->sa_integr);
	hash_update(sa->sa_integr, ibuf_data(src),
	    ibuf_size(src) - integrlen);
	hash_final(sa->sa_integr, ibuf_data(tmp), &tmplen);

	if (tmplen != integrlen) {
		log_debug("%s: hash failure", __func__);
		goto done;
	}

	if ((ptr = ibuf_seek(src,
	    ibuf_size(src) - integrlen, integrlen)) == NULL)
		goto done;
	memcpy(ptr, ibuf_data(tmp), tmplen);

	print_hex(ibuf_data(tmp), 0, ibuf_size(tmp));

	ret = 0;
 done:
	ibuf_release(tmp);

	return (ret);
}

struct ibuf *
ikev2_message_decrypt(struct iked *env, struct iked_sa *sa,
    struct ibuf *msg, struct ibuf *src)
{
	size_t			 ivlen, encrlen, integrlen, blocklen,
				    outlen, tmplen;
	u_int8_t		 pad, *ptr;
	struct ibuf		*integr, *encr, *tmp = NULL, *out = NULL;
	off_t			 ivoff, encroff, integroff;

	if (sa == NULL ||
	    sa->sa_encr == NULL ||
	    sa->sa_integr == NULL) {
		log_debug("%s: invalid SA", __func__);
		print_hex(ibuf_data(src), 0, ibuf_size(src));
		goto done;
	}

	if (!sa->sa_hdr.sh_initiator) {
		encr = sa->sa_key_iencr;
		integr = sa->sa_key_iauth;
	} else {
		encr = sa->sa_key_rencr;
		integr = sa->sa_key_rauth;
	}

	blocklen = cipher_length(sa->sa_encr);
	ivlen = cipher_ivlength(sa->sa_encr);
	ivoff = 0;
	integrlen = hash_length(sa->sa_integr);
	integroff = ibuf_size(src) - integrlen;
	encroff = ivlen;
	encrlen = ibuf_size(src) - integrlen - ivlen;

	log_debug("%s: IV length %d", __func__, ivlen);
	print_hex(ibuf_data(src), 0, ivlen);
	log_debug("%s: encrypted payload length %d", __func__, encrlen);
	print_hex(ibuf_data(src), encroff, encrlen);
	log_debug("%s: integrity checksum length %d", __func__, integrlen);
	print_hex(ibuf_data(src), integroff, integrlen);

	/*
	 * Validate packet checksum
	 */
	if ((tmp = ibuf_new(NULL, ibuf_length(integr))) == NULL)
		goto done;

	hash_setkey(sa->sa_integr, integr->buf, ibuf_length(integr));
	hash_init(sa->sa_integr);
	hash_update(sa->sa_integr, ibuf_data(msg),
	    ibuf_size(msg) - integrlen);
	hash_final(sa->sa_integr, tmp->buf, &tmplen);

	if (memcmp(tmp->buf, ibuf_data(src) + integroff, integrlen) != 0) {
		log_debug("%s: integrity check failed", __func__);
		goto done;
	}

	log_debug("%s: integrity check succeeded", __func__, tmplen);
	print_hex(tmp->buf, 0, tmplen);

	ibuf_release(tmp);
	tmp = NULL;

	/*
	 * Decrypt the payload and strip any padding
	 */
	if ((encrlen % blocklen) != 0) {
		log_debug("%s: unaligned encrypted payload", __func__);
		goto done;
	}

	cipher_setkey(sa->sa_encr, encr->buf, ibuf_length(encr));
	cipher_setiv(sa->sa_encr, ibuf_data(src) + ivoff, ivlen);
	cipher_init_decrypt(sa->sa_encr);

	if ((out = ibuf_new(NULL, cipher_outlength(sa->sa_encr,
	    encrlen))) == NULL)
		goto done;

	outlen = ibuf_length(out);
	/* XXX why does it need encrlen + blocklen to work correctly? */
	cipher_update(sa->sa_encr,
	    ibuf_data(src) + encroff, encrlen + blocklen,
	    ibuf_data(out), &outlen);
	cipher_final(sa->sa_encr, ibuf_seek(out, outlen, blocklen), &tmplen);
	if (tmplen)
		outlen += tmplen;

	/*
	 * XXX 
	 * XXX the padding is wrong
	 * XXX
	 */
	ptr = ibuf_seek(out, outlen - 1, 1);
	pad = *ptr;

	log_debug("%s: decrypted payload length %d/%d padding %d",
	    __func__, outlen, encrlen, pad);
	print_hex(ibuf_data(out), 0, ibuf_size(out));

	if (ibuf_setsize(out, outlen) != 0)
		goto done;

	ibuf_release(src);
	return (out);
 done:
	ibuf_release(tmp);
	ibuf_release(out);
	ibuf_release(src);
	return (NULL);
}

d1046 1
a1046 1
	if ((buf = ikev2_message_init(env, &resp,
d1148 1
a1148 1
	(void)ikev2_parse_message(env, hdr, &resp, 0);
d1156 1
a1156 1
	ret = ikev2_message_send(env, msg->msg_fd, &resp);
d1305 1
a1305 1
	ret = ikev2_message_send_encrypt(env, sa, &e,
d1393 1
a1393 1
	ret = ikev2_message_send_encrypt(env, sa, &e,
d1422 1
a1422 1
	ret = ikev2_message_send_encrypt(env, sa, &e,
d1509 1
a1509 1
	ret = ikev2_message_send_encrypt(env, sa, &e,
d1533 1
a1533 1
	if ((buf = ikev2_message_init(env, &resp,
d1568 1
a1568 1
		    ikev2_message_id(env, sa, 0),
d1577 1
a1577 1
		if ((e = ikev2_message_encrypt(env, sa, e)) == NULL) {
d1591 1
a1591 1
		if (ikev2_message_integr(env, sa, buf) != 0) {
d1608 1
a1608 1
		    ikev2_message_id(env, &sah, 0),
d1623 1
a1623 1
	(void)ikev2_parse_message(env, hdr, &resp, 0);
d1626 1
a1626 1
	ret = ikev2_message_send(env, msg->msg_fd, &resp);
d1635 3
a1637 3
int
ikev2_message_send_encrypt(struct iked *env, struct iked_sa *sa,
    struct ibuf **ep, u_int8_t exchange, u_int8_t firstpayload, int response)
d1639 2
a1640 5
	struct iked_message		 resp;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ibuf			*buf, *e = *ep;
	int				 ret = -1;
d1642 2
a1643 4
	if ((buf = ikev2_message_init(env, &resp,
	    &sa->sa_peer.addr, sa->sa_peer.addr.ss_len,
	    &sa->sa_local.addr, sa->sa_local.addr.ss_len, 1)) == NULL)
		goto done;
d1645 2
a1646 87
	/* IKE header */
	if ((hdr = ikev2_add_header(buf, sa,
	    ikev2_message_id(env, sa, response),
	    IKEV2_PAYLOAD_E, exchange,
	    response ? IKEV2_FLAG_RESPONSE : 0)) == NULL)
		goto done;

	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;

	/* Encrypt message and add as an E payload */
	if ((e = ikev2_message_encrypt(env, sa, e)) == NULL) {
		log_debug("%s: encryption failed", __func__);
		goto done;
	}
	if (ibuf_cat(buf, e) != 0)
		goto done;
	if (ikev2_next_payload(pld, ibuf_size(e), firstpayload) == -1)
		goto done;

	if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
		goto done;

	/* Add integrity checksum (HMAC) */
	if (ikev2_message_integr(env, sa, buf) != 0) {
		log_debug("%s: integrity checksum failed", __func__);
		goto done;
	}

	resp.msg_data = buf;
	resp.msg_sa = sa;
	TAILQ_INIT(&resp.msg_proposals);

	sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
	(void)ikev2_parse_message(env, hdr, &resp, 0);
	sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;

	ret = ikev2_message_send(env, sa->sa_fd, &resp);

 done:
	/* e is cleaned up by the calling function */
	*ep = e;
	message_cleanup(env, &resp);

	return (ret);
}

struct ibuf *
ikev2_message_auth(struct iked *env, struct iked_sa *sa, int response)
{
	struct ibuf		*authmsg = NULL, *nonce, *prfkey, *buf;
	u_int8_t		*ptr;
	struct iked_id		*id;
	size_t			 tmplen;

	/*
	 * Create the payload to be signed/MAC'ed for AUTH
	 */

	if (!response) {
		if ((nonce = sa->sa_rnonce) == NULL ||
		    (sa->sa_iid.id_type == 0) ||
		    (prfkey = sa->sa_key_iprf) == NULL ||
		    (buf = sa->sa_1stmsg) == NULL)
			return (NULL);
		id = &sa->sa_iid;
	} else {
		if ((nonce = sa->sa_inonce) == NULL ||
		    (sa->sa_rid.id_type == 0) ||
		    (prfkey = sa->sa_key_rprf) == NULL ||
		    (buf = sa->sa_2ndmsg) == NULL)
			return (NULL);
		id = &sa->sa_rid;
	}

	if ((authmsg = ibuf_dup(buf)) == NULL)
		return (NULL);
	if (ibuf_cat(authmsg, nonce) != 0)
		goto fail;

	if ((hash_setkey(sa->sa_prf, ibuf_data(prfkey),
	    ibuf_size(prfkey))) == NULL)
		goto fail;

	if ((ptr = ibuf_advance(authmsg,
	    hash_length(sa->sa_prf))) == NULL)
		goto fail;
d1649 2
a1650 2
	hash_update(sa->sa_prf, ibuf_data(id->id_buf), ibuf_size(id->id_buf));
	hash_final(sa->sa_prf, ptr, &tmplen);
d1652 2
a1653 1227
	if (tmplen != hash_length(sa->sa_prf))
		goto fail;

	log_debug("%s: %s auth data length %d",
	    __func__, response ? "responder" : "initiator",
	    ibuf_size(authmsg));
	print_hex(ibuf_data(authmsg), 0, ibuf_size(authmsg));

	return (authmsg);

 fail:
	ibuf_release(authmsg);
	return (NULL);
}

int
ikev2_parse_message(struct iked *env, struct ike_header *hdr,
    struct iked_message *msg, off_t offset)
{
	log_debug("%s: header ispi %s rspi %s"
	    " nextpayload %s version 0x%02x exchange %s flags 0x%02x"
	    " msgid %d length %d response %d", __func__,
	    print_spi(betoh64(hdr->ike_ispi), 8),
	    print_spi(betoh64(hdr->ike_rspi), 8),
	    print_map(hdr->ike_nextpayload, ikev2_payload_map),
	    hdr->ike_version,
	    print_map(hdr->ike_exchange, ikev2_exchange_map),
	    hdr->ike_flags,
	    betoh32(hdr->ike_msgid),
	    betoh32(hdr->ike_length),
	    msg->msg_response);

	if (ibuf_size(msg->msg_data) < betoh32(hdr->ike_length)) {
		log_debug("%s: short message", __func__);
		return (-1);
	}

	offset += sizeof(*hdr);

	return (ikev2_parse_payloads(env, msg, offset,
	    betoh32(hdr->ike_length), hdr->ike_nextpayload, 0));
}

int
ikev2_parse_payloads(struct iked *env, struct iked_message *msg,
    off_t offset, size_t length, u_int payload, int quick)
{
	struct ikev2_payload	 pld;
	u_int			 e;
	int			 ret;
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);

	/* Check if message was decrypted in an E payload */
	e = msg->msg_decrypted ? IKED_E : 0;

	if (quick)
		print_debug("%s: %spayloads", __func__,
		    e ? "decrypted " : "");
	else
		ikev2_parse_payloads(env, msg, offset, length, payload, 1);

	while (payload != 0 && offset < (off_t)length) {
		memcpy(&pld, msgbuf + offset, sizeof(pld));

		if (quick)
			print_debug(" %s",
			    print_map(payload, ikev2_payload_map));
		else
			log_debug("%s: %spayload %s"
			    " nextpayload %s critical 0x%02x length %d",
			    __func__, e ? "decrypted " : "",
			    print_map(payload, ikev2_payload_map),
			    print_map(pld.pld_nextpayload, ikev2_payload_map),
			    pld.pld_reserved & IKEV2_CRITICAL_PAYLOAD,
			    betoh16(pld.pld_length));

		offset += sizeof(pld);
		ret = 0;

		if (quick)
			goto next;

		switch (payload | e) {
		case IKEV2_PAYLOAD_SA:
		case IKEV2_PAYLOAD_SA | IKED_E:
			ret = ikev2_parse_sa(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_KE:
			ret = ikev2_parse_ke(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_IDi | IKED_E:
		case IKEV2_PAYLOAD_IDr | IKED_E:
			ret = ikev2_parse_id(env, &pld, msg, offset, payload);
			break;
		case IKEV2_PAYLOAD_CERT | IKED_E:
			ret = ikev2_parse_cert(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_CERTREQ:
		case IKEV2_PAYLOAD_CERTREQ | IKED_E:
			ret = ikev2_parse_certreq(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_AUTH | IKED_E:
			ret = ikev2_parse_auth(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_NONCE:
		case IKEV2_PAYLOAD_NONCE | IKED_E:
			ret = ikev2_parse_nonce(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_NOTIFY:
		case IKEV2_PAYLOAD_NOTIFY | IKED_E:
			ret = ikev2_parse_notify(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_DELETE | IKED_E:
			ret = ikev2_parse_delete(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_TSi | IKED_E:
		case IKEV2_PAYLOAD_TSr | IKED_E:
			ret = ikev2_parse_ts(env, &pld, msg, offset, payload);
			break;
		case IKEV2_PAYLOAD_E:
			ret = ikev2_parse_e(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_CP | IKED_E:
			ret = ikev2_parse_cp(env, &pld, msg, offset);
			break;
		case IKEV2_PAYLOAD_EAP | IKED_E:
			ret = ikev2_parse_eap(env, &pld, msg, offset);
			break;
		default:
			print_hex(msgbuf, offset,
			    betoh16(pld.pld_length) - sizeof(pld));
			break;
		}

		if (ret != 0 && !msg->msg_response) {
			(void)ikev2_send_informational(env, msg);
			return (-1);
		}

		/* Encrypted payload must appear last */
		if (payload == IKEV2_PAYLOAD_E)
			return (0);

 next:
		payload = pld.pld_nextpayload;
		offset += betoh16(pld.pld_length) - sizeof(pld);
	}

	if (quick)
		print_debug("\n");

	return (0);
}

int
ikev2_parse_sa(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_sa_proposal	 sap;
	struct iked_proposal		*prop = NULL;
	u_int32_t			 spi32;
	u_int64_t			 spi = 0, spi64;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
	struct iked_sa			*sa = msg->msg_sa;

	memcpy(&sap, msgbuf + offset, sizeof(sap));
	offset += sizeof(sap);

	if (sap.sap_spisize) {
		switch (sap.sap_spisize) {
		case 4:
			memcpy(&spi32, msgbuf + offset, 4);
			spi = betoh32(spi32);
			break;
		case 8:
			memcpy(&spi64, msgbuf + offset, 8);
			spi = betoh64(spi64);
			break;
		default:
			log_debug("%s: unsupported SPI size %d",
			    __func__, sap.sap_spisize);
			return (-1);
		}

		offset += sap.sap_spisize;
	}

	log_debug("%s: more %d reserved %d length %d"
	    " proposal #%d protoid %s spisize %d xforms %d spi %s",
	    __func__, sap.sap_more, sap.sap_reserved,
	    betoh16(sap.sap_length), sap.sap_proposalnr,
	    print_map(sap.sap_protoid, ikev2_saproto_map), sap.sap_spisize,
	    sap.sap_transforms, print_spi(spi, sap.sap_spisize));

	if (!msg->msg_response) {
		if ((msg->msg_prop = config_add_proposal(&msg->msg_proposals,
		    sap.sap_proposalnr, sap.sap_protoid)) == NULL) {
			log_debug("%s: invalid proposal", __func__);
			return (-1);
		}
		prop = msg->msg_prop;
		prop->prop_localspi.spi_size = sap.sap_spisize;
		prop->prop_peerspi.spi = spi;
	}

	/*
	 * Parse the attached transforms
	 */
	if (ikev2_parse_xform(env, &sap, msg, offset) != 0) {
		log_debug("%s: invalid proposal transforms", __func__);
		return (-1);
	}

	if (msg->msg_response)
		return (0);

	/* XXX we need a better way to get this */
	if (ikev2_sa_negotiate(sa,
	    &msg->msg_policy->pol_proposals,
	    &msg->msg_proposals, msg->msg_decrypted ?
	    IKEV2_SAPROTO_ESP : IKEV2_SAPROTO_IKE) != 0) {
		log_debug("%s: no proposal chosen", __func__);
		msg->msg_error = IKEV2_N_NO_PROPOSAL_CHOSEN;
		return (-1);
	} else if (sa_stateok(sa, IKEV2_STATE_SA_INIT))
		sa_stateflags(sa, IKED_REQ_SA);

	return (0);
}

int
ikev2_parse_xform(struct iked *env, struct ikev2_sa_proposal *sap,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_transform		 xfrm;
	char				 id[BUFSIZ];
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&xfrm, msgbuf + offset, sizeof(xfrm));

	switch (xfrm.xfrm_type) {
	case IKEV2_XFORMTYPE_ENCR:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformencr_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_PRF:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformprf_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_INTEGR:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformauth_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_DH:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformdh_map), sizeof(id));
		break;
	case IKEV2_XFORMTYPE_ESN:
		strlcpy(id, print_map(betoh16(xfrm.xfrm_id),
		    ikev2_xformesn_map), sizeof(id));
		break;
	default:
		snprintf(id, sizeof(id), "<%d>", betoh16(xfrm.xfrm_id));
		break;
	}

	log_debug("%s: more %d reserved %d length %d"
	    " type %s id %s",
	    __func__, xfrm.xfrm_more, xfrm.xfrm_reserved,
	    betoh16(xfrm.xfrm_length),
	    print_map(xfrm.xfrm_type, ikev2_xformtype_map), id);

	/*
	 * Parse transform attributes, if available
	 */
	msg->msg_attrlength = 0;
	if ((u_int)betoh16(xfrm.xfrm_length) > sizeof(xfrm))
		ikev2_parse_attr(env, &xfrm, msg, offset + sizeof(xfrm),
		    betoh16(xfrm.xfrm_length) - sizeof(xfrm));

	if (!msg->msg_response) {
		if (config_add_transform(msg->msg_prop, xfrm.xfrm_type,
		    betoh16(xfrm.xfrm_id), msg->msg_attrlength,
		    msg->msg_attrlength) == NULL) {
			log_debug("%s: failed to add transform", __func__);
			return (-1);
		}
	}

	/* Next transform */
	offset += betoh16(xfrm.xfrm_length);
	if (xfrm.xfrm_more == IKEV2_XFORM_MORE)
		ikev2_parse_xform(env, sap, msg, offset);

	return (0);
}

int
ikev2_parse_attr(struct iked *env, struct ikev2_transform *xfrm,
    struct iked_message *msg, off_t offset, int total)
{
	struct ikev2_attribute		 attr;
	u_int				 type;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&attr, msgbuf + offset, sizeof(attr));

	type = betoh16(attr.attr_type) & ~IKEV2_ATTRAF_TV;

	log_debug("%s: attribute type %s length %d total %d",
	    __func__, print_map(type, ikev2_attrtype_map),
	    betoh16(attr.attr_length), total);

	if (betoh16(attr.attr_type) & IKEV2_ATTRAF_TV) {
		/* Type-Value attribute */
		offset += sizeof(attr);
		total -= sizeof(attr);

		if (type == IKEV2_ATTRTYPE_KEY_LENGTH)
			msg->msg_attrlength = betoh16(attr.attr_length);
	} else {
		/* Type-Length-Value attribute */
		print_hex(msgbuf, offset + sizeof(attr),
		    betoh16(attr.attr_length) - sizeof(attr));
		offset += betoh16(attr.attr_length);
		total -= betoh16(attr.attr_length);
	}

	if (total > 0) {
		/* Next attribute */
		ikev2_parse_attr(env, xfrm, msg, offset, total);
	}

	return (0);
}

int
ikev2_parse_ke(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_keyexchange	 kex;
	u_int8_t			*buf;
	size_t				 len;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&kex, msgbuf + offset, sizeof(kex));

	log_debug("%s: dh group %s reserved %d",
	    __func__,
	    print_map(betoh16(kex.kex_dhgroup), ikev2_xformdh_map),
	    betoh16(kex.kex_reserved));

	buf = msgbuf + offset + sizeof(kex);
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(kex);

	print_hex(buf, 0, len);

	if (!msg->msg_response) {
		if ((msg->msg_sa->sa_dhiexchange =
		    ibuf_new(buf, len)) == NULL) {
			log_debug("%s: failed to get exchange", __func__);
			return (-1);
		}
	}

	return (0);
}

int
ikev2_parse_id(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset, u_int payload)
{
	u_int8_t			*ptr;
	struct ikev2_id			 id;
	size_t				 len;
	struct iked_id			*idp, idb;
	struct iked_sa			*sa = msg->msg_sa;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);
	struct ibuf			*authmsg;
	char				 idstr[IKED_ID_SIZE];

	memcpy(&id, msgbuf + offset, sizeof(id));
	bzero(&idb, sizeof(idb));

	/* Don't strip the Id payload header */
	ptr = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld);

	idb.id_type = id.id_type;
	if ((idb.id_buf = ibuf_new(ptr, len)) == NULL)
		return (-1);

	if (print_id(&idb, sizeof(id), idstr, sizeof(idstr)) == -1) {
		log_debug("%s: malformed id", __func__);
		return (-1);
	}

	log_debug("%s: id %s/%s length %d",
	    __func__, print_map(id.id_type, ikev2_id_map), idstr, len);

	if (msg->msg_response) {
		ibuf_release(idb.id_buf);
		return (0);
	}

	if (sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDr) {
		idp = &sa->sa_rid;
	} else if (!sa->sa_hdr.sh_initiator && payload == IKEV2_PAYLOAD_IDi) {
		idp = &sa->sa_iid;
	} else {
		log_debug("%s: unexpected id payload", __func__);
		return (0);
	}

	ibuf_release(idp->id_buf);
	idp->id_buf = idb.id_buf;
	idp->id_type = idb.id_type;

	if ((authmsg = ikev2_message_auth(env, sa,
	    !sa->sa_hdr.sh_initiator)) == NULL) {
		log_debug("%s: failed to get response auth data", __func__);
		return (-1);
	}

	ca_setauth(env, sa, authmsg, PROC_CERT);

	return (0);
}

int
ikev2_parse_cert(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_cert		 cert;
	u_int8_t			*buf;
	size_t				 len;
	struct iked_sa			*sa = msg->msg_sa;
	struct iked_id			*certid, *id;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&cert, msgbuf + offset, sizeof(cert));
	offset += sizeof(cert);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(cert);

	log_debug("%s: type %s length %d",
	    __func__, print_map(cert.cert_type, ikev2_cert_map), len);

	print_hex(buf, 0, len);

	if (msg->msg_response)
		return (0);

	if (!sa->sa_hdr.sh_initiator && !msg->msg_response) {
		certid = &sa->sa_icert;
		id = &sa->sa_iid;
	} else if (sa->sa_hdr.sh_initiator && msg->msg_response) {
		certid = &sa->sa_rcert;
		id = &sa->sa_rid;
	} else
		return (0);	/* ignore */

	if ((certid->id_buf = ibuf_new(buf, len)) == NULL) {
		log_debug("%s: failed to save cert", __func__);
		return (-1);
	}
	certid->id_type = cert.cert_type;

	ca_setcert(env, &msg->msg_sa->sa_hdr, id, cert.cert_type,
	    buf, len, PROC_CERT);

	return (0);
}

int
ikev2_parse_certreq(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_cert		 cert;
	u_int8_t			*buf;
	size_t				 len;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&cert, msgbuf + offset, sizeof(cert));
	offset += sizeof(cert);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(cert);

	log_debug("%s: type %s signatures length %d",
	    __func__, print_map(cert.cert_type, ikev2_cert_map), len);
	print_hex(buf, 0, len);

	if (msg->msg_response)
		return (0);

	if (!len || (len % SHA_DIGEST_LENGTH) != 0) {
		log_debug("%s: invalid certificate request", __func__);
		return (-1);
	}

	if (msg->msg_sa == NULL)
		return (-1);

	/* Optional certreq for PSK */
	msg->msg_sa->sa_staterequire |= IKED_REQ_CERT;

	ca_setreq(env, &msg->msg_sa->sa_hdr, cert.cert_type,
	    buf, len, PROC_CERT);

	return (0);
}

int
ikev2_parse_auth(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_auth		 auth;
	struct iked_auth		 ikeauth;
	u_int8_t			*buf;
	size_t				 len;
	struct ibuf			*authmsg;
	struct iked_sa			*sa = msg->msg_sa;
	struct iked_policy		*policy = sa->sa_policy;
	int				 ret = -1;
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&auth, msgbuf + offset, sizeof(auth));
	offset += sizeof(auth);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(auth);

	log_debug("%s: method %s length %d",
	    __func__, print_map(auth.auth_method, ikev2_auth_map), len);

	print_hex(buf, 0, len);

	if (msg->msg_response)
		return (0);

	memcpy(&ikeauth, &policy->pol_auth, sizeof(ikeauth));

	if (policy->pol_auth.auth_eap && sa->sa_eapmsk != NULL) {
		/* The initiator EAP auth is a PSK derived from the MSK */
		ikeauth.auth_method = IKEV2_AUTH_SHARED_KEY_MIC;

		/* Copy session key as PSK */
		memcpy(ikeauth.auth_data, ibuf_data(sa->sa_eapmsk),
		    ibuf_size(sa->sa_eapmsk));
		ikeauth.auth_length = ibuf_size(sa->sa_eapmsk);
	}
	if (auth.auth_method != ikeauth.auth_method) {
		log_debug("%s: method %s required", __func__,
		    print_map(ikeauth.auth_method, ikev2_auth_map));
		return (-1);
	}

	/* The AUTH payload indicates if the responder wants EAP or not */
	if (!sa_stateok(sa, IKEV2_STATE_EAP))
		sa_state(env, sa, IKEV2_STATE_AUTH_REQUEST);

	if ((authmsg = ikev2_message_auth(env, sa,
	    sa->sa_hdr.sh_initiator)) == NULL) {
		log_debug("%s: failed to get auth data", __func__);
		return (-1);
	}

	ret = ikev2_message_authverify(env, sa, &ikeauth, buf, len,
	    authmsg);

	ibuf_release(authmsg);
	authmsg = NULL;

	if (ret != 0)
		goto done;

	if (sa->sa_eapmsk != NULL) {
		if ((authmsg = ikev2_message_auth(env, sa,
		    !sa->sa_hdr.sh_initiator)) == NULL) {
			log_debug("%s: failed to get auth data", __func__);
			return (-1);
		}

		/* 2nd AUTH for EAP messages */
		if ((ret = ikev2_message_authsign(env, sa,
		    &ikeauth, authmsg)) != 0)
			goto done;

		sa_state(env, sa, IKEV2_STATE_EAP_VALID);
	}

 done:
	ibuf_release(authmsg);

	return (ret);
}

ssize_t
ikev2_psk(struct iked_sa *sa, u_int8_t *data, size_t length,
    u_int8_t **pskptr)
{
	u_int8_t	*psk;
	size_t		 psklen = -1;

	if (hash_setkey(sa->sa_prf, data, length) == NULL)
		return (-1);

	if ((psk = calloc(1, hash_keylength(sa->sa_prf))) == NULL)
		return (-1);

	hash_init(sa->sa_prf);
	hash_update(sa->sa_prf, IKEV2_KEYPAD, strlen(IKEV2_KEYPAD));
	hash_final(sa->sa_prf, psk, &psklen);

	*pskptr = psk;
	return (psklen);
}

int
ikev2_message_authverify(struct iked *env, struct iked_sa *sa,
    struct iked_auth *auth, u_int8_t *buf, size_t len, struct ibuf *authmsg)
{
	u_int8_t			*key, *psk = NULL;
	ssize_t				 keylen;
	struct iked_id			*id;
	struct iked_dsa			*dsa = NULL;
	int				 ret = -1;
	u_int8_t			 keytype;

	if (sa->sa_hdr.sh_initiator)
		id = &sa->sa_rcert;
	else
		id = &sa->sa_icert;

	if ((dsa = dsa_verify_new(auth->auth_method, sa->sa_prf)) == NULL) {
		log_debug("%s: invalid auth method", __func__);
		return (-1);
	}

	switch (auth->auth_method) {
	case IKEV2_AUTH_SHARED_KEY_MIC:
		if (!auth->auth_length) {
			log_debug("%s: no pre-shared key found", __func__);
			goto done;
		}
		if ((keylen = ikev2_psk(sa, auth->auth_data,
		    auth->auth_length, &psk)) == -1) {
			log_debug("%s: failed to get PSK", __func__);
			goto done;
		}
		key = psk;
		keytype = 0;
		break;
	default:
		if (id == NULL) {
			log_debug("%s: no cert found", __func__);
			goto done;
		}
		key = ibuf_data(id->id_buf);
		keylen = ibuf_size(id->id_buf);
		keytype = id->id_type;
		break;
	}

	log_debug("%s: method %s keylen %d type %s", __func__,
	    print_map(auth->auth_method, ikev2_auth_map), keylen,
	    print_map(id->id_type, ikev2_cert_map));

	if (dsa_setkey(dsa, key, keylen, keytype) == NULL ||
	    dsa_init(dsa) != 0 ||
	    dsa_update(dsa, ibuf_data(authmsg), ibuf_size(authmsg))) {
		log_debug("%s: failed to compute digital signature", __func__);
		goto done;
	}

	if ((ret = dsa_verify_final(dsa, buf, len)) == 0) {
		log_debug("%s: authentication successful", __func__);
		sa_state(env, sa, IKEV2_STATE_AUTH_SUCCESS);

		if (!sa->sa_policy->pol_auth.auth_eap &&
		    auth->auth_method == IKEV2_AUTH_SHARED_KEY_MIC)
			sa_state(env, sa, IKEV2_STATE_VALID);
	} else {
		log_debug("%s: authentication failed", __func__);
		sa_state(env, sa, IKEV2_STATE_AUTH_REQUEST);
	}

 done:
	if (psk != NULL)
		free(psk);
	dsa_free(dsa);

	return (ret);
}

int
ikev2_message_authsign(struct iked *env, struct iked_sa *sa,
    struct iked_auth *auth, struct ibuf *authmsg)
{
	u_int8_t			*key, *psk = NULL;
	ssize_t				 keylen;
	struct iked_hash		*prf = sa->sa_prf;
	struct iked_id			*id;
	struct iked_dsa			*dsa = NULL;
	struct ibuf			*buf;
	int				 ret = -1;
	u_int8_t			 keytype;

	if (sa->sa_hdr.sh_initiator)
		id = &sa->sa_icert;
	else
		id = &sa->sa_rcert;

	if ((dsa = dsa_sign_new(auth->auth_method, prf)) == NULL) {
		log_debug("%s: invalid auth method", __func__);
		return (-1);
	}

	switch (auth->auth_method) {
	case IKEV2_AUTH_SHARED_KEY_MIC:
		if (!auth->auth_length) {
			log_debug("%s: no pre-shared key found", __func__);
			goto done;
		}
		if ((keylen = ikev2_psk(sa, auth->auth_data,
		    auth->auth_length, &psk)) == -1) {
			log_debug("%s: failed to get PSK", __func__);
			goto done;
		}
		key = psk;
		keytype = 0;
		break;
	default:
		if (id == NULL) {
			log_debug("%s: no cert found", __func__);
			goto done;
		}
		key = ibuf_data(id->id_buf);
		keylen = ibuf_size(id->id_buf);
		keytype = id->id_type;
		break;
	}

	if (dsa_setkey(dsa, key, keylen, keytype) == NULL ||
	    dsa_init(dsa) != 0 ||
	    dsa_update(dsa, ibuf_data(authmsg), ibuf_size(authmsg))) {
		log_debug("%s: failed to compute digital signature", __func__);
		goto done;
	}

	ibuf_release(sa->sa_localauth.id_buf);
	sa->sa_localauth.id_buf = NULL;

	if ((buf = ibuf_new(NULL, dsa_length(dsa))) == NULL) {
		log_debug("%s: failed to get auth buffer", __func__);
		goto done;
	}

	if ((ret = dsa_sign_final(dsa,
	    ibuf_data(buf), ibuf_size(buf))) == -1) {
		log_debug("%s: failed to create auth signature", __func__);
		ibuf_release(buf);
		goto done;
	}

	sa->sa_localauth.id_type = auth->auth_method;
	sa->sa_localauth.id_buf = buf;

	ret = 0;
 done:
	if (psk != NULL)
		free(psk);
	dsa_free(dsa);

	return (ret);
}

int
ikev2_parse_nonce(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	size_t		 len;
	u_int8_t	*buf;
	u_int8_t	*msgbuf = ibuf_data(msg->msg_data);
	struct iked_sa	*sa = msg->msg_sa;
	struct ibuf	*localnonce, *peernonce;

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld);
	print_hex(buf, 0, len);

	if (!msg->msg_response) {
		if ((peernonce = ibuf_new(buf, len)) == NULL) {
			log_debug("%s: failed to get peer nonce", __func__);
			return (-1);
		}
		if ((localnonce =
		    ibuf_random(IKED_NONCE_SIZE)) == NULL) {
			log_debug("%s: failed to get local nonce", __func__);
			ibuf_release(peernonce);
			return (-1);
		}

		ibuf_release(sa->sa_inonce);
		ibuf_release(sa->sa_rnonce);

		log_debug("%s: updating nonces", __func__);

		if (sa->sa_hdr.sh_initiator) {
			sa->sa_inonce = localnonce;
			sa->sa_rnonce = peernonce;
		} else {
			sa->sa_inonce = peernonce;
			sa->sa_rnonce = localnonce;
		}
	}

	return (0);
}

int
ikev2_parse_notify(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_notify	*n;
	u_int8_t		*buf, md[SHA_DIGEST_LENGTH];
	size_t			 len;
	u_int16_t		 type;
	u_int32_t		 spi32;
	u_int64_t		 spi64;
	struct iked_spi		*rekey;
	
	if ((n = ibuf_seek(msg->msg_data, offset, sizeof(*n))) == NULL)
		return (-1);
	type = betoh16(n->n_type);

	log_debug("%s: protoid %s spisize %d type %s",
	    __func__,
	    print_map(n->n_protoid, ikev2_saproto_map), n->n_spisize,
	    print_map(type, ikev2_n_map));

	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(*n);
	if ((buf = ibuf_seek(msg->msg_data, offset + sizeof(*n), len)) == NULL)
		return (-1);

	print_hex(buf, 0, len);

	switch (type) {
	case IKEV2_N_NAT_DETECTION_SOURCE_IP:
	case IKEV2_N_NAT_DETECTION_DESTINATION_IP:
		if (ikev2_nat_detection(msg, md, sizeof(md), type,
		    msg->msg_response) == -1)
			return (-1);
		if (len != sizeof(md) || memcmp(buf, md, len) != 0) {
			log_debug("%s: %s detected NAT, enabling "
			    "UDP encapsulation", __func__,
			    print_map(type, ikev2_n_map));

			/*
			 * Enable UDP encapsulation of ESP packages if
			 * the check detected NAT.
			 */
			if (msg->msg_sa != NULL)
				msg->msg_sa->sa_udpencap = 1;
		}
		print_hex(md, 0, sizeof(md));
		break;
	case IKEV2_N_REKEY_SA:
		if (len != n->n_spisize) {
			log_debug("%s: malformed notification", __func__);
			return (-1);
		}
		if (msg->msg_decrypted)
			rekey = &msg->msg_decrypted->msg_rekey;
		else
			rekey = &msg->msg_rekey;
		if (rekey->spi != 0) {
			log_debug("%s: rekeying of multiple SAs not supported",
			    __func__);
			return (-1);
		}
		switch (n->n_spisize) {
		case 4:
			memcpy(&spi32, buf, len);
			rekey->spi = betoh32(spi32);
			break;
		case 8:
			memcpy(&spi64, buf, len);
			rekey->spi = betoh64(spi64);
			break;
		default:
			log_debug("%s: invalid spi size %d", __func__,
			    n->n_spisize);
			return (-1);
		}
		rekey->spi_size = n->n_spisize;
		rekey->spi_protoid = n->n_protoid;

		log_debug("%s: rekey %s spi %s", __func__,
		    print_map(n->n_protoid, ikev2_saproto_map),
		    print_spi(rekey->spi, n->n_spisize));
		break;
	}

	return (0);
}

int
ikev2_parse_delete(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_delete	*del, *localdel;
	u_int64_t		 spi64, spi = 0, *localspi = NULL;
	u_int32_t		 spi32;
	size_t			 len, i, cnt, sz, found = 0, failed = 0;
	u_int8_t		*buf, firstpayload = 0;
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
	struct iked_sa		*sa = msg->msg_sa;
	struct ibuf		*resp = NULL;
	int			 ret = -1;

	if ((del = ibuf_seek(msg->msg_data, offset, sizeof(*del))) == NULL)
		return (-1);
	cnt = betoh16(del->del_nspi);
	sz = del->del_spisize;

	log_debug("%s: protoid %s spisize %d nspi %d",
	    __func__, print_map(del->del_protoid, ikev2_saproto_map),
	    sz, cnt);

	buf = msgbuf + offset + sizeof(*del);
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(*del);

	print_hex(buf, 0, len);

	switch (sz) {
	case 4:
	case 8:
		break;
	default:
		if (!msg->msg_response &&
		    del->del_protoid == IKEV2_SAPROTO_IKE) {
			sa_state(env, sa, IKEV2_STATE_DELETE);
			return (0);
		}
		log_debug("%s: invalid SPI size", __func__);
		return (-1);
	}

	if ((len / sz) != cnt) {
		log_debug("%s: invalid payload length %d/%d != %d",
		    __func__, len, sz, cnt);
		return (-1);
	}

	if (!msg->msg_response &&
	    (localspi = calloc(cnt, sizeof(u_int64_t))) == NULL) {
		log_warn("%s", __func__);
		return (-1);
	}

	for (i = 0; i < cnt; i++) {
		/* XXX delete SAs */
		switch (sz) {
		case 4:
			memcpy(&spi32, buf + (i * sz), sizeof(spi32));
			spi = betoh32(spi32);
			break;
		case 8:
			memcpy(&spi64, buf + (i * sz), sizeof(spi64));
			spi = betoh64(spi64);
			break;
		}
		if (msg->msg_response) {
			log_debug("%s: spi %s", __func__, print_spi(spi, sz));
			continue;
		}

		if (ikev2_childsa_delete(env, sa,
		    del->del_protoid, spi, &localspi[i], 0) == -1)
			failed++;
		else
			found++;
	}

	if (msg->msg_response)
		return (0);

	if ((resp = ibuf_static()) == NULL)
		goto done;

	if (found) {
		if ((localdel = ibuf_advance(resp, sizeof(*localdel))) == NULL)
			goto done;

		firstpayload = IKEV2_PAYLOAD_DELETE;
		localdel->del_protoid = del->del_protoid;
		localdel->del_spisize = del->del_spisize;
		localdel->del_nspi = htobe16(found);

		for (i = 0; i < cnt; i++) {
			if (!localspi[i])
				continue;

			switch (sz) {
			case 4:
				spi32 = htobe32(localspi[i]);
				if (ibuf_add(resp, &spi32, sizeof(spi32)) != 0)
					goto done;
				break;
			case 8:
				spi64 = htobe64(localspi[i]);
				if (ibuf_add(resp, &spi64, sizeof(spi64)) != 0)
					goto done;
				break;
			}
		}

	}

	if (found) {
		ret = ikev2_send_ike_e(env, sa, resp,
		    firstpayload, IKEV2_EXCHANGE_INFORMATIONAL, 1);
	} else {
		/* XXX should we send an INVALID_SPI notification? */
		ret = 0;
	}

 done:
	if (localspi != NULL)
		free(localspi);
	ibuf_release(resp);
	return (ret);
}

int
ikev2_parse_ts(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset, u_int payload)
{
	u_int8_t			*ptr;
	struct ikev2_tsp		 tsp;
	struct ikev2_ts			 ts;
	size_t				 len, i;
	struct sockaddr_in		 s4;
	struct sockaddr_in6		 s6;
	u_int8_t			 buf[2][128];
	u_int8_t			*msgbuf = ibuf_data(msg->msg_data);

	memcpy(&tsp, msgbuf + offset, sizeof(tsp));
	offset += sizeof(tsp);

	ptr = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(tsp);

	log_debug("%s: count %d length %d", __func__,
	    tsp.tsp_count, len);

	for (i = 0; i < tsp.tsp_count; i++) {
		memcpy(&ts, msgbuf + offset, sizeof(ts));

		log_debug("%s: type %s protoid %u length %d "
		    "startport %u endport %u", __func__,
		    print_map(ts.ts_type, ikev2_ts_map),
		    ts.ts_protoid, betoh16(ts.ts_length),
		    betoh16(ts.ts_startport),
		    betoh16(ts.ts_endport));

		switch (ts.ts_type) {
		case IKEV2_TS_IPV4_ADDR_RANGE:
			bzero(&s4, sizeof(s4));
			s4.sin_family = AF_INET;
			s4.sin_len = sizeof(s4);
			memcpy(&s4.sin_addr.s_addr,
			    msgbuf + offset + sizeof(ts), 4);
			print_host((struct sockaddr_storage *)&s4,
			    (char *)buf[0], sizeof(buf[0]));
			memcpy(&s4.sin_addr.s_addr,
			    msgbuf + offset + sizeof(ts) + 4, 4);
			print_host((struct sockaddr_storage *)&s4,
			    (char *)buf[1], sizeof(buf[1]));
			log_debug("%s: start %s end %s", __func__,
			    buf[0], buf[1]);
			break;
		case IKEV2_TS_IPV6_ADDR_RANGE:
			bzero(&s6, sizeof(s6));
			s6.sin6_family = AF_INET6;
			s6.sin6_len = sizeof(s6);
			memcpy(&s6.sin6_addr,
			    msgbuf + offset + sizeof(ts), 16);
			print_host((struct sockaddr_storage *)&s6,
			    (char *)buf[0], sizeof(buf[0]));
			memcpy(&s6.sin6_addr,
			    msgbuf + offset + sizeof(ts) + 16, 16);
			print_host((struct sockaddr_storage *)&s6,
			    (char *)buf[1], sizeof(buf[1]));
			log_debug("%s: start %s end %s", __func__,
			    buf[0], buf[1]);
			break;
		default:
			break;
		}

		offset += betoh16(ts.ts_length);
	}

	return (0);
}

int
ikev2_parse_e(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ibuf		*e = NULL;
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
	struct iked_message	 emsg;
	u_int8_t		*buf;
	size_t			 len;
	int			 ret = -1;

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld);

	if ((e = ibuf_new(buf, len)) == NULL)
		goto done;

	if ((e = ikev2_message_decrypt(env, msg->msg_sa,
	    msg->msg_data, e)) == NULL)
		goto done;

	/*
	 * Parse decrypted payload
	 */
	bzero(&emsg, sizeof(emsg));
	memcpy(&emsg, msg, sizeof(*msg));
	emsg.msg_data = e;
	emsg.msg_decrypted = msg;
	TAILQ_INIT(&emsg.msg_proposals);

	ret = ikev2_parse_payloads(env, &emsg, 0, ibuf_size(e),
	    pld->pld_nextpayload, 0);

 done:
	ibuf_release(e);

	return (ret);
}

int
ikev2_parse_cp(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct ikev2_cp		 cp;
	struct ikev2_cfg	*cfg;
	u_int8_t		*buf;
	size_t			 len, i;
	u_int8_t		*msgbuf = ibuf_data(msg->msg_data);
	struct iked_sa		*sa = msg->msg_sa;

	memcpy(&cp, msgbuf + offset, sizeof(cp));
	offset += sizeof(cp);

	buf = msgbuf + offset;
	len = betoh16(pld->pld_length) - sizeof(*pld) - sizeof(cp);

	log_debug("%s: type %s",
	    __func__, print_map(cp.cp_type, ikev2_cp_map), len);
	print_hex(buf, 0, len);

	for (i = 0; i < len;) {
		cfg = (struct ikev2_cfg *)(buf + i);

		log_debug("%s: %s 0x%04x length %d", __func__,
		    print_map(betoh16(cfg->cfg_type), ikev2_cfg_map),
		    betoh16(cfg->cfg_type),
		    betoh16(cfg->cfg_length));

		i += betoh16(cfg->cfg_length) + sizeof(*cfg);
	}

	if (msg->msg_response)
		return (0);

	if (sa)
		sa->sa_cp = cp.cp_type;

	return (0);
}

int
ikev2_parse_eap(struct iked *env, struct ikev2_payload *pld,
    struct iked_message *msg, off_t offset)
{
	struct eap_header		*hdr;
	struct eap_message		*eap = NULL;
	struct iked_sa			*sa = msg->msg_sa;
	size_t				 len;

	if ((hdr = ibuf_seek(msg->msg_data, offset, sizeof(*hdr))) == NULL) {
		log_debug("%s: failed to get EAP header", __func__);
		return (-1);
	}

	len = betoh16(hdr->eap_length);

	if (len < sizeof(*eap)) {
		log_info("%s: %s id %d length %d", __func__,
		    print_map(hdr->eap_code, eap_code_map),
		    hdr->eap_id, betoh16(hdr->eap_length));
	} else {
		/* Now try to get the indicated length */
		if ((eap = ibuf_seek(msg->msg_data, offset, len)) == NULL) {
			log_debug("%s: invalid EAP length", __func__);
			return (-1);
		}

		log_info("%s: %s id %d length %d EAP-%s", __func__,
		    print_map(eap->eap_code, eap_code_map),
		    eap->eap_id, betoh16(eap->eap_length),
		    print_map(eap->eap_type, eap_type_map));
	}

	if (eap_parse(env, sa, hdr, msg->msg_response) == -1)
		return (-1);

	return (0);
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d3135 1
a3135 2
			 * the check detected NAT and and if we received
			 * the IKE message on the NAT-T port.
d3137 1
a3137 1
			if (msg->msg_sa != NULL && msg->msg_sa->sa_natt)
@

