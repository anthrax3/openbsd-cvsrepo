head	1.115;
access;
symbols
	OPENBSD_6_1:1.113.0.4
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.96.0.2
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.81.0.4
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.56.0.4
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.56.0.2
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.4
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18;
locks; strict;
comment	@ * @;


1.115
date	2017.04.26.10.42.38;	author henning;	state Exp;
branches;
next	1.114;
commitid	4JCdLHI0iXkeq6jm;

1.114
date	2017.04.13.07.04.09;	author patrick;	state Exp;
branches;
next	1.113;
commitid	bo33yiQX6Rmx6w3D;

1.113
date	2017.03.27.17.17.49;	author mikeb;	state Exp;
branches;
next	1.112;
commitid	Bk5vOJlj7LPPcjYU;

1.112
date	2017.03.27.10.43.53;	author mikeb;	state Exp;
branches;
next	1.111;
commitid	3tQzvpAXTrEiRD3X;

1.111
date	2017.03.27.10.21.19;	author reyk;	state Exp;
branches;
next	1.110;
commitid	luuYVyfWc8UoYDKf;

1.110
date	2017.03.27.10.06.41;	author reyk;	state Exp;
branches;
next	1.109;
commitid	37oqp7mUEkdGuEb4;

1.109
date	2017.03.13.18.49.20;	author mikeb;	state Exp;
branches;
next	1.108;
commitid	QPmMphRu2IVU5ovk;

1.108
date	2017.03.13.18.48.16;	author mikeb;	state Exp;
branches;
next	1.107;
commitid	yVaAm7edeFc8tc7a;

1.107
date	2017.03.13.18.28.02;	author reyk;	state Exp;
branches;
next	1.106;
commitid	1RefuXbcgN5FeUER;

1.106
date	2017.03.13.17.23.45;	author mikeb;	state Exp;
branches;
next	1.105;
commitid	iTSgtFdg16wtwocX;

1.105
date	2017.03.13.15.06.51;	author patrick;	state Exp;
branches;
next	1.104;
commitid	EkthUtnilpgGayvp;

1.104
date	2017.03.13.14.57.55;	author reyk;	state Exp;
branches;
next	1.103;
commitid	U1hvTbFj9hTbHufd;

1.103
date	2017.03.13.14.33.33;	author patrick;	state Exp;
branches;
next	1.102;
commitid	7TWpCOFlqUFXFrnD;

1.102
date	2017.02.03.08.23.46;	author guenther;	state Exp;
branches;
next	1.101;
commitid	RkgZAc0srXet0WqL;

1.101
date	2017.01.20.14.10.05;	author mikeb;	state Exp;
branches;
next	1.100;
commitid	CfbodF1uD0UR3vwu;

1.100
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.99;
commitid	eA8b246voAapPTkX;

1.99
date	2017.01.03.17.51.38;	author reyk;	state Exp;
branches;
next	1.98;
commitid	l0crj6yP4TgYYXus;

1.98
date	2016.09.04.10.26.02;	author vgross;	state Exp;
branches;
next	1.97;
commitid	2AXsFnCZH4WCra85;

1.97
date	2016.09.03.09.20.07;	author vgross;	state Exp;
branches;
next	1.96;
commitid	Bw4TFBm7VKjvvnRJ;

1.96
date	2016.06.01.11.16.41;	author patrick;	state Exp;
branches;
next	1.95;
commitid	LPZMTPg26WvdrIfQ;

1.95
date	2015.12.07.12.46.37;	author reyk;	state Exp;
branches;
next	1.94;
commitid	8zCLewXZF0DAEoO0;

1.94
date	2015.11.23.19.28.34;	author reyk;	state Exp;
branches;
next	1.93;
commitid	m6hksQq6WXPE2kks;

1.93
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.92;
commitid	T3JBYxNT0thPuavp;

1.92
date	2015.11.21.12.59.24;	author reyk;	state Exp;
branches;
next	1.91;
commitid	3e5uaIE8fHlFNGaa;

1.91
date	2015.10.22.15.55.18;	author reyk;	state Exp;
branches;
next	1.90;
commitid	9R73DxVDj9dmoXct;

1.90
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.89;
commitid	HzcDW70HFbhaqvT8;

1.89
date	2015.10.01.10.59.23;	author reyk;	state Exp;
branches;
next	1.88;
commitid	J33WGURgnlsCAOFp;

1.88
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.87;
commitid	CNs9dXqQUQ09vB19;

1.87
date	2015.08.19.14.12.43;	author reyk;	state Exp;
branches;
next	1.86;
commitid	AVPSAC8CcLDWTPgE;

1.86
date	2015.07.07.19.13.31;	author markus;	state Exp;
branches;
next	1.85;
commitid	a1FLyyKqRzzs0TCl;

1.85
date	2015.06.11.18.49.09;	author reyk;	state Exp;
branches;
next	1.84;
commitid	r36j1ZCD0yPK3S9O;

1.84
date	2015.03.26.19.52.35;	author markus;	state Exp;
branches;
next	1.83;
commitid	OLM4J0heQ8InGopV;

1.83
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	Uu5nFG3wCl0LACBb;

1.82
date	2014.08.18.09.43.02;	author reyk;	state Exp;
branches;
next	1.81;
commitid	o804X3aJRVygt1Ju;

1.81
date	2014.05.09.06.37.24;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2014.05.09.06.29.46;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2014.05.08.13.11.16;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2014.05.07.12.57.13;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2014.05.06.14.10.53;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2014.05.06.07.24.37;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2014.05.06.07.08.10;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2014.04.29.11.51.13;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2014.04.10.16.08.02;	author reyk;	state Exp;
branches;
next	1.70;

1.70
date	2014.02.21.20.52.38;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2014.02.17.15.53.46;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2014.02.17.15.07.23;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2014.02.14.10.23.43;	author benno;	state Exp;
branches;
next	1.66;

1.66
date	2014.02.14.09.00.03;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.24.07.31.25;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.24.05.58.52;	author mikeb;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.22.09.25.41;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.09.15.22.32;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.28.20.26.04;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.28.20.21.17;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.21.17.46.17;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.14.12.38.20;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.29.15.08.08;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2012.10.22.10.25.17;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.02.13.03.24;	author mikeb;	state Exp;
branches;
next	1.51;

1.51
date	2012.06.29.15.05.49;	author mikeb;	state Exp;
branches;
next	1.50;

1.50
date	2012.06.26.11.00.28;	author mikeb;	state Exp;
branches;
next	1.49;

1.49
date	2012.06.22.16.28.20;	author mikeb;	state Exp;
branches;
next	1.48;

1.48
date	2012.06.22.16.06.31;	author mikeb;	state Exp;
branches;
next	1.47;

1.47
date	2012.05.30.16.17.20;	author mikeb;	state Exp;
branches;
next	1.46;

1.46
date	2012.05.30.09.18.13;	author mikeb;	state Exp;
branches;
next	1.45;

1.45
date	2012.05.29.15.09.12;	author mikeb;	state Exp;
branches;
next	1.44;

1.44
date	2012.05.23.14.54.04;	author mikeb;	state Exp;
branches;
next	1.43;

1.43
date	2012.05.08.15.37.09;	author mikeb;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.05.17.31.36;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.05.12.59.31;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.02.12.39.18;	author mikeb;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.18.08.45.43;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.15.13.10.49;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.26.16.59.23;	author mikeb;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.21.17.01.33;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.21.16.51.38;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.21.11.37.02;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.17.18.49.35;	author mikeb;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.17.17.16.43;	author mikeb;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.12.14.35.45;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.12.14.26.26;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.22.17.53.54;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.22.17.43.10;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.01.12.01.25;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.17.16.43.45;	author ckuethe;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.22.09.12.18;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.09.13.06.46;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.01.02.15.08;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.29.21.04.42;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.27.05.49.05;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.27.01.03.22;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.26.19.54.19;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.26.19.48.04;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.26.18.32.34;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.14.23.14.09;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.14.21.12.56;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.14.14.03.15;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.14.11.33.55;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.14.08.55.59;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.11.12.47.18;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.12.06.34;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.08.29.47;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.115
log
@cope with IP address changes. before, we were trying to resend the msg
with the no-longer-available address over and over and over, requiring
iked to be restarted eventually. instead, on EADDRNOTAVAIL, schedule
SA deletion so a new one is set up shortly thereafter. ok reyk mikeb
@
text
@/*	$OpenBSD: iked.h,v 1.114 2017/04/13 07:04:09 patrick Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <arpa/inet.h>
#include <limits.h>
#include <imsg.h>

#include <openssl/evp.h>

#include "types.h"
#include "dh.h"

#ifndef IKED_H
#define IKED_H

/*
 * Common IKEv1/IKEv2 header
 */

struct ike_header {
	uint64_t	 ike_ispi;		/* Initiator cookie */
	uint64_t	 ike_rspi;		/* Responder cookie */
	uint8_t		 ike_nextpayload;	/* Next payload type */
	uint8_t		 ike_version;		/* Major/Minor version number */
	uint8_t		 ike_exchange;		/* Exchange type */
	uint8_t		 ike_flags;		/* Message options */
	uint32_t	 ike_msgid;		/* Message identifier */
	uint32_t	 ike_length;		/* Total message length */
} __packed;

/*
 * Common daemon infrastructure, local imsg etc.
 */

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	struct privsep_proc	*proc;
	void			*data;
	short			 events;
	const char		*name;
};

#define IMSG_SIZE_CHECK(imsg, p) do {				\
	if (IMSG_DATA_SIZE(imsg) < sizeof(*p))			\
		fatalx("bad length imsg received");		\
} while (0)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)

#define IKED_ADDR_EQ(_a, _b)						\
	((_a)->addr_mask == (_b)->addr_mask &&				\
	sockaddr_cmp((struct sockaddr *)&(_a)->addr,			\
	(struct sockaddr *)&(_b)->addr, (_a)->addr_mask) == 0)

#define IKED_ADDR_NEQ(_a, _b)						\
	((_a)->addr_mask != (_b)->addr_mask ||				\
	sockaddr_cmp((struct sockaddr *)&(_a)->addr,			\
	(struct sockaddr *)&(_b)->addr, (_a)->addr_mask) != 0)

/* initially control.h */
struct control_sock {
	const char	*cs_name;
	struct event	 cs_ev;
	struct event	 cs_evt;
	int		 cs_fd;
	int		 cs_restricted;
	void		*cs_env;

	TAILQ_ENTRY(control_sock) cs_entry;
};
TAILQ_HEAD(control_socks, control_sock);

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	uint8_t			 flags;
#define CTL_CONN_NOTIFY		 0x01
	struct imsgev		 iev;
};
TAILQ_HEAD(ctl_connlist, ctl_conn);
extern  struct ctl_connlist ctl_conns;

enum privsep_procid privsep_process;

/*
 * Runtime structures
 */

struct iked_timer {
	struct event	 tmr_ev;
	struct iked	*tmr_env;
	void		(*tmr_cb)(struct iked *, void *);
	void		*tmr_cbarg;
};

struct iked_spi {
	uint64_t	 spi;
	uint8_t		 spi_size;
	uint8_t		 spi_protoid;
};

struct iked_proposal {
	uint8_t				 prop_id;
	uint8_t				 prop_protoid;

	struct iked_spi			 prop_localspi;
	struct iked_spi			 prop_peerspi;

	struct iked_transform		*prop_xforms;
	unsigned int			 prop_nxforms;

	TAILQ_ENTRY(iked_proposal)	 prop_entry;
};
TAILQ_HEAD(iked_proposals, iked_proposal);

struct iked_addr {
	int				 addr_af;
	struct sockaddr_storage		 addr;
	uint8_t				 addr_mask;
	int				 addr_net;
	in_port_t			 addr_port;
};

struct iked_flow {
	struct iked_addr		 flow_src;
	struct iked_addr		 flow_dst;
	unsigned int			 flow_dir;	/* in/out */
	struct iked_addr		 flow_prenat;

	unsigned int			 flow_loaded;	/* pfkey done */

	uint8_t				 flow_saproto;
	uint8_t				 flow_ipproto;
	uint8_t				 flow_type;

	struct iked_addr		*flow_local;	/* outer source */
	struct iked_addr		*flow_peer;	/* outer dest */
	struct iked_sa			*flow_ikesa;	/* parent SA */

	RB_ENTRY(iked_flow)		 flow_node;
	TAILQ_ENTRY(iked_flow)		 flow_entry;
	int				 flow_ipcomp;
};
RB_HEAD(iked_flows, iked_flow);
TAILQ_HEAD(iked_saflows, iked_flow);

struct iked_childsa {
	uint8_t				 csa_saproto;	/* IPSec protocol */
	unsigned int			 csa_dir;	/* in/out */

	uint64_t			 csa_peerspi;	/* peer relation */
	uint8_t				 csa_loaded;	/* pfkey done */
	uint8_t				 csa_rekey;	/* will be deleted */
	uint8_t				 csa_allocated;	/* from the kernel */
	uint8_t				 csa_persistent;/* do not rekey */
	uint8_t				 csa_esn;	/* use ESN */
	uint8_t				 csa_transport;	/* transport mode */
	uint8_t				 csa_acquired;	/* no rekey for me */

	struct iked_spi			 csa_spi;

	struct ibuf			*csa_encrkey;	/* encryption key */
	uint16_t			 csa_encrid;	/* encryption xform id */

	struct ibuf			*csa_integrkey;	/* auth key */
	uint16_t			 csa_integrid;	/* auth xform id */

	struct iked_addr		*csa_local;	/* outer source */
	struct iked_addr		*csa_peer;	/* outer dest */
	struct iked_sa			*csa_ikesa;	/* parent SA */

	struct iked_childsa		*csa_peersa;	/* peer */

	struct iked_childsa		*csa_parent;	/* IPCOMP parent */
	unsigned int			 csa_children;	/* IPCOMP children */

	RB_ENTRY(iked_childsa)		 csa_node;
	TAILQ_ENTRY(iked_childsa)	 csa_entry;
};
RB_HEAD(iked_activesas, iked_childsa);
TAILQ_HEAD(iked_childsas, iked_childsa);


struct iked_static_id {
	uint8_t		id_type;
	uint8_t		id_length;
	uint8_t		id_offset;
	uint8_t		id_data[IKED_ID_SIZE];
};

struct iked_auth {
	uint8_t		auth_method;
	uint8_t		auth_eap;			/* optional EAP */
	uint8_t		auth_length;			/* zero if EAP */
	uint8_t		auth_data[IKED_PSK_SIZE];
};

struct iked_cfg {
	uint8_t				 cfg_action;
	uint16_t			 cfg_type;
	union {
		struct iked_addr	 address;
	} cfg;
};

TAILQ_HEAD(iked_sapeers, iked_sa);

struct iked_lifetime {
	uint64_t			 lt_bytes;
	uint64_t			 lt_seconds;
};

struct iked_policy {
	unsigned int			 pol_id;
	char				 pol_name[IKED_ID_SIZE];

#define IKED_SKIP_FLAGS			 0
#define IKED_SKIP_AF			 1
#define IKED_SKIP_PROTO			 2
#define IKED_SKIP_SRC_ADDR		 3
#define IKED_SKIP_DST_ADDR		 4
#define IKED_SKIP_COUNT			 5
	struct iked_policy		*pol_skip[IKED_SKIP_COUNT];

	uint8_t				 pol_flags;
#define IKED_POLICY_PASSIVE		 0x00
#define IKED_POLICY_DEFAULT		 0x01
#define IKED_POLICY_ACTIVE		 0x02
#define IKED_POLICY_REFCNT		 0x04
#define IKED_POLICY_QUICK		 0x08
#define IKED_POLICY_SKIP		 0x10
#define IKED_POLICY_IPCOMP		 0x20

	int				 pol_refcnt;

	uint8_t				 pol_certreqtype;

	int				 pol_af;
	uint8_t				 pol_saproto;
	unsigned int			 pol_ipproto;

	struct iked_addr		 pol_peer;
	struct iked_static_id		 pol_peerid;
	uint32_t			 pol_peerdh;

	struct iked_addr		 pol_local;
	struct iked_static_id		 pol_localid;

	struct iked_auth		 pol_auth;

	char				 pol_tag[IKED_TAG_SIZE];
	unsigned int			 pol_tap;

	struct iked_proposals		 pol_proposals;
	size_t				 pol_nproposals;

	struct iked_flows		 pol_flows;
	size_t				 pol_nflows;

	struct iked_cfg			 pol_cfg[IKED_CFG_MAX];
	unsigned int			 pol_ncfg;

	uint32_t			 pol_rekey;	/* ike SA lifetime */
	struct iked_lifetime		 pol_lifetime;	/* child SA lifetime */

	struct iked_sapeers		 pol_sapeers;

	TAILQ_ENTRY(iked_policy)	 pol_entry;
};
TAILQ_HEAD(iked_policies, iked_policy);

struct iked_hash {
	uint8_t		 hash_type;	/* PRF or INTEGR */
	uint16_t	 hash_id;	/* IKE PRF/INTEGR hash id */
	const void	*hash_priv;	/* Identifying the hash alg */
	void		*hash_ctx;	/* Context of the current invocation */
	int		 hash_fixedkey;	/* Requires fixed key length */
	struct ibuf	*hash_key;	/* MAC key derived from key seed */
	size_t		 hash_length;	/* Output length */
	size_t		 hash_trunc;	/* Truncate the output length */
	struct iked_hash *hash_prf;	/* PRF pointer */
};

struct iked_cipher {
	uint8_t		 encr_type;	/* ENCR */
	uint16_t	 encr_id;	/* IKE ENCR hash id */
	const void	*encr_priv;	/* Identifying the hash alg */
	void		*encr_ctx;	/* Context of the current invocation */
	int		 encr_fixedkey;	/* Requires fixed key length */
	struct ibuf	*encr_key;	/* MAC key derived from key seed */
	struct ibuf	*encr_iv;	/* Initialization Vector */
	size_t		 encr_ivlength;	/* IV length */
	size_t		 encr_length;	/* Block length */
};

struct iked_dsa {
	uint8_t		 dsa_method;	/* AUTH method */
	const void	*dsa_priv;	/* PRF or signature hash function */
	void		*dsa_ctx;	/* PRF or signature hash ctx */
	struct ibuf	*dsa_keydata;	/* public, private or shared key */
	void		*dsa_key;	/* parsed public or private key */
	void		*dsa_cert;	/* parsed certificate */
	int		 dsa_hmac;	/* HMAC or public/private key */
	int		 dsa_sign;	/* Sign or verify operation */
};

struct iked_id {
	uint8_t		 id_type;
	uint8_t		 id_offset;
	struct ibuf	*id_buf;
};

#define IKED_REQ_CERT		0x0001	/* get local certificate (if required) */
#define IKED_REQ_CERTVALID	0x0002	/* validated the peer cert */
#define IKED_REQ_CERTREQ	0x0004	/* CERTREQ has been received */
#define IKED_REQ_AUTH		0x0008	/* AUTH payload */
#define IKED_REQ_AUTHVALID	0x0010	/* AUTH payload has been verified */
#define IKED_REQ_SA		0x0020	/* SA available */
#define IKED_REQ_EAPVALID	0x0040	/* EAP payload has been verified */
#define IKED_REQ_CHILDSA	0x0080	/* Child SA initiated */
#define IKED_REQ_INF		0x0100	/* Informational exchange initiated */

#define IKED_REQ_BITS	\
    "\20\01CERT\02CERTVALID\03CERTREQ\04AUTH\05AUTHVALID\06SA\07EAPVALID" \
    "\10CHILDSA\11INF"

TAILQ_HEAD(iked_msgqueue, iked_message);

struct iked_sahdr {
	uint64_t			 sh_ispi;	/* Initiator SPI */
	uint64_t			 sh_rspi;	/* Responder SPI */
	unsigned int			 sh_initiator;	/* Is initiator? */
} __packed;

struct iked_kex {
	struct ibuf			*kex_inonce;	/* Ni */
	struct ibuf			*kex_rnonce;	/* Nr */

	struct group			*kex_dhgroup;	/* DH group */
	struct ibuf			*kex_dhiexchange;
	struct ibuf			*kex_dhrexchange;
	struct ibuf			*kex_dhpeer;	/* pointer to i or r */
};

struct iked_sa {
	struct iked_sahdr		 sa_hdr;
	uint32_t			 sa_msgid;	/* Last request rcvd */
	int				 sa_msgid_set;	/* msgid initialized */
	uint32_t			 sa_reqid;	/* Next request sent */

	int				 sa_type;
#define IKED_SATYPE_LOOKUP		 0		/* Used for lookup */
#define IKED_SATYPE_LOCAL		 1		/* Local SA */

	struct iked_addr		 sa_peer;
	struct iked_addr		 sa_local;
	int				 sa_fd;

	int				 sa_natt;	/* for IKE messages */
	int				 sa_udpencap;	/* for pfkey */
	int				 sa_usekeepalive;/* NAT-T keepalive */

	int				 sa_state;
	unsigned int			 sa_stateflags;
	unsigned int			 sa_stateinit;	/* SA_INIT */
	unsigned int			 sa_statevalid;	/* IKE_AUTH */

	int				 sa_cp;		/* XXX */

	struct iked_policy		*sa_policy;
	struct timeval			 sa_timecreated;
	struct timeval			 sa_timeused;

	char				*sa_tag;

	struct iked_kex			 sa_kex;
/* XXX compat defines until everything is converted */
#define sa_inonce		sa_kex.kex_inonce
#define sa_rnonce		sa_kex.kex_rnonce
#define sa_dhgroup		sa_kex.kex_dhgroup
#define sa_dhiexchange		sa_kex.kex_dhiexchange
#define sa_dhrexchange		sa_kex.kex_dhrexchange
#define sa_dhpeer		sa_kex.kex_dhpeer

	struct iked_hash		*sa_prf;	/* PRF alg */
	struct iked_hash		*sa_integr;	/* integrity alg */
	struct iked_cipher		*sa_encr;	/* encryption alg */

	struct ibuf			*sa_key_d;	/* SK_d */
	struct ibuf			*sa_key_iauth;	/* SK_ai */
	struct ibuf			*sa_key_rauth;	/* SK_ar */
	struct ibuf			*sa_key_iencr;	/* SK_ei */
	struct ibuf			*sa_key_rencr;	/* SK_er */
	struct ibuf			*sa_key_iprf;	/* SK_pi */
	struct ibuf			*sa_key_rprf;	/* SK_pr */

	struct ibuf			*sa_1stmsg;	/* for initiator AUTH */
	struct ibuf			*sa_2ndmsg;	/* for responder AUTH */
	struct iked_id			 sa_localauth;	/* local AUTH message */
	int				 sa_sigsha2;	/* use SHA2 for signatures */

	struct iked_id			 sa_iid;	/* initiator id */
	struct iked_id			 sa_rid;	/* responder id */
	struct iked_id			 sa_icert;	/* initiator cert */
	struct iked_id			 sa_rcert;	/* responder cert */
#define IKESA_SRCID(x) ((x)->sa_hdr.sh_initiator ? &(x)->sa_iid : &(x)->sa_rid)
#define IKESA_DSTID(x) ((x)->sa_hdr.sh_initiator ? &(x)->sa_rid : &(x)->sa_iid)

	char				*sa_eapid;	/* EAP identity */
	struct iked_id			 sa_eap;	/* EAP challenge */
	struct ibuf			*sa_eapmsk;	/* EAK session key */

	struct iked_proposals		 sa_proposals;	/* SA proposals */
	struct iked_childsas		 sa_childsas;	/* IPSec Child SAs */
	struct iked_saflows		 sa_flows;	/* IPSec flows */

	struct iked_sa			*sa_nexti;	/* initiated IKE SA */
	struct iked_sa			*sa_nextr;	/* simultaneous rekey */
	uint64_t			 sa_rekeyspi;	/* peerspi CSA rekey*/
	struct ibuf			*sa_simult;	/* simultaneous rekey */

	uint8_t				 sa_ipcomp;	/* IPcomp transform */
	uint16_t			 sa_cpi_out;	/* IPcomp outgoing */
	uint16_t			 sa_cpi_in;	/* IPcomp incoming*/

	struct iked_timer		 sa_timer;	/* SA timeouts */
#define IKED_IKE_SA_EXCHANGE_TIMEOUT	 300		/* 5 minutes */
#define IKED_IKE_SA_REKEY_TIMEOUT	 120		/* 2 minutes */
#define IKED_IKE_SA_DELETE_TIMEOUT	 120		/* 2 minutes */
#define IKED_IKE_SA_ALIVE_TIMEOUT	 60		/* 1 minute */

	struct iked_timer		 sa_keepalive;	/* keepalive timer */
#define IKED_IKE_SA_KEEPALIVE_TIMEOUT	 20

	struct iked_timer		 sa_rekey;	/* rekey timeout */

	struct iked_msgqueue		 sa_requests;	/* request queue */
#define IKED_RETRANSMIT_TIMEOUT		 2		/* 2 seconds */

	struct iked_msgqueue		 sa_responses;	/* response queue */
#define IKED_RESPONSE_TIMEOUT		 120		/* 2 minutes */

	TAILQ_ENTRY(iked_sa)		 sa_peer_entry;
	RB_ENTRY(iked_sa)		 sa_entry;

	struct iked_addr		*sa_addrpool;	/* address from pool */
	RB_ENTRY(iked_sa)		 sa_addrpool_entry;	/* pool entries */

	struct iked_addr		*sa_addrpool6;	/* address from pool */
	RB_ENTRY(iked_sa)		 sa_addrpool6_entry;	/* pool entries */
};
RB_HEAD(iked_sas, iked_sa);
RB_HEAD(iked_addrpool, iked_sa);
RB_HEAD(iked_addrpool6, iked_sa);

struct iked_message {
	struct ibuf		*msg_data;
	size_t			 msg_offset;

	struct sockaddr_storage	 msg_local;
	socklen_t		 msg_locallen;

	struct sockaddr_storage	 msg_peer;
	socklen_t		 msg_peerlen;

	struct iked_socket	*msg_sock;

	int			 msg_fd;
	int			 msg_response;
	int			 msg_responded;
	int			 msg_natt;
	int			 msg_error;
	int			 msg_e;
	struct iked_message	*msg_parent;

	/* Associated policy and SA */
	struct iked_policy	*msg_policy;
	struct iked_sa		*msg_sa;

	uint32_t		 msg_msgid;
	uint8_t			 msg_exchange;

	/* Parsed information */
	struct iked_proposals	 msg_proposals;
	struct iked_spi		 msg_rekey;
	struct ibuf		*msg_nonce;	/* dh NONCE */
	struct ibuf		*msg_ke;	/* dh key exchange */
	struct iked_id		 msg_auth;	/* AUTH payload */
	struct iked_id		 msg_id;
	struct iked_id		 msg_cert;
	struct ibuf		*msg_cookie;

	/* Parse stack */
	struct iked_proposal	*msg_prop;
	uint16_t		 msg_attrlength;

	/* Retransmit queue */
	struct iked_timer	 msg_timer;
	TAILQ_ENTRY(iked_message)
				 msg_entry;
	int			 msg_tries;	/* retransmits sent */
#define IKED_RETRANSMIT_TRIES	 5		/* try 5 times */
};

struct iked_user {
	char			 usr_name[LOGIN_NAME_MAX];
	char			 usr_pass[IKED_PASSWORD_SIZE];
	RB_ENTRY(iked_user)	 usr_entry;
};
RB_HEAD(iked_users, iked_user);

struct privsep_pipes {
	int				*pp_pipes[PROC_MAX];
};

struct privsep {
	struct privsep_pipes		*ps_pipes[PROC_MAX];
	struct privsep_pipes		*ps_pp;

	struct imsgev			*ps_ievs[PROC_MAX];
	const char			*ps_title[PROC_MAX];
	pid_t				 ps_pid[PROC_MAX];
	struct passwd			*ps_pw;
	int				 ps_noaction;

	struct control_sock		 ps_csock;
	struct control_socks		 ps_rcsocks;

	unsigned int			 ps_instances[PROC_MAX];
	unsigned int			 ps_ninstances;
	unsigned int			 ps_instance;

	/* Event and signal handlers */
	struct event			 ps_evsigint;
	struct event			 ps_evsigterm;
	struct event			 ps_evsigchld;
	struct event			 ps_evsighup;
	struct event			 ps_evsigpipe;
	struct event			 ps_evsigusr1;

	struct iked			*ps_env;
};

struct privsep_proc {
	const char		*p_title;
	enum privsep_procid	 p_id;
	int			(*p_cb)(int, struct privsep_proc *,
				    struct imsg *);
	pid_t			(*p_init)(struct privsep *,
				    struct privsep_proc *);
	const char		*p_chroot;
	struct privsep		*p_ps;
	struct iked		*p_env;
	void			(*p_shutdown)(void);
	unsigned int		 p_instance;
};

struct iked_ocsp_entry {
	TAILQ_ENTRY(iked_ocsp_entry) ioe_entry;	/* next request */
	void			*ioe_ocsp;	/* private ocsp request data */
};
TAILQ_HEAD(iked_ocsp_requests, iked_ocsp_entry);

/*
 * Daemon configuration
 */

struct iked {
	char				 sc_conffile[PATH_MAX];

	uint32_t			 sc_opts;
	uint8_t				 sc_passive;
	uint8_t				 sc_decoupled;

	struct iked_policies		 sc_policies;
	struct iked_policy		*sc_defaultcon;

	struct iked_sas			 sc_sas;
	struct iked_activesas		 sc_activesas;
	struct iked_flows		 sc_activeflows;
	struct iked_users		 sc_users;

	void				*sc_priv;	/* per-process */

	int				 sc_pfkey;	/* ike process */
	struct event			 sc_pfkeyev;
	uint8_t				 sc_certreqtype;
	struct ibuf			*sc_certreq;

	struct iked_socket		*sc_sock4[2];
	struct iked_socket		*sc_sock6[2];

	struct iked_timer		 sc_inittmr;
#define IKED_INITIATOR_INITIAL		 2
#define IKED_INITIATOR_INTERVAL		 60

	struct privsep			 sc_ps;

	struct iked_ocsp_requests	 sc_ocsp;
	char				*sc_ocsp_url;

	struct iked_addrpool		 sc_addrpool;
	struct iked_addrpool6		 sc_addrpool6;
};

struct iked_socket {
	int			 sock_fd;
	struct event		 sock_ev;
	struct iked		*sock_env;
	struct sockaddr_storage	 sock_addr;
};

/* iked.c */
void	 parent_reload(struct iked *, int, const char *);

/* control.c */
pid_t	 control(struct privsep *, struct privsep_proc *);
int	 control_init(struct privsep *, struct control_sock *);
int	 control_listen(struct control_sock *);
void	 control_cleanup(struct control_sock *);

/* config.c */
struct iked_policy *
	 config_new_policy(struct iked *);
void	 config_free_kex(struct iked_kex *);
void	 config_free_sa(struct iked *, struct iked_sa *);
struct iked_sa *
	 config_new_sa(struct iked *, int);
struct iked_user *
	 config_new_user(struct iked *, struct iked_user *);
uint64_t
	 config_getspi(void);
struct iked_transform *
	 config_findtransform(struct iked_proposals *, uint8_t, unsigned int);
void	 config_free_policy(struct iked *, struct iked_policy *);
struct iked_proposal *
	 config_add_proposal(struct iked_proposals *, unsigned int,
	    unsigned int);
void	 config_free_proposals(struct iked_proposals *, unsigned int);
void	 config_free_flows(struct iked *, struct iked_flows *);
void	 config_free_childsas(struct iked *, struct iked_childsas *,
	    struct iked_spi *, struct iked_spi *);
struct iked_transform *
	 config_add_transform(struct iked_proposal *,
	    unsigned int, unsigned int, unsigned int, unsigned int);
int	 config_setcoupled(struct iked *, unsigned int);
int	 config_getcoupled(struct iked *, unsigned int);
int	 config_setmode(struct iked *, unsigned int);
int	 config_getmode(struct iked *, unsigned int);
int	 config_setreset(struct iked *, unsigned int, enum privsep_procid);
int	 config_getreset(struct iked *, struct imsg *);
int	 config_setpolicy(struct iked *, struct iked_policy *,
	    enum privsep_procid);
int	 config_getpolicy(struct iked *, struct imsg *);
int	 config_setflow(struct iked *, struct iked_policy *,
	    enum privsep_procid);
int	 config_getflow(struct iked *, struct imsg *);
int	 config_setsocket(struct iked *, struct sockaddr_storage *, in_port_t,
	    enum privsep_procid);
int	 config_getsocket(struct iked *env, struct imsg *,
	    void (*cb)(int, short, void *));
int	 config_setpfkey(struct iked *, enum privsep_procid);
int	 config_getpfkey(struct iked *, struct imsg *);
int	 config_setuser(struct iked *, struct iked_user *, enum privsep_procid);
int	 config_getuser(struct iked *, struct imsg *);
int	 config_setcompile(struct iked *, enum privsep_procid);
int	 config_getcompile(struct iked *, struct imsg *);
int	 config_setocsp(struct iked *);
int	 config_getocsp(struct iked *, struct imsg *);
int	 config_setkeys(struct iked *);
int	 config_getkey(struct iked *, struct imsg *);

/* policy.c */
void	 policy_init(struct iked *);
int	 policy_lookup(struct iked *, struct iked_message *);
struct iked_policy *
	 policy_test(struct iked *, struct iked_policy *);
void	 policy_calc_skip_steps(struct iked_policies *);
void	 policy_ref(struct iked *, struct iked_policy *);
void	 policy_unref(struct iked *, struct iked_policy *);
void	 sa_state(struct iked *, struct iked_sa *, int);
void	 sa_stateflags(struct iked_sa *, unsigned int);
int	 sa_stateok(struct iked_sa *, int);
struct iked_sa *
	 sa_new(struct iked *, uint64_t, uint64_t, unsigned int,
	    struct iked_policy *);
void	 sa_free(struct iked *, struct iked_sa *);
void	 sa_free_flows(struct iked *, struct iked_saflows *);
int	 sa_address(struct iked_sa *, struct iked_addr *,
	    struct sockaddr_storage *);
void	 childsa_free(struct iked_childsa *);
struct iked_childsa *
	 childsa_lookup(struct iked_sa *, uint64_t, uint8_t);
void	 flow_free(struct iked_flow *);
int	 flow_equal(struct iked_flow *, struct iked_flow *);
struct iked_sa *
	 sa_lookup(struct iked *, uint64_t, uint64_t, unsigned int);
struct iked_user *
	 user_lookup(struct iked *, const char *);
RB_PROTOTYPE(iked_sas, iked_sa, sa_entry, sa_cmp);
RB_PROTOTYPE(iked_addrpool, iked_sa, sa_addrpool_entry, sa_addrpool_cmp);
RB_PROTOTYPE(iked_addrpool6, iked_sa, sa_addrpool6_entry, sa_addrpool6_cmp);
RB_PROTOTYPE(iked_users, iked_user, user_entry, user_cmp);
RB_PROTOTYPE(iked_activesas, iked_childsa, csa_node, childsa_cmp);
RB_PROTOTYPE(iked_flows, iked_flow, flow_node, flow_cmp);

/* crypto.c */
struct iked_hash *
	 hash_new(uint8_t, uint16_t);
struct ibuf *
	 hash_setkey(struct iked_hash *, void *, size_t);
void	 hash_free(struct iked_hash *);
void	 hash_init(struct iked_hash *);
void	 hash_update(struct iked_hash *, void *, size_t);
void	 hash_final(struct iked_hash *, void *, size_t *);
size_t	 hash_keylength(struct iked_hash *);
size_t	 hash_length(struct iked_hash *);

struct iked_cipher *
	 cipher_new(uint8_t, uint16_t, uint16_t);
struct ibuf *
	 cipher_setkey(struct iked_cipher *, void *, size_t);
struct ibuf *
	 cipher_setiv(struct iked_cipher *, void *, size_t);
void	 cipher_free(struct iked_cipher *);
void	 cipher_init(struct iked_cipher *, int);
void	 cipher_init_encrypt(struct iked_cipher *);
void	 cipher_init_decrypt(struct iked_cipher *);
void	 cipher_update(struct iked_cipher *, void *, size_t, void *, size_t *);
void	 cipher_final(struct iked_cipher *, void *, size_t *);
size_t	 cipher_length(struct iked_cipher *);
size_t	 cipher_keylength(struct iked_cipher *);
size_t	 cipher_ivlength(struct iked_cipher *);
size_t	 cipher_outlength(struct iked_cipher *, size_t);

struct iked_dsa *
	 dsa_new(uint16_t, struct iked_hash *, int);
struct iked_dsa *
	 dsa_sign_new(uint16_t, struct iked_hash *);
struct iked_dsa *
	 dsa_verify_new(uint16_t, struct iked_hash *);
struct ibuf *
	 dsa_setkey(struct iked_dsa *, void *, size_t, uint8_t);
void	 dsa_free(struct iked_dsa *);
int	 dsa_init(struct iked_dsa *, const void *, size_t);
size_t	 dsa_prefix(struct iked_dsa *);
size_t	 dsa_length(struct iked_dsa *);
int	 dsa_update(struct iked_dsa *, const void *, size_t);
ssize_t	 dsa_sign_final(struct iked_dsa *, void *, size_t);
ssize_t	 dsa_verify_final(struct iked_dsa *, void *, size_t);

/* ikev2.c */
pid_t	 ikev2(struct privsep *, struct privsep_proc *);
void	 ikev2_recv(struct iked *, struct iked_message *);
void	 ikev2_init_ike_sa(struct iked *, void *);
int	 ikev2_sa_negotiate(struct iked_proposals *, struct iked_proposals *,
	    struct iked_proposals *, int);
int	 ikev2_policy2id(struct iked_static_id *, struct iked_id *, int);
int	 ikev2_childsa_enable(struct iked *, struct iked_sa *);
int	 ikev2_childsa_delete(struct iked *, struct iked_sa *,
	    uint8_t, uint64_t, uint64_t *, int);
void	 ikev2_ikesa_recv_delete(struct iked *, struct iked_sa *);
void	 ikev2_ike_sa_timeout(struct iked *env, void *);

struct ibuf *
	 ikev2_prfplus(struct iked_hash *, struct ibuf *, struct ibuf *,
	    size_t);
ssize_t	 ikev2_psk(struct iked_sa *, uint8_t *, size_t, uint8_t **);
ssize_t	 ikev2_nat_detection(struct iked *, struct iked_message *,
	    void *, size_t, unsigned int);
int	 ikev2_send_informational(struct iked *, struct iked_message *);
int	 ikev2_send_ike_e(struct iked *, struct iked_sa *, struct ibuf *,
	    uint8_t, uint8_t, int);
struct ike_header *
	 ikev2_add_header(struct ibuf *, struct iked_sa *,
	    uint32_t, uint8_t, uint8_t, uint8_t);
int	 ikev2_set_header(struct ike_header *, size_t);
struct ikev2_payload *
	 ikev2_add_payload(struct ibuf *);
int	 ikev2_next_payload(struct ikev2_payload *, size_t,
	    uint8_t);
int	 ikev2_acquire_sa(struct iked *, struct iked_flow *);
void	 ikev2_disable_rekeying(struct iked *, struct iked_sa *);
int	 ikev2_rekey_sa(struct iked *, struct iked_spi *);
int	 ikev2_drop_sa(struct iked *, struct iked_spi *);
int	 ikev2_print_id(struct iked_id *, char *, size_t);

/* ikev2_msg.c */
void	 ikev2_msg_cb(int, short, void *);
struct ibuf *
	 ikev2_msg_init(struct iked *, struct iked_message *,
	    struct sockaddr_storage *, socklen_t,
	    struct sockaddr_storage *, socklen_t, int);
struct iked_message *
	 ikev2_msg_copy(struct iked *, struct iked_message *);
void	 ikev2_msg_cleanup(struct iked *, struct iked_message *);
uint32_t
	 ikev2_msg_id(struct iked *, struct iked_sa *);
struct ibuf
	*ikev2_msg_auth(struct iked *, struct iked_sa *, int);
int	 ikev2_msg_authsign(struct iked *, struct iked_sa *,
	    struct iked_auth *, struct ibuf *);
int	 ikev2_msg_authverify(struct iked *, struct iked_sa *,
	    struct iked_auth *, uint8_t *, size_t, struct ibuf *);
int	 ikev2_msg_valid_ike_sa(struct iked *, struct ike_header *,
	    struct iked_message *);
int	 ikev2_msg_send(struct iked *, struct iked_message *);
int	 ikev2_msg_send_encrypt(struct iked *, struct iked_sa *,
	    struct ibuf **, uint8_t, uint8_t, int);
struct ibuf
	*ikev2_msg_encrypt(struct iked *, struct iked_sa *, struct ibuf *);
struct ibuf *
	 ikev2_msg_decrypt(struct iked *, struct iked_sa *,
	    struct ibuf *, struct ibuf *);
int	 ikev2_msg_integr(struct iked *, struct iked_sa *, struct ibuf *);
int	 ikev2_msg_frompeer(struct iked_message *);
struct iked_socket *
	 ikev2_msg_getsocket(struct iked *, int, int);
int	 ikev2_msg_retransmit_response(struct iked *, struct iked_sa *,
	    struct iked_message *);
void	 ikev2_msg_prevail(struct iked *, struct iked_msgqueue *,
	    struct iked_message *);
void	 ikev2_msg_dispose(struct iked *, struct iked_msgqueue *,
	    struct iked_message *);
void	 ikev2_msg_flushqueue(struct iked *, struct iked_msgqueue *);
struct iked_message *
	 ikev2_msg_lookup(struct iked *, struct iked_msgqueue *,
	    struct iked_message *, struct ike_header *);

/* ikev2_pld.c */
int	 ikev2_pld_parse(struct iked *, struct ike_header *,
	    struct iked_message *, size_t);

/* eap.c */
ssize_t	 eap_identity_request(struct ibuf *);
int	 eap_parse(struct iked *, struct iked_sa *, void *, int);

/* pfkey.c */
int	 pfkey_couple(int, struct iked_sas *, int);
int	 pfkey_flow_add(int fd, struct iked_flow *);
int	 pfkey_flow_delete(int fd, struct iked_flow *);
int	 pfkey_block(int, int, unsigned int);
int	 pfkey_sa_init(int, struct iked_childsa *, uint32_t *);
int	 pfkey_sa_add(int, struct iked_childsa *, struct iked_childsa *);
int	 pfkey_sa_delete(int, struct iked_childsa *);
int	 pfkey_sa_last_used(int, struct iked_childsa *, uint64_t *);
int	 pfkey_flush(int);
int	 pfkey_socket(void);
void	 pfkey_init(struct iked *, int fd);

/* ca.c */
pid_t	 caproc(struct privsep *, struct privsep_proc *);
int	 ca_setreq(struct iked *, struct iked_sa *, struct iked_static_id *,
	    uint8_t, uint8_t *, size_t, enum privsep_procid);
int	 ca_setcert(struct iked *, struct iked_sahdr *, struct iked_id *,
	    uint8_t, uint8_t *, size_t, enum privsep_procid);
int	 ca_setauth(struct iked *, struct iked_sa *,
	    struct ibuf *, enum privsep_procid);
void	 ca_getkey(struct privsep *, struct iked_id *, enum imsg_type);
int	 ca_privkey_serialize(EVP_PKEY *, struct iked_id *);
int	 ca_pubkey_serialize(EVP_PKEY *, struct iked_id *);
void	 ca_sslinit(void);
void	 ca_sslerror(const char *);
char	*ca_asn1_name(uint8_t *, size_t);
char	*ca_x509_name(void *);
void	*ca_x509_name_parse(char *);

/* timer.c */
void	 timer_set(struct iked *, struct iked_timer *,
	    void (*)(struct iked *, void *), void *);
void	 timer_add(struct iked *, struct iked_timer *, int);
void	 timer_del(struct iked *, struct iked_timer *);

/* proc.c */
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int);
void	 proc_kill(struct privsep *);
void	 proc_listen(struct privsep *, struct privsep_proc *, size_t);
void	 proc_dispatch(int, short event, void *);
pid_t	 proc_run(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, unsigned int,
	    void (*)(struct privsep *, struct privsep_proc *, void *), void *);
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, void *, uint16_t);
int	 imsg_composev_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, const struct iovec *, int);
int	 proc_compose_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, void *, u_int16_t);
int	 proc_compose(struct privsep *, enum privsep_procid,
	    uint16_t, void *, uint16_t);
int	 proc_composev_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, const struct iovec *, int);
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
int	 proc_forward_imsg(struct privsep *, struct imsg *,
	    enum privsep_procid, int);
struct imsgbuf *
	 proc_ibuf(struct privsep *, enum privsep_procid, int);
struct imsgev *
	 proc_iev(struct privsep *, enum privsep_procid, int);

/* util.c */
int	 socket_af(struct sockaddr *, in_port_t);
in_port_t
	 socket_getport(struct sockaddr *);
int	 socket_setport(struct sockaddr *, in_port_t);
int	 socket_getaddr(int, struct sockaddr_storage *);
int	 socket_bypass(int, struct sockaddr *);
int	 udp_bind(struct sockaddr *, in_port_t);
ssize_t	 sendtofrom(int, void *, size_t, int, struct sockaddr *,
	    socklen_t, struct sockaddr *, socklen_t);
ssize_t	 recvfromto(int, void *, size_t, int, struct sockaddr *,
	    socklen_t *, struct sockaddr *, socklen_t *);
const char *
	 print_spi(uint64_t, int);
const char *
	 print_map(unsigned int, struct iked_constmap *);
void	 lc_string(char *);
void	 print_hex(uint8_t *, off_t, size_t);
void	 print_hexval(uint8_t *, off_t, size_t);
const char *
	 print_bits(unsigned short, unsigned char *);
int	 sockaddr_cmp(struct sockaddr *, struct sockaddr *, int);
uint8_t mask2prefixlen(struct sockaddr *);
uint8_t mask2prefixlen6(struct sockaddr *);
struct in6_addr *
	 prefixlen2mask6(uint8_t, uint32_t *);
uint32_t
	 prefixlen2mask(uint8_t);
const char *
	 print_host(struct sockaddr *, char *, size_t);
char	*get_string(uint8_t *, size_t);
const char *
	 print_proto(uint8_t);
int	 expand_string(char *, size_t, const char *, const char *);
uint8_t *string2unicode(const char *, size_t *);
void	 print_debug(const char *, ...)
	    __attribute__((format(printf, 1, 2)));
void	 print_verbose(const char *, ...)
	    __attribute__((format(printf, 1, 2)));

/* imsg_util.c */
struct ibuf *
	 ibuf_new(const void *, size_t);
struct ibuf *
	 ibuf_static(void);
int	 ibuf_cat(struct ibuf *, struct ibuf *);
void	 ibuf_release(struct ibuf *);
size_t	 ibuf_length(struct ibuf *);
int	 ibuf_setsize(struct ibuf *, size_t);
uint8_t *
	 ibuf_data(struct ibuf *);
void	*ibuf_getdata(struct ibuf *, size_t);
struct ibuf *
	 ibuf_get(struct ibuf *, size_t);
struct ibuf *
	 ibuf_dup(struct ibuf *);
struct ibuf *
	 ibuf_random(size_t);
int	 ibuf_prepend(struct ibuf *, void *, size_t);
void	*ibuf_advance(struct ibuf *, size_t);
void	 ibuf_zero(struct ibuf *);

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

/* ocsp.c */
int	 ocsp_connect(struct iked *env);
int	 ocsp_receive_fd(struct iked *, struct imsg *);
int	 ocsp_validate_cert(struct iked *, struct iked_static_id *,
    void *, size_t, struct iked_sahdr, uint8_t);

/* parse.y */
int	 parse_config(const char *, struct iked *);
void	 print_user(struct iked_user *);
void	 print_policy(struct iked_policy *);
size_t	 keylength_xf(unsigned int, unsigned int, unsigned int);
size_t	 noncelength_xf(unsigned int, unsigned int);
int	 cmdline_symset(char *);

#endif /* IKED_H */
@


1.114
log
@Add a NAT-T keepalive timer in case we are behind a NAT gateway.

See RFC 5996, section 2.23, NAT Traversal:
  In the case of a mismatching NAT_DETECTION_DESTINATION_IP hash, it
  means that the system receiving the NAT_DETECTION_DESTINATION_IP
  payload is behind a NAT and that system SHOULD start sending
  keepalive packets as defined in [UDPENCAPS].

With markus@@, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.113 2017/03/27 17:17:49 mikeb Exp $	*/
d781 1
@


1.113
log
@Don't cache the DH group in the policy

When tearing IKE SA down, the DH group referred by it is destroyed,
however it remains cached in the policy.  With the introduction of
IKE SA rekeying we have extended the life of this dangling pointer
by reusing it on new SAs.  So instead of caching the pointer in the
policy we can store the DH group ID and create a DH group on demand
using this parameter if it's specified.

With and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.112 2017/03/27 10:43:53 mikeb Exp $	*/
d379 1
d449 3
@


1.112
log
@Factor out flows into separate configuration messages

We reach an imsg payload limit with just a few traffic selectors
so in order to load more we need to split them up and send separately.

Suggested and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.111 2017/03/27 10:21:19 reyk Exp $	*/
a260 1
	struct group			*pol_peerdh;
d262 1
@


1.111
log
@Add support to reflect the responder IKEv2 COOKIE.

This fixes connecting to Azure VPN and other implementations that
implement the IKEv2 COOKIE mechanism on the responder side.  Azure
decides to send you a responder COOKIE after too many connection
attempts - we have to keep it and reflect it to establish a
connection.  This implementation is only for the initiator (client)
side, we do not support sending COOKIEs on the responder (server) side
yet.

OK patrick@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.110 2017/03/27 10:06:41 reyk Exp $	*/
d669 3
@


1.110
log
@Add support for RFC4754 (ECDSA) and RFC7427 authentication.

These modes provide stronger and more flexible ways for
authentication: while RSA public key auth relies on SHA-1 hashes, the
news modes use SHA2-256 and up to SHA2-512 hashes.

Original diff from markus@@ with patches from mikeb@@ and me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.109 2017/03/13 18:49:20 mikeb Exp $	*/
d505 1
@


1.109
log
@Resolve simultaneous Child SA rekeying

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.108 2017/03/13 18:48:16 mikeb Exp $	*/
d756 1
@


1.108
log
@Resolve simultaneous IKE SA rekeying

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.107 2017/03/13 18:28:02 reyk Exp $	*/
d436 2
a437 1
	uint64_t			 sa_rekeyspi;	/* peerspi for rekey*/
@


1.107
log
@Make sure that proposal contains a DH group when rekeying with PFS enabled

Via markus, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.106 2017/03/13 17:23:45 mikeb Exp $	*/
d434 2
a435 1
	struct iked_sa			*sa_next;	/* IKE SA rekeying */
d770 1
@


1.106
log
@Don't rekey acquired Child SAs

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.105 2017/03/13 15:06:51 patrick Exp $	*/
d764 1
a764 1
	    struct iked_proposals *);
@


1.105
log
@When setting up IPcomp flows for the networks 'A' and 'B' between
gateways 'a' and 'b', we replace the ESP flow "A->B ESP" with an
IPCOMP flow "A->B IPCOMP" and add a matching (transport mode) ESP
flow between the gateways "a->b ESP".  The later is now marked with
flow_ipcomp so it is not translated into "a->b IPCOMP" on rekeying.

When SAs get deleted we do an extra loop to figure out if matching
IPcomp SAs can now be removed, too.  This allows faster expiry of
unused IPcomp SAs.

Disable bytes lifetime for IP compression.

ok markus@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.104 2017/03/13 14:57:55 reyk Exp $	*/
d176 1
@


1.104
log
@Fix and improve the IKE SA rekeying timeout, add a randomized jitter.

Diff from markus@@ with a small tweak from me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.103 2017/03/13 14:33:33 patrick Exp $	*/
d160 1
@


1.103
log
@flow_cmp() must compare the same flow-attributes as the kernel,
otherwise we never can keep the in-daemon and the in-kernel idea
of flows in sync and iked ends up deleting flows that are still
in use.  Make use of flow_cmp() and a new flow_equal() instead
of handcrafting the compare in an if.

ok markus@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.102 2017/02/03 08:23:46 guenther Exp $	*/
d440 3
a442 1
#define IKED_IKE_SA_DELETE_TIMEOUT	 300		/* 5 minutes */
@


1.102
log
@Stop assuming that in_{addr,port}_t are typedefed in <sys/types.h> and
instead pull in <netinet/in.h> or <arpa/inet.h> when those are needed.

ok florian@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.101 2017/01/20 14:10:05 mikeb Exp $	*/
d699 1
@


1.101
log
@Constify the data argument for ibuf_new

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.100 2017/01/09 14:49:21 reyk Exp $	*/
d22 1
@


1.100
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.99 2017/01/03 17:51:38 reyk Exp $	*/
d943 1
a943 1
	 ibuf_new(void *, size_t);
@


1.99
log
@Fix pledge of the ca process by calling the right function on startup.
As a related change, load the local.pub and local.key keys after
privsep and reload them on SIGHUP/reload.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.98 2016/09/04 10:26:02 vgross Exp $	*/
d966 2
a967 1
void	log_verbose(int);
@


1.98
log
@Now that we have IP_SENDSRCADDR, add sendtofrom().

Ok jca@@ and reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.97 2016/09/03 09:20:07 vgross Exp $	*/
d25 2
d673 2
d858 3
@


1.97
log
@Add the missing bits to have NAT on enc(4) support in iked.

Ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.96 2016/06/01 11:16:41 patrick Exp $	*/
d902 2
@


1.96
log
@Implement a second address pool specifically for IPv6, so that
clients can be given an IPv4 and IPv6 address at the same time,
thus enabling dual stack usage.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.95 2015/12/07 12:46:37 reyk Exp $	*/
d143 1
@


1.95
log
@Sync proc.c, use shorter proc_compose[v]()
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.94 2015/11/23 19:28:34 reyk Exp $	*/
d452 3
d458 1
d606 1
d699 1
@


1.94
log
@Replace socket_set_blockmode() and fcntl(fd, F_SETFL, O_NONBLOCK) calls
with the SOCK_NONBLOCK flag to socket() and accept4().

OK claudio@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.93 2015/11/22 13:27:13 reyk Exp $	*/
d873 3
a875 1
	    uint16_t, int, void *, uint16_t);
d877 3
a879 1
	    uint16_t, int, const struct iovec *, int);
@


1.93
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.92 2015/11/21 12:59:24 reyk Exp $	*/
a883 1
void	 socket_set_blockmode(int, enum blockmodes);
@


1.92
log
@Move local logging functions to util.c (which is shared with ikectl),
sync log.c with relayd and httpd - all three daemons are using a copy
of the same file now.  Nevertheless, adding "extern int debug/verbose"
in util.c is not super nice but helps for now.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.91 2015/10/22 15:55:18 reyk Exp $	*/
d945 2
a946 1
void	log_init(int);
d960 4
a963 2
__dead void fatal(const char *);
__dead void fatalx(const char *);
@


1.91
log
@iked hereby pledges that it will run with restricted system
operations.  This adds pledge(2) too all processes, including the iked
parent process; the existing privsep design has been improved for
better pledgeability.  There haven't been any serious problems as it
was already sane (eg. by receiving the PFKEYv2 and UDP sockets via fd
passing).  The control socket moved to an independent process to
remove some abilities from the cert process.

Committed in agreement with many but nobody was brave enough to OK it.

Better testing will happen with having it in the tree.
"It's the truth" deraadt@@
"Let's see what happens" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.90 2015/10/19 11:25:35 reyk Exp $	*/
d917 4
d945 14
a958 8
void	 log_init(int);
void	 log_verbose(int);
void	 log_warn(const char *, ...) __attribute__((format(printf, 1, 2)));
void	 log_warnx(const char *, ...) __attribute__((format(printf, 1, 2)));
void	 log_info(const char *, ...) __attribute__((format(printf, 1, 2)));
void	 log_debug(const char *, ...) __attribute__((format(printf, 1, 2)));
void	 print_debug(const char *, ...) __attribute__((format(printf, 1, 2)));
void	 print_verbose(const char *, ...) __attribute__((format(printf, 1, 2)));
@


1.90
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.89 2015/10/01 10:59:23 reyk Exp $	*/
d615 1
@


1.89
log
@Fix interoperability with Apple iOS9: If we don't get a (valid)
CERTREQ but a CERT, respond with a local CERT that was selected based
on our own policy instead of leaving it out.  This seems to be valid
with the RFC that makes the CERTREQ optional and allows to ignore it
or to apply an own policy.

OK mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.88 2015/08/21 11:59:27 reyk Exp $	*/
a739 3

/* ikev1.c */
pid_t	 ikev1(struct privsep *, struct privsep_proc *);
@


1.88
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.87 2015/08/19 14:12:43 reyk Exp $	*/
d325 9
a333 8
#define IKED_REQ_CERT		0x01	/* get local certificate (if required) */
#define IKED_REQ_CERTVALID	0x02	/* validated the peer cert */
#define IKED_REQ_AUTH		0x04	/* AUTH payload */
#define IKED_REQ_AUTHVALID	0x08	/* AUTH payload has been verified */
#define IKED_REQ_SA		0x10	/* SA available */
#define IKED_REQ_EAPVALID	0x20	/* EAP payload has been verified */
#define IKED_REQ_CHILDSA	0x40	/* Child SA initiated */
#define IKED_REQ_INF		0x80	/* Informational exchange initiated */
d336 2
a337 1
    "\20\01CERT\02CERTVALID\03AUTH\04AUTHVALID\05SA\06EAP"
d843 1
a843 1
int	 ca_setreq(struct iked *, struct iked_sahdr *, struct iked_static_id *,
@


1.87
log
@spacing (no binary change, verified with checksums)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.86 2015/07/07 19:13:31 markus Exp $	*/
d36 8
a43 8
	u_int64_t	 ike_ispi;		/* Initiator cookie */
	u_int64_t	 ike_rspi;		/* Responder cookie */
	u_int8_t	 ike_nextpayload;	/* Next payload type */
	u_int8_t	 ike_version;		/* Major/Minor version number */
	u_int8_t	 ike_exchange;		/* Exchange type */
	u_int8_t	 ike_flags;		/* Message options */
	u_int32_t	 ike_msgid;		/* Message identifier */
	u_int32_t	 ike_length;		/* Total message length */
d91 1
a91 1
	u_int8_t		 flags;
d112 3
a114 3
	u_int64_t	 spi;
	u_int8_t	 spi_size;
	u_int8_t	 spi_protoid;
d118 2
a119 2
	u_int8_t			 prop_id;
	u_int8_t			 prop_protoid;
d125 1
a125 1
	u_int				 prop_nxforms;
d134 1
a134 1
	u_int8_t			 addr_mask;
d142 1
a142 1
	u_int				 flow_dir;	/* in/out */
d144 1
a144 1
	u_int				 flow_loaded;	/* pfkey done */
d146 3
a148 3
	u_int8_t			 flow_saproto;
	u_int8_t			 flow_ipproto;
	u_int8_t			 flow_type;
d161 2
a162 2
	u_int8_t			 csa_saproto;	/* IPSec protocol */
	u_int				 csa_dir;	/* in/out */
d164 7
a170 7
	u_int64_t			 csa_peerspi;	/* peer relation */
	u_int8_t			 csa_loaded;	/* pfkey done */
	u_int8_t			 csa_rekey;	/* will be deleted */
	u_int8_t			 csa_allocated;	/* from the kernel */
	u_int8_t			 csa_persistent;/* do not rekey */
	u_int8_t			 csa_esn;	/* use ESN */
	u_int8_t			 csa_transport;	/* transport mode */
d175 1
a175 1
	u_int16_t			 csa_encrid;	/* encryption xform id */
d178 1
a178 1
	u_int16_t			 csa_integrid;	/* auth xform id */
d187 1
a187 1
	u_int				 csa_children;	/* IPCOMP children */
d197 4
a200 4
	u_int8_t	id_type;
	u_int8_t	id_length;
	u_int8_t	id_offset;
	u_int8_t	id_data[IKED_ID_SIZE];
d204 4
a207 4
	u_int8_t	auth_method;
	u_int8_t	auth_eap;			/* optional EAP */
	u_int8_t	auth_length;			/* zero if EAP */
	u_int8_t	auth_data[IKED_PSK_SIZE];
d211 2
a212 2
	u_int8_t			 cfg_action;
	u_int16_t			 cfg_type;
d221 2
a222 2
	u_int64_t			 lt_bytes;
	u_int64_t			 lt_seconds;
d226 1
a226 1
	u_int				 pol_id;
d237 1
a237 1
	u_int8_t			 pol_flags;
d248 1
a248 1
	u_int8_t			 pol_certreqtype;
d251 2
a252 2
	u_int8_t			 pol_saproto;
	u_int				 pol_ipproto;
d264 1
a264 1
	u_int				 pol_tap;
d273 1
a273 1
	u_int				 pol_ncfg;
d275 1
a275 1
	u_int32_t			 pol_rekey;	/* ike SA lifetime */
d285 2
a286 2
	u_int8_t	 hash_type;	/* PRF or INTEGR */
	u_int16_t	 hash_id;	/* IKE PRF/INTEGR hash id */
d297 2
a298 2
	u_int8_t	 encr_type;	/* ENCR */
	u_int16_t	 encr_id;	/* IKE ENCR hash id */
d309 1
a309 1
	u_int8_t	 dsa_method;	/* AUTH method */
d320 2
a321 2
	u_int8_t	 id_type;
	u_int8_t	 id_offset;
d340 3
a342 3
	u_int64_t			 sh_ispi;	/* Initiator SPI */
	u_int64_t			 sh_rspi;	/* Responder SPI */
	u_int				 sh_initiator;	/* Is initiator? */
d357 1
a357 1
	u_int32_t			 sa_msgid;	/* Last request rcvd */
d359 1
a359 1
	u_int32_t			 sa_reqid;	/* Next request sent */
d373 3
a375 3
	u_int				 sa_stateflags;
	u_int				 sa_stateinit;	/* SA_INIT */
	u_int				 sa_statevalid;	/* IKE_AUTH */
d427 1
a427 1
	u_int64_t			 sa_rekeyspi;	/* peerspi for rekey*/
d429 3
a431 3
	u_int8_t			 sa_ipcomp;	/* IPcomp transform */
	u_int16_t			 sa_cpi_out;	/* IPcomp outgoing */
	u_int16_t			 sa_cpi_in;	/* IPcomp incoming*/
d478 2
a479 2
	u_int32_t		 msg_msgid;
	u_int8_t		 msg_exchange;
d492 1
a492 1
	u_int16_t		 msg_attrlength;
d526 3
a528 3
	u_int				 ps_instances[PROC_MAX];
	u_int				 ps_ninstances;
	u_int				 ps_instance;
d552 1
a552 1
	u_int			 p_instance;
d568 3
a570 3
	u_int32_t			 sc_opts;
	u_int8_t			 sc_passive;
	u_int8_t			 sc_decoupled;
d584 1
a584 1
	u_int8_t			 sc_certreqtype;
d626 1
a626 1
u_int64_t
d629 1
a629 1
	 config_findtransform(struct iked_proposals *, u_int8_t, u_int);
d632 3
a634 2
	 config_add_proposal(struct iked_proposals *, u_int, u_int);
void	 config_free_proposals(struct iked_proposals *, u_int);
d640 6
a645 6
	    u_int, u_int, u_int, u_int);
int	 config_setcoupled(struct iked *, u_int);
int	 config_getcoupled(struct iked *, u_int);
int	 config_setmode(struct iked *, u_int);
int	 config_getmode(struct iked *, u_int);
int	 config_setreset(struct iked *, u_int, enum privsep_procid);
d672 1
a672 1
void	 sa_stateflags(struct iked_sa *, u_int);
d675 1
a675 1
	 sa_new(struct iked *, u_int64_t, u_int64_t, u_int,
d683 1
a683 1
	 childsa_lookup(struct iked_sa *, u_int64_t, u_int8_t);
d686 1
a686 1
	 sa_lookup(struct iked *, u_int64_t, u_int64_t, u_int);
d697 1
a697 1
	 hash_new(u_int8_t, u_int16_t);
d708 1
a708 1
	 cipher_new(u_int8_t, u_int16_t, u_int16_t);
d725 1
a725 1
	 dsa_new(u_int16_t, struct iked_hash *, int);
d727 1
a727 1
	 dsa_sign_new(u_int16_t, struct iked_hash *);
d729 1
a729 1
	 dsa_verify_new(u_int16_t, struct iked_hash *);
d731 1
a731 1
	 dsa_setkey(struct iked_dsa *, void *, size_t, u_int8_t);
d751 1
a751 1
	    u_int8_t, u_int64_t, u_int64_t *, int);
d756 1
a756 1
ssize_t	 ikev2_psk(struct iked_sa *, u_int8_t *, size_t, u_int8_t **);
d758 1
a758 1
	    void *, size_t, u_int);
d761 1
a761 1
	    u_int8_t, u_int8_t, int);
d764 1
a764 1
	    u_int32_t, u_int8_t, u_int8_t, u_int8_t);
d769 1
a769 1
	    u_int8_t);
d785 1
a785 1
u_int32_t
d792 1
a792 1
	    struct iked_auth *, u_int8_t *, size_t, struct ibuf *);
d797 1
a797 1
	    struct ibuf **, u_int8_t, u_int8_t, int);
d830 2
a831 2
int	 pfkey_block(int, int, u_int);
int	 pfkey_sa_init(int, struct iked_childsa *, u_int32_t *);
d834 1
a834 1
int	 pfkey_sa_last_used(int, struct iked_childsa *, u_int64_t *);
d842 1
a842 1
	    u_int8_t, u_int8_t *, size_t, enum privsep_procid);
d844 1
a844 1
	    u_int8_t, u_int8_t *, size_t, enum privsep_procid);
d849 1
a849 1
char	*ca_asn1_name(u_int8_t *, size_t);
d860 1
a860 1
void	 proc_init(struct privsep *, struct privsep_proc *, u_int);
d865 1
a865 1
	    struct privsep_proc *, u_int,
d868 3
a870 3
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);
int	 imsg_composev_event(struct imsgev *, u_int16_t, u_int32_t,
d873 1
a873 1
	    u_int16_t, int, void *, u_int16_t);
d875 1
a875 1
	    u_int16_t, int, const struct iovec *, int);
d895 1
a895 1
	 print_spi(u_int64_t, int);
d897 1
a897 1
	 print_map(u_int, struct iked_constmap *);
d899 2
a900 2
void	 print_hex(u_int8_t *, off_t, size_t);
void	 print_hexval(u_int8_t *, off_t, size_t);
d902 1
a902 1
	 print_bits(u_short, u_char *);
d904 2
a905 2
u_int8_t mask2prefixlen(struct sockaddr *);
u_int8_t mask2prefixlen6(struct sockaddr *);
d907 3
a909 3
	 prefixlen2mask6(u_int8_t, u_int32_t *);
u_int32_t
	 prefixlen2mask(u_int8_t);
d912 1
a912 1
char	*get_string(u_int8_t *, size_t);
d914 1
a914 1
	 print_proto(u_int8_t);
d916 1
a916 1
u_int8_t *string2unicode(const char *, size_t *);
d927 1
a927 1
u_int8_t *
d956 1
a956 1
    void *, size_t, struct iked_sahdr, u_int8_t);
d962 2
a963 2
size_t	 keylength_xf(u_int, u_int, u_int);
size_t	 noncelength_xf(u_int, u_int);
@


1.86
log
@repair policy-ikesa-linking by replacing the broken RB_TREE w/TAILQ
(e.g. the policy might be used-after-free on 'ikectl reconfig')
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.85 2015/06/11 18:49:09 reyk Exp $	*/
d178 1
a178 1
	u_int16_t		 	 csa_integrid;	/* auth xform id */
@


1.85
log
@Use "compliant" header guards by avoiding the reserved '_' namespace.

Pointed out by Markus Elfring

OK mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.84 2015/03/26 19:52:35 markus Exp $	*/
d218 1
a218 1
RB_HEAD(iked_sapeers, iked_sa);
a365 1
	struct iked_addr		 sa_polpeer;
d445 1
a445 1
	RB_ENTRY(iked_sa)		 sa_peer_entry;
d679 1
a679 1
	    struct sockaddr_storage *, int);
a685 2
struct iked_sa *
	 sa_peer_lookup(struct iked_policy *, struct sockaddr_storage *);
a688 1
RB_PROTOTYPE(iked_sapeers, iked_sa, sa_peer_entry, sa_peer_cmp);
@


1.84
log
@initial support for RFC 7427 signatures, so we are no longer
restricted to SHA1 for RSA signatures. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.83 2015/01/16 06:39:58 deraadt Exp $	*/
d28 2
a29 2
#ifndef _IKED_H
#define _IKED_H
d969 1
a969 1
#endif /* _IKED_H */
@


1.83
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.82 2014/08/18 09:43:02 reyk Exp $	*/
d410 1
d736 1
a736 1
int	 dsa_init(struct iked_dsa *);
@


1.82
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but iked will ignore it
now instead of terminating the process.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.81 2014/05/09 06:37:24 markus Exp $	*/
d22 1
d503 1
a503 1
	char			 usr_name[MAXLOGNAME];
d566 1
a566 1
	char				 sc_conffile[MAXPATHLEN];
@


1.81
log
@get rid of redundant {csa,flow}_{src,dst}id pointers, so we don't need
to update it on rekey (fixes use-after-free); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.80 2014/05/09 06:29:46 markus Exp $	*/
d535 1
@


1.80
log
@replace iked_transform pointer with xform id, since target of pointer
might be freed (e.g. on ike sa rekey); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.79 2014/05/08 13:11:16 blambert Exp $	*/
a148 3
	struct iked_id			*flow_srcid;
	struct iked_id			*flow_dstid;

a178 3
	struct iked_id			*csa_srcid;
	struct iked_id			*csa_dstid;

d414 2
@


1.79
log
@match iked proc.c infrastructure with proc.c

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.78 2014/05/07 12:57:13 markus Exp $	*/
d177 1
a177 1
	struct iked_transform		*csa_encrxf;	/* encryption xform */
d180 1
a180 1
	struct iked_transform		*csa_integrxf;	/* auth xform */
@


1.78
log
@make authentication work with X509 certificates that don't have a
subject-altname, i.e. support IKEV2_ID_ASN1_DN correctly;
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.77 2014/05/06 14:10:53 markus Exp $	*/
d83 2
d86 1
d527 1
@


1.77
log
@change the create-child-sa responder code, so it does not store any
state in the ikesa structure. this way we can initiate a create-child-sa
and process requests for the peer at the same time. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.76 2014/05/06 10:24:22 markus Exp $	*/
d851 1
@


1.76
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.75 2014/05/06 07:24:37 markus Exp $	*/
d347 10
d388 8
a395 7
	struct ibuf			*sa_inonce;	/* Ni */
	struct ibuf			*sa_rnonce;	/* Nr */

	struct group			*sa_dhgroup;	/* DH group */
	struct ibuf			*sa_dhiexchange;
	struct ibuf			*sa_dhrexchange;
	struct ibuf			*sa_dhpeer;	/* pointer to i or r */
d618 1
d746 1
a746 1
int	 ikev2_sa_negotiate(struct iked_sa *, struct iked_proposals *,
@


1.75
log
@initial support for PFS; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.74 2014/05/06 07:08:10 markus Exp $	*/
d277 2
a278 1
	struct iked_lifetime		 pol_lifetime;
d415 1
d423 1
a423 1
#define IKED_IKE_SA_REKEY_TIMEOUT	 300		/* 5 minutes */
d426 2
d758 1
a758 1
void	 ikev2_acquire_sa(struct iked *, struct iked_flow *);
d760 2
a761 2
void	 ikev2_rekey_sa(struct iked *, struct iked_spi *);
void	 ikev2_drop_sa(struct iked *, struct iked_spi *);
@


1.74
log
@retire IKED_REQ_DELETE and fix delete parsing; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.73 2014/04/29 11:51:13 markus Exp $	*/
d414 2
d611 1
a611 1
	 config_findtransform(struct iked_proposals *, u_int8_t);
@


1.73
log
@make sure the state machine only advances if the AUTH payload has
been verified; with & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.72 2014/04/22 12:00:03 reyk Exp $	*/
a333 1
#define IKED_REQ_DELETE		0x100	/* Rekeying continuation */
@


1.72
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.71 2014/04/10 16:08:02 reyk Exp $	*/
d327 1
a327 1
#define IKED_REQ_VALID		0x02	/* validate the peer cert */
d329 6
a334 4
#define IKED_REQ_SA		0x08	/* SA available */
#define IKED_REQ_CHILDSA	0x10	/* Child SA initiated */
#define IKED_REQ_INF		0x20	/* Informational exchange initiated */
#define IKED_REQ_DELETE		0x40	/* Rekeying continuation */
d337 1
a337 1
    "\10\01CERT\02VALID\03AUTH\04SA"
@


1.71
log
@Add validation routines to ikev2_pld.c: For each payload type overall
header structure is checked for sanity before copying the header.
Always pass down the number of remaining bytes in the payload or
substructure so we can always ensure to not go beyond actual data.
Also remove the quick parsing step as it does not provide a real
benefit anymore.

From Hans-Joerg Hoexer

ok mikeb@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.70 2014/02/21 20:52:38 markus Exp $	*/
d53 1
d491 4
d496 4
a499 2
	int				 ps_pipes[PROC_MAX][PROC_MAX];
	struct imsgev			 ps_ievs[PROC_MAX];
d503 1
d507 4
d531 2
d842 1
a842 1
void	 proc_config(struct privsep *, struct privsep_proc *, u_int);
d846 1
a846 1
	    void (*)(struct privsep *, void *), void *);
d852 1
a852 1
int	 proc_compose_imsg(struct iked *, enum privsep_procid,
d854 1
a854 1
int	 proc_composev_imsg(struct iked *, enum privsep_procid,
d856 6
a861 2
int	 proc_forward_imsg(struct iked *, struct imsg *,
	    enum privsep_procid);
@


1.70
log
@support rekeying for IPCOMP; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.69 2014/02/17 15:53:46 markus Exp $	*/
d437 1
a437 1
	off_t			 msg_offset;
d787 1
a787 1
	    struct iked_message *, off_t);
@


1.69
log
@interpret 'config address net/prefix' as a pool of addresses and
randomly choose the address for CFG_REQUEST. this address will be used
to replace 0.0.0.0/32 in the specified flow. e.g.
> ikev2 passive esp from 192.168.1.0/24 to 0.0.0.0 \
>     config address 192.168.10.200/24
will assign an address between 192.168.10.200 and 192.168.10.254
and replace 0.0.0.0 with this address.
ok mikeb@@ on older version of this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.68 2014/02/17 15:07:23 markus Exp $	*/
d187 3
d850 1
@


1.68
log
@basic OCSP support. enable with 'set ocsp "http://10.0.0.10:8888/"'
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.67 2014/02/14 10:23:43 benno Exp $	*/
d425 3
d430 1
d561 2
d654 1
@


1.67
log
@remove unused function that distracts from cleaning up the imsg_flush() mess
ok krw, florian, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.66 2014/02/14 09:00:03 markus Exp $	*/
d514 6
d554 3
d615 2
d902 6
@


1.66
log
@initial support for IPComp
still experimental and rekeying needs some work; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.65 2014/01/24 07:31:25 markus Exp $	*/
a822 1
void	 proc_flush_imsg(struct iked *, enum privsep_procid);
@


1.65
log
@enable format-string checks for log_*(); ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.64 2014/01/24 05:58:52 mikeb Exp $	*/
d168 1
d242 1
d408 4
@


1.64
log
@use a bit saner timer api
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.63 2014/01/22 09:25:41 markus Exp $	*/
d878 6
a883 6
void	 log_warn(const char *, ...);
void	 log_warnx(const char *, ...);
void	 log_info(const char *, ...);
void	 log_debug(const char *, ...);
void	 print_debug(const char *, ...);
void	 print_verbose(const char *, ...);
@


1.63
log
@implement DPD similar to isakmpd, but only send DPD-messages 'on-demand'
(less aggressive, only if the ESP-SAs are actually used);
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.62 2013/12/09 15:22:32 markus Exp $	*/
d793 1
a793 1
void	 timer_initialize(struct iked *, struct iked_timer *,
d795 2
a796 3
int	 timer_initialized(struct iked *, struct iked_timer *);
void	 timer_register(struct iked *, struct iked_timer *, int);
void	 timer_deregister(struct iked *, struct iked_timer *);
@


1.62
log
@distingush between sa_msgid not set and 0; otherwise we start
dropping messages if we usually are the initiator and the peer
initiates rekeying first.  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.61 2013/12/03 13:55:39 markus Exp $	*/
d409 1
d436 1
d774 1
@


1.61
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.60 2013/11/28 20:26:04 markus Exp $	*/
d341 3
a343 2
	u_int32_t			 sa_msgid;	/* Last resp rcvd */
	u_int32_t			 sa_reqid;	/* Next req sent */
@


1.60
log
@document sa_msgid & sa_reqid; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.59 2013/11/28 20:21:17 markus Exp $	*/
d820 1
a820 1
	 socket_getport(struct sockaddr_storage *);
d843 1
a843 1
	 print_host(struct sockaddr_storage *, char *, size_t);
@


1.59
log
@support raw pubkey authentication w/o x509 certificates;
mostly by Michael Cardell Widerkrantz, reyk@@ and mikeb@@; ok mike@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.58 2013/11/21 17:46:17 millert Exp $	*/
d341 2
a342 2
	u_int32_t			 sa_msgid;
	u_int32_t			 sa_reqid;
@


1.58
log
@Make the bit string u_char * in print_bits().  In practice we
shouldn't have chars > 127 in these but it is better not to assume
this.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.57 2013/11/14 12:38:20 markus Exp $	*/
d243 2
@


1.57
log
@pass caller to ca_sslerror for better error messages; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.56 2013/01/08 10:38:19 reyk Exp $	*/
d832 1
a832 1
	 print_bits(u_short, char *);
@


1.56
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.55 2012/11/29 15:08:08 reyk Exp $	*/
d782 1
a782 1
void	 ca_sslerror(void);
@


1.55
log
@Prevent VPN traffic leakages in dual-stack hosts/networks.
See http://tools.ietf.org/html/draft-gont-opsec-vpn-leakages.

We forcibly block IPv6 traffic by loading a "flow esp out from ::/0 to
::/0 type deny" unless the protocol is used in any of the flows.  Note
that this will block any IPv6 traffic, superseding routes and pf, on
the host by default when iked is running with IPv4 flows only.  This
auto-blocking feature can be disabled by specifying the "-6" command
line flag to iked.

Thanks to Fernando Gont.

ok mikeb@@
@
text
@d1 1
a1 2
/*	$OpenBSD: iked.h,v 1.54 2012/10/22 10:25:17 reyk Exp $	*/
/*	$vantronix: iked.h,v 1.61 2010/06/03 07:57:33 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.54
log
@Fix NAT-T support in iked, both on the initiator and the responder
side.  Also add a new command line option -t to optionally enforce
NAT-T with UDP encapsulation on port 4500.

Tested by mikeb@@ and me
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.53 2012/09/18 12:07:59 reyk Exp $	*/
d144 1
d766 1
@


1.53
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.52 2012/07/02 13:03:24 mikeb Exp $	*/
d529 2
a530 2
	struct iked_socket		*sc_sock4;
	struct iked_socket		*sc_sock6;
d692 2
a693 1
ssize_t	 ikev2_nat_detection(struct iked_message *, void *, size_t, u_int);
d741 1
a741 1
	 ikev2_msg_getsocket(struct iked *, int);
@


1.52
log
@Don't close IKE SA immediately after creating a new one when rekeying.
Instead set a timeout that will shut it down in case we don't get an SA
delete notification.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.51 2012/06/29 15:05:49 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.51
log
@Add missing ESN bits
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.50 2012/06/26 11:00:28 mikeb Exp $	*/
d404 3
a462 1

@


1.50
log
@compare exchange types as well when looking up a message;
proceed with a response only when the appropriate request
is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.49 2012/06/22 16:28:20 mikeb Exp $	*/
d167 1
@


1.49
log
@Add initial support for retransmition timeouts and response retries.
This should still be considered an experimental work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.48 2012/06/22 16:06:31 mikeb Exp $	*/
d438 1
d747 1
a747 1
	    struct iked_message *);
@


1.48
log
@decouple timer initialization from timer_register
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.47 2012/05/30 16:17:20 mikeb Exp $	*/
d328 2
d403 6
d437 2
d451 8
d712 2
d716 1
a716 1
	 ikev2_msg_id(struct iked *, struct iked_sa *, int);
d737 10
@


1.47
log
@more timer changes
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.46 2012/05/30 09:18:13 mikeb Exp $	*/
d751 4
a754 2
void	 timer_register(struct iked *, struct iked_timer *,
	    void (*)(struct iked *, void *), void *, int);
@


1.46
log
@pass a file descriptor in the msg_fd instead of a function argument
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.45 2012/05/29 15:09:12 mikeb Exp $	*/
d751 1
a751 1
void	 timer_register(struct iked_timer *, struct iked *,
d753 1
@


1.45
log
@improve timer framework; will be needed soon
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.44 2012/05/23 14:54:04 mikeb Exp $	*/
d705 1
a705 1
int	 ikev2_msg_send(struct iked *, int, struct iked_message *);
@


1.44
log
@factor out proposal matching code from ikev2_sa_negotiate and eliminate
the protoid argument as a first step towards successful ah negotiation;
make code a bit more readable while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.43 2012/05/08 15:37:09 mikeb Exp $	*/
d100 7
d510 4
d658 1
a658 1
int	 ikev2_init_ike_sa(struct iked *, struct iked_policy *);
d751 2
a752 3
void	 timer_register_initiator(struct iked *,
	    int (*)(struct iked *, struct iked_policy *));
void	 timer_unregister_initiator(struct iked *);
@


1.43
log
@When setting up NAT-T notify payloads, make sure to supply an
actual source address so that a valid hash can be generated.
Fixes a bug introduces some time ago that prevented iked from
initiating if NAT-T wasn't disabled (via -T) and local address
wasn't specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.42 2012/04/05 17:31:36 deraadt Exp $	*/
d649 1
a649 1
	    struct iked_proposals *, u_int8_t);
@


1.42
log
@rate-limit accepting of new connections while we are experiencing
fd exhaustion.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.41 2011/05/09 11:15:18 reyk Exp $	*/
d770 1
@


1.41
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.40 2011/05/05 12:59:31 reyk Exp $	*/
d79 1
@


1.40
log
@Small tweak - add direct pointer to env instead of using an indirect one.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.39 2011/05/05 12:55:52 reyk Exp $	*/
d744 5
a748 8
void	 init_procs(struct privsep *, struct privsep_proc *, u_int);
void	 kill_procs(struct privsep *);
void	 init_pipes(struct privsep *);
void	 config_pipes(struct privsep *, struct privsep_proc *, u_int);
void	 config_procs(struct privsep *, struct privsep_proc *, u_int);
void	 purge_config(struct privsep *, u_int8_t);
void	 dispatch_proc(int, short event, void *);
pid_t	 run_proc(struct privsep *, struct privsep_proc *,
d751 12
a797 12
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);
int	 imsg_composev_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, const struct iovec *, int);
int	 imsg_compose_proc(struct iked *, enum privsep_procid,
	    u_int16_t, int, void *, u_int16_t);
int	 imsg_composev_proc(struct iked *, enum privsep_procid,
	    u_int16_t, int, const struct iovec *, int);
int	 imsg_forward_proc(struct iked *, struct imsg *,
	    enum privsep_procid);
void	 imsg_flush_proc(struct iked *, enum privsep_procid);
@


1.39
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.38 2011/05/05 12:17:10 reyk Exp $	*/
d470 1
@


1.38
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.37 2011/05/02 12:39:18 mikeb Exp $	*/
d442 30
a482 6
	int				 sc_pipes[PROC_MAX][PROC_MAX];
	struct imsgev			 sc_ievs[PROC_MAX];
	const char			*sc_title[PROC_MAX];
	pid_t				 sc_pid[PROC_MAX];
	struct passwd			*sc_pw;

d501 1
a501 18
	struct control_sock		 sc_csock;

	/* Event and signal handlers */
	struct event			 sc_evsigint;
	struct event			 sc_evsigterm;
	struct event			 sc_evsigchld;
	struct event			 sc_evsighup;
	struct event			 sc_evsigpipe;
};

struct privsep_proc {
	const char		*title;
	enum privsep_procid	 id;
	int			(*cb)(int, struct privsep_proc *,
				    struct imsg *);
	pid_t			(*init)(struct iked *, struct privsep_proc *);
	const char		*chroot;
	struct iked		*env;
d515 1
a515 1
int	 control_init(struct iked *, struct control_sock *);
d640 1
a640 1
pid_t	 ikev1(struct iked *, struct privsep_proc *);
d643 1
a643 1
pid_t	 ikev2(struct iked *, struct privsep_proc *);
d725 1
a725 1
pid_t	 caproc(struct iked *, struct privsep_proc *);
d743 6
a748 6
void	 init_procs(struct iked *, struct privsep_proc *, u_int);
void	 kill_procs(struct iked *);
void	 init_pipes(struct iked *);
void	 config_pipes(struct iked *, struct privsep_proc *, u_int);
void	 config_procs(struct iked *, struct privsep_proc *, u_int);
void	 purge_config(struct iked *, u_int8_t);
d750 3
a752 2
pid_t	 run_proc(struct iked *, struct privsep_proc *, struct privsep_proc *,
	    u_int, void (*)(struct iked *, void *), void *);
@


1.37
log
@store the peer address as it was specified in the policy in the
tree that is used to figure out whether the policy is active or
not.  makes active sa lookup via policy work for nat traversal.
problem was reported and fix was tested by sthen, ok sthen, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.36 2011/04/18 08:45:43 reyk Exp $	*/
d93 1
a93 1
enum iked_procid iked_process;
d487 1
a487 1
struct iked_proc {
d489 4
a492 3
	enum iked_procid	 id;
	int			(*cb)(int, struct iked_proc *, struct imsg *);
	pid_t			(*init)(struct iked *, struct iked_proc *);
d538 1
a538 1
int	 config_setreset(struct iked *, u_int, enum iked_procid);
d541 1
a541 1
	    enum iked_procid);
d544 1
a544 1
	    enum iked_procid);
d547 1
a547 1
int	 config_setpfkey(struct iked *, enum iked_procid);
d549 1
a549 1
int	 config_setuser(struct iked *, struct iked_user *, enum iked_procid);
d551 1
a551 1
int	 config_setcompile(struct iked *, enum iked_procid);
d633 1
a633 1
pid_t	 ikev1(struct iked *, struct iked_proc *);
d636 1
a636 1
pid_t	 ikev2(struct iked *, struct iked_proc *);
d718 1
a718 1
pid_t	 caproc(struct iked *, struct iked_proc *);
d720 1
a720 1
	    u_int8_t, u_int8_t *, size_t, enum iked_procid);
d722 1
a722 1
	    u_int8_t, u_int8_t *, size_t, enum iked_procid);
d724 1
a724 1
	    struct ibuf *, enum iked_procid);
d736 1
a736 1
void	 init_procs(struct iked *, struct iked_proc *, u_int);
d739 2
a740 2
void	 config_pipes(struct iked *, struct iked_proc *, u_int);
void	 config_procs(struct iked *, struct iked_proc *, u_int);
d743 1
a743 1
pid_t	 run_proc(struct iked *, struct iked_proc *, struct iked_proc *,
d785 1
a785 1
int	 imsg_compose_proc(struct iked *, enum iked_procid,
d787 1
a787 1
int	 imsg_composev_proc(struct iked *, enum iked_procid,
d790 2
a791 2
	    enum iked_procid);
void	 imsg_flush_proc(struct iked *, enum iked_procid);
@


1.36
log
@When the kernel wants to acquire an SA for an unknown flow, lookup a
matching policy and init a new IKE SA.  This adds support for "acquire mode"
from static flows.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.35 2011/04/15 13:10:49 reyk Exp $	*/
d336 1
d570 1
a570 1
	    struct sockaddr_storage *);
@


1.35
log
@remove unused function ikev2_flows_delete()
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.34 2011/01/26 16:59:23 mikeb Exp $	*/
d147 2
a148 2
RB_HEAD(iked_activeflows, iked_flow);
TAILQ_HEAD(iked_flows, iked_flow);
d390 1
a390 1
	struct iked_flows		 sa_flows;	/* IPSec flows */
d463 1
a463 1
	struct iked_activeflows		 sc_activeflows;
d567 1
d584 1
a584 1
RB_PROTOTYPE(iked_activeflows, iked_flow, flow_node, flow_cmp);
@


1.34
log
@get rid of acquire flows completely, as they tend to pass traffic
when there's no sa established (as pointed out by reyk).  instead
use require mode feature to send acquires from the kernel.  this
allows us to get rid of the code that changes flow mode to acquire
and keep all installed flows in the tree and save up on some code
that deals with renegotiation.  also several entities were renamed
(iked_acqflows -> iked_activeflows, iked_ipsecsas -> iked_activesas,
ikev2_acquire -> ikev2_acquire_sa).   ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.33 2011/01/21 17:01:33 reyk Exp $	*/
a641 1
int	 ikev2_flows_delete(struct iked *, struct iked_sa *, u_int8_t);
@


1.33
log
@don't use memcmp on comparing two iked_addrs but IKED_ADDR_EQ.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.32 2011/01/21 16:51:38 reyk Exp $	*/
a132 1
	u_int				 flow_acquire;
d144 1
a144 1
	RB_ENTRY(iked_flow)		 flow_acq_entry;
d147 1
a147 1
RB_HEAD(iked_acqflows, iked_flow);
d177 1
a177 1
	RB_ENTRY(iked_childsa)		 csa_ipsec_entry;
d180 1
a180 1
RB_HEAD(iked_ipsecsas, iked_childsa);
d462 2
a463 2
	struct iked_ipsecsas		 sc_ipsecsas;
	struct iked_acqflows		 sc_acqflows;
d582 2
a583 2
RB_PROTOTYPE(iked_ipsecsas, iked_childsa, csa_ipsec_entry, childsa_cmp);
RB_PROTOTYPE(iked_acqflows, iked_flow, flow_acq_entry, acquire_flow_cmp);
d642 1
a642 1
int	 ikev2_flows_delete(struct iked *, struct iked_sa *, u_int8_t, int);
d660 1
a660 1
void	 ikev2_acquire(struct iked *, struct iked_flow *);
@


1.32
log
@- Fix traffic selector configuration that it is always "from $localnet
to $peernet" and not depending on the initiator/responder mode.
- Remove the flow hash calculated but not used anymore.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.31 2011/01/21 11:56:00 reyk Exp $	*/
d64 5
@


1.31
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.30 2011/01/21 11:37:02 reyk Exp $	*/
a386 1
	u_int8_t			 sa_flowhash[20]; /* SHA1 */
@


1.30
log
@split pfkey initialization into a privileged and unprivileged part to
prevent a possible crash.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.29 2011/01/17 18:49:35 mikeb Exp $	*/
d65 5
d213 8
d226 2
d231 1
d235 1
a235 3
	struct sockaddr_storage		 pol_peer;
	u_int8_t			 pol_peermask;
	int				 pol_peernet;
d237 1
d239 1
a239 5
	struct sockaddr_storage		 pol_local;
	u_int8_t			 pol_localmask;
	int				 pol_localnet;

	struct iked_static_id		 pol_peerid;
d260 1
a260 1
	RB_ENTRY(iked_policy)		 pol_entry;
d262 1
a262 1
RB_HEAD(iked_policies, iked_policy);
d546 2
d552 3
a575 1
RB_PROTOTYPE(iked_policies, iked_policy, pol_entry, policy_cmp);
@


1.29
log
@Add initial acquire mode support and use it whenever Windows peers decide
to drop Child SA based on the inactivity timer.  In this case we instruct
the kernel to send us an acquire message upon receiving a packet for those
hosts and initiate a Child SA creation exchange ourselves.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.28 2011/01/17 17:16:43 mikeb Exp $	*/
d532 1
a532 2
int	 config_getpfkey(struct iked *, struct imsg *,
	    void (*)(int, short, void *));
d694 2
a695 2
int	 pfkey_init(struct iked *);
void	 pfkey_dispatch(int, short, void *);
@


1.28
log
@move mask2prefixlen functions to the util module;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.27 2011/01/12 14:35:45 mikeb Exp $	*/
d123 1
d135 1
d138 1
d153 1
a153 1
	struct ibuf			*csa_encrkey;	/* encryption key */	
d449 1
d566 1
d625 1
a625 1
int	 ikev2_flows_delete(struct iked *, struct iked_sa *, u_int8_t);
d643 1
@


1.27
log
@postpone processing of pfkey messages received in pfkey_reply instead of
just dropping them;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.26 2011/01/12 14:26:26 mikeb Exp $	*/
d740 2
@


1.26
log
@decouple flow deletion from the ikev2_childsa_delete;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.25 2010/12/22 17:53:54 reyk Exp $	*/
d689 1
a689 1
int	 pfkey_init(void);
@


1.25
log
@move and rename util.c:print_id() to ikev2.c:ikev2_print_id() because
it is too specific to be in util.c.  This will allow to link util.c
into ikectl later without all the other dependencies of pritn_id().
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.24 2010/12/22 17:43:10 reyk Exp $	*/
a483 4
/* flags for ikev2_childsa_delete */
#define IKED_DEL_FLOWS		 0x01
#define IKED_DEL_NOTLOADED	 0x02

d620 2
@


1.24
log
@split util.c into two files: imsg_util.c for ibuf/imsg stuff and util for
everything else.  we might need to include util.c in ikectl later.

sure mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.23 2010/12/22 16:22:27 mikeb Exp $	*/
d643 1
a748 1
int	 print_id(struct iked_id *, char *, size_t);
@


1.23
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.22 2010/12/01 12:01:25 reyk Exp $	*/
a723 12
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);
int	 imsg_composev_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, const struct iovec *, int);
int	 imsg_compose_proc(struct iked *, enum iked_procid,
	    u_int16_t, int, void *, u_int16_t);
int	 imsg_composev_proc(struct iked *, enum iked_procid,
	    u_int16_t, int, const struct iovec *, int);
int	 imsg_forward_proc(struct iked *, struct imsg *,
	    enum iked_procid);
void	 imsg_flush_proc(struct iked *, enum iked_procid);
d754 13
@


1.22
log
@Clarify the internal ibuf API: rename ibuf_copy() to ibuf_get() because
it returns a new buffer from the internal read offset like stdio get
functions do and not the same buffer when it is called multiple times.
Also rename the old ibuf_get() to ibuf_getdata() because it returns
a "special" data type and it matches the stdio get* conventions.

pointed out by mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.21 2010/11/17 16:43:45 ckuethe Exp $	*/
d99 2
a100 2
	struct iked_spi			 prop_localspi;	
	struct iked_spi			 prop_peerspi;	
a121 1
	u_int64_t			 flow_peerspi;	/* peer relation */
a122 1
	u_int				 flow_rekey;	/* will be deleted */
d146 1
d163 3
d168 1
d196 5
d242 2
d296 2
d300 1
a300 1
    "\10\01CERT\02VALID\03AUTH\04SA\05CHILDSA"
d311 1
d445 1
d451 1
d484 4
d512 1
a512 2
void	 config_free_flows(struct iked *, struct iked_flows *,
	    struct iked_spi *);
d532 2
a533 1
int	 config_getpfkey(struct iked *, struct imsg *);
d552 2
d565 1
d621 1
d640 3
d691 1
@


1.21
log
@Allow the -D command line flag to actually define macros.
ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.20 2010/09/22 09:12:18 mikeb Exp $	*/
d749 1
a749 1
void	*ibuf_get(struct ibuf *, size_t);
d751 1
a751 1
	 ibuf_copy(struct ibuf *, size_t);
@


1.20
log
@support INVALID_KE_PAYLOAD notification sent by the responder in case
the initiator chose wrong D-H group.  in this case we throw away our
SA and start over with a proper group.

makes iked work as an initiator with strongswan/charon without any
specific "ikesa" (phase 1) configuration.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.19 2010/09/09 13:06:46 mikeb Exp $	*/
d778 1
@


1.19
log
@- allow esp proposals without integrity and ah proposals without
  encryption;

- add additional nonce length field, use that for the ciphers that
  require additional keying material;

- setup right flow direction depending on the mode: fixes up iked
  working as an initiator against charon.

tested by me and jsg.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.18 2010/07/01 02:15:08 reyk Exp $	*/
d211 1
d595 1
@


1.18
log
@Add support for the tap extension (ikev2 ... tap "enc1") that will
tell the kernel to send all IPsec traffic for derived SAs to the
specified enc(4) interface instead of enc0.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.17 2010/06/29 21:04:42 reyk Exp $	*/
d775 1
@


1.17
log
@add code to lookup the RSA public keys in /etc/iked/pubkeys/ as an
alternative to X.509 CA verification.  this will be needed to support public
key authentication like isakmpd does;  a few bits are still missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.16 2010/06/27 05:49:05 reyk Exp $	*/
d222 1
@


1.16
log
@When a peer requests a certificate from the local gateway, we first
lookup a cert from /etc/iked/certs/ that is signed by a requested CA.
As a second step we also compare the subjectAltName of any found
certificate now to match the local srcid; this allows to have multiple
certs for the same CA but different srcids in the certs/ directory but
enforces that the subjectAltName has to be set correctly.

requested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.15 2010/06/27 01:03:22 reyk Exp $	*/
d717 1
@


1.15
log
@Instead of modifying and fiddling with the IKE SA in the payload
parsing routines directly, first parse the message and save the parsed
elements in the temporary message struct before validating the
information and taking any other actions on the actual SA.  This needs
more testing, but is the cleaner and better approach.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.13 2010/06/26 19:48:04 reyk Exp $	*/
d665 2
a666 2
int	 ca_setreq(struct iked *, struct iked_sahdr *, u_int8_t,
	    u_int8_t *, size_t, enum iked_procid);
@


1.14
log
@revert the files that have been accidentally committed with my
previous parse.y change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.12 2010/06/26 18:32:34 reyk Exp $	*/
a379 1
	struct iked_message	*msg_decrypted;
d381 2
d393 3
@


1.13
log
@mixing any (AF_UNSPEC) with AF_INET/INET6 is not an address family mismatch
@
text
@a391 2
	struct iked_id		 msg_id;
	struct iked_id		 msg_cert;
@


1.12
log
@Include the Id type in the generated SA tag that is passed to the
kernel, just like isakmpd does it.  In difference to isakmpd, the Id
type is printed in capital letters, eg. FQDN/foo.example.com, because
it is using the existing print_map() API.  For consistency, rename a
few Id types in grammar and code from the RFC-names to the
OpenBSD-style names; including RFC822_ADDR to UFQDN, IPV4_ADDR to just
IPV4, DER_ASN1_DN to ASN1_DN etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.11 2010/06/14 23:14:09 reyk Exp $	*/
d392 2
@


1.11
log
@Initiator mode with certificates;  needs more work but works.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.10 2010/06/14 21:12:56 reyk Exp $	*/
d172 1
d275 1
d725 1
a725 1
int	 print_id(struct iked_id *, off_t, char *, size_t);
@


1.10
log
@Initial support for initiator mode which allows to run iked as a
"client" or to configure iked to iked (OpenBSD to OpenBSD) IKEv2 VPNs.

It currently only supports psk (pre-shared keys) and no certificates,
doesn't do any rekeying or SA timeouts, and needs more cleanup.  So it
is not quite production ready yet - but ready for simple tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.9 2010/06/14 14:03:15 reyk Exp $	*/
d309 2
a310 1
	u_int				 sa_staterequire;
@


1.9
log
@NAT detection again: make it work in initiator and responder mode
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.8 2010/06/14 11:33:55 reyk Exp $	*/
d145 3
a147 2
	u_int				 csa_loaded;	/* pfkey done */
	u_int				 csa_rekey;	/* will be deleted */
d325 1
d371 2
@


1.8
log
@restructure code a bit to move closer to initiator mode:
- split responder/initiator- specific code into different functions and use
shared functions for common stuff.
- first parse the received message and store information in the temporary
message struct instead of modifying the ike sa in the parsing code directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.7 2010/06/14 08:55:59 reyk Exp $	*/
d591 1
a591 2
ssize_t	 ikev2_nat_detection(struct iked_message *, void *, size_t,
	    u_int, int);
@


1.7
log
@cleanup messages and parsed information correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.6 2010/06/14 08:10:32 reyk Exp $	*/
d383 2
d584 1
@


1.6
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.5 2010/06/11 12:47:18 reyk Exp $	*/
d608 1
a718 1
void	 message_cleanup(struct iked *, struct iked_message *);
@


1.5
log
@add some infrastructure to support timers and initiator mode later.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.4 2010/06/10 14:08:37 reyk Exp $	*/
d295 4
d425 3
d627 3
d664 1
a664 1
	    void (*)(struct iked *, struct iked_policy *));
@


1.4
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.3 2010/06/10 12:06:34 reyk Exp $	*/
d651 5
@


1.3
log
@Add another tree to lookup policy SAs by peer address.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.2 2010/06/10 08:29:47 reyk Exp $	*/
d400 2
d478 4
d630 1
@


1.2
log
@i don't like splitting source code in too many source files but ikev2.c
has grown too large, so split it in 3 files and rename a few functions
to organize the code a bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d189 2
d230 2
d351 1
d502 2
d508 2
d514 1
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 15
d556 12
d570 20
a589 1
int	 ikev2_message_authsign(struct iked *, struct iked_sa *,
d591 9
d601 7
a607 3
	 ikev2_prfplus(struct iked_hash *, struct ibuf *, struct ibuf *,
	    size_t);
ssize_t	 ikev2_psk(struct iked_sa *, u_int8_t *, size_t, u_int8_t **);
@

