head	1.58;
access;
symbols
	OPENBSD_6_2:1.58.0.2
	OPENBSD_6_2_BASE:1.58
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.58
date	2017.04.18.02.29.56;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	0b2VaK4OUJUaWS29;

1.57
date	2017.03.27.10.29.02;	author reyk;	state Exp;
branches;
next	1.56;
commitid	yfhMvs0gHdZ86p06;

1.56
date	2017.03.27.10.24.36;	author reyk;	state Exp;
branches;
next	1.55;
commitid	QtsiC6NORfrFiVfm;

1.55
date	2017.03.13.17.41.14;	author reyk;	state Exp;
branches;
next	1.54;
commitid	9gRqWsDzrTZXxOb2;

1.54
date	2017.03.13.15.06.51;	author patrick;	state Exp;
branches;
next	1.53;
commitid	EkthUtnilpgGayvp;

1.53
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.52;
commitid	rmbXKt3efXwOBuCw;

1.52
date	2016.09.03.09.20.07;	author vgross;	state Exp;
branches;
next	1.51;
commitid	Bw4TFBm7VKjvvnRJ;

1.51
date	2016.03.07.19.33.26;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	dH2OOqaSrGDRNHR8;

1.50
date	2015.12.10.17.23.34;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	TlswZf4jypqHHZMZ;

1.49
date	2015.12.09.21.41.49;	author naddy;	state Exp;
branches;
next	1.48;
commitid	CLwtYUTkBZ3FXV1w;

1.48
date	2015.12.02.12.43.59;	author naddy;	state Exp;
branches;
next	1.47;
commitid	duHJNnO9Vx1nKUKx;

1.47
date	2015.11.04.12.40.49;	author mikeb;	state Exp;
branches;
next	1.46;
commitid	B4ca1ecJQ735kuxU;

1.46
date	2015.10.15.18.40.38;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	rQFz7wM8cPpo2dCG;

1.45
date	2015.08.26.02.09.29;	author jsg;	state Exp;
branches;
next	1.44;
commitid	tSkWgrY90o6CyoRw;

1.44
date	2015.08.21.11.59.28;	author reyk;	state Exp;
branches;
next	1.43;
commitid	CNs9dXqQUQ09vB19;

1.43
date	2015.07.17.14.48.17;	author mikeb;	state Exp;
branches;
next	1.42;
commitid	byZMOqtU8kVVyjig;

1.42
date	2015.06.05.13.35.08;	author vgross;	state Exp;
branches;
next	1.41;
commitid	uODdRvDa4EYEKCCz;

1.41
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	Uu5nFG3wCl0LACBb;

1.40
date	2014.10.29.06.26.39;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	Tez37f8p0vZ5t0Gz;

1.39
date	2014.10.18.03.11.54;	author doug;	state Exp;
branches;
next	1.38;
commitid	gVLMZuvMMidArDJn;

1.38
date	2014.07.09.12.05.01;	author markus;	state Exp;
branches;
next	1.37;
commitid	vVxwcvD37B30artE;

1.37
date	2014.05.09.06.37.24;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.09.06.29.46;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.07.13.09.43;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.05.18.50.36;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.05.16.13.12;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.05.08.23.57;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.25.09.41.21;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.21.20.52.38;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.14.09.00.03;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.22.09.25.41;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.14.13.35.19;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.14.12.44.51;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2012.11.29.15.08.08;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.23.14.40.14;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.29.15.05.49;	author mikeb;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.24.00.40.25;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.26.16.59.24;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.21.11.37.02;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.17.18.49.35;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.12.14.35.45;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.22.17.53.54;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.23.11.42.36;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.01.02.15.08;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.26.18.32.34;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.14.21.12.56;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.12.04.21;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.04.09.51.45;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.58
log
@use freezero()
@
text
@/*	$OpenBSD: pfkey.c,v 1.57 2017/03/27 10:29:02 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004, 2005 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2003, 2004 Markus Friedl <markus@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/uio.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <event.h>

#include "iked.h"
#include "ikev2.h"

#define ROUNDUP(x) (((x) + (PFKEYV2_CHUNK - 1)) & ~(PFKEYV2_CHUNK - 1))
#define IOV_CNT 20

#define PFKEYV2_CHUNK sizeof(uint64_t)
#define PFKEY_REPLY_TIMEOUT 1000

static uint32_t sadb_msg_seq = 0;
static unsigned int sadb_decoupled = 0;
static unsigned int sadb_ipv6refcnt = 0;

static int pfkey_blockipv6 = 0;
static struct event pfkey_timer_ev;
static struct timeval pfkey_timer_tv;

struct pfkey_message {
	SIMPLEQ_ENTRY(pfkey_message)
			 pm_entry;
	uint8_t		*pm_data;
	ssize_t		 pm_length;
};
SIMPLEQ_HEAD(, pfkey_message) pfkey_retry, pfkey_postponed =
    SIMPLEQ_HEAD_INITIALIZER(pfkey_postponed);

struct pfkey_constmap {
	uint8_t		 pfkey_id;
	unsigned int	 pfkey_ikeid;
	unsigned int	 pfkey_fixedkey;
};

static const struct pfkey_constmap pfkey_encr[] = {
	{ SADB_EALG_3DESCBC,	IKEV2_XFORMENCR_3DES },
	{ SADB_X_EALG_CAST,	IKEV2_XFORMENCR_CAST },
	{ SADB_X_EALG_BLF,	IKEV2_XFORMENCR_BLOWFISH },
	{ SADB_EALG_NULL,	IKEV2_XFORMENCR_NULL },
	{ SADB_X_EALG_AES,	IKEV2_XFORMENCR_AES_CBC },
	{ SADB_X_EALG_AESCTR,	IKEV2_XFORMENCR_AES_CTR },
	{ SADB_X_EALG_AESGCM16,	IKEV2_XFORMENCR_AES_GCM_16 },
	{ SADB_X_EALG_AESGMAC,	IKEV2_XFORMENCR_NULL_AES_GMAC },
	{ SADB_X_EALG_CHACHA20POLY1305, IKEV2_XFORMENCR_CHACHA20_POLY1305 },
	{ 0 }
};

static const struct pfkey_constmap pfkey_integr[] = {
	{ SADB_AALG_MD5HMAC,	IKEV2_XFORMAUTH_HMAC_MD5_96 },
	{ SADB_AALG_SHA1HMAC,	IKEV2_XFORMAUTH_HMAC_SHA1_96 },
	{ SADB_X_AALG_SHA2_256,	IKEV2_XFORMAUTH_HMAC_SHA2_256_128 },
	{ SADB_X_AALG_SHA2_384,	IKEV2_XFORMAUTH_HMAC_SHA2_384_192 },
	{ SADB_X_AALG_SHA2_512,	IKEV2_XFORMAUTH_HMAC_SHA2_512_256 },
	{ 0 }
};

static const struct pfkey_constmap pfkey_satype[] = {
	{ SADB_SATYPE_AH,	IKEV2_SAPROTO_AH },
	{ SADB_SATYPE_ESP,	IKEV2_SAPROTO_ESP },
	{ SADB_X_SATYPE_IPCOMP,	IKEV2_SAPROTO_IPCOMP },
	{ 0 }
};

int	pfkey_map(const struct pfkey_constmap *, uint16_t, uint8_t *);
int	pfkey_flow(int, uint8_t, uint8_t, struct iked_flow *);
int	pfkey_sa(int, uint8_t, uint8_t, struct iked_childsa *);
int	pfkey_sa_getspi(int, uint8_t, struct iked_childsa *, uint32_t *);
int	pfkey_sagroup(int, uint8_t, uint8_t,
	    struct iked_childsa *, struct iked_childsa *);
int	pfkey_write(int, struct sadb_msg *, struct iovec *, int,
	    uint8_t **, ssize_t *);
int	pfkey_reply(int, uint8_t **, ssize_t *);
void	pfkey_dispatch(int, short, void *);

struct sadb_ident *
	pfkey_id2ident(struct iked_id *, unsigned int);
void	*pfkey_find_ext(uint8_t *, ssize_t, int);

void	pfkey_timer_cb(int, short, void *);
int	pfkey_process(struct iked *, struct pfkey_message *);

int
pfkey_couple(int sd, struct iked_sas *sas, int couple)
{
	struct iked_sa		*sa;
	struct iked_flow	*flow;
	struct iked_childsa	*csa;
	const char		*mode[] = { "coupled", "decoupled" };

	/* Socket is not ready */
	if (sd == -1)
		return (-1);

	if (sadb_decoupled == !couple)
		return (0);

	log_debug("%s: kernel %s -> %s", __func__,
	    mode[sadb_decoupled], mode[!sadb_decoupled]);

	/* Allow writes to the PF_KEY socket */
	sadb_decoupled = 0;

	RB_FOREACH(sa, iked_sas, sas) {
		TAILQ_FOREACH(csa, &sa->sa_childsas, csa_entry) {
			if (!csa->csa_loaded && couple)
				(void)pfkey_sa_add(sd, csa, NULL);
			else if (csa->csa_loaded && !couple)
				(void)pfkey_sa_delete(sd, csa);
		}
		TAILQ_FOREACH(flow, &sa->sa_flows, flow_entry) {
			if (!flow->flow_loaded && couple)
				(void)pfkey_flow_add(sd, flow);
			else if (flow->flow_loaded && !couple)
				(void)pfkey_flow_delete(sd, flow);
		}
	}

	sadb_decoupled = !couple;

	return (0);
}

int
pfkey_map(const struct pfkey_constmap *map, uint16_t alg, uint8_t *pfkalg)
{
	int	 i;

	for (i = 0; map[i].pfkey_id != 0; i++)
		if (map[i].pfkey_ikeid == alg) {
			*pfkalg = map[i].pfkey_id;
			return (0);
		}
	return (-1);
}

int
pfkey_flow(int sd, uint8_t satype, uint8_t action, struct iked_flow *flow)
{
	struct sadb_msg		 smsg;
	struct iked_addr	*flow_src, *flow_dst;
	struct sadb_address	 sa_src, sa_dst, sa_local, sa_peer, sa_smask,
				 sa_dmask;
	struct sadb_protocol	 sa_flowtype, sa_protocol;
	struct sadb_ident	*sa_srcid, *sa_dstid;
	struct sockaddr_storage	 ssrc, sdst, slocal, speer, smask, dmask;
	struct iovec		 iov[IOV_CNT];
	int			 iov_cnt, ret = -1;

	sa_srcid = sa_dstid = NULL;

	flow_src = &flow->flow_src;
	flow_dst = &flow->flow_dst;

	if (flow->flow_prenat.addr_af == flow_src->addr_af) {
		switch (flow->flow_type) {
		case SADB_X_FLOW_TYPE_USE:
			flow_dst = &flow->flow_prenat;
			break;
		case SADB_X_FLOW_TYPE_REQUIRE:
			flow_src = &flow->flow_prenat;
			break;
		case 0:
			if (flow->flow_dir == IPSP_DIRECTION_IN)
				flow_dst = &flow->flow_prenat;
			else
				flow_src = &flow->flow_prenat;
		}
	}

	bzero(&ssrc, sizeof(ssrc));
	bzero(&smask, sizeof(smask));
	memcpy(&ssrc, &flow_src->addr, sizeof(ssrc));
	memcpy(&smask, &flow_src->addr, sizeof(smask));
	socket_af((struct sockaddr *)&ssrc, flow_src->addr_port);
	socket_af((struct sockaddr *)&smask, flow_src->addr_port ?
	    0xffff : 0);

	switch (flow_src->addr_af) {
	case AF_INET:
		((struct sockaddr_in *)&smask)->sin_addr.s_addr =
		    prefixlen2mask(flow_src->addr_net ?
		    flow_src->addr_mask : 32);
		break;
	case AF_INET6:
		prefixlen2mask6(flow_src->addr_net ?
		    flow_src->addr_mask : 128,
		    (uint32_t *)((struct sockaddr_in6 *)
		    &smask)->sin6_addr.s6_addr);
		break;
	default:
		log_warnx("%s: unsupported address family %d",
		    __func__, flow_src->addr_af);
		return (-1);
	}
	smask.ss_len = ssrc.ss_len;

	bzero(&sdst, sizeof(sdst));
	bzero(&dmask, sizeof(dmask));
	memcpy(&sdst, &flow_dst->addr, sizeof(sdst));
	memcpy(&dmask, &flow_dst->addr, sizeof(dmask));
	socket_af((struct sockaddr *)&sdst, flow_dst->addr_port);
	socket_af((struct sockaddr *)&dmask, flow_dst->addr_port ?
	    0xffff : 0);

	switch (flow_dst->addr_af) {
	case AF_INET:
		((struct sockaddr_in *)&dmask)->sin_addr.s_addr =
		    prefixlen2mask(flow_dst->addr_net ?
		    flow_dst->addr_mask : 32);
		break;
	case AF_INET6:
		prefixlen2mask6(flow_dst->addr_net ?
		    flow_dst->addr_mask : 128,
		    (uint32_t *)((struct sockaddr_in6 *)
		    &dmask)->sin6_addr.s6_addr);
		break;
	default:
		log_warnx("%s: unsupported address family %d",
		    __func__, flow_dst->addr_af);
		return (-1);
	}
	dmask.ss_len = sdst.ss_len;

	bzero(&slocal, sizeof(slocal));
	bzero(&speer, sizeof(speer));
	if (action != SADB_X_DELFLOW && flow->flow_local != NULL) {
		memcpy(&slocal, &flow->flow_local->addr, sizeof(slocal));
		socket_af((struct sockaddr *)&slocal, 0);

		memcpy(&speer, &flow->flow_peer->addr, sizeof(speer));
		socket_af((struct sockaddr *)&speer, 0);
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = action;
	smsg.sadb_msg_satype = satype;

	bzero(&sa_flowtype, sizeof(sa_flowtype));
	sa_flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
	sa_flowtype.sadb_protocol_len = sizeof(sa_flowtype) / 8;
	sa_flowtype.sadb_protocol_direction = flow->flow_dir;
	sa_flowtype.sadb_protocol_proto =
	    flow->flow_type ? flow->flow_type :
	    (flow->flow_dir == IPSP_DIRECTION_IN ?
	    SADB_X_FLOW_TYPE_USE : SADB_X_FLOW_TYPE_REQUIRE);

	bzero(&sa_protocol, sizeof(sa_protocol));
	sa_protocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	sa_protocol.sadb_protocol_len = sizeof(sa_protocol) / 8;
	sa_protocol.sadb_protocol_direction = 0;
	sa_protocol.sadb_protocol_proto = flow->flow_ipproto;

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;

	bzero(&sa_smask, sizeof(sa_smask));
	sa_smask.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
	sa_smask.sadb_address_len =
	    (sizeof(sa_smask) + ROUNDUP(smask.ss_len)) / 8;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_exttype = SADB_X_EXT_DST_FLOW;
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;

	bzero(&sa_dmask, sizeof(sa_dmask));
	sa_dmask.sadb_address_exttype = SADB_X_EXT_DST_MASK;
	sa_dmask.sadb_address_len =
	    (sizeof(sa_dmask) + ROUNDUP(dmask.ss_len)) / 8;

	if (action != SADB_X_DELFLOW && flow->flow_local != NULL) {
		/* local address */
		bzero(&sa_local, sizeof(sa_local));
		sa_local.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
		sa_local.sadb_address_len =
		    (sizeof(sa_local) + ROUNDUP(slocal.ss_len)) / 8;

		/* peer address */
		bzero(&sa_peer, sizeof(sa_peer));
		sa_peer.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
		sa_peer.sadb_address_len =
		    (sizeof(sa_peer) + ROUNDUP(speer.ss_len)) / 8;

		/* local id */
		sa_srcid = pfkey_id2ident(IKESA_SRCID(flow->flow_ikesa),
		    SADB_EXT_IDENTITY_SRC);

		/* peer id */
		sa_dstid = pfkey_id2ident(IKESA_DSTID(flow->flow_ikesa),
		    SADB_EXT_IDENTITY_DST);
	}

	iov_cnt = 0;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* add flow type */
	iov[iov_cnt].iov_base = &sa_flowtype;
	iov[iov_cnt].iov_len = sizeof(sa_flowtype);
	smsg.sadb_msg_len += sa_flowtype.sadb_protocol_len;
	iov_cnt++;

	if (action != SADB_X_DELFLOW && flow->flow_local != NULL) {
#if 0
		/* local ip */
		iov[iov_cnt].iov_base = &sa_local;
		iov[iov_cnt].iov_len = sizeof(sa_local);
		iov_cnt++;
		iov[iov_cnt].iov_base = &slocal;
		iov[iov_cnt].iov_len = ROUNDUP(slocal.ss_len);
		smsg.sadb_msg_len += sa_local.sadb_address_len;
		iov_cnt++;
#endif

		/* remote peer */
		iov[iov_cnt].iov_base = &sa_peer;
		iov[iov_cnt].iov_len = sizeof(sa_peer);
		iov_cnt++;
		iov[iov_cnt].iov_base = &speer;
		iov[iov_cnt].iov_len = ROUNDUP(speer.ss_len);
		smsg.sadb_msg_len += sa_peer.sadb_address_len;
		iov_cnt++;
	}

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	/* src mask */
	iov[iov_cnt].iov_base = &sa_smask;
	iov[iov_cnt].iov_len = sizeof(sa_smask);
	iov_cnt++;
	iov[iov_cnt].iov_base = &smask;
	iov[iov_cnt].iov_len = ROUNDUP(smask.ss_len);
	smsg.sadb_msg_len += sa_smask.sadb_address_len;
	iov_cnt++;

	/* dest addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	/* dst mask */
	iov[iov_cnt].iov_base = &sa_dmask;
	iov[iov_cnt].iov_len = sizeof(sa_dmask);
	iov_cnt++;
	iov[iov_cnt].iov_base = &dmask;
	iov[iov_cnt].iov_len = ROUNDUP(dmask.ss_len);
	smsg.sadb_msg_len += sa_dmask.sadb_address_len;
	iov_cnt++;

	/* add protocol */
	iov[iov_cnt].iov_base = &sa_protocol;
	iov[iov_cnt].iov_len = sizeof(sa_protocol);
	smsg.sadb_msg_len += sa_protocol.sadb_protocol_len;
	iov_cnt++;

	if (sa_srcid) {
		/* src identity */
		iov[iov_cnt].iov_base = sa_srcid;
		iov[iov_cnt].iov_len = sa_srcid->sadb_ident_len * 8;
		smsg.sadb_msg_len += sa_srcid->sadb_ident_len;
		iov_cnt++;
	}
	if (sa_dstid) {
		/* dst identity */
		iov[iov_cnt].iov_base = sa_dstid;
		iov[iov_cnt].iov_len = sa_dstid->sadb_ident_len * 8;
		smsg.sadb_msg_len += sa_dstid->sadb_ident_len;
		iov_cnt++;
	}

	ret = pfkey_write(sd, &smsg, iov, iov_cnt, NULL, NULL);

	free(sa_srcid);
	free(sa_dstid);

	return (ret);
}

int
pfkey_sa(int sd, uint8_t satype, uint8_t action, struct iked_childsa *sa)
{
	struct sadb_msg		 smsg;
	struct sadb_sa		 sadb;
	struct sadb_address	 sa_src, sa_dst;
	struct sadb_key		 sa_authkey, sa_enckey;
	struct sadb_lifetime	 sa_ltime_hard, sa_ltime_soft;
	struct sadb_x_udpencap	 udpencap;
	struct sadb_x_tag	 sa_tag;
	char			*tag = NULL;
	struct sadb_x_tap	 sa_tap;
	struct sockaddr_storage	 ssrc, sdst;
	struct sadb_ident	*sa_srcid, *sa_dstid;
	struct iked_lifetime	*lt;
	struct iked_policy	*pol;
	struct iovec		 iov[IOV_CNT];
	uint32_t		 jitter;
	int			 iov_cnt;
	int			 ret;

	sa_srcid = sa_dstid = NULL;

	if (sa->csa_ikesa == NULL || sa->csa_ikesa->sa_policy == NULL) {
		log_warn("%s: invalid SA and policy", __func__);
		return (-1);
	}
	pol = sa->csa_ikesa->sa_policy;
	lt = &pol->pol_lifetime;

	bzero(&ssrc, sizeof(ssrc));
	memcpy(&ssrc, &sa->csa_local->addr, sizeof(ssrc));
	if (socket_af((struct sockaddr *)&ssrc, 0) == -1) {
		log_warn("%s: invalid address", __func__);
		return (-1);
	}

	bzero(&sdst, sizeof(sdst));
	memcpy(&sdst, &sa->csa_peer->addr, sizeof(sdst));
	if (socket_af((struct sockaddr *)&sdst, 0) == -1) {
		log_warn("%s: invalid address", __func__);
		return (-1);
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = action;
	smsg.sadb_msg_satype = satype;

	bzero(&sadb, sizeof(sadb));
	sadb.sadb_sa_len = sizeof(sadb) / 8;
	sadb.sadb_sa_exttype = SADB_EXT_SA;
	sadb.sadb_sa_spi = htonl(sa->csa_spi.spi);
	sadb.sadb_sa_state = SADB_SASTATE_MATURE;
	sadb.sadb_sa_replay = 64;

	if (!sa->csa_transport)
		sadb.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;

	if (sa->csa_esn)
		sadb.sadb_sa_flags |= SADB_X_SAFLAGS_ESN;

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;
	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;

	bzero(&sa_authkey, sizeof(sa_authkey));
	bzero(&sa_enckey, sizeof(sa_enckey));
	bzero(&udpencap, sizeof udpencap);
	bzero(&sa_ltime_hard, sizeof(sa_ltime_hard));
	bzero(&sa_ltime_soft, sizeof(sa_ltime_soft));

	if (action == SADB_DELETE)
		goto send;

	if (satype == SADB_SATYPE_ESP &&
	    sa->csa_ikesa->sa_udpencap && sa->csa_ikesa->sa_natt) {
		sadb.sadb_sa_flags |= SADB_X_SAFLAGS_UDPENCAP;
		udpencap.sadb_x_udpencap_exttype = SADB_X_EXT_UDPENCAP;
		udpencap.sadb_x_udpencap_len = sizeof(udpencap) / 8;
		udpencap.sadb_x_udpencap_port =
		    sa->csa_ikesa->sa_peer.addr_port;

		log_debug("%s: udpencap port %d", __func__,
		    ntohs(udpencap.sadb_x_udpencap_port));
	}

	if ((action == SADB_ADD || action == SADB_UPDATE) &&
	    !sa->csa_persistent && (lt->lt_bytes || lt->lt_seconds)) {
		sa_ltime_hard.sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
		sa_ltime_hard.sadb_lifetime_len = sizeof(sa_ltime_hard) / 8;
		sa_ltime_hard.sadb_lifetime_bytes = lt->lt_bytes;
		sa_ltime_hard.sadb_lifetime_addtime = lt->lt_seconds;

		/* double the lifetime for ipcomp; disable byte lifetime */
		if (satype == SADB_X_SATYPE_IPCOMP) {
			sa_ltime_hard.sadb_lifetime_addtime *= 2;
			sa_ltime_hard.sadb_lifetime_bytes = 0;
		}

		sa_ltime_soft.sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
		sa_ltime_soft.sadb_lifetime_len = sizeof(sa_ltime_soft) / 8;
		/* set randomly to 85-95% */
		jitter = 850 + arc4random_uniform(100);
		sa_ltime_soft.sadb_lifetime_bytes =
		    (sa_ltime_hard.sadb_lifetime_bytes * jitter) / 1000;
		sa_ltime_soft.sadb_lifetime_addtime =
		    (sa_ltime_hard.sadb_lifetime_addtime * jitter) / 1000;
	}

	/* XXX handle NULL encryption or NULL auth or combined encr/auth */
	if (action == SADB_ADD &&
	    !ibuf_length(sa->csa_integrkey) && !ibuf_length(sa->csa_encrkey) &&
	    satype != SADB_X_SATYPE_IPCOMP && satype != SADB_X_SATYPE_IPIP) {
		log_warnx("%s: no key specified", __func__);
		return (-1);
	}

	if (sa->csa_integrid)
		if (pfkey_map(pfkey_integr,
		    sa->csa_integrid, &sadb.sadb_sa_auth) == -1) {
			log_warnx("%s: unsupported integrity algorithm %s",
			    __func__, print_map(sa->csa_integrid,
			    ikev2_xformauth_map));
			return (-1);
		}

	if (sa->csa_encrid)
		if (pfkey_map(pfkey_encr,
		    sa->csa_encrid, &sadb.sadb_sa_encrypt) == -1) {
			log_warnx("%s: unsupported encryption algorithm %s",
			    __func__, print_map(sa->csa_encrid,
			    ikev2_xformencr_map));
			return (-1);
		}

	if (ibuf_length(sa->csa_integrkey)) {
		sa_authkey.sadb_key_len = (sizeof(sa_authkey) +
		    ((ibuf_size(sa->csa_integrkey) + 7) / 8) * 8) / 8;
		sa_authkey.sadb_key_exttype = SADB_EXT_KEY_AUTH;
		sa_authkey.sadb_key_bits =
		    8 * ibuf_size(sa->csa_integrkey);
	}

	if (ibuf_length(sa->csa_encrkey)) {
		sa_enckey.sadb_key_len = (sizeof(sa_enckey) +
		    ((ibuf_size(sa->csa_encrkey) + 7) / 8) * 8) / 8;
		sa_enckey.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
		sa_enckey.sadb_key_bits =
		    8 * ibuf_size(sa->csa_encrkey);
	}

	/* we only support deflate */
	if (satype == SADB_X_SATYPE_IPCOMP)
		sadb.sadb_sa_encrypt = SADB_X_CALG_DEFLATE;

	/* Note that we need to swap the IDs for incoming SAs (SADB_UPDATE) */
	if (action != SADB_UPDATE) {
		sa_srcid = pfkey_id2ident(
		    IKESA_SRCID(sa->csa_ikesa), SADB_EXT_IDENTITY_SRC);
		sa_dstid = pfkey_id2ident(
		    IKESA_DSTID(sa->csa_ikesa), SADB_EXT_IDENTITY_DST);
	} else {
		sa_srcid = pfkey_id2ident(
		    IKESA_DSTID(sa->csa_ikesa), SADB_EXT_IDENTITY_SRC);
		sa_dstid = pfkey_id2ident(
		    IKESA_SRCID(sa->csa_ikesa), SADB_EXT_IDENTITY_DST);
	}

	tag = sa->csa_ikesa->sa_tag;
	if (tag != NULL && *tag != '\0') {
		bzero(&sa_tag, sizeof(sa_tag));
		sa_tag.sadb_x_tag_exttype = SADB_X_EXT_TAG;
		sa_tag.sadb_x_tag_len =
		    (ROUNDUP(strlen(tag) + 1) + sizeof(sa_tag)) / 8;
		sa_tag.sadb_x_tag_taglen = strlen(tag) + 1;
	} else
		tag = NULL;

	if (pol->pol_tap != 0) {
		bzero(&sa_tap, sizeof(sa_tap));
		sa_tap.sadb_x_tap_exttype = SADB_X_EXT_TAP;
		sa_tap.sadb_x_tap_len = sizeof(sa_tap) / 8;
		sa_tap.sadb_x_tap_unit = pol->pol_tap;
	}

 send:
	iov_cnt = 0;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* sa */
	iov[iov_cnt].iov_base = &sadb;
	iov[iov_cnt].iov_len = sizeof(sadb);
	smsg.sadb_msg_len += sadb.sadb_sa_len;
	iov_cnt++;

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	/* dst addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	if (sa_ltime_soft.sadb_lifetime_len) {
		/* soft lifetime */
		iov[iov_cnt].iov_base = &sa_ltime_soft;
		iov[iov_cnt].iov_len = sizeof(sa_ltime_soft);
		smsg.sadb_msg_len += sa_ltime_soft.sadb_lifetime_len;
		iov_cnt++;
	}

	if (sa_ltime_hard.sadb_lifetime_len) {
		/* hard lifetime */
		iov[iov_cnt].iov_base = &sa_ltime_hard;
		iov[iov_cnt].iov_len = sizeof(sa_ltime_hard);
		smsg.sadb_msg_len += sa_ltime_hard.sadb_lifetime_len;
		iov_cnt++;
	}

	if (udpencap.sadb_x_udpencap_len) {
		iov[iov_cnt].iov_base = &udpencap;
		iov[iov_cnt].iov_len = sizeof(udpencap);
		smsg.sadb_msg_len += udpencap.sadb_x_udpencap_len;
		iov_cnt++;
	}

	if (sa_enckey.sadb_key_len) {
		/* encryption key */
		iov[iov_cnt].iov_base = &sa_enckey;
		iov[iov_cnt].iov_len = sizeof(sa_enckey);
		iov_cnt++;
		iov[iov_cnt].iov_base = ibuf_data(sa->csa_encrkey);
		iov[iov_cnt].iov_len =
		    ((ibuf_size(sa->csa_encrkey) + 7) / 8) * 8;
		smsg.sadb_msg_len += sa_enckey.sadb_key_len;
		iov_cnt++;
	}
	if (sa_authkey.sadb_key_len) {
		/* authentication key */
		iov[iov_cnt].iov_base = &sa_authkey;
		iov[iov_cnt].iov_len = sizeof(sa_authkey);
		iov_cnt++;
		iov[iov_cnt].iov_base = ibuf_data(sa->csa_integrkey);
		iov[iov_cnt].iov_len =
		    ((ibuf_size(sa->csa_integrkey) + 7) / 8) * 8;
		smsg.sadb_msg_len += sa_authkey.sadb_key_len;
		iov_cnt++;
	}

	if (sa_srcid) {
		/* src identity */
		iov[iov_cnt].iov_base = sa_srcid;
		iov[iov_cnt].iov_len = sa_srcid->sadb_ident_len * 8;
		smsg.sadb_msg_len += sa_srcid->sadb_ident_len;
		iov_cnt++;
	}
	if (sa_dstid) {
		/* dst identity */
		iov[iov_cnt].iov_base = sa_dstid;
		iov[iov_cnt].iov_len = sa_dstid->sadb_ident_len * 8;
		smsg.sadb_msg_len += sa_dstid->sadb_ident_len;
		iov_cnt++;
	}

	if (tag != NULL) {
		/* tag identity */
		iov[iov_cnt].iov_base = &sa_tag;
		iov[iov_cnt].iov_len = sizeof(sa_tag);
		iov_cnt++;
		iov[iov_cnt].iov_base = tag;
		iov[iov_cnt].iov_len = ROUNDUP(strlen(tag) + 1);
		smsg.sadb_msg_len += sa_tag.sadb_x_tag_len;
		iov_cnt++;
	}

	if (pol->pol_tap != 0) {
		/* enc(4) device tap unit */
		iov[iov_cnt].iov_base = &sa_tap;
		iov[iov_cnt].iov_len = sizeof(sa_tap);
		smsg.sadb_msg_len += sa_tap.sadb_x_tap_len;
		iov_cnt++;
	}

	ret = pfkey_write(sd, &smsg, iov, iov_cnt, NULL, NULL);

	free(sa_srcid);
	free(sa_dstid);

	return ret;
}

int
pfkey_sa_last_used(int sd, struct iked_childsa *sa, uint64_t *last_used)
{
	struct sadb_msg		*msg, smsg;
	struct sadb_address	 sa_src, sa_dst;
	struct sadb_sa		 sadb;
	struct sadb_lifetime	*sa_life;
	struct sockaddr_storage	 ssrc, sdst;
	struct iovec		 iov[IOV_CNT];
	uint8_t			*data;
	ssize_t			 n;
	int			 iov_cnt, ret = -1;
	uint8_t			 satype;

	*last_used = 0;

	if (pfkey_map(pfkey_satype, sa->csa_saproto, &satype) == -1)
		return (-1);

	bzero(&ssrc, sizeof(ssrc));
	memcpy(&ssrc, &sa->csa_local->addr, sizeof(ssrc));
	if (socket_af((struct sockaddr *)&ssrc, 0) == -1) {
		log_warn("%s: invalid address", __func__);
		return (-1);
	}

	bzero(&sdst, sizeof(sdst));
	memcpy(&sdst, &sa->csa_peer->addr, sizeof(sdst));
	if (socket_af((struct sockaddr *)&sdst, 0) == -1) {
		log_warn("%s: invalid address", __func__);
		return (-1);
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = SADB_GET;
	smsg.sadb_msg_satype = satype;

	bzero(&sadb, sizeof(sadb));
	sadb.sadb_sa_len = sizeof(sadb) / 8;
	sadb.sadb_sa_exttype = SADB_EXT_SA;
	sadb.sadb_sa_spi = htonl(sa->csa_spi.spi);
	sadb.sadb_sa_state = SADB_SASTATE_MATURE;
	sadb.sadb_sa_replay = 64;

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;
	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;

	iov_cnt = 0;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* sa */
	iov[iov_cnt].iov_base = &sadb;
	iov[iov_cnt].iov_len = sizeof(sadb);
	smsg.sadb_msg_len += sadb.sadb_sa_len;
	iov_cnt++;

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	/* dst addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	if ((ret = pfkey_write(sd, &smsg, iov, iov_cnt, &data, &n)) != 0)
		return (-1);

	msg = (struct sadb_msg *)data;
	if (msg->sadb_msg_errno != 0) {
		errno = msg->sadb_msg_errno;
		ret = -1;
		log_warn("%s: message", __func__);
		goto done;
	}
	if ((sa_life = pfkey_find_ext(data, n, SADB_X_EXT_LIFETIME_LASTUSE))
	    == NULL) {
		/* has never been used */
		ret = -1;
		goto done;
	}
	*last_used = sa_life->sadb_lifetime_usetime;
	log_debug("%s: last_used %llu", __func__, *last_used);

done:
	freezero(data, n);
	return (ret);
}

int
pfkey_sa_getspi(int sd, uint8_t satype, struct iked_childsa *sa,
    uint32_t *spip)
{
	struct sadb_msg		*msg, smsg;
	struct sadb_address	 sa_src, sa_dst;
	struct sadb_sa		*sa_ext;
	struct sadb_spirange	 sa_spirange;
	struct sockaddr_storage	 ssrc, sdst;
	struct iovec		 iov[IOV_CNT];
	uint8_t			*data;
	ssize_t			 n;
	int			 iov_cnt, ret = -1;

	bzero(&ssrc, sizeof(ssrc));
	memcpy(&ssrc, &sa->csa_local->addr, sizeof(ssrc));
	if (socket_af((struct sockaddr *)&ssrc, 0) == -1) {
		log_warn("%s: invalid address", __func__);
		return (-1);
	}

	bzero(&sdst, sizeof(sdst));
	memcpy(&sdst, &sa->csa_peer->addr, sizeof(sdst));
	if (socket_af((struct sockaddr *)&sdst, 0) == -1) {
		log_warn("%s: invalid address", __func__);
		return (-1);
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = SADB_GETSPI;
	smsg.sadb_msg_satype = satype;

	bzero(&sa_spirange, sizeof(sa_spirange));
	sa_spirange.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
	sa_spirange.sadb_spirange_len = sizeof(sa_spirange) / 8;
	sa_spirange.sadb_spirange_min = 0x100;
	sa_spirange.sadb_spirange_max = (satype == SADB_X_SATYPE_IPCOMP) ?
	    (CPI_PRIVATE_MIN - 1) : 0xffffffff;
	sa_spirange.sadb_spirange_reserved = 0;

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;
	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;

	iov_cnt = 0;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* SPI range */
	iov[iov_cnt].iov_base = &sa_spirange;
	iov[iov_cnt].iov_len = sizeof(sa_spirange);
	smsg.sadb_msg_len += sa_spirange.sadb_spirange_len;
	iov_cnt++;

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	/* dst addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	*spip = 0;

	if ((ret = pfkey_write(sd, &smsg, iov, iov_cnt, &data, &n)) != 0)
		return (-1);

	msg = (struct sadb_msg *)data;
	if (msg->sadb_msg_errno != 0) {
		errno = msg->sadb_msg_errno;
		log_warn("%s: message", __func__);
		goto done;
	}
	if ((sa_ext = pfkey_find_ext(data, n, SADB_EXT_SA)) == NULL) {
		log_debug("%s: erronous reply", __func__);
		goto done;
	}

	*spip = ntohl(sa_ext->sadb_sa_spi);
	log_debug("%s: spi 0x%08x", __func__, *spip);

done:
	freezero(data, n);
	return (ret);
}

int
pfkey_sagroup(int sd, uint8_t satype1, uint8_t action,
    struct iked_childsa *sa1, struct iked_childsa *sa2)
{
	struct sadb_msg		smsg;
	struct sadb_sa		sadb1, sadb2;
	struct sadb_address	sa_dst1, sa_dst2;
	struct sockaddr_storage	sdst1, sdst2;
	struct sadb_protocol	sa_proto;
	struct iovec		iov[IOV_CNT];
	int			iov_cnt;
	uint8_t			satype2;

	if (pfkey_map(pfkey_satype, sa2->csa_saproto, &satype2) == -1)
		return (-1);

	bzero(&sdst1, sizeof(sdst1));
	memcpy(&sdst1, &sa1->csa_peer->addr, sizeof(sdst1));
	if (socket_af((struct sockaddr *)&sdst1, 0) == -1) {
		log_warnx("%s: unsupported address family %d",
		    __func__, sdst1.ss_family);
		return (-1);
	}

	bzero(&sdst2, sizeof(sdst2));
	memcpy(&sdst2, &sa2->csa_peer->addr, sizeof(sdst2));
	if (socket_af((struct sockaddr *)&sdst2, 0) == -1) {
		log_warnx("%s: unsupported address family %d",
		    __func__, sdst2.ss_family);
		return (-1);
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = action;
	smsg.sadb_msg_satype = satype1;

	bzero(&sadb1, sizeof(sadb1));
	sadb1.sadb_sa_len = sizeof(sadb1) / 8;
	sadb1.sadb_sa_exttype = SADB_EXT_SA;
	sadb1.sadb_sa_spi = htonl(sa1->csa_spi.spi);
	sadb1.sadb_sa_state = SADB_SASTATE_MATURE;

	bzero(&sadb2, sizeof(sadb2));
	sadb2.sadb_sa_len = sizeof(sadb2) / 8;
	sadb2.sadb_sa_exttype = SADB_X_EXT_SA2;
	sadb2.sadb_sa_spi = htonl(sa2->csa_spi.spi);
	sadb2.sadb_sa_state = SADB_SASTATE_MATURE;
	iov_cnt = 0;

	bzero(&sa_dst1, sizeof(sa_dst1));
	sa_dst1.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	sa_dst1.sadb_address_len =
	    (sizeof(sa_dst1) + ROUNDUP(sdst1.ss_len)) / 8;

	bzero(&sa_dst2, sizeof(sa_dst2));
	sa_dst2.sadb_address_exttype = SADB_X_EXT_DST2;
	sa_dst2.sadb_address_len =
	    (sizeof(sa_dst2) + ROUNDUP(sdst2.ss_len)) / 8;

	bzero(&sa_proto, sizeof(sa_proto));
	sa_proto.sadb_protocol_exttype = SADB_X_EXT_SATYPE2;
	sa_proto.sadb_protocol_len = sizeof(sa_proto) / 8;
	sa_proto.sadb_protocol_direction = 0;
	sa_proto.sadb_protocol_proto = satype2;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* sa */
	iov[iov_cnt].iov_base = &sadb1;
	iov[iov_cnt].iov_len = sizeof(sadb1);
	smsg.sadb_msg_len += sadb1.sadb_sa_len;
	iov_cnt++;

	/* dst addr */
	iov[iov_cnt].iov_base = &sa_dst1;
	iov[iov_cnt].iov_len = sizeof(sa_dst1);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst1;
	iov[iov_cnt].iov_len = ROUNDUP(sdst1.ss_len);
	smsg.sadb_msg_len += sa_dst1.sadb_address_len;
	iov_cnt++;

	/* second sa */
	iov[iov_cnt].iov_base = &sadb2;
	iov[iov_cnt].iov_len = sizeof(sadb2);
	smsg.sadb_msg_len += sadb2.sadb_sa_len;
	iov_cnt++;

	/* second dst addr */
	iov[iov_cnt].iov_base = &sa_dst2;
	iov[iov_cnt].iov_len = sizeof(sa_dst2);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst2;
	iov[iov_cnt].iov_len = ROUNDUP(sdst2.ss_len);
	smsg.sadb_msg_len += sa_dst2.sadb_address_len;
	iov_cnt++;

	/* SA type */
	iov[iov_cnt].iov_base = &sa_proto;
	iov[iov_cnt].iov_len = sizeof(sa_proto);
	smsg.sadb_msg_len += sa_proto.sadb_protocol_len;
	iov_cnt++;

	return (pfkey_write(sd, &smsg, iov, iov_cnt, NULL, NULL));
}

int
pfkey_write(int sd, struct sadb_msg *smsg, struct iovec *iov, int iov_cnt,
    uint8_t **datap, ssize_t *lenp)
{
	ssize_t n, len = smsg->sadb_msg_len * 8;

	if (sadb_decoupled) {
		switch (smsg->sadb_msg_type) {
		case SADB_GETSPI:
			/* we need to get a new SPI from the kernel */
			break;
		default:
			if (datap || lenp) {
				log_warnx("%s: pfkey not coupled", __func__);
				return (-1);
			}
			/* ignore request */
			return (0);
		}
	}

	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		log_warn("%s: writev failed", __func__);
		return (-1);
	} else if (n != len) {
		log_warn("%s: short write", __func__);
		return (-1);
	}

	return (pfkey_reply(sd, datap, lenp));
}

int
pfkey_reply(int sd, uint8_t **datap, ssize_t *lenp)
{
	struct pfkey_message	*pm;
	struct sadb_msg		 hdr;
	ssize_t			 len;
	uint8_t			*data;
	struct pollfd		pfd[1];
	int			 n;

	pfd[0].fd = sd;
	pfd[0].events = POLLIN;

	for (;;) {
		/*
		 * We should actually expect the reply to get lost
		 * as PF_KEY is an unreliable service per the specs.
		 * Currently we do this by setting a short timeout,
		 * and if it is not readable in that time, we fail
		 * the read.
		 */
		n = poll(pfd, 1, PFKEY_REPLY_TIMEOUT / 1000);
		if (n == -1) {
			log_warn("%s: poll() failed", __func__);
			return (-1);
		}
		if (n == 0) {
			log_warnx("%s: no reply from PF_KEY", __func__);
			return (-1);
		}

		if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
			log_warn("%s: short recv", __func__);
			return (-1);
		}

		if (hdr.sadb_msg_version != PF_KEY_V2) {
			log_warnx("%s: wrong pfkey version", __func__);
			return (-1);
		}

		if ((data = reallocarray(NULL, hdr.sadb_msg_len,
		    PFKEYV2_CHUNK)) == NULL) {
			log_warn("%s: malloc", __func__);
			return (-1);
		}
		len = hdr.sadb_msg_len * PFKEYV2_CHUNK;

		if (read(sd, data, len) != len) {
			log_warnx("%s: short read", __func__);
			free(data);
			return (-1);
		}

		/* XXX: Only one message can be outstanding. */
		if (hdr.sadb_msg_seq == sadb_msg_seq &&
		    hdr.sadb_msg_pid == (uint32_t)getpid())
			break;

		/* ignore messages for other processes */
		if (hdr.sadb_msg_pid != 0 &&
		    hdr.sadb_msg_pid != (uint32_t)getpid()) {
			free(data);
			continue;
		}

		/* not the reply, enqueue */
		if ((pm = malloc(sizeof(*pm))) == NULL) {
			log_warn("%s: malloc", __func__);
			free(data);
			return (-1);
		}
		pm->pm_data = data;
		pm->pm_length = len;
		SIMPLEQ_INSERT_TAIL(&pfkey_postponed, pm, pm_entry);
		evtimer_add(&pfkey_timer_ev, &pfkey_timer_tv);
	}

	if (datap) {
		*datap = data;
		if (lenp)
			*lenp = len;
	} else
		free(data);

	if (datap == NULL && hdr.sadb_msg_errno != 0) {
		errno = hdr.sadb_msg_errno;
		if (errno != EEXIST) {
			log_warn("%s: message", __func__);
			return (-1);
		}
	}
	return (0);
}

int
pfkey_flow_add(int fd, struct iked_flow *flow)
{
	uint8_t		 satype;

	if (flow->flow_loaded)
		return (0);

	if (pfkey_map(pfkey_satype, flow->flow_saproto, &satype) == -1)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_ADDFLOW, flow) == -1)
		return (-1);

	flow->flow_loaded = 1;

	if (flow->flow_dst.addr_af == AF_INET6) {
		sadb_ipv6refcnt++;
		if (sadb_ipv6refcnt == 1)
			return (pfkey_block(fd, AF_INET6, SADB_X_DELFLOW));
	}

	return (0);
}

int
pfkey_flow_delete(int fd, struct iked_flow *flow)
{
	uint8_t		satype;

	if (!flow->flow_loaded)
		return (0);

	if (pfkey_map(pfkey_satype, flow->flow_saproto, &satype) == -1)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_DELFLOW, flow) == -1)
		return (-1);

	flow->flow_loaded = 0;

	if (flow->flow_dst.addr_af == AF_INET6) {
		sadb_ipv6refcnt--;
		if (sadb_ipv6refcnt == 0)
			return (pfkey_block(fd, AF_INET6, SADB_X_ADDFLOW));
	}

	return (0);
}

int
pfkey_block(int fd, int af, unsigned int action)
{
	struct iked_flow	 flow;

	if (!pfkey_blockipv6)
		return (0);

	/*
	 * Prevent VPN traffic leakages in dual-stack hosts/networks.
	 * https://tools.ietf.org/html/draft-gont-opsec-vpn-leakages.
	 * We forcibly block IPv6 traffic unless it is used in any of
	 * the flows by tracking a sadb_ipv6refcnt reference counter.
	 */
	bzero(&flow, sizeof(flow));
	flow.flow_src.addr_af = flow.flow_src.addr.ss_family = af;
	flow.flow_src.addr_net = 1;
	socket_af((struct sockaddr *)&flow.flow_src.addr, 0);
	flow.flow_dst.addr_af = flow.flow_dst.addr.ss_family = af;
	flow.flow_dst.addr_net = 1;
	socket_af((struct sockaddr *)&flow.flow_dst.addr, 0);
	flow.flow_type = SADB_X_FLOW_TYPE_DENY;
	flow.flow_dir = IPSP_DIRECTION_OUT;

	if (pfkey_flow(fd, 0, action, &flow) == -1)
		return (-1);

	return (0);
}

int
pfkey_sa_init(int fd, struct iked_childsa *sa, uint32_t *spi)
{
	uint8_t		 satype;

	if (pfkey_map(pfkey_satype, sa->csa_saproto, &satype) == -1)
		return (-1);

	if (pfkey_sa_getspi(fd, satype, sa, spi) == -1)
		return (-1);

	log_debug("%s: new spi 0x%08x", __func__, *spi);

	return (0);
}

int
pfkey_sa_add(int fd, struct iked_childsa *sa, struct iked_childsa *last)
{
	uint8_t		 satype;
	unsigned int	 cmd;

	if (pfkey_map(pfkey_satype, sa->csa_saproto, &satype) == -1)
		return (-1);

	if (sa->csa_allocated || sa->csa_loaded)
		cmd = SADB_UPDATE;
	else
		cmd = SADB_ADD;

	log_debug("%s: %s spi %s", __func__, cmd == SADB_ADD ? "add": "update",
	    print_spi(sa->csa_spi.spi, 4));

	if (pfkey_sa(fd, satype, cmd, sa) == -1) {
		if (cmd == SADB_ADD) {
			(void)pfkey_sa_delete(fd, sa);
			return (-1);
		}
		if (sa->csa_allocated && !sa->csa_loaded && errno == ESRCH) {
			/* Needed for recoupling local SAs */
			log_debug("%s: SADB_UPDATE on local SA returned ESRCH,"
			    " trying SADB_ADD", __func__);
			if (pfkey_sa(fd, satype, SADB_ADD, sa) == -1)
				return (-1);
		} else {
			return (-1);
		}
	}

	if (last && cmd == SADB_ADD) {
		if (pfkey_sagroup(fd, satype,
		    SADB_X_GRPSPIS, sa, last) == -1) {
			(void)pfkey_sa_delete(fd, sa);
			return (-1);
		}
	}

	sa->csa_loaded = 1;
	return (0);
}

int
pfkey_sa_delete(int fd, struct iked_childsa *sa)
{
	uint8_t		satype;

	if (!sa->csa_loaded || sa->csa_spi.spi == 0)
		return (0);

	if (pfkey_map(pfkey_satype, sa->csa_saproto, &satype) == -1)
		return (-1);

	if (pfkey_sa(fd, satype, SADB_DELETE, sa) == -1)
		return (-1);

	sa->csa_loaded = 0;
	return (0);
}

int
pfkey_flush(int sd)
{
	struct sadb_msg smsg;
	struct iovec	iov[IOV_CNT];
	int		iov_cnt;

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = SADB_FLUSH;
	smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;

	iov_cnt = 0;

	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	return (pfkey_write(sd, &smsg, iov, iov_cnt, NULL, NULL));
}

struct sadb_ident *
pfkey_id2ident(struct iked_id *id, unsigned int exttype)
{
	char			 idstr[IKED_ID_SIZE];
	unsigned int		 type;
	size_t			 len;
	struct sadb_ident	*sa_id;

	switch (id->id_type) {
	case IKEV2_ID_FQDN:
		type = SADB_IDENTTYPE_FQDN;
		break;
	case IKEV2_ID_UFQDN:
		type = SADB_IDENTTYPE_USERFQDN;
		break;
	case IKEV2_ID_IPV4:
	case IKEV2_ID_IPV6:
		type = SADB_IDENTTYPE_PREFIX;
		break;
	case IKEV2_ID_ASN1_DN:
	case IKEV2_ID_ASN1_GN:
	case IKEV2_ID_KEY_ID:
	case IKEV2_ID_NONE:
	default:
		/* XXX not implemented/supported by PFKEY */
		return (NULL);
	}

	bzero(&idstr, sizeof(idstr));

	if (ikev2_print_id(id, idstr, sizeof(idstr)) == -1)
		return (NULL);

	len = ROUNDUP(strlen(idstr) + 1) + sizeof(*sa_id);
	if ((sa_id = calloc(1, len)) == NULL)
		return (NULL);

	strlcpy((char *)(sa_id + 1), idstr, ROUNDUP(strlen(idstr) + 1));
	sa_id->sadb_ident_type = type;
	sa_id->sadb_ident_len = len / 8;
	sa_id->sadb_ident_exttype = exttype;

	return (sa_id);
}

int
pfkey_socket(void)
{
	int	 fd;

	if (privsep_process != PROC_PARENT)
		fatal("pfkey_socket: called from unprivileged process");

	if ((fd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1)
		fatal("pfkey_socket: failed to open PF_KEY socket");

	pfkey_flush(fd);

	return (fd);
}

void
pfkey_init(struct iked *env, int fd)
{
	struct sadb_msg		smsg;
	struct iovec		iov;

	/* Set up a timer to process messages deferred by the pfkey_reply */
	pfkey_timer_tv.tv_sec = 1;
	pfkey_timer_tv.tv_usec = 0;
	evtimer_set(&pfkey_timer_ev, pfkey_timer_cb, env);

	/* Register the pfkey socket event handler */
	env->sc_pfkey = fd;
	event_set(&env->sc_pfkeyev, env->sc_pfkey,
	    EV_READ|EV_PERSIST, pfkey_dispatch, env);
	event_add(&env->sc_pfkeyev, NULL);

	/* Register it to get ESP and AH acquires from the kernel */
	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = SADB_REGISTER;
	smsg.sadb_msg_satype = SADB_SATYPE_ESP;

	iov.iov_base = &smsg;
	iov.iov_len = sizeof(smsg);

	if (pfkey_write(fd, &smsg, &iov, 1, NULL, NULL))
		fatal("pfkey_init: failed to set up ESP acquires");

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = SADB_REGISTER;
	smsg.sadb_msg_satype = SADB_SATYPE_AH;

	iov.iov_base = &smsg;
	iov.iov_len = sizeof(smsg);

	if (pfkey_write(fd, &smsg, &iov, 1, NULL, NULL))
		fatal("pfkey_init: failed to set up AH acquires");

	if (env->sc_opts & IKED_OPT_NOIPV6BLOCKING)
		return;

	/* Block all IPv6 traffic by default */
	pfkey_blockipv6 = 1;
	if (pfkey_block(fd, AF_INET6, SADB_X_ADDFLOW))
		fatal("pfkey_init: failed to block IPv6 traffic");
}

void *
pfkey_find_ext(uint8_t *data, ssize_t len, int type)
{
	struct sadb_ext	*ext = (struct sadb_ext *)(data +
	    sizeof(struct sadb_msg));

	while (ext && ((uint8_t *)ext - data < len)) {
		if (ext->sadb_ext_type == type)
			return (ext);
		ext = (struct sadb_ext *)((uint8_t *)ext +
		    ext->sadb_ext_len * PFKEYV2_CHUNK);
	}

	return (NULL);
}

void
pfkey_dispatch(int sd, short event, void *arg)
{
	struct iked		*env = (struct iked *)arg;
	struct pfkey_message	 pm, *pmp;
	struct sadb_msg		 hdr;
	ssize_t			 len;
	uint8_t			*data;

	if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
		log_warn("%s: short recv", __func__);
		return;
	}

	if (hdr.sadb_msg_version != PF_KEY_V2) {
		log_warnx("%s: wrong pfkey version", __func__);
		return;
	}

	if ((data = reallocarray(NULL, hdr.sadb_msg_len, PFKEYV2_CHUNK))
	    == NULL) {
		log_warn("%s: malloc", __func__);
		return;
	}
	len = hdr.sadb_msg_len * PFKEYV2_CHUNK;

	if (read(sd, data, len) != len) {
		log_warn("%s: short read", __func__);
		free(data);
		return;
	}

	/* Try postponed requests first, so we do in-order processing */
	if (!SIMPLEQ_EMPTY(&pfkey_postponed))
		pfkey_timer_cb(0, 0, env);

	pm.pm_data = data;
	pm.pm_length = len;

	if (pfkey_process(env, &pm) == -1 &&
	    (pmp = calloc(1, sizeof(*pmp))) != NULL) {
		pmp->pm_data = data;
		pmp->pm_length = len;
		log_debug("%s: pfkey_process is busy, retry later", __func__);
		SIMPLEQ_INSERT_TAIL(&pfkey_postponed, pmp, pm_entry);
		evtimer_add(&pfkey_timer_ev, &pfkey_timer_tv);
	} else {
		free(data);
	}
}

void
pfkey_timer_cb(int unused, short event, void *arg)
{
	struct iked		*env = arg;
	struct pfkey_message	*pm;

	SIMPLEQ_INIT(&pfkey_retry);
	while (!SIMPLEQ_EMPTY(&pfkey_postponed)) {
		pm = SIMPLEQ_FIRST(&pfkey_postponed);
		SIMPLEQ_REMOVE_HEAD(&pfkey_postponed, pm_entry);
		if (pfkey_process(env, pm) == -1) {
			log_debug("%s: pfkey_process is busy, retry later",
			    __func__);
			SIMPLEQ_INSERT_TAIL(&pfkey_retry, pm, pm_entry);
		} else {
			free(pm->pm_data);
			free(pm);
		}
	}
	/* move from retry to postponed */
	while ((pm = SIMPLEQ_FIRST(&pfkey_retry)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&pfkey_retry, pm_entry);
		SIMPLEQ_INSERT_TAIL(&pfkey_postponed, pm, pm_entry);
	}
	if (!SIMPLEQ_EMPTY(&pfkey_postponed))
		evtimer_add(&pfkey_timer_ev, &pfkey_timer_tv);
}

/*
 * pfkey_process returns 0 if the message has been processed and -1 if
 * the system is busy and the message should be passed again, later.
 */
int
pfkey_process(struct iked *env, struct pfkey_message *pm)
{
	struct iked_spi		 spi;
	struct sadb_sa		*sa;
	struct sadb_lifetime	*sa_ltime;
	struct sadb_msg		*hdr;
	struct sadb_msg		 smsg;
	struct iked_addr	 peer;
	struct iked_flow	 flow;
	struct sadb_address	*sa_addr;
	struct sadb_protocol	*sa_proto;
	struct sadb_x_policy	 sa_pol;
	struct sockaddr		*ssrc, *sdst, *smask, *dmask, *speer;
	struct iovec		 iov[IOV_CNT];
	int			 ret = 0, iov_cnt, sd;
	uint8_t			*reply;
	ssize_t			 rlen;
	const char		*errmsg = NULL;
	uint8_t			*data = pm->pm_data;
	ssize_t			 len = pm->pm_length;
	size_t			 slen;

	if (!env || !data || !len)
		return (0);

	sd = env->sc_pfkey;
	hdr = (struct sadb_msg *)data;

	switch (hdr->sadb_msg_type) {
	case SADB_ACQUIRE:
		bzero(&flow, sizeof(flow));
		bzero(&peer, sizeof(peer));

		if ((sa_addr = pfkey_find_ext(data, len,
		    SADB_EXT_ADDRESS_DST)) == NULL) {
			log_debug("%s: no peer address", __func__);
			return (0);
		}
		speer = (struct sockaddr *)(sa_addr + 1);
		peer.addr_af = speer->sa_family;
		peer.addr_port = htons(socket_getport(speer));
		if ((slen = speer->sa_len) > sizeof(peer.addr)) {
			log_debug("%s: invalid peer address len", __func__);
			return (0);
		}
		memcpy(&peer.addr, speer, slen);
		if (socket_af((struct sockaddr *)&peer.addr,
		    peer.addr_port) == -1) {
			log_debug("%s: invalid address", __func__);
			return (0);
		}
		flow.flow_peer = &peer;

		log_debug("%s: acquire request (peer %s)", __func__,
		    print_host(speer, NULL, 0));

		/* get the matching flow */
		bzero(&smsg, sizeof(smsg));
		smsg.sadb_msg_version = PF_KEY_V2;
		smsg.sadb_msg_seq = ++sadb_msg_seq;
		smsg.sadb_msg_pid = getpid();
		smsg.sadb_msg_len = sizeof(smsg) / 8;
		smsg.sadb_msg_type = SADB_X_ASKPOLICY;

		iov_cnt = 0;

		iov[iov_cnt].iov_base = &smsg;
		iov[iov_cnt].iov_len = sizeof(smsg);
		iov_cnt++;

		bzero(&sa_pol, sizeof(sa_pol));
		sa_pol.sadb_x_policy_exttype = SADB_X_EXT_POLICY;
		sa_pol.sadb_x_policy_len = sizeof(sa_pol) / 8;
		sa_pol.sadb_x_policy_seq = hdr->sadb_msg_seq;

		iov[iov_cnt].iov_base = &sa_pol;
		iov[iov_cnt].iov_len = sizeof(sa_pol);
		smsg.sadb_msg_len += sizeof(sa_pol) / 8;
		iov_cnt++;

		if (pfkey_write(sd, &smsg, iov, iov_cnt, &reply, &rlen)) {
			log_warnx("%s: failed to get a policy", __func__);
			return (0);
		}

		if ((sa_addr = pfkey_find_ext(reply, rlen,
		    SADB_X_EXT_SRC_FLOW)) == NULL) {
			errmsg = "flow source address";
			goto out;
		}
		ssrc = (struct sockaddr *)(sa_addr + 1);
		flow.flow_src.addr_af = ssrc->sa_family;
		flow.flow_src.addr_port = htons(socket_getport(ssrc));
		if ((slen = ssrc->sa_len) > sizeof(flow.flow_src.addr)) {
			log_debug("%s: invalid src address len", __func__);
			return (0);
		}
		memcpy(&flow.flow_src.addr, ssrc, slen);
		if (socket_af((struct sockaddr *)&flow.flow_src.addr,
		    flow.flow_src.addr_port) == -1) {
			log_debug("%s: invalid address", __func__);
			return (0);
		}

		if ((sa_addr = pfkey_find_ext(reply, rlen,
		    SADB_X_EXT_DST_FLOW)) == NULL) {
			errmsg = "flow destination address";
			goto out;
		}
		sdst = (struct sockaddr *)(sa_addr + 1);
		flow.flow_dst.addr_af = sdst->sa_family;
		flow.flow_dst.addr_port = htons(socket_getport(sdst));
		if ((slen = sdst->sa_len) > sizeof(flow.flow_dst.addr)) {
			log_debug("%s: invalid dst address len", __func__);
			return (0);
		}
		memcpy(&flow.flow_dst.addr, sdst, slen);
		if (socket_af((struct sockaddr *)&flow.flow_dst.addr,
		    flow.flow_dst.addr_port) == -1) {
			log_debug("%s: invalid address", __func__);
			return (0);
		}

		if ((sa_addr = pfkey_find_ext(reply, rlen,
		    SADB_X_EXT_SRC_MASK)) == NULL) {
			errmsg = "flow source mask";
			goto out;
		}
		smask = (struct sockaddr *)(sa_addr + 1);
		switch (smask->sa_family) {
		case AF_INET:
			flow.flow_src.addr_mask =
			    mask2prefixlen((struct sockaddr *)smask);
			if (flow.flow_src.addr_mask != 32)
				flow.flow_src.addr_net = 1;
			break;
		case AF_INET6:
			flow.flow_src.addr_mask =
			    mask2prefixlen6((struct sockaddr *)smask);
			if (flow.flow_src.addr_mask != 128)
				flow.flow_src.addr_net = 1;
			break;
		default:
			log_debug("%s: bad address family", __func__);
			free(reply);
			return (0);
		}

		if ((sa_addr = pfkey_find_ext(reply, rlen,
		    SADB_X_EXT_DST_MASK)) == NULL) {
			errmsg = "flow destination mask";
			goto out;
		}
		dmask = (struct sockaddr *)(sa_addr + 1);
		switch (dmask->sa_family) {
		case AF_INET:
			flow.flow_dst.addr_mask =
			    mask2prefixlen((struct sockaddr *)dmask);
			if (flow.flow_src.addr_mask != 32)
				flow.flow_src.addr_net = 1;
			break;
		case AF_INET6:
			flow.flow_dst.addr_mask =
			    mask2prefixlen6((struct sockaddr *)dmask);
			if (flow.flow_src.addr_mask != 128)
				flow.flow_src.addr_net = 1;
			break;
		default:
			log_debug("%s: bad address family", __func__);
			free(reply);
			return (0);
		}

		if ((sa_proto = pfkey_find_ext(reply, rlen,
		    SADB_X_EXT_FLOW_TYPE)) == NULL) {
			errmsg = "flow protocol";
			goto out;
		}
		flow.flow_dir = sa_proto->sadb_protocol_direction;

		log_debug("%s: flow %s from %s/%s to %s/%s via %s", __func__,
		    flow.flow_dir == IPSP_DIRECTION_IN ? "in" : "out",
		    print_host(ssrc, NULL, 0), print_host(smask, NULL, 0),
		    print_host(sdst, NULL, 0), print_host(dmask, NULL, 0),
		    print_host(speer, NULL, 0));

		ret = ikev2_acquire_sa(env, &flow);

out:
		if (errmsg)
			log_warnx("%s: %s wasn't found", __func__, errmsg);
		free(reply);
		break;

	case SADB_EXPIRE:
		if ((sa = pfkey_find_ext(data, len, SADB_EXT_SA)) == NULL) {
			log_warnx("%s: SA extension wasn't found", __func__);
			return (0);
		}
		if ((sa_ltime = pfkey_find_ext(data, len,
			SADB_EXT_LIFETIME_SOFT)) == NULL &&
		    (sa_ltime = pfkey_find_ext(data, len,
			SADB_EXT_LIFETIME_HARD)) == NULL) {
			log_warnx("%s: lifetime extension wasn't found",
			    __func__);
			return (0);
		}
		spi.spi = ntohl(sa->sadb_sa_spi);
		spi.spi_size = 4;
		switch (hdr->sadb_msg_satype) {
		case SADB_SATYPE_AH:
			spi.spi_protoid = IKEV2_SAPROTO_AH;
			break;
		case SADB_SATYPE_ESP:
			spi.spi_protoid = IKEV2_SAPROTO_ESP;
			break;
		case SADB_X_SATYPE_IPCOMP:
			spi.spi_size = 2;
			spi.spi_protoid = IKEV2_SAPROTO_IPCOMP;
			break;
		default:
			log_warnx("%s: unsupported SA type %d spi %s",
			    __func__, hdr->sadb_msg_satype,
			    print_spi(spi.spi, spi.spi_size));
			return (0);
		}

		log_debug("%s: SA %s is expired, pending %s", __func__,
		    print_spi(spi.spi, spi.spi_size),
		    sa_ltime->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ?
		    "rekeying" : "deletion");

		if (sa_ltime->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT)
			ret = ikev2_rekey_sa(env, &spi);
		else
			ret = ikev2_drop_sa(env, &spi);
		break;
	}
	return (ret);
}
@


1.57
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.56 2017/03/27 10:24:36 reyk Exp $	*/
d853 1
a853 2
	explicit_bzero(data, n);
	free(data);
d960 1
a960 2
	explicit_bzero(data, n);
	free(data);
@


1.56
log
@Fix another iked leak of SAs in pfkey_sa(), copy tags correctly.

Diff from markus@@
OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.55 2017/03/13 17:41:14 reyk Exp $	*/
d534 1
a534 1
		/* double the lifetime for IP compression; disable byte lifetime */
@


1.55
log
@NAT-T improvements

Move repeated creation of the NAT-T payload into a function, remove
erroneous msg_offset, and improve NAT-T handling.

From and OK markus, OK mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.54 2017/03/13 15:06:51 patrick Exp $	*/
d452 1
d738 6
a743 1
	return (pfkey_write(sd, &smsg, iov, iov_cnt, NULL, NULL));
@


1.54
log
@When setting up IPcomp flows for the networks 'A' and 'B' between
gateways 'a' and 'b', we replace the ESP flow "A->B ESP" with an
IPCOMP flow "A->B IPCOMP" and add a matching (transport mode) ESP
flow between the gateways "a->b ESP".  The later is now marked with
flow_ipcomp so it is not translated into "a->b IPCOMP" on rekeying.

When SAs get deleted we do an extra loop to figure out if matching
IPcomp SAs can now be removed, too.  This allows faster expiry of
unused IPcomp SAs.

Disable bytes lifetime for IP compression.

ok markus@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.53 2017/02/28 16:46:27 bluhm Exp $	*/
d514 12
a554 12
	}

	if (satype == SADB_SATYPE_ESP &&
	    sa->csa_ikesa->sa_udpencap && sa->csa_ikesa->sa_natt) {
		sadb.sadb_sa_flags |= SADB_X_SAFLAGS_UDPENCAP;
		udpencap.sadb_x_udpencap_exttype = SADB_X_EXT_UDPENCAP;
		udpencap.sadb_x_udpencap_len = sizeof(udpencap) / 8;
		udpencap.sadb_x_udpencap_port =
		    sa->csa_ikesa->sa_peer.addr_port;

		log_debug("%s: udpencap port %d", __func__,
		    ntohs(udpencap.sadb_x_udpencap_port));
@


1.53
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.52 2016/09/03 09:20:07 vgross Exp $	*/
d521 2
a522 2
		/* double the lifetime for IP compression */
		if (satype == SADB_X_SATYPE_IPCOMP)
d524 2
@


1.52
log
@Add the missing bits to have NAT on enc(4) support in iked.

Ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.51 2016/03/07 19:33:26 mmcc Exp $	*/
d1022 1
a1022 1
	sa_proto.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
@


1.51
log
@http -> https for IETF/IANA URLs in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.50 2015/12/10 17:23:34 mmcc Exp $	*/
d176 1
d187 19
d208 4
a211 4
	memcpy(&ssrc, &flow->flow_src.addr, sizeof(ssrc));
	memcpy(&smask, &flow->flow_src.addr, sizeof(smask));
	socket_af((struct sockaddr *)&ssrc, flow->flow_src.addr_port);
	socket_af((struct sockaddr *)&smask, flow->flow_src.addr_port ?
d214 1
a214 1
	switch (flow->flow_src.addr_af) {
d217 2
a218 2
		    prefixlen2mask(flow->flow_src.addr_net ?
		    flow->flow_src.addr_mask : 32);
d221 2
a222 2
		prefixlen2mask6(flow->flow_src.addr_net ?
		    flow->flow_src.addr_mask : 128,
d228 1
a228 1
		    __func__, flow->flow_src.addr_af);
d235 4
a238 4
	memcpy(&sdst, &flow->flow_dst.addr, sizeof(sdst));
	memcpy(&dmask, &flow->flow_dst.addr, sizeof(dmask));
	socket_af((struct sockaddr *)&sdst, flow->flow_dst.addr_port);
	socket_af((struct sockaddr *)&dmask, flow->flow_dst.addr_port ?
d241 1
a241 1
	switch (flow->flow_dst.addr_af) {
d244 2
a245 2
		    prefixlen2mask(flow->flow_dst.addr_net ?
		    flow->flow_dst.addr_mask : 32);
d248 2
a249 2
		prefixlen2mask6(flow->flow_dst.addr_net ?
		    flow->flow_dst.addr_mask : 128,
d255 1
a255 1
		    __func__, flow->flow_dst.addr_af);
@


1.50
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.49 2015/12/09 21:41:49 naddy Exp $	*/
d1238 1
a1238 1
	 * http://tools.ietf.org/html/draft-gont-opsec-vpn-leakages.
@


1.49
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.48 2015/12/02 12:43:59 naddy Exp $	*/
d1574 1
a1574 1
 * the system is busy and the the message should be passed again, later.
@


1.48
log
@remove unimplemented PF_KEY algorithms; ok sthen@@ mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.47 2015/11/04 12:40:49 mikeb Exp $	*/
a71 1
	{ SADB_EALG_DESCBC,	IKEV2_XFORMENCR_DES },
@


1.47
log
@Support Chacha20-Poly1305 for Child SAs;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.46 2015/10/15 18:40:38 mmcc Exp $	*/
a71 1
	{ SADB_X_EALG_DES_IV64,	IKEV2_XFORMENCR_DES_IV64 },
a73 2
	{ SADB_X_EALG_RC5,	IKEV2_XFORMENCR_RC5 },
	{ SADB_X_EALG_IDEA,	IKEV2_XFORMENCR_IDEA },
a75 3
	{ SADB_X_EALG_3IDEA,	IKEV2_XFORMENCR_3IDEA },
	{ SADB_X_EALG_DES_IV32,	IKEV2_XFORMENCR_DES_IV32 },
	{ SADB_X_EALG_RC4,	IKEV2_XFORMENCR_RC4 },
a87 1
	{ SADB_X_AALG_DES,	IKEV2_XFORMAUTH_DES_MAC },
@


1.46
log
@Remove some unnecessary NULL-checks before free(). Change two bzero()
calls on pf data to explicit_bzero().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.45 2015/08/26 02:09:29 jsg Exp $	*/
d87 1
@


1.45
log
@use 0xffff not 0xfffff for a 16 bit port constant
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.44 2015/08/21 11:59:28 reyk Exp $	*/
d414 2
a415 4
	if (sa_srcid)
		free(sa_srcid);
	if (sa_dstid)
		free(sa_dstid);
d832 1
a832 1
	bzero(data, n);
d940 1
a940 1
	bzero(data, n);
@


1.44
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.43 2015/07/17 14:48:17 mikeb Exp $	*/
d199 1
a199 1
	    0xfffff : 0);
@


1.43
log
@Assign correct destination port value for the destination netmask.

This repairs setup of SPD flows that specify port only on the one
side of the from-to specification.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.42 2015/06/05 13:35:08 vgross Exp $	*/
d45 1
a45 1
#define PFKEYV2_CHUNK sizeof(u_int64_t)
d48 3
a50 3
static u_int32_t sadb_msg_seq = 0;
static u_int sadb_decoupled = 0;
static u_int sadb_ipv6refcnt = 0;
d59 1
a59 1
	u_int8_t	*pm_data;
d66 3
a68 3
	u_int8_t	 pfkey_id;
	u_int		 pfkey_ikeid;
	u_int		 pfkey_fixedkey;
d107 5
a111 5
int	pfkey_map(const struct pfkey_constmap *, u_int16_t, u_int8_t *);
int	pfkey_flow(int, u_int8_t, u_int8_t, struct iked_flow *);
int	pfkey_sa(int, u_int8_t, u_int8_t, struct iked_childsa *);
int	pfkey_sa_getspi(int, u_int8_t, struct iked_childsa *, u_int32_t *);
int	pfkey_sagroup(int, u_int8_t, u_int8_t,
d114 2
a115 2
	    u_int8_t **, ssize_t *);
int	pfkey_reply(int, u_int8_t **, ssize_t *);
d119 2
a120 2
	pfkey_id2ident(struct iked_id *, u_int);
void	*pfkey_find_ext(u_int8_t *, ssize_t, int);
d167 1
a167 1
pfkey_map(const struct pfkey_constmap *map, u_int16_t alg, u_int8_t *pfkalg)
d180 1
a180 1
pfkey_flow(int sd, u_int8_t satype, u_int8_t action, struct iked_flow *flow)
d210 1
a210 1
		    (u_int32_t *)((struct sockaddr_in6 *)
d237 1
a237 1
		    (u_int32_t *)((struct sockaddr_in6 *)
d423 1
a423 1
pfkey_sa(int sd, u_int8_t satype, u_int8_t action, struct iked_childsa *sa)
d439 1
a439 1
	u_int32_t		 jitter;
d728 1
a728 1
pfkey_sa_last_used(int sd, struct iked_childsa *sa, u_int64_t *last_used)
d736 1
a736 1
	u_int8_t		*data;
d739 1
a739 1
	u_int8_t		 satype;
d840 2
a841 2
pfkey_sa_getspi(int sd, u_int8_t satype, struct iked_childsa *sa,
    u_int32_t *spip)
d849 1
a849 1
	u_int8_t		*data;
d948 1
a948 1
pfkey_sagroup(int sd, u_int8_t satype1, u_int8_t action,
d958 1
a958 1
	u_int8_t		satype2;
d1062 1
a1062 1
    u_int8_t **datap, ssize_t *lenp)
d1093 1
a1093 1
pfkey_reply(int sd, u_int8_t **datap, ssize_t *lenp)
d1098 1
a1098 1
	u_int8_t		*data;
d1148 1
a1148 1
		    hdr.sadb_msg_pid == (u_int32_t)getpid())
d1153 1
a1153 1
		    hdr.sadb_msg_pid != (u_int32_t)getpid()) {
d1190 1
a1190 1
	u_int8_t	 satype;
d1215 1
a1215 1
	u_int8_t	satype;
d1238 1
a1238 1
pfkey_block(int fd, int af, u_int action)
d1268 1
a1268 1
pfkey_sa_init(int fd, struct iked_childsa *sa, u_int32_t *spi)
d1270 1
a1270 1
	u_int8_t	satype;
d1286 2
a1287 2
	u_int8_t	 satype;
	u_int		 cmd;
d1331 1
a1331 1
	u_int8_t	satype;
d1371 1
a1371 1
pfkey_id2ident(struct iked_id *id, u_int exttype)
d1374 1
a1374 1
	u_int			 type;
d1487 1
a1487 1
pfkey_find_ext(u_int8_t *data, ssize_t len, int type)
d1492 1
a1492 1
	while (ext && ((u_int8_t *)ext - data < len)) {
d1495 1
a1495 1
		ext = (struct sadb_ext *)((u_int8_t *)ext +
d1509 1
a1509 1
	u_int8_t		*data;
d1601 1
a1601 1
	u_int8_t		*reply;
d1604 1
a1604 1
	u_int8_t		*data = pm->pm_data;
@


1.42
log
@Fix coupling and decoupling operations.

With help and ok from mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.41 2015/01/16 06:39:58 deraadt Exp $	*/
a189 1
	in_port_t		 sport, dport;
a190 1
	sport = dport = 0;
d197 3
a199 4
	if ((sport = flow->flow_src.addr_port) != 0)
		dport = 0xffff;
	socket_af((struct sockaddr *)&ssrc, sport);
	socket_af((struct sockaddr *)&smask, dport);
d224 3
a226 4
	if ((sport = flow->flow_dst.addr_port) != 0)
		dport = 0xffff;
	socket_af((struct sockaddr *)&sdst, sport);
	socket_af((struct sockaddr *)&dmask, dport);
@


1.41
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.40 2014/10/29 06:26:39 deraadt Exp $	*/
a130 1
	u_int			 old;
d137 1
a137 4
	old = sadb_decoupled ? 1 : 0;
	sadb_decoupled = couple ? 0 : 1;

	if (old == sadb_decoupled)
d141 4
a144 1
	    mode[old], mode[sadb_decoupled]);
d148 1
a148 1
			if (!csa->csa_loaded && !sadb_decoupled)
d150 1
a150 1
			else if (csa->csa_loaded && sadb_decoupled)
d154 1
a154 1
			if (!flow->flow_loaded && !sadb_decoupled)
d156 1
a156 1
			else if (flow->flow_loaded && sadb_decoupled)
d161 2
d1305 1
a1305 1
		if (cmd == SADB_ADD)
d1307 11
a1317 1
		return (-1);
@


1.40
log
@convert simple cases of select() to poll()
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.39 2014/10/18 03:11:54 doug Exp $	*/
a21 1
#include <sys/param.h>
@


1.39
log
@Simple malloc() to reallocarray() conversion to potentially avoid integer
overflow.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.38 2014/07/09 12:05:01 markus Exp $	*/
d34 1
a1100 1
	struct timeval		 tv;
d1103 1
a1103 1
	fd_set			*fds;
d1106 3
d1117 1
a1117 12
		n = howmany(sd + 1, NFDBITS);
		if ((fds = calloc(n, sizeof(fd_mask))) == NULL) {
			log_warn("%s: calloc(%lu, %lu) failed", __func__,
			    (unsigned long) n,
			    (unsigned long) sizeof(fd_mask));
			return (-1);
		}
		FD_SET(sd, fds);
		tv.tv_sec = 0;
		tv.tv_usec = PFKEY_REPLY_TIMEOUT;
		n = select(sd + 1, fds, 0, 0, &tv);
		free(fds);
d1119 1
a1119 2
			log_warn("%s: select(%d, fds, 0, 0, &tv) failed",
			    __func__, sd + 1);
@


1.38
log
@expire IPcomp SAs too; ok mikeb (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.37 2014/05/09 06:37:24 markus Exp $	*/
d1146 2
a1147 2
		len = hdr.sadb_msg_len * PFKEYV2_CHUNK;
		if ((data = malloc(len)) == NULL) {
d1151 2
d1524 2
a1525 2
	len = hdr.sadb_msg_len * PFKEYV2_CHUNK;
	if ((data = malloc(len)) == NULL) {
d1529 2
@


1.37
log
@get rid of redundant {csa,flow}_{src,dst}id pointers, so we don't need
to update it on rekey (fixes use-after-free); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.36 2014/05/09 06:29:46 markus Exp $	*/
d513 4
d522 1
a522 1
		    (lt->lt_bytes * jitter) / 1000;
d524 1
a524 1
		    (lt->lt_seconds * jitter) / 1000;
d1800 4
@


1.36
log
@replace iked_transform pointer with xform id, since target of pointer
might be freed (e.g. on ike sa rekey); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.35 2014/05/07 13:09:43 markus Exp $	*/
d315 1
a315 1
		sa_srcid = pfkey_id2ident(flow->flow_srcid,
d319 1
a319 1
		sa_dstid = pfkey_id2ident(flow->flow_dstid,
d581 12
a592 5
	/* local id */
	sa_srcid = pfkey_id2ident(sa->csa_srcid, SADB_EXT_IDENTITY_SRC);

	/* peer id */
	sa_dstid = pfkey_id2ident(sa->csa_dstid, SADB_EXT_IDENTITY_DST);
@


1.35
log
@try postponed requests first, so we do in-order processing; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.34 2014/05/06 10:24:22 markus Exp $	*/
d543 1
a543 1
	if (sa->csa_integrxf)
d545 1
a545 1
		    sa->csa_integrxf->xform_id, &sadb.sadb_sa_auth) == -1) {
d547 1
a547 1
			    __func__, print_map(sa->csa_integrxf->xform_id,
d552 1
a552 1
	if (sa->csa_encrxf)
d554 1
a554 1
		    sa->csa_encrxf->xform_id, &sadb.sadb_sa_encrypt) == -1) {
d556 1
a556 1
			    __func__, print_map(sa->csa_encrxf->xform_id,
@


1.34
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.33 2014/05/05 18:50:36 markus Exp $	*/
d1522 4
d1560 1
d1791 1
a1791 1
			log_warnx("%s: usupported SA type %d spi %s",
@


1.33
log
@pfkey is unreliable, so add a select-timeout before MSG_PEEK;
similar code is in isakmpd; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.32 2014/05/05 16:13:12 markus Exp $	*/
d62 1
a62 1
SIMPLEQ_HEAD(, pfkey_message) pfkey_postponed =
d123 1
a123 1
void	pfkey_process(struct iked *, struct pfkey_message *);
d1496 1
a1496 1
	struct pfkey_message	 pm;
a1523 1
	pfkey_process(env, &pm);
d1525 10
a1534 1
	free(data);
d1543 1
d1547 12
a1558 3
		pfkey_process(env, pm);
		free(pm->pm_data);
		free(pm);
d1560 2
d1564 5
a1568 1
void
d1583 1
a1583 1
	int			 iov_cnt, sd;
d1592 1
a1592 1
		return;
d1605 1
a1605 1
			return;
d1612 1
a1612 1
			return;
d1618 1
a1618 1
			return;
d1651 1
a1651 1
			return;
d1664 1
a1664 1
			return;
d1670 1
a1670 1
			return;
d1683 1
a1683 1
			return;
d1689 1
a1689 1
			return;
d1714 1
a1714 1
			return;
d1739 1
a1739 1
			return;
d1755 1
a1755 1
		ikev2_acquire_sa(env, &flow);
d1766 1
a1766 1
			return;
d1774 1
a1774 1
			return;
d1789 1
a1789 1
			return;
d1798 1
a1798 1
			ikev2_rekey_sa(env, &spi);
d1800 1
a1800 1
			ikev2_drop_sa(env, &spi);
d1803 1
@


1.32
log
@don't leak on pid mismatch; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.31 2014/05/05 08:23:57 blambert Exp $	*/
d46 1
d1089 1
d1092 2
d1096 29
@


1.31
log
@change surprisingly consistent mispelling of length ("lenght")

no change in md5 of resulting object file

ok markus@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.30 2014/04/25 09:41:21 jsg Exp $	*/
d1120 2
a1121 1
		    hdr.sadb_msg_pid != (u_int32_t)getpid())
d1123 1
@


1.30
log
@don't access a pointer till after the null check
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.29 2014/02/21 20:52:38 markus Exp $	*/
d59 1
a59 1
	ssize_t		 pm_lenght;
d1130 1
a1130 1
		pm->pm_lenght = len;
d1488 1
a1488 1
	pm.pm_lenght = len;
d1529 1
a1529 1
	ssize_t			 len = pm->pm_lenght;
@


1.29
log
@support rekeying for IPCOMP; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.28 2014/02/14 09:00:03 markus Exp $	*/
d1524 1
a1524 1
	int			 iov_cnt, sd = env->sc_pfkey;
d1535 1
@


1.28
log
@initial support for IPComp
still experimental and rekeying needs some work; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.27 2014/01/22 09:25:41 markus Exp $	*/
d817 1
a817 1
		log_debug("%s: erronous reply", __func__);
@


1.27
log
@implement DPD similar to isakmpd, but only send DPD-messages 'on-demand'
(less aggressive, only if the ESP-SAs are actually used);
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.26 2013/12/03 13:55:39 markus Exp $	*/
d102 1
d482 2
a483 2
	/* XXX we don't support transport mode, yet */
	sadb.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
d530 2
a531 1
	if (sa->csa_ikesa->sa_udpencap && sa->csa_ikesa->sa_natt) {
d576 4
d870 2
a871 1
	sa_spirange.sadb_spirange_max = 0xffffffff;
@


1.26
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.25 2013/11/14 13:35:19 markus Exp $	*/
d710 112
@


1.25
log
@ignore messages for other daemons, like isakmpd does; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.24 2013/11/14 12:44:51 markus Exp $	*/
d1403 1
a1403 1
	struct sockaddr_storage	*ssrc, *sdst, *smask, *dmask, *speer;
d1411 1
d1428 2
a1429 2
		speer = (struct sockaddr_storage *)(sa_addr + 1);
		peer.addr_af = speer->ss_family;
d1431 5
a1435 1
		memcpy(&peer.addr, speer, sizeof(*speer));
d1480 2
a1481 2
		ssrc = (struct sockaddr_storage *)(sa_addr + 1);
		flow.flow_src.addr_af = ssrc->ss_family;
d1483 5
a1487 1
		memcpy(&flow.flow_src.addr, ssrc, sizeof(*ssrc));
d1499 2
a1500 2
		sdst = (struct sockaddr_storage *)(sa_addr + 1);
		flow.flow_dst.addr_af = sdst->ss_family;
d1502 5
a1506 1
		memcpy(&flow.flow_dst.addr, sdst, sizeof(*sdst));
d1518 2
a1519 2
		smask = (struct sockaddr_storage *)(sa_addr + 1);
		switch (smask->ss_family) {
d1543 2
a1544 2
		dmask = (struct sockaddr_storage *)(sa_addr + 1);
		switch (dmask->ss_family) {
@


1.24
log
@setup pfkey timer before use; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.23 2013/03/21 04:30:14 deraadt Exp $	*/
d999 5
d1006 1
a1006 1
			log_warn("%s", __func__);
@


1.23
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.22 2013/01/08 10:38:19 reyk Exp $	*/
d1268 5
a1306 5

	/* Set up a timer to process messages deferred by the pfkey_reply */
	pfkey_timer_tv.tv_sec = 1;
	pfkey_timer_tv.tv_usec = 0;
	evtimer_set(&pfkey_timer_ev, pfkey_timer_cb, env);
@


1.22
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.21 2012/11/29 15:08:08 reyk Exp $	*/
a21 1
#include <sys/types.h>
@


1.21
log
@Prevent VPN traffic leakages in dual-stack hosts/networks.
See http://tools.ietf.org/html/draft-gont-opsec-vpn-leakages.

We forcibly block IPv6 traffic by loading a "flow esp out from ::/0 to
::/0 type deny" unless the protocol is used in any of the flows.  Note
that this will block any IPv6 traffic, superseding routes and pf, on
the host by default when iked is running with IPv4 flows only.  This
auto-blocking feature can be disabled by specifying the "-6" command
line flag to iked.

Thanks to Fernando Gont.

ok mikeb@@
@
text
@d1 1
a1 2
/*	$OpenBSD: pfkey.c,v 1.20 2012/10/23 14:40:14 reyk Exp $	*/
/*	$vantronix: pfkey.c,v 1.11 2010/06/03 07:57:33 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.20
log
@Change the order of variables just to shrink the diff to the (not yet
released) portable version a bit.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.19 2012/09/18 12:07:59 reyk Exp $	*/
d51 1
d53 1
d252 1
a252 1
	if (action != SADB_X_DELFLOW) {
d273 3
a275 2
	    flow->flow_dir == IPSP_DIRECTION_IN ?
	    SADB_X_FLOW_TYPE_USE : SADB_X_FLOW_TYPE_REQUIRE;
d301 1
a301 1
	if (action != SADB_X_DELFLOW) {
d336 1
a336 1
	if (action != SADB_X_DELFLOW) {
d1045 7
d1070 37
d1309 8
@


1.19
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.18 2012/06/29 15:05:49 mikeb Exp $	*/
d432 1
a440 1
	char			*tag = NULL;
d1335 5
a1341 1
	struct iked_spi		 spi;
a1342 3
	struct sadb_msg		*hdr, smsg;
	struct sadb_sa		*sa;
	struct sadb_lifetime	*sa_ltime;
d1348 2
a1349 2
	u_int8_t		*reply, *data = pm->pm_data;
	ssize_t			 rlen, len = pm->pm_lenght;
d1351 2
@


1.18
log
@Add missing ESN bits
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.17 2012/03/24 00:40:25 jsg Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.17
log
@fix some leaks
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.16 2011/05/27 12:01:02 reyk Exp $	*/
d478 1
a478 1
	sadb.sadb_sa_replay = 16;
d482 3
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.15 2011/05/05 12:17:10 reyk Exp $	*/
d1457 1
d1482 1
@


1.15
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.14 2011/01/26 16:59:24 mikeb Exp $	*/
d1201 1
a1201 1
	int	 		fd;
@


1.14
log
@get rid of acquire flows completely, as they tend to pass traffic
when there's no sa established (as pointed out by reyk).  instead
use require mode feature to send acquires from the kernel.  this
allows us to get rid of the code that changes flow mode to acquire
and keep all installed flows in the tree and save up on some code
that deals with renegotiation.  also several entities were renamed
(iked_acqflows -> iked_activeflows, iked_ipsecsas -> iked_activesas,
ikev2_acquire -> ikev2_acquire_sa).   ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.13 2011/01/21 11:37:02 reyk Exp $	*/
d1203 1
a1203 1
	if (iked_process != PROC_PARENT)
@


1.13
log
@split pfkey initialization into a privileged and unprivileged part to
prevent a possible crash.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.12 2011/01/17 18:49:35 mikeb Exp $	*/
d270 3
a272 5
	if (flow->flow_dir == IPSP_DIRECTION_IN)
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
	else
		sa_flowtype.sadb_protocol_proto = flow->flow_acquire ?
		    SADB_X_FLOW_TYPE_ACQUIRE : SADB_X_FLOW_TYPE_REQUIRE;
d1497 1
a1497 1
		ikev2_acquire(env, &flow);
@


1.12
log
@Add initial acquire mode support and use it whenever Windows peers decide
to drop Child SA based on the inactivity timer.  In this case we instruct
the kernel to send us an acquire message upon receiving a packet for those
hosts and initiate a Child SA creation exchange ourselves.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.11 2011/01/12 14:35:45 mikeb Exp $	*/
d114 1
d1201 1
a1201 1
pfkey_init(struct iked *env)
a1202 2
	struct sadb_msg		smsg;
	struct iovec		iov;
d1205 3
d1209 1
a1209 1
		fatal("pfkey_init: failed to open PF_KEY socket");
d1213 15
a1260 2

	return (fd);
@


1.11
log
@postpone processing of pfkey messages received in pfkey_reply instead of
just dropping them;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.10 2010/12/22 17:53:54 reyk Exp $	*/
d269 5
a273 3
	sa_flowtype.sadb_protocol_proto =
	    flow->flow_dir == IPSP_DIRECTION_IN ?
	    SADB_X_FLOW_TYPE_USE : SADB_X_FLOW_TYPE_REQUIRE;
d1202 2
d1211 29
d1319 2
d1322 2
a1323 1
	struct sadb_msg		*hdr;
d1325 9
a1333 3
	struct sadb_lifetime	*ltime;
	u_int8_t		*data = pm->pm_data;
	ssize_t			 len = pm->pm_lenght;
d1341 151
d1494 1
a1494 1
			log_warnx("%s: SADB_EXPIRE w/o SA payload", __func__);
d1497 1
a1497 1
		if ((ltime = pfkey_find_ext(data, len,
d1499 1
a1499 1
		    (ltime = pfkey_find_ext(data, len,
d1501 1
a1501 1
			log_warnx("%s: SADB_EXPIRE w/o lifetime payload",
d1523 1
a1523 1
		    ltime->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ?
d1526 1
a1526 1
		if (ltime->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT)
@


1.10
log
@move and rename util.c:print_id() to ikev2.c:ikev2_print_id() because
it is too specific to be in util.c.  This will allow to link util.c
into ikectl later without all the other dependencies of pritn_id().
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.9 2010/12/22 16:22:27 mikeb Exp $	*/
d52 12
d119 2
d962 4
a965 3
	struct sadb_msg	 hdr;
	ssize_t		 len;
	u_int8_t	*data;
d978 11
d994 4
a997 3
		/* not ours, discard */
		if (read(sd, &hdr, sizeof(hdr)) == -1) {
			log_warn("%s: read", __func__);
d1000 4
a1005 11
	len = hdr.sadb_msg_len * PFKEYV2_CHUNK;
	if ((data = malloc(len)) == NULL) {
		log_warn("%s: malloc", __func__);
		return (-1);
	}
	if (read(sd, data, len) != len) {
		log_warnx("%s: short read", __func__);
		bzero(data, len);
		free(data);
		return (-1);
	}
d1010 1
a1010 2
	} else {
		bzero(data, len);
d1012 1
a1012 1
	}
d1198 1
a1198 1
pfkey_init(void)
d1200 1
a1200 1
	int	 fd;
d1207 5
d1235 1
a1235 1
	struct iked_spi		 spi;
a1236 2
	struct sadb_sa		*sa;
	struct sadb_lifetime	*ltime;
a1256 1
		bzero(data, len);
d1261 38
a1298 1
	switch (hdr.sadb_msg_type) {
d1314 1
a1314 1
		switch (hdr.sadb_msg_satype) {
d1323 1
a1323 1
			    __func__, hdr.sadb_msg_satype,
a1338 2

	free(data);
@


1.9
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.8 2010/09/23 11:42:36 mikeb Exp $	*/
d1163 1
a1163 1
	if (print_id(id, idstr, sizeof(idstr)) == -1)
@


1.8
log
@support for aes-gcm

OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.7 2010/07/01 02:15:08 reyk Exp $	*/
d49 1
a49 1
static u_int32_t sadb_msg_seq = 1;
d99 1
a99 1
int	pfkey_write(int sd, struct sadb_msg *, struct iovec *, int,
d105 2
d245 1
a245 1
	smsg.sadb_msg_seq = sadb_msg_seq++;
d414 1
d420 1
d423 1
d434 1
d452 1
a452 1
	smsg.sadb_msg_seq = sadb_msg_seq++;
d479 2
d485 17
d517 2
a518 3
		log_debug("%s: udpencap port %d", __func__, 
		    ntohs(udpencap.sadb_x_udpencap_port),
		    udpencap.sadb_x_udpencap_port);
d610 16
a699 1
	struct sadb_ext		*ext;
d705 1
a705 1
	int			 iov_cnt, ret = 0;
d723 1
a723 1
	smsg.sadb_msg_seq = sadb_msg_seq++;
d775 1
a775 1
	*spip = 0;	
d781 8
a788 10
	for (ext = (struct sadb_ext *)(msg + 1);
	    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
	    msg->sadb_msg_len * PFKEYV2_CHUNK;
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
	    ext->sadb_ext_len * PFKEYV2_CHUNK)) {
		if (ext->sadb_ext_type == SADB_EXT_SA) {
			sa_ext = (struct sadb_sa *)ext;
			*spip = ntohl(sa_ext->sadb_sa_spi);
			break;
		}
d791 4
a796 3

	log_debug("%s: spi 0x%08x", __func__, *spip);

d834 1
a834 1
	smsg.sadb_msg_seq = sadb_msg_seq++;
d952 21
a972 3
	if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
		log_warnx("%s: short recv", __func__);
		return (-1);
d974 1
d1118 1
a1118 1
	smsg.sadb_msg_seq = sadb_msg_seq++;
d1189 94
@


1.7
log
@Add support for the tap extension (ikev2 ... tap "enc1") that will
tell the kernel to send all IPsec traffic for derived SAs to the
specified enc(4) interface instead of enc0.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.6 2010/06/26 18:32:34 reyk Exp $	*/
d72 2
@


1.6
log
@Include the Id type in the generated SA tag that is passed to the
kernel, just like isakmpd does it.  In difference to isakmpd, the Id
type is printed in capital letters, eg. FQDN/foo.example.com, because
it is using the existing print_map() API.  For consistency, rename a
few Id types in grammar and code from the RFC-names to the
OpenBSD-style names; including RFC822_ADDR to UFQDN, IPV4_ADDR to just
IPV4, DER_ASN1_DN to ASN1_DN etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.5 2010/06/14 21:12:56 reyk Exp $	*/
d412 1
d415 1
d422 6
d545 7
d637 8
@


1.5
log
@Initial support for initiator mode which allows to run iked as a
"client" or to configure iked to iked (OpenBSD to OpenBSD) IKEv2 VPNs.

It currently only supports psk (pre-shared keys) and no certificates,
doesn't do any rekeying or SA timeouts, and needs more cleanup.  So it
is not quite production ready yet - but ready for simple tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.4 2010/06/10 14:08:37 reyk Exp $	*/
d1063 1
a1063 1
	case IKEV2_ID_RFC822_ADDR:
d1066 2
a1067 2
	case IKEV2_ID_IPV4_ADDR:
	case IKEV2_ID_IPV6_ADDR:
d1070 2
a1071 2
	case IKEV2_ID_DER_ASN1_DN:
	case IKEV2_ID_DER_ASN1_GN:
d1081 1
a1081 1
	if (print_id(id, sizeof(struct ikev2_id), idstr, sizeof(idstr)) == -1)
@


1.4
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.3 2010/06/10 12:04:21 reyk Exp $	*/
d983 1
a983 1
	if (sa->csa_dir == IPSP_DIRECTION_IN || sa->csa_loaded)
@


1.3
log
@simplify the pfkey code by adding a pfkey_write() function
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.2 2010/06/04 09:51:45 reyk Exp $	*/
d50 1
d105 40
d855 15
@


1.2
log
@Fix NAT-T detection to enable UDP encapsulation.  It was done before,
but not in the right order to run the IKEv2 NAT detection and check the
source port of the last IKE message which should be the NAT-T port 4500.

Tested with iked running on sparc64 and a NAT'ed windows box.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.49 2008/12/22 17:00:37 hshoexer Exp $	*/
d96 2
d99 1
d126 1
a126 2
	ssize_t			 n;
	int			 iov_cnt, len, ret = -1;
d352 1
a352 8
	len = smsg.sadb_msg_len * 8;
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		log_warn("%s: writev failed", __func__);
		goto done;
	} else if (n != len) {
		log_warnx("%s: short write", __func__);
		goto done;
	}
a353 3
	ret = pfkey_reply(sd, NULL, NULL);

 done:
d374 1
a374 2
	ssize_t			 n;
	int			 iov_cnt, len;
d584 1
a584 10
	len = smsg.sadb_msg_len * 8;
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		log_warn("%s: writev failed", __func__);
		return (-1);
	} else if (n != len) {
		log_warnx("%s: short write", __func__);
		return (-1);
	}

	return (pfkey_reply(sd, NULL, NULL));
d600 1
a600 1
	int			 iov_cnt, len, ret = 0;
d672 1
a672 10
	len = smsg.sadb_msg_len * 8;
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		log_warn("%s: writev failed", __func__);
		return (-1);
	} else if (n != len) {
		log_warnx("%s: short write", __func__);
		return (-1);
	}

	if ((ret = pfkey_reply(sd, &data, &n)) != 0)
d688 1
a688 1
	bzero(data, len);
d706 1
a706 2
	ssize_t			n;
	int			iov_cnt, len;
d806 9
a814 1
	len = smsg.sadb_msg_len * 8;
d819 1
a819 1
		log_warnx("%s: short write", __func__);
d823 1
a823 1
	return (pfkey_reply(sd, NULL, NULL));
d834 2
a835 2
		warnx("short read");
		return -1;
d838 4
a841 2
	if ((data = malloc(len)) == NULL)
		err(1, "pfkey_reply: malloc");
d843 1
a843 1
		warn("PF_KEY short read");
d846 1
a846 1
		return -1;
d859 2
a860 2
			warn("PF_KEY failed");
			return -1;
d863 1
a863 1
	return 0;
d976 1
a976 2
	ssize_t		n;
	int		iov_cnt, len;
d992 1
a992 13
	len = smsg.sadb_msg_len * 8;
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		log_warn("%s: writev failed", __func__);
		return (-1);
	}
	if (n != len) {
		log_warnx("%s: short write", __func__);
		return (-1);
	}
	if (pfkey_reply(sd, NULL, NULL) < 0)
		return (-1);

	return (0);
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d443 1
a443 1
	if (sa->csa_ikesa->sa_udpencap) {
@

