head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.6
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11;
locks; strict;
comment	@ * @;


1.46
date	2017.03.13.18.48.16;	author mikeb;	state Exp;
branches;
next	1.45;
commitid	yVaAm7edeFc8tc7a;

1.45
date	2017.03.13.15.01.59;	author mikeb;	state Exp;
branches;
next	1.44;
commitid	QoZe353lClEgHHmk;

1.44
date	2017.03.13.14.33.33;	author patrick;	state Exp;
branches;
next	1.43;
commitid	7TWpCOFlqUFXFrnD;

1.43
date	2017.03.13.14.19.08;	author patrick;	state Exp;
branches;
next	1.42;
commitid	yf3vbLQ7l3sjpNd2;

1.42
date	2016.06.01.11.16.41;	author patrick;	state Exp;
branches;
next	1.41;
commitid	LPZMTPg26WvdrIfQ;

1.41
date	2015.10.20.06.42.59;	author reyk;	state Exp;
branches;
next	1.40;
commitid	neP1N2HKB4ugTlne;

1.40
date	2015.10.01.10.59.23;	author reyk;	state Exp;
branches;
next	1.39;
commitid	J33WGURgnlsCAOFp;

1.39
date	2015.08.21.11.59.28;	author reyk;	state Exp;
branches;
next	1.38;
commitid	CNs9dXqQUQ09vB19;

1.38
date	2015.08.19.14.12.43;	author reyk;	state Exp;
branches;
next	1.37;
commitid	AVPSAC8CcLDWTPgE;

1.37
date	2015.07.07.19.13.31;	author markus;	state Exp;
branches;
next	1.36;
commitid	a1FLyyKqRzzs0TCl;

1.36
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	Uu5nFG3wCl0LACBb;

1.35
date	2014.11.07.14.12.57;	author mikeb;	state Exp;
branches;
next	1.34;
commitid	RWGetcohgd6oEuqg;

1.34
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.06.09.48.40;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.29.11.51.13;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2014.02.21.20.52.38;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2014.02.17.15.53.46;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.24.07.35.55;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.24.07.30.48;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2013.12.03.13.55.40;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.28.20.24.48;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.28.20.23.28;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.24.02.55.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.15.23.12.21;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2012.05.30.09.39.35;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.02.12.39.18;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.18.09.54.41;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.18.08.45.43;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.26.16.59.24;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.18.11.34.44;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.17.18.49.35;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.03.16.59.35;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.27.00.32.42;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.15.00.34.17;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.14.23.14.09;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.14.21.12.56;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.14.12.06.33;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.14.11.33.55;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.12.06.34;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.07.35.41;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Resolve simultaneous IKE SA rekeying

From and OK markus, OK reyk
@
text
@/*	$OpenBSD: policy.c,v 1.45 2017/03/13 15:01:59 mikeb Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2001 Daniel Hartmeier
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/tree.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <event.h>

#include "iked.h"
#include "ikev2.h"

static __inline int
	 sa_cmp(struct iked_sa *, struct iked_sa *);
static __inline int
	 user_cmp(struct iked_user *, struct iked_user *);
static __inline int
	 childsa_cmp(struct iked_childsa *, struct iked_childsa *);
static __inline int
	 flow_cmp(struct iked_flow *, struct iked_flow *);


void
policy_init(struct iked *env)
{
	TAILQ_INIT(&env->sc_policies);
	TAILQ_INIT(&env->sc_ocsp);
	RB_INIT(&env->sc_users);
	RB_INIT(&env->sc_sas);
	RB_INIT(&env->sc_activesas);
	RB_INIT(&env->sc_activeflows);
}

int
policy_lookup(struct iked *env, struct iked_message *msg)
{
	struct iked_policy	 pol;
	char			*s, idstr[IKED_ID_SIZE];


	if (msg->msg_sa != NULL && msg->msg_sa->sa_policy != NULL) {
		/* Existing SA with policy */
		msg->msg_policy = msg->msg_sa->sa_policy;
		goto found;
	}

	bzero(&pol, sizeof(pol));
	pol.pol_af = msg->msg_peer.ss_family;
	memcpy(&pol.pol_peer.addr, &msg->msg_peer, sizeof(msg->msg_peer));
	memcpy(&pol.pol_local.addr, &msg->msg_local, sizeof(msg->msg_local));
	if (msg->msg_id.id_type &&
	    ikev2_print_id(&msg->msg_id, idstr, IKED_ID_SIZE) == 0 &&
	    (s = strchr(idstr, '/')) != NULL) {
		pol.pol_peerid.id_type = msg->msg_id.id_type;
		pol.pol_peerid.id_length = strlen(s+1);
		strlcpy(pol.pol_peerid.id_data, s+1,
		    sizeof(pol.pol_peerid.id_data));
		log_debug("%s: peerid '%s'", __func__, s+1);
	}

	/* Try to find a matching policy for this message */
	if ((msg->msg_policy = policy_test(env, &pol)) != NULL)
		goto found;

	/* No matching policy found, try the default */
	if ((msg->msg_policy = env->sc_defaultcon) != NULL)
		goto found;

	/* No policy found */
	return (-1);

 found:
	return (0);
}

struct iked_policy *
policy_test(struct iked *env, struct iked_policy *key)
{
	struct iked_policy	*p = NULL, *pol = NULL;
	struct iked_flow	*flow = NULL, *flowkey;
	unsigned int		 cnt = 0;

	p = TAILQ_FIRST(&env->sc_policies);
	while (p != NULL) {
		cnt++;
		if (p->pol_flags & IKED_POLICY_SKIP)
			p = p->pol_skip[IKED_SKIP_FLAGS];
		else if (key->pol_af && p->pol_af &&
		    key->pol_af != p->pol_af)
			p = p->pol_skip[IKED_SKIP_AF];
		else if (key->pol_ipproto && p->pol_ipproto &&
		    key->pol_ipproto != p->pol_ipproto)
			p = p->pol_skip[IKED_SKIP_PROTO];
		else if (sockaddr_cmp((struct sockaddr *)&key->pol_peer.addr,
		    (struct sockaddr *)&p->pol_peer.addr,
		    p->pol_peer.addr_mask) != 0)
			p = p->pol_skip[IKED_SKIP_DST_ADDR];
		else if (sockaddr_cmp((struct sockaddr *)&key->pol_local.addr,
		    (struct sockaddr *)&p->pol_local.addr,
		    p->pol_local.addr_mask) != 0)
			p = p->pol_skip[IKED_SKIP_SRC_ADDR];
		else {
			/*
			 * Check if a specific flow is requested
			 * (eg. for acquire messages from the kernel)
			 * and find a matching flow.
			 */
			if (key->pol_nflows &&
			    (flowkey = RB_MIN(iked_flows,
			    &key->pol_flows)) != NULL &&
			    (flow = RB_FIND(iked_flows, &p->pol_flows,
			    flowkey)) == NULL) {
				p = TAILQ_NEXT(p, pol_entry);
				continue;
			}
			/* make sure the peer ID matches */
			if (key->pol_peerid.id_type &&
			    (key->pol_peerid.id_type != p->pol_peerid.id_type ||
			    memcmp(key->pol_peerid.id_data,
			    p->pol_peerid.id_data,
			    sizeof(key->pol_peerid.id_data)) != 0)) {
				p = TAILQ_NEXT(p, pol_entry);
				continue;
			}

			/* Policy matched */
			pol = p;

			if (pol->pol_flags & IKED_POLICY_QUICK)
				break;

			/* Continue to find last matching policy */
			p = TAILQ_NEXT(p, pol_entry);
		}
	}

	return (pol);
}

#define	IKED_SET_SKIP_STEPS(i)						\
	do {								\
		while (head[i] != cur) {				\
			head[i]->pol_skip[i] = cur;			\
			head[i] = TAILQ_NEXT(head[i], pol_entry);	\
		}							\
	} while (0)

/* This code is derived from pf_calc_skip_steps() from pf.c */
void
policy_calc_skip_steps(struct iked_policies *policies)
{
	struct iked_policy	*head[IKED_SKIP_COUNT], *cur, *prev;
	int			 i;

	cur = TAILQ_FIRST(policies);
	prev = cur;
	for (i = 0; i < IKED_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {
		if (cur->pol_flags & IKED_POLICY_SKIP)
			IKED_SET_SKIP_STEPS(IKED_SKIP_FLAGS);
		else if (cur->pol_af != AF_UNSPEC &&
		    prev->pol_af != AF_UNSPEC &&
		    cur->pol_af != prev->pol_af)
			IKED_SET_SKIP_STEPS(IKED_SKIP_AF);
		else if (cur->pol_ipproto && prev->pol_ipproto &&
		    cur->pol_ipproto != prev->pol_ipproto)
			IKED_SET_SKIP_STEPS(IKED_SKIP_PROTO);
		else if (IKED_ADDR_NEQ(&cur->pol_peer, &prev->pol_peer))
			IKED_SET_SKIP_STEPS(IKED_SKIP_DST_ADDR);
		else if (IKED_ADDR_NEQ(&cur->pol_local, &prev->pol_local))
			IKED_SET_SKIP_STEPS(IKED_SKIP_SRC_ADDR);

		prev = cur;
		cur = TAILQ_NEXT(cur, pol_entry);
	}
	for (i = 0; i < IKED_SKIP_COUNT; ++i)
		IKED_SET_SKIP_STEPS(i);
}

void
policy_ref(struct iked *env, struct iked_policy *pol)
{
	pol->pol_refcnt++;
	pol->pol_flags |= IKED_POLICY_REFCNT;
}

void
policy_unref(struct iked *env, struct iked_policy *pol)
{
	if (pol == NULL || (pol->pol_flags & IKED_POLICY_REFCNT) == 0)
		return;
	if (--(pol->pol_refcnt) <= 0)
		config_free_policy(env, pol);
	else {
		struct iked_sa		*tmp;
		int			 count = 0;

		TAILQ_FOREACH(tmp, &pol->pol_sapeers, sa_peer_entry)
			count++;
		if (count != pol->pol_refcnt)
			log_warnx("%s: ERROR pol %p pol_refcnt %d != count %d",
			    __func__, pol, pol->pol_refcnt, count);
	}
}

void
sa_state(struct iked *env, struct iked_sa *sa, int state)
{
	const char		*a;
	const char		*b;
	int			 ostate = sa->sa_state;

	a = print_map(ostate, ikev2_state_map);
	b = print_map(state, ikev2_state_map);

	sa->sa_state = state;
	if (ostate != IKEV2_STATE_INIT &&
	    !sa_stateok(sa, state)) {
		log_debug("%s: cannot switch: %s -> %s", __func__, a, b);
		sa->sa_state = ostate;
	} else if (ostate != sa->sa_state) {
		switch (state) {
		case IKEV2_STATE_ESTABLISHED:
		case IKEV2_STATE_CLOSED:
			log_info("%s: %s -> %s from %s to %s policy '%s'",
			    __func__, a, b,
			    print_host((struct sockaddr *)&sa->sa_peer.addr,
			    NULL, 0),
			    print_host((struct sockaddr *)&sa->sa_local.addr,
			    NULL, 0),
			    sa->sa_policy ? sa->sa_policy->pol_name :
			    "<unknown>");
			break;
		default:
			log_debug("%s: %s -> %s", __func__, a, b);
			break;
		}
	}

}

void
sa_stateflags(struct iked_sa *sa, unsigned int flags)
{
	unsigned int	require;

	if (sa->sa_state > IKEV2_STATE_SA_INIT)
		require = sa->sa_statevalid;
	else
		require = sa->sa_stateinit;

	log_debug("%s: 0x%04x -> 0x%04x %s (required 0x%04x %s)", __func__,
	    sa->sa_stateflags, sa->sa_stateflags | flags,
	    print_bits(sa->sa_stateflags | flags, IKED_REQ_BITS), require,
	    print_bits(require, IKED_REQ_BITS));

	sa->sa_stateflags |= flags;
}

int
sa_stateok(struct iked_sa *sa, int state)
{
	unsigned int	 require;

	if (sa->sa_state < state)
		return (0);

	if (state == IKEV2_STATE_SA_INIT)
		require = sa->sa_stateinit;
	else
		require = sa->sa_statevalid;

	if (state == IKEV2_STATE_SA_INIT ||
	    state == IKEV2_STATE_VALID ||
	    state == IKEV2_STATE_EAP_VALID) {
		log_debug("%s: %s flags 0x%04x, require 0x%04x %s", __func__,
		    print_map(state, ikev2_state_map),
		    (sa->sa_stateflags & require), require,
		    print_bits(require, IKED_REQ_BITS));

		if ((sa->sa_stateflags & require) != require)
			return (0);	/* not ready, ignore */
	}
	return (1);
}

struct iked_sa *
sa_new(struct iked *env, uint64_t ispi, uint64_t rspi,
    unsigned int initiator, struct iked_policy *pol)
{
	struct iked_sa	*sa;
	struct iked_sa	*old;
	struct iked_id	*localid;
	unsigned int	 diff;

	if ((ispi == 0 && rspi == 0) ||
	    (sa = sa_lookup(env, ispi, rspi, initiator)) == NULL) {
		/* Create new SA */
		if (!initiator && ispi == 0) {
			log_debug("%s: cannot create responder IKE SA w/o ispi",
			    __func__);
			return (NULL);
		}
		sa = config_new_sa(env, initiator);
		if (sa == NULL) {
			log_debug("%s: failed to allocate IKE SA", __func__);
			return (NULL);
		}
		if (!initiator)
			sa->sa_hdr.sh_ispi = ispi;
		old = RB_INSERT(iked_sas, &env->sc_sas, sa);
		if (old && old != sa) {
			log_warnx("%s: duplicate IKE SA", __func__);
			config_free_sa(env, sa);
			return (NULL);
		}
	}
	/* Update rspi in the initator case */
	if (initiator && sa->sa_hdr.sh_rspi == 0 && rspi)
		sa->sa_hdr.sh_rspi = rspi;

	if (pol == NULL && sa->sa_policy == NULL)
		fatalx("%s: sa %p no policy", __func__, sa);
	else if (sa->sa_policy == NULL) {
		/* Increment refcount if the policy has refcounting enabled. */
		if (pol->pol_flags & IKED_POLICY_REFCNT) {
			log_info("%s: sa %p old pol %p pol_refcnt %d",
			    __func__, sa, pol, pol->pol_refcnt);
			policy_ref(env, pol);
		}
		sa->sa_policy = pol;
		TAILQ_INSERT_TAIL(&pol->pol_sapeers, sa, sa_peer_entry);
	} else
		pol = sa->sa_policy;

	sa->sa_statevalid = IKED_REQ_AUTH|IKED_REQ_AUTHVALID|IKED_REQ_SA;
	if (pol != NULL && pol->pol_auth.auth_eap) {
		sa->sa_statevalid |= IKED_REQ_CERT|IKED_REQ_EAPVALID;
	} else if (pol != NULL && pol->pol_auth.auth_method !=
	    IKEV2_AUTH_SHARED_KEY_MIC) {
		sa->sa_statevalid |= IKED_REQ_CERTVALID|IKED_REQ_CERT;
	}

	if (initiator) {
		localid = &sa->sa_iid;
		diff = IKED_REQ_CERTVALID|IKED_REQ_AUTHVALID|IKED_REQ_SA|
		    IKED_REQ_EAPVALID;
		sa->sa_stateinit = sa->sa_statevalid & ~diff;
		sa->sa_statevalid = sa->sa_statevalid & diff;
	} else
		localid = &sa->sa_rid;

	if (!ibuf_length(localid->id_buf) && pol != NULL &&
	    ikev2_policy2id(&pol->pol_localid, localid, 1) != 0) {
		log_debug("%s: failed to get local id", __func__);
		sa_free(env, sa);
		return (NULL);
	}

	return (sa);
}

void
sa_free(struct iked *env, struct iked_sa *sa)
{
	log_debug("%s: ispi %s rspi %s", __func__,
	    print_spi(sa->sa_hdr.sh_ispi, 8),
	    print_spi(sa->sa_hdr.sh_rspi, 8));

	/* IKE rekeying running? */
	if (sa->sa_nexti) {
		RB_REMOVE(iked_sas, &env->sc_sas, sa->sa_nexti);
		config_free_sa(env, sa->sa_nexti);
	}
	if (sa->sa_nextr) {
		RB_REMOVE(iked_sas, &env->sc_sas, sa->sa_nextr);
		config_free_sa(env, sa->sa_nextr);
	}
	RB_REMOVE(iked_sas, &env->sc_sas, sa);
	config_free_sa(env, sa);
}

void
sa_free_flows(struct iked *env, struct iked_saflows *head)
{
	struct iked_flow	*flow, *next;

	for (flow = TAILQ_FIRST(head); flow != NULL; flow = next) {
		next = TAILQ_NEXT(flow, flow_entry);

		log_debug("%s: free %p", __func__, flow);

		if (flow->flow_loaded)
			RB_REMOVE(iked_flows, &env->sc_activeflows, flow);
		TAILQ_REMOVE(head, flow, flow_entry);
		(void)pfkey_flow_delete(env->sc_pfkey, flow);
		flow_free(flow);
	}
}


int
sa_address(struct iked_sa *sa, struct iked_addr *addr,
    struct sockaddr_storage *peer)
{
	bzero(addr, sizeof(*addr));
	addr->addr_af = peer->ss_family;
	addr->addr_port = htons(socket_getport((struct sockaddr *)peer));
	memcpy(&addr->addr, peer, sizeof(*peer));
	if (socket_af((struct sockaddr *)&addr->addr, addr->addr_port) == -1) {
		log_debug("%s: invalid address", __func__);
		return (-1);
	}
	return (0);
}

void
childsa_free(struct iked_childsa *csa)
{
	struct iked_childsa *csb;

	if (csa->csa_children) {
		/* XXX should not happen */
		log_warnx("%s: trying to remove CSA %p children %u",
		    __func__, csa, csa->csa_children);
		return;
	}
	if (csa->csa_parent)
		csa->csa_parent->csa_children--;
	if ((csb = csa->csa_peersa) != NULL)
		csb->csa_peersa = NULL;
	ibuf_release(csa->csa_encrkey);
	ibuf_release(csa->csa_integrkey);
	free(csa);
}

struct iked_childsa *
childsa_lookup(struct iked_sa *sa, uint64_t spi, uint8_t protoid)
{
	struct iked_childsa	*csa;

	if (sa == NULL || spi == 0 || protoid == 0)
		return (NULL);

	TAILQ_FOREACH(csa, &sa->sa_childsas, csa_entry) {
		if (csa->csa_spi.spi_protoid == protoid &&
		    (csa->csa_spi.spi == spi))
			break;
	}
	return (csa);
}

void
flow_free(struct iked_flow *flow)
{
	free(flow);
}

struct iked_sa *
sa_lookup(struct iked *env, uint64_t ispi, uint64_t rspi,
    unsigned int initiator)
{
	struct iked_sa	*sa, key;

	key.sa_hdr.sh_ispi = ispi;
	/* key.sa_hdr.sh_rspi = rspi; */
	key.sa_hdr.sh_initiator = initiator;

	if ((sa = RB_FIND(iked_sas, &env->sc_sas, &key)) != NULL) {
		gettimeofday(&sa->sa_timeused, NULL);

		/* Validate if SPIr matches */
		if ((sa->sa_hdr.sh_rspi != 0) &&
		    (rspi != 0) &&
		    (sa->sa_hdr.sh_rspi != rspi))
			return (NULL);
	}

	return (sa);
}

static __inline int
sa_cmp(struct iked_sa *a, struct iked_sa *b)
{
	if (a->sa_hdr.sh_initiator > b->sa_hdr.sh_initiator)
		return (-1);
	if (a->sa_hdr.sh_initiator < b->sa_hdr.sh_initiator)
		return (1);

	if (a->sa_hdr.sh_ispi > b->sa_hdr.sh_ispi)
		return (-1);
	if (a->sa_hdr.sh_ispi < b->sa_hdr.sh_ispi)
		return (1);

#if 0
	/* Responder SPI is not yet set in the local IKE SADB */
	if ((b->sa_type == IKED_SATYPE_LOCAL && b->sa_hdr.sh_rspi == 0) ||
	    (a->sa_type == IKED_SATYPE_LOCAL && a->sa_hdr.sh_rspi == 0))
		return (0);

	if (a->sa_hdr.sh_rspi > b->sa_hdr.sh_rspi)
		return (-1);
	if (a->sa_hdr.sh_rspi < b->sa_hdr.sh_rspi)
		return (1);
#endif

	return (0);
}

static __inline int
sa_addrpool_cmp(struct iked_sa *a, struct iked_sa *b)
{
	return (sockaddr_cmp((struct sockaddr *)&a->sa_addrpool->addr,
	    (struct sockaddr *)&b->sa_addrpool->addr, -1));
}

static __inline int
sa_addrpool6_cmp(struct iked_sa *a, struct iked_sa *b)
{
	return (sockaddr_cmp((struct sockaddr *)&a->sa_addrpool6->addr,
	    (struct sockaddr *)&b->sa_addrpool6->addr, -1));
}

struct iked_user *
user_lookup(struct iked *env, const char *user)
{
	struct iked_user	 key;

	if (strlcpy(key.usr_name, user,
	    sizeof(key.usr_name)) >= sizeof(key.usr_name))
		return (NULL);

	return (RB_FIND(iked_users, &env->sc_users, &key));
}

static __inline int
user_cmp(struct iked_user *a, struct iked_user *b)
{
	return (strcmp(a->usr_name, b->usr_name));
}

static __inline int
childsa_cmp(struct iked_childsa *a, struct iked_childsa *b)
{
	if (a->csa_spi.spi > b->csa_spi.spi)
		return (1);
	if (a->csa_spi.spi < b->csa_spi.spi)
		return (-1);
	return (0);
}

static __inline int
addr_cmp(struct iked_addr *a, struct iked_addr *b, int useports)
{
	int		diff = 0;

	diff = sockaddr_cmp((struct sockaddr *)&a->addr,
	    (struct sockaddr *)&b->addr, 128);
	if (!diff)
		diff = (int)a->addr_mask - (int)b->addr_mask;
	if (!diff && useports)
		diff = a->addr_port - b->addr_port;

	return (diff);
}

static __inline int
flow_cmp(struct iked_flow *a, struct iked_flow *b)
{
	int		diff = 0;

	if (!diff)
		diff = (int)a->flow_ipproto - (int)b->flow_ipproto;
	if (!diff)
		diff = (int)a->flow_saproto - (int)b->flow_saproto;
	if (!diff)
		diff = (int)a->flow_dir - (int)b->flow_dir;
	if (!diff)
		diff = addr_cmp(&a->flow_dst, &b->flow_dst, 1);
	if (!diff)
		diff = addr_cmp(&a->flow_src, &b->flow_src, 1);

	return (diff);
}

int
flow_equal(struct iked_flow *a, struct iked_flow *b)
{
	return (flow_cmp(a, b) == 0);
}

RB_GENERATE(iked_sas, iked_sa, sa_entry, sa_cmp);
RB_GENERATE(iked_addrpool, iked_sa, sa_addrpool_entry, sa_addrpool_cmp);
RB_GENERATE(iked_addrpool6, iked_sa, sa_addrpool6_entry, sa_addrpool6_cmp);
RB_GENERATE(iked_users, iked_user, usr_entry, user_cmp);
RB_GENERATE(iked_activesas, iked_childsa, csa_node, childsa_cmp);
RB_GENERATE(iked_flows, iked_flow, flow_node, flow_cmp);
@


1.45
log
@When freeing a Child SA make sure it's peer no longer points to it

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.44 2017/03/13 14:33:33 patrick Exp $	*/
d395 7
a401 3
	if (sa->sa_next) {
		RB_REMOVE(iked_sas, &env->sc_sas, sa->sa_next);
		config_free_sa(env, sa->sa_next);
@


1.44
log
@flow_cmp() must compare the same flow-attributes as the kernel,
otherwise we never can keep the in-daemon and the in-kernel idea
of flows in sync and iked ends up deleting flows that are still
in use.  Make use of flow_cmp() and a new flow_equal() instead
of handcrafting the compare in an if.

ok markus@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.43 2017/03/13 14:19:08 patrick Exp $	*/
d440 2
d450 2
@


1.43
log
@We need to call policy_ref() for policies that have refcounting
enabled. Refcounting is enabled when a policy is removed during
'ikectl reload' and still has SAs point to it. On IKESA rekeying
such a policy will be referenced by the new IKESA, so we need to
adjust the refcount -- otherwise the policies get free()d too
early and we will crash at some point.

ok markus@@ mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.42 2016/06/01 11:16:41 patrick Exp $	*/
d588 6
a593 2
	if (a->flow_peer && b->flow_peer)
		diff = addr_cmp(a->flow_peer, b->flow_peer, 0);
a597 2
	if (!diff && a->flow_dir && b->flow_dir)
		diff = (int)a->flow_dir - (int)b->flow_dir;
d600 6
@


1.42
log
@Implement a second address pool specifically for IPv6, so that
clients can be given an IPv4 and IPv6 address at the same time,
thus enabling dual stack usage.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.41 2015/10/20 06:42:59 reyk Exp $	*/
d346 9
a354 1
	if (sa->sa_policy == NULL) {
@


1.41
log
@Fix ocsp by adding a missing TAILQ_INIT().

Confirmed by markus@@ with an identical diff
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.40 2015/10/01 10:59:23 reyk Exp $	*/
d525 7
d594 1
@


1.40
log
@Fix interoperability with Apple iOS9: If we don't get a (valid)
CERTREQ but a CERT, respond with a local CERT that was selected based
on our own policy instead of leaving it out.  This seems to be valid
with the RFC that makes the CERTREQ optional and allows to ignore it
or to apply an own policy.

OK mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.39 2015/08/21 11:59:28 reyk Exp $	*/
d50 1
@


1.39
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.38 2015/08/19 14:12:43 reyk Exp $	*/
d275 1
a275 1
	log_debug("%s: 0x%02x -> 0x%02x %s (required 0x%02x %s)", __func__,
d299 1
a299 1
		log_debug("%s: %s flags 0x%02x, require 0x%02x %s", __func__,
@


1.38
log
@spacing (no binary change, verified with checksums)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.37 2015/07/07 19:13:31 markus Exp $	*/
d103 1
a103 1
	u_int			 cnt = 0;
d266 1
a266 1
sa_stateflags(struct iked_sa *sa, u_int flags)
d268 1
a268 1
	u_int	require;
d286 1
a286 1
	u_int	 require;
d311 2
a312 2
sa_new(struct iked *env, u_int64_t ispi, u_int64_t rspi,
    u_int initiator, struct iked_policy *pol)
d317 1
a317 1
	u_int		 diff;
d445 1
a445 1
childsa_lookup(struct iked_sa *sa, u_int64_t spi, u_int8_t protoid)
d467 2
a468 2
sa_lookup(struct iked *env, u_int64_t ispi, u_int64_t rspi,
    u_int initiator)
@


1.37
log
@repair policy-ikesa-linking by replacing the broken RB_TREE w/TAILQ
(e.g. the policy might be used-after-free on 'ikectl reconfig')
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.36 2015/01/16 06:39:58 deraadt Exp $	*/
d234 1
a234 1
	int 			ostate = sa->sa_state;
@


1.36
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.35 2014/11/07 14:12:57 mikeb Exp $	*/
d217 10
d345 1
a345 1
	if (sa->sa_policy == NULL)
d347 2
a348 1
	else
d415 1
a415 1
    struct sockaddr_storage *peer, int initiator)
a416 7
	struct iked_policy	*pol = sa->sa_policy;

	if (sa->sa_state != IKEV2_STATE_CLOSING && pol == NULL) {
		log_debug("%s: missing policy", __func__);
		return (-1);
	}

a424 9

	if (addr == &sa->sa_peer && pol) {
		/* XXX Re-insert node into the tree */
		RB_REMOVE(iked_sapeers, &pol->pol_sapeers, sa);
		memcpy(&sa->sa_polpeer, initiator ? &pol->pol_peer :
		    &sa->sa_peer, sizeof(sa->sa_polpeer));
		RB_INSERT(iked_sapeers, &pol->pol_sapeers, sa);
	}

a516 16
struct iked_sa *
sa_peer_lookup(struct iked_policy *pol, struct sockaddr_storage *peer)
{
	struct iked_sa	 key;

	memcpy(&key.sa_polpeer.addr, peer, sizeof(*peer));
	return (RB_FIND(iked_sapeers, &pol->pol_sapeers, &key));
}

static __inline int
sa_peer_cmp(struct iked_sa *a, struct iked_sa *b)
{
	return (sockaddr_cmp((struct sockaddr *)&a->sa_polpeer.addr,
	    (struct sockaddr *)&b->sa_polpeer.addr, -1));
}

a584 1
RB_GENERATE(iked_sapeers, iked_sa, sa_peer_entry, sa_peer_cmp);
@


1.35
log
@Fixup a few problems with EAP state transition

First of all we don't need to satisfy valid EAP state flags for
IKEV2_STATE_EAP as it's an initial EAP exchange state.  Then
when waiting for the "ca" process to construct our AUTH payload
we need to bail while sa_localauth is not available.  With this
change Win7 is able to establish the the tunnel again.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.34 2014/05/06 10:24:22 markus Exp $	*/
a19 1
#include <sys/param.h>
@


1.34
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.33 2014/05/06 09:48:40 markus Exp $	*/
d289 1
a289 2
	    state == IKEV2_STATE_EAP_VALID ||
	    state == IKEV2_STATE_EAP) {
@


1.33
log
@cleanup IKE-SA tree handling (fixes repeated-insert & double-remove)

sa_new() always re-inserts an SA into the SA tree. in case of a key
collision it would try to free the new SA. While doing that it would
accidentially free the existing SA, since config_free_sa() does
RB_REMOVE() uncoditionally.  This change fixes this by:
a) moving the responsibility for RB_REMOVE() to CALLER of config_free_sa() and
b) by calling config_free_sa() instead of sa_free() from sa_new()
It also changes to code to NEVER re-add an SA to the tree. So
RB_INSERT() is ONLY called once per SA. The code also makes sure
that there is always a KEY defined for this tree (ispi).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.32 2014/04/29 11:51:13 markus Exp $	*/
d245 2
a246 1
			    sa->sa_policy->pol_name);
d376 5
d410 2
a411 2
	if (pol == NULL) {
		log_debug("%s: invalid policy", __func__);
d424 1
a424 1
	if (addr == &sa->sa_peer) {
d480 1
a480 1
	key.sa_hdr.sh_rspi = rspi;
@


1.32
log
@make sure the state machine only advances if the AUTH payload has
been verified; with & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.31 2014/02/21 20:52:38 markus Exp $	*/
d313 5
d319 12
d332 4
a335 4
	if (sa == NULL) {
		log_debug("%s: failed to get sa", __func__);
		return (NULL);
	}
a364 13
	if (sa->sa_hdr.sh_ispi == 0)
		sa->sa_hdr.sh_ispi = ispi;
	if (sa->sa_hdr.sh_rspi == 0)
		sa->sa_hdr.sh_rspi = rspi;

	/* Re-insert node into the tree */
	old = RB_INSERT(iked_sas, &env->sc_sas, sa);
	if (old && old != sa) {
		log_debug("%s: duplicate ikesa", __func__);
		sa_free(env, sa);
		return (NULL);
	}

d375 1
@


1.31
log
@support rekeying for IPCOMP; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.30 2014/02/17 15:53:46 markus Exp $	*/
d225 1
d227 1
a227 1
	a = print_map(sa->sa_state, ikev2_state_map);
d230 6
a235 1
	if (state > sa->sa_state) {
a252 1
	sa->sa_state = state;
d288 1
d324 1
a324 1
	sa->sa_statevalid = IKED_REQ_AUTH|IKED_REQ_SA;
d326 1
a326 1
		sa->sa_statevalid |= IKED_REQ_CERT;
d329 1
a329 1
		sa->sa_statevalid |= IKED_REQ_VALID|IKED_REQ_CERT;
d334 2
a335 1
		diff = IKED_REQ_VALID|IKED_REQ_SA;
@


1.30
log
@interpret 'config address net/prefix' as a pool of addresses and
randomly choose the address for CFG_REQUEST. this address will be used
to replace 0.0.0.0/32 in the specified flow. e.g.
> ikev2 passive esp from 192.168.1.0/24 to 0.0.0.0 \
>     config address 192.168.10.200/24
will assign an address between 192.168.10.200 and 192.168.10.254
and replace 0.0.0.0 with this address.
ok mikeb@@ on older version of this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.29 2014/01/24 07:35:55 markus Exp $	*/
d418 1
a418 1
childsa_free(struct iked_childsa *sa)
d420 11
a430 3
	ibuf_release(sa->csa_encrkey);
	ibuf_release(sa->csa_integrkey);
	free(sa);
@


1.29
log
@re-lookup the policy as soon as we have the ID of the peer (destid)
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.28 2014/01/24 07:30:48 markus Exp $	*/
d514 7
d583 1
@


1.28
log
@make sure sa_lookup() can actually find SAs; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.27 2013/12/03 13:55:40 markus Exp $	*/
d61 2
d74 9
d136 9
@


1.27
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.26 2013/11/28 20:24:48 markus Exp $	*/
d453 4
a456 2
	if (a->sa_hdr.sh_initiator != b->sa_hdr.sh_initiator)
		return (-2);
@


1.26
log
@sa_lookup: don't compare with sh_rspi if rspi is not set

otherwise this can happen: initiator retransmits SA_INIT
with rspi of zero, sa_lookup for responder fails, and
it creates a new SA, that cannot be inserted in the SA tree
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.25 2013/11/28 20:23:28 markus Exp $	*/
d215 4
a218 2
			    print_host(&sa->sa_peer.addr, NULL, 0),
			    print_host(&sa->sa_local.addr, NULL, 0),
d379 1
a379 1
	addr->addr_port = htons(socket_getport(peer));
@


1.25
log
@sa_new(): discard & free duplicate IKESAs; ok mibek@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.24 2013/10/24 02:55:50 deraadt Exp $	*/
d440 1
@


1.24
log
@no need for netinet/ip_var.h (and friends)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.23 2013/01/08 10:38:19 reyk Exp $	*/
d278 1
d325 6
a330 1
	RB_INSERT(iked_sas, &env->sc_sas, sa);
@


1.23
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.22 2012/12/15 23:12:21 reyk Exp $	*/
a24 7

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
@


1.22
log
@Don't dereference NULL pointers (and some cleanup here).
@
text
@d1 1
a1 2
/*	$OpenBSD: policy.c,v 1.21 2012/09/18 12:07:59 reyk Exp $	*/
/*	$vantronix: policy.c,v 1.29 2010/05/28 15:34:35 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010, 2011 Reyk Floeter <reyk@@openbsd.org>
@


1.21
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.20 2012/05/30 09:39:35 mikeb Exp $	*/
d319 1
a319 1
	if (!ibuf_length(localid->id_buf) &&
a474 2
RB_GENERATE(iked_sas, iked_sa, sa_entry, sa_cmp);

a490 2
RB_GENERATE(iked_sapeers, iked_sa, sa_peer_entry, sa_peer_cmp);

a508 2
RB_GENERATE(iked_users, iked_user, usr_entry, user_cmp);

a518 2
RB_GENERATE(iked_activesas, iked_childsa, csa_node, childsa_cmp);

d551 4
@


1.20
log
@when changing peer's address in the SA, remove the old entry from the
tree before doing the actual change, otherwise we won't remove anything
for real.  also add the newly created SA to the peer's tree so that
initiator timer will treat the ike policy as "in progress".
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.19 2011/05/02 12:39:18 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010, 2011 Reyk Floeter <reyk@@vantronix.net>
@


1.19
log
@store the peer address as it was specified in the policy in the
tree that is used to figure out whether the policy is active or
not.  makes active sa lookup via policy work for nat traversal.
problem was reported and fix was tested by sthen, ok sthen, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.18 2011/04/18 09:54:41 reyk Exp $	*/
d387 2
a390 2
		/* XXX Re-insert node into the tree */
		(void)RB_REMOVE(iked_sapeers, &pol->pol_sapeers, sa);
@


1.18
log
@Improve the iked acquire mode peer <-> policy matching.  This change
picks the peer from the acquire message and allows to match masked
peers in the policies like "peer any" or "peer 10.0.0.0/8" instead of
requiring exactly matching peer specifications.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.17 2011/04/18 08:45:43 reyk Exp $	*/
d368 1
a368 1
    struct sockaddr_storage *peer)
d387 2
d482 1
a482 1
	memcpy(&key.sa_peer.addr, peer, sizeof(*peer));
d489 2
a490 2
	return (sockaddr_cmp((struct sockaddr *)&a->sa_peer.addr,
	    (struct sockaddr *)&b->sa_peer.addr, -1));
@


1.17
log
@When the kernel wants to acquire an SA for an unknown flow, lookup a
matching policy and init a new IKE SA.  This adds support for "acquire mode"
from static flows.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.16 2011/01/26 16:59:24 mikeb Exp $	*/
d126 1
a126 2
			 * and find a matching flow.  The policy also
			 * needs to have a valid peer address specified.
a130 2
			    (p->pol_peer.addr_net ||
			    p->pol_peer.addr_af == AF_UNSPEC ||
d132 1
a132 1
			    flowkey)) == NULL)) {
@


1.16
log
@get rid of acquire flows completely, as they tend to pass traffic
when there's no sa established (as pointed out by reyk).  instead
use require mode feature to send acquires from the kernel.  this
allows us to get rid of the code that changes flow mode to acquire
and keep all installed flows in the tree and save up on some code
that deals with renegotiation.  also several entities were renamed
(iked_acqflows -> iked_activeflows, iked_ipsecsas -> iked_activesas,
ikev2_acquire -> ikev2_acquire_sa).   ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.15 2011/01/21 11:56:00 reyk Exp $	*/
d100 1
d123 17
d146 1
a146 1
			/* Continue to find last matchin policy */
d350 19
d548 2
a549 1
	diff = addr_cmp(a->flow_peer, b->flow_peer, 0);
d554 1
a554 1
	if (!diff)
d560 1
a560 1
RB_GENERATE(iked_activeflows, iked_flow, flow_node, flow_cmp);
@


1.15
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.14 2011/01/18 11:34:44 mikeb Exp $	*/
d61 2
a62 2
	RB_INIT(&env->sc_ipsecsas);
	RB_INIT(&env->sc_acqflows);
d489 1
a489 1
RB_GENERATE(iked_ipsecsas, iked_childsa, csa_ipsec_entry, childsa_cmp);
d522 1
a522 1
RB_GENERATE(iked_acqflows, iked_flow, flow_acq_entry, flow_cmp);
@


1.14
log
@reyk noticed that my rb-tree-fu is not that great.  fixup compare function
to do exact matches;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.13 2011/01/17 18:49:35 mikeb Exp $	*/
d5 2
a6 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
a45 2
	 policy_cmp(struct iked_policy *, struct iked_policy *);
static __inline int
d58 1
a58 1
	RB_INIT(&env->sc_policies);
d77 3
a79 2
	memcpy(&pol.pol_peer, &msg->msg_peer, sizeof(pol.pol_peer));
	memcpy(&pol.pol_local, &msg->msg_local, sizeof(pol.pol_local));
d82 1
a82 2
	if ((msg->msg_policy =
	    RB_FIND(iked_policies, &env->sc_policies, &pol)) != NULL)
d96 2
a97 2
static __inline int
policy_cmp(struct iked_policy *a, struct iked_policy *b)
d99 36
a134 1
	int	 ret;
d136 7
a142 2
	if (b->pol_flags & IKED_POLICY_DEFAULT)
		return (-2);
d144 25
a168 6
	if ((ret = sockaddr_cmp((struct sockaddr *)&a->pol_peer,
	    (struct sockaddr *)&b->pol_peer, b->pol_peermask)) != 0)
		return (ret);
	if ((ret = sockaddr_cmp((struct sockaddr *)&a->pol_local,
	    (struct sockaddr *)&b->pol_local, b->pol_localmask)) != 0)
		return (ret);
d170 5
a174 1
	return (0);
a191 2

RB_GENERATE(iked_policies, iked_policy, pol_entry, policy_cmp);
@


1.13
log
@Add initial acquire mode support and use it whenever Windows peers decide
to drop Child SA based on the inactivity timer.  In this case we instruct
the kernel to send us an acquire message upon receiving a packet for those
hosts and initiate a Child SA creation exchange ourselves.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.12 2010/12/22 16:22:27 mikeb Exp $	*/
a434 1
	int		prefix;
a435 1
	prefix = MAX(a->addr_mask, b->addr_mask);
d437 3
a439 1
	    (struct sockaddr *)&b->addr, prefix);
@


1.12
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.11 2010/07/03 16:59:35 reyk Exp $	*/
d52 3
d63 1
d430 33
@


1.11
log
@Better non-debug logging messages when a session is established/closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.10 2010/06/27 00:32:42 reyk Exp $	*/
d50 2
d59 1
d305 16
d414 12
@


1.10
log
@print the required bits as a string
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.9 2010/06/15 00:34:17 reyk Exp $	*/
d135 16
a150 1
	log_info("%s: %s -> %s", __func__, a, b);
@


1.9
log
@only compare the SPIi in the SA tree
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.8 2010/06/14 23:14:09 reyk Exp $	*/
d149 1
a149 1
	log_debug("%s: 0x%02x -> 0x%02x %s (required 0x%02x)", __func__,
d151 2
a152 2
	    print_bits(sa->sa_stateflags | flags,
	    IKED_REQ_BITS), require);
@


1.8
log
@Initiator mode with certificates;  needs more work but works.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.7 2010/06/14 21:12:56 reyk Exp $	*/
a221 5
	if (sa->sa_hdr.sh_ispi == 0)
		sa->sa_hdr.sh_ispi = ispi;
	if (sa->sa_hdr.sh_rspi == 0)
		sa->sa_hdr.sh_rspi = rspi;

d229 5
a234 1
	(void)RB_REMOVE(iked_sas, &env->sc_sas, sa);
d271 1
a271 1
		/* Re-insert node into the tree */
d303 1
a303 1
	if ((sa = RB_FIND(iked_sas, &env->sc_sas, &key)) != NULL)
d306 6
d326 1
d336 1
@


1.7
log
@Initial support for initiator mode which allows to run iked as a
"client" or to configure iked to iked (OpenBSD to OpenBSD) IKEv2 VPNs.

It currently only supports psk (pre-shared keys) and no certificates,
doesn't do any rekeying or SA timeouts, and needs more cleanup.  So it
is not quite production ready yet - but ready for simple tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.6 2010/06/14 12:06:33 reyk Exp $	*/
d142 7
d152 1
a152 1
	    IKED_REQ_BITS), sa->sa_staterequire);
d160 2
d164 8
a171 1
	if (state == IKEV2_STATE_VALID ||
d173 4
a176 5
		log_debug("%s: flags 0x%02x require 0x%02x %s", __func__,
		    (sa->sa_stateflags & sa->sa_staterequire),
		    sa->sa_staterequire,
		    print_bits(sa->sa_staterequire,
		    IKED_REQ_BITS));
d178 1
a178 2
		if ((sa->sa_stateflags & sa->sa_staterequire) !=
		    sa->sa_staterequire)
d190 1
d206 1
a206 1
	sa->sa_staterequire = IKED_REQ_AUTH|IKED_REQ_SA;
d208 1
a208 1
		sa->sa_staterequire |= IKED_REQ_CERT;
d211 1
a211 1
		sa->sa_staterequire |= IKED_REQ_VALID|IKED_REQ_CERT;
d214 8
a225 5

	if (initiator)
		localid = &sa->sa_iid;
	else
		localid = &sa->sa_rid;
@


1.6
log
@remove policy lookup debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.5 2010/06/14 11:33:55 reyk Exp $	*/
d191 14
a204 1
	if (initiator) {
d206 1
a206 1
	} else {
d209 2
a210 14
		sa->sa_staterequire = IKED_REQ_AUTH|IKED_REQ_SA;
		if (pol != NULL && pol->pol_auth.auth_eap) {
			sa->sa_staterequire |= IKED_REQ_CERT;
		} else if (pol != NULL && pol->pol_auth.auth_method !=
		    IKEV2_AUTH_SHARED_KEY_MIC) {
			sa->sa_staterequire |= IKED_REQ_VALID|IKED_REQ_CERT;
		}
		if (sa->sa_hdr.sh_ispi == 0)
			sa->sa_hdr.sh_ispi = ispi;
		if (sa->sa_hdr.sh_rspi == 0)
			sa->sa_hdr.sh_rspi = rspi;
	}

	if (ikev2_policy2id(&pol->pol_localid, localid, 1) != 0) {
@


1.5
log
@restructure code a bit to move closer to initiator mode:
- split responder/initiator- specific code into different functions and use
shared functions for common stuff.
- first parse the received message and store information in the temporary
message struct instead of modifying the ike sa in the parsing code directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.4 2010/06/14 08:10:32 reyk Exp $	*/
a293 6
	log_debug("%s: ispi %s rspi %s <-> ispi %s rspi %s", __func__,
	    print_spi(a->sa_hdr.sh_ispi, 8),
	    print_spi(a->sa_hdr.sh_rspi, 8),
	    print_spi(b->sa_hdr.sh_ispi, 8),
	    print_spi(b->sa_hdr.sh_rspi, 8));

@


1.4
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.3 2010/06/10 12:06:34 reyk Exp $	*/
d172 1
a172 1
    u_int initiator, struct iked_policy *policy)
d175 1
d187 8
a194 1
		sa->sa_policy = policy;
a195 1
	if (!initiator) {
d197 1
a197 1
		if (policy != NULL && policy->pol_auth.auth_eap) {
d199 1
a199 1
		} else if (policy != NULL && policy->pol_auth.auth_method !=
d207 6
@


1.3
log
@Add another tree to lookup policy SAs by peer address.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.2 2010/06/10 07:35:41 reyk Exp $	*/
d176 2
a177 1
	if ((sa = sa_lookup(env, ispi, rspi, initiator)) == NULL) {
d185 1
a185 1
	if (sa->sa_policy == NULL) {
d187 13
a200 11
	sa->sa_staterequire = IKED_REQ_AUTH|IKED_REQ_SA;
	if (policy != NULL && policy->pol_auth.auth_eap) {
		sa->sa_staterequire |= IKED_REQ_CERT;
	} else if (policy != NULL &&
	    policy->pol_auth.auth_method != IKEV2_AUTH_SHARED_KEY_MIC) {
		sa->sa_staterequire |= IKED_REQ_VALID|IKED_REQ_CERT;
	}
	if (sa->sa_hdr.sh_ispi == 0)
		sa->sa_hdr.sh_ispi = ispi;
	if (sa->sa_hdr.sh_rspi == 0)
		sa->sa_hdr.sh_rspi = rspi;
d274 1
d281 6
d295 3
a297 2
	/* Responder SPI is not yet set */
	if (a->sa_hdr.sh_rspi == 0)
@


1.2
log
@only call RB_REMOVE once when removing an SA.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d216 29
d298 18
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a212 1
	(void)RB_REMOVE(iked_sas, &env->sc_sas, sa);
@

