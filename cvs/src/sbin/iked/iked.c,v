head	1.34;
access;
symbols
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.34
date	2017.03.23.05.29.48;	author jsg;	state Exp;
branches;
next	1.33;
commitid	s3mcLCKVawU2OT8D;

1.33
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.32;
commitid	eA8b246voAapPTkX;

1.32
date	2017.01.03.17.51.38;	author reyk;	state Exp;
branches;
next	1.31;
commitid	l0crj6yP4TgYYXus;

1.31
date	2016.09.04.16.55.43;	author reyk;	state Exp;
branches;
next	1.30;
commitid	Dq5V32qCi45ZXkNX;

1.30
date	2015.12.07.12.46.37;	author reyk;	state Exp;
branches;
next	1.29;
commitid	8zCLewXZF0DAEoO0;

1.29
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.28;
commitid	T3JBYxNT0thPuavp;

1.28
date	2015.10.22.15.55.18;	author reyk;	state Exp;
branches;
next	1.27;
commitid	9R73DxVDj9dmoXct;

1.27
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.26;
commitid	HzcDW70HFbhaqvT8;

1.26
date	2015.10.15.18.40.38;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	rQFz7wM8cPpo2dCG;

1.25
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.24;
commitid	CNs9dXqQUQ09vB19;

1.24
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.23;
commitid	GouatFiJVxwlAVIQ;

1.23
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Uu5nFG3wCl0LACBb;

1.22
date	2014.08.18.09.43.02;	author reyk;	state Exp;
branches;
next	1.21;
commitid	o804X3aJRVygt1Ju;

1.21
date	2014.05.08.13.11.16;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2014.02.17.15.07.23;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.24.02.55.50;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2012.12.15.23.19.35;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.29.15.08.08;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.22.10.25.17;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.17.16.43.45;	author ckuethe;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.24.20.15.30;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.10.14.18.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.10.14.17.48;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.07.10.07.44;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.34
log
@set ps_noaction to not fork uneeded children when checking config with -n

ok mikeb@@ reyk@@
@
text
@/*	$OpenBSD: iked.c,v 1.33 2017/01/09 14:49:21 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <signal.h>
#include <syslog.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include "iked.h"
#include "ikev2.h"

__dead void usage(void);

void	 parent_shutdown(struct iked *);
void	 parent_sig_handler(int, short, void *);
int	 parent_dispatch_ca(int, struct privsep_proc *, struct imsg *);
int	 parent_dispatch_control(int, struct privsep_proc *, struct imsg *);
int	 parent_configure(struct iked *);

static struct privsep_proc procs[] = {
	{ "ca",		PROC_CERT,	parent_dispatch_ca, caproc, IKED_CA },
	{ "control",	PROC_CONTROL,	parent_dispatch_control, control },
	{ "ikev2",	PROC_IKEV2,	NULL, ikev2 }
};

__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-6dnSTtv] [-D macro=value] "
	    "[-f file]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int		 c;
	int		 debug = 0, verbose = 0;
	int		 opts = 0;
	const char	*conffile = IKED_CONFIG;
	struct iked	*env = NULL;
	struct privsep	*ps;

	log_init(1, LOG_DAEMON);

	while ((c = getopt(argc, argv, "6dD:nf:vSTt")) != -1) {
		switch (c) {
		case '6':
			opts |= IKED_OPT_NOIPV6BLOCKING;
			break;
		case 'd':
			debug++;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'n':
			debug = 1;
			opts |= IKED_OPT_NOACTION;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'v':
			verbose++;
			opts |= IKED_OPT_VERBOSE;
			break;
		case 'S':
			opts |= IKED_OPT_PASSIVE;
			break;
		case 'T':
			opts |= IKED_OPT_NONATT;
			break;
		case 't':
			opts |= IKED_OPT_NATT;
			break;
		default:
			usage();
		}
	}

	if ((env = calloc(1, sizeof(*env))) == NULL)
		fatal("calloc: env");

	env->sc_opts = opts;

	ps = &env->sc_ps;
	ps->ps_env = env;
	TAILQ_INIT(&ps->ps_rcsocks);

	if ((opts & (IKED_OPT_NONATT|IKED_OPT_NATT)) ==
	    (IKED_OPT_NONATT|IKED_OPT_NATT))
		errx(1, "conflicting NAT-T options");

	if (strlcpy(env->sc_conffile, conffile, PATH_MAX) >= PATH_MAX)
		errx(1, "config file exceeds PATH_MAX");

	ca_sslinit();
	policy_init(env);

	/* check for root privileges */
	if (geteuid())
		errx(1, "need root privileges");

	if ((ps->ps_pw =  getpwnam(IKED_USER)) == NULL)
		errx(1, "unknown user %s", IKED_USER);

	/* Configure the control socket */
	ps->ps_csock.cs_name = IKED_SOCKET;

	log_init(debug, LOG_DAEMON);
	log_setverbose(verbose);

	if (opts & IKED_OPT_NOACTION)
		ps->ps_noaction = 1;

	if (!debug && daemon(0, 0) == -1)
		err(1, "failed to daemonize");

	group_init();

	ps->ps_ninstances = 1;
	proc_init(ps, procs, nitems(procs));

	setproctitle("parent");
	log_procinit("parent");

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigterm, SIGTERM, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigchld, SIGCHLD, parent_sig_handler, ps);
	signal_set(&ps->ps_evsighup, SIGHUP, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, parent_sig_handler, ps);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsigchld, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_listen(ps, procs, nitems(procs));

	if (parent_configure(env) == -1)
		fatalx("configuration failed");

	event_dispatch();

	log_debug("%d parent exiting", getpid());

	return (0);
}

int
parent_configure(struct iked *env)
{
	struct sockaddr_storage	 ss;

	if (parse_config(env->sc_conffile, env) == -1) {
		proc_kill(&env->sc_ps);
		exit(1);
	}

	if (env->sc_opts & IKED_OPT_NOACTION) {
		fprintf(stderr, "configuration OK\n");
		proc_kill(&env->sc_ps);
		exit(0);
	}

	env->sc_pfkey = -1;
	config_setpfkey(env, PROC_IKEV2);

	/* Send private and public keys to cert after forking the children */
	if (config_setkeys(env) == -1)
		fatalx("%s: failed to send keys", __func__);
	config_setreset(env, RESET_CA, PROC_CERT);

	/* Now compile the policies and calculate skip steps */
	config_setcompile(env, PROC_IKEV2);

	bzero(&ss, sizeof(ss));
	ss.ss_family = AF_INET;

	if ((env->sc_opts & IKED_OPT_NATT) == 0)
		config_setsocket(env, &ss, ntohs(IKED_IKE_PORT), PROC_IKEV2);
	if ((env->sc_opts & IKED_OPT_NONATT) == 0)
		config_setsocket(env, &ss, ntohs(IKED_NATT_PORT), PROC_IKEV2);

	bzero(&ss, sizeof(ss));
	ss.ss_family = AF_INET6;

	if ((env->sc_opts & IKED_OPT_NATT) == 0)
		config_setsocket(env, &ss, ntohs(IKED_IKE_PORT), PROC_IKEV2);
	if ((env->sc_opts & IKED_OPT_NONATT) == 0)
		config_setsocket(env, &ss, ntohs(IKED_NATT_PORT), PROC_IKEV2);

	/*
	 * pledge in the parent process:
	 * It has to run fairly late to allow forking the processes and
	 * opening the PFKEY socket and the listening UDP sockets (once)
	 * that need the bypass ioctls that are never allowed by pledge.
	 *
	 * Other flags:
	 * stdio - for malloc and basic I/O including events.
	 * rpath - for reload to open and read the configuration files.
	 * proc - run kill to terminate its children safely.
	 * dns - for reload and ocsp connect.
	 * inet - for ocsp connect.
	 * route - for using interfaces in iked.conf (SIOCGIFGMEMB)
	 * sendfd - for ocsp sockets.
	 */
	if (pledge("stdio rpath proc dns inet route sendfd", NULL) == -1)
		fatal("pledge");

	config_setcoupled(env, env->sc_decoupled ? 0 : 1);
	config_setmode(env, env->sc_passive ? 1 : 0);
	config_setocsp(env);

	return (0);
}

void
parent_reload(struct iked *env, int reset, const char *filename)
{
	/* Switch back to the default config file */
	if (filename == NULL || *filename == '\0')
		filename = env->sc_conffile;

	log_debug("%s: level %d config file %s", __func__, reset, filename);

	if (reset == RESET_RELOAD) {
		config_setreset(env, RESET_POLICY, PROC_IKEV2);
		if (config_setkeys(env) == -1)
			fatalx("%s: failed to send keys", __func__);
		config_setreset(env, RESET_CA, PROC_CERT);

		if (parse_config(filename, env) == -1) {
			log_debug("%s: failed to load config file %s",
			    __func__, filename);
		}

		/* Re-compile policies and skip steps */
		config_setcompile(env, PROC_IKEV2);

		config_setcoupled(env, env->sc_decoupled ? 0 : 1);
		config_setmode(env, env->sc_passive ? 1 : 0);
		config_setocsp(env);
	} else {
		config_setreset(env, reset, PROC_IKEV2);
		config_setreset(env, reset, PROC_CERT);
	}
}

void
parent_sig_handler(int sig, short event, void *arg)
{
	struct privsep	*ps = arg;
	int		 die = 0, status, fail, id;
	pid_t		 pid;
	char		*cause;

	switch (sig) {
	case SIGHUP:
		log_info("%s: reload requested with SIGHUP", __func__);

		/*
		 * This is safe because libevent uses async signal handlers
		 * that run in the event loop and not in signal context.
		 */
		parent_reload(ps->ps_env, 0, NULL);
		break;
	case SIGPIPE:
		log_info("%s: ignoring SIGPIPE", __func__);
		break;
	case SIGUSR1:
		log_info("%s: ignoring SIGUSR1", __func__);
		break;
	case SIGTERM:
	case SIGINT:
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		do {
			int len;

			pid = waitpid(-1, &status, WNOHANG);
			if (pid <= 0)
				continue;

			fail = 0;
			if (WIFSIGNALED(status)) {
				fail = 1;
				len = asprintf(&cause, "terminated; signal %d",
				    WTERMSIG(status));
			} else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) != 0) {
					fail = 1;
					len = asprintf(&cause,
					    "exited abnormally");
				} else
					len = asprintf(&cause, "exited okay");
			} else
				fatalx("unexpected cause of SIGCHLD");

			if (len == -1)
				fatal("asprintf");

			die = 1;

			for (id = 0; id < PROC_MAX; id++)
				if (pid == ps->ps_pid[id]) {
					if (fail)
						log_warnx("lost child: %s %s",
						    ps->ps_title[id], cause);
					break;
				}

			free(cause);
		} while (pid > 0 || (pid == -1 && errno == EINTR));

		if (die)
			parent_shutdown(ps->ps_env);
		break;
	default:
		fatalx("unexpected signal");
	}
}

int
parent_dispatch_ca(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked	*env = p->p_ps->ps_env;

	switch (imsg->hdr.type) {
	case IMSG_OCSP_FD:
		ocsp_connect(env);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
parent_dispatch_control(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked	*env = p->p_ps->ps_env;
	int		 v;
	char		*str = NULL;
	unsigned int	 type = imsg->hdr.type;

	switch (type) {
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &v);
		memcpy(&v, imsg->data, sizeof(v));
		parent_reload(env, v, NULL);
		break;
	case IMSG_CTL_COUPLE:
	case IMSG_CTL_DECOUPLE:
	case IMSG_CTL_ACTIVE:
	case IMSG_CTL_PASSIVE:
		proc_compose(&env->sc_ps, PROC_IKEV2, type, NULL, 0);
		break;
	case IMSG_CTL_RELOAD:
		if (IMSG_DATA_SIZE(imsg) > 0)
			str = get_string(imsg->data, IMSG_DATA_SIZE(imsg));
		parent_reload(env, 0, str);
		free(str);
		break;
	case IMSG_CTL_VERBOSE:
		proc_forward_imsg(&env->sc_ps, imsg, PROC_IKEV2, -1);
		proc_forward_imsg(&env->sc_ps, imsg, PROC_CERT, -1);

		/* return 1 to let proc.c handle it locally */
		return (1);
	default:
		return (-1);
	}

	return (0);
}

void
parent_shutdown(struct iked *env)
{
	proc_kill(&env->sc_ps);

	free(env);

	log_warnx("parent terminating");
	exit(0);
}
@


1.33
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.32 2017/01/03 17:51:38 reyk Exp $	*/
d144 3
@


1.32
log
@Fix pledge of the ca process by calling the right function on startup.
As a related change, load the local.pub and local.key keys after
privsep and reload them on SIGHUP/reload.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.31 2016/09/04 16:55:43 reyk Exp $	*/
d143 1
a143 1
	log_verbose(verbose);
@


1.31
log
@Forward IMSG_CTL_VERBOSE via the parent; this fixes a crash when doing
"ikectl log verbose" and keeps the control process separated from the
cert process.

Thanks for the bug report to Wouter Clarie

OK vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.30 2015/12/07 12:46:37 reyk Exp $	*/
d203 5
d263 2
@


1.30
log
@Sync proc.c, use shorter proc_compose[v]()
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.29 2015/11/22 13:27:13 reyk Exp $	*/
d394 6
@


1.29
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.28 2015/10/22 15:55:18 reyk Exp $	*/
d386 1
a386 2
		proc_compose_imsg(&env->sc_ps, PROC_IKEV2, -1,
		    type, -1, NULL, 0);
@


1.28
log
@iked hereby pledges that it will run with restricted system
operations.  This adds pledge(2) too all processes, including the iked
parent process; the existing privsep design has been improved for
better pledgeability.  There haven't been any serious problems as it
was already sane (eg. by receiving the PFKEYv2 and UDP sockets via fd
passing).  The control socket moved to an independent process to
remove some abilities from the cert process.

Committed in agreement with many but nobody was brave enough to OK it.

Better testing will happen with having it in the tree.
"It's the truth" deraadt@@
"Let's see what happens" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.27 2015/10/19 11:25:35 reyk Exp $	*/
d30 1
d73 1
a73 1
	log_init(1);
d142 1
a142 1
	log_init(debug);
d154 1
@


1.27
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.26 2015/10/15 18:40:38 mmcc Exp $	*/
a41 1
int	 parent_dispatch_ikev2(int, struct privsep_proc *, struct imsg *);
d43 1
d47 3
a49 2
	{ "ikev2",	PROC_IKEV2, parent_dispatch_ikev2, ikev2 },
	{ "ca",		PROC_CERT, parent_dispatch_ca, caproc, IKED_CA }
d220 18
d351 1
a351 1
parent_dispatch_ikev2(int fd, struct privsep_proc *p, struct imsg *imsg)
d353 2
d356 3
d360 1
a360 1
		break;
d363 1
a363 1
	return (-1);
d367 1
a367 1
parent_dispatch_ca(int fd, struct privsep_proc *p, struct imsg *imsg)
a391 3
		break;
	case IMSG_OCSP_FD:
		ocsp_connect(env);
@


1.26
log
@Remove some unnecessary NULL-checks before free(). Change two bzero()
calls on pf data to explicit_bzero().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.25 2015/08/21 11:59:27 reyk Exp $	*/
a41 1
int	 parent_dispatch_ikev1(int, struct privsep_proc *, struct imsg *);
a46 1
	{ "ikev1",	PROC_IKEV1, parent_dispatch_ikev1, ikev1 },
a200 1
	config_setcompile(env, PROC_IKEV1);
a235 1
		config_setreset(env, RESET_POLICY, PROC_IKEV1);
a244 1
		config_setcompile(env, PROC_IKEV1);
a250 1
		config_setreset(env, reset, PROC_IKEV1);
a331 11
parent_dispatch_ikev1(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	default:
		break;
	}

	return (-1);
}

int
a359 2
		proc_compose_imsg(&env->sc_ps, PROC_IKEV1, -1,
		    type, -1, NULL, 0);
@


1.25
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.24 2015/06/03 02:24:36 millert Exp $	*/
d386 1
a386 2
		if (str != NULL)
			free(str);
@


1.24
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.23 2015/01/16 06:39:58 deraadt Exp $	*/
d365 1
a365 1
	u_int		 type = imsg->hdr.type;
@


1.23
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.22 2014/08/18 09:43:02 reyk Exp $	*/
d292 2
d301 1
a301 1
				asprintf(&cause, "terminated; signal %d",
d306 2
a307 1
					asprintf(&cause, "exited abnormally");
d309 1
a309 1
					asprintf(&cause, "exited okay");
d312 3
@


1.22
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but iked will ignore it
now instead of terminating the process.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.21 2014/05/08 13:11:16 blambert Exp $	*/
a18 1
#include <sys/param.h>
d126 2
a127 2
	if (strlcpy(env->sc_conffile, conffile, MAXPATHLEN) >= MAXPATHLEN)
		errx(1, "config file exceeds MAXPATHLEN");
@


1.21
log
@match iked proc.c infrastructure with proc.c

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.20 2014/04/22 12:00:03 reyk Exp $	*/
d163 1
d170 1
d283 3
@


1.20
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.19 2014/02/17 15:07:23 markus Exp $	*/
d121 1
@


1.19
log
@basic OCSP support. enable with 'set ocsp "http://10.0.0.10:8888/"'
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.18 2013/10/24 02:55:50 deraadt Exp $	*/
d149 2
d169 1
a169 1
	proc_config(ps, procs, nitems(procs));
d366 4
a369 2
		proc_compose_imsg(env, PROC_IKEV1, type, -1, NULL, 0);
		proc_compose_imsg(env, PROC_IKEV2, type, -1, NULL, 0);
@


1.18
log
@no need for netinet/ip_var.h (and friends)
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.17 2013/03/21 04:30:14 deraadt Exp $	*/
d220 1
d250 1
d373 3
@


1.17
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.16 2013/01/08 10:38:19 reyk Exp $	*/
a23 7

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
@


1.16
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.15 2012/12/15 23:19:35 reyk Exp $	*/
a19 1
#include <sys/types.h>
@


1.15
log
@Don't print an error if the process exited normally.
@
text
@d1 1
a1 2
/*	$OpenBSD: iked.c,v 1.14 2012/11/29 15:08:08 reyk Exp $	*/
/*	$vantronix: iked.c,v 1.22 2010/06/02 14:43:30 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.14
log
@Prevent VPN traffic leakages in dual-stack hosts/networks.
See http://tools.ietf.org/html/draft-gont-opsec-vpn-leakages.

We forcibly block IPv6 traffic by loading a "flow esp out from ::/0 to
::/0 type deny" unless the protocol is used in any of the flows.  Note
that this will block any IPv6 traffic, superseding routes and pf, on
the host by default when iked is running with IPv4 flows only.  This
auto-blocking feature can be disabled by specifying the "-6" command
line flag to iked.

Thanks to Fernando Gont.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.13 2012/10/22 10:25:17 reyk Exp $	*/
a122 3
	argv += optind;
	argc -= optind;

d314 3
a316 2
					log_warnx("lost child: %s %s",
					    ps->ps_title[id], cause);
@


1.13
log
@Fix NAT-T support in iked, both on the initiator and the responder
side.  Also add a new command line option -t to optionally enforce
NAT-T with UDP encapsulation on port 4500.

Tested by mikeb@@ and me
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.12 2012/09/18 12:07:59 reyk Exp $	*/
d68 1
a68 1
	fprintf(stderr, "usage: %s [-dnSTtv] [-D macro=value] "
d85 1
a85 1
	while ((c = getopt(argc, argv, "dD:nf:vSTt")) != -1) {
d87 3
@


1.12
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.11 2011/05/09 11:15:18 reyk Exp $	*/
d68 1
a68 1
	fprintf(stderr, "usage: %s [-dnSTv] [-D macro=value] "
d85 1
a85 1
	while ((c = getopt(argc, argv, "dD:nf:vST")) != -1) {
d112 3
d131 4
d214 4
a217 2
	config_setsocket(env, &ss, ntohs(IKED_IKE_PORT), PROC_IKEV2);
	config_setsocket(env, &ss, ntohs(IKED_NATT_PORT), PROC_IKEV2);
d222 4
a225 2
	config_setsocket(env, &ss, ntohs(IKED_IKE_PORT), PROC_IKEV2);
	config_setsocket(env, &ss, ntohs(IKED_NATT_PORT), PROC_IKEV2);
@


1.11
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.10 2011/05/05 12:55:52 reyk Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.10
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.9 2011/05/05 12:17:10 reyk Exp $	*/
d23 1
a24 1
#include <sys/socket.h>
d151 1
a151 1
	init_procs(ps, procs, nitems(procs));
d169 1
a169 2
	config_pipes(ps, procs, nitems(procs));
	config_procs(ps, procs, nitems(procs));
d187 1
a187 1
		kill_procs(&env->sc_ps);
d193 1
a193 1
		kill_procs(&env->sc_ps);
d359 2
a360 2
		imsg_compose_proc(env, PROC_IKEV1, type, -1, NULL, 0);
		imsg_compose_proc(env, PROC_IKEV2, type, -1, NULL, 0);
d379 1
a379 9
	pid_t		 pid;
	u_int		 i;

	for (i = 0; i < PROC_MAX; i++)
		kill(env->sc_ps.ps_pid[i], SIGTERM);

	do {
		pid = waitpid(WAIT_MYPGRP, NULL, 0);
	} while (pid != -1 || (pid == -1 && errno == EINTR));
@


1.9
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.8 2011/01/21 11:56:00 reyk Exp $	*/
d81 1
d125 3
d138 1
a138 1
	if ((env->sc_pw =  getpwnam(IKED_USER)) == NULL)
d142 1
a142 1
	env->sc_csock.cs_name = IKED_SOCKET;
d151 1
a151 1
	init_procs(env, procs, nitems(procs));
d157 11
a167 11
	signal_set(&env->sc_evsigint, SIGINT, parent_sig_handler, env);
	signal_set(&env->sc_evsigterm, SIGTERM, parent_sig_handler, env);
	signal_set(&env->sc_evsigchld, SIGCHLD, parent_sig_handler, env);
	signal_set(&env->sc_evsighup, SIGHUP, parent_sig_handler, env);
	signal_set(&env->sc_evsigpipe, SIGPIPE, parent_sig_handler, env);

	signal_add(&env->sc_evsigint, NULL);
	signal_add(&env->sc_evsigterm, NULL);
	signal_add(&env->sc_evsigchld, NULL);
	signal_add(&env->sc_evsighup, NULL);
	signal_add(&env->sc_evsigpipe, NULL);
d169 2
a170 2
	config_pipes(env, procs, nitems(procs));
	config_procs(env, procs, nitems(procs));
d188 1
a188 1
		kill_procs(env);
d194 1
a194 1
		kill_procs(env);
d256 1
a256 1
parent_sig_handler(int sig, short event, void *p)
d258 1
a258 1
	struct iked	*env = p;
d271 1
a271 1
		parent_reload(env, 0, NULL);
d303 1
a303 1
				if (pid == env->sc_pid[id]) {
d305 1
a305 1
					    env->sc_title[id], cause);
d313 1
a313 1
			parent_shutdown(env);
d345 1
a345 1
	struct iked	*env = p->env;
d384 1
a384 1
		kill(env->sc_pid[i], SIGTERM);
@


1.8
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.7 2010/11/17 16:43:45 ckuethe Exp $	*/
d52 3
a54 3
int	 parent_dispatch_ikev1(int, struct iked_proc *, struct imsg *);
int	 parent_dispatch_ikev2(int, struct iked_proc *, struct imsg *);
int	 parent_dispatch_ca(int, struct iked_proc *, struct imsg *);
d57 1
a57 1
static struct iked_proc procs[] = {
d317 1
a317 1
parent_dispatch_ikev1(int fd, struct iked_proc *p, struct imsg *imsg)
d328 1
a328 1
parent_dispatch_ikev2(int fd, struct iked_proc *p, struct imsg *imsg)
d339 1
a339 1
parent_dispatch_ca(int fd, struct iked_proc *p, struct imsg *imsg)
@


1.7
log
@Allow the -D command line flag to actually define macros.
ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.6 2010/06/24 20:15:30 reyk Exp $	*/
d197 4
d237 4
@


1.6
log
@unbreak the ikectl log verbose/brief commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.5 2010/06/10 14:18:26 reyk Exp $	*/
a89 1
#if 0
a92 1
#endif
@


1.5
log
@update usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.4 2010/06/10 14:17:48 reyk Exp $	*/
d345 1
a345 1
		return (0);
d352 1
a352 1
		return (0);
d359 1
a359 1
		return (0);
d361 1
a361 1
		break;
d364 1
a364 1
	return (-1);
@


1.4
log
@Add the -S flag which does the same as "set passive" but matches the
isakmpd flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.3 2010/06/10 14:08:37 reyk Exp $	*/
d68 1
a68 1
	fprintf(stderr, "usage: %s [-dnTv] [-D macro=value] "
@


1.3
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.2 2010/06/07 10:07:44 jmc Exp $	*/
d84 1
a84 1
	while ((c = getopt(argc, argv, "dD:nf:vT")) != -1) {
d106 3
@


1.2
log
@various small tweaks; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d208 3
d232 3
d335 1
d337 1
a337 1
	switch (imsg->hdr.type) {
d342 7
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
	fprintf(stderr, "usage: %s [-dnvT] [-D macro=value] "
@

