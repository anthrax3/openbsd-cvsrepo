head	1.48;
access;
symbols
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.47.0.4
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.48
date	2017.04.13.07.04.09;	author patrick;	state Exp;
branches;
next	1.47;
commitid	bo33yiQX6Rmx6w3D;

1.47
date	2017.03.27.10.43.53;	author mikeb;	state Exp;
branches;
next	1.46;
commitid	3tQzvpAXTrEiRD3X;

1.46
date	2017.03.27.10.29.02;	author reyk;	state Exp;
branches;
next	1.45;
commitid	yfhMvs0gHdZ86p06;

1.45
date	2017.03.27.10.24.36;	author reyk;	state Exp;
branches;
next	1.44;
commitid	QtsiC6NORfrFiVfm;

1.44
date	2017.03.13.18.49.20;	author mikeb;	state Exp;
branches;
next	1.43;
commitid	QPmMphRu2IVU5ovk;

1.43
date	2017.01.03.17.51.38;	author reyk;	state Exp;
branches;
next	1.42;
commitid	l0crj6yP4TgYYXus;

1.42
date	2016.06.01.11.16.41;	author patrick;	state Exp;
branches;
next	1.41;
commitid	LPZMTPg26WvdrIfQ;

1.41
date	2015.12.07.12.46.37;	author reyk;	state Exp;
branches;
next	1.40;
commitid	8zCLewXZF0DAEoO0;

1.40
date	2015.11.18.16.46.30;	author reyk;	state Exp;
branches;
next	1.39;
commitid	3lGjAfydwTGmEsyl;

1.39
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.38;
commitid	HzcDW70HFbhaqvT8;

1.38
date	2015.10.15.18.40.38;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	rQFz7wM8cPpo2dCG;

1.37
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.36;
commitid	CNs9dXqQUQ09vB19;

1.36
date	2015.07.07.19.13.31;	author markus;	state Exp;
branches;
next	1.35;
commitid	a1FLyyKqRzzs0TCl;

1.35
date	2015.02.06.10.39.01;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	fN2B4abgRqE4hFJn;

1.34
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2014.12.03.23.18.21;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	JDFiyucrtmUUJdLy;

1.32
date	2014.10.08.05.47.03;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	9YQtxhafn8yX9UAX;

1.31
date	2014.05.06.14.10.53;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.06.09.48.40;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.06.07.24.37;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2014.02.17.15.53.46;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2014.02.17.15.07.23;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.24.05.58.52;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.28.20.28.34;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.24.02.55.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.15.23.20.17;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.22.10.25.17;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.02.13.03.24;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2012.06.22.16.28.20;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.05.19.59.00;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.18.08.45.43;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.26.16.59.23;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.21.11.37.02;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.12.14.35.45;	author mikeb;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.12.06.34;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Add a NAT-T keepalive timer in case we are behind a NAT gateway.

See RFC 5996, section 2.23, NAT Traversal:
  In the case of a mismatching NAT_DETECTION_DESTINATION_IP hash, it
  means that the system receiving the NAT_DETECTION_DESTINATION_IP
  payload is behind a NAT and that system SHOULD start sending
  keepalive packets as defined in [UDPENCAPS].

With markus@@, ok reyk@@
@
text
@/*	$OpenBSD: config.c,v 1.47 2017/03/27 10:43:53 mikeb Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include <openssl/evp.h>
#include <openssl/pem.h>

#include "iked.h"
#include "ikev2.h"

struct iked_sa *
config_new_sa(struct iked *env, int initiator)
{
	struct iked_sa	*sa;

	if ((sa = calloc(1, sizeof(*sa))) == NULL)
		return (NULL);

	TAILQ_INIT(&sa->sa_proposals);
	TAILQ_INIT(&sa->sa_childsas);
	TAILQ_INIT(&sa->sa_flows);
	TAILQ_INIT(&sa->sa_requests);
	TAILQ_INIT(&sa->sa_responses);
	sa->sa_hdr.sh_initiator = initiator;
	sa->sa_type = IKED_SATYPE_LOCAL;

	if (initiator)
		sa->sa_hdr.sh_ispi = config_getspi();
	else
		sa->sa_hdr.sh_rspi = config_getspi();

	gettimeofday(&sa->sa_timecreated, NULL);
	memcpy(&sa->sa_timeused, &sa->sa_timecreated, sizeof(sa->sa_timeused));

	return (sa);
}

uint64_t
config_getspi(void)
{
	uint64_t	 spi;

	do {
		arc4random_buf(&spi, sizeof spi);
	} while (spi == 0);

	return (spi);
}

void
config_free_kex(struct iked_kex *kex)
{
	if (kex == NULL)
		return;

	ibuf_release(kex->kex_inonce);
	ibuf_release(kex->kex_rnonce);

	if (kex->kex_dhgroup != NULL)
		group_free(kex->kex_dhgroup);
	ibuf_release(kex->kex_dhiexchange);
	ibuf_release(kex->kex_dhrexchange);

	free(kex);
}

void
config_free_sa(struct iked *env, struct iked_sa *sa)
{
	timer_del(env, &sa->sa_timer);
	timer_del(env, &sa->sa_keepalive);
	timer_del(env, &sa->sa_rekey);

	config_free_proposals(&sa->sa_proposals, 0);
	config_free_childsas(env, &sa->sa_childsas, NULL, NULL);
	sa_free_flows(env, &sa->sa_flows);

	if (sa->sa_addrpool) {
		(void)RB_REMOVE(iked_addrpool, &env->sc_addrpool, sa);
		free(sa->sa_addrpool);
	}
	if (sa->sa_addrpool6) {
		(void)RB_REMOVE(iked_addrpool6, &env->sc_addrpool6, sa);
		free(sa->sa_addrpool6);
	}

	if (sa->sa_policy) {
		TAILQ_REMOVE(&sa->sa_policy->pol_sapeers, sa, sa_peer_entry);
		policy_unref(env, sa->sa_policy);
	}

	ikev2_msg_flushqueue(env, &sa->sa_requests);
	ikev2_msg_flushqueue(env, &sa->sa_responses);

	ibuf_release(sa->sa_inonce);
	ibuf_release(sa->sa_rnonce);

	if (sa->sa_dhgroup != NULL)
		group_free(sa->sa_dhgroup);
	ibuf_release(sa->sa_dhiexchange);
	ibuf_release(sa->sa_dhrexchange);

	ibuf_release(sa->sa_simult);

	hash_free(sa->sa_prf);
	hash_free(sa->sa_integr);
	cipher_free(sa->sa_encr);

	ibuf_release(sa->sa_key_d);
	ibuf_release(sa->sa_key_iauth);
	ibuf_release(sa->sa_key_rauth);
	ibuf_release(sa->sa_key_iencr);
	ibuf_release(sa->sa_key_rencr);
	ibuf_release(sa->sa_key_iprf);
	ibuf_release(sa->sa_key_rprf);

	ibuf_release(sa->sa_1stmsg);
	ibuf_release(sa->sa_2ndmsg);

	ibuf_release(sa->sa_iid.id_buf);
	ibuf_release(sa->sa_rid.id_buf);
	ibuf_release(sa->sa_icert.id_buf);
	ibuf_release(sa->sa_rcert.id_buf);

	ibuf_release(sa->sa_eap.id_buf);
	free(sa->sa_eapid);
	ibuf_release(sa->sa_eapmsk);

	free(sa->sa_tag);
	free(sa);
}

struct iked_policy *
config_new_policy(struct iked *env)
{
	struct iked_policy	*pol;

	if ((pol = calloc(1, sizeof(*pol))) == NULL)
		return (NULL);

	/* XXX caller does this again */
	TAILQ_INIT(&pol->pol_proposals);
	TAILQ_INIT(&pol->pol_sapeers);
	RB_INIT(&pol->pol_flows);

	return (pol);
}

void
config_free_policy(struct iked *env, struct iked_policy *pol)
{
	struct iked_sa		*sa;

	if (pol->pol_flags & IKED_POLICY_REFCNT)
		goto remove;

	TAILQ_REMOVE(&env->sc_policies, pol, pol_entry);

	TAILQ_FOREACH(sa, &pol->pol_sapeers, sa_peer_entry) {
		/* Remove from the policy list, but keep for existing SAs */
		if (sa->sa_policy == pol)
			policy_ref(env, pol);
		else
			log_warnx("%s: ERROR: sa_policy %p != pol %p",
			    __func__, sa->sa_policy, pol);
	}

	if (pol->pol_refcnt)
		return;

 remove:
	config_free_proposals(&pol->pol_proposals, 0);
	config_free_flows(env, &pol->pol_flows);
	free(pol);
}

struct iked_proposal *
config_add_proposal(struct iked_proposals *head, unsigned int id,
    unsigned int proto)
{
	struct iked_proposal	*pp;

	TAILQ_FOREACH(pp, head, prop_entry) {
		if (pp->prop_protoid == proto &&
		    pp->prop_id == id)
			return (pp);
	}

	if ((pp = calloc(1, sizeof(*pp))) == NULL)
		return (NULL);

	pp->prop_protoid = proto;
	pp->prop_id = id;

	TAILQ_INSERT_TAIL(head, pp, prop_entry);

	return (pp);
}

void
config_free_proposals(struct iked_proposals *head, unsigned int proto)
{
	struct iked_proposal	*prop, *next;

	for (prop = TAILQ_FIRST(head); prop != NULL; prop = next) {
		next = TAILQ_NEXT(prop, prop_entry);

		/* Free any proposal or only selected SA proto */
		if (proto != 0 && prop->prop_protoid != proto)
			continue;

		log_debug("%s: free %p", __func__, prop);

		TAILQ_REMOVE(head, prop, prop_entry);
		if (prop->prop_nxforms)
			free(prop->prop_xforms);
		free(prop);
	}
}

void
config_free_flows(struct iked *env, struct iked_flows *head)
{
	struct iked_flow	*flow, *next;

	for (flow = RB_MIN(iked_flows, head); flow != NULL; flow = next) {
		next = RB_NEXT(iked_flows, head, flow);
		log_debug("%s: free %p", __func__, flow);
		RB_REMOVE(iked_flows, head, flow);
		flow_free(flow);
	}
}

void
config_free_childsas(struct iked *env, struct iked_childsas *head,
    struct iked_spi *peerspi, struct iked_spi *localspi)
{
	struct iked_childsa	*csa, *nextcsa;

	if (localspi != NULL)
		bzero(localspi, sizeof(*localspi));

	for (csa = TAILQ_FIRST(head); csa != NULL; csa = nextcsa) {
		nextcsa = TAILQ_NEXT(csa, csa_entry);

		if (peerspi != NULL) {
			/* Only delete matching peer SPIs */
			if (peerspi->spi != csa->csa_peerspi)
				continue;

			/* Store assigned local SPI */
			if (localspi != NULL && localspi->spi == 0)
				memcpy(localspi, &csa->csa_spi,
				    sizeof(*localspi));
		}
		log_debug("%s: free %p", __func__, csa);

		TAILQ_REMOVE(head, csa, csa_entry);
		if (csa->csa_loaded) {
			RB_REMOVE(iked_activesas, &env->sc_activesas, csa);
			(void)pfkey_sa_delete(env->sc_pfkey, csa);
		}
		childsa_free(csa);
	}
}

struct iked_transform *
config_add_transform(struct iked_proposal *prop, unsigned int type,
    unsigned int id, unsigned int length, unsigned int keylength)
{
	struct iked_transform	*xform;
	struct iked_constmap	*map = NULL;
	int			 score = 1;
	unsigned int		 i;

	switch (type) {
	case IKEV2_XFORMTYPE_ENCR:
		map = ikev2_xformencr_map;
		break;
	case IKEV2_XFORMTYPE_PRF:
		map = ikev2_xformprf_map;
		break;
	case IKEV2_XFORMTYPE_INTEGR:
		map = ikev2_xformauth_map;
		break;
	case IKEV2_XFORMTYPE_DH:
		map = ikev2_xformdh_map;
		break;
	case IKEV2_XFORMTYPE_ESN:
		map = ikev2_xformesn_map;
		break;
	default:
		log_debug("%s: invalid transform type %d", __func__, type);
		return (NULL);
	}

	for (i = 0; i < prop->prop_nxforms; i++) {
		xform = prop->prop_xforms + i;
		if (xform->xform_type == type &&
		    xform->xform_id == id &&
		    xform->xform_length == length)
			return (xform);
	}

	for (i = 0; i < prop->prop_nxforms; i++) {
		xform = prop->prop_xforms + i;
		if (xform->xform_type == type) {
			switch (type) {
			case IKEV2_XFORMTYPE_ENCR:
			case IKEV2_XFORMTYPE_INTEGR:
				score += 3;
				break;
			case IKEV2_XFORMTYPE_DH:
				score += 2;
				break;
			default:
				score += 1;
				break;
			}
		}
	}

	if ((xform = reallocarray(prop->prop_xforms,
	    prop->prop_nxforms + 1, sizeof(*xform))) == NULL) {
		return (NULL);
	}

	prop->prop_xforms = xform;
	xform = prop->prop_xforms + prop->prop_nxforms++;
	bzero(xform, sizeof(*xform));

	xform->xform_type = type;
	xform->xform_id = id;
	xform->xform_length = length;
	xform->xform_keylength = keylength;
	xform->xform_score = score;
	xform->xform_map = map;

	return (xform);
}

struct iked_transform *
config_findtransform(struct iked_proposals *props, uint8_t type,
    unsigned int proto)
{
	struct iked_proposal	*prop;
	struct iked_transform	*xform;
	unsigned int		 i;

	/* Search of the first transform with the desired type */
	TAILQ_FOREACH(prop, props, prop_entry) {
		/* Find any proposal or only selected SA proto */
		if (proto != 0 && prop->prop_protoid != proto)
			continue;
		for (i = 0; i < prop->prop_nxforms; i++) {
			xform = prop->prop_xforms + i;
			if (xform->xform_type == type)
				return (xform);
		}
	}

	return (NULL);
}

struct iked_user *
config_new_user(struct iked *env, struct iked_user *new)
{
	struct iked_user	*usr, *old;

	if ((usr = calloc(1, sizeof(*usr))) == NULL)
		return (NULL);

	memcpy(usr, new, sizeof(*usr));

	if ((old = RB_INSERT(iked_users, &env->sc_users, usr)) != NULL) {
		/* Update the password of an existing user*/
		memcpy(old, new, sizeof(*old));

		log_debug("%s: updating user %s", __func__, usr->usr_name);
		free(usr);

		return (old);
	}

	log_debug("%s: inserting new user %s", __func__, usr->usr_name);
	return (usr);
}

/*
 * Inter-process communication of configuration items.
 */

int
config_setcoupled(struct iked *env, unsigned int couple)
{
	unsigned int	 type;

	type = couple ? IMSG_CTL_COUPLE : IMSG_CTL_DECOUPLE;
	proc_compose(&env->sc_ps, PROC_IKEV2, type, NULL, 0);

	return (0);
}

int
config_getcoupled(struct iked *env, unsigned int type)
{
	return (pfkey_couple(env->sc_pfkey, &env->sc_sas,
	    type == IMSG_CTL_COUPLE ? 1 : 0));
}

int
config_setmode(struct iked *env, unsigned int passive)
{
	unsigned int	 type;

	type = passive ? IMSG_CTL_PASSIVE : IMSG_CTL_ACTIVE;
	proc_compose(&env->sc_ps, PROC_IKEV2, type, NULL, 0);

	return (0);
}

int
config_getmode(struct iked *env, unsigned int type)
{
	uint8_t		 old;
	unsigned char	*mode[] = { "active", "passive" };

	old = env->sc_passive ? 1 : 0;
	env->sc_passive = type == IMSG_CTL_PASSIVE ? 1 : 0;

	if (old == env->sc_passive)
		return (0);

	log_debug("%s: mode %s -> %s", __func__,
	    mode[old], mode[env->sc_passive]);

	return (0);
}

int
config_setreset(struct iked *env, unsigned int mode, enum privsep_procid id)
{
	proc_compose(&env->sc_ps, id, IMSG_CTL_RESET, &mode, sizeof(mode));
	return (0);
}

int
config_getreset(struct iked *env, struct imsg *imsg)
{
	struct iked_policy	*pol, *nextpol;
	struct iked_sa		*sa, *nextsa;
	struct iked_user	*usr, *nextusr;
	unsigned int		 mode;

	IMSG_SIZE_CHECK(imsg, &mode);
	memcpy(&mode, imsg->data, sizeof(mode));

	if (mode == RESET_ALL || mode == RESET_POLICY) {
		log_debug("%s: flushing policies", __func__);
		for (pol = TAILQ_FIRST(&env->sc_policies);
		    pol != NULL; pol = nextpol) {
			nextpol = TAILQ_NEXT(pol, pol_entry);
			config_free_policy(env, pol);
		}
	}

	if (mode == RESET_ALL || mode == RESET_SA) {
		log_debug("%s: flushing SAs", __func__);
		for (sa = RB_MIN(iked_sas, &env->sc_sas);
		    sa != NULL; sa = nextsa) {
			nextsa = RB_NEXT(iked_sas, &env->sc_sas, sa);
			RB_REMOVE(iked_sas, &env->sc_sas, sa);
			config_free_sa(env, sa);
		}
	}

	if (mode == RESET_ALL || mode == RESET_USER) {
		log_debug("%s: flushing users", __func__);
		for (usr = RB_MIN(iked_users, &env->sc_users);
		    usr != NULL; usr = nextusr) {
			nextusr = RB_NEXT(iked_users, &env->sc_users, usr);
			RB_REMOVE(iked_users, &env->sc_users, usr);
			free(usr);
		}
	}

	return (0);
}

int
config_setsocket(struct iked *env, struct sockaddr_storage *ss,
    in_port_t port, enum privsep_procid id)
{
	int	 s;

	if ((s = udp_bind((struct sockaddr *)ss, port)) == -1)
		return (-1);
	proc_compose_imsg(&env->sc_ps, id, -1,
	    IMSG_UDP_SOCKET, -1, s, ss, sizeof(*ss));
	return (0);
}

int
config_getsocket(struct iked *env, struct imsg *imsg,
    void (*cb)(int, short, void *))
{
	struct iked_socket	*sock, **sptr, **nptr;

	log_debug("%s: received socket fd %d", __func__, imsg->fd);

	if ((sock = calloc(1, sizeof(*sock))) == NULL)
		fatal("config_getsocket: calloc");

	IMSG_SIZE_CHECK(imsg, &sock->sock_addr);

	memcpy(&sock->sock_addr, imsg->data, sizeof(sock->sock_addr));
	sock->sock_fd = imsg->fd;
	sock->sock_env = env;

	switch (sock->sock_addr.ss_family) {
	case AF_INET:
		sptr = &env->sc_sock4[0];
		nptr = &env->sc_sock4[1];
		break;
	case AF_INET6:
		sptr = &env->sc_sock6[0];
		nptr = &env->sc_sock6[1];
		break;
	default:
		fatal("config_getsocket: socket af");
		/* NOTREACHED */
	}
	if (*sptr == NULL)
		*sptr = sock;
	if (*nptr == NULL &&
	    socket_getport((struct sockaddr *)&sock->sock_addr) ==
	    IKED_NATT_PORT)
		*nptr = sock;

	event_set(&sock->sock_ev, sock->sock_fd,
	    EV_READ|EV_PERSIST, cb, sock);
	event_add(&sock->sock_ev, NULL);

	return (0);
}

int
config_setpfkey(struct iked *env, enum privsep_procid id)
{
	int	 s;

	if ((s = pfkey_socket()) == -1)
		return (-1);
	proc_compose_imsg(&env->sc_ps, id, -1,
	    IMSG_PFKEY_SOCKET, -1, s, NULL, 0);
	return (0);
}

int
config_getpfkey(struct iked *env, struct imsg *imsg)
{
	log_debug("%s: received pfkey fd %d", __func__, imsg->fd);
	pfkey_init(env, imsg->fd);
	return (0);
}

int
config_setuser(struct iked *env, struct iked_user *usr, enum privsep_procid id)
{
	if (env->sc_opts & IKED_OPT_NOACTION) {
		print_user(usr);
		return (0);
	}

	proc_compose(&env->sc_ps, id, IMSG_CFG_USER, usr, sizeof(*usr));
	return (0);
}

int
config_getuser(struct iked *env, struct imsg *imsg)
{
	struct iked_user	 usr;

	IMSG_SIZE_CHECK(imsg, &usr);
	memcpy(&usr, imsg->data, sizeof(usr));

	if (config_new_user(env, &usr) == NULL)
		return (-1);

	print_user(&usr);

	return (0);
}

int
config_setpolicy(struct iked *env, struct iked_policy *pol,
    enum privsep_procid id)
{
	struct iked_proposal	*prop;
	struct iked_transform	*xform;
	size_t			 iovcnt, j, c = 0;
	struct iovec		 iov[IOV_MAX];

	iovcnt = 1;
	TAILQ_FOREACH(prop, &pol->pol_proposals, prop_entry) {
		iovcnt += prop->prop_nxforms + 1;
	}

	if (iovcnt > IOV_MAX) {
		log_warn("%s: too many proposals", __func__);
		return (-1);
	}

	iov[c].iov_base = pol;
	iov[c++].iov_len = sizeof(*pol);

	TAILQ_FOREACH(prop, &pol->pol_proposals, prop_entry) {
		iov[c].iov_base = prop;
		iov[c++].iov_len = sizeof(*prop);

		for (j = 0; j < prop->prop_nxforms; j++) {
			xform = prop->prop_xforms + j;

			iov[c].iov_base = xform;
			iov[c++].iov_len = sizeof(*xform);
		}
	}

	print_policy(pol);

	if (env->sc_opts & IKED_OPT_NOACTION)
		return (0);

	if (proc_composev(&env->sc_ps, id, IMSG_CFG_POLICY, iov,
	    iovcnt) == -1) {
		log_debug("%s: proc_composev failed", __func__);
		return (-1);
	}

	return (0);
}

int
config_setflow(struct iked *env, struct iked_policy *pol,
    enum privsep_procid id)
{
	struct iked_flow	*flow;
	struct iovec		 iov[2];

	if (env->sc_opts & IKED_OPT_NOACTION)
		return (0);

	RB_FOREACH(flow, iked_flows, &pol->pol_flows) {
		iov[0].iov_base = &pol->pol_id;
		iov[0].iov_len = sizeof(pol->pol_id);
		iov[1].iov_base = flow;
		iov[1].iov_len = sizeof(*flow);

		if (proc_composev(&env->sc_ps, id, IMSG_CFG_FLOW,
		    iov, 2) == -1) {
			log_debug("%s: proc_composev failed", __func__);
			return (-1);
		}
	}

	return (0);
}

int
config_getpolicy(struct iked *env, struct imsg *imsg)
{
	struct iked_policy	*pol;
	struct iked_proposal	 pp, *prop;
	struct iked_transform	 xf, *xform;
	off_t			 offset = 0;
	unsigned int		 i, j;
	uint8_t			*buf = (uint8_t *)imsg->data;

	IMSG_SIZE_CHECK(imsg, pol);
	log_debug("%s: received policy", __func__);

	if ((pol = config_new_policy(NULL)) == NULL)
		fatal("config_getpolicy: new policy");

	memcpy(pol, buf, sizeof(*pol));
	offset += sizeof(*pol);

	TAILQ_INIT(&pol->pol_proposals);
	TAILQ_INIT(&pol->pol_sapeers);
	RB_INIT(&pol->pol_flows);

	for (i = 0; i < pol->pol_nproposals; i++) {
		memcpy(&pp, buf + offset, sizeof(pp));
		offset += sizeof(pp);

		if ((prop = config_add_proposal(&pol->pol_proposals,
		    pp.prop_id, pp.prop_protoid)) == NULL)
			fatal("config_getpolicy: add proposal");

		for (j = 0; j < pp.prop_nxforms; j++) {
			memcpy(&xf, buf + offset, sizeof(xf));
			offset += sizeof(xf);

			if ((xform = config_add_transform(prop, xf.xform_type,
			    xf.xform_id, xf.xform_length,
			    xf.xform_keylength)) == NULL)
				fatal("config_getpolicy: add transform");
		}
	}

	/* Flows are sent separately */
	pol->pol_nflows = 0;

	TAILQ_INSERT_TAIL(&env->sc_policies, pol, pol_entry);

	if (pol->pol_flags & IKED_POLICY_DEFAULT) {
		/* Only one default policy, just free/unref the old one */
		if (env->sc_defaultcon != NULL)
			config_free_policy(env, env->sc_defaultcon);
		env->sc_defaultcon = pol;
	}

	return (0);
}

int
config_getflow(struct iked *env, struct imsg *imsg)
{
	struct iked_policy	*pol;
	struct iked_flow	*flow;
	off_t			 offset = 0;
	unsigned int		 id;
	uint8_t			*buf = (uint8_t *)imsg->data;

	if (IMSG_DATA_SIZE(imsg) < sizeof(id))
		fatalx("bad length imsg received");

	memcpy(&id, buf, sizeof(id));
	offset += sizeof(id);

	TAILQ_FOREACH(pol, &env->sc_policies, pol_entry) {
		if (pol->pol_id == id)
			break;
	}
	if (pol == NULL) {
		log_warnx("%s: unknown policy %u", __func__, id);
		return (-1);
	}

	if ((flow = calloc(1, sizeof(*flow))) == NULL)
		fatal("config_getpolicy: new flow");

	memcpy(flow, buf + offset, sizeof(*flow));

	if (RB_INSERT(iked_flows, &pol->pol_flows, flow)) {
		log_warnx("%s: received duplicate flow", __func__);
		free(flow);
		return (-1);
	}
	pol->pol_nflows++;

	return (0);
}

int
config_setcompile(struct iked *env, enum privsep_procid id)
{
	if (env->sc_opts & IKED_OPT_NOACTION)
		return (0);

	proc_compose(&env->sc_ps, id, IMSG_COMPILE, NULL, 0);
	return (0);
}

int
config_getcompile(struct iked *env, struct imsg *imsg)
{
	/*
	 * Do any necessary steps after configuration, for now we
	 * only need to compile the skip steps.
	 */
	policy_calc_skip_steps(&env->sc_policies);

	log_debug("%s: compilation done", __func__);
	return (0);
}

int
config_setocsp(struct iked *env)
{
	if (env->sc_opts & IKED_OPT_NOACTION)
		return (0);
	proc_compose(&env->sc_ps, PROC_CERT,
	    IMSG_OCSP_URL, env->sc_ocsp_url,
	    env->sc_ocsp_url ? strlen(env->sc_ocsp_url) : 0);

	return (0);
}

int
config_getocsp(struct iked *env, struct imsg *imsg)
{
	free(env->sc_ocsp_url);
	if (IMSG_DATA_SIZE(imsg) > 0)
		env->sc_ocsp_url = get_string(imsg->data, IMSG_DATA_SIZE(imsg));
	else
		env->sc_ocsp_url = NULL;
	log_debug("%s: ocsp_url %s", __func__,
	    env->sc_ocsp_url ? env->sc_ocsp_url : "none");
	return (0);
}

int
config_setkeys(struct iked *env)
{
	FILE			*fp = NULL;
	EVP_PKEY		*key = NULL;
	struct iked_id		 privkey;
	struct iked_id		 pubkey;
	struct iovec		 iov[2];
	int			 ret = -1;

	memset(&privkey, 0, sizeof(privkey));
	memset(&pubkey, 0, sizeof(pubkey));

	/* Read private key */
	if ((fp = fopen(IKED_PRIVKEY, "r")) == NULL) {
		log_warn("%s: failed to open private key", __func__);
		goto done;
	}

	if ((key = PEM_read_PrivateKey(fp, NULL, NULL, NULL)) == NULL) {
		log_warnx("%s: failed to read private key", __func__);
		goto done;
	}

	if (ca_privkey_serialize(key, &privkey) != 0) {
		log_warnx("%s: failed to serialize private key", __func__);
		goto done;
	}
	if (ca_pubkey_serialize(key, &pubkey) != 0) {
		log_warnx("%s: failed to serialize public key", __func__);
		goto done;
	}

	iov[0].iov_base = &privkey;
	iov[0].iov_len = sizeof(privkey);
	iov[1].iov_base = ibuf_data(privkey.id_buf);
	iov[1].iov_len = ibuf_length(privkey.id_buf);

	if (proc_composev(&env->sc_ps, PROC_CERT, IMSG_PRIVKEY, iov, 2) == -1) {
		log_warnx("%s: failed to send private key", __func__);
		goto done;
	}

	iov[0].iov_base = &pubkey;
	iov[0].iov_len = sizeof(pubkey);
	iov[1].iov_base = ibuf_data(pubkey.id_buf);
	iov[1].iov_len = ibuf_length(pubkey.id_buf);

	if (proc_composev(&env->sc_ps, PROC_CERT, IMSG_PUBKEY, iov, 2) == -1) {
		log_warnx("%s: failed to send public key", __func__);
		goto done;
	}

	ret = 0;
 done:
	if (fp != NULL)
		fclose(fp);

	ibuf_release(pubkey.id_buf);
	ibuf_release(privkey.id_buf);
	EVP_PKEY_free(key);

	return (ret);
}

int
config_getkey(struct iked *env, struct imsg *imsg)
{
	size_t		 len;
	struct iked_id	 id;

	len = IMSG_DATA_SIZE(imsg);
	if (len <= sizeof(id))
		fatalx("%s: invalid key message", __func__);

	memcpy(&id, imsg->data, sizeof(id));
	if ((id.id_buf = ibuf_new((uint8_t *)imsg->data + sizeof(id),
	    len - sizeof(id))) == NULL)
		fatalx("%s: failed to get key", __func__);

	explicit_bzero(imsg->data, len);
	ca_getkey(&env->sc_ps, &id, imsg->hdr.type);

	return (0);
}
@


1.47
log
@Factor out flows into separate configuration messages

We reach an imsg payload limit with just a few traffic selectors
so in order to load more we need to split them up and send separately.

Suggested and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.46 2017/03/27 10:29:02 reyk Exp $	*/
d100 1
@


1.46
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.45 2017/03/27 10:24:36 reyk Exp $	*/
a627 1
	struct iked_flow	*flow;
d629 1
a629 1
	size_t			 size, iovcnt, j, c = 0;
a632 1
	size = sizeof(*pol);
a633 2
		size += (prop->prop_nxforms * sizeof(*xform)) +
		    (sizeof(*prop));
a636 2
	iovcnt += pol->pol_nflows;

d638 1
a638 1
		log_warn("%s: too many proposals/flows", __func__);
d657 9
a665 3
	RB_FOREACH(flow, iked_flows, &pol->pol_flows) {
		iov[c].iov_base = flow;
		iov[c++].iov_len = sizeof(*flow);
d668 9
a676 1
	print_policy(pol);
d681 12
a692 2
	if (proc_composev(&env->sc_ps, id, IMSG_CFG_POLICY, iov, iovcnt) == -1)
		return (-1);
a702 1
	struct iked_flow	*flow;
d739 2
a740 10
	for (i = 0; i < pol->pol_nflows; i++) {
		if ((flow = calloc(1, sizeof(*flow))) == NULL)
			fatal("config_getpolicy: new flow");

		memcpy(flow, buf + offset, sizeof(*flow));
		offset += sizeof(*flow);

		if (RB_INSERT(iked_flows, &pol->pol_flows, flow))
			free(flow);
	}
d750 39
@


1.45
log
@Fix another iked leak of SAs in pfkey_sa(), copy tags correctly.

Diff from markus@@
OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.44 2017/03/13 18:49:20 mikeb Exp $	*/
a157 1

@


1.44
log
@Resolve simultaneous Child SA rekeying

From and OK markus, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.43 2017/01/03 17:51:38 reyk Exp $	*/
d156 2
@


1.43
log
@Fix pledge of the ca process by calling the right function on startup.
As a related change, load the local.pub and local.key keys after
privsep and reload them on SIGHUP/reload.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.42 2016/06/01 11:16:41 patrick Exp $	*/
d130 2
@


1.42
log
@Implement a second address pool specifically for IPv6, so that
clients can be given an IPv4 and IPv6 address at the same time,
thus enabling dual stack usage.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.41 2015/12/07 12:46:37 reyk Exp $	*/
d34 3
d787 86
@


1.41
log
@Sync proc.c, use shorter proc_compose[v]()
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.40 2015/11/18 16:46:30 reyk Exp $	*/
d106 4
@


1.40
log
@pledge exposed a simple bug: the unprivileged child tried to print the
policy after receiving it from the parent.  print_policy ->
print_proto -> getprotobynumber -> pledge abort because it tried to
access /etc/protocols without rpath.  It was just a debugging message
that can be moved to the parent (printing the policy on the sender
side and not the receiver side).  The parent has rpath and dns.

Issue found by sthen@@ with "proto etherip"
OK sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.39 2015/10/19 11:25:35 reyk Exp $	*/
d417 1
a417 1
	proc_compose_imsg(&env->sc_ps, PROC_IKEV2, -1, type, -1, NULL, 0);
d435 1
a435 1
	proc_compose_imsg(&env->sc_ps, PROC_IKEV2, -1, type, -1, NULL, 0);
d461 1
a461 2
	proc_compose_imsg(&env->sc_ps, id, -1,
	    IMSG_CTL_RESET, -1, &mode, sizeof(mode));
d517 1
a517 1
	    IMSG_UDP_SOCKET, s, ss, sizeof(*ss));
d573 1
a573 1
	    IMSG_PFKEY_SOCKET, s, NULL, 0);
d593 1
a593 2
	proc_compose_imsg(&env->sc_ps, id, -1,
	    IMSG_CFG_USER, -1, usr, sizeof(*usr));
d663 1
a663 2
	if (proc_composev_imsg(&env->sc_ps, id, -1,
	    IMSG_CFG_POLICY, -1, iov, iovcnt) == -1)
d741 1
a741 2
	proc_compose_imsg(&env->sc_ps, id, -1,
	    IMSG_COMPILE, -1, NULL, 0);
d763 2
a764 2
	proc_compose_imsg(&env->sc_ps, PROC_CERT, -1,
	    IMSG_OCSP_URL, -1, env->sc_ocsp_url,
@


1.39
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.38 2015/10/15 18:40:38 mmcc Exp $	*/
d660 3
a662 2
	if (env->sc_opts & IKED_OPT_NOACTION) {
		print_policy(pol);
a663 1
	}
a733 2

	print_policy(pol);
@


1.38
log
@Remove some unnecessary NULL-checks before free(). Change two bzero()
calls on pf data to explicit_bzero().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.37 2015/08/21 11:59:27 reyk Exp $	*/
a416 1
	proc_compose_imsg(&env->sc_ps, PROC_IKEV1, -1, type, -1, NULL, 0);
a434 1
	proc_compose_imsg(&env->sc_ps, PROC_IKEV1, -1, type, -1, NULL, 0);
@


1.37
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.36 2015/07/07 19:13:31 markus Exp $	*/
d145 1
a145 2
	if (sa->sa_eapid != NULL)
		free(sa->sa_eapid);
d781 1
a781 2
	if (env->sc_ocsp_url)
		free(env->sc_ocsp_url);
@


1.36
log
@repair policy-ikesa-linking by replacing the broken RB_TREE w/TAILQ
(e.g. the policy might be used-after-free on 'ikectl reconfig')
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.35 2015/02/06 10:39:01 deraadt Exp $	*/
d64 1
a64 1
u_int64_t
d67 1
a67 1
	u_int64_t	 spi;
d197 2
a198 1
config_add_proposal(struct iked_proposals *head, u_int id, u_int proto)
d220 1
a220 1
config_free_proposals(struct iked_proposals *head, u_int proto)
d287 2
a288 2
config_add_transform(struct iked_proposal *prop, u_int type,
    u_int id, u_int length, u_int keylength)
d293 1
a293 1
	u_int			 i;
d362 2
a363 2
config_findtransform(struct iked_proposals *props, u_int8_t type,
    u_int proto)
d367 1
a367 1
	u_int			 i;
d413 1
a413 1
config_setcoupled(struct iked *env, u_int couple)
d415 1
a415 1
	u_int	 type;
d425 1
a425 1
config_getcoupled(struct iked *env, u_int type)
d432 1
a432 1
config_setmode(struct iked *env, u_int passive)
d434 1
a434 1
	u_int	 type;
d444 1
a444 1
config_getmode(struct iked *env, u_int type)
d446 2
a447 2
	u_int8_t	 old;
	u_char		*mode[] = { "active", "passive" };
d462 1
a462 1
config_setreset(struct iked *env, u_int mode, enum privsep_procid id)
d475 1
a475 1
	u_int			 mode;
d683 2
a684 2
	u_int			 i, j;
	u_int8_t		*buf = (u_int8_t *)imsg->data;
@


1.35
log
@unneeded getopt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.34 2015/01/16 06:39:58 deraadt Exp $	*/
d109 1
a109 1
		(void)RB_REMOVE(iked_sapeers, &sa->sa_policy->pol_sapeers, sa);
d160 1
d162 2
a163 1
	RB_INIT(&pol->pol_sapeers);
d178 2
a179 2
	RB_FOREACH(sa, iked_sapeers, &pol->pol_sapeers) {
		/* Remove from the policy tree, but keep for existing SAs */
d182 3
d695 1
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.33 2014/12/03 23:18:21 deraadt Exp $	*/
a27 1
#include <getopt.h>
@


1.33
log
@Init SPI using arc4random_buf, rather than (r << 32) | r
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.32 2014/10/08 05:47:03 deraadt Exp $	*/
a18 1
#include <sys/param.h>
@


1.32
log
@trivial use of reallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.31 2014/05/06 14:10:53 markus Exp $	*/
d71 3
a73 3
	spi = ((u_int64_t)arc4random() << 32) | arc4random();
	if (spi == 0)
		return (config_getspi());
@


1.31
log
@change the create-child-sa responder code, so it does not store any
state in the ikesa structure. this way we can initiate a create-child-sa
and process requests for the peer at the same time. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.30 2014/05/06 10:24:22 markus Exp $	*/
d338 2
a339 2
	if ((xform = realloc(prop->prop_xforms,
	    (prop->prop_nxforms + 1) * sizeof(*xform))) == NULL) {
@


1.30
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.29 2014/05/06 09:48:40 markus Exp $	*/
d76 17
@


1.29
log
@cleanup IKE-SA tree handling (fixes repeated-insert & double-remove)

sa_new() always re-inserts an SA into the SA tree. in case of a key
collision it would try to free the new SA. While doing that it would
accidentially free the existing SA, since config_free_sa() does
RB_REMOVE() uncoditionally.  This change fixes this by:
a) moving the responsibility for RB_REMOVE() to CALLER of config_free_sa() and
b) by calling config_free_sa() instead of sa_free() from sa_new()
It also changes to code to NEVER re-add an SA to the tree. So
RB_INSERT() is ONLY called once per SA. The code also makes sure
that there is always a KEY defined for this tree (ispi).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.28 2014/05/06 07:24:37 markus Exp $	*/
d82 1
@


1.28
log
@initial support for PFS; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2014/04/22 12:00:03 reyk Exp $	*/
a80 2
	(void)RB_REMOVE(iked_sas, &env->sc_sas, sa);

d472 1
@


1.27
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2014/02/17 15:53:46 markus Exp $	*/
d342 2
a343 1
config_findtransform(struct iked_proposals *props, u_int8_t type)
d351 3
@


1.26
log
@interpret 'config address net/prefix' as a pool of addresses and
randomly choose the address for CFG_REQUEST. this address will be used
to replace 0.0.0.0/32 in the specified flow. e.g.
> ikev2 passive esp from 192.168.1.0/24 to 0.0.0.0 \
>     config address 192.168.10.200/24
will assign an address between 192.168.10.200 and 192.168.10.254
and replace 0.0.0.0 with this address.
ok mikeb@@ on older version of this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2014/02/17 15:07:23 markus Exp $	*/
d394 2
a395 2
	proc_compose_imsg(env, PROC_IKEV1, type, -1, NULL, 0);
	proc_compose_imsg(env, PROC_IKEV2, type, -1, NULL, 0);
d413 2
a414 2
	proc_compose_imsg(env, PROC_IKEV1, type, -1, NULL, 0);
	proc_compose_imsg(env, PROC_IKEV2, type, -1, NULL, 0);
d440 2
a441 1
	proc_compose_imsg(env, id, IMSG_CTL_RESET, -1, &mode, sizeof(mode));
d495 2
a496 2
	proc_compose_imsg(env, id, IMSG_UDP_SOCKET, s,
	    ss, sizeof(*ss));
d551 2
a552 1
	proc_compose_imsg(env, id, IMSG_PFKEY_SOCKET, s, NULL, 0);
d572 2
a573 1
	proc_compose_imsg(env, id, IMSG_CFG_USER, -1, usr, sizeof(*usr));
d643 2
a644 2
	if (proc_composev_imsg(env, id, IMSG_CFG_POLICY, -1,
	    iov, iovcnt) == -1)
d723 2
a724 1
	proc_compose_imsg(env, id, IMSG_COMPILE, -1, NULL, 0);
d746 2
a747 1
	proc_compose_imsg(env, PROC_CERT, IMSG_OCSP_URL, -1, env->sc_ocsp_url,
@


1.25
log
@basic OCSP support. enable with 'set ocsp "http://10.0.0.10:8888/"'
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2014/01/24 05:58:52 mikeb Exp $	*/
d88 5
@


1.24
log
@use a bit saner timer api
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2013/12/03 13:55:39 markus Exp $	*/
d729 25
@


1.23
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2013/11/28 20:28:34 markus Exp $	*/
d83 1
a83 1
	timer_deregister(env, &sa->sa_timer);
@


1.22
log
@don't leak duplicate flows; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2013/10/24 02:55:50 deraadt Exp $	*/
d527 2
a528 1
	    socket_getport(&sock->sock_addr) == IKED_NATT_PORT)
@


1.21
log
@no need for netinet/ip_var.h (and friends)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2013/03/21 04:30:14 deraadt Exp $	*/
d690 2
a691 1
		RB_INSERT(iked_flows, &pol->pol_flows, flow);
@


1.20
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2013/01/08 10:38:19 reyk Exp $	*/
a23 7

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
@


1.19
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2012/12/15 23:20:17 reyk Exp $	*/
a19 1
#include <sys/types.h>
@


1.18
log
@Remove unused variables.
@
text
@d1 1
a1 2
/*	$OpenBSD: config.c,v 1.17 2012/10/22 10:25:17 reyk Exp $	*/
/*	$vantronix: config.c,v 1.30 2010/05/28 15:34:35 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.17
log
@Fix NAT-T support in iked, both on the initiator and the responder
side.  Also add a new command line option -t to optionally enforce
NAT-T with UDP encapsulation on port 4500.

Tested by mikeb@@ and me
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2012/09/18 12:07:59 reyk Exp $	*/
a610 1
	size += pol->pol_nflows * sizeof(*flow);
@


1.16
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2012/07/02 13:03:24 mikeb Exp $	*/
d507 1
a507 1
	struct iked_socket	*sock, **sptr;
d522 2
a523 1
		sptr = &env->sc_sock4;
d526 2
a527 1
		sptr = &env->sc_sock6;
d535 3
@


1.15
log
@Don't close IKE SA immediately after creating a new one when rekeying.
Instead set a timeout that will shut it down in case we don't get an SA
delete notification.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2012/06/22 16:28:20 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.14
log
@Add initial support for retransmition timeouts and response retries.
This should still be considered an experimental work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2011/07/05 19:59:00 tedu Exp $	*/
d91 2
@


1.13
log
@fix memcpy sizeof.  found by jsg.  ok deraadt krw mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2011/05/09 11:15:18 reyk Exp $	*/
d59 2
d100 3
@


1.12
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2011/05/05 12:17:10 reyk Exp $	*/
d369 1
a369 1
		memcpy(old, new, sizeof(old));
@


1.11
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2011/04/18 08:45:43 reyk Exp $	*/
d391 2
a392 2
	imsg_compose_proc(env, PROC_IKEV1, type, -1, NULL, 0);
	imsg_compose_proc(env, PROC_IKEV2, type, -1, NULL, 0);
d410 2
a411 2
	imsg_compose_proc(env, PROC_IKEV1, type, -1, NULL, 0);
	imsg_compose_proc(env, PROC_IKEV2, type, -1, NULL, 0);
d437 1
a437 1
	imsg_compose_proc(env, id, IMSG_CTL_RESET, -1, &mode, sizeof(mode));
d491 1
a491 1
	imsg_compose_proc(env, id, IMSG_UDP_SOCKET, s,
d541 1
a541 1
	imsg_compose_proc(env, id, IMSG_PFKEY_SOCKET, s, NULL, 0);
d561 1
a561 1
	imsg_compose_proc(env, id, IMSG_CFG_USER, -1, usr, sizeof(*usr));
d632 1
a632 1
	if (imsg_composev_proc(env, id, IMSG_CFG_POLICY, -1,
d711 1
a711 1
	imsg_compose_proc(env, id, IMSG_COMPILE, -1, NULL, 0);
@


1.10
log
@When the kernel wants to acquire an SA for an unknown flow, lookup a
matching policy and init a new IKE SA.  This adds support for "acquire mode"
from static flows.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2011/01/26 16:59:23 mikeb Exp $	*/
d435 1
a435 1
config_setreset(struct iked *env, u_int mode, enum iked_procid id)
d485 1
a485 1
    in_port_t port, enum iked_procid id)
d535 1
a535 1
config_setpfkey(struct iked *env, enum iked_procid id)
d554 1
a554 1
config_setuser(struct iked *env, struct iked_user *usr, enum iked_procid id)
d583 1
a583 1
    enum iked_procid id)
d706 1
a706 1
config_setcompile(struct iked *env, enum iked_procid id)
@


1.9
log
@get rid of acquire flows completely, as they tend to pass traffic
when there's no sa established (as pointed out by reyk).  instead
use require mode feature to send acquires from the kernel.  this
allows us to get rid of the code that changes flow mode to acquire
and keep all installed flows in the tree and save up on some code
that deals with renegotiation.  also several entities were renamed
(iked_acqflows -> iked_activeflows, iked_ipsecsas -> iked_activesas,
ikev2_acquire -> ikev2_acquire_sa).   ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2011/01/21 11:56:00 reyk Exp $	*/
d92 1
a92 1
	config_free_flows(env, &sa->sa_flows);
d222 2
a223 3
	for (flow = TAILQ_FIRST(head); flow != NULL; flow = next) {
		next = TAILQ_NEXT(flow, flow_entry);

d225 1
a225 5

		if (flow->flow_loaded)
			RB_REMOVE(iked_activeflows, &env->sc_activeflows, flow);
		TAILQ_REMOVE(head, flow, flow_entry);
		(void)pfkey_flow_delete(env->sc_pfkey, flow);
d622 1
a622 1
	TAILQ_FOREACH(flow, &pol->pol_flows, flow_entry) {
d660 1
a660 1
	TAILQ_INIT(&pol->pol_flows);
d688 1
a688 1
		TAILQ_INSERT_TAIL(&pol->pol_flows, flow, flow_entry);
@


1.8
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2011/01/21 11:37:02 reyk Exp $	*/
d227 2
d261 1
a261 1
			RB_REMOVE(iked_ipsecsas, &env->sc_ipsecsas, csa);
@


1.7
log
@split pfkey initialization into a privileged and unprivileged part to
prevent a possible crash.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2011/01/12 14:35:45 mikeb Exp $	*/
a145 3
	if (env != NULL)
		RB_INSERT(iked_policies, &env->sc_policies, pol);

d157 1
a157 1
	(void)RB_REMOVE(iked_policies, &env->sc_policies, pol);
d457 1
a457 1
		for (pol = RB_MIN(iked_policies, &env->sc_policies);
d459 1
a459 2
			nextpol =
			    RB_NEXT(iked_policies, &env->sc_policies, pol);
d645 1
a645 1
	struct iked_policy	*pol, *old;
d694 1
a694 5
	if ((old = RB_INSERT(iked_policies,
	    &env->sc_policies, pol)) != NULL) {
		config_free_policy(env, old);
		RB_INSERT(iked_policies, &env->sc_policies, pol);
	}
d696 4
a699 1
	if (pol->pol_flags & IKED_POLICY_DEFAULT)
d701 1
d705 23
@


1.6
log
@postpone processing of pfkey messages received in pfkey_reply instead of
just dropping them;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2010/12/22 16:22:27 mikeb Exp $	*/
d546 1
a546 1
	if ((s = pfkey_init(env)) == -1)
d553 1
a553 2
config_getpfkey(struct iked *env, struct imsg *imsg,
    void (*dispatch)(int, short, void *))
d556 1
a556 4
	env->sc_pfkey = imsg->fd;
	event_set(&env->sc_pfkeyev, env->sc_pfkey,
	    EV_READ|EV_PERSIST, dispatch, env);
	event_add(&env->sc_pfkeyev, NULL);
@


1.5
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2010/06/14 08:10:32 reyk Exp $	*/
d546 1
a546 1
	if ((s = pfkey_init()) == -1)
@


1.4
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2010/06/10 14:08:37 reyk Exp $	*/
d92 1
a92 1
	config_free_flows(env, &sa->sa_flows, NULL);
d173 1
a173 1
	config_free_flows(env, &pol->pol_flows, NULL);
d221 1
a221 2
config_free_flows(struct iked *env, struct iked_flows *head,
    struct iked_spi *spi)
a227 3
		if (spi != NULL && spi->spi != flow->flow_peerspi)
			continue;

d261 4
a264 1
		(void)pfkey_sa_delete(env->sc_pfkey, csa);
d553 2
a554 1
config_getpfkey(struct iked *env, struct imsg *imsg)
d558 3
@


1.3
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2010/06/10 12:06:34 reyk Exp $	*/
d60 1
d508 1
a508 1
	struct iked_socket	*sock;
d520 14
@


1.2
log
@Add another tree to lookup policy SAs by peer address.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d390 49
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 4
a96 1
	policy_unref(env, sa->sa_policy);
d143 1
d154 1
a154 1
	struct iked_sa	*sa;
d161 1
a161 1
	RB_FOREACH(sa, iked_sas, &env->sc_sas) {
@

