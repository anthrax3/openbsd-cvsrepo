head	1.52;
access;
symbols
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.52
date	2017.04.26.10.42.38;	author henning;	state Exp;
branches;
next	1.51;
commitid	4JCdLHI0iXkeq6jm;

1.51
date	2017.03.27.10.21.19;	author reyk;	state Exp;
branches;
next	1.50;
commitid	luuYVyfWc8UoYDKf;

1.50
date	2017.03.27.10.06.41;	author reyk;	state Exp;
branches;
next	1.49;
commitid	37oqp7mUEkdGuEb4;

1.49
date	2017.03.13.17.41.14;	author reyk;	state Exp;
branches;
next	1.48;
commitid	9gRqWsDzrTZXxOb2;

1.48
date	2017.01.20.14.09.00;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	xkkfx0KBr23Qc1Ef;

1.47
date	2017.01.20.13.58.05;	author mikeb;	state Exp;
branches;
next	1.46;
commitid	7OJZOZxhSgP6lJVa;

1.46
date	2016.09.04.10.26.02;	author vgross;	state Exp;
branches;
next	1.45;
commitid	2AXsFnCZH4WCra85;

1.45
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.44;
commitid	HzcDW70HFbhaqvT8;

1.44
date	2015.10.15.18.40.38;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	rQFz7wM8cPpo2dCG;

1.43
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.42;
commitid	CNs9dXqQUQ09vB19;

1.42
date	2015.03.26.19.52.35;	author markus;	state Exp;
branches;
next	1.41;
commitid	OLM4J0heQ8InGopV;

1.41
date	2015.02.15.01.56.42;	author tedu;	state Exp;
branches;
next	1.40;
commitid	MizPuKMrwD760Res;

1.40
date	2015.02.06.10.39.01;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	fN2B4abgRqE4hFJn;

1.39
date	2015.01.19.14.42.42;	author mikeb;	state Exp;
branches;
next	1.38;
commitid	6zq5j7t9YeU29dry;

1.38
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2014.11.07.14.02.32;	author mikeb;	state Exp;
branches;
next	1.36;
commitid	auhursM13zeUc6fY;

1.36
date	2014.08.25.07.50.25;	author doug;	state Exp;
branches;
next	1.35;
commitid	vcwz0sp1JH7QzUmA;

1.35
date	2014.05.07.13.04.01;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.06.10.24.22;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.05.16.14.37;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.29.11.51.13;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.10.16.08.02;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.17.11.00.14;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.24.05.58.52;	author mikeb;	state Exp;
branches;
next	1.27;

1.27
date	2013.12.03.13.55.39;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2013.09.26.13.09.38;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.15.23.20.17;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.22.10.25.17;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2012.06.27.15.36.36;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2012.06.27.14.03.50;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.26.11.09.10;	author mikeb;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.26.11.00.28;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2012.06.22.16.28.20;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2012.05.30.09.18.14;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.24.14.41.36;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2012.05.07.10.58.38;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.21.12.37.28;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.21.11.56.00;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.22.16.22.27;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.30.10.34.56;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.27.01.03.22;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.14.23.23.52;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.14.21.12.56;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.11.33.55;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.14.08.55.59;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.14.08.10.32;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.10.08.29.47;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.52
log
@cope with IP address changes. before, we were trying to resend the msg
with the no-longer-available address over and over and over, requiring
iked to be restarted eventually. instead, on EADDRNOTAVAIL, schedule
SA deletion so a new one is set up shortly thereafter. ok reyk mikeb
@
text
@/*	$OpenBSD: ikev2_msg.c,v 1.51 2017/03/27 10:21:19 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* roundup */
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include <openssl/sha.h>
#include <openssl/evp.h>

#include "iked.h"
#include "ikev2.h"
#include "eap.h"
#include "dh.h"

void	 ikev1_recv(struct iked *, struct iked_message *);
void	 ikev2_msg_response_timeout(struct iked *, void *);
void	 ikev2_msg_retransmit_timeout(struct iked *, void *);

void
ikev2_msg_cb(int fd, short event, void *arg)
{
	struct iked_socket	*sock = arg;
	struct iked		*env = sock->sock_env;
	struct iked_message	 msg;
	struct ike_header	 hdr;
	uint32_t		 natt = 0x00000000;
	uint8_t			 buf[IKED_MSGBUF_MAX];
	ssize_t			 len;
	off_t			 off;

	bzero(&msg, sizeof(msg));
	bzero(buf, sizeof(buf));

	msg.msg_peerlen = sizeof(msg.msg_peer);
	msg.msg_locallen = sizeof(msg.msg_local);
	msg.msg_parent = &msg;
	memcpy(&msg.msg_local, &sock->sock_addr, sizeof(sock->sock_addr));

	if ((len = recvfromto(fd, buf, sizeof(buf), 0,
	    (struct sockaddr *)&msg.msg_peer, &msg.msg_peerlen,
	    (struct sockaddr *)&msg.msg_local, &msg.msg_locallen)) <
	    (ssize_t)sizeof(natt))
		return;

	if (socket_getport((struct sockaddr *)&msg.msg_local) ==
	    IKED_NATT_PORT) {
		if (memcmp(&natt, buf, sizeof(natt)) != 0)
			return;
		msg.msg_natt = 1;
		off = sizeof(natt);
	} else
		off = 0;

	if ((size_t)(len - off) <= sizeof(hdr))
		return;
	memcpy(&hdr, buf + off, sizeof(hdr));

	if ((msg.msg_data = ibuf_new(buf + off, len - off)) == NULL)
		return;

	TAILQ_INIT(&msg.msg_proposals);
	msg.msg_fd = fd;

	if (hdr.ike_version == IKEV1_VERSION)
		ikev1_recv(env, &msg);
	else
		ikev2_recv(env, &msg);

	ikev2_msg_cleanup(env, &msg);
}

void
ikev1_recv(struct iked *env, struct iked_message *msg)
{
	struct ike_header	*hdr;

	if (ibuf_size(msg->msg_data) <= sizeof(*hdr)) {
		log_debug("%s: short message", __func__);
		return;
	}

	hdr = (struct ike_header *)ibuf_data(msg->msg_data);

	log_debug("%s: header ispi %s rspi %s"
	    " nextpayload %u version 0x%02x exchange %u flags 0x%02x"
	    " msgid %u length %u", __func__,
	    print_spi(betoh64(hdr->ike_ispi), 8),
	    print_spi(betoh64(hdr->ike_rspi), 8),
	    hdr->ike_nextpayload,
	    hdr->ike_version,
	    hdr->ike_exchange,
	    hdr->ike_flags,
	    betoh32(hdr->ike_msgid),
	    betoh32(hdr->ike_length));

	log_debug("%s: IKEv1 not supported", __func__);
}

struct ibuf *
ikev2_msg_init(struct iked *env, struct iked_message *msg,
    struct sockaddr_storage *peer, socklen_t peerlen,
    struct sockaddr_storage *local, socklen_t locallen, int response)
{
	bzero(msg, sizeof(*msg));
	memcpy(&msg->msg_peer, peer, peerlen);
	msg->msg_peerlen = peerlen;
	memcpy(&msg->msg_local, local, locallen);
	msg->msg_locallen = locallen;
	msg->msg_response = response ? 1 : 0;
	msg->msg_fd = -1;
	msg->msg_data = ibuf_static();
	msg->msg_e = 0;
	msg->msg_parent = msg;	/* has to be set */
	TAILQ_INIT(&msg->msg_proposals);

	return (msg->msg_data);
}

struct iked_message *
ikev2_msg_copy(struct iked *env, struct iked_message *msg)
{
	struct iked_message		*m = NULL;
	struct ibuf			*buf;
	size_t				 len;
	void				*ptr;

	if (ibuf_size(msg->msg_data) < msg->msg_offset)
		return (NULL);
	len = ibuf_size(msg->msg_data) - msg->msg_offset;

	if ((ptr = ibuf_seek(msg->msg_data, msg->msg_offset, len)) == NULL ||
	    (m = malloc(sizeof(*m))) == NULL ||
	    (buf = ikev2_msg_init(env, m, &msg->msg_peer, msg->msg_peerlen,
	     &msg->msg_local, msg->msg_locallen, msg->msg_response)) == NULL ||
	    ibuf_add(buf, ptr, len))
		return (NULL);

	m->msg_fd = msg->msg_fd;
	m->msg_msgid = msg->msg_msgid;
	m->msg_offset = msg->msg_offset;
	m->msg_sa = msg->msg_sa;

	return (m);
}

void
ikev2_msg_cleanup(struct iked *env, struct iked_message *msg)
{
	if (msg == msg->msg_parent) {
		ibuf_release(msg->msg_nonce);
		ibuf_release(msg->msg_ke);
		ibuf_release(msg->msg_auth.id_buf);
		ibuf_release(msg->msg_id.id_buf);
		ibuf_release(msg->msg_cert.id_buf);
		ibuf_release(msg->msg_cookie);

		msg->msg_nonce = NULL;
		msg->msg_ke = NULL;
		msg->msg_auth.id_buf = NULL;
		msg->msg_id.id_buf = NULL;
		msg->msg_cert.id_buf = NULL;
		msg->msg_cookie = NULL;

		config_free_proposals(&msg->msg_proposals, 0);
	}

	if (msg->msg_data != NULL) {
		ibuf_release(msg->msg_data);
		msg->msg_data = NULL;
	}
}

int
ikev2_msg_valid_ike_sa(struct iked *env, struct ike_header *oldhdr,
    struct iked_message *msg)
{
#if 0
	/* XXX Disabled, see comment below */
	struct iked_message		 resp;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ikev2_notify		*n;
	struct ibuf			*buf;
	struct iked_sa			 sa;
#endif

	if (msg->msg_sa != NULL && msg->msg_policy != NULL) {
		if (msg->msg_sa->sa_state == IKEV2_STATE_CLOSED)
			return (-1);
		/*
		 * Only permit informational requests from initiator
		 * on closing SAs (for DELETE).
		 */
		if (msg->msg_sa->sa_state == IKEV2_STATE_CLOSING) {
			if (((oldhdr->ike_flags &
			    (IKEV2_FLAG_INITIATOR|IKEV2_FLAG_RESPONSE)) ==
			    IKEV2_FLAG_INITIATOR) &&
			    (oldhdr->ike_exchange ==
			    IKEV2_EXCHANGE_INFORMATIONAL))
				return (0);
			return (-1);
		}
		return (0);
	}

#if 0
	/*
	 * XXX Sending INVALID_IKE_SPIs notifications is disabled
	 * XXX because it is not mandatory and ignored by most
	 * XXX implementations.  We might want to enable it in
	 * XXX combination with a rate-limitation to avoid DoS situations.
	 */

	/* Fail without error message */
	if (msg->msg_response || msg->msg_policy == NULL)
		return (-1);

	/* Invalid IKE SA, return notification */
	if ((buf = ikev2_msg_init(env, &resp,
	    &msg->msg_peer, msg->msg_peerlen,
	    &msg->msg_local, msg->msg_locallen, 1)) == NULL)
		goto done;

	resp.msg_fd = msg->msg_fd;

	bzero(&sa, sizeof(sa));
	if ((oldhdr->ike_flags & IKEV2_FLAG_INITIATOR) == 0)
		sa.sa_hdr.sh_initiator = 1;
	sa.sa_hdr.sh_ispi = betoh64(oldhdr->ike_ispi);
	sa.sa_hdr.sh_rspi = betoh64(oldhdr->ike_rspi);

	resp.msg_msgid = betoh32(oldhdr->ike_msgid);

	/* IKE header */
	if ((hdr = ikev2_add_header(buf, &sa, resp.msg_msgid,
	    IKEV2_PAYLOAD_NOTIFY, IKEV2_EXCHANGE_INFORMATIONAL,
	    IKEV2_FLAG_RESPONSE)) == NULL)
		goto done;

	/* SA payload */
	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;
	if ((n = ibuf_advance(buf, sizeof(*n))) == NULL)
		goto done;
	n->n_protoid = IKEV2_SAPROTO_IKE;
	n->n_spisize = 0;
	n->n_type = htobe16(IKEV2_N_INVALID_IKE_SPI);

	if (ikev2_next_payload(pld, sizeof(*n), IKEV2_PAYLOAD_NONE) == -1)
		goto done;

	if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
		goto done;

	(void)ikev2_pld_parse(env, hdr, &resp, 0);
	(void)ikev2_msg_send(env, &resp);

 done:
	ikev2_msg_cleanup(env, &resp);
#endif

	/* Always fail */
	return (-1);
}

int
ikev2_msg_send(struct iked *env, struct iked_message *msg)
{
	struct iked_sa		*sa = msg->msg_sa;
	struct ibuf		*buf = msg->msg_data;
	uint32_t		 natt = 0x00000000;
	int			 isnatt = 0;
	uint8_t			 exchange, flags;
	struct ike_header	*hdr;
	struct iked_message	*m;

	if (buf == NULL || (hdr = ibuf_seek(msg->msg_data,
	    msg->msg_offset, sizeof(*hdr))) == NULL)
		return (-1);

	isnatt = (msg->msg_natt || (msg->msg_sa && msg->msg_sa->sa_natt));

	exchange = hdr->ike_exchange;
	flags = hdr->ike_flags;
	log_info("%s: %s %s from %s to %s msgid %u, %ld bytes%s", __func__,
	    print_map(exchange, ikev2_exchange_map),
	    (flags & IKEV2_FLAG_RESPONSE) ? "response" : "request",
	    print_host((struct sockaddr *)&msg->msg_local, NULL, 0),
	    print_host((struct sockaddr *)&msg->msg_peer, NULL, 0),
	    betoh32(hdr->ike_msgid),
	    ibuf_length(buf), isnatt ? ", NAT-T" : "");

	if (isnatt) {
		if (ibuf_prepend(buf, &natt, sizeof(natt)) == -1) {
			log_debug("%s: failed to set NAT-T", __func__);
			return (-1);
		}
	}

	if (sendtofrom(msg->msg_fd, ibuf_data(buf), ibuf_size(buf), 0,
	    (struct sockaddr *)&msg->msg_peer, msg->msg_peerlen,
	    (struct sockaddr *)&msg->msg_local, msg->msg_locallen) == -1) {
		if (errno == EADDRNOTAVAIL) {
			sa_state(env, msg->msg_sa, IKEV2_STATE_CLOSING);
			timer_del(env, &msg->msg_sa->sa_timer);
			timer_set(env, &msg->msg_sa->sa_timer,
			    ikev2_ike_sa_timeout, msg->msg_sa);
			timer_add(env, &msg->msg_sa->sa_timer,
			    IKED_IKE_SA_DELETE_TIMEOUT);
		}
		log_warn("%s: sendtofrom", __func__);
		return (-1);
	}

	if (!sa)
		return (0);

	if ((m = ikev2_msg_copy(env, msg)) == NULL) {
		log_debug("%s: failed to copy a message", __func__);
		return (-1);
	}
	m->msg_exchange = exchange;

	if (flags & IKEV2_FLAG_RESPONSE) {
		TAILQ_INSERT_TAIL(&sa->sa_responses, m, msg_entry);
		timer_set(env, &m->msg_timer, ikev2_msg_response_timeout, m);
		timer_add(env, &m->msg_timer, IKED_RESPONSE_TIMEOUT);
	} else {
		TAILQ_INSERT_TAIL(&sa->sa_requests, m, msg_entry);
		timer_set(env, &m->msg_timer, ikev2_msg_retransmit_timeout, m);
		timer_add(env, &m->msg_timer, IKED_RETRANSMIT_TIMEOUT);
	}

	return (0);
}

uint32_t
ikev2_msg_id(struct iked *env, struct iked_sa *sa)
{
	uint32_t		id = sa->sa_reqid;

	if (++sa->sa_reqid == UINT32_MAX) {
		/* XXX we should close and renegotiate the connection now */
		log_debug("%s: IKEv2 message sequence overflow", __func__);
	}
	return (id);
}

struct ibuf *
ikev2_msg_encrypt(struct iked *env, struct iked_sa *sa, struct ibuf *src)
{
	size_t			 len, ivlen, encrlen, integrlen, blocklen,
				    outlen;
	uint8_t			*buf, pad = 0, *ptr;
	struct ibuf		*encr, *dst = NULL, *out = NULL;

	buf = ibuf_data(src);
	len = ibuf_size(src);

	log_debug("%s: decrypted length %zu", __func__, len);
	print_hex(buf, 0, len);

	if (sa == NULL ||
	    sa->sa_encr == NULL ||
	    sa->sa_integr == NULL) {
		log_debug("%s: invalid SA", __func__);
		goto done;
	}

	if (sa->sa_hdr.sh_initiator)
		encr = sa->sa_key_iencr;
	else
		encr = sa->sa_key_rencr;

	blocklen = cipher_length(sa->sa_encr);
	ivlen = cipher_ivlength(sa->sa_encr);
	integrlen = hash_length(sa->sa_integr);
	encrlen = roundup(len + sizeof(pad), blocklen);
	pad = encrlen - (len + sizeof(pad));

	/*
	 * Pad the payload and encrypt it
	 */
	if (pad) {
		if ((ptr = ibuf_advance(src, pad)) == NULL)
			goto done;
		arc4random_buf(ptr, pad);
	}
	if (ibuf_add(src, &pad, sizeof(pad)) != 0)
		goto done;

	log_debug("%s: padded length %zu", __func__, ibuf_size(src));
	print_hex(ibuf_data(src), 0, ibuf_size(src));

	cipher_setkey(sa->sa_encr, encr->buf, ibuf_length(encr));
	cipher_setiv(sa->sa_encr, NULL, 0);	/* XXX ivlen */
	cipher_init_encrypt(sa->sa_encr);

	if ((dst = ibuf_dup(sa->sa_encr->encr_iv)) == NULL)
		goto done;

	if ((out = ibuf_new(NULL,
	    cipher_outlength(sa->sa_encr, encrlen))) == NULL)
		goto done;

	outlen = ibuf_size(out);
	cipher_update(sa->sa_encr,
	    ibuf_data(src), encrlen, ibuf_data(out), &outlen);

	if (outlen && ibuf_add(dst, ibuf_data(out), outlen) != 0)
		goto done;

	if ((ptr = ibuf_advance(dst, integrlen)) == NULL)
		goto done;
	explicit_bzero(ptr, integrlen);

	log_debug("%s: length %zu, padding %d, output length %zu",
	    __func__, len + sizeof(pad), pad, ibuf_size(dst));
	print_hex(ibuf_data(dst), 0, ibuf_size(dst));

	ibuf_release(src);
	ibuf_release(out);
	return (dst);
 done:
	ibuf_release(src);
	ibuf_release(out);
	ibuf_release(dst);
	return (NULL);
}

int
ikev2_msg_integr(struct iked *env, struct iked_sa *sa, struct ibuf *src)
{
	int			 ret = -1;
	size_t			 integrlen, tmplen;
	struct ibuf		*integr, *tmp = NULL;
	uint8_t			*ptr;

	log_debug("%s: message length %zu", __func__, ibuf_size(src));
	print_hex(ibuf_data(src), 0, ibuf_size(src));

	if (sa == NULL ||
	    sa->sa_integr == NULL) {
		log_debug("%s: invalid SA", __func__);
		return (-1);
	}

	if (sa->sa_hdr.sh_initiator)
		integr = sa->sa_key_iauth;
	else
		integr = sa->sa_key_rauth;

	integrlen = hash_length(sa->sa_integr);

	log_debug("%s: integrity checksum length %zu", __func__,
	    integrlen);

	/*
	 * Validate packet checksum
	 */
	if ((tmp = ibuf_new(NULL, hash_keylength(sa->sa_integr))) == NULL)
		goto done;

	hash_setkey(sa->sa_integr, ibuf_data(integr), ibuf_size(integr));
	hash_init(sa->sa_integr);
	hash_update(sa->sa_integr, ibuf_data(src),
	    ibuf_size(src) - integrlen);
	hash_final(sa->sa_integr, ibuf_data(tmp), &tmplen);

	if (tmplen != integrlen) {
		log_debug("%s: hash failure", __func__);
		goto done;
	}

	if ((ptr = ibuf_seek(src,
	    ibuf_size(src) - integrlen, integrlen)) == NULL)
		goto done;
	memcpy(ptr, ibuf_data(tmp), tmplen);

	print_hex(ibuf_data(tmp), 0, ibuf_size(tmp));

	ret = 0;
 done:
	ibuf_release(tmp);

	return (ret);
}

struct ibuf *
ikev2_msg_decrypt(struct iked *env, struct iked_sa *sa,
    struct ibuf *msg, struct ibuf *src)
{
	ssize_t			 ivlen, encrlen, integrlen, blocklen,
				    outlen, tmplen;
	uint8_t			 pad = 0, *ptr;
	struct ibuf		*integr, *encr, *tmp = NULL, *out = NULL;
	off_t			 ivoff, encroff, integroff;

	if (sa == NULL ||
	    sa->sa_encr == NULL ||
	    sa->sa_integr == NULL) {
		log_debug("%s: invalid SA", __func__);
		print_hex(ibuf_data(src), 0, ibuf_size(src));
		goto done;
	}

	if (!sa->sa_hdr.sh_initiator) {
		encr = sa->sa_key_iencr;
		integr = sa->sa_key_iauth;
	} else {
		encr = sa->sa_key_rencr;
		integr = sa->sa_key_rauth;
	}

	blocklen = cipher_length(sa->sa_encr);
	ivlen = cipher_ivlength(sa->sa_encr);
	ivoff = 0;
	integrlen = hash_length(sa->sa_integr);
	integroff = ibuf_size(src) - integrlen;
	encroff = ivlen;
	encrlen = ibuf_size(src) - integrlen - ivlen;

	if (encrlen < 0 || integroff < 0) {
		log_debug("%s: invalid integrity value", __func__);
		goto done;
	}

	log_debug("%s: IV length %zd", __func__, ivlen);
	print_hex(ibuf_data(src), 0, ivlen);
	log_debug("%s: encrypted payload length %zd", __func__, encrlen);
	print_hex(ibuf_data(src), encroff, encrlen);
	log_debug("%s: integrity checksum length %zd", __func__, integrlen);
	print_hex(ibuf_data(src), integroff, integrlen);

	/*
	 * Validate packet checksum
	 */
	if ((tmp = ibuf_new(NULL, ibuf_length(integr))) == NULL)
		goto done;

	hash_setkey(sa->sa_integr, integr->buf, ibuf_length(integr));
	hash_init(sa->sa_integr);
	hash_update(sa->sa_integr, ibuf_data(msg),
	    ibuf_size(msg) - integrlen);
	hash_final(sa->sa_integr, tmp->buf, &tmplen);

	if (memcmp(tmp->buf, ibuf_data(src) + integroff, integrlen) != 0) {
		log_debug("%s: integrity check failed", __func__);
		goto done;
	}

	log_debug("%s: integrity check succeeded", __func__);
	print_hex(tmp->buf, 0, tmplen);

	ibuf_release(tmp);
	tmp = NULL;

	/*
	 * Decrypt the payload and strip any padding
	 */
	if ((encrlen % blocklen) != 0) {
		log_debug("%s: unaligned encrypted payload", __func__);
		goto done;
	}

	cipher_setkey(sa->sa_encr, encr->buf, ibuf_length(encr));
	cipher_setiv(sa->sa_encr, ibuf_data(src) + ivoff, ivlen);
	cipher_init_decrypt(sa->sa_encr);

	if ((out = ibuf_new(NULL, cipher_outlength(sa->sa_encr,
	    encrlen))) == NULL)
		goto done;

	if ((outlen = ibuf_length(out)) != 0) {
		cipher_update(sa->sa_encr, ibuf_data(src) + encroff, encrlen,
		    ibuf_data(out), &outlen);

		ptr = ibuf_seek(out, outlen - 1, 1);
		pad = *ptr;
	}

	log_debug("%s: decrypted payload length %zd/%zd padding %d",
	    __func__, outlen, encrlen, pad);
	print_hex(ibuf_data(out), 0, ibuf_size(out));

	if (ibuf_setsize(out, outlen) != 0)
		goto done;

	ibuf_release(src);
	return (out);
 done:
	ibuf_release(tmp);
	ibuf_release(out);
	ibuf_release(src);
	return (NULL);
}

int
ikev2_msg_send_encrypt(struct iked *env, struct iked_sa *sa, struct ibuf **ep,
    uint8_t exchange, uint8_t firstpayload, int response)
{
	struct iked_message		 resp;
	struct ike_header		*hdr;
	struct ikev2_payload		*pld;
	struct ibuf			*buf, *e = *ep;
	int				 ret = -1;

	if ((buf = ikev2_msg_init(env, &resp, &sa->sa_peer.addr,
	    sa->sa_peer.addr.ss_len, &sa->sa_local.addr,
	    sa->sa_local.addr.ss_len, response)) == NULL)
		goto done;

	resp.msg_msgid = response ? sa->sa_msgid : ikev2_msg_id(env, sa);

	/* IKE header */
	if ((hdr = ikev2_add_header(buf, sa, resp.msg_msgid, IKEV2_PAYLOAD_SK,
	    exchange, response ? IKEV2_FLAG_RESPONSE : 0)) == NULL)
		goto done;

	if ((pld = ikev2_add_payload(buf)) == NULL)
		goto done;

	/* Encrypt message and add as an E payload */
	if ((e = ikev2_msg_encrypt(env, sa, e)) == NULL) {
		log_debug("%s: encryption failed", __func__);
		goto done;
	}
	if (ibuf_cat(buf, e) != 0)
		goto done;
	if (ikev2_next_payload(pld, ibuf_size(e), firstpayload) == -1)
		goto done;

	if (ikev2_set_header(hdr, ibuf_size(buf) - sizeof(*hdr)) == -1)
		goto done;

	/* Add integrity checksum (HMAC) */
	if (ikev2_msg_integr(env, sa, buf) != 0) {
		log_debug("%s: integrity checksum failed", __func__);
		goto done;
	}

	resp.msg_data = buf;
	resp.msg_sa = sa;
	resp.msg_fd = sa->sa_fd;
	TAILQ_INIT(&resp.msg_proposals);

	(void)ikev2_pld_parse(env, hdr, &resp, 0);

	ret = ikev2_msg_send(env, &resp);

 done:
	/* e is cleaned up by the calling function */
	*ep = e;
	ikev2_msg_cleanup(env, &resp);

	return (ret);
}

struct ibuf *
ikev2_msg_auth(struct iked *env, struct iked_sa *sa, int response)
{
	struct ibuf		*authmsg = NULL, *nonce, *prfkey, *buf;
	uint8_t			*ptr;
	struct iked_id		*id;
	size_t			 tmplen;

	/*
	 * Create the payload to be signed/MAC'ed for AUTH
	 */

	if (!response) {
		if ((nonce = sa->sa_rnonce) == NULL ||
		    (sa->sa_iid.id_type == 0) ||
		    (prfkey = sa->sa_key_iprf) == NULL ||
		    (buf = sa->sa_1stmsg) == NULL)
			return (NULL);
		id = &sa->sa_iid;
	} else {
		if ((nonce = sa->sa_inonce) == NULL ||
		    (sa->sa_rid.id_type == 0) ||
		    (prfkey = sa->sa_key_rprf) == NULL ||
		    (buf = sa->sa_2ndmsg) == NULL)
			return (NULL);
		id = &sa->sa_rid;
	}

	if ((authmsg = ibuf_dup(buf)) == NULL)
		return (NULL);
	if (ibuf_cat(authmsg, nonce) != 0)
		goto fail;

	if ((hash_setkey(sa->sa_prf, ibuf_data(prfkey),
	    ibuf_size(prfkey))) == NULL)
		goto fail;

	if ((ptr = ibuf_advance(authmsg,
	    hash_length(sa->sa_prf))) == NULL)
		goto fail;

	hash_init(sa->sa_prf);
	hash_update(sa->sa_prf, ibuf_data(id->id_buf), ibuf_size(id->id_buf));
	hash_final(sa->sa_prf, ptr, &tmplen);

	if (tmplen != hash_length(sa->sa_prf))
		goto fail;

	log_debug("%s: %s auth data length %zu",
	    __func__, response ? "responder" : "initiator",
	    ibuf_size(authmsg));
	print_hex(ibuf_data(authmsg), 0, ibuf_size(authmsg));

	return (authmsg);

 fail:
	ibuf_release(authmsg);
	return (NULL);
}

int
ikev2_msg_authverify(struct iked *env, struct iked_sa *sa,
    struct iked_auth *auth, uint8_t *buf, size_t len, struct ibuf *authmsg)
{
	uint8_t				*key, *psk = NULL;
	ssize_t				 keylen;
	struct iked_id			*id;
	struct iked_dsa			*dsa = NULL;
	int				 ret = -1;
	uint8_t				 keytype;

	if (sa->sa_hdr.sh_initiator)
		id = &sa->sa_rcert;
	else
		id = &sa->sa_icert;

	if ((dsa = dsa_verify_new(auth->auth_method, sa->sa_prf)) == NULL) {
		log_debug("%s: invalid auth method", __func__);
		return (-1);
	}

	switch (auth->auth_method) {
	case IKEV2_AUTH_SHARED_KEY_MIC:
		if (!auth->auth_length) {
			log_debug("%s: no pre-shared key found", __func__);
			goto done;
		}
		if ((keylen = ikev2_psk(sa, auth->auth_data,
		    auth->auth_length, &psk)) == -1) {
			log_debug("%s: failed to get PSK", __func__);
			goto done;
		}
		key = psk;
		keytype = 0;
		break;
	default:
		if (!id->id_type || !ibuf_length(id->id_buf)) {
			log_debug("%s: no cert found", __func__);
			goto done;
		}
		key = ibuf_data(id->id_buf);
		keylen = ibuf_size(id->id_buf);
		keytype = id->id_type;
		break;
	}

	log_debug("%s: method %s keylen %zd type %s", __func__,
	    print_map(auth->auth_method, ikev2_auth_map), keylen,
	    print_map(id->id_type, ikev2_cert_map));

	if (dsa_setkey(dsa, key, keylen, keytype) == NULL ||
	    dsa_init(dsa, buf, len) != 0 ||
	    dsa_update(dsa, ibuf_data(authmsg), ibuf_size(authmsg))) {
		log_debug("%s: failed to compute digital signature", __func__);
		goto done;
	}

	if ((ret = dsa_verify_final(dsa, buf, len)) == 0) {
		log_debug("%s: authentication successful", __func__);
		sa_state(env, sa, IKEV2_STATE_AUTH_SUCCESS);
		sa_stateflags(sa, IKED_REQ_AUTHVALID);
	} else {
		log_debug("%s: authentication failed", __func__);
		sa_state(env, sa, IKEV2_STATE_AUTH_REQUEST);
	}

 done:
	free(psk);
	dsa_free(dsa);

	return (ret);
}

int
ikev2_msg_authsign(struct iked *env, struct iked_sa *sa,
    struct iked_auth *auth, struct ibuf *authmsg)
{
	uint8_t				*key, *psk = NULL;
	ssize_t				 keylen, siglen;
	struct iked_hash		*prf = sa->sa_prf;
	struct iked_id			*id;
	struct iked_dsa			*dsa = NULL;
	struct ibuf			*buf;
	int				 ret = -1;
	uint8_t			 keytype;

	if (sa->sa_hdr.sh_initiator)
		id = &sa->sa_icert;
	else
		id = &sa->sa_rcert;

	if ((dsa = dsa_sign_new(auth->auth_method, prf)) == NULL) {
		log_debug("%s: invalid auth method", __func__);
		return (-1);
	}

	switch (auth->auth_method) {
	case IKEV2_AUTH_SHARED_KEY_MIC:
		if (!auth->auth_length) {
			log_debug("%s: no pre-shared key found", __func__);
			goto done;
		}
		if ((keylen = ikev2_psk(sa, auth->auth_data,
		    auth->auth_length, &psk)) == -1) {
			log_debug("%s: failed to get PSK", __func__);
			goto done;
		}
		key = psk;
		keytype = 0;
		break;
	default:
		if (id == NULL) {
			log_debug("%s: no cert found", __func__);
			goto done;
		}
		key = ibuf_data(id->id_buf);
		keylen = ibuf_size(id->id_buf);
		keytype = id->id_type;
		break;
	}

	if (dsa_setkey(dsa, key, keylen, keytype) == NULL ||
	    dsa_init(dsa, NULL, 0) != 0 ||
	    dsa_update(dsa, ibuf_data(authmsg), ibuf_size(authmsg))) {
		log_debug("%s: failed to compute digital signature", __func__);
		goto done;
	}

	ibuf_release(sa->sa_localauth.id_buf);
	sa->sa_localauth.id_buf = NULL;

	if ((buf = ibuf_new(NULL, dsa_length(dsa))) == NULL) {
		log_debug("%s: failed to get auth buffer", __func__);
		goto done;
	}

	if ((siglen = dsa_sign_final(dsa,
	    ibuf_data(buf), ibuf_size(buf))) < 0) {
		log_debug("%s: failed to create auth signature", __func__);
		ibuf_release(buf);
		goto done;
	}

	if (ibuf_setsize(buf, siglen) < 0) {
		log_debug("%s: failed to set auth signature size to %zd",
		    __func__, siglen);
		ibuf_release(buf);
		goto done;
	}

	sa->sa_localauth.id_type = auth->auth_method;
	sa->sa_localauth.id_buf = buf;

	ret = 0;
 done:
	free(psk);
	dsa_free(dsa);

	return (ret);
}

int
ikev2_msg_frompeer(struct iked_message *msg)
{
	struct iked_sa		*sa = msg->msg_sa;
	struct ike_header	*hdr;

	msg = msg->msg_parent;

	if (sa == NULL ||
	    (hdr = ibuf_seek(msg->msg_data, 0, sizeof(*hdr))) == NULL)
		return (0);

	if (!sa->sa_hdr.sh_initiator &&
	    (hdr->ike_flags & IKEV2_FLAG_INITIATOR))
		return (1);
	else if (sa->sa_hdr.sh_initiator &&
	    (hdr->ike_flags & IKEV2_FLAG_INITIATOR) == 0)
		return (1);

	return (0);
}

struct iked_socket *
ikev2_msg_getsocket(struct iked *env, int af, int natt)
{
	switch (af) {
	case AF_INET:
		return (env->sc_sock4[natt ? 1 : 0]);
	case AF_INET6:
		return (env->sc_sock6[natt ? 1 : 0]);
	}

	log_debug("%s: af socket %d not available", __func__, af);
	return (NULL);
}

void
ikev2_msg_prevail(struct iked *env, struct iked_msgqueue *queue,
    struct iked_message *msg)
{
	struct iked_message	*m, *mtmp;

	TAILQ_FOREACH_SAFE(m, queue, msg_entry, mtmp) {
		if (m->msg_msgid < msg->msg_msgid)
			ikev2_msg_dispose(env, queue, m);
	}
}

void
ikev2_msg_dispose(struct iked *env, struct iked_msgqueue *queue,
    struct iked_message *msg)
{
	TAILQ_REMOVE(queue, msg, msg_entry);
	timer_del(env, &msg->msg_timer);
	ikev2_msg_cleanup(env, msg);
	free(msg);
}

void
ikev2_msg_flushqueue(struct iked *env, struct iked_msgqueue *queue)
{
	struct iked_message	*m = NULL;

	while ((m = TAILQ_FIRST(queue)) != NULL)
		ikev2_msg_dispose(env, queue, m);
}

struct iked_message *
ikev2_msg_lookup(struct iked *env, struct iked_msgqueue *queue,
    struct iked_message *msg, struct ike_header *hdr)
{
	struct iked_message	*m = NULL;

	TAILQ_FOREACH(m, queue, msg_entry) {
		if (m->msg_msgid == msg->msg_msgid &&
		    m->msg_exchange == hdr->ike_exchange)
			break;
	}

	return (m);
}

int
ikev2_msg_retransmit_response(struct iked *env, struct iked_sa *sa,
    struct iked_message *msg)
{
	if (sendtofrom(msg->msg_fd, ibuf_data(msg->msg_data),
	    ibuf_size(msg->msg_data), 0,
	    (struct sockaddr *)&msg->msg_peer, msg->msg_peerlen,
	    (struct sockaddr *)&msg->msg_local, msg->msg_locallen) == -1) {
		log_warn("%s: sendtofrom", __func__);
		return (-1);
	}

	timer_add(env, &msg->msg_timer, IKED_RESPONSE_TIMEOUT);
	return (0);
}

void
ikev2_msg_response_timeout(struct iked *env, void *arg)
{
	struct iked_message	*msg = arg;
	struct iked_sa		*sa = msg->msg_sa;

	ikev2_msg_dispose(env, &sa->sa_responses, msg);
}

void
ikev2_msg_retransmit_timeout(struct iked *env, void *arg)
{
	struct iked_message	*msg = arg;
	struct iked_sa		*sa = msg->msg_sa;

	if (msg->msg_tries < IKED_RETRANSMIT_TRIES) {
		if (sendtofrom(msg->msg_fd, ibuf_data(msg->msg_data),
		    ibuf_size(msg->msg_data), 0,
		    (struct sockaddr *)&msg->msg_peer, msg->msg_peerlen,
		    (struct sockaddr *)&msg->msg_local,
		    msg->msg_locallen) == -1) {
			log_warn("%s: sendtofrom", __func__);
			sa_free(env, sa);
			return;
		}
		/* Exponential timeout */
		timer_add(env, &msg->msg_timer,
		    IKED_RETRANSMIT_TIMEOUT * (2 << (msg->msg_tries++)));
	} else {
		log_debug("%s: retransmit limit reached for msgid %u",
		    __func__, msg->msg_msgid);
		sa_free(env, sa);
	}
}
@


1.51
log
@Add support to reflect the responder IKEv2 COOKIE.

This fixes connecting to Azure VPN and other implementations that
implement the IKEv2 COOKIE mechanism on the responder side.  Azure
decides to send you a responder COOKIE after too many connection
attempts - we have to keep it and reflect it to establish a
connection.  This implementation is only for the initiator (client)
side, we do not support sending COOKIEs on the responder (server) side
yet.

OK patrick@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.50 2017/03/27 10:06:41 reyk Exp $	*/
d334 8
@


1.50
log
@Add support for RFC4754 (ECDSA) and RFC7427 authentication.

These modes provide stronger and more flexible ways for
authentication: while RSA public key auth relies on SHA-1 hashes, the
news modes use SHA2-256 and up to SHA2-512 hashes.

Original diff from markus@@ with patches from mikeb@@ and me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.49 2017/03/13 17:41:14 reyk Exp $	*/
d186 1
d193 2
@


1.49
log
@NAT-T improvements

Move repeated creation of the NAT-T payload into a function, remove
erroneous msg_offset, and improve NAT-T handling.

From and OK markus, OK mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.48 2017/01/20 14:09:00 mikeb Exp $	*/
d817 1
a817 1
	ssize_t				 keylen;
d875 2
a876 2
	if ((ret = dsa_sign_final(dsa,
	    ibuf_data(buf), ibuf_size(buf))) == -1) {
d878 7
@


1.48
log
@Reset various pointers in ikev2_msg_cleanup

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.47 2017/01/20 13:58:05 mikeb Exp $	*/
a325 1
		msg->msg_offset += sizeof(natt);
@


1.47
log
@Closed SAs should never be treated as valid

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.46 2016/09/04 10:26:02 vgross Exp $	*/
d187 5
@


1.46
log
@Now that we have IP_SENDSRCADDR, add sendtofrom().

Ok jca@@ and reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.45 2015/10/19 11:25:35 reyk Exp $	*/
d211 2
@


1.45
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.44 2015/10/15 18:40:38 mmcc Exp $	*/
d322 4
a325 3
	if ((sendto(msg->msg_fd, ibuf_data(buf), ibuf_size(buf), 0,
	    (struct sockaddr *)&msg->msg_peer, msg->msg_peerlen)) == -1) {
		log_warn("%s: sendto", __func__);
d973 5
a977 4
	if ((sendto(msg->msg_fd, ibuf_data(msg->msg_data),
	    ibuf_size(msg->msg_data), 0, (struct sockaddr *)&msg->msg_peer,
	    msg->msg_peerlen)) == -1) {
		log_warn("%s: sendto", __func__);
d1001 1
a1001 1
		if ((sendto(msg->msg_fd, ibuf_data(msg->msg_data),
d1003 4
a1006 3
		    (struct sockaddr *)&msg->msg_peer,
		    msg->msg_peerlen)) == -1) {
			log_warn("%s: sendto", __func__);
@


1.44
log
@Remove some unnecessary NULL-checks before free(). Change two bzero()
calls on pf data to explicit_bzero().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.43 2015/08/21 11:59:27 reyk Exp $	*/
d46 1
a60 1
	struct iovec		 iov[2];
a91 10
	if (hdr.ike_version == IKEV1_VERSION) {
		iov[0].iov_base = &msg;
		iov[0].iov_len = sizeof(msg);
		iov[1].iov_base = buf;
		iov[1].iov_len = len;

		proc_composev_imsg(&env->sc_ps, PROC_IKEV1, -1,
		    IMSG_IKE_MESSAGE, -1, iov, 2);
		goto done;
	}
d93 1
d95 4
a98 2
	msg.msg_fd = fd;
	ikev2_recv(env, &msg);
a99 1
 done:
d101 27
@


1.43
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.42 2015/03/26 19:52:35 markus Exp $	*/
d780 1
a780 2
	if (psk != NULL)
		free(psk);
d861 1
a861 2
	if (psk != NULL)
		free(psk);
@


1.42
log
@initial support for RFC 7427 signatures, so we are no longer
restricted to SHA1 for RSA signatures. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.41 2015/02/15 01:56:42 tedu Exp $	*/
d56 2
a57 2
	u_int32_t		 natt = 0x00000000;
	u_int8_t		 buf[IKED_MSGBUF_MAX];
d273 1
a273 1
	u_int32_t		 natt = 0x00000000;
d275 1
a275 1
	u_int8_t		 exchange, flags;
d331 1
a331 1
u_int32_t
d334 1
a334 1
	u_int32_t		id = sa->sa_reqid;
d348 1
a348 1
	u_int8_t		*buf, pad = 0, *ptr;
d431 1
a431 1
	u_int8_t		*ptr;
d489 1
a489 1
	u_int8_t		 pad = 0, *ptr;
d594 1
a594 1
    u_int8_t exchange, u_int8_t firstpayload, int response)
d657 1
a657 1
	u_int8_t		*ptr;
d715 1
a715 1
    struct iked_auth *auth, u_int8_t *buf, size_t len, struct ibuf *authmsg)
d717 1
a717 1
	u_int8_t			*key, *psk = NULL;
d722 1
a722 1
	u_int8_t			 keytype;
d791 1
a791 1
	u_int8_t			*key, *psk = NULL;
d798 1
a798 1
	u_int8_t			 keytype;
@


1.41
log
@convert bcmp to memcmp
ok doug millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.40 2015/02/06 10:39:01 deraadt Exp $	*/
d764 1
a764 1
	    dsa_init(dsa) != 0 ||
d836 1
a836 1
	    dsa_init(dsa) != 0 ||
@


1.40
log
@unneeded getopt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.39 2015/01/19 14:42:42 mikeb Exp $	*/
d78 1
a78 1
		if (bcmp(&natt, buf, sizeof(natt)) != 0)
@


1.39
log
@Remove unnecessary <netinet/ip_ipsp.h> includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.38 2015/01/16 06:39:58 deraadt Exp $	*/
a31 1
#include <getopt.h>
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.37 2014/11/07 14:02:32 mikeb Exp $	*/
a25 1
#include <netinet/ip_ipsp.h>
@


1.37
log
@Repair initiator with PSK auth

Attempt state transition to VALID (or EAP_VALID) in the
ikev2_ike_auth after we have completed authentication
synchronously (PSK) or asynchronously (X.509 and RSA)
eliminating the need to do so in multiple places and
restoring the correct order for PSK.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.36 2014/08/25 07:50:25 doug Exp $	*/
d19 1
a19 1
#include <sys/param.h>
@


1.36
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.35 2014/05/07 13:04:01 markus Exp $	*/
a775 4

		if (!sa->sa_policy->pol_auth.auth_eap &&
		    auth->auth_method == IKEV2_AUTH_SHARED_KEY_MIC)
			sa_state(env, sa, IKEV2_STATE_VALID);
@


1.35
log
@print msgid for debugging; ok reyk & mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.34 2014/05/06 10:24:22 markus Exp $	*/
d411 1
a411 1
	bzero(ptr, integrlen);
@


1.34
log
@initiate ike sa rekeying (ikesalifetime keyword), re-queue pfkey
events while we are busy initiating child-SAs; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.33 2014/05/05 16:14:37 markus Exp $	*/
d289 1
a289 1
	log_info("%s: %s from %s to %s, %ld bytes%s", __func__,
d291 1
d294 1
d1000 2
a1001 1
		log_debug("%s: retransmit limit reached", __func__);
@


1.33
log
@the caller of ikev2_msg_retransmit_response already frees the sa; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.32 2014/04/29 11:51:13 markus Exp $	*/
d193 14
a206 1
	if (msg->msg_sa != NULL && msg->msg_policy != NULL)
d208 1
@


1.32
log
@make sure the state machine only advances if the AUTH payload has
been verified; with & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.31 2014/04/22 12:00:03 reyk Exp $	*/
a948 1
		sa_free(env, sa);
@


1.31
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.30 2014/04/10 16:08:02 reyk Exp $	*/
d759 1
@


1.30
log
@Add validation routines to ikev2_pld.c: For each payload type overall
header structure is checked for sanity before copying the header.
Always pass down the number of remaining bytes in the payload or
substructure so we can always ensure to not go beyond actual data.
Also remove the quick parsing step as it does not provide a real
benefit anymore.

From Hans-Joerg Hoexer

ok mikeb@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.29 2014/02/17 11:00:14 reyk Exp $	*/
d100 2
a101 2
		proc_composev_imsg(env, PROC_IKEV1, IMSG_IKE_MESSAGE, -1,
		    iov, 2);
@


1.29
log
@Fix compiler warnings in the format strings: use %zd for ssize_t and
%zu for size_t.

From Andre de Oliveira
With input and OK from blambert@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.28 2014/01/24 05:58:52 mikeb Exp $	*/
d138 1
a138 1
	ssize_t				 len;
d141 5
a145 2
	if ((len = ibuf_size(msg->msg_data) - msg->msg_offset) <= 0 ||
	    (ptr = ibuf_seek(msg->msg_data, msg->msg_offset, len)) == NULL ||
@


1.28
log
@use a bit saner timer api
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.27 2013/12/03 13:55:39 markus Exp $	*/
d337 1
a337 1
	log_debug("%s: decrypted length %d", __func__, len);
d369 1
a369 1
	log_debug("%s: padded length %d", __func__, ibuf_size(src));
d394 1
a394 1
	log_debug("%s: length %d, padding %d, output length %d",
d416 1
a416 1
	log_debug("%s: message length %d", __func__, ibuf_size(src));
d432 1
a432 1
	log_debug("%s: integrity checksum length %d", __func__,
d505 1
a505 1
	log_debug("%s: IV length %d", __func__, ivlen);
d507 1
a507 1
	log_debug("%s: encrypted payload length %d", __func__, encrlen);
d509 1
a509 1
	log_debug("%s: integrity checksum length %d", __func__, integrlen);
d559 1
a559 1
	log_debug("%s: decrypted payload length %d/%d padding %d",
d684 1
a684 1
	log_debug("%s: %s auth data length %d",
d742 1
a742 1
	log_debug("%s: method %s keylen %d type %s", __func__,
@


1.27
log
@never cast to sockaddr_storage, always cast to the abstract 'class' sockaddr
this fixes an out-of-bounds-memcpy in pfkey_process(); ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.26 2013/09/26 13:09:38 mikeb Exp $	*/
d303 2
a304 3
		timer_initialize(env, &m->msg_timer,
		    ikev2_msg_response_timeout, m);
		timer_register(env, &m->msg_timer, IKED_RESPONSE_TIMEOUT);
d307 2
a308 3
		timer_initialize(env, &m->msg_timer,
		    ikev2_msg_retransmit_timeout, m);
		timer_register(env, &m->msg_timer, IKED_RETRANSMIT_TIMEOUT);
d908 1
a908 1
	timer_deregister(env, &msg->msg_timer);
d949 1
a949 1
	timer_register(env, &msg->msg_timer, IKED_RESPONSE_TIMEOUT);
d978 1
a978 1
		timer_register(env, &msg->msg_timer,
@


1.26
log
@After some manipulations with the buffer, ike message header (hdr)
might no longer point to the same memory as before.

The bug was reported and fix was tested by LEVAI Daniel.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.25 2013/03/21 04:30:14 deraadt Exp $	*/
d78 2
a79 1
	if (socket_getport(&msg.msg_local) == IKED_NATT_PORT) {
d274 2
a275 2
	    print_host(&msg->msg_local, NULL, 0),
	    print_host(&msg->msg_peer, NULL, 0),
@


1.25
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.24 2013/01/08 10:38:19 reyk Exp $	*/
d259 1
d269 2
d272 1
a272 1
	    print_map(hdr->ike_exchange, ikev2_exchange_map),
d298 1
a298 1
	m->msg_exchange = hdr->ike_exchange;
d300 1
a300 1
	if (hdr->ike_flags & IKEV2_FLAG_RESPONSE) {
@


1.24
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.23 2012/12/15 23:20:17 reyk Exp $	*/
a19 1
#include <sys/types.h>
@


1.23
log
@Remove unused variables.
@
text
@d1 1
a1 2
/*	$OpenBSD: ikev2_msg.c,v 1.22 2012/10/22 10:25:17 reyk Exp $	*/
/*	$vantronix: ikev2.c,v 1.101 2010/06/03 07:57:33 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.22
log
@Fix NAT-T support in iked, both on the initiator and the responder
side.  Also add a new command line option -t to optionally enforce
NAT-T with UDP encapsulation on port 4500.

Tested by mikeb@@ and me
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.21 2012/09/18 12:07:59 reyk Exp $	*/
d332 1
a332 1
	struct ibuf		*integr, *encr, *dst = NULL, *out = NULL;
d347 1
a347 1
	if (sa->sa_hdr.sh_initiator) {
d349 1
a349 2
		integr = sa->sa_key_iauth;
	} else {
a350 2
		integr = sa->sa_key_rauth;
	}
d373 1
a373 1
	cipher_setiv(sa->sa_encr, NULL, 0);	/* new IV */
d413 1
a413 1
	struct ibuf		*integr, *prf, *tmp = NULL;
d425 1
a425 1
	if (sa->sa_hdr.sh_initiator) {
d427 1
a427 2
		prf = sa->sa_key_iprf;
	} else {
a428 2
		prf = sa->sa_key_rprf;
	}
@


1.21
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.20 2012/06/27 15:36:36 mikeb Exp $	*/
d139 2
d142 3
a144 1
	if ((m = malloc(sizeof(*m))) == NULL ||
d147 1
a147 1
	    ibuf_add(buf, ibuf_data(msg->msg_data), ibuf_size(msg->msg_data)))
d260 1
d268 3
a270 1
	log_info("%s: %s from %s to %s, %ld bytes", __func__,
d274 1
a274 1
	    ibuf_length(buf));
d276 1
a276 1
	if (msg->msg_natt || (msg->msg_sa && msg->msg_sa->sa_natt)) {
d884 1
a884 1
ikev2_msg_getsocket(struct iked *env, int af)
d888 1
a888 1
		return (env->sc_sock4);
d890 1
a890 1
		return (env->sc_sock6);
@


1.20
log
@leftover code re-enqueued the same item on the list multiple times
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.19 2012/06/27 14:03:50 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.19
log
@prevent an endless loop
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.18 2012/06/26 11:09:10 mikeb Exp $	*/
a975 1
		TAILQ_INSERT_TAIL(&sa->sa_requests, msg, msg_entry);
@


1.18
log
@improve ikev2_msg_retransmit_timeout
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.17 2012/06/26 11:00:28 mikeb Exp $	*/
d894 1
a894 1
	struct iked_message	*m = NULL;
d896 1
a896 1
	while ((m = TAILQ_FIRST(queue)) != NULL) {
@


1.17
log
@compare exchange types as well when looking up a message;
proceed with a response only when the appropriate request
is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.16 2012/06/22 16:28:20 mikeb Exp $	*/
a966 8
	if ((sendto(msg->msg_fd, ibuf_data(msg->msg_data),
	    ibuf_size(msg->msg_data), 0,
	    (struct sockaddr *)&msg->msg_peer, msg->msg_peerlen)) == -1) {
		log_warn("%s: sendto", __func__);
		sa_free(env, sa);
		return;
	}

d968 8
d980 2
a981 1
	} else
d983 1
@


1.16
log
@Add initial support for retransmition timeouts and response retries.
This should still be considered an experimental work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.13 2012/05/07 10:58:38 mikeb Exp $	*/
a51 3
struct iked_message *
	 ikev2_msg_lookup_by_id(struct iked *, struct iked_msgqueue *,
	    u_int32_t);
d290 1
d922 2
a923 2
ikev2_msg_lookup_by_id(struct iked *env, struct iked_msgqueue *queue,
    u_int32_t msgid)
d928 2
a929 1
		if (m->msg_msgid == msgid)
d932 1
a933 7
}

struct iked_message *
ikev2_msg_lookup(struct iked *env, struct iked_msgqueue *queue,
    struct iked_message *msg)
{
	return (ikev2_msg_lookup_by_id(env, queue, msg->msg_msgid));
@


1.15
log
@pass a file descriptor in the msg_fd instead of a function argument
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.14 2012/05/24 14:41:36 mikeb Exp $	*/
d50 6
d137 20
d219 2
d222 1
a222 1
	if ((hdr = ikev2_add_header(buf, &sa, betoh32(oldhdr->ike_msgid),
d256 1
d260 1
d277 1
d286 20
d310 1
a310 1
ikev2_msg_id(struct iked *env, struct iked_sa *sa, int response)
d312 1
a312 1
	u_int32_t		 id;
a313 4
	if (response)
		return (sa->sa_msgid);

	id = sa->sa_reqid;
d577 2
a578 2
ikev2_msg_send_encrypt(struct iked *env, struct iked_sa *sa,
    struct ibuf **ep, u_int8_t exchange, u_int8_t firstpayload, int response)
d586 3
a588 3
	if ((buf = ikev2_msg_init(env, &resp,
	    &sa->sa_peer.addr, sa->sa_peer.addr.ss_len,
	    &sa->sa_local.addr, sa->sa_local.addr.ss_len, 1)) == NULL)
d591 2
d594 2
a595 4
	if ((hdr = ikev2_add_header(buf, sa,
	    ikev2_msg_id(env, sa, response),
	    IKEV2_PAYLOAD_SK, exchange,
	    response ? IKEV2_FLAG_RESPONSE : 0)) == NULL)
d890 99
@


1.14
log
@don't increment the next expected message id when sending a response back.
while it might look like a step backwards, this fixes up eap negotiation
and bigger changes to this code are in the pipe anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.13 2012/05/07 10:58:38 mikeb Exp $	*/
d185 2
d215 1
a215 1
	(void)ikev2_msg_send(env, msg->msg_fd, &resp);
d226 1
a226 1
ikev2_msg_send(struct iked *env, int fd, struct iked_message *msg)
d248 2
a249 1
	if ((sendto(fd, ibuf_data(buf), ibuf_size(buf), 0,
d575 1
d580 1
a580 1
	ret = ikev2_msg_send(env, sa->sa_fd, &resp);
@


1.13
log
@Sync up several defines with RFC 5996.  IANA has changed the existing
IKEv2 Payload Type "Encrypted" (E) to "Encrypted and Authenticated" (SK).
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.12 2011/05/09 11:15:18 reyk Exp $	*/
d258 1
a258 1
	u_int32_t		*id;
d260 5
a264 2
	id = response ? &sa->sa_msgid : &sa->sa_reqid;
	if (++*id == UINT32_MAX) {
d268 1
a268 1
	return (*id - 1);
@


1.12
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.11 2011/01/21 12:37:28 reyk Exp $	*/
d541 1
a541 1
	    IKEV2_PAYLOAD_E, exchange,
@


1.11
log
@handle empty encrypted payloads (might happen with some informationals)

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.10 2011/01/21 11:56:00 reyk Exp $	*/
d98 1
a98 1
		imsg_composev_proc(env, PROC_IKEV1, IMSG_IKE_MESSAGE, -1,
@


1.10
log
@Reimplement the iked(8) policy evaluation for incoming connections to
use the last matching semantics of PF.  The previous rbtree-based
implementation was broken and tried to do a longest prefix match.  But
instead of prefix match and using radix-trees to fix it I decided with
mikeb@@ to implement it as last matching policy evaluation.  The last
matching policy wins; the "quick" keyword can enforce first matching;
additional keywords like "skip" are specific to iked(8).  See
iked.conf(5) for more details.

The implementation also uses skip steps based on PF's code.  It
significantly speeds up the evaluation of many policies but also adds
a little delay when loading them (only noticeable with thousands of
policies).  This allows iked(8) to scale well with thousands of
configured policies but I also liked the fact to have skip steps in
another piece of code.

ok dhartmei@@ for using his skip step code under the ISC license in policy.c
ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.9 2010/12/22 16:22:27 mikeb Exp $	*/
d418 1
a418 1
	size_t			 ivlen, encrlen, integrlen, blocklen,
d420 1
a420 1
	u_int8_t		 pad, *ptr;
d448 5
d499 3
a501 1
	outlen = ibuf_length(out);
d503 3
a505 5
	cipher_update(sa->sa_encr, ibuf_data(src) + encroff, encrlen,
	    ibuf_data(out), &outlen);

	ptr = ibuf_seek(out, outlen - 1, 1);
	pad = *ptr;
@


1.9
log
@child sa rekeying revamp plus numerous bugfixes;
with suggestions and OK from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.8 2010/09/30 10:34:56 mikeb Exp $	*/
d72 2
a73 2
	    (struct sockaddr*)&msg.msg_peer, &msg.msg_peerlen,
	    (struct sockaddr*)&msg.msg_local, &msg.msg_locallen)) <
@


1.8
log
@disable padding correctly.  therefore we no longer need to supply
additional space in the buffer and just pad input length up to the
block size.  finalization is not needed for properly padded data.

kills a bunch of XXX's and an annoying error from openssl.

also, check a result from CipherUpdate while here.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.7 2010/06/27 01:03:22 reyk Exp $	*/
d258 1
a258 2
	if (response)
		return (sa->sa_msgid);
d260 2
a261 1
	if (++sa->sa_msgid == UINT32_MAX) {
d265 1
a265 2

	return (sa->sa_msgid);
d472 1
a472 1
	log_debug("%s: integrity check succeeded", __func__, tmplen);
@


1.7
log
@Instead of modifying and fiddling with the IKE SA in the payload
parsing routines directly, first parse the message and save the parsed
elements in the temporary message struct before validating the
information and taking any other actions on the actual SA.  This needs
more testing, but is the cleaner and better approach.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.6 2010/06/14 23:23:52 reyk Exp $	*/
a335 5
	outlen = cipher_outlength(sa->sa_encr, 0);
	cipher_final(sa->sa_encr, out->buf, &outlen);
	if (outlen)
		ibuf_add(dst, out->buf, outlen);

d496 2
a497 3
	/* XXX why does it need encrlen + blocklen to work correctly? */
	cipher_update(sa->sa_encr,
	    ibuf_data(src) + encroff, encrlen + blocklen,
a498 3
	cipher_final(sa->sa_encr, ibuf_seek(out, outlen, blocklen), &tmplen);
	if (tmplen)
		outlen += tmplen;
a499 5
	/*
	 * XXX 
	 * XXX the padding is wrong
	 * XXX
	 */
@


1.6
log
@check if cert is available and valid
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.5 2010/06/14 21:12:56 reyk Exp $	*/
d68 1
d124 2
d134 10
a147 1
	config_free_proposals(&msg->msg_proposals, 0);
d818 1
a818 2
	if (msg->msg_decrypted)
		msg = msg->msg_decrypted;
@


1.5
log
@Initial support for initiator mode which allows to run iked as a
"client" or to configure iked to iked (OpenBSD to OpenBSD) IKEv2 VPNs.

It currently only supports psk (pre-shared keys) and no certificates,
doesn't do any rekeying or SA timeouts, and needs more cleanup.  So it
is not quite production ready yet - but ready for simple tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.4 2010/06/14 11:33:55 reyk Exp $	*/
d677 1
a677 1
		if (id == NULL) {
@


1.4
log
@restructure code a bit to move closer to initiator mode:
- split responder/initiator- specific code into different functions and use
shared functions for common stuff.
- first parse the received message and store information in the temporary
message struct instead of modifying the ike sa in the parsing code directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.3 2010/06/14 08:55:59 reyk Exp $	*/
d214 2
a215 2
	struct ibuf	*buf = msg->msg_data;
	u_int32_t	 natt = 0x00000000;
d222 1
a222 1
	log_info("%s: %s to %s from %s", __func__,
d224 1
d226 1
a226 1
	    print_host(&msg->msg_local, NULL, 0));
a568 1
	sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
a569 1
	sa->sa_hdr.sh_initiator = sa->sa_hdr.sh_initiator ? 0 : 1;
@


1.3
log
@cleanup messages and parsed information correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.2 2010/06/14 08:10:32 reyk Exp $	*/
d806 3
@


1.2
log
@More code for initiator mode (not finished yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2_msg.c,v 1.1 2010/06/10 08:29:47 reyk Exp $	*/
d107 1
a107 1
	message_cleanup(env, &msg);
d123 1
d128 10
d204 1
a204 1
	message_cleanup(env, &resp);
d577 1
a577 1
	message_cleanup(env, &resp);
@


1.1
log
@i don't like splitting source code in too many source files but ikev2.c
has grown too large, so split it in 3 files and rename a few functions
to organize the code a bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikev2.c,v 1.2 2010/06/04 09:51:45 reyk Exp $	*/
d788 34
@

