head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2017.01.17.22.10.55;	author krw;	state Exp;
branches;
next	1.24;
commitid	nf3UdaW8au6U0a03;

1.24
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.23;
commitid	eA8b246voAapPTkX;

1.23
date	2017.01.09.14.04.31;	author krw;	state Exp;
branches;
next	1.22;
commitid	KJkQGNLsnMxWc9MG;

1.22
date	2016.09.04.16.55.43;	author reyk;	state Exp;
branches;
next	1.21;
commitid	Dq5V32qCi45ZXkNX;

1.21
date	2015.12.05.13.09.46;	author claudio;	state Exp;
branches;
next	1.20;
commitid	pOVYglb4bj0794uz;

1.20
date	2015.11.23.19.28.33;	author reyk;	state Exp;
branches;
next	1.19;
commitid	m6hksQq6WXPE2kks;

1.19
date	2015.10.22.15.55.18;	author reyk;	state Exp;
branches;
next	1.18;
commitid	9R73DxVDj9dmoXct;

1.18
date	2015.10.19.11.27.35;	author reyk;	state Exp;
branches;
next	1.17;
commitid	llqYeatyob4GTRAF;

1.17
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.16;
commitid	HzcDW70HFbhaqvT8;

1.16
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2014.06.03.06.25.47;	author yasuoka;	state Exp;
branches;
next	1.14;
commitid	GbQF0wMbjISLtFeG;

1.14
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.15.12.30.19;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.11.17.40.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.05.17.31.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.22.16.37.52;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.21.13.24.11;	author mikeb;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.24.20.15.30;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@/*	$OpenBSD: control.c,v 1.24 2017/01/09 14:49:21 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include "iked.h"

#define	CONTROL_BACKLOG	5

struct ctl_connlist ctl_conns;

void
	 control_accept(int, short, void *);
struct ctl_conn
	*control_connbyfd(int);
void	 control_close(int, struct control_sock *);
void	 control_dispatch_imsg(int, short, void *);
void	 control_dispatch_parent(int, short, void *);
void	 control_imsg_forward(struct imsg *);
void	 control_run(struct privsep *, struct privsep_proc *, void *);

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT, NULL }
};

pid_t
control(struct privsep *ps, struct privsep_proc *p)
{
	return (proc_run(ps, p, procs, nitems(procs), control_run, NULL));
}

void
control_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	/*
	 * pledge in the control process:
	 * stdio - for malloc and basic I/O including events.
	 * cpath - for unlinking the control socket.
	 * unix - for the control socket.
	 */
	if (pledge("stdio cpath unix", NULL) == -1)
		fatal("pledge");
}

int
control_init(struct privsep *ps, struct control_sock *cs)
{
	struct iked		*env = ps->ps_env;
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask, mode;

	if (cs->cs_name == NULL)
		return (0);

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("%s: socket", __func__);
		return (-1);
	}

	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, cs->cs_name,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
		log_warn("%s: %s name too long", __func__, cs->cs_name);
		close(fd);
		return (-1);
	}

	if (unlink(cs->cs_name) == -1)
		if (errno != ENOENT) {
			log_warn("%s: unlink %s", __func__, cs->cs_name);
			close(fd);
			return (-1);
		}

	if (cs->cs_restricted) {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
	} else {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
	}

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("%s: bind: %s", __func__, cs->cs_name);
		close(fd);
		(void)umask(old_umask);
		return (-1);
	}
	(void)umask(old_umask);

	if (chmod(cs->cs_name, mode) == -1) {
		log_warn("%s: chmod", __func__);
		close(fd);
		(void)unlink(cs->cs_name);
		return (-1);
	}

	cs->cs_fd = fd;
	cs->cs_env = env;

	return (0);
}

int
control_listen(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return (0);

	if (listen(cs->cs_fd, CONTROL_BACKLOG) == -1) {
		log_warn("%s: listen", __func__);
		return (-1);
	}

	event_set(&cs->cs_ev, cs->cs_fd, EV_READ,
	    control_accept, cs);
	event_add(&cs->cs_ev, NULL);
	evtimer_set(&cs->cs_evt, control_accept, cs);

	return (0);
}

void
control_cleanup(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return;
	event_del(&cs->cs_ev);
	event_del(&cs->cs_evt);
	(void)unlink(cs->cs_name);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *arg)
{
	struct control_sock	*cs = arg;
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&cs->cs_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd,
	    (struct sockaddr *)&sun, &len, SOCK_NONBLOCK)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&cs->cs_ev);
			evtimer_add(&cs->cs_evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("%s: accept", __func__);
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("%s", __func__);
		close(connfd);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	c->iev.data = cs;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, c->iev.data);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

void
control_close(int fd, struct control_sock *cs)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&cs->cs_evt, NULL)) {
		evtimer_del(&cs->cs_evt);
		event_add(&cs->cs_ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *arg)
{
	struct control_sock	*cs = arg;
	struct iked		*env = cs->cs_env;
	struct ctl_conn		*c;
	struct imsg		 imsg;
	int			 n, v;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd, cs);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd, cs);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd, cs);
			return;
		}

		if (n == 0)
			break;

		control_imsg_forward(&imsg);

		switch (imsg.hdr.type) {
		case IMSG_CTL_NOTIFY:
			if (c->flags & CTL_CONN_NOTIFY) {
				log_debug("%s: "
				    "client requested notify more than once",
				    __func__);
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, 0, -1, NULL, 0);
				break;
			}
			c->flags |= CTL_CONN_NOTIFY;
			break;
		case IMSG_CTL_VERBOSE:
			IMSG_SIZE_CHECK(&imsg, &v);

			memcpy(&v, imsg.data, sizeof(v));
			log_setverbose(v);

			proc_forward_imsg(&env->sc_ps, &imsg, PROC_PARENT, -1);
			break;
		case IMSG_CTL_RELOAD:
		case IMSG_CTL_RESET:
		case IMSG_CTL_COUPLE:
		case IMSG_CTL_DECOUPLE:
		case IMSG_CTL_ACTIVE:
		case IMSG_CTL_PASSIVE:
			proc_forward_imsg(&env->sc_ps, &imsg, PROC_PARENT, -1);
			break;
		default:
			log_debug("%s: error handling imsg %d",
			    __func__, imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

void
control_imsg_forward(struct imsg *imsg)
{
	struct ctl_conn *c;

	TAILQ_FOREACH(c, &ctl_conns, entry)
		if (c->flags & CTL_CONN_NOTIFY)
			imsg_compose_event(&c->iev, imsg->hdr.type,
			    0, imsg->hdr.pid, -1, imsg->data,
			    imsg->hdr.len - IMSG_HEADER_SIZE);
}
@


1.24
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2017/01/09 14:04:31 krw Exp $	*/
d67 1
a67 1
 	 * stdio - for malloc and basic I/O including events.
@


1.23
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2016/09/04 16:55:43 reyk Exp $	*/
d307 1
a307 1
			log_verbose(v);
@


1.22
log
@Forward IMSG_CTL_VERBOSE via the parent; this fixes a crash when doing
"ikectl log verbose" and keeps the control process separated from the
cert process.

Thanks for the bug report to Wouter Clarie

OK vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2015/12/05 13:09:46 claudio Exp $	*/
d218 4
a221 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.21
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2015/11/23 19:28:33 reyk Exp $	*/
a308 1
			proc_forward_imsg(&env->sc_ps, &imsg, PROC_IKEV2, -1);
@


1.20
log
@Replace socket_set_blockmode() and fcntl(fd, F_SETFL, O_NONBLOCK) calls
with the SOCK_NONBLOCK flag to socket() and accept4().

OK claudio@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2015/10/22 15:55:18 reyk Exp $	*/
d266 2
a267 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.19
log
@iked hereby pledges that it will run with restricted system
operations.  This adds pledge(2) too all processes, including the iked
parent process; the existing privsep design has been improved for
better pledgeability.  There haven't been any serious problems as it
was already sane (eg. by receiving the PFKEYv2 and UDP sockets via fd
passing).  The control socket moved to an independent process to
remove some abilities from the cert process.

Committed in agreement with many but nobody was brave enough to OK it.

Better testing will happen with having it in the tree.
"It's the truth" deraadt@@
"Let's see what happens" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2015/10/19 11:27:35 reyk Exp $	*/
d86 1
a86 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a128 1
	socket_set_blockmode(fd, BM_NONBLOCK);
d179 2
a180 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a194 2

	socket_set_blockmode(connfd, BM_NONBLOCK);
@


1.18
log
@Fix control_imsg_forward() by changing imsg_compose() to
imsg_compose_event().  This was done by pyr@@ in relayd/control.c
-r1.32 (2009/06/05, ok eric@@) but somehow didn't slip into other
daemons that imported control.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2015/10/19 11:25:35 reyk Exp $	*/
d48 1
d50 24
@


1.17
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2015/01/16 06:39:58 deraadt Exp $	*/
d314 1
a314 1
			imsg_compose(&c->iev.ibuf, imsg->hdr.type,
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2014/06/03 06:25:47 yasuoka Exp $	*/
a286 1
			proc_forward_imsg(&env->sc_ps, &imsg, PROC_IKEV1, -1);
@


1.15
log
@Handle the event parameter of libevent callback function as a bit
mask.  Also remove redundant imsg_event_add calls.  Fixes come from
usr.sbin/ospfd/control.c

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2014/04/22 12:00:03 reyk Exp $	*/
a20 1
#include <sys/param.h>
@


1.14
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2013/11/15 12:30:19 mikeb Exp $	*/
d244 1
a244 2
	switch (event) {
	case EV_READ:
d249 2
a250 2
		break;
	case EV_WRITE:
a254 4
		imsg_event_add(&c->iev);
		return;
	default:
		fatalx("unknown event");
@


1.13
log
@Cope with the EAGAIN API change for msgbuf_write()
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2013/03/21 04:30:14 deraadt Exp $	*/
d291 3
a293 3
			proc_forward_imsg(env, &imsg, PROC_PARENT);
			proc_forward_imsg(env, &imsg, PROC_IKEV2);
			proc_forward_imsg(env, &imsg, PROC_IKEV1);
d301 1
a301 1
			proc_forward_imsg(env, &imsg, PROC_PARENT);
@


1.12
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2013/03/11 17:40:10 deraadt Exp $	*/
d252 1
a252 1
		if (msgbuf_write(&c->iev.ibuf.w) < 0) {
@


1.11
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2013/01/08 10:38:19 reyk Exp $	*/
a21 1
#include <sys/types.h>
@


1.10
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2012/09/18 12:07:59 reyk Exp $	*/
d168 2
a169 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.9
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 2
/*	$OpenBSD: control.c,v 1.8 2012/04/05 17:31:36 deraadt Exp $	*/
/*	$vantronix: control.c,v 1.4 2010/05/14 07:35:52 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.8
log
@rate-limit accepting of new connections while we are experiencing
fd exhaustion.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2011/05/09 11:15:18 reyk Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.7
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2011/05/05 12:55:52 reyk Exp $	*/
d49 1
a49 1
void	 control_close(int);
d125 2
a126 2
	event_set(&cs->cs_ev, cs->cs_fd, EV_READ | EV_PERSIST,
	    control_accept, cs->cs_env);
d128 1
d138 2
d147 1
a147 1
	struct iked		*env = arg;
d153 4
d160 10
a169 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d185 1
a185 1
	c->iev.data = env;
d206 1
a206 1
control_close(int fd)
d220 7
d234 2
a235 1
	struct iked		*env = arg;
d248 1
a248 1
			control_close(fd);
d254 1
a254 1
			control_close(fd);
d265 1
a265 1
			control_close(fd);
@


1.6
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2010/12/22 16:37:52 reyk Exp $	*/
d268 3
a270 3
			imsg_forward_proc(env, &imsg, PROC_PARENT);
			imsg_forward_proc(env, &imsg, PROC_IKEV2);
			imsg_forward_proc(env, &imsg, PROC_IKEV1);
d278 1
a278 1
			imsg_forward_proc(env, &imsg, PROC_PARENT);
@


1.5
log
@Fix a little control socket bug, as discussed with mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2010/12/21 13:24:11 mikeb Exp $	*/
d54 1
a54 1
control_init(struct iked *env, struct control_sock *cs)
d56 1
@


1.4
log
@fixup log_warn and log_debug arguments;  ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2010/06/24 20:15:30 reyk Exp $	*/
d168 1
d170 1
a170 1
	    c->iev.handler, env);
@


1.3
log
@unbreak the ikectl log verbose/brief commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2010/06/10 14:08:37 reyk Exp $	*/
d120 1
a120 1
		log_warn("%s: listen");
d153 1
a153 1
			log_warn("%s: accept");
@


1.2
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d267 1
a268 1
			imsg_forward_proc(env, &imsg, PROC_IKEV2);
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2009/12/02 19:10:02 mk Exp $	*/
d272 4
@

