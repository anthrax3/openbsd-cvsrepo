head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10;
locks; strict;
comment	@ * @;


1.44
date	2017.03.28.19.52.03;	author reyk;	state Exp;
branches;
next	1.43;
commitid	1iWLWVzBdFroqQt3;

1.43
date	2017.03.27.10.06.41;	author reyk;	state Exp;
branches;
next	1.42;
commitid	37oqp7mUEkdGuEb4;

1.42
date	2017.01.20.14.08.08;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	rxvQQBipf4VrxcSv;

1.41
date	2017.01.03.17.51.38;	author reyk;	state Exp;
branches;
next	1.40;
commitid	l0crj6yP4TgYYXus;

1.40
date	2015.12.07.12.46.37;	author reyk;	state Exp;
branches;
next	1.39;
commitid	8zCLewXZF0DAEoO0;

1.39
date	2015.10.22.15.55.18;	author reyk;	state Exp;
branches;
next	1.38;
commitid	9R73DxVDj9dmoXct;

1.38
date	2015.10.19.11.25.35;	author reyk;	state Exp;
branches;
next	1.37;
commitid	HzcDW70HFbhaqvT8;

1.37
date	2015.10.01.10.59.23;	author reyk;	state Exp;
branches;
next	1.36;
commitid	J33WGURgnlsCAOFp;

1.36
date	2015.08.21.11.59.27;	author reyk;	state Exp;
branches;
next	1.35;
commitid	CNs9dXqQUQ09vB19;

1.35
date	2015.03.26.19.52.35;	author markus;	state Exp;
branches;
next	1.34;
commitid	OLM4J0heQ8InGopV;

1.34
date	2015.02.06.10.39.01;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	fN2B4abgRqE4hFJn;

1.33
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.12.05.07.24.45;	author mikeb;	state Exp;
branches;
next	1.31;
commitid	FyR2JeRirAu17Kum;

1.31
date	2014.07.10.12.50.05;	author jsg;	state Exp;
branches;
next	1.30;
commitid	ER0OliUrARJBWane;

1.30
date	2014.05.07.12.57.13;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.05.18.56.42;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.05.18.54.17;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.22.12.00.03;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2014.02.17.15.07.23;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2014.02.17.11.00.14;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.28.20.21.17;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.14.12.38.20;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.16.14.39.00;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.09.13.43.31;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.09.11.15.18;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.05.12.59.31;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.05.12.55.52;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.05.12.17.10;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.22.17.53.54;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.30.14.25.54;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.29.21.04.42;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.27.05.49.05;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.27.01.37.56;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.27.01.11.09;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.26.18.32.34;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.24.20.15.30;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.11.10.15.31;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.14.09.19;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.08.29.47;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.41.12;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Add helpful debug messages to tell us why public key authentication failed.

This is currently only visible in debug mode (eg. iked -dvv), some
debug messages will be turned into regular warnings later.

OK claudio@@ deraadt@@
@
text
@/*	$OpenBSD: ca.c,v 1.43 2017/03/27 10:06:41 reyk Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <event.h>

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/engine.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/pem.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/rsa.h>

#include "iked.h"
#include "ikev2.h"

void	 ca_run(struct privsep *, struct privsep_proc *, void *);
void	 ca_reset(struct privsep *);
int	 ca_reload(struct iked *);

int	 ca_getreq(struct iked *, struct imsg *);
int	 ca_getcert(struct iked *, struct imsg *);
int	 ca_getauth(struct iked *, struct imsg *);
X509	*ca_by_subjectpubkey(X509_STORE *, uint8_t *, size_t);
X509	*ca_by_issuer(X509_STORE *, X509_NAME *, struct iked_static_id *);
int	 ca_subjectpubkey_digest(X509 *, uint8_t *, unsigned int *);
int	 ca_x509_subject_cmp(X509 *, struct iked_static_id *);
int	 ca_validate_pubkey(struct iked *, struct iked_static_id *,
	    void *, size_t);
int	 ca_validate_cert(struct iked *, struct iked_static_id *,
	    void *, size_t);
int	 ca_privkey_to_method(struct iked_id *);
struct ibuf *
	 ca_x509_serialize(X509 *);
int	 ca_x509_subjectaltname_cmp(X509 *, struct iked_static_id *);
int	 ca_x509_subjectaltname(X509 *cert, struct iked_id *);
int	 ca_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 ca_dispatch_ikev2(int, struct privsep_proc *, struct imsg *);

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	ca_dispatch_parent },
	{ "ikev2",	PROC_IKEV2,	ca_dispatch_ikev2 }
};

struct ca_store {
	X509_STORE	*ca_cas;
	X509_LOOKUP	*ca_calookup;

	X509_STORE	*ca_certs;
	X509_LOOKUP	*ca_certlookup;

	struct iked_id	 ca_privkey;
	struct iked_id	 ca_pubkey;

	uint8_t		 ca_privkey_method;
};

pid_t
caproc(struct privsep *ps, struct privsep_proc *p)
{
	return (proc_run(ps, p, procs, nitems(procs), ca_run, NULL));
}

void
ca_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	struct iked	*env = ps->ps_env;
	struct ca_store	*store;

	/*
	 * pledge in the ca process:
	 * stdio - for malloc and basic I/O including events.
	 * rpath - for certificate files.
	 * recvfd - for ocsp sockets.
	 */
	if (pledge("stdio rpath recvfd", NULL) == -1)
		fatal("pledge");

	if ((store = calloc(1, sizeof(*store))) == NULL)
		fatal("%s: failed to allocate cert store", __func__);

	env->sc_priv = store;
}

void
ca_getkey(struct privsep *ps, struct iked_id *key, enum imsg_type type)
{
	struct iked	*env = ps->ps_env;
	struct ca_store	*store = env->sc_priv;
	struct iked_id	*id;
	const char	*name;

	if (store == NULL)
		fatalx("%s: invalid store", __func__);

	if (type == IMSG_PRIVKEY) {
		name = "private";
		id = &store->ca_privkey;

		store->ca_privkey_method = ca_privkey_to_method(key);
		if (store->ca_privkey_method == IKEV2_AUTH_NONE)
			fatalx("ca: failed to get auth method for privkey");
	} else if (type == IMSG_PUBKEY) {
		name = "public";
		id = &store->ca_pubkey;
	} else
		fatalx("%s: invalid type %d", __func__, type);

	log_debug("%s: received %s key type %s length %zd", __func__,
	    name, print_map(key->id_type, ikev2_cert_map),
	    ibuf_length(key->id_buf));

	/* clear old key and copy new one */
	ibuf_release(id->id_buf);
	memcpy(id, key, sizeof(*id));
}

void
ca_reset(struct privsep *ps)
{
	struct iked	*env = ps->ps_env;
	struct ca_store	*store = env->sc_priv;

	if (store->ca_privkey.id_type == IKEV2_ID_NONE ||
	    store->ca_pubkey.id_type == IKEV2_ID_NONE)
		fatalx("ca_reset: keys not loaded");

	if (store->ca_cas != NULL)
		X509_STORE_free(store->ca_cas);
	if (store->ca_certs != NULL)
		X509_STORE_free(store->ca_certs);

	if ((store->ca_cas = X509_STORE_new()) == NULL)
		fatalx("ca_reset: failed to get ca store");
	if ((store->ca_calookup = X509_STORE_add_lookup(store->ca_cas,
	    X509_LOOKUP_file())) == NULL)
		fatalx("ca_reset: failed to add ca lookup");

	if ((store->ca_certs = X509_STORE_new()) == NULL)
		fatalx("ca_reset: failed to get cert store");
	if ((store->ca_certlookup = X509_STORE_add_lookup(store->ca_certs,
	    X509_LOOKUP_file())) == NULL)
		fatalx("ca_reset: failed to add cert lookup");

	if (ca_reload(env) != 0)
		fatal("ca_reset: reload");
}

int
ca_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked		*env = p->p_env;
	unsigned int		 mode;

	switch (imsg->hdr.type) {
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &mode);
		memcpy(&mode, imsg->data, sizeof(mode));
		if (mode == RESET_ALL || mode == RESET_CA) {
			log_debug("%s: config reset", __func__);
			ca_reset(&env->sc_ps);
		}
		break;
	case IMSG_OCSP_FD:
		ocsp_receive_fd(env, imsg);
		break;
	case IMSG_OCSP_URL:
		config_getocsp(env, imsg);
		break;
	case IMSG_PRIVKEY:
	case IMSG_PUBKEY:
		config_getkey(env, imsg);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
ca_dispatch_ikev2(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct iked	*env = p->p_env;

	switch (imsg->hdr.type) {
	case IMSG_CERTREQ:
		ca_getreq(env, imsg);
		break;
	case IMSG_CERT:
		ca_getcert(env, imsg);
		break;
	case IMSG_AUTH:
		ca_getauth(env, imsg);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
ca_setcert(struct iked *env, struct iked_sahdr *sh, struct iked_id *id,
    uint8_t type, uint8_t *data, size_t len, enum privsep_procid procid)
{
	struct iovec		iov[4];
	int			iovcnt = 0;
	struct iked_static_id	idb;

	/* Must send the cert and a valid Id to the ca process */
	if (procid == PROC_CERT) {
		if (id == NULL || id->id_type == IKEV2_ID_NONE ||
		    ibuf_length(id->id_buf) > IKED_ID_SIZE)
			return (-1);
		bzero(&idb, sizeof(idb));

		/* Convert to a static Id */
		idb.id_type = id->id_type;
		idb.id_offset = id->id_offset;
		idb.id_length = ibuf_length(id->id_buf);
		memcpy(&idb.id_data, ibuf_data(id->id_buf),
		    ibuf_length(id->id_buf));

		iov[iovcnt].iov_base = &idb;
		iov[iovcnt].iov_len = sizeof(idb);
		iovcnt++;
	}

	iov[iovcnt].iov_base = sh;
	iov[iovcnt].iov_len = sizeof(*sh);
	iovcnt++;
	iov[iovcnt].iov_base = &type;
	iov[iovcnt].iov_len = sizeof(type);
	iovcnt++;
	iov[iovcnt].iov_base = data;
	iov[iovcnt].iov_len = len;
	iovcnt++;

	if (proc_composev(&env->sc_ps, procid, IMSG_CERT, iov, iovcnt) == -1)
		return (-1);
	return (0);
}

int
ca_setreq(struct iked *env, struct iked_sa *sa,
    struct iked_static_id *localid, uint8_t type, uint8_t *data,
    size_t len, enum privsep_procid procid)
{
	struct iovec		iov[4];
	int			iovcnt = 0;
	struct iked_static_id	idb;
	struct iked_id		id;
	int			ret = -1;

	/* Convert to a static Id */
	bzero(&id, sizeof(id));
	if (ikev2_policy2id(localid, &id, 1) != 0)
		return (-1);

	bzero(&idb, sizeof(idb));
	idb.id_type = id.id_type;
	idb.id_offset = id.id_offset;
	idb.id_length = ibuf_length(id.id_buf);
	memcpy(&idb.id_data, ibuf_data(id.id_buf),
	    ibuf_length(id.id_buf));
	iov[iovcnt].iov_base = &idb;
	iov[iovcnt].iov_len = sizeof(idb);
	iovcnt++;

	iov[iovcnt].iov_base = &sa->sa_hdr;
	iov[iovcnt].iov_len = sizeof(sa->sa_hdr);
	iovcnt++;
	iov[iovcnt].iov_base = &type;
	iov[iovcnt].iov_len = sizeof(type);
	iovcnt++;
	iov[iovcnt].iov_base = data;
	iov[iovcnt].iov_len = len;
	iovcnt++;

	if (proc_composev(&env->sc_ps, procid, IMSG_CERTREQ, iov, iovcnt) == -1)
		goto done;

	sa_stateflags(sa, IKED_REQ_CERTREQ);

	ret = 0;
 done:
	ibuf_release(id.id_buf);
	return (ret);
}

int
ca_setauth(struct iked *env, struct iked_sa *sa,
    struct ibuf *authmsg, enum privsep_procid id)
{
	struct iovec		 iov[3];
	int			 iovcnt = 3;
	struct iked_policy	*policy = sa->sa_policy;
	uint8_t			 type = policy->pol_auth.auth_method;

	if (id == PROC_CERT) {
		/* switch encoding to IKEV2_AUTH_SIG if SHA2 is supported */
		if (sa->sa_sigsha2 && type == IKEV2_AUTH_RSA_SIG) {
			log_debug("%s: switching RSA_SIG to SIG", __func__);
			type = IKEV2_AUTH_SIG;
		} else if (!sa->sa_sigsha2 && type == IKEV2_AUTH_SIG_ANY) {
			log_debug("%s: switching SIG to RSA_SIG(*)", __func__);
			/* XXX ca might auto-switch to ECDSA */
			type = IKEV2_AUTH_RSA_SIG;
		} else if (type == IKEV2_AUTH_SIG) {
			log_debug("%s: using SIG (RFC7427)", __func__);
		}
	}

	if (type == IKEV2_AUTH_SHARED_KEY_MIC) {
		sa->sa_stateflags |= IKED_REQ_AUTH;
		return (ikev2_msg_authsign(env, sa,
		    &policy->pol_auth, authmsg));
	}

	iov[0].iov_base = &sa->sa_hdr;
	iov[0].iov_len = sizeof(sa->sa_hdr);
	iov[1].iov_base = &type;
	iov[1].iov_len = sizeof(type);
	if (type == IKEV2_AUTH_NONE)
		iovcnt--;
	else {
		iov[2].iov_base = ibuf_data(authmsg);
		iov[2].iov_len = ibuf_size(authmsg);
		log_debug("%s: auth length %zu", __func__, ibuf_size(authmsg));
	}

	if (proc_composev(&env->sc_ps, id, IMSG_AUTH, iov, iovcnt) == -1)
		return (-1);
	return (0);
}

int
ca_getcert(struct iked *env, struct imsg *imsg)
{
	struct iked_sahdr	 sh;
	uint8_t			 type;
	uint8_t			*ptr;
	size_t			 len;
	struct iked_static_id	 id;
	unsigned int		 i;
	struct iovec		 iov[2];
	int			 iovcnt = 2, cmd, ret = 0;

	ptr = (uint8_t *)imsg->data;
	len = IMSG_DATA_SIZE(imsg);
	i = sizeof(id) + sizeof(sh) + sizeof(type);
	if (len <= i)
		return (-1);

	memcpy(&id, ptr, sizeof(id));
	if (id.id_type == IKEV2_ID_NONE)
		return (-1);
	memcpy(&sh, ptr + sizeof(id), sizeof(sh));
	memcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(uint8_t));

	ptr += i;
	len -= i;

	switch (type) {
	case IKEV2_CERT_X509_CERT:
		ret = ca_validate_cert(env, &id, ptr, len);
		if (ret == 0 && env->sc_ocsp_url) {
			ret = ocsp_validate_cert(env, &id, ptr, len, sh, type);
			if (ret == 0)
				return (0);
		}
		break;
	case IKEV2_CERT_RSA_KEY:
	case IKEV2_CERT_ECDSA:
		ret = ca_validate_pubkey(env, &id, ptr, len);
		break;
	default:
		log_debug("%s: unsupported cert type %d", __func__, type);
		ret = -1;
		break;
	}

	if (ret == 0)
		cmd = IMSG_CERTVALID;
	else
		cmd = IMSG_CERTINVALID;

	iov[0].iov_base = &sh;
	iov[0].iov_len = sizeof(sh);
	iov[1].iov_base = &type;
	iov[1].iov_len = sizeof(type);

	if (proc_composev(&env->sc_ps, PROC_IKEV2, cmd, iov, iovcnt) == -1)
		return (-1);
	return (0);
}

int
ca_getreq(struct iked *env, struct imsg *imsg)
{
	struct ca_store		*store = env->sc_priv;
	struct iked_sahdr	 sh;
	uint8_t			 type;
	uint8_t			*ptr;
	size_t			 len;
	unsigned int		 i, n;
	X509			*ca = NULL, *cert = NULL;
	struct ibuf		*buf;
	struct iked_static_id	 id;

	ptr = (uint8_t *)imsg->data;
	len = IMSG_DATA_SIZE(imsg);
	i = sizeof(id) + sizeof(uint8_t) + sizeof(sh);
	if (len < i || ((len - i) % SHA_DIGEST_LENGTH) != 0)
		return (-1);

	memcpy(&id, ptr, sizeof(id));
	if (id.id_type == IKEV2_ID_NONE)
		return (-1);
	memcpy(&sh, ptr + sizeof(id), sizeof(sh));
	memcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(uint8_t));

	switch (type) {
	case IKEV2_CERT_RSA_KEY:
	case IKEV2_CERT_ECDSA:
		if (store->ca_pubkey.id_type != type ||
		    (buf = store->ca_pubkey.id_buf) == NULL)
			return (-1);

		log_debug("%s: using local public key of type %s", __func__,
		    print_map(type, ikev2_cert_map));
		break;
	case IKEV2_CERT_X509_CERT:
		for (n = 1; i < len; n++, i += SHA_DIGEST_LENGTH) {
			if ((ca = ca_by_subjectpubkey(store->ca_cas, ptr + i,
			    SHA_DIGEST_LENGTH)) == NULL)
				continue;

			log_debug("%s: found CA %s", __func__, ca->name);

			if ((cert = ca_by_issuer(store->ca_certs,
			    X509_get_subject_name(ca), &id)) != NULL) {
				/* XXX
				 * should we re-validate our own cert here?
				 */
				break;
			}
		}
		if (ca == NULL || cert == NULL) {
			log_warnx("%s: no valid local certificate found",
			    __func__);
			type = IKEV2_CERT_NONE;
			ca_setcert(env, &sh, NULL, type, NULL, 0, PROC_IKEV2);
			return (0);
		}
		log_debug("%s: found local certificate %s", __func__,
		    cert->name);

		if ((buf = ca_x509_serialize(cert)) == NULL)
			return (-1);
		break;
	default:
		log_warnx("%s: unknown cert type requested", __func__);
		return (-1);
	}

	ca_setcert(env, &sh, NULL, type,
	    ibuf_data(buf), ibuf_size(buf), PROC_IKEV2);

	return (0);
}

int
ca_getauth(struct iked *env, struct imsg *imsg)
{
	struct ca_store		*store = env->sc_priv;
	struct iked_sahdr	 sh;
	uint8_t			 method;
	uint8_t			*ptr;
	size_t			 len;
	unsigned int		 i;
	int			 ret = -1;
	struct iked_sa		 sa;
	struct iked_policy	 policy;
	struct iked_id		*id;
	struct ibuf		*authmsg;

	ptr = (uint8_t *)imsg->data;
	len = IMSG_DATA_SIZE(imsg);
	i = sizeof(method) + sizeof(sh);
	if (len <= i)
		return (-1);

	memcpy(&sh, ptr, sizeof(sh));
	memcpy(&method, ptr + sizeof(sh), sizeof(uint8_t));
	if (method == IKEV2_AUTH_SHARED_KEY_MIC)
		return (-1);

	ptr += i;
	len -= i;

	if ((authmsg = ibuf_new(ptr, len)) == NULL)
		return (-1);

	/*
	 * Create fake SA and policy
	 */
	bzero(&sa, sizeof(sa));
	bzero(&policy, sizeof(policy));
	memcpy(&sa.sa_hdr, &sh, sizeof(sh));
	sa.sa_policy = &policy;
	if (sh.sh_initiator)
		id = &sa.sa_icert;
	else
		id = &sa.sa_rcert;
	memcpy(id, &store->ca_privkey, sizeof(*id));
	policy.pol_auth.auth_method = method == IKEV2_AUTH_SIG ?
	    method : store->ca_privkey_method;

	if (ikev2_msg_authsign(env, &sa, &policy.pol_auth, authmsg) != 0) {
		log_debug("%s: AUTH sign failed", __func__);
		policy.pol_auth.auth_method = IKEV2_AUTH_NONE;
	}

	ret = ca_setauth(env, &sa, sa.sa_localauth.id_buf, PROC_IKEV2);

	ibuf_release(sa.sa_localauth.id_buf);
	ibuf_release(authmsg);

	return (ret);
}

int
ca_reload(struct iked *env)
{
	struct ca_store		*store = env->sc_priv;
	uint8_t			 md[EVP_MAX_MD_SIZE];
	char			 file[PATH_MAX];
	struct iovec		 iov[2];
	struct dirent		*entry;
	STACK_OF(X509_OBJECT)	*h;
	X509_OBJECT		*xo;
	X509			*x509;
	DIR			*dir;
	int			 i, len, iovcnt = 0;

	/*
	 * Load CAs
	 */
	if ((dir = opendir(IKED_CA_DIR)) == NULL)
		return (-1);

	while ((entry = readdir(dir)) != NULL) {
		if ((entry->d_type != DT_REG) &&
		    (entry->d_type != DT_LNK))
			continue;

		if (snprintf(file, sizeof(file), "%s%s",
		    IKED_CA_DIR, entry->d_name) == -1)
			continue;

		if (!X509_load_cert_file(store->ca_calookup, file,
		    X509_FILETYPE_PEM)) {
			log_warn("%s: failed to load ca file %s", __func__,
			    entry->d_name);
			ca_sslerror(__func__);
			continue;
		}
		log_debug("%s: loaded ca file %s", __func__, entry->d_name);
	}
	closedir(dir);

	/*
	 * Load CRLs for the CAs
	 */
	if ((dir = opendir(IKED_CRL_DIR)) == NULL)
		return (-1);

	while ((entry = readdir(dir)) != NULL) {
		if ((entry->d_type != DT_REG) &&
		    (entry->d_type != DT_LNK))
			continue;

		if (snprintf(file, sizeof(file), "%s%s",
		    IKED_CRL_DIR, entry->d_name) == -1)
			continue;

		if (!X509_load_crl_file(store->ca_calookup, file,
		    X509_FILETYPE_PEM)) {
			log_warn("%s: failed to load crl file %s", __func__,
			    entry->d_name);
			ca_sslerror(__func__);
			continue;
		}

		/* Only enable CRL checks if we actually loaded a CRL */
		X509_STORE_set_flags(store->ca_cas, X509_V_FLAG_CRL_CHECK);

		log_debug("%s: loaded crl file %s", __func__, entry->d_name);
	}
	closedir(dir);

	/*
	 * Save CAs signatures for the IKEv2 CERTREQ
	 */
	ibuf_release(env->sc_certreq);
	if ((env->sc_certreq = ibuf_new(NULL, 0)) == NULL)
		return (-1);

	h = store->ca_cas->objs;
	for (i = 0; i < sk_X509_OBJECT_num(h); i++) {
		xo = sk_X509_OBJECT_value(h, i);
		if (xo->type != X509_LU_X509)
			continue;

		x509 = xo->data.x509;
		len = sizeof(md);
		ca_subjectpubkey_digest(x509, md, &len);
		log_debug("%s: %s", __func__, x509->name);

		if (ibuf_add(env->sc_certreq, md, len) != 0) {
			ibuf_release(env->sc_certreq);
			env->sc_certreq = NULL;
			return (-1);
		}
	}

	if (ibuf_length(env->sc_certreq)) {
		env->sc_certreqtype = IKEV2_CERT_X509_CERT;
		iov[0].iov_base = &env->sc_certreqtype;
		iov[0].iov_len = sizeof(env->sc_certreqtype);
		iovcnt++;
		iov[1].iov_base = ibuf_data(env->sc_certreq);
		iov[1].iov_len = ibuf_length(env->sc_certreq);
		iovcnt++;

		log_debug("%s: loaded %zu ca certificate%s", __func__,
		    ibuf_length(env->sc_certreq) / SHA_DIGEST_LENGTH,
		    ibuf_length(env->sc_certreq) == SHA_DIGEST_LENGTH ?
		    "" : "s");

		(void)proc_composev(&env->sc_ps, PROC_IKEV2, IMSG_CERTREQ,
		    iov, iovcnt);
	}

	/*
	 * Load certificates
	 */
	if ((dir = opendir(IKED_CERT_DIR)) == NULL)
		return (-1);

	while ((entry = readdir(dir)) != NULL) {
		if ((entry->d_type != DT_REG) &&
		    (entry->d_type != DT_LNK))
			continue;

		if (snprintf(file, sizeof(file), "%s%s",
		    IKED_CERT_DIR, entry->d_name) == -1)
			continue;

		if (!X509_load_cert_file(store->ca_certlookup, file,
		    X509_FILETYPE_PEM)) {
			log_warn("%s: failed to load cert file %s", __func__,
			    entry->d_name);
			ca_sslerror(__func__);
			continue;
		}
		log_debug("%s: loaded cert file %s", __func__, entry->d_name);
	}
	closedir(dir);

	h = store->ca_certs->objs;
	for (i = 0; i < sk_X509_OBJECT_num(h); i++) {
		xo = sk_X509_OBJECT_value(h, i);
		if (xo->type != X509_LU_X509)
			continue;

		x509 = xo->data.x509;

		(void)ca_validate_cert(env, NULL, x509, 0);
	}

	if (!env->sc_certreqtype)
		env->sc_certreqtype = store->ca_pubkey.id_type;

	log_debug("%s: local cert type %s", __func__,
	    print_map(env->sc_certreqtype, ikev2_cert_map));

	iov[0].iov_base = &env->sc_certreqtype;
	iov[0].iov_len = sizeof(env->sc_certreqtype);
	if (iovcnt == 0)
		iovcnt++;
	(void)proc_composev(&env->sc_ps, PROC_IKEV2, IMSG_CERTREQ, iov, iovcnt);

	return (0);
}

X509 *
ca_by_subjectpubkey(X509_STORE *ctx, uint8_t *sig, size_t siglen)
{
	STACK_OF(X509_OBJECT)	*h;
	X509_OBJECT		*xo;
	X509			*ca;
	int			 i;
	unsigned int		 len;
	uint8_t			 md[EVP_MAX_MD_SIZE];

	h = ctx->objs;

	for (i = 0; i < sk_X509_OBJECT_num(h); i++) {
		xo = sk_X509_OBJECT_value(h, i);
		if (xo->type != X509_LU_X509)
			continue;

		ca = xo->data.x509;
		len = sizeof(md);
		ca_subjectpubkey_digest(ca, md, &len);

		if (len == siglen && memcmp(md, sig, len) == 0)
			return (ca);
	}

	return (NULL);
}

X509 *
ca_by_issuer(X509_STORE *ctx, X509_NAME *subject, struct iked_static_id *id)
{
	STACK_OF(X509_OBJECT)	*h;
	X509_OBJECT		*xo;
	X509			*cert;
	int			 i;
	X509_NAME		*issuer;

	if (subject == NULL)
		return (NULL);

	h = ctx->objs;
	for (i = 0; i < sk_X509_OBJECT_num(h); i++) {
		xo = sk_X509_OBJECT_value(h, i);
		if (xo->type != X509_LU_X509)
			continue;

		cert = xo->data.x509;
		if ((issuer = X509_get_issuer_name(cert)) == NULL)
			continue;
		else if (X509_NAME_cmp(subject, issuer) == 0) {
			switch (id->id_type) {
			case IKEV2_ID_ASN1_DN:
				if (ca_x509_subject_cmp(cert, id) == 0)
					return (cert);
				break;
			default:
				if (ca_x509_subjectaltname_cmp(cert, id) == 0)
					return (cert);
				break;
			}
		}
	}

	return (NULL);
}

int
ca_subjectpubkey_digest(X509 *x509, uint8_t *md, unsigned int *size)
{
	EVP_PKEY	*pkey;
	uint8_t		*buf = NULL;
	int		 buflen;

	if (*size < SHA_DIGEST_LENGTH)
		return (-1);

	/*
	 * Generate a SHA-1 digest of the Subject Public Key Info
	 * element in the X.509 certificate, an ASN.1 sequence
	 * that includes the public key type (eg. RSA) and the
	 * public key value (see 3.7 of RFC4306).
	 */
	if ((pkey = X509_get_pubkey(x509)) == NULL)
		return (-1);
	buflen = i2d_PUBKEY(pkey, &buf);
	EVP_PKEY_free(pkey);
	if (buflen == 0)
		return (-1);
	if (!EVP_Digest(buf, buflen, md, size, EVP_sha1(), NULL)) {
		free(buf);
		return (-1);
	}
	free(buf);

	return (0);
}

struct ibuf *
ca_x509_serialize(X509 *x509)
{
	long		 len;
	struct ibuf	*buf;
	uint8_t		*d = NULL;
	BIO		*out;

	if ((out = BIO_new(BIO_s_mem())) == NULL)
		return (NULL);
	if (!i2d_X509_bio(out, x509)) {
		BIO_free(out);
		return (NULL);
	}

	len = BIO_get_mem_data(out, &d);
	buf = ibuf_new(d, len);
	BIO_free(out);

	return (buf);
}

int
ca_pubkey_serialize(EVP_PKEY *key, struct iked_id *id)
{
	RSA		*rsa = NULL;
	EC_KEY		*ec = NULL;
	uint8_t		*d;
	int		 len = 0;
	int		 ret = -1;

	switch (key->type) {
	case EVP_PKEY_RSA:
		id->id_type = 0;
		id->id_offset = 0;
		ibuf_release(id->id_buf);
		id->id_buf = NULL;

		if ((rsa = EVP_PKEY_get1_RSA(key)) == NULL)
			goto done;
		if ((len = i2d_RSAPublicKey(rsa, NULL)) <= 0)
			goto done;
		if ((id->id_buf = ibuf_new(NULL, len)) == NULL)
			goto done;

		d = ibuf_data(id->id_buf);
		if (i2d_RSAPublicKey(rsa, &d) != len) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			goto done;
		}

		id->id_type = IKEV2_CERT_RSA_KEY;
		break;
	case EVP_PKEY_EC:
		id->id_type = 0;
		id->id_offset = 0;
		ibuf_release(id->id_buf);
		id->id_buf = NULL;

		if ((ec = EVP_PKEY_get1_EC_KEY(key)) == NULL)
			goto done;
		if ((len = i2d_EC_PUBKEY(ec, NULL)) <= 0)
			goto done;
		if ((id->id_buf = ibuf_new(NULL, len)) == NULL)
			goto done;

		d = ibuf_data(id->id_buf);
		if (i2d_EC_PUBKEY(ec, &d) != len) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			goto done;
		}

		id->id_type = IKEV2_CERT_ECDSA;
		break;
	default:
		log_debug("%s: unsupported key type %d", __func__, key->type);
		return (-1);
	}

	log_debug("%s: type %s length %d", __func__,
	    print_map(id->id_type, ikev2_cert_map), len);

	ret = 0;
 done:
	if (rsa != NULL)
		RSA_free(rsa);
	if (ec != NULL)
		EC_KEY_free(ec);
	return (ret);
}

int
ca_privkey_serialize(EVP_PKEY *key, struct iked_id *id)
{
	RSA		*rsa = NULL;
	EC_KEY		*ec = NULL;
	uint8_t		*d;
	int		 len = 0;
	int		 ret = -1;

	switch (key->type) {
	case EVP_PKEY_RSA:
		id->id_type = 0;
		id->id_offset = 0;
		ibuf_release(id->id_buf);
		id->id_buf = NULL;

		if ((rsa = EVP_PKEY_get1_RSA(key)) == NULL)
			goto done;
		if ((len = i2d_RSAPrivateKey(rsa, NULL)) <= 0)
			goto done;
		if ((id->id_buf = ibuf_new(NULL, len)) == NULL)
			goto done;

		d = ibuf_data(id->id_buf);
		if (i2d_RSAPrivateKey(rsa, &d) != len) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			goto done;
		}

		id->id_type = IKEV2_CERT_RSA_KEY;
		break;
	case EVP_PKEY_EC:
		id->id_type = 0;
		id->id_offset = 0;
		ibuf_release(id->id_buf);
		id->id_buf = NULL;

		if ((ec = EVP_PKEY_get1_EC_KEY(key)) == NULL)
			goto done;
		if ((len = i2d_ECPrivateKey(ec, NULL)) <= 0)
			goto done;
		if ((id->id_buf = ibuf_new(NULL, len)) == NULL)
			goto done;

		d = ibuf_data(id->id_buf);
		if (i2d_ECPrivateKey(ec, &d) != len) {
			ibuf_release(id->id_buf);
			id->id_buf = NULL;
			goto done;
		}

		id->id_type = IKEV2_CERT_ECDSA;
		break;
	default:
		log_debug("%s: unsupported key type %d", __func__, key->type);
		return (-1);
	}

	log_debug("%s: type %s length %d", __func__,
	    print_map(id->id_type, ikev2_cert_map), len);

	ret = 0;
 done:
	if (rsa != NULL)
		RSA_free(rsa);
	if (ec != NULL)
		EC_KEY_free(ec);
	return (ret);
}

int
ca_privkey_to_method(struct iked_id *privkey)
{
	BIO		*rawcert = NULL;
	EC_KEY		*ec = NULL;
	const EC_GROUP	*group = NULL;
	uint8_t	 method = IKEV2_AUTH_NONE;

	switch (privkey->id_type) {
	case IKEV2_CERT_RSA_KEY:
		method = IKEV2_AUTH_RSA_SIG;
		break;
	case IKEV2_CERT_ECDSA:
		if ((rawcert = BIO_new_mem_buf(ibuf_data(privkey->id_buf),
		    ibuf_length(privkey->id_buf))) == NULL)
			goto out;
		if ((ec = d2i_ECPrivateKey_bio(rawcert, NULL)) == NULL)
			goto out;
		if ((group = EC_KEY_get0_group(ec)) == NULL)
			goto out;
		switch (EC_GROUP_get_degree(group)) {
		case 256:
			method = IKEV2_AUTH_ECDSA_256;
			break;
		case 384:
			method = IKEV2_AUTH_ECDSA_384;
			break;
		case 521:
			method = IKEV2_AUTH_ECDSA_521;
			break;
		}
	}

	log_debug("%s: type %s method %s", __func__,
	    print_map(privkey->id_type, ikev2_cert_map),
	    print_map(method, ikev2_auth_map));

 out:
	if (ec != NULL)
		EC_KEY_free(ec);
	if (rawcert != NULL)
		BIO_free(rawcert);

	return (method);
}

char *
ca_asn1_name(uint8_t *asn1, size_t len)
{
	X509_NAME	*name = NULL;
	char		*str = NULL;
	const uint8_t	*p;

	p = asn1;
	if ((name = d2i_X509_NAME(NULL, &p, len)) == NULL)
		return (NULL);
	str = ca_x509_name(name);
	X509_NAME_free(name);

	return (str);
}

char *
ca_x509_name(void *ptr)
{
	char		 buf[BUFSIZ];
	X509_NAME	*name = ptr;

	bzero(buf, sizeof(buf));
	if (!X509_NAME_oneline(name, buf, sizeof(buf) - 1))
		return (NULL);

	return (strdup(buf));
}

/*
 * Copy 'src' to 'dst' until 'marker' is found while unescaping '\'
 * characters. The return value tells the caller where to continue
 * parsing (might be the end of the string) or NULL on error.
 */
static char *
ca_x509_name_unescape(char *src, char *dst, char marker)
{
	while (*src) {
		if (*src == marker) {
			src++;
			break;
		}
		if (*src == '\\') {
			src++;
			if (!*src) {
				log_warnx("%s: '\\' at end of string",
				    __func__);
				*dst = '\0';
				return (NULL);
			}
		}
		*dst++ = *src++;
	}
	*dst = '\0';
	return (src);
}
/*
 * Parse an X509 subject name where 'subject' is in the format
 *    /type0=value0/type1=value1/type2=...
 * where characters may be escaped by '\'.
 * See lib/libssl/src/apps/apps.c:parse_name()
 */
void *
ca_x509_name_parse(char *subject)
{
	char		*cp, *value = NULL, *type = NULL;
	size_t		 maxlen;
	X509_NAME	*name = NULL;

	if (*subject != '/') {
		log_warnx("%s: leading '/' missing in '%s'", __func__, subject);
		goto err;
	}

	/* length of subject is upper bound for unescaped type/value */
	maxlen = strlen(subject) + 1;

	if ((type = calloc(1, maxlen)) == NULL ||
	    (value = calloc(1, maxlen)) == NULL ||
	    (name = X509_NAME_new()) == NULL)
		goto err;

	cp = subject + 1;
	while (*cp) {
		/* unescape type, terminated by '=' */
		cp = ca_x509_name_unescape(cp, type, '=');
		if (cp == NULL) {
			log_warnx("%s: could not parse type", __func__);
			goto err;
		}
		if (!*cp) {
			log_warnx("%s: missing value", __func__);
			goto err;
		}
		/* unescape value, terminated by '/' */
		cp = ca_x509_name_unescape(cp, value, '/');
		if (cp == NULL) {
			log_warnx("%s: could not parse value", __func__);
			goto err;
		}
		if (!*type || !*value) {
			log_warnx("%s: empty type or value", __func__);
			goto err;
		}
		log_debug("%s: setting '%s' to '%s'", __func__, type, value);
		if (!X509_NAME_add_entry_by_txt(name, type, MBSTRING_ASC,
		    value, -1, -1, 0)) {
			log_warnx("%s: setting '%s' to '%s' failed", __func__,
			    type, value);
			ca_sslerror(__func__);
			goto err;
		}
	}
	free(type);
	free(value);
	return (name);

err:
	X509_NAME_free(name);
	free(type);
	free(value);
	return (NULL);
}

int
ca_validate_pubkey(struct iked *env, struct iked_static_id *id,
    void *data, size_t len)
{
	BIO		*rawcert = NULL;
	RSA		*peerrsa = NULL, *localrsa = NULL;
	EC_KEY		*peerec = NULL;
	EVP_PKEY	*peerkey = NULL, *localkey = NULL;
	int		 ret = -1;
	FILE		*fp = NULL;
	char		 idstr[IKED_ID_SIZE];
	char		 file[PATH_MAX];
	struct iked_id	 idp;

	if (len == 0 && data == NULL)
		return (-1);

	switch (id->id_type) {
	case IKEV2_ID_IPV4:
	case IKEV2_ID_FQDN:
	case IKEV2_ID_UFQDN:
	case IKEV2_ID_IPV6:
		break;
	default:
		/* Some types like ASN1_DN will not be mapped to file names */
		log_debug("%s: unsupported public key type %s",
		    __func__, print_map(id->id_type, ikev2_id_map));
		return (-1);
	}

	bzero(&idp, sizeof(idp));
	if ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)
		goto done;

	idp.id_type = id->id_type;
	idp.id_offset = id->id_offset;
	if (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)
		goto done;

	if (len == 0) {
		/* Data is already an public key */
		peerkey = (EVP_PKEY *)data;
	} else {
		if ((rawcert = BIO_new_mem_buf(data, len)) == NULL)
			goto done;

		if ((peerkey = EVP_PKEY_new()) == NULL)
			goto sslerr;
		if ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {
			if (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {
				goto sslerr;
			}
		} else if (BIO_reset(rawcert) == 1 &&
		    (peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {
			if (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {
				goto sslerr;
			}
		} else {
			log_debug("%s: unknown key type received", __func__);
			goto sslerr;
		}
	}

	lc_string(idstr);
	if (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||
	    strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {
		log_debug("%s: public key id too long %s", __func__, idstr);
		goto done;
	}

	if ((fp = fopen(file, "r")) == NULL) {
		log_debug("%s: could not open public key %s", __func__, file);
		goto done;
	}
	localkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
	if (localkey == NULL) {
		/* reading PKCS #8 failed, try PEM RSA */
		rewind(fp);
		localrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);
		fclose(fp);
		if (localrsa == NULL)
			goto sslerr;
		if ((localkey = EVP_PKEY_new()) == NULL)
			goto sslerr;
		if (!EVP_PKEY_set1_RSA(localkey, localrsa))
			goto sslerr;
	} else {
		fclose(fp);
	}
	if (localkey == NULL)
		goto sslerr;

	if (!EVP_PKEY_cmp(peerkey, localkey)) {
		log_debug("%s: public key does not match %s", __func__, file);
		goto done;
	}

	log_debug("%s: valid public key in file %s", __func__, file);

	ret = 0;
 sslerr:
	if (ret != 0)
		ca_sslerror(__func__);
 done:
	ibuf_release(idp.id_buf);
	if (peerkey != NULL)
		EVP_PKEY_free(peerkey);
	if (localkey != NULL)
		EVP_PKEY_free(localkey);
	if (peerrsa != NULL)
		RSA_free(peerrsa);
	if (peerec != NULL)
		EC_KEY_free(peerec);
	if (localrsa != NULL)
		RSA_free(localrsa);
	if (rawcert != NULL)
		BIO_free(rawcert);

	return (ret);
}

int
ca_validate_cert(struct iked *env, struct iked_static_id *id,
    void *data, size_t len)
{
	struct ca_store	*store = env->sc_priv;
	X509_STORE_CTX	 csc;
	BIO		*rawcert = NULL;
	X509		*cert = NULL;
	int		 ret = -1, result, error;
	X509_NAME	*subject;
	const char	*errstr = "failed";

	if (len == 0) {
		/* Data is already an X509 certificate */
		cert = (X509 *)data;
	} else {
		/* Convert data to X509 certificate */
		if ((rawcert = BIO_new_mem_buf(data, len)) == NULL)
			goto done;
		if ((cert = d2i_X509_bio(rawcert, NULL)) == NULL)
			goto done;
	}

	/* Certificate needs a valid subjectName */
	if ((subject = X509_get_subject_name(cert)) == NULL) {
		errstr = "invalid subject";
		goto done;
	}

	if (id != NULL) {
		if ((ret = ca_validate_pubkey(env, id, X509_get_pubkey(cert),
		    0)) == 0) {
			errstr = "in public key file, ok";
			goto done;
		}

		switch (id->id_type) {
		case IKEV2_ID_ASN1_DN:
			if (ca_x509_subject_cmp(cert, id) < 0) {
				errstr = "ASN1_DN identifier mismatch";
				goto done;
			}
			break;
		default:
			if (ca_x509_subjectaltname_cmp(cert, id) != 0) {
				errstr = "invalid subjectAltName extension";
				goto done;
			}
			break;
		}
	}

	bzero(&csc, sizeof(csc));
	X509_STORE_CTX_init(&csc, store->ca_cas, cert, NULL);
	if (store->ca_cas->param->flags & X509_V_FLAG_CRL_CHECK) {
		X509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK);
		X509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK_ALL);
	}

	result = X509_verify_cert(&csc);
	error = csc.error;
	X509_STORE_CTX_cleanup(&csc);
	if (error != 0) {
		errstr = X509_verify_cert_error_string(error);
		goto done;
	}

	if (!result) {
		/* XXX should we accept self-signed certificates? */
		errstr = "rejecting self-signed certificate";
		goto done;
	}

	/* Success */
	ret = 0;
	errstr = "ok";

 done:
	if (cert != NULL)
		log_debug("%s: %s %.100s", __func__, cert->name, errstr);

	if (rawcert != NULL) {
		BIO_free(rawcert);
		if (cert != NULL)
			X509_free(cert);
	}

	return (ret);
}

/* check if subject from cert matches the id */
int
ca_x509_subject_cmp(X509 *cert, struct iked_static_id *id)
{
	X509_NAME	*subject, *idname = NULL;
	const uint8_t	*idptr;
	size_t		 idlen;
	int		 ret = -1;

	if (id->id_type != IKEV2_ID_ASN1_DN)
		return (-1);
	if ((subject = X509_get_subject_name(cert)) == NULL)
		return (-1);
	if (id->id_length <= id->id_offset)
		return (-1);
	idlen = id->id_length - id->id_offset;
	idptr = id->id_data + id->id_offset;
	if ((idname = d2i_X509_NAME(NULL, &idptr, idlen)) == NULL)
		return (-1);
	if (X509_NAME_cmp(subject, idname) == 0)
		ret = 0;
	X509_NAME_free(idname);
	return (ret);
}

int
ca_x509_subjectaltname_cmp(X509 *cert, struct iked_static_id *id)
{
	struct iked_id	 sanid;
	char		 idstr[IKED_ID_SIZE];
	int		 ret = -1;

	bzero(&sanid, sizeof(sanid));

	if (ca_x509_subjectaltname(cert, &sanid) != 0)
		return (-1);

	ikev2_print_id(&sanid, idstr, sizeof(idstr));

	/* Compare id types, length and data */
	if ((id->id_type != sanid.id_type) ||
	    ((ssize_t)ibuf_size(sanid.id_buf) !=
	    (id->id_length - id->id_offset)) ||
	    (memcmp(id->id_data + id->id_offset,
	    ibuf_data(sanid.id_buf),
	    ibuf_size(sanid.id_buf)) != 0)) {
		log_debug("%s: %s mismatched", __func__, idstr);
		goto done;
	}

	ret = 0;
 done:
	ibuf_release(sanid.id_buf);
	return (ret);
}

int
ca_x509_subjectaltname(X509 *cert, struct iked_id *id)
{
	X509_EXTENSION	*san;
	uint8_t		 sanhdr[4], *data;
	int		 ext, santype, sanlen;
	char		 idstr[IKED_ID_SIZE];

	if ((ext = X509_get_ext_by_NID(cert,
	    NID_subject_alt_name, -1)) == -1 ||
	    ((san = X509_get_ext(cert, ext)) == NULL)) {
		log_debug("%s: did not find subjectAltName in certificate",
		    __func__);
		return (-1);
	}

	if (san->value == NULL || san->value->data == NULL ||
	    san->value->length < (int)sizeof(sanhdr)) {
		log_debug("%s: invalid subjectAltName in certificate",
		    __func__);
		return (-1);
	}

	/* This is partially based on isakmpd's x509 subjectaltname code */
	data = (uint8_t *)san->value->data;
	memcpy(&sanhdr, data, sizeof(sanhdr));
	santype = sanhdr[2] & 0x3f;
	sanlen = sanhdr[3];

	if ((sanlen + (int)sizeof(sanhdr)) > san->value->length) {
		log_debug("%s: invalid subjectAltName length", __func__);
		return (-1);
	}

	switch (santype) {
	case GEN_DNS:
		id->id_type = IKEV2_ID_FQDN;
		break;
	case GEN_EMAIL:
		id->id_type = IKEV2_ID_UFQDN;
		break;
	case GEN_IPADD:
		if (sanlen == 4)
			id->id_type = IKEV2_ID_IPV4;
		else if (sanlen == 16)
			id->id_type = IKEV2_ID_IPV6;
		else {
			log_debug("%s: invalid subjectAltName IP address",
			    __func__);
			return (-1);
		}
		break;
	default:
		log_debug("%s: unsupported subjectAltName type %d",
		    __func__, santype);
		return (-1);
	}

	ibuf_release(id->id_buf);
	if ((id->id_buf = ibuf_new(data + sizeof(sanhdr), sanlen)) == NULL) {
		log_debug("%s: failed to get id buffer", __func__);
		return (-1);
	}
	id->id_offset = 0;

	ikev2_print_id(id, idstr, sizeof(idstr));
	log_debug("%s: %s", __func__, idstr);

	return (0);
}

void
ca_sslinit(void)
{
	OpenSSL_add_all_algorithms();
	ERR_load_crypto_strings();

	/* Init hardware crypto engines. */
	ENGINE_load_builtin_engines();
	ENGINE_register_all_complete();
}

void
ca_sslerror(const char *caller)
{
	unsigned long	 error;

	while ((error = ERR_get_error()) != 0)
		log_warnx("%s: %s: %.100s", __func__, caller,
		    ERR_error_string(error, NULL));
}
@


1.43
log
@Add support for RFC4754 (ECDSA) and RFC7427 authentication.

These modes provide stronger and more flexible ways for
authentication: while RSA public key auth relies on SHA-1 hashes, the
news modes use SHA2-256 and up to SHA2-512 hashes.

Original diff from markus@@ with patches from mikeb@@ and me.

OK mikeb@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.42 2017/01/20 14:08:08 mikeb Exp $	*/
d1187 2
d1227 2
a1228 1
	    strlcat(file, idstr, sizeof(file)) >= sizeof(file))
d1230 1
d1232 2
a1233 1
	if ((fp = fopen(file, "r")) == NULL)
d1235 1
d1254 2
a1255 1
	if (!EVP_PKEY_cmp(peerkey, localkey))
d1257 1
@


1.42
log
@Make sure to free reference to the public key after decoding

From and OK markus@@, OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.41 2017/01/03 17:51:38 reyk Exp $	*/
d64 1
d86 2
d131 4
d333 12
a344 4
	/* switch encoding to IKEV2_AUTH_SIG if SHA2 is supported */
	if (sa->sa_sigsha2 && type == IKEV2_AUTH_RSA_SIG) {
		log_debug("%s: switching from RSA_SIG to SIG", __func__);
		type = IKEV2_AUTH_SIG;
d407 1
d458 1
a544 1
	policy.pol_auth.auth_method = method;
d550 2
d854 1
d864 1
d876 1
d882 22
d916 2
d925 1
d935 1
d947 1
d953 22
d987 2
d992 46
d1168 1
a1205 2
		if ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL)) == NULL)
			goto sslerr;
d1208 11
a1218 1
		if (!EVP_PKEY_set1_RSA(peerkey, peerrsa))
d1220 1
d1232 1
a1232 1
		/* reading PKCS #8 failed, try PEM */
d1265 2
@


1.41
log
@Fix pledge of the ca process by calling the right function on startup.
As a related change, load the local.pub and local.key keys after
privsep and reload them on SIGHUP/reload.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.40 2015/12/07 12:46:37 reyk Exp $	*/
d638 1
d782 1
d795 5
a799 2
	buflen = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x509), &buf);
	if (!buflen)
d1379 1
a1379 1
		log_warn("%s: %s: %.100s", __func__, caller,
@


1.40
log
@Sync proc.c, use shorter proc_compose[v]()
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.39 2015/10/22 15:55:18 reyk Exp $	*/
d50 1
a50 1
void	 ca_reset(struct privsep *, struct privsep_proc *, void *);
a67 2
int	 ca_privkey_serialize(EVP_PKEY *, struct iked_id *);
int	 ca_pubkey_serialize(EVP_PKEY *, struct iked_id *);
d90 1
a90 26
	struct ca_store	*store;
	FILE		*fp = NULL;
	EVP_PKEY	*key;

	/*
	 * This function runs code before privsep
	 */
	if ((store = calloc(1, sizeof(*store))) == NULL)
		fatal("ca: failed to allocate cert store");

	/* Read private key */
	if ((fp = fopen(IKED_PRIVKEY, "r")) == NULL)
		fatal("ca: failed to open private key");

	if ((key = PEM_read_PrivateKey(fp, NULL, NULL, NULL)) == NULL)
		fatalx("ca: failed to read private key");
	fclose(fp);

	if (ca_privkey_serialize(key, &store->ca_privkey) != 0)
		fatalx("ca: failed to serialize private key");
	if (ca_pubkey_serialize(key, &store->ca_pubkey) != 0)
		fatalx("ca: failed to serialize public key");

	EVP_PKEY_free(key);

	return (proc_run(ps, p, procs, nitems(procs), ca_reset, store));
d96 3
d108 33
a140 1
	ca_reset(ps, p, arg);
d144 1
a144 1
ca_reset(struct privsep *ps, struct privsep_proc *p, void *arg)
d147 5
a151 1
	struct ca_store	*store = arg;
a169 2
	env->sc_priv = store;

a177 1
	struct ca_store		*store = env->sc_priv;
d185 2
a186 2
			log_debug("%s: config reload", __func__);
			ca_reset(&env->sc_ps, p, store);
d194 4
@


1.39
log
@iked hereby pledges that it will run with restricted system
operations.  This adds pledge(2) too all processes, including the iked
parent process; the existing privsep design has been improved for
better pledgeability.  There haven't been any serious problems as it
was already sane (eg. by receiving the PFKEYv2 and UDP sockets via fd
passing).  The control socket moved to an independent process to
remove some abilities from the cert process.

Committed in agreement with many but nobody was brave enough to OK it.

Better testing will happen with having it in the tree.
"It's the truth" deraadt@@
"Let's see what happens" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.38 2015/10/19 11:25:35 reyk Exp $	*/
d252 1
a252 2
	if (proc_composev_imsg(&env->sc_ps, procid, -1,
	    IMSG_CERT, -1, iov, iovcnt) == -1)
d293 1
a293 2
	if (proc_composev_imsg(&env->sc_ps, procid, -1,
	    IMSG_CERTREQ, -1, iov, iovcnt) == -1)
d337 1
a337 2
	if (proc_composev_imsg(&env->sc_ps, id, -1,
	    IMSG_AUTH, -1, iov, iovcnt) == -1)
d397 1
a397 2
	if (proc_composev_imsg(&env->sc_ps, PROC_IKEV2, -1,
	    cmd, -1, iov, iovcnt) == -1)
d643 2
a644 2
		(void)proc_composev_imsg(&env->sc_ps, PROC_IKEV2, -1,
		    IMSG_CERTREQ, -1, iov, iovcnt);
d694 1
a694 2
	(void)proc_composev_imsg(&env->sc_ps, PROC_IKEV2, -1,
	    IMSG_CERTREQ, -1, iov, iovcnt);
@


1.38
log
@Remove the ikev1 stub - Since I started iked, it has an empty privsep
process for ISAKMP+IKEv1.  I kept it to let somebody either contribute
the old protocol one day, I never intended to implement IKEv1 myself,
or to add a new kind of pipe to isakmpd to hand off IKEv1 messages.
As IKEv2 is widely supported by all major OS and networking vendors
now, I'm happy to scrap the idea of supporting ISAKMP+IKEv1.  It is
still possible to use isakmpd for legacy VPNs.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.37 2015/10/01 10:59:23 reyk Exp $	*/
d49 1
d118 15
@


1.37
log
@Fix interoperability with Apple iOS9: If we don't get a (valid)
CERTREQ but a CERT, respond with a local CERT that was selected based
on our own policy instead of leaving it out.  This seems to be valid
with the RFC that makes the CERTREQ optional and allows to ignore it
or to apply an own policy.

OK mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.36 2015/08/21 11:59:27 reyk Exp $	*/
a69 1
int	 ca_dispatch_ikev1(int, struct privsep_proc *, struct imsg *);
a73 1
	{ "ikev1",	PROC_IKEV1,	ca_dispatch_ikev1 },
a174 6
}

int
ca_dispatch_ikev1(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	return (-1);
@


1.36
log
@Switch iked to C99-style fixed-width integer types.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.35 2015/03/26 19:52:35 markus Exp $	*/
d251 1
a251 1
ca_setreq(struct iked *env, struct iked_sahdr *sh,
d276 2
a277 2
	iov[iovcnt].iov_base = sh;
	iov[iovcnt].iov_len = sizeof(*sh);
d289 2
@


1.35
log
@initial support for RFC 7427 signatures, so we are no longer
restricted to SHA1 for RSA signatures. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.34 2015/02/06 10:39:01 deraadt Exp $	*/
d55 1
a55 1
X509	*ca_by_subjectpubkey(X509_STORE *, u_int8_t *, size_t);
d57 1
a57 1
int	 ca_subjectpubkey_digest(X509 *, u_int8_t *, u_int *);
d154 2
a155 2
	struct ca_store	*store = env->sc_priv;
	u_int			 mode;
d209 1
a209 1
    u_int8_t type, u_int8_t *data, size_t len, enum privsep_procid procid)
d252 1
a252 1
    struct iked_static_id *localid, u_int8_t type, u_int8_t *data,
d303 1
a303 1
	u_int8_t		 type = policy->pol_auth.auth_method;
d339 2
a340 2
	u_int8_t		 type;
	u_int8_t		*ptr;
d343 1
a343 1
	u_int			 i;
d347 1
a347 1
	ptr = (u_int8_t *)imsg->data;
d357 1
a357 1
	memcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(u_int8_t));
d399 1
a399 1
	struct ca_store	*store = env->sc_priv;
d401 2
a402 2
	u_int8_t		 type;
	u_int8_t		*ptr;
d404 1
a404 1
	u_int			 i, n;
d409 1
a409 1
	ptr = (u_int8_t *)imsg->data;
d411 1
a411 1
	i = sizeof(id) + sizeof(u_int8_t) + sizeof(sh);
d419 1
a419 1
	memcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(u_int8_t));
d473 1
a473 1
	struct ca_store	*store = env->sc_priv;
d475 2
a476 2
	u_int8_t		 method;
	u_int8_t		*ptr;
d478 1
a478 1
	u_int			 i;
d485 1
a485 1
	ptr = (u_int8_t *)imsg->data;
d492 1
a492 1
	memcpy(&method, ptr + sizeof(sh), sizeof(u_int8_t));
d533 1
a533 1
	u_int8_t		 md[EVP_MAX_MD_SIZE];
d695 1
a695 1
ca_by_subjectpubkey(X509_STORE *ctx, u_int8_t *sig, size_t siglen)
d701 2
a702 2
	u_int			 len;
	u_int8_t		 md[EVP_MAX_MD_SIZE];
d761 1
a761 1
ca_subjectpubkey_digest(X509 *x509, u_int8_t *md, u_int *size)
d763 1
a763 1
	u_int8_t	*buf = NULL;
d792 1
a792 1
	u_int8_t	*d = NULL;
d813 1
a813 1
	u_int8_t	*d;
d857 1
a857 1
	u_int8_t	*d;
d898 1
a898 1
ca_asn1_name(u_int8_t *asn1, size_t len)
d902 1
a902 1
	const u_int8_t	*p;
d1217 1
a1217 1
	const u_int8_t	*idptr;
d1272 1
a1272 1
	u_int8_t	 sanhdr[4], *data;
d1292 1
a1292 1
	data = (u_int8_t *)san->value->data;
d1353 1
a1353 1
	u_long		 error;
@


1.34
log
@unneeded getopt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.33 2015/01/16 06:39:58 deraadt Exp $	*/
d304 6
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.32 2014/12/05 07:24:45 mikeb Exp $	*/
a28 1
#include <getopt.h>
@


1.32
log
@Specify correct number of iovecs when sending replies to the ikev2 proc

Crash reported and fix tested by Vincent Gross <dermiste at kilob ! yt>;
patch from Pedro Martelletto, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.31 2014/07/10 12:50:05 jsg Exp $	*/
a18 1
#include <sys/param.h>
d1026 1
a1026 1
	char		 file[MAXPATHLEN];
@


1.31
log
@add additional includes required to build with -DOPENSSL_NO_DEPRECATED
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.30 2014/05/07 12:57:13 markus Exp $	*/
d537 1
a537 1
	int			 i, len, iovcnt = 2;
d623 1
d626 1
d682 2
@


1.30
log
@make authentication work with X509 certificates that don't have a
subject-altname, i.e. support IKEV2_ID_ASN1_DN correctly;
feedback & ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.29 2014/05/05 18:56:42 markus Exp $	*/
d46 1
@


1.29
log
@ca_x509_serialize: don't leak the bio buffer; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.28 2014/05/05 18:54:17 markus Exp $	*/
d59 1
d735 10
a744 3
			if (ca_x509_subjectaltname_cmp(cert, id) != 0)
				continue;
			return (cert);
d917 95
d1122 1
a1122 3
	size_t		 idlen, idoff;
	const u_int8_t	*idptr;
	X509_NAME	*idname = NULL, *subject;
d1151 1
a1151 11
			idoff = id->id_offset;
			if (id->id_length <= idoff) {
				errstr = "invalid ASN1_DN id length";
				goto done;
			}
			idlen = id->id_length - idoff;
			idptr = id->id_data + idoff;

			if ((idname = d2i_X509_NAME(NULL,
			    &idptr, idlen)) == NULL ||
			    X509_NAME_cmp(subject, idname) != 0) {
a1193 2
	if (idname != NULL)
		X509_NAME_free(idname);
d1200 25
@


1.28
log
@make the ca_pubkey_serialize() code similar to the private key code, and
fixes a leak of the rsa object in the error case. from hshoexer@@; ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.27 2014/04/22 12:00:03 reyk Exp $	*/
d787 1
@


1.27
log
@Update iked to use the same proc.c that relayd uses.
Less differences, less code to audit.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.26 2014/02/17 15:07:23 markus Exp $	*/
d794 1
a794 2
	RSA		*rsa;
	BIO		*out = NULL;
d807 1
a807 1
		if ((out = BIO_new(BIO_s_mem())) == NULL)
d809 1
a809 1
		if (!i2d_RSAPublicKey_bio(out, rsa))
d812 3
a814 2
		len = BIO_get_mem_data(out, &d);
		if ((id->id_buf = ibuf_new(d, len)) == NULL)
d816 1
d830 2
a831 2
	if (out != NULL)
		BIO_free(out);
d838 1
a838 1
	RSA		*rsa;
d841 1
d850 1
a850 1
			return (-1);
d852 1
a852 1
			return (-1);
d854 1
a854 1
			return (-1);
d859 1
a859 1
			return (-1);
d872 5
a876 1
	return (0);
@


1.26
log
@basic OCSP support. enable with 'set ocsp "http://10.0.0.10:8888/"'
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.25 2014/02/17 11:00:14 reyk Exp $	*/
d50 1
a50 1
void	 ca_reset(struct privsep *, void *);
d122 1
a122 1
ca_reset(struct privsep *ps, void *arg)
d163 1
a163 1
			ca_reset(&env->sc_ps, store);
d244 2
a245 1
	if (proc_composev_imsg(env, procid, IMSG_CERT, -1, iov, iovcnt) == -1)
d286 1
a286 1
	if (proc_composev_imsg(env, procid,
d323 2
a324 1
	if (proc_composev_imsg(env, id, IMSG_AUTH, -1, iov, iovcnt) == -1)
d384 2
a385 1
	if (proc_composev_imsg(env, PROC_IKEV2, cmd, -1, iov, iovcnt) == -1)
d629 2
a630 2
		(void)proc_composev_imsg(env, PROC_IKEV2, IMSG_CERTREQ, -1,
		    iov, iovcnt);
d678 2
a679 2
	(void)proc_composev_imsg(env, PROC_IKEV2, IMSG_CERTREQ, -1,
	    iov, iovcnt);
@


1.25
log
@Fix compiler warnings in the format strings: use %zd for ssize_t and
%zu for size_t.

From Andre de Oliveira
With input and OK from blambert@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.24 2013/11/28 20:21:17 markus Exp $	*/
d166 6
d357 5
@


1.24
log
@support raw pubkey authentication w/o x509 certificates;
mostly by Michael Cardell Widerkrantz, reyk@@ and mikeb@@; ok mike@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.23 2013/11/14 12:38:20 markus Exp $	*/
d313 1
a313 1
		log_debug("%s: auth length %d", __func__, ibuf_size(authmsg));
d610 1
a610 1
		log_debug("%s: loaded %d ca certificate%s", __func__,
@


1.23
log
@pass caller to ca_sslerror for better error messages; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.22 2013/03/21 04:30:14 deraadt Exp $	*/
d67 2
a68 1
int	 ca_key_serialize(EVP_PKEY *, struct iked_id *);
d87 1
d103 1
d111 1
a111 1
	if (ca_key_serialize(key, &store->ca_privkey) != 0)
d113 4
a399 2
	if (type != IKEV2_CERT_X509_CERT)
		return (-1);
d401 14
a414 7
	for (n = 1; i < len; n++, i += SHA_DIGEST_LENGTH) {
		if ((ca = ca_by_subjectpubkey(store->ca_cas,
		    ptr + i, SHA_DIGEST_LENGTH)) == NULL) {
			log_debug("%s: CA %d not found", __func__, n);
			print_hex(ptr, i, SHA_DIGEST_LENGTH);
			continue;
		}
d416 1
a416 1
		log_debug("%s: found CA %s", __func__, ca->name);
d418 14
a431 4
		if ((cert = ca_by_issuer(store->ca_certs,
		    X509_get_subject_name(ca), &id)) != NULL) {
			/* XXX should we re-validate our own cert here? */
			break;
d433 2
d436 6
a441 1
		log_debug("%s: no valid certificate for this CA", __func__);
a442 8
	if (ca == NULL || cert == NULL) {
		log_warnx("%s: no valid local certificate found", __func__);
		type = IKEV2_CERT_NONE;
		ca_setcert(env, &sh, NULL, type, NULL, 0, PROC_IKEV2);
		return (0);
	}

	log_debug("%s: found local certificate %s", __func__, cert->name);
a443 4
	if ((buf = ca_x509_serialize(cert)) == NULL)
		return (-1);

	type = IKEV2_CERT_X509_CERT;
d512 4
a515 2
	struct ca_store	*store = env->sc_priv;
	DIR			*dir;
a516 1
	char			 file[PATH_MAX];
d520 2
a521 4
	int			 i, len;
	u_int8_t		 md[EVP_MAX_MD_SIZE];
	struct iovec		 iov[2];
	int			 iovcnt = 2;
d656 11
d778 1
a778 1
ca_key_serialize(EVP_PKEY *key, struct iked_id *id)
d780 2
a781 1
	int		 len;
d783 40
d824 2
d853 3
d893 1
a893 1
	RSA		*rsa = NULL;
d931 1
a931 1
		if ((rsa = d2i_RSAPublicKey_bio(rawcert, NULL)) == NULL)
d935 1
a935 1
		if (!EVP_PKEY_set1_RSA(peerkey, rsa))
d941 1
a941 1
	    strlcpy(file, idstr, sizeof(file)) >= sizeof(file))
a943 2
	log_debug("%s: looking up %s", __func__, file);

a945 1

d947 14
a960 1
	fclose(fp);
d967 2
d977 6
a982 2
	if (rsa != NULL)
		RSA_free(rsa);
d1023 1
a1023 1
			errstr = "public key found, ok";
d1076 1
d1080 1
a1080 2
		log_debug("%s: %s %.100s", __func__, cert->name,
		    ret == 0 ? "ok" : errstr);
@


1.22
log
@remove excessive includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.21 2013/01/08 10:38:19 reyk Exp $	*/
d526 1
a526 1
			ca_sslerror();
d552 1
a552 1
			ca_sslerror();
d622 1
a622 1
			ca_sslerror();
d887 1
a887 1
		ca_sslerror();
d1118 1
a1118 1
ca_sslerror(void)
d1123 1
a1123 1
		log_warn("%s: %.100s", __func__,
@


1.21
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.20 2012/11/16 14:39:00 mikeb Exp $	*/
a19 1
#include <sys/types.h>
@


1.20
log
@promote some debug messages to warnings; ok reyk
@
text
@d1 1
a1 2
/*	$OpenBSD: ca.c,v 1.19 2012/10/09 13:43:31 reyk Exp $	*/
/*	$vantronix: ca.c,v 1.29 2010/06/02 12:22:58 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.19
log
@"If srcid is omitted, the default is to use the hostname of the local
machine." This has been broken when the subjectAltName certificate
check was introduced some time ago.  Fix it by obtaining the hostname
source Id in the certificate request code as well.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.18 2012/09/18 12:07:59 reyk Exp $	*/
d526 1
a526 1
			log_debug("%s: failed to load ca file %s", __func__,
d552 1
a552 1
			log_debug("%s: failed to load crl file %s", __func__,
d622 1
a622 1
			log_debug("%s: failed to load cert file %s", __func__,
@


1.18
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.17 2011/05/27 12:01:02 reyk Exp $	*/
d251 1
a251 1
	if (ikev2_policy2id(localid, &id, 0) != 0)
@


1.17
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.16 2011/05/09 11:15:18 reyk Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.16
log
@rename functions in proc.c to proc_* and move some code from imsg_util.c to
proc.c.  this is the first sync to what i did for relayd but does not include
the multi-instance handling - so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.15 2011/05/05 12:59:31 reyk Exp $	*/
d981 1
a981 1
 	if (!result) {
@


1.15
log
@Small tweak - add direct pointer to env instead of using an indirect one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.14 2011/05/05 12:55:52 reyk Exp $	*/
d113 1
a113 1
	return (run_proc(ps, p, procs, nitems(procs), ca_reset, store));
d233 1
a233 1
	if (imsg_composev_proc(env, procid, IMSG_CERT, -1, iov, iovcnt) == -1)
d274 1
a274 1
	if (imsg_composev_proc(env, procid,
d311 1
a311 1
	if (imsg_composev_proc(env, id, IMSG_AUTH, -1, iov, iovcnt) == -1)
d366 1
a366 1
	if (imsg_composev_proc(env, PROC_IKEV2, cmd, -1, iov, iovcnt) == -1)
d601 1
a601 1
		(void)imsg_composev_proc(env, PROC_IKEV2, IMSG_CERTREQ, -1,
@


1.14
log
@Move the proc.c-specific runtime state out of struct iked into a sub-struct.
This removes iked-specific stuff from proc.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.13 2011/05/05 12:17:10 reyk Exp $	*/
d148 1
a148 1
	struct iked		*env = p->p_ps->ps_env;
d177 1
a177 1
	struct iked	*env = p->p_ps->ps_env;
@


1.13
log
@rename iked_proc* to privsep_proc*.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.12 2010/12/22 17:53:54 reyk Exp $	*/
d52 1
a52 1
void	 ca_reset(struct iked *, void *);
d91 1
a91 1
caproc(struct iked *env, struct privsep_proc *p)
d113 1
a113 1
	return (run_proc(env, p, procs, nitems(procs), ca_reset, store));
d117 1
a117 1
ca_reset(struct iked *env, void *arg)
d119 1
d148 1
a148 1
	struct iked		*env = p->env;
d158 1
a158 1
			ca_reset(env, store);
d177 1
a177 1
	struct iked	*env = p->env;
@


1.12
log
@move and rename util.c:print_id() to ikev2.c:ikev2_print_id() because
it is too specific to be in util.c.  This will allow to link util.c
into ikectl later without all the other dependencies of pritn_id().
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.11 2010/09/30 14:25:54 mikeb Exp $	*/
d70 3
a72 3
int	 ca_dispatch_parent(int, struct iked_proc *, struct imsg *);
int	 ca_dispatch_ikev1(int, struct iked_proc *, struct imsg *);
int	 ca_dispatch_ikev2(int, struct iked_proc *, struct imsg *);
d74 1
a74 1
static struct iked_proc procs[] = {
d91 1
a91 1
caproc(struct iked *env, struct iked_proc *p)
d145 1
a145 1
ca_dispatch_parent(int fd, struct iked_proc *p, struct imsg *imsg)
d168 1
a168 1
ca_dispatch_ikev1(int fd, struct iked_proc *p, struct imsg *imsg)
d174 1
a174 1
ca_dispatch_ikev2(int fd, struct iked_proc *p, struct imsg *imsg)
d197 1
a197 1
    u_int8_t type, u_int8_t *data, size_t len, enum iked_procid procid)
d240 1
a240 1
    size_t len, enum iked_procid procid)
d285 1
a285 1
    struct ibuf *authmsg, enum iked_procid id)
@


1.11
log
@promote openssl errors to the warning level; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.10 2010/06/29 21:04:42 reyk Exp $	*/
d849 1
a849 1
	if (print_id(&idp, idstr, sizeof(idstr)) == -1)
d1017 1
a1017 1
	print_id(&sanid, idstr, sizeof(idstr));
d1101 1
a1101 1
	print_id(id, idstr, sizeof(idstr));
@


1.10
log
@add code to lookup the RSA public keys in /etc/iked/pubkeys/ as an
alternative to X.509 CA verification.  this will be needed to support public
key authentication like isakmpd does;  a few bits are still missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.9 2010/06/27 05:49:05 reyk Exp $	*/
a1121 4
	extern int 	 verbose;

	if (verbose < 3)
		return;
d1124 1
a1124 1
		log_debug("%s: %.100s", __func__,
@


1.9
log
@When a peer requests a certificate from the local gateway, we first
lookup a cert from /etc/iked/certs/ that is signed by a requested CA.
As a second step we also compare the subjectAltName of any found
certificate now to match the local srcid; this allows to have multiple
certs for the same CA but different srcids in the certs/ directory but
enforces that the subjectAltName has to be set correctly.

requested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.8 2010/06/27 01:37:56 reyk Exp $	*/
d61 2
d325 1
a325 1
	int			 iovcnt = 2, cmd;
a337 2
	if (type != IKEV2_CERT_X509_CERT)
		return (-1);
d342 14
a355 1
	if (ca_validate_cert(env, &id, ptr, len) == 0)
d817 85
d933 6
@


1.8
log
@fix the length check for ASN1_ID Ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.7 2010/06/27 01:11:09 reyk Exp $	*/
d59 1
a59 1
X509	*ca_by_issuer(X509_STORE *, X509_NAME *);
d65 1
d236 3
a238 2
ca_setreq(struct iked *env, struct iked_sahdr *sh, u_int8_t type,
    u_int8_t *data, size_t len, enum iked_procid id)
d240 30
a269 2
	struct iovec		iov[3];
	int			iovcnt = 3;
d271 3
a273 6
	iov[0].iov_base = sh;
	iov[0].iov_len = sizeof(*sh);
	iov[1].iov_base = &type;
	iov[1].iov_len = sizeof(type);
	iov[2].iov_base = data;
	iov[2].iov_len = len;
d275 4
a278 3
	if (imsg_composev_proc(env, id, IMSG_CERTREQ, -1, iov, iovcnt) == -1)
		return (-1);
	return (0);
d368 1
d372 1
a372 1
	i = sizeof(u_int8_t) + sizeof(sh);
d376 5
a380 2
	memcpy(&sh, ptr, sizeof(sh));
	memcpy(&type, ptr + sizeof(sh), sizeof(u_int8_t));
d395 1
a395 1
		    X509_get_subject_name(ca))) != NULL) {
d660 1
a660 1
ca_by_issuer(X509_STORE *ctx, X509_NAME *subject)
d680 3
a682 1
		else if (X509_NAME_cmp(subject, issuer) == 0)
d684 1
a814 1
	struct iked_id	 sanid;
a815 3
	char		 idstr[IKED_ID_SIZE];

	bzero(&sanid, sizeof(sanid));
d853 2
a854 20
			if (ca_x509_subjectaltname(cert, &sanid) != 0) {
				errstr = "missing subjectAltName extension";
				goto done;
			}

			print_id(&sanid, idstr, sizeof(idstr));

			/* Compare id types, length and data */
			if ((id->id_type != sanid.id_type) ||
			    ((ssize_t)ibuf_size(sanid.id_buf) !=
			    (id->id_length - id->id_offset)) ||
			    (memcmp(id->id_data + id->id_offset,
			    ibuf_data(sanid.id_buf),
			    ibuf_size(sanid.id_buf)) != 0)) {
				log_debug("%s: subjectAltName %s is not %s/%s",
				    __func__, idstr,
				    print_map(id->id_type, ikev2_id_map),
				    id->id_data + id->id_offset);

				errstr = "subjectAltName mismatch";
a889 1
	ibuf_release(sanid.id_buf);
d898 31
@


1.7
log
@Verify that the subjectAltName extension is present and matches the
peer Id if the Id type is not ASN1_DN.  If it is ASN1_DN, compare it
with the certificate subjectName (DN).  This prevents the peer from
using an arbitrary peer Id (it is signed by the CA in the cert) and
qualifies the optional pf tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.6 2010/06/26 18:32:34 reyk Exp $	*/
d807 2
a808 1
			if (id->id_length > idoff)
d810 1
@


1.6
log
@Include the Id type in the generated SA tag that is passed to the
kernel, just like isakmpd does it.  In difference to isakmpd, the Id
type is printed in capital letters, eg. FQDN/foo.example.com, because
it is using the existing print_map() API.  For consistency, rename a
few Id types in grammar and code from the RFC-names to the
OpenBSD-style names; including RFC822_ADDR to UFQDN, IPV4_ADDR to just
IPV4, DER_ASN1_DN to ASN1_DN etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.5 2010/06/24 20:15:30 reyk Exp $	*/
d65 1
a66 1

d777 8
d797 49
d856 4
d861 1
a861 4
	log_debug("%s: %s %.100s", __func__, cert->name,
	    error == 0 ? "ok" : X509_verify_cert_error_string(error));

	if (!result) {
d863 1
a863 1
		ret = -1;
a866 5
	if (id != NULL) {
		/* compare the id with the certificate CN or subjectAltName */
		/* XXX */
	}

d871 7
d885 71
@


1.5
log
@unbreak the ikectl log verbose/brief commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.4 2010/06/11 10:15:31 jsg Exp $	*/
d209 1
d713 1
@


1.4
log
@tweak the code slightly so we can remove -lssl

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.3 2010/06/10 14:09:19 jsg Exp $	*/
d68 1
d73 1
d156 1
a156 1
		return (0);
d158 1
a158 1
		break;
d161 6
@


1.3
log
@move a bzero of the x509 store context higher up so the
cert validation does something useful.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.2 2010/06/10 08:29:47 reyk Exp $	*/
d821 1
a821 1
	SSL_load_error_strings();
@


1.2
log
@i don't like splitting source code in too many source files but ikev2.c
has grown too large, so split it in 3 files and rename a few functions
to organize the code a bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ca.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
d779 1
a785 1
	bzero(&csc, sizeof(csc));
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d255 1
a255 1
		return (ikev2_message_authsign(env, sa,
d426 1
a426 1
	if (ikev2_message_authsign(env, &sa, &policy.pol_auth, authmsg) != 0) {
@

