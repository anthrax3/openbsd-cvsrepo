head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.6
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.25
date	2016.03.16.08.34.11;	author natano;	state Exp;
branches;
next	1.24;
commitid	AWIqmxqubloftaTs;

1.24
date	2016.03.14.20.30.34;	author natano;	state Exp;
branches;
next	1.23;
commitid	TeeZuuQxYniC1tdh;

1.23
date	2016.03.14.20.14.30;	author natano;	state Exp;
branches;
next	1.22;
commitid	Kmrc1675R20HF8Yj;

1.22
date	2015.12.06.11.56.47;	author tobias;	state Exp;
branches;
next	1.21;
commitid	2CO2sgsumCvf1pCb;

1.21
date	2015.11.28.06.12.09;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	8TqdF8kIFaXX2ELx;

1.20
date	2015.11.26.06.59.12;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	lB6sMnhYIPjrEMi4;

1.19
date	2015.11.26.06.45.08;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	8ulWnR5i8S3xVGmC;

1.18
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Cz19p5I1S6mVZIjV;

1.17
date	2015.10.14.15.54.49;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	0VAb8oakXKy0rP2Z;

1.16
date	2015.10.13.15.15.30;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	zsmA6OHfkN1DqE6P;

1.15
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.13;
commitid	HIbf8HnT4wFtIrOp;

1.13
date	2014.06.29.00.32.50;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	AwAbrIl5vuYQ7v3F;

1.12
date	2014.05.21.06.23.01;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.22.00.23.35;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.21.09.22.15;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.22.04.14.01;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.27.18.54.03;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2012.12.04.02.27.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.18.07.58.14;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.17.19.26.10;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.16.12.25.35;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.16.08.29.50;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.16.08.25.55;	author otto;	state Exp;
branches;
next	;


desc
@@


1.25
log
@There's no reason to have execute permissions on a file system image.

ok millert
@
text
@/* $OpenBSD: newfs_ext2fs.c,v 1.24 2016/03/14 20:30:34 natano Exp $ */
/*	$NetBSD: newfs_ext2fs.c,v 1.8 2009/03/02 10:38:13 tsutsui Exp $	*/

/*
 * Copyright (c) 1983, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * newfs: friendly front end to mke2fs
 */
#include <sys/param.h>	/* powerof2 */
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/disklabel.h>
#include <sys/mount.h>

#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_dinode.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <limits.h>
#include <paths.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#include "extern.h"

static int64_t strsuftoi64(const char *, const char *, int64_t, int64_t, int *);
static void usage(void) __dead;

/*
 * For file systems smaller than SMALL_FSSIZE we use the S_DFL_* defaults,
 * otherwise if less than MEDIUM_FSSIZE use M_DFL_*, otherwise use
 * L_DFL_*.
 */
#define SMALL_FSSIZE	((4 * 1024 * 1024) / sectorsize)	/* 4MB */
#define S_DFL_BSIZE	1024
#define MEDIUM_FSSIZE	((512 * 1024 * 1024) / sectorsize)	/* 512MB */
#define M_DFL_BSIZE	1024
#define L_DFL_BSIZE	4096

/*
 * Each file system has a number of inodes statically allocated.
 * We allocate one inode slot per 2, 4, or 8 blocks, expecting this
 * to be far more than we will ever need.
 */
#define S_DFL_NINODE(blocks)	((blocks) / 8)
#define M_DFL_NINODE(blocks)	((blocks) / 4)
#define L_DFL_NINODE(blocks)	((blocks) / 2)

/*
 * Default sector size.
 */
#define	DFL_SECSIZE	512

int	Nflag;			/* run without writing file system */
int	Oflag = 0;		/* format as conservative REV0 by default */
int	verbosity;		/* amount of printf() output */
#define DEFAULT_VERBOSITY 4	/* 4 is traditional behavior of newfs(8) */
int64_t fssize;			/* file system size */
uint	sectorsize;		/* bytes/sector */
uint16_t inodesize = EXT2_REV0_DINODE_SIZE;	/* inode size */
uint	fsize = 0;		/* fragment size */
uint	bsize = 0;		/* block size */
uint	minfree = MINFREE;	/* free space threshold */
uint	density;		/* number of bytes per inode */
uint	num_inodes;		/* number of inodes (overrides density) */
int	max_cols;
char	*volname = NULL;	/* volume name */

static char *disktype = NULL;

struct disklabel *getdisklabel(const char *, int);
struct partition *getpartition(int, const char *, char *[], struct disklabel **);

int
main(int argc, char *argv[])
{
	struct statfs *mp;
	struct stat sb;
	int ch, fd, len, n, Fflag, Iflag, Zflag;
	char *s1, *s2, *special;
	const char *opstring;
	int byte_sized, fl;
	uint blocks;			/* number of blocks */
	struct partition *pp = NULL;
	struct disklabel *lp;
	struct winsize winsize;

	/* Get terminal width */
	if (ioctl(fileno(stdout), TIOCGWINSZ, &winsize) == 0)
		max_cols = winsize.ws_col;
	else
		max_cols = 80;

	if (pledge("stdio rpath wpath cpath disklabel", NULL) == -1)
		err(1, "pledge");

	Fflag = Iflag = Zflag = 0;
	verbosity = -1;
	opstring = "D:FINO:S:V:Zb:f:i:l:m:n:qs:t:v:";
	byte_sized = 0;
	while ((ch = getopt(argc, argv, opstring)) != -1)
		switch (ch) {
		case 'D':
			inodesize = (uint16_t)strtol(optarg, &s1, 0);
			if (*s1 || (inodesize != 128 && inodesize != 256))
				errx(1, "Bad inode size %d "
				    "(only 128 and 256 supported)", inodesize);
			break;
		case 'F':
			Fflag = 1;
			break;
		case 'I':
			Iflag = 1;
			break;
		case 'N':
			Nflag = 1;
			if (verbosity == -1)
				verbosity = DEFAULT_VERBOSITY;
			break;
		case 'O':
			Oflag = strsuftoi64("format", optarg, 0, 1, NULL);
			break;
		case 'S':
			/*
			 * XXX:
			 * non-512 byte sectors almost certainly don't work.
			 */
			sectorsize = strsuftoi64("sector size",
			    optarg, 512, 65536, NULL);
			if (!powerof2(sectorsize))
				errx(EXIT_FAILURE,
				    "sector size `%s' is not a power of 2.",
				    optarg);
			break;
		case 'V':
			verbosity = strsuftoi64("verbose", optarg, 0, 4, NULL);
			break;
		case 'Z':
			Zflag = 1;
			break;
		case 'b':
			bsize = strsuftoi64("block size",
			    optarg, MINBSIZE, EXT2_MAXBSIZE, NULL);
			break;
		case 'f':
			fsize = strsuftoi64("fragment size",
			    optarg, MINBSIZE, EXT2_MAXBSIZE, NULL);
			break;
		case 'i':
			density = strsuftoi64("bytes per inode",
			    optarg, 1, INT_MAX, NULL);
			break;
		case 'm':
			minfree = strsuftoi64("free space %",
			    optarg, 0, 99, NULL);
			break;
		case 'n':
			num_inodes = strsuftoi64("number of inodes",
			    optarg, 1, INT_MAX, NULL);
			break;
		case 'q':
			verbosity = 1;
			break;
		case 's':
			fssize = strsuftoi64("file system size",
			    optarg, INT64_MIN, INT64_MAX, &byte_sized);
			break;
		case 't':
			/* compat with newfs -t */
			break;
		case 'v':
			volname = optarg;
			if (volname[0] == '\0')
				errx(EXIT_FAILURE,
				    "Volume name cannot be zero length");
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (verbosity == -1)
		/* Default to showing cg info */
		verbosity = DEFAULT_VERBOSITY;

	if (argc != 1)
		usage();

	memset(&sb, 0, sizeof(sb));
	special = argv[0];
	fl = Nflag ? O_RDONLY : O_RDWR;

	if (Fflag) {
		/*
		 * It's a file system image
		 * no label, use fixed default for sectorsize.
		 */
		if (sectorsize == 0)
			sectorsize = DFL_SECSIZE;

		/* creating image in a regular file */
		if (!Nflag && fssize > 0)
			fl |= O_CREAT;
		fd = open(special, fl, 0666);
		if (fd == -1)
			err(EXIT_FAILURE, "can't open file %s", special);
		if (fstat(fd, &sb) == -1)
			err(EXIT_FAILURE, "can't fstat opened %s", special);
	} else {	/* !Fflag */
		fd = opendev(special, fl, 0, &special);
		if (fd < 0 || fstat(fd, &sb) == -1)
			err(EXIT_FAILURE, "%s: open", special);

		if (!Nflag) {
			/* Bail if target special is mounted */
			n = getmntinfo(&mp, MNT_NOWAIT);
			if (n == 0)
				err(EXIT_FAILURE, "%s: getmntinfo", special);

			len = sizeof(_PATH_DEV) - 1;
			s1 = special;
			if (strncmp(_PATH_DEV, s1, len) == 0)
				s1 += len;

			while (--n >= 0) {
				s2 = mp->f_mntfromname;
				if (strncmp(_PATH_DEV, s2, len) == 0) {
					s2 += len - 1;
					*s2 = 'r';
				}
				if (strcmp(s1, s2) == 0 ||
				    strcmp(s1, &s2[1]) == 0)
					errx(EXIT_FAILURE,
					    "%s is mounted on %s",
					    special, mp->f_mntonname);
				++mp;
			}
		}

		pp = getpartition(fd, special, argv, &lp);
		if (!Iflag) {
			static const char m[] =
			    "%s partition type is not `%s' (or use -I)";
			if (pp->p_fstype != FS_EXT2FS)
				errx(EXIT_FAILURE, m, special, "ext2fs");
		}
		if (sectorsize == 0) {
			sectorsize = lp->d_secsize;
			if (sectorsize <= 0)
				errx(EXIT_FAILURE, "no default sector size");
		}
	}

	if (byte_sized)
		fssize /= sectorsize;
	if (fssize <= 0) {
		if (sb.st_size != 0)
			fssize += sb.st_size / sectorsize;
		else if (pp)
			fssize += DL_GETPSIZE(pp);
		if (fssize <= 0)
			errx(EXIT_FAILURE,
			    "Unable to determine file system size");
	}

	/* XXXLUKEM: only ftruncate() regular files ? (dsl: or at all?) */
	if (Fflag && !Nflag
	    && ftruncate(fd, (off_t)fssize * sectorsize) == -1)
		err(1, "can't ftruncate %s to %" PRId64, special, fssize);

	if (Zflag && !Nflag) {	/* pre-zero (and de-sparce) the file */
		char *buf;
		int bufsize, i;
		off_t bufrem;
		struct statfs sfs;

		if (fstatfs(fd, &sfs) == -1) {
			warn("can't fstatvfs `%s'", special);
			bufsize = 8192;
		} else
			bufsize = sfs.f_iosize;

		if ((buf = calloc(1, bufsize)) == NULL)
			err(1, "can't allocate buffer of %d",
			bufsize);
		bufrem = fssize * sectorsize;
		if (verbosity > 0)
			printf("Creating file system image in `%s', "
			    "size %" PRId64 " bytes, in %d byte chunks.\n",
			    special, bufrem, bufsize);
		while (bufrem > 0) {
			i = write(fd, buf, MINIMUM(bufsize, bufrem));
			if (i == -1)
				err(1, "writing image");
			bufrem -= i;
		}
		free(buf);
	}

	/* Sort out fragment and block sizes */
	if (bsize == 0) {
		bsize = fsize;
		if (bsize == 0) {
			if (fssize < SMALL_FSSIZE)
				bsize = S_DFL_BSIZE;
			else if (fssize < MEDIUM_FSSIZE)
				bsize = M_DFL_BSIZE;
			else
				bsize = L_DFL_BSIZE;
		}
	}
	if (fsize == 0)
		fsize = bsize;

	blocks = fssize * sectorsize / bsize;

	if (num_inodes == 0) {
		if (density != 0)
			num_inodes = fssize / density;
		else {
			if (fssize < SMALL_FSSIZE)
				num_inodes = S_DFL_NINODE(blocks);
			else if (fssize < MEDIUM_FSSIZE)
				num_inodes = M_DFL_NINODE(blocks);
			else
				num_inodes = L_DFL_NINODE(blocks);
		}
	}
	mke2fs(special, fd);

	close(fd);
	exit(EXIT_SUCCESS);
}

static int64_t
strsuftoi64(const char *desc, const char *arg, int64_t min, int64_t max,
    int *num_suffix)
{
	int64_t result, r1;
	int shift = 0;
	char *ep;

	errno = 0;
	r1 = strtoll(arg, &ep, 10);
	if (ep[0] != '\0' && ep[1] != '\0')
		errx(EXIT_FAILURE,
		    "%s `%s' is not a valid number.", desc, arg);
	switch (ep[0]) {
	case '\0':
	case 's':
	case 'S':
		if (num_suffix != NULL)
			*num_suffix = 0;
		break;
	case 'g':
	case 'G':
		shift += 10;
		/* FALLTHROUGH */
	case 'm':
	case 'M':
		shift += 10;
		/* FALLTHROUGH */
	case 'k':
	case 'K':
		shift += 10;
		/* FALLTHROUGH */
	case 'b':
	case 'B':
		if (num_suffix != NULL)
			*num_suffix = 1;
		break;
	default:
		errx(EXIT_FAILURE,
		    "`%s' is not a valid suffix for %s.", ep, desc);
	}
	result = r1 << shift;
	if (errno == ERANGE || result >> shift != r1)
		errx(EXIT_FAILURE,
		    "%s `%s' is too large to convert.", desc, arg);
	if (result < min)
		errx(EXIT_FAILURE,
		    "%s `%s' (%" PRId64 ") is less than the minimum (%"
		    PRId64 ").", desc, arg, result, min);
	if (result > max)
		errx(EXIT_FAILURE,
		    "%s `%s' (%" PRId64 ") is greater than the maximum (%"
		    PRId64 ").", desc, arg, result, max);
	return result;
}

static const char help_strings[] =
	"\t-b bsize\tblock size\n"
	"\t-D inodesize\tsize of an inode in bytes (128 or 256)\n"
	"\t-F \t\tcreate file system image in regular file\n"
	"\t-f fsize\tfragment size\n"
	"\t-I \t\tdo not check that the file system type is `ext2fs'\n"
	"\t-i density\tnumber of bytes per inode\n"
	"\t-m minfree\tminimum free space %\n"
	"\t-N \t\tdo not create file system, just print out parameters\n"
	"\t-n inodes\tnumber of inodes (overrides -i density)\n"
	"\t-O N\t\tfilesystem revision: 0 ==> REV0, 1 ==> REV1 (default 0)\n"
	"\t-S secsize\tsector size\n"
	"\t-s fssize\tfile system size (sectors)\n"
	"\t-V verbose\toutput verbosity: 0 ==> none, 4 ==> max\n"
	"\t-v volname\text2fs volume name\n"
	"\t-Z \t\tpre-zero the image file\n";

static void
usage(void)
{

	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [ fsoptions ] special-device\n", __progname);
	fprintf(stderr, "where fsoptions are:\n");
	fprintf(stderr, "%s", help_strings);

	exit(EXIT_FAILURE);
}

struct disklabel *
getdisklabel(const char *s, int fd)
{
	static struct disklabel lab;

	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
		if (disktype != NULL) {
			struct disklabel *lp;

			//unlabeled++;
			lp = getdiskbyname(disktype);
			if (lp == NULL)
				errx(EXIT_FAILURE, "%s: unknown disk type",
				    disktype);
			return (lp);
		}
		warn("ioctl (GDINFO)");
		errx(EXIT_FAILURE,
		    "%s: can't read disk label; disk type must be specified",
		    s);
	}
	return (&lab);
}

struct partition *
getpartition(int fsi, const char *special, char *argv[], struct disklabel **dl)
{
	struct stat st;
	const char *cp;
	struct disklabel *lp;
	struct partition *pp;

	if (fstat(fsi, &st) < 0)
		err(EXIT_FAILURE, "%s", special);
	if (S_ISBLK(st.st_mode))
		errx(EXIT_FAILURE, "%s: block device", special);
	if (!S_ISCHR(st.st_mode))
		warnx("%s: not a character-special device", special);
	if (*argv[0] == '\0')
		errx(EXIT_FAILURE, "empty partition name supplied");
	cp = argv[0] + strlen(argv[0]) - 1;
	if ((*cp < 'a' || *cp > ('a' + getmaxpartitions() - 1))
	    && !isdigit((unsigned char)*cp))
		errx(EXIT_FAILURE, "%s: can't figure out file system partition", argv[0]);
	lp = getdisklabel(special, fsi);
	if (isdigit((unsigned char)*cp))
		pp = &lp->d_partitions[0];
	else
		pp = &lp->d_partitions[*cp - 'a'];
	if (DL_GETPSIZE(pp) == 0) 
		errx(EXIT_FAILURE, "%s: `%c' partition is unavailable", argv[0], *cp);
	if (pp->p_fstype == FS_BOOT)
			errx(EXIT_FAILURE, "%s: `%c' partition overlaps boot program",
			      argv[0], *cp);
	*dl = lp;
	return pp;
}

@


1.24
log
@Replace an ad-hoc implementation of opendev(), with said function and
open the device only once with the correct flags, instead of twice (one
file handle for reading and one for writing). Committing this at once
because the changes are interrelated.

ok stefan
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.23 2016/03/14 20:14:30 natano Exp $ */
d244 1
a244 1
		fd = open(special, fl, 0777);
@


1.23
log
@Add a missing "cpath" promise; newfs_ext2fs can create files when used
with the -F and -s flags.

ok stefan
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.22 2015/12/06 11:56:47 tobias Exp $ */
a107 1
static char device[PATH_MAX];
d117 2
a118 2
	int ch, fsi, fso, len, n, Fflag, Iflag, Zflag;
	char *cp, *s1, *s2, *special;
d120 1
a120 1
	int byte_sized;
a134 2
	cp = NULL;
	fsi = fso = -1;
d231 2
a233 1
		int fl;
d242 4
a245 10
		if (Nflag)
			fl = O_RDONLY;
		else {
			if (fssize > 0)
				fl = O_RDWR | O_CREAT;
			else
				fl = O_RDWR;
		}
		fsi = open(special, fl, 0777);
		if (fsi == -1)
d247 1
a247 1
		if (fstat(fsi, &sb) == -1)
a248 2
		if (!Nflag)
			fso = fsi;
d250 3
a252 17
		cp = strrchr(special, '/');
		if (cp == NULL) {
			struct stat st;
			/*
			 * No path prefix; try /dev/r%s then /dev/%s.
			 */
			(void)snprintf(device, sizeof(device), "%sr%s",
			    _PATH_DEV, special);
			if (stat(device, &st) == -1)
				(void)snprintf(device, sizeof(device), "%s%s",
				    _PATH_DEV, special);
			special = device;
		}

		fsi = open(special, O_RDONLY);
		if (fsi < 0 || fstat(fsi, &sb) == -1)
			err(EXIT_FAILURE, "%s: open for read", special);
a254 5
			fso = open(special, O_WRONLY, 0);
			if (fso < 0)
				err(EXIT_FAILURE,
				    "%s: open for write", special);

d280 1
a280 1
		pp = getpartition(fsi, special, argv, &lp);
d307 2
a308 2
	if (Fflag && fso != -1
	    && ftruncate(fso, (off_t)fssize * sectorsize) == -1)
d311 1
a311 1
	if (Zflag && fso != -1) {	/* pre-zero (and de-sparce) the file */
d317 1
a317 1
		if (fstatfs(fso, &sfs) == -1) {
d332 1
a332 1
			i = write(fso, buf, MINIMUM(bufsize, bufrem));
d369 1
a369 1
	mke2fs(special, fsi, fso);
d371 1
a371 4
	if (fsi != -1)
		close(fsi);
	if (fso != -1 && fso != fsi)
		close(fso);
@


1.22
log
@Avoid out of boundary access on illegal command line arguments.

ok deraadt, mmcc, tedu
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.21 2015/11/28 06:12:09 deraadt Exp $ */
d133 1
a133 1
	if (pledge("stdio rpath wpath disklabel", NULL) == -1)
@


1.21
log
@Oops, left the pledge "tty" active in the previous commited
pointed out by Chris Hettrick
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.20 2015/11/26 06:59:12 deraadt Exp $ */
d532 5
a536 3
	cp = strchr(argv[0], '\0') - 1;
	if (cp == NULL || ((*cp < 'a' || *cp > ('a' + getmaxpartitions() - 1))
	    && !isdigit((unsigned char)*cp)))
@


1.20
log
@Instead, hoist TIOCGWINSZ up to the top, then "tty" pledge is not needed.
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.19 2015/11/26 06:45:08 deraadt Exp $ */
d133 1
a133 1
	if (pledge("stdio rpath wpath tty disklabel", NULL) == -1)
@


1.19
log
@unbelievable.. this uses TIOCGWINSZ.. how did i miss that.  pledge "tty".
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.18 2015/11/23 19:19:30 deraadt Exp $ */
d104 1
d125 7
@


1.18
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.17 2015/10/14 15:54:49 deraadt Exp $ */
d125 1
a125 1
	if (pledge("stdio rpath wpath disklabel", NULL) == -1)
@


1.17
log
@unfortunately rewritelabel() just before termination does a non-permitted
ioctl to rewrite the label, in support of the old-school "frag info in
the disklabel" concept.  disklabel folk, please come talk to me...
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.15 2015/01/16 06:40:00 deraadt Exp $ */
d124 3
@


1.16
log
@can pledge "stdio" after opening device.
@
text
@a298 4

		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");

@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.14 2014/11/20 15:22:39 tedu Exp $ */
d299 4
@


1.14
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.13 2014/06/29 00:32:50 deraadt Exp $ */
d36 2
a37 1
#include <sys/param.h>
d60 2
d107 1
a107 1
static char device[MAXPATHLEN];
d350 1
a350 1
			i = write(fso, buf, MIN(bufsize, bufrem));
@


1.13
log
@do not need sys/disk.h
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.12 2014/05/21 06:23:01 guenther Exp $ */
a39 1
#include <sys/file.h>
d48 1
@


1.12
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.11 2014/04/22 00:23:35 guenther Exp $ */
a39 1
#include <sys/disk.h>
@


1.11
log
@Clarify an err() message
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.10 2014/04/21 09:22:15 guenther Exp $ */
d514 1
a514 1
		errx(EXIT_FAILURE, "%s: %s", special, strerror(errno));
@


1.10
log
@While we don't recommend using ext2fs, the directions for doing so
shouldn't be misleading

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.9 2013/11/22 04:14:01 deraadt Exp $ */
d340 1
a340 1
			err(1, "can't malloc buffer of %d",
@


1.9
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.8 2013/10/27 18:54:03 guenther Exp $ */
d301 1
a301 1
				errx(EXIT_FAILURE, m, special, "Linux Ext2");
d455 1
a455 1
	"\t-I \t\tdo not check that the file system type is `Linux Ext2'\n"
@


1.8
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.7 2012/12/04 02:27:00 deraadt Exp $ */
d521 1
a521 1
	    && !isdigit(*cp)))
d524 1
a524 1
	if (isdigit(*cp))
@


1.7
log
@remove some unnecessary sys/cdefs.h inclusions
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.6 2010/05/18 04:41:14 dlg Exp $ */
a480 2
char lmsg[] = "%s: can't read disk label; disk type must be specified";

d498 3
a500 1
		errx(EXIT_FAILURE, lmsg, s);
@


1.6
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.5 2010/02/18 07:58:14 otto Exp $ */
a31 2

#include <sys/cdefs.h>
@


1.5
log
@Add -q flag for compatiblity with newfs as requested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.4 2010/02/17 19:26:10 otto Exp $ */
d40 1
@


1.4
log
@handle -t for when being called by newfs
@
text
@d1 1
a1 1
/* $OpenBSD: newfs_ext2fs.c,v 1.3 2010/02/16 12:25:35 otto Exp $ */
d128 1
a128 1
	opstring = "D:FINO:S:V:Zb:f:i:l:m:n:s:t:v:";
d189 3
@


1.3
log
@fix OpenBSD rcs tags, prompted by Tim van der Molen
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d128 1
a128 1
	opstring = "D:FINO:S:V:Zb:f:i:l:m:n:s:v:";
d193 3
@


1.2
log
@default verbosity to 4
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.1
log
@Port of newfs_ext2fs from NetBSD. not hooked to the build yet.
ok miod@@
@
text
@d94 1
a94 1
#define DEFAULT_VERBOSITY 3	/* 4 is traditional behavior of newfs(8) */
@

