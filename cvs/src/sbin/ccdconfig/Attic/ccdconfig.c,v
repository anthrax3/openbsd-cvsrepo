head	1.37;
access;
symbols
	OPENBSD_5_0:1.36.0.4
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.34.0.10
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.6
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2011.10.06.20.49.29;	author deraadt;	state dead;
branches;
next	1.36;

1.36
date	2010.08.24.07.43.33;	author jasper;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.12.04.33.40;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.06.19.16.05;	author sobrado;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.17.15.52.24;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.06.06.41.42;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.26.18.06.00;	author grunk;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.13.19.14.56;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.06.10.45.56;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.12.20.15.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.12.18.47.42;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.12.15.26.23;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.29.22.23.42;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.24.19.37.19;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.29.12.35.54;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.17.01.41.45;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.30.20.28.38;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.07.18.26.10;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.04.14.59.47;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.30.16.06.33;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.30.16.00.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.08.15.20.16.34;	author deraadt;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	98.07.08.22.24.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.26.22.34.05;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.09.14.08.52.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.05.28.21.51.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.13.21.23.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.22.03.00.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.30.09.11.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.11.34.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.21.00.15.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.10.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.26;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2000.10.06.20.40.26;	author jason;	state Exp;
branches;
next	;


desc
@@


1.37
log
@ccd goes to the attic
discussed with jsing and millert
@
text
@/*	$OpenBSD: ccdconfig.c,v 1.36 2010/08/24 07:43:33 jasper Exp $	*/
/*	$NetBSD: ccdconfig.c,v 1.6 1996/05/16 07:11:18 thorpej Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/disklabel.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#ifndef SMALL
/* this kvm nonsense doesn't belong here */
#define SMALL
#endif

#ifndef SMALL
#include <kvm.h>
#include <nlist.h>
#endif

#include <dev/ccdvar.h>

#include "pathnames.h"

extern	char *__progname;

static	int lineno = 0;
static	int verbose = 0;
static	char *ccdconf = _PATH_CCDCONF;

static	char *core = NULL;
static	char *kernel = NULL;

struct	flagval {
	char	*fv_flag;
	int	fv_val;
} flagvaltab[] = {
	{ "CCDF_SWAP",		CCDF_SWAP },
	{ "CCDF_UNIFORM",	CCDF_UNIFORM },
	{ "CCDF_MIRROR",	CCDF_MIRROR },
	{ "CCDF_OLD",		CCDF_OLD },
	{ NULL,			0 },
};

#ifndef SMALL
static	struct nlist nl[] = {
	{ "_ccd_softc" },
#define SYM_CCDSOFTC		0
	{ "_numccd" },
#define SYM_NUMCCD		1
	{ NULL },
};
#endif

#define CCD_CONFIG		0	/* configure a device */
#define CCD_CONFIGALL		1	/* configure all devices */
#define CCD_UNCONFIG		2	/* unconfigure a device */
#define CCD_UNCONFIGALL		3	/* unconfigure all devices */
#define CCD_DUMP		4	/* dump a ccd's configuration */

static	int checkdev(const char *);
static	int do_io(char *, u_long, struct ccd_ioctl *);
static	int do_single(int, char **, int);
static	int do_all(int);
static	int dump_ccd(int, char **);
static	int flags_to_val(char *);
#ifndef SMALL
static 	int pathtounit(const char *, int *);
static	void print_ccd_info(struct ccd_softc *, kvm_t *);
#endif
static	char *resolve_ccdname(char *);
static	void usage(void);

int
main(int argc, char *argv[])
{
	int ch, options = 0, action = CCD_CONFIG;
	gid_t gid;

	while ((ch = getopt(argc, argv, "cCf:gM:N:uUv")) != -1) {
		switch (ch) {
		case 'c':
			action = CCD_CONFIG;
			++options;
			break;

		case 'C':
			action = CCD_CONFIGALL;
			++options;
			break;

		case 'f':
			ccdconf = optarg;
			break;

		case 'g':
			action = CCD_DUMP;
			break;

		case 'M':
			core = optarg;
			break;

		case 'N':
			kernel = optarg;
			break;

		case 'u':
			action = CCD_UNCONFIG;
			++options;
			break;

		case 'U':
			action = CCD_UNCONFIGALL;
			++options;
			break;

		case 'v':
			verbose = 1;
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (options > 1)
		usage();

	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	gid = getgid();
	if (core != NULL || kernel != NULL || action != CCD_DUMP)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	switch (action) {
	case CCD_CONFIG:
	case CCD_UNCONFIG:
		setegid(getgid());
		setgid(getgid());
		return (do_single(argc, argv, action));

	case CCD_CONFIGALL:
	case CCD_UNCONFIGALL:
		setegid(getgid());
		setgid(getgid());
		return (do_all(action));

	case CCD_DUMP:
		return (dump_ccd(argc, argv));
	}
	/* NOTREACHED */

	return (0);
}

static int
do_single(int argc, char *argv[], int action)
{
	struct ccd_ioctl ccio;
	char *ccd, *cp, *cp2, **disks = NULL;
	int noflags = 0, i, ileave, flags = 0, j, ret = 1;

	memset(&ccio, 0, sizeof(ccio));

	/*
	 * If unconfiguring, all arguments are treated as ccds.
	 */
	if (action == CCD_UNCONFIG || action == CCD_UNCONFIGALL) {
		for (i = 0; argc != 0; ) {
			cp = *argv++; --argc;
			if ((ccd = resolve_ccdname(cp)) == NULL) {
				warnx("invalid ccd name: %s", cp);
				i = 1;
				continue;
			}
			if (do_io(ccd, CCDIOCCLR, &ccio))
				i = 1;
			else {
				if (verbose)
					printf("%s unconfigured\n", cp);
			}

			free(ccd);
		}
		return (i);
	}

	/* Make sure there are enough arguments. */
	if (argc < 4) {
		if (argc == 3) {
			/* Assume that no flags are specified. */
			noflags = 1;
		} else {
			if (action == CCD_CONFIGALL) {
				warnx("%s: bad line: %d", ccdconf, lineno);
				return (1);
			} else
				usage();
		}
	}

	/* First argument is the ccd to configure. */
	cp = *argv++; --argc;
	if ((ccd = resolve_ccdname(cp)) == NULL) {
		warnx("invalid ccd name: %s", cp);
		return (1);
	}

	/* Next argument is the interleave factor. */
	cp = *argv++; --argc;
	errno = 0;	/* to check for ERANGE */
	ileave = (int)strtol(cp, &cp2, 10);
	if ((errno == ERANGE) || (ileave < 0) || (*cp2 != '\0')) {
		warnx("invalid interleave factor: %s", cp);
		goto done;	
	}

	if (noflags == 0) {
		/* Next argument is the ccd configuration flags. */
		cp = *argv++; --argc;
		if ((flags = flags_to_val(cp)) < 0) {
			warnx("invalid flags argument: %s", cp);
			goto done;
		}
	}

	/* Next is the list of disks to make the ccd from. */
	disks = calloc(argc, sizeof(char *));
	if (disks == NULL) {
		warnx("no memory to configure ccd");
		goto done;
	}
	for (i = 0; argc != 0; ) {
		cp = *argv++; --argc;
		if ((j = checkdev(cp)) == 0)
			disks[i++] = cp;
		else {
			warnx("%s: %s", cp, strerror(j));
			goto done;
		}
	}

	/* Fill in the ccio. */
	ccio.ccio_disks = disks;
	ccio.ccio_ndisks = i;
	ccio.ccio_ileave = ileave;
	ccio.ccio_flags = flags;

	if (do_io(ccd, CCDIOCSET, &ccio))
		goto done;

	if (verbose) {
		printf("ccd%d: %d components ", ccio.ccio_unit,
		    ccio.ccio_ndisks);
		for (i = 0; i < ccio.ccio_ndisks; ++i) {
			if ((cp2 = strrchr(disks[i], '/')) != NULL)
				++cp2;
			else
				cp2 = disks[i];
			printf("%c%s%c",
			    i == 0 ? '(' : ' ', cp2,
			    i == ccio.ccio_ndisks - 1 ? ')' : ',');
		}
		printf(", %ld blocks ", ccio.ccio_size);
		if (ccio.ccio_ileave != 0)
			printf("interleaved at %d blocks\n", ccio.ccio_ileave);
		else
			printf("concatenated\n");
	}

	ret = 0;

done:
	free(disks);
	free(ccd);
	return (ret);
}

static int
do_all(int action)
{
	FILE *f;
	char line[_POSIX2_LINE_MAX];
	char *cp, **argv;
	int argc, rval = 0;
	gid_t egid;
	char **nargv;

	egid = getegid();
	setegid(getgid());
	if ((f = fopen(ccdconf, "r")) == NULL) {
		setegid(egid);
		warn("fopen: %s", ccdconf);
		return (1);
	}
	setegid(egid);

	while (fgets(line, sizeof(line), f) != NULL) {
		argc = 0;
		argv = NULL;
		++lineno;
		if ((cp = strrchr(line, '\n')) != NULL)
			*cp = '\0';

		/* Break up the line and pass it's contents to do_single(). */
		if (line[0] == '\0')
			goto end_of_line;
		for (cp = line; (cp = strtok(cp, " \t")) != NULL; cp = NULL) {
			if (*cp == '#')
				break;
			if ((nargv = realloc(argv,
			    sizeof(char *) * ++argc)) == NULL) {
				fclose(f);
				warnx("no memory to configure ccds");
				return (1);
			}
			argv = nargv;
			argv[argc - 1] = cp;
			/*
			 * If our action is to unconfigure all, then pass
			 * just the first token to do_single() and ignore
			 * the rest.  Since this will be encountered on
			 * our first pass through the line, the Right
			 * Thing will happen.
			 */
			if (action == CCD_UNCONFIGALL) {
				if (do_single(argc, argv, action))
					rval = 1;
				goto end_of_line;
			}
		}
		if (argc != 0)
			if (do_single(argc, argv, action))
				rval = 1;

 end_of_line:
		if (argv != NULL)
			free(argv);
	}

	(void)fclose(f);
	return (rval);
}

static int
checkdev(const char *path)
{
	struct stat st;

	if (stat(path, &st) != 0)
		return (errno);

	if (!S_ISBLK(st.st_mode) && !S_ISCHR(st.st_mode))
		return (EINVAL);

	return (0);
}

#ifndef SMALL
static int
pathtounit(const char *path, int *unitp)
{
	struct stat st;
	int maxpartitions;

	if (stat(path, &st) != 0)
		return (errno);

	if (!S_ISBLK(st.st_mode) && !S_ISCHR(st.st_mode))
		return (EINVAL);

	if ((maxpartitions = getmaxpartitions()) < 0)
		return (errno);

	*unitp = minor(st.st_rdev) / maxpartitions;

	return (0);
}
#endif

static char *
resolve_ccdname(char *name)
{
	char c, *path;
	size_t len;
	int rawpart;

	if (name[0] == '/' || name[0] == '.') {
		/* Assume they gave the correct pathname. */
		return (strdup(name));
	}

	len = strlen(name);
	c = name[len - 1];

	if (isdigit(c)) {
		if ((rawpart = getrawpartition()) < 0)
			return (NULL);
		if (asprintf(&path, "/dev/%s%c", name, 'a' + rawpart) == -1)
			return (NULL);
	} else {
		if (asprintf(&path, "/dev/%s", name) == -1)
			return (NULL);
	}

	return (path);
}

static int
do_io(char *path, u_long cmd, struct ccd_ioctl *cciop)
{
	int fd;
	char *cp;

	if ((fd = open(path, O_RDWR, 0640)) < 0) {
		warn("open: %s", path);
		return (1);
	}

	if (ioctl(fd, cmd, cciop) < 0) {
		switch (cmd) {
		case CCDIOCSET:
			cp = "CCDIOCSET";
			break;

		case CCDIOCCLR:
			cp = "CCDIOCCLR";
			break;

		default:
			cp = "unknown";
		}
		warn("ioctl (%s): %s", cp, path);
		close(fd);
		return (1);
	}

	close(fd);
	return (0);
}

#ifdef SMALL
static int
dump_ccd(int argc, char *argv[])
{
	warnx("option not supported");
	return (1);
}
#else
#define KVM_ABORT(kd, str) {						\
	(void)kvm_close((kd));						\
	warnx("%s", (str));						\
	warnx("%s", kvm_geterr((kd)));					\
	return (1);							\
}

static int
dump_ccd(int argc, char *argv[])
{
	char errbuf[_POSIX2_LINE_MAX], *ccd, *cp;
	struct ccd_softc *cs, *kcs;
	size_t readsize;
	int i, error, numccd, numconfiged = 0;
	kvm_t *kd;

	memset(errbuf, 0, sizeof(errbuf));

	if ((kd = kvm_openfiles(kernel, core, NULL, O_RDONLY,
	    errbuf)) == NULL) {
		warnx("can't open kvm: %s", errbuf);
		return (1);
	}

	setegid(getgid());
	setgid(getgid());

	if (kvm_nlist(kd, nl))
		KVM_ABORT(kd, "ccd-related symbols not available");

	/* Check to see how many ccds are currently configured. */
	if (kvm_read(kd, nl[SYM_NUMCCD].n_value, (char *)&numccd,
	    sizeof(numccd)) != sizeof(numccd))
		KVM_ABORT(kd, "can't determine number of configured ccds");

	if (numccd == 0) {
		printf("ccd driver in kernel, but is uninitialized\n");
		goto done;
	}

	/* Allocate space for the configuration data. */
	readsize = numccd * sizeof(struct ccd_softc);
	if ((cs = malloc(readsize)) == NULL) {
		warnx("no memory for configuration data");
		goto bad;
	}
	memset(cs, 0, readsize);

	/*
	 * Read the ccd configuration data from the kernel and dump
	 * it to stdout.
	 */
	if (kvm_read(kd, nl[SYM_CCDSOFTC].n_value, (char *)&kcs,
	    sizeof(kcs)) != sizeof(kcs)) {
		free(cs);
		KVM_ABORT(kd, "can't find pointer to configuration data");
	}
	if (kvm_read(kd, (u_long)kcs, (char *)cs, readsize) != readsize) {
		free(cs);
		KVM_ABORT(kd, "can't read configuration data");
	}

	if (argc == 0) {
		for (i = 0; i < numccd; ++i)
			if (cs[i].sc_flags & CCDF_INITED) {
				++numconfiged;
				print_ccd_info(&cs[i], kd);
			}

		if (numconfiged == 0)
			printf("no concatenated disks configured\n");
	} else {
		while (argc) {
			cp = *argv++; --argc;
			if ((ccd = resolve_ccdname(cp)) == NULL) {
				warnx("invalid ccd name: %s", cp);
				continue;
			}
			if ((error = pathtounit(ccd, &i)) != 0) {
				warnx("%s: %s", ccd, strerror(error));
				free(ccd);
				continue;
			}
			free(ccd);
			if (i >= numccd) {
				warnx("ccd%d not configured", i);
				continue;
			}
			if (cs[i].sc_flags & CCDF_INITED)
				print_ccd_info(&cs[i], kd);
			else
				printf("ccd%d not configured\n", i);
		}
	}

	free(cs);

 done:
	(void)kvm_close(kd);
	return (0);

 bad:
	(void)kvm_close(kd);
	return (1);
}

static void
print_ccd_info(struct ccd_softc *cs, kvm_t *kd)
{
	static int header_printed = 0;
	struct ccdcinfo *cip;
	size_t readsize;
	char path[MAXPATHLEN];
	int i;

	if (header_printed == 0 && verbose) {
		printf("# ccd\t\tileave\tflags\tcomponent devices\n");
		header_printed = 1;
	}

	readsize = cs->sc_nccdisks * sizeof(struct ccdcinfo);
	if ((cip = malloc(readsize)) == NULL) {
		warn("%s: can't allocate memory for component info",
		    cs->sc_xname);
		return;
	}
	memset(cip, 0, readsize);

	/* Dump out softc information. */
	printf("%s\t\t%d\t0x%x\t", cs->sc_xname, cs->sc_ileave,
	    cs->sc_cflags & CCDF_USERMASK);
	fflush(stdout);

	/* Read in the component info. */
	if (kvm_read(kd, (u_long)cs->sc_cinfo, (char *)cip,
	    readsize) != readsize) {
		printf("\n");
		warnx("can't read component info");
		warnx("%s", kvm_geterr(kd));
		goto done;
	}

	/* Read component pathname and display component info. */
	for (i = 0; i < cs->sc_nccdisks; ++i) {
		if (kvm_read(kd, (u_long)cip[i].ci_path, (char *)path,
		    cip[i].ci_pathlen) != cip[i].ci_pathlen) {
			printf("\n");
			warnx("can't read component pathname");
			warnx("%s", kvm_geterr(kd));
			goto done;
		}
		printf((i + 1 < cs->sc_nccdisks) ? "%s " : "%s\n", path);
		fflush(stdout);
	}

 done:
	free(cip);
}
#endif /* !SMALL */

static int
flags_to_val(char *flags)
{
	char *cp, *tok;
	int i, tmp, val = ~CCDF_USERMASK;
	size_t flagslen;

	/*
	 * The most common case is that of NIL flags, so check for
	 * those first.
	 */
	if (strcmp("none", flags) == 0 || strcmp("0x0", flags) == 0 ||
	    strcmp("0", flags) == 0)
		return (0);

	flagslen = strlen(flags);

	/* Check for values represented by strings. */
	if ((cp = strdup(flags)) == NULL)
		err(1, "no memory to parse flags");
	tmp = 0;
	for (tok = cp; (tok = strtok(tok, ",")) != NULL; tok = NULL) {
		for (i = 0; flagvaltab[i].fv_flag != NULL; ++i)
			if (strcmp(tok, flagvaltab[i].fv_flag) == 0)
				break;
		if (flagvaltab[i].fv_flag == NULL) {
			free(cp);
			goto bad_string;
		}
		tmp |= flagvaltab[i].fv_val;
	}

	/* If we get here, the string was ok. */
	free(cp);
	val = tmp;
	goto out;

 bad_string:

	/* Check for values represented in hex. */
	if (flagslen > 2 && flags[0] == '0' && flags[1] == 'x') {
		errno = 0;	/* to check for ERANGE */
		val = (int)strtol(&flags[2], &cp, 16);
		if ((errno == ERANGE) || (*cp != '\0'))
			return (-1);
		goto out;
	}

	/* Check for values represented in decimal. */
	errno = 0;	/* to check for ERANGE */
	val = (int)strtol(flags, &cp, 10);
	if ((errno == ERANGE) || (*cp != '\0'))
		return (-1);

 out:
	return (((val & ~CCDF_USERMASK) == 0) ? val : -1);
}

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-cv] ccd ileave [flags] dev ...\n",
	    __progname);
	fprintf(stderr, "       %s -C [-v] [-f config_file]\n", __progname);
	fprintf(stderr, "       %s -u [-v] ccd ...\n", __progname);
	fprintf(stderr, "       %s -U [-v] [-f config_file]\n", __progname);
	exit(1);
}
@


1.36
log
@- plugs two fd leaks

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.35 2010/08/12 04:33:40 tedu Exp $	*/
@


1.35
log
@correct a format string.  not sure who thought size_t would be a good match
for ccd size, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.34 2008/06/26 05:42:06 ray Exp $	*/
d480 1
d484 1
@


1.34
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.33 2007/09/02 15:19:23 deraadt Exp $	*/
d310 1
a310 1
		printf(", %d blocks ", ccio.ccio_size);
@


1.33
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.32 2007/08/06 19:16:05 sobrado Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.32
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.31 2007/04/17 15:52:24 tedu Exp $	*/
d281 1
a281 1
	disks = malloc(argc * sizeof(char *));
@


1.31
log
@remove mention of -g and assocatiated options that aren't working now
reminded by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.30 2007/04/06 06:41:42 tedu Exp $	*/
d723 2
a724 2
	fprintf(stderr, "usage: %s [-cv] ccd ileave [flags] %s\n", __progname,
	    "dev [...]");
d726 1
a726 1
	fprintf(stderr, "       %s -u [-v] ccd [...]\n", __progname);
@


1.30
log
@use rwlocks instead of hand-rolled.  make the softc private parts private.
this means making ccdconfig "SMALL" to turn off the kvm groveling nonsense
ok deraadt millert pedro todd
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.29 2006/03/26 18:06:00 grunk Exp $	*/
a727 2
	fprintf(stderr, "       %s -g [-M core] [-N system] %s\n", __progname,
	    "[ccd [...]]");
@


1.29
log
@fix output of ``ccdconfig -gv'':  one typo, and one missing \t

mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.28 2006/03/13 19:14:56 otto Exp $	*/
d57 6
@


1.28
log
@Cleanup and plug a fe memleaks and; from Davif Hill with a twist from
myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.27 2006/03/06 10:45:56 djm Exp $	*/
d611 1
a611 1
		printf("# ccd\t\tileave\tflags\tcompnent devices\n");
d624 1
a624 1
	printf("%s\t%d\t0x%x\t", cs->sc_xname, cs->sc_ileave,
@


1.27
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.26 2005/11/12 20:15:13 deraadt Exp $	*/
d102 1
a102 1
static	int checkdev(char *);
d109 1
d207 2
a208 2
	char *ccd, *cp, *cp2, **disks;
	int noflags = 0, i, ileave, flags = 0, j;
d225 1
a225 1
			else
d228 3
d262 1
a262 1
		return (1);
d270 1
a270 1
			return (1);
d278 1
a278 1
		return (1);
d286 1
a286 2
			free(disks);
			return (1);
d296 2
a297 4
	if (do_io(ccd, CCDIOCSET, &ccio)) {
		free(disks);
		return (1);
	}
d318 3
d322 2
a323 1
	return (0);
d393 1
a393 1
checkdev(char *path)
d408 1
a408 1
pathtounit(char *path, int *unitp)
d575 1
d578 1
@


1.26
log
@FILE * leak, missing fclose(); evol@@online.ptt.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.25 2005/11/12 18:47:42 deraadt Exp $	*/
d118 1
d176 4
a179 4
	if (core != NULL || kernel != NULL || action != CCD_DUMP) {
		setegid(getgid());
		setgid(getgid());
	}
@


1.25
log
@left a free() behind, spotted by cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.24 2005/11/12 15:26:23 deraadt Exp $	*/
d354 1
@


1.24
log
@more asprintf; ok dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.23 2005/03/29 22:23:42 mickey Exp $	*/
d437 1
a437 2
		if ((rawpart = getrawpartition()) < 0) {
			free(path);
a438 1
		}
@


1.23
log
@less ugly printout
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.22 2005/02/24 19:37:19 mickey Exp $	*/
d425 1
a425 1
	size_t len, newlen;
a435 5
	newlen = len + 8;
	if ((path = malloc(newlen)) == NULL)
		return (NULL);
	memset(path, 0, newlen);

d441 6
a446 3
		(void)snprintf(path, newlen, "/dev/%s%c", name, 'a' + rawpart);
	} else
		(void)snprintf(path, newlen, "/dev/%s", name);
@


1.22
log
@changes for ccd changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.21 2004/05/29 12:35:54 deraadt Exp $	*/
d619 1
a619 1
	printf("%s\t\t%d\t0x%x\t", cs->sc_xname, cs->sc_ileave,
@


1.21
log
@memory leak; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.20 2003/12/17 01:41:45 millert Exp $	*/
d612 2
a613 2
		warn("ccd%d: can't allocate memory for component info",
		    cs->sc_unit);
d619 1
a619 1
	printf("ccd%d\t\t%d\t%d\t", cs->sc_unit, cs->sc_ileave,
@


1.20
log
@Add support for -DSMALL that doesn't need -lkvm (no -g option)
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.19 2003/06/11 06:22:12 deraadt Exp $	*/
d281 1
@


1.19
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.18 2003/03/30 20:28:38 deraadt Exp $	*/
a50 1
#include <kvm.h>
a51 1
#include <nlist.h>
d57 4
d86 1
d94 1
d108 1
d110 1
d398 1
d418 1
d483 8
d647 1
@


1.18
log
@snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.17 2002/02/16 21:27:33 millert Exp $	*/
d109 1
a109 3
main(argc, argv)
	int argc;
	char **argv;
d196 1
a196 4
do_single(argc, argv, action)
	int argc;
	char **argv;
	int action;
d314 1
a314 2
do_all(action)
	int action;
d379 1
a379 2
checkdev(path)
	char *path;
d393 1
a393 3
pathtounit(path, unitp)
	char *path;
	int *unitp;
d413 1
a413 2
resolve_ccdname(name)
	char *name;
d445 1
a445 4
do_io(path, cmd, cciop)
	char *path;
	u_long cmd;
	struct ccd_ioctl *cciop;
d483 1
a483 3
dump_ccd(argc, argv)
	int argc;
	char **argv;
d580 1
a580 3
print_ccd_info(cs, kd)
	struct ccd_softc *cs;
	kvm_t *kd;
d633 1
a633 2
flags_to_val(flags)
	char *flags;
d691 1
a691 1
usage()
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.16 2001/07/07 18:26:10 deraadt Exp $	*/
d447 1
a447 1
		(void)sprintf(path, "/dev/%s%c", name, 'a' + rawpart);
d449 1
a449 1
		(void)sprintf(path, "/dev/%s", name);
@


1.16
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.15 2001/06/04 14:59:47 mickey Exp $	*/
d98 9
a106 9
static	int checkdev __P((char *));
static	int do_io __P((char *, u_long, struct ccd_ioctl *));
static	int do_single __P((int, char **, int));
static	int do_all __P((int));
static	int dump_ccd __P((int, char **));
static	int flags_to_val __P((char *));
static	void print_ccd_info __P((struct ccd_softc *, kvm_t *));
static	char *resolve_ccdname __P((char *));
static	void usage __P((void));
@


1.15
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.14 2000/09/30 16:06:33 aaron Exp $	*/
d230 1
a230 1
	if (argc < 4)
d241 1
@


1.14
log
@Some format string problems that were missed during initial audit; deraadt@@ and
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.13 2000/06/30 16:00:07 millert Exp $	*/
d181 1
a181 3

		exit(do_single(argc, argv, action));
		/* NOTREACHED */
a184 1

d187 1
a187 3

		exit(do_all(action));
		/* NOTREACHED */
d190 1
a190 2
		exit(dump_ccd(argc, argv));
		/* NOTREACHED */
d193 2
a194 1
	exit(0);
@


1.13
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.12 1998/08/15 20:16:34 deraadt Exp $	*/
d494 1
a494 1
	warnx((str));							\
@


1.12
log
@fix realloc
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.11 1998/07/08 22:24:54 deraadt Exp $	*/
d495 1
a495 1
	warnx(kvm_geterr((kd)));					\
d632 1
a632 1
		warnx(kvm_geterr(kd));
d642 1
a642 1
			warnx(kvm_geterr(kd));
@


1.12.8.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.12 1998/08/15 20:16:34 deraadt Exp $	*/
d494 1
a494 1
	warnx("%s", (str));						\
@


1.11
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.10 1997/11/26 22:34:05 niklas Exp $	*/
d331 1
d355 1
a355 1
			if ((argv = realloc(argv,
d360 1
@


1.10
log
@Add a CCDF_OLD flag used to get the old I/O policy
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.9 1997/09/14 08:52:13 deraadt Exp $	*/
d179 3
d187 4
d515 3
@


1.9
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.8 1997/05/28 21:51:47 deraadt Exp $	*/
d80 1
@


1.8
log
@be more paranoid about gid revoking
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.7 1997/01/13 21:23:35 deraadt Exp $	*/
a102 1
static	int pathtodevt __P((char *, dev_t *));
d191 1
d202 1
a202 1
	int noflags = 0, i, ileave, flags, j, error;
d204 1
a204 1
	bzero(&ccio, sizeof(ccio));
d321 1
a321 1
	int argc, rval;
a398 1
	dev_t dev;
d419 1
a419 1
	char c, *cp, *path;
d434 1
a434 1
	bzero(path, newlen);
d500 1
a500 1
	bzero(errbuf, sizeof(errbuf));
d527 1
a527 1
	bzero(cs, readsize);
d607 1
a607 1
	bzero(cip, readsize);
@


1.7
log
@egid for open; spotted by oliver@@secnet.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.6 1996/12/22 03:00:47 deraadt Exp $	*/
d171 1
a171 1
	if (core != NULL || kernel != NULL) {
d177 13
a189 13
		case CCD_CONFIG:
		case CCD_UNCONFIG:
			exit(do_single(argc, argv, action));
			/* NOTREACHED */

		case CCD_CONFIGALL:
		case CCD_UNCONFIGALL:
			exit(do_all(action));
			/* NOTREACHED */

		case CCD_DUMP:
			exit(dump_ccd(argc, argv));
			/* NOTREACHED */
@


1.6
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.5 1996/05/30 09:11:20 deraadt Exp $	*/
d322 1
d324 2
d327 1
d331 1
@


1.5
log
@revoke privs before opening kvm if user has specified mem/kernel paths
@
text
@d1 1
a1 1
/*	$OpenBSD: ccdconfig.c,v 1.4 1996/05/22 11:34:48 deraadt Exp $	*/
d171 2
a172 1
	if (core != NULL || kernel != NULL)
d174 1
@


1.4
log
@libutil
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 7
@


1.3
log
@From NetBSD: Merge of 960317
@
text
@d2 1
a2 1
/*	$NetBSD: ccdconfig.c,v 1.5 1996/02/28 01:01:18 thorpej Exp $	*/
d58 1
a101 2
static	int getmaxpartitions __P((void));
static	int getrawpartition __P((void));
a624 30
}

static int
getmaxpartitions()
{
	int maxpart, mib[2];
	size_t varlen;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MAXPARTITIONS;
	varlen = sizeof(maxpart);
	if (sysctl(mib, 2, &maxpart, &varlen, NULL, 0) < 0)
		return (-1);

	return (maxpart);
}

static int
getrawpartition()
{
	int rawpart, mib[2];
	size_t varlen;

	mib[0] = CTL_KERN;
	mib[1] = KERN_RAWPARTITION;
	varlen = sizeof(rawpart);
	if (sysctl(mib, 2, &rawpart, &varlen, NULL, 0) < 0)
		return (-1);

	return (rawpart);
@


1.2
log
@from netbsd:
Fix handling of "-M core" and "-N system"; a real brain-o on my part.
Fix related typo in manual page.
@
text
@d1 2
a2 1
/*	$NetBSD: ccdconfig.c,v 1.2.2.1 1995/11/11 02:43:35 thorpej Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995 Jason R. Thorpe.
d8 3
d21 5
a25 4
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 11
a37 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d78 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ccdconfig.c,v 1.2 1995/08/23 01:06:59 thorpej Exp $	*/
d110 1
a110 1
	while ((ch = getopt(argc, argv, "cCf:guUv")) != -1) {
d135 1
a135 1
			core = optarg;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
