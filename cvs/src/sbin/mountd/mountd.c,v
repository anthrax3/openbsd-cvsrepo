head	1.85;
access;
symbols
	OPENBSD_6_1:1.85.0.6
	OPENBSD_6_1_BASE:1.85
	OPENBSD_6_0:1.85.0.4
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.79.0.6
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.72.0.4
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.71.0.14
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.71.0.12
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.71.0.10
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.8
	OPENBSD_5_0:1.71.0.6
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.71.0.4
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.71.0.2
	OPENBSD_4_8_BASE:1.71
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.69.0.10
	OPENBSD_4_6_BASE:1.69
	OPENBSD_4_5:1.69.0.6
	OPENBSD_4_5_BASE:1.69
	OPENBSD_4_4:1.69.0.4
	OPENBSD_4_4_BASE:1.69
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.68.0.2
	OPENBSD_4_2_BASE:1.68
	OPENBSD_4_1:1.67.0.4
	OPENBSD_4_1_BASE:1.67
	OPENBSD_4_0:1.67.0.2
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.65.0.2
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.63.0.2
	OPENBSD_3_8_BASE:1.63
	OPENBSD_3_7:1.62.0.6
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.62.0.4
	OPENBSD_3_6_BASE:1.62
	OPENBSD_3_5:1.62.0.2
	OPENBSD_3_5_BASE:1.62
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	OPENBSD_3_3:1.57.0.2
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	OPENBSD_2_6:1.29.0.2
	OPENBSD_2_6_BASE:1.29
	OPENBSD_2_5:1.28.0.2
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.26.0.2
	OPENBSD_2_4_BASE:1.26
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.85
date	2015.12.23.21.32.52;	author tim;	state Exp;
branches;
next	1.84;
commitid	FYkG3mCW9tulJA53;

1.84
date	2015.12.23.21.16.17;	author tim;	state Exp;
branches;
next	1.83;
commitid	bGq4FA66YCPj2e1L;

1.83
date	2015.12.15.18.17.34;	author tim;	state Exp;
branches;
next	1.82;
commitid	Y5eL0OyZteshopXm;

1.82
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.81;
commitid	82PdNqu2kKAuXPfA;

1.81
date	2015.08.20.22.16.35;	author millert;	state Exp;
branches;
next	1.80;
commitid	e62lBrztJdrskjEi;

1.80
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	0qPuuXwccpVXsXcV;

1.79
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	Uu5nFG3wCl0LACBb;

1.78
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.77;
commitid	HIbf8HnT4wFtIrOp;

1.77
date	2014.10.22.13.31.04;	author millert;	state Exp;
branches;
next	1.76;
commitid	Pxj2LPK20iZ3Aury;

1.76
date	2014.08.24.14.45.00;	author doug;	state Exp;
branches;
next	1.75;
commitid	AJdg5ADzWewBCXEI;

1.75
date	2014.05.16.17.30.28;	author millert;	state Exp;
branches;
next	1.74;

1.74
date	2014.04.22.20.25.16;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2014.03.24.00.19.48;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.22.16.35.27;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.30.13.41.09;	author sobrado;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.01.05.37.14;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.29.16.49.42;	author avsm;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.28.23.29.32;	author avsm;	state Exp;
branches;
next	1.65;

1.65
date	2005.09.20.22.40.35;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2005.09.13.02.53.28;	author drahn;	state Exp;
branches;
next	1.63;

1.63
date	2005.04.08.20.09.38;	author jaredy;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.16.20.14.42;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.09.20.33.14;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.26.16.09.27;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.16.01.42.27;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.14.00.51.15;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.13.09.09.26;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.09.00.30.24;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.05.22.41.36;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.18.08.46.18;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.18.08.41.05;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.11.21.23.29;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.29.23.19.49;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.26.09.24.35;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.04.20.57.17;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.17.19.42.28;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.16.21.27.36;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.02.02.05.59;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.17.19.54.57;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.03.18.54.29;	author hin;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.14.21.57.44;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.11.18.35.21;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.17.19.27.11;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.16.02.59.46;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.12.30.06.18.27;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.05.23.41.10;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.03.17.58.19;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.01.20.20.12;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	99.04.21.02.13.57;	author alex;	state Exp;
branches;
next	1.28;

1.28
date	99.03.07.21.02.08;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.12.28.08.04.27;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.08.11.16.18.36;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.06.23.23.34.14;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.03.01.20.06.30;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.12.19.09.21.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.09.29.19.31.05;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.09.13.12.24.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.08.13.18.59.26;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.08.09.12.59.14;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.08.06.01.45.21;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.06.24.20.59.10;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.05.04.21.05.28;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.04.11.17.09.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.01.15.23.41.28;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	96.12.10.07.26.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.12.05.23.14.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.09.28.05.47.42;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.09.19.06.12.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.29.17.41.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.02.10.43.56;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.25.15.57.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.21.00.16.16;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	95.12.27.12.32.42;	author david;	state Exp;
branches;
next	1.4;

1.4
date	95.12.14.01.33.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.13.05.07.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.11.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.85
log
@Remove unnecessary SIGSYS/ENOSYS handling for getfh(2).

Encouragement from deraadt@@
@
text
@/*	$OpenBSD: mountd.c,v 1.84 2015/12/23 21:16:17 tim Exp $	*/
/*	$NetBSD: mountd.c,v 1.31 1996/02/18 11:57:53 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Herb Hasler and Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <syslog.h>

#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_prot.h>
#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>

#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <grp.h>
#include <imsg.h>
#include <netdb.h>
#include <netgroup.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include "pathnames.h"

#include <stdarg.h>

#define isterminated(str, size) (memchr((str), '\0', (size)) != NULL)

/*
 * Structures for keeping the mount list and export list
 */
struct mountlist {
	struct mountlist *ml_next;
	char		ml_host[RPCMNT_NAMELEN+1];
	char		ml_dirp[RPCMNT_PATHLEN+1];
};

struct dirlist {
	struct dirlist	*dp_left;
	struct dirlist	*dp_right;
	int		dp_flag;
	struct hostlist	*dp_hosts;	/* List of hosts this dir exported to */
	char		dp_dirp[1];	/* Actually malloc'd to size of dir */
};
/* dp_flag bits */
#define	DP_DEFSET	0x1
#define DP_HOSTSET	0x2

struct exportlist {
	struct exportlist *ex_next;
	struct dirlist	*ex_dirl;
	struct dirlist	*ex_defdir;
	int		ex_flag;
	fsid_t		ex_fs;
	char		*ex_fsdir;
};
/* ex_flag bits */
#define	EX_LINKED	0x1

struct netmsk {
	in_addr_t	nt_net;
	in_addr_t	nt_mask;
	char		*nt_name;
};

union grouptypes {
	struct hostent *gt_hostent;
	struct netmsk	gt_net;
};

struct grouplist {
	int gr_type;
	union grouptypes gr_ptr;
	struct grouplist *gr_next;
};
/* Group types */
#define	GT_NULL		0x0
#define	GT_HOST		0x1
#define	GT_NET		0x2
#define	GT_IGNORE	0x5

struct hostlist {
	int		 ht_flag;	/* Uses DP_xx bits */
	struct grouplist *ht_grp;
	struct hostlist	 *ht_next;
};

struct fhreturn {
	int	fhr_flag;
	int	fhr_vers;
	nfsfh_t	fhr_fh;
};

#define IMSG_GETFH_REQ		0x0
#define IMSG_GETFH_RESP		0x1
#define IMSG_EXPORT_REQ		0x2
#define IMSG_EXPORT_RESP	0x3
#define IMSG_DELEXPORT		0x4
#define IMSG_MLIST_APPEND	0x5
#define IMSG_MLIST_OPEN		0x6
#define IMSG_MLIST_CLOSE	0x7
#define IMSG_MLIST_WRITE	0x8

struct getfh_resp {
	fhandle_t	gr_fh;
	int		gr_error;
};

struct export_req {
	char		er_path[MNAMELEN];
	struct export_args er_args;
	struct sockaddr	er_addr;
	struct sockaddr	er_mask;
};

/* Global defs */
char	*add_expdir(struct dirlist **, char *, int);
void	add_dlist(struct dirlist **, struct dirlist *, struct grouplist *, int);
void	add_mlist(char *, char *);
void	check_child(int);
int	check_dirpath(char *);
int	check_options(struct dirlist *);
int	chk_host(struct dirlist *, in_addr_t, int *, int *);
void	del_mlist(char *, char *);
struct dirlist *dirp_search(struct dirlist *, char *);
int	do_mount(struct exportlist *, struct grouplist *, int, struct xucred *,
	    char *, int);
int	do_opt(char **, char **, struct exportlist *, struct grouplist *,
	    int *, int *, struct xucred *);
struct	exportlist *ex_search(fsid_t *);
struct	exportlist *get_exp(void);
void	free_dir(struct dirlist *);
void	free_exp(struct exportlist *);
void	free_grp(struct grouplist *);
void	free_host(struct hostlist *);
void	new_exportlist(int signo);
void	get_exportlist(void);
int	get_host(char *, struct grouplist *, struct grouplist *);
int	get_num(char *);
struct hostlist *get_ht(void);
int	get_line(void);
void	get_mountlist(void);
int	get_net(char *, struct netmsk *, int);
void	getexp_err(struct exportlist *, struct grouplist *);
struct grouplist *get_grp(void);
void	hang_dirp(struct dirlist *, struct grouplist *, struct exportlist *,
	    int);
void	mntsrv(struct svc_req *, SVCXPRT *);
void	nextfield(char **, char **);
void	out_of_mem(void);
void	parsecred(char *, struct xucred *);
void	privchild(int);
int	put_exlist(struct dirlist *, XDR *, struct dirlist *, int *);
ssize_t	recv_imsg(struct imsg *);
int	scan_tree(struct dirlist *, in_addr_t);
int	send_imsg(u_int32_t, void *, u_int16_t);
void	send_umntall(int signo);
int	umntall_each(caddr_t, struct sockaddr_in *);
int	xdr_dir(XDR *, char *);
int	xdr_explist(XDR *, caddr_t);
int	xdr_fhs(XDR *, caddr_t);
int	xdr_mlist(XDR *, caddr_t);
void	mountd_svc_run(void);

struct exportlist *exphead;
struct mountlist *mlhead;
struct grouplist *grphead;
char exname[PATH_MAX];
struct xucred def_anon = {
	.cr_uid		= (uid_t) -2,
	.cr_gid		= (gid_t) -2,
	.cr_ngroups	= 0,
	.cr_groups	= { 0, }
};
int opt_flags;
/* Bits for above */
#define	OP_MAPROOT	0x01
#define	OP_MAPALL	0x02
#define	OP_MASK		0x08
#define	OP_NET		0x10
#define	OP_ALLDIRS	0x40

struct imsgbuf ibuf;
int debug = 0;

volatile sig_atomic_t gotchld;
volatile sig_atomic_t gothup;
volatile sig_atomic_t gotterm;

/*
 * Mountd server for NFS mount protocol as described in:
 * NFS: Network File System Protocol Specification, RFC1094, Appendix A
 * The optional arguments are the exports file name
 * default: _PATH_EXPORTS
 * "-d" to enable debugging
 */
int
main(int argc, char *argv[])
{
	SVCXPRT *udptransp, *tcptransp;
	FILE *pidfile;
	int c, socks[2];

	while ((c = getopt(argc, argv, "dnr")) != -1)
		switch (c) {
		case 'd':
			debug = 1;
			break;
		case 'n':
		case 'r':
			/* Compatibility */
			break;
		default:
			fprintf(stderr, "usage: mountd [-d] [exportsfile]\n");
			exit(1);
		}
	argc -= optind;
	argv += optind;
	grphead = NULL;
	exphead = NULL;
	mlhead = NULL;

	strlcpy(exname, argc == 1? *argv : _PATH_EXPORTS, sizeof(exname));

	openlog("mountd", LOG_PID, LOG_DAEMON);
	if (debug)
		fprintf(stderr, "Here we go.\n");
	if (debug == 0) {
		daemon(0, 0);
		signal(SIGINT, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
	}
	/* Store pid in file unless mountd is already running */
	pidfile = fopen(_PATH_MOUNTDPID, "r");
	if (pidfile != NULL) {
		if (fscanf(pidfile, "%d\n", &c) > 0 && c > 0) {
			if (kill(c, 0) == 0) {
				syslog(LOG_ERR, "Already running (pid %d)", c);
				exit(1);
			}
		}
		pidfile = freopen(_PATH_MOUNTDPID, "w", pidfile);
	} else {
		pidfile = fopen(_PATH_MOUNTDPID, "w");
	}
	if (pidfile) {
		fprintf(pidfile, "%ld\n", (long)getpid());
		fclose(pidfile);
	}

	signal(SIGCHLD, (void (*)(int)) check_child);
	signal(SIGHUP, (void (*)(int)) new_exportlist);

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, socks) == -1) {
		syslog(LOG_ERR, "socketpair: %m");
		exit(1);
	}

	switch (fork()) {
	case -1:
		syslog(LOG_ERR, "fork: %m");
		exit(1);
	case 0:
		close(socks[0]);
		privchild(socks[1]);
	}

	close(socks[1]);

	if (pledge("stdio rpath inet dns getpw", NULL) == -1) {
		syslog(LOG_ERR, "pledge: %m");
		exit(1);
	}

	signal(SIGTERM, (void (*)(int)) send_umntall);
	imsg_init(&ibuf, socks[0]);
	setproctitle("parent");

	if (debug)
		fprintf(stderr, "Getting export list.\n");
	get_exportlist();
	if (debug)
		fprintf(stderr, "Getting mount list.\n");
	get_mountlist();

	if ((udptransp = svcudp_create(RPC_ANYSOCK)) == NULL ||
	    (tcptransp = svctcp_create(RPC_ANYSOCK, 0, 0)) == NULL) {
		syslog(LOG_ERR, "Can't create socket");
		exit(1);
	}
	pmap_unset(RPCPROG_MNT, RPCMNT_VER1);
	pmap_unset(RPCPROG_MNT, RPCMNT_VER3);
	if (!svc_register(udptransp, RPCPROG_MNT, RPCMNT_VER1, mntsrv, IPPROTO_UDP) ||
	    !svc_register(udptransp, RPCPROG_MNT, RPCMNT_VER3, mntsrv, IPPROTO_UDP) ||
	    !svc_register(tcptransp, RPCPROG_MNT, RPCMNT_VER1, mntsrv, IPPROTO_TCP) ||
	    !svc_register(tcptransp, RPCPROG_MNT, RPCMNT_VER3, mntsrv, IPPROTO_TCP)) {
		syslog(LOG_ERR, "Can't register mount");
		exit(1);
	}
	mountd_svc_run();
	syslog(LOG_ERR, "Mountd died");
	exit(1);
}

void
check_child(int signo)
{
	gotchld = 1;
}

void
privchild(int sock)
{
	struct imsg imsg;
	struct pollfd pfd[1];
	struct ufs_args args;
	struct statfs sfb;
	struct getfh_resp resp;
	struct export_req *req;
	struct mountlist *ml;
	FILE *fp;
	char *path;
	int error, size;

	imsg_init(&ibuf, sock);
	setproctitle("[priv]");
	fp = NULL;

	for (;;) {
		if (gothup) {
			kill(getppid(), SIGHUP);
			gothup = 0;
		}

		pfd[0].fd = ibuf.fd;
		pfd[0].events = POLLIN;
		switch (poll(pfd, 1, INFTIM)) {
		case -1:
			if (errno == EINTR)
				continue;
			syslog(LOG_ERR, "poll: %m");
			_exit(1);
		case 0:
			continue;
		}
		if (pfd[0].revents & POLLHUP) {
			syslog(LOG_ERR, "Socket disconnected");
			_exit(1);
		}
		if (!(pfd[0].revents & POLLIN))
			continue;

		switch (imsg_read(&ibuf)) {
		case -1:
			syslog(LOG_ERR, "imsg_read: %m");
			_exit(1);
		case 0:
			syslog(LOG_ERR, "Socket disconnected");
			_exit(1);
		}

		while ((size = imsg_get(&ibuf, &imsg)) != 0) {
			if (size == -1) {
				syslog(LOG_ERR, "imsg_get: %m");
				_exit(1);
			}
			size -= IMSG_HEADER_SIZE;

			switch (imsg.hdr.type) {
			case IMSG_GETFH_REQ:
				if (size != PATH_MAX) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				path = imsg.data;
				if (getfh(path, &resp.gr_fh) == -1)
					resp.gr_error = errno;
				else
					resp.gr_error = 0;
				send_imsg(IMSG_GETFH_RESP, &resp, sizeof(resp));
				break;
			case IMSG_EXPORT_REQ:
				if (size != sizeof(*req)) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				req = imsg.data;
				if (statfs(req->er_path, &sfb) == -1) {
					error = errno;
					syslog(LOG_ERR, "statfs: %m");
					send_imsg(IMSG_EXPORT_RESP, &error,
					    sizeof(error));
					break;
				}
				args.fspec = 0;
				args.export_info = req->er_args;
				args.export_info.ex_addr = &req->er_addr;
				args.export_info.ex_mask = &req->er_mask;
				if (mount(sfb.f_fstypename, sfb.f_mntonname,
				    sfb.f_flags | MNT_UPDATE, &args) == -1) {
				    	error = errno;
				    	syslog(LOG_ERR, "mount: %m");
					send_imsg(IMSG_EXPORT_RESP, &error,
					    sizeof(error));
					break;
				}
				error = 0;
				send_imsg(IMSG_EXPORT_RESP, &error, sizeof(error));
				break;
			case IMSG_DELEXPORT:
				if (size != MNAMELEN) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				path = imsg.data;
				if (statfs(path, &sfb) == -1) {
					syslog(LOG_ERR, "statfs: %m");
					break;
				}
				memset(&args, 0, sizeof(args));
				args.export_info.ex_flags = MNT_DELEXPORT;
				if (mount(sfb.f_fstypename, sfb.f_mntonname,
				    sfb.f_flags | MNT_UPDATE, &args) == -1)
					syslog(LOG_ERR, "mount: %m");
				break;
			case IMSG_MLIST_APPEND:
				if (size != sizeof(*ml)) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				if (fp != NULL)
					break;
				ml = imsg.data;
				if (!isterminated(&ml->ml_host,
				    sizeof(ml->ml_host)) ||
				    !isterminated(&ml->ml_dirp,
				    sizeof(ml->ml_dirp)))
					break;
				fp = fopen(_PATH_RMOUNTLIST, "a");
				if (fp == NULL) {
					syslog(LOG_ERR, "fopen: %s: %m",
					    _PATH_RMOUNTLIST);
					break;
				}
				fprintf(fp, "%s %s\n", ml->ml_host,
				    ml->ml_dirp);
				fclose(fp);
				fp = NULL;
				break;
			case IMSG_MLIST_OPEN:
				if (size != 0) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				if (fp != NULL)
					break;
				fp = fopen(_PATH_RMOUNTLIST, "w");
				if (fp == NULL)
					syslog(LOG_ERR, "fopen: %s: %m",
					    _PATH_RMOUNTLIST);
				break;
			case IMSG_MLIST_WRITE:
				if (size != sizeof(*ml)) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				if (fp == NULL)
					break;
				ml = imsg.data;
				if (!isterminated(&ml->ml_host,
				    sizeof(ml->ml_host)) ||
				    !isterminated(&ml->ml_dirp,
				    sizeof(ml->ml_host)))
					break;
				fprintf(fp, "%s %s\n", ml->ml_host,
				    ml->ml_dirp);
				break;
			case IMSG_MLIST_CLOSE:
				if (size != 0) {
					syslog(LOG_ERR, "Invalid message size");
					break;
				}
				if (fp != NULL) {
					fclose(fp);
					fp = NULL;
				}
				break;
			default:
				syslog(LOG_ERR, "Unexpected message type");
				break;
			}

			imsg_free(&imsg);
		}
	}
}

int
imsg_getfh(char *path, fhandle_t *fh)
{
	struct imsg imsg;
	struct getfh_resp *resp;
	ssize_t size;

	if (send_imsg(IMSG_GETFH_REQ, path, PATH_MAX) == -1)
		return (-1);

	size = recv_imsg(&imsg);
	if (size == -1)
		return (-1);
	if (imsg.hdr.type != IMSG_GETFH_RESP || size != sizeof(*resp)) {
		syslog(LOG_ERR, "Invalid message");
		imsg_free(&imsg);
		errno = EINVAL;
		return (-1);
	}

	resp = imsg.data;
	*fh = resp->gr_fh;
	if (resp->gr_error) {
		errno = resp->gr_error;
		imsg_free(&imsg);
		return (-1);
	}

	imsg_free(&imsg);
	return (0);
}

int
imsg_export(const char *dir, struct export_args *args)
{
	struct export_req req;
	struct imsg imsg;
	ssize_t size;

	if (strlcpy(req.er_path, dir, sizeof(req.er_path)) >=
	    sizeof(req.er_path)) {
		syslog(LOG_ERR, "%s: mount dir too long", dir);
		errno = EINVAL;
		return (-1);
	}

	req.er_args = *args;
	if (args->ex_addrlen)
		req.er_addr = *args->ex_addr;
	if (args->ex_masklen)
		req.er_mask = *args->ex_mask;

	if (send_imsg(IMSG_EXPORT_REQ, &req, sizeof(req)) == -1)
		return (-1);

	size = recv_imsg(&imsg);
	if (size == -1)
		return (-1);
	if (imsg.hdr.type != IMSG_EXPORT_RESP || size != sizeof(int)) {
		syslog(LOG_ERR, "Invalid message");
		imsg_free(&imsg);
		errno = EINVAL;
		return (-1);
	}

	if (*(int *)imsg.data != 0) {
		errno = *(int *)imsg.data;
		imsg_free(&imsg);
		return (-1);
	}

	imsg_free(&imsg);
	return (0);
}

ssize_t
recv_imsg(struct imsg *imsg)
{
	ssize_t n;

	n = imsg_read(&ibuf);
	if (n == -1) {
		syslog(LOG_ERR, "imsg_read: %m");
		return (-1);
	}
	if (n == 0) {
		syslog(LOG_ERR, "Socket disconnected");
		errno = EINVAL;
		return (-1);
	}

	n = imsg_get(&ibuf, imsg);
	if (n == -1) {
		syslog(LOG_ERR, "imsg_get: %m");
		return (-1);
	}
	if (n == 0) {
		syslog(LOG_ERR, "No messages ready");
		errno = EINVAL;
		return (-1);
	}

	return (n - IMSG_HEADER_SIZE);
}

int
send_imsg(u_int32_t type, void *data, u_int16_t size)
{
	if (imsg_compose(&ibuf, type, 0, 0, -1, data, size) == -1) {
		syslog(LOG_ERR, "imsg_compose: %m");
		return (-1);
	}

	if (imsg_flush(&ibuf) == -1) {
		syslog(LOG_ERR, "imsg_flush: %m");
		return (-1);
	}

	return (0);
}

void
mountd_svc_run(void)
{
	struct pollfd *pfd = NULL, *newp;
	nfds_t saved_max_pollfd = 0;
	int nready, status;

	for (;;) {
		if (gotchld) {
			if (waitpid(WAIT_ANY, &status, WNOHANG) == -1) {
				syslog(LOG_ERR, "waitpid: %m");
				break;
			}
			if (WIFEXITED(status)) {
				syslog(LOG_ERR, "Child exited");
				break;
			}
			if (WIFSIGNALED(status)) {
				syslog(LOG_ERR, "Child terminated by signal");
				break;
			}
			gotchld = 0;
		}
		if (gothup) {
			get_exportlist();
			gothup = 0;
		}
		if (gotterm)
			break;
		if (svc_max_pollfd > saved_max_pollfd) {
			newp = reallocarray(pfd, svc_max_pollfd, sizeof(*pfd));
			if (!newp) {
				free(pfd);
				perror("mountd_svc_run: - realloc failed");
				return;
			}
			pfd = newp;
			saved_max_pollfd = svc_max_pollfd;
		}
		memcpy(pfd, svc_pollfd, svc_max_pollfd * sizeof(*pfd));

		nready = poll(pfd, svc_max_pollfd, INFTIM);
		switch (nready) {
		case -1:
			if (errno == EINTR)
				break;
			perror("mountd_svc_run: - poll failed");
			free(pfd);
			return;
		case 0:
			break;
		default:
			svc_getreq_poll(pfd, nready);
			break;
		}
	}

	(void) clnt_broadcast(RPCPROG_MNT, RPCMNT_VER1, RPCMNT_UMNTALL,
	    xdr_void, (caddr_t)0, xdr_void, (caddr_t)0, umntall_each);
	exit(0);
}

/*
 * The mount rpc service
 */
void
mntsrv(struct svc_req *rqstp, SVCXPRT *transp)
{
	char rpcpath[RPCMNT_PATHLEN+1], dirpath[PATH_MAX];
	struct hostent *hp = NULL;
	struct exportlist *ep;
	sigset_t sighup_mask;
	int defset, hostset;
	struct fhreturn fhr;
	struct dirlist *dp;
	struct statfs fsb;
	struct stat stb;
	in_addr_t saddr;
	u_short sport;
	long bad = 0;

	sigemptyset(&sighup_mask);
	sigaddset(&sighup_mask, SIGHUP);
	saddr = transp->xp_raddr.sin_addr.s_addr;
	sport = ntohs(transp->xp_raddr.sin_port);
	switch (rqstp->rq_proc) {
	case NULLPROC:
		if (!svc_sendreply(transp, xdr_void, NULL))
			syslog(LOG_ERR, "Can't send reply");
		return;
	case RPCMNT_MOUNT:
		if (debug)
			fprintf(stderr, "Got mount request from %s\n",
			    inet_ntoa(transp->xp_raddr.sin_addr));
		if (sport >= IPPORT_RESERVED) {
			syslog(LOG_NOTICE,
			    "Refused mount RPC from host %s port %d",
			    inet_ntoa(transp->xp_raddr.sin_addr), sport);
			svcerr_weakauth(transp);
			return;
		}
		if (!svc_getargs(transp, xdr_dir, rpcpath)) {
			svcerr_decode(transp);
			return;
		}
		if (debug)
			fprintf(stderr, "rpcpath: %s\n", rpcpath);

		/*
		 * Get the real pathname and make sure it is a file or
		 * directory that exists.
		 */
		if (realpath(rpcpath, dirpath) == NULL) {
			bad = errno;
			if (debug)
				fprintf(stderr, "realpath failed on %s\n",
				    rpcpath);
			strlcpy(dirpath, rpcpath, sizeof(dirpath));
		} else if (stat(dirpath, &stb) < 0 ||
		    (!S_ISDIR(stb.st_mode) && !S_ISREG(stb.st_mode)) ||
		    statfs(dirpath, &fsb) < 0) {
			if (debug)
				fprintf(stderr, "stat failed on %s\n", dirpath);
			bad = ENOENT;	/* We will send error reply later */
		}

		/* Check in the exports list */
		sigprocmask(SIG_BLOCK, &sighup_mask, NULL);
		ep = ex_search(&fsb.f_fsid);
		hostset = defset = 0;
		if (ep && (chk_host(ep->ex_defdir, saddr, &defset, &hostset) ||
		    ((dp = dirp_search(ep->ex_dirl, dirpath)) &&
		    chk_host(dp, saddr, &defset, &hostset)) ||
		    (defset && scan_tree(ep->ex_defdir, saddr) == 0 &&
		    scan_tree(ep->ex_dirl, saddr) == 0))) {
			if (bad) {
				if (!svc_sendreply(transp, xdr_long,
				    (caddr_t)&bad))
					syslog(LOG_ERR, "Can't send reply");
				sigprocmask(SIG_UNBLOCK, &sighup_mask, NULL);
				return;
			}
			if (hostset & DP_HOSTSET)
				fhr.fhr_flag = hostset;
			else
				fhr.fhr_flag = defset;
			fhr.fhr_vers = rqstp->rq_vers;
			/* Get the file handle */
			memset(&fhr.fhr_fh, 0, sizeof(nfsfh_t));
			if (imsg_getfh(dirpath, (fhandle_t *)&fhr.fhr_fh) < 0) {
				bad = errno;
				syslog(LOG_ERR, "Can't get fh for %s", dirpath);
				if (!svc_sendreply(transp, xdr_long,
				    (caddr_t)&bad))
					syslog(LOG_ERR, "Can't send reply");
				sigprocmask(SIG_UNBLOCK, &sighup_mask, NULL);
				return;
			}
			if (!svc_sendreply(transp, xdr_fhs, (caddr_t)&fhr))
				syslog(LOG_ERR, "Can't send reply");
			if (hp == NULL)
				hp = gethostbyaddr((caddr_t)&saddr,
				    sizeof(saddr), AF_INET);
			if (hp)
				add_mlist(hp->h_name, dirpath);
			else
				add_mlist(inet_ntoa(transp->xp_raddr.sin_addr),
					dirpath);
			if (debug) {
				fprintf(stderr,
				    "Mount successful for %s by %s.\n",
				    dirpath,
				    inet_ntoa(transp->xp_raddr.sin_addr));
			}
		} else
			bad = EACCES;

		if (bad && !svc_sendreply(transp, xdr_long, (caddr_t)&bad))
			syslog(LOG_ERR, "Can't send reply");
		sigprocmask(SIG_UNBLOCK, &sighup_mask, NULL);
		return;
	case RPCMNT_DUMP:
		if (!svc_sendreply(transp, xdr_mlist, NULL))
			syslog(LOG_ERR, "Can't send reply");
		return;
	case RPCMNT_UMOUNT:
		if (sport >= IPPORT_RESERVED) {
			svcerr_weakauth(transp);
			return;
		}
		if (!svc_getargs(transp, xdr_dir, dirpath)) {
			svcerr_decode(transp);
			return;
		}
		if (!svc_sendreply(transp, xdr_void, NULL))
			syslog(LOG_ERR, "Can't send reply");
		hp = gethostbyaddr((caddr_t)&saddr, sizeof(saddr), AF_INET);
		if (hp)
			del_mlist(hp->h_name, dirpath);
		del_mlist(inet_ntoa(transp->xp_raddr.sin_addr), dirpath);
		return;
	case RPCMNT_UMNTALL:
		if (sport >= IPPORT_RESERVED) {
			svcerr_weakauth(transp);
			return;
		}
		if (!svc_sendreply(transp, xdr_void, NULL))
			syslog(LOG_ERR, "Can't send reply");
		hp = gethostbyaddr((caddr_t)&saddr, sizeof(saddr), AF_INET);
		if (hp)
			del_mlist(hp->h_name, NULL);
		del_mlist(inet_ntoa(transp->xp_raddr.sin_addr), NULL);
		return;
	case RPCMNT_EXPORT:
		if (!svc_sendreply(transp, xdr_explist, NULL))
			syslog(LOG_ERR, "Can't send reply");
		return;
	default:
		svcerr_noproc(transp);
		return;
	}
}

/*
 * Xdr conversion for a dirpath string
 */
int
xdr_dir(XDR *xdrsp, char *dirp)
{
	return (xdr_string(xdrsp, &dirp, RPCMNT_PATHLEN));
}

/*
 * Xdr routine to generate file handle reply
 */
int
xdr_fhs(XDR *xdrsp, caddr_t cp)
{
	struct fhreturn *fhrp = (struct fhreturn *)cp;
	long ok = 0, len, auth;

	if (!xdr_long(xdrsp, &ok))
		return (0);
	switch (fhrp->fhr_vers) {
	case 1:
		return (xdr_opaque(xdrsp, (caddr_t)&fhrp->fhr_fh, NFSX_V2FH));
	case 3:
		len = NFSX_V3FH;
		if (!xdr_long(xdrsp, &len))
			return (0);
		if (!xdr_opaque(xdrsp, (caddr_t)&fhrp->fhr_fh, len))
			return (0);
		auth = RPCAUTH_UNIX;
		len = 1;
		if (!xdr_long(xdrsp, &len))
			return (0);
		return (xdr_long(xdrsp, &auth));
	}
	return (0);
}

int
xdr_mlist(XDR *xdrsp, caddr_t cp)
{
	int true = 1, false = 0;
	struct mountlist *mlp;
	char *strp;

	mlp = mlhead;
	while (mlp) {
		if (!xdr_bool(xdrsp, &true))
			return (0);
		strp = &mlp->ml_host[0];
		if (!xdr_string(xdrsp, &strp, RPCMNT_NAMELEN))
			return (0);
		strp = &mlp->ml_dirp[0];
		if (!xdr_string(xdrsp, &strp, RPCMNT_PATHLEN))
			return (0);
		mlp = mlp->ml_next;
	}
	if (!xdr_bool(xdrsp, &false))
		return (0);
	return (1);
}

/*
 * Xdr conversion for export list
 */
int
xdr_explist(XDR *xdrsp, caddr_t cp)
{
	struct exportlist *ep;
	int false = 0, putdef;
	sigset_t sighup_mask;

	sigemptyset(&sighup_mask);
	sigaddset(&sighup_mask, SIGHUP);
	sigprocmask(SIG_BLOCK, &sighup_mask, NULL);
	ep = exphead;
	while (ep) {
		putdef = 0;
		if (put_exlist(ep->ex_dirl, xdrsp, ep->ex_defdir, &putdef))
			goto errout;
		if (ep->ex_defdir && putdef == 0 && put_exlist(ep->ex_defdir,
		    xdrsp, NULL, &putdef))
			goto errout;
		ep = ep->ex_next;
	}
	sigprocmask(SIG_UNBLOCK, &sighup_mask, NULL);
	if (!xdr_bool(xdrsp, &false))
		return (0);
	return (1);
errout:
	sigprocmask(SIG_UNBLOCK, &sighup_mask, NULL);
	return (0);
}

/*
 * Called from xdr_explist() to traverse the tree and export the
 * directory paths.
 */
int
put_exlist(struct dirlist *dp, XDR *xdrsp, struct dirlist *adp,
    int *putdefp)
{
	int true = 1, false = 0, gotalldir = 0;
	struct grouplist *grp;
	struct hostlist *hp;
	char *strp;

	if (dp) {
		if (put_exlist(dp->dp_left, xdrsp, adp, putdefp))
			return (1);
		if (!xdr_bool(xdrsp, &true))
			return (1);
		strp = dp->dp_dirp;
		if (!xdr_string(xdrsp, &strp, RPCMNT_PATHLEN))
			return (1);
		if (adp && !strcmp(dp->dp_dirp, adp->dp_dirp)) {
			gotalldir = 1;
			*putdefp = 1;
		}
		if ((dp->dp_flag & DP_DEFSET) == 0 &&
		    (gotalldir == 0 || (adp->dp_flag & DP_DEFSET) == 0)) {
			hp = dp->dp_hosts;
			while (hp) {
				grp = hp->ht_grp;
				if (grp->gr_type == GT_HOST) {
					if (!xdr_bool(xdrsp, &true))
						return (1);
					strp = grp->gr_ptr.gt_hostent->h_name;
					if (!xdr_string(xdrsp, &strp,
					    RPCMNT_NAMELEN))
						return (1);
				} else if (grp->gr_type == GT_NET) {
					if (!xdr_bool(xdrsp, &true))
						return (1);
					strp = grp->gr_ptr.gt_net.nt_name;
					if (!xdr_string(xdrsp, &strp,
					    RPCMNT_NAMELEN))
						return (1);
				}
				hp = hp->ht_next;
				if (gotalldir && hp == NULL) {
					hp = adp->dp_hosts;
					gotalldir = 0;
				}
			}
		}
		if (!xdr_bool(xdrsp, &false))
			return (1);
		if (put_exlist(dp->dp_right, xdrsp, adp, putdefp))
			return (1);
	}
	return (0);
}

#define LINESIZ	10240
char line[LINESIZ];
FILE *exp_file;

void
new_exportlist(int signo)
{
	gothup = 1;

}

/*
 * Get the export list
 */
void
get_exportlist(void)
{
	int len, has_host, exflags, got_nondir, dirplen = 0, num;
	int lookup_failed, num_hosts, i, netgrp;
	char *cp, *endcp, *dirp = NULL, *hst, *usr, *dom, savedc;
	struct exportlist *ep, *ep2;
	struct grouplist *grp, *tgrp;
	struct exportlist **epp;
	struct dirlist *dirhead;
	struct statfs fsb, *ofsp, *fsp;
	struct hostent *hpe;
	struct xucred anon;
	struct fsarray {
		int exflags;
		char *mntonname;
	} *fstbl;

	/*
	 * First, get rid of the old list
	 */
	ep = exphead;
	while (ep) {
		ep2 = ep;
		ep = ep->ex_next;
		free_exp(ep2);
	}
	exphead = NULL;

	grp = grphead;
	while (grp) {
		tgrp = grp;
		grp = grp->gr_next;
		free_grp(tgrp);
	}
	grphead = NULL;

	/*
	 * And delete exports that are in the kernel for all local
	 * file systems.
	 * XXX: Should know how to handle all local exportable file systems
	 *      instead of just MOUNT_FFS.
	 */
	num = getmntinfo(&ofsp, MNT_NOWAIT);
	if (num == 0 && errno)
		syslog(LOG_ERR, "getmntinfo: %s", strerror(errno));

	fsp = ofsp;

	fstbl = calloc(num, sizeof (fstbl[0]));
	if (fstbl == NULL)
		out_of_mem();

	for (i = 0; i < num; i++) {

		if (!strncmp(fsp->f_fstypename, MOUNT_MFS, MFSNAMELEN) ||
		    !strncmp(fsp->f_fstypename, MOUNT_FFS, MFSNAMELEN) ||
		    !strncmp(fsp->f_fstypename, MOUNT_EXT2FS, MFSNAMELEN) ||
		    !strncmp(fsp->f_fstypename, MOUNT_MSDOS, MFSNAMELEN) ||
		    !strncmp(fsp->f_fstypename, MOUNT_CD9660, MFSNAMELEN)) {
			fstbl[i].exflags = MNT_DELEXPORT;
			fstbl[i].mntonname = fsp->f_mntonname;
		}
		fsp++;
	}

	/*
	 * Read in the exports file and build the list, calling mount() through
	 * the privileged child as we go along to push the export rules into
	 * the kernel.
	 */
	if ((exp_file = fopen(exname, "r")) == NULL) {
		syslog(LOG_ERR, "Can't open %s", exname);
		exit(2);
	}
	dirhead = NULL;
	while (get_line()) {
		if (debug)
			fprintf(stderr, "Got line %s\n",line);
		cp = line;
		nextfield(&cp, &endcp);
		if (*cp == '#')
			goto nextline;

		/*
		 * Set defaults.
		 */
		has_host = FALSE;
		num_hosts = 0;
		lookup_failed = FALSE;
		anon = def_anon;
		exflags = MNT_EXPORTED;
		got_nondir = 0;
		opt_flags = 0;
		ep = NULL;

		/*
		 * Create new exports list entry
		 */
		len = endcp-cp;
		tgrp = grp = get_grp();
		while (len > 0) {
			if (len > RPCMNT_NAMELEN) {
				getexp_err(ep, tgrp);
				goto nextline;
			}
			if (*cp == '-') {
				if (ep == NULL) {
					getexp_err(ep, tgrp);
					goto nextline;
				}
				if (debug)
					fprintf(stderr, "doing opt %s\n", cp);
				got_nondir = 1;
				if (do_opt(&cp, &endcp, ep, grp, &has_host,
				    &exflags, &anon)) {
					getexp_err(ep, tgrp);
					goto nextline;
				}
			} else if (*cp == '/') {
			    savedc = *endcp;
			    *endcp = '\0';
			    if (check_dirpath(cp) &&
				statfs(cp, &fsb) >= 0) {
				if (got_nondir) {
				    syslog(LOG_ERR, "Dirs must be first");
				    getexp_err(ep, tgrp);
				    goto nextline;
				}
				if (ep) {
				    if (ep->ex_fs.val[0] != fsb.f_fsid.val[0] ||
					ep->ex_fs.val[1] != fsb.f_fsid.val[1]) {
					getexp_err(ep, tgrp);
					goto nextline;
				    }
				} else {
				    /*
				     * See if this directory is already
				     * in the list.
				     */
				    ep = ex_search(&fsb.f_fsid);
				    if (ep == NULL) {
					int len;

					ep = get_exp();
					ep->ex_fs = fsb.f_fsid;
					len = strlen(fsb.f_mntonname) + 1;
					ep->ex_fsdir = malloc(len);
					if (ep->ex_fsdir)
					    strlcpy(ep->ex_fsdir,
					        fsb.f_mntonname, len);
					else
					    out_of_mem();
					if (debug)
					  fprintf(stderr,
					      "Making new ep fs=0x%x,0x%x\n",
					      fsb.f_fsid.val[0],
					      fsb.f_fsid.val[1]);
				    } else if (debug)
					fprintf(stderr,
					    "Found ep fs=0x%x,0x%x\n",
					    fsb.f_fsid.val[0],
					    fsb.f_fsid.val[1]);
				}

				/*
				 * Add dirpath to export mount point.
				 */
				dirp = add_expdir(&dirhead, cp, len);
				dirplen = len;
			    } else {
				getexp_err(ep, tgrp);
				goto nextline;
			    }
			    *endcp = savedc;
			} else {
			    savedc = *endcp;
			    *endcp = '\0';
			    got_nondir = 1;
			    if (ep == NULL) {
				getexp_err(ep, tgrp);
				goto nextline;
			    }

			    /*
			     * Get the host or netgroup.
			     */
			    setnetgrent(cp);
			    netgrp = getnetgrent((const char **)&hst,
				(const char **)&usr, (const char **)&dom);
			    do {
				if (has_host) {
				    grp->gr_next = get_grp();
				    grp = grp->gr_next;
				} else {
				    memset(grp, 0, sizeof(*grp));
				}
				if (netgrp) {
				    if (hst == NULL) {
					syslog(LOG_ERR,
					    "NULL hostname in netgroup %s, skipping",
					    cp);
					grp->gr_type = GT_IGNORE;
					lookup_failed = TRUE;
					continue;
				    } else if (get_host(hst, grp, tgrp)) {
					syslog(LOG_ERR,
					    "Unknown host (%s) in netgroup %s",
					    hst, cp);
					grp->gr_type = GT_IGNORE;
					lookup_failed = TRUE;
					continue;
				    }
				} else if (get_host(cp, grp, tgrp)) {
				    syslog(LOG_ERR,
					"Unknown host (%s) in line %s",
					cp, line);
				    grp->gr_type = GT_IGNORE;
				    lookup_failed = TRUE;
				    continue;
				}
				has_host = TRUE;
				num_hosts++;
			    } while (netgrp && getnetgrent((const char **)&hst,
				(const char **)&usr, (const char **)&dom));
			    endnetgrent();
			    *endcp = savedc;
			}
			cp = endcp;
			nextfield(&cp, &endcp);
			len = endcp - cp;
		}
		/*
		 * If the exports list is empty due to unresolvable hostnames
		 * we throw away the line.
		 */
		if (lookup_failed == TRUE && num_hosts == 0 &&
		    tgrp->gr_type == GT_IGNORE)  {
			getexp_err(ep, tgrp);
			goto nextline;
		}
		if (check_options(dirhead)) {
			getexp_err(ep, tgrp);
			goto nextline;
		}
		if (!has_host) {
			grp->gr_type = GT_HOST;
			if (debug)
				fprintf(stderr, "Adding a default entry\n");
			/* add a default group and make the grp list NULL */
			hpe = malloc(sizeof(struct hostent));
			if (hpe == NULL)
				out_of_mem();
			hpe->h_name = strdup("Default");
			if (hpe->h_name == NULL)
				out_of_mem();
			hpe->h_addrtype = AF_INET;
			hpe->h_length = sizeof (u_int32_t);
			hpe->h_addr_list = NULL;
			grp->gr_ptr.gt_hostent = hpe;

		/*
		 * Don't allow a network export coincide with a list of
		 * host(s) on the same line.
		 */
		} else if ((opt_flags & OP_NET) && tgrp->gr_next) {
			getexp_err(ep, tgrp);
			goto nextline;
		}

		/*
		 * Loop through hosts, pushing the exports into the kernel.
		 * After loop, tgrp points to the start of the list and
		 * grp points to the last entry in the list.
		 */
		grp = tgrp;
		do {

			/*
			 * remove filesystem from unexport list
			 * add MNT_DELEXPORT to exflags to clean up
			 * any old addrlist in the kernel
			 */

			for (i = 0; i < num; i++) {
				if ((fstbl[i].mntonname != NULL) &&
				    (strcmp(fsb.f_mntonname,
				    fstbl[i].mntonname) == 0) &&
				    (fstbl[i].exflags & MNT_DELEXPORT)) {
					exflags |= MNT_DELEXPORT;
					fstbl[i].exflags = 0;
					if (debug)
						fprintf(stderr, "removing  %s %s from unexport list\n", dirp, fstbl[i].mntonname);
				}
			}

			if (debug)
				fprintf(stderr, "exporting %s\n", dirp);
			/*
			 * Non-zero return indicates an error.  Return
			 * val of 1 means line is invalid (not just entry).
			 */
			i = do_mount(ep, grp, exflags, &anon, dirp, dirplen);
			exflags &= ~MNT_DELEXPORT;
			if (i == 1) {
				getexp_err(ep, tgrp);
				goto nextline;
			} else if (i == 2) {
				syslog(LOG_ERR,
				    "Bad exports list entry (%s) in line %s",
				    (grp->gr_type == GT_HOST)
				    ? grp->gr_ptr.gt_hostent->h_name
				    : (grp->gr_type == GT_NET)
				    ? grp->gr_ptr.gt_net.nt_name
				    : "Unknown", line);
			}
		} while (grp->gr_next && (grp = grp->gr_next));

		/*
		 * Success. Update the data structures.
		 */
		if (has_host) {
			hang_dirp(dirhead, tgrp, ep, opt_flags);
			grp->gr_next = grphead;
			grphead = tgrp;
		} else {
			hang_dirp(dirhead, NULL, ep,
				opt_flags);
			free_grp(grp);
		}
		dirhead = NULL;
		if ((ep->ex_flag & EX_LINKED) == 0) {
			ep2 = exphead;
			epp = &exphead;

			/*
			 * Insert in the list in alphabetical order.
			 */
			while (ep2 && strcmp(ep2->ex_fsdir, ep->ex_fsdir) < 0) {
				epp = &ep2->ex_next;
				ep2 = ep2->ex_next;
			}
			if (ep2)
				ep->ex_next = ep2;
			*epp = ep;
			ep->ex_flag |= EX_LINKED;
		}
nextline:
		if (dirhead) {
			free_dir(dirhead);
			dirhead = NULL;
		}
	}

	fsp = ofsp;
	for (i = 0; i < num; i++, fsp++) {
		if ((fstbl[i].exflags & MNT_DELEXPORT) == 0)
			continue;
		if (debug)
			fprintf(stderr, "unexporting %s %s\n",
			    fsp->f_mntonname, fstbl[i].mntonname);
		send_imsg(IMSG_DELEXPORT, fsp->f_mntonname,
		    sizeof(fsp->f_mntonname));
	}
	free(fstbl);
	fclose(exp_file);
}

/*
 * Allocate an export list element
 */
struct exportlist *
get_exp(void)
{
	struct exportlist *ep;

	ep = calloc(1, sizeof (struct exportlist));
	if (ep == NULL)
		out_of_mem();
	return (ep);
}

/*
 * Allocate a group list element
 */
struct grouplist *
get_grp(void)
{
	struct grouplist *gp;

	gp = calloc(1, sizeof (struct grouplist));
	if (gp == NULL)
		out_of_mem();
	return (gp);
}

/*
 * Clean up upon an error in get_exportlist().
 */
void
getexp_err(struct exportlist *ep, struct grouplist *grp)
{
	struct grouplist *tgrp;

	syslog(LOG_ERR, "Bad exports list line %s", line);
	if (ep && (ep->ex_flag & EX_LINKED) == 0)
		free_exp(ep);
	while (grp) {
		tgrp = grp;
		grp = grp->gr_next;
		free_grp(tgrp);
	}
}

/*
 * Search the export list for a matching fs.
 */
struct exportlist *
ex_search(fsid_t *fsid)
{
	struct exportlist *ep;

	ep = exphead;
	while (ep) {
		if (ep->ex_fs.val[0] == fsid->val[0] &&
		    ep->ex_fs.val[1] == fsid->val[1])
			return (ep);
		ep = ep->ex_next;
	}
	return (ep);
}

/*
 * Add a directory path to the list.
 */
char *
add_expdir(struct dirlist **dpp, char *cp, int len)
{
	struct dirlist *dp;

	/* do not need +1 because of dp_dirp[1] */
	dp = malloc(sizeof (struct dirlist) + len);
	if (dp == NULL)
		out_of_mem();
	dp->dp_left = *dpp;
	dp->dp_right = NULL;
	dp->dp_flag = 0;
	dp->dp_hosts = NULL;
	strlcpy(dp->dp_dirp, cp, len + 1);
	*dpp = dp;
	return (dp->dp_dirp);
}

/*
 * Hang the dir list element off the dirpath binary tree as required
 * and update the entry for host.
 */
void
hang_dirp(struct dirlist *dp, struct grouplist *grp, struct exportlist *ep,
    int flags)
{
	struct hostlist *hp;
	struct dirlist *dp2;

	if (flags & OP_ALLDIRS) {
		if (ep->ex_defdir)
			free((caddr_t)dp);
		else
			ep->ex_defdir = dp;
		if (grp == NULL) {
			ep->ex_defdir->dp_flag |= DP_DEFSET;
		} else while (grp) {
			hp = get_ht();
			hp->ht_grp = grp;
			hp->ht_next = ep->ex_defdir->dp_hosts;
			ep->ex_defdir->dp_hosts = hp;
			grp = grp->gr_next;
		}
	} else {

		/*
		 * Loop through the directories adding them to the tree.
		 */
		while (dp) {
			dp2 = dp->dp_left;
			add_dlist(&ep->ex_dirl, dp, grp, flags);
			dp = dp2;
		}
	}
}

/*
 * Traverse the binary tree either updating a node that is already there
 * for the new directory or adding the new node.
 */
void
add_dlist(struct dirlist **dpp, struct dirlist *newdp, struct grouplist *grp,
    int flags)
{
	struct dirlist *dp;
	struct hostlist *hp;
	int cmp;

	dp = *dpp;
	if (dp) {
		cmp = strcmp(dp->dp_dirp, newdp->dp_dirp);
		if (cmp > 0) {
			add_dlist(&dp->dp_left, newdp, grp, flags);
			return;
		} else if (cmp < 0) {
			add_dlist(&dp->dp_right, newdp, grp, flags);
			return;
		} else
			free((caddr_t)newdp);
	} else {
		dp = newdp;
		dp->dp_left = NULL;
		*dpp = dp;
	}
	if (grp) {

		/*
		 * Hang all of the host(s) off of the directory point.
		 */
		do {
			hp = get_ht();
			hp->ht_grp = grp;
			hp->ht_next = dp->dp_hosts;
			dp->dp_hosts = hp;
			grp = grp->gr_next;
		} while (grp);
	} else {
		dp->dp_flag |= DP_DEFSET;
	}
}

/*
 * Search for a dirpath on the export point.
 */
struct dirlist *
dirp_search(struct dirlist *dp, char *dirpath)
{
	int cmp;

	if (dp) {
		cmp = strcmp(dp->dp_dirp, dirpath);
		if (cmp > 0)
			return (dirp_search(dp->dp_left, dirpath));
		else if (cmp < 0)
			return (dirp_search(dp->dp_right, dirpath));
		else
			return (dp);
	}
	return (dp);
}

/*
 * Scan for a host match in a directory tree.
 */
int
chk_host(struct dirlist *dp, in_addr_t saddr, int *defsetp, int *hostsetp)
{
	struct hostlist *hp;
	struct grouplist *grp;
	u_int32_t **addrp;

	if (dp) {
		if (dp->dp_flag & DP_DEFSET)
			*defsetp = dp->dp_flag;
		hp = dp->dp_hosts;
		while (hp) {
			grp = hp->ht_grp;
			switch (grp->gr_type) {
			case GT_HOST:
			    addrp = (u_int32_t **)
				grp->gr_ptr.gt_hostent->h_addr_list;
			    while (*addrp) {
				if (**addrp == saddr) {
				    *hostsetp = (hp->ht_flag | DP_HOSTSET);
				    return (1);
				}
				addrp++;
			    }
			    break;
			case GT_NET:
			    if ((saddr & grp->gr_ptr.gt_net.nt_mask) ==
				grp->gr_ptr.gt_net.nt_net) {
				*hostsetp = (hp->ht_flag | DP_HOSTSET);
				return (1);
			    }
			    break;
			}
			hp = hp->ht_next;
		}
	}
	return (0);
}

/*
 * Scan tree for a host that matches the address.
 */
int
scan_tree(struct dirlist *dp, in_addr_t saddr)
{
	int defset, hostset;

	if (dp) {
		if (scan_tree(dp->dp_left, saddr))
			return (1);
		if (chk_host(dp, saddr, &defset, &hostset))
			return (1);
		if (scan_tree(dp->dp_right, saddr))
			return (1);
	}
	return (0);
}

/*
 * Traverse the dirlist tree and free it up.
 */
void
free_dir(struct dirlist *dp)
{

	if (dp) {
		free_dir(dp->dp_left);
		free_dir(dp->dp_right);
		free_host(dp->dp_hosts);
		free((caddr_t)dp);
	}
}

/*
 * Parse the option string and update fields.
 * Option arguments may either be -<option>=<value> or
 * -<option> <value>
 */
int
do_opt(char **cpp, char **endcpp, struct exportlist *ep, struct grouplist *grp,
    int *has_hostp, int *exflagsp, struct xucred *cr)
{
	char *cp, *endcp, *cpopt, savedc, savedc2 = 0;
	char *cpoptarg, *cpoptend;
	int allflag, usedarg;

	cpopt = *cpp;
	cpopt++;
	cp = *endcpp;
	savedc = *cp;
	*cp = '\0';
	while (cpopt && *cpopt) {
		allflag = 1;
		usedarg = -2;
		if ((cpoptend = strchr(cpopt, ','))) {
			*cpoptend++ = '\0';
			if ((cpoptarg = strchr(cpopt, '=')))
				*cpoptarg++ = '\0';
		} else {
			if ((cpoptarg = strchr(cpopt, '=')))
				*cpoptarg++ = '\0';
			else {
				*cp = savedc;
				nextfield(&cp, &endcp);
				**endcpp = '\0';
				if (endcp > cp && *cp != '-') {
					cpoptarg = cp;
					savedc2 = *endcp;
					*endcp = '\0';
					usedarg = 0;
				}
			}
		}
		if (!strcmp(cpopt, "ro") || !strcmp(cpopt, "o")) {
			*exflagsp |= MNT_EXRDONLY;
		} else if (cpoptarg && (!strcmp(cpopt, "maproot") ||
		    !(allflag = strcmp(cpopt, "mapall")) ||
		    !strcmp(cpopt, "root") || !strcmp(cpopt, "r"))) {
			usedarg++;
			parsecred(cpoptarg, cr);
			if (allflag == 0) {
				*exflagsp |= MNT_EXPORTANON;
				opt_flags |= OP_MAPALL;
			} else
				opt_flags |= OP_MAPROOT;
		} else
		    if (cpoptarg && (!strcmp(cpopt, "mask") ||
				     !strcmp(cpopt, "m"))) {
			if (get_net(cpoptarg, &grp->gr_ptr.gt_net, 1)) {
				syslog(LOG_ERR, "Bad mask: %s", cpoptarg);
				return (1);
			}
			usedarg++;
			opt_flags |= OP_MASK;
		} else if (cpoptarg && (!strcmp(cpopt, "network") ||
		    !strcmp(cpopt, "n"))) {
			if (grp->gr_type != GT_NULL) {
				syslog(LOG_ERR, "Network/host conflict");
				return (1);
			} else if (get_net(cpoptarg, &grp->gr_ptr.gt_net, 0)) {
				syslog(LOG_ERR, "Bad net: %s", cpoptarg);
				return (1);
			}
			grp->gr_type = GT_NET;
			*has_hostp = 1;
			usedarg++;
			opt_flags |= OP_NET;
		} else if (!strcmp(cpopt, "alldirs")) {
			opt_flags |= OP_ALLDIRS;
		} else {
			syslog(LOG_ERR, "Bad opt %s", cpopt);
			return (1);
		}
		if (usedarg >= 0) {
			*endcp = savedc2;
			**endcpp = savedc;
			if (usedarg > 0) {
				*cpp = cp;
				*endcpp = endcp;
			}
			return (0);
		}
		cpopt = cpoptend;
	}
	**endcpp = savedc;
	return (0);
}

/*
 * Translate a character string to the corresponding list of network
 * addresses for a hostname.
 */
int
get_host(char *cp, struct grouplist *grp, struct grouplist *tgrp)
{
	struct hostent *hp, *nhp, t_host;
	struct grouplist *checkgrp;
	char **addrp, **naddrp;
	struct in_addr saddr;
	char *aptr[2];
	int i;

	if (grp->gr_type != GT_NULL)
		return (1);
	if ((hp = gethostbyname(cp)) == NULL) {
		if (isdigit((unsigned char)*cp)) {
			if (inet_aton(cp, &saddr) == 0) {
				syslog(LOG_ERR, "inet_aton failed for %s", cp);
				return (1);
			}
			if ((hp = gethostbyaddr((caddr_t)&saddr.s_addr,
			    sizeof (saddr.s_addr), AF_INET)) == NULL) {
				hp = &t_host;
				hp->h_name = cp;
				hp->h_addrtype = AF_INET;
				hp->h_length = sizeof (u_int32_t);
				hp->h_addr_list = aptr;
				aptr[0] = (char *)&saddr;
				aptr[1] = NULL;
			}
		} else {
			syslog(LOG_ERR, "gethostbyname; failed for %s: %s", cp,
			    hstrerror(h_errno));
			return (1);
		}
	}

	/* only insert each host onto the list once */
	for (checkgrp = tgrp; checkgrp; checkgrp = checkgrp->gr_next) {
		if (checkgrp->gr_type == GT_HOST &&
		    checkgrp->gr_ptr.gt_hostent != NULL &&
		    !strcmp(checkgrp->gr_ptr.gt_hostent->h_name, hp->h_name)) {
			grp->gr_type = GT_IGNORE;
			return (0);
		}
	}

	grp->gr_type = GT_HOST;
	nhp = grp->gr_ptr.gt_hostent = malloc(sizeof(struct hostent));
	if (nhp == NULL)
		out_of_mem();
	memcpy(nhp, hp, sizeof(struct hostent));
	i = strlen(hp->h_name)+1;
	nhp->h_name = malloc(i);
	if (nhp->h_name == NULL)
		out_of_mem();
	memcpy(nhp->h_name, hp->h_name, i);
	addrp = hp->h_addr_list;
	i = 1;
	while (*addrp++)
		i++;
	naddrp = nhp->h_addr_list = reallocarray(NULL, i, sizeof(char *));
	if (naddrp == NULL)
		out_of_mem();
	addrp = hp->h_addr_list;
	while (*addrp) {
		*naddrp = malloc(hp->h_length);
		if (*naddrp == NULL)
		    out_of_mem();
		memcpy(*naddrp, *addrp, hp->h_length);
		addrp++;
		naddrp++;
	}
	*naddrp = NULL;
	if (debug)
		fprintf(stderr, "got host %s\n", hp->h_name);
	return (0);
}

/*
 * Free up an exports list component
 */
void
free_exp(struct exportlist *ep)
{

	if (ep->ex_defdir) {
		free_host(ep->ex_defdir->dp_hosts);
		free((caddr_t)ep->ex_defdir);
	}
	free(ep->ex_fsdir);
	free_dir(ep->ex_dirl);
	free((caddr_t)ep);
}

/*
 * Free hosts.
 */
void
free_host(struct hostlist *hp)
{
	struct hostlist *hp2;

	while (hp) {
		hp2 = hp;
		hp = hp->ht_next;
		free((caddr_t)hp2);
	}
}

struct hostlist *
get_ht(void)
{
	struct hostlist *hp;

	hp = malloc(sizeof (struct hostlist));
	if (hp == NULL)
		out_of_mem();
	hp->ht_next = NULL;
	hp->ht_flag = 0;
	return (hp);
}

/*
 * Out of memory, fatal
 */
void
out_of_mem(void)
{

	syslog(LOG_ERR, "Out of memory");
	exit(2);
}

/*
 * Do the mount syscall with the update flag to push the export info into
 * the kernel.  Returns 0 on success, 1 for fatal error, and 2 for error
 * that only invalidates the specific entry/host.
 */
int
do_mount(struct exportlist *ep, struct grouplist *grp, int exflags,
    struct xucred *anoncrp, char *dirp, int dirplen)
{
	struct sockaddr_in sin, imask;
	struct export_args args;
	char savedc = '\0';
	u_int32_t **addrp;
	char *cp = NULL;
	in_addr_t net;
	int done;

	args.ex_flags = exflags;
	args.ex_anon = *anoncrp;
	memset(&sin, 0, sizeof(sin));
	memset(&imask, 0, sizeof(imask));
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof(sin);
	imask.sin_family = AF_INET;
	imask.sin_len = sizeof(sin);
	if (grp->gr_type == GT_HOST)
		addrp = (u_int32_t **)grp->gr_ptr.gt_hostent->h_addr_list;
	else
		addrp = NULL;

	done = FALSE;
	while (!done) {
		switch (grp->gr_type) {
		case GT_HOST:
			args.ex_addr = (struct sockaddr *)&sin;
			args.ex_masklen = 0;
			if (!addrp) {
				args.ex_addrlen = 0;
				break;
			}
			sin.sin_addr.s_addr = **addrp;
			args.ex_addrlen = sizeof(sin);
			break;
		case GT_NET:
			sin.sin_addr.s_addr = grp->gr_ptr.gt_net.nt_net;
			args.ex_addr = (struct sockaddr *)&sin;
			args.ex_addrlen = sizeof (sin);
			args.ex_mask = (struct sockaddr *)&imask;
			args.ex_masklen = sizeof (imask);
			if (grp->gr_ptr.gt_net.nt_mask) {
				imask.sin_addr.s_addr = grp->gr_ptr.gt_net.nt_mask;
				break;
			}
			net = ntohl(grp->gr_ptr.gt_net.nt_net);
			if (IN_CLASSA(net))
				imask.sin_addr.s_addr = inet_addr("255.0.0.0");
			else if (IN_CLASSB(net))
				imask.sin_addr.s_addr = inet_addr("255.255.0.0");
			else
				imask.sin_addr.s_addr = inet_addr("255.255.255.0");
			grp->gr_ptr.gt_net.nt_mask = imask.sin_addr.s_addr;
			break;
		case GT_IGNORE:
			return (0);
		default:
			syslog(LOG_ERR, "Bad grouptype");
			if (cp)
				*cp = savedc;
			return (1);
		}

		/*
		 * XXX:
		 * Maybe I should just use the fsb->f_mntonname path instead
		 * of looping back up the dirp to the mount point??
		 * Also, needs to know how to export all types of local
		 * exportable file systems and not just MOUNT_FFS.
		 */
		while (imsg_export(dirp, &args) == -1) {
			if (cp)
				*cp-- = savedc;
			else
				cp = dirp + dirplen - 1;
			if (errno == EPERM) {
				syslog(LOG_ERR,
				    "Can't change attributes for %s (%s).\n",
				    dirp,
				    (grp->gr_type == GT_HOST)
				    ?grp->gr_ptr.gt_hostent->h_name
				    :(grp->gr_type == GT_NET)
				    ?grp->gr_ptr.gt_net.nt_name
				    :"Unknown");
				return (2);
			}
			if (opt_flags & OP_ALLDIRS) {
#if 0
				syslog(LOG_ERR, "Could not remount %s: %m",
					dirp);
				return (2);
#endif
			}
			/* back up over the last component */
			while (*cp == '/' && cp > dirp)
				cp--;
			while (*(cp - 1) != '/' && cp > dirp)
				cp--;
			if (cp == dirp) {
				if (debug)
					fprintf(stderr, "mnt unsucc\n");
				syslog(LOG_ERR, "Can't export %s: %m", dirp);
				return (2);
			}
			savedc = *cp;
			*cp = '\0';
		}
		if (addrp) {
			++addrp;
			if (*addrp == NULL)
				done = TRUE;
		} else
			done = TRUE;
	}
	if (cp)
		*cp = savedc;
	return (0);
}

/*
 * Translate a net address.
 */
int
get_net(char *cp, struct netmsk *net, int maskflg)
{
	struct in_addr inetaddr, inetaddr2;
	in_addr_t netaddr;
	struct netent *np;
	char *name;

	if ((netaddr = inet_network(cp)) != INADDR_NONE) {
		inetaddr = inet_makeaddr(netaddr, 0);
		/*
		 * Due to arbitrary subnet masks, you don't know how many
		 * bits to shift the address to make it into a network,
		 * however you do know how to make a network address into
		 * a host with host == 0 and then compare them.
		 * (What a pest)
		 */
		if (!maskflg) {
			setnetent(0);
			while ((np = getnetent())) {
				inetaddr2 = inet_makeaddr(np->n_net, 0);
				if (inetaddr2.s_addr == inetaddr.s_addr)
					break;
			}
			endnetent();
		}
	} else {
		if ((np = getnetbyname(cp)))
			inetaddr = inet_makeaddr(np->n_net, 0);
		else
			return (1);
	}
	if (maskflg)
		net->nt_mask = inetaddr.s_addr;
	else {
		int len;

		if (np)
			name = np->n_name;
		else
			name = inet_ntoa(inetaddr);
		len = strlen(name) + 1;
		net->nt_name = malloc(len);
		if (net->nt_name == NULL)
			out_of_mem();
		strlcpy(net->nt_name, name, len);
		net->nt_net = inetaddr.s_addr;
	}
	return (0);
}

/*
 * Parse out the next white space separated field
 */
void
nextfield(char **cp, char **endcp)
{
	char *p;

	p = *cp;
	while (*p == ' ' || *p == '\t')
		p++;
	if (*p == '\n' || *p == '\0')
		*cp = *endcp = p;
	else {
		*cp = p++;
		while (*p != ' ' && *p != '\t' && *p != '\n' && *p != '\0')
			p++;
		*endcp = p;
	}
}

/*
 * Get an exports file line. Skip over blank lines and handle line
 * continuations.
 */
int
get_line(void)
{
	int totlen, cont_line, len;
	char *p, *cp;

	/*
	 * Loop around ignoring blank lines and getting all continuation lines.
	 */
	p = line;
	totlen = 0;
	do {
		if (fgets(p, LINESIZ - totlen, exp_file) == NULL)
			return (0);
		len = strlen(p);
		cp = p + len - 1;
		cont_line = 0;
		while (cp >= p && (*cp == ' ' || *cp == '\t' || *cp == '\n' ||
		    *cp == '\\')) {
			if (*cp == '\\')
				cont_line = 1;
			cp--;
			len--;
		}
		*++cp = '\0';
		if (len > 0) {
			totlen += len;
			if (totlen >= LINESIZ) {
				syslog(LOG_ERR, "Exports line too long");
				exit(2);
			}
			p = cp;
		}
	} while (totlen == 0 || cont_line);
	return (1);
}

/*
 * Parse a description of a credential.
 */
void
parsecred(char *namelist, struct xucred *cr)
{
	gid_t groups[NGROUPS_MAX + 1];
	char *name, *names;
	struct passwd *pw;
	struct group *gr;
	int ngroups, cnt;

	/*
	 * Set up the unprivileged user.
	 */
	*cr = def_anon;

	/*
	 * Get the user's password table entry.
	 */
	names = strsep(&namelist, " \t\n");
	name = strsep(&names, ":");
	if (isdigit((unsigned char)*name) || *name == '-')
		pw = getpwuid(atoi(name));
	else
		pw = getpwnam(name);
	/*
	 * Credentials specified as those of a user.
	 */
	if (names == NULL) {
		if (pw == NULL) {
			syslog(LOG_ERR, "Unknown user: %s", name);
			return;
		}
		cr->cr_uid = pw->pw_uid;
		ngroups = NGROUPS_MAX + 1;
		if (getgrouplist(pw->pw_name, pw->pw_gid, groups, &ngroups))
			syslog(LOG_ERR, "Too many groups for %s: %m", pw->pw_name);
		/*
		 * compress out duplicate
		 */
		cr->cr_ngroups = ngroups - 1;
		cr->cr_gid = groups[0];
		for (cnt = 1; cnt < ngroups; cnt++)
			cr->cr_groups[cnt - 1] = groups[cnt];
		return;
	}
	/*
	 * Explicit credential specified as a colon separated list:
	 *	uid:gid:gid:...
	 */
	if (pw != NULL)
		cr->cr_uid = pw->pw_uid;
	else if (isdigit((unsigned char)*name) || *name == '-')
		cr->cr_uid = atoi(name);
	else {
		syslog(LOG_ERR, "Unknown user: %s", name);
		return;
	}
	cr->cr_ngroups = 0;
	while (names != NULL && *names != '\0' && cr->cr_ngroups < NGROUPS_MAX) {
		name = strsep(&names, ":");
		if (isdigit((unsigned char)*name) || *name == '-') {
			cr->cr_groups[cr->cr_ngroups++] = atoi(name);
		} else {
			if ((gr = getgrnam(name)) == NULL) {
				syslog(LOG_ERR, "Unknown group: %s", name);
				continue;
			}
			cr->cr_groups[cr->cr_ngroups++] = gr->gr_gid;
		}
	}
	if (names != NULL && *names != '\0' && cr->cr_ngroups == NGROUPS_MAX)
		syslog(LOG_ERR, "Too many groups");
}

#define	STRSIZ	(RPCMNT_NAMELEN+RPCMNT_PATHLEN+50)
/*
 * Routines that maintain the remote mounttab
 */
void
get_mountlist(void)
{
	struct mountlist *mlp, **mlpp;
	char *host, *dirp, *cp;
	char str[STRSIZ];
	FILE *mlfile;

	if ((mlfile = fopen(_PATH_RMOUNTLIST, "r")) == NULL) {
		syslog(LOG_ERR, "Can't open %s: %m", _PATH_RMOUNTLIST);
		return;
	}
	mlpp = &mlhead;
	while (fgets(str, STRSIZ, mlfile) != NULL) {
		cp = str;
		host = strsep(&cp, " \t\n");
		dirp = strsep(&cp, " \t\n");
		if (host == NULL || dirp == NULL)
			continue;
		mlp = malloc(sizeof (*mlp));
		if (mlp == NULL)
			out_of_mem();
		strlcpy(mlp->ml_host, host, sizeof(mlp->ml_host));
		strlcpy(mlp->ml_dirp, dirp, sizeof(mlp->ml_dirp));
		mlp->ml_next = NULL;
		*mlpp = mlp;
		mlpp = &mlp->ml_next;
	}
	fclose(mlfile);
}

void
del_mlist(char *hostp, char *dirp)
{
	struct mountlist *mlp, **mlpp;
	struct mountlist *mlp2;
	int fnd = 0;

	mlpp = &mlhead;
	mlp = mlhead;
	while (mlp) {
		if (!strcmp(mlp->ml_host, hostp) &&
		    (!dirp || !strcmp(mlp->ml_dirp, dirp))) {
			fnd = 1;
			mlp2 = mlp;
			*mlpp = mlp = mlp->ml_next;
			free((caddr_t)mlp2);
		} else {
			mlpp = &mlp->ml_next;
			mlp = mlp->ml_next;
		}
	}
	if (fnd) {
		send_imsg(IMSG_MLIST_OPEN, NULL, 0);
		mlp = mlhead;
		while (mlp) {
			send_imsg(IMSG_MLIST_WRITE, mlp, sizeof(*mlp));
			mlp = mlp->ml_next;
		}
		send_imsg(IMSG_MLIST_CLOSE, NULL, 0);
	}
}

void
add_mlist(char *hostp, char *dirp)
{
	struct mountlist *mlp, **mlpp;

	mlpp = &mlhead;
	mlp = mlhead;
	while (mlp) {
		if (!strcmp(mlp->ml_host, hostp) && !strcmp(mlp->ml_dirp, dirp))
			return;
		mlpp = &mlp->ml_next;
		mlp = mlp->ml_next;
	}
	mlp = malloc(sizeof (*mlp));
	if (mlp == NULL)
		out_of_mem();
	strlcpy(mlp->ml_host, hostp, sizeof(mlp->ml_host));
	strlcpy(mlp->ml_dirp, dirp, sizeof(mlp->ml_dirp));
	mlp->ml_next = NULL;
	*mlpp = mlp;
	send_imsg(IMSG_MLIST_APPEND, mlp, sizeof(*mlp));
}

/*
 * This function is called via SIGTERM when the system is going down.
 * It sends a broadcast RPCMNT_UMNTALL.
 */
void
send_umntall(int signo)
{
	gotterm = 1;
}

int
umntall_each(caddr_t resultsp, struct sockaddr_in *raddr)
{
	return (1);
}

/*
 * Free up a group list.
 */
void
free_grp(struct grouplist *grp)
{
	char **addrp;

	if (grp->gr_type == GT_HOST) {
		if (grp->gr_ptr.gt_hostent->h_name) {
			addrp = grp->gr_ptr.gt_hostent->h_addr_list;
			while (addrp && *addrp)
				free(*addrp++);
			free((caddr_t)grp->gr_ptr.gt_hostent->h_addr_list);
			free(grp->gr_ptr.gt_hostent->h_name);
		}
		free((caddr_t)grp->gr_ptr.gt_hostent);
	} else if (grp->gr_type == GT_NET) {
		free(grp->gr_ptr.gt_net.nt_name);
	}
	free((caddr_t)grp);
}

/*
 * Check options for consistency.
 */
int
check_options(struct dirlist *dp)
{

	if (dp == NULL)
		return (1);
	if ((opt_flags & (OP_MAPROOT | OP_MAPALL)) == (OP_MAPROOT | OP_MAPALL)) {
		syslog(LOG_ERR, "-mapall and -maproot mutually exclusive");
		return (1);
	}
	if ((opt_flags & OP_MASK) && (opt_flags & OP_NET) == 0) {
		syslog(LOG_ERR, "-mask requires -network");
		return (1);
	}
	if ((opt_flags & OP_ALLDIRS) && dp->dp_left) {
		syslog(LOG_ERR, "-alldirs has multiple directories");
		return (1);
	}
	return (0);
}

/*
 * Check an absolute directory path for any symbolic links. Return true
 * if no symbolic links are found.
 */
int
check_dirpath(char *dirp)
{
	struct stat sb;
	int ret = 1;
	char *cp;

	/* Remove trailing '/' */
	cp = dirp + strlen(dirp) - 1;
	while (cp > dirp && *cp == '/')
		*cp-- = '\0';

	cp = dirp + 1;
	while (*cp && ret) {
		if (*cp == '/') {
			*cp = '\0';
			if (lstat(dirp, &sb) < 0 || !S_ISDIR(sb.st_mode))
				ret = 0;
			*cp = '/';
		}
		cp++;
	}
	if (lstat(dirp, &sb) < 0 ||
	    (!S_ISDIR(sb.st_mode) && !S_ISREG(sb.st_mode)))
		ret = 0;
	return (ret);
}
@


1.84
log
@Add privilege separation and pledge().

A privileged (that is, unpledged) child is forked that makes the "unpledgable"
getfh(2) and mount(2) calls. It also takes care of writing /var/db/mountdtab so
that the parent does not have to pledge "cpath wpath".

This, then, allows the parent to pledge "stdio rpath inet dns".

Suggestions and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.83 2015/12/15 18:17:34 tim Exp $	*/
a369 1
	signal(SIGSYS, SIG_IGN);
a813 6
				if (errno == ENOSYS) {
					syslog(LOG_ERR,
					    "Kernel does not support NFS exporting, "
					    "mountd aborting..");
					_exit(1);
				}
@


1.83
log
@When (re)reading /etc/exports, handle the case where the mount point of an
export is not also the mount point of a local filesystem. In this case, the
local filesystem would not be removed from the "unexport list", causing the
export to be "unexported" again.

This fix then also allows us to actually delete an export that has been removed
from /etc/exports, by passing the MNT_DELEXPORT export flag to mount(2).

Makes sense to millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.82 2015/12/10 17:27:00 mmcc Exp $	*/
d39 1
d42 2
d57 1
d72 2
d139 22
d165 1
d172 1
a172 1
	    char *, int, struct statfs *);
d197 1
d199 1
d201 1
d228 1
d231 1
d247 1
a247 1
	int c;
a271 6
		fprintf(stderr, "Getting export list.\n");
	get_exportlist();
	if (debug)
		fprintf(stderr, "Getting mount list.\n");
	get_mountlist();
	if (debug)
d296 1
d298 22
d321 10
a330 1
	signal(SIGSYS, SIG_IGN);
d351 315
d670 1
a670 1
	int nready;
d673 15
d692 2
a693 6
		if (gotterm) {
			(void) clnt_broadcast(RPCPROG_MNT, RPCMNT_VER1,
			    RPCMNT_UMNTALL, xdr_void, (caddr_t)0, xdr_void,
			    (caddr_t)0, umntall_each);
			exit(0);
		}
d721 4
d814 1
a814 1
			if (getfh(dirpath, (fhandle_t *)&fhr.fhr_fh) < 0) {
a1074 6
	union {
		struct ufs_args ua;
		struct iso_args ia;
		struct mfs_args ma;
		struct msdosfs_args da;
	} targs;
d1129 3
a1131 2
	 * Read in the exports file and build the list, calling
	 * mount() as we go along to push the export rules into the kernel.
d1364 1
a1364 1
			i = do_mount(ep, grp, exflags, &anon, dirp, dirplen, &fsb);
d1423 2
a1424 6
		bzero(&targs, sizeof(targs));
		targs.ua.export_info.ex_flags = MNT_DELEXPORT;
		if (mount(fsp->f_fstypename, fsp->f_mntonname,
		    fsp->f_flags | MNT_UPDATE, &targs) < 0)
			syslog(LOG_ERR, "Can't delete exports for %s: %m",
			    fsp->f_mntonname);
d1932 1
a1932 1
    struct xucred *anoncrp, char *dirp, int dirplen, struct statfs *fsb)
d1935 1
a1935 6
	union {
		struct ufs_args ua;
		struct iso_args ia;
		struct mfs_args ma;
		struct msdosfs_args da;
	} args;
d1942 2
a1943 3
	args.ua.fspec = 0;
	args.ua.export_info.ex_flags = exflags;
	args.ua.export_info.ex_anon = *anoncrp;
d1959 2
a1960 2
			args.ua.export_info.ex_addr = (struct sockaddr *)&sin;
			args.ua.export_info.ex_masklen = 0;
d1962 1
a1962 1
				args.ua.export_info.ex_addrlen = 0;
d1966 1
a1966 1
			args.ua.export_info.ex_addrlen = sizeof(sin);
d1970 4
a1973 4
			args.ua.export_info.ex_addr = (struct sockaddr *)&sin;
			args.ua.export_info.ex_addrlen = sizeof (sin);
			args.ua.export_info.ex_mask = (struct sockaddr *)&imask;
			args.ua.export_info.ex_masklen = sizeof (imask);
d2003 1
a2003 2
		while (mount(fsb->f_fstypename, dirp,
		    fsb->f_flags | MNT_UPDATE, &args) < 0) {
a2283 1
	FILE *mlfile;
d2301 1
a2301 5
		if ((mlfile = fopen(_PATH_RMOUNTLIST, "w")) == NULL) {
			syslog(LOG_ERR, "Can't update %s: %m",
			    _PATH_RMOUNTLIST);
			return;
		}
d2304 1
a2304 1
			fprintf(mlfile, "%s %s\n", mlp->ml_host, mlp->ml_dirp);
d2307 1
a2307 1
		fclose(mlfile);
a2314 1
	FILE *mlfile;
d2331 1
a2331 6
	if ((mlfile = fopen(_PATH_RMOUNTLIST, "a")) == NULL) {
		syslog(LOG_ERR, "Can't update %s: %m", _PATH_RMOUNTLIST);
		return;
	}
	fprintf(mlfile, "%s %s\n", mlp->ml_host, mlp->ml_dirp);
	fclose(mlfile);
@


1.82
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.81 2015/08/20 22:16:35 millert Exp $	*/
d963 2
a964 1
				    (strcmp (dirp, fstbl[i].mntonname) == 0) &&
d1039 1
@


1.81
log
@Two reallocarray() conversions that were missed earlier.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.80 2015/08/20 22:02:21 deraadt Exp $	*/
d1498 1
a1498 2
	if (ep->ex_fsdir)
		free(ep->ex_fsdir);
d2003 1
a2003 2
		if (grp->gr_ptr.gt_net.nt_name)
			free(grp->gr_ptr.gt_net.nt_name);
@


1.80
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.79 2015/01/16 06:39:59 deraadt Exp $	*/
d1469 1
a1469 1
	naddrp = nhp->h_addr_list = malloc(i*sizeof(char *));
@


1.79
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.78 2014/11/20 15:22:39 tedu Exp $	*/
d824 1
a824 1
					ep->ex_fsdir = (char *)malloc(len);
d927 1
a927 1
			hpe = (struct hostent *)malloc(sizeof(struct hostent));
d1120 1
a1120 1
	dp = (struct dirlist *)malloc(sizeof (struct dirlist) + len);
d1456 1
a1456 2
	nhp = grp->gr_ptr.gt_hostent = (struct hostent *)
		malloc(sizeof(struct hostent));
d1461 1
a1461 1
	nhp->h_name = (char *)malloc(i);
d1469 1
a1469 2
	naddrp = nhp->h_addr_list = (char **)
		malloc(i*sizeof(char *));
d1474 1
a1474 2
		*naddrp = (char *)
		    malloc(hp->h_length);
d1524 1
a1524 1
	hp = (struct hostlist *)malloc(sizeof (struct hostlist));
d1722 1
a1722 1
		net->nt_name = (char *)malloc(len);
d1892 1
a1892 1
		mlp = (struct mountlist *)malloc(sizeof (*mlp));
d1955 1
a1955 1
	mlp = (struct mountlist *)malloc(sizeof (*mlp));
@


1.78
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.77 2014/10/22 13:31:04 millert Exp $	*/
d36 1
a36 1
#include <sys/param.h>
d63 1
d181 1
a181 1
char exname[MAXPATHLEN];
d343 1
a343 1
	char rpcpath[RPCMNT_PATHLEN+1], dirpath[MAXPATHLEN];
d1802 1
a1802 1
	gid_t groups[NGROUPS + 1];
d1831 1
a1831 1
		ngroups = NGROUPS + 1;
d1856 1
a1856 1
	while (names != NULL && *names != '\0' && cr->cr_ngroups < NGROUPS) {
d1868 1
a1868 1
	if (names != NULL && *names != '\0' && cr->cr_ngroups == NGROUPS)
@


1.77
log
@Use svc_getreq_poll() instead of svc_getreqset2() for mountd's
custom svc_run loop.  From Dimitris Papastamos.  OK schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.76 2014/08/24 14:45:00 doug Exp $	*/
a36 1
#include <sys/file.h>
@


1.76
log
@Remove imaginary non-reserved port support from mountd.

This bug was reported by Julian Hsiao.

ok concept deraadt@@, miod@@
mountd.8 diff is from jmc@@.  ok doug@@
mountd.c diff is from me.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.75 2014/05/16 17:30:28 millert Exp $	*/
d57 1
d293 3
a295 4
	fd_set *fds = NULL;
	int fds_size = 0;
	extern fd_set *__svc_fdset;
	extern int __svc_fdsetsize;
d308 6
a313 8
		if (__svc_fdset) {
			int bytes = howmany(__svc_fdsetsize, NFDBITS) *
			    sizeof(fd_mask);
			if (fds_size != __svc_fdsetsize) {
				if (fds)
					free(fds);
				fds = (fd_set *)malloc(bytes);  /* XXX */
				fds_size = __svc_fdsetsize;
d315 2
a316 5
			memcpy(fds, __svc_fdset, bytes);
		} else {
			if (fds)
				free(fds);
			fds = NULL;
d318 4
a321 1
		switch (select(svc_maxfd+1, fds, 0, 0, (struct timeval *)0)) {
d325 2
a326 3
			perror("mountd_svc_run: - select failed");
			if (fds)
				free(fds);
d331 1
a331 1
			svc_getreqset2(fds, svc_maxfd+1);
@


1.75
log
@Zero out grp before re-using it (new ones are already cleared by
calloc).   We only reuse grp when there is an unresolvable host.
Fixes a bug where if a host in a netgroup is unresolvable then
entire netgroup is ignore.  OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.74 2014/04/22 20:25:16 tedu Exp $	*/
a186 1
int resvport_only = 1;
a205 1
 * and "-n" to allow nonroot mount.
a219 2
			resvport_only = 0;
			break;
d224 1
a224 1
			fprintf(stderr, "usage: mountd [-dn] [exportsfile]\n");
d372 1
a372 1
		if (sport >= IPPORT_RESERVED && resvport_only) {
d470 1
a470 1
		if (sport >= IPPORT_RESERVED && resvport_only) {
d486 1
a486 1
		if (sport >= IPPORT_RESERVED && resvport_only) {
@


1.74
log
@malloc/memset -> calloc. from peter malone
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.73 2014/03/24 00:19:48 guenther Exp $	*/
d878 2
@


1.73
log
@Split the API: struct ucred remains the kernel internal structure while
struct xucred becomes the structure for syscalls (mount(2) and nfssvc(2)).

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.72 2013/11/22 04:12:48 deraadt Exp $	*/
d1060 1
a1060 1
	ep = (struct exportlist *)malloc(sizeof (struct exportlist));
a1062 1
	memset(ep, 0, sizeof(struct exportlist));
d1074 1
a1074 1
	gp = (struct grouplist *)malloc(sizeof (struct grouplist));
a1076 1
	memset(gp, 0, sizeof(struct grouplist));
@


1.72
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.71 2010/03/22 16:35:27 otto Exp $	*/
a42 1
#include <sys/ucred.h>
d141 1
a141 1
int	do_mount(struct exportlist *, struct grouplist *, int, struct ucred *,
d144 1
a144 1
	    int *, int *, struct ucred *);
d166 1
a166 1
void	parsecred(char *, struct ucred *);
d181 5
a185 6
struct ucred def_anon = {
	1,
	(uid_t) -2,
	(gid_t) -2,
	0,
	{ 0, }
d691 1
a691 1
	struct ucred anon;
d1325 1
a1325 1
    int *has_hostp, int *exflagsp, struct ucred *cr)
d1560 1
a1560 1
    struct ucred *anoncrp, char *dirp, int dirplen, struct statfs *fsb)
d1807 1
a1807 1
parsecred(char *namelist, struct ucred *cr)
d1818 2
a1819 4
	cr->cr_ref = 1;
	cr->cr_uid = (uid_t)-2;
	cr->cr_gid = (gid_t)-2;
	cr->cr_ngroups = 0;
@


1.71
log
@report why getgrouplist() failed and for which user, helps with debugging;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.70 2009/10/27 23:59:33 deraadt Exp $	*/
d1432 1
a1432 1
		if (isdigit(*cp)) {
d1829 1
a1829 1
	if (isdigit(*name) || *name == '-')
d1860 1
a1860 1
	else if (isdigit(*name) || *name == '-')
d1869 1
a1869 1
		if (isdigit(*name) || *name == '-') {
@


1.70
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.69 2007/12/30 13:41:09 sobrado Exp $	*/
d1844 1
a1844 1
			syslog(LOG_ERR, "Too many groups");
@


1.69
log
@use the same argument name in synopsis and usage; lowercase "usage:"

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.68 2007/06/01 05:37:14 deraadt Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mountd.c  8.15 (Berkeley) 5/1/95";
#else
static char rcsid[] = "$NetBSD: mountd.c,v 1.31 1996/02/18 11:57:53 fvdl Exp $";
#endif
#endif /* not lint */
@


1.68
log
@remove crufty adosfs.  everytime we try to change a vfs layer interface,
adosfs has the issue and in an entirely different way.  noone uses this
code so this is hte best way to handle the problem
diff from pedro who went to sleep but we need to move ahead; ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.67 2006/05/29 16:49:42 avsm Exp $	*/
d244 1
a244 1
			fprintf(stderr, "Usage: mountd [-dn] [export_file]\n");
@


1.67
log
@revert vfs.nfs.privport sysctl, broke a few architectures
requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.65 2005/09/20 22:40:35 deraadt Exp $	*/
a712 1
		struct adosfs_args aa;
a759 1
		    !strncmp(fsp->f_fstypename, MOUNT_ADOSFS, MFSNAMELEN) ||
a1583 1
		struct adosfs_args aa;
@


1.66
log
@Add support for NFS mounts to be from non-reserved ports:

- new sysctl vfs.nfs.privport to require NFS mount requests to be on
reserved ports when set to 1 (the default).
- mountd now automatically sets the sysctl depending on the -n flag.
- add mountd_flags to rc.conf to enable the -n flag at boot.
deraadt@@ ok
@
text
@a50 1
#include <sys/sysctl.h>
a63 1
#include <nfs/nfs.h>
d230 1
a230 2
	int c, nfs_id, mib[4];
	size_t s_len;
a286 35
	/* Set vfs.nfs.privport to correct value */
	mib[0] = CTL_VFS;
	mib[1] = VFS_GENERIC;
	mib[2] = VFS_MAXTYPENUM;
	s_len = sizeof nfs_id;
	if (sysctl(mib, 3, &nfs_id, &s_len, NULL, 0)) {
		syslog(LOG_ERR, "sysctl VFS_MAXTYPENUM: %m");
		exit(1);
	}
	for (; nfs_id; nfs_id--) {
		struct vfsconf vfsc;
		mib[0] = CTL_VFS;
		mib[1] = VFS_GENERIC;
		mib[2] = VFS_CONF;
		mib[3] = nfs_id;
		s_len = sizeof(vfsc);
		if (sysctl(mib, 4, &vfsc, &s_len, NULL, 0))
			continue;
		if (!strcmp(vfsc.vfc_name, MOUNT_NFS))
			break;
	}
	if (nfs_id == 0) {
		syslog(LOG_ERR, "null nfs filesystem id");
		exit(1);
	}

	mib[0] = CTL_VFS;
	mib[1] = nfs_id;
	mib[2] = NFS_PRIVPORT;
	if (sysctl(mib, 3, NULL, 0, &resvport_only,
		sizeof resvport_only) != 0 && errno != ENOENT) {
		syslog(LOG_ERR, "sysctl NFS_PRIVPORT: %m");
		exit(1);
	}
	
@


1.65
log
@if we must un-export, only un-export when we do the first call for
each filesystem; ok drahn, specific issue found by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.64 2005/09/13 02:53:28 drahn Exp $	*/
d51 1
d65 1
d232 2
a233 1
	int c;
d290 35
@


1.64
log
@Only DELEXPORT filesystems which are not exported. Removes NFS race when
mounting filesystems on nfs servers. Improvements and ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.63 2005/04/08 20:09:38 jaredy Exp $	*/
d1002 1
@


1.63
log
@Sync with recent realpath(3) changes:  on failure, don't use the second
argument "resolved", since it is undefined.

ok and help millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.62 2003/10/16 20:14:42 millert Exp $	*/
d705 1
a705 1
	struct statfs fsb, *fsp;
d708 11
d745 10
a754 1
	num = getmntinfo(&fsp, MNT_NOWAIT);
a755 7
		union {
			struct ufs_args ua;
			struct iso_args ia;
			struct mfs_args ma;
			struct msdosfs_args da;
			struct adosfs_args aa;
		} targs;
d763 2
a764 7
			bzero((char *)&targs, sizeof(targs));
			targs.ua.fspec = NULL;
			targs.ua.export_info.ex_flags = MNT_DELEXPORT;
			if (mount(fsp->f_fstypename, fsp->f_mntonname,
			    fsp->f_flags | MNT_UPDATE, &targs) < 0)
				syslog(LOG_ERR, "Can't delete exports for %s: %m",
				    fsp->f_mntonname);
d977 20
d1051 15
@


1.62
log
@Check for signals in local svc_run before doing anything else.  Fixes
the bug where signals would not be handled until the next mount request.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.61 2003/10/09 20:33:14 millert Exp $	*/
d410 7
a416 2
		if (realpath(rpcpath, dirpath) == 0 ||
		    stat(dirpath, &stb) < 0 ||
a418 1
			chdir("/");	/* Just in case realpath doesn't */
@


1.61
log
@Remove errant semicolon introduced in rev 1.60; joshua stein
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.60 2003/09/26 16:09:27 deraadt Exp $	*/
d318 10
a355 10
		}
		if (gothup) {
			get_exportlist();
			gothup = 0;
		}
		if (gotterm) {
			(void) clnt_broadcast(RPCPROG_MNT, RPCMNT_VER1,
			    RPCMNT_UMNTALL, xdr_void, (caddr_t)0, xdr_void,
			    (caddr_t)0, umntall_each);
			exit(0);
@


1.60
log
@check strdup failure; ok anil millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.59 2003/06/11 06:22:14 deraadt Exp $	*/
d942 1
a942 1
			if (hpe->h_name == NULL);
@


1.59
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.58 2003/06/02 20:06:16 millert Exp $	*/
d942 2
@


1.58
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.57 2003/03/16 01:42:27 millert Exp $	*/
d310 1
a310 1
mountd_svc_run()
d1039 1
a1039 1
get_grp()
@


1.57
log
@Use len+1 as the size parameter to strlcpy() since len does not include
the trailing NUL.  From krw@@; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.56 2003/03/14 00:51:15 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.56
log
@tweak; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.55 2003/03/13 09:09:26 deraadt Exp $	*/
d1106 1
a1106 1
	strlcpy(dp->dp_dirp, cp, len);
@


1.55
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.54 2003/03/09 00:30:24 deraadt Exp $	*/
d1098 2
a1099 1
	dp = (struct dirlist *)malloc(sizeof (struct dirlist) + len + 1);
d1106 1
a1106 1
	strlcpy(dp->dp_dirp, cp, len);	/* might be 1 byte extra */
@


1.54
log
@if fopen fails, do not bork; rob@@animoid-row.org
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.53 2003/01/05 22:41:36 deraadt Exp $	*/
d836 2
d840 2
a841 2
					ep->ex_fsdir = (char *)
					    malloc(strlen(fsb.f_mntonname) + 1);
d843 2
a844 2
					    strcpy(ep->ex_fsdir,
						fsb.f_mntonname);
d1098 1
a1098 1
	dp = (struct dirlist *)malloc(sizeof (struct dirlist) + len);
d1105 1
a1105 1
	strcpy(dp->dp_dirp, cp);
d1697 2
d1703 2
a1704 1
		net->nt_name = (char *)malloc(strlen(name) + 1);
d1707 1
a1707 1
		strcpy(net->nt_name, name);
@


1.53
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.52 2002/07/18 08:46:18 deraadt Exp $	*/
d286 4
a289 2
	fprintf(pidfile, "%ld\n", (long)getpid());
	fclose(pidfile);
@


1.52
log
@fix warning
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.51 2002/07/18 08:41:05 deraadt Exp $	*/
d1134 1
a1134 1
		 * Loop throught the directories adding them to the tree.
@


1.51
log
@de-lint a bit.  use inet_aton(); millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.50 2002/07/11 21:23:29 deraadt Exp $	*/
d1399 1
a1399 1
				syslog(LOG_ERR, "inet_addr failed for %s", cp);
@


1.50
log
@malloc() failure tests; rimshot@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.49 2002/06/29 23:19:49 deraadt Exp $	*/
d205 1
a205 1
	{ }
d1390 1
a1390 1
	in_addr_t saddr;
d1398 1
a1398 2
			saddr = inet_addr(cp);
			if (saddr == -1) {
d1402 2
a1403 2
			if ((hp = gethostbyaddr((caddr_t)&saddr, sizeof (saddr),
				AF_INET)) == NULL) {
d1784 2
a1785 2
	cr->cr_uid = -2;
	cr->cr_gid = -2;
@


1.49
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.48 2002/06/09 08:13:08 todd Exp $	*/
d1095 2
d1871 2
d1934 2
@


1.48
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.47 2002/06/04 00:09:08 deraadt Exp $	*/
d170 1
a170 1
void	new_exportlist(void);
d188 1
a188 1
void	send_umntall(void);
d230 1
a230 3
main(argc, argv)
	int argc;
	char **argv;
d366 1
a366 3
mntsrv(rqstp, transp)
	struct svc_req *rqstp;
	SVCXPRT *transp;
d368 2
d371 3
d375 1
a375 1
	struct fhreturn fhr;
a376 2
	struct statfs fsb;
	struct hostent *hp;
a378 1
	char rpcpath[RPCMNT_PATHLEN+1], dirpath[MAXPATHLEN];
a379 2
	int defset, hostset;
	sigset_t sighup_mask;
a384 1
	hp = NULL;
d392 1
a392 2
			fprintf(stderr,
			    "Got mount request from %s\n",
d529 1
a529 3
xdr_dir(xdrsp, dirp)
	XDR *xdrsp;
	char *dirp;
d538 1
a538 3
xdr_fhs(xdrsp, cp)
	XDR *xdrsp;
	caddr_t cp;
d564 1
a564 3
xdr_mlist(xdrsp, cp)
	XDR *xdrsp;
	caddr_t cp;
d566 1
a567 2
	int true = 1;
	int false = 0;
d591 1
a591 3
xdr_explist(xdrsp, cp)
	XDR *xdrsp;
	caddr_t cp;
d594 1
a594 2
	int false = 0;
	int putdef;
d624 2
a625 5
put_exlist(dp, xdrsp, adp, putdefp)
	struct dirlist *dp;
	XDR *xdrsp;
	struct dirlist *adp;
	int *putdefp;
d627 1
a629 3
	int true = 1;
	int false = 0;
	int gotalldir = 0;
d684 1
a684 1
new_exportlist()
d694 1
a694 1
get_exportlist()
d696 3
a705 3
	char *cp, *endcp, *dirp = NULL, *hst, *usr, *dom, savedc;
	int len, has_host, exflags, got_nondir, dirplen = 0, num, i, netgrp;
	int lookup_failed, num_hosts;
d1024 1
a1024 1
get_exp()
d1054 1
a1054 3
getexp_err(ep, grp)
	struct exportlist *ep;
	struct grouplist *grp;
d1072 1
a1072 2
ex_search(fsid)
	fsid_t *fsid;
d1090 1
a1090 4
add_expdir(dpp, cp, len)
	struct dirlist **dpp;
	char *cp;
	int len;
d1109 2
a1110 5
hang_dirp(dp, grp, ep, flags)
	struct dirlist *dp;
	struct grouplist *grp;
	struct exportlist *ep;
	int flags;
d1147 2
a1148 5
add_dlist(dpp, newdp, grp, flags)
	struct dirlist **dpp;
	struct dirlist *newdp;
	struct grouplist *grp;
	int flags;
d1191 1
a1191 3
dirp_search(dp, dirpath)
	struct dirlist *dp;
	char *dirpath;
d1211 1
a1211 5
chk_host(dp, saddr, defsetp, hostsetp)
	struct dirlist *dp;
	in_addr_t saddr;
	int *defsetp;
	int *hostsetp;
d1253 1
a1253 3
scan_tree(dp, saddr)
	struct dirlist *dp;
	in_addr_t saddr;
d1272 1
a1272 2
free_dir(dp)
	struct dirlist *dp;
d1289 2
a1290 7
do_opt(cpp, endcpp, ep, grp, has_hostp, exflagsp, cr)
	char **cpp, **endcpp;
	struct exportlist *ep;
	struct grouplist *grp;
	int *has_hostp;
	int *exflagsp;
	struct ucred *cr;
d1292 1
a1293 1
	char *cp, *endcp, *cpopt, savedc, savedc2 = 0;
d1383 1
a1383 4
get_host(cp, grp, tgrp)
	char *cp;
	struct grouplist *grp;
	struct grouplist *tgrp;
d1385 1
a1386 1
	struct hostent *hp, *nhp;
a1387 2
	struct hostent t_host;
	int i;
d1390 1
d1467 1
a1467 2
free_exp(ep)
	struct exportlist *ep;
d1484 1
a1484 2
free_host(hp)
	struct hostlist *hp;
d1496 1
a1496 1
get_ht()
d1512 1
a1512 1
out_of_mem()
d1525 2
a1526 8
do_mount(ep, grp, exflags, anoncrp, dirp, dirplen, fsb)
	struct exportlist *ep;
	struct grouplist *grp;
	int exflags;
	struct ucred *anoncrp;
	char *dirp;
	int dirplen;
	struct statfs *fsb;
a1527 4
	char *cp = NULL;
	u_int32_t **addrp;
	int done;
	char savedc = '\0';
d1536 3
d1540 1
d1658 1
a1658 4
get_net(cp, net, maskflg)
	char *cp;
	struct netmsk *net;
	int maskflg;
d1660 2
a1662 2
	in_addr_t netaddr;
	struct in_addr inetaddr, inetaddr2;
d1709 1
a1709 3
nextfield(cp, endcp)
	char **cp;
	char **endcp;
d1731 1
a1731 1
get_line()
d1733 1
a1734 2
	int len;
	int totlen, cont_line;
d1771 1
a1771 3
parsecred(namelist, cr)
	char *namelist;
	struct ucred *cr;
d1773 2
a1774 3
	char *name;
	int cnt;
	char *names;
d1777 1
a1777 1
	int ngroups, groups[NGROUPS + 1];
d1808 1
a1808 1
		 * Convert from int's to gid_t's and compress out duplicate
d1850 1
a1850 1
get_mountlist()
d1879 1
a1879 2
del_mlist(hostp, dirp)
	char *hostp, *dirp;
d1916 1
a1916 2
add_mlist(hostp, dirp)
	char *hostp, *dirp;
d1943 1
a1943 1
 * This function is called via. SIGTERM when the system is going down.
d1947 1
a1947 1
send_umntall()
d1953 1
a1953 3
umntall_each(resultsp, raddr)
	caddr_t resultsp;
	struct sockaddr_in *raddr;
d1962 1
a1962 2
free_grp(grp)
	struct grouplist *grp;
d1986 1
a1986 2
check_options(dp)
	struct dirlist *dp;
d2011 1
a2011 2
check_dirpath(dirp)
	char *dirp;
d2013 2
a2015 2
	int ret = 1;
	struct stat sb;
@


1.47
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.46 2002/05/26 09:24:35 deraadt Exp $	*/
d398 1
a398 1
			    "Got mount request from %s\n", 
d401 1
a401 1
			syslog(LOG_NOTICE, 
d1382 1
a1382 1
		} else 
@


1.46
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.45 2002/04/23 18:54:12 espie Exp $	*/
d1848 1
a1848 1
	 * Set up the unpriviledged user.
@


1.45
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.44 2002/04/04 20:57:17 millert Exp $	*/
d288 1
a288 1
	fprintf(pidfile, "%d\n", getpid());
@


1.44
log
@Add more debugging info in -d mode.  Some from NetBSD (via Brett Eldridge).
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.43 2002/02/17 19:42:28 millert Exp $	*/
d771 1
a771 1
			targs.ua.export.ex_flags = MNT_DELEXPORT;
d1602 2
a1603 2
	args.ua.export.ex_flags = exflags;
	args.ua.export.ex_anon = *anoncrp;
d1619 2
a1620 2
			args.ua.export.ex_addr = (struct sockaddr *)&sin;
			args.ua.export.ex_masklen = 0;
d1622 1
a1622 1
				args.ua.export.ex_addrlen = 0;
d1626 1
a1626 1
			args.ua.export.ex_addrlen = sizeof(sin);
d1630 4
a1633 4
			args.ua.export.ex_addr = (struct sockaddr *)&sin;
			args.ua.export.ex_addrlen = sizeof (sin);
			args.ua.export.ex_mask = (struct sockaddr *)&imask;
			args.ua.export.ex_masklen = sizeof (imask);
@


1.43
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.42 2002/02/16 21:27:36 millert Exp $	*/
d396 4
d401 3
d411 2
d476 6
a481 2
			if (debug)
				fprintf(stderr, "Mount successful.\n");
@


1.42
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.41 2001/12/02 02:05:59 deraadt Exp $	*/
d153 1
a153 2
void	add_dlist __P((struct dirlist **, struct dirlist *,
	    struct grouplist *, int));
d160 4
a163 4
int	do_mount __P((struct exportlist *, struct grouplist *, int,
	    struct ucred *, char *, int, struct statfs *));
int	do_opt __P((char **, char **, struct exportlist *, struct grouplist *,
	    int *, int *, struct ucred *));
d180 2
a181 2
void	hang_dirp __P((struct dirlist *, struct grouplist *,
	    struct exportlist *, int));
@


1.41
log
@remove some };
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.40 2001/11/17 19:54:57 deraadt Exp $	*/
d152 1
a152 1
char	*add_expdir __P((struct dirlist **, char *, int));
d155 6
a160 6
void	add_mlist __P((char *, char *));
int	check_dirpath __P((char *));
int	check_options __P((struct dirlist *));
int	chk_host __P((struct dirlist *, in_addr_t, int *, int *));
void	del_mlist __P((char *, char *));
struct dirlist *dirp_search __P((struct dirlist *, char *));
d165 16
a180 16
struct	exportlist *ex_search __P((fsid_t *));
struct	exportlist *get_exp __P((void));
void	free_dir __P((struct dirlist *));
void	free_exp __P((struct exportlist *));
void	free_grp __P((struct grouplist *));
void	free_host __P((struct hostlist *));
void	new_exportlist __P((void));
void	get_exportlist __P((void));
int	get_host __P((char *, struct grouplist *, struct grouplist *));
int	get_num __P((char *));
struct hostlist *get_ht __P((void));
int	get_line __P((void));
void	get_mountlist __P((void));
int	get_net __P((char *, struct netmsk *, int));
void	getexp_err __P((struct exportlist *, struct grouplist *));
struct grouplist *get_grp __P((void));
d183 13
a195 13
void	mntsrv __P((struct svc_req *, SVCXPRT *));
void	nextfield __P((char **, char **));
void	out_of_mem __P((void));
void	parsecred __P((char *, struct ucred *));
int	put_exlist __P((struct dirlist *, XDR *, struct dirlist *, int *));
int	scan_tree __P((struct dirlist *, in_addr_t));
void	send_umntall __P((void));
int	umntall_each __P((caddr_t, struct sockaddr_in *));
int	xdr_dir __P((XDR *, char *));
int	xdr_explist __P((XDR *, caddr_t));
int	xdr_fhs __P((XDR *, caddr_t));
int	xdr_mlist __P((XDR *, caddr_t));
void	mountd_svc_run __P((void));
d292 2
a293 2
	signal(SIGHUP, (void (*) __P((int))) new_exportlist);
	signal(SIGTERM, (void (*) __P((int))) send_umntall);
@


1.40
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.39 2001/11/05 07:39:16 mpech Exp $	*/
d253 1
a253 1
		};
d557 1
a557 1
	};
d1269 1
a1269 1
			};
d1642 1
a1642 1
		};
@


1.39
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.38 2001/10/03 18:54:29 hin Exp $	*/
d219 2
a220 2
sig_atomic_t gothup;
sig_atomic_t gotterm;
@


1.38
log
@Remove all traces of Kerberised NFS; it never worked in OpenBSD, but it
has been in the userland tools and the manpages for ages.

Spotted by Lars Hansson <lars@@unet.net.ph>

Ok deraadt@@
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.37 2001/06/14 21:57:44 mickey Exp $	*/
d538 1
a538 1
	register struct fhreturn *fhrp = (struct fhreturn *)cp;
@


1.37
log
@a typo i made
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.36 2001/05/11 18:35:21 mickey Exp $	*/
a104 1
#define DP_KERB		0x4
a212 1
#define	OP_KERB		0x04
d552 1
a552 4
		if (fhrp->fhr_flag & DP_KERB)
			auth = RPCAUTH_KERB4;
		else
			auth = RPCAUTH_UNIX;
a1139 2
			if (flags & OP_KERB)
				ep->ex_defdir->dp_flag |= DP_KERB;
a1141 2
			if (flags & OP_KERB)
				hp->ht_flag |= DP_KERB;
a1197 2
			if (flags & OP_KERB)
				hp->ht_flag |= DP_KERB;
a1204 2
		if (flags & OP_KERB)
			dp->dp_flag |= DP_KERB;
d1370 3
a1372 5
		} else if (!strcmp(cpopt, "kerb") || !strcmp(cpopt, "k")) {
			*exflagsp |= MNT_EXKERB;
			opt_flags |= OP_KERB;
		} else if (cpoptarg && (!strcmp(cpopt, "mask") ||
		    !strcmp(cpopt, "m"))) {
d2053 2
a2054 4
	if ((opt_flags & (OP_MAPROOT | OP_MAPALL)) == (OP_MAPROOT | OP_MAPALL) ||
	    (opt_flags & (OP_MAPROOT | OP_KERB)) == (OP_MAPROOT | OP_KERB) ||
	    (opt_flags & (OP_MAPALL | OP_KERB)) == (OP_MAPALL | OP_KERB)) {
		syslog(LOG_ERR, "-mapall, -maproot and -kerb mutually exclusive");
@


1.36
log
@use strlcpy instead of strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.35 2001/01/17 19:27:11 deraadt Exp $	*/
d2004 1
a2004 1
	strlcpy(mlp->ml_dirp, dirp, sizeof(mlp->ml_dirp, dirp));
@


1.35
log
@make send_umntall() handler safe also
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.34 2001/01/16 02:59:46 deraadt Exp $	*/
d262 1
a262 5
	if (argc == 1)
		strncpy(exname, *argv, sizeof(exname)-1);
	else
		strncpy(exname, _PATH_EXPORTS, sizeof exname-1);
	exname[sizeof(exname)-1] = '\0';
d1940 2
a1941 4
		strncpy(mlp->ml_host, host, RPCMNT_NAMELEN);
		mlp->ml_host[RPCMNT_NAMELEN] = '\0';
		strncpy(mlp->ml_dirp, dirp, RPCMNT_PATHLEN);
		mlp->ml_dirp[RPCMNT_PATHLEN] = '\0';
d2003 2
a2004 4
	strncpy(mlp->ml_host, hostp, RPCMNT_NAMELEN);
	mlp->ml_host[RPCMNT_NAMELEN] = '\0';
	strncpy(mlp->ml_dirp, dirp, RPCMNT_PATHLEN);
	mlp->ml_dirp[RPCMNT_PATHLEN] = '\0';
@


1.34
log
@use a private svc_run(), which looks at a global touched by SIGHUP handler
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.33 2000/12/30 06:18:27 angelos Exp $	*/
d221 2
a222 1
volatile int gothup;
d362 6
d2030 1
a2030 3
	(void) clnt_broadcast(RPCPROG_MNT, RPCMNT_VER1, RPCMNT_UMNTALL,
		xdr_void, (caddr_t)0, xdr_void, (caddr_t)0, umntall_each);
	exit(0);
@


1.33
log
@Don't do a getnetbyname() if the address is in dot notation already;
solves a DNS-related deadlock. Patch by gluk@@ptci.ru (PR 1582)
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.32 2000/07/05 23:41:10 deraadt Exp $	*/
d196 1
d221 2
d314 1
a314 1
	svc_run();
d319 45
d697 1
a697 1
	int save_errno = errno;
a698 2
	get_exportlist();
	errno = save_errno;
@


1.32
log
@remove SYSLOG(), unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.31 2000/05/03 17:58:19 millert Exp $	*/
d1681 1
a1681 5
	if ((np = getnetbyname(cp)))
		inetaddr = inet_makeaddr(np->n_net, 0);
	else if (isdigit(*cp)) {
		if ((netaddr = inet_network(cp)) == -1)
			return (1);
d1684 1
a1684 1
		 * Due to arbritrary subnet masks, you don't know how many
d1699 6
a1704 2
	} else
		return (1);
@


1.31
log
@Fix behavior when a host is unresolvable.  Mark it as type GT_IGNORE
so we don't get an error that inadvertainly causes the entry
to get exported to the world.  Also keep a count of unresolved hosts
and error out sanely on lines w/ no resolvable hosts.  Work by
myself and provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.30 2000/05/01 20:20:12 millert Exp $	*/
a2012 15
}

void
SYSLOG(int pri, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);

	if (debug)
		vfprintf(stderr, fmt, ap);
	else
		vsyslog(pri, fmt, ap);

	va_end(ap);
@


1.30
log
@Remove trailing '/' in exports pathnames so mount requests will match
properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.29 1999/04/21 02:13:57 alex Exp $	*/
d670 1
a670 1
	int lookup_failed;
d745 1
d856 2
d862 1
a862 1
					has_host = FALSE;
d870 1
a870 1
				    has_host = FALSE;
d875 1
d889 2
a890 2
		if (lookup_failed == TRUE && has_host == FALSE &&
		    tgrp->gr_type == GT_NULL)  {
@


1.29
log
@Typo in diagnostic; gonter@@whisky.wu-wien.ac.at
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.28 1999/03/07 21:02:08 millert Exp $	*/
d2064 5
@


1.28
log
@Only throw away a line with an empty exports list if the list is empty
due to unresolvable hostnames.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.27 1998/12/28 08:04:27 deraadt Exp $	*/
d2047 1
a2047 1
		syslog(LOG_ERR, "-alldir has multiple directories");
@


1.27
log
@some cleanup, in preperation for a rewrite of the racy guts
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.26 1998/08/11 16:18:36 deraadt Exp $	*/
d670 1
d745 1
d860 1
d868 1
d881 6
a886 1
		if (has_host == FALSE && tgrp->gr_type == GT_NULL)  {
@


1.26
log
@proper name is -network not -net; d
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.25 1998/06/23 23:34:14 deraadt Exp $	*/
a65 3
#ifdef ISO
#include <netiso/iso.h>
#endif
d91 2
a92 2
	char	ml_host[RPCMNT_NAMELEN+1];
	char	ml_dirp[RPCMNT_PATHLEN+1];
a126 3
#ifdef ISO
	struct sockaddr_iso *gt_isoaddr;
#endif
a137 1
#define	GT_ISO		0x4
d155 1
a155 1
				struct grouplist *, int));
d163 1
a163 1
		struct ucred *, char *, int, struct statfs *));
d165 1
a165 1
				int *, int *, struct ucred *));
d183 1
a183 1
				struct exportlist *, int));
a196 4
#ifdef ISO
struct iso_addr *iso_addr();
#endif

a215 1
#define	OP_ISO		0x20
d234 1
d254 10
a263 8
	grphead = (struct grouplist *)NULL;
	exphead = (struct exportlist *)NULL;
	mlhead = (struct mountlist *)NULL;
	if (argc == 1) {
		strncpy(exname, *argv, MAXPATHLEN-1);
		exname[MAXPATHLEN-1] = '\0';
	} else
		strcpy(exname, _PATH_EXPORTS);
d279 2
a280 3
	{
	    FILE *pidfile = fopen(_PATH_MOUNTDPID, "r");
	    if (pidfile != NULL) {
d282 4
a285 4
		    if (kill(c, 0) == 0) {
			syslog(LOG_ERR, "Already running (pid %d)", c);
			exit(1);
		    }
d288 1
a288 1
	    } else {
a289 3
	    }
	    fprintf(pidfile, "%d\n", getpid());
	    fclose(pidfile);
d291 3
d304 4
a307 8
	if (!svc_register(udptransp, RPCPROG_MNT, RPCMNT_VER1, mntsrv,
		IPPROTO_UDP) ||
	    !svc_register(udptransp, RPCPROG_MNT, RPCMNT_VER3, mntsrv,
		IPPROTO_UDP) ||
	    !svc_register(tcptransp, RPCPROG_MNT, RPCMNT_VER1, mntsrv,
		IPPROTO_TCP) ||
	    !svc_register(tcptransp, RPCPROG_MNT, RPCMNT_VER3, mntsrv,
		IPPROTO_TCP)) {
d341 1
a341 1
	hp = (struct hostent *)NULL;
d344 1
a344 1
		if (!svc_sendreply(transp, xdr_void, (caddr_t)NULL))
d377 3
a379 3
		     chk_host(dp, saddr, &defset, &hostset)) ||
		     (defset && scan_tree(ep->ex_defdir, saddr) == 0 &&
		      scan_tree(ep->ex_dirl, saddr) == 0))) {
d429 1
a429 1
		if (!svc_sendreply(transp, xdr_mlist, (caddr_t)NULL))
d441 1
a441 1
		if (!svc_sendreply(transp, xdr_void, (caddr_t)NULL))
d453 1
a453 1
		if (!svc_sendreply(transp, xdr_void, (caddr_t)NULL))
d457 2
a458 2
			del_mlist(hp->h_name, (char *)NULL);
		del_mlist(inet_ntoa(transp->xp_raddr.sin_addr), (char *)NULL);
d461 1
a461 1
		if (!svc_sendreply(transp, xdr_explist, (caddr_t)NULL))
d563 2
a564 3
		if (ep->ex_defdir && putdef == 0 &&
			put_exlist(ep->ex_defdir, xdrsp, (struct dirlist *)NULL,
			&putdef))
d616 1
a616 1
					if (!xdr_string(xdrsp, &strp, 
d623 1
a623 1
					if (!xdr_string(xdrsp, &strp, 
d628 1
a628 1
				if (gotalldir && hp == (struct hostlist *)NULL) {
d680 1
a680 1
	exphead = (struct exportlist *)NULL;
d688 1
a688 1
	grphead = (struct grouplist *)NULL;
d716 3
a718 5
				  (u_short)fsp->f_flags | MNT_UPDATE,
				  (caddr_t)&targs) < 0)
				syslog(LOG_ERR,
				       "Can't delete exports for %s: %m",
				       fsp->f_mntonname);
d731 1
a731 1
	dirhead = (struct dirlist *)NULL;
d748 1
a748 1
		ep = (struct exportlist *)NULL;
d757 2
a758 2
			    getexp_err(ep, tgrp);
			    goto nextline;
d761 12
a772 12
			    if (ep == (struct exportlist *)NULL) {
				getexp_err(ep, tgrp);
				goto nextline;
			    }
			    if (debug)
				fprintf(stderr, "doing opt %s\n", cp);
			    got_nondir = 1;
			    if (do_opt(&cp, &endcp, ep, grp, &has_host,
				&exflags, &anon)) {
				getexp_err(ep, tgrp);
				goto nextline;
			    }
d795 1
a795 1
				    if (ep == (struct exportlist *)NULL) {
d831 1
a831 1
			    if (ep == (struct exportlist *)NULL) {
d841 1
a841 1
			    	(const char **)&usr, (const char **)&dom);
d891 1
a891 1
			if (hpe == (struct hostent *)NULL)
d896 1
a896 1
			hpe->h_addr_list = (char **)NULL;
d919 1
a919 2
			i = do_mount(ep, grp, exflags, &anon, dirp, dirplen,
			    &fsb);
d942 1
a942 1
			hang_dirp(dirhead, (struct grouplist *)NULL, ep,
d946 1
a946 1
		dirhead = (struct dirlist *)NULL;
d966 1
a966 1
			dirhead = (struct dirlist *)NULL;
d981 1
a981 1
	if (ep == (struct exportlist *)NULL)
d996 1
a996 1
	if (gp == (struct grouplist *)NULL)
d1054 1
a1054 1
	dp->dp_right = (struct dirlist *)NULL;
d1056 1
a1056 1
	dp->dp_hosts = (struct hostlist *)NULL;
d1081 1
a1081 1
		if (grp == (struct grouplist *)NULL) {
d1135 1
a1135 1
		dp->dp_left = (struct dirlist *)NULL;
a1346 10
#ifdef ISO
		} else if (cpoptarg && !strcmp(cpopt, "iso")) {
			if (get_isoaddr(cpoptarg, grp)) {
				syslog(LOG_ERR, "Bad iso addr: %s", cpoptarg);
				return (1);
			}
			*has_hostp = 1;
			usedarg++;
			opt_flags |= OP_ISO;
#endif /* ISO */
d1401 1
a1401 1
				aptr[1] = (char *)NULL;
d1423 1
a1423 1
	if (nhp == (struct hostent *)NULL)
d1428 1
a1428 1
	if (nhp->h_name == (char *)NULL)
d1437 1
a1437 1
	if (naddrp == (char **)NULL)
d1443 1
a1443 1
		if (*naddrp == (char *)NULL)
d1449 1
a1449 1
	*naddrp = (char *)NULL;
d1495 1
a1495 1
	if (hp == (struct hostlist *)NULL)
d1497 1
a1497 1
	hp->ht_next = (struct hostlist *)NULL;
a1501 32
#ifdef ISO
/*
 * Translate an iso address.
 */
get_isoaddr(cp, grp)
	char *cp;
	struct grouplist *grp;
{
	struct iso_addr *isop;
	struct sockaddr_iso *isoaddr;

	if (grp->gr_type != GT_NULL)
		return (1);
	if ((isop = iso_addr(cp)) == NULL) {
		syslog(LOG_ERR,
		    "iso_addr failed, ignored");
		return (1);
	}
	isoaddr = (struct sockaddr_iso *)
	    malloc(sizeof (struct sockaddr_iso));
	if (isoaddr == (struct sockaddr_iso *)NULL)
		out_of_mem();
	memset(isoaddr, 0, sizeof(struct sockaddr_iso));
	memcpy(&isoaddr->siso_addr, isop, sizeof(struct iso_addr));
	isoaddr->siso_len = sizeof(struct sockaddr_iso);
	isoaddr->siso_family = AF_ISO;
	grp->gr_type = GT_ISO;
	grp->gr_ptr.gt_isoaddr = isoaddr;
	return (0);
}
#endif	/* ISO */

d1528 1
a1528 1
	char *cp = (char *)NULL;
d1554 2
a1555 1
		addrp = (u_int32_t **)NULL;
a1559 5
			if (addrp) {
				sin.sin_addr.s_addr = **addrp;
				args.ua.export.ex_addrlen = sizeof(sin);
			} else
				args.ua.export.ex_addrlen = 0;
d1562 6
a1569 14
			if (grp->gr_ptr.gt_net.nt_mask)
			    imask.sin_addr.s_addr = grp->gr_ptr.gt_net.nt_mask;
			else {
			    net = ntohl(grp->gr_ptr.gt_net.nt_net);
			    if (IN_CLASSA(net))
				imask.sin_addr.s_addr = inet_addr("255.0.0.0");
			    else if (IN_CLASSB(net))
				imask.sin_addr.s_addr =
				    inet_addr("255.255.0.0");
			    else
				imask.sin_addr.s_addr =
				    inet_addr("255.255.255.0");
			    grp->gr_ptr.gt_net.nt_mask = imask.sin_addr.s_addr;
			}
d1575 12
a1587 9
#ifdef ISO
		case GT_ISO:
			args.ua.export.ex_addr =
				(struct sockaddr *)grp->gr_ptr.gt_isoaddr;
			args.ua.export.ex_addrlen =
				sizeof(struct sockaddr_iso);
			args.ua.export.ex_masklen = 0;
			break;
#endif	/* ISO */
d1605 1
a1605 2
		       (u_short)fsb->f_flags | MNT_UPDATE, (caddr_t)&args) <
                       0) {
a1618 1
			      /* XXX: Get address from sockaddr_iso? */
d1644 1
a1644 1
			if (*addrp == (u_int32_t *)NULL)
d1700 1
a1700 1
		if (net->nt_name == (char *)NULL)
d1753 2
a1754 2
		while (cp >= p &&
		    (*cp == ' ' || *cp == '\t' || *cp == '\n' || *cp == '\\')) {
d1882 1
a1882 1
		mlp->ml_next = (struct mountlist *)NULL;
d1947 1
a1947 1
	mlp->ml_next = (struct mountlist *)NULL;
a1998 4
#ifdef ISO
	else if (grp->gr_type == GT_ISO)
		free((caddr_t)grp->gr_ptr.gt_isoaddr);
#endif
d2025 2
a2026 2
	if (dp == (struct dirlist *)NULL)
	    return (1);
d2030 2
a2031 2
	    syslog(LOG_ERR, "-mapall, -maproot and -kerb mutually exclusive");
	    return (1);
d2034 2
a2035 6
	    syslog(LOG_ERR, "-mask requires -network");
	    return (1);
	}
	if ((opt_flags & (OP_NET | OP_ISO)) == (OP_NET | OP_ISO)) {
	    syslog(LOG_ERR, "-network and -iso mutually exclusive");
	    return (1);
d2038 2
a2039 2
	    syslog(LOG_ERR, "-alldir has multiple directories");
	    return (1);
@


1.25
log
@handle (,,dom); joerg
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.24 1998/03/01 20:06:30 millert Exp $	*/
d2109 1
a2109 1
	    syslog(LOG_ERR, "-mask requires -net");
d2113 1
a2113 1
	    syslog(LOG_ERR, "-net and -iso mutually exclusive");
@


1.24
log
@If an /etc/exports entry has a single host that cannot be looked
up, throw out the entire line.  A previous change that only throws
out unknown hosts could leave the export host list null (ie:
everyone) if all the listed hosts are unknown.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.23 1997/12/19 09:21:40 deraadt Exp $	*/
d865 6
a870 1
				    if (get_host(hst, grp, tgrp)) {
@


1.23
log
@make mountd abort if getfh() not supported. reported by newsham@@secnet.com, fixed by me
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.22 1997/09/29 19:31:05 millert Exp $	*/
d888 4
@


1.22
log
@Don't ignore a line w/ a bogus hostname, just ignore the bogus hostname...
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.21 1997/09/13 12:24:49 deraadt Exp $	*/
a230 1
void	SYSLOG __P((int, const char *, ...));
d306 1
d409 6
@


1.21
log
@annoying indentation botch
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.20 1997/08/13 18:59:26 deraadt Exp $	*/
d860 5
a864 4
					syslog(LOG_ERR, "Bad netgroup %s", cp);
					getexp_err(ep, tgrp);
					endnetgrent();
					goto nextline;
d867 5
a871 2
				    getexp_err(ep, tgrp);
				    goto nextline;
@


1.20
log
@handle ext2fs specially
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.19 1997/08/09 12:59:14 niklas Exp $	*/
d1324 1
a1324 1
			!strcmp(cpopt, "m"))) {
d1332 1
a1332 1
			!strcmp(cpopt, "n"))) {
@


1.19
log
@struct statfs uses a signed short f_flags field.  This field is used in
the long (the type) expression that makes up the mount flags field passed
to mount(2).  If we are dealing with a noatime mount this means sign
extension will occur and the flag field will get messed up.  I.e. noatime
mounts (at least rw ones) ended up not exportable.  I fixed this by casting
to u_short in the expressions, but I would like to change struct statfs
instead, but that is an API issue it is not for me to decide on.
I also added error decoding in two syslog calls.

This was made possible by the arglist heuristics printout of OpenBSD/alpha
DDB :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.18 1997/08/06 01:45:21 deraadt Exp $	*/
d717 1
@


1.18
log
@do not clobber errno in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.17 1997/06/24 20:59:10 deraadt Exp $	*/
d724 1
a724 1
				  fsp->f_flags | MNT_UPDATE,
d726 2
a727 1
				syslog(LOG_ERR, "Can't delete exports for %s",
d1654 2
a1655 1
		       fsb->f_flags | MNT_UPDATE, (caddr_t)&args) < 0) {
d1687 1
a1687 1
				syslog(LOG_ERR, "Can't export %s", dirp);
@


1.17
log
@in_addr_t all over
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.16 1997/05/04 21:05:28 millert Exp $	*/
d179 1
d305 1
a305 1
	signal(SIGHUP, (void (*) __P((int))) get_exportlist);
d654 9
@


1.16
log
@Fix writing of pid file.  From Matthieu Herrb <Mathieu.Herrb@@mipnet.fr>
Closes OpenBSD PR#178
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.15 1997/04/11 17:09:02 millert Exp $	*/
d122 3
a124 3
	u_long	nt_net;
	u_long	nt_mask;
	char *nt_name;
d166 1
a166 1
int	chk_host __P((struct dirlist *, u_long, int *, int *));
d195 1
a195 1
int	scan_tree __P((struct dirlist *, u_long));
d343 1
a343 1
	u_long saddr;
d1174 1
a1174 1
	u_long saddr;
d1220 1
a1220 1
	u_long saddr;
d1378 1
a1378 1
	u_long saddr;
d1569 1
a1569 1
	u_long net;
d1703 1
a1703 1
	long netaddr;
@


1.15
log
@ - check existing pid file and don't start up if there is already
   a mountd running
 - if there is a problem with an entry in an exports line don't
   throw away the whole line unless it is obviously bogus.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.14 1997/01/15 23:41:28 millert Exp $	*/
d298 2
a299 2
		fprintf(pidfile, "%d\n", getpid());
		fclose(pidfile);
d301 2
@


1.14
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.13 1996/12/10 07:26:45 deraadt Exp $	*/
d78 1
a202 5
/* C library */
int	getnetgrent();
void	endnetgrent();
void	setnetgrent();

d287 11
a297 4
	signal(SIGHUP, (void (*) __P((int))) get_exportlist);
	signal(SIGTERM, (void (*) __P((int))) send_umntall);
	{ FILE *pidfile = fopen(_PATH_MOUNTDPID, "w");
	  if (pidfile != NULL) {
d300 1
a300 1
	  }
d302 2
d837 2
a838 1
			    netgrp = getnetgrent(&hst, &usr, &dom);
d856 2
a857 1
			    } while (netgrp && getnetgrent(&hst, &usr, &dom));
d899 18
a916 5
		    if (do_mount(ep, grp, exflags, &anon, dirp,
			dirplen, &fsb)) {
			getexp_err(ep, tgrp);
			goto nextline;
		    }
d1542 2
a1543 1
 * the kernel.
d1656 1
a1656 1
				return (1);
d1662 1
a1662 1
				return (1);
d1674 1
a1674 1
				return (1);
@


1.13
log
@64 bit & -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.12 1996/12/05 23:14:27 millert Exp $	*/
d252 1
a252 1
	while ((c = getopt(argc, argv, "dnr")) != EOF)
@


1.12
log
@Stop info gathering attack pointed out by Alan Cox <alan@@cymru.net>
Only return ENOENT if the dir trying to be mounted is really exported
to the client.  Return EACCESS if not exported.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.11 1996/09/28 05:47:42 downsj Exp $	*/
d279 1
a279 1
		fprintf(stderr,"Getting export list.\n");
d282 1
a282 1
		fprintf(stderr,"Getting mount list.\n");
d285 1
a285 1
		fprintf(stderr,"Here we go.\n");
d420 1
a420 1
				fprintf(stderr,"Mount successful.\n");
d660 2
a661 2
	char *cp, *endcp, *dirp, *hst, *usr, *dom, savedc;
	int len, has_host, exflags, got_nondir, dirplen, num, i, netgrp;
d726 1
a726 1
			fprintf(stderr,"Got line %s\n",line);
d865 1
a865 1
				fprintf(stderr,"Adding a default entry\n");
d872 1
a872 1
			hpe->h_length = sizeof (u_long);
d1158 1
a1158 1
	u_long **addrp;
d1168 1
a1168 1
			    addrp = (u_long **)
d1244 1
a1244 1
	char *cp, *endcp, *cpopt, savedc, savedc2;
d1255 1
a1255 1
		if (cpoptend = strchr(cpopt, ',')) {
d1257 1
a1257 1
			if (cpoptarg = strchr(cpopt, '='))
d1260 1
a1260 1
			if (cpoptarg = strchr(cpopt, '='))
d1365 1
a1365 1
				syslog(LOG_ERR, "Inet_addr failed for %s.",cp);
d1373 1
a1373 1
				hp->h_length = sizeof (u_long);
d1379 2
a1380 1
			syslog(LOG_ERR, "Gethostbyname failed for %s.",cp);
d1535 1
a1535 1
	u_long **addrp;
d1558 1
a1558 1
		addrp = (u_long **)grp->gr_ptr.gt_hostent->h_addr_list;
d1560 1
a1560 1
		addrp = (u_long **)NULL;
d1651 1
a1651 1
					fprintf(stderr,"mnt unsucc\n");
d1660 1
a1660 1
			if (*addrp == (u_long *)NULL)
d1684 1
a1684 1
	if (np = getnetbyname(cp))
d1699 1
a1699 1
			while (np = getnetent()) {
d1883 1
a1883 1
		syslog(LOG_ERR, "Can't open %s", _PATH_RMOUNTLIST);
d1930 2
a1931 1
			syslog(LOG_ERR,"Can't update %s", _PATH_RMOUNTLIST);
d1966 1
a1966 1
		syslog(LOG_ERR, "Can't update %s", _PATH_RMOUNTLIST);
@


1.11
log
@Correct spelling, from NetBSD PR#2783, seebs@@taniemarie.solon.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.10 1996/09/19 06:12:08 deraadt Exp $	*/
d339 1
a339 1
	long bad = ENOENT;
d374 1
a374 3
			if (!svc_sendreply(transp, xdr_long, (caddr_t)&bad))
				syslog(LOG_ERR, "Can't send reply");
			return;
d386 7
d421 1
a421 1
		} else {
d423 3
a425 3
			if (!svc_sendreply(transp, xdr_long, (caddr_t)&bad))
				syslog(LOG_ERR, "Can't send reply");
		}
@


1.10
log
@bad is long for xdr_long(); from cgd@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.9 1996/08/29 17:41:32 deraadt Exp $	*/
d415 1
a415 1
				fprintf(stderr,"Mount successfull.\n");
@


1.9
log
@bogus exports entry crash; from candy@@fct.kgc.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.8 1996/07/02 10:43:56 deraadt Exp $	*/
d339 2
a340 1
	int bad = ENOENT, defset, hostset;
@


1.8
log
@permit -alldirs, but document it
@
text
@d1 1
a1 1
/*	$OpenBSD: mountd.c,v 1.7 1996/06/25 15:57:20 deraadt Exp $	*/
d1380 2
a1381 1
		if (checkgrp->gr_ptr.gt_hostent != NULL &&
@


1.7
log
@from wpaul@@freebsd, more than a year ago: only put each host to export to
onto the export list once.
from jeorg@@freebsd/grog@@lemis.de, also, strdup() to avoid a later crash
in free().
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1630 1
d1634 1
@


1.6
log
@From NetBSD: Merge of 960317
@
text
@d144 1
d179 1
a179 1
int	get_host __P((char *, struct grouplist *));
d833 1
a833 1
				    if (get_host(hst, grp)) {
d839 1
a839 1
				} else if (get_host(cp, grp)) {
d864 1
a864 1
			hpe->h_name = "Default";
d1340 1
a1340 1
get_host(cp, grp)
d1343 1
d1345 1
d1377 10
d1595 2
@


1.5
log
@If mountd is unable to export a filesystem due to a hostname being invalid
or specified on two (conflicting) lines it now logs the offending hostname
@
text
@d1 2
a2 1
/*	$NetBSD: mountd.c,v 1.30 1995/11/28 05:25:47 jtc Exp $	*/
d48 1
a48 1
static char sccsid[] = "@@(#)mountd.c	8.8 (Berkeley) 2/20/94";
d50 1
a50 1
static char rcsid[] = "$NetBSD: mountd.c,v 1.30 1995/11/28 05:25:47 jtc Exp $";
d70 1
a70 1
#include <nfs/nfsv2.h>
d106 2
d146 1
d151 6
d160 1
a160 1
				struct grouplist *));
d164 1
a164 1
int	chk_host __P((struct dirlist *, u_long, int *));
d168 1
a168 1
				struct ucred *, char *, int, struct statfs *));
d179 1
d198 1
a198 1
int	xdr_fhs __P((XDR *, nfsv2fh_t *));
d251 1
a251 1
	while ((c = getopt(argc, argv, "dn")) != EOF)
d259 3
d304 1
d306 3
a308 1
	    IPPROTO_UDP) ||
d310 3
a312 1
	    IPPROTO_TCP)) {
d331 1
a331 1
	nfsv2fh_t nfh;
d338 2
a339 2
	int bad = ENOENT, defset;
	sigset_t sigset, osigset;
d341 2
d378 1
a378 3
		sigemptyset(&sigset);
		sigaddset(&sigset, SIGHUP);
		sigprocmask(SIG_BLOCK, &sigset, &osigset);
d380 2
a381 2
		defset = 0;
		if (ep && (chk_host(ep->ex_defdir, saddr, &defset) ||
d383 1
a383 1
		     chk_host(dp, saddr, &defset)) ||
d386 5
d392 2
a393 2
			memset(&nfh, 0, sizeof(nfh));
			if (getfh(dirpath, (fhandle_t *)&nfh) < 0) {
d399 1
a399 1
				sigprocmask(SIG_SETMASK, &osigset, NULL);
d402 1
a402 1
			if (!svc_sendreply(transp, xdr_fhs, (caddr_t)&nfh))
d419 1
a419 1
		sigprocmask(SIG_SETMASK, &osigset, NULL);
d475 1
a475 1
 * Xdr routine to generate fhstatus
d478 1
a478 1
xdr_fhs(xdrsp, nfh)
d480 1
a480 1
	nfsv2fh_t *nfh;
d482 2
a483 1
	long ok = 0;
d487 19
a505 1
	return (xdr_opaque(xdrsp, (caddr_t)nfh, NFSX_FH));
d546 1
a546 1
	sigset_t sigset, osigset;
d548 3
a550 3
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGHUP);
	sigprocmask(SIG_BLOCK, &sigset, &osigset);
d562 1
a562 1
	sigprocmask(SIG_SETMASK, &osigset, NULL);
d567 1
a567 1
	sigprocmask(SIG_SETMASK, &osigset, NULL);
d835 1
d896 1
a896 1
			hang_dirp(dirhead, tgrp, ep, (opt_flags & OP_ALLDIRS));
d901 1
a901 1
			(opt_flags & OP_ALLDIRS));
d1025 1
a1025 1
hang_dirp(dp, grp, ep, alldirs)
d1029 1
a1029 1
	int alldirs;
d1034 1
a1034 1
	if (alldirs) {
d1039 1
a1039 1
		if (grp == (struct grouplist *)NULL)
d1041 3
a1043 1
		else while (grp) {
d1045 2
d1059 1
a1059 1
			add_dlist(&ep->ex_dirl, dp, grp);
d1070 1
a1070 1
add_dlist(dpp, newdp, grp)
d1074 1
d1084 1
a1084 1
			add_dlist(&dp->dp_left, newdp, grp);
d1087 1
a1087 1
			add_dlist(&dp->dp_right, newdp, grp);
d1103 2
d1110 1
a1110 1
	} else
d1112 3
d1143 1
a1143 1
chk_host(dp, saddr, defsetp)
d1147 1
d1155 1
a1155 1
			*defsetp = 1;
d1164 2
a1165 1
				if (**addrp == saddr)
d1167 1
d1173 2
a1174 1
				grp->gr_ptr.gt_net.nt_net)
d1176 1
d1193 1
a1193 1
	int defset;
d1198 1
a1198 1
		if (chk_host(dp, saddr, &defset))
d1452 1
d1615 2
a1616 1
				syslog(LOG_ERR, "Not root dir");
@


1.4
log
@from netbsd:
Don't require compiling with -DDEBUG to enable debugging messages.  Instead,
add a new option flag "-d", which enables debugging output.  Compile all
of the code that used to be enabled with -DDEBUG unconditionally.  The
amount of extra code is negligable, and all of the tests to check if
debugging is enabled were done regardless of -DDEBUG anyway.  Adjust
SYSLOG() to DTRT if debugging is not enabled.
@
text
@d1297 1
a1297 1
				syslog(LOG_ERR, "Inet_addr failed");
d1311 1
a1311 1
			syslog(LOG_ERR, "Gethostbyname failed");
d1544 8
a1551 1
				   "Can't change attributes for %s.\n", dirp);
@


1.3
log
@fix mounting two filesystems on the same point; from osymh@@gemini.oscs.montana.edu; netbsd pr#1722
@
text
@d1 1
a1 1
/*	$NetBSD: mountd.c,v 1.27.2.1 1995/11/01 00:06:22 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: mountd.c,v 1.27.2.1 1995/11/01 00:06:22 jtc Exp $";
a84 1
#ifdef DEBUG
a85 1
#endif
d221 1
a221 2
#ifdef DEBUG
int debug = 1;
a222 4
#define syslog SYSLOG
#else
int debug = 0;
#endif
d229 1
d240 1
a240 1
	while ((c = getopt(argc, argv, "n")) != EOF)
d242 3
d249 1
a249 1
			fprintf(stderr, "Usage: mountd [-n] [export_file]\n");
a1927 1
#ifdef DEBUG
d1934 6
a1939 1
	vfprintf(stderr, fmt, ap);
a1941 1
#endif /* DEBUG */
@


1.2
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d656 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mountd.c,v 1.27 1995/08/19 16:08:05 chopps Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: mountd.c,v 1.27 1995/08/19 16:08:05 chopps Exp $";
d639 1
a639 1
	 *      instead of just MOUNT_UFS.
d652 1
a652 1
		    !strncmp(fsp->f_fstypename, MOUNT_UFS, MFSNAMELEN) ||
d1536 1
a1536 1
		 * exportable file systems and not just MOUNT_UFS.
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

