head	1.218;
access;
symbols
	OPENBSD_6_1_BASE:1.218
	OPENBSD_6_0:1.139.0.2
	OPENBSD_6_0_BASE:1.139
	OPENBSD_5_9:1.138.0.2
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.124.0.4
	OPENBSD_5_8_BASE:1.124
	OPENBSD_5_7:1.114.0.2
	OPENBSD_5_7_BASE:1.114
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.99.0.4
	OPENBSD_5_5_BASE:1.99
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.92.0.2
	OPENBSD_5_2_BASE:1.92
	OPENBSD_5_1_BASE:1.91
	OPENBSD_5_1:1.91.0.2
	OPENBSD_5_0:1.89.0.2
	OPENBSD_5_0_BASE:1.89
	OPENBSD_4_9:1.88.0.4
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.83.0.4
	OPENBSD_4_6_BASE:1.83
	OPENBSD_4_5:1.78.0.10
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.78.0.8
	OPENBSD_4_4_BASE:1.78
	OPENBSD_4_3:1.78.0.6
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.78.0.4
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.78.0.2
	OPENBSD_4_1_BASE:1.78
	OPENBSD_4_0:1.77.0.2
	OPENBSD_4_0_BASE:1.77
	OPENBSD_3_9:1.73.0.2
	OPENBSD_3_9_BASE:1.73
	OPENBSD_3_8:1.72.0.2
	OPENBSD_3_8_BASE:1.72
	OPENBSD_3_7:1.70.0.2
	OPENBSD_3_7_BASE:1.70
	OPENBSD_3_6:1.67.0.2
	OPENBSD_3_6_BASE:1.67
	OPENBSD_3_5:1.65.0.2
	OPENBSD_3_5_BASE:1.65
	OPENBSD_3_4:1.63.0.2
	OPENBSD_3_4_BASE:1.63
	OPENBSD_3_3:1.57.0.4
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.57.0.2
	OPENBSD_3_2_BASE:1.57
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	OPENBSD_3_0:1.46.0.2
	OPENBSD_3_0_BASE:1.46
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_8:1.41.0.4
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.41.0.2
	OPENBSD_2_7_BASE:1.41
	OPENBSD_2_6:1.40.0.2
	OPENBSD_2_6_BASE:1.40
	OPENBSD_2_5:1.38.0.2
	OPENBSD_2_5_BASE:1.38
	OPENBSD_2_4:1.35.0.2
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.30.0.2
	OPENBSD_2_3_BASE:1.30
	OPENBSD_2_2:1.25.0.2
	OPENBSD_2_2_BASE:1.25
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.218
date	2017.02.22.13.43.35;	author renato;	state Exp;
branches;
next	1.217;
commitid	XLxmobGQ93qfeLYG;

1.217
date	2016.10.20.18.34.17;	author florian;	state Exp;
branches;
next	1.216;
commitid	Mho0XojDkkcN7U7E;

1.216
date	2016.09.28.06.39.12;	author florian;	state Exp;
branches;
next	1.215;
commitid	sMHkRo7iaWZ6XuW4;

1.215
date	2016.09.26.16.42.46;	author florian;	state Exp;
branches;
next	1.214;
commitid	t5T5WgjNT9RySxCW;

1.214
date	2016.09.20.15.21.34;	author deraadt;	state Exp;
branches;
next	1.213;
commitid	WufR0sw51ytof9th;

1.213
date	2016.09.19.07.08.30;	author florian;	state Exp;
branches;
next	1.212;
commitid	YccDj7tyB5lxV1ax;

1.212
date	2016.09.18.17.27.25;	author florian;	state Exp;
branches;
next	1.211;
commitid	yKBPz9MPyqK0VRZr;

1.211
date	2016.09.18.15.14.08;	author deraadt;	state Exp;
branches;
next	1.210;
commitid	qYa1A109AAKczGyW;

1.210
date	2016.09.18.14.52.14;	author deraadt;	state Exp;
branches;
next	1.209;
commitid	VRjUcvyOvqmetURJ;

1.209
date	2016.09.18.13.59.51;	author florian;	state Exp;
branches;
next	1.208;
commitid	KrSKnPchMI590UHU;

1.208
date	2016.09.18.13.56.15;	author florian;	state Exp;
branches;
next	1.207;
commitid	bkgosNgpr5AKEtZp;

1.207
date	2016.09.17.21.30.02;	author florian;	state Exp;
branches;
next	1.206;
commitid	3DtnsDdg0W7Z0bf7;

1.206
date	2016.09.17.14.58.42;	author florian;	state Exp;
branches;
next	1.205;
commitid	N51b00OFIERZj92R;

1.205
date	2016.09.17.09.38.26;	author florian;	state Exp;
branches;
next	1.204;
commitid	J6izx2deGqs7HTXG;

1.204
date	2016.09.17.09.37.19;	author florian;	state Exp;
branches;
next	1.203;
commitid	VXIW5hLWj3p7QBRC;

1.203
date	2016.09.17.09.36.42;	author florian;	state Exp;
branches;
next	1.202;
commitid	ybQkETOZGLFbgd7B;

1.202
date	2016.09.17.09.35.27;	author florian;	state Exp;
branches;
next	1.201;
commitid	zl0WmJ4UB2IldOBs;

1.201
date	2016.09.17.09.34.57;	author florian;	state Exp;
branches;
next	1.200;
commitid	oXHML5mNRSG5MZM9;

1.200
date	2016.09.17.09.34.03;	author florian;	state Exp;
branches;
next	1.199;
commitid	JFOa47OdFlxWSfjj;

1.199
date	2016.09.17.09.33.32;	author florian;	state Exp;
branches;
next	1.198;
commitid	ql6UIu7tpjvnr8qF;

1.198
date	2016.09.17.09.32.54;	author florian;	state Exp;
branches;
next	1.197;
commitid	kYplsKt4gYWCNSQH;

1.197
date	2016.09.17.09.31.04;	author florian;	state Exp;
branches;
next	1.196;
commitid	ewOnmc3utFvgY7Uu;

1.196
date	2016.09.17.09.30.26;	author florian;	state Exp;
branches;
next	1.195;
commitid	bYBtf4iPzvpFb37M;

1.195
date	2016.09.17.09.30.00;	author florian;	state Exp;
branches;
next	1.194;
commitid	gdMOeoHOLVdrEvE3;

1.194
date	2016.09.17.09.29.27;	author florian;	state Exp;
branches;
next	1.193;
commitid	ulvkzlJMDAF58Gvl;

1.193
date	2016.09.17.09.26.49;	author florian;	state Exp;
branches;
next	1.192;
commitid	JKzSi8pcb6Mfsimw;

1.192
date	2016.09.17.09.26.07;	author florian;	state Exp;
branches;
next	1.191;
commitid	jtpsxfJ8IxpJhFyf;

1.191
date	2016.09.17.09.22.31;	author florian;	state Exp;
branches;
next	1.190;
commitid	9bGcFZKIqtx3p22Y;

1.190
date	2016.09.17.09.21.59;	author florian;	state Exp;
branches;
next	1.189;
commitid	NVU7EVrcRpRAlnuB;

1.189
date	2016.09.17.09.21.16;	author florian;	state Exp;
branches;
next	1.188;
commitid	rbhI96S3Txvc4ROn;

1.188
date	2016.09.17.09.19.44;	author florian;	state Exp;
branches;
next	1.187;
commitid	SnamYclZ9tq3rNd6;

1.187
date	2016.09.17.09.17.55;	author florian;	state Exp;
branches;
next	1.186;
commitid	6Q8Safx81IpeN4zv;

1.186
date	2016.09.17.09.16.32;	author florian;	state Exp;
branches;
next	1.185;
commitid	NzLBw21CU7S7rhwX;

1.185
date	2016.09.17.09.14.30;	author florian;	state Exp;
branches;
next	1.184;
commitid	LfvoSUWQetdjXRgL;

1.184
date	2016.09.13.07.17.40;	author florian;	state Exp;
branches;
next	1.183;
commitid	Rk6ObdFanSHRQR6z;

1.183
date	2016.09.13.07.16.49;	author florian;	state Exp;
branches;
next	1.182;
commitid	7VewTkSlpddNRZ4T;

1.182
date	2016.09.13.07.15.03;	author florian;	state Exp;
branches;
next	1.181;
commitid	3czwrlpDlEOrhOKV;

1.181
date	2016.09.13.07.14.24;	author florian;	state Exp;
branches;
next	1.180;
commitid	2uzA0YUAElO5xdqx;

1.180
date	2016.09.13.07.11.56;	author florian;	state Exp;
branches;
next	1.179;
commitid	ymGjdsu5NS1IScFV;

1.179
date	2016.09.12.15.47.57;	author florian;	state Exp;
branches;
next	1.178;
commitid	IUGBF8idEez36TTs;

1.178
date	2016.09.12.06.02.43;	author florian;	state Exp;
branches;
next	1.177;
commitid	JdjyWoQjYkA9CkQL;

1.177
date	2016.09.12.06.01.58;	author florian;	state Exp;
branches;
next	1.176;
commitid	4Gzt9v73RxVWPzXW;

1.176
date	2016.09.11.19.59.25;	author florian;	state Exp;
branches;
next	1.175;
commitid	RlUr3dXORyX75RgQ;

1.175
date	2016.09.11.19.44.43;	author florian;	state Exp;
branches;
next	1.174;
commitid	Y1XsOvE3VBYkfKD8;

1.174
date	2016.09.11.18.28.31;	author florian;	state Exp;
branches;
next	1.173;
commitid	ObCKJCjHRMCDprSG;

1.173
date	2016.09.11.18.27.44;	author florian;	state Exp;
branches;
next	1.172;
commitid	YqSGK2P5FqPcJZue;

1.172
date	2016.09.11.18.24.44;	author florian;	state Exp;
branches;
next	1.171;
commitid	8sXzOHnY4gBajEeR;

1.171
date	2016.09.11.18.21.09;	author florian;	state Exp;
branches;
next	1.170;
commitid	j9dyZgLmg3q5YWX4;

1.170
date	2016.09.11.18.19.32;	author florian;	state Exp;
branches;
next	1.169;
commitid	gtTg1sxkeC3mojTD;

1.169
date	2016.09.11.18.18.25;	author florian;	state Exp;
branches;
next	1.168;
commitid	DxMzrCNVuZ3pj31q;

1.168
date	2016.09.11.18.04.07;	author florian;	state Exp;
branches;
next	1.167;
commitid	LGVxe2LhUmmzsail;

1.167
date	2016.09.11.18.03.12;	author florian;	state Exp;
branches;
next	1.166;
commitid	QwOlXjP1pIxaOoXv;

1.166
date	2016.09.11.18.01.24;	author florian;	state Exp;
branches;
next	1.165;
commitid	2VrmwiqoRl7Os0eI;

1.165
date	2016.09.11.17.58.21;	author florian;	state Exp;
branches;
next	1.164;
commitid	NoUU9ER3gtVgad8P;

1.164
date	2016.09.11.17.55.05;	author florian;	state Exp;
branches;
next	1.163;
commitid	PmmLDbFm0EJBR7gX;

1.163
date	2016.09.11.17.50.56;	author florian;	state Exp;
branches;
next	1.162;
commitid	VEKtwQvWNh1hnsMj;

1.162
date	2016.09.11.11.19.27;	author florian;	state Exp;
branches;
next	1.161;
commitid	UValYUVkuvZRa6GK;

1.161
date	2016.09.11.11.18.11;	author florian;	state Exp;
branches;
next	1.160;
commitid	yB7x7sE10I4jRfP3;

1.160
date	2016.09.10.07.47.00;	author florian;	state Exp;
branches;
next	1.159;
commitid	9wvYOKPIJ6hW5kAE;

1.159
date	2016.09.10.07.46.20;	author florian;	state Exp;
branches;
next	1.158;
commitid	1OwjUcHfEHG5WEJt;

1.158
date	2016.09.10.07.42.20;	author florian;	state Exp;
branches;
next	1.157;
commitid	Cj0ERH3jRHj5afrE;

1.157
date	2016.09.10.07.40.58;	author florian;	state Exp;
branches;
next	1.156;
commitid	KVwCj18y4RIjlARl;

1.156
date	2016.09.10.07.39.49;	author florian;	state Exp;
branches;
next	1.155;
commitid	l41HhVVPzzdCYJ3R;

1.155
date	2016.09.10.07.31.43;	author florian;	state Exp;
branches;
next	1.154;
commitid	xHG6UmFUJDM8lKSn;

1.154
date	2016.09.08.13.59.33;	author florian;	state Exp;
branches;
next	1.153;
commitid	YpSTXviIjeDqZOlp;

1.153
date	2016.09.08.13.58.15;	author florian;	state Exp;
branches;
next	1.152;
commitid	1Oqo1EjCh7bjzwy9;

1.152
date	2016.09.07.17.56.00;	author florian;	state Exp;
branches;
next	1.151;
commitid	2a5WL8bAWwIkyBrf;

1.151
date	2016.09.07.17.55.14;	author florian;	state Exp;
branches;
next	1.150;
commitid	XleWBoM1lYtpFh3U;

1.150
date	2016.09.07.17.53.53;	author florian;	state Exp;
branches;
next	1.149;
commitid	a0G1J9Ss5Et9wfBZ;

1.149
date	2016.09.07.17.52.56;	author florian;	state Exp;
branches;
next	1.148;
commitid	XC1M814uIIeTM9T4;

1.148
date	2016.09.04.09.36.37;	author florian;	state Exp;
branches;
next	1.147;
commitid	4SZzhCoQ4GoIb6xO;

1.147
date	2016.09.03.21.50.52;	author florian;	state Exp;
branches;
next	1.146;
commitid	MVRMi4d1FASPvLzQ;

1.146
date	2016.09.03.21.49.55;	author florian;	state Exp;
branches;
next	1.145;
commitid	2D1LGibvQlDFrkQq;

1.145
date	2016.09.03.21.48.51;	author florian;	state Exp;
branches;
next	1.144;
commitid	99DVSyUH3XQMh3Mh;

1.144
date	2016.09.02.21.46.18;	author florian;	state Exp;
branches;
next	1.143;
commitid	oBQMp11wORSRB4JY;

1.143
date	2016.09.02.14.15.58;	author florian;	state Exp;
branches;
next	1.142;
commitid	Ilje6tO1nAn5qiqA;

1.142
date	2016.08.30.14.28.31;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	3abf2zIDdzi8zwhq;

1.141
date	2016.08.30.13.58.12;	author millert;	state Exp;
branches;
next	1.140;
commitid	0a5uQGPt7p5yMRsu;

1.140
date	2016.08.30.12.10.10;	author florian;	state Exp;
branches;
next	1.139;
commitid	HuKDnsKr2swBwjWi;

1.139
date	2016.03.03.18.30.48;	author florian;	state Exp;
branches;
next	1.138;
commitid	kLdbxgpRjkk0XaLr;

1.138
date	2016.01.30.05.38.26;	author semarie;	state Exp;
branches;
next	1.137;
commitid	uFaQox6LSTMSbQ90;

1.137
date	2015.11.29.22.42.13;	author florian;	state Exp;
branches;
next	1.136;
commitid	WCZsR1LlVF2crQkf;

1.136
date	2015.11.29.22.41.20;	author florian;	state Exp;
branches;
next	1.135;
commitid	Mf1d1GyWDPSh4QXP;

1.135
date	2015.11.29.12.32.10;	author florian;	state Exp;
branches;
next	1.134;
commitid	qqS1UKFJGoFAz0rz;

1.134
date	2015.11.10.18.36.33;	author florian;	state Exp;
branches;
next	1.133;
commitid	SlMlKJPFbG8mpckN;

1.133
date	2015.11.05.21.53.35;	author florian;	state Exp;
branches;
next	1.132;
commitid	6nvQXvn8vWTadmzX;

1.132
date	2015.11.04.21.26.30;	author tedu;	state Exp;
branches;
next	1.131;
commitid	nSnFqH97ozIJAVfM;

1.131
date	2015.10.30.11.00.52;	author florian;	state Exp;
branches;
next	1.130;
commitid	RVAyog1IjALKdX7Y;

1.130
date	2015.10.29.13.01.29;	author florian;	state Exp;
branches;
next	1.129;
commitid	4xtNX0D7952DEc1t;

1.129
date	2015.10.27.13.58.45;	author dlg;	state Exp;
branches;
next	1.128;
commitid	YBVR5B0wrVvjT9Co;

1.128
date	2015.10.11.00.20.29;	author guenther;	state Exp;
branches;
next	1.127;
commitid	p83AfJYsoHS8dtNj;

1.127
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.126;
commitid	sbrB3Q5CNxcwZpfU;

1.126
date	2015.10.03.00.44.37;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	edXxx7agLA4fyrml;

1.125
date	2015.09.03.17.59.54;	author florian;	state Exp;
branches;
next	1.124;
commitid	lDt22b3bb6uLsnPq;

1.124
date	2015.08.05.12.46.12;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	2d23O6YgAFKOsEOv;

1.123
date	2015.05.02.18.03.37;	author florian;	state Exp;
branches;
next	1.122;
commitid	8UEKCqV8h8FhV8nS;

1.122
date	2015.05.02.17.16.07;	author florian;	state Exp;
branches;
next	1.121;
commitid	X68xDARUM9bL5oY6;

1.121
date	2015.04.20.00.36.51;	author dlg;	state Exp;
branches;
next	1.120;
commitid	Bmlm42H4EwJQwcE3;

1.120
date	2015.04.19.12.56.42;	author dlg;	state Exp;
branches;
next	1.119;
commitid	ImfW5QCmybfa5W82;

1.119
date	2015.04.19.12.45.37;	author dlg;	state Exp;
branches;
next	1.118;
commitid	y3ux2bBTKGaNSW5E;

1.118
date	2015.03.23.09.36.25;	author dlg;	state Exp;
branches;
next	1.117;
commitid	PolqxtNsGQs8f6M7;

1.117
date	2015.03.12.09.54.11;	author florian;	state Exp;
branches;
next	1.116;
commitid	76fmqmF7GJ3r5bFi;

1.116
date	2015.03.12.00.14.29;	author dlg;	state Exp;
branches;
next	1.115;
commitid	yJqJnYL1i1LGngtu;

1.115
date	2015.03.11.03.35.17;	author dlg;	state Exp;
branches;
next	1.114;
commitid	FAjZ8nOAjOuu31RR;

1.114
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	Uu5nFG3wCl0LACBb;

1.113
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.112;
commitid	HIbf8HnT4wFtIrOp;

1.112
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.111;
commitid	RKMpGS78lskgSHj4;

1.111
date	2014.07.11.15.30.47;	author florian;	state Exp;
branches;
next	1.110;
commitid	DWNxYGoK2201FRXe;

1.110
date	2014.07.11.15.29.46;	author florian;	state Exp;
branches;
next	1.109;
commitid	mv0uuh5wYgKFaHmv;

1.109
date	2014.07.11.15.26.55;	author florian;	state Exp;
branches;
next	1.108;
commitid	xBp9yk5adDyq1Bne;

1.108
date	2014.07.09.15.24.19;	author florian;	state Exp;
branches;
next	1.107;
commitid	6VLjITLr1ODzmtr0;

1.107
date	2014.07.09.15.23.29;	author florian;	state Exp;
branches;
next	1.106;
commitid	TlyNkDDOeYcvnGDZ;

1.106
date	2014.07.09.15.22.36;	author florian;	state Exp;
branches;
next	1.105;
commitid	8BfV5K2soa28qhii;

1.105
date	2014.07.09.15.21.41;	author florian;	state Exp;
branches;
next	1.104;
commitid	r2vqCAhtuD6kw8lW;

1.104
date	2014.07.09.15.20.51;	author florian;	state Exp;
branches;
next	1.103;
commitid	oesJ5go4D1E5SvUr;

1.103
date	2014.04.28.15.25.34;	author florian;	state Exp;
branches;
next	1.102;

1.102
date	2014.04.23.18.16.36;	author jca;	state Exp;
branches;
next	1.101;

1.101
date	2014.04.23.12.27.31;	author florian;	state Exp;
branches;
next	1.100;

1.100
date	2014.03.24.11.11.49;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.10.21.57.44;	author florian;	state Exp;
branches;
next	1.98;

1.98
date	2014.01.10.06.18.40;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2013.10.28.15.05.35;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2013.09.12.23.06.44;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2013.04.16.22.10.34;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2012.03.17.10.16.40;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2011.09.20.09.46.19;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2011.09.17.14.10.05;	author haesbaert;	state Exp;
branches;
next	1.89;

1.89
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.26.18.30.03;	author phessler;	state Exp;
branches;
next	1.86;

1.86
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.85;

1.85
date	2009.12.15.21.09.43;	author mpf;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.05.00.11.26;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.05.00.07.47;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.01.14.16.02;	author jmc;	state Exp;
branches;
next	1.80;

1.80
date	2009.05.31.17.33.39;	author ckuethe;	state Exp;
branches;
next	1.79;

1.79
date	2009.04.23.23.18.35;	author sthen;	state Exp;
branches;
next	1.78;

1.78
date	2007.02.06.15.25.18;	author jmc;	state Exp;
branches;
next	1.77;

1.77
date	2006.04.13.00.49.15;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2006.04.10.08.05.13;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.23.03.30.49;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.06.10.45.56;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2006.01.09.22.42.35;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2005.09.01.17.59.13;	author otto;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.27.04.55.27;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.19.13.40.47;	author mpf;	state Exp;
branches;
next	1.69;

1.69
date	2004.09.14.23.52.46;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2004.09.14.23.51.34;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.03.20.55.46;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.21.20.00.55;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2004.02.29.05.19.37;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2003.07.24.03.10.04;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2003.04.14.19.57.38;	author cloder;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.14.10.21.03;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.06.21.17.39;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2002.07.03.09.39.28;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.29.07.56.44;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.22.22.47.45;	author jakob;	state Exp;
branches;
next	1.53;

1.53
date	2002.05.31.04.54.36;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2002.05.31.04.53.10;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.31.01.11.31;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.17.02.04.38;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.28.08.08.20;	author hugh;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.04.07.37.24;	author jakob;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.03.19.36.49;	author jakob;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.12.20.07.05;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.11.19.22.09;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.21.00.25.17;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2000.01.22.20.25.04;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	99.10.12.18.10.16;	author hugh;	state Exp;
branches;
next	1.39;

1.39
date	99.07.18.16.21.55;	author hugh;	state Exp;
branches;
next	1.38;

1.38
date	99.02.24.21.02.41;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	99.02.23.20.04.37;	author kjell;	state Exp;
branches;
next	1.36;

1.36
date	98.11.18.16.50.05;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	98.05.17.01.46.51;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	98.05.16.21.14.17;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	98.05.16.05.57.46;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	98.05.16.05.52.36;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.04.30.23.34.12;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.04.03.11.27.58;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.04.02.20.52.53;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.03.31.23.04.10;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.03.03.19.06.11;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	98.02.05.04.56.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.08.06.01.45.24;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.06.29.19.23.07;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.06.23.22.45.53;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.06.11.10.04.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.06.05.10.02.31;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.06.02.08.08.01;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.06.01.21.35.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.06.01.21.19.08;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.05.29.15.55.34;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.02.04.16.44.14;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.04.14.52.56;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.01.30.22.43.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.15.23.41.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.12.22.03.00.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.12.14.15.35.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.14.02.16.42;	author bitblt;	state Exp;
branches;
next	1.9;

1.9
date	96.12.10.08.37.06;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.23.10.36.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.23.10.31.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.23.08.36.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.23.02.30.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.22.21.12.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.32.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.19.11.18.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.218
log
@Unbreak "ping6 -L"

$ ping6 -L ff02::1%em1
ping6: setsockopt IP6_MULTICAST_LOOP: Invalid argument

Unfortunately we have this inconsistency in the sockets API where we need
to pass an unsigned char for IP_MULTICAST_LOOP but we need an unsigned
int for IPV6_MULTICAST_LOOP.

While here, fix a typo in the error message.

OK millert@@ florian@@
@
text
@/*	$OpenBSD: ping.c,v 1.217 2016/10/20 18:34:17 florian Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Muuss.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Using the InterNet Control Message Protocol (ICMP) "ECHO" facility,
 * measure round-trip-delays and packet loss across network paths.
 *
 * Author -
 *	Mike Muuss
 *	U. S. Army Ballistic Research Laboratory
 *	December, 1983
 *
 * Status -
 *	Public Domain.  Distribution Unlimited.
 * Bugs -
 *	More statistics could always be gathered.
 *	This program has to run SUID to ROOT to access the ICMP socket.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_var.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet/ip_ah.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <siphash.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

struct tv64 {
	u_int64_t	tv64_sec;
	u_int64_t	tv64_nsec;
};

struct payload {
	struct tv64	tv64;
	u_int8_t	mac[SIPHASH_DIGEST_LENGTH];
};

#define	ECHOLEN		8	/* icmp echo header len excluding time */
#define	ECHOTMLEN	sizeof(struct payload)
#define	DEFDATALEN	(64 - ECHOLEN)		/* default data length */
#define	MAXIPLEN	60
#define	MAXICMPLEN	76
#define	MAXPAYLOAD	(IP_MAXPACKET - MAXIPLEN - ECHOLEN)
#define	IP6LEN		40
#define	EXTRA		256	/* for AH and various other headers. weird. */
#define	MAXPAYLOAD6	IPV6_MAXPACKET - IP6LEN - ECHOLEN
#define	MAXWAIT_DEFAULT	10			/* secs to wait for response */
#define	NROUTES		9			/* number of record route slots */

#define	A(bit)		rcvd_tbl[(bit)>>3]	/* identify byte in array */
#define	B(bit)		(1 << ((bit) & 0x07))	/* identify bit in byte */
#define	SET(bit)	(A(bit) |= B(bit))
#define	CLR(bit)	(A(bit) &= (~B(bit)))
#define	TST(bit)	(A(bit) & B(bit))

/* various options */
int options;
#define	F_FLOOD		0x0001
#define	F_INTERVAL	0x0002
#define	F_HOSTNAME	0x0004
#define	F_PINGFILLED	0x0008
#define	F_QUIET		0x0010
#define	F_RROUTE	0x0020
#define	F_SO_DEBUG	0x0040
/*			0x0080 */
#define	F_VERBOSE	0x0100
/*			0x0200 */
#define	F_HDRINCL	0x0400
#define	F_TTL		0x0800
/*			0x1000 */
#define	F_AUD_RECV	0x2000
#define	F_AUD_MISS	0x4000

/* multicast options */
int moptions;
#define	MULTICAST_NOLOOP	0x001
#define	MULTICAST_TTL		0x002

#define	DUMMY_PORT	10101
#define	PING_USER	"_ping"

/*
 * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum
 * number of received sequence numbers we can keep track of.  Change 128
 * to 8192 for complete accuracy...
 */
#define	MAX_DUP_CHK	(8 * 8192)
int mx_dup_ck = MAX_DUP_CHK;
char rcvd_tbl[MAX_DUP_CHK / 8];

int datalen = DEFDATALEN;
int maxpayload = MAXPAYLOAD;
u_char outpackhdr[IP_MAXPACKET+sizeof(struct ip)];
u_char *outpack = outpackhdr+sizeof(struct ip);
char BSPACE = '\b';		/* characters written for flood */
char DOT = '.';
char *hostname;
int ident;			/* process id to identify our packets */
int v6flag = 0;			/* are we ping6? */

/* counters */
int64_t npackets;		/* max packets to transmit */
int64_t nreceived;		/* # of packets we got back */
int64_t nrepeats;		/* number of duplicates */
int64_t ntransmitted;		/* sequence # for outbound packets = #sent */
int64_t nmissedmax = 1;		/* max value of ntransmitted - nreceived - 1 */
struct timeval interval = {1, 0}; /* interval between packets */

/* timing */
int timing = 0;			/* flag to do timing */
int timinginfo = 0;
unsigned int maxwait = MAXWAIT_DEFAULT;	/* max seconds to wait for response */
double tmin = 999999999.0;	/* minimum round trip time */
double tmax = 0.0;		/* maximum round trip time */
double tsum = 0.0;		/* sum of all times, for doing average */
double tsumsq = 0.0;		/* sum of all times squared, for std. dev. */

struct tv64 tv64_offset;
SIPHASH_KEY mac_key;

struct msghdr smsghdr;
struct iovec smsgiov;

volatile sig_atomic_t seenalrm;
volatile sig_atomic_t seenint;
volatile sig_atomic_t seeninfo;

void			 fill(char *, char *);
void			 summary(void);
void			 onsignal(int);
void			 retransmit(int);
int			 pinger(int);
const char		*pr_addr(struct sockaddr *, socklen_t);
void			 pr_pack(u_char *, int, struct msghdr *);
__dead void		 usage(void);

/* IPv4 specific functions */
void			 pr_ipopt(int, u_char *);
int			 in_cksum(u_short *, int);
void			 pr_icmph(struct icmp *);
void			 pr_retip(struct ip *);
void			 pr_iph(struct ip *);
#ifndef SMALL
int			 map_tos(char *, int *);
#endif	/* SMALL */

/* IPv6 specific functions */
int			 get_hoplim(struct msghdr *);
int			 get_pathmtu(struct msghdr *, struct sockaddr_in6 *);
void			 pr_icmph6(struct icmp6_hdr *, u_char *);
void			 pr_iph6(struct ip6_hdr *);
void			 pr_exthdrs(struct msghdr *);
void			 pr_ip6opt(void *);
void			 pr_rthdr(void *);
void			 pr_retip6(struct ip6_hdr *, u_char *);

int
main(int argc, char *argv[])
{
	struct addrinfo hints, *res;
	struct itimerval itimer;
	struct sockaddr *from, *dst;
	struct sockaddr_in from4, dst4;
	struct sockaddr_in6 from6, dst6;
	struct cmsghdr *scmsg = NULL;
	struct in6_pktinfo *pktinfo = NULL;
	struct icmp6_filter filt;
	struct passwd *pw;
	socklen_t maxsizelen;
	int64_t preload;
	int ch, i, optval = 1, packlen, maxsize, error, s;
	int df = 0, tos = 0, bufspace = IP_MAXPACKET, hoplimit = -1, mflag = 0;
	u_char *datap, *packet;
	u_char ttl = MAXTTL;
	char *e, *target, hbuf[NI_MAXHOST], *source = NULL;
	char rspace[3 + 4 * NROUTES + 1];	/* record route space */
	const char *errstr;
	double intval;
	uid_t ouid, uid;
	gid_t gid;
	u_int rtableid = 0;
	extern char *__progname;

	if (strcmp("ping6", __progname) == 0) {
		v6flag = 1;
		maxpayload = MAXPAYLOAD6;
		if ((s = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) == -1)
			err(1, "socket");
	} else {
		if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) == -1)
			err(1, "socket");
	}

	/* revoke privs */
	ouid = getuid();
	if (ouid == 0 && (pw = getpwnam(PING_USER)) != NULL) {
		uid = pw->pw_uid;
		gid = pw->pw_gid;
	} else {
		uid = getuid();
		gid = getgid();
	}
	if (setgroups(1, &gid) ||
	    setresgid(gid, gid, gid) ||
	    setresuid(uid, uid, uid))
		err(1, "unable to revoke privs");

	preload = 0;
	datap = &outpack[ECHOLEN + ECHOTMLEN];
	while ((ch = getopt(argc, argv, v6flag ?
	    "c:dEefHh:I:i:Ll:mNnp:qS:s:V:vw:" :
	    "DEI:LRS:c:defHi:l:np:qs:T:t:V:vw:")) != -1) {
		switch(ch) {
		case 'c':
			npackets = strtonum(optarg, 0, INT64_MAX, &errstr);
			if (errstr)
				errx(1,
				    "number of packets to transmit is %s: %s",
				    errstr, optarg);
			break;
		case 'D':
			options |= F_HDRINCL;
			df = 1;
			break;
		case 'd':
			options |= F_SO_DEBUG;
			break;
		case 'E':
			options |= F_AUD_MISS;
			break;
		case 'e':
			options |= F_AUD_RECV;
			break;
		case 'f':
			if (ouid)
				errc(1, EPERM, NULL);
			options |= F_FLOOD;
			setvbuf(stdout, NULL, _IONBF, 0);
			break;
		case 'H':
			options |= F_HOSTNAME;
			break;
		case 'h':		/* hoplimit */
			hoplimit = strtonum(optarg, 0, IPV6_MAXHLIM, &errstr);
			if (errstr)
				errx(1, "hoplimit is %s: %s", errstr, optarg);
			break;
		case 'I':
		case 'S':	/* deprecated */
			source = optarg;
			break;
		case 'i':		/* wait between sending packets */
			intval = strtod(optarg, &e);
			if (*optarg == '\0' || *e != '\0')
				errx(1, "illegal timing interval %s", optarg);
			if (intval < 1 && ouid)
				errx(1, "only root may use interval < 1s");
			interval.tv_sec = (time_t)intval;
			interval.tv_usec =
			    (long)((intval - interval.tv_sec) * 1000000);
			if (interval.tv_sec < 0)
				errx(1, "illegal timing interval %s", optarg);
			/* less than 1/Hz does not make sense */
			if (interval.tv_sec == 0 && interval.tv_usec < 10000) {
				warnx("too small interval, raised to 0.01");
				interval.tv_usec = 10000;
			}
			options |= F_INTERVAL;
			break;
		case 'L':
			moptions |= MULTICAST_NOLOOP;
			break;
		case 'l':
			if (ouid)
				errc(1, EPERM, NULL);
			preload = strtonum(optarg, 1, INT64_MAX, &errstr);
			if (errstr)
				errx(1, "preload value is %s: %s", errstr,
				    optarg);
			break;
		case 'm':
			mflag++;
			break;
		case 'n':
			options &= ~F_HOSTNAME;
			break;
		case 'p':		/* fill buffer with user pattern */
			options |= F_PINGFILLED;
			fill((char *)datap, optarg);
				break;
		case 'q':
			options |= F_QUIET;
			break;
		case 'R':
			options |= F_RROUTE;
			break;
		case 's':		/* size of packet to send */
			datalen = strtonum(optarg, 0, maxpayload, &errstr);
			if (errstr)
				errx(1, "packet size is %s: %s", errstr,
				    optarg);
			break;
#ifndef SMALL
		case 'T':
			options |= F_HDRINCL;
			errno = 0;
			errstr = NULL;
			if (map_tos(optarg, &tos))
				break;
			if (strlen(optarg) > 1 && optarg[0] == '0' &&
			    optarg[1] == 'x')
				tos = (int)strtol(optarg, NULL, 16);
			else
				tos = strtonum(optarg, 0, 255, &errstr);
			if (tos < 0 || tos > 255 || errstr || errno)
				errx(1, "illegal tos value %s", optarg);
			break;
#endif	/* SMALL */
		case 't':
			options |= F_TTL;
			ttl = strtonum(optarg, 0, MAXTTL, &errstr);
			if (errstr)
				errx(1, "ttl value is %s: %s", errstr, optarg);
			break;
		case 'V':
			rtableid = strtonum(optarg, 0, RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "rtable value is %s: %s", errstr,
				    optarg);
			if (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
			    sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
			break;
		case 'v':
			options |= F_VERBOSE;
			break;
		case 'w':
			maxwait = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "maxwait value is %s: %s",
				    errstr, optarg);
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	memset(&dst4, 0, sizeof(dst4));
	memset(&dst6, 0, sizeof(dst6));

	target = *argv;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = v6flag ? AF_INET6 : AF_INET;
	hints.ai_socktype = SOCK_RAW;
	hints.ai_protocol = 0;
	hints.ai_flags = AI_CANONNAME;
	if ((error = getaddrinfo(target, NULL, &hints, &res)))
		errx(1, "%s", gai_strerror(error));

	switch (res->ai_family) {
	case AF_INET:
		if (res->ai_addrlen != sizeof(dst4))
			errx(1, "size of sockaddr mismatch");
		dst = (struct sockaddr *)&dst4;
		from = (struct sockaddr *)&from4;
		break;
	case AF_INET6:
		if (res->ai_addrlen != sizeof(dst6))
			errx(1, "size of sockaddr mismatch");
		dst = (struct sockaddr *)&dst6;
		from = (struct sockaddr *)&from6;
		break;
	default:
		errx(1, "unsupported AF: %d", res->ai_family);
		break;
	}

	memcpy(dst, res->ai_addr, res->ai_addrlen);

	if (!hostname) {
		hostname = res->ai_canonname ? strdup(res->ai_canonname) :
		    target;
		if (!hostname)
			err(1, "malloc");
	}

	if (res->ai_next) {
		if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(hbuf, "?", sizeof(hbuf));
		warnx("Warning: %s has multiple "
		    "addresses; using %s", hostname, hbuf);
	}
	freeaddrinfo(res);

	if (source) {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = dst->sa_family;
		if ((error = getaddrinfo(source, NULL, &hints, &res)))
			errx(1, "%s: %s", source, gai_strerror(error));
		if (res->ai_addrlen != dst->sa_len)
			errx(1, "size of sockaddr mismatch");
		memcpy(from, res->ai_addr, res->ai_addrlen);
		freeaddrinfo(res);

		if (!v6flag && IN_MULTICAST(ntohl(dst4.sin_addr.s_addr))) {
			if (setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF,
			    &from4.sin_addr, sizeof(from4.sin_addr)) < 0)
				err(1, "setsockopt IP_MULTICAST_IF");
		} else {
			if (bind(s, from, from->sa_len) < 0)
				err(1, "bind");
		}
	} else if (options & F_VERBOSE) {
		/*
		 * get the source address. XXX since we revoked the root
		 * privilege, we cannot use a raw socket for this.
		 */
		int dummy;
		socklen_t len = dst->sa_len;

		if ((dummy = socket(dst->sa_family, SOCK_DGRAM, 0)) < 0)
			err(1, "UDP socket");

		memcpy(from, dst, dst->sa_len);
		if (v6flag) {
			from6.sin6_port = ntohs(DUMMY_PORT);
			if (pktinfo &&
			    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTINFO,
			    (void *)pktinfo, sizeof(*pktinfo)))
				err(1, "UDP setsockopt(IPV6_PKTINFO)");

			if (hoplimit != -1 &&
			    setsockopt(dummy, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
			    (void *)&hoplimit, sizeof(hoplimit)))
				err(1, "UDP setsockopt(IPV6_UNICAST_HOPS)");

			if (hoplimit != -1 &&
			    setsockopt(dummy, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
			    (void *)&hoplimit, sizeof(hoplimit)))
				err(1, "UDP setsockopt(IPV6_MULTICAST_HOPS)");
		} else {
			u_char loop = 0;

			from4.sin_port = ntohs(DUMMY_PORT);

			if ((moptions & MULTICAST_NOLOOP) && setsockopt(dummy,
			    IPPROTO_IP, IP_MULTICAST_LOOP, &loop,
			    sizeof(loop)) < 0)
				err(1, "setsockopt IP_MULTICAST_LOOP");
			if ((moptions & MULTICAST_TTL) && setsockopt(dummy,
			    IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
			    sizeof(ttl)) < 0)
				err(1, "setsockopt IP_MULTICAST_TTL");
		}

		if (rtableid > 0 &&
		    setsockopt(dummy, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) < 0)
			err(1, "setsockopt(SO_RTABLE)");

		if (connect(dummy, from, len) < 0)
			err(1, "UDP connect");

		if (getsockname(dummy, from, &len) < 0)
			err(1, "getsockname");

		close(dummy);
	}

	if (options & F_SO_DEBUG)
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, &optval,
		    sizeof(optval));

	if ((options & F_FLOOD) && (options & F_INTERVAL))
		errx(1, "-f and -i options are incompatible");

	if ((options & F_FLOOD) && (options & (F_AUD_RECV | F_AUD_MISS)))
		warnx("No audible output for flood pings");

	if (datalen >= sizeof(struct payload))	/* can we time transfer */
		timing = 1;

	if (v6flag) {
		/* in F_VERBOSE case, we may get non-echoreply packets*/
		if (options & F_VERBOSE && datalen < 2048) /* XXX 2048? */
			packlen = 2048 + IP6LEN + ECHOLEN + EXTRA;
		else
			packlen = datalen + IP6LEN + ECHOLEN + EXTRA;
	} else
		packlen = datalen + MAXIPLEN + MAXICMPLEN;
	if (!(packet = malloc(packlen)))
		err(1, "malloc");

	if (!(options & F_PINGFILLED))
		for (i = ECHOTMLEN; i < datalen; ++i)
			*datap++ = i;

	ident = getpid() & 0xFFFF;

	/*
	 * When trying to send large packets, you must increase the
	 * size of both the send and receive buffers...
	 */
	maxsizelen = sizeof maxsize;
	if (getsockopt(s, SOL_SOCKET, SO_SNDBUF, &maxsize, &maxsizelen) < 0)
		err(1, "getsockopt");
	if (maxsize < packlen &&
	    setsockopt(s, SOL_SOCKET, SO_SNDBUF, &packlen, sizeof(maxsize)) < 0)
		err(1, "setsockopt");

	/*
	 * When pinging the broadcast address, you can get a lot of answers.
	 * Doing something so evil is useful if you are trying to stress the
	 * ethernet, or just want to fill the arp cache to get some stuff for
	 * /etc/ethers.
	 */
	while (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
	    (void*)&bufspace, sizeof(bufspace)) < 0) {
		if ((bufspace -= 1024) <= 0)
			err(1, "Cannot set the receive buffer size");
	}
	if (bufspace < IP_MAXPACKET)
		warnx("Could only allocate a receive buffer of %d bytes "
		    "(default %d)", bufspace, IP_MAXPACKET);

	if (v6flag) {
		unsigned int loop = 0;

		/*
		 * let the kernel pass extension headers of incoming packets,
		 * for privileged socket options
		 */
		if ((options & F_VERBOSE) != 0) {
			int opton = 1;

			if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPOPTS,
			    &opton, (socklen_t)sizeof(opton)))
				err(1, "setsockopt(IPV6_RECVHOPOPTS)");
			if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVDSTOPTS,
			    &opton, (socklen_t)sizeof(opton)))
				err(1, "setsockopt(IPV6_RECVDSTOPTS)");
			if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDR, &opton,
			    sizeof(opton)))
				err(1, "setsockopt(IPV6_RECVRTHDR)");
			ICMP6_FILTER_SETPASSALL(&filt);
		} else {
			ICMP6_FILTER_SETBLOCKALL(&filt);
			ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filt);
		}

		if ((moptions & MULTICAST_NOLOOP) &&
		    setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &loop,
		    sizeof(loop)) < 0)
			err(1, "setsockopt IPV6_MULTICAST_LOOP");

		optval = IPV6_DEFHLIM;
		if (IN6_IS_ADDR_MULTICAST(&dst6.sin6_addr))
			if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
			    &optval, (socklen_t)sizeof(optval)) == -1)
				err(1, "IPV6_MULTICAST_HOPS");
		if (mflag != 1) {
			optval = mflag > 1 ? 0 : 1;

			if (setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU,
			    &optval, (socklen_t)sizeof(optval)) == -1)
				err(1, "setsockopt(IPV6_USE_MIN_MTU)");
		} else {
			optval = 1;
			if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPATHMTU,
			    &optval, sizeof(optval)) == -1)
				err(1, "setsockopt(IPV6_RECVPATHMTU)");
		}

		if (setsockopt(s, IPPROTO_ICMPV6, ICMP6_FILTER, &filt,
		    (socklen_t)sizeof(filt)) < 0)
			err(1, "setsockopt(ICMP6_FILTER)");

		if (hoplimit != -1) {
			/* set IP6 packet options */
			if ((scmsg = malloc( CMSG_SPACE(sizeof(int)))) == NULL)
				err(1, "malloc");
			smsghdr.msg_control = (caddr_t)scmsg;
			smsghdr.msg_controllen = CMSG_SPACE(sizeof(int));

			scmsg->cmsg_len = CMSG_LEN(sizeof(int));
			scmsg->cmsg_level = IPPROTO_IPV6;
			scmsg->cmsg_type = IPV6_HOPLIMIT;
			*(int *)(CMSG_DATA(scmsg)) = hoplimit;
		}

		optval = 1;
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &optval,
		    (socklen_t)sizeof(optval)) < 0)
			warn("setsockopt(IPV6_RECVPKTINFO)"); /* XXX err? */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &optval,
		    (socklen_t)sizeof(optval)) < 0)
			warn("setsockopt(IPV6_RECVHOPLIMIT)"); /* XXX err? */
	} else {
		u_char loop = 0;

		if (options & F_TTL) {
			if (IN_MULTICAST(ntohl(dst4.sin_addr.s_addr)))
				moptions |= MULTICAST_TTL;
			else
				options |= F_HDRINCL;
		}

		if (options & F_RROUTE && options & F_HDRINCL)
			errx(1, "-R option and -D or -T, or -t to unicast"
			    " destinations are incompatible");

		if (options & F_HDRINCL) {
			struct ip *ip = (struct ip *)outpackhdr;

			setsockopt(s, IPPROTO_IP, IP_HDRINCL, &optval,
			    sizeof(optval));
			ip->ip_v = IPVERSION;
			ip->ip_hl = sizeof(struct ip) >> 2;
			ip->ip_tos = tos;
			ip->ip_id = 0;
			ip->ip_off = htons(df ? IP_DF : 0);
			ip->ip_ttl = ttl;
			ip->ip_p = IPPROTO_ICMP;
			if (source)
				ip->ip_src = from4.sin_addr;
			else
				ip->ip_src.s_addr = INADDR_ANY;
			ip->ip_dst = dst4.sin_addr;
		}

		/* record route option */
		if (options & F_RROUTE) {
			if (IN_MULTICAST(ntohl(dst4.sin_addr.s_addr)))
				errx(1, "record route not valid to multicast"
				    " destinations");
			memset(rspace, 0, sizeof(rspace));
			rspace[IPOPT_OPTVAL] = IPOPT_RR;
			rspace[IPOPT_OLEN] = sizeof(rspace)-1;
			rspace[IPOPT_OFFSET] = IPOPT_MINOFF;
			if (setsockopt(s, IPPROTO_IP, IP_OPTIONS, rspace,
			    sizeof(rspace)) < 0) {
				perror("ping: record route");
				exit(1);
			}
		}

		if ((moptions & MULTICAST_NOLOOP) &&
		    setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &loop,
		    sizeof(loop)) < 0)
			err(1, "setsockopt IP_MULTICAST_LOOP");
		if ((moptions & MULTICAST_TTL) &&
		    setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
		    sizeof(ttl)) < 0)
			err(1, "setsockopt IP_MULTICAST_TTL");
	}

	if (options & F_HOSTNAME) {
		if (pledge("stdio inet dns", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio inet", NULL) == -1)
			err(1, "pledge");
	}

	arc4random_buf(&tv64_offset, sizeof(tv64_offset));
	arc4random_buf(&mac_key, sizeof(mac_key));

	printf("PING %s (", hostname);
	if (options & F_VERBOSE)
		printf("%s --> ", pr_addr(from, from->sa_len));
	printf("%s): %d data bytes\n", pr_addr(dst, dst->sa_len), datalen);

	smsghdr.msg_name = dst;
	smsghdr.msg_namelen = dst->sa_len;
	smsgiov.iov_base = (caddr_t)outpack;
	smsghdr.msg_iov = &smsgiov;
	smsghdr.msg_iovlen = 1;

	while (preload--)		/* Fire off them quickies. */
		pinger(s);

	(void)signal(SIGINT, onsignal);
	(void)signal(SIGINFO, onsignal);

	if ((options & F_FLOOD) == 0) {
		(void)signal(SIGALRM, onsignal);
		itimer.it_interval = interval;
		itimer.it_value = interval;
		(void)setitimer(ITIMER_REAL, &itimer, NULL);
		if (ntransmitted == 0)
			retransmit(s);
	}

	seenalrm = seenint = 0;
	seeninfo = 0;

	for (;;) {
		struct msghdr		m;
		union {
			struct cmsghdr hdr;
			u_char buf[CMSG_SPACE(1024)];
		}			cmsgbuf;
		struct iovec		iov[1];
		struct pollfd		pfd;
		struct sockaddr_in	peer4;
		struct sockaddr_in6	peer6;
		ssize_t			cc;
		int			timeout;

		/* signal handling */
		if (seenint)
			break;
		if (seenalrm) {
			retransmit(s);
			seenalrm = 0;
			if (ntransmitted - nreceived - 1 > nmissedmax) {
				nmissedmax = ntransmitted - nreceived - 1;
				if (!(options & F_FLOOD) &&
				    (options & F_AUD_MISS))
					(void)fputc('\a', stderr);
			}
			continue;
		}
		if (seeninfo) {
			summary();
			seeninfo = 0;
			continue;
		}

		if (options & F_FLOOD) {
			(void)pinger(s);
			timeout = 10;
		} else
			timeout = INFTIM;

		pfd.fd = s;
		pfd.events = POLLIN;

		if (poll(&pfd, 1, timeout) <= 0)
			continue;

		if (v6flag) {
			m.msg_name = &peer6;
			m.msg_namelen = sizeof(peer6);
		} else {
			m.msg_name = &peer4;
			m.msg_namelen = sizeof(peer4);
		}
		memset(&iov, 0, sizeof(iov));
		iov[0].iov_base = (caddr_t)packet;
		iov[0].iov_len = packlen;
		m.msg_iov = iov;
		m.msg_iovlen = 1;
		m.msg_control = (caddr_t)&cmsgbuf.buf;
		m.msg_controllen = sizeof(cmsgbuf.buf);

		cc = recvmsg(s, &m, 0);
		if (cc < 0) {
			if (errno != EINTR) {
				warn("recvmsg");
				sleep(1);
			}
			continue;
		} else if (cc == 0) {
			int mtu;

			/*
			 * receive control messages only. Process the
			 * exceptions (currently the only possibility is
			 * a path MTU notification.)
			 */
			if ((mtu = get_pathmtu(&m, &dst6)) > 0) {
				if ((options & F_VERBOSE) != 0) {
					printf("new path MTU (%d) is "
					    "notified\n", mtu);
				}
			}
			continue;
		} else
			pr_pack(packet, cc, &m);

		if (npackets && nreceived >= npackets)
			break;
	}
	summary();
	exit(nreceived == 0);
}

void
onsignal(int sig)
{
	switch (sig) {
	case SIGALRM:
		seenalrm++;
		break;
	case SIGINT:
		seenint++;
		break;
	case SIGINFO:
		seeninfo++;
		break;
	}
}

void
fill(char *bp, char *patp)
{
	int ii, jj, kk;
	int pat[16];
	char *cp;

	for (cp = patp; *cp; cp++)
		if (!isxdigit((unsigned char)*cp))
			errx(1, "patterns must be specified as hex digits");
	ii = sscanf(patp,
	    "%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x",
	    &pat[0], &pat[1], &pat[2], &pat[3], &pat[4], &pat[5], &pat[6],
	    &pat[7], &pat[8], &pat[9], &pat[10], &pat[11], &pat[12],
	    &pat[13], &pat[14], &pat[15]);

	if (ii > 0)
		for (kk = 0;
		    kk <= maxpayload - (ECHOLEN + ECHOTMLEN + ii);
		    kk += ii)
			for (jj = 0; jj < ii; ++jj)
				bp[jj + kk] = pat[jj];
	if (!(options & F_QUIET)) {
		(void)printf("PATTERN: 0x");
		for (jj = 0; jj < ii; ++jj)
			(void)printf("%02x", bp[jj] & 0xFF);
		(void)printf("\n");
	}
}

void
summary(void)
{
	printf("\n--- %s ping statistics ---\n", hostname);
	printf("%lld packets transmitted, ", ntransmitted);
	printf("%lld packets received, ", nreceived);

	if (nrepeats)
		printf("%lld duplicates, ", nrepeats);
	if (ntransmitted) {
		if (nreceived > ntransmitted)
			printf("-- somebody's duplicating packets!");
		else
			printf("%.1f%% packet loss",
			    ((((double)ntransmitted - nreceived) * 100) /
			    ntransmitted));
	}
	printf("\n");
	if (timinginfo) {
		/* Only display average to microseconds */
		double num = nreceived + nrepeats;
		double avg = tsum / num;
		double dev = sqrt(fmax(0, tsumsq / num - avg * avg));
		printf("round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
		    tmin, avg, tmax, dev);
	}
}

/*
 * pr_addr --
 *	Return address in numeric form or a host name
 */
const char *
pr_addr(struct sockaddr *addr, socklen_t addrlen)
{
	static char buf[NI_MAXHOST];
	int flag = 0;

	if ((options & F_HOSTNAME) == 0)
		flag |= NI_NUMERICHOST;

	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)
		return (buf);
	else
		return "?";
}

/*
 * retransmit --
 *	This routine transmits another ping.
 */
void
retransmit(int s)
{
	struct itimerval itimer;
	static int last_time = 0;

	if (last_time) {
		seenint = 1;	/* break out of ping event loop */
		return;
	}

	if (pinger(s) == 0)
		return;

	/*
	 * If we're not transmitting any more packets, change the timer
	 * to wait two round-trip times if we've received any packets or
	 * maxwait seconds if we haven't.
	 */
	if (nreceived) {
		itimer.it_value.tv_sec = 2 * tmax / 1000;
		if (itimer.it_value.tv_sec == 0)
			itimer.it_value.tv_sec = 1;
	} else
		itimer.it_value.tv_sec = maxwait;
	itimer.it_interval.tv_sec = 0;
	itimer.it_interval.tv_usec = 0;
	itimer.it_value.tv_usec = 0;
	(void)setitimer(ITIMER_REAL, &itimer, NULL);

	/* When the alarm goes off we are done. */
	last_time = 1;
}

/*
 * pinger --
 *	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet
 * will be added on by the kernel.  The ID field is our UNIX process ID,
 * and the sequence number is an ascending integer.  The first 8 bytes
 * of the data portion are used to hold a UNIX "timeval" struct in VAX
 * byte-order, to compute the round-trip time.
 */
int
pinger(int s)
{
	struct icmp *icp = NULL;
	struct icmp6_hdr *icp6 = NULL;
	int cc, i;
	u_int16_t seq;

	if (npackets && ntransmitted >= npackets)
		return(-1);	/* no more transmission */

	seq = htons(ntransmitted++);

	if (v6flag) {
		icp6 = (struct icmp6_hdr *)outpack;
		memset(icp6, 0, sizeof(*icp6));
		icp6->icmp6_cksum = 0;
		icp6->icmp6_type = ICMP6_ECHO_REQUEST;
		icp6->icmp6_code = 0;
		icp6->icmp6_id = htons(ident);
		icp6->icmp6_seq = seq;
	} else {
		icp = (struct icmp *)outpack;
		icp->icmp_type = ICMP_ECHO;
		icp->icmp_code = 0;
		icp->icmp_cksum = 0;
		icp->icmp_seq = seq;
		icp->icmp_id = ident;			/* ID */
	}
	CLR(ntohs(seq) % mx_dup_ck);

	if (timing) {
		SIPHASH_CTX ctx;
		struct timespec ts;
		struct payload payload;
		struct tv64 *tv64 = &payload.tv64;

		if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
			err(1, "clock_gettime(CLOCK_MONOTONIC)");
		tv64->tv64_sec = htobe64((u_int64_t)ts.tv_sec +
		    tv64_offset.tv64_sec);
		tv64->tv64_nsec = htobe64((u_int64_t)ts.tv_nsec +
		    tv64_offset.tv64_nsec);

		SipHash24_Init(&ctx, &mac_key);
		SipHash24_Update(&ctx, tv64, sizeof(*tv64));
		SipHash24_Update(&ctx, &ident, sizeof(ident));
		SipHash24_Update(&ctx, &seq, sizeof(seq));
		SipHash24_Final(&payload.mac, &ctx);

		memcpy(&outpack[ECHOLEN], &payload, sizeof(payload));
	}

	cc = ECHOLEN + datalen;

	if (!v6flag) {
		/* compute ICMP checksum here */
		icp->icmp_cksum = in_cksum((u_short *)icp, cc);

		if (options & F_HDRINCL) {
			struct ip *ip = (struct ip *)outpackhdr;

			smsgiov.iov_base = (caddr_t)outpackhdr;
			cc += sizeof(struct ip);
			ip->ip_len = htons(cc);
			ip->ip_sum = in_cksum((u_short *)outpackhdr, cc);
		}
	}

	smsgiov.iov_len = cc;

	i = sendmsg(s, &smsghdr, 0);

	if (i < 0 || i != cc) {
		if (i < 0)
			warn("sendmsg");
		printf("ping: wrote %s %d chars, ret=%d\n", hostname, cc, i);
	}
	if (!(options & F_QUIET) && options & F_FLOOD)
		(void)write(STDOUT_FILENO, &DOT, 1);

	return (0);
}

/*
 * pr_pack --
 *	Print out the packet, if it came from us.  This logic is necessary
 * because ALL readers of the ICMP socket get a copy of ALL ICMP packets
 * which arrive ('tis only fair).  This permits multiple copies of this
 * program to be run without having intermingled output (or statistics!).
 */
void
pr_pack(u_char *buf, int cc, struct msghdr *mhdr)
{
	struct ip *ip = NULL;
	struct icmp *icp = NULL;
	struct icmp6_hdr *icp6 = NULL;
	struct timespec ts, tp;
	struct payload payload;
	struct sockaddr *from;
	socklen_t fromlen;
	double triptime = 0;
	int i, dupflag;
	int hlen = -1, hoplim = -1, echo_reply = 0;
	u_int16_t seq;
	u_char *cp, *dp;
	char* pkttime;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
		err(1, "clock_gettime(CLOCK_MONOTONIC)");

	if (v6flag) {
		if (!mhdr || !mhdr->msg_name ||
		    mhdr->msg_namelen != sizeof(struct sockaddr_in6) ||
		    ((struct sockaddr *)mhdr->msg_name)->sa_family !=
		    AF_INET6) {
			if (options & F_VERBOSE)
				warnx("invalid peername");
			return;
		}
		from = (struct sockaddr *)mhdr->msg_name;
		fromlen = mhdr->msg_namelen;

		if (cc < sizeof(struct icmp6_hdr)) {
			if (options & F_VERBOSE)
				warnx("packet too short (%d bytes) from %s", cc,
				    pr_addr(from, fromlen));
			return;
		}
		icp6 = (struct icmp6_hdr *)buf;

		if ((hoplim = get_hoplim(mhdr)) == -1) {
			warnx("failed to get receiving hop limit");
			return;
		}

		if (icp6->icmp6_type == ICMP6_ECHO_REPLY) {
			if (ntohs(icp6->icmp6_id) != ident)
				return;			/* 'Twas not our ECHO */
			seq = icp6->icmp6_seq;
			echo_reply = 1;
			pkttime = (char *)(icp6 + 1);
		}
	} else {
		if (!mhdr || !mhdr->msg_name ||
		    mhdr->msg_namelen != sizeof(struct sockaddr_in) ||
		    ((struct sockaddr *)mhdr->msg_name)->sa_family != AF_INET) {
			if (options & F_VERBOSE)
				warnx("invalid peername");
			return;
		}

		from = (struct sockaddr *)mhdr->msg_name;
		fromlen = mhdr->msg_namelen;

		/* Check the IP header */
		ip = (struct ip *)buf;
		hlen = ip->ip_hl << 2;
		if (cc < hlen + ICMP_MINLEN) {
			if (options & F_VERBOSE)
				warnx("packet too short (%d bytes) from %s", cc,
				    pr_addr(from, fromlen));
			return;
		}

		/* Now the ICMP part */
		cc -= hlen;
		icp = (struct icmp *)(buf + hlen);
		if (icp->icmp_type == ICMP_ECHOREPLY) {
			if (icp->icmp_id != ident)
				return;			/* 'Twas not our ECHO */
			seq = icp->icmp_seq;
			echo_reply = 1;
			pkttime = (char *)icp->icmp_data;
		}
	}

	if (echo_reply) {
		++nreceived;
		if (cc >= ECHOLEN + ECHOTMLEN) {
			SIPHASH_CTX ctx;
			struct tv64 *tv64;
			u_int8_t mac[SIPHASH_DIGEST_LENGTH];

			memcpy(&payload, pkttime, sizeof(payload));
			tv64 = &payload.tv64;

			SipHash24_Init(&ctx, &mac_key);
			SipHash24_Update(&ctx, tv64, sizeof(*tv64));
			SipHash24_Update(&ctx, &ident, sizeof(ident));
			SipHash24_Update(&ctx, &seq, sizeof(seq));
			SipHash24_Final(mac, &ctx);

			if (timingsafe_memcmp(mac, &payload.mac,
			    sizeof(mac)) != 0) {
				(void)printf("signature mismatch!\n");
				return;
			}
			timinginfo=1;

			tp.tv_sec = betoh64(tv64->tv64_sec) -
			    tv64_offset.tv64_sec;
			tp.tv_nsec = betoh64(tv64->tv64_nsec) -
			    tv64_offset.tv64_nsec;

			timespecsub(&ts, &tp, &ts);
			triptime = ((double)ts.tv_sec) * 1000.0 +
			    ((double)ts.tv_nsec) / 1000000.0;
			tsum += triptime;
			tsumsq += triptime * triptime;
			if (triptime < tmin)
				tmin = triptime;
			if (triptime > tmax)
				tmax = triptime;
		}

		if (TST(ntohs(seq) % mx_dup_ck)) {
			++nrepeats;
			--nreceived;
			dupflag = 1;
		} else {
			SET(ntohs(seq) % mx_dup_ck);
			dupflag = 0;
		}

		if (options & F_QUIET)
			return;

		if (options & F_FLOOD)
			(void)write(STDOUT_FILENO, &BSPACE, 1);
		else {
			(void)printf("%d bytes from %s: icmp_seq=%u", cc,
			    pr_addr(from, fromlen), ntohs(seq));
			if (v6flag)
				(void)printf(" hlim=%d", hoplim);
			else
				(void)printf(" ttl=%d", ip->ip_ttl);
			if (cc >= ECHOLEN + ECHOTMLEN)
				(void)printf(" time=%.3f ms", triptime);
			if (dupflag)
				(void)printf(" (DUP!)");
			/* check the data */
			if (cc - ECHOLEN < datalen)
				(void)printf(" (TRUNC!)");
			if (v6flag)
				cp = buf + ECHOLEN + ECHOTMLEN;
			else
				cp = (u_char *)&icp->icmp_data[ECHOTMLEN];
			dp = &outpack[ECHOLEN + ECHOTMLEN];
			for (i = ECHOLEN + ECHOTMLEN;
			    i < cc && i < datalen;
			    ++i, ++cp, ++dp) {
				if (*cp != *dp) {
					(void)printf("\nwrong data byte #%d "
					    "should be 0x%x but was 0x%x",
					    i - ECHOLEN, *dp, *cp);
					if (v6flag)
						cp = buf + ECHOLEN;
					else
						cp = (u_char *)
						    &icp->icmp_data[0];
					for (i = ECHOLEN; i < cc && i < datalen;
					    ++i, ++cp) {
						if ((i % 32) == 8)
							(void)printf("\n\t");
						(void)printf("%x ", *cp);
					}
					break;
				}
			}
		}
	} else {
		/* We've got something other than an ECHOREPLY */
		if (!(options & F_VERBOSE))
			return;
		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));
		if (v6flag)
			pr_icmph6(icp6, buf + cc);
		else
			pr_icmph(icp);
	}

	/* Display any IP options */
	if (!v6flag && hlen > sizeof(struct ip))
		pr_ipopt(hlen, buf);

	if (!(options & F_FLOOD)) {
		(void)putchar('\n');
		if (v6flag && (options & F_VERBOSE))
			pr_exthdrs(mhdr);
		(void)fflush(stdout);
		if (options & F_AUD_RECV)
			(void)fputc('\a', stderr);
	}
}

void
pr_ipopt(int hlen, u_char *buf)
{
	static int old_rrlen;
	static char old_rr[MAX_IPOPTLEN];
	struct sockaddr_in s_in;
	in_addr_t l;
	u_int i, j;
	u_char *cp;

	cp = buf + sizeof(struct ip);

	s_in.sin_len = sizeof(s_in);
	s_in.sin_family = AF_INET;

	for (; hlen > sizeof(struct ip); --hlen, ++cp) {
		switch (*cp) {
		case IPOPT_EOL:
			hlen = 0;
			break;
		case IPOPT_LSRR:
			(void)printf("\nLSRR: ");
			hlen -= 2;
			j = *++cp;
			++cp;
			i = 0;
			if (j > IPOPT_MINOFF) {
				for (;;) {
					l = *++cp;
					l = (l<<8) + *++cp;
					l = (l<<8) + *++cp;
					l = (l<<8) + *++cp;
					if (l == 0)
						(void)printf("\t0.0.0.0");
					else {
						s_in.sin_addr.s_addr = ntohl(l);
						(void)printf("\t%s",
						    pr_addr((struct sockaddr*)
						    &s_in, sizeof(s_in)));
					}
					hlen -= 4;
					j -= 4;
					i += 4;
					if (j <= IPOPT_MINOFF)
						break;
					if (i >= MAX_IPOPTLEN) {
						(void)printf("\t(truncated route)");
						break;
					}
					(void)putchar('\n');
				}
			}
			break;
		case IPOPT_RR:
			j = *++cp;		/* get length */
			i = *++cp;		/* and pointer */
			hlen -= 2;
			if (i > j)
				i = j;
			i -= IPOPT_MINOFF;
			if (i <= 0)
				continue;
			if (i == old_rrlen &&
			    cp == buf + sizeof(struct ip) + 2 &&
			    !memcmp(cp, old_rr, i) &&
			    !(options & F_FLOOD)) {
				(void)printf("\t(same route)");
				i = ((i + 3) / 4) * 4;
				hlen -= i;
				cp += i;
				break;
			}
			if (i < MAX_IPOPTLEN) {
				old_rrlen = i;
				memcpy(old_rr, cp, i);
			} else
				old_rrlen = 0;

			(void)printf("\nRR: ");
			j = 0;
			for (;;) {
				l = *++cp;
				l = (l<<8) + *++cp;
				l = (l<<8) + *++cp;
				l = (l<<8) + *++cp;
				if (l == 0)
					(void)printf("\t0.0.0.0");
				else {
					s_in.sin_addr.s_addr = ntohl(l);
					(void)printf("\t%s",
					    pr_addr((struct sockaddr*)&s_in,
					    sizeof(s_in)));
				}
				hlen -= 4;
				i -= 4;
				j += 4;
				if (i <= 0)
					break;
				if (j >= MAX_IPOPTLEN) {
					(void)printf("\t(truncated route)");
					break;
				}
				(void)putchar('\n');
			}
			break;
		case IPOPT_NOP:
			(void)printf("\nNOP");
			break;
		default:
			(void)printf("\nunknown option %x", *cp);
			hlen = hlen - (cp[IPOPT_OLEN] - 1);
			cp = cp + (cp[IPOPT_OLEN] - 1);
			break;
		}
	}
}

/*
 * in_cksum --
 *	Checksum routine for Internet Protocol family headers (C Version)
 */
int
in_cksum(u_short *addr, int len)
{
	int nleft = len;
	u_short *w = addr;
	int sum = 0;
	u_short answer = 0;

	/*
	 * Our algorithm is simple, using a 32 bit accumulator (sum), we add
	 * sequential 16 bit words to it, and at the end, fold back all the
	 * carry bits from the top 16 bits into the lower 16 bits.
	 */
	while (nleft > 1) {
		sum += *w++;
		nleft -= 2;
	}

	/* mop up an odd byte, if necessary */
	if (nleft == 1) {
		*(u_char *)(&answer) = *(u_char *)w ;
		sum += answer;
	}

	/* add back carry outs from top 16 bits to low 16 bits */
	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);			/* add carry */
	answer = ~sum;				/* truncate to 16 bits */
	return(answer);
}

/*
 * pr_icmph --
 *	Print a descriptive string about an ICMP header.
 */
void
pr_icmph(struct icmp *icp)
{
	switch(icp->icmp_type) {
	case ICMP_ECHOREPLY:
		(void)printf("Echo Reply\n");
		/* XXX ID + Seq + Data */
		break;
	case ICMP_UNREACH:
		switch(icp->icmp_code) {
		case ICMP_UNREACH_NET:
			(void)printf("Destination Net Unreachable\n");
			break;
		case ICMP_UNREACH_HOST:
			(void)printf("Destination Host Unreachable\n");
			break;
		case ICMP_UNREACH_PROTOCOL:
			(void)printf("Destination Protocol Unreachable\n");
			break;
		case ICMP_UNREACH_PORT:
			(void)printf("Destination Port Unreachable\n");
			break;
		case ICMP_UNREACH_NEEDFRAG:
			if (icp->icmp_nextmtu != 0)
				(void)printf("frag needed and DF set (MTU %d)\n",
				    ntohs(icp->icmp_nextmtu));
			else
				(void)printf("frag needed and DF set\n");
			break;
		case ICMP_UNREACH_SRCFAIL:
			(void)printf("Source Route Failed\n");
			break;
		case ICMP_UNREACH_NET_UNKNOWN:
			(void)printf("Network Unknown\n");
			break;
		case ICMP_UNREACH_HOST_UNKNOWN:
			(void)printf("Host Unknown\n");
			break;
		case ICMP_UNREACH_ISOLATED:
			(void)printf("Source Isolated\n");
			break;
		case ICMP_UNREACH_NET_PROHIB:
			(void)printf("Dest. Net Administratively Prohibited\n");
			break;
		case ICMP_UNREACH_HOST_PROHIB:
			(void)printf("Dest. Host Administratively Prohibited\n");
			break;
		case ICMP_UNREACH_TOSNET:
			(void)printf("Destination Net Unreachable for TOS\n");
			break;
		case ICMP_UNREACH_TOSHOST:
			(void)printf("Destination Host Unreachable for TOS\n");
			break;
		case ICMP_UNREACH_FILTER_PROHIB:
			(void)printf("Route administratively prohibited\n");
			break;
		case ICMP_UNREACH_HOST_PRECEDENCE:
			(void)printf("Host Precedence Violation\n");
			break;
		case ICMP_UNREACH_PRECEDENCE_CUTOFF:
			(void)printf("Precedence Cutoff\n");
			break;
		default:
			(void)printf("Dest Unreachable, Unknown Code: %d\n",
			    icp->icmp_code);
			break;
		}
		/* Print returned IP header information */
		pr_retip((struct ip *)icp->icmp_data);
		break;
	case ICMP_SOURCEQUENCH:
		(void)printf("Source Quench\n");
		pr_retip((struct ip *)icp->icmp_data);
		break;
	case ICMP_REDIRECT:
		switch(icp->icmp_code) {
		case ICMP_REDIRECT_NET:
			(void)printf("Redirect Network");
			break;
		case ICMP_REDIRECT_HOST:
			(void)printf("Redirect Host");
			break;
		case ICMP_REDIRECT_TOSNET:
			(void)printf("Redirect Type of Service and Network");
			break;
		case ICMP_REDIRECT_TOSHOST:
			(void)printf("Redirect Type of Service and Host");
			break;
		default:
			(void)printf("Redirect, Unknown Code: %d", icp->icmp_code);
			break;
		}
		(void)printf("(New addr: %s)\n",
		    inet_ntoa(icp->icmp_gwaddr));
		pr_retip((struct ip *)icp->icmp_data);
		break;
	case ICMP_ECHO:
		(void)printf("Echo Request\n");
		/* XXX ID + Seq + Data */
		break;
	case ICMP_ROUTERADVERT:
		/* RFC1256 */
		(void)printf("Router Discovery Advertisement\n");
		(void)printf("(%d entries, lifetime %d seconds)\n",
		    icp->icmp_num_addrs, ntohs(icp->icmp_lifetime));
		break;
	case ICMP_ROUTERSOLICIT:
		/* RFC1256 */
		(void)printf("Router Discovery Solicitation\n");
		break;
	case ICMP_TIMXCEED:
		switch(icp->icmp_code) {
		case ICMP_TIMXCEED_INTRANS:
			(void)printf("Time to live exceeded\n");
			break;
		case ICMP_TIMXCEED_REASS:
			(void)printf("Frag reassembly time exceeded\n");
			break;
		default:
			(void)printf("Time exceeded, Unknown Code: %d\n",
			    icp->icmp_code);
			break;
		}
		pr_retip((struct ip *)icp->icmp_data);
		break;
	case ICMP_PARAMPROB:
		switch(icp->icmp_code) {
		case ICMP_PARAMPROB_OPTABSENT:
			(void)printf("Parameter problem, required option "
			    "absent: pointer = 0x%02x\n",
			    ntohs(icp->icmp_hun.ih_pptr));
			break;
		default:
			(void)printf("Parameter problem: pointer = 0x%02x\n",
			    ntohs(icp->icmp_hun.ih_pptr));
			break;
		}
		pr_retip((struct ip *)icp->icmp_data);
		break;
	case ICMP_TSTAMP:
		(void)printf("Timestamp\n");
		/* XXX ID + Seq + 3 timestamps */
		break;
	case ICMP_TSTAMPREPLY:
		(void)printf("Timestamp Reply\n");
		/* XXX ID + Seq + 3 timestamps */
		break;
	case ICMP_IREQ:
		(void)printf("Information Request\n");
		/* XXX ID + Seq */
		break;
	case ICMP_IREQREPLY:
		(void)printf("Information Reply\n");
		/* XXX ID + Seq */
		break;
	case ICMP_MASKREQ:
		(void)printf("Address Mask Request\n");
		break;
	case ICMP_MASKREPLY:
		(void)printf("Address Mask Reply (Mask 0x%08x)\n",
		    ntohl(icp->icmp_mask));
		break;
	default:
		(void)printf("Unknown ICMP type: %d\n", icp->icmp_type);
	}
}

/*
 * pr_iph --
 *	Print an IP header with options.
 */
void
pr_iph(struct ip *ip)
{
	int hlen;
	u_char *cp;

	hlen = ip->ip_hl << 2;
	cp = (u_char *)ip + 20;		/* point to options */

	(void)printf("Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src      Dst Data\n");
	(void)printf(" %1x  %1x  %02x %04x %04x",
	    ip->ip_v, ip->ip_hl, ip->ip_tos, ip->ip_len, ip->ip_id);
	(void)printf("   %1x %04x", ((ip->ip_off) & 0xe000) >> 13,
	    (ip->ip_off) & 0x1fff);
	(void)printf("  %02x  %02x %04x", ip->ip_ttl, ip->ip_p, ip->ip_sum);
	(void)printf(" %s ", inet_ntoa(*(struct in_addr *)&ip->ip_src.s_addr));
	(void)printf(" %s ", inet_ntoa(*(struct in_addr *)&ip->ip_dst.s_addr));
	/* dump and option bytes */
	while (hlen-- > 20) {
		(void)printf("%02x", *cp++);
	}
	(void)putchar('\n');
}

/*
 * pr_retip --
 *	Dump some info on a returned (via ICMP) IP packet.
 */
void
pr_retip(struct ip *ip)
{
	int hlen;
	u_char *cp;

	pr_iph(ip);
	hlen = ip->ip_hl << 2;
	cp = (u_char *)ip + hlen;

	if (ip->ip_p == 6)
		(void)printf("TCP: from port %u, to port %u (decimal)\n",
		    (*cp * 256 + *(cp + 1)), (*(cp + 2) * 256 + *(cp + 3)));
	else if (ip->ip_p == 17)
		(void)printf("UDP: from port %u, to port %u (decimal)\n",
		    (*cp * 256 + *(cp + 1)), (*(cp + 2) * 256 + *(cp + 3)));
}

#ifndef SMALL
int
map_tos(char *key, int *val)
{
	/* DiffServ Codepoints and other TOS mappings */
	const struct toskeywords {
		const char	*keyword;
		int		 val;
	} *t, toskeywords[] = {
		{ "af11",		IPTOS_DSCP_AF11 },
		{ "af12",		IPTOS_DSCP_AF12 },
		{ "af13",		IPTOS_DSCP_AF13 },
		{ "af21",		IPTOS_DSCP_AF21 },
		{ "af22",		IPTOS_DSCP_AF22 },
		{ "af23",		IPTOS_DSCP_AF23 },
		{ "af31",		IPTOS_DSCP_AF31 },
		{ "af32",		IPTOS_DSCP_AF32 },
		{ "af33",		IPTOS_DSCP_AF33 },
		{ "af41",		IPTOS_DSCP_AF41 },
		{ "af42",		IPTOS_DSCP_AF42 },
		{ "af43",		IPTOS_DSCP_AF43 },
		{ "critical",		IPTOS_PREC_CRITIC_ECP },
		{ "cs0",		IPTOS_DSCP_CS0 },
		{ "cs1",		IPTOS_DSCP_CS1 },
		{ "cs2",		IPTOS_DSCP_CS2 },
		{ "cs3",		IPTOS_DSCP_CS3 },
		{ "cs4",		IPTOS_DSCP_CS4 },
		{ "cs5",		IPTOS_DSCP_CS5 },
		{ "cs6",		IPTOS_DSCP_CS6 },
		{ "cs7",		IPTOS_DSCP_CS7 },
		{ "ef",			IPTOS_DSCP_EF },
		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
		{ "lowdelay",		IPTOS_LOWDELAY },
		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
		{ "reliability",	IPTOS_RELIABILITY },
		{ "throughput",		IPTOS_THROUGHPUT },
		{ NULL,			-1 },
	};

	for (t = toskeywords; t->keyword != NULL; t++) {
		if (strcmp(key, t->keyword) == 0) {
			*val = t->val;
			return (1);
		}
	}

	return (0);
}
#endif	/* SMALL */

void
pr_exthdrs(struct msghdr *mhdr)
{
	struct cmsghdr *cm;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	    cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_level != IPPROTO_IPV6)
			continue;

		switch (cm->cmsg_type) {
		case IPV6_HOPOPTS:
			printf("  HbH Options: ");
			pr_ip6opt(CMSG_DATA(cm));
			break;
		case IPV6_DSTOPTS:
		case IPV6_RTHDRDSTOPTS:
			printf("  Dst Options: ");
			pr_ip6opt(CMSG_DATA(cm));
			break;
		case IPV6_RTHDR:
			printf("  Routing: ");
			pr_rthdr(CMSG_DATA(cm));
			break;
		}
	}
}

void
pr_ip6opt(void *extbuf)
{
	struct ip6_hbh *ext;
	int currentlen;
	u_int8_t type;
	size_t extlen;
	socklen_t len;
	void *databuf;
	u_int16_t value2;
	u_int32_t value4;

	ext = (struct ip6_hbh *)extbuf;
	extlen = (ext->ip6h_len + 1) * 8;
	printf("nxt %u, len %u (%lu bytes)\n", ext->ip6h_nxt,
	    (unsigned int)ext->ip6h_len, (unsigned long)extlen);

	currentlen = 0;
	while (1) {
		currentlen = inet6_opt_next(extbuf, extlen, currentlen,
		    &type, &len, &databuf);
		if (currentlen == -1)
			break;
		switch (type) {
		/*
		 * Note that inet6_opt_next automatically skips any padding
		 * options.
		 */
		case IP6OPT_JUMBO:
			inet6_opt_get_val(databuf, 0, &value4, sizeof(value4));
			printf("    Jumbo Payload Opt: Length %u\n",
			    (u_int32_t)ntohl(value4));
			break;
		case IP6OPT_ROUTER_ALERT:
			inet6_opt_get_val(databuf, 0, &value2, sizeof(value2));
			printf("    Router Alert Opt: Type %u\n",
			    ntohs(value2));
			break;
		default:
			printf("    Received Opt %u len %lu\n",
			    type, (unsigned long)len);
			break;
		}
	}
	return;
}

void
pr_rthdr(void *extbuf)
{
	struct in6_addr *in6;
	char ntopbuf[INET6_ADDRSTRLEN];
	struct ip6_rthdr *rh = (struct ip6_rthdr *)extbuf;
	int i, segments;

	/* print fixed part of the header */
	printf("nxt %u, len %u (%d bytes), type %u, ", rh->ip6r_nxt,
	    rh->ip6r_len, (rh->ip6r_len + 1) << 3, rh->ip6r_type);
	if ((segments = inet6_rth_segments(extbuf)) >= 0)
		printf("%d segments, ", segments);
	else
		printf("segments unknown, ");
	printf("%d left\n", rh->ip6r_segleft);

	for (i = 0; i < segments; i++) {
		in6 = inet6_rth_getaddr(extbuf, i);
		if (in6 == NULL)
			printf("   [%d]<NULL>\n", i);
		else {
			if (!inet_ntop(AF_INET6, in6, ntopbuf,
			    sizeof(ntopbuf)))
				strncpy(ntopbuf, "?", sizeof(ntopbuf));
			printf("   [%d]%s\n", i, ntopbuf);
		}
	}

	return;

}

int
get_hoplim(struct msghdr *mhdr)
{
	struct cmsghdr *cm;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_len == 0)
			return(-1);

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			return(*(int *)CMSG_DATA(cm));
	}

	return(-1);
}

int
get_pathmtu(struct msghdr *mhdr, struct sockaddr_in6 *dst)
{
	struct cmsghdr *cm;
	struct ip6_mtuinfo *mtuctl = NULL;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	    cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_len == 0)
			return(0);

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PATHMTU &&
		    cm->cmsg_len == CMSG_LEN(sizeof(struct ip6_mtuinfo))) {
			mtuctl = (struct ip6_mtuinfo *)CMSG_DATA(cm);

			/*
			 * If the notified destination is different from
			 * the one we are pinging, just ignore the info.
			 * We check the scope ID only when both notified value
			 * and our own value have non-0 values, because we may
			 * have used the default scope zone ID for sending,
			 * in which case the scope ID value is 0.
			 */
			if (!IN6_ARE_ADDR_EQUAL(&mtuctl->ip6m_addr.sin6_addr,
			    &dst->sin6_addr) ||
			    (mtuctl->ip6m_addr.sin6_scope_id &&
			    dst->sin6_scope_id &&
			    mtuctl->ip6m_addr.sin6_scope_id !=
			    dst->sin6_scope_id)) {
				if ((options & F_VERBOSE) != 0) {
					printf("path MTU for %s is notified. "
					    "(ignored)\n",
					    pr_addr((struct sockaddr *)
					    &mtuctl->ip6m_addr,
					    sizeof(mtuctl->ip6m_addr)));
				}
				return(0);
			}

			/*
			 * Ignore an invalid MTU. XXX: can we just believe
			 * the kernel check?
			 */
			if (mtuctl->ip6m_mtu < IPV6_MMTU)
				return(0);

			/* notification for our destination. return the MTU. */
			return((int)mtuctl->ip6m_mtu);
		}
	}
	return(0);
}

/*
 * pr_icmph6 --
 *	Print a descriptive string about an ICMP header.
 */
void
pr_icmph6(struct icmp6_hdr *icp, u_char *end)
{
	char ntop_buf[INET6_ADDRSTRLEN];
	struct nd_redirect *red;

	switch (icp->icmp6_type) {
	case ICMP6_DST_UNREACH:
		switch (icp->icmp6_code) {
		case ICMP6_DST_UNREACH_NOROUTE:
			(void)printf("No Route to Destination\n");
			break;
		case ICMP6_DST_UNREACH_ADMIN:
			(void)printf("Destination Administratively "
			    "Unreachable\n");
			break;
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
			(void)printf("Destination Unreachable Beyond Scope\n");
			break;
		case ICMP6_DST_UNREACH_ADDR:
			(void)printf("Destination Host Unreachable\n");
			break;
		case ICMP6_DST_UNREACH_NOPORT:
			(void)printf("Destination Port Unreachable\n");
			break;
		default:
			(void)printf("Destination Unreachable, Bad Code: %d\n",
			    icp->icmp6_code);
			break;
		}
		/* Print returned IP header information */
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_PACKET_TOO_BIG:
		(void)printf("Packet too big mtu = %d\n",
		    (int)ntohl(icp->icmp6_mtu));
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_TIME_EXCEEDED:
		switch (icp->icmp6_code) {
		case ICMP6_TIME_EXCEED_TRANSIT:
			(void)printf("Time to live exceeded\n");
			break;
		case ICMP6_TIME_EXCEED_REASSEMBLY:
			(void)printf("Frag reassembly time exceeded\n");
			break;
		default:
			(void)printf("Time exceeded, Bad Code: %d\n",
			    icp->icmp6_code);
			break;
		}
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_PARAM_PROB:
		(void)printf("Parameter problem: ");
		switch (icp->icmp6_code) {
		case ICMP6_PARAMPROB_HEADER:
			(void)printf("Erroneous Header ");
			break;
		case ICMP6_PARAMPROB_NEXTHEADER:
			(void)printf("Unknown Nextheader ");
			break;
		case ICMP6_PARAMPROB_OPTION:
			(void)printf("Unrecognized Option ");
			break;
		default:
			(void)printf("Bad code(%d) ", icp->icmp6_code);
			break;
		}
		(void)printf("pointer = 0x%02x\n",
		    (u_int32_t)ntohl(icp->icmp6_pptr));
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_ECHO_REQUEST:
		(void)printf("Echo Request");
		/* XXX ID + Seq + Data */
		break;
	case ICMP6_ECHO_REPLY:
		(void)printf("Echo Reply");
		/* XXX ID + Seq + Data */
		break;
	case ICMP6_MEMBERSHIP_QUERY:
		(void)printf("Listener Query");
		break;
	case ICMP6_MEMBERSHIP_REPORT:
		(void)printf("Listener Report");
		break;
	case ICMP6_MEMBERSHIP_REDUCTION:
		(void)printf("Listener Done");
		break;
	case ND_ROUTER_SOLICIT:
		(void)printf("Router Solicitation");
		break;
	case ND_ROUTER_ADVERT:
		(void)printf("Router Advertisement");
		break;
	case ND_NEIGHBOR_SOLICIT:
		(void)printf("Neighbor Solicitation");
		break;
	case ND_NEIGHBOR_ADVERT:
		(void)printf("Neighbor Advertisement");
		break;
	case ND_REDIRECT:
		red = (struct nd_redirect *)icp;
		(void)printf("Redirect\n");
		if (!inet_ntop(AF_INET6, &red->nd_rd_dst, ntop_buf,
		    sizeof(ntop_buf)))
			strncpy(ntop_buf, "?", sizeof(ntop_buf));
		(void)printf("Destination: %s", ntop_buf);
		if (!inet_ntop(AF_INET6, &red->nd_rd_target, ntop_buf,
		    sizeof(ntop_buf)))
			strncpy(ntop_buf, "?", sizeof(ntop_buf));
		(void)printf(" New Target: %s", ntop_buf);
		break;
	default:
		(void)printf("Bad ICMP type: %d", icp->icmp6_type);
	}
}

/*
 * pr_iph6 --
 *	Print an IP6 header.
 */
void
pr_iph6(struct ip6_hdr *ip6)
{
	u_int32_t flow = ip6->ip6_flow & IPV6_FLOWLABEL_MASK;
	u_int8_t tc;
	char ntop_buf[INET6_ADDRSTRLEN];

	tc = *(&ip6->ip6_vfc + 1); /* XXX */
	tc = (tc >> 4) & 0x0f;
	tc |= (ip6->ip6_vfc << 4);

	printf("Vr TC  Flow Plen Nxt Hlim\n");
	printf(" %1x %02x %05x %04x  %02x   %02x\n",
	    (ip6->ip6_vfc & IPV6_VERSION_MASK) >> 4, tc, (u_int32_t)ntohl(flow),
	    ntohs(ip6->ip6_plen), ip6->ip6_nxt, ip6->ip6_hlim);
	if (!inet_ntop(AF_INET6, &ip6->ip6_src, ntop_buf, sizeof(ntop_buf)))
		strncpy(ntop_buf, "?", sizeof(ntop_buf));
	printf("%s->", ntop_buf);
	if (!inet_ntop(AF_INET6, &ip6->ip6_dst, ntop_buf, sizeof(ntop_buf)))
		strncpy(ntop_buf, "?", sizeof(ntop_buf));
	printf("%s\n", ntop_buf);
}

/*
 * pr_retip6 --
 *	Dump some info on a returned (via ICMPv6) IPv6 packet.
 */
void
pr_retip6(struct ip6_hdr *ip6, u_char *end)
{
	u_char *cp = (u_char *)ip6, nh;
	int hlen;

	if (end - (u_char *)ip6 < sizeof(*ip6)) {
		printf("IP6");
		goto trunc;
	}
	pr_iph6(ip6);
	hlen = sizeof(*ip6);

	nh = ip6->ip6_nxt;
	cp += hlen;
	while (end - cp >= 8) {
		switch (nh) {
		case IPPROTO_HOPOPTS:
			printf("HBH ");
			hlen = (((struct ip6_hbh *)cp)->ip6h_len+1) << 3;
			nh = ((struct ip6_hbh *)cp)->ip6h_nxt;
			break;
		case IPPROTO_DSTOPTS:
			printf("DSTOPT ");
			hlen = (((struct ip6_dest *)cp)->ip6d_len+1) << 3;
			nh = ((struct ip6_dest *)cp)->ip6d_nxt;
			break;
		case IPPROTO_FRAGMENT:
			printf("FRAG ");
			hlen = sizeof(struct ip6_frag);
			nh = ((struct ip6_frag *)cp)->ip6f_nxt;
			break;
		case IPPROTO_ROUTING:
			printf("RTHDR ");
			hlen = (((struct ip6_rthdr *)cp)->ip6r_len+1) << 3;
			nh = ((struct ip6_rthdr *)cp)->ip6r_nxt;
			break;
		case IPPROTO_AH:
			printf("AH ");
			hlen = (((struct ah *)cp)->ah_hl+2) << 2;
			nh = ((struct ah *)cp)->ah_nh;
			break;
		case IPPROTO_ICMPV6:
			printf("ICMP6: type = %d, code = %d\n",
			    *cp, *(cp + 1));
			return;
		case IPPROTO_ESP:
			printf("ESP\n");
			return;
		case IPPROTO_TCP:
			printf("TCP: from port %u, to port %u (decimal)\n",
			    (*cp * 256 + *(cp + 1)),
			    (*(cp + 2) * 256 + *(cp + 3)));
			return;
		case IPPROTO_UDP:
			printf("UDP: from port %u, to port %u (decimal)\n",
			    (*cp * 256 + *(cp + 1)),
			    (*(cp + 2) * 256 + *(cp + 3)));
			return;
		default:
			printf("Unknown Header(%d)\n", nh);
			return;
		}

		if ((cp += hlen) >= end)
			goto trunc;
	}
	if (end - cp < 8)
		goto trunc;

	putchar('\n');
	return;

  trunc:
	printf("...\n");
	return;
}

__dead void
usage(void)
{
	if (v6flag) {
		(void)fprintf(stderr,
		    "usage: ping6 [-dEefHLmnqv] [-c count] [-h hoplimit] "
		    "[-I sourceaddr]\n\t[-i wait] [-l preload] [-p pattern] "
		    "[-s packetsize] [-V rtable]\n\t[-w maxwait] host\n");
	} else {
		(void)fprintf(stderr,
		    "usage: ping [-DdEefHLnqRv] [-c count] [-I ifaddr]"
		    " [-i wait]\n\t[-l preload] [-p pattern] [-s packetsize]"
#ifndef	SMALL
		    " [-T toskeyword]"
#endif	/* SMALL */
		    "\n\t[-t ttl] [-V rtable] [-w maxwait] host\n");
	}
	exit(1);
}
@


1.217
log
@Only drop to _ping user if invoked as root. If invoked as an
unprivileged user just shed the setuid privs as previously.

sthen@@ pointed out that you cannot kill(2) your own ping.
With this we rely on pledge(2) for unprivileged users.

OK sthen@@, deraadt@@ is happy with the middle ground
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.216 2016/09/28 06:39:12 florian Exp $	*/
d256 1
a256 1
	u_char *datap, *packet, loop = 1;
a354 1
			loop = 0;
d533 2
d618 2
d645 1
a645 1
			err(1, "setsockopt IP6_MULTICAST_LOOP");
d690 2
@


1.216
log
@Always do the setgroups, setresgid and setresuid even if if the
unprivileged user is not present instead of erroring out. This lets
ping and traceroute work in restricted enviornments like the bgplg
chroot.
Problem reported by sthen@@
input & prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.215 2016/09/26 16:42:46 florian Exp $	*/
d279 1
a279 1
	if ((pw = getpwnam(PING_USER)) != NULL) {
@


1.215
log
@Drop privileges to newly added _ping user/group.
It does not buy us much when called as a unpriv user. But if run as
root we can now lose privileges.
OK natano@@, deraadt@@ is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.214 2016/09/20 15:21:34 deraadt Exp $	*/
d262 2
a263 1
	uid_t uid;
d278 11
a288 6
	uid = getuid();
	if ((pw = getpwnam(PING_USER)) == NULL)
		errx(1, "no %s user", PING_USER);
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d318 1
a318 1
			if (uid)
d339 1
a339 1
			if (intval < 1 && uid)
d358 1
a358 1
			if (uid)
@


1.214
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.213 2016/09/19 07:08:30 florian Exp $	*/
d101 1
d162 2
a163 1
#define DUMMY_PORT	10101
d251 1
d278 6
a283 2
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid");
d312 2
a313 2
			if (getuid())
				errx(1, "%s", strerror(EPERM));
d333 2
a334 4
			if (intval < 1 && getuid()) {
				errx(1, "%s: only root may use interval < 1s",
				    strerror(EPERM));
			}
d352 2
a353 2
			if (getuid())
				errx(1, "%s", strerror(EPERM));
@


1.213
log
@Only allow standard dot notation for IPv4 addresses.
We can get rid of inet_aton(3) and use the AF independent getaddrinfo(3).
OK natano@@, krw@@, millert@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.212 2016/09/18 17:27:25 florian Exp $	*/
d443 1
a443 1
		    errx(1, "size of sockaddr mismatch");
d449 1
a449 1
		    errx(1, "size of sockaddr mismatch");
@


1.212
log
@unbreak IPv6 source selection
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.211 2016/09/18 15:14:08 deraadt Exp $	*/
d430 1
a430 6
	if (inet_aton(*argv, &dst4.sin_addr) != 0) {
		hostname = *argv;
		if ((target = strdup(inet_ntoa(dst4.sin_addr))) == NULL)
			err(1, "malloc");
	} else
		target = *argv;
a476 5
		if (inet_aton(source, &from4.sin_addr) != 0) {
			if ((source = strdup(inet_ntoa(from4.sin_addr))) ==
			    NULL)
				err(1, "malloc");
		}
@


1.211
log
@simplify startup, since we know earlier which type of socket we need
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.210 2016/09/18 14:52:14 deraadt Exp $	*/
d491 1
a491 1
		if (res->ai_addrlen != sizeof(from4))
@


1.210
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.209 2016/09/18 13:59:51 florian Exp $	*/
d173 1
a173 1
int maxpayload;
d251 1
a251 1
	int ch, i, optval = 1, packlen, maxsize, error, s4, s6, s;
a252 1
	int v4sock_errno = 0, v6sock_errno = 0;
d263 9
a271 4
	if ((s4 = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
		v4sock_errno = errno;
	if ((s6 = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		v6sock_errno = errno;
a276 18

	if (strcmp("ping6", __progname) == 0) {
		v6flag = 1;
		if (v6sock_errno != 0)
			errc(1, v6sock_errno, "socket");
		s = s6;
		if (s4 >= 0)
			close(s4);
		maxpayload = MAXPAYLOAD6;
	} else {
		v6flag = 0;
		if (v4sock_errno != 0)
			errc(1, v4sock_errno, "socket");
		s = s4;
		if (s6 >= 0)
			close(s6);
		maxpayload = MAXPAYLOAD;
	}
@


1.209
log
@If running in verbose mode and no source address has been specified
with -I find the kernel selected address and print it even for v4
addresses.
OK phessler@@, natano@@, mpi@@, claudio@@, benno@@, sthen@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.208 2016/09/18 13:56:15 florian Exp $	*/
d684 1
a684 1
			smsghdr.msg_controllen =  CMSG_SPACE(sizeof(int));
d1005 1
a1005 1
		itimer.it_value.tv_sec =  2 * tmax / 1000;
d1100 1
a1100 1
	if (i < 0 || i != cc)  {
d1289 1
a1289 1
					     ++i, ++cp) {
d1457 1
a1457 1
	while (nleft > 1)  {
d1732 1
a1732 1
		{ NULL, 		-1 },
d1734 1
a1734 1
	
d1741 1
a1741 1
	
a1745 1

d1752 1
a1752 1
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
d1880 1
a1880 1
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
d1898 1
a1898 1
						&dst->sin6_addr) ||
d1900 3
a1902 3
			     dst->sin6_scope_id &&
			     mtuctl->ip6m_addr.sin6_scope_id !=
			     dst->sin6_scope_id)) {
d1905 4
a1908 3
					       "(ignored)\n",
					   pr_addr((struct sockaddr *)&mtuctl->ip6m_addr,
					   sizeof(mtuctl->ip6m_addr)));
@


1.208
log
@Do not print 'ping6' in reporting output, just 'ping'.
OK tom@@, natano@@, claudio@@, sthen@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.207 2016/09/17 21:30:02 florian Exp $	*/
d768 1
a768 1
	if (v6flag && (options & F_VERBOSE))
@


1.207
log
@backwards if(v6flag); pointed out by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.206 2016/09/17 14:58:42 florian Exp $	*/
d767 1
a767 4
	if (v6flag)
		printf("PING6 %s (", hostname);
	else
		printf("PING %s (", hostname);
d937 1
a937 4
	if (v6flag)
		printf("\n--- %s ping6 statistics ---\n", hostname);
	else
		printf("\n--- %s ping statistics ---\n", hostname);
d1103 1
a1103 6
		if (v6flag)
			printf("ping6: wrote %s %d chars, ret=%d\n", hostname,
			    cc, i);
		else
			printf("ping: wrote %s %d chars, ret=%d\n", hostname,
			    cc, i);
@


1.206
log
@The final merge ping6 into ping.
"why slow down?" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.205 2016/09/17 09:38:26 florian Exp $	*/
d941 2
a943 2
	else
		printf("\n--- %s ping6 statistics ---\n", hostname);
@


1.205
log
@Use ECHOTMLEN define; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.204 2016/09/17 09:37:19 florian Exp $	*/
d126 3
d180 1
d218 1
d228 10
d245 4
d251 3
a253 2
	int ch, i, optval = 1, packlen, maxsize, error, s;
	int df = 0, tos = 0, bufspace = IP_MAXPACKET;
d262 1
d264 4
a267 2
	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
		err(1, "socket");
d274 18
a292 1
	maxpayload = MAXPAYLOAD;
d294 2
a295 1
	while ((ch = getopt(argc, argv,
d327 5
d368 3
d442 1
d452 1
a452 1
	hints.ai_family = AF_INET;
d467 5
d502 1
a502 1
		hints.ai_family = AF_INET;
d510 1
a510 1
		if (IN_MULTICAST(ntohl(dst4.sin_addr.s_addr))) {
d530 18
a547 1
		from4.sin_port = ntohs(DUMMY_PORT);
d549 9
a557 8
		if ((moptions & MULTICAST_NOLOOP) &&
		    setsockopt(dummy, IPPROTO_IP, IP_MULTICAST_LOOP, &loop,
		    sizeof(loop)) < 0)
			err(1, "setsockopt IP_MULTICAST_LOOP");
		if ((moptions & MULTICAST_TTL) &&
		    setsockopt(dummy, IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
		    sizeof(ttl)) < 0)
			err(1, "setsockopt IP_MULTICAST_TTL");
d585 9
a593 1
	packlen = datalen + MAXIPLEN + MAXICMPLEN;
d629 77
a705 6
	if (options & F_TTL) {
		if (IN_MULTICAST(ntohl(dst4.sin_addr.s_addr)))
			moptions |= MULTICAST_TTL;
		else
			options |= F_HDRINCL;
	}
d707 22
a728 21
	if (options & F_RROUTE && options & F_HDRINCL)
		errx(1, "-R option and -D or -T, or -t to unicast destinations"
		    " are incompatible");

	if (options & F_HDRINCL) {
		struct ip *ip = (struct ip *)outpackhdr;

		setsockopt(s, IPPROTO_IP, IP_HDRINCL, &optval, sizeof(optval));
		ip->ip_v = IPVERSION;
		ip->ip_hl = sizeof(struct ip) >> 2;
		ip->ip_tos = tos;
		ip->ip_id = 0;
		ip->ip_off = htons(df ? IP_DF : 0);
		ip->ip_ttl = ttl;
		ip->ip_p = IPPROTO_ICMP;
		if (source)
			ip->ip_src = from4.sin_addr;
		else
			ip->ip_src.s_addr = INADDR_ANY;
		ip->ip_dst = dst4.sin_addr;
	}
d730 14
a743 12
	/* record route option */
	if (options & F_RROUTE) {
		if (IN_MULTICAST(ntohl(dst4.sin_addr.s_addr)))
			errx(1, "record route not valid to multicast destinations");
		memset(rspace, 0, sizeof(rspace));
		rspace[IPOPT_OPTVAL] = IPOPT_RR;
		rspace[IPOPT_OLEN] = sizeof(rspace)-1;
		rspace[IPOPT_OFFSET] = IPOPT_MINOFF;
		if (setsockopt(s, IPPROTO_IP, IP_OPTIONS, rspace,
		    sizeof(rspace)) < 0) {
			perror("ping: record route");
			exit(1);
d745 9
a755 9
	if ((moptions & MULTICAST_NOLOOP) &&
	    setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &loop,
	    sizeof(loop)) < 0)
		err(1, "setsockopt IP_MULTICAST_LOOP");
	if ((moptions & MULTICAST_TTL) &&
	    setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
	    sizeof(ttl)) < 0)
		err(1, "setsockopt IP_MULTICAST_TTL");

d767 5
a771 2
	printf("PING %s (", hostname);
	if (0 && (options & F_VERBOSE))
d807 2
a808 1
		struct sockaddr_in	peer;
d844 7
a850 2
		m.msg_name = &peer;
		m.msg_namelen = sizeof(peer);
d866 15
d940 4
a943 1
	printf("\n--- %s ping statistics ---\n", hostname);
d1036 2
a1037 1
	struct icmp *icp;
d1046 16
a1061 7
	icp = (struct icmp *)outpack;
	icp->icmp_type = ICMP_ECHO;
	icp->icmp_code = 0;
	icp->icmp_cksum = 0;
	icp->icmp_seq = seq;
	icp->icmp_id = ident;			/* ID */

d1088 12
a1099 10
	/* compute ICMP checksum here */
	icp->icmp_cksum = in_cksum((u_short *)icp, cc);

	if (options & F_HDRINCL) {
		struct ip *ip = (struct ip *)outpackhdr;

		smsgiov.iov_base = (caddr_t)outpackhdr;
		cc += sizeof(struct ip);
		ip->ip_len = htons(cc);
		ip->ip_sum = in_cksum((u_short *)outpackhdr, cc);
d1109 6
a1114 1
		printf("ping: wrote %s %d chars, ret=%d\n", hostname, cc, i);
d1132 3
a1134 2
	struct ip *ip;
	struct icmp *icp;
d1141 1
a1141 1
	int hlen;
d1149 53
a1201 9
	if (!mhdr || !mhdr->msg_name ||
	    mhdr->msg_namelen != sizeof(struct sockaddr_in) ||
	    ((struct sockaddr *)mhdr->msg_name)->sa_family != AF_INET) {
		if (options & F_VERBOSE)
			warnx("invalid peername");
		return;
	}
	from = (struct sockaddr *)mhdr->msg_name;
	fromlen = mhdr->msg_namelen;
d1203 10
a1212 8
	/* Check the IP header */
	ip = (struct ip *)buf;
	hlen = ip->ip_hl << 2;
	if (cc < hlen + ICMP_MINLEN) {
		if (options & F_VERBOSE)
			warnx("packet too short (%d bytes) from %s", cc,
			    pr_addr(from, fromlen));
		return;
d1215 1
a1215 7
	/* Now the ICMP part */
	cc -= hlen;
	icp = (struct icmp *)(buf + hlen);
	if (icp->icmp_type == ICMP_ECHOREPLY) {
		if (icp->icmp_id != ident)
			return;			/* 'Twas not our ECHO */
		seq = icp->icmp_seq;
a1221 1
			pkttime = (char *)icp->icmp_data;
d1271 4
a1274 1
			(void)printf(" ttl=%d", ip->ip_ttl);
d1282 4
a1285 1
			cp = (u_char *)&icp->icmp_data[ECHOTMLEN];
d1294 5
a1298 1
					cp = (u_char *)&icp->icmp_data[0];
d1314 4
a1317 1
		pr_icmph(icp);
d1321 1
a1321 1
	if (hlen > sizeof(struct ip))
d1326 2
d1757 413
d2173 9
a2181 3
	(void)fprintf(stderr,
	    "usage: ping [-DdEefHLnqRv] [-c count] [-I ifaddr] [-i wait]\n"
	    "\t[-l preload] [-p pattern] [-s packetsize]"
d2183 1
a2183 1
	    " [-T toskeyword]"
d2185 2
a2186 1
	    "\n\t[-t ttl] [-V rtable] [-w maxwait] host\n");
@


1.204
log
@iov_base is already set in this case; reduce diff to ping6(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.203 2016/09/17 09:36:42 florian Exp $	*/
d1040 1
a1040 1
			cp = (u_char *)&icp->icmp_data[sizeof(struct payload)];
@


1.203
log
@MAXPAYLOAD is different between ping and ping6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.202 2016/09/17 09:35:27 florian Exp $	*/
d906 1
a906 2
	} else
		smsgiov.iov_base = (caddr_t)outpack;
@


1.202
log
@Just use AF_INET like everywhere else.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.201 2016/09/17 09:34:57 florian Exp $	*/
d170 1
d252 1
d336 1
a336 1
			datalen = strtonum(optarg, 0, MAXPAYLOAD, &errstr);
d746 1
a746 1
		    kk <= MAXPAYLOAD - (ECHOLEN + ECHOTMLEN + ii);
@


1.201
log
@malloc sets errno; use err not errx
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.200 2016/09/17 09:34:03 florian Exp $	*/
d400 1
a400 1
	hints.ai_family = PF_INET;
@


1.200
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.199 2016/09/17 09:33:32 florian Exp $	*/
d426 1
a426 1
			errx(1, "malloc");
@


1.199
log
@Make getting source address more AF independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.198 2016/09/17 09:32:54 florian Exp $	*/
d482 1
a482 1
		err(1, "setsockopt IP_MULTICAST_TTL");
@


1.198
log
@If -I was not given hoist getting source address up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.197 2016/09/17 09:31:04 florian Exp $	*/
d467 1
a467 1
		socklen_t len = sizeof(from4);
d469 1
a469 1
		if ((dummy = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
d472 1
a472 2
		from4.sin_family = AF_INET;
		from4.sin_addr = dst4.sin_addr;
d489 1
a489 1
		if (connect(dummy, (struct sockaddr *)&from4, len) < 0)
d492 1
a492 1
		if (getsockname(dummy, (struct sockaddr *)&from4, &len) < 0)
@


1.197
log
@Make source address selection more AF independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.196 2016/09/17 09:30:26 florian Exp $	*/
d461 36
a598 38

	if (!source && options & F_VERBOSE) {
		/*
		 * get the source address. XXX since we revoked the root
		 * privilege, we cannot use a raw socket for this.
		 */
		int dummy;
		socklen_t len = sizeof(from4);

		if ((dummy = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
			err(1, "UDP socket");

		from4.sin_family = AF_INET;
		from4.sin_addr = dst4.sin_addr;
		from4.sin_port = ntohs(DUMMY_PORT);

		if ((moptions & MULTICAST_NOLOOP) &&
		    setsockopt(dummy, IPPROTO_IP, IP_MULTICAST_LOOP, &loop,
		    sizeof(loop)) < 0)
			err(1, "setsockopt IP_MULTICAST_LOOP");
		if ((moptions & MULTICAST_TTL) &&
		    setsockopt(dummy, IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
		    sizeof(ttl)) < 0)
		err(1, "setsockopt IP_MULTICAST_TTL");

		if (rtableid > 0 &&
		    setsockopt(dummy, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) < 0)
			err(1, "setsockopt(SO_RTABLE)");

		if (connect(dummy, (struct sockaddr *)&from4, len) < 0)
			err(1, "UDP connect");

		if (getsockname(dummy, (struct sockaddr *)&from4, &len) < 0)
			err(1, "getsockname");

		close(dummy);
	}
@


1.196
log
@Introduce AF independent from.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.195 2016/09/17 09:30:00 florian Exp $	*/
d395 1
a395 1
			errx(1, "malloc");
d439 4
a442 12
		memset(&from4, 0, sizeof(from4));
		from4.sin_family = AF_INET;
		if (inet_aton(source, &from4.sin_addr) == 0) {
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = AF_INET;
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			if ((error = getaddrinfo(source, NULL, &hints, &res)))
				errx(1, "%s: %s", source, gai_strerror(error));
			if (res->ai_addrlen != sizeof(from4))
				errx(1, "size of sockaddr mismatch");
			memcpy(&from4, res->ai_addr, res->ai_addrlen);
			freeaddrinfo(res);
d444 8
d458 1
a458 2
			if (bind(s, (struct sockaddr *)&from4, sizeof(from4))
			    < 0)
@


1.195
log
@Use AF independent dst where possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.194 2016/09/17 09:29:27 florian Exp $	*/
d227 1
a227 1
	struct sockaddr *dst;
d412 1
d616 1
a616 2
		printf("%s --> ", pr_addr((struct sockaddr *)&from4,
		    sizeof(from4)));
@


1.194
log
@Blindly s/dst/dst4/ or s/dst/dst6/, AF independent dst will be
introduced next.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.193 2016/09/17 09:26:49 florian Exp $	*/
d227 1
d411 1
d419 1
a419 1
	memcpy(&dst4, res->ai_addr, res->ai_addrlen);
d617 1
a617 2
	printf("%s): %d data bytes\n", pr_addr((struct sockaddr *)&dst4,
	    sizeof(dst4)), datalen);
d619 2
a620 2
	smsghdr.msg_name = &dst4;
	smsghdr.msg_namelen = sizeof(dst4);
@


1.193
log
@We will need the variable name "from" soon, so free it up by renaming
to peer. While here move declaration down to where it's needed. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.192 2016/09/17 09:26:07 florian Exp $	*/
d227 1
a227 1
	struct sockaddr_in from4, dst;
d389 1
a389 1
	memset(&dst, 0, sizeof(dst));
d391 1
a391 1
	if (inet_aton(*argv, &dst.sin_addr) != 0) {
d393 1
a393 1
		if ((target = strdup(inet_ntoa(dst.sin_addr))) == NULL)
d408 1
a408 1
		if (res->ai_addrlen != sizeof(dst))
d417 1
a417 1
	memcpy(&dst, res->ai_addr, res->ai_addrlen);
d450 1
a450 1
		if (IN_MULTICAST(ntohl(dst.sin_addr.s_addr))) {
d510 1
a510 1
		if (IN_MULTICAST(ntohl(dst.sin_addr.s_addr)))
d535 1
a535 1
		ip->ip_dst = dst.sin_addr;
d540 1
a540 1
		if (IN_MULTICAST(ntohl(dst.sin_addr.s_addr)))
d574 1
a574 1
		from4.sin_addr = dst.sin_addr;
d615 2
a616 2
	printf("%s): %d data bytes\n", pr_addr((struct sockaddr *)&dst,
	    sizeof(dst)), datalen);
d618 2
a619 2
	smsghdr.msg_name = &dst;
	smsghdr.msg_namelen = sizeof(dst);
@


1.192
log
@Reduce diff in pinger().
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.191 2016/09/17 09:22:31 florian Exp $	*/
d227 1
a227 1
	struct sockaddr_in  from, from4, dst;
d643 1
a643 1
		struct msghdr	m;
d647 6
a652 5
		}		cmsgbuf;
		struct iovec	iov[1];
		struct pollfd	pfd;
		ssize_t		cc;
		int		timeout;
d686 2
a687 2
		m.msg_name = &from;
		m.msg_namelen = sizeof(from);
@


1.191
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.190 2016/09/17 09:21:59 florian Exp $	*/
d894 1
a894 1
	cc = datalen + ECHOLEN;			/* skips ICMP portion */
@


1.190
log
@Move more AF independent initialization around to reduce diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.189 2016/09/17 09:21:16 florian Exp $	*/
d506 2
a507 3
		warnx("Could only allocate a receive buffer of %d bytes (default %d)",
		    bufspace, IP_MAXPACKET);

@


1.189
log
@Normalize receive packet allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.188 2016/09/17 09:19:44 florian Exp $	*/
d483 27
a561 26

	/*
	 * When trying to send large packets, you must increase the
	 * size of both the send and receive buffers...
	 */
	maxsizelen = sizeof maxsize;
	if (getsockopt(s, SOL_SOCKET, SO_SNDBUF, &maxsize, &maxsizelen) < 0)
		err(1, "getsockopt");
	if (maxsize < packlen &&
	    setsockopt(s, SOL_SOCKET, SO_SNDBUF, &packlen, sizeof(maxsize)) < 0)
		err(1, "setsockopt");

	/*
	 * When pinging the broadcast address, you can get a lot of answers.
	 * Doing something so evil is useful if you are trying to stress the
	 * ethernet, or just want to fill the arp cache to get some stuff for
	 * /etc/ethers.
	 */
	while (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
	    (void*)&bufspace, sizeof(bufspace)) < 0) {
		if ((bufspace -= 1024) <= 0)
			err(1, "Cannot set the receive buffer size");
	}
	if (bufspace < IP_MAXPACKET)
		warnx("Could only allocate a receive buffer of %d bytes (default %d)",
		    bufspace, IP_MAXPACKET);
@


1.188
log
@Use ECHOTMLEN define.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.187 2016/09/17 09:17:55 florian Exp $	*/
d474 1
a474 1
	if (!(packet = malloc((size_t)packlen)))
d476 1
@


1.187
log
@ping(8): The IPv6 header has a payload length field while IPv4 has a
length field for the whole packet. Make some room for IPv6 payload.
ping6(8): Sync to ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.186 2016/09/17 09:16:32 florian Exp $	*/
d477 1
a477 1
		for (i = sizeof(struct payload); i < datalen; ++i)
@


1.186
log
@Bring over includes, we will need them in a merge anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.185 2016/09/17 09:14:30 florian Exp $	*/
d170 1
a170 1
u_char outpackhdr[IP_MAXPACKET]; /* Max packet size = 65535 */
@


1.185
log
@If no source address is specified and we are running in verbose mode
try to find it with getsockname(2) like ping6(8). Disable printing
for now though because scripts might depend on ping(8)'s output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.184 2016/09/13 07:17:40 florian Exp $	*/
d89 3
@


1.184
log
@Rearange option handling to reduce diff between ping(8) and ping6(8).
While here be explicit that timing and timinginfo are initialized to
0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.183 2016/09/13 07:16:49 florian Exp $	*/
d155 2
d558 38
d607 6
a612 2
	printf("PING %s (%s): %d data bytes\n", hostname,
	    pr_addr((struct sockaddr *)&dst, sizeof(dst)), datalen);
@


1.183
log
@Make the raw socket non-global and pass it to retransmit()/pinger().
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.182 2016/09/13 07:15:03 florian Exp $	*/
d181 2
a182 2
int timing;			/* flag to do timing */
int timinginfo;
d460 1
a460 1
	if (options & F_FLOOD && options & F_INTERVAL)
@


1.182
log
@No need to have the destination global.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.181 2016/09/13 07:14:24 florian Exp $	*/
a164 1
int s;				/* socket file descriptor */
d202 2
a203 2
void			 retransmit(void);
int			 pinger(void);
d225 1
a225 1
	int ch, i, optval = 1, packlen, maxsize, error;
d577 1
a577 1
		pinger();
d588 1
a588 1
			retransmit();
d609 1
a609 1
			retransmit();
d626 1
a626 1
			(void)pinger();
d762 1
a762 1
retransmit(void)
d772 1
a772 1
	if (pinger() == 0)
d804 1
a804 1
pinger(void)
@


1.181
log
@No need to have this global.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.180 2016/09/13 07:11:56 florian Exp $	*/
a163 1
struct sockaddr_in dst;	/* who to ping */
d223 1
a223 1
	struct sockaddr_in  from, from4;
@


1.180
log
@timinginfo is a global flag that we got at least one packet back with
timing information for the summary line. Here we need to know if the
current echo reply was long enough to carry timing information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.179 2016/09/12 15:47:57 florian Exp $	*/
a189 1
int bufspace = IP_MAXPACKET;
d228 1
a228 1
	int df = 0, tos = 0;
@


1.179
log
@Bring over KAME copyright, there is now code from ping in ping6. While
here nuke NetBSD, KAME and BSDI ids. With this the beginning of
ping.c and ping6.c are in sync.
prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.178 2016/09/12 06:02:43 florian Exp $	*/
d989 1
a989 1
			if (timinginfo)
@


1.178
log
@No need for have this unsigned, reduces diff to ping6(8).
@
text
@d1 30
a30 2
/*	$OpenBSD: ping.c,v 1.177 2016/09/12 06:01:58 florian Exp $	*/
/*	$NetBSD: ping.c,v 1.20 1995/08/11 22:37:58 cgd Exp $	*/
a64 2
 *			P I N G . C
 *
@


1.177
log
@Use ECHOLEN/ECHOTMLEN defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.176 2016/09/11 19:59:25 florian Exp $	*/
d139 1
a139 1
unsigned int datalen = DEFDATALEN;
@


1.176
log
@bring over LEN defines from ping6(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.175 2016/09/11 19:44:43 florian Exp $	*/
d222 1
a222 1
	datap = &outpack[8 + sizeof(struct payload)];
d675 1
a675 1
		    kk <= MAXPAYLOAD - (8 + sizeof(struct payload) + ii);
d820 1
a820 1
		memcpy(&outpack[8], &payload, sizeof(payload));
d823 1
a823 1
	cc = datalen + 8;			/* skips ICMP portion */
d907 1
a907 1
		if (cc >= 8 + sizeof(struct payload)) {
d968 1
a968 1
			if (cc - 8 < datalen)
d971 2
a972 2
			dp = &outpack[8 + sizeof(struct payload)];
			for (i = 8 + sizeof(struct payload);
d978 1
a978 1
					    i - 8, *dp, *cp);
d980 1
a980 1
					for (i = 8; i < cc && i < datalen;
@


1.175
log
@The canonical way to find out if we can have timing stats is timinginfo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.174 2016/09/11 18:28:31 florian Exp $	*/
d91 3
a93 1
#define	DEFDATALEN	(64 - 8)		/* default data length */
d96 1
a96 1
#define	MAXPAYLOAD	(IP_MAXPACKET - MAXIPLEN - 8) /* max ICMP payload size */
@


1.174
log
@Normalize variable declarations in pr_pack. While here introduce seq
variable in ping and normalize it's usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.173 2016/09/11 18:27:44 florian Exp $	*/
d961 1
a961 1
			if (cc >= 8 + sizeof(struct payload))
@


1.173
log
@use fputc to put in sync with ping6
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.172 2016/09/11 18:24:44 florian Exp $	*/
d861 4
d867 4
a870 2
	struct icmp *icp;
	u_int i;
d872 1
a872 6
	struct ip *ip;
	struct timespec ts, tp;
	char *pkttime;
	double triptime = 0;
	int hlen, dupflag;
	struct payload payload;
d903 1
d907 1
a907 1
			struct tv64 *tv64 = &payload.tv64;
d912 1
d917 1
a917 2
			SipHash24_Update(&ctx, &icp->icmp_seq,
			    sizeof(icp->icmp_seq));
d943 1
a943 1
		if (TST(ntohs(icp->icmp_seq) % mx_dup_ck)) {
d948 1
a948 1
			SET(ntohs(icp->icmp_seq) % mx_dup_ck);
d959 1
a959 2
			    pr_addr(from, fromlen),
			    ntohs(icp->icmp_seq));
@


1.172
log
@Introduce pr_ipopt() to remove IPv4 specifics from pr_pack(); small
step to make this AF independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.171 2016/09/11 18:21:09 florian Exp $	*/
d1003 1
a1003 1
			write(STDERR_FILENO, "\a", 1);
@


1.171
log
@Hoist pr_addr() up, it's AF independent; no obj change.

Diff between ping and ping6 is easier to read if all identical
or as close as possible to being identical functions are in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.170 2016/09/11 18:19:32 florian Exp $	*/
d183 1
a860 1
	struct sockaddr_in s_in;
d864 1
a864 2
	in_addr_t l;
	u_int i, j;
a865 2
	static int old_rrlen;
	static char old_rr[MAX_IPOPTLEN];
a872 3
	s_in.sin_len = sizeof(s_in);
	s_in.sin_family = AF_INET;

d996 21
d1019 4
a1022 1
	for (; hlen > (int)sizeof(struct ip); --hlen, ++cp)
a1120 5
	if (!(options & F_FLOOD)) {
		(void)putchar('\n');
		(void)fflush(stdout);
		if (options & F_AUD_RECV)
			write(STDERR_FILENO, "\a", 1);
@


1.170
log
@Hoist summary() up, it's AF independent; no obj change.

Diff between ping and ping6 is easier to read if all identical
or as close as possible to being identical functions are in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.169 2016/09/11 18:18:25 florian Exp $	*/
d713 19
a1342 19
}

/*
 * pr_addr --
 *	Return address in numeric form or a host name
 */
const char *
pr_addr(struct sockaddr *addr, socklen_t addrlen)
{
	static char buf[NI_MAXHOST];
	int flag = 0;

	if ((options & F_HOSTNAME) == 0)
		flag |= NI_NUMERICHOST;

	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)
		return (buf);
	else
		return "?";
@


1.169
log
@Hoist fill() up, it's AF independent; no obj change.

Diff between ping and ping6 is easier to read if all identical
or as close as possible to being identical functions are in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.168 2016/09/11 18:04:07 florian Exp $	*/
d684 28
a1124 28
}

void
summary(void)
{
	printf("\n--- %s ping statistics ---\n", hostname);
	printf("%lld packets transmitted, ", ntransmitted);
	printf("%lld packets received, ", nreceived);

	if (nrepeats)
		printf("%lld duplicates, ", nrepeats);
	if (ntransmitted) {
		if (nreceived > ntransmitted)
			printf("-- somebody's duplicating packets!");
		else
			printf("%.1f%% packet loss",
			    ((((double)ntransmitted - nreceived) * 100) /
			    ntransmitted));
	}
	printf("\n");
	if (timinginfo) {
		/* Only display average to microseconds */
		double num = nreceived + nrepeats;
		double avg = tsum / num;
		double dev = sqrt(fmax(0, tsumsq / num - avg * avg));
		printf("round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
		    tmin, avg, tmax, dev);
	}
@


1.168
log
@Pass from around as struct sockaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.167 2016/09/11 18:03:12 florian Exp $	*/
d654 30
a1364 30
}

void
fill(char *bp, char *patp)
{
	int ii, jj, kk;
	int pat[16];
	char *cp;

	for (cp = patp; *cp; cp++)
		if (!isxdigit((unsigned char)*cp))
			errx(1, "patterns must be specified as hex digits");
	ii = sscanf(patp,
	    "%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x",
	    &pat[0], &pat[1], &pat[2], &pat[3], &pat[4], &pat[5], &pat[6],
	    &pat[7], &pat[8], &pat[9], &pat[10], &pat[11], &pat[12],
	    &pat[13], &pat[14], &pat[15]);

	if (ii > 0)
		for (kk = 0;
		    kk <= MAXPAYLOAD - (8 + sizeof(struct payload) + ii);
		    kk += ii)
			for (jj = 0; jj < ii; ++jj)
				bp[jj + kk] = pat[jj];
	if (!(options & F_QUIET)) {
		(void)printf("PATTERN: 0x");
		for (jj = 0; jj < ii; ++jj)
			(void)printf("%02x", bp[jj] & 0xFF);
		(void)printf("\n");
	}
@


1.167
log
@Get rid of check_icmph(), it's just a convoluted way of saying: Is
this an ICMP echo reply. But we want to print things if it's not an
echo reply!
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.166 2016/09/11 18:01:24 florian Exp $	*/
d783 2
a784 1
	struct sockaddr_in *from, s_in;
d812 1
a812 1
	from = (struct sockaddr_in *)mhdr->msg_name;
d821 1
a821 1
			    pr_addr((struct sockaddr*)from, fromlen));
d886 1
a886 1
			    pr_addr((struct sockaddr*)from, fromlen),
d920 1
a920 2
		(void)printf("%d bytes from %s: ", cc,
		    pr_addr((struct sockaddr*)from, fromlen));
@


1.166
log
@Move smsghdr initialization into main, another step towards AF
independent pinger().
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.165 2016/09/11 17:58:21 florian Exp $	*/
a183 1
int			 check_icmph(struct ip *);
d791 1
a791 1
	struct ip *ip, *ip2;
d795 1
a795 1
	int hlen, hlen2, dupflag;
a918 4
		ip2 = (struct ip *)(buf + hlen + sizeof (struct icmp));
		hlen2 = ip2->ip_hl << 2;
		if (cc >= hlen2 + 8 && check_icmph(ip2) != 1)
			return;
a1364 31
}

/*
 * when we get types of ICMP message with parts of the orig. datagram
 * we want to try to assure ourselves that it is from this instance
 * of ping, and not say, a refused finger connection or something
 */
int
check_icmph(struct ip *iph)
{
	struct icmp *icmph;

	/* only allow IP version 4 */
	if (iph->ip_v != 4)
		return 0;

	/* Only allow ICMP */
	if (iph->ip_p != IPPROTO_ICMP)
		return 0;

	icmph = (struct icmp *) (iph + (4 * iph->ip_hl));

	/* make sure it is in response to an ECHO request */
	if (icmph->icmp_type != 8)
		return 0;

	/* ok, make sure it has the right id on it */
	if (icmph->icmp_hun.ih_idseq.icd_id != ident)
		return 0;

	return 1;
@


1.165
log
@Switch to sendmsg like ping6(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.164 2016/09/11 17:55:05 florian Exp $	*/
d545 6
a706 1
	u_char *packet = outpack;
d752 1
a752 1
		packet = (u_char *)ip;
d756 2
a757 2
	}

a758 3
	smsghdr.msg_name = &dst;
	smsghdr.msg_namelen = sizeof(dst);
	smsgiov.iov_base = (caddr_t)packet;
a759 2
	smsghdr.msg_iov = &smsgiov;
	smsghdr.msg_iovlen = 1;
@


1.164
log
@pinger() is no longer called in a sighandler since some time, just
printf(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.163 2016/09/11 17:50:56 florian Exp $	*/
d167 3
d753 9
a761 2
	i = sendto(s, packet, cc, 0, (struct sockaddr *)&dst,
	    sizeof(dst));
d765 1
a765 1
			warn("sendto");
@


1.163
log
@Remove destination IP from mac, it's not helping anything.
Next step in making these functions AF independent. Note that before
rev 1.147 of ping6(8) it did not put the destination IP into the mac,
only ping(8) did.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.162 2016/09/11 11:19:27 florian Exp $	*/
d755 2
a756 3
			perror("ping: sendto");
		dprintf(STDOUT_FILENO, "ping: wrote %s %d chars, ret=%d\n",
		    hostname, cc, i);
@


1.162
log
@normalize seq handling in pinger; little step to make this AF
independent
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.161 2016/09/11 11:18:11 florian Exp $	*/
a730 2
		SipHash24_Update(&ctx, &dst.sin_addr,
		    sizeof(dst.sin_addr));
a835 2
			SipHash24_Update(&ctx, &dst.sin_addr,
			    sizeof(dst.sin_addr));
@


1.161
log
@Correctly initialize source address for multicast pings. This got
broken 9 months ago in 1.136, sorry about that!
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.160 2016/09/10 07:47:00 florian Exp $	*/
d697 1
d703 2
d709 1
a709 1
	icp->icmp_seq = htons(ntransmitted);
d712 1
a712 1
	CLR(ntohs(icp->icmp_seq) % mx_dup_ck);
d730 1
a730 1
		SipHash24_Update(&ctx, &icp->icmp_seq, sizeof(icp->icmp_seq));
a763 1
	ntransmitted++;
@


1.160
log
@The getopt while loop is very long, put the body in {}.
Removes a "Huh, that's weird" diff to ping6. No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.159 2016/09/10 07:46:20 florian Exp $	*/
a125 1
#define	MULTICAST_IF		0x004
d403 19
a421 18
		if (IN_MULTICAST(ntohl(dst.sin_addr.s_addr)))
			moptions |= MULTICAST_IF;
		else {
			memset(&from4, 0, sizeof(from4));
			from4.sin_family = AF_INET;
			if (inet_aton(source, &from4.sin_addr) == 0) {
				memset(&hints, 0, sizeof(hints));
				hints.ai_family = AF_INET;
				hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
				if ((error = getaddrinfo(source, NULL, &hints,
				    &res)))
					errx(1, "%s: %s", source,
					    gai_strerror(error));
				if (res->ai_addrlen != sizeof(from4))
					errx(1, "size of sockaddr mismatch");
				memcpy(&from4, res->ai_addr, res->ai_addrlen);
				freeaddrinfo(res);
			}
a500 4
	if ((moptions & MULTICAST_IF) &&
	    setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &from4.sin_addr,
	    sizeof(from4.sin_addr)) < 0)
		err(1, "setsockopt IP_MULTICAST_IF");
@


1.159
log
@reorder main variables, no object change, reduces diff to ping6
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.158 2016/09/10 07:42:20 florian Exp $	*/
d220 1
a220 1
	    "DEI:LRS:c:defHi:l:np:qs:T:t:V:vw:")) != -1)
d349 2
@


1.158
log
@reorder main variables, reduces diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.157 2016/09/10 07:40:58 florian Exp $	*/
d200 2
a201 1
	u_char *datap, *packet, ttl = MAXTTL, loop = 1;
@


1.157
log
@reorder main variables; no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.156 2016/09/10 07:39:49 florian Exp $	*/
d198 2
a199 2
	int ch, i, optval = 1, packlen, maxsize, df = 0, tos = 0;
	int error;
@


1.156
log
@packet is actually u_char, pass it around as one
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.155 2016/09/10 07:31:43 florian Exp $	*/
d196 1
a202 1
	socklen_t maxsizelen;
@


1.155
log
@reorder function declaration to reduce diff between ping and ping6; no
object change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.154 2016/09/08 13:59:33 florian Exp $	*/
d178 1
a178 1
void			 pr_pack(char *, int, struct msghdr *);
d774 1
a774 1
pr_pack(char *buf, int cc, struct msghdr *mhdr)
d924 1
a924 1
	cp = (u_char *)buf + sizeof(struct ip);
d974 1
a974 1
			    cp == (u_char *)buf + sizeof(struct ip) + 2 &&
@


1.154
log
@normalize option defines; reduces diff between ping(8) and ping6(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.153 2016/09/08 13:58:15 florian Exp $	*/
d172 14
a185 12
void fill(char *, char *);
void summary(void);
int in_cksum(u_short *, int);
void onsignal(int);
void retransmit(void);
int pinger(void);
const char *pr_addr(struct sockaddr *, socklen_t);
int check_icmph(struct ip *);
void pr_icmph(struct icmp *);
void pr_pack(char *, int, struct msghdr *);
void pr_retip(struct ip *);
void pr_iph(struct ip *);
d187 1
a187 1
int map_tos(char *, int *);
a188 1
__dead void usage(void);
@


1.153
log
@We need this for struct iovec; reduces diff to ping6(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.152 2016/09/07 17:56:00 florian Exp $	*/
d118 1
@


1.152
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.151 2016/09/07 17:55:14 florian Exp $	*/
d57 1
@


1.151
log
@normalize code to send preload packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.150 2016/09/07 17:53:53 florian Exp $	*/
a626 1

@


1.150
log
@move header printing down; reduces diff to ping6
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.149 2016/09/07 17:52:56 florian Exp $	*/
d540 1
a540 1
	while (preload--)		/* fire off them quickies */
@


1.149
log
@move arc4random down; reduces diff to ping6
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.148 2016/09/04 09:36:37 florian Exp $	*/
a525 3
	(void)printf("PING %s (%s): %d data bytes\n", hostname,
	    pr_addr((struct sockaddr *)&dst, sizeof(dst)), datalen);

d536 3
@


1.148
log
@Switch ping to getaddrinfo while retaining inet_aton functionality as
has been done in the traceroute merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.147 2016/09/03 21:50:52 florian Exp $	*/
a425 3
	arc4random_buf(&tv64_offset, sizeof(tv64_offset));
	arc4random_buf(&mac_key, sizeof(mac_key));

d536 3
@


1.147
log
@How can this not be AF_INET?!
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.146 2016/09/03 21:49:55 florian Exp $	*/
a189 1
	struct hostent *hp;
d197 1
a197 1
	char *e, *target, hnamebuf[HOST_NAME_MAX+1], *source = NULL;
d351 29
a379 1
	target = *argv;
d381 13
a393 13
	memset(&dst, 0, sizeof(dst));
	dst.sin_len = sizeof(struct sockaddr_in);
	dst.sin_family = AF_INET;
	if (inet_aton(target, &dst.sin_addr) != 0)
		hostname = target;
	else {
		hp = gethostbyname(target);
		if (!hp)
			errx(1, "unknown host: %s", target);
		dst.sin_family = hp->h_addrtype;
		memcpy(&dst.sin_addr, hp->h_addr, (size_t)hp->h_length);
		(void)strlcpy(hnamebuf, hp->h_name, sizeof(hnamebuf));
		hostname = hnamebuf;
d395 1
@


1.146
log
@s/to/dst/
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.145 2016/09/03 21:48:51 florian Exp $	*/
d501 2
a502 6
	if (dst.sin_family == AF_INET)
		(void)printf("PING %s (%s): %d data bytes\n", hostname,
		    pr_addr((struct sockaddr *)&dst, sizeof(dst)),
		    datalen);
	else
		(void)printf("PING %s: %d data bytes\n", hostname, datalen);
@


1.145
log
@s/whereto/dst/
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.144 2016/09/02 21:46:18 florian Exp $	*/
a193 1
	struct sockaddr_in *to;
d355 3
a357 4
	to = &dst;
	to->sin_len = sizeof(struct sockaddr_in);
	to->sin_family = AF_INET;
	if (inet_aton(target, &to->sin_addr) != 0)
d363 2
a364 2
		to->sin_family = hp->h_addrtype;
		memcpy(&to->sin_addr, hp->h_addr, (size_t)hp->h_length);
d370 1
a370 1
		if (IN_MULTICAST(ntohl(to->sin_addr.s_addr)))
d419 1
a419 1
		if (IN_MULTICAST(ntohl(to->sin_addr.s_addr)))
d444 1
a444 1
		ip->ip_dst = to->sin_addr;
d449 1
a449 1
		if (IN_MULTICAST(ntohl(to->sin_addr.s_addr)))
d501 1
a501 1
	if (to->sin_family == AF_INET)
d503 1
a503 1
		    pr_addr((struct sockaddr *)to, sizeof(*to)),
@


1.144
log
@In preparation for merging of ping(8) and ping6(8) the -n flag needs to
become the default. That means no DNS reverse look ups per default.
In practice this doesn't change anything since ping(8) only did
reverse DNS look ups per for weird corner cases:
1) Something that's not an echo reply and -v was specified
2) LSRR or RR IP options

With this pr_addr() can become the default address printing mechanism
and can be made AF independent. With that we get ping(8)'s -H option
for free.

OK sthen@@, benno@@
OK deraadt@@ for the -H a long time ago when this were two diffs.
man page tweak jmc@@ a long time ago
deraadt@@ softened up and has no objections to -n per default
beck@@ is in favor of no look ups per default.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.143 2016/09/02 14:15:58 florian Exp $	*/
d135 1
a135 1
struct sockaddr_in whereto;	/* who to ping */
d355 2
a356 2
	memset(&whereto, 0, sizeof(whereto));
	to = &whereto;
d705 2
a706 2
		SipHash24_Update(&ctx, &whereto.sin_addr,
		    sizeof(whereto.sin_addr));
d726 2
a727 2
	i = sendto(s, packet, cc, 0, (struct sockaddr *)&whereto,
	    sizeof(whereto));
d813 2
a814 2
			SipHash24_Update(&ctx, &whereto.sin_addr,
			    sizeof(whereto.sin_addr));
@


1.143
log
@timinginfo is a flag to track if the received icmp packet is big
enough to carry timing information.
Do not treat it as a counter as it could overflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.142 2016/08/30 14:28:31 deraadt Exp $	*/
d107 1
a107 1
#define	F_NUMERIC	0x0004
d176 1
a176 1
char *pr_addr(in_addr_t);
d218 1
a218 1
	    "DEI:LRS:c:defi:l:np:qs:T:t:V:vw:")) != -1)
d246 3
d286 1
a286 1
			options |= F_NUMERIC;
d505 1
a505 1
		    inet_ntoa(*(struct in_addr *)&to->sin_addr.s_addr),
d510 2
a511 2
	if (options & F_NUMERIC) {
		if (pledge("stdio inet", NULL) == -1)
d514 1
a514 1
		if (pledge("stdio inet dns", NULL) == -1)
d752 1
a752 1
	struct sockaddr_in *from;
d767 3
d789 1
a789 1
			    inet_ntoa(*(struct in_addr *)&from->sin_addr.s_addr));
d856 1
a856 1
			    inet_ntoa(*(struct in_addr *)&from->sin_addr.s_addr),
d895 1
a895 1
		    pr_addr(from->sin_addr.s_addr));
d921 2
a922 1
					else
d924 3
a926 1
						    pr_addr(ntohl(l)));
d974 6
a979 2
				else
					(void)printf("\t%s", pr_addr(ntohl(l)));
d1273 1
a1273 2
 *	Return an ascii host address as a dotted quad and optionally with
 * a hostname.
d1275 2
a1276 2
char *
pr_addr(in_addr_t a)
d1278 5
a1282 3
	struct hostent *hp;
	struct in_addr in;
	static char buf[16+3+HOST_NAME_MAX+1];
d1284 2
a1285 4
	in.s_addr = a;
	if ((options & F_NUMERIC) ||
	    !(hp = gethostbyaddr((char *)&in.s_addr, sizeof(in.s_addr), AF_INET)))
		(void)snprintf(buf, sizeof buf, "%s", inet_ntoa(in));
d1287 1
a1287 3
		(void)snprintf(buf, sizeof buf, "%s (%s)", hp->h_name,
		    inet_ntoa(in));
	return(buf);
d1427 1
a1427 1
	    "usage: ping [-DdEefLnqRv] [-c count] [-I ifaddr] [-i wait]\n"
@


1.142
log
@summary() is no longer called from a signal handler, so it can use
stdio and does not need the workarounds.
ok florian millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.141 2016/08/30 13:58:12 millert Exp $	*/
d816 1
a816 1
			timinginfo++;
@


1.141
log
@Avoid calling summary() from a signal handler.  This will allow us
to go back to using stdio there.  OK florian@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.140 2016/08/30 12:10:10 florian Exp $	*/
d1034 3
a1036 1
	char buf[8192], buft[8192];
d1038 2
a1039 17
	/* XXX - safe to use fprintf here now */
	(void)putchar('\r');
	(void)fflush(stdout);

	snprintf(buft, sizeof buft, "--- %s ping statistics ---\n",
	    hostname);
	strlcat(buf, buft, sizeof buf);

	snprintf(buft, sizeof buft, "%lld packets transmitted, ", ntransmitted);
	strlcat(buf, buft, sizeof buf);
	snprintf(buft, sizeof buft, "%lld packets received, ", nreceived);
	strlcat(buf, buft, sizeof buf);

	if (nrepeats) {
		snprintf(buft, sizeof buft, "%lld duplicates, ", nrepeats);
		strlcat(buf, buft, sizeof buf);
	}
d1042 1
a1042 2
			snprintf(buft, sizeof buft,
			    "-- somebody's duplicating packets!");
d1044 1
a1044 1
			snprintf(buft, sizeof buft, "%.1f%% packet loss",
a1046 1
		strlcat(buf, buft, sizeof buf);
d1048 1
a1048 1
	strlcat(buf, "\n", sizeof buf);
d1054 1
a1054 2
		snprintf(buft, sizeof(buft),
		    "round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
a1055 1
		strlcat(buf, buft, sizeof(buf));
a1056 1
	write(STDOUT_FILENO, buf, strlen(buf));		/* XXX atomicio? */
@


1.140
log
@usage() is __dead.
While here remove one useless call to usage() that's covered by the
very next line.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.139 2016/03/03 18:30:48 florian Exp $	*/
d171 1
a171 1
void summary(int);
a174 1
void onint(int);
d545 2
a557 5
		if (seenint) {
			onint(SIGINT);
			seenint = 0;
			continue;
		}
d559 1
a559 1
			summary(0);
d599 1
a599 1
	summary(0);
d628 6
d652 1
d654 2
a655 2
	(void)signal(SIGALRM, onint);
	(void)setitimer(ITIMER_REAL, &itimer, NULL);
a1030 15
/*
 * onint --
 *	SIGINT handler.
 */
void
onint(int signo)
{
	summary(signo);

	if (signo)
		_exit(nreceived ? 0 : 1);
	else
		exit(nreceived ? 0 : 1);
}

d1032 1
a1032 1
summary(int insig)
d1036 3
a1038 8
	buf[0] = '\0';

	if (!insig) {
		(void)putchar('\r');
		(void)fflush(stdout);
	} else
		strlcat(buf, "\r", sizeof buf);

@


1.139
log
@ping(8) and ping6(8) use different types for packet counters. In
preparation of a merge just use int64_t and be done with it.
OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.138 2016/01/30 05:38:26 semarie Exp $	*/
d186 1
a186 1
void usage(void);
d1448 1
a1448 1
void
@


1.138
log
@ping, ping6: corrects -E (audible beep when no packet is received before the
next packet is transmitted) regression

with help and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.137 2015/11/29 22:42:13 florian Exp $	*/
d73 1
d146 5
a150 5
unsigned long npackets;		/* max packets to transmit */
unsigned long nreceived;	/* # of packets we got back */
unsigned long nrepeats;		/* number of duplicates */
unsigned long ntransmitted;	/* sequence # for outbound packets = #sent */
unsigned long nmissedmax = 1;	/* max value of ntransmitted - nreceived - 1 */
d196 2
a197 1
	int ch, i, optval = 1, packlen, preload, maxsize, df = 0, tos = 0;
d222 1
a222 1
			npackets = strtonum(optarg, 0, INT_MAX, &errstr);
d278 1
a278 1
			preload = strtonum(optarg, 1, INT_MAX, &errstr);
d1061 1
a1061 1
	snprintf(buft, sizeof buft, "%ld packets transmitted, ", ntransmitted);
d1063 1
a1063 1
	snprintf(buft, sizeof buft, "%ld packets received, ", nreceived);
d1067 1
a1067 1
		snprintf(buft, sizeof buft, "%ld duplicates, ", nrepeats);
@


1.137
log
@use ping6(8)'s engine; next step in unification
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.136 2015/11/29 22:41:20 florian Exp $	*/
d547 6
a599 6
		if (ntransmitted - nreceived - 1 > nmissedmax) {
			nmissedmax = ntransmitted - nreceived - 1;
			if (!(options & F_FLOOD) && (options & F_AUD_MISS))
				(void)fputc('\a', stderr);
		}

@


1.136
log
@Reimplement source address selection. Inspired by the previous
traceroute / traceroute6 merge. Next step in unification.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.135 2015/11/29 12:32:10 florian Exp $	*/
d150 1
a150 2
double interval = 1;		/* interval between packets */
struct itimerval interstr;	/* interval structure for use with setitimer */
d165 4
d170 1
a170 4
void catcher(int signo);
void prtsig(int signo);
__dead void finish(int signo);
void summary(int, int);
d172 4
a175 1
void pinger(void);
d179 1
a179 1
void pr_pack(char *, int, struct sockaddr_in *);
d192 2
a193 1
	struct sockaddr_in  from4;
d198 1
a198 1
	char *target, hnamebuf[HOST_NAME_MAX+1], *source = NULL;
d202 1
d250 17
a266 13
			interval = strtod(optarg, NULL);

			if (interval <= 0 || interval >= INT_MAX)
				errx(1, "bad timing interval: %s", optarg);

			if (interval < 1)
				if (getuid())
					errx(1, "%s: only root may use interval < 1s",
					    strerror(EPERM));

			if (interval < 0.01)
				interval = 0.01;

a398 6
	memset(&interstr, 0, sizeof(interstr));

	interstr.it_value.tv_sec = interval;
	interstr.it_value.tv_usec =
		(long) ((interval - interstr.it_value.tv_sec) * 1000000);

a513 4
	(void)signal(SIGINT, finish);
	(void)signal(SIGALRM, catcher);
	(void)signal(SIGINFO, prtsig);

d517 14
a530 2
	if ((options & F_FLOOD) == 0)
		catcher(0);		/* start things going */
d533 26
a558 6
		struct sockaddr_in	from;
		sigset_t		omask, nmask;
		socklen_t		fromlen;
		struct pollfd		pfd;
		ssize_t			cc;
		int			timeout;
d561 1
a561 1
			pinger();
d572 16
a587 6
		fromlen = sizeof(from);
		if ((cc = recvfrom(s, packet, packlen, 0,
		    (struct sockaddr *)&from, &fromlen)) < 0) {
			if (errno == EINTR)
				continue;
			perror("ping: recvfrom");
d589 3
a591 6
		}
		sigemptyset(&nmask);
		sigaddset(&nmask, SIGALRM);
		sigprocmask(SIG_BLOCK, &nmask, &omask);
		pr_pack((char *)packet, cc, &from);
		sigprocmask(SIG_SETMASK, &omask, NULL);
d594 6
d601 2
a602 2
	finish(0);
	/* NOTREACHED */
d605 1
a605 11
/*
 * catcher --
 *	This routine causes another PING to be transmitted, and then
 * schedules another SIGALRM for 1 second from now.
 *
 * bug --
 *	Our sense of time will slowly skew (i.e., packets will not be
 * launched exactly at 1-second intervals).  This does not affect the
 * quality of the delay and loss statistics.
 */
/* ARGSUSED */
d607 1
a607 1
catcher(int signo)
d609 10
a618 21
	int save_errno = errno;
	unsigned int waittime;

	pinger();
	(void)signal(SIGALRM, catcher);
	if (!npackets || ntransmitted < npackets)
		setitimer(ITIMER_REAL, &interstr, (struct itimerval *)0);
	else {
		if (nreceived) {
			waittime = 2 * tmax / 1000000;
			if (!waittime)
				waittime = 1;
		} else
			waittime = maxwait;
		(void)signal(SIGALRM, finish);
		(void)alarm(waittime);
	}
	if (ntransmitted - nreceived - 1 > nmissedmax) {
		nmissedmax = ntransmitted - nreceived - 1;
		if (!(options & F_FLOOD) && (options & F_AUD_MISS))
			write(STDERR_FILENO, "\a", 1);
a619 1
	errno = save_errno;
d623 2
a624 1
 * Print statistics when SIGINFO is received.
a625 1
/* ARGSUSED */
d627 1
a627 1
prtsig(int signo)
d629 4
a632 1
	int save_errno = errno;
d634 17
a650 2
	summary(0, 1);
	errno = save_errno;
d661 1
a661 1
void
d668 3
d731 1
d742 1
a742 1
pr_pack(char *buf, int cc, struct sockaddr_in *from)
d744 2
d762 10
d1026 15
d1042 1
a1042 1
summary(int header, int insig)
d1054 4
a1057 5
	if (header) {
		snprintf(buft, sizeof buft, "--- %s ping statistics ---\n",
		    hostname);
		strlcat(buf, buft, sizeof buf);
	}
a1089 16
}

/*
 * finish --
 *	Print out statistics, and give up.
 */
__dead void
finish(int signo)
{
	(void)signal(SIGINT, SIG_IGN);

	summary(1, signo);
	if (signo)
		_exit(nreceived ? 0 : 1);
	else
		exit(nreceived ? 0 : 1);
@


1.135
log
@Doubles are not reals. Imprecision might lead to trying to
calculate square root of a negative number. Just use 0 in this case.
Pointed out by and fix from Nathanael Rensen ( nathanael AT list DOT
polymorpheus DOT com ), thanks!
OK deraadt@@

(Funnily this bug was in ping6 for many years, only discovered once I
synced ping to the ping6 implementation recently.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.134 2015/11/10 18:36:33 florian Exp $	*/
d113 1
a113 1
#define	F_SADDR		0x0200
a134 1
struct sockaddr_in whence;		/* Which interface we come from */
d188 2
a190 1
	struct in_addr saddr;
d192 1
d194 1
a194 1
	char *target, hnamebuf[HOST_NAME_MAX+1];
d242 1
a242 7
			if (inet_aton(optarg, &saddr) == 0) {
				if ((hp = gethostbyname(optarg)) == NULL)
					errx(1, "bad interface address: %s",
					    optarg);
				memcpy(&saddr, hp->h_addr, sizeof(saddr));
			}
			options |= F_SADDR;
d358 1
a358 1
	if (options & F_SADDR) {
d362 17
a378 6
			memset(&whence, 0, sizeof(whence));
			whence.sin_len = sizeof(whence);
			whence.sin_family = AF_INET;
			memcpy(&whence.sin_addr.s_addr, &saddr, sizeof(saddr));
			if (bind(s, (struct sockaddr *)&whence,
			    sizeof(whence)) < 0)
d435 2
a436 2
		if (options & F_SADDR)
			ip->ip_src = saddr;
d466 2
a467 2
	    setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &saddr,
	    sizeof(saddr)) < 0)
@


1.134
log
@Reduce diff between ping and ping6.
- increase MAX_DUP_CHK in ping to ping6' value, we should have enough
  ram these days.
- sync -l, -s and -V option handling
- rename MAXDATALEN to MAXPAYLOAD in ping6
no (intendet) functional change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.133 2015/11/05 21:53:35 florian Exp $	*/
d1007 1
a1007 1
		double dev = sqrt(tsumsq / num - avg * avg);
@


1.133
log
@Reorder #includes to reduce diff between ping and ping6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.132 2015/11/04 21:26:30 tedu Exp $	*/
d130 1
a130 1
#define	MAX_DUP_CHK	(8 * 128)
d198 1
a198 1
	u_int rtableid;
d274 2
a275 2
				errx(1, "preload value is %s: %s",
				    errstr, optarg);
d293 2
a294 2
				errx(1, "packet size is %s: %s",
				    errstr, optarg);
d321 2
a322 3
				errx(1, "rtable value is %s: %s",
				    errstr, optarg);

@


1.132
log
@replace setbuf with setvbuf, from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.131 2015/10/30 11:00:52 florian Exp $	*/
a54 1
#include <sys/queue.h>
a62 1
#include <math.h>
d64 1
a64 3
#include <signal.h>
#include <unistd.h>
#include <stdio.h>
d68 2
d71 4
d76 2
a77 4
#include <limits.h>
#include <stdlib.h>

#include <siphash.h>
@


1.131
log
@Use double variables and sqrt(3) from libm to calculate statistics like
ping6 does.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.130 2015/10/29 13:01:29 florian Exp $	*/
d237 1
a237 1
			setbuf(stdout, (char *)NULL);
@


1.130
log
@Backout chacha.
It's getting in the way of the merge and it's not supposed to pull in
a private header.
Prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.129 2015/10/27 13:58:45 dlg Exp $	*/
d64 1
d158 4
a161 5
quad_t tmin = 999999999;	/* minimum round trip time in usec */
quad_t tmax = 0;		/* maximum round trip time in usec */
quad_t tsum = 0;		/* sum of all times in usec, for doing average */
quad_t tsumsq = 0;		/* sum of all times squared, for std. dev. */

a178 1
quad_t qsqrt(quad_t);
d704 1
a704 1
	quad_t triptime = 0;
d758 2
a759 1
			triptime = (ts.tv_sec * 1000000) + (ts.tv_nsec / 1000);
d787 2
a788 5
			if (cc >= 8 + sizeof(struct payload)) {
				(void)printf(" time=%d.%03d ms",
				    (int)(triptime / 1000),
				    (int)(triptime % 1000));
			}
d1005 8
a1012 10
		quad_t avg = tsum / timinginfo;
		quad_t dev = qsqrt(tsumsq / timinginfo - avg * avg);

		snprintf(buft, sizeof buft, "round-trip min/avg/max/std-dev = "
		    "%d.%03d/%d.%03d/%d.%03d/%d.%03d ms\n",
		    (int)(tmin / 1000), (int)(tmin % 1000),
		    (int)(avg  / 1000), (int)(avg  % 1000),
		    (int)(tmax / 1000), (int)(tmax % 1000),
		    (int)(dev  / 1000), (int)(dev  % 1000));
		strlcat(buf, buft, sizeof buf);
a1014 18
}

quad_t
qsqrt(quad_t qdev)
{
	quad_t y, x = 1;

	if (!qdev)
		return(0);

	do { /* newton was a stinker */
		y = x;
		x = qdev / x;
		x += y;
		x /= 2;
	} while ((x - y) > 1 || (x - y) < -1);

	return(x);
@


1.129
log
@fix fallout from chacha changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.128 2015/10/11 00:20:29 guenther Exp $	*/
a76 2
#define KEYSTREAM_ONLY
#include <crypto/chacha_private.h>
a165 1
chacha_ctx fill_stream;
d192 1
a192 1
	int ch, optval = 1, packlen, preload, maxsize, df = 0, tos = 0;
d403 3
a405 5
	if (!(options & F_PINGFILLED) && datalen > sizeof(struct payload)) {
		u_int8_t key[32];
		arc4random_buf(key, sizeof(key));
		chacha_keysetup(&fill_stream, key, sizeof(key) * 8);
	}
a654 8

		if (!(options & F_PINGFILLED) && datalen >= sizeof(payload)) {
			u_int8_t *dp = &outpack[8 + sizeof(payload)];

			chacha_ivsetup(&fill_stream, payload.mac, 0);
			chacha_encrypt_bytes(&fill_stream, dp, dp,
			    datalen - sizeof(payload));
		}
a798 5
			if (!(options & F_PINGFILLED) && datalen >= sizeof(payload)) {
				chacha_ivsetup(&fill_stream, payload.mac, 0);
				chacha_encrypt_bytes(&fill_stream, dp, dp,
				    datalen - sizeof(payload));
			}
@


1.128
log
@Prefer dprintf() over snprintf()+write()

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.127 2015/10/09 01:37:06 deraadt Exp $	*/
d409 1
a409 1
		chacha_keysetup(&fill_stream, key, sizeof(key) * 8, 0);
d664 1
a664 1
			chacha_ivsetup(&fill_stream, payload.mac);
d813 1
a813 1
				chacha_ivsetup(&fill_stream, payload.mac);
@


1.127
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.126 2015/10/03 00:44:37 deraadt Exp $	*/
a625 1
	char buf[8192];
d690 1
a690 1
		snprintf(buf, sizeof buf, "ping: wrote %s %d chars, ret=%d\n",
a691 1
		write(STDOUT_FILENO, buf, strlen(buf));
@


1.126
log
@ping is a setuid root priv-drop which holds a sockraw.  we can tame it
substantially with "stdio inet", plus "dns" if the -n option is missing.
a successful exploit against it then cannot create files, or perform a
variety of other operations, as described in the tame(2) man page.
work with florian a while back
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.125 2015/09/03 17:59:54 florian Exp $	*/
d505 2
a506 2
		if (tame("stdio inet", NULL) == -1)
			err(1, "tame");
d508 2
a509 2
		if (tame("stdio inet dns", NULL) == -1)
			err(1, "tame");
@


1.125
log
@Move tricky system calls up and sensitive data calculations down so
that tame(2) can sit in the middle.
diff from deraadt@@
"you can commit that diff" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.124 2015/08/05 12:46:12 deraadt Exp $	*/
d503 8
@


1.124
log
@repair buffer size checks around chacha block, spotted by Dimitris Papastamos
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.123 2015/05/02 18:03:37 florian Exp $	*/
a349 9
	arc4random_buf(&tv64_offset, sizeof(tv64_offset));
	arc4random_buf(&mac_key, sizeof(mac_key));

	memset(&interstr, 0, sizeof(interstr));

	interstr.it_value.tv_sec = interval;
	interstr.it_value.tv_usec =
		(long) ((interval - interstr.it_value.tv_sec) * 1000000);

d368 27
a412 18

	if (options & F_SADDR) {
		if (IN_MULTICAST(ntohl(to->sin_addr.s_addr)))
			moptions |= MULTICAST_IF;
		else {
			memset(&whence, 0, sizeof(whence));
			whence.sin_len = sizeof(whence);
			whence.sin_family = AF_INET;
			memcpy(&whence.sin_addr.s_addr, &saddr, sizeof(saddr));
			if (bind(s, (struct sockaddr *)&whence,
			    sizeof(whence)) < 0)
				err(1, "bind");
		}
	}

	if (options & F_SO_DEBUG)
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, &optval,
		    sizeof(optval));
@


1.123
log
@de-castify strtonum to make it consistent again.
Pointed out by bluhm@@; no object change.
OK bluhm@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.122 2015/05/02 17:16:07 florian Exp $	*/
d654 1
a654 1
		if (!(options & F_PINGFILLED) && datalen > sizeof(payload)) {
d806 1
a806 1
			if (!(options & F_PINGFILLED)) {
@


1.122
log
@A ttl of 0 is valid. While here use MAXTTL instead of 255.
Input bluhm@@, OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.121 2015/04/20 00:36:51 dlg Exp $	*/
d218 1
a218 2
			npackets = (unsigned long)strtonum(optarg, 0,
			    INT_MAX, &errstr);
d276 1
a276 1
			preload = (int)strtonum(optarg, 1, INT_MAX, &errstr);
d295 1
a295 1
			datalen = (unsigned int)strtonum(optarg, 0, MAXPAYLOAD, &errstr);
d311 1
a311 2
				tos = (int)strtonum(optarg, 0, 255,
				    &errstr);
d323 1
a323 2
			rtableid = (unsigned int)strtonum(optarg, 0,
			    RT_TABLEID_MAX, &errstr);
d336 1
a336 2
			maxwait = (unsigned int)strtonum(optarg, 1, INT_MAX,
			    &errstr);
@


1.121
log
@fold the icmp seq number into the mac.

i dont know why i missed this before.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.120 2015/04/19 12:56:42 dlg Exp $	*/
d320 1
a320 1
			ttl = (u_char)strtonum(optarg, 1, 255, &errstr);
@


1.120
log
@by default fill the ping payload with a chacha stream instead of
an unvarying payload.

each ping process generates a random key, and each packet then uses
the timestamps mac as the IV for the stream.

this allows us to have a different payload per packet that we can
recalculate and compare in the same was as the static payload was
checked before. by aggressively varying the payload we hope to
generate more opportunities for dodgy network equipment to show
errors.

note that we do siphash before chacha because we want to be strict
about the timestamp payload, but we want to be able to recognise
errors in the rest of the payload and where those errors were. doing
chacha before siphash would have us than fail the whole packet if
a checksum doesnt match.

discussed with jp aumasson
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.118 2015/03/23 09:36:25 dlg Exp $	*/
d651 1
d751 2
@


1.119
log
@add a mac to the timestamp payload and calculate it with siphash.

this lets us have some confidence that the timestamp hasnt been
damaged or tampered with in transit.

discussed with jp aumasson
ok florian@@
@
text
@d75 1
d77 2
d168 1
d195 1
a195 1
	int ch, i, optval = 1, packlen, preload, maxsize, df = 0, tos = 0;
d392 5
a396 3
	if (!(options & F_PINGFILLED))
		for (i = sizeof(struct payload); i < datalen; ++i)
			*datap++ = i;
d656 8
d717 1
a740 1
			struct payload payload;
d807 5
@


1.118
log
@obfuscate the monotonic clock values we put on the wire by offsetting
them with a random value.

picking between ^ and +- as the operator for the obfuscation has
turned out to be a great bikeshed. im picking + and - cos it prevents
observers seeing high bits roll over which can indicate the magnitude
of the current clock value.

discussed with many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.117 2015/03/12 09:54:11 florian Exp $	*/
d75 1
d82 5
d164 1
d209 1
a209 1
	datap = &outpack[8 + sizeof(struct tv64)];
d351 1
d383 1
a383 1
	if (datalen >= sizeof(struct tv64))	/* can we time transfer */
d389 1
a389 1
		for (i = sizeof(struct tv64); i < datalen; ++i)
d630 1
d632 2
a633 1
		struct tv64 tv64;
d637 1
a637 1
		tv64.tv64_sec = htobe64((u_int64_t)ts.tv_sec +
d639 1
a639 1
		tv64.tv64_nsec = htobe64((u_int64_t)ts.tv_nsec +
d641 9
a649 1
		memcpy(&outpack[8], &tv64, sizeof(tv64));
d724 8
a731 2
		if (cc >= 8 + sizeof(struct tv64)) {
			struct tv64 tv64;
d733 12
d746 2
a747 3
			pkttime = (char *)icp->icmp_data;
			memcpy(&tv64, pkttime, sizeof(tv64));
			tp.tv_sec = betoh64(tv64.tv64_sec) -
d749 1
a749 1
			tp.tv_nsec = betoh64(tv64.tv64_nsec) -
d781 1
a781 1
			if (cc >= 8 + sizeof(struct tv64))
d785 1
d791 4
a794 3
			cp = (u_char *)&icp->icmp_data[sizeof(struct tv64)];
			dp = &outpack[8 + sizeof(struct tv64)];
			for (i = 8 + sizeof(struct tv64); i < cc && i < datalen;
d1311 1
a1311 1
		    kk <= MAXPAYLOAD - (8 + sizeof(struct tv64) + ii);
@


1.117
log
@Only read time information from the received packet if it is big
enough.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.116 2015/03/12 00:14:29 dlg Exp $	*/
d157 2
d343 2
d627 4
a630 2
		tv64.tv64_sec = htobe64(ts.tv_sec);
		tv64.tv64_nsec = htobe64(ts.tv_nsec);
d712 4
a715 2
			tp.tv_sec = betoh64(tv64.tv64_sec);
			tp.tv_nsec = betoh64(tv64.tv64_nsec);
@


1.116
log
@bump the size of the time types on the wire to 64bit, and use nsec
instead of usec so its easier to translate to/from timespecs instead
of timevals.

ok deraadt@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.115 2015/03/11 03:35:17 dlg Exp $	*/
d148 1
d700 1
a700 1
		if (timing) {
d703 1
d738 1
a738 1
			if (timing)
d956 3
a958 4
	if (nreceived && timing) {
		quad_t num = nreceived + nrepeats;
		quad_t avg = tsum / num;
		quad_t dev = qsqrt(tsumsq / num - avg * avg);
@


1.115
log
@use clock_gettime(CLOCK_MONOTONIC) to get timestamps to measure the
interval between sending a ping and getting a reply for it.

this makes it resistant against local wall clock changes, which can
skew the intervals reported or make them go negative.

ok deraadt@@ florian@@
makes sense to lots of others
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.114 2015/01/16 06:40:00 deraadt Exp $	*/
d76 3
a78 3
struct tv32 {
	u_int	tv32_sec;
	u_int	tv32_usec;
d199 1
a199 1
	datap = &outpack[8 + sizeof(struct tv32)];
d370 1
a370 1
	if (datalen >= sizeof(struct tv32))	/* can we time transfer */
d376 1
a376 1
		for (i = sizeof(struct tv32); i < datalen; ++i)
d618 1
a618 2
		struct timeval tv;
		struct tv32 tv32;
d622 3
a624 4
		TIMESPEC_TO_TIMEVAL(&tv, &ts);
		tv32.tv32_sec = htonl(tv.tv_sec);	/* XXX 2038 */
		tv32.tv32_usec = htonl(tv.tv_usec);
		memcpy(&outpack[8], &tv32, sizeof tv32);
d674 1
a674 2
	struct timespec ts;
	struct timeval tv, tp;
a680 1
	TIMESPEC_TO_TIMEVAL(&tv, &ts);
d700 1
a700 1
			struct tv32 tv32;
d703 3
a705 3
			memcpy(&tv32, pkttime, sizeof tv32);
			tp.tv_sec = ntohl(tv32.tv32_sec);
			tp.tv_usec = ntohl(tv32.tv32_usec);
d707 2
a708 2
			timersub(&tv, &tp, &tv);
			triptime = (tv.tv_sec * 1000000) + tv.tv_usec;
d745 3
a747 3
			cp = (u_char *)&icp->icmp_data[sizeof(struct tv32)];
			dp = &outpack[8 + sizeof(struct tv32)];
			for (i = 8 + sizeof(struct tv32); i < cc && i < datalen;
d1265 1
a1265 1
		    kk <= MAXPAYLOAD - (8 + sizeof(struct tv32) + ii);
@


1.114
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.113 2014/11/20 15:22:39 tedu Exp $	*/
d617 1
d621 3
a623 1
		(void)gettimeofday(&tv, (struct timezone *)NULL);
d676 1
d682 3
a684 1
	(void)gettimeofday(&tv, (struct timezone *)NULL);
@


1.113
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.112 2014/10/25 03:18:13 lteo Exp $	*/
d73 1
d183 1
a183 1
	char *target, hnamebuf[MAXHOSTNAMELEN];
d1211 1
a1211 1
	static char buf[16+3+MAXHOSTNAMELEN];
@


1.112
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.111 2014/07/11 15:30:47 florian Exp $	*/
a56 1
#include <sys/file.h>
@


1.111
log
@__dead for finish()
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.110 2014/07/11 15:29:46 florian Exp $	*/
a59 1
#include <netinet/in_systm.h>
@


1.110
log
@Silence compiler warning and build with -Wall etc.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.109 2014/07/11 15:26:55 florian Exp $	*/
d160 1
a160 1
void finish(int signo);
a537 1
	exit(0);	/* Make the compiler happy */
d991 1
a991 1
void
@


1.109
log
@use optval for setsockopt; sync with ping6
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.108 2014/07/09 15:24:19 florian Exp $	*/
d1310 1
a1310 1
map_tos(char *s, int *val)
d1348 1
a1348 1
		if (strcmp(s, t->keyword) == 0) {
@


1.108
log
@We do have icmp_data; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.107 2014/07/09 15:23:29 florian Exp $	*/
d182 1
a182 1
	int ch, hold = 1, i, packlen, preload, maxsize, df = 0, tos = 0;
d397 2
a398 2
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, &hold,
		    sizeof(hold));
d414 1
a414 1
		setsockopt(s, IPPROTO_IP, IP_HDRINCL, &hold, sizeof(hold));
@


1.107
log
@We do have ICMP_MASKREQ & ICMP_MASKREPLY; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.106 2014/07/09 15:22:36 florian Exp $	*/
a701 3
#ifndef icmp_data
			pkttime = (char *)&icp->icmp_ip;
#else
a702 1
#endif
a1075 3
#ifndef icmp_data
		pr_retip(&icp->icmp_ip);
#else
a1076 1
#endif
a1079 3
#ifndef icmp_data
		pr_retip(&icp->icmp_ip);
#else
a1080 1
#endif
a1101 3
#ifndef icmp_data
		pr_retip(&icp->icmp_ip);
#else
a1102 1
#endif
a1130 3
#ifndef icmp_data
		pr_retip(&icp->icmp_ip);
#else
a1131 1
#endif
a1144 3
#ifndef icmp_data
		pr_retip(&icp->icmp_ip);
#else
a1145 1
#endif
@


1.106
log
@notdef is notdef since the beginning of time; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.105 2014/07/09 15:21:41 florian Exp $	*/
a1186 1
#ifdef ICMP_MASKREQ
a1189 2
#endif
#ifdef ICMP_MASKREPLY
a1193 1
#endif
@


1.105
log
@We do have SIGINFO; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.104 2014/07/09 15:20:51 florian Exp $	*/
a1006 16

#ifdef notdef
static char *ttab[] = {
	"Echo Reply",		/* ip + seq + udata */
	"Dest Unreachable",	/* net, host, proto, port, frag, sr + IP */
	"Source Quench",	/* IP */
	"Redirect",		/* redirect type, gateway, + IP  */
	"Echo",
	"Time Exceeded",	/* transit, frag reassem + IP */
	"Parameter Problem",	/* pointer + IP */
	"Timestamp",		/* id + seq + three timestamps */
	"Timestamp Reply",	/* " */
	"Info Request",		/* id + sq */
	"Info Reply"		/* " */
};
#endif
@


1.104
log
@We do have IP_OPTIONS; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.103 2014/04/28 15:25:34 florian Exp $	*/
a491 1
#ifdef SIGINFO
a492 1
#endif
@


1.103
log
@Do not sleep after poll returning an error. Blindly copied over from
ping6 to ping by me without thinking clearly.
pointed out by deraadt@@
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.102 2014/04/23 18:16:36 jca Exp $	*/
a184 1
#ifdef IP_OPTIONS
a185 1
#endif
a432 1
#ifdef IP_OPTIONS
a441 3
#else
		errx(1, "record route not available in this implementation");
#endif /* IP_OPTIONS */
@


1.102
log
@Better name for fdmaskp, reduce the scope of some variables, don't abuse
cc for poll()'s return value, and indent decls.  ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.101 2014/04/23 12:27:31 florian Exp $	*/
d514 1
a514 1
		int			ret, timeout;
d525 1
a525 8
		ret = poll(&pfd, 1, timeout);
		if (ret < 0) {
			if (errno != EINTR) {
				warn("poll");
				sleep(1);
			}
			continue;
		} else if (ret == 0)
@


1.101
log
@Replace malloc / memset / select song and dance with poll(2) like
ping6.
Prompted by and initial diff from Peter Malone (peter _AT_
petermalone _DOT_ org), thanks!
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.100 2014/03/24 11:11:49 mpi Exp $	*/
a180 1
	struct pollfd fdmaskp[1];
d182 1
a182 2
	int i, ch, hold = 1, packlen, preload, maxsize, df = 0, tos = 0;
	int timeout;
d509 6
a514 4
		struct sockaddr_in from;
		sigset_t omask, nmask;
		socklen_t fromlen;
		int cc;
d521 6
a526 4
		fdmaskp[0].fd = s;
		fdmaskp[0].events = POLLIN;
		cc = poll(fdmaskp, 1, timeout);
		if (cc < 0) {
d532 1
a532 1
		} else if (cc == 0)
d534 1
@


1.100
log
@Remove "-r" option from ping(8) and traceroute{,6}(8).  You've probably
never heard about it, it was to bypass the routing tables, not available
for IPv6 and we're going to always use the routing tables soon.

ok florian@@, man pages ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.99 2014/01/10 21:57:44 florian Exp $	*/
d73 1
a178 1
	struct timeval timeout;
d181 1
d184 1
a191 2
	fd_set *fdmaskp;
	size_t fdmasks;
a509 4
	fdmasks = howmany(s+1, NFDBITS) * sizeof(fd_mask);
	if ((fdmaskp = (fd_set *)malloc(fdmasks)) == NULL)
		err(1, "malloc");

d518 14
a531 8
			timeout.tv_sec = 0;
			timeout.tv_usec = 10000;
			memset(fdmaskp, 0, fdmasks);
			FD_SET(s, fdmaskp);
			if (select(s + 1, (fd_set *)fdmaskp, (fd_set *)NULL,
			    (fd_set *)NULL, &timeout) < 1)
				continue;
		}
a547 1
	free(fdmaskp);
@


1.99
log
@Fix the unitialized rtableid bug discovered and fixed in the previous
commit by brad@@ by calling setsockopt SO_RTABLE only when -V is
present. As a bonus drop privileges very early in main, before option
parsing.
This brings ping6 more in line with what ping does and will make
eventual unification easier.

OK deraadt@@
"works for me" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.98 2014/01/10 06:18:40 brad Exp $	*/
d103 1
a103 1
#define	F_SO_DONTROUTE	0x0080
d206 1
a206 1
	    "DEI:LRS:c:defi:l:np:qrs:T:t:V:vw:")) != -1)
a285 3
		case 'r':
			options |= F_SO_DONTROUTE;
			break;
a402 3
	if (options & F_SO_DONTROUTE)
		(void)setsockopt(s, SOL_SOCKET, SO_DONTROUTE, &hold,
		    sizeof(hold));
d1417 1
a1417 1
	    "usage: ping [-DdEefLnqRrv] [-c count] [-I ifaddr] [-i wait]\n"
@


1.98
log
@Fix a bug found in ping6 when rebuilding with stack protector strong.
rtableid is unitialized; the stack protector strong binary would fail
to set the routing table id. Copy the rtableid initialization over to
ping to keep what is essentially similar code in sync.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.97 2013/11/22 04:12:48 deraadt Exp $	*/
d193 1
a193 1
	int rtableid = -1;
@


1.97
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.96 2013/10/28 15:05:35 deraadt Exp $	*/
d193 1
a193 1
	u_int rtableid;
@


1.96
log
@use %d instead of %i in a few fprintf for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.95 2013/09/12 23:06:44 krw Exp $	*/
d1316 1
a1316 1
		if (!isxdigit(*cp))
@


1.95
log
@Misc time_t tweaks. %ld / (long)tv_sec -> %lld / (long long)tv_sec.
Eliminate unneeded casts. suggestions from & ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.94 2013/04/16 22:10:34 deraadt Exp $	*/
d494 1
a494 1
		warnx("Could only allocate a receive buffer of %i bytes (default %i)",
@


1.94
log
@improve name of the 32-bit timeval that ping uses, and bound the use
a bit better.  discussed with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.93 2012/12/04 02:24:47 deraadt Exp $	*/
d350 1
a350 1
	interstr.it_value.tv_sec = (long) interval;
@


1.93
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.92 2012/03/17 10:16:40 dlg Exp $	*/
d76 3
a78 3
struct tvi {
	u_int	tv_sec;
	u_int	tv_usec;
d204 1
a204 1
	datap = &outpack[8 + sizeof(struct tvi)];
d378 1
a378 1
	if (datalen >= sizeof(struct tvi))	/* can we time transfer */
d384 1
a384 1
		for (i = sizeof(struct tvi); i < datalen; ++i)
d637 1
a637 1
		struct tvi tvi;
d640 3
a642 3
		tvi.tv_sec = htonl(tv.tv_sec);
		tvi.tv_usec = htonl(tv.tv_usec);
		memcpy(&outpack[8], &tvi, sizeof tvi);
d717 1
a717 1
			struct tvi tvi;
d724 3
a726 3
			memcpy(&tvi, pkttime, sizeof tvi);
			tp.tv_sec = ntohl(tvi.tv_sec);
			tp.tv_usec = ntohl(tvi.tv_usec);
d766 3
a768 3
			cp = (u_char *)&icp->icmp_data[sizeof(struct tvi)];
			dp = &outpack[8 + sizeof(struct tvi)];
			for (i = 8 + sizeof(struct tvi); i < cc && i < datalen;
d1326 1
a1326 1
		    kk <= MAXPAYLOAD - (8 + sizeof(struct tvi) + ii);
@


1.92
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.91 2011/09/20 09:46:19 deraadt Exp $	*/
d54 1
a54 1
#include <sys/param.h>
@


1.91
log
@rev 1.80 added calls from the signal handler to stdio.  bad bad bad!
use system calls directly, instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.90 2011/09/17 14:10:05 haesbaert Exp $	*/
a107 1
#define	F_SO_JUMBO	0x1000
d206 1
a206 1
	    "DEI:LRS:c:defi:jl:np:qrs:T:t:V:vw:")) != -1)
a260 3
		case 'j':
			options |= F_SO_JUMBO;
			break;
a407 3
		    sizeof(hold));
	if (options & F_SO_JUMBO)
		(void)setsockopt(s, SOL_SOCKET, SO_JUMBO, &hold,
@


1.90
log
@Standarize the ToS option across nc/ping/traceroute so that they'll
accept the same values as pf.conf. It accepts decimal, hexadecimal and
the dscp/tos keywords. The ping option was ripped of in SMALL.

ok mcbride@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.89 2011/06/21 17:31:07 mikeb Exp $	*/
d599 1
a599 1
			(void)fputc('\a', stderr);
d904 1
a904 1
			(void)fputc('\a', stderr);
@


1.89
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.88 2010/07/03 04:44:51 guenther Exp $	*/
d171 3
d299 1
d302 12
a313 3
			tos = (int)strtonum(optarg, 0, 0xff, &errstr);
			if (errstr)
				errx(1, "tos value is %s: %s", errstr, optarg);
d315 1
d1376 50
d1431 5
a1435 2
	    "\t[-l preload] [-p pattern] [-s packetsize] [-T tos] [-t ttl]\n"
	    "\t[-V rtable] [-w maxwait] host\n");
@


1.88
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.87 2010/06/26 18:30:03 phessler Exp $	*/
d315 1
a315 1
			if (setsockopt(s, IPPROTO_IP, SO_RTABLE, &rtableid,
@


1.87
log
@allow a user to set a -c count of 0.
while here, change ping6 to use strtonum instead of strtol.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.86 2009/12/24 10:06:35 sobrado Exp $	*/
d191 1
a191 1
	u_int rdomain;
d309 1
a309 1
			rdomain = (unsigned int)strtonum(optarg, 0,
d312 1
a312 1
				errx(1, "rdomain value is %s: %s",
d315 3
a317 3
			if (setsockopt(s, IPPROTO_IP, SO_RDOMAIN, &rdomain,
			    sizeof(rdomain)) == -1)
				err(1, "setsockopt SO_RDOMAIN");
d1368 1
a1368 1
	    "\t[-V rdomain] [-w maxwait] host\n");
@


1.86
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.85 2009/12/15 21:09:43 mpf Exp $	*/
d207 2
a208 1
			npackets = (unsigned long)strtonum(optarg, 1, INT_MAX, &errstr);
@


1.85
log
@Let ping handle truncated echo replies.
Instead of a false data mismatch report, we now print (TRUNC!).
This also fixes two out of bounds accesses.
The "wrong data byte #XXX" counter was also wrong and off by 8 bytes.
OK djm@@ on an earlier version, OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.84 2009/10/27 23:59:34 deraadt Exp $	*/
d1088 1
a1088 1
			(void)printf("Desination Host Unreachable for TOS\n");
@


1.84
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.83 2009/06/05 00:11:26 claudio Exp $	*/
d756 2
d760 1
a760 1
			for (i = 8 + sizeof(struct tvi); i < datalen;
d765 1
a765 1
					    i, *dp, *cp);
d767 2
a768 1
					for (i = 8; i < datalen; ++i, ++cp) {
@


1.83
log
@Fix usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.82 2009/06/05 00:07:47 claudio Exp $	*/
a34 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)ping.c	8.1 (Berkeley) 6/5/93";
#else
static const char rcsid[] = "$OpenBSD: ping.c,v 1.82 2009/06/05 00:07:47 claudio Exp $";
#endif
#endif /* not lint */
@


1.82
log
@Allow ping to use an alternate routing domain by using the -V flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.81 2009/06/01 14:16:02 jmc Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.81 2009/06/01 14:16:02 jmc Exp $";
d1378 1
a1378 1
	    "\t[-w maxwait] host\n");
@


1.81
log
@tweak previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.80 2009/05/31 17:33:39 ckuethe Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.80 2009/05/31 17:33:39 ckuethe Exp $";
d205 1
d218 1
a218 1
	    "DEI:LRS:c:defi:jl:np:qrs:T:t:vw:")) != -1)
d321 11
d336 2
a337 1
			maxwait = (unsigned int)strtonum(optarg, 1, INT_MAX, &errstr);
@


1.80
log
@add audible output to ping and ping6: -e beeps when pings are replied, -E beeps when
pings are dropped.

suggestion to make ping and ping6 use the same flag from deraadt & sthen.
reminder to not forget about ping6 from todd and naddy.

ok deraadt, sthen
"well, i don't object..." from a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.79 2009/04/23 23:18:35 sthen Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.79 2009/04/23 23:18:35 sthen Exp $";
d1363 1
a1363 1
	    "usage: ping [-AaDdfLnqRrv] [-c count] [-I ifaddr] [-i wait]\n"
@


1.79
log
@ping -v can segfault when displaying received icmp packets that aren't
echo replies. it's because the pointer arithmetic is scaled to the size
of struct icmp, so 28*28 bytes are added rather than just 28. fortunately
a correct value was calculated 2 lines earlier, so we can just use that.

"thats a cool fix" dlg, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.78 2007/02/06 15:25:18 jmc Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.78 2007/02/06 15:25:18 jmc Exp $";
d123 2
d157 1
d217 1
a217 1
	    "DI:LRS:c:dfi:jl:np:qrs:T:t:vw:")) != -1)
d233 6
d365 3
d582 5
d886 2
d1363 1
a1363 1
	    "usage: ping [-DdfLnqRrv] [-c count] [-I ifaddr] [-i wait]\n"
@


1.78
log
@remove -j from usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.77 2006/04/13 00:49:15 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.77 2006/04/13 00:49:15 deraadt Exp $";
d764 1
a764 2
		if (cc >= hlen2 + 8 && check_icmph((struct ip *)(icp +
		    sizeof (struct icmp))) != 1)
@


1.77
log
@fix more signal races; ok moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.76 2006/04/10 08:05:13 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.76 2006/04/10 08:05:13 deraadt Exp $";
d1345 1
a1345 1
	    "usage: ping [-DdfjLnqRrv] [-c count] [-I ifaddr] [-i wait]\n"
@


1.76
log
@minimal cleanups prompted by lint; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.75 2006/03/23 03:30:49 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.75 2006/03/23 03:30:49 deraadt Exp $";
a574 1
 * XXX not race safe
d909 1
a909 1
summary(int header, int sig)
d915 1
a915 1
	if (!sig) {
d990 1
a990 1
	summary(1, 0);
@


1.75
log
@sloppy style to cast the sockaddrs backwards, and then potentially wrong size; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.74 2006/03/06 10:45:56 djm Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.74 2006/03/06 10:45:56 djm Exp $";
d359 1
a359 1
	if (!(packet = (u_char *)malloc((u_int)packlen)))
d518 1
a518 1
		if ((cc = recvfrom(s, (char *)packet, packlen, 0,
d619 1
a619 1
		memcpy((u_int *)&outpack[8], &tvi, sizeof tvi);
d636 1
a636 1
	i = sendto(s, (char *)packet, cc, 0, (struct sockaddr *)&whereto,
d763 1
a763 1
		ip2 = (struct ip *) (buf + hlen + sizeof (struct icmp));
@


1.74
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.73 2006/01/09 22:42:35 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.73 2006/01/09 22:42:35 deraadt Exp $";
d139 1
a139 1
struct sockaddr whereto;	/* who to ping */
d337 2
a338 2
	memset(&whereto, 0, sizeof(struct sockaddr));
	to = (struct sockaddr_in *)&whereto;
d636 2
a637 2
	i = sendto(s, (char *)packet, cc, 0, &whereto,
	    sizeof(struct sockaddr));
@


1.73
log
@some minor types house cleaning, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.72 2005/09/01 17:59:13 otto Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.72 2005/09/01 17:59:13 otto Exp $";
d201 1
d207 3
a209 2
	seteuid(getuid());
	setuid(getuid());
@


1.72
log
@Comment fix and make description of -c and -w match reality more
closely. ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.71 2005/05/27 04:55:27 mcbride Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.71 2005/05/27 04:55:27 mcbride Exp $";
d191 2
a192 5
	int i;
	int ch, hold = 1, packlen, preload;
	int maxsize, fdmasks;
	socklen_t maxsizelen;
	u_char *datap, *packet;
a193 2
	u_char ttl = MAXTTL, loop = 1;
	int df = 0, tos = 0;
d197 2
d200 1
a200 1
	const char *errstr;
d215 1
a215 1
			npackets = strtonum(optarg, 1, INT_MAX, &errstr);
d270 1
a270 1
			preload = strtonum(optarg, 1, INT_MAX, &errstr);
d292 1
a292 1
			datalen = strtonum(optarg, 0, MAXPAYLOAD, &errstr);
d299 1
a299 1
			tos = strtonum(optarg, 0, 0xff, &errstr);
d305 1
a305 1
			ttl = strtonum(optarg, 1, 255, &errstr);
d313 1
a313 1
			maxwait = strtonum(optarg, 1, INT_MAX, &errstr);
d346 1
a346 1
		memcpy(&to->sin_addr, hp->h_addr, hp->h_length);
d373 1
a373 1
			if (bind(s, (struct sockaddr*)&whence,
d380 1
a380 1
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&hold,
d383 1
a383 1
		(void)setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *)&hold,
d386 1
a386 1
		(void)setsockopt(s, SOL_SOCKET, SO_JUMBO, (char *)&hold,
@


1.71
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.70 2005/01/19 13:40:47 mpf Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.70 2005/01/19 13:40:47 mpf Exp $";
d161 3
a163 3
quad_t tmin = 999999999;	/* minimum round trip time in millisec */
quad_t tmax = 0;		/* maximum round trip time in millisec */
quad_t tsum = 0;		/* sum of all times in millisec, for doing average */
@


1.70
log
@Don't ignore a provided source address, when building an own IP header.
This makes the -I option work together with -D, -T and -t.
OK deraadt@@, hshoexer@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.69 2004/09/14 23:52:46 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.69 2004/09/14 23:52:46 deraadt Exp $";
d110 13
a122 12
#define	F_FLOOD		0x001
#define	F_INTERVAL	0x002
#define	F_NUMERIC	0x004
#define	F_PINGFILLED	0x008
#define	F_QUIET		0x010
#define	F_RROUTE	0x020
#define	F_SO_DEBUG	0x040
#define	F_SO_DONTROUTE	0x080
#define	F_VERBOSE	0x100
#define	F_SADDR		0x200
#define	F_HDRINCL	0x400
#define	F_TTL		0x800
d214 2
a215 1
	while ((ch = getopt(argc, argv, "DI:LRS:c:dfi:l:np:qrs:T:t:vw:")) != -1)
d263 3
d388 3
d1347 1
a1347 1
	    "usage: ping [-DdfLnqRrv] [-c count] [-I ifaddr] [-i wait]\n"
@


1.69
log
@df is a flag, not some u_char thing with -1 value; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.68 2004/09/14 23:51:34 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.68 2004/09/14 23:51:34 deraadt Exp $";
d406 4
a409 1
		ip->ip_src.s_addr = INADDR_ANY;
@


1.68
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.67 2004/05/03 20:55:46 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.67 2004/05/03 20:55:46 millert Exp $";
d196 2
a197 2
	u_char ttl = MAXTTL, loop = 1, df = 0;
	int tos = 0;
d224 1
a224 1
			df = -1;
d403 1
a403 1
		ip->ip_off = htons(df?IP_DF:0);
@


1.67
log
@Use libc strtonum, not private copy.  Based on a diff from tedu@@.
OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.66 2004/04/07 14:09:35 aaron Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.66 2004/04/07 14:09:35 aaron Exp $";
d539 1
d567 1
@


1.66
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.65 2004/03/21 20:00:55 markus Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.65 2004/03/21 20:00:55 markus Exp $";
a181 2
static unsigned long strtonum(const char *, unsigned long, unsigned long,
    const char *);
d202 1
d216 5
a220 2
			npackets = strtonum(optarg, 1, INT_MAX,
			    "number of packets to transmit");
d268 4
a271 1
			preload = strtonum(optarg, 1, INT_MAX, "preload value");
d290 4
a293 2
			datalen = strtonum(optarg, 0, MAXPAYLOAD,
			    "packet size");
d297 3
a299 1
			tos = strtonum(optarg, 0, 0xff, "tos value");
d303 3
a305 1
			ttl = strtonum(optarg, 1, 255, "ttl value");
d311 4
a314 1
			maxwait = strtonum(optarg, 1, INT_MAX, "maxwait value");
a1338 22

static unsigned long
strtonum(const char *numstring, unsigned long minval, unsigned long maxval,
    const char *errstring)
{
	char *ep;
	unsigned long lval;

	errno = 0;
	lval = strtoul(numstring, &ep, 10);
	if (numstring[0] == '\0' || *ep != '\0')
		errx(1, "bad %s: %s", errstring, numstring);
	if (errno == ERANGE && lval == ULONG_MAX)
		errx(1, "bad %s: %s", errstring, numstring);
	if (lval < minval)
		errx(1, "%s too small: %s", errstring, numstring);
	if (lval > maxval)
		errx(1, "%s too large: %s", errstring, numstring);

	return (lval);
}

@


1.65
log
@don't leak the stack on -R; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.64 2004/02/29 05:19:37 tedu Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.64 2004/02/29 05:19:37 tedu Exp $";
d214 1
a214 1
	while ((ch = getopt(argc, argv, "DI:LRS:c:dfh:i:l:np:qrs:T:t:vw:")) != -1)
@


1.64
log
@better strtol with consistent usage, unsigned where appropriate, -Wall clean.
with some help and ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.63 2003/07/24 03:10:04 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: ping.c,v 1.63 2003/07/24 03:10:04 deraadt Exp $";
d401 1
@


1.63
log
@make packet loss double and print using %.1lf; based on diff from jeffi@@rcn.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.62 2003/07/02 21:44:58 deraadt Exp $	*/
d37 1
a37 1
static char copyright[] =
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.62 2003/07/02 21:44:58 deraadt Exp $";
d140 1
a140 1
int datalen = DEFDATALEN;
d150 4
a153 4
long npackets;			/* max packets to transmit */
long nreceived;			/* # of packets we got back */
long nrepeats;			/* number of duplicates */
long ntransmitted;		/* sequence # for outbound packets = #sent */
d159 1
a159 1
int maxwait = MAXWAIT_DEFAULT;	/* max seconds to wait for response */
d182 2
d217 2
a218 4
			npackets = strtol(optarg, NULL, 0);
			if (npackets <= 0)
				errx(1, "bad number of packets to transmit: %s",
				    optarg);
d266 1
a266 3
			preload = strtol(optarg, NULL, 0);
			if (preload < 0)
				errx(1, "bad preload value: %s", optarg);
d285 2
a286 5
			datalen = strtol(optarg, NULL, 0);
			if (datalen < 0)
				errx(1, "bad packet size: %s", optarg);
			if (datalen > MAXPAYLOAD)
				errx(1, "packet size too large: %s", optarg);
d290 1
a290 3
			tos = strtoul(optarg, NULL, 0);
			if (tos > 0xFF)
				errx(1, "bad tos value: %s", optarg);
d294 1
a294 5
			ttl = strtol(optarg, NULL, 0);
			if (ttl <= 0)
				errx(1, "bad ttl value: %s", optarg);
			if (ttl > 255)
				errx(1, "ttl value too large: %s", optarg);
d300 1
a300 3
			maxwait = strtol(optarg, NULL, 0);
			if (maxwait <= 0)
				errx(1, "bad maxwait value: %s", optarg);
d528 1
a528 1
	int waittime;
d542 1
a542 1
		(void)alarm((u_int)waittime);
d915 1
a915 1
			snprintf(buft, sizeof buft, "%.1lf%% packet loss",
d1324 22
@


1.62
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.61 2003/06/11 06:22:14 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.61 2003/06/11 06:22:14 deraadt Exp $";
d928 2
a929 2
			snprintf(buft, sizeof buft, "%d%% packet loss",
			    (int) (((ntransmitted - nreceived) * 100) /
@


1.61
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.60 2003/06/02 20:06:16 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.60 2003/06/02 20:06:16 millert Exp $";
d180 1
@


1.60
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.59 2003/04/14 19:57:38 cloder Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.59 2003/04/14 19:57:38 cloder Exp $";
d1228 1
a1228 2
pr_addr(a)
	in_addr_t a;
@


1.59
log
@Defer incrementing ntransmitted until we are sure sendto succeeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.58 2003/04/14 10:21:03 itojun Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.58 2003/04/14 10:21:03 itojun Exp $";
@


1.58
log
@permit -s0.  from Maxim Konovalov
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.57 2002/09/06 21:17:39 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.57 2002/09/06 21:17:39 deraadt Exp $";
d596 1
a596 1
	icp->icmp_seq = htons(ntransmitted++);
d637 2
@


1.57
log
@socklen_t and various other minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.56 2002/07/03 09:39:28 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.56 2002/07/03 09:39:28 deraadt Exp $";
d291 1
a291 1
			if (datalen <= 0)
@


1.56
log
@convert to ansi.  suddenly realise that means yet another function is a
signal handler in some cases, and make it cope with the termination race.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.55 2002/06/29 07:56:44 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.55 2002/06/29 07:56:44 deraadt Exp $";
d195 2
a196 1
	int maxsize, maxsizelen, fdmasks;
d398 1
a398 1
		struct ip *ip = (struct ip*)outpackhdr;
d495 2
a496 1
		int fromlen, cc;
d590 1
a590 1
	char *packet = outpack;
d617 1
a617 1
		struct ip *ip = (struct ip*)outpackhdr;
d619 1
a619 1
		packet = (char*)ip;
d728 1
a728 1
			cp = (u_char*)&icp->icmp_data[sizeof(struct tvi)];
d736 1
a736 1
					cp = (u_char*)&icp->icmp_data[0];
@


1.55
log
@IPPROTO_ICMP will not change in our life; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.54 2002/06/22 22:47:45 jakob Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.54 2002/06/22 22:47:45 jakob Exp $";
d172 4
a175 1
void catcher(), prtsig(), finish(), summary(int, int);
d177 1
a177 1
void pinger();
d184 1
a184 1
void usage();
d187 1
a187 3
main(argc, argv)
	int argc;
	char **argv;
d253 2
a254 1
					errx(1, "%s: only root may use interval < 1s", strerror(EPERM));
d485 1
a485 1
		catcher();		/* start things going */
d523 1
a523 1
	finish();
d539 1
a539 1
catcher()
d566 1
a566 1
prtsig()
d583 1
a583 1
pinger()
d645 1
a645 4
pr_pack(buf, cc, from)
	char *buf;
	int cc;
	struct sockaddr_in *from;
d864 1
a864 3
in_cksum(addr, len)
	u_short *addr;
	int len;
d895 1
a895 2
summary(header, sig)
	int header, sig;
d972 1
a972 1
finish()
d977 4
a980 1
	exit(nreceived ? 0 : 1);
d1004 1
a1004 2
pr_icmph(icp)
	struct icmp *icp;
d1199 1
a1199 2
pr_iph(ip)
	struct ip *ip;
d1250 1
a1250 2
pr_retip(ip)
	struct ip *ip;
d1268 1
a1268 2
fill(bp, patp)
	char *bp, *patp;
d1303 1
a1303 2
check_icmph(iph)
	struct ip *iph;
d1329 1
a1329 1
usage()
@


1.54
log
@document -T option, PR#2766. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.53 2002/05/31 04:54:36 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.53 2002/05/31 04:54:36 deraadt Exp $";
a190 1
	struct protoent *proto;
d204 1
a204 3
	if (!(proto = getprotobyname("icmp")))
		errx(1, "unknown protocol icmp");
	if ((s = socket(AF_INET, SOCK_RAW, proto->p_proto)) < 0)
d404 1
a404 1
		ip->ip_p = proto->p_proto;
@


1.53
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.52 2002/05/31 04:53:10 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.52 2002/05/31 04:53:10 deraadt Exp $";
d1342 2
a1343 2
	    "\t[-l preload] [-p pattern] [-s packetsize] [-t ttl]"
	    " [-w maxwait] host\n");
@


1.52
log
@kill the signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.51 2002/05/31 01:11:31 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.51 2002/05/31 01:11:31 itojun Exp $";
d124 1
a124 1
#define	F_HDRINCL       0x400
a168 4
#ifdef SIGINFO
int reset_kerninfo;
#endif

d242 1
a242 1
					     optarg);
d387 2
a388 2
		if (IN_MULTICAST(ntohl(to->sin_addr.s_addr))) 
		    moptions |= MULTICAST_TTL;
d390 1
a390 1
		    options |= F_HDRINCL;
d395 1
a395 1
		     " are incompatible");
d404 1
a404 1
		ip->ip_id = 0;  
d432 1
a432 1
		       sizeof(loop)) < 0)
d436 1
a436 1
		       sizeof(ttl)) < 0)
d440 1
a440 1
		       sizeof(saddr)) < 0)
d443 1
a443 1
	/* 
a493 2
		int cc;
		int fromlen;
d495 1
d542 1
a543 1
	int save_errno = errno;
d625 1
a625 1
		   sizeof(struct sockaddr));
d671 1
a671 1
			  inet_ntoa(*(struct in_addr *)&from->sin_addr.s_addr));
d693 1
a693 1
			
d720 2
a721 2
			   inet_ntoa(*(struct in_addr *)&from->sin_addr.s_addr),
			   ntohs(icp->icmp_seq));
d735 3
a737 2
	(void)printf("\nwrong data byte #%d should be 0x%x but was 0x%x",
	    i, *dp, *cp);
d753 1
a753 1
		hlen2 = ip2->ip_hl << 2; 
d809 4
a812 4
			if (i == old_rrlen
			    && cp == (u_char *)buf + sizeof(struct ip) + 2
			    && !memcmp(cp, old_rr, i)
			    && !(options & F_FLOOD)) {
d1033 2
a1034 2
					ntohs(icp->icmp_nextmtu));
			else 
d1152 2
a1153 2
			(void)printf(
			    "Parameter problem, required option absent: pointer = 0x%02x\n",
d1271 1
a1271 1
			(*cp * 256 + *(cp + 1)), (*(cp + 2) * 256 + *(cp + 3)));
d1305 1
a1305 1
/* 
@


1.51
log
@clarify comment when nreceived > ntransmitted.  from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.50 2002/02/17 02:04:38 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.50 2002/02/17 02:04:38 deraadt Exp $";
d176 1
a176 1
void catcher(), prtsig(), finish(), summary(int);
d576 1
a576 1
	summary(0);
d592 2
a593 2
	int cc;
	int i;
d635 1
a635 1
		(void)printf("ping: wrote %s %d chars, ret=%d\n",
d637 1
d905 2
a906 2
summary(header)
	int header;
d908 3
a910 2
	(void)putchar('\r');
	(void)fflush(stdout);
d912 5
a916 2
	if (header)
		(void)printf("--- %s ping statistics ---\n", hostname);
d918 15
a932 4
	(void)printf("%ld packets transmitted, ", ntransmitted);
	(void)printf("%ld packets received, ", nreceived);
	if (nrepeats)
		(void)printf("%ld duplicates, ", nrepeats);
d935 2
a936 1
			(void)printf("-- somebody's duplicating packets!");
d938 1
a938 1
			(void)printf("%d%% packet loss",
d941 1
d943 1
a943 1
	(void)putchar('\n');
d948 2
a949 1
		(void)printf("round-trip min/avg/max/std-dev = "
d955 1
d957 1
d987 1
a987 1
	summary(1);
@


1.50
log
@correct arithmetic brain damage; maxim@@macomnet.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.49 2002/02/16 21:27:37 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.49 2002/02/16 21:27:37 millert Exp $";
d919 1
a919 1
			(void)printf("-- somebody's printing up packets!");
@


1.49
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.48 2002/01/28 08:08:20 hugh Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.48 2002/01/28 08:08:20 hugh Exp $";
d856 2
a857 2
			hlen = hlen + cp[1] - 1;
			cp = cp + cp[1] - 1;
@


1.48
log
@Request enough buffer space to fit the maximum size of a packet.
Problem noticed by Art, and fix checked by Markus and Niels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.47 2001/11/05 07:39:17 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.47 2001/11/05 07:39:17 mpech Exp $";
d175 1
a175 1
void fill __P((char *, char *));
d177 1
a177 1
int in_cksum __P((u_short *, int));
d179 6
a184 6
char *pr_addr __P((in_addr_t));
int check_icmph __P((struct ip *));
void pr_icmph __P((struct icmp *));
void pr_pack __P((char *, int, struct sockaddr_in *));
void pr_retip __P((struct ip *));
quad_t qsqrt __P((quad_t));
@


1.47
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.46 2001/10/04 07:37:24 jakob Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.46 2001/10/04 07:37:24 jakob Exp $";
d173 1
a173 2
#define DEFAULT_BUFSPACE	60*1024 /* default read buffer size */
int bufspace = DEFAULT_BUFSPACE;
d469 1
a469 1
	if (bufspace < DEFAULT_BUFSPACE)
d471 1
a471 1
		    bufspace, DEFAULT_BUFSPACE);
@


1.46
log
@trim warnx output
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.45 2001/10/03 19:36:49 jakob Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.45 2001/10/03 19:36:49 jakob Exp $";
d198 1
a198 1
	register int i;
d499 1
a499 1
		register int cc;
d592 2
a593 2
	register struct icmp *icp;
	register int cc;
d656 4
a659 4
	register struct icmp *icp;
	register in_addr_t l;
	register u_int i, j;
	register u_char *cp, *dp;
d876 3
a878 3
	register int nleft = len;
	register u_short *w = addr;
	register int sum = 0;
d1262 1
a1262 1
	register int ii, jj, kk;
@


1.45
log
@try to increase receive buffer size, <ft@@pi.se>. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.44 2001/01/12 20:07:05 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.44 2001/01/12 20:07:05 deraadt Exp $";
d471 1
a471 1
		warnx("Could only allocate a receive buffer of %i bytes (default %i)\n",
@


1.44
log
@remove extra + character in status output
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.43 2001/01/11 19:22:09 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.43 2001/01/11 19:22:09 deraadt Exp $";
d173 3
d465 8
a472 1
	(void)setsockopt(s, SOL_SOCKET, SO_RCVBUF, &packlen, sizeof(packlen));
@


1.43
log
@comment on a signal race
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.42 2000/12/21 00:25:17 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.42 2000/12/21 00:25:17 deraadt Exp $";
d907 1
a907 1
		(void)printf("+%ld duplicates, ", nrepeats);
@


1.42
log
@use strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.41 2000/01/22 20:25:04 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.41 2000/01/22 20:25:04 deraadt Exp $";
d560 1
@


1.41
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.40 1999/10/12 18:10:16 hugh Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.40 1999/10/12 18:10:16 hugh Exp $";
d349 1
a349 2
		(void)strncpy(hnamebuf, hp->h_name, sizeof(hnamebuf) - 1);
		hnamebuf[sizeof(hnamebuf) - 1] = '\0';
@


1.40
log
@avoid an infinite loop
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.39 1999/07/18 16:21:55 hugh Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.39 1999/07/18 16:21:55 hugh Exp $";
a189 2
	extern int errno, optind;
	extern char *optarg;
@


1.39
log
@support fine timing interval and calculate std dev
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.38 1999/02/24 21:02:41 kjell Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.38 1999/02/24 21:02:41 kjell Exp $";
d945 1
a945 1
	} while (x - y);
@


1.38
log
@fix default payload alignment error; hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.37 1999/02/23 20:04:37 kjell Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.37 1999/02/23 20:04:37 kjell Exp $";
d158 2
a159 1
int interval = 1;		/* interval between packets */
d167 1
d182 1
d252 3
a254 2
			interval = strtol(optarg, NULL, 0);
			if (interval <= 0)
d256 8
d330 7
d547 1
a547 1
		alarm((u_int)interval);
d694 1
a899 2
	quad_t	i;

d920 5
a924 3
		/* Only display average to milliseconds */
		i = tsum / (nreceived + nrepeats);
		(void)printf("round-trip min/avg/max = %d.%03d/%d.%03d/%d.%03d ms\n",
d926 3
a928 2
		    (int)(i / 1000), (int)(i % 1000),
		    (int)(tmax / 1000), (int)(tmax % 1000));
d930 18
@


1.37
log
@Fix a buffer overrun with very large ICMP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.36 1998/11/18 16:50:05 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.36 1998/11/18 16:50:05 deraadt Exp $";
d346 1
a346 1
		for (i = 8 + sizeof(struct tvi); i < datalen; ++i)
@


1.36
log
@obvious typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.35 1998/05/17 01:46:51 angelos Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.35 1998/05/17 01:46:51 angelos Exp $";
d102 1
a102 1
#define	MAXPACKET	(65536 - 60 - 8)	/* max packet size */
d146 1
a146 1
u_char outpackhdr[MAXPACKET];
d285 1
a285 1
			if (datalen > MAXPACKET)
d1230 1
a1230 1
		    kk <= MAXPACKET - (8 + sizeof(struct tvi) + ii);
@


1.35
log
@Unroll that last patch, Theo thinks there's a better way of solving
the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.34 1998/05/16 05:57:46 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.34 1998/05/16 05:57:46 deraadt Exp $";
d220 1
a220 1
			npackets = strtol(optarg, 0, NULL);
@


1.34
log
@Avoid the SIGALRM/ping DOS attack. From FreeBSD patch by Jason Young.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.33 1998/05/16 05:57:46 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.33 1998/05/16 05:57:46 deraadt Exp $";
a158 1
volatile time_t lasttime;	/* avoid DOS attack that involves SIGALRMs */
a215 2
	lasttime = 0;

a523 19
	time_t timenow;

	if (nreceived) {
		waittime = 2 * tmax / 1000000;
		if (!waittime)
			waittime = 1;
	} else
		waittime = maxwait;

	/*
	 * Die if SIGALRM is caught earlier than it should have been. This
 	 * is usually the result of someone sending thousands of SIGALRMs
 	 * in an attempt to simulate a ping -f (flood).
 	 */

	if (time((time_t *)&timenow) < lasttime + waittime)
	  exit(0);

     	lasttime = timenow;
a525 1

d530 6
a538 1

@


1.33
log
@put time in network byte order. I thought I fixed this!
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.32 1998/05/16 05:52:36 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.32 1998/05/16 05:52:36 deraadt Exp $";
d159 1
d217 2
d527 19
d548 1
a552 6
		if (nreceived) {
			waittime = 2 * tmax / 1000000;
			if (!waittime)
				waittime = 1;
		} else
			waittime = maxwait;
d556 1
@


1.32
log
@on 64 bit architectures, tv_sec and tv_usec cause problems when we
move them onto the wire - so don't put them on the wire. i thought i
fixed this  ages ago..
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.31 1998/04/30 23:34:12 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.31 1998/04/30 23:34:12 deraadt Exp $";
d584 2
a585 2
		tvi.tv_sec = tv.tv_sec;
		tvi.tv_usec = tv.tv_usec;
d669 2
a670 2
			tp.tv_sec = tvi.tv_sec;
			tp.tv_usec = tvi.tv_usec;
@


1.31
log
@certain variables are in msec not usec now
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.30 1998/04/03 11:27:58 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.30 1998/04/03 11:27:58 deraadt Exp $";
d94 6
a99 1
#define	DEFDATALEN	(64 - 8)	/* default data length */
d102 3
a104 3
#define	MAXPACKET	(65536 - 60 - 8)/* max packet size */
#define	MAXWAIT_DEFAULT	10		/* max seconds to wait for response */
#define	NROUTES		9		/* number of record route slots */
d216 1
a216 1
	datap = &outpack[8 + sizeof(struct timeval)];
d340 1
a340 1
	if (datalen >= sizeof(struct timeval))	/* can we time transfer */
d346 1
a346 1
		for (i = 8; i < datalen; ++i)
d579 9
a587 3
	if (timing)
		(void)gettimeofday((struct timeval *)&outpack[8],
		    (struct timezone *)NULL);
d661 2
d668 4
a671 1
			memcpy(&tp, pkttime, sizeof (tp));
d707 3
a709 3
			cp = (u_char*)&icp->icmp_data[sizeof (struct timeval)];
			dp = &outpack[8 + sizeof (struct timeval)];
			for (i = 8 + sizeof(struct timeval); i < datalen;
d1230 1
a1230 1
		    kk <= MAXPACKET - (8 + sizeof(struct timeval) + ii);
@


1.30
log
@handle unknown option too. All this ipoption handling needs rewriting, I now see a whole bunch more flaws
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.29 1998/04/02 20:52:53 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.29 1998/04/02 20:52:53 deraadt Exp $";
d158 3
a160 3
quad_t tmin = 999999999;	/* minimum round trip time in microsec */
quad_t tmax = 0;		/* maximum round trip time in microsec */
quad_t tsum = 0;		/* sum of all times in microsec, for doing average */
d526 1
a526 1
			waittime = 2 * tmax / 1000;
d876 1
a876 1
	if (ntransmitted)
d883 1
d886 1
a886 1
		/* Only display average to microseconds */
@


1.29
log
@do not run off end of option buffer for LSRR either; tqbf
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.28 1998/03/31 23:04:10 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.28 1998/03/31 23:04:10 deraadt Exp $";
d621 1
a621 1
	register u_char *cp,*dp;
d813 2
@


1.28
log
@possible buf oflow in -R; reported by tqbf, fixed by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.27 1998/03/03 19:06:11 provos Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.27 1998/03/03 19:06:11 provos Exp $";
d735 2
a736 1
			if (j > IPOPT_MINOFF)
d744 14
a757 7
				else
					(void)printf("\t%s", pr_addr(ntohl(l)));
				hlen -= 4;
				j -= 4;
				if (j <= IPOPT_MINOFF)
					break;
				(void)putchar('\n');
@


1.27
log
@make ping work for large packet sizes. closing pr# 417.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.26 1998/02/05 04:56:47 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.26 1998/02/05 04:56:47 millert Exp $";
d771 6
a776 2
			old_rrlen = i;
			memcpy(old_rr, cp, i);
d778 1
d790 1
d793 4
@


1.26
log
@Don't count DNS lookup time in ping -R.  Problem noted by
Bill Fenner <fenner@@FreeBSD.ORG>, fix from Theo <deraadt@@openbsd.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.25 1997/08/06 01:45:24 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.25 1997/08/06 01:45:24 deraadt Exp $";
d441 1
a441 3
	hold = 48 * 1024;
	(void)setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&hold,
	    sizeof(hold));
d620 1
a620 1
	register int i, j;
@


1.25
log
@do not clobber errno in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.24 1997/06/29 19:23:07 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.24 1997/06/29 19:23:07 millert Exp $";
d472 1
d492 3
d496 1
@


1.24
log
@Don't assume sizeof(in_addr_t) == 4 and don't coerce an in_addr_t
to struct in_addr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.23 1997/06/23 22:45:53 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.23 1997/06/23 22:45:53 deraadt Exp $";
d515 1
d531 1
d540 2
d543 1
@


1.23
log
@64 bit clean and Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.22 1997/06/11 10:04:24 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.22 1997/06/11 10:04:24 deraadt Exp $";
d1126 2
a1127 2
pr_addr(l)
	in_addr_t l;
d1130 1
d1133 1
d1135 2
a1136 3
	    !(hp = gethostbyaddr((char *)&l, 4, AF_INET)))
		(void)snprintf(buf, sizeof buf, "%s",
		    inet_ntoa(*(struct in_addr *)&l));
d1139 1
a1139 1
		    inet_ntoa(*(struct in_addr *)&l));
@


1.22
log
@dynamic fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.21 1997/06/05 10:02:31 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.21 1997/06/05 10:02:31 deraadt Exp $";
d170 1
a170 1
char *pr_addr __P((u_long));
d611 1
a611 1
	register u_long l;
d619 1
a619 1
	quad_t triptime;
d1127 1
a1127 1
	u_long l;
@


1.21
log
@getpid() is going to be OK in a few minutes
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.20 1997/06/02 08:08:01 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.20 1997/06/02 08:08:01 deraadt Exp $";
d190 2
a191 2
	int ch, fdmask, hold = 1, packlen, preload;
	int maxsize, maxsizelen;
d199 1
d464 4
d477 3
a479 2
			fdmask = 1 << s;
			if (select(s + 1, (fd_set *)&fdmask, (fd_set *)NULL,
d495 1
@


1.20
log
@network byte order for icmp_seq; obfuscate ident (pid) more
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.19 1997/06/01 21:35:55 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.19 1997/06/01 21:35:55 deraadt Exp $";
d343 1
a343 1
	ident = (getpid() & 0x00FF) | (arc4random() & 0xFF00);
@


1.19
log
@i think this solves a number of byte order problems in the icmp code.
If these are right, I also want to note that if a host pings me I can
tell what it's byte order is (because if the seq numbers)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.18 1997/06/01 21:19:08 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.18 1997/06/01 21:19:08 deraadt Exp $";
d343 1
a343 1
	ident = getpid() & 0xFFFF;
d554 1
a554 1
	icp->icmp_seq = ntransmitted++;
d557 1
a557 1
	CLR(icp->icmp_seq % mx_dup_ck);
d650 1
a650 1
		if (TST(icp->icmp_seq % mx_dup_ck)) {
d655 1
a655 1
			SET(icp->icmp_seq % mx_dup_ck);
d667 1
a667 1
			   icp->icmp_seq);
@


1.18
log
@kill fp, fix unterminated buf, add lots of icmp code; denny1@@home.com, PR#205
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.17 1997/05/29 15:55:34 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.17 1997/05/29 15:55:34 kstailey Exp $";
d918 1
a918 1
					icp->icmp_nextmtu);
d993 2
a994 2
		(void)printf("(New addr: 0x%08lx)\n",
		    (u_long)icp->icmp_gwaddr.s_addr);
d1009 1
a1009 1
		    icp->icmp_num_addrs, icp->icmp_lifetime);
d1039 1
a1039 1
			    icp->icmp_hun.ih_pptr);
d1043 1
a1043 1
			    icp->icmp_hun.ih_pptr);
d1075 2
a1076 1
		(void)printf("Address Mask Reply (Mask 0x%04x)\n", icp->icmp_mask);
@


1.17
log
@print stats on SIGINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.16 1997/02/04 16:44:14 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.16 1997/02/04 16:44:14 kstailey Exp $";
d158 3
a160 3
double tmin = 999999999.0;	/* minimum round trip time */
double tmax = 0.0;		/* maximum round trip time */
double tsum = 0.0;		/* sum of all times, for doing average */
d327 1
d612 1
a612 1
	double triptime;
d642 1
a642 2
			triptime = ((double)tv.tv_sec) * 1000.0 +
			    ((double)tv.tv_usec) / 1000.0;
d670 3
a672 1
				(void)printf(" time=%.3f ms", triptime);
d829 1
a829 1
	register int i;
d851 5
a855 3
		i = 1000.0 * tsum / (nreceived + nrepeats);
		(void)printf("round-trip min/avg/max = %.3f/%.3f/%.3f ms\n",
		    tmin, ((double)i) / 1000.0, tmax);
d916 5
a920 1
			(void)printf("frag needed and DF set\n");
d925 21
d949 6
d956 1
a956 1
			(void)printf("Dest Unreachable, Bad Code: %d\n",
d990 1
a990 1
			(void)printf("Redirect, Bad Code: %d", icp->icmp_code);
d1005 10
d1024 1
a1024 1
			(void)printf("Time exceeded, Bad Code: %d\n",
d1035 11
a1045 2
		(void)printf("Parameter problem: pointer = 0x%02x\n",
		    icp->icmp_hun.ih_pptr);
d1075 1
a1075 1
		(void)printf("Address Mask Reply\n");
d1079 1
a1079 1
		(void)printf("Bad ICMP type: %d\n", icp->icmp_type);
@


1.16
log
@Changed ICMP "unreachable" code #defines to match the ones in
tcpdump/print-icmp.c since they were in BSD first.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.15 1997/02/04 14:52:56 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.15 1997/02/04 14:52:56 kstailey Exp $";
d162 4
d167 1
a167 1
void catcher(), finish();
d452 3
d525 9
a822 4
/*
 * finish --
 *	Print out statistics, and give up.
 */
d824 2
a825 1
finish()
d829 1
a829 2
	(void)signal(SIGINT, SIG_IGN);
	(void)putchar('\n');
d831 4
a834 1
	(void)printf("--- %s ping statistics ---\n", hostname);
d853 12
@


1.15
log
@RFC-1812 addtion
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.14 1997/01/30 22:43:14 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.14 1997/01/30 22:43:14 deraadt Exp $";
d890 1
a890 1
		case ICMP_UNREACH_ADM_PROHIB:
@


1.14
log
@deal with IP_HDRINCL option network byte order change; lidl@@va.pubnix.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.13 1997/01/15 23:41:36 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.13 1997/01/15 23:41:36 millert Exp $";
d889 3
@


1.13
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.12 1996/12/22 03:00:52 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.12 1996/12/22 03:00:52 deraadt Exp $";
d380 1
a380 1
		ip->ip_off = (df?IP_DF:0);
d556 1
a556 1
		ip->ip_len = cc;
@


1.12
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.11 1996/12/14 15:35:26 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.11 1996/12/14 15:35:26 deraadt Exp $";
d207 1
a207 1
	while ((ch = getopt(argc, argv, "DI:LRS:c:dfh:i:l:np:qrs:T:t:vw:")) != EOF)
@


1.11
log
@indent correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.10 1996/12/14 02:16:42 bitblt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.10 1996/12/14 02:16:42 bitblt Exp $";
d202 1
@


1.10
log
@Now does not display responses to other peoples stuff, like UDP packets
or other peoples network unreachables when you do a ping -v.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.9 1996/12/10 08:37:06 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.9 1996/12/10 08:37:06 deraadt Exp $";
a608 1

a647 1
 
d678 5
a682 7
                ip2 = (struct ip *) (buf + hlen + sizeof (struct icmp));
                hlen2 = ip2->ip_hl << 2; 
 	        if ((cc >= hlen2 + 8) && check_icmph(
                         (struct ip *)(icp + sizeof (struct icmp))) != 1)
                     return;


a863 2

      
a1102 1

d1112 1
a1112 1
  struct icmp *icmph;
d1114 3
a1116 3
  /* only allow IP version 4 */
  if (iph->ip_v != 4)
    return 0;
d1118 3
a1120 3
  /* Only allow ICMP */
  if (iph->ip_p != IPPROTO_ICMP)
    return 0;
d1122 1
a1122 1
  icmph = (struct icmp *) (iph + (4 * iph->ip_hl));
d1124 3
a1126 3
  /* make sure it is in response to an ECHO request */
  if (icmph->icmp_type != 8)
    return 0;
d1128 3
a1130 3
  /* ok, make sure it has the right id on it */
  if (icmph->icmp_hun.ih_idseq.icd_id != ident)
    return 0;
d1132 1
a1132 1
  return 1;
a1133 1

@


1.9
log
@crank SO_SNDBUF if needed, kml@@nas.nasa.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.8 1996/07/23 10:36:41 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.8 1996/07/23 10:36:41 deraadt Exp $";
d167 1
d591 1
a591 1
	struct ip *ip;
d595 1
a595 1
	int hlen, dupflag;
d609 1
d649 1
d680 7
d868 2
d1108 34
@


1.8
log
@treat -l and -f the same
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.7 1996/07/23 10:31:28 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.7 1996/07/23 10:31:28 deraadt Exp $";
d186 1
d415 11
@


1.7
log
@ptrace is safe; limit preload to root
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.5 1996/07/23 02:30:22 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.5 1996/07/23 02:30:22 deraadt Exp $";
d246 2
a247 2
			if (getuid() != 0)
				errx(1, "must be root to specify preload");
@


1.6
log
@skip until ptrace problem is resolved
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.4 1996/07/22 21:12:23 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.4 1996/07/22 21:12:23 deraadt Exp $";
d185 1
a185 1
	int ch, fdmask, hold, packlen, preload;
d194 8
d246 2
a335 6

	if (!(proto = getprotobyname("icmp")))
		errx(1, "unknown protocol icmp");
	if ((s = socket(AF_INET, SOCK_RAW, proto->p_proto)) < 0)
		err(1, "socket");
	hold = 1;
@


1.5
log
@open socket as soon as possible, and then revoke privs
@
text
@d185 1
a185 1
	int ch, fdmask, hold = 1, packlen, preload;
a193 8
	if (!(proto = getprotobyname("icmp")))
		errx(1, "unknown protocol icmp");
	if ((s = socket(AF_INET, SOCK_RAW, proto->p_proto)) < 0)
		err(1, "socket");

	/* revoke privs */
	setuid(getuid());

d326 6
@


1.4
log
@no overflow; from brian@@saturn.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.3 1996/06/23 14:32:02 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.3 1996/06/23 14:32:02 deraadt Exp $";
d185 1
a185 1
	int ch, fdmask, hold, packlen, preload;
d194 8
a333 6

	if (!(proto = getprotobyname("icmp")))
		errx(1, "unknown protocol icmp");
	if ((s = socket(AF_INET, SOCK_RAW, proto->p_proto)) < 0)
		err(1, "socket");
	hold = 1;
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ping.c,v 1.20 1995/08/11 22:37:58 cgd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ping.c,v 1.20 1995/08/11 22:37:58 cgd Exp $";
d1015 1
a1015 1
	static char buf[80];
d1019 2
a1020 1
		(void)sprintf(buf, "%s", inet_ntoa(*(struct in_addr *)&l));
d1022 1
a1022 1
		(void)sprintf(buf, "%s (%s)", hp->h_name,
@


1.2
log
@let user set TOS, DF bit, and TTL. also use strtol() instead of atoi() so
that other bases work; netbsd pr#2017; jhawk@@mit.edu
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: ping.c,v 1.20 1995/08/11 22:37:58 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d118 2
d140 2
a141 1
u_char outpack[MAXPACKET];
d182 1
a182 1
	struct in_addr ifaddr, saddr;
d187 2
a188 1
	u_char ttl, loop = 1;
d195 1
a195 1
	while ((ch = getopt(argc, argv, "I:LRS:c:dfh:i:l:np:qrs:t:vw:")) != EOF)
d198 1
a198 1
			npackets = atoi(optarg);
d203 4
d217 8
a224 3
			if (inet_aton(optarg, &ifaddr) == 0)
				errx(1, "bad interface address: %s", optarg);
			moptions |= MULTICAST_IF;
d227 1
a227 1
			interval = atoi(optarg);
d237 1
a237 1
			preload = atoi(optarg);
a256 9
		case 'S':
			if (inet_aton(optarg, &saddr) == 0) {
				if ((hp = gethostbyname(optarg)) == NULL)
					errx(1, "bad interface address: %s",
					     optarg);
				memcpy(&saddr, hp->h_addr, sizeof(saddr));
			}
			options |= F_SADDR;
			break;
d258 1
a258 1
			datalen = atoi(optarg);
d264 6
d271 2
a272 1
			ttl = atoi(optarg);
a276 1
			moptions |= MULTICAST_TTL;
d282 1
a282 1
			maxwait = atoi(optarg);
d333 11
a343 6
		memset(&whence, 0, sizeof(whence));
		whence.sin_len = sizeof(whence);
		whence.sin_family = AF_INET;
		memcpy(&whence.sin_addr.s_addr, &saddr, sizeof(saddr));
		if (bind(s, (struct sockaddr*)&whence, sizeof(whence)) < 0)
			err(1, "bind");
d353 26
d381 2
d406 2
a407 2
	    setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &ifaddr,
		       sizeof(ifaddr)) < 0)
d512 1
d532 11
a542 2
	i = sendto(s, (char *)outpack, cc, 0, &whereto,
	    sizeof(struct sockaddr));
d1083 3
a1085 1
	    "usage: ping [-dfLnqRrv] [-c count] [-I ifaddr] [ -S ifaddr ] [-i wait]\n\t[-l preload] [-p pattern] [-s packetsize] [-t ttl] [-w maxwait] host\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

