head	1.10;
access;
symbols
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	98.05.24.13.28.50;	author provos;	state dead;
branches;
next	1.9;

1.9
date	97.09.14.10.37.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.26.22.16.56;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.07.13.23.29.00;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.23.05.15;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.11.23.50.25;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.07.01.22.18.10;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.04.14.10.04.37;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.22.03.48.29;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	97.02.21.23.17.30;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.10
log
@incorporate functionality of rt and rtdelete commands into ipsecadm,
some improvements to manpage, stricter option checking, -Wall.
@
text
@/*
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
 *
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
 *
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/param.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <netns/ns.h>
#include <netiso/iso.h>
#include <netccitt/x25.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>

 
#define INET
#include "net/encap.h"

char buf[2048];

int
main(int argc, char **argv)
{
    struct sockaddr_encap *dst, *msk, *gw;
    struct rt_msghdr *rtm;
    int sd, proto;

    if (argc != 11)
      fprintf(stderr, "usage: %s isrc isrcmask idst idstmask tproto sport dport raddr spi fespah\n", argv[0]), exit(1);
    
    switch(argv[10][0]) {
    case '0':
	 proto = IPPROTO_AH;
	 break;
    case '1':
	 proto = IPPROTO_ESP;
	 break;
    case '-':
	 proto = 0;
	 break;
    case 'p':
	 proto = atoi(argv[10]+1);
	 break;
    default:
	 fprintf(stderr, "flag fespah: wrong value %s\n", argv[10]);
	 exit(-1);
    }	 


    sd = socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC);
    if (sd < 0)
      perror("socket"), exit(1);
	
    rtm = (struct rt_msghdr *)(&buf[0]);
    dst = (struct sockaddr_encap *) (&buf[sizeof (*rtm)]);
    gw = (struct sockaddr_encap *) (&buf[sizeof (*rtm) + SENT_IP4_LEN]);
    msk = (struct sockaddr_encap *) (&buf[sizeof (*rtm) + SENT_IP4_LEN +
					  SENT_IPSP_LEN]);
	
    rtm->rtm_version = RTM_VERSION;
    rtm->rtm_type = RTM_ADD;
    rtm->rtm_index = 0;
    rtm->rtm_pid = getpid();
    rtm->rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK /* | RTA_IFP */;
    rtm->rtm_errno = 0;
    rtm->rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;
    rtm->rtm_inits = 0;
	
    dst->sen_len = SENT_IP4_LEN;
    dst->sen_family = AF_ENCAP;
    dst->sen_type = SENT_IP4;
    dst->sen_ip_src.s_addr = inet_addr(argv[1]);
    dst->sen_ip_dst.s_addr = inet_addr(argv[3]);
    dst->sen_proto = dst->sen_sport = dst->sen_dport = 0;
    
    if (atoi(argv[5]) > 0)
    {
	dst->sen_proto = atoi(argv[5]);
	msk->sen_proto = 0xff;

	if (atoi(argv[6]) > 0)
	{
	    dst->sen_sport = atoi(argv[6]);
	    msk->sen_sport = 0xffff;
	}

	if (atoi(argv[7]) > 0)
	{
	    dst->sen_dport = atoi(argv[7]);
	    msk->sen_dport = 0xffff;
	}
    }

    gw->sen_len = SENT_IPSP_LEN;
    gw->sen_family = AF_ENCAP;
    gw->sen_type = SENT_IPSP;
    gw->sen_ipsp_dst.s_addr = inet_addr(argv[8]);
    gw->sen_ipsp_spi = htonl(strtoul(argv[9], NULL, 16));
    gw->sen_ipsp_sproto = proto;

    msk->sen_len = SENT_IP4_LEN;
    msk->sen_family = AF_ENCAP;
    msk->sen_type = SENT_IP4;
    msk->sen_ip_src.s_addr = inet_addr(argv[2]);
    msk->sen_ip_dst.s_addr = inet_addr(argv[4]);

    rtm->rtm_msglen = sizeof(*rtm) + dst->sen_len + gw->sen_len +
		      msk->sen_len;
	
    if (write(sd, (caddr_t) buf, rtm->rtm_msglen) < 0)
      perror("write");
    exit(0);
}
@


1.9
log
@some -Wall
@
text
@@


1.8
log
@support for noipsec routes. use -1 or p0 at fespah.
@
text
@d55 1
d146 1
@


1.7
log
@Cleanup, made argument order a bit more sane.
@
text
@d59 1
a59 1
    int sd;
d63 20
a82 1
	
d132 1
a132 1
    gw->sen_ipsp_sproto = atoi(argv[10]) == 1 ? IPPROTO_ESP : IPPROTO_AH;
@


1.6
log
@Typo correction.
@
text
@a49 11

#define SENO_EOL        0x00            /* End of Options, or placeholder */
#define SENO_NOP        0x01            /* No Operation. Skip */
#define SENO_NAME       0x02            /* tunnel name, NUL-terminated */
#define SENO_TDB        0x03            /* tunnel descriptor block address */
#define SENO_IFN        0x04            /* Encap interface number */
#define SENO_IFIP4A     0x05            /* Encap interface IPv4 address */
#define SENO_IPSA       0x06            /* Encap interface generic sockaddr */


#define IFT_ENC 0x37
a50 2


a52 8
/*
 * The numbers below are arbitrary. They have been chosen for their
 * mnemonic value. If sen_len is larger than what would be expected from
 * the length of the data that follow, then TLV-triplets follow the 
 * addresses containing system-depended information.
 */


d55 1
a55 3
main(argc, argv)
int argc;
char **argv;
d57 37
a93 1
	int sd;
d95 5
a99 3
	struct rt_msghdr *rtm;
	struct sockaddr_encap *dst, *msk, *gw;
	u_char *opts;
d101 1
a101 29
	if (argc != 11)
	  fprintf(stderr, "usage: %s isrc isrcmask idst idstmask odst spi fespah proto sport dport\n", argv[0]), exit(1);
	
	sd = socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC);
	if (sd < 0)
	  perror("socket"), exit(1);
	
	rtm = (struct rt_msghdr *)(&buf[0]);
	dst = (struct sockaddr_encap *)(&buf[sizeof (*rtm)]);
	gw = (struct sockaddr_encap *)(&buf[sizeof (*rtm) + SENT_IP4_LEN]);
	msk = (struct sockaddr_encap *)(&buf[sizeof (*rtm) + SENT_IP4_LEN + SENT_IPSP_LEN]);
	
	rtm->rtm_version = RTM_VERSION;
	rtm->rtm_type = RTM_ADD;
	rtm->rtm_index = 0;
	rtm->rtm_pid = getpid();
	rtm->rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK /* | RTA_IFP */;
	rtm->rtm_errno = 0;
	rtm->rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;
	rtm->rtm_inits = 0;
	
	dst->sen_len = SENT_IP4_LEN;
	dst->sen_family = AF_ENCAP;
	dst->sen_type = SENT_IP4;
	dst->sen_ip_src.s_addr = inet_addr(argv[1]);
	dst->sen_ip_dst.s_addr = inet_addr(argv[3]);
	dst->sen_proto = dst->sen_sport = dst->sen_dport = 0;

	if (atoi(argv[8]) >= 0)
d103 2
a104 12
		dst->sen_proto = atoi(argv[8]);
		msk->sen_proto = 0xff;
		if (atoi(argv[9]) >= 0)
		{
			dst->sen_sport = atoi(argv[9]);
			msk->sen_sport = 0xffff;
		}
		if (atoi(argv[10]) >= 0)
		{
			dst->sen_dport = atoi(argv[10]);
			msk->sen_dport = 0xffff;
		}
d106 1
d108 12
a119 12
	gw->sen_len = SENT_IPSP_LEN;
	gw->sen_family = AF_ENCAP;
	gw->sen_type = SENT_IPSP;
	gw->sen_ipsp_dst.s_addr = inet_addr(argv[5]);
	gw->sen_ipsp_spi = htonl(strtoul(argv[6], NULL, 16));
	gw->sen_ipsp_sproto = atoi(argv[7]) == 1 ? IPPROTO_ESP : IPPROTO_AH;

	msk->sen_len = SENT_IP4_LEN;
	msk->sen_family = AF_ENCAP;
	msk->sen_type = SENT_IP4;
	msk->sen_ip_src.s_addr = inet_addr(argv[2]);
	msk->sen_ip_dst.s_addr = inet_addr(argv[4]);
d121 2
a122 1
	rtm->rtm_msglen = sizeof (*rtm) + dst->sen_len + gw->sen_len + msk->sen_len;
d124 2
a125 2
	if (write(sd, (caddr_t)buf, rtm->rtm_msglen) < 0)
	  perror("write");
a126 3

	
	
@


1.5
log
@reflect changes in kernel ipsec
@
text
@d116 1
a116 1
		dst->sen_proto = atoi(argv[7]);
@


1.4
log
@reflect changes in ipsec
@
text
@d86 2
a87 2
	if (argc != 10)
	  fprintf(stderr, "usage: %s isrc isrcmask idst idstmask odst spi proto sport dport\n", argv[0]), exit(1);
d114 1
a114 1
	if (atoi(argv[7]) >= 0)
d118 1
a118 1
		if (atoi(argv[8]) >= 0)
d120 1
a120 1
			dst->sen_sport = atoi(argv[8]);
d123 1
a123 1
		if (atoi(argv[9]) >= 0)
d125 1
a125 1
			dst->sen_dport = atoi(argv[9]);
d135 1
@


1.3
log
@strtol to strtoul
@
text
@a83 1
	struct sockaddr_dl *dl;
d86 2
a87 2
	if (argc != 12)
	  fprintf(stderr, "usage: %s isrc isrcmask idst idstmask osrc odst spi if proto sport dport\n", argv[0]), exit(1);
a95 1
/*	opts = (u_char *)(&buf[sizeof (*rtm) + 2*SENT_IP4_LEN]); */
a96 1
/*	dl = (struct sockaddr_dl *)(&buf[sizeof (*rtm) + 3*SENT_IP4_LEN + 12]); */
d114 1
a114 1
	if (atoi(argv[9]) >= 0)
d116 1
a116 1
		dst->sen_proto = atoi(argv[9]);
d118 1
a118 1
		if (atoi(argv[10]) >= 0)
d120 1
a120 1
			dst->sen_sport = atoi(argv[10]);
d123 1
a123 1
		if (atoi(argv[11]) >= 0)
d125 1
a125 1
			dst->sen_dport = atoi(argv[11]);
d133 2
a134 4
	gw->sen_ipsp_src.s_addr = inet_addr(argv[5]);
	gw->sen_ipsp_dst.s_addr = inet_addr(argv[6]);
	gw->sen_ipsp_spi = htonl(strtoul(argv[7], NULL, 16));
	gw->sen_ipsp_ifn = atoi(argv[8]);
a135 14
/*
	opts[0] = SENO_IFN;
	opts[1] = 3;
	opts[2] = 2;
	opts[3] = SENO_NOP;
	opts[4] = SENO_NOP;
	opts[5] = SENO_NOP;
	opts[6] = SENO_SPI;
	opts[7] = 4;
	opts[8] = 0x12;
	opts[9] = 0x34;
	opts[10] = 0x56;
	opts[11] = 0x78;
*/
d142 1
a142 15
/*
	dl->sdl_len = 12;
	dl->sdl_family = AF_DLI;
	dl->sdl_index = 0;
	dl->sdl_type = IFT_ENC;
	dl->sdl_nlen = 4;
	dl->sdl_alen = 0;
	dl->sdl_slen = 0;
	dl->sdl_data[0] = 'e';
	dl->sdl_data[1] = 'n';
	dl->sdl_data[2] = 'c';
	dl->sdl_data[3] = '2';
*/

	rtm->rtm_msglen = sizeof (*rtm) + dst->sen_len + gw->sen_len + msk->sen_len /* + dl->sdl_len */ ;
@


1.2
log
@Amended the copyleft.
@
text
@d138 1
a138 1
	gw->sen_ipsp_spi = htonl(strtol(argv[7], NULL, 16));
@


1.1
log
@Integration of IPSEC userland tools, no manpages yet, sorry.
@
text
@d7 1
a7 1
 * Ported to NetBSD, with additional transforms, in December 1996,
@
