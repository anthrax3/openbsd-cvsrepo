head	1.7;
access;
symbols
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	photurisd100:1.1.1.1
	photuris:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	98.11.14.23.37.06;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	98.06.30.16.58.45;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	98.03.04.11.43.14;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.09.02.17.26.35;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.07.24.23.47.08;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.07.23.12.28.46;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.22.48.48;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.07.18.22.48.48;	author provos;	state Exp;
branches;
next	;


desc
@@


1.7
log
@move ipsec tools into .
@
text
@/*
 * Copyright 1997,1998 Niels Provos <provos@@physnet.uni-hamburg.de>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * compute_secrets.c:
 * shared secret with diffie-hellman key exchange
 * cryptographic hashes for session keys
 */

#ifndef lint 
static char rcsid[] = "$Id: compute_secrets.c,v 1.6 1998/06/30 16:58:45 provos Exp $"; 
#endif 

#define _SECRETS_C_

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <arpa/inet.h> 
#include <gmp.h>
#include <md5.h>
#include "state.h"
#include <sha1.h>
#include "config.h"
#include "identity.h"
#include "attributes.h"
#include "modulus.h"
#include "secrets.h"
#include "buffer.h"
#include "spi.h"
#include "exchange.h"
#include "scheme.h"
#include "errlog.h"

int privacykey(struct stateob *st, struct idxform *hash, u_int8_t *key, 
	       u_int8_t *packet, u_int16_t bytes, u_int16_t *order, int owner);
int
compute_shared_secret(struct stateob *st, 
		      u_int8_t **shared, u_int16_t *sharedsize)
{
     struct moduli_cache *mod;
     int header;

     mpz_t tmp, bits, tex;

     mpz_init(tmp);
     mpz_init(bits);

     if((mod=mod_find_modgen(st->modulus, st->generator)) == NULL) {
	  log_error(0, "Can't find exchange information in cache in compute_shared_secret()");
	  return -1;
     }

     /* Compute Diffie-Hellmann a^(xy) (mod n) */

     mpz_init_set_varpre(tex, st->texchange);
     mpz_powm(tmp, tex, mod->private_value, mod->modulus);

     mpz_clear(tex);

     varpre_get_number_bits(bits, scheme_get_mod(st->scheme));

     *sharedsize = BUFFER_SIZE;
     if(mpz_to_varpre(buffer, sharedsize, tmp, bits) == -1)   
          return -1;
     mpz_clear(bits);
     mpz_clear(tmp);

     /* The shared secret is not used with the size part */
     if (buffer[0] == 255 && buffer[1] == 255)
	  header = 8;
     else if (buffer[0] == 255)
	  header = 4;
     else
	  header = 2;

     *sharedsize -= header;

     if((*shared = calloc(*sharedsize,sizeof(u_int8_t))) == NULL) {
          log_error(0, "Not enough memory for shared secret in compute_shared_secret()");
          return -1;
     }
     bcopy(buffer+header, *shared, *sharedsize);
     return 0;
}

/*
 * Generate session keys for all attributes in given SPI.
 */

int
make_session_keys(struct stateob *st, struct spiob *spi)
{
     u_int8_t *p, *attributes, **secret;
     u_int16_t attribsize, *secretsize;
     u_int16_t i, count = 0;
     int bits;

     attributes = spi->attributes;
     attribsize = spi->attribsize;
     secret = &(spi->sessionkey);
     secretsize = &(spi->sessionkeysize);

     if (*secret != NULL)
	  return 0;           /* Already calculated */

     p = attributes;
     for (i = 0; i<attribsize; i += p[i+1] + 2) {
	  if (p[i] != AT_AH_ATTRIB && p[i] != AT_ESP_ATTRIB) {
	       bits = get_session_key_length(p+i);
	       if (bits == -1) {
		    log_error(0, "Invalid attribute choice for SPI in make_session_keys()");
		    return -1;
	       }
	       count += bits & 7 ? (bits >> 3) + 1 : bits >> 3;
	  }
     }
     if ((*secret = calloc(count, sizeof(u_int8_t))) == NULL) {
	  log_error(1, "calloc() in make_session_keys()");
	  return -1;
     }
     *secretsize = count;

     count = 0;
     p = *secret;
     for (i = 0; i<attribsize; i += attributes[i+1] + 2) {
	  if (attributes[i] != AT_AH_ATTRIB && 
	      attributes[i] != AT_ESP_ATTRIB) {
	       bits = compute_session_key(st, p, attributes+i, 
					  spi->flags & SPI_OWNER, 
					  &count);
	       if (bits == -1)
		    return -1;
	       if (bits > 0) {
#ifdef DEBUG
		    { 
			 int d = BUFFER_SIZE;
			 printf("%s session key for AT %d: ", 
				spi->flags & SPI_OWNER ? 
				"Owner" : "User", (int)attributes[i]);
			 bin2hex(buffer, &d, p, 
				 bits & 7 ? (bits >> 3) + 1 : bits >> 3);
			 printf("0x%s\n", buffer);
		    }
#endif /* DEBUG */
		    
		    p += bits & 7 ? (bits >> 3) + 1 : bits >> 3;
	       }
	  }
     }
     
     return 0;
}

/*
 * Return length of requried session key in bits. 
 * DES would be 64 bits.
 */

int
get_session_key_length(u_int8_t *attribute)
{
     attrib_t *ob;

     if ((ob = getattrib(*attribute)) == NULL) {
	  log_error(0, "Unknown attribute %d in get_session_key_length()", 
		    *attribute);
	  return -1;
     }

     return ob->klen << 3;
}

/*
 * Compute session keys for the attributes in the security association.
 * owner determines the direction of the spi session key.
 * order is the amount of bits we already used for other session keys.
 */

int
compute_session_key(struct stateob *st, u_int8_t *key, 
		    u_int8_t *attribute, int owner,
		    u_int16_t *order)
{
     struct idxform *hash;
     u_int16_t size, i, n;
     u_int8_t digest[HASH_MAX];
     int bits;

     switch(ntohs(*((u_int16_t *)st->scheme))) {
     case DH_G_2_MD5: 
     case DH_G_3_MD5:  
     case DH_G_2_DES_MD5:  
     case DH_G_5_MD5:  
     case DH_G_3_DES_MD5:  
     case DH_G_5_DES_MD5:  
     case DH_G_VAR_MD5: 
     case DH_G_VAR_DES_MD5: 
	  hash = get_hash(HASH_MD5);
	  break;
     case DH_G_2_3DES_SHA1:  
     case DH_G_3_3DES_SHA1:  
     case DH_G_5_3DES_SHA1:
     case DH_G_VAR_3DES_SHA1: 
	  hash = get_hash(HASH_SHA1);
	  break;
     default:
	  log_error(0, "Unkown scheme %d in compute_session_key()",
		    ntohs(*((u_int16_t *)st->scheme)));
	  return -1;
     }	  
	  

     if ((bits = get_session_key_length(attribute)) == -1)
	  return -1;
     if (bits == 0)
	  return 0;

     size = bits >> 3;
     if(bits & 0x7)
	  size++;

     /* As many shared secrets we used already */
     n = *order;

     hash->Init(hash->ctx);
     hash->Update(hash->ctx, st->icookie, COOKIE_SIZE);
     hash->Update(hash->ctx, st->rcookie, COOKIE_SIZE);
     if(owner) { /* Session key for Owner SPI */
	  hash->Update(hash->ctx,st->oSPIsecret,st->oSPIsecretsize);
	  hash->Update(hash->ctx,st->uSPIsecret,st->uSPIsecretsize);
     } else {    /* Session key for User SPI */
	  hash->Update(hash->ctx,st->uSPIsecret,st->uSPIsecretsize); 
	  hash->Update(hash->ctx,st->oSPIsecret,st->oSPIsecretsize); 
     }

     /* Message Verification field */
     hash->Update(hash->ctx, st->verification, st->versize);

     for (i=0; i<n; i++)
	  hash->Update(hash->ctx, st->shared, st->sharedsize);

     do {
	  bcopy(hash->ctx, hash->ctx2, hash->ctxsize);
	  hash->Update(hash->ctx2,st->shared, st->sharedsize);
	  bcopy(hash->ctx2, hash->ctx, hash->ctxsize);

	  hash->Final(digest, hash->ctx2);
	  /* One iteration more */
	  n++;

	  bcopy(digest, key, size>hash->hashsize ? hash->hashsize : size);
	  key += size>hash->hashsize ? hash->hashsize : size;

	  /* Unsigned integer arithmetic */
	  size -= size>hash->hashsize ? hash->hashsize : size;
     } while(size > 0);  
     
     *order = n;

     return bits;
}

/*
 * Initializes the hash contexts for privacy key computation.
 */

int
init_privacy_key(struct stateob *st, int owner)
{
     void **ctx;
     struct idxform *hash;
     u_int8_t *first, *second;
     u_int16_t firstsize, secondsize;

     if (owner) {
	  ctx = &st->oSPIprivacyctx;
	  first = st->exchangevalue;
	  firstsize = st->exchangesize;
	  second = st->texchange;
	  secondsize = st->texchangesize;
     } else {
	  ctx = &st->uSPIprivacyctx;
	  first = st->texchange;
	  firstsize = st->texchangesize;
	  second = st->exchangevalue;
	  secondsize = st->exchangesize;
     }

     switch(ntohs(*((u_int16_t *)st->scheme))) {  
     case DH_G_2_MD5:  
     case DH_G_3_MD5:  
     case DH_G_5_MD5:  
     case DH_G_2_DES_MD5:  
     case DH_G_3_DES_MD5:  
     case DH_G_5_DES_MD5: 
	  hash = get_hash(HASH_MD5);
	  break;
     case DH_G_2_3DES_SHA1:  
     case DH_G_3_3DES_SHA1:  
     case DH_G_5_3DES_SHA1:  
	  hash = get_hash(HASH_SHA1);
	  break;
     default:  
          log_error(0, "Unknown exchange scheme in init_privacy_key()");
          return -1;  
     }  

     if (hash == NULL)
	  return -1;

     if (*ctx != NULL)
	  free(*ctx);

     if ((*ctx = calloc(hash->ctxsize, sizeof(char))) == NULL) {
	  log_error(1, "calloc() in init_privacy_key()");
	  return -1;
     }
     hash->Init(*ctx);
     hash->Update(*ctx, first, firstsize);
     hash->Update(*ctx, second, secondsize);
     return 1;
}

/*
 * order gives the number of iterations already done for keys
 */

int
compute_privacy_key(struct stateob *st, u_int8_t *key, u_int8_t *packet,
		    u_int16_t bits, u_int16_t *order, int owner)
{
     u_int16_t size;
     struct idxform *hash;

     size = bits >> 3; 
     if(bits & 0x7) 
          size++; 

     switch(ntohs(*((u_int16_t *)st->scheme))) {  
     case DH_G_2_MD5:  
     case DH_G_3_MD5:  
     case DH_G_5_MD5:  
     case DH_G_2_DES_MD5:  
     case DH_G_3_DES_MD5:  
     case DH_G_5_DES_MD5:  
	  hash = get_hash(HASH_MD5);
	  break;
     case DH_G_2_3DES_SHA1:  
     case DH_G_3_3DES_SHA1:  
     case DH_G_5_3DES_SHA1:  
	  hash = get_hash(HASH_SHA1);
	  break;
     default:  
          log_error(0, "Unknown exchange scheme in compute_privacy_key()");
          return -1;  
     }  

     if (hash == NULL)
	  return -1;

     return privacykey(st, hash, key, packet, size, order, owner);
}


int
privacykey(struct stateob *st, struct idxform *hash, 
	   u_int8_t *key, u_int8_t *packet, 
	   u_int16_t bytes, u_int16_t *order, int owner) 
{
     u_int16_t i, n;
     u_int8_t digest[HASH_MAX];
     
     /* SPIprivacyctx contains the hashed exchangevalues */
     bcopy(owner ? st->oSPIprivacyctx : st->uSPIprivacyctx, 
	   hash->ctx2, hash->ctxsize);
	  
     hash->Update(hash->ctx2, packet, 2*COOKIE_SIZE + 4 + SPI_SIZE); 
     
     /* As many shared secrets we used already */ 
     n = *order;
     for(i=0; i<n; i++) 
	  hash->Update(hash->ctx2, st->shared, st->sharedsize); 

     do {
	  bcopy(hash->ctx2, hash->ctx, hash->ctxsize);
	  hash->Update(hash->ctx, st->shared, st->sharedsize);
	  bcopy(hash->ctx, hash->ctx2, hash->ctxsize);
	  
	  hash->Final(digest, hash->ctx);
          bcopy(digest, key, bytes>hash->hashsize ? hash->hashsize : bytes); 
	  key += bytes>hash->hashsize ? hash->hashsize : bytes;
 
	  /* Unsigned integer arithmetic */ 
          bytes -= bytes>hash->hashsize ? hash->hashsize : bytes; 
	  
	  /* Increment the times we called Final */
	  i++;
     } while(bytes > 0);   

     *order = i;
     return 0;
}

@


1.6
log
@- support HMAC flag which if present in the attribute list toggles to
HMAC authentication transforms and otherwise to simple keyed authentication.
Note, HMAC is necessary if new esp is to use integrity checking, i.e.
authentication of the payload.
- Also fix bug, where SPIs were reserved for more than one protocol when
only one protocol, e.g. ESP or AH, could be agreed upon.
- Also make kernel.c a bit less complex, I hope.
- return notifies to kernel on failure only when kernel started the keying.
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.5 1998/03/04 11:43:14 provos Exp $"; 
@


1.5
log
@compliance with draft-simpson-photuris-18.txt, better packet structure
checking, better support for new esp and ah, documentation ...
@
text
@d2 1
a2 1
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.4 1997/09/02 17:26:35 provos Exp $"; 
d163 1
d165 9
a173 8
	       {    int d = BUFFER_SIZE;
		    printf("%s session key for AT %d: ", 
			   spi->flags & SPI_OWNER ? 
			   "Owner" : "User", (int)attributes[i]);
		    bin2hex(buffer, &d, p, 
			    bits & 7 ? (bits >> 3) + 1 : bits >> 3);
		    printf("0x%s\n", buffer);
	       }
d176 2
a177 1
	       p += bits & 7 ? (bits >> 3) + 1 : bits >> 3;
d245 2
@


1.4
log
@including changes between drafts-14-16.
update cookie and counters correctly after receiving a resource limit
message.
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.3 1997/07/24 23:47:08 provos Exp $"; 
d65 1
a65 1
	       u_int8_t *packet, u_int16_t bytes, u_int16_t order, int owner);
d71 1
d98 10
d112 1
a112 1
     bcopy(buffer, *shared, *sharedsize);
d181 4
d189 3
a191 6
     switch(*attribute) {
     case AT_MD5_KDP:
	  return MD5_KEYLEN;
     case AT_DES_CBC:
	  return DES_KEYLEN;
     default:
d196 2
d214 1
a214 1
     int bits, hbits;
a246 3
     hbits = (hash->hashsize << 3);
     *order += (*order%hbits) ? hbits - (*order%hbits) : 0;

d248 1
a248 1
     n = *order/hbits;
d273 3
d283 1
a283 1
     *order += bits + (bits%hbits ? hbits - (bits%hbits) : 0 );
d350 1
a350 1
 * order gives the number of bits already used for keys
d355 1
a355 1
		    u_int16_t bits, u_int16_t order, int owner)
d393 1
a393 1
	   u_int16_t bytes, u_int16_t order, int owner) 
d395 1
a395 1
     u_int16_t i, n, hbits;
d405 1
a405 2
     hbits = (hash->hashsize << 3);
     n = order/hbits + (order%hbits ? 1 : 0); 
d420 3
d425 1
@


1.3
log
@new symmetric identity choice. fix bug with expired exchange values on
multiple exchanges. a bit more documentation. drop -f flag and have -c
with opposite meaning instead. include responder offered schemes into
responder cookie calculation.
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.2 1997/07/23 12:28:46 provos Exp $"; 
d54 1
d64 2
a65 6
int MD5privacykey(struct stateob *st, u_int8_t *key, u_int8_t *packet,
		  u_int16_t bytes, u_int16_t order, int owner);
int SHA1privacykey(struct stateob *st, u_int8_t *key, u_int8_t *packet,
		   u_int16_t bytes, u_int16_t order, int owner);


d193 1
a193 1
compute_session_key(struct stateob *st, u_int8_t *key,
d197 28
a224 4
     u_int16_t size, i,n;
     u_int8_t digest[16];
     int bits;
     MD5_CTX ctx;
d233 2
a234 2
     /* XXX - we only do md5 at the moment */
     *order = (*order^(*order&0x7f)) + (*order & 0x7f ? 128 : 0);
d237 18
a254 1
     n = *order >> 7;
d257 7
a263 18
	  MD5Init(&ctx);
	  MD5Update(&ctx, st->icookie, COOKIE_SIZE);
	  MD5Update(&ctx, st->rcookie, COOKIE_SIZE);
	  if(owner) { /* Session key for Owner SPI */
	       MD5Update(&ctx,st->oSPIsecret,st->oSPIsecretsize);
	       MD5Update(&ctx,st->uSPIsecret,st->uSPIsecretsize);
	       MD5Update(&ctx,st->oSPIidentver, st->oSPIidentversize);
	  } else {    /* Session key for User SPI */
               MD5Update(&ctx,st->uSPIsecret,st->uSPIsecretsize); 
               MD5Update(&ctx,st->oSPIsecret,st->oSPIsecretsize); 
               MD5Update(&ctx,st->uSPIidentver, st->uSPIidentversize); 
	  }
	  for(i=0; i<n; i++)
	       MD5Update(&ctx,st->shared, st->sharedsize);
	  n++;
	  MD5Final(digest, &ctx);
	  bcopy(digest, key, size>16 ? 16 : size);
	  key += size>16 ? 16 : size;
d266 1
a266 1
	  size -= size>16 ? 16 : size;
d269 1
a269 1
     *order += (bits^(bits&0x7f)) + (bits & 0x7f ? 128 : 0);
d275 61
d344 1
d357 2
a358 1
	  return MD5privacykey(st, key, packet, size, order, owner);
d362 2
a363 1
	  return SHA1privacykey(st, key, packet, size, order, owner);
d368 5
d377 3
a379 2
MD5privacykey(struct stateob *st, u_int8_t *key, u_int8_t *packet, 
	      u_int16_t bytes, u_int16_t order, int owner) 
d381 2
a382 3
     MD5_CTX ctx, ctxb; 
     u_int16_t i, n;
     u_int8_t digest[16];
d384 3
a386 1
     MD5Init(&ctxb); 
d388 1
a388 9
     MD5Update(&ctxb, packet, 2*COOKIE_SIZE + 4 + SPI_SIZE); 
     
     if (owner) {
	  MD5Update(&ctxb, st->exchangevalue, st->exchangesize);   
	  MD5Update(&ctxb, st->texchange, st->texchangesize);   
     } else {
	  MD5Update(&ctxb, st->texchange, st->texchangesize);    
	  MD5Update(&ctxb, st->exchangevalue, st->exchangesize);    
     }
d391 2
a392 1
     n = order&0x7f ? (order >> 7) + 1 : order >> 7; 
d394 1
a394 1
	  MD5Update(&ctxb, st->shared, st->sharedsize); 
d397 3
a399 3
	  ctx = ctxb;
	  MD5Update(&ctx, st->shared, st->sharedsize);
	  ctxb = ctx;
d401 3
a403 3
	  MD5Final(digest, &ctx);
          bcopy(digest, key, bytes>16 ? 16 : bytes); 
	  key += bytes>16 ? 16 : bytes;
d406 2
a407 2
          bytes -= bytes>16 ? 16 : bytes; 
     } while(bytes>=16);   
a411 44
int
SHA1privacykey(struct stateob *st, u_int8_t *key, u_int8_t *packet,
	      u_int16_t bytes, u_int16_t order, int owner) 
{
     SHA1_CTX ctx, ctxb; 
     u_int16_t i, n; 
     u_int8_t digest[20];

     SHA1Init(&ctxb); 
     
     SHA1Update(&ctxb, packet, 2*COOKIE_SIZE + 4 + SPI_SIZE);  
	  
     if (owner) {
	  SHA1Update(&ctxb, st->exchangevalue, st->exchangesize);   
	  SHA1Update(&ctxb, st->texchange, st->texchangesize);   
     } else {
	  SHA1Update(&ctxb, st->texchange, st->texchangesize);    
	  SHA1Update(&ctxb, st->exchangevalue, st->exchangesize);    
     }


     /* As many shared secrets we used already */ 
     n = order%160 ? order/160+1 : order/160; 
     for (i=0; i<n; i++)
	  SHA1Update(&ctxb, st->shared, st->sharedsize);

     do {

	  ctx = ctxb;
	  SHA1Update(&ctx, st->shared, st->sharedsize); 
	  ctxb = ctx;

	  SHA1Final(digest, &ctx);

          bcopy(digest, key, bytes>20 ? 20 : bytes); 

	  key += bytes>20 ? 20 : bytes;
 
          /* Unsigned integer arithmetic */ 
          bytes -= bytes>20 ? 20 : bytes; 
     } while(bytes>0);   

     return 0;
}
@


1.2
log
@tunnel,lifetimes,hostname via startkey/startup
errors to stderr before daemon, to syslog afterwards
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.1.1.1 1997/07/18 22:48:48 provos Exp $"; 
a285 1
     struct moduli_cache *mod; 
a291 3
     if((mod=mod_find_modgen(st->modulus,st->generator)) == NULL)
	  return -1;

d293 1
a293 1
	  MD5Update(&ctxb, mod->exchangevalue, mod->exchangesize);   
d297 1
a297 1
	  MD5Update(&ctxb, mod->exchangevalue, mod->exchangesize);    
a326 1
     struct moduli_cache *mod; 
a332 3
     if((mod=mod_find_modgen(st->modulus,st->generator)) == NULL)
	       return -1;

d334 1
a334 1
	  SHA1Update(&ctxb, mod->exchangevalue, mod->exchangesize);   
d338 1
a338 1
	  SHA1Update(&ctxb, mod->exchangevalue, mod->exchangesize);    
@


1.1
log
@Initial revision
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: compute_secrets.c,v 1.3 1997/06/12 17:09:20 provos Exp provos $"; 
d150 2
a151 1
	       bits = compute_session_key(st, p, attributes+i, spi->owner, 
d158 2
a159 1
			   spi->owner ? "Owner" : "User", (int)attributes[i]);
@


1.1.1.1
log
@initial import of the photuris keymanagement daemon
@
text
@@

