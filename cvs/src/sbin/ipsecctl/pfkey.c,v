head	1.60;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.12
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.10
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.6
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.4
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.6
	OPENBSD_5_0:1.51.0.4
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.49.0.8
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.4
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.6
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.2
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.48.0.6
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.4
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23;
locks; strict;
comment	@ * @;


1.60
date	2017.04.19.15.59.38;	author bluhm;	state Exp;
branches;
next	1.59;
commitid	CiHS8CSu2u0AMgvM;

1.59
date	2017.04.18.02.29.56;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	0b2VaK4OUJUaWS29;

1.58
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.57;
commitid	rmbXKt3efXwOBuCw;

1.57
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	82PdNqu2kKAuXPfA;

1.56
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.55;
commitid	CLwtYUTkBZ3FXV1w;

1.55
date	2015.10.18.02.30.53;	author mmcc;	state Exp;
branches;
next	1.54;
commitid	223tdQ7wDT4xpRu0;

1.54
date	2014.11.03.03.22.22;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	rN87Gb7tm807pJtA;

1.53
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.52;

1.52
date	2012.03.24.15.39.54;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.22.14.04.09;	author mikeb;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.22.17.00.37;	author hshoexer;	state Exp;
branches;
next	1.48;

1.48
date	2007.03.16.20.51.01;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.10.14.47.52;	author hshoexer;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.30.18.02.20;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.08.22.34.30;	author hshoexer;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.01.22.29.19;	author hshoexer;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.01.17.32.20;	author naddy;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.01.12.19.59;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.01.06.20.30;	author todd;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.31.05.38.45;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.30.21.56.05;	author msf;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.28.21.08.42;	author hshoexer;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.28.20.58.24;	author todd;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.19.16.10.50;	author hshoexer;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.31.13.13.51;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.30.12.44.20;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.07.00.30.28;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.06.14.27.57;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.24.11.52.07;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.12.16.41.39;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.12.12.00.53;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.06.22.51.51;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.06.10.52.27;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.30.19.50.24;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.17.07.31.44;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.16.19.52.19;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.22.17.26.46;	author hshoexer;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.12.37.45;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.08.14.19.16;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.09.15.09;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.05.14.39.02;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.03.15.27.01;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.02.15.47.25;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.09.21.31.24;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.09.21.17.46;	author hshoexer;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.09.21.05.02;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.07.22.00.36;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.07.21.13.00;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.07.20.58.28;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.30.18.50.55;	author hshoexer;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.30.18.27.14;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.27.19.55.21;	author hshoexer;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.27.19.15.44;	author hshoexer;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.27.15.36.02;	author hshoexer;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.25.17.23.46;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.25.17.21.27;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.25.17.10.26;	author hshoexer;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.04.22.22.55;	author hshoexer;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.04.22.19.50;	author hshoexer;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Rename all SA groups to bundles consistently.  The first kernel
commit in 2000 that introduced the features already called them SA
bundles.  The word group is taken by Diffie-Hellman, reusing it
causes confusion.
OK hshoexer@@
@
text
@/*	$OpenBSD: pfkey.c,v 1.59 2017/04/18 02:29:56 deraadt Exp $	*/
/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2003, 2004 Markus Friedl <markus@@openbsd.org>
 * Copyright (c) 2004, 2005 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <poll.h>
#include <unistd.h>

#include "ipsecctl.h"
#include "pfkey.h"

#define ROUNDUP(x) (((x) + (PFKEYV2_CHUNK - 1)) & ~(PFKEYV2_CHUNK - 1))
#define IOV_CNT 20

static int	fd;
static u_int32_t sadb_msg_seq = 1;

static int	pfkey_flow(int, u_int8_t, u_int8_t, u_int8_t, u_int8_t,
		    struct ipsec_addr_wrap *, u_int16_t,
		    struct ipsec_addr_wrap *, u_int16_t,
		    struct ipsec_addr_wrap *, struct ipsec_addr_wrap *,
		    struct ipsec_auth *, u_int8_t);
static int	pfkey_sa(int, u_int8_t, u_int8_t, u_int32_t,
		    struct ipsec_addr_wrap *, struct ipsec_addr_wrap *,
		    struct ipsec_transforms *, struct ipsec_key *,
		    struct ipsec_key *, u_int8_t);
static int	pfkey_sabundle(int, u_int8_t, u_int8_t, u_int8_t,
		    struct ipsec_addr_wrap *, u_int32_t,
		    struct ipsec_addr_wrap *, u_int32_t);
static int	pfkey_reply(int, u_int8_t **, ssize_t *);
int		pfkey_parse(struct sadb_msg *, struct ipsec_rule *);
int		pfkey_ipsec_flush(void);
int		pfkey_ipsec_establish(int, struct ipsec_rule *);
int		pfkey_init(void);

static int
pfkey_flow(int sd, u_int8_t satype, u_int8_t action, u_int8_t direction,
    u_int8_t proto, struct ipsec_addr_wrap *src, u_int16_t sport,
    struct ipsec_addr_wrap *dst, u_int16_t dport,
    struct ipsec_addr_wrap *local, struct ipsec_addr_wrap *peer,
    struct ipsec_auth *auth, u_int8_t flowtype)
{
	struct sadb_msg		 smsg;
	struct sadb_address	 sa_src, sa_dst, sa_local, sa_peer, sa_smask,
				 sa_dmask;
	struct sadb_protocol	 sa_flowtype, sa_protocol;
	struct sadb_ident	*sa_srcid, *sa_dstid;
	struct sockaddr_storage	 ssrc, sdst, slocal, speer, smask, dmask;
	struct iovec		 iov[IOV_CNT];
	ssize_t			 n;
	int			 iov_cnt, len, ret = 0;

	sa_srcid = sa_dstid = NULL;

	bzero(&ssrc, sizeof(ssrc));
	bzero(&smask, sizeof(smask));
	ssrc.ss_family = smask.ss_family = src->af;
	switch (src->af) {
	case AF_INET:
		((struct sockaddr_in *)&ssrc)->sin_addr = src->address.v4;
		ssrc.ss_len = sizeof(struct sockaddr_in);
		((struct sockaddr_in *)&smask)->sin_addr = src->mask.v4;
		if (sport) {
			((struct sockaddr_in *)&ssrc)->sin_port = sport;
			((struct sockaddr_in *)&smask)->sin_port = 0xffff;
		}
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&ssrc)->sin6_addr = src->address.v6;
		ssrc.ss_len = sizeof(struct sockaddr_in6);
		((struct sockaddr_in6 *)&smask)->sin6_addr = src->mask.v6;
		if (sport) {
			((struct sockaddr_in6 *)&ssrc)->sin6_port = sport;
			((struct sockaddr_in6 *)&smask)->sin6_port = 0xffff;
		}
		break;
	default:
		warnx("unsupported address family %d", src->af);
		return -1;
	}
	smask.ss_len = ssrc.ss_len;

	bzero(&sdst, sizeof(sdst));
	bzero(&dmask, sizeof(dmask));
	sdst.ss_family = dmask.ss_family = dst->af;
	switch (dst->af) {
	case AF_INET:
		((struct sockaddr_in *)&sdst)->sin_addr = dst->address.v4;
		sdst.ss_len = sizeof(struct sockaddr_in);
		((struct sockaddr_in *)&dmask)->sin_addr = dst->mask.v4;
		if (dport) {
			((struct sockaddr_in *)&sdst)->sin_port = dport;
			((struct sockaddr_in *)&dmask)->sin_port = 0xffff;
		}
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&sdst)->sin6_addr = dst->address.v6;
		sdst.ss_len = sizeof(struct sockaddr_in6);
		((struct sockaddr_in6 *)&dmask)->sin6_addr = dst->mask.v6;
		if (dport) {
			((struct sockaddr_in6 *)&sdst)->sin6_port = dport;
			((struct sockaddr_in6 *)&dmask)->sin6_port = 0xffff;
		}
		break;
	default:
		warnx("unsupported address family %d", dst->af);
		return -1;
	}
	dmask.ss_len = sdst.ss_len;

	bzero(&slocal, sizeof(slocal));
	if (local) {
		slocal.ss_family = local->af;
		switch (local->af) {
		case AF_INET:
			((struct sockaddr_in *)&slocal)->sin_addr =
			    local->address.v4;
			slocal.ss_len = sizeof(struct sockaddr_in);
			break;
		case AF_INET6:
			((struct sockaddr_in6 *)&slocal)->sin6_addr =
			    local->address.v6;
			slocal.ss_len = sizeof(struct sockaddr_in6);
			break;
		default:
			warnx("unsupported address family %d", local->af);
			return -1;
		}
	}

	bzero(&speer, sizeof(speer));
	if (peer) {
		speer.ss_family = peer->af;
		switch (peer->af) {
		case AF_INET:
			((struct sockaddr_in *)&speer)->sin_addr =
			    peer->address.v4;
			speer.ss_len = sizeof(struct sockaddr_in);
			break;
		case AF_INET6:
			((struct sockaddr_in6 *)&speer)->sin6_addr =
			    peer->address.v6;
			speer.ss_len = sizeof(struct sockaddr_in6);
			break;
		default:
			warnx("unsupported address family %d", peer->af);
			return -1;
		}
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = sadb_msg_seq++;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = action;
	smsg.sadb_msg_satype = satype;

	bzero(&sa_flowtype, sizeof(sa_flowtype));
	sa_flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
	sa_flowtype.sadb_protocol_len = sizeof(sa_flowtype) / 8;
	sa_flowtype.sadb_protocol_direction = direction;

	switch (flowtype) {
	case TYPE_USE:
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
		break;
	case TYPE_ACQUIRE:
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_ACQUIRE;
		break;
	case TYPE_REQUIRE:
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
		break;
	case TYPE_DENY:
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_DENY;
		break;
	case TYPE_BYPASS:
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_BYPASS;
		break;
	case TYPE_DONTACQ:
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_DONTACQ;
		break;
	default:
		warnx("unsupported flowtype %d", flowtype);
		return -1;
	}

	bzero(&sa_protocol, sizeof(sa_protocol));
	sa_protocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	sa_protocol.sadb_protocol_len = sizeof(sa_protocol) / 8;
	sa_protocol.sadb_protocol_direction = 0;
	sa_protocol.sadb_protocol_proto = proto;

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;

	bzero(&sa_smask, sizeof(sa_smask));
	sa_smask.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
	sa_smask.sadb_address_len =
	    (sizeof(sa_smask) + ROUNDUP(smask.ss_len)) / 8;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_exttype = SADB_X_EXT_DST_FLOW;
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;

	bzero(&sa_dmask, sizeof(sa_dmask));
	sa_dmask.sadb_address_exttype = SADB_X_EXT_DST_MASK;
	sa_dmask.sadb_address_len =
	    (sizeof(sa_dmask) + ROUNDUP(dmask.ss_len)) / 8;

	if (local) {
		bzero(&sa_local, sizeof(sa_local));
		sa_local.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
		sa_local.sadb_address_len =
		    (sizeof(sa_local) + ROUNDUP(slocal.ss_len)) / 8;
	}
	if (peer) {
		bzero(&sa_peer, sizeof(sa_peer));
		sa_peer.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
		sa_peer.sadb_address_len =
		    (sizeof(sa_peer) + ROUNDUP(speer.ss_len)) / 8;
	}

	if (auth && auth->srcid) {
		len = ROUNDUP(strlen(auth->srcid) + 1) + sizeof(*sa_srcid);

		sa_srcid = calloc(len, sizeof(u_int8_t));
		if (sa_srcid == NULL)
			err(1, "pfkey_flow: calloc");

		sa_srcid->sadb_ident_type = auth->srcid_type;
		sa_srcid->sadb_ident_len = len / 8;
		sa_srcid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;

		strlcpy((char *)(sa_srcid + 1), auth->srcid,
		    ROUNDUP(strlen(auth->srcid) + 1));
	}
	if (auth && auth->dstid) {
		len = ROUNDUP(strlen(auth->dstid) + 1) + sizeof(*sa_dstid);

		sa_dstid = calloc(len, sizeof(u_int8_t));
		if (sa_dstid == NULL)
			err(1, "pfkey_flow: calloc");

		sa_dstid->sadb_ident_type = auth->dstid_type;
		sa_dstid->sadb_ident_len = len / 8;
		sa_dstid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;

		strlcpy((char *)(sa_dstid + 1), auth->dstid,
		    ROUNDUP(strlen(auth->dstid) + 1));
	}

	iov_cnt = 0;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* add flow type */
	iov[iov_cnt].iov_base = &sa_flowtype;
	iov[iov_cnt].iov_len = sizeof(sa_flowtype);
	smsg.sadb_msg_len += sa_flowtype.sadb_protocol_len;
	iov_cnt++;

	/* local ip */
	if (local) {
		iov[iov_cnt].iov_base = &sa_local;
		iov[iov_cnt].iov_len = sizeof(sa_local);
		iov_cnt++;
		iov[iov_cnt].iov_base = &slocal;
		iov[iov_cnt].iov_len = ROUNDUP(slocal.ss_len);
		smsg.sadb_msg_len += sa_local.sadb_address_len;
		iov_cnt++;
	}

	/* remote peer */
	if (peer) {
		iov[iov_cnt].iov_base = &sa_peer;
		iov[iov_cnt].iov_len = sizeof(sa_peer);
		iov_cnt++;
		iov[iov_cnt].iov_base = &speer;
		iov[iov_cnt].iov_len = ROUNDUP(speer.ss_len);
		smsg.sadb_msg_len += sa_peer.sadb_address_len;
		iov_cnt++;
	}

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	/* src mask */
	iov[iov_cnt].iov_base = &sa_smask;
	iov[iov_cnt].iov_len = sizeof(sa_smask);
	iov_cnt++;
	iov[iov_cnt].iov_base = &smask;
	iov[iov_cnt].iov_len = ROUNDUP(smask.ss_len);
	smsg.sadb_msg_len += sa_smask.sadb_address_len;
	iov_cnt++;

	/* dest addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	/* dst mask */
	iov[iov_cnt].iov_base = &sa_dmask;
	iov[iov_cnt].iov_len = sizeof(sa_dmask);
	iov_cnt++;
	iov[iov_cnt].iov_base = &dmask;
	iov[iov_cnt].iov_len = ROUNDUP(dmask.ss_len);
	smsg.sadb_msg_len += sa_dmask.sadb_address_len;
	iov_cnt++;

	/* add protocol */
	iov[iov_cnt].iov_base = &sa_protocol;
	iov[iov_cnt].iov_len = sizeof(sa_protocol);
	smsg.sadb_msg_len += sa_protocol.sadb_protocol_len;
	iov_cnt++;

	if (sa_srcid) {
		/* src identity */
		iov[iov_cnt].iov_base = sa_srcid;
		iov[iov_cnt].iov_len = sa_srcid->sadb_ident_len * 8;
		smsg.sadb_msg_len += sa_srcid->sadb_ident_len;
		iov_cnt++;
	}
	if (sa_dstid) {
		/* dst identity */
		iov[iov_cnt].iov_base = sa_dstid;
		iov[iov_cnt].iov_len = sa_dstid->sadb_ident_len * 8;
		smsg.sadb_msg_len += sa_dstid->sadb_ident_len;
		iov_cnt++;
	}
	len = smsg.sadb_msg_len * 8;

	do {
		n = writev(sd, iov, iov_cnt);
	} while (n == -1 && (errno == EAGAIN || errno == EINTR));
	if (n == -1) {
		warn("writev failed");
		ret = -1;
	}

	free(sa_srcid);
	free(sa_dstid);

	return ret;
}

static int
pfkey_sa(int sd, u_int8_t satype, u_int8_t action, u_int32_t spi,
    struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
    struct ipsec_transforms *xfs, struct ipsec_key *authkey,
    struct ipsec_key *enckey, u_int8_t tmode)
{
	struct sadb_msg		smsg;
	struct sadb_sa		sa;
	struct sadb_address	sa_src, sa_dst;
	struct sadb_key		sa_authkey, sa_enckey;
	struct sockaddr_storage	ssrc, sdst;
	struct iovec		iov[IOV_CNT];
	ssize_t			n;
	int			iov_cnt, len, ret = 0;

	bzero(&ssrc, sizeof(ssrc));
	ssrc.ss_family = src->af;
	switch (src->af) {
	case AF_INET:
		((struct sockaddr_in *)&ssrc)->sin_addr = src->address.v4;
		ssrc.ss_len = sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&ssrc)->sin6_addr = src->address.v6;
		ssrc.ss_len = sizeof(struct sockaddr_in6);
		break;
	default:
		warnx("unsupported address family %d", src->af);
		return -1;
	}

	bzero(&sdst, sizeof(sdst));
	sdst.ss_family = dst->af;
	switch (dst->af) {
	case AF_INET:
		((struct sockaddr_in *)&sdst)->sin_addr = dst->address.v4;
		sdst.ss_len = sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&sdst)->sin6_addr = dst->address.v6;
		sdst.ss_len = sizeof(struct sockaddr_in6);
		break;
	default:
		warnx("unsupported address family %d", dst->af);
		return -1;
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = sadb_msg_seq++;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = action;
	smsg.sadb_msg_satype = satype;

	bzero(&sa, sizeof(sa));
	sa.sadb_sa_len = sizeof(sa) / 8;
	sa.sadb_sa_exttype = SADB_EXT_SA;
	sa.sadb_sa_spi = htonl(spi);
	sa.sadb_sa_state = SADB_SASTATE_MATURE;

	if (satype != SADB_X_SATYPE_IPIP && tmode == IPSEC_TUNNEL)
		sa.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;

	if (xfs && xfs->authxf) {
		switch (xfs->authxf->id) {
		case AUTHXF_NONE:
			break;
		case AUTHXF_HMAC_MD5:
			sa.sadb_sa_auth = SADB_AALG_MD5HMAC;
			break;
		case AUTHXF_HMAC_RIPEMD160:
			sa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
			break;
		case AUTHXF_HMAC_SHA1:
			sa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
			break;
		case AUTHXF_HMAC_SHA2_256:
			sa.sadb_sa_auth = SADB_X_AALG_SHA2_256;
			break;
		case AUTHXF_HMAC_SHA2_384:
			sa.sadb_sa_auth = SADB_X_AALG_SHA2_384;
			break;
		case AUTHXF_HMAC_SHA2_512:
			sa.sadb_sa_auth = SADB_X_AALG_SHA2_512;
			break;
		default:
			warnx("unsupported authentication algorithm %d",
			    xfs->authxf->id);
		}
	}
	if (xfs && xfs->encxf) {
		switch (xfs->encxf->id) {
		case ENCXF_NONE:
			break;
		case ENCXF_3DES_CBC:
			sa.sadb_sa_encrypt = SADB_EALG_3DESCBC;
			break;
		case ENCXF_AES:
		case ENCXF_AES_128:
		case ENCXF_AES_192:
		case ENCXF_AES_256:
			sa.sadb_sa_encrypt = SADB_X_EALG_AES;
			break;
		case ENCXF_AESCTR:
		case ENCXF_AES_128_CTR:
		case ENCXF_AES_192_CTR:
		case ENCXF_AES_256_CTR:
			sa.sadb_sa_encrypt = SADB_X_EALG_AESCTR;
			break;
		case ENCXF_AES_128_GCM:
		case ENCXF_AES_192_GCM:
		case ENCXF_AES_256_GCM:
			sa.sadb_sa_encrypt = SADB_X_EALG_AESGCM16;
			break;
		case ENCXF_AES_128_GMAC:
		case ENCXF_AES_192_GMAC:
		case ENCXF_AES_256_GMAC:
			sa.sadb_sa_encrypt = SADB_X_EALG_AESGMAC;
			break;
		case ENCXF_BLOWFISH:
			sa.sadb_sa_encrypt = SADB_X_EALG_BLF;
			break;
		case ENCXF_CAST128:
			sa.sadb_sa_encrypt = SADB_X_EALG_CAST;
			break;
		case ENCXF_NULL:
			sa.sadb_sa_encrypt = SADB_EALG_NULL;
			break;
		default:
			warnx("unsupported encryption algorithm %d",
			    xfs->encxf->id);
		}
	}
	if (xfs && xfs->compxf) {
		switch (xfs->compxf->id) {
		case COMPXF_DEFLATE:
			sa.sadb_sa_encrypt = SADB_X_CALG_DEFLATE;
			break;
		case COMPXF_LZS:
			sa.sadb_sa_encrypt = SADB_X_CALG_LZS;
			break;
		default:
			warnx("unsupported compression algorithm %d",
			    xfs->compxf->id);
		}
	}

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;
	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;

	if (action == SADB_ADD && !authkey && !enckey && satype !=
	    SADB_X_SATYPE_IPCOMP && satype != SADB_X_SATYPE_IPIP) { /* XXX ENCNULL */
		warnx("no key specified");
		return -1;
	}
	if (authkey) {
		bzero(&sa_authkey, sizeof(sa_authkey));
		sa_authkey.sadb_key_len = (sizeof(sa_authkey) +
		    ((authkey->len + 7) / 8) * 8) / 8;
		sa_authkey.sadb_key_exttype = SADB_EXT_KEY_AUTH;
		sa_authkey.sadb_key_bits = 8 * authkey->len;
	}
	if (enckey) {
		bzero(&sa_enckey, sizeof(sa_enckey));
		sa_enckey.sadb_key_len = (sizeof(sa_enckey) +
		    ((enckey->len + 7) / 8) * 8) / 8;
		sa_enckey.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
		sa_enckey.sadb_key_bits = 8 * enckey->len;
	}

	iov_cnt = 0;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* sa */
	iov[iov_cnt].iov_base = &sa;
	iov[iov_cnt].iov_len = sizeof(sa);
	smsg.sadb_msg_len += sa.sadb_sa_len;
	iov_cnt++;

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	/* dst addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	if (authkey) {
		/* authentication key */
		iov[iov_cnt].iov_base = &sa_authkey;
		iov[iov_cnt].iov_len = sizeof(sa_authkey);
		iov_cnt++;
		iov[iov_cnt].iov_base = authkey->data;
		iov[iov_cnt].iov_len = ((authkey->len + 7) / 8) * 8;
		smsg.sadb_msg_len += sa_authkey.sadb_key_len;
		iov_cnt++;
	}
	if (enckey) {
		/* encryption key */
		iov[iov_cnt].iov_base = &sa_enckey;
		iov[iov_cnt].iov_len = sizeof(sa_enckey);
		iov_cnt++;
		iov[iov_cnt].iov_base = enckey->data;
		iov[iov_cnt].iov_len = ((enckey->len + 7) / 8) * 8;
		smsg.sadb_msg_len += sa_enckey.sadb_key_len;
		iov_cnt++;
	}

	len = smsg.sadb_msg_len * 8;
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		warn("writev failed");
		ret = -1;
	} else if (n != len) {
		warnx("short write");
		ret = -1;
	}

	return ret;
}

static int
pfkey_sabundle(int sd, u_int8_t satype, u_int8_t satype2, u_int8_t action,
    struct ipsec_addr_wrap *dst, u_int32_t spi, struct ipsec_addr_wrap *dst2,
    u_int32_t spi2)
{
	struct sadb_msg		smsg;
	struct sadb_sa		sa1, sa2;
	struct sadb_address	sa_dst, sa_dst2;
	struct sockaddr_storage	sdst, sdst2;
	struct sadb_protocol	sa_proto;
	struct iovec		iov[IOV_CNT];
	ssize_t			n;
	int			iov_cnt, len, ret = 0;

	bzero(&sdst, sizeof(sdst));
	sdst.ss_family = dst->af;
	switch (dst->af) {
	case AF_INET:
		((struct sockaddr_in *)&sdst)->sin_addr = dst->address.v4;
		sdst.ss_len = sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&sdst)->sin6_addr = dst->address.v6;
		sdst.ss_len = sizeof(struct sockaddr_in6);
		break;
	default:
		warnx("unsupported address family %d", dst->af);
		return -1;
	}

	bzero(&sdst2, sizeof(sdst2));
	sdst2.ss_family = dst2->af;
	switch (dst2->af) {
	case AF_INET:
		((struct sockaddr_in *)&sdst2)->sin_addr = dst2->address.v4;
		sdst2.ss_len = sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&sdst2)->sin6_addr = dst2->address.v6;
		sdst2.ss_len = sizeof(struct sockaddr_in6);
		break;
	default:
		warnx("unsupported address family %d", dst2->af);
		return -1;
	}

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = sadb_msg_seq++;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = action;
	smsg.sadb_msg_satype = satype;

	bzero(&sa1, sizeof(sa1));
	sa1.sadb_sa_len = sizeof(sa1) / 8;
	sa1.sadb_sa_exttype = SADB_EXT_SA;
	sa1.sadb_sa_spi = htonl(spi);
	sa1.sadb_sa_state = SADB_SASTATE_MATURE;

	bzero(&sa2, sizeof(sa2));
	sa2.sadb_sa_len = sizeof(sa2) / 8;
	sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
	sa2.sadb_sa_spi = htonl(spi2);
	sa2.sadb_sa_state = SADB_SASTATE_MATURE;
	iov_cnt = 0;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;

	bzero(&sa_dst2, sizeof(sa_dst2));
	sa_dst2.sadb_address_exttype = SADB_X_EXT_DST2;
	sa_dst2.sadb_address_len = (sizeof(sa_dst2) + ROUNDUP(sdst2.ss_len)) / 8;

	bzero(&sa_proto, sizeof(sa_proto));
	sa_proto.sadb_protocol_exttype = SADB_X_EXT_SATYPE2;
	sa_proto.sadb_protocol_len = sizeof(sa_proto) / 8;
	sa_proto.sadb_protocol_direction = 0;
	sa_proto.sadb_protocol_proto = satype2;

	/* header */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	/* sa */
	iov[iov_cnt].iov_base = &sa1;
	iov[iov_cnt].iov_len = sizeof(sa1);
	smsg.sadb_msg_len += sa1.sadb_sa_len;
	iov_cnt++;

	/* dst addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	/* second sa */
	iov[iov_cnt].iov_base = &sa2;
	iov[iov_cnt].iov_len = sizeof(sa2);
	smsg.sadb_msg_len += sa2.sadb_sa_len;
	iov_cnt++;

	/* second dst addr */
	iov[iov_cnt].iov_base = &sa_dst2;
	iov[iov_cnt].iov_len = sizeof(sa_dst2);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst2;
	iov[iov_cnt].iov_len = ROUNDUP(sdst2.ss_len);
	smsg.sadb_msg_len += sa_dst2.sadb_address_len;
	iov_cnt++;

	/* SA type */
	iov[iov_cnt].iov_base = &sa_proto;
	iov[iov_cnt].iov_len = sizeof(sa_proto);
	smsg.sadb_msg_len += sa_proto.sadb_protocol_len;
	iov_cnt++;

	len = smsg.sadb_msg_len * 8;
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
		warn("writev failed");
		ret = -1;
	} else if (n != len) {
		warnx("short write");
		ret = -1;
	}

	return (ret);
}

static int
pfkey_reply(int sd, u_int8_t **datap, ssize_t *lenp)
{
	struct sadb_msg	 hdr;
	ssize_t		 len;
	u_int8_t	*data;

	if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
		warnx("short read");
		return -1;
	}
	len = hdr.sadb_msg_len * PFKEYV2_CHUNK;
	if ((data = malloc(len)) == NULL)
		err(1, "pfkey_reply: malloc");
	if (read(sd, data, len) != len) {
		warn("PF_KEY short read");
		freezero(data, len);
		return -1;
	}
	if (datap) {
		*datap = data;
		if (lenp)
			*lenp = len;
	} else {
		freezero(data, len);
	}
	if (datap == NULL && hdr.sadb_msg_errno != 0) {
		errno = hdr.sadb_msg_errno;
		if (errno != EEXIST) {
			warn("PF_KEY failed");
			return -1;
		}
	}
	return 0;
}

int
pfkey_parse(struct sadb_msg *msg, struct ipsec_rule *rule)
{
	struct sadb_ext		*ext;
	struct sadb_address	*saddr;
	struct sadb_protocol	*sproto;
	struct sadb_ident	*sident;
	struct sockaddr		*sa;
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	int			 len;

	switch (msg->sadb_msg_satype) {
	case SADB_SATYPE_ESP:
		rule->satype = IPSEC_ESP;
		break;
	case SADB_SATYPE_AH:
		rule->satype = IPSEC_AH;
		break;
	case SADB_X_SATYPE_IPCOMP:
		rule->satype = IPSEC_IPCOMP;
		break;
	case SADB_X_SATYPE_IPIP:
		rule->satype = IPSEC_IPIP;
		break;
	default:
		return (1);
	}

	for (ext = (struct sadb_ext *)(msg + 1);
	    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
	    msg->sadb_msg_len * PFKEYV2_CHUNK && ext->sadb_ext_len > 0;
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
	    ext->sadb_ext_len * PFKEYV2_CHUNK)) {
		switch (ext->sadb_ext_type) {
		case SADB_EXT_ADDRESS_SRC:
			saddr = (struct sadb_address *)ext;
			sa = (struct sockaddr *)(saddr + 1);

			rule->local = calloc(1, sizeof(struct ipsec_addr_wrap));
			if (rule->local == NULL)
				err(1, "pfkey_parse: calloc");

			rule->local->af = sa->sa_family;
			switch (sa->sa_family) {
			case AF_INET:
				bcopy(&((struct sockaddr_in *)sa)->sin_addr,
				    &rule->local->address.v4,
				    sizeof(struct in_addr));
				set_ipmask(rule->local, 32);
				break;
			case AF_INET6:
				bcopy(&((struct sockaddr_in6 *)sa)->sin6_addr,
				    &rule->local->address.v6,
				    sizeof(struct in6_addr));
				set_ipmask(rule->local, 128);
				break;
			default:
				return (1);
			}
			break;


		case SADB_EXT_ADDRESS_DST:
			saddr = (struct sadb_address *)ext;
			sa = (struct sockaddr *)(saddr + 1);

			rule->peer = calloc(1, sizeof(struct ipsec_addr_wrap));
			if (rule->peer == NULL)
				err(1, "pfkey_parse: calloc");

			rule->peer->af = sa->sa_family;
			switch (sa->sa_family) {
			case AF_INET:
				bcopy(&((struct sockaddr_in *)sa)->sin_addr,
				    &rule->peer->address.v4,
				    sizeof(struct in_addr));
				set_ipmask(rule->peer, 32);
				break;
			case AF_INET6:
				bcopy(&((struct sockaddr_in6 *)sa)->sin6_addr,
				    &rule->peer->address.v6,
				    sizeof(struct in6_addr));
				set_ipmask(rule->peer, 128);
				break;
			default:
				return (1);
			}
			break;

		case SADB_EXT_IDENTITY_SRC:
			sident = (struct sadb_ident *)ext;
			len = (sident->sadb_ident_len * sizeof(uint64_t)) -
			    sizeof(struct sadb_ident);

			if (rule->auth == NULL) {
				rule->auth = calloc(1, sizeof(struct
				    ipsec_auth));
				if (rule->auth == NULL)
					err(1, "pfkey_parse: calloc");
			}

			rule->auth->srcid = calloc(1, len);
			if (rule->auth->srcid == NULL)
				err(1, "pfkey_parse: calloc");

			strlcpy(rule->auth->srcid, (char *)(sident + 1), len);
			break;

		case SADB_EXT_IDENTITY_DST:
			sident = (struct sadb_ident *)ext;
			len = (sident->sadb_ident_len * sizeof(uint64_t)) -
			    sizeof(struct sadb_ident);

			if (rule->auth == NULL) {
				rule->auth = calloc(1, sizeof(struct
				    ipsec_auth));
				if (rule->auth == NULL)
					err(1, "pfkey_parse: calloc");
			}

			rule->auth->dstid = calloc(1, len);
			if (rule->auth->dstid == NULL)
				err(1, "pfkey_parse: calloc");

			strlcpy(rule->auth->dstid, (char *)(sident + 1), len);
			break;

		case SADB_X_EXT_PROTOCOL:
			sproto = (struct sadb_protocol *)ext;
			if (sproto->sadb_protocol_direction == 0)
				rule->proto = sproto->sadb_protocol_proto;
			break;

		case SADB_X_EXT_FLOW_TYPE:
			sproto = (struct sadb_protocol *)ext;

			switch (sproto->sadb_protocol_direction) {
			case IPSP_DIRECTION_IN:
				rule->direction = IPSEC_IN;
				break;
			case IPSP_DIRECTION_OUT:
				rule->direction = IPSEC_OUT;
				break;
			default:
				return (1);
			}
			switch (sproto->sadb_protocol_proto) {
			case SADB_X_FLOW_TYPE_USE:
				rule->flowtype = TYPE_USE;
				break;
			case SADB_X_FLOW_TYPE_ACQUIRE:
				rule->flowtype = TYPE_ACQUIRE;
				break;
			case SADB_X_FLOW_TYPE_REQUIRE:
				rule->flowtype = TYPE_REQUIRE;
				break;
			case SADB_X_FLOW_TYPE_DENY:
				rule->flowtype = TYPE_DENY;
				break;
			case SADB_X_FLOW_TYPE_BYPASS:
				rule->flowtype = TYPE_BYPASS;
				break;
			case SADB_X_FLOW_TYPE_DONTACQ:
				rule->flowtype = TYPE_DONTACQ;
				break;
			default:
				rule->flowtype = TYPE_UNKNOWN;
				break;
			}
			break;

		case SADB_X_EXT_SRC_FLOW:
			saddr = (struct sadb_address *)ext;
			sa = (struct sockaddr *)(saddr + 1);

			if (rule->src == NULL) {
				rule->src = calloc(1,
				    sizeof(struct ipsec_addr_wrap));
				if (rule->src == NULL)
					err(1, "pfkey_parse: calloc");
			}

			rule->src->af = sa->sa_family;
			switch (sa->sa_family) {
			case AF_INET:
				bcopy(&((struct sockaddr_in *)sa)->sin_addr,
				    &rule->src->address.v4,
				    sizeof(struct in_addr));
				rule->sport =
				    ((struct sockaddr_in *)sa)->sin_port;
				break;
			case AF_INET6:
				bcopy(&((struct sockaddr_in6 *)sa)->sin6_addr,
				    &rule->src->address.v6,
				    sizeof(struct in6_addr));
				rule->sport =
				    ((struct sockaddr_in6 *)sa)->sin6_port;
				break;
			default:
				return (1);
			}
			break;

		case SADB_X_EXT_DST_FLOW:
			saddr = (struct sadb_address *)ext;
			sa = (struct sockaddr *)(saddr + 1);

			if (rule->dst == NULL) {
				rule->dst = calloc(1,
				    sizeof(struct ipsec_addr_wrap));
				if (rule->dst == NULL)
					err(1, "pfkey_parse: calloc");
			}

			rule->dst->af = sa->sa_family;
			switch (sa->sa_family) {
			case AF_INET:
				bcopy(&((struct sockaddr_in *)sa)->sin_addr,
				    &rule->dst->address.v4,
				    sizeof(struct in_addr));
				rule->dport =
				    ((struct sockaddr_in *)sa)->sin_port;
				break;
			case AF_INET6:
				bcopy(&((struct sockaddr_in6 *)sa)->sin6_addr,
				    &rule->dst->address.v6,
				    sizeof(struct in6_addr));
				rule->dport =
				    ((struct sockaddr_in6 *)sa)->sin6_port;
				break;
			default:
				return (1);
			}
			break;


		case SADB_X_EXT_SRC_MASK:
			saddr = (struct sadb_address *)ext;
			sa = (struct sockaddr *)(saddr + 1);

			if (rule->src == NULL) {
				rule->src = calloc(1,
				    sizeof(struct ipsec_addr_wrap));
				if (rule->src == NULL)
					err(1, "pfkey_parse: calloc");
			}

			rule->src->af = sa->sa_family;
			switch (sa->sa_family) {
			case AF_INET:
				sa_in = (struct sockaddr_in *)sa;
				bcopy(&sa_in->sin_addr, &rule->src->mask.v4,
				    sizeof(struct in_addr));
				break;
			case AF_INET6:
				sa_in6 = (struct sockaddr_in6 *)sa;
				bcopy(&sa_in6->sin6_addr, &rule->src->mask.v6,
				    sizeof(struct in6_addr));
				break;

			default:
				return (1);
			}
			break;

		case SADB_X_EXT_DST_MASK:
			saddr = (struct sadb_address *)ext;
			sa = (struct sockaddr *)(saddr + 1);

			if (rule->dst == NULL) {
				rule->dst = calloc(1,
				    sizeof(struct ipsec_addr_wrap));
				if (rule->dst == NULL)
					err(1, "pfkey_parse: calloc");
			}

			rule->dst->af = sa->sa_family;
			switch (sa->sa_family) {
			case AF_INET:
				sa_in = (struct sockaddr_in *)sa;
				bcopy(&sa_in->sin_addr, &rule->dst->mask.v4,
				    sizeof(struct in_addr));
				break;
			case AF_INET6:
				sa_in6 = (struct sockaddr_in6 *)sa;
				bcopy(&sa_in6->sin6_addr, &rule->dst->mask.v6,
				    sizeof(struct in6_addr));
				break;
			default:
				return (1);
			}
			break;

		default:
			return (1);
		}
	}

	return (0);
}

int
pfkey_ipsec_establish(int action, struct ipsec_rule *r)
{
	int		ret;
	u_int8_t	satype, satype2, direction;

	if (r->type == RULE_FLOW) {
		switch (r->satype) {
		case IPSEC_ESP:
			satype = SADB_SATYPE_ESP;
			break;
		case IPSEC_AH:
			satype = SADB_SATYPE_AH;
			break;
		case IPSEC_IPCOMP:
			satype = SADB_X_SATYPE_IPCOMP;
			break;
		case IPSEC_IPIP:
			satype = SADB_X_SATYPE_IPIP;
			break;
		default:
			return -1;
		}

		switch (r->direction) {
		case IPSEC_IN:
			direction = IPSP_DIRECTION_IN;
			break;
		case IPSEC_OUT:
			direction = IPSP_DIRECTION_OUT;
			break;
		default:
			return -1;
		}

		switch (action) {
		case ACTION_ADD:
			ret = pfkey_flow(fd, satype, SADB_X_ADDFLOW, direction,
			    r->proto, r->src, r->sport, r->dst, r->dport,
			    r->local, r->peer, r->auth, r->flowtype);
			break;
		case ACTION_DELETE:
			/* No peer for flow deletion. */
			ret = pfkey_flow(fd, satype, SADB_X_DELFLOW, direction,
			    r->proto, r->src, r->sport, r->dst, r->dport,
			    NULL, NULL, NULL, r->flowtype);
			break;
		default:
			return -1;
		}
	} else if (r->type == RULE_SA) {
		switch (r->satype) {
		case IPSEC_AH:
			satype = SADB_SATYPE_AH;
			break;
		case IPSEC_ESP:
			satype = SADB_SATYPE_ESP;
			break;
		case IPSEC_IPCOMP:
			satype = SADB_X_SATYPE_IPCOMP;
			break;
		case IPSEC_TCPMD5:
			satype = SADB_X_SATYPE_TCPSIGNATURE;
			break;
		case IPSEC_IPIP:
			satype = SADB_X_SATYPE_IPIP;
			break;
		default:
			return -1;
		}
		switch (action) {
		case ACTION_ADD:
			ret = pfkey_sa(fd, satype, SADB_ADD, r->spi,
			    r->src, r->dst, r->xfs, r->authkey, r->enckey,
			    r->tmode);
			break;
		case ACTION_DELETE:
			ret = pfkey_sa(fd, satype, SADB_DELETE, r->spi,
			    r->src, r->dst, r->xfs, NULL, NULL, r->tmode);
			break;
		default:
			return -1;
		}
	} else if (r->type == RULE_BUNDLE) {
		switch (r->satype) {
		case IPSEC_AH:
			satype = SADB_SATYPE_AH;
			break;
		case IPSEC_ESP:
			satype = SADB_SATYPE_ESP;
			break;
		case IPSEC_IPCOMP:
			satype = SADB_X_SATYPE_IPCOMP;
			break;
		case IPSEC_TCPMD5:
			satype = SADB_X_SATYPE_TCPSIGNATURE;
			break;
		case IPSEC_IPIP:
			satype = SADB_X_SATYPE_IPIP;
			break;
		default:
			return -1;
		}
		switch (r->proto2) {
		case IPSEC_AH:
			satype2 = SADB_SATYPE_AH;
			break;
		case IPSEC_ESP:
			satype2 = SADB_SATYPE_ESP;
			break;
		case IPSEC_IPCOMP:
			satype2 = SADB_X_SATYPE_IPCOMP;
			break;
		case IPSEC_TCPMD5:
			satype2 = SADB_X_SATYPE_TCPSIGNATURE;
			break;
		case IPSEC_IPIP:
			satype2 = SADB_X_SATYPE_IPIP;
			break;
		default:
			return -1;
		}
		switch (action) {
		case ACTION_ADD:
			ret = pfkey_sabundle(fd, satype, satype2,
			    SADB_X_GRPSPIS, r->dst, r->spi, r->dst2, r->spi2);
			break;
		case ACTION_DELETE:
			return 0;
		default:
			return -1;
		}
	} else
		return -1;

	if (ret < 0)
		return -1;
	if (pfkey_reply(fd, NULL, NULL) < 0)
		return -1;

	return 0;
}

int
pfkey_ipsec_flush(void)
{
	struct sadb_msg smsg;
	struct iovec	iov[IOV_CNT];
	ssize_t		n;
	int		iov_cnt, len;

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = sadb_msg_seq++;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = SADB_FLUSH;
	smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;

	iov_cnt = 0;

	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	len = smsg.sadb_msg_len * 8;
	if ((n = writev(fd, iov, iov_cnt)) == -1) {
		warn("writev failed");
		return -1;
	}
	if (n != len) {
		warnx("short write");
		return -1;
	}
	if (pfkey_reply(fd, NULL, NULL) < 0)
		return -1;

	return 0;
}

static int
pfkey_promisc(void)
{
	struct sadb_msg msg;

	memset(&msg, 0, sizeof(msg));
	msg.sadb_msg_version = PF_KEY_V2;
	msg.sadb_msg_seq = sadb_msg_seq++;
	msg.sadb_msg_pid = getpid();
	msg.sadb_msg_len = sizeof(msg) / PFKEYV2_CHUNK;
	msg.sadb_msg_type = SADB_X_PROMISC;
	msg.sadb_msg_satype = 1;	/* enable */
	if (write(fd, &msg, sizeof(msg)) != sizeof(msg)) {
		warn("pfkey_promisc: write failed");
		return -1;
	}
	if (pfkey_reply(fd, NULL, NULL) < 0)
		return -1;
	return 0;
}

int
pfkey_monitor(int opts)
{
	struct pollfd pfd[1];
	struct sadb_msg *msg;
	u_int8_t *data;
	ssize_t len;
	int n;

	if (pfkey_init() < 0)
		return -1;
	if (pfkey_promisc() < 0)
		return -1;

	pfd[0].fd = fd;
	pfd[0].events = POLLIN;
	for (;;) {
		if ((n = poll(pfd, 1, -1)) < 0)
			err(2, "poll");
		if (n == 0)
			break;
		if ((pfd[0].revents & POLLIN) == 0)
			continue;
		if (pfkey_reply(fd, &data, &len) < 0)
			continue;
		msg = (struct sadb_msg *)data;
		if (msg->sadb_msg_type == SADB_X_PROMISC) {
			/* remove extra header from promisc messages */
			if ((msg->sadb_msg_len * PFKEYV2_CHUNK) >=
			    2 * sizeof(struct sadb_msg)) {
				msg++;
			}
		}
		pfkey_monitor_sa(msg, opts);
		if (opts & IPSECCTL_OPT_VERBOSE)
			pfkey_print_raw(data, len);
		freezero(data, len);
	}
	close(fd);
	return 0;
}

int
pfkey_init(void)
{
	if ((fd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1)
		err(1, "pfkey_init: failed to open PF_KEY socket");

	return 0;
}
@


1.59
log
@use freezero()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.58 2017/02/28 16:46:27 bluhm Exp $	*/
d54 1
a54 1
static int	pfkey_sagroup(int, u_int8_t, u_int8_t, u_int8_t,
d629 1
a629 1
pfkey_sagroup(int sd, u_int8_t satype, u_int8_t satype2, u_int8_t action,
d1183 1
a1183 1
	} else if (r->type == RULE_GROUP) {
d1224 1
a1224 1
			ret = pfkey_sagroup(fd, satype, satype2,
@


1.58
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.57 2015/12/10 17:27:00 mmcc Exp $	*/
d778 1
a778 2
		explicit_bzero(data, len);
		free(data);
d786 1
a786 2
		explicit_bzero(data, len);
		free(data);
d1337 1
a1337 2
		explicit_bzero(data, len);
		free(data);
@


1.57
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.56 2015/12/09 21:41:50 naddy Exp $	*/
d704 1
a704 1
	sa_proto.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
@


1.56
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.55 2015/10/18 02:30:53 mmcc Exp $	*/
d382 2
a383 4
	if (sa_srcid)
		free(sa_srcid);
	if (sa_dstid)
		free(sa_dstid);
@


1.55
log
@Use explicit_bzero() when the memory is freed directly afterward.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.54 2014/11/03 03:22:22 deraadt Exp $	*/
a486 3
			break;
		case ENCXF_DES_CBC:
			sa.sadb_sa_encrypt = SADB_EALG_DESCBC;
@


1.54
log
@simple conversion from select() to poll()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.53 2012/06/30 14:51:31 naddy Exp $	*/
d783 1
a783 1
		bzero(data, len);
d792 1
a792 1
		bzero(data, len);
d1344 1
a1344 1
		memset(data, 0, len);
@


1.53
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.52 2012/03/24 15:39:54 jsg Exp $	*/
d33 1
d1311 2
a1312 1
	fd_set *rset;
d1314 1
a1314 2
	struct sadb_msg *msg;
	ssize_t len, set_size;
d1322 2
a1323 5
	set_size = howmany(fd + 1, NFDBITS) * sizeof(fd_mask);
	if ((rset = malloc(set_size)) == NULL) {
		warn("malloc");
		return -1;
	}
d1325 2
a1326 4
		memset(rset, 0, set_size);
		FD_SET(fd, rset);
		if ((n = select(fd+1, rset, NULL, NULL, NULL)) < 0)
			err(2, "select");
d1329 1
a1329 1
		if (!FD_ISSET(fd, rset))
a1347 1
	free(rset);
@


1.52
log
@fix some leaks
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.51 2010/10/06 22:19:20 mikeb Exp $	*/
d497 3
@


1.51
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.50 2010/09/22 14:04:09 mikeb Exp $	*/
d1349 1
@


1.50
log
@Support AES-GCM-16 (as aes-gcm) and ENCR_NULL_AUTH_AES_GMAC
(as aes-gmac) encryption transformations in the ipsec.conf(5).

Available "enc" arguments denoting use of

1) AES-GCM-16:

 aes-128-gcm for 160 bit key (128+nonce)
 aes-192-gcm for 224 bit key (192+nonce)
 aes-256-gcm for 288 bit key (256+nonce)

2) ENCR_NULL_AUTH_AES_GMAC:

 aes-128-gmac for 160 bit key (128+nonce)
 aes-192-gmac for 224 bit key (192+nonce)
 aes-256-gmac for 288 bit key (256+nonce)

Please note that aes-gmac family performs no encryption and provides
no confidentiality and is intended for cases in which confidentiality
is not desired (it can be thought of as AH with NAT-T support).

Also, although this implementation supports manual keying, it's
use is strictly discouraged as AES-GCM security depends on frequent
re-keying.  So it can be thought of as a debug facility only.

Example configuration:

	ike esp from 172.23.61.36 to 172.23.61.156 \
		quick enc aes-256-gcm \
		psk humppa

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

OK naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.49 2008/12/22 17:00:37 hshoexer Exp $	*/
a516 3
			break;
		case ENCXF_SKIPJACK:
			sa.sadb_sa_encrypt = SADB_X_EALG_SKIPJACK;
@


1.49
log
@Only warn about pfkey failures when errno is != EEXIST.

This avoids warnings about already existing manual flows when
ipsec.conf is reloaded.  From Mitja Muzenic <mitja at muzenic dot
net>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.48 2007/03/16 20:51:01 markus Exp $	*/
d491 3
d498 10
@


1.48
log
@move autodetection of the ID type to the parser.  this way the
static flows have the correct ID, too. ok hshoexer, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.47 2006/11/10 14:47:52 hshoexer Exp $	*/
d783 4
a786 2
		warn("PF_KEY failed");
		return -1;
@


1.47
log
@Fix grouping for SAs.  Now all combinations of SAs are possible,
not only ESP+AH (ie. ESP inside AH).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.46 2006/08/30 18:02:20 henning Exp $	*/
d258 1
a258 1
		sa_srcid->sadb_ident_type = auth->idtype;
d272 1
a272 1
		sa_dstid->sadb_ident_type = auth->idtype;
@


1.46
log
@can get EAGAIN when writing to the pfkey socket; same change as bgpd,
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.45 2006/06/08 22:34:30 hshoexer Exp $	*/
d53 3
a55 3
static int	pfkey_sagroup(int, u_int8_t, u_int8_t,
		    struct ipsec_addr_wrap *, u_int32_t, u_int32_t,
		    struct ipsec_addr_wrap *, u_int32_t, u_int32_t);
d620 3
a622 3
pfkey_sagroup(int sd, u_int8_t satype, u_int8_t action,
    struct ipsec_addr_wrap *dst, u_int32_t proto, u_int32_t spi,
    struct ipsec_addr_wrap *dst2, u_int32_t proto2, u_int32_t spi2)
d698 1
a698 1
	sa_proto.sadb_protocol_proto = proto;
d1095 1
a1095 1
	u_int8_t	satype, direction;
d1194 19
d1215 2
a1216 2
			ret = pfkey_sagroup(fd, satype, SADB_X_GRPSPIS, r->dst,
			    r->proto, r->spi, r->dst2, r->proto2, r->spi2);
@


1.45
log
@fix some indentation, noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.44 2006/06/01 22:29:19 hshoexer Exp $	*/
d372 5
a376 1
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
a378 5
		goto out;
	}
	if (n != len) {
		warnx("short write");
		ret = -1;
a380 1
out:
@


1.44
log
@pfkey bits needed for SA grouping
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.43 2006/06/01 17:32:20 naddy Exp $	*/
d1309 1
a1309 1
			     2 * sizeof(struct sadb_msg)) {
@


1.43
log
@Support flows with port modifiers for proto tcp/udp, e.g.
flow proto udp from 1.2.3.4 port ntp to 5.6.7.8

ok hshoexer@@ msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.42 2006/06/01 12:19:59 markus Exp $	*/
d53 3
d622 134
d1173 30
@


1.42
log
@read the full reply from PFKEY even if sadb_errno is set; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.41 2006/06/01 06:20:30 todd Exp $	*/
d45 2
a46 1
		    struct ipsec_addr_wrap *, struct ipsec_addr_wrap *,
d61 2
a62 1
    u_int8_t proto, struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
d86 4
d95 4
d114 4
d123 4
d843 2
d850 2
d875 2
d882 2
d994 2
a995 2
			    r->proto, r->src, r->dst, r->local, r->peer, r->auth,
			    r->flowtype);
d1000 2
a1001 2
			    r->proto, r->src, r->dst, NULL, NULL, NULL,
			    r->flowtype);
@


1.41
log
@correct error messages to match calloc where appropriate
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.40 2006/05/31 05:38:45 hshoexer Exp $	*/
a610 5
	if (datap == NULL && hdr.sadb_msg_errno != 0) {
		errno = hdr.sadb_msg_errno;
		warn("PF_KEY failed");
		return -1;
	}
d628 5
a632 1

@


1.40
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.39 2006/05/30 21:56:05 msf Exp $	*/
d678 1
a678 1
				err(1, "pfkey_parse: malloc");
d706 1
a706 1
				err(1, "pfkey_parse: malloc");
@


1.39
log
@implement monitor mode for ipsecctl. worked on with markus@@

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.38 2006/05/28 21:08:42 hshoexer Exp $	*/
d1079 1
a1079 1
		return -1; 
d1112 1
a1112 1
			continue; 
@


1.38
log
@kill trainling whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.37 2006/05/28 20:58:24 todd Exp $	*/
d52 1
a52 1
static int	pfkey_reply(int);
d601 1
a601 1
pfkey_reply(int sd)
d611 1
a611 1
	if (hdr.sadb_msg_errno != 0) {
d625 8
a632 2
	bzero(data, len);
	free(data);
d1019 1
a1019 1
	if (pfkey_reply(fd) < 0)
d1056 39
a1094 1
	if (pfkey_reply(fd) < 0)
d1097 31
@


1.37
log
@fill in AF_INET6 cases
this does not complete v6 support for ipsecctl, but makes progress
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.36 2006/04/19 16:10:50 hshoexer Exp $	*/
d663 1
a663 1
	    ext = (struct sadb_ext *)((u_int8_t *)ext + 
@


1.36
log
@"type" keyword to specify flow type (require, use, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.35 2006/03/31 13:13:51 markus Exp $	*/
d78 1
a82 1
		ssrc.ss_family = AF_INET;
d86 4
a93 1
	smask.ss_family = ssrc.ss_family;
d98 1
a102 1
		sdst.ss_family = AF_INET;
d106 4
a113 1
	dmask.ss_family = sdst.ss_family;
d118 1
a123 1
			slocal.ss_family = AF_INET;
d126 4
d138 1
a143 1
			speer.ss_family = AF_INET;
d146 4
d386 1
a390 1
		ssrc.ss_family = AF_INET;
d393 3
d402 1
a406 1
		sdst.ss_family = AF_INET;
d409 3
d640 1
d663 1
a663 1
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
d674 1
d680 7
a686 2
				rule->local->mask.addr32[0] = 0xffffffff;
				rule->local->af = AF_INET;
d702 1
d708 7
a714 2
				rule->peer->mask.addr32[0] = 0xffffffff;
				rule->peer->af = AF_INET;
d814 1
d820 5
a824 1
				rule->src->af = AF_INET;
d842 1
a847 1
				rule->dst->af = AF_INET;
d849 5
a853 1

d871 1
d877 5
a881 1
				rule->src->af = AF_INET;
d900 1
a905 1
				rule->dst->af = AF_INET;
d907 5
a911 1

@


1.35
log
@allow specification of encapsulated protocol for flows; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.34 2006/03/30 12:44:20 markus Exp $	*/
d159 3
d170 3
@


1.34
log
@allow specification of outer local ips in flows (SADB_EXT_ADDRESS_SRC); ok hshoexer, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.33 2006/03/07 00:30:28 reyk Exp $	*/
d44 1
a44 1
static int	pfkey_flow(int, u_int8_t, u_int8_t, u_int8_t,
d60 1
a60 1
    struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
d177 1
a177 1
	sa_protocol.sadb_protocol_proto = IPPROTO_IP;
d618 1
a618 1
		rule->proto = IPSEC_ESP;
d621 1
a621 1
		rule->proto = IPSEC_AH;
d624 1
a624 1
		rule->proto = IPSEC_IPCOMP;
d627 1
a627 1
		rule->proto = IPSEC_IPIP;
d721 3
a723 1
			/* XXX nothing yet? */
d875 1
a875 1
		switch (r->proto) {
d906 2
a907 1
			    r->src, r->dst, r->local, r->peer, r->auth, r->flowtype);
d912 2
a913 1
			    r->src, r->dst, NULL, NULL, NULL, r->flowtype);
d919 1
a919 1
		switch (r->proto) {
@


1.33
log
@add support for special "bypass" and "deny" flows.

ok hshoexer@@, thanks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.32 2005/12/06 14:27:57 markus Exp $	*/
d46 2
a47 1
		    struct ipsec_addr_wrap *, struct ipsec_auth *, u_int8_t);
d61 2
a62 1
    struct ipsec_addr_wrap *peer, struct ipsec_auth *auth, u_int8_t flowtype)
d65 2
a66 1
	struct sadb_address	 sa_src, sa_dst, sa_peer, sa_smask, sa_dmask;
d69 1
a69 1
	struct sockaddr_storage	 ssrc, sdst, speer, smask, dmask;
d110 16
d138 1
a138 1
		return -1;
d197 12
a208 4
	bzero(&sa_peer, sizeof(sa_peer));
	sa_peer.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	sa_peer.sadb_address_len =
	    (sizeof(sa_peer) + ROUNDUP(speer.ss_len)) / 8;
d252 11
a639 1
#ifdef notyet
a657 1
#endif
d904 1
a904 1
			    r->src, r->dst, r->peer, r->auth, r->flowtype);
d909 1
a909 1
			    r->src, r->dst, NULL, NULL, r->flowtype);
@


1.32
log
@ipip support: ip-in-ip w/o gif(4); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.31 2005/11/24 11:52:07 hshoexer Exp $	*/
d142 6
@


1.31
log
@Remove old-style keyed sha1/md5.  We only support hmac-sha1/md5.
Noticed the hard way by <raff at brodewicz dot pl>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.30 2005/11/12 16:41:39 deraadt Exp $	*/
d361 1
a361 1
	if (tmode == IPSEC_TUNNEL)
d447 1
a447 1
	    SADB_X_SATYPE_IPCOMP) { /* XXX ENCNULL */
d582 3
d841 3
d885 3
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.29 2005/11/12 12:00:53 hshoexer Exp $	*/
a384 6
			break;
		case AUTHXF_MD5:
			sa.sadb_sa_auth = SADB_X_AALG_MD5;
			break;
		case AUTHXF_SHA1:
			sa.sadb_sa_auth = SADB_X_AALG_SHA1;
@


1.29
log
@handle transport/tunnel mode
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.28 2005/11/06 22:51:51 hshoexer Exp $	*/
d67 2
a68 2
	struct iovec	 	 iov[IOV_CNT];
	ssize_t		 	 n;
d317 3
a319 3
	struct iovec	 	iov[IOV_CNT];
	ssize_t		 	n;
	int		 	iov_cnt, len, ret = 0;
d818 1
a818 1
		
@


1.28
log
@Improved address and address mask handling, derived from pfctl stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.27 2005/11/06 10:52:27 hshoexer Exp $	*/
d50 1
a50 1
		    struct ipsec_key *);
d310 1
a310 1
    struct ipsec_key *enckey)
d361 3
d892 2
a893 1
			    r->src, r->dst, r->xfs, r->authkey, r->enckey);
d897 1
a897 1
			    r->src, r->dst, r->xfs, NULL, NULL);
@


1.27
log
@better handling of ip addresses, prepare for v6.  Partially derived from diff
by todd@@.  Work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.26 2005/10/30 19:50:24 hshoexer Exp $	*/
d45 2
a46 2
		    struct ipsec_addr *, struct ipsec_addr *,
		    struct ipsec_addr *, struct ipsec_auth *, u_int8_t);
d48 1
a48 1
		    struct ipsec_addr *, struct ipsec_addr *,
a51 1
static u_int8_t mask2prefixlen(const in_addr_t);
d59 2
a60 2
    struct ipsec_addr *src, struct ipsec_addr *dst, struct ipsec_addr *peer,
    struct ipsec_auth *auth, u_int8_t flowtype)
d307 4
a310 3
pfkey_sa(int sd, u_int8_t satype, u_int8_t action, u_int32_t spi, struct
    ipsec_addr *src, struct ipsec_addr *dst, struct ipsec_transforms *xfs,
    struct ipsec_key *authkey, struct ipsec_key *enckey)
a563 9
static u_int8_t
mask2prefixlen(const in_addr_t ina)
{
	if (ina == 0)
		return 0;
	else
		return (33 - ffs(ntohl(ina)));
}

d600 1
a600 1
			rule->local = calloc(1, sizeof(struct ipsec_addr));
d607 1
a607 1
				    &rule->local->addressv4,
d609 1
a609 2
				memset(&rule->local->mask.mask32, 0xff,
				    sizeof(u_int32_t));
a610 1
				rule->local->prefixlen = 32;
d623 1
a623 1
			rule->peer = calloc(1, sizeof(struct ipsec_addr));
d632 1
a632 2
				memset(&rule->peer->mask.mask32, 0xff,
				    sizeof(u_int32_t));
a633 1
				rule->peer->prefixlen = 32;
d726 1
a726 1
				    sizeof(struct ipsec_addr));
d749 1
a749 1
				    sizeof(struct ipsec_addr));
d774 1
a774 1
				    sizeof(struct ipsec_addr));
a784 2
				rule->src->prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
d798 1
a798 1
				    sizeof(struct ipsec_addr));
a808 2
				rule->dst->prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
@


1.26
log
@add support for ipcomp.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.25 2005/10/17 07:31:44 hshoexer Exp $	*/
d52 1
d78 1
a78 1
		((struct sockaddr_in *)&ssrc)->sin_addr = src->v4;
d81 1
a81 1
		((struct sockaddr_in *)&smask)->sin_addr = src->v4mask.mask;
d95 1
a95 1
		((struct sockaddr_in *)&sdst)->sin_addr = dst->v4;
d98 1
a98 1
		((struct sockaddr_in *)&dmask)->sin_addr = dst->v4mask.mask;
d112 2
a113 1
			((struct sockaddr_in *)&speer)->sin_addr = peer->v4;
d324 1
a324 1
		((struct sockaddr_in *)&ssrc)->sin_addr = src->v4;
d337 1
a337 1
		((struct sockaddr_in *)&sdst)->sin_addr = dst->v4;
d564 9
d581 1
d616 3
a618 2
				    &rule->local->v4, sizeof(struct in_addr));
				memset(&rule->local->v4mask, 0xff,
d621 1
d641 3
a643 2
				    &rule->peer->v4, sizeof(struct in_addr));
				memset(&rule->peer->v4mask, 0xff,
d646 1
d747 2
a748 1
				    &rule->src->v4, sizeof(struct in_addr));
d770 2
a771 1
				    &rule->dst->v4, sizeof(struct in_addr));
d794 2
a795 2
				bcopy(&((struct sockaddr_in *)sa)->sin_addr,
				    &rule->src->v4mask.mask,
d798 2
d820 2
a821 2
				bcopy(&((struct sockaddr_in *)sa)->sin_addr,
				    &rule->dst->v4mask.mask,
d824 2
@


1.25
log
@parse correctly flows using ipcomp.  Glitch noticed by jared rr spiegel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.24 2005/10/16 19:52:19 hshoexer Exp $	*/
d425 13
d447 2
a448 1
	if (action == SADB_ADD && !authkey && !enckey) { /* XXX ENCNULL */
d580 1
a580 1
		rule->proto = IPSEC_COMP;
d833 3
a835 1
		case IPSEC_COMP:
d871 3
@


1.24
log
@cleanup messages generated by err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.23 2005/08/22 17:26:46 hshoexer Exp $	*/
d566 2
@


1.23
log
@Teach ipsecctl to control isakmpd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.22 2005/08/09 12:37:45 hshoexer Exp $	*/
d181 1
a181 1
			err(1, "calloc");
d195 1
a195 1
			err(1, "calloc");
d535 1
a535 1
		err(1, NULL);
d583 1
a583 1
				err(1, "malloc");
d606 1
a606 1
				err(1, "malloc");
d630 1
a630 1
					err(1, "calloc");
d635 1
a635 1
				err(1, "calloc");
d649 1
a649 1
					err(1, "calloc");
d654 1
a654 1
				err(1, "calloc");
d709 1
a709 1
					err(1, "calloc");
d731 1
a731 1
					err(1, "calloc");
d755 1
a755 1
					err(1, "calloc");
d779 1
a779 1
					err(1, "calloc");
d924 1
a924 1
		err(1, "failed to open PF_KEY socket");
@


1.22
log
@Rewrite handling of transforms.  Now both ah and esp can be specified and
validated correctly.  Unbreaks ah.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.21 2005/08/08 14:19:16 hshoexer Exp $	*/
d834 1
a834 1
		case PFK_ACTION_ADD:
d838 1
a838 1
		case PFK_ACTION_DELETE:
d861 1
a861 1
		case PFK_ACTION_ADD:
d865 1
a865 1
		case PFK_ACTION_DELETE:
@


1.21
log
@pfkey pieces for static keying, enable static keying
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.20 2005/08/08 09:15:09 hshoexer Exp $	*/
d48 2
a49 2
		    struct ipsec_addr *, struct ipsec_addr *, const struct
		    ipsec_xf *, const struct ipsec_xf *, struct ipsec_key *,
d306 3
a308 4
pfkey_sa(int sd, u_int8_t satype, u_int8_t action, u_int32_t spi,
    struct ipsec_addr *src, struct ipsec_addr *dst, const struct ipsec_xf
    *authxf, const struct ipsec_xf *encxf, struct ipsec_key *authkey,
    struct ipsec_key *enckey)
d359 2
a360 2
	if (authxf) {
		switch (authxf->id) {
d389 1
a389 1
			    authxf->id);
d392 2
a393 2
	if (encxf) {
		switch (encxf->id) {
d421 2
a422 1
			warnx("unsupported encryption algorithm %d", encxf->id);
d863 1
a863 2
			    r->src, r->dst, r->encxf, r->authxf,
			    r->authkey, r->enckey);
d867 1
a867 1
			    r->src, r->dst, r->encxf, r->authxf, NULL, NULL);
@


1.20
log
@prepare for static keying
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.19 2005/08/05 14:39:02 hshoexer Exp $	*/
d48 2
a49 1
		    struct ipsec_addr *, struct ipsec_addr *,
d307 3
a309 1
    struct ipsec_addr *src, struct ipsec_addr *dst, struct ipsec_key *key)
d314 1
a314 1
	struct sadb_key		sa_key;
d360 66
d434 17
a450 10
	if (action == SADB_ADD) {
		if (!key) {
			warnx("no key specified");
			return -1;
		}
		bzero(&sa_key, sizeof(sa_key));
		sa_key.sadb_key_len = (sizeof(sa_key) + ((key->len + 7) / 8)
		    * 8) / 8;
		sa_key.sadb_key_exttype = SADB_EXT_KEY_AUTH;
		sa_key.sadb_key_bits = 8 * key->len;
d484 4
a487 4
	if (action == SADB_ADD) {
		/* key */
		iov[iov_cnt].iov_base = &sa_key;
		iov[iov_cnt].iov_len = sizeof(sa_key);
d489 13
a501 3
		iov[iov_cnt].iov_base = key->data;
		iov[iov_cnt].iov_len = ((key->len + 7) / 8) * 8;
		smsg.sadb_msg_len += sa_key.sadb_key_len;
d848 6
d863 2
a864 1
			    r->src, r->dst, r->authkey);
d868 1
a868 1
			    r->src, r->dst, r->authkey);
@


1.19
log
@prepare for authentication and encryption keys, not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.18 2005/08/03 15:27:01 hshoexer Exp $	*/
d761 7
a767 1
		satype = SADB_X_SATYPE_TCPSIGNATURE;
@


1.18
log
@be more careful when using struct ipsec_auth, might be NULL now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.17 2005/08/02 15:47:25 hshoexer Exp $	*/
d765 1
a765 1
			    r->src, r->dst, r->key);
d769 1
a769 1
			    r->src, r->dst, r->key);
@


1.17
log
@Make use of struct ipsec_auth dynamic.
Do not pass IDs to kernel when deleting flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.16 2005/07/09 21:31:24 hshoexer Exp $	*/
d540 7
d558 7
@


1.16
log
@also bail out when pfkey returns ESRCH (eg. trying to delete a non-existing SA)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.15 2005/07/09 21:17:46 hshoexer Exp $	*/
d46 1
a46 1
		    struct ipsec_addr *, struct ipsec_auth, u_int8_t);
d59 1
a59 1
    struct ipsec_auth auth, u_int8_t flowtype)
d175 2
a176 2
	if (auth.srcid) {
		len = ROUNDUP(strlen(auth.srcid) + 1) + sizeof(*sa_srcid);
d182 1
a182 1
		sa_srcid->sadb_ident_type = auth.idtype;
d186 2
a187 2
		strlcpy((char *)(sa_srcid + 1), auth.srcid,
		    ROUNDUP(strlen(auth.srcid) + 1));
d189 2
a190 2
	if (auth.dstid) {
		len = ROUNDUP(strlen(auth.dstid) + 1) + sizeof(*sa_dstid);
d196 1
a196 1
		sa_dstid->sadb_ident_type = auth.idtype;
d200 2
a201 2
		strlcpy((char *)(sa_dstid + 1), auth.dstid,
		    ROUNDUP(strlen(auth.dstid) + 1));
d540 2
a541 2
			rule->auth.srcid = calloc(1, len);
			if (rule->auth.srcid == NULL)
d544 1
a544 1
			strlcpy(rule->auth.srcid, (char *)(sident + 1), len);
d552 2
a553 2
			rule->auth.dstid = calloc(1, len);
			if (rule->auth.dstid == NULL)
d556 1
a556 1
			strlcpy(rule->auth.dstid, (char *)(sident + 1), len);
d741 1
a741 1
			    r->src, r->dst, NULL, r->auth, r->flowtype);
@


1.15
log
@small cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.14 2005/07/09 21:05:02 hshoexer Exp $	*/
d366 4
d444 2
a445 6
		if (errno == ESRCH)
			return 0;
		else {
			warn("PF_KEY returned error");
			return -1;
		}
@


1.14
log
@Provide infrastructure for adding/deleting SAs, will be used by tcpmd5 and
manual keying.  Not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.13 2005/07/07 22:00:36 hshoexer Exp $	*/
d61 8
a68 8
	struct sadb_msg	 smsg;
	struct sadb_address sa_src, sa_dst, sa_peer, sa_smask, sa_dmask;
	struct sadb_protocol sa_flowtype, sa_protocol;
	struct sadb_ident *sa_srcid, *sa_dstid;
	struct sockaddr_storage ssrc, sdst, speer, smask, dmask;
	struct iovec	 iov[IOV_CNT];
	ssize_t		 n;
	int		 iov_cnt, len, ret = 0;
d308 8
a315 8
	struct sadb_msg  smsg;
	struct sadb_sa	 sa;
	struct sadb_address sa_src, sa_dst;
	struct sadb_key	 sa_key;
	struct sockaddr_storage ssrc, sdst;
	struct iovec	 iov[IOV_CNT];
	ssize_t		 n;
	int		 iov_cnt, len, ret = 0;
d487 1
a487 1
	    ext = (struct sadb_ext *)((u_int8_t *)ext + 
d754 1
a754 1
			ret = pfkey_sa(fd, satype, SADB_DELETE, r->spi, 
@


1.13
log
@set flow type (use, require, etc.) when a rule is created.  Up to now this was
done while crafting the corresponding pfkey message.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.12 2005/07/07 21:13:00 hshoexer Exp $	*/
d44 1
a44 1
static int pfkey_flow(int, u_int8_t, u_int8_t, u_int8_t, struct ipsec_addr *,
d46 4
a49 1
		    struct ipsec_auth, u_int8_t);
d305 123
d709 23
a731 11
	switch (r->proto) {
	case IPSEC_ESP:
		satype = SADB_SATYPE_ESP;
		break;
	case IPSEC_AH:
		satype = SADB_SATYPE_AH;
		break;
	case IPSEC_COMP:
	default:
		return -1;
	}
d733 28
a760 8
	switch (r->direction) {
	case IPSEC_IN:
		direction = IPSP_DIRECTION_IN;
		break;
	case IPSEC_OUT:
		direction = IPSP_DIRECTION_OUT;
		break;
	default:
a761 1
	}
a762 13
	switch (action) {
	case PFK_ACTION_ADD:
		ret = pfkey_flow(fd, satype, SADB_X_ADDFLOW, direction, r->src,
		    r->dst, r->peer, r->auth, r->flowtype);
		break;
	case PFK_ACTION_DELETE:
		/* No peer for flow deletion. */
		ret = pfkey_flow(fd, satype, SADB_X_DELFLOW, direction, r->src,
		    r->dst, NULL, r->auth, r->flowtype);
		break;
	default:
		return -1;
	}
@


1.12
log
@Do not mix rule types with flow types
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.11 2005/07/07 20:58:28 hshoexer Exp $	*/
d46 1
a46 1
		    struct ipsec_auth);
d56 1
a56 1
    struct ipsec_auth auth)
d131 2
a132 1
	if (direction == IPSP_DIRECTION_IN)
d134 2
a135 1
	else
d137 5
d609 1
a609 1
		    r->dst, r->peer, r->auth);
d614 1
a614 1
		    r->dst, NULL, r->auth);
@


1.11
log
@add prototype for pfkey_parse()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.10 2005/06/30 18:50:55 hshoexer Exp $	*/
d445 1
a445 1
				rule->type = TYPE_USE;
d448 1
a448 1
				rule->type = TYPE_ACQUIRE;
d451 1
a451 1
				rule->type = TYPE_REQUIRE;
d454 1
a454 1
				rule->type = TYPE_DENY;
d457 1
a457 1
				rule->type = TYPE_BYPASS;
d460 1
a460 1
				rule->type = TYPE_DONTACQ;
d463 1
a463 1
				rule->type = TYPE_UNKNOWN;
@


1.10
log
@Next step, again no functional change yet
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.9 2005/06/30 18:27:14 hshoexer Exp $	*/
d48 1
@


1.9
log
@Prepare for flow deletion, no functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.8 2005/05/27 19:55:21 hshoexer Exp $	*/
d103 10
a112 9
	switch (peer->af) {
	case AF_INET:
		((struct sockaddr_in *)&speer)->sin_addr = peer->v4;
		speer.ss_len = sizeof(struct sockaddr_in);
		speer.ss_family = AF_INET;
		break;
	case AF_INET6:
	default:
		warnx("unsupported address family %d", peer->af);
d114 1
d207 9
a215 7
	iov[iov_cnt].iov_base = &sa_peer;
	iov[iov_cnt].iov_len = sizeof(sa_peer);
	iov_cnt++;
	iov[iov_cnt].iov_base = &speer;
	iov[iov_cnt].iov_len = ROUNDUP(speer.ss_len);
	smsg.sadb_msg_len += sa_peer.sadb_address_len;
	iov_cnt++;
d572 2
a573 10
	u_int8_t	satype, direction, sa_act;

	switch (action) {
	case PFK_ACTION_ADD:
		sa_act = SADB_X_ADDFLOW;
		break;
	case PFK_ACTION_DELETE:
	default:
		return -1;
	}
d598 14
a611 2
	if (pfkey_flow(fd, satype, SADB_X_ADDFLOW, direction, r->src, r->dst,
	    r->peer, r->auth) < 0)
@


1.8
log
@show flow type (require, use, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.7 2005/05/27 19:15:44 hshoexer Exp $	*/
d49 1
a49 1
int		pfkey_ipsec_establish(struct ipsec_rule *);
d566 1
a566 1
pfkey_ipsec_establish(struct ipsec_rule *r)
d568 10
a577 2
	u_int8_t	satype;
	u_int8_t	direction;
@


1.7
log
@Use SADB_SATYPE_* instead of IPPROTO_*
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.6 2005/05/27 15:36:02 hshoexer Exp $	*/
d437 23
@


1.6
log
@When looping over pfkey messages, make sure extension length is > 0.
While around, do some minor tweaks in a not yet used code path.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.5 2005/05/25 17:23:46 hshoexer Exp $	*/
d335 1
a335 1
	case IPPROTO_ESP:
d338 1
a338 1
	case IPPROTO_AH:
d341 1
a341 1
	case IPPROTO_IPCOMP:
@


1.5
log
@rearrange order of messages sent to the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.2 2005/04/04 22:22:55 hshoexer Exp $	*/
d348 1
a348 1
	    msg->sadb_msg_len * PFKEYV2_CHUNK;
a350 1

d353 1
a353 1
#if 0
d357 2
a358 2
			rule->peer = calloc(1, sizeof(struct ipsec_addr));
			if (rule->peer == NULL)
d364 2
a365 2
				    &rule->peer->v4, sizeof(struct in_addr));
				memset(&rule->peer->v4mask, 0xff,
d367 1
a367 1
				rule->peer->af = AF_INET;
@


1.4
log
@set incoming flows to "use", outgoing to "require"
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.3 2005/05/25 17:10:26 hshoexer Exp $	*/
d198 6
d213 3
a215 4
	/* add flow type */
	iov[iov_cnt].iov_base = &sa_flowtype;
	iov[iov_cnt].iov_len = sizeof(sa_flowtype);
	smsg.sadb_msg_len += sa_flowtype.sadb_protocol_len;
d217 3
a219 5

	/* add protocol */
	iov[iov_cnt].iov_base = &sa_protocol;
	iov[iov_cnt].iov_len = sizeof(sa_protocol);
	smsg.sadb_msg_len += sa_protocol.sadb_protocol_len;
d222 1
a222 1
	/* add flow masks */
a230 8
	iov[iov_cnt].iov_base = &sa_dmask;
	iov[iov_cnt].iov_len = sizeof(sa_dmask);
	iov_cnt++;
	iov[iov_cnt].iov_base = &dmask;
	iov[iov_cnt].iov_len = ROUNDUP(dmask.ss_len);
	smsg.sadb_msg_len += sa_dmask.sadb_address_len;
	iov_cnt++;

d240 7
a246 3
	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
d248 5
a252 3
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
@


1.3
log
@prepare for new sysctl interface, not used yet
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.2 2005/04/04 22:22:55 hshoexer Exp $	*/
d127 5
a131 1
	sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
@


1.2
log
@fix cvs id tags
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d36 1
a37 1
#define PFKEYV2_CHUNK sizeof(u_int64_t)
d317 219
@


1.1
log
@Add ipsecctl utility, work in progress

ok deraadt
@
text
@d1 1
a1 1
/*	$Id: pfkey.c,v 1.4 2005/02/03 16:26:54 hshoexer Exp $	 */
@

