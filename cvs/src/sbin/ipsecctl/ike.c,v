head	1.81;
access;
symbols
	OPENBSD_6_2:1.81.0.10
	OPENBSD_6_2_BASE:1.81
	OPENBSD_6_1:1.81.0.8
	OPENBSD_6_1_BASE:1.81
	OPENBSD_6_0:1.81.0.4
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.78.0.6
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.77.0.4
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.74.0.2
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.69.0.4
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.69.0.2
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.67.0.4
	OPENBSD_4_8_BASE:1.67
	OPENBSD_4_7:1.67.0.2
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.65.0.6
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.65.0.2
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.63.0.2
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.81
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.80;
commitid	CLwtYUTkBZ3FXV1w;

1.80
date	2015.05.25.19.29.36;	author naddy;	state Exp;
branches;
next	1.79;
commitid	30znlICNP5AFkaPd;

1.79
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	Uu5nFG3wCl0LACBb;

1.78
date	2013.08.25.23.15.20;	author mikeb;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.17.20.38.28;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2012.09.15.13.17.48;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2012.08.30.20.03.18;	author naddy;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.13.19.36.07;	author mikeb;	state Exp;
branches;
next	1.73;

1.73
date	2012.07.10.13.58.33;	author lteo;	state Exp;
branches;
next	1.72;

1.72
date	2012.07.09.21.06.51;	author lteo;	state Exp;
branches;
next	1.71;

1.71
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.70;

1.70
date	2011.11.08.13.26.06;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2010.10.15.12.11.10;	author mikeb;	state Exp;
branches;
next	1.68;

1.68
date	2010.09.22.14.04.09;	author mikeb;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.04.11.39.32;	author jsing;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.04.15.05.50;	author jsing;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.20.14.36.19;	author mpf;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.01.15.00.53;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2008.02.22.23.51.31;	author hshoexer;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.04.11.06.02;	author hshoexer;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.16.20.51.01;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.19.09.00.46;	author hshoexer;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.18.00.08.04;	author msf;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.30.21.35.34;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.30.16.17.58;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.30.15.51.28;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.24.13.52.13;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.24.08.07.18;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.21.13.51.17;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.01.03.12.14;	author mcbride;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.01.03.10.02;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.18.13.45.45;	author hshoexer;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.30.12.18.10;	author msf;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.29.18.10.31;	author msf;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.29.17.52.40;	author naddy;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.21.12.34.52;	author hshoexer;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.18.18.18.01;	author hshoexer;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.16.18.46.26;	author hshoexer;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.15.16.57.24;	author hshoexer;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.13.16.13.41;	author naddy;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.10.19.21.10;	author hshoexer;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.08.22.34.30;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.08.21.15.21;	author naddy;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.08.20.52.43;	author todd;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.08.18.25.50;	author hshoexer;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.02.15.43.37;	author naddy;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.02.05.59.31;	author hshoexer;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.02.03.40.26;	author hshoexer;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.01.18.03.40;	author msf;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.01.06.46.35;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.01.06.14.05;	author todd;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.01.02.19.22;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.31.02.28.35;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.31.02.26.41;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.28.08.30.04;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.27.17.21.40;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.15.07.50.26;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.13.11.55.07;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.31.14.11.39;	author hshoexer;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.31.14.02.08;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.31.13.13.51;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.20.17.09.38;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.20.16.49.12;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.07.00.19.58;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.03.13.39.29;	author naddy;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.02.14.42.23;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.17.00.05.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.16.23.57.20;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.28.19.18.43;	author naddy;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.28.10.53.12;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.12.09.44.06;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.24.11.52.07;	author hshoexer;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.12.16.41.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.06.22.51.51;	author hshoexer;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.06.10.52.27;	author hshoexer;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.28.07.18.47;	author hshoexer;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.16.19.52.19;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.22.15.07.29;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.20.17.30.58;	author hshoexer;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.20.17.29.19;	author hshoexer;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.22.17.26.46;	author hshoexer;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@/*	$OpenBSD: ike.c,v 1.80 2015/05/25 19:29:36 naddy Exp $	*/
/*
 * Copyright (c) 2005 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ipsecctl.h"

static void	ike_section_general(struct ipsec_rule *, FILE *);
static void	ike_section_peer(struct ipsec_rule *, FILE *);
static void	ike_section_ids(struct ipsec_rule *, FILE *);
static void	ike_section_ipsec(struct ipsec_rule *, FILE *);
static int	ike_section_p1(struct ipsec_rule *, FILE *);
static int	ike_section_p2(struct ipsec_rule *, FILE *);
static void	ike_section_p2ids(struct ipsec_rule *, FILE *);
static int	ike_connect(struct ipsec_rule *, FILE *);
static int	ike_gen_config(struct ipsec_rule *, FILE *);
static int	ike_delete_config(struct ipsec_rule *, FILE *);
static void	ike_setup_ids(struct ipsec_rule *);

int		ike_print_config(struct ipsec_rule *, int);
int		ike_ipsec_establish(int, struct ipsec_rule *, const char *);

#define	SET	"C set "
#define	ADD	"C add "
#define	DELETE	"C rms "
#define	RMV	"C rmv "

#define CONF_DFLT_DYNAMIC_DPD_CHECK_INTERVAL	5
#define CONF_DFLT_DYNAMIC_CHECK_INTERVAL	30

char *ike_id_types[] = {
	"", "", "IPV4_ADDR", "IPV6_ADDR", "FQDN", "USER_FQDN"
};

static void
ike_section_general(struct ipsec_rule *r, FILE *fd)
{
	if (r->ikemode == IKE_DYNAMIC) {
		fprintf(fd, SET "[General]:Check-interval=%d force\n",
		    CONF_DFLT_DYNAMIC_CHECK_INTERVAL);
		fprintf(fd, SET "[General]:DPD-check-interval=%d force\n",
		    CONF_DFLT_DYNAMIC_DPD_CHECK_INTERVAL);
	}
}

static void
ike_section_peer(struct ipsec_rule *r, FILE *fd)
{
	if (r->peer)
		fprintf(fd, SET "[Phase 1]:%s=%s force\n", r->peer->name,
		    r->p1name);
	else
		fprintf(fd, SET "[Phase 1]:Default=%s force\n", r->p1name);
	fprintf(fd, SET "[%s]:Phase=1 force\n", r->p1name);
	if (r->peer)
		fprintf(fd, SET "[%s]:Address=%s force\n", r->p1name,
		    r->peer->name);
	if (r->local)
		fprintf(fd, SET "[%s]:Local-address=%s force\n", r->p1name,
		    r->local->name);
	if (r->ikeauth->type == IKE_AUTH_PSK)
		fprintf(fd, SET "[%s]:Authentication=%s force\n", r->p1name,
		    r->ikeauth->string);
}

static void
ike_section_ids(struct ipsec_rule *r, FILE *fd)
{
	char myname[HOST_NAME_MAX+1];

	if (r->auth == NULL)
		return;

	if (r->ikemode == IKE_DYNAMIC && r->auth->srcid == NULL) {
		if (gethostname(myname, sizeof(myname)) == -1)
			err(1, "ike_section_ids: gethostname");
		if ((r->auth->srcid = strdup(myname)) == NULL)
			err(1, "ike_section_ids: strdup");
		r->auth->srcid_type = ID_FQDN;
	}
	if (r->auth->srcid) {
		fprintf(fd, SET "[%s]:ID=id-%s force\n", r->p1name,
		    r->auth->srcid);
		fprintf(fd, SET "[id-%s]:ID-type=%s force\n", r->auth->srcid,
		    ike_id_types[r->auth->srcid_type]);
		if (r->auth->srcid_type == ID_IPV4 ||
		    r->auth->srcid_type == ID_IPV6)
			fprintf(fd, SET "[id-%s]:Address=%s force\n",
			    r->auth->srcid, r->auth->srcid);
		else
			fprintf(fd, SET "[id-%s]:Name=%s force\n",
			    r->auth->srcid, r->auth->srcid);
	}
	if (r->auth->dstid) {
		fprintf(fd, SET "[%s]:Remote-ID=id-%s force\n", r->p1name,
		    r->auth->dstid);
		fprintf(fd, SET "[id-%s]:ID-type=%s force\n", r->auth->dstid,
		    ike_id_types[r->auth->dstid_type]);
		if (r->auth->dstid_type == ID_IPV4 ||
		    r->auth->dstid_type == ID_IPV6)
			fprintf(fd, SET "[id-%s]:Address=%s force\n",
			    r->auth->dstid, r->auth->dstid);
		else
			fprintf(fd, SET "[id-%s]:Name=%s force\n",
			    r->auth->dstid, r->auth->dstid);
	}
}

static void
ike_section_ipsec(struct ipsec_rule *r, FILE *fd)
{
	fprintf(fd, SET "[%s]:Phase=2 force\n", r->p2name);
	fprintf(fd, SET "[%s]:ISAKMP-peer=%s force\n", r->p2name, r->p1name);
	fprintf(fd, SET "[%s]:Configuration=phase2-%s force\n", r->p2name,
	    r->p2name);
	fprintf(fd, SET "[%s]:Local-ID=%s force\n", r->p2name, r->p2lid);
	if (r->p2nid)
		fprintf(fd, SET "[%s]:NAT-ID=%s force\n", r->p2name, r->p2nid);
	fprintf(fd, SET "[%s]:Remote-ID=%s force\n", r->p2name, r->p2rid);

	if (r->tag)
		fprintf(fd, SET "[%s]:PF-Tag=%s force\n", r->p2name, r->tag);
}

static int
ike_section_p2(struct ipsec_rule *r, FILE *fd)
{
	char	*exchange_type, *key_length, *transform, *p;
	char	*enc_alg, *auth_alg, *group_desc, *encap;
	int	needauth = 1;
	int	num_print = 0;

	switch (r->p2ie) {
	case IKE_QM:
		exchange_type = "QUICK_MODE";
		break;
	default:
		warnx("illegal phase 2 ike mode %d", r->p2ie);
		return (-1);
	}

	fprintf(fd, SET "[phase2-%s]:EXCHANGE_TYPE=%s force\n", r->p2name,
	    exchange_type);
	fprintf(fd, SET "[phase2-%s]:Suites=phase2-suite-%s force\n", r->p2name,
	    r->p2name);

	fprintf(fd, SET "[phase2-suite-%s]:Protocols=phase2-protocol-%s "
	    "force\n", r->p2name, r->p2name);

	fprintf(fd, SET "[phase2-protocol-%s]:PROTOCOL_ID=", r->p2name);

	switch (r->satype) {
	case IPSEC_ESP:
		fprintf(fd, "IPSEC_ESP");
		break;
	case IPSEC_AH:
		fprintf(fd, "IPSEC_AH");
		break;
	default:
		warnx("illegal satype %d", r->satype);
		return (-1);
	}
	fprintf(fd, " force\n");

	key_length = NULL;
	enc_alg = NULL;
	if (r->p2xfs && r->p2xfs->encxf) {
		if (r->satype == IPSEC_ESP) {
			switch (r->p2xfs->encxf->id) {
			case ENCXF_3DES_CBC:
				enc_alg = "3DES";
				break;
			case ENCXF_AES:
				enc_alg = "AES";
				key_length = "128,128:256";
				break;
			case ENCXF_AES_128:
				enc_alg = "AES";
				key_length = "128,128:128";
				break;
			case ENCXF_AES_192:
				enc_alg = "AES";
				key_length = "192,192:192";
				break;
			case ENCXF_AES_256:
				enc_alg = "AES";
				key_length = "256,256:256";
				break;
			case ENCXF_AESCTR:
				enc_alg = "AES_CTR";
				key_length = "128,128:128";
				break;
			case ENCXF_AES_128_CTR:
				enc_alg = "AES_CTR";
				key_length = "128,128:128";
				break;
			case ENCXF_AES_192_CTR:
				enc_alg = "AES_CTR";
				key_length = "192,192:192";
				break;
			case ENCXF_AES_256_CTR:
				enc_alg = "AES_CTR";
				key_length = "256,256:256";
				break;
			case ENCXF_AES_128_GCM:
				enc_alg = "AES_GCM_16";
				key_length = "128,128:128";
				needauth = 0;
				break;
			case ENCXF_AES_192_GCM:
				enc_alg = "AES_GCM_16";
				key_length = "192,192:192";
				needauth = 0;
				break;
			case ENCXF_AES_256_GCM:
				enc_alg = "AES_GCM_16";
				key_length = "256,256:256";
				needauth = 0;
				break;
			case ENCXF_AES_128_GMAC:
				enc_alg = "AES_GMAC";
				key_length = "128,128:128";
				needauth = 0;
				break;
			case ENCXF_AES_192_GMAC:
				enc_alg = "AES_GMAC";
				key_length = "192,192:192";
				needauth = 0;
				break;
			case ENCXF_AES_256_GMAC:
				enc_alg = "AES_GMAC";
				key_length = "256,256:256";
				needauth = 0;
				break;
			case ENCXF_BLOWFISH:
				enc_alg = "BLOWFISH";
				key_length = "128,96:192";
				break;
			case ENCXF_CAST128:
				enc_alg = "CAST";
				break;
			case ENCXF_NULL:
				enc_alg = "NULL";
				needauth = 0;
				break;
			default:
				warnx("illegal transform %s",
				    r->p2xfs->encxf->name);
				return (-1);
			}
		} else {
			warnx("illegal transform %s", r->p2xfs->encxf->name);
			return (-1);
		}
	} else if (r->satype == IPSEC_ESP) {
		enc_alg = "AES";
		key_length = "128,128:256";
	}

	switch (r->tmode) {
	case IPSEC_TUNNEL:
		encap = "TUNNEL";
		break;
	case IPSEC_TRANSPORT:
		encap = "TRANSPORT";
		break;
	default:
		warnx("illegal encapsulation mode %d", r->tmode);
		return (-1);
	}

	auth_alg = NULL;
	if (r->p2xfs && r->p2xfs->authxf) {
		switch (r->p2xfs->authxf->id) {
		case AUTHXF_HMAC_MD5:
			auth_alg = "MD5";
			break;
		case AUTHXF_HMAC_SHA1:
			auth_alg = "SHA";
			break;
		case AUTHXF_HMAC_RIPEMD160:
			auth_alg = "RIPEMD";
			break;
		case AUTHXF_HMAC_SHA2_256:
			auth_alg = "SHA2_256";
			break;
		case AUTHXF_HMAC_SHA2_384:
			auth_alg = "SHA2_384";
			break;
		case AUTHXF_HMAC_SHA2_512:
			auth_alg = "SHA2_512";
			break;
		default:
			warnx("illegal transform %s", r->p2xfs->authxf->name);
			return (-1);
		}
	} else if (needauth)
		auth_alg = "SHA2_256";

	group_desc = NULL;
	if (r->p2xfs && r->p2xfs->groupxf) {
		switch (r->p2xfs->groupxf->id) {
		case GROUPXF_NONE:
			break;
		case GROUPXF_768:
			group_desc = "MODP_768";
			break;
		case GROUPXF_1024:
			group_desc = "MODP_1024";
			break;
		case GROUPXF_1536:
			group_desc = "MODP_1536";
			break;
		case GROUPXF_2048:
			group_desc = "MODP_2048";
			break;
		case GROUPXF_3072:
			group_desc = "MODP_3072";
			break;
		case GROUPXF_4096:
			group_desc = "MODP_4096";
			break;
		case GROUPXF_6144:
			group_desc = "MODP_6144";
			break;
		case GROUPXF_8192:
			group_desc = "MODP_8192";
			break;
		default:
			warnx("illegal group %s", r->p2xfs->groupxf->name);
			return (-1);
		}
	} else
		group_desc = "MODP_3072";

	/* the transform name must not include "," */
	if (key_length && (p = strchr(key_length, ',')) != NULL)
		num_print = p - key_length;
	/*
	 * create a unique transform name, otherwise we cannot have
	 * multiple transforms per p2name.
	 */
	if (asprintf(&transform, "phase2-transform-%s-%s%.*s-%s-%s-%s",
	    r->p2name,
	    enc_alg ? enc_alg : "NONE",
	    num_print, key_length ? key_length : "",
	    auth_alg ? auth_alg : "NONE",
	    group_desc ? group_desc : "NONE",
	    encap) == -1)
		errx(1, "asprintf phase2-transform");

	fprintf(fd, SET "[phase2-protocol-%s]:Transforms=%s force\n",
	    r->p2name, transform);

	fprintf(fd, SET "[%s]:TRANSFORM_ID=%s force\n", transform,
	    r->satype == IPSEC_AH ?  auth_alg : enc_alg);
	if (key_length)
		fprintf(fd, SET "[%s]:KEY_LENGTH=%s force\n", transform,
		    key_length);
	fprintf(fd, SET "[%s]:ENCAPSULATION_MODE=%s force\n", transform, encap);
	if (auth_alg)
		fprintf(fd, SET "[%s]:AUTHENTICATION_ALGORITHM=HMAC_%s force\n",
		    transform, auth_alg);
	if (group_desc)
		fprintf(fd, SET "[%s]:GROUP_DESCRIPTION=%s force\n", transform,
		    group_desc);

	if (r->p2life && r->p2life->lt_seconds != -1) {
		fprintf(fd, SET "[%s]:Life=%s-life force\n",
		    transform, transform);
		fprintf(fd, SET "[%s-life]:LIFE_TYPE=SECONDS force\n",
		    transform);
		fprintf(fd, SET "[%s-life]:LIFE_DURATION=%d force\n",
		    transform, r->p2life->lt_seconds);
	} else
		fprintf(fd, SET "[%s]:Life=LIFE_QUICK_MODE force\n",
		    transform);

	free(transform);
	return (0);
}

static int
ike_section_p1(struct ipsec_rule *r, FILE *fd)
{
	char	*exchange_type, *key_length, *transform, *p;
	char	*enc_alg, *auth_alg, *group_desc, *auth_method;
	int	num_print = 0;

	switch (r->p1ie) {
	case IKE_MM:
		exchange_type = "ID_PROT";
		break;
	case IKE_AM:
		exchange_type = "AGGRESSIVE";
		break;
	default:
		warnx("illegal phase 1 ike mode %d", r->p1ie);
		return (-1);
	}

	fprintf(fd, SET "[%s]:Configuration=phase1-%s force\n", r->p1name,
	    r->p1name);
	fprintf(fd, SET "[phase1-%s]:EXCHANGE_TYPE=%s force\n", r->p1name,
	    exchange_type);

	key_length = NULL;
	if (r->p1xfs && r->p1xfs->encxf) {
		switch (r->p1xfs->encxf->id) {
		case ENCXF_3DES_CBC:
			enc_alg = "3DES";
			break;
		case ENCXF_AES:
			enc_alg = "AES";
			key_length = "128,128:256";
			break;
		case ENCXF_AES_128:
			enc_alg = "AES";
			key_length = "128,128:128";
			break;
		case ENCXF_AES_192:
			enc_alg = "AES";
			key_length = "192,192:192";
			break;
		case ENCXF_AES_256:
			enc_alg = "AES";
			key_length = "256,256:256";
			break;
		case ENCXF_BLOWFISH:
			enc_alg = "BLOWFISH";
			key_length = "128,96:192";
			break;
		case ENCXF_CAST128:
			enc_alg = "CAST";
			break;
		default:
			warnx("illegal transform %s", r->p1xfs->encxf->name);
			return (-1);
		}
	} else {
		enc_alg = "AES";
		key_length = "128,128:256";
	}

	if (r->p1xfs && r->p1xfs->authxf) {
		switch (r->p1xfs->authxf->id) {
		case AUTHXF_HMAC_MD5:
			auth_alg = "MD5";
			break;
		case AUTHXF_HMAC_SHA1:
			auth_alg = "SHA";
			break;
		case AUTHXF_HMAC_SHA2_256:
			auth_alg = "SHA2_256";
			break;
		case AUTHXF_HMAC_SHA2_384:
			auth_alg = "SHA2_384";
			break;
		case AUTHXF_HMAC_SHA2_512:
			auth_alg = "SHA2_512";
			break;
		default:
			warnx("illegal transform %s", r->p1xfs->authxf->name);
			return (-1);
		}
	} else
		auth_alg = "SHA";

	if (r->p1xfs && r->p1xfs->groupxf) {
		switch (r->p1xfs->groupxf->id) {
		case GROUPXF_768:
			group_desc = "MODP_768";
			break;
		case GROUPXF_1024:
			group_desc = "MODP_1024";
			break;
		case GROUPXF_1536:
			group_desc = "MODP_1536";
			break;
		case GROUPXF_2048:
			group_desc = "MODP_2048";
			break;
		case GROUPXF_3072:
			group_desc = "MODP_3072";
			break;
		case GROUPXF_4096:
			group_desc = "MODP_4096";
			break;
		case GROUPXF_6144:
			group_desc = "MODP_6144";
			break;
		case GROUPXF_8192:
			group_desc = "MODP_8192";
			break;
		default:
			warnx("illegal group %s", r->p1xfs->groupxf->name);
			return (-1);
		};
	} else
		group_desc = "MODP_3072";

	switch (r->ikeauth->type) {
	case IKE_AUTH_PSK:
		auth_method = "PRE_SHARED";
		break;
	case IKE_AUTH_RSA:
		auth_method = "RSA_SIG";
		break;
	default:
		warnx("illegal authentication method %u", r->ikeauth->type);
		return (-1);
	}

	/* the transform name must not include "," */
	if (key_length && (p = strchr(key_length, ',')) != NULL)
		num_print = p - key_length;
	/* create unique name for transform, see also ike_section_p2() */
	if (asprintf(&transform, "phase1-transform-%s-%s-%s-%s%.*s-%s",
	    r->p1name, auth_method, auth_alg, enc_alg,
	    num_print, key_length ? key_length : "",
	    group_desc) == -1)
		errx(1, "asprintf phase1-transform");

	fprintf(fd, ADD "[phase1-%s]:Transforms=%s force\n", r->p1name,
	    transform);
	fprintf(fd, SET "[%s]:AUTHENTICATION_METHOD=%s force\n", transform,
	    auth_method);
	fprintf(fd, SET "[%s]:HASH_ALGORITHM=%s force\n", transform, auth_alg);
	fprintf(fd, SET "[%s]:ENCRYPTION_ALGORITHM=%s_CBC force\n", transform,
	    enc_alg);
	if (key_length)
		fprintf(fd, SET "[%s]:KEY_LENGTH=%s force\n", transform,
		    key_length);
	fprintf(fd, SET "[%s]:GROUP_DESCRIPTION=%s force\n", transform,
	    group_desc);

	if (r->p1life && r->p1life->lt_seconds != -1) {
		fprintf(fd, SET "[%s]:Life=%s-life force\n",
		    transform, transform);
		fprintf(fd, SET "[%s-life]:LIFE_TYPE=SECONDS force\n",
		    transform);
		fprintf(fd, SET "[%s-life]:LIFE_DURATION=%d force\n",
		    transform, r->p1life->lt_seconds);
	} else
		fprintf(fd, SET "[%s]:Life=LIFE_MAIN_MODE force\n", transform);

	free(transform);
	return (0);
}

static void
ike_section_p2ids_net(struct ipsec_addr *iamask, sa_family_t af, char *name,
    char *p2xid, FILE *fd)
{
	char mask[NI_MAXHOST], *network, *p;
	struct sockaddr_storage sas;
	struct sockaddr *sa = (struct sockaddr *)&sas;

	bzero(&sas, sizeof(struct sockaddr_storage));
	bzero(mask, sizeof(mask));
	sa->sa_family = af;
	switch (af) {
	case AF_INET:
		sa->sa_len = sizeof(struct sockaddr_in);
		bcopy(&iamask->ipa,
		    &((struct sockaddr_in *)(sa))->sin_addr,
		    sizeof(struct in6_addr));
		break;
	case AF_INET6:
		sa->sa_len = sizeof(struct sockaddr_in6);
		bcopy(&iamask->ipa,
		    &((struct sockaddr_in6 *)(sa))->sin6_addr,
		    sizeof(struct in6_addr));
		break;
	}
	if (getnameinfo(sa, sa->sa_len, mask, sizeof(mask), NULL, 0,
	    NI_NUMERICHOST))
		errx(1, "could not get a numeric mask");

	if ((network = strdup(name)) == NULL)
		err(1, "ike_section_p2ids: strdup");
	if ((p = strrchr(network, '/')) != NULL)
		*p = '\0';

	fprintf(fd, SET "[%s]:ID-type=IPV%d_ADDR_SUBNET force\n",
	    p2xid, ((af == AF_INET) ? 4 : 6));
	fprintf(fd, SET "[%s]:Network=%s force\n", p2xid, network);
	fprintf(fd, SET "[%s]:Netmask=%s force\n", p2xid, mask);

	free(network);
}

static void
ike_section_p2ids(struct ipsec_rule *r, FILE *fd)
{
	char *p;
	struct ipsec_addr_wrap *src = r->src;
	struct ipsec_addr_wrap *dst = r->dst;

	if (src->netaddress) {
		ike_section_p2ids_net(&src->mask, src->af, src->name,
		    r->p2lid, fd);
	} else {
		fprintf(fd, SET "[%s]:ID-type=IPV%d_ADDR force\n",
		    r->p2lid, ((src->af == AF_INET) ? 4 : 6));
		if ((p = strrchr(src->name, '/')) != NULL)
			*p = '\0';
		fprintf(fd, SET "[%s]:Address=%s force\n", r->p2lid,
		    src->name);
	}

	if (src->srcnat && src->srcnat->netaddress) {
		ike_section_p2ids_net(&src->srcnat->mask, src->af, src->srcnat->name,
		    r->p2nid, fd);
	} else if (src->srcnat) {
		fprintf(fd, SET "[%s]:ID-type=IPV%d_ADDR force\n",
		    r->p2nid, ((src->af == AF_INET) ? 4 : 6));
		if ((p = strrchr(src->srcnat->name, '/')) != NULL)
			*p = '\0';
		fprintf(fd, SET "[%s]:Address=%s force\n", r->p2nid,
		    src->srcnat->name);
	}

	if (dst->netaddress) {
		ike_section_p2ids_net(&dst->mask, dst->af, dst->name,
		    r->p2rid, fd);
	} else {
		fprintf(fd, SET "[%s]:ID-type=IPV%d_ADDR force\n",
		    r->p2rid, ((dst->af == AF_INET) ? 4 : 6));
		if ((p = strrchr(dst->name, '/')) != NULL)
			*p = '\0';
		fprintf(fd, SET "[%s]:Address=%s force\n", r->p2rid,
		    dst->name);
	}
	if (r->proto) {
		fprintf(fd, SET "[%s]:Protocol=%d force\n",
		    r->p2lid, r->proto);
		fprintf(fd, SET "[%s]:Protocol=%d force\n",
		    r->p2rid, r->proto);
	}
	if (r->sport)
		fprintf(fd, SET "[%s]:Port=%d force\n", r->p2lid,
		    ntohs(r->sport));
	if (r->dport)
		fprintf(fd, SET "[%s]:Port=%d force\n", r->p2rid,
		    ntohs(r->dport));
}

static int
ike_connect(struct ipsec_rule *r, FILE *fd)
{
	switch (r->ikemode) {
	case IKE_ACTIVE:
	case IKE_DYNAMIC:
		fprintf(fd, ADD "[Phase 2]:Connections=%s\n", r->p2name);
		break;
	case IKE_PASSIVE:
		fprintf(fd, ADD "[Phase 2]:Passive-Connections=%s\n",
		    r->p2name);
		break;
	default:
		return (-1);
	}
	return (0);
}

static int
ike_gen_config(struct ipsec_rule *r, FILE *fd)
{
	ike_setup_ids(r);
	ike_section_general(r, fd);
	ike_section_peer(r, fd);
	if (ike_section_p1(r, fd) == -1) {
		return (-1);
	}
	ike_section_ids(r, fd);
	ike_section_ipsec(r, fd);
	if (ike_section_p2(r, fd) == -1) {
		return (-1);
	}
	ike_section_p2ids(r, fd);

	if (ike_connect(r, fd) == -1)
		return (-1);
	return (0);
}

static int
ike_delete_config(struct ipsec_rule *r, FILE *fd)
{
	ike_setup_ids(r);
#if 0
	switch (r->ikemode) {
	case IKE_ACTIVE:
	case IKE_DYNAMIC:
		fprintf(fd, "t %s\n", r->p2name);
		break;
	case IKE_PASSIVE:
		fprintf(fd, DELETE "[Phase 2]\n");
		fprintf(fd, "t %s\n", r->p2name);
		break;
	default:
		return (-1);
	}

	if (r->peer) {
		fprintf(fd, DELETE "[%s]\n", r->p1name);
		fprintf(fd, DELETE "[phase1-%s]\n", r->p1name);
	}
	if (r->auth) {
		if (r->auth->srcid)
			fprintf(fd, DELETE "[%s-ID]\n", r->auth->srcid);
		if (r->auth->dstid)
			fprintf(fd, DELETE "[%s-ID]\n", r->auth->dstid);
	}
	fprintf(fd, DELETE "[%s]\n", r->p2name);
	fprintf(fd, DELETE "[phase2-%s]\n", r->p2name);
	fprintf(fd, DELETE "[%s]\n", r->p2lid);
	fprintf(fd, DELETE "[%s]\n", r->p2rid);
#else
	fprintf(fd, "t %s\n", r->p2name);
	switch (r->ikemode) {
	case IKE_ACTIVE:
	case IKE_DYNAMIC:
		fprintf(fd, RMV "[Phase 2]:Connections=%s\n", r->p2name);
		break;
	case IKE_PASSIVE:
		fprintf(fd, RMV "[Phase 2]:Passive-Connections=%s\n",
		    r->p2name);
		break;
	default:
		return (-1);
	}
	fprintf(fd, DELETE "[%s]\n", r->p2name);
	fprintf(fd, DELETE "[phase2-%s]\n", r->p2name);
#endif

	return (0);
}

static void
ike_setup_ids(struct ipsec_rule *r)
{
	char sproto[10], ssport[10], sdport[10];

	/* phase 1 name is peer and local address */
	if (r->peer) {
		if (r->local) {
			/* peer-dstaddr-local-srcaddr */
			if (asprintf(&r->p1name, "peer-%s-local-%s",
			    r->peer->name, r->local->name) == -1)
				err(1, "ike_setup_ids");
		} else
			/* peer-dstaddr */
			if (asprintf(&r->p1name, "peer-%s",
			    r->peer->name) == -1)
				err(1, "ike_setup_ids");
	} else
		if ((r->p1name = strdup("peer-default")) == NULL)
			err(1, "ike_setup_ids");

	/* Phase 2 name is from and to network, protocol, port*/
	sproto[0] = ssport[0] = sdport[0] = 0;
	if (r->proto)
		snprintf(sproto, sizeof sproto, "=%u", r->proto);
	if (r->sport)
		snprintf(ssport, sizeof ssport, ":%u", ntohs(r->sport));
	if (r->dport)
		snprintf(sdport, sizeof sdport, ":%u", ntohs(r->dport));
	/* from-network/masklen=proto:port */
	if (asprintf(&r->p2lid, "from-%s%s%s", r->src->name, sproto, ssport)
	    == -1)
		err(1, "ike_setup_ids");
	/* to-network/masklen=proto:port */
	if (asprintf(&r->p2rid, "to-%s%s%s", r->dst->name, sproto, sdport)
	    == -1)
		err(1, "ike_setup_ids");
	/* from-network/masklen=proto:port-to-network/masklen=proto:port */
	if (asprintf(&r->p2name, "%s-%s", r->p2lid , r->p2rid) == -1)
		err(1, "ike_setup_ids");
	/* nat-network/masklen=proto:port */
	if (r->src->srcnat && r->src->srcnat->name) {
		if (asprintf(&r->p2nid, "nat-%s%s%s", r->src->srcnat->name, sproto,
		    ssport) == -1)
			err(1, "ike_setup_ids");
	}
}

int
ike_print_config(struct ipsec_rule *r, int opts)
{
	if (opts & IPSECCTL_OPT_DELETE)
		return (ike_delete_config(r, stdout));
	else
		return (ike_gen_config(r, stdout));
}

int
ike_ipsec_establish(int action, struct ipsec_rule *r, const char *fifo)
{
	struct stat	 sb;
	FILE		*fdp;
	int		 fd, ret = 0;

	if ((fd = open(fifo, O_WRONLY)) == -1)
		err(1, "ike_ipsec_establish: open(%s)", fifo);
	if (fstat(fd, &sb) == -1)
		err(1, "ike_ipsec_establish: fstat(%s)", fifo);
	if (!S_ISFIFO(sb.st_mode))
		errx(1, "ike_ipsec_establish: %s not a fifo", fifo);
	if ((fdp = fdopen(fd, "w")) == NULL)
		err(1, "ike_ipsec_establish: fdopen(%s)", fifo);

	switch (action) {
	case ACTION_ADD:
		ret = ike_gen_config(r, fdp);
		break;
	case ACTION_DELETE:
		ret = ike_delete_config(r, fdp);
		break;
	default:
		ret = -1;
	}

	fclose(fdp);
	return (ret);
}
@


1.80
log
@bump up the default Diffie-Hellman group to modp3072; ok mikeb@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.79 2015/01/16 06:39:58 deraadt Exp $	*/
a200 3
			case ENCXF_DES_CBC:
				enc_alg = "DES";
				break;
a439 3
			break;
		case ENCXF_DES_CBC:
			enc_alg = "DES";
@


1.79
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.78 2013/08/25 23:15:20 mikeb Exp $	*/
d365 1
a365 1
		group_desc = "MODP_1024";
d534 1
a534 1
		group_desc = "MODP_1024";
@


1.78
log
@the comment that comma characters cannot be used in transform
names in ike_section_p2 applies to phase-1 transforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.77 2012/09/17 20:38:28 markus Exp $	*/
d32 1
d97 1
a97 1
	char myname[MAXHOSTNAMELEN];
@


1.77
log
@unbreak the last commit by making sure that the transform name
does not include a "," character. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.76 2012/09/15 13:17:48 markus Exp $	*/
d547 1
@


1.76
log
@Encode the transform parameters in the transform name, too.
Only using p1name or p2name as a transform identifier (as in rev 1.74)
breaks setups that allow multiple transforms for a connection, e.g. in
    ike passive esp from any to 1.1.1.1 quick enc aes-128
    ike passive esp from any to 1.1.1.1 quick enc aes-192
the aes-128 will be overwritten.  ok and feedback mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.75 2012/08/30 20:03:18 naddy Exp $	*/
d155 1
a155 1
	char	*exchange_type, *key_length, *transform;
d158 1
d366 3
d373 1
a373 1
	if (asprintf(&transform, "phase2-transform-%s-%s%s-%s-%s-%s",
d376 1
a376 1
	    key_length ? key_length : "",
d416 1
a416 1
	char	*exchange_type, *key_length, *transform;
d418 1
d547 2
d550 1
a550 1
	if (asprintf(&transform, "phase1-transform-%s-%s-%s-%s%s-%s",
d552 1
a552 1
	    key_length ? key_length : "",
@


1.75
log
@Do not issue a spurious "force" when "group none" is specified.
Tweaked from his fix and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.74 2012/07/13 19:36:07 mikeb Exp $	*/
d155 2
a156 1
	char	*exchange_type, *key_length;
a190 3
	fprintf(fd, SET "[phase2-protocol-%s]:Transforms=phase2-transform-%s"
	    " force\n", r->p2name, r->p2name);

d192 1
a194 2
			fprintf(fd, SET "[phase2-transform-%s]:TRANSFORM_ID=",
			    r->p2name);
d197 1
a197 1
				fprintf(fd, "3DES");
d200 1
a200 1
				fprintf(fd, "DES");
d203 1
a203 1
				fprintf(fd, "AES");
d207 1
a207 1
				fprintf(fd, "AES");
d211 1
a211 1
				fprintf(fd, "AES");
d215 1
a215 1
				fprintf(fd, "AES");
d219 1
a219 1
				fprintf(fd, "AES_CTR");
d223 1
a223 1
				fprintf(fd, "AES_CTR");
d227 1
a227 1
				fprintf(fd, "AES_CTR");
d231 1
a231 1
				fprintf(fd, "AES_CTR");
d235 1
a235 1
				fprintf(fd, "AES_GCM_16");
d240 1
a240 1
				fprintf(fd, "AES_GCM_16");
d245 1
a245 1
				fprintf(fd, "AES_GCM_16");
d250 1
a250 1
				fprintf(fd, "AES_GMAC");
d255 1
a255 1
				fprintf(fd, "AES_GMAC");
d260 1
a260 1
				fprintf(fd, "AES_GMAC");
d265 1
a265 1
				fprintf(fd, "BLOWFISH");
d269 1
a269 1
				fprintf(fd, "CAST");
d272 1
a272 1
				fprintf(fd, "NULL");
a279 4
			fprintf(fd, " force\n");
			if (key_length)
				fprintf(fd, SET "[phase2-transform-%s]:KEY_LENGTH=%s"
				    " force\n", r->p2name, key_length);
d285 2
a286 4
		fprintf(fd, SET "[phase2-transform-%s]:TRANSFORM_ID=AES force\n",
		    r->p2name);
		fprintf(fd, SET "[phase2-transform-%s]:KEY_LENGTH=128,128:256 force\n",
		    r->p2name);
a288 3
	fprintf(fd, SET "[phase2-transform-%s]:ENCAPSULATION_MODE=",
	    r->p2name);

d291 1
a291 1
		fprintf(fd, "TUNNEL");
d294 1
a294 1
		fprintf(fd, "TRANSPORT");
a299 2
	fprintf(fd, " force\n");

d301 1
a302 2
		char *axfname = NULL;

d305 1
a305 1
			axfname =  "MD5";
d308 1
a308 1
			axfname =  "SHA";
d311 1
a311 1
			axfname =  "RIPEMD";
d314 1
a314 1
			axfname =  "SHA2_256";
d317 1
a317 1
			axfname =  "SHA2_384";
d320 1
a320 1
			axfname =  "SHA2_512";
d326 2
a327 13
		if (r->satype == IPSEC_AH)
			fprintf(fd, SET "[phase2-transform-%s]:TRANSFORM_ID=%s",
			    r->p2name, axfname);
		fprintf(fd, SET "[phase2-transform-%s]:AUTHENTICATION_ALGORITHM="
		    "HMAC_%s", r->p2name, axfname);
		fprintf(fd, " force\n");
	} else if (needauth) {
		if (r->satype == IPSEC_AH)
			fprintf(fd, SET "[phase2-transform-%s]:TRANSFORM_ID="
			"SHA2_256 force\n", r->p2name);
		fprintf(fd, SET "[phase2-transform-%s]:AUTHENTICATION_ALGORITHM="
	        "HMAC_SHA2_256 force\n", r->p2name);
	}
d329 1
d331 30
a360 34
		if (r->p2xfs->groupxf->id != GROUPXF_NONE) {
			fprintf(fd, SET "[phase2-transform-%s]:GROUP_DESCRIPTION=",
			    r->p2name);
			switch (r->p2xfs->groupxf->id) {
			case GROUPXF_768:
				fprintf(fd, "MODP_768");
				break;
			case GROUPXF_1024:
				fprintf(fd, "MODP_1024");
				break;
			case GROUPXF_1536:
				fprintf(fd, "MODP_1536");
				break;
			case GROUPXF_2048:
				fprintf(fd, "MODP_2048");
				break;
			case GROUPXF_3072:
				fprintf(fd, "MODP_3072");
				break;
			case GROUPXF_4096:
				fprintf(fd, "MODP_4096");
				break;
			case GROUPXF_6144:
				fprintf(fd, "MODP_6144");
				break;
			case GROUPXF_8192:
				fprintf(fd, "MODP_8192");
				break;
			default:
				warnx("illegal group %s",
				    r->p2xfs->groupxf->name);
				return (-1);
			};
			fprintf(fd, " force\n");
d363 30
a392 2
		fprintf(fd, SET "[phase2-transform-%s]:GROUP_DESCRIPTION="
		    "MODP_1024 force\n", r->p2name);
d395 6
a400 6
		fprintf(fd, SET "[phase2-transform-%s]:Life=phase2-life-%s force\n",
		    r->p2name, r->p2name);
		fprintf(fd, SET "[phase2-life-%s]:LIFE_TYPE=SECONDS force\n",
		    r->p2name);
		fprintf(fd, SET "[phase2-life-%s]:LIFE_DURATION=%d force\n",
		    r->p2name, r->p2life->lt_seconds);
d402 2
a403 2
		fprintf(fd, SET "[phase2-transform-%s]:Life=LIFE_QUICK_MODE"
		    " force\n", r->p2name);
d405 1
d412 2
a413 2
	char *exchange_type;
	char *key_length;
a430 4
	fprintf(fd, ADD "[phase1-%s]:Transforms=phase1-transform-%s force\n",
	    r->p1name, r->p1name);
	fprintf(fd, SET "[phase1-transform-%s]:ENCRYPTION_ALGORITHM=",
	    r->p1name);
d436 1
a436 1
			fprintf(fd, "3DES");
d439 1
a439 1
			fprintf(fd, "DES");
d442 1
a442 1
			fprintf(fd, "AES");
d446 1
a446 1
			fprintf(fd, "AES");
d450 1
a450 1
			fprintf(fd, "AES");
d454 1
a454 1
			fprintf(fd, "AES");
d458 1
a458 1
			fprintf(fd, "BLOWFISH");
d462 1
a462 1
			fprintf(fd, "CAST");
d469 1
a469 1
		fprintf(fd, "AES");
a471 8
	fprintf(fd, "_CBC force\n");

	if (key_length)
		fprintf(fd, SET "[phase1-transform-%s]:KEY_LENGTH=%s force\n",
	        r->p1name, key_length);

	fprintf(fd, SET "[phase1-transform-%s]:HASH_ALGORITHM=",
	    r->p1name);
d476 1
a476 1
			fprintf(fd, "MD5");
d479 1
a479 1
			fprintf(fd, "SHA");
d482 1
a482 1
			fprintf(fd, "SHA2_256");
d485 1
a485 1
			fprintf(fd, "SHA2_384");
d488 1
a488 1
			fprintf(fd, "SHA2_512");
d495 1
a495 2
		fprintf(fd, "SHA");
	fprintf(fd, " force\n");
a497 2
		fprintf(fd, SET "[phase1-transform-%s]:GROUP_DESCRIPTION=",
		    r->p1name);
d500 1
a500 1
			fprintf(fd, "MODP_768");
d503 1
a503 1
			fprintf(fd, "MODP_1024");
d506 1
a506 1
			fprintf(fd, "MODP_1536");
d509 1
a509 1
			fprintf(fd, "MODP_2048");
d512 1
a512 1
			fprintf(fd, "MODP_3072");
d515 1
a515 1
			fprintf(fd, "MODP_4096");
d518 1
a518 1
			fprintf(fd, "MODP_6144");
d521 1
a521 1
			fprintf(fd, "MODP_8192");
a526 1
		fprintf(fd, " force\n");
d528 1
a528 5
		fprintf(fd, SET "[phase1-transform-%s]:GROUP_DESCRIPTION="
		    "MODP_1024 force\n", r->p1name);

	fprintf(fd, SET "[phase1-transform-%s]:AUTHENTICATION_METHOD=",
	    r->p1name);
d532 1
a532 1
		fprintf(fd, "PRE_SHARED");
d535 1
a535 1
		fprintf(fd, "RSA_SIG");
d541 20
a560 1
	fprintf(fd, " force\n");
d563 6
a568 6
		fprintf(fd, SET "[phase1-transform-%s]:Life=phase1-life-%s force\n",
		    r->p1name, r->p1name);
		fprintf(fd, SET "[phase1-life-%s]:LIFE_TYPE=SECONDS force\n",
		    r->p1name);
		fprintf(fd, SET "[phase1-life-%s]:LIFE_DURATION=%d force\n",
		    r->p1name, r->p1life->lt_seconds);
d570 1
a570 2
		fprintf(fd, SET "[phase1-transform-%s]:Life=LIFE_MAIN_MODE"
		    " force\n", r->p1name);
d572 1
@


1.74
log
@Change the configuration format fed to the isakmpd FIFO to be able
to specify extended options like SA Lifetime. All the hard work was
done by lteo@@, while naddy@@ and me have made sure that defaults and
AH still work; sthen and jmc have looked over the diffs as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.73 2012/07/10 13:58:33 lteo Exp $	*/
d356 1
a356 1
		if (r->p2xfs->groupxf->id != GROUPXF_NONE)
d359 32
a390 32
		switch (r->p2xfs->groupxf->id) {
		case GROUPXF_NONE:
			break;
		case GROUPXF_768:
			fprintf(fd, "MODP_768");
			break;
		case GROUPXF_1024:
			fprintf(fd, "MODP_1024");
			break;
		case GROUPXF_1536:
			fprintf(fd, "MODP_1536");
			break;
		case GROUPXF_2048:
			fprintf(fd, "MODP_2048");
			break;
		case GROUPXF_3072:
			fprintf(fd, "MODP_3072");
			break;
		case GROUPXF_4096:
			fprintf(fd, "MODP_4096");
			break;
		case GROUPXF_6144:
			fprintf(fd, "MODP_6144");
			break;
		case GROUPXF_8192:
			fprintf(fd, "MODP_8192");
			break;
		default:
			warnx("illegal group %s", r->p2xfs->groupxf->name);
			return (-1);
		};
		fprintf(fd, " force\n");
@


1.73
log
@Rename "life" to "lifetime" to match iked.

ok mikeb naddy sthen; procedures ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.72 2012/07/09 21:06:51 lteo Exp $	*/
a70 6
	if (r->p1life && r->p1life->lt_seconds != -1)
		fprintf(fd, SET "[General]:Default-phase-1-lifetime=%d force\n",
		    r->p1life->lt_seconds);
	if (r->p2life && r->p2life->lt_seconds != -1)
		fprintf(fd, SET "[General]:Default-phase-2-lifetime=%d force\n",
		    r->p2life->lt_seconds);
d155 1
a155 1
	char	*exchange_type, *sprefix;
a160 1
		sprefix = "QM";
d169 7
a175 1
	fprintf(fd, SET "[phase2-%s]:Suites=%s-", r->p2name, sprefix);
d179 1
a179 1
		fprintf(fd, "ESP");
d182 1
a182 1
		fprintf(fd, "AH");
d188 1
a188 1
	fprintf(fd, "-");
d190 2
a191 10
	switch (r->tmode) {
	case IPSEC_TUNNEL:
		break;
	case IPSEC_TRANSPORT:
		fprintf(fd, "TRP-");
		break;
	default:
		warnx("illegal encapsulation mode %d", r->tmode);
		return (-1);
	}
d193 1
d196 2
d207 1
d210 2
a211 1
				fprintf(fd, "AES-128");
d214 2
a215 1
				fprintf(fd, "AES-192");
d218 2
a219 1
				fprintf(fd, "AES-256");
d222 2
a223 1
				fprintf(fd, "AESCTR");
d226 2
a227 1
				fprintf(fd, "AESCTR-128");
d230 2
a231 1
				fprintf(fd, "AESCTR-192");
d234 2
a235 1
				fprintf(fd, "AESCTR-256");
d238 2
a239 1
				fprintf(fd, "AESGCM-128");
d243 2
a244 1
				fprintf(fd, "AESGCM-192");
d248 2
a249 1
				fprintf(fd, "AESGCM-256");
d253 2
a254 1
				fprintf(fd, "AESGMAC-128");
d258 2
a259 1
				fprintf(fd, "AESGMAC-192");
d263 2
a264 1
				fprintf(fd, "AESGMAC-256");
d268 2
a269 1
				fprintf(fd, "BLF");
d283 4
a286 1
			fprintf(fd, "-");
d291 23
a313 2
	} else if (r->satype == IPSEC_ESP)
		fprintf(fd, "AES-");
d316 2
d320 1
a320 1
			fprintf(fd, "MD5");
d323 1
a323 1
			fprintf(fd, "SHA");
d326 1
a326 1
			fprintf(fd, "RIPEMD");
d329 1
a329 1
			fprintf(fd, "SHA2-256");
d332 1
a332 1
			fprintf(fd, "SHA2-384");
d335 1
a335 1
			fprintf(fd, "SHA2-512");
d341 13
a353 3
		fprintf(fd, "-");
	} else if (needauth)
		fprintf(fd, "SHA2-256-");
d356 3
d363 1
a363 1
			fprintf(fd, "PFS-GRP1-");
d366 1
a366 1
			fprintf(fd, "PFS-GRP2-");
d369 1
a369 1
			fprintf(fd, "PFS-GRP5-");
d372 1
a372 1
			fprintf(fd, "PFS-GRP14-");
d375 1
a375 1
			fprintf(fd, "PFS-GRP15-");
d378 1
a378 1
			fprintf(fd, "PFS-GRP16-");
d381 1
a381 1
			fprintf(fd, "PFS-GRP17-");
d384 1
a384 1
			fprintf(fd, "PFS-GRP18-");
d390 12
d403 2
a404 2
		fprintf(fd, "PFS-");
	fprintf(fd, "SUITE force\n");
d413 1
d431 4
a434 1
	fprintf(fd, ADD "[phase1-%s]:Transforms=", r->p1name);
d436 1
d447 1
d450 2
a451 1
			fprintf(fd, "AES-128");
d454 2
a455 1
			fprintf(fd, "AES-192");
d458 2
a459 1
			fprintf(fd, "AES-256");
d462 2
a463 1
			fprintf(fd, "BLF");
d472 1
a472 1
	} else
d474 10
a483 1
	fprintf(fd, "-");
d494 1
a494 1
			fprintf(fd, "SHA2-256");
d497 1
a497 1
			fprintf(fd, "SHA2-384");
d500 1
a500 1
			fprintf(fd, "SHA2-512");
d508 1
d511 2
d515 1
a515 1
			fprintf(fd, "-GRP1");
d518 1
a518 1
			fprintf(fd, "-GRP2");
d521 1
a521 1
			fprintf(fd, "-GRP5");
d524 1
a524 1
			fprintf(fd, "-GRP14");
d527 1
a527 1
			fprintf(fd, "-GRP15");
d530 1
a530 1
			fprintf(fd, "-GRP16");
d533 1
a533 1
			fprintf(fd, "-GRP17");
d536 1
a536 1
			fprintf(fd, "-GRP18");
d542 18
d561 1
d563 10
a572 3
	if (r->ikeauth->type == IKE_AUTH_RSA)
		fprintf(fd, "-RSA_SIG");
	fprintf(fd, " force\n");
@


1.72
log
@Fix typo in warning message.

ok mikeb sthen haesbaert henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.71 2012/06/30 14:51:31 naddy Exp $	*/
d71 1
a71 1
	if (r->p1life && r->p1life->lifetime != -1)
d73 2
a74 2
		    r->p1life->lifetime);
	if (r->p2life && r->p2life->lifetime != -1)
d76 1
a76 1
		    r->p2life->lifetime);
@


1.71
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.70 2011/11/08 13:26:06 henning Exp $	*/
d362 1
a362 1
		warnx("illegal phase 2 ike mode %d", r->p1ie);
@


1.70
log
@allow the path to isakmpd's fifo to be specified (aka changed) on the
command line, ok mikeb sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.69 2010/10/15 12:11:10 mikeb Exp $	*/
d225 9
@


1.69
log
@fixup generation of suites string for isakmpd wrt "group none"

bug noticed and fix tested by robert
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.68 2010/09/22 14:04:09 mikeb Exp $	*/
d48 1
a48 1
int		ike_ipsec_establish(int, struct ipsec_rule *);
a54 2
#define ISAKMPD_FIFO	"/var/run/isakmpd.fifo"

d708 1
a708 1
ike_ipsec_establish(int action, struct ipsec_rule *r)
d714 2
a715 2
	if ((fd = open(ISAKMPD_FIFO, O_WRONLY)) == -1)
		err(1, "ike_ipsec_establish: open(%s)", ISAKMPD_FIFO);
d717 1
a717 1
		err(1, "ike_ipsec_establish: fstat(%s)", ISAKMPD_FIFO);
d719 1
a719 1
		errx(1, "ike_ipsec_establish: %s not a fifo", ISAKMPD_FIFO);
d721 1
a721 1
		err(1, "ike_ipsec_establish: fdopen(%s)", ISAKMPD_FIFO);
@


1.68
log
@Support AES-GCM-16 (as aes-gcm) and ENCR_NULL_AUTH_AES_GMAC
(as aes-gmac) encryption transformations in the ipsec.conf(5).

Available "enc" arguments denoting use of

1) AES-GCM-16:

 aes-128-gcm for 160 bit key (128+nonce)
 aes-192-gcm for 224 bit key (192+nonce)
 aes-256-gcm for 288 bit key (256+nonce)

2) ENCR_NULL_AUTH_AES_GMAC:

 aes-128-gmac for 160 bit key (128+nonce)
 aes-192-gmac for 224 bit key (192+nonce)
 aes-256-gmac for 288 bit key (256+nonce)

Please note that aes-gmac family performs no encryption and provides
no confidentiality and is intended for cases in which confidentiality
is not desired (it can be thought of as AH with NAT-T support).

Also, although this implementation supports manual keying, it's
use is strictly discouraged as AES-GCM security depends on frequent
re-keying.  So it can be thought of as a debug facility only.

Example configuration:

	ike esp from 172.23.61.36 to 172.23.61.156 \
		quick enc aes-256-gcm \
		psk humppa

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

OK naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.67 2009/10/04 11:39:32 jsing Exp $	*/
d308 1
a308 1
			fprintf(fd, "PFS-GRP1");
d311 1
a311 1
			fprintf(fd, "PFS-GRP2");
d314 1
a314 1
			fprintf(fd, "PFS-GRP5");
d317 1
a317 1
			fprintf(fd, "PFS-GRP14");
d320 1
a320 1
			fprintf(fd, "PFS-GRP15");
d323 1
a323 1
			fprintf(fd, "PFS-GRP16");
d326 1
a326 1
			fprintf(fd, "PFS-GRP17");
d329 1
a329 1
			fprintf(fd, "PFS-GRP18");
d336 2
a337 2
		fprintf(fd, "PFS");
	fprintf(fd, "-SUITE force\n");
@


1.67
log
@When IKE is operating in dynamic mode and no srcid is given, the hostname
is used as the srcid, however the srcid type is not specified. Rectify this
by explicitly setting the srcid type to FQDN after successfully retrieving the
hostname. This worked prior to the addition of IPV4_ADDR/IPV6_ADDR support
since get_id_type() returned ID_FQDN even when presented with a null pointer.

Issue reported by Mikolaj Kucharski.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.66 2009/08/04 15:05:50 jsing Exp $	*/
d164 1
d228 24
d260 1
d299 3
a301 2
	} else
		fprintf(fd, "SHA2-256");
d308 1
a308 1
			fprintf(fd, "-PFS-GRP1");
d311 1
a311 1
			fprintf(fd, "-PFS-GRP2");
d314 1
a314 1
			fprintf(fd, "-PFS-GRP5");
d317 1
a317 1
			fprintf(fd, "-PFS-GRP14");
d320 1
a320 1
			fprintf(fd, "-PFS-GRP15");
d323 1
a323 1
			fprintf(fd, "-PFS-GRP16");
d326 1
a326 1
			fprintf(fd, "-PFS-GRP17");
d329 1
a329 1
			fprintf(fd, "-PFS-GRP18");
d336 1
a336 1
		fprintf(fd, "-PFS");
@


1.66
log
@Specify an ID-type of IPV4_ADDR or IPV6_ADDR if the srcid or dstid is
given as an IPv4 or IPv6 address, rather than treating the IP address as
a FQDN.

ok hshoexer@@ markus@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.64 2008/07/01 15:00:53 bluhm Exp $	*/
d114 1
@


1.65
log
@Add support to isakmpd(8) and ipsecctl(8) to install SA's with a
different source network than we have negotiated with a peer.
This enables us to do nat/binat on the enc(4) interface.
Very useful to work around rfc 1918 collisions.
Manpage and testing by Mitja Muzenic. Thanks!
OK hshoexer@@, markus@@. "I like it" todd@@
@
text
@d60 3
a62 1
char *ike_id_types[] = { "", "", "FQDN", "USER_FQDN" };
d120 7
a126 2
		fprintf(fd, SET "[id-%s]:Name=%s force\n", r->auth->srcid,
		    r->auth->srcid);
d133 7
a139 2
		fprintf(fd, SET "[id-%s]:Name=%s force\n", r->auth->dstid,
		    r->auth->dstid);
@


1.64
log
@Isakmpd acquire mode did not work with a config generated from
ipsec.conf.  The config created by isakmpd dynamically was different
from the config that ipsecctl generated out of ipsec.conf.

Both config formats are changed so that they match.  One needs a
passive ike line and a require flow line with the same parameters
in the ipsec.conf.  Then the acquire message generated by the kernel
will trigger isakmpd to generate a config that matches the one that
ipsecctl generated from the ike line.

ok hshoexer, 'sounds good' todd
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.63 2008/02/22 23:51:31 hshoexer Exp $	*/
d139 2
d423 2
a424 1
ike_section_p2ids(struct ipsec_rule *r, FILE *fd)
d429 39
d472 2
a473 33
		bzero(&sas, sizeof(struct sockaddr_storage));
		bzero(mask, sizeof(mask));
		sa->sa_family = src->af;
		switch (src->af) {
		case AF_INET:
			sa->sa_len = sizeof(struct sockaddr_in);
			bcopy(&src->mask.ipa,
			    &((struct sockaddr_in *)(sa))->sin_addr,
			    sizeof(struct in6_addr));
			break;
		case AF_INET6:
			sa->sa_len = sizeof(struct sockaddr_in6);
			bcopy(&src->mask.ipa,
			    &((struct sockaddr_in6 *)sa)->sin6_addr,
			    sizeof(struct in6_addr));
			break;
		}
		if (getnameinfo(sa, sa->sa_len, mask, sizeof(mask), NULL, 0,
		    NI_NUMERICHOST))
			errx(1, "could not get a numeric mask");

		if ((network = strdup(src->name)) == NULL)
			err(1, "ike_section_p2ids: strdup");
		if ((p = strrchr(network, '/')) != NULL)
			*p = '\0';

		fprintf(fd, SET "[%s]:ID-type=IPV%d_ADDR_SUBNET force\n",
		    r->p2lid, ((src->af == AF_INET) ? 4 : 6));
		fprintf(fd, SET "[%s]:Network=%s force\n", r->p2lid,
		    network);
		fprintf(fd, SET "[%s]:Netmask=%s force\n", r->p2lid, mask);

		free(network);
d482 8
a489 25
	if (dst->netaddress) {
		bzero(&sas, sizeof(struct sockaddr_storage));
		bzero(mask, sizeof(mask));
		sa->sa_family = dst->af;
		switch (dst->af) {
		case AF_INET:
			sa->sa_len = sizeof(struct sockaddr_in);
			bcopy(&dst->mask.ipa,
			    &((struct sockaddr_in *)(sa))->sin_addr,
			    sizeof(struct in6_addr));
			break;
		case AF_INET6:
			sa->sa_len = sizeof(struct sockaddr_in6);
			bcopy(&dst->mask.ipa,
			    &((struct sockaddr_in6 *)(sa))->sin6_addr,
			    sizeof(struct in6_addr));
			break;
		}
		if (getnameinfo(sa, sa->sa_len, mask, sizeof(mask), NULL, 0,
		    NI_NUMERICHOST))
			errx(1, "could not get a numeric mask");

		if ((network = strdup(dst->name)) == NULL)
			err(1, "ike_section_p2ids: strdup");
		if ((p = strrchr(network, '/')) != NULL)
d491 3
d495 3
a497 7
		fprintf(fd, SET "[%s]:ID-type=IPV%d_ADDR_SUBNET force\n",
		    r->p2rid, ((dst->af == AF_INET) ? 4 : 6));
		fprintf(fd, SET "[%s]:Network=%s force\n", r->p2rid,
		    network);
		fprintf(fd, SET "[%s]:Netmask=%s force\n", r->p2rid, mask);

		free(network);
d652 6
@


1.63
log
@Support for specifying aes-{128,192,256}.  Originial idea by Prabhu
Gurumurthy, tweaks and commit-ready diff by Mitja Muzenic!  Thanks
guys!

ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.62 2008/01/04 11:06:02 hshoexer Exp $	*/
d82 8
a89 5
	if (r->peer) {
		fprintf(fd, SET "[Phase 1]:%s=peer-%s force\n", r->peer->name,
		    r->peer->name);
		fprintf(fd, SET "[peer-%s]:Phase=1 force\n", r->peer->name);
		fprintf(fd, SET "[peer-%s]:Address=%s force\n", r->peer->name,
d91 6
a96 18
		if (r->local)
			fprintf(fd, SET "[peer-%s]:Local-address=%s force\n",
			    r->peer->name, r->local->name);
		if (r->ikeauth->type == IKE_AUTH_PSK)
			fprintf(fd, SET "[peer-%s]:Authentication=%s force\n",
			    r->peer->name, r->ikeauth->string);
	} else {
		fprintf(fd, SET "[Phase 1]:Default=peer-default force\n");
		fprintf(fd, SET "[peer-default]:Phase=1 force\n");
		if (r->local)
			fprintf(fd, SET
			    "[peer-default]:Local-address=%s force\n",
			    r->local->name);
		if (r->ikeauth->type == IKE_AUTH_PSK)
			fprintf(fd, SET
			    "[peer-default]:Authentication=%s force\n",
			    r->ikeauth->string);
	}
d114 3
a116 8
		if (r->peer)
			fprintf(fd, SET "[peer-%s]:ID=%s-ID force\n",
			    r->peer->name, r->auth->srcid);
		else
			fprintf(fd, SET "[peer-default]:ID=%s-ID force\n",
			    r->auth->srcid);

		fprintf(fd, SET "[%s-ID]:ID-type=%s force\n", r->auth->srcid,
d118 1
a118 1
		fprintf(fd, SET "[%s-ID]:Name=%s force\n", r->auth->srcid,
d122 6
a127 15
		if (r->peer) {
			fprintf(fd, SET "[peer-%s]:Remote-ID=%s-ID force\n",
			    r->peer->name, r->peer->name);
			fprintf(fd, SET "[%s-ID]:ID-type=%s force\n",
			    r->peer->name, ike_id_types[r->auth->dstid_type]);
			fprintf(fd, SET "[%s-ID]:Name=%s force\n", r->peer->name,
			    r->auth->dstid);
		} else {
			fprintf(fd, SET
			    "[peer-default]:Remote-ID=default-ID force\n");
			fprintf(fd, SET "[default-ID]:ID-type=%s force\n",
			    ike_id_types[r->auth->dstid_type]);
			fprintf(fd, SET "[default-ID]:Name=%s force\n",
			    r->auth->dstid);
		}
d134 3
a136 10
	fprintf(fd, SET "[IPsec-%s]:Phase=2 force\n", r->p2name);

	if (r->peer)
		fprintf(fd, SET "[IPsec-%s]:ISAKMP-peer=peer-%s force\n",
		    r->p2name, r->peer->name);
	else
		fprintf(fd, SET
		    "[IPsec-%s]:ISAKMP-peer=peer-default force\n", r->p2name);

	fprintf(fd, SET "[IPsec-%s]:Configuration=qm-%s force\n", r->p2name,
d138 2
a139 4
	fprintf(fd, SET "[IPsec-%s]:Local-ID=lid-%s force\n", r->p2name,
	    r->p2lid);
	fprintf(fd, SET "[IPsec-%s]:Remote-ID=rid-%s force\n", r->p2name,
	    r->p2rid);
d142 1
a142 2
		fprintf(fd, SET "[IPsec-%s]:PF-Tag=%s force\n", r->p2name,
		    r->tag);
d148 1
a148 1
	char	*tag, *exchange_type, *sprefix;
a151 1
		tag = "qm";
d160 1
a160 1
	fprintf(fd, SET "[%s-%s]:EXCHANGE_TYPE=%s force\n", tag, r->p2name,
d162 1
a162 1
	fprintf(fd, SET "[%s-%s]:Suites=%s-", tag, r->p2name, sprefix);
d303 1
a303 1
	char *tag, *exchange_type;
a306 1
		tag = "mm";
a309 1
		tag = "am";
d317 5
a321 13
	if (r->peer) {
		fprintf(fd, SET "[peer-%s]:Configuration=%s-%s force\n",
		    r->peer->name, tag, r->peer->name);
		fprintf(fd, SET "[%s-%s]:EXCHANGE_TYPE=%s force\n",
		    tag, r->peer->name, exchange_type);
		fprintf(fd, ADD "[%s-%s]:Transforms=", tag, r->peer->name);
	} else {
		fprintf(fd, SET
		    "[peer-default]:Configuration=%s-default force\n", tag);
		fprintf(fd, SET "[%s-default]:EXCHANGE_TYPE=%s force\n",
		    tag, exchange_type);
		fprintf(fd, ADD "[%s-default]:Transforms=", tag);
	}
d456 1
a456 1
		fprintf(fd, SET "[lid-%s]:ID-type=IPV%d_ADDR_SUBNET force\n",
d458 1
a458 1
		fprintf(fd, SET "[lid-%s]:Network=%s force\n", r->p2lid,
d460 1
a460 1
		fprintf(fd, SET "[lid-%s]:Netmask=%s force\n", r->p2lid, mask);
d464 1
a464 1
		fprintf(fd, SET "[lid-%s]:ID-type=IPV%d_ADDR force\n",
d468 1
a468 1
		fprintf(fd, SET "[lid-%s]:Address=%s force\n", r->p2lid,
d498 1
a498 1
		fprintf(fd, SET "[rid-%s]:ID-type=IPV%d_ADDR_SUBNET force\n",
d500 1
a500 1
		fprintf(fd, SET "[rid-%s]:Network=%s force\n", r->p2rid,
d502 1
a502 1
		fprintf(fd, SET "[rid-%s]:Netmask=%s force\n", r->p2rid, mask);
d506 1
a506 1
		fprintf(fd, SET "[rid-%s]:ID-type=IPV%d_ADDR force\n",
d510 1
a510 1
		fprintf(fd, SET "[rid-%s]:Address=%s force\n", r->p2rid,
d514 1
a514 1
		fprintf(fd, SET "[lid-%s]:Protocol=%d force\n",
d516 1
a516 1
		fprintf(fd, SET "[rid-%s]:Protocol=%d force\n",
d520 1
a520 1
		fprintf(fd, SET "[lid-%s]:Port=%d force\n", r->p2lid,
d523 1
a523 1
		fprintf(fd, SET "[rid-%s]:Port=%d force\n", r->p2rid,
d533 1
a533 1
		fprintf(fd, ADD "[Phase 2]:Connections=IPsec-%s\n", r->p2name);
d536 1
a536 1
		fprintf(fd, ADD "[Phase 2]:Passive-Connections=IPsec-%s\n",
d574 1
a574 1
		fprintf(fd, "t IPsec-%s\n", r->p2name);
d578 1
a578 1
		fprintf(fd, "t IPsec-%s\n", r->p2name);
d585 2
a586 3
		fprintf(fd, DELETE "[peer-%s]\n", r->peer->name);
		fprintf(fd, DELETE "[mm-%s]\n", r->peer->name);
		fprintf(fd, DELETE "[am-%s]\n", r->peer->name);
d594 4
a597 4
	fprintf(fd, DELETE "[IPsec-%s]\n", r->p2name);
	fprintf(fd, DELETE "[qm-%s]\n", r->p2name);
	fprintf(fd, DELETE "[lid-%s]\n", r->p2lid);
	fprintf(fd, DELETE "[rid-%s]\n", r->p2rid);
d599 1
a599 1
	fprintf(fd, "t IPsec-%s\n", r->p2name);
d603 1
a603 1
		fprintf(fd, RMV "[Phase 2]:Connections=IPsec-%s\n", r->p2name);
d606 1
a606 1
		fprintf(fd, RMV "[Phase 2]:Passive-Connections=IPsec-%s\n",
d612 2
a613 2
	fprintf(fd, DELETE "[IPsec-%s]\n", r->p2name);
	fprintf(fd, DELETE "[qm-%s]\n", r->p2name);
d622 8
a629 11
	if (r->proto) {
		if (asprintf(&r->p2lid, "%s:%d-%d", r->src->name,
		     ntohs(r->sport), r->proto) == -1)
			err(1, "ike_setup_ids");
		if (asprintf(&r->p2rid, "%s:%d-%d", r->dst->name,
		     ntohs(r->dport), r->proto) == -1)
			err(1, "ike_setup_ids");
	} else {
		if (r->sport) {
			if (asprintf(&r->p2lid, "%s:%d", r->src->name,
			     ntohs(r->sport)) == -1)
d631 4
a634 2
		} else {
			if ((r->p2lid = strdup(r->src->name)) == NULL)
d636 22
a657 11
		}
		if (r->dport) {
			if (asprintf(&r->p2rid, "%s:%d", r->dst->name,
			     ntohs(r->dport)) == -1)
				err(1, "ike_setup_ids");
		} else {
			if ((r->p2rid = strdup(r->dst->name)) == NULL)
				err(1, "ike_setup_ids");
		}
	}
	if (asprintf(&r->p2name, "%s-%s", r->p2lid, r->p2rid) == -1)
@


1.62
log
@Strip off trailing '/32' when address type is IPV4_ADDR as isakmpd does
not accept the trailing '/32'.

Diff from Mitja Muzenic <mitja@@muzenic.net>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.61 2007/03/16 20:51:01 markus Exp $	*/
d234 9
d377 9
@


1.61
log
@move autodetection of the ID type to the parser.  this way the
static flows have the correct ID, too. ok hshoexer, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.60 2007/02/19 09:00:46 hshoexer Exp $	*/
d492 2
d534 2
@


1.60
log
@Bits for ESP+NULL encryption.  This is useful, when AH can not be
used (when being behind NAT).  With Martin Hedenfalk <martin.hedenfalk
at gmail.com>, thanks!

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.59 2006/12/18 00:08:04 msf Exp $	*/
a37 1
static int	ike_get_id_type(char *);
a122 2
		int idtype = ike_get_id_type(r->auth->srcid);

d131 1
a131 1
		    ike_id_types[idtype]);
a135 2
		int idtype = ike_get_id_type(r->auth->dstid);

d140 1
a140 1
			    r->peer->name, ike_id_types[idtype]);
d147 1
a147 1
			    ike_id_types[idtype]);
a151 9
}

static int
ike_get_id_type(char *string)
{
	if (strchr(string, '@@'))
		return ID_UFQDN;
	else
		return ID_FQDN;
@


1.59
log
@call ike_setup_ids from a more appropriate location.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.58 2006/11/30 21:35:34 markus Exp $	*/
d256 3
@


1.58
log
@typo: wrong rid for protocol
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.57 2006/11/30 16:17:58 markus Exp $	*/
d581 1
d602 1
a687 1
	ike_setup_ids(r);
@


1.57
log
@use rmv to unregister ipsec connections; ok hshoexer, ho
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.56 2006/11/30 15:51:28 markus Exp $	*/
d550 1
a550 1
		    r->p2lid, r->proto);
@


1.56
log
@handle multiple SAs with different same src/dst but different port;
store IKE connection string and phase2 IDs in the ipsec rule;
cleanup internal API: pass rules around instead of rule members;
report Brian Candler; fix with hshoexer, msf; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.55 2006/11/24 13:52:13 reyk Exp $	*/
d54 1
d632 12
@


1.55
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.54 2006/11/24 08:07:18 markus Exp $	*/
d36 2
a37 4
static void	ike_section_peer(struct ipsec_addr_wrap *,
		    struct ipsec_addr_wrap *, FILE *, struct ike_auth *);
static void	ike_section_ids(struct ipsec_addr_wrap *, struct ipsec_auth *,
		    FILE *, u_int8_t);
d39 5
a43 11
static void	ike_section_ipsec(struct ipsec_addr_wrap *, struct
		    ipsec_addr_wrap *, struct ipsec_addr_wrap *, char *, FILE *);
static int	ike_section_p1(struct ipsec_addr_wrap *, struct
		    ipsec_transforms *, FILE *, struct ike_auth *, u_int8_t);
static int	ike_section_p2(struct ipsec_addr_wrap *, struct
		    ipsec_addr_wrap *, u_int8_t, u_int8_t, struct
		    ipsec_transforms *, FILE *, u_int8_t);
static void	ike_section_p2ids(u_int8_t, struct ipsec_addr_wrap *,
		    u_int16_t, struct ipsec_addr_wrap *, u_int16_t, FILE *);
static int	ike_connect(u_int8_t, struct ipsec_addr_wrap *, struct
		    ipsec_addr_wrap *, FILE *);
d46 1
d80 1
a80 2
ike_section_peer(struct ipsec_addr_wrap *peer, struct ipsec_addr_wrap *local,
    FILE *fd, struct ike_auth *auth)
d82 7
a88 7
	if (peer) {
		fprintf(fd, SET "[Phase 1]:%s=peer-%s force\n", peer->name,
		    peer->name);
		fprintf(fd, SET "[peer-%s]:Phase=1 force\n", peer->name);
		fprintf(fd, SET "[peer-%s]:Address=%s force\n", peer->name,
		    peer->name);
		if (local)
d90 2
a91 2
			    peer->name, local->name);
		if (auth->type == IKE_AUTH_PSK)
d93 1
a93 1
			    peer->name, auth->string);
d97 1
a97 1
		if (local)
d100 2
a101 2
			    local->name);
		if (auth->type == IKE_AUTH_PSK)
d104 1
a104 1
			    auth->string);
d109 1
a109 2
ike_section_ids(struct ipsec_addr_wrap *peer, struct ipsec_auth *auth, FILE *fd,
    u_int8_t ikemode)
d113 1
a113 1
	if (auth == NULL)
d116 1
a116 1
	if (ikemode == IKE_DYNAMIC && auth->srcid == NULL) {
d119 1
a119 1
		if ((auth->srcid = strdup(myname)) == NULL)
d122 2
a123 2
	if (auth->srcid) {
		int idtype = ike_get_id_type(auth->srcid);
d125 1
a125 1
		if (peer)
d127 1
a127 1
			    peer->name, auth->srcid);
d130 1
a130 1
			    auth->srcid);
d132 1
a132 1
		fprintf(fd, SET "[%s-ID]:ID-type=%s force\n", auth->srcid,
d134 2
a135 2
		fprintf(fd, SET "[%s-ID]:Name=%s force\n", auth->srcid,
		    auth->srcid);
d137 2
a138 2
	if (auth->dstid) {
		int idtype = ike_get_id_type(auth->dstid);
d140 1
a140 1
		if (peer) {
d142 1
a142 1
			    peer->name, peer->name);
d144 3
a146 3
			    peer->name, ike_id_types[idtype]);
			fprintf(fd, SET "[%s-ID]:Name=%s force\n", peer->name,
			    auth->dstid);
d153 1
a153 1
			    auth->dstid);
d168 1
a168 2
ike_section_ipsec(struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
    struct ipsec_addr_wrap *peer, char *tag, FILE *fd)
d170 1
a170 1
	fprintf(fd, SET "[IPsec-%s-%s]:Phase=2 force\n", src->name, dst->name);
d172 3
a174 3
	if (peer)
		fprintf(fd, SET "[IPsec-%s-%s]:ISAKMP-peer=peer-%s force\n",
		    src->name, dst->name, peer->name);
d177 1
a177 2
		    "[IPsec-%s-%s]:ISAKMP-peer=peer-default force\n",
		    src->name, dst->name);
d179 10
a188 10
	fprintf(fd, SET "[IPsec-%s-%s]:Configuration=qm-%s-%s force\n",
	    src->name, dst->name, src->name, dst->name);
	fprintf(fd, SET "[IPsec-%s-%s]:Local-ID=lid-%s force\n", src->name,
	    dst->name, src->name);
	fprintf(fd, SET "[IPsec-%s-%s]:Remote-ID=rid-%s force\n", src->name,
	    dst->name, dst->name);

	if (tag)
		fprintf(fd, SET "[IPsec-%s-%s]:PF-Tag=%s force\n",
		    src->name, dst->name, tag);
d192 1
a192 3
ike_section_p2(struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
    u_int8_t satype, u_int8_t tmode, struct ipsec_transforms *qmxfs, FILE *fd,
    u_int8_t ike_exch)
d194 1
a194 1
	char *tag, *exchange_type, *sprefix;
d196 1
a196 1
	switch (ike_exch) {
d203 1
a203 1
		warnx("illegal phase 2 ike mode %d", ike_exch);
d207 3
a209 4
	fprintf(fd, SET "[%s-%s-%s]:EXCHANGE_TYPE=%s force\n",
	    tag, src->name, dst->name, exchange_type);
	fprintf(fd, SET "[%s-%s-%s]:Suites=%s-", tag, src->name,
	    dst->name, sprefix);
d211 1
a211 1
	switch (satype) {
d219 1
a219 1
		warnx("illegal satype %d", satype);
d224 1
a224 1
	switch (tmode) {
d231 1
a231 1
		warnx("illegal encapsulation mode %d", tmode);
d235 3
a237 3
	if (qmxfs && qmxfs->encxf) {
		if (satype == IPSEC_ESP) {
			switch (qmxfs->encxf->id) {
d258 1
a258 1
				    qmxfs->encxf->name);
d263 1
a263 1
			warnx("illegal transform %s", qmxfs->encxf->name);
d266 1
a266 1
	} else if (satype == IPSEC_ESP)
d269 2
a270 2
	if (qmxfs && qmxfs->authxf) {
		switch (qmxfs->authxf->id) {
d290 1
a290 1
			warnx("illegal transform %s", qmxfs->authxf->name);
d296 2
a297 2
	if (qmxfs && qmxfs->groupxf) {
		switch (qmxfs->groupxf->id) {
d325 1
a325 1
			warnx("illegal group %s", qmxfs->groupxf->name);
d336 1
a336 2
ike_section_p1(struct ipsec_addr_wrap *peer, struct ipsec_transforms *p1xfs,
    FILE *fd, struct ike_auth *auth, u_int8_t ike_exch)
d340 1
a340 1
	switch (ike_exch) {
d350 1
a350 1
		warnx("illegal phase 2 ike mode %d", ike_exch);
d354 1
a354 1
	if (peer) {
d356 1
a356 1
		    peer->name, tag, peer->name);
d358 2
a359 2
		    tag, peer->name, exchange_type);
		fprintf(fd, ADD "[%s-%s]:Transforms=", tag, peer->name);
d368 2
a369 2
	if (p1xfs && p1xfs->encxf) {
		switch (p1xfs->encxf->id) {
d386 1
a386 1
			warnx("illegal transform %s", p1xfs->encxf->name);
d393 2
a394 2
	if (p1xfs && p1xfs->authxf) {
		switch (p1xfs->authxf->id) {
d411 1
a411 1
			warnx("illegal transform %s", p1xfs->authxf->name);
d417 2
a418 2
	if (p1xfs && p1xfs->groupxf) {
		switch (p1xfs->groupxf->id) {
d444 1
a444 1
			warnx("illegal group %s", p1xfs->groupxf->name);
d449 1
a449 1
	if (auth->type == IKE_AUTH_RSA)
d457 1
a457 2
ike_section_p2ids(u_int8_t proto, struct ipsec_addr_wrap *src,
    u_int16_t sport, struct ipsec_addr_wrap *dst, u_int16_t dport, FILE *fd)
d462 2
d493 2
a494 2
		    src->name, ((src->af == AF_INET) ? 4 : 6));
		fprintf(fd, SET "[lid-%s]:Network=%s force\n", src->name,
d496 1
a496 1
		fprintf(fd, SET "[lid-%s]:Netmask=%s force\n", src->name, mask);
d501 2
a502 2
		    src->name, ((src->af == AF_INET) ? 4 : 6));
		fprintf(fd, SET "[lid-%s]:Address=%s force\n", src->name,
d533 2
a534 2
		    dst->name, ((dst->af == AF_INET) ? 4 : 6));
		fprintf(fd, SET "[rid-%s]:Network=%s force\n", dst->name,
d536 1
a536 1
		fprintf(fd, SET "[rid-%s]:Netmask=%s force\n", dst->name, mask);
d541 2
a542 2
		    dst->name, ((dst->af == AF_INET) ? 4 : 6));
		fprintf(fd, SET "[rid-%s]:Address=%s force\n", dst->name,
d545 1
a545 1
	if (proto) {
d547 1
a547 1
		    src->name, proto);
d549 1
a549 1
		    dst->name, proto);
d551 6
a556 6
	if (sport)
		fprintf(fd, SET "[lid-%s]:Port=%d force\n", src->name,
		    ntohs(sport));
	if (dport)
		fprintf(fd, SET "[rid-%s]:Port=%d force\n", dst->name,
		    ntohs(dport));
d560 1
a560 2
ike_connect(u_int8_t mode, struct ipsec_addr_wrap *src,
    struct ipsec_addr_wrap *dst, FILE *fd)
d562 1
a562 1
	switch (mode) {
d565 1
a565 2
		fprintf(fd, ADD "[Phase 2]:Connections=IPsec-%s-%s\n",
		    src->name, dst->name);
d568 2
a569 2
		fprintf(fd, ADD "[Phase 2]:Passive-Connections=IPsec-%s-%s\n",
		    src->name, dst->name);
d581 2
a582 3
	ike_section_peer(r->peer, r->local, fd, r->ikeauth);
	if (ike_section_p1(r->peer, r->p1xfs,
	    fd, r->ikeauth, r->p1ie) == -1)
d584 4
a587 4
	ike_section_ids(r->peer, r->auth, fd, r->ikemode);
	ike_section_ipsec(r->src, r->dst, r->peer, r->tag, fd);
	if (ike_section_p2(r->src, r->dst, r->satype, r->tmode, r->p2xfs,
	    fd, r->p2ie) == -1)
d589 2
a590 1
	ike_section_p2ids(r->proto, r->src, r->sport, r->dst, r->dport, fd);
d592 1
a592 1
	if (ike_connect(r->ikemode, r->src, r->dst, fd) == -1)
a593 1

d604 1
a604 1
		fprintf(fd, "t IPsec-%s-%s\n", r->src->name, r->dst->name);
d608 1
a608 1
		fprintf(fd, "t IPsec-%s-%s\n", r->src->name, r->dst->name);
d625 4
a628 4
	fprintf(fd, DELETE "[IPsec-%s-%s]\n", r->src->name, r->dst->name);
	fprintf(fd, DELETE "[qm-%s-%s]\n", r->src->name, r->dst->name);
	fprintf(fd, DELETE "[lid-%s]\n", r->src->name);
	fprintf(fd, DELETE "[rid-%s]\n", r->dst->name);
d630 3
a632 3
	fprintf(fd, "t IPsec-%s-%s\n", r->src->name, r->dst->name);
	fprintf(fd, DELETE "[IPsec-%s-%s]\n", r->src->name, r->dst->name);
	fprintf(fd, DELETE "[qm-%s-%s]\n", r->src->name, r->dst->name);
d638 32
d673 1
@


1.54
log
@fix typo for remote port; from Brian Candler
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.53 2006/11/21 13:51:17 markus Exp $	*/
d42 1
a42 1
		    ipsec_addr_wrap *, struct ipsec_addr_wrap *, FILE *);
d178 1
a178 1
    struct ipsec_addr_wrap *peer, FILE *fd)
d196 4
d602 1
a602 1
	ike_section_ipsec(r->src, r->dst, r->peer, fd);
@


1.53
log
@do not delete sections that might be shared with other connections
however, this workaround might leak config entries in isakmpd;
ok (for now) hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.52 2006/11/01 03:12:14 mcbride Exp $	*/
d565 1
a565 1
		fprintf(fd, SET "[rid-%s]:Port=%d force\n", src->name,
@


1.52
log
@KNF unrelated to previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.51 2006/11/01 03:10:02 mcbride Exp $	*/
d613 1
d642 5
@


1.51
log
@Add support for aggressive mode (from the k2k6 IPsec hackathon).

ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.50 2006/09/18 13:45:45 hshoexer Exp $	*/
d556 4
a559 2
		fprintf(fd, SET "[lid-%s]:Protocol=%d force\n", src->name, proto);
		fprintf(fd, SET "[rid-%s]:Protocol=%d force\n", dst->name, proto);
@


1.50
log
@KNF and clean some trailing white spaces, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.49 2006/08/30 12:18:10 msf Exp $	*/
d43 3
a45 1
static int	ike_section_qm(struct ipsec_addr_wrap *, struct
d47 2
a48 4
		    ipsec_transforms *, FILE *);
static int	ike_section_mm(struct ipsec_addr_wrap *, struct
		    ipsec_transforms *, FILE *, struct ike_auth *);
static void	ike_section_qmids(u_int8_t, struct ipsec_addr_wrap *,
d78 1
a78 1
	if (r->mmlife && r->mmlife->lifetime != -1)
d80 2
a81 2
		    r->mmlife->lifetime);
	if (r->qmlife && r->qmlife->lifetime != -1)
d83 1
a83 1
		    r->qmlife->lifetime);
d199 21
a219 6
ike_section_qm(struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
    u_int8_t satype, u_int8_t tmode, struct ipsec_transforms *qmxfs, FILE *fd)
{
	fprintf(fd, SET "[qm-%s-%s]:EXCHANGE_TYPE=QUICK_MODE force\n",
	    src->name, dst->name);
	fprintf(fd, SET "[qm-%s-%s]:Suites=QM-", src->name, dst->name);
d346 2
a347 2
ike_section_mm(struct ipsec_addr_wrap *peer, struct ipsec_transforms *mmxfs,
    FILE *fd, struct ike_auth *auth)
d349 16
d366 5
a370 5
		fprintf(fd, SET "[peer-%s]:Configuration=mm-%s force\n",
		    peer->name, peer->name);
		fprintf(fd, SET "[mm-%s]:EXCHANGE_TYPE=ID_PROT force\n",
		    peer->name);
		fprintf(fd, ADD "[mm-%s]:Transforms=", peer->name);
d373 4
a376 3
		    "[peer-default]:Configuration=mm-default force\n");
		fprintf(fd, SET "[mm-default]:EXCHANGE_TYPE=ID_PROT force\n");
		fprintf(fd, ADD "[mm-default]:Transforms=");
d379 2
a380 2
	if (mmxfs && mmxfs->encxf) {
		switch (mmxfs->encxf->id) {
d397 1
a397 1
			warnx("illegal transform %s", mmxfs->encxf->name);
d404 2
a405 2
	if (mmxfs && mmxfs->authxf) {
		switch (mmxfs->authxf->id) {
d422 1
a422 1
			warnx("illegal transform %s", mmxfs->authxf->name);
d428 2
a429 2
	if (mmxfs && mmxfs->groupxf) {
		switch (mmxfs->groupxf->id) {
d455 1
a455 1
			warnx("illegal group %s", mmxfs->groupxf->name);
d468 1
a468 1
ike_section_qmids(u_int8_t proto, struct ipsec_addr_wrap *src,
d498 1
a498 1
			err(1, "ike_section_qmids: strdup");
d538 1
a538 1
			err(1, "ike_section_qmids: strdup");
d592 2
a593 1
	if (ike_section_mm(r->peer, r->mmxfs, fd, r->ikeauth) == -1)
d597 2
a598 2
	if (ike_section_qm(r->src, r->dst, r->satype, r->tmode, r->qmxfs, fd)
	    == -1)
d600 1
a600 1
	ike_section_qmids(r->proto, r->src, r->sport, r->dst, r->dport, fd);
d627 1
@


1.49
log
@actually use the right value for USER_FQDN

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.48 2006/08/29 18:10:31 msf Exp $	*/
d141 2
a142 1
		fprintf(fd, SET "[%s-ID]:ID-type=%s force\n", auth->srcid, ike_id_types[idtype]);
d159 2
a160 1
			fprintf(fd, SET "[default-ID]:ID-type=%s force\n", ike_id_types[idtype]);
d168 2
a169 2
ike_get_id_type(char *string) 
{ 
@


1.48
log
@add support for ufqdn ids in ike rules

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.47 2006/08/29 17:52:40 naddy Exp $	*/
d67 1
a67 1
char *ike_id_types[] = { "", "", "FQDN", "UFQDN" };
@


1.47
log
@Add support for IKE AH rules to ipsecctl.  Man page input by jmc@@.
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.46 2006/07/21 12:34:52 hshoexer Exp $	*/
d40 1
d67 2
d132 2
d141 1
a141 1
		fprintf(fd, SET "[%s-ID]:ID-type=FQDN force\n", auth->srcid);
d146 2
d151 2
a152 2
			fprintf(fd, SET "[%s-ID]:ID-type=FQDN force\n",
			    peer->name);
d158 1
a158 1
			fprintf(fd, SET "[default-ID]:ID-type=FQDN force\n");
d163 9
@


1.46
log
@When no peer is specified, no peer address is defined, thus do not use it.
Noticed by Alexey E. Suslikov <cruel@@texnika.com.ua>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.45 2006/06/18 18:18:01 hshoexer Exp $	*/
d192 3
d213 27
a239 20
		switch (qmxfs->encxf->id) {
		case ENCXF_3DES_CBC:
			fprintf(fd, "3DES");
			break;
		case ENCXF_DES_CBC:
			fprintf(fd, "DES");
			break;
		case ENCXF_AES:
			fprintf(fd, "AES");
			break;
		case ENCXF_AESCTR:
			fprintf(fd, "AESCTR");
			break;
		case ENCXF_BLOWFISH:
			fprintf(fd, "BLF");
			break;
		case ENCXF_CAST128:
			fprintf(fd, "CAST");
			break;
		default:
d243 2
a244 3
	} else
		fprintf(fd, "AES");
	fprintf(fd, "-");
@


1.45
log
@add group "none"; when choosen, pfs will be disabled.

ok david msf
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.44 2006/06/16 18:46:26 hshoexer Exp $	*/
d93 6
d102 8
a110 6
	if (local)
		fprintf(fd, SET "[peer-%s]:Local-address=%s force\n",
		    peer->name, local->name);
	if (auth->type == IKE_AUTH_PSK)
		fprintf(fd, SET "[peer-%s]:Authentication=%s force\n",
		    peer->name, auth->string);
@


1.44
log
@add a missing "force"
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.43 2006/06/15 16:57:24 hshoexer Exp $	*/
d258 2
d288 2
a289 1
	} 
@


1.43
log
@be careful when touch the peer component of a rule.  It is not
necessarily set anymore, as now the peer can be left out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.42 2006/06/13 16:13:41 naddy Exp $	*/
d303 2
a304 1
		fprintf(fd, SET "[peer-default]:Configuration=mm-default\n");
@


1.42
log
@For IKE, allow main mode SHA2 and quick mode AESCTR transforms,
which were recently added to isakmpd.  ok hshoexer@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.41 2006/06/10 19:21:10 hshoexer Exp $	*/
d552 4
a555 1
	fprintf(fd, DELETE "[peer-%s]\n", r->peer->name);
a563 1
	fprintf(fd, DELETE "[mm-%s]\n", r->peer->name);
@


1.41
log
@switch back to original defaults regarding DH groups.  modp3072 is to
heavyweight.  Testing by Jason George, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.40 2006/06/08 22:34:30 hshoexer Exp $	*/
d212 3
d340 9
@


1.40
log
@fix some indentation, noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.39 2006/06/08 21:15:21 naddy Exp $	*/
a251 1
	fprintf(fd, "-PFS-");
d256 1
a256 1
			fprintf(fd, "GRP1");
d259 1
a259 1
			fprintf(fd, "GRP2");
d262 1
a262 1
			fprintf(fd, "GRP5");
d265 1
a265 1
			fprintf(fd, "GRP14");
d268 1
a268 1
			fprintf(fd, "GRP15");
d271 1
a271 1
			fprintf(fd, "GRP16");
d274 1
a274 1
			fprintf(fd, "GRP17");
d277 1
a277 1
			fprintf(fd, "GRP18");
d283 1
a283 2
	} else
		fprintf(fd, "GRP15");
a343 1
	fprintf(fd, "-");
d348 1
a348 1
			fprintf(fd, "GRP1");
d351 1
a351 1
			fprintf(fd, "GRP2");
d354 1
a354 1
			fprintf(fd, "GRP5");
d357 1
a357 1
			fprintf(fd, "GRP14");
d360 1
a360 1
			fprintf(fd, "GRP15");
d363 1
a363 1
			fprintf(fd, "GRP16");
d366 1
a366 1
			fprintf(fd, "GRP17");
d369 1
a369 1
			fprintf(fd, "GRP18");
d375 1
a375 2
	} else
		fprintf(fd, "GRP15");
@


1.39
log
@Add a transport mode specifier to ike rules.  Tunnel mode remains the default.
"looks right" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.38 2006/06/08 20:52:43 todd Exp $	*/
d457 1
a457 1
		
@


1.38
log
@allocate enough storage via sockaddr_storage for sockaddr_in6,
fixes ike29.in in regress
looks right hshoexer@@, ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.37 2006/06/08 18:25:50 hshoexer Exp $	*/
d43 2
a44 2
		    ipsec_addr_wrap *, u_int8_t, struct ipsec_transforms *,
		    FILE *);
d174 1
a174 1
    u_int8_t satype, struct ipsec_transforms *qmxfs, FILE *fd)
d190 11
d517 2
a518 1
	if (ike_section_qm(r->src, r->dst, r->satype, r->qmxfs, fd) == -1)
@


1.37
log
@Fix a typo:  When testing for quick mode lifetimes, make sure to
reference quick mode lifetimes, too, not main mode lifetimes.
Otherwise we might dereference a NULL pointer...
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.36 2006/06/02 15:43:37 naddy Exp $	*/
d382 2
a383 1
	struct sockaddr sa;
d386 1
a386 1
		bzero(&sa, sizeof(struct sockaddr));
d388 1
a388 1
		sa.sa_family = src->af;
d391 1
a391 1
			sa.sa_len = sizeof(struct sockaddr_in);
d393 1
a393 1
			    &((struct sockaddr_in *)(&sa))->sin_addr,
d397 1
a397 1
			sa.sa_len = sizeof(struct sockaddr_in6);
d399 1
a399 1
			    &((struct sockaddr_in6 *)(&sa))->sin6_addr,
d403 1
a403 1
		if (getnameinfo(&sa, sa.sa_len, mask, sizeof(mask), NULL, 0,
d426 1
a426 1
		bzero(&sa, sizeof(struct sockaddr));
d428 1
a428 1
		sa.sa_family = dst->af;
d431 1
a431 1
			sa.sa_len = sizeof(struct sockaddr_in);
d433 1
a433 1
			    &((struct sockaddr_in *)(&sa))->sin_addr,
d437 1
a437 1
			sa.sa_len = sizeof(struct sockaddr_in6);
d439 1
a439 1
			    &((struct sockaddr_in6 *)(&sa))->sin6_addr,
d443 1
a443 1
		if (getnameinfo(&sa, sa.sa_len, mask, sizeof(mask), NULL, 0,
@


1.36
log
@support tcp/udp port modifiers in ike rules
"put it in if it doesn't break regress" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.35 2006/06/02 05:59:31 hshoexer Exp $	*/
d78 1
a78 1
	if (r->qmlife && r->mmlife->lifetime != -1)
@


1.35
log
@allow to specify phase 1 and 2 lifetimes.  Right now, these values
can only be set globally (ie. Default-phase-[12]-lifetime).
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.34 2006/06/02 03:40:26 hshoexer Exp $	*/
d47 2
a48 2
static void	ike_section_qmids(u_int8_t, struct ipsec_addr_wrap *, struct
		    ipsec_addr_wrap *, FILE *);
d379 1
a379 1
    struct ipsec_addr_wrap *dst, FILE *fd)
d468 6
d507 1
a507 1
	ike_section_qmids(r->proto, r->src, r->dst, fd);
@


1.34
log
@Simplify main/quick mode parsing and generation of the actual ike config.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.33 2006/06/01 18:03:40 msf Exp $	*/
d75 6
@


1.33
log
@change the local-ID section name to always be unique as we may want to use more than one ISAKMP ID on the local peer.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.32 2006/06/01 06:46:35 hshoexer Exp $	*/
d184 1
a184 1
	if (qmxfs->encxf) {
d209 1
a209 1
	if (qmxfs->authxf) {
d237 1
a237 1
	if (qmxfs->groupxf) {
d290 1
a290 1
	if (mmxfs->encxf) {
d315 1
a315 1
	if (mmxfs->authxf) {
d331 1
a331 1
	if (mmxfs->groupxf) {
@


1.32
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.31 2006/06/01 06:14:05 todd Exp $	*/
d117 1
a117 1
			    peer->name, "local");
d120 1
a120 1
			    "local");
d122 2
a123 2
		fprintf(fd, SET "[%s-ID]:ID-type=FQDN force\n", "local");
		fprintf(fd, SET "[%s-ID]:Name=%s force\n", "local",
@


1.31
log
@permit feeding isakmpd.fifo IPv6 addresses
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.30 2006/06/01 02:19:22 hshoexer Exp $	*/
d385 3
a387 2
			bcopy(&src->mask.ipa, &((struct sockaddr_in *)(&sa))->sin_addr,
				sizeof(struct in6_addr));
d391 3
a393 2
			bcopy(&src->mask.ipa, &((struct sockaddr_in6 *)(&sa))->sin6_addr,
				sizeof(struct in6_addr));
d396 4
a399 3
		if (getnameinfo(&sa, sa.sa_len, mask, sizeof(mask), NULL, 0, NI_NUMERICHOST)) {
			err(1, "could not get a numeric mask");
		}
d425 3
a427 2
			bcopy(&dst->mask.ipa, &((struct sockaddr_in *)(&sa))->sin_addr,
				sizeof(struct in6_addr));
d431 3
a433 2
			bcopy(&dst->mask.ipa, &((struct sockaddr_in6 *)(&sa))->sin6_addr,
				sizeof(struct in6_addr));
d436 4
a439 3
		if (getnameinfo(&sa, sa.sa_len, mask, sizeof(mask), NULL, 0, NI_NUMERICHOST)) {
			err(1, "could not get a numeric mask");
		}
@


1.30
log
@Generate correct configuration for default peers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.29 2006/05/31 02:28:35 hshoexer Exp $	*/
d23 1
d375 2
a376 1
	char *mask, *network, *p;
d379 18
a396 1
		mask = inet_ntoa(src->mask.v4);
d402 2
a403 2
		fprintf(fd, SET "[lid-%s]:ID-type=IPV4_ADDR_SUBNET force\n",
		    src->name);
d410 2
a411 2
		fprintf(fd, SET "[lid-%s]:ID-type=IPV4_ADDR force\n",
		    src->name);
d416 18
a433 1
		mask = inet_ntoa(dst->mask.v4);
d439 2
a440 2
		fprintf(fd, SET "[rid-%s]:ID-type=IPV4_ADDR_SUBNET force\n",
		    dst->name);
d447 2
a448 2
		fprintf(fd, SET "[rid-%s]:ID-type=IPV4_ADDR force\n",
		    dst->name);
@


1.29
log
@Small function header knf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.28 2006/05/31 02:26:41 hshoexer Exp $	*/
d118 2
a119 1
			fprintf(fd, SET "[peer-default]:ID=default-ID force\n");
d126 1
a126 1
		if (peer)
d129 5
a133 1
		else
d136 4
a139 4
			
		fprintf(fd, SET "[%s-ID]:ID-type=FQDN force\n", peer->name);
		fprintf(fd, SET "[%s-ID]:Name=%s force\n", peer->name,
		    auth->dstid);
@


1.28
log
@Prepare for handling unnamed remote peers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.27 2006/05/28 08:30:04 todd Exp $	*/
d366 2
a367 2
ike_section_qmids(u_int8_t proto, struct ipsec_addr_wrap *src, struct ipsec_addr_wrap
    *dst, FILE *fd)
d418 2
a419 2
ike_connect(u_int8_t mode, struct ipsec_addr_wrap *src, struct ipsec_addr_wrap
    *dst, FILE *fd)
@


1.27
log
@matching brackets are useful
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.26 2006/05/27 17:21:40 hshoexer Exp $	*/
d80 10
a89 3
	fprintf(fd, SET "[Phase 1]:%s=peer-%s force\n", peer->name, peer->name);
	fprintf(fd, SET "[peer-%s]:Phase=1 force\n", peer->name);
	fprintf(fd, SET "[peer-%s]:Address=%s force\n", peer->name, peer->name);
d114 6
a119 2
		fprintf(fd, SET "[peer-%s]:ID=%s-ID force\n", peer->name,
		    "local");
d125 7
a131 2
		fprintf(fd, SET "[peer-%s]:Remote-ID=%s-ID force\n",
		    peer->name, peer->name);
d143 9
a151 2
	fprintf(fd, SET "[IPsec-%s-%s]:ISAKMP-peer=peer-%s force\n", src->name,
	    dst->name, peer->name);
d272 11
a282 4
	fprintf(fd, SET "[peer-%s]:Configuration=mm-%s force\n", peer->name,
	    peer->name);
	fprintf(fd, SET "[mm-%s]:EXCHANGE_TYPE=ID_PROT force\n", peer->name);
	fprintf(fd, ADD "[mm-%s]:Transforms=", peer->name);
@


1.26
log
@allow to specify groups to be used IKE
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.25 2006/05/15 07:50:26 deraadt Exp $	*/
d84 1
a84 1
		fprintf(fd, SET "[peer-%s:Local-address=%s force\n",
@


1.25
log
@delete weird C
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.24 2006/04/13 11:55:07 hshoexer Exp $	*/
d206 35
a240 1
	fprintf(fd, "-PFS-SUITE force\n");
d293 34
@


1.24
log
@Add support for "local" to ike rules.  Allows to specify the local IP to be
used on a multi-homed machine.  Also, relax order of peer/local keywords.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.23 2006/03/31 14:11:39 hshoexer Exp $	*/
d152 1
a152 1
	};
d175 1
a175 1
		};
d203 1
a203 1
		};
d240 1
a240 1
		};
d256 1
a256 1
		};
@


1.23
log
@allow do delete dynamic rules

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.22 2006/03/31 14:02:08 markus Exp $	*/
d35 2
a36 2
static void	ike_section_peer(struct ipsec_addr_wrap *, FILE *,
		    struct ike_auth *);
d77 2
a78 1
ike_section_peer(struct ipsec_addr_wrap *peer, FILE *fd, struct ike_auth *auth)
d83 3
d343 1
a343 1
	ike_section_peer(r->peer, fd, r->ikeauth);
@


1.22
log
@allow specification of encapsulated protocol for ike; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.21 2006/03/31 13:13:51 markus Exp $	*/
d359 1
@


1.21
log
@allow specification of encapsulated protocol for flows; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.20 2006/03/20 17:09:38 hshoexer Exp $	*/
d46 1
a46 1
static void	ike_section_qmids(struct ipsec_addr_wrap *, struct
d264 2
a265 2
ike_section_qmids(struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst,
    FILE *fd)
d309 4
d346 1
a346 1
	ike_section_qmids(r->src, r->dst, fd);
@


1.20
log
@When being verbose while deleting ike rules (-dv), print deletions instead of
additions.  Suggested by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.19 2006/03/20 16:49:12 hshoexer Exp $	*/
d135 1
a135 1
    u_int8_t proto, struct ipsec_transforms *qmxfs, FILE *fd)
d141 1
a141 1
	switch (proto) {
d146 1
a146 1
		warnx("illegal protocol %d", proto);
d340 1
a340 1
	if (ike_section_qm(r->src, r->dst, r->proto, r->qmxfs, fd) == -1)
@


1.19
log
@When adding a connection, do not explicitly start that connection
using "t" and "c" fifo commands.  This is prone to a race when
adding several tunnels between the same peers.  Just let isakmpd
start that connection on its own (using the connection checker).
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.18 2006/03/07 00:19:58 reyk Exp $	*/
a380 1
/* ARGSUSED1 */
d384 4
a387 1
	return (ike_gen_config(r, stdout));
@


1.18
log
@add an ike option for road warrior setups (hosts with dynamic ip
addresses).

"ike dynamic esp" will use the system's hostname as the fqdn source id
(instead of the ip address) by default and enable dpd (dead peer
detection) to allow smooth reconnects after an ip address change (i.e.
forced reconnect with consumer adsl lines).

ok hshoexer@@, looks fine markus@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.17 2006/02/03 13:39:29 naddy Exp $	*/
a319 2
		fprintf(fd, "t IPsec-%s-%s\n", src->name, dst->name);
		fprintf(fd, "c IPsec-%s-%s\n", src->name, dst->name);
@


1.17
log
@override authentication tag as well; ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.16 2006/02/02 14:42:23 hshoexer Exp $	*/
d34 1
d38 1
a38 1
		    FILE *);
d62 14
d88 2
a89 1
ike_section_ids(struct ipsec_addr_wrap *peer, struct ipsec_auth *auth, FILE *fd)
d91 2
d96 6
d317 1
d336 1
d340 1
a340 1
	ike_section_ids(r->peer, r->auth, fd);
@


1.16
log
@Two fixes: generate default main mode config when using PSK, added missing
force (with naddy@@)

ok reyk@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.15 2006/01/17 00:05:42 deraadt Exp $	*/
d68 1
a68 1
		fprintf(fd, SET "[peer-%s]:Authentication=%s\n",
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.14 2006/01/16 23:57:20 reyk Exp $	*/
a186 3
	if (!(mmxfs->authxf || mmxfs->encxf))
		return (0);

d233 2
a234 3
		fprintf(fd, "-RSA_SIG\n");
	else
		fprintf(fd, "\n");
@


1.14
log
@add support for pre-shared keys with "ike esp" using the new keyword
"psk". rsa-sig is recommended and will still be used by default.

ok hshoexer@@, manpage ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.13 2005/12/28 19:18:43 naddy Exp $	*/
d373 1
a373 1
	int	 	 fd, ret = 0;
@


1.13
log
@no close() after fdopen(); ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.12 2005/12/28 10:53:12 hshoexer Exp $	*/
d34 2
a35 1
static void	ike_section_peer(struct ipsec_addr_wrap *, FILE *);
d44 1
a44 1
		    ipsec_transforms *, FILE *);
d62 1
a62 1
ike_section_peer(struct ipsec_addr_wrap *peer, FILE *fd)
d67 3
d185 1
a185 1
    FILE *fd)
d235 4
a238 1
	fprintf(fd, "-RSA_SIG\n");
d315 2
a316 2
	ike_section_peer(r->peer, fd);
	if (ike_section_mm(r->peer, r->mmxfs, fd) == -1)
@


1.12
log
@make sure isakmpd fifo is actually a fifo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.11 2005/12/12 09:44:06 hshoexer Exp $	*/
a375 1
	close(fd);
@


1.11
log
@use err() instead of errx()
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.10 2005/11/24 11:52:07 hshoexer Exp $	*/
d20 1
d58 2
d354 1
d364 13
a376 5
	FILE	*fd;
	int	 ret = 0;

	if ((fd = fopen("/var/run/isakmpd.fifo", "w")) == NULL)
		err(1, "ike_ipsec_establish: fopen");
d380 1
a380 1
		ret = ike_gen_config(r, fd);
d383 1
a383 1
		ret = ike_delete_config(r, fd);
d389 1
a389 1
	fclose(fd);
@


1.10
log
@Remove old-style keyed sha1/md5.  We only support hmac-sha1/md5.
Noticed the hard way by <raff at brodewicz dot pl>
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.9 2005/11/12 16:41:39 deraadt Exp $	*/
d364 1
a364 1
		errx(1, "ike_ipsec_establish: fopen");
@


1.9
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.8 2005/11/06 22:51:51 hshoexer Exp $	*/
a147 1
		case AUTHXF_MD5:
a150 1
		case AUTHXF_SHA1:
a215 1
		case AUTHXF_MD5:
a218 1
		case AUTHXF_SHA1:
@


1.8
log
@Improved address and address mask handling, derived from pfctl stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.7 2005/11/06 10:52:27 hshoexer Exp $	*/
d109 1
a109 1
	
d275 1
a275 1
		
@


1.7
log
@better handling of ip addresses, prepare for v6.  Partially derived from diff
by todd@@.  Work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.6 2005/10/28 07:18:47 hshoexer Exp $	*/
d33 2
a34 2
static void	ike_section_peer(struct ipsec_addr *, FILE *);
static void	ike_section_ids(struct ipsec_addr *, struct ipsec_auth *,
d36 4
a39 9
static void	ike_section_ipsec(struct ipsec_addr *, struct ipsec_addr *,
		    struct ipsec_addr *, FILE *);
static int	ike_section_qm(struct ipsec_addr *, struct ipsec_addr *,
		    u_int8_t, struct ipsec_transforms *, FILE *);
static int	ike_section_mm(struct ipsec_addr *, struct ipsec_transforms *,
		    FILE *);
static void	ike_section_qmids(struct ipsec_addr *, struct ipsec_addr *,
		    FILE *);
static int	ike_connect(u_int8_t, struct ipsec_addr *, struct ipsec_addr *,
d41 6
d58 1
a58 1
ike_section_peer(struct ipsec_addr *peer, FILE *fd)
d66 1
a66 1
ike_section_ids(struct ipsec_addr *peer, struct ipsec_auth *auth, FILE *fd)
d88 2
a89 2
ike_section_ipsec(struct ipsec_addr *src, struct ipsec_addr *dst, struct
    ipsec_addr *peer, FILE *fd)
d103 2
a104 2
ike_section_qm(struct ipsec_addr *src, struct ipsec_addr *dst, u_int8_t proto,
    struct ipsec_transforms *qmxfs, FILE *fd)
d179 1
a179 1
ike_section_mm(struct ipsec_addr *peer, struct ipsec_transforms *mmxfs,
d238 2
a239 1
ike_section_qmids(struct ipsec_addr *src, struct ipsec_addr *dst, FILE *fd)
d286 2
a287 2
ike_connect(u_int8_t mode, struct ipsec_addr *src, struct ipsec_addr *dst,
    FILE *fd)
@


1.6
log
@more error message cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.5 2005/10/16 19:52:19 hshoexer Exp $	*/
d242 1
a242 1
		mask = inet_ntoa(src->v4mask.mask);
d262 1
a262 1
		mask = inet_ntoa(dst->v4mask.mask);
@


1.5
log
@cleanup messages generated by err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.4 2005/09/22 15:07:29 hshoexer Exp $	*/
d366 1
a366 1
		errx(1, "fopen");
@


1.4
log
@use "force" keyword when adding to Phase 1 section, otherwise isakmpd will
write some annyoing warning to the logs...
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.3 2005/09/20 17:30:58 hshoexer Exp $	*/
d244 1
a244 1
			err(1, "strdup");
d264 1
a264 1
			err(1, "strdup");
@


1.3
log
@add an entry to "Phase 1" section for each remote peer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike.c,v 1.1 2005/08/22 17:26:46 hshoexer Exp $	*/
d59 1
a59 1
	fprintf(fd, SET "[Phase 1]:%s=peer-%s\n", peer->name, peer->name);
@


1.2
log
@add a "Connection=..." entry for active connections
@
text
@d59 1
@


1.1
log
@Teach ipsecctl to control isakmpd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.25 2005/08/09 12:37:45 hshoexer Exp $	*/
d288 2
@

