head	1.168;
access;
symbols
	OPENBSD_6_2_BASE:1.168
	OPENBSD_6_1:1.166.0.4
	OPENBSD_6_1_BASE:1.166
	OPENBSD_6_0:1.165.0.2
	OPENBSD_6_0_BASE:1.165
	OPENBSD_5_9:1.164.0.2
	OPENBSD_5_9_BASE:1.164
	OPENBSD_5_8:1.162.0.4
	OPENBSD_5_8_BASE:1.162
	OPENBSD_5_7:1.161.0.2
	OPENBSD_5_7_BASE:1.161
	OPENBSD_5_6:1.159.0.6
	OPENBSD_5_6_BASE:1.159
	OPENBSD_5_5:1.159.0.4
	OPENBSD_5_5_BASE:1.159
	OPENBSD_5_4:1.156.0.6
	OPENBSD_5_4_BASE:1.156
	OPENBSD_5_3:1.156.0.4
	OPENBSD_5_3_BASE:1.156
	OPENBSD_5_2:1.156.0.2
	OPENBSD_5_2_BASE:1.156
	OPENBSD_5_1_BASE:1.152
	OPENBSD_5_1:1.152.0.2
	OPENBSD_5_0:1.151.0.2
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.150.0.2
	OPENBSD_4_9_BASE:1.150
	OPENBSD_4_8:1.148.0.2
	OPENBSD_4_8_BASE:1.148
	OPENBSD_4_7:1.146.0.2
	OPENBSD_4_7_BASE:1.146
	OPENBSD_4_6:1.145.0.4
	OPENBSD_4_6_BASE:1.145
	OPENBSD_4_5:1.144.0.2
	OPENBSD_4_5_BASE:1.144
	OPENBSD_4_4:1.138.0.2
	OPENBSD_4_4_BASE:1.138
	OPENBSD_4_3:1.133.0.2
	OPENBSD_4_3_BASE:1.133
	OPENBSD_4_2:1.125.0.2
	OPENBSD_4_2_BASE:1.125
	OPENBSD_4_1:1.121.0.2
	OPENBSD_4_1_BASE:1.121
	OPENBSD_4_0:1.108.0.2
	OPENBSD_4_0_BASE:1.108
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24;
locks; strict;
comment	@ * @;


1.168
date	2017.04.19.15.59.38;	author bluhm;	state Exp;
branches;
next	1.167;
commitid	CiHS8CSu2u0AMgvM;

1.167
date	2017.04.14.18.06.28;	author bluhm;	state Exp;
branches;
next	1.166;
commitid	mFgJjuy1SZ9lenK0;

1.166
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.165;
commitid	uzjOUwLRoN7KbcZI;

1.165
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.164;
commitid	AL6SnrmnHkmPOpjv;

1.164
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.163;
commitid	CLwtYUTkBZ3FXV1w;

1.163
date	2015.11.04.12.46.13;	author mikeb;	state Exp;
branches;
next	1.162;
commitid	TJX0if8DFoSZbZ4V;

1.162
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.161;
commitid	GouatFiJVxwlAVIQ;

1.161
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.160;
commitid	3Z7yItGpFsmshk0c;

1.160
date	2014.11.04.05.56.39;	author doug;	state Exp;
branches;
next	1.159;
commitid	frR55rjKNE3g9Bb0;

1.159
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2013.11.25.12.52.12;	author benno;	state Exp;
branches;
next	1.157;

1.157
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2012.07.10.13.58.33;	author lteo;	state Exp;
branches;
next	1.155;

1.155
date	2012.07.08.17.51.51;	author naddy;	state Exp;
branches;
next	1.154;

1.154
date	2012.07.07.20.29.23;	author naddy;	state Exp;
branches;
next	1.153;

1.153
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.152;

1.152
date	2011.12.20.13.27.51;	author mikeb;	state Exp;
branches;
next	1.151;

1.151
date	2011.07.06.22.03.00;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.149;

1.149
date	2010.09.22.14.04.09;	author mikeb;	state Exp;
branches;
next	1.148;

1.148
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2010.05.10.02.00.50;	author krw;	state Exp;
branches;
next	1.146;

1.146
date	2009.08.04.15.05.50;	author jsing;	state Exp;
branches;
next	1.145;

1.145
date	2009.03.31.21.03.48;	author tobias;	state Exp;
branches;
next	1.144;

1.144
date	2009.01.30.14.24.52;	author bluhm;	state Exp;
branches;
next	1.143;

1.143
date	2009.01.29.15.37.09;	author bluhm;	state Exp;
branches;
next	1.142;

1.142
date	2009.01.28.18.07.19;	author bluhm;	state Exp;
branches;
next	1.141;

1.141
date	2009.01.20.14.36.19;	author mpf;	state Exp;
branches;
next	1.140;

1.140
date	2008.11.14.23.16.37;	author hshoexer;	state Exp;
branches;
next	1.139;

1.139
date	2008.10.17.14.33.15;	author henning;	state Exp;
branches;
next	1.138;

1.138
date	2008.07.01.14.31.37;	author bluhm;	state Exp;
branches;
next	1.137;

1.137
date	2008.07.01.14.08.39;	author bluhm;	state Exp;
branches;
next	1.136;

1.136
date	2008.06.14.00.57.30;	author bluhm;	state Exp;
branches;
next	1.135;

1.135
date	2008.06.11.22.11.20;	author bluhm;	state Exp;
branches;
next	1.134;

1.134
date	2008.04.11.00.05.51;	author reyk;	state Exp;
branches;
next	1.133;

1.133
date	2008.02.22.23.51.31;	author hshoexer;	state Exp;
branches;
next	1.132;

1.132
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.131;

1.131
date	2007.10.22.16.35.33;	author pyr;	state Exp;
branches;
next	1.130;

1.130
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.129;

1.129
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2007.10.13.16.35.18;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2007.10.11.14.39.16;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2007.09.12.20.22.59;	author hshoexer;	state Exp;
branches;
next	1.125;

1.125
date	2007.08.10.12.32.12;	author markus;	state Exp;
branches;
next	1.124;

1.124
date	2007.07.03.11.32.27;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2007.05.10.06.10.04;	author hshoexer;	state Exp;
branches;
next	1.122;

1.122
date	2007.03.16.20.51.01;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2007.02.26.14.40.09;	author todd;	state Exp;
branches;
next	1.120;

1.120
date	2007.02.19.09.00.46;	author hshoexer;	state Exp;
branches;
next	1.119;

1.119
date	2007.02.19.08.29.30;	author hshoexer;	state Exp;
branches;
next	1.118;

1.118
date	2007.02.16.10.16.09;	author hshoexer;	state Exp;
branches;
next	1.117;

1.117
date	2007.01.10.14.37.09;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2007.01.04.21.31.21;	author markus;	state Exp;
branches;
next	1.115;

1.115
date	2007.01.02.23.27.33;	author itojun;	state Exp;
branches;
next	1.114;

1.114
date	2006.11.24.13.52.13;	author reyk;	state Exp;
branches;
next	1.113;

1.113
date	2006.11.13.11.04.05;	author mcbride;	state Exp;
branches;
next	1.112;

1.112
date	2006.11.10.15.01.31;	author msf;	state Exp;
branches;
next	1.111;

1.111
date	2006.11.10.14.42.19;	author hshoexer;	state Exp;
branches;
next	1.110;

1.110
date	2006.11.01.03.10.02;	author mcbride;	state Exp;
branches;
next	1.109;

1.109
date	2006.09.22.10.22.49;	author hshoexer;	state Exp;
branches;
next	1.108;

1.108
date	2006.06.18.18.18.01;	author hshoexer;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2006.06.16.10.09.51;	author hshoexer;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.11.20.21.08;	author hshoexer;	state Exp;
branches;
next	1.105;

1.105
date	2006.06.10.19.38.24;	author hshoexer;	state Exp;
branches;
next	1.104;

1.104
date	2006.06.10.12.02.56;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2006.06.08.22.34.30;	author hshoexer;	state Exp;
branches;
next	1.102;

1.102
date	2006.06.08.21.15.21;	author naddy;	state Exp;
branches;
next	1.101;

1.101
date	2006.06.08.16.51.25;	author todd;	state Exp;
branches;
next	1.100;

1.100
date	2006.06.07.23.02.52;	author hshoexer;	state Exp;
branches;
next	1.99;

1.99
date	2006.06.07.21.57.52;	author hshoexer;	state Exp;
branches;
next	1.98;

1.98
date	2006.06.07.21.49.46;	author hshoexer;	state Exp;
branches;
next	1.97;

1.97
date	2006.06.02.15.43.37;	author naddy;	state Exp;
branches;
next	1.96;

1.96
date	2006.06.02.05.59.31;	author hshoexer;	state Exp;
branches;
next	1.95;

1.95
date	2006.06.02.05.57.05;	author hshoexer;	state Exp;
branches;
next	1.94;

1.94
date	2006.06.02.05.01.27;	author hshoexer;	state Exp;
branches;
next	1.93;

1.93
date	2006.06.02.04.51.55;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2006.06.02.03.40.26;	author hshoexer;	state Exp;
branches;
next	1.91;

1.91
date	2006.06.02.03.31.20;	author hshoexer;	state Exp;
branches;
next	1.90;

1.90
date	2006.06.02.00.33.47;	author hshoexer;	state Exp;
branches;
next	1.89;

1.89
date	2006.06.01.22.44.03;	author hshoexer;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.01.17.32.20;	author naddy;	state Exp;
branches;
next	1.87;

1.87
date	2006.06.01.15.33.08;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2006.06.01.06.50.58;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.01.05.55.04;	author hshoexer;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.01.05.48.31;	author todd;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.01.02.20.44;	author hshoexer;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.31.14.38.31;	author hshoexer;	state Exp;
branches;
next	1.81;

1.81
date	2006.05.31.09.03.43;	author todd;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.29.20.12.14;	author hshoexer;	state Exp;
branches;
next	1.79;

1.79
date	2006.05.29.18.50.27;	author hshoexer;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.29.16.04.25;	author hshoexer;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.29.15.59.49;	author hshoexer;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.29.15.48.46;	author hshoexer;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.29.15.22.40;	author hshoexer;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.29.15.18.17;	author hshoexer;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.29.04.18.16;	author hshoexer;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.29.03.53.04;	author hshoexer;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.29.03.38.28;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.28.21.24.09;	author hshoexer;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.28.21.10.10;	author hshoexer;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.28.01.36.06;	author todd;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.27.17.21.40;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.26.01.06.11;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.15.08.39.51;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.11.20.40.12;	author hshoexer;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.20.09.03.23;	author hshoexer;	state Exp;
branches;
next	1.62;

1.62
date	2006.04.19.17.28.28;	author hshoexer;	state Exp;
branches;
next	1.61;

1.61
date	2006.04.19.17.19.45;	author hshoexer;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.19.16.10.50;	author hshoexer;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.19.15.49.49;	author hshoexer;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.13.11.55.07;	author hshoexer;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.31.14.02.08;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.31.13.13.51;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.30.15.30.18;	author hshoexer;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.30.12.44.20;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.22.16.01.23;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.07.00.30.28;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.07.00.19.58;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.20.16.11.22;	author naddy;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.17.05.39.23;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.16.23.57.20;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.12.09.41.51;	author hshoexer;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.06.14.27.57;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.01.15.14.47;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.27.09.47.56;	author hshoexer;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.27.03.50.58;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.26.23.26.49;	author hshoexer;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.24.11.52.07;	author hshoexer;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.12.21.57.34;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.12.21.49.38;	author hshoexer;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.12.17.22.23;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.12.17.04.32;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.12.16.41.39;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.12.16.40.58;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.12.12.00.53;	author hshoexer;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.06.22.51.51;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.06.10.52.27;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.30.20.42.11;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.30.19.50.23;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.28.07.18.47;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.16.21.41.36;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.16.21.29.22;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.16.21.24.45;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.16.19.52.19;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.22.17.26.46;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.19.08.47.56;	author hshoexer;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.12.37.45;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.09.12.35.25;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.13.29.00;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.09.15.09;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.05.15.44.57;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.05.14.39.02;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.05.14.09.27;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.02.15.47.25;	author hshoexer;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.24.12.11.49;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.24.10.06.38;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.23.20.35.04;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.23.20.09.02;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.23.19.28.27;	author hshoexer;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.10.09.33.10;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.09.21.41.08;	author hshoexer;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.09.21.12.07;	author hshoexer;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.07.22.00.36;	author hshoexer;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.07.21.00.08;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.25.16.31.22;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.25.16.29.21;	author hshoexer;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.04.22.22.55;	author hshoexer;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.04.22.19.50;	author hshoexer;	state Exp;
branches;
next	;

1.108.2.1
date	2006.11.16.22.27.53;	author brad;	state Exp;
branches;
next	;


desc
@@


1.168
log
@Rename all SA groups to bundles consistently.  The first kernel
commit in 2000 that introduced the features already called them SA
bundles.  The word group is taken by Diffie-Hellman, reusing it
causes confusion.
OK hshoexer@@
@
text
@/*	$OpenBSD: parse.y,v 1.167 2017/04/14 18:06:28 bluhm Exp $	*/

/*
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 * Copyright (c) 2004, 2005 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <netdb.h>

#include "ipsecctl.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 yywarn(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);
int		 cmdline_symset(char *);

#define KEYSIZE_LIMIT	1024

static struct ipsecctl	*ipsec = NULL;
static int		 debug = 0;

const struct ipsec_xf authxfs[] = {
	{ "unknown",		AUTHXF_UNKNOWN,		0,	0 },
	{ "none",		AUTHXF_NONE,		0,	0 },
	{ "hmac-md5",		AUTHXF_HMAC_MD5,	16,	0 },
	{ "hmac-ripemd160",	AUTHXF_HMAC_RIPEMD160,	20,	0 },
	{ "hmac-sha1",		AUTHXF_HMAC_SHA1,	20,	0 },
	{ "hmac-sha2-256",	AUTHXF_HMAC_SHA2_256,	32,	0 },
	{ "hmac-sha2-384",	AUTHXF_HMAC_SHA2_384,	48,	0 },
	{ "hmac-sha2-512",	AUTHXF_HMAC_SHA2_512,	64,	0 },
	{ NULL,			0,			0,	0 },
};

const struct ipsec_xf encxfs[] = {
	{ "unknown",		ENCXF_UNKNOWN,		0,	0,	0, 0 },
	{ "none",		ENCXF_NONE,		0,	0,	0, 0 },
	{ "3des-cbc",		ENCXF_3DES_CBC,		24,	24,	0, 0 },
	{ "aes",		ENCXF_AES,		16,	32,	0, 0 },
	{ "aes-128",		ENCXF_AES_128,		16,	16,	0, 0 },
	{ "aes-192",		ENCXF_AES_192,		24,	24,	0, 0 },
	{ "aes-256",		ENCXF_AES_256,		32,	32,	0, 0 },
	{ "aesctr",		ENCXF_AESCTR,		16+4,	32+4,	0, 1 },
	{ "aes-128-ctr",	ENCXF_AES_128_CTR,	16+4,	16+4,	0, 1 },
	{ "aes-192-ctr",	ENCXF_AES_192_CTR,	24+4,	24+4,	0, 1 },
	{ "aes-256-ctr",	ENCXF_AES_256_CTR,	32+4,	32+4,	0, 1 },
	{ "aes-128-gcm",	ENCXF_AES_128_GCM,	16+4,	16+4,	1, 1 },
	{ "aes-192-gcm",	ENCXF_AES_192_GCM,	24+4,	24+4,	1, 1 },
	{ "aes-256-gcm",	ENCXF_AES_256_GCM,	32+4,	32+4,	1, 1 },
	{ "aes-128-gmac",	ENCXF_AES_128_GMAC,	16+4,	16+4,	1, 1 },
	{ "aes-192-gmac",	ENCXF_AES_192_GMAC,	24+4,	24+4,	1, 1 },
	{ "aes-256-gmac",	ENCXF_AES_256_GMAC,	32+4,	32+4,	1, 1 },
	{ "blowfish",		ENCXF_BLOWFISH,		5,	56,	0, 0 },
	{ "cast128",		ENCXF_CAST128,		5,	16,	0, 0 },
	{ "chacha20-poly1305",	ENCXF_CHACHA20_POLY1305, 32+4,	32+4,	1, 1 },
	{ "null",		ENCXF_NULL,		0,	0,	0, 0 },
	{ NULL,			0,			0,	0,	0, 0 },
};

const struct ipsec_xf compxfs[] = {
	{ "unknown",		COMPXF_UNKNOWN,		0,	0 },
	{ "deflate",		COMPXF_DEFLATE,		0,	0 },
	{ "lzs",		COMPXF_LZS,		0,	0 },
	{ NULL,			0,			0,	0 },
};

const struct ipsec_xf groupxfs[] = {
	{ "unknown",		GROUPXF_UNKNOWN,	0,	0 },
	{ "none",		GROUPXF_NONE,		0,	0 },
	{ "modp768",		GROUPXF_768,		768,	0 },
	{ "grp1",		GROUPXF_768,		768,	0 },
	{ "modp1024",		GROUPXF_1024,		1024,	0 },
	{ "grp2",		GROUPXF_1024,		1024,	0 },
	{ "modp1536",		GROUPXF_1536,		1536,	0 },
	{ "grp5",		GROUPXF_1536,		1536,	0 },
	{ "modp2048",		GROUPXF_2048,		2048,	0 },
	{ "grp14",		GROUPXF_2048,		2048,	0 },
	{ "modp3072",		GROUPXF_3072,		3072,	0 },
	{ "grp15",		GROUPXF_3072,		3072,	0 },
	{ "modp4096",		GROUPXF_4096,		4096,	0 },
	{ "grp16",		GROUPXF_4096,		4096,	0 },
	{ "modp6144",		GROUPXF_6144,		6144,	0 },
	{ "grp17",		GROUPXF_6144,		6144,	0 },
	{ "modp8192",		GROUPXF_8192,		8192,	0 },
	{ "grp18",		GROUPXF_8192,		8192,	0 },
	{ NULL,			0,			0,	0 },
};

int			 atoul(char *, u_long *);
int			 atospi(char *, u_int32_t *);
u_int8_t		 x2i(unsigned char *);
struct ipsec_key	*parsekey(unsigned char *, size_t);
struct ipsec_key	*parsekeyfile(char *);
struct ipsec_addr_wrap	*host(const char *);
struct ipsec_addr_wrap	*host_v6(const char *, int);
struct ipsec_addr_wrap	*host_v4(const char *, int);
struct ipsec_addr_wrap	*host_dns(const char *, int);
struct ipsec_addr_wrap	*host_if(const char *, int);
struct ipsec_addr_wrap	*host_any(void);
void			 ifa_load(void);
int			 ifa_exists(const char *);
struct ipsec_addr_wrap	*ifa_lookup(const char *ifa_name);
struct ipsec_addr_wrap	*ifa_grouplookup(const char *);
void			 set_ipmask(struct ipsec_addr_wrap *, u_int8_t);
const struct ipsec_xf	*parse_xf(const char *, const struct ipsec_xf *);
struct ipsec_lifetime	*parse_life(const char *);
struct ipsec_transforms *copytransforms(const struct ipsec_transforms *);
struct ipsec_lifetime	*copylife(const struct ipsec_lifetime *);
struct ipsec_auth	*copyipsecauth(const struct ipsec_auth *);
struct ike_auth		*copyikeauth(const struct ike_auth *);
struct ipsec_key	*copykey(struct ipsec_key *);
struct ipsec_addr_wrap	*copyhost(const struct ipsec_addr_wrap *);
char			*copytag(const char *);
struct ipsec_rule	*copyrule(struct ipsec_rule *);
int			 validate_af(struct ipsec_addr_wrap *,
			     struct ipsec_addr_wrap *);
int			 validate_sa(u_int32_t, u_int8_t,
			     struct ipsec_transforms *, struct ipsec_key *,
			     struct ipsec_key *, u_int8_t);
struct ipsec_rule	*create_sa(u_int8_t, u_int8_t, struct ipsec_hosts *,
			     u_int32_t, struct ipsec_transforms *,
			     struct ipsec_key *, struct ipsec_key *);
struct ipsec_rule	*reverse_sa(struct ipsec_rule *, u_int32_t,
			     struct ipsec_key *, struct ipsec_key *);
struct ipsec_rule	*create_sabundle(struct ipsec_addr_wrap *, u_int8_t,
			     u_int32_t, struct ipsec_addr_wrap *, u_int8_t,
			     u_int32_t);
struct ipsec_rule	*create_flow(u_int8_t, u_int8_t, struct ipsec_hosts *,
			     u_int8_t, char *, char *, u_int8_t);
int			 set_rule_peers(struct ipsec_rule *r,
			     struct ipsec_hosts *peers);
void			 expand_any(struct ipsec_addr_wrap *);
int			 expand_rule(struct ipsec_rule *, struct ipsec_hosts *,
			     u_int8_t, u_int32_t, struct ipsec_key *,
			     struct ipsec_key *, char *);
struct ipsec_rule	*reverse_rule(struct ipsec_rule *);
struct ipsec_rule	*create_ike(u_int8_t, struct ipsec_hosts *,
			     struct ike_mode *, struct ike_mode *, u_int8_t,
			     u_int8_t, u_int8_t, char *, char *,
			     struct ike_auth *, char *);
int			 add_sabundle(struct ipsec_rule *, char *);
int			 get_id_type(char *);

struct ipsec_transforms *ipsec_transforms;

typedef struct {
	union {
		int64_t	 	 number;
		u_int8_t	 ikemode;
		u_int8_t	 dir;
		u_int8_t	 satype;	/* encapsulating prococol */
		u_int8_t	 proto;		/* encapsulated protocol */
		u_int8_t	 tmode;
		char		*string;
		u_int16_t	 port;
		struct ipsec_hosts hosts;
		struct ipsec_hosts peers;
		struct ipsec_addr_wrap *anyhost;
		struct ipsec_addr_wrap *singlehost;
		struct ipsec_addr_wrap *host;
		struct {
			char *srcid;
			char *dstid;
		} ids;
		char		*id;
		u_int8_t	 type;
		struct ike_auth	 ikeauth;
		struct {
			u_int32_t	spiout;
			u_int32_t	spiin;
		} spis;
		struct {
			struct ipsec_key *keyout;
			struct ipsec_key *keyin;
		} authkeys;
		struct {
			struct ipsec_key *keyout;
			struct ipsec_key *keyin;
		} enckeys;
		struct {
			struct ipsec_key *keyout;
			struct ipsec_key *keyin;
		} keys;
		struct ipsec_transforms *transforms;
		struct ipsec_lifetime	*life;
		struct ike_mode		*mode;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	FLOW FROM ESP AH IN PEER ON OUT TO SRCID DSTID RSA PSK TCPMD5 SPI
%token	AUTHKEY ENCKEY FILENAME AUTHXF ENCXF ERROR IKE MAIN QUICK AGGRESSIVE
%token	PASSIVE ACTIVE ANY IPIP IPCOMP COMPXF TUNNEL TRANSPORT DYNAMIC LIFETIME
%token	TYPE DENY BYPASS LOCAL PROTO USE ACQUIRE REQUIRE DONTACQ GROUP PORT TAG
%token	INCLUDE BUNDLE
%token	<v.string>		STRING
%token	<v.number>		NUMBER
%type	<v.string>		string
%type	<v.dir>			dir
%type	<v.satype>		satype
%type	<v.proto>		proto
%type	<v.number>		protoval
%type	<v.tmode>		tmode
%type	<v.hosts>		hosts
%type	<v.port>		port
%type	<v.number>		portval
%type	<v.peers>		peers
%type	<v.anyhost>		anyhost
%type	<v.singlehost>		singlehost
%type	<v.host>		host host_list host_spec
%type	<v.ids>			ids
%type	<v.id>			id
%type	<v.spis>		spispec
%type	<v.authkeys>		authkeyspec
%type	<v.enckeys>		enckeyspec
%type	<v.string>		bundlestring
%type	<v.keys>		keyspec
%type	<v.transforms>		transforms
%type	<v.ikemode>		ikemode
%type	<v.ikeauth>		ikeauth
%type	<v.type>		type
%type	<v.life>		lifetime
%type	<v.mode>		phase1mode phase2mode
%type	<v.string>		tag
%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar ikerule '\n'
		| grammar flowrule '\n'
		| grammar sarule '\n'
		| grammar tcpmd5rule '\n'
		| grammar varset '\n'
		| grammar error '\n'		{ file->errors++; }
		;

comma		: ','
		| /* empty */
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

tcpmd5rule	: TCPMD5 hosts spispec authkeyspec	{
			struct ipsec_rule	*r;

			r = create_sa(IPSEC_TCPMD5, IPSEC_TRANSPORT, &$2,
			    $3.spiout, NULL, $4.keyout, NULL);
			if (r == NULL)
				YYERROR;

			if (expand_rule(r, NULL, 0, $3.spiin, $4.keyin, NULL,
			    NULL))
				errx(1, "tcpmd5rule: expand_rule");
		}
		;

sarule		: satype tmode hosts spispec transforms authkeyspec
		    enckeyspec bundlestring {
			struct ipsec_rule	*r;

			r = create_sa($1, $2, &$3, $4.spiout, $5, $6.keyout,
			    $7.keyout);
			if (r == NULL)
				YYERROR;

			if (expand_rule(r, NULL, 0, $4.spiin, $6.keyin,
			    $7.keyin, $8))
				errx(1, "sarule: expand_rule");
		}
		;

flowrule	: FLOW satype dir proto hosts peers ids type {
			struct ipsec_rule	*r;

			r = create_flow($3, $4, &$5, $2, $7.srcid,
			    $7.dstid, $8);
			if (r == NULL)
				YYERROR;

			if (expand_rule(r, &$6, $3, 0, NULL, NULL, NULL))
				errx(1, "flowrule: expand_rule");
		}
		;

ikerule		: IKE ikemode satype tmode proto hosts peers
		    phase1mode phase2mode ids ikeauth tag {
			struct ipsec_rule	*r;

			r = create_ike($5, &$6, $8, $9, $3, $4, $2,
			    $10.srcid, $10.dstid, &$11, $12);
			if (r == NULL)
				YYERROR;

			if (expand_rule(r, &$7, 0, 0, NULL, NULL, NULL))
				errx(1, "ikerule: expand_rule");
		}
		;

satype		: /* empty */			{ $$ = IPSEC_ESP; }
		| ESP				{ $$ = IPSEC_ESP; }
		| AH				{ $$ = IPSEC_AH; }
		| IPCOMP			{ $$ = IPSEC_IPCOMP; }
		| IPIP				{ $$ = IPSEC_IPIP; }
		;

proto		: /* empty */			{ $$ = 0; }
		| PROTO protoval		{ $$ = $2; }
		| PROTO ESP 			{ $$ = IPPROTO_ESP; }
		| PROTO AH			{ $$ = IPPROTO_AH; }
		;

protoval	: STRING			{
			struct protoent *p;

			p = getprotobyname($1);
			if (p == NULL) {
				yyerror("unknown protocol: %s", $1);
				YYERROR;
			}
			$$ = p->p_proto;
			free($1);
		}
		| NUMBER			{
			if ($1 > 255 || $1 < 0) {
				yyerror("protocol outside range");
				YYERROR;
			}
		}
		;

tmode		: /* empty */			{ $$ = IPSEC_TUNNEL; }
		| TUNNEL			{ $$ = IPSEC_TUNNEL; }
		| TRANSPORT			{ $$ = IPSEC_TRANSPORT; }
		;

dir		: /* empty */			{ $$ = IPSEC_INOUT; }
		| IN				{ $$ = IPSEC_IN; }
		| OUT				{ $$ = IPSEC_OUT; }
		;

hosts		: FROM host port TO host port		{
			struct ipsec_addr_wrap *ipa;
			for (ipa = $5; ipa; ipa = ipa->next) {
				if (ipa->srcnat) {
					yyerror("no flow NAT support for"
					    " destination network: %s", ipa->name);
					YYERROR;
				}
			}
			$$.src = $2;
			$$.sport = $3;
			$$.dst = $5;
			$$.dport = $6;
		}
		| TO host port FROM host port		{
			struct ipsec_addr_wrap *ipa;
			for (ipa = $2; ipa; ipa = ipa->next) {
				if (ipa->srcnat) {
					yyerror("no flow NAT support for"
					    " destination network: %s", ipa->name);
					YYERROR;
				}
			}
			$$.src = $5;
			$$.sport = $6;
			$$.dst = $2;
			$$.dport = $3;
		}
		;

port		: /* empty */				{ $$ = 0; }
		| PORT portval				{ $$ = $2; }
		;

portval		: STRING				{
			struct servent *s;

			if ((s = getservbyname($1, "tcp")) != NULL ||
			    (s = getservbyname($1, "udp")) != NULL) {
				$$ = s->s_port;
			} else {
				yyerror("unknown port: %s", $1);
				YYERROR;
			}
		}
		| NUMBER				{
			if ($1 > USHRT_MAX || $1 < 0) {
				yyerror("port outside range");
				YYERROR;
			}
			$$ = htons($1);
		}
		;

peers		: /* empty */				{
			$$.dst = NULL;
			$$.src = NULL;
		}
		| PEER anyhost LOCAL singlehost		{
			$$.dst = $2;
			$$.src = $4;
		}
		| LOCAL singlehost PEER anyhost		{
			$$.dst = $4;
			$$.src = $2;
		}
		| PEER anyhost				{
			$$.dst = $2;
			$$.src = NULL;
		}
		| LOCAL singlehost			{
			$$.dst = NULL;
			$$.src = $2;
		}
		;

anyhost		: singlehost			{ $$ = $1; }
		| ANY				{
			$$ = host_any();
		}

singlehost	: /* empty */			{ $$ = NULL; }
		| STRING			{
			if (($$ = host($1)) == NULL) {
				free($1);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($1);
		}
		;

host_list	: host				{ $$ = $1; }
		| host_list comma host		{
			if ($3 == NULL)
				$$ = $1;
			else if ($1 == NULL)
				$$ = $3;
			else {
				$1->tail->next = $3;
				$1->tail = $3->tail;
				$$ = $1;
			}
		}
		;

host_spec	: STRING			{
			if (($$ = host($1)) == NULL) {
				free($1);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($1);
		}
		| STRING '/' NUMBER		{
			char	*buf;

			if (asprintf(&buf, "%s/%lld", $1, $3) == -1)
				err(1, "host: asprintf");
			free($1);
			if (($$ = host(buf)) == NULL)	{
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		;

host		: host_spec			{ $$ = $1; }
		| host_spec '(' host_spec ')'   {
			if ($3->af != $1->af) {
				yyerror("Flow NAT address family mismatch");
				YYERROR;
			}
			$$ = $1;
			$$->srcnat = $3;
		}
		| ANY				{
			$$ = host_any();
		}
		| '{' host_list '}'		{ $$ = $2; }
		;

ids		: /* empty */			{
			$$.srcid = NULL;
			$$.dstid = NULL;
		}
		| SRCID id DSTID id		{
			$$.srcid = $2;
			$$.dstid = $4;
		}
		| SRCID id			{
			$$.srcid = $2;
			$$.dstid = NULL;
		}
		| DSTID id			{
			$$.srcid = NULL;
			$$.dstid = $2;
		}
		;

type		: /* empty */			{
			$$ = TYPE_UNKNOWN;
		}
		| TYPE USE			{
			$$ = TYPE_USE;
		}
		| TYPE ACQUIRE			{
			$$ = TYPE_ACQUIRE;
		}
		| TYPE REQUIRE			{
			$$ = TYPE_REQUIRE;
		}
		| TYPE DENY			{
			$$ = TYPE_DENY;
		}
		| TYPE BYPASS			{
			$$ = TYPE_BYPASS;
		}
		| TYPE DONTACQ			{
			$$ = TYPE_DONTACQ;
		}
		;

id		: STRING			{ $$ = $1; }
		;

spispec		: SPI STRING			{
			u_int32_t	 spi;
			char		*p = strchr($2, ':');

			if (p != NULL) {
				*p++ = 0;

				if (atospi(p, &spi) == -1) {
					free($2);
					YYERROR;
				}
				$$.spiin = spi;
			} else
				$$.spiin = 0;

			if (atospi($2, &spi) == -1) {
				free($2);
				YYERROR;
			}
			$$.spiout = spi;


			free($2);
		}
		| SPI NUMBER			{
			if ($2 > UINT_MAX || $2 < 0) {
				yyerror("%lld not a valid spi", $2);
				YYERROR;
			}
			if ($2 >= SPI_RESERVED_MIN && $2 <= SPI_RESERVED_MAX) {
				yyerror("%lld within reserved spi range", $2);
				YYERROR;
			}

			$$.spiin = 0;
			$$.spiout = $2;
		}
		;

transforms	:					{
			if ((ipsec_transforms = calloc(1,
			    sizeof(struct ipsec_transforms))) == NULL)
				err(1, "transforms: calloc");
		}
		    transforms_l
			{ $$ = ipsec_transforms; }
		| /* empty */				{
			if (($$ = calloc(1,
			    sizeof(struct ipsec_transforms))) == NULL)
				err(1, "transforms: calloc");
		}
		;

transforms_l	: transforms_l transform
		| transform
		;

transform	: AUTHXF STRING			{
			if (ipsec_transforms->authxf)
				yyerror("auth already set");
			else {
				ipsec_transforms->authxf = parse_xf($2,
				    authxfs);
				if (!ipsec_transforms->authxf)
					yyerror("%s not a valid transform", $2);
			}
		}
		| ENCXF STRING			{
			if (ipsec_transforms->encxf)
				yyerror("enc already set");
			else {
				ipsec_transforms->encxf = parse_xf($2, encxfs);
				if (!ipsec_transforms->encxf)
					yyerror("%s not a valid transform", $2);
			}
		}
		| COMPXF STRING			{
			if (ipsec_transforms->compxf)
				yyerror("comp already set");
			else {
				ipsec_transforms->compxf = parse_xf($2,
				    compxfs);
				if (!ipsec_transforms->compxf)
					yyerror("%s not a valid transform", $2);
			}
		}
		| GROUP STRING			{
			if (ipsec_transforms->groupxf)
				yyerror("group already set");
			else {
				ipsec_transforms->groupxf = parse_xf($2,
				    groupxfs);
				if (!ipsec_transforms->groupxf)
					yyerror("%s not a valid transform", $2);
			}
		}
		;

phase1mode	: /* empty */	{
			struct ike_mode		*p1;

			/* We create just an empty main mode */
			if ((p1 = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "phase1mode: calloc");
			p1->ike_exch = IKE_MM;
			$$ = p1;
		}
		| MAIN transforms lifetime		{
			struct ike_mode *p1;

			if ((p1 = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "phase1mode: calloc");
			p1->xfs = $2;
			p1->life = $3;
			p1->ike_exch = IKE_MM;
			$$ = p1;
		}
		| AGGRESSIVE transforms lifetime	{
			struct ike_mode	*p1;

			if ((p1 = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "phase1mode: calloc");
			p1->xfs = $2;
			p1->life = $3;
			p1->ike_exch = IKE_AM;
			$$ = p1;
		}
		;

phase2mode	: /* empty */	{
			struct ike_mode		*p2;

			/* We create just an empty quick mode */
			if ((p2 = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "phase2mode: calloc");
			p2->ike_exch = IKE_QM;
			$$ = p2;
		}
		| QUICK transforms lifetime	{
			struct ike_mode	*p2;

			if ((p2 = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "phase2mode: calloc");
			p2->xfs = $2;
			p2->life = $3;
			p2->ike_exch = IKE_QM;
			$$ = p2;
		}
		;

lifetime	: /* empty */			{
			struct ipsec_lifetime *life;

			/* We create just an empty transform */
			if ((life = calloc(1, sizeof(struct ipsec_lifetime)))
			    == NULL)
				err(1, "life: calloc");
			life->lt_seconds = -1;
			life->lt_bytes = -1;
			$$ = life;
		}
		| LIFETIME NUMBER		{
			struct ipsec_lifetime *life;

			if ((life = calloc(1, sizeof(struct ipsec_lifetime)))
			    == NULL)
				err(1, "life: calloc");
			life->lt_seconds = $2;
			life->lt_bytes = -1;
			$$ = life;
		}
		| LIFETIME STRING		{
			$$ = parse_life($2);
		}
		;

authkeyspec	: /* empty */			{
			$$.keyout = NULL;
			$$.keyin = NULL;
		}
		| AUTHKEY keyspec		{
			$$.keyout = $2.keyout;
			$$.keyin = $2.keyin;
		}
		;

enckeyspec	: /* empty */			{
			$$.keyout = NULL;
			$$.keyin = NULL;
		}
		| ENCKEY keyspec		{
			$$.keyout = $2.keyout;
			$$.keyin = $2.keyin;
		}
		;

bundlestring	: /* empty */			{ $$ = NULL; }
		| BUNDLE STRING			{ $$ = $2; }
		;

keyspec		: STRING			{
			unsigned char	*hex;
			unsigned char	*p = strchr($1, ':');

			if (p != NULL ) {
				*p++ = 0;

				if (!strncmp(p, "0x", 2))
					p += 2;
				$$.keyin = parsekey(p, strlen(p));
			} else
				$$.keyin = NULL;

			hex = $1;
			if (!strncmp(hex, "0x", 2))
				hex += 2;
			$$.keyout = parsekey(hex, strlen(hex));

			free($1);
		}
		| FILENAME STRING		{
			unsigned char	*p = strchr($2, ':');

			if (p != NULL) {
				*p++ = 0;
				$$.keyin = parsekeyfile(p);
			}
			$$.keyout = parsekeyfile($2);
			free($2);
		}
		;

ikemode		: /* empty */			{ $$ = IKE_ACTIVE; }
		| PASSIVE			{ $$ = IKE_PASSIVE; }
		| DYNAMIC			{ $$ = IKE_DYNAMIC; }
		| ACTIVE			{ $$ = IKE_ACTIVE; }
		;

ikeauth		: /* empty */			{
			$$.type = IKE_AUTH_RSA;
			$$.string = NULL;
		}
		| RSA				{
			$$.type = IKE_AUTH_RSA;
			$$.string = NULL;
		}
		| PSK STRING			{
			$$.type = IKE_AUTH_PSK;
			if (($$.string = strdup($2)) == NULL)
				err(1, "ikeauth: strdup");
		}
		;

tag		: /* empty */
		{
			$$ = NULL;
		}
		| TAG STRING
		{
			$$ = $2;
		}
		;

string		: string STRING
		{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				err(1, "string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string
		{
			char *s = $1;
			if (ipsec->opts & IPSECCTL_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				err(1, "cannot store variable");
			free($1);
			free($3);
		}
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;

	file->errors++;
	va_start(ap, fmt);
	fprintf(stderr, "%s: %d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
yywarn(const char *fmt, ...)
{
	va_list		 ap;

	va_start(ap, fmt);
	fprintf(stderr, "%s: %d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "acquire",		ACQUIRE },
		{ "active",		ACTIVE },
		{ "aggressive",		AGGRESSIVE },
		{ "ah",			AH },
		{ "any",		ANY },
		{ "auth",		AUTHXF },
		{ "authkey",		AUTHKEY },
		{ "bundle",		BUNDLE },
		{ "bypass",		BYPASS },
		{ "comp",		COMPXF },
		{ "deny",		DENY },
		{ "dontacq",		DONTACQ },
		{ "dstid",		DSTID },
		{ "dynamic",		DYNAMIC },
		{ "enc",		ENCXF },
		{ "enckey",		ENCKEY },
		{ "esp",		ESP },
		{ "file",		FILENAME },
		{ "flow",		FLOW },
		{ "from",		FROM },
		{ "group",		GROUP },
		{ "ike",		IKE },
		{ "in",			IN },
		{ "include",		INCLUDE },
		{ "ipcomp",		IPCOMP },
		{ "ipip",		IPIP },
		{ "lifetime",		LIFETIME },
		{ "local",		LOCAL },
		{ "main",		MAIN },
		{ "out",		OUT },
		{ "passive",		PASSIVE },
		{ "peer",		PEER },
		{ "port",		PORT },
		{ "proto",		PROTO },
		{ "psk",		PSK },
		{ "quick",		QUICK },
		{ "require",		REQUIRE },
		{ "rsa",		RSA },
		{ "spi",		SPI },
		{ "srcid",		SRCID },
		{ "tag",		TAG },
		{ "tcpmd5",		TCPMD5 },
		{ "to",			TO },
		{ "transport",		TRANSPORT },
		{ "tunnel",		TUNNEL },
		{ "type",		TYPE },
		{ "use",		USE }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p) {
		if (debug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
		return (p->k_val);
	} else {
		if (debug > 1)
			fprintf(stderr, "string: %s\n", s);
		return (STRING);
	}
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		warn("malloc");
		free(nfile);
		return (NULL);
	}
	if (TAILQ_FIRST(&files) == NULL && strcmp(nfile->name, "-") == 0) {
		nfile->stream = stdin;
		free(nfile->name);
		if ((nfile->name = strdup("stdin")) == NULL) {
			warn("strdup");
			free(nfile);
			return (NULL);
		}
	} else if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
		prev->errors += file->errors;
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
}

int
parse_rules(const char *filename, struct ipsecctl *ipsecx)
{
	struct sym	*sym;
	int		 errors = 0;

	ipsec = ipsecx;

	if ((file = pushfile(filename, 1)) == NULL) {
		return (-1);
	}

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	while ((sym = TAILQ_FIRST(&symhead))) {
		if ((ipsec->opts & IPSECCTL_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entry);
		free(sym);
	}

	return (errors ? -1 : 0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		err(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
}

int
atospi(char *s, u_int32_t *spivalp)
{
	unsigned long	ulval;

	if (atoul(s, &ulval) == -1)
		return (-1);
	if (ulval > UINT_MAX) {
		yyerror("%lu not a valid spi", ulval);
		return (-1);
	}
	if (ulval >= SPI_RESERVED_MIN && ulval <= SPI_RESERVED_MAX) {
		yyerror("%lu within reserved spi range", ulval);
		return (-1);
	}
	*spivalp = ulval;
	return (0);
}

u_int8_t
x2i(unsigned char *s)
{
	char	ss[3];

	ss[0] = s[0];
	ss[1] = s[1];
	ss[2] = 0;

	if (!isxdigit(s[0]) || !isxdigit(s[1])) {
		yyerror("keys need to be specified in hex digits");
		return (-1);
	}
	return ((u_int8_t)strtoul(ss, NULL, 16));
}

struct ipsec_key *
parsekey(unsigned char *hexkey, size_t len)
{
	struct ipsec_key *key;
	int		  i;

	key = calloc(1, sizeof(struct ipsec_key));
	if (key == NULL)
		err(1, "parsekey: calloc");

	key->len = len / 2;
	key->data = calloc(key->len, sizeof(u_int8_t));
	if (key->data == NULL)
		err(1, "parsekey: calloc");

	for (i = 0; i < (int)key->len; i++)
		key->data[i] = x2i(hexkey + 2 * i);

	return (key);
}

struct ipsec_key *
parsekeyfile(char *filename)
{
	struct stat	 sb;
	int		 fd;
	unsigned char	*hex;

	if ((fd = open(filename, O_RDONLY)) < 0)
		err(1, "open %s", filename);
	if (fstat(fd, &sb) < 0)
		err(1, "parsekeyfile: stat %s", filename);
	if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
		errx(1, "%s: key too %s", filename, sb.st_size ? "large" :
		    "small");
	if ((hex = calloc(sb.st_size, sizeof(unsigned char))) == NULL)
		err(1, "parsekeyfile: calloc");
	if (read(fd, hex, sb.st_size) < sb.st_size)
		err(1, "parsekeyfile: read");
	close(fd);
	return (parsekey(hex, sb.st_size));
}

int
get_id_type(char *string)
{
	struct in6_addr ia;

	if (string == NULL)
		return (ID_UNKNOWN);

	if (inet_pton(AF_INET, string, &ia) == 1)
		return (ID_IPV4);
	else if (inet_pton(AF_INET6, string, &ia) == 1)
		return (ID_IPV6);
	else if (strchr(string, '@@'))
		return (ID_UFQDN);
	else
		return (ID_FQDN);
}

struct ipsec_addr_wrap *
host(const char *s)
{
	struct ipsec_addr_wrap	*ipa = NULL;
	int			 mask, cont = 1;
	char			*p, *q, *ps;

	if ((p = strrchr(s, '/')) != NULL) {
		errno = 0;
		mask = strtol(p + 1, &q, 0);
		if (errno == ERANGE || !q || *q || mask > 128 || q == (p + 1))
			errx(1, "host: invalid netmask '%s'", p);
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: calloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else {
		if ((ps = strdup(s)) == NULL)
			err(1, "host: strdup");
		mask = -1;
	}

	/* Does interface with this name exist? */
	if (cont && (ipa = host_if(ps, mask)) != NULL)
		cont = 0;

	/* IPv4 address? */
	if (cont && (ipa = host_v4(s, mask == -1 ? 32 : mask)) != NULL)
		cont = 0;

	/* IPv6 address? */
	if (cont && (ipa = host_v6(ps, mask == -1 ? 128 : mask)) != NULL)
		cont = 0;

	/* dns lookup */
	if (cont && mask == -1 && (ipa = host_dns(s, mask)) != NULL)
		cont = 0;
	free(ps);

	if (ipa == NULL || cont == 1) {
		fprintf(stderr, "no IP address found for %s\n", s);
		return (NULL);
	}
	return (ipa);
}

struct ipsec_addr_wrap *
host_v6(const char *s, int prefixlen)
{
	struct ipsec_addr_wrap	*ipa = NULL;
	struct addrinfo		 hints, *res;
	char			 hbuf[NI_MAXHOST];

	bzero(&hints, sizeof(struct addrinfo));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, NULL, &hints, &res))
		return (NULL);
	if (res->ai_next)
		err(1, "host_v6: numeric hostname expanded to multiple item");

	ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (ipa == NULL)
		err(1, "host_v6: calloc");
	ipa->af = res->ai_family;
	memcpy(&ipa->address.v6,
	    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
	    sizeof(struct in6_addr));
	if (prefixlen > 128)
		prefixlen = 128;
	ipa->next = NULL;
	ipa->tail = ipa;

	set_ipmask(ipa, prefixlen);
	if (getnameinfo(res->ai_addr, res->ai_addrlen,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST)) {
		errx(1, "could not get a numeric hostname");
	}

	if (prefixlen != 128) {
		ipa->netaddress = 1;
		if (asprintf(&ipa->name, "%s/%d", hbuf, prefixlen) == -1)
			err(1, "host_v6: asprintf");
	} else {
		if ((ipa->name = strdup(hbuf)) == NULL)
			err(1, "host_v6: strdup");
	}

	freeaddrinfo(res);

	return (ipa);
}

struct ipsec_addr_wrap *
host_v4(const char *s, int mask)
{
	struct ipsec_addr_wrap	*ipa = NULL;
	struct in_addr		 ina;
	int			 bits = 32;

	bzero(&ina, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
	}

	ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (ipa == NULL)
		err(1, "host_v4: calloc");

	ipa->address.v4 = ina;
	ipa->name = strdup(s);
	if (ipa->name == NULL)
		err(1, "host_v4: strdup");
	ipa->af = AF_INET;
	ipa->next = NULL;
	ipa->tail = ipa;

	set_ipmask(ipa, bits);
	if (strrchr(s, '/') != NULL)
		ipa->netaddress = 1;

	return (ipa);
}

struct ipsec_addr_wrap *
host_dns(const char *s, int mask)
{
	struct ipsec_addr_wrap	*ipa = NULL, *head = NULL;
	struct addrinfo		 hints, *res0, *res;
	int			 error;
	char			 hbuf[NI_MAXHOST];

	bzero(&hints, sizeof(struct addrinfo));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error)
		return (NULL);

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET && res->ai_family != AF_INET6)
			continue;

		ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (ipa == NULL)
			err(1, "host_dns: calloc");
		switch (res->ai_family) {
		case AF_INET:
			memcpy(&ipa->address.v4,
			    &((struct sockaddr_in *)res->ai_addr)->sin_addr,
			    sizeof(struct in_addr));
			break;
		case AF_INET6:
			/* XXX we do not support scoped IPv6 address yet */
			if (((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id) {
				free(ipa);
				continue;
			}
			memcpy(&ipa->address.v6,
			    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
			    sizeof(struct in6_addr));
			break;
		}
		error = getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
		if (error)
			err(1, "host_dns: getnameinfo");
		ipa->name = strdup(hbuf);
		if (ipa->name == NULL)
			err(1, "host_dns: strdup");
		ipa->af = res->ai_family;
		ipa->next = NULL;
		ipa->tail = ipa;
		if (head == NULL)
			head = ipa;
		else {
			head->tail->next = ipa;
			head->tail = ipa;
		}

		/*
		 * XXX for now, no netmask support for IPv6.
		 * but since there's no way to specify address family, once you
		 * have IPv6 address on a host, you cannot use dns/netmask
		 * syntax.
		 */
		if (ipa->af == AF_INET)
			set_ipmask(ipa, mask == -1 ? 32 : mask);
		else
			if (mask != -1)
				err(1, "host_dns: cannot apply netmask "
				    "on non-IPv4 address");
	}
	freeaddrinfo(res0);

	return (head);
}

struct ipsec_addr_wrap *
host_if(const char *s, int mask)
{
	struct ipsec_addr_wrap *ipa = NULL;

	if (ifa_exists(s))
		ipa = ifa_lookup(s);

	return (ipa);
}

struct ipsec_addr_wrap *
host_any(void)
{
	struct ipsec_addr_wrap	*ipa;

	ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (ipa == NULL)
		err(1, "host_any: calloc");
	ipa->af = AF_UNSPEC;
	ipa->netaddress = 1;
	ipa->tail = ipa;
	return (ipa);
}

/* interface lookup routintes */

struct ipsec_addr_wrap	*iftab;

void
ifa_load(void)
{
	struct ifaddrs		*ifap, *ifa;
	struct ipsec_addr_wrap	*n = NULL, *h = NULL;

	if (getifaddrs(&ifap) < 0)
		err(1, "ifa_load: getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (!(ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6 ||
		    ifa->ifa_addr->sa_family == AF_LINK))
			continue;
		n = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (n == NULL)
			err(1, "ifa_load: calloc");
		n->af = ifa->ifa_addr->sa_family;
		if ((n->name = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
		if (n->af == AF_INET) {
			n->af = AF_INET;
			memcpy(&n->address.v4, &((struct sockaddr_in *)
			    ifa->ifa_addr)->sin_addr,
			    sizeof(struct in_addr));
			memcpy(&n->mask.v4, &((struct sockaddr_in *)
			    ifa->ifa_netmask)->sin_addr,
			    sizeof(struct in_addr));
		} else if (n->af == AF_INET6) {
			n->af = AF_INET6;
			memcpy(&n->address.v6, &((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_addr,
			    sizeof(struct in6_addr));
			memcpy(&n->mask.v6, &((struct sockaddr_in6 *)
			    ifa->ifa_netmask)->sin6_addr,
			    sizeof(struct in6_addr));
		}
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	iftab = h;
	freeifaddrs(ifap);
}

int
ifa_exists(const char *ifa_name)
{
	struct ipsec_addr_wrap	*n;
	struct ifgroupreq	 ifgr;
	int			 s;

	if (iftab == NULL)
		ifa_load();

	/* check whether this is a group */
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "ifa_exists: socket");
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, ifa_name, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == 0) {
		close(s);
		return (1);
	}
	close(s);

	for (n = iftab; n; n = n->next) {
		if (n->af == AF_LINK && !strncmp(n->name, ifa_name,
		    IFNAMSIZ))
			return (1);
	}

	return (0);
}

struct ipsec_addr_wrap *
ifa_grouplookup(const char *ifa_name)
{
	struct ifg_req		*ifg;
	struct ifgroupreq	 ifgr;
	int			 s;
	size_t			 len;
	struct ipsec_addr_wrap	*n, *h = NULL, *hn;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "socket");
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, ifa_name, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
		close(s);
		return (NULL);
	}

	len = ifgr.ifgr_len;
	if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
		err(1, "calloc");
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
		err(1, "ioctl");

	for (ifg = ifgr.ifgr_groups; ifg && len >= sizeof(struct ifg_req);
	    ifg++) {
		len -= sizeof(struct ifg_req);
		if ((n = ifa_lookup(ifg->ifgrq_member)) == NULL)
			continue;
		if (h == NULL)
			h = n;
		else {
			for (hn = h; hn->next != NULL; hn = hn->next)
				;	/* nothing */
			hn->next = n;
			n->tail = hn;
		}
	}
	free(ifgr.ifgr_groups);
	close(s);

	return (h);
}

struct ipsec_addr_wrap *
ifa_lookup(const char *ifa_name)
{
	struct ipsec_addr_wrap	*p = NULL, *h = NULL, *n = NULL;

	if (iftab == NULL)
		ifa_load();

	if ((n = ifa_grouplookup(ifa_name)) != NULL)
		return (n);

	for (p = iftab; p; p = p->next) {
		if (p->af != AF_INET && p->af != AF_INET6)
			continue;
		if (strncmp(p->name, ifa_name, IFNAMSIZ))
			continue;
		n = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (n == NULL)
			err(1, "ifa_lookup: calloc");
		memcpy(n, p, sizeof(struct ipsec_addr_wrap));
		if ((n->name = strdup(p->name)) == NULL)
			err(1, "ifa_lookup: strdup");
		switch (n->af) {
		case AF_INET:
			set_ipmask(n, 32);
			break;
		case AF_INET6:
			/* route/show.c and bgpd/util.c give KAME credit */
			if (IN6_IS_ADDR_LINKLOCAL(&n->address.v6)) {
				u_int16_t tmp16;
				/* for now we can not handle link local,
				 * therefore bail for now
				 */
				free(n);
				continue;

				memcpy(&tmp16, &n->address.v6.s6_addr[2],
				    sizeof(tmp16));
				/* use this when we support link-local
				 * n->??.scopeid = ntohs(tmp16);
				 */
				n->address.v6.s6_addr[2] = 0;
				n->address.v6.s6_addr[3] = 0;
			}
			set_ipmask(n, 128);
			break;
		}

		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	return (h);
}

void
set_ipmask(struct ipsec_addr_wrap *address, u_int8_t b)
{
	struct ipsec_addr	*ipa;
	int			 i, j = 0;

	ipa = &address->mask;
	bzero(ipa, sizeof(struct ipsec_addr));

	while (b >= 32) {
		ipa->addr32[j++] = 0xffffffff;
		b -= 32;
	}
	for (i = 31; i > 31 - b; --i)
		ipa->addr32[j] |= (1 << i);
	if (b)
		ipa->addr32[j] = htonl(ipa->addr32[j]);
}

const struct ipsec_xf *
parse_xf(const char *name, const struct ipsec_xf xfs[])
{
	int		i;

	for (i = 0; xfs[i].name != NULL; i++) {
		if (strncmp(name, xfs[i].name, strlen(name)))
			continue;
		return &xfs[i];
	}
	return (NULL);
}

struct ipsec_lifetime *
parse_life(const char *value)
{
	struct ipsec_lifetime	*life;
	int			ret;
	int			seconds = 0;
	char			unit = 0;

	ret = sscanf(value, "%d%c", &seconds, &unit);
	if (ret == 2) {
		switch (tolower((unsigned char)unit)) {
		case 'm':
			seconds *= 60;
			break;
		case 'h':
			seconds *= 60 * 60;
			break;
		default:
			err(1, "invalid time unit");
		}
	} else if (ret != 1)
		err(1, "invalid time specification: %s", value);

	life = calloc(1, sizeof(struct ipsec_lifetime));
	if (life == NULL)
		err(1, "calloc");

	life->lt_seconds = seconds;
	life->lt_bytes = -1;

	return (life);
}

struct ipsec_transforms *
copytransforms(const struct ipsec_transforms *xfs)
{
	struct ipsec_transforms *newxfs;

	if (xfs == NULL)
		return (NULL);

	newxfs = calloc(1, sizeof(struct ipsec_transforms));
	if (newxfs == NULL)
		err(1, "copytransforms: calloc");

	memcpy(newxfs, xfs, sizeof(struct ipsec_transforms));
	return (newxfs);
}

struct ipsec_lifetime *
copylife(const struct ipsec_lifetime *life)
{
	struct ipsec_lifetime *newlife;

	if (life == NULL)
		return (NULL);

	newlife = calloc(1, sizeof(struct ipsec_lifetime));
	if (newlife == NULL)
		err(1, "copylife: calloc");

	memcpy(newlife, life, sizeof(struct ipsec_lifetime));
	return (newlife);
}

struct ipsec_auth *
copyipsecauth(const struct ipsec_auth *auth)
{
	struct ipsec_auth	*newauth;

	if (auth == NULL)
		return (NULL);

	if ((newauth = calloc(1, sizeof(struct ipsec_auth))) == NULL)
		err(1, "calloc");
	if (auth->srcid &&
	    asprintf(&newauth->srcid, "%s", auth->srcid) == -1)
		err(1, "asprintf");
	if (auth->dstid &&
	    asprintf(&newauth->dstid, "%s", auth->dstid) == -1)
		err(1, "asprintf");

	newauth->srcid_type = auth->srcid_type;
	newauth->dstid_type = auth->dstid_type;
	newauth->type = auth->type;

	return (newauth);
}

struct ike_auth *
copyikeauth(const struct ike_auth *auth)
{
	struct ike_auth	*newauth;

	if (auth == NULL)
		return (NULL);

	if ((newauth = calloc(1, sizeof(struct ike_auth))) == NULL)
		err(1, "calloc");
	if (auth->string &&
	    asprintf(&newauth->string, "%s", auth->string) == -1)
		err(1, "asprintf");

	newauth->type = auth->type;

	return (newauth);
}

struct ipsec_key *
copykey(struct ipsec_key *key)
{
	struct ipsec_key	*newkey;

	if (key == NULL)
		return (NULL);

	if ((newkey = calloc(1, sizeof(struct ipsec_key))) == NULL)
		err(1, "calloc");
	if ((newkey->data = calloc(key->len, sizeof(u_int8_t))) == NULL)
		err(1, "calloc");
	memcpy(newkey->data, key->data, key->len);
	newkey->len = key->len;

	return (newkey);
}

struct ipsec_addr_wrap *
copyhost(const struct ipsec_addr_wrap *src)
{
	struct ipsec_addr_wrap *dst;

	if (src == NULL)
		return (NULL);

	dst = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (dst == NULL)
		err(1, "copyhost: calloc");

	memcpy(dst, src, sizeof(struct ipsec_addr_wrap));

	if (src->name != NULL && (dst->name = strdup(src->name)) == NULL)
		err(1, "copyhost: strdup");

	return dst;
}

char *
copytag(const char *src)
{
	char *tag;

	if (src == NULL)
		return (NULL);
	if ((tag = strdup(src)) == NULL)
		err(1, "copytag: strdup");

	return (tag);
}

struct ipsec_rule *
copyrule(struct ipsec_rule *rule)
{
	struct ipsec_rule	*r;

	if ((r = calloc(1, sizeof(struct ipsec_rule))) == NULL)
		err(1, "calloc");

	r->src = copyhost(rule->src);
	r->dst = copyhost(rule->dst);
	r->local = copyhost(rule->local);
	r->peer = copyhost(rule->peer);
	r->auth = copyipsecauth(rule->auth);
	r->ikeauth = copyikeauth(rule->ikeauth);
	r->xfs = copytransforms(rule->xfs);
	r->p1xfs = copytransforms(rule->p1xfs);
	r->p2xfs = copytransforms(rule->p2xfs);
	r->p1life = copylife(rule->p1life);
	r->p2life = copylife(rule->p2life);
	r->authkey = copykey(rule->authkey);
	r->enckey = copykey(rule->enckey);
	r->tag = copytag(rule->tag);

	r->p1ie = rule->p1ie;
	r->p2ie = rule->p2ie;
	r->type = rule->type;
	r->satype = rule->satype;
	r->proto = rule->proto;
	r->tmode = rule->tmode;
	r->direction = rule->direction;
	r->flowtype = rule->flowtype;
	r->sport = rule->sport;
	r->dport = rule->dport;
	r->ikemode = rule->ikemode;
	r->spi = rule->spi;
	r->nr = rule->nr;

	return (r);
}

int
validate_af(struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst)
{
	struct ipsec_addr_wrap *ta;
	u_int8_t src_v4 = 0;
	u_int8_t dst_v4 = 0;
	u_int8_t src_v6 = 0;
	u_int8_t dst_v6 = 0;

	for (ta = src; ta; ta = ta->next) {
		if (ta->af == AF_INET)
			src_v4 = 1;
		if (ta->af == AF_INET6)
			src_v6 = 1;
		if (ta->af == AF_UNSPEC)
			return 0;
		if (src_v4 && src_v6)
			break;
	}
	for (ta = dst; ta; ta = ta->next) {
		if (ta->af == AF_INET)
			dst_v4 = 1;
		if (ta->af == AF_INET6)
			dst_v6 = 1;
		if (ta->af == AF_UNSPEC)
			return 0;
		if (dst_v4 && dst_v6)
			break;
	}
	if (src_v4 != dst_v4 && src_v6 != dst_v6)
		return (1);

	return (0);
}


int
validate_sa(u_int32_t spi, u_int8_t satype, struct ipsec_transforms *xfs,
    struct ipsec_key *authkey, struct ipsec_key *enckey, u_int8_t tmode)
{
	/* Sanity checks */
	if (spi == 0) {
		yyerror("no SPI specified");
		return (0);
	}
	if (satype == IPSEC_AH) {
		if (!xfs) {
			yyerror("no transforms specified");
			return (0);
		}
		if (!xfs->authxf)
			xfs->authxf = &authxfs[AUTHXF_HMAC_SHA2_256];
		if (xfs->encxf) {
			yyerror("ah does not provide encryption");
			return (0);
		}
		if (xfs->compxf) {
			yyerror("ah does not provide compression");
			return (0);
		}
	}
	if (satype == IPSEC_ESP) {
		if (!xfs) {
			yyerror("no transforms specified");
			return (0);
		}
		if (xfs->compxf) {
			yyerror("esp does not provide compression");
			return (0);
		}
		if (!xfs->encxf)
			xfs->encxf = &encxfs[ENCXF_AES];
		if (xfs->encxf->nostatic) {
			yyerror("%s is disallowed with static keys",
			    xfs->encxf->name);
			return 0;
		}
		if (xfs->encxf->noauth && xfs->authxf) {
			yyerror("authentication is implicit for %s",
			    xfs->encxf->name);
			return (0);
		} else if (!xfs->encxf->noauth && !xfs->authxf)
			xfs->authxf = &authxfs[AUTHXF_HMAC_SHA2_256];
	}
	if (satype == IPSEC_IPCOMP) {
		if (!xfs) {
			yyerror("no transform specified");
			return (0);
		}
		if (xfs->authxf || xfs->encxf) {
			yyerror("no encryption or authentication with ipcomp");
			return (0);
		}
		if (!xfs->compxf)
			xfs->compxf = &compxfs[COMPXF_DEFLATE];
	}
	if (satype == IPSEC_IPIP) {
		if (!xfs) {
			yyerror("no transform specified");
			return (0);
		}
		if (xfs->authxf || xfs->encxf || xfs->compxf) {
			yyerror("no encryption, authentication or compression"
			    " with ipip");
			return (0);
		}
	}
	if (satype == IPSEC_TCPMD5 && authkey == NULL && tmode !=
	    IPSEC_TRANSPORT) {
		yyerror("authentication key needed for tcpmd5");
		return (0);
	}
	if (xfs && xfs->authxf) {
		if (!authkey && xfs->authxf != &authxfs[AUTHXF_NONE]) {
			yyerror("no authentication key specified");
			return (0);
		}
		if (authkey && authkey->len != xfs->authxf->keymin) {
			yyerror("wrong authentication key length, needs to be "
			    "%zu bits", xfs->authxf->keymin * 8);
			return (0);
		}
	}
	if (xfs && xfs->encxf) {
		if (!enckey && xfs->encxf != &encxfs[ENCXF_NULL]) {
			yyerror("no encryption key specified");
			return (0);
		}
		if (enckey) {
			if (enckey->len < xfs->encxf->keymin) {
				yyerror("encryption key too short (%zu bits), "
				    "minimum %zu bits", enckey->len * 8,
				    xfs->encxf->keymin * 8);
				return (0);
			}
			if (xfs->encxf->keymax < enckey->len) {
				yyerror("encryption key too long (%zu bits), "
				    "maximum %zu bits", enckey->len * 8,
				    xfs->encxf->keymax * 8);
				return (0);
			}
		}
	}

	return 1;
}

int
add_sabundle(struct ipsec_rule *r, char *bundle)
{
	struct ipsec_rule	*rp, *last, *sabundle;
	int			 found = 0;

	TAILQ_FOREACH(rp, &ipsec->bundle_queue, bundle_entry) {
		if ((strcmp(rp->src->name, r->src->name) == 0) &&
		    (strcmp(rp->dst->name, r->dst->name) == 0) &&
		    (strcmp(rp->bundle, bundle) == 0)) {
			found = 1;
			break;
		}
	}
	if (found) {
		last = TAILQ_LAST(&rp->dst_bundle_queue, dst_bundle_queue);
		TAILQ_INSERT_TAIL(&rp->dst_bundle_queue, r, dst_bundle_entry);

		sabundle = create_sabundle(last->dst, last->satype, last->spi,
		    r->dst, r->satype, r->spi);
		if (sabundle == NULL)
			return (1);
		sabundle->nr = ipsec->rule_nr++;
		if (ipsecctl_add_rule(ipsec, sabundle))
			return (1);
	} else {
		TAILQ_INSERT_TAIL(&ipsec->bundle_queue, r, bundle_entry);
		TAILQ_INIT(&r->dst_bundle_queue);
		TAILQ_INSERT_TAIL(&r->dst_bundle_queue, r, dst_bundle_entry);
		r->bundle = bundle;
	}

	return (0);
}

struct ipsec_rule *
create_sa(u_int8_t satype, u_int8_t tmode, struct ipsec_hosts *hosts,
    u_int32_t spi, struct ipsec_transforms *xfs, struct ipsec_key *authkey,
    struct ipsec_key *enckey)
{
	struct ipsec_rule *r;

	if (validate_sa(spi, satype, xfs, authkey, enckey, tmode) == 0)
		return (NULL);

	r = calloc(1, sizeof(struct ipsec_rule));
	if (r == NULL)
		err(1, "create_sa: calloc");

	r->type |= RULE_SA;
	r->satype = satype;
	r->tmode = tmode;
	r->src = hosts->src;
	r->dst = hosts->dst;
	r->spi = spi;
	r->xfs = xfs;
	r->authkey = authkey;
	r->enckey = enckey;

	return r;
}

struct ipsec_rule *
reverse_sa(struct ipsec_rule *rule, u_int32_t spi, struct ipsec_key *authkey,
    struct ipsec_key *enckey)
{
	struct ipsec_rule *reverse;

	if (validate_sa(spi, rule->satype, rule->xfs, authkey, enckey,
	    rule->tmode) == 0)
		return (NULL);

	reverse = calloc(1, sizeof(struct ipsec_rule));
	if (reverse == NULL)
		err(1, "reverse_sa: calloc");

	reverse->type |= RULE_SA;
	reverse->satype = rule->satype;
	reverse->tmode = rule->tmode;
	reverse->src = copyhost(rule->dst);
	reverse->dst = copyhost(rule->src);
	reverse->spi = spi;
	reverse->xfs = copytransforms(rule->xfs);
	reverse->authkey = authkey;
	reverse->enckey = enckey;

	return (reverse);
}

struct ipsec_rule *
create_sabundle(struct ipsec_addr_wrap *dst, u_int8_t proto, u_int32_t spi,
    struct ipsec_addr_wrap *dst2, u_int8_t proto2, u_int32_t spi2)
{
	struct ipsec_rule *r;

	r = calloc(1, sizeof(struct ipsec_rule));
	if (r == NULL)
		err(1, "create_sabundle: calloc");

	r->type |= RULE_BUNDLE;

	r->dst = copyhost(dst);
	r->dst2 = copyhost(dst2);
	r->proto = proto;
	r->proto2 = proto2;
	r->spi = spi;
	r->spi2 = spi2;
	r->satype = proto;

	return (r);
}

struct ipsec_rule *
create_flow(u_int8_t dir, u_int8_t proto, struct ipsec_hosts *hosts,
    u_int8_t satype, char *srcid, char *dstid, u_int8_t type)
{
	struct ipsec_rule *r;

	r = calloc(1, sizeof(struct ipsec_rule));
	if (r == NULL)
		err(1, "create_flow: calloc");

	r->type |= RULE_FLOW;

	if (dir == IPSEC_INOUT)
		r->direction = IPSEC_OUT;
	else
		r->direction = dir;

	r->satype = satype;
	r->proto = proto;
	r->src = hosts->src;
	r->sport = hosts->sport;
	r->dst = hosts->dst;
	r->dport = hosts->dport;
	if ((hosts->sport != 0 || hosts->dport != 0) &&
	    (proto != IPPROTO_TCP && proto != IPPROTO_UDP)) {
		yyerror("no protocol supplied with source/destination ports");
		goto errout;
	}

	switch (satype) {
	case IPSEC_IPCOMP:
	case IPSEC_IPIP:
		if (type == TYPE_UNKNOWN)
			type = TYPE_USE;
		break;
	default:
		if (type == TYPE_UNKNOWN)
			type = TYPE_REQUIRE;
		break;
	}		

	r->flowtype = type;
	if (type == TYPE_DENY || type == TYPE_BYPASS)
		return (r);

	r->auth = calloc(1, sizeof(struct ipsec_auth));
	if (r->auth == NULL)
		err(1, "create_flow: calloc");
	r->auth->srcid = srcid;
	r->auth->dstid = dstid;
	r->auth->srcid_type = get_id_type(srcid);
	r->auth->dstid_type = get_id_type(dstid);
	return r;

errout:
	free(r);
	if (srcid)
		free(srcid);
	if (dstid)
		free(dstid);
	free(hosts->src);
	hosts->src = NULL;
	free(hosts->dst);
	hosts->dst = NULL;

	return NULL;
}

void
expand_any(struct ipsec_addr_wrap *ipa_in)
{
	struct ipsec_addr_wrap *oldnext, *ipa;

	for (ipa = ipa_in; ipa; ipa = ipa->next) {
		if (ipa->af != AF_UNSPEC)
			continue;
		oldnext = ipa->next;

		ipa->af = AF_INET;
		ipa->netaddress = 1;
		if ((ipa->name = strdup("0.0.0.0/0")) == NULL)
			err(1, "expand_any: strdup");

		ipa->next = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (ipa->next == NULL)
			err(1, "expand_any: calloc");
		ipa->next->af = AF_INET6;
		ipa->next->netaddress = 1;
		if ((ipa->next->name = strdup("::/0")) == NULL)
			err(1, "expand_any: strdup");

		ipa->next->next = oldnext;
	}
}
	 
int
set_rule_peers(struct ipsec_rule *r, struct ipsec_hosts *peers)
{
	if (r->type == RULE_FLOW &&
	    (r->flowtype == TYPE_DENY || r->flowtype == TYPE_BYPASS))
		return (0);

	r->local = copyhost(peers->src);
	r->peer = copyhost(peers->dst);
	if (r->peer == NULL) {
		/* Set peer to remote host.  Must be a host address. */
		if (r->direction == IPSEC_IN) {
			if (!r->src->netaddress)
				r->peer = copyhost(r->src);
		} else {
			if (!r->dst->netaddress)
				r->peer = copyhost(r->dst);
		}
	}
	if (r->type == RULE_FLOW && r->peer == NULL) {
		yyerror("no peer specified for destination %s",
		    r->dst->name);
		return (1);
	}
	if (r->peer != NULL && r->peer->af == AF_UNSPEC) {
		/* If peer has been specified as any, use the default peer. */
		free(r->peer);
		r->peer = NULL;
	}
	if (r->type == RULE_IKE && r->peer == NULL) {
		/*
                 * Check if the default peer is consistent for all
                 * rules.  Only warn to avoid breaking existing configs.
		 */
		static struct ipsec_rule *pdr = NULL;

		if (pdr == NULL) {
			/* Remember first default peer rule for comparison. */
			pdr = r;
		} else {
			/* The new default peer must create the same config. */
			if ((pdr->local == NULL && r->local != NULL) ||
			    (pdr->local != NULL && r->local == NULL) ||
			    (pdr->local != NULL && r->local != NULL &&
			    strcmp(pdr->local->name, r->local->name)))
				yywarn("default peer local mismatch");
			if (pdr->ikeauth->type != r->ikeauth->type)
				yywarn("default peer phase 1 auth mismatch");
			if (pdr->ikeauth->type == IKE_AUTH_PSK &&
			    r->ikeauth->type == IKE_AUTH_PSK &&
			    strcmp(pdr->ikeauth->string, r->ikeauth->string))
				yywarn("default peer psk mismatch");
			if (pdr->p1ie != r->p1ie)
				yywarn("default peer phase 1 mode mismatch");
			/*
			 * Transforms have ADD insted of SET so they may be
			 * different and are not checked here.
			 */
			if ((pdr->auth->srcid == NULL &&
			    r->auth->srcid != NULL) ||
			    (pdr->auth->srcid != NULL &&
			    r->auth->srcid == NULL) ||
			    (pdr->auth->srcid != NULL &&
			    r->auth->srcid != NULL &&
			    strcmp(pdr->auth->srcid, r->auth->srcid)))
				yywarn("default peer srcid mismatch");
			if ((pdr->auth->dstid == NULL &&
			    r->auth->dstid != NULL) ||
			    (pdr->auth->dstid != NULL &&
			    r->auth->dstid == NULL) ||
			    (pdr->auth->dstid != NULL &&
			    r->auth->dstid != NULL &&
			    strcmp(pdr->auth->dstid, r->auth->dstid)))
				yywarn("default peer dstid mismatch");
		}
	}
	return (0);
}

int
expand_rule(struct ipsec_rule *rule, struct ipsec_hosts *peers,
    u_int8_t direction, u_int32_t spi, struct ipsec_key *authkey,
    struct ipsec_key *enckey, char *bundle)
{
	struct ipsec_rule	*r, *revr;
	struct ipsec_addr_wrap	*src, *dst;
	int added = 0, ret = 1;

	if (validate_af(rule->src, rule->dst)) {
		yyerror("source/destination address families do not match");
		goto errout;
	}
	expand_any(rule->src);
	expand_any(rule->dst);
	for (src = rule->src; src; src = src->next) {
		for (dst = rule->dst; dst; dst = dst->next) {
			if (src->af != dst->af)
				continue;
			r = copyrule(rule);

			r->src = copyhost(src);
			r->dst = copyhost(dst);

			if (peers && set_rule_peers(r, peers)) {
				ipsecctl_free_rule(r);
				goto errout;
			}

			r->nr = ipsec->rule_nr++;
			if (ipsecctl_add_rule(ipsec, r))
				goto out;
			if (bundle && add_sabundle(r, bundle))
				goto out;

			if (direction == IPSEC_INOUT) {
				/* Create and add reverse flow rule. */
				revr = reverse_rule(r);
				if (revr == NULL)
					goto out;

				revr->nr = ipsec->rule_nr++;
				if (ipsecctl_add_rule(ipsec, revr))
					goto out;
				if (bundle && add_sabundle(revr, bundle))
					goto out;
			} else if (spi != 0 || authkey || enckey) {
				/* Create and add reverse sa rule. */
				revr = reverse_sa(r, spi, authkey, enckey);
				if (revr == NULL)
					goto out;

				revr->nr = ipsec->rule_nr++;
				if (ipsecctl_add_rule(ipsec, revr))
					goto out;
				if (bundle && add_sabundle(revr, bundle))
					goto out;
			}
			added++;
		}
	}
	if (!added)
		yyerror("rule expands to no valid combination");
 errout:
	ret = 0;
	ipsecctl_free_rule(rule);
 out:
	if (peers) {
		if (peers->src)
			free(peers->src);
		if (peers->dst)
			free(peers->dst);
	}
	return (ret);
}

struct ipsec_rule *
reverse_rule(struct ipsec_rule *rule)
{
	struct ipsec_rule *reverse;

	reverse = calloc(1, sizeof(struct ipsec_rule));
	if (reverse == NULL)
		err(1, "reverse_rule: calloc");

	reverse->type |= RULE_FLOW;

	/* Reverse direction */
	if (rule->direction == (u_int8_t)IPSEC_OUT)
		reverse->direction = (u_int8_t)IPSEC_IN;
	else
		reverse->direction = (u_int8_t)IPSEC_OUT;

	reverse->flowtype = rule->flowtype;
	reverse->src = copyhost(rule->dst);
	reverse->dst = copyhost(rule->src);
	reverse->sport = rule->dport;
	reverse->dport = rule->sport;
	if (rule->local)
		reverse->local = copyhost(rule->local);
	if (rule->peer)
		reverse->peer = copyhost(rule->peer);
	reverse->satype = rule->satype;
	reverse->proto = rule->proto;

	if (rule->auth) {
		reverse->auth = calloc(1, sizeof(struct ipsec_auth));
		if (reverse->auth == NULL)
			err(1, "reverse_rule: calloc");
		if (rule->auth->dstid && (reverse->auth->dstid =
		    strdup(rule->auth->dstid)) == NULL)
			err(1, "reverse_rule: strdup");
		if (rule->auth->srcid && (reverse->auth->srcid =
		    strdup(rule->auth->srcid)) == NULL)
			err(1, "reverse_rule: strdup");
		reverse->auth->srcid_type = rule->auth->srcid_type;
		reverse->auth->dstid_type = rule->auth->dstid_type;
		reverse->auth->type = rule->auth->type;
	}

	return reverse;
}

struct ipsec_rule *
create_ike(u_int8_t proto, struct ipsec_hosts *hosts,
    struct ike_mode *phase1mode, struct ike_mode *phase2mode, u_int8_t satype,
    u_int8_t tmode, u_int8_t mode, char *srcid, char *dstid,
    struct ike_auth *authtype, char *tag)
{
	struct ipsec_rule *r;

	r = calloc(1, sizeof(struct ipsec_rule));
	if (r == NULL)
		err(1, "create_ike: calloc");

	r->type = RULE_IKE;

	r->proto = proto;
	r->src = hosts->src;
	r->sport = hosts->sport;
	r->dst = hosts->dst;
	r->dport = hosts->dport;
	if ((hosts->sport != 0 || hosts->dport != 0) &&
	    (proto != IPPROTO_TCP && proto != IPPROTO_UDP)) {
		yyerror("no protocol supplied with source/destination ports");
		goto errout;
	}

	r->satype = satype;
	r->tmode = tmode;
	r->ikemode = mode;
	if (phase1mode) {
		r->p1xfs = phase1mode->xfs;
		r->p1life = phase1mode->life;
		r->p1ie = phase1mode->ike_exch;
	} else {
		r->p1ie = IKE_MM;
	}
	if (phase2mode) {
		if (phase2mode->xfs && phase2mode->xfs->encxf &&
		    phase2mode->xfs->encxf->noauth &&
		    phase2mode->xfs->authxf) {
			yyerror("authentication is implicit for %s",
			    phase2mode->xfs->encxf->name);
			goto errout;
		}
		r->p2xfs = phase2mode->xfs;
		r->p2life = phase2mode->life;
		r->p2ie = phase2mode->ike_exch;
	} else {
		r->p2ie = IKE_QM;
	}

	r->auth = calloc(1, sizeof(struct ipsec_auth));
	if (r->auth == NULL)
		err(1, "create_ike: calloc");
	r->auth->srcid = srcid;
	r->auth->dstid = dstid;
	r->auth->srcid_type = get_id_type(srcid);
	r->auth->dstid_type = get_id_type(dstid);
	r->ikeauth = calloc(1, sizeof(struct ike_auth));
	if (r->ikeauth == NULL)
		err(1, "create_ike: calloc");
	r->ikeauth->type = authtype->type;
	r->ikeauth->string = authtype->string;
	r->tag = tag;

	return (r);

errout:
	free(r);
	free(hosts->src);
	hosts->src = NULL;
	free(hosts->dst);
	hosts->dst = NULL;
	if (phase1mode) {
		free(phase1mode->xfs);
		phase1mode->xfs = NULL;
		free(phase1mode->life);
		phase1mode->life = NULL;
	}
	if (phase2mode) {
		free(phase2mode->xfs);
		phase2mode->xfs = NULL;
		free(phase2mode->life);
		phase2mode->life = NULL;
	}
	if (srcid)
		free(srcid);
	if (dstid)
		free(dstid);
	return NULL;
}
@


1.167
log
@Up to now ipsecctl(8) grouped SAs with identical src and dst to the
flow which the first SA matched by the flow type.  This behaviour
was mostly undocumented and unexpected.  Make SA bundles explicit
in ipsec.conf(5).  Only group SAs that have the same src and dst
and also the same bundle identifier.
OK hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.166 2017/01/05 12:42:18 krw Exp $	*/
d194 1
a194 1
struct ipsec_rule	*create_sagroup(struct ipsec_addr_wrap *, u_int8_t,
d210 1
a210 1
int			 add_sagroup(struct ipsec_rule *, char *);
d2347 1
a2347 1
add_sagroup(struct ipsec_rule *r, char *bundle)
d2349 1
a2349 1
	struct ipsec_rule	*rp, *last, *group;
d2352 1
a2352 1
	TAILQ_FOREACH(rp, &ipsec->group_queue, group_entry) {
d2361 2
a2362 2
		last = TAILQ_LAST(&rp->dst_group_queue, dst_group_queue);
		TAILQ_INSERT_TAIL(&rp->dst_group_queue, r, dst_group_entry);
d2364 1
a2364 1
		group = create_sagroup(last->dst, last->satype, last->spi,
d2366 1
a2366 1
		if (group == NULL)
d2368 2
a2369 2
		group->nr = ipsec->rule_nr++;
		if (ipsecctl_add_rule(ipsec, group))
d2372 3
a2374 3
		TAILQ_INSERT_TAIL(&ipsec->group_queue, r, group_entry);
		TAILQ_INIT(&r->dst_group_queue);
		TAILQ_INSERT_TAIL(&r->dst_group_queue, r, dst_group_entry);
d2436 1
a2436 1
create_sagroup(struct ipsec_addr_wrap *dst, u_int8_t proto, u_int32_t spi,
d2443 1
a2443 1
		err(1, "create_sagroup: calloc");
d2445 1
a2445 1
	r->type |= RULE_GROUP;
d2664 1
a2664 1
			if (bundle && add_sagroup(r, bundle))
d2676 1
a2676 1
				if (bundle && add_sagroup(revr, bundle))
d2687 1
a2687 1
				if (bundle && add_sagroup(revr, bundle))
@


1.166
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.165 2016/06/21 21:35:24 benno Exp $	*/
d204 1
a204 1
			     struct ipsec_key *, int);
d210 1
a210 1
int			 add_sagroup(struct ipsec_rule *);
d266 1
a266 1
%token	INCLUDE
d287 1
d337 1
a337 1
			    0))
d343 1
a343 1
		    enckeyspec {
d352 1
a352 1
			    $7.keyin, 1))
d365 1
a365 1
			if (expand_rule(r, &$6, $3, 0, NULL, NULL, 0))
d379 1
a379 1
			if (expand_rule(r, &$7, 0, 0, NULL, NULL, 0))
d810 4
d958 1
d2347 1
a2347 1
add_sagroup(struct ipsec_rule *r)
d2354 2
a2355 1
		    (strcmp(rp->dst->name, r->dst->name) == 0)) {
d2375 1
d2635 1
a2635 1
    struct ipsec_key *enckey, int group)
d2664 1
a2664 1
			if (group && add_sagroup(r))
d2676 1
a2676 1
				if (group && add_sagroup(revr))
d2687 1
a2687 1
				if (group && add_sagroup(revr))
@


1.165
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.164 2015/12/09 21:41:50 naddy Exp $	*/
d1362 4
a1365 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1424 1
a1424 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1429 1
@


1.164
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.163 2015/11/04 12:46:13 mikeb Exp $	*/
d884 1
d887 7
@


1.163
log
@Decode Chacha20-Poly1305 when dumping SAs;  ok reyk, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.162 2015/06/03 02:24:36 millert Exp $	*/
a107 1
	{ "des-cbc",		ENCXF_DES_CBC,		8,	8,	0, 0 },
@


1.162
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.161 2014/11/20 05:51:20 jsg Exp $	*/
d125 1
@


1.161
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.160 2014/11/04 05:56:39 doug Exp $	*/
d1616 6
a1621 5
		asprintf(&ipa->name, "%s/%d", hbuf, prefixlen);
	} else
		ipa->name = strdup(hbuf);
	if (ipa->name == NULL)
		err(1, "host_v6: strdup");
@


1.160
log
@Add gcc format attributes to ipsecctl's parse.y.  Also, fix a few format
characters.

ok sthen@@ naddy@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.159 2014/01/22 00:21:16 henning Exp $	*/
d1161 3
@


1.159
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.157 2013/11/22 04:12:47 deraadt Exp $	*/
d63 6
a68 2
int		 yyerror(const char *, ...);
int		 yywarn(const char *, ...);
d2298 1
a2298 1
			    "%d bits", xfs->authxf->keymin * 8);
d2309 2
a2310 2
				yyerror("encryption key too short (%d bits), "
				    "minimum %d bits", enckey->len * 8,
d2315 2
a2316 2
				yyerror("encryption key too long (%d bits), "
				    "maximum %d bits", enckey->len * 8,
@


1.158
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d1249 2
a1250 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
@


1.157
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.156 2012/07/10 13:58:33 lteo Exp $	*/
d999 1
a999 1
char	*parsebuf;
d1001 1
a1001 1
char	 pushback_buffer[MAXPUSHBACK];
d1093 2
a1094 2
	char	 buf[8096];
	char	*p, *val;
d1117 1
a1117 1
				*p++ = (char)c;
d1162 1
a1162 1
			*p++ = (char)c;
@


1.156
log
@Rename "life" to "lifetime" to match iked.

ok mikeb naddy sthen; procedures ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.155 2012/07/08 17:51:51 naddy Exp $	*/
d1986 1
a1986 1
		switch (tolower(unit)) {
@


1.155
log
@Disallow manual security associations that use AES-CTR, AES-GCM,
or AES-GMAC.  These algorithms cannot be used safely with static
keys and RFCs 3686, 4106, and 4543 expressly forbid such configurations.

Also include a tweak (with jmc@@) to the key size explanation, for
completeness sake.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.154 2012/07/07 20:29:23 naddy Exp $	*/
d171 1
a171 1
struct ipsec_life	*parse_life(int);
d173 1
a173 1
struct ipsec_life	*copylife(const struct ipsec_life *);
d250 1
a250 1
		struct ipsec_life	*life;
d260 1
a260 1
%token	PASSIVE ACTIVE ANY IPIP IPCOMP COMPXF TUNNEL TRANSPORT DYNAMIC LIFE
d288 1
a288 1
%type	<v.life>		life
d716 2
a717 2
		| MAIN transforms life		{
			struct ike_mode	*p1;
d726 1
a726 1
		| AGGRESSIVE transforms life		{
d747 1
a747 1
		| QUICK transforms life		{
d759 2
a760 2
life		: /* empty */			{
			struct ipsec_life *life;
d763 11
a773 1
			if ((life = calloc(1, sizeof(struct ipsec_life)))
d776 2
a777 2
			life->lifetime = -1;
			life->lifevolume = -1;
d780 1
a780 5
		| LIFE NUMBER			{
			if ($2 > INT_MAX || $2 < 0) {
				yyerror("%lld not a valid lifetime", $2);
				YYERROR;
			}
d959 1
a959 1
		{ "life",		LIFE },
d1976 2
a1977 2
struct ipsec_life *
parse_life(int value)
d1979 19
a1997 1
	struct ipsec_life	*life;
d1999 1
a1999 1
	life = calloc(1, sizeof(struct ipsec_life));
d2003 2
a2004 1
	life->lifetime = value;
d2025 2
a2026 2
struct ipsec_life *
copylife(const struct ipsec_life *life)
d2028 1
a2028 1
	struct ipsec_life *newlife;
d2033 1
a2033 1
	newlife = calloc(1, sizeof(struct ipsec_life));
d2037 1
a2037 1
	memcpy(newlife, life, sizeof(struct ipsec_life));
@


1.154
log
@copy&paste mistake in error message
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.153 2012/06/30 14:51:31 naddy Exp $	*/
d101 22
a122 22
	{ "unknown",		ENCXF_UNKNOWN,		0,	0,	0 },
	{ "none",		ENCXF_NONE,		0,	0,	0 },
	{ "3des-cbc",		ENCXF_3DES_CBC,		24,	24,	0 },
	{ "des-cbc",		ENCXF_DES_CBC,		8,	8,	0 },
	{ "aes",		ENCXF_AES,		16,	32,	0 },
	{ "aes-128",		ENCXF_AES_128,		16,	16,	0 },
	{ "aes-192",		ENCXF_AES_192,		24,	24,	0 },
	{ "aes-256",		ENCXF_AES_256,		32,	32,	0 },
	{ "aesctr",		ENCXF_AESCTR,		16+4,	32+4,	0 },
	{ "aes-128-ctr",	ENCXF_AES_128_CTR,	16+4,	16+4,	0 },
	{ "aes-192-ctr",	ENCXF_AES_192_CTR,	24+4,	24+4,	0 },
	{ "aes-256-ctr",	ENCXF_AES_256_CTR,	32+4,	32+4,	0 },
	{ "aes-128-gcm",	ENCXF_AES_128_GCM,	16+4,	16+4,	1 },
	{ "aes-192-gcm",	ENCXF_AES_192_GCM,	24+4,	24+4,	1 },
	{ "aes-256-gcm",	ENCXF_AES_256_GCM,	32+4,	32+4,	1 },
	{ "aes-128-gmac",	ENCXF_AES_128_GMAC,	16+4,	16+4,	1 },
	{ "aes-192-gmac",	ENCXF_AES_192_GMAC,	24+4,	24+4,	1 },
	{ "aes-256-gmac",	ENCXF_AES_256_GMAC,	32+4,	32+4,	1 },
	{ "blowfish",		ENCXF_BLOWFISH,		5,	56,	0 },
	{ "cast128",		ENCXF_CAST128,		5,	16,	0 },
	{ "null",		ENCXF_NULL,		0,	0,	0 },
	{ NULL,			0,			0,	0,	0 },
d2222 5
@


1.153
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.152 2011/12/20 13:27:51 mikeb Exp $	*/
d743 1
a743 1
				err(1, "phase1mode: calloc");
d751 1
a751 1
				err(1, "phase1mode: calloc");
@


1.152
log
@unsigned long should use "%lu" format; from eric lax, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.151 2011/07/06 22:03:00 deraadt Exp $	*/
d110 3
@


1.151
log
@For non-crypted flows (such as ipcomp and ipip), default their
type (if not specified) to "use" instead of "require".
(since they will not get a key...)
ok mikeb claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.150 2010/10/06 22:19:20 mikeb Exp $	*/
d1431 1
a1431 1
		yyerror("%lld not a valid spi", ulval);
d1435 1
a1435 1
		yyerror("%lld within reserved spi range", ulval);
@


1.150
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.149 2010/09/22 14:04:09 mikeb Exp $	*/
d581 1
a581 1
			$$ = TYPE_REQUIRE;
d2427 12
@


1.149
log
@Support AES-GCM-16 (as aes-gcm) and ENCR_NULL_AUTH_AES_GMAC
(as aes-gmac) encryption transformations in the ipsec.conf(5).

Available "enc" arguments denoting use of

1) AES-GCM-16:

 aes-128-gcm for 160 bit key (128+nonce)
 aes-192-gcm for 224 bit key (192+nonce)
 aes-256-gcm for 288 bit key (256+nonce)

2) ENCR_NULL_AUTH_AES_GMAC:

 aes-128-gmac for 160 bit key (128+nonce)
 aes-192-gmac for 224 bit key (192+nonce)
 aes-256-gmac for 288 bit key (256+nonce)

Please note that aes-gmac family performs no encryption and provides
no confidentiality and is intended for cases in which confidentiality
is not desired (it can be thought of as AH with NAT-T support).

Also, although this implementation supports manual keying, it's
use is strictly discouraged as AES-GCM security depends on frequent
re-keying.  So it can be thought of as a debug facility only.

Example configuration:

	ike esp from 172.23.61.36 to 172.23.61.156 \
		quick enc aes-256-gcm \
		psk humppa

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

OK naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.148 2010/08/03 18:42:40 henning Exp $	*/
a118 1
	{ "skipjack",		ENCXF_SKIPJACK,		10,	10,	0 },
@


1.148
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.147 2010/05/10 02:00:50 krw Exp $	*/
d101 20
a120 14
	{ "unknown",		ENCXF_UNKNOWN,		0,	0 },
	{ "none",		ENCXF_NONE,		0,	0 },
	{ "3des-cbc",		ENCXF_3DES_CBC,		24,	24 },
	{ "des-cbc",		ENCXF_DES_CBC,		8,	8 },
	{ "aes",		ENCXF_AES,		16,	32 },
	{ "aes-128",		ENCXF_AES_128,		16,	16 },
	{ "aes-192",		ENCXF_AES_192,		24,	24 },
	{ "aes-256",		ENCXF_AES_256,		32,	32 },
	{ "aesctr",		ENCXF_AESCTR,		16+4,	32+4 },
	{ "blowfish",		ENCXF_BLOWFISH,		5,	56 },
	{ "cast128",		ENCXF_CAST128,		5,	16 },
	{ "null",		ENCXF_NULL,		0,	0 },
	{ "skipjack",		ENCXF_SKIPJACK,		10,	10 },
	{ NULL,			0,			0,	0 },
a2217 2
		if (!xfs->authxf)
			xfs->authxf = &authxfs[AUTHXF_HMAC_SHA2_256];
d2220 6
d2707 1
a2707 22
		free(r);
		free(hosts->src);
		hosts->src = NULL;
		free(hosts->dst);
		hosts->dst = NULL;
		if (phase1mode) {
			free(phase1mode->xfs);
			phase1mode->xfs = NULL;
			free(phase1mode->life);
			phase1mode->life = NULL;
		}
		if (phase2mode) {
			free(phase2mode->xfs);
			phase2mode->xfs = NULL;
			free(phase2mode->life);
			phase2mode->life = NULL;
		}
		if (srcid)
			free(srcid);
		if (dstid)
			free(dstid);
		return NULL;
d2721 7
d2750 24
@


1.147
log
@Various comment typos. 'wether' -> 'whether' (most popular), 'possiblity' ->
'possibility', 'optins' -> 'options', 'resposne' -> 'response', 'unecessary' -> 'unnecessary', 'desination' -> 'destination'. Collected from various misc@@
and tech@@ postings, many by Brad Tilley.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.146 2009/08/04 15:05:50 jsing Exp $	*/
d1135 2
a1136 1
				else if (next == '\n')
d1138 1
a1138 1
				else
@


1.146
log
@Specify an ID-type of IPV4_ADDR or IPV6_ADDR if the srcid or dstid is
given as an IPv4 or IPv6 address, rather than treating the IP address as
a FQDN.

ok hshoexer@@ markus@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.144 2009/01/30 14:24:52 bluhm Exp $	*/
d1804 1
a1804 1
	/* check wether this is a group */
@


1.145
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1498 10
a1507 1
	if (string && strchr(string, '@@'))
d1509 2
a1510 1
	return (ID_FQDN);
@


1.144
log
@If the "peer" address is not specified or derived from "to" for
"ike" rules in ipsec.conf, the default peer is used.  In theory
ipsecctl -f ipsec.conf can configure the default peer for each "ike"
entry.  As isakmpd only supports one default peer, the last "ike"
rule that uses a default peer wins.  This configuration is then
significant for all "ike" rules that use the default peer.

Now a warning is printed if a later rule in ipsec.conf changes the
configuration of the original default peer.  This should be an error
but that would break existing user configs.  So only a warning is
printed.

ok hshoexer@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.143 2009/01/29 15:37:09 bluhm Exp $	*/
d1246 1
a1246 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d1248 5
@


1.143
log
@After checking that peer == NULL do not assign peer = NULL a few
lines later.  No functional change.

ok grunk@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.142 2009/01/28 18:07:19 bluhm Exp $	*/
d64 1
d897 13
d2476 7
a2482 1
	} else if (r->peer->af == AF_UNSPEC) {
a2485 1
		return (0);
d2487 6
d2494 39
a2532 4
	if (r->type == RULE_FLOW && r->peer == NULL) {
		yyerror("no peer specified for destination %s",
		    r->dst->name);
		return (1);
@


1.142
log
@Allow to specify ike and flow explicitly without peer.  The any
keyword as argument for the peer parameter will do that.  An ike
without peer creates the peer-default config.  A flow without peer
acquires a host-to-host SA.

tested by grunk@@, todd@@,  ok grunk@@, hshoexer@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.141 2009/01/20 14:36:19 mpf Exp $	*/
d2456 1
a2456 3
			if (r->src->netaddress)
				r->peer = NULL;
			else
d2459 1
a2459 3
			if (r->dst->netaddress)
				r->peer = NULL;
			else
@


1.141
log
@Add support to isakmpd(8) and ipsecctl(8) to install SA's with a
different source network than we have negotiated with a peer.
This enables us to do nat/binat on the enc(4) interface.
Very useful to work around rfc 1918 collisions.
Manpage and testing by Mitja Muzenic. Thanks!
OK hshoexer@@, markus@@. "I like it" todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.140 2008/11/14 23:16:37 hshoexer Exp $	*/
d155 1
d214 1
d266 1
d470 1
a470 1
		| PEER singlehost LOCAL singlehost	{
d474 1
a474 1
		| LOCAL singlehost PEER singlehost	{
d478 1
a478 1
		| PEER singlehost			{
d488 5
d551 1
a551 9
			struct ipsec_addr_wrap	*ipa;

			ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
			if (ipa == NULL)
				err(1, "host: calloc");
			ipa->af = AF_UNSPEC;
			ipa->netaddress = 1;
			ipa->tail = ipa;
			$$ = ipa;
d1697 14
d2466 5
@


1.140
log
@When parsing v4 addresses mark them as network addresses
(IPV4_ADDR_SUBNET) when they contain a '/'.

This allows to choose between IPV4_ADDR and IPV4_ADDR_SUBNET by adding
"/32", ie. "a.b.c.d" vs. "a.b.c.d/32".  This helps to interop with other
IKE implementations.

From Mitja Muzenic <mitja at muzenic dot net>, thanks!

Idea supported by markus@@ and jdixon@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.139 2008/10/17 14:33:15 henning Exp $	*/
d265 1
a265 1
%type	<v.host>		host host_list
d410 8
d424 8
d510 1
a510 1
host		: STRING			{
d530 11
@


1.139
log
@findeol() fix from pfctl
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.138 2008/07/01 14:31:37 bluhm Exp $	*/
d1579 1
a1579 1
	if (bits != (ipa->af == AF_INET ? 32 : 128))
@


1.138
log
@If a rules contains a hostname instead of an address, use the list
of all possible addresses from DNS and not only the first one.  So
during expansion, the right address family can be chosen and
regression test ike56 passes again.  There localhost resolves to
127.0.0.1 and ::1.
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.137 2008/07/01 14:08:39 bluhm Exp $	*/
a1017 1
	pushback_index = 0;
d1021 4
a1024 1
		c = lgetc(0);
@


1.137
log
@If multiple to addresses but no peer are given in an ike or flow
rule, the current to address is taken as peer during expansion.
This makes the broken regress test ikefail7 obsolete as address
family mismatch cannot happen anymore.
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.136 2008/06/14 00:57:30 bluhm Exp $	*/
d1586 1
a1586 1
	struct ipsec_addr_wrap	*ipa = NULL;
d1632 6
a1650 1
		break;
d1654 1
a1654 1
	return (ipa);
@


1.136
log
@Move ike and flow peer selection to common function.
No functional change yet.
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.135 2008/06/11 22:11:20 bluhm Exp $	*/
d184 2
a185 3
			     struct ipsec_hosts *, u_int8_t, char *, char *,
			     u_int8_t);
void			 set_rule_peers(struct ipsec_rule *r,
d188 3
a190 2
int			 expand_rule(struct ipsec_rule *, u_int8_t, u_int32_t,
			     struct ipsec_key *, struct ipsec_key *, int);
d193 3
a195 3
			     struct ipsec_hosts *, struct ike_mode *,
			     struct ike_mode *, u_int8_t, u_int8_t, u_int8_t,
			     char *, char *, struct ike_auth *, char *);
d319 2
a320 1
			if (expand_rule(r, 0, $3.spiin, $4.keyin, NULL, 0))
d334 2
a335 1
			if (expand_rule(r, 0, $4.spiin, $6.keyin, $7.keyin, 1))
d343 1
a343 1
			r = create_flow($3, $4, &$5, &$6, $2, $7.srcid,
d348 1
a348 1
			if (expand_rule(r, $3, 0, NULL, NULL, 0))
d357 1
a357 1
			r = create_ike($5, &$6, &$7, $8, $9, $3, $4, $2,
d362 1
a362 1
			if (expand_rule(r, 0, 0, NULL, NULL, 0))
a2314 1
    struct ipsec_hosts *peers,
a2345 6
	set_rule_peers(r, peers);
	if (r->peer == NULL) {
		yyerror("no peer specified");
		goto errout;
	}

d2396 1
a2396 1
void
d2399 6
a2404 2
	r->local = peers->src;
	r->peer = peers->dst;
d2419 7
d2429 3
a2431 2
expand_rule(struct ipsec_rule *rule, u_int8_t direction, u_int32_t spi,
    struct ipsec_key *authkey, struct ipsec_key *enckey, int group)
d2435 1
a2435 1
	int added = 0;
a2442 1
	expand_any(rule->peer);
d2452 5
d2459 1
a2459 1
				return (1);
d2461 1
a2461 1
				return (1);
d2467 1
a2467 1
					return (1);
d2471 1
a2471 1
					return (1);
d2473 1
a2473 1
					return (1);
d2478 1
a2478 1
					return (1);
d2482 1
a2482 1
					return (1);
d2484 1
a2484 1
					return (1);
d2492 1
d2494 8
a2501 1
	return (0);
d2552 1
a2552 1
create_ike(u_int8_t proto, struct ipsec_hosts *hosts, struct ipsec_hosts *peers,
a2595 2

	set_rule_peers(r, peers);
@


1.135
log
@trivial code simplification
tested and ok hshoexer, grunk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.134 2008/04/11 00:05:51 reyk Exp $	*/
d171 1
a171 1
			    struct ipsec_addr_wrap *);
d186 2
d2345 5
a2349 18
	r->local = peers->src;
	if (peers->dst == NULL) {
		/* Set peer to remote host.  Must be a host address. */
		if (r->direction == IPSEC_IN) {
			if (r->src->netaddress) {
				yyerror("no peer specified");
				goto errout;
			}
			r->peer = copyhost(r->src);
		} else {
			if (r->dst->netaddress) {
				yyerror("no peer specified");
				goto errout;
			}
			r->peer = copyhost(r->dst);
		}
	} else
		r->peer = peers->dst;
d2400 21
d2578 1
a2578 18
	if (peers->dst == NULL) {
		/* Set peer to remote host.  Must be a host address. */
		if (r->direction == IPSEC_IN) {
			if (r->src->netaddress)
				r->peer = NULL;
			else
				r->peer = copyhost(r->src);
		} else {
			if (r->dst->netaddress)
				r->peer = NULL;
			else
				r->peer = copyhost(r->dst);
		}
	} else
		r->peer = peers->dst;

	if (peers->src)
		r->local = peers->src;
@


1.134
log
@add support for the "include" directive using code from pfctl/parse.y.

pointed out by Prabhu Gurumurthy

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.132 2007/11/12 23:59:41 mpf Exp $	*/
d2339 2
a2340 2
	if (type == TYPE_DENY || type == TYPE_BYPASS) {
		r->flowtype = type;
a2341 1
	}
a2342 1
	r->flowtype = type;
@


1.133
log
@Support for specifying aes-{128,192,256}.  Originial idea by Prabhu
Gurumurthy, tweaks and commit-ready diff by Mitja Muzenic!  Thanks
guys!

ok todd@@
@
text
@d249 1
d280 1
d294 15
d897 1
@


1.132
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.131 2007/10/22 16:35:33 pyr Exp $	*/
d105 3
@


1.131
log
@sync with daemon parser code.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.130 2007/10/16 20:01:23 mpf Exp $	*/
a961 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d1018 1
a1018 1
	while ((c = lgetc(0)) == ' ')
@


1.130
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.129 2007/10/16 06:06:49 deraadt Exp $	*/
d1187 2
a1188 1
	    (nfile->name = strdup(name)) == NULL)
d1190 1
d1195 1
d1200 1
a1241 1
		warn("cannot open the main config file!");
@


1.129
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.128 2007/10/13 16:35:18 deraadt Exp $	*/
d1096 1
a1096 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.128
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.127 2007/10/11 14:39:16 deraadt Exp $	*/
d1073 1
a1073 1
				if (next == quotec)
d1075 2
@


1.127
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.126 2007/09/12 20:22:59 hshoexer Exp $	*/
d50 32
a84 3
static FILE		*fin = NULL;
static int		 lineno = 1;
static int		 errors = 0;
a141 21
int			 yyerror(const char *, ...);
int			 yyparse(void);
int			 kw_cmp(const void *, const void *);
int			 lookup(char *);
int			 lgetc(int);
int			 lungetc(int);
int			 findeol(void);
int			 yylex(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int		 used;
	int		 persist;
	char		*nam;
	char		*val;
};

int			 symset(const char *, const char *, int);
int			 cmdline_symset(char *);
char			*symget(const char *);
d282 1
a282 1
		| grammar error '\n'		{ errors++; }
a833 1
	extern const char *infile;
d835 1
a835 1
	errors = 1;
d837 1
a837 1
	fprintf(stderr, "%s: %d: ", infile, yylval.lineno);
d925 1
a925 1
lgetc(int inquot)
d927 1
a927 2
	int	c, next;
	FILE *f = fin;
d943 7
a949 2
	if (inquot) {
		c = getc(f);
d953 2
a954 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d959 2
a960 2
		yylval.lineno = lineno;
		lineno++;
d965 1
a965 1
			c = getc(f);
d967 1
a967 1
		ungetc(c, f);
d971 5
d1007 1
a1007 1
			lineno++;
d1021 1
a1021 1
	int	 endc, next, c;
d1029 1
a1029 1
	yylval.lineno = lineno;
d1063 1
a1063 1
		endc = c;
d1065 1
a1065 1
			if ((c = lgetc(1)) == EOF)
d1068 1
a1068 1
				lineno++;
d1071 1
a1071 1
				if ((next = lgetc(1)) == EOF)
d1073 1
a1073 1
				if (next == endc)
d1077 1
a1077 1
			} else if (c == endc) {
d1151 2
a1152 2
		yylval.lineno = lineno;
		lineno++;
d1160 69
a1228 1
parse_rules(FILE *input, struct ipsecctl *ipsecx)
d1231 1
d1234 5
a1238 3
	fin = input;
	lineno = 1;
	errors = 0;
d1241 2
a1248 1
		TAILQ_REMOVE(&symhead, sym, entries);
d1251 1
d1264 1
a1264 1
	    sym = TAILQ_NEXT(sym, entries))
a1270 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1273 1
d1293 1
a1293 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d1324 1
a1324 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.126
log
@Here too: Add support to the lex for parsing number out of the stream.
handle this in the parser.  better range checks.

with and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.125 2007/08/10 12:32:12 markus Exp $	*/
d117 1
a117 1
int			 lgetc(FILE *);
d918 1
a918 1
lgetc(FILE *f)
d921 1
d937 5
d989 1
a989 1
		c = lgetc(fin);
d1005 1
a1005 1
	int	 endc, c;
d1010 1
a1010 1
	while ((c = lgetc(fin)) == ' ')
d1015 1
a1015 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d1019 1
a1019 1
			if ((c = lgetc(fin)) == EOF)
d1036 1
a1036 1
			yyerror("macro \"%s\" not defined", buf);
d1049 1
a1049 1
			if ((c = lgetc(fin)) == EOF)
a1050 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d1054 10
d1087 1
a1087 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
d1126 1
a1126 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.125
log
@duplicate strdup; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.124 2007/07/03 11:32:27 markus Exp $	*/
d190 1
a190 1
		u_int32_t	 number;
d239 1
d244 1
a245 1
%type	<v.number>		number
d248 1
a276 18
number		: STRING			{
			unsigned long	ulval;

			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
				free($1);
				YYERROR;
			}
			if (ulval > UINT_MAX) {
				yyerror("0x%lx out of range", ulval);
				free($1);
				YYERROR;
			}
			$$ = (u_int32_t)ulval;
			free($1);
		}
		;

d343 6
a348 1
		| PROTO STRING			{
a349 2
			const char *errstr;
			int proto;
d351 12
a362 8
			if ((p = getprotobyname($2)) != NULL) {
				$$ = p->p_proto;
			} else {
				errstr = NULL;
				proto = strtonum($2, 0, 255, &errstr);
				if (errstr)
					errx(1, "unknown protocol: %s", $2);
				$$ = proto;
a363 1

a364 2
		| PROTO ESP 			{ $$ = IPPROTO_ESP; }
		| PROTO AH			{ $$ = IPPROTO_AH; }
d392 4
a395 1
		| PORT STRING				{
a396 2
			const char *errstr;
			int port;
d398 2
a399 2
			if ((s = getservbyname($2, "tcp")) != NULL ||
			    (s = getservbyname($2, "udp")) != NULL) {
d402 8
a409 7
				errstr = NULL;
				port = strtonum($2, 0, USHRT_MAX, &errstr);
				if (errstr) {
					yyerror("unknown port: %s", $2);
					YYERROR;
				}
				$$ = htons(port);
d411 1
d470 1
a470 1
		| STRING '/' number		{
d473 1
a473 1
			if (asprintf(&buf, "%s/%u", $1, $3) == -1)
a548 1
					yyerror("%s is not a valid spi", p);
a556 1
				yyerror("%s is not a valid spi", $2);
d565 13
d702 6
a707 7
		| LIFE number			{
			struct ipsec_life *life;

			life = parse_life($2);
			if (life == NULL)
				yyerror("%s not a valid lifetime", $2);
			$$ = life;
d1065 36
d1254 4
d1259 1
a1259 1
		yyerror("illegal SPI value");
@


1.124
log
@allow proto esp/ah in flow specification (especially useful for bypass flows)
ok hshoexer, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.123 2007/05/10 06:10:04 hshoexer Exp $	*/
a1539 2
		if ((n->name = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
@


1.123
log
@Do not crash when lists include the "any" keyword.  Reported by
<ralf.horstmann at gmx.net>, thanks!

Slightly different fix.  Also add a regression test.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.122 2007/03/16 20:51:01 markus Exp $	*/
d375 2
@


1.122
log
@move autodetection of the ID type to the parser.  this way the
static flows have the correct ID, too. ok hshoexer, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.121 2007/02/26 14:40:09 todd Exp $	*/
d498 1
@


1.121
log
@Really, we don't need two grp18's ;-)
ok hshoexer@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.120 2007/02/19 09:00:46 hshoexer Exp $	*/
d184 1
d1281 8
d1783 2
a1784 1
	newauth->idtype = auth->idtype;
d2208 2
a2209 2
	r->auth->idtype = ID_FQDN;	/* XXX For now only FQDN. */

d2355 2
a2356 1
		reverse->auth->idtype = rule->auth->idtype;
d2451 2
a2452 1
	r->auth->idtype = ID_FQDN;	/* XXX For now only FQDN. */
@


1.120
log
@Bits for ESP+NULL encryption.  This is useful, when AH can not be
used (when being behind NAT).  With Martin Hedenfalk <martin.hedenfalk
at gmail.com>, thanks!

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.119 2007/02/19 08:29:30 hshoexer Exp $	*/
d107 1
a107 1
	{ "grp18",		GROUPXF_6144,		6144,	0 },
@


1.119
log
@undo previous commit and keep the original behaviour of the parser.

asked for by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.118 2007/02/16 10:16:09 hshoexer Exp $	*/
d1994 1
a1994 1
		if (!authkey) {
d1998 1
a1998 1
		if (authkey->len != xfs->authxf->keymin) {
@


1.118
log
@Do not accept '\n' in quoted strings.  Addresses issues noticed by
Prabhu Gurumurthy <pgurumu () gmail ! com>
(http://marc.theaimsgroup.com/?l=openbsd-misc&m=116060233106902&w=2),
thanks!

ok markus@@ cloder@@ (uhm, quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.117 2007/01/10 14:37:09 markus Exp $	*/
d1044 4
a1047 2
			if (c == '\n')
				return (0);
@


1.117
log
@allow rule if there is at least _one_ matching address family combination.
this allows 'flow from lo0 to 127.0.0.1' if lo0 has an ipv6 address.
ok itojun@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.116 2007/01/04 21:31:21 markus Exp $	*/
d1044 2
a1045 4
			if (c == '\n') {
				lineno++;
				continue;
			}
@


1.116
log
@don't pass -1 as a netmask; report vicviq at gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.115 2007/01/02 23:27:33 itojun Exp $	*/
d1919 1
a1919 1
	if (src_v4 != dst_v4 || src_v6 != dst_v6)
@


1.115
log
@better support for IPv6 hostname/numeric representation.
hostname/prefixlen works only for IPv4-only hostname.
markus ok (regress tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.114 2006/11/24 13:52:13 reyk Exp $	*/
d1464 1
a1464 1
			set_ipmask(ipa, mask);
d1467 2
a1468 1
				err(1, "host_dns: cannot apply netmask on non-IPv4 address");
@


1.114
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.113 2006/11/13 11:04:05 mcbride Exp $	*/
d142 1
a142 1
struct ipsec_addr_wrap	*host_dns(const char *, int, int);
d1284 1
a1284 1
	int			 mask, v4mask, cont = 1;
a1294 1
		v4mask = mask;
a1297 1
		v4mask = 32;
d1306 1
a1306 1
	if (cont && (ipa = host_v4(s, v4mask)) != NULL)
d1314 1
a1314 1
	if (cont && (ipa = host_dns(s, v4mask, 0)) != NULL)
d1329 1
a1329 1
	struct addrinfo		 hints, *res0, *res;
d1333 1
a1333 1
	hints.ai_family = PF_UNSPEC;
d1336 1
a1336 1
	if (getaddrinfo(s, NULL, &hints, &res0))
d1338 2
a1340 5
	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET6)
			continue;
		break; /* found one */
	}
d1343 1
a1343 1
		err(1, "host_addr: calloc");
d1346 1
a1346 1
	    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr.s6_addr,
d1365 1
a1365 1
		err(1, "host_dns: strdup");
d1367 1
a1367 1
	freeaddrinfo(res0);
d1408 1
a1408 1
host_dns(const char *s, int v4mask, int v6mask)
d1413 1
a1413 1
	int			 bits = 32;
d1423 1
a1423 1
		if (res->ai_family != AF_INET)
d1425 1
d1429 22
a1450 4
		memcpy(&ipa->address.v4,
		    &((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr,
		    sizeof(struct in_addr));
		ipa->name = strdup(inet_ntoa(ipa->address.v4));
d1453 1
a1453 1
		ipa->af = AF_INET;
d1457 11
a1467 3
		set_ipmask(ipa, bits);
		if (bits != (ipa->af == AF_INET ? 32 : 128))
			ipa->netaddress = 1;
d1513 1
a1513 1
			    ifa->ifa_addr)->sin_addr.s_addr,
d1516 1
a1516 1
			    ifa->ifa_netmask)->sin_addr.s_addr,
d1521 1
a1521 1
			    ifa->ifa_addr)->sin6_addr.s6_addr,
d1524 1
a1524 1
			    ifa->ifa_netmask)->sin6_addr.s6_addr,
d1645 1
a1645 2
			if (IN6_IS_ADDR_LINKLOCAL(&n->address.v6) ||
			    IN6_IS_ADDR_MC_LINKLOCAL(&n->address.v6)) {
@


1.113
log
@Handle rules with addresses from mismatched address families correctly.

ok msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.112 2006/11/10 15:01:31 msf Exp $	*/
d157 1
d182 1
a182 1
			     char *, char *, struct ike_auth *);
d236 1
a236 1
%token	TYPE DENY BYPASS LOCAL PROTO USE ACQUIRE REQUIRE DONTACQ GROUP PORT
d261 1
d337 1
a337 1
		    phase1mode phase2mode ids ikeauth {
d341 1
a341 1
			    $10.srcid, $10.dstid, &$11);
d779 10
d881 1
d1815 13
d1849 1
d2334 1
a2334 1
    struct ike_auth *authtype)
d2424 1
@


1.112
log
@check both rule sourace and destination when grouping sa's

fixes PR5262

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.111 2006/11/10 14:42:19 hshoexer Exp $	*/
d158 2
d174 1
d493 1
a493 2

			ipa->af = AF_INET;
a494 12
			if ((ipa->name = strdup("0.0.0.0/0")) == NULL)
				err(1, "host: strdup");

			ipa->next = calloc(1, sizeof(struct ipsec_addr_wrap));
			if (ipa->next == NULL)
				err(1, "host: calloc");

			ipa->next->af = AF_INET6;
			ipa->next->netaddress = 1;
			if ((ipa->next->name = strdup("::/0")) == NULL)
				err(1, "host: strdup");

d1796 1
a1796 1
	if ((dst->name = strdup(src->name)) == NULL)
d1842 36
d2167 27
d2202 7
d2252 1
@


1.111
log
@Do not count sa, ike and tcpmd5 rules twice.  Fixes PR 5263.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.110 2006/11/01 03:10:02 mcbride Exp $	*/
d1960 2
a1961 1
		if (strcmp(rp->dst->name, r->dst->name) == 0) {
@


1.110
log
@Add support for aggressive mode (from the k2k6 IPsec hackathon).

ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.109 2006/09/22 10:22:49 hshoexer Exp $	*/
a297 1
			r->nr = ipsec->rule_nr++;
a311 1
			r->nr = ipsec->rule_nr++;
a338 1
			r->nr = ipsec->rule_nr++;
@


1.109
log
@typo in err(); from bret.lambert@@gmail.com, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.108 2006/06/18 18:18:01 hshoexer Exp $	*/
d222 1
a222 2
		struct ike_mode		*mainmode;
		struct ike_mode		*quickmode;
d230 2
a231 2
%token	AUTHKEY ENCKEY FILENAME AUTHXF ENCXF ERROR IKE MAIN QUICK PASSIVE
%token	ACTIVE ANY IPIP IPCOMP COMPXF TUNNEL TRANSPORT DYNAMIC LIFE
d256 1
a256 2
%type	<v.mainmode>		mainmode
%type	<v.quickmode>		quickmode
d333 2
a334 2
ikerule		: IKE ikemode satype tmode proto hosts peers mainmode quickmode
		    ids ikeauth {
d644 2
a645 2
mainmode	: /* empty */			{
			struct ike_mode		*mm;
d647 5
a651 4
			/* We create just an empty mode */
			if ((mm = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "mainmode: calloc");
			$$ = mm;
d654 1
a654 1
			struct ike_mode	*mm;
d656 16
a671 5
			if ((mm = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "mainmode: calloc");
			mm->xfs = $2;
			mm->life = $3;
			$$ = mm;
d675 8
a682 7
quickmode	: /* empty */			{
			struct ike_mode		*qm;

			/* We create just an empty mode */
			if ((qm = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "quickmode: calloc");
			$$ = qm;
d685 1
a685 1
			struct ike_mode	*qm;
d687 6
a692 5
			if ((qm = calloc(1, sizeof(struct ike_mode))) == NULL)
				err(1, "quickmode: calloc");
			qm->xfs = $2;
			qm->life = $3;
			$$ = qm;
d846 1
d1830 4
a1833 4
	r->mmxfs = copytransforms(rule->mmxfs);
	r->qmxfs = copytransforms(rule->qmxfs);
	r->mmlife = copylife(rule->mmlife);
	r->qmlife = copylife(rule->qmlife);
d1837 2
d2246 2
a2247 2
    struct ike_mode *mainmode, struct ike_mode *quickmode,
    u_int8_t satype, u_int8_t tmode, u_int8_t mode, char *srcid, char *dstid,
d2271 11
a2281 11
		if (mainmode) {
			free(mainmode->xfs);
			mainmode->xfs = NULL;
			free(mainmode->life);
			mainmode->life = NULL;
		}
		if (quickmode) {
			free(quickmode->xfs);
			quickmode->xfs = NULL;
			free(quickmode->life);
			quickmode->life = NULL;
d2312 6
a2317 7
	if (mainmode) {
		r->mmxfs = mainmode->xfs;
		r->mmlife = mainmode->life;
	}
	if (quickmode) {
		r->qmxfs = quickmode->xfs;
		r->qmlife = quickmode->life;
d2319 8
@


1.108
log
@add group "none"; when choosen, pfs will be disabled.

ok david msf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.107 2006/06/16 10:09:51 hshoexer Exp $	*/
d1462 1
a1462 1
		err(1, "ifa_load: getiffaddrs");
@


1.108.2.1
log
@MFC:
Fix by msf@@

check both rule source and destination when grouping sa's

fixes PR5262

ok msg@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.108 2006/06/18 18:18:01 hshoexer Exp $	*/
d1948 1
a1948 2
		if ((strcmp(rp->src->name, r->src->name) == 0) &&
		    (strcmp(rp->dst->name, r->dst->name) == 0)) {
@


1.107
log
@report the correct line number on an error.  Noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.106 2006/06/11 20:21:08 hshoexer Exp $	*/
d93 1
@


1.106
log
@As naddy@@ pointed out RFC 3686 discourages use of AESCTR for static
keying.  markus@@ seconds this, so use AES CBC as default.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.105 2006/06/10 19:38:24 hshoexer Exp $	*/
d813 1
a813 1
	fprintf(stderr, "%s: %d: ", infile, yyval.lineno);
@


1.105
log
@Better error message when a key file can not be opened or the provided key is
not of correct size.  Suggested by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.104 2006/06/10 12:02:56 deraadt Exp $	*/
d1875 1
a1875 1
			xfs->encxf = &encxfs[ENCXF_AESCTR];
@


1.104
log
@knf & careful data freeing, regression tested by todd
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.103 2006/06/08 22:34:30 hshoexer Exp $	*/
d1252 1
a1252 1
		err(1, "parsekeyfile: open");
d1256 1
a1256 1
		errx(1, "parsekeyfile: key too %s", sb.st_size ? "large" :
@


1.103
log
@fix some indentation, noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.102 2006/06/08 21:15:21 naddy Exp $	*/
d1603 1
a1603 1
		switch(n->af) {
d1925 1
a1925 1
				     xfs->encxf->keymin * 8);
d1931 1
a1931 1
				     xfs->encxf->keymax * 8);
d2120 1
d2122 1
d2252 1
d2254 1
d2257 1
d2259 1
d2263 1
d2265 1
@


1.102
log
@Add a transport mode specifier to ike rules.  Tunnel mode remains the default.
"looks right" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.101 2006/06/08 16:51:25 todd Exp $	*/
d335 1
a335 1
		      ids ikeauth {
d2074 1
a2074 1
            (proto != IPPROTO_TCP && proto != IPPROTO_UDP)) {
d2246 1
a2246 1
            (proto != IPPROTO_TCP && proto != IPPROTO_UDP)) {
@


1.101
log
@turns out this really doesn't break what is in the tree; ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.100 2006/06/07 23:02:52 hshoexer Exp $	*/
d176 2
a177 2
			     struct ike_mode *, u_int8_t, u_int8_t, char *,
			     char *, struct ike_auth *);
d334 1
a334 1
ikerule		: IKE ikemode satype proto hosts peers mainmode quickmode
d338 2
a339 2
			r = create_ike($4, &$5, &$6, $7, $8, $3, $2, $9.srcid,
			    $9.dstid, &$10);
d2229 1
a2229 1
    u_int8_t satype, u_int8_t mode, char *srcid, char *dstid,
d2286 1
@


1.100
log
@make sure, we initialize unspecified keys and spis.  Noticed by
naddy@@, ok naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.99 2006/06/07 21:57:52 hshoexer Exp $	*/
d499 10
@


1.99
log
@Do not yet expand the "any" keyword to v6 addresses.  ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.98 2006/06/07 21:49:46 hshoexer Exp $	*/
d561 3
a563 1
			}
d724 2
a725 1
			}
@


1.98
log
@remove unused prototype, ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.97 2006/06/02 15:43:37 naddy Exp $	*/
a498 10

			ipa->next = calloc(1, sizeof(struct ipsec_addr_wrap));
			if (ipa->next == NULL)
				err(1, "host: calloc");

			ipa->next->af = AF_INET6;
			ipa->next->netaddress = 1;
			if ((ipa->next->name = strdup("::/0")) == NULL)
				err(1, "host: strdup");

@


1.97
log
@support tcp/udp port modifiers in ike rules
"put it in if it doesn't break regress" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.96 2006/06/02 05:59:31 hshoexer Exp $	*/
a159 2
int			 validate_af(struct ipsec_addr_wrap *,
				struct ipsec_addr_wrap *);
@


1.96
log
@allow to specify phase 1 and 2 lifetimes.  Right now, these values
can only be set globally (ie. Default-phase-[12]-lifetime).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.95 2006/06/02 05:57:05 hshoexer Exp $	*/
d2241 1
d2243 21
@


1.95
log
@simplify handling of peers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.94 2006/06/02 05:01:27 hshoexer Exp $	*/
d151 1
d659 1
d678 1
d690 2
d1704 16
d1817 2
d2264 1
a2264 1
	if (mainmode)
d2266 3
a2268 1
	if (quickmode)
d2270 2
@


1.94
log
@some more cleanup and simplification, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.93 2006/06/02 04:51:55 hshoexer Exp $	*/
d176 3
a178 3
			     struct ipsec_addr_wrap *, struct ipsec_addr_wrap *,
			     struct ike_mode *, struct ike_mode *, u_int8_t,
			     u_int8_t, char *, char *, struct ike_auth *);
d339 2
a340 2
			r = create_ike($4, &$5, $6.src, $6.dst,
			    $7, $8, $3, $2, $9.srcid, $9.dstid, &$10);
d2203 1
a2203 3
create_ike(u_int8_t proto,
    struct ipsec_hosts *hosts,
    struct ipsec_addr_wrap *local, struct ipsec_addr_wrap *peer,
d2220 1
a2220 1
	if (peer == NULL) {
d2234 1
a2234 1
		r->peer = peer;
d2236 2
a2237 2
	if (local)
		r->local = local;
@


1.93
log
@put src and dst host in dedicated structure.  Make the API more
compact which will soon simplify my life.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.92 2006/06/02 03:40:26 hshoexer Exp $	*/
d170 2
a171 2
			     struct ipsec_addr_wrap *, struct ipsec_addr_wrap *,
			     u_int8_t, char *, char *, u_int8_t);
d194 1
a194 4
		struct {
			struct ipsec_addr_wrap *peer;
			struct ipsec_addr_wrap *local;
		} peers;
d325 2
a326 2
			r = create_flow($3, $4, &$5, $6.local, $6.peer, $2,
			    $7.srcid, $7.dstid, $8);
d339 1
a339 1
			r = create_ike($4, &$5, $6.local, $6.peer,
d422 2
a423 2
			$$.peer = NULL;
			$$.local = NULL;
d426 2
a427 2
			$$.peer = $2;
			$$.local = $4;
d430 2
a431 2
			$$.peer = $4;
			$$.local = $2;
d434 2
a435 2
			$$.peer = $2;
			$$.local = NULL;
d438 2
a439 2
			$$.peer = NULL;
			$$.local = $2;
d2027 1
a2027 1
    struct ipsec_addr_wrap *local, struct ipsec_addr_wrap *peer,
d2061 2
a2062 2
	r->local = local;
	if (peer == NULL) {
d2078 1
a2078 1
		r->peer = peer;
@


1.92
log
@Simplify main/quick mode parsing and generation of the actual ike config.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.91 2006/06/02 03:31:20 hshoexer Exp $	*/
d161 3
a163 4
struct ipsec_rule	*create_sa(u_int8_t, u_int8_t, struct ipsec_addr_wrap *,
			     struct ipsec_addr_wrap *, u_int32_t,
			     struct ipsec_transforms *, struct ipsec_key *,
			     struct ipsec_key *);
d169 1
a169 3
struct ipsec_rule	*create_flow(u_int8_t, u_int8_t,
			     struct ipsec_addr_wrap *, u_int16_t,
			     struct ipsec_addr_wrap *, u_int16_t,
d175 4
a178 6
struct ipsec_rule	*create_ike(u_int8_t, struct ipsec_addr_wrap *, struct
			     ipsec_addr_wrap *, struct ipsec_addr_wrap *,
			     struct ipsec_addr_wrap *,
			     struct ipsec_transforms *, struct
			     ipsec_transforms *, u_int8_t, u_int8_t, char *,
			     char *, struct ike_auth *);
a191 6
		struct {
			struct ipsec_addr_wrap *src;
			struct ipsec_addr_wrap *dst;
			u_int16_t	sport;
			u_int16_t	dport;
		} hosts;
d193 1
d299 2
a300 2
			r = create_sa(IPSEC_TCPMD5, IPSEC_TRANSPORT, $2.src,
			    $2.dst, $3.spiout, NULL, $4.keyout, NULL);
d314 2
a315 2
			r = create_sa($1, $2, $3.src, $3.dst, $4.spiout, $5,
			    $6.keyout, $7.keyout);
d328 2
a329 3
			r = create_flow($3, $4, $5.src, $5.sport, $5.dst,
			    $5.dport, $6.local, $6.peer, $2, $7.srcid,
			    $7.dstid, $8);
d342 2
a343 2
			r = create_ike($4, $5.src, $5.dst, $6.local, $6.peer,
			    $7->xfs, $8->xfs, $3, $2, $9.srcid, $9.dstid, &$10);
d1952 3
a1954 3
create_sa(u_int8_t satype, u_int8_t tmode, struct ipsec_addr_wrap *src, struct
    ipsec_addr_wrap *dst, u_int32_t spi, struct ipsec_transforms *xfs,
    struct ipsec_key *authkey, struct ipsec_key *enckey)
d1968 2
a1969 2
	r->src = src;
	r->dst = dst;
d2029 1
a2029 2
create_flow(u_int8_t dir, u_int8_t proto, struct ipsec_addr_wrap *src,
    u_int16_t sport, struct ipsec_addr_wrap *dst, u_int16_t dport,
d2048 5
a2052 5
	r->src = src;
	r->sport = sport;
	r->dst = dst;
	r->dport = dport;
	if ((sport != 0 || dport != 0) &&
d2098 2
a2099 2
	free(src);
	free(dst);
d2206 4
a2209 3
create_ike(u_int8_t proto, struct ipsec_addr_wrap *src, struct ipsec_addr_wrap
    *dst, struct ipsec_addr_wrap *local, struct ipsec_addr_wrap *peer,
    struct ipsec_transforms *mmxfs, struct ipsec_transforms *qmxfs,
d2222 2
a2223 2
	r->src = src;
	r->dst = dst;
d2246 4
a2249 2
	r->mmxfs = mmxfs;
	r->qmxfs = qmxfs;
@


1.91
log
@Generalize parsing of main/quick mode specification.  Preparation
for lifetime support.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2006/06/02 00:33:47 hshoexer Exp $	*/
a659 1
			struct ipsec_transforms	*xfs;
a663 5
			/* And an empty transform */
			if ((xfs = calloc(1, sizeof(struct ipsec_transforms)))
			    == NULL)
				err(1, "mainmode: calloc");
			mm->xfs = xfs;
a677 1
			struct ipsec_transforms	*xfs;
a681 5
			/* And an empty transform */
			if ((xfs = calloc(1, sizeof(struct ipsec_transforms)))
			    == NULL)
				err(1, "mainmode: calloc");
			qm->xfs = xfs;
@


1.90
log
@Prepare for parsing lifetimes for ike main and quick mode.  Not enabled yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2006/06/01 22:44:03 hshoexer Exp $	*/
a233 2
		struct ipsec_transforms *mmxfs;
		struct ipsec_transforms *qmxfs;
d235 2
a265 2
%type	<v.mmxfs>		mmxfs
%type	<v.qmxfs>		qmxfs
d270 2
d349 1
a349 1
ikerule		: IKE ikemode satype proto hosts peers mmxfs life qmxfs life
d354 1
a354 1
			    $7, $9, $3, $2, $11.srcid, $11.dstid, &$12);
d658 8
a665 4
mmxfs		: /* empty */			{
			struct ipsec_transforms *xfs;

			/* We create just an empty transform */
d668 11
a678 2
				err(1, "mmxfs: calloc");
			$$ = xfs;
a679 1
		| MAIN transforms		{ $$ = $2; }
d682 3
a684 2
qmxfs		: /* empty */			{
			struct ipsec_transforms *xfs;
d686 4
a689 1
			/* We create just an empty transform */
d692 11
a702 2
				err(1, "qmxfs: calloc");
			$$ = xfs;
a703 1
		| QUICK transforms		{ $$ = $2; }
@


1.89
log
@Final bits for SA grouping.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2006/06/01 17:32:20 naddy Exp $	*/
d149 1
d236 1
d245 1
a245 1
%token	ACTIVE ANY IPIP IPCOMP COMPXF TUNNEL TRANSPORT DYNAMIC
d271 1
d349 2
a350 1
ikerule		: IKE ikemode satype proto hosts peers mmxfs qmxfs ids ikeauth {
d354 1
a354 1
			    $7, $8, $3, $2, $9.srcid, $9.dstid, &$10);
d682 19
d850 1
d1669 14
@


1.88
log
@Support flows with port modifiers for proto tcp/udp, e.g.
flow proto udp from 1.2.3.4 port ntp to 5.6.7.8

ok hshoexer@@ msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2006/06/01 15:33:08 markus Exp $	*/
d166 3
d175 1
a175 1
			     struct ipsec_key *, struct ipsec_key *);
d183 1
d312 1
a312 1
			if (expand_rule(r, 0, $3.spiin, $4.keyin, NULL))
d327 1
a327 1
			if (expand_rule(r, 0, $4.spiin, $6.keyin, $7.keyin))
d341 1
a341 1
			if (expand_rule(r, $3, 0, NULL, NULL))
d355 1
a355 1
			if (expand_rule(r, 0, 0, NULL, NULL))
d1880 32
d1967 23
d2068 1
a2068 1
    struct ipsec_key *authkey, struct ipsec_key *enckey)
d2086 2
d2098 2
d2108 2
@


1.87
log
@print actual key size when warning about the wrong key size; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2006/06/01 06:50:58 deraadt Exp $	*/
d166 3
a168 2
struct ipsec_rule	*create_flow(u_int8_t, u_int8_t, struct
			     ipsec_addr_wrap *, struct ipsec_addr_wrap *,
d195 2
d198 1
d240 1
a240 1
%token	TYPE DENY BYPASS LOCAL PROTO USE ACQUIRE REQUIRE DONTACQ GROUP
d249 1
d331 3
a333 2
			r = create_flow($3, $4, $5.src, $5.dst, $6.local,
			    $6.peer, $2, $7.srcid, $7.dstid, $8);
d392 1
a392 1
hosts		: FROM host TO host		{
d394 9
a402 1
			$$.dst = $4;
d404 20
a423 3
		| TO host FROM host		{
			$$.src = $4;
			$$.dst = $2;
d828 1
d1765 2
d1932 3
a1934 3
    struct ipsec_addr_wrap *dst, struct ipsec_addr_wrap *local,
    struct ipsec_addr_wrap *peer, u_int8_t satype, char *srcid, char *dstid,
    u_int8_t type)
d1952 1
d1954 6
d2076 2
@


1.86
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2006/06/01 05:55:04 hshoexer Exp $	*/
d1825 3
a1827 2
				yyerror("encryption key too short, "
				    "minimum %d bits", xfs->encxf->keymin * 8);
d1831 3
a1833 2
				yyerror("encryption key too long, "
				    "maximum %d bits", xfs->encxf->keymax * 8);
@


1.85
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2006/06/01 05:48:31 todd Exp $	*/
d1254 1
a1254 1
	char 			 hbuf[NI_MAXHOST];
@


1.84
log
@add more v6 support, this round `any' expands additionally to ::/0
skip link-locals for now, to be handled separately later
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2006/06/01 02:20:44 hshoexer Exp $	*/
d1555 1
a1555 1
					sizeof(tmp16));
@


1.83
log
@When no peer is specified, make this rule a "catch-all" rule for any remote
peer.  Similar to isakmpd(8)s "Default=" tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.82 2006/05/31 14:38:31 hshoexer Exp $	*/
d475 10
d1529 1
a1529 1
		if (p->af != AF_INET)
d1539 26
a1564 1
		set_ipmask(n, 32);
@


1.82
log
@white spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.81 2006/05/31 09:03:43 todd Exp $	*/
d2044 4
a2047 5
			if (r->src->netaddress) {
				yyerror("no peer specified");
				goto errout;
			}
			r->peer = copyhost(r->src);
d2049 4
a2052 5
			if (r->dst->netaddress) {
				yyerror("no peer specified");
				goto errout;
			}
			r->peer = copyhost(r->dst);
a2076 13

errout:
	free(r);
	if (srcid)
		free(srcid);
	if (dstid)
		free(dstid);
	free(src);
	free(dst);
	if (authtype->string)
		free(authtype->string);

	return (NULL);
@


1.81
log
@add basic
- IPv6 parsing for only v6 host addresses
- checks for dst <-> src address family sanity
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2006/05/29 20:12:14 hshoexer Exp $	*/
d1263 2
a1264 2
    	    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr.s6_addr,
    	    sizeof(struct in6_addr));
@


1.80
log
@enable lists.

This allows rules like:

	ike from em0 to { 192.168.7.0/24, 192.168.9.0/24 } peer 1.2.3.4

This will setup two tunnels to the networks 192.168.7.0/24 and
192.168.9.0/24.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2006/05/29 18:50:27 hshoexer Exp $	*/
d139 1
d158 2
d1202 1
a1202 1
		if (errno == ERANGE || !q || *q || mask > 32 || q == (p + 1))
a1222 1
#if notyet
d1224 1
a1224 1
	if (cont && (ipa = host_v6(s, v6mask)) != NULL)
a1225 1
#endif
d1240 50
d1935 1
d1939 2
d1969 1
d1972 2
@


1.79
log
@Provide functions for copying members of rules.  Implement copyrule()
function to copy a single rule.  Use that for rule expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2006/05/29 16:04:25 hshoexer Exp $	*/
d244 1
a244 1
%type	<v.host>		host
d287 4
d426 14
d474 1
@


1.78
log
@unify code a little bit (consistent variable names).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2006/05/29 15:59:49 hshoexer Exp $	*/
a146 1
struct ipsec_addr_wrap	*copyhost(const struct ipsec_addr_wrap *);
d149 5
a1492 17
struct ipsec_addr_wrap *
copyhost(const struct ipsec_addr_wrap *src)
{
	struct ipsec_addr_wrap *dst;

	dst = calloc(1, sizeof(struct ipsec_addr_wrap));
	if (dst == NULL)
		err(1, "copyhost: calloc");

	memcpy(dst, src, sizeof(struct ipsec_addr_wrap));

	if ((dst->name = strdup(src->name)) == NULL)
		err(1, "copyhost: strdup");

	return dst;
}

d1522 113
d1863 2
a1864 2
	struct ipsec_rule	*r;
	struct ipsec_addr_wrap	*src, *dst, *tsrc, *tdst;
d1866 3
a1868 2
	src = rule->src;
	dst = rule->dst;
d1870 2
a1871 2
	for (tsrc = src; tsrc; tsrc = tsrc->next) {
		rule->src = tsrc;
d1873 2
a1874 5
		for (tdst = dst; tdst; tdst = tdst->next) {
			rule->dst = tdst;

			rule->nr = ipsec->rule_nr++;
			if (ipsecctl_add_rule(ipsec, rule))
d1879 2
a1880 2
				r = reverse_rule(rule);
				if (r == NULL)
d1883 2
a1884 2
				r->nr = ipsec->rule_nr++;
				if (ipsecctl_add_rule(ipsec, r))
d1888 2
a1889 2
				r = reverse_sa(rule, spi, authkey, enckey);
				if (r == NULL)
d1892 2
a1893 2
				r->nr = ipsec->rule_nr++;
				if (ipsecctl_add_rule(ipsec, r))
d1898 1
@


1.77
log
@Also return proper list of addresses for interface groups.

As usual, this and the previous commit reused suitable code from
the tree (pfctl).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2006/05/29 15:48:46 hshoexer Exp $	*/
d1436 1
a1436 1
	struct ipsec_addr_wrap	*ipa = NULL, *p = NULL, *h = NULL;
d1441 2
a1442 2
	if ((ipa = ifa_grouplookup(ifa_name)) != NULL)
		return (ipa);
d1449 2
a1450 2
		ipa = calloc(1, sizeof(struct ipsec_addr_wrap));
		if (ipa == NULL)
d1452 2
a1453 2
		memcpy(ipa, p, sizeof(struct ipsec_addr_wrap));
		if ((ipa->name = strdup(p->name)) == NULL)
d1455 1
a1455 1
		set_ipmask(ipa, 32);
d1457 2
a1458 2
		ipa->next = NULL;
		ipa->tail = ipa;
d1460 1
a1460 1
			h = ipa;
d1462 2
a1463 2
			h->tail->next = ipa;
			h->tail = ipa;
@


1.76
log
@As the rule expansion is now aware of host lists, host_if() has to
return a proper list of addresses bound to an interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2006/05/29 15:22:40 hshoexer Exp $	*/
d1396 1
a1396 1
	struct ipsec_addr_wrap	*ipa = NULL;
d1416 10
a1425 2
		if ((ipa = ifa_lookup(ifg->ifgrq_member)) != NULL)
			break;
d1430 1
a1430 1
	return (ipa);
@


1.75
log
@teach expand_rule() to iterate over host lists, not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2006/05/29 15:18:17 hshoexer Exp $	*/
d1428 1
a1428 1
	struct ipsec_addr_wrap	*ipa = NULL, *p = NULL;
d1448 9
a1456 1
		break;
d1459 1
a1459 1
	return (ipa);
@


1.74
log
@fix rule numbering (for -vv)
late ikerule also use expand_rule
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2006/05/29 04:18:16 hshoexer Exp $	*/
d1748 1
d1750 2
a1751 3
	rule->nr = ipsec->rule_nr++;
	if (ipsecctl_add_rule(ipsec, rule))
		return (1);
d1753 2
a1754 5
	if (direction == IPSEC_INOUT) {
		/* Create and add reverse flow rule. */
		r = reverse_rule(rule);
		if (r == NULL)
			return (1);
d1756 27
a1782 12
		r->nr = ipsec->rule_nr++;
		if (ipsecctl_add_rule(ipsec, r))
			return (1);
	} else if (spi != 0 || authkey || enckey) {
		/* Create and add reverse sa rule. */
		r = reverse_sa(rule, spi, authkey, enckey);
		if (r == NULL)
			return (1);

		r->nr = ipsec->rule_nr++;
		if (ipsecctl_add_rule(ipsec, r))
			return (1);
@


1.73
log
@merge expand_sa() and expand_rule().
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2006/05/29 03:53:04 hshoexer Exp $	*/
a318 1
			r->nr = ipsec->rule_nr++;
d334 2
a335 2
			if (ipsecctl_add_rule(ipsec, r))
				errx(1, "ikerule: ipsecctl_add_rule");
d1749 1
d1756 3
a1759 1

d1767 1
a1768 1

a1771 1

@


1.72
log
@move generation of reverse flow rules to seperat function.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2006/05/29 03:38:28 hshoexer Exp $	*/
a156 2
int			 expand_sa(struct ipsec_rule *, u_int32_t,
			     struct ipsec_key *, struct ipsec_key *);
d163 2
a164 1
int			 expand_rule(struct ipsec_rule *, u_int8_t);
d292 2
a293 2
			if (expand_sa(r, $3.spiin, $4.keyin, NULL))
				errx(1, "tcpmd5rule: expand_sa");
d307 2
a308 2
			if (expand_sa(r, $4.spiin, $6.keyin, $7.keyin))
				errx(1, "sarule: expand_sa");
d321 1
a321 1
			if (expand_rule(r, $3))
a1646 21
int
expand_sa(struct ipsec_rule *rule, u_int32_t spi, struct ipsec_key *authkey,
    struct ipsec_key *enckey)
{
	struct ipsec_rule	*r;

	if (ipsecctl_add_rule(ipsec, rule))
		return (1);
	if (spi != 0 || authkey || enckey) {
		r = reverse_sa(rule, spi, authkey, enckey);
		if (r == NULL)
			return (1);
		r->nr = ipsec->rule_nr++;

		if (ipsecctl_add_rule(ipsec, r))
			return (1);
	}

	return (0);
}

d1745 2
a1746 1
expand_rule(struct ipsec_rule *rule, u_int8_t direction)
a1752 1
	/* Create and add reverse flow rule. */
d1754 1
d1756 9
@


1.71
log
@unify expansion of SA rules.  Needed for general rule expansion.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2006/05/28 21:24:09 hshoexer Exp $	*/
d165 1
d322 2
a323 11
			if (ipsecctl_add_rule(ipsec, r))
				errx(1, "flowrule: ipsecctl_add_rule");

			/* Create and add reverse flow rule. */
			if ($3 == IPSEC_INOUT) {
				r = reverse_rule(r);
				r->nr = ipsec->rule_nr++;

				if (ipsecctl_add_rule(ipsec, r))
					errx(1, "flowrule: ipsecctl_add_rule");
			}
d1764 20
@


1.70
log
@when parsing host specifications, initialize host address queue pointers, not
used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2006/05/28 21:10:10 hshoexer Exp $	*/
d157 2
d292 2
a293 14
			if (ipsecctl_add_rule(ipsec, r))
				errx(1, "tcpmd5rule: ipsecctl_add_rule");

			/* Create and add reverse SA rule. */
			if ($3.spiin != 0 || $4.keyin != NULL) {
				r = reverse_sa(r, $3.spiin, $4.keyin, NULL);
				if (r == NULL)
					YYERROR;
				r->nr = ipsec->rule_nr++;

				if (ipsecctl_add_rule(ipsec, r))
					errx(1, "tcpmd5rule: "
					    "ipsecctl_add_rule");
			}
d307 2
a308 14
			if (ipsecctl_add_rule(ipsec, r))
				errx(1, "sarule: ipsecctl_add_rule");

			/* Create and add reverse SA rule. */
			if ($4.spiin != 0 || $6.keyin || $7.keyin) {
				r = reverse_sa(r, $4.spiin, $6.keyin,
				    $7.keyin);
				if (r == NULL)
					YYERROR;
				r->nr = ipsec->rule_nr++;

				if (ipsecctl_add_rule(ipsec, r))
					errx(1, "sarule: ipsecctl_add_rule");
			}
d1654 21
@


1.69
log
@prepare for rule expansion.  Get rid of addr_node, link struct
ipsec_addr_wrap directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2006/05/28 01:36:06 todd Exp $	*/
d1272 2
d1310 2
@


1.68
log
@add ERANGE error detection, found when looking at bgpd's parse.y
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.67 2006/05/27 17:21:40 hshoexer Exp $	*/
d1332 1
a1332 1
struct addr_node	*iftab;
d1338 1
a1338 1
	struct addr_node	*n = NULL, *h = NULL;
d1348 1
a1348 1
		n = calloc(1, sizeof(struct addr_node));
d1352 1
a1352 1
		if ((n->addr.name = strdup(ifa->ifa_name)) == NULL)
d1355 2
a1356 2
			n->addr.af = AF_INET;
			memcpy(&n->addr.address.v4, &((struct sockaddr_in *)
d1359 1
a1359 1
			memcpy(&n->addr.mask.v4, &((struct sockaddr_in *)
d1363 2
a1364 2
			n->addr.af = AF_INET6;
			memcpy(&n->addr.address.v6, &((struct sockaddr_in6 *)
d1367 1
a1367 1
			memcpy(&n->addr.mask.v6, &((struct sockaddr_in6 *)
d1371 1
a1371 1
		if ((n->addr.name = strdup(ifa->ifa_name)) == NULL)
d1390 1
a1390 1
	struct addr_node	*n;
d1409 1
a1409 1
		if (n->af == AF_LINK && !strncmp(n->addr.name, ifa_name,
d1456 1
a1456 2
	struct addr_node	*p = NULL;
	struct ipsec_addr_wrap	*ipa = NULL;
d1467 1
a1467 1
		if (strncmp(p->addr.name, ifa_name, IFNAMSIZ))
d1472 2
a1473 2
		memcpy(ipa, &p->addr, sizeof(struct ipsec_addr_wrap));
		if ((ipa->name = strdup(p->addr.name)) == NULL)
@


1.67
log
@allow to specify groups to be used IKE
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2006/05/26 01:06:11 deraadt Exp $	*/
d1206 1
d1208 1
a1208 1
		if (!q || *q || mask > 32 || q == (p + 1))
@


1.66
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2006/05/15 08:39:51 deraadt Exp $	*/
d91 21
d227 1
a227 1
%token	TYPE DENY BYPASS LOCAL PROTO USE ACQUIRE REQUIRE DONTACQ
d603 10
d783 1
@


1.65
log
@permit proto 0; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2006/05/11 20:40:12 hshoexer Exp $	*/
d820 1
a820 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
@


1.64
log
@fix some spelling; noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2006/04/20 09:03:23 hshoexer Exp $	*/
d367 1
a367 1
				proto = strtonum($2, 1, 255, &errstr);
d540 1
a540 1
		    transforms_l			
d1203 1
a1203 1
	
d1253 2
a1254 2
	struct addrinfo	 	 hints, *res0, *res;
	int		 	 error;
d1432 1
a1432 1
		return (ipa);	
@


1.63
log
@constify char *infile here, too.  noticed by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2006/04/19 17:28:28 hshoexer Exp $	*/
d1562 1
a1562 1
			yyerror("no encryption or authenticaion with ipcomp");
d1574 1
a1574 1
			yyerror("no encryption, authenticaion or compression"
@


1.62
log
@add support for interface groups.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2006/04/19 17:19:45 hshoexer Exp $	*/
d712 1
a712 1
	extern char	*infile;
@


1.61
log
@small cleanup:  no need to strdup here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2006/04/19 16:10:50 hshoexer Exp $	*/
d124 1
d1360 2
d1366 11
d1387 36
d1430 3
@


1.60
log
@"type" keyword to specify flow type (require, use, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2006/04/19 15:49:49 hshoexer Exp $	*/
a1290 1
	char			*ps;
d1292 2
a1293 2
	if ((ps = strdup(s)) == NULL)
		err(1, "host_if: strdup");
a1294 4
	if (ifa_exists(ps))
		ipa = ifa_lookup(ps);

	free(ps);
@


1.59
log
@add hostname resolver.

at least some eyeballing by cloder@@
tested by jean raby, requested/suggested by rod withworth
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2006/04/13 11:55:07 hshoexer Exp $	*/
d205 1
a205 1
%token	TYPE DENY BYPASS LOCAL PROTO
d325 1
a325 1
			if ($8 == TYPE_UNKNOWN && $3 == IPSEC_INOUT) {
d483 10
a492 1
			$$ = TYPE_UNKNOWN;
d500 3
d733 1
d742 1
d763 1
d772 1
d1647 1
a1647 1
	if (type != TYPE_UNKNOWN) {
d1652 1
a1652 5
	if (r->direction == IPSEC_IN)
		r->flowtype = TYPE_USE;
	else
		r->flowtype = TYPE_REQUIRE;

d1704 2
a1705 1
	if (rule->direction == (u_int8_t)IPSEC_OUT) {
d1707 1
a1707 2
		reverse->flowtype = TYPE_USE;
	} else {
a1708 2
		reverse->flowtype = TYPE_REQUIRE;
	}
d1710 1
d1715 2
a1716 1
	reverse->peer = copyhost(rule->peer);
d1720 13
a1732 11
	reverse->auth = calloc(1, sizeof(struct ipsec_auth));
	if (reverse->auth == NULL)
		err(1, "reverse_rule: calloc");
	if (rule->auth->dstid && (reverse->auth->dstid =
	    strdup(rule->auth->dstid)) == NULL)
		err(1, "reverse_rule: strdup");
	if (rule->auth->srcid && (reverse->auth->srcid =
	    strdup(rule->auth->srcid)) == NULL)
		err(1, "reverse_rule: strdup");
	reverse->auth->idtype = rule->auth->idtype;
	reverse->auth->type = rule->auth->type;
@


1.58
log
@Add support for "local" to ike rules.  Allows to specify the local IP to be
used on a multi-homed machine.  Also, relax order of peer/local keywords.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2006/03/31 14:02:08 markus Exp $	*/
d40 1
d119 1
d1178 1
a1178 1
	if (cont && (ipa = host_v4(s, mask)) != NULL)
d1183 1
a1183 1
	if (cont && (ipa = host_dns(ps, v4mask, 0)) != NULL)
d1186 4
d1228 39
@


1.57
log
@allow specification of encapsulated protocol for ike; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2006/03/31 13:13:51 markus Exp $	*/
d135 2
a136 1
struct ipsec_rule	*create_flow(u_int8_t, u_int8_t, struct ipsec_addr_wrap *,
d138 1
a138 2
			     struct ipsec_addr_wrap *, u_int8_t, char *, char *,
			     u_int8_t);
d142 1
d162 5
a166 2
		struct ipsec_addr_wrap *local;
		struct ipsec_addr_wrap *peer;
d212 2
a213 2
%type	<v.local>		local
%type	<v.peer>		peer
d310 1
a310 1
flowrule	: FLOW satype dir proto hosts local peer ids type {
d313 2
a314 2
			r = create_flow($3, $4, $5.src, $5.dst, $6, $7, $2,
			    $8.srcid, $8.dstid, $9);
d323 1
a323 1
			if ($9 == TYPE_UNKNOWN && $3 == IPSEC_INOUT) {
d333 1
a333 1
ikerule		: IKE ikemode satype proto hosts peer mmxfs qmxfs ids ikeauth {
d336 2
a337 2
			r = create_ike($4, $5.src, $5.dst, $6, $7, $8, $3, $2,
			    $9.srcid, $9.dstid, &$10);
d393 19
a411 8
peer		: /* empty */			{ $$ = NULL; }
		| PEER STRING			{
			if (($$ = host($2)) == NULL) {
				free($2);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($2);
d415 4
a418 4
local		: /* empty */			{ $$ = NULL; }
		| LOCAL STRING			{
			if (($$ = host($2)) == NULL) {
				free($2);
d422 1
a422 1
			free($2);
d525 2
a526 1
		    transforms_l			{ $$ = ipsec_transforms; }
d1680 4
a1683 3
    *dst, struct ipsec_addr_wrap * peer, struct ipsec_transforms *mmxfs, struct
    ipsec_transforms *qmxfs, u_int8_t satype, u_int8_t mode, char *srcid, char
    *dstid, struct ike_auth *authtype)
d1714 3
@


1.56
log
@allow specification of encapsulated protocol for flows; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2006/03/30 15:30:18 hshoexer Exp $	*/
d140 1
a140 1
struct ipsec_rule	*create_ike(struct ipsec_addr_wrap *, struct
d329 1
a329 1
ikerule		: IKE ikemode satype hosts peer mmxfs qmxfs ids ikeauth {
d332 2
a333 2
			r = create_ike($4.src, $4.dst, $5, $6, $7, $3, $2,
			    $8.srcid, $8.dstid, &$9);
d1663 2
a1664 2
create_ike(struct ipsec_addr_wrap *src, struct ipsec_addr_wrap *dst, struct
    ipsec_addr_wrap * peer, struct ipsec_transforms *mmxfs, struct
d1676 1
@


1.55
log
@when resolving interface names to ip adresses, set netmask to all bits 1
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2006/03/30 12:44:20 markus Exp $	*/
d45 1
d135 3
a137 3
struct ipsec_rule	*create_flow(u_int8_t, struct ipsec_addr_wrap *, struct
			     ipsec_addr_wrap *, struct ipsec_addr_wrap *, struct
			     ipsec_addr_wrap *, u_int8_t, char *, char *,
d153 2
a154 1
		u_int8_t	 protocol;
d199 1
a199 1
%token	TYPE DENY BYPASS LOCAL
d203 2
a204 1
%type	<v.protocol>		protocol
d279 1
a279 1
sarule		: protocol tmode hosts spispec transforms authkeyspec
d306 1
a306 1
flowrule	: FLOW protocol dir hosts local peer ids type {
d309 2
a310 2
			r = create_flow($3, $4.src, $4.dst, $5, $6, $2,
			    $7.srcid, $7.dstid, $8);
d319 1
a319 1
			if ($8 == TYPE_UNKNOWN && $3 == IPSEC_INOUT) {
d329 1
a329 1
ikerule		: IKE ikemode protocol hosts peer mmxfs qmxfs ids ikeauth {
d343 1
a343 1
protocol	: /* empty */			{ $$ = IPSEC_ESP; }
d350 19
d728 1
d1393 1
a1393 1
validate_sa(u_int32_t spi, u_int8_t protocol, struct ipsec_transforms *xfs,
d1401 1
a1401 1
	if (protocol == IPSEC_AH) {
d1417 1
a1417 1
	if (protocol == IPSEC_ESP) {
d1431 1
a1431 1
	if (protocol == IPSEC_IPCOMP) {
d1443 1
a1443 1
	if (protocol == IPSEC_IPIP) {
d1454 1
a1454 1
	if (protocol == IPSEC_TCPMD5 && authkey == NULL && tmode !=
d1493 1
a1493 1
create_sa(u_int8_t protocol, u_int8_t tmode, struct ipsec_addr_wrap *src, struct
d1499 1
a1499 1
	if (validate_sa(spi, protocol, xfs, authkey, enckey, tmode) == 0)
d1507 1
a1507 1
	r->proto = protocol;
d1525 1
a1525 1
	if (validate_sa(spi, rule->proto, rule->xfs, authkey, enckey,
d1534 1
a1534 1
	reverse->proto = rule->proto;
d1547 4
a1550 3
create_flow(u_int8_t dir, struct ipsec_addr_wrap *src, struct ipsec_addr_wrap
    *dst, struct ipsec_addr_wrap *local, struct ipsec_addr_wrap *peer,
    u_int8_t proto, char *srcid, char *dstid, u_int8_t type)
d1565 1
d1644 2
a1645 1
	reverse->proto = (u_int8_t)rule->proto;
d1665 1
a1665 1
    ipsec_transforms *qmxfs, u_int8_t proto, u_int8_t mode, char *srcid, char
d1697 1
a1697 1
	r->proto = proto;
@


1.54
log
@allow specification of outer local ips in flows (SADB_EXT_ADDRESS_SRC); ok hshoexer, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2006/03/22 16:01:23 reyk Exp $	*/
d1297 1
@


1.53
log
@add support for macros in ipsec.conf(5). some bits have already been
there.

requested by david@@
ok hshoexer@@, msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2006/03/07 00:30:28 reyk Exp $	*/
d135 3
a137 2
			     ipsec_addr_wrap *, struct ipsec_addr_wrap *,
			     u_int8_t, char *, char *, u_int8_t);
d159 1
d197 1
a197 1
%token	TYPE DENY BYPASS
d205 1
d303 1
a303 1
flowrule	: FLOW protocol dir hosts peer ids type {
d306 2
a307 2
			r = create_flow($3, $4.src, $4.dst, $5, $2, $6.srcid,
			    $6.dstid, $7);
d316 1
a316 1
			if ($7 == TYPE_UNKNOWN && $3 == IPSEC_INOUT) {
d378 11
d701 1
d1524 2
a1525 2
    *dst, struct ipsec_addr_wrap *peer, u_int8_t proto, char *srcid, char
    *dstid, u_int8_t type)
d1554 1
d1615 2
@


1.52
log
@add support for special "bypass" and "deny" flows.

ok hshoexer@@, thanks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2006/03/07 00:19:58 reyk Exp $	*/
d197 1
d225 1
d613 21
d919 3
@


1.51
log
@add an ike option for road warrior setups (hosts with dynamic ip
addresses).

"ike dynamic esp" will use the system's hostname as the fqdn source id
(instead of the ip address) by default and enable dpd (dead peer
detection) to allow smooth reconnects after an ip address change (i.e.
forced reconnect with consumer adsl lines).

ok hshoexer@@, looks fine markus@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2006/01/20 16:11:22 naddy Exp $	*/
d136 1
a136 1
			     u_int8_t, char *, char *);
d165 1
d195 1
d215 1
d298 1
a298 1
flowrule	: FLOW protocol dir hosts peer ids {
d302 1
a302 1
			    $6.dstid);
d311 1
a311 1
			if ($3 == IPSEC_INOUT) {
d427 11
d649 1
d651 1
d677 1
d1484 1
a1484 1
    *dstid)
d1499 9
a1512 3
	r->src = src;
	r->dst = dst;

a1530 1
	r->proto = proto;
@


1.50
log
@initialize authtype->string in case of RSA to avoid bad free()
ok reyk@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2006/01/17 05:39:23 reyk Exp $	*/
d193 1
a193 1
%token	ACTIVE ANY IPIP IPCOMP COMPXF TUNNEL TRANSPORT
d578 1
d637 1
@


1.49
log
@wrap long lines (no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2006/01/16 23:57:20 reyk Exp $	*/
d581 8
a588 2
ikeauth		: /* empty */			{ $$.type = IKE_AUTH_RSA; }
		| RSA				{ $$.type = IKE_AUTH_RSA; }
@


1.48
log
@add support for pre-shared keys with "ike esp" using the new keyword
"psk". rsa-sig is recommended and will still be used by default.

ok hshoexer@@, manpage ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2005/12/12 09:41:51 hshoexer Exp $	*/
d262 2
a263 1
					errx(1, "tcpmd5rule: ipsecctl_add_rule");
d474 2
a475 1
				ipsec_transforms->authxf = parse_xf($2, authxfs);
d493 2
a494 1
				ipsec_transforms->compxf = parse_xf($2, compxfs);
d1360 1
a1360 1
			   " with ipip");
d1387 2
a1388 2
				yyerror("encryption key too short, minimum %d bits",
				    xfs->encxf->keymin * 8);
d1392 2
a1393 2
				yyerror("encryption key too long, maximum %d bits",
				    xfs->encxf->keymax * 8);
@


1.47
log
@Correctly copy interface names; fixes breakage noticed by naddy@@

ok naddy@@
cvs: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2005/12/06 14:27:57 markus Exp $	*/
d136 1
a136 1
			     u_int8_t, char *, char *, u_int16_t);
d142 1
a142 1
			     char *);
d165 1
a165 1
		u_int16_t	 authtype;
a203 1
%type	<v.authtype>		authtype
d212 1
d294 1
a294 1
flowrule	: FLOW protocol dir hosts peer ids authtype	{
d298 1
a298 1
			    $6.dstid, $7);
d317 1
a317 1
ikerule		: IKE ikemode protocol hosts peer mmxfs qmxfs ids {
d321 1
a321 1
			    $8.srcid, $8.dstid);
a425 5
authtype	: /* empty */			{ $$ = 0; }
		| RSA				{ $$ = AUTH_RSA; }
		| PSK				{ $$ = AUTH_PSK; }
		;

d572 1
d577 10
d1456 1
a1456 1
    *dstid, u_int16_t authtype)
a1503 3
#ifdef notyet
	r->auth->type = authtype;
#endif
d1562 1
a1562 1
    *dstid)
d1603 5
d1619 2
@


1.46
log
@ipip support: ip-in-ip w/o gif(4); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2005/12/01 15:14:47 deraadt Exp $	*/
d1220 2
@


1.45
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2005/11/27 09:47:56 hshoexer Exp $	*/
d193 1
a193 1
%token	ACTIVE ANY IPCOMP COMPXF TUNNEL TRANSPORT
d335 1
d630 1
d1341 11
@


1.44
log
@sanity check constraints for transforms.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2005/11/27 03:50:58 deraadt Exp $	*/
d456 1
a456 1
transforms	: 					{
@


1.43
log
@truly permit auth/enc/comp expressions to be in any order
hshoexer will add back in the contraint language
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2005/11/26 23:26:49 hshoexer Exp $	*/
d1309 4
d1319 4
d1331 4
@


1.42
log
@allow specficiation of encryption and authentication algorithms to be swapped.
Ie. both "enc 3des-cbc auth hmac-sha1" and " auth hmac-sha1 enc 3des-cbc" are
valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2005/11/24 11:52:07 hshoexer Exp $	*/
a123 1
struct ipsec_transforms *transforms(const char *, const char *, const char *);
d144 2
d456 3
a458 6
transforms	: /* empty */			{
			struct ipsec_transforms *xfs;

			/* We create just an empty transform */
			if ((xfs = calloc(1, sizeof(struct ipsec_transforms)))
			    == NULL)
a459 1
			$$ = xfs;
d461 5
a465 9
		| AUTHXF STRING ENCXF STRING	{
			if (($$ = transforms($2, $4, NULL)) == NULL) {
				free($2);
				free($4);
				yyerror("could not parse transforms");
				YYERROR;
			}
			free($2);
			free($4);
d467 13
a479 6
		| ENCXF STRING AUTHXF STRING	{
			if (($$ = transforms($4, $2, NULL)) == NULL) {
				free($2);
				free($4);
				yyerror("could not parse transforms");
				YYERROR;
a480 10
			free($2);
			free($4);
		}
		| AUTHXF STRING			{
			if (($$ = transforms($2, NULL, NULL)) == NULL) {
				free($2);
				yyerror("could not parse transforms");
				YYERROR;
			}
			free($2);
d483 6
a488 4
			if (($$ = transforms(NULL, $2, NULL)) == NULL) {
				free($2);
				yyerror("could not parse transforms");
				YYERROR;
a489 1
			free($2);
d492 6
a497 4
			if (($$ = transforms(NULL, NULL, $2)) == NULL) {
				free($2);
				yyerror("could not parse transforms");
				YYERROR;
a498 1
			free($2);
a1270 28
}

struct ipsec_transforms *
transforms(const char *authname, const char *encname, const char *compname)
{
	struct ipsec_transforms *xfs;

	xfs = calloc(1, sizeof(struct ipsec_transforms));
	if (xfs == NULL)
		err(1, "transforms: calloc");

	if (authname) {
		xfs->authxf = parse_xf(authname, authxfs);
		if (xfs->authxf == NULL)
			yyerror("%s not a valid transform", authname);
	}
	if (encname) {
		xfs->encxf = parse_xf(encname, encxfs);
		if (xfs->encxf == NULL)
			yyerror("%s not a valid transform", encname);
	}
	if (compname) {
		xfs->compxf = parse_xf(compname, compxfs);
		if (xfs->compxf == NULL)
			yyerror("%s not a valid transform", compname);
	}

	return (xfs);
@


1.41
log
@Remove old-style keyed sha1/md5.  We only support hmac-sha1/md5.
Noticed the hard way by <raff at brodewicz dot pl>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2005/11/12 21:57:34 hshoexer Exp $	*/
d466 10
@


1.40
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2005/11/12 21:49:38 hshoexer Exp $	*/
a64 2
	{ "md5",		AUTHXF_MD5,		16,	0 },
	{ "sha1",		AUTHXF_SHA1,		20,	0 },
@


1.39
log
@add support for interface names as host specifications
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2005/11/12 17:22:23 deraadt Exp $	*/
d356 1
a356 1
 		;
@


1.38
log
@permit TO/FROM to be swapped (symmetry is good); ok hshoexermk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2005/11/12 17:04:32 deraadt Exp $	*/
d25 1
d29 1
d38 1
d119 4
a1054 1
#if notyet
a1057 1
#endif
d1065 1
a1065 1
	if (cont && (ipa = host_dsn(ps, v4mask, 0)) != NULL)
d1106 114
@


1.37
log
@simplify TAILQ walking code; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2005/11/12 16:41:39 deraadt Exp $	*/
d345 5
a349 1
		;
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2005/11/12 16:40:58 deraadt Exp $	*/
d838 1
a838 1
	struct sym	*sym, *next;
d848 2
a849 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
a851 1
		TAILQ_REMOVE(&symhead, sym, entries);
d871 1
a873 1
			TAILQ_REMOVE(&symhead, sym, entries);
@


1.35
log
@do not stat() before open(); instead -- use fstat(); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2005/11/12 12:00:53 hshoexer Exp $	*/
d54 11
a64 11
	{"unknown",		AUTHXF_UNKNOWN,		0,	0},
	{"none",		AUTHXF_NONE,		0,	0},
	{"hmac-md5",		AUTHXF_HMAC_MD5,	16,	0},
	{"hmac-ripemd160",	AUTHXF_HMAC_RIPEMD160,	20,	0},
	{"hmac-sha1",		AUTHXF_HMAC_SHA1,	20,	0},
	{"hmac-sha2-256",	AUTHXF_HMAC_SHA2_256,	32,	0},
	{"hmac-sha2-384",	AUTHXF_HMAC_SHA2_384,	48,	0},
	{"hmac-sha2-512",	AUTHXF_HMAC_SHA2_512,	64,	0},
	{"md5",			AUTHXF_MD5,		16,	0},
	{"sha1",		AUTHXF_SHA1,		20,	0},
	{NULL,			0,			0,	0},
d68 11
a78 11
	{"unknown",		ENCXF_UNKNOWN,		0,	0},
	{"none",		ENCXF_NONE,		0,	0},
	{"3des-cbc",		ENCXF_3DES_CBC,		24,	24},
	{"des-cbc",		ENCXF_DES_CBC,		8,	8},
	{"aes",			ENCXF_AES,		16,	32},
	{"aesctr",		ENCXF_AESCTR,		16+4,	32+4},
	{"blowfish",		ENCXF_BLOWFISH,		5,	56},
	{"cast128",		ENCXF_CAST128,		5,	16},
	{"null",		ENCXF_NULL,		0,	0},
	{"skipjack",		ENCXF_SKIPJACK,		10,	10},
	{NULL,			0,			0,	0},
d82 4
a85 4
	{"unknown",		COMPXF_UNKNOWN,		0,	0},
	{"deflate",		COMPXF_DEFLATE,		0,	0},
	{"lzs",			COMPXF_LZS,		0,	0},
	{NULL,			0,			0,	0},
d234 1
d302 1
a302 1
				r = reverse_rule(r);	
d322 2
a323 1
		};
d501 1
a501 1
		; 
d538 1
a538 1
			
d580 1
a580 1
	extern char 	*infile;
d602 29
a630 29
		{ "active",		ACTIVE},
		{ "ah",			AH},
		{ "any",		ANY},
		{ "auth",		AUTHXF},
		{ "authkey",		AUTHKEY},
		{ "comp",		COMPXF},
		{ "dstid",		DSTID},
		{ "enc",		ENCXF},
		{ "enckey",		ENCKEY},
		{ "esp",		ESP},
		{ "file",		FILENAME},
		{ "flow",		FLOW},
		{ "from",		FROM},
		{ "ike",		IKE},
		{ "in",			IN},
		{ "ipcomp",		IPCOMP},
		{ "main",		MAIN},
		{ "out",		OUT},
		{ "passive",		PASSIVE},
		{ "peer",		PEER},
		{ "psk",		PSK},
		{ "quick",		QUICK},
		{ "rsa",		RSA},
		{ "spi",		SPI},
		{ "srcid",		SRCID},
		{ "tcpmd5",		TCPMD5},
		{ "to",			TO},
		{ "transport",		TRANSPORT},
		{ "tunnel",		TUNNEL},
d1105 1
a1105 1
	struct ipsec_addr 	*ipa;
d1134 1
a1134 1
	
d1256 10
a1265 10
		if (enckey->len < xfs->encxf->keymin) {
			yyerror("encryption key too short, minimum %d bits",
			    xfs->encxf->keymin * 8);
			return (0);
		}
		if (xfs->encxf->keymax < enckey->len) {
			yyerror("encryption key too long, maximum %d bits",
			    xfs->encxf->keymax * 8);
			return (0);
		}
d1336 1
a1336 1
	
d1405 1
a1405 1
	
d1413 1
a1413 1
	
@


1.34
log
@handle transport/tunnel mode
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2005/11/06 22:51:51 hshoexer Exp $	*/
d1006 3
a1008 1
	if (stat(filename, &sb) < 0)
d1013 1
a1013 2
	if ((hex = calloc(sb.st_size, sizeof(unsigned char)))
	    == NULL)
a1014 2
	if ((fd = open(filename, O_RDONLY)) < 0)
		err(1, "parsekeyfile: open");
@


1.33
log
@Improved address and address mask handling, derived from pfctl stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2005/11/06 10:52:27 hshoexer Exp $	*/
d123 2
a124 2
			     struct ipsec_key *);
struct ipsec_rule	*create_sa(u_int8_t, struct ipsec_addr_wrap *,
d145 2
a147 1
		u_int8_t	 protocol;
d187 1
a187 1
%token	ACTIVE ANY IPCOMP COMPXF
d191 1
d238 2
a239 2
			r = create_sa(IPSEC_TCPMD5, $2.src, $2.dst, $3.spiout,
			    NULL, $4.keyout, NULL);
d260 2
a261 1
sarule		: protocol hosts spispec transforms authkeyspec enckeyspec {
d264 2
a265 2
			r = create_sa($1, $2.src, $2.dst, $3.spiout, $4,
			    $5.keyout, $6.keyout);
d274 3
a276 3
			if ($3.spiin != 0 || $5.keyin || $6.keyin) {
				r = reverse_sa(r, $3.spiin, $5.keyin,
				    $6.keyin);
d329 5
d627 2
d1196 1
a1196 1
    struct ipsec_key *authkey, struct ipsec_key *enckey)
d1233 2
a1234 1
	if (protocol == IPSEC_TCPMD5 && authkey == NULL) {
d1272 1
a1272 1
create_sa(u_int8_t protocol, struct ipsec_addr_wrap *src, struct
d1278 1
a1278 1
	if (validate_sa(spi, protocol, xfs, authkey, enckey) == 0)
d1287 1
d1304 2
a1305 1
	if (validate_sa(spi, rule->proto, rule->xfs, authkey, enckey) == 0)
d1314 1
@


1.32
log
@better handling of ip addresses, prepare for v6.  Partially derived from diff
by todd@@.  Work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2005/10/30 20:42:11 hshoexer Exp $	*/
d114 4
a117 3
struct ipsec_addr	*host(const char *);
struct ipsec_addr	*host_v4(const char *, int);
struct ipsec_addr	*copyhost(const struct ipsec_addr *);
d124 2
a125 2
struct ipsec_rule	*create_sa(u_int8_t, struct ipsec_addr *,
			     struct ipsec_addr *, u_int32_t,
d130 3
a132 3
struct ipsec_rule	*create_flow(u_int8_t, struct ipsec_addr *, struct
			     ipsec_addr *, struct ipsec_addr *, u_int8_t,
			     char *, char *, u_int16_t);
d134 5
a138 4
struct ipsec_rule	*create_ike(struct ipsec_addr *, struct ipsec_addr *,
			     struct ipsec_addr *, struct ipsec_transforms *,
			     struct ipsec_transforms *, u_int8_t, u_int8_t,
			     char *, char *);
d148 2
a149 2
			struct ipsec_addr *src;
			struct ipsec_addr *dst;
d151 2
a152 2
		struct ipsec_addr *peer;
		struct ipsec_addr *host;
d370 1
a370 1
			struct ipsec_addr	*ipa;
d372 1
a372 1
			ipa = calloc(1, sizeof(struct ipsec_addr));
d1012 1
a1012 1
struct ipsec_addr *
d1015 1
a1015 1
	struct ipsec_addr	*ipa = NULL;
d1058 1
a1058 1
struct ipsec_addr *
d1061 1
a1061 1
	struct ipsec_addr	*ipa = NULL;
d1063 1
a1063 1
	int			 i, bits = 32;
d1074 1
a1074 1
	ipa = calloc(1, sizeof(struct ipsec_addr));
d1084 2
a1085 7
	if (bits == 32) {
		ipa->mask.mask32 = 0xffffffff;
		ipa->netaddress = 0;
	} else {
		for (i = 31; i > 31 - bits; i--)
			ipa->mask.mask32 |= (1 << i);
		ipa->mask.mask32 = htonl(ipa->mask.mask32);
a1086 2
	}
	ipa->prefixlen = bits;
d1091 21
a1111 2
struct ipsec_addr *
copyhost(const struct ipsec_addr *src)
d1113 1
a1113 1
	struct ipsec_addr *dst;
d1115 1
a1115 1
	dst = calloc(1, sizeof(struct ipsec_addr));
d1119 1
a1119 1
	memcpy(dst, src, sizeof(struct ipsec_addr));
d1261 3
a1263 3
create_sa(u_int8_t protocol, struct ipsec_addr *src, struct ipsec_addr *dst,
    u_int32_t spi, struct ipsec_transforms *xfs, struct ipsec_key *authkey,
    struct ipsec_key *enckey)
d1312 3
a1314 3
create_flow(u_int8_t dir, struct ipsec_addr *src, struct ipsec_addr *dst,
    struct ipsec_addr *peer, u_int8_t proto, char *srcid, char *dstid,
    u_int16_t authtype)
d1420 4
a1423 3
create_ike(struct ipsec_addr *src, struct ipsec_addr *dst, struct ipsec_addr *
    peer, struct ipsec_transforms *mmxfs, struct ipsec_transforms *qmxfs,
    u_int8_t proto, u_int8_t mode, char *srcid, char *dstid)
@


1.31
log
@prepare for more flexible hostname resolver.  Right now just v4, more to come
(if groups, v6, dns).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2005/10/30 19:50:23 hshoexer Exp $	*/
d1076 1
a1076 1
	ipa->v4 = ina;
d1083 1
a1083 1
		ipa->v4mask.mask32 = 0xffffffff;
d1087 2
a1088 2
			ipa->v4mask.mask32 |= (1 << i);
		ipa->v4mask.mask32 = htonl(ipa->v4mask.mask32);
d1091 1
@


1.30
log
@add support for ipcomp.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2005/10/28 07:18:47 hshoexer Exp $	*/
a115 3
#if 0
struct ipsec_addr	*host_if(const char *, int);
#endif
a1016 1
	/* XXX for now only AF_INET. */
d1032 6
d1041 6
@


1.29
log
@more error message cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2005/10/16 21:41:36 hshoexer Exp $	*/
d81 7
d116 3
d121 1
a121 1
struct ipsec_transforms *transforms(const char *, const char *);
d187 1
a187 1
%token	ACTIVE ANY
a232 1
		;
d324 1
d447 1
a447 1
			if (($$ = transforms($2, $4)) == NULL) {
d457 1
a457 1
			if (($$ = transforms($2, NULL)) == NULL) {
d465 9
a473 1
			if (($$ = transforms(NULL, $2)) == NULL) {
d598 1
d608 1
d1118 1
a1118 1
transforms(const char *authname, const char *encname)
d1136 5
d1191 8
@


1.28
log
@Prepare for better host specification parser: dns names, interfaces, etc.  But
for now, just ipv4.  Derived from pfctl(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2005/10/16 21:29:22 hshoexer Exp $	*/
d365 1
a365 1
				err(1, "calloc");
d370 1
a370 1
				err(1, "strdup");
d980 1
a980 1
		errx(1, "key too %s", sb.st_size ? "large" :
d1004 1
a1004 1
			errx(1, "invalid netmask '%s'", p);
@


1.27
log
@Unset debug flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2005/10/16 21:24:45 hshoexer Exp $	*/
d108 1
d996 3
a998 2
	struct ipsec_addr	*ipa;
	int			 i, bits = 32;
d1001 26
d1028 6
a1033 3
	ipa = calloc(1, sizeof(struct ipsec_addr));
	if (ipa == NULL)
		err(1, "host: calloc");
d1035 1
a1035 3
	if ((ipa->name = strdup(s)) == NULL)
		err(1, "host: strdup");
	
d1037 2
a1038 6
		bits = inet_net_pton(AF_INET, s, &ipa->v4, sizeof(ipa->v4));
		if (bits == -1 || bits > 32) {
			free(ipa->name);
			free(ipa);
			return(NULL);
		}
d1040 1
a1040 3
		if (inet_pton(AF_INET, s, &ipa->v4) != 1) {
			free(ipa->name);
			free(ipa);
a1041 1
		}
d1044 10
a1053 1
	bzero(&ipa->v4mask, sizeof(ipa->v4mask));
a1062 2

	ipa->af = AF_INET;
@


1.26
log
@Add keyword "any" for addresses, reduces to "0.0.0.0/0".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2005/10/16 19:52:19 hshoexer Exp $	*/
d51 1
a51 1
static int		 debug = 5;
@


1.25
log
@cleanup messages generated by err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2005/08/22 17:26:46 hshoexer Exp $	*/
d51 1
a51 1
static int		 debug = 0;
d176 1
a176 1
%token	ACTIVE
d222 1
d359 13
d576 1
@


1.24
log
@Teach ipsecctl to control isakmpd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2005/08/19 08:47:56 hshoexer Exp $	*/
d418 1
a418 1
				err(1, "calloc");
d455 1
a455 1
				err(1, "calloc");
d467 1
a467 1
				err(1, "calloc");
d941 1
a941 1
		err(1, "calloc");
d946 1
a946 1
		err(1, "calloc");
d962 1
a962 1
		err(1, "stat %s", filename);
d968 1
a968 1
		err(1, "calloc");
d970 1
a970 1
		err(1, "open");
d972 1
a972 1
		err(1, "read");
d987 1
a987 1
		err(1, "calloc");
d990 1
a990 1
		err(1, "strdup");
d1030 1
a1030 1
		err(1, "calloc");
d1035 1
a1035 1
		err(1, "strdup");
d1060 1
a1060 1
		err(1, "calloc");
d1086 1
a1086 1
		err(1, "calloc");
d1172 1
a1172 1
		err(1, "calloc");
d1197 1
a1197 1
		err(1, "calloc");
d1220 1
a1220 1
		err(1, "calloc");
d1258 1
a1258 1
		err(1, "calloc");
d1287 1
a1287 1
		err(1, "calloc");
d1306 1
a1306 1
		err(1, "calloc");
d1309 1
a1309 1
		err(1, "strdup");
d1312 1
a1312 1
		err(1, "strdup");
d1328 1
a1328 1
		err(1, "calloc");
d1359 1
a1359 1
		err(1, "calloc");
@


1.23
log
@more useful error message
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2005/08/09 12:37:45 hshoexer Exp $	*/
d125 4
d133 1
a135 1
		int		 log;
d166 2
d175 2
a176 1
%token	AUTHKEY ENCKEY FILENAME AUTHXF ENCXF ERROR
d192 3
d199 1
d297 13
d415 1
d449 24
d523 4
d560 1
d571 1
d573 1
d575 1
d578 1
d988 3
d995 1
d1001 1
d1003 1
a1003 1
			return NULL;
d1020 1
a1020 1
	return ipa;
d1031 5
a1036 1
	memcpy(dst, src, sizeof(struct ipsec_addr));
d1062 1
a1062 1
	if (authname)
d1064 4
a1067 1
	if (encname)
d1069 3
d1317 59
@


1.22
log
@Rewrite handling of transforms.  Now both ah and esp can be specified and
validated correctly.  Unbreaks ah.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2005/08/09 12:35:25 hshoexer Exp $	*/
d904 1
a904 1
		err(1, "stat");
@


1.21
log
@Correct keysize for 3des-cbc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2005/08/08 13:29:00 hshoexer Exp $	*/
d110 2
d113 2
a114 2
			     const struct ipsec_xf *, const struct ipsec_xf *,
			     struct ipsec_key *, struct ipsec_key *);
d117 2
a118 2
			     const struct ipsec_xf *, const struct ipsec_xf *,
			     struct ipsec_key *, struct ipsec_key *);
d161 1
a161 4
		struct {
			const struct ipsec_xf *authxf;
			const struct ipsec_xf *encxf;
		} transforms;
d216 1
a216 1
			    NULL, NULL, $4.keyout, NULL);
d240 2
a241 2
			r = create_sa($1, $2.src, $2.dst, $3.spiout,
			    $4.authxf, $4.encxf, $5.keyout, $6.keyout);
d389 6
a394 2
			$$.authxf = &authxfs[AUTHXF_HMAC_SHA2_256];
			$$.encxf = &encxfs[ENCXF_AESCTR];
d397 4
a400 4
			$$.authxf = parse_xf($2, authxfs);
			free($2);
			if ($$.authxf == NULL) {
				yyerror("could not parse authentication xf");
d403 1
a403 1
			$$.encxf = parse_xf($4, encxfs);
a404 4
			if ($$.encxf == NULL) {
				yyerror("could not parse encryption xf");
				YYERROR;
			}
d407 3
a409 5
			$$.encxf = &encxfs[ENCXF_AESCTR];
			$$.authxf = parse_xf($2, authxfs);
			free($2);
			if ($$.authxf == NULL) {
				yyerror("could not parse authentication xf");
d412 1
d415 3
a417 5
			$$.authxf = &authxfs[AUTHXF_HMAC_SHA2_256];
			$$.encxf = parse_xf($2, encxfs);
			free($2);
			if ($$.encxf == NULL) {
				yyerror("could not parse encryption xf");
d420 1
d986 33
d1020 2
a1021 3
validate_sa(u_int32_t spi, u_int8_t protocol, const struct ipsec_xf *authxf,
    const struct ipsec_xf *encxf, struct ipsec_key *authkey,
    struct ipsec_key *enckey)
d1028 22
d1054 1
a1054 1
	if (authxf) {
d1059 1
a1059 1
		if (authkey->len != authxf->keymin) {
d1061 1
a1061 1
			    "%d bits", authxf->keymin * 8);
d1065 2
a1066 2
	if (encxf) {
		if (!enckey) {
d1070 2
a1071 1
		if (enckey->len < encxf->keymin) {
d1073 1
a1073 1
			    encxf->keymin * 8);
d1076 1
a1076 1
		if (encxf->keymax < enckey->len) {
d1078 1
a1078 1
			    encxf->keymax * 8);
d1081 1
d1089 2
a1090 2
    u_int32_t spi, const struct ipsec_xf *authxf, const struct ipsec_xf *encxf,
    struct ipsec_key *authkey, struct ipsec_key *enckey)
d1094 1
a1094 1
	if (validate_sa(spi, protocol, authxf, encxf, authkey, enckey) == 0)
d1106 1
a1106 2
	r->authxf = authxf;
	r->encxf = encxf;
d1119 1
a1119 2
	if (validate_sa(spi, rule->proto, rule->authxf, rule->encxf, authkey,
	    enckey) == 0)
d1131 1
a1131 2
	reverse->authxf = rule->authxf;
	reverse->encxf = rule->encxf;
@


1.20
log
@add crypto transforms and static keying rules
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2005/08/08 09:15:09 hshoexer Exp $	*/
d70 1
a70 1
	{"3des-cbc",		ENCXF_3DES_CBC,		8,	8},
@


1.19
log
@prepare for static keying
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2005/08/05 15:44:57 hshoexer Exp $	*/
d53 28
d109 4
d114 3
a116 2
			     struct ipsec_addr *, u_int32_t, u_int16_t,
			     u_int16_t, struct ipsec_key *, struct ipsec_key *);
d159 4
d170 1
a170 1
%token	AUTHKEY ENCKEY FILENAME ERROR
d185 1
d191 1
d217 1
a217 1
			    AUTH_NONE, ENC_NONE, $4.keyout, NULL);
d238 26
d389 38
d511 1
d514 1
d854 2
a855 1
	if (ulval >= SPI_RESERVED_MIN && ulval <= SPI_RESERVED_MAX)
d857 1
d976 58
d1036 1
a1036 1
    u_int32_t spi, u_int16_t authxf, u_int16_t encxf,
d1041 1
a1041 3
	if (spi == 0)
		return (NULL);
	if (protocol == IPSEC_TCPMD5 && authkey == NULL)
d1053 2
d1067 2
a1068 3
	if (spi == 0)
		return (NULL);
	if (rule->proto == IPSEC_TCPMD5 && authkey == NULL)
d1080 2
@


1.18
log
@more key handling stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2005/08/05 14:39:02 hshoexer Exp $	*/
d81 3
a83 3
struct ipsec_rule	*create_sa(struct ipsec_addr *, struct ipsec_addr *,
			 u_int32_t, struct ipsec_key *);

d85 1
a85 1
			     struct ipsec_key *);
d177 2
a178 1
			r = create_sa($2.src, $2.dst, $3.spiout, $4.keyout);
d188 1
a188 1
				r = reverse_sa(r, $3.spiin, $4.keyin);
d870 3
a872 2
create_sa(struct ipsec_addr *src, struct ipsec_addr *dst, u_int32_t spi,
    struct ipsec_key *authkey)
d876 3
a878 1
	if (spi == 0 || authkey == NULL)
d886 1
a886 1

d891 1
d897 2
a898 1
reverse_sa(struct ipsec_rule *rule, u_int32_t spi, struct ipsec_key *authkey)
d902 3
a904 1
	if (spi == 0 || authkey == NULL)
d912 1
d917 1
@


1.17
log
@prepare for authentication and encryption keys, not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2005/08/05 14:09:27 hshoexer Exp $	*/
d78 1
d122 4
d133 1
a133 1
%token	AUTHKEY ENCKEY KEYFILE ERROR
d147 1
d327 17
a343 1
		| AUTHKEY STRING			{
d345 1
a345 1
			unsigned char	*p = strchr($2, ':');
d355 1
a355 1
			hex = $2;
d360 1
a360 1
			free($2);
d362 2
a363 19
		| KEYFILE STRING		{
			struct stat	 sb;
			int		 fd;
			unsigned char	*hex;

			if (stat($2, &sb) < 0)
				err(1, "stat");
			if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
				errx(1, "key too %s", sb.st_size ? "large" :
				    "small");
			if ((hex = calloc(sb.st_size, sizeof(unsigned char)))
			    == NULL)
				err(1, "calloc");
			if ((fd = open($2, O_RDONLY)) < 0)
				err(1, "open");
			if (read(fd, hex, sb.st_size) < sb.st_size)
				err(1, "read");
			close(fd);
			$$.keyout = parsekey(hex, sb.st_size);
d365 5
a372 2

mode		: /* empty */			{ };
d411 1
a414 1
		{ "keyfile",		KEYFILE},
d765 1
a765 1
		return -1;
d789 23
@


1.16
log
@simplify a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2005/08/02 15:47:25 hshoexer Exp $	*/
d116 5
a120 1
		} keys;
d127 2
a128 2
%token	FLOW FROM ESP AH IN PEER ON OUT TO SRCID DSTID RSA PSK TCPMD5 SPI KEY
%token	KEYFILE ERROR
d140 2
a141 1
%type	<v.keys>		keyspec
d168 1
a168 1
tcpmd5rule	: TCPMD5 hosts spispec keyspec	{
d317 1
a317 1
keyspec		: /* empty */			{
d321 1
a321 1
		| KEY STRING			{
d363 2
d399 1
d401 1
a405 1
		{ "key",		KEY},
d839 1
a839 1
    struct ipsec_key *key)
d843 1
a843 1
	if (spi == 0 || key == NULL)
d855 1
a855 1
	r->key = key;
d861 1
a861 1
reverse_sa(struct ipsec_rule *rule, u_int32_t spi, struct ipsec_key *key)
d865 1
a865 1
	if (spi == 0 || key == NULL)
d876 1
a876 1
	reverse->key = key;
@


1.15
log
@Make use of struct ipsec_auth dynamic.
Do not pass IDs to kernel when deleting flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2005/07/24 12:11:49 hshoexer Exp $	*/
a162 3
flowrule	: FLOW ipsecrule		{ }
		;

d187 1
a187 1
ipsecrule	: protocol dir hosts peer ids authtype	{
d190 2
a191 2
			r = create_flow($2, $3.src, $3.dst, $4, $1, $5.srcid,
			    $5.dstid, $6);
d197 1
a197 1
				errx(1, "ipsecrule: ipsecctl_add_rule");
d200 1
a200 1
			if ($2 == IPSEC_INOUT) {
d205 1
a205 1
					errx(1, "ipsecrule: ipsecctl_add_rule");
@


1.14
log
@use correct function names in error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2005/07/24 10:06:38 hshoexer Exp $	*/
d921 6
a926 3
	r->auth.srcid = srcid;
	r->auth.dstid = dstid;
	r->auth.idtype = ID_FQDN;	/* XXX For now only FQDN. */
d928 1
a928 1
	r->auth.type = authtype;
d969 5
a973 2
	if (rule->auth.dstid && (reverse->auth.dstid =
	    strdup(rule->auth.dstid)) == NULL)
d975 2
a976 2
	if (rule->auth.srcid && (reverse->auth.srcid =
	    strdup(rule->auth.srcid)) == NULL)
d978 2
a979 2
	reverse->auth.idtype = rule->auth.idtype;
	reverse->auth.type = rule->auth.type;
@


1.13
log
@prepare for combining SAs and flows in one single rule, no functional change
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2005/07/23 20:35:04 hshoexer Exp $	*/
d200 1
a200 1
				errx(1, "esprule: ipsecctl_add_rule");
d208 1
a208 1
					errx(1, "esprule: ipsecctl_add_rule");
@


1.12
log
@add automatic creation of reverse SAs.

A tcpmd5 rule like:
	tcpmd5 from 192.168.3.28 to 192.168.3.14 spi 0x2000:0x2001 \
		key 0xbeefdead:0xdeadbeef
expands now to:
	tcpmd5 from 192.168.3.28 to 192.168.3.14 spi 0x00002000 key 0xbeefdead
	tcpmd5 from 192.168.3.14 to 192.168.3.28 spi 0x00002001 key 0xdeadbeef
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2005/07/23 20:09:02 hshoexer Exp $	*/
d845 1
a845 1
	r->type = RULE_SA;
d867 1
a867 1
	reverse->type = RULE_SA;
d887 1
a887 1
	r->type = RULE_FLOW;
d951 1
a951 1
	reverse->type = RULE_FLOW;
@


1.11
log
@prepare for specifying both in and out key, not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2005/07/23 19:28:27 hshoexer Exp $	*/
d82 3
d176 11
d202 1
a202 1
			/* Create and add reverse rule. */
d296 2
a297 2
				if (atospi($2, &spi) == -1) {
					yyerror("%s is not a valid spi", $2);
d310 1
d838 3
d853 21
@


1.10
log
@prepare for specifying incoming and outgoing SPIs, not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2005/07/10 09:33:10 hshoexer Exp $	*/
d110 4
a113 1
		struct ipsec_key *key;
d133 1
a133 1
%type	<v.key>			keyspec
d166 1
a166 1
			r = create_sa($2.src, $2.dst, $3.spiout, $4);
d300 4
a303 1
keyspec		: /* empty */			{ $$ = NULL; }
d305 2
a306 1
			unsigned char	 *hex;
d308 8
d319 1
a319 1
			$$ = parsekey(hex, strlen(hex));
d341 1
a341 1
			$$ = parsekey(hex, sb.st_size);
@


1.9
log
@allow reading key from a file
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2005/07/09 21:41:08 hshoexer Exp $	*/
d75 1
d106 4
a109 1
		u_int32_t	 spi;
d129 1
a129 1
%type	<v.spi>			spi
d160 1
a160 1
tcpmd5rule	: TCPMD5 hosts spi keyspec	{
d163 1
a163 1
			r = create_sa($2.src, $2.dst, $3, $4);
d272 18
a289 4
spi		: SPI number			{
			if ($2 >= SPI_RESERVED_MIN && $2 <= SPI_RESERVED_MAX) {
			    yyerror("invalid spi 0x%lx", $2);
			    YYERROR;
d291 3
a293 1
			$$ = $2;
d695 13
@


1.8
log
@it's ok to not specify the key when deleting a tcpmd5 SA
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2005/07/09 21:12:07 hshoexer Exp $	*/
d27 1
d35 1
d41 1
d45 2
d76 1
d114 1
a114 1
%token	ERROR
d279 1
a279 3
			struct ipsec_key *key;
			int	 i;
			char	*hexkey;
d281 4
a284 12
			hexkey = $2;
			if (!strncmp(hexkey, "0x", 2))
				hexkey += 2;

			key = calloc(1, sizeof(struct ipsec_key));
			if (key == NULL)
				err(1, "calloc:");

			key->len = strlen(hexkey) / 2;
			key->data = calloc(key->len, sizeof(u_int8_t));
			if (key->data == NULL)
				err(1, "calloc:");
d286 21
a306 2
			for (i = 0; i < (int)key->len; i++)
				key->data[i] = x2i(hexkey + 2 * i);
a307 1
			$$ = key;
d351 1
d692 21
@


1.7
log
@add support tcpmd5
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2005/07/07 22:00:36 hshoexer Exp $	*/
d120 1
a120 1
%type	<v.key>			key
d150 1
a150 1
tcpmd5rule	: TCPMD5 hosts spi key		{
d271 2
a272 1
key		: KEY STRING			{
@


1.6
log
@set flow type (use, require, etc.) when a rule is created.  Up to now this was
done while crafting the corresponding pfkey message.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2005/07/07 21:00:08 hshoexer Exp $	*/
d28 1
d70 1
d73 3
a75 1
struct ipsec_rule	*create_rule(u_int8_t, struct ipsec_addr *, struct
d99 2
d107 1
a107 1
%token	FLOW FROM ESP AH IN PEER ON OUT TO SRCID DSTID RSA PSK
d119 2
d126 1
d137 7
a143 2
			} else
				$$ = ulval;
d150 13
d166 1
a166 1
			r = create_rule($2, $3.src, $3.dst, $4, $1, $5.srcid,
d261 35
d335 1
d340 1
d342 1
d662 16
d733 21
a753 1
create_rule(u_int8_t dir, struct ipsec_addr *src, struct ipsec_addr *dst,
@


1.5
log
@add type for rules; will need this for tcpmd5
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2005/05/25 16:31:22 hshoexer Exp $	*/
d662 2
d669 4
a672 1
	r->type = RULE_FLOW;
d728 1
a728 1
	if (rule->direction == (u_int8_t)IPSEC_OUT)
d730 2
a731 1
	else
d733 2
@


1.4
log
@do not swap srcid/dstid for INOUT rules.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2005/05/25 16:29:21 hshoexer Exp $	*/
d667 2
d720 2
@


1.3
log
@use bzero
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2005/04/04 22:22:55 hshoexer Exp $	*/
d729 1
a729 1
	if (rule->auth.dstid && (reverse->auth.srcid =
d732 1
a732 1
	if (rule->auth.srcid && (reverse->auth.dstid =
@


1.2
log
@fix cvs id tags
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d622 1
a622 1
	memset(&ipa->v4mask, 0, sizeof(ipa->v4mask));
@


1.1
log
@Add ipsecctl utility, work in progress

ok deraadt
@
text
@d1 1
a1 1
/*	$Id: parse.y,v 1.9 2005/04/04 21:41:56 hshoexer Exp $	*/
@

