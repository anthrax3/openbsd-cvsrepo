head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.8
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.44
date	2017.03.02.17.44.32;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	aaLSueYcyfhIr3Fh;

1.43
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.42;
commitid	rmbXKt3efXwOBuCw;

1.42
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.41;
commitid	CLwtYUTkBZ3FXV1w;

1.41
date	2015.12.02.12.43.59;	author naddy;	state Exp;
branches;
next	1.40;
commitid	duHJNnO9Vx1nKUKx;

1.40
date	2015.11.04.12.46.13;	author mikeb;	state Exp;
branches;
next	1.39;
commitid	TJX0if8DFoSZbZ4V;

1.39
date	2015.04.17.10.04.37;	author mikeb;	state Exp;
branches;
next	1.38;
commitid	KP3L4W0chjmfJmS7;

1.38
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.37;
commitid	bQi1IVHgugweH5gs;

1.37
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2014.12.28.14.19.31;	author claudio;	state Exp;
branches;
next	1.35;
commitid	VpvZE67yTkd6WPk7;

1.35
date	2014.01.22.09.36.04;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.05.09.02.20;	author mikeb;	state Exp;
branches;
next	1.32;

1.32
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.31;

1.31
date	2012.06.29.15.01.07;	author mikeb;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.13.11.31.27;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.22.14.04.09;	author mikeb;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.01.02.11.35;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.13.20.09.54;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.19.10.37.12;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.03.12.17.43;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.24.13.52.13;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.19.21.29.47;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.30.15.49.32;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.30.12.16.59;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.12.19.17.51;	author naddy;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.02.12.29.43;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.02.04.14.51;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.02.03.52.29;	author msf;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.01.16.13.01;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.01.06.50.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.31.05.38.45;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.31.05.36.06;	author msf;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.30.21.56.05;	author msf;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.21.01.40.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.12.23.24.10;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.13.18.39.19;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.12.12.00.53;	author hshoexer;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.30.19.50.24;	author hshoexer;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.09.21.54.12;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.27.21.26.02;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.06.07.15.46;	author hshoexer;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.27.05.48.10;	author hshoexer;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.27.05.19.55;	author hshoexer;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Now that the kernel provides information about IPsec SA bundles,
print them by default.
OK hshoexer@@
@
text
@/*	$OpenBSD: pfkdump.c,v 1.43 2017/02/28 16:46:27 bluhm Exp $	*/

/*
 * Copyright (c) 2003 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/time.h>
#include <sys/sysctl.h>
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <err.h>
#include <errno.h>

#include "ipsecctl.h"
#include "pfkey.h"

static void	print_proto(struct sadb_ext *, struct sadb_msg *);
static void	print_flow(struct sadb_ext *, struct sadb_msg *);
static void	print_supp(struct sadb_ext *, struct sadb_msg *);
static void	print_prop(struct sadb_ext *, struct sadb_msg *);
static void	print_sens(struct sadb_ext *, struct sadb_msg *);
static void	print_spir(struct sadb_ext *, struct sadb_msg *);
static void	print_policy(struct sadb_ext *, struct sadb_msg *);
static void	print_sa(struct sadb_ext *, struct sadb_msg *);
static void	print_addr(struct sadb_ext *, struct sadb_msg *);
static void	print_key(struct sadb_ext *, struct sadb_msg *);
static void	print_life(struct sadb_ext *, struct sadb_msg *);
static void	print_ident(struct sadb_ext *, struct sadb_msg *);
static void	print_udpenc(struct sadb_ext *, struct sadb_msg *);
static void	print_tag(struct sadb_ext *, struct sadb_msg *);
static void	print_tap(struct sadb_ext *, struct sadb_msg *);
static void	print_satype(struct sadb_ext *, struct sadb_msg *);

static struct idname *lookup(struct idname *, u_int32_t);
static char    *lookup_name(struct idname *, u_int32_t);
static void	print_ext(struct sadb_ext *, struct sadb_msg *);

void		pfkey_print_raw(u_int8_t *, ssize_t);
static char	*print_flags(uint32_t);

struct sadb_ext *extensions[SADB_EXT_MAX + 1];

struct idname {
	u_int32_t id;
	char *name;
	void (*func)(struct sadb_ext *, struct sadb_msg *);
};

struct idname ext_types[] = {
	{ SADB_EXT_RESERVED,		"reserved",		NULL },
	{ SADB_EXT_SA,			"sa",			print_sa },
	{ SADB_EXT_LIFETIME_CURRENT,	"lifetime_cur",		print_life },
	{ SADB_EXT_LIFETIME_HARD,	"lifetime_hard",	print_life },
	{ SADB_EXT_LIFETIME_SOFT,	"lifetime_soft",	print_life },
	{ SADB_EXT_ADDRESS_SRC,		"address_src",		print_addr },
	{ SADB_EXT_ADDRESS_DST,		"address_dst",		print_addr },
	{ SADB_EXT_ADDRESS_PROXY,	"address_proxy",	print_addr },
	{ SADB_EXT_KEY_AUTH,		"key_auth",		print_key },
	{ SADB_EXT_KEY_ENCRYPT,		"key_encrypt",		print_key },
	{ SADB_EXT_IDENTITY_SRC,	"identity_src",		print_ident },
	{ SADB_EXT_IDENTITY_DST,	"identity_dst",		print_ident },
	{ SADB_EXT_SENSITIVITY,		"sensitivity",		print_sens },
	{ SADB_EXT_PROPOSAL,		"proposal",		print_prop },
	{ SADB_EXT_SUPPORTED_AUTH,	"supported_auth",	print_supp },
	{ SADB_EXT_SUPPORTED_ENCRYPT,	"supported_encrypt",	print_supp },
	{ SADB_EXT_SPIRANGE,		"spirange",		print_spir },
	{ SADB_X_EXT_SRC_MASK,		"src_mask",		print_addr },
	{ SADB_X_EXT_DST_MASK,		"dst_mask",		print_addr },
	{ SADB_X_EXT_PROTOCOL,		"protocol",		print_proto },
	{ SADB_X_EXT_FLOW_TYPE,		"flow_type",		print_flow },
	{ SADB_X_EXT_SRC_FLOW,		"src_flow",		print_addr },
	{ SADB_X_EXT_DST_FLOW,		"dst_flow",		print_addr },
	{ SADB_X_EXT_SA2,		"sa2",			print_sa },
	{ SADB_X_EXT_DST2,		"dst2",			print_addr },
	{ SADB_X_EXT_POLICY,		"policy",		print_policy },
	{ SADB_X_EXT_SUPPORTED_COMP,	"supported_comp",	print_supp },
	{ SADB_X_EXT_UDPENCAP,		"udpencap",		print_udpenc },
	{ SADB_X_EXT_LIFETIME_LASTUSE,	"lifetime_lastuse",	print_life },
	{ SADB_X_EXT_TAG,		"tag",			print_tag },
	{ SADB_X_EXT_TAP,		"tap",			print_tap },
	{ SADB_X_EXT_SATYPE2,		"satype2",		print_satype },
	{ 0,				NULL,			NULL }
};

struct idname msg_types[] = {
	{ SADB_ACQUIRE,			"sadb_acquire",		NULL },
	{ SADB_ADD,			"sadb_add",		NULL },
	{ SADB_DELETE,			"sadb_delete",		NULL },
	{ SADB_DUMP,			"sadb_dump",		NULL },
	{ SADB_EXPIRE,			"sadb_expire",		NULL },
	{ SADB_FLUSH,			"sadb_flush",		NULL },
	{ SADB_GET,			"sadb_get",		NULL },
	{ SADB_GETSPI,			"sadb_getspi",		NULL },
	{ SADB_REGISTER,		"sadb_register",	NULL },
	{ SADB_UPDATE,			"sadb_update",		NULL },
	{ SADB_X_ADDFLOW,		"sadb_addflow",		NULL },
	{ SADB_X_ASKPOLICY,		"sadb_askpolicy",	NULL },
	{ SADB_X_DELFLOW,		"sadb_delflow",		NULL },
	{ SADB_X_GRPSPIS,		"sadb_grpspis",		NULL },
	{ SADB_X_PROMISC,		"sadb_promisc",		NULL },
	{ 0,				NULL,			NULL },
};

struct idname sa_types[] = {
	{ SADB_SATYPE_UNSPEC,		"unspec",		NULL },
	{ SADB_SATYPE_AH,		"ah",			NULL },
	{ SADB_SATYPE_ESP,		"esp",			NULL },
	{ SADB_SATYPE_RSVP,		"rsvp",			NULL },
	{ SADB_SATYPE_OSPFV2,		"ospfv2",		NULL },
	{ SADB_SATYPE_RIPV2,		"ripv2",		NULL },
	{ SADB_SATYPE_MIP,		"mip",			NULL },
	{ SADB_X_SATYPE_IPIP,		"ipip",			NULL },
	{ SADB_X_SATYPE_TCPSIGNATURE,	"tcpmd5",		NULL },
	{ SADB_X_SATYPE_IPCOMP,		"ipcomp",		NULL },
	{ 0,				NULL,			NULL }
};

struct idname auth_types[] = {
	{ SADB_AALG_NONE,		"none",			NULL },
	{ SADB_AALG_MD5HMAC,		"hmac-md5",		NULL },
	{ SADB_X_AALG_RIPEMD160HMAC,	"hmac-ripemd160",	NULL },
	{ SADB_AALG_SHA1HMAC,		"hmac-sha1",		NULL },
	{ SADB_X_AALG_SHA2_256,		"hmac-sha2-256",	NULL },
	{ SADB_X_AALG_SHA2_384,		"hmac-sha2-384",	NULL },
	{ SADB_X_AALG_SHA2_512,		"hmac-sha2-512",	NULL },
	{ SADB_X_AALG_AES128GMAC,	"gmac-aes-128",		NULL },
	{ SADB_X_AALG_AES192GMAC,	"gmac-aes-192",		NULL },
	{ SADB_X_AALG_AES256GMAC,	"gmac-aes-256",		NULL },
	{ SADB_X_AALG_CHACHA20POLY1305,	"chacha20-poly1305",	NULL },
	{ 0,				NULL,			NULL }
};

struct idname enc_types[] = {
	{ SADB_EALG_NONE,		"none",			NULL },
	{ SADB_EALG_3DESCBC,		"3des-cbc",		NULL },
	{ SADB_X_EALG_AES,		"aes",			NULL },
	{ SADB_X_EALG_AESCTR,		"aesctr",		NULL },
	{ SADB_X_EALG_AESGCM16,		"aes-gcm",		NULL },
	{ SADB_X_EALG_AESGMAC,		"aes-gmac",		NULL },
	{ SADB_X_EALG_BLF,		"blowfish",		NULL },
	{ SADB_X_EALG_CAST,		"cast128",		NULL },
	{ SADB_EALG_NULL,		"null",			NULL },
	{ SADB_X_EALG_CHACHA20POLY1305,	"chacha20-poly1305",	NULL },
	{ 0,				NULL,			NULL }
};

struct idname comp_types[] = {
	{ SADB_X_CALG_NONE,		"none",			NULL },
	{ SADB_X_CALG_OUI,		"oui",			NULL },
	{ SADB_X_CALG_DEFLATE,		"deflate",		NULL },
	{ SADB_X_CALG_LZS,		"lzs",			NULL },
	{ 0,				NULL,			NULL }
};

struct idname flag_types[] = {
	{ SADB_SAFLAGS_PFS,		"pfs",			NULL },
	{ SADB_X_SAFLAGS_TUNNEL,	"tunnel",		NULL },
	{ SADB_X_SAFLAGS_CHAINDEL,	"chaindel",		NULL },
	{ SADB_X_SAFLAGS_UDPENCAP,	"udpencap",		NULL },
	{ SADB_X_SAFLAGS_ESN,		"esn",			NULL },
	{ 0,				NULL,			NULL }
};

struct idname identity_types[] = {
	{ SADB_IDENTTYPE_RESERVED,	"reserved",		NULL },
	{ SADB_IDENTTYPE_PREFIX,	"prefix",		NULL },
	{ SADB_IDENTTYPE_FQDN,		"fqdn",			NULL },
	{ SADB_IDENTTYPE_USERFQDN,	"ufqdn",		NULL },
	{ 0,				NULL,			NULL }
};

struct idname flow_types[] = {
	{ SADB_X_FLOW_TYPE_USE,		"use",			NULL },
	{ SADB_X_FLOW_TYPE_ACQUIRE,	"acquire",		NULL },
	{ SADB_X_FLOW_TYPE_REQUIRE,	"require",		NULL },
	{ SADB_X_FLOW_TYPE_BYPASS,	"bypass",		NULL },
	{ SADB_X_FLOW_TYPE_DENY,	"deny",			NULL },
	{ SADB_X_FLOW_TYPE_DONTACQ,	"dontacq",		NULL },
	{ 0,				NULL,			NULL }
};

struct idname states[] = {
	{ SADB_SASTATE_LARVAL,		"larval",		NULL },
	{ SADB_SASTATE_MATURE,		"mature",		NULL },
	{ SADB_SASTATE_DYING,		"dying",		NULL },
	{ SADB_SASTATE_DEAD,		"dead",			NULL },
	{ 0,				NULL,			NULL }
};

static struct idname *
lookup(struct idname *tab, u_int32_t id)
{
	struct idname *entry;

	for (entry = tab; entry->name; entry++)
		if (entry->id == id)
			return (entry);
	return (NULL);
}

static char *
lookup_name(struct idname *tab, u_int32_t id)
{
	struct idname *entry;

	entry = lookup(tab, id);
	return (entry ? entry->name : "unknown");
}

static void
print_ext(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct idname *entry;

	if ((entry = lookup(ext_types, ext->sadb_ext_type)) == NULL) {
		printf("unknown ext: type %u len %u\n",
		    ext->sadb_ext_type, ext->sadb_ext_len);
		return;
	}
	printf("\t%s: ", entry->name);
	if (entry->func != NULL)
		(*entry->func)(ext, msg);
	else
		printf("type %u len %u",
		    ext->sadb_ext_type, ext->sadb_ext_len);
	printf("\n");
}

static char *
print_flags(uint32_t flags)
{
	static char fstr[80];
	struct idname *entry;
	size_t len;
	int i, comma = 0;

	len = snprintf(fstr, sizeof(fstr), "%#x<", flags);
	for (i = 0; i < 32; i++) {
		if ((flags & (1 << i)) == 0 ||
		    (entry = lookup(flag_types, 1 << i)) == NULL)
			continue;
		len += snprintf(fstr + len, sizeof(fstr) - len - 1,
		    comma ? ",%s" : "%s", entry->name);
		comma = 1;
	}
	strlcat(fstr, ">", sizeof(fstr));

	return (fstr);
}

static void
print_sa(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_sa *sa = (struct sadb_sa *)ext;

	if (msg->sadb_msg_satype == SADB_X_SATYPE_IPCOMP)
		printf("cpi 0x%8.8x comp %s\n",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(comp_types, sa->sadb_sa_encrypt));
	else
		printf("spi 0x%8.8x auth %s enc %s\n",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(auth_types, sa->sadb_sa_auth),
		    lookup_name(enc_types, sa->sadb_sa_encrypt));
	printf("\t\tstate %s replay %u flags %s",
	    lookup_name(states, sa->sadb_sa_state),
	    sa->sadb_sa_replay, print_flags(sa->sadb_sa_flags));
}

/* ARGSUSED1 */
static void
print_addr(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_address *addr = (struct sadb_address *)ext;
	struct sockaddr *sa;
	struct sockaddr_in *sin4;
	struct sockaddr_in6 *sin6;
	char hbuf[NI_MAXHOST];

	sa = (struct sockaddr *)(addr + 1);
	if (sa->sa_family == 0)
		printf("<any>");
	else if (getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0,
	    NI_NUMERICHOST))
		printf("<could not get numeric hostname>");
	else
		printf("%s", hbuf);
	switch (sa->sa_family) {
	case AF_INET:
		sin4 = (struct sockaddr_in *)sa;
		if (sin4->sin_port)
			printf(" port %u", ntohs(sin4->sin_port));
		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)sa;
		if (sin6->sin6_port)
			printf(" port %u", ntohs(sin6->sin6_port));
		break;
	}
}

/* ARGSUSED1 */
static void
print_key(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_key *key = (struct sadb_key *)ext;
	u_int8_t *data;
	int i;

	printf("bits %u: ", key->sadb_key_bits);
	data = (u_int8_t *)(key + 1);
	for (i = 0; i < key->sadb_key_bits / 8; i++) {
		printf("%2.2x", data[i]);
		data[i] = 0x00;		/* clear sensitive data */
	}
}

/* ARGSUSED1 */
static void
print_life(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_lifetime *life = (struct sadb_lifetime *)ext;

	printf("alloc %u bytes %llu add %llu first %llu",
	    life->sadb_lifetime_allocations,
	    life->sadb_lifetime_bytes,
	    life->sadb_lifetime_addtime,
	    life->sadb_lifetime_usetime);
}

static void
print_proto(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_protocol *proto = (struct sadb_protocol *)ext;

	/* overloaded */
	if (msg->sadb_msg_type == SADB_X_GRPSPIS)
		printf("satype %s flags %x",
		    lookup_name(sa_types, proto->sadb_protocol_proto),
		    proto->sadb_protocol_flags);
	else
		printf("proto %u flags %x",
		    proto->sadb_protocol_proto, proto->sadb_protocol_flags);
}

/* ARGSUSED1 */
static void
print_flow(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_protocol *proto = (struct sadb_protocol *)ext;
	char *dir = "unknown";

	switch (proto->sadb_protocol_direction) {
	case IPSP_DIRECTION_IN:
		dir = "in";
		break;
	case IPSP_DIRECTION_OUT:
		dir = "out";
		break;
	}
	printf("type %s direction %s",
	    lookup_name(flow_types, proto->sadb_protocol_proto), dir);
}

static void
print_tag(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_tag *stag = (struct sadb_x_tag *)ext;
	char *p;

	p = (char *)(stag + 1);
	printf("%s", p);
}

static void
print_tap(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_tap *stap = (struct sadb_x_tap *)ext;

	printf("enc%u", stap->sadb_x_tap_unit);
}

static void
print_satype(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_protocol *proto = (struct sadb_protocol *)ext;

	printf("type %s", lookup_name(sa_types, proto->sadb_protocol_proto));
}

static char *
alg_by_ext(u_int8_t ext_type, u_int8_t id)
{
	switch (ext_type) {
	case SADB_EXT_SUPPORTED_ENCRYPT:
		return lookup_name(enc_types, id);
	case SADB_EXT_SUPPORTED_AUTH:
		return lookup_name(auth_types, id);
	case SADB_X_EXT_SUPPORTED_COMP:
		return lookup_name(comp_types, id);
	default:
		return "unknown";
	}
}

static void
print_alg(struct sadb_alg *alg, u_int8_t ext_type)
{
	printf("\t\t%s iv %u min %u max %u",
	    alg_by_ext(ext_type, alg->sadb_alg_id), alg->sadb_alg_ivlen,
	    alg->sadb_alg_minbits, alg->sadb_alg_maxbits);
}

/* ARGSUSED1 */
static void
print_supp(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_supported *supported = (struct sadb_supported *)ext;
	struct sadb_alg *alg;

	printf("\n");
	for (alg = (struct sadb_alg *)(supported + 1);
	    (size_t)((u_int8_t *)alg - (u_int8_t *)ext) <
	    ext->sadb_ext_len * PFKEYV2_CHUNK;
	    alg++) {
		struct sadb_alg *next = alg + 1;
		print_alg(alg, ext->sadb_ext_type);
		if ((size_t)((u_int8_t *)next - (u_int8_t *)ext) <
		    ext->sadb_ext_len * PFKEYV2_CHUNK)
			printf("\n");
	}
}

/* ARGSUSED1 */
static void
print_comb(struct sadb_comb *comb, struct sadb_msg *msg)
{
	printf("\t\tauth %s min %u max %u\n"
	    "\t\tenc %s min %u max %u\n"
	    "\t\taddtime hard %llu soft %llu\n"
	    "\t\tusetime hard %llu soft %llu",
	    lookup_name(auth_types, comb->sadb_comb_auth),
	    comb->sadb_comb_auth_minbits,
	    comb->sadb_comb_auth_maxbits,
	    lookup_name(enc_types, comb->sadb_comb_encrypt),
	    comb->sadb_comb_encrypt_minbits,
	    comb->sadb_comb_encrypt_maxbits,
	    comb->sadb_comb_soft_addtime,
	    comb->sadb_comb_hard_addtime,
	    comb->sadb_comb_soft_usetime,
	    comb->sadb_comb_hard_usetime);
#if 0
	    comb->sadb_comb_flags,
	    comb->sadb_comb_reserved,
	    comb->sadb_comb_soft_allocations,
	    comb->sadb_comb_hard_allocations,
	    comb->sadb_comb_soft_bytes,
	    comb->sadb_comb_hard_bytes,
#endif
}

/* ARGSUSED1 */
static void
print_prop(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_prop *prop = (struct sadb_prop *)ext;
	struct sadb_comb *comb;

	printf("replay %u\n", prop->sadb_prop_replay);
	for (comb = (struct sadb_comb *)(prop + 1);
	    (size_t)((u_int8_t *)comb - (u_int8_t *)ext) <
	    ext->sadb_ext_len * PFKEYV2_CHUNK;
	    comb++)
		print_comb(comb, msg);
}

/* ARGSUSED1 */
static void
print_sens(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_sens *sens = (struct sadb_sens *)ext;

	printf("dpd %u sens_level %u integ_level %u",
	    sens->sadb_sens_dpd,
	    sens->sadb_sens_sens_level,
	    sens->sadb_sens_integ_level);
}

/* ARGSUSED1 */
static void
print_spir(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_spirange *spirange = (struct sadb_spirange *)ext;

	printf("min 0x%8.8x max 0x%8.8x",
	    spirange->sadb_spirange_min, spirange->sadb_spirange_max);
}

/* ARGSUSED1 */
static void
print_ident(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_ident *ident = (struct sadb_ident *)ext;

	printf("type %s id %llu: %s",
	    lookup_name(identity_types, ident->sadb_ident_type),
	    ident->sadb_ident_id, (char *)(ident + 1));
}

/* ARGSUSED1 */
static void
print_policy(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_policy *x_policy = (struct sadb_x_policy *)ext;

	printf("seq %u", x_policy->sadb_x_policy_seq);
}

/* ARGSUSED1 */
static void
print_udpenc(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_udpencap *x_udpencap = (struct sadb_x_udpencap *)ext;

	printf("udpencap port %u", ntohs(x_udpencap->sadb_x_udpencap_port));
}

static void
setup_extensions(struct sadb_msg *msg)
{
	struct sadb_ext *ext;

	bzero(extensions, sizeof(extensions));
	if (msg->sadb_msg_len == 0)
		return;
	for (ext = (struct sadb_ext *)(msg + 1);
	    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
	    msg->sadb_msg_len * PFKEYV2_CHUNK && ext->sadb_ext_len > 0;
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
	    ext->sadb_ext_len * PFKEYV2_CHUNK))
		extensions[ext->sadb_ext_type] = ext;
}

static void
parse_addr(struct sadb_ext *ext, struct ipsec_addr_wrap *ipa)
{
	struct sadb_address *addr = (struct sadb_address *)ext;
	struct sockaddr *sa;

	if (addr == NULL)
		return;
	sa = (struct sockaddr *)(addr + 1);
	switch (sa->sa_family) {
	case AF_INET:
		ipa->address.v4 = ((struct sockaddr_in *)sa)->sin_addr;
		set_ipmask(ipa, 32);
		break;
	case AF_INET6:
		ipa->address.v6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
		set_ipmask(ipa, 128);
		break;
	}
	ipa->af = sa->sa_family;
	ipa->next = NULL;
	ipa->tail = ipa;
}

static void
parse_key(struct sadb_ext *ext, struct ipsec_key *ikey)
{
	struct sadb_key *key = (struct sadb_key *)ext;
	u_int8_t *data;

	if (key == NULL)
		return;
	data = (u_int8_t *)(key + 1);
	ikey->data = data;
	ikey->len = key->sadb_key_bits / 8;
}

static void
parse_satype(struct sadb_ext *ext, u_int8_t *satype)
{
	struct sadb_protocol *proto = (struct sadb_protocol *)ext;

	if (proto == NULL)
		return;
	switch (proto->sadb_protocol_proto) {
	case SADB_SATYPE_ESP:
		*satype = IPSEC_ESP;
		break;
	case SADB_SATYPE_AH:
		*satype = IPSEC_AH;
		break;
	case SADB_X_SATYPE_IPCOMP:
		*satype = IPSEC_IPCOMP;
		break;
	case SADB_X_SATYPE_IPIP:
		*satype = IPSEC_IPIP;
		break;
	default:
		return;
	}
}

u_int32_t
pfkey_get_spi(struct sadb_msg *msg)
{
	struct sadb_sa *sa;

	setup_extensions(msg);
	sa = (struct sadb_sa *)extensions[SADB_EXT_SA];
	return (ntohl(sa->sadb_sa_spi));
}

/* opposite of pfkey_sa() */
void
pfkey_print_sa(struct sadb_msg *msg, int opts)
{
	int i;
	struct ipsec_rule r;
	struct ipsec_key enckey, authkey;
	struct ipsec_transforms xfs;
	struct ipsec_addr_wrap src, dst, dst2;
	struct sadb_sa *sa, *sa2;

	setup_extensions(msg);
	sa = (struct sadb_sa *)extensions[SADB_EXT_SA];
	bzero(&r, sizeof r);
	r.type |= RULE_SA;
	r.tmode = (msg->sadb_msg_satype != SADB_X_SATYPE_TCPSIGNATURE) &&
	    (sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL) ?
	    IPSEC_TUNNEL : IPSEC_TRANSPORT;
	r.spi = ntohl(sa->sadb_sa_spi);

	switch (msg->sadb_msg_satype) {
	case SADB_SATYPE_AH:
		r.satype = IPSEC_AH;
		break;
	case SADB_SATYPE_ESP:
		r.satype = IPSEC_ESP;
		break;
	case SADB_X_SATYPE_IPCOMP:
		r.satype = IPSEC_IPCOMP;
		break;
	case SADB_X_SATYPE_TCPSIGNATURE:
		r.satype = IPSEC_TCPMD5;
		break;
	case SADB_X_SATYPE_IPIP:
		r.satype = IPSEC_IPIP;
		break;
	default:
		return;
	}
	bzero(&dst, sizeof dst);
	bzero(&src, sizeof src);
	parse_addr(extensions[SADB_EXT_ADDRESS_SRC], &src);
	parse_addr(extensions[SADB_EXT_ADDRESS_DST], &dst);
	r.src = &src;
	r.dst = &dst;
	if (r.satype == IPSEC_IPCOMP) {
		if (sa->sadb_sa_encrypt) {
			bzero(&xfs, sizeof xfs);
			r.xfs = &xfs;
			switch (sa->sadb_sa_encrypt) {
			case SADB_X_CALG_DEFLATE:
				xfs.compxf = &compxfs[COMPXF_DEFLATE];
				break;
			case SADB_X_CALG_LZS:
				xfs.compxf = &compxfs[COMPXF_LZS];
				break;
			}
		}
	} else if (r.satype == IPSEC_TCPMD5) {
		bzero(&authkey, sizeof authkey);
		parse_key(extensions[SADB_EXT_KEY_AUTH], &authkey);
		r.authkey = &authkey;
	} else if (sa->sadb_sa_encrypt || sa->sadb_sa_auth) {
		bzero(&xfs, sizeof xfs);
		r.xfs = &xfs;
		if (sa->sadb_sa_encrypt) {
			bzero(&enckey, sizeof enckey);
			parse_key(extensions[SADB_EXT_KEY_ENCRYPT], &enckey);
			r.enckey = &enckey;

			switch (sa->sadb_sa_encrypt) {
			case SADB_EALG_3DESCBC:
				xfs.encxf = &encxfs[ENCXF_3DES_CBC];
				break;
			case SADB_X_EALG_AES:
				switch (r.enckey->len) {
				case 192/8:
					xfs.encxf = &encxfs[ENCXF_AES_192];
					break;
				case 256/8:
					xfs.encxf = &encxfs[ENCXF_AES_256];
					break;
				default:
					xfs.encxf = &encxfs[ENCXF_AES];
					break;
				}
				break;
			case SADB_X_EALG_AESCTR:
				switch (r.enckey->len) {
				case 28:
					xfs.encxf = &encxfs[ENCXF_AES_192_CTR];
					break;
				case 36:
					xfs.encxf = &encxfs[ENCXF_AES_256_CTR];
					break;
				default:
					xfs.encxf = &encxfs[ENCXF_AESCTR];
					break;
				}
				break;
			case SADB_X_EALG_AESGCM16:
				switch (r.enckey->len) {
				case 28:
					xfs.encxf = &encxfs[ENCXF_AES_192_GCM];
					break;
				case 36:
					xfs.encxf = &encxfs[ENCXF_AES_256_GCM];
					break;
				default:
					xfs.encxf = &encxfs[ENCXF_AES_128_GCM];
					break;
				}
				break;
			case SADB_X_EALG_AESGMAC:
				switch (r.enckey->len) {
				case 28:
					xfs.encxf = &encxfs[ENCXF_AES_192_GMAC];
					break;
				case 36:
					xfs.encxf = &encxfs[ENCXF_AES_256_GMAC];
					break;
				default:
					xfs.encxf = &encxfs[ENCXF_AES_128_GMAC];
					break;
				}
				break;
			case SADB_X_EALG_BLF:
				xfs.encxf = &encxfs[ENCXF_BLOWFISH];
				break;
			case SADB_X_EALG_CAST:
				xfs.encxf = &encxfs[ENCXF_CAST128];
				break;
			case SADB_X_EALG_CHACHA20POLY1305:
				xfs.encxf = &encxfs[ENCXF_CHACHA20_POLY1305];
				break;
			case SADB_EALG_NULL:
				xfs.encxf = &encxfs[ENCXF_NULL];
				break;
			}
		}
		if (sa->sadb_sa_auth) {
			bzero(&authkey, sizeof authkey);
			parse_key(extensions[SADB_EXT_KEY_AUTH], &authkey);
			r.authkey = &authkey;

			switch (sa->sadb_sa_auth) {
			case SADB_AALG_MD5HMAC:
				xfs.authxf = &authxfs[AUTHXF_HMAC_MD5];
				break;
			case SADB_X_AALG_RIPEMD160HMAC:
				xfs.authxf = &authxfs[AUTHXF_HMAC_RIPEMD160];
				break;
			case SADB_AALG_SHA1HMAC:
				xfs.authxf = &authxfs[AUTHXF_HMAC_SHA1];
				break;
			case SADB_X_AALG_SHA2_256:
				xfs.authxf = &authxfs[AUTHXF_HMAC_SHA2_256];
				break;
			case SADB_X_AALG_SHA2_384:
				xfs.authxf = &authxfs[AUTHXF_HMAC_SHA2_384];
				break;
			case SADB_X_AALG_SHA2_512:
				xfs.authxf = &authxfs[AUTHXF_HMAC_SHA2_512];
				break;
			}
		}
	}
	if (!(opts & IPSECCTL_OPT_SHOWKEY)) {
		bzero(&enckey, sizeof enckey);
		bzero(&authkey, sizeof authkey);
		extensions[SADB_EXT_KEY_AUTH] = NULL;
		extensions[SADB_EXT_KEY_ENCRYPT] = NULL;
	}
	if (extensions[SADB_X_EXT_SA2]) {
		r.type |= RULE_GROUP;
		sa2 = (struct sadb_sa *)extensions[SADB_X_EXT_SA2];
		r.spi2 = ntohl(sa2->sadb_sa_spi);
		parse_addr(extensions[SADB_X_EXT_DST2], &dst2);
		r.dst2 = &dst2;
		parse_satype(extensions[SADB_X_EXT_SATYPE2], &r.proto2);
		r.proto = r.satype;
	}
	ipsecctl_print_rule(&r, opts);

	if (opts & IPSECCTL_OPT_VERBOSE) {
		for (i = 0; i <= SADB_EXT_MAX; i++)
			if (extensions[i])
				print_ext(extensions[i], msg);
	}
	fflush(stdout);
}

/* ARGSUSED1 */
void
pfkey_monitor_sa(struct sadb_msg *msg, int opts)
{
	int		 i;

	setup_extensions(msg);

	printf("%s: satype %s vers %u len %u seq %u pid %u\n",
	    lookup_name(msg_types, msg->sadb_msg_type),
	    lookup_name(sa_types, msg->sadb_msg_satype),
	    msg->sadb_msg_version, msg->sadb_msg_len,
	    msg->sadb_msg_seq,
	    msg->sadb_msg_pid);
	if (msg->sadb_msg_errno)
		printf("\terrno %u: %s\n", msg->sadb_msg_errno,
		    strerror(msg->sadb_msg_errno));
	for (i = 0; i <= SADB_EXT_MAX; i++)
		if (extensions[i])
			print_ext(extensions[i], msg);
	fflush(stdout);
}

void
pfkey_print_raw(u_int8_t *data, ssize_t len)
{
	int i;
	const u_int8_t *sp = (const u_int8_t *)data;

	printf("RAW PFKEYV2 MESSAGE:\n");
	for (i = 0; i < len; i++) {
		if ((i % 8 == 0) && (i != 0))
			printf("\n");
		printf("%02x ", *sp);
		sp++;
	}
	printf("\n");
}
@


1.43
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.42 2015/12/09 21:41:50 naddy Exp $	*/
d607 25
d650 2
a651 2
	struct ipsec_addr_wrap src, dst;
	struct sadb_sa *sa;
d814 9
@


1.42
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.41 2015/12/02 12:43:59 naddy Exp $	*/
d58 1
d107 1
d407 8
@


1.41
log
@remove unimplemented PF_KEY algorithms; ok sthen@@ mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.40 2015/11/04 12:46:13 mikeb Exp $	*/
a159 1
	{ SADB_EALG_DESCBC,		"des-cbc",		NULL },
a679 3
				break;
			case SADB_EALG_DESCBC:
				xfs.encxf = &encxfs[ENCXF_DES_CBC];
@


1.40
log
@Decode Chacha20-Poly1305 when dumping SAs;  ok reyk, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.39 2015/04/17 10:04:37 mikeb Exp $	*/
a143 1
	{ SADB_X_AALG_DES,		"des",			NULL },
a160 1
	{ SADB_X_EALG_3IDEA,		"idea3",		NULL },
a166 3
	{ SADB_X_EALG_DES_IV32,		"des-iv32",		NULL },
	{ SADB_X_EALG_DES_IV64,		"des-iv64",		NULL },
	{ SADB_X_EALG_IDEA,		"idea",			NULL },
a167 2
	{ SADB_X_EALG_RC4,		"rc4",			NULL },
	{ SADB_X_EALG_RC5,		"rc5",			NULL },
@


1.39
log
@Remove unsupported SADB_X_IDENTTYPE_CONNECTION;  OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.38 2015/04/14 12:22:15 mikeb Exp $	*/
d154 1
d175 1
d749 3
@


1.38
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.37 2015/01/16 06:39:58 deraadt Exp $	*/
a198 1
	{ SADB_X_IDENTTYPE_CONNECTION,	"x_connection",		NULL },
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.36 2014/12/28 14:19:31 claudio Exp $	*/
a54 2
static void	print_auth(struct sadb_ext *, struct sadb_msg *);
static void	print_cred(struct sadb_ext *, struct sadb_msg *);
a100 1
	{ SADB_X_EXT_LOCAL_AUTH,	"local_auth",		print_auth },
a101 3
	{ SADB_X_EXT_REMOTE_AUTH,	"remote_auth",		print_auth },
	{ SADB_X_EXT_LOCAL_CREDENTIALS,	"local_cred",		print_cred },
	{ SADB_X_EXT_REMOTE_CREDENTIALS,"remote_cred",		print_cred },
a156 6
struct idname cred_types[] = {
	{ SADB_X_CREDTYPE_X509,		"x509-asn1",		NULL },
	{ SADB_X_CREDTYPE_KEYNOTE,	"keynote",		NULL },
	{ 0,				NULL,			NULL }
};

a184 7
struct idname xauth_types[] = {
	{ SADB_X_AUTHTYPE_NONE,		"none",			NULL },
	{ SADB_X_AUTHTYPE_PASSPHRASE,	"passphrase",		NULL },
	{ SADB_X_AUTHTYPE_RSA,		"rsa",			NULL },
	{ 0,				NULL,			NULL }
};

a530 19
}

/* ARGSUSED1 */
static void
print_auth(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_cred *x_cred = (struct sadb_x_cred *)ext;

	printf("type %s",
	    lookup_name(xauth_types, x_cred->sadb_x_cred_type));
}

/* ARGSUSED1 */
static void
print_cred(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_cred *x_cred = (struct sadb_x_cred *)ext;
	printf("type %s",
	    lookup_name(cred_types, x_cred->sadb_x_cred_type));
@


1.36
log
@Unbreak the tree. Looks like tedu did not tedu enough when killing KPDK
support.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.35 2014/01/22 09:36:04 markus Exp $	*/
d26 1
a26 1
#include <sys/param.h>
@


1.35
log
@fix printing of IPcomp SAs; ok mikeb@@ & todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.34 2012/09/18 09:24:45 markus Exp $	*/
a159 2
	{ SADB_X_AALG_MD5,		"md5",			NULL },
	{ SADB_X_AALG_SHA1,		"sha1",			NULL },
@


1.34
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.33 2012/07/05 09:02:20 mikeb Exp $	*/
d705 1
a705 1
				xfs.encxf = &compxfs[COMPXF_DEFLATE];
d708 1
a708 1
				xfs.encxf = &compxfs[COMPXF_LZS];
@


1.33
log
@don't output "esn" string in the rule section as we can't use the
keyword in the grammar to create a esn-enabled rule (no reason to
do so for manual sa configuration).  instead decode sa flags so
that we can also watch changes happening in the realtime with the
monitor mode.  prompted and ok by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.32 2012/06/30 14:51:31 naddy Exp $	*/
a207 1
	{ SADB_X_SAFLAGS_HALFIV,	"halfiv",		NULL },
a209 2
	{ SADB_X_SAFLAGS_RANDOMPADDING,	"randpad",		NULL },
	{ SADB_X_SAFLAGS_NOREPLAY,	"noreplay",		NULL },
@


1.32
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.31 2012/06/29 15:01:07 mikeb Exp $	*/
d61 2
a62 2
static struct idname *lookup(struct idname *, u_int8_t);
static char    *lookup_name(struct idname *, u_int8_t);
d66 1
d71 1
a71 1
	u_int8_t id;
d206 12
d246 1
a246 1
lookup(struct idname *tab, u_int8_t id)
d257 1
a257 1
lookup_name(struct idname *tab, u_int8_t id)
d284 22
d320 1
a320 1
	printf("\t\tstate %s replay %u flags %x",
d322 1
a322 1
	    sa->sadb_sa_replay, sa->sadb_sa_flags);
a674 1
	r.esn = sa->sadb_sa_flags & SADB_X_SAFLAGS_ESN ? 1 : 0;
@


1.31
log
@Print esn flag when dumping SAs with ESN enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.30 2011/04/13 11:31:27 markus Exp $	*/
d714 11
a724 1
				xfs.encxf = &encxfs[ENCXF_AESCTR];
@


1.30
log
@print flags in hex; from hshoexer@@; ok mikeb@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.29 2010/10/06 22:19:20 mikeb Exp $	*/
d640 1
@


1.29
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.28 2010/09/22 14:04:09 mikeb Exp $	*/
d285 1
a285 1
	printf("\t\tstate %s replay %u flags %u",
d358 1
a358 1
		printf("satype %s flags %u",
d362 1
a362 1
		printf("proto %u flags %u",
@


1.28
log
@Support AES-GCM-16 (as aes-gcm) and ENCR_NULL_AUTH_AES_GMAC
(as aes-gmac) encryption transformations in the ipsec.conf(5).

Available "enc" arguments denoting use of

1) AES-GCM-16:

 aes-128-gcm for 160 bit key (128+nonce)
 aes-192-gcm for 224 bit key (192+nonce)
 aes-256-gcm for 288 bit key (256+nonce)

2) ENCR_NULL_AUTH_AES_GMAC:

 aes-128-gmac for 160 bit key (128+nonce)
 aes-192-gmac for 224 bit key (192+nonce)
 aes-256-gmac for 288 bit key (256+nonce)

Please note that aes-gmac family performs no encryption and provides
no confidentiality and is intended for cases in which confidentiality
is not desired (it can be thought of as AH with NAT-T support).

Also, although this implementation supports manual keying, it's
use is strictly discouraged as AES-GCM security depends on frequent
re-keying.  So it can be thought of as a debug facility only.

Example configuration:

	ike esp from 172.23.61.36 to 172.23.61.156 \
		quick enc aes-256-gcm \
		psk humppa

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

OK naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.27 2010/07/01 02:11:35 reyk Exp $	*/
a186 1
	{ SADB_X_EALG_SKIPJACK,		"skipjack",		NULL },
a748 3
				break;
			case SADB_X_EALG_SKIPJACK:
				xfs.encxf = &encxfs[ENCXF_SKIPJACK];
@


1.27
log
@support dumping the new SADB_X_EXT_TAP extension.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.26 2009/11/13 20:09:54 jsg Exp $	*/
d156 3
d177 2
d715 26
@


1.26
log
@Don't use [] in function arguments when dealing with arrays
we don't know the size of, otherwise gcc >= 4 will error.

ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.25 2008/08/19 10:37:12 markus Exp $	*/
d59 1
d110 1
d389 8
@


1.25
log
@use the actual keysize from the SA to figure out which AES variant
(aes-192, aes-256) is used; ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.24 2007/01/03 12:17:43 markus Exp $	*/
d60 2
a61 2
static struct idname *lookup(struct idname [], u_int8_t);
static char    *lookup_name(struct idname [], u_int8_t);
d227 1
a227 1
lookup(struct idname tab[], u_int8_t id)
d238 1
a238 1
lookup_name(struct idname tab[], u_int8_t id)
@


1.24
log
@do not print secret keys by default, -k restores old behaviour; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.23 2006/11/24 13:52:13 reyk Exp $	*/
a620 4
	if (!(opts & IPSECCTL_OPT_SHOWKEY)) {
	    extensions[SADB_EXT_KEY_AUTH] = NULL;
	    extensions[SADB_EXT_KEY_ENCRYPT] = NULL;
	}
d674 4
d686 11
a696 1
				xfs.encxf = &encxfs[ENCXF_AES];
a713 3
			bzero(&enckey, sizeof enckey);
			parse_key(extensions[SADB_EXT_KEY_ENCRYPT], &enckey);
			r.enckey = &enckey;
d716 4
a739 3
			bzero(&authkey, sizeof authkey);
			parse_key(extensions[SADB_EXT_KEY_AUTH], &authkey);
			r.authkey = &authkey;
d741 6
@


1.23
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.22 2006/09/19 21:29:47 markus Exp $	*/
d621 4
a624 1

@


1.22
log
@sort SAs by spi; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.21 2006/08/30 15:49:32 markus Exp $	*/
d58 1
d108 1
d377 10
@


1.21
log
@partial backout of last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.20 2006/08/30 12:16:59 markus Exp $	*/
a62 1
void		pfkey_print_sa(struct sadb_msg *, int);
d586 10
d759 1
a759 1
	for(i = 0; i < len; i++) {
@


1.20
log
@print extensions with type SADB_EXT_MAX, too; ok hshoexer, reyk, msf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.19 2006/06/12 19:17:51 naddy Exp $	*/
a57 1
static void	print_tag(struct sadb_ext *, struct sadb_msg *);
a107 1
	{ SADB_X_EXT_TAG,		"tag",			print_tag },
a254 2
		printf("type %u len %u",
		    ext->sadb_ext_type, ext->sadb_ext_len);
a375 7
}

static void
print_tag(struct sadb_ext *ext, struct sadb_msg *msg)
{
	struct sadb_x_tag *stag = (struct sadb_x_tag *)ext;
	printf("%s", stag->sadb_x_tag_name);
@


1.19
log
@Fix a typo that prevented ipsecctl -ss from showing authentication
information for AH SAs.  ok markus@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.18 2006/06/02 12:29:43 markus Exp $	*/
d58 1
d67 1
a67 1
struct sadb_ext *extensions[SADB_EXT_MAX];
d109 1
d257 2
d382 7
d724 1
a724 1
		for (i = 0; i < SADB_EXT_MAX; i++)
d748 1
a748 1
	for (i = 0; i < SADB_EXT_MAX; i++)
@


1.18
log
@print full information about tcpmd5 and ipcomp SAs, too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.17 2006/06/02 04:14:51 hshoexer Exp $	*/
d650 1
a650 1
	} else if (sa->sadb_sa_encrypt || sa->sadb_sa_encrypt) {
@


1.17
log
@tiny style cleanup and white spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.16 2006/06/02 03:52:29 msf Exp $	*/
d633 18
a650 1
	if (sa->sadb_sa_encrypt || sa->sadb_sa_encrypt) {
@


1.16
log
@fix the formatting for sadb_register messages in monitor mode.
put back one mistakenly deleted newline.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.15 2006/06/01 16:13:01 markus Exp $	*/
d80 5
a84 5
	{ SADB_EXT_ADDRESS_SRC,		"address_src",		print_addr},
	{ SADB_EXT_ADDRESS_DST,		"address_dst",		print_addr},
	{ SADB_EXT_ADDRESS_PROXY,	"address_proxy",	print_addr},
	{ SADB_EXT_KEY_AUTH,		"key_auth",		print_key},
	{ SADB_EXT_KEY_ENCRYPT,		"key_encrypt",		print_key},
d415 1
a415 1
		if ((size_t)((u_int8_t *)next - (u_int8_t *)ext) < 
@


1.15
log
@convert pfkey to ipsec_rule and use ipsecctl_print_rule() when dumping
the in-kernel SAs. this way we produce the same output as rule loading
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.14 2006/06/01 06:50:58 deraadt Exp $	*/
d412 2
a413 1
	    alg++)
d415 4
d456 1
a456 1
	printf("replay %u", prop->sadb_prop_replay);
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.13 2006/05/31 05:38:45 hshoexer Exp $	*/
d61 1
a61 1
static void	print_ext(struct sadb_ext *, struct sadb_msg *, int);
d246 1
a246 1
print_ext(struct sadb_ext *ext, struct sadb_msg *msg, int opts)
a249 4
	if (ext->sadb_ext_type == SADB_EXT_ADDRESS_SRC ||
	    ext->sadb_ext_type == SADB_EXT_ADDRESS_DST)
		return;

d255 1
a255 5

	if (!(opts & IPSECCTL_OPT_VERBOSE) && (entry->id != SADB_EXT_SA))
		return;
	if (entry->id != SADB_EXT_SA)
		printf("\t%s: ", entry->name);
a268 17
	/* tunnel/transport is only meaningful for esp/ah/ipcomp */
	if (msg->sadb_msg_satype != SADB_X_SATYPE_TCPSIGNATURE) {
		if (sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
			printf("tunnel ");
		else
			printf("transport ");
	}

	if (extensions[SADB_EXT_ADDRESS_SRC]) {
		printf("from ");
		print_addr(extensions[SADB_EXT_ADDRESS_SRC], msg);
	}
	if (extensions[SADB_EXT_ADDRESS_DST]) {
		printf(" to ");
		print_addr(extensions[SADB_EXT_ADDRESS_DST], msg);
	}
	printf(" spi 0x%08x", ntohl(sa->sadb_sa_spi));
d270 11
a280 10
		printf(" comp %s", lookup_name(comp_types,
		    sa->sadb_sa_encrypt));
	else {
		if (sa->sadb_sa_encrypt)
			printf(" enc %s", lookup_name(enc_types,
			    sa->sadb_sa_encrypt));
		if (sa->sadb_sa_auth)
			printf(" auth %s", lookup_name(auth_types,
			    sa->sadb_sa_auth));
	}
d545 2
a546 2
void
pfkey_print_sa(struct sadb_msg *msg, int opts)
d548 2
a549 1
	int		 i;
d551 16
a566 8
	setup_extensions(msg);

	printf("%s ", lookup_name(sa_types, msg->sadb_msg_satype));
	for (i = 0; i < SADB_EXT_MAX; i++)
		if (extensions[i])
			print_ext(extensions[i], msg, opts);

	fflush(stdout);
d570 1
a570 1
monitor_sa(struct sadb_ext *ext, struct sadb_msg *msg)
d572 2
a573 1
	struct sadb_sa *sa = (struct sadb_sa *) ext;
d575 5
a579 12
	if (msg->sadb_msg_satype == SADB_X_SATYPE_IPCOMP)
		printf("cpi 0x%8.8x comp %s\n",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(comp_types, sa->sadb_sa_encrypt));
	else
		printf("spi 0x%8.8x auth %s enc %s\n",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(auth_types, sa->sadb_sa_auth),
		    lookup_name(enc_types, sa->sadb_sa_encrypt));
	printf("\t\tstate %s replay %u flags %u",
	    lookup_name(states, sa->sadb_sa_state),
	    sa->sadb_sa_replay, sa->sadb_sa_flags);
d582 3
a584 2
static void
monitor_ext(struct sadb_ext *ext, struct sadb_msg *msg)
d586 9
a594 1
	struct idname *entry;
d596 24
a619 3
	if ((entry = lookup(ext_types, ext->sadb_ext_type)) == NULL) {
		printf("unknown ext: type %u len %u\n",
		    ext->sadb_ext_type, ext->sadb_ext_len);
d622 74
a695 9
	printf("\t%s: ", entry->name);
	if (entry->func == print_sa)
		monitor_sa(ext, msg);
	else if (entry->func != NULL)
		(*entry->func)(ext, msg);
	else
		printf("type %u len %u",
		    ext->sadb_ext_type, ext->sadb_ext_len);
	printf("\n");
d717 1
a717 1
			monitor_ext(extensions[i], msg);
@


1.13
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.12 2006/05/31 05:36:06 msf Exp $	*/
d580 1
a580 1
	
d652 1
a652 1
	
@


1.12
log
@shuffle some newlines to make all the formatting work again

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.11 2006/05/30 21:56:05 msf Exp $	*/
d587 1
a587 1
        struct sadb_sa *sa = (struct sadb_sa *) ext;
d589 12
a600 12
        if (msg->sadb_msg_satype == SADB_X_SATYPE_IPCOMP)
                printf("cpi 0x%8.8x comp %s\n",
                    ntohl(sa->sadb_sa_spi),
                    lookup_name(comp_types, sa->sadb_sa_encrypt));
        else
                printf("spi 0x%8.8x auth %s enc %s\n",
                    ntohl(sa->sadb_sa_spi),
                    lookup_name(auth_types, sa->sadb_sa_auth),
                    lookup_name(enc_types, sa->sadb_sa_encrypt));
        printf("\t\tstate %s replay %u flags %u",
            lookup_name(states, sa->sadb_sa_state),
            sa->sadb_sa_replay, sa->sadb_sa_flags);
d606 1
a606 1
        struct idname *entry;
d608 13
a620 13
        if ((entry = lookup(ext_types, ext->sadb_ext_type)) == NULL) {
                printf("unknown ext: type %u len %u\n",
                    ext->sadb_ext_type, ext->sadb_ext_len);
                return;
        }
        printf("\t%s: ", entry->name);
        if (entry->func == print_sa)
                monitor_sa(ext, msg);
        else if (entry->func != NULL)
                (*entry->func)(ext, msg);
        else
                printf("type %u len %u",
                    ext->sadb_ext_type, ext->sadb_ext_len);
d657 1
a657 1
		printf("%02x ", *sp); 
@


1.11
log
@implement monitor mode for ipsecctl. worked on with markus@@

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.10 2005/12/21 01:40:23 millert Exp $	*/
d267 1
a267 1
		printf("type %u len %u\n",
d269 1
a304 1
	printf("\n");
a352 1
	printf("\n");
d361 1
a361 1
	printf("alloc %u bytes %llu add %llu first %llu\n",
d420 1
a420 1
	printf("\t\t%s iv %u min %u max %u\n",
d447 1
a447 1
	    "\t\tusetime hard %llu soft %llu\n",
d475 1
a475 1
	printf("replay %u\n", prop->sadb_prop_replay);
d489 1
a489 1
	printf("dpd %u sens_level %u integ_level %u\n",
d501 1
a501 1
	printf("min 0x%8.8x max 0x%8.8x\n",
d511 1
a511 1
	printf("type %s id %llu: %s\n",
d522 1
a522 1
	printf("type %s\n",
d531 1
a531 1
	printf("type %s\n",
d541 1
a541 1
	printf("seq %u\n", x_policy->sadb_x_policy_seq);
d550 1
a550 1
	printf("udpencap port %u\n", ntohs(x_udpencap->sadb_x_udpencap_port));
d580 1
@


1.10
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.9 2005/12/12 23:24:10 hshoexer Exp $	*/
d43 7
d64 1
d82 1
d87 16
d111 19
d207 18
d369 137
d538 9
d554 2
a555 2
void
pfkey_print_sa(struct sadb_msg *msg, int opts)
a557 1
	int		 i;
d560 2
a561 2

	printf("%s ", lookup_name(sa_types, msg->sadb_msg_satype));
d568 6
d575 3
d582 79
@


1.9
log
@use ARGSUSED1 here
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.8 2005/11/13 18:39:19 deraadt Exp $	*/
a27 1
#include <sys/errno.h>
d38 1
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.7 2005/11/12 12:00:53 hshoexer Exp $	*/
d245 1
d277 1
d294 1
d307 1
d318 1
d328 1
d337 1
@


1.7
log
@handle transport/tunnel mode
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.6 2005/10/30 19:50:24 hshoexer Exp $	*/
d68 1
a68 1
	{ SADB_EXT_SA,			"sa",			print_sa},
d79 1
a79 1
	{ SADB_X_EXT_LOCAL_CREDENTIALS, "local_cred",		print_cred },
@


1.6
log
@add support for ipcomp.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.5 2005/07/09 21:54:12 hshoexer Exp $	*/
d214 8
a241 2
	if (sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
		printf(" tunnel");
@


1.5
log
@make sure, output of -ss is identical to syntax for SA rules
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.4 2005/06/27 21:26:02 hshoexer Exp $	*/
d222 1
d224 2
a225 3
		printf("cpi 0x%8.8x %s",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(comp_types, sa->sadb_sa_encrypt));
a226 1
		printf(" spi 0x%8.8x", ntohl(sa->sadb_sa_spi));
d228 2
a229 2
			printf(" %s",
			    lookup_name(enc_types, sa->sadb_sa_encrypt));
d231 2
a232 2
			printf(" %s",
			    lookup_name(auth_types, sa->sadb_sa_auth));
@


1.4
log
@improve output for SAs

while around, do small whitesparce cleanup
added a missing "static"
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.3 2005/06/06 07:15:46 hshoexer Exp $	*/
a213 11
	if (msg->sadb_msg_satype == SADB_X_SATYPE_IPCOMP)
		printf("cpi 0x%8.8x %s",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(comp_types, sa->sadb_sa_encrypt));
	else
		printf("spi 0x%8.8x %s %s",
		    ntohl(sa->sadb_sa_spi),
		    lookup_name(enc_types, sa->sadb_sa_encrypt),
		    lookup_name(auth_types, sa->sadb_sa_auth));
	if (sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
		printf(" tunnel");
d215 1
a215 1
		printf(" from ");
d222 15
@


1.3
log
@parse local/remote credential payload types.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.2 2005/05/27 05:48:10 hshoexer Exp $	*/
d58 2
d188 4
d198 1
a198 1
	if (!(opts & IPSECCTL_OPT_VERBOSE) && entry->id != SADB_EXT_SA)
d212 1
a212 1
	struct sadb_sa *sa = (struct sadb_sa *) ext;
d215 1
a215 1
		printf("cpi 0x%8.8x comp %s",
d219 1
a219 1
		printf("spi 0x%8.8x auth %s enc %s",
d221 2
a222 2
		    lookup_name(auth_types, sa->sadb_sa_auth),
		    lookup_name(enc_types, sa->sadb_sa_encrypt));
d225 8
d239 1
a239 1
	struct sadb_address *addr = (struct sadb_address *) ext;
a264 1
	printf("\n");
d270 1
a270 1
	struct sadb_key *key = (struct sadb_key *) ext;
d286 1
a286 1
	struct sadb_lifetime *life = (struct sadb_lifetime *) ext;
d298 1
a298 1
	struct sadb_ident *ident = (struct sadb_ident *) ext;
d308 1
a308 1
	struct sadb_x_cred *x_cred = (struct sadb_x_cred *) ext;
d314 1
a314 1
void
d317 1
a317 1
	struct sadb_x_cred *x_cred = (struct sadb_x_cred *) ext;
d325 1
a325 1
	struct sadb_x_udpencap *x_udpencap = (struct sadb_x_udpencap *) ext;
d334 3
d344 5
a348 1
		print_ext(ext, msg, opts);
@


1.2
log
@remove unused table
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.1 2005/05/27 05:19:55 hshoexer Exp $	*/
d49 1
d77 2
d112 6
d299 8
@


1.1
log
@Support for dumping the SADB.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkdump.c,v 1.16 2005/05/25 05:51:13 markus Exp $	*/
a148 8
	{ 0,				NULL,			NULL }
};

struct idname states[] = {
	{ SADB_SASTATE_LARVAL,		"larval",		NULL },
	{ SADB_SASTATE_MATURE,		"mature",		NULL },
	{ SADB_SASTATE_DYING,		"dying",		NULL },
	{ SADB_SASTATE_DEAD,		"dead",			NULL },
@

