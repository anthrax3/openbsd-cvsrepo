head	1.82;
access;
symbols
	OPENBSD_6_2:1.82.0.2
	OPENBSD_6_2_BASE:1.82
	OPENBSD_6_1:1.81.0.4
	OPENBSD_6_1_BASE:1.81
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.79.0.6
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.77.0.12
	OPENBSD_5_6_BASE:1.77
	OPENBSD_5_5:1.77.0.10
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.77.0.6
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.77.0.4
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.77.0.2
	OPENBSD_5_2_BASE:1.77
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.2
	OPENBSD_5_0:1.73.0.12
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.73.0.10
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.73.0.8
	OPENBSD_4_8_BASE:1.73
	OPENBSD_4_7:1.73.0.4
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.73.0.6
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.73.0.2
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.71.0.2
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.67.0.4
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.67.0.2
	OPENBSD_4_1_BASE:1.67
	OPENBSD_4_0:1.59.0.2
	OPENBSD_4_0_BASE:1.59
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26;
locks; strict;
comment	@ * @;


1.82
date	2017.04.19.15.59.38;	author bluhm;	state Exp;
branches;
next	1.81;
commitid	CiHS8CSu2u0AMgvM;

1.81
date	2017.03.02.17.44.32;	author bluhm;	state Exp;
branches;
next	1.80;
commitid	aaLSueYcyfhIr3Fh;

1.80
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.79;
commitid	82PdNqu2kKAuXPfA;

1.79
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	Uu5nFG3wCl0LACBb;

1.78
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.77;
commitid	dOUqRDzYiPQXkCLL;

1.77
date	2012.07.05.09.02.20;	author mikeb;	state Exp;
branches;
next	1.76;

1.76
date	2012.06.29.15.01.07;	author mikeb;	state Exp;
branches;
next	1.75;

1.75
date	2011.11.08.16.49.32;	author jmc;	state Exp;
branches;
next	1.74;

1.74
date	2011.11.08.13.26.06;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2009.01.27.15.32.08;	author bluhm;	state Exp;
branches;
next	1.72;

1.72
date	2009.01.20.14.36.19;	author mpf;	state Exp;
branches;
next	1.71;

1.71
date	2008.07.21.14.37.53;	author bluhm;	state Exp;
branches;
next	1.70;

1.70
date	2008.07.01.15.00.53;	author bluhm;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.13.16.35.18;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2007.08.21.18.44.52;	author hshoexer;	state Exp;
branches;
next	1.67;

1.67
date	2007.02.19.08.50.43;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.10.13.45.01;	author jmc;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.03.12.17.43;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.30.15.51.28;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.10.14.49.49;	author hshoexer;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.01.03.12.14;	author mcbride;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.01.03.10.02;	author mcbride;	state Exp;
branches;
next	1.60;

1.60
date	2006.09.19.21.29.47;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2006.08.31.19.01.16;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.08.23.05.14;	author hshoexer;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.02.18.04.17;	author hshoexer;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.02.09.37.34;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.02.05.59.31;	author hshoexer;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.01.17.32.20;	author naddy;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.01.16.41.38;	author hshoexer;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.01.16.13.01;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.01.15.47.26;	author hshoexer;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.01.06.20.30;	author todd;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.01.04.12.34;	author hshoexer;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.30.21.56.05;	author msf;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.29.18.43.36;	author hshoexer;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.31.14.24.15;	author hshoexer;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.31.13.13.51;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.30.12.44.20;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.22.16.01.23;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.01.12.38.47;	author hshoexer;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.17.05.39.23;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.16.23.57.20;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.06.16.55.28;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.06.14.27.57;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.01.10.36.42;	author hshoexer;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.30.12.42.05;	author hshoexer;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.21.09.52.22;	author hshoexer;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.13.18.28.03;	author hshoexer;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.12.16.41.39;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.12.12.00.53;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.06.22.51.51;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.06.10.52.27;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.30.19.50.23;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.28.07.18.47;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.16.19.52.19;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.22.17.26.46;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.09.12.37.45;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.08.13.29.00;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.08.09.15.09;	author hshoexer;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.05.14.39.02;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.03.15.27.01;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.02.15.47.25;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.24.10.06.38;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.09.21.41.08;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.09.21.12.07;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.07.22.00.36;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.07.21.13.00;	author hshoexer;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.07.21.00.07;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.30.19.13.57;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.30.19.05.27;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.30.18.27.14;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.27.19.55.21;	author hshoexer;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.27.15.33.49;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.27.05.19.55;	author hshoexer;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.25.17.10.26;	author hshoexer;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.23.22.48.17;	author kjell;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.23.20.25.54;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.12.06.57.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.05.07.14.00;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.04.22.22.55;	author hshoexer;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.04.22.19.50;	author hshoexer;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Rename all SA groups to bundles consistently.  The first kernel
commit in 2000 that introduced the features already called them SA
bundles.  The word group is taken by Diffie-Hellman, reusing it
causes confusion.
OK hshoexer@@
@
text
@/*	$OpenBSD: ipsecctl.c,v 1.81 2017/03/02 17:44:32 bluhm Exp $	*/
/*
 * Copyright (c) 2004, 2005 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <net/pfkeyv2.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ipsecctl.h"
#include "pfkey.h"

int		 ipsecctl_rules(char *, int);
FILE		*ipsecctl_fopen(const char *, const char *);
int		 ipsecctl_commit(int, struct ipsecctl *);
int		 ipsecctl_add_rule(struct ipsecctl *, struct ipsec_rule *);
void		 ipsecctl_free_rule(struct ipsec_rule *);
void		 ipsecctl_print_addr(struct ipsec_addr_wrap *);
void		 ipsecctl_print_proto(u_int8_t);
void		 ipsecctl_print_port(u_int16_t, const char *);
void		 ipsecctl_print_key(struct ipsec_key *);
void		 ipsecctl_print_flow(struct ipsec_rule *, int);
void		 ipsecctl_print_sa(struct ipsec_rule *, int);
void		 ipsecctl_print_sabundle(struct ipsec_rule *, int);
int		 ipsecctl_flush(int);
void		 ipsecctl_get_rules(struct ipsecctl *);
void		 ipsecctl_print_title(char *);
void		 ipsecctl_show_flows(int);
void		 ipsecctl_show_sas(int);
int		 ipsecctl_monitor(int);
void		 usage(void);
const char	*ipsecctl_lookup_option(char *, const char **);
static int	 unmask(struct ipsec_addr *, sa_family_t);
int		 sacompare(const void *, const void *);

const char	*showopt;
char		*isakmpd_fifo = "/var/run/isakmpd.fifo";

int		 first_title = 1;

static const char *showopt_list[] = {
	"flow", "sa", "all", NULL
};

static const char *direction[] = {"?", "in", "out"};
static const char *flowtype[] = {"?", "use", "acquire", "require", "deny",
    "bypass", "dontacq"};
static const char *satype[] = {"?", "esp", "ah", "ipcomp", "tcpmd5", "ipip"};
static const char *tmode[] = {"?", "transport", "tunnel"};
static const char *auth[] = {"?", "psk", "rsa"};

struct sad {
	struct sadb_msg	*sad_msg;
	u_int32_t	 sad_spi;
};

int
sacompare(const void *va, const void *vb)
{
	const struct sad *a = va, *b = vb;

	if (a->sad_spi < b->sad_spi)
		return (-1);
	if (a->sad_spi > b->sad_spi)
		return (1);
	return (0);
}

int
ipsecctl_rules(char *filename, int opts)
{
	struct ipsecctl		 ipsec;
	struct ipsec_rule	*rp;
	int			 action, error = 0;

	bzero(&ipsec, sizeof(ipsec));
	ipsec.opts = opts;
	TAILQ_INIT(&ipsec.rule_queue);
	TAILQ_INIT(&ipsec.bundle_queue);

	if (parse_rules(filename, &ipsec) < 0) {
		warnx("Syntax error in config file: ipsec rules not loaded");
		error = 1;
	} else {
		if (opts & IPSECCTL_OPT_DELETE)
			action = ACTION_DELETE;
		else
			action = ACTION_ADD;

		if ((opts & IPSECCTL_OPT_NOACTION) == 0)
			error = ipsecctl_commit(action, &ipsec);

	}

	/* This also frees the rules in ipsec.bundle_queue. */
	while ((rp = TAILQ_FIRST(&ipsec.rule_queue))) {
		TAILQ_REMOVE(&ipsec.rule_queue, rp, rule_entry);
		ipsecctl_free_rule(rp);
	}

	return (error);
}

FILE *
ipsecctl_fopen(const char *name, const char *mode)
{
	struct stat	 st;
	FILE		*fp;

	fp = fopen(name, mode);
	if (fp == NULL)
		return (NULL);

	if (fstat(fileno(fp), &st)) {
		fclose(fp);
		return (NULL);
	}
	if (S_ISDIR(st.st_mode)) {
		fclose(fp);
		errno = EISDIR;
		return (NULL);
	}
	return (fp);
}

int
ipsecctl_commit(int action, struct ipsecctl *ipsec)
{
	struct ipsec_rule	*rp;
	int			 ret = 0;

	if (pfkey_init() == -1)
		errx(1, "ipsecctl_commit: failed to open PF_KEY socket");

	TAILQ_FOREACH(rp, &ipsec->rule_queue, rule_entry) {
		if (rp->type & RULE_IKE) {
			if (ike_ipsec_establish(action, rp, isakmpd_fifo) ==
			    -1) {
				warnx("failed to %s ike rule %d",
				    action == ACTION_DELETE ? "delete" : "add",
				    rp->nr);
				ret = 2;
			}
		} else {
			if (pfkey_ipsec_establish(action, rp) == -1) {
				warnx("failed to %s rule %d",
				    action == ACTION_DELETE ? "delete" : "add",
				    rp->nr);
				ret = 2;
			}
		}
	}

	return (ret);
}

int
ipsecctl_add_rule(struct ipsecctl *ipsec, struct ipsec_rule *r)
{
	TAILQ_INSERT_TAIL(&ipsec->rule_queue, r, rule_entry);

	if ((ipsec->opts & IPSECCTL_OPT_VERBOSE) && !(ipsec->opts &
	    IPSECCTL_OPT_SHOW))
		ipsecctl_print_rule(r, ipsec->opts);

	return (0);
}

void
ipsecctl_free_rule(struct ipsec_rule *rp)
{
	if (rp->src) {
		free(rp->src->name);
		free(rp->src);
	}
	if (rp->dst) {
		free(rp->dst->name);
		free(rp->dst);
	}
	if (rp->dst2) {
		free(rp->dst2->name);
		free(rp->dst2);
	}
	if (rp->local) {
		free(rp->local->name);
		free(rp->local);
	}
	if (rp->peer) {
		free(rp->peer->name);
		free(rp->peer);
	}
	if (rp->auth) {
		free(rp->auth->srcid);
		free(rp->auth->dstid);
		free(rp->auth);
	}
	if (rp->ikeauth) {
		free(rp->ikeauth->string);
		free(rp->ikeauth);
	}
	free(rp->xfs);
	free(rp->p1xfs);
	free(rp->p2xfs);
	free(rp->p1life);
	free(rp->p2life);
	if (rp->authkey) {
		free(rp->authkey->data);
		free(rp->authkey);
	}
	if (rp->enckey) {
		free(rp->enckey->data);
		free(rp->enckey);
	}
	free(rp->p1name);
	free(rp->p2name);
	free(rp->p2lid);
	free(rp->p2nid);
	free(rp->p2rid);
	free(rp);
}

void
ipsecctl_print_addr(struct ipsec_addr_wrap *ipa)
{
	int		bits;
	char		buf[NI_MAXHOST];

	if (ipa == NULL) {
		printf("?");
		return;
	}
	if (inet_ntop(ipa->af, &ipa->address, buf, sizeof(buf)) == NULL)
		printf("?");
	else
		printf("%s", buf);

	bits = unmask(&ipa->mask, ipa->af);
	if (bits != (ipa->af == AF_INET ? 32 : 128))
		printf("/%d", bits);
}

void
ipsecctl_print_proto(u_int8_t proto)
{
	struct protoent *p;

	if ((p = getprotobynumber(proto)) != NULL)
		printf("%s", p->p_name);
	else
		printf("%u", proto);
}

void
ipsecctl_print_port(u_int16_t port, const char *proto)
{
	struct servent *s;

	if ((s = getservbyport(port, proto)) != NULL)
		printf("%s", s->s_name);
	else
		printf("%u", ntohs(port));
}

void
ipsecctl_print_key(struct ipsec_key *key)
{
	int	i;

	for (i = 0; i < (int)key->len; i++)
		printf("%02x", key->data[i]);
}

void
ipsecctl_print_flow(struct ipsec_rule *r, int opts)
{
	printf("flow %s %s", satype[r->satype], direction[r->direction]);

	if (r->proto) {
		printf(" proto ");
		ipsecctl_print_proto(r->proto);
	}
	printf(" from ");
	ipsecctl_print_addr(r->src);
	if (r->sport) {
		printf(" port ");
		ipsecctl_print_port(r->sport,
		    r->proto == IPPROTO_TCP ? "tcp" : "udp");
	}
	printf(" to ");
	ipsecctl_print_addr(r->dst);
	if (r->dport) {
		printf(" port ");
		ipsecctl_print_port(r->dport,
		    r->proto == IPPROTO_TCP ? "tcp" : "udp");
	}
	if (r->local) {
		printf(" local ");
		ipsecctl_print_addr(r->local);
	}
	if (r->peer) {
		printf(" peer ");
		ipsecctl_print_addr(r->peer);
	}
	if (r->auth) {
		if (r->auth->srcid)
			printf(" srcid %s", r->auth->srcid);
		if (r->auth->dstid)
			printf(" dstid %s", r->auth->dstid);
		if (r->auth->type > 0)
			printf(" %s", auth[r->auth->type]);
	}
	printf(" type %s", flowtype[r->flowtype]);
	printf("\n");
}

/* ARGSUSED1 */
void
ipsecctl_print_sa(struct ipsec_rule *r, int opts)
{
	printf("%s ", satype[r->satype]);
	/* tunnel/transport is only meaningful for esp/ah/ipcomp */
	if (r->satype != IPSEC_TCPMD5 && r->satype != IPSEC_IPIP)
		printf("%s ", tmode[r->tmode]);
	printf("from ");
	ipsecctl_print_addr(r->src);
	printf(" to ");
	ipsecctl_print_addr(r->dst);
	printf(" spi 0x%08x", r->spi);

	if (r->satype != IPSEC_TCPMD5) {
		if (r->xfs && r->xfs->authxf)
			printf(" auth %s", r->xfs->authxf->name);
		if (r->xfs && r->xfs->encxf)
			printf(" enc %s", r->xfs->encxf->name);
		if (r->xfs && r->xfs->compxf)
			printf(" comp %s", r->xfs->compxf->name);
	}
	if (r->authkey && (opts & IPSECCTL_OPT_SHOWKEY)) {
		if (r->satype == IPSEC_TCPMD5)
			printf(" ");
		else
			printf(" \\\n\t");
		printf("authkey 0x");
		ipsecctl_print_key(r->authkey);
	}
	if (r->enckey && (opts & IPSECCTL_OPT_SHOWKEY)) {
		if (r->satype == IPSEC_TCPMD5)
			printf(" ");
		else
			printf(" \\\n\t");
		printf("enckey 0x");
		ipsecctl_print_key(r->enckey);
	}
	printf("\n");
}

void
ipsecctl_print_sabundle(struct ipsec_rule *r, int opts)
{
	printf("[bundle %s to ", satype[r->proto]);
	ipsecctl_print_addr(r->dst);
	printf(" spi 0x%08x with %s to ", r->spi, satype[r->proto2]);
	ipsecctl_print_addr(r->dst2);
	printf(" spi 0x%08x", r->spi2);

	printf("]\n");
}

void
ipsecctl_print_rule(struct ipsec_rule *r, int opts)
{
	if (opts & IPSECCTL_OPT_VERBOSE2)
		printf("@@%d ", r->nr);

	if (r->type & RULE_FLOW)
		ipsecctl_print_flow(r, opts);
	if (r->type & RULE_SA)
		ipsecctl_print_sa(r, opts);
	if (r->type & RULE_IKE)
		ike_print_config(r, opts);
	if (r->type & RULE_BUNDLE)
		ipsecctl_print_sabundle(r, opts);
}

int
ipsecctl_flush(int opts)
{
	if (opts & IPSECCTL_OPT_NOACTION)
		return (0);

	if (pfkey_init() == -1)
		errx(1, "ipsecctl_flush: failed to open PF_KEY socket");

	if (pfkey_ipsec_flush() == -1)
		errx(1, "ipsecctl_flush: failed to flush");

	return (0);
}

void
ipsecctl_get_rules(struct ipsecctl *ipsec)
{
	struct sadb_msg *msg;
	struct ipsec_rule *rule;
	int		 mib[4];
	size_t		 need;
	char		*buf, *lim, *next;

	mib[0] = CTL_NET;
	mib[1] = PF_KEY;
	mib[2] = PF_KEY_V2;
	mib[3] = NET_KEY_SPD_DUMP;

	if (sysctl(mib, 4, NULL, &need, NULL, 0) == -1)
		err(1, "ipsecctl_get_rules: sysctl");
	if (need == 0)
		return;
	if ((buf = malloc(need)) == NULL)
		err(1, "ipsecctl_get_rules: malloc");
	if (sysctl(mib, 4, buf, &need, NULL, 0) == -1)
		err(1, "ipsecctl_get_rules: sysctl");
	lim = buf + need;

	for (next = buf; next < lim; next += msg->sadb_msg_len *
	    PFKEYV2_CHUNK) {
		msg = (struct sadb_msg *)next;
		if (msg->sadb_msg_len == 0)
			break;

		rule = calloc(1, sizeof(struct ipsec_rule));
		if (rule == NULL)
			err(1, "ipsecctl_get_rules: calloc");
		rule->nr = ipsec->rule_nr++;
		rule->type |= RULE_FLOW;

		if (pfkey_parse(msg, rule))
			errx(1, "ipsecctl_get_rules: "
			    "failed to parse PF_KEY message");

		ipsecctl_add_rule(ipsec, rule);
	}

	free(buf);
}

void
ipsecctl_print_title(char *title)
{
	if (!first_title)
		printf("\n");
	first_title = 0;
	printf("%s\n", title);
}

void
ipsecctl_show_flows(int opts)
{
	struct ipsecctl ipsec;
	struct ipsec_rule *rp;

	bzero(&ipsec, sizeof(ipsec));
	ipsec.opts = opts;
	TAILQ_INIT(&ipsec.rule_queue);

	ipsecctl_get_rules(&ipsec);

	if (opts & IPSECCTL_OPT_SHOWALL)
		ipsecctl_print_title("FLOWS:");

	if (TAILQ_FIRST(&ipsec.rule_queue) == 0) {
		if (opts & IPSECCTL_OPT_SHOWALL)
			printf("No flows\n");
		return;
	}

	while ((rp = TAILQ_FIRST(&ipsec.rule_queue))) {
		TAILQ_REMOVE(&ipsec.rule_queue, rp, rule_entry);

		ipsecctl_print_rule(rp, ipsec.opts);

		free(rp->src->name);
		free(rp->src);
		free(rp->dst->name);
		free(rp->dst);
		if (rp->local) {
			free(rp->local->name);
			free(rp->local);
		}
		if (rp->peer) {
			free(rp->peer->name);
			free(rp->peer);
		}
		if (rp->auth) {
			free(rp->auth->srcid);
			free(rp->auth->dstid);
			free(rp->auth);
		}
		free(rp);
	}
}

void
ipsecctl_show_sas(int opts)
{
	struct sadb_msg *msg;
	struct sad	*sad;
	int		 mib[5], sacount, i;
	size_t		 need = 0;
	char		*buf, *lim, *next;

	mib[0] = CTL_NET;
	mib[1] = PF_KEY;
	mib[2] = PF_KEY_V2;
	mib[3] = NET_KEY_SADB_DUMP;
	mib[4] = SADB_SATYPE_UNSPEC;

	if (opts & IPSECCTL_OPT_SHOWALL)
		ipsecctl_print_title("SAD:");

	/* When the SAD is empty we get ENOENT, no need to err(). */
	if (sysctl(mib, 5, NULL, &need, NULL, 0) == -1 && errno != ENOENT)
		err(1, "ipsecctl_show_sas: sysctl");
	if (need == 0) {
		if (opts & IPSECCTL_OPT_SHOWALL)
			printf("No entries\n");
		return;
	}
	if ((buf = malloc(need)) == NULL)
		err(1, "ipsecctl_show_sas: malloc");
	if (sysctl(mib, 5, buf, &need, NULL, 0) == -1)
		err(1, "ipsecctl_show_sas: sysctl");
	sacount = 0;
	lim = buf + need;
	for (next = buf; next < lim;
	    next += msg->sadb_msg_len * PFKEYV2_CHUNK) {
		msg = (struct sadb_msg *)next;
		if (msg->sadb_msg_len == 0)
			break;
		sacount++;
	}
	if ((sad = calloc(sacount, sizeof(*sad))) == NULL)
		err(1, "ipsecctl_show_sas: calloc");
	i = 0;
	for (next = buf; next < lim;
	    next += msg->sadb_msg_len * PFKEYV2_CHUNK) {
		msg = (struct sadb_msg *)next;
		if (msg->sadb_msg_len == 0)
			break;
		sad[i].sad_spi = pfkey_get_spi(msg);
		sad[i].sad_msg = msg;
		i++;
	}
	qsort(sad, sacount, sizeof(*sad), sacompare);
	for (i = 0; i < sacount; i++)
		pfkey_print_sa(sad[i].sad_msg, opts);
	free(sad);
	free(buf);
}

int
ipsecctl_monitor(int opts)
{
	return (pfkey_monitor(opts));
}

__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dFkmnv] [-D macro=value] [-f file]"
	    " [-i fifo] [-s modifier]\n", __progname);
	exit(1);
}

const char *
ipsecctl_lookup_option(char *cmd, const char **list)
{
	if (cmd != NULL && *cmd)
		for (; *list; list++)
			if (!strncmp(cmd, *list, strlen(cmd)))
				return (*list);
	return (NULL);
}

int
main(int argc, char *argv[])
{
	int		 error = 0;
	int		 ch;
	int		 opts = 0;
	char		*rulesopt = NULL;

	if (argc < 2)
		usage();

	while ((ch = getopt(argc, argv, "D:df:Fi:kmnvs:")) != -1) {
		switch (ch) {
		case 'D':
			if (cmdline_symset(optarg) < 0)
				warnx("could not parse macro definition %s",
				    optarg);
			break;

		case 'd':
			opts |= IPSECCTL_OPT_DELETE;
			break;

		case 'f':
			rulesopt = optarg;
			break;

		case 'F':
			opts |= IPSECCTL_OPT_FLUSH;
			break;

		case 'i':
			isakmpd_fifo = optarg;
			break;

		case 'k':
			opts |= IPSECCTL_OPT_SHOWKEY;
			break;

		case 'm':
			opts |= IPSECCTL_OPT_MONITOR;
			break;

		case 'n':
			opts |= IPSECCTL_OPT_NOACTION;
			break;

		case 'v':
			if (opts & IPSECCTL_OPT_VERBOSE)
				opts |= IPSECCTL_OPT_VERBOSE2;
			opts |= IPSECCTL_OPT_VERBOSE;
			break;

		case 's':
			showopt = ipsecctl_lookup_option(optarg, showopt_list);
			if (showopt == NULL) {
				warnx("Unknown show modifier '%s'", optarg);
				usage();
				/* NOTREACHED */
			}
			opts |= IPSECCTL_OPT_SHOW;
			break;

		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (argc != optind) {
		warnx("unknown command line argument: %s ...", argv[optind]);
		usage();
		/* NOTREACHED */
	}
	if (opts & IPSECCTL_OPT_FLUSH)
		if (ipsecctl_flush(opts))
			error = 1;

	if (rulesopt != NULL)
		if (ipsecctl_rules(rulesopt, opts))
			error = 1;

	if (showopt != NULL) {
		switch (*showopt) {
		case 'f':
			ipsecctl_show_flows(opts);
			break;
		case 's':
			ipsecctl_show_sas(opts);
			break;
		case 'a':
			opts |= IPSECCTL_OPT_SHOWALL;
			ipsecctl_show_flows(opts);
			ipsecctl_show_sas(opts);
		}
	}

	if (opts & IPSECCTL_OPT_MONITOR)
		if (ipsecctl_monitor(opts))
			error = 1;

	exit(error);
}

/* ARGSUSED1 */
static int
unmask(struct ipsec_addr *ipa, sa_family_t af)
{
	int		i = 31, j = 0, b = 0;
	u_int32_t	tmp;

	while (j < 4 && ipa->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < 4) {
		tmp = ntohl(ipa->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}
@


1.81
log
@Now that the kernel provides information about IPsec SA bundles,
print them by default.
OK hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.80 2015/12/10 17:27:00 mmcc Exp $	*/
d51 1
a51 1
void		 ipsecctl_print_sagroup(struct ipsec_rule *, int);
d106 1
a106 1
	TAILQ_INIT(&ipsec.group_queue);
d122 1
a122 1
	/* This also frees the rules in ipsec.group_queue. */
d385 1
a385 1
ipsecctl_print_sagroup(struct ipsec_rule *r, int opts)
d387 1
a387 1
	printf("[group %s to ", satype[r->proto]);
d408 2
a409 2
	if (r->type & RULE_GROUP)
		ipsecctl_print_sagroup(r, opts);
@


1.80
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.79 2015/01/16 06:39:58 deraadt Exp $	*/
a386 3
	if (!(opts & IPSECCTL_OPT_VERBOSE2))
		return;

@


1.79
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.78 2014/11/20 14:51:42 krw Exp $	*/
d220 2
a221 4
		if (rp->auth->srcid)
			free(rp->auth->srcid);
		if (rp->auth->dstid)
			free(rp->auth->dstid);
d225 1
a225 2
		if (rp->ikeauth->string)
			free(rp->ikeauth->string);
d228 5
a232 10
	if (rp->xfs)
		free(rp->xfs);
	if (rp->p1xfs)
		free(rp->p1xfs);
	if (rp->p2xfs)
		free(rp->p2xfs);
	if (rp->p1life)
		free(rp->p1life);
	if (rp->p2life)
		free(rp->p2life);
d241 5
a245 10
	if (rp->p1name)
		free(rp->p1name);
	if (rp->p2name)
		free(rp->p2name);
	if (rp->p2lid)
		free(rp->p2lid);
	if (rp->p2nid)
		free(rp->p2nid);
	if (rp->p2rid)
		free(rp->p2rid);
d524 2
a525 4
			if (rp->auth->srcid)
				free(rp->auth->srcid);
			if (rp->auth->dstid)
				free(rp->auth->dstid);
@


1.78
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.77 2012/07/05 09:02:20 mikeb Exp $	*/
a17 1
#include <sys/param.h>
@


1.77
log
@don't output "esn" string in the rule section as we can't use the
keyword in the grammar to create a esn-enabled rule (no reason to
do so for manual sa configuration).  instead decode sa flags so
that we can also watch changes happening in the realtime with the
monitor mode.  prompted and ok by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.76 2012/06/29 15:01:07 mikeb Exp $	*/
a36 1
#include <netdb.h>
@


1.76
log
@Print esn flag when dumping SAs with ESN enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.75 2011/11/08 16:49:32 jmc Exp $	*/
a369 2
	if (r->esn)
		printf(" esn");
@


1.75
log
@- put -i in the right place
- prevent an erroneous space in the formatting of -D
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.74 2011/11/08 13:26:06 henning Exp $	*/
d363 1
a363 1
	/* tunnel/transport is only meaningful esp/ah/ipcomp */
d370 2
@


1.74
log
@allow the path to isakmpd's fifo to be specified (aka changed) on the
command line, ok mikeb sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.73 2009/01/27 15:32:08 bluhm Exp $	*/
d619 1
a619 1
	    " [-s modifier] [-i fifo]\n", __progname);
@


1.73
log
@A warning text in ipsecctl was used twice.  Make the messages unique
for easier debugging.

ok grunk@@, hshoexer@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.72 2009/01/20 14:36:19 mpf Exp $	*/
d66 1
d166 2
a167 1
			if (ike_ipsec_establish(action, rp) == -1) {
d619 1
a619 1
	    " [-s modifier]\n", __progname);
d644 1
a644 1
	while ((ch = getopt(argc, argv, "D:df:Fkmnvs:")) != -1) {
d662 4
@


1.72
log
@Add support to isakmpd(8) and ipsecctl(8) to install SA's with a
different source network than we have negotiated with a peer.
This enables us to do nat/binat on the enc(4) interface.
Very useful to work around rfc 1918 collisions.
Manpage and testing by Mitja Muzenic. Thanks!
OK hshoexer@@, markus@@. "I like it" todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.71 2008/07/21 14:37:53 bluhm Exp $	*/
d166 1
a166 1
				warnx("failed to %s rule %d",
@


1.71
log
@Free the rules in the rule_queue also if ipsecctl is called with
the -n switch.  This triggers malloc related bugs during the regress
tests.
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.70 2008/07/01 15:00:53 bluhm Exp $	*/
d255 2
@


1.70
log
@Isakmpd acquire mode did not work with a config generated from
ipsec.conf.  The config created by isakmpd dynamically was different
from the config that ipsecctl generated out of ipsec.conf.

Both config formats are changed so that they match.  One needs a
passive ike line and a require flow line with the same parameters
in the ipsec.conf.  Then the acquire message generated by the kernel
will trigger isakmpd to generate a config that matches the one that
ipsecctl generated from the ike line.

ok hshoexer, 'sounds good' todd
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.69 2007/10/13 16:35:18 deraadt Exp $	*/
d100 3
a102 2
	struct ipsecctl	 ipsec;
	int		 action, error = 0;
d120 7
d128 1
d163 1
a163 3
	while ((rp = TAILQ_FIRST(&ipsec->rule_queue))) {
		TAILQ_REMOVE(&ipsec->rule_queue, rp, rule_entry);

a178 1
		ipsecctl_free_rule(rp);
@


1.69
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.68 2007/08/21 18:44:52 hshoexer Exp $	*/
d243 2
@


1.68
log
@no need to include both sys/types.h and params.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.67 2007/02/19 08:50:43 hshoexer Exp $	*/
a64 1
const char	*infile;	/* Used by parse.y */
a99 1
	FILE		*fin;
d108 1
a108 12
	if (strcmp(filename, "-") == 0) {
		fin = stdin;
		infile = "stdin";
	} else {
		if ((fin = ipsecctl_fopen(filename, "r")) == NULL) {
			warn("%s", filename);
			return (1);
		}
		infile = filename;
	}

	if (parse_rules(fin, &ipsec) < 0) {
a118 5
	}

	if (fin != stdin) {
		fclose(fin);
		fin = NULL;
@


1.67
log
@do not display empty authkey/enckey line when -k option is not
specified.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.66 2007/01/10 13:45:01 jmc Exp $	*/
a17 1
#include <sys/types.h>
@


1.66
log
@add -k to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.65 2007/01/03 12:17:43 markus Exp $	*/
d387 1
a387 1
	if (r->authkey) {
d395 1
a395 1
	if (r->enckey) {
@


1.65
log
@do not print secret keys by default, -k restores old behaviour; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.64 2006/11/30 15:51:28 markus Exp $	*/
d625 1
a625 1
	fprintf(stderr, "usage: %s [-dFmnv] [-D macro=value] [-f file]"
@


1.64
log
@handle multiple SAs with different same src/dst but different port;
store IKE connection string and phase2 IDs in the ipsec rule;
cleanup internal API: pass rules around instead of rule members;
report Brian Candler; fix with hshoexer, msf; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.63 2006/11/10 14:49:49 hshoexer Exp $	*/
d651 1
a651 1
	while ((ch = getopt(argc, argv, "D:df:Fmnvs:")) != -1) {
d658 1
d662 1
d669 4
@


1.63
log
@When using -vv, also show grouped SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.62 2006/11/01 03:12:14 mcbride Exp $	*/
d262 6
@


1.62
log
@KNF unrelated to previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.61 2006/11/01 03:10:02 mcbride Exp $	*/
d54 1
d401 15
d427 2
@


1.61
log
@Add support for aggressive mode (from the k2k6 IPsec hackathon).

ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.60 2006/09/19 21:29:47 markus Exp $	*/
d90 1
a90 1
	
@


1.60
log
@sort SAs by spi; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.59 2006/08/31 19:01:16 ho Exp $	*/
d245 8
a252 8
	if (rp->mmxfs)
		free(rp->mmxfs);
	if (rp->qmxfs)
		free(rp->qmxfs);
	if (rp->mmlife)
		free(rp->mmlife);
	if (rp->qmlife)
		free(rp->qmlife);
@


1.59
log
@Security Association Database is abbreviated 'SAD' (RFC 2401 et al), not 'SADB'. jmc@@, hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.58 2006/06/08 23:05:14 hshoexer Exp $	*/
d63 1
d81 17
d536 2
a537 1
	int		 mib[5];
d562 1
d569 1
a569 1
		pfkey_print_sa(msg, opts);
d571 16
a586 1

@


1.58
log
@fix usage, make synopsis more pretty.  noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.57 2006/06/02 18:04:17 hshoexer Exp $	*/
d529 1
a529 1
		ipsecctl_print_title("SADB:");
d531 1
a531 1
	/* When the SADB is empty we get ENOENT, no need to err(). */
@


1.57
log
@exit(2) when loading of rules did work partially.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.56 2006/06/02 09:37:34 markus Exp $	*/
d566 1
a566 1
	fprintf(stderr, "usage: %s [-dFnv] [-D macro=value] [-f file]"
@


1.56
log
@add trailing \ when printing multiple lines for an SA, this way
the output of ispecctl matches its input
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.55 2006/06/02 05:59:31 hshoexer Exp $	*/
d113 1
a113 2
			if (ipsecctl_commit(action, &ipsec))
				err(1, NULL);
d148 2
a149 1
	struct ipsec_rule *rp;
d158 1
a158 1
			if (ike_ipsec_establish(action, rp) == -1)
d162 2
d165 1
a165 1
			if (pfkey_ipsec_establish(action, rp) == -1)
d169 2
d175 1
a175 1
	return (0);
@


1.55
log
@allow to specify phase 1 and 2 lifetimes.  Right now, these values
can only be set globally (ie. Default-phase-[12]-lifetime).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.54 2006/06/01 17:32:20 naddy Exp $	*/
d362 1
a362 1
			printf("\n\t");
d370 1
a370 1
			printf("\n\t");
@


1.54
log
@Support flows with port modifiers for proto tcp/udp, e.g.
flow proto udp from 1.2.3.4 port ntp to 5.6.7.8

ok hshoexer@@ msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.53 2006/06/01 16:41:38 hshoexer Exp $	*/
d223 8
@


1.53
log
@more to free, needed for SA grouping.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.52 2006/06/01 16:13:01 markus Exp $	*/
d50 1
d266 11
d296 5
d303 5
@


1.52
log
@convert pfkey to ipsec_rule and use ipsecctl_print_rule() when dumping
the in-kernel SAs. this way we produce the same output as rule loading
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.51 2006/06/01 15:47:26 hshoexer Exp $	*/
d188 12
a199 6
	/* src and dst are always used. */
	free(rp->src->name);
	free(rp->src);
	free(rp->dst->name);
	free(rp->dst);

@


1.51
log
@Prepare for SA grouping.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.50 2006/06/01 06:20:30 todd Exp $	*/
a52 1
void		 ipsecctl_print_rule(struct ipsec_rule *, int);
@


1.50
log
@correct error messages to match calloc where appropriate
ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.49 2006/06/01 04:12:34 hshoexer Exp $	*/
d90 1
@


1.49
log
@rename list link for ipsec_rule structures from "entries" to "rule_entry".
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.48 2006/05/30 21:56:05 msf Exp $	*/
d402 1
a402 1
			err(1, "ipsecctl_get_rules: malloc");
@


1.48
log
@implement monitor mode for ipsecctl. worked on with markus@@

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.47 2006/05/29 18:43:36 hshoexer Exp $	*/
d154 1
a154 1
		TAILQ_REMOVE(&ipsec->rule_queue, rp, entries);
d176 1
a176 1
	TAILQ_INSERT_TAIL(&ipsec->rule_queue, r, entries);
d447 1
a447 1
		TAILQ_REMOVE(&ipsec.rule_queue, rp, entries);
@


1.47
log
@add ipsecctl_free_rule() for cleaning up rules.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.46 2006/03/31 14:24:15 hshoexer Exp $	*/
d59 1
d515 6
d552 1
a552 1
	while ((ch = getopt(argc, argv, "D:df:Fnvs:")) != -1) {
d570 4
d627 4
@


1.46
log
@wenn dumping rules always show type, srcid and dstid (if set).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.45 2006/03/31 13:13:51 markus Exp $	*/
d47 1
d166 1
a166 38

		/* src and dst are always used. */
		free(rp->src->name);
		free(rp->src);
		free(rp->dst->name);
		free(rp->dst);

		if (rp->local) {
			free(rp->local->name);
			free(rp->local);
		}
		if (rp->peer) {
			free(rp->peer->name);
			free(rp->peer);
		}
		if (rp->auth) {
			if (rp->auth->srcid)
				free(rp->auth->srcid);
			if (rp->auth->dstid)
				free(rp->auth->dstid);
			free(rp->auth);
		}
		if (rp->ikeauth) {
			if (rp->ikeauth->string)
				free(rp->ikeauth->string);
			free(rp->ikeauth);
		}
		if (rp->xfs)
			free(rp->xfs);
		if (rp->authkey) {
			free(rp->authkey->data);
			free(rp->authkey);
		}
		if (rp->enckey) {
			free(rp->enckey->data);
			free(rp->enckey);
		}
		free(rp);
d182 42
@


1.45
log
@allow specification of encapsulated protocol for flows; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.44 2006/03/30 12:44:20 markus Exp $	*/
d281 7
a287 11

	if (opts & IPSECCTL_OPT_VERBOSE) {
		if (r->auth) {
			if (r->auth->srcid)
				printf("\n\tsrcid %s", r->auth->srcid);
			if (r->auth->dstid)
				printf("\n\tdstid %s", r->auth->dstid);
			if (r->auth->type > 0)
				printf("\n\t%s", auth[r->auth->type]);
		}
		printf("\n\ttype %s", flowtype[r->flowtype]);
d289 1
@


1.44
log
@allow specification of outer local ips in flows (SADB_EXT_ADDRESS_SRC); ok hshoexer, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.43 2006/03/22 16:01:23 reyk Exp $	*/
d38 1
d48 1
d74 1
a74 1
static const char *proto[] = {"?", "esp", "ah", "ipcomp", "tcpmd5", "ipip"};
d241 11
d263 1
a263 1
	printf("flow %s %s", proto[r->proto], direction[r->direction]);
d265 4
d300 1
a300 1
	printf("%s ", proto[r->proto]);
d302 1
a302 1
	if (r->proto != IPSEC_TCPMD5 && r->proto != IPSEC_IPIP)
d310 1
a310 1
	if (r->proto != IPSEC_TCPMD5) {
d319 1
a319 1
		if (r->proto == IPSEC_TCPMD5)
d327 1
a327 1
		if (r->proto == IPSEC_TCPMD5)
@


1.43
log
@add support for macros in ipsec.conf(5). some bits have already been
there.

requested by david@@
ok hshoexer@@, msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.42 2006/02/01 12:38:47 hshoexer Exp $	*/
d170 4
d256 4
d434 4
@


1.42
log
@noted by lint: include <string.h> instead of <strings.h>, add tow ARGSUSED1
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.41 2006/01/17 05:39:23 reyk Exp $	*/
d487 2
a488 2
	fprintf(stderr, "usage: %s [-dFnv] [-f file] [-s modifier]\n",
	    __progname);
d513 1
a513 1
	while ((ch = getopt(argc, argv, "df:Fnvs:")) != -1) {
d515 5
@


1.41
log
@wrap long lines (no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.40 2006/01/16 23:57:20 reyk Exp $	*/
d36 1
a36 1
#include <strings.h>
d271 1
d583 1
@


1.40
log
@add support for pre-shared keys with "ike esp" using the new keyword
"psk". rsa-sig is recommended and will still be used by default.

ok hshoexer@@, manpage ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.39 2005/12/06 16:55:28 markus Exp $	*/
d377 2
a378 1
			errx(1, "ipsecctl_get_rules: failed to parse PF_KEY message");
@


1.39
log
@more appropriate error messages; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.38 2005/12/06 14:27:57 markus Exp $	*/
d180 5
@


1.38
log
@ipip support: ip-in-ip w/o gif(4); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.37 2005/12/01 10:36:42 hshoexer Exp $	*/
d154 3
a156 1
				warnx("failed to add rule %d", rp->nr);
d159 3
a161 1
				warnx("failed to add rule %d", rp->nr);
@


1.37
log
@do not choke and dump core when printing bypass flows.  noticed by jacob
schlyter.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.36 2005/11/30 12:42:05 hshoexer Exp $	*/
d72 1
a72 1
static const char *proto[] = {"?", "esp", "ah", "ipcomp", "tcpmd5"};
d267 1
a267 1
	if (r->proto != IPSEC_TCPMD5)
@


1.36
log
@handle that pfkey_ipsec_flush() can fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.35 2005/11/21 09:52:22 hshoexer Exp $	*/
d243 4
a246 2
	printf(" peer ");
	ipsecctl_print_addr(r->peer);
d415 4
a418 2
		free(rp->peer->name);
		free(rp->peer);
@


1.35
log
@Fix memory leaks.  From  Andrey Matveev <evol at online dot ptt dot ru>,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.34 2005/11/13 18:28:03 hshoexer Exp $	*/
d323 2
a324 1
	pfkey_ipsec_flush();
@


1.34
log
@fclose() file descriptor of the rule file when we are done with it.
From David Hill <dhill at mindcry dot org>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.33 2005/11/12 16:41:39 deraadt Exp $	*/
d369 2
d462 2
@


1.33
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.32 2005/11/12 12:00:53 hshoexer Exp $	*/
d110 5
@


1.32
log
@handle transport/tunnel mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.31 2005/11/06 22:51:51 hshoexer Exp $	*/
d395 1
a395 1
		
a415 2

	return;
@


1.31
log
@Improved address and address mask handling, derived from pfctl stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.30 2005/11/06 10:52:27 hshoexer Exp $	*/
d73 1
d259 3
@


1.30
log
@better handling of ip addresses, prepare for v6.  Partially derived from diff
by todd@@.  Work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.29 2005/10/30 19:50:23 hshoexer Exp $	*/
d46 1
a46 1
void		 ipsecctl_print_addr(struct ipsec_addr *);
d58 1
d200 1
a200 1
ipsecctl_print_addr(struct ipsec_addr *ipa)
d202 1
d214 3
a216 6
	switch (ipa->af) {
	case AF_INET:
		if (ipa->prefixlen != 32)
			printf("/%d", ipa->prefixlen);
		break;
	}
d554 18
@


1.29
log
@add support for ipcomp.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.28 2005/10/28 07:18:47 hshoexer Exp $	*/
d33 1
d201 1
a201 2
	u_int32_t	mask;
	char		buf[48];
d207 1
a207 1
	if (inet_ntop(ipa->af, &ipa->v4, buf, sizeof(buf)) == NULL)
d212 5
a216 6
	if (ipa->v4mask.mask32 != 0xffffffff) {
		mask = ntohl(ipa->v4mask.mask32);
		if (mask == 0)
			printf("/0");
		else
			printf("/%d", 32 - ffs((int) mask) + 1);
@


1.28
log
@more error message cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.27 2005/10/16 19:52:19 hshoexer Exp $	*/
d271 2
@


1.27
log
@cleanup messages generated by err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.26 2005/08/22 17:26:46 hshoexer Exp $	*/
d139 1
a139 1
		errx(1, "failed to open PF_KEY socket");
d312 1
a312 1
		errx(1, "failed to open PF_KEY socket");
d356 1
a356 1
			errx(1, "failed to parse pfkey message");
@


1.26
log
@Teach ipsecctl to control isakmpd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.25 2005/08/09 12:37:45 hshoexer Exp $	*/
d334 1
a334 1
		err(1, "sysctl");
d338 1
a338 1
		err(1, "malloc");
d340 1
a340 1
		err(1, "sysctl");
d351 1
a351 1
			err(1, "malloc");
d435 1
a435 1
		err(1, "sysctl");
d442 1
a442 1
		err(1, "malloc");
d444 1
a444 1
		err(1, "sysctl");
@


1.25
log
@Rewrite handling of transforms.  Now both ah and esp can be specified and
validated correctly.  Unbreaks ah.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.24 2005/08/08 13:29:00 hshoexer Exp $	*/
d100 1
a100 1
			action = PFK_ACTION_DELETE;
d102 1
a102 1
			action = PFK_ACTION_ADD;
d144 7
a150 2
		if (pfkey_ipsec_establish(action, rp) == -1)
			warnx("failed to add rule %d", rp->nr);
d153 1
d155 1
d158 2
a159 1
		if (rp->peer)
d161 1
a166 1
			}
d168 1
d253 1
d288 1
d301 2
a302 1
	printf("\n");
d397 1
d399 1
d401 1
@


1.24
log
@add crypto transforms and static keying rules
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.23 2005/08/08 09:15:09 hshoexer Exp $	*/
d160 2
d166 4
d257 4
a260 4
		if (r->authxf)
			printf(" auth %s", r->authxf->name);
		if (r->encxf)
			printf(" enc %s", r->encxf->name);
@


1.23
log
@prepare for static keying
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.22 2005/08/05 14:39:02 hshoexer Exp $	*/
d249 7
d257 5
a261 1
		printf(" authkey 0x");
d265 5
a269 1
		printf(" enckey 0x");
@


1.22
log
@prepare for authentication and encryption keys, not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.21 2005/08/03 15:27:01 hshoexer Exp $	*/
a66 1
static const char *ruletype[] = {"?", "flow", "tcpmd5"};
d70 1
a70 1
static const char *proto[] = {"?", "esp", "ah"};
d218 1
a218 1
	printf(" %s %s", proto[r->proto], direction[r->direction]);
d243 2
a244 1
	printf(" from ");
d253 4
a263 2

	printf("%s", ruletype[r->type]);
@


1.21
log
@be more careful when using struct ipsec_auth, might be NULL now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.20 2005/08/02 15:47:25 hshoexer Exp $	*/
d161 3
a163 3
		if (rp->key) {
			free(rp->key->data);
			free(rp->key);
d249 3
a251 3
	if (r->key) {
		printf(" key 0x");
		ipsecctl_print_key(r->key);
@


1.20
log
@Make use of struct ipsec_auth dynamic.
Do not pass IDs to kernel when deleting flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.19 2005/07/24 10:06:38 hshoexer Exp $	*/
d229 8
a236 6
		if (r->auth->srcid)
			printf("\n\tsrcid %s", r->auth->srcid);
		if (r->auth->dstid)
			printf("\n\tdstid %s", r->auth->dstid);
		if (r->auth->type > 0)
			printf("\n\t%s", auth[r->auth->type]);
@


1.19
log
@prepare for combining SAs and flows in one single rule, no functional change
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.18 2005/07/09 21:41:08 hshoexer Exp $	*/
d154 7
a160 4
		if (rp->auth.srcid)
			free(rp->auth.srcid);
		if (rp->auth.dstid)
			free(rp->auth.dstid);
d229 6
a234 6
		if (r->auth.srcid)
			printf("\n\tsrcid %s", r->auth.srcid);
		if (r->auth.dstid)
			printf("\n\tdstid %s", r->auth.dstid);
		if (r->auth.type > 0)
			printf("\n\t%s", auth[r->auth.type]);
d363 7
a369 4
		if (rp->auth.srcid)
			free(rp->auth.srcid);
		if (rp->auth.dstid)
			free(rp->auth.dstid);
@


1.18
log
@it's ok to not specify the key when deleting a tcpmd5 SA
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.17 2005/07/09 21:12:07 hshoexer Exp $	*/
d258 1
a258 2
	switch (r->type) {
	case RULE_FLOW:
d260 1
a260 2
		break;
	case RULE_SA:
a261 3
		break;
	}

d313 1
a313 1
		rule->type = RULE_FLOW;
@


1.17
log
@add support tcpmd5
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.16 2005/07/07 22:00:36 hshoexer Exp $	*/
d244 4
a247 2
	printf(" key 0x");
	ipsecctl_print_key(r->key);
@


1.16
log
@set flow type (use, require, etc.) when a rule is created.  Up to now this was
done while crafting the corresponding pfkey message.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.15 2005/07/07 21:13:00 hshoexer Exp $	*/
d46 3
d67 7
d148 1
d151 3
a153 1
		free(rp->peer);
d158 4
d205 1
a205 1
ipsecctl_print_rule(struct ipsec_rule *r, int opts)
d207 1
a207 6
	static const char *rule[] = {"?", "flow", "tcpmd5"};
	static const char *direction[] = {"?", "in", "out"};
	static const char *type[] = {"?", "use", "acquire", "require", "deny",
	    "bypass", "dontacq"};
	static const char *proto[] = {"?", "esp", "ah"};
	static const char *auth[] = {"?", "psk", "rsa"};
d209 8
a216 2
	if (opts & IPSECCTL_OPT_VERBOSE2)
		printf("@@%d ", r->nr);
a217 2
	printf("%s %s %s", rule[r->type], proto[r->proto],
	    direction[r->direction]);
d232 1
a232 1
		printf("\n\ttype %s", type[r->flowtype]);
d234 31
@


1.15
log
@Do not mix rule types with flow types
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.14 2005/07/07 21:00:07 hshoexer Exp $	*/
d216 1
a216 1
		printf("\n\ttype %s", type[r->type]);
@


1.14
log
@add type for rules; will need this for tcpmd5
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.13 2005/06/30 19:13:57 hshoexer Exp $	*/
d269 1
@


1.13
log
@grmpf, forgot to add -d to usage()...
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.12 2005/06/30 19:05:27 hshoexer Exp $	*/
d190 1
d200 2
a201 1
	printf("flow %s %s", proto[r->proto], direction[r->direction]);
@


1.12
log
@add -d flag for flow deletion.  Enable flow deletion.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.11 2005/06/30 18:27:14 hshoexer Exp $	*/
d367 1
a367 1
	fprintf(stderr, "usage: %s [-Fnv] [-f file] [-s modifier]\n",
@


1.11
log
@Prepare for flow deletion, no functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.10 2005/05/27 19:55:21 hshoexer Exp $	*/
d43 1
a43 1
int		 ipsecctl_commit(struct ipsecctl *);
d69 1
a69 1
	int		 error = 0;
d90 5
d96 1
a96 1
			if (ipsecctl_commit(&ipsec))
d125 1
a125 1
ipsecctl_commit(struct ipsecctl *ipsec)
d135 1
a135 1
		if (pfkey_ipsec_establish(PFK_ACTION_ADD, rp) == -1)
d393 1
a393 1
	while ((ch = getopt(argc, argv, "f:Fnvs:")) != -1) {
d395 3
@


1.10
log
@show flow type (require, use, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.9 2005/05/27 15:33:49 hshoexer Exp $	*/
d130 1
a130 1
		if (pfkey_ipsec_establish(rp) == -1)
@


1.9
log
@use new sysctl to retrieve flow informations including IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.8 2005/05/27 05:19:55 hshoexer Exp $	*/
d186 2
d208 2
a209 1
			printf(" %s", auth[r->auth.type]);
@


1.8
log
@Support for dumping the SADB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.7 2005/05/25 17:10:26 hshoexer Exp $	*/
d228 1
a228 1
	struct ipsec_policy *ipo;
a240 1

a246 1

a247 2
	for (next = buf; next < lim; next += sizeof(struct ipsec_policy)) {
		ipo = (struct ipsec_policy *)next;
d249 5
a253 6
		/*
		 * We only want static policies and are not interrested in
		 * policies attached to sockets.
		 */
		if (ipo->ipo_flags & IPSP_POLICY_SOCKET)
			continue;
d260 2
a261 60
		/* Source and destination. */
		if (ipo->ipo_addr.sen_type == SENT_IP4) {
			rule->src = calloc(1, sizeof(struct ipsec_addr));
			if (rule->src == NULL)
				err(1, "calloc");
			rule->src->af = AF_INET;

			bcopy(&ipo->ipo_addr.sen_ip_src.s_addr, &rule->src->v4,
			    sizeof(struct in_addr));
			bcopy(&ipo->ipo_mask.sen_ip_src.s_addr,
			    &rule->src->v4mask.mask, sizeof(struct in_addr));

			rule->dst = calloc(1, sizeof(struct ipsec_addr));
			if (rule->dst == NULL)
				err(1, "calloc");
			rule->dst->af = AF_INET;

			bcopy(&ipo->ipo_addr.sen_ip_dst.s_addr, &rule->dst->v4,
			    sizeof(struct in_addr));
			bcopy(&ipo->ipo_mask.sen_ip_dst.s_addr,
			    &rule->dst->v4mask.mask, sizeof(struct in_addr));
		} else
			warnx("unsupported encapsulation policy type %d",
			    ipo->ipo_addr.sen_type);

		/* IPsec gateway. */
		if (ipo->ipo_dst.sa.sa_family == AF_INET) {
			rule->peer = calloc(1, sizeof(struct ipsec_addr));
			if (rule->peer == NULL)
				err(1, "calloc");
			rule->peer->af = AF_INET;

			bcopy(&((struct sockaddr_in *)&ipo->ipo_dst.sa)->sin_addr,
			    &rule->peer->v4, sizeof(struct in_addr));

			/* No netmask for peer. */
			memset(&rule->peer->v4mask, 0xff, sizeof(u_int32_t));

			if (ipo->ipo_sproto == IPPROTO_ESP)
				rule->proto = IPSEC_ESP;
			else if (ipo->ipo_sproto == IPPROTO_AH)
				rule->proto = IPSEC_AH;
			else {
				rule->proto = PROTO_UNKNOWN;
				warnx("unsupported protocol %d",
				    ipo->ipo_sproto);
			}

			if (ipo->ipo_addr.sen_direction == IPSP_DIRECTION_OUT)
				rule->direction = IPSEC_OUT;
			else if (ipo->ipo_addr.sen_direction == IPSP_DIRECTION_IN)
				rule->direction = IPSEC_IN;
			else {
				rule->direction = DIRECTION_UNKNOWN;
				warnx("bogus direction %d",
				    ipo->ipo_addr.sen_direction);
			}
		} else
			warnx("unsupported address family %d",
			    ipo->ipo_dst.sa.sa_family);
@


1.7
log
@prepare for new sysctl interface, not used yet
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.6 2005/05/23 22:48:17 kjell Exp $	*/
d49 3
a51 1
void		 ipsecctl_show(int);
d53 1
d56 7
d153 1
a153 1
		ipsecctl_print_rule(r, ipsec->opts & IPSECCTL_OPT_VERBOSE2);
d183 1
a183 1
ipsecctl_print_rule(struct ipsec_rule *r, int verbose)
d189 1
a189 1
	if (verbose)
d200 8
a207 8
	if (r->auth.srcid)
		printf(" srcid %s", r->auth.srcid);
	if (r->auth.dstid)
		printf(" dstid %s", r->auth.dstid);

	if (r->auth.type > 0)
		printf(" %s", auth[r->auth.type]);

d331 10
a340 1
ipsecctl_show(int opts)
d351 9
d363 1
a363 1
		ipsecctl_print_rule(rp, ipsec.opts & IPSECCTL_OPT_VERBOSE2);
d378 39
d422 2
a423 1
	fprintf(stderr, "usage: %s [-Fnsv] [-f file]\n", __progname);
d427 10
d448 1
a448 1
	while ((ch = getopt(argc, argv, "f:Fnvs")) != -1) {
d469 6
d497 14
a510 2
	if (opts & IPSECCTL_OPT_SHOW)
		ipsecctl_show(opts);
@


1.6
log
@minor memset->bzero, clarify an error condition, and plug a leak.
ok cloder@@, unpronounceable@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.5 2005/05/23 20:25:54 kjell Exp $	*/
d39 1
@


1.5
log
@tap. tap. is this thing on?

KNF, Fix a typo in an ENUM, Xr to ipsec.conf
no binary change

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.4 2005/04/12 06:57:36 deraadt Exp $	*/
d60 1
a60 1
	memset(&ipsec, 0, sizeof(ipsec));
d78 4
a82 4
	if (((opts & IPSECCTL_OPT_NOACTION) == 0) && (error == 0))
		if (ipsecctl_commit(&ipsec))
			err(1, NULL);

d325 1
a325 1
	memset(&ipsec, 0, sizeof(ipsec));
d339 4
@


1.4
log
@help option useless; any unused option does that
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.3 2005/04/05 07:14:00 jmc Exp $	*/
d70 1
a70 1
			return 1;
d83 1
a83 1
	return error;
d94 1
a94 1
		return NULL;
d98 1
a98 1
		return NULL;
d103 1
a103 1
		return NULL;
d105 1
a105 1
	return fp;
d132 1
a132 1
	return 0;
d144 1
a144 1
	return 0;
d204 1
a204 1
		return 0;
d211 1
a211 1
	return 0;
d297 1
a297 1
				rule->proto = PROTO_UNKNWON;
@


1.3
log
@cleanup; ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsecctl.c,v 1.2 2005/04/04 22:22:55 hshoexer Exp $	*/
d350 1
a350 1
	fprintf(stderr, "usage: %s [-Fhnsv] [-f file]\n", __progname);
d365 1
a365 1
	while ((ch = getopt(argc, argv, "f:Fhnvs")) != -1) {
a388 2
		case 'h':
			/* FALLTHROUGH */
@


1.2
log
@fix cvs id tags
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d350 1
a350 1
	fprintf(stderr, "usage: %s [-Fhnvs] [-f file]\n", __progname);
@


1.1
log
@Add ipsecctl utility, work in progress

ok deraadt
@
text
@d1 1
a1 1
/*	$Id: ipsecctl.c,v 1.9 2005/04/04 20:39:49 hshoexer Exp $	 */
@

