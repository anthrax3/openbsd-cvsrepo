head	1.59;
access;
symbols
	OPENBSD_3_9:1.58.0.4
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.58.0.2
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.57.0.2
	OPENBSD_3_7_BASE:1.57
	OPENBSD_3_6:1.54.0.2
	OPENBSD_3_6_BASE:1.54
	OPENBSD_3_5:1.48.0.2
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	OPENBSD_3_3:1.44.0.2
	OPENBSD_3_3_BASE:1.44
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.59
date	2006.06.27.15.19.33;	author deraadt;	state dead;
branches;
next	1.58;

1.58
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2004.11.24.18.11.15;	author fgsch;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.25.15.35.46;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.24.11.50.47;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.25.17.16.44;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2004.07.20.15.26.55;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.15.16.56.18;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.15.16.38.57;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.22.20.49.22;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.29.17.49.19;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.18.16.16.11;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.07.21.14.42;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.12.04.21.18;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.10.27.16.20.48;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.11.13.33.14;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.10.10.20.27.46;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.25.22.27.50;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.20.19.37.36;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.19.18.53.53;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.02.16.11.41;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.30.16.06.45;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.30.07.09.23;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.30.08.13.49;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.11.19.48.04;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.06.23.51.10;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.06.22.00.05;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.02.06.01.43;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.01.20.43.08;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.01.19.50.44;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.01.17.53.53;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.01.17.51.23;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.31.00.54.03;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.28.20.48.38;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.28.19.32.44;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.28.18.34.01;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.21.01.08.40;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.38;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.17.00.40.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.25.18.07.35;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.24.22.24.00;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.24.01.58.13;	author marc;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.07.18.58.39;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.04.14.59.50;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.15.02.40.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.13.18.58.10;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.17.21.57.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.16.17.39.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.11.09.13.21;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.18.20.44.36;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.02.18.50.00;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.26.23.36.28;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.24.17.09.55;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.03.09.55.19;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.03.00.53.59;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.02.07.33.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.07.11.16.31.08;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.59
log
@bye bye
@
text
@/*	$OpenBSD: wicontrol.c,v 1.58 2005/05/25 07:40:49 reyk Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	$FreeBSD: wicontrol.c,v 1.6 1999/05/22 16:12:49 wpaul Exp $
 */

#include <sys/types.h>
#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#ifdef __FreeBSD__
#include <net/if_var.h>
#include <net/ethernet.h>

#include <machine/if_wavelan_ieee.h>
#else
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net80211/ieee80211.h>

#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_hostap.h>
#endif

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <err.h>

#if !defined(lint)
static const char copyright[] = "@@(#) Copyright (c) 1997, 1998, 1999\
	Bill Paul. All rights reserved.";
static const char rcsid[] =
	"@@(#) $OpenBSD: wicontrol.c,v 1.58 2005/05/25 07:40:49 reyk Exp $";
#endif

int  wi_getval(char *, struct wi_req *);
void wi_setval(char *, struct wi_req *);
void wi_printstr(struct wi_req *);
void wi_setstr(char *, int, char *);
void wi_setbytes(char *, int, char *, int);
void wi_setword(char *, int, char *);
void wi_sethex(char *, int, char *);
void wi_printwords(struct wi_req *);
void wi_printbool(struct wi_req *);
void wi_printhex(struct wi_req *);
void wi_printalgorithm(struct wi_req *wreq);
void wi_printaplist(char *);
void wi_dumpinfo(char *);
void wi_setkeys(char *, int, char *);
void wi_printkeys(struct wi_req *);
void wi_printcardid(struct wi_req *, u_int16_t);
void wi_dumpstats(char *);
void wi_dumpstations(char *);
void printb(char *, unsigned short, char *);
__dead void usage(void);
char *portid(char *);
int  get_if_flags(int, const char *);
int  set_if_flags(int, const char *, int);
int  wi_hex2int(char c);
void wi_str2key(char *s, struct wi_key *k);

const struct wi_card_ident wi_card_ident[] = {
	WI_CARD_IDS
};

int
wi_getval(char *iface, struct wi_req *wreq)
{
	struct ifreq		ifr;
	int			error = 0, i, s;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		err(1, "socket");

	for (i = 10; --i; sleep(1)) {
		bzero((char *)&ifr, sizeof(ifr));
		strlcpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name));
		ifr.ifr_data = (caddr_t)wreq;
		error = ioctl(s, SIOCGWAVELAN, &ifr);
		if (error != -1 || errno != EINPROGRESS)
			break;
	}

	if (error == -1) {
		warn("SIOCGWAVELAN (0x%x)", wreq->wi_type);
		if (errno == ENXIO || errno == EINVAL)
			exit(1);
	}
	close(s);
	return (error);
}

void
wi_setval(char *iface, struct wi_req *wreq)
{
	struct ifreq		ifr;
	int			s;

	bzero((char *)&ifr, sizeof(ifr));

	strlcpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t)wreq;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		err(1, "socket");

	if (ioctl(s, SIOCSWAVELAN, &ifr) == -1)
		err(1, "SIOCSWAVELAN");

	close(s);
}

void
wi_printstr(struct wi_req *wreq)
{
	char			*ptr;
	int			i, max;

	if (wreq->wi_type == WI_RID_SERIALNO) {
		ptr = (char *)&wreq->wi_val;
		max = MIN(sizeof(wreq->wi_val) - 1, (wreq->wi_len - 1) * 2);
		for (i = 0; i < max; i++) {
			if (ptr[i] == '\0')
				ptr[i] = ' ';
		}
	} else {
		int len = letoh16(wreq->wi_val[0]);

		ptr = (char *)&wreq->wi_val[1];
		max = MIN(sizeof(wreq->wi_val) - 1, len);
		for (i = 0; i < max; i++) {
			if (ptr[i] == '\0')
				ptr[i] = ' ';
		}
	}

	ptr[i] = '\0';
	printf("[ %s ]", ptr);
}

void
wi_setstr(char *iface, int code, char *str)
{
	struct wi_req		wreq;

	if (str == NULL)
		errx(1, "must specify string");

	bzero((char *)&wreq, sizeof(wreq));

	if (strlen(str) > IEEE80211_NWID_LEN)
		errx(1, "string too long");

	wreq.wi_type = code;
	wreq.wi_len = 18;
	wreq.wi_val[0] = htole16(strlen(str));
	bcopy(str, (char *)&wreq.wi_val[1], strlen(str));

	wi_setval(iface, &wreq);
}

void
wi_setbytes(char *iface, int code, char *bytes, int len)
{
	struct wi_req		wreq;

	bzero((char *)&wreq, sizeof(wreq));

	wreq.wi_type = code;
	wreq.wi_len = (len / 2) + 1;
	bcopy(bytes, (char *)&wreq.wi_val[0], len);

	wi_setval(iface, &wreq);
}

void
wi_setword(char *iface, int code, char *word)
{
	struct wi_req		wreq;
	int			value = strtol(word, NULL, 10);

	bzero((char *)&wreq, sizeof(wreq));

	wreq.wi_type = code;
	wreq.wi_len = 2;
	wreq.wi_val[0] = htole16(value);

	wi_setval(iface, &wreq);
}

void
wi_sethex(char *iface, int code, char *str)
{
	struct ether_addr	*addr;

	if (str == NULL)
		errx(1, "must specify address");

	addr = ether_aton(str);
	if (addr == NULL)
		errx(1, "badly formatted address");

	wi_setbytes(iface, code, (char *)addr, ETHER_ADDR_LEN);
}

int
wi_hex2int(char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'A' && c <= 'F')
		return (c - 'A' + 10);
	if (c >= 'a' && c <= 'f')
		return (c - 'a' + 10);

	return (0);
}

void
wi_str2key(char *s, struct wi_key *k)
{
	int			n, i;
	char			*p;

	/* Is this a hex string? */
	if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
		/* Yes, convert to int. */
		n = 0;
		p = (char *)&k->wi_keydat[0];
		for (i = 2; i < strlen(s); i+= 2) {
			*p++ = (wi_hex2int(s[i]) << 4) + wi_hex2int(s[i + 1]);
			n++;
		}
		k->wi_keylen = htole16(n);
	} else {
		/* No, just copy it in. */
		bcopy(s, k->wi_keydat, strlen(s));
		k->wi_keylen = htole16(strlen(s));
	}
}

void
wi_setkeys(char *iface, int idx, char *key)
{
	struct wi_req		wreq;
	struct wi_ltv_keys	*keys;
	struct wi_key		*k;

	bzero((char *)&wreq, sizeof(wreq));
	wreq.wi_len = WI_MAX_DATALEN;
	wreq.wi_type = WI_RID_WEP_AVAIL;

	wi_getval(iface, &wreq);
	if (letoh16(wreq.wi_val[0]) == 0)
		errx(1, "no WEP option available on this card");

	bzero((char *)&wreq, sizeof(wreq));
	wreq.wi_len = WI_MAX_DATALEN;
	wreq.wi_type = WI_RID_DEFLT_CRYPT_KEYS;

	wi_getval(iface, &wreq);
	keys = (struct wi_ltv_keys *)&wreq;

	if (key[0] == '0' && (key[1] == 'x' || key[1] == 'X')) {
		if (strlen(key) > 28)
			errx(1, "encryption key must be no "
			    "more than 26 hex digits long");
	} else {
		if (strlen(key) > 13)
			errx(1, "encryption key must be no "
			    "more than 13 characters long");
	}

	if (idx > 3)
		errx(1, "only 4 encryption keys available");

	k = &keys->wi_keys[idx];
	wi_str2key(key, k);

	wreq.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;
	wreq.wi_type = WI_RID_DEFLT_CRYPT_KEYS;
	wi_setval(iface, &wreq);
}

void
wi_printkeys(struct wi_req *wreq)
{
	int			 i, j, bn;
	struct wi_key		*k;
	struct wi_ltv_keys	*keys;
	char			*ptr;

	keys = (struct wi_ltv_keys *)wreq;

	for (i = 0, bn = 0; i < 4; i++, bn = 0) {
		k = &keys->wi_keys[i];
		ptr = (char *)k->wi_keydat;
		for (j = 0; j < letoh16(k->wi_keylen); j++) {
			/* Only print 7-bit ASCII keys */
			if (ptr[j] & 0x80 || !isprint((unsigned char)ptr[j])) {
				bn = 1;
				break;
			}
		}

		if (bn)	{
			printf("[ 0x");
			for (j = 0; j < letoh16(k->wi_keylen); j++)
				printf("%02x", ((unsigned char *) ptr)[j]);
			printf(" ]");
		} else {
			ptr[j] = '\0';
			printf("[ %s ]", ptr);
		}
	}
}

void
wi_printcardid(struct wi_req *wreq, u_int16_t chip_id)
{
	const char *chip_name;
	const struct wi_card_ident *id;

	if (wreq->wi_len < 4)
		return;

	for (id = wi_card_ident; id->firm_type != WI_NOTYPE; id++) {
		if (chip_id == id->card_id)
			break;
	}
	if (id->firm_type != WI_NOTYPE)
		chip_name = id->card_name;
	else {
		if (chip_id & htole16(0x8000))
			chip_name = "Unknown PRISM chip";
		else
			chip_name = "Unknown Lucent chip";
	}

	/* XXX - doesn't decode Symbol firmware */
	if (chip_id & htole16(0x8000))
		printf("[ %s, Firmware %d.%d.%d ]", chip_name,
		    letoh16(wreq->wi_val[2]), letoh16(wreq->wi_val[3]),
		    letoh16(wreq->wi_val[1]));
	else
		printf("[ %s, Firmware %d.%02d variant %d ]", chip_name,
		    letoh16(wreq->wi_val[2]), letoh16(wreq->wi_val[3]),
		    letoh16(wreq->wi_val[1]));
}

void
wi_printwords(struct wi_req *wreq)
{
	int			i;

	printf("[ ");
	for (i = 0; i < wreq->wi_len - 1; i++)
		printf("%d ", letoh16(wreq->wi_val[i]));
	printf("]");
}

void
wi_printbool(struct wi_req *wreq)
{
	if (letoh16(wreq->wi_val[0]))
		printf("[ On ]");
	else
		printf("[ Off ]");
}

void
wi_printhex(struct wi_req *wreq)
{
	int			i;
	unsigned char		*c;

	c = (unsigned char *)&wreq->wi_val;

	printf("[ ");
	for (i = 0; i < (wreq->wi_len - 1) * 2; i++) {
		printf("%02x", c[i]);
		if (i < ((wreq->wi_len - 1) * 2) - 1)
			printf(":");
	}

	printf(" ]");
}

void
wi_printalgorithm(struct wi_req *wreq)
{
	switch(letoh16(wreq->wi_val[0])) {
	case WI_CRYPTO_FIRMWARE_WEP:
		printf("[ Firmware WEP ]");
		break;
	case WI_CRYPTO_SOFTWARE_WEP:
		printf("[ Software WEP ]");
		break;
	default:
		printf("[ Unknown ]");
		break;
	}
}

void
wi_printaplist(char *iface)
{
	int			prism2, len, i = 0, j, s, flags, nap;
	struct wi_req		wreq;
	struct wi_scan_p2_hdr	*wi_p2_h;
	struct wi_scan_res	*res;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		err(1, "socket");
	flags = get_if_flags(s, iface);
	if ((flags & IFF_UP) == 0)
		flags = set_if_flags(s, iface, flags | IFF_UP);

	/* first determine whether this is a prism2 card or not */
	wreq.wi_len = WI_MAX_DATALEN;
	wreq.wi_type = WI_RID_PRISM2;

	if (wi_getval(iface, &wreq) == -1)
		goto done;
	prism2 = wreq.wi_val[0];

	/* send out a scan request */
	wreq.wi_len = prism2 ? 3 : 1;
	wreq.wi_type = WI_RID_SCAN_REQ;

	if (prism2) {
		wreq.wi_val[0] = 0x3FFF;
		wreq.wi_val[1] = 0x000F;
	}

	wi_setval(iface, &wreq);

	/*
	 * sleep for 200 milliseconds so there's enough time for the card
	 * to respond... prism2's take a little longer.
	 */
	usleep(prism2 ? 700000 : 200000);

	/* get the scan results */
	wreq.wi_len = WI_MAX_DATALEN;
	wreq.wi_type = WI_RID_SCAN_RES;

	if (wi_getval(iface, &wreq) == -1)
		goto done;

	if (prism2) {
		wi_p2_h = (struct wi_scan_p2_hdr *)wreq.wi_val;

		/* if the reason is 0, this info is invalid */
		if (wi_p2_h->wi_reason == 0)
			return;

		i = 4;
	}

	len = prism2 ? WI_PRISM2_RES_SIZE : WI_WAVELAN_RES_SIZE;

	printf("AP Information\n");

	for (nap = 0; i < (wreq.wi_len * 2) - len; i += len) {
		res = (struct wi_scan_res *)((char *)wreq.wi_val + i);

		res->wi_ssid[letoh16(res->wi_ssid_len)] = '\0';
		res->wi_chan = letoh16(res->wi_chan);
		res->wi_noise = letoh16(res->wi_noise);
		res->wi_signal = letoh16(res->wi_signal);
		res->wi_interval = letoh16(res->wi_interval);
		res->wi_capinfo = letoh16(res->wi_capinfo);

		printf("ap[%d]:", nap++);
		printf("\tnetname (SSID):\t\t\t[ %s ]\n", res->wi_ssid);
		printf("\tBSSID:\t\t\t\t[ %02x:%02x:%02x:%02x:%02x:%02x ]\n",
		    res->wi_bssid[0], res->wi_bssid[1],
		    res->wi_bssid[2], res->wi_bssid[3],
		    res->wi_bssid[4], res->wi_bssid[5]);
		printf("\tChannel:\t\t\t[ %d ]\n", res->wi_chan);
		printf("\tBeacon Interval:\t\t[ %d ]\n", res->wi_interval);
		printf("\tQuality/Signal/Noise [signal]:\t[ %d / %d / %d ]\n",
		    res->wi_signal - res->wi_noise, res->wi_signal,
		    res->wi_noise);
		if (!prism2)
			printf("\t\t\t\t[dBm]:\t[ %d / %d / %d ]\n",
			    res->wi_signal - res->wi_noise,
			    res->wi_signal - 149, res->wi_noise - 149);

		if (res->wi_capinfo) {
			printf("\tCapinfo:\t\t\t[ ");
			if (res->wi_capinfo & WI_CAPINFO_ESS)
				printf("ESS ");
			if (res->wi_capinfo & WI_CAPINFO_IBSS)
				printf("IBSS ");
			if (res->wi_capinfo & WI_CAPINFO_PRIV)
				printf("PRIV ");
			printf("]\n");
		}

		if (prism2) {
			printf("\tDataRate [Mbps]:\t\t[ %2.1f ]\n",
			    res->wi_rate == 0xa ? 1 :
			    (res->wi_rate == 0x14 ? 2 :
			    (res->wi_rate == 0x37 ? 5.5 :
			    (res->wi_rate == 0x6e ? 11 : 0))));

			printf("\tAvailableRates [Mbps]:\t\t[ ");
			for (j = 0; res->wi_srates[j] != 0; j++) {
				res->wi_srates[j] = res->wi_srates[j] &
				    WI_VAR_SRATES_MASK;
				printf("%d.%d ", res->wi_srates[j] / 2,
				    (res->wi_srates[j] % 2) * 5);
			}
			printf("]\n");
		}
	}
done:
	set_if_flags(s, iface, flags);
	close(s);
	return;
}

#define WI_STRING		0x01
#define WI_BOOL			0x02
#define WI_WORDS		0x03
#define WI_HEXBYTES		0x04
#define WI_KEYSTRUCT		0x05
#define WI_CARDINFO		0x06
#define WI_ALGORITHM		0x07

struct wi_table {
	int			wi_code;
	int			wi_type;
	char			*wi_str;
};

struct wi_table wi_table[] = {
	{ WI_RID_SERIALNO, WI_STRING, "NIC serial number:\t\t\t" },
	{ WI_RID_NODENAME, WI_STRING, "Station name:\t\t\t\t" },
	{ WI_RID_OWN_SSID, WI_STRING, "SSID for IBSS creation:\t\t\t" },
	{ WI_RID_CURRENT_SSID, WI_STRING, "Current netname (SSID):\t\t\t" },
	{ WI_RID_DESIRED_SSID, WI_STRING, "Desired netname (SSID):\t\t\t" },
	{ WI_RID_CURRENT_BSSID, WI_HEXBYTES, "Current BSSID:\t\t\t\t" },
	{ WI_RID_CHANNEL_LIST, WI_WORDS, "Channel list:\t\t\t\t" },
	{ WI_RID_OWN_CHNL, WI_WORDS, "IBSS channel:\t\t\t\t" },
	{ WI_RID_CURRENT_CHAN, WI_WORDS, "Current channel:\t\t\t" },
	{ WI_RID_COMMS_QUALITY, WI_WORDS, "Comms quality/signal/noise:\t\t" },
	{ WI_RID_PROMISC, WI_BOOL, "Promiscuous mode:\t\t\t" },
	{ WI_RID_PROCFRAME, WI_BOOL, "Process 802.11b Frame:\t\t\t" },
	{ WI_RID_PORTTYPE, WI_WORDS, "Port type (1=BSS, 3=ad-hoc, 6=Host AP):\t"},
	{ WI_RID_MAC_NODE, WI_HEXBYTES, "MAC address:\t\t\t\t"},
	{ WI_RID_TX_RATE, WI_WORDS, "TX rate (selection):\t\t\t"},
	{ WI_RID_CUR_TX_RATE, WI_WORDS, "TX rate (actual speed):\t\t\t"},
	{ WI_RID_MAX_DATALEN, WI_WORDS, "Maximum data length:\t\t\t"},
	{ WI_RID_RTS_THRESH, WI_WORDS, "RTS/CTS handshake threshold:\t\t"},
	{ WI_RID_CREATE_IBSS, WI_BOOL, "Create IBSS:\t\t\t\t" },
	{ WI_RID_SYMBOL_DIVERSITY, WI_WORDS, "Antenna diversity (0=auto,1=pri,2=aux):\t"},
	{ WI_RID_MICROWAVE_OVEN, WI_BOOL, "Microwave oven robustness:\t\t"},
	{ WI_RID_ROAMING_MODE, WI_WORDS, "Roaming mode(1=firm,3=disable):\t\t"},
	{ WI_RID_SYSTEM_SCALE, WI_WORDS, "Access point density:\t\t\t" },
	{ WI_RID_PM_ENABLED, WI_BOOL, "Power Management:\t\t\t" },
	{ WI_RID_MAX_SLEEP, WI_WORDS, "Max sleep time:\t\t\t\t" },
	{ WI_RID_ENH_SECURITY, WI_WORDS, "Enhanced Security mode:\t\t\t" },
	{ WI_RID_PRISM2, WI_WORDS, "Intersil Prism2-based card:\t\t" },
	{ WI_RID_STA_IDENTITY, WI_CARDINFO, "Card info:\t\t\t\t" },
	{ 0, NULL }
};

struct wi_table wi_crypt_table[] = {
	{ WI_RID_ENCRYPTION, WI_BOOL, "Encryption:\t\t\t\t" },
	{ WI_FRID_CRYPTO_ALG, WI_ALGORITHM, "Encryption algorithm:\t\t\t" },
	{ WI_RID_CNFAUTHMODE, WI_WORDS,
	  "Authentication type \n(1=OpenSys, 2=Shared Key):\t\t" },
	{ WI_RID_TX_CRYPT_KEY, WI_WORDS, "TX encryption key:\t\t\t" },
	{ WI_RID_DEFLT_CRYPT_KEYS, WI_KEYSTRUCT, "Encryption keys:\t\t\t" },
	{ 0, NULL }
};

void
wi_dumpinfo(char *iface)
{
	struct wi_req		wreq;
	int			i, has_wep, chip_id;
	struct wi_table		*w;

	/* Get chip ID. */
	bzero((char *)&wreq, sizeof(wreq));
	wreq.wi_type = WI_RID_CARD_ID;
	wreq.wi_len = 5;
	wi_getval(iface, &wreq);
	chip_id = letoh16(wreq.wi_val[0]);

	/* Check for WEP support. */
	bzero((char *)&wreq, sizeof(wreq));
	wreq.wi_type = WI_RID_WEP_AVAIL;
	wreq.wi_len = 2;
	wi_getval(iface, &wreq);
	has_wep = letoh16(wreq.wi_val[0]);

	w = wi_table;

	for (i = 0; w[i].wi_type; i++) {
		bzero((char *)&wreq, sizeof(wreq));

		wreq.wi_len = WI_MAX_DATALEN;
		wreq.wi_type = w[i].wi_code;

		wi_getval(iface, &wreq);
		printf("%s", w[i].wi_str);
		switch (w[i].wi_type) {
		case WI_STRING:
			wi_printstr(&wreq);
			break;
		case WI_WORDS:
			wi_printwords(&wreq);
			break;
		case WI_BOOL:
			wi_printbool(&wreq);
			break;
		case WI_HEXBYTES:
			wi_printhex(&wreq);
			break;
		case WI_CARDINFO:
			wi_printcardid(&wreq, chip_id);
			break;
		default:
			break;
		}
		printf("\n");
	}

	if (has_wep) {
		w = wi_crypt_table;
		for (i = 0; w[i].wi_type; i++) {
			bzero((char *)&wreq, sizeof(wreq));

			wreq.wi_len = WI_MAX_DATALEN;
			wreq.wi_type = w[i].wi_code;

			wi_getval(iface, &wreq);
			printf("%s", w[i].wi_str);
			switch (w[i].wi_type) {
			case WI_STRING:
				wi_printstr(&wreq);
				break;
			case WI_WORDS:
				if (wreq.wi_type == WI_RID_TX_CRYPT_KEY)
					wreq.wi_val[0] =
					   htole16(letoh16(wreq.wi_val[0]) + 1);
				wi_printwords(&wreq);
				break;
			case WI_BOOL:
				wi_printbool(&wreq);
				break;
			case WI_HEXBYTES:
				wi_printhex(&wreq);
				break;
			case WI_KEYSTRUCT:
				wi_printkeys(&wreq);
				break;
			case WI_ALGORITHM:
				wi_printalgorithm(&wreq);
				break;
			default:
				break;
			}
			printf("\n");
		}
	}
}

void
wi_dumpstats(char *iface)
{
	struct wi_req		wreq;
	struct wi_counters	*c;

	bzero((char *)&wreq, sizeof(wreq));
	wreq.wi_len = WI_MAX_DATALEN;
	wreq.wi_type = WI_RID_IFACE_STATS;

	wi_getval(iface, &wreq);

	c = (struct wi_counters *)&wreq.wi_val;

	/* XXX native byte order */
	printf("Transmitted unicast frames:\t\t%u\n",
	    c->wi_tx_unicast_frames);
	printf("Transmitted multicast frames:\t\t%u\n",
	    c->wi_tx_multicast_frames);
	printf("Transmitted fragments:\t\t\t%u\n",
	    c->wi_tx_fragments);
	printf("Transmitted unicast octets:\t\t%u\n",
	    c->wi_tx_unicast_octets);
	printf("Transmitted multicast octets:\t\t%u\n",
	    c->wi_tx_multicast_octets);
	printf("Single transmit retries:\t\t%u\n",
	    c->wi_tx_single_retries);
	printf("Multiple transmit retries:\t\t%u\n",
	    c->wi_tx_multi_retries);
	printf("Transmit retry limit exceeded:\t\t%u\n",
	    c->wi_tx_retry_limit);
	printf("Transmit discards:\t\t\t%u\n",
	    c->wi_tx_discards);
	printf("Transmit discards due to wrong SA:\t%u\n",
	    c->wi_tx_discards_wrong_sa);
	printf("Received unicast frames:\t\t%u\n",
	    c->wi_rx_unicast_frames);
	printf("Received multicast frames:\t\t%u\n",
	    c->wi_rx_multicast_frames);
	printf("Received fragments:\t\t\t%u\n",
	    c->wi_rx_fragments);
	printf("Received unicast octets:\t\t%u\n",
	    c->wi_rx_unicast_octets);
	printf("Received multicast octets:\t\t%u\n",
	    c->wi_rx_multicast_octets);
	printf("Receive FCS errors:\t\t\t%u\n",
	    c->wi_rx_fcs_errors);
	printf("Receive discards due to no buffer:\t%u\n",
	    c->wi_rx_discards_nobuf);
	printf("Can't decrypt WEP frame:\t\t%u\n",
	    c->wi_rx_WEP_cant_decrypt);
	printf("Received message fragments:\t\t%u\n",
	    c->wi_rx_msg_in_msg_frags);
	printf("Received message bad fragments:\t\t%u\n",
	    c->wi_rx_msg_in_bad_msg_frags);
}

void
wi_dumpstations(char *iface)
{
	struct hostap_getall    reqall;
	struct hostap_sta	stas[WIHAP_MAX_STATIONS];
	struct ifreq		ifr;
	int i, s;

	bzero(&ifr, sizeof(ifr));
	strlcpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t) & reqall;
	bzero(&reqall, sizeof(reqall));
	reqall.size = sizeof(stas);
	reqall.addr = stas;
	bzero(&stas, sizeof(stas));

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		err(1, "socket");

	if (ioctl(s, SIOCHOSTAP_GETALL, &ifr) < 0)
		err(1, "SIOCHOSTAP_GETALL");

	printf("%d station%s:\n", reqall.nstations, reqall.nstations>1?"s":"");
	for (i = 0; i < reqall.nstations; i++) {
		struct hostap_sta *info = &stas[i];

		printf("%02x:%02x:%02x:%02x:%02x:%02x  asid=%04x",
			info->addr[0], info->addr[1], info->addr[2],
			info->addr[3], info->addr[4], info->addr[5],
			info->asid - 0xc001);

		printb(", flags", info->flags, HOSTAP_FLAGS_BITS);
		printb(", caps", info->capinfo, IEEE80211_CAPINFO_BITS);
		printb(", rates", info->rates, WI_RATES_BITS);
		if (info->sig_info)
			printf(", sig=%d/%d",
			    info->sig_info >> 8, info->sig_info & 0xff);
		putchar('\n');
	}
	close(s);
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [interface] [-olL] [-t tx rate] [-n network name]\n"
	    "       [-s station name] [-e 0|1] [-k key [-v 1|2|3|4]] [-T 1|2|3|4]\n"
	    "       [-x 0|1] [-F 0|1] [-c 0|1] [-q SSID] [-p port type]\n"
	    "       [-a access point density] [-m MAC address] [-d max data length]\n"
	    "       [-r RTS threshold] [-f frequency] [-M 0|1] [-P 0|1]\n"
	    "       [-S max sleep duration] [-A 1|2|3] [-D 0|1|2] [-R 1|3] [-E 0|1|2|3]\n",
	    __progname);
	exit(1);
}

struct wi_func {
	int   key;
	void (*function) (char *, int, char *);
	int   wi_code;
	char  *optarg;
};

struct wi_func wi_opt[] = {
	{ 'k', wi_setkeys, 0, NULL },  /* MUST be first entry in table */
	{ 'a', wi_setword, WI_RID_SYSTEM_SCALE, NULL },
	{ 'c', wi_setword, WI_RID_CREATE_IBSS, NULL },
	{ 'd', wi_setword, WI_RID_MAX_DATALEN, NULL },
	{ 'e', wi_setword, WI_RID_ENCRYPTION, NULL },
	{ 'f', wi_setword, WI_RID_OWN_CHNL, NULL },
	{ 'm', wi_sethex, WI_RID_MAC_NODE, NULL },
	{ 'n', wi_setstr, WI_RID_DESIRED_SSID, NULL },
	{ 'p', wi_setword, WI_RID_PORTTYPE, NULL },
	{ 'q', wi_setstr, WI_RID_OWN_SSID, NULL },
	{ 'r', wi_setword, WI_RID_RTS_THRESH, NULL },
	{ 's', wi_setstr, WI_RID_NODENAME, NULL },
	{ 't', wi_setword, WI_RID_TX_RATE, NULL },
	{ 'x', wi_setword, WI_FRID_CRYPTO_ALG, NULL },
	{ 'A', wi_setword, WI_RID_CNFAUTHMODE, NULL },
	{ 'D', wi_setword, WI_RID_SYMBOL_DIVERSITY, NULL },
	{ 'E', wi_setword, WI_RID_ENH_SECURITY, NULL },
	{ 'M', wi_setword, WI_RID_MICROWAVE_OVEN, NULL },
	{ 'P', wi_setword, WI_RID_PM_ENABLED, NULL },
	{ 'R', wi_setword, WI_RID_ROAMING_MODE, NULL },
	{ 'S', wi_setword, WI_RID_MAX_SLEEP, NULL },
	{ 'T', wi_setword, WI_RID_TX_CRYPT_KEY, NULL },
	{ 'F', wi_setword, WI_RID_PROCFRAME, NULL },

	/* These options will never be command line options which is why
	   they are not 'quoted' */
	{ 1, wi_setkeys, 0, NULL }, /* Dummy option for key 0 */
	{ 2, wi_setkeys, 1, NULL }, /* key 1 */
	{ 3, wi_setkeys, 2, NULL }, /* key 2 */
	{ 4, wi_setkeys, 3, NULL }, /* key 3 */
	{ 0, NULL, 0, NULL }
};

int
main(int argc, char *argv[])
{
	int	ch, p, dumpstats = 0, dumpinfo = 1, ifspecified = 0;
	int	listaps = 0, dumpstations = 0;
	char	*iface;

	iface = "wi0";
	if (argc > 1 && argv[1][0] != '-') {
		iface = argv[1];
		ifspecified = 1;
		optind = 2;
	}

	while ((ch = getopt(argc, argv,
	    "a:c:d:e:f:hi:k:lm:n:op:q:r:s:t:v:x:A:D:E:F:LM:S:P:R:T:")) != -1) {
		dumpinfo = 0;
		for (p = 0; ch && wi_opt[p].key; p++)
			if (ch == wi_opt[p].key) {
				if (ch == 'p' && !isdigit(*optarg))
					wi_opt[p].optarg = portid(optarg);
				else
					wi_opt[p].optarg = optarg;
				if (ch == 'T')	/* key 1-4/0-3 kludge */
					(*optarg)--;
				dumpinfo = ch = 0;
			}
		switch (ch) {
		case '\0':
			break;
		case 'i':
			if (!ifspecified)
				iface = optarg;
			break;
		case 'l':
			dumpstations++;
			break;
		case 'L':
			listaps++;
			break;
		case 'o':
			dumpstats++;
			break;
		case 'v':
			for (p = 0; wi_opt[p].key; p++)
				if (wi_opt[p].key ==
				    strtol(optarg, NULL, 10)) {
					wi_opt[p].optarg = wi_opt[0].optarg;
					/* prevent multiple -v without
					   multiple -k */
					wi_opt[0].optarg = NULL;
					break;
				}
			break;
		case 'h':
		default:
			usage();
			break;
		}
	}

	for (p = 0; wi_opt[p].key; p++)
		if (wi_opt[p].optarg != NULL)
			wi_opt[p].function(iface, wi_opt[p].wi_code,
					   wi_opt[p].optarg);

	if (listaps)
		wi_printaplist(iface);

	if (dumpstations)
		wi_dumpstations(iface);

	if (dumpstats && !listaps && !dumpstations)
		wi_dumpstats(iface);

	if (dumpinfo && !dumpstats && !listaps && !dumpstations)
		wi_dumpinfo(iface);

	exit(0);
}

int
get_if_flags(int s, const char *name)
{
	struct ifreq	ifr;
	int		flags;

	bzero(&ifr, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) == -1)
		  err(1, "SIOCGIFFLAGS");
	flags = ifr.ifr_flags;

	return (flags);
}

int
set_if_flags(int s, const char *name, int flags)
{
	struct ifreq ifr;

	bzero(&ifr, sizeof(ifr));
	ifr.ifr_flags = flags;
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr) == -1)
		err(1, "SIOCSIFFLAGS");

	return (0);
}

/*
 * Print a value a la the %b format of the kernel's printf
 * (ripped screaming from ifconfig/ifconfig.c)
 */
void
printb(char *s, unsigned short v, char *bits)
{
	int i, any = 0;
	char c;

	if (bits && *bits == 8)
		printf("%s=%o", s, v);
	else
		printf("%s=%x", s, v);
	bits++;
	if (bits) {
		putchar('<');
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(c);
			} else
				for (; *bits > 32; bits++)
					;
		}
		putchar('>');
	}
}

char *
portid(char *name)
{
	char *id;

	if (strcasecmp(name, "bss") == 0)
		id = "1";
	else if (strcasecmp(name, "adhoc") == 0 ||
	    strcasecmp(name, "ad-hoc") == 0)
		id = "3";
	else if (strcasecmp(name, "ibss") == 0)
		id = "4";
	else if (strcasecmp(name, "hostap") == 0)
		id = "6";
	else
		errx(1, "unknown port type %s", name);

	return(id);
}
@


1.58
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.57 2004/11/24 18:11:15 fgsch Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.57 2004/11/24 18:11:15 fgsch Exp $";
@


1.57
log
@replace old net/if_ieee80211.h header with the net80211 ones, userland part.
millert@@ mcbride@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.56 2004/10/25 15:35:46 deraadt Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.56 2004/10/25 15:35:46 deraadt Exp $";
d125 1
a125 1
		if (errno == ENXIO)
@


1.56
log
@broke parsing, oops, noted by jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.55 2004/10/24 11:50:47 deraadt Exp $	*/
d52 1
a52 1
#include <net/if_ieee80211.h>
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.55 2004/10/24 11:50:47 deraadt Exp $";
@


1.55
log
@unify device selection
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.54 2004/08/25 17:16:44 mickey Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.54 2004/08/25 17:16:44 mickey Exp $";
d888 1
d900 2
@


1.54
log
@add -E to usage(); from weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.53 2004/07/20 15:26:55 millert Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.53 2004/07/20 15:26:55 millert Exp $";
d875 3
a877 3
	char	*iface = "wi0";
	int	ch, p, dumpstats, dumpinfo = 1, ifspecified;
	int	listaps, dumpstations;
d879 1
a879 1
	dumpstats = ifspecified = listaps = dumpstations = 0;
a881 2
		memcpy(&argv[1], &argv[2], argc * sizeof(char *));
		argc--;
d883 1
a898 2
		case 0:
			break;
d903 2
a904 2
		case 'o':
			dumpstats++;
d909 2
a910 2
		case 'l':
			dumpstations++;
@


1.53
log
@Make ENXIO from SIOCGWAVELAN a fatal error so we don't get garbage
when wicontrol is run on a non-existant interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.52 2004/07/15 16:56:18 millert Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.52 2004/07/15 16:56:18 millert Exp $";
d826 1
a826 1
	    "       [-S max sleep duration] [-A 1|2|3] [-D 0|1|2] [-R 1|3]\n",
@


1.52
log
@Keep trying if we get EINPROGRESS from SIOCGWAVELAN, up to 10 times.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.51 2004/07/15 16:38:57 millert Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.51 2004/07/15 16:38:57 millert Exp $";
d123 1
a123 1
	if (error == -1)
d125 3
@


1.51
log
@Make wi_getval() return int and check the rval when printing the AP list.
Avoids bogus data leading to a core dump on cards that don't support it.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.50 2004/06/22 20:49:22 millert Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.50 2004/06/22 20:49:22 millert Exp $";
d108 1
a108 6
	int			error, s;

	bzero((char *)&ifr, sizeof(ifr));

	strlcpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t)wreq;
d114 10
a123 1
	if ((error = ioctl(s, SIOCGWAVELAN, &ifr)) == -1)
a124 1

@


1.50
log
@Remove the CNF_ from WI_RID_CNF_ENH_SECURITY and WI_RID_CNF_DBM_ADJUST
to match changes in wi(4).  Also, don't exit wicontrol if SIOCGWAVELAN
fails; just keep going and get the values we can.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.49 2004/05/29 17:49:19 millert Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.49 2004/05/29 17:49:19 millert Exp $";
d74 1
a74 1
void wi_getval(char *, struct wi_req *);
d97 2
a98 2
int	wi_hex2int(char c);
void	wi_str2key(char *s, struct wi_key *k);
d104 1
a104 1
void
d108 1
a108 1
	int			s;
d119 1
a119 1
	if (ioctl(s, SIOCGWAVELAN, &ifr) == -1)
d123 1
d458 2
a459 1
	wi_getval(iface, &wreq);
d483 2
a484 1
	wi_getval(iface, &wreq);
d554 1
@


1.49
log
@Changes from Andrey Matveev:
 o only include socket.h once
 o use errx() not err() where appropriate
 o close the socket we opened
 o bzero struct ifreq before use
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.48 2004/03/18 16:16:11 millert Exp $	*/
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.48 2004/03/18 16:16:11 millert Exp $";
d120 1
a120 1
		err(1, "SIOCGWAVELAN");
d596 1
a596 1
	{ WI_RID_CNF_ENH_SECURITY, WI_WORDS, "Enhanced Security mode:\t\t\t" },
d845 1
a845 1
	{ 'E', wi_setword, WI_RID_CNF_ENH_SECURITY, NULL },
@


1.48
log
@Starting with Prism firmware version 1.6.3, HostAP supports an
enhanced security mode whereby the SSID can be hidden from snoopers.
Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.47 2003/07/29 18:38:36 deraadt Exp $	*/
a39 1
#include <sys/socket.h>
d71 1
a71 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.47 2003/07/29 18:38:36 deraadt Exp $";
a115 1

a136 1

a232 1

d288 1
a288 1
		err(1, "no WEP option available on this card");
d299 1
a299 1
			err(1, "encryption key must be no "
d303 1
a303 1
			err(1, "encryption key must be no "
d308 1
a308 1
		err(1, "only 4 encryption keys available");
d802 1
d949 1
d963 1
d969 1
a969 1
	return 0;
@


1.47
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.46 2003/07/02 21:44:58 deraadt Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.46 2003/07/02 21:44:58 deraadt Exp $";
d600 1
d848 1
d881 1
a881 1
	    "a:c:d:e:f:hi:k:lm:n:op:q:r:s:t:v:x:A:D:F:LM:S:P:R:T:")) != -1) {
@


1.46
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.45 2003/06/07 21:14:42 mickey Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.45 2003/06/07 21:14:42 mickey Exp $";
d664 1
a664 1
		}	
d702 1
a702 1
			}	
@


1.45
log
@print minor version as 02d; from Adam Montague via pr 3284; matches what freebsd does as well
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.44 2002/12/12 04:21:18 deraadt Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.44 2002/12/12 04:21:18 deraadt Exp $";
d98 2
@


1.44
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.43 2002/10/27 16:20:48 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.43 2002/10/27 16:20:48 millert Exp $";
d381 1
a381 1
		printf("[ %s, Firmware %d.%d variant %d ]", chip_name,
@


1.43
log
@Add an option to use software WEP now that we have a software decrypt
function.  Can be useful for cards that only support 40-bit WEP or
where the card firmware lacks weak IVs avoidance.  Prism/Symbol only.
In the future this will be expanded to support proposed WEP replacements.
Based on code from Jamison Adcock.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.42 2002/10/11 13:33:14 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.42 2002/10/11 13:33:14 millert Exp $";
d104 1
a104 3
wi_getval(iface, wreq)
	char			*iface;
	struct wi_req		*wreq;
d126 1
a126 3
wi_setval(iface, wreq)
	char			*iface;
	struct wi_req		*wreq;
d148 1
a148 2
wi_printstr(wreq)
	struct wi_req		*wreq;
d176 1
a176 4
wi_setstr(iface, code, str)
	char			*iface;
	int			code;
	char			*str;
d197 1
a197 5
wi_setbytes(iface, code, bytes, len)
	char			*iface;
	int			code;
	char			*bytes;
	int			len;
d211 1
a211 4
wi_setword(iface, code, word)
	char			*iface;
	int			code;
	char			*word;
d226 1
a226 4
wi_sethex(iface, code, str)
	char			*iface;
	int			code;
	char			*str;
d242 1
a242 2
wi_hex2int(c)
	char			c;
d255 1
a255 3
wi_str2key(s, k)
	char			*s;
	struct wi_key		*k;
d278 1
a278 4
wi_setkeys(iface, idx, key)
	char			*iface;
	int			 idx;
	char			*key;
d321 1
a321 2
wi_printkeys(wreq)
	struct wi_req		*wreq;
d354 1
a354 3
wi_printcardid(wreq, chip_id)
	struct wi_req *wreq;
	u_int16_t chip_id;
d387 1
a387 2
wi_printwords(wreq)
	struct wi_req		*wreq;
d398 1
a398 2
wi_printbool(wreq)
	struct wi_req		*wreq;
d407 1
a407 2
wi_printhex(wreq)
	struct wi_req		*wreq;
d425 1
a425 2
wi_printalgorithm(wreq)
	struct wi_req   *wreq;
d441 1
a441 2
wi_printaplist(iface)
	char			*iface;
d614 1
a614 2
wi_dumpinfo(iface)
	char			*iface;
d707 1
a707 2
wi_dumpstats(iface)
	char			*iface;
d764 1
a764 2
wi_dumpstations(iface)
	char			*iface;
d806 1
a806 1
usage()
d862 1
a862 3
main(argc, argv)
	int			argc;
	char			*argv[];
d943 1
a943 3
get_if_flags(s, name)
	int		s;
	const char	*name;
d957 1
a957 4
set_if_flags(s, name, flags)
	int		s;
	const char	*name;
	int		flags;
d974 1
a974 4
printb(s, v, bits)
	char *s;
	char *bits;
	unsigned short v;
@


1.42
log
@Add a letoh16() since card ids in WI_CARD_IDS are not guaranteed
to be little endian.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.41 2002/10/10 20:27:46 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.41 2002/10/10 20:27:46 millert Exp $";
d85 1
d455 17
d596 1
d636 2
a637 1
	{ WI_RID_ENCRYPTION, WI_BOOL, "WEP encryption:\t\t\t\t" },
d728 3
d848 5
a852 4
	    "       [-F 0|1] [-c 0|1] [-q SSID] [-p port type] [-a access point density]\n"
	    "       [-m MAC address] [-d max data length] [-r RTS threshold]\n"
	    "       [-f frequency] [-M 0|1] [-P 0|1] [-S max sleep duration]\n"
	    "       [-A 1|2|3] [-D 0|1|2] [-R 1|3]\n", __progname);
d877 1
d914 1
a914 1
	    "a:c:d:e:f:hi:k:lm:n:op:q:r:s:t:v:A:D:F:LM:S:P:R:T:")) != -1) {
@


1.41
log
@Make wi_get_id() table driven, similar to NetBSD and FreeBSD but
make the table itself a #define so we can reuse it in wicontrol.
Also add a bunch of chip IDs from NetBSD/FreeBSD.
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.40 2002/07/25 22:27:50 deraadt Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.40 2002/07/25 22:27:50 deraadt Exp $";
d638 1
a638 1
	chip_id = wreq.wi_val[0];
@


1.40
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.39 2002/06/20 19:37:36 fgsch Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.39 2002/06/20 19:37:36 fgsch Exp $";
d89 1
a89 1
void wi_printcardid(struct wi_req *, int);
d98 4
d380 1
a380 1
	int chip_id;
d382 2
a383 1
	char *chip_name;
d388 9
a396 41
	/* Copied from wi_get_id() in if_wi.c */
	switch (chip_id) {
	case WI_NIC_EVB2:
		chip_name = "PRISM I HFA3841(EVB2)";
		break;
	case WI_NIC_HWB3763:
		chip_name = "PRISM II HWB3763 rev.B";
		break;
	case WI_NIC_HWB3163:
		chip_name = "PRISM II HWB3163 rev.A";
		break;
	case WI_NIC_HWB3163B:
		chip_name = "PRISM II HWB3163 rev.B";
		break;
	case WI_NIC_EVB3:
		chip_name = "PRISM II  HFA3842(EVB3)";
		break;
	case WI_NIC_HWB1153:
		chip_name = "PRISM I HFA1153";
		break;
	case WI_NIC_P2_SST:
		chip_name = "PRISM II HWB3163 SST-flash";
		break;
	case WI_NIC_PRISM2_5:
		chip_name = "PRISM 2.5 ISL3873";
		break;
	case WI_NIC_37300P:
		chip_name = "PRISM 2.5 ISL37300P";
		break;
	case WI_NIC_LUCENT:
		chip_name = "Lucent";
		break;
	case WI_NIC_SONY:
		chip_name = "Sony";
		break;
	case WI_NIC_LUCENT_EM:
		chip_name = "Lucent (embedded)";
		break;
	default:
		if (chip_id & 0x8000)
			chip_name = "Unknown PRISM II chip";
d400 3
a402 1
	if (chip_id & 0x8000)
d638 1
a638 1
	chip_id = letoh16(wreq.wi_val[0]);
@


1.39
log
@wi_ssid_len is in little-endian as well, so convert it. fixes ssid
printing on sparc64; millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.38 2002/06/19 18:53:53 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.38 2002/06/19 18:53:53 millert Exp $";
d536 1
a536 1
	printf("\nAP Information\n");
d548 1
a548 1
		printf("ap[%d]:\n", nap++);
a590 1
		putchar('\n');
@


1.38
log
@Since we can no longer count on isprint() to tell us whether or not
a character is 7-bit ASCII, check the high bit by hand when deciding
whether to print a WEP key as ASCII or hex.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.37 2002/06/02 16:11:41 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.37 2002/06/02 16:11:41 millert Exp $";
d541 1
a541 1
		res->wi_ssid[res->wi_ssid_len] = '\0';
@


1.37
log
@BSD air-tools 0.2 patches from dachb0den labs; h1kari@@dachb0den.com
The common.h include file has been incorporated into if_wi_ieee.h
similar to what is in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.36 2002/05/30 16:06:45 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.36 2002/05/30 16:06:45 millert Exp $";
d354 2
a355 1
			if (!isprint((unsigned char)ptr[j])) {
@


1.36
log
@power management and microwave over robustness are booleans
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.35 2002/05/30 07:09:23 deraadt Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.35 2002/05/30 07:09:23 deraadt Exp $";
d85 1
d95 2
d477 120
d622 1
d636 1
d848 1
a848 1
	    "usage: %s [interface] [-ol] [-t tx rate] [-n network name]\n"
d850 1
a850 1
	    "       [-c 0|1] [-q SSID] [-p port type] [-a access point density]\n"
d885 1
d902 2
a903 1
	int	ch, p, dumpstats, dumpinfo = 1, ifspecified, dumpstations;
d905 1
a905 1
	dumpstats = ifspecified = dumpstations = 0;
d914 1
a914 1
	    "a:c:d:e:f:hi:k:lm:n:op:q:r:s:t:v:A:D:M:S:P:R:T:")) != -1) {
d935 3
d964 3
d970 1
a970 1
	if (dumpstats && !dumpstations)
d973 1
a973 1
	if (dumpinfo && !dumpstats && !dumpstations)
d977 32
@


1.35
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.34 2002/04/30 08:13:49 deraadt Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.34 2002/04/30 08:13:49 deraadt Exp $";
a90 1
void usage(void);
d92 1
d507 1
a507 1
	{ WI_RID_MICROWAVE_OVEN, WI_WORDS, "Microwave oven robustness:\t\t"},
d510 1
a510 1
	{ WI_RID_PM_ENABLED, WI_WORDS, "Power Mgmt (1=on, 0=off):\t\t" },
d717 1
a717 1
void
@


1.34
log
@print usage right
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.33 2002/04/11 19:48:04 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.33 2002/04/11 19:48:04 millert Exp $";
d218 1
a218 1
	char                    *word;
d221 1
a221 1
	int                     value = strtol(word, NULL, 10);
d253 1
a253 1
        char                    c;
d255 2
a256 2
        if (c >= '0' && c <= '9')
                return (c - '0');
d258 1
a258 1
	        return (c - 'A' + 10);
d260 1
a260 1
                return (c - 'a' + 10);
d262 1
a262 1
	return (0); 
d267 2
a268 2
        char                    *s;
        struct wi_key           *k;
d270 2
a271 2
        int                     n, i;
        char                    *p;
d273 15
a287 15
        /* Is this a hex string? */
        if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
                /* Yes, convert to int. */
                n = 0;
                p = (char *)&k->wi_keydat[0];
                for (i = 2; i < strlen(s); i+= 2) {
                        *p++ = (wi_hex2int(s[i]) << 4) + wi_hex2int(s[i + 1]);
                        n++;
                }
                k->wi_keylen = htole16(n);
        } else {
                /* No, just copy it in. */
                bcopy(s, k->wi_keydat, strlen(s));
                k->wi_keylen = htole16(strlen(s));
        }
d292 26
a317 26
        char                    *iface;
        int                     idx;
        char                    *key;
{
        struct wi_req           wreq;
        struct wi_ltv_keys      *keys;
        struct wi_key           *k;

        bzero((char *)&wreq, sizeof(wreq));
        wreq.wi_len = WI_MAX_DATALEN;
        wreq.wi_type = WI_RID_WEP_AVAIL;

        wi_getval(iface, &wreq);
        if (letoh16(wreq.wi_val[0]) == 0)
                err(1, "no WEP option available on this card");

        bzero((char *)&wreq, sizeof(wreq));
        wreq.wi_len = WI_MAX_DATALEN;
        wreq.wi_type = WI_RID_DEFLT_CRYPT_KEYS;

        wi_getval(iface, &wreq);
        keys = (struct wi_ltv_keys *)&wreq;

        if (key[0] == '0' && (key[1] == 'x' || key[1] == 'X')) {
	        if (strlen(key) > 28)
		        err(1, "encryption key must be no "
d320 2
a321 2
	        if (strlen(key) > 13)
		        err(1, "encryption key must be no "
d325 2
a326 2
        if (idx > 3)
                err(1, "only 4 encryption keys available");
d328 2
a329 2
        k = &keys->wi_keys[idx];
        wi_str2key(key, k);
d331 3
a333 3
        wreq.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;
        wreq.wi_type = WI_RID_DEFLT_CRYPT_KEYS;
        wi_setval(iface, &wreq);
d338 1
a338 1
        struct wi_req           *wreq;
d340 4
a343 4
        int                     i, j, bn;
        struct wi_key           *k;
        struct wi_ltv_keys      *keys;
        char                    *ptr;
d348 2
a349 2
                k = &keys->wi_keys[i];
                ptr = (char *)k->wi_keydat;
d351 2
a352 2
		        if (!isprint((unsigned char)ptr[j])) {
			        bn = 1;
d358 3
a360 3
		        printf("[ 0x");
		        for (j = 0; j < letoh16(k->wi_keylen); j++)
			      printf("%02x", ((unsigned char *) ptr)[j]);
d363 1
a363 1
		        ptr[j] = '\0';
d366 1
a366 1
        }
d478 2
a479 2
#define WI_KEYSTRUCT            0x05
#define WI_CARDINFO             0x06
d517 2
a518 2
        { WI_RID_ENCRYPTION, WI_BOOL, "WEP encryption:\t\t\t\t" },
        { WI_RID_CNFAUTHMODE, WI_WORDS,
d520 3
a522 3
        { WI_RID_TX_CRYPT_KEY, WI_WORDS, "TX encryption key:\t\t\t" },
        { WI_RID_DEFLT_CRYPT_KEYS, WI_KEYSTRUCT, "Encryption keys:\t\t\t" },
        { 0, NULL }
d557 1
a557 1
		switch(w[i].wi_type) {
d589 1
a589 1
			switch(w[i].wi_type) {
d679 1
a679 1
	struct hostap_sta       stas[WIHAP_MAX_STATIONS];
d702 1
a702 1
	        printf("%02x:%02x:%02x:%02x:%02x:%02x  asid=%04x",
d733 4
a736 4
        int   key;
        void (*function) (char *, int, char *);
        int   wi_code;
        char  *optarg;
d786 1
a786 1
	while((ch = getopt(argc, argv,
d788 2
a789 2
	        for (p = 0; ch && wi_opt[p].key; p++)
		        if (ch == wi_opt[p].key) {
d795 1
a795 1
				        (*optarg)--;
d798 1
a798 1
		switch(ch) {
d800 1
a800 1
		        break;
d802 2
a803 2
		        if (!ifspecified)
			        iface = optarg;
d812 3
a814 3
 		        for (p = 0; wi_opt[p].key; p++)
				if (wi_opt[p].key == 
                                    strtol(optarg, NULL, 10)) {
d816 3
a818 3
                                        /* prevent multiple -v without
                                           multiple -k */
                                        wi_opt[0].optarg = NULL; 
d821 1
a821 1
		       	break;
d824 1
a824 1
		        usage();
d830 2
a831 2
	        if (wi_opt[p].optarg != NULL)
		        wi_opt[p].function(iface, wi_opt[p].wi_code, 
d838 1
a838 1
	        wi_dumpstats(iface);
d841 1
a841 1
	        wi_dumpinfo(iface);
@


1.33
log
@Accept "ibss" for port type 4
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.32 2002/04/06 23:51:10 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.32 2002/04/06 23:51:10 millert Exp $";
d723 2
a724 3
	    "usage: %s interface [-ol]"
	    "       [-t tx rate] [-n network name] [-s station name]\n"
	    "       [-e 0|1] [-k key [-v 1|2|3|4]] [-T 1|2|3|4]\n"
@


1.32
log
@o Add -D option to set antenna diversity on Symbol cards
o Mention other symbol-specific things
o Convert tables to real mdoc colummn lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.31 2002/04/06 22:00:05 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.31 2002/04/06 22:00:05 millert Exp $";
d892 2
@


1.31
log
@Use new WI_NIC_* names for lucent cards instead of hard-coded hex values.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.30 2002/04/02 06:01:43 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.30 2002/04/02 06:01:43 millert Exp $";
d506 1
d508 1
a508 1
	{ WI_RID_ROAMING_MODE, WI_WORDS, "Roaming mode(1:firm,3:disable):\t\t"},
d729 1
a729 1
	    "       [-A 0|1 ] [-R 1|3]\n", __progname);
d755 1
d788 1
a788 1
	    "a:c:d:e:f:hi:k:lm:n:op:q:r:s:t:v:A:M:S:P:R:T:")) != -1) {
@


1.30
log
@Prism2 firmware should be reported as version a.b.c not a.b variant c.
Only Lucent uses the 'variant' form.  Also, prism2 firmware 0.8.2 does
WEP w/o requiring promisc mode (from NetBSD).  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.29 2002/04/01 20:43:08 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.29 2002/04/01 20:43:08 millert Exp $";
d408 1
a408 1
	case 1:
d411 1
a411 1
	case 2:
d414 1
a414 1
	case 5:
d418 4
a421 2
		asprintf(&chip_name, "Unknown (%d)", chip_id);
		break;
d423 2
a424 2
	if (chip_id <= 5)
		printf("[ %s, Firmware %d.%d variant %d ]", chip_name,
d428 1
a428 1
		printf("[ %s, Firmware %d.%d.%d ]", chip_name,
@


1.29
log
@Also accept "adhoc" (or "ad-hoc"), "bss", and "hostap" instead of
numbers for -p option.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.28 2002/04/01 19:50:44 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.28 2002/04/01 19:50:44 millert Exp $";
d421 8
a428 3
	printf("[ %s, Firmware %i.%i variant %i ]", chip_name,
	    letoh16(wreq->wi_val[2]), letoh16(wreq->wi_val[3]),
	    letoh16(wreq->wi_val[1]));
@


1.28
log
@members of wi_counters are u_int32_t so print them with "%u" not "%d"
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.27 2002/04/01 17:53:53 millert Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.27 2002/04/01 17:53:53 millert Exp $";
d92 2
a93 1
void printb(char *s, unsigned short v, char *bits);
d782 4
a785 1
			        wi_opt[p].optarg = optarg;
a792 3
		case 'o':
			dumpstats ++;
			break;
d797 3
a820 3
	if (iface == NULL)
		usage();

d871 18
@


1.27
log
@Fix max WEP key len.  Max len for a 104 bit WEP key len is 26 hex digits
(not counting the leading 0x) or 13 characters.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.26 2002/04/01 17:51:23 mickey Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.26 2002/04/01 17:51:23 mickey Exp $";
d623 1
a623 1
	printf("Transmitted unicast frames:\t\t%d\n",
d625 1
a625 1
	printf("Transmitted multicast frames:\t\t%d\n",
d627 1
a627 1
	printf("Transmitted fragments:\t\t\t%d\n",
d629 1
a629 1
	printf("Transmitted unicast octets:\t\t%d\n",
d631 1
a631 1
	printf("Transmitted multicast octets:\t\t%d\n",
d633 1
a633 1
	printf("Single transmit retries:\t\t%d\n",
d635 1
a635 1
	printf("Multiple transmit retries:\t\t%d\n",
d637 1
a637 1
	printf("Transmit retry limit exceeded:\t\t%d\n",
d639 1
a639 1
	printf("Transmit discards:\t\t\t%d\n",
d641 1
a641 1
	printf("Transmit discards due to wrong SA:\t%d\n",
d643 1
a643 1
	printf("Received unicast frames:\t\t%d\n",
d645 1
a645 1
	printf("Received multicast frames:\t\t%d\n",
d647 1
a647 1
	printf("Received fragments:\t\t\t%d\n",
d649 1
a649 1
	printf("Received unicast octets:\t\t%d\n",
d651 1
a651 1
	printf("Received multicast octets:\t\t%d\n",
d653 1
a653 1
	printf("Receive FCS errors:\t\t\t%d\n",
d655 1
a655 1
	printf("Receive discards due to no buffer:\t%d\n",
d657 1
a657 1
	printf("Can't decrypt WEP frame:\t\t%d\n",
d659 1
a659 1
	printf("Received message fragments:\t\t%d\n",
d661 1
a661 1
	printf("Received message bad fragments:\t\t%d\n",
@


1.26
log
@yes, string could be up to 32; pt out by Cory Bosley (openbsd@@bosleys.org) via pr#2508
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.25 2002/03/31 00:54:03 mickey Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.25 2002/03/31 00:54:03 mickey Exp $";
d315 1
a315 1
	        if (strlen(key) > 30)
d317 1
a317 1
			    "more than 28 hex digits long");
d319 1
a319 1
	        if (strlen(key) > 14)
d321 1
a321 1
			    "more than 14 characters long");
@


1.25
log
@extraneous  new line in stations list
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.24 2002/03/28 20:48:38 mickey Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.24 2002/03/28 20:48:38 mickey Exp $";
d184 1
a184 1
	if (strlen(str) > 30)
@


1.24
log
@list out the ap's stations
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.23 2002/03/28 19:32:44 mickey Exp $	*/
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.23 2002/03/28 19:32:44 mickey Exp $";
d702 1
a702 1
			printf(", sig=%d/%d\n",
@


1.23
log
@chip id copies here; just for niels, all for niels, all in the name of niels
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.22 2002/03/28 18:34:01 millert Exp $	*/
d53 1
d57 1
d72 1
a72 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.22 2002/03/28 18:34:01 millert Exp $";
d75 18
a92 16
static void wi_getval(char *, struct wi_req *);
static void wi_setval(char *, struct wi_req *);
static void wi_printstr(struct wi_req *);
static void wi_setstr(char *, int, char *);
static void wi_setbytes(char *, int, char *, int);
static void wi_setword(char *, int, char *);
static void wi_sethex(char *, int, char *);
static void wi_printwords(struct wi_req *);
static void wi_printbool(struct wi_req *);
static void wi_printhex(struct wi_req *);
static void wi_dumpinfo(char *);
static void wi_setkeys(char *, int, char *);
static void wi_printkeys(struct wi_req *);
static void wi_printcardid(struct wi_req *, int);
static void wi_dumpstats(char *);
static void usage(void);
d94 1
a94 1
static void
d118 1
a118 1
static void
d250 1
a250 1
static int
d264 1
a264 1
static void
d289 1
a289 1
static void
d335 1
a335 1
static void
d479 1
a479 1
static struct wi_table wi_table[] = {
d491 1
a491 1
	{ WI_RID_PORTTYPE, WI_WORDS, "Port type (1=BSS, 3=ad-hoc):\t\t"},
d507 1
a507 1
static struct wi_table wi_crypt_table[] = {
d516 1
a516 1
static void
d607 1
a607 1
static void
d665 44
a708 1
static void
d714 2
a715 2
	    "usage: %s interface "
	    "[-o] [-t tx rate] [-n network name] [-s station name]\n"
d731 1
a731 1
static struct wi_func wi_opt[] = {
d766 2
a767 2
	char			*iface = "wi0";
	int                     ch, p, dumpstats = 0, dumpinfo = 1, ifspecified = 0;
d769 1
d778 1
a778 1
	    "a:c:d:e:f:hi:k:m:n:op:q:r:s:t:v:A:M:S:P:R:T:")) != -1) {
d796 3
d825 4
a828 1
	if (dumpstats)
d831 1
a831 1
	if (dumpinfo && !dumpstats)
d835 35
@


1.22
log
@WI_RID_AUTH_CNTL was renamed to WI_RID_CNFAUTHMODE
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.21 2002/03/21 01:08:40 millert Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.21 2002/03/21 01:08:40 millert Exp $";
d399 3
@


1.21
log
@Change 'Airport' to 'Lucent (embedded)' to correspond to reality.
Otherwise, the embedded Lucent wavelan is called 'Airport' on Toshiba
and Sony laptops.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.20 2002/02/16 21:27:38 millert Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.20 2002/02/16 21:27:38 millert Exp $";
d502 1
a502 1
        { WI_RID_AUTH_CNTL, WI_WORDS,
d695 1
a695 1
	{ 'A', wi_setword, WI_RID_AUTH_CNTL, NULL },
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.19 2001/08/17 00:40:11 millert Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.19 2001/08/17 00:40:11 millert Exp $";
d407 1
a407 1
		chip_name = "Airport";
@


1.19
log
@Sony is Chip ID 2 (like in the Aibo)
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.18 2001/06/25 18:07:35 drahn Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.18 2001/06/25 18:07:35 drahn Exp $";
d73 16
a88 16
static void wi_getval		__P((char *, struct wi_req *));
static void wi_setval		__P((char *, struct wi_req *));
static void wi_printstr		__P((struct wi_req *));
static void wi_setstr		__P((char *, int, char *));
static void wi_setbytes		__P((char *, int, char *, int));
static void wi_setword		__P((char *, int, char *));
static void wi_sethex		__P((char *, int, char *));
static void wi_printwords	__P((struct wi_req *));
static void wi_printbool	__P((struct wi_req *));
static void wi_printhex		__P((struct wi_req *));
static void wi_dumpinfo		__P((char *));
static void wi_setkeys		__P((char *, int, char *));
static void wi_printkeys	__P((struct wi_req *));
static void wi_printcardid	__P((struct wi_req *, int));
static void wi_dumpstats	__P((char *));
static void usage		__P((void));
@


1.18
log
@Identify the Apple Airport card.
ok, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.17 2001/06/24 22:24:00 provos Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.17 2001/06/24 22:24:00 provos Exp $";
d402 3
@


1.17
log
@prevent buffer overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.16 2001/06/24 01:58:13 marc Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.16 2001/06/24 01:58:13 marc Exp $";
d402 3
@


1.16
log
@fix multiple key handling in wicontrol.
The entry for option 'k' in the wi_opt table MUST be the first
entry for the code that processes the -v option to work
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.15 2001/06/07 18:58:39 millert Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.15 2001/06/07 18:58:39 millert Exp $";
d143 1
a143 1
	int			i;
d147 2
a148 1
		for (i = 0; i < (wreq->wi_len - 1) * 2; i++) {
d156 2
a157 1
		for (i = 0; i < len; i++) {
@


1.15
log
@o alphabetize getopt() options and wi_opt()
o print max data len, microwave oven robustness, roaming mode from NetBSD
o endian fixes from NetBSD
o print card and firmware info, adapted from wi_get_id()
o Some minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.14 2001/06/04 14:59:50 mickey Exp $	*/
d70 1
a70 1
	"@@(#) $OpenBSD: wicontrol.c,v 1.14 2001/06/04 14:59:50 mickey Exp $";
d674 1
a679 1
	{ 'k', wi_setkeys, 0, NULL },
@


1.14
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.13 2001/05/15 02:40:36 millert Exp $	*/
d34 1
a34 1
 *	From: wicontrol.c,v 1.6 1999/05/22 16:12:49 wpaul Exp $
d55 1
d70 1
a70 1
	"@@(#) $Id: wicontrol.c,v 1.13 2001/05/15 02:40:36 millert Exp $";
d86 3
a88 1
static void usage		__P((char *));
d90 2
a91 1
static void wi_getval(iface, wreq)
a111 2

	return;
d114 2
a115 1
static void wi_setval(iface, wreq)
a135 2

	return;
d138 2
a139 1
void wi_printstr(wreq)
d152 2
d155 1
a155 1
		for (i = 0; i < wreq->wi_val[0]; i++) {
a162 2

	return;
d165 2
a166 1
void wi_setstr(iface, code, str)
d183 1
a183 1
	wreq.wi_val[0] = strlen(str);
a186 2

	return;
d189 2
a190 1
void wi_setbytes(iface, code, bytes, len)
a204 2

	return;
d207 2
a208 1
void wi_setword(iface, code, word)
d220 1
a220 1
	wreq.wi_val[0] = value;
a222 2

	return;
d225 2
a226 1
void wi_sethex(iface, code, str)
a241 2

	return;
d244 2
a245 1
static int wi_hex2int(c)
d258 2
a259 1
static void wi_str2key(s, k)
d275 1
a275 1
                k->wi_keylen = n;
d279 1
a279 1
                k->wi_keylen = strlen(s);
a280 2

        return;
d283 2
a284 1
static void wi_setkeys(iface, idx, key)
d298 1
a298 1
        if (wreq.wi_val[0] == 0)
a326 2

        return;
d329 2
a330 1
static void wi_printkeys(wreq)
d343 2
a344 2
                for (j = 0; j < k->wi_keylen; j++) {
		        if (!isprint(ptr[j])) {
d352 1
a352 1
		        for (j = 0; j < k->wi_keylen; j++)
d360 1
d362 47
a408 2
        return;
};
d410 2
a411 1
void wi_printwords(wreq)
d418 1
a418 1
		printf("%d ", wreq->wi_val[i]);
a419 2

	return;
d422 2
a423 1
void wi_printbool(wreq)
d426 1
a426 1
	if (wreq->wi_val[0])
a429 2

	return;
d432 2
a433 1
void wi_printhex(wreq)
a448 1
	return;
d456 1
d480 1
d483 2
d488 1
d494 2
d501 2
a502 1
static void wi_dumpinfo(iface)
d506 1
a506 1
	int			i, has_wep;
d509 1
d511 4
d516 2
a517 1
	wreq.wi_len = WI_MAX_DATALEN;
d519 1
a519 1

d521 1
a521 1
	has_wep = wreq.wi_val[0];
d546 3
d571 2
a572 1
					wreq.wi_val[0]++;
a589 2

	return;
d592 2
a593 1
static void wi_dumpstats(iface)
d607 1
a647 2

	return;
d650 2
a651 2
static void usage(p)
	char			*p;
d653 2
d656 1
a656 1
	    "usage: wicontrol interface "
d661 2
a662 1
	    "       [-f frequency] [-P 0|1] [-S max sleep duration]\n");
a673 15
        { 'k', wi_setkeys, 0, NULL },
        { 'c', wi_setword, WI_RID_CREATE_IBSS, NULL },
        { 'd', wi_setword, WI_RID_MAX_DATALEN, NULL },
        { 'f', wi_setword, WI_RID_OWN_CHNL, NULL },
        { 'p', wi_setword, WI_RID_PORTTYPE, NULL },
        { 'r', wi_setword, WI_RID_RTS_THRESH, NULL },
        { 't', wi_setword, WI_RID_TX_RATE, NULL },
        { 'n', wi_setstr, WI_RID_DESIRED_SSID, NULL },
        { 's', wi_setstr, WI_RID_NODENAME, NULL },
        { 'm', wi_sethex, WI_RID_MAC_NODE, NULL },
        { 'q', wi_setstr, WI_RID_OWN_SSID, NULL },
        { 'T', wi_setword, WI_RID_TX_CRYPT_KEY, NULL },
        { 'S', wi_setword, WI_RID_MAX_SLEEP, NULL },
        { 'P', wi_setword, WI_RID_PM_ENABLED, NULL },
        { 'e', wi_setword, WI_RID_ENCRYPTION, NULL },
d675 26
a700 8

        /* These options will never be command line options which is why
          they are not 'quoted' */
        { 1, wi_setkeys, 0, NULL }, /* Dummy option for key 0 */
        { 2, wi_setkeys, 1, NULL }, /* key 1 */
        { 3, wi_setkeys, 2, NULL }, /* key 2 */
        { 4, wi_setkeys, 3, NULL }, /* key 3 */
        { 0, NULL, 0, NULL }
d703 2
a704 1
int main(argc, argv)
d719 1
a719 1
	    "hoc:d:f:p:r:q:t:n:s:i:m:P:S:T:e:k:v:a:")) != -1) {
d750 1
a750 1
		        usage(argv[0]);
d756 1
a756 1
		usage(argv[0]);
d769 1
a769 1
	return (0);
@


1.13
log
@Split wi(4) into bus-dependent and bus-independent bits similar to
an(4) -- no real code changes at this point.
Rename if_wavelan_ieee.h to if_wi_ieee.h while I'm at it and
create an if_wivar.h similar to NetBSD.
PCI adaptors exist that are not true PCMCIA controllers so
wi(4) @@ PCI is possible (though the code is not working yet ;-).
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.12 2000/10/13 18:58:10 chris Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.12 2000/10/13 18:58:10 chris Exp $";
d704 1
a704 1
	exit(0);
@


1.12
log
@The -i flags was being ignored, this breaks backwards compatibility

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.11 2000/08/17 21:57:40 deraadt Exp $	*/
d54 1
a54 1
#include <dev/pcmcia/if_wavelan_ieee.h>
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.11 2000/08/17 21:57:40 deraadt Exp $";
@


1.11
log
@make interface optional, and provide a good default
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.10 2000/08/16 17:39:56 millert Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.10 2000/08/16 17:39:56 millert Exp $";
d644 1
a644 1
	int                     ch, p, dumpstats = 0, dumpinfo = 1;
d650 1
d669 1
a669 1
		        if (iface == NULL)
@


1.10
log
@Implement -a option, was documented but not present.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.9 2000/08/11 09:13:21 ho Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.9 2000/08/11 09:13:21 ho Exp $";
d643 1
a643 1
	char			*iface = NULL;
@


1.9
log
@Permit multiple -k <key> -v # arguments. Work by <binkertn@@umich.edu> and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.8 2000/06/18 20:44:36 aaron Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.8 2000/06/18 20:44:36 aaron Exp $";
d628 1
d653 1
a653 1
	    "hoc:d:f:p:r:q:t:n:s:i:m:P:S:T:e:k:v:")) != -1) {
@


1.8
log
@strcpy() -> strlcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.7 2000/03/02 18:50:00 ho Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.7 2000/03/02 18:50:00 ho Exp $";
d613 1
d628 7
a634 1
        { 'k', wi_setkeys, 0, NULL },
d672 6
a677 4
			        if (wi_opt[p].key == 'k') {
				        wi_opt[p].wi_code = strtol(optarg, 
								   NULL, 10);
					wi_opt[p].wi_code--; /* 1-4/0-3 */
@


1.7
log
@Fix; don't print settings with other options present. Slightly modify
the -o option handling. Modify manpage to match. (angelos@@ ok)
Angelos also spotted that usage() still said 'wiconfig', not 'wicontrol'.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.6 2000/02/26 23:36:28 ho Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.6 2000/02/26 23:36:28 ho Exp $";
d96 1
a96 1
	strcpy(ifr.ifr_name, iface);
d121 1
a121 1
	strcpy(ifr.ifr_name, iface);
@


1.6
log
@Handle the options better. angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.5 2000/02/24 17:09:55 ho Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.5 2000/02/24 17:09:55 ho Exp $";
d596 1
a596 1
	    "usage: wiconfig interface "
d636 1
a636 1
	int                     ch, p, dumpstats = 0;
d651 1
a651 1
				ch = 0;
a681 5
	if (dumpstats) {
	        wi_dumpstats(iface);
		exit(0);
	}

d687 5
a691 1
	wi_dumpinfo(iface);
@


1.5
log
@Do not exit() after just one option/command. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.4 2000/02/03 09:55:19 angelos Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.4 2000/02/03 09:55:19 angelos Exp $";
d77 1
a77 1
static void wi_setword		__P((char *, int, int));
d83 1
a83 1
static void wi_setkeys		__P((char *, char *, int));
a169 3
	if (iface == NULL)
		errx(1, "must specify interface name");

a195 3
	if (iface == NULL)
		errx(1, "must specify interface name");

d210 1
a210 1
	int			word;
d213 1
a213 3

	if (iface == NULL)
		errx(1, "must specify interface name");
d219 1
a219 1
	wreq.wi_val[0] = word;
d285 1
a285 1
static void wi_setkeys(iface, key, idx)
d287 1
a288 1
        int                     idx;
a293 3
	if (iface == NULL)
		errx(1, "must specify interface name");

a539 3
	if (iface == NULL)
		errx(1, "must specify interface name");

d605 26
a634 1
	int			ch;
d636 1
a636 4
	char			*p = argv[0];
	char                    *key = NULL;
	int                     modifier = 0;
	int                     ok_to_exit = 0;
d646 7
d654 2
d657 1
a657 2
			wi_dumpstats(iface);
			exit(0);
d660 2
a661 62
			if (iface == NULL)
				iface = optarg;
			break;
		case 'c':
			wi_setword(iface, WI_RID_CREATE_IBSS, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'd':
			wi_setword(iface, WI_RID_MAX_DATALEN, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'f':
			wi_setword(iface, WI_RID_OWN_CHNL, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'p':
			wi_setword(iface, WI_RID_PORTTYPE, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'r':
			wi_setword(iface, WI_RID_RTS_THRESH, atoi(optarg));
			ok_to_exit ++;
			break;
		case 't':
			wi_setword(iface, WI_RID_TX_RATE, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'n':
			wi_setstr(iface, WI_RID_DESIRED_SSID, optarg);
			ok_to_exit ++;
			break;
		case 's':
			wi_setstr(iface, WI_RID_NODENAME, optarg);
			ok_to_exit ++;
			break;
		case 'm':
			wi_sethex(iface, WI_RID_MAC_NODE, optarg);
			ok_to_exit ++;
			break;
		case 'q':
			wi_setstr(iface, WI_RID_OWN_SSID, optarg);
			ok_to_exit ++;
			break;
		case 'S':
			wi_setword(iface, WI_RID_MAX_SLEEP, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'P':
			wi_setword(iface, WI_RID_PM_ENABLED, atoi(optarg));
			ok_to_exit ++;
			break;
		case 'T':
			wi_setword(iface, WI_RID_TX_CRYPT_KEY,
				   atoi(optarg) - 1);
			ok_to_exit ++;
			break;
		case 'k':
		        key = optarg;
			break;
		case 'e':
		        wi_setword(iface, WI_RID_ENCRYPTION, atoi(optarg));
			ok_to_exit ++;
d664 8
a671 3
		        modifier = atoi(optarg);
			modifier--;
			break;
d674 1
a674 1
			usage(p);
d679 2
a680 2
	if (ok_to_exit)
	        exit(0);
d682 4
a685 2
	if (iface == NULL)
		usage(p);
d687 4
a690 2
	if (key != NULL)
	        wi_setkeys(iface, key, modifier);
@


1.4
log
@Correctly handle and print hexadecimal keys.
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.3 2000/02/03 00:53:59 angelos Exp $	*/
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.3 2000/02/03 00:53:59 angelos Exp $";
d628 1
d649 1
a649 1
			exit(0);
d653 1
a653 1
			exit(0);
d657 1
a657 1
			exit(0);
d661 1
a661 1
			exit(0);
d665 1
a665 1
			exit(0);
d669 1
a669 1
			exit(0);
d673 1
a673 1
			exit(0);
d677 1
a677 1
			exit(0);
d681 1
a681 1
			exit(0);
d685 1
a685 1
			exit(0);
d689 1
a689 1
			exit(0);
d693 1
a693 1
			exit(0);
d698 1
a698 1
			exit(0);
d705 1
a705 1
			exit(0);
d717 3
@


1.3
log
@WEP support (ported from FreeBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.2 2000/01/02 07:33:01 deraadt Exp $	*/
d59 1
d69 1
a69 1
	"@@(#) $Id: wicontrol.c,v 1.2 2000/01/02 07:33:01 deraadt Exp $";
d320 9
a328 4
        if (strlen(key) > 14) {
                err(1, "encryption key must be no "
                    "more than 14 characters long");
        }
d346 1
a346 1
        int                     i, j;
d353 1
a353 1
	for (i = 0; i < 4; i++) {
d357 15
a371 5
                        if (ptr[i] == '\0')
                                ptr[i] = ' ';
                }
                ptr[j] = '\0';
                printf("[ %s ]", ptr);
@


1.2
log
@chagne wicontrol so that it is activated as:
	wicontrol interface [options]
you can still use [-i interface] if you really feel like it
@
text
@d1 1
a1 1
/*	$OpenBSD: wicontrol.c,v 1.1 1999/07/11 16:31:08 niklas Exp $	*/
d68 1
a68 1
	"@@(#) $Id: wicontrol.c,v 1.1 1999/07/11 16:31:08 niklas Exp $";
d82 2
d219 3
d253 108
d408 1
d430 2
a431 1
	{ WI_RID_TX_RATE, WI_WORDS, "TX rate:\t\t\t\t"},
d440 7
d451 1
a451 1
	int			i;
d454 8
d491 35
d596 1
d610 2
d620 1
a620 1
	    "hoc:d:f:p:r:q:t:n:s:i:m:P:S:")) != -1) {
d678 16
d703 3
@


1.1
log
@WaveLAN configuration utility
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
	"@@(#) $Id: wicontrol.c,v 1.6 1999/05/22 16:12:49 wpaul Exp $";
d428 6
a433 16
	fprintf(stderr, "usage:  %s -i iface\n", p);
	fprintf(stderr, "\t%s -i iface -o\n", p);
	fprintf(stderr, "\t%s -i iface -t tx rate\n", p);
	fprintf(stderr, "\t%s -i iface -n network name\n", p);
	fprintf(stderr, "\t%s -i iface -s station name\n", p);
	fprintf(stderr, "\t%s -i iface -c 0|1\n", p);
	fprintf(stderr, "\t%s -i iface -q SSID\n", p);
	fprintf(stderr, "\t%s -i iface -p port type\n", p);
	fprintf(stderr, "\t%s -i iface -a access point density\n", p);
	fprintf(stderr, "\t%s -i iface -m mac address\n", p);
	fprintf(stderr, "\t%s -i iface -d max data length\n", p);
	fprintf(stderr, "\t%s -i iface -r RTS threshold\n", p);
	fprintf(stderr, "\t%s -i iface -f frequency\n", p);
	fprintf(stderr, "\t%s -i iface -P 0|1t\n", p);
	fprintf(stderr, "\t%s -i iface -S max sleep duration\n", p);

d445 6
d452 1
a452 1
	    "hoc:d:f:i:p:r:q:t:n:s:m:P:S:")) != -1) {
d459 2
a460 1
			iface = optarg;
@

