head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.12
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.8
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.10
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.8
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.05.21.19.14.02;	author jmc;	state Exp;
branches;
next	1.32;
commitid	y0WbxfQmMYwQ9Ee5;

1.32
date	2016.05.21.18.11.36;	author natano;	state Exp;
branches;
next	1.31;
commitid	h6HuALSffVqURa2m;

1.31
date	2015.11.02.01.22.37;	author chl;	state Exp;
branches;
next	1.30;
commitid	t6aPWxViwSZiNO10;

1.30
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	6b2lLILbgCR1fvia;

1.29
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2012.12.04.02.27.00;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.09.12.58.01;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.08.14.30.58;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.04.13.49.48;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.20.03.45.54;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.15.12.48.29;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.15.03.04.24;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.08.20.09.37;	author jaredy;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.03.22.41.40;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.02.22.38.53;	author avsm;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.18.22.16.24;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.04.20.23.06.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.12.21.14.21.23;	author art;	state Exp;
branches;
next	1.10;

1.10
date	97.06.20.14.44.39;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.41.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.12.16.17.11.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.09.13.40.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.11.24.23.46.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.14.31.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.46.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.29.01.35.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.36.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@no more -x;
@
text
@/*	$OpenBSD: mount_msdos.c,v 1.32 2016/05/21 18:11:36 natano Exp $	*/
/*	$NetBSD: mount_msdos.c,v 1.16 1996/10/24 00:12:50 cgd Exp $	*/

/*
 * Copyright (c) 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <ctype.h>
#include <err.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

#include "mntopts.h"

const struct mntopt mopts[] = {
	MOPT_STDOPTS,
	MOPT_UPDATE,
	MOPT_ASYNC,
	{ NULL }
};

gid_t	a_gid(char *);
uid_t	a_uid(char *);
mode_t	a_mask(char *);
void	usage(void);

int
main(int argc, char **argv)
{
	struct msdosfs_args args;
	struct stat sb;
	int c, mntflags, set_gid, set_uid, set_mask;
	char *dev, dir[PATH_MAX];
	char *errcause;

	mntflags = set_gid = set_uid = set_mask = 0;
	(void)memset(&args, '\0', sizeof(args));

	while ((c = getopt(argc, argv, "sl9u:g:m:o:")) != -1) {
		switch (c) {
		case 's':
			args.flags |= MSDOSFSMNT_SHORTNAME;
			break;
		case 'l':
			args.flags |= MSDOSFSMNT_LONGNAME;
			break;
		case '9':
			args.flags |= MSDOSFSMNT_NOWIN95;
			break;
		case 'u':
			args.uid = a_uid(optarg);
			set_uid = 1;
			break;
		case 'g':
			args.gid = a_gid(optarg);
			set_gid = 1;
			break;
		case 'm':
			args.mask = a_mask(optarg);
			set_mask = 1;
			break;
		case 'o':
			getmntopts(optarg, mopts, &mntflags);
			break;
		case '?':
		default:
			usage();
			break;
		}
	}

	if (optind + 2 != argc)
		usage();

	dev = argv[optind];
	if (realpath(argv[optind + 1], dir) == NULL)
		err(1, "realpath %s", argv[optind + 1]);

	args.fspec = dev;
	args.export_info.ex_root = -2;	/* unchecked anyway on DOS fs */
	if (mntflags & MNT_RDONLY)
		args.export_info.ex_flags = MNT_EXRDONLY;
	else
		args.export_info.ex_flags = 0;
	if (!set_gid || !set_uid || !set_mask) {
		if (stat(dir, &sb) == -1)
			err(1, "stat %s", dir);

		if (!set_uid)
			args.uid = sb.st_uid;
		if (!set_gid)
			args.gid = sb.st_gid;
		if (!set_mask)
			args.mask = sb.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO);
	}

	if (mount(MOUNT_MSDOS, dir, mntflags, &args) < 0) {
		switch (errno) {
		case EOPNOTSUPP:
			errcause = "filesystem not supported by kernel";
			break;
		case EMFILE:
			errcause = "mount table full";
			break;
		case EINVAL:
			errcause =
			    "not an MSDOS filesystem";
			break;
		default:
			errcause = strerror(errno);
			break;
		}
		errx(1, "%s on %s: %s", args.fspec, dir, errcause);
	}

	exit (0);
}

gid_t
a_gid(char *s)
{
	struct group *gr;
	const char *errstr;
	gid_t gid;

	if ((gr = getgrnam(s)) != NULL)
		return gr->gr_gid;
	gid = strtonum(s, 0, GID_MAX, &errstr);
	if (errstr)
		errx(1, "group is %s: %s", errstr, s);
	return (gid);
}

uid_t
a_uid(char *s)
{
	struct passwd *pw;
	const char *errstr;
	uid_t uid;

	if ((pw = getpwnam(s)) != NULL)
		return pw->pw_uid;
	uid = strtonum(s, 0, UID_MAX, &errstr);
	if (errstr)
		errx(1, "user is %s: %s", errstr, s);
	return (uid);
}

mode_t
a_mask(char *s)
{
	int done, rv;
	char *ep;

	done = 0;
	if (*s >= '0' && *s <= '7') {
		done = 1;
		rv = strtol(optarg, &ep, 8);
	}
	if (!done || rv < 0 || *ep)
		errx(1, "invalid file mode: %s", s);
	return (rv);
}

void
usage(void)
{

	fprintf(stderr,
	    "usage: mount_msdos [-9ls] [-g gid] [-m mask] [-o options] [-u uid] special node\n");
	exit(1);
}
@


1.32
log
@Remove the -x flag from mount_msdos and always assume the execute bit
for readable directories, while making it subject to the mask option
(-m in mount_msdos), so it is still possible to mount with
non-executable directories, but with semantics that are easier to
comprehend.

This makes directory listings with default mount options work again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.31 2015/11/02 01:22:37 chl Exp $	*/
d205 1
a205 1
	    "usage: mount_msdos [-9lsx] [-g gid] [-m mask] [-o options] [-u uid] special node\n");
@


1.31
log
@remove unused variables

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.30 2015/04/18 18:28:37 deraadt Exp $	*/
d74 1
a74 1
	while ((c = getopt(argc, argv, "sl9xu:g:m:o:")) != -1) {
a83 3
			break;
		case 'x':
			args.flags |= MSDOSFSMNT_ALLOWDIRX;
@


1.30
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.29 2015/01/16 06:39:59 deraadt Exp $	*/
a161 1
	char *gname;
a176 1
	char *uname;
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.28 2013/11/22 04:12:48 deraadt Exp $	*/
d161 1
d166 4
a169 9
		gid = gr->gr_gid;
	else {
		for (gname = s; isdigit((unsigned char)*s); ++s)
			;
		if (!*s)
			gid = atoi(gname);
		else
			errx(1, "unknown group id: %s", gname);
	}
d177 1
d182 4
a185 9
		uid = pw->pw_uid;
	else {
		for (uname = s; isdigit((unsigned char)*s); ++s)
			;
		if (!*s)
			uid = atoi(uname);
		else
			errx(1, "unknown user id: %s", uname);
	}
@


1.28
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.27 2012/12/04 02:27:00 deraadt Exp $	*/
d34 1
a34 1
#include <sys/param.h>
d45 1
d68 1
a68 1
	char *dev, dir[MAXPATHLEN];
@


1.27
log
@remove some unnecessary sys/cdefs.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.26 2012/07/09 12:58:01 krw Exp $	*/
d166 2
a167 1
		for (gname = s; isdigit(*s); ++s);
d186 2
a187 1
		for (uname = s; isdigit(*s); ++s);
@


1.26
log
@Revert previous.

The standards gpds are jealous gods. kettenis@@ and beck@@ have shown
EROFS is the wrong thing to return. So revert to EACCES until a
better error code is decided on.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.25 2012/07/08 14:30:58 krw Exp $	*/
a33 1
#include <sys/cdefs.h>
@


1.25
log
@Return EROFS when a read-write mount of a read-only sd(4) device
is attempted. This is instead of the current EACCES and is intended
to result in better error messages from mount(8).

Tweak default EROFS error text to mention fsck'ing in mount_ext2fs
and mount_msdos since they both have fsck's like ffs.

ok deraadt@@ aja@@ ian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.24 2011/04/04 13:49:48 tedu Exp $	*/
a141 4
			break;
		case EROFS:
			errcause =
			    "filesystem must be mounted read-only; you may need to run fsck";
@


1.24
log
@no reason not to let msdosfs mount async, from Alexander Polakov
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.23 2009/10/27 23:59:33 deraadt Exp $	*/
d142 4
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.22 2007/03/20 03:45:54 tedu Exp $	*/
d53 1
@


1.22
log
@remove some bogus *p, from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.21 2006/12/15 12:48:29 jmc Exp $	*/
a32 4

#ifndef lint
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.21 2006/12/15 12:48:29 jmc Exp $";
#endif /* not lint */
@


1.21
log
@sort options; sync usage;
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.20 2006/12/15 03:04:24 krw Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.20 2006/12/15 03:04:24 krw Exp $";
d170 1
a170 1
		for (gname = s; *s && isdigit(*s); ++s);
d189 1
a189 1
		for (uname = s; *s && isdigit(*s); ++s);
@


1.20
log
@Nuke GEMDOSFS. Unused part of unused atari port. Simplifies
MSDOSFS code. Eliminates -G option to mount_msdos.

Nit detection by gwk@@, tom@@, jmc@@.

ok weingart@@ tom@@ thib@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.19 2005/04/08 20:09:37 jaredy Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.19 2005/04/08 20:09:37 jaredy Exp $";
d219 1
a219 1
	    "usage: mount_msdos [-o options] [-u user] [-g group] [-m mask] bdev dir\n");
@


1.19
log
@Sync with recent realpath(3) changes:  on failure, don't use the second
argument "resolved", since it is undefined.

ok and help millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.18 2003/07/03 22:41:40 tedu Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.18 2003/07/03 22:41:40 tedu Exp $";
d77 1
a77 1
	while ((c = getopt(argc, argv, "Gsl9xu:g:m:o:")) != -1) {
a78 3
		case 'G':
			args.flags |= MSDOSFSMNT_GEMDOSFS;
			break;
@


1.18
log
@use realpath() in helpers instead of doing it ourselves every time.
also fixes pr1662.  from otto moerbeek
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.17 2003/07/02 22:38:53 avsm Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.17 2003/07/02 22:38:53 avsm Exp $";
d121 1
a121 1
		err(1, "realpath %s", dir);
@


1.17
log
@convert strncat -> strlcat
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.16 2003/06/11 06:22:14 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.16 2003/06/11 06:22:14 deraadt Exp $";
d71 1
a71 1
	char *dev, *dir, ndir[MAXPATHLEN];
d120 2
a121 10
	dir = argv[optind + 1];
	if (dir[0] != '/') {
		warnx("\"%s\" is a relative path.", dir);
		if (getcwd(ndir, sizeof(ndir)) == NULL)
			err(1, "getcwd");
		strlcat(ndir, "/", sizeof(ndir));
		strlcat(ndir, dir, sizeof(ndir));
		dir = ndir;
		warnx("using \"%s\" instead.", dir);
	}
@


1.16
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.15 2003/04/18 22:16:24 tedu Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.15 2003/04/18 22:16:24 tedu Exp $";
d71 1
a71 1
	char *dev, *dir, ndir[MAXPATHLEN+1];
d125 2
a126 2
		strncat(ndir, "/", sizeof(ndir) - strlen(ndir));
		strncat(ndir, dir, sizeof(ndir) - strlen(ndir));
@


1.15
log
@support for making directories executable if readable.
to use this, you want to run mount_msdos with -m 0644 -x or so.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.14 2002/04/23 18:54:12 espie Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.14 2002/04/23 18:54:12 espie Exp $";
d66 1
a66 3
main(argc, argv)
	int argc;
	char **argv;
d172 1
a172 2
a_gid(s)
	char *s;
d191 1
a191 2
a_uid(s)
	char *s;
d210 1
a210 2
a_mask(s)
	char *s;
d226 1
a226 1
usage()
d229 2
a230 1
	fprintf(stderr, "usage: mount_msdos [-o options] [-u user] [-g group] [-m mask] bdev dir\n");
@


1.14
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.13 2002/02/16 21:27:36 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.13 2002/02/16 21:27:36 millert Exp $";
d79 1
a79 1
	while ((c = getopt(argc, argv, "Gsl9u:g:m:o:")) != -1) {
d92 3
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.12 1999/04/20 23:06:47 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.12 1999/04/20 23:06:47 millert Exp $";
d131 1
a131 1
	args.export.ex_root = -2;	/* unchecked anyway on DOS fs */
d133 1
a133 1
		args.export.ex_flags = MNT_EXRDONLY;
d135 1
a135 1
		args.export.ex_flags = 0;
@


1.12
log
@if mount fails with EINVAL, say "not an MSDOS filesystem"
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.11 1998/12/21 14:21:23 art Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.11 1998/12/21 14:21:23 art Exp $";
d60 4
a63 4
gid_t	a_gid __P((char *));
uid_t	a_uid __P((char *));
mode_t	a_mask __P((char *));
void	usage __P((void));
@


1.11
log
@nice error message when mount(2) returns EOPNOTSUPP
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.10 1997/06/20 14:44:39 kstailey Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.10 1997/06/20 14:44:39 kstailey Exp $";
d158 1
a158 1
			    "specified device does not match mounted device";
@


1.10
log
@Now that mount(2) sets errno to EFTYPE, not EINVAL for "invalid file system"
we can use NLS for the text, not a hardcode English message.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.9 1997/01/15 23:41:22 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.9 1997/01/15 23:41:22 millert Exp $";
d150 3
@


1.9
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.8 1996/12/16 17:11:38 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.8 1996/12/16 17:11:38 deraadt Exp $";
d154 1
a154 2
			if (mntflags & MNT_UPDATE)
				errcause =
a155 2
			else 
				errcause = "incorrect super block";
@


1.8
log
@does noone know how to use strncat correctly?
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.7 1996/12/09 13:40:55 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.7 1996/12/09 13:40:55 deraadt Exp $";
d79 1
a79 1
	while ((c = getopt(argc, argv, "Gsl9u:g:m:o:")) != EOF) {
@


1.7
log
@better error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.6 1996/11/24 23:46:46 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.6 1996/11/24 23:46:46 millert Exp $";
d124 2
a125 2
		strncat(ndir, "/", sizeof(ndir) - strlen(ndir) - 1);
		strncat(ndir, dir, sizeof(ndir) - strlen(ndir) - 1);
@


1.6
log
@Add MOPT_UPDATE to mount options since there is filesystem
support for it.  From NetBSD (cgd).
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_msdos.c,v 1.5 1996/06/23 14:31:27 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.5 1996/06/23 14:31:27 deraadt Exp $";
d50 1
d74 1
d148 18
a165 2
	if (mount(MOUNT_MSDOS, dir, mntflags, &args) < 0)
		err(1, "mount");
@


1.5
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: mount_msdos.c,v 1.14 1996/04/13 05:35:47 cgd Exp $	*/
/*	$NetBSD: mount_msdos.c,v 1.14 1996/04/13 05:35:47 cgd Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mount_msdos.c,v 1.14 1996/04/13 05:35:47 cgd Exp $";
d55 1
@


1.4
log
@sync to netbsd 960418
@
text
@d1 1
d35 1
a35 1
static char rcsid[] = "$NetBSD: mount_msdos.c,v 1.14 1996/04/13 05:35:47 cgd Exp $";
@


1.3
log
@from leo; add -G flag for mounting atari gemdos filesystems
@
text
@d1 1
a1 1
/*	$NetBSD: mount_msdos.c,v 1.12 1996/01/19 21:14:46 leo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$NetBSD: mount_msdos.c,v 1.12 1996/01/19 21:14:46 leo Exp $";
d52 1
a52 1
struct mntopt mopts[] = {
@


1.2
log
@from ws@@netbsd:
- Add support for Win'95 separate creation/modification/access timestamps
- Re-introduce lowercase filenames for non-Win'95-filesystems
@
text
@d1 1
a1 1
/*	$NetBSD: mount_msdos.c,v 1.11 1995/10/15 15:35:48 ws Exp $	*/
d34 1
a34 1
static char rcsid[] = "$NetBSD: mount_msdos.c,v 1.11 1995/10/15 15:35:48 ws Exp $";
d75 1
a75 1
	while ((c = getopt(argc, argv, "sl9u:g:m:o:")) != EOF) {
d77 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mount_msdos.c,v 1.10 1995/03/18 14:57:38 cgd Exp $	*/
d34 1
a34 1
static char rcsid[] = "$NetBSD: mount_msdos.c,v 1.10 1995/03/18 14:57:38 cgd Exp $";
d75 1
a75 1
	while ((c = getopt(argc, argv, "u:g:m:o:")) != EOF) {
d77 9
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
