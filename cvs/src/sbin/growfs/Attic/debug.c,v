head	1.13;
access;
symbols
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2015.11.23.18.35.18;	author mmcc;	state dead;
branches;
next	1.12;
commitid	tzGJfQvw5OfoVhiq;

1.12
date	2015.11.23.15.38.52;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	IfGM2hPUhJ63gQvh;

1.11
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	Uu5nFG3wCl0LACBb;

1.10
date	2014.05.24.17.56.17;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.07.08.22.55;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.01.19.26.06;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.07.16.37.52;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.28.21.09.28;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove the debugging infrastructure, which was ~1/3 of the code. Makes
pledging easier, and it was excessive complicated stuff.

"Good." deraadt@@
@
text
@/*	$OpenBSD: debug.c,v 1.12 2015/11/23 15:38:52 mmcc Exp $	*/
/*
 * Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz
 * Copyright (c) 1980, 1989, 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christoph Herrmann and Thomas-Henning von Kamptz, Munich and Frankfurt.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors, as well as Christoph
 *      Herrmann and Thomas-Henning von Kamptz.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $TSHeader: src/sbin/growfs/debug.c,v 1.3 2000/12/12 19:31:00 tomsoft Exp $
 * $FreeBSD: src/sbin/growfs/debug.c,v 1.10 2006/10/31 22:02:24 pjd Exp $
 *
 */

#include <limits.h>
#include <stdio.h>
#include <string.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#include "debug.h"

#ifdef FS_DEBUG

static FILE	*dbg_log;
static unsigned int	indent;

/*
 * prototypes not done here, as they come with debug.h
 */

/*
 * Open the filehandle where all debug output has to go.
 */
void
dbg_open(const char *fn)
{

	if (strcmp(fn, "-") == 0)
		dbg_log = stdout;
	else
		dbg_log = fopen(fn, "a");

	return;
}

/*
 * Close the filehandle where all debug output went to.
 */
void
dbg_close(void)
{

	if (dbg_log) {
		if (dbg_log != stdout)
			fclose(dbg_log);
		dbg_log = NULL;
	}

	return;
}

/*
 * Dump out a full file system block in hex.
 */
void
dbg_dump_hex(struct fs *sb, const char *comment, unsigned char *mem)
{
	int i, j, k;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START HEXDUMP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)mem, comment);
	indent++;
	for (i = 0; i < sb->fs_bsize; i += 24) {
		for (j = 0; j < 3; j++) {
			for (k = 0; k < 8; k++)
				fprintf(dbg_log, "%02x ", *mem++);
			fprintf(dbg_log, "  ");
		}
		fprintf(dbg_log, "\n");
	}
	indent--;
	fprintf(dbg_log, "===== END HEXDUMP =====\n");

	return;
}

/*
 * Dump the superblock.
 */
void
dbg_dump_fs(struct fs *sb, const char *comment)
{
#ifdef FSMAXSNAP
	int	j;
#endif /* FSMAXSNAP */

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START SUPERBLOCK =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)sb, comment);
	indent++;

	fprintf(dbg_log, "sblkno            int32_t          0x%08x\n",
	    sb->fs_sblkno);
	fprintf(dbg_log, "cblkno            int32_t          0x%08x\n",
	    sb->fs_cblkno);
	fprintf(dbg_log, "iblkno            int32_t          0x%08x\n",
	    sb->fs_iblkno);
	fprintf(dbg_log, "dblkno            int32_t          0x%08x\n",
	    sb->fs_dblkno);

	fprintf(dbg_log, "cgoffset          int32_t          0x%08x\n",
	    sb->fs_cgoffset);
	fprintf(dbg_log, "cgmask            int32_t          0x%08x\n",
	    sb->fs_cgmask);
	fprintf(dbg_log, "time              int32_t          %10d\n",
	    sb->fs_ffs1_time);
	fprintf(dbg_log, "size              int32_t          0x%08x\n",
	    sb->fs_ffs1_size);
	fprintf(dbg_log, "dsize             int32_t          0x%08x\n",
	    sb->fs_ffs1_dsize);
	fprintf(dbg_log, "ncg               int32_t          0x%08x\n",
	    sb->fs_ncg);
	fprintf(dbg_log, "bsize             int32_t          0x%08x\n",
	    sb->fs_bsize);
	fprintf(dbg_log, "fsize             int32_t          0x%08x\n",
	    sb->fs_fsize);
	fprintf(dbg_log, "frag              int32_t          0x%08x\n",
	    sb->fs_frag);

	fprintf(dbg_log, "minfree           int32_t          0x%08x\n",
	    sb->fs_minfree);
	fprintf(dbg_log, "rotdelay          int32_t          0x%08x\n",
	    sb->fs_rotdelay);
	fprintf(dbg_log, "rps               int32_t          0x%08x\n",
	    sb->fs_rps);

	fprintf(dbg_log, "bmask             int32_t          0x%08x\n",
	    sb->fs_bmask);
	fprintf(dbg_log, "fmask             int32_t          0x%08x\n",
	    sb->fs_fmask);
	fprintf(dbg_log, "bshift            int32_t          0x%08x\n",
	    sb->fs_bshift);
	fprintf(dbg_log, "fshift            int32_t          0x%08x\n",
	    sb->fs_fshift);

	fprintf(dbg_log, "maxcontig         int32_t          0x%08x\n",
	    sb->fs_maxcontig);
	fprintf(dbg_log, "maxbpg            int32_t          0x%08x\n",
	    sb->fs_maxbpg);

	fprintf(dbg_log, "fragshift         int32_t          0x%08x\n",
	    sb->fs_fragshift);
	fprintf(dbg_log, "fsbtodb           int32_t          0x%08x\n",
	    sb->fs_fsbtodb);
	fprintf(dbg_log, "sbsize            int32_t          0x%08x\n",
	    sb->fs_sbsize);
	fprintf(dbg_log, "csmask            int32_t          0x%08x\n",
	    sb->fs_csmask);
	fprintf(dbg_log, "csshift           int32_t          0x%08x\n",
	    sb->fs_csshift);
	fprintf(dbg_log, "nindir            int32_t          0x%08x\n",
	    sb->fs_nindir);
	fprintf(dbg_log, "inopb             int32_t          0x%08x\n",
	    sb->fs_inopb);
	fprintf(dbg_log, "nspf              int32_t          0x%08x\n",
	    sb->fs_nspf);

	fprintf(dbg_log, "optim             int32_t          0x%08x\n",
	    sb->fs_optim);

	fprintf(dbg_log, "npsect            int32_t          0x%08x\n",
	    sb->fs_npsect);
	fprintf(dbg_log, "interleave        int32_t          0x%08x\n",
	    sb->fs_interleave);
	fprintf(dbg_log, "trackskew         int32_t          0x%08x\n",
	    sb->fs_trackskew);

	fprintf(dbg_log, "id                int32_t[2]       0x%08x 0x%08x\n",
	    sb->fs_id[0], sb->fs_id[1]);

	fprintf(dbg_log, "ffs1_csaddr       int32_t          0x%08x\n",
	    sb->fs_ffs1_csaddr);
	fprintf(dbg_log, "cssize            int32_t          0x%08x\n",
	    sb->fs_cssize);
	fprintf(dbg_log, "cgsize            int32_t          0x%08x\n",
	    sb->fs_cgsize);

	fprintf(dbg_log, "ntrak             int32_t          0x%08x\n",
	    sb->fs_ntrak);
	fprintf(dbg_log, "nsect             int32_t          0x%08x\n",
	    sb->fs_nsect);
	fprintf(dbg_log, "spc               int32_t          0x%08x\n",
	    sb->fs_spc);

	fprintf(dbg_log, "ncyl              int32_t          0x%08x\n",
	    sb->fs_ncyl);

	fprintf(dbg_log, "cpg               int32_t          0x%08x\n",
	    sb->fs_cpg);
	fprintf(dbg_log, "ipg               int32_t          0x%08x\n",
	    sb->fs_ipg);
	fprintf(dbg_log, "fpg               int32_t          0x%08x\n",
	    sb->fs_fpg);

	dbg_dump_csum("internal cstotal", &sb->fs_ffs1_cstotal);

	fprintf(dbg_log, "fmod              int8_t           0x%02x\n",
	    sb->fs_fmod);
	fprintf(dbg_log, "clean             int8_t           0x%02x\n",
	    sb->fs_clean);
	fprintf(dbg_log, "ronly             int8_t           0x%02x\n",
	    sb->fs_ronly);
	fprintf(dbg_log, "ffs1_flags        int8_t           0x%02x\n",
	    sb->fs_ffs1_flags);
	fprintf(dbg_log, "fsmnt             u_char[MAXMNTLEN] \"%s\"\n",
	    sb->fs_fsmnt);
	fprintf(dbg_log, "volname           u_char[MAXVOLLEN] \"%s\"\n",
	    sb->fs_volname);
	fprintf(dbg_log, "swuid             u_int64_t        0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_swuid))[1],
	    ((unsigned int *)&(sb->fs_swuid))[0]);
	fprintf(dbg_log, "pad               int32_t          0x%08x\n",
	    sb->fs_pad);
	fprintf(dbg_log, "cgrotor           int32_t          0x%08x\n",
	    sb->fs_cgrotor);
/*
 * struct csum[MAXCSBUFS] - is only maintained in memory
 */
/*	fprintf(dbg_log, " int32_t\n", sb->*fs_maxcluster);*/
	fprintf(dbg_log, "cpc               int32_t          0x%08x\n",
	    sb->fs_cpc);
/*
 * int16_t fs_opostbl[16][8] - is dumped when used in dbg_dump_sptbl
 */
	fprintf(dbg_log, "maxbsize          int32_t          0x%08x\n",
	    sb->fs_maxbsize);
#ifdef notyet
	fprintf(dbg_log, "unrefs            int64_t          0x%08llx\n",
	    sb->fs_unrefs);
#endif
	fprintf(dbg_log, "sblockloc         int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_sblockloc))[1],
	    ((unsigned int *)&(sb->fs_sblockloc))[0]);

	dbg_dump_csum_total("internal cstotal", &sb->fs_cstotal);

	fprintf(dbg_log, "time              int64_t          %10lld\n",
	    (long long)sb->fs_time);

	fprintf(dbg_log, "size              int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_size))[1],
	    ((unsigned int *)&(sb->fs_size))[0]);
	fprintf(dbg_log, "dsize             int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_dsize))[1],
	    ((unsigned int *)&(sb->fs_dsize))[0]);
	fprintf(dbg_log, "csaddr            int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_csaddr))[1],
	    ((unsigned int *)&(sb->fs_csaddr))[0]);
	fprintf(dbg_log, "pendingblocks     int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_pendingblocks))[1],
	    ((unsigned int *)&(sb->fs_pendingblocks))[0]);
	fprintf(dbg_log, "pendinginodes     int32_t          0x%08x\n",
	    sb->fs_pendinginodes);

#ifdef FSMAXSNAP
	for (j = 0; j < FSMAXSNAP; j++) {
		fprintf(dbg_log, "snapinum          int32_t[%2d]      0x%08x\n",
		    j, sb->fs_snapinum[j]);
		if (!sb->fs_snapinum[j]) { /* list is dense */
			break;
		}
	}
#endif /* FSMAXSNAP */
	fprintf(dbg_log, "avgfilesize       int32_t          0x%08x\n",
	    sb->fs_avgfilesize);
	fprintf(dbg_log, "avgfpdir          int32_t          0x%08x\n",
	    sb->fs_avgfpdir);
#ifdef notyet
	fprintf(dbg_log, "save_cgsize       int32_t          0x%08x\n",
	    sb->fs_save_cgsize);
#endif
	fprintf(dbg_log, "flags             int32_t          0x%08x\n",
	    sb->fs_flags);
	fprintf(dbg_log, "contigsumsize     int32_t          0x%08x\n",
	    sb->fs_contigsumsize);
	fprintf(dbg_log, "maxsymlinklen     int32_t          0x%08x\n",
	    sb->fs_maxsymlinklen);
	fprintf(dbg_log, "inodefmt          int32_t          0x%08x\n",
	    sb->fs_inodefmt);
	fprintf(dbg_log, "maxfilesize       u_int64_t        0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_maxfilesize))[1],
	    ((unsigned int *)&(sb->fs_maxfilesize))[0]);
	fprintf(dbg_log, "qbmask            int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_qbmask))[1],
	    ((unsigned int *)&(sb->fs_qbmask))[0]);
	fprintf(dbg_log, "qfmask            int64_t          0x%08x%08x\n",
	    ((unsigned int *)&(sb->fs_qfmask))[1],
	    ((unsigned int *)&(sb->fs_qfmask))[0]);
	fprintf(dbg_log, "state             int32_t          0x%08x\n",
	    sb->fs_state);
	fprintf(dbg_log, "postblformat      int32_t          0x%08x\n",
	    sb->fs_postblformat);
	fprintf(dbg_log, "nrpos             int32_t          0x%08x\n",
	    sb->fs_nrpos);
	fprintf(dbg_log, "postbloff         int32_t          0x%08x\n",
	    sb->fs_postbloff);
	fprintf(dbg_log, "rotbloff          int32_t          0x%08x\n",
	    sb->fs_rotbloff);
	fprintf(dbg_log, "magic             int32_t          0x%08x\n",
	    sb->fs_magic);

	indent--;
	fprintf(dbg_log, "===== END SUPERBLOCK =====\n");

	return;
}

/*
 * Dump a cylinder group.
 */
void
dbg_dump_cg(const char *comment, struct cg *cgr)
{
	int j;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START CYLINDER GROUP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cgr, comment);
	indent++;

	fprintf(dbg_log, "magic         int32_t    0x%08x\n", cgr->cg_magic);
	fprintf(dbg_log, "time          int32_t    0x%08x\n", cgr->cg_time);
	fprintf(dbg_log, "cgx           int32_t    0x%08x\n", cgr->cg_cgx);
	fprintf(dbg_log, "ncyl          int16_t    0x%04x\n", cgr->cg_ncyl);
	fprintf(dbg_log, "niblk         int16_t    0x%04x\n", cgr->cg_niblk);
	fprintf(dbg_log, "ndblk         int32_t    0x%08x\n", cgr->cg_ndblk);
	dbg_dump_csum("internal cs", &cgr->cg_cs);
	fprintf(dbg_log, "rotor         int32_t    0x%08x\n", cgr->cg_rotor);
	fprintf(dbg_log, "frotor        int32_t    0x%08x\n", cgr->cg_frotor);
	fprintf(dbg_log, "irotor        int32_t    0x%08x\n", cgr->cg_irotor);
	for (j = 0; j < MAXFRAG; j++) {
		fprintf(dbg_log, "frsum         int32_t[%d] 0x%08x\n", j,
		    cgr->cg_frsum[j]);
	}
	fprintf(dbg_log, "btotoff       int32_t    0x%08x\n", cgr->cg_btotoff);
	fprintf(dbg_log, "boff          int32_t    0x%08x\n", cgr->cg_boff);
	fprintf(dbg_log, "iusedoff      int32_t    0x%08x\n", cgr->cg_iusedoff);
	fprintf(dbg_log, "freeoff       int32_t    0x%08x\n", cgr->cg_freeoff);
	fprintf(dbg_log, "nextfreeoff   int32_t    0x%08x\n",
	    cgr->cg_nextfreeoff);
	fprintf(dbg_log, "clustersumoff int32_t    0x%08x\n",
	    cgr->cg_clustersumoff);
	fprintf(dbg_log, "clusteroff    int32_t    0x%08x\n",
	    cgr->cg_clusteroff);
	fprintf(dbg_log, "nclusterblks  int32_t    0x%08x\n",
	    cgr->cg_nclusterblks);
	fprintf(dbg_log, "ffs2_niblk    int32_t    0x%08x\n", cgr->cg_ffs2_niblk);
	fprintf(dbg_log, "initediblk    int32_t    0x%08x\n", cgr->cg_initediblk);
#ifdef notyet
	fprintf(dbg_log, "unrefs        int32_t    0x%08x\n", cgr->cg_unrefs);
#endif
	fprintf(dbg_log, "ffs2_time     int64_t    %10u\n", /* XXX */
	    (unsigned int)cgr->cg_initediblk);

	indent--;
	fprintf(dbg_log, "===== END CYLINDER GROUP =====\n");

	return;
}

/*
 * Dump a cylinder summary.
 */
void
dbg_dump_csum(const char *comment, struct csum *cs)
{

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START CYLINDER SUMMARY =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cs, comment);
	indent++;

	fprintf(dbg_log, "ndir   int32_t 0x%08x\n", cs->cs_ndir);
	fprintf(dbg_log, "nbfree int32_t 0x%08x\n", cs->cs_nbfree);
	fprintf(dbg_log, "nifree int32_t 0x%08x\n", cs->cs_nifree);
	fprintf(dbg_log, "nffree int32_t 0x%08x\n", cs->cs_nffree);

	indent--;
	fprintf(dbg_log, "===== END CYLINDER SUMMARY =====\n");

	return;
}

/*
 * Dump a cylinder summary.
 */
void
dbg_dump_csum_total(const char *comment, struct csum_total *cs)
{

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START CYLINDER SUMMARY TOTAL =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cs, comment);
	indent++;

	fprintf(dbg_log, "ndir        int64_t 0x%08x%08x\n",
	    ((unsigned int *)&(cs->cs_ndir))[1],
	    ((unsigned int *)&(cs->cs_ndir))[0]);
	fprintf(dbg_log, "nbfree      int64_t 0x%08x%08x\n",
	    ((unsigned int *)&(cs->cs_nbfree))[1],
	    ((unsigned int *)&(cs->cs_nbfree))[0]);
	fprintf(dbg_log, "nifree      int64_t 0x%08x%08x\n",
	    ((unsigned int *)&(cs->cs_nifree))[1],
	    ((unsigned int *)&(cs->cs_nifree))[0]);
	fprintf(dbg_log, "nffree      int64_t 0x%08x%08x\n",
	    ((unsigned int *)&(cs->cs_nffree))[1],
	    ((unsigned int *)&(cs->cs_nffree))[0]);
#ifdef notyet
	fprintf(dbg_log, "numclusters int64_t 0x%08x%08x\n",
	    ((unsigned int *)&(cs->cs_numclusters))[1],
	    ((unsigned int *)&(cs->cs_numclusters))[0]);
#endif

	indent--;
	fprintf(dbg_log, "===== END CYLINDER SUMMARY TOTAL =====\n");

	return;
}
/*
 * Dump the inode allocation map in one cylinder group.
 */
void
dbg_dump_inmap(struct fs *sb, const char *comment, struct cg *cgr)
{
	int j, k, l, e;
	unsigned char *cp;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START INODE ALLOCATION MAP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cgr, comment);
	indent++;

	cp = (unsigned char *)cg_inosused(cgr);
	e = sb->fs_ipg / 8;
	for (j = 0; j < e; j += 32) {
		fprintf(dbg_log, "0x%08x: ", j);
		for (k = 0; k < 32; k += 8) {
			if (j + k + 8 < e) {
				fprintf(dbg_log,
				    "%02x%02x%02x%02x%02x%02x%02x%02x ",
				    cp[0], cp[1], cp[2], cp[3],
				    cp[4], cp[5], cp[6], cp[7]);
			} else {
				for (l = 0; (l < 8) && (j + k + l < e); l++) {
					fprintf(dbg_log, "%02x", cp[l]);
				}
			}
			cp += 8;
		}
		fprintf(dbg_log, "\n");
	}

	indent--;
	fprintf(dbg_log, "===== END INODE ALLOCATION MAP =====\n");

	return;
}


/*
 * Dump the fragment allocation map in one cylinder group.
 */
void
dbg_dump_frmap(struct fs *sb, const char *comment, struct cg *cgr)
{
	int j, k, l, e;
	unsigned char *cp;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START FRAGMENT ALLOCATION MAP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cgr, comment);
	indent++;

	cp = (unsigned char *)cg_blksfree(cgr);
	if (sb->fs_nspf)
		e = howmany((sb->fs_cpg * sb->fs_spc / sb->fs_nspf), CHAR_BIT);
	else
		e = 0;
	for (j = 0; j < e; j += 32) {
		fprintf(dbg_log, "0x%08x: ", j);
		for (k = 0; k < 32; k += 8) {
			if (j + k + 8 < e) {
				fprintf(dbg_log,
				    "%02x%02x%02x%02x%02x%02x%02x%02x ",
				    cp[0], cp[1], cp[2], cp[3],
				    cp[4], cp[5], cp[6], cp[7]);
			} else {
				for (l = 0; (l < 8) && (j + k + l < e); l++) {
					fprintf(dbg_log, "%02x", cp[l]);
				}
			}
			cp += 8;
		}
		fprintf(dbg_log, "\n");
	}

	indent--;
	fprintf(dbg_log, "===== END FRAGMENT ALLOCATION MAP =====\n");

	return;
}

/*
 * Dump the cluster allocation map in one cylinder group.
 */
void
dbg_dump_clmap(struct fs *sb, const char *comment, struct cg *cgr)
{
	int j, k, l, e;
	unsigned char *cp;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START CLUSTER ALLOCATION MAP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cgr, comment);
	indent++;

	cp = (unsigned char *)cg_clustersfree(cgr);
	if (sb->fs_nspf)
		e = howmany(sb->fs_cpg * sb->fs_spc /
		    (sb->fs_nspf << sb->fs_fragshift), CHAR_BIT);
	else
		e = 0;
	for (j = 0; j < e; j += 32) {
		fprintf(dbg_log, "0x%08x: ", j);
		for (k = 0; k < 32; k += 8) {
			if (j + k + 8 < e) {
				fprintf(dbg_log,
				    "%02x%02x%02x%02x%02x%02x%02x%02x ",
				    cp[0], cp[1], cp[2], cp[3],
				    cp[4], cp[5], cp[6], cp[7]);
			} else {
				for (l = 0; (l < 8) && (j + k + l < e); l++)
					fprintf(dbg_log, "%02x", cp[l]);
			}
			cp += 8;
		}
		fprintf(dbg_log, "\n");
	}

	indent--;
	fprintf(dbg_log, "===== END CLUSTER ALLOCATION MAP =====\n");

	return;
}

/*
 * Dump the cluster availability summary of one cylinder group.
 */
void
dbg_dump_clsum(struct fs *sb, const char *comment, struct cg *cgr)
{
	int j;
	int *ip;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START CLUSTER SUMMARY =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cgr, comment);
	indent++;

	ip = (int *)cg_clustersum(cgr);
	for (j = 0; j <= sb->fs_contigsumsize; j++) {
		fprintf(dbg_log, "%02d: %8d\n", j, *ip++);
	}

	indent--;
	fprintf(dbg_log, "===== END CLUSTER SUMMARY =====\n");

	return;
}

#ifdef NOT_CURRENTLY
/*
 * This code dates from before the UFS2 integration, and doesn't compile
 * post-UFS2 due to the use of cg_blks().  I'm not sure how best to update
 * this for UFS2, where the rotational bits of UFS no longer apply, so
 * will leave it disabled for now; it should probably be re-enabled
 * specifically for UFS1.
 */
/*
 * Dump the block summary, and the rotational layout table.
 */
void
dbg_dump_sptbl(struct fs *sb, const char *comment, struct cg *cgr)
{
	int j, k;
	int *ip;

	if (!dbg_log)
		return;

	fprintf(dbg_log,
	    "===== START BLOCK SUMMARY AND POSITION TABLE =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)cgr, comment);
	indent++;

	ip = (int *)cg_blktot(cgr);
	for (j = 0; j < sb->fs_cpg; j++) {
		fprintf(dbg_log, "%2d: %5d = ", j, *ip++);
		for (k = 0; k < sb->fs_nrpos; k++) {
			fprintf(dbg_log, "%4d", cg_blks(sb, cgr, j)[k]);
			if (k < sb->fs_nrpos - 1) {
				fprintf(dbg_log, " + ");
			}
		}
		fprintf(dbg_log, "\n");
	}

	indent--;
	fprintf(dbg_log, "===== END BLOCK SUMMARY AND POSITION TABLE =====\n");

	return;
}
#endif

/*
 * Dump an UFS1 inode structure.
 */
void
dbg_dump_ino(struct fs *sb, const char *comment, struct ufs1_dinode *ino)
{
	int ictr;
	int remaining_blocks;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START UFS1 INODE DUMP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)ino, comment);
	indent++;

	fprintf(dbg_log, "mode       u_int16_t      0%o\n", ino->di_mode);
	fprintf(dbg_log, "nlink      int16_t        0x%04x\n", ino->di_nlink);
	fprintf(dbg_log, "size       u_int64_t      0x%08x%08x\n",
	    ((unsigned int *)&(ino->di_size))[1],
	    ((unsigned int *)&(ino->di_size))[0]);
	fprintf(dbg_log, "atime      int32_t        0x%08x\n", ino->di_atime);
	fprintf(dbg_log, "atimensec  int32_t        0x%08x\n",
	    ino->di_atimensec);
	fprintf(dbg_log, "mtime      int32_t        0x%08x\n", ino->di_mtime);
	fprintf(dbg_log, "mtimensec  int32_t        0x%08x\n",
	    ino->di_mtimensec);
	fprintf(dbg_log, "ctime      int32_t        0x%08x\n", ino->di_ctime);
	fprintf(dbg_log, "ctimensec  int32_t        0x%08x\n",
	    ino->di_ctimensec);

	remaining_blocks = howmany(ino->di_size, sb->fs_bsize); /* XXX ts - +1? */
	for (ictr = 0; ictr < MINIMUM(NDADDR, remaining_blocks); ictr++) {
		fprintf(dbg_log, "db         int32_t[%x] 0x%08x\n", ictr,
		    ino->di_db[ictr]);
	}
	remaining_blocks-=NDADDR;
	if (remaining_blocks > 0) {
		fprintf(dbg_log, "ib         int32_t[0] 0x%08x\n",
		    ino->di_ib[0]);
	}
	remaining_blocks -= howmany(sb->fs_bsize, sizeof(int32_t));
	if (remaining_blocks > 0) {
		fprintf(dbg_log, "ib         int32_t[1] 0x%08x\n",
		    ino->di_ib[1]);
	}
#define SQUARE(a) ((a)*(a))
	remaining_blocks -= SQUARE(howmany(sb->fs_bsize, sizeof(int32_t)));
#undef SQUARE
	if (remaining_blocks > 0) {
		fprintf(dbg_log, "ib         int32_t[2] 0x%08x\n",
		    ino->di_ib[2]);
	}

	fprintf(dbg_log, "flags      u_int32_t      0x%08x\n", ino->di_flags);
	fprintf(dbg_log, "blocks     int32_t        0x%08x\n", ino->di_blocks);
	fprintf(dbg_log, "gen        int32_t        0x%08x\n", ino->di_gen);
	fprintf(dbg_log, "uid        u_int32_t      0x%08x\n", ino->di_uid);
	fprintf(dbg_log, "gid        u_int32_t      0x%08x\n", ino->di_gid);

	indent--;
	fprintf(dbg_log, "===== END UFS1 INODE DUMP =====\n");

	return;
}

/*
 * Dump a UFS2 inode structure.
 */
void
dbg_dump_ufs2_ino(struct fs *sb, const char *comment, struct ufs2_dinode *ino)
{
	int ictr;
	int remaining_blocks;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START UFS2 INODE DUMP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)ino, comment);
	indent++;

	fprintf(dbg_log, "mode       u_int16_t      0%o\n", ino->di_mode);
	fprintf(dbg_log, "nlink      int16_t        0x%04x\n", ino->di_nlink);
	fprintf(dbg_log, "uid        u_int32_t      0x%08x\n", ino->di_uid);
	fprintf(dbg_log, "gid        u_int32_t      0x%08x\n", ino->di_gid);
	fprintf(dbg_log, "blksize    u_int32_t      0x%08x\n", ino->di_blksize);
	fprintf(dbg_log, "size       u_int64_t      0x%08x%08x\n",
	    ((unsigned int *)&(ino->di_size))[1],
	    ((unsigned int *)&(ino->di_size))[0]);
	fprintf(dbg_log, "blocks     u_int64_t      0x%08x%08x\n",
	    ((unsigned int *)&(ino->di_blocks))[1],
	    ((unsigned int *)&(ino->di_blocks))[0]);
	fprintf(dbg_log, "atime      ufs_time_t     %10jd\n", ino->di_atime);
	fprintf(dbg_log, "mtime      ufs_time_t     %10jd\n", ino->di_mtime);
	fprintf(dbg_log, "ctime      ufs_time_t     %10jd\n", ino->di_ctime);
	fprintf(dbg_log, "birthtime  ufs_time_t     %10jd\n", ino->di_birthtime);
	fprintf(dbg_log, "mtimensec  int32_t        0x%08x\n", ino->di_mtimensec);
	fprintf(dbg_log, "atimensec  int32_t        0x%08x\n", ino->di_atimensec);
	fprintf(dbg_log, "ctimensec  int32_t        0x%08x\n", ino->di_ctimensec);
	fprintf(dbg_log, "birthnsec  int32_t        0x%08x\n", ino->di_birthnsec);
	fprintf(dbg_log, "gen        int32_t        0x%08x\n", ino->di_gen);
	fprintf(dbg_log, "kernflags  u_int32_t      0x%08x\n", ino->di_kernflags);
	fprintf(dbg_log, "flags      u_int32_t      0x%08x\n", ino->di_flags);
	fprintf(dbg_log, "extsize    int32_t        0x%08x\n", ino->di_extsize);

	/* XXX: What do we do with di_extb[NXADDR]? */

	remaining_blocks = howmany(ino->di_size, sb->fs_bsize); /* XXX ts - +1? */
	for (ictr = 0; ictr < MINIMUM(NDADDR, remaining_blocks); ictr++) {
		fprintf(dbg_log, "db         daddr_t[%x] 0x%16jx\n", ictr,
		    ino->di_db[ictr]);
	}
	remaining_blocks -= NDADDR;
	if (remaining_blocks > 0) {
		fprintf(dbg_log, "ib         daddr_t[0] 0x%16jx\n",
		    ino->di_ib[0]);
	}
	remaining_blocks -= howmany(sb->fs_bsize, sizeof(daddr_t));
	if (remaining_blocks > 0) {
		fprintf(dbg_log, "ib         daddr_t[1] 0x%16jx\n",
		    ino->di_ib[1]);
	}
#define SQUARE(a) ((a)*(a))
	remaining_blocks -= SQUARE(howmany(sb->fs_bsize, sizeof(daddr_t)));
#undef SQUARE
	if (remaining_blocks > 0) {
		fprintf(dbg_log, "ib         daddr_t[2] 0x%16jx\n",
		    ino->di_ib[2]);
	}

	indent--;
	fprintf(dbg_log, "===== END UFS2 INODE DUMP =====\n");

	return;
}

/*
 * Dump an indirect block. The iteration to dump a full file has to be
 * written around.
 */
void
dbg_dump_iblk(struct fs *sb, const char *comment, char *block, size_t length)
{
	unsigned int *mem, i, j, size;

	if (!dbg_log)
		return;

	fprintf(dbg_log, "===== START INDIRECT BLOCK DUMP =====\n");
	fprintf(dbg_log, "# %d@@%lx: %s\n", indent, (unsigned long)block,
	    comment);
	indent++;

	if (sb->fs_magic == FS_UFS1_MAGIC)
		size = sizeof(int32_t);
	else
		size = sizeof(int64_t);

	mem = (unsigned int *)block;
	for (i = 0; (size_t)i < MINIMUM(howmany(sb->fs_bsize, size), length); i += 8) {
		fprintf(dbg_log, "%04x: ", i);
		for (j = 0; j < 8; j++) {
			if ((size_t)(i + j) < length) {
				fprintf(dbg_log, "%08X ", *mem++);
			}
		}
		fprintf(dbg_log, "\n");
	}

	indent--;
	fprintf(dbg_log, "===== END INDIRECT BLOCK DUMP =====\n");

	return;
}

#endif /* FS_DEBUG */
@


1.12
log
@Remove more useless comments. This whole file may go eventually, as per
deraadt@@'s decree.
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.11 2015/01/16 06:39:58 deraadt Exp $	*/
@


1.11
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.10 2014/05/24 17:56:17 krw Exp $	*/
a43 2
/* ********************************************************** INCLUDES ***** */

a57 1
/* *********************************************************** GLOBALS ***** */
a64 1
/* ********************************************************** dbg_open ***** */
a79 1
/* ********************************************************* dbg_close ***** */
a95 1
/* ****************************************************** dbg_dump_hex ***** */
a123 1
/* ******************************************************* dbg_dump_fs ***** */
a356 1
/* ******************************************************* dbg_dump_cg ***** */
a411 1
/* ***************************************************** dbg_dump_csum ***** */
a436 1
/* ************************************************ dbg_dump_csum_total ***** */
a473 1
/* **************************************************** dbg_dump_inmap ***** */
a516 1
/* **************************************************** dbg_dump_frmap ***** */
a561 1
/* **************************************************** dbg_dump_clmap ***** */
a606 1
/* **************************************************** dbg_dump_clsum ***** */
a641 1
/* **************************************************** dbg_dump_sptbl ***** */
a677 1
/* ****************************************************** dbg_dump_ino ***** */
a743 1
/* ************************************************** dbg_dump_ufs2_ino ***** */
a814 1
/* ***************************************************** dbg_dump_iblk ***** */
@


1.10
log
@Break annoyingly long line that keeps popping up in diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.9 2013/06/11 16:42:04 deraadt Exp $	*/
a44 1
#include <sys/param.h>
d53 3
d726 1
a726 1
	for (ictr = 0; ictr < MIN(NDADDR, remaining_blocks); ictr++) {
d804 1
a804 1
	for (ictr = 0; ictr < MIN(NDADDR, remaining_blocks); ictr++) {
d856 1
a856 1
	for (i = 0; (size_t)i < MIN(howmany(sb->fs_bsize, size), length); i += 8) {
@


1.9
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.8 2009/10/27 23:59:33 deraadt Exp $	*/
d591 2
a592 1
		e = howmany(sb->fs_cpg * sb->fs_spc / (sb->fs_nspf << sb->fs_fragshift), CHAR_BIT);
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.7 2007/07/07 08:22:55 millert Exp $	*/
d802 1
a802 1
		fprintf(dbg_log, "db         daddr64_t[%x] 0x%16jx\n", ictr,
d807 1
a807 1
		fprintf(dbg_log, "ib         daddr64_t[0] 0x%16jx\n",
d810 1
a810 1
	remaining_blocks -= howmany(sb->fs_bsize, sizeof(daddr64_t));
d812 1
a812 1
		fprintf(dbg_log, "ib         daddr64_t[1] 0x%16jx\n",
d816 1
a816 1
	remaining_blocks -= SQUARE(howmany(sb->fs_bsize, sizeof(daddr64_t)));
d819 1
a819 1
		fprintf(dbg_log, "ib         daddr64_t[2] 0x%16jx\n",
@


1.7
log
@Pull in ffs2 support and other updates from FreeBSD.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.6 2007/06/01 19:26:06 deraadt Exp $	*/
a42 5

#ifndef lint
static const char rcsid[] =
  "$OpenBSD: debug.c,v 1.5 2007/03/19 13:27:47 pedro Exp $";
#endif /* not lint */
@


1.6
log
@ufs_daddr_t is a dead type.  growfs is the only program that uses it, yet
it is ffs1-aware only.  therefore all the types are on disk, and thus,
they are actually int32_t.  ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.5 2007/03/19 13:27:47 pedro Exp $	*/
d40 1
a40 1
 * $FreeBSD: src/sbin/growfs/debug.c,v 1.7 2002/09/25 04:06:36 mike Exp $
d54 2
d64 2
a65 2
static FILE	*dbg_log=NULL;
static unsigned int	indent=0;
d80 1
a80 1
		dbg_log=fopen("/dev/stdout", "a");
d82 1
a82 1
		dbg_log=fopen(fn, "a");
d95 4
a98 3
	if(dbg_log) {
		fclose(dbg_log);
		dbg_log=NULL;
d113 1
a113 1
	if(!dbg_log) {
d115 1
a115 1
	}
d119 3
a121 3
	for (i=0; i<sb->fs_bsize; i+=24) {
		for (j=0; j<3; j++) {
			for (k=0; k<8; k++) {
a122 1
			}
d144 1
a144 1
	if(!dbg_log) {
a145 1
	}
d151 1
a151 1
	fprintf(dbg_log, "sblkno        int32_t       0x%08x\n",
d153 1
a153 1
	fprintf(dbg_log, "cblkno        int32_t       0x%08x\n",
d155 1
a155 1
	fprintf(dbg_log, "iblkno        int32_t       0x%08x\n",
d157 1
a157 1
	fprintf(dbg_log, "dblkno        int32_t       0x%08x\n",
d160 1
a160 1
	fprintf(dbg_log, "cgoffset      int32_t           0x%08x\n",
d162 1
a162 1
	fprintf(dbg_log, "cgmask        int32_t           0x%08x\n",
d164 3
a166 3
	fprintf(dbg_log, "time          time_t            %10u\n",
	    (unsigned int)sb->fs_ffs1_time);
	fprintf(dbg_log, "size          int32_t           0x%08x\n",
d168 1
a168 1
	fprintf(dbg_log, "dsize         int32_t           0x%08x\n",
d170 1
a170 1
	fprintf(dbg_log, "ncg           int32_t           0x%08x\n",
d172 1
a172 1
	fprintf(dbg_log, "bsize         int32_t           0x%08x\n",
d174 1
a174 1
	fprintf(dbg_log, "fsize         int32_t           0x%08x\n",
d176 1
a176 1
	fprintf(dbg_log, "frag          int32_t           0x%08x\n",
d179 1
a179 1
	fprintf(dbg_log, "minfree       int32_t           0x%08x\n",
d181 1
a181 1
	fprintf(dbg_log, "rotdelay      int32_t           0x%08x\n",
d183 1
a183 1
	fprintf(dbg_log, "rps           int32_t           0x%08x\n",
d186 1
a186 1
	fprintf(dbg_log, "bmask         int32_t           0x%08x\n",
d188 1
a188 1
	fprintf(dbg_log, "fmask         int32_t           0x%08x\n",
d190 1
a190 1
	fprintf(dbg_log, "bshift        int32_t           0x%08x\n",
d192 1
a192 1
	fprintf(dbg_log, "fshift        int32_t           0x%08x\n",
d195 1
a195 1
	fprintf(dbg_log, "maxcontig     int32_t           0x%08x\n",
d197 1
a197 1
	fprintf(dbg_log, "maxbpg        int32_t           0x%08x\n",
d200 1
a200 1
	fprintf(dbg_log, "fragshift     int32_t           0x%08x\n",
d202 1
a202 1
	fprintf(dbg_log, "fsbtodb       int32_t           0x%08x\n",
d204 1
a204 1
	fprintf(dbg_log, "sbsize        int32_t           0x%08x\n",
d206 1
a206 1
	fprintf(dbg_log, "csmask        int32_t           0x%08x\n",
d208 1
a208 1
	fprintf(dbg_log, "csshift       int32_t           0x%08x\n",
d210 1
a210 1
	fprintf(dbg_log, "nindir        int32_t           0x%08x\n",
d212 1
a212 1
	fprintf(dbg_log, "inopb         int32_t           0x%08x\n",
d214 1
a214 1
	fprintf(dbg_log, "nspf          int32_t           0x%08x\n",
d217 1
a217 1
	fprintf(dbg_log, "optim         int32_t           0x%08x\n",
d220 1
a220 1
	fprintf(dbg_log, "npsect        int32_t           0x%08x\n",
d222 1
a222 1
	fprintf(dbg_log, "interleave    int32_t           0x%08x\n",
d224 1
a224 1
	fprintf(dbg_log, "trackskew     int32_t           0x%08x\n",
d227 1
a227 1
	fprintf(dbg_log, "id            int32_t[2]        %08x %08x\n",
d230 1
a230 1
	fprintf(dbg_log, "csaddr        int32_t       0x%08x\n",
d232 1
a232 1
	fprintf(dbg_log, "cssize        int32_t           0x%08x\n",
d234 1
a234 1
	fprintf(dbg_log, "cgsize        int32_t           0x%08x\n",
d237 1
a237 1
	fprintf(dbg_log, "ntrak         int32_t           0x%08x\n",
d239 1
a239 1
	fprintf(dbg_log, "nsect         int32_t           0x%08x\n",
d241 1
a241 1
	fprintf(dbg_log, "spc           int32_t           0x%08x\n",
d244 1
a244 1
	fprintf(dbg_log, "ncyl          int32_t           0x%08x\n",
d247 1
a247 1
	fprintf(dbg_log, "cpg           int32_t           0x%08x\n",
d249 1
a249 1
	fprintf(dbg_log, "ipg           int32_t           0x%08x\n",
d251 1
a251 1
	fprintf(dbg_log, "fpg           int32_t           0x%08x\n",
d256 1
a256 1
	fprintf(dbg_log, "fmod          int8_t            0x%02x\n",
d258 1
a258 1
	fprintf(dbg_log, "clean         int8_t            0x%02x\n",
d260 1
a260 1
	fprintf(dbg_log, "ronly         int8_t            0x%02x\n",
d262 1
a262 1
	fprintf(dbg_log, "flags         int8_t            0x%02x\n",
d264 1
a264 1
	fprintf(dbg_log, "fsmnt         u_char[MAXMNTLEN] \"%s\"\n",
d266 8
a273 2

	fprintf(dbg_log, "cgrotor       int32_t           0x%08x\n",
d279 1
a279 1
	fprintf(dbg_log, "cpc           int32_t           0x%08x\n",
d284 30
d315 2
a316 2
	for(j=0; j<FSMAXSNAP; j++) {
		fprintf(dbg_log, "snapinum      int32_t[%2d]       0x%08x\n",
d318 1
a318 1
		if(!sb->fs_snapinum[j]) { /* list is dense */
d323 11
a333 1
	fprintf(dbg_log, "contigsumsize int32_t           0x%08x\n",
d335 1
a335 1
	fprintf(dbg_log, "maxsymlinklen int32_t           0x%08x\n",
d337 1
a337 1
	fprintf(dbg_log, "inodefmt      int32_t           0x%08x\n",
d339 1
a339 1
	fprintf(dbg_log, "maxfilesize   u_int64_t         0x%08x%08x\n",
d342 1
a342 1
	fprintf(dbg_log, "qbmask        int64_t           0x%08x%08x\n",
d345 1
a345 1
	fprintf(dbg_log, "qfmask        int64_t           0x%08x%08x\n",
d348 1
a348 1
	fprintf(dbg_log, "state         int32_t           0x%08x\n",
d350 1
a350 1
	fprintf(dbg_log, "postblformat  int32_t           0x%08x\n",
d352 1
a352 1
	fprintf(dbg_log, "nrpos         int32_t           0x%08x\n",
d354 1
a354 1
	fprintf(dbg_log, "postbloff     int32_t           0x%08x\n",
d356 1
a356 1
	fprintf(dbg_log, "rotbloff      int32_t           0x%08x\n",
d358 1
a358 1
	fprintf(dbg_log, "magic         int32_t           0x%08x\n",
d376 1
a376 1
	if(!dbg_log) {
a377 1
	}
d384 1
a384 2
	fprintf(dbg_log, "time          time_t     %10u\n", (unsigned int)
	    cgr->cg_time);
d393 1
a393 1
	for(j=0; j<MAXFRAG; j++) {
d405 1
a405 1
	fprintf(dbg_log, "clusterof     int32_t    0x%08x\n",
d409 7
d431 1
a431 1
	if(!dbg_log) {
a432 1
	}
d449 38
d494 1
a494 1
	int j,k,l,e;
d497 1
a497 1
	if(!dbg_log) {
a498 1
	}
d504 6
a509 6
	cp=(unsigned char *)cg_inosused(cgr);
	e=sb->fs_ipg/8;
	for(j=0; j<e; j+=32) {
		fprintf(dbg_log, "%08x: ", j);
		for(k=0; k<32; k+=8) {
			if(j+k+8<e) {
d515 1
a515 1
				for(l=0; (l<8)&&(j+k+l<e); l++) {
d519 1
a519 1
			cp+=8;
d538 1
a538 1
	int j,k,l,e;
d541 1
a541 1
	if(!dbg_log) {
a542 1
	}
d548 9
a556 6
	cp=(unsigned char *)cg_blksfree(cgr);
	e=howmany((sb->fs_cpg * sb->fs_spc / NSPF(sb)), CHAR_BIT);
	for(j=0; j<e; j+=32) {
		fprintf(dbg_log, "%08x: ", j);
		for(k=0; k<32; k+=8) {
			if(j+k+8<e) {
d562 1
a562 1
				for(l=0; (l<8)&&(j+k+l<e); l++) {
d566 1
a566 1
			cp+=8;
d584 1
a584 1
	int j,k,l,e;
d587 1
a587 1
	if(!dbg_log) {
a588 1
	}
d594 9
a602 6
	cp=(unsigned char *)cg_clustersfree(cgr);
	e=howmany(sb->fs_cpg * sb->fs_spc / NSPB(sb), CHAR_BIT);
	for(j=0; j<e; j+=32) {
		fprintf(dbg_log, "%08x: ", j);
		for(k=0; k<32; k+=8) {
			if(j+k+8<e) {
d608 1
a608 1
				for(l=0; (l<8)&&(j+k+l<e); l++) {
a609 1
				}
d611 1
a611 1
			cp+=8;
d632 1
a632 1
	if(!dbg_log) {
a633 1
	}
d639 2
a640 2
	ip=(int *)cg_clustersum(cgr);
	for(j=0; j<=sb->fs_contigsumsize; j++) {
d650 8
d665 1
a665 1
	int j,k;
d668 1
a668 1
	if(!dbg_log) {
a669 1
	}
d676 2
a677 2
	ip=(int *)cg_blktot(cgr);
	for(j=0; j<sb->fs_cpg; j++) {
d679 1
a679 1
		for(k=0; k<sb->fs_nrpos; k++) {
d681 1
a681 1
			if(k<sb->fs_nrpos-1) {
d693 1
d697 1
a697 1
 * Dump an inode structure.
d705 1
a705 1
	if(!dbg_log) {
a706 1
	}
d708 1
a708 1
	fprintf(dbg_log, "===== START INODE DUMP =====\n");
d720 1
a720 2
	fprintf(dbg_log, "mtime      int32_t        0x%08x\n",
	    ino->di_mtime);
d727 2
a728 2
	remaining_blocks=howmany(ino->di_size, sb->fs_bsize); /* XXX ts - +1? */
	for(ictr=0; ictr < MIN(NDADDR, remaining_blocks); ictr++) {
d733 1
a733 1
	if(remaining_blocks>0) {
d737 2
a738 2
	remaining_blocks-=howmany(sb->fs_bsize, sizeof(int32_t));
	if(remaining_blocks>0) {
d743 1
a743 1
	remaining_blocks-=SQUARE(howmany(sb->fs_bsize, sizeof(ufs_daddr_t)));
d745 1
a745 1
	if(remaining_blocks>0) {
d757 73
a829 1
	fprintf(dbg_log, "===== END INODE DUMP =====\n");
d842 1
a842 2
	unsigned int *mem;
	int i, j;
d844 1
a844 1
	if(!dbg_log) {
a845 1
	}
d852 7
a858 3
	mem=(unsigned int *)block;
	for (i=0; (size_t)i<MIN(howmany(sb->fs_bsize, sizeof(ufs_daddr_t)),
	    length); i+=8) {
d860 2
a861 2
		for (j=0; j<8; j++) {
			if((size_t)(i+j)<length) {
a874 1

@


1.5
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.4 2003/08/25 23:28:15 tedu Exp $	*/
d46 1
a46 1
  "$OpenBSD: debug.c,v 1.4 2003/08/25 23:28:15 tedu Exp $";
d150 1
a150 1
	fprintf(dbg_log, "sblkno        ufs_daddr_t       0x%08x\n",
d152 1
a152 1
	fprintf(dbg_log, "cblkno        ufs_daddr_t       0x%08x\n",
d154 1
a154 1
	fprintf(dbg_log, "iblkno        ufs_daddr_t       0x%08x\n",
d156 1
a156 1
	fprintf(dbg_log, "dblkno        ufs_daddr_t       0x%08x\n",
d229 1
a229 1
	fprintf(dbg_log, "csaddr        ufs_daddr_t       0x%08x\n",
d633 1
a633 1
		fprintf(dbg_log, "db         ufs_daddr_t[%x] 0x%08x\n", ictr,
d638 1
a638 1
		fprintf(dbg_log, "ib         ufs_daddr_t[0] 0x%08x\n",
d641 1
a641 1
	remaining_blocks-=howmany(sb->fs_bsize, sizeof(ufs_daddr_t));
d643 1
a643 1
		fprintf(dbg_log, "ib         ufs_daddr_t[1] 0x%08x\n",
d650 1
a650 1
		fprintf(dbg_log, "ib         ufs_daddr_t[2] 0x%08x\n",
@


1.4
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: debug.c,v 1.3 2003/08/07 16:37:52 fgsch Exp $	*/
d46 1
a46 1
  "$OpenBSD: debug.c,v 1.3 2003/08/07 16:37:52 fgsch Exp $";
d164 1
a164 1
	    (unsigned int)sb->fs_time);
d166 1
a166 1
	    sb->fs_size);
d168 1
a168 1
	    sb->fs_dsize);
d230 1
a230 1
	    sb->fs_csaddr);
d253 1
a253 1
	dbg_dump_csum("internal cstotal", &sb->fs_cstotal);
d262 1
a262 1
	    sb->fs_flags);
@


1.3
log
@add missing tags and make this compile with debug.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
  "$OpenBSD$";
d602 1
a602 1
dbg_dump_ino(struct fs *sb, const char *comment, struct dinode *ino)
@


1.2
log
@spaces
@
text
@d1 1
d40 1
d46 1
a46 1
  "$FreeBSD: src/sbin/growfs/debug.c,v 1.7 2002/09/25 04:06:36 mike Exp $";
@


1.1
log
@introducing growfs, compliments of freebsd.  cleaned up slightly to obey knf.
requests/oks from many.
@
text
@d5 1
a5 1
 * 
d8 1
a8 1
 * 
d25 1
a25 1
 * 
d421 1
a421 1
				    "%02x%02x%02x%02x%02x%02x%02x%02x ", 
d466 1
a466 1
				    "%02x%02x%02x%02x%02x%02x%02x%02x ", 
d510 1
a510 1
				    "%02x%02x%02x%02x%02x%02x%02x%02x ", 
d604 1
a604 1
	
d615 1
a615 1
	fprintf(dbg_log, "size       u_int64_t      0x%08x%08x\n", 
@

