head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.4
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.51.0.6
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6;
locks; strict;
comment	@ * @;


1.51
date	2016.05.28.20.40.23;	author tb;	state Exp;
branches;
next	1.50;
commitid	8p3pL4tVSbvsilpF;

1.50
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.49;
commitid	0afdJPZPXUfvItJV;

1.49
date	2016.01.29.11.50.40;	author tb;	state Exp;
branches;
next	1.48;
commitid	wdsCJfnz2IT7Qf4z;

1.48
date	2015.11.28.19.59.15;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	5ccMX0fjQqfnlmJY;

1.47
date	2015.11.27.17.27.01;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	lpZ1fZ8ySafMjHmt;

1.46
date	2015.11.23.18.35.18;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	tzGJfQvw5OfoVhiq;

1.45
date	2015.11.20.17.37.08;	author mmcc;	state Exp;
branches;
next	1.44;
commitid	2gixAujZOarqKQAf;

1.44
date	2015.11.20.17.31.20;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	5qN6KCoo4sjeAmAT;

1.43
date	2015.11.19.17.46.46;	author mmcc;	state Exp;
branches;
next	1.42;
commitid	CYA5DbxBuM2wFsA7;

1.42
date	2015.11.19.17.40.28;	author mmcc;	state Exp;
branches;
next	1.41;
commitid	EzC11ElKkG6OMHyf;

1.41
date	2015.11.19.17.30.41;	author mmcc;	state Exp;
branches;
next	1.40;
commitid	vvEv9nkfPOcAWk97;

1.40
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	0qPuuXwccpVXsXcV;

1.39
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	6b2lLILbgCR1fvia;

1.38
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	F55lwc3gS4GN2mLs;

1.37
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2014.05.15.19.18.23;	author chl;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.05.15.04.05;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.30.14.28.48;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.10.00.48.04;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.09.15.53.20;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.23.21.27.15;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.01.05.31.55;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.24.20.48.33;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.28.00.15.54;	author ckuethe;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.24.08.33.04;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.05.13.56.14;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.02.23.50.03;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.07.08.22.55;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.01.19.26.06;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.29.06.28.16;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.23.10.18.30;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.02.00.48.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.31.08.13.07;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.14.21.10.20;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.19.15.18.01;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.14.19.58.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.15.08.52.01;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.28.21.35.16;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.26.21.39.21;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.14.05.23.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.16.17.31.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.07.16.37.52;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.04.04.49.57;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.29.22.54.26;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.28.21.09.28;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Give growfs a chance to error out with ENOTTY before pledging disklabel.
Fixes pledge crash due to ioctl DIOCGDINFO with an inappropriate file.

looks good to deraadt
@
text
@/*	$OpenBSD: growfs.c,v 1.50 2016/03/17 05:27:10 bentley Exp $	*/
/*
 * Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz
 * Copyright (c) 1980, 1989, 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christoph Herrmann and Thomas-Henning von Kamptz, Munich and Frankfurt.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors, as well as Christoph
 *      Herrmann and Thomas-Henning von Kamptz.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $TSHeader: src/sbin/growfs/growfs.c,v 1.5 2000/12/12 19:31:00 tomsoft Exp $
 * $FreeBSD: src/sbin/growfs/growfs.c,v 1.25 2006/07/17 20:48:36 stefanf Exp $
 *
 */

#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE setbit isset isclr clrbit */
#include <sys/types.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/stat.h>

#include <stdio.h>
#include <paths.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <util.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define	rounddown(x, y)	(((x)/(y))*(y))
#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))

static int quiet;		/* quiet flag */

static union {
	struct	fs fs;
	char	pad[SBLOCKSIZE];
} fsun1, fsun2;
#define	sblock	fsun1.fs	/* the new superblock */
#define	osblock	fsun2.fs	/* the old superblock */

/*
 * Possible superblock locations ordered from most to least likely.
 */
static int sblock_try[] = SBLOCKSEARCH;
static daddr_t sblockloc;

static union {
	struct	cg cg;
	char	pad[MAXBSIZE];
} cgun1, cgun2;
#define	acg	cgun1.cg	/* a cylinder cgroup (new) */
#define	aocg	cgun2.cg	/* an old cylinder group */

static char	ablk[MAXBSIZE];		/* a block */

static struct csum	*fscs;	/* cylinder summary */

union dinode {
	struct ufs1_dinode dp1;
	struct ufs2_dinode dp2;
};
#define	DIP(dp, field) \
	((sblock.fs_magic == FS_UFS1_MAGIC) ? \
	(uint32_t)(dp)->dp1.field : (dp)->dp2.field)
#define	DIP_SET(dp, field, val) do { \
	if (sblock.fs_magic == FS_UFS1_MAGIC) \
		(dp)->dp1.field = (val); \
	else \
		(dp)->dp2.field = (val); \
	} while (0)
static daddr_t		inoblk;			/* inode block address */
static char		inobuf[MAXBSIZE];	/* inode block */
ino_t			maxino;			/* last valid inode */

/*
 * An array of elements of type struct gfs_bpp describes all blocks to
 * be relocated in order to free the space needed for the cylinder group
 * summary for all cylinder groups located in the first cylinder group.
 */
struct gfs_bpp {
	daddr_t		old;		/* old block number */
	daddr_t		new;		/* new block number */
#define GFS_FL_FIRST	1
#define GFS_FL_LAST	2
	unsigned int	flags;		/* special handling required */
	int		found;		/* how many references were updated */
};

static void	growfs(int, int, unsigned int);
static void	rdfs(daddr_t, size_t, void *, int);
static void	wtfs(daddr_t, size_t, void *, int, unsigned int);
static daddr_t alloc(void);
static int	charsperline(void);
static void	usage(void);
static int	isblock(struct fs *, unsigned char *, int);
static void	clrblock(struct fs *, unsigned char *, int);
static void	setblock(struct fs *, unsigned char *, int);
static void	initcg(int, time_t, int, unsigned int);
static void	updjcg(int, time_t, int, int, unsigned int);
static void	updcsloc(time_t, int, int, unsigned int);
static struct disklabel	*get_disklabel(int);
static void	return_disklabel(int, struct disklabel *, unsigned int);
static union dinode *ginode(ino_t, int, int);
static void	frag_adjust(daddr_t, int);
static int	cond_bl_upd(daddr_t *, struct gfs_bpp *, int, int,
		    unsigned int);
static void	updclst(int);
static void	updrefs(int, ino_t, struct gfs_bpp *, int, int, unsigned int);
static void	indirchk(daddr_t, daddr_t, daddr_t, daddr_t,
		    struct gfs_bpp *, int, int, unsigned int);
static void	ffs1_sb_update(struct fs *, daddr_t);

int	colwidth;

/*
 * Here we actually start growing the filesystem. We basically read the
 * cylinder summary from the first cylinder group as we want to update
 * this on the fly during our various operations. First we handle the
 * changes in the former last cylinder group. Afterwards we create all new
 * cylinder groups. Now we handle the cylinder group containing the
 * cylinder summary which might result in a relocation of the whole
 * structure. In the end we write back the updated cylinder summary, the
 * new superblock, and slightly patched versions of the super block
 * copies.
 */
static void
growfs(int fsi, int fso, unsigned int Nflag)
{
	int	i;
	int	cylno, j;
	time_t	utime;
	char	tmpbuf[100];

	time(&utime);

	/*
	 * Get the cylinder summary into the memory.
	 */
	fscs = calloc(1, (size_t)sblock.fs_cssize);
	if (fscs == NULL)
		errx(1, "calloc failed");
	for (i = 0; i < osblock.fs_cssize; i += osblock.fs_bsize) {
		rdfs(fsbtodb(&osblock, osblock.fs_csaddr +
		    numfrags(&osblock, i)), (size_t)MINIMUM(osblock.fs_cssize - i,
		    osblock.fs_bsize), (void *)(((char *)fscs)+i), fsi);
	}

	/*
	 * Do all needed changes in the former last cylinder group.
	 */
	updjcg(osblock.fs_ncg - 1, utime, fsi, fso, Nflag);

	/*
	 * Dump out summary information about filesystem.
	 */
#define B2MBFACTOR (1 / (1024.0 * 1024.0))
	printf("growfs: %.1fMB (%jd sectors) block size %d, fragment size %d\n",
	    (float)sblock.fs_size * sblock.fs_fsize * B2MBFACTOR,
	    (intmax_t)fsbtodb(&sblock, sblock.fs_size), sblock.fs_bsize,
	    sblock.fs_fsize);
	printf("\tusing %d cylinder groups of %.2fMB, %d blks, %d inodes.\n",
	    sblock.fs_ncg, (float)sblock.fs_fpg * sblock.fs_fsize * B2MBFACTOR,
	    sblock.fs_fpg / sblock.fs_frag, sblock.fs_ipg);
	if (sblock.fs_flags & FS_DOSOFTDEP)
		printf("\twith soft updates\n");
#undef B2MBFACTOR

	/*
	 * Now build the cylinders group blocks and
	 * then print out indices of cylinder groups.
	 */
	if (!quiet)
		printf("super-block backups (for fsck -b #) at:\n");
	i = 0;

	/*
	 * Iterate for only the new cylinder groups.
	 */
	for (cylno = osblock.fs_ncg; cylno < sblock.fs_ncg; cylno++) {
		initcg(cylno, utime, fso, Nflag);
		if (quiet)
			continue;
		j = snprintf(tmpbuf, sizeof(tmpbuf), " %lld%s",
		    fsbtodb(&sblock, cgsblock(&sblock, cylno)),
		    cylno < (sblock.fs_ncg - 1) ? "," : "");
		if (j >= sizeof(tmpbuf))
			j = sizeof(tmpbuf) - 1;
		if (j == -1 || i + j >= colwidth) {
			printf("\n");
			i = 0;
		}
		i += j;
		printf("%s", tmpbuf);
		fflush(stdout);
	}
	if (!quiet)
		printf("\n");

	/*
	 * Do all needed changes in the first cylinder group.
	 * allocate blocks in new location
	 */
	updcsloc(utime, fsi, fso, Nflag);

	/*
	 * Now write the cylinder summary back to disk.
	 */
	for (i = 0; i < sblock.fs_cssize; i += sblock.fs_bsize) {
		wtfs(fsbtodb(&sblock, sblock.fs_csaddr + numfrags(&sblock, i)),
		    (size_t)MINIMUM(sblock.fs_cssize - i, sblock.fs_bsize),
		    (void *)(((char *)fscs) + i), fso, Nflag);
	}

	/*
	 * Now write the new superblock back to disk.
	 */
	sblock.fs_time = utime;
	sblock.fs_clean = 0;
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		sblock.fs_ffs1_time = (int32_t)sblock.fs_time;
		sblock.fs_ffs1_size = (int32_t)sblock.fs_size;
		sblock.fs_ffs1_dsize = (int32_t)sblock.fs_dsize;
		sblock.fs_ffs1_csaddr = (int32_t)sblock.fs_csaddr;
		sblock.fs_ffs1_cstotal.cs_ndir =
		    (int32_t)sblock.fs_cstotal.cs_ndir;
		sblock.fs_ffs1_cstotal.cs_nbfree =
		    (int32_t)sblock.fs_cstotal.cs_nbfree;
		sblock.fs_ffs1_cstotal.cs_nifree =
		    (int32_t)sblock.fs_cstotal.cs_nifree;
		sblock.fs_ffs1_cstotal.cs_nffree =
		    (int32_t)sblock.fs_cstotal.cs_nffree;
	}
	wtfs(sblockloc, (size_t)SBLOCKSIZE, (void *)&sblock, fso, Nflag);

	/*
	 * Clean up the dynamic fields in our superblock copies.
	 */
	sblock.fs_fmod = 0;
	sblock.fs_clean = 1;
	sblock.fs_ronly = 0;
	sblock.fs_cgrotor = 0;
	sblock.fs_state = 0;
	memset(&sblock.fs_fsmnt, 0, sizeof(sblock.fs_fsmnt));
	sblock.fs_flags &= FS_DOSOFTDEP;
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		sblock.fs_ffs1_flags &= FS_DOSOFTDEP;

	/*
	 * XXX
	 * The following fields are currently distributed from the  superblock
	 * to the copies:
	 *     fs_minfree
	 *     fs_rotdelay
	 *     fs_maxcontig
	 *     fs_maxbpg
	 *     fs_minfree,
	 *     fs_optim
	 *     fs_flags regarding SOFTPDATES
	 *
	 * We probably should rather change the summary for the cylinder group
	 * statistics here to the value of what would be in there, if the file
	 * system were created initially with the new size. Therefore we still
	 * need to find an easy way of calculating that.
	 * Possibly we can try to read the first superblock copy and apply the
	 * "diffed" stats between the old and new superblock by still  copying
	 * certain parameters onto that.
	 */

	/*
	 * Write out the duplicate superblocks.
	 */
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++) {
		wtfs(fsbtodb(&sblock, cgsblock(&sblock, cylno)),
		    (size_t)SBLOCKSIZE, (void *)&sblock, fso, Nflag);
	}
}

/*
 * This creates a new cylinder group structure, for more details please  see
 * the  source of newfs(8), as this function is taken over almost unchanged.
 * As  this  is  never called for the  first  cylinder  group,  the  special
 * provisions for that case are removed here.
 */
static void
initcg(int cylno, time_t utime, int fso, unsigned int Nflag)
{
	static char *iobuf;
	daddr_t d, dlower, dupper, blkno, start;
	daddr_t i, cbase, dmax;
	struct ufs1_dinode *dp1;
	struct ufs2_dinode *dp2;
	struct csum *cs;
	ino_t j;
	size_t iobufsize;

	if (sblock.fs_bsize < SBLOCKSIZE)
		iobufsize = SBLOCKSIZE + 3 * sblock.fs_bsize;
	else
		iobufsize = 4 * sblock.fs_bsize;

	if (iobuf == NULL && (iobuf = malloc(iobufsize)) == NULL)
		errx(37, "panic: cannot allocate I/O buffer");
	bzero(iobuf, iobufsize);

	/*
	 * Determine block bounds for cylinder group.
	 * Allow space for super block summary information in first
	 * cylinder group.
	 */
	cbase = cgbase(&sblock, cylno);
	dmax = cbase + sblock.fs_fpg;
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
	dlower = cgsblock(&sblock, cylno) - cbase;
	dupper = cgdmin(&sblock, cylno) - cbase;
	if (cylno == 0) /* XXX fscs may be relocated */
		dupper += howmany(sblock.fs_cssize, sblock.fs_fsize);
	cs = &fscs[cylno];
	memset(&acg, 0, sblock.fs_cgsize);
	acg.cg_ffs2_time = utime;
	acg.cg_magic = CG_MAGIC;
	acg.cg_cgx = cylno;
	acg.cg_ffs2_niblk = sblock.fs_ipg;
	acg.cg_initediblk = MINIMUM(sblock.fs_ipg, 2 * INOPB(&sblock));
	acg.cg_ndblk = dmax - cbase;
	if (sblock.fs_contigsumsize > 0)
		acg.cg_nclusterblks = acg.cg_ndblk / sblock.fs_frag;
	start = sizeof(struct cg);
	if (sblock.fs_magic == FS_UFS2_MAGIC) {
		acg.cg_iusedoff = start;
	} else {
		if (cylno == sblock.fs_ncg - 1)
			acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
		else
			acg.cg_ncyl = sblock.fs_cpg;
		acg.cg_time = (int32_t)acg.cg_ffs2_time;
		acg.cg_ffs2_time = 0;
		acg.cg_niblk = (int16_t)acg.cg_ffs2_niblk;
		acg.cg_ffs2_niblk = 0;
		acg.cg_initediblk = 0;
		acg.cg_btotoff = start;
		acg.cg_boff = acg.cg_btotoff +
		    sblock.fs_cpg * sizeof(int32_t);
		acg.cg_iusedoff = acg.cg_boff +
		    sblock.fs_cpg * sizeof(u_int16_t);
	}
	acg.cg_freeoff = acg.cg_iusedoff + howmany(sblock.fs_ipg, CHAR_BIT);
	acg.cg_nextfreeoff = acg.cg_freeoff + howmany(sblock.fs_fpg, CHAR_BIT);
	if (sblock.fs_contigsumsize > 0) {
		acg.cg_clustersumoff =
		    roundup(acg.cg_nextfreeoff, sizeof(u_int32_t));
		acg.cg_clustersumoff -= sizeof(u_int32_t);
		acg.cg_clusteroff = acg.cg_clustersumoff +
		    (sblock.fs_contigsumsize + 1) * sizeof(u_int32_t);
		acg.cg_nextfreeoff = acg.cg_clusteroff +
		    howmany(fragstoblks(&sblock, sblock.fs_fpg), CHAR_BIT);
	}
	if (acg.cg_nextfreeoff > sblock.fs_cgsize) {
		/*
		 * This should never happen as we would have had that panic
		 *     already on filesystem creation
		 */
		errx(37, "panic: cylinder group too big");
	}
	acg.cg_cs.cs_nifree += sblock.fs_ipg;
	if (cylno == 0) {
		for (i = 0; i < ROOTINO; i++) {
			setbit(cg_inosused(&acg), i);
			acg.cg_cs.cs_nifree--;
		}
	}
	if (cylno > 0) {
		/*
		 * In cylno 0, beginning space is reserved
		 * for boot and super blocks.
		 */
		for (d = 0; d < dlower; d += sblock.fs_frag) {
			blkno = d / sblock.fs_frag;
			setblock(&sblock, cg_blksfree(&acg), blkno);
			if (sblock.fs_contigsumsize > 0)
				setbit(cg_clustersfree(&acg), blkno);
			acg.cg_cs.cs_nbfree++;
		}
		sblock.fs_dsize += dlower;
	}
	sblock.fs_dsize += acg.cg_ndblk - dupper;
	if ((i = dupper % sblock.fs_frag)) {
		acg.cg_frsum[sblock.fs_frag - i]++;
		for (d = dupper + sblock.fs_frag - i; dupper < d; dupper++) {
			setbit(cg_blksfree(&acg), dupper);
			acg.cg_cs.cs_nffree++;
		}
	}
	for (d = dupper; d + sblock.fs_frag <= acg.cg_ndblk;
	    d += sblock.fs_frag) {
		blkno = d / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), blkno);
		if (sblock.fs_contigsumsize > 0)
			setbit(cg_clustersfree(&acg), blkno);
		acg.cg_cs.cs_nbfree++;
	}
	if (d < acg.cg_ndblk) {
		acg.cg_frsum[acg.cg_ndblk - d]++;
		for (; d < acg.cg_ndblk; d++) {
			setbit(cg_blksfree(&acg), d);
			acg.cg_cs.cs_nffree++;
		}
	}
	if (sblock.fs_contigsumsize > 0) {
		int32_t	*sump = cg_clustersum(&acg);
		u_char	*mapp = cg_clustersfree(&acg);
		int	map = *mapp++;
		int	bit = 1;
		int	run = 0;

		for (i = 0; i < acg.cg_nclusterblks; i++) {
			if ((map & bit) != 0)
				run++;
			else if (run != 0) {
				if (run > sblock.fs_contigsumsize)
					run = sblock.fs_contigsumsize;
				sump[run]++;
				run = 0;
			}
			if ((i & (CHAR_BIT - 1)) != CHAR_BIT - 1)
				bit <<= 1;
			else {
				map = *mapp++;
				bit = 1;
			}
		}
		if (run != 0) {
			if (run > sblock.fs_contigsumsize)
				run = sblock.fs_contigsumsize;
			sump[run]++;
		}
	}
	sblock.fs_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
	*cs = acg.cg_cs;

	/*
	 * Write out the duplicate superblock, the cylinder group map
	 * and two blocks worth of inodes in a single write.
	 */
	bcopy(&sblock, iobuf, SBLOCKSIZE);
	start = sblock.fs_bsize > SBLOCKSIZE ? sblock.fs_bsize : SBLOCKSIZE;
	bcopy(&acg, &iobuf[start], sblock.fs_cgsize);
	start += sblock.fs_bsize;
	dp1 = (struct ufs1_dinode *)&iobuf[start];
	dp2 = (struct ufs2_dinode *)&iobuf[start];
	for (i = MINIMUM(sblock.fs_ipg, 2 * INOPB(&sblock)); i != 0; i--) {
		if (sblock.fs_magic == FS_UFS1_MAGIC) {
			dp1->di_gen = arc4random();
			dp1++;
		} else {
			dp2->di_gen = arc4random();
			dp2++;
		}
	}
	wtfs(fsbtodb(&sblock, cgsblock(&sblock, cylno)), iobufsize,
	    iobuf, fso, Nflag);

	/* Initialize inodes for FFS1. */
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		for (i = 2 * sblock.fs_frag; i < sblock.fs_ipg / INOPF(&sblock);
		    i += sblock.fs_frag) {
			dp1 = (struct ufs1_dinode *)&iobuf[start];
			for (j = 0; j < INOPB(&sblock); j++) {
				dp1->di_gen = arc4random();
				dp1++;
			}
			wtfs(fsbtodb(&sblock, cgimin(&sblock, cylno) + i),
			    (size_t)sblock.fs_bsize, &iobuf[start], fso, Nflag);
		}
	}
}

/*
 * Here  we add or subtract (sign +1/-1) the available fragments in  a  given
 * block to or from the fragment statistics. By subtracting before and adding
 * after  an operation on the free frag map we can easy update  the  fragment
 * statistic, which seems to be otherwise a rather complex operation.
 */
static void
frag_adjust(daddr_t frag, int sign)
{
	int fragsize;
	int f;

	fragsize = 0;
	/*
	 * Here frag only needs to point to any fragment in the block we want
	 * to examine.
	 */
	for (f = rounddown(frag, sblock.fs_frag);
	    f < roundup(frag + 1, sblock.fs_frag);
	    f++) {
		/*
		 * Count contiguous free fragments.
		 */
		if (isset(cg_blksfree(&acg), f)) {
			fragsize++;
		} else {
			if (fragsize && fragsize < sblock.fs_frag) {
				/*
				 * We found something in between.
				 */
				acg.cg_frsum[fragsize] += sign;
			}
			fragsize = 0;
		}
	}
	if (fragsize && fragsize < sblock.fs_frag) {
		/*
		 * We found something.
		 */
		acg.cg_frsum[fragsize] += sign;
	}
}

/*
 * Here we conditionally update a pointer to a fragment. We check for all
 * relocated blocks if any of its fragments is referenced by the current
 * field,  and update the pointer to the respective fragment in  our  new
 * block.  If  we find a reference we write back the  block  immediately,
 * as there is no easy way for our general block reading engine to figure
 * out if a write back operation is needed.
 */
static int
cond_bl_upd(daddr_t *block, struct gfs_bpp *field, int fsi, int fso,
    unsigned int Nflag)
{
	struct gfs_bpp	*f;
	daddr_t src, dst;
	int fragnum;
	void *ibuf;

	for (f = field; f->old != 0; f++) {
		src = *block;
		if (fragstoblks(&sblock, src) != f->old)
			continue;
		/*
		 * The fragment is part of the block, so update.
		 */
		dst = blkstofrags(&sblock, f->new);
		fragnum = fragnum(&sblock, src);
		*block = dst + fragnum;
		f->found++;

		/*
		 * Copy the block back immediately.
		 *
		 * XXX	If src is from an indirect block we have
		 *	to implement copy on write here in case of
		 *	active snapshots.
		 */
		ibuf = malloc(sblock.fs_bsize);
		if (!ibuf)
			errx(1, "malloc failed");
		src -= fragnum;
		rdfs(fsbtodb(&sblock, src), (size_t)sblock.fs_bsize, ibuf, fsi);
		wtfs(dst, (size_t)sblock.fs_bsize, ibuf, fso, Nflag);
		free(ibuf);
		/*
		 * The same block can't be found again in this loop.
		 */
		return (1);
	}

	return (0);
}

/*
 * Here we do all needed work for the former last cylinder group. It has to be
 * changed  in  any case, even if the filesystem ended exactly on the  end  of
 * this  group, as there is some slightly inconsistent handling of the  number
 * of cylinders in the cylinder group. We start again by reading the  cylinder
 * group from disk. If the last block was not fully available, we first handle
 * the  missing  fragments, then we handle all new full blocks  in  that  file
 * system  and  finally we handle the new last fragmented block  in  the  file
 * system.  We again have to handle the fragment statistics rotational  layout
 * tables and cluster summary during all those operations.
 */
static void
updjcg(int cylno, time_t utime, int fsi, int fso, unsigned int Nflag)
{
	daddr_t	cbase, dmax, dupper;
	struct csum	*cs;
	int	i, k;
	int	j = 0;

	/*
	 * Read the former last (joining) cylinder group from disk, and make
	 * a copy.
	 */
	rdfs(fsbtodb(&osblock, cgtod(&osblock, cylno)),
	    (size_t)osblock.fs_cgsize, (void *)&aocg, fsi);

	memcpy(&cgun1, &cgun2, sizeof(cgun2));

	/*
	 * If the cylinder group had already its new final size almost
	 * nothing is to be done ... except:
	 * For some reason the value of cg_ncyl in the last cylinder group has
	 * to  be  zero instead of fs_cpg. As this is now no longer  the  last
	 * cylinder group we have to change that value now to fs_cpg.
	 */
	if (cgbase(&osblock, cylno+1) == osblock.fs_size) {
		if (sblock.fs_magic == FS_UFS1_MAGIC)
			acg.cg_ncyl = sblock.fs_cpg;

		wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)),
		    (size_t)sblock.fs_cgsize, (void *)&acg, fso, Nflag);

		return;
	}

	/*
	 * Set up some variables needed later.
	 */
	cbase = cgbase(&sblock, cylno);
	dmax = cbase + sblock.fs_fpg;
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
	dupper = cgdmin(&sblock, cylno) - cbase;
	if (cylno == 0)	/* XXX fscs may be relocated */
		dupper += howmany(sblock.fs_cssize, sblock.fs_fsize);

	/*
	 * Set pointer to the cylinder summary for our cylinder group.
	 */
	cs = fscs + cylno;

	/*
	 * Touch the cylinder group, update all fields in the cylinder group as
	 * needed, update the free space in the superblock.
	 */
	acg.cg_time = utime;
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		if (cylno == sblock.fs_ncg - 1) {
			/*
			 * This is still the last cylinder group.
			 */
			acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
		} else {
			acg.cg_ncyl = sblock.fs_cpg;
		}
	}
	acg.cg_ndblk = dmax - cbase;
	sblock.fs_dsize += acg.cg_ndblk-aocg.cg_ndblk;
	if (sblock.fs_contigsumsize > 0)
		acg.cg_nclusterblks = acg.cg_ndblk / sblock.fs_frag;

	/*
	 * Now  we have to update the free fragment bitmap for our new  free
	 * space.  There again we have to handle the fragmentation and  also
	 * the  rotational  layout tables and the cluster summary.  This  is
	 * also  done per fragment for the first new block if the  old  file
	 * system end was not on a block boundary, per fragment for the  new
	 * last block if the new filesystem end is not on a block boundary,
	 * and per block for all space in between.
	 *
	 * Handle the first new block here if it was partially available
	 * before.
	 */
	if (osblock.fs_size % sblock.fs_frag) {
		if (roundup(osblock.fs_size, sblock.fs_frag) <= sblock.fs_size) {
			/*
			 * The new space is enough to fill at least this
			 * block
			 */
			j = 0;
			for (i = roundup(osblock.fs_size-cbase, sblock.fs_frag) - 1;
			    i >= osblock.fs_size-cbase; i--) {
				setbit(cg_blksfree(&acg), i);
				acg.cg_cs.cs_nffree++;
				j++;
			}

			/*
			 * Check  if the fragment just created could join  an
			 * already existing fragment at the former end of the
			 * filesystem.
			 */
			if (isblock(&sblock, cg_blksfree(&acg),
			    ((osblock.fs_size - cgbase(&sblock, cylno))/
			    sblock.fs_frag))) {
				/*
				 * The block is now completely available.
				 */
				acg.cg_frsum[osblock.fs_size%sblock.fs_frag]--;
				acg.cg_cs.cs_nbfree++;
				acg.cg_cs.cs_nffree-=sblock.fs_frag;
				k = rounddown(osblock.fs_size-cbase,
				    sblock.fs_frag);
				updclst((osblock.fs_size-cbase)/sblock.fs_frag);
			} else {
				/*
				 * Lets rejoin a possible partially growed
				 * fragment.
				 */
				k = 0;
				while (isset(cg_blksfree(&acg), i) &&
				    (i >= rounddown(osblock.fs_size - cbase,
				    sblock.fs_frag))) {
					i--;
					k++;
				}
				if (k)
					acg.cg_frsum[k]--;
				acg.cg_frsum[k + j]++;
			}
		} else {
			/*
			 * We only grow by some fragments within this last
			 * block.
			 */
			for (i = sblock.fs_size-cbase-1;
			    i >= osblock.fs_size-cbase; i--) {
				setbit(cg_blksfree(&acg), i);
				acg.cg_cs.cs_nffree++;
				j++;
			}
			/*
			 * Lets rejoin a possible partially growed fragment.
			 */
			k = 0;
			while (isset(cg_blksfree(&acg), i) &&
			    (i >= rounddown(osblock.fs_size - cbase,
			    sblock.fs_frag))) {
				i--;
				k++;
			}
			if (k)
				acg.cg_frsum[k]--;
			acg.cg_frsum[k + j]++;
		}
	}

	/*
	 * Handle all new complete blocks here.
	 */
	for (i = roundup(osblock.fs_size - cbase, sblock.fs_frag);
	    i + sblock.fs_frag <= dmax-cbase;	/* XXX <= or only < ? */
	    i += sblock.fs_frag) {
		j = i / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), j);
		updclst(j);
		acg.cg_cs.cs_nbfree++;
	}

	/*
	 * Handle the last new block if there are stll some new fragments left.
	 * Here  we don't have to bother about the cluster summary or the  even
	 * the rotational layout table.
	 */
	if (i < (dmax - cbase)) {
		acg.cg_frsum[dmax - cbase - i]++;
		for (; i < dmax - cbase; i++) {
			setbit(cg_blksfree(&acg), i);
			acg.cg_cs.cs_nffree++;
		}
	}

	sblock.fs_cstotal.cs_nffree +=
	    (acg.cg_cs.cs_nffree - aocg.cg_cs.cs_nffree);
	sblock.fs_cstotal.cs_nbfree +=
	    (acg.cg_cs.cs_nbfree - aocg.cg_cs.cs_nbfree);
	/*
	 * The following statistics are not changed here:
	 *     sblock.fs_cstotal.cs_ndir
	 *     sblock.fs_cstotal.cs_nifree
	 * As the statistics for this cylinder group are ready, copy it to
	 * the summary information array.
	 */
	*cs = acg.cg_cs;

	/*
	 * Write the updated "joining" cylinder group back to disk.
	 */
	wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)), (size_t)sblock.fs_cgsize,
	    (void *)&acg, fso, Nflag);
}

/*
 * Here  we update the location of the cylinder summary. We have  two  possible
 * ways of growing the cylinder summary.
 * (1)	We can try to grow the summary in the current location, and  relocate
 *	possibly used blocks within the current cylinder group.
 * (2)	Alternatively we can relocate the whole cylinder summary to the first
 *	new completely empty cylinder group. Once the cylinder summary is  no
 *	longer in the beginning of the first cylinder group you should  never
 *	use  a version of fsck which is not aware of the possibility to  have
 *	this structure in a non standard place.
 * Option (1) is considered to be less intrusive to the structure of the  file-
 * system. So we try to stick to that whenever possible. If there is not enough
 * space  in the cylinder group containing the cylinder summary we have to  use
 * method  (2). In case of active snapshots in the filesystem we  probably  can
 * completely avoid implementing copy on write if we stick to method (2) only.
 */
static void
updcsloc(time_t utime, int fsi, int fso, unsigned int Nflag)
{
	struct csum	*cs;
	int	ocscg, ncscg;
	int	blocks;
	daddr_t	cbase, dupper, odupper, d, f, g;
	int	ind;
	int	cylno, inc;
	struct gfs_bpp	*bp;
	int	i, l;
	int	lcs = 0;
	int	block;

	if (howmany(sblock.fs_cssize, sblock.fs_fsize) ==
	    howmany(osblock.fs_cssize, osblock.fs_fsize)) {
		/*
		 * No new fragment needed.
		 */
		return;
	}
	ocscg = dtog(&osblock, osblock.fs_csaddr);
	cs = fscs + ocscg;
	blocks = 1+howmany(sblock.fs_cssize, sblock.fs_bsize)-
	    howmany(osblock.fs_cssize, osblock.fs_bsize);

	/*
	 * Read original cylinder group from disk, and make a copy.
	 * XXX	If Nflag is set in some very rare cases we now miss
	 *	some changes done in updjcg by reading the unmodified
	 *	block from disk.
	 */
	rdfs(fsbtodb(&osblock, cgtod(&osblock, ocscg)),
	    (size_t)osblock.fs_cgsize, (void *)&aocg, fsi);

	memcpy(&cgun1, &cgun2, sizeof(cgun2));

	/*
	 * Touch the cylinder group, set up local variables needed later
	 * and update the superblock.
	 */
	acg.cg_time = utime;

	/*
	 * XXX	In the case of having active snapshots we may need much more
	 *	blocks for the copy on write. We need each block twice,  and
	 *	also  up to 8*3 blocks for indirect blocks for all  possible
	 *	references.
	 */
	if (/*((int)sblock.fs_time & 0x3) > 0 || */ cs->cs_nbfree < blocks) {
		/*
		 * There  is  not enough space in the old cylinder  group  to
		 * relocate  all blocks as needed, so we relocate  the  whole
		 * cylinder  group summary to a new group. We try to use  the
		 * first complete new cylinder group just created. Within the
		 * cylinder  group we align the area immediately  after  the
		 * cylinder  group  information location in order  to  be  as
		 * close as possible to the original implementation of ffs.
		 *
		 * First  we have to make sure we'll find enough space in  the
		 * new  cylinder  group. If not, then we  currently  give  up.
		 * We  start  with freeing everything which was  used  by  the
		 * fragments of the old cylinder summary in the current group.
		 * Now  we write back the group meta data, read in the  needed
		 * meta data from the new cylinder group, and start allocating
		 * within  that  group. Here we can assume, the  group  to  be
		 * completely empty. Which makes the handling of fragments and
		 * clusters a lot easier.
		 */
		if (sblock.fs_ncg-osblock.fs_ncg < 2)
			errx(2, "panic: not enough space");

		/*
		 * Point "d" to the first fragment not used by the cylinder
		 * summary.
		 */
		d = osblock.fs_csaddr + (osblock.fs_cssize / osblock.fs_fsize);

		/*
		 * Set up last cluster size ("lcs") already here. Calculate
		 * the size for the trailing cluster just behind where  "d"
		 * points to.
		 */
		if (sblock.fs_contigsumsize > 0) {
			for (block = howmany(d % sblock.fs_fpg, sblock.fs_frag),
			    lcs = 0; lcs < sblock.fs_contigsumsize;
			    block++, lcs++) {
				if (isclr(cg_clustersfree(&acg), block))
					break;
			}
		}

		/*
		 * Point "d" to the last frag used by the cylinder summary.
		 */
		d--;

		if ((d + 1) % sblock.fs_frag) {
			/*
			 * The end of the cylinder summary is not a complete
			 * block.
			 */
			frag_adjust(d % sblock.fs_fpg, -1);
			for (; (d + 1) % sblock.fs_frag; d--) {
				setbit(cg_blksfree(&acg), d % sblock.fs_fpg);
				acg.cg_cs.cs_nffree++;
				sblock.fs_cstotal.cs_nffree++;
			}
			/*
			 * Point  "d" to the last fragment of the  last
			 * (incomplete) block of the cylinder summary.
			 */
			d++;
			frag_adjust(d % sblock.fs_fpg, 1);

			if (isblock(&sblock, cg_blksfree(&acg),
			    (d % sblock.fs_fpg) / sblock.fs_frag)) {
				acg.cg_cs.cs_nffree -= sblock.fs_frag;
				acg.cg_cs.cs_nbfree++;
				sblock.fs_cstotal.cs_nffree -= sblock.fs_frag;
				sblock.fs_cstotal.cs_nbfree++;
				if (sblock.fs_contigsumsize > 0) {
					setbit(cg_clustersfree(&acg),
					    (d % sblock.fs_fpg) / sblock.fs_frag);
					if (lcs < sblock.fs_contigsumsize) {
						if (lcs) {
							cg_clustersum(&acg)
							    [lcs]--;
						}
						lcs++;
						cg_clustersum(&acg)[lcs]++;
					}
				}
			}
			/*
			 * Point "d" to the first fragment of the block before
			 * the last incomplete block.
			 */
			d--;
		}

		for (d = rounddown(d, sblock.fs_frag); d >= osblock.fs_csaddr;
		    d -= sblock.fs_frag) {
			setblock(&sblock, cg_blksfree(&acg),
			    (d % sblock.fs_fpg) / sblock.fs_frag);
			acg.cg_cs.cs_nbfree++;
			sblock.fs_cstotal.cs_nbfree++;
			 if (sblock.fs_contigsumsize > 0) {
				setbit(cg_clustersfree(&acg),
				    (d % sblock.fs_fpg) / sblock.fs_frag);
				/*
				 * The last cluster size is already set up.
				 */
				if (lcs < sblock.fs_contigsumsize) {
					if (lcs) {
						cg_clustersum(&acg)[lcs]--;
					}
					lcs++;
					cg_clustersum(&acg)[lcs]++;
				}
			}
		}
		*cs = acg.cg_cs;

		/*
		 * Now write the former cylinder group containing the cylinder
		 * summary back to disk.
		 */
		wtfs(fsbtodb(&sblock, cgtod(&sblock, ocscg)),
		    (size_t)sblock.fs_cgsize, (void *)&acg, fso, Nflag);

		/*
		 * Find the beginning of the new cylinder group containing the
		 * cylinder summary.
		 */
		sblock.fs_csaddr = cgdmin(&sblock, osblock.fs_ncg);
		ncscg = dtog(&sblock, sblock.fs_csaddr);
		cs = fscs + ncscg;


		/*
		 * If Nflag is specified, we would now read random data instead
		 * of an empty cg structure from disk. So we can't simulate that
		 * part for now.
		 */
		if (Nflag)
			return;

		/*
		 * Read the future cylinder group containing the cylinder
		 * summary from disk, and make a copy.
		 */
		rdfs(fsbtodb(&sblock, cgtod(&sblock, ncscg)),
		    (size_t)sblock.fs_cgsize, &aocg, fsi);

		memcpy(&cgun1, &cgun2, sizeof(cgun2));

		/*
		 * Allocate all complete blocks used by the new cylinder
		 * summary.
		 */
		for (d = sblock.fs_csaddr; d + sblock.fs_frag <=
		    sblock.fs_csaddr + (sblock.fs_cssize / sblock.fs_fsize);
		    d += sblock.fs_frag) {
			clrblock(&sblock, cg_blksfree(&acg),
			    (d%sblock.fs_fpg)/sblock.fs_frag);
			acg.cg_cs.cs_nbfree--;
			sblock.fs_cstotal.cs_nbfree--;
			if (sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg),
				    (d % sblock.fs_fpg) / sblock.fs_frag);
			}
		}

		/*
		 * Allocate all fragments used by the cylinder summary in the
		 * last block.
		 */
		if (d < sblock.fs_csaddr + (sblock.fs_cssize / sblock.fs_fsize)) {
			for (; d - sblock.fs_csaddr <
			    sblock.fs_cssize/sblock.fs_fsize;
			    d++) {
				clrbit(cg_blksfree(&acg), d%sblock.fs_fpg);
				acg.cg_cs.cs_nffree--;
				sblock.fs_cstotal.cs_nffree--;
			}
			acg.cg_cs.cs_nbfree--;
			acg.cg_cs.cs_nffree += sblock.fs_frag;
			sblock.fs_cstotal.cs_nbfree--;
			sblock.fs_cstotal.cs_nffree += sblock.fs_frag;
			if (sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg),
				    (d%sblock.fs_fpg) / sblock.fs_frag);
			}

			frag_adjust(d % sblock.fs_fpg, 1);
		}
		/*
		 * XXX	Handle the cluster statistics here in the case  this
		 *	cylinder group is now almost full, and the remaining
		 *	space is less then the maximum cluster size. This is
		 *	probably not needed, as you would hardly find a file
		 *	system which has only MAXCSBUFS+FS_MAXCONTIG of free
		 *	space right behind the cylinder group information in
		 *	any new cylinder group.
		 */

		/*
		 * Update our statistics in the cylinder summary.
		 */
		*cs = acg.cg_cs;

		/*
		 * Write the new cylinder group containing the cylinder summary
		 * back to disk.
		 */
		wtfs(fsbtodb(&sblock, cgtod(&sblock, ncscg)),
		    (size_t)sblock.fs_cgsize, (void *)&acg, fso, Nflag);
		return;
	}
	/*
	 * We have got enough of space in the current cylinder group, so we
	 * can relocate just a few blocks, and let the summary  information
	 * grow in place where it is right now.
	 */
	cbase = cgbase(&osblock, ocscg);	/* old and new are equal */
	dupper = sblock.fs_csaddr - cbase +
	    howmany(sblock.fs_cssize, sblock.fs_fsize);
	odupper = osblock.fs_csaddr - cbase +
	    howmany(osblock.fs_cssize, osblock.fs_fsize);

	sblock.fs_dsize -= dupper-odupper;

	/*
	 * Allocate the space for the array of blocks to be relocated.
	 */
	bp = calloc(((dupper-odupper) / sblock.fs_frag + 2),
	    sizeof(struct gfs_bpp));
	if (bp == NULL)
		errx(1, "calloc failed");

	/*
	 * Lock all new frags needed for the cylinder group summary. This  is
	 * done per fragment in the first and last block of the new  required
	 * area, and per block for all other blocks.
	 *
	 * Handle the first new  block here (but only if some fragments where
	 * already used for the cylinder summary).
	 */
	ind = 0;
	frag_adjust(odupper, -1);
	for (d = odupper; ((d < dupper) && (d % sblock.fs_frag)); d++) {
		if (isclr(cg_blksfree(&acg), d)) {
			if (!ind) {
				bp[ind].old = d / sblock.fs_frag;
				bp[ind].flags|=GFS_FL_FIRST;
				if (roundup(d, sblock.fs_frag) >= dupper)
					bp[ind].flags |= GFS_FL_LAST;
				ind++;
			}
		} else {
			clrbit(cg_blksfree(&acg), d);
			acg.cg_cs.cs_nffree--;
			sblock.fs_cstotal.cs_nffree--;
		}
		/*
		 * No cluster handling is needed here, as there was at least
		 * one  fragment in use by the cylinder summary in  the  old
		 * filesystem.
		 * No block - free counter handling here as this block was not
		 * a free block.
		 */
	}
	frag_adjust(odupper, 1);

	/*
	 * Handle all needed complete blocks here.
	 */
	for (; d + sblock.fs_frag <= dupper; d += sblock.fs_frag) {
		if (!isblock(&sblock, cg_blksfree(&acg), d / sblock.fs_frag)) {
			for (f = d; f < d + sblock.fs_frag; f++) {
				if (isset(cg_blksfree(&aocg), f)) {
					acg.cg_cs.cs_nffree--;
					sblock.fs_cstotal.cs_nffree--;
				}
			}
			clrblock(&sblock, cg_blksfree(&acg), d / sblock.fs_frag);
			bp[ind].old = d / sblock.fs_frag;
			ind++;
		} else {
			clrblock(&sblock, cg_blksfree(&acg), d / sblock.fs_frag);
			acg.cg_cs.cs_nbfree--;
			sblock.fs_cstotal.cs_nbfree--;
			if (sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg), d / sblock.fs_frag);
				for (lcs = 0, l = (d / sblock.fs_frag) + 1;
				    lcs < sblock.fs_contigsumsize;
				    l++, lcs++) {
					if (isclr(cg_clustersfree(&acg), l))
						break;
				}
				if (lcs < sblock.fs_contigsumsize) {
					cg_clustersum(&acg)[lcs + 1]--;
					if (lcs)
						cg_clustersum(&acg)[lcs]++;
				}
			}
		}
		/*
		 * No fragment counter handling is needed here, as this finally
		 * doesn't change after the relocation.
		 */
	}

	/*
	 * Handle all fragments needed in the last new affected block.
	 */
	if (d < dupper) {
		frag_adjust(dupper - 1, -1);

		if (isblock(&sblock, cg_blksfree(&acg), d / sblock.fs_frag)) {
			acg.cg_cs.cs_nbfree--;
			sblock.fs_cstotal.cs_nbfree--;
			acg.cg_cs.cs_nffree+=sblock.fs_frag;
			sblock.fs_cstotal.cs_nffree+=sblock.fs_frag;
			if (sblock.fs_contigsumsize > 0) {
				clrbit(cg_clustersfree(&acg), d / sblock.fs_frag);
				for (lcs = 0, l = (d / sblock.fs_frag) + 1;
				    lcs < sblock.fs_contigsumsize;
				    l++, lcs++) {
					if (isclr(cg_clustersfree(&acg), l))
						break;
				}
				if (lcs < sblock.fs_contigsumsize) {
					cg_clustersum(&acg)[lcs + 1]--;
					if (lcs)
						cg_clustersum(&acg)[lcs]++;
				}
			}
		}

		for (; d < dupper; d++) {
			if (isclr(cg_blksfree(&acg), d)) {
				bp[ind].old = d / sblock.fs_frag;
				bp[ind].flags |= GFS_FL_LAST;
			} else {
				clrbit(cg_blksfree(&acg), d);
				acg.cg_cs.cs_nffree--;
				sblock.fs_cstotal.cs_nffree--;
			}
		}
		if (bp[ind].flags & GFS_FL_LAST) /* we have to advance here */
			ind++;
		frag_adjust(dupper - 1, 1);
	}

	/*
	 * If we found a block to relocate just do so.
	 */
	if (ind) {
		for (i = 0; i < ind; i++) {
			if (!bp[i].old) { /* no more blocks listed */
				/*
				 * XXX	A relative blocknumber should not be
				 *	zero,   which  is   not   explicitly
				 *	guaranteed by our code.
				 */
				break;
			}
			/*
			 * Allocate a complete block in the same (current)
			 * cylinder group.
			 */
			bp[i].new = alloc() / sblock.fs_frag;

			/*
			 * There is no frag_adjust() needed for the new block
			 * as it will have no fragments yet :-).
			 */
			for (f = bp[i].old * sblock.fs_frag,
			    g = bp[i].new * sblock.fs_frag;
			    f < (bp[i].old + 1) * sblock.fs_frag;
			    f++, g++) {
				if (isset(cg_blksfree(&aocg), f)) {
					setbit(cg_blksfree(&acg), g);
					acg.cg_cs.cs_nffree++;
					sblock.fs_cstotal.cs_nffree++;
				}
			}

			/*
			 * Special handling is required if this was the  first
			 * block. We have to consider the fragments which were
			 * used by the cylinder summary in the original  block
			 * which  re to be free in the copy of our  block.  We
			 * have  to be careful if this first block happens  to
			 * be also the last block to be relocated.
			 */
			if (bp[i].flags & GFS_FL_FIRST) {
				for (f = bp[i].old * sblock.fs_frag,
				    g = bp[i].new * sblock.fs_frag;
				    f < odupper;
				    f++, g++) {
					setbit(cg_blksfree(&acg), g);
					acg.cg_cs.cs_nffree++;
					sblock.fs_cstotal.cs_nffree++;
				}
				if (!(bp[i].flags & GFS_FL_LAST))
					frag_adjust(bp[i].new * sblock.fs_frag, 1);
			}

			/*
			 * Special handling is required if this is the last
			 * block to be relocated.
			 */
			if (bp[i].flags & GFS_FL_LAST) {
				frag_adjust(bp[i].new * sblock.fs_frag, 1);
				frag_adjust(bp[i].old * sblock.fs_frag, -1);
				for (f = dupper;
				    f < roundup(dupper, sblock.fs_frag);
				    f++) {
					if (isclr(cg_blksfree(&acg), f)) {
						setbit(cg_blksfree(&acg), f);
						acg.cg_cs.cs_nffree++;
						sblock.fs_cstotal.cs_nffree++;
					}
				}
				frag_adjust(bp[i].old * sblock.fs_frag, 1);
			}

			/*
			 * !!! Attach the cylindergroup offset here.
			 */
			bp[i].old += cbase / sblock.fs_frag;
			bp[i].new += cbase / sblock.fs_frag;

			/*
			 * Copy the content of the block.
			 */
			/*
			 * XXX	Here we will have to implement a copy on write
			 *	in the case we have any active snapshots.
			 */
			rdfs(fsbtodb(&sblock, bp[i].old * sblock.fs_frag),
			    (size_t)sblock.fs_bsize, (void *)&ablk, fsi);
			wtfs(fsbtodb(&sblock, bp[i].new * sblock.fs_frag),
			    (size_t)sblock.fs_bsize, (void *)&ablk, fso, Nflag);
		}

		/*
		 * Now we have to update all references to any fragment which
		 * belongs  to any block relocated. We iterate now  over  all
		 * cylinder  groups,  within those over all non  zero  length
		 * inodes.
		 */
		for (cylno = 0; cylno < osblock.fs_ncg; cylno++) {
			for (inc = osblock.fs_ipg - 1; inc > 0; inc--) {
				updrefs(cylno, (ino_t)inc, bp, fsi, fso, Nflag);
			}
		}

		/*
		 * All inodes are checked, now make sure the number of
		 * references found make sense.
		 */
		for (i = 0; i < ind; i++) {
			if (!bp[i].found || (bp[i].found > sblock.fs_frag)) {
				warnx("error: %jd refs found for block %jd.",
				    (intmax_t)bp[i].found, (intmax_t)bp[i].old);
			}

		}
	}
	/*
	 * The following statistics are not changed here:
	 *     sblock.fs_cstotal.cs_ndir
	 *     sblock.fs_cstotal.cs_nifree
	 * The following statistics were already updated on the fly:
	 *     sblock.fs_cstotal.cs_nffree
	 *     sblock.fs_cstotal.cs_nbfree
	 * As the statistics for this cylinder group are ready, copy it to
	 * the summary information array.
	 */

	*cs = acg.cg_cs;

	/*
	 * Write summary cylinder group back to disk.
	 */
	wtfs(fsbtodb(&sblock, cgtod(&sblock, ocscg)), (size_t)sblock.fs_cgsize,
	    (void *)&acg, fso, Nflag);
}

/*
 * Here we read some block(s) from disk.
 */
static void
rdfs(daddr_t bno, size_t size, void *bf, int fsi)
{
	ssize_t	n;

	if (bno < 0) {
		err(32, "rdfs: attempting to read negative block number");
	}
	if (lseek(fsi, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0) {
		err(33, "rdfs: seek error: %jd", (intmax_t)bno);
	}
	n = read(fsi, bf, size);
	if (n != (ssize_t)size) {
		err(34, "rdfs: read error: %jd", (intmax_t)bno);
	}
}

/*
 * Here we write some block(s) to disk.
 */
static void
wtfs(daddr_t bno, size_t size, void *bf, int fso, unsigned int Nflag)
{
	ssize_t	n;

	if (Nflag)
		return;

	if (lseek(fso, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0)
		err(35, "wtfs: seek error: %ld", (long)bno);
	n = write(fso, bf, size);
	if (n != (ssize_t)size)
		err(36, "wtfs: write error: %ld", (long)bno);
}

/*
 * Here we allocate a free block in the current cylinder group. It is assumed,
 * that  acg contains the current cylinder group. As we may take a block  from
 * somewhere in the filesystem we have to handle cluster summary here.
 */
static daddr_t
alloc(void)
{
	daddr_t	d, blkno;
	int	lcs1, lcs2;
	int	l;
	int	csmin, csmax;
	int	dlower, dupper, dmax;

	if (acg.cg_magic != CG_MAGIC) {
		warnx("acg: bad magic number");
		return (0);
	}
	if (acg.cg_cs.cs_nbfree == 0) {
		warnx("error: cylinder group ran out of space");
		return (0);
	}
	/*
	 * We start seeking for free blocks only from the space available after
	 * the  end of the new grown cylinder summary. Otherwise we allocate  a
	 * block here which we have to relocate a couple of seconds later again
	 * again, and we are not prepared to to this anyway.
	 */
	blkno = -1;
	dlower = cgsblock(&sblock, acg.cg_cgx) - cgbase(&sblock, acg.cg_cgx);
	dupper = cgdmin(&sblock, acg.cg_cgx) - cgbase(&sblock, acg.cg_cgx);
	dmax = cgbase(&sblock, acg.cg_cgx) + sblock.fs_fpg;
	if (dmax > sblock.fs_size) {
		dmax = sblock.fs_size;
	}
	dmax -= cgbase(&sblock, acg.cg_cgx); /* retransform into cg */
	csmin=sblock.fs_csaddr-cgbase(&sblock, acg.cg_cgx);
	csmax = csmin + howmany(sblock.fs_cssize, sblock.fs_fsize);

	for (d = 0; (d < dlower && blkno == -1); d += sblock.fs_frag) {
		if (d >= csmin && d <= csmax) {
			continue;
		}
		if (isblock(&sblock, cg_blksfree(&acg), fragstoblks(&sblock,
		    d))) {
			blkno = fragstoblks(&sblock, d);/* Yeah found a block */
			break;
		}
	}
	for (d = dupper; (d < dmax && blkno == -1); d += sblock.fs_frag) {
		if (d >= csmin && d <= csmax) {
			continue;
		}
		if (isblock(&sblock, cg_blksfree(&acg), fragstoblks(&sblock,
		    d))) {
			blkno = fragstoblks(&sblock, d);/* Yeah found a block */
			break;
		}
	}
	if (blkno == -1) {
		warnx("internal error: couldn't find promised block in cg");
		return (0);
	}

	/*
	 * This is needed if the block was found already in the first loop.
	 */
	d = blkstofrags(&sblock, blkno);

	clrblock(&sblock, cg_blksfree(&acg), blkno);
	if (sblock.fs_contigsumsize > 0) {
		/*
		 * Handle the cluster allocation bitmap.
		 */
		clrbit(cg_clustersfree(&acg), blkno);
		/*
		 * We  possibly have split a cluster here, so we have  to  do
		 * recalculate the sizes of the remaining cluster halves now,
		 * and use them for updating the cluster summary information.
		 *
		 * Lets start with the blocks before our allocated block ...
		 */
		for (lcs1 = 0, l = blkno - 1; lcs1 < sblock.fs_contigsumsize;
		    l--, lcs1++) {
			if (isclr(cg_clustersfree(&acg), l))
				break;
		}
		/*
		 * ... and continue with the blocks right after our allocated
		 * block.
		 */
		for (lcs2 = 0, l = blkno + 1; lcs2 < sblock.fs_contigsumsize;
		    l++, lcs2++) {
			if (isclr(cg_clustersfree(&acg), l))
				break;
		}

		/*
		 * Now update all counters.
		 */
		cg_clustersum(&acg)[MINIMUM(lcs1 + lcs2 + 1, sblock.fs_contigsumsize)]--;
		if (lcs1)
			cg_clustersum(&acg)[lcs1]++;
		if (lcs2)
			cg_clustersum(&acg)[lcs2]++;
	}
	/*
	 * Update all statistics based on blocks.
	 */
	acg.cg_cs.cs_nbfree--;
	sblock.fs_cstotal.cs_nbfree--;

	return (d);
}

/*
 * Here  we check if all frags of a block are free. For more details  again
 * please see the source of newfs(8), as this function is taken over almost
 * unchanged.
 */
static int
isblock(struct fs *fs, unsigned char *cp, int h)
{
	unsigned char	mask;

	switch (fs->fs_frag) {
	case 8:
		return (cp[h] == 0xff);
	case 4:
		mask = 0x0f << ((h & 0x1) << 2);
		return ((cp[h >> 1] & mask) == mask);
	case 2:
		mask = 0x03 << ((h & 0x3) << 1);
		return ((cp[h >> 2] & mask) == mask);
	case 1:
		mask = 0x01 << (h & 0x7);
		return ((cp[h >> 3] & mask) == mask);
	default:
		fprintf(stderr, "isblock bad fs_frag %d\n", fs->fs_frag);
		return (0);
	}
}

/*
 * Here we allocate a complete block in the block map. For more details again
 * please  see the source of newfs(8), as this function is taken over  almost
 * unchanged.
 */
static void
clrblock(struct fs *fs, unsigned char *cp, int h)
{
	switch ((fs)->fs_frag) {
	case 8:
		cp[h] = 0;
		break;
	case 4:
		cp[h >> 1] &= ~(0x0f << ((h & 0x1) << 2));
		break;
	case 2:
		cp[h >> 2] &= ~(0x03 << ((h & 0x3) << 1));
		break;
	case 1:
		cp[h >> 3] &= ~(0x01 << (h & 0x7));
		break;
	default:
		warnx("clrblock bad fs_frag %d", fs->fs_frag);
		break;
	}
}

/*
 * Here we free a complete block in the free block map. For more details again
 * please  see the source of newfs(8), as this function is taken  over  almost
 * unchanged.
 */
static void
setblock(struct fs *fs, unsigned char *cp, int h)
{
	switch (fs->fs_frag) {
	case 8:
		cp[h] = 0xff;
		break;
	case 4:
		cp[h >> 1] |= (0x0f << ((h & 0x1) << 2));
		break;
	case 2:
		cp[h >> 2] |= (0x03 << ((h & 0x3) << 1));
		break;
	case 1:
		cp[h >> 3] |= (0x01 << (h & 0x7));
		break;
	default:
		warnx("setblock bad fs_frag %d", fs->fs_frag);
		break;
	}
}

/*
 * This function provides access to an individual inode. We find out in which
 * block  the  requested inode is located, read it from disk if  needed,  and
 * return  the pointer into that block. We maintain a cache of one  block  to
 * not  read the same block again and again if we iterate linearly  over  all
 * inodes.
 */
static union dinode *
ginode(ino_t inumber, int fsi, int cg)
{
	static ino_t	startinum = 0;	/* first inode in cached block */

	/*
	 * The inumber passed in is relative to the cg, so use it here to see
	 * if the inode has been allocated yet.
	 */
	if (isclr(cg_inosused(&aocg), inumber)) {
		return NULL;
	}
	/*
	 * Now make the inumber relative to the entire inode space so it can
	 * be sanity checked.
	 */
	inumber += (cg * sblock.fs_ipg);
	if (inumber < ROOTINO) {
		return NULL;
	}
	if (inumber > maxino)
		errx(8, "bad inode number %llu to ginode",
		    (unsigned long long)inumber);
	if (startinum == 0 ||
	    inumber < startinum || inumber >= startinum + INOPB(&sblock)) {
		inoblk = fsbtodb(&sblock, ino_to_fsba(&sblock, inumber));
		rdfs(inoblk, (size_t)sblock.fs_bsize, inobuf, fsi);
		startinum = (inumber / INOPB(&sblock)) * INOPB(&sblock);
	}
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		return (union dinode *)((uintptr_t)inobuf +
		    (inumber % INOPB(&sblock)) * sizeof(struct ufs1_dinode));
	return (union dinode *)((uintptr_t)inobuf +
	    (inumber % INOPB(&sblock)) * sizeof(struct ufs2_dinode));
}

/*
 * Figure out how many lines our current terminal has. For more details again
 * please see the source of newfs(8), as this function is taken over almost
 * unchanged.
 */
static int
charsperline(void)
{
	int	columns;
	char	*cp;
	struct winsize	ws;

	columns = 0;
	if ((cp = getenv("COLUMNS")) != NULL)
		columns = strtonum(cp, 1, INT_MAX, NULL);
	if (columns == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 &&
	    ws.ws_col > 0)
		columns = ws.ws_col;
	if (columns == 0)
		columns = 80;

	return columns;
}

/*
 * growfs(8) is a utility which allows to increase the size of an existing
 * ufs filesystem. Currently this can only be done on unmounted file system.
 * It recognizes some command line options to specify the new desired size,
 * and it does some basic checkings. The old filesystem size is determined
 * and after some more checks like we can really access the new last block
 * on the disk etc. we calculate the new parameters for the superblock. After
 * having done this we just call growfs() which will do the work. Before
 * we finish the only thing left is to update the disklabel.
 * We still have to provide support for snapshots. Therefore we first have to
 * understand what data structures are always replicated in the snapshot on
 * creation, for all other blocks we touch during our procedure, we have to
 * keep the old blocks unchanged somewhere available for the snapshots. If we
 * are lucky, then we only have to handle our blocks to be relocated in that
 * way.
 * Also we have to consider in what order we actually update the critical
 * data structures of the filesystem to make sure, that in case of a disaster
 * fsck(8) is still able to restore any lost data.
 * The foreseen last step then will be to provide for growing even mounted
 * file systems. There we have to extend the mount() system call to provide
 * userland access to the filesystem locking facility.
 */
int
main(int argc, char **argv)
{
	char	*device, *lastsector;
	int	ch;
	long long	size = 0;
	unsigned int	Nflag = 0;
	int	ExpertFlag = 0;
	struct stat	st;
	struct disklabel	*lp;
	struct partition	*pp;
	int	i, fsi, fso;
	char	reply[5];
	const char *errstr;
#ifdef FSMAXSNAP
	int	j;
#endif /* FSMAXSNAP */

	while ((ch = getopt(argc, argv, "Nqs:vy")) != -1) {
		switch (ch) {
		case 'N':
			Nflag = 1;
			break;
		case 'q':
			quiet = 1;
			break;
		case 's':
			size = strtonum(optarg, 1, LLONG_MAX, &errstr);
			if (errstr)
				usage();
			break;
		case 'v': /* for compatibility to newfs */
			break;
		case 'y':
			ExpertFlag = 1;
			break;
		case '?':
			/* FALLTHROUGH */
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	colwidth = charsperline();

	/*
	 * Rather than guessing, use opendev() to get the device
	 * name, which we open for reading.
	 */
	if ((fsi = opendev(*argv, O_RDONLY, 0, &device)) < 0)
		err(1, "%s", *argv);

	/*
	 * Try to access our devices for writing ...
	 */
	if (Nflag) {
		fso = -1;
	} else {
		fso = open(device, O_WRONLY);
		if (fso < 0)
			err(1, "%s", device);
	}

	/*
	 * Now we have a file descriptor for our device, fstat() it to
	 * figure out the partition number.
	 */
	if (fstat(fsi, &st) != 0)
		err(1, "%s: fstat()", device);

	/*
	 * Try to read a label from the disk. Then get the partition from the
	 * device minor number, using DISKPART(). Probably don't need to
	 * check against getmaxpartitions().
	 */
	lp = get_disklabel(fsi);
	if (DISKPART(st.st_rdev) < getmaxpartitions())
		pp = &lp->d_partitions[DISKPART(st.st_rdev)];
	else
		errx(1, "%s: invalid partition number %u",
		    device, DISKPART(st.st_rdev));

	if (pledge("stdio disklabel", NULL) == -1)
		err(1, "pledge");

	/*
	 * Check if that partition is suitable for growing a file system.
	 */
	if (DL_GETPSIZE(pp) < 1)
		errx(1, "partition is unavailable");
	if (pp->p_fstype != FS_BSDFFS)
		errx(1, "can only grow ffs partitions");

	/*
	 * Read the current superblock, and take a backup.
	 */
	for (i = 0; sblock_try[i] != -1; i++) {
		sblockloc = sblock_try[i] / DEV_BSIZE;
		rdfs(sblockloc, (size_t)SBLOCKSIZE, (void *)&(osblock), fsi);
		if ((osblock.fs_magic == FS_UFS1_MAGIC ||
		     (osblock.fs_magic == FS_UFS2_MAGIC &&
		      osblock.fs_sblockloc == sblock_try[i])) &&
		    osblock.fs_bsize <= MAXBSIZE &&
		    osblock.fs_bsize >= (int32_t) sizeof(struct fs))
			break;
	}
	if (sblock_try[i] == -1)
		errx(1, "superblock not recognized");
	if (osblock.fs_clean == 0)
		errx(1, "filesystem not clean - run fsck");
	if (sblock.fs_magic == FS_UFS1_MAGIC &&
	    (sblock.fs_ffs1_flags & FS_FLAGS_UPDATED) == 0)
		ffs1_sb_update(&sblock, sblock_try[i]);
	memcpy(&fsun1, &fsun2, sizeof(fsun2));
	maxino = sblock.fs_ncg * sblock.fs_ipg;

	/*
	 * Determine size to grow to. Default to the full size specified in
	 * the disk label.
	 */
	sblock.fs_size = dbtofsb(&osblock, DL_SECTOBLK(lp, DL_GETPSIZE(pp)));
	if (size != 0) {
		if (size > DL_GETPSIZE(pp)) {
			errx(1, "there is not enough space (%llu < %lld)",
			    DL_GETPSIZE(pp), size);
		}
		sblock.fs_size = dbtofsb(&osblock, DL_SECTOBLK(lp, size));
	}

	/*
	 * Are we really growing ?
	 */
	if (osblock.fs_size >= sblock.fs_size) {
		errx(1, "we are not growing (%jd->%jd)",
		    (intmax_t)osblock.fs_size, (intmax_t)sblock.fs_size);
	}


#ifdef FSMAXSNAP
	/*
	 * Check if we find an active snapshot.
	 */
	if (ExpertFlag == 0) {
		for (j = 0; j < FSMAXSNAP; j++) {
			if (sblock.fs_snapinum[j]) {
				errx(1, "active snapshot found in filesystem\n"
				    "	please remove all snapshots before "
				    "using growfs");
			}
			if (!sblock.fs_snapinum[j])	/* list is dense */
				break;
		}
	}
#endif

	if (ExpertFlag == 0 && Nflag == 0) {
		printf("We strongly recommend you to make a backup "
		    "before growing the Filesystem\n\n"
		    " Did you backup your data (Yes/No) ? ");
		if (fgets(reply, (int)sizeof(reply), stdin) == NULL ||
		    strncasecmp(reply, "Yes", 3)) {
			printf("\n Nothing done \n");
			exit (0);
		}
	}

	if (!quiet)
		printf("new filesystem size is: %jd frags\n",
		    (intmax_t)sblock.fs_size);

	/*
	 * Try to access our new last sector in the filesystem. Even if we
	 * later on realize we have to abort our operation, on that sector
	 * there should be no data, so we can't destroy something yet.
	 */
	lastsector = calloc(1, lp->d_secsize);
	if (!lastsector)
		err(1, "No memory for last sector test write");
	wtfs(DL_SECTOBLK(lp, DL_GETPSIZE(pp) - 1), lp->d_secsize,
	    lastsector, fso, Nflag);
	free(lastsector);

	/*
	 * Now calculate new superblock values and check for reasonable
	 * bound for new filesystem size:
	 *     fs_size:    is derived from label or user input
	 *     fs_dsize:   should get updated in the routines creating or
	 *                 updating the cylinder groups on the fly
	 *     fs_cstotal: should get updated in the routines creating or
	 *                 updating the cylinder groups
	 */

	/*
	 * Update the number of cylinders and cylinder groups in the file system.
	 */
	if (sblock.fs_magic == FS_UFS1_MAGIC) {
		sblock.fs_ncyl = sblock.fs_size * NSPF(&sblock) / sblock.fs_spc;
		if (sblock.fs_size * NSPF(&sblock) >
		    sblock.fs_ncyl * sblock.fs_spc)
		sblock.fs_ncyl++;
	}
	sblock.fs_ncg = howmany(sblock.fs_size, sblock.fs_fpg);
	maxino = sblock.fs_ncg * sblock.fs_ipg;

	if (sblock.fs_size % sblock.fs_fpg != 0 &&
	    sblock.fs_size % sblock.fs_fpg < cgdmin(&sblock, sblock.fs_ncg)) {
		/*
		 * The space in the new last cylinder group is too small,
		 * so revert back.
		 */
		sblock.fs_ncg--;
		if (sblock.fs_magic == FS_UFS1_MAGIC)
			sblock.fs_ncyl = sblock.fs_ncg * sblock.fs_cpg;
		if (!quiet)
			printf("Warning: %jd sector(s) cannot be allocated.\n",
			    (intmax_t)fsbtodb(&sblock,
			    sblock.fs_size % sblock.fs_fpg));
		sblock.fs_size = sblock.fs_ncg * sblock.fs_fpg;
	}

	/*
	 * Update the space for the cylinder group summary information in the
	 * respective cylinder group data area.
	 */
	sblock.fs_cssize =
	    fragroundup(&sblock, sblock.fs_ncg * sizeof(struct csum));

	if (osblock.fs_size >= sblock.fs_size)
		errx(1, "not enough new space");

	/*
	 * Ok, everything prepared, so now let's do the tricks.
	 */
	growfs(fsi, fso, Nflag);

	/*
	 * Update the disk label.
	 */
	pp->p_fragblock =
	    DISKLABELV1_FFS_FRAGBLOCK(sblock.fs_fsize, sblock.fs_frag);
	pp->p_cpg = sblock.fs_fpg;

	return_disklabel(fso, lp, Nflag);

	close(fsi);
	if (fso > -1)
		close(fso);

	return 0;
}

/*
 * Write the updated disklabel back to disk.
 */
static void
return_disklabel(int fd, struct disklabel *lp, unsigned int Nflag)
{
	u_short	sum;
	u_short	*ptr;

	if (!lp)
		return;

	if (!Nflag) {
		lp->d_checksum = 0;
		sum = 0;
		ptr = (u_short *)lp;

		/*
		 * recalculate checksum
		 */
		while (ptr < (u_short *)&lp->d_partitions[lp->d_npartitions])
			sum ^= *ptr++;
		lp->d_checksum = sum;

		if (ioctl(fd, DIOCWDINFO, (char *)lp) < 0)
			errx(1, "DIOCWDINFO failed");
	}
	free(lp);

	return ;
}

/*
 * Read the disklabel from disk.
 */
static struct disklabel *
get_disklabel(int fd)
{
	static struct	disklabel *lab;

	lab = malloc(sizeof(struct disklabel));
	if (!lab)
		errx(1, "malloc failed");
	if (ioctl(fd, DIOCGDINFO, (char *)lab) != 0)
		err(1, "DIOCGDINFO");

	return (lab);
}


/*
 * Dump a line of usage.
 */
static void
usage(void)
{
	fprintf(stderr, "usage: growfs [-Nqy] [-s size] special\n");
	exit(1);
}

/*
 * This updates most parameters and the bitmap related to cluster. We have to
 * assume that sblock, osblock, acg are set up.
 */
static void
updclst(int block)
{
	static int	lcs = 0;

	if (sblock.fs_contigsumsize < 1)	/* no clustering */
		return;

	/*
	 * update cluster allocation map
	 */
	setbit(cg_clustersfree(&acg), block);

	/*
	 * update cluster summary table
	 */
	if (!lcs) {
		/*
		 * calculate size for the trailing cluster
		 */
		for (block--; lcs < sblock.fs_contigsumsize; block--, lcs++) {
			if (isclr(cg_clustersfree(&acg), block))
				break;
		}
	}
	if (lcs < sblock.fs_contigsumsize) {
		if (lcs)
			cg_clustersum(&acg)[lcs]--;
		lcs++;
		cg_clustersum(&acg)[lcs]++;
	}
}

/*
 * This updates all references to relocated blocks for the given inode.  The
 * inode is given as number within the cylinder group, and the number of the
 * cylinder group.
 */
static void
updrefs(int cg, ino_t in, struct gfs_bpp *bp, int fsi, int fso, unsigned int
    Nflag)
{
	daddr_t	len, lbn, numblks;
	daddr_t	iptr, blksperindir;
	union dinode	*ino;
	int		i, mode, inodeupdated;

	ino = ginode(in, fsi, cg);
	if (ino == NULL)
		return;

	mode = DIP(ino, di_mode) & IFMT;
	if (mode != IFDIR && mode != IFREG && mode != IFLNK)
		return; /* only check DIR, FILE, LINK */
	if (mode == IFLNK &&
	    DIP(ino, di_size) < (u_int64_t) sblock.fs_maxsymlinklen)
		return;	/* skip short symlinks */
	numblks = howmany(DIP(ino, di_size), sblock.fs_bsize);
	if (numblks == 0)
		return;	/* skip empty file */
	if (DIP(ino, di_blocks) == 0)
		return;	/* skip empty swiss cheesy file or old fastlink */

	/*
	 * Check all the blocks.
	 */
	inodeupdated = 0;
	len = numblks < NDADDR ? numblks : NDADDR;
	for (i = 0; i < len; i++) {
		iptr = DIP(ino, di_db[i]);
		if (iptr == 0)
			continue;
		if (cond_bl_upd(&iptr, bp, fsi, fso, Nflag)) {
			DIP_SET(ino, di_db[i], iptr);
			inodeupdated++;
		}
	}

	blksperindir = 1;
	len = numblks - NDADDR;
	lbn = NDADDR;
	for (i = 0; len > 0 && i < NIADDR; i++) {
		iptr = DIP(ino, di_ib[i]);
		if (iptr == 0)
			continue;
		if (cond_bl_upd(&iptr, bp, fsi, fso, Nflag)) {
			DIP_SET(ino, di_ib[i], iptr);
			inodeupdated++;
		}
		indirchk(blksperindir, lbn, iptr, numblks, bp, fsi, fso, Nflag);
		blksperindir *= NINDIR(&sblock);
		lbn += blksperindir;
		len -= blksperindir;
	}
	if (inodeupdated)
		wtfs(inoblk, sblock.fs_bsize, inobuf, fso, Nflag);
}

/*
 * Recursively check all the indirect blocks.
 */
static void
indirchk(daddr_t blksperindir, daddr_t lbn, daddr_t blkno,
    daddr_t lastlbn, struct gfs_bpp *bp, int fsi, int fso, unsigned int Nflag)
{
	void *ibuf;
	int i, last;
	daddr_t iptr;

	/* read in the indirect block. */
	ibuf = malloc(sblock.fs_bsize);
	if (!ibuf)
		errx(1, "malloc failed");
	rdfs(fsbtodb(&sblock, blkno), (size_t)sblock.fs_bsize, ibuf, fsi);
	last = howmany(lastlbn - lbn, blksperindir) < NINDIR(&sblock) ?
	    howmany(lastlbn - lbn, blksperindir) : NINDIR(&sblock);
	for (i = 0; i < last; i++) {
		if (sblock.fs_magic == FS_UFS1_MAGIC)
			iptr = ((int32_t *)ibuf)[i];
		else
			iptr = ((daddr_t *)ibuf)[i];
		if (iptr == 0)
			continue;
		if (cond_bl_upd(&iptr, bp, fsi, fso, Nflag)) {
			if (sblock.fs_magic == FS_UFS1_MAGIC)
				((int32_t *)ibuf)[i] = iptr;
			else
				((daddr_t *)ibuf)[i] = iptr;
		}
		if (blksperindir == 1)
			continue;
		indirchk(blksperindir / NINDIR(&sblock), lbn + blksperindir * i,
		    iptr, lastlbn, bp, fsi, fso, Nflag);
	}
	free(ibuf);
}

static void
ffs1_sb_update(struct fs *fs, daddr_t sbloc)
{
	fs->fs_flags = fs->fs_ffs1_flags;
	fs->fs_sblockloc = sbloc;
	fs->fs_maxbsize = fs->fs_bsize;
	fs->fs_time = fs->fs_ffs1_time;
	fs->fs_size = fs->fs_ffs1_size;
	fs->fs_dsize = fs->fs_ffs1_dsize;
	fs->fs_csaddr = fs->fs_ffs1_csaddr;
	fs->fs_cstotal.cs_ndir = fs->fs_ffs1_cstotal.cs_ndir;
	fs->fs_cstotal.cs_nbfree = fs->fs_ffs1_cstotal.cs_nbfree;
	fs->fs_cstotal.cs_nifree = fs->fs_ffs1_cstotal.cs_nifree;
	fs->fs_cstotal.cs_nffree = fs->fs_ffs1_cstotal.cs_nffree;
	fs->fs_ffs1_flags |= FS_FLAGS_UPDATED;
}
@


1.50
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.49 2016/01/29 11:50:40 tb Exp $	*/
a1769 3
	if (pledge("stdio disklabel", NULL) == -1)
		err(1, "pledge");

d1788 3
@


1.49
log
@Therefor -> Therefore (where appropriate)

from ray@@, ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.48 2015/11/28 19:59:15 deraadt Exp $	*/
d1669 4
a1672 1
	if (ioctl(0, TIOCGWINSZ, &ws) != -1) {
d1674 2
a1675 7
	}
	if (columns == 0 && (cp = getenv("COLUMNS"))) {
		columns = strtonum(cp, 1, INT_MAX, NULL);
	}
	if (columns == 0) {
		columns = 80;	/* last resort */
	}
@


1.48
log
@hoist TIOCGWINSZ code upwards, and pledge "stdio disklabel" at the
right place.
tested by mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.47 2015/11/27 17:27:01 deraadt Exp $	*/
d303 1
a303 1
	 * system were created initially with the new size. Therefor we  still
@


1.47
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.46 2015/11/23 18:35:18 mmcc Exp $	*/
d154 2
a172 1
	int	width;
a215 1
	width = charsperline();
d229 1
a229 1
		if (j == -1 || i + j >= width) {
d1752 2
d1771 3
@


1.46
log
@Remove the debugging infrastructure, which was ~1/3 of the code. Makes
pledging easier, and it was excessive complicated stuff.

"Good." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.45 2015/11/20 17:37:08 mmcc Exp $	*/
d112 1
a112 1
static daddr_t 	inoblk;			/* inode block address */
d436 1
a436 1
	     d += sblock.fs_frag) {
d502 1
a502 1
		}  
d510 1
a510 1
		     i += sblock.fs_frag) {
d1121 1
a1121 1
 	bp = calloc(((dupper-odupper) / sblock.fs_frag + 2),
d1715 1
a1715 1
	int	i,fsi,fso;
d1944 1
a1944 1
        pp->p_cpg = sblock.fs_fpg;
@


1.45
log
@De-justify more comments. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.44 2015/11/20 17:31:20 mmcc Exp $	*/
a69 2
#include "debug.h"

a72 4
#ifdef FS_DEBUG
int	_dbg_lvl_ = (DL_INFO);	/* DL_TRC */
#endif /* FS_DEBUG */

a167 1
	DBG_FUNC("growfs")
a173 2
	DBG_ENTER;

a187 16
#ifdef FS_DEBUG
{
	struct csum	*dbg_csp;
	int	dbg_csc;
	char	dbg_line[80];

	dbg_csp = fscs;
	for (dbg_csc = 0; dbg_csc < osblock.fs_ncg; dbg_csc++) {
		snprintf(dbg_line, sizeof(dbg_line),
		    "%d. old csum in old location", dbg_csc);
		DBG_DUMP_CSUM(&osblock, dbg_line, dbg_csp++);
	}
}
#endif /* FS_DEBUG */
	DBG_PRINT0("fscs read\n");

a253 16
	DBG_PRINT0("fscs written\n");

#ifdef FS_DEBUG
{
	struct csum	*dbg_csp;
	int	dbg_csc;
	char	dbg_line[80];

	dbg_csp = fscs;
	for (dbg_csc = 0; dbg_csc < sblock.fs_ncg; dbg_csc++) {
		snprintf(dbg_line, sizeof(dbg_line),
		    "%d. new csum in new location", dbg_csc);
		DBG_DUMP_CSUM(&sblock, dbg_line, dbg_csp++);
	}
}
#endif /* FS_DEBUG */
a274 2
	DBG_PRINT0("sblock written\n");
	DBG_DUMP_FS(&sblock, "new initial sblock");
a316 4
	DBG_PRINT0("sblock copies written\n");
	DBG_DUMP_FS(&sblock, "new other sblocks");

	DBG_LEAVE;
a327 1
	DBG_FUNC("initcg")
a519 4

	DBG_DUMP_CG(&sblock, "new cg", &acg);

	DBG_LEAVE;
a530 1
	DBG_FUNC("frag_adjust")
a533 2
	DBG_ENTER;

a552 2
				DBG_PRINT2("frag_adjust [%d]+=%d\n", fragsize,
				    sign);
a561 1
		DBG_PRINT2("frag_adjust [%d]+=%d\n", fragsize, sign);
a562 3
	DBG_PRINT2("frag_adjust [[%d]]+=%d\n", fragsize, sign);

	DBG_LEAVE;
a576 1
	DBG_FUNC("cond_bl_upd")
a581 2
	DBG_ENTER;

a592 2
		DBG_PRINT3("scg (%jd->%jd)[%d] reference updated\n",
		    (intmax_t)f->old, (intmax_t)f->new, fragnum);
a613 1
	DBG_LEAVE;
a630 1
	DBG_FUNC("updjcg")
a635 2
	DBG_ENTER;

a641 2
	DBG_PRINT0("jcg read\n");
	DBG_DUMP_CG(&sblock, "old joining cg", &aocg);
a657 2
		DBG_PRINT0("jcg written\n");
		DBG_DUMP_CG(&sblock, "new joining cg", &acg);
a658 1
		DBG_LEAVE;
a692 6
	DBG_PRINT2("jcg dbg: %d %u", cylno, sblock.fs_ncg);
#ifdef FS_DEBUG
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		DBG_PRINT2("%d %u", acg.cg_ncyl, sblock.fs_cpg);
#endif
	DBG_PRINT0("\n");
a734 1
				DBG_PRINT0("block was\n");
a826 4
	DBG_PRINT0("jcg written\n");
	DBG_DUMP_CG(&sblock, "new joining cg", &acg);

	DBG_LEAVE;
a847 1
	DBG_FUNC("updcsloc")
a858 2
	DBG_ENTER;

a863 1
		DBG_LEAVE;
a878 2
	DBG_PRINT0("oscg read\n");
	DBG_DUMP_CG(&sblock, "old summary cg", &aocg);
a913 1
		DBG_TRC;
a941 1
		DBG_PRINT1("d=%jd\n", (intmax_t)d);
a946 1
			DBG_TRC;
a948 1
				DBG_PRINT1("d=%jd\n", (intmax_t)d);
a961 1
				DBG_PRINT1("d=%jd\n", (intmax_t)d);
a985 1
		DBG_PRINT1("d=%jd\n", (intmax_t)d);
a987 2
			DBG_TRC;
			DBG_PRINT1("d=%d\n", d);
a1014 2
		DBG_PRINT0("oscg written\n");
		DBG_DUMP_CG(&sblock, "old summary cg", &acg);
d1030 1
a1030 3
		if (Nflag) {
			DBG_PRINT0("nscg update skipped\n");
			DBG_LEAVE;
a1031 1
		}
a1038 2
		DBG_PRINT0("nscg read\n");
		DBG_DUMP_CG(&sblock, "new summary cg", &aocg);
a1102 4
		DBG_PRINT0("nscg written\n");
		DBG_DUMP_CG(&sblock, "new summary cg", &acg);

		DBG_LEAVE;
a1109 2
	DBG_TRC;

a1136 1
		DBG_PRINT1("scg first frag check loop d=%jd\n", (intmax_t)d);
a1163 1
		DBG_PRINT1("scg block check loop d=%jd\n", (intmax_t)d);
a1226 2
			DBG_PRINT1("scg second frag check loop d=%jd\n",
			    (intmax_t)d);
a1331 5
			DBG_DUMP_HEX(&sblock, "copied full block",
			    (unsigned char *)&ablk);

			DBG_PRINT2("scg (%jd->%jd) block relocated\n",
			    (intmax_t)bp[i].old, (intmax_t)bp[i].new);
a1340 1
			DBG_PRINT1("scg doing cg (%d)\n", cylno);
a1375 4
	DBG_PRINT0("scg written\n");
	DBG_DUMP_CG(&sblock, "new summary cg", &acg);

	DBG_LEAVE;
a1383 1
	DBG_FUNC("rdfs")
a1385 2
	DBG_ENTER;

a1395 2

	DBG_LEAVE;
a1403 1
	DBG_FUNC("wtfs")
d1406 2
a1407 1
	DBG_ENTER;
d1409 1
a1409 5
	if (Nflag) {
		DBG_LEAVE;
		return;
	}
	if (lseek(fso, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0) {
a1410 1
	}
d1412 1
a1412 1
	if (n != (ssize_t)size) {
a1413 3
	}

	DBG_LEAVE;
a1423 1
	DBG_FUNC("alloc")
a1429 2
	DBG_ENTER;

a1431 1
		DBG_LEAVE;
a1435 1
		DBG_LEAVE;
a1453 2
	DBG_PRINT3("seek range: dl=%d, du=%d, dm=%d\n", dlower, dupper, dmax);
	DBG_PRINT2("range cont: csmin=%d, csmax=%d\n", csmin, csmax);
a1476 1
		DBG_LEAVE;
a1527 1
	DBG_LEAVE;
a1538 1
	DBG_FUNC("isblock")
a1540 2
	DBG_ENTER;

a1542 1
		DBG_LEAVE;
a1545 1
		DBG_LEAVE;
a1548 1
		DBG_LEAVE;
a1551 1
		DBG_LEAVE;
a1554 1
		DBG_LEAVE;
a1566 4
	DBG_FUNC("clrblock")

	DBG_ENTER;

a1583 2

	DBG_LEAVE;
a1593 4
	DBG_FUNC("setblock")

	DBG_ENTER;

a1610 2

	DBG_LEAVE;
a1622 1
	DBG_FUNC("ginode")
a1624 2
	DBG_ENTER;

a1629 1
		DBG_LEAVE;
a1637 1
		DBG_LEAVE;
a1648 1
	DBG_LEAVE;
a1663 1
	DBG_FUNC("charsperline")
a1667 2
	DBG_ENTER;

a1678 1
	DBG_LEAVE;
a1706 1
	DBG_FUNC("main")
a1721 2
	DBG_ENTER;

a1819 3
	DBG_OPEN("/tmp/growfs.debug"); /* already here we need a superblock */
	DBG_DUMP_FS(&sblock, "old sblock");

a1933 2
	DBG_PRINT0("sblock calculated\n");

a1946 1
	DBG_PRINT0("label rewritten\n");
a1951 3
	DBG_CLOSE;

	DBG_LEAVE;
a1960 1
	DBG_FUNC("return_disklabel")
d1964 2
a1965 1
	DBG_ENTER;
a1966 4
	if (!lp) {
		DBG_LEAVE;
		return;
	}
a1983 1
	DBG_LEAVE;
a1992 1
	DBG_FUNC("get_disklabel")
a1994 2
	DBG_ENTER;

a2000 1
	DBG_LEAVE;
a2010 4
	DBG_FUNC("usage")

	DBG_ENTER;

a2011 2

	DBG_LEAVE;
a2021 1
	DBG_FUNC("updclst")
a2023 2
	DBG_ENTER;

a2049 2

	DBG_LEAVE;
a2060 1
	DBG_FUNC("updrefs")
a2065 2
	DBG_ENTER;

d2067 1
a2067 2
	if (ino == NULL) {
		DBG_LEAVE;
d2069 1
a2069 1
	}
d2071 1
a2071 2
	if (mode != IFDIR && mode != IFREG && mode != IFLNK) {
		DBG_LEAVE;
a2072 1
	}
d2074 1
a2074 2
	    DIP(ino, di_size) < (u_int64_t) sblock.fs_maxsymlinklen) {
		DBG_LEAVE;
a2075 1
	}
d2077 1
a2077 2
	if (numblks == 0) {
		DBG_LEAVE;
d2079 1
a2079 3
	}
	if (DIP(ino, di_blocks) == 0) {
		DBG_LEAVE;
a2080 3
	}
	DBG_PRINT2("scg checking inode (%llu in %d)\n",
	    (unsigned long long)in, cg);
a2095 1
	DBG_PRINT0("~~scg direct blocks checked\n");
a2111 1
		DBG_PRINT1("scg indirect_%d blocks checked\n", i + 1);
a2114 2

	DBG_LEAVE;
a2123 1
	DBG_FUNC("indirchk")
a2127 2
	DBG_ENTER;

a2153 2

	DBG_LEAVE;
@


1.44
log
@Monospace comments are not meant to be justified. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.43 2015/11/19 17:46:46 mmcc Exp $	*/
d123 1
a123 1
 * An  array of elements of type struct gfs_bpp describes all blocks  to
d161 3
a163 3
 * Here  we actually start growing the filesystem. We basically  read  the
 * cylinder  summary  from the first cylinder group as we want  to  update
 * this  on  the fly during our various operations. First  we  handle  the
d165 3
a167 3
 * cylinder  groups.  Now  we handle the  cylinder  group  containing  the
 * cylinder  summary  which  might result in a  relocation  of  the  whole
 * structure.  In the end we write back the updated cylinder summary,  the
d1833 1
a1833 1
 * please  see the source of newfs(8), as this function is taken over  almost
d1960 2
a1961 2
	 * Try to read a label from the disk.  Then get the partition from the
	 * device minor number, using DISKPART().  Probably don't need to
@


1.43
log
@Remove some weird comments containing only the name of the next function.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.42 2015/11/19 17:40:28 mmcc Exp $	*/
d1862 5
a1866 5
 * growfs(8)  is a utility which allows to increase the size of  an  existing
 * ufs filesystem. Currently this can only be done on unmounted file  system.
 * It  recognizes some command line options to specify the new desired  size,
 * and  it does some basic checkings. The old filesystem size is  determined
 * and  after some more checks like we can really access the new  last  block
d1868 1
a1868 1
 * having  done  this we just call growfs() which will do  the  work.  Before
d1871 2
a1872 2
 * understand  what data structures are always replicated in the snapshot  on
 * creation,  for all other blocks we touch during our procedure, we have  to
d1874 1
a1874 1
 * are lucky, then we only have to handle our blocks to be relocated in  that
d1876 1
a1876 1
 * Also  we  have to consider in what order we actually update  the  critical
d1879 2
a1880 2
 * The  foreseen last step then will be to provide for growing  even  mounted
 * file  systems. There we have to extend the mount() system call to  provide
@


1.42
log
@Don't bother casting memset() argument to void*. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.41 2015/11/19 17:30:41 mmcc Exp $	*/
a43 1
/* ********************************************************** INCLUDES ***** */
a74 1
/* *************************************************** GLOBALS & TYPES ***** */
a135 1
/* ******************************************************** PROTOTYPES ***** */
a159 1
/* ************************************************************ growfs ***** */
a365 1
/* ************************************************************ initcg ***** */
a573 1
/* ******************************************************* frag_adjust ***** */
a625 1
/* ******************************************************* cond_bl_upd ***** */
a683 1
/* ************************************************************ updjcg ***** */
a914 1
/* ********************************************************** updcsloc ***** */
a1504 1
/* ************************************************************** rdfs ***** */
a1529 1
/* ************************************************************** wtfs ***** */
a1555 1
/* ************************************************************* alloc ***** */
a1679 1
/* *********************************************************** isblock ***** */
a1715 1
/* ********************************************************** clrblock ***** */
a1748 1
/* ********************************************************** setblock ***** */
a1781 1
/* ************************************************************ ginode ***** */
a1830 1
/* ****************************************************** charsperline ***** */
a1860 1
/* ************************************************************** main ***** */
a2145 1
/* ************************************************** return_disklabel ***** */
a2182 1
/* ***************************************************** get_disklabel ***** */
a2204 1
/* ************************************************************* usage ***** */
a2220 1
/* *********************************************************** updclst ***** */
a2262 1
/* *********************************************************** updrefs ***** */
@


1.41
log
@calloc((size_t)1, ...) -> calloc(1, ...)
No binary change (for real this time).
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.40 2015/08/20 22:02:21 deraadt Exp $	*/
d331 1
a331 1
	memset((void *)&sblock.fs_fsmnt, 0, sizeof(sblock.fs_fsmnt));
@


1.40
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.39 2015/04/18 18:28:37 deraadt Exp $	*/
d192 1
a192 1
	fscs = calloc((size_t)1, (size_t)sblock.fs_cssize);
@


1.39
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.38 2015/01/20 18:22:21 deraadt Exp $	*/
d1243 1
a1243 1
 	bp = (struct gfs_bpp *)calloc(((dupper-odupper) / sblock.fs_frag + 2),
d2214 1
a2214 1
	lab = (struct disklabel *)malloc(sizeof(struct disklabel));
@


1.38
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.37 2015/01/16 06:39:58 deraadt Exp $	*/
d1868 1
a1868 1
		columns = atoi(cp);
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.36 2014/05/15 19:18:23 chl Exp $	*/
d45 1
a45 1
#include <sys/param.h>	/* DEV_BSIZE MAXFRAG MAXBSIZE setbit isset isclr clrbit */
@


1.36
log
@- typo in comment
- memset() is not needed after a calloc()
- add missing DBG_ENTER;
- use SEEK_SET instead of 0 in an lseek() call

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.35 2014/05/05 15:04:05 krw Exp $	*/
d45 2
a46 1
#include <sys/param.h>
d68 3
d197 1
a197 1
		    numfrags(&osblock, i)), (size_t)MIN(osblock.fs_cssize - i,
d280 1
a280 1
		    (size_t)MIN(sblock.fs_cssize - i, sblock.fs_bsize),
d418 1
a418 1
	acg.cg_initediblk = MIN(sblock.fs_ipg, 2 * INOPB(&sblock));
d548 1
a548 1
	for (i = MIN(sblock.fs_ipg, 2 * INOPB(&sblock)); i != 0; i--) {
d1676 1
a1676 1
		cg_clustersum(&acg)[MIN(lcs1 + lcs2 + 1, sblock.fs_contigsumsize)]--;
@


1.35
log
@"new file systemsize is" -> "new filesystem size is".

From David Vasek.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.34 2014/04/30 14:28:48 krw Exp $	*/
d666 1
a666 1
		 * XXX	If src is is from an indirect block we have
a1242 2
	memset((char *)bp, 0, ((dupper-odupper) / sblock.fs_frag + 2) *
	    sizeof(struct gfs_bpp));
d1520 1
d1525 1
a1525 1
	if (lseek(fsi, (off_t)bno * DEV_BSIZE, 0) < 0) {
@


1.34
log
@Write last disk sector, not last 512-byte block, when testing validity
of new partition limit.

Fixes growfs on 4K-sector disks.

Reported by and fix tested by David Vasek via misc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.33 2013/11/10 00:48:04 krw Exp $	*/
d2071 1
a2071 1
		printf("new file systemsize is: %jd frags\n",
@


1.33
log
@Don't use p_size as if it was the full partition size, and don't
assume the disk sector size is 512-bytes. Use DL_GETPSIZE() to get
correct partition sizes and DL_SECTOBLK() to turn disk sector values
into 512-byte-block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.32 2013/11/09 15:53:20 krw Exp $	*/
d1902 1
a1902 1
	char	*device;
d2075 2
a2076 2
	 * Try to access our new last block in the filesystem. Even if we
	 * later on realize we have to abort our operation, on that block
d2079 6
a2084 2
	wtfs(DL_SECTOBLK(lp, DL_GETPSIZE(pp)) - 1, (size_t)DEV_BSIZE,
	    (void *)&sblock, fso, Nflag);
@


1.32
log
@Replace (int) = (size_t)(long) with (long long) = (long long) by replacing
atol() with strtonum() and storing value of 's' parameter in long long
variable instead of an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.31 2013/06/11 16:42:04 deraadt Exp $	*/
d1989 1
a1989 1
	if (pp->p_size < 1)
d2024 1
a2024 1
	sblock.fs_size = dbtofsb(&osblock, pp->p_size);
d2026 3
a2028 3
		if (size > pp->p_size) {
			errx(1, "there is not enough space (%d < %lld)",
			    pp->p_size, size);
d2030 1
a2030 1
		sblock.fs_size = dbtofsb(&osblock, size);
d2079 2
a2080 2
	wtfs((daddr_t)pp->p_size-1, (size_t)DEV_BSIZE, (void *)&sblock,
	    fso, Nflag);
@


1.31
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.30 2013/04/23 21:27:15 deraadt Exp $	*/
d1904 1
a1904 1
	unsigned int	size = 0;
d1912 1
d1928 2
a1929 2
			size = (size_t)atol(optarg);
			if (size < 1)
d2027 1
a2027 1
			errx(1, "there is not enough space (%d < %d)",
@


1.30
log
@handle large ino_t; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.29 2010/05/18 04:41:14 dlg Exp $	*/
d90 1
a90 1
static daddr64_t sblockloc;
d116 1
a116 1
static daddr64_t 	inoblk;			/* inode block address */
d126 2
a127 2
	daddr64_t	old;		/* old block number */
	daddr64_t	new;		/* new block number */
d130 2
a131 2
	unsigned int	flags;	/* special handling required */
	int	found;		/* how many references were updated */
d136 3
a138 3
static void	rdfs(daddr64_t, size_t, void *, int);
static void	wtfs(daddr64_t, size_t, void *, int, unsigned int);
static daddr64_t alloc(void);
d150 2
a151 2
static void	frag_adjust(daddr64_t, int);
static int	cond_bl_upd(daddr64_t *, struct gfs_bpp *, int, int,
d155 1
a155 1
static void	indirchk(daddr64_t, daddr64_t, daddr64_t, daddr64_t,
d157 1
a157 1
static void	ffs1_sb_update(struct fs *, daddr64_t);
d378 2
a379 2
	daddr64_t d, dlower, dupper, blkno, start;
	daddr64_t i, cbase, dmax;
d583 1
a583 1
frag_adjust(daddr64_t frag, int sign)
d638 1
a638 1
cond_bl_upd(daddr64_t *block, struct gfs_bpp *field, int fsi, int fso,
d643 1
a643 1
	daddr64_t src, dst;
d703 1
a703 1
	daddr64_t	cbase, dmax, dupper;
d943 1
a943 1
	daddr64_t	cbase, dupper, odupper, d, f, g;
d1517 1
a1517 1
rdfs(daddr64_t bno, size_t size, void *bf, int fsi)
d1542 1
a1542 1
wtfs(daddr64_t bno, size_t size, void *bf, int fso, unsigned int Nflag)
d1570 1
a1570 1
static daddr64_t
d1574 1
a1574 1
	daddr64_t	d, blkno;
d2078 1
a2078 1
	wtfs((daddr64_t)pp->p_size-1, (size_t)DEV_BSIZE, (void *)&sblock,
d2288 2
a2289 2
	daddr64_t	len, lbn, numblks;
	daddr64_t	iptr, blksperindir;
d2365 2
a2366 2
indirchk(daddr64_t blksperindir, daddr64_t lbn, daddr64_t blkno,
    daddr64_t lastlbn, struct gfs_bpp *bp, int fsi, int fso, unsigned int Nflag)
d2371 1
a2371 1
	daddr64_t iptr;
d2386 1
a2386 1
			iptr = ((daddr64_t *)ibuf)[i];
d2393 1
a2393 1
				((daddr64_t *)ibuf)[i] = iptr;
d2406 1
a2406 1
ffs1_sb_update(struct fs *fs, daddr64_t sbloc)
@


1.29
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.28 2009/10/27 23:59:33 deraadt Exp $	*/
d1828 2
a1829 1
		errx(8, "bad inode number %d to ginode", inumber);
d2319 2
a2320 1
	DBG_PRINT2("scg checking inode (%d in %d)\n", in, cg);
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.27 2009/04/01 05:31:55 jsg Exp $	*/
d48 1
@


1.27
log
@Don't be picky about character case when checking response.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.26 2008/12/24 20:48:33 otto Exp $	*/
a42 7

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz\n\
Copyright (c) 1980, 1989, 1993 The Regents of the University of California.\n\
All rights reserved.\n";
#endif /* not lint */
@


1.26
log
@fox format string; ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.25 2008/11/28 00:15:54 ckuethe Exp $	*/
d2068 1
a2068 1
		    strncmp(reply, "Yes", 3)) {
@


1.25
log
@Make growfs refuse to run on a dirty filesystem, and set the filesystem to
dirty on the way out so that users are forced to run fsck afterwards. The
manpage politely suggested that the filesystem be checked after growing it;
change it to say that fsck is required.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.24 2008/06/24 08:33:04 sobrado Exp $	*/
d255 1
a255 1
		j = snprintf(tmpbuf, sizeof(tmpbuf), " %d%s",
@


1.24
log
@Index: src/sbin/growfs/growfs.c
===================================================================
RCS file: /cvs/src/sbin/growfs/growfs.c,v
retrieving revision 1.23
diff -u -p -r1.23 growfs.c
--- src/sbin/growfs/growfs.c	5 Oct 2007 13:56:14 -0000	1.23
+++ src/sbin/growfs/growfs.c	4 Jun 2008 10:10:32 -0000
@@@@ -2227,7 +2227,7 @@@@ usage(void)

 	DBG_ENTER;

-	fprintf(stderr, "usage: growfs [-Ny] [-s size] special\n");
+	fprintf(stderr, "usage: growfs [-Nqy] [-s size] special\n");

 	DBG_LEAVE;
 	exit(1);
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.23 2007/10/05 13:56:14 chl Exp $	*/
d306 1
d2013 2
@


1.23
log
@check fgets return value
use strncmp instead of strcmp

with help of ray@@ "Looks OK" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.22 2007/09/02 23:50:03 deraadt Exp $	*/
d2230 1
a2230 1
	fprintf(stderr, "usage: growfs [-Ny] [-s size] special\n");
@


1.22
log
@more malloc(n * m) -> calloc(n, m); from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.21 2007/07/07 08:22:55 millert Exp $	*/
d2064 2
a2065 2
		fgets(reply, (int)sizeof(reply), stdin);
		if (strcmp(reply, "Yes\n")) {
@


1.21
log
@Pull in ffs2 support and other updates from FreeBSD.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.20 2007/06/01 19:26:06 deraadt Exp $	*/
d1244 1
a1244 1
 	bp = (struct gfs_bpp *)malloc(((dupper-odupper) / sblock.fs_frag + 2) *
d1247 1
a1247 1
		errx(1, "malloc failed");
@


1.20
log
@ufs_daddr_t is a dead type.  growfs is the only program that uses it, yet
it is ffs1-aware only.  therefore all the types are on disk, and thus,
they are actually int32_t.  ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.19 2007/05/29 06:28:16 otto Exp $	*/
d40 1
a48 2

static const char rcsid[] = "$OpenBSD: growfs.c,v 1.19 2007/05/29 06:28:16 otto Exp $";
d62 1
d64 1
d66 1
d75 3
d83 1
a83 1
int	quiet = 0;		/* quiet flag */
d87 1
a87 1
	char	pad[SBSIZE];
d92 6
a105 14
static char	i1blk[MAXBSIZE];	/* some indirect blocks */
static char	i2blk[MAXBSIZE];
static char	i3blk[MAXBSIZE];

	/* where to write back updated blocks */
static daddr_t	in_src, i1_src, i2_src, i3_src;

	/* what object contains the reference */
enum pointer_source {
	GFS_PS_INODE,
	GFS_PS_IND_BLK_LVL1,
	GFS_PS_IND_BLK_LVL2,
	GFS_PS_IND_BLK_LVL3
};
d107 1
a107 1
static struct csum	*fscs;		/* cylinder summary */
d109 16
a124 1
static struct ufs1_dinode	zino[MAXBSIZE / sizeof(struct ufs1_dinode)]; /* some inodes */
d132 2
a133 2
	daddr_t	old;		/* old block number */
	daddr_t	new;		/* new block number */
d141 4
a144 4
static void	growfs(char *, int, int, unsigned int);
static void	rdfs(daddr_t, size_t, void *, int);
static void	wtfs(daddr_t, size_t, void *, int, unsigned int);
static daddr_t	alloc(void);
d155 4
a158 4
static struct ufs1_dinode	*ginode(ino_t, int, int);
static void	frag_adjust(daddr_t, int);
static void	cond_bl_upd(int32_t *, struct gfs_bpp *,
    enum pointer_source, int, unsigned int);
d161 3
d178 1
a178 1
growfs(char *fsys, int fsi, int fso, unsigned int Nflag)
d198 1
a198 1
		rdfs(fsbtodb(&osblock, osblock.fs_ffs1_csaddr +
d200 1
a200 1
		    osblock.fs_bsize), (((char *)fscs) + i), fsi);
d213 1
a213 3
		DBG_DUMP_CSUM(&osblock,
		    dbg_line,
		    dbg_csp++);
a226 3
	printf("%s:\t%d sectors in %d %s of %d tracks, %d sectors\n",
	    fsys, sblock.fs_ffs1_size * NSPF(&sblock), sblock.fs_ncyl,
	    "cylinders", sblock.fs_ntrak, sblock.fs_nsect);
d228 9
a236 5
	printf("\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n",
	    (float)sblock.fs_ffs1_size * sblock.fs_fsize * B2MBFACTOR,
	    sblock.fs_ncg, sblock.fs_cpg,
	    (float)sblock.fs_fpg * sblock.fs_fsize * B2MBFACTOR,
	    sblock.fs_ipg);
d244 1
a244 1
		printf("superblock backups (for fsck -b #) at:\n");
d255 2
a256 2
		j = snprintf(tmpbuf, sizeof tmpbuf, " %d%s",
		    (int)fsbtodb(&sblock, cgsblock(&sblock, cylno)),
d258 2
a259 2
		if (j >= sizeof tmpbuf)
			j = sizeof tmpbuf - 1;
d281 1
a281 1
		wtfs(fsbtodb(&sblock, sblock.fs_ffs1_csaddr + numfrags(&sblock, i)),
d283 1
a283 1
		    (((char *)fscs) + i), fso, Nflag);
a301 3
	/* Force update on next mount */
	sblock.fs_ffs1_flags &= ~FS_FLAGS_UPDATED;

d305 16
a320 3
	sblock.fs_ffs1_time = utime;
	wtfs((daddr_t)(SBOFF / DEV_BSIZE), (size_t)SBSIZE, &sblock,
	    fso, Nflag);
d332 4
a335 2
	memset(&sblock.fs_fsmnt, 0, sizeof(sblock.fs_fsmnt));
	sblock.fs_ffs1_flags &= FS_DOSOFTDEP;
d347 1
a347 1
	 *     fs_ffs1_flags regarding SOFTUPDATES
d363 1
a363 1
		    (size_t)SBSIZE, &sblock, fso, Nflag);
d382 5
a386 2
	daddr_t cbase, d, dlower, dupper, dmax, blkno;
	int i;
d388 2
a389 1
	int j;
d391 8
a398 1
	DBG_ENTER;
d402 2
d407 2
a408 2
	if (dmax > sblock.fs_ffs1_size)
		dmax = sblock.fs_ffs1_size;
d413 3
a415 3
	cs = fscs + cylno;
	memset(&acg, 0, (size_t)sblock.fs_cgsize);
	acg.cg_time = utime;
d418 2
a419 5
	if (cylno == sblock.fs_ncg - 1)
		acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
	else
		acg.cg_ncyl = sblock.fs_cpg;
	acg.cg_niblk = sblock.fs_ipg;
d423 3
a425 8
	acg.cg_btotoff = sizeof(struct cg);
	acg.cg_boff = acg.cg_btotoff + sblock.fs_cpg * sizeof(int32_t);
	acg.cg_iusedoff = acg.cg_boff +
	    sblock.fs_cpg * sblock.fs_nrpos * sizeof(u_int16_t);
	acg.cg_freeoff = acg.cg_iusedoff + howmany(sblock.fs_ipg, NBBY);
	if (sblock.fs_contigsumsize <= 0) {
		acg.cg_nextfreeoff = acg.cg_freeoff +
		    howmany(sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY);
d427 18
a444 3
		acg.cg_clustersumoff = acg.cg_freeoff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY) -
		    sizeof(u_int32_t);
d446 2
a447 1
		    roundup(acg.cg_clustersumoff, sizeof(u_int32_t));
d450 2
a451 2
		acg.cg_nextfreeoff = acg.cg_clusteroff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPB(&sblock), NBBY);
d453 1
a453 1
	if (acg.cg_nextfreeoff-(int)(&acg.cg_firstfield) > sblock.fs_cgsize) {
d455 1
a455 1
		 * XXX This should never happen as we would have had that panic
d461 2
a462 2
	if (cylno == 0)
		for (i = 0; (size_t)i < ROOTINO; i++) {
a465 5
	for (i = 0; i < sblock.fs_ipg / INOPF(&sblock); i += sblock.fs_frag) {
		for (j = 0; (unsigned)j < sblock.fs_bsize / sizeof(struct ufs1_dinode); j++)
			zino[j].di_gen = arc4random();
		wtfs(fsbtodb(&sblock, cgimin(&sblock, cylno) + i),
		    (size_t)sblock.fs_bsize, zino, fso, Nflag);
d467 11
a477 5
	for (d = 0; d < dlower; d += sblock.fs_frag) {
		blkno = d / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), blkno);
		if (sblock.fs_contigsumsize > 0) {
			setbit(cg_clustersfree(&acg), blkno);
d479 1
a479 4
		acg.cg_cs.cs_nbfree++;
		cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]++;
d481 1
a481 2
	sblock.fs_ffs1_dsize += dlower;
	sblock.fs_ffs1_dsize += acg.cg_ndblk - dupper;
d489 2
a490 1
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase;) {
d493 1
a493 1
		if (sblock.fs_contigsumsize > 0) {
a494 1
		}
d496 4
a499 8
		cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]++;
		d += sblock.fs_frag;
	}
	if (d < dmax - cbase) {
		acg.cg_frsum[dmax - cbase - d]++;
		for (; d < dmax - cbase; d++) {
d520 1
a520 1
			if ((i & (NBBY - 1)) != (NBBY - 1))
d528 1
a528 1
			if (run > sblock.fs_contigsumsize) {
a529 1
			}
d533 4
a536 4
	sblock.fs_ffs1_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_ffs1_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_ffs1_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_ffs1_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
d538 37
a574 2
	wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)),
	    (size_t)sblock.fs_bsize, &acg, fso, Nflag);
d585 1
a585 1
 * statistic, which seems to be otherwise an rather complex operation.
d588 1
a588 1
frag_adjust(daddr_t frag, int sign)
a600 1
#define	rounddown(x, y)	(((x)/(y))*(y))
d602 2
a603 1
	    f < roundup(frag + 1, sblock.fs_frag); f++) {
d607 1
a607 1
		if (isset(cg_blksfree(&acg), f))
d609 1
a609 1
		else {
d614 3
a616 2
				acg.cg_frsum[fragsize]+=sign;
				DBG_PRINT2("frag_adjust [%d]+=%d\n", fragsize, sign);
d625 1
a625 1
		acg.cg_frsum[fragsize]+=sign;
d636 1
a636 1
 * relocated blocks if any of it's fragments is referenced by the current
d642 3
a644 3
static void
cond_bl_upd(int32_t *block, struct gfs_bpp *field,
    enum pointer_source source, int fso, unsigned int Nflag)
d648 3
a650 2
	char *src;
	daddr_t dst = 0;
d654 13
a666 42
	f = field;
	while (f->old) { /* for all old blocks */
		if (*block/sblock.fs_frag == f->old) {
			/*
			 * The fragment is part of the block, so update.
			 */
			*block = (f->new * sblock.fs_frag + (*block % sblock.fs_frag));
			f->found++;
			DBG_PRINT3("scg (%d->%d)[%d] reference updated\n",
			    f->old, f->new, *block % sblock.fs_frag);

			/* Write the block back to disk immediately */
			switch (source) {
			case GFS_PS_INODE:
				src = ablk;
				dst = in_src;
				break;
			case GFS_PS_IND_BLK_LVL1:
				src = i1blk;
				dst = i1_src;
				break;
			case GFS_PS_IND_BLK_LVL2:
				src = i2blk;
				dst = i2_src;
				break;
			case GFS_PS_IND_BLK_LVL3:
				src = i3blk;
				dst = i3_src;
				break;
			default:	/* error */
				src = NULL;
				break;
			}
			if (src) {
				/*
				 * XXX	If src is not of type inode we have to
				 *	implement  copy on write here in  case
				 *	of active snapshots.
				 */
				wtfs(dst, (size_t)sblock.fs_bsize, src,
				    fso, Nflag);
			}
d668 18
a685 6
			/*
			 * The same block can't be found again in this loop.
			 */
			break;
		}
		f++;
d689 1
d708 1
a708 1
	daddr_t	cbase, dmax, dupper;
d720 1
a720 1
	    (size_t)osblock.fs_cgsize, &aocg, fsi);
d727 1
a727 1
	 * If  the  cylinder  group had already it's  new  final  size  almost
d733 3
a735 3

	if (cgbase(&osblock, cylno + 1) == osblock.fs_ffs1_size) {
		acg.cg_ncyl = sblock.fs_cpg;
d738 1
a738 1
		    (size_t)sblock.fs_cgsize, &acg, fso, Nflag);
d741 1
d751 2
a752 2
	if (dmax > sblock.fs_ffs1_size)
		dmax = sblock.fs_ffs1_size;
d754 1
a754 1
	if (cylno == 0) /* XXX fscs may be relocated */
d767 9
a775 7
	if (cylno == sblock.fs_ncg - 1) {
		/*
		 * This is still the last cylinder group.
		 */
		acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
	} else {
		acg.cg_ncyl = sblock.fs_cpg;
d777 6
a782 2
	DBG_PRINT4("jcg dbg: %d %u %d %u\n", cylno, sblock.fs_ncg, acg.cg_ncyl,
	    sblock.fs_cpg);
d784 1
a784 1
	sblock.fs_ffs1_dsize += acg.cg_ndblk - aocg.cg_ndblk;
d800 2
a801 2
	if (osblock.fs_ffs1_size % sblock.fs_frag) {
		if (roundup(osblock.fs_ffs1_size, sblock.fs_frag)<=sblock.fs_ffs1_size) {
d807 2
a808 2
			for (i = roundup(osblock.fs_ffs1_size - cbase, sblock.fs_frag)-1;
			    i >= osblock.fs_ffs1_size - cbase; i--) {
d820 1
a820 1
			    ((osblock.fs_ffs1_size - cgbase(&sblock, cylno))/
d823 1
a823 1
				 * The block is now completely available
d826 1
a826 1
				acg.cg_frsum[osblock.fs_ffs1_size % sblock.fs_frag]--;
d829 1
a829 1
				k = rounddown(osblock.fs_ffs1_size - cbase,
d831 1
a831 4
				cg_blktot(&acg)[cbtocylno(&sblock, k)]++;
				cg_blks(&sblock, &acg, cbtocylno(&sblock, k))
				    [cbtorpos(&sblock, k)]++;
				updclst((osblock.fs_ffs1_size - cbase)/sblock.fs_frag);
d839 1
a839 1
				    (i >= rounddown(osblock.fs_ffs1_size - cbase,
d853 2
a854 2
			for (i = sblock.fs_ffs1_size - cbase - 1;
			    i >= osblock.fs_ffs1_size - cbase; i--) {
d864 1
a864 1
			    (i >= rounddown(osblock.fs_ffs1_size - cbase,
d878 2
a879 2
	for (i = roundup(osblock.fs_ffs1_size - cbase, sblock.fs_frag);
	    i + sblock.fs_frag<=dmax-cbase;	/* XXX <= or only < ? */
a884 3
		cg_blktot(&acg)[cbtocylno(&sblock, i)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, i))
		    [cbtorpos(&sblock, i)]++;
d900 1
a900 1
	sblock.fs_ffs1_cstotal.cs_nffree +=
d902 1
a902 1
	sblock.fs_ffs1_cstotal.cs_nbfree +=
d906 2
a907 2
	 *     sblock.fs_ffs1_cstotal.cs_ndir
	 *     sblock.fs_ffs1_cstotal.cs_nifree
d917 1
a917 1
	    &acg, fso, Nflag);
d919 1
a919 3
	DBG_DUMP_CG(&sblock,
	    "new joining cg",
	    &acg);
d948 1
a948 1
	daddr_t	cbase, dupper, odupper, d, f, g;
d966 1
a966 1
	ocscg = dtog(&osblock, osblock.fs_ffs1_csaddr);
d978 1
a978 1
	    (size_t)osblock.fs_cgsize, &aocg, fsi);
d980 1
a980 3
	DBG_DUMP_CG(&sblock,
	    "old summary cg",
	    &aocg);
d996 1
a996 2
	if (/* ((int)sblock.fs_ffs1_time & 0x3) > 0 || */
	    cs->cs_nbfree < blocks) {
d1017 1
a1017 1
		if (sblock.fs_ncg - osblock.fs_ncg < 2)
d1024 1
a1024 1
		d = osblock.fs_ffs1_csaddr+(osblock.fs_cssize/osblock.fs_fsize);
d1045 1
a1045 1
		DBG_PRINT1("d=%d\n", d);
d1054 1
a1054 2
				DBG_PRINT1("d=%d\n",
				    d);
d1057 1
a1057 1
				sblock.fs_ffs1_cstotal.cs_nffree++;
d1067 3
a1069 4
			    (d % sblock.fs_fpg)/sblock.fs_frag)) {
				DBG_PRINT1("d=%d\n",
				    d);
				acg.cg_cs.cs_nffree-=sblock.fs_frag;
d1071 2
a1072 7
				sblock.fs_ffs1_cstotal.cs_nffree-=sblock.fs_frag;
				sblock.fs_ffs1_cstotal.cs_nbfree++;
				cg_blktot(&acg)[cbtocylno(&sblock,
				    d % sblock.fs_fpg)]++;
				cg_blks(&sblock, &acg, cbtocylno(&sblock,
				    d % sblock.fs_fpg))[cbtorpos(&sblock,
				    d % sblock.fs_fpg)]++;
d1075 1
a1075 1
					    (d % sblock.fs_fpg)/sblock.fs_frag);
d1077 4
a1080 2
						if (lcs)
							cg_clustersum(&acg)[lcs]--;
d1093 2
a1094 3
		DBG_PRINT1("d=%d\n",
		    d);
		for (d = rounddown(d, sblock.fs_frag); d >= osblock.fs_ffs1_csaddr;
d1097 1
a1097 2
			DBG_PRINT1("d=%d\n",
			    d);
d1099 1
a1099 1
			    (d % sblock.fs_fpg)/sblock.fs_frag);
d1101 1
a1101 5
			sblock.fs_ffs1_cstotal.cs_nbfree++;
			cg_blktot(&acg)[cbtocylno(&sblock, d % sblock.fs_fpg)]++;
			cg_blks(&sblock, &acg, cbtocylno(&sblock,
			    d % sblock.fs_fpg))[cbtorpos(&sblock,
			    d % sblock.fs_fpg)]++;
d1104 1
a1104 1
				    (d % sblock.fs_fpg)/sblock.fs_frag);
d1109 1
a1109 1
					if (lcs)
d1111 1
d1124 1
a1124 1
		    (size_t)sblock.fs_cgsize, &acg, fso, Nflag);
d1132 2
a1133 2
		sblock.fs_ffs1_csaddr = cgdmin(&sblock, osblock.fs_ncg);
		ncscg = dtog(&sblock, sblock.fs_ffs1_csaddr);
d1155 1
a1155 3
		DBG_DUMP_CG(&sblock,
		    "new summary cg",
		    &aocg);
d1163 3
a1165 3
		for (d = sblock.fs_ffs1_csaddr; d + sblock.fs_frag <=
		    sblock.fs_ffs1_csaddr+(sblock.fs_cssize/sblock.fs_fsize);
		    d+=sblock.fs_frag) {
d1169 1
a1169 5
			sblock.fs_ffs1_cstotal.cs_nbfree--;
			cg_blktot(&acg)[cbtocylno(&sblock, d%sblock.fs_fpg)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock,
			    d%sblock.fs_fpg))[cbtorpos(&sblock,
			    d%sblock.fs_fpg)]--;
d1172 1
a1172 1
				    (d%sblock.fs_fpg)/sblock.fs_frag);
d1180 2
a1181 2
		if (d < sblock.fs_ffs1_csaddr+(sblock.fs_cssize/sblock.fs_fsize)) {
			for (; d - sblock.fs_ffs1_csaddr<
d1186 1
a1186 1
				sblock.fs_ffs1_cstotal.cs_nffree--;
d1189 3
a1191 7
			acg.cg_cs.cs_nffree+=sblock.fs_frag;
			sblock.fs_ffs1_cstotal.cs_nbfree--;
			sblock.fs_ffs1_cstotal.cs_nffree+=sblock.fs_frag;
			cg_blktot(&acg)[cbtocylno(&sblock, d%sblock.fs_fpg)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock,
			    d%sblock.fs_fpg))[cbtorpos(&sblock,
			    d%sblock.fs_fpg)]--;
d1194 1
a1194 1
				    (d%sblock.fs_fpg)/sblock.fs_frag);
d1197 1
a1197 1
			frag_adjust(d%sblock.fs_fpg, +1);
d1202 1
a1202 1
		 *	space is less than the maximum cluster size. This is
d1219 1
a1219 1
		    (size_t)sblock.fs_cgsize, &acg, fso, Nflag);
d1221 1
a1221 3
		DBG_DUMP_CG(&sblock,
		    "new summary cg",
		    &acg);
d1234 1
a1234 1
	dupper = sblock.fs_ffs1_csaddr - cbase +
d1236 1
a1236 1
	odupper = osblock.fs_ffs1_csaddr - cbase +
d1239 1
a1239 1
	sblock.fs_ffs1_dsize -= dupper - odupper;
d1244 1
a1244 1
	bp= malloc(((dupper - odupper)/sblock.fs_frag + 2) *
d1248 1
a1248 1
	memset(bp, 0, ((dupper - odupper) / sblock.fs_frag + 2) *
d1262 1
a1262 1
		DBG_PRINT1("scg first frag check loop d=%d\n", d);
d1274 1
a1274 1
			sblock.fs_ffs1_cstotal.cs_nffree--;
d1289 3
a1291 4
	for (; d + sblock.fs_frag<=dupper; d+=sblock.fs_frag) {
		DBG_PRINT1("scg block check loop d=%d\n",
		    d);
		if (!isblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag)) {
d1295 1
a1295 1
					sblock.fs_ffs1_cstotal.cs_nffree--;
d1298 1
a1298 1
			clrblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag);
d1302 1
a1302 1
			clrblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag);
d1304 1
a1304 4
			sblock.fs_ffs1_cstotal.cs_nbfree--;
			cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]--;
d1332 1
a1332 1
		if (isblock(&sblock, cg_blksfree(&acg), d/sblock.fs_frag)) {
d1334 1
a1334 1
			sblock.fs_ffs1_cstotal.cs_nbfree--;
d1336 1
a1336 4
			sblock.fs_ffs1_cstotal.cs_nffree+=sblock.fs_frag;
			cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]--;
d1354 2
a1355 1
			DBG_PRINT1("scg second frag check loop d=%d\n", d);
d1362 1
a1362 1
				sblock.fs_ffs1_cstotal.cs_nffree--;
d1400 1
a1400 1
					sblock.fs_ffs1_cstotal.cs_nffree++;
d1415 2
a1416 1
				    f < odupper; f++, g++) {
d1419 1
a1419 1
					sblock.fs_ffs1_cstotal.cs_nffree++;
d1422 1
a1422 2
					frag_adjust(bp[i].new * sblock.fs_frag,1);

d1433 2
a1434 1
				    f < roundup(dupper, sblock.fs_frag); f++) {
d1438 1
a1438 1
						sblock.fs_ffs1_cstotal.cs_nffree++;
d1458 1
a1458 1
			    (size_t)sblock.fs_bsize, &ablk, fsi);
d1460 1
a1460 1
			    (size_t)sblock.fs_bsize, &ablk, fso, Nflag);
d1464 2
a1465 2
			DBG_PRINT2("scg (%d->%d) block relocated\n",
			    bp[i].old, bp[i].new);
d1476 1
a1476 1
			for (inc = osblock.fs_ipg - 1; inc >= 0; inc--) {
d1486 3
a1488 3
			if (!bp[i].found || (bp[i].found>sblock.fs_frag)) {
				warnx("error: %d refs found for block %d.",
				    bp[i].found, bp[i].old);
d1495 2
a1496 2
	 *     sblock.fs_ffs1_cstotal.cs_ndir
	 *     sblock.fs_ffs1_cstotal.cs_nifree
d1498 2
a1499 2
	 *     sblock.fs_ffs1_cstotal.cs_nffree
	 *     sblock.fs_ffs1_cstotal.cs_nbfree
d1510 1
a1510 1
	    &acg, fso, Nflag);
d1512 1
a1512 3
	DBG_DUMP_CG(&sblock,
	    "new summary cg",
	    &acg);
d1522 1
a1522 1
rdfs(daddr_t bno, size_t size, void *bf, int fsi)
a1526 1
	DBG_ENTER;
d1528 5
a1532 2
	if (lseek(fsi, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0) {
		err(33, "rdfs: seek error: %ld", (long)bno);
d1536 1
a1536 1
		err(34, "rdfs: read error: %ld", (long)bno);
d1547 1
a1547 1
wtfs(daddr_t bno, size_t size, void *bf, int fso, unsigned int Nflag)
d1558 1
a1558 1
	if (lseek(fso, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0)
d1560 1
d1562 1
a1562 1
	if (n != (ssize_t)size)
d1564 1
d1575 1
a1575 1
static daddr_t
d1579 1
a1579 1
	daddr_t	d, blkno;
d1607 2
a1608 2
	if (dmax > sblock.fs_ffs1_size) {
		dmax = sblock.fs_ffs1_size;
d1611 1
a1611 1
	csmin = sblock.fs_ffs1_csaddr - cgbase(&sblock, acg.cg_cgx);
d1613 1
a1613 2
	DBG_PRINT3("seek range: dl=%d, du=%d, dm=%d\n",
	    dlower, dupper, dmax);
d1617 1
a1617 1
		if (d >= csmin && d<=csmax) {
d1636 1
a1636 1
	if (blkno==-1) {
d1660 1
a1660 1
		for (lcs1 = 0, l = blkno - 1; lcs1<sblock.fs_contigsumsize;
d1669 1
a1669 1
		for (lcs2 = 0, l = blkno + 1; lcs2<sblock.fs_contigsumsize;
d1678 1
a1678 1
		cg_clustersum(&acg)[MIN(lcs1+lcs2 + 1, sblock.fs_contigsumsize)]--;
d1688 1
a1688 3
	sblock.fs_ffs1_cstotal.cs_nbfree--;
	cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
	cg_blks(&sblock, &acg, cbtocylno(&sblock, d))[cbtorpos(&sblock, d)]--;
d1807 1
a1807 1
static struct ufs1_dinode *
a1810 1
	int32_t	iblk;
a1811 1
	struct ufs1_dinode	*pi;
d1815 12
a1826 1
	pi = (struct ufs1_dinode *)ablk;
d1828 10
a1837 9
	if (startinum == 0 || inumber < startinum ||
	    inumber >= startinum + INOPB(&sblock)) {
		/*
		 * The block needed is not cached, so we have to read it from
		 * disk now.
		 */
		iblk = ino_to_fsba(&sblock, inumber);
		in_src = fsbtodb(&sblock, iblk);
		rdfs(in_src, (size_t)sblock.fs_bsize, &ablk, fsi);
a1839 1

d1841 5
a1845 1
	return (&(pi[inumber % INOPB(&sblock)]));
d1906 1
a1906 1
	char	*device, *rdev;
d1914 1
a1914 1
	int	fsi, fso;
d1922 1
a1922 1
	while ((ch = getopt(argc, argv, "Nqs:y")) != -1) {
d1932 1
a1932 1
			if (size < 1) {
d1934 2
a1935 1
			}
d1949 1
a1949 1
	if (argc != 1) {
a1950 2
	}
	device = *argv;
d1956 2
a1957 2
	if ((fsi = opendev(device, O_RDONLY, 0, &rdev)) < 0)
		err(1, "%s", rdev);
d1960 1
a1960 1
	 * Try to access our device for writing ...
d1965 1
a1965 1
		fso = open(rdev, O_WRONLY);
d1967 1
a1967 1
			err(1, "%s", rdev);
d1975 1
a1975 1
		err(1, "%s: fstat()", rdev);
d1987 1
a1987 1
		    rdev, DISKPART(st.st_rdev));
d1990 1
a1990 1
	 * Check if that partition looks suited for growing a filesystem.
d1995 1
a1995 1
		errx(1, "partition not 4.2BSD");
d2000 11
a2010 2
	rdfs((daddr_t)(SBOFF / DEV_BSIZE), (size_t)SBSIZE, &osblock, fsi);
	if (osblock.fs_magic != FS_MAGIC)
d2012 3
d2016 1
d2025 1
a2025 1
	sblock.fs_ffs1_size = dbtofsb(&osblock, pp->p_size);
d2028 1
a2028 1
			errx(1, "There is not enough space (%d < %d)",
d2031 1
a2031 1
		sblock.fs_ffs1_size = dbtofsb(&osblock, size);
d2037 3
a2039 3
	if (osblock.fs_ffs1_size >= sblock.fs_ffs1_size) {
		errx(1, "we are not growing (%d->%d)", osblock.fs_ffs1_size,
		    sblock.fs_ffs1_size);
d2054 1
a2054 1
			if (!sblock.fs_snapinum[j]) /* list is dense */
d2061 1
a2061 1
		printf("We strongly recommend you make a backup "
d2072 2
a2073 1
		printf("new file system size is: %d frags\n", sblock.fs_ffs1_size);
d2080 2
a2081 2
	wtfs((daddr_t)pp->p_size - 1, (size_t)DEV_BSIZE, &sblock, fso,
	    Nflag);
d2086 2
a2087 2
	 *     fs_ffs1_size:    is derived from label or user input
	 *     fs_ffs1_dsize:   should get updated in the routines creating or
d2089 1
a2089 1
	 *     fs_ffs1_cstotal: should get updated in the routines creating or
d2094 1
a2094 1
	 * Update the number of cylinders in the filesystem.
d2096 4
a2099 2
	sblock.fs_ncyl = sblock.fs_ffs1_size * NSPF(&sblock) / sblock.fs_spc;
	if (sblock.fs_ffs1_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc)
d2101 3
d2105 2
a2106 11
	/*
	 * Update the number of cylinder groups in the filesystem.
	 */
	sblock.fs_ncg = sblock.fs_ncyl / sblock.fs_cpg;
	if (sblock.fs_ncyl % sblock.fs_cpg)
		sblock.fs_ncg++;

	if ((sblock.fs_ffs1_size - (sblock.fs_ncg - 1) * sblock.fs_fpg) <
	    sblock.fs_fpg && cgdmin(&sblock, (sblock.fs_ncg - 1))-
	    cgbase(&sblock, (sblock.fs_ncg - 1)) > (sblock.fs_ffs1_size -
	    (sblock.fs_ncg - 1) * sblock.fs_fpg)) {
d2112 2
a2113 6
#if 1 /* this is a bit more safe */
		sblock.fs_ncyl = sblock.fs_ncg * sblock.fs_cpg;
#else
		sblock.fs_ncyl -= sblock.fs_ncyl % sblock.fs_cpg;
#endif
		sblock.fs_ncyl -= sblock.fs_ncyl % sblock.fs_cpg;
d2115 4
a2118 4
			printf("Warning: %d sector(s) cannot be allocated.\n",
			    (sblock.fs_ffs1_size-(sblock.fs_ncg)*sblock.fs_fpg) *
			    NSPF(&sblock));
		sblock.fs_ffs1_size = sblock.fs_ncyl * sblock.fs_spc / NSPF(&sblock);
d2128 1
a2128 1
	if (osblock.fs_ffs1_size >= sblock.fs_ffs1_size) {
a2129 1
	}
d2136 1
a2136 1
	growfs(rdev, fsi, fso, Nflag);
d2143 1
a2143 1
	pp->p_cpg = sblock.fs_cpg;
d2155 1
a2155 1
	return (0);
a2184 1

d2193 1
d2208 1
a2208 1
	lab = malloc(sizeof(struct disklabel));
d2211 2
a2212 2
	if (ioctl(fd, DIOCGDINFO, (char *)lab) < 0)
		errx(1, "DIOCGDINFO failed");
d2230 1
a2230 1
	fprintf(stderr, "usage: growfs [-Nqy] [-s size] special\n");
d2239 1
a2239 1
 * assume, that sblock, osblock, acg are set up.
d2249 1
a2249 1
	if (sblock.fs_contigsumsize < 1) /* no clustering */
d2251 1
d2290 4
a2293 4
	unsigned int	ictr, ind2ctr, ind3ctr;
	int32_t	*iptr, *ind2ptr, *ind3ptr;
	struct ufs1_dinode	*ino;
	int	remaining_blocks;
a2296 4
	/*
	 * XXX We should skip unused inodes even from beeing read from disk
	 *     here by using the bitmap.
	 */
d2298 6
a2303 2
	if (!((ino->di_mode & IFMT) == IFDIR || (ino->di_mode & IFMT) == IFREG ||
	    (ino->di_mode & IFMT) == IFLNK)) {
d2307 2
a2308 2
	if (((ino->di_mode & IFMT) == IFLNK) &&
	    (ino->di_size < MAXSYMLINKLEN_UFS1)) {
d2312 2
a2313 1
	if (!ino->di_size) {
d2317 1
a2317 1
	if (!ino->di_blocks) {
d2324 1
a2324 1
	 * Start checking all direct blocks.
d2326 10
a2335 6
	remaining_blocks = howmany(ino->di_size, sblock.fs_bsize);
	for (ictr = 0; ictr < MIN(NDADDR, (unsigned int)remaining_blocks);
	    ictr++) {
		iptr = &(ino->di_db[ictr]);
		if (*iptr)
			cond_bl_upd(iptr, bp, GFS_PS_INODE, fso, Nflag);
d2339 16
a2354 4
	remaining_blocks -= NDADDR;
	if (remaining_blocks < 0) {
		DBG_LEAVE;
		return;
d2356 5
a2360 18
	if (ino->di_ib[0]) {
		/*
		 * Start checking first indirect block
		 */
		cond_bl_upd(&(ino->di_ib[0]), bp, GFS_PS_INODE, fso, Nflag);
		i1_src = fsbtodb(&sblock, ino->di_ib[0]);
		rdfs(i1_src, (size_t)sblock.fs_bsize, &i1blk, fsi);
		for (ictr = 0; ictr < MIN(howmany(sblock.fs_bsize,
		    sizeof(int32_t)), (unsigned int)remaining_blocks);
		    ictr++) {
			iptr = &((int32_t *)&i1blk)[ictr];
			if (*iptr) {
				cond_bl_upd(iptr, bp, GFS_PS_IND_BLK_LVL1,
				    fso, Nflag);
			}
		}
	}
	DBG_PRINT0("scg indirect_1 blocks checked\n");
d2362 11
a2372 34
	remaining_blocks -= howmany(sblock.fs_bsize, sizeof(int32_t));
	if (remaining_blocks<0) {
		DBG_LEAVE;
		return;
	}
	if (ino->di_ib[1]) {
		/*
		 * Start checking second indirect block
		 */
		cond_bl_upd(&(ino->di_ib[1]), bp, GFS_PS_INODE, fso, Nflag);
		i2_src = fsbtodb(&sblock, ino->di_ib[1]);
		rdfs(i2_src, (size_t)sblock.fs_bsize, &i2blk, fsi);
		for (ind2ctr = 0; ind2ctr < howmany(sblock.fs_bsize,
		    sizeof(int32_t)); ind2ctr++) {
			ind2ptr = &((int32_t *)&i2blk)[ind2ctr];
			if (!*ind2ptr)
				continue;
			cond_bl_upd(ind2ptr, bp, GFS_PS_IND_BLK_LVL2, fso,
			    Nflag);
			i1_src = fsbtodb(&sblock, *ind2ptr);
			rdfs(i1_src, (size_t)sblock.fs_bsize, &i1blk,
			    fsi);
			for (ictr = 0; ictr < MIN(howmany((unsigned int)
			    sblock.fs_bsize, sizeof(int32_t)),
			    (unsigned int)remaining_blocks); ictr++) {
				iptr = &((int32_t *)&i1blk)[ictr];
				if (*iptr) {
					cond_bl_upd(iptr, bp,
					    GFS_PS_IND_BLK_LVL1, fso, Nflag);
				}
			}
		}
	}
	DBG_PRINT0("scg indirect_2 blocks checked\n");
d2374 1
a2374 7
#define SQUARE(a) ((a)*(a))
	remaining_blocks -= SQUARE(howmany(sblock.fs_bsize, sizeof(int32_t)));
#undef SQUARE
	if (remaining_blocks < 0) {
		DBG_LEAVE;
		return;
	}
d2376 19
a2394 38
	if (ino->di_ib[2]) {
		/*
		 * Start checking third indirect block
		 */
		cond_bl_upd(&(ino->di_ib[2]), bp, GFS_PS_INODE, fso, Nflag);
		i3_src = fsbtodb(&sblock, ino->di_ib[2]);
		rdfs(i3_src, (size_t)sblock.fs_bsize, &i3blk, fsi);
		for (ind3ctr = 0; ind3ctr < howmany(sblock.fs_bsize,
		    sizeof(int32_t)); ind3ctr++) {
			ind3ptr = &((int32_t *)&i3blk)[ind3ctr];
			if (!*ind3ptr)
				continue;
			cond_bl_upd(ind3ptr, bp, GFS_PS_IND_BLK_LVL3, fso,
			    Nflag);
			i2_src = fsbtodb(&sblock, *ind3ptr);
			rdfs(i2_src, (size_t)sblock.fs_bsize, &i2blk,
			    fsi);
			for (ind2ctr = 0; ind2ctr < howmany(sblock.fs_bsize,
			    sizeof(int32_t)); ind2ctr++) {
				ind2ptr = &((int32_t *)&i2blk)[ind2ctr];
				if (!*ind2ptr)
					continue;
				cond_bl_upd(ind2ptr, bp, GFS_PS_IND_BLK_LVL2,
				    fso, Nflag);
				i1_src = fsbtodb(&sblock, *ind2ptr);
				rdfs(i1_src, (size_t)sblock.fs_bsize,
				    &i1blk, fsi);
				for (ictr = 0; ictr < MIN(howmany(sblock.fs_bsize,
				    sizeof(int32_t)),
				    (unsigned int)remaining_blocks); ictr++) {
					iptr = &((int32_t *)&i1blk)[ictr];
					if (*iptr) {
						cond_bl_upd(iptr, bp,
						    GFS_PS_IND_BLK_LVL1, fso,
						    Nflag);
					}
				}
			}
d2396 4
d2401 1
a2401 2

	DBG_PRINT0("scg indirect_3 blocks checked\n");
d2406 16
@


1.19
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.18 2007/04/23 10:18:30 pedro Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.18 2007/04/23 10:18:30 pedro Exp $";
d145 1
a145 1
static void	cond_bl_upd(ufs_daddr_t *, struct gfs_bpp *,
d568 1
a568 1
cond_bl_upd(ufs_daddr_t *block, struct gfs_bpp *field,
d1783 1
a1783 1
	ufs_daddr_t	iblk;
d2245 1
a2245 1
	ufs_daddr_t	*iptr, *ind2ptr, *ind3ptr;
d2301 1
a2301 1
		    sizeof(ufs_daddr_t)), (unsigned int)remaining_blocks);
d2303 1
a2303 1
			iptr = &((ufs_daddr_t *)&i1blk)[ictr];
d2312 1
a2312 1
	remaining_blocks -= howmany(sblock.fs_bsize, sizeof(ufs_daddr_t));
d2325 2
a2326 2
		    sizeof(ufs_daddr_t)); ind2ctr++) {
			ind2ptr = &((ufs_daddr_t *)&i2blk)[ind2ctr];
d2335 1
a2335 1
			    sblock.fs_bsize, sizeof(ufs_daddr_t)),
d2337 1
a2337 1
				iptr = &((ufs_daddr_t *)&i1blk)[ictr];
d2348 1
a2348 1
	remaining_blocks -= SQUARE(howmany(sblock.fs_bsize, sizeof(ufs_daddr_t)));
d2363 2
a2364 2
		    sizeof(ufs_daddr_t)); ind3ctr++) {
			ind3ptr = &((ufs_daddr_t *)&i3blk)[ind3ctr];
d2373 2
a2374 2
			    sizeof(ufs_daddr_t)); ind2ctr++) {
				ind2ptr = &((ufs_daddr_t *)&i2blk)[ind2ctr];
d2383 1
a2383 1
				    sizeof(ufs_daddr_t)),
d2385 1
a2385 1
					iptr = &((ufs_daddr_t *)&i1blk)[ictr];
@


1.18
log
@Remove 'cg_space' from 'struct cg'. Due to the alignment on 64-bit
architectures, CGSIZE() was returning something sligthly over one block.
The 'new' fsck would round this value up to a fragment boundary, and end
up trying to access memory beyond allocated space. From mickey@@, okay
pedro@@, millert@@ and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.17 2007/03/19 13:27:47 pedro Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.17 2007/03/19 13:27:47 pedro Exp $";
d2096 2
a2097 2
	pp->p_fsize = sblock.fs_fsize;
	pp->p_frag = sblock.fs_frag;
@


1.17
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.16 2006/04/02 00:48:35 deraadt Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.16 2006/04/02 00:48:35 deraadt Exp $";
d387 1
a387 1
	acg.cg_btotoff = &acg.cg_space[0] - (u_char *)(&acg.cg_firstfield);
@


1.16
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.15 2006/03/31 08:13:07 pedro Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.15 2006/03/31 08:13:07 pedro Exp $";
d183 1
a183 1
		rdfs(fsbtodb(&osblock, osblock.fs_csaddr +
d215 1
a215 1
	    fsys, sblock.fs_size * NSPF(&sblock), sblock.fs_ncyl,
d219 1
a219 1
	    (float)sblock.fs_size * sblock.fs_fsize * B2MBFACTOR,
d267 1
a267 1
		wtfs(fsbtodb(&sblock, sblock.fs_csaddr + numfrags(&sblock, i)),
d288 2
a289 1
	sblock.fs_flags &= ~FS_FLAGS_UPDATED; /* Force update on next mount */
d294 1
a294 1
	sblock.fs_time = utime;
d309 1
a309 1
	sblock.fs_flags &= FS_DOSOFTDEP;
d321 1
a321 1
	 *     fs_flags regarding SOFTUPDATES
d368 2
a369 2
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
d436 2
a437 2
	sblock.fs_dsize += dlower;
	sblock.fs_dsize += acg.cg_ndblk - dupper;
d494 4
a497 4
	sblock.fs_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
d674 1
a674 1
	if (cgbase(&osblock, cylno + 1) == osblock.fs_size) {
d690 2
a691 2
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
d717 1
a717 1
	sblock.fs_dsize += acg.cg_ndblk - aocg.cg_ndblk;
d733 2
a734 2
	if (osblock.fs_size % sblock.fs_frag) {
		if (roundup(osblock.fs_size, sblock.fs_frag)<=sblock.fs_size) {
d740 2
a741 2
			for (i = roundup(osblock.fs_size - cbase, sblock.fs_frag)-1;
			    i >= osblock.fs_size - cbase; i--) {
d753 1
a753 1
			    ((osblock.fs_size - cgbase(&sblock, cylno))/
d759 1
a759 1
				acg.cg_frsum[osblock.fs_size % sblock.fs_frag]--;
d762 1
a762 1
				k = rounddown(osblock.fs_size - cbase,
d767 1
a767 1
				updclst((osblock.fs_size - cbase)/sblock.fs_frag);
d775 1
a775 1
				    (i >= rounddown(osblock.fs_size - cbase,
d789 2
a790 2
			for (i = sblock.fs_size - cbase - 1;
			    i >= osblock.fs_size - cbase; i--) {
d800 1
a800 1
			    (i >= rounddown(osblock.fs_size - cbase,
d814 1
a814 1
	for (i = roundup(osblock.fs_size - cbase, sblock.fs_frag);
d839 1
a839 1
	sblock.fs_cstotal.cs_nffree +=
d841 1
a841 1
	sblock.fs_cstotal.cs_nbfree +=
d845 2
a846 2
	 *     sblock.fs_cstotal.cs_ndir
	 *     sblock.fs_cstotal.cs_nifree
d907 1
a907 1
	ocscg = dtog(&osblock, osblock.fs_csaddr);
d939 2
a940 1
	if (/* ((int)sblock.fs_time & 0x3) > 0 || */ cs->cs_nbfree < blocks) {
d968 1
a968 1
		d = osblock.fs_csaddr+(osblock.fs_cssize/osblock.fs_fsize);
d1002 1
a1002 1
				sblock.fs_cstotal.cs_nffree++;
d1017 2
a1018 2
				sblock.fs_cstotal.cs_nffree-=sblock.fs_frag;
				sblock.fs_cstotal.cs_nbfree++;
d1044 1
a1044 1
		for (d = rounddown(d, sblock.fs_frag); d >= osblock.fs_csaddr;
d1052 1
a1052 1
			sblock.fs_cstotal.cs_nbfree++;
d1086 2
a1087 2
		sblock.fs_csaddr = cgdmin(&sblock, osblock.fs_ncg);
		ncscg = dtog(&sblock, sblock.fs_csaddr);
d1119 2
a1120 2
		for (d = sblock.fs_csaddr; d + sblock.fs_frag <=
		    sblock.fs_csaddr+(sblock.fs_cssize/sblock.fs_fsize);
d1125 1
a1125 1
			sblock.fs_cstotal.cs_nbfree--;
d1140 2
a1141 2
		if (d < sblock.fs_csaddr+(sblock.fs_cssize/sblock.fs_fsize)) {
			for (; d - sblock.fs_csaddr<
d1146 1
a1146 1
				sblock.fs_cstotal.cs_nffree--;
d1150 2
a1151 2
			sblock.fs_cstotal.cs_nbfree--;
			sblock.fs_cstotal.cs_nffree+=sblock.fs_frag;
d1200 1
a1200 1
	dupper = sblock.fs_csaddr - cbase +
d1202 1
a1202 1
	odupper = osblock.fs_csaddr - cbase +
d1205 1
a1205 1
	sblock.fs_dsize -= dupper - odupper;
d1240 1
a1240 1
			sblock.fs_cstotal.cs_nffree--;
d1262 1
a1262 1
					sblock.fs_cstotal.cs_nffree--;
d1271 1
a1271 1
			sblock.fs_cstotal.cs_nbfree--;
d1304 1
a1304 1
			sblock.fs_cstotal.cs_nbfree--;
d1306 1
a1306 1
			sblock.fs_cstotal.cs_nffree+=sblock.fs_frag;
d1334 1
a1334 1
				sblock.fs_cstotal.cs_nffree--;
d1372 1
a1372 1
					sblock.fs_cstotal.cs_nffree++;
d1390 1
a1390 1
					sblock.fs_cstotal.cs_nffree++;
d1409 1
a1409 1
						sblock.fs_cstotal.cs_nffree++;
d1466 2
a1467 2
	 *     sblock.fs_cstotal.cs_ndir
	 *     sblock.fs_cstotal.cs_nifree
d1469 2
a1470 2
	 *     sblock.fs_cstotal.cs_nffree
	 *     sblock.fs_cstotal.cs_nbfree
d1576 2
a1577 2
	if (dmax > sblock.fs_size) {
		dmax = sblock.fs_size;
d1580 1
a1580 1
	csmin = sblock.fs_csaddr - cgbase(&sblock, acg.cg_cgx);
d1658 1
a1658 1
	sblock.fs_cstotal.cs_nbfree--;
d1972 1
a1972 1
	sblock.fs_size = dbtofsb(&osblock, pp->p_size);
d1978 1
a1978 1
		sblock.fs_size = dbtofsb(&osblock, size);
d1984 3
a1986 3
	if (osblock.fs_size >= sblock.fs_size) {
		errx(1, "we are not growing (%d->%d)", osblock.fs_size,
		    sblock.fs_size);
d2019 1
a2019 1
		printf("new file system size is: %d frags\n", sblock.fs_size);
d2032 2
a2033 2
	 *     fs_size:    is derived from label or user input
	 *     fs_dsize:   should get updated in the routines creating or
d2035 1
a2035 1
	 *     fs_cstotal: should get updated in the routines creating or
d2042 2
a2043 2
	sblock.fs_ncyl = sblock.fs_size * NSPF(&sblock) / sblock.fs_spc;
	if (sblock.fs_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc)
d2053 1
a2053 1
	if ((sblock.fs_size - (sblock.fs_ncg - 1) * sblock.fs_fpg) <
d2055 1
a2055 1
	    cgbase(&sblock, (sblock.fs_ncg - 1)) > (sblock.fs_size -
d2070 1
a2070 1
			    (sblock.fs_size-(sblock.fs_ncg)*sblock.fs_fpg) *
d2072 1
a2072 1
		sblock.fs_size = sblock.fs_ncyl * sblock.fs_spc / NSPF(&sblock);
d2082 1
a2082 1
	if (osblock.fs_size >= sblock.fs_size) {
@


1.15
log
@Super block changes for FFS2, thanks to all who tested.
Silent okay after almost 3 weeks, hackers@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.14 2006/01/14 21:10:20 miod Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.14 2006/01/14 21:10:20 miod Exp $";
d1500 1
a1500 1
	if (lseek(fsi, (off_t)bno * DEV_BSIZE, 0) < 0) {
@


1.14
log
@Add a -q flag to reduce output a la newfs, and print the raw device we are
operating on instead of ``growfs'' (a la newfs as well).

ok millert@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.13 2005/12/19 15:18:01 pedro Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.13 2005/12/19 15:18:01 pedro Exp $";
d287 2
@


1.13
log
@Add and use a few more constants and macros needed by UFS2
No functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.12 2005/04/14 19:58:32 deraadt Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.12 2005/04/14 19:58:32 deraadt Exp $";
d78 2
d129 1
a129 1
static void	growfs(int, int, unsigned int);
d163 1
a163 1
growfs(int fsi, int fso, unsigned int Nflag)
d214 2
a215 2
	printf("growfs:\t%d sectors in %d %s of %d tracks, %d sectors\n",
	    sblock.fs_size * NSPF(&sblock), sblock.fs_ncyl,
d229 2
a230 1
	printf("superblock backups (for fsck -b #) at:\n");
d239 2
d254 2
a255 1
	printf("\n");
d1877 1
a1877 1
	while ((ch = getopt(argc, argv, "Ns:y")) != -1) {
d1882 3
d2014 2
a2015 1
	printf("new file system size is: %d frags\n", sblock.fs_size);
d2064 4
a2067 3
		printf("Warning: %d sector(s) cannot be allocated.\n",
		    (sblock.fs_size-(sblock.fs_ncg)*sblock.fs_fpg) *
		    NSPF(&sblock));
d2087 1
a2087 1
	growfs(fsi, fso, Nflag);
d2181 1
a2181 1
	fprintf(stderr, "usage: growfs [-Ny] [-s size] special\n");
@


1.12
log
@handle snprintf out of range conditions; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.11 2004/03/15 08:52:01 deraadt Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.11 2004/03/15 08:52:01 deraadt Exp $";
d2246 2
a2247 1
	if (((ino->di_mode & IFMT) == IFLNK) && (ino->di_size < MAXSYMLINKLEN)) {
@


1.11
log
@some small knf
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.10 2003/11/08 19:17:28 jmc Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.10 2003/11/08 19:17:28 jmc Exp $";
d239 3
a241 1
		if (i + j >= width) {
@


1.10
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.9 2003/10/28 21:35:16 tedu Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.9 2003/10/28 21:35:16 tedu Exp $";
d1932 1
a1932 1
		     rdev, DISKPART(st.st_rdev));
d2052 1
a2052 1
		printf( "Warning: %d sector(s) cannot be allocated.\n",
d2087 2
a2088 1
	if (fso > -1) close(fso);
@


1.9
log
@better partition finding.  instead of groveling around looking for
a device, and then trying to guess what partition it is, use opendev(),
fstat(), and DISKPART() to know what what's going on.
most of the diff from Tom Cosgrove <tom.cosgrove at arches-consulting.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.8 2003/10/26 21:39:21 tedu Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.8 2003/10/26 21:39:21 tedu Exp $";
d1154 1
a1154 1
		 *	space is less then the maximum cluster size. This is
@


1.8
log
@fix partition selection to allow all partitions to be grown.
report by Mitja Muzenic <mitja at muzenic.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.7 2003/10/14 05:23:30 drahn Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.7 2003/10/14 05:23:30 drahn Exp $";
d1853 1
a1853 1
	char	*device, *special, *cp;
a1855 1
	size_t	len;
d1869 1
a1869 1
	while ((ch = getopt(argc, argv, "Ns:vy")) != -1) {
a1879 2
		case 'v': /* for compatibility to newfs */
			break;
d1898 2
a1899 1
	 * Now try to guess the (raw)device name.
d1901 2
a1902 15
	if (0 == strrchr(device, '/')) {
		/*
		 * No path prefix was given, so try in that order:
		 *     /dev/%s
		 *     /dev/r%s
		 */
		len = strlen(device) + strlen(_PATH_DEV) + 2;
		special = malloc(len);
		if (special == NULL)
			errx(1, "malloc failed");
		snprintf(special, len, "%s%s", _PATH_DEV, device);
		if (stat(special, &st) == -1)
			snprintf(special, len, "%sr%s", _PATH_DEV, device);
		device = special;
	}
d1905 1
a1905 1
	 * Try to access our devices for writing ...
d1910 1
a1910 1
		fso = open(device, O_WRONLY);
d1912 1
a1912 1
			err(1, "%s", device);
d1916 2
a1917 1
	 * ... and reading.
d1919 2
a1920 3
	fsi = open(device, O_RDONLY);
	if (fsi < 0)
		err(1, "%s", device);
d1923 3
a1925 3
	 * Try  to read a label and guess the slice if not  specified.  This
	 * code  should guess the right thing and avoid to bother the user
	 * with the task of specifying the option -v on vinum volumes.
a1926 1
	cp = device + strlen(device)-1;
d1928 2
a1929 4
	if (isdigit(*cp))
		pp = &lp->d_partitions[0];
	else if (*cp >= 'a' && *cp < 'a' + getmaxpartitions())
		pp = &lp->d_partitions[*cp - 'a'];
d1931 2
a1932 1
		errx(1, "unknown device");
@


1.7
log
@getopt() returns int not char. ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.6 2003/08/25 23:28:15 tedu Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.6 2003/08/25 23:28:15 tedu Exp $";
d66 2
d1945 2
a1946 2
		pp = &lp->d_partitions[2];
	else if (*cp>='a' && *cp<='h')
@


1.6
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.5 2003/08/16 17:31:55 deraadt Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.5 2003/08/16 17:31:55 deraadt Exp $";
d1852 1
a1852 1
	char	ch;
@


1.5
log
@more errx/warnx style \n errors; tom.cosgrove@@arches-consulting.com
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.4 2003/08/07 16:37:52 fgsch Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.4 2003/08/07 16:37:52 fgsch Exp $";
d108 1
a108 1
static struct dinode	zino[MAXBSIZE / sizeof(struct dinode)]; /* some inodes */
d139 1
a139 1
static struct dinode	*ginode(ino_t, int, int);
d407 1
a407 1
		for (j = 0; (unsigned)j < sblock.fs_bsize / sizeof(struct dinode); j++)
d1765 1
a1765 1
static struct dinode *
d1771 1
a1771 1
	struct dinode	*pi;
d1775 1
a1775 1
	pi = (struct dinode *)ablk;
d2243 1
a2243 1
	struct dinode	*ino;
@


1.4
log
@add missing tags and make this compile with debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: growfs.c,v 1.3 2003/08/04 04:49:57 tedu Exp $	*/
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.3 2003/08/04 04:49:57 tedu Exp $";
d1999 1
a1999 1
				    "using growfs\n");
@


1.3
log
@spelling, freebsd pr50979 via khalek on irc
@
text
@d1 1
a1 1
/* $OpenBSD: growfs.c,v 1.2 2003/07/29 22:54:26 tedu Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.2 2003/07/29 22:54:26 tedu Exp $";
@


1.2
log
@more pretty
@
text
@d1 1
a1 1
/* $OpenBSD: growfs.c,v 1.1 2003/07/28 21:09:28 tedu Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: growfs.c,v 1.1 2003/07/28 21:09:28 tedu Exp $";
d518 1
a518 1
		 * Count contiguos free fragments.
d932 1
a932 1
		 * cylinder  group we allign the area immediately  after  the
d992 1
a992 1
			 * (incomplete) block of the clinder summary.
d1936 3
a1938 3
	 * Try  to read a label and gess the slice if not  specified.  This
	 * code  should guess the right thing and avaid to bother the  user
	 * user with the task of specifying the option -v on vinum volumes.
d2190 1
a2190 1
 * This updates most paramters and the bitmap related to cluster. We have to
@


1.1
log
@introducing growfs, compliments of freebsd.  cleaned up slightly to obey knf.
requests/oks from many.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD$";
d225 1
a225 1
	printf("super - block backups (for fsck -b #) at:\n");
d236 1
a236 1
		    cylno < (sblock.fs_ncg - 1) ? "," : "" );
d320 1
a320 1
	 * Write out the duplicate super blocks.
d381 1
a381 1
		    howmany(sblock.fs_cpg* sblock.fs_spc / NSPF(&sblock), NBBY);
d432 1
a432 1
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase; ) {
d571 1
a571 1
			*block=(f->new * sblock.fs_frag+(*block % sblock.fs_frag));
d1265 1
a1265 1
				    l++, lcs++ ) {
d1297 2
a1298 2
				clrbit(cg_clustersfree(&acg), d/sblock.fs_frag);
				for (lcs = 0, l=(d/sblock.fs_frag)+1;
d1300 1
a1300 1
				    l++, lcs++ ) {
d1315 2
a1316 2
				bp[ind].old = d/sblock.fs_frag;
				bp[ind].flags|=GFS_FL_LAST;
d1418 1
a1418 2
			DBG_DUMP_HEX(&sblock,
			    "copied full block",
d1422 1
a1422 2
			    bp[i].old,
			    bp[i].new);
d1432 2
a1433 3
			DBG_PRINT1("scg doing cg (%d)\n",
			    cylno);
			for (inc = osblock.fs_ipg - 1 ; inc>=0 ; inc--) {
a1473 1
	return;
a1496 1
	return;
a1521 1
	return;
d1558 4
a1561 4
	blkno=-1;
	dlower = cgsblock(&sblock, acg.cg_cgx)-cgbase(&sblock, acg.cg_cgx);
	dupper = cgdmin(&sblock, acg.cg_cgx)-cgbase(&sblock, acg.cg_cgx);
	dmax = cgbase(&sblock, acg.cg_cgx)+sblock.fs_fpg;
d1565 1
a1565 1
	dmax-=cgbase(&sblock, acg.cg_cgx); /* retransform into cg */
d1569 2
a1570 6
	    dlower,
	    dupper,
	    dmax);
	DBG_PRINT2("range cont: csmin=%d, csmax=%d\n",
	    csmin,
	    csmax);
d1572 1
a1572 1
	for (d = 0; (d < dlower && blkno==-1); d+=sblock.fs_frag) {
d1582 1
a1582 1
	for (d = dupper; (d < dmax && blkno==-1); d+=sblock.fs_frag) {
d1617 1
a1617 1
		    l--, lcs1++ ) {
d1626 1
a1626 1
		    l++, lcs2++ ) {
a1720 1
	return;
a1754 1
	return;
d1869 1
a1869 1
		switch(ch) {
d1874 2
a1875 2
			size=(size_t)atol(optarg);
			if (size<1) {
d1960 2
a1961 3
	rdfs((daddr_t)(SBOFF/DEV_BSIZE), (size_t)SBSIZE, &osblock,
	    fsi);
	if (osblock.fs_magic != FS_MAGIC) {
a1962 1
	}
d1995 1
a1995 1
		for (j = 0; j<FSMAXSNAP; j++) {
d2055 1
a2055 1
	    (sblock.fs_ncg - 1) * sblock.fs_fpg )) {
d2130 1
a2130 1
		ptr=(u_short *)lp;
d2215 1
a2215 1
		for (block--; lcs < sblock.fs_contigsumsize; block--, lcs++ ) {
d2278 1
a2278 1
		iptr=&(ino->di_db[ictr]);
d2308 1
a2308 1
	remaining_blocks-= howmany(sblock.fs_bsize, sizeof(ufs_daddr_t));
d2330 1
a2330 1
			for (ictr = 0; ictr<MIN(howmany((unsigned int)
d2359 1
a2359 1
		    sizeof(ufs_daddr_t)); ind3ctr ++) {
d2369 2
a2370 2
			    sizeof(ufs_daddr_t)); ind2ctr ++) {
				ind2ptr=&((ufs_daddr_t *)&i2blk)[ind2ctr];
@

