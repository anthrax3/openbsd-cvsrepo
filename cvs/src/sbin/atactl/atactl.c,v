head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.10
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.8
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.4
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.44.0.16
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.14
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.10
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.8
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.42.0.8
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.6
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.42.0.4
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.37.0.4
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.35.0.4
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.33.0.4
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.46
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	0qPuuXwccpVXsXcV;

1.45
date	2015.01.16.06.39.56;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	Uu5nFG3wCl0LACBb;

1.44
date	2011.05.04.21.40.07;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2009.04.16.07.40.44;	author grange;	state Exp;
branches;
next	1.41;

1.41
date	2008.08.10.17.40.10;	author sobrado;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.05.21.13.47;	author sobrado;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.02.19.30.19;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.27.21.19.33;	author moritz;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.10.15.22.39;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.16.04.39.35;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.19.21.22.07;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.19.21.17.41;	author grange;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.02.08.37.56;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.10.17.42.59;	author grange;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.20.21.47.27;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.14.23.53.25;	author avsm;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.23.09.36.59;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.22.18.29.56;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.11.19.44.34;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.24.20.36.11;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.16.13.00.51;	author gluk;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.04.14.11.41;	author gluk;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.06.14.46.57;	author gluk;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.15.10.59.06;	author gluk;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.12.50.42;	author gluk;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.08.12.31.54;	author gluk;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.04.23.08.44;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.27.17.42.37;	author gluk;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.30.00.46.36;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.07.18.26.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.04.14.59.47;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.23.02.16.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.13.15.12.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.05.23.41.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.31.22.54.45;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.02.02.52.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.21.04.58.14;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.46
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/*	$OpenBSD: atactl.c,v 1.45 2015/01/16 06:39:56 deraadt Exp $	*/
/*	$NetBSD: atactl.c,v 1.4 1999/02/24 18:49:14 jwise Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ken Hornstein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * atactl(8) - a program to control ATA devices.
 */

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/ioctl.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include <dev/ata/atareg.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcevent.h>
#include <sys/ataio.h>

#include "atasec.h"
#include "atasmart.h"

struct command {
	const char *cmd_name;
	void (*cmd_func)(int, char *[]);
};

struct bitinfo {
	u_int bitmask;
	const char *string;
};

struct valinfo {
	int value;
	const char *string;
};

int  main(int, char *[]);
__dead void usage(void);
void ata_command(struct atareq *);
void print_bitinfo(const char *, u_int, struct bitinfo *);
int  strtoval(const char *, struct valinfo *);
const char *valtostr(int, struct valinfo *);

int	fd;				/* file descriptor for device */

extern char *__progname;		/* from crt0.o */

void    device_dump(int, char*[]);
void	device_identify(int, char *[]);
void	device_setidle(int, char *[]);
void	device_idle(int, char *[]);
void	device_checkpower(int, char *[]);
void	device_acoustic(int, char *[]);
void	device_apm(int, char *[]);
void	device_feature(int, char *[]);
void	device_sec_setpass(int, char *[]);
void	device_sec_unlock(int, char *[]);
void	device_sec_erase(int, char *[]);
void	device_sec_freeze(int, char *[]);
void	device_sec_disablepass(int, char *[]);
void	device_smart_enable(int, char *[]);
void	device_smart_disable(int, char *[]);
void	device_smart_status(int, char *[]);
void	device_smart_autosave(int, char *[]);
void	device_smart_offline(int, char *[]);
void	device_smart_read(int, char *[]);
void	device_smart_readlog(int, char *[]);
void	device_attr(int, char *[]);

void	smart_print_errdata(struct smart_log_errdata *);
int	smart_cksum(u_int8_t *, size_t);

char 	*sec_getpass(int, int);

struct command commands[] = {
	{ "dump",		device_dump },
	{ "identify",		device_identify },
	{ "setidle",		device_setidle },
	{ "setstandby",		device_setidle },
	{ "idle",		device_idle },
	{ "standby",		device_idle },
	{ "sleep",		device_idle },
	{ "checkpower",		device_checkpower },
	{ "acousticdisable",	device_feature },
	{ "acousticset",	device_acoustic },
	{ "apmdisable",		device_feature },
	{ "apmset",		device_apm },
	{ "poddisable",		device_feature },
	{ "podenable",		device_feature },
	{ "puisdisable",	device_feature },
	{ "puisenable",		device_feature },
	{ "puisspinup",		device_feature },
	{ "readaheaddisable",	device_feature },
	{ "readaheadenable",	device_feature },
	{ "secsetpass",		device_sec_setpass },
	{ "secunlock",		device_sec_unlock },
	{ "secerase",		device_sec_erase },
	{ "secfreeze",		device_sec_freeze },
	{ "secdisablepass",	device_sec_disablepass },
	{ "smartenable", 	device_smart_enable },
	{ "smartdisable", 	device_smart_disable },
	{ "smartstatus", 	device_smart_status },
	{ "smartautosave",	device_smart_autosave },
	{ "smartoffline",	device_smart_offline },
	{ "smartread",		device_smart_read },
	{ "smartreadlog",	device_smart_readlog },
	{ "readattr",		device_attr },
	{ "writecachedisable",	device_feature },
	{ "writecacheenable",	device_feature },
	{ NULL,		NULL },
};

/*
 * Tables containing bitmasks used for error reporting and
 * device identification.
 */

struct bitinfo ata_caps[] = {
	{ ATA_CAP_STBY, "ATA standby timer values" },
	{ WDC_CAP_IORDY, "IORDY operation" },
	{ WDC_CAP_IORDY_DSBL, "IORDY disabling" },
	{ 0, NULL },
};

struct bitinfo ata_vers[] = {
	{ WDC_VER_ATA1,	 "ATA-1" },
	{ WDC_VER_ATA2,	 "ATA-2" },
	{ WDC_VER_ATA3,	 "ATA-3" },
	{ WDC_VER_ATA4,	 "ATA-4" },
	{ WDC_VER_ATA5,	 "ATA-5" },
	{ WDC_VER_ATA6,	 "ATA-6" },
	{ WDC_VER_ATA7,	 "ATA-7" },
	{ WDC_VER_ATA8,	 "ATA-8" },
	{ WDC_VER_ATA9,	 "ATA-9" },
	{ WDC_VER_ATA10, "ATA-10" },
	{ WDC_VER_ATA11, "ATA-11" },
	{ WDC_VER_ATA12, "ATA-12" },
	{ WDC_VER_ATA13, "ATA-13" },
	{ WDC_VER_ATA14, "ATA-14" },
	{ 0, NULL },
};

struct bitinfo ata_cmd_set1[] = {
	{ WDC_CMD1_NOP, "NOP command" },
	{ WDC_CMD1_RB, "READ BUFFER command" },
	{ WDC_CMD1_WB, "WRITE BUFFER command" },
	{ WDC_CMD1_HPA, "Host Protected Area feature set" },
	{ WDC_CMD1_DVRST, "DEVICE RESET command" },
	{ WDC_CMD1_SRV, "SERVICE interrupt" },
	{ WDC_CMD1_RLSE, "Release interrupt" },
	{ WDC_CMD1_AHEAD, "Read look-ahead" },
	{ WDC_CMD1_CACHE, "Write cache" },
	{ WDC_CMD1_PKT, "PACKET command feature set" },
	{ WDC_CMD1_PM, "Power Management feature set" },
	{ WDC_CMD1_REMOV, "Removable Media feature set" },
	{ WDC_CMD1_SEC, "Security Mode feature set" },
	{ WDC_CMD1_SMART, "SMART feature set" },
	{ 0, NULL },
};

struct bitinfo ata_cmd_set2[] = {
	{ ATAPI_CMD2_FCE, "Flush Cache Ext command" },
	{ ATAPI_CMD2_FC, "Flush Cache command" },
	{ ATAPI_CMD2_DCO, "Device Configuration Overlay feature set" },
	{ ATAPI_CMD2_48AD, "48bit address feature set" },
	{ ATAPI_CMD2_AAM, "Automatic Acoustic Management feature set" },
	{ ATAPI_CMD2_SM, "Set Max security extension commands" },
	{ ATAPI_CMD2_SF, "Set Features subcommand required" },
	{ ATAPI_CMD2_PUIS, "Power-up in standby feature set" },
	{ WDC_CMD2_RMSN, "Removable Media Status Notification feature set" },
	{ ATA_CMD2_APM, "Advanced Power Management feature set" },
	{ ATA_CMD2_CFA, "CFA feature set" },
	{ ATA_CMD2_RWQ, "READ/WRITE DMA QUEUED commands" },
	{ WDC_CMD2_DM, "DOWNLOAD MICROCODE command" },
	{ 0, NULL },
};

struct bitinfo ata_cmd_ext[] = {
	{ ATAPI_CMDE_IIUF, "IDLE IMMEDIATE with UNLOAD FEATURE" },
	{ ATAPI_CMDE_MSER, "Media serial number" },
	{ ATAPI_CMDE_TEST, "SMART self-test" },
	{ ATAPI_CMDE_SLOG, "SMART error logging" },
	{ 0, NULL },
};

/*
 * Tables containing bitmasks and values used for
 * SMART commands.
 */

struct bitinfo smart_offcap[] = {
	{ SMART_OFFCAP_EXEC, "execute immediate" },
	{ SMART_OFFCAP_ABORT, "abort/restart" },
	{ SMART_OFFCAP_READSCAN, "read scanning" },
	{ SMART_OFFCAP_SELFTEST, "self-test routines" },
	{ 0, NULL}
};

struct bitinfo smart_smartcap[] = {
	{ SMART_SMARTCAP_SAVE, "saving SMART data" },
	{ SMART_SMARTCAP_AUTOSAVE, "enable/disable attribute autosave" },
	{ 0, NULL }
};

struct valinfo smart_autosave[] = {
	{ SMART_AUTOSAVE_EN, "enable" },
	{ SMART_AUTOSAVE_DS, "disable" },
	{ 0, NULL }
};

struct valinfo smart_offline[] = {
	{ SMART_OFFLINE_COLLECT, "collect" },
	{ SMART_OFFLINE_SHORTOFF, "shortoffline" },
	{ SMART_OFFLINE_EXTENOFF, "extenoffline" },
	{ SMART_OFFLINE_ABORT, "abort" },
	{ SMART_OFFLINE_SHORTCAP, "shortcaptive" },
	{ SMART_OFFLINE_EXTENCAP, "extencaptive" },
	{ 0, NULL }
};

struct valinfo smart_readlog[] = {
	{ SMART_READLOG_DIR, "directory" },
	{ SMART_READLOG_SUM, "summary" },
	{ SMART_READLOG_COMP, "comp" },
	{ SMART_READLOG_SELF, "selftest" },
	{ 0, NULL }
};

struct valinfo smart_offstat[] = {
	{ SMART_OFFSTAT_NOTSTART, "never started" },
	{ SMART_OFFSTAT_COMPLETE, "completed ok" },
	{ SMART_OFFSTAT_SUSPEND, "suspended by an interrupting command" },
	{ SMART_OFFSTAT_INTR, "aborted by an interrupting command" },
	{ SMART_OFFSTAT_ERROR, "aborted due to fatal error" },
	{ 0, NULL }
};

struct valinfo smart_selfstat[] = {
	{ SMART_SELFSTAT_COMPLETE, "completed ok or not started" },
	{ SMART_SELFSTAT_ABORT, "aborted" },
	{ SMART_SELFSTAT_INTR, "hardware or software reset" },
	{ SMART_SELFSTAT_ERROR, "fatal error" },
	{ SMART_SELFSTAT_UNKFAIL, "unknown test element failed" },
	{ SMART_SELFSTAT_ELFAIL, "electrical test element failed" },
	{ SMART_SELFSTAT_SRVFAIL, "servo test element failed" },
	{ SMART_SELFSTAT_RDFAIL, "read test element failed" },
	{ 0, NULL }
};

struct valinfo smart_logstat[] = {
	{ SMART_LOG_STATE_UNK, "unknown" },
	{ SMART_LOG_STATE_SLEEP, "sleep" },
	{ SMART_LOG_STATE_ACTIDL, "active/idle" },
	{ SMART_LOG_STATE_OFFSELF, "off-line or self-test" },
	{ 0, NULL }
};

/*
 * Tables containing values used for reading
 * device attributes.
 */

struct valinfo ibm_attr_names[] = {
	{ 1, "Raw Read Error Rate" },
	{ 2, "Throughput Performance" },
	{ 3, "Spin Up Time" },
	{ 4, "Start/Stop Count" },
	{ 5, "Reallocated Sector Count" },
	{ 6, "Read Channel Margin" },
	{ 7, "Seek Error Rate" },
	{ 8, "Seek Time Performance" },
	{ 9, "Power-On Hours Count" },
	{ 10, "Spin Retry Count" },
	{ 11, "Calibration Retry Count" },
	{ 12, "Device Power Cycle Count" },
	{ 13, "Soft Read Error Rate" },
	{ 189, "High Fly Writes" },
	{ 190, "Airflow Temperature" },
	{ 191, "G-Sense Error Rate" },
	{ 192, "Power-Off Retract Count" },
	{ 193, "Load Cycle Count" },
	{ 194, "Temperature" },
	{ 195, "Hardware ECC Recovered" },
	{ 196, "Reallocation Event Count" },
	{ 197, "Current Pending Sector Count" },
	{ 198, "Off-Line Scan Uncorrectable Sector Count" },
	{ 199, "Ultra DMA CRC Error Count" },
	{ 200, "Write Error Rate" },
	{ 201, "Soft Read Error Rate" },
	{ 202, "Data Address Mark Errors" },
	{ 203, "Run Out Cancel" },
	{ 204, "Soft ECC Correction" },
	{ 205, "Thermal Asperity Check" },
	{ 206, "Flying Height" },
	{ 207, "Spin High Current" },
	{ 208, "Spin Buzz" },
	{ 209, "Offline Seek Performance" },
	{ 220, "Disk Shift" },
	{ 221, "G-Sense Error Rate" },
	{ 222, "Loaded Hours" },
	{ 223, "Load/Unload Retry Count" },
	{ 224, "Load Friction" },
	{ 225, "Load/Unload Cycle Count" },
	{ 226, "Load-In Time" },
	{ 227, "Torque Amplification Count" },
	{ 228, "Power-Off Retract Count" },
	{ 230, "GMR Head Amplitude" },
	{ 231, "Temperature" },
	{ 240, "Head Flying Hours" },
	{ 250, "Read Error Retry Rate" },
	{ 0, NULL },
};

#define MAKEWORD(b1, b2) \
	(b2 << 8 | b1)
#define MAKEDWORD(b1, b2, b3, b4) \
	(b4 << 24 | b3 << 16 | b2 << 8 | b1)

int
main(int argc, char *argv[])
{
	struct command	*cmdp;

	if (argc < 2)
		usage();

	/*
	 * Open the device
	 */
	if ((fd = opendev(argv[1], O_RDWR, OPENDEV_PART, NULL)) == -1)
		err(1, "%s", argv[1]);

	/* Skip program name and device name. */
	if (argc != 2) {
		argv += 2;
		argc -= 2;
	} else {
		argv[1] = "identify";
		argv += 1;
		argc -= 1;
	}

	/* Look up and call the command. */
	for (cmdp = commands; cmdp->cmd_name != NULL; cmdp++)
		if (strcmp(argv[0], cmdp->cmd_name) == 0)
			break;
	if (cmdp->cmd_name == NULL)
		errx(1, "unknown command: %s", argv[0]);

	(cmdp->cmd_func)(argc, argv);

	return (0);
}

__dead void
usage(void)
{

	fprintf(stderr, "usage: %s device [command [arg]]\n", __progname);
	exit(1);
}

/*
 * Wrapper that calls ATAIOCCOMMAND and checks for errors
 */
void
ata_command(struct atareq *req)
{
	if (ioctl(fd, ATAIOCCOMMAND, req) == -1)
		err(1, "ATAIOCCOMMAND failed");

	switch (req->retsts) {

	case ATACMD_OK:
		return;
	case ATACMD_TIMEOUT:
		errx(1, "ATA command timed out");
	case ATACMD_DF:
		errx(1, "ATA device returned a Device Fault");
	case ATACMD_ERROR:
		if (req->error & WDCE_ABRT)
			errx(1, "ATA device returned Aborted Command");
		else
			errx(1, "ATA device returned error register %0x",
			    req->error);
	default:
		errx(1, "ATAIOCCOMMAND returned unknown result code %d",
		    req->retsts);
	}
}

/*
 * Print out strings associated with particular bitmasks
 */
void
print_bitinfo(const char *f, u_int bits, struct bitinfo *binfo)
{

	for (; binfo->bitmask != 0; binfo++)
		if (bits & binfo->bitmask)
			printf(f, binfo->string);
}

/*
 * strtoval():
 *    returns value associated with given string,
 *    if no value found -1 is returned.
 */
int
strtoval(const char *str, struct valinfo *vinfo)
{
	for (; vinfo->string != NULL; vinfo++)
		if (strcmp(str, vinfo->string) == 0)
			return (vinfo->value);
	return (-1);
}

/*
 * valtostr():
 *    returns string associated with given value,
 *    if no string found NULL is returned.
 */
const char *
valtostr(int val, struct valinfo *vinfo)
{
	for (; vinfo->string != NULL; vinfo++)
		if (val == vinfo->value)
			return (vinfo->string);
	return (NULL);
}

/*
 * DEVICE COMMANDS
 */

/*
 * device dump:
 *
 * extract issued ATA requests from the log buffer
 */
void
device_dump(int argc, char *argv[])
{
	unsigned char buf[131072];
	atagettrace_t agt;
	unsigned int total;
	unsigned int p = 0;
	int type;
	const char *types[] = { NULL, "status", "error", "ATAPI",
	    "ATAPI done", "ATA cmd", "ATA", "select slave",
	    "select master", "register read", "ATA LBA48" };
	int num_types = sizeof(types) / sizeof(types[0]);
	int info;
	int entrysize;
	int i;
	int flags;

	if (argc != 1)
		goto usage;

	memset(&agt, 0, sizeof(agt));
	agt.buf_size = sizeof(buf);
	agt.buf = buf;

	if (ioctl(fd, ATAIOGETTRACE, &agt) == -1)
		err(1, "ATAIOGETTRACE failed");

	total = agt.bytes_copied;

	/* Parse entries */
	while (p < total) {
		type = buf[p++];
		if (p >= total)
			return;
		if (type <= 0 || type >= num_types)
			return;

		info = buf[p++];
		if (p >= total)
			return;
		entrysize = (info & 0x1f);

		printf ("ch %d", (info >> 5) & 0x7);
		printf(": %s", types[type]);

		switch (type) {
		case WDCEVENT_STATUS:
			if (entrysize != 1)
				return;

			printf(": 0x%x", buf[p]);
			if (buf[p] & WDCS_BSY)
				printf(" BSY");
			if (buf[p] & WDCS_DRDY)
				printf(" DRDY");
			if (buf[p] & WDCS_DWF)
				printf(" DWF");
			if (buf[p] & WDCS_DSC)
				printf(" DSC");
			if (buf[p] & WDCS_DRQ)
				printf(" DRQ");
			if (buf[p] & WDCS_CORR)
				printf(" CORR");
			if (buf[p] & WDCS_IDX)
				printf(" IDX");
			if (buf[p] & WDCS_ERR)
				printf(" ERR");

			p++;
			entrysize = 0;
			break;
		case WDCEVENT_ERROR:
			if (entrysize != 1)
				return;

			printf(": 0x%x", buf[p]);
			if (buf[p] & WDCE_BBK)
				printf(" BBK/CRC");
			if (buf[p] & WDCE_UNC)
				printf(" UNC");
			if (buf[p] & WDCE_MC)
				printf(" MC");
			if (buf[p] & WDCE_IDNF)
				printf(" IDNF");
			if (buf[p] & WDCE_MCR)
				printf(" MCR");
			if (buf[p] & WDCE_ABRT)
				printf(" ABRT");
			if (buf[p] & WDCE_TK0NF)
				printf(" TK0NF");
			if (buf[p] & WDCE_AMNF)
				printf(" AMNF");

			p++;
			entrysize = 0;
			break;
		case WDCEVENT_ATAPI_CMD:
			if (entrysize < 2 || p + 2 > total)
				return;

			flags = (buf[p] << 8) + buf[p + 1];
			printf(": flags 0x%x", flags);
			if (flags & 0x0100)
				printf(" MEDIA");
			if (flags & 0x0080)
				printf(" SENSE");
			if (flags & 0x0040)
				printf(" DMA");
			if (flags & 0x0020)
				printf(" POLL");
			if (flags & 0x0004)
				printf(" TIMEOUT");
			if (flags & 0x0002)
				printf(" ATAPI");

			p += 2;
			entrysize -= 2;
			break;
		case WDCEVENT_ATAPI_DONE:
			if (entrysize != 3 || p + 3 > total)
				return;

			flags = (buf[p] << 8) + buf[p + 1];
			printf(": flags 0x%x", flags);
			if (flags & 0x0100)
				printf(" MEDIA");
			if (flags & 0x0080)
				printf(" SENSE");
			if (flags & 0x0040)
				printf(" DMA");
			if (flags & 0x0020)
				printf(" POLL");
			if (flags & 0x0004)
				printf(" TIMEOUT");
			if (flags & 0x0002)
				printf(" ATAPI");

			printf(", error 0x%x", buf[p + 2]);
			switch (buf[p + 2]) {
			case 1:
				printf(" (sense)");
				break;
			case 2:
				printf(" (driver failure)");
				break;
			case 3:
				printf(" (timeout)");
				break;
			case 4:
				printf(" (busy)");
				break;
			case 5:
				printf(" (ATAPI sense)");
				break;
			case 8:
				printf(" (reset)");
				break;
			}

			p += 3;
			entrysize  = 0;
			break;
		case WDCEVENT_ATA_LONG:
			if (entrysize != 7 || p + 7 > total)
				return;

			printf(": ");
			switch (buf[p + 6]) {
			case WDCC_READDMA:
				printf("READ DMA");
				break;
			case WDCC_WRITEDMA:
				printf("WRITE DMA");
				break;
			default:
				printf("CMD 0x%x", buf[p + 6]);
			}
			printf(" head %d, precomp %d, cyl_hi %d, "
			    "cyl_lo %d, sec %d, cnt %d",
			    buf[p], buf[p + 1], buf[p + 2], buf[p + 3],
			    buf[p + 4], buf[p + 5]);

			p += 7;
			entrysize = 0;
			break;
		case WDCEVENT_REG:
			if (entrysize != 3 || p + 3 > total)
				return;

			switch (buf[p]) {
			case 1:
				printf(": error");
				break;
			case 2:
				printf(": ireason");
				break;
			case 3:
				printf(": lba_lo");
				break;
			case 4:
				printf(": lba_mi");
				break;
			case 5:
				printf(": lba_hi");
				break;
			case 6:
				printf(": sdh");
				break;
			case 7:
				printf(": status");
				break;
			case 8:
				printf(": altstatus");
				break;
			default:
				printf(": unknown register %d", buf[p]);
			}
			printf(": 0x%x", (buf[p + 1] << 8) + buf[p + 2]);

			p += 3;
			entrysize = 0;
			break;
		case WDCEVENT_ATA_EXT:
			if (entrysize != 9 || p + 9 > total)
				return;

			printf(": ");
			switch (buf[p + 8]) {
			case WDCC_READDMA_EXT:
				printf("READ DMA EXT");
				break;
			case WDCC_WRITEDMA_EXT:
				printf("WRITE DMA EXT");
				break;
			default:
				printf("CMD 0x%x", buf[p + 8]);
			}
			printf(" lba_hi1 %d, lba_hi2 %d, "
			    "lba_mi1 %d, lba_mi2 %d, lba_lo1 %d, lba_lo2 %d, "
			    "count1 %d, count2 %d",
			    buf[p], buf[p + 1], buf[p + 2], buf[p + 3],
			    buf[p + 4], buf[p + 5], buf[p + 6],
			    buf[p + 7]);

			p += 9;
			entrysize = 0;
			break;
		}

		if (entrysize > 0)
			printf(":");
		for (i = 0; i < entrysize; i++) {
			printf (" 0x%02x", buf[p]);
			if (++p >= total)
				break;
		}
		printf("\n");
	}

	return;

usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * device_identify:
 *
 *	Display the identity of the device
 */
void
device_identify(int argc, char *argv[])
{
	struct ataparams *inqbuf;
	struct atareq req;
	char inbuf[DEV_BSIZE];
	u_int64_t capacity;
	u_int8_t *s;

	if (argc != 1)
		goto usage;

	memset(&inbuf, 0, sizeof(inbuf));
	memset(&req, 0, sizeof(req));

	inqbuf = (struct ataparams *) inbuf;

	req.flags = ATACMD_READ;
	req.command = WDCC_IDENTIFY;
	req.databuf = (caddr_t) inbuf;
	req.datalen = sizeof(inbuf);
	req.timeout = 1000;

	ata_command(&req);

	if (BYTE_ORDER == BIG_ENDIAN) {
		swap16_multi((u_int16_t *)inbuf, 10);
		swap16_multi(((u_int16_t *)inbuf) + 20, 3);
		swap16_multi(((u_int16_t *)inbuf) + 47, sizeof(inbuf) / 2 - 47);
	}

	if (!((inqbuf->atap_config & WDC_CFG_ATAPI_MASK) == WDC_CFG_ATAPI &&
	      ((inqbuf->atap_model[0] == 'N' &&
		  inqbuf->atap_model[1] == 'E') ||
	       (inqbuf->atap_model[0] == 'F' &&
		  inqbuf->atap_model[1] == 'X')))) {
		swap16_multi((u_int16_t *)(inqbuf->atap_model),
		    sizeof(inqbuf->atap_model) / 2);
		swap16_multi((u_int16_t *)(inqbuf->atap_serial),
		    sizeof(inqbuf->atap_serial) / 2);
		swap16_multi((u_int16_t *)(inqbuf->atap_revision),
		    sizeof(inqbuf->atap_revision) / 2);
	}

	/*
	 * Strip blanks off of the info strings.
	 */

	for (s = &inqbuf->atap_model[sizeof(inqbuf->atap_model) - 1];
	    s >= inqbuf->atap_model && *s == ' '; s--)
		*s = '\0';

	for (s = &inqbuf->atap_revision[sizeof(inqbuf->atap_revision) - 1];
	    s >= inqbuf->atap_revision && *s == ' '; s--)
		*s = '\0';

	for (s = &inqbuf->atap_serial[sizeof(inqbuf->atap_serial) - 1];
	    s >= inqbuf->atap_serial && *s == ' '; s--)
		*s = '\0';

	printf("Model: %.*s, Rev: %.*s, Serial #: %.*s\n",
	    (int) sizeof(inqbuf->atap_model), inqbuf->atap_model,
	    (int) sizeof(inqbuf->atap_revision), inqbuf->atap_revision,
	    (int) sizeof(inqbuf->atap_serial), inqbuf->atap_serial);

	printf("Device type: %s, %s\n", inqbuf->atap_config & WDC_CFG_ATAPI ?
	       "ATAPI" : "ATA", inqbuf->atap_config & ATA_CFG_FIXED ? "fixed" :
	       "removable");

	if (inqbuf->atap_cmd2_en & ATAPI_CMD2_48AD)
		capacity = ((u_int64_t)inqbuf->atap_max_lba[3] << 48) |
		    ((u_int64_t)inqbuf->atap_max_lba[2] << 32) |
		    ((u_int64_t)inqbuf->atap_max_lba[1] << 16) |
		    (u_int64_t)inqbuf->atap_max_lba[0];
	else
		capacity = (inqbuf->atap_capacity[1] << 16) |
		    inqbuf->atap_capacity[0];
	printf("Cylinders: %d, heads: %d, sec/track: %d, total "
	    "sectors: %llu\n", inqbuf->atap_cylinders,
	    inqbuf->atap_heads, inqbuf->atap_sectors, capacity);

	if ((inqbuf->atap_cmd_set2 & ATA_CMD2_RWQ) &&
	    (inqbuf->atap_queuedepth & WDC_QUEUE_DEPTH_MASK))
		printf("Device supports command queue depth of %d\n",
		    (inqbuf->atap_queuedepth & WDC_QUEUE_DEPTH_MASK) + 1);

	printf("Device capabilities:\n");
	print_bitinfo("\t%s\n", inqbuf->atap_capabilities1, ata_caps);

	if (inqbuf->atap_ata_major != 0 && inqbuf->atap_ata_major != 0xffff) {
		printf("Device supports the following standards:\n");
		print_bitinfo("%s ", inqbuf->atap_ata_major, ata_vers);
		printf("\n");
	}

	if ((inqbuf->atap_cmd_set1 & WDC_CMD1_SEC) &&
	    inqbuf->atap_mpasswd_rev != 0 &&
	    inqbuf->atap_mpasswd_rev != 0xffff)
		printf("Master password revision code 0x%04x\n",
		    inqbuf->atap_mpasswd_rev);

	if (inqbuf->atap_cmd_set1 != 0 && inqbuf->atap_cmd_set1 != 0xffff &&
	    inqbuf->atap_cmd_set2 != 0 && inqbuf->atap_cmd_set2 != 0xffff) {
		printf("Device supports the following command sets:\n");
		print_bitinfo("\t%s\n", inqbuf->atap_cmd_set1, ata_cmd_set1);
		print_bitinfo("\t%s\n", inqbuf->atap_cmd_set2, ata_cmd_set2);
		print_bitinfo("\t%s\n", inqbuf->atap_cmd_ext, ata_cmd_ext);
	}

	if (inqbuf->atap_cmd_def != 0 && inqbuf->atap_cmd_def != 0xffff) {
		printf("Device has enabled the following command "
		    "sets/features:\n");
		print_bitinfo("\t%s\n", inqbuf->atap_cmd1_en, ata_cmd_set1);
		print_bitinfo("\t%s\n", inqbuf->atap_cmd2_en, ata_cmd_set2);
	}

	return;

usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * device idle:
 *
 * issue the IDLE IMMEDIATE command to the drive
 */
void
device_idle(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	if (strcmp(argv[0], "idle") == 0)
		req.command = WDCC_IDLE_IMMED;
	else if (strcmp(argv[0], "standby") == 0)
		req.command = WDCC_STANDBY_IMMED;
	else
		req.command = WDCC_SLEEP;

	req.timeout = 1000;

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * SECURITY SET PASSWORD command
 */
void
device_sec_setpass(int argc, char *argv[])
{
	struct atareq req;
	struct sec_password pwd;
	char *pass, inbuf[DEV_BSIZE];
	struct ataparams *inqbuf = (struct ataparams *)inbuf;

	if (argc < 2)
		goto usage;

	memset(&pwd, 0, sizeof(pwd));

	if (strcmp(argv[1], "user") == 0 && argc == 3)
		pwd.ctrl |= SEC_PASSWORD_USER;
	else if (strcmp(argv[1], "master") == 0 && argc == 2)
		pwd.ctrl |= SEC_PASSWORD_MASTER;
	else
		goto usage;
	if (argc == 3) {
		if (strcmp(argv[2], "high") == 0)
			pwd.ctrl |= SEC_LEVEL_HIGH;
		else if (strcmp(argv[2], "maximum") == 0)
			pwd.ctrl |= SEC_LEVEL_MAX;
		else
			goto usage;
	}

	/*
	 * Issue IDENTIFY command to obtain master password
	 * revision code and decrement its value.
	 * The valid revision codes are 0x0001 through 0xfffe.
	 * If the device returns 0x0000 or 0xffff as a revision
	 * code then the master password revision code is not
	 * supported so don't touch it.
	 */
	memset(&inbuf, 0, sizeof(inbuf));
	memset(&req, 0, sizeof(req));

	req.command = WDCC_IDENTIFY;
	req.timeout = 1000;
	req.flags = ATACMD_READ;
	req.databuf = (caddr_t)inbuf;
	req.datalen = sizeof(inbuf);

	ata_command(&req);

	pwd.revision = inqbuf->atap_mpasswd_rev;
	if (pwd.revision != 0 && pwd.revision != 0xffff && --pwd.revision == 0)
		pwd.revision = 0xfffe;

	pass = sec_getpass(pwd.ctrl & SEC_PASSWORD_MASTER, 1);
	memcpy(pwd.password, pass, strlen(pass));

	memset(&req, 0, sizeof(req));

	req.command = ATA_SEC_SET_PASSWORD;
	req.timeout = 1000;
	req.flags = ATACMD_WRITE;
	req.databuf = (caddr_t)&pwd;
	req.datalen = sizeof(pwd);

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s user high | maximum\n",
	    __progname, argv[0]);
	fprintf(stderr, "       %s device %s master\n", __progname, argv[0]);
	exit(1);
}

/*
 * SECURITY UNLOCK command
 */
void
device_sec_unlock(int argc, char *argv[])
{
	struct atareq req;
	struct sec_password pwd;
	char *pass;

	if (argc != 2)
		goto usage;

	memset(&pwd, 0, sizeof(pwd));

	if (strcmp(argv[1], "user") == 0)
		pwd.ctrl |= SEC_PASSWORD_USER;
	else if (strcmp(argv[1], "master") == 0)
		pwd.ctrl |= SEC_PASSWORD_MASTER;
	else
		goto usage;

	pass = sec_getpass(pwd.ctrl & SEC_PASSWORD_MASTER, 0);
	memcpy(pwd.password, pass, strlen(pass));

	memset(&req, 0, sizeof(req));

	req.command = ATA_SEC_UNLOCK;
	req.timeout = 1000;
	req.flags = ATACMD_WRITE;
	req.databuf = (caddr_t)&pwd;
	req.datalen = sizeof(pwd);

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s user | master\n", __progname,
	    argv[0]);
	exit(1);
}

/*
 * SECURITY ERASE UNIT command
 */
void
device_sec_erase(int argc, char *argv[])
{
	struct atareq req;
	struct sec_password pwd;
	char *pass;

	if (argc < 2)
		goto usage;

	memset(&pwd, 0, sizeof(pwd));

	if (strcmp(argv[1], "user") == 0)
		pwd.ctrl |= SEC_PASSWORD_USER;
	else if (strcmp(argv[1], "master") == 0)
		pwd.ctrl |= SEC_PASSWORD_MASTER;
	else
		goto usage;
	if (argc == 2)
		pwd.ctrl |= SEC_ERASE_NORMAL;
	else if (argc == 3 && strcmp(argv[2], "enhanced") == 0)
		pwd.ctrl |= SEC_ERASE_ENHANCED;
	else
		goto usage;

	pass = sec_getpass(pwd.ctrl & SEC_PASSWORD_MASTER, 0);
	memcpy(pwd.password, pass, strlen(pass));

	 /* Issue SECURITY ERASE PREPARE command before */
	memset(&req, 0, sizeof(req));

	req.command = ATA_SEC_ERASE_PREPARE;
	req.timeout = 1000;

	ata_command(&req);

	memset(&req, 0, sizeof(req));

	req.command = ATA_SEC_ERASE_UNIT;
	req.timeout = 1000;
	req.flags = ATACMD_WRITE;
	req.databuf = (caddr_t)&pwd;
	req.datalen = sizeof(pwd);

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s user | master [enhanced]\n",
	    __progname, argv[0]);
	exit(1);
}

/*
 * SECURITY FREEZE LOCK command
 */
void
device_sec_freeze(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = ATA_SEC_FREEZE_LOCK;
	req.timeout = 1000;

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * SECURITY DISABLE PASSWORD command
 */
void
device_sec_disablepass(int argc, char *argv[])
{
	struct atareq req;
	struct sec_password pwd;
	char *pass;

	if (argc != 2)
		goto usage;

	memset(&pwd, 0, sizeof(pwd));

	if (strcmp(argv[1], "user") == 0)
		pwd.ctrl |= SEC_PASSWORD_USER;
	else if (strcmp(argv[1], "master") == 0)
		pwd.ctrl |= SEC_PASSWORD_MASTER;
	else
		goto usage;

	pass = sec_getpass(pwd.ctrl & SEC_PASSWORD_MASTER, 0);
	memcpy(pwd.password, pass, strlen(pass));

	memset(&req, 0, sizeof(req));

	req.command = ATA_SEC_DISABLE_PASSWORD;
	req.timeout = 1000;
	req.flags = ATACMD_WRITE;
	req.databuf = (caddr_t)&pwd;
	req.datalen = sizeof(pwd);

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s user | master\n", __progname,
	    argv[0]);
	exit(1);
}

char *
sec_getpass(int ident, int confirm)
{
	char *pass, buf[33];

	if ((pass = getpass(ident ? "Master password:" :
	    "User password:")) == NULL)
		err(1, "getpass()");
	if (strlen(pass) > 32)
		errx(1, "password too long");
	if (confirm) {
		strlcpy(buf, pass, sizeof(buf));
		if ((pass = getpass(ident ? "Retype master password:" :
		    "Retype user password:")) == NULL)
			err(1, "getpass()");
		if (strcmp(pass, buf) != 0)
			errx(1, "password mismatch");
	}

	return (pass);
}

/*
 * SMART ENABLE OPERATIONS command
 */
void
device_smart_enable(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_EN;

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * SMART DISABLE OPERATIONS command
 */
void
device_smart_disable(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_DS;

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * SMART STATUS command
 */
void
device_smart_status(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_STATUS;

	ata_command(&req);

	if (req.cylinder == 0xc24f)
		printf("No SMART threshold exceeded\n");
	else if (req.cylinder == 0x2cf4) {
		errx(2, "SMART threshold exceeded!");
	} else {
		errx(1, "Unknown response %02x!", req.cylinder);
	}

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * SMART ENABLE/DISABLE ATTRIBUTE AUTOSAVE command
 */
void
device_smart_autosave(int argc, char *argv[])
{
	struct atareq req;
	int val;

	if (argc != 2)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_AUTOSAVE;
	if ((val = strtoval(argv[1], smart_autosave)) == -1)
		goto usage;
	req.sec_num = val;

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s enable | disable\n", __progname,
	    argv[0]);
	exit(1);
}

/*
 * SMART EXECUTE OFF-LINE IMMEDIATE command
 */
void
device_smart_offline(int argc, char *argv[])
{
	struct atareq req;
	int val;

	if (argc != 2)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_OFFLINE;
	if ((val = strtoval(argv[1], smart_offline)) == -1)
		goto usage;
	req.sec_num = val;

	ata_command(&req);

	return;
usage:
	fprintf(stderr, "usage: %s device %s subcommand\n", __progname,
	    argv[0]);
	exit(1);
}

/*
 * SMART READ DATA command
 */
void
device_smart_read(int argc, char *argv[])
{
	struct atareq req;
	struct smart_read data;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));
	memset(&data, 0, sizeof(data));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_READ;
	req.flags = ATACMD_READ;
	req.databuf = (caddr_t)&data;
	req.datalen = sizeof(data);

	ata_command(&req);

	if (smart_cksum((u_int8_t *)&data, sizeof(data)) != 0)
		errx(1, "Checksum mismatch");

	printf("Off-line data collection:\n");
	printf("    status: %s\n",
	    valtostr(data.offstat & 0x7f, smart_offstat));
	printf("    activity completion time: %d seconds\n",
	    letoh16(data.time));
	printf("    capabilities:\n");
	print_bitinfo("\t%s\n", data.offcap, smart_offcap);
	printf("Self-test execution:\n");
	printf("    status: %s\n", valtostr(SMART_SELFSTAT_STAT(data.selfstat),
	    smart_selfstat));
	if (SMART_SELFSTAT_STAT(data.selfstat) == SMART_SELFSTAT_PROGRESS)
		printf("remains %d%% of total time\n",
		    SMART_SELFSTAT_PCNT(data.selfstat));
	printf("    recommended polling time:\n");
	printf("\tshort routine: %d minutes\n", data.shtime);
	printf("\textended routine: %d minutes\n", data.extime);
	printf("SMART capabilities:\n");
	print_bitinfo("    %s\n", letoh16(data.smartcap), smart_smartcap);
	printf("Error logging: ");
	if (data.errcap & SMART_ERRCAP_ERRLOG)
		printf("supported\n");
	else
		printf("not supported\n");

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * SMART READ LOG command
 */
void
device_smart_readlog(int argc, char *argv[])
{
	struct atareq req;
	int val;
	u_int8_t inbuf[DEV_BSIZE];

	if (argc != 2)
		goto usage;

	memset(&req, 0, sizeof(req));
	memset(&inbuf, 0, sizeof(inbuf));

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;
	req.timeout = 1000;
	req.features = ATA_SMART_READLOG;
	req.flags = ATACMD_READ;
	req.sec_count = 1;
	req.databuf = (caddr_t)inbuf;
	req.datalen = sizeof(inbuf);
	if ((val = strtoval(argv[1], smart_readlog)) == -1)
		goto usage;
	req.sec_num = val;

	ata_command(&req);

	if (strcmp(argv[1], "directory") == 0) {
		struct smart_log_dir *data = (struct smart_log_dir *)inbuf;
		int i;

		if (data->version != SMART_LOG_MSECT) {
			printf("Device doesn't support multi-sector logs\n");
			return;
		}

		for (i = 0; i < 255; i++)
			printf("Log address %d: %d sectors\n", i + 1,
			    data->entry[i].sec_num);
	} else if (strcmp(argv[1], "summary") == 0) {
		struct smart_log_sum *data = (struct smart_log_sum *)inbuf;
		int i, n, nerr;

		if (smart_cksum(inbuf, sizeof(inbuf)) != 0)
			errx(1, "Checksum mismatch");

		if (data->index == 0) {
			printf("No log entries\n");
			return;
		}

		nerr = letoh16(data->err_cnt);
		printf("Error count: %d\n\n", nerr);
		/*
		 * Five error log data structures form a circular
		 * buffer. data->index points to the most recent
		 * record and err_cnt contains total error number.
		 * We pass from the most recent record to the
		 * latest one.
		 */
		i = data->index - 1;
		n = 0;
		do {
			printf("Error %d:\n", n + 1);
			smart_print_errdata(&data->errdata[i--]);
			if (i == -1)
				i = 4;
		} while (++n < (nerr > 5 ? 5 : nerr));
	} else if (strcmp(argv[1], "comp") == 0) {
		struct smart_log_comp *data = (struct smart_log_comp *)inbuf;
		u_int8_t *newbuf;
		int i, n, nerr, nsect;

		if (smart_cksum(inbuf, sizeof(inbuf)) != 0)
			errx(1, "Checksum mismatch");

		if (data->index == 0) {
			printf("No log entries\n");
			return;
		}

		i = data->index - 1;
		nerr = letoh16(data->err_cnt);
		printf("Error count: %d\n", nerr);
		/*
		 * From the first sector we obtain total error number
		 * and calculate necessary number of sectors to read.
		 * All read error data structures form a circular
		 * buffer and we pass from the most recent record to
		 * the latest one.
		 */
		nsect = nerr / 5 + (nerr % 5 != 0 ? 1 : 0);
		if ((newbuf = calloc(nsect, DEV_BSIZE)) == NULL)
			err(1, "calloc()");
		memset(&req, 0, sizeof(req));
		req.flags = ATACMD_READ;
		req.command = ATAPI_SMART;
		req.features = ATA_SMART_READLOG;
		req.sec_count = nsect;
		req.sec_num = SMART_READLOG_COMP;
		req.cylinder = 0xc24f;
		req.databuf = (caddr_t)newbuf;
		req.datalen = nsect * DEV_BSIZE;
		req.timeout = 1000;
		ata_command(&req);

		n = 0;
		data = (struct smart_log_comp *)
		    (newbuf + (nsect - 1) * DEV_BSIZE);
		do {
			printf("Error %d:\n", n + 1);
			smart_print_errdata(&data->errdata[i-- % 5]);
			if (i == -1)
				i = 254;
			if (i % 5 == 4)
				data = (struct smart_log_comp *)
				    (newbuf + (i / 5) * DEV_BSIZE);
		} while (++n < nerr);
	} else if (strcmp(argv[1], "selftest") == 0) {
		struct smart_log_self *data = (struct smart_log_self *)inbuf;
		int i, n;

		if (smart_cksum(inbuf, sizeof(inbuf)) != 0)
			errx(1, "Checksum mismatch");

		if (data->index == 0) {
			printf("No log entries\n");
			return;
		}

		/* circular buffer of 21 entries */
		i = data->index - 1;
		n = 0;
		do {
			/* don't print empty entries */
			if ((data->desc[i].time1 | data->desc[i].time2) == 0)
				break;
			printf("Test %d\n", n + 1);
			printf("    LBA Low: 0x%x\n", data->desc[i].reg_lbalo);
			printf("    status: %s\n",
			    valtostr(SMART_SELFSTAT_STAT(
			    data->desc[i].selfstat),
			    smart_selfstat));
			printf("    timestamp: %d\n",
			    MAKEWORD(data->desc[i].time1,
				     data->desc[i].time2));
			printf("    failure checkpoint byte: 0x%x\n",
			    data->desc[i].chkpnt);
			printf("    failing LBA: 0x%x\n",
			    MAKEDWORD(data->desc[i].lbafail1,
				      data->desc[i].lbafail2,
				      data->desc[i].lbafail3,
				      data->desc[i].lbafail4));
			if (--i == -1)
				i = 20;
		} while (++n < 21);
	}

	return;
usage:
	fprintf(stderr, "usage: %s device %s log\n", __progname, argv[0]);
	exit(1);
}

#define SMART_PRINTREG(str, reg)				\
	printf(str "0x%02x\t0x%02x\t0x%02x\t0x%02x\t0x%02x\n",	\
	    data->cmd[0].reg,					\
	    data->cmd[1].reg,					\
	    data->cmd[2].reg,					\
	    data->cmd[3].reg,					\
	    data->cmd[4].reg)

void
smart_print_errdata(struct smart_log_errdata *data)
{
	printf("    error register: 0x%x\n", data->err.reg_err);
	printf("    sector count register: 0x%x\n", data->err.reg_seccnt);
	printf("    LBA Low register: 0x%x\n", data->err.reg_lbalo);
	printf("    LBA Mid register: 0x%x\n", data->err.reg_lbamid);
	printf("    LBA High register: 0x%x\n", data->err.reg_lbahi);
	printf("    device register: 0x%x\n", data->err.reg_dev);
	printf("    status register: 0x%x\n", data->err.reg_stat);
	printf("    state: %s\n", valtostr(data->err.state, smart_logstat));
	printf("    timestamp: %d\n", MAKEWORD(data->err.time1,
					       data->err.time2));
	printf("    history:\n");
	SMART_PRINTREG("\tcontrol register:\t", reg_ctl);
	SMART_PRINTREG("\tfeatures register:\t", reg_feat);
	SMART_PRINTREG("\tsector count register:\t", reg_seccnt);
	SMART_PRINTREG("\tLBA Low register:\t", reg_lbalo);
	SMART_PRINTREG("\tLBA Mid register:\t", reg_lbamid);
	SMART_PRINTREG("\tLBA High register:\t", reg_lbahi);
	SMART_PRINTREG("\tdevice register:\t", reg_dev);
	SMART_PRINTREG("\tcommand register:\t", reg_cmd);
	printf("\ttimestamp:\t\t"
	    "%d\t%d\t%d\t%d\t%d\n",
	    MAKEDWORD(data->cmd[0].time1, data->cmd[0].time2,
		      data->cmd[0].time3, data->cmd[0].time4),
	    MAKEDWORD(data->cmd[1].time1, data->cmd[1].time2,
		      data->cmd[1].time3, data->cmd[1].time4),
	    MAKEDWORD(data->cmd[2].time1, data->cmd[2].time2,
		      data->cmd[2].time3, data->cmd[2].time4),
	    MAKEDWORD(data->cmd[3].time1, data->cmd[3].time2,
		      data->cmd[3].time3, data->cmd[3].time4),
	    MAKEDWORD(data->cmd[4].time1, data->cmd[4].time2,
		      data->cmd[4].time3, data->cmd[4].time4));
}

int
smart_cksum(u_int8_t *data, size_t len)
{
	u_int8_t sum = 0;
	size_t i;

	for (i = 0; i < len; i++)
		sum += data[i];

	return (sum);
}

/*
 * Read device attributes
 */
void
device_attr(int argc, char *argv[])
{
	struct atareq req;
	struct smart_read attr_val;
	struct smart_threshold attr_thr;
	struct attribute *attr;
	struct threshold *thr;
	const char *attr_name;
	static const char hex[]="0123456789abcdef";
	char raw[13], *format;
	int i, k, threshold_exceeded = 0;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));
	memset(&attr_val, 0, sizeof(attr_val));	/* XXX */
	memset(&attr_thr, 0, sizeof(attr_thr));	/* XXX */

	req.command = ATAPI_SMART;
	req.cylinder = 0xc24f;		/* LBA High = C2h, LBA Mid = 4Fh */
	req.timeout = 1000;

	req.features = ATA_SMART_READ;
	req.flags = ATACMD_READ;
	req.databuf = (caddr_t)&attr_val;
	req.datalen = sizeof(attr_val);
	ata_command(&req);

	req.features = ATA_SMART_THRESHOLD;
	req.flags = ATACMD_READ;
	req.databuf = (caddr_t)&attr_thr;
	req.datalen = sizeof(attr_thr);
	ata_command(&req);

	if (attr_val.revision != attr_thr.revision) {
		/*
		 * Non standard vendor implementation.
		 * Return, since we don't know how to use this.
		 */
		return;
	}

	attr = attr_val.attribute;
	thr = attr_thr.threshold;

	printf("Attributes table revision: %d\n", attr_val.revision);
	printf("ID\tAttribute name\t\t\tThreshold\tValue\tRaw\n");
	for (i = 0; i < 30; i++) {
		if (thr[i].id != 0 && thr[i].id == attr[i].id) {
			attr_name = valtostr(thr[i].id, ibm_attr_names);
			if (attr_name == NULL)
				attr_name = "Unknown";

			for (k = 0; k < 6; k++) {
				u_int8_t b;
				b = attr[i].raw[6 - k];
				raw[k + k] = hex[b >> 4];
				raw[k + k + 1] = hex[b & 0x0f];
			}
			raw[k + k] = '\0';
			if (thr[i].value >= attr[i].value) {
				++threshold_exceeded;
				format = "%3d    *%-32.32s %3d\t\t%3d\t0x%s\n";
			} else {
				format = "%3d\t%-32.32s %3d\t\t%3d\t0x%s\n";
			}
			printf(format, thr[i].id, attr_name,
			    thr[i].value, attr[i].value, raw);
		}
	}
	if (threshold_exceeded)
		fprintf(stderr, "One or more threshold values exceeded!\n");

	return;

usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * Set the automatic acoustic management on the disk.
 */
void
device_acoustic(int argc, char *argv[])
{
	u_char acoustic;
	struct atareq req;
	const char *errstr;

	if (argc != 2)
		goto usage;

	acoustic = strtonum(argv[1], 0, 126, &errstr);
	if (errstr)
		errx(1, "Acoustic management value \"%s\" is %s "
		    "(valid values: 0 - 126)", argv[1], errstr);

	memset(&req, 0, sizeof(req));

	req.sec_count = acoustic + 0x80;

	req.command = SET_FEATURES ;
	req.features = WDSF_AAM_EN ;
	req.timeout = 1000;

	ata_command(&req);

	return;

usage:
	fprintf(stderr, "usage: %s device %s acoustic-management-level\n",
	    __progname, argv[0]);
	exit(1);
}

/*
 * Set the advanced power managmement on the disk. Power management
 * levels are translated from user-range 0-253 to ATAPI levels 1-0xFD
 * to keep a uniform interface to the user.
 */
void
device_apm(int argc, char *argv[])
{
	u_char power;
	struct atareq req;
	const char *errstr;

	if (argc != 2)
		goto usage;

	power = strtonum(argv[1], 0, 253, &errstr);
	if (errstr)
		errx(1, "Advanced power management value \"%s\" is %s "
		    "(valid values: 0 - 253)", argv[1], errstr);

	memset(&req, 0, sizeof(req));

	req.sec_count = power + 0x01;

	req.command = SET_FEATURES ;
	req.features = WDSF_APM_EN ;
	req.timeout = 1000;

	ata_command(&req);

	return;

usage:
	fprintf(stderr, "usage: %s device %s power-management-level\n",
	    __progname, argv[0]);
	exit(1);
}

/*
 * En/disable features (the automatic acoustic managmement, Advanced Power
 * Management) on the disk.
 */
void
device_feature(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = SET_FEATURES ;

	if (strcmp(argv[0], "acousticdisable") == 0)
		req.features = WDSF_AAM_DS;
	else if (strcmp(argv[0], "readaheadenable") == 0)
		req.features = WDSF_READAHEAD_EN;
	else if (strcmp(argv[0], "readaheaddisable") == 0)
		req.features = WDSF_READAHEAD_DS;
	else if (strcmp(argv[0], "writecacheenable") == 0)
		req.features = WDSF_EN_WR_CACHE;
	else if (strcmp(argv[0], "writecachedisable") == 0)
		req.features = WDSF_WRITE_CACHE_DS;
	else if (strcmp(argv[0], "apmdisable") == 0)
		req.features = WDSF_APM_DS;
	else if (strcmp(argv[0], "podenable") == 0)
		req.features = WDSF_POD_EN;
	else if (strcmp(argv[0], "poddisable") == 0)
		req.features = WDSF_POD_DS;
	else if (strcmp(argv[0], "puisenable") == 0)
		req.features = WDSF_PUIS_EN;
	else if (strcmp(argv[0], "puisdisable") == 0)
		req.features = WDSF_PUIS_DS;
	else if (strcmp(argv[0], "puisspinup") == 0)
		req.features = WDSF_PUIS_SPINUP;
	else
		goto usage;

	req.timeout = 1000;

	ata_command(&req);

	return;

usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}

/*
 * Set the idle timer on the disk.  Set it for either idle mode or
 * standby mode, depending on how we were invoked.
 */
void
device_setidle(int argc, char *argv[])
{
	unsigned long idle;
	struct atareq req;
	char *end;

	if (argc != 2)
		goto usage;

	idle = strtoul(argv[1], &end, 0);

	if (*end != '\0' || idle > 19800)
		errx(1, "Invalid idle time: \"%s\" "
		    "(valid values: 1 - 19800)", argv[1]);

	if (idle != 0 && idle < 5)
		errx(1, "Idle timer must be at least 5 seconds");

	memset(&req, 0, sizeof(req));

	if (idle <= 240 * 5)
		req.sec_count = idle / 5;
	else
		req.sec_count = idle / (30 * 60) + 240;

	if (strcmp(argv[0], "setstandby") == 0)
		req.command = WDCC_STANDBY;
	else if (strcmp(argv[0], "setidle") == 0)
		req.command = WDCC_IDLE;
	else
		goto usage;
	req.timeout = 1000;

	ata_command(&req);

	return;

usage:
	fprintf(stderr, "usage: %s device %s %s\n", __progname, argv[0],
	    (strcmp(argv[0], "setidle") == 0) ? "idle-timer" : "standby-timer");
	exit(1);
}

/*
 * Query the device for the current power mode
 */
void
device_checkpower(int argc, char *argv[])
{
	struct atareq req;

	if (argc != 1)
		goto usage;

	memset(&req, 0, sizeof(req));

	req.command = WDCC_CHECK_PWR;
	req.timeout = 1000;
	req.flags = ATACMD_READREG;

	ata_command(&req);

	printf("Current power status: ");

	switch (req.sec_count) {
	case 0x00:
		printf("Standby mode\n");
		break;
	case 0x80:
		printf("Idle mode\n");
		break;
	case 0xff:
		printf("Active mode\n");
		break;
	default:
		printf("Unknown power code (%02x)\n", req.sec_count);
	}

	return;
usage:
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
	exit(1);
}
@


1.45
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.44 2011/05/04 21:40:07 oga Exp $	*/
d1464 1
a1464 1
		if ((newbuf = (u_int8_t *)calloc(nsect, DEV_BSIZE)) == NULL)
@


1.44
log
@Switch atactl over to using opendev() instead of opendisk() so it can
grok DUIDs

now commands such as:
# atactl b9b455bd99e393cd

work as expected (while everything else that used to work still does).

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.43 2011/04/06 11:36:25 miod Exp $	*/
d37 1
a37 1
#include <sys/param.h>
@


1.43
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.42 2009/04/16 07:40:44 grange Exp $	*/
a357 1
	char dvname_store[MAXPATHLEN];
d365 2
a366 17
	fd = opendisk(argv[1], O_RDWR, dvname_store, sizeof(dvname_store), 0);
	if (fd == -1) {
		if (errno == ENOENT) {
			/*
			 * Device doesn't exist.  Probably trying to open
			 * a device which doesn't use disk semantics for
			 * device name.  Try again, specifying "cooked",
			 * which leaves off the "r" in front of the device's
			 * name.
			 */
			fd = opendisk(argv[1], O_RDWR, dvname_store,
			    sizeof(dvname_store), 1);
			if (fd == -1)
				err(1, "%s", argv[1]);
		} else
			err(1, "%s", argv[1]);
	}
@


1.42
log
@Update SMART attributes list. From kirill.timofeev@@gmail.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.41 2008/08/10 17:40:10 sobrado Exp $	*/
d157 1
a157 1
	{ NULL, NULL },
d175 1
a175 1
	{ NULL, NULL },
d193 1
a193 1
	{ NULL, NULL },
d210 1
a210 1
	{ NULL, NULL },
d218 1
a218 1
	{ NULL, NULL },
d450 1
a450 1
	for (; binfo->bitmask != NULL; binfo++)
@


1.41
log
@add missing ellipsis; spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.40 2008/07/05 21:13:47 sobrado Exp $	*/
d304 1
d307 1
a307 1
	{ 9, "Power-on Hours Count" },
d309 1
d311 5
a315 1
	{ 192, "Power-off Retract Count" },
d318 1
d321 1
a321 1
	{ 198, "Off-line Scan Uncorrectable Sector Count" },
d323 23
@


1.40
log
@synchronize usage of atactl commands with manual page.

ok millert@@, (for the change) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.39 2008/06/26 05:42:06 ray Exp $	*/
d957 1
a957 1
	fprintf(stderr, "usage: %s device %s user high|maximum\n",
d1000 1
a1000 1
	fprintf(stderr, "usage: %s device %s user|master\n", __progname,
d1056 1
a1056 1
	fprintf(stderr, "usage: %s device %s user|master [enhanced]\n",
d1122 1
a1122 1
	fprintf(stderr, "usage: %s device %s user|master\n", __progname,
d1261 1
a1261 1
	fprintf(stderr, "usage: %s device %s enable|disable\n", __progname,
@


1.39
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.38 2007/09/02 15:19:23 deraadt Exp $	*/
d380 1
a380 2
	fprintf(stderr, "usage: %s <device> [command [arg]]\n",
	    __progname);
d724 1
a724 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d852 1
a852 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d884 1
a884 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d957 1
a957 1
	fprintf(stderr, "usage: %s <device> %s user high | maximum\n",
d959 1
a959 1
	fprintf(stderr, "usage: %s <device> %s master\n", __progname, argv[0]);
d1000 1
a1000 1
	fprintf(stderr, "usage: %s <device> %s user | master\n", __progname,
d1056 1
a1056 1
	fprintf(stderr, "usage: %s <device> %s user | master [enhanced]\n",
d1081 1
a1081 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1122 1
a1122 1
	fprintf(stderr, "usage: %s <device> %s user | master\n", __progname,
d1171 1
a1171 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1197 1
a1197 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1231 1
a1231 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1261 1
a1261 1
	fprintf(stderr, "usage: %s <device> %s enable | disable\n", __progname,
d1292 1
a1292 1
	fprintf(stderr, "usage: %s <device> %s <subcommand>\n", __progname,
d1351 1
a1351 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1518 1
a1518 1
	fprintf(stderr, "usage: %s <device> %s <log>\n", __progname, argv[0]);
d1659 1
a1659 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1694 1
a1694 1
	fprintf(stderr, "usage: %s <device> %s <acoustic-management-value>\n",
d1732 1
a1732 1
	fprintf(stderr, "usage: %s <device> %s <power-management-level>\n",
d1785 1
a1785 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
d1832 2
a1833 2
	fprintf(stderr, "usage: %s <device> %s <idle-time>\n", __progname,
	    argv[0]);
d1874 1
a1874 1
	fprintf(stderr, "usage: %s <device> %s\n", __progname, argv[0]);
@


1.38
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.37 2006/10/02 19:30:19 jmc Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.37
log
@simplify SYNOPSIS and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.36 2006/05/27 21:19:33 moritz Exp $	*/
d1458 2
a1459 2
		if ((newbuf = (u_int8_t *)malloc(nsect * DEV_BSIZE)) == NULL)
			err(1, "malloc()");
@


1.36
log
@Kill some lint warnings by changing some variables to more
appropriate types and change some strtoul() to use strtonum().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.35 2005/08/10 15:22:39 jsg Exp $	*/
d387 1
a387 1
	fprintf(stderr, "usage: %s <device> <command> [arg [...]]\n",
@


1.35
log
@Mention if the disk supports IDLE IMMEDIATE with UNLOAD FEATURE
when listing information about it. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.34 2004/09/16 04:39:35 deraadt Exp $	*/
d88 1
a88 1
extern const char *__progname;		/* from crt0.o */
d113 1
a113 1
int	smart_cksum(u_int8_t *, int);
d475 2
a476 2
	int total;
	int p = 0;
d746 1
a746 1
	char inbuf[DEV_BSIZE], *s;
d748 1
d790 1
a790 1
	    s >= (char *)inqbuf->atap_model && *s == ' '; s--)
d794 1
a794 1
	    s >= (char *)inqbuf->atap_revision && *s == ' '; s--)
d798 1
a798 1
	    s >= (char *)inqbuf->atap_serial && *s == ' '; s--)
d1575 1
a1575 1
smart_cksum(u_int8_t *data, int len)
d1578 1
a1578 1
	int i;
d1677 1
a1677 1
	unsigned long acoustic;
d1679 1
a1679 1
	char *end;
d1684 4
a1687 5
	acoustic = strtoul(argv[1], &end, 0);

	if (*end != '\0' || acoustic > 126)
		errx(1, "Invalid acoustic management value: \"%s\" "
		    "(valid values range from 0 to 126)", argv[1]);
d1715 1
a1715 1
	unsigned long power;
d1717 1
a1717 1
	char *end;
d1722 4
a1725 5
	power = strtoul(argv[1], &end, 0);

	if (*end != '\0' || power > 253)
		errx(1, "Invalid advanced power management value: "
		    "\"%s\" (valid values range from 0 to 253)", argv[1]);
d1815 1
a1815 1
		    "(valid values range from 1 to 19800)", argv[1]);
@


1.34
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.33 2004/02/19 21:22:07 grange Exp $	*/
d221 1
@


1.33
log
@Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.32 2004/02/19 21:17:41 grange Exp $	*/
d397 1
a397 3
	int error;

	if ((error = ioctl(fd, ATAIOCCOMMAND, req)) == -1)
a472 1
	int error;
d493 1
a493 1
	if ((error = ioctl(fd, ATAIOGETTRACE, &agt)) == -1)
@


1.32
log
@wdc logs parser, now not only costa@@ can read it.

ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.31 2004/02/02 08:37:56 grange Exp $	*/
d478 1
a478 1
	int p;
d647 1
a647 1
				printf("CMD 0x%x");
d707 1
a707 1
				printf("CMD 0x%x");
@


1.31
log
@pod enable/disable have never been implemented, sigh. From gluk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.30 2003/07/29 18:38:35 deraadt Exp $	*/
d58 1
d477 11
d499 231
a729 2
	write(STDOUT_FILENO, agt.buf, agt.bytes_copied);
	fprintf(stderr, "%d bytes written\n", agt.bytes_copied);
@


1.30
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.29 2003/07/10 17:42:59 grange Exp $	*/
d1535 4
@


1.29
log
@Properly determine the capacity for LBA48 drives and also remove
the check for obsoleted bits in the identify word 0 since
some drives put garbage there.

Tested by Peter Galbavy <peter.galbavy@@knowtion.net> and avsm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.28 2003/06/11 06:22:12 deraadt Exp $	*/
d117 1
a117 1
	{ "dump",               device_dump },
@


1.28
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.27 2003/02/20 21:47:27 millert Exp $	*/
d508 1
d570 11
a580 6
	if ((inqbuf->atap_config & WDC_CFG_ATAPI_MASK) == 0)
		printf("Cylinders: %d, heads: %d, sec/track: %d, total "
		    "sectors: %d\n", inqbuf->atap_cylinders,
		    inqbuf->atap_heads, inqbuf->atap_sectors,
		    (inqbuf->atap_capacity[1] << 16) |
		    inqbuf->atap_capacity[0]);
@


1.27
log
@Use STDOUT_FILENO; David at phobia dot ms
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.26 2003/01/14 23:53:25 avsm Exp $	*/
d382 1
a382 1
usage()
@


1.26
log
@consistent output and typo, grange@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.25 2002/12/23 09:36:59 grange Exp $	*/
d487 1
a487 1
	write(1, agt.buf, agt.bytes_copied);
@


1.25
log
@- mark usage() as __dead
- combine function call and return value checking into one statement
- use errx() instead of fprintf(stderr)/exit()
- style(9)ed returns
- better comments
- proper initializing of agt var
- add usage to device_dump()
- grammar
- some -W -Wall fixes
- add missing exit()s in usage blocks
- simplify sec_getpass() function

Work by Andrey Matveev <andrushock@@korovino.net> and me.
ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.24 2002/12/22 18:29:56 grange Exp $	*/
d191 3
a193 3
	{ WDC_CMD1_RLSE, "release interrupt" },
	{ WDC_CMD1_AHEAD, "read look-ahead" },
	{ WDC_CMD1_CACHE, "write cache" },
@


1.24
log
@Convert to using atagettrace_t.
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.23 2002/12/11 19:44:34 grange Exp $	*/
d78 5
a82 5
int	main(int, char *[]);
void	usage(void);
void	ata_command(struct atareq *);
void	print_bitinfo(const char *, u_int, struct bitinfo *);
int	strtoval(const char *, struct valinfo *);
d381 2
a382 2
void
usage(void)
d398 1
a398 3
	error = ioctl(fd, ATAIOCCOMMAND, req);

	if (error == -1)
d406 1
a406 2
		fprintf(stderr, "ATA command timed out\n");
		exit(1);
d408 1
a408 2
		fprintf(stderr, "ATA device returned a Device Fault\n");
		exit(1);
d411 1
a411 2
			fprintf(stderr, "ATA device returned Aborted "
			    "Command\n");
d413 2
a414 3
			fprintf(stderr, "ATA device returned error register "
			    "%0x\n", req->error);
		exit(1);
d416 2
a417 3
		fprintf(stderr, "ATAIOCCOMMAND returned unknown result code "
		    "%d\n", req->retsts);
		exit(1);
d443 2
a444 2
			return vinfo->value;
	return -1;
d457 2
a458 2
			return vinfo->string;
	return NULL;
d464 6
d475 4
a478 1
	atagettrace_t agt = { sizeof(buf), &buf, 0 };
d480 5
a484 2
	error = ioctl(fd, ATAIOGETTRACE, &agt);
	if (error == -1) {
a485 1
	}
d491 4
d585 1
a585 1
		printf("Device supports following standards:\n");
d672 1
a672 1
	if (argc == 3)
d679 1
d722 1
d764 1
d820 1
d844 1
d886 1
d892 1
a892 1
	char *pass;
d900 1
a900 5
		char *pass2;

		pass2 = strdup(pass);
		if (pass2 == NULL)
			err(1, "strdup()");
d904 1
a904 1
		if (strcmp(pass, pass2) != 0)
a905 1
		free(pass2);
d908 1
a908 1
	return pass;
d986 1
a986 2
		fprintf(stderr,"SMART threshold exceeded!\n");
		exit(2);
d988 1
a988 2
		fprintf(stderr, "Unknown response %02x!\n", req.cylinder);
		exit(1);
d1084 2
a1085 4
	if (smart_cksum((u_int8_t *)&data, sizeof(data)) != 0) {
		fprintf(stderr, "Checksum mismatch\n");
		exit(1);
	}
d1163 2
a1164 4
		if (smart_cksum(inbuf, sizeof(inbuf)) != 0) {
			fprintf(stderr, "Checksum mismatch\n");
			exit(1);
		}
d1187 1
a1187 1
		} while (++n < (nerr > 5 ? 5 :  nerr));
d1193 2
a1194 4
		if (smart_cksum(inbuf, sizeof(inbuf)) != 0) {
			fprintf(stderr, "Checksum mismatch\n");
			exit(1);
		}
d1242 2
a1243 4
		if (smart_cksum(inbuf, sizeof(inbuf)) != 0) {
			fprintf(stderr, "Checksum mismatch\n");
			exit(1);
		}
d1337 1
a1337 1
	return sum;
d1440 3
a1442 5
	if (*end != '\0' || acoustic > 126) {
		fprintf(stderr, "Invalid acoustic management value: \"%s\" "
		    "(valid values range from 0 to 126)\n", argv[1]);
		exit(1);
	}
d1479 3
a1481 6
	if (*end != '\0' || power > 253) {
		fprintf(stderr, "Invalid advanced power management value: "
		    "\"%s\" (valid values range from 0 to 253)\n",
		    argv[1]);
		exit(1);
	}
d1545 1
a1545 2
	fprintf(stderr, "usage: %s <device> %s\n", __progname,
	    argv[0]);
d1565 3
a1567 5
	if (*end != '\0' || idle > 19800) {
		fprintf(stderr, "Invalid idle time: \"%s\" "
		    "(valid values range from 1 to 19800)\n", argv[1]);
		exit(1);
	}
d1569 2
a1570 4
	if (idle != 0 && idle < 5) {
		fprintf(stderr, "Idle timer must be at least 5 seconds\n");
		exit(1);
	}
@


1.23
log
@ansi; p/o by Andrushock <andrushock@@korovino.net>
ok gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.22 2002/11/24 20:36:11 henning Exp $	*/
d476 1
a476 1
	struct atagettrace agt = { sizeof(buf), &buf, 0 };
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.21 2002/10/16 13:00:51 gluk Exp $	*/
d1330 1
a1330 3
smart_cksum(data, len)
	u_int8_t *data;
	int len;
@


1.21
log
@Check parameters range.	Alexander Yurchenko <grange@@rt.mipt.ru>

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.20 2002/08/04 14:11:41 gluk Exp $	*/
d485 1
a485 1
	
@


1.20
log
@- grammar cleanup.
- check for the failure of strdup().

from tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.19 2002/07/06 14:46:57 gluk Exp $	*/
d1359 3
a1388 1
	printf("Attributes table revision: %d\n", attr_val.revision);
d1392 2
d1420 6
d1443 2
a1444 2
	if (*end != '\0') {
		fprintf(stderr, "Invalid acoustic management value: \"%s\""
a1448 6
	if (acoustic > 126) {
		fprintf(stderr, "Automatic acoustic management has a "
		    "maximum value of 126\n");
		exit(1);
	}

d1484 1
a1484 1
	if (*end != '\0') {
a1490 6
	if (power > 253) {
		fprintf(stderr, "Advanced power management has a "
		    "maximum value of 253\n");
		exit(1);
	}

d1574 3
a1576 8
	if (*end != '\0') {
		fprintf(stderr, "Invalid idle time: \"%s\"\n", argv[1]);
		exit(1);
	}

	if (idle > 19800) {
		fprintf(stderr, "Idle time has a maximum value of 5.5 "
		    "hours\n");
@


1.19
log
@Security Mode feature set.
From Alexander Yurchenko <grange@@rt.mipt.ru>

Approved by csapuntz@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.18 2002/07/03 22:32:32 deraadt Exp $	*/
d676 1
a676 1
	 * If device returnes 0x0000 or 0xffff as a revision
d889 2
@


1.18
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.17 2002/06/15 10:59:06 gluk Exp $	*/
d60 1
d97 5
d114 2
d136 5
d385 1
a385 1
	fprintf(stderr, "usage: %s device command [arg [...]]\n",
d499 1
a499 1
	char inbuf[512], *s;
d582 6
d606 1
a606 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
d638 1
a638 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
d643 258
d922 1
a922 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
d948 1
a948 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
d984 1
a984 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
d1014 1
a1014 1
	fprintf(stderr, "usage: %s device %s enable | disable\n", __progname,
d1045 1
a1045 1
	fprintf(stderr, "usage: %s device %s subcommand\n", __progname,
d1106 1
a1106 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
d1279 1
a1279 1
	fprintf(stderr, "usage: %s device %s log\n", __progname, argv[0]);
d1456 1
a1456 1
	fprintf(stderr, "usage: %s device %s acoustic-management-value\n",
d1504 1
a1504 1
	fprintf(stderr, "usage: %s device %s power-management-level\n",
d1553 1
a1553 1
	fprintf(stderr, "usage: %s device %s\n", __progname,
d1610 1
a1610 1
	fprintf(stderr, "usage: %s device %s idle-time\n", __progname,
d1652 1
a1652 1
	fprintf(stderr, "usage: %s device %s\n", __progname, argv[0]);
@


1.17
log
@Move ATA SMART defines to atactl.
No kernel parts use this constants.

From Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.16 2002/06/09 08:13:05 todd Exp $	*/
d317 1
a317 3
main(argc, argv)
	int argc;
	char *argv[];
d369 1
a369 1
usage()
d381 1
a381 2
ata_command(req)
	struct atareq *req;
d419 1
a419 4
print_bitinfo(f, bits, binfo)
	const char *f;
	u_int bits;
	struct bitinfo *binfo;
d433 1
a433 3
strtoval(str, vinfo)
	const char *str;
	struct valinfo *vinfo;
d447 1
a447 3
valtostr(val, vinfo)
	int val;
	struct valinfo *vinfo;
d459 1
a459 3
device_dump(argc, argv)
	int argc;
	char *argv[];
d482 1
a482 3
device_identify(argc, argv)
	int argc;
	char *argv[];
d597 1
a597 3
device_idle(argc, argv)
	int argc;
	char *argv[];
d627 1
a627 3
device_smart_enable(argc, argv)
	int argc;
	char *argv[];
d653 1
a653 3
device_smart_disable(argc, argv)
	int argc;
	char *argv[];
d679 1
a679 3
device_smart_status(argc, argv)
	int argc;
	char *argv[];
d715 1
a715 3
device_smart_autosave(argc, argv)
	int argc;
	char *argv[];
d746 1
a746 3
device_smart_offline(argc, argv)
	int argc;
	char *argv[];
d777 1
a777 3
device_smart_read(argc, argv)
	int argc;
	char *argv[];
d837 1
a837 3
device_smart_readlog(argc, argv)
	int argc;
	char *argv[];
d1015 1
a1015 2
smart_print_errdata(data)
	struct smart_log_errdata *data;
d1068 1
a1068 3
device_attr(argc, argv)
	int argc;
	char *argv[];
d1143 1
a1143 3
device_acoustic(argc, argv)
	int argc;
	char *argv[];
d1190 1
a1190 3
device_apm(argc, argv)
	int argc;
	char *argv[];
d1237 1
a1237 3
device_feature(argc, argv)
	int argc;
	char *argv[];
d1286 1
a1286 3
device_setidle(argc, argv)
	int argc;
	char *argv[];
d1342 1
a1342 3
device_checkpower(argc, argv)
	int argc;
	char *argv[];
@


1.16
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.15 2002/06/08 12:50:42 gluk Exp $	*/
d657 1
a657 1
	req.features = ATAPI_SMART_EN;
d685 1
a685 1
	req.features = ATAPI_SMART_DS;
d713 1
a713 1
	req.features = ATAPI_SMART_STATUS;
d752 1
a752 1
	req.features = ATAPI_SMART_AUTOSAVE;
d785 1
a785 1
	req.features = ATAPI_SMART_OFFLINE;
d819 1
a819 1
	req.features = ATAPI_SMART_READ;
d882 1
a882 1
	req.features = ATAPI_SMART_READLOG;
d967 1
a967 1
		req.features = ATAPI_SMART_READLOG;
d1121 1
a1121 1
	req.features = ATAPI_SMART_READ;
d1127 1
a1127 1
	req.features = SMART_THRESHOLD;
@


1.15
log
@- extended SMART support.
- style, typos.
- Big part of program redesigned and become more clean and simple.

Work done by Alexander Yurchenko <grange@@openbsd.ru>.
Readattr command implementation and some cleanups by me.

Costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.14 2002/06/08 12:31:54 gluk Exp $	*/
d471 1
a471 1
	char *argv[]; 
d1173 1
a1173 1
 * Set the automatic acoustic management on the disk. 
d1271 1
a1271 1
 * Management) on the disk. 
@


1.14
log
@Fix cut & paste error from last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.13 2002/06/04 23:08:44 csapuntz Exp $	*/
d46 1
d60 2
d72 5
d81 2
a84 3
const	char *dvname;			/* device name */
char	dvname_store[MAXPATHLEN];	/* for opendisk(3) */
const	char *cmdname;			/* command user issued */
d96 11
a106 1
void	device_smart(int, char *[]);
d128 8
a135 3
	{ "smartenable", 	device_smart },
	{ "smartdisable", 	device_smart },
	{ "smartstatus", 	device_smart },
d213 103
d321 2
a322 1
	int i;
d324 1
a324 6
	dvname = argv[1];
	if (argc == 2) {
		cmdname = "identify";
		argv += 2;
		argc -= 2;
	} else if (argc < 3) {
a325 7
	} else {
		/* Skip program name, get and skip device name and command. */

		cmdname = argv[2];
		argv += 3;
		argc -= 3;
	}
d330 1
a330 1
	fd = opendisk(dvname, O_RDWR, dvname_store, sizeof(dvname_store), 0);
d340 1
a340 1
			fd = opendisk(dvname, O_RDWR, dvname_store,
d343 1
a343 1
				err(1, "%s", dvname);
d345 1
a345 1
			err(1, "%s", dvname);
d348 9
a356 4
	/*
	 * Point the dvname at the actual device name that opendisk() opened.
	 */
	dvname = dvname_store;
d359 2
a360 2
	for (i = 0; commands[i].cmd_name != NULL; i++)
		if (strcmp(cmdname, commands[i].cmd_name) == 0)
d362 2
a363 2
	if (commands[i].cmd_name == NULL)
		errx(1, "unknown command: %s", cmdname);
d365 1
a365 1
	(*commands[i].cmd_func)(argc, argv);
a381 1

a420 1

d434 32
a467 1

d500 1
a500 1
	unsigned char inbuf[512];
d502 1
a502 2
	/* No arguments. */
	if (argc != 0)
d538 1
a538 2
	 * Strip blanks off of the info strings.  Yuck, I wish this was
	 * cleaner.
d541 11
a551 17
	if (inqbuf->atap_model[sizeof(inqbuf->atap_model) - 1] == ' ') {
		inqbuf->atap_model[sizeof(inqbuf->atap_model) - 1] = '\0';
		while (inqbuf->atap_model[strlen(inqbuf->atap_model) - 1] == ' ')
			inqbuf->atap_model[strlen(inqbuf->atap_model) - 1] = '\0';
	}

	if (inqbuf->atap_revision[sizeof(inqbuf->atap_revision) - 1] == ' ') {
		inqbuf->atap_revision[sizeof(inqbuf->atap_revision) - 1] = '\0';
		while (inqbuf->atap_revision[strlen(inqbuf->atap_revision) - 1] == ' ')
			inqbuf->atap_revision[strlen(inqbuf->atap_revision) - 1] = '\0';
	}

	if (inqbuf->atap_serial[sizeof(inqbuf->atap_serial) - 1] == ' ') {
		inqbuf->atap_serial[sizeof(inqbuf->atap_serial) - 1] = '\0';
		while (inqbuf->atap_serial[strlen(inqbuf->atap_serial) - 1] == ' ')
			inqbuf->atap_serial[strlen(inqbuf->atap_serial) - 1] = '\0';
	}
d592 2
a593 1
		printf("Device has enabled the following command sets/features:\n");
a595 10
#if 0
		print_bitinfo("\t%s\n", inqbuf->atap_cmd_set1 &
		    (WDC_CMD1_SRV | WDC_CMD1_RLSE | WDC_CMD1_AHEAD |
		    WDC_CMD1_CACHE | WDC_CMD1_SEC | WDC_CMD1_SMART),
		    ata_cmd_set1);
		print_bitinfo("\t%s\n", inqbuf->atap_cmd_set2 &
		    (WDC_CMD2_RMSN | ATA_CMD2_APM | ATAPI_CMD2_PUIS |
		    ATAPI_CMD2_AAM | ATAPI_CMD2_48AD |
		    ATAPI_CMD2_DCO), ata_cmd_set2);
#endif
d601 1
a601 1
	fprintf(stderr, "usage: %s device %s\n", __progname, cmdname);
a609 1

d617 1
a617 2
	/* No arguments. */
	if (argc != 0)
d622 1
a622 1
	if (strcmp(cmdname, "idle") == 0)
d624 1
a624 1
	else if (strcmp(cmdname, "standby") == 0)
d635 29
a663 1
	fprintf(stderr, "usage: %s device %s\n", __progname, cmdname);
d668 100
a767 3
 * SMART.
 *
 * issue the SMART ENABLE/DISABLE/STATUS commands to the drive
d769 22
d792 10
d803 1
a803 1
device_smart(argc, argv)
d808 1
d810 1
a810 2
	/* No arguments. */
	if (argc != 0)
d814 1
d817 35
a851 10
	req.cylinder = 0xC24F; /* Cylinders is mapped to LBA Mid/Low */
	/* XXX: I assume cylinders is correctly mapped w.r.t.
	 * endianness? */

	if (strcmp(cmdname, "smartenable") == 0)
		req.features = ATAPI_SMART_EN;
	else if (strcmp(cmdname, "smartdisable") == 0)
		req.features = ATAPI_SMART_DS;
	else if (strcmp(cmdname, "smartstatus") == 0)
		req.features = ATAPI_SMART_STATUS;
d853 21
d876 5
d882 8
d893 101
a993 9
	if (strcmp(cmdname, "smartstatus") == 0) {
		if (req.cylinder == 0xC24F)
			printf("No SMART threshold exceeded\n");
		else if (req.cylinder == 0x2CF4) {
			fprintf(stderr,"SMART threshold exceeded!\n");
			exit(2);
		} else {
			fprintf(stderr, "Unknown response %02x!\n",
			    req.cylinder);
d996 32
d1032 1
a1032 1
	fprintf(stderr, "usage: %s device %s\n", __progname, cmdname);
d1036 136
d1173 1
a1173 1
 * Set the automatic acoustic managmement on the disk. 
d1184 1
a1184 2
	/* Only one argument */
	if (argc != 1)
d1187 1
a1187 1
	acoustic = strtoul(argv[0], &end, 0);
d1191 1
a1191 1
		    "(valid values range from 0 to 126)\n", argv[0]);
d1214 2
a1215 2
	fprintf(stderr, "usage; %s device %s acoustic-management-value\n",
	    __progname, cmdname);
d1233 1
a1233 2
	/* Only one argument */
	if (argc != 1)
d1236 1
a1236 1
	power = strtoul(argv[0], &end, 0);
d1241 1
a1241 1
		    argv[0]);
d1264 2
a1265 2
	fprintf(stderr, "usage; %s device %s power-management-level\n",
	    __progname, cmdname);
d1280 1
a1280 2
	/* No argument */
	if (argc != 0)
d1287 1
a1287 1
	if (strcmp(cmdname, "acousticdisable") == 0)
d1289 1
a1289 1
	else if (strcmp(cmdname, "readaheadenable") == 0)
d1291 1
a1291 1
	else if (strcmp(cmdname, "readaheaddisable") == 0)
d1293 1
a1293 1
	else if (strcmp(cmdname, "writecacheenable") == 0)
d1295 1
a1295 1
	else if (strcmp(cmdname, "writecachedisable") == 0)
d1297 1
a1297 1
	else if (strcmp(cmdname, "apmdisable") == 0)
d1299 1
a1299 1
	else if (strcmp(cmdname, "puisenable") == 0)
d1301 1
a1301 1
	else if (strcmp(cmdname, "puisdisable") == 0)
d1303 1
a1303 1
	else if (strcmp(cmdname, "puisspinup") == 0)
d1315 2
a1316 2
	fprintf(stderr, "usage; %s device %s\n", __progname,
	    cmdname);
a1323 1

d1333 1
a1333 2
	/* Only one argument */
	if (argc != 1)
d1336 1
a1336 1
	idle = strtoul(argv[0], &end, 0);
d1339 1
a1339 1
		fprintf(stderr, "Invalid idle time: \"%s\"\n", argv[0]);
d1356 1
a1356 1
	if (idle <= 240*5)
d1359 1
a1359 1
		req.sec_count = idle / (30*60) + 240;
d1361 6
a1366 1
	req.command = cmdname[3] == 's' ? WDCC_STANDBY : WDCC_IDLE;
d1374 2
a1375 2
	fprintf(stderr, "usage; %s device %s idle-time\n", __progname,
	    cmdname);
a1381 1

d1389 1
a1389 2
	/* No arguments. */
	if (argc != 0)
d1418 1
a1418 1
	fprintf(stderr, "usage: %s device %s\n", __progname, cmdname);
@


1.13
log
@Fix identify logic to match kernel. Works better on big endian architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.12 2002/03/27 17:42:37 gluk Exp $	*/
d385 3
a387 3
		    sizeof(inqbuf->atap_model) / 2);
		swap16_multi((u_int16_t *)(inqbuf->atap_model),
		    sizeof(inqbuf->atap_model) / 2);
@


1.12
log
@Calculate the maximum queue depth correctly.
PR2490 from Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.11 2002/03/14 06:51:41 mpech Exp $	*/
d352 1
a352 5
	unsigned char inbuf[DEV_BSIZE];
#if BYTE_ORDER == LITTLE_ENDIAN
	int i;
	u_int16_t *p;
#endif
d371 5
a375 6
#if BYTE_ORDER == LITTLE_ENDIAN
	/*
	 * On little endian machines, we need to shuffle the string
	 * byte order.  However, we don't have to do this for NEC or
	 * Mitsumi ATAPI devices
	 */
d382 6
a387 12
		for (i = 0 ; i < sizeof(inqbuf->atap_model); i += 2) {
			p = (u_short *) (inqbuf->atap_model + i);
			*p = ntohs(*p);
		}
		for (i = 0 ; i < sizeof(inqbuf->atap_serial); i += 2) {
			p = (u_short *) (inqbuf->atap_serial + i);
			*p = ntohs(*p);
		}
		for (i = 0 ; i < sizeof(inqbuf->atap_revision); i += 2) {
			p = (u_short *) (inqbuf->atap_revision + i);
			*p = ntohs(*p);
		}
a388 1
#endif
@


1.11
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.10 2002/02/16 21:27:33 millert Exp $	*/
d441 2
a442 1
	if (inqbuf->atap_queuedepth & WDC_QUEUE_DEPTH_MASK)
d444 1
a444 1
		    inqbuf->atap_queuedepth & 0xf);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.9 2002/01/30 00:46:36 csapuntz Exp $	*/
d244 1
a244 1
		errx(1, "unknown command: %s\n", cmdname);
@


1.9
log
@atactl [ata device] dump

will dump the ATA trace buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.8 2001/07/07 18:26:09 deraadt Exp $	*/
d61 1
a61 1
	void (*cmd_func) __P((int, char *[]));
d69 4
a72 4
int	main __P((int, char *[]));
void	usage __P((void));
void	ata_command __P((struct atareq *));
void	print_bitinfo __P((const char *, u_int, struct bitinfo *));
d82 8
a89 8
void	device_identify __P((int, char *[]));
void	device_setidle __P((int, char *[]));
void	device_idle __P((int, char *[]));
void	device_checkpower __P((int, char *[]));
void	device_acoustic __P((int, char *[]));
void	device_apm __P((int, char *[]));
void	device_feature __P((int, char *[]));
void	device_smart __P((int, char *[]));
@


1.8
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.7 2001/06/04 14:59:47 mickey Exp $	*/
d81 1
d92 1
d319 20
@


1.7
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.6 2001/03/23 02:16:42 deraadt Exp $	*/
d543 1
a543 1
			fprintf(stderr, "Unknown response %0.2x!\n",
@


1.6
log
@atactl SMART support; wouter@@yourcreativesolutions.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.5 2000/07/13 15:12:34 deraadt Exp $	*/
d245 2
a246 1
	exit(0);
@


1.5
log
@undo
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.4 2000/07/05 23:41:37 deraadt Exp $	*/
d85 4
d91 23
a113 7
	{ "identify",	device_identify },
	{ "setidle",	device_setidle },
	{ "setstandby",	device_setidle },
	{ "idle",	device_idle },
	{ "standby",	device_idle },
	{ "sleep",	device_idle },
	{ "checkpower",	device_checkpower },
d130 14
a143 4
	{ WDC_VER_ATA1,	"ATA-1" },
	{ WDC_VER_ATA2,	"ATA-2" },
	{ WDC_VER_ATA3,	"ATA-3" },
	{ WDC_VER_ATA4,	"ATA-4" },
d155 1
a155 1
	{ WDC_CMD1_AHEAD, "look-ahead" },
d166 8
d182 7
d285 1
a285 1
				"Command\n");
d288 1
a288 1
				"%0x\n", req->error);
d292 1
a292 1
			"%d\n", req->retsts);
d403 3
a405 3
	       (int) sizeof(inqbuf->atap_model), inqbuf->atap_model,
	       (int) sizeof(inqbuf->atap_revision), inqbuf->atap_revision,
	       (int) sizeof(inqbuf->atap_serial), inqbuf->atap_serial);
d413 4
a416 4
		       "sectors: %d\n", inqbuf->atap_cylinders,
		       inqbuf->atap_heads, inqbuf->atap_sectors,
		       (inqbuf->atap_capacity[1] << 16) |
		       inqbuf->atap_capacity[0]);
d420 1
a420 1
		       inqbuf->atap_queuedepth & 0xf);
d433 1
a433 1
		printf("Command set support:\n");
d436 1
d440 4
a443 1
		printf("Command sets/features enabled:\n");
d445 3
a447 3
			      (WDC_CMD1_SRV | WDC_CMD1_RLSE | WDC_CMD1_AHEAD |
			       WDC_CMD1_CACHE | WDC_CMD1_SEC | WDC_CMD1_SMART),
			       ata_cmd_set1);
d449 4
a452 1
			      (WDC_CMD2_RMSN | ATA_CMD2_APM), ata_cmd_set2);
d499 207
d732 1
a732 1
			"hours\n");
d757 1
a757 1
		cmdname);
@


1.4
log
@printf without %s
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.3 2000/05/31 22:54:45 chris Exp $	*/
d265 1
a265 1
			printf(f, "%s", binfo->string);
@


1.3
log
@It's "DMA" not "DMS" for the ATA-4 queued feature set!!
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.2 2000/02/02 02:52:05 deraadt Exp $	*/
d265 1
a265 1
			printf(f, binfo->string);
@


1.2
log
@without a command, identify is implied
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.1 1999/09/21 04:58:14 csapuntz Exp $	*/
d139 1
a139 1
	{ ATA_CMD2_RWQ, "READ/WRITE DMS QUEUED commands" },
@


1.1
log
@

Add atactl utility from NetBSD. This utility gives detailed inquiry info as
well as letting you spin down disks, set standby times, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: atactl.c,v 1.4 1999/02/24 18:49:14 jwise Exp $	*/
d151 6
a156 2
	/* Must have at least: device command */
	if (argc < 3)
d158 2
d161 4
a164 5
	/* Skip program name, get and skip device name and command. */
	dvname = argv[1];
	cmdname = argv[2];
	argv += 3;
	argc -= 3;
@

