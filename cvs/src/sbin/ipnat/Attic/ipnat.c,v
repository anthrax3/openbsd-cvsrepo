head	1.41;
access;
symbols
	OPENBSD_2_9:1.40.0.2
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.36.0.2
	OPENBSD_2_7_BASE:1.36
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.22.0.2
	OPENBSD_2_3_BASE:1.22
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.41
date	2001.05.30.02.11.49;	author deraadt;	state dead;
branches;
next	1.40;

1.40
date	2001.01.30.04.26.49;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.17.05.01.01;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2000.08.10.05.50.27;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2000.07.26.20.33.01;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.13.23.40.19;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.16.22.34.22;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.01.19.30.00;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	99.12.16.07.38.45;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	99.12.15.05.20.24;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	99.07.25.19.14.43;	author hugh;	state Exp;
branches;
next	1.30;

1.30
date	99.07.23.19.48.02;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	99.07.08.01.38.36;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.06.06.20.34.56;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.06.03.17.53.11;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.02.05.05.58.48;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.10.11.05.36.32;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.10.06.06.32.54;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.09.15.09.57.29;	author pattonme;	state Exp;
branches;
next	1.22;

1.22
date	98.03.21.22.42.13;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.03.07.00.34.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.02.24.04.03.38;	author dgregor;	state Exp;
branches;
next	1.19;

1.19
date	98.01.26.04.13.49;	author dgregor;	state Exp;
branches;
next	1.18;

1.18
date	97.09.22.05.11.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.07.08.13.15.21;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.06.23.17.02.43;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.06.23.01.16.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.06.17.10.42.08;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.02.14.11.02.05;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.02.13.23.33.37;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.02.13.01.19.05;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.02.11.22.24.20;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.02.07.20.06.44;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.02.07.19.33.49;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.02.07.18.26.47;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.02.07.18.10.07;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.07.17.02.50;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.08.07.33.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.18.05.08.39;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.31.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.21.39.56;	author dm;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ipnat.c,v 1.40 2001/01/30 04:26:49 kjell Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 *
 * Added redirect stuff and a variety of bug fixes. (mcn@@EnGarde.com)
 */
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#if !defined(__SVR4) && !defined(__svr4__)
#include <strings.h>
#else
#include <sys/byteorder.h>
#endif
#include <sys/time.h>
#include <sys/param.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#if defined(sun) && (defined(__svr4__) || defined(__SVR4))
# include <sys/ioccom.h>
# include <sys/sysmacros.h>
#endif
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <net/if.h>
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
#endif
#include <netdb.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <resolv.h>
#include <ctype.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include "ipf.h"
#include "kmem.h"

#if	defined(sun) && !SOLARIS2
# define	STRERROR(x)	sys_errlist[x]
extern	char	*sys_errlist[];
#else
# define	STRERROR(x)	strerror(x)
#endif

#if !defined(lint)
static const char sccsid[] ="@@(#)ipnat.c	1.9 6/5/96 (C) 1993 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipnat.c,v 2.16.2.5 2000/12/02 00:15:04 darrenr Exp $";
#endif


#if	SOLARIS
#define	bzero(a,b)	memset(a,0,b)
#endif
#ifdef	USE_INET6
int	use_inet6 = 0;
#endif

static	char	thishost[MAXHOSTNAMELEN];


extern	char	*optarg;
char	*nlistf = NULL, *memf = NULL;
extern	ipnat_t	*natparse __P((char *, int));
extern	void	natparsefile __P((int, char *, int));
extern	void	printnat __P((ipnat_t *, int, void *));

void	dostats __P((int, int)), flushtable __P((int, int));
void	usage __P((char *));
int	countbits __P((u_32_t));
char	*getnattype __P((ipnat_t *));
int	main __P((int, char*[]));
void	printaps __P((ap_session_t *, int));
char	*getsumd __P((u_32_t));


void usage(name)
char *name;
{
	fprintf(stderr, "%s: [-CFhlnrsv] [-f filename]\n", name);
	exit(1);
}


char *getsumd(sum)
u_32_t sum;
{
	static char sumdbuf[17];

	if (sum & NAT_HW_CKSUM)
		sprintf(sumdbuf, "hw(%#0x)", sum & 0xffff);
	else
		sprintf(sumdbuf, "%#0x", sum);
	return sumdbuf;
}


int main(argc, argv)
int argc;
char *argv[];
{
	char	*file = NULL;
	int	fd = -1, opts = 0, c, mode = O_RDWR;

	while ((c = getopt(argc, argv, "CdFf:hlnrsv")) != -1)
		switch (c)
		{
		case 'C' :
			opts |= OPT_CLEAR;
			break;
		case 'd' :
			opts |= OPT_DEBUG;
			break;
		case 'f' :
			file = optarg;
			break;
		case 'F' :
			opts |= OPT_FLUSH;
			break;
		case 'h' :
			opts |=OPT_HITS;
			break;
		case 'l' :
			opts |= OPT_LIST;
			mode = O_RDONLY;
			break;
		case 'n' :
			opts |= OPT_NODO;
			mode = O_RDONLY;
			break;
		case 'r' :
			opts |= OPT_REMOVE;
			break;
		case 's' :
			opts |= OPT_STAT;
			mode = O_RDONLY;
			break;
		case 'v' :
			opts |= OPT_VERBOSE;
			break;
		default :
			usage(argv[0]);
		}

	gethostname(thishost, sizeof(thishost));
	thishost[sizeof(thishost) - 1] = '\0';

	if (!(opts & OPT_NODO) && ((fd = open(IPL_NAT, mode)) == -1) &&
	    ((fd = open(IPL_NAT, O_RDONLY)) == -1)) {
		(void) fprintf(stderr, "%s: open: %s\n", IPL_NAT,
			STRERROR(errno));
		exit(-1);
	}

	if (opts & (OPT_FLUSH|OPT_CLEAR))
		flushtable(fd, opts);
	if (file)
		natparsefile(fd, file, opts);
	if (opts & (OPT_LIST|OPT_STAT))
		dostats(fd, opts);
	return 0;
}


void printaps(aps, opts)
ap_session_t *aps;
int opts;
{
	ap_session_t ap;
	ftpinfo_t ftp;
	aproxy_t apr;
	raudio_t ra;

	if (kmemcpy((char *)&ap, (long)aps, sizeof(ap)))
		return;
	if (kmemcpy((char *)&apr, (long)ap.aps_apr, sizeof(apr)))
		return;
	printf("\tproxy %s/%d use %d flags %x\n", apr.apr_label,
		apr.apr_p, apr.apr_ref, apr.apr_flags);
	printf("\t\tproto %d flags %#x bytes ", ap.aps_p, ap.aps_flags);
#ifdef	USE_QUAD_T
	printf("%qu pkts %qu", (unsigned long long)ap.aps_bytes,
		(unsigned long long)ap.aps_pkts);
#else
	printf("%lu pkts %lu", ap.aps_bytes, ap.aps_pkts);
#endif
	printf(" data %p psiz %d\n", ap.aps_data, ap.aps_psiz);
	if ((ap.aps_p == IPPROTO_TCP) && (opts & OPT_VERBOSE)) {
		printf("\t\tstate[%u,%u], sel[%d,%d]\n",
			ap.aps_state[0], ap.aps_state[1],
			ap.aps_sel[0], ap.aps_sel[1]);
#if (defined(NetBSD) && (NetBSD >= 199905) && (NetBSD < 1991011)) || \
    (__FreeBSD_version >= 300000) || defined(OpenBSD)
		printf("\t\tseq: off %hd/%hd min %x/%x\n",
			ap.aps_seqoff[0], ap.aps_seqoff[1],
			ap.aps_seqmin[0], ap.aps_seqmin[1]);
		printf("\t\tack: off %hd/%hd min %x/%x\n",
			ap.aps_ackoff[0], ap.aps_ackoff[1],
			ap.aps_ackmin[0], ap.aps_ackmin[1]);
#else
		printf("\t\tseq: off %hd/%hd min %lx/%lx\n",
			ap.aps_seqoff[0], ap.aps_seqoff[1],
			ap.aps_seqmin[0], ap.aps_seqmin[1]);
		printf("\t\tack: off %hd/%hd min %lx/%lx\n",
			ap.aps_ackoff[0], ap.aps_ackoff[1],
			ap.aps_ackmin[0], ap.aps_ackmin[1]);
#endif
	}

	if (!strcmp(apr.apr_label, "raudio") && ap.aps_psiz == sizeof(ra)) {
		if (kmemcpy((char *)&ra, (long)ap.aps_data, sizeof(ra)))
			return;
		printf("\tReal Audio Proxy:\n");
		printf("\t\tSeen PNA: %d\tVersion: %d\tEOS: %d\n",
			ra.rap_seenpna, ra.rap_version, ra.rap_eos);
		printf("\t\tMode: %#x\tSBF: %#x\n", ra.rap_mode, ra.rap_sbf);
		printf("\t\tPorts:pl %hu, pr %hu, sr %hu\n",
			ra.rap_plport, ra.rap_prport, ra.rap_srport);
	} else if (!strcmp(apr.apr_label, "ftp") &&
		   (ap.aps_psiz == sizeof(ftp))) {
		if (kmemcpy((char *)&ftp, (long)ap.aps_data, sizeof(ftp)))
			return;
		printf("\tFTP Proxy:\n");
		printf("\t\tpassok: %d\n", ftp.ftp_passok);
		ftp.ftp_side[0].ftps_buf[FTP_BUFSZ - 1] = '\0';
		ftp.ftp_side[1].ftps_buf[FTP_BUFSZ - 1] = '\0';
		printf("\tClient:\n");
		printf("\t\trptr %p wptr %p seq %x len %d junk %d\n",
			ftp.ftp_side[0].ftps_rptr, ftp.ftp_side[0].ftps_wptr,
			ftp.ftp_side[0].ftps_seq, ftp.ftp_side[0].ftps_len,
			ftp.ftp_side[0].ftps_junk);
		printf("\t\tbuf [");
		printbuf(ftp.ftp_side[0].ftps_buf, FTP_BUFSZ, 1);
		printf("]\n\tServer:\n");
		printf("\t\trptr %p wptr %p seq %x len %d junk %d\n",
			ftp.ftp_side[1].ftps_rptr, ftp.ftp_side[1].ftps_wptr,
			ftp.ftp_side[1].ftps_seq, ftp.ftp_side[1].ftps_len,
			ftp.ftp_side[1].ftps_junk);
		printf("\t\tbuf [");
		printbuf(ftp.ftp_side[1].ftps_buf, FTP_BUFSZ, 1);
		printf("]\n");
	}
}


/*
 * Get a nat filter type given its kernel address.
 */
char *getnattype(ipnat)
ipnat_t *ipnat;
{
	char *which;
	ipnat_t ipnatbuff;

	if (!ipnat || (ipnat && kmemcpy((char *)&ipnatbuff, (long)ipnat,
					sizeof(ipnatbuff))))
		return "???";

	switch (ipnatbuff.in_redir)
	{
	case NAT_MAP :
		which = "MAP";
		break;
	case NAT_MAPBLK :
		which = "MAP-BLOCK";
		break;
	case NAT_REDIRECT :
		which = "RDR";
		break;
	case NAT_BIMAP :
		which = "BIMAP";
		break;
	default :
		which = "unknown";
		break;
	}
	return which;
}


void dostats(fd, opts)
int fd, opts;
{
	natstat_t ns, *nsp = &ns;
	nat_t **nt[2], *np, nat;
	ipnat_t	ipn;

	bzero((char *)&ns, sizeof(ns));

	if (!(opts & OPT_NODO) && ioctl(fd, SIOCGNATS, &nsp) == -1) {
		perror("ioctl(SIOCGNATS)");
		return;
	}

	if (opts & OPT_STAT) {
		printf("mapped\tin\t%lu\tout\t%lu\n",
			ns.ns_mapped[0], ns.ns_mapped[1]);
		printf("added\t%lu\texpired\t%lu\n",
			ns.ns_added, ns.ns_expire);
		printf("no memory\t%lu\tbad nat\t%lu\n",
			ns.ns_memfail, ns.ns_badnat);
		printf("inuse\t%lu\nrules\t%lu\n", ns.ns_inuse, ns.ns_rules);
		printf("wilds\t%u\n", ns.ns_wilds);
		if (opts & OPT_VERBOSE)
			printf("table %p list %p\n", ns.ns_table, ns.ns_list);
	}
	if (opts & OPT_LIST) {
		printf("List of active MAP/Redirect filters:\n");
		while (ns.ns_list) {
			if (kmemcpy((char *)&ipn, (long)ns.ns_list,
				    sizeof(ipn))) {
				perror("kmemcpy");
				break;
			}
			if (opts & OPT_HITS)
				printf("%d ", ipn.in_hits);
			printnat(&ipn, opts & (OPT_DEBUG|OPT_VERBOSE),
				 (void *)ns.ns_list);
			ns.ns_list = ipn.in_next;
		}

		nt[0] = (nat_t **)malloc(sizeof(*nt) * NAT_SIZE);
		if (kmemcpy((char *)nt[0], (long)ns.ns_table[0],
			    sizeof(**nt) * NAT_SIZE)) {
			perror("kmemcpy");
			return;
		}

		printf("\nList of active sessions:\n");

		for (np = ns.ns_instances; np; np = nat.nat_next) {
			if (kmemcpy((char *)&nat, (long)np, sizeof(nat)))
				break;

			printf("%s %-15s %-5hu <- ->", getnattype(nat.nat_ptr),
			       inet_ntoa(nat.nat_inip), ntohs(nat.nat_inport));
			printf(" %-15s %-5hu", inet_ntoa(nat.nat_outip),
				ntohs(nat.nat_outport));
			printf(" [%s %hu]", inet_ntoa(nat.nat_oip),
				ntohs(nat.nat_oport));
			if (opts & OPT_VERBOSE) {
				printf("\n\tage %lu use %hu sumd %s/",
					nat.nat_age, nat.nat_use,
					getsumd(nat.nat_sumd[0]));
				printf("%s pr %u bkt %d/%d flags %x ",
					getsumd(nat.nat_sumd[1]), nat.nat_p,
					(int)NAT_HASH_FN(nat.nat_inip.s_addr,
							 nat.nat_inport,
							 NAT_TABLE_SZ),
					(int)NAT_HASH_FN(nat.nat_outip.s_addr,
							 nat.nat_outport,
							 NAT_TABLE_SZ),
					nat.nat_flags);
#ifdef	USE_QUAD_T
				printf("bytes %qu pkts %qu",
					(unsigned long long)nat.nat_bytes,
					(unsigned long long)nat.nat_pkts);
#else
				printf("bytes %lu pkts %lu",
					nat.nat_bytes, nat.nat_pkts);
#endif
#if SOLARIS
				printf(" %lx", nat.nat_ipsumd);
#endif
			}
			putchar('\n');
			if (nat.nat_aps)
				printaps(nat.nat_aps, opts);
		}

		free(nt[0]);
	}
}


void flushtable(fd, opts)
int fd, opts;
{
	int n = 0;

	if (opts & OPT_FLUSH) {
		n = 0;
		if (!(opts & OPT_NODO) && ioctl(fd, SIOCIPFFL, &n) == -1)
			perror("ioctl(SIOCFLNAT)");
		else
			printf("%d entries flushed from NAT table\n", n);
	}

	if (opts & OPT_CLEAR) {
		n = 1;
		if (!(opts & OPT_NODO) && ioctl(fd, SIOCIPFFL, &n) == -1)
			perror("ioctl(SIOCCNATL)");
		else
			printf("%d entries flushed from NAT list\n", n);
	}
}
@


1.40
log
@reimplement whacked ipnat changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.39 2001/01/17 05:01:01 fgsch Exp $	*/
@


1.39
log
@1st part of ipf userland code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
#include <netinet/ip_compat.h>
d77 1
@


1.38
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.37 2000/07/26 20:33:01 mickey Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d46 1
a46 1
#include <netinet/ip_fil_compat.h>
d50 1
d62 1
a62 1
static const char rcsid[] = "@@(#)$IPFilter: ipnat.c,v 2.1.2.3 2000/07/27 13:07:07 darrenr Exp $";
d69 6
a76 1
char	*nlistf = NULL, *memf = NULL;
a80 6
#if defined(__OpenBSD__)
extern  int	if_addr __P((char *, struct in_addr *));
#endif

u_32_t	hostnum __P((char *, int *, int));
u_32_t	hostmask __P((char *));
a88 9
#define	OPT_REM		1
#define	OPT_NODO	2
#define	OPT_STAT	4
#define	OPT_LIST	8
#define	OPT_VERBOSE	16
#define	OPT_FLUSH	32
#define	OPT_CLEAR	64
#define	OPT_HITS	128

d118 1
a118 1
	while ((c = getopt(argc, argv, "CFf:hlnrsv")) != -1)
d124 3
d145 1
a145 1
			opts |= OPT_REM;
d158 3
a177 29
/*
 * count consecutive 1's in bit mask.  If the mask generated by counting
 * consecutive 1's is different to that passed, return -1, else return #
 * of bits.
 */
int	countbits(ip)
u_32_t	ip;
{
	u_32_t	ipn;
	int	cnt = 0, i, j;

	ip = ipn = ntohl(ip);
	for (i = 32; i; i--, ipn *= 2)
		if (ipn & 0x80000000)
			cnt++;
		else
			break;
	ipn = 0;
	for (i = 32, j = cnt; i; i--, j--) {
		ipn *= 2;
		if (j > 0)
			ipn++;
	}
	if (ipn == ip)
		return cnt;
	return -1;
}


d183 1
d195 2
a196 1
	printf("%qu pkts %qu", ap.aps_bytes, ap.aps_pkts);
d232 23
d297 2
a298 1
	natstat_t ns;
a299 2
	nat_t	**nt[2], *np, nat;
	int	i = 0;
d303 1
a303 1
	if (!(opts & OPT_NODO) && ioctl(fd, SIOCGNATS, &ns) == -1) {
d313 2
d316 1
d330 2
a331 1
			printnat(&ipn, opts & OPT_VERBOSE, (void *)ns.ns_list);
d358 1
a358 1
				printf("%s pr %u bkt %d flags %x ",
d360 7
a366 1
					i, nat.nat_flags);
d369 2
a370 1
					nat.nat_bytes, nat.nat_pkts);
a388 62
u_32_t	hostmask(msk)
char	*msk;
{
	int	bits = -1;
	u_32_t	mask;

	if (!isdigit(*msk))
		return (u_32_t)-1;
	if (strchr(msk, '.'))
		return inet_addr(msk);
	if (strchr(msk, 'x'))
		return (u_32_t)strtol(msk, NULL, 0);
	/*
	 * set x most significant bits
	 */
	for (mask = 0, bits = atoi(msk); bits; bits--) {
		mask /= 2;
		mask |= ntohl(inet_addr("128.0.0.0"));
	}
	mask = htonl(mask);
	return mask;
}


/*
 * returns an ip address as a long var as a result of either a DNS lookup or
 * straight inet_addr() call
 */
u_32_t	hostnum(host, resolved, linenum)
char	*host;
int	*resolved;
int     linenum;
{
	struct	hostent	*hp;
	struct	netent	*np;
#if defined(__OpenBSD__)
	struct in_addr	addr;
#endif

	*resolved = 0;
	if (!strcasecmp("any", host))
		return 0L;
	if (isdigit(*host))
		return inet_addr(host);

#if defined(__OpenBSD__)
	/* attempt a map from interface name to address */
	if (if_addr(host, &addr))
		return (u_32_t)addr.s_addr;
#endif
	if (!(hp = gethostbyname(host))) {
		if (!(np = getnetbyname(host))) {
			*resolved = -1;
			fprintf(stderr, "Line %d: can't resolve hostname: %s\n", linenum, host);
			return 0;
		}
		return htonl(np->n_net);
	}
	return *(u_32_t *)hp->h_addr;
}


d396 1
a396 1
		if (!(opts & OPT_NODO) && ioctl(fd, SIOCFLNAT, &n) == -1)
d403 2
a404 2
		n = 0;
		if (!(opts & OPT_NODO) && ioctl(fd, SIOCCNATL, &n) == -1)
@


1.37
log
@open /dev/ipl rdonly on non-destructive operations
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.36 2000/03/13 23:40:19 kjell Exp $	*/
d61 1
a61 1
static const char rcsid[] = "@@(#)$IPFilter: ipnat.c,v 2.1.2.2 1999/12/04 02:09:30 darrenr Exp $";
@


1.36
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
a125 1
	int	fd = -1, opts = 0, c;
d144 1
d148 1
d155 1
d164 1
a164 1
	if (!(opts & OPT_NODO) && ((fd = open(IPL_NAT, O_RDWR)) == -1) &&
@


1.35
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.34
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.33
log
@Add the ability to use interface names in place of addresses
in firewall rules. i.e.

block return-rst in quick on fxp0 proto tcp from any to fxp0 port = 9999

This will make things like DHCP much easier to deal with in the future.
@
text
@d1 2
a2 1
/* $OpenBSD: ipnat.c,v 1.32 1999/12/15 05:20:24 kjell Exp $ */
d61 1
a61 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.32 1999/12/15 05:20:24 kjell Exp $";
d405 1
@


1.32
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a49 3
#if defined(__OpenBSD__)
#include <err.h>
#endif
d60 1
a60 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 2.1.2.2 1999/12/04 02:09:30 darrenr Exp $";
d75 1
a75 1
int	if_addr __P((char *, struct in_addr *));
a403 67

#if defined(__OpenBSD__)
/*
 * if_addr():
 *	given a string containing an interface name (e.g. "ppp0")
 *	return the IP address it represents
 *
 * The OpenBSD community considers this feature to be quite useful and
 * suggests inclusion into other platforms. The closest alternative is
 * to define /etc/networks with suitable values.
 */
int	if_addr(name, ap)
char		*name;
struct in_addr	*ap;
{
	struct ifconf ifc;
	struct ifreq ifreq, *ifr;
	char *inbuf = NULL;
	int s, i, len = 8192;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		warn("socket");
		return 0;
	}

	while (1) {
		ifc.ifc_len = len;
		ifc.ifc_buf = inbuf = realloc(inbuf, len);
		if (inbuf == NULL)
			err(1, "malloc");
		if (ioctl(s, SIOCGIFCONF, &ifc) < 0) {
			warn("SIOCGIFCONF");
			goto if_addr_lose;
		}
		if (ifc.ifc_len + sizeof(ifreq) < len)
			break;
		len *= 2;
	}
	ifr = ifc.ifc_req;
	ifreq.ifr_name[0] = '\0';
	for (i = 0; i < ifc.ifc_len; ) {
		ifr = (struct ifreq *)((caddr_t)ifc.ifc_req + i);
		i += sizeof(ifr->ifr_name) +
			(ifr->ifr_addr.sa_len > sizeof(struct sockaddr)
				? ifr->ifr_addr.sa_len
				: sizeof(struct sockaddr));
		ifreq = *ifr;
		if (ioctl(s, SIOCGIFADDR, (caddr_t)ifr) < 0)
			continue;
		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;
		if (!strcmp(name, ifr->ifr_name)) {
			struct sockaddr_in *sin;
			close(s);
			free(inbuf);
			sin = (struct sockaddr_in *)&ifr->ifr_addr;
			*ap = sin->sin_addr;
			return (1);
		}
	}

if_addr_lose:
	close(s);
	free(inbuf);
	return 0;
}
#endif
@


1.31
log
@fix ipnat to not require -v
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.30 1999/07/23 19:48:02 kjell Exp $    */
a9 9
 *
 * Broken still:
 * Displaying the nat with redirect entries is way confusing
 *
 * Example redirection line:
 * rdr le1 0.0.0.0/0 port 79 -> 199.165.219.129 port 9901
 * 
 * Will redirect all incoming packets on le1 to any machine, port 79 to
 * host 199.165.219.129, port 9901
d37 3
d45 1
a45 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d50 3
d63 1
a63 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.30 1999/07/23 19:48:02 kjell Exp $";
d73 3
d77 5
a81 2
ipnat_t	*parse __P((char *));
u_32_t	hostnum __P((char *, int *));
a82 1
u_short	portnum __P((char *, char *));
a83 3
void	printnat __P((ipnat_t *, int, void *));
void	printaps __P((ap_session_t *, int ));
void	parsefile __P((int, char *, int));
d88 2
d98 1
d104 1
a104 1
	fprintf(stderr, "%s: [-CFlnrsv] [-f filename]\n", name);
d109 13
d127 1
a127 1
	int	fd = -1, opts = 1, c;
d129 1
a129 1
	while ((c = getopt(argc, argv, "CFf:lnrsv")) != -1)
d141 3
d151 1
a151 1
			opts &= ~OPT_REM;
d173 1
a173 1
		parsefile(fd, file, opts);
a208 106
void printnat(np, verbose, ptr)
ipnat_t *np;
int verbose;
void *ptr;
{
	struct	protoent	*pr;
	struct	servent	*sv;
	int	bits;

	switch (np->in_redir)
	{
	case NAT_REDIRECT :
		printf("rdr ");
		break;
	case NAT_MAP :
		printf("map ");
		break;
	case NAT_BIMAP :
		printf("bimap ");
		break;
	default :
		fprintf(stderr, "unknown value for in_redir: %#x\n",
			np->in_redir);
		break;
	}

	if (np->in_redir == NAT_REDIRECT) {
		printf("%s %s", np->in_ifname, inet_ntoa(np->in_out[0]));
		bits = countbits(np->in_out[1].s_addr);
		if (bits != -1)
			printf("/%d ", bits);
		else
			printf("/%s ", inet_ntoa(np->in_out[1]));
		if (np->in_pmin)
			printf("port %d ", ntohs(np->in_pmin));
		printf("-> %s", inet_ntoa(np->in_in[0]));
		if (np->in_pnext)
			printf(" port %d", ntohs(np->in_pnext));
		if ((np->in_flags & IPN_TCPUDP) == IPN_TCPUDP)
			printf(" tcp/udp");
		else if ((np->in_flags & IPN_TCP) == IPN_TCP)
			printf(" tcp");
		else if ((np->in_flags & IPN_UDP) == IPN_UDP)
			printf(" udp");
		printf("\n");
		if (verbose)
			printf("\t%p %u %x %u %p %d\n", np->in_ifp,
			       np->in_space, np->in_flags, np->in_pnext, np,
			       np->in_use);
	} else {
		np->in_nextip.s_addr = htonl(np->in_nextip.s_addr);
		printf("%s %s/", np->in_ifname, inet_ntoa(np->in_in[0]));
		bits = countbits(np->in_in[1].s_addr);
		if (bits != -1)
			printf("%d ", bits);
		else
			printf("%s", inet_ntoa(np->in_in[1]));
		printf(" -> %s/", inet_ntoa(np->in_out[0]));
		bits = countbits(np->in_out[1].s_addr);
		if (bits != -1)
			printf("%d ", bits);
		else
			printf("%s", inet_ntoa(np->in_out[1]));
		if (*np->in_plabel) {
			pr = getprotobynumber(np->in_p);
			printf(" proxy port");
			if (np->in_dport != 0) {
				if (pr != NULL)
					sv = getservbyport(np->in_dport,
							   pr->p_name);
				else
					sv = getservbyport(np->in_dport, NULL);
				if (sv != NULL)
					printf(" %s", sv->s_name);
				else
					printf(" %hu", ntohs(np->in_dport));
			}
			printf(" %.*s/", (int)sizeof(np->in_plabel),
				np->in_plabel);
			if (pr != NULL)
				fputs(pr->p_name, stdout);
			else
				printf("%d", np->in_p);
		} else if (np->in_pmin || np->in_pmax) {
			printf(" portmap");
			if ((np->in_flags & IPN_TCPUDP) == IPN_TCPUDP)
				printf(" tcp/udp");
			else if (np->in_flags & IPN_TCP)
				printf(" tcp");
			else if (np->in_flags & IPN_UDP)
				printf(" udp");
			printf(" %d:%d", ntohs(np->in_pmin),
			       ntohs(np->in_pmax));
		}
		printf("\n");
		if (verbose) {
			printf("\tifp %p space %u nextip %s pnext %d",
			       np->in_ifp, np->in_space,
			       inet_ntoa(np->in_nextip), np->in_pnext);
			printf(" flags %x use %u\n",
			       np->in_flags, np->in_use);
		}
	}
}


d215 1
a215 2
	ap_tcp_t apt;
	ap_udp_t apu;
d223 1
a223 2
	printf("\t\t%d %s -> ", ap.aps_p, inet_ntoa(ap.aps_src));
	printf("%s [%#x ", inet_ntoa(ap.aps_dst), ap.aps_flags);
d225 1
a225 1
	printf("%qu %qu", ap.aps_bytes, ap.aps_pkts);
d227 1
a227 1
	printf("%lu %lu", ap.aps_bytes, ap.aps_pkts);
d229 1
a229 1
	printf(" %x[%d]]\n", ap.aps_data, ap.aps_psiz);
d231 1
a231 2
		printf("\t\t%hu -> %hu state[%d,%d], sel[%d,%d]\n",
			ap.aps_sport, ap.aps_dport,
d234 2
d242 19
d274 2
a275 2
	if (ipnat && kmemcpy((char *)&ipnatbuff, (long)ipnat,
			     sizeof(ipnatbuff)))
d283 3
d332 2
d347 17
a363 21
		for (i = 0; i < NAT_SIZE; i++)
			for (np = nt[0][i]; np; np = nat.nat_hnext[0]) {
				if (kmemcpy((char *)&nat, (long)np,
					    sizeof(nat)))
					break;

				printf("%s %-15s %-5hu <- ->",
					getnattype(nat.nat_ptr),
					inet_ntoa(nat.nat_inip),
					ntohs(nat.nat_inport));
				printf(" %-15s %-5hu",
					inet_ntoa(nat.nat_outip),
					ntohs(nat.nat_outport));
				printf(" [%s %hu]", inet_ntoa(nat.nat_oip),
					ntohs(nat.nat_oport));
				if (opts & OPT_VERBOSE) {
					printf("\n\tage %lu use %hu sumd %x",
						nat.nat_age, nat.nat_use,
						nat.nat_sumd);
					printf(" bkt %d flags %x ",
						i, nat.nat_flags);
d365 2
a366 2
					printf("bytes %qu pkts %qu",
						nat.nat_bytes, nat.nat_pkts);
d368 2
a369 2
					printf("bytes %lu pkts %lu",
						nat.nat_bytes, nat.nat_pkts);
d372 1
a372 1
					printf(" %lx", nat.nat_ipsumd);
a373 4
				}
				putchar('\n');
				if (nat.nat_aps)
					printaps(nat.nat_aps, opts);
d375 5
a384 36
u_short	portnum(name, proto)
char	*name, *proto;
{
	struct	servent *sp, *sp2;
	u_short	p1 = 0;

	if (isdigit(*name))
		return htons((u_short)atoi(name));
	if (!proto)
		proto = "tcp/udp";
	if (strcasecmp(proto, "tcp/udp")) {
		sp = getservbyname(name, proto);
		if (sp)
			return sp->s_port;
		(void) fprintf(stderr, "unknown service \"%s\".\n", name);
		return 0;
	}
	sp = getservbyname(name, "tcp");
	if (sp)
		p1 = sp->s_port;
	sp2 = getservbyname(name, "udp");
	if (!sp || !sp2) {
		(void) fprintf(stderr, "unknown tcp/udp service \"%s\".\n",
			name);
		return 0;
	}
	if (p1 != sp2->s_port) {
		(void) fprintf(stderr, "%s %d/tcp is a different port to ",
			name, p1);
		(void) fprintf(stderr, "%s %d/udp\n", name, sp->s_port);
		return 0;
	}
	return p1;
}


a407 1

a474 1

d479 1
a479 1
u_32_t	hostnum(host, resolved)
d482 1
d493 2
a494 2
	if (inet_aton(host, &addr))
		return (u_32_t)addr.s_addr;
d504 1
a504 1
			fprintf(stderr, "can't resolve hostname: %s\n", host);
a509 340
}


ipnat_t *parse(line)
char *line;
{
	struct protoent *pr;
	static ipnat_t ipn;
	char *s, *t;
	char *shost, *snetm, *dhost, *proto;
	char *dnetm = NULL, *dport = NULL, *tport = NULL;
	int resolved;

	bzero((char *)&ipn, sizeof(ipn));
	if ((s = strchr(line, '\n')))
		*s = '\0';
	if ((s = strchr(line, '#')))
		*s = '\0';
	if (!*line)
		return NULL;
	if (!(s = strtok(line, " \t")))
		return NULL;
	if (!strcasecmp(s, "map"))
		ipn.in_redir = NAT_MAP;
	else if (!strcasecmp(s, "rdr"))
		ipn.in_redir = NAT_REDIRECT;
	else if (!strcasecmp(s, "bimap"))
		ipn.in_redir = NAT_BIMAP;
	else {
		(void)fprintf(stderr,
			      "expected map/rdr/bimap, got \"%s\"\n", s);
		return NULL;
	}

	if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "missing fields (interface)\n");
		return NULL;
	}
	strncpy(ipn.in_ifname, s, sizeof(ipn.in_ifname) - 1);
	ipn.in_ifname[sizeof(ipn.in_ifname) - 1] = '\0';
	if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "missing fields (%s)\n", 
			ipn.in_redir & NAT_MAP ? "source": "destination");
		return NULL;
	}
	shost = s;

	if (ipn.in_redir == NAT_REDIRECT) {
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr, "missing fields (destination port)\n");
			return NULL;
		}

		if (strcasecmp(s, "port")) {
			fprintf(stderr, "missing fields (port)\n");
			return NULL;
		}

		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr, "missing fields (destination port)\n");
			return NULL;
		}

		dport = s;
	}


	if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "missing fields (->)\n");
		return NULL;
	}
	if (!strcmp(s, "->")) {
		snetm = strrchr(shost, '/');
		if (!snetm) {
			fprintf(stderr, "missing fields (%s netmask)\n",
				ipn.in_redir & NAT_MAP ? "source":"destination");
			return NULL;
		}
	} else {
		if (strcasecmp(s, "netmask")) {
			fprintf(stderr, "missing fields (netmask)\n");
			return NULL;
		}
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr, "missing fields (%s netmask)\n",
				ipn.in_redir & NAT_MAP ? "source":"destination");
			return NULL;
		}
		snetm = s;
	}

        if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "missing fields (%s)\n",
			ipn.in_redir & NAT_MAP ? "target":"destination");
		return NULL;
	}
        dhost = s;

        if (ipn.in_redir & NAT_MAP) {
		if (!(s = strtok(NULL, " \t"))) {
			dnetm = strrchr(dhost, '/');
			if (!dnetm) {
				fprintf(stderr,
					"missing fields (dest netmask)\n");
				return NULL;
			}
		}
		if (!s || !strcasecmp(s, "portmap") ||
		    !strcasecmp(s, "proxy")) {
			dnetm = strrchr(dhost, '/');
			if (!dnetm) {
				fprintf(stderr,
					"missing fields (dest netmask)\n");
				return NULL;
			}
		} else {
			if (strcasecmp(s, "netmask")) {
				fprintf(stderr,
					"missing fields (dest netmask)\n");
				return NULL;
			}
			if (!(s = strtok(NULL, " \t"))) {
				fprintf(stderr,
					"missing fields (dest netmask)\n");
				return NULL;
			}
			dnetm = s;
		}
		if (*dnetm == '/')
			*dnetm++ = '\0';
	} else {
		if (strrchr(dhost, '/') != NULL) {
			fprintf(stderr, "No netmask supported in %s\n",
				"destination host for redirect");
			return NULL;
		}
		/* If it's a in_redir, expect target port */
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr, "missing fields (destination port)\n");
			return NULL;
		}

		if (strcasecmp(s, "port")) {
			fprintf(stderr, "missing fields (port)\n");
			return NULL;
		}
	  
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr, "missing fields (destination port)\n");
			return NULL;
		}
		tport = s;
	} 
	    

	if (*snetm == '/')
		*snetm++ = '\0';

	if (ipn.in_redir & NAT_MAP) {
		ipn.in_inip = hostnum(shost, &resolved);
		if (resolved == -1)
			return NULL;
		ipn.in_inmsk = hostmask(snetm);
		ipn.in_outip = hostnum(dhost, &resolved);
		if (resolved == -1)
			return NULL;
		ipn.in_outmsk = hostmask(dnetm);
	} else {
		ipn.in_inip = hostnum(dhost, &resolved); /* Inside is target */
		if (resolved == -1)
			return NULL;
		ipn.in_inmsk = hostmask("255.255.255.255");
		ipn.in_outip = hostnum(shost, &resolved);
		if (resolved == -1)
			return NULL;
		ipn.in_outmsk = hostmask(snetm);
		if (!(s = strtok(NULL, " \t"))) {
			ipn.in_flags = IPN_TCP; /* XXX- TCP only by default */
			proto = "tcp";
		} else {
			if (!strcasecmp(s, "tcp"))
				ipn.in_flags = IPN_TCP;
			else if (!strcasecmp(s, "udp"))
				ipn.in_flags = IPN_UDP;
			else if (!strcasecmp(s, "tcp/udp"))
				ipn.in_flags = IPN_TCPUDP;
			else if (!strcasecmp(s, "tcpudp"))
				ipn.in_flags = IPN_TCPUDP;
			else {
				fprintf(stderr,
					"expected protocol - got \"%s\"\n", s);
				return NULL;
			}
			proto = s;
			if ((s = strtok(NULL, " \t"))) {
				fprintf(stderr,
					"extra junk at the end of rdr: %s\n",
					s);
				return NULL;
			}
		}
		ipn.in_pmin = portnum(dport, proto); /* dest port */
		ipn.in_pmax = ipn.in_pmin; /* NECESSARY of removing nats */
		ipn.in_pnext = portnum(tport, proto); /* target port */
		s = NULL; /* That's all she wrote! */
	}
	ipn.in_inip &= ipn.in_inmsk;
	ipn.in_outip &= ipn.in_outmsk;

	if (!s)
		return &ipn;

	if (ipn.in_redir == NAT_BIMAP) {
		fprintf(stderr, "extra words at the end of bimap line: %s\n",
			s);
		return NULL;
	}
	if (!strcasecmp(s, "proxy")) {
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr, "missing parameter for \"proxy\"\n");
			return NULL;
		}
		dport = NULL;

		if (!strcasecmp(s, "port")) {
			if (!(s = strtok(NULL, " \t"))) {
				fprintf(stderr,
					"missing parameter for \"port\"\n");
				return NULL;
			}

			dport = s;

			if (!(s = strtok(NULL, " \t"))) {
				fprintf(stderr,
					"missing parameter for \"proxy\"\n");
				return NULL;
			}
		} else {
			fprintf(stderr, "missing keyword \"port\"\n");
			return NULL;
		}
		if ((proto = index(s, '/'))) {
			*proto++ = '\0';
			if ((pr = getprotobyname(proto)))
				ipn.in_p = pr->p_proto;
			else
				ipn.in_p = atoi(proto);
			if (dport)
				ipn.in_dport = portnum(dport, proto);
		} else {
			ipn.in_p = 0;
			if (dport)
				ipn.in_dport = portnum(dport, NULL);
		}

		(void) strncpy(ipn.in_plabel, s, sizeof(ipn.in_plabel));
		if ((s = strtok(NULL, " \t"))) {
			fprintf(stderr, "too many parameters for \"proxy\"\n");
			return NULL;
		}
		return &ipn;
		
	}
	if (strcasecmp(s, "portmap")) {
		fprintf(stderr, "expected \"portmap\" - got \"%s\"\n", s);
		return NULL;
	}
	if (!(s = strtok(NULL, " \t")))
		return NULL;
	if (!strcasecmp(s, "tcp"))
		ipn.in_flags = IPN_TCP;
	else if (!strcasecmp(s, "udp"))
		ipn.in_flags = IPN_UDP;
	else if (!strcasecmp(s, "tcpudp"))
		ipn.in_flags = IPN_TCPUDP;
	else if (!strcasecmp(s, "tcp/udp"))
		ipn.in_flags = IPN_TCPUDP;
	else {
		fprintf(stderr, "expected protocol name - got \"%s\"\n", s);
		return NULL;
	}
	proto = s;
	if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "no port range found\n");
		return NULL;
	}
	if (!(t = strchr(s, ':'))) {
		fprintf(stderr, "no port range in \"%s\"\n", s);
		return NULL;
	}
	*t++ = '\0';
	ipn.in_pmin = portnum(s, proto);
	ipn.in_pmax = portnum(t, proto);
	return &ipn;
}


void parsefile(fd, file, opts)
int fd;
char *file;
int opts;
{
	char	line[512], *s;
	ipnat_t	*np;
	FILE	*fp;
	int	linenum = 1;

	if (strcmp(file, "-")) {
		if (!(fp = fopen(file, "r"))) {
			(void) fprintf(stderr, "%s: open: %s\n", file,
				STRERROR(errno));
			exit(1);
		}
	} else
		fp = stdin;

	while (fgets(line, sizeof(line) - 1, fp)) {
		line[sizeof(line) - 1] = '\0';
		if ((s = strchr(line, '\n')))
			*s = '\0';
		if (!(np = parse(line))) {
			if (*line)
				fprintf(stderr, "%d: syntax error in \"%s\"\n",
					linenum, line);
		} else {
			if ((opts & OPT_VERBOSE) && np)
				printnat(np, opts &  OPT_VERBOSE, NULL);
			if (!(opts & OPT_NODO)) {
				if (opts & OPT_REM) {
					if (ioctl(fd, SIOCADNAT, np) == -1)
						perror("ioctl(SIOCADNAT)");
				} else if (ioctl(fd, SIOCRMNAT, np) == -1)
					perror("ioctl(SIOCRMNAT)");
			}
		}
		linenum++;
	}
	if (fp != stdin)
		fclose(fp);
@


1.30
log
@fix -n to work with verbose mode. ipnat -nvf will now show the parsed rules
without processing them.
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.29 1999/07/08 01:38:36 deraadt Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.29 1999/07/08 01:38:36 deraadt Exp $";
d944 3
a946 2
		} else if ((opts & OPT_VERBOSE) && np) {
			printnat(np, opts &  OPT_VERBOSE, NULL);
@


1.29
log
@stupid kmem snooping programs!
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.28 1999/06/06 20:34:56 deraadt Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.28 1999/06/06 20:34:56 deraadt Exp $";
d944 9
a952 8
		} else if (!(opts & OPT_NODO)) {
			if ((opts & OPT_VERBOSE) && np)
				printnat(np, opts &  OPT_VERBOSE, NULL);
			if (opts & OPT_REM) {
				if (ioctl(fd, SIOCADNAT, np) == -1)
					perror("ioctl(SIOCADNAT)");
			} else if (ioctl(fd, SIOCRMNAT, np) == -1)
				perror("ioctl(SIOCRMNAT)");
@


1.28
log
@use inet_aton() instead of inet_addr()
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.27 1999/06/03 17:53:11 deraadt Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.27 1999/06/03 17:53:11 deraadt Exp $";
d79 1
@


1.27
log
@check for interface names before hostnames
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.26 1999/02/05 05:58:48 deraadt Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.26 1999/02/05 05:58:48 deraadt Exp $";
d518 1
a518 1
 * get_if_addr():
d520 1
a520 1
 *	return the IP address it represents as an unsigned int
d526 3
a528 2
u_32_t  if_addr(name)
char   *name;
d537 1
a537 1
		return INADDR_NONE;
d571 2
a572 1
			return (sin->sin_addr.s_addr);
d579 1
a579 1
	return INADDR_NONE;
d595 1
a595 1
	u_32_t		addr;
d601 2
a602 2
	if (isdigit(*host))
		return inet_addr(host);
d606 2
a607 2
	if ((addr = if_addr(host)) != INADDR_NONE)
		return addr;
@


1.26
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.25 1998/10/11 05:36:32 deraadt Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.25 1998/10/11 05:36:32 deraadt Exp $";
d602 5
a608 5
#if defined(__OpenBSD__)
			/* attempt a map from interface name to address */
			if ((addr = if_addr(host)) != INADDR_NONE)
				return addr;
#endif
@


1.25
log
@NAT_MAP is now a flag; garath@@code.ridgefield.org
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.24 1998/10/06 06:32:54 deraadt Exp $    */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.24 1998/10/06 06:32:54 deraadt Exp $";
d86 1
d199 2
a201 1
	struct	protoent	*pr;
d258 1
d260 11
a270 2
			if (np->in_dport)
				printf(" %hu", ntohs(np->in_dport));
d273 1
a273 1
			if ((pr = getprotobynumber(np->in_p)))
d289 45
a333 4
		if (verbose)
			printf("\t%p %u %s %d %x\n", np->in_ifp,
			       np->in_space, inet_ntoa(np->in_nextip),
			       np->in_pnext, np->in_flags);
d430 13
a442 2
				printf(" %ld %hu %x", nat.nat_age,
					nat.nat_use, nat.nat_sumd);
d444 1
a444 1
				printf(" %lx", nat.nat_ipsumd);
d446 1
d448 2
d747 5
@


1.24
log
@fix the SIOCGIFCONF code; bug found by markc@@
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.23 1998/09/15 09:57:29 pattonme Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.23 1998/09/15 09:57:29 pattonme Exp $";
d591 1
a591 1
			ipn.in_redir ? "destination": "source");
d624 1
a624 1
				ipn.in_redir ? "destination":"source");
d634 1
a634 1
				ipn.in_redir ? "destination":"source");
d642 1
a642 1
			ipn.in_redir ? "destination":"target");
@


1.23
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.22 1998/03/21 22:42:13 millert Exp $    */
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id$";
d493 2
a494 2
		if (!strncmp(ifreq.ifr_name, ifr->ifr_name,
				sizeof(ifr->ifr_name)))
a495 5
		ifreq = *ifr;
		if (ioctl(s, SIOCGIFADDR, (caddr_t)ifr) < 0) {
			warn("SIOCGIFADDR");
			goto if_addr_lose;
		}
@


1.22
log
@Print the devicename in the error message when it cannot be opened
since it is not obvious from the source.
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.21 1998/03/07 00:34:27 deraadt Exp $    */
d23 1
d51 8
a58 4
#include "ip_fil_compat.h"
#include "ip_fil.h"
#include "ip_proxy.h"
#include "ip_nat.h"
d61 7
d70 1
a70 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.21 1998/03/07 00:34:27 deraadt Exp $";
d81 2
a82 2
u_int	hostnum __P((char *, int *));
u_int	hostmask __P((char *));
d88 1
a88 1
int	countbits __P((u_int));
d149 2
a150 1
		perror("open "IPL_NAT);
d170 1
a170 1
u_int	ip;
d172 1
a172 1
	u_int	ipn;
d377 1
a377 1
				printf(" %ld %hu %lx", nat.nat_age,
d425 1
a425 1
u_int	hostmask(msk)
d429 1
a429 1
	u_int	mask;
d432 1
a432 1
		return (u_int)-1;
d436 1
a436 1
		return (u_int)strtol(msk, NULL, 0);
d448 10
a457 3
/* 
 * get_if_addr(): given a string containing an interface name (e.g. "ppp0")
 *		  return the IP address it represents as an unsigned int
d459 2
a460 2
u_int	if_addr(name)
char	*name;
d471 1
a471 1
	
d494 1
a494 1
			     sizeof(ifr->ifr_name)))
d511 1
d517 2
d521 1
a521 1
 * returns an ip address as an int var as a result of either a DNS lookup or
d524 1
a524 1
u_int	hostnum(host, resolved)
d530 3
d542 2
a543 1
			u_int addr;
d546 1
d787 3
d859 2
a860 1
			perror(file);
@


1.21
log
@n_net is host byte order; pattonme@@gnpr.pae.osd.mil
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.20 1998/02/24 04:03:38 dgregor Exp $    */
d58 1
a58 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.20 1998/02/24 04:03:38 dgregor Exp $";
d137 1
a137 1
		perror("open");
@


1.20
log
@put back support for ppp0/32
@
text
@d1 1
a1 1
/*    $OpenBSD: ipnat.c,v 1.19 1998/01/26 04:13:49 dgregor Exp $    */
d58 1
a58 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 1.19 1998/01/26 04:13:49 dgregor Exp $";
d523 1
a523 1
		return np->n_net;
@


1.19
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*    $OpenBSD$    */
d58 1
a58 1
static const char rcsid[] = "@@(#)$Id: ipnat.c,v 2.0.2.21.2.1 1997/11/08 04:55:55 darrenr Exp $";
d69 2
a70 2
u_long	hostnum __P((char *, int *));
u_long	hostmask __P((char *));
d76 1
a76 1
int	countbits __P((u_long));
d157 1
a157 1
u_long	ip;
d159 1
a159 1
	u_long	ipn;
d237 1
a237 1
		bits = countbits(ntohl(np->in_out[1].s_addr));
d412 1
a412 1
u_long	hostmask(msk)
d416 1
a416 1
	u_long	mask;
d419 1
a419 1
		return (u_long)-1;
d423 1
a423 1
		return (u_long)strtol(msk, NULL, 0);
d435 61
d498 1
a498 1
 * returns an ip address as a long var as a result of either a DNS lookup or
d501 1
a501 1
u_long	hostnum(host, resolved)
d516 3
@


1.18
log
@Change some longs to ints for alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.17 1997/07/08 13:15:21 kstailey Exp $	*/
d3 1
a3 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d23 1
d29 1
a29 1
#include <sys/types.h>
a44 2
#include "ip_fil_compat.h"
#include "ip_fil.h"		/* XXX needed? */
d49 4
d54 1
a54 1
#include <ctype.h>
d56 4
a60 4
#if !defined(lint) && defined(LIBC_SCCS)
static  char    sccsid[] ="@@(#)ipnat.c	1.9 6/5/96 (C) 1993 Darren Reed";
static	char	rcsid[] = "$DRId: ipnat.c,v 2.0.1.8 1997/02/16 21:23:40 darrenr Exp $";
#endif
a66 1
extern	int	kmemcpy();
d68 11
a78 1
void	dostats(), printnat(), parsefile(), flushtable();
d101 2
a102 2
	char	*file = NULL, c;
	int	fd, opts = 1;
d135 2
a136 2
	if (!(opts & OPT_NODO) && ((fd = open(IPL_NAME, O_RDWR)) == -1) &&
	    ((fd = open(IPL_NAME, O_RDONLY)) == -1)) {
d157 1
a157 1
u_int	ip;
d159 1
a159 1
	u_int	ipn;
d186 18
d206 1
a206 1
		printf("rdr %s %s", np->in_ifname, inet_ntoa(np->in_out[0]));
d217 1
a217 1
		if (np->in_flags & IPN_TCPUDP)
d219 1
a219 1
		else if (np->in_flags & IPN_TCP)
d221 1
a221 1
		else if (np->in_flags & IPN_UDP)
d230 1
a230 1
		printf("map %s %s/", np->in_ifname, inet_ntoa(np->in_in[0]));
d237 1
a237 1
		bits = countbits(np->in_out[1].s_addr);
d242 11
a252 1
		if (np->in_pmin || np->in_pmax) {
d278 1
d281 2
a282 1
	if (ipnat && kmemcpy(&ipnatbuff, ipnat, sizeof(ipnatbuff)))
d285 16
a300 1
	return (ipnatbuff.in_redir == NAT_MAP) ? "MAP" : "RDR";
d324 1
a324 1
		printf("inuse\t%lu\n", ns.ns_inuse);
d331 2
a332 1
			if (kmemcpy(&ipn, ns.ns_list, sizeof(ipn))) {
d341 2
a342 1
		if (kmemcpy(nt[0], ns.ns_table[0], sizeof(**nt) * NAT_SIZE)) {
d351 2
a352 1
				if (kmemcpy(&nat, np, sizeof(nat)))
d364 1
a364 1
				printf(" %d %hu %lx", nat.nat_age,
d412 1
a412 1
u_int	hostmask(msk)
d416 1
a416 1
	u_int	mask;
d419 1
a419 1
		return (u_int)-1;
d423 1
a423 1
		return (u_int)strtol(msk, NULL, 0);
a434 59
/* 
 * get_if_addr(): given a string containing an interface name (e.g. "ppp0")
 *		  return the IP address it represents as an unsigned int
 */
u_int	if_addr(name)
char	*name;
{
	struct ifconf ifc;
	struct ifreq ifreq, *ifr;
	char *inbuf = NULL;
	int s, i, len = 8192;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		warn("socket");
		return INADDR_NONE;
	}
	
	while (1) {
		ifc.ifc_len = len;
		ifc.ifc_buf = inbuf = realloc(inbuf, len);
		if (inbuf == NULL)
			err(1, "malloc");
		if (ioctl(s, SIOCGIFCONF, &ifc) < 0) {
			warn("SIOCGIFCONF");
			goto if_addr_lose;
		}
		if (ifc.ifc_len + sizeof(ifreq) < len)
			break;
		len *= 2;
	}
	ifr = ifc.ifc_req;
	ifreq.ifr_name[0] = '\0';
	for (i = 0; i < ifc.ifc_len; ) {
		ifr = (struct ifreq *)((caddr_t)ifc.ifc_req + i);
		i += sizeof(ifr->ifr_name) +
			(ifr->ifr_addr.sa_len > sizeof(struct sockaddr)
				? ifr->ifr_addr.sa_len
				: sizeof(struct sockaddr));
		if (!strncmp(ifreq.ifr_name, ifr->ifr_name,
			     sizeof(ifr->ifr_name)))
			continue;
		ifreq = *ifr;
		if (ioctl(s, SIOCGIFADDR, (caddr_t)ifr) < 0)
			continue;
		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;
		if (!strcmp(name, ifr->ifr_name)) {
			struct sockaddr_in *sin;
			close(s);
			free(inbuf);
			sin = (struct sockaddr_in *)&ifr->ifr_addr;
			return (sin->sin_addr.s_addr);
		}
	}
if_addr_lose:
	close(s);
	free(inbuf);
	return INADDR_NONE;
}
d437 1
a437 1
 * returns an ip address as an int var as a result of either a DNS lookup or
d440 1
a440 1
u_int	hostnum(host, resolved)
a454 3
			u_int addr;
			if ((addr = if_addr(host)) != INADDR_NONE)
				return addr;
d461 1
a461 1
	return *(u_int32_t *)hp->h_addr;
d468 1
d488 2
d492 1
a492 1
			      "expected \"map\" or \"rdr\", got \"%s\"\n", s);
d560 1
a560 1
        if (ipn.in_redir == NAT_MAP) {
d569 2
a570 1
		if (!s || !strcasecmp(s, "portmap")) {
d615 1
a615 1
	if (ipn.in_redir == NAT_MAP) {
d669 49
d763 3
a765 3
		if ((fp = fopen(file, "r")) == NULL) {
			perror("fopen");
			exit(-1);
d789 2
a790 1
	fclose(stdin);
@


1.17
log
@countbits() uses network byte order, not host byte order; enami tsugutomo, NetBSD PR 3830
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.16 1997/06/23 17:02:43 kstailey Exp $	*/
d145 1
a145 1
u_long	ip;
d147 1
a147 1
	u_long	ipn;
d352 1
a352 1
u_long	hostmask(msk)
d356 1
a356 1
	u_long	mask;
d359 1
a359 1
		return (u_long)-1;
d363 1
a363 1
		return (u_long)strtol(msk, NULL, 0);
d377 1
a377 1
 *		  return the IP address it represents as an unsigned long
d379 1
a379 1
u_long	if_addr(name)
d436 1
a436 1
 * returns an ip address as a long var as a result of either a DNS lookup or
d439 1
a439 1
u_long	hostnum(host, resolved)
d454 1
a454 1
			u_long addr;
@


1.16
log
@use masks
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.15 1997/06/23 01:16:16 deraadt Exp $	*/
d207 1
a207 1
		bits = countbits(ntohl(np->in_out[1].s_addr));
@


1.15
log
@sizeof(int) != sizeof(long)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.14 1997/06/17 10:42:08 provos Exp $	*/
d56 1
a56 1
static	char	rcsid[] = "Id: ipnat.c,v 2.0.1.7 1997/01/30 12:02:32 darrenr Exp";
d661 3
d666 1
@


1.14
log
@dont coredump if the specified rule file does not exist
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.13 1997/02/14 11:02:05 niklas Exp $	*/
d463 1
a463 1
	return *(u_long *)hp->h_addr;
@


1.13
log
@64-bit clean
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.12 1997/02/13 23:33:37 kstailey Exp $	*/
d707 6
a712 3
	if (strcmp(file, "-"))
		fp = fopen(file, "r");
	else
@


1.12
log
@don't fail completely in if_addr() just because one interface won't SIOCGIFADDR.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.11 1997/02/13 01:19:05 kstailey Exp $	*/
d195 1
a195 1
			printf("\t%x %u %x %u %x %d\n", (u_int)np->in_ifp,
d225 1
a225 1
			printf("\t%x %u %s %d %x\n", (u_int)np->in_ifp,
d269 1
a269 2
			printf("table %#x list %#x\n",
				(u_int)ns.ns_table, (u_int)ns.ns_list);
@


1.11
log
@Allow use of interface name in rules file.  This way if you have a dynamic
IP address you don't have to edit the rules file every time you connect.

Example of usage:

coyote% cat /etc/nat.rules
map ppp0 10.0.0.0/8 -> ppp0/32 portmap tcp/udp 10000:20000

ppp0 is automagically transformed into the IP address of the ppp0 interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.10 1997/02/11 22:24:20 kstailey Exp $	*/
d418 2
a419 4
		if (ioctl(s, SIOCGIFADDR, (caddr_t)ifr) < 0) {
			warn("SIOCGIFADDR");
			goto if_addr_lose;
		}
@


1.10
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d376 61
d450 1
a450 1
	if (!strcasecmp("any",host))
d457 3
@


1.9
log
@fixed order of tests in printnat() so that it catches tcp/udp first
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.8 1997/02/07 19:33:49 kstailey Exp $	*/
d45 1
a45 1
#include "ip_fil.h"
d53 2
a54 2
#if 0
#ifndef lint
d56 1
a56 1
#endif
d66 9
a74 1
void	dostats(), printnat(), parsefile();
d80 1
a80 1
	fprintf(stderr, "%s: [-lnrsv] [-f filename]\n", name);
d92 1
a92 1
	while ((c = getopt(argc, argv, "f:lnrsv")) != -1)
d95 3
d101 3
d105 1
a105 1
			opts |= 8;
d108 1
a108 1
			opts |= 2;
d111 1
a111 1
			opts &= ~1;
d114 1
a114 1
			opts |= 4;
d117 1
a117 1
			opts |= 16;
d123 1
a123 1
	if (((fd = open(IPL_NAME, O_RDWR)) == -1) &&
d129 2
d133 1
a133 1
	if (opts & 12)
d168 1
a168 1
void printnat(np, verbose)
d171 1
d184 9
a192 4
		printf("-> %s", inet_ntoa(np->in_in[0]),
		       ntohs(np->in_pnext));
		if (np->in_pmax)
			printf(" port %d", ntohs(np->in_pmax));
d195 3
a197 2
			printf("\t%x %u %x %u", (u_int)np->in_ifp,
			       np->in_space, np->in_flags, np->in_pnext);
d212 1
a212 1
		if (np->in_port[0] || np->in_port[1]) {
d214 1
a214 1
			if (np->in_flags & IPN_TCPUDP)
d220 2
a221 2
			printf(" %d:%d", ntohs(np->in_port[0]),
			       ntohs(np->in_port[1]));
d232 15
d252 2
a253 2
	nat_t	**nt, *np, nat;
	int	i;
d255 3
a257 1
	if (ioctl(fd, SIOCGNATS, &ns) == -1) {
d261 2
a262 1
	if (opts & 4) {
d268 1
a268 1
		if (opts & 16)
d272 2
a273 1
	if (opts & 8) {
d279 1
a279 1
			printnat(&ipn, opts & 16);
d283 2
a284 2
		nt = (nat_t **)malloc(sizeof(*nt) * NAT_SIZE);
		if (kmemcpy(nt, ns.ns_table, sizeof(*nt) * NAT_SIZE)) {
d288 3
d292 1
a292 1
			for (np = nt[i]; np; np = nat.nat_next) {
d295 3
a297 1
				printf("%s %hu <- -> ",
d300 1
a300 1
				printf("%s %hu %hu %hu %lx [",
d302 2
a303 4
					ntohs(nat.nat_outport),
					nat.nat_age, nat.nat_use,
					nat.nat_sumd);
				printf("%s %hu]\n", inet_ntoa(nat.nat_oip),
d305 6
d312 1
d411 2
a412 1
	char *shost, *snetm, *dhost, *dnetm, *proto, *dport, *tport;
d554 2
d558 2
d563 2
d567 2
d580 2
d588 6
d612 2
d659 4
a662 4
		} else if (!(opts & 2)) {
			if ((opts &16) && np)
				printnat(np, opts & 16);
			if (opts & 1) {
d671 23
@


1.8
log
@one more tcpudp->tcp/udp
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.7 1997/02/07 18:26:47 kstailey Exp $	*/
d191 3
a193 1
			if (np->in_flags & IPN_TCP)
a196 2
			else if (np->in_flags & IPN_TCPUDP)
				printf(" tcp/udp");
@


1.7
log
@make output look like input (and like docs)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipnat.c,v 1.6 1997/02/07 18:10:07 kstailey Exp $	*/
d543 1
a543 1
	else if (!strcasecmp(s, "tcpudp"))
@


1.6
log
@fix tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d196 1
a196 1
				printf(" tcpudp");
@


1.5
log
@make protocol string be tcp/udp not tcpudp since this is how it is documented.
@
text
@d1 1
d53 1
a53 1

d56 1
a56 1
static	char	rcsid[] = "$Id: ipnat.c,v 1.4 1996/10/08 07:33:33 niklas Exp $";
@


1.4
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d55 1
a55 1
static	char	rcsid[] = "$Id: ipnat.c,v 1.3 1996/07/18 05:08:39 dm Exp $";
d516 1
a516 1
			else if (!strcasecmp(s, "tcpudp"))
@


1.3
log
@ipfilter 3.1.0
@
text
@d44 1
d55 1
a55 1
static	char	rcsid[] = "$Id: ipnat.c,v 1.2 1996/07/07 02:45:58 darrenr Exp $";
@


1.2
log
@update rcsid
@
text
@a0 2
/*	$OpenBSD$	*/

d43 1
a43 1
#include "ip_fil.h"
d53 2
a54 1
static  char    sccsid[] ="@@(#)ipnat.c	1.8 4/10/96 (C) 1993 Darren Reed";
d66 9
d104 1
a104 2
			fprintf(stderr, "unknown option \"%c\"\n", c);
			break;
d107 2
a108 1
	if ((fd = open(IPL_NAME, O_RDONLY)) == -1) {
d116 1
a116 1
		dostats(fd);
d121 30
a150 1
void printnat(np)
d152 1
d154 2
d158 8
a165 3
		printf("/%s (%d) -> ", inet_ntoa(np->in_out[1]),
		       ntohs(np->in_pmin));
		printf("%s (%d)\n", inet_ntoa(np->in_in[0]),
d167 6
a172 2
		printf("\t%x %u %x %u\n", (u_int)np->in_ifp, np->in_space,
		       np->in_flags, np->in_pnext);
d176 27
a202 7
		printf("%s -> ", inet_ntoa(np->in_in[1]));
		printf("%s/", inet_ntoa(np->in_out[0]));
		printf("%s\n", inet_ntoa(np->in_out[1]));
		printf("\t%x %u %s %x %u %d:%d\n", (u_int)np->in_ifp,
		       np->in_space, inet_ntoa(np->in_nextip), np->in_flags,
		       np->in_pnext, ntohs(np->in_port[0]),
		       ntohs(np->in_port[1]));
d225 3
a227 2
		printf("table %#x list %#x\n",
			(u_int)ns.ns_table, (u_int)ns.ns_list);
d235 1
a235 1
			printnat(&ipn);
a489 1
	  
d588 1
a588 1
				printnat(np);
@


1.1
log
@ipfilter 3.0.4
@
text
@d1 2
@

