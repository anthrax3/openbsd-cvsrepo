head	1.12;
access;
symbols
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.12
date	2001.05.30.02.11.49;	author deraadt;	state dead;
branches;
next	1.11;

1.11
date	2001.02.18.23.20.42;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.05.17.33.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.30.04.26.50;	author kjell;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.23.02.24.12;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.17.05.01.01;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.10.05.50.27;	author kjell;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.01.06.16.48;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.13.23.40.19;	author kjell;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.16.22.34.22;	author kjell;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.01.19.30.00;	author kjell;	state Exp;
branches;
next	1.1;

1.1
date	99.12.14.04.17.17;	author kjell;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: natparse.c,v 1.11 2001/02/18 23:20:42 millert Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#if !defined(__SVR4) && !defined(__svr4__)
#include <strings.h>
#else
#include <sys/byteorder.h>
#endif
#include <sys/time.h>
#include <sys/param.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#if defined(sun) && (defined(__svr4__) || defined(__SVR4))
# include <sys/ioccom.h>
# include <sys/sysmacros.h>
#endif
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <net/if.h>
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
#endif
#include <netdb.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <resolv.h>
#include <ctype.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include "ipf.h"

#if	defined(sun) && !SOLARIS2
# define	STRERROR(x)	sys_errlist[x]
extern	char	*sys_errlist[];
#else
# define	STRERROR(x)	strerror(x)
#endif

#if !defined(lint)
static const char sccsid[] ="@@(#)ipnat.c	1.9 6/5/96 (C) 1993 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: natparse.c,v 1.17.2.6 2000/07/08 02:14:40 darrenr Exp $";
#endif


#if	SOLARIS
#define	bzero(a,b)	memset(a,0,b)
#endif

extern	int	countbits __P((u_32_t));
extern	char	*proto;

ipnat_t	*natparse __P((char *, int));
void	printnat __P((ipnat_t *, int, void *));
void	natparsefile __P((int, char *, int));
void	nat_setgroupmap __P((struct ipnat *));


void printnat(np, opts, ptr)
ipnat_t *np;
int opts;
void *ptr;
{
	struct	protoent	*pr;
	struct	servent	*sv;
	int	bits;

	switch (np->in_redir)
	{
	case NAT_REDIRECT :
		printf("rdr");
		break;
	case NAT_MAP :
		printf("map");
		break;
	case NAT_MAPBLK :
		printf("map-block");
		break;
	case NAT_BIMAP :
		printf("bimap");
		break;
	default :
		fprintf(stderr, "unknown value for in_redir: %#x\n",
			np->in_redir);
		break;
	}

	printf(" %s ", np->in_ifname);

	if (np->in_flags & IPN_FILTER) {
		if (np->in_flags & IPN_NOTSRC)
			printf("! ");
		printf("from ");
		if (np->in_redir == NAT_REDIRECT) {
			printhostmask(4, (u_32_t *)&np->in_srcip,
				      (u_32_t *)&np->in_srcmsk);
			if (np->in_scmp)
				printportcmp(np->in_p, &np->in_tuc.ftu_src);
		} else {
			printhostmask(4, (u_32_t *)&np->in_inip,
				      (u_32_t *)&np->in_inmsk);
			if (np->in_dcmp)
				printportcmp(np->in_p, &np->in_tuc.ftu_dst);
		}

		if (np->in_flags & IPN_NOTDST)
			printf(" !");
		printf(" to ");
		if (np->in_redir == NAT_REDIRECT) {
			printhostmask(4, (u_32_t *)&np->in_outip,
				      (u_32_t *)&np->in_outmsk);
			if (np->in_dcmp)
				printportcmp(np->in_p, &np->in_tuc.ftu_dst);
		} else {
			printhostmask(4, (u_32_t *)&np->in_srcip,
				      (u_32_t *)&np->in_srcmsk);
			if (np->in_scmp)
				printportcmp(np->in_p, &np->in_tuc.ftu_src);
		}
	}

	if (np->in_redir == NAT_REDIRECT) {
		if (!(np->in_flags & IPN_FILTER)) {
			printf("%s", inet_ntoa(np->in_out[0]));
			bits = countbits(np->in_out[1].s_addr);
			if (bits != -1)
				printf("/%d ", bits);
			else
				printf("/%s ", inet_ntoa(np->in_out[1]));
			if (np->in_pmin)
				printf("port %d", ntohs(np->in_pmin));
			if (np->in_pmax != np->in_pmin)
				printf("- %d", ntohs(np->in_pmax));
		}
		printf(" -> %s", inet_ntoa(np->in_in[0]));
		if (np->in_flags & IPN_SPLIT)
			printf(",%s", inet_ntoa(np->in_in[1]));
		if (np->in_pnext)
			printf(" port %d", ntohs(np->in_pnext));
		if ((np->in_flags & IPN_TCPUDP) == IPN_TCPUDP)
			printf(" tcp/udp");
		else if ((np->in_flags & IPN_TCP) == IPN_TCP)
			printf(" tcp");
		else if ((np->in_flags & IPN_UDP) == IPN_UDP)
			printf(" udp");
		if (np->in_flags & IPN_ROUNDR)
			printf(" round-robin");
		printf("\n");
		if (opts & OPT_DEBUG)
			printf("\t%p %lu %#x %u %p %d\n", np->in_ifp,
			       np->in_space, np->in_flags, np->in_pmax, np,
			       np->in_use);
	} else {
		np->in_nextip.s_addr = htonl(np->in_nextip.s_addr);
		if (!(np->in_flags & IPN_FILTER)) {
			printf("%s/", inet_ntoa(np->in_in[0]));
			bits = countbits(np->in_in[1].s_addr);
			if (bits != -1)
				printf("%d ", bits);
			else
				printf("%s", inet_ntoa(np->in_in[1]));
		}
		printf(" -> ");
		if (np->in_flags & IPN_IPRANGE) {
			printf("range %s-", inet_ntoa(np->in_out[0]));
			printf("%s", inet_ntoa(np->in_out[1]));
		} else {
			printf("%s/", inet_ntoa(np->in_out[0]));
			bits = countbits(np->in_out[1].s_addr);
			if (bits != -1)
				printf("%d ", bits);
			else
				printf("%s", inet_ntoa(np->in_out[1]));
		}
		if (*np->in_plabel) {
			pr = getprotobynumber(np->in_p);
			printf(" proxy port");
			if (np->in_dport != 0) {
				if (pr != NULL)
					sv = getservbyport(np->in_dport,
							   pr->p_name);
				else
					sv = getservbyport(np->in_dport, NULL);
				if (sv != NULL)
					printf(" %s", sv->s_name);
				else
					printf(" %hu", ntohs(np->in_dport));
			}
			printf(" %.*s/", (int)sizeof(np->in_plabel),
				np->in_plabel);
			if (pr != NULL)
				fputs(pr->p_name, stdout);
			else
				printf("%d", np->in_p);
		} else if (np->in_redir == NAT_MAPBLK) {
			printf(" ports %d", np->in_pmin);
			if (opts & OPT_VERBOSE)
				printf("\n\tip modulous %d", np->in_pmax);
		} else if (np->in_pmin || np->in_pmax) {
			printf(" portmap");
			if (np->in_flags & IPN_AUTOPORTMAP) {
				printf(" auto");
				if (opts & OPT_DEBUG)
					printf(" [%d:%d %d %d]",
					       ntohs(np->in_pmin),
					       ntohs(np->in_pmax),
					       np->in_ippip, np->in_ppip);
			} else {
				if ((np->in_flags & IPN_TCPUDP) == IPN_TCPUDP)
					printf(" tcp/udp");
				else if (np->in_flags & IPN_TCP)
					printf(" tcp");
				else if (np->in_flags & IPN_UDP)
					printf(" udp");
				printf(" %d:%d", ntohs(np->in_pmin),
				       ntohs(np->in_pmax));
			}
		}
		printf("\n");
		if (opts & OPT_DEBUG) {
			printf("\tifp %p space %lu nextip %s pnext %d",
			       np->in_ifp, np->in_space,
			       inet_ntoa(np->in_nextip), np->in_pnext);
			printf(" flags %x use %u\n",
			       np->in_flags, np->in_use);
		}
	}
}


void nat_setgroupmap(n)
ipnat_t *n;
{
	if (n->in_outmsk == n->in_inmsk)
		n->in_ippip = 1;
	else if (n->in_flags & IPN_AUTOPORTMAP) {
		n->in_ippip = ~ntohl(n->in_inmsk);
		if (n->in_outmsk != 0xffffffff)
			n->in_ippip /= (~ntohl(n->in_outmsk) + 1);
		n->in_ippip++;
		if (n->in_ippip == 0)
			n->in_ippip = 1;
		n->in_ppip = USABLE_PORTS / n->in_ippip;
	} else {
		n->in_space = USABLE_PORTS * ~ntohl(n->in_outmsk);
		n->in_nip = 0;
		if (!(n->in_ppip = n->in_pmin))
			n->in_ppip = 1;
		n->in_ippip = USABLE_PORTS / n->in_ppip;
	}
}



ipnat_t *natparse(line, linenum)
char *line;
int linenum;
{
	static ipnat_t ipn;
	struct protoent *pr;
	char *dnetm = NULL, *dport = NULL;
	char *s, *t, *cps[31], **cpp;
	int i, cnt;


	if ((s = strchr(line, '\n')))
		*s = '\0';
	if ((s = strchr(line, '#')))
		*s = '\0';
	while (*line && isspace(*line))
		line++;
	if (!*line)
		return NULL;

	bzero((char *)&ipn, sizeof(ipn));
	cnt = 0;

	for (i = 0, *cps = strtok(line, " \b\t\r\n"); cps[i] && i < 30; cnt++)
		cps[++i] = strtok(NULL, " \b\t\r\n");

	cps[i] = NULL;

	if (cnt < 3) {
		fprintf(stderr, "%d: not enough segments in line\n", linenum);
		return NULL;
	}

	cpp = cps;

	if (!strcasecmp(*cpp, "map"))
		ipn.in_redir = NAT_MAP;
	else if (!strcasecmp(*cpp, "map-block"))
		ipn.in_redir = NAT_MAPBLK;
	else if (!strcasecmp(*cpp, "rdr"))
		ipn.in_redir = NAT_REDIRECT;
	else if (!strcasecmp(*cpp, "bimap"))
		ipn.in_redir = NAT_BIMAP;
	else {
		fprintf(stderr, "%d: unknown mapping: \"%s\"\n",
			linenum, *cpp);
		return NULL;
	}

	cpp++;

	strncpy(ipn.in_ifname, *cpp, sizeof(ipn.in_ifname) - 1);
	ipn.in_ifname[sizeof(ipn.in_ifname) - 1] = '\0';
	cpp++;

	if (!strcasecmp(*cpp, "from") || (**cpp == '!')) {
		if (!strcmp(*cpp, "!")) {
			cpp++;
			if (strcasecmp(*cpp, "from")) {
				fprintf(stderr, "Missing from after !\n");
				return NULL;
			}
			ipn.in_flags |= IPN_NOTSRC;
		} else if (**cpp == '!') {
			if (strcasecmp(*cpp + 1, "from")) {
				fprintf(stderr, "Missing from after !\n");
				return NULL;
			}
			ipn.in_flags |= IPN_NOTSRC;
		}
		if ((ipn.in_flags & IPN_NOTSRC) &&
		    (ipn.in_redir & (NAT_MAP|NAT_MAPBLK))) {
			fprintf(stderr, "Cannot use '! from' with map\n");
			return NULL;
		}

		ipn.in_flags |= IPN_FILTER;
		cpp++;
		if (ipn.in_redir == NAT_REDIRECT) {
				if (hostmask(&cpp, (u_32_t *)&ipn.in_srcip,
					     (u_32_t *)&ipn.in_srcmsk,
					     &ipn.in_sport, &ipn.in_scmp,
					     &ipn.in_stop, linenum)) {
					return NULL;
				}
		} else {
				if (hostmask(&cpp, (u_32_t *)&ipn.in_inip,
					     (u_32_t *)&ipn.in_inmsk,
					     &ipn.in_sport, &ipn.in_scmp,
					     &ipn.in_stop, linenum)) {
					return NULL;
				}
		}

		if (!strcmp(*cpp, "!")) {
			cpp++;
			ipn.in_flags |= IPN_NOTDST;
		} else if (**cpp == '!') {
			(*cpp)++;
			ipn.in_flags |= IPN_NOTDST;
		}

		if (strcasecmp(*cpp, "to")) {
			fprintf(stderr, "%d: unexpected keyword (%s) - to\n",
				linenum, *cpp);
			return NULL;
		}
		if ((ipn.in_flags & IPN_NOTDST) &&
		    (ipn.in_redir & (NAT_REDIRECT))) {
			fprintf(stderr, "Cannot use '! to' with rdr\n");
			return NULL;
		}

		if (!*++cpp) {
			fprintf(stderr, "%d: missing host after to\n", linenum);
			return NULL;
		}
		if (ipn.in_redir == NAT_REDIRECT) {
				if (hostmask(&cpp, (u_32_t *)&ipn.in_outip,
					     (u_32_t *)&ipn.in_outmsk,
					     &ipn.in_dport, &ipn.in_dcmp,
					     &ipn.in_dtop, linenum)) {
					return NULL;
				}
				ipn.in_pmin = htons(ipn.in_dport);
		} else {
				if (hostmask(&cpp, (u_32_t *)&ipn.in_srcip,
					     (u_32_t *)&ipn.in_srcmsk,
					     &ipn.in_dport, &ipn.in_dcmp,
					     &ipn.in_dtop, linenum)) {
					return NULL;
				}
		}
	} else {
		s = *cpp;
		if (!s)
			return NULL;
		t = strchr(s, '/');
		if (!t)
			return NULL;
		*t++ = '\0';
		if (ipn.in_redir == NAT_REDIRECT) {
			if (hostnum((u_32_t *)&ipn.in_outip, s, linenum) == -1)
				return NULL;
			if (genmask(t, (u_32_t *)&ipn.in_outmsk) == -1) {
				return NULL;
			}
		} else {
			if (hostnum((u_32_t *)&ipn.in_inip, s, linenum) == -1)
				return NULL;
			if (genmask(t, (u_32_t *)&ipn.in_inmsk) == -1) {
				return NULL;
			}
		}
		cpp++;
		if (!*cpp)
			return NULL;
	}

	if ((ipn.in_redir == NAT_REDIRECT) && !(ipn.in_flags & IPN_FILTER)) {
		if (strcasecmp(*cpp, "port")) {
			fprintf(stderr, "%d: missing fields - 1st port\n",
				linenum);
			return NULL;
		}

		/* The default protocol for "redir" is TCP */
		ipn.in_flags |= IPN_TCP;
		proto = "tcp";

		cpp++;

		if (!*cpp) {
			fprintf(stderr,
				"%d: missing fields (destination port)\n",
				linenum);
			return NULL;
		}

		if (isdigit(**cpp) && (s = strchr(*cpp, '-')))
			*s++ = '\0';
		else
			s = NULL;

		if (!portnum(*cpp, &ipn.in_pmin, linenum))
			return NULL;
		ipn.in_pmin = htons(ipn.in_pmin);
		cpp++;

		if (!strcmp(*cpp, "-")) {
			cpp++;
			s = *cpp++;
		}

		if (s) {
			if (!portnum(s, &ipn.in_pmax, linenum))
				return NULL;
			ipn.in_pmax = htons(ipn.in_pmax);
		} else
			ipn.in_pmax = ipn.in_pmin;
	}

	if (!*cpp) {
		fprintf(stderr, "%d: missing fields (->)\n", linenum);
		return NULL;
	}
	if (strcmp(*cpp, "->")) {
		fprintf(stderr, "%d: missing ->\n", linenum);
		return NULL;
	}
	cpp++;

	if (!*cpp) {
		fprintf(stderr, "%d: missing fields (%s)\n",
			linenum, ipn.in_redir ? "destination" : "target");
		return NULL;
	}

	if (ipn.in_redir == NAT_MAP) {
		if (!strcasecmp(*cpp, "range")) {
			cpp++;
			ipn.in_flags |= IPN_IPRANGE;
			if (!*cpp) {
				fprintf(stderr, "%d: missing fields (%s)\n",
					linenum,
					ipn.in_redir ? "destination":"target");
				return NULL;
			}
		}
	}

	if (ipn.in_flags & IPN_IPRANGE) {
		dnetm = strrchr(*cpp, '-');
		if (dnetm == NULL) {
			cpp++;
			if (*cpp && !strcmp(*cpp, "-") && *(cpp + 1))
					dnetm = *(cpp + 1);
		} else
			*dnetm++ = '\0';
		if (dnetm == NULL || *dnetm == '\0') {
			fprintf(stderr,
				"%d: desination range not specified\n",
				linenum);
			return NULL;
		}
	} else if (ipn.in_redir != NAT_REDIRECT) {
		dnetm = strrchr(*cpp, '/');
		if (dnetm == NULL) {
			cpp++;
			if (*cpp && !strcasecmp(*cpp, "netmask"))
				dnetm = *++cpp;
		}
		if (dnetm == NULL) {
			fprintf(stderr,
				"%d: missing fields (dest netmask)\n",
				linenum);
			return NULL;
		}
		if (*dnetm == '/')
			*dnetm++ = '\0';
	}

	if (ipn.in_redir == NAT_REDIRECT) {
		dnetm = strchr(*cpp, ',');
		if (dnetm != NULL) {
			ipn.in_flags |= IPN_SPLIT;
			*dnetm++ = '\0';
		}
		if (hostnum((u_32_t *)&ipn.in_inip, *cpp, linenum) == -1)
			return NULL;
	} else {
		if (hostnum((u_32_t *)&ipn.in_outip, *cpp, linenum) == -1)
			return NULL;
	}
	cpp++;

	if (ipn.in_redir & NAT_MAPBLK) {
		if (*cpp && strcasecmp(*cpp, "ports")) {
			fprintf(stderr,
				"%d: expected \"ports\" - got \"%s\"\n",
				linenum, *cpp);
			return NULL;
		}
		cpp++;
		if (*cpp) {
			ipn.in_pmin = atoi(*cpp);
			cpp++;
		} else
			ipn.in_pmin = 0;
	} else if ((ipn.in_redir & NAT_BIMAP) == NAT_REDIRECT) {
		if (strrchr(*cpp, '/') != NULL) {
			fprintf(stderr, "%d: No netmask supported in %s\n",
				linenum, "destination host for redirect");
			return NULL;
		}
		/* If it's a in_redir, expect target port */

		if (strcasecmp(*cpp, "port")) {
			fprintf(stderr, "%d: missing fields - 2nd port (%s)\n",
				linenum, *cpp);
			return NULL;
		}
		cpp++;
		if (!*cpp) {
			fprintf(stderr,
				"%d: missing fields (destination port)\n",
				linenum);
			return NULL;
		}
		if (!portnum(*cpp, &ipn.in_pnext, linenum))
			return NULL;
		ipn.in_pnext = htons(ipn.in_pnext);
		cpp++;
	} 
	if (dnetm && *dnetm == '/')
		*dnetm++ = '\0';

	if (ipn.in_redir & (NAT_MAP|NAT_MAPBLK)) {
		if (ipn.in_flags & IPN_IPRANGE) {
			if (hostnum((u_32_t *)&ipn.in_outmsk, dnetm,
				    linenum) == -1)
				return NULL;
		} else if (genmask(dnetm, (u_32_t *)&ipn.in_outmsk))
			return NULL;
	} else {
		if (ipn.in_flags & IPN_SPLIT) {
			if (hostnum((u_32_t *)&ipn.in_inmsk, dnetm,
				    linenum) == -1)
				return NULL;
		} else if (genmask("255.255.255.255", (u_32_t *)&ipn.in_inmsk))
			return NULL;
		if (*cpp) {
			ipn.in_flags &= ~IPN_TCP;	/* override default */
			if (!strcasecmp(*cpp, "tcp"))
				ipn.in_flags |= IPN_TCP;
			else if (!strcasecmp(*cpp, "udp"))
				ipn.in_flags |= IPN_UDP;
			else if (!strcasecmp(*cpp, "tcp/udp"))
				ipn.in_flags |= IPN_TCPUDP;
			else if (!strcasecmp(*cpp, "tcpudp"))
				ipn.in_flags |= IPN_TCPUDP;
			else if (!strcasecmp(*cpp, "ip"))
				ipn.in_flags |= IPN_ANY;
			else {
				ipn.in_flags |= IPN_ANY;
				if ((pr = getprotobyname(*cpp)))
					ipn.in_p = pr->p_proto;
				else
					ipn.in_p = atoi(*cpp);
			}
			proto = *cpp;
			cpp++;

			if (*cpp && !strcasecmp(*cpp, "round-robin")) {
				cpp++;
				ipn.in_flags |= IPN_ROUNDR;
			}

			if (*cpp) {
				fprintf(stderr,
				"%d: extra junk at the end of rdr: %s\n",
					linenum, *cpp);
				return NULL;
			}
		}
	}

	if (!(ipn.in_flags & IPN_SPLIT))
		ipn.in_inip &= ipn.in_inmsk;
	if ((ipn.in_flags & IPN_IPRANGE) == 0)
		ipn.in_outip &= ipn.in_outmsk;
	ipn.in_srcip &= ipn.in_srcmsk;

	if ((ipn.in_redir & NAT_MAPBLK) != 0)
		nat_setgroupmap(&ipn);

	if (!*cpp)
		return &ipn;

	if (ipn.in_redir == NAT_BIMAP) {
		fprintf(stderr,
			"%d: extra words at the end of bimap line: %s\n",
			linenum, *cpp);
		return NULL;
	}

	if (!strcasecmp(*cpp, "proxy")) {
		cpp++;
		if (!*cpp) {
			fprintf(stderr,
				"%d: missing parameter for \"proxy\"\n",
				linenum);
			return NULL;
		}
		dport = NULL;

		if (!strcasecmp(*cpp, "port")) {
			cpp++;
			if (!*cpp) {
				fprintf(stderr,
					"%d: missing parameter for \"port\"\n",
					linenum);
				return NULL;
			}

			dport = *cpp;
			cpp++;

			if (!*cpp) {
				fprintf(stderr,
					"%d: missing parameter for \"proxy\"\n",
					linenum);
				return NULL;
			}
		} else {
			fprintf(stderr,
				"%d: missing keyword \"port\"\n", linenum);
			return NULL;
		}

		if ((proto = index(*cpp, '/'))) {
			*proto++ = '\0';
			if ((pr = getprotobyname(proto)))
				ipn.in_p = pr->p_proto;
			else
				ipn.in_p = atoi(proto);
		} else
			ipn.in_p = 0;

		if (dport && !portnum(dport, &ipn.in_dport, linenum))
			return NULL;
		ipn.in_dport = htons(ipn.in_dport);

		(void) strncpy(ipn.in_plabel, *cpp, sizeof(ipn.in_plabel));
		cpp++;

		if (*cpp) {
			fprintf(stderr,
				"%d: too many parameters for \"proxy\"\n",
				linenum);
			return NULL;
		}
		return &ipn;
	}

	if (strcasecmp(*cpp, "portmap")) {
		fprintf(stderr,
			"%d: expected \"portmap\" - got \"%s\"\n", linenum,
			*cpp);
		return NULL;
	}
	cpp++;
	if (!*cpp) {
		fprintf(stderr, "%d: missing expression following portmap\n",
			linenum);
		return NULL;
	}

	if (!strcasecmp(*cpp, "tcp"))
		ipn.in_flags |= IPN_TCP;
	else if (!strcasecmp(*cpp, "udp"))
		ipn.in_flags |= IPN_UDP;
	else if (!strcasecmp(*cpp, "tcpudp"))
		ipn.in_flags |= IPN_TCPUDP;
	else if (!strcasecmp(*cpp, "tcp/udp"))
		ipn.in_flags |= IPN_TCPUDP;
	else {
		fprintf(stderr,
			"%d: expected protocol name - got \"%s\"\n",
			linenum, *cpp);
		return NULL;
	}
	proto = *cpp;
	cpp++;

	if (!*cpp) {
		fprintf(stderr, "%d: no port range found\n", linenum);
		return NULL;
	}

	if (!strcasecmp(*cpp, "auto")) {
		ipn.in_flags |= IPN_AUTOPORTMAP;
		ipn.in_pmin = htons(1024);
		ipn.in_pmax = htons(65535);
		nat_setgroupmap(&ipn);
		return &ipn;
	}

	if (!(t = strchr(*cpp, ':'))) {
		fprintf(stderr, "%d: no port range in \"%s\"\n",
			linenum, *cpp);
		return NULL;
	}
	*t++ = '\0';
	if (!portnum(*cpp, &ipn.in_pmin, linenum) ||
	    !portnum(t, &ipn.in_pmax, linenum))
		return NULL;
	ipn.in_pmin = htons(ipn.in_pmin);
	ipn.in_pmax = htons(ipn.in_pmax);
	return &ipn;
}


void natparsefile(fd, file, opts)
int fd;
char *file;
int opts;
{
	char	line[512], *s;
	ipnat_t	*np;
	FILE	*fp;
	int	linenum = 0;

	if (strcmp(file, "-")) {
		if (!(fp = fopen(file, "r"))) {
			fprintf(stderr, "%s: open: %s\n", file,
				STRERROR(errno));
			exit(1);
		}
	} else
		fp = stdin;

	while (fgets(line, sizeof(line) - 1, fp)) {
		linenum++;
		line[sizeof(line) - 1] = '\0';
		if ((s = strchr(line, '\n')))
			*s = '\0';

		if (!(np = natparse(line, linenum))) {
			if (*line)
				fprintf(stderr, "%d: syntax error in \"%s\"\n",
					linenum, line);
		} else {
			if ((opts & OPT_VERBOSE) && np)
				printnat(np, opts, NULL);
			if (!(opts & OPT_NODO)) {
				if (!(opts & OPT_REMOVE)) {
					if (ioctl(fd, SIOCADNAT, &np) == -1) {
						fprintf(stderr, "%d:",
							linenum);
						perror("ioctl(SIOCADNAT)");
					}
				} else if (ioctl(fd, SIOCRMNAT, &np) == -1) {
					fprintf(stderr, "%d:", linenum);
					perror("ioctl(SIOCRMNAT)");
				}
			}
		}
	}
	if (fp != stdin)
		fclose(fp);
}
@


1.11
log
@Move default protocol setting of TCP into the redir-specific code
so it doesn't affect the "map" entries.  Fixes a problem introduced
in last commit where protocols other than TCP were not being mapped
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: natparse.c,v 1.10 2001/02/05 17:33:08 millert Exp $	*/
@


1.10
log
@Restore change from revision 1.8 that got lost in last commit.
Set default proto earlier enough so service names may be used as well as numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: natparse.c,v 1.9 2001/01/30 04:26:50 kjell Exp $	*/
a320 4
	/* TCP only by default */
	ipn.in_flags |= IPN_TCP;
	proto = "tcp";

d437 4
@


1.9
log
@reimplement whacked ipnat changes
@
text
@d1 1
a1 1
/*	$OpenBSD: natparse.c,v 1.8 2001/01/23 02:24:12 fgsch Exp $	*/
d321 4
d603 2
a604 4
		if (!*cpp) {
			ipn.in_flags |= IPN_TCP; /* XXX- TCP only by default */
			proto = "tcp";
		} else {
@


1.8
log
@set default proto earlier enough so service names may be used as well;
report & fix by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: natparse.c,v 1.7 2001/01/17 05:01:01 fgsch Exp $	*/
d44 1
a44 1
#include <netinet/ip_compat.h>
a320 4
	/* TCP only by default */
	ipn.in_flags |= IPN_TCP;
	proto = "tcp";

d599 4
a602 2
		if (*cpp) {
			ipn.in_flags &= ~IPN_TCP;	/* override default */
@


1.7
log
@1st part of ipf userland code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d321 4
d603 2
a604 4
		if (!*cpp) {
			ipn.in_flags |= IPN_TCP; /* XXX- TCP only by default */
			proto = "tcp";
		} else {
@


1.6
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: natparse.c,v 1.5 2000/05/01 06:16:48 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d44 1
a44 1
#include <netinet/ip_fil_compat.h>
d48 1
d59 1
a59 1
static const char rcsid[] = "@@(#)$IPFilter: natparse.c,v 1.2.2.3 2000/06/25 07:13:28 darrenr Exp $";
d68 1
a68 1
extern	u_32_t	hostnum __P((char *, int *, int));
a72 2
u_32_t	n_hostmask __P((char *));
u_short	n_portnum __P((char *, char *, int));
a74 7
#define	OPT_REM		1
#define	OPT_NODO	2
#define	OPT_STAT	4
#define	OPT_LIST	8
#define	OPT_VERBOSE	16
#define	OPT_FLUSH	32
#define	OPT_CLEAR	64
d76 1
a76 2

void printnat(np, verbose, ptr)
d78 1
a78 1
int verbose;
d88 1
a88 1
		printf("rdr ");
d91 1
a91 1
		printf("map ");
d94 1
a94 1
		printf("map-block ");
d97 1
a97 1
		printf("bimap ");
d105 34
d140 3
a142 4
		printf("%s ", np->in_ifname);
		if (np->in_src[0].s_addr || np->in_src[1].s_addr) {
			printf("from %s",inet_ntoa(np->in_src[0]));
			bits = countbits(np->in_src[1].s_addr);
d146 9
a154 11
				printf("/%s ", inet_ntoa(np->in_src[1]));
		}
		printf("%s",inet_ntoa(np->in_out[0]));
		bits = countbits(np->in_out[1].s_addr);
		if (bits != -1)
			printf("/%d ", bits);
		else
			printf("/%s ", inet_ntoa(np->in_out[1]));
		if (np->in_pmin)
			printf("port %d ", ntohs(np->in_pmin));
		printf("-> %s", inet_ntoa(np->in_in[0]));
d163 2
d166 3
a168 3
		if (verbose)
			printf("\t%p %lu %x %u %p %d\n", np->in_ifp,
			       np->in_space, np->in_flags, np->in_pnext, np,
d172 8
a179 6
		printf("%s %s/", np->in_ifname, inet_ntoa(np->in_in[0]));
		bits = countbits(np->in_in[1].s_addr);
		if (bits != -1)
			printf("%d ", bits);
		else
			printf("%s", inet_ntoa(np->in_in[1]));
d181 1
a181 1
		if (np->in_flags & IPN_RANGE) {
d214 1
a214 1
			if (verbose)
d220 1
a220 1
				if (verbose)
d237 1
a237 1
		if (verbose) {
d276 1
d278 3
a280 5
	static ipnat_t ipn;
	char *s, *t;
	char *shost, *snetm, *dhost, *proto, *srchost, *srcnetm;
	char *dnetm = NULL, *dport = NULL, *tport = NULL;
	int resolved;
a281 2
	srchost = NULL;
	srcnetm = NULL;
a282 1
	bzero((char *)&ipn, sizeof(ipn));
d287 2
d291 11
a301 1
	if (!(s = strtok(line, " \t")))
d303 5
a307 1
	if (!strcasecmp(s, "map"))
d309 1
a309 1
	else if (!strcasecmp(s, "map-block"))
d311 1
a311 1
	else if (!strcasecmp(s, "rdr"))
d313 1
a313 1
	else if (!strcasecmp(s, "bimap"))
d317 1
a317 1
			linenum, s);
d321 1
a321 5
	if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "%d: missing fields (interface)\n",
			linenum);
		return NULL;
	}
d323 1
a323 1
	strncpy(ipn.in_ifname, s, sizeof(ipn.in_ifname) - 1);
d325 1
a325 5
	if (!(s = strtok(NULL, " \t"))) {
		fprintf(stderr, "%d: missing fields (%s)\n", linenum, 
			ipn.in_redir ? "from source | destination" : "source");
		return NULL;
	}
d327 18
a344 5
	if ((ipn.in_redir == NAT_REDIRECT) && !strcasecmp(s, "from")) {
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr,
				"%d: missing fields (source address)\n",
				linenum);
d348 25
a372 2
		srchost = s;
		srcnetm = strrchr(srchost, '/');
d374 43
a416 5
		if (srcnetm == NULL) {
			if (!(s = strtok(NULL, " \t"))) {
				fprintf(stderr,
				"%d: missing fields (source netmask)\n",
					linenum);
d419 2
a420 5

			if (strcasecmp(s, "netmask")) {
				fprintf(stderr,
					"%d: missing fields (netmask)\n",
					linenum);
d422 1
a422 5
			}
			if (!(s = strtok(NULL, " \t"))) {
				fprintf(stderr,
					"%d: missing fields (source netmask)\n",
					linenum);
a424 1
			srcnetm = s;
d426 4
a429 2
		if (*srcnetm == '/')
			*srcnetm++ = '\0';
d431 4
a434 4
		/* re read the  next word  -- destination */
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr,
				"%d: missing fields (destination)\n", linenum);
d438 1
a438 3
	}

	shost = s;
d440 1
a440 2
	if (ipn.in_redir == NAT_REDIRECT) {
		if (!(s = strtok(NULL, " \t"))) {
d447 6
a452 2
		if (strcasecmp(s, "port")) {
			fprintf(stderr, "%d: missing fields (port)\n", linenum);
d454 2
a455 1
		}
d457 3
a459 5
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr,
				"%d: missing fields (destination port)\n",
				linenum);
			return NULL;
d462 6
a467 1
		dport = s;
d470 1
a470 2

	if (!(s = strtok(NULL, " \t"))) {
d474 3
a476 21
	if (!strcmp(s, "->")) {
		snetm = strrchr(shost, '/');
		if (!snetm) {
			fprintf(stderr,
				"%d: missing fields (%s netmask)\n", linenum,
				ipn.in_redir ? "destination" : "source");
			return NULL;
		}
	} else {
		if (strcasecmp(s, "netmask")) {
			fprintf(stderr, "%d: missing fields (netmask)\n",
				linenum);
			return NULL;
		}
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr,
				"%d: missing fields (%s netmask)\n", linenum,
				ipn.in_redir ? "destination" : "source");
			return NULL;
		}
		snetm = s;
d478 1
d480 1
a480 1
	if (!(s = strtok(NULL, " \t"))) {
d482 1
a482 1
			linenum, ipn.in_redir ? "destination":"target");
d487 4
a490 3
		if (!strcasecmp(s, "range")) {
			ipn.in_flags |= IPN_RANGE;
			if (!(s = strtok(NULL, " \t"))) {
a497 1
	dhost = s;
d499 36
a534 38
	if (ipn.in_redir & (NAT_MAP|NAT_MAPBLK)) {
		if (ipn.in_flags & IPN_RANGE) {
			dnetm = strrchr(dhost, '-');
			if (dnetm == NULL) {
				if (!(s = strtok(NULL, " \t")))
					dnetm = NULL;
				else {
					if (strcmp(s, "-"))
						s = NULL;
					else if ((s = strtok(NULL, " \t"))) {
						dnetm = s;
					}
				}
			} else
				*dnetm++ = '\0';
			if (dnetm == NULL || *dnetm == '\0') {
				fprintf(stderr,
					"%d: desination range not specified\n",
					linenum);
				return NULL;
			}
		} else {
			dnetm = strrchr(dhost, '/');
			if (dnetm == NULL) {
				if (!(s = strtok(NULL, " \t")))
					dnetm = NULL;
				else if (!strcasecmp(s, "netmask"))
					if ((s = strtok(NULL, " \t")) != NULL)
						dnetm = s;
			}
			if (dnetm == NULL) {
				fprintf(stderr,
					"%d: missing fields (dest netmask)\n",
					linenum);
				return NULL;
			}
			if (*dnetm == '/')
				*dnetm++ = '\0';
d536 5
a540 1
		s = strtok(NULL, " \t");
d542 1
d545 1
a545 1
		if (s && strcasecmp(s, "ports")) {
d548 1
a548 1
				linenum, s);
d551 4
a554 5
		if (s != NULL) {
			if ((s = strtok(NULL, " \t")) == NULL)
				return NULL;
			ipn.in_pmin = atoi(s);
			s = strtok(NULL, " \t");
d558 1
a558 1
		if (strrchr(dhost, '/') != NULL) {
a563 6
		if (!(s = strtok(NULL, " \t"))) {
			fprintf(stderr,
				"%d: missing fields (destination port)\n",
				linenum);
			return NULL;
		}
d565 3
a567 3
		if (strcasecmp(s, "port")) {
			fprintf(stderr, "%d: missing fields (port)\n",
				linenum);
d570 2
a571 2
	  
		if (!(s = strtok(NULL, " \t"))) {
d577 4
a580 1
		tport = s;
a583 2
	if (snetm && *snetm == '/')
		*snetm++ = '\0';
d586 5
a590 2
		ipn.in_inip = hostnum(shost, &resolved, linenum);
		if (resolved == -1)
d592 4
a595 7
		ipn.in_inmsk = n_hostmask(snetm);
		ipn.in_outip = hostnum(dhost, &resolved, linenum);
		if (resolved == -1)
			return NULL;
		if (ipn.in_flags & IPN_RANGE) {
			ipn.in_outmsk = hostnum(dnetm, &resolved, linenum);
			if (resolved == -1)
d597 1
a597 23
		} else
			ipn.in_outmsk = n_hostmask(dnetm);
		if (srchost) {
			ipn.in_srcip = hostnum(srchost, &resolved, linenum);
			if (resolved == -1)
				return NULL;
		}
		if (srcnetm)
			ipn.in_srcmsk = n_hostmask(srcnetm);
	} else {
		if (srchost) {
			ipn.in_srcip = hostnum(srchost, &resolved, linenum);
			if (resolved == -1)
				return NULL;
		}
		if (srcnetm)
			ipn.in_srcmsk = n_hostmask(srcnetm);
		ipn.in_inip = hostnum(dhost, &resolved, linenum);
		if (resolved == -1)
			return NULL;
		ipn.in_inmsk = n_hostmask("255.255.255.255");
		ipn.in_outip = hostnum(shost, &resolved, linenum);
		if (resolved == -1)
d599 1
a599 2
		ipn.in_outmsk = n_hostmask(snetm);
		if (!(s = strtok(NULL, " \t"))) {
d603 1
a603 1
			if (!strcasecmp(s, "tcp"))
d605 1
a605 1
			else if (!strcasecmp(s, "udp"))
d607 1
a607 1
			else if (!strcasecmp(s, "tcp/udp"))
d609 1
a609 1
			else if (!strcasecmp(s, "tcpudp"))
d611 1
a611 1
			else if (!strcasecmp(s, "ip"))
d615 1
a615 1
				if ((pr = getprotobyname(s)))
d618 8
a625 1
					ipn.in_p = atoi(s);
d627 2
a628 2
			proto = s;
			if ((s = strtok(NULL, " \t"))) {
d631 1
a631 1
					linenum, s);
a634 4
		ipn.in_pmin = n_portnum(dport, proto, linenum);
		ipn.in_pmax = ipn.in_pmin;
		ipn.in_pnext = n_portnum(tport, proto, linenum);
		s = NULL;
d636 4
a639 2
	ipn.in_inip &= ipn.in_inmsk;
	if ((ipn.in_flags & IPN_RANGE) == 0)
d646 1
a646 1
	if (!s)
d652 1
a652 1
			linenum, s);
d655 4
a658 2
	if (!strcasecmp(s, "proxy")) {
		if (!(s = strtok(NULL, " \t"))) {
d666 3
a668 2
		if (!strcasecmp(s, "port")) {
			if (!(s = strtok(NULL, " \t"))) {
d675 2
a676 1
			dport = s;
d678 1
a678 1
			if (!(s = strtok(NULL, " \t"))) {
d689 2
a690 1
		if ((proto = index(s, '/'))) {
d696 1
a696 3
			if (dport)
				ipn.in_dport = n_portnum(dport, proto, linenum);
		} else {
a697 3
			if (dport)
				ipn.in_dport = n_portnum(dport, NULL, linenum);
		}
d699 8
a706 2
		(void) strncpy(ipn.in_plabel, s, sizeof(ipn.in_plabel));
		if ((s = strtok(NULL, " \t"))) {
a712 1
		
d715 1
a715 1
	if (strcasecmp(s, "portmap")) {
d717 2
a718 1
			"%d: expected \"portmap\" - got \"%s\"\n", linenum, s);
d721 4
a724 1
	if (!(s = strtok(NULL, " \t")))
d726 3
a728 1
	if (!strcasecmp(s, "tcp"))
d730 1
a730 1
	else if (!strcasecmp(s, "udp"))
d732 1
a732 1
	else if (!strcasecmp(s, "tcpudp"))
d734 1
a734 1
	else if (!strcasecmp(s, "tcp/udp"))
d739 1
a739 1
			linenum, s);
d742 2
d745 1
a745 1
	if (!(s = strtok(NULL, " \t"))) {
d750 1
a750 1
	if (!strcasecmp(s, "auto")) {
d757 4
a760 3
	proto = s;
	if (!(t = strchr(s, ':'))) {
		fprintf(stderr, "%d: no port range in \"%s\"\n", linenum, s);
d764 5
a768 2
	ipn.in_pmin = n_portnum(s, proto, linenum);
	ipn.in_pmax = n_portnum(t, proto, linenum);
d793 1
a793 1
	        linenum++;
d804 1
a804 1
				printnat(np, opts &  OPT_VERBOSE, NULL);
d806 4
a809 2
				if (!(opts & OPT_REM)) {
					if (ioctl(fd, SIOCADNAT, np) == -1)
d811 3
a813 1
				} else if (ioctl(fd, SIOCRMNAT, np) == -1)
d815 1
a820 65
}


u_32_t	n_hostmask(msk)
char	*msk;
{
	int	bits = -1;
	u_32_t	mask;

	if (!isdigit(*msk))
		return (u_32_t)-1;
	if (strchr(msk, '.'))
		return inet_addr(msk);
	if (strchr(msk, 'x'))
#if defined(sun) && !defined(__SVR4) && !defined(__svr4__)
		return (u_32_t)htonl(strtol(msk, NULL, 0));
#else
		return (u_32_t)htonl(strtoul(msk, NULL, 0));
#endif
	/*
	 * set x most significant bits
	 */
	for (mask = 0, bits = atoi(msk); bits; bits--) {
		mask /= 2;
		mask |= ntohl(inet_addr("128.0.0.0"));
	}
	mask = htonl(mask);
	return mask;
}


u_short	n_portnum(name, proto, linenum)
char	*name, *proto;
int     linenum;
{
	struct	servent *sp, *sp2;
	u_short	p1 = 0;

	if (isdigit(*name))
		return htons((u_short)atoi(name));
	if (!proto)
		proto = "tcp/udp";
	if (strcasecmp(proto, "tcp/udp")) {
		sp = getservbyname(name, proto);
		if (sp)
			return sp->s_port;
		fprintf(stderr, "%d: unknown service \"%s\".\n", linenum, name);
		return 0;
	}
	sp = getservbyname(name, "tcp");
	if (sp)
		p1 = sp->s_port;
	sp2 = getservbyname(name, "udp");
	if (!sp || !sp2) {
		fprintf(stderr, "%d: unknown tcp/udp service \"%s\".\n",
			linenum, name);
		return 0;
	}
	if (p1 != sp2->s_port) {
		fprintf(stderr, "%d: %s %d/tcp is a different port to ",
			linenum, name, p1);
		fprintf(stderr, "%d: %s %d/udp\n", linenum, name, sp->s_port);
		return 0;
	}
	return p1;
@


1.5
log
@Update to ipfilter 3.3.13. This should be the last of the 3.3.x releases.
This patch fixes mostly ICMP timeout problems, as the ftp proxy
changes were imported previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: natparse.c,v 1.4 2000/03/13 23:40:19 kjell Exp $	*/
d58 1
a58 1
static const char rcsid[] = "@@(#)$IPFilter: natparse.c,v 1.2.2.2 2000/03/25 00:37:37 darrenr Exp $";
d749 5
a753 1
		return (u_32_t)strtol(msk, NULL, 0);
@


1.4
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
static const char rcsid[] = "@@(#)$IPFilter: natparse.c,v 1.2.2.1 1999/11/20 22:50:30 darrenr Exp $";
d541 1
a541 1
			ipn.in_flags = IPN_TCP; /* XXX- TCP only by default */
d545 1
a545 1
				ipn.in_flags = IPN_TCP;
d547 1
a547 1
				ipn.in_flags = IPN_UDP;
d549 1
a549 1
				ipn.in_flags = IPN_TCPUDP;
d551 1
a551 1
				ipn.in_flags = IPN_TCPUDP;
d553 1
a553 1
				ipn.in_flags = IPN_ANY;
d555 1
a555 1
				ipn.in_flags = IPN_ANY;
d654 1
a654 1
		ipn.in_flags = IPN_TCP;
d656 1
a656 1
		ipn.in_flags = IPN_UDP;
d658 1
a658 1
		ipn.in_flags = IPN_TCPUDP;
d660 1
a660 1
		ipn.in_flags = IPN_TCPUDP;
@


1.3
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.2
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.1
log
@New ipfilter files. Preparing for merge of ipfilter 3.3.4.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d58 1
a58 1
static const char rcsid[] = "@@(#)$Id: natparse.c,v 1.2.2.1 1999/11/20 22:50:30 darrenr Exp $";
@

