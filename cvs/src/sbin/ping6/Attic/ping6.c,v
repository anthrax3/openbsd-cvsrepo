head	1.223;
access;
symbols
	OPENBSD_6_0:1.146.0.2
	OPENBSD_6_0_BASE:1.146
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.108.0.4
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.101.0.2
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.99.0.4
	OPENBSD_5_6_BASE:1.99
	OPENBSD_5_5:1.88.0.4
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.84.0.2
	OPENBSD_5_4_BASE:1.84
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.81.0.6
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.4
	OPENBSD_5_0:1.81.0.2
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.80.0.4
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.80.0.2
	OPENBSD_4_8_BASE:1.80
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.74.0.4
	OPENBSD_4_6_BASE:1.74
	OPENBSD_4_5:1.73.0.4
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.69.0.4
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.69.0.2
	OPENBSD_4_1_BASE:1.69
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.61.0.2
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.59.0.4
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.59.0.2
	OPENBSD_3_7_BASE:1.59
	OPENBSD_3_6:1.58.0.2
	OPENBSD_3_6_BASE:1.58
	OPENBSD_3_5:1.57.0.2
	OPENBSD_3_5_BASE:1.57
	OPENBSD_3_4:1.56.0.2
	OPENBSD_3_4_BASE:1.56
	OPENBSD_3_3:1.52.0.2
	OPENBSD_3_3_BASE:1.52
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.223
date	2016.09.17.18.42.10;	author florian;	state dead;
branches;
next	1.222;
commitid	XNaormxjVXGLVjzb;

1.222
date	2016.09.17.09.39.09;	author florian;	state Exp;
branches;
next	1.221;
commitid	7VEWv0ATe5VR0Ffs;

1.221
date	2016.09.17.09.37.56;	author florian;	state Exp;
branches;
next	1.220;
commitid	tt8gB4BgqJJN36eR;

1.220
date	2016.09.17.09.36.42;	author florian;	state Exp;
branches;
next	1.219;
commitid	ybQkETOZGLFbgd7B;

1.219
date	2016.09.17.09.36.12;	author florian;	state Exp;
branches;
next	1.218;
commitid	917GiOHXJPZ1U6N0;

1.218
date	2016.09.17.09.35.27;	author florian;	state Exp;
branches;
next	1.217;
commitid	zl0WmJ4UB2IldOBs;

1.217
date	2016.09.17.09.34.57;	author florian;	state Exp;
branches;
next	1.216;
commitid	oXHML5mNRSG5MZM9;

1.216
date	2016.09.17.09.34.28;	author florian;	state Exp;
branches;
next	1.215;
commitid	ggFAnohqpbVCfx8p;

1.215
date	2016.09.17.09.33.32;	author florian;	state Exp;
branches;
next	1.214;
commitid	ql6UIu7tpjvnr8qF;

1.214
date	2016.09.17.09.32.54;	author florian;	state Exp;
branches;
next	1.213;
commitid	kYplsKt4gYWCNSQH;

1.213
date	2016.09.17.09.31.04;	author florian;	state Exp;
branches;
next	1.212;
commitid	ewOnmc3utFvgY7Uu;

1.212
date	2016.09.17.09.30.26;	author florian;	state Exp;
branches;
next	1.211;
commitid	bYBtf4iPzvpFb37M;

1.211
date	2016.09.17.09.30.00;	author florian;	state Exp;
branches;
next	1.210;
commitid	gdMOeoHOLVdrEvE3;

1.210
date	2016.09.17.09.29.27;	author florian;	state Exp;
branches;
next	1.209;
commitid	ulvkzlJMDAF58Gvl;

1.209
date	2016.09.17.09.26.49;	author florian;	state Exp;
branches;
next	1.208;
commitid	JKzSi8pcb6Mfsimw;

1.208
date	2016.09.17.09.26.07;	author florian;	state Exp;
branches;
next	1.207;
commitid	jtpsxfJ8IxpJhFyf;

1.207
date	2016.09.17.09.25.36;	author florian;	state Exp;
branches;
next	1.206;
commitid	dTk3rnsGVthQ05JQ;

1.206
date	2016.09.17.09.24.51;	author florian;	state Exp;
branches;
next	1.205;
commitid	pbZwUYg5mZKaiIu2;

1.205
date	2016.09.17.09.23.42;	author florian;	state Exp;
branches;
next	1.204;
commitid	fl6gY4GlH9tNvMe1;

1.204
date	2016.09.17.09.23.04;	author florian;	state Exp;
branches;
next	1.203;
commitid	sjvKil4kaARfPToY;

1.203
date	2016.09.17.09.21.59;	author florian;	state Exp;
branches;
next	1.202;
commitid	NVU7EVrcRpRAlnuB;

1.202
date	2016.09.17.09.21.16;	author florian;	state Exp;
branches;
next	1.201;
commitid	rbhI96S3Txvc4ROn;

1.201
date	2016.09.17.09.20.39;	author florian;	state Exp;
branches;
next	1.200;
commitid	dKSQ9w2kY9EgX0Pz;

1.200
date	2016.09.17.09.18.43;	author florian;	state Exp;
branches;
next	1.199;
commitid	AL3Z0lHlk95MFvjM;

1.199
date	2016.09.17.09.17.55;	author florian;	state Exp;
branches;
next	1.198;
commitid	6Q8Safx81IpeN4zv;

1.198
date	2016.09.17.09.16.32;	author florian;	state Exp;
branches;
next	1.197;
commitid	NzLBw21CU7S7rhwX;

1.197
date	2016.09.17.09.15.38;	author florian;	state Exp;
branches;
next	1.196;
commitid	4w5Mi7EZpVNCBeHR;

1.196
date	2016.09.13.07.17.40;	author florian;	state Exp;
branches;
next	1.195;
commitid	Rk6ObdFanSHRQR6z;

1.195
date	2016.09.13.07.16.49;	author florian;	state Exp;
branches;
next	1.194;
commitid	7VewTkSlpddNRZ4T;

1.194
date	2016.09.13.07.15.56;	author florian;	state Exp;
branches;
next	1.193;
commitid	SxseiAerjf1H8UJu;

1.193
date	2016.09.13.07.13.07;	author florian;	state Exp;
branches;
next	1.192;
commitid	bBKM78NFYy0ZZnd6;

1.192
date	2016.09.13.07.11.56;	author florian;	state Exp;
branches;
next	1.191;
commitid	ymGjdsu5NS1IScFV;

1.191
date	2016.09.12.15.47.58;	author florian;	state Exp;
branches;
next	1.190;
commitid	IUGBF8idEez36TTs;

1.190
date	2016.09.12.06.01.58;	author florian;	state Exp;
branches;
next	1.189;
commitid	4Gzt9v73RxVWPzXW;

1.189
date	2016.09.11.19.58.36;	author florian;	state Exp;
branches;
next	1.188;
commitid	vNYy38v2eErh0vbb;

1.188
date	2016.09.11.19.55.10;	author florian;	state Exp;
branches;
next	1.187;
commitid	kwFK0tohuPAPylvD;

1.187
date	2016.09.11.19.53.33;	author florian;	state Exp;
branches;
next	1.186;
commitid	QVIPYoj0qdbjRu7r;

1.186
date	2016.09.11.19.52.47;	author florian;	state Exp;
branches;
next	1.185;
commitid	CJ2dhwUOF5quPT8P;

1.185
date	2016.09.11.19.49.51;	author florian;	state Exp;
branches;
next	1.184;
commitid	HhPLh1W4OvuXbZIS;

1.184
date	2016.09.11.19.49.20;	author florian;	state Exp;
branches;
next	1.183;
commitid	SemGw4auhiw6UoQo;

1.183
date	2016.09.11.19.48.12;	author florian;	state Exp;
branches;
next	1.182;
commitid	LB4za2WUKwLCnS0H;

1.182
date	2016.09.11.19.47.12;	author florian;	state Exp;
branches;
next	1.181;
commitid	cQZcklfSLrbYOQgQ;

1.181
date	2016.09.11.19.46.10;	author florian;	state Exp;
branches;
next	1.180;
commitid	26Zd04NAGU7xJARR;

1.180
date	2016.09.11.19.44.43;	author florian;	state Exp;
branches;
next	1.179;
commitid	Y1XsOvE3VBYkfKD8;

1.179
date	2016.09.11.18.29.10;	author florian;	state Exp;
branches;
next	1.178;
commitid	OjsuOPKsvNnkNOuo;

1.178
date	2016.09.11.18.28.31;	author florian;	state Exp;
branches;
next	1.177;
commitid	ObCKJCjHRMCDprSG;

1.177
date	2016.09.11.18.25.29;	author florian;	state Exp;
branches;
next	1.176;
commitid	epv3aRcuUrYw0VDg;

1.176
date	2016.09.11.18.21.09;	author florian;	state Exp;
branches;
next	1.175;
commitid	j9dyZgLmg3q5YWX4;

1.175
date	2016.09.11.18.19.32;	author florian;	state Exp;
branches;
next	1.174;
commitid	gtTg1sxkeC3mojTD;

1.174
date	2016.09.11.18.18.25;	author florian;	state Exp;
branches;
next	1.173;
commitid	DxMzrCNVuZ3pj31q;

1.173
date	2016.09.11.18.16.12;	author florian;	state Exp;
branches;
next	1.172;
commitid	Ps81djyM8DgZSQvB;

1.172
date	2016.09.11.18.02.06;	author florian;	state Exp;
branches;
next	1.171;
commitid	gmTBJ3e6sZMlFEvo;

1.171
date	2016.09.11.18.01.24;	author florian;	state Exp;
branches;
next	1.170;
commitid	2VrmwiqoRl7Os0eI;

1.170
date	2016.09.11.17.59.12;	author florian;	state Exp;
branches;
next	1.169;
commitid	s2Gl3d01Ip98l7nB;

1.169
date	2016.09.11.17.56.12;	author florian;	state Exp;
branches;
next	1.168;
commitid	pR9VxzClW6HespWb;

1.168
date	2016.09.11.17.53.16;	author florian;	state Exp;
branches;
next	1.167;
commitid	MWjjsjl2mGjBYcen;

1.167
date	2016.09.11.17.50.56;	author florian;	state Exp;
branches;
next	1.166;
commitid	VEKtwQvWNh1hnsMj;

1.166
date	2016.09.11.11.19.27;	author florian;	state Exp;
branches;
next	1.165;
commitid	UValYUVkuvZRa6GK;

1.165
date	2016.09.11.11.17.15;	author florian;	state Exp;
branches;
next	1.164;
commitid	oCdeN6u1i6foTk1o;

1.164
date	2016.09.11.11.16.07;	author florian;	state Exp;
branches;
next	1.163;
commitid	5m6XvmdLKPtK8w54;

1.163
date	2016.09.10.07.43.49;	author florian;	state Exp;
branches;
next	1.162;
commitid	TXFHMWevPTYAMNfr;

1.162
date	2016.09.10.07.43.03;	author florian;	state Exp;
branches;
next	1.161;
commitid	oMKeoA1rRzMO9wEt;

1.161
date	2016.09.10.07.42.20;	author florian;	state Exp;
branches;
next	1.160;
commitid	Cj0ERH3jRHj5afrE;

1.160
date	2016.09.10.07.41.36;	author florian;	state Exp;
branches;
next	1.159;
commitid	P6StLE7UwsNAZK81;

1.159
date	2016.09.10.07.31.43;	author florian;	state Exp;
branches;
next	1.158;
commitid	xHG6UmFUJDM8lKSn;

1.158
date	2016.09.08.13.59.33;	author florian;	state Exp;
branches;
next	1.157;
commitid	YpSTXviIjeDqZOlp;

1.157
date	2016.09.07.17.56.00;	author florian;	state Exp;
branches;
next	1.156;
commitid	2a5WL8bAWwIkyBrf;

1.156
date	2016.09.07.17.55.14;	author florian;	state Exp;
branches;
next	1.155;
commitid	XleWBoM1lYtpFh3U;

1.155
date	2016.09.04.10.44.28;	author florian;	state Exp;
branches;
next	1.154;
commitid	BkmnoTrGFJLWs6Wc;

1.154
date	2016.09.03.21.47.57;	author florian;	state Exp;
branches;
next	1.153;
commitid	CFXRvFTWN3yETXoq;

1.153
date	2016.09.02.14.22.29;	author florian;	state Exp;
branches;
next	1.152;
commitid	rm8SfeqQU5K5j64M;

1.152
date	2016.09.02.14.14.39;	author florian;	state Exp;
branches;
next	1.151;
commitid	z0wbmM9uPMs9UYtS;

1.151
date	2016.08.30.14.28.31;	author deraadt;	state Exp;
branches;
next	1.150;
commitid	3abf2zIDdzi8zwhq;

1.150
date	2016.08.30.13.58.24;	author millert;	state Exp;
branches;
next	1.149;
commitid	5qbdaC5XFa5L46Yi;

1.149
date	2016.08.30.13.50.13;	author florian;	state Exp;
branches;
next	1.148;
commitid	IwwJHnScXFsRDBNX;

1.148
date	2016.08.30.12.10.10;	author florian;	state Exp;
branches;
next	1.147;
commitid	HuKDnsKr2swBwjWi;

1.147
date	2016.08.30.11.15.16;	author florian;	state Exp;
branches;
next	1.146;
commitid	sYq8OrkNSqFSgztz;

1.146
date	2016.03.03.18.30.48;	author florian;	state Exp;
branches;
next	1.145;
commitid	kLdbxgpRjkk0XaLr;

1.145
date	2016.01.30.05.38.26;	author semarie;	state Exp;
branches;
next	1.144;
commitid	uFaQox6LSTMSbQ90;

1.144
date	2016.01.28.17.26.10;	author gsoares;	state Exp;
branches;
next	1.143;
commitid	asCM1XeyZ4r9sHqx;

1.143
date	2015.11.29.22.41.20;	author florian;	state Exp;
branches;
next	1.142;
commitid	Mf1d1GyWDPSh4QXP;

1.142
date	2015.11.29.12.32.10;	author florian;	state Exp;
branches;
next	1.141;
commitid	qqS1UKFJGoFAz0rz;

1.141
date	2015.11.10.18.36.33;	author florian;	state Exp;
branches;
next	1.140;
commitid	SlMlKJPFbG8mpckN;

1.140
date	2015.11.05.21.56.56;	author florian;	state Exp;
branches;
next	1.139;
commitid	bqSbdTvVlUi4zagC;

1.139
date	2015.11.05.21.30.45;	author florian;	state Exp;
branches;
next	1.138;
commitid	Yjh6kdfIlHVfJJ0V;

1.138
date	2015.11.04.21.26.30;	author tedu;	state Exp;
branches;
next	1.137;
commitid	nSnFqH97ozIJAVfM;

1.137
date	2015.11.04.20.10.15;	author florian;	state Exp;
branches;
next	1.136;
commitid	ChzLPaXMswhxf0fQ;

1.136
date	2015.11.04.20.04.10;	author florian;	state Exp;
branches;
next	1.135;
commitid	H9QWSasYRwkouVb5;

1.135
date	2015.10.25.20.01.21;	author florian;	state Exp;
branches;
next	1.134;
commitid	l16yl0cRPFZ02znx;

1.134
date	2015.10.25.19.58.56;	author florian;	state Exp;
branches;
next	1.133;
commitid	v3sMm47K38DP49fB;

1.133
date	2015.10.25.14.43.48;	author florian;	state Exp;
branches;
next	1.132;
commitid	whfNuw7p6PcNxaCD;

1.132
date	2015.10.25.12.47.26;	author florian;	state Exp;
branches;
next	1.131;
commitid	dzEWBjiQhbHwscWR;

1.131
date	2015.10.24.16.59.15;	author florian;	state Exp;
branches;
next	1.130;
commitid	HOP1KGT5yNVHEeLL;

1.130
date	2015.10.24.16.41.11;	author florian;	state Exp;
branches;
next	1.129;
commitid	pD7GIcMSE05yIp3u;

1.129
date	2015.10.24.16.32.26;	author florian;	state Exp;
branches;
next	1.128;
commitid	SZ9ZWjk6A1u62Gse;

1.128
date	2015.10.17.15.43.31;	author florian;	state Exp;
branches;
next	1.127;
commitid	NqS1sUCU4WYFmIhj;

1.127
date	2015.10.17.13.08.14;	author florian;	state Exp;
branches;
next	1.126;
commitid	LoqH0afUJSPs9QR8;

1.126
date	2015.10.17.13.07.02;	author florian;	state Exp;
branches;
next	1.125;
commitid	VgK7B2ZrbZzSASVK;

1.125
date	2015.10.16.22.47.12;	author florian;	state Exp;
branches;
next	1.124;
commitid	oSP1zuicVqiGduFW;

1.124
date	2015.10.16.18.17.12;	author florian;	state Exp;
branches;
next	1.123;
commitid	V45ovbWUhRYfGi0e;

1.123
date	2015.10.14.17.26.01;	author florian;	state Exp;
branches;
next	1.122;
commitid	vm6nhEgSHTYUXXD7;

1.122
date	2015.10.13.16.26.54;	author florian;	state Exp;
branches;
next	1.121;
commitid	bjIaho9aWMkX3GCT;

1.121
date	2015.10.12.18.32.18;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	2kuGRLEB0ll7oNAM;

1.120
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.119;
commitid	sbrB3Q5CNxcwZpfU;

1.119
date	2015.10.04.04.56.50;	author deraadt;	state Exp;
branches;
next	1.118;
commitid	eqnuRUvFqXxvWybg;

1.118
date	2015.10.03.00.53.13;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	wVgjxEm5l2cpvRB3;

1.117
date	2015.09.30.12.21.46;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	e41lHegrMrhEiRSb;

1.116
date	2015.09.16.10.12.03;	author florian;	state Exp;
branches;
next	1.115;
commitid	9lRtdd8gSR7OzBzY;

1.115
date	2015.09.12.11.52.23;	author naddy;	state Exp;
branches;
next	1.114;
commitid	E2GNG25yYntQfvNR;

1.114
date	2015.09.12.09.44.08;	author tobias;	state Exp;
branches;
next	1.113;
commitid	74l7YbGCpqRCidyL;

1.113
date	2015.09.09.14.37.07;	author claudio;	state Exp;
branches;
next	1.112;
commitid	bXes9PdLVBzFBzuV;

1.112
date	2015.09.01.19.53.23;	author florian;	state Exp;
branches;
next	1.111;
commitid	AaV9Y6r6SY6C0jWQ;

1.111
date	2015.08.31.16.42.33;	author florian;	state Exp;
branches;
next	1.110;
commitid	8wEeChHndDivk2M2;

1.110
date	2015.08.30.18.48.45;	author florian;	state Exp;
branches;
next	1.109;
commitid	rd4cpyfpbQcgdNUk;

1.109
date	2015.08.30.18.27.03;	author florian;	state Exp;
branches;
next	1.108;
commitid	63TajonI0DfelDuO;

1.108
date	2015.05.02.17.19.42;	author florian;	state Exp;
branches;
next	1.107;
commitid	xiXjFCQ1JI3J8Cvv;

1.107
date	2015.05.02.00.32.03;	author krw;	state Exp;
branches;
next	1.106;
commitid	7JBKw3TZxbKgQFnl;

1.106
date	2015.04.20.00.46.32;	author dlg;	state Exp;
branches;
next	1.105;
commitid	iJgsiPHi7HG5i4VP;

1.105
date	2015.03.23.10.36.24;	author dlg;	state Exp;
branches;
next	1.104;
commitid	1bkspBX8kad9ql26;

1.104
date	2015.03.23.10.09.02;	author dlg;	state Exp;
branches;
next	1.103;
commitid	PtDDU60INPLJTum8;

1.103
date	2015.03.12.00.30.38;	author dlg;	state Exp;
branches;
next	1.102;
commitid	4lEUv8yAf33ewqKy;

1.102
date	2015.03.11.03.38.56;	author dlg;	state Exp;
branches;
next	1.101;
commitid	Y4fzSRcAxRLy2ARK;

1.101
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	Uu5nFG3wCl0LACBb;

1.100
date	2014.12.03.23.04.52;	author deraadt;	state Exp;
branches;
next	1.99;
commitid	isBg2rOaYXVMscCc;

1.99
date	2014.07.11.15.28.27;	author florian;	state Exp;
branches;
next	1.98;
commitid	nQsP10uIaoFkcKwG;

1.98
date	2014.07.11.15.25.48;	author florian;	state Exp;
branches;
next	1.97;
commitid	aQ1urSnNfHjpqPta;

1.97
date	2014.07.09.09.41.09;	author florian;	state Exp;
branches;
next	1.96;
commitid	5AVVadE6m44UxgAt;

1.96
date	2014.07.09.09.39.54;	author florian;	state Exp;
branches;
next	1.95;
commitid	lMfh4HilKBLYTzCE;

1.95
date	2014.07.09.09.38.35;	author florian;	state Exp;
branches;
next	1.94;
commitid	3a69KLnqr3Nt5Mq2;

1.94
date	2014.07.09.09.37.30;	author florian;	state Exp;
branches;
next	1.93;
commitid	h8F3pOHs0hTmN1tm;

1.93
date	2014.07.09.09.35.51;	author florian;	state Exp;
branches;
next	1.92;
commitid	j9TY74g90qM671mS;

1.92
date	2014.07.09.09.34.47;	author florian;	state Exp;
branches;
next	1.91;
commitid	zLm2SpZzZhRaIPmI;

1.91
date	2014.07.09.09.33.12;	author florian;	state Exp;
branches;
next	1.90;
commitid	fSRDOeOloIEGOnq7;

1.90
date	2014.04.28.15.25.34;	author florian;	state Exp;
branches;
next	1.89;

1.89
date	2014.04.23.18.16.36;	author jca;	state Exp;
branches;
next	1.88;

1.88
date	2014.01.10.21.57.44;	author florian;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.10.06.18.40;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2013.10.21.08.47.10;	author phessler;	state Exp;
branches;
next	1.84;

1.84
date	2013.05.31.19.46.57;	author naddy;	state Exp;
branches;
next	1.83;

1.83
date	2013.04.16.22.10.48;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.03.00.30.31;	author mikeb;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.26.18.30.03;	author phessler;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.10.02.00.50;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.21.19.00.11;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.02.22.31.50;	author sobrado;	state Exp;
branches;
next	1.75;

1.75
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2009.05.31.17.33.39;	author ckuethe;	state Exp;
branches;
next	1.73;

1.73
date	2008.03.24.16.11.08;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2008.03.15.16.10.11;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.30.13.38.47;	author sobrado;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.15.06.07.39;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.20.08.07.00;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.16.02.19.12;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2006.08.10.18.40.35;	author jmc;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.13.00.49.15;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.10.08.05.14;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.17.16.11.06;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.06.10.45.57;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.12.18.45.40;	author jaredy;	state Exp;
branches;
next	1.60;

1.60
date	2005.12.02.01.05.50;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.14.22.12.27;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2004.06.09.02.01.15;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.25.03.39.15;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2003.07.25.06.01.42;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.11.06.22.15;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.11.05.32.43;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2002.12.05.02.08.28;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.25.02.25.43;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2002.10.25.02.24.27;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.08.14.31.28;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.31.01.11.31;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.30.21.32.45;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.30.18.22.13;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.26.13.22.40;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.26.13.02.17;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.11.02.11.18;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.17.19.42.29;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.17.22.26.50;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.17.19.54.57;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.05.07.54.44;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.05.07.50.37;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.01.14.18.49;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.01.08.23.33;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.26.05.09.35;	author mpech;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.18.20.42.28;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.07.18.26.18;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.27.03.31.48;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.22.13.20.21;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.09.11.39.45;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.04.00.37.21;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.26.12.16.49;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.12.19.11.38;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.12.19.05.40;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.12.18.53.37;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.12.18.01.43;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.31.05.03.52;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.28.21.39.34;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.22.05.52.04;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.22.00.33.33;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.02.02.56.50;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.11.00.45.38;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.10.18.12.07;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.12.14.13.10;	author itojun;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.10.12.09.02.19;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.08.00.27.44;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.06.10.58.19;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.14.02.50.04;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.13.20.17.00;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.30.16.00.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.20.20.00.03;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.12.17.24.27;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.08.13.58.21;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.23.11.26.18;	author hugh;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.02.28.14.06.39;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.16.05.59.20;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.22.20.25.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.08.43.19;	author itojun;	state Exp;
branches;
next	;

1.5.2.1
date	2000.10.06.20.40.27;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2001.03.01.02.37.45;	author jason;	state Exp;
branches;
next	;


desc
@@


1.223
log
@... and we have unification.
"Das tritt nach meiner Kenntnis... ist das sofort... unverzueglich..."
@
text
@/*	$OpenBSD: ping6.c,v 1.222 2016/09/17 09:39:09 florian Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Muuss.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Using the InterNet Control Message Protocol (ICMP) "ECHO" facility,
 * measure round-trip-delays and packet loss across network paths.
 *
 * Author -
 *	Mike Muuss
 *	U. S. Army Ballistic Research Laboratory
 *	December, 1983
 *
 * Status -
 *	Public Domain.  Distribution Unlimited.
 * Bugs -
 *	More statistics could always be gathered.
 *	This program has to run SUID to ROOT to access the ICMP socket.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_var.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet/ip_ah.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include <poll.h>
#include <signal.h>
#include <siphash.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

struct tv64 {
	u_int64_t	tv64_sec;
	u_int64_t	tv64_nsec;
};

struct payload {
	struct tv64	tv64;
	u_int8_t	mac[SIPHASH_DIGEST_LENGTH];
};

#define	ECHOLEN		8	/* icmp echo header len excluding time */
#define	ECHOTMLEN	sizeof(struct payload)
#define	DEFDATALEN	(64 - ECHOLEN)		/* default data length */
#define	IP6LEN		40
#define	EXTRA		256	/* for AH and various other headers. weird. */
#define	MAXPAYLOAD6	IPV6_MAXPACKET - IP6LEN - ECHOLEN
#define	MAXWAIT_DEFAULT	10			/* secs to wait for response */

#define	A(bit)		rcvd_tbl[(bit)>>3]	/* identify byte in array */
#define	B(bit)		(1 << ((bit) & 0x07))	/* identify bit in byte */
#define	SET(bit)	(A(bit) |= B(bit))
#define	CLR(bit)	(A(bit) &= (~B(bit)))
#define	TST(bit)	(A(bit) & B(bit))

/* various options */
int options;
#define	F_FLOOD		0x0001
#define	F_INTERVAL	0x0002
#define	F_HOSTNAME	0x0004
#define	F_PINGFILLED	0x0008
#define	F_QUIET		0x0010
/*			0x0020 */
#define	F_SO_DEBUG	0x0040
/*			0x0080 */
#define	F_VERBOSE	0x0100
/*			0x0200 */
/*			0x0400 */
/*			0x0800 */
/*			0x1000 */
#define	F_AUD_RECV	0x2000
#define	F_AUD_MISS	0x4000

/* multicast options */
int moptions;
#define	MULTICAST_NOLOOP	0x001

#define DUMMY_PORT	10101

/*
 * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum
 * number of received sequence numbers we can keep track of.  Change 128
 * to 8192 for complete accuracy...
 */
#define	MAX_DUP_CHK	(8 * 8192)
int mx_dup_ck = MAX_DUP_CHK;
char rcvd_tbl[MAX_DUP_CHK / 8];

int datalen = DEFDATALEN;
int maxpayload;
u_char outpackhdr[IP_MAXPACKET+sizeof(struct ip)];
u_char *outpack = outpackhdr+sizeof(struct ip);
char BSPACE = '\b';		/* characters written for flood */
char DOT = '.';
char *hostname;
int ident;			/* process id to identify our packets */

/* counters */
int64_t npackets;		/* max packets to transmit */
int64_t nreceived;		/* # of packets we got back */
int64_t nrepeats;		/* number of duplicates */
int64_t ntransmitted;		/* sequence # for outbound packets = #sent */
int64_t nmissedmax = 1;		/* max value of ntransmitted - nreceived - 1 */
struct timeval interval = {1, 0}; /* interval between packets */

/* timing */
int timing = 0;			/* flag to do timing */
int timinginfo = 0;
unsigned int maxwait = MAXWAIT_DEFAULT;	/* max seconds to wait for response */
double tmin = 999999999.0;	/* minimum round trip time */
double tmax = 0.0;		/* maximum round trip time */
double tsum = 0.0;		/* sum of all times, for doing average */
double tsumsq = 0.0;		/* sum of all times squared, for std. dev. */

struct tv64 tv64_offset;
SIPHASH_KEY mac_key;

struct msghdr smsghdr;
struct iovec smsgiov;

volatile sig_atomic_t seenalrm;
volatile sig_atomic_t seenint;
volatile sig_atomic_t seeninfo;

void			 fill(char *, char *);
void			 summary(void);
void			 onsignal(int);
void			 retransmit(int);
int			 pinger(int);
const char		*pr_addr(struct sockaddr *, socklen_t);
void			 pr_pack(u_char *, int, struct msghdr *);
__dead void		 usage(void);

int			 get_hoplim(struct msghdr *);
int			 get_pathmtu(struct msghdr *, struct sockaddr_in6 *);
void			 pr_icmph6(struct icmp6_hdr *, u_char *);
void			 pr_iph6(struct ip6_hdr *);
void			 pr_exthdrs(struct msghdr *);
void			 pr_ip6opt(void *);
void			 pr_rthdr(void *);
void			 pr_retip6(struct ip6_hdr *, u_char *);

int
main(int argc, char *argv[])
{
	struct addrinfo hints, *res;
	struct itimerval itimer;
	struct sockaddr *from, *dst;
	struct sockaddr_in6 from6, dst6;
	struct cmsghdr *scmsg = NULL;
	struct in6_pktinfo *pktinfo = NULL;
	struct icmp6_filter filt;
	socklen_t maxsizelen;
	int64_t preload;
	int ch, i, optval = 1, packlen, maxsize, error, s, hoplimit = -1;
	int bufspace = IP_MAXPACKET;
	u_char *datap, *packet, loop = 1;
	char *e, *target, hbuf[NI_MAXHOST], *source = NULL;
	const char *errstr;
	double intval;
	int mflag = 0;
	uid_t uid;
	u_int rtableid = 0;

	if ((s = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		err(1, "socket");

	/* revoke privs */
	uid = getuid();
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid");

	preload = 0;
	maxpayload = MAXPAYLOAD6;
	datap = &outpack[ECHOLEN + ECHOTMLEN];
	while ((ch = getopt(argc, argv,
	    "c:dEefHh:I:i:Ll:mNnp:qS:s:V:vw:")) != -1) {
		switch (ch) {
		case 'c':
			npackets = strtonum(optarg, 0, INT64_MAX, &errstr);
			if (errstr)
				errx(1,
				    "number of packets to transmit is %s: %s",
				    errstr, optarg);
			break;
		case 'd':
			options |= F_SO_DEBUG;
			break;
		case 'E':
			options |= F_AUD_MISS;
			break;
		case 'e':
			options |= F_AUD_RECV;
			break;
		case 'f':
			if (getuid())
				errx(1, "%s", strerror(EPERM));
			options |= F_FLOOD;
			setvbuf(stdout, NULL, _IONBF, 0);
			break;
		case 'H':
			options |= F_HOSTNAME;
			break;
		case 'h':		/* hoplimit */
			hoplimit = strtonum(optarg, 0, IPV6_MAXHLIM, &errstr);
			if (errstr)
				errx(1, "hoplimit is %s: %s", errstr, optarg);
			break;
		case 'I':
		case 'S':	/* deprecated */
			source = optarg;
			break;
		case 'i':		/* wait between sending packets */
			intval = strtod(optarg, &e);
			if (*optarg == '\0' || *e != '\0')
				errx(1, "illegal timing interval %s", optarg);
			if (intval < 1 && getuid()) {
				errx(1, "%s: only root may use interval < 1s",
				    strerror(EPERM));
			}
			interval.tv_sec = (time_t)intval;
			interval.tv_usec =
			    (long)((intval - interval.tv_sec) * 1000000);
			if (interval.tv_sec < 0)
				errx(1, "illegal timing interval %s", optarg);
			/* less than 1/Hz does not make sense */
			if (interval.tv_sec == 0 && interval.tv_usec < 10000) {
				warnx("too small interval, raised to 0.01");
				interval.tv_usec = 10000;
			}
			options |= F_INTERVAL;
			break;
		case 'L':
			moptions |= MULTICAST_NOLOOP;
			loop = 0;
			break;
		case 'l':
			if (getuid())
				errx(1, "%s", strerror(EPERM));
			preload = strtonum(optarg, 1, INT64_MAX, &errstr);
			if (errstr)
				errx(1, "preload value is %s: %s", errstr,
				    optarg);
			break;
		case 'm':
			mflag++;
			break;
		case 'n':
			options &= ~F_HOSTNAME;
			break;
		case 'p':		/* fill buffer with user pattern */
			options |= F_PINGFILLED;
			fill((char *)datap, optarg);
				break;
		case 'q':
			options |= F_QUIET;
			break;
		case 's':		/* size of packet to send */
			datalen = strtonum(optarg, 0, maxpayload, &errstr);
			if (errstr)
				errx(1, "packet size is %s: %s", errstr,
				    optarg);
			break;
		case 'V':
			rtableid = strtonum(optarg, 0, RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "rtable value is %s: %s", errstr,
				    optarg);
			if (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
			    sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
			break;
		case 'v':
			options |= F_VERBOSE;
			break;
		case 'w':
			maxwait = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "maxwait value is %s: %s",
				    errstr, optarg);
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	memset(&dst6, 0, sizeof(dst6));

#if 0
	if (inet_aton(*argv, &dst4.sin_addr) != 0) {
		hostname = *argv;
		if ((target = strdup(inet_ntoa(dst4.sin_addr))) == NULL)
			err(1, "malloc");
	} else
#endif
		target = *argv;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_RAW;
	hints.ai_protocol = 0;
	hints.ai_flags = AI_CANONNAME;
	if ((error = getaddrinfo(target, NULL, &hints, &res)))
		errx(1, "%s", gai_strerror(error));

	switch (res->ai_family) {
	case AF_INET6:
		if (res->ai_addrlen != sizeof(dst6))
		    errx(1, "size of sockaddr mismatch");
		dst = (struct sockaddr *)&dst6;
		from = (struct sockaddr *)&from6;
		break;
	case AF_INET:
	default:
		errx(1, "unsupported AF: %d", res->ai_family);
		break;
	}

	memcpy(dst, res->ai_addr, res->ai_addrlen);

	if (!hostname) {
		hostname = res->ai_canonname ? strdup(res->ai_canonname) :
		    target;
		if (!hostname)
			err(1, "malloc");
	}

	if (res->ai_next) {
		if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(hbuf, "?", sizeof(hbuf));
		warnx("Warning: %s has multiple "
		    "addresses; using %s", hostname, hbuf);
	}
	freeaddrinfo(res);

	if (source) {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = AF_INET6;
		if ((error = getaddrinfo(source, NULL, &hints, &res)))
			errx(1, "%s: %s", source, gai_strerror(error));
		if (res->ai_family != AF_INET6 || res->ai_addrlen !=
		    sizeof(from6))
			errx(1, "invalid source address");
		memcpy(from, res->ai_addr, res->ai_addrlen);
		freeaddrinfo(res);
		if (bind(s, from, from->sa_len) < 0)
			err(1, "bind");
	} else if (options & F_VERBOSE) {
		/*
		 * get the source address. XXX since we revoked the root
		 * privilege, we cannot use a raw socket for this.
		 */
		int dummy;
		socklen_t len = dst->sa_len;

		if ((dummy = socket(dst->sa_family, SOCK_DGRAM, 0)) < 0)
			err(1, "UDP socket");

		memcpy(from, dst, dst->sa_len);
		from6.sin6_port = ntohs(DUMMY_PORT);

		if (pktinfo &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTINFO,
		    (void *)pktinfo, sizeof(*pktinfo)))
			err(1, "UDP setsockopt(IPV6_PKTINFO)");

		if (hoplimit != -1 &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
		    (void *)&hoplimit, sizeof(hoplimit)))
			err(1, "UDP setsockopt(IPV6_UNICAST_HOPS)");

		if (hoplimit != -1 &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		    (void *)&hoplimit, sizeof(hoplimit)))
			err(1, "UDP setsockopt(IPV6_MULTICAST_HOPS)");

		if (rtableid > 0 &&
		    setsockopt(dummy, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) < 0)
			err(1, "setsockopt(SO_RTABLE)");

		if (connect(dummy, from, len) < 0)
			err(1, "UDP connect");

		if (getsockname(dummy, from, &len) < 0)
			err(1, "getsockname");

		close(dummy);
	}

	if (options & F_SO_DEBUG)
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, &optval,
		    sizeof(optval));

	if ((options & F_FLOOD) && (options & F_INTERVAL))
		errx(1, "-f and -i options are incompatible");

	if ((options & F_FLOOD) && (options & (F_AUD_RECV | F_AUD_MISS)))
		warnx("No audible output for flood pings");

	if (datalen >= sizeof(struct payload))	/* can we time transfer */
		timing = 1;

	/* in F_VERBOSE case, we may get non-echoreply packets*/
	if (options & F_VERBOSE && datalen < 2048)
		packlen = 2048 + IP6LEN + ECHOLEN + EXTRA; /* XXX 2048? */
	else
		packlen = datalen + IP6LEN + ECHOLEN + EXTRA;

	if (!(packet = malloc(packlen)))
		err(1, "malloc");

	if (!(options & F_PINGFILLED))
		for (i = ECHOTMLEN; i < datalen; ++i)
			*datap++ = i;

	ident = getpid() & 0xFFFF;

	/*
	 * When trying to send large packets, you must increase the
	 * size of both the send and receive buffers...
	 */
	maxsizelen = sizeof maxsize;
	if (getsockopt(s, SOL_SOCKET, SO_SNDBUF, &maxsize, &maxsizelen) < 0)
		err(1, "getsockopt");
	if (maxsize < packlen &&
	    setsockopt(s, SOL_SOCKET, SO_SNDBUF, &packlen, sizeof(maxsize)) < 0)
		err(1, "setsockopt");

	/*
	 * When pinging the broadcast address, you can get a lot of answers.
	 * Doing something so evil is useful if you are trying to stress the
	 * ethernet, or just want to fill the arp cache to get some stuff for
	 * /etc/ethers.
	 */
	while (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
	    (void*)&bufspace, sizeof(bufspace)) < 0) {
		if ((bufspace -= 1024) <= 0)
			err(1, "Cannot set the receive buffer size");
	}
	if (bufspace < IP_MAXPACKET)
		warnx("Could only allocate a receive buffer of %d bytes "
		    "(default %d)", bufspace, IP_MAXPACKET);

	/*
	 * let the kernel pass extension headers of incoming packets,
	 * for privileged socket options
	 */
	if ((options & F_VERBOSE) != 0) {
		int opton = 1;

		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &opton,
		    (socklen_t)sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVHOPOPTS)");
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &opton,
		    (socklen_t)sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVDSTOPTS)");
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDR, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVRTHDR)");
		ICMP6_FILTER_SETPASSALL(&filt);
	} else {
		ICMP6_FILTER_SETBLOCKALL(&filt);
		ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filt);
	}

	if ((moptions & MULTICAST_NOLOOP) &&
	    setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &loop,
	    sizeof(loop)) < 0)
		err(1, "setsockopt IP6_MULTICAST_LOOP");

	optval = IPV6_DEFHLIM;
	if (IN6_IS_ADDR_MULTICAST(&dst6.sin6_addr))
		if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		    &optval, (socklen_t)sizeof(optval)) == -1)
			err(1, "IPV6_MULTICAST_HOPS");
	if (mflag != 1) {
		optval = mflag > 1 ? 0 : 1;

		if (setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU,
		    &optval, (socklen_t)sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_USE_MIN_MTU)");
	} else {
		optval = 1;
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPATHMTU,
		    &optval, sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_RECVPATHMTU)");
	}

	if (setsockopt(s, IPPROTO_ICMPV6, ICMP6_FILTER, &filt,
	    (socklen_t)sizeof(filt)) < 0)
		err(1, "setsockopt(ICMP6_FILTER)");

	if (hoplimit != -1) {
		/* set IP6 packet options */
		if ((scmsg = malloc( CMSG_SPACE(sizeof(int)))) == NULL)
			err(1, "malloc");
		smsghdr.msg_control = (caddr_t)scmsg;
		smsghdr.msg_controllen =  CMSG_SPACE(sizeof(int));

		scmsg->cmsg_len = CMSG_LEN(sizeof(int));
		scmsg->cmsg_level = IPPROTO_IPV6;
		scmsg->cmsg_type = IPV6_HOPLIMIT;
		*(int *)(CMSG_DATA(scmsg)) = hoplimit;
	}

	optval = 1;
	if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &optval,
	    (socklen_t)sizeof(optval)) < 0)
		warn("setsockopt(IPV6_RECVPKTINFO)"); /* XXX err? */
	if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &optval,
	    (socklen_t)sizeof(optval)) < 0)
		warn("setsockopt(IPV6_RECVHOPLIMIT)"); /* XXX err? */

	if (options & F_HOSTNAME) {
		if (pledge("stdio inet dns", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio inet", NULL) == -1)
			err(1, "pledge");
	}

	arc4random_buf(&tv64_offset, sizeof(tv64_offset));
	arc4random_buf(&mac_key, sizeof(mac_key));

	printf("PING6 %s (", hostname);
	if (options & F_VERBOSE)
		printf("%s --> ", pr_addr(from, from->sa_len));
	printf("%s): %d data bytes\n", pr_addr(dst, dst->sa_len), datalen);

	smsghdr.msg_name = dst;
	smsghdr.msg_namelen = dst->sa_len;
	smsgiov.iov_base = (caddr_t)outpack;
	smsghdr.msg_iov = &smsgiov;
	smsghdr.msg_iovlen = 1;

	while (preload--)		/* Fire off them quickies. */
		pinger(s);

	(void)signal(SIGINT, onsignal);
	(void)signal(SIGINFO, onsignal);

	if ((options & F_FLOOD) == 0) {
		(void)signal(SIGALRM, onsignal);
		itimer.it_interval = interval;
		itimer.it_value = interval;
		(void)setitimer(ITIMER_REAL, &itimer, NULL);
		if (ntransmitted == 0)
			retransmit(s);
	}

	seenalrm = seenint = 0;
	seeninfo = 0;

	for (;;) {
		struct msghdr		m;
		union {
			struct cmsghdr hdr;
			u_char buf[CMSG_SPACE(1024)];
		}			cmsgbuf;
		struct iovec		iov[1];
		struct pollfd		pfd;
		struct sockaddr_in6	peer;
		ssize_t			cc;
		int			timeout;

		/* signal handling */
		if (seenint)
			break;
		if (seenalrm) {
			retransmit(s);
			seenalrm = 0;
			if (ntransmitted - nreceived - 1 > nmissedmax) {
				nmissedmax = ntransmitted - nreceived - 1;
				if (!(options & F_FLOOD) &&
				    (options & F_AUD_MISS))
					(void)fputc('\a', stderr);
			}
			continue;
		}
		if (seeninfo) {
			summary();
			seeninfo = 0;
			continue;
		}

		if (options & F_FLOOD) {
			(void)pinger(s);
			timeout = 10;
		} else
			timeout = INFTIM;

		pfd.fd = s;
		pfd.events = POLLIN;

		if (poll(&pfd, 1, timeout) <= 0)
			continue;

		m.msg_name = &peer;
		m.msg_namelen = sizeof(peer);
		memset(&iov, 0, sizeof(iov));
		iov[0].iov_base = (caddr_t)packet;
		iov[0].iov_len = packlen;
		m.msg_iov = iov;
		m.msg_iovlen = 1;
		m.msg_control = (caddr_t)&cmsgbuf.buf;
		m.msg_controllen = sizeof(cmsgbuf.buf);

		cc = recvmsg(s, &m, 0);
		if (cc < 0) {
			if (errno != EINTR) {
				warn("recvmsg");
				sleep(1);
			}
			continue;
		} else if (cc == 0) {
			int mtu;

			/*
			 * receive control messages only. Process the
			 * exceptions (currently the only possibility is
			 * a path MTU notification.)
			 */
			if ((mtu = get_pathmtu(&m, &dst6)) > 0) {
				if ((options & F_VERBOSE) != 0) {
					printf("new path MTU (%d) is "
					    "notified\n", mtu);
				}
			}
			continue;
		} else
			pr_pack(packet, cc, &m);

		if (npackets && nreceived >= npackets)
			break;
	}
	summary();
	exit(nreceived == 0);
}

void
onsignal(int sig)
{
	switch (sig) {
	case SIGALRM:
		seenalrm++;
		break;
	case SIGINT:
		seenint++;
		break;
	case SIGINFO:
		seeninfo++;
		break;
	}
}

void
fill(char *bp, char *patp)
{
	int ii, jj, kk;
	int pat[16];
	char *cp;

	for (cp = patp; *cp; cp++)
		if (!isxdigit((unsigned char)*cp))
			errx(1, "patterns must be specified as hex digits");
	ii = sscanf(patp,
	    "%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x",
	    &pat[0], &pat[1], &pat[2], &pat[3], &pat[4], &pat[5], &pat[6],
	    &pat[7], &pat[8], &pat[9], &pat[10], &pat[11], &pat[12],
	    &pat[13], &pat[14], &pat[15]);

	if (ii > 0)
		for (kk = 0;
		    kk <= maxpayload - (ECHOLEN + ECHOTMLEN + ii);
		    kk += ii)
			for (jj = 0; jj < ii; ++jj)
				bp[jj + kk] = pat[jj];
	if (!(options & F_QUIET)) {
		(void)printf("PATTERN: 0x");
		for (jj = 0; jj < ii; ++jj)
			(void)printf("%02x", bp[jj] & 0xFF);
		(void)printf("\n");
	}
}

void
summary(void)
{
	printf("\n--- %s ping6 statistics ---\n", hostname);
	printf("%lld packets transmitted, ", ntransmitted);
	printf("%lld packets received, ", nreceived);

	if (nrepeats)
		printf("%lld duplicates, ", nrepeats);
	if (ntransmitted) {
		if (nreceived > ntransmitted)
			printf("-- somebody's duplicating packets!");
		else
			printf("%.1f%% packet loss",
			    ((((double)ntransmitted - nreceived) * 100) /
			    ntransmitted));
	}
	printf("\n");
	if (timinginfo) {
		/* Only display average to microseconds */
		double num = nreceived + nrepeats;
		double avg = tsum / num;
		double dev = sqrt(fmax(0, tsumsq / num - avg * avg));
		printf("round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
		    tmin, avg, tmax, dev);
	}
}

/*
 * pr_addr --
 *	Return address in numeric form or a host name
 */
const char *
pr_addr(struct sockaddr *addr, socklen_t addrlen)
{
	static char buf[NI_MAXHOST];
	int flag = 0;

	if ((options & F_HOSTNAME) == 0)
		flag |= NI_NUMERICHOST;

	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)
		return (buf);
	else
		return "?";
}

/*
 * retransmit --
 *	This routine transmits another ping6.
 */
void
retransmit(int s)
{
	struct itimerval itimer;
	static int last_time = 0;

	if (last_time) {
		seenint = 1;	/* break out of ping event loop */
		return;
	}

	if (pinger(s) == 0)
		return;

	/*
	 * If we're not transmitting any more packets, change the timer
	 * to wait two round-trip times if we've received any packets or
	 * maxwait seconds if we haven't.
	 */
	if (nreceived) {
		itimer.it_value.tv_sec =  2 * tmax / 1000;
		if (itimer.it_value.tv_sec == 0)
			itimer.it_value.tv_sec = 1;
	} else
		itimer.it_value.tv_sec = maxwait;
	itimer.it_interval.tv_sec = 0;
	itimer.it_interval.tv_usec = 0;
	itimer.it_value.tv_usec = 0;
	(void)setitimer(ITIMER_REAL, &itimer, NULL);

	/* When the alarm goes off we are done. */
	last_time = 1;
}

/*
 * pinger --
 *	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet
 * will be added on by the kernel.  The ID field is our UNIX process ID,
 * and the sequence number is an ascending integer.  The first 8 bytes
 * of the data portion are used to hold a UNIX "timeval" struct in VAX
 * byte-order, to compute the round-trip time.
 */
int
pinger(int s)
{
	struct icmp6_hdr *icp;
	int cc, i;
	u_int16_t seq;

	if (npackets && ntransmitted >= npackets)
		return(-1);	/* no more transmission */

	seq = htons(ntransmitted++);

	icp = (struct icmp6_hdr *)outpack;
	memset(icp, 0, sizeof(*icp));
	icp->icmp6_cksum = 0;
	icp->icmp6_type = ICMP6_ECHO_REQUEST;
	icp->icmp6_code = 0;
	icp->icmp6_id = htons(ident);
	icp->icmp6_seq = seq;

	CLR(ntohs(seq) % mx_dup_ck);

	if (timing) {
		SIPHASH_CTX ctx;
		struct timespec ts;
		struct payload payload;
		struct tv64 *tv64 = &payload.tv64;

		if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
			err(1, "clock_gettime(CLOCK_MONOTONIC)");
		tv64->tv64_sec = htobe64((u_int64_t)ts.tv_sec +
		    tv64_offset.tv64_sec);
		tv64->tv64_nsec = htobe64((u_int64_t)ts.tv_nsec +
		    tv64_offset.tv64_nsec);

		SipHash24_Init(&ctx, &mac_key);
		SipHash24_Update(&ctx, tv64, sizeof(*tv64));
		SipHash24_Update(&ctx, &ident, sizeof(ident));
		SipHash24_Update(&ctx, &seq, sizeof(seq));
		SipHash24_Final(&payload.mac, &ctx);

		memcpy(&outpack[ECHOLEN], &payload, sizeof(payload));
	}

	cc = ECHOLEN + datalen;

	smsgiov.iov_len = cc;

	i = sendmsg(s, &smsghdr, 0);

	if (i < 0 || i != cc)  {
		if (i < 0)
			warn("sendmsg");
		printf("ping6: wrote %s %d chars, ret=%d\n", hostname, cc, i);
	}
	if (!(options & F_QUIET) && options & F_FLOOD)
		(void)write(STDOUT_FILENO, &DOT, 1);

	return (0);
}

/*
 * pr_pack --
 *	Print out the packet, if it came from us.  This logic is necessary
 * because ALL readers of the ICMP socket get a copy of ALL ICMP packets
 * which arrive ('tis only fair).  This permits multiple copies of this
 * program to be run without having intermingled output (or statistics!).
 */
void
pr_pack(u_char *buf, int cc, struct msghdr *mhdr)
{
	struct icmp6_hdr *icp;
	struct timespec ts, tp;
	struct payload payload;
	struct sockaddr *from;
	socklen_t fromlen;
	double triptime = 0;
	int i, dupflag;
	int hoplim;
	u_int16_t seq;
	u_char *cp = NULL, *dp, *end = buf + cc;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
		err(1, "clock_gettime(CLOCK_MONOTONIC)");

	if (!mhdr || !mhdr->msg_name ||
	    mhdr->msg_namelen != sizeof(struct sockaddr_in6) ||
	    ((struct sockaddr *)mhdr->msg_name)->sa_family != AF_INET6) {
		if (options & F_VERBOSE)
			warnx("invalid peername");
		return;
	}
	from = (struct sockaddr *)mhdr->msg_name;
	fromlen = mhdr->msg_namelen;
	if (cc < sizeof(struct icmp6_hdr)) {
		if (options & F_VERBOSE)
			warnx("packet too short (%d bytes) from %s", cc,
			    pr_addr(from, fromlen));
		return;
	}
	icp = (struct icmp6_hdr *)buf;

	if ((hoplim = get_hoplim(mhdr)) == -1) {
		warnx("failed to get receiving hop limit");
		return;
	}

	if (icp->icmp6_type == ICMP6_ECHO_REPLY) {
		if (ntohs(icp->icmp6_id) != ident)
			return;			/* 'Twas not our ECHO */
		seq = icp->icmp6_seq;
		++nreceived;
		if (cc >= ECHOLEN + ECHOTMLEN) {
			SIPHASH_CTX ctx;
			struct tv64 *tv64;
			u_int8_t mac[SIPHASH_DIGEST_LENGTH];

			memcpy(&payload, icp + 1, sizeof(payload));
			tv64 = &payload.tv64;

			SipHash24_Init(&ctx, &mac_key);
			SipHash24_Update(&ctx, tv64, sizeof(*tv64));
			SipHash24_Update(&ctx, &ident, sizeof(ident));
			SipHash24_Update(&ctx, &seq, sizeof(seq));
			SipHash24_Final(mac, &ctx);

			if (timingsafe_memcmp(mac, &payload.mac,
			    sizeof(mac)) != 0) {
				(void)printf("signature mismatch!\n");
				return;
			}
			timinginfo=1;

			tp.tv_sec = betoh64(tv64->tv64_sec) -
			    tv64_offset.tv64_sec;
			tp.tv_nsec = betoh64(tv64->tv64_nsec) -
			    tv64_offset.tv64_nsec;

			timespecsub(&ts, &tp, &ts);
			triptime = ((double)ts.tv_sec) * 1000.0 +
			    ((double)ts.tv_nsec) / 1000000.0;
			tsum += triptime;
			tsumsq += triptime * triptime;
			if (triptime < tmin)
				tmin = triptime;
			if (triptime > tmax)
				tmax = triptime;
		}

		if (TST(ntohs(seq) % mx_dup_ck)) {
			++nrepeats;
			--nreceived;
			dupflag = 1;
		} else {
			SET(ntohs(seq) % mx_dup_ck);
			dupflag = 0;
		}

		if (options & F_QUIET)
			return;

		if (options & F_FLOOD)
			(void)write(STDOUT_FILENO, &BSPACE, 1);
		else {
			(void)printf("%d bytes from %s: icmp_seq=%u", cc,
			    pr_addr(from, fromlen), ntohs(seq));
			(void)printf(" hlim=%d", hoplim);
			if (cc >= ECHOLEN + ECHOTMLEN)
				(void)printf(" time=%.3f ms", triptime);
			if (dupflag)
				(void)printf(" (DUP!)");
			/* check the data */
			if (cc - ECHOLEN < datalen)
				(void)printf(" (TRUNC!)");
			cp = buf + ECHOLEN + ECHOTMLEN;
			dp = &outpack[ECHOLEN + ECHOTMLEN];
			for (i = ECHOLEN + ECHOTMLEN;
			    i < cc && i < datalen;
			    ++i, ++cp, ++dp) {
				if (*cp != *dp) {
					(void)printf("\nwrong data byte #%d "
					    "should be 0x%x but was 0x%x",
					    i - ECHOLEN, *dp, *cp);
					cp = buf + ECHOLEN;
					for (i = ECHOLEN; i < cc && i < datalen;
					     ++i, ++cp) {
						if ((i % 32) == 8)
							(void)printf("\n\t");
						(void)printf("%x ", *cp);
					}
					break;
				}
			}
		}
	} else {
		/* We've got something other than an ECHOREPLY */
		if (!(options & F_VERBOSE))
			return;
		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));
		pr_icmph6(icp, end);
	}

	if (!(options & F_FLOOD)) {
		(void)putchar('\n');
		if (options & F_VERBOSE)
			pr_exthdrs(mhdr);
		(void)fflush(stdout);
		if (options & F_AUD_RECV)
			(void)fputc('\a', stderr);
	}
}

void
pr_exthdrs(struct msghdr *mhdr)
{
	struct cmsghdr *cm;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_level != IPPROTO_IPV6)
			continue;

		switch (cm->cmsg_type) {
		case IPV6_HOPOPTS:
			printf("  HbH Options: ");
			pr_ip6opt(CMSG_DATA(cm));
			break;
		case IPV6_DSTOPTS:
		case IPV6_RTHDRDSTOPTS:
			printf("  Dst Options: ");
			pr_ip6opt(CMSG_DATA(cm));
			break;
		case IPV6_RTHDR:
			printf("  Routing: ");
			pr_rthdr(CMSG_DATA(cm));
			break;
		}
	}
}

void
pr_ip6opt(void *extbuf)
{
	struct ip6_hbh *ext;
	int currentlen;
	u_int8_t type;
	size_t extlen;
	socklen_t len;
	void *databuf;
	u_int16_t value2;
	u_int32_t value4;

	ext = (struct ip6_hbh *)extbuf;
	extlen = (ext->ip6h_len + 1) * 8;
	printf("nxt %u, len %u (%lu bytes)\n", ext->ip6h_nxt,
	    (unsigned int)ext->ip6h_len, (unsigned long)extlen);

	currentlen = 0;
	while (1) {
		currentlen = inet6_opt_next(extbuf, extlen, currentlen,
		    &type, &len, &databuf);
		if (currentlen == -1)
			break;
		switch (type) {
		/*
		 * Note that inet6_opt_next automatically skips any padding
		 * options.
		 */
		case IP6OPT_JUMBO:
			inet6_opt_get_val(databuf, 0, &value4, sizeof(value4));
			printf("    Jumbo Payload Opt: Length %u\n",
			    (u_int32_t)ntohl(value4));
			break;
		case IP6OPT_ROUTER_ALERT:
			inet6_opt_get_val(databuf, 0, &value2, sizeof(value2));
			printf("    Router Alert Opt: Type %u\n",
			    ntohs(value2));
			break;
		default:
			printf("    Received Opt %u len %lu\n",
			    type, (unsigned long)len);
			break;
		}
	}
	return;
}

void
pr_rthdr(void *extbuf)
{
	struct in6_addr *in6;
	char ntopbuf[INET6_ADDRSTRLEN];
	struct ip6_rthdr *rh = (struct ip6_rthdr *)extbuf;
	int i, segments;

	/* print fixed part of the header */
	printf("nxt %u, len %u (%d bytes), type %u, ", rh->ip6r_nxt,
	    rh->ip6r_len, (rh->ip6r_len + 1) << 3, rh->ip6r_type);
	if ((segments = inet6_rth_segments(extbuf)) >= 0)
		printf("%d segments, ", segments);
	else
		printf("segments unknown, ");
	printf("%d left\n", rh->ip6r_segleft);

	for (i = 0; i < segments; i++) {
		in6 = inet6_rth_getaddr(extbuf, i);
		if (in6 == NULL)
			printf("   [%d]<NULL>\n", i);
		else {
			if (!inet_ntop(AF_INET6, in6, ntopbuf,
			    sizeof(ntopbuf)))
				strncpy(ntopbuf, "?", sizeof(ntopbuf));
			printf("   [%d]%s\n", i, ntopbuf);
		}
	}

	return;

}

int
get_hoplim(struct msghdr *mhdr)
{
	struct cmsghdr *cm;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_len == 0)
			return(-1);

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			return(*(int *)CMSG_DATA(cm));
	}

	return(-1);
}

int
get_pathmtu(struct msghdr *mhdr, struct sockaddr_in6 *dst)
{
	struct cmsghdr *cm;
	struct ip6_mtuinfo *mtuctl = NULL;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_len == 0)
			return(0);

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PATHMTU &&
		    cm->cmsg_len == CMSG_LEN(sizeof(struct ip6_mtuinfo))) {
			mtuctl = (struct ip6_mtuinfo *)CMSG_DATA(cm);

			/*
			 * If the notified destination is different from
			 * the one we are pinging, just ignore the info.
			 * We check the scope ID only when both notified value
			 * and our own value have non-0 values, because we may
			 * have used the default scope zone ID for sending,
			 * in which case the scope ID value is 0.
			 */
			if (!IN6_ARE_ADDR_EQUAL(&mtuctl->ip6m_addr.sin6_addr,
						&dst->sin6_addr) ||
			    (mtuctl->ip6m_addr.sin6_scope_id &&
			     dst->sin6_scope_id &&
			     mtuctl->ip6m_addr.sin6_scope_id !=
			     dst->sin6_scope_id)) {
				if ((options & F_VERBOSE) != 0) {
					printf("path MTU for %s is notified. "
					       "(ignored)\n",
					   pr_addr((struct sockaddr *)&mtuctl->ip6m_addr,
					   sizeof(mtuctl->ip6m_addr)));
				}
				return(0);
			}

			/*
			 * Ignore an invalid MTU. XXX: can we just believe
			 * the kernel check?
			 */
			if (mtuctl->ip6m_mtu < IPV6_MMTU)
				return(0);

			/* notification for our destination. return the MTU. */
			return((int)mtuctl->ip6m_mtu);
		}
	}
	return(0);
}

/*
 * pr_icmph6 --
 *	Print a descriptive string about an ICMP header.
 */
void
pr_icmph6(struct icmp6_hdr *icp, u_char *end)
{
	char ntop_buf[INET6_ADDRSTRLEN];
	struct nd_redirect *red;

	switch (icp->icmp6_type) {
	case ICMP6_DST_UNREACH:
		switch (icp->icmp6_code) {
		case ICMP6_DST_UNREACH_NOROUTE:
			(void)printf("No Route to Destination\n");
			break;
		case ICMP6_DST_UNREACH_ADMIN:
			(void)printf("Destination Administratively "
			    "Unreachable\n");
			break;
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
			(void)printf("Destination Unreachable Beyond Scope\n");
			break;
		case ICMP6_DST_UNREACH_ADDR:
			(void)printf("Destination Host Unreachable\n");
			break;
		case ICMP6_DST_UNREACH_NOPORT:
			(void)printf("Destination Port Unreachable\n");
			break;
		default:
			(void)printf("Destination Unreachable, Bad Code: %d\n",
			    icp->icmp6_code);
			break;
		}
		/* Print returned IP header information */
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_PACKET_TOO_BIG:
		(void)printf("Packet too big mtu = %d\n",
		    (int)ntohl(icp->icmp6_mtu));
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_TIME_EXCEEDED:
		switch (icp->icmp6_code) {
		case ICMP6_TIME_EXCEED_TRANSIT:
			(void)printf("Time to live exceeded\n");
			break;
		case ICMP6_TIME_EXCEED_REASSEMBLY:
			(void)printf("Frag reassembly time exceeded\n");
			break;
		default:
			(void)printf("Time exceeded, Bad Code: %d\n",
			    icp->icmp6_code);
			break;
		}
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_PARAM_PROB:
		(void)printf("Parameter problem: ");
		switch (icp->icmp6_code) {
		case ICMP6_PARAMPROB_HEADER:
			(void)printf("Erroneous Header ");
			break;
		case ICMP6_PARAMPROB_NEXTHEADER:
			(void)printf("Unknown Nextheader ");
			break;
		case ICMP6_PARAMPROB_OPTION:
			(void)printf("Unrecognized Option ");
			break;
		default:
			(void)printf("Bad code(%d) ", icp->icmp6_code);
			break;
		}
		(void)printf("pointer = 0x%02x\n",
		    (u_int32_t)ntohl(icp->icmp6_pptr));
		pr_retip6((struct ip6_hdr *)(icp + 1), end);
		break;
	case ICMP6_ECHO_REQUEST:
		(void)printf("Echo Request");
		/* XXX ID + Seq + Data */
		break;
	case ICMP6_ECHO_REPLY:
		(void)printf("Echo Reply");
		/* XXX ID + Seq + Data */
		break;
	case ICMP6_MEMBERSHIP_QUERY:
		(void)printf("Listener Query");
		break;
	case ICMP6_MEMBERSHIP_REPORT:
		(void)printf("Listener Report");
		break;
	case ICMP6_MEMBERSHIP_REDUCTION:
		(void)printf("Listener Done");
		break;
	case ND_ROUTER_SOLICIT:
		(void)printf("Router Solicitation");
		break;
	case ND_ROUTER_ADVERT:
		(void)printf("Router Advertisement");
		break;
	case ND_NEIGHBOR_SOLICIT:
		(void)printf("Neighbor Solicitation");
		break;
	case ND_NEIGHBOR_ADVERT:
		(void)printf("Neighbor Advertisement");
		break;
	case ND_REDIRECT:
		red = (struct nd_redirect *)icp;
		(void)printf("Redirect\n");
		if (!inet_ntop(AF_INET6, &red->nd_rd_dst, ntop_buf,
		    sizeof(ntop_buf)))
			strncpy(ntop_buf, "?", sizeof(ntop_buf));
		(void)printf("Destination: %s", ntop_buf);
		if (!inet_ntop(AF_INET6, &red->nd_rd_target, ntop_buf,
		    sizeof(ntop_buf)))
			strncpy(ntop_buf, "?", sizeof(ntop_buf));
		(void)printf(" New Target: %s", ntop_buf);
		break;
	default:
		(void)printf("Bad ICMP type: %d", icp->icmp6_type);
	}
}

/*
 * pr_iph6 --
 *	Print an IP6 header.
 */
void
pr_iph6(struct ip6_hdr *ip6)
{
	u_int32_t flow = ip6->ip6_flow & IPV6_FLOWLABEL_MASK;
	u_int8_t tc;
	char ntop_buf[INET6_ADDRSTRLEN];

	tc = *(&ip6->ip6_vfc + 1); /* XXX */
	tc = (tc >> 4) & 0x0f;
	tc |= (ip6->ip6_vfc << 4);

	printf("Vr TC  Flow Plen Nxt Hlim\n");
	printf(" %1x %02x %05x %04x  %02x   %02x\n",
	    (ip6->ip6_vfc & IPV6_VERSION_MASK) >> 4, tc, (u_int32_t)ntohl(flow),
	    ntohs(ip6->ip6_plen), ip6->ip6_nxt, ip6->ip6_hlim);
	if (!inet_ntop(AF_INET6, &ip6->ip6_src, ntop_buf, sizeof(ntop_buf)))
		strncpy(ntop_buf, "?", sizeof(ntop_buf));
	printf("%s->", ntop_buf);
	if (!inet_ntop(AF_INET6, &ip6->ip6_dst, ntop_buf, sizeof(ntop_buf)))
		strncpy(ntop_buf, "?", sizeof(ntop_buf));
	printf("%s\n", ntop_buf);
}

/*
 * pr_retip6 --
 *	Dump some info on a returned (via ICMPv6) IPv6 packet.
 */
void
pr_retip6(struct ip6_hdr *ip6, u_char *end)
{
	u_char *cp = (u_char *)ip6, nh;
	int hlen;

	if (end - (u_char *)ip6 < sizeof(*ip6)) {
		printf("IP6");
		goto trunc;
	}
	pr_iph6(ip6);
	hlen = sizeof(*ip6);

	nh = ip6->ip6_nxt;
	cp += hlen;
	while (end - cp >= 8) {
		switch (nh) {
		case IPPROTO_HOPOPTS:
			printf("HBH ");
			hlen = (((struct ip6_hbh *)cp)->ip6h_len+1) << 3;
			nh = ((struct ip6_hbh *)cp)->ip6h_nxt;
			break;
		case IPPROTO_DSTOPTS:
			printf("DSTOPT ");
			hlen = (((struct ip6_dest *)cp)->ip6d_len+1) << 3;
			nh = ((struct ip6_dest *)cp)->ip6d_nxt;
			break;
		case IPPROTO_FRAGMENT:
			printf("FRAG ");
			hlen = sizeof(struct ip6_frag);
			nh = ((struct ip6_frag *)cp)->ip6f_nxt;
			break;
		case IPPROTO_ROUTING:
			printf("RTHDR ");
			hlen = (((struct ip6_rthdr *)cp)->ip6r_len+1) << 3;
			nh = ((struct ip6_rthdr *)cp)->ip6r_nxt;
			break;
		case IPPROTO_AH:
			printf("AH ");
			hlen = (((struct ah *)cp)->ah_hl+2) << 2;
			nh = ((struct ah *)cp)->ah_nh;
			break;
		case IPPROTO_ICMPV6:
			printf("ICMP6: type = %d, code = %d\n",
			    *cp, *(cp + 1));
			return;
		case IPPROTO_ESP:
			printf("ESP\n");
			return;
		case IPPROTO_TCP:
			printf("TCP: from port %u, to port %u (decimal)\n",
			    (*cp * 256 + *(cp + 1)),
			    (*(cp + 2) * 256 + *(cp + 3)));
			return;
		case IPPROTO_UDP:
			printf("UDP: from port %u, to port %u (decimal)\n",
			    (*cp * 256 + *(cp + 1)),
			    (*(cp + 2) * 256 + *(cp + 3)));
			return;
		default:
			printf("Unknown Header(%d)\n", nh);
			return;
		}

		if ((cp += hlen) >= end)
			goto trunc;
	}
	if (end - cp < 8)
		goto trunc;

	putchar('\n');
	return;

  trunc:
	printf("...\n");
	return;
}

__dead void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: ping6 [-dEefHLmnqv] [-c count] [-h hoplimit] "
	    "[-I sourceaddr]\n\t[-i wait] [-l preload] [-p pattern] "
	    "[-s packetsize] [-V rtable]\n\t[-w maxwait] host\n");
	exit(1);
}
@


1.222
log
@Sync printing of wrong additional data to ping version.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.221 2016/09/17 09:37:56 florian Exp $	*/
@


1.221
log
@Only print that data is truncated like ping(8) does.  While here get
rid of the MINIMUM macro, it wasn't doing anything, anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.220 2016/09/17 09:36:42 florian Exp $	*/
d1040 4
a1043 2
			dp = outpack + ECHOLEN + ECHOTMLEN;
			for (i = ECHOLEN; cp < end; ++i, ++cp, ++dp) {
d1047 8
a1054 1
					    i, *dp, *cp);
@


1.220
log
@MAXPAYLOAD is different between ping and ping6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.219 2016/09/17 09:36:12 florian Exp $	*/
a925 2
#define MINIMUM(a,b) (((a)<(b))?(a):(b))

d1037 2
a1040 7
			if (cc != ECHOLEN + datalen) {
				int delta = cc - (datalen + ECHOLEN);

				(void)printf(" (%d bytes %s)",
				    abs(delta), delta > 0 ? "extra" : "short");
				end = buf + MINIMUM(cc, ECHOLEN + datalen);
			}
@


1.219
log
@dead store
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.218 2016/09/17 09:35:27 florian Exp $	*/
d125 1
a125 1
#define	MAXPAYLOAD	IPV6_MAXPACKET - IP6LEN - ECHOLEN
d168 1
d252 1
d337 1
a337 1
			datalen = strtonum(optarg, 0, MAXPAYLOAD, &errstr);
d760 1
a760 1
		    kk <= MAXPAYLOAD - (ECHOLEN + ECHOTMLEN + ii);
@


1.218
log
@Just use AF_INET like everywhere else.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.217 2016/09/17 09:34:57 florian Exp $	*/
a553 2

	optval = 1;
@


1.217
log
@malloc sets errno; use err not errx
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.216 2016/09/17 09:34:28 florian Exp $	*/
d381 1
a381 1
	hints.ai_family = PF_INET6;
@


1.216
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.215 2016/09/17 09:33:32 florian Exp $	*/
d375 1
a375 1
			errx(1, "malloc");
d407 1
a407 1
			errx(1, "malloc");
d582 1
a582 1
			errx(1, "can't allocate enough memory");
@


1.215
log
@Make getting source address more AF independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.214 2016/09/17 09:32:54 florian Exp $	*/
d641 1
a641 1
		struct msghdr	m;
@


1.214
log
@If -I was not given hoist getting source address up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.213 2016/09/17 09:31:04 florian Exp $	*/
d437 1
a437 1
		socklen_t len = sizeof(from6);
d439 1
a439 1
		if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
d442 1
a442 2
		from6.sin6_family = AF_INET6;
		from6.sin6_addr = dst6.sin6_addr;
a443 1
		from6.sin6_scope_id = dst6.sin6_scope_id;
d465 1
a465 1
		if (connect(dummy, (struct sockaddr *)&from6, len) < 0)
d468 1
a468 1
		if (getsockname(dummy, (struct sockaddr *)&from6, &len) < 0)
@


1.213
log
@Make source address selection more AF independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.212 2016/09/17 09:30:26 florian Exp $	*/
d431 43
a591 45
	}

	if (!source && options & F_VERBOSE) {
		/*
		 * get the source address. XXX since we revoked the root
		 * privilege, we cannot use a raw socket for this.
		 */
		int dummy;
		socklen_t len = sizeof(from6);

		if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
			err(1, "UDP socket");

		from6.sin6_family = AF_INET6;
		from6.sin6_addr = dst6.sin6_addr;
		from6.sin6_port = ntohs(DUMMY_PORT);
		from6.sin6_scope_id = dst6.sin6_scope_id;

		if (pktinfo &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTINFO,
		    (void *)pktinfo, sizeof(*pktinfo)))
			err(1, "UDP setsockopt(IPV6_PKTINFO)");

		if (hoplimit != -1 &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
		    (void *)&hoplimit, sizeof(hoplimit)))
			err(1, "UDP setsockopt(IPV6_UNICAST_HOPS)");

		if (hoplimit != -1 &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		    (void *)&hoplimit, sizeof(hoplimit)))
			err(1, "UDP setsockopt(IPV6_MULTICAST_HOPS)");

		if (rtableid > 0 &&
		    setsockopt(dummy, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) < 0)
			err(1, "setsockopt(SO_RTABLE)");

		if (connect(dummy, (struct sockaddr *)&from6, len) < 0)
			err(1, "UDP connect");

		if (getsockname(dummy, (struct sockaddr *)&from6, &len) < 0)
			err(1, "getsockname");

		close(dummy);
@


1.212
log
@Introduce AF independent from.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.211 2016/09/17 09:30:00 florian Exp $	*/
d420 1
a420 2
		memset(&hints, 0, sizeof(struct addrinfo));
		hints.ai_flags = AI_NUMERICHOST; /* allow hostname? */
d422 2
a423 8
		hints.ai_socktype = SOCK_RAW;
		hints.ai_protocol = IPPROTO_ICMPV6;

		error = getaddrinfo(source, NULL, &hints, &res);
		if (error)
			errx(1, "invalid source address: %s", 
			     gai_strerror(error));

d427 1
a427 1
		memcpy(&from6, res->ai_addr, sizeof(from6));
d429 1
a429 1
		if (bind(s, (struct sockaddr *)&from6, sizeof(from6)) != 0)
@


1.211
log
@Use AF independent dst where possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.210 2016/09/17 09:29:27 florian Exp $	*/
d225 1
a225 1
	struct sockaddr *dst;
d393 1
d624 1
a624 2
		printf("%s --> ", pr_addr((struct sockaddr *)&from6,
		    sizeof(from6)));
@


1.210
log
@Blindly s/dst/dst4/ or s/dst/dst6/, AF independent dst will be
introduced next.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.209 2016/09/17 09:26:49 florian Exp $	*/
d225 1
d392 1
d400 1
a400 1
	memcpy(&dst6, res->ai_addr, res->ai_addrlen);
d625 1
a625 2
	printf("%s): %d data bytes\n", pr_addr((struct sockaddr *)&dst6,
	    sizeof(dst6)), datalen);
d627 2
a628 2
	smsghdr.msg_name = &dst6;
	smsghdr.msg_namelen = sizeof(dst6);
@


1.209
log
@We will need the variable name "from" soon, so free it up by renaming
to peer. While here move declaration down to where it's needed. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.208 2016/09/17 09:26:07 florian Exp $	*/
d225 1
a225 1
	struct sockaddr_in6 from6, dst;
d368 1
a368 1
	memset(&dst, 0, sizeof(dst));
d371 1
a371 1
	if (inet_aton(*argv, &dst.sin_addr) != 0) {
d373 1
a373 1
		if ((target = strdup(inet_ntoa(dst.sin_addr))) == NULL)
d389 1
a389 1
		if (res->ai_addrlen != sizeof(dst))
d398 1
a398 1
	memcpy(&dst, res->ai_addr, res->ai_addrlen);
d521 1
a521 1
	if (IN6_IS_ADDR_MULTICAST(&dst.sin6_addr))
d567 1
a567 1
		from6.sin6_addr = dst.sin6_addr;
d569 1
a569 1
		from6.sin6_scope_id = dst.sin6_scope_id;
d623 2
a624 2
	printf("%s): %d data bytes\n", pr_addr((struct sockaddr *)&dst,
	    sizeof(dst)), datalen);
d626 2
a627 2
	smsghdr.msg_name = &dst;
	smsghdr.msg_namelen = sizeof(dst);
d719 1
a719 1
			if ((mtu = get_pathmtu(&m, &dst)) > 0) {
@


1.208
log
@Reduce diff in pinger().
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.207 2016/09/17 09:25:36 florian Exp $	*/
d225 1
a225 1
	struct sockaddr_in6 from, from6, dst;
d655 6
a660 5
		}		cmsgbuf;
		struct iovec	iov[1];
		struct pollfd	pfd;
		ssize_t		cc;
		int		timeout;
d694 2
a695 2
		m.msg_name = &from;
		m.msg_namelen = sizeof(from);
@


1.207
log
@We have different filters depending on the verbose flag. Merge filter
construction into existing verbose handling block.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.206 2016/09/17 09:24:51 florian Exp $	*/
d917 1
@


1.206
log
@Merge socket options that are set only when -v is given.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.205 2016/09/17 09:23:42 florian Exp $	*/
d507 4
a537 6
	if (!(options & F_VERBOSE)) {
		ICMP6_FILTER_SETBLOCKALL(&filt);
		ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filt);
	} else {
		ICMP6_FILTER_SETPASSALL(&filt);
	}
@


1.205
log
@This style hurt my eyes long enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.204 2016/09/17 09:23:04 florian Exp $	*/
d504 3
a542 9

	/* let the kernel pass extension headers of incoming packets */
	if ((options & F_VERBOSE) != 0) {
		int opton = 1;

		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDR, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVRTHDR)");
	}
@


1.204
log
@Set SO_RCVBUF like ping; the buffer will be bigger than before so this
should be ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.203 2016/09/17 09:21:59 florian Exp $	*/
d228 1
a530 3

    {
	struct icmp6_filter filt;
a539 1
    }
@


1.203
log
@Move more AF independent initialization around to reduce diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.202 2016/09/17 09:21:16 florian Exp $	*/
d231 1
d475 14
a488 5
	if (getsockopt(s, SOL_SOCKET, SO_RCVBUF, &maxsize, &maxsizelen) < 0)
		err(1, "getsockopt");
	if (maxsize < packlen &&
	    setsockopt(s, SOL_SOCKET, SO_RCVBUF, &packlen, sizeof(maxsize)) < 0)
		err(1, "setsockopt");
@


1.202
log
@Normalize receive packet allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.201 2016/09/17 09:20:39 florian Exp $	*/
d464 17
a498 17

	/*
	 * When trying to send large packets, you must increase the
	 * size of both the send and receive buffers...
	 */
	maxsizelen = sizeof maxsize;
	if (getsockopt(s, SOL_SOCKET, SO_SNDBUF, &maxsize, &maxsizelen) < 0)
		err(1, "getsockopt");
	if (maxsize < packlen &&
	    setsockopt(s, SOL_SOCKET, SO_SNDBUF, &packlen, sizeof(maxsize)) < 0)
		err(1, "setsockopt");

	if (getsockopt(s, SOL_SOCKET, SO_RCVBUF, &maxsize, &maxsizelen) < 0)
		err(1, "getsockopt");
	if (maxsize < packlen &&
	    setsockopt(s, SOL_SOCKET, SO_RCVBUF, &packlen, sizeof(maxsize)) < 0)
		err(1, "setsockopt");
@


1.201
log
@Sync PINGFILLED handling to ping(8); fixes bug by using the correct
length.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.200 2016/09/17 09:18:43 florian Exp $	*/
d455 1
a455 1
		err(1, "Unable to allocate packet");
@


1.200
log
@Move some more option handling around to reduce diff to ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.199 2016/09/17 09:17:55 florian Exp $	*/
d458 1
a458 1
		for (i = ECHOLEN; i < packlen; ++i)
@


1.199
log
@ping(8): The IPv6 header has a payload length field while IPv4 has a
length field for the whole packet. Make some room for IPv6 payload.
ping6(8): Sync to ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.198 2016/09/17 09:16:32 florian Exp $	*/
d448 15
a482 9
	/* in F_VERBOSE case, we may get non-echoreply packets*/
	if (options & F_VERBOSE && datalen < 2048)
		packlen = 2048 + IP6LEN + ECHOLEN + EXTRA; /* XXX 2048? */
	else
		packlen = datalen + IP6LEN + ECHOLEN + EXTRA;

	if (!(packet = malloc(packlen)))
		err(1, "Unable to allocate packet");

a498 6

	if (!(options & F_PINGFILLED))
		for (i = ECHOLEN; i < packlen; ++i)
			*datap++ = i;

	ident = getpid() & 0xFFFF;
@


1.198
log
@Bring over includes, we will need them in a merge anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.197 2016/09/17 09:15:38 florian Exp $	*/
d168 2
a169 1
u_char outpack[IPV6_MAXPACKET];
@


1.197
log
@does not need to be global
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.196 2016/09/13 07:17:40 florian Exp $	*/
d86 3
@


1.196
log
@Rearange option handling to reduce diff between ping(8) and ping6(8).
While here be explicit that timing and timinginfo are initialized to
0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.195 2016/09/13 07:16:49 florian Exp $	*/
a169 1
int hoplimit = -1;		/* hoplimit */
d226 1
a226 1
	int ch, i, optval = 1, packlen, maxsize, error, s;
@


1.195
log
@Make the raw socket non-global and pass it to retransmit()/pinger().
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.194 2016/09/13 07:15:56 florian Exp $	*/
d181 2
a182 2
int timing;			/* flag to do timing */
int timinginfo;
d432 13
a459 6
	if ((options & F_FLOOD) && (options & F_INTERVAL))
		errx(1, "-f and -i incompatible options");

	if ((options & F_FLOOD) && (options & (F_AUD_RECV | F_AUD_MISS)))
		warnx("No audible output for flood pings");

a464 5
	if (datalen >= sizeof(struct payload)) {
		/* we can time transfer */
		timing = 1;
	} else
		timing = 0;
a498 3
	if (options & F_SO_DEBUG)
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, &optval,
		    (socklen_t)sizeof(optval));
@


1.194
log
@Like in ping(8) there is no need to have the destination global. In
ping6(8) we have to pass the destination down to get_pathmtu.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.193 2016/09/13 07:13:07 florian Exp $	*/
a164 1
int s;				/* socket file descriptor */
d202 2
a203 2
void			 retransmit(void);
int			 pinger(void);
d227 1
a227 1
	int ch, i, optval = 1, packlen, maxsize, error;
d632 1
a632 1
		pinger();
d643 1
a643 1
			retransmit();
d664 1
a664 1
			retransmit();
d681 1
a681 1
			(void)pinger();
d832 1
a832 1
retransmit(void)
d842 1
a842 1
	if (pinger() == 0)
d874 1
a874 1
pinger(void)
@


1.193
log
@These functions are fundamentally AF dependent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.192 2016/09/13 07:11:56 florian Exp $	*/
a163 2
struct sockaddr_in6 dst;	/* who to ping6 */

d210 1
a210 1
int			 get_pathmtu(struct msghdr *);
d223 1
a223 1
	struct sockaddr_in6 from, from6;
d718 1
a718 1
			if ((mtu = get_pathmtu(&m)) > 0) {
d1211 1
a1211 1
get_pathmtu(struct msghdr *mhdr)
d1235 1
a1235 1
						&dst.sin6_addr) ||
d1237 1
a1237 1
			     dst.sin6_scope_id &&
d1239 1
a1239 1
			     dst.sin6_scope_id)) {
@


1.192
log
@timinginfo is a global flag that we got at least one packet back with
timing information for the summary line. Here we need to know if the
current echo reply was long enough to carry timing information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.191 2016/09/12 15:47:58 florian Exp $	*/
d213 2
a214 2
void			 pr_icmph(struct icmp6_hdr *, u_char *);
void			 pr_iph(struct ip6_hdr *);
d218 1
a218 1
void			 pr_retip(struct ip6_hdr *, u_char *);
d1072 1
a1072 1
		pr_icmph(icp, end);
d1266 1
a1266 1
 * pr_icmph --
d1270 1
a1270 1
pr_icmph(struct icmp6_hdr *icp, u_char *end)
d1300 1
a1300 1
		pr_retip((struct ip6_hdr *)(icp + 1), end);
d1305 1
a1305 1
		pr_retip((struct ip6_hdr *)(icp + 1), end);
d1320 1
a1320 1
		pr_retip((struct ip6_hdr *)(icp + 1), end);
d1340 1
a1340 1
		pr_retip((struct ip6_hdr *)(icp + 1), end);
d1389 1
a1389 1
 * pr_iph --
d1393 1
a1393 1
pr_iph(struct ip6_hdr *ip6)
d1416 1
a1416 1
 * pr_retip --
d1420 1
a1420 1
pr_retip(struct ip6_hdr *ip6, u_char *end)
d1429 1
a1429 1
	pr_iph(ip6);
@


1.191
log
@Bring over KAME copyright, there is now code from ping in ping6. While
here nuke NetBSD, KAME and BSDI ids. With this the beginning of
ping.c and ping6.c are in sync.
prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.190 2016/09/12 06:01:58 florian Exp $	*/
d1044 1
a1044 1
			if (timinginfo)
@


1.190
log
@Use ECHOLEN/ECHOTMLEN defines.
@
text
@d1 1
a1 2
/*	$OpenBSD: ping6.c,v 1.189 2016/09/11 19:58:36 florian Exp $	*/
/*	$KAME: ping6.c,v 1.163 2002/10/25 02:19:06 itojun Exp $	*/
a30 2

/*	BSDI	ping.c,v 2.3 1996/01/21 17:56:50 jch Exp	*/
@


1.189
log
@use ECHOLEN to define DEFDATALEN
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.188 2016/09/11 19:55:10 florian Exp $	*/
d774 1
a774 1
		    kk <= MAXPAYLOAD - (8 + sizeof(struct payload) + ii);
d992 1
a992 1
		if (cc >= 8 + sizeof(struct payload)) {
d1061 1
a1061 1
			for (i = 8; cp < end; ++i, ++cp, ++dp) {
@


1.188
log
@The lenght of our payload is AF independent;
s/ICMP6ECHOTMLEN/ECHOTMLEN/
no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.187 2016/09/11 19:53:33 florian Exp $	*/
d120 3
a122 1
#define	DEFDATALEN	(64 - 8)		/* default data length */
a123 2
#define	ECHOLEN	8	/* icmp echo header len excluding time */
#define	ECHOTMLEN sizeof(struct payload)
@


1.187
log
@The lenght of an icmp echo packet is AF independent;
s/ICMP6ECHOLEN/ECHOLEN/
no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.186 2016/09/11 19:52:47 florian Exp $	*/
d123 1
a123 1
#define	ICMP6ECHOTMLEN sizeof(struct payload)
d251 1
a251 1
	datap = &outpack[ECHOLEN + ICMP6ECHOTMLEN];
d1052 2
a1053 2
			cp = buf + ECHOLEN + ICMP6ECHOTMLEN;
			dp = outpack + ECHOLEN + ICMP6ECHOTMLEN;
@


1.186
log
@Crank default packetsize to ping(8) levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.185 2016/09/11 19:49:51 florian Exp $	*/
d122 1
a122 1
#define	ICMP6ECHOLEN	8	/* icmp echo header len excluding time */
d125 1
a125 1
#define	MAXPAYLOAD	IPV6_MAXPACKET - IP6LEN - ICMP6ECHOLEN
d251 1
a251 1
	datap = &outpack[ICMP6ECHOLEN + ICMP6ECHOTMLEN];
d471 1
a471 1
		packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA; /* XXX 2048? */
d473 1
a473 1
		packlen = datalen + IP6LEN + ICMP6ECHOLEN + EXTRA;
d496 1
a496 1
		for (i = ICMP6ECHOLEN; i < packlen; ++i)
d920 1
a920 1
		memcpy(&outpack[ICMP6ECHOLEN], &payload, sizeof(payload));
d922 1
a922 1
	cc = ICMP6ECHOLEN + datalen;
d1052 4
a1055 4
			cp = buf + ICMP6ECHOLEN + ICMP6ECHOTMLEN;
			dp = outpack + ICMP6ECHOLEN + ICMP6ECHOTMLEN;
			if (cc != ICMP6ECHOLEN + datalen) {
				int delta = cc - (datalen + ICMP6ECHOLEN);
d1059 1
a1059 1
				end = buf + MINIMUM(cc, ICMP6ECHOLEN + datalen);
@


1.185
log
@Whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.184 2016/09/11 19:49:20 florian Exp $	*/
d120 1
a124 1
#define	DEFDATALEN	ICMP6ECHOTMLEN
@


1.184
log
@Do not pretend that we can send more than IPV6_MAXPACKET bytes
payload. Sprinkle in some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.183 2016/09/11 19:48:12 florian Exp $	*/
d126 1
a126 1
#define	MAXWAIT_DEFAULT	10	/* secs to wait for response */
@


1.183
log
@style; no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.182 2016/09/11 19:47:12 florian Exp $	*/
a119 1
#define MAXPACKETLEN	131072
d121 2
a122 2
#define ICMP6ECHOLEN	8	/* icmp echo header len excluding time */
#define ICMP6ECHOTMLEN sizeof(struct payload)
d125 1
a125 1
#define MAXPAYLOAD	MAXPACKETLEN - IP6LEN - ICMP6ECHOLEN
d171 1
a171 1
u_char outpack[MAXPACKETLEN];
@


1.182
log
@With the if a few lines above, this can never be true.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.181 2016/09/11 19:46:10 florian Exp $	*/
d1064 3
a1066 1
					(void)printf("\nwrong data byte #%d should be 0x%x but was 0x%x", i, *dp, *cp);
@


1.181
log
@In this day and age use tcpdump to figure out to whom an ICMP echo
reply was sent. We already print the source IP for the echo request in
verbose mode. The destination IP should be the same in the replies.
Gets rid of 37 LOC and makes unification with ping easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.180 2016/09/11 19:44:43 florian Exp $	*/
a996 5

			if (cc - sizeof(*cp) < sizeof(payload)) {
				(void)printf("signature missing!\n");
				return;
			}
@


1.180
log
@The canonical way to find out if we can have timing stats is timinginfo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.179 2016/09/11 18:29:10 florian Exp $	*/
a216 1
struct in6_pktinfo	*get_rcvpktinfo(struct msghdr *);
a951 1
	struct in6_pktinfo *pktinfo = NULL;
a986 4
	if ((pktinfo = get_rcvpktinfo(mhdr)) == NULL) {
		warnx("failed to get receiving packet information");
		return;
	}
a1052 12
			if ((options & F_VERBOSE) != 0) {
				struct sockaddr_in6 dstsa;

				memset(&dstsa, 0, sizeof(dstsa));
				dstsa.sin6_family = AF_INET6;
				dstsa.sin6_len = sizeof(dstsa);
				dstsa.sin6_scope_id = pktinfo->ipi6_ifindex;
				dstsa.sin6_addr = pktinfo->ipi6_addr;
				(void)printf(" dst=%s",
				    pr_addr((struct sockaddr *)&dstsa,
				    sizeof(dstsa)));
			}
a1216 19
}

struct in6_pktinfo *
get_rcvpktinfo(struct msghdr *mhdr)
{
	struct cmsghdr *cm;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_len == 0)
			return(NULL);

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PKTINFO &&
		    cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo)))
			return((struct in6_pktinfo *)CMSG_DATA(cm));
	}

	return(NULL);
@


1.179
log
@adapt output to ping
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.178 2016/09/11 18:28:31 florian Exp $	*/
d1071 1
a1071 1
			if (timing)
@


1.178
log
@Normalize variable declarations in pr_pack. While here introduce seq
variable in ping and normalize it's usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.177 2016/09/11 18:25:29 florian Exp $	*/
d1056 1
a1056 1
			(void)printf("%d bytes from %s, icmp_seq=%u", cc,
d1074 1
a1074 1
				(void)printf("(DUP!)");
@


1.177
log
@Sync to ping: ring bell later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.176 2016/09/11 18:21:09 florian Exp $	*/
d953 1
d955 2
a956 2
	int i;
	int hoplim;
a958 5
	u_char *cp = NULL, *dp, *end = buf + cc;
	struct in6_pktinfo *pktinfo = NULL;
	struct timespec ts, tp;
	struct payload payload;
	struct tv64 *tv64;
d960 2
a961 1
	int dupflag;
d963 1
d997 1
a997 1
		seq = ntohs(icp->icmp6_seq);
d1001 1
d1015 1
a1015 2
			SipHash24_Update(&ctx,
			    &icp->icmp6_seq, sizeof(icp->icmp6_seq));
d1029 1
d1041 1
a1041 1
		if (TST(seq % mx_dup_ck)) {
d1046 1
a1046 1
			SET(seq % mx_dup_ck);
d1057 1
a1057 1
			    pr_addr(from, fromlen), seq);
@


1.176
log
@Hoist pr_addr() up, it's AF independent; no obj change.

Diff between ping and ping6 is easier to read if all identical
or as close as possible to being identical functions are in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.175 2016/09/11 18:19:32 florian Exp $	*/
a1075 2
			if (options & F_AUD_RECV)
				(void)fputc('\a', stderr);
d1106 2
@


1.175
log
@Hoist summary() up, it's AF independent; no obj change.

Diff between ping and ping6 is easier to read if all identical
or as close as possible to being identical functions are in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.174 2016/09/11 18:18:25 florian Exp $	*/
d817 19
a1457 20
}

/*
 * pr_addr --
 *	Return an ascii host address as a dotted quad and optionally with
 * a hostname.
 */
const char *
pr_addr(struct sockaddr *addr, socklen_t addrlen)
{
	static char buf[NI_MAXHOST];
	int flag = 0;

	if ((options & F_HOSTNAME) == 0)
		flag |= NI_NUMERICHOST;

	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)
		return (buf);
	else
		return "?";
@


1.174
log
@Hoist fill() up, it's AF independent; no obj change.

Diff between ping and ping6 is easier to read if all identical
or as close as possible to being identical functions are in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.173 2016/09/11 18:16:12 florian Exp $	*/
d788 28
a1288 28
}

void
summary(void)
{
	printf("\n--- %s ping6 statistics ---\n", hostname);
	printf("%lld packets transmitted, ", ntransmitted);
	printf("%lld packets received, ", nreceived);

	if (nrepeats)
		printf("%lld duplicates, ", nrepeats);
	if (ntransmitted) {
		if (nreceived > ntransmitted)
			printf("-- somebody's duplicating packets!");
		else
			printf("%.1f%% packet loss",
			    ((((double)ntransmitted - nreceived) * 100) /
			    ntransmitted));
	}
	printf("\n");
	if (timinginfo) {
		/* Only display average to microseconds */
		double num = nreceived + nrepeats;
		double avg = tsum / num;
		double dev = sqrt(fmax(0, tsumsq / num - avg * avg));
		printf("round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
		    tmin, avg, tmax, dev);
	}
@


1.173
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.172 2016/09/11 18:02:06 florian Exp $	*/
d758 30
a1540 31
}

void
fill(char *bp, char *patp)
{
	int ii, jj, kk;
	int pat[16];
	char *cp;

	for (cp = patp; *cp; cp++)
		if (!isxdigit((unsigned char)*cp))
			errx(1, "patterns must be specified as hex digits");
	ii = sscanf(patp,
	    "%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x",
	    &pat[0], &pat[1], &pat[2], &pat[3], &pat[4], &pat[5], &pat[6],
	    &pat[7], &pat[8], &pat[9], &pat[10], &pat[11], &pat[12],
	    &pat[13], &pat[14], &pat[15]);

/* xxx */
	if (ii > 0)
		for (kk = 0;
		    kk <= MAXPAYLOAD - (8 + sizeof(struct payload) + ii);
		    kk += ii)
			for (jj = 0; jj < ii; ++jj)
				bp[jj + kk] = pat[jj];
	if (!(options & F_QUIET)) {
		(void)printf("PATTERN: 0x");
		for (jj = 0; jj < ii; ++jj)
			(void)printf("%02x", bp[jj] & 0xFF);
		(void)printf("\n");
	}
@


1.172
log
@Whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.171 2016/09/11 18:01:24 florian Exp $	*/
a803 1

@


1.171
log
@Move smsghdr initialization into main, another step towards AF
independent pinger().
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.170 2016/09/11 17:59:12 florian Exp $	*/
d846 1
a846 2
		memcpy(&outpack[ICMP6ECHOLEN],
		    &payload, sizeof(payload));
@


1.170
log
@Remove useless comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.169 2016/09/11 17:56:12 florian Exp $	*/
d633 6
a850 3
	smsghdr.msg_name = &dst;
	smsghdr.msg_namelen = sizeof(dst);
	smsgiov.iov_base = (caddr_t)outpack;
a851 2
	smsghdr.msg_iov = &smsgiov;
	smsghdr.msg_iovlen = 1;
@


1.169
log
@sync to ping(8), no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.168 2016/09/11 17:53:16 florian Exp $	*/
a198 1
/* for ancillary data(advanced API) */
@


1.168
log
@Shuffle pinger() initialization around to reduce diff to ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.167 2016/09/11 17:50:56 florian Exp $	*/
d858 1
a858 2
		(void)printf("ping6: wrote %s %d chars, ret=%d\n",
		    hostname, cc, i);
d863 1
a863 1
	return(0);
@


1.167
log
@Remove destination IP from mac, it's not helping anything.
Next step in making these functions AF independent. Note that before
rev 1.147 of ping6(8) it did not put the destination IP into the mac,
only ping(8) did.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.166 2016/09/11 11:19:27 florian Exp $	*/
d804 1
a804 1
	int i, cc;
d810 2
a814 3
	seq = htons(ntransmitted++);
	CLR(ntohs(seq) % mx_dup_ck);

d819 3
@


1.166
log
@normalize seq handling in pinger; little step to make this AF
independent
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.165 2016/09/11 11:17:15 florian Exp $	*/
a836 1
		SipHash24_Update(&ctx, &dst.sin6_addr, sizeof(dst.sin6_addr));
a941 2
			SipHash24_Update(&ctx, &dst.sin6_addr,
			    sizeof(dst.sin6_addr));
@


1.165
log
@remove useless comment; reduces diff to ping; no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.164 2016/09/11 11:16:07 florian Exp $	*/
d805 1
a805 1
	int seq;
d813 2
a814 2
	seq = ntransmitted++;
	CLR(seq % mx_dup_ck);
d819 1
a819 1
	icp->icmp6_seq = ntohs(seq);
d836 1
a836 2
		SipHash24_Update(&ctx,
		    &icp->icmp6_seq, sizeof(icp->icmp6_seq));
@


1.164
log
@safeputc is unused ever since we nuked RFC 4620 support
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.163 2016/09/10 07:43:49 florian Exp $	*/
d727 1
a727 4
		} else {
			/*
			 * an ICMPv6 message (probably an echoreply) arrived.
			 */
d729 1
a729 1
		}
@


1.163
log
@according to netinet6/in6.h IPV6_MULTICAST_LOOP setsockopt takes a
u_char argument
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.162 2016/09/10 07:43:03 florian Exp $	*/
a881 1
#define safeputc(c)	printf((isprint((c)) ? "%c" : "\\%03o"), c)
a1039 1
#undef safeputc
@


1.162
log
@move IPv6 specific structs up; no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.161 2016/09/10 07:42:20 florian Exp $	*/
d237 1
a237 1
	u_char *datap, *packet;
d241 1
a241 1
	int mflag = 0, loop = 1;
@


1.161
log
@reorder main variables, reduces diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.160 2016/09/10 07:41:36 florian Exp $	*/
d232 2
a239 2
	struct cmsghdr *scmsg = NULL;
	struct in6_pktinfo *pktinfo = NULL;
@


1.160
log
@reorder main variables; no obj change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.159 2016/09/10 07:31:43 florian Exp $	*/
d234 1
a234 1
	int ch, i, maxsize, packlen, optval, error;
@


1.159
log
@reorder function declaration to reduce diff between ping and ping6; no
object change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.158 2016/09/08 13:59:33 florian Exp $	*/
d229 1
a229 1
	struct addrinfo *res;
d232 1
a232 1
	struct addrinfo hints;
a234 1
	socklen_t maxsizelen;
d236 1
a236 2
	char *e, *target, hbuf[NI_MAXHOST];
	char *source = NULL;
@


1.158
log
@normalize option defines; reduces diff between ping(8) and ping6(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.157 2016/09/07 17:56:00 florian Exp $	*/
d195 2
a196 1
struct tv64 tv64_offset;	/* random offset for time values */
d207 18
a224 18
int	 main(int, char *[]);
void	 fill(char *, char *);
int	 get_hoplim(struct msghdr *);
int	 get_pathmtu(struct msghdr *);
struct in6_pktinfo *get_rcvpktinfo(struct msghdr *);
void	 onsignal(int);
void	 retransmit(void);
int	 pinger(void);
const char *pr_addr(struct sockaddr *, socklen_t);
void	 pr_icmph(struct icmp6_hdr *, u_char *);
void	 pr_iph(struct ip6_hdr *);
void	 pr_pack(u_char *, int, struct msghdr *);
void	 pr_exthdrs(struct msghdr *);
void	 pr_ip6opt(void *);
void	 pr_rthdr(void *);
void	 pr_retip(struct ip6_hdr *, u_char *);
void	 summary(void);
__dead void	 usage(void);
@


1.157
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.156 2016/09/07 17:55:14 florian Exp $	*/
d135 2
d139 1
d142 1
d144 1
d146 6
a151 5
/*			0x4000 */
#define F_HOSTNAME	0x10000
#define F_AUD_RECV	0x200000
#define F_AUD_MISS	0x400000
u_int options;
@


1.156
log
@normalize code to send preload packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.155 2016/09/04 10:44:28 florian Exp $	*/
a737 1

@


1.155
log
@move to ping's getaddrinfo version to reduce diff; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.154 2016/09/03 21:47:57 florian Exp $	*/
d630 1
a630 1
		(void)pinger();
@


1.154
log
@get to the target the same way as ping; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.153 2016/09/02 14:22:29 florian Exp $	*/
d222 1
a222 1
	struct addrinfo *res0;
d230 1
a230 1
	char *e, *target;
d367 1
a367 1
	target = *argv;
d369 13
a381 2
	/* getaddrinfo */
	memset(&hints, 0, sizeof(struct addrinfo));
d383 15
a397 3
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_RAW;
	hints.ai_protocol = IPPROTO_ICMPV6;
d399 6
a404 13
	error = getaddrinfo(target, NULL, &hints, &res0);
	if (error)
		errx(1, "host %s: %s", target, gai_strerror(error));
	if (res0->ai_canonname) {
		if ((hostname = strdup(res0->ai_canonname)) == NULL)
			errx(1, "out of memory");
	} else
		hostname = target;
	if (res0->ai_next && (options & F_VERBOSE))
		warnx("host resolves to multiple addresses");
	if (res0->ai_family != AF_INET6 || res0->ai_addrlen != sizeof(dst))
		errx(1, "getaddrinfo failed");
	memcpy(&dst, res0->ai_addr, sizeof(dst));
d406 8
a413 1
	freeaddrinfo(res0);
a414 1
	/* set the source address if specified. */
d422 1
a422 1
		error = getaddrinfo(source, NULL, &hints, &res0);
d427 1
a427 1
		if (res0->ai_family != AF_INET6 || res0->ai_addrlen !=
d430 2
a431 2
		memcpy(&from6, res0->ai_addr, sizeof(from6));
		freeaddrinfo(res0);
@


1.153
log
@Bring over 1.117 from ping:
----------------------------------------------------------------
Only read time information from the received packet if it is big
enough.
OK deraadt@@
----------------------------------------------------------------

And with this summary() is in sync between ping and ping6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.152 2016/09/02 14:14:39 florian Exp $	*/
d367 1
a367 1
	target = argv[argc - 1];
@


1.152
log
@Reduce ping/ping6 difference in summary().
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.151 2016/08/30 14:28:31 deraadt Exp $	*/
d183 1
d905 1
a905 1
		if (timing) {
d931 1
d1235 1
a1235 1
	if (nreceived && timing) {
@


1.151
log
@summary() is no longer called from a signal handler, so it can use
stdio and does not need the workarounds.
ok florian millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.150 2016/08/30 13:58:24 millert Exp $	*/
a1214 4
/*
 * summary --
 *	Print out statistics.
 */
d1223 1
a1223 1
		printf("+%lld duplicates, ", nrepeats);
d1228 1
a1228 1
			printf("%.1lf%% packet loss",
@


1.150
log
@Avoid calling summary() from a signal handler.  This will allow us
to go back to using stdio there.  OK florian@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.149 2016/08/30 13:50:13 florian Exp $	*/
d1222 3
a1224 1
	char buf[8192], buft[8192];
d1226 2
a1227 15
	 /* XXX - safe to use fprintf here now */
	snprintf(buft, sizeof(buft), "--- %s ping6 statistics ---\n",
	    hostname);
	strlcat(buf, buft, sizeof(buf));
	snprintf(buft, sizeof(buft), "%lld packets transmitted, ",
	    ntransmitted);
	strlcat(buf, buft, sizeof(buf));
	snprintf(buft, sizeof(buft), "%lld packets received, ",
	    nreceived);
	strlcat(buf, buft, sizeof(buf));
	if (nrepeats) {
		snprintf(buft, sizeof(buft), "+%lld duplicates, ",
		    nrepeats);
		strlcat(buf, buft, sizeof(buf));
	}
d1230 1
a1230 2
			snprintf(buft, sizeof(buft),
			    "-- somebody's duplicating packets!");
d1232 1
a1232 1
			snprintf(buft, sizeof(buft), "%.1lf%% packet loss",
a1234 1
		strlcat(buf, buft, sizeof(buf));
d1236 1
a1236 1
	strlcat(buf, "\n", sizeof(buf));
d1242 1
a1242 2
		snprintf(buft, sizeof(buft),
		    "round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
a1243 1
		strlcat(buf, buft, sizeof(buf));
a1244 2
	write(STDOUT_FILENO, buf, strlen(buf));
	(void)fflush(stdout);
@


1.149
log
@Make sure to not decrease packet size when running with -v.
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.148 2016/08/30 12:10:10 florian Exp $	*/
a205 1
void	 onint(int);
d215 1
a215 1
void	 summary(int);
d636 2
a648 5
		if (seenint) {
			onint(SIGINT);
			seenint = 0;
			continue;
		}
d650 1
a650 1
			summary(0);
d708 1
a708 1
	summary(0);
d737 6
d761 1
d763 2
a764 2
	(void)signal(SIGALRM, onint);
	(void)setitimer(ITIMER_REAL, &itimer, NULL);
a1215 15
 * onint --
 *	SIGINT handler.
 */
void
onint(int signo)
{
	summary(signo);

	if (signo)
		_exit(nreceived ? 0 : 1);
	else
		exit(nreceived ? 0 : 1);
}

/*
d1220 1
a1220 1
summary(int signo)
d1224 1
a1224 2
	buf[0] = '\0';

d1261 1
a1261 2
	if (signo == 0)
		(void)fflush(stdout);
@


1.148
log
@usage() is __dead.
While here remove one useless call to usage() that's covered by the
very next line.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.147 2016/08/30 11:15:16 florian Exp $	*/
d446 1
a446 1
	if (options & F_VERBOSE)
@


1.147
log
@Add destination IP to MAC, reduces difference to ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.146 2016/03/03 18:30:48 florian Exp $	*/
d217 1
a217 1
void	 usage(void);
a357 1
			/*NOTREACHED*/
a363 5
	if (argc < 1) {
		usage();
		/*NOTREACHED*/
	}

d1561 1
a1561 1
void
@


1.146
log
@ping(8) and ping6(8) use different types for packet counters. In
preparation of a merge just use int64_t and be done with it.
OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.145 2016/01/30 05:38:26 semarie Exp $	*/
d817 1
d924 2
@


1.145
log
@ping, ping6: corrects -E (audible beep when no packet is received before the
next packet is transmitted) regression

with help and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.144 2016/01/28 17:26:10 gsoares Exp $	*/
d103 1
d174 5
a178 5
long npackets;			/* max packets to transmit */
long nreceived;			/* # of packets we got back */
long nrepeats;			/* number of duplicates */
long ntransmitted;		/* sequence # for outbound packets = #sent */
unsigned long nmissedmax = 1;	/* max value of ntransmitted - nreceived - 1 */
d226 2
a227 1
	int ch, i, maxsize, packlen, preload, optval, error;
d254 1
a254 1
			npackets = strtonum(optarg, 0, INT_MAX, &errstr);
d314 1
a314 1
			preload = strtonum(optarg, 1, INT_MAX, &errstr);
d1244 1
a1244 1
	snprintf(buft, sizeof(buft), "%ld packets transmitted, ",
d1247 1
a1247 1
	snprintf(buft, sizeof(buft), "%ld packets received, ",
d1251 1
a1251 1
		snprintf(buft, sizeof(buft), "+%ld duplicates, ",
@


1.144
log
@malloc(3) returns a pointer, so check against NULL, not 0. (No functional change)

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.143 2015/11/29 22:41:20 florian Exp $	*/
d644 6
a714 6
		if (ntransmitted - nreceived - 1 > nmissedmax) {
			nmissedmax = ntransmitted - nreceived - 1;
			if (!(options & F_FLOOD) && (options & F_AUD_MISS))
				(void)fputc('\a', stderr);
		}

@


1.143
log
@Reimplement source address selection. Inspired by the previous
traceroute / traceroute6 merge. Next step in unification.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.142 2015/11/29 12:32:10 florian Exp $	*/
d529 1
a529 1
		if ((scmsg = malloc( CMSG_SPACE(sizeof(int)))) == 0)
@


1.142
log
@Doubles are not reals. Imprecision might lead to trying to
calculate square root of a negative number. Just use 0 in this case.
Pointed out by and fix from Nathanael Rensen ( nathanael AT list DOT
polymorpheus DOT com ), thanks!
OK deraadt@@

(Funnily this bug was in ping6 for many years, only discovered once I
synced ping to the ping6 implementation recently.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.141 2015/11/10 18:36:33 florian Exp $	*/
d140 1
a140 1
#define F_SRCADDR	0x4000
d162 1
a162 1
struct sockaddr_in6 src;	/* src addr of this packet */
d223 1
a223 1
	struct sockaddr_in6 from;
d229 1
d282 2
a283 17
			memset(&hints, 0, sizeof(struct addrinfo));
			hints.ai_flags = AI_NUMERICHOST; /* allow hostname? */
			hints.ai_family = AF_INET6;
			hints.ai_socktype = SOCK_RAW;
			hints.ai_protocol = IPPROTO_ICMPV6;

			error = getaddrinfo(optarg, NULL, &hints, &res0);
			if (error)
				errx(1, "invalid source address: %s",
				     gai_strerror(error));

			if (res0->ai_family != AF_INET6 || res0->ai_addrlen !=
			    sizeof(src))
				errx(1, "invalid source address");
			memcpy(&src, res0->ai_addr, sizeof(src));
			freeaddrinfo(res0);
			options |= F_SRCADDR;
d397 19
a415 3
	if ((options & F_SRCADDR) &&
	    bind(s, (struct sockaddr *)&src, sizeof(src)) != 0) {
		err(1, "bind");
d540 1
a540 1
	if (!(options & F_SRCADDR) && options & F_VERBOSE) {
d546 1
a546 1
		socklen_t len = sizeof(src);
d551 4
a554 4
		src.sin6_family = AF_INET6;
		src.sin6_addr = dst.sin6_addr;
		src.sin6_port = ntohs(DUMMY_PORT);
		src.sin6_scope_id = dst.sin6_scope_id;
d576 1
a576 1
		if (connect(dummy, (struct sockaddr *)&src, len) < 0)
d579 1
a579 1
		if (getsockname(dummy, (struct sockaddr *)&src, &len) < 0)
d606 2
a607 2
		printf("%s --> ", pr_addr((struct sockaddr *)&src,
		    sizeof(src)));
@


1.141
log
@Reduce diff between ping and ping6.
- increase MAX_DUP_CHK in ping to ping6' value, we should have enough
  ram these days.
- sync -l, -s and -V option handling
- rename MAXDATALEN to MAXPAYLOAD in ping6
no (intendet) functional change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.140 2015/11/05 21:56:56 florian Exp $	*/
d1266 1
a1266 1
		double dev = sqrt(tsumsq / num - avg * avg);
@


1.140
log
@Whitespace, reduce diff to ping.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.139 2015/11/05 21:30:45 florian Exp $	*/
d125 1
a125 1
#define MAXDATALEN	MAXPACKETLEN - IP6LEN - ICMP6ECHOLEN
d240 1
a240 1
	/* revoke root privilege */
d267 2
a268 4
			if (getuid()) {
				errno = EPERM;
				errx(1, "Must be superuser to flood ping");
			}
d324 3
a326 5
			if (getuid()) {
				errno = EPERM;
				errx(1, "Must be superuser to preload");
			}
			preload = strtonum(optarg, 0, INT_MAX, &errstr);
d345 1
a345 1
			datalen = strtonum(optarg, 1, MAXDATALEN, &errstr);
d347 1
a347 1
				errx(1, "datalen value is %s: %s", errstr,
d1548 1
a1548 1
		    kk <= MAXDATALEN - (8 + sizeof(struct payload) + ii);
@


1.139
log
@Cleanup includes.
guenther@@ and kettenis@@ confirmed that while not strictly necessary on
OpenBSD we should include both time.h and sys/time.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.138 2015/11/04 21:26:30 tedu Exp $	*/
d110 2
a111 2
	u_int64_t tv64_sec;
	u_int64_t tv64_nsec;
@


1.138
log
@replace setbuf with setvbuf, from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.137 2015/11/04 20:10:15 florian Exp $	*/
d84 2
a86 4
#include <sys/socket.h>

#include <net/if.h>
#include <net/route.h>
a92 1
#include <arpa/nameser.h>
d98 1
a98 2
#include <fcntl.h>
#include <time.h>
d100 1
d102 1
d106 1
a107 4
#include <poll.h>

#include <md5.h>
#include <siphash.h>
@


1.137
log
@Simplify packet option handling since we are only setting one option
these days.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.136 2015/11/04 20:04:10 florian Exp $	*/
d277 1
a277 1
			setbuf(stdout, (char *)NULL);
@


1.136
log
@dead store; pointed out by llvm
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.135 2015/10/25 20:01:21 florian Exp $	*/
a197 1
char *scmsg;
d235 1
a235 2
	int ip6optlen = 0;
	struct cmsghdr *scmsgp = NULL;
d534 3
a536 7
	if (hoplimit != -1)
		ip6optlen += CMSG_SPACE(sizeof(int));


	/* set IP6 packet options */
	if (ip6optlen) {
		if ((scmsg = malloc(ip6optlen)) == 0)
d539 1
a539 9
		smsghdr.msg_controllen = ip6optlen;
		scmsgp = (struct cmsghdr *)scmsg;
	}

	if (hoplimit != -1) {
		scmsgp->cmsg_len = CMSG_LEN(sizeof(int));
		scmsgp->cmsg_level = IPPROTO_IPV6;
		scmsgp->cmsg_type = IPV6_HOPLIMIT;
		*(int *)(CMSG_DATA(scmsgp)) = hoplimit;
d541 4
a544 1
		scmsgp = CMSG_NXTHDR(&smsghdr, scmsgp);
@


1.135
log
@pr_bitrange() is unused, nuke it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.134 2015/10/25 19:58:56 florian Exp $	*/
a1068 1
	size_t offset;
d1089 1
a1089 3
			offset = 0;
			offset = inet6_opt_get_val(databuf, offset,
			    &value4, sizeof(value4));
d1094 1
a1094 3
			offset = 0;
			offset = inet6_opt_get_val(databuf, offset,
						   &value2, sizeof(value2));
@


1.134
log
@remove prototype for removed pingerlen function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.133 2015/10/25 14:43:48 florian Exp $	*/
a219 1
int	 pr_bitrange(u_int32_t, int, int);
a1142 46
}

int
pr_bitrange(u_int32_t v, int soff, int ii)
{
	int off;
	int i;

	off = 0;
	while (off < 32) {
		/* shift till we have 0x01 */
		if ((v & 0x01) == 0) {
			if (ii > 1)
				printf("-%u", soff + off - 1);
			ii = 0;
			switch (v & 0x0f) {
			case 0x00:
				v >>= 4;
				off += 4;
				continue;
			case 0x08:
				v >>= 3;
				off += 3;
				continue;
			case 0x04: case 0x0c:
				v >>= 2;
				off += 2;
				continue;
			default:
				v >>= 1;
				off += 1;
				continue;
			}
		}

		/* we have 0x01 with us */
		for (i = 0; i < 32 - off; i++) {
			if ((v & (0x01 << i)) == 0)
				break;
		}
		if (!ii)
			printf(" %u", soff + off);
		ii += i;
		v >>= i; off += i;
	}
	return ii;
@


1.133
log
@IPV6_NEXTHOP is gone, remove -g option which used this.
kill it mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.132 2015/10/25 12:47:26 florian Exp $	*/
a211 1
size_t	 pingerlen(void);
@


1.132
log
@Implement ping(8)'s -L option in ping6:
Disable the loopback, so the transmitting host doesn't see the ICMP
requests. For multicast pings.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.131 2015/10/24 16:59:15 florian Exp $	*/
d236 1
a236 1
	char *e, *target, *gateway = NULL;
d257 1
a257 1
	    "c:dEefg:Hh:I:i:Ll:mNnp:qS:s:V:vw:")) != -1) {
a282 3
		case 'g':
			gateway = optarg;
			break;
a428 21
	/* set the gateway (next hop) if specified */
	if (gateway) {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = AF_INET6;
		hints.ai_socktype = SOCK_RAW;
		hints.ai_protocol = IPPROTO_ICMPV6;

		error = getaddrinfo(gateway, NULL, &hints, &res0);
		if (error)
			errx(1, "gateway %s: %s", gateway, gai_strerror(error));

		if (res0->ai_next && (options & F_VERBOSE))
			warnx("gateway resolves to multiple addresses");

		if (setsockopt(s, IPPROTO_IPV6, IPV6_NEXTHOP, res0->ai_addr,
		    res0->ai_addrlen))
			err(1, "setsockopt(IPV6_NEXTHOP)");

		freeaddrinfo(res0);
	}

d1637 1
a1637 1
	    "usage: ping6 [-dEefHLmnqv] [-c count] [-g gateway] [-h hoplimit] "
@


1.131
log
@Inline trivial myechoreply function in the one place it's used; like
ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.130 2015/10/24 16:41:11 florian Exp $	*/
d151 4
d242 1
a242 1
	int mflag = 0;
d257 1
a257 1
	    "c:dEefg:Hh:I:i:l:mNnp:qS:s:V:vw:")) != -1) {
d333 4
d474 5
d1661 1
a1661 1
	    "usage: ping6 [-dEefHmnqv] [-c count] [-g gateway] [-h hoplimit] "
@


1.130
log
@nonce is unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.129 2015/10/24 16:32:26 florian Exp $	*/
a212 1
int	 myechoreply(const struct icmp6_hdr *);
a873 9
int
myechoreply(const struct icmp6_hdr *icp)
{
	if (ntohs(icp->icmp6_id) == ident)
		return 1;
	else
		return 0;
}

d930 3
a932 1
	if (icp->icmp6_type == ICMP6_ECHO_REPLY && myechoreply(icp)) {
@


1.129
log
@Sync ping6 output to ping. ping has been around for longer and so
defines the canonical output format. Having different output is
getting in the way of a merge.
This moves the output of the src address to the -v option. With the
overly complicated IPv6 address selection it's sometimes usefull to
have this information.
OK benno@@, sthen@@ can live with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.128 2015/10/17 15:43:31 florian Exp $	*/
a170 1
u_int8_t nonce[8];		/* nonce field for node information */
a502 1
	arc4random_buf(nonce, sizeof(nonce));
@


1.128
log
@make usage() less horrible
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.127 2015/10/17 13:08:14 florian Exp $	*/
d574 1
a574 1
	if (!(options & F_SRCADDR)) {
d638 6
a643 4
	printf("PING6(%lu=40+8+%lu bytes) ", (unsigned long)(40 + ICMP6ECHOLEN
	    + datalen), (unsigned long)(ICMP6ECHOLEN + datalen - 8));
	printf("%s --> ", pr_addr((struct sockaddr *)&src, sizeof(src)));
	printf("%s\n", pr_addr((struct sockaddr *)&dst, sizeof(dst)));
d1331 1
a1331 1
	snprintf(buft, sizeof(buft), "\n--- %s ping6 statistics ---\n",
@


1.127
log
@Implement -w maxwait now that the -w flag is free in ping6. Same
behaviour as ping(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.126 2015/10/17 13:07:02 florian Exp $	*/
d1656 3
a1658 6
	    "usage: ping6 [-dEefH"
	    "m"
	    "nqv"
	    "] [-c count] [-g gateway]\n\t"
	    "[-h hoplimit] [-I sourceaddr] [-i wait] [-l preload] [-p pattern]"
	    "\n\t[-s packetsize] [-V rtable] [-w maxwait] host\n");
@


1.126
log
@move -V option before -v and remove one spurious newline, now in sync
with ping.
No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.125 2015/10/16 22:47:12 florian Exp $	*/
d131 1
d184 1
d255 1
a255 1
	    "c:dEefg:Hh:I:i:l:mNnp:qS:s:vV:")) != -1) {
d372 6
d784 1
a784 1
	 * ten seconds if we haven't.
a785 1
#define	MAXWAIT		10
d791 1
a791 1
		itimer.it_value.tv_sec = MAXWAIT;
d1661 1
a1661 1
	    "\n\t[-s packetsize] [-V rtable] host\n");
@


1.125
log
@Remove RFC 4620 support. The RFC is experimental and this code plain
needs killing before the installed user base excedes 6. Minus 745 LOC.
This is getting in the way of a merge since it has it's tentacles all
over the place.
OK jca@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.124 2015/10/16 18:17:12 florian Exp $	*/
a357 3
		case 'v':
			options |= F_VERBOSE;
			break;
d359 1
a359 2
			rtableid = strtonum(optarg, 0, RT_TABLEID_MAX,
			    &errstr);
d366 3
@


1.124
log
@Move -t and -w functionality to -a. Both flags are in the way for a
merge with ping(8). Let's see if we can shove every weird and special v6
functionality into -a.
suggested by and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.123 2015/10/14 17:26:01 florian Exp $	*/
a127 3
#define ICMP6_NIQLEN	(ICMP6ECHOLEN + 8)
/* FQDN case, 64 bits of nonce + 32 bits ttl */
#define ICMP6_NIRLEN	(ICMP6ECHOLEN + 12)
a143 2
#define F_NODEADDR	0x0800
#define F_FQDN		0x1000
a145 2
#define F_NIGROUP	0x40000
#define F_SUPTYPES	0x80000
a147 1
#define F_NOUSERDATA	(F_NODEADDR | F_FQDN | F_SUPTYPES)
a189 3
/* for node addresses */
u_short naflags;

a211 2
void	 pr_suptypes(struct icmp6_nodeinfo *, size_t);
void	 pr_nodeaddr(struct icmp6_nodeinfo *, int);
a212 3
int	 mynireply(const struct icmp6_nodeinfo *);
char	*dnsdecode(const u_char **, const u_char *, const u_char *, char *,
	    size_t);
a219 1
char	*nigroup(char *);
d253 1
a253 1
	    "a:c:dEefHg:h:I:i:l:mnNp:qS:s:vV:")) != -1) {
a254 48
		case 'a':
		{
			char *cp;

			options &= ~F_NOUSERDATA;
			for (cp = optarg; *cp != '\0'; cp++) {
				switch (*cp) {
				case 'a':
					options |= F_NODEADDR;
					naflags |= NI_NODEADDR_FLAG_ALL;
					break;
				case 'c':
				case 'C':
					options |= F_NODEADDR;
					naflags |= NI_NODEADDR_FLAG_COMPAT;
					break;
				case 'd':
					options |= F_FQDN;
					break;
				case 'l':
				case 'L':
					options |= F_NODEADDR;
					naflags |= NI_NODEADDR_FLAG_LINKLOCAL;
					break;
				case 'n':
					options |= F_SUPTYPES;
					break;
				case 's':
				case 'S':
					options |= F_NODEADDR;
					naflags |= NI_NODEADDR_FLAG_SITELOCAL;
					break;
				case 'g':
				case 'G':
					options |= F_NODEADDR;
					naflags |= NI_NODEADDR_FLAG_GLOBAL;
					break;
				case 'A': /* experimental. not in the spec */
					options |= F_NODEADDR;
					naflags |= NI_NODEADDR_FLAG_ANYCAST;
					break;
				default:
					usage();
					/*NOTREACHED*/
				}
			}
			break;
		}
a344 3
		case 'N':
			options |= F_NIGROUP;
			break;
d388 1
a388 8
	if (options & F_NIGROUP) {
		target = nigroup(argv[argc - 1]);
		if (target == NULL) {
			usage();
			/*NOTREACHED*/
		}
	} else
		target = argv[argc - 1];
d461 4
a464 14

	if ((options & F_NOUSERDATA) == 0) {
		if (datalen >= sizeof(struct payload)) {
			/* we can time transfer */
			timing = 1;
		} else
			timing = 0;
		/* in F_VERBOSE case, we may get non-echoreply packets*/
		if (options & F_VERBOSE)
			packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA;
		else
			packlen = datalen + IP6LEN + ICMP6ECHOLEN + EXTRA;
	} else {
		/* suppress timing for node information query */
d466 5
a470 3
		datalen = 2048;
		packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA;
	}
d527 1
a527 5
		if ((options & F_FQDN) || (options & F_NODEADDR) ||
		    (options & F_SUPTYPES))
			ICMP6_FILTER_SETPASS(ICMP6_NI_REPLY, &filt);
		else
			ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filt);
d631 2
a632 2
	printf("PING6(%lu=40+8+%lu bytes) ", (unsigned long)(40 + pingerlen()),
	    (unsigned long)(pingerlen() - 8));
a801 16
size_t
pingerlen(void)
{
	size_t l;

	if (options & F_FQDN)
		l = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
	else if (options & F_NODEADDR)
		l = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
	else if (options & F_SUPTYPES)
		l = ICMP6_NIQLEN;
	else
		l = ICMP6ECHOLEN + datalen;

	return l;
}
a807 1
	struct icmp6_nodeinfo *nip;
a813 1
	nip = (struct icmp6_nodeinfo *)outpack;
d819 23
a841 64
	if (options & F_FQDN) {
		icp->icmp6_type = ICMP6_NI_QUERY;
		icp->icmp6_code = ICMP6_NI_SUBJ_IPV6;
		nip->ni_qtype = htons(NI_QTYPE_FQDN);
		nip->ni_flags = htons(0);

		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);

		memcpy(&outpack[ICMP6_NIQLEN], &dst.sin6_addr,
		    sizeof(dst.sin6_addr));
		cc = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
		datalen = 0;
	} else if (options & F_NODEADDR) {
		icp->icmp6_type = ICMP6_NI_QUERY;
		icp->icmp6_code = ICMP6_NI_SUBJ_IPV6;
		nip->ni_qtype = htons(NI_QTYPE_NODEADDR);
		nip->ni_flags = naflags;

		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);

		memcpy(&outpack[ICMP6_NIQLEN], &dst.sin6_addr,
		    sizeof(dst.sin6_addr));
		cc = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
		datalen = 0;
	} else if (options & F_SUPTYPES) {
		icp->icmp6_type = ICMP6_NI_QUERY;
		icp->icmp6_code = ICMP6_NI_SUBJ_FQDN;	/*empty*/
		nip->ni_qtype = htons(NI_QTYPE_SUPTYPES);
		/* we support compressed bitmap */
		nip->ni_flags = NI_SUPTYPE_FLAG_COMPRESS;

		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);
		cc = ICMP6_NIQLEN;
		datalen = 0;
	} else {
		icp->icmp6_type = ICMP6_ECHO_REQUEST;
		icp->icmp6_code = 0;
		icp->icmp6_id = htons(ident);
		icp->icmp6_seq = ntohs(seq);
		if (timing) {
			SIPHASH_CTX ctx;
			struct timespec ts;
			struct payload payload;
			struct tv64 *tv64 = &payload.tv64;

			if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
				err(1, "clock_gettime(CLOCK_MONOTONIC)");
			tv64->tv64_sec = htobe64((u_int64_t)ts.tv_sec +
			    tv64_offset.tv64_sec);
			tv64->tv64_nsec = htobe64((u_int64_t)ts.tv_nsec +
			    tv64_offset.tv64_nsec);

			SipHash24_Init(&ctx, &mac_key);
			SipHash24_Update(&ctx, tv64, sizeof(*tv64));
			SipHash24_Update(&ctx, &ident, sizeof(ident));
			SipHash24_Update(&ctx,
			    &icp->icmp6_seq, sizeof(icp->icmp6_seq));
			SipHash24_Final(&payload.mac, &ctx);
d843 2
a844 4
			memcpy(&outpack[ICMP6ECHOLEN],
			    &payload, sizeof(payload));
		}
		cc = ICMP6ECHOLEN + datalen;
d846 1
a877 71
int
mynireply(const struct icmp6_nodeinfo *nip)
{
	if (memcmp(nip->icmp6_ni_nonce + sizeof(u_int16_t),
	    nonce + sizeof(u_int16_t),
	    sizeof(nonce) - sizeof(u_int16_t)) == 0)
		return 1;
	else
		return 0;
}

char *
dnsdecode(const u_char **sp, const u_char *ep, const u_char *base,
    char *buf, size_t bufsiz)
{
	int i;
	const u_char *cp;
	char cresult[MAXDNAME + 1];
	const u_char *comp;
	int l;

	cp = *sp;
	*buf = '\0';

	if (cp >= ep)
		return NULL;
	while (cp < ep) {
		i = *cp;
		if (i == 0 || cp != *sp) {
			if (strlcat((char *)buf, ".", bufsiz) >= bufsiz)
				return NULL;	/*result overrun*/
		}
		if (i == 0)
			break;
		cp++;

		if ((i & 0xc0) == 0xc0 && cp - base > (i & 0x3f)) {
			/* DNS compression */
			if (!base)
				return NULL;

			comp = base + (i & 0x3f);
			if (dnsdecode(&comp, cp, base, cresult,
			    sizeof(cresult)) == NULL)
				return NULL;
			if (strlcat(buf, cresult, bufsiz) >= bufsiz)
				return NULL;	/*result overrun*/
			break;
		} else if ((i & 0x3f) == i) {
			if (i > ep - cp)
				return NULL;	/*source overrun*/
			while (i-- > 0 && cp < ep) {
				l = snprintf(cresult, sizeof(cresult),
				    isprint((unsigned char)*cp) ? "%c" : "\\%03o",
				    *cp & 0xff);
				if (l >= sizeof(cresult) || l < 0)
					return NULL;
				if (strlcat(buf, cresult, bufsiz) >= bufsiz)
					return NULL;	/*result overrun*/
				cp++;
			}
		} else
			return NULL;	/*invalid label*/
	}
	if (i != 0)
		return NULL;	/*not terminated*/
	cp++;
	*sp = cp;
	return buf;
}

a891 1
	struct icmp6_nodeinfo *ni;
a902 2
	size_t off;
	int oldfqdn;
a903 1
	char dnsname[MAXDNAME + 1];
a923 2
	ni = (struct icmp6_nodeinfo *)buf;
	off = 0;
d1014 1
a1014 1
			cp = buf + off + ICMP6ECHOLEN + ICMP6ECHOTMLEN;
a1029 150
	} else if (icp->icmp6_type == ICMP6_NI_REPLY &&
	    cc >= sizeof(*ni) && mynireply(ni)) {
		seq = ntohs(*(u_int16_t *)ni->icmp6_ni_nonce);
		++nreceived;
		if (TST(seq % mx_dup_ck)) {
			++nrepeats;
			--nreceived;
			dupflag = 1;
		} else {
			SET(seq % mx_dup_ck);
			dupflag = 0;
		}

		if (options & F_QUIET)
			return;

		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));

		switch (ntohs(ni->ni_code)) {
		case ICMP6_NI_SUCCESS:
			break;
		case ICMP6_NI_REFUSED:
			printf("refused, type 0x%x", ntohs(ni->ni_type));
			goto fqdnend;
		case ICMP6_NI_UNKNOWN:
			printf("unknown, type 0x%x", ntohs(ni->ni_type));
			goto fqdnend;
		default:
			printf("unknown code 0x%x, type 0x%x",
			    ntohs(ni->ni_code), ntohs(ni->ni_type));
			goto fqdnend;
		}

		switch (ntohs(ni->ni_qtype)) {
		case NI_QTYPE_NOOP:
			printf("NodeInfo NOOP");
			break;
		case NI_QTYPE_SUPTYPES:
			pr_suptypes(ni, end - (u_char *)ni);
			break;
		case NI_QTYPE_NODEADDR:
			pr_nodeaddr(ni, end - (u_char *)ni);
			break;
		case NI_QTYPE_FQDN:
		default:	/* XXX: for backward compatibility */
			cp = (u_char *)ni + ICMP6_NIRLEN;
			if (off + ICMP6_NIRLEN < cc &&
			    buf[off + ICMP6_NIRLEN] ==
			    cc - off - ICMP6_NIRLEN - 1)
				oldfqdn = 1;
			else
				oldfqdn = 0;
			if (oldfqdn) {
				cp++;	/* skip length */
				while (cp < end) {
					safeputc(*cp & 0xff);
					cp++;
				}
			} else {
				i = 0;
				while (cp < end) {
					if (dnsdecode((const u_char **)&cp, end,
					    (const u_char *)(ni + 1), dnsname,
					    sizeof(dnsname)) == NULL) {
						printf("???");
						break;
					}
					/*
					 * name-lookup special handling for
					 * truncated name
					 */
					if (cp + 1 <= end && !*cp &&
					    strlen(dnsname) > 0) {
						dnsname[strlen(dnsname) - 1] = '\0';
						cp++;
					}
					printf("%s%s", i > 0 ? "," : "",
					    dnsname);
				}
			}
			if (options & F_VERBOSE) {
				int32_t ttl;
				int comma = 0;

				(void)printf(" (");	/*)*/

				switch (ni->ni_code) {
				case ICMP6_NI_REFUSED:
					(void)printf("refused");
					comma++;
					break;
				case ICMP6_NI_UNKNOWN:
					(void)printf("unknown qtype");
					comma++;
					break;
				}

				if ((end - (u_char *)ni) < ICMP6_NIRLEN) {
					/* case of refusion, unknown */
					/*(*/
					putchar(')');
					goto fqdnend;
				}
				ttl = (int32_t)ntohl(*(u_long *)
				    &buf[off+ICMP6ECHOLEN+8]);
				if (comma)
					printf(",");
				if (!(ni->ni_flags & NI_FQDN_FLAG_VALIDTTL)) {
					(void)printf("TTL=%d:meaningless",
					    (int)ttl);
				} else {
					if (ttl < 0) {
						(void)printf("TTL=%d:invalid",
						   ttl);
					} else
						(void)printf("TTL=%d", ttl);
				}
				comma++;

				if (oldfqdn) {
					if (comma)
						printf(",");
					printf("03 draft");
					comma++;
				} else {
					cp = (u_char *)ni + ICMP6_NIRLEN;
					if (cp == end) {
						if (comma)
							printf(",");
						printf("no name");
						comma++;
					}
				}

				if (off + ICMP6_NIRLEN < cc &&
				    buf[off + ICMP6_NIRLEN] !=
				    cc - off - ICMP6_NIRLEN - 1 && oldfqdn) {
					if (comma)
						printf(",");
					(void)printf("invalid namelen:%d/%lu",
					    buf[off + ICMP6_NIRLEN],
					    (u_long)cc - off - ICMP6_NIRLEN - 1);
					comma++;
				}
				/*(*/
				putchar(')');
			}
		fqdnend:
			;
		}
a1205 130
/* ni->qtype must be SUPTYPES */
void
pr_suptypes(struct icmp6_nodeinfo *ni, size_t nilen)
{
	size_t clen;
	u_int32_t v;
	const u_char *cp, *end;
	u_int16_t cur;
	struct cbit {
		u_int16_t words;	/*32bit count*/
		u_int16_t skip;
	} cbit;
#define MAXQTYPES	(1 << 16)
	size_t off;
	int b;

	cp = (u_char *)(ni + 1);
	end = ((u_char *)ni) + nilen;
	cur = 0;
	b = 0;

	printf("NodeInfo Supported Qtypes");
	if (options & F_VERBOSE) {
		if (ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS)
			printf(", compressed bitmap");
		else
			printf(", raw bitmap");
	}

	while (cp < end) {
		clen = (size_t)(end - cp);
		if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) == 0) {
			if (clen == 0 || clen > MAXQTYPES / 8 ||
			    clen % sizeof(v)) {
				printf("???");
				return;
			}
		} else {
			if (clen < sizeof(cbit) || clen % sizeof(v))
				return;
			memcpy(&cbit, cp, sizeof(cbit));
			if (sizeof(cbit) + ntohs(cbit.words) * sizeof(v) >
			    clen)
				return;
			cp += sizeof(cbit);
			clen = ntohs(cbit.words) * sizeof(v);
			if (cur + clen * 8 + (u_long)ntohs(cbit.skip) * 32 >
			    MAXQTYPES)
				return;
		}

		for (off = 0; off < clen; off += sizeof(v)) {
			memcpy(&v, cp + off, sizeof(v));
			v = (u_int32_t)ntohl(v);
			b = pr_bitrange(v, (int)(cur + off * 8), b);
		}
		/* flush the remaining bits */
		b = pr_bitrange(0, (int)(cur + off * 8), b);

		cp += clen;
		cur += clen * 8;
		if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) != 0)
			cur += ntohs(cbit.skip) * 32;
	}
}

/* ni->qtype must be NODEADDR */
void
pr_nodeaddr(struct icmp6_nodeinfo *ni, int nilen)
{
	u_char *cp = (u_char *)(ni + 1);
	char ntop_buf[INET6_ADDRSTRLEN];
	int withttl = 0;

	nilen -= sizeof(struct icmp6_nodeinfo);

	if (options & F_VERBOSE) {
		switch (ni->ni_code) {
		case ICMP6_NI_REFUSED:
			(void)printf("refused");
			break;
		case ICMP6_NI_UNKNOWN:
			(void)printf("unknown qtype");
			break;
		}
		if (ni->ni_flags & NI_NODEADDR_FLAG_TRUNCATE)
			(void)printf(" truncated");
	}
	putchar('\n');
	if (nilen <= 0)
		printf("  no address\n");

	/*
	 * In icmp-name-lookups 05 and later, TTL of each returned address
	 * is contained in the response. We try to detect the version
	 * by the length of the data, but note that the detection algorithm
	 * is incomplete. We assume the latest draft by default.
	 */
	if (nilen % (sizeof(u_int32_t) + sizeof(struct in6_addr)) == 0)
		withttl = 1;
	while (nilen >= sizeof(struct in6_addr)) {
		u_int32_t ttl = (u_int32_t)ntohl(*(u_int32_t *)cp);

		if (withttl) {
			cp += sizeof(u_int32_t);
			nilen -= sizeof(u_int32_t);
		}

		if (nilen < sizeof(struct in6_addr) || inet_ntop(AF_INET6,
		    cp, ntop_buf, sizeof(ntop_buf)) == NULL)
			strncpy(ntop_buf, "?", sizeof(ntop_buf));
		printf("  %s", ntop_buf);
		if (withttl) {
			if (ttl == 0xffffffff) {
				/*
				 * XXX: can this convention be applied to all
				 * type of TTL (i.e. non-ND TTL)?
				 */
				printf("(TTL=infty)");
			}
			else
				printf("(TTL=%u)", ttl);
		}
		putchar('\n');

		nilen -= sizeof(struct in6_addr);
		cp += sizeof(struct in6_addr);
	}
}

a1362 13
/*subject type*/
static const char *niqcode[] = {
	"IPv6 address",
	"DNS label",	/*or empty*/
	"IPv4 address",
};

/*result code*/
static const char *nircode[] = {
	"Success", "Refused", "Unknown",
};


a1371 4
	struct icmp6_nodeinfo *ni;
	char dnsname[MAXDNAME + 1];
	const u_char *cp;
	size_t l;
a1480 103
	case ICMP6_NI_QUERY:
		(void)printf("Node Information Query");
		/* XXX ID + Seq + Data */
		ni = (struct icmp6_nodeinfo *)icp;
		l = end - (u_char *)(ni + 1);
		printf(", ");
		switch (ntohs(ni->ni_qtype)) {
		case NI_QTYPE_NOOP:
			(void)printf("NOOP");
			break;
		case NI_QTYPE_SUPTYPES:
			(void)printf("Supported qtypes");
			break;
		case NI_QTYPE_FQDN:
			(void)printf("DNS name");
			break;
		case NI_QTYPE_NODEADDR:
			(void)printf("nodeaddr");
			break;
		case NI_QTYPE_IPV4ADDR:
			(void)printf("IPv4 nodeaddr");
			break;
		default:
			(void)printf("unknown qtype");
			break;
		}
		if (options & F_VERBOSE) {
			switch (ni->ni_code) {
			case ICMP6_NI_SUBJ_IPV6:
				if (l == sizeof(struct in6_addr) &&
				    inet_ntop(AF_INET6, ni + 1, ntop_buf,
				    sizeof(ntop_buf)) != NULL) {
					(void)printf(", subject=%s(%s)",
					    niqcode[ni->ni_code], ntop_buf);
				} else {
#if 1
					/* backward compat to -W */
					(void)printf(", oldfqdn");
#else
					(void)printf(", invalid");
#endif
				}
				break;
			case ICMP6_NI_SUBJ_FQDN:
				if (end == (u_char *)(ni + 1)) {
					(void)printf(", no subject");
					break;
				}
				printf(", subject=%s", niqcode[ni->ni_code]);
				cp = (const u_char *)(ni + 1);
				if (dnsdecode(&cp, end, NULL, dnsname,
				    sizeof(dnsname)) != NULL)
					printf("(%s)", dnsname);
				else
					printf("(invalid)");
				break;
			case ICMP6_NI_SUBJ_IPV4:
				if (l == sizeof(struct in_addr) &&
				    inet_ntop(AF_INET, ni + 1, ntop_buf,
				    sizeof(ntop_buf)) != NULL) {
					(void)printf(", subject=%s(%s)",
					    niqcode[ni->ni_code], ntop_buf);
				} else
					(void)printf(", invalid");
				break;
			default:
				(void)printf(", invalid");
				break;
			}
		}
		break;
	case ICMP6_NI_REPLY:
		(void)printf("Node Information Reply");
		/* XXX ID + Seq + Data */
		ni = (struct icmp6_nodeinfo *)icp;
		printf(", ");
		switch (ntohs(ni->ni_qtype)) {
		case NI_QTYPE_NOOP:
			(void)printf("NOOP");
			break;
		case NI_QTYPE_SUPTYPES:
			(void)printf("Supported qtypes");
			break;
		case NI_QTYPE_FQDN:
			(void)printf("DNS name");
			break;
		case NI_QTYPE_NODEADDR:
			(void)printf("nodeaddr");
			break;
		case NI_QTYPE_IPV4ADDR:
			(void)printf("IPv4 nodeaddr");
			break;
		default:
			(void)printf("unknown qtype");
			break;
		}
		if (options & F_VERBOSE) {
			if (ni->ni_code >= sizeof(nircode) / sizeof(nircode[0]))
				printf(", invalid");
			else
				printf(", %s", nircode[ni->ni_code]);
		}
		break;
a1645 44
char *
nigroup(char *name)
{
	char *p;
	char *q;
	MD5_CTX ctxt;
	u_int8_t digest[16];
	u_int8_t c;
	size_t l;
	char hbuf[NI_MAXHOST];
	struct in6_addr in6;

	p = strchr(name, '.');
	if (!p)
		p = name + strlen(name);
	l = p - name;
	if (l > 63 || l > sizeof(hbuf) - 1)
		return NULL;	/*label too long*/
	strncpy(hbuf, name, l);
	hbuf[(int)l] = '\0';

	for (q = name; *q; q++) {
		if (isupper(*(unsigned char *)q))
			*q = tolower(*(unsigned char *)q);
	}

	/* generate 8 bytes of pseudo-random value. */
	memset(&ctxt, 0, sizeof(ctxt));
	MD5Init(&ctxt);
	c = l & 0xff;
	MD5Update(&ctxt, &c, sizeof(c));
	MD5Update(&ctxt, (unsigned char *)name, l);
	MD5Final(digest, &ctxt);

	if (inet_pton(AF_INET6, "ff02::2:0000:0000", &in6) != 1)
		return NULL;	/*XXX*/
	memcpy(&in6.s6_addr[12], digest, 4);

	if (inet_ntop(AF_INET6, &in6, hbuf, sizeof(hbuf)) == NULL)
		return NULL;

	return strdup(hbuf);
}

d1652 2
a1653 2
	    "Nnqv"
	    "] [-a addrtype] [-c count] [-g gateway]\n\t"
@


1.123
log
@To specify a source address ping uses -I while ping6 uses -S. Switch
ping6 -I to the ping-alike semantics.
sthen@@ thinks this is OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.122 2015/10/13 16:26:54 florian Exp $	*/
d270 1
a270 1
	    "a:c:dEefHg:h:I:i:l:mnNp:qS:s:tvV:w")) != -1) {
a276 1
			options |= F_NODEADDR;
d280 1
d285 1
d288 3
d293 1
d296 3
d301 1
d306 1
d310 1
a425 4
		case 't':
			options &= ~F_NOUSERDATA;
			options |= F_SUPTYPES;
			break;
a438 4
		case 'w':
			options &= ~F_NOUSERDATA;
			options |= F_FQDN;
			break;
d2320 1
a2320 1
	    "Nnqtvw"
@


1.122
log
@Remove -b flag and let ping6 set the socket buffer size automatically
like ping.
Suggested by deraadt@@, OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.121 2015/10/12 18:32:18 deraadt Exp $	*/
a148 1
#define F_INTERFACE	0x2000
d249 1
a249 1
	char *e, *target, *ifname = NULL, *gateway = NULL;
a252 1
	int usepktinfo = 0;
d345 17
a361 3
			ifname = optarg;
			options |= F_INTERFACE;
			usepktinfo++;
a408 19
		case 'S':
			memset(&hints, 0, sizeof(struct addrinfo));
			hints.ai_flags = AI_NUMERICHOST; /* allow hostname? */
			hints.ai_family = AF_INET6;
			hints.ai_socktype = SOCK_RAW;
			hints.ai_protocol = IPPROTO_ICMPV6;

			error = getaddrinfo(optarg, NULL, &hints, &res0);
			if (error)
				errx(1, "invalid source address: %s",
				     gai_strerror(error));

			if (res0->ai_family != AF_INET6 || res0->ai_addrlen !=
			    sizeof(src))
				errx(1, "invalid source address");
			memcpy(&src, res0->ai_addr, sizeof(src));
			freeaddrinfo(res0);
			options |= F_SRCADDR;
			break;
a628 4
	/* Specify the outgoing interface and/or the source address */
	if (usepktinfo)
		ip6optlen += CMSG_SPACE(sizeof(struct in6_pktinfo));

a640 8
	if (usepktinfo) {
		pktinfo = (struct in6_pktinfo *)(CMSG_DATA(scmsgp));
		memset(pktinfo, 0, sizeof(*pktinfo));
		scmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
		scmsgp->cmsg_level = IPPROTO_IPV6;
		scmsgp->cmsg_type = IPV6_PKTINFO;
		scmsgp = CMSG_NXTHDR(&smsghdr, scmsgp);
	}
a641 6
	/* set the outgoing interface */
	if (ifname) {
		/* pktinfo must have already been allocated */
		if ((pktinfo->ipi6_ifindex = if_nametoindex(ifname)) == 0)
			errx(1, "%s: invalid interface name", ifname);
	}
d2319 2
a2320 2
	    "[-h hoplimit] [-I interface] [-i wait] [-l preload] [-p pattern]"
	    "\n\t[-S sourceaddr] [-s packetsize] [-V rtable] host\n");
@


1.121
log
@deprecate & remove -W option; ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.120 2015/10/09 01:37:06 deraadt Exp $	*/
d247 2
a248 1
	int ch, i, packlen, preload, optval, error;
a253 2
	u_long lsockbufsize;
	int sockbufsize = 0;
d272 1
a272 1
	    "a:b:c:dEefHg:h:I:i:l:mnNp:qS:s:tvV:w")) != -1) {
a310 9
		case 'b':
			errno = 0;
			e = NULL;
			lsockbufsize = strtoul(optarg, &e, 10);
			sockbufsize = lsockbufsize;
			if (errno || !*optarg || *e ||
			    sockbufsize != lsockbufsize)
				errx(1, "invalid socket buffer size");
			break;
d561 18
a720 23
	if (sockbufsize) {
		if (datalen > sockbufsize)
			warnx("you need -b to increase socket buffer size");
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &sockbufsize,
		    (socklen_t)sizeof(sockbufsize)) < 0)
			err(1, "setsockopt(SO_SNDBUF)");
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &sockbufsize,
		    (socklen_t)sizeof(sockbufsize)) < 0)
			err(1, "setsockopt(SO_RCVBUF)");
	} else {
		if (datalen > 8 * 1024)	/*XXX*/
			warnx("you need -b to increase socket buffer size");
		/*
		 * When pinging the broadcast address, you can get a lot of
		 * answers. Doing something so evil is useful if you are trying
		 * to stress the ethernet, or just want to fill the arp cache
		 * to get some stuff for /etc/ethers.
		 */
		optval = 48 * 1024;
		setsockopt(s, SOL_SOCKET, SO_RCVBUF, &optval,
		    (socklen_t)sizeof(optval));
	}

d2343 1
a2343 1
	    "] [-a addrtype] [-b bufsiz] [-c count] [-g gateway]\n\t"
@


1.120
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.119 2015/10/04 04:56:50 deraadt Exp $	*/
a151 1
#define F_FQDNOLD	0x20000
d156 1
a156 1
#define F_NOUSERDATA	(F_NODEADDR | F_FQDN | F_FQDNOLD | F_SUPTYPES)
d273 1
a273 1
	    "a:b:c:dEefHg:h:I:i:l:mnNp:qS:s:tvV:wW")) != -1) {
a452 4
		case 'W':
			options &= ~F_NOUSERDATA;
			options |= F_FQDNOLD;
			break;
d606 2
a607 2
		if ((options & F_FQDN) || (options & F_FQDNOLD) ||
		    (options & F_NODEADDR) || (options & F_SUPTYPES))
a932 2
	else if (options & F_FQDNOLD)
		l = ICMP6_NIQLEN;
a974 13
	} else if (options & F_FQDNOLD) {
		/* packet format in 03 draft - no Subject data on queries */
		icp->icmp6_type = ICMP6_NI_QUERY;
		icp->icmp6_code = 0;	/* code field is always 0 */
		nip->ni_qtype = htons(NI_QTYPE_FQDN);
		nip->ni_flags = htons(0);

		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);

		cc = ICMP6_NIQLEN;
		datalen = 0;
d2357 1
a2357 1
	    "NnqtvWw"
@


1.119
log
@Repair tame() error check to be == -1
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.118 2015/10/03 00:53:13 deraadt Exp $	*/
d750 2
a751 2
		if (tame("stdio inet dns", NULL) == -1)
			err(1, "tame");
d753 2
a754 2
		if (tame("stdio inet", NULL) == -1)
			err(1, "tame");
@


1.118
log
@ping6 is a setuid root priv-drop which holds a sockraw.  we can tame it
substantially with "stdio inet", plus "dns" if the -n option is missing.
a successful exploit against it then cannot create files, or perform a
variety of other operations, as described in the tame(2) man page.

ping6 is a bit trickier than ping, because it uses recvmsg() with CMSG
types of IPV6_HOPOPTS, IPV6_DSTOPTS, IPV6_RTHDRDSTOPTS, IPV6_RTHDR.
there is further work to do in the kernel, with claudio!

work with florian a while back, which involved hoisting lots of initization
code upwards.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.117 2015/09/30 12:21:46 deraadt Exp $	*/
d753 1
a753 1
		if (tame("stdio inet", NULL) != 0)
@


1.117
log
@remove old self-kill() in the signal handler.  must predate the
signal handler audit.  found while adapting ping6 to tame.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.116 2015/09/16 10:12:03 florian Exp $	*/
d748 8
@


1.116
log
@Some cleanup from dhill AT mindcry.org, thanks!
- remove unused defines
- use socklen_t for getnameinfo
no object change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.115 2015/09/12 11:52:23 naddy Exp $	*/
a1857 3

	(void)signal(SIGINT, SIG_DFL);
	(void)kill(getpid(), SIGINT);
@


1.115
log
@typo that breaks the build
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.114 2015/09/12 09:44:08 tobias Exp $	*/
a133 1
#define	NROUTES		9		/* number of record route slots */
a144 1
#define	F_RROUTE	0x0020
a154 1
#define F_NOMINMTU	0x100000
a159 2
#define IN6LEN		sizeof(struct in6_addr)
#define SA6LEN		sizeof(struct sockaddr_in6)
d222 1
a222 1
const char *pr_addr(struct sockaddr *, int);
d1163 1
a1163 1
	int fromlen;
d2195 1
a2195 1
pr_addr(struct sockaddr *addr, int addrlen)
@


1.114
log
@Avoid out of boundary access on invalid or short packet reads.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.113 2015/09/09 14:37:07 claudio Exp $	*/
d1354 2
a1355 1
			if (off + ICMP_NIRLEN < cc && buf[off + ICMP6_NIRLEN] ==
@


1.113
log
@Cleanup the iov handling in ping6. Use the global iov instead of a local
version which is then added to a global struct msghdr. Issue found by
Michael McConville. OK florian@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.112 2015/09/01 19:53:23 florian Exp $	*/
d1219 5
d1308 2
a1309 1
	} else if (icp->icmp6_type == ICMP6_NI_REPLY && mynireply(ni)) {
d1354 1
a1354 1
			if (buf[off + ICMP6_NIRLEN] ==
d1441 2
a1442 1
				if (buf[off + ICMP6_NIRLEN] !=
@


1.112
log
@Display the correct source address when using a non-default routing
table.
Problem reported on bugs@@ and diff from phil AT unita.com.au, thanks!
OK phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.111 2015/08/31 16:42:33 florian Exp $	*/
d211 1
a211 1
char *scmsg = 0;
a275 4
	/* just to be sure */
	memset(&smsghdr, 0, sizeof(smsghdr));
	memset(&smsgiov, 0, sizeof(smsgiov));

d786 1
a786 1
		struct iovec	iov[2];
a950 1
	struct iovec iov[2];
d1051 3
a1053 4
	memset(&iov, 0, sizeof(iov));
	iov[0].iov_base = (caddr_t)outpack;
	iov[0].iov_len = cc;
	smsghdr.msg_iov = iov;
@


1.111
log
@remove unused define; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.110 2015/08/30 18:48:45 florian Exp $	*/
d266 1
a266 1
	u_int rtableid;
d712 5
@


1.110
log
@Clean up getaddrinfo(3) calls to make them look like the canonical
example from the man page. While there was nothing wrong this pattern
makes it easier to figure that out.
While here be more paranoid how much we memcpy(3).
Looks clean to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.109 2015/08/30 18:27:03 florian Exp $	*/
a165 2

#define SIN6(s)	((struct sockaddr_in6 *)(s))
@


1.109
log
@Remove RH0 support, it was deprecated in RFC 5095 some time ago and
you couldn't send packets anyway since our stack drops them
unconditionally.
reasoning is sound to deraadt@@, OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.108 2015/05/02 17:19:42 florian Exp $	*/
a177 1
struct addrinfo *res;
a179 1
socklen_t srclen;
d251 1
d255 1
a255 1
	int ch, i, packlen, preload, optval, ret_ga;
d426 2
a427 2
			ret_ga = getaddrinfo(optarg, NULL, &hints, &res);
			if (ret_ga) {
d429 7
a435 9
				     gai_strerror(ret_ga));
			}
			/*
			 * res->ai_family must be AF_INET6 and res->ai_addrlen
			 * must be sizeof(src).
			 */
			memcpy(&src, res->ai_addr, res->ai_addrlen);
			srclen = res->ai_addrlen;
			freeaddrinfo(res);
d502 7
a508 6
	ret_ga = getaddrinfo(target, NULL, &hints, &res);
	if (ret_ga)
		errx(1, "%s", gai_strerror(ret_ga));
	if (res->ai_canonname)
		hostname = res->ai_canonname;
	else
d510 3
a512 2

	if (!res->ai_addr)
d514 1
d516 1
a516 1
	memcpy(&dst, res->ai_addr, res->ai_addrlen);
d520 1
a520 1
	    bind(s, (struct sockaddr *)&src, srclen) != 0) {
d526 8
a533 2
		struct addrinfo ghints, *gres;
		int error;
d535 1
a535 11
		memset(&ghints, 0, sizeof(ghints));
		ghints.ai_family = AF_INET6;
		ghints.ai_socktype = SOCK_RAW;
		ghints.ai_protocol = IPPROTO_ICMPV6;

		error = getaddrinfo(gateway, NULL, &ghints, &gres);
		if (error) {
			errx(1, "getaddrinfo for the gateway %s: %s",
			     gateway, gai_strerror(error));
		}
		if (gres->ai_next && (options & F_VERBOSE))
d538 2
a539 2
		if (setsockopt(s, IPPROTO_IPV6, IPV6_NEXTHOP,
		    gres->ai_addr, gres->ai_addrlen)) {
a540 1
		}
d542 1
a542 1
		freeaddrinfo(gres);
@


1.108
log
@Use IPV6_MAXHLIM instead of 255; pointed out by bluhm@@
No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.107 2015/05/02 00:32:03 krw Exp $	*/
a265 1
	struct ip6_rthdr *rthdr = NULL;
a266 1
	size_t rthlen;
d486 2
a487 8
	if (argc > 1) {
		rthlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, argc - 1);
		if (rthlen == 0) {
			errx(1, "too many intermediate hops");
			/*NOTREACHED*/
		}
		ip6optlen += CMSG_SPACE(rthlen);
	}
a688 34
	if (argc > 1) {	/* some intermediate addrs are specified */
		int hops, error;
		int rthdrlen;

		rthdrlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, argc - 1);
		scmsgp->cmsg_len = CMSG_LEN(rthdrlen);
		scmsgp->cmsg_level = IPPROTO_IPV6;
		scmsgp->cmsg_type = IPV6_RTHDR;
		rthdr = (struct ip6_rthdr *)CMSG_DATA(scmsgp);
		rthdr = inet6_rth_init((void *)rthdr, rthdrlen,
		    IPV6_RTHDR_TYPE_0, argc - 1);
		if (rthdr == NULL)
			errx(1, "can't initialize rthdr");

		for (hops = 0; hops < argc - 1; hops++) {
			struct addrinfo *iaip;

			if ((error = getaddrinfo(argv[hops], NULL, &hints,
			    &iaip)))
				errx(1, "%s", gai_strerror(error));
			if (SIN6(iaip->ai_addr)->sin6_family != AF_INET6)
				errx(1,
				    "bad addr family of an intermediate addr");

			if (inet6_rth_add(rthdr,
			    &(SIN6(iaip->ai_addr))->sin6_addr))
				errx(1, "can't add an intermediate node");
			freeaddrinfo(iaip);
		}


		scmsgp = CMSG_NXTHDR(&smsghdr, scmsgp);
	}

a719 5
		if (rthdr &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_RTHDR,
		    (void *)rthdr, (rthdr->ip6r_len + 1) << 3))
			err(1, "UDP setsockopt(IPV6_RTHDR)");

d2380 1
a2380 2
	    "\n\t[-S sourceaddr] [-s packetsize] [-V rtable] [hops ...]"
	    " host\n");
@


1.107
log
@Use strtonum() when parsing argument list, as ping(8) does.  Give
or take a cast. Tweak error messages to also be consistant with
ping(8).

Change lower bound of '-h' to 0 from -1 at the request of florian@@.

Tweaks and suggestions from, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.106 2015/04/20 00:46:32 dlg Exp $	*/
d367 1
a367 1
			hoplimit = strtonum(optarg, 0, 255, &errstr);
@


1.106
log
@port src/sbin/ping/ping.c r1.119 and r1.121 to ping6:

> add a mac to the timestamp payload and calculate it with siphash.
>
> this lets us have some confidence that the timestamp hasnt been
> damaged or tampered with in transit.
>
> discussed with jp aumasson
> ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.105 2015/03/23 10:36:24 dlg Exp $	*/
d337 1
a337 2
			npackets = (unsigned long)strtonum(optarg, 0,
			    INT_MAX, &errstr);
d367 3
a369 6
			hoplimit = strtol(optarg, &e, 10);
			if (*optarg == '\0' || *e != '\0')
				errx(1, "illegal hoplimit %s", optarg);
			if (255 < hoplimit || hoplimit < -1)
				errx(1,
				    "illegal hoplimit -- %s", optarg);
d401 4
a404 3
			preload = strtol(optarg, &e, 10);
			if (preload < 0 || *optarg == '\0' || *e != '\0')
				errx(1, "illegal preload value -- %s", optarg);
d444 4
a447 8
			datalen = strtol(optarg, &e, 10);
			if (datalen <= 0 || *optarg == '\0' || *e != '\0')
				errx(1, "illegal datalen value -- %s", optarg);
			if (datalen > MAXDATALEN) {
				errx(1,
				    "datalen value too large, maximum is %d",
				    MAXDATALEN);
			}
d457 2
a458 2
			rtableid = (unsigned int)strtonum(optarg, 0,
			    RT_TABLEID_MAX, &errstr);
d460 2
a461 2
				errx(1, "rtable value is %s: %s",
				    errstr, optarg);
@


1.105
log
@port src/sbin/ping/ping.c r1.118 to ping6:

> obfuscate the monotonic clock values we put on the wire by offsetting
> them with a random value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.104 2015/03/23 10:09:02 dlg Exp $	*/
d112 1
d119 5
d127 1
a127 1
#define ICMP6ECHOTMLEN sizeof(struct tv64)
d207 1
d588 1
a588 1
		if (datalen >= sizeof(struct tv64)) {
d815 1
d1085 1
d1087 2
a1088 1
			struct tv64 tv64;
d1092 1
a1092 1
			tv64.tv64_sec = htobe64((u_int64_t)ts.tv_sec +
d1094 1
a1094 1
			tv64.tv64_nsec = htobe64((u_int64_t)ts.tv_nsec +
d1096 10
a1105 1
			memcpy(&outpack[ICMP6ECHOLEN], &tv64, sizeof(tv64));
d1234 2
a1235 1
	struct tv64 tv64;
d1278 20
a1297 2
			memcpy(&tv64, icp + 1, sizeof(tv64));
			tp.tv_sec = betoh64(tv64.tv64_sec) -
d1299 1
a1299 1
			tp.tv_nsec = betoh64(tv64.tv64_nsec) -
d2369 1
a2369 1
		    kk <= MAXDATALEN - (8 + sizeof(struct tv64) + ii);
@


1.104
log
@port src/sbin/ping/ping.c r1.116 to ping6:

> bump the size of the time types on the wire to 64bit, and use nsec
> instead of usec so its easier to translate to/from timespecs instead
> of timevals.

this raises the size of the default ping payload from 16 to 24bytes,
but claudio@@ thinks we'll be fine with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.103 2015/03/12 00:30:38 dlg Exp $	*/
d200 1
d807 2
d1082 4
a1085 2
			tv64.tv64_sec = htobe64(ts.tv_sec);
			tv64.tv64_nsec = htobe64(ts.tv_nsec);
d1259 4
a1262 2
			tp.tv_sec = betoh64(tv64.tv64_sec);
			tp.tv_nsec = betoh64(tv64.tv64_nsec);
@


1.103
log
@replace bcopy with memcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.102 2015/03/11 03:38:56 dlg Exp $	*/
a85 1
#include <sys/time.h>
d102 1
d113 3
a115 3
struct tv32 {
	u_int32_t tv32_sec;
	u_int32_t tv32_usec;
d121 1
a121 1
#define ICMP6ECHOTMLEN sizeof(struct tv32)
a238 1
void	 tvsub(struct timeval *, struct timeval *);
d580 1
a580 1
		if (datalen >= sizeof(struct tv32)) {
d1075 1
a1075 2
			struct timeval tv;
			struct tv32 tv32;
d1079 3
a1081 4
			TIMESPEC_TO_TIMEVAL(&tv, &ts);
			tv32.tv32_sec = htonl(tv.tv_sec);	/* XXX 2038 */
			tv32.tv32_usec = htonl(tv.tv_usec);
			memcpy(&outpack[ICMP6ECHOLEN], &tv32, sizeof(tv32));
d1209 2
a1210 3
	struct timespec ts;
	struct timeval tv, tp;
	struct tv32 tv32;
a1219 1
	TIMESPEC_TO_TIMEVAL(&tv, &ts);
d1253 6
a1258 6
			memcpy(&tv32, icp + 1, sizeof(tv32));
			tp.tv_sec = ntohl(tv32.tv32_sec);
			tp.tv_usec = ntohl(tv32.tv32_usec);
			tvsub(&tv, &tp);
			triptime = ((double)tv.tv_sec) * 1000.0 +
			    ((double)tv.tv_usec) / 1000.0;
a1864 15
 * tvsub --
 *	Subtract 2 timeval structs:  out = out - in.  Out is assumed to
 * be >= in.
 */
void
tvsub(struct timeval *out, struct timeval *in)
{
	if ((out->tv_usec -= in->tv_usec) < 0) {
		--out->tv_sec;
		out->tv_usec += 1000000;
	}
	out->tv_sec -= in->tv_sec;
}

/*
d2324 1
a2324 1
		    kk <= MAXDATALEN - (8 + sizeof(struct tv32) + ii);
@


1.102
log
@port src/sbin/ping/ping.c r1.115.

> use clock_gettime(CLOCK_MONOTONIC) to get timestamps to measure the
> interval between sending a ping and getting a reply for it.
>
> this makes it resistant against local wall clock changes, which can
> skew the intervals reported or make them go negative.

requested by deraadt@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.101 2015/01/16 06:40:00 deraadt Exp $	*/
d1084 1
a1084 1
			bcopy(&tv32, &outpack[ICMP6ECHOLEN], sizeof(tv32));
d1258 1
a1258 1
			bcopy(icp + 1, &tv32, sizeof(tv32));
d2392 1
a2392 1
	bcopy(digest, &in6.s6_addr[12], 4);
@


1.101
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.100 2014/12/03 23:04:52 deraadt Exp $	*/
d1075 1
d1079 3
a1081 1
			(void)gettimeofday(&tv, NULL);
d1212 1
d1222 3
a1224 1
	(void)gettimeofday(&tv, NULL);
@


1.100
log
@Use arc4random_buf() rather than iterating word by wordo
itk florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.99 2014/07/11 15:28:27 florian Exp $	*/
d1188 2
d1310 1
a1310 1
				end = buf + MIN(cc, ICMP6ECHOLEN + datalen);
@


1.99
log
@Silence a compiler warning and build with -Wall etc.
While here check that our buffer is big enough.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.98 2014/07/11 15:25:48 florian Exp $	*/
d605 1
a605 3
	memset(nonce, 0, sizeof(nonce));
	for (i = 0; i < sizeof(nonce); i += sizeof(u_int32_t))
		*((u_int32_t *)&nonce[i]) = arc4random();
@


1.98
log
@use optval for setsockopt consistently
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.97 2014/07/09 09:41:09 florian Exp $	*/
d1742 2
a1743 2
	while (nilen > 0) {
		u_int32_t ttl;
a1745 2
			/* XXX: alignment? */
			ttl = (u_int32_t)ntohl(*(u_int32_t *)cp);
d1750 2
a1751 2
		if (inet_ntop(AF_INET6, cp, ntop_buf, sizeof(ntop_buf)) ==
		    NULL)
@


1.97
log
@Hopefully we are calculating the pkg size correctly by now;
no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.96 2014/07/09 09:39:54 florian Exp $	*/
d249 1
a249 1
	int ch, hold, i, packlen, preload, optval, ret_ga;
d609 1
a609 1
	hold = 1;
d612 2
a613 2
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, &hold,
		    (socklen_t)sizeof(hold));
d796 3
a798 3
		hold = 48 * 1024;
		setsockopt(s, SOL_SOCKET, SO_RCVBUF, &hold,
		    (socklen_t)sizeof(hold));
@


1.96
log
@We do have ICMP6_FILTER; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.95 2014/07/09 09:38:35 florian Exp $	*/
a1086 5

#ifdef DIAGNOSTIC
	if (pingerlen() != cc)
		errx(1, "internal error; length mismatch");
#endif
@


1.95
log
@We do have SO_SNDBUF & SO_RCVBUF; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.94 2014/07/09 09:37:30 florian Exp $	*/
a632 1
#ifdef ICMP6_FILTER
a648 1
#endif /*ICMP6_FILTER*/
@


1.94
log
@We do have NI_NODEADDR_FLAG_ANYCAST, no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.93 2014/07/09 09:35:51 florian Exp $	*/
a254 1
#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
a256 1
#endif
a320 1
#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
a327 4
#else
			errx(1,
"-b option ignored: SO_SNDBUF/SO_RCVBUF socket options not supported");
#endif
a779 1
#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
a801 1
#endif
@


1.93
log
@We do have SIGINFO; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.92 2014/07/09 09:34:47 florian Exp $	*/
a312 1
#ifdef NI_NODEADDR_FLAG_ANYCAST
a314 5
#else
					errx(1,
"-a A is not supported on the platform");
					/*NOTREACHED*/
#endif
@


1.92
log
@We don't have IPV6_REACHCONF, no obj change after unifdef(1).
Further cleanup by hand lead to a obj change though.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.91 2014/07/09 09:33:12 florian Exp $	*/
a210 1
#ifdef SIGINFO
a211 1
#endif
a834 1
#ifdef SIGINFO
a835 1
#endif
a846 1
#ifdef SIGINFO
a847 1
#endif
a870 1
#ifdef SIGINFO
a875 1
#endif
a950 1
#ifdef SIGINFO
a953 1
#endif
@


1.91
log
@Kill code commented since forever; no obj change.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.90 2014/04/28 15:25:34 florian Exp $	*/
a146 3
#ifdef IPV6_REACHCONF
#define F_REACHCONF	0x8000
#endif
d285 1
a285 1
	    "a:b:c:dEefHg:h:I:i:l:mnNp:qRS:s:tvV:wW")) != -1) {
a432 7
		case 'R':
#ifdef IPV6_REACHCONF
			options |= F_REACHCONF;
			break;
#else
			errx(1, "-R is not supported in this configuration");
#endif
a682 4
#ifdef IPV6_REACHCONF
	if (options & F_REACHCONF)
		ip6optlen += CMSG_SPACE(0);
#endif
a714 9
#ifdef IPV6_REACHCONF
	if (options & F_REACHCONF) {
		scmsgp->cmsg_len = CMSG_LEN(0);
		scmsgp->cmsg_level = IPPROTO_IPV6;
		scmsgp->cmsg_type = IPV6_REACHCONF;

		scmsgp = CMSG_NXTHDR(&smsghdr, scmsgp);
	}
#endif
a2434 3
#ifdef IPV6_REACHCONF
	    "R"
#endif
@


1.90
log
@Do not sleep after poll returning an error. Blindly copied over from
ping6 to ping by me without thinking clearly.
pointed out by deraadt@@
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.89 2014/04/23 18:16:36 jca Exp $	*/
a684 8

/*
	optval = 1;
	if (IN6_IS_ADDR_MULTICAST(&dst.sin6_addr))
		if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
		    &optval, sizeof(optval)) == -1)
			err(1, "IPV6_MULTICAST_LOOP");
*/
@


1.89
log
@Better name for fdmaskp, reduce the scope of some variables, don't abuse
cc for poll()'s return value, and indent decls.  ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.88 2014/01/10 21:57:44 florian Exp $	*/
d895 1
a895 1
		int		ret, timeout;
d925 1
a925 8
		ret = poll(&pfd, 1, timeout);
		if (ret < 0) {
			if (errno != EINTR) {
				warn("poll");
				sleep(1);
			}
			continue;
		} else if (ret == 0)
@


1.88
log
@Fix the unitialized rtableid bug discovered and fixed in the previous
commit by brad@@ by calling setsockopt SO_RTABLE only when -V is
present. As a bonus drop privileges very early in main, before option
parsing.
This brings ping6 more in line with what ping does and will make
eventual unification easier.

OK deraadt@@
"works for me" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.87 2014/01/10 06:18:40 brad Exp $	*/
a252 1
	int timeout;
d254 1
a254 3
	struct pollfd fdmaskp[1];
	int cc, i;
	int ch, hold, packlen, preload, optval, ret_ga;
d887 1
a887 1
		struct msghdr m;
d891 5
a895 2
		} cmsgbuf;
		struct iovec iov[2];
d921 6
a926 4
		fdmaskp[0].fd = s;
		fdmaskp[0].events = POLLIN;
		cc = poll(fdmaskp, 1, timeout);
		if (cc < 0) {
d932 1
a932 1
		} else if (cc == 0)
@


1.87
log
@Fix a bug found in ping6 when rebuilding with stack protector strong.
rtableid is unitialized; the stack protector strong binary would fail
to set the routing table id. Copy the rtableid initialization over to
ping to keep what is essentially similar code in sync.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.86 2013/11/22 04:12:48 deraadt Exp $	*/
d274 9
a282 1
	int rtableid = -1;
d490 3
a553 8
	if ((s = socket(res->ai_family, res->ai_socktype,
	    res->ai_protocol)) < 0)
		err(1, "socket");

	if (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
	    sizeof(rtableid)) == -1))
		err(1, "setsockopt SO_RTABLE");

a599 5

	/* revoke root privilege */
	uid = getuid();
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid");
@


1.86
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.85 2013/10/21 08:47:10 phessler Exp $	*/
d274 1
a274 1
	u_int rtableid;
d547 2
a548 2
	if (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
	    sizeof(rtableid)) == -1)
@


1.85
log
@More rdomain / rtable support for useful diagnostic tools


OK claudio@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.84 2013/05/31 19:46:57 naddy Exp $	*/
d1242 2
a1243 1
				    isprint(*cp) ? "%c" : "\\%03o", *cp & 0xff);
d2399 1
a2399 1
		if (!isxdigit(*cp))
@


1.84
log
@don't truncate trailing zeros from the round-trip times; ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.83 2013/04/16 22:10:48 deraadt Exp $	*/
d274 1
d283 1
a283 1
	    "a:b:c:dEefHg:h:I:i:l:mnNp:qRS:s:tvwW")) != -1) {
d476 7
d547 4
d2477 2
a2478 1
	    "\n\t[-S sourceaddr] [-s packetsize] [hops ...] host\n");
@


1.83
log
@mark time_t edges with comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.82 2012/12/04 02:24:47 deraadt Exp $	*/
d1354 1
a1354 1
				(void)printf(" time=%g ms", triptime);
@


1.82
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.81 2011/03/03 00:30:31 mikeb Exp $	*/
d393 1
a393 1
			interval.tv_sec = (long)intval;
d1134 1
a1134 1
			tv32.tv32_sec = htonl(tv.tv_sec);
@


1.81
log
@This change makes ping compare minimum amount of bytes between what
was received and what was sent out and print additional information
explaining payload size differences.

Issue was found by reyk, debugged by jsg and me with an input from
claudio (who found out that initial version breaks -w) and bluhm
(who advised to notify a user).  Ok bluhm and deraadt on the
previous version of the diff.  Lots of history for a one-liner :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.80 2010/06/26 18:30:03 phessler Exp $	*/
d83 1
a83 1
#include <sys/param.h>
@


1.80
log
@allow a user to set a -c count of 0.
while here, change ping6 to use strtonum instead of strtol.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.79 2010/05/10 02:00:50 krw Exp $	*/
d1362 7
@


1.79
log
@Various comment typos. 'wether' -> 'whether' (most popular), 'possiblity' ->
'possibility', 'optins' -> 'options', 'resposne' -> 'response', 'unecessary' -> 'unnecessary', 'desination' -> 'destination'. Collected from various misc@@
and tech@@ postings, many by Brad Tilley.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.78 2010/02/21 19:00:11 deraadt Exp $	*/
d260 1
d342 3
a344 2
			npackets = strtol(optarg, &e, 10);
			if (npackets <= 0 || *optarg == '\0' || *e != '\0')
d346 2
a347 1
				    "illegal number of packets -- %s", optarg);
@


1.78
log
@Actually use the gints addrinfo setup for gateway lookup, instead of using
the global one (which has a useless AI_CANONNAME and thus is slower)
found by martin.pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.77 2009/12/24 10:06:35 sobrado Exp $	*/
d942 1
a942 1
			 * exceptions (currently the only possiblity is
d1585 1
a1585 1
		 * optins.
d1783 1
a1783 1
	 * is contained in the resposne. We try to detect the version
@


1.77
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.76 2009/11/02 22:31:50 sobrado Exp $	*/
d552 1
a552 1
		error = getaddrinfo(gateway, NULL, &hints, &gres);
@


1.76
log
@s/hz/Hz/ on multiples of the SI unit hertz other than MHz.

reminded by STeve Andre.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.75 2009/10/27 23:59:34 deraadt Exp $	*/
d569 1
a569 1
	 * let the kerel pass extension headers of incoming packets,
d667 1
a667 1
	/* let the kerel pass extension headers of incoming packets */
@


1.75
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.74 2009/05/31 17:33:39 ckuethe Exp $	*/
d395 1
a395 1
			/* less than 1/hz does not make sense */
@


1.74
log
@add audible output to ping and ping6: -e beeps when pings are replied, -E beeps when
pings are dropped.

suggestion to make ping and ping6 use the same flag from deraadt & sthen.
reminder to not forget about ping6 from todd and naddy.

ok deraadt, sthen
"well, i don't object..." from a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.73 2008/03/24 16:11:08 deraadt Exp $	*/
a65 10

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)ping.c	8.1 (Berkeley) 6/5/93";
#endif /* not lint */
@


1.73
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.72 2008/03/15 16:10:11 kettenis Exp $	*/
d165 2
d204 1
d291 1
a291 1
	    "a:b:c:dfHg:h:I:i:l:mnNp:qRS:s:tvwW")) != -1) {
d359 6
d601 4
d970 6
d1364 2
d2457 1
a2457 1
	    "usage: ping6 [-dfH"
d2464 1
a2464 1
            "[-h hoplimit] [-I interface] [-i wait] [-l preload] [-p pattern]"
@


1.72
log
@Fix several CMSG-related bugs.  Chaining CMSG's is tricky since you need to
use CMSG_SPACE for all except the last one, which should be CMSG_LEN.  This
makes calculate .msg_controllen tricky.  Also make sure that we can receive
multiple CMSG's again.

ok deraadt@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.71 2008/03/13 01:49:53 deraadt Exp $	*/
d267 1
a267 1
	int ip6optlen = 0, ip6optspace = 0;
d501 1
a501 2
		ip6optlen = ip6optspace + CMSG_LEN(rthlen);
		ip6optspace += CMSG_SPACE(rthlen);
d682 2
a683 4
	if (usepktinfo) {
		ip6optlen = ip6optspace + CMSG_LEN(sizeof(struct in6_pktinfo));
		ip6optspace += CMSG_SPACE(sizeof(struct in6_pktinfo));
	}
d685 2
a686 4
	if (hoplimit != -1) {
		ip6optlen = ip6optspace + CMSG_LEN(sizeof(int));
		ip6optspace += CMSG_SPACE(sizeof(int));
	}
d689 2
a690 4
	if (options & F_REACHCONF) {
		ip6optlen = ip6optspace + CMSG_LEN(0);
		ip6optspace += CMSG_SPACE(0);
	}
d695 1
a695 1
		if ((scmsg = malloc(ip6optspace)) == 0)
d925 1
a925 1
		m.msg_controllen = CMSG_LEN(1024);
@


1.71
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.70 2007/12/30 13:38:47 sobrado Exp $	*/
d267 1
a267 1
	int ip6optlen = 0;
d496 1
a496 2
		rthlen = CMSG_SPACE(inet6_rth_space(IPV6_RTHDR_TYPE_0,
		    argc - 1));
d501 2
a502 1
		ip6optlen += rthlen;
d683 4
a686 2
	if (usepktinfo)
		ip6optlen += CMSG_SPACE(sizeof(struct in6_pktinfo));
d688 4
a691 2
	if (hoplimit != -1)
		ip6optlen += CMSG_SPACE(sizeof(int));
d694 4
a697 2
	if (options & F_REACHCONF)
		ip6optlen += CMSG_SPACE(0);
d702 1
a702 1
		if ((scmsg = malloc(ip6optlen)) == 0)
d884 1
a884 1
			u_char buf[sizeof(struct in6_pktinfo)];
d932 1
a932 1
		m.msg_controllen = sizeof(cmsgbuf.buf);
@


1.70
log
@add missing space between argument names and ellipsis

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.69 2006/12/15 06:07:39 itojun Exp $	*/
d876 4
a879 1
		u_char buf[1024];
d925 2
a926 2
		m.msg_control = (caddr_t)buf;
		m.msg_controllen = sizeof(buf);
@


1.69
log
@reduce RFC2292/3542 #ifdefs.
while here, correct type mismatch (socklen_t) and adjust AH handling to OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.68 2006/11/20 08:07:00 itojun Exp $	*/
d2442 1
a2442 1
	    "\n\t[-S sourceaddr] [-s packetsize] [hops...] host\n");
@


1.68
log
@knf: sizeof x -> sizeof(x)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.67 2006/11/16 02:19:12 itojun Exp $	*/
a91 7
/*
 * NOTE:
 * USE_SIN6_SCOPE_ID assumes that sin6_scope_id has the same semantics
 * as IPV6_PKTINFO.  Some people object it (sin6_scope_id specifies *link*
 * while IPV6_PKTINFO specifies *interface*.  Link is defined as collection of
 * network attached to 1 or more interfaces)
 */
d104 1
a118 1
#ifdef HAVE_POLL_H
a119 6
#endif

#ifdef IPSEC
#include <netinet6/ah.h>
#include <netinet6/ipsec.h>
#endif
a152 8
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
#define	F_POLICY	0x0400
#else
#define F_AUTHHDR	0x0200
#define F_ENCRYPT	0x0400
#endif /*IPSEC_POLICY_IPSEC*/
#endif /*IPSEC*/
a251 3
#ifdef IPSEC_POLICY_IPSEC
int	 setpolicy(int, char *);
#endif
a259 1
#ifdef HAVE_POLL_H
a260 3
#else
	struct timeval timeout, *tv;
#endif
a261 1
#ifdef HAVE_POLL_H
a262 4
#else
	fd_set *fdmaskp;
	int fdmasks;
#endif
a274 1
#ifdef IPV6_RECVPKTINFO
a275 5
#endif
#ifdef IPSEC_POLICY_IPSEC
	char *policy_in = NULL;
	char *policy_out = NULL;
#endif
a277 1
#ifdef IPV6_USE_MIN_MTU
a278 1
#endif
a286 9
#ifndef IPSEC
#define ADDOPTS
#else
#ifdef IPSEC_POLICY_IPSEC
#define ADDOPTS	"P:"
#else
#define ADDOPTS	"AE"
#endif /*IPSEC_POLICY_IPSEC*/
#endif
d288 1
a288 2
	    "a:b:c:dfHg:h:I:i:l:mnNp:qRS:s:tvwW" ADDOPTS)) != -1) {
#undef ADDOPTS
a380 1
#ifndef USE_SIN6_SCOPE_ID
a381 1
#endif
a412 1
#ifdef IPV6_USE_MIN_MTU
a414 4
#else
			errx(1, "-%c is not supported on this platform", ch);
			/*NOTREACHED*/
#endif
a480 22
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
		case 'P':
			options |= F_POLICY;
			if (!strncmp("in", optarg, 2)) {
				if ((policy_in = strdup(optarg)) == NULL)
					errx(1, "strdup");
			} else if (!strncmp("out", optarg, 3)) {
				if ((policy_out = strdup(optarg)) == NULL)
					errx(1, "strdup");
			} else
				errx(1, "invalid security policy");
			break;
#else
		case 'A':
			options |= F_AUTHHDR;
			break;
		case 'E':
			options |= F_ENCRYPT;
			break;
#endif /*IPSEC_POLICY_IPSEC*/
#endif /*IPSEC*/
a495 1
#ifdef IPV6_RECVRTHDR
a497 3
#else
		rthlen = inet6_rthdr_space(IPV6_RTHDR_TYPE_0, argc - 1);
#endif
a576 1
#ifdef IPV6_RECVHOPOPTS
a579 6
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPOPTS, &opton,
		    (socklen_t)sizeof(opton)))
			err(1, "setsockopt(IPV6_HOPOPTS)");
#endif
#ifdef IPV6_RECVDSTOPTS
a582 10
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_DSTOPTS, &opton,
		    (socklen_t)sizeof(opton)))
			err(1, "setsockopt(IPV6_DSTOPTS)");
#endif
#ifdef IPV6_RECVRTHDRDSTOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDRDSTOPTS, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVRTHDRDSTOPTS)");
#endif
a631 1
#ifdef IPV6_USE_MIN_MTU
d638 1
a638 3
	}
#ifdef IPV6_RECVPATHMTU
	else {
a643 2
#endif /* IPV6_RECVPATHMTU */
#endif /* IPV6_USE_MIN_MTU */
a644 29
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
	if (options & F_POLICY) {
		if (setpolicy(s, policy_in) < 0)
			errx(1, "%s", ipsec_strerror());
		if (setpolicy(s, policy_out) < 0)
			errx(1, "%s", ipsec_strerror());
	}
#else
	if (options & F_AUTHHDR) {
		optval = IPSEC_LEVEL_REQUIRE;
#ifdef IPV6_AUTH_TRANS_LEVEL
		if (setsockopt(s, IPPROTO_IPV6, IPV6_AUTH_TRANS_LEVEL,
		    &optval, sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_AUTH_TRANS_LEVEL)");
#else /* old def */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_AUTH_LEVEL,
		    &optval, sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_AUTH_LEVEL)");
#endif
	}
	if (options & F_ENCRYPT) {
		optval = IPSEC_LEVEL_REQUIRE;
		if (setsockopt(s, IPPROTO_IPV6, IPV6_ESP_TRANS_LEVEL,
		    &optval, sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_ESP_TRANS_LEVEL)");
	}
#endif /*IPSEC_POLICY_IPSEC*/
#endif
a668 1
#ifdef IPV6_RECVRTHDR
a671 5
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, &opton,
		    (socklen_t)sizeof(opton)))
			err(1, "setsockopt(IPV6_RTHDR)");
#endif
a712 1
#ifndef USE_SIN6_SCOPE_ID
a715 4
#else
		if ((dst.sin6_scope_id = if_nametoindex(ifname)) == 0)
			errx(1, "%s: invalid interface name", ifname);
#endif
a736 1
#ifdef IPV6_RECVPKTINFO
a737 1
#endif
a738 1
#ifdef IPV6_RECVPKTINFO
a747 5
#else  /* old advanced API */
		if ((scmsgp = (struct cmsghdr *)inet6_rthdr_init(scmsgp,
		    IPV6_RTHDR_TYPE_0)) == 0)
			errx(1, "can't initialize rthdr");
#endif /* IPV6_RECVPKTINFO */
a758 1
#ifdef IPV6_RECVPKTINFO
a761 6
#else  /* old advanced API */
			if (inet6_rthdr_add(scmsgp,
			    &(SIN6(iaip->ai_addr))->sin6_addr,
			    IPV6_RTHDR_LOOSE))
				errx(1, "can't add an intermediate node");
#endif /* IPV6_RECVPKTINFO */
a764 4
#ifndef IPV6_RECVPKTINFO
		if (inet6_rthdr_lasthop(scmsgp, IPV6_RTHDR_LOOSE))
			errx(1, "can't set the last flag");
#endif
a784 1
#ifdef IPV6_RECVPKTINFO
a803 6
#else  /* old advanced API */
		if (smsghdr.msg_control &&
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTOPTIONS,
		    (void *)smsghdr.msg_control, smsghdr.msg_controllen))
			err(1, "UDP setsockopt(IPV6_PKTOPTIONS)");
#endif
a839 2
#ifndef USE_SIN6_SCOPE_ID
#ifdef IPV6_RECVPKTINFO
a842 7
#else  /* old adv. API */
	if (setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &optval,
	    (socklen_t)sizeof(optval)) < 0)
		warn("setsockopt(IPV6_PKTINFO)"); /* XXX err? */
#endif
#endif /* USE_SIN6_SCOPE_ID */
#ifdef IPV6_RECVHOPLIMIT
a845 5
#else  /* old adv. API */
	if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &optval,
	    (socklen_t)sizeof(optval)) < 0)
		warn("setsockopt(IPV6_HOPLIMIT)"); /* XXX err? */
#endif
a868 6
#ifndef HAVE_POLL_H
	fdmasks = howmany(s + 1, NFDBITS) * sizeof(fd_mask);
	if ((fdmaskp = malloc(fdmasks)) == NULL)
		err(1, "malloc");
#endif

a899 1
#ifdef HAVE_POLL_H
d901 1
a901 7
#else
			timeout.tv_sec = 0;
			timeout.tv_usec = 10000;
			tv = &timeout;
#endif
		} else {
#ifdef HAVE_POLL_H
a902 5
#else
			tv = NULL;
#endif
		}
#ifdef HAVE_POLL_H
a905 5
#else
		memset(fdmaskp, 0, fdmasks);
		FD_SET(s, fdmaskp);
		cc = select(s + 1, fdmaskp, NULL, NULL, tv);
#endif
a907 1
#ifdef HAVE_POLL_H
a908 3
#else
				warn("select");
#endif
a1331 1
#ifdef SIN6_LEN
a1332 1
#endif
a1532 1
#ifdef IPV6_RTHDRDSTOPTS
a1533 1
#endif
a1544 1
#ifdef IPV6_RECVPKTINFO
d1551 2
a1552 1
	size_t extlen, len;
a1595 9
#else  /* !IPV6_RECVPKTINFO */
/* ARGSUSED */
void
pr_ip6opt(void *extbuf)
{
	putchar('\n');
	return;
}
#endif /* IPV6_RECVPKTINFO */
a1596 1
#ifdef IPV6_RECVPKTINFO
a1628 9
#else  /* !IPV6_RECVPKTINFO */
/* ARGSUSED */
void
pr_rthdr(void *extbuf)
{
	putchar('\n');
	return;
}
#endif /* IPV6_RECVPKTINFO */
a1848 1
#ifdef IPV6_RECVPATHMTU
a1895 1
#endif
a2313 1
#ifdef IPSEC
d2316 2
a2317 2
			hlen = (((struct ah *)cp)->ah_len+2) << 2;
			nh = ((struct ah *)cp)->ah_nxt;
a2318 1
#endif
a2385 23
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
int
setpolicy(int so, char *policy)
{
	char *buf;

	if (policy == NULL)
		return 0;	/* ignore */

	buf = ipsec_set_policy(policy, strlen(policy));
	if (buf == NULL)
		errx(1, "%s", ipsec_strerror());
	if (setsockopt(s, IPPROTO_IPV6, IPV6_IPSEC_POLICY, buf,
	    ipsec_get_policylen(buf)) < 0)
		warnx("Unable to set IPsec policy");
	free(buf);

	return 0;
}
#endif
#endif

a2434 1
#ifdef IPV6_USE_MIN_MTU
a2435 1
#endif
a2438 7
#endif
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
	    "] [-P policy"
#else
	    "AE"
#endif
@


1.67
log
@make RFC2292/3542 selection automagically happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.66 2006/08/10 18:40:35 jmc Exp $	*/
d1335 1
a1335 1
			bcopy(&tv32, &outpack[ICMP6ECHOLEN], sizeof tv32);
d1508 1
a1508 1
			bcopy(icp + 1, &tv32, sizeof tv32);
d2181 1
a2181 1
	snprintf(buft, sizeof buft, "\n--- %s ping6 statistics ---\n",
d2183 2
a2184 2
	strlcat(buf, buft, sizeof buf);
	snprintf(buft, sizeof buft, "%ld packets transmitted, ",
d2186 2
a2187 2
	strlcat(buf, buft, sizeof buf);
	snprintf(buft, sizeof buft, "%ld packets received, ",
d2189 1
a2189 1
	strlcat(buf, buft, sizeof buf);
d2191 1
a2191 1
		snprintf(buft, sizeof buft, "+%ld duplicates, ",
d2193 1
a2193 1
		strlcat(buf, buft, sizeof buf);
d2197 1
a2197 1
			snprintf(buft, sizeof buft,
d2200 1
a2200 1
			snprintf(buft, sizeof buft, "%.1lf%% packet loss",
d2203 1
a2203 1
		strlcat(buf, buft, sizeof buf);
d2205 1
a2205 1
	strlcat(buf, "\n", sizeof buf);
d2211 1
a2211 1
		snprintf(buft, sizeof buft,
d2214 1
a2214 1
		strlcat(buf, buft, sizeof buf);
@


1.66
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.65 2006/04/13 00:49:15 deraadt Exp $	*/
d308 1
a308 1
#ifdef USE_RFC2292BIS
d576 1
a576 1
#ifdef IPV6_RECVRTHDR	/* 2292bis */
d579 1
a579 1
#else  /* RFC2292 */
d883 1
a883 1
#ifdef USE_RFC2292BIS
d887 1
a887 1
#ifdef USE_RFC2292BIS
d901 1
a901 1
#endif /* USE_RFC2292BIS */
d913 1
a913 1
#ifdef USE_RFC2292BIS
d922 1
a922 1
#endif /* USE_RFC2292BIS */
d926 1
a926 1
#ifndef USE_RFC2292BIS
d950 1
a950 1
#ifdef USE_RFC2292BIS
d1762 1
a1762 1
#ifdef USE_RFC2292BIS
d1813 1
a1813 1
#else  /* !USE_RFC2292BIS */
d1821 1
a1821 1
#endif /* USE_RFC2292BIS */
d1823 1
a1823 1
#ifdef USE_RFC2292BIS
d1856 1
a1856 2

#else  /* !USE_RFC2292BIS */
d1864 1
a1864 1
#endif /* USE_RFC2292BIS */
@


1.65
log
@fix more signal races; ok moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.64 2006/04/10 08:05:14 deraadt Exp $	*/
d2702 1
a2702 1
	    "nNqtvwW"
d2713 3
a2715 4
	    "] [-a [aAclsg]] [-b sockbufsiz] [-c count] \n"
            "\t[-I interface] [-i wait] [-l preload] [-p pattern] "
	    "[-S sourceaddr]\n"
            "\t[-s packetsize] [-h hoplimit] [-g gateway] [hops...] host\n");
@


1.64
log
@minimal cleanups prompted by lint; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.63 2006/03/17 16:11:06 otto Exp $	*/
d271 1
a271 1
void	 summary(void);
d1084 1
a1084 1
			summary();
d1169 1
a1169 1
	summary();
a2156 1
/* ARGSUSED */
d2158 1
a2158 1
onint(int notused)
d2160 1
a2160 1
	summary();			/* XXX signal race */
d2165 4
a2168 2
	/* NOTREACHED */
	exit(1);			/* XXX signal race */
d2176 1
a2176 1
summary(void)
d2178 3
d2182 14
a2195 5
	(void)printf("\n--- %s ping6 statistics ---\n", hostname);
	(void)printf("%ld packets transmitted, ", ntransmitted);
	(void)printf("%ld packets received, ", nreceived);
	if (nrepeats)
		(void)printf("+%ld duplicates, ", nrepeats);
d2198 2
a2199 1
			(void)printf("-- somebody's duplicating packets!");
d2201 1
a2201 1
			(void)printf("%.1lf%% packet loss",
d2204 1
d2206 1
a2206 1
	(void)putchar('\n');
d2212 1
a2212 1
		(void)printf(
d2215 4
a2219 2
	}
	(void)fflush(stdout);
@


1.63
log
@Off-by-one; from NetBSD's coverity analysis; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.62 2006/03/06 10:45:57 djm Exp $	*/
a216 1
int pathmtu = 0;		/* path MTU for the destination.  0 = unspec. */
d273 1
d275 1
d616 1
a616 1
	(void)memcpy(&dst, res->ai_addr, res->ai_addrlen);
d647 1
a647 1
			       gres->ai_addr, gres->ai_addrlen)) {
d663 1
a663 1
		    sizeof(opton)))
d667 1
a667 1
		    sizeof(opton)))
d672 1
a672 1
		    sizeof(opton)))
d676 1
a676 1
		    sizeof(opton)))
d712 1
a712 1
	if (!(packet = (u_char *)malloc((u_int)packlen)))
d726 2
a727 2
		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&hold,
		    sizeof(hold));
d731 1
a731 1
		    &optval, sizeof(optval)) == -1)
d738 1
a738 1
		    &optval, sizeof(optval)) == -1)
d795 1
a795 1
	    sizeof(filt)) < 0)
d810 1
a810 1
		    sizeof(opton)))
d837 1
a837 1
		if ((scmsg = (char *)malloc(ip6optlen)) == 0)
d991 1
a991 1
		    sizeof(sockbufsize)) < 0)
d994 1
a994 1
		    sizeof(sockbufsize)) < 0)
d996 1
a996 2
	}
	else {
d1006 2
a1007 2
		setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&hold,
		    sizeof(hold));
d1015 1
a1015 1
	    sizeof(optval)) < 0)
d1019 1
a1019 1
	    sizeof(optval)) < 0)
d1025 1
a1025 1
	    sizeof(optval)) < 0)
d1029 1
a1029 1
	    sizeof(optval)) < 0)
d1128 1
a1128 1
		m.msg_name = (caddr_t)&from;
d1345 1
a1345 1
	smsghdr.msg_name = (caddr_t)&dst;
d1669 2
a1670 1
				ttl = (int32_t)ntohl(*(u_long *)&buf[off+ICMP6ECHOLEN+8]);
@


1.62
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.61 2005/12/12 18:45:40 jaredy Exp $	*/
d2436 1
a2436 1
			if (ni->ni_code > sizeof(nircode) / sizeof(nircode[0]))
@


1.61
log
@Don't wait one time interval before sending the first packet.

Problem reported by Andreas Lundin <lunde@@woopheer.mine.nu>
on tech@@, but fix from KAME.

ok pascoe markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.60 2005/12/02 01:05:50 deraadt Exp $	*/
d319 1
d686 3
a688 2
	seteuid(getuid());
	setuid(getuid());
@


1.60
log
@mark signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.59 2004/09/14 22:12:27 deraadt Exp $	*/
d1049 1
a1049 1
		if (ntransmitted)
@


1.59
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.58 2004/06/09 02:01:15 itojun Exp $	*/
d2158 1
a2158 1
	summary();
d2164 1
a2164 1
	exit(1);
@


1.58
log
@correct mistake in usage().  Chris Pinnock
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.57 2004/01/25 03:39:15 deraadt Exp $	*/
a1065 1
		struct cmsghdr *cm;
a1132 1
		cm = (struct cmsghdr *)buf;
@


1.57
log
@when dealing with structs in packets, be paranoid in case sometime
in the future they end up being misaligned; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.56 2003/07/25 06:01:42 itojun Exp $	*/
d2698 1
a2698 1
            "\t[-s packetsize] [-h hoplimit] [hops...] [-g gateway] host\n");
@


1.56
log
@packet loss count in floating point (double).  Wouter Clarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.55 2003/06/11 06:22:15 deraadt Exp $	*/
d1330 2
a1331 1
			struct tv32 *tv32;
d1333 3
a1335 3
			tv32 = (struct tv32 *)&outpack[ICMP6ECHOLEN];
			tv32->tv32_sec = htonl(tv.tv_sec);
			tv32->tv32_usec = htonl(tv.tv_usec);
d1466 1
a1466 1
	struct tv32 *tpp;
d1508 3
a1510 3
			tpp = (struct tv32 *)(icp + 1);
			tp.tv_sec = ntohl(tpp->tv32_sec);
			tp.tv_usec = ntohl(tpp->tv32_usec);
@


1.55
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.54 2003/06/11 05:32:43 itojun Exp $	*/
d2185 2
a2186 2
			(void)printf("%d%% packet loss",
			    (int) (((ntransmitted - nreceived) * 100) /
@


1.54
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.53 2003/06/02 20:06:16 millert Exp $	*/
d279 1
a279 3
main(argc, argv)
	int argc;
	char *argv[];
d1174 1
a1174 2
onsignal(sig)
	int sig;
d1197 1
a1197 1
retransmit()
d1233 1
a1233 1
pingerlen()
d1252 1
a1252 1
pinger()
d1367 1
a1367 2
myechoreply(icp)
	const struct icmp6_hdr *icp;
d1376 1
a1376 2
mynireply(nip)
	const struct icmp6_nodeinfo *nip;
d1387 2
a1388 6
dnsdecode(sp, ep, base, buf, bufsiz)
	const u_char **sp;
	const u_char *ep;
	const u_char *base;	/*base for compressed name*/
	char *buf;
	size_t bufsiz;
d1453 1
a1453 4
pr_pack(buf, cc, mhdr)
	u_char *buf;
	int cc;
	struct msghdr *mhdr;
d1731 1
a1731 2
pr_exthdrs(mhdr)
	struct msghdr *mhdr;
d1866 1
a1866 4
pr_bitrange(v, soff, ii)
	u_int32_t v;
	int soff;
	int ii;
d1911 1
d1913 1
a1913 3
pr_suptypes(ni, nilen)
	struct icmp6_nodeinfo *ni; /* ni->qtype must be SUPTYPES */
	size_t nilen;
d1977 1
d1979 1
a1979 3
pr_nodeaddr(ni, nilen)
	struct icmp6_nodeinfo *ni; /* ni->qtype must be NODEADDR */
	int nilen;
d2044 1
a2044 2
get_hoplim(mhdr)
	struct msghdr *mhdr;
d2063 1
a2063 2
get_rcvpktinfo(mhdr)
	struct msghdr *mhdr;
d2082 1
a2082 2
get_pathmtu(mhdr)
	struct msghdr *mhdr;
d2142 1
a2142 2
tvsub(out, in)
	struct timeval *out, *in;
d2157 1
a2157 2
onint(notused)
	int notused;
d2173 1
a2173 1
summary()
d2221 1
a2221 3
pr_icmph(icp, end)
	struct icmp6_hdr *icp;
	u_char *end;
d2451 1
a2451 2
pr_iph(ip6)
	struct ip6_hdr *ip6;
d2479 1
a2479 3
pr_addr(addr, addrlen)
	struct sockaddr *addr;
	int addrlen;
d2498 1
a2498 3
pr_retip(ip6, end)
	struct ip6_hdr *ip6;
	u_char *end;
d2578 1
a2578 2
fill(bp, patp)
	char *bp, *patp;
d2611 1
a2611 3
setpolicy(so, policy)
	int so;
	char *policy;
d2632 1
a2632 2
nigroup(name)
	char *name;
d2676 1
a2676 1
usage()
@


1.53
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.52 2002/12/05 02:08:28 itojun Exp $	*/
d1511 1
a1511 1
		warnx("failed to get receiving pakcet information");
@


1.52
log
@correct sizeof() to memset().  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.51 2002/10/25 02:25:43 itojun Exp $	*/
d50 1
a50 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.51
log
@use poll(2).  sync w/kame (originally from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.50 2002/10/25 02:24:27 itojun Exp $	*/
d327 2
a328 2
	memset(&smsghdr, 0, sizeof(&smsghdr));
	memset(&smsgiov, 0, sizeof(&smsgiov));
@


1.50
log
@be picky about arg parsing (-b).  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.49 2002/09/08 14:31:28 itojun Exp $	*/
d129 3
d289 3
d293 1
d295 3
d300 1
d1059 1
d1063 1
d1097 3
d1103 5
a1107 1
		} else
d1109 7
d1119 1
d1122 3
d1126 1
@


1.49
log
@ansi pedantic.  sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.48 2002/05/31 01:11:31 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.160 2002/09/08 14:28:18 itojun Exp $	*/
d296 2
d299 1
d379 7
a385 1
			sockbufsize = atoi(optarg);
@


1.48
log
@clarify comment when nreceived > ntransmitted.  from deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.47 2002/05/30 21:32:45 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.155 2002/05/26 13:18:25 itojun Exp $	*/
d265 1
a265 1
char	*dnsdecode(const u_char **, const u_char *, const u_char *, u_char *,
d922 2
a923 1
		int dummy, len = sizeof(src);
d1359 1
a1359 1
	u_char *buf;
d1376 1
a1376 1
			if (strlcat(buf, ".", bufsiz) >= bufsiz)
d2632 1
a2632 1
	unsigned char *q;
d2650 2
a2651 2
		if (isupper(*q))
			*q = tolower(*q);
d2659 1
a2659 1
	MD5Update(&ctxt, name, l);
@


1.47
log
@missing "%s".  from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.46 2002/05/30 18:22:13 deraadt Exp $	*/
d2168 1
a2168 1
			(void)printf("-- somebody's printing up packets!");
@


1.46
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.45 2002/05/26 13:22:40 itojun Exp $	*/
d624 1
a624 1
			errx(1, "getaddrinfo for the gateway %s",
@


1.45
log
@KNF.  remove unneeded variable.  from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.44 2002/05/26 13:02:17 itojun Exp $	*/
d1631 1
a1631 1
					(void)printf("unknwon qtype");
@


1.44
log
@sync with latest KAME tree.  -S option uses bind(2), -g option, KNF
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.43 2002/03/11 02:11:18 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.154 2002/05/26 12:56:34 itojun Exp $	*/
a241 1
volatile int signo;
d1042 1
a1042 1
	signo = seenalrm = seenint = 0;
d1141 1
a1141 1
	signo = sig;
d1600 3
a1602 5
					if (dnsdecode((const u_char **)&cp,
						      end,
						      (const u_char *)(ni + 1),
						      dnsname,
						      sizeof(dnsname)) == NULL) {
@


1.43
log
@no \n to warnx(3).  From: Mike Pechkin <mpech@@prosoft.org.lv>
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.42 2002/02/17 19:42:29 millert Exp $	*/
/*	$KAME: ping6.c,v 1.129 2001/06/22 13:16:02 itojun Exp $	*/
a122 1
#if defined(__OpenBSD__) || defined(__NetBSD__)
a123 1
#endif
a134 1
#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
a135 3
#else
#include "md5.h"
#endif
d137 3
a139 3
struct ping6_timeval {
	int32_t	tv_sec;
	int32_t	tv_usec;
d145 1
a145 1
#define ICMP6ECHOTMLEN sizeof(struct ping6_timeval)
d208 1
a216 1
struct in6_addr srcaddr;
a231 1
#if defined(__OpenBSD__) || defined(__NetBSD__)
a232 1
#endif
d242 1
d292 1
a292 1
	int ch, fromlen, hold, packlen, preload, optval, ret_ga;
d294 1
a294 1
	char *e, *target, *ifname = NULL;
d309 3
d329 1
a329 1
	    "a:b:c:dfHh:I:i:l:mnNp:qRS:s:tvwW" ADDOPTS)) != -1) {
d379 1
a379 1
			err(1,
d400 3
d408 2
d452 1
a452 1
			options |= F_NOMINMTU;
d479 18
a496 3
			/* XXX: use getaddrinfo? */
			if (inet_pton(AF_INET6, optarg, (void *)&srcaddr) != 1)
				errx(1, "invalid IPv6 address: %s", optarg);
a497 1
			usepktinfo++;
d551 1
d584 1
a584 1
	bzero(&hints, sizeof(struct addrinfo));
d591 2
a592 4
	if (ret_ga) {
		fprintf(stderr, "ping6: %s\n", gai_strerror(ret_ga));
		exit(1);
	}
d607 32
d675 1
a675 1
	if (options & F_FLOOD && options & F_INTERVAL)
d679 1
a679 1
		if (datalen >= sizeof(struct ping6_timeval)) {
a702 7
#ifndef __OpenBSD__
	gettimeofday(&timeout, NULL);
	srand((unsigned int)(timeout.tv_sec ^ timeout.tv_usec ^ (long)ident));
	memset(nonce, 0, sizeof(nonce));
	for (i = 0; i < sizeof(nonce); i += sizeof(int))
		*((int *)&nonce[i]) = rand();
#else
a705 1
#endif
d718 3
a720 2
	if ((options & F_NOMINMTU) == 0) {
		optval = 1;
a846 4
	/* set the source address */
	if (options & F_SRCADDR)/* pktinfo must be valid */
		pktinfo->ipi6_addr = srcaddr;

d918 1
a918 1
	{
d920 2
a921 1
		 * source selection
d940 6
a945 1
		    setsockopt(dummy, IPPROTO_IPV6, IPV6_HOPLIMIT,
d947 1
a947 1
			err(1, "UDP setsockopt(IPV6_HOPLIMIT)");
d1035 2
a1036 1
		retransmit();
d1043 1
a1043 1
	seenalrm = seenint = 0;
a1091 1
		fromlen = sizeof(from);
d1139 2
a1140 2
onsignal(signo)
	int signo;
d1142 2
a1143 1
	switch (signo) {
d1296 1
a1296 2
			struct ping6_timeval tv6;

d1298 3
a1300 3
			tv6.tv_sec = htonl(tv.tv_sec);
			tv6.tv_usec = htonl(tv.tv_usec);
			memcpy(&outpack[ICMP6ECHOLEN], &tv6, sizeof(tv6));
d1362 1
a1362 1
	int i = 0;
d1439 2
a1440 1
	struct timeval tv, tv2;
d1482 4
a1485 6
			struct ping6_timeval tv6;

			memcpy(&tv6, (void *)(icp + 1), sizeof(tv6));
			tv2.tv_sec = ntohl(tv6.tv_sec);
			tv2.tv_usec = ntohl(tv6.tv_usec);
			tvsub(&tv, &tv2);
a1488 1
#if defined(__OpenBSD__) || defined(__NetBSD__)
a1489 1
#endif
d1601 5
a1605 3
					if (dnsdecode((const u_char **)&cp, end,
					    (const u_char *)(ni + 1), dnsname,
					    sizeof(dnsname)) == NULL) {
d1844 1
a1844 1
pr_bitrange(v, s, ii)
d1846 1
a1846 1
	int s;
d1857 1
a1857 1
				printf("-%u", s + off - 1);
d1885 1
a1885 1
			printf(" %u", s + off);
d1995 1
a1995 1
		u_int32_t ttl = 0;
a2181 1
#if defined(__OpenBSD__) || defined(__NetBSD__)
a2185 5
#else
		(void)printf(
		    "round-trip min/avg/max = %.3f/%.3f/%.3f ms\n",
		    tmin, avg, tmax);
#endif
d2192 1
a2192 1
static char *niqcode[] = {
d2199 1
a2199 1
static char *nircode[] = {
d2475 1
a2475 1
	int flag;
a2476 5
#ifdef NI_WITHSCOPEID
	flag = NI_WITHSCOPEID;
#else
	flag = 0;
#endif
d2592 1
a2592 1
		    kk <= MAXDATALEN - (8 + sizeof(struct ping6_timeval) + ii);
d2657 1
a2657 1
	bzero(&ctxt, sizeof(ctxt));
d2696 1
a2696 1
            "\t[-s packetsize] [-h hoplimit] [hops...] host\n");
@


1.42
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.41 2002/02/16 21:27:37 millert Exp $	*/
d1412 1
a1412 1
			warnx("invalid peername\n");
d1419 1
a1419 1
			warnx("packet too short (%d bytes) from %s\n", cc,
@


1.41
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.40 2001/11/17 22:26:50 deraadt Exp $	*/
d273 2
a274 2
char *dnsdecode __P((const u_char **, const u_char *, const u_char *,
	u_char *, size_t));
@


1.40
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.39 2001/11/17 19:54:57 deraadt Exp $	*/
d256 17
a272 17
int	 main __P((int, char *[]));
void	 fill __P((char *, char *));
int	 get_hoplim __P((struct msghdr *));
int	 get_pathmtu __P((struct msghdr *));
struct in6_pktinfo *get_rcvpktinfo __P((struct msghdr *));
void	 onsignal __P((int));
void	 retransmit __P((void));
void	 onint __P((int));
size_t	 pingerlen __P((void));
int	 pinger __P((void));
const char *pr_addr __P((struct sockaddr *, int));
void	 pr_icmph __P((struct icmp6_hdr *, u_char *));
void	 pr_iph __P((struct ip6_hdr *));
void	 pr_suptypes __P((struct icmp6_nodeinfo *, size_t));
void	 pr_nodeaddr __P((struct icmp6_nodeinfo *, int));
int	 myechoreply __P((const struct icmp6_hdr *));
int	 mynireply __P((const struct icmp6_nodeinfo *));
d275 11
a285 11
void	 pr_pack __P((u_char *, int, struct msghdr *));
void	 pr_exthdrs __P((struct msghdr *));
void	 pr_ip6opt __P((void *));
void	 pr_rthdr __P((void *));
int	 pr_bitrange __P((u_int32_t, int, int));
void	 pr_retip __P((struct ip6_hdr *, u_char *));
void	 summary __P((void));
void	 tvsub __P((struct timeval *, struct timeval *));
int	 setpolicy __P((int, char *));
char	*nigroup __P((char *));
void	 usage __P((void));
@


1.39
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.38 2001/11/05 07:54:44 itojun Exp $	*/
d1098 1
a1098 1
onsignal(sig)
@


1.38
log
@one more mistake in ping6_timeval conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.37 2001/11/05 07:50:37 itojun Exp $	*/
a249 1
volatile int signo;
d1001 1
a1001 1
	signo = seenalrm = seenint = 0;
d1099 1
a1099 1
	int sig;
d1101 1
a1101 2
	signo = sig;
	switch (sig) {
@


1.37
log
@one mistake in ping6_timeval conversion.  use int32_t instead of int
when we want a variable with specific size.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.36 2001/11/01 14:18:49 deraadt Exp $	*/
d143 5
d151 1
a151 1
#define ICMP6ECHOTMLEN sizeof(struct timeval)
a255 5

struct ping6_timeval {
	int32_t	tv_sec;
	int32_t	tv_usec;
};
@


1.36
log
@ship timing info in network byte order
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.34 2001/10/26 05:09:35 mpech Exp $	*/
d253 2
a254 2
	int	tv_sec;
	int	tv_usec;
d2565 1
a2565 1
		    kk <= MAXDATALEN - (8 + sizeof(struct timeval) + ii);
@


1.35
log
@fix 64 bit issues regarding timevals
@
text
@d1259 2
a1260 2
			tv6.tv_sec = tv.tv_sec;
			tv6.tv_usec = tv.tv_usec;
d1445 2
a1446 2
			tv2.tv_sec = tv6.tv_sec;
			tv2.tv_usec = tv6.tv_usec;
@


1.34
log
@kill registers.

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.33 2001/08/18 20:42:28 deraadt Exp $	*/
d252 5
d634 1
a634 1
		if (datalen >= sizeof(struct timeval)) {
d1254 9
a1262 3
		if (timing)
			(void)gettimeofday((struct timeval *)
					   &outpack[ICMP6ECHOLEN], NULL);
d1400 1
a1400 1
	struct timeval tv, *tp;
d1442 6
a1447 2
			tp = (struct timeval *)(icp + 1);
			tvsub(&tv, tp);
@


1.33
log
@also handle snprintf() < 0
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.32 2001/07/07 18:26:18 deraadt Exp $	*/
d294 1
a294 1
	register int cc, i;
d2076 1
a2076 1
	register struct timeval *out, *in;
d2534 1
a2534 1
	register int ii, jj, kk;
@


1.32
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.31 2001/06/27 03:31:48 angelos Exp $	*/
d1351 1
a1351 1
				if (l >= sizeof(cresult))
@


1.31
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.30 2001/06/22 13:20:21 itojun Exp $	*/
d1312 1
a1312 1
	int i;
d1942 1
a1942 1
		u_int32_t ttl;
@


1.30
log
@sync usage/manpage with reality.
From: Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.29 2001/05/09 11:39:45 itojun Exp $	*/
d2579 1
a2579 1
		warnx("Unable to set IPSec policy");
@


1.29
log
@correct signal handling for ping6 -f <nonexisting destination>.
from hash@@iij.ad.jp.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.28 2001/02/04 00:37:21 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.125 2001/05/09 11:17:33 itojun Exp $	*/
d219 1
d255 1
d260 2
a261 1
void	 pinger __P((void));
d329 1
a329 1
	    "a:b:c:dfHh:I:i:l:nNp:qRS:s:tvwW" ADDOPTS)) != EOF) {
d445 8
d634 5
d643 1
a645 1
	packlen = datalen + IP6LEN + ICMP6ECHOLEN + EXTRA;
d972 2
a973 1
	printf("PING6(%d=40+8+%d bytes) ", datalen + 48, datalen);
d978 1
a978 1
		pinger();
d1028 1
a1028 1
			pinger();
d1065 15
d1122 1
a1122 2
	if (!npackets || ntransmitted < npackets) {
		pinger();
a1123 1
	}
d1153 20
a1172 1
void
d1181 3
d1255 5
d1278 2
d2013 56
d2636 5
a2640 1
	    "usage: ping6 [-dfHmnNqvwW"
@


1.28
log
@add more pedantic checks for recvmsg return value.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.27 2001/01/26 12:16:49 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.121 2001/02/01 16:43:01 itojun Exp $	*/
a162 1
#define	F_NUMERIC	0x0004
d443 1
a443 1
			options |= F_NUMERIC;
d554 1
a554 2
	if ((options & F_NUMERIC) != 0)
		hints.ai_flags = AI_CANONNAME;
a876 5

#ifdef USE_SIN6_SCOPE_ID
		src.sin6_scope_id = dst.sin6_scope_id;
#endif

d1022 1
a1022 1
				warn("recvmsg");
d1026 2
a1027 1
		}
@


1.27
log
@better signal handling.  look at check signal flag bit every time we visit
the loop (not just after EINTR on select).  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.26 2001/01/12 19:11:38 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.115 2001/01/26 09:01:23 itojun Exp $	*/
d248 1
d250 1
a257 1
void	 oninfo __P((int));
d260 1
a260 1
const char *pr_addr __P((struct sockaddr_in6 *));
d358 1
d361 5
d964 2
a965 2
	printf("%s --> ", pr_addr(&src));
	printf("%s\n", pr_addr(&dst));
d987 4
a990 1
	signo = seenalrm = seenint = seeninfo = 0;
d1009 1
d1011 1
a1011 1
			oninfo(SIGINFO);
d1015 1
d1079 1
d1083 1
d1332 2
a1333 1
	struct sockaddr_in6 *from;
d1346 2
a1347 1
	if (!mhdr || !mhdr->msg_name || mhdr->msg_namelen != sizeof(*from) ||
d1353 2
a1354 1
	from = (struct sockaddr_in6 *)mhdr->msg_name;
d1358 1
a1358 1
			    pr_addr(from));
d1408 1
a1408 1
			    pr_addr(from), seq);
d1415 1
d1417 1
d1420 3
a1422 1
				(void)printf(" dst=%s", pr_addr(&dstsa));
d1453 1
a1453 1
		(void)printf("%d bytes from %s: ", cc, pr_addr(from));
d1588 1
a1588 1
		(void)printf("%d bytes from %s: ", cc, pr_addr(from));
a1976 13
 * oninfo --
 *	SIGINFO handler.
 */
/* ARGSUSED */
void
oninfo(notused)
	int notused;
{

	summary();
}

/*
d2314 3
a2316 2
pr_addr(addr)
	struct sockaddr_in6 *addr;
d2318 2
a2319 2
	static char buf[MAXHOSTNAMELEN];
	int flag = 0;
d2321 5
a2327 3
#ifdef NI_WITHSCOPEID
	flag |= NI_WITHSCOPEID;
#endif
d2329 1
a2329 2
	if (getnameinfo((struct sockaddr *)addr, addr->sin6_len,
	    buf, sizeof(buf), NULL, 0, flag) == 0)
d2527 1
a2527 1
	    "usage: ping6 [-dfHnNqvwW"
@


1.26
log
@repair -f.
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.25 2001/01/12 19:05:40 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.112 2001/01/12 19:11:49 itojun Exp $	*/
d246 3
a248 3
volatile int seenalrm;
volatile int seenint;
volatile int seeninfo;
d988 17
d1015 4
a1018 4
		if ((cc < 0 && errno == EINTR) || ((options & F_FLOOD) && signo)) {
			if (seenalrm) {
				retransmit();
				seenalrm = 0;
a1019 11
			if (seenint) {
				onint(SIGINT);
				seenint = 0;
			}
			if (seeninfo) {
				oninfo(SIGINFO);
				seeninfo = 0;
			}
			signo = 0;
			continue;
		} else if (cc == 0)
d1021 1
a1023 1

d1039 1
a1039 15
				continue;
			}
			if (!signo)
				continue;
			if (seenalrm) {
				retransmit();
				seenalrm = 0;
			}
			if (seenint) {
				onint(SIGINT);
				seenint = 0;
			}
			if (seeninfo) {
				oninfo(SIGINFO);
				seeninfo = 0;
d1318 1
a1318 1
	struct sockaddr_in6 *from = (struct sockaddr_in6 *)mhdr->msg_name;
d1331 7
@


1.25
log
@minimize chance of signal handler race.  big help from deraadt.
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.24 2001/01/12 18:53:37 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.111 2001/01/12 19:04:03 itojun Exp $	*/
d998 1
a998 3
		if ((cc < 0 && errno == EINTR) || (options & F_FLOOD)) {
			if (!signo)
				break;
d1011 1
@


1.24
log
@correct fd_set allocation.   from deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.23 2001/01/12 18:01:43 deraadt Exp $	*/
/*	$KAME: ping6.c,v 1.109 2000/12/27 11:32:37 itojun Exp $	*/
d245 5
d254 2
a255 1
void	 onalrm __P((int));
d287 1
a287 1
	struct timeval timeout;
a302 3
#ifndef __OpenBSD__
	struct timeval tv;
#endif
d633 2
a634 2
	gettimeofday(&tv, NULL);
	srand((unsigned int)(tv.tv_sec ^ tv.tv_usec ^ (long)ident));
d963 1
a963 1
	(void)signal(SIGINT, onint);
d965 1
a965 1
	(void)signal(SIGINFO, oninfo);
d969 1
a969 1
		(void)signal(SIGALRM, onalrm);
d971 1
a971 2
		itimer.it_value.tv_sec = 0;
		itimer.it_value.tv_usec = 1;
d973 1
d980 2
d992 25
a1016 5
			memset(fdmaskp, 0, fdmasks);
			FD_SET(s, fdmaskp);
			if (select(s + 1, fdmaskp, NULL, NULL, &timeout) < 1)
				continue;
		}
d1030 4
a1033 2
		if ((cc = recvmsg(s, &m, 0)) < 0) {
			if (errno == EINTR)
d1035 15
a1049 1
			warn("recvfrom");
d1051 5
a1056 2

		pr_pack(packet, cc, &m);
d1064 18
d1083 1
a1083 1
 * onalrm --
a1084 1
 * XXX almost certainly not race-safe?
a1085 1
/* ARGSUSED */
d1087 1
a1087 2
onalrm(signo)
	int signo;
a1088 1
	int save_errno = errno;
a1092 1
		errno = save_errno;
a1113 1
	errno = save_errno;
a1965 1
	int save_errno = errno;
a1967 1
	errno = save_errno;
@


1.23
log
@save_errno handling; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.22 2000/12/31 05:03:52 itojun Exp $	*/
d973 1
a973 1
	fdmasks = howmany(s+1, NFDBITS);
@


1.22
log
@merge mistake.  -m is not available in *bsd-current
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.21 2000/12/28 21:39:34 itojun Exp $	*/
d1023 1
d1030 1
d1035 1
d1057 1
@


1.21
log
@indent.  couple of pedant.  from deraadt (sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.20 2000/12/22 05:52:04 itojun Exp $	*/
d2461 1
a2461 1
	    "usage: ping6 [-dfHmnNqvwW"
@


1.20
log
@call seteuid(getuid) too
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.19 2000/12/22 00:33:33 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.108 2000/12/22 05:51:26 itojun Exp $	*/
d99 2
a100 2
 * as IPV6_PKTINFO.  Some people object it (sin6_scope_id specifies *link* while
 * IPV6_PKTINFO specifies *interface*.  Link is defined as collection of
d188 1
d194 1
a194 1
#define DUMMY_PORT      10101
d196 1
a196 1
#define SIN6(s) ((struct sockaddr_in6 *)(s))
d207 3
a209 3
struct addrinfo *res;	
struct sockaddr_in6 dst;        /* who to ping6 */
struct sockaddr_in6 src;        /* src addr of this packet */
d322 2
a323 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:tvwW" ADDOPTS)) != EOF) {
d560 1
a560 1
		
d566 2
a567 1
	if ((s = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)
d579 1
a579 1
			       sizeof(opton)))
d583 1
a583 1
			       sizeof(opton)))
d588 1
a588 1
			       sizeof(opton)))
d592 1
a592 1
			       sizeof(opton)))
d597 1
a597 1
			       sizeof(opton)))
d620 1
d649 1
a649 1
			       &optval, sizeof(optval)) == -1)
d651 16
d681 1
a681 1
				&optval, sizeof(optval)) == -1)
d685 1
a685 1
				&optval, sizeof(optval)) == -1)
d692 1
a692 1
				&optval, sizeof(optval)) == -1)
d712 1
a712 1
			sizeof(filt)) < 0)
d723 1
a723 1
			       sizeof(opton)))
d727 1
a727 1
			       sizeof(opton)))
d736 1
a736 1
			       &optval, sizeof(optval)) == -1)
d774 1
a774 1
			    errx(1, "%s: invalid interface name", ifname);
d815 1
a815 1
				       IPV6_RTHDR_TYPE_0, argc - 1);
d820 1
a820 1
								 IPV6_RTHDR_TYPE_0)) == 0)
d827 2
a828 1
			if ((error = getaddrinfo(argv[hops], NULL, &hints, &iaip)))
d832 1
a832 1
				     "bad addr family of an intermediate addr");
d836 1
a836 1
					  &(SIN6(iaip->ai_addr))->sin6_addr))
d840 2
a841 2
					    &(SIN6(iaip->ai_addr))->sin6_addr,
					    IPV6_RTHDR_LOOSE))
d860 1
a860 1
		
d877 1
a877 1
			       (void *)pktinfo, sizeof(*pktinfo)))
d882 1
a882 1
			       (void *)&hoplimit, sizeof(hoplimit)))
d887 1
a887 1
			       (void *)rthdr, (rthdr->ip6r_len + 1) << 3))
d892 1
a892 2
			       (void *)smsghdr.msg_control,
			       smsghdr.msg_controllen)) {
a893 1
		}
d895 1
a895 1
				
d898 1
a898 1
	
d910 1
a910 1
			       sizeof(sockbufsize)) < 0)
d913 1
a913 1
			       sizeof(sockbufsize)) < 0)
d926 2
a927 1
		setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&hold, sizeof(hold));
d935 1
a935 1
		       sizeof(optval)) < 0)
d939 1
a939 1
		       sizeof(optval)) < 0)
d945 1
a945 1
		       sizeof(optval)) < 0)
d949 1
a949 1
		       sizeof(optval)) < 0)
d1086 2
a1087 1
		memcpy(nip->icmp6_ni_nonce, nonce, sizeof(nip->icmp6_ni_nonce));
d1101 2
a1102 1
		memcpy(nip->icmp6_ni_nonce, nonce, sizeof(nip->icmp6_ni_nonce));
d1113 2
a1114 1
		memcpy(nip->icmp6_ni_nonce, nonce, sizeof(nip->icmp6_ni_nonce));
d1128 2
a1129 1
		memcpy(nip->icmp6_ni_nonce, nonce, sizeof(nip->icmp6_ni_nonce));
d1198 1
d1231 1
a1231 1
				(void)snprintf(cresult, sizeof(cresult),
d1233 2
d1569 1
a1569 1
	       (unsigned int)ext->ip6h_len, (unsigned long)extlen);
d1574 1
a1574 1
					    &type, &len, &databuf);
d1585 1
a1585 1
						   &value4, sizeof(value4));
d1587 1
a1587 1
			       (unsigned int)ntohl(value4));
d1594 1
a1594 1
			       ntohs(value2));
d1598 1
a1598 1
			       type, (unsigned long)len);
d1625 1
a1625 1
	       rh->ip6r_len, (rh->ip6r_len + 1) << 3, rh->ip6r_type);
d1637 2
a1638 1
			if (!inet_ntop(AF_INET6, in6, ntopbuf, sizeof(ntopbuf)))
d1645 1
a1645 1
	
d1647 1
d1676 3
a1678 1
				v >>= 4; off += 4; continue;
d1680 3
a1682 1
				v >>= 3; off += 3; continue;
d1684 3
a1686 1
				v >>= 2; off += 2; continue;
d1688 3
a1690 1
				v >>= 1; off += 1; continue;
d1749 2
a1750 1
			if (sizeof(cbit) + ntohs(cbit.words) * sizeof(v) > clen)
d1754 2
a1755 1
			if (cur + clen * 8 + (u_long)ntohs(cbit.skip) * 32 > MAXQTYPES)
d1813 2
a1814 1
			ttl = ntohl(*(u_int32_t *)cp); /* XXX: alignment? */
d1906 2
d1909 1
d2008 1
a2008 1
				     "Unreachable\n");
d2029 1
a2029 1
			     (int)ntohl(icp->icmp6_mtu));
d2064 1
a2064 1
			     (int)ntohl(icp->icmp6_pptr));
d2138 2
a2139 1
				    inet_ntop(AF_INET6, ni + 1, ntop_buf, sizeof(ntop_buf)) != NULL) {
d2158 2
a2159 1
				if (dnsdecode(&cp, end, NULL, dnsname, sizeof(dnsname)) != NULL)
d2166 2
a2167 1
				    inet_ntop(AF_INET, ni + 1, ntop_buf, sizeof(ntop_buf)) != NULL) {
d2234 2
a2235 3
	       (ip6->ip6_vfc & IPV6_VERSION_MASK) >> 4, tc, (int)ntohl(flow),
	       ntohs(ip6->ip6_plen),
	       ip6->ip6_nxt, ip6->ip6_hlim);
d2320 2
a2321 1
			printf("ICMP6: type = %d, code = %d\n", *cp, *(cp + 1));
d2372 1
a2372 1
/* xxx */	
d2402 2
a2403 2
	if (setsockopt(s, IPPROTO_IPV6, IPV6_IPSEC_POLICY,
			buf, ipsec_get_policylen(buf)) < 0)
d2420 2
a2421 1
	char l;
d2429 1
a2429 4
	if (l > 63)
		return NULL;	/*label too long*/
#ifdef DIAGNOSTIC
	if (sizeof(hbuf) - 1 > l)
a2430 1
#endif
d2442 2
a2443 1
	MD5Update(&ctxt, &l, sizeof(l));
d2461 1
a2461 1
"usage: ping6 [-dfHnNqvwW"
d2463 1
a2463 1
		      "R"
d2467 1
a2467 1
		      "] [-P policy"
d2469 2
a2470 1
		      "AE"
d2472 4
a2475 4
#endif		
		      "] [-a [aAclsg]] [-b sockbufsiz] [-c count] \n\
             [-I interface] [-i wait] [-l preload] [-p pattern] [-S sourceaddr]\n\
             [-s packetsize] [-h hoplimit] [hops...] host\n");
@


1.19
log
@revoke root privilege earliest possible
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.18 2000/12/02 02:56:50 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.107 2000/12/22 00:32:44 itojun Exp $	*/
d600 1
@


1.18
log
@sync with latest kame.
- validate strdup() error in argument parsing.
- use strlcat in complex string manipulation
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.17 2000/11/11 00:45:38 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.105 2000/12/02 02:48:41 itojun Exp $	*/
d564 38
a635 3
	if ((s = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)
		err(1, "socket");

a696 1
	/* TODO: implement parsing routine */
a707 23
#endif
#ifdef IPV6_RECVHOPOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &opton,
			       sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVHOPOPTS)");
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPOPTS, &opton,
			       sizeof(opton)))
			err(1, "setsockopt(IPV6_HOPOPTS)");
#endif
#ifdef IPV6_RECVDSTOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &opton,
			       sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVDSTOPTS)");
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_DSTOPTS, &opton,
			       sizeof(opton)))
			err(1, "setsockopt(IPV6_DSTOPTS)");
#endif
#ifdef IPV6_RECVRTHDRDSTOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDRDSTOPTS, &opton,
			       sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVRTHDRDSTOPTS)");
@


1.17
log
@improve spec conformance of node information query (07).
make sure to check scoped address right on PMTUD.
sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.16 2000/11/10 18:12:07 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.99 2000/11/08 09:55:45 itojun Exp $	*/
d487 7
a493 5
			if (!strncmp("in", optarg, 2))
				policy_in = strdup(optarg);
			else if (!strncmp("out", optarg, 3))
				policy_out = strdup(optarg);
			else
d1158 1
a1158 1
	int i, l;
a1159 2
	char *q;
	const char *eq;
d1164 1
a1164 2
	q = buf;
	eq = buf + bufsiz;
d1171 1
a1171 1
			if (q >= eq - 1)
a1172 1
			*q++ = '.';
d1187 1
a1187 1
			if (eq - q < strlen(cresult) + 1)
a1188 2
			strcpy(q, cresult);	/*XXX should be strlcpy*/
			q += strlen(q);
d1194 3
a1196 1
				if (eq - q < (isprint(*cp) ? 2 : 5))
a1197 2
				l = snprintf(q, eq - q,
				    isprint(*cp) ? "%c" : "\\%03o", *cp & 0xff);
a1198 1
				q += l;
a1202 2
	if (q >= eq)
		return NULL;	/*result overrun*/
a1205 1
	*q = '\0';
d1797 3
d1817 3
d2051 1
a2051 1
		(void)printf("New Target: %s", ntop_buf);
@


1.16
log
@sync with kame.
- allow -s (data len) that are < 8.
- more fflush.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.15 2000/10/12 14:13:10 itojun Exp $	*/
d255 1
d265 1
d313 1
a313 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:tvwW")) != EOF)
d316 1
a316 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:tvwWP:")) != EOF)
d318 1
a318 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:tvwWAE")) != EOF)
d321 2
a322 1
	{
d1088 2
a1089 1
		nip->ni_flags = 0;	/* do not support compressed bitmap */
d1365 1
a1365 21
			printf("NodeInfo Supported Qtypes");
			if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) != 0) {
				printf(", compressed bitmap");
				break;
			} else {
				size_t clen;
				u_int32_t v;
				cp = (u_char *)(ni + 1);
				clen = (size_t)(end - cp);
				if (clen == 0 || clen > 8192 || clen % 4) {
					printf(", invalid length(%lu)",
					    (u_long)clen);
					break;
				}
				printf(", bitmap = 0x");
				for (dp = end - 4; dp >= cp; dp -= 4) {
					memcpy(&v, dp, sizeof(v));
					v = (u_int32_t)ntohl(v);
					printf("%08x", v);
				}
			}
d1625 105
d1736 1
a1736 1
	struct in6_addr *ia6 = (struct in6_addr *)(ni + 1);
d1738 1
d1757 37
a1793 3
	for (; nilen > 0; nilen -= sizeof(*ia6), ia6 += 1) {
		printf("  %s\n",
		       inet_ntop(AF_INET6, ia6, ntop_buf, sizeof(ntop_buf)));
@


1.15
log
@don't segv on too many arguments.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.14 2000/10/12 09:02:19 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.93 2000/10/12 10:27:00 itojun Exp $	*/
d218 1
a225 1
int hoplimit = -1;		/* hoplimit */
d562 6
a567 4
	if ((options & F_NOUSERDATA) == 0 &&
	    datalen >= sizeof(struct timeval)) {
		/* can we time transfer */
		timing = 1;
d1553 2
a1554 2
	printf("nxt %u, len %u (%d bytes)\n", ext->ip6h_nxt,
	       ext->ip6h_len, extlen);
d1582 2
a1583 1
			printf("    Received Opt %u len %u\n", type, len);
d1791 1
@


1.15.2.1
log
@Pull current ping6 into 2.8 branch (revisions 1.16 - 1.28)
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.28 2001/02/04 00:37:21 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.121 2001/02/01 16:43:01 itojun Exp $	*/
d99 2
a100 2
 * as IPV6_PKTINFO.  Some people object it (sin6_scope_id specifies *link*
 * while IPV6_PKTINFO specifies *interface*.  Link is defined as collection of
a187 1
#define F_NOMINMTU	0x100000
d193 1
a193 1
#define DUMMY_PORT	10101
d195 1
a195 1
#define SIN6(s)	((struct sockaddr_in6 *)(s))
d206 3
a208 3
struct addrinfo *res;
struct sockaddr_in6 dst;	/* who to ping6 */
struct sockaddr_in6 src;	/* src addr of this packet */
a217 1
int hoplimit = -1;		/* hoplimit */
d225 1
a243 7
volatile int signo;
volatile sig_atomic_t seenalrm;
volatile sig_atomic_t seenint;
#ifdef SIGINFO
volatile sig_atomic_t seeninfo;
#endif

d248 2
a249 2
void	 onsignal __P((int));
void	 retransmit __P((void));
d252 1
a252 1
const char *pr_addr __P((struct sockaddr *, int));
a254 1
void	 pr_suptypes __P((struct icmp6_nodeinfo *, size_t));
a263 1
int	 pr_bitrange __P((u_int32_t, int, int));
d278 1
a278 1
	struct timeval timeout, *tv;
d294 3
d311 1
a311 1
#define ADDOPTS
d314 1
a314 1
#define ADDOPTS	"P:"
d316 1
a316 1
#define ADDOPTS	"AE"
d319 1
a319 3
	while ((ch = getopt(argc, argv,
	    "a:b:c:dfHh:I:i:l:nNp:qRS:s:tvwW" ADDOPTS)) != EOF) {
#undef ADDOPTS
a348 1
#ifdef NI_NODEADDR_FLAG_ANYCAST
a350 5
#else
					errx(1,
"-a A is not supported on the platform");
					/*NOTREACHED*/
#endif
d484 5
a488 7
			if (!strncmp("in", optarg, 2)) {
				if ((policy_in = strdup(optarg)) == NULL)
					errx(1, "strdup");
			} else if (!strncmp("out", optarg, 3)) {
				if ((policy_out = strdup(optarg)) == NULL)
					errx(1, "strdup");
			} else
d553 1
a553 1

a558 40
	if ((s = socket(res->ai_family, res->ai_socktype,
	    res->ai_protocol)) < 0)
		err(1, "socket");

	/*
	 * let the kerel pass extension headers of incoming packets,
	 * for privileged socket options
	 */
	if ((options & F_VERBOSE) != 0) {
		int opton = 1;

#ifdef IPV6_RECVHOPOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVHOPOPTS)");
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPOPTS, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_HOPOPTS)");
#endif
#ifdef IPV6_RECVDSTOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVDSTOPTS)");
#else  /* old adv. API */
		if (setsockopt(s, IPPROTO_IPV6, IPV6_DSTOPTS, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_DSTOPTS)");
#endif
#ifdef IPV6_RECVRTHDRDSTOPTS
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDRDSTOPTS, &opton,
		    sizeof(opton)))
			err(1, "setsockopt(IPV6_RECVRTHDRDSTOPTS)");
#endif
	}

	/* revoke root privilege */
	seteuid(getuid());
	setuid(getuid());

d562 4
a565 6
	if ((options & F_NOUSERDATA) == 0) {
		if (datalen >= sizeof(struct timeval)) {
			/* we can time transfer */
			timing = 1;
		} else
			timing = 0;
a570 1

d580 2
a581 2
	gettimeofday(&timeout, NULL);
	srand((unsigned int)(timeout.tv_sec ^ timeout.tv_usec ^ (long)ident));
d591 3
d602 1
a602 1
		    &optval, sizeof(optval)) == -1)
a603 16
#ifdef IPV6_USE_MIN_MTU
	if ((options & F_NOMINMTU) == 0) {
		optval = 1;
		if (setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU,
		    &optval, sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_USE_MIN_MTU)");
	}
#ifdef IPV6_RECVPATHMTU
	else {
		optval = 1;
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPATHMTU,
		    &optval, sizeof(optval)) == -1)
			err(1, "setsockopt(IPV6_RECVPATHMTU)");
	}
#endif /* IPV6_RECVPATHMTU */
#endif /* IPV6_USE_MIN_MTU */
d618 1
a618 1
		    &optval, sizeof(optval)) == -1)
d622 1
a622 1
		    &optval, sizeof(optval)) == -1)
d629 1
a629 1
		    &optval, sizeof(optval)) == -1)
d649 1
a649 1
	    sizeof(filt)) < 0)
d655 1
d661 1
a661 1
		    sizeof(opton)))
d665 1
a665 1
		    sizeof(opton)))
d668 23
d697 1
a697 1
		    &optval, sizeof(optval)) == -1)
d735 1
a735 1
			errx(1, "%s: invalid interface name", ifname);
d776 1
a776 1
		    IPV6_RTHDR_TYPE_0, argc - 1);
d781 1
a781 1
		    IPV6_RTHDR_TYPE_0)) == 0)
d788 1
a788 2
			if ((error = getaddrinfo(argv[hops], NULL, &hints,
			    &iaip)))
d792 1
a792 1
				    "bad addr family of an intermediate addr");
d796 1
a796 1
			    &(SIN6(iaip->ai_addr))->sin6_addr))
d800 2
a801 2
			    &(SIN6(iaip->ai_addr))->sin6_addr,
			    IPV6_RTHDR_LOOSE))
d820 1
a820 1

d837 1
a837 1
		    (void *)pktinfo, sizeof(*pktinfo)))
d842 1
a842 1
		    (void *)&hoplimit, sizeof(hoplimit)))
d847 1
a847 1
		    (void *)rthdr, (rthdr->ip6r_len + 1) << 3))
d852 2
a853 1
		    (void *)smsghdr.msg_control, smsghdr.msg_controllen))
d855 1
d857 1
a857 1

d860 1
a860 1

d872 1
a872 1
		    sizeof(sockbufsize)) < 0)
d875 1
a875 1
		    sizeof(sockbufsize)) < 0)
d888 1
a888 2
		setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&hold,
		    sizeof(hold));
d896 1
a896 1
	    sizeof(optval)) < 0)
d900 1
a900 1
	    sizeof(optval)) < 0)
d906 1
a906 1
	    sizeof(optval)) < 0)
d910 1
a910 1
	    sizeof(optval)) < 0)
d915 2
a916 2
	printf("%s --> ", pr_addr((struct sockaddr *)&src, sizeof(src)));
	printf("%s\n", pr_addr((struct sockaddr *)&dst, sizeof(dst)));
d921 1
a921 1
	(void)signal(SIGINT, onsignal);
d923 1
a923 1
	(void)signal(SIGINFO, onsignal);
d927 1
a927 1
		(void)signal(SIGALRM, onsignal);
d929 2
a930 1
		itimer.it_value = interval;
a931 1
		retransmit();
d934 1
a934 1
	fdmasks = howmany(s + 1, NFDBITS) * sizeof(fd_mask);
a937 5
	signo = seenalrm = seenint = 0;
#ifdef SIGINFO
	seeninfo = 0;
#endif

a943 19
		/* signal handling */
		if (seenalrm) {
			retransmit();
			seenalrm = 0;
			continue;
		}
		if (seenint) {
			onint(SIGINT);
			seenint = 0;
			continue;
		}
#ifdef SIGINFO
		if (seeninfo) {
			summary();
			seeninfo = 0;
			continue;
		}
#endif

d948 4
a951 12
			tv = &timeout;
		} else
			tv = NULL;
		memset(fdmaskp, 0, fdmasks);
		FD_SET(s, fdmaskp);
		cc = select(s + 1, fdmaskp, NULL, NULL, tv);
		if (cc < 0) {
			if (errno != EINTR) {
				warn("recvmsg");
				sleep(1);
			}
			continue;
d953 1
a954 1
		fromlen = sizeof(from);
d966 4
a969 6
		cc = recvmsg(s, &m, 0);
		if (cc < 0) {
			if (errno != EINTR) {
				warn("recvmsg");
				sleep(1);
			}
a970 5
		} else {
			/*
			 * an ICMPv6 message (probably an echoreply) arrived.
			 */
			pr_pack(packet, cc, &m);
d972 2
a980 20
void
onsignal(sig)
	int sig;
{
	signo = sig;
	switch (sig) {
	case SIGALRM:
		seenalrm++;
		break;
	case SIGINT:
		seenint++;
		break;
#ifdef SIGINFO
	case SIGINFO:
		seeninfo++;
		break;
#endif
	}
}

d982 1
a982 1
 * retransmit --
d985 1
d987 2
a988 1
retransmit()
d1047 1
a1047 2
		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
d1061 1
a1061 2
		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
d1072 1
a1072 2
		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
d1083 1
a1083 2
		/* we support compressed bitmap */
		nip->ni_flags = NI_SUPTYPE_FLAG_COMPRESS;
d1085 1
a1085 2
		memcpy(nip->icmp6_ni_nonce, nonce,
		    sizeof(nip->icmp6_ni_nonce));
d1150 1
a1150 1
	int i;
d1152 2
a1155 1
	int l;
d1158 2
a1159 1
	*buf = '\0';
d1166 1
a1166 1
			if (strlcat(buf, ".", bufsiz) >= bufsiz)
d1168 1
d1183 1
a1183 1
			if (strlcat(buf, cresult, bufsiz) >= bufsiz)
d1185 2
d1192 3
a1194 1
				l = snprintf(cresult, sizeof(cresult),
a1195 4
				if (l >= sizeof(cresult))
					return NULL;
				if (strlcat(buf, cresult, bufsiz) >= bufsiz)
					return NULL;	/*result overrun*/
d1197 1
d1202 2
d1207 1
d1230 1
a1230 2
	struct sockaddr *from;
	int fromlen;
a1242 9
	if (!mhdr || !mhdr->msg_name ||
	    mhdr->msg_namelen != sizeof(struct sockaddr_in6) ||
	    ((struct sockaddr *)mhdr->msg_name)->sa_family != AF_INET6) {
		if (options & F_VERBOSE)
			warnx("invalid peername\n");
		return;
	}
	from = (struct sockaddr *)mhdr->msg_name;
	fromlen = mhdr->msg_namelen;
d1246 1
a1246 1
			    pr_addr(from, fromlen));
d1296 1
a1296 1
			    pr_addr(from, fromlen), seq);
a1302 1
#ifdef SIN6_LEN
a1303 1
#endif
d1306 1
a1306 3
				(void)printf(" dst=%s",
				    pr_addr((struct sockaddr *)&dstsa,
				    sizeof(dstsa)));
d1337 1
a1337 1
		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));
d1359 21
a1379 1
			pr_suptypes(ni, end - (u_char *)ni);
d1492 1
a1492 1
		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));
d1551 2
a1552 2
	printf("nxt %u, len %u (%lu bytes)\n", ext->ip6h_nxt,
	    (unsigned int)ext->ip6h_len, (unsigned long)extlen);
d1557 1
a1557 1
		    &type, &len, &databuf);
d1568 1
a1568 1
			    &value4, sizeof(value4));
d1570 1
a1570 1
			    (u_int32_t)ntohl(value4));
d1577 1
a1577 1
			    ntohs(value2));
d1580 1
a1580 2
			printf("    Received Opt %u len %lu\n",
			    type, (unsigned long)len);
d1607 1
a1607 1
	    rh->ip6r_len, (rh->ip6r_len + 1) << 3, rh->ip6r_type);
d1619 1
a1619 2
			if (!inet_ntop(AF_INET6, in6, ntopbuf,
			    sizeof(ntopbuf)))
d1626 1
a1626 1

a1627 1

a1637 115
int
pr_bitrange(v, s, ii)
	u_int32_t v;
	int s;
	int ii;
{
	int off;
	int i;

	off = 0;
	while (off < 32) {
		/* shift till we have 0x01 */
		if ((v & 0x01) == 0) {
			if (ii > 1)
				printf("-%u", s + off - 1);
			ii = 0;
			switch (v & 0x0f) {
			case 0x00:
				v >>= 4;
				off += 4;
				continue;
			case 0x08:
				v >>= 3;
				off += 3;
				continue;
			case 0x04: case 0x0c:
				v >>= 2;
				off += 2;
				continue;
			default:
				v >>= 1;
				off += 1;
				continue;
			}
		}

		/* we have 0x01 with us */
		for (i = 0; i < 32 - off; i++) {
			if ((v & (0x01 << i)) == 0)
				break;
		}
		if (!ii)
			printf(" %u", s + off);
		ii += i;
		v >>= i; off += i;
	}
	return ii;
}

void
pr_suptypes(ni, nilen)
	struct icmp6_nodeinfo *ni; /* ni->qtype must be SUPTYPES */
	size_t nilen;
{
	size_t clen;
	u_int32_t v;
	const u_char *cp, *end;
	u_int16_t cur;
	struct cbit {
		u_int16_t words;	/*32bit count*/
		u_int16_t skip;
	} cbit;
#define MAXQTYPES	(1 << 16)
	size_t off;
	int b;

	cp = (u_char *)(ni + 1);
	end = ((u_char *)ni) + nilen;
	cur = 0;
	b = 0;

	printf("NodeInfo Supported Qtypes");
	if (options & F_VERBOSE) {
		if (ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS)
			printf(", compressed bitmap");
		else
			printf(", raw bitmap");
	}

	while (cp < end) {
		clen = (size_t)(end - cp);
		if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) == 0) {
			if (clen == 0 || clen > MAXQTYPES / 8 ||
			    clen % sizeof(v)) {
				printf("???");
				return;
			}
		} else {
			if (clen < sizeof(cbit) || clen % sizeof(v))
				return;
			memcpy(&cbit, cp, sizeof(cbit));
			if (sizeof(cbit) + ntohs(cbit.words) * sizeof(v) >
			    clen)
				return;
			cp += sizeof(cbit);
			clen = ntohs(cbit.words) * sizeof(v);
			if (cur + clen * 8 + (u_long)ntohs(cbit.skip) * 32 >
			    MAXQTYPES)
				return;
		}

		for (off = 0; off < clen; off += sizeof(v)) {
			memcpy(&v, cp + off, sizeof(v));
			v = (u_int32_t)ntohl(v);
			b = pr_bitrange(v, (int)(cur + off * 8), b);
		}
		/* flush the remaining bits */
		b = pr_bitrange(0, (int)(cur + off * 8), b);

		cp += clen;
		cur += clen * 8;
		if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) != 0)
			cur += ntohs(cbit.skip) * 32;
	}
}
d1644 1
a1644 1
	u_char *cp = (u_char *)(ni + 1);
a1645 1
	int withttl = 0;
d1664 3
a1666 38

	/*
	 * In icmp-name-lookups 05 and later, TTL of each returned address
	 * is contained in the resposne. We try to detect the version
	 * by the length of the data, but note that the detection algorithm
	 * is incomplete. We assume the latest draft by default.
	 */
	if (nilen % (sizeof(u_int32_t) + sizeof(struct in6_addr)) == 0)
		withttl = 1;
	while (nilen > 0) {
		u_int32_t ttl;

		if (withttl) {
			/* XXX: alignment? */
			ttl = (u_int32_t)ntohl(*(u_int32_t *)cp);
			cp += sizeof(u_int32_t);
			nilen -= sizeof(u_int32_t);
		}

		if (inet_ntop(AF_INET6, cp, ntop_buf, sizeof(ntop_buf)) ==
		    NULL)
			strncpy(ntop_buf, "?", sizeof(ntop_buf));
		printf("  %s", ntop_buf);
		if (withttl) {
			if (ttl == 0xffffffff) {
				/*
				 * XXX: can this convention be applied to all
				 * type of TTL (i.e. non-ND TTL)?
				 */
				printf("(TTL=infty)");
			}
			else
				printf("(TTL=%u)", ttl);
		}
		putchar('\n');

		nilen -= sizeof(struct in6_addr);
		cp += sizeof(struct in6_addr);
a1677 3
		if (cm->cmsg_len == 0)
			return(-1);

a1694 3
		if (cm->cmsg_len == 0)
			return(NULL);

d1721 12
a1787 1
	(void)fflush(stdout);
d1827 1
a1827 1
			    "Unreachable\n");
d1848 1
a1848 1
		    (int)ntohl(icp->icmp6_mtu));
d1883 1
a1883 1
		    (u_int32_t)ntohl(icp->icmp6_pptr));
d1925 1
a1925 1
		(void)printf(" New Target: %s", ntop_buf);
d1957 1
a1957 2
				    inet_ntop(AF_INET6, ni + 1, ntop_buf,
				    sizeof(ntop_buf)) != NULL) {
d1976 1
a1976 2
				if (dnsdecode(&cp, end, NULL, dnsname,
				    sizeof(dnsname)) != NULL)
d1983 1
a1983 2
				    inet_ntop(AF_INET, ni + 1, ntop_buf,
				    sizeof(ntop_buf)) != NULL) {
d2050 3
a2052 2
	    (ip6->ip6_vfc & IPV6_VERSION_MASK) >> 4, tc, (u_int32_t)ntohl(flow),
	    ntohs(ip6->ip6_plen), ip6->ip6_nxt, ip6->ip6_hlim);
d2067 2
a2068 3
pr_addr(addr, addrlen)
	struct sockaddr *addr;
	int addrlen;
d2070 2
a2071 2
	static char buf[NI_MAXHOST];
	int flag;
d2073 2
d2076 1
a2076 3
	flag = NI_WITHSCOPEID;
#else
	flag = 0;
a2077 2
	if ((options & F_HOSTNAME) == 0)
		flag |= NI_NUMERICHOST;
d2079 2
a2080 1
	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)
d2137 1
a2137 2
			printf("ICMP6: type = %d, code = %d\n",
			    *cp, *(cp + 1));
d2188 1
a2188 1
/* xxx */
d2218 2
a2219 2
	if (setsockopt(s, IPPROTO_IPV6, IPV6_IPSEC_POLICY, buf,
	    ipsec_get_policylen(buf)) < 0)
d2236 1
a2236 2
	u_int8_t c;
	size_t l;
d2244 4
a2247 1
	if (l > 63 || l > sizeof(hbuf) - 1)
d2249 1
d2261 1
a2261 2
	c = l & 0xff;
	MD5Update(&ctxt, &c, sizeof(c));
d2279 1
a2279 1
	    "usage: ping6 [-dfHmnNqvwW"
d2281 1
a2281 1
	    "R"
d2285 1
a2285 1
	    "] [-P policy"
d2287 1
a2287 2
	    "AE"
#endif
d2289 4
a2292 4
	    "] [-a [aAclsg]] [-b sockbufsiz] [-c count] \n"
            "\t[-I interface] [-i wait] [-l preload] [-p pattern] "
	    "[-S sourceaddr]\n"
            "\t[-s packetsize] [-h hoplimit] [hops...] host\n");
@


1.14
log
@printf-like string format pedant
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.13 2000/10/08 00:27:44 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.92 2000/10/11 00:04:47 itojun Exp $	*/
d302 1
d515 1
a515 1
		ip6optlen += CMSG_SPACE(inet6_rth_space(IPV6_RTHDR_TYPE_0,
d518 1
a518 1
		ip6optlen += inet6_rthdr_space(IPV6_RTHDR_TYPE_0, argc - 1);
d520 5
@


1.13
log
@update DNS label length validation.  check inet_ntop() errors.  sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.12 2000/10/06 10:58:19 art Exp $	*/
/*	$KAME: ping6.c,v 1.91 2000/10/07 06:23:06 itojun Exp $	*/
d783 1
a783 1
				errx(1, gai_strerror(error));
@


1.12
log
@Avoid fd_set overflow. (just like in ping).
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.11 2000/08/14 02:50:04 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.74 2000/08/14 02:48:14 itojun Exp $	*/
a111 1
#include <netinet/in_systm.h>
a112 2
#include <netinet/ip.h>
#include <netinet/ip_var.h>
d123 1
a123 1
#ifdef __OpenBSD__
d232 1
a232 1
#ifdef __OpenBSD__
d675 1
a675 1
#else  /* olad adv. API */
d784 1
a784 1
			if (SIN6(res->ai_addr)->sin6_family != AF_INET6)
d798 1
d916 1
d918 1
d1265 1
a1265 1
#ifdef __OpenBSD__
d1432 3
a1434 1
					/* case of refusion, unkown */
d1612 5
a1616 4
		else
			printf("   [%d]%s\n", i,
			       inet_ntop(AF_INET6, in6,
					 ntopbuf, sizeof(ntopbuf)));
d1652 1
a1652 1
		if (ni->ni_flags & NI_NODEADDR_FLAG_ALL)
d1770 1
a1770 1
#ifdef __OpenBSD__
d1912 8
a1919 6
		(void)printf("Destination: %s",
			     inet_ntop(AF_INET6, &red->nd_rd_dst,
				       ntop_buf, sizeof(ntop_buf)));
		(void)printf("New Target: %s",
			     inet_ntop(AF_INET6, &red->nd_rd_target,
				       ntop_buf, sizeof(ntop_buf)));
d2047 6
a2052 4
	printf("%s->", inet_ntop(AF_INET6, &ip6->ip6_src,
				  ntop_buf, sizeof(ntop_buf)));
	printf("%s\n", inet_ntop(AF_INET6, &ip6->ip6_dst,
				 ntop_buf, sizeof(ntop_buf)));
d2227 1
d2234 5
a2238 4
	p = name;
	while (p && *p && *p != '.')
		p++;
	if (p - name > 63)
d2240 11
a2250 1
	l = p - name;
d2256 1
a2256 1
	MD5Update(&ctxt, name, p - name);
@


1.11
log
@correct truncated FQDN printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.10 2000/08/13 20:17:00 itojun Exp $	*/
d283 2
a284 1
	fd_set fdset;
d928 4
a931 3
	FD_ZERO(&fdset);
	timeout.tv_sec = 0;
	timeout.tv_usec = 10000;
d940 5
a944 2
			FD_SET(s, &fdset);
			if (select(s + 1, &fdset, NULL, NULL, &timeout) < 1)
@


1.10
log
@recover less-than-1 interval support with -i.
completely in sync with kame (do not nuke #ifdef please).
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.9 2000/06/30 16:00:10 millert Exp $	*/
/*	$KAME: ping6.c,v 1.72 2000/08/13 20:12:48 itojun Exp $	*/
d1400 1
a1400 1
					if (cp + 1 < end && !*cp &&
a1742 1
	register int i;
@


1.9
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 2
a2 2
/*	$OpenBSD: ping6.c,v 1.8 2000/06/20 20:00:03 itojun Exp $	*/
/*	$KAME: ping6.c,v 1.55 2000/06/12 16:18:32 itojun Exp $	*/
d119 1
d126 1
d128 1
d140 1
d142 3
d151 2
a152 1
#define ICMP6_NIRLEN	(ICMP6ECHOLEN + 12) /* 64 bits of nonce + 32 bits ttl */
d190 2
d219 1
d227 1
a227 1
double interval = 1;		/* interval between packets */
d235 1
d237 1
d259 4
a278 4
#if defined(__FreeBSD__) && __FreeBSD__ < 3
	extern int optind;
	extern char *optarg;
#endif
d296 3
d303 1
d312 1
a312 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:vwW")) != -1)
d315 1
a315 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:vwWP:")) != -1)
d317 1
a317 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:vwWAE")) != -1)
d321 39
a359 39
		switch(ch) {
		 case 'a':
		 {
			 char *cp;

			 options |= F_NODEADDR;
			 datalen = 2048; /* XXX: enough? */
			 for (cp = optarg; *cp != '\0'; cp++) {
				 switch(*cp) {
				 case 'a':
					 naflags |= NI_NODEADDR_FLAG_ALL;
					 break;
				 case 'c':
				 case 'C':
					 naflags |= NI_NODEADDR_FLAG_COMPAT;
					 break;
				 case 'l':
				 case 'L':
					 naflags |= NI_NODEADDR_FLAG_LINKLOCAL;
					 break;
				 case 's':
				 case 'S':
					 naflags |= NI_NODEADDR_FLAG_SITELOCAL;
					 break;
				 case 'g':
				 case 'G':
					 naflags |= NI_NODEADDR_FLAG_GLOBAL;
					 break;
				 case 'A': /* experimental. not in the spec */
					 naflags |= NI_NODEADDR_FLAG_ANYCAST;
					 break;
				 default:
					 usage();
					 /*NOTREACHED*/
				 }
			 }
			 break;
		 }
		 case 'b':
d401 17
a417 12
			interval = strtod(optarg, NULL);

			if (interval <= 0 || interval >= INT_MAX)
				errx(1, "bad timing interval: %s", optarg);

			if (interval < 1)
				if (getuid())
					errx(1, "%s: only root may use interval < 1s", strerror(EPERM));

			if (interval < 0.01)
				interval = 0.01;

d460 1
a460 1
			if (datalen > MAXDATALEN)
d464 5
d474 1
d478 1
d515 4
a518 3
#ifdef USE_SIN6_SCOPE_ID
		ip6optlen += CMSG_SPACE(inet6_rth_space(IPV6_RTHDR_TYPE_0, argc - 1));
#else  /* old advanced API */
d558 3
a560 1
	if (datalen >= sizeof(struct timeval))	/* can we time transfer */
d562 5
d571 1
a571 1
		for (i = 8; i < datalen; ++i)
d575 11
d588 1
a588 1
	  err(1, "socket");
d637 1
a637 1
		    (options & F_NODEADDR))
d785 1
a785 1
				errx(1, "%s", gai_strerror(error));
d921 1
a921 2
		itimer.it_interval.tv_sec = interval;
		itimer.it_interval.tv_usec = 0;
d1020 2
d1024 1
a1025 1
	icp->icmp6_code = 0;
d1027 2
a1028 5
	icp->icmp6_seq = ntransmitted++;		/* htons later */
	icp->icmp6_id = htons(ident);			/* ID */

	CLR(icp->icmp6_seq % mx_dup_ck);
	icp->icmp6_seq = htons(icp->icmp6_seq);
d1033 6
a1038 6
		/* XXX: overwrite icmp6_id */
		((struct icmp6_nodeinfo *)icp)->ni_qtype = htons(NI_QTYPE_FQDN);
		((struct icmp6_nodeinfo *)icp)->ni_flags = htons(0);
		if (timing)
			(void)gettimeofday((struct timeval *)
					   &outpack[ICMP6ECHOLEN], NULL);
d1046 7
a1052 7
		/* code field is always 0 */
		/* XXX: overwrite icmp6_id */
		((struct icmp6_nodeinfo *)icp)->ni_qtype = htons(NI_QTYPE_FQDN);
		((struct icmp6_nodeinfo *)icp)->ni_flags = htons(0);
		if (timing)
			(void)gettimeofday((struct timeval *)
					   &outpack[ICMP6ECHOLEN], NULL);
d1058 6
a1063 7
		/* XXX: overwrite icmp6_id */
		((struct icmp6_nodeinfo *)icp)->ni_qtype =
		    htons(NI_QTYPE_NODEADDR);
		((struct icmp6_nodeinfo *)icp)->ni_flags = htons(0);
		if (timing)
			(void)gettimeofday((struct timeval *)
					   &outpack[ICMP6ECHOLEN], NULL);
d1068 11
a1078 3
		((struct icmp6_nodeinfo *)icp)->ni_flags = naflags;
	}
	else {
d1080 3
d1109 92
d1216 1
d1227 2
d1239 1
d1251 2
a1252 5
	if (icp->icmp6_type == ICMP6_ECHO_REPLY) {
		/* XXX the following line overwrites the original packet */
		icp->icmp6_seq = ntohs(icp->icmp6_seq);
		if (ntohs(icp->icmp6_id) != ident)
			return;			/* It was not our ECHO */
d1260 1
d1262 1
d1269 1
a1269 1
		if (TST(icp->icmp6_seq % mx_dup_ck)) {
d1274 1
a1274 1
			SET(icp->icmp6_seq % mx_dup_ck);
d1285 1
a1285 2
				     pr_addr(from),
				     icp->icmp6_seq);
d1311 16
a1326 2
	} else if (icp->icmp6_type == ICMP6_NI_REPLY) { /* ICMP6_NI_REPLY */
		struct icmp6_nodeinfo *ni = (struct icmp6_nodeinfo *)(buf + off);
d1328 14
a1341 2
		(void)printf("%d bytes from %s: ", cc,
			     pr_addr(from));
d1343 32
a1374 12
		switch(ntohs(ni->ni_qtype)) {
		 case NI_QTYPE_NOOP:
			 printf("NodeInfo NOOP");
			 break;
		 case NI_QTYPE_SUPTYPES:
			 printf("NodeInfo Supported Qtypes");
			 break;
		 case NI_QTYPE_NODEADDR:
			 pr_nodeaddr(ni, end - (u_char *)ni);
			 break;
		 case NI_QTYPE_FQDN:
		 default:	/* XXX: for backward compatibility */
d1382 1
a1382 1
				cp++;
d1388 1
d1390 4
a1393 23
					i = *cp++;
					if (i) {
						if (i > end - cp) {
							printf("???");
							break;
						}
						while (i-- && cp < end) {
							safeputc(*cp & 0xff);
							cp++;
						}
						if (cp + 1 < end && *cp)
							printf(".");
					} else {
						if (cp == end) {
							/* FQDN */
							printf(".");
						} else if (cp + 1 == end &&
							   *cp == '\0') {
							/* truncated */
						} else {
							/* invalid */
							printf("???");
						}
d1396 11
d1415 1
a1415 1
				switch(ni->ni_code) {
d1433 1
a1433 1
				if (!(ni->ni_flags & NI_FQDN_FLAG_VALIDTTL))
d1435 2
a1436 2
						     (int)ttl);
				else {
d1439 1
a1439 1
						    ttl);
d1465 2
a1466 2
						     buf[off + ICMP6_NIRLEN],
						     (u_long)cc - off - ICMP6_NIRLEN - 1);
d1472 1
a1472 1
		 fqdnend:
d1479 1
a1479 2
		(void)printf("%d bytes from %s: ", cc,
			     pr_addr(from));
d1503 1
a1503 1
		switch(cm->cmsg_type) {
d1636 7
a1642 7
		switch(ni->ni_code) {
		 case ICMP6_NI_REFUSED:
			 (void)printf("refused");
			 break;
		 case ICMP6_NI_UNKNOWN:
			 (void)printf("unknown qtype");
			 break;
d1763 1
d1768 5
d1777 5
a1781 13
#ifdef notdef
static char *ttab[] = {
	"Echo Reply",		/* ip + seq + udata */
	"Dest Unreachable",	/* net, host, proto, port, frag, sr + IP */
	"Source Quench",	/* IP */
	"Redirect",		/* redirect type, gateway, + IP  */
	"Echo",
	"Time Exceeded",	/* transit, frag reassem + IP */
	"Parameter Problem",	/* pointer + IP */
	"Timestamp",		/* id + seq + three timestamps */
	"Timestamp Reply",	/* " */
	"Info Request",		/* id + sq */
	"Info Reply"		/* " */
d1783 6
a1788 1
#endif
d1800 5
d1806 1
a1806 1
	switch(icp->icmp6_type) {
d1808 1
a1808 1
		switch(icp->icmp6_code) {
d1839 1
a1839 1
		switch(icp->icmp6_code) {
d1855 13
a1867 13
		switch(icp->icmp6_code) {
		 case ICMP6_PARAMPROB_HEADER:
			 (void)printf("Erroneous Header ");
			 break;
		 case ICMP6_PARAMPROB_NEXTHEADER:
			 (void)printf("Unknown Nextheader ");
			 break;
		 case ICMP6_PARAMPROB_OPTION:
			 (void)printf("Unrecognized Option ");
			 break;
		 default:
			 (void)printf("Bad code(%d) ", icp->icmp6_code);
			 break;
d1903 1
a1903 3
	{
		struct nd_redirect *red = (struct nd_redirect *)icp;

a1911 1
	}
d1915 64
d1983 28
d2058 1
a2058 1
#ifdef KAME_SCOPEID
d2062 5
a2066 4
	getnameinfo((struct sockaddr *)addr, addr->sin6_len, buf, sizeof(buf),
		NULL, 0, flag);

	return (buf);
d2092 20
a2111 20
		 case IPPROTO_HOPOPTS:
			 printf("HBH ");
			 hlen = (((struct ip6_hbh *)cp)->ip6h_len+1) << 3;
			 nh = ((struct ip6_hbh *)cp)->ip6h_nxt;
			 break;
		 case IPPROTO_DSTOPTS:
			 printf("DSTOPT ");
			 hlen = (((struct ip6_dest *)cp)->ip6d_len+1) << 3;
			 nh = ((struct ip6_dest *)cp)->ip6d_nxt;
			 break;
		 case IPPROTO_FRAGMENT:
			 printf("FRAG ");
			 hlen = sizeof(struct ip6_frag);
			 nh = ((struct ip6_frag *)cp)->ip6f_nxt;
			 break;
		 case IPPROTO_ROUTING:
			 printf("RTHDR ");
			 hlen = (((struct ip6_rthdr *)cp)->ip6r_len+1) << 3;
			 nh = ((struct ip6_rthdr *)cp)->ip6r_nxt;
			 break;
d2113 25
a2137 26
		 case IPPROTO_AH:
			 printf("AH ");
			 hlen = (((struct ah *)cp)->ah_len+2) << 2;
			 nh = ((struct ah *)cp)->ah_nxt;
			 break;
#endif
		 case IPPROTO_ICMPV6:
			 printf("ICMP6: type = %d, code = %d\n",
				*cp, *(cp + 1));
			 return;
		 case IPPROTO_ESP:
			 printf("ESP\n");
			 return;
		 case IPPROTO_TCP:
			 printf("TCP: from port %u, to port %u (decimal)\n",
				(*cp * 256 + *(cp + 1)),
				(*(cp + 2) * 256 + *(cp + 3)));
			 return;
		 case IPPROTO_UDP:
			 printf("UDP: from port %u, to port %u (decimal)\n",
				(*cp * 256 + *(cp + 1)),
				(*(cp + 2) * 256 + *(cp + 3)));
			 return;
		 default:
			 printf("Unknown Header(%d)\n", nh);
			 return;
d2236 2
a2237 4
	bzero(&in6, sizeof(in6));
	in6.s6_addr[0] = 0xff;
	in6.s6_addr[1] = 0x02;
	in6.s6_addr[11] = 0x02;
@


1.8
log
@pedant; getopt(3) returns -1 instead of EOF.  from aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.7 2000/06/12 17:24:27 itojun Exp $	*/
d557 1
a557 1
			errx(1, ipsec_strerror());
d559 1
a559 1
			errx(1, ipsec_strerror());
d737 1
a737 1
				errx(1, gai_strerror(error));
d1915 1
a1915 1
		errx(1, ipsec_strerror());
@


1.7
log
@update icmp6 name lookup code to conform to 05 draft.  previous code
was 03/05 chimera.

ping6: -n by default due to too many false error report due to too long
reverse query delay.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.6 2000/06/08 13:58:21 itojun Exp $	*/
d295 1
a295 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:vwW")) != EOF)
d298 1
a298 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:vwWP:")) != EOF)
d300 1
a300 1
	while ((ch = getopt(argc, argv, "a:b:c:dfHh:I:i:l:nNp:qRS:s:vwWAE")) != EOF)
@


1.6
log
@make sure to clear ni_flags on ping6 -w.
@
text
@d1 2
a2 1
/*	$OpenBSD: ping6.c,v 1.5 2000/03/23 11:26:18 hugh Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d137 2
d179 3
d199 1
a199 1
struct addrinfo *res;	        
d254 1
d282 1
a282 1
#endif 
d295 1
a295 1
	while ((ch = getopt(argc, argv, "a:b:c:dfh:I:i:l:np:qRS:s:vwW")) != EOF)
d298 1
a298 1
	while ((ch = getopt(argc, argv, "a:b:c:dfh:I:i:l:np:qRS:s:vwWP:")) != EOF)
d300 1
a300 1
	while ((ch = getopt(argc, argv, "a:b:c:dfh:I:i:l:np:qRS:s:vwWAE")) != EOF)
d303 1
d337 1
d367 3
d410 3
d447 2
d450 1
a450 1
			options |= F_FQDN;
d474 1
d476 1
d480 1
a480 1
	if (argc < 1)
d482 2
d493 8
a500 1
	target = argv[argc - 1];
d504 1
a504 1
	if ((options & F_NUMERIC) == 0)
d588 2
a589 1
		if ((options & F_FQDN) || (options & F_NODEADDR))
d615 1
a615 1
#endif 
d624 1
a624 1
#endif 
d633 1
a633 1
#endif 
d638 1
a638 1
#endif 
d642 1
a642 1
	optval = 1; 
d715 1
a715 1
#endif 
d757 1
a757 1
#endif 
d763 1
a763 1
		/* 
d803 1
a803 1
#endif 
d817 1
a817 1
			warnx("you need -b to increae socket buffer size");
d849 1
a849 1
#endif 
d859 1
a859 1
#endif 
d873 2
a874 3
		itimer.it_interval.tv_sec = (long)interval;
		itimer.it_interval.tv_usec =
		    (long)((interval - itimer.it_interval.tv_sec) * 1000000);
d986 14
d1011 1
a1011 1
		/* code field is always 0 */
d1019 3
a1021 1
		cc = ICMP6_NIQLEN;
d1066 1
d1077 1
d1179 57
a1235 10
			 cp = (u_char *)ni + ICMP6_NIRLEN + 1;
			 while (cp < end) {
				 if (isprint(*cp))
					 putchar(*cp);
				 else
					 printf("\\%03o", *cp & 0xff);
				 cp++;
			 }
			 if (options & F_VERBOSE) {
				 long ttl;
d1237 18
a1254 1
				 (void)printf(" (");
d1256 14
a1269 8
				 switch(ni->ni_code) {
				  case ICMP6_NI_REFUSED:
					  (void)printf("refused,");
					  break;
				  case ICMP6_NI_UNKNOWN:
					  (void)printf("unknwon qtype,");
					  break;
				 }
d1271 14
a1284 27
				 if ((end - (u_char *)ni) < ICMP6_NIRLEN) {
					 /* case of refusion, unkown */
					 goto fqdnend;
				 }
				 ttl = ntohl(*(u_long *)&buf[off+ICMP6ECHOLEN+8]);
				 if (!(ni->ni_flags & NI_FQDN_FLAG_VALIDTTL))
					 (void)printf("TTL=%d:meaningless",
						      (int)ttl);
				 else {
					 if (ttl < 0)
						 (void)printf("TTL=%d:invalid",
							      (int)ttl);
					 else
						 (void)printf("TTL=%d",
							      (int)ttl);
				 }

				 if (buf[off + ICMP6_NIRLEN] !=
				     cc - off - ICMP6_NIRLEN - 1) {
					 (void)printf(",invalid namelen:%d/%lu",
						      buf[off + ICMP6_NIRLEN],
						      (u_long)cc - off - ICMP6_NIRLEN - 1);
				 }
				 putchar(')');
			 }
		  fqdnend:
			 ;
d1301 1
d1771 1
a1771 1
	if (options & F_NUMERIC)
d1926 37
d1967 4
a1970 1
"usage: ping6 [-dfnqvwW"
d1977 1
a1977 1
#endif		      
@


1.5
log
@Support std-dev gathering and fine interval like our regular ping.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.4 2000/02/28 14:06:39 itojun Exp $	*/
d947 1
d960 2
a961 1
		icp->icmp6_data16[0] = htons(NI_QTYPE_FQDN);
d971 3
a973 1
		icp->icmp6_data16[0] = htons(NI_QTYPE_NODEADDR);
@


1.5.2.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.5 2000/03/23 11:26:18 hugh Exp $	*/
d529 1
a529 1
			errx(1, "%s", ipsec_strerror());
d531 1
a531 1
			errx(1, "%s", ipsec_strerror());
d708 1
a708 1
				errx(1, "%s", gai_strerror(error));
d1807 1
a1807 1
		errx(1, "%s", ipsec_strerror());
@


1.4
log
@add support for "ping6 -a c".
(new feature in draft-ietf-ipngwg-icmp-name-lookups-05.txt)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.3 2000/02/16 05:59:20 itojun Exp $	*/
d124 1
d210 1
a210 1
int interval = 1;		/* interval between packets */
d218 1
d372 12
a383 4
			interval = strtol(optarg, &e, 10);
			if (interval <= 0 || *optarg == '\0' || *e != '\0')
				errx(1,
				    "illegal timing interval -- %s", optarg);
d844 3
a846 2
		itimer.it_interval.tv_sec = interval;
		itimer.it_interval.tv_usec = 0;
d1061 1
d1465 6
a1470 3
		i = 1000.0 * tsum / (nreceived + nrepeats);
		(void)printf("round-trip min/avg/max = %g/%g/%g ms\n",
		    tmin, ((double)i) / 1000.0, tmax);
@


1.3
log
@sync with more recent kame.  uses getnameinfo(3) as much as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.2 2000/01/22 20:25:05 deraadt Exp $	*/
d306 4
d1815 2
a1816 2
		      "] [-a [alsg]] [-b sockbufsiz] [-c count] [-I interface]\n\
             [-i wait] [-l preload] [-p pattern] [-S sourceaddr]\n\
@


1.2
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: ping6.c,v 1.1 1999/12/11 08:43:19 itojun Exp $	*/
d98 1
a98 1
 * as IPV6_PKTINFO.  Some objects it (sin6_scope_id specifies *link* while
d172 3
a217 3
/* for inet_ntop() */
char ntop_buf[INET6_ADDRSTRLEN];

d229 1
d234 1
a234 1
char	*pr_addr __P((struct sockaddr_in6 *));
d239 3
d253 4
d271 3
d286 1
a286 1
	while ((ch = getopt(argc, argv, "a:b:c:dfh:I:i:l:np:qRrS:s:vwW")) != EOF)
d289 1
a289 1
	while ((ch = getopt(argc, argv, "a:b:c:dfh:I:i:l:np:qRrS:s:vwWP:")) != EOF)
d291 1
a291 1
	while ((ch = getopt(argc, argv, "a:b:c:dfh:I:i:l:np:qRrS:s:vwWAE")) != EOF)
d373 4
d392 2
a393 1
			options |= F_RROUTE;
d395 3
d450 4
a453 1
	if (argc > 1)
d455 2
a464 3
#ifdef NRL_GETADDRINFO
	hints.ai_socktype = SOCK_DGRAM;
#else
a466 1
#endif
a480 4
#ifdef NRL_GETADDRINFO
	res->ai_socktype = SOCK_RAW;
	res->ai_protocol = IPPROTO_ICMPV6;
#endif
d559 39
a604 3
	/* record route option */
	if (options & F_RROUTE)
		errx(1, "record route not available in this implementation");
d613 5
d658 10
d670 15
a684 1
		
d688 1
d699 5
d708 1
d711 1
d714 1
d733 23
a755 2
#ifndef USE_SIN6_SCOPE_ID
		if (setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTOPTIONS,
d760 1
a760 3
#else
		src.sin6_scope_id = dst.sin6_scope_id;
#endif
d798 19
a816 3
	setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &optval, sizeof(optval));
#endif
	setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &optval, sizeof(optval));
d819 2
a820 2
	printf("%s --> ", inet_ntop(AF_INET6, &src.sin6_addr, ntop_buf, sizeof(ntop_buf)));
	printf("%s\n", inet_ntop(AF_INET6, &dst.sin6_addr, ntop_buf, sizeof(ntop_buf)));
d843 1
a843 1
		u_char buf[256];
d884 1
d1008 1
a1008 3
#ifdef OLD_RAWSOCKET
	struct ip6_hdr *ip;
#endif
a1015 51
#ifdef OLD_RAWSOCKET
	/* Check the IP header */
	ip = (struct ip6_hdr *)buf;
	if (cc < sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr)) {
		if (options & F_VERBOSE)
			warnx("packet too short (%d bytes) from %s\n", cc,
			  inet_ntop(AF_INET6, (void *)&from->sin6_addr,
				    ntop_buf, sizeof(ntop_buf)));
		return;
	}

	/* chase nexthdr link */
    {
	u_int8_t nh;
	struct ah *ah;
	struct ip6_ext *ip6e;

	off = IP6LEN;
	nh = ip->ip6_nxt;
	while (nh != IPPROTO_ICMPV6) {
		if (options & F_VERBOSE)
			fprintf(stderr, "header chain: type=0x%x\n", nh);

		switch (nh) {
#ifdef IPSEC
		case IPPROTO_AH:
			ah = (struct ah *)(buf + off);
			off += sizeof(struct ah);
			off += (ah->ah_len << 2);
			nh = ah->ah_nxt;
			break;
#endif

		 case IPPROTO_HOPOPTS:
			ip6e = (struct ip6_ext *)(buf + off);
			off += (ip6e->ip6e_len + 1) << 3;
			nh = ip6e->ip6e_nxt;
			break;
		default:
			if (options & F_VERBOSE) {
				fprintf(stderr,
					"unknown header type=0x%x: drop it\n",
					nh);
			}
			return;
		}
	}
    }
	/* Now the ICMP part */
	icp = (struct icmp6_hdr *)(buf + off);
#else
d1019 1
a1019 2
			  inet_ntop(AF_INET6, (void *)&from->sin6_addr,
				    ntop_buf, sizeof(ntop_buf)));
a1023 1
#endif
d1029 4
d1071 10
d1174 2
d1181 133
d1319 1
d1361 17
d1398 1
d1410 1
d1481 2
d1513 1
d1551 1
a1551 1
		(void)printf("Echo Request\n");
d1555 1
a1555 1
		(void)printf("Echo Reply\n");
d1559 1
a1559 1
		(void)printf("Membership Query\n");
d1562 1
a1562 1
		(void)printf("Membership Report\n");
d1565 1
a1565 1
		(void)printf("Membership Reduction\n");
d1568 1
a1568 1
		(void)printf("Router Solicitation\n");
d1571 1
a1571 1
		(void)printf("Router Advertisement\n");
d1574 1
a1574 1
		(void)printf("Neighbor Solicitation\n");
d1577 1
a1577 1
		(void)printf("Neighbor Advertisement\n");
d1584 1
a1584 1
		(void)printf("Destination: %s\n",
d1587 1
a1587 1
		(void)printf("New Target: %s\n",
d1593 1
a1593 1
		(void)printf("Node Information Query\n");
d1597 1
a1597 1
		(void)printf("Node Information Reply\n");
d1601 1
a1601 1
		(void)printf("Bad ICMP type: %d\n", icp->icmp6_type);
d1615 1
d1627 1
a1627 1
				  ntop_buf, INET6_ADDRSTRLEN));
d1629 1
a1629 1
				 ntop_buf, INET6_ADDRSTRLEN));
d1637 1
a1637 1
char *
d1803 1
a1803 1
"usage: ping6 [-dfnqRrvwW"
d1813 1
a1813 1
             [-s packetsize] [-h hoplimit] host [hosts...]\n");
@


1.1
log
@add ping6(8), IPv6 ping.

XXX may be merged into ping(8)?
XXX NRL getaddrinfo(3) does not allow SOCK_RAW as ai_socktype.
quickhack is enabled by -DNRL_GETADDRINFO.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a248 2
	extern int errno, optind;
	extern char *optarg;
@

