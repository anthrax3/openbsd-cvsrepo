head	1.53;
access;
symbols
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.2
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.35.0.14
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.33.0.8
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.53
date	2016.05.28.23.46.06;	author tb;	state Exp;
branches;
next	1.52;
commitid	GL0ThM0F6KSZzPq6;

1.52
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Cz19p5I1S6mVZIjV;

1.51
date	2015.10.11.19.00.40;	author doug;	state Exp;
branches;
next	1.50;
commitid	MzWImTTbo2frlJ6G;

1.50
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	pzd3OPiuZ6mCFBtc;

1.49
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	F55lwc3gS4GN2mLs;

1.48
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	Uu5nFG3wCl0LACBb;

1.47
date	2014.10.09.02.41.22;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	egXT90S44arLZntk;

1.46
date	2014.07.09.11.21.48;	author krw;	state Exp;
branches;
next	1.45;
commitid	EyytWuqQVeUkoT3O;

1.45
date	2014.05.27.12.35.40;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.24.21.49.09;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.22.02.15.54;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.13.05.50.24;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.11.21.25.07;	author halex;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.11.21.14.03;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.01.17.36.18;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.02.22.37.05;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.06.19.16.05;	author sobrado;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.09.17.12.17;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.29.03.37.09;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.01.23.42.35;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.01.06.41.35;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.21.18.12.00;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.02.00.48.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.12.15.26.23;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.12.06.39.29;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.21.22.57.32;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.25.07.50.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.04.16.24.44;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.17.18.27.58;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.17.17.56.53;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.11.21.23.29;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.01.19.05.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.07.18.26.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.41.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.14.06.41.37;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.30.05.45.55;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.30.04.43.34;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.25.04.43.45;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Don't pledge before opendev() and ioctl DIOCGDINFO were called.
Avoids a pledge crash with 'ncheck_ffs /dev/tty'.

deraadt agrees
@
text
@/*	$OpenBSD: ncheck_ffs.c,v 1.52 2015/11/23 19:19:30 deraadt Exp $	*/

/*-
 * Copyright (c) 1995, 1996 SigmaSoft, Th. Lockert <tholo@@sigmasoft.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1980, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE */
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dinode.h>

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <limits.h>
#include <fstab.h>
#include <errno.h>
#include <err.h>
#include <util.h>

#define DIP(dp, field) \
    ((sblock->fs_magic == FS_UFS1_MAGIC) ? \
    ((struct ufs1_dinode *)(dp))->field : \
    ((struct ufs2_dinode *)(dp))->field)

char	*disk;		/* name of the disk file */
char	rdisk[PATH_MAX];/* resolved name of the disk file */
int	diskfd;		/* disk file descriptor */
struct	fs *sblock;	/* the file system super block */
char	sblock_buf[MAXBSIZE];
int	sblock_try[] = SBLOCKSEARCH; /* possible superblock locations */
ufsino_t *ilist;	/* list of inodes to check */
int	ninodes;	/* number of inodes in list */
int	sflag;		/* only suid and special files */
int	aflag;		/* print the . and .. entries too */
int	mflag;		/* verbose output */
int	iflag;		/* specific inode */
char	*format;	/* output format */

struct disklabel lab;

struct icache_s {
	ufsino_t	ino;
	union {
		struct ufs1_dinode dp1;
		struct ufs2_dinode dp2;
	} di;
} *icache;
int	nicache;
int	maxicache;

void addinode(ufsino_t inum);
void *getino(ufsino_t inum);
void findinodes(ufsino_t);
void bread(daddr_t, char *, int);
__dead void usage(void);
void scanonedir(ufsino_t, const char *);
void dirindir(ufsino_t, daddr_t, int, off_t *, const char *);
void searchdir(ufsino_t, daddr_t, long, off_t, const char *);
int matchino(const void *, const void *);
int matchcache(const void *, const void *);
void cacheino(ufsino_t, void *);
void *cached(ufsino_t);
int main(int, char *[]);
char *rawname(char *);
void format_entry(const char *, struct direct *);

/*
 * Check to see if the indicated inodes are the same
 */
int
matchino(const void *key, const void *val)
{
	ufsino_t k = *(ufsino_t *)key;
	ufsino_t v = *(ufsino_t *)val;

	if (k < v)
		return -1;
	else if (k > v)
		return 1;
	return 0;
}

/*
 * Check if the indicated inode match the entry in the cache
 */
int
matchcache(const void *key, const void *val)
{
	ufsino_t	ino = *(ufsino_t *)key;
	struct icache_s	*ic = (struct icache_s *)val;

	if (ino < ic->ino)
		return -1;
	else if (ino > ic->ino)
		return 1;
	return 0;
}

/*
 * Add an inode to the cached entries
 */
void
cacheino(ufsino_t ino, void *dp)
{
	if (nicache == maxicache) {
		struct icache_s *newicache;

		/* grow exponentially */
		maxicache += 10 + maxicache/2;
		newicache = reallocarray(icache, maxicache, sizeof(*icache));
		if (newicache == NULL)
			errx(1, "malloc");
		icache = newicache;

	}
	icache[nicache].ino = ino;
	if (sblock->fs_magic == FS_UFS1_MAGIC)
		icache[nicache++].di.dp1 = *(struct ufs1_dinode *)dp;
	else
		icache[nicache++].di.dp2 = *(struct ufs2_dinode *)dp;
}

/*
 * Get a cached inode
 */
void *
cached(ufsino_t ino)
{
	struct icache_s *ic;
	void *dp = NULL;

	ic = bsearch(&ino, icache, nicache, sizeof(*icache), matchcache);
	if (ic != NULL) {
		if (sblock->fs_magic == FS_UFS1_MAGIC)
			dp = &ic->di.dp1;
		else
			dp = &ic->di.dp2;
	}
	return (dp);
}

/*
 * Walk the inode list for a filesystem to find all allocated inodes
 * Remember inodes we want to give information about and cache all
 * inodes pointing to directories
 */
void
findinodes(ufsino_t maxino)
{
	ufsino_t ino;
	void *dp;
	mode_t mode;

	for (ino = ROOTINO; ino < maxino; ino++) {
		dp = getino(ino);
		mode = DIP(dp, di_mode) & IFMT;
		if (!mode)
			continue;
		if (mode == IFDIR)
			cacheino(ino, dp);
		if (iflag ||
		    (sflag && (mode == IFDIR ||
		     ((DIP(dp, di_mode) & (ISGID | ISUID)) == 0 &&
		      (mode == IFREG || mode == IFLNK)))))
			continue;
		addinode(ino);
	}
}

/*
 * Get a specified inode from disk.  Attempt to minimize reads to once
 * per cylinder group
 */
void *
getino(ufsino_t inum)
{
	static char *itab = NULL;
	static daddr_t iblk = -1;
	void *dp;
	size_t dsize;

	if (inum < ROOTINO || inum >= sblock->fs_ncg * sblock->fs_ipg)
		return NULL;
	if ((dp = cached(inum)) != NULL)
		return dp;
	if (sblock->fs_magic == FS_UFS1_MAGIC)
		dsize = sizeof(struct ufs1_dinode);
	else
		dsize = sizeof(struct ufs2_dinode);
	if ((inum / sblock->fs_ipg) != iblk || itab == NULL) {
		iblk = inum / sblock->fs_ipg;
		if (itab == NULL &&
		    (itab = reallocarray(NULL, sblock->fs_ipg, dsize)) == NULL)
			errx(1, "no memory for inodes");
		bread(fsbtodb(sblock, cgimin(sblock, iblk)), itab,
		      sblock->fs_ipg * dsize);
	}
	return itab + (inum % sblock->fs_ipg) * dsize;
}

/*
 * Read a chunk of data from the disk.
 * Try to recover from hard errors by reading in sector sized pieces.
 * Error recovery is attempted at most BREADEMAX times before seeking
 * consent from the operator to continue.
 */
int	breaderrors = 0;
#define	BREADEMAX 32

void
bread(daddr_t blkno, char *buf, int size)
{
	off_t offset;
 	int cnt, i;
	u_int32_t secsize = lab.d_secsize;

	offset = blkno * DEV_BSIZE;

loop:
	if ((cnt = pread(diskfd, buf, size, offset)) == size)
		return;
	if (blkno + (size / DEV_BSIZE) >
	    fsbtodb(sblock, sblock->fs_ffs1_size)) {
		/*
		 * Trying to read the final fragment.
		 *
		 * NB - dump only works in TP_BSIZE blocks, hence
		 * rounds `DEV_BSIZE' fragments up to TP_BSIZE pieces.
		 * It should be smarter about not actually trying to
		 * read more than it can get, but for the time being
		 * we punt and scale back the read only when it gets
		 * us into trouble. (mkm 9/25/83)
		 */
		size -= secsize;
		goto loop;
	}
	if (cnt == -1)
		warnx("read error from %s: %s: [block %lld]: count=%d",
		    disk, strerror(errno), (long long)blkno, size);
	else
		warnx("short read error from %s: [block %lld]: count=%d, "
		    "got=%d", disk, (long long)blkno, size, cnt);
	if (++breaderrors > BREADEMAX)
		errx(1, "More than %d block read errors from %s", BREADEMAX,
		    disk);
	/*
	 * Zero buffer, then try to read each sector of buffer separately.
	 */
	memset(buf, 0, size);
	for (i = 0; i < size; i += secsize, buf += secsize) {
		if ((cnt = pread(diskfd, buf, secsize, offset + i)) ==
		    secsize)
			continue;
		if (cnt == -1) {
			warnx("read error from %s: %s: [sector %lld]: "
			    "count=%u", disk, strerror(errno),
			    (long long)(offset + i) / DEV_BSIZE, secsize);
			continue;
		}
		warnx("short read error from %s: [sector %lld]: count=%u, "
		    "got=%d", disk, (long long)(offset + i) / DEV_BSIZE,
		    secsize, cnt);
	}
}

/*
 * Add an inode to the in-memory list of inodes to dump
 */
void
addinode(ufsino_t ino)
{
	ufsino_t *newilist;

	newilist = reallocarray(ilist, ninodes + 1, sizeof(*ilist));
	if (newilist == NULL)
		errx(4, "not enough memory to allocate tables");
	ilist = newilist;
	ilist[ninodes] = ino;
	ninodes++;
}

/*
 * Scan the directory pointer at by ino
 */
void
scanonedir(ufsino_t ino, const char *path)
{
	void *dp;
	off_t filesize;
	int i;

	if ((dp = cached(ino)) == NULL)
		return;
	filesize = (off_t)DIP(dp, di_size);
	for (i = 0; filesize > 0 && i < NDADDR; i++) {
		if (DIP(dp, di_db[i]) != 0) {
			searchdir(ino, DIP(dp, di_db[i]),
			    sblksize(sblock, DIP(dp, di_size), i),
			    filesize, path);
		}
		filesize -= sblock->fs_bsize;
	}
	for (i = 0; filesize > 0 && i < NIADDR; i++) {
		if (DIP(dp, di_ib[i]))
			dirindir(ino, DIP(dp, di_ib[i]), i, &filesize, path);
	}
}

/*
 * Read indirect blocks, and pass the data blocks to be searched
 * as directories.
 */
void
dirindir(ufsino_t ino, daddr_t blkno, int ind_level, off_t *filesizep,
    const char *path)
{
	int i;
	void *idblk;

	if ((idblk = malloc(sblock->fs_bsize)) == NULL)
		errx(1, "dirindir: cannot allocate indirect memory.\n");
	bread(fsbtodb(sblock, blkno), idblk, (int)sblock->fs_bsize);
	if (ind_level <= 0) {
		for (i = 0; *filesizep > 0 && i < NINDIR(sblock); i++) {
			if (sblock->fs_magic == FS_UFS1_MAGIC)
				blkno = ((int32_t *)idblk)[i];
			else
				blkno = ((int64_t *)idblk)[i];
			if (blkno != 0)
				searchdir(ino, blkno, sblock->fs_bsize,
				    *filesizep, path);
			*filesizep -= sblock->fs_bsize;
		}
	} else {
		ind_level--;
		for (i = 0; *filesizep > 0 && i < NINDIR(sblock); i++) {
			if (sblock->fs_magic == FS_UFS1_MAGIC)
				blkno = ((int32_t *)idblk)[i];
			else
				blkno = ((int64_t *)idblk)[i];
			if (blkno != 0)
				dirindir(ino, blkno, ind_level, filesizep,
				    path);
		}
	}
	free(idblk);
}

/*
 * Scan a disk block containing directory information looking to see if
 * any of the entries are on the dump list and to see if the directory
 * contains any subdirectories.
 */
void
searchdir(ufsino_t ino, daddr_t blkno, long size, off_t filesize,
    const char *path)
{
	char *dblk;
	struct direct *dp;
	void *di;
	mode_t mode;
	char *npath;
	ufsino_t subino;
	long loc;

	if ((dblk = malloc(sblock->fs_bsize)) == NULL)
		errx(1, "searchdir: cannot allocate directory memory.");
	bread(fsbtodb(sblock, blkno), dblk, (int)size);
	if (filesize < size)
		size = filesize;
	for (loc = 0; loc < size; ) {
		dp = (struct direct *)(dblk + loc);
		if (dp->d_reclen == 0) {
			warnx("corrupted directory, inode %llu",
			    (unsigned long long)ino);
			break;
		}
		loc += dp->d_reclen;
		if (dp->d_ino == 0)
			continue;
		if (dp->d_name[0] == '.') {
			if (!aflag && (dp->d_name[1] == '\0' ||
			    (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
				continue;
		}
		di = getino(dp->d_ino);
		mode = DIP(di, di_mode) & IFMT;
		subino = dp->d_ino;
		if (bsearch(&subino, ilist, ninodes, sizeof(*ilist), matchino)) {
			if (format) {
				format_entry(path, dp);
			} else {
				if (mflag)
					printf("mode %-6o uid %-5u gid %-5u ino ",
					    DIP(di, di_mode), DIP(di, di_uid),
					    DIP(di, di_gid));
				printf("%-7llu %s/%s%s\n",
				    (unsigned long long)dp->d_ino, path,
				    dp->d_name, mode == IFDIR ? "/." : "");
			}
		}
		if (mode == IFDIR) {
			if (dp->d_name[0] == '.') {
				if (dp->d_name[1] == '\0' ||
				    (dp->d_name[1] == '.' && dp->d_name[2] == '\0'))
				continue;
			}
			if (asprintf(&npath, "%s/%s", path, dp->d_name) == -1)
				errx(1, "malloc");
			scanonedir(dp->d_ino, npath);
			free(npath);
		}
	}
	free(dblk);
}

char *
rawname(char *name)
{
	static char newname[PATH_MAX];
	char *p;

	if ((p = strrchr(name, '/')) == NULL)
		return name;
	*p = '\0';
	strlcpy(newname, name, sizeof newname - 2);
	*p++ = '/';
	strlcat(newname, "/r", sizeof newname);
	strlcat(newname, p, sizeof newname);
	return(newname);
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-ams] [-f format] [-i number ...] filesystem\n",
	    __progname);
	exit(3);
}

int
main(int argc, char *argv[])
{
	struct stat stblock;
	struct fstab *fsp;
	unsigned long long ullval;
	ssize_t n;
	char *ep;
	int c, i;

	while ((c = getopt(argc, argv, "af:i:ms")) != -1)
		switch (c) {
		case 'a':
			aflag = 1;
			break;
		case 'i':
			iflag = 1;

			errno = 0;
			ullval = strtoull(optarg, &ep, 10);
			if (optarg[0] == '\0' || *ep != '\0')
				errx(1, "%s is not a number",
				    optarg);
			if ((errno == ERANGE && ullval == ULLONG_MAX) ||
			    (ufsino_t)ullval != ullval)
				errx(1, "%s is out of range",
				    optarg);
			addinode((ufsino_t)ullval);

			while (optind < argc) {
				errno = 0;
				ullval = strtoull(argv[optind], &ep, 10);
				if (argv[optind][0] == '\0' || *ep != '\0')
					break;
				if ((errno == ERANGE && ullval == ULLONG_MAX)
				    || (ufsino_t)ullval != ullval)
					errx(1, "%s is out of range",
					    argv[optind]);
				addinode((ufsino_t)ullval);
				optind++;
			}
			break;
		case 'f':
			format = optarg;
			break;
		case 'm':
			mflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		default:
			usage();
			exit(2);
		}
	if (optind != argc - 1 || (mflag && format))
		usage();

	disk = argv[optind];
	if ((diskfd = opendev(disk, O_RDONLY, 0, NULL)) >= 0) {
		if (fstat(diskfd, &stblock))
			err(1, "cannot stat %s", disk);
		if (S_ISCHR(stblock.st_mode))
			goto gotdev;
		close(diskfd);
	}

	if (realpath(disk, rdisk) == NULL)
		err(1, "cannot find real path for %s", disk);
	disk = rdisk;

	if (stat(disk, &stblock) < 0)
		err(1, "cannot stat %s", disk);

        if (S_ISBLK(stblock.st_mode)) {
		disk = rawname(disk);
	} else if (!S_ISCHR(stblock.st_mode)) {
		if ((fsp = getfsfile(disk)) == NULL)
			err(1, "could not find file system %s", disk);
                disk = rawname(fsp->fs_spec);
        }

	if ((diskfd = opendev(disk, O_RDONLY, 0, NULL)) < 0)
		err(1, "cannot open %s", disk);

gotdev:
	if (ioctl(diskfd, DIOCGDINFO, (char *)&lab) < 0)
		err(1, "ioctl (DIOCGDINFO)");
	if (ioctl(diskfd, DIOCGPDINFO, (char *)&lab) < 0)
		err(1, "ioctl (DIOCGPDINFO)");

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	sblock = (struct fs *)sblock_buf;
	for (i = 0; sblock_try[i] != -1; i++) {
		n = pread(diskfd, sblock, SBLOCKSIZE, (off_t)sblock_try[i]);
		if (n == SBLOCKSIZE && (sblock->fs_magic == FS_UFS1_MAGIC ||
		     (sblock->fs_magic == FS_UFS2_MAGIC &&
		      sblock->fs_sblockloc == sblock_try[i])) &&
		    sblock->fs_bsize <= MAXBSIZE &&
		    sblock->fs_bsize >= sizeof(struct fs))
			break;
	}
	if (sblock_try[i] == -1)
		errx(1, "cannot find filesystem superblock");

	findinodes(sblock->fs_ipg * sblock->fs_ncg);
	if (!format)
		printf("%s:\n", disk);
	scanonedir(ROOTINO, "");
	close(diskfd);
	exit (0);
}

void
format_entry(const char *path, struct direct *dp)
{
	static size_t size;
	static char *buf;
	char *src, *dst, *newbuf;
	int len;

	if (buf == NULL) {
		if ((buf = malloc(LINE_MAX)) == NULL)
			err(1, "malloc");
		size = LINE_MAX;
	}

	for (src = format, dst = buf; *src; src++) {
		/* Need room for at least one character in buf. */
		if (size <= dst - buf) {
		    expand_buf:
			if ((newbuf = reallocarray(buf, size, 2)) == NULL)
				err(1, "realloc");
			buf = newbuf;
			size = size * 2;
		}
		if (src[0] =='\\') {
			switch (src[1]) {
			case 'I':
				len = snprintf(dst, size - (dst - buf), "%llu",
				    (unsigned long long)dp->d_ino);
				if (len == -1 || len >= size - (dst - buf))
					goto expand_buf;
				dst += len;
				break;
			case 'P':
				len = snprintf(dst, size - (dst - buf), "%s/%s",
				    path, dp->d_name);
				if (len == -1 || len >= size - (dst - buf))
					goto expand_buf;
				dst += len;
				break;
			case '\\':
				*dst++ = '\\';
				break;
			case '0':
				/* XXX - support other octal numbers? */
				*dst++ = '\0';
				break;
			case 'a':
				*dst++ = '\a';
				break;
			case 'b':
				*dst++ = '\b';
				break;
			case 'e':
				*dst++ = '\e';
				break;
			case 'f':
				*dst++ = '\f';
				break;
			case 'n':
				*dst++ = '\n';
				break;
			case 'r':
				*dst++ = '\r';
				break;
			case 't':
				*dst++ = '\t';
				break;
			case 'v':
				*dst++ = '\v';
				break;
			default:
				*dst++ = src[1];
				break;
			}
			src++;
		} else
			*dst++ = *src;
	}
	fwrite(buf, dst - buf, 1, stdout);
}
@


1.52
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.51 2015/10/11 19:00:40 doug Exp $	*/
a511 3

	if (pledge("stdio rpath disklabel", NULL) == -1)
		err(1, "pledge");
@


1.51
log
@Pledge that ncheck_ffs only uses "stdio" after opening the device.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.50 2015/02/07 02:09:13 deraadt Exp $	*/
d512 3
@


1.50
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.49 2015/01/20 18:22:21 deraadt Exp $	*/
d593 4
@


1.49
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.48 2015/01/16 06:39:59 deraadt Exp $	*/
d516 1
a516 1
			aflag++;
d519 1
a519 1
			iflag++;
d549 1
a549 1
			mflag++;
d552 1
a552 1
			sflag++;
@


1.48
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.47 2014/10/09 02:41:22 deraadt Exp $	*/
d57 1
a57 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE */
@


1.47
log
@fairly obvious reallocarray() conversion, where the size is recalculated
only on success.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.46 2014/07/09 11:21:48 krw Exp $	*/
d57 1
a57 1
#include <sys/param.h>
d73 1
d479 1
a479 1
	static char newname[MAXPATHLEN];
@


1.46
log
@Enable specifying the filesystem of interest by the duid.

Original diff from halex@@ a while ago.

ok halex@@ jsing@@ (with comments for future tweaking)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.45 2014/05/27 12:35:40 krw Exp $	*/
a617 1
	size_t nsize;
d631 1
a631 3
			nsize = size << 1;

			if ((newbuf = realloc(buf, nsize)) == NULL)
d634 1
a634 1
			size = nsize;
@


1.45
log
@Where trying to pread() a single disk sector, the i/o must be for the
actual disk sector size and not DEV_BSIZE. The sector size must be
obtained via the disklabel. Larger i/o's must be multiple sectors,
so when retrying with a smaller size shrink the attempt by one sector
and not DEV_BSIZE.

Of course if your d_secsize is DEV_BSIZE, this will all be a no-op.

This does not make non-512-byte sectors work, but puts in place the
logic to get and use the disklabel info. Which makes the next diffs
bite sized and focused.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.44 2014/05/24 21:49:09 krw Exp $	*/
d76 1
d509 1
a509 1
	char *ep, *odisk;
d560 11
a570 3
	odisk = argv[optind];
	if (realpath(odisk, rdisk) == NULL)
		err(1, "cannot find real path for %s", odisk);
d584 1
a584 1
	if ((diskfd = open(disk, O_RDONLY)) < 0)
d586 4
@


1.44
log
@Nuke last of the illusionary 'dev_bsize' and 'dev_bshift' variables in
favour of DEV_BSIZE. No-op on 512-byte sector devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.43 2014/05/22 02:15:54 krw Exp $	*/
d60 3
d96 2
d272 1
d291 1
a291 1
		size -= DEV_BSIZE;
d307 3
a309 3
	for (i = 0; i < size; i += DEV_BSIZE, buf += DEV_BSIZE) {
		if ((cnt = pread(diskfd, buf, DEV_BSIZE, offset + i)) ==
		    DEV_BSIZE)
d313 2
a314 2
			    "count=%d", disk, strerror(errno),
			    (long long)(offset + i) / DEV_BSIZE, DEV_BSIZE);
d317 1
a317 1
		warnx("short read error from %s: [sector %lld]: count=%d, "
d319 1
a319 1
		    DEV_BSIZE, cnt);
d577 2
@


1.43
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.42 2014/05/20 21:11:16 krw Exp $	*/
a84 2
long	dev_bsize;	/* block size of underlying disk device */
int	dev_bshift;	/* log2(dev_bsize) */
d265 4
a268 1
	int cnt, i;
d271 1
a271 2
	if ((cnt = pread(diskfd, buf, size, (off_t)blkno << dev_bshift)) ==
	    size)
d273 2
a274 1
	if (blkno + (size / dev_bsize) > fsbtodb(sblock, sblock->fs_ffs1_size)) {
d279 1
a279 1
		 * rounds `dev_bsize' fragments up to TP_BSIZE pieces.
d285 1
a285 1
		size -= dev_bsize;
d301 3
a303 3
	for (i = 0; i < size; i += dev_bsize, buf += dev_bsize, blkno++) {
		if ((cnt = pread(diskfd, buf, (int)dev_bsize,
			    (off_t)blkno << dev_bshift)) == dev_bsize)
d307 2
a308 2
			    "count=%ld", disk, strerror(errno),
			    (long long)blkno, dev_bsize);
d311 3
a313 2
		warnx("short read error from %s: [sector %lld]: count=%ld, "
		    "got=%d", disk, (long long)blkno, dev_bsize, cnt);
a583 4
	dev_bsize = sblock->fs_fsize / fsbtodb(sblock, 1);
	dev_bshift = ffs(dev_bsize) - 1;
	if (dev_bsize != (1 << dev_bshift))
		errx(2, "blocksize (%ld) not a power of 2", dev_bsize);
@


1.42
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.41 2014/05/13 05:50:24 guenther Exp $	*/
d367 1
a367 1
	void *idblk; 
@


1.41
log
@Since this is limited to ffs, use ufsinfo_t instead of ino_t.
Grow the array of cached inodes exponentially instead of arithmetically.
Prefer sizeof(*pointer) over sizeof(type) in mallocs.
Don't leak memory in searchdir().
Fix multiple bugs in the handling of indirect blocks, including reuse of
a static buffer in a recursive function and failure to track the remaining
size of the directory blocks to process

Tested with a directory *doubly* indirect block!
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.40 2014/05/11 21:25:07 halex Exp $	*/
d270 2
a271 3
	if (lseek(diskfd, ((off_t)blkno << dev_bshift), SEEK_SET) < 0)
		warnx("bread: lseek fails");
	if ((cnt = read(diskfd, buf, size)) == size)
d301 2
a302 3
		if (lseek(diskfd, ((off_t)blkno << dev_bshift), SEEK_SET) < 0)
			warnx("bread: lseek2 fails!");
		if ((cnt = read(diskfd, buf, (int)dev_bsize)) == dev_bsize)
@


1.40
log
@replace realloc(p, N * M) with reallocarray(p, N, M) and remove some
pointless cleanup if we're obviously going to die anyway

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.39 2014/05/11 21:14:03 guenther Exp $	*/
d87 1
a87 1
ino_t	*ilist;		/* list of inodes to check */
d96 1
a96 1
	ino_t		ino;
d103 1
d105 3
a107 3
void addinode(ino_t inum);
void *getino(ino_t inum);
void findinodes(ino_t);
d110 3
a112 3
void scanonedir(ino_t, const char *);
void dirindir(ino_t, daddr_t, int, off_t, const char *);
void searchdir(ino_t, daddr_t, long, off_t, const char *);
d115 2
a116 2
void cacheino(ino_t, void *);
void *cached(ino_t);
d127 2
a128 2
	ino_t k = *(ino_t *)key;
	ino_t v = *(ino_t *)val;
d143 1
a143 1
	ino_t		ino = *(ino_t *)key;
d157 1
a157 1
cacheino(ino_t ino, void *dp)
d159 2
a160 1
	struct icache_s *newicache;
d162 8
a169 4
	newicache = reallocarray(icache, nicache + 1, sizeof(struct icache_s));
	if (newicache == NULL)
		errx(1, "malloc");
	icache = newicache;
d181 1
a181 1
cached(ino_t ino)
d186 1
a186 2
	ic = (struct icache_s *)bsearch(&ino, icache, nicache,
	    sizeof(struct icache_s), matchcache);
d202 1
a202 1
findinodes(ino_t maxino)
d204 1
a204 1
	ino_t ino;
d229 1
a229 1
getino(ino_t inum)
d247 1
a247 1
		    (itab = calloc(sblock->fs_ipg, dsize)) == NULL)
d321 1
a321 1
addinode(ino_t ino)
d323 1
a323 1
	ino_t *newilist;
d325 1
a325 1
	newilist = reallocarray(ilist, ninodes + 1, sizeof(ino_t));
d337 1
a337 1
scanonedir(ino_t ino, const char *path)
d356 1
a356 1
			dirindir(ino, DIP(dp, di_ib[i]), i, filesize, path);
d362 1
a362 2
 * as directories. Quit as soon as any entry is found that will
 * require the directory to be dumped.
d365 1
a365 1
dirindir(ino_t ino, daddr_t blkno, int ind_level, off_t filesize,
d369 1
a369 1
	static void *idblk; 
d371 1
a371 1
	if (idblk == NULL && (idblk = malloc(sblock->fs_bsize)) == NULL)
d375 1
a375 1
		for (i = 0; filesize > 0 && i < NINDIR(sblock); i++) {
d382 13
a394 1
				    filesize, path);
a395 10
		return;
	}
	ind_level--;
	for (i = 0; filesize > 0 && i < NINDIR(sblock); i++) {
		if (sblock->fs_magic == FS_UFS1_MAGIC)
			blkno = ((int32_t *)idblk)[i];
		else
			blkno = ((int64_t *)idblk)[i];
		if (blkno != 0)
			dirindir(ino, blkno, ind_level, filesize, path);
d397 1
d406 1
a406 1
searchdir(ino_t ino, daddr_t blkno, long size, off_t filesize,
d414 1
a414 1
	ino_t subino;
d418 1
a418 1
		errx(1, "searchdir: cannot allocate indirect memory.");
d465 1
d518 3
a520 2
			if (errno == ERANGE && ullval == ULLONG_MAX)
				errx(1, "%s is out or range",
d522 1
a522 1
			addinode((ino_t)ullval);
d529 3
a531 2
				if (errno == ERANGE && ullval == ULLONG_MAX)
					errx(1, "%s is out or range",
d533 1
a533 1
				addinode((ino_t)ullval);
@


1.39
log
@struct direct's d_ino is no longer the same size as an ino_t, so copy it
for the call to bsearch()

problem report and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.38 2013/11/01 17:36:18 krw Exp $	*/
d160 2
a161 5
	newicache = realloc(icache, (nicache + 1) * sizeof(struct icache_s));
	if (newicache == NULL) {
		if (icache)
			free(icache);
		icache = NULL;
a162 1
	}
d320 2
a321 5
	newilist = realloc(ilist, sizeof(ino_t) * (ninodes + 1));
	if (newilist == NULL) {
		if (ilist)
			free(ilist);
		ilist = NULL;
a322 1
	}
@


1.38
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.37 2013/06/11 16:42:05 deraadt Exp $	*/
d415 1
d440 2
a441 1
		if (bsearch(&dp->d_ino, ilist, ninodes, sizeof(*ilist), matchino)) {
@


1.37
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.36 2013/04/24 13:46:29 deraadt Exp $	*/
d291 2
a292 2
		warnx("short read error from %s: [block %lld]: count=%d, got=%d",
		    disk, (long long)blkno, size, cnt);
d294 2
a295 1
		errx(1, "More than %d block read errors from %s", BREADEMAX, disk);
d306 3
a308 2
			warnx("read error from %s: %s: [sector %lld]: count=%ld",
			    disk, strerror(errno), (long long)blkno, dev_bsize);
d311 2
a312 2
		warnx("short read error from %s: [sector %lld]: count=%ld, got=%d",
		    disk, (long long)blkno, dev_bsize, cnt);
@


1.36
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.35 2009/10/27 23:59:33 deraadt Exp $	*/
d107 1
a107 1
void bread(daddr64_t, char *, int);
d110 2
a111 2
void dirindir(ino_t, daddr64_t, int, off_t, const char *);
void searchdir(ino_t, daddr64_t, long, off_t, const char *);
d231 1
a231 1
	static daddr64_t iblk = -1;
d264 1
a264 1
bread(daddr64_t blkno, char *buf, int size)
d367 1
a367 1
dirindir(ino_t ino, daddr64_t blkno, int ind_level, off_t filesize,
d405 1
a405 1
searchdir(ino_t ino, daddr64_t blkno, long size, off_t filesize,
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.34 2009/06/02 22:37:05 ray Exp $	*/
d423 2
a424 1
			warnx("corrupted directory, inode %u", ino);
d445 2
a446 1
				printf("%-7u %s/%s%s\n", dp->d_ino, path,
d496 1
a496 1
	unsigned long ulval;
d510 1
a510 1
			ulval = strtoul(optarg, &ep, 10);
d514 1
a514 1
			if (errno == ERANGE && ulval == ULONG_MAX)
d517 1
a517 1
			addinode((ino_t)ulval);
d521 1
a521 1
				ulval = strtoul(argv[optind], &ep, 10);
d524 1
a524 1
				if (errno == ERANGE && ulval == ULONG_MAX)
d527 1
a527 1
				addinode((ino_t)ulval);
d619 2
a620 2
				len = snprintf(dst, size - (dst - buf), "%u",
				    dp->d_ino);
@


1.34
log
@snprintf returns int, not size_t.

OK millert otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.33 2007/08/06 19:16:05 sobrado Exp $	*/
a55 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.33 2007/08/06 19:16:05 sobrado Exp $";
#endif /* not lint */
@


1.33
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.32 2007/07/09 17:12:17 thib Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.32 2007/07/09 17:12:17 thib Exp $";
d597 1
a597 1
	size_t len, nsize;
d599 1
@


1.32
log
@correct a typo in an error message.
use realpath(3) to sanitize the path we're going to
work with, prevents silly errors when passing ncheck_ffs
paths from the shell with a trailing '/' since that
doesnt match the entry in fstab.

ok deraadt@@,krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.31 2007/06/29 03:37:09 deraadt Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.31 2007/06/29 03:37:09 deraadt Exp $";
d487 2
a488 1
	fprintf(stderr, "usage: %s [-ams] [-f format] [-i number [...]] filesystem\n",
@


1.31
log
@more daddr64_t changes; checked by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.30 2007/06/01 23:42:35 pedro Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.30 2007/06/01 23:42:35 pedro Exp $";
d84 1
d499 1
a499 1
	char *ep;
d548 4
a551 1
	disk = argv[optind];
d560 1
a560 1
			err(1, "cound not find file system %s", disk);
@


1.30
log
@ufs1_daddr_t cleanup, okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.29 2007/06/01 06:41:35 deraadt Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.29 2007/06/01 06:41:35 deraadt Exp $";
d234 1
a234 1
	static daddr_t iblk = -1;
@


1.29
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.28 2007/05/21 18:12:00 millert Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.28 2007/05/21 18:12:00 millert Exp $";
d382 1
a382 1
				blkno = ((ufs1_daddr_t *)idblk)[i];
d384 1
a384 1
				blkno = ((daddr64_t *)idblk)[i];
d394 1
a394 1
			blkno = ((ufs1_daddr_t *)idblk)[i];
d396 1
a396 1
			blkno = ((daddr64_t *)idblk)[i];
@


1.28
log
@Add ffs2 support; some parts adapted from ffs2 dump changes in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.27 2007/03/19 13:27:47 pedro Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.27 2007/03/19 13:27:47 pedro Exp $";
d110 1
a110 1
void bread(ufs2_daddr_t, char *, int);
d113 2
a114 2
void dirindir(ino_t, ufs2_daddr_t, int, off_t, const char *);
void searchdir(ino_t, ufs2_daddr_t, long, off_t, const char *);
d267 1
a267 1
bread(ufs2_daddr_t blkno, char *buf, int size)
d370 1
a370 1
dirindir(ino_t ino, ufs2_daddr_t blkno, int ind_level, off_t filesize,
d384 1
a384 1
				blkno = ((ufs2_daddr_t *)idblk)[i];
d396 1
a396 1
			blkno = ((ufs2_daddr_t *)idblk)[i];
d408 1
a408 1
searchdir(ino_t ino, ufs2_daddr_t blkno, long size, off_t filesize,
@


1.27
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.26 2006/04/02 00:48:35 deraadt Exp $	*/
d28 29
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.26 2006/04/02 00:48:35 deraadt Exp $";
d78 4
a81 1
#define MAXINOPB	(MAXBSIZE / sizeof(struct ufs1_dinode))
d87 1
d100 4
a103 1
	struct ufs1_dinode	di;
d108 1
a108 1
struct ufs1_dinode *getino(ino_t inum);
d110 1
a110 1
void bread(daddr_t, char *, int);
d113 2
a114 2
void dirindir(ino_t, daddr_t, int, long *, const char *);
void searchdir(ino_t, daddr_t, long, long, const char *);
d117 2
a118 2
void cacheino(ino_t, struct ufs1_dinode *);
struct ufs1_dinode *cached(ino_t);
d159 1
a159 1
cacheino(ino_t ino, struct ufs1_dinode *ip)
d172 4
a175 1
	icache[nicache++].di = *ip;
d181 1
a181 1
struct ufs1_dinode *
d185 1
d189 7
a195 1
	return ic ? &ic->di : NULL;
d207 1
a207 1
	struct ufs1_dinode *dp;
d212 1
a212 1
		mode = dp->di_mode & IFMT;
d219 1
a219 1
		     ((dp->di_mode & (ISGID | ISUID)) == 0 &&
d230 1
a230 1
struct ufs1_dinode *
d233 1
a233 1
	static struct ufs1_dinode *itab = NULL;
d235 2
a236 1
	struct ufs1_dinode *ip;
d240 6
a245 2
	if ((ip = cached(inum)) != NULL)
		return ip;
d249 1
a249 1
		    (itab = calloc(sblock->fs_ipg, sizeof(struct ufs1_dinode))) == NULL)
d251 2
a252 2
		bread(fsbtodb(sblock, cgimin(sblock, iblk)), (char *)itab,
		      sblock->fs_ipg * sizeof(struct ufs1_dinode));
d254 1
a254 1
	return &itab[inum % sblock->fs_ipg];
d258 4
a261 3
 * Read a chunk of data from the disk. Try to recover from hard errors by
 * reading in sector sized pieces.  Error recovery is attempted at most
 * BREADEMAX times before seeking consent from the operator to continue.
d267 1
a267 1
bread(daddr_t blkno, char *buf, int size)
d291 2
a292 2
		warnx("read error from %s: %s: [block %d]: count=%d",
			disk, strerror(errno), blkno, size);
d294 2
a295 2
		warnx("short read error from %s: [block %d]: count=%d, got=%d",
			disk, blkno, size, cnt);
d308 2
a309 2
			warnx("read error from %s: %s: [sector %d]: count=%ld",
			    disk, strerror(errno), blkno, dev_bsize);
d312 2
a313 2
		warnx("short read error from %s: [sector %d]: count=%ld, got=%d",
		    disk, blkno, dev_bsize, cnt);
d343 2
a344 2
	struct ufs1_dinode *dp;
	long filesize;
d349 1
a349 1
	filesize = dp->di_size;
d351 3
a353 2
		if (dp->di_db[i])
			searchdir(ino, dp->di_db[i], dblksize(sblock, dp, i),
d355 1
d359 2
a360 2
		if (dp->di_ib[i])
			dirindir(ino, dp->di_ib[i], i, &filesize, path);
d370 1
a370 1
dirindir(ino_t ino, daddr_t blkno, int ind_level, long *filesize,
a372 1
	daddr_t idblk[MAXBSIZE / sizeof(daddr_t)];
d374 1
d376 3
a378 1
	bread(fsbtodb(sblock, blkno), (char *)idblk, (int)sblock->fs_bsize);
d380 6
a385 3
		for (i = 0; *filesize > 0 && i < NINDIR(sblock); i++) {
			blkno = idblk[i];
			if (blkno)
d387 1
a387 1
				    *filesize, path);
d392 6
a397 3
	for (i = 0; *filesize > 0 && NINDIR(sblock); i++) {
		blkno = idblk[i];
		if (blkno)
d404 2
a405 3
 * any of the entries are on the inode list and to see if the directory
 * contains any subdirectories.  Display entries for marked inodes.
 * Pass inodes pointing to directories back to scanonedir().
d408 1
a408 1
searchdir(ino_t ino, daddr_t blkno, long size, long filesize,
d411 1
a411 1
	char dblk[MAXBSIZE];
d413 1
a413 1
	struct ufs1_dinode *di;
d418 2
d423 1
a423 1
	for (loc = 0; loc < size;) {
d430 1
a430 1
		if (!dp->d_ino)
d438 1
a438 1
		mode = di->di_mode & IFMT;
d445 2
a446 1
					    di->di_mode, di->di_uid, di->di_gid);
d497 1
d499 1
a499 1
	int c;
d563 12
a574 3
	bread(SBOFF, (char *)sblock, SBSIZE);
	if (sblock->fs_magic != FS_MAGIC)
		errx(1, "not a file system");
@


1.26
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.25 2005/11/12 15:26:23 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.25 2005/11/12 15:26:23 deraadt Exp $";
d224 1
a224 1
	if (blkno + (size / dev_bsize) > fsbtodb(sblock, sblock->fs_size)) {
@


1.25
log
@more asprintf; ok dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.24 2005/04/12 06:39:29 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.24 2005/04/12 06:39:29 deraadt Exp $";
d220 1
a220 1
	if (lseek(diskfd, ((off_t)blkno << dev_bshift), 0) < 0)
d251 1
a251 1
		if (lseek(diskfd, ((off_t)blkno << dev_bshift), 0) < 0)
@


1.24
log
@handle snprintf potential -1 case
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.23 2004/08/08 19:04:25 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.23 2004/08/08 19:04:25 deraadt Exp $";
a387 2
			int len;

d393 1
a393 3
			len = strlen(path) + strlen(dp->d_name) + 2;
			npath = malloc(len);
			if (npath == NULL)
a394 1
			snprintf(npath, len, "%s/%s", path, dp->d_name);
@


1.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.22 2003/11/21 22:57:32 jmc Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.22 2003/11/21 22:57:32 jmc Exp $";
d548 1
a548 1
				if (len >= size - (dst - buf))
d555 1
a555 1
				if (len >= size - (dst - buf))
@


1.22
log
@- standard SYNOPSIS
- sort OPTIONS
- s/Dq/Sq when quoting single characters
- sync usage()
- simplify macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.21 2003/09/25 07:50:22 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.21 2003/09/25 07:50:22 deraadt Exp $";
d537 1
a537 1
			
@


1.21
log
@realloc fixes; 3rd rev to make markus happier
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.20 2003/08/25 23:28:15 tedu Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.20 2003/08/25 23:28:15 tedu Exp $";
d427 1
a427 1
	fprintf(stderr, "usage: %s [-f format] [-i numbers] [-ams] filesystem\n",
@


1.20
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.19 2003/07/29 18:38:36 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.19 2003/07/29 18:38:36 deraadt Exp $";
d125 7
a131 5
	if (nicache)
		icache = realloc(icache, (nicache + 1) * sizeof(struct icache_s));
	else
		icache = malloc(sizeof(struct icache_s));
	if (icache == NULL)
d133 2
d271 7
a277 5
	if (ninodes)
		ilist = realloc(ilist, sizeof(ino_t) * (ninodes + 1));
	else
		ilist = malloc(sizeof(ino_t));
	if (ilist == NULL)
d279 2
d523 2
a524 2
	size_t len;
	char *src, *dst;
d536 3
a538 2
			size <<= 1;
			if ((buf = realloc(buf, size)) == NULL)
d540 2
@


1.19
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.18 2003/06/11 06:22:14 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.18 2003/06/11 06:22:14 deraadt Exp $";
d49 1
a49 1
#define MAXINOPB	(MAXBSIZE / sizeof(struct dinode))
d67 1
a67 1
	struct dinode	di;
d72 1
a72 1
struct dinode *getino(ino_t inum);
d81 2
a82 2
void cacheino(ino_t, struct dinode *);
struct dinode *cached(ino_t);
d123 1
a123 1
cacheino(ino_t ino, struct dinode *ip)
d138 1
a138 1
struct dinode *
d157 1
a157 1
	struct dinode *dp;
d180 1
a180 1
struct dinode *
d183 1
a183 1
	static struct dinode *itab = NULL;
d185 1
a185 1
	struct dinode *ip;
d194 1
a194 1
		    (itab = calloc(sblock->fs_ipg, sizeof(struct dinode))) == NULL)
d197 1
a197 1
		      sblock->fs_ipg * sizeof(struct dinode));
d283 1
a283 1
	struct dinode *dp;
d344 1
a344 1
	struct dinode *di;
@


1.18
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.17 2003/06/04 16:24:44 deraadt Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.17 2003/06/04 16:24:44 deraadt Exp $";
d207 1
a207 1
int	breaderrors = 0;		
d451 1
a451 1
			while (optind < argc) {	
@


1.17
log
@term 3 & 4 from tholo after permission
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.16 2003/01/17 18:27:58 millert Exp $	*/
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.16 2003/01/17 18:27:58 millert Exp $";
d106 2
a107 1
int matchcache(const void *key, const void *val)
@


1.16
log
@Add a new option, -f, that allows the user to specify a custom output
format.  Currently only supports printing the inode number and path
(along with any arbitrary text) but other escapes may be added later.
A useful invocation is:
    ncheck -s -f '\P\0' | xargs -0 ls -ldgT

deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.15 2003/01/17 17:56:53 millert Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by SigmaSoft, Th. Lockert
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d29 1
a29 1
static const char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.15 2003/01/17 17:56:53 millert Exp $";
@


1.15
log
@Don't report setugid directories in "ncheck -s" output since those
bits have no meaning on OpenBSD.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.14 2002/08/12 00:42:56 aaron Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.14 2002/08/12 00:42:56 aaron Exp $";
d68 1
d80 1
a80 1
void usage(void);
d90 1
d359 1
a359 1
			warnx("corrupted directory, inode %lu", (long)ino);
d373 9
a381 6
			if (mflag)
				printf("mode %-6o uid %-5lu gid %-5lu ino ",
				    di->di_mode, (unsigned long)di->di_uid,
				    (unsigned long)di->di_gid);
			printf("%-7lu %s/%s%s\n", (unsigned long)dp->d_ino,
			    path, dp->d_name, mode == IFDIR ? "/." : "");
d418 1
a418 1
void
d421 4
a424 1
	fprintf(stderr, "Usage: ncheck_ffs [-i numbers] [-ams] filesystem\n");
d433 1
a433 1
	u_long ulval;
d437 1
a437 1
	while ((c = getopt(argc, argv, "ai:ms")) != -1)
d467 3
d480 1
a480 1
	if (optind != argc - 1)
d490 1
a490 2
	}
	else if (!S_ISCHR(stblock.st_mode)) {
d507 2
a508 1
	printf("%s:\n", disk);
d511 81
a591 1
	return 0;
@


1.14
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.13 2002/07/11 21:23:29 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.13 2002/07/11 21:23:29 deraadt Exp $";
d170 3
a172 3
		    (sflag &&
		     (((dp->di_mode & (ISGID | ISUID)) == 0) &&
		      ((mode == IFREG) || (mode == IFDIR) || (mode == IFLNK)))))
@


1.13
log
@malloc() failure tests; rimshot@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.12 2002/07/03 22:32:33 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.12 2002/07/03 22:32:33 deraadt Exp $";
d196 1
a196 1
		    (itab = calloc(sizeof(struct dinode), sblock->fs_ipg)) == NULL)
@


1.12
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.11 2002/05/22 08:21:02 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.11 2002/05/22 08:21:02 deraadt Exp $";
d131 2
d388 2
@


1.11
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.10 2002/03/14 06:51:41 mpech Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.10 2002/03/14 06:51:41 mpech Exp $";
d94 1
a94 2
matchino(key, val)
	const void *key, *val;
d109 1
a109 2
int matchcache(key, val)
	const void *key, *val;
d125 1
a125 3
cacheino(ino, ip)
	ino_t ino;
	struct dinode *ip;
d139 1
a139 2
cached(ino)
	ino_t ino;
d143 2
a144 1
	ic = (struct icache_s *)bsearch(&ino, icache, nicache, sizeof(struct icache_s), matchcache);
d154 1
a154 2
findinodes(maxino)
	ino_t maxino;
d181 1
a181 2
getino(inum)
	ino_t inum;
d211 1
a211 4
bread(blkno, buf, size)
	daddr_t blkno;
	char *buf;
	int size;	
d265 1
a265 2
addinode(ino)
	ino_t ino;
d281 1
a281 3
scanonedir(ino, path)
	ino_t ino;
	const char *path;
d308 2
a309 6
dirindir(ino, blkno, ind_level, filesize, path)
	ino_t ino;
	daddr_t blkno;
	int ind_level;
	long *filesize;
	const char *path;
d339 2
a340 6
searchdir(ino, blkno, size, filesize, path)
	ino_t ino;
	daddr_t blkno;
	long size;
	long filesize;
	const char *path;
d394 1
a394 2
rawname(name)
	char *name;
d410 1
a410 1
usage()
d417 1
a417 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.10
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.9 2002/02/16 21:27:36 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.9 2002/02/16 21:27:36 millert Exp $";
d397 2
d404 3
a406 4
			npath = malloc(strlen(path) + strlen(dp->d_name) + 2);
			strcpy(npath, path);
			strcat(npath, "/");
			strcat(npath, dp->d_name);
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.8 2001/12/01 19:05:39 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.8 2001/12/01 19:05:39 deraadt Exp $";
d226 1
a226 1
		warnx("bread: lseek fails\n");
d244 1
a244 1
		warnx("read error from %s: %s: [block %d]: count=%d\n",
d247 1
a247 1
		warnx("short read error from %s: [block %d]: count=%d, got=%d\n",
d250 1
a250 1
		errx(1, "More than %d block read errors from %s\n", BREADEMAX, disk);
d257 1
a257 1
			warnx("bread: lseek2 fails!\n");
d261 1
a261 1
			warnx("read error from %s: %s: [sector %d]: count=%ld\n",
d265 1
a265 1
		warnx("short read error from %s: [sector %d]: count=%ld, got=%d\n",
@


1.8
log
@use strtoul() instead of atoi()
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.7 2001/11/05 07:39:16 mpech Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.7 2001/11/05 07:39:16 mpech Exp $";
d75 14
a88 14
void addinode __P((ino_t inum));
struct dinode *getino __P((ino_t inum));
void findinodes __P((ino_t));
void bread __P((daddr_t, char *, int));
void usage __P((void));
void scanonedir __P((ino_t, const char *));
void dirindir __P((ino_t, daddr_t, int, long *, const char *));
void searchdir __P((ino_t, daddr_t, long, long, const char *));
int matchino __P((const void *, const void *));
int matchcache __P((const void *, const void *));
void cacheino __P((ino_t, struct dinode *));
struct dinode *cached __P((ino_t));
int main __P((int, char *[]));
char *rawname __P((char *));
@


1.7
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.6 2001/07/07 18:26:16 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.6 2001/07/07 18:26:16 deraadt Exp $";
d304 2
a305 1
			searchdir(ino, dp->di_db[i], dblksize(sblock, dp, i), filesize, path);
d335 2
a336 1
				searchdir(ino, blkno, sblock->fs_bsize, *filesize, path);
d422 1
a422 1
	strcpy(newname, name);
d424 2
a425 2
	strcat(newname, "/r");
	strcat(newname, p);
d443 2
a445 1
	ino_t ino;
d449 37
a485 19
			case 'a':
				aflag++;
				break;
			case 'i':
				iflag++;
				addinode(strtoul(optarg, NULL, 10));
				while (optind < argc && (ino = strtoul(argv[optind], NULL, 10)) != 0) {
					addinode(ino);
					optind++;
				}
				break;
			case 'm':
				mflag++;
				break;
			case 's':
				sflag++;
				break;
			case '?':
				exit(2);
@


1.6
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.5 1997/01/15 23:41:30 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.5 1997/01/15 23:41:30 millert Exp $";
d161 2
a162 2
	register ino_t ino;
	register struct dinode *dp;
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.4 1996/08/14 06:41:37 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.4 1996/08/14 06:41:37 tholo Exp $";
d261 2
a262 2
			warnx("read error from %s: %s: [sector %d]: count=%d\n",
				disk, strerror(errno), blkno, dev_bsize);
d265 2
a266 2
		warnx("short read error from %s: [sector %d]: count=%d, got=%d\n",
			disk, blkno, dev_bsize, cnt);
d373 1
a373 1
			warnx("corrupted directory, inode %lu", ino);
d388 5
a392 2
				printf("mode %-6o uid %-5lu gid %-5lu ino ", di->di_mode, di->di_uid, di->di_gid);
			printf("%-7lu %s/%s%s\n", dp->d_ino, path, dp->d_name, mode == IFDIR ? "/." : "");
d492 1
a492 1
		errx(2, "blocksize (%d) not a power of 2", dev_bsize);
@


1.4
log
@ncheck -i would never show any information as it did not cache the directory
inodes; from OpenBSD PR #3
Also avoid recursing into . or .. directories due to misplaced test
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.3 1996/06/30 05:45:55 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.3 1996/06/30 05:45:55 tholo Exp $";
d441 1
a441 1
	while ((c = getopt(argc, argv, "ai:ms")) != EOF)
@


1.3
log
@Accept mount points and block devices
Correct search for matched inodes
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.2 1996/06/30 04:43:34 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.2 1996/06/30 04:43:34 tholo Exp $";
d67 1
d172 4
a175 3
		if (sflag &&
		    (((dp->di_mode & (ISGID | ISUID)) == 0) &&
		     ((mode == IFREG) || (mode == IFDIR) || (mode == IFLNK))))
d390 2
a396 2
		}
		if (mode == IFDIR) {
d438 1
a438 1
	int c, iflag = 0;
d490 1
a490 2
	if (!iflag)
		findinodes(sblock->fs_ipg * sblock->fs_ncg);
@


1.2
log
@Fix usage and manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: ncheck_ffs.c,v 1.1 1996/06/25 04:43:45 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: ncheck_ffs.c,v 1.1 1996/06/25 04:43:45 tholo Exp $";
d50 1
d87 1
d102 1
a102 1
		return 0;
d405 17
d434 2
d463 1
d465 12
@


1.1
log
@ncheck(8) implementation
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD$";
d406 1
a406 1
	fprintf(stderr, "Usage: ncheck [-i numbers] [-as] filesystem\n");
@
