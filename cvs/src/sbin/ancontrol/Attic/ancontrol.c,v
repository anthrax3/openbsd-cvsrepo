head	1.30;
access;
symbols
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.30
date	2006.01.09.21.22.01;	author jsg;	state dead;
branches;
next	1.29;

1.29
date	2005.12.13.00.33.59;	author cloder;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.24.11.50.47;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.19.18.26.52;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.17.19.26.01;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.05.07.54.14;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.15.22.37.41;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.13.16.36.38;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.08.13.04;	author todd;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.06.17.25.16;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.29.21.57.15;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.04.14.59.46;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.02.22.31.09;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.30.15.03.01;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.16.07.51.01;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.16.05.10.07;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.16.00.39.39;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.15.23.19.13;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.27.08.38.36;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.26.06.19.34;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.13.18.58.09;	author chris;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.17.21.57.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.22.22.56.33;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.20.17.41.50;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.18.22.27.41;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.18.20.44.33;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.20.17.28.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.03.01.08.09;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Move ancontrol to the attic, no longer needed.
@
text
@/*	$OpenBSD: ancontrol.c,v 1.29 2005/12/13 00:33:59 cloder Exp $	*/
/*
 * Copyright (c) 2001 Eric Jackson <ericj@@monkey.org>
 *
 * Copyright 1997, 1998, 1999
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/usr.sbin/ancontrol/ancontrol.c,v 1.1 2000/01/14 20:40:57 wpaul Exp $
 */

#include <sys/param.h>
#include <sys/cdefs.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <dev/ic/anvar.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <err.h>

#if !defined(lint)
static const char copyright[] = "@@(#) Copyright (c) 1997, 1998, 1999\
	Bill Paul. All rights reserved.";
static const char rcsid[] =
  "@@(#) $FreeBSD: src/usr.sbin/ancontrol/ancontrol.c,v 1.1 2000/01/14 20:40:57 wpaul Exp $";
#endif

#define	an_printbool(val) printf(val? "[ On ]" : "[ Off ]")

void an_getval(struct an_req *);
void an_setval(struct an_req *);
void an_printwords(u_int16_t *, int);
void an_printspeeds(u_int8_t*, int);
void an_printhex(char *, int);
void an_printstr(char *, int);
void an_dumpstatus(void);
void an_dumpstats(void);
void an_dumpconfig(void);
void an_dumpcaps(void);
void an_dumpssid(void);
void an_dumpap(void);
void an_setconfig(int, void *);
void an_setssid(int, void *);
void an_setap(int, void *);
void an_setspeed(void *);
void an_readkeyinfo(void);
#ifdef ANCACHE
void an_zerocache(void);
void an_readcache(void);
#endif
void getsock(void);
static void usage(void);
int main(int, char **);

/* flags to trigger dumping information about configs */
#define STAT_DUMPAP	0x01
#define STAT_DUMPCONFIG	0x02
#define STAT_DUMPCAPS	0x04
#define STAT_DUMPSSID	0x08
#define STAT_DUMPSTATUS	0x10
#define STAT_DUMPSTATS	0x20

#define ACT_SET_OPMODE 7
#define ACT_SET_SSID1 8
#define ACT_SET_SSID2 9
#define ACT_SET_SSID3 10
#define ACT_SET_FREQ 11
#define ACT_SET_AP1 12
#define ACT_SET_AP2 13
#define ACT_SET_AP3 14
#define ACT_SET_AP4 15
#define ACT_SET_DRIVERNAME 16
#define ACT_SET_SCANMODE 17
#define ACT_SET_TXRATE 18
#define ACT_SET_RTS_THRESH 19
#define ACT_SET_PWRSAVE 20
#define ACT_SET_DIVERSITY_RX 21
#define ACT_SET_DIVERSITY_TX 22
#define ACT_SET_RTS_RETRYLIM 23
#define ACT_SET_WAKE_DURATION 24
#define ACT_SET_BEACON_PERIOD 25
#define ACT_SET_TXPWR 26
#define ACT_SET_FRAG_THRESH 27
#define ACT_SET_NETJOIN 28
#define ACT_SET_MYNAME 29
#define ACT_SET_MAC 30

#define ACT_ENABLE_WEP 33
#define ACT_SET_KEY_TYPE 34
#define ACT_SET_KEYS 35
#define ACT_ENABLE_TX_KEY 36

#ifdef ANCACHE
#define ACT_DUMPCACHE 31
#define ACT_ZEROCACHE 32
#define OPTIONS "a:b:c:d:e:f:hi:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NQSTW:Z"
#else
#define OPTIONS "a:b:c:d:e:f:hi:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NSTW:"
#endif /* ANCACHE */

int s;			/* Global socket for ioctl's */
struct ifreq ifr;	/* Global ifreq */

void
getsock(void)
{
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		errx(1, "socket");
}

void
an_getval(struct an_req *areq)
{
	ifr.ifr_data = (caddr_t)areq;

	if (ioctl(s, SIOCGAIRONET, &ifr) == -1)
		err(1, "SIOCGAIRONET");

	return;
}

void
an_setval(struct an_req *areq)
{
	ifr.ifr_data = (caddr_t)areq;

	if (ioctl(s, SIOCSAIRONET, &ifr) == -1)
		err(1, "SIOCSAIRONET");

	return;
}

void
an_printstr(char *str, int len)
{
	int			i;

	for (i = 0; i < len - 1; i++) {
		if (str[i] == '\0')
			str[i] = ' ';
	}

	printf("[ %.*s ]", len, str);

	return;
}

void
an_printwords(u_int16_t *w, int len)
{
	int			i;

	printf("[ ");
	for (i = 0; i < len; i++)
		printf("%u ", w[i]);
	printf("]");

	return;
}

void
an_printspeeds(u_int8_t *w, int len)
{
	int			i;

	printf("[ ");
	for (i = 0; i < len && w[i]; i++)
		printf("%2.1fMbps ", w[i] * 0.500);
	printf("]");

	return;
}

void
an_printhex(char *ptr, int len)
{
	int			i;

	printf("[ ");
	for (i = 0; i < len; i++) {
		printf("%02x", ptr[i] & 0xFF);
		if (i < (len - 1))
			printf(":");
	}

	printf(" ]");
	return;
}

void
an_dumpstatus(void)
{
	struct an_ltv_status	*sts;
	struct an_req		areq;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_STATUS;

	an_getval(&areq);

	sts = (struct an_ltv_status *)&areq;

	printf("MAC address:\t\t");
	an_printhex((char *)&sts->an_macaddr, ETHER_ADDR_LEN);
	printf("\nOperating mode:\t\t[ ");
	if (sts->an_opmode & AN_STATUS_OPMODE_CONFIGURED)
		printf("configured ");
	if (sts->an_opmode & AN_STATUS_OPMODE_MAC_ENABLED)
		printf("MAC ON ");
	if (sts->an_opmode & AN_STATUS_OPMODE_RX_ENABLED)
		printf("RX ON ");
	if (sts->an_opmode & AN_STATUS_OPMODE_IN_SYNC)
		printf("synced ");
	if (sts->an_opmode & AN_STATUS_OPMODE_ASSOCIATED)
		printf("associated ");
	if (sts->an_opmode & AN_STATUS_OPMODE_ERROR)
		printf("error ");
	printf("]\n");
	printf("Error code:\t\t");
	an_printhex((char *)&sts->an_errcode, 1);
	printf("\nSignal strength:\t[ %u%% ]",sts->an_normalized_rssi);
	printf("\nSignal quality:\t\t");
	an_printhex((char *)&sts->an_cur_signal_quality, 1);
	printf("\nCurrent SSID:\t\t");
	an_printstr((char *)&sts->an_ssid, sts->an_ssidlen);
	printf("\nCurrent AP name:\t");
	an_printstr((char *)&sts->an_ap_name, 16);
	printf("\nCurrent BSSID:\t\t");
	an_printhex((char *)&sts->an_cur_bssid, ETHER_ADDR_LEN);
	printf("\nBeacon period:\t\t");
	an_printwords(&sts->an_beacon_period, 1);
	printf("\nDTIM period:\t\t");
	an_printwords(&sts->an_dtim_period, 1);
	printf("\nATIM duration:\t\t");
	an_printwords(&sts->an_atim_duration, 1);
	printf("\nHOP period:\t\t");
	an_printwords(&sts->an_hop_period, 1);
	printf("\nChannel set:\t\t");
	an_printwords(&sts->an_channel_set, 1);
	printf("\nCurrent channel:\t");
	an_printwords(&sts->an_cur_channel, 1);
	printf("\nHops to backbone:\t");
	an_printwords(&sts->an_hops_to_backbone, 1);
	printf("\nTotal AP load:\t\t");
	an_printwords(&sts->an_ap_total_load, 1);
	printf("\nOur generated load:\t");
	an_printwords(&sts->an_our_generated_load, 1);
	printf("\nAccumulated ARL:\t");
	an_printwords(&sts->an_accumulated_arl, 1);
	printf("\n");
	return;
}

void
an_dumpcaps(void)
{
	struct an_ltv_caps	*caps;
	struct an_req		areq;
	u_int16_t		tmp;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_CAPABILITIES;

	an_getval(&areq);

	caps = (struct an_ltv_caps *)&areq;

	printf("OUI:\t\t\t");
	an_printhex((char *)&caps->an_oui, 3);
	printf("\nProduct number:\t\t");
	an_printwords(&caps->an_prodnum, 1);
	printf("\nManufacturer name:\t");
	an_printstr((char *)&caps->an_manufname, 32);
	printf("\nProduce name:\t\t");
	an_printstr((char *)&caps->an_prodname, 16);
	printf("\nFirmware version:\t");
	an_printstr((char *)&caps->an_prodvers, 1);
	printf("\nOEM MAC address:\t");
	an_printhex((char *)&caps->an_oemaddr, ETHER_ADDR_LEN);
	printf("\nAironet MAC address:\t");
	an_printhex((char *)&caps->an_aironetaddr, ETHER_ADDR_LEN);
	printf("\nRadio type:\t\t[ ");
	if (caps->an_radiotype & AN_RADIOTYPE_80211_FH)
		printf("802.11 FH");
	else if (caps->an_radiotype & AN_RADIOTYPE_80211_DS)
		printf("802.11 DS");
	else if (caps->an_radiotype & AN_RADIOTYPE_LM2000_DS)
		printf("LM2000 DS");
	else
		printf("unknown (%x)", caps->an_radiotype);
	printf(" ]");
	printf("\nRegulatory domain:\t");
	an_printwords(&caps->an_regdomain, 1);
	printf("\nAssigned CallID:\t");
	an_printhex((char *)&caps->an_callid, 6);
	printf("\nSupported speeds:\t");
	an_printspeeds(caps->an_rates, 8);
	printf("\nRX Diversity:\t\t[ ");
	if (caps->an_rx_diversity == AN_DIVERSITY_ANTENNA_1_ONLY)
		printf("antenna 1 only");
	else if (caps->an_rx_diversity == AN_DIVERSITY_ANTENNA_2_ONLY)
		printf("antenna 2 only");
	else if (caps->an_rx_diversity == AN_DIVERSITY_ANTENNA_1_AND_2)
		printf("antenna 1 and 2");
	printf(" ]");
	printf("\nTX Diversity:\t\t[ ");
	if (caps->an_rx_diversity == AN_DIVERSITY_ANTENNA_1_ONLY)
		printf("antenna 1 only");
	else if (caps->an_rx_diversity == AN_DIVERSITY_ANTENNA_2_ONLY)
		printf("antenna 2 only");
	else if (caps->an_rx_diversity == AN_DIVERSITY_ANTENNA_1_AND_2)
		printf("antenna 1 and 2");
	printf(" ]");
	printf("\nSupported power levels:\t");
	an_printwords(caps->an_tx_powerlevels, 8);
	printf("\nHardware revision:\t");
	tmp = ntohs(caps->an_hwrev);
	an_printhex((char *)&tmp, 2);
	printf("\nSoftware revision:\t");
	tmp = ntohs(caps->an_fwrev);
	an_printhex((char *)&tmp, 2);
	printf("\nSoftware subrevision:\t");
	tmp = ntohs(caps->an_fwsubrev);
	an_printhex((char *)&tmp, 2);
	printf("\nInterface revision:\t");
	tmp = ntohs(caps->an_ifacerev);
	an_printhex((char *)&tmp, 2);
	printf("\nBootblock revision:\t");
	tmp = ntohs(caps->an_bootblockrev);
	an_printhex((char *)&tmp, 2);
	printf("\n");
	return;
}

void
an_dumpstats(void)
{
	struct an_ltv_stats	*stats;
	struct an_req		areq;
	caddr_t			ptr;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_32BITS_CUM;

	an_getval(&areq);

	ptr = (caddr_t)&areq;
	ptr -= 2;
	stats = (struct an_ltv_stats *)ptr;

	printf("RX overruns:\t\t\t\t\t[ %u ]\n", stats->an_rx_overruns);
	printf("RX PLCP CSUM errors:\t\t\t\t[ %u ]\n",
	    stats->an_rx_plcp_csum_errs);
	printf("RX PLCP format errors:\t\t\t\t[ %u ]\n",
	    stats->an_rx_plcp_format_errs);
	printf("RX PLCP length errors:\t\t\t\t[ %u ]\n",
	    stats->an_rx_plcp_len_errs);
	printf("RX MAC CRC errors:\t\t\t\t[ %u ]\n",
	    stats->an_rx_mac_crc_errs);
	printf("RX MAC CRC OK:\t\t\t\t\t[ %u ]\n",
	    stats->an_rx_mac_crc_ok);
	printf("RX WEP errors:\t\t\t\t\t[ %u ]\n",
	    stats->an_rx_wep_errs);
	printf("RX WEP OK:\t\t\t\t\t[ %u ]\n",
	    stats->an_rx_wep_ok);
	printf("Long retries:\t\t\t\t\t[ %u ]\n",
	    stats->an_retry_long);
	printf("Short retries:\t\t\t\t\t[ %u ]\n",
	    stats->an_retry_short);
	printf("Retries exhausted:\t\t\t\t[ %u ]\n",
	    stats->an_retry_max);
	printf("Bad ACK:\t\t\t\t\t[ %u ]\n",
	    stats->an_no_ack);
	printf("Bad CTS:\t\t\t\t\t[ %u ]\n",
	    stats->an_no_cts);
	printf("RX good ACKs:\t\t\t\t\t[ %u ]\n",
	    stats->an_rx_ack_ok);
	printf("RX good CTSs:\t\t\t\t\t[ %u ]\n",
	    stats->an_rx_cts_ok);
	printf("TX good ACKs:\t\t\t\t\t[ %u ]\n",
	    stats->an_tx_ack_ok);
	printf("TX good RTSs:\t\t\t\t\t[ %u ]\n",
	    stats->an_tx_rts_ok);
	printf("TX good CTSs:\t\t\t\t\t[ %u ]\n",
	    stats->an_tx_cts_ok);
	printf("LMAC multicasts transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_lmac_mcasts);
	printf("LMAC broadcasts transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_lmac_bcasts);
	printf("LMAC unicast frags transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_lmac_ucast_frags);
	printf("LMAC unicasts transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_lmac_ucasts);
	printf("Beacons transmitted:\t\t\t\t[ %u ]\n",
	    stats->an_tx_beacons);
	printf("Beacons received:\t\t\t\t[ %u ]\n",
	    stats->an_rx_beacons);
	printf("Single transmit collisions:\t\t\t[ %u ]\n",
	    stats->an_tx_single_cols);
	printf("Multiple transmit collisions:\t\t\t[ %u ]\n",
	    stats->an_tx_multi_cols);
	printf("Transmits without deferrals:\t\t\t[ %u ]\n",
	    stats->an_tx_defers_no);
	printf("Transmits deferred due to protocol:\t\t[ %u ]\n",
	    stats->an_tx_defers_prot);
	printf("Transmits deferred due to energy detect:\t\t[ %u ]\n",
	    stats->an_tx_defers_energy);
	printf("RX duplicate frames/frags:\t\t\t[ %u ]\n",
	    stats->an_rx_dups);
	printf("RX partial frames:\t\t\t\t[ %u ]\n",
	    stats->an_rx_partial);
	printf("TX max lifetime exceeded:\t\t\t[ %u ]\n",
	    stats->an_tx_too_old);
	printf("RX max lifetime exceeded:\t\t\t[ %u ]\n",
	    stats->an_tx_too_old);
	printf("Sync lost due to too many missed beacons:\t[ %u ]\n",
	    stats->an_lostsync_missed_beacons);
	printf("Sync lost due to ARL exceeded:\t\t\t[ %u ]\n",
	    stats->an_lostsync_arl_exceeded);
	printf("Sync lost due to deauthentication:\t\t[ %u ]\n",
	    stats->an_lostsync_deauthed);
	printf("Sync lost due to disassociation:\t\t[ %u ]\n",
	    stats->an_lostsync_disassociated);
	printf("Sync lost due to excess change in TSF timing:\t[ %u ]\n",
	    stats->an_lostsync_tsf_timing);
	printf("Host transmitted multicasts:\t\t\t[ %u ]\n",
	    stats->an_tx_host_mcasts);
	printf("Host transmitted broadcasts:\t\t\t[ %u ]\n",
	    stats->an_tx_host_bcasts);
	printf("Host transmitted unicasts:\t\t\t[ %u ]\n",
	    stats->an_tx_host_ucasts);
	printf("Host transmission failures:\t\t\t[ %u ]\n",
	    stats->an_tx_host_failed);
	printf("Host received multicasts:\t\t\t[ %u ]\n",
	    stats->an_rx_host_mcasts);
	printf("Host received broadcasts:\t\t\t[ %u ]\n",
	    stats->an_rx_host_bcasts);
	printf("Host received unicasts:\t\t\t\t[ %u ]\n",
	    stats->an_rx_host_ucasts);
	printf("Host receive discards:\t\t\t\t[ %u ]\n",
	    stats->an_rx_host_discarded);
	printf("HMAC transmitted multicasts:\t\t\t[ %u ]\n",
	    stats->an_tx_hmac_mcasts);
	printf("HMAC transmitted broadcasts:\t\t\t[ %u ]\n",
	    stats->an_tx_hmac_bcasts);
	printf("HMAC transmitted unicasts:\t\t\t[ %u ]\n",
	    stats->an_tx_hmac_ucasts);
	printf("HMAC transmissions failed:\t\t\t[ %u ]\n",
	    stats->an_tx_hmac_failed);
	printf("HMAC received multicasts:\t\t\t[ %u ]\n",
	    stats->an_rx_hmac_mcasts);
	printf("HMAC received broadcasts:\t\t\t[ %u ]\n",
	    stats->an_rx_hmac_bcasts);
	printf("HMAC received unicasts:\t\t\t\t[ %u ]\n",
	    stats->an_rx_hmac_ucasts);
	printf("HMAC receive discards:\t\t\t\t[ %u ]\n",
	    stats->an_rx_hmac_discarded);
	printf("HMAC transmits accepted:\t\t\t[ %u ]\n",
	    stats->an_tx_hmac_accepted);
	printf("SSID mismatches:\t\t\t\t[ %u ]\n",
	    stats->an_ssid_mismatches);
	printf("Access point mismatches:\t\t\t[ %u ]\n",
	    stats->an_ap_mismatches);
	printf("Speed mismatches:\t\t\t\t[ %u ]\n",
	    stats->an_rates_mismatches);
	printf("Authentication rejects:\t\t\t\t[ %u ]\n",
	    stats->an_auth_rejects);
	printf("Authentication timeouts:\t\t\t[ %u ]\n",
	    stats->an_auth_timeouts);
	printf("Association rejects:\t\t\t\t[ %u ]\n",
	    stats->an_assoc_rejects);
	printf("Association timeouts:\t\t\t\t[ %u ]\n",
	    stats->an_assoc_timeouts);
	printf("Management frames received:\t\t\t[ %u ]\n",
	    stats->an_rx_mgmt_pkts);
	printf("Management frames transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_mgmt_pkts);
	printf("Refresh frames received:\t\t\t[ %u ]\n",
	    stats->an_rx_refresh_pkts),
	printf("Refresh frames transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_refresh_pkts),
	printf("Poll frames received:\t\t\t\t[ %u ]\n",
	    stats->an_rx_poll_pkts);
	printf("Poll frames transmitted:\t\t\t[ %u ]\n",
	    stats->an_tx_poll_pkts);
	printf("Host requested sync losses:\t\t\t[ %u ]\n",
	    stats->an_lostsync_hostreq);
	printf("Host transmitted bytes:\t\t\t\t[ %u ]\n",
	    stats->an_host_tx_bytes);
	printf("Host received bytes:\t\t\t\t[ %u ]\n",
	    stats->an_host_rx_bytes);
	printf("Uptime in microseconds:\t\t\t\t[ %u ]\n",
	    stats->an_uptime_usecs);
	printf("Uptime in seconds:\t\t\t\t[ %u ]\n",
	    stats->an_uptime_secs);
	printf("Sync lost due to better AP:\t\t\t[ %u ]\n",
	    stats->an_lostsync_better_ap);

	return;
}

void
an_dumpap(void)
{
	struct an_ltv_aplist	*ap;
	struct an_req		areq;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_APLIST;

	an_getval(&areq);

	ap = (struct an_ltv_aplist *)&areq;
	printf("Access point 1:\t\t\t");
	an_printhex((char *)&ap->an_ap1, ETHER_ADDR_LEN);
	printf("\nAccess point 2:\t\t\t");
	an_printhex((char *)&ap->an_ap2, ETHER_ADDR_LEN);
	printf("\nAccess point 3:\t\t\t");
	an_printhex((char *)&ap->an_ap3, ETHER_ADDR_LEN);
	printf("\nAccess point 4:\t\t\t");
	an_printhex((char *)&ap->an_ap4, ETHER_ADDR_LEN);
	printf("\n");

	return;
}

void
an_dumpssid(void)
{
	struct an_ltv_ssidlist	*ssid;
	struct an_req		areq;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_SSIDLIST;

	an_getval(&areq);

	ssid = (struct an_ltv_ssidlist *)&areq;
	printf("SSID 1:\t\t\t[ %.*s ]\n", ssid->an_ssid1_len, ssid->an_ssid1);
	printf("SSID 2:\t\t\t[ %.*s ]\n", ssid->an_ssid2_len, ssid->an_ssid2);
	printf("SSID 3:\t\t\t[ %.*s ]\n", ssid->an_ssid3_len, ssid->an_ssid3);

	return;
}

void
an_dumpconfig(void)
{
	struct an_ltv_genconfig	*cfg;
	struct an_req		areq;
	unsigned char		div;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_ACTUALCFG;

	an_getval(&areq);

	cfg = (struct an_ltv_genconfig *)&areq;

	printf("Operating mode:\t\t\t\t[ ");
	if ((cfg->an_opmode & 0x7) == AN_OPMODE_IBSS_ADHOC)
		printf("ad-hoc");
	if ((cfg->an_opmode & 0x7) == AN_OPMODE_INFRASTRUCTURE_STATION)
		printf("infrastructure");
	if ((cfg->an_opmode & 0x7) == AN_OPMODE_AP)
		printf("access point");
	if ((cfg->an_opmode & 0x7) == AN_OPMODE_AP_REPEATER)
		printf("access point repeater");
	printf(" ]");
	printf("\nReceive mode:\t\t\t\t[ ");
	if ((cfg->an_rxmode & 0x7) == AN_RXMODE_BC_MC_ADDR)
		printf("broadcast/multicast/unicast");
	if ((cfg->an_rxmode & 0x7) == AN_RXMODE_BC_ADDR)
		printf("broadcast/unicast");
	if ((cfg->an_rxmode & 0x7) == AN_RXMODE_ADDR)
		printf("unicast");
	if ((cfg->an_rxmode & 0x7) == AN_RXMODE_80211_MONITOR_CURBSS)
		printf("802.11 monitor, current BSSID");
	if ((cfg->an_rxmode & 0x7) == AN_RXMODE_80211_MONITOR_ANYBSS)
		printf("802.11 monitor, any BSSID");
	if ((cfg->an_rxmode & 0x7) == AN_RXMODE_LAN_MONITOR_CURBSS)
		printf("LAN monitor, current BSSID");
	printf(" ]");
	printf("\nFragment threshold:\t\t\t");
	an_printwords(&cfg->an_fragthresh, 1);
	printf("\nRTS threshold:\t\t\t\t");
	an_printwords(&cfg->an_rtsthresh, 1);
	printf("\nMAC address:\t\t\t\t");
	an_printhex((char *)&cfg->an_macaddr, ETHER_ADDR_LEN);
	printf("\nSupported rates:\t\t\t");
	an_printspeeds(cfg->an_rates, 8);
	printf("\nShort retry limit:\t\t\t");
	an_printwords(&cfg->an_shortretry_limit, 1);
	printf("\nLong retry limit:\t\t\t");
	an_printwords(&cfg->an_longretry_limit, 1);
	printf("\nTX MSDU lifetime:\t\t\t");
	an_printwords(&cfg->an_tx_msdu_lifetime, 1);
	printf("\nRX MSDU lifetime:\t\t\t");
	an_printwords(&cfg->an_rx_msdu_lifetime, 1);
	printf("\nStationary:\t\t\t\t");
	an_printbool(cfg->an_stationary);
	printf("\nOrdering:\t\t\t\t");
	an_printbool(cfg->an_ordering);
	printf("\nDevice type:\t\t\t\t[ ");
	if (cfg->an_devtype == AN_DEVTYPE_PC4500)
		printf("PC4500");
	else if (cfg->an_devtype == AN_DEVTYPE_PC4800)
		printf("PC4800");
	else
		printf("unknown (%x)", cfg->an_devtype);
	printf(" ]");
	printf("\nScanning mode:\t\t\t\t[ ");
	if (cfg->an_scanmode == AN_SCANMODE_ACTIVE)
		printf("active");
	if (cfg->an_scanmode == AN_SCANMODE_PASSIVE)
		printf("passive");
	if (cfg->an_scanmode == AN_SCANMODE_AIRONET_ACTIVE)
		printf("Aironet active");
	printf(" ]");
	printf("\nProbe delay:\t\t\t\t");
	an_printwords(&cfg->an_probedelay, 1);
	printf("\nProbe energy timeout:\t\t\t");
	an_printwords(&cfg->an_probe_energy_timeout, 1);
	printf("\nProbe response timeout:\t\t\t");
	an_printwords(&cfg->an_probe_response_timeout, 1);
	printf("\nBeacon listen timeout:\t\t\t");
	an_printwords(&cfg->an_beacon_listen_timeout, 1);
	printf("\nIBSS join network timeout:\t\t");
	an_printwords(&cfg->an_ibss_join_net_timeout, 1);
	printf("\nAuthentication timeout:\t\t\t");
	an_printwords(&cfg->an_auth_timeout, 1);
	printf("\nWEP enabled:\t\t\t\t[ ");
	if (cfg->an_authtype & AN_AUTHTYPE_PRIVACY_IN_USE) {
		if (cfg->an_authtype & AN_AUTHTYPE_ALLOW_UNENCRYPTED)
			printf("mixed cell");
		else
			printf("full");
	} else
		printf("no");
	printf(" ]");
	printf("\nAuthentication type:\t\t\t[ ");
	if ((cfg->an_authtype & AN_AUTHTYPE_MASK) == AN_AUTHTYPE_NONE)
		printf("none");
	if ((cfg->an_authtype & AN_AUTHTYPE_MASK) == AN_AUTHTYPE_OPEN)
		printf("open");
	if ((cfg->an_authtype & AN_AUTHTYPE_MASK) == AN_AUTHTYPE_SHAREDKEY)
		printf("shared key");
	printf(" ]");
	printf("\nAssociation timeout:\t\t\t");
	an_printwords(&cfg->an_assoc_timeout, 1);
	printf("\nSpecified AP association timeout:\t");
	an_printwords(&cfg->an_specified_ap_timeout, 1);
	printf("\nOffline scan interval:\t\t\t");
	an_printwords(&cfg->an_offline_scan_interval, 1);
	printf("\nOffline scan duration:\t\t\t");
	an_printwords(&cfg->an_offline_scan_duration, 1);
	printf("\nLink loss delay:\t\t\t");
	an_printwords(&cfg->an_link_loss_delay, 1);
	printf("\nMax beacon loss time:\t\t\t");
	an_printwords(&cfg->an_max_beacon_lost_time, 1);
	printf("\nRefresh interval:\t\t\t");
	an_printwords(&cfg->an_refresh_interval, 1);
	printf("\nPower save mode:\t\t\t[ ");
	if (cfg->an_psave_mode == AN_PSAVE_NONE)
		printf("none");
	if (cfg->an_psave_mode == AN_PSAVE_CAM)
		printf("constantly awake mode");
	if (cfg->an_psave_mode == AN_PSAVE_PSP)
		printf("PSP");
	if (cfg->an_psave_mode == AN_PSAVE_PSP_CAM)
		printf("PSP-CAM (fast PSP)");
	printf(" ]");
	printf("\nSleep through DTIMs:\t\t\t");
	an_printbool(cfg->an_sleep_for_dtims);
	printf("\nPower save listen interval:\t\t");
	an_printwords(&cfg->an_listen_interval, 1);
	printf("\nPower save fast listen interval:\t");
	an_printwords(&cfg->an_fast_listen_interval, 1);
	printf("\nPower save listen decay:\t\t");
	an_printwords(&cfg->an_listen_decay, 1);
	printf("\nPower save fast listen decay:\t\t");
	an_printwords(&cfg->an_fast_listen_decay, 1);
	printf("\nAP/ad-hoc Beacon period:\t\t");
	an_printwords(&cfg->an_beacon_period, 1);
	printf("\nAP/ad-hoc ATIM duration:\t\t");
	an_printwords(&cfg->an_atim_duration, 1);
	printf("\nAP/ad-hoc current channel:\t\t");
	an_printwords(&cfg->an_ds_channel, 1);
	printf("\nAP/ad-hoc DTIM period:\t\t\t");
	an_printwords(&cfg->an_dtim_period, 1);
	printf("\nRadio type:\t\t\t\t[ ");
	if (cfg->an_radiotype & AN_RADIOTYPE_80211_FH)
		printf("802.11 FH");
	else if (cfg->an_radiotype & AN_RADIOTYPE_80211_DS)
		printf("802.11 DS");
	else if (cfg->an_radiotype & AN_RADIOTYPE_LM2000_DS)
		printf("LM2000 DS");
	else
		printf("unknown (%x)", cfg->an_radiotype);
	printf(" ]");
	printf("\nRX Diversity:\t\t\t\t[ ");
	div = cfg->an_diversity & 0xFF;
	if (div == AN_DIVERSITY_ANTENNA_1_ONLY)
		printf("antenna 1 only");
	else if (div == AN_DIVERSITY_ANTENNA_2_ONLY)
		printf("antenna 2 only");
	else if (div == AN_DIVERSITY_ANTENNA_1_AND_2)
		printf("antenna 1 and 2");
	printf(" ]");
	printf("\nTX Diversity:\t\t\t\t[ ");
	div = (cfg->an_diversity >> 8) & 0xFF;
	if (div == AN_DIVERSITY_ANTENNA_1_ONLY)
		printf("antenna 1 only");
	else if (div == AN_DIVERSITY_ANTENNA_2_ONLY)
		printf("antenna 2 only");
	else if (div == AN_DIVERSITY_ANTENNA_1_AND_2)
		printf("antenna 1 and 2");
	printf(" ]");
	printf("\nTransmit power level:\t\t\t");
	an_printwords(&cfg->an_tx_power, 1);
	printf("\nRSS threshold:\t\t\t\t");
	an_printwords(&cfg->an_rss_thresh, 1);
	printf("\nNode name:\t\t\t\t");
	an_printstr((char *)&cfg->an_nodename, 16);
	printf("\nARL threshold:\t\t\t\t");
	an_printwords(&cfg->an_arl_thresh, 1);
	printf("\nARL decay:\t\t\t\t");
	an_printwords(&cfg->an_arl_decay, 1);
	printf("\nARL delay:\t\t\t\t");
	an_printwords(&cfg->an_arl_delay, 1);

	printf("\n");
	an_readkeyinfo();

	return;
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: ancontrol [interface] [-AChINST] [[-v 1|2|3|4] -a AP]\n"
	    "       [-b beacon_period] [-c channel] [-v 0|1 -d 0|1|2|3]\n"
	    "       [-e 0|1|2|3] [-f fragmentation_threshold] [-j netjoin_timeout]\n"
	    "       [-K 0|1|2] [-v 0|1|2|3|4|5|6|7 -k key] [-l station_name]\n"
	    "       [-m macaddress] [[-v 1|2|3] -n SSID] [-o 0|1] [-p tx_power]\n"
	    "       [-r RTS_threshold] [-s 0|1|2|3] [-t 0|1|2|3|4] [-W 0|1|2]\n");
#ifdef ANCACHE
	fprintf(stderr,
	    "       [-QZ]\n");
#endif
	exit(1);
}

void
an_setconfig(int act, void *arg)
{
	struct an_ltv_genconfig	*cfg;
	struct an_ltv_caps	*caps;
	struct an_req		areq;
	struct an_req		areq_caps;
	u_int16_t		diversity = 0;
	struct ether_addr	*addr;
	int			i;

	bzero((char *)&areq, sizeof(struct an_req));
	bzero((char *)&areq_caps, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_GENCONFIG;
	an_getval(&areq);
	cfg = (struct an_ltv_genconfig *)&areq;

	areq_caps.an_len = sizeof(areq);
	areq_caps.an_type = AN_RID_CAPABILITIES;
	an_getval(&areq_caps);
	caps = (struct an_ltv_caps *)&areq_caps;

	switch(act) {
	case ACT_SET_OPMODE:
		cfg->an_opmode = atoi(arg);
		break;
	case ACT_SET_FREQ:
		cfg->an_ds_channel = atoi(arg);
		break;
	case ACT_SET_PWRSAVE:
		cfg->an_psave_mode = atoi(arg);
		break;
	case ACT_SET_SCANMODE:
		cfg->an_scanmode = atoi(arg);
		break;
	case ACT_SET_DIVERSITY_RX:
	case ACT_SET_DIVERSITY_TX:
		switch(atoi(arg)) {
		case 0:
			diversity = AN_DIVERSITY_FACTORY_DEFAULT;
			break;
		case 1:
			diversity = AN_DIVERSITY_ANTENNA_1_ONLY;
			break;
		case 2:
			diversity = AN_DIVERSITY_ANTENNA_2_ONLY;
			break;
		case 3:
			diversity = AN_DIVERSITY_ANTENNA_1_AND_2;
			break;
		default:
			errx(1, "bad diversity setting: %u", diversity);
			break;
		}
		if (act == ACT_SET_DIVERSITY_TX) {
			cfg->an_diversity &= 0x00FF;
			cfg->an_diversity |= (diversity << 8);
		} else {
			cfg->an_diversity &= 0xFF00;
			cfg->an_diversity |= diversity;
		}
		break;
	case ACT_SET_TXPWR:
		for (i = 0; i < 8; i++) {
			if (caps->an_tx_powerlevels[i] == atoi(arg))
				break;
		}
		if (i == 8)
			errx(1, "unsupported power level: %dmW", atoi(arg));

		cfg->an_tx_power = atoi(arg);
		break;
	case ACT_SET_RTS_THRESH:
		cfg->an_rtsthresh = atoi(arg);
		break;
	case ACT_SET_RTS_RETRYLIM:
		cfg->an_shortretry_limit =
		   cfg->an_longretry_limit = atoi(arg);
		break;
	case ACT_SET_BEACON_PERIOD:
		cfg->an_beacon_period = atoi(arg);
		break;
	case ACT_SET_WAKE_DURATION:
		cfg->an_atim_duration = atoi(arg);
		break;
	case ACT_SET_FRAG_THRESH:
		cfg->an_fragthresh = atoi(arg);
		break;
	case ACT_SET_NETJOIN:
		cfg->an_ibss_join_net_timeout = atoi(arg);
		break;
	case ACT_SET_MYNAME:
		bzero(cfg->an_nodename, 16);
		strncpy((char *)&cfg->an_nodename, optarg, 16);
		break;
	case ACT_SET_MAC:
		addr = ether_aton((char *)arg);

		if (addr == NULL)
			errx(1, "badly formatted address");
		bzero(cfg->an_macaddr, ETHER_ADDR_LEN);
		bcopy((char *)addr, (char *)&cfg->an_macaddr, ETHER_ADDR_LEN);
		break;
	case ACT_ENABLE_WEP:
		switch(atoi(arg)) {
		case 0:	/* WEP disabled */
			cfg->an_authtype &= ~(AN_AUTHTYPE_PRIVACY_IN_USE
					| AN_AUTHTYPE_ALLOW_UNENCRYPTED);
			break;
		case 1:	/* WEP enabled */
			cfg->an_authtype |= AN_AUTHTYPE_PRIVACY_IN_USE;
			cfg->an_authtype &= ~AN_AUTHTYPE_ALLOW_UNENCRYPTED;
			break;
		case 2:	/* WEP optional */
			cfg->an_authtype = AN_AUTHTYPE_PRIVACY_IN_USE
					| AN_AUTHTYPE_ALLOW_UNENCRYPTED;
			break;
		}
		break;
	case ACT_SET_KEY_TYPE:
		cfg->an_authtype = (cfg->an_authtype & ~AN_AUTHTYPE_MASK)
			| atoi(arg);
		break;
	default:
		errx(1, "unknown action");
		break;
	}

	an_setval(&areq);
}

void
an_setspeed(void *arg)
{
	struct an_req		areq;
	struct an_ltv_caps	*caps;
	u_int16_t		speed;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_CAPABILITIES;

	an_getval(&areq);
	caps = (struct an_ltv_caps *)&areq;

	switch(atoi(arg)) {
	case 0:
		speed = 0;
		break;
	case 1:
		speed = AN_RATE_1MBPS;
		break;
	case 2:
		speed = AN_RATE_2MBPS;
		break;
	case 3:
		if (caps->an_rates[2] != AN_RATE_5_5MBPS)
			errx(1, "5.5Mbps not supported on this card");
		speed = AN_RATE_5_5MBPS;
		break;
	case 4:
		if (caps->an_rates[3] != AN_RATE_11MBPS)
			errx(1, "11Mbps not supported on this card");
		speed = AN_RATE_11MBPS;
		break;
	default:
		errx(1, "unsupported speed");
		break;
	}

	areq.an_len = 6;
	areq.an_type = AN_RID_TX_SPEED;
	areq.an_val[0] = speed;

	an_setval(&areq);
}

void
an_setap(int act, void *arg)
{
	struct an_ltv_aplist	*ap;
	struct an_req		areq;
	struct ether_addr	*addr;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_APLIST;

	an_getval(&areq);
	ap = (struct an_ltv_aplist *)&areq;

	addr = ether_aton((char *)arg);

	if (addr == NULL)
		errx(1, "badly formatted address");

	switch(act) {
	case ACT_SET_AP1:
		bzero(ap->an_ap1, ETHER_ADDR_LEN);
		bcopy((char *)addr, (char *)&ap->an_ap1, ETHER_ADDR_LEN);
		break;
	case ACT_SET_AP2:
		bzero(ap->an_ap2, ETHER_ADDR_LEN);
		bcopy((char *)addr, (char *)&ap->an_ap2, ETHER_ADDR_LEN);
		break;
	case ACT_SET_AP3:
		bzero(ap->an_ap3, ETHER_ADDR_LEN);
		bcopy((char *)addr, (char *)&ap->an_ap3, ETHER_ADDR_LEN);
		break;
	case ACT_SET_AP4:
		bzero(ap->an_ap4, ETHER_ADDR_LEN);
		bcopy((char *)addr, (char *)&ap->an_ap4, ETHER_ADDR_LEN);
		break;
	default:
		errx(1, "unknown action");
		break;
	}

	an_setval(&areq);
}

void
an_setssid(int act, void *arg)
{
	struct an_ltv_ssidlist	*ssid;
	struct an_req		areq;

	bzero((char *)&areq, sizeof(struct an_req));
	areq.an_len = sizeof(areq);
	areq.an_type = AN_RID_SSIDLIST;

	an_getval(&areq);
	ssid = (struct an_ltv_ssidlist *)&areq;

	switch (act) {
	case ACT_SET_SSID1:
		bzero(ssid->an_ssid1, sizeof(ssid->an_ssid1));
		strlcpy(ssid->an_ssid1, (char *)arg, sizeof(ssid->an_ssid1));
		ssid->an_ssid1_len = strlen(ssid->an_ssid1);
		break;
	case ACT_SET_SSID2:
		bzero(ssid->an_ssid2, sizeof(ssid->an_ssid2));
		strlcpy(ssid->an_ssid2, (char *)arg, sizeof(ssid->an_ssid2));
		ssid->an_ssid2_len = strlen(ssid->an_ssid2);
		break;
	case ACT_SET_SSID3:
		bzero(ssid->an_ssid3, sizeof(ssid->an_ssid3));
		strlcpy(ssid->an_ssid3, (char *)arg, sizeof(ssid->an_ssid3));
		ssid->an_ssid3_len = strlen(ssid->an_ssid3);
		break;
	default:
		errx(1, "unknown action");
		break;
	}

	an_setval(&areq);
}

#ifdef ANCACHE
void
an_zerocache(void)
{
	struct an_req		areq;

	bzero((char *)&areq, sizeof(areq));
	areq.an_len = 0;
	areq.an_type = AN_RID_ZERO_CACHE;

	an_getval(&areq);

	return;
}

void
an_readcache(void)
{
	struct an_req		areq;
	int			*an_sigitems;
	struct an_sigcache	*sc;
	char *			pt;
	int			i;
	struct in_addr		iaddr;

	bzero((char *)&areq, sizeof(areq));
	areq.an_len = AN_MAX_DATALEN;
	areq.an_type = AN_RID_READ_CACHE;

	an_getval(&areq);

	an_sigitems = (int *) &areq.an_val;
	pt = ((char *) &areq.an_val);
	pt += sizeof(int);
	sc = (struct an_sigcache *) pt;

	for (i = 0; i < *an_sigitems; i++, sc++) {
		iaddr.s_addr = sc->ipsrc;
		printf("[%d/%d]: %02x:%02x:%02x:%02x:%02x:%02x, %s, sig: %d\n",
		    i + 1, *an_sigitems,
		    sc->macsrc[0], sc->macsrc[1], sc->macsrc[2],
		    sc->macsrc[3], sc->macsrc[4], sc->macsrc[5],
		    inet_ntoa(iaddr), sc->signal);
	}
}
#endif /* ANCACHE */

int
an_hex2int(char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'A' && c <= 'F')
		return (c - 'A' + 10);
	if (c >= 'a' && c <= 'f')
		return (c - 'a' + 10);

	return (0);
}

void
an_str2key(char *s, struct an_ltv_key *k)
{
	int			n, i;
	char			*p;

	/* Is this a hex string? */
	if ((s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))) {
		/* Yes, convert to int */
		n = 0;
		p = (char *)&k->key[0];
		for (i = 2; i < strlen(s); i += 2) {
			*p++ = (an_hex2int(s[i]) << 4) + an_hex2int(s[i + 1]);
			n++;
		}
		k->klen = n;
	} else {
		/* No, just copy it in */
		bcopy(s, k->key, strlen(s));
		k->klen = strlen(s);
	}

	return;
}

void
an_setkeys(char *key, int keytype)
{
	struct an_req		areq;
	struct an_ltv_key	*k;

	bzero((char *)&areq, sizeof(areq));
	k = (struct an_ltv_key *)&areq;

	if (strlen(key) > 28)
		err(1, "encryption key must be no more than 18 chars long");

	an_str2key(key, k);

	k->kindex = keytype / 2;

	if (!(k->klen == 0 || k->klen == 5 || k->klen == 13)) {
		err(1, "encryption key must be 0, 5 or 13 bytes long");
	}

	/* default mac and only valid one (from manual) 1:0:0:0:0:0 */
	k->mac[0] = 1;
	k->mac[1] = 0;
	k->mac[2] = 0;
	k->mac[3] = 0;
	k->mac[4] = 0;
	k->mac[5] = 0;

	areq.an_len = sizeof(struct an_ltv_key);
	areq.an_type = (keytype & 1)
	    ? AN_RID_WEP_VOLATILE : AN_RID_WEP_PERMANENT;
	an_setval(&areq);

	return;
}

void
an_readkeyinfo(void)
{
	struct an_req		areq;
	struct an_ltv_key	*k;
	int			i;

	bzero((char *)&areq, sizeof(areq));
	k = (struct an_ltv_key *)&areq;

	printf ("\nWEP Key status:\n");
	areq.an_type = AN_RID_WEP_VOLATILE;	/* read first key */
	for (i = 0; i < 4; i++) {
		areq.an_len = sizeof(struct an_ltv_key);
		an_getval(&areq);
		for (; i < k->kindex && i < 4; i++)
			printf("\tKey %d is unset\n", i);
		if (i < 4) {
			switch (k->klen) {
			case 0:
				printf("\tKey %d is unset\n", i);
				break;
			case 5:
				printf("\tKey %d is set  40 bits\n", i);
				break;
			case 13:
				printf("\tKey %d is set 128 bits\n", i);
				break;
			default:
				printf("\tKey %d has an unknown size %d\n", i, k->klen);
				break;
			}
		}
		areq.an_type = AN_RID_WEP_PERMANENT;	/* read next key */
	}
	k->kindex = 0xffff;
	areq.an_len = sizeof(struct an_ltv_key);
	an_getval(&areq);
	printf("\tThe active transmit key is %d\n", k->mac[0]);

	return;
}

void
an_enable_tx_key(char *arg)
{
	struct an_req		areq;
	struct an_ltv_key	*k;

	bzero((char *)&areq, sizeof(areq));
	k = (struct an_ltv_key *)&areq;

	/*
	 * From a Cisco engineer:  Write the transmit key
	 * to use in the first MAC, index is FFFF
	 */
	k->kindex = 0xFFFF;
	k->klen = 0;

	k->mac[0] = atoi(arg);
	k->mac[1] = 0;
	k->mac[2] = 0;
	k->mac[3] = 0;
	k->mac[4] = 0;
	k->mac[5] = 0;

	areq.an_len = sizeof(struct an_ltv_key);
	areq.an_type = AN_RID_WEP_PERMANENT;
	an_setval(&areq);

	return;
}

int
main(int argc, char *argv[])
{
	int modifier = 0, print_stat = 0, ifspecified = 0;
	int ch;

	strlcpy(ifr.ifr_name, "an0", sizeof(ifr.ifr_name));
	if (argc > 1 && argv[1][0] != '-') {
		strlcpy(ifr.ifr_name, argv[1], sizeof(ifr.ifr_name));
		ifspecified = 1;
		optind = 2;
	}

	/* Grab a socket to do our ioctl's */
	getsock();

	while ((ch = getopt(argc, argv, OPTIONS)) != -1) {
		switch (ch) {
		case 'i':
			if (!ifspecified)
				strlcpy(ifr.ifr_name, optarg, sizeof(ifr.ifr_name));
			break;
		case 'A':
			print_stat |= STAT_DUMPAP;
			break;
		case 'C':
			print_stat |= STAT_DUMPCONFIG;
			break;
		case 'I':
			print_stat |= STAT_DUMPCAPS;
			break;
		case 'K':
			an_setconfig(ACT_SET_KEY_TYPE, optarg);
			break;
		case 'N':
			print_stat |= STAT_DUMPSSID;
			break;
		case 'S':
			print_stat |= STAT_DUMPSTATUS;
			break;
		case 'T':
			print_stat |= STAT_DUMPSTATS;
			break;
		case 'W':
			an_setconfig(ACT_ENABLE_WEP, optarg);
			break;
#ifdef ANCACHE
		case 'Q':
			an_readcache();
			break;
		case 'Z':
			an_zerocache();
			break;
#endif /* ANCACHE */
		case 'a':
			switch (modifier) {
			case 0:
			case 1:
				an_setap(ACT_SET_AP1, optarg);
				break;
			case 2:
				an_setap(ACT_SET_AP2, optarg);
				break;
			case 3:
				an_setap(ACT_SET_AP3, optarg);
				break;
			case 4:
				an_setap(ACT_SET_AP4, optarg);
				break;
			default:
				errx(1, "bad modifier %d", modifier);
			}
			modifier = 0;
			break;
		case 'b':
			an_setconfig(ACT_SET_BEACON_PERIOD, optarg);
			break;
		case 'c':
			an_setconfig(ACT_SET_FREQ, optarg);
			break;
		case 'd':
			switch (modifier) {
			case 0:
				an_setconfig(ACT_SET_DIVERSITY_RX, optarg);
				break;
			case 1:
				an_setconfig(ACT_SET_DIVERSITY_TX, optarg);
				break;
			default:
				errx(1, "must specify RX or TX diversity");
			}
			modifier = 0;
			break;
		case 'e':
			an_enable_tx_key(optarg);
			break;
		case 'f':
			an_setconfig(ACT_SET_FRAG_THRESH, optarg);
			break;
		case 'h':
			usage();
			break;
		case 'j':
			an_setconfig(ACT_SET_NETJOIN, optarg);
			break;
		case 'k':
			an_setkeys(optarg, modifier);
			break;
		case 'l':
			an_setconfig(ACT_SET_MYNAME, optarg);
			break;
		case 'm':
			an_setconfig(ACT_SET_MAC, optarg);
			break;
		case 'n':
			switch (modifier) {
			case 0:
			case 1:
				an_setssid(ACT_SET_SSID1, optarg);
				break;
			case 2:
				an_setssid(ACT_SET_SSID2, optarg);
				break;
			case 3:
				an_setssid(ACT_SET_SSID3, optarg);
				break;
			default:
				errx(1, "bad modifier %d", modifier);
			}
			modifier = 0;
			break;
		case 'o':
			an_setconfig(ACT_SET_OPMODE, optarg);
			break;
		case 'p':
			an_setconfig(ACT_SET_TXPWR, optarg);
			break;
		case 'q':
			an_setconfig(ACT_SET_RTS_RETRYLIM, optarg);
			break;
		case 'r':
			an_setconfig(ACT_SET_RTS_THRESH, optarg);
			break;
		case 's':
			an_setconfig(ACT_SET_PWRSAVE, optarg);
			break;
		case 't':
			an_setspeed(optarg);
			break;
		case 'v':
			modifier = atoi(optarg);
			break;
		case 'w':
			an_setconfig(ACT_SET_WAKE_DURATION, optarg);
			break;
		default:
			usage();
		}
	}

	/*
	 * Show configuration status first. Do not allow
	 * the showing of and setting of options to be done
	 * on the same command line.
	 */
	if (print_stat) {
		if (print_stat & STAT_DUMPAP)
			an_dumpap();
		if (print_stat & STAT_DUMPCONFIG)
			an_dumpconfig();
		if (print_stat & STAT_DUMPCAPS)
			an_dumpcaps();
		if (print_stat & STAT_DUMPSSID)
			an_dumpssid();
		if (print_stat & STAT_DUMPSTATUS)
			an_dumpstatus();
		if (print_stat & STAT_DUMPSTATS)
			an_dumpstats();
	}

	/* Close our socket */
	if (s)
		close(s);

	return (0);
}
@


1.29
log
@Fix an assignment (=) where an equality test (==) was meant.  Found by
lint.  OK millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.28 2004/10/24 11:50:47 deraadt Exp $	*/
@


1.28
log
@unify device selection
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.27 2004/08/19 18:26:52 jmc Exp $	*/
d1123 1
a1123 1
	if ((s[0] = '0' && (s[1] == 'x' || s[1] == 'X'))) {
@


1.27
log
@- sort options and sync usage()
- a few other tweaks

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.26 2004/08/17 19:26:01 mickey Exp $	*/
d132 1
a132 1
#define OPTIONS "a:b:c:d:e:f:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NQSTW:Z"
d134 1
a134 1
#define OPTIONS "a:b:c:d:e:f:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NSTW:"
d1253 1
a1254 2
	int modifier = 0;
	int print_stat = 0;
d1256 5
a1260 13
	/* Grab device name, if one is given. Default to "an0" */
	opterr = 0;
	ch = getopt(argc, argv, "i:");
	if (ch == 'i') {
		strlcpy(ifr.ifr_name, optarg, sizeof(ifr.ifr_name));
	} else {
		if (argc > 1 && argv[1][0] != '-') {
			strlcpy(ifr.ifr_name, argv[1], sizeof(ifr.ifr_name));
			optind = 2;
		} else {
			strlcpy(ifr.ifr_name, "an0", sizeof(ifr.ifr_name));
			optind = 1;
		}
a1261 1
	opterr = optreset = 1;
d1267 5
a1271 1
		switch(ch) {
@


1.26
log
@missing inet_ntoa proto and fix an error it uncovers; form Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.25 2004/08/05 07:54:14 mickey Exp $	*/
d784 6
a789 6
	    "usage: ancontrol interface [-ACINSTh] [-t 0|1|2|3|4]\n"
	    "       [-s 0|1|2|3] [-v 1|2|3|4] [-a AP] [-b beacon period] [-v 0|1]\n"
	    "       [-d 1|2|3|4] [-e 0|1|2|3] [-j netjoin timeout] [-v 0|1|2|3|4|5|6|7[\n"
	    "       [-k key] [-K 0|1|2] [-l station name] [-m macaddress] [-v 1|2|3]\n"
	    "       [-n SSID] [-o 0|1] [-p tx power] [-c channel number]\n"
	    "       [-f fragmentation threshold] [-r RTS threshold] [-W 0|1|2]\n");
d792 1
a792 1
	    "       [-Q] [-Z]\n");
@


1.25
log
@better signal cache printf
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.24 2004/07/15 22:37:41 mickey Exp $	*/
d46 1
d1079 1
d1092 2
a1093 1
	for (i = 0; i < *an_sigitems; i++, sc++)
d1098 2
a1099 1
		    inet_ntoa(sc->ipsrc), sc->signal);
@


1.24
log
@fix for setting antena diversity; from Brian Falk <falk@@seas.upenn.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.23 2004/05/13 16:36:38 mickey Exp $	*/
d1090 6
a1095 14
	for (i = 0; i < *an_sigitems; i++) {
		printf("[%d/%d]:", i+1, *an_sigitems);
		printf(" %02x:%02x:%02x:%02x:%02x:%02x,",
		    sc->macsrc[0]&0xff, sc->macsrc[1]&0xff,
		    sc->macsrc[2]&0xff, sc->macsrc[3]&0xff,
		    sc->macsrc[4]&0xff, sc->macsrc[5]&0xff);
		printf(" %u.%u.%u.%u,",
		    ((sc->ipsrc >> 0) & 0xff), ((sc->ipsrc >> 8) & 0xff),
		    ((sc->ipsrc >> 16) & 0xff), ((sc->ipsrc >> 24) & 0xff));
		printf(" sig: %d\n", sc->signal);
		sc++;
	}

	return;
@


1.23
log
@fields are unsigned -- printf 'em accordingly; from David Hill <davidh@@wmis.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.22 2003/06/11 06:22:12 deraadt Exp $	*/
d851 1
a851 1
		if (atoi(arg) == ACT_SET_DIVERSITY_RX) {
d1346 1
a1346 1
				an_setconfig(ACT_SET_DIVERSITY_RX, optarg);
@


1.22
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.21 2002/06/09 08:13:04 todd Exp $	*/
d190 1
a190 1
		printf("%d ", w[i]);
d257 1
a257 1
	printf("\nSignal strength:\t[ %d%% ]",sts->an_normalized_rssi);
d389 2
a390 2
	printf("RX overruns:\t\t\t\t\t[ %d ]\n", stats->an_rx_overruns);
	printf("RX PLCP CSUM errors:\t\t\t\t[ %d ]\n",
d392 1
a392 1
	printf("RX PLCP format errors:\t\t\t\t[ %d ]\n",
d394 1
a394 1
	printf("RX PLCP length errors:\t\t\t\t[ %d ]\n",
d396 1
a396 1
	printf("RX MAC CRC errors:\t\t\t\t[ %d ]\n",
d398 1
a398 1
	printf("RX MAC CRC OK:\t\t\t\t\t[ %d ]\n",
d400 1
a400 1
	printf("RX WEP errors:\t\t\t\t\t[ %d ]\n",
d402 1
a402 1
	printf("RX WEP OK:\t\t\t\t\t[ %d ]\n",
d404 1
a404 1
	printf("Long retries:\t\t\t\t\t[ %d ]\n",
d406 1
a406 1
	printf("Short retries:\t\t\t\t\t[ %d ]\n",
d408 1
a408 1
	printf("Retries exhausted:\t\t\t\t[ %d ]\n",
d410 1
a410 1
	printf("Bad ACK:\t\t\t\t\t[ %d ]\n",
d412 1
a412 1
	printf("Bad CTS:\t\t\t\t\t[ %d ]\n",
d414 1
a414 1
	printf("RX good ACKs:\t\t\t\t\t[ %d ]\n",
d416 1
a416 1
	printf("RX good CTSs:\t\t\t\t\t[ %d ]\n",
d418 1
a418 1
	printf("TX good ACKs:\t\t\t\t\t[ %d ]\n",
d420 1
a420 1
	printf("TX good RTSs:\t\t\t\t\t[ %d ]\n",
d422 1
a422 1
	printf("TX good CTSs:\t\t\t\t\t[ %d ]\n",
d424 1
a424 1
	printf("LMAC multicasts transmitted:\t\t\t[ %d ]\n",
d426 1
a426 1
	printf("LMAC broadcasts transmitted:\t\t\t[ %d ]\n",
d428 1
a428 1
	printf("LMAC unicast frags transmitted:\t\t\t[ %d ]\n",
d430 1
a430 1
	printf("LMAC unicasts transmitted:\t\t\t[ %d ]\n",
d432 1
a432 1
	printf("Beacons transmitted:\t\t\t\t[ %d ]\n",
d434 1
a434 1
	printf("Beacons received:\t\t\t\t[ %d ]\n",
d436 1
a436 1
	printf("Single transmit collisions:\t\t\t[ %d ]\n",
d438 1
a438 1
	printf("Multiple transmit collisions:\t\t\t[ %d ]\n",
d440 1
a440 1
	printf("Transmits without deferrals:\t\t\t[ %d ]\n",
d442 1
a442 1
	printf("Transmits deferred due to protocol:\t\t[ %d ]\n",
d444 1
a444 1
	printf("Transmits deferred due to energy detect:\t\t[ %d ]\n",
d446 1
a446 1
	printf("RX duplicate frames/frags:\t\t\t[ %d ]\n",
d448 1
a448 1
	printf("RX partial frames:\t\t\t\t[ %d ]\n",
d450 1
a450 1
	printf("TX max lifetime exceeded:\t\t\t[ %d ]\n",
d452 1
a452 1
	printf("RX max lifetime exceeded:\t\t\t[ %d ]\n",
d454 1
a454 1
	printf("Sync lost due to too many missed beacons:\t[ %d ]\n",
d456 1
a456 1
	printf("Sync lost due to ARL exceeded:\t\t\t[ %d ]\n",
d458 1
a458 1
	printf("Sync lost due to deauthentication:\t\t[ %d ]\n",
d460 1
a460 1
	printf("Sync lost due to disassociation:\t\t[ %d ]\n",
d462 1
a462 1
	printf("Sync lost due to excess change in TSF timing:\t[ %d ]\n",
d464 1
a464 1
	printf("Host transmitted multicasts:\t\t\t[ %d ]\n",
d466 1
a466 1
	printf("Host transmitted broadcasts:\t\t\t[ %d ]\n",
d468 1
a468 1
	printf("Host transmitted unicasts:\t\t\t[ %d ]\n",
d470 1
a470 1
	printf("Host transmission failures:\t\t\t[ %d ]\n",
d472 1
a472 1
	printf("Host received multicasts:\t\t\t[ %d ]\n",
d474 1
a474 1
	printf("Host received broadcasts:\t\t\t[ %d ]\n",
d476 1
a476 1
	printf("Host received unicasts:\t\t\t\t[ %d ]\n",
d478 1
a478 1
	printf("Host receive discards:\t\t\t\t[ %d ]\n",
d480 1
a480 1
	printf("HMAC transmitted multicasts:\t\t\t[ %d ]\n",
d482 1
a482 1
	printf("HMAC transmitted broadcasts:\t\t\t[ %d ]\n",
d484 1
a484 1
	printf("HMAC transmitted unicasts:\t\t\t[ %d ]\n",
d486 1
a486 1
	printf("HMAC transmissions failed:\t\t\t[ %d ]\n",
d488 1
a488 1
	printf("HMAC received multicasts:\t\t\t[ %d ]\n",
d490 1
a490 1
	printf("HMAC received broadcasts:\t\t\t[ %d ]\n",
d492 1
a492 1
	printf("HMAC received unicasts:\t\t\t\t[ %d ]\n",
d494 1
a494 1
	printf("HMAC receive discards:\t\t\t\t[ %d ]\n",
d496 1
a496 1
	printf("HMAC transmits accepted:\t\t\t[ %d ]\n",
d498 1
a498 1
	printf("SSID mismatches:\t\t\t\t[ %d ]\n",
d500 1
a500 1
	printf("Access point mismatches:\t\t\t[ %d ]\n",
d502 1
a502 1
	printf("Speed mismatches:\t\t\t\t[ %d ]\n",
d504 1
a504 1
	printf("Authentication rejects:\t\t\t\t[ %d ]\n",
d506 1
a506 1
	printf("Authentication timeouts:\t\t\t[ %d ]\n",
d508 1
a508 1
	printf("Association rejects:\t\t\t\t[ %d ]\n",
d510 1
a510 1
	printf("Association timeouts:\t\t\t\t[ %d ]\n",
d512 1
a512 1
	printf("Management frames received:\t\t\t[ %d ]\n",
d514 1
a514 1
	printf("Management frames transmitted:\t\t\t[ %d ]\n",
d516 1
a516 1
	printf("Refresh frames received:\t\t\t[ %d ]\n",
d518 1
a518 1
	printf("Refresh frames transmitted:\t\t\t[ %d ]\n",
d520 1
a520 1
	printf("Poll frames received:\t\t\t\t[ %d ]\n",
d522 1
a522 1
	printf("Poll frames transmitted:\t\t\t[ %d ]\n",
d524 1
a524 1
	printf("Host requested sync losses:\t\t\t[ %d ]\n",
d526 1
a526 1
	printf("Host transmitted bytes:\t\t\t\t[ %d ]\n",
d528 1
a528 1
	printf("Host received bytes:\t\t\t\t[ %d ]\n",
d530 1
a530 1
	printf("Uptime in microseconds:\t\t\t\t[ %d ]\n",
d532 1
a532 1
	printf("Uptime in seconds:\t\t\t\t[ %d ]\n",
d534 1
a534 1
	printf("Sync lost due to better AP:\t\t\t[ %d ]\n",
d848 1
a848 1
			errx(1, "bad diversity setting: %d", diversity);
@


1.21
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.20 2002/06/06 17:25:16 mickey Exp $	*/
d140 1
a140 1
getsock()
d147 1
a147 2
an_getval(areq)
	struct an_req		*areq;
a150 1

d158 1
a158 2
an_setval(areq)
	struct an_req		*areq;
d169 1
a169 3
an_printstr(str, len)
	char			*str;
	int			len;
d184 1
a184 3
an_printwords(w, len)
	u_int16_t		*w;
	int			len;
d197 1
a197 3
an_printspeeds(w, len)
	u_int8_t		*w;
	int			len;
d210 1
a210 3
an_printhex(ptr, len)
	char			*ptr;
	int			len;
d226 1
a226 1
an_dumpstatus()
d291 1
a291 1
an_dumpcaps()
d373 1
a373 1
an_dumpstats()
d541 1
a541 1
an_dumpap()
d567 1
a567 1
an_dumpssid()
d587 1
a587 1
an_dumpconfig()
d674 1
a674 2
	if (cfg->an_authtype & AN_AUTHTYPE_PRIVACY_IN_USE)
	{
d679 1
a679 2
	}
	else
a778 1

d780 1
a780 1
usage()
d797 1
a797 3
an_setconfig(act, arg)
	int			act;
	void			*arg;
d929 1
a929 2
an_setspeed(arg)
	void			*arg;
d975 1
a975 3
an_setap(act, arg)
	int			act;
	void			*arg;
d1019 1
a1019 3
an_setssid(act, arg)
	int			act;
	void			*arg;
d1057 1
a1057 1
an_zerocache()
d1071 1
a1071 1
an_readcache()
d1074 2
a1075 2
	int 			*an_sigitems;
	struct an_sigcache 	*sc;
d1077 1
a1077 1
	int 			i;
d1093 6
a1098 10
		  		    	sc->macsrc[0]&0xff,
		  		    	sc->macsrc[1]&0xff,
		   		    	sc->macsrc[2]&0xff,
		   			sc->macsrc[3]&0xff,
		   			sc->macsrc[4]&0xff,
		   			sc->macsrc[5]&0xff);
        	printf(" %d.%d.%d.%d,",((sc->ipsrc >> 0) & 0xff),
				        ((sc->ipsrc >> 8) & 0xff),
				        ((sc->ipsrc >> 16) & 0xff),
				        ((sc->ipsrc >> 24) & 0xff));
d1108 1
a1108 2
an_hex2int(c)
	char			c;
d1121 1
a1121 3
an_str2key(s, k)
	char			*s;
	struct an_ltv_key	*k;
d1146 1
a1146 3
an_setkeys(key, keytype)
	char *key;
	int keytype;
d1182 1
a1182 1
an_readkeyinfo()
d1225 1
a1225 2
an_enable_tx_key(arg)
	char			*arg;
d1255 1
a1255 3
main(argc, argv)
	int argc;
	char *argv[];
a1418 1

@


1.20
log
@print normalized signal strength; from Gabriel Kihlman <gk@@univits.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.19 2002/02/16 21:27:32 millert Exp $	*/
d1106 1
a1106 1
	an_sigitems = (int *) &areq.an_val; 
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.18 2001/09/29 21:57:15 mickey Exp $	*/
d268 1
@


1.18
log
@alright, do not print quality and noise for cache; pr#2063
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.17 2001/06/04 14:59:46 mickey Exp $	*/
d65 17
a81 17
void an_getval		__P((struct an_req *));
void an_setval		__P((struct an_req *));
void an_printwords	__P((u_int16_t *, int));
void an_printspeeds	__P((u_int8_t*, int));
void an_printhex	__P((char *, int));
void an_printstr	__P((char *, int));
void an_dumpstatus	__P((void));
void an_dumpstats	__P((void));
void an_dumpconfig	__P((void));
void an_dumpcaps	__P((void));
void an_dumpssid	__P((void));
void an_dumpap		__P((void));
void an_setconfig	__P((int, void *));
void an_setssid		__P((int, void *));
void an_setap		__P((int, void *));
void an_setspeed	__P((void *));
void an_readkeyinfo	__P((void));
d83 2
a84 2
void an_zerocache	__P((void));
void an_readcache	__P((void));
d86 3
a88 3
void getsock		__P((void));
static void usage	__P((void));
int main		__P((int, char **));
@


1.17
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.16 2001/05/02 22:31:09 ericj Exp $	*/
d1123 1
a1123 4
		printf(" sig: %d, noise: %d, qual: %d\n",
		   			sc->signal,
		   			sc->noise,
		   			sc->quality);
@


1.16
log
@T doesnt take an arg
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.15 2001/04/30 15:03:01 ericj Exp $	*/
d1479 2
a1480 1
	exit(0);
@


1.15
log
@
Assure that we always close the socket, and that the default behavior
is always chosen. Cleanup the documentation and add a security section
about WEP taken from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.14 2001/04/16 07:51:01 ericj Exp $	*/
d131 1
a131 1
#define OPTIONS "a:b:c:d:e:f:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NQST:W:Z"
d133 1
a133 1
#define OPTIONS "a:b:c:d:e:f:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NST:W:"
@


1.14
log
@
check for 'i' before the getopt. (idea from freebsd)
this allows us to call the functions directly from the switch, which
lets us now put all options on ONE command line, instead
of separating them out into several command's.

ok tholo@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.13 2001/04/16 05:10:07 ericj Exp $	*/
d3 2
a122 3
#define ACT_DUMPCACHE 31
#define ACT_ZEROCACHE 32

d129 2
d796 1
a796 1
	    "usage: ancontrol interface [-A] [-N] [-S] [-I] [-T] [-C] [-t 0|1|2|3|4]\n"
d1310 1
a1310 1
	opterr = optreset =1;
d1367 1
d1386 1
d1394 3
d1424 1
a1473 2

		exit(0);
@


1.13
log
@
much more cleanup.
- Only create the socket for ioctl()'s once.
- get rid of gratuitous argument passing
- treat an_dump* function different than the regular options
- fix the -T option, it doesnt take an arguement.

deraadt@@, tholo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.12 2001/04/16 00:39:39 tholo Exp $	*/
d78 2
a79 2
void an_setspeed	__P((int, void *));
void an_readkeyinfo	__P(());
d81 2
a82 2
void an_zerocache	__P(());
void an_readcache	__P(());
d130 1
a130 1
#define OPTIONS "a:b:c:d:e:f:i:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NQST:W:Z"
d132 1
a132 1
#define OPTIONS "a:b:c:d:e:f:i:j:k:l:m:n:o:p:r:s:t:v:w:ACIK:NST:W:"
d943 1
a943 2
an_setspeed(act, arg)
	int			act;
a1291 1
	int act = 0, ifspecified = 0;
a1293 1
	void *arg = NULL;
d1296 17
a1312 7
	if (argc > 1 && argv[1][0] != '-') {
		strlcpy(ifr.ifr_name, argv[1], sizeof(ifr.ifr_name));
		memcpy(&argv[1], &argv[2], argc * sizeof(char *));
		argc--;
		ifspecified = 1;
	} else
		strlcpy(ifr.ifr_name, "an0", sizeof(ifr.ifr_name));
d1326 1
a1326 2
			act = ACT_SET_KEY_TYPE;
			arg = optarg;
d1338 1
a1338 2
			act = ACT_ENABLE_WEP;
			arg = optarg;
d1342 1
a1342 1
			act = ACT_DUMPCACHE;
d1345 1
a1345 1
			act = ACT_ZEROCACHE;
d1352 1
a1352 1
				act = ACT_SET_AP1;
d1355 1
a1355 1
				act = ACT_SET_AP2;
d1358 1
a1358 1
				act = ACT_SET_AP3;
d1361 1
a1361 1
				act = ACT_SET_AP4;
a1365 1
			arg = optarg;
d1368 1
a1368 2
			act = ACT_SET_BEACON_PERIOD;
			arg = optarg;
d1371 1
a1371 2
			act = ACT_SET_FREQ;
			arg = optarg;
d1376 1
a1376 1
				act = ACT_SET_DIVERSITY_RX;
d1379 1
a1379 1
				act = ACT_SET_DIVERSITY_TX;
a1383 1
			arg = optarg;
d1386 1
a1386 2
			act = ACT_SET_KEYS;
			arg = optarg;
d1389 1
a1389 6
			act = ACT_SET_FRAG_THRESH;
			arg = optarg;
			break;
		case 'i':
			if (!ifspecified)
				strlcpy(ifr.ifr_name, optarg, sizeof(ifr.ifr_name));
d1392 1
a1392 2
			act = ACT_SET_NETJOIN;
			arg = optarg;
d1395 1
a1395 2
			act = ACT_SET_KEYS;
			arg = optarg;
d1398 1
a1398 2
			act = ACT_SET_MYNAME;
			arg = optarg;
d1401 1
a1401 2
			act = ACT_SET_MAC;
			arg = optarg;
d1407 1
a1407 1
				act = ACT_SET_SSID1;
d1410 2
a1411 2
				act = ACT_SET_SSID2;
				break;	
d1413 1
a1413 1
				act = ACT_SET_SSID3;	
a1417 1
			arg = optarg;
d1420 1
a1420 2
			act = ACT_SET_OPMODE;
			arg = optarg;
d1423 1
a1423 2
			act = ACT_SET_TXPWR;
			arg = optarg;
d1426 1
a1426 2
			act = ACT_SET_RTS_RETRYLIM;
			arg = optarg;
d1429 1
a1429 2
			act = ACT_SET_RTS_THRESH;
			arg = optarg;
d1432 1
a1432 2
			act = ACT_SET_PWRSAVE;
			arg = optarg;
d1435 1
a1435 2
			act = ACT_SET_TXRATE;
			arg = optarg;
d1441 1
a1441 2
			act = ACT_SET_WAKE_DURATION;
			arg = optarg;
a1447 5
	if (!print_stat && !act)
		usage();

	/* Grab a socket to do our ioctl's */
	getsock();
a1468 34
	}

	switch(act) {
	case ACT_SET_SSID1:
	case ACT_SET_SSID2:
	case ACT_SET_SSID3:
		an_setssid(act, arg);
		break;
	case ACT_SET_AP1:
	case ACT_SET_AP2:
	case ACT_SET_AP3:
	case ACT_SET_AP4:
		an_setap(act, arg);
		break;
	case ACT_SET_TXRATE:
		an_setspeed(act, arg);
		break;
#ifdef ANCACHE
	case ACT_ZEROCACHE:
		an_zerocache();
		break;
	case ACT_DUMPCACHE:
		an_readcache();
		break;
#endif
	case ACT_SET_KEYS:
		an_setkeys(arg, modifier);
		break;
	case ACT_ENABLE_TX_KEY:
		an_enable_tx_key(arg);
		break;
	default:
		an_setconfig(act, arg);
		break;
@


1.12
log
@Actually permit setting the transmit key in WEP mode; from Kurt Miller.
Correctly display number and order of WEP keys; from Kurt Miller.
Fixes part of PR 1754; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.11 2001/04/15 23:19:13 ericj Exp $	*/
a37 1
#include <sys/socket.h>
d63 2
a64 2
void an_getval		__P((char *, struct an_req *));
void an_setval		__P((char *, struct an_req *));
d69 11
a79 11
void an_dumpstatus	__P((char *));
void an_dumpstats	__P((char *));
void an_dumpconfig	__P((char *));
void an_dumpcaps	__P((char *));
void an_dumpssid	__P((char *));
void an_dumpap		__P((char *));
void an_setconfig	__P((char *, int, void *));
void an_setssid		__P((char *, int, void *));
void an_setap		__P((char *, int, void *));
void an_setspeed	__P((char *, int, void *));
void an_readkeyinfo	__P((char *));
d81 2
a82 2
void an_zerocache	__P((char *));
void an_readcache	__P((char *));
d84 1
d88 7
a94 6
#define ACT_DUMPSTATS 1
#define ACT_DUMPCONFIG 2
#define ACT_DUMPSTATUS 3
#define ACT_DUMPCAPS 4
#define ACT_DUMPSSID 5
#define ACT_DUMPAP 6
d135 10
d146 1
a146 2
an_getval(iface, areq)
	char			*iface;
a148 6
	struct ifreq		ifr;
	int			s;

	bzero((char *)&ifr, sizeof(ifr));

	strlcpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name));
a150 4
	s = socket(AF_INET, SOCK_DGRAM, 0);

	if (s == -1)
		err(1, "socket");
a154 2
	close(s);

d159 1
a159 2
an_setval(iface, areq)
	char			*iface;
a161 6
	struct ifreq		ifr;
	int			s;

	bzero((char *)&ifr, sizeof(ifr));

	strlcpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name));
a163 5
	s = socket(AF_INET, SOCK_DGRAM, 0);

	if (s == -1)
		err(1, "socket");

a166 2
	close(s);

d236 1
a236 2
an_dumpstatus(iface)
	char			*iface;
d241 1
d245 1
a245 1
	an_getval(iface, &areq);
d300 1
a300 2
an_dumpcaps(iface)
	char			*iface;
d306 1
d310 1
a310 1
	an_getval(iface, &areq);
d382 1
a382 2
an_dumpstats(iface)
	char			*iface;
d388 1
d392 1
a392 1
	an_getval(iface, &areq);
d550 1
a550 2
an_dumpap(iface)
	char			*iface;
d555 1
d559 1
a559 1
	an_getval(iface, &areq);
d576 1
a576 2
an_dumpssid(iface)
	char			*iface;
d581 1
d585 1
a585 1
	an_getval(iface, &areq);
d596 1
a596 2
an_dumpconfig(iface)
	char			*iface;
d602 1
d606 1
a606 1
	an_getval(iface, &areq);
d785 1
a785 1
	an_readkeyinfo(iface);
d809 1
a809 2
an_setconfig(iface, act, arg)
	char			*iface;
d821 2
d825 1
a825 1
	an_getval(iface, &areq);
d830 1
a830 1
	an_getval(iface, &areq_caps);
d939 1
a939 2
	an_setval(iface, &areq);
	exit(0);
d943 1
a943 2
an_setspeed(iface, act, arg)
	char			*iface;
d951 1
d955 1
a955 1
	an_getval(iface, &areq);
d987 1
a987 2
	an_setval(iface, &areq);
	exit(0);
d991 1
a991 2
an_setap(iface, act, arg)
	char			*iface;
d999 1
d1003 1
a1003 1
	an_getval(iface, &areq);
d1033 1
a1033 2
	an_setval(iface, &areq);
	exit(0);
d1037 1
a1037 2
an_setssid(iface, act, arg)
	char			*iface;
d1044 1
d1048 1
a1048 1
	an_getval(iface, &areq);
d1072 1
a1072 2
	an_setval(iface, &areq);
	exit(0);
d1077 1
a1077 2
an_zerocache(iface)
	char			*iface;
d1085 1
a1085 1
	an_getval(iface, &areq);
d1091 1
a1091 2
an_readcache(iface)
	char			*iface;
a1098 3
	if (iface == NULL)
		errx(1, "must specify interface name");

d1103 1
a1103 1
	an_getval(iface, &areq);
d1132 1
a1132 1
#endif
d1176 3
a1178 4
an_setkeys(iface, key, keytype)
	char			*iface;
	char			*key;
	int			keytype;
d1186 2
a1187 4
	if (strlen(key) > 28) {
		err(1, "encryption key must be no "
		    "more than 18 characters long");
	}
d1208 1
a1208 1
	an_setval(iface, &areq);
d1214 1
a1214 2
an_readkeyinfo(iface)
	char			*iface;
d1227 1
a1227 1
		an_getval(iface, &areq);
d1250 1
a1250 1
	an_getval(iface, &areq);
d1257 1
a1257 2
an_enable_tx_key(iface, arg)
	char			*iface;
d1282 1
a1282 1
	an_setval(iface, &areq);
d1289 2
a1290 2
	int			argc;
	char			*argv[];
d1292 5
a1296 5
	int			ch;
	int			act = 0, ifspecified = 0;
	char			*iface = "an0";
	int			modifier = 0;
	void			*arg = NULL;
d1298 1
d1300 1
a1300 1
		iface = argv[1];
d1304 2
a1305 1
	}
d1310 1
a1310 1
			act = ACT_DUMPAP;
d1313 1
a1313 1
			act = ACT_DUMPCONFIG;
d1316 1
a1316 1
			act = ACT_DUMPCAPS;
d1323 1
a1323 1
			act = ACT_DUMPSSID;
d1326 1
a1326 1
			act = ACT_DUMPSTATUS;
d1329 1
a1329 1
			act = ACT_DUMPSTATS;
d1394 1
a1394 1
				iface = optarg;
d1465 1
a1465 1
	if (iface == NULL || !act)
d1468 25
a1493 18
	case ACT_DUMPSTATUS:
		an_dumpstatus(iface);
		break;
	case ACT_DUMPCAPS:
		an_dumpcaps(iface);
		break;
	case ACT_DUMPSTATS:
		an_dumpstats(iface);
		break;
	case ACT_DUMPCONFIG:
		an_dumpconfig(iface);
		break;
	case ACT_DUMPSSID:
		an_dumpssid(iface);
		break;
	case ACT_DUMPAP:
		an_dumpap(iface);
		break;
d1497 1
a1497 1
		an_setssid(iface, act, arg);
d1503 1
a1503 1
		an_setap(iface, act, arg);
d1506 1
a1506 1
		an_setspeed(iface, act, arg);
d1510 1
a1510 1
		an_zerocache(iface);
d1513 1
a1513 1
		an_readcache(iface);
d1517 1
a1517 1
		an_setkeys(iface, arg, modifier);
d1520 1
a1520 1
		an_enable_tx_key(iface, arg);
d1523 1
a1523 1
		an_setconfig(iface, act, arg);
d1527 3
@


1.11
log
@
start some cleanup to ancontrol
- alphabetize the argument list
- get rid of unused vars

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.10 2001/02/27 08:38:36 tholo Exp $	*/
d1256 1
a1256 2
		switch (k->klen) {
		case 0:
d1258 15
a1272 10
			break;
		case 5:
			printf("\tKey %d is set  40 bits\n", i);
			break;
		case 13:
			printf("\tKey %d is set 128 bits\n", i);
			break;
		default:
			printf("\tKey %d has an unknown size %d\n", i, k->klen);
			break;
a1273 1

d1409 4
@


1.10
log
@Match reality
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.9 2001/02/26 06:19:34 tholo Exp $	*/
d85 1
a85 1
void usage		__P((char *));
d128 6
d807 2
a808 3
void
usage(p)
	char			*p;
d1181 1
a1181 1
	if (s[0] = '0' && (s[1] == 'x' || s[1] == 'X')) {
a1322 1
	char			*p = argv[0];
d1331 1
a1331 2
	while ((ch = getopt(argc, argv,
	    "i:ANISCTt:a:e:o:s:n:v:d:f:j:b:c:r:p:w:m:l:k:K:W:QZ")) != -1) {
d1333 2
a1334 6
		case 'Z':
#ifdef ANCACHE
			act = ACT_ZEROCACHE;
#else
			errx(1, "ANCACHE not available");
#endif
d1336 2
a1337 6
		case 'Q':
#ifdef ANCACHE
			act = ACT_DUMPCACHE;
#else
			errx(1, "ANCACHE not available");
#endif
d1339 2
a1340 3
		case 'i':
			if (!ifspecified)
				iface = optarg;
d1342 3
a1344 2
		case 'A':
			act = ACT_DUMPAP;
a1351 3
		case 'I':
			act = ACT_DUMPCAPS;
			break;
d1355 2
a1356 5
		case 'C':
			act = ACT_DUMPCONFIG;
			break;
		case 't':
			act = ACT_SET_TXRATE;
d1359 3
a1361 3
		case 's':
			act = ACT_SET_PWRSAVE;
			arg = optarg;
d1363 2
a1364 6
		case 'p':
			act = ACT_SET_TXPWR;
			arg = optarg;
			break;
		case 'v':
			modifier = atoi(optarg);
d1366 1
d1368 1
a1368 1
			switch(modifier) {
d1383 1
a1383 5
				errx(1, "bad modifier %d: there "
				    "are only 4 access point settings",
				    modifier);
				usage(p);
				break;
d1391 4
d1396 1
a1396 1
			switch(modifier) {
d1404 1
a1404 2
				errx(1, "must specift RX or TX diversity");
				break;
d1408 8
d1420 4
d1433 1
a1433 1
			switch(modifier) {
d1440 1
a1440 1
				break;
d1442 1
a1442 1
				act = ACT_SET_SSID3;
d1445 1
a1445 4
				errx(1, "bad modifier %d: there"
				    "are only 3 SSID settings", modifier);
				usage(p);
				break;
d1453 2
a1454 6
		case 'c':
			act = ACT_SET_FREQ;
			arg = optarg;
			break;
		case 'f':
			act = ACT_SET_FRAG_THRESH;
d1465 2
a1466 2
		case 'w':
			act = ACT_SET_WAKE_DURATION;
d1469 2
a1470 2
		case 'W':
			act = ACT_ENABLE_WEP;
d1473 2
a1474 3
		case 'K':
			act = ACT_SET_KEY_TYPE;
			arg = optarg;
d1476 2
a1477 2
		case 'k':
			act = ACT_SET_KEYS;
d1481 1
a1481 1
			usage(p);
d1486 1
a1486 1
		usage(p);
a1541 1

@


1.9
log
@Allow configuration of WEP.  From FreeBSD; ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.8 2000/10/13 18:58:09 chris Exp $	*/
a709 2
	if ((cfg->an_authtype & AN_AUTHTYPE_MASK) == AN_AUTHTYPE_EXCLUDE_UNENCRYPTED)
		printf("exclude unencrypted");
@


1.8
log
@The -i flags was being ignored, this breaks backwards compatibility

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.7 2000/08/17 21:57:38 deraadt Exp $	*/
d80 1
d123 5
d692 11
d704 3
a706 3
	if (cfg->an_authtype == AN_AUTHTYPE_NONE)
		printf("no auth");
	if (cfg->an_authtype == AN_AUTHTYPE_OPEN)
d708 1
a708 1
	if (cfg->an_authtype == AN_AUTHTYPE_SHAREDKEY)
d710 1
a710 1
	if (cfg->an_authtype == AN_AUTHTYPE_EXCLUDE_UNENCRYPTED)
d797 1
d809 5
a813 4
	    "       [-s 0|1|2|3] [-a AP] [-v 1|2|3|4] [-b beacon period] [-d 0|1|2|3]\n"
	    "       [-v 0|1] [-j netjoin timeout] [-l station name] [-m macaddress]\n"
	    "       [-n SSID] [-v 1|2|3] [-o 0|1] [-p tx power] [-c channel number]\n"
	    "       [-f fragmentation threshold] [-r RTS threshold]\n");
d926 20
d1155 154
d1330 1
a1330 1
	    "i:ANISCTt:a:o:s:n:v:d:f:j:b:c:r:p:w:m:l:QZ")) != -1) {
d1481 12
d1542 6
@


1.7
log
@make interface optional, and provide a good default
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.6 2000/06/22 22:56:33 todd Exp $	*/
d1123 1
a1123 1
	int			act = 0;
d1133 1
d1154 1
a1154 1
			if (iface == NULL)
@


1.6
log
@fix a typo by wpaul; using ipv6 tunneled to usenix (thanks itojun!)
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.5 2000/06/20 17:41:50 aaron Exp $	*/
d1124 1
a1124 1
	char			*iface = NULL;
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.4 2000/06/18 22:27:41 aaron Exp $	*/
d1136 1
a1136 1
	    "i:ANISCTt:a:o:s:n:v:d:j:b:c:r:p:w:m:l:QZ")) != -1) {
@


1.4
log
@Fix more buffer overflows... that's 5 in this one program (so far)
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.3 2000/06/18 20:44:33 aaron Exp $	*/
d421 1
a421 1
	printf("Retries exchausted:\t\t\t\t[ %d ]\n",
d455 1
a455 1
	printf("Transmits defered due to protocol:\t\t[ %d ]\n",
d457 1
a457 1
	printf("Transmits defered due to energy detect:\t\t[ %d ]\n",
@


1.3
log
@strcpy() -> strlcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.2 2000/05/20 17:28:41 deraadt Exp $	*/
d1027 1
a1027 1
	switch(act) {
d1030 2
a1031 3
		bcopy((char *)arg, (char *)&ssid->an_ssid1,
		    strlen((char *)arg));
		ssid->an_ssid1_len = strlen((char *)arg);
d1035 2
a1036 3
		bcopy((char *)arg, (char *)&ssid->an_ssid2,
		    strlen((char *)arg));
		ssid->an_ssid2_len = strlen((char *)arg);
d1040 2
a1041 3
		bcopy((char *)arg, (char *)&ssid->an_ssid3,
		    strlen((char *)arg));
		ssid->an_ssid3_len = strlen((char *)arg);
@


1.2
log
@make this more like our wicontrol(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: ancontrol.c,v 1.1 2000/04/03 01:08:09 mickey Exp $	*/
d132 1
a132 1
	strcpy(ifr.ifr_name, iface);
d158 1
a158 1
	strcpy(ifr.ifr_name, iface);
@


1.1
log
@ancontrol(8) to manipulate an(4)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d789 6
a794 20
	fprintf(stderr, "usage:  %s -i iface -A (show specified APs)\n", p);
	fprintf(stderr, "\t%s -i iface -N (show specified SSIDss)\n", p);
	fprintf(stderr, "\t%s -i iface -S (show NIC status)\n", p);
	fprintf(stderr, "\t%s -i iface -I (show NIC capabilities)\n", p);
	fprintf(stderr, "\t%s -i iface -T (show stats counters)\n", p);
	fprintf(stderr, "\t%s -i iface -C (show current config)\n", p);
	fprintf(stderr, "\t%s -i iface -t 0|1|2|3|4 (set TX speed)\n", p);
	fprintf(stderr, "\t%s -i iface -s 0|1|2|3 (set power same mode)\n", p);
	fprintf(stderr, "\t%s -i iface [-v 1|2|3|4] -a AP (specify AP)\n", p);
	fprintf(stderr, "\t%s -i iface -b val (set beacon period)\n", p);
	fprintf(stderr, "\t%s -i iface [-v 0|1] -d val (set diversity)\n", p);
	fprintf(stderr, "\t%s -i iface -j val (set netjoin timeout)\n", p);
	fprintf(stderr, "\t%s -i iface -l val (set station name)\n", p);
	fprintf(stderr, "\t%s -i iface -m val (set MAC address)\n", p);
	fprintf(stderr, "\t%s -i iface [-v 1|2|3] -n SSID "
	    "(specify SSID)\n", p);
	fprintf(stderr, "\t%s -i iface -o 0|1 (set operating mode)\n", p);
	fprintf(stderr, "\t%s -i iface -c val (set ad-hoc channel)\n", p);
	fprintf(stderr, "\t%s -i iface -f val (set frag threshold)\n", p);
	fprintf(stderr, "\t%s -i iface -r val (set RTS threshold)\n", p);
d796 2
a797 2
	fprintf(stderr, "\t%s -i iface -Q print signal quality cache\n", p);
	fprintf(stderr, "\t%s -i iface -Z zero out signal cache\n", p);
a798 4

	fprintf(stderr, "\t%s -h (display this message)\n", p);


d1132 6
d1139 1
a1139 1
	    "i:ANISCTht:a:o:s:n:v:d:j:b:c:r:p:w:m:l:QZ")) != -1) {
d1156 2
a1157 1
			iface = optarg;
a1289 1
		case 'h':
@

