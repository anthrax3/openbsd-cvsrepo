head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.18
	OPENBSD_5_0:1.25.0.16
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.14
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.12
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.8
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.06.07.01.29.38;	author tedu;	state Exp;
branches;
next	1.29;
commitid	aJp7bbwjTwgUYbAT;

1.29
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.28;
commitid	HIbf8HnT4wFtIrOp;

1.28
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.03.20.46.44;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.24.15.39.54;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.18.00.30.32;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.28.01.06.18;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.13.02.11.28;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.23.02.50.20;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.13.19.16.09;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.13.02.33.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.11.22.02.06;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.11.14.59.01;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.09.02.14.32;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.14.19.39.59;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.23.23.10.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.06.22.03.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.26.15.41.12;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.06.22.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.13.05.00.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.20.21.47.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.07.18.26.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.21.41.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.22.20.25.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.12.10.05.02.02;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.08.26.13.38.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.06.24.02.03.00;	author dgregor;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.41.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.12.11.21.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@per trending style, add continue to emtpy loop bodies.
ok mglocker
@
text
@/*	$OpenBSD: scsi.c,v 1.29 2014/11/20 15:22:39 tedu Exp $	*/
/*	$FreeBSD: scsi.c,v 1.11 1996/04/06 11:00:28 joerg Exp $	*/

/*
 * Written By Julian ELischer
 * Copyright julian Elischer 1993.
 * Permission is granted to use or redistribute this file in any way as long
 * as this notice remains. Julian Elischer does not guarantee that this file
 * is totally correct for any given task and users of this file must
 * accept responsibility for any damage that occurs from the application of this
 * file.
 *
 * (julian@@tfs.com julian@@dialix.oz.au)
 *
 * User SCSI hooks added by Peter Dufault:
 *
 * Copyright (c) 1994 HD Associates
 * (contact: dufault@@hda.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of HD Associates
 *    may not be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY HD ASSOCIATES ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL HD ASSOCIATES BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/scsiio.h>
#include <ctype.h>
#include <signal.h>
#include <err.h>
#include <paths.h>

#include "libscsi.h"

int	fd;
int	debuglevel;
int	debugflag;
int commandflag;
int verbose = 0;

int modeflag;
int editflag;
int modepage = 0; /* Read this mode page */
int pagectl = 0;  /* Mode sense page control */
int seconds = 2;

void	procargs(int *argc_p, char ***argv_p);
int	iget(void *hook, char *name);
char	*cget(void *hook, char *name);
void	arg_put(void *hook, int letter, void *arg, int count, char *name);
void	mode_sense(int fd, u_char *data, int len, int pc, int page);
void	mode_select(int fd, u_char *data, int len, int perm);
int	editit(const char *pathname);

static void
usage(void)
{
	fprintf(stderr,
"Usage:\n"
"\n"
"  scsi -f device -d debug_level                    # To set debug level\n"
"  scsi -f device -m page [-P pc]                   # To read mode pages\n"
"  scsi -f device [-v] [-s seconds] -c cmd_fmt [arg0 ... argn] # A command...\n"
"                 -o count out_fmt [arg0 ... argn]  #   EITHER (data out)\n"
"                 -i count in_fmt                   #   OR     (data in)\n"
"\n"
"\"out_fmt\" can be \"-\" to read output data from stdin;\n"
"\"in_fmt\" can be \"-\" to write input data to stdout;\n"
"\n"
"If debugging is not compiled in the kernel, \"-d\" will have no effect\n"

);

	exit (1);
}

void
procargs(int *argc_p, char ***argv_p)
{
	int argc = *argc_p;
	char **argv = *argv_p;
	int fflag, ch;

	fflag = 0;
	commandflag = 0;
	debugflag = 0;
	while ((ch = getopt(argc, argv, "cef:d:m:P:s:v")) != -1) {
		switch (ch) {
		case 'c':
			commandflag = 1;
			break;
		case 'e':
			editflag = 1;
			break;
		case 'f':
			if ((fd = scsi_open(optarg, O_RDWR)) < 0)
				err(1, "unable to open device %s", optarg);
			fflag = 1;
			break;
		case 'd':
			debuglevel = strtol(optarg, 0, 0);
			debugflag = 1;
			break;
		case 'm':
			modeflag = 1;
			modepage = strtol(optarg, 0, 0);
			break;
		case 'P':
			pagectl = strtol(optarg, 0, 0);
			break;
		case 's':
			seconds = strtol(optarg, 0, 0);
			break;
		case 'v':
			verbose = 1;
			break;
		case '?':
		default:
			usage();
		}
	}
	*argc_p = argc - optind;
	*argv_p = argv + optind;

	if (!fflag) usage();
}

/* get_hook: Structure for evaluating args in a callback.
 */
struct get_hook
{
	int argc;
	char **argv;
	int got;
};

/* iget: Integer argument callback
 */
int
iget(void *hook, char *name)
{
	struct get_hook *h = (struct get_hook *)hook;
	int arg;

	if (h->got >= h->argc)
	{
		fprintf(stderr, "Expecting an integer argument.\n");
		usage();
	}
	arg = strtol(h->argv[h->got], 0, 0);
	h->got++;

	if (verbose && name && *name)
		printf("%s: %d\n", name, arg);

	return arg;
}

/* cget: char * argument callback
 */
char *
cget(void *hook, char *name)
{
	struct get_hook *h = (struct get_hook *)hook;
	char *arg;

	if (h->got >= h->argc)
	{
		fprintf(stderr, "Expecting a character pointer argument.\n");
		usage();
	}
	arg = h->argv[h->got];
	h->got++;

	if (verbose && name)
		printf("cget: %s: %s", name, arg);

	return arg;
}

/* arg_put: "put argument" callback
 */
void arg_put(void *hook, int letter, void *arg, int count, char *name)
{
	if (verbose && name && *name)
		printf("%s:  ", name);

	switch(letter)
	{
		case 'i':
		case 'b':
		printf("%ld ", (long)arg);
		break;

		case 'c':
		case 'z':
		{
			char *p = malloc(count + 1);
			if (p == NULL)
				err(1, NULL);

			p[count] = 0;
			strncpy(p, (char *)arg, count);
			if (letter == 'z')
			{
				int i;
				for (i = count - 1; i >= 0; i--)
					if (p[i] == ' ')
						p[i] = 0;
					else
						break;
			}
			printf("%s ", p);
			free(p);
		}

		break;

		default:
		printf("Unknown format letter: '%c'\n", letter);
	}
	if (verbose)
		putchar('\n');
}

/* data_phase: SCSI bus data phase: DATA IN, DATA OUT, or no data transfer.
 */
enum data_phase {none = 0, in, out};

/* do_cmd: Send a command to a SCSI device
 */
static void
do_cmd(int fd, char *fmt, int argc, char **argv)
{
	struct get_hook h;
	scsireq_t *scsireq = scsireq_new();
	enum data_phase data_phase;
	int count, amount;
	char *data_fmt, *bp;

	h.argc = argc;
	h.argv = argv;
	h.got = 0;

	scsireq_reset(scsireq);

	scsireq_build_visit(scsireq, 0, 0, 0, fmt, iget, (void *)&h);

	/* Three choices here:
	 * 1. We've used up all the args and have no data phase.
	 * 2. We have input data ("-i")
	 * 3. We have output data ("-o")
	 */

	if (h.got >= h.argc)
	{
		data_phase = none;
		count = scsireq->datalen = 0;
	}
	else
	{
		char *flag = cget(&h, 0);

		if (strcmp(flag, "-o") == 0)
		{
			data_phase = out;
			scsireq->flags = SCCMD_WRITE;
		}
		else if (strcmp(flag, "-i") == 0)
		{
			data_phase = in;
			scsireq->flags = SCCMD_READ;
		}
		else
		{
			fprintf(stderr,
			"Need either \"-i\" or \"-o\" for data phase; not \"%s\".\n", flag);
			usage();
		}

		count = scsireq->datalen = iget(&h, 0);
		if (count) {
			data_fmt = cget(&h, 0);

			scsireq->databuf = malloc(count);
			if (scsireq->databuf == NULL)
				err(1, NULL);

			if (data_phase == out) {
				if (strcmp(data_fmt, "-") == 0)	{
					bp = (char *)scsireq->databuf;
					while (count > 0 &&
					    (amount = read(STDIN_FILENO,
					    bp, count)) > 0) {
						count -= amount;
						bp += amount;
					}
					if (amount == -1)
						err(1, "read");
					else if (amount == 0) {
						/* early EOF */
						fprintf(stderr,
							"Warning: only read %lu bytes out of %lu.\n",
							scsireq->datalen - (u_long)count,
							scsireq->datalen);
						scsireq->datalen -= (u_long)count;
					}
				}
				else
				{
					bzero(scsireq->databuf, count);
					scsireq_encode_visit(scsireq, data_fmt, iget, (void *)&h);
				}
			}
		}
	}


	scsireq->timeout = seconds * 1000;

	if (scsireq_enter(fd, scsireq) == -1)
	{
		scsi_debug(stderr, -1, scsireq);
		exit(1);
	}

	if (SCSIREQ_ERROR(scsireq))
		scsi_debug(stderr, 0, scsireq);

	if (count && data_phase == in)
	{
		if (strcmp(data_fmt, "-") == 0)	/* stdout */
		{
			bp = (char *)scsireq->databuf;
			while (count > 0 && (amount = write(STDOUT_FILENO, bp, count)) > 0)
			{
				count -= amount;
				bp += amount;
			}
			if (amount < 0)
				err(1, "write");
			else if (amount == 0)
				fprintf(stderr, "Warning: wrote only %lu bytes out of %lu.\n",
					scsireq->datalen - count,
					scsireq->datalen);

		}
		else
		{
			scsireq_decode_visit(scsireq, data_fmt, arg_put, 0);
			putchar('\n');
		}
	}
}

void mode_sense(int fd, u_char *data, int len, int pc, int page)
{
	scsireq_t *scsireq;

	bzero(data, len);

	scsireq = scsireq_new();

	if (scsireq_enter(fd, scsireq_build(scsireq,
	 len, data, SCCMD_READ,
	 "1A 0 v:2 {Page Control} v:6 {Page Code} 0 v:i1 {Allocation Length} 0",
	 pc, page, len)) == -1)	/* Mode sense */
	{
		scsi_debug(stderr, -1, scsireq);
		exit(1);
	}

	if (SCSIREQ_ERROR(scsireq))
	{
		scsi_debug(stderr, 0, scsireq);
		exit(1);
	}

	free(scsireq);
}

void mode_select(int fd, u_char *data, int len, int perm)
{
	scsireq_t *scsireq;

	scsireq = scsireq_new();

	if (scsireq_enter(fd, scsireq_build(scsireq,
	 len, data, SCCMD_WRITE,
	 "15 0:7 v:1 {SP} 0 0 v:i1 {Allocation Length} 0", perm, len)) == -1)	/* Mode select */
	{
		scsi_debug(stderr, -1, scsireq);
		exit(1);
	}

	if (SCSIREQ_ERROR(scsireq))
	{
		scsi_debug(stderr, 0, scsireq);
		exit(1);
	}

	free(scsireq);
}


#define START_ENTRY '{'
#define END_ENTRY '}'

static void
skipwhite(FILE *f)
{
	int c;

skip_again:

	while (isspace(c = getc(f)))
		continue;

	if (c == '#') {
		while ((c = getc(f)) != '\n' && c != EOF)
			continue;
		goto skip_again;
	}

	ungetc(c, f);
}

/* mode_lookup: Lookup a format description for a given page.
 */
char *mode_db = "/usr/share/misc/scsi_modes";
static char *mode_lookup(int page)
{
	char *new_db;
	FILE *modes;
	int match, next, found, c;
	static char fmt[1024];	/* XXX This should be with strealloc */
	int page_desc;
	new_db = getenv("SCSI_MODES");

	if (new_db)
		mode_db = new_db;

	modes = fopen(mode_db, "r");
	if (modes == NULL)
		return 0;

	next = 0;
	found = 0;

	while (!found) {

		skipwhite(modes);

		if (fscanf(modes, "%i", &page_desc) != 1)
			break;

		if (page_desc == page)
			found = 1;

		skipwhite(modes);
		if (getc(modes) != START_ENTRY) {
			errx(1, "Expected %c", START_ENTRY);
		}

		match = 1;
		while (match != 0) {
			c = getc(modes);
			if (c == EOF)
				fprintf(stderr, "Expected %c.\n", END_ENTRY);

			if (c == START_ENTRY) {
				match++;
			}
			if (c == END_ENTRY) {
				match--;
				if (match == 0)
					break;
			}
			if (found && c != '\n') {
				if (next >= sizeof(fmt)) {
					errx(1, "Stupid program: Buffer overflow.\n");
				}

				fmt[next++] = (u_char)c;
			}
		}
	}
	fclose(modes);
	fmt[next] = 0;

	return (found) ? fmt : 0;
}

/* -------- edit: Mode Select Editor ---------
 */
struct editinfo
{
	long can_edit;
	long default_value;
} editinfo[64];	/* XXX Bogus fixed size */

static int editind;
volatile int edit_opened;
static FILE *edit_file;
static char edit_name[L_tmpnam];

static void
edit_rewind(void)
{
	editind = 0;
}

static void
edit_done(void)
{
	int opened;

	sigset_t all, prev;
	sigfillset(&all);

	(void)sigprocmask(SIG_SETMASK, &all, &prev);

	opened = (int)edit_opened;
	edit_opened = 0;

	(void)sigprocmask(SIG_SETMASK, &prev, 0);

	if (opened)
	{
		if (fclose(edit_file))
			perror(edit_name);
		if (unlink(edit_name))
			perror(edit_name);
	}
}

static void
edit_init(void)
{
	int fd;

	edit_rewind();
	strlcpy(edit_name, "/var/tmp/scXXXXXXXX", sizeof edit_name);
	if ((fd = mkstemp(edit_name)) == -1)
		err(1, "mkstemp");
	if ( (edit_file = fdopen(fd, "w+")) == 0)
		err(1, "fdopen");
	edit_opened = 1;

	atexit(edit_done);
}

static void
edit_check(void *hook, int letter, void *arg, int count, char *name)
{
	if (letter != 'i' && letter != 'b') {
		errx(1, "Can't edit format %c.\n", letter);
	}

	if (editind >= sizeof(editinfo) / sizeof(editinfo[0])) {
		errx(1, "edit table overflow");
	}
	editinfo[editind].can_edit = ((long)arg != 0);
	editind++;
}

static void
edit_defaults(void *hook, int letter, void *arg, int count, char *name)
{
	if (letter != 'i' && letter != 'b') {
		errx(1, "Can't edit format %c.\n", letter);
	}

	editinfo[editind].default_value = ((long)arg);
	editind++;
}

static void
edit_report(void *hook, int letter, void *arg, int count, char *name)
{
	if (editinfo[editind].can_edit) {
		if (letter != 'i' && letter != 'b') {
			errx(1, "Can't report format %c.\n", letter);
		}

		fprintf(edit_file, "%s:  %ld\n", name, (long)arg);
	}

	editind++;
}

static int
edit_get(void *hook, char *name)
{
	int arg = editinfo[editind].default_value;

	if (editinfo[editind].can_edit) {
		char line[80];
		size_t len;
		if (fgets(line, sizeof(line), edit_file) == NULL)
			err(1, "fgets");

		len = strlen(line);
		if (len && line[len - 1] == '\n')
			line[len - 1] = '\0';

		if (strncmp(name, line, strlen(name)) != 0) {
			errx(1, "Expected \"%s\" and read \"%s\"\n",
			    name, line);
		}

		arg = strtoul(line + strlen(name) + 2, 0, 0);
	}

	editind++;
	return arg;
}

int
editit(const char *pathname)
{
	char *argp[] = {"sh", "-c", NULL, NULL}, *ed, *p;
	sig_t sighup, sigint, sigquit;
	pid_t pid;
	int st;

	ed = getenv("VISUAL");
	if (ed == NULL || ed[0] == '\0')
		ed = getenv("EDITOR");
	if (ed == NULL || ed[0] == '\0')
		ed = _PATH_VI;
	if (asprintf(&p, "%s %s", ed, pathname) == -1)
		return (-1);
	argp[2] = p;

 top:
	sighup = signal(SIGHUP, SIG_IGN);
	sigint = signal(SIGINT, SIG_IGN);
	sigquit = signal(SIGQUIT, SIG_IGN);
	if ((pid = fork()) == -1) {
		int saved_errno = errno;

		(void)signal(SIGHUP, sighup);
		(void)signal(SIGINT, sigint);
		(void)signal(SIGQUIT, sigquit);
		if (saved_errno == EAGAIN) {
			sleep(1);
			goto top;
		}
		free(p);
		errno = saved_errno;
		return (-1);
	}
	if (pid == 0) {
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}
	free(p);
	for (;;) {
		if (waitpid(pid, &st, 0) == -1) {
			if (errno != EINTR)
				return (-1);
		} else
			break;
	}
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	if (!WIFEXITED(st) || WEXITSTATUS(st) != 0) {
		errno = ECHILD;
		return (-1);
	}
	return (0);
}

static void
mode_edit(int fd, int page, int edit, int argc, char *argv[])
{
	int i;
	u_char data[255];
	u_char *mode_pars;
	struct mode_header
	{
		u_char mdl;	/* Mode data length */
		u_char medium_type;
		u_char dev_spec_par;
		u_char bdl;	/* Block descriptor length */
	};

	struct mode_page_header
	{
		u_char page_code;
		u_char page_length;
	};

	struct mode_header *mh;
	struct mode_page_header *mph;

	char *fmt = mode_lookup(page);
	if (!fmt && verbose) {
		fprintf(stderr,
		"No mode data base entry in \"%s\" for page %d;  binary %s only.\n",
		mode_db, page, (edit ? "edit" : "display"));
	}

	if (edit) {
		if (!fmt) {
			errx(1, "Sorry: can't edit without a format.\n");
		}

		if (pagectl != 0 && pagectl != 3) {
			errx(1,
"It only makes sense to edit page 0 (current) or page 3 (saved values)\n");
		}

		verbose = 1;

		mode_sense(fd, data, sizeof(data), 1, page);

		mh = (struct mode_header *)data;
		mph = (struct mode_page_header *)
		(((char *)mh) + sizeof(*mh) + mh->bdl);

		mode_pars = (char *)mph + sizeof(*mph);

		edit_init();
		scsireq_buff_decode_visit(mode_pars, mh->mdl,
		fmt, edit_check, 0);

		mode_sense(fd, data, sizeof(data), 0, page);

		edit_rewind();
		scsireq_buff_decode_visit(mode_pars, mh->mdl,
		fmt, edit_defaults, 0);

		edit_rewind();
		scsireq_buff_decode_visit(mode_pars, mh->mdl,
		fmt, edit_report, 0);

		fclose(edit_file);
		if (editit(edit_name) == -1 && errno != ECHILD)
			err(1, "edit %s", edit_name);
		if ((edit_file = fopen(edit_name, "r")) == NULL)
			err(1, "open %s", edit_name);

		edit_rewind();
		scsireq_buff_encode_visit(mode_pars, mh->mdl,
		fmt, edit_get, 0);

		/* Eliminate block descriptors:
		 */
		bcopy((char *)mph, ((char *)mh) + sizeof(*mh),
		sizeof(*mph) + mph->page_length);

		mh->bdl = 0;
		mph = (struct mode_page_header *) (((char *)mh) + sizeof(*mh));
		mode_pars = ((char *)mph) + 2;

#if 0
		/* Turn this on to see what you're sending to the
		 * device:
		 */
		edit_rewind();
		scsireq_buff_decode_visit(mode_pars,
		mh->mdl, fmt, arg_put, 0);
#endif

		edit_done();

		/* Make it permanent if pageselect is three.
		 */

		mph->page_code &= ~0xC0;	/* Clear PS and RESERVED */
		mh->mdl = 0;				/* Reserved for mode select */

		mode_select(fd, (char *)mh,
		sizeof(*mh) + mh->bdl + sizeof(*mph) + mph->page_length,
		(pagectl == 3));

		exit(0);
	}

	mode_sense(fd, data, sizeof(data), pagectl, page);

	/* Skip over the block descriptors.
	 */
	mh = (struct mode_header *)data;
	mph = (struct mode_page_header *)(((char *)mh) + sizeof(*mh) + mh->bdl);
	mode_pars = (char *)mph + sizeof(*mph);

	if (!fmt) {
		for (i = 0; i < mh->mdl; i++) {
			printf("%02x%c",mode_pars[i],
			(((i + 1) % 8) == 0) ? '\n' : ' ');
		}
		putc('\n', stdout);
	} else {
			verbose = 1;
			scsireq_buff_decode_visit(mode_pars,
			mh->mdl, fmt, arg_put, 0);
	}
}

int
main(int argc, char **argv)
{
	procargs(&argc,&argv);

	/* XXX This has grown to the point that it should be cleaned up.
	 */
	if (debugflag) {
		if (ioctl(fd,SCIOCDEBUG,&debuglevel) == -1)
			err(1, "SCIOCDEBUG");
	} else if (commandflag) {
		char *fmt;

		if (argc < 1) {
			fprintf(stderr, "Need the command format string.\n");
			usage();
		}


		fmt = argv[0];

		argc -= 1;
		argv += 1;

		do_cmd(fd, fmt, argc, argv);
	} else if (modeflag)
		mode_edit(fd, modepage, editflag, argc, argv);

	exit(0);
}
@


1.29
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.28 2013/11/12 04:59:02 deraadt Exp $	*/
d445 1
a445 1
		;
d449 1
a449 1
			;
@


1.28
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.27 2012/09/03 20:46:44 okan Exp $	*/
d49 1
a55 1
#include <sys/file.h>
@


1.27
log
@- resolve unchecked malloc()'s; prompted by rustyBSD.
- first pass at fixing err() and exit() usage.
- document that scsi(8) returns 0 or >0.

ok krw@@ otto@@ (noting this code is barely worth the effort...)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.26 2012/03/24 15:39:54 jsg Exp $	*/
d81 1
@


1.26
log
@fix some leaks
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.25 2007/10/18 00:30:32 ray Exp $	*/
d124 1
a124 1
				err(errno, "unable to open device %s", optarg);
d226 3
d313 2
d326 1
a326 1
						err(errno, "read");
d351 1
a351 1
		exit(errno);
d368 1
a368 1
				err(errno, "write");
d397 1
a397 1
		exit(errno);
d420 1
a420 1
		exit(errno);
d489 1
a489 2
			fprintf(stderr, "Expected %c.\n", START_ENTRY);
			exit(1);
d508 1
a508 3
					fprintf(stderr,
					    "Stupid program: Buffer overflow.\n");
					exit(ENOMEM);
d572 1
a572 1
		err(errno, "mkstemp failed");
d574 1
a574 1
		err(errno, "fdopen failed");
d584 1
a584 2
		fprintf(stderr, "Can't edit format %c.\n", letter);
		exit(1);
d588 1
a588 2
		fprintf(stderr, "edit table overflow\n");
		exit(ENOMEM);
d598 1
a598 2
		fprintf(stderr, "Can't edit format %c.\n", letter);
		exit(1);
d610 1
a610 2
			fprintf(stderr, "Can't report format %c.\n", letter);
			exit(1);
d628 1
a628 1
			err(errno, "fgets");
d635 1
a635 1
			fprintf(stderr, "Expected \"%s\" and read \"%s\"\n",
a636 1
			exit(1);
d735 1
a735 2
			fprintf(stderr, "Sorry: can't edit without a format.\n");
			exit(1);
d739 1
a739 1
			fprintf(stderr,
a740 1
			exit(1);
d840 1
a840 1
			err(errno, "SCIODEBUG");
@


1.25
log
@SIGCHLD is not an errno value.

Spotted by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.24 2007/04/28 01:06:18 ray Exp $	*/
d238 1
@


1.24
log
@Copy sendbug's editit().

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.23 2006/10/13 02:11:28 cloder Exp $	*/
d772 1
a772 1
		if (editit(edit_name) == -1 && errno != SIGCHLD)
@


1.23
log
@Fix another potentially unsafe instance of foo[strlen(foo) - 1] = '\0'.
OK krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.22 2006/10/10 21:38:16 cloder Exp $	*/
d46 3
d648 2
a649 2
static void
edit_edit(void)
d651 52
a702 15
	char *system_line;
	char *editor = getenv("EDITOR");
	if (!editor)
		editor = _PATH_VI;

	fclose(edit_file);

	if (asprintf(&system_line, "%s %s", editor, edit_name) == -1)
		err(1, NULL);

	system(system_line);
	free(system_line);

	if ( (edit_file = fopen(edit_name, "r")) == 0)
		err(errno, "open %s", edit_name);
d771 5
a775 1
		edit_edit();
@


1.22
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.21 2006/07/23 02:50:20 dlg Exp $	*/
d624 1
d628 3
a630 1
		line[strlen(line) - 1] = 0;
@


1.21
log
@remove some scsi ioctls, most importantly the ones that can reprobe the
bus. supporting these complicates the midlayer unnecessarily.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.20 2005/11/13 19:16:09 deraadt Exp $	*/
d624 1
a624 1
		if (fgets(line, sizeof(line), edit_file) == 0)
@


1.20
log
@missing fclose(); dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.19 2005/04/13 02:33:08 deraadt Exp $	*/
a63 4
int	reprobe;
#ifdef SCIOCADDR
int	probe_all;
#endif
a64 6
int	bus = -1;	/* all busses */
int	targ = -1;	/* all targs */
int	lun = 0;	/* just lun 0 */
#ifdef SCIOCFREEZE
int	freeze = 0;	/* Freeze this many seconds */
#endif
a75 1
int	arg_get (void *hook, char *field_name);
a85 3
#ifdef SCIOCFREEZE
"  scsi -f device [-v] -z seconds                   # To freeze bus\n"
#endif
a86 2
"  scsi -f device -p [-b bus] [-l lun]              # To probe all devices\n"
"  scsi -f device -r [-b bus] [-t targ] [-l lun]    # To reprobe a device\n"
d111 1
a111 1
	while ((ch = getopt(argc, argv, "ceprvf:d:b:t:l:z:m:P:s:")) != -1) {
a112 8
#ifdef SCIOCADDR
		case 'p':
			probe_all = 1;
			break;
#endif
		case 'r':
			reprobe = 1;
			break;
a115 3
		case 'v':
			verbose = 1;
			break;
d128 3
a130 8
		case 'b':
			bus = strtol(optarg, 0, 0);
			break;
		case 't':
			targ = strtol(optarg, 0, 0);
			break;
		case 'l':
			lun = strtol(optarg, 0, 0);
a131 5
#ifdef SCIOCFREEZE
		case 'z':
			freeze = strtol(optarg, 0, 0);
			break;
#endif
d138 2
a139 3
		case 'm':
			modeflag = 1;
			modepage = strtol(optarg, 0, 0);
a245 6
int arg_get (void *hook, char *field_name)
{
	printf("get \"%s\".\n", field_name);
	return 0;
}

a373 46
#ifdef SCIOCFREEZE
static void
freeze_ioctl(int fd, int op, void *data)
{
	if (ioctl(fd, SCIOCFREEZE, 0) == -1) {
		if (errno == ENODEV) {
			fprintf(stderr,
			"Your kernel must be configured with option SCSI_FREEZE.\n");
			exit(errno);
		} else
			err(errno, "SCIOCFREEZE");
	}
}

/* do_freeze: Freeze the bus for a given number of seconds.
 */
static void do_freeze(int seconds)
{
	if (seconds == -1) {
		printf("Hit return to thaw:  ");
		fflush(stdout);
		sync();

		freeze_ioctl(fd, SCIOCFREEZE, 0);

		(void)getchar();

		freeze_ioctl(fd, SCIOCTHAW, 0);
	}
	else {
		sync();
		freeze_ioctl(fd, SCIOCFREEZETHAW, &seconds);
		if (verbose) {
			putchar('\007');
			fflush(stdout);
		}

		freeze_ioctl(fd, SCIOCWAITTHAW, 0);
		if (verbose) {
			putchar('\007');
			fflush(stdout);
		}
	}
}
#endif

a787 59
#ifdef SCIOCADDR
/* do_probe_all: Loop over all SCSI IDs and see if something is
 * there.  This only does BUS 0 LUN 0.
 */
void do_probe_all(void)
{
	scsireq_t *scsireq;

	char vendor_id[8 + 1], product_id[16 + 1], revision[4 + 1];
	int id;
	u_char *inq_buf = malloc(96);
	struct scsi_addr addr;

	scsireq = scsireq_build(scsireq_new(),
	96, inq_buf, SCCMD_READ,
	"12 0 0 0 v 0", 96);

	addr.scbus = (bus == -1) ? 0 : bus;
	addr.lun = lun;

	if (addr.scbus || addr.lun)
	{
		printf("For bus %d lun %d:\n", addr.scbus, addr.lun);
	}

	for (id = 0; id < 8; id++)
	{
		addr.target = id;

		printf("%d: ", id);
		if (ioctl(fd, SCIOCADDR, &addr) == -1) {
			if (errno == ENXIO)
			{
				errno = 0;
				printf("nothing.\n");
			}
			else
				printf("SCIOCADDR: %s\n", strerror(errno));

			continue;
		}

		if (scsireq_enter(fd, scsireq) == -1) {
			printf("scsireq_enter: %s\n", strerror(errno));
			continue;
		}

		vendor_id[sizeof(vendor_id) - 1] = 0;
		product_id[sizeof(product_id) - 1] = 0;
		revision[sizeof(revision) - 1] = 0;

		scsireq_decode(scsireq, "s8 c8 c16 c4",
		vendor_id, product_id, revision);

		printf("%s %s %s\n", vendor_id, product_id, revision);
	}
}
#endif

a790 2
	struct scsi_addr scaddr;

d795 1
a795 18
#ifdef SCIOCFREEZE
	if (freeze) {
		do_freeze(freeze);
	} else
#endif
#ifdef SCIOCADDR
	if (probe_all)
		do_probe_all();
	else
#endif
	if(reprobe) {
		scaddr.scbus = bus;
		scaddr.target = targ;
		scaddr.lun = lun;

		if (ioctl(fd,SCIOCREPROBE,&scaddr) == -1)
			warn("SCIOCREPROBE");
	} else if(debugflag) {
@


1.19
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.18 2005/04/11 22:02:06 cloder Exp $	*/
d552 1
a552 1
	if (modes == 0)
d590 2
a591 1
					fprintf(stderr, "Stupid program: Buffer overflow.\n");
d599 1
@


1.18
log
@Use absolute path for vi. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.17 2005/04/11 14:59:01 cloder Exp $	*/
d346 1
a346 2
		if (count)
		{
d351 2
a352 4
			if (data_phase == out)
			{
				if (strcmp(data_fmt, "-") == 0)	/* Read data from stdin */
				{
d354 3
a356 2
					while (count > 0 && (amount = read(0, bp, count)) > 0)
					{
d362 1
a362 2
					else if (amount == 0)
					{
@


1.17
log
@Check for asprintf failure.  From Bruno Rohee (thank you).
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.16 2005/04/09 02:14:32 cloder Exp $	*/
d56 1
d739 1
a739 1
		editor = "vi";
@


1.16
log
@Compile with -ansi by killing an inline
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.15 2004/01/14 19:39:59 otto Exp $	*/
d742 3
a744 1
	asprintf(&system_line, "%s %s", editor, edit_name);
@


1.15
log
@Fix printf format string. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.14 2003/07/23 23:10:23 deraadt Exp $	*/
d618 1
a618 1
static inline void
@


1.14
log
@move junk (bad code, terrible APIs) to the only program that uses it;
millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.13 2003/07/06 22:03:58 deraadt Exp $	*/
d407 1
a407 1
				fprintf(stderr, "Warning: wrote only %u bytes out of %u.\n",
@


1.13
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.12 2003/06/26 15:41:12 mickey Exp $	*/
a52 1
#include <scsi.h>
d56 2
@


1.12
log
@use err.h
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.11 2003/06/11 06:22:15 deraadt Exp $	*/
d80 9
a88 1
void
@


1.11
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.10 2003/03/13 05:00:45 deraadt Exp $	*/
d56 1
d83 1
a83 1
	printf(
d112 1
a112 1
	int		    fflag, ch;
d137 2
a138 6
			if ((fd = scsi_open(optarg, O_RDWR)) < 0) {
				(void) fprintf(stderr,
					  "%s: unable to open device %s: %s\n",
					       argv[0], optarg, strerror(errno));
				exit(errno);
			}
d353 1
a353 4
					{
						perror("read");
						exit(errno);
					}
d396 1
a396 4
			{
				perror("write");
				exit(errno);
			}
d401 1
a401 1
			
d419 3
a421 4
		}
		else
			perror("SCIOCFREEZE");
		exit(errno);
d570 1
a570 1
			if (c == EOF) {
a571 1
			}
d646 4
a649 8
	if ((fd = mkstemp(edit_name)) == -1) {
		perror("mkstemp failed");
		exit(errno);
	}
	if ( (edit_file = fdopen(fd, "w+")) == 0) {
		perror("fdopen failed");
		exit(errno);
	}
d705 2
a706 4
		if (fgets(line, sizeof(line), edit_file) == 0) {
			perror("fgets");
			exit(errno);
		}
d712 1
a712 1
			name, line);
d737 2
a738 4
	if ( (edit_file = fopen(edit_name, "r")) == 0) {
		perror(edit_name);
		exit(errno);
	}
d941 1
a941 1
	if (probe_all) {
d943 1
a943 1
	} else
d951 1
a951 1
			perror("ioctl");
d954 1
a954 4
		{
			perror("ioctl [SCIODEBUG]");
			exit(1);
		}
d970 1
a970 1
	} else if (modeflag) {
d972 1
a972 1
	}
@


1.10
log
@more strlcpy; most from Hans-Joerg.Hoexer@@yerbouti.franken.de, a bit from me
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.9 2003/02/20 21:47:27 millert Exp $	*/
d79 2
a80 1
void usage(void)
a82 1

d106 2
a107 1
void procargs(int *argc_p, char ***argv_p)
d111 1
a111 2
	int		    fflag,
	                    ch;
d194 2
a195 1
int iget(void *hook, char *name)
d216 2
a217 1
char *cget(void *hook, char *name)
@


1.9
log
@Use STDOUT_FILENO; David at phobia dot ms
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.8 2001/07/07 18:26:21 deraadt Exp $	*/
d654 1
a654 1
	strcpy(edit_name, "/var/tmp/scXXXXXXXX");
d748 1
a748 2
	system_line = malloc(strlen(editor) + strlen(edit_name) + 6);
	sprintf(system_line, "%s %s", editor, edit_name);
@


1.8
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.7 2001/03/08 21:41:50 deraadt Exp $	*/
d394 1
a394 1
			while (count > 0 && (amount = write(1, bp, count)) > 0)
@


1.7
log
@whack exit(-#)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.6 2000/01/22 20:25:07 deraadt Exp $	*/
d405 1
a405 1
				fprintf(stderr, "Warning: wrote only %d bytes out of %d.\n",
a713 1
	struct get_hook *h = (struct get_hook *)hook;
a976 1
		int i;
@


1.6
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.5 1997/12/10 05:02:02 angelos Exp $	*/
d485 1
a485 1
		exit(-1);
d508 1
a508 1
		exit(-1);
d572 1
a572 1
			exit(-1);
d673 1
a673 1
		exit(-1);
d689 1
a689 1
		exit(-1);
d702 1
a702 1
			exit(-1);
d729 1
a729 1
			exit(-1);
d793 1
a793 1
			exit(-1);
d799 1
a799 1
			exit(-1);
@


1.5
log
@Fix tmpnam()...i don't have SCSI though, so i couldn't test.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.4 1997/08/26 13:38:09 niklas Exp $	*/
a109 2
	extern char        *optarg;
	extern int          optind;
@


1.4
log
@main should return int
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.3 1997/06/24 02:03:00 dgregor Exp $	*/
d653 2
d656 3
a658 2
	if (tmpnam(edit_name) == 0) {
		perror("tmpnam failed");
d661 2
a662 2
	if ( (edit_file = fopen(edit_name, "w")) == 0) {
		perror(edit_name);
@


1.3
log
@Fix void *  -> int casts -- change int's to long's
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.2 1997/01/15 23:41:41 millert Exp $	*/
d944 2
a945 1
void main(int argc, char **argv)
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.1 1996/06/12 11:21:43 deraadt Exp $	*/
d247 1
a247 1
		printf("%d ", (int)arg);
d611 2
a612 2
	int can_edit;
	int default_value;
d679 1
a679 1
	editinfo[editind].can_edit = ((int)arg != 0);
d691 1
a691 1
	editinfo[editind].default_value = ((int)arg);
d704 1
a704 1
		fprintf(edit_file, "%s:  %d\n", name, (int)arg);
@


1.1
log
@add /sbin/scsi from FreeBSD -- a good start!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d118 1
a118 1
	while ((ch = getopt(argc, argv, "ceprvf:d:b:t:l:z:m:P:s:")) != EOF) {
@
