head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.10
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.4
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.10
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.18
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.16
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.14
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.12
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	82PdNqu2kKAuXPfA;

1.38
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	6b2lLILbgCR1fvia;

1.37
date	2015.02.07.02.09.14;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	pzd3OPiuZ6mCFBtc;

1.36
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	F55lwc3gS4GN2mLs;

1.35
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2014.07.22.18.28.40;	author jca;	state Exp;
branches;
next	1.33;
commitid	uhkNBhGu0j1yV7cK;

1.33
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.12.21.10.35;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.23.21.28.10;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2012.05.31.13.55.54;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2012.04.12.18.30.43;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2012.03.24.15.39.54;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2012.02.08.20.38.50;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.16.21.22.53;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.11.13.40.24;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.29.03.37.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.21.06.22.25;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.05.00.13.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.04.00.42.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.13.09.09.27;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.11.02.32.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.17.19.42.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	97.06.25.18.29.07;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.22.00.37.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.03.16.22.10;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.06.23.14.32.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.25.11.04.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.23.47.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.07.05.28.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.06.21.11.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.24.14.32.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: quotacheck.c,v 1.38 2015/04/18 18:28:37 deraadt Exp $	*/
/*	$NetBSD: quotacheck.c,v 1.12 1996/03/30 22:34:25 mark Exp $	*/

/*
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Elz at The University of Melbourne.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Fix up / report on disk quotas & usage
 */
#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE */
#include <sys/stat.h>
#include <sys/wait.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ufs/quota.h>
#include <ufs/ffs/fs.h>

#include <fcntl.h>
#include <fstab.h>
#include <pwd.h>
#include <grp.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include "fsutil.h"

char *qfname = QUOTAFILENAME;
char *qfextension[] = INITQFNAMES;
char *quotagroup = QUOTAGROUP;

union {
	struct	fs	sblk;
	char	dummy[MAXBSIZE];
} sb_un;
#define	sblock	sb_un.sblk
union {
	struct	cg	cgblk;
	char	dummy[MAXBSIZE];
} cg_un;
#define	cgblk	cg_un.cgblk

long maxino;

union dinode {
	struct ufs1_dinode dp1;
	struct ufs2_dinode dp2;
};
#define	DIP(dp, field) \
	((sblock.fs_magic == FS_UFS1_MAGIC) ? \
	(dp)->dp1.field : (dp)->dp2.field)

struct quotaname {
	long	flags;
	char	grpqfname[PATH_MAX + 1];
	char	usrqfname[PATH_MAX + 1];
};
#define	HASUSR	1
#define	HASGRP	2

struct fileusage {
	struct fileusage *fu_next;
	u_int32_t	fu_curinodes;
	u_int32_t	fu_curblocks;
	u_int32_t	fu_id;	/* uid_t or gid_t */
	char		fu_name[1];
	/* actually bigger */
};
#define FUHASH 1024	/* must be power of two */
struct fileusage *fuhead[MAXQUOTAS][FUHASH];

int	gflag;			/* check group quotas */
int	uflag;			/* check user quotas */
int	flags;			/* check flags (avd) */
int	fi;			/* open disk file descriptor */
u_int32_t highid[MAXQUOTAS];	/* highest addid()'ed identifier per type */

struct fileusage *
	 addid(u_int32_t, int, char *);
char	*blockcheck(char *);
void	 bread(daddr_t, char *, long);
int	 chkquota(const char *, const char *, const char *, void *, pid_t *);
void	 freeinodebuf(void);
union dinode *
	 getnextinode(ino_t);
int	 getquotagid(void);
int	 hasquota(struct fstab *, int, char **);
struct fileusage *
	 lookup(u_int32_t, int);
void	*needchk(struct fstab *);
int	 oneof_realpath(char *, char*[], int);
int	 oneof_specname(char *, char*[], int);
void	 setinodebuf(ino_t);
int	 update(const char *, const char *, int);
void	 usage(void);

int
main(int argc, char *argv[])
{
	struct fstab *fs;
	struct passwd *pw;
	struct group *gr;
	struct quotaname *auxdata;
	int i, argnum, maxrun, errs, ch;
	u_int64_t done = 0;	/* XXX supports maximum 64 filesystems */
	const char *errstr;
	char *name;

	errs = maxrun = 0;
	while ((ch = getopt(argc, argv, "adguvl:")) != -1) {
		switch(ch) {
		case 'a':
			flags |= CHECK_PREEN;
			break;
		case 'd':
			flags |= CHECK_DEBUG;
			break;
		case 'g':
			gflag = 1;
			break;
		case 'l':
			maxrun = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-l %s: %s", optarg, errstr);
			break;
		case 'u':
			uflag = 1;
			break;
		case 'v':
			flags |= CHECK_VERBOSE;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if ((argc == 0 && !(flags&CHECK_PREEN)) ||
	    (argc > 0 && (flags&CHECK_PREEN)))
		usage();
	if (!gflag && !uflag) {
		gflag++;
		uflag++;
	}
	if (gflag) {
		setgrent();
		while ((gr = getgrent()) != 0)
			(void) addid(gr->gr_gid, GRPQUOTA, gr->gr_name);
		endgrent();
	}
	if (uflag) {
		setpwent();
		while ((pw = getpwent()) != 0)
			(void) addid(pw->pw_uid, USRQUOTA, pw->pw_name);
		endpwent();
	}
	if (flags&CHECK_PREEN)
		exit(checkfstab(flags, maxrun, needchk, chkquota));
	if (setfsent() == 0)
		err(1, "%s: can't open", _PATH_FSTAB);
	while ((fs = getfsent()) != NULL) {
		if (((argnum = oneof_realpath(fs->fs_file, argv, argc)) >= 0 ||
		    (argnum = oneof_specname(fs->fs_spec, argv, argc)) >= 0) &&
		    (auxdata = needchk(fs)) &&
		    (name = blockcheck(fs->fs_spec))) {
			done |= 1 << argnum;
			errs += chkquota(fs->fs_vfstype, name,
			    fs->fs_file, auxdata, NULL);
		}
	}
	endfsent();
	for (i = 0; i < argc; i++)
		if ((done & (1 << i)) == 0)
			fprintf(stderr, "%s not found in %s\n",
			    argv[i], _PATH_FSTAB);
	exit(errs);
}

void
usage(void)
{
	extern char *__progname;
	(void)fprintf(stderr, "usage: %s [-adguv] [-l maxparallel] "
	    "filesystem ...\n", __progname);
	exit(1);
}

void *
needchk(struct fstab *fs)
{
	struct quotaname *qnp;
	char *qfnp;

	if (fs->fs_passno == 0)
		return NULL;
	if (strcmp(fs->fs_type, FSTAB_RW))
		return (NULL);
	if (strcmp(fs->fs_vfstype, "ffs") &&
	    strcmp(fs->fs_vfstype, "ufs") &&
	    strcmp(fs->fs_vfstype, "mfs"))
		return (NULL);
	if ((qnp = malloc(sizeof(*qnp))) == NULL)
		err(1, "%s", strerror(errno));
	qnp->flags = 0;
	if (gflag && hasquota(fs, GRPQUOTA, &qfnp)) {
		strlcpy(qnp->grpqfname, qfnp, sizeof qnp->grpqfname);
		qnp->flags |= HASGRP;
	}
	if (uflag && hasquota(fs, USRQUOTA, &qfnp)) {
		strlcpy(qnp->usrqfname, qfnp, sizeof qnp->usrqfname);
		qnp->flags |= HASUSR;
	}
	if (qnp->flags)
		return (qnp);
	free(qnp);
	return (NULL);
}

/*
 * Possible superblock locations ordered from most to least likely.
 */
static int sblock_try[] = SBLOCKSEARCH;

/*
 * Scan the specified file system to check quota(s) present on it.
 */
int
chkquota(const char *vfstype, const char *fsname, const char *mntpt,
    void *auxarg, pid_t *pidp)
{
	struct quotaname *qnp = auxarg;
	struct fileusage *fup;
	union dinode *dp;
	int cg, i, mode, errs = 0, status;
	ino_t ino, inosused;
	pid_t pid;
	char *cp;

	switch (pid = fork()) {
	case -1:	/* error */
		warn("fork");
		return 1;
	case 0:		/* child */
		if ((fi = opendev(fsname, O_RDONLY, 0, NULL)) < 0)
			err(1, "%s", fsname);
		sync();
		for (i = 0; sblock_try[i] != -1; i++) {
			bread(sblock_try[i] / DEV_BSIZE, (char *)&sblock,
			    (long)SBLOCKSIZE);
			if ((sblock.fs_magic == FS_UFS1_MAGIC ||
			     (sblock.fs_magic == FS_UFS2_MAGIC &&
			      sblock.fs_sblockloc == sblock_try[i])) &&
			    sblock.fs_bsize <= MAXBSIZE &&
			    sblock.fs_bsize >= sizeof(struct fs))
				break;
		}
		if (sblock_try[i] == -1) {
			warn("Cannot find file system superblock");
			return (1);
		}
		maxino = sblock.fs_ncg * sblock.fs_ipg;
		for (cg = 0; cg < sblock.fs_ncg; cg++) {
			ino = cg * sblock.fs_ipg;
			setinodebuf(ino);
			bread(fsbtodb(&sblock, cgtod(&sblock, cg)),
			    (char *)(&cgblk), sblock.fs_cgsize);
			if (sblock.fs_magic == FS_UFS2_MAGIC)
				inosused = cgblk.cg_initediblk;
			else
				inosused = sblock.fs_ipg;
			/*
			 * If we are using soft updates, then we can trust the
			 * cylinder group inode allocation maps to tell us which
			 * inodes are allocated. We will scan the used inode map
			 * to find the inodes that are really in use, and then
			 * read only those inodes in from disk.
			 */
			if (sblock.fs_flags & FS_DOSOFTDEP) {
				if (!cg_chkmagic(&cgblk))
					errx(1, "CG %d: BAD MAGIC NUMBER\n", cg);
				cp = &cg_inosused(&cgblk)[(inosused - 1) / CHAR_BIT];
				for ( ; inosused > 0; inosused -= CHAR_BIT, cp--) {
					if (*cp == 0)
						continue;
					for (i = 1 << (CHAR_BIT - 1); i > 0; i >>= 1) {
						if (*cp & i)
							break;
						inosused--;
					}
					break;
				}
				if (inosused <= 0)
					continue;
			}
			for (i = 0; i < inosused; i++, ino++) {
				if ((dp = getnextinode(ino)) == NULL ||
				    ino < ROOTINO ||
				    (mode = DIP(dp, di_mode) & IFMT) == 0)
					continue;
				if (qnp->flags & HASGRP) {
					fup = addid(DIP(dp, di_gid),
					    GRPQUOTA, NULL);
					fup->fu_curinodes++;
					if (mode == IFREG || mode == IFDIR ||
					    mode == IFLNK)
						fup->fu_curblocks +=
						    DIP(dp, di_blocks);
				}
				if (qnp->flags & HASUSR) {
					fup = addid(DIP(dp, di_uid),
					    USRQUOTA, NULL);
					fup->fu_curinodes++;
					if (mode == IFREG || mode == IFDIR ||
					    mode == IFLNK)
						fup->fu_curblocks +=
						    DIP(dp, di_blocks);
				}
			}
		}
		freeinodebuf();
		if (flags&(CHECK_DEBUG|CHECK_VERBOSE)) {
			(void)printf("*** Checking ");
			if (qnp->flags & HASUSR) {
				(void)printf("%s", qfextension[USRQUOTA]);
				if (qnp->flags & HASGRP)
					(void)printf(" and ");
			}
			if (qnp->flags & HASGRP)
				(void)printf("%s", qfextension[GRPQUOTA]);
			(void)printf(" quotas for %s (%s), %swait\n",
			    fsname, mntpt, pidp? "no" : "");
		}
		if (qnp->flags & HASUSR)
			errs += update(mntpt, qnp->usrqfname, USRQUOTA);
		if (qnp->flags & HASGRP)
			errs += update(mntpt, qnp->grpqfname, GRPQUOTA);
		close(fi);
		exit (errs);
		break;
	default:	/* parent */
		if (pidp != NULL) {
			*pidp = pid;
			return 0;
		}
		if (waitpid(pid, &status, 0) < 0) {
			warn("waitpid");
			return 1;
		}
		if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				return WEXITSTATUS(status);
		} else if (WIFSIGNALED(status)) {
			warnx("%s: %s", fsname, strsignal(WTERMSIG(status)));
			return 1;
		}
		break;
	}
	return (0);
}

/*
 * Update a specified quota file.
 */
int
update(const char *fsname, const char *quotafile, int type)
{
	struct fileusage *fup;
	FILE *qfi, *qfo;
	u_int32_t id, lastid;
	struct dqblk dqbuf;
	static int warned = 0;
	static struct dqblk zerodqbuf;
	static struct fileusage zerofileusage;

	if (flags&CHECK_DEBUG)
		printf("updating: %s\n", quotafile);

	if ((qfo = fopen(quotafile, (flags&CHECK_DEBUG)? "r" : "r+")) == NULL) {
		if (errno == ENOENT)
			qfo = fopen(quotafile, "w+");
		if (qfo) {
			warnx("creating quota file: %s", quotafile);
#define	MODE	(S_IRUSR|S_IWUSR|S_IRGRP)
			(void) fchown(fileno(qfo), getuid(), getquotagid());
			(void) fchmod(fileno(qfo), MODE);
		} else {
			warn("%s", quotafile);
			return (1);
		}
	}
	if ((qfi = fopen(quotafile, "r")) == NULL) {
		warn("%s", quotafile);
		(void) fclose(qfo);
		return (1);
	}
	if (quotactl(fsname, QCMD(Q_SYNC, type), 0, (caddr_t)0) < 0 &&
	    errno == EOPNOTSUPP && !warned &&
	    (flags&(CHECK_DEBUG|CHECK_VERBOSE))) {
		warned++;
		(void)printf("*** Warning: %s\n",
		    "Quotas are not compiled into this kernel");
	}
	for (lastid = highid[type], id = 0; id <= lastid; id++) {
		if (fread((char *)&dqbuf, sizeof(struct dqblk), 1, qfi) == 0)
			dqbuf = zerodqbuf;
		if ((fup = lookup(id, type)) == 0)
			fup = &zerofileusage;
		if (dqbuf.dqb_curinodes == fup->fu_curinodes &&
		    dqbuf.dqb_curblocks == fup->fu_curblocks) {
			fup->fu_curinodes = 0;
			fup->fu_curblocks = 0;
			fseek(qfo, (long)sizeof(struct dqblk), SEEK_CUR);
			continue;
		}
		if (flags&(CHECK_DEBUG|CHECK_VERBOSE)) {
			if (flags&CHECK_PREEN)
				printf("%s: ", fsname);
			printf("%-8s fixed:", fup->fu_name);
			if (dqbuf.dqb_curinodes != fup->fu_curinodes)
				(void)printf("\tinodes %d -> %u",
				    dqbuf.dqb_curinodes, fup->fu_curinodes);
			if (dqbuf.dqb_curblocks != fup->fu_curblocks)
				(void)printf("\tblocks %u -> %u",
				    dqbuf.dqb_curblocks, fup->fu_curblocks);
			(void)printf("\n");
		}
		/*
		 * Reset time limit if have a soft limit and were
		 * previously under it, but are now over it.
		 */
		if (dqbuf.dqb_bsoftlimit &&
		    dqbuf.dqb_curblocks < dqbuf.dqb_bsoftlimit &&
		    fup->fu_curblocks >= dqbuf.dqb_bsoftlimit)
			dqbuf.dqb_btime = 0;
		if (dqbuf.dqb_isoftlimit &&
		    dqbuf.dqb_curblocks < dqbuf.dqb_isoftlimit &&
		    fup->fu_curblocks >= dqbuf.dqb_isoftlimit)
			dqbuf.dqb_itime = 0;
		dqbuf.dqb_curinodes = fup->fu_curinodes;
		dqbuf.dqb_curblocks = fup->fu_curblocks;
		if (!(flags & CHECK_DEBUG)) {
			fwrite((char *)&dqbuf, sizeof(struct dqblk), 1, qfo);
			(void) quotactl(fsname, QCMD(Q_SETUSE, type), id,
			    (caddr_t)&dqbuf);
		}
		fup->fu_curinodes = 0;
		fup->fu_curblocks = 0;
	}
	fclose(qfi);
	fflush(qfo);
	if (!(flags & CHECK_DEBUG))
		ftruncate(fileno(qfo),
		    (off_t)((highid[type] + 1) * sizeof(struct dqblk)));
	fclose(qfo);
	return (0);
}

/*
 * Check to see if realpath(target) matches a realpath() in list of size cnt.
 */
int
oneof_realpath(char *target, char *list[], int cnt)
{
	int i;
	char realtarget[PATH_MAX], realargv[PATH_MAX];
	char *rv;

	rv = realpath(target, realtarget);
	if (rv == NULL)
		return (-1);

	for (i = 0; i < cnt; i++) {
		rv = realpath(list[i], realargv);
		if (rv && strcmp(realtarget, realargv) == 0)
			break;
	}

	if (i < cnt)
		return (i);
	else
		return (-1);
}

/*
 * Check to see if opendev(target) matches a opendev() in list of size cnt.
 */
int
oneof_specname(char *target, char *list[], int cnt)
{
	int i, fd;
	char *tmp, *targetdev, *argvdev;

	fd = opendev(target, O_RDONLY, 0, &tmp);
	if (fd == -1)
		return (-1);
	close(fd);
	targetdev = strdup(tmp);

	for (i = 0; i < cnt; i++) {
		fd = opendev(list[i], O_RDONLY, 0, &argvdev);
		if (fd == -1)
			continue;
		close(fd);
		if (strcmp(targetdev, argvdev) == 0)
			break;
	}

	free(targetdev);

	if (i < cnt)
		return (i);
	else
		return (-1);
}

/*
 * Determine the group identifier for quota files.
 */
int
getquotagid(void)
{
	struct group *gr;

	if ((gr = getgrnam(quotagroup)) != NULL)
		return (gr->gr_gid);
	return (-1);
}

/*
 * Check to see if a particular quota is to be enabled.
 */
int
hasquota(struct fstab *fs, int type, char **qfnamep)
{
	char *opt, *cp;
	static char initname, usrname[100], grpname[100];
	static char buf[BUFSIZ];

	if (!initname) {
		(void)snprintf(usrname, sizeof(usrname),
		    "%s%s", qfextension[USRQUOTA], qfname);
		(void)snprintf(grpname, sizeof(grpname),
		    "%s%s", qfextension[GRPQUOTA], qfname);
		initname = 1;
	}
	(void)strlcpy(buf, fs->fs_mntops, sizeof(buf));
	for (opt = strtok(buf, ","); opt; opt = strtok(NULL, ",")) {
		if ((cp = strchr(opt, '=')) != NULL)
			*cp++ = '\0';
		if (type == USRQUOTA && strcmp(opt, usrname) == 0)
			break;
		if (type == GRPQUOTA && strcmp(opt, grpname) == 0)
			break;
	}
	if (!opt)
		return (0);
	if (cp)
		*qfnamep = cp;
	else {
		(void)snprintf(buf, sizeof(buf),
		    "%s/%s.%s", fs->fs_file, qfname, qfextension[type]);
		*qfnamep = buf;
	}
	return (1);
}

/*
 * Routines to manage the file usage table.
 *
 * Lookup an id of a specific type.
 */
struct fileusage *
lookup(u_int32_t id, int type)
{
	struct fileusage *fup;

	for (fup = fuhead[type][id & (FUHASH-1)]; fup != 0; fup = fup->fu_next)
		if (fup->fu_id == id)
			return (fup);
	return (NULL);
}

/*
 * Add a new file usage id if it does not already exist.
 */
struct fileusage *
addid(u_int32_t id, int type, char *name)
{
	struct fileusage *fup, **fhp;
	int len;

	if ((fup = lookup(id, type)) != NULL)
		return (fup);
	if (name)
		len = strlen(name);
	else
		len = 10;
	if ((fup = calloc(1, sizeof(*fup) + len)) == NULL)
		err(1, "%s", strerror(errno));
	fhp = &fuhead[type][id & (FUHASH - 1)];
	fup->fu_next = *fhp;
	*fhp = fup;
	fup->fu_id = id;
	if (id > highid[type])
		highid[type] = id;
	if (name)
		memcpy(fup->fu_name, name, len + 1);
	else
		(void)snprintf(fup->fu_name, len, "%u", id);
	return (fup);
}

/*
 * Special purpose version of ginode used to optimize pass
 * over all the inodes in numerical order.
 */
static ino_t nextino, lastinum, lastvalidinum;
static long readcnt, readpercg, fullcnt, inobufsize, partialcnt, partialsize;
static caddr_t inodebuf;
#define	INOBUFSIZE	56*1024		/* size of buffer to read inodes */

union dinode *
getnextinode(ino_t inumber)
{
	long size;
	daddr_t dblk;
	union dinode *dp;
	static caddr_t nextinop;

	if (inumber != nextino++ || inumber > lastvalidinum)
		err(1, "bad inode number %llu to nextinode",
		    (unsigned long long)inumber);
	if (inumber >= lastinum) {
		readcnt++;
		dblk = fsbtodb(&sblock, ino_to_fsba(&sblock, lastinum));
		if (readcnt % readpercg == 0) {
			size = partialsize;
			lastinum += partialcnt;
		} else {
			size = inobufsize;
			lastinum += fullcnt;
		}
		/*
		 * If bread returns an error, it will already have zeroed
		 * out the buffer, so we do not need to do so here.
		 */
		bread(dblk, inodebuf, size);
		nextinop = inodebuf;
	}
	dp = (union dinode *)nextinop;
	if (sblock.fs_magic == FS_UFS1_MAGIC)
		nextinop += sizeof(struct ufs1_dinode);
	else
		nextinop += sizeof(struct ufs2_dinode);
	return (dp);
}

/*
 * Prepare to scan a set of inodes.
 */
void
setinodebuf(ino_t inum)
{

	if (inum % sblock.fs_ipg != 0)
		errx(1, "bad inode number %llu to setinodebuf",
		    (unsigned long long)inum);
	lastvalidinum = inum + sblock.fs_ipg - 1;
	nextino = inum;
	lastinum = inum;
	readcnt = 0;
	if (inodebuf != NULL)
		return;
	inobufsize = blkroundup(&sblock, INOBUFSIZE);
	fullcnt = inobufsize / ((sblock.fs_magic == FS_UFS1_MAGIC) ?
	    sizeof(struct ufs1_dinode) : sizeof(struct ufs2_dinode));
	readpercg = sblock.fs_ipg / fullcnt;
	partialcnt = sblock.fs_ipg % fullcnt;
	partialsize = partialcnt * ((sblock.fs_magic == FS_UFS1_MAGIC) ?
	    sizeof(struct ufs1_dinode) : sizeof(struct ufs2_dinode));
	if (partialcnt != 0) {
		readpercg++;
	} else {
		partialcnt = fullcnt;
		partialsize = inobufsize;
	}
	if ((inodebuf = malloc((size_t)inobufsize)) == NULL)
		errx(1, "cannot allocate space for inode buffer");
}

/*
 * Free up data structures used to scan inodes.
 */
void
freeinodebuf(void)
{

	free(inodebuf);
	inodebuf = NULL;
}

/*
 * Read specified disk blocks.
 */
void
bread(daddr_t bno, char *buf, long cnt)
{
	if (pread(fi, buf, cnt, bno * DEV_BSIZE) != cnt)
		err(1, "read failed on block %lld", (long long)bno);
}
@


1.38
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.37 2015/02/07 02:09:14 deraadt Exp $	*/
d731 1
a731 2
	if (inodebuf != NULL)
		free(inodebuf);
@


1.37
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.36 2015/01/20 18:22:21 deraadt Exp $	*/
d139 1
d155 3
a157 1
			maxrun = atoi(optarg);
@


1.36
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.35 2015/01/16 06:40:00 deraadt Exp $	*/
d151 1
a151 1
			gflag++;
d157 1
a157 1
			uflag++;
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.34 2014/07/22 18:28:40 jca Exp $	*/
d39 1
a39 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE MAXBSIZE */
@


1.34
log
@FSTAB -> _PATH_FSTAB, the latter is deprecated.
From natano@@bitrig, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.33 2014/05/20 21:11:16 krw Exp $	*/
d39 1
a39 1
#include <sys/param.h>
d53 1
d88 2
a89 2
	char	grpqfname[MAXPATHLEN + 1];
	char	usrqfname[MAXPATHLEN + 1];
@


1.33
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.32 2014/05/12 21:10:35 krw Exp $	*/
d189 1
a189 1
		err(1, "%s: can't open", FSTAB);
d204 1
a204 1
			    argv[i], FSTAB);
@


1.32
log
@Remove useless dev_bsize variable and use DEV_BSIZE as needed. Divide
sblock_try[] entries by DEV_BSIZE to get proper 512-byte-block address
for bread().

Confirmed to still work on 4k-byte sector devices by David Vasek.
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.31 2013/06/11 16:42:05 deraadt Exp $	*/
d738 2
a739 3
	if (lseek(fi, (off_t)bno * DEV_BSIZE, SEEK_SET) < 0 ||
	    read(fi, buf, cnt) != cnt)
		err(1, "bread failed on block %lld", (long long)bno);
@


1.31
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.30 2013/04/23 21:28:10 deraadt Exp $	*/
a74 1
long dev_bsize;
a275 1
		dev_bsize = 1;
d277 2
a278 1
			bread(sblock_try[i], (char *)&sblock, (long)SBLOCKSIZE);
a289 1
		dev_bsize = sblock.fs_fsize / fsbtodb(&sblock, 1);
d738 1
a738 2

	if (lseek(fi, (off_t)bno * dev_bsize, SEEK_SET) < 0 ||
@


1.30
log
@handle large ino_t; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.29 2012/05/31 13:55:54 krw Exp $	*/
d114 1
a114 1
void	 bread(daddr64_t, char *, long);
d657 1
a657 1
	daddr64_t dblk;
d738 1
a738 1
bread(daddr64_t bno, char *buf, long cnt)
@


1.29
log
@Let quotacheck work with duid based fstab. Missed one open() -> opendev()
from Rogier Krieger's original diff.

Found by and fix tested by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.28 2012/04/12 18:30:43 deraadt Exp $	*/
d662 2
a663 1
		err(1, "bad inode number %u to nextinode", inumber);
d697 2
a698 1
		errx(1, "bad inode number %d to setinodebuf", inum);
@


1.28
log
@do not downsize a type before calling malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.27 2012/03/24 15:39:54 jsg Exp $	*/
d274 1
a274 1
		if ((fi = open(fsname, O_RDONLY, 0)) < 0)
@


1.27
log
@fix some leaks
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.26 2012/02/08 20:38:50 krw Exp $	*/
d716 1
a716 1
	if ((inodebuf = malloc((unsigned)inobufsize)) == NULL)
@


1.26
log
@Hammer fstab entries and command line entries into same format with
realpath() and opendev() so duid and device names work consistantly.
Also lets duid fstab entries work.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.25 2009/10/27 23:59:34 deraadt Exp $	*/
d538 2
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.24 2007/12/16 21:22:53 otto Exp $	*/
d53 1
d124 2
a125 1
int	 oneof(char *, char*[], int);
d192 2
a193 2
		if (((argnum = oneof(fs->fs_file, argv, argc)) >= 0 ||
		    (argnum = oneof(fs->fs_spec, argv, argc)) >= 0) &&
d490 1
a490 1
 * Check to see if target appears in list of size cnt.
d493 1
a493 1
oneof(char *target, char *list[], int cnt)
d496 2
d499 44
a542 4
	for (i = 0; i < cnt; i++)
		if (strcmp(target, list[i]) == 0)
			return (i);
	return (-1);
@


1.24
log
@fix ffs2 case: fs_sblockloc's unit is disk sectors, not fragments;
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.23 2007/07/11 13:40:24 millert Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)quotacheck.c	8.3 (Berkeley) 1/29/94";
#else
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.23 2007/07/11 13:40:24 millert Exp $";
#endif
#endif /* not lint */
@


1.23
log
@ffs2 support from FreeBSD.  Tested by jmc@@ and kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.22 2007/06/29 03:37:09 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.22 2007/06/29 03:37:09 deraadt Exp $";
d294 1
a294 2
			      sblock.fs_sblockloc ==
				  numfrags(&sblock, sblock_try[i]))) &&
@


1.22
log
@more daddr64_t changes; checked by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.21 2007/02/21 06:22:25 jmc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.21 2007/02/21 06:22:25 jmc Exp $";
d80 8
a87 2
} un;
#define	sblock	un.sblk
d91 8
d130 1
a130 1
struct ufs1_dinode *
d138 1
a138 1
void	 resetinodebuf(void);
d262 6
a267 1
 * Scan the specified filesystem to check quota(s) present on it.
d275 1
a275 1
	struct ufs1_dinode *dp;
d277 1
a277 1
	ino_t ino;
d279 1
d290 14
a303 1
		bread(SBOFF, (char *)&sblock, (long)SBSIZE);
d306 31
a336 4
		resetinodebuf();
		for (ino = 0, cg = 0; cg < sblock.fs_ncg; cg++) {
			for (i = 0; i < sblock.fs_ipg; i++, ino++) {
				if (ino < ROOTINO)
d338 5
a342 3
				if ((dp = getnextinode(ino)) == NULL)
					continue;
				if ((mode = dp->di_mode & IFMT) == 0)
d345 1
a345 1
					fup = addid(dp->di_gid,
d351 1
a351 1
						    dp->di_blocks;
d354 1
a354 1
					fup = addid(dp->di_uid,
d360 1
a360 1
						    dp->di_blocks;
d464 1
a464 1
				(void)printf("\tinodes %d -> %ld",
d467 1
a467 1
				(void)printf("\tblocks %u -> %ld",
d609 1
a609 2
		(void)snprintf(fup->fu_name, len, "%lu",
		    id); /* 1 byte extra */
d617 4
a620 4
ino_t nextino, lastinum;
long readcnt, readpercg, fullcnt, inobufsize, partialcnt, partialsize;
struct ufs1_dinode *inodebuf;
#define	INOBUFSIZE	56*1024	/* size of buffer to read inodes */
d622 1
a622 1
struct ufs1_dinode *
d627 2
a628 1
	static struct ufs1_dinode *dp;
d630 1
a630 1
	if (inumber != nextino++ || inumber > maxino)
d642 6
a647 2
		bread(dblk, (char *)inodebuf, size);
		dp = inodebuf;
d649 6
a654 1
	return (dp++);
d661 1
a661 1
resetinodebuf(void)
d664 5
a668 2
	nextino = 0;
	lastinum = 0;
d670 2
d673 2
a674 1
	fullcnt = inobufsize / sizeof(struct ufs1_dinode);
d677 2
a678 1
	partialsize = partialcnt * sizeof(struct ufs1_dinode);
d685 2
a686 5
	if (inodebuf == NULL &&
	   (inodebuf = malloc((u_int)inobufsize)) == NULL)
		err(1, "%s", strerror(errno));
	while (nextino < ROOTINO)
		getnextinode(nextino);
d710 1
a710 1
		err(1, "block %lld", bno);
@


1.21
log
@simplify synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.20 2005/04/05 00:13:49 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.20 2005/04/05 00:13:49 deraadt Exp $";
d94 5
a98 5
	struct	fileusage *fu_next;
	u_long	fu_curinodes;
	u_long	fu_curblocks;
	u_long	fu_id;
	char	fu_name[1];
d108 1
a108 1
u_long	highid[MAXQUOTAS];	/* highest addid()'ed identifier per type */
d111 1
a111 1
	 addid(u_long, int, char *);
d113 1
a113 1
void	 bread(daddr_t, char *, long);
d121 1
a121 1
	 lookup(u_long, int);
d136 1
a136 1
	long done = 0;
d176 1
a176 1
			(void) addid((u_long)gr->gr_gid, GRPQUOTA, gr->gr_name);
d182 1
a182 1
			(void) addid((u_long)pw->pw_uid, USRQUOTA, pw->pw_name);
d283 1
a283 1
					fup = addid((u_long)dp->di_gid,
d292 1
a292 1
					fup = addid((u_long)dp->di_uid,
d351 1
a351 1
	u_long id, lastid;
d378 1
a378 1
	if (quotactl(fsname, QCMD(Q_SYNC, type), (u_long)0, (caddr_t)0) < 0 &&
d394 1
a394 1
			fseek(qfo, (long)sizeof(struct dqblk), 1);
d405 1
a405 1
				(void)printf("\tblocks %d -> %ld",
d511 1
a511 1
lookup(u_long id, int type)
d525 1
a525 1
addid(u_long id, int type, char *name)
d565 1
a565 1
	daddr_t dblk;
d569 1
a569 1
		err(1, "bad inode number %d to nextinode", inumber);
d630 1
a630 1
bread(daddr_t bno, char *buf, long cnt)
d635 1
a635 1
		err(1, "block %u", bno);
@


1.20
log
@spacing found while digging for bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.19 2003/08/25 23:28:15 tedu Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.19 2003/08/25 23:28:15 tedu Exp $";
d210 3
a212 3
	(void)fprintf(stderr, "usage:\t%s\n\t%s\n",
	    "quotacheck -a [-dguv] [-l <maxparallel>]",
	    "quotacheck [-dguv] filesys ...");
@


1.19
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.18 2003/06/02 20:06:16 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.18 2003/06/02 20:06:16 millert Exp $";
d135 1
a135 1
	int i, argnum, maxrun, errs;
a137 1
	int ch;
d196 1
a196 1
					 fs->fs_file, auxdata, NULL);
d203 1
a203 1
				argv[i], FSTAB);
d211 2
a212 2
		"quotacheck -a [-dguv] [-l <maxparallel>]",
		"quotacheck [-dguv] filesys ...");
d243 2
a244 4
	else {
		free(qnp);
		return (NULL);
	}
d284 1
a284 1
						    GRPQUOTA, NULL);
d289 1
a289 1
							dp->di_blocks;
d293 1
a293 1
						    USRQUOTA, NULL);
d298 1
a298 1
							dp->di_blocks;
d313 1
a313 1
				     fsname, mntpt, pidp? "no" : "");
d403 1
a403 1
					dqbuf.dqb_curinodes, fup->fu_curinodes);
d406 1
a406 1
					dqbuf.dqb_curblocks, fup->fu_curblocks);
d473 1
a473 2
	char *opt;
	char *cp;
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.17 2003/04/04 00:42:34 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.17 2003/04/04 00:42:34 deraadt Exp $";
d116 1
a116 1
struct dinode *
d259 1
a259 1
	struct dinode *dp;
d562 1
a562 1
struct dinode *inodebuf;
d565 1
a565 1
struct dinode *
d570 1
a570 1
	static struct dinode *dp;
d601 1
a601 1
	fullcnt = inobufsize / sizeof(struct dinode);
d604 1
a604 1
	partialsize = partialcnt * sizeof(struct dinode);
@


1.17
log
@snprintf & strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.16 2003/03/13 09:09:27 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.16 2003/03/13 09:09:27 deraadt Exp $";
@


1.16
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.15 2003/03/11 02:32:31 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.15 2003/03/11 02:32:31 deraadt Exp $";
d239 1
a239 1
		strcpy(qnp->grpqfname, qfnp);
d243 1
a243 1
		strcpy(qnp->usrqfname, qfnp);
@


1.15
log
@strcpy -> strlcpy; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.14 2002/07/03 22:32:33 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.14 2002/07/03 22:32:33 deraadt Exp $";
d555 2
a556 1
		(void)sprintf(fup->fu_name, "%lu", id);
@


1.14
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.13 2002/02/17 19:42:29 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.13 2002/02/17 19:42:29 millert Exp $";
d492 1
a492 1
	strcpy(buf, fs->fs_mntops);
@


1.13
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.12 2002/02/16 21:27:37 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.12 2002/02/16 21:27:37 millert Exp $";
d133 1
a133 3
main(argc, argv)
	int argc;
	char *argv[];
d213 1
a213 1
usage()
d222 1
a222 2
needchk(fs)
	struct fstab *fs;
d258 2
a259 4
chkquota(vfstype, fsname, mntpt, auxarg, pidp)
	const char *vfstype, *fsname, *mntpt;
	void *auxarg;
	pid_t *pidp;
d354 1
a354 3
update(fsname, quotafile, type)
	const char *fsname, *quotafile;
	int type;
d451 1
a451 3
oneof(target, list, cnt)
	char *target, *list[];
	int cnt;
d465 1
a465 1
getquotagid()
d478 1
a478 4
hasquota(fs, type, qfnamep)
	struct fstab *fs;
	int type;
	char **qfnamep;
d519 1
a519 3
lookup(id, type)
	u_long id;
	int type;
d533 1
a533 4
addid(id, type, name)
	u_long id;
	int type;
	char *name;
d569 1
a569 2
getnextinode(inumber)
	ino_t inumber;
d597 1
a597 1
resetinodebuf()
d625 1
a625 1
freeinodebuf()
d637 1
a637 4
bread(bno, buf, cnt)
	daddr_t bno;
	char *buf;
	long cnt;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.11 2001/11/05 07:39:17 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.11 2001/11/05 07:39:17 mpech Exp $";
d118 1
a118 2
int	 chkquota __P((const char *, const char *,
			const char *, void *, pid_t *));
@


1.11
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.10 1997/06/25 18:29:07 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.10 1997/06/25 18:29:07 kstailey Exp $";
d115 3
a117 3
	 addid __P((u_long, int, char *));
char	*blockcheck __P((char *));
void	 bread __P((daddr_t, char *, long));
d120 1
a120 1
void	 freeinodebuf __P((void));
d122 3
a124 3
	 getnextinode __P((ino_t));
int	 getquotagid __P((void));
int	 hasquota __P((struct fstab *, int, char **));
d126 6
a131 6
	 lookup __P((u_long, int));
void	*needchk __P((struct fstab *));
int	 oneof __P((char *, char*[], int));
void	 resetinodebuf __P((void));
int	 update __P((const char *, const char *, int));
void	 usage __P((void));
@


1.10
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.9 1997/01/22 00:37:15 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.9 1997/01/22 00:37:15 deraadt Exp $";
d138 3
a140 3
	register struct fstab *fs;
	register struct passwd *pw;
	register struct group *gr;
d226 1
a226 1
	register struct fstab *fs;
d228 1
a228 1
	register struct quotaname *qnp;
d267 3
a269 3
	register struct quotaname *qnp = auxarg;
	register struct fileusage *fup;
	register struct dinode *dp;
d362 1
a362 1
	register int type;
d364 3
a366 3
	register struct fileusage *fup;
	register FILE *qfi, *qfo;
	register u_long id, lastid;
d460 1
a460 1
	register char *target, *list[];
d463 1
a463 1
	register int i;
d489 1
a489 1
	register struct fstab *fs;
d493 1
a493 1
	register char *opt;
d536 1
a536 1
	register struct fileusage *fup;
@


1.9
log
@call err() correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.8 1997/01/03 16:22:10 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.8 1997/01/03 16:22:10 mickey Exp $";
d297 1
a297 1
						    GRPQUOTA, (char *)0);
d306 1
a306 1
						    USRQUOTA, (char *)0);
@


1.8
log
@make it work again, 'twas broken for a long time 'coze of ../fsck/preen.c
changes, that is yantc situation.
as a side effect it's parallelized too.
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.7 1996/06/23 14:32:05 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.7 1996/06/23 14:32:05 deraadt Exp $";
d280 1
a280 1
			err("%s", fsname);
@


1.7
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: quotacheck.c,v 1.12 1996/03/30 22:34:25 mark Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: quotacheck.c,v 1.12 1996/03/30 22:34:25 mark Exp $";
d59 1
d75 1
a107 1
int	aflag;			/* all file systems */
d110 1
a110 1
int	vflag;			/* verbose */
d118 2
a119 1
int	 chkquota __P((char *, char *, struct quotaname *));
d130 1
a130 1
int	 update __P((char *, char *, int));
d148 1
a148 1
	while ((ch = getopt(argc, argv, "aguvl:")) != -1) {
d151 4
a154 1
			aflag++;
d159 3
d166 1
a166 4
			vflag++;
			break;
		case 'l':
			maxrun = atoi(optarg);
d174 2
a175 1
	if ((argc == 0 && !aflag) || (argc > 0 && aflag))
d193 2
a194 2
	if (aflag)
		exit(checkfstab(1, maxrun, needchk, chkquota));
d203 2
a204 1
			errs += chkquota(name, fs->fs_file, auxdata);
d219 2
a220 2
		"quotacheck -a [-guv]",
		"quotacheck [-guv] filesys ...");
d231 2
d252 4
a255 2
	free(qnp);
	return (NULL);
d262 4
a265 3
chkquota(fsname, mntpt, qnp)
	char *fsname, *mntpt;
	register struct quotaname *qnp;
d267 1
d270 1
a270 1
	int cg, i, mode, errs = 0;
d272 1
d274 39
a312 34
	if ((fi = open(fsname, O_RDONLY, 0)) < 0) {
		perror(fsname);
		return (1);
	}
	if (vflag) {
		(void)printf("*** Checking ");
		if (qnp->flags & HASUSR)
			(void)printf("%s%s", qfextension[USRQUOTA],
			    (qnp->flags & HASGRP) ? " and " : "");
		if (qnp->flags & HASGRP)
			(void)printf("%s", qfextension[GRPQUOTA]);
		(void)printf(" quotas for %s (%s)\n", fsname, mntpt);
	}
	sync();
	dev_bsize = 1;
	bread(SBOFF, (char *)&sblock, (long)SBSIZE);
	dev_bsize = sblock.fs_fsize / fsbtodb(&sblock, 1);
	maxino = sblock.fs_ncg * sblock.fs_ipg;
	resetinodebuf();
	for (ino = 0, cg = 0; cg < sblock.fs_ncg; cg++) {
		for (i = 0; i < sblock.fs_ipg; i++, ino++) {
			if (ino < ROOTINO)
				continue;
			if ((dp = getnextinode(ino)) == NULL)
				continue;
			if ((mode = dp->di_mode & IFMT) == 0)
				continue;
			if (qnp->flags & HASGRP) {
				fup = addid((u_long)dp->di_gid, GRPQUOTA,
				    (char *)0);
				fup->fu_curinodes++;
				if (mode == IFREG || mode == IFDIR ||
				    mode == IFLNK)
					fup->fu_curblocks += dp->di_blocks;
d314 4
d319 3
a321 6
				fup = addid((u_long)dp->di_uid, USRQUOTA,
				    (char *)0);
				fup->fu_curinodes++;
				if (mode == IFREG || mode == IFDIR ||
				    mode == IFLNK)
					fup->fu_curblocks += dp->di_blocks;
d323 4
d328 24
d353 1
a353 7
	freeinodebuf();
	if (qnp->flags & HASUSR)
		errs += update(mntpt, qnp->usrqfname, USRQUOTA);
	if (qnp->flags & HASGRP)
		errs += update(mntpt, qnp->grpqfname, GRPQUOTA);
	close(fi);
	return (errs);
d361 1
a361 1
	char *fsname, *quotafile;
d372 4
a375 1
	if ((qfo = fopen(quotafile, "r+")) == NULL) {
d379 1
a379 2
			(void) fprintf(stderr,
			    "quotacheck: creating quota file %s\n", quotafile);
d384 1
a384 2
			(void) fprintf(stderr,
			    "quotacheck: %s: %s\n", quotafile, strerror(errno));
d389 1
a389 2
		(void) fprintf(stderr,
		    "quotacheck: %s: %s\n", quotafile, strerror(errno));
d394 2
a395 1
	    errno == EOPNOTSUPP && !warned && vflag) {
d412 2
a413 2
		if (vflag) {
			if (aflag)
d417 1
a417 1
				(void)printf("\tinodes %d -> %d",
d420 1
a420 1
				(void)printf("\tblocks %d -> %d",
d438 5
a442 3
		fwrite((char *)&dqbuf, sizeof(struct dqblk), 1, qfo);
		(void) quotactl(fsname, QCMD(Q_SETUSE, type), id,
		    (caddr_t)&dqbuf);
d448 3
a450 2
	ftruncate(fileno(qfo),
	    (off_t)((highid[type] + 1) * sizeof(struct dqblk)));
d479 1
a479 1
	if (gr = getgrnam(quotagroup))
d507 1
a507 1
		if (cp = strchr(opt, '='))
d556 1
a556 1
	if (fup = lookup(id, type))
d573 1
a573 1
		(void)sprintf(fup->fu_name, "%u", id);
d664 1
a664 1
		err(1, "block %ld", bno);
@


1.6
log
@permit quotas to work on mfs; problem reported by rdante@@pnet.net
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: quotacheck.c,v 1.12 1996/03/30 22:34:25 mark Exp $";
@


1.5
log
@sync to netbsd 960418
@
text
@d226 2
a227 1
	    strcmp(fs->fs_vfstype, "ufs"))
@


1.4
log
@accept either ffs or ufs for filesystem name
@
text
@d1 1
a1 1
/*	$NetBSD: quotacheck.c,v 1.10.2.1 1995/11/01 00:32:51 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: quotacheck.c,v 1.10.2.1 1995/11/01 00:32:51 jtc Exp $";
d141 2
a142 1
	char ch, *name;
d145 1
a145 1
	while ((ch = getopt(argc, argv, "aguvl:")) != EOF) {
@


1.3
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d222 4
a225 2
	if (strcmp(fs->fs_vfstype, "ffs") ||
	    strcmp(fs->fs_type, FSTAB_RW))
@


1.2
log
@ufs -> ffs
@
text
@d1 1
a1 1
/*	$NetBSD: quotacheck.c,v 1.10 1995/03/18 14:59:22 cgd Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: quotacheck.c,v 1.10 1995/03/18 14:59:22 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d222 1
a222 1
	if (strcmp(fs->fs_vfstype, "ufs") ||
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
