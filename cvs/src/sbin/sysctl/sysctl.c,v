head	1.225;
access;
symbols
	OPENBSD_6_0:1.215.0.2
	OPENBSD_6_0_BASE:1.215
	OPENBSD_5_9:1.211.0.2
	OPENBSD_5_9_BASE:1.211
	OPENBSD_5_8:1.211.0.4
	OPENBSD_5_8_BASE:1.211
	OPENBSD_5_7:1.210.0.2
	OPENBSD_5_7_BASE:1.210
	OPENBSD_5_6:1.202.0.4
	OPENBSD_5_6_BASE:1.202
	OPENBSD_5_5:1.199.0.4
	OPENBSD_5_5_BASE:1.199
	OPENBSD_5_4:1.194.0.2
	OPENBSD_5_4_BASE:1.194
	OPENBSD_5_3:1.184.0.2
	OPENBSD_5_3_BASE:1.184
	OPENBSD_5_2:1.183.0.2
	OPENBSD_5_2_BASE:1.183
	OPENBSD_5_1_BASE:1.182
	OPENBSD_5_1:1.182.0.2
	OPENBSD_5_0:1.177.0.2
	OPENBSD_5_0_BASE:1.177
	OPENBSD_4_9:1.174.0.2
	OPENBSD_4_9_BASE:1.174
	OPENBSD_4_8:1.172.0.2
	OPENBSD_4_8_BASE:1.172
	OPENBSD_4_7:1.167.0.2
	OPENBSD_4_7_BASE:1.167
	OPENBSD_4_6:1.161.0.4
	OPENBSD_4_6_BASE:1.161
	OPENBSD_4_5:1.160.0.4
	OPENBSD_4_5_BASE:1.160
	OPENBSD_4_4:1.160.0.2
	OPENBSD_4_4_BASE:1.160
	OPENBSD_4_3:1.155.0.2
	OPENBSD_4_3_BASE:1.155
	OPENBSD_4_2:1.149.0.2
	OPENBSD_4_2_BASE:1.149
	OPENBSD_4_1:1.146.0.2
	OPENBSD_4_1_BASE:1.146
	OPENBSD_4_0:1.141.0.2
	OPENBSD_4_0_BASE:1.141
	OPENBSD_3_9:1.133.0.2
	OPENBSD_3_9_BASE:1.133
	OPENBSD_3_8:1.128.0.2
	OPENBSD_3_8_BASE:1.128
	OPENBSD_3_7:1.117.0.2
	OPENBSD_3_7_BASE:1.117
	OPENBSD_3_6:1.115.0.2
	OPENBSD_3_6_BASE:1.115
	OPENBSD_3_5:1.112.0.2
	OPENBSD_3_5_BASE:1.112
	OPENBSD_3_4:1.98.0.2
	OPENBSD_3_4_BASE:1.98
	OPENBSD_3_3:1.86.0.2
	OPENBSD_3_3_BASE:1.86
	OPENBSD_3_2:1.84.0.2
	OPENBSD_3_2_BASE:1.84
	OPENBSD_3_1:1.79.0.2
	OPENBSD_3_1_BASE:1.79
	OPENBSD_3_0:1.76.0.2
	OPENBSD_3_0_BASE:1.76
	OPENBSD_2_9:1.60.0.2
	OPENBSD_2_9_BASE:1.60
	OPENBSD_2_8:1.53.0.2
	OPENBSD_2_8_BASE:1.53
	OPENBSD_2_7:1.49.0.2
	OPENBSD_2_7_BASE:1.49;
locks; strict;
comment	@ * @;


1.225
date	2017.03.16.10.05.47;	author mpi;	state Exp;
branches;
next	1.224;
commitid	VnKJ5iq4P8TBHC01;

1.224
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.223;
commitid	T2qzeepA7r1EGy1x;

1.223
date	2016.10.18.09.31.05;	author otto;	state Exp;
branches;
next	1.222;
commitid	MxZUsxMMkxDV8sME;

1.222
date	2016.10.09.06.20.25;	author otto;	state Exp;
branches;
next	1.221;
commitid	Ut8fxYWsWdosAuO6;

1.221
date	2016.09.21.14.06.49;	author deraadt;	state Exp;
branches;
next	1.220;
commitid	i8Lki9zW9tZfkC2H;

1.220
date	2016.09.02.11.11.48;	author deraadt;	state Exp;
branches;
next	1.219;
commitid	MAVRnQT48jqZaPFa;

1.219
date	2016.09.01.09.13.49;	author deraadt;	state Exp;
branches;
next	1.218;
commitid	WEdtftTF2GamxOJk;

1.218
date	2016.08.27.01.55.30;	author guenther;	state Exp;
branches;
next	1.217;
commitid	nMHwEPEA2Ox25Cu9;

1.217
date	2016.08.14.22.54.56;	author guenther;	state Exp;
branches;
next	1.216;
commitid	HETJpoNzHSNzn02x;

1.216
date	2016.07.27.14.44.59;	author tedu;	state Exp;
branches;
next	1.215;
commitid	XAdC1jj6KiTyzPFD;

1.215
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.214;
commitid	r16P5gVURcjZa76o;

1.214
date	2016.05.23.15.48.59;	author deraadt;	state Exp;
branches;
next	1.213;
commitid	u827DKK0c0dFAF72;

1.213
date	2016.05.04.19.48.08;	author jca;	state Exp;
branches;
next	1.212;
commitid	pjrI8Uv5D3MXA8k7;

1.212
date	2016.02.29.19.44.07;	author naddy;	state Exp;
branches;
next	1.211;
commitid	Tzte6JKABMyG38MY;

1.211
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.210;
commitid	6b2lLILbgCR1fvia;

1.210
date	2015.02.13.00.02.21;	author guenther;	state Exp;
branches;
next	1.209;
commitid	IJVKs6GRyE7jq0PQ;

1.209
date	2015.02.09.12.04.27;	author dlg;	state Exp;
branches;
next	1.208;
commitid	UJ02iYJWktCf5Nwe;

1.208
date	2015.01.16.06.40.01;	author deraadt;	state Exp;
branches;
next	1.207;
commitid	Uu5nFG3wCl0LACBb;

1.207
date	2014.11.19.18.04.54;	author tedu;	state Exp;
branches;
next	1.206;
commitid	DhpzIJGhCsFp0uYg;

1.206
date	2014.10.26.03.45.29;	author brad;	state Exp;
branches;
next	1.205;
commitid	6arLZ8DHdjnFiVip;

1.205
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.204;
commitid	RKMpGS78lskgSHj4;

1.204
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.203;
commitid	uuiU9j2I8AUx0fez;

1.203
date	2014.08.16.21.39.16;	author deraadt;	state Exp;
branches;
next	1.202;
commitid	AGFVw6ij1bhgJGwr;

1.202
date	2014.05.07.01.49.36;	author tedu;	state Exp;
branches;
next	1.201;

1.201
date	2014.05.07.01.41.18;	author tedu;	state Exp;
branches;
next	1.200;

1.200
date	2014.04.08.14.04.11;	author mpi;	state Exp;
branches;
next	1.199;

1.199
date	2014.01.23.03.00.04;	author guenther;	state Exp;
branches;
next	1.198;

1.198
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2013.11.15.22.20.04;	author millert;	state Exp;
branches;
next	1.196;

1.196
date	2013.11.12.19.42.47;	author deraadt;	state Exp;
branches;
next	1.195;

1.195
date	2013.10.22.16.40.28;	author guenther;	state Exp;
branches;
next	1.194;

1.194
date	2013.07.18.05.02.57;	author guenther;	state Exp;
branches;
next	1.193;

1.193
date	2013.07.18.03.26.48;	author guenther;	state Exp;
branches;
next	1.192;

1.192
date	2013.06.09.12.54.38;	author tedu;	state Exp;
branches;
next	1.191;

1.191
date	2013.06.09.12.37.43;	author tedu;	state Exp;
branches;
next	1.190;

1.190
date	2013.06.08.14.24.39;	author yasuoka;	state Exp;
branches;
next	1.189;

1.189
date	2013.04.16.22.06.48;	author deraadt;	state Exp;
branches;
next	1.188;

1.188
date	2013.04.15.16.47.14;	author guenther;	state Exp;
branches;
next	1.187;

1.187
date	2013.03.29.01.35.37;	author tedu;	state Exp;
branches;
next	1.186;

1.186
date	2013.03.29.01.29.16;	author tedu;	state Exp;
branches;
next	1.185;

1.185
date	2013.03.28.16.39.14;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2012.09.20.20.11.58;	author yuo;	state Exp;
branches;
next	1.183;

1.183
date	2012.04.12.12.33.04;	author deraadt;	state Exp;
branches;
next	1.182;

1.182
date	2012.01.19.09.44.16;	author chl;	state Exp;
branches;
next	1.181;

1.181
date	2012.01.15.16.00.50;	author dhill;	state Exp;
branches;
next	1.180;

1.180
date	2011.09.16.20.52.48;	author yuo;	state Exp;
branches;
next	1.179;

1.179
date	2011.09.16.16.41.55;	author yuo;	state Exp;
branches;
next	1.178;

1.178
date	2011.09.16.15.44.31;	author yuo;	state Exp;
branches;
next	1.177;

1.177
date	2011.07.08.18.30.17;	author yasuoka;	state Exp;
branches;
next	1.176;

1.176
date	2011.05.23.01.33.20;	author djm;	state Exp;
branches;
next	1.175;

1.175
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.174;

1.174
date	2010.11.02.10.24.34;	author dlg;	state Exp;
branches;
next	1.173;

1.173
date	2010.08.19.18.14.14;	author kettenis;	state Exp;
branches;
next	1.172;

1.172
date	2010.04.21.19.40.59;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2010.04.21.04.07.13;	author deraadt;	state Exp;
branches;
next	1.170;

1.170
date	2010.04.20.20.49.35;	author deraadt;	state Exp;
branches;
next	1.169;

1.169
date	2010.04.20.19.44.07;	author oga;	state Exp;
branches;
next	1.168;

1.168
date	2010.04.15.04.57.29;	author yuo;	state Exp;
branches;
next	1.167;

1.167
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.166;

1.166
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.165;

1.165
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.164;

1.164
date	2009.09.08.17.52.17;	author michele;	state Exp;
branches;
next	1.163;

1.163
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.162;

1.162
date	2009.08.12.12.26.51;	author kettenis;	state Exp;
branches;
next	1.161;

1.161
date	2009.06.07.03.07.19;	author millert;	state Exp;
branches;
next	1.160;

1.160
date	2008.08.04.04.26.42;	author miod;	state Exp;
branches;
next	1.159;

1.159
date	2008.07.12.12.04.10;	author thib;	state Exp;
branches;
next	1.158;

1.158
date	2008.07.09.20.20.46;	author djm;	state Exp;
branches;
next	1.157;

1.157
date	2008.04.28.11.52.53;	author norby;	state Exp;
branches;
next	1.156;

1.156
date	2008.03.14.19.19.57;	author sobrado;	state Exp;
branches;
next	1.155;

1.155
date	2008.02.09.15.10.58;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2007.12.14.18.34.26;	author deraadt;	state Exp;
branches;
next	1.153;

1.153
date	2007.12.13.20.29.03;	author reyk;	state Exp;
branches;
next	1.152;

1.152
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.151;

1.151
date	2007.11.26.13.36.33;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2007.11.11.15.48.35;	author jmc;	state Exp;
branches;
next	1.149;

1.149
date	2007.06.04.13.17.54;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2007.05.29.21.11.51;	author robert;	state Exp;
branches;
next	1.147;

1.147
date	2007.05.21.21.36.07;	author cnst;	state Exp;
branches;
next	1.146;

1.146
date	2007.02.20.00.02.56;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2007.01.06.00.23.52;	author deraadt;	state Exp;
branches;
next	1.144;

1.144
date	2006.12.26.11.52.30;	author mbalmer;	state Exp;
branches;
next	1.143;

1.143
date	2006.12.23.17.49.53;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2006.10.19.03.49.26;	author marco;	state Exp;
branches;
next	1.141;

1.141
date	2006.06.05.06.34.44;	author otto;	state Exp;
branches;
next	1.140;

1.140
date	2006.06.04.01.34.48;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2006.04.25.04.37.01;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2006.04.25.03.14.46;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2006.04.20.21.09.08;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2006.04.18.03.07.44;	author marco;	state Exp;
branches;
next	1.135;

1.135
date	2006.04.13.01.05.59;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2006.04.02.21.38.56;	author djm;	state Exp;
branches;
next	1.133;

1.133
date	2005.11.30.15.46.32;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2005.11.15.22.12.07;	author kettenis;	state Exp;
branches;
next	1.131;

1.131
date	2005.11.12.15.20.33;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2005.11.12.02.23.11;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2005.10.23.13.53.09;	author kettenis;	state Exp;
branches;
next	1.128;

1.128
date	2005.08.05.03.07.40;	author dlg;	state Exp;
branches;
next	1.127;

1.127
date	2005.08.04.16.00.06;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2005.08.04.13.00.44;	author jsg;	state Exp;
branches;
next	1.125;

1.125
date	2005.08.04.03.53.08;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2005.08.03.14.53.39;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2005.07.20.16.56.12;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.24.04.20.26;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2005.04.24.21.48.15;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2005.04.24.18.55.49;	author uwe;	state Exp;
branches;
next	1.119;

1.119
date	2005.04.20.23.40.12;	author beck;	state Exp;
branches;
next	1.118;

1.118
date	2005.04.13.04.02.06;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2005.01.28.15.39.14;	author millert;	state Exp;
branches;
next	1.116;

1.116
date	2004.09.14.22.09.38;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	1.113;

1.113
date	2004.04.15.00.23.17;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.21.01.46.42;	author tedu;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.25.08.39.02;	author jmc;	state Exp;
branches;
next	1.110;

1.110
date	2004.02.24.21.45.01;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2004.02.10.19.53.33;	author grange;	state Exp;
branches;
next	1.108;

1.108
date	2004.02.10.03.52.53;	author millert;	state Exp;
branches;
next	1.107;

1.107
date	2004.02.10.01.20.12;	author millert;	state Exp;
branches;
next	1.106;

1.106
date	2004.01.19.01.09.06;	author tedu;	state Exp;
branches;
next	1.105;

1.105
date	2004.01.11.22.19.18;	author grange;	state Exp;
branches;
next	1.104;

1.104
date	2004.01.11.21.56.31;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2004.01.11.21.54.27;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2004.01.09.02.46.04;	author millert;	state Exp;
branches;
next	1.101;

1.101
date	2004.01.05.15.26.18;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2003.10.17.21.04.57;	author mcbride;	state Exp;
branches;
next	1.99;

1.99
date	2003.09.26.16.09.27;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2003.09.09.11.55.05;	author jmc;	state Exp;
branches;
next	1.97;

1.97
date	2003.08.24.01.30.26;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.95;

1.95
date	2003.06.11.06.22.15;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.93;

1.93
date	2003.05.26.08.35.05;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2003.05.14.01.50.33;	author jfb;	state Exp;
branches;
next	1.91;

1.91
date	2003.05.06.19.30.14;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2003.05.06.19.27.47;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2003.04.25.20.32.18;	author grange;	state Exp;
branches;
next	1.88;

1.88
date	2003.04.25.20.27.19;	author grange;	state Exp;
branches;
next	1.87;

1.87
date	2003.04.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2003.01.21.16.59.23;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.84;

1.84
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.83;

1.83
date	2002.07.03.22.32.34;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.09.08.13.09;	author todd;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.09.04.49.19;	author angelos;	state Exp;
branches;
next	1.80;

1.80
date	2002.05.26.07.55.01;	author matthieu;	state Exp;
branches;
next	1.79;

1.79
date	2002.02.16.21.27.38;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2001.12.04.14.57.27;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2001.11.05.23.15.25;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.02.11.09.39;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2001.07.13.23.51.35;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.05.08.42.15;	author jjbg;	state Exp;
branches;
next	1.73;

1.73
date	2001.06.27.06.16.47;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.22.23.17.27;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.22.22.34.26;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.22.22.14.39;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.22.21.39.07;	author mickey;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.22.21.35.46;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.22.21.31.02;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.01.20.08.31;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.01.19.29.13;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.01.19.27.07;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.14.07.14.53;	author angelos;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.12.06.47.17;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.11.06.43.41;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.02.23.16.46.36;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2001.01.22.23.10.33;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2001.01.04.22.02.02;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.04.07.50.33;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.01.04.06.07.22;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2000.12.22.22.47.04;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2000.11.21.06.18.27;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2000.06.30.16.00.10;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2000.06.14.16.54.46;	author provos;	state Exp;
branches;
next	1.51;

1.51
date	2000.06.07.00.20.32;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.22.17.29.42;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.10.19.50.50;	author mickey;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2000.03.21.20.46.30;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2000.02.06.16.58.01;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2000.01.21.02.53.06;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2000.01.07.21.34.58;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	99.12.30.19.06.06;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	99.12.10.10.12.56;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	99.10.28.03.34.03;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	99.09.02.22.04.38;	author pjanzen;	state Exp;
branches;
next	1.40;

1.40
date	99.07.01.15.45.18;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	99.04.11.19.41.41;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	99.04.09.23.30.06;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	99.02.25.21.59.50;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.02.24.22.59.43;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	98.03.19.07.36.11;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.03.15.17.48.48;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.02.17.20.51.24;	author matthieu;	state Exp;
branches;
next	1.32;

1.32
date	97.10.25.21.46.06;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	97.10.25.08.23.38;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	97.10.22.23.40.35;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.10.15.19.30.55;	author kstailey;	state Exp;
branches;
next	1.28;

1.28
date	97.10.03.21.15.19;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.10.03.20.58.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.09.21.23.02.03;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.09.12.03.56.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.08.29.02.40.40;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.08.28.19.39.20;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.08.28.19.31.51;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.08.19.23.20.32;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.08.19.22.38.31;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.08.19.06.42.42;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.08.19.06.16.26;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.08.19.05.53.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.08.19.05.32.57;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.08.09.23.36.31;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.22.15.06.54;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.07.22.14.43.19;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.07.15.00.38.15;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	97.06.28.07.05.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.24.02.45.02;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.17.19.42.02;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.14.21.37.12;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.06.20.19.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.03.57.31;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.44.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.11.25.08.22.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.08.08.06.36.48;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.30.04.53.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.22;	author deraadt;	state Exp;
branches;
next	;

1.49.2.1
date	2000.10.06.20.40.28;	author jason;	state Exp;
branches;
next	;


desc
@@


1.225
log
@Fix a regression preventing ``kern.profiling'' to return the profiling
state even with a correct kernel.

Reported by jmc@@, ok tb@@
@
text
@/*	$OpenBSD: sysctl.c,v 1.224 2016/12/22 11:04:44 rzalamena Exp $	*/
/*	$NetBSD: sysctl.c,v 1.9 1995/09/30 07:12:50 thorpej Exp $	*/

/*
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/gmon.h>
#include <sys/mount.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/sysctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/uio.h>
#include <sys/tty.h>
#include <sys/namei.h>
#include <sys/sched.h>
#include <sys/sensors.h>
#include <sys/vmmeter.h>
#include <net/route.h>
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_ipip.h>
#include <netinet/ip_ether.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/icmp_var.h>
#include <netinet/igmp_var.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/ip_gre.h>
#include <netinet/ip_ipcomp.h>
#include <netinet/ip_carp.h>
#include <netinet/ip_divert.h>

#include <net/pfvar.h>
#include <net/if_pfsync.h>
#include <net/pipex.h>

#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/ip6_divert.h>

#include <netmpls/mpls.h>

#include <uvm/uvm_swap_encrypt.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ffs/ffs_extern.h>

#include <miscfs/fuse/fusefs.h>

#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <ddb/db_var.h>
#include <dev/rndvar.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <unistd.h>

#include <machine/cpu.h>

#ifdef CPU_BIOS
#include <machine/biosvar.h>
#endif

struct ctlname topname[] = CTL_NAMES;
struct ctlname kernname[] = CTL_KERN_NAMES;
struct ctlname vmname[] = CTL_VM_NAMES;
struct ctlname fsname[] = CTL_FS_NAMES;
struct ctlname netname[] = CTL_NET_NAMES;
struct ctlname hwname[] = CTL_HW_NAMES;
struct ctlname debugname[CTL_DEBUG_MAXID];
struct ctlname kernmallocname[] = CTL_KERN_MALLOC_NAMES;
struct ctlname forkstatname[] = CTL_KERN_FORKSTAT_NAMES;
struct ctlname nchstatsname[] = CTL_KERN_NCHSTATS_NAMES;
struct ctlname ttysname[] = CTL_KERN_TTY_NAMES;
struct ctlname semname[] = CTL_KERN_SEMINFO_NAMES;
struct ctlname shmname[] = CTL_KERN_SHMINFO_NAMES;
struct ctlname watchdogname[] = CTL_KERN_WATCHDOG_NAMES;
struct ctlname tcname[] = CTL_KERN_TIMECOUNTER_NAMES;
struct ctlname *vfsname;
#ifdef CTL_MACHDEP_NAMES
struct ctlname machdepname[] = CTL_MACHDEP_NAMES;
#endif
struct ctlname ddbname[] = CTL_DDB_NAMES;
char names[BUFSIZ];
int lastused;

/* Maximum size object to expect from sysctl(3) */
#define SYSCTL_BUFSIZ	8192

struct list {
	struct	ctlname *list;
	int	size;
};
struct list toplist = { topname, CTL_MAXID };
struct list secondlevel[] = {
	{ 0, 0 },			/* CTL_UNSPEC */
	{ kernname, KERN_MAXID },	/* CTL_KERN */
	{ vmname, VM_MAXID },		/* CTL_VM */
	{ fsname, FS_MAXID },		/* CTL_FS */
	{ netname, NET_MAXID },		/* CTL_NET */
	{ 0, CTL_DEBUG_MAXID },		/* CTL_DEBUG */
	{ hwname, HW_MAXID },		/* CTL_HW */
#ifdef CTL_MACHDEP_NAMES
	{ machdepname, CPU_MAXID },	/* CTL_MACHDEP */
#else
	{ 0, 0 },			/* CTL_MACHDEP */
#endif
	{ 0, 0 },			/* was CTL_USER */
	{ ddbname, DBCTL_MAXID },	/* CTL_DDB_NAMES */
	{ 0, 0 },			/* CTL_VFS */
};

int	Aflag, aflag, nflag, qflag;

/*
 * Variables requiring special processing.
 */
#define	CLOCK		0x00000001
#define	BOOTTIME	0x00000002
#define	CHRDEV		0x00000004
#define	BLKDEV		0x00000008
#define	BADDYNAMIC	0x00000020
#define	BIOSGEO		0x00000040
#define	BIOSDEV		0x00000080
#define	MAJ2DEV		0x00000100
#define	UNSIGNED	0x00000200
#define	KMEMBUCKETS	0x00000400
#define	LONGARRAY	0x00000800
#define	KMEMSTATS	0x00001000
#define	SENSORS		0x00002000
#define	SMALLBUF	0x00004000
#define	HEX		0x00008000

/* prototypes */
void debuginit(void);
void listall(char *, struct list *);
void parse(char *, int);
void parse_baddynamic(int *, size_t, char *, void **, size_t *, int, int);
void usage(void);
int findname(char *, char *, char **, struct list *);
int sysctl_inet(char *, char **, int *, int, int *);
int sysctl_inet6(char *, char **, int *, int, int *);
int sysctl_bpf(char *, char **, int *, int, int *);
int sysctl_mpls(char *, char **, int *, int, int *);
int sysctl_pipex(char *, char **, int *, int, int *);
int sysctl_fs(char *, char **, int *, int, int *);
static int sysctl_vfs(char *, char **, int[], int, int *);
static int sysctl_vfsgen(char *, char **, int[], int, int *);
int sysctl_bios(char *, char **, int *, int, int *);
int sysctl_swpenc(char *, char **, int *, int, int *);
int sysctl_forkstat(char *, char **, int *, int, int *);
int sysctl_tty(char *, char **, int *, int, int *);
int sysctl_nchstats(char *, char **, int *, int, int *);
int sysctl_malloc(char *, char **, int *, int, int *);
int sysctl_seminfo(char *, char **, int *, int, int *);
int sysctl_shminfo(char *, char **, int *, int, int *);
int sysctl_watchdog(char *, char **, int *, int, int *);
int sysctl_tc(char *, char **, int *, int, int *);
int sysctl_sensors(char *, char **, int *, int, int *);
void print_sensordev(char *, int *, u_int, struct sensordev *);
void print_sensor(struct sensor *);
#ifdef CPU_CHIPSET
int sysctl_chipset(char *, char **, int *, int, int *);
#endif
void vfsinit(void);

char *equ = "=";

int
main(int argc, char *argv[])
{
	int ch, lvl1;

	while ((ch = getopt(argc, argv, "Aanqw")) != -1) {
		switch (ch) {

		case 'A':
			Aflag = 1;
			break;

		case 'a':
			aflag = 1;
			break;

		case 'n':
			nflag = 1;
			break;

		case 'q':
			qflag = 1;
			break;

		case 'w':
			/* flag no longer needed; var=value implies write */
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0 || (Aflag || aflag)) {
		debuginit();
		vfsinit();
		for (lvl1 = 1; lvl1 < CTL_MAXID; lvl1++)
			listall(topname[lvl1].ctl_name, &secondlevel[lvl1]);
		return (0);
	}
	for (; *argv != NULL; ++argv)
		parse(*argv, 1);
	return (0);
}

/*
 * List all variables known to the system.
 */
void
listall(char *prefix, struct list *lp)
{
	char *cp, name[BUFSIZ];
	int lvl2, len;

	if (lp->list == NULL)
		return;
	if ((len = strlcpy(name, prefix, sizeof(name))) >= sizeof(name))
		errx(1, "%s: name too long", prefix);
	cp = name + len++;
	*cp++ = '.';
	for (lvl2 = 0; lvl2 < lp->size; lvl2++) {
		if (lp->list[lvl2].ctl_name == NULL)
			continue;
		if (strlcpy(cp, lp->list[lvl2].ctl_name,
		    sizeof(name) - len) >= sizeof(name) - len)
			warn("%s: name too long", lp->list[lvl2].ctl_name);
		parse(name, Aflag);
	}
}

/*
 * Parse a name into a MIB entry.
 * Lookup and print out the MIB entry if it exists.
 * Set a new value if requested.
 */
void
parse(char *string, int flags)
{
	int indx, type, state, intval, len;
	size_t size, newsize = 0;
	int lal = 0, special = 0;
	void *newval = NULL;
	int64_t quadval;
	struct list *lp;
	int mib[CTL_MAXNAME];
	char *cp, *bufp, buf[SYSCTL_BUFSIZ];

	(void)strlcpy(buf, string, sizeof(buf));
	bufp = buf;
	if ((cp = strchr(string, '=')) != NULL) {
		*strchr(buf, '=') = '\0';
		*cp++ = '\0';
		while (isspace((unsigned char)*cp))
			cp++;
		newval = cp;
		newsize = strlen(cp);
	}
	if ((indx = findname(string, "top", &bufp, &toplist)) == -1)
		return;
	mib[0] = indx;
	if (indx == CTL_VFS)
		vfsinit();
	if (indx == CTL_DEBUG)
		debuginit();
	lp = &secondlevel[indx];
	if (lp->list == 0) {
		warnx("%s: class is not implemented", topname[indx].ctl_name);
		return;
	}
	if (bufp == NULL) {
		listall(topname[indx].ctl_name, lp);
		return;
	}
	if ((indx = findname(string, "second", &bufp, lp)) == -1)
		return;
	mib[1] = indx;
	type = lp->list[indx].ctl_type;
	len = 2;
	switch (mib[0]) {

	case CTL_KERN:
		switch (mib[1]) {
		case KERN_PROF:
			mib[2] = GPROF_STATE;
			mib[3] = 0; /* Assume CPU ID 0 is always valid. */
			size = sizeof(state);
			if (sysctl(mib, 4, &state, &size, NULL, 0) == -1) {
				if (flags == 0)
					return;
				if (!nflag)
					(void)printf("%s: ", string);
				(void)puts("kernel is not compiled for profiling");
				return;
			}
			if (!nflag)
				(void)printf("%s = %s\n", string,
				    state == GMON_PROF_OFF ? "off" : "running");
			return;
		case KERN_FORKSTAT:
			sysctl_forkstat(string, &bufp, mib, flags, &type);
			return;
		case KERN_TTY:
			len = sysctl_tty(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		case KERN_NCHSTATS:
			sysctl_nchstats(string, &bufp, mib, flags, &type);
			return;
		case KERN_MALLOCSTATS:
			len = sysctl_malloc(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			if (mib[2] == KERN_MALLOC_BUCKET)
				special |= KMEMBUCKETS;
			if (mib[2] == KERN_MALLOC_KMEMSTATS)
				special |= KMEMSTATS;
			newsize = 0;
			break;
		case KERN_MBSTAT:
			if (flags == 0)
				return;
			warnx("use netstat to view %s", string);
			return;
		case KERN_MSGBUF:
			if (flags == 0)
				return;
			warnx("use dmesg to view %s", string);
			return;
		case KERN_PROC:
			if (flags == 0)
				return;
			warnx("use ps to view %s information", string);
			return;
		case KERN_CLOCKRATE:
			special |= CLOCK;
			break;
		case KERN_BOOTTIME:
			special |= BOOTTIME;
			break;
		case KERN_HOSTID:
			special |= UNSIGNED;
			special |= SMALLBUF;
			break;
		case KERN_CPTIME:
			special |= LONGARRAY;
			lal = CPUSTATES;
			break;
		case KERN_SEMINFO:
			len = sysctl_seminfo(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		case KERN_SHMINFO:
			len = sysctl_shminfo(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		case KERN_INTRCNT:
			if (flags == 0)
				return;
			warnx("use vmstat or systat to view %s information",
			    string);
			return;
		case KERN_WATCHDOG:
			len = sysctl_watchdog(string, &bufp, mib, flags,
			    &type);
			if (len < 0)
				return;
			break;
		case KERN_TIMECOUNTER:
			len = sysctl_tc(string, &bufp, mib, flags,
			    &type);
			if (len < 0)
				return;
			break;
		case KERN_FILE:
			if (flags == 0)
				return;
			warnx("use fstat to view %s information", string);
			return;
		case KERN_CONSDEV:
			special |= CHRDEV;
			break;
		case KERN_NETLIVELOCKS:
			special |= UNSIGNED;
			break;
		}
		break;

	case CTL_HW:
		switch (mib[1]) {
		case HW_DISKSTATS:
			/*
			 * Only complain if someone asks explicitly for this,
			 * otherwise "fail" silently.
			 */
			if (flags)
				warnx("use vmstat to view %s information",
				    string);
			return;
		case HW_SENSORS:
			special |= SENSORS;
			len = sysctl_sensors(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		case HW_PHYSMEM:
		case HW_USERMEM:
			/*
			 * Don't print these; we'll print the 64-bit
			 * variants instead.
			 */
			return;
		}
		break;

	case CTL_VM:
		if (mib[1] == VM_LOADAVG) {
			double loads[3];

			getloadavg(loads, 3);
			if (!nflag)
				(void)printf("%s%s", string, equ);
			(void)printf("%.2f %.2f %.2f\n", loads[0],
			    loads[1], loads[2]);
			return;
		} else if (mib[1] == VM_PSSTRINGS) {
			struct _ps_strings _ps;

			size = sizeof(_ps);
			if (sysctl(mib, 2, &_ps, &size, NULL, 0) == -1) {
				if (flags == 0)
					return;
				if (!nflag)
					(void)printf("%s: ", string);
				(void)puts("can't find ps strings");
				return;
			}
			if (!nflag)
				(void)printf("%s%s", string, equ);
			(void)printf("%p\n", _ps.val);
			return;
		} else if (mib[1] == VM_SWAPENCRYPT) {
			len = sysctl_swpenc(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;

			break;
		} else if (mib[1] == VM_NKMEMPAGES ||
		    mib[1] == VM_ANONMIN ||
		    mib[1] == VM_VTEXTMIN ||
		    mib[1] == VM_VNODEMIN) {
			break;
		}
		if (flags == 0)
			return;
		warnx("use vmstat or systat to view %s information", string);
		return;

		break;

	case CTL_NET:
		if (mib[1] == PF_INET) {
			len = sysctl_inet(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;

			if ((mib[2] == IPPROTO_IP && mib[3] == IPCTL_MRTSTATS) ||
			    (mib[2] == IPPROTO_IP && mib[3] == IPCTL_STATS) ||
			    (mib[2] == IPPROTO_IP && mib[3] == IPCTL_MRTMFC) ||
			    (mib[2] == IPPROTO_IP && mib[3] == IPCTL_MRTVIF) ||
			    (mib[2] == IPPROTO_TCP && mib[3] == TCPCTL_STATS) ||
			    (mib[2] == IPPROTO_UDP && mib[3] == UDPCTL_STATS) ||
			    (mib[2] == IPPROTO_ESP && mib[3] == ESPCTL_STATS) ||
			    (mib[2] == IPPROTO_AH && mib[3] == AHCTL_STATS) ||
			    (mib[2] == IPPROTO_IGMP && mib[3] == IGMPCTL_STATS) ||
			    (mib[2] == IPPROTO_ETHERIP && mib[3] == ETHERIPCTL_STATS) ||
			    (mib[2] == IPPROTO_IPIP && mib[3] == IPIPCTL_STATS) ||
			    (mib[2] == IPPROTO_IPCOMP && mib[3] == IPCOMPCTL_STATS) ||
			    (mib[2] == IPPROTO_ICMP && mib[3] == ICMPCTL_STATS) ||
			    (mib[2] == IPPROTO_CARP && mib[3] == CARPCTL_STATS) ||
			    (mib[2] == IPPROTO_PFSYNC && mib[3] == PFSYNCCTL_STATS) ||
			    (mib[2] == IPPROTO_DIVERT && mib[3] == DIVERTCTL_STATS)) {
				if (flags == 0)
					return;
				warnx("use netstat to view %s information",
				    string);
				return;
			} else if ((mib[2] == IPPROTO_TCP &&
			    (mib[3] == TCPCTL_BADDYNAMIC ||
			    mib[3] == TCPCTL_ROOTONLY)) ||
			    (mib[2] == IPPROTO_UDP &&
			    (mib[3] == UDPCTL_BADDYNAMIC ||
			    mib[3] == UDPCTL_ROOTONLY))) {

				special |= BADDYNAMIC;

				if (newval != NULL)
					parse_baddynamic(mib, len, string,
					    &newval, &newsize, flags, nflag);
			}
			break;
		}
		if (mib[1] == PF_INET6) {
			len = sysctl_inet6(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;

			if ((mib[2] == IPPROTO_IPV6 && mib[3] == IPV6CTL_MRTMFC) ||
			    (mib[2] == IPPROTO_IPV6 && mib[3] == IPV6CTL_MRTMIF) ||
			    (mib[2] == IPPROTO_DIVERT && mib[3] == DIVERT6CTL_STATS)) {
				if (flags == 0)
					return;
				warnx("use netstat to view %s information",
				    string);
				return;
			}
			break;
		}
		if (mib[1] == PF_BPF) {
			len = sysctl_bpf(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		}
		if (mib[1] == PF_MPLS) {
			len = sysctl_mpls(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		}
		if (mib[1] == PF_PIPEX) {
			len = sysctl_pipex(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		}
		if (flags == 0)
			return;
		warnx("use netstat to view %s information", string);
		return;

	case CTL_DEBUG:
		mib[2] = CTL_DEBUG_VALUE;
		len = 3;
		break;

	case CTL_MACHDEP:
#ifdef CPU_CONSDEV
		if (mib[1] == CPU_CONSDEV)
			special |= CHRDEV;
#endif
#ifdef CPU_CPUFEATURE
		if (mib[1] == CPU_CPUFEATURE)
			special |= HEX;
#endif
#ifdef CPU_BLK2CHR
		if (mib[1] == CPU_BLK2CHR) {
			if (bufp == NULL)
				return;
			mib[2] = makedev(atoi(bufp),0);
			bufp = NULL;
			len = 3;
			special |= CHRDEV;
			break;
		}
#endif
#ifdef CPU_CHR2BLK
		if (mib[1] == CPU_CHR2BLK) {
			if (bufp == NULL)
				return;
			mib[2] = makedev(atoi(bufp),0);
			bufp = NULL;
			len = 3;
			special |= BLKDEV;
			break;
		}
#endif
#ifdef CPU_BIOS
		if (mib[1] == CPU_BIOS) {
			len = sysctl_bios(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			if (mib[2] == BIOS_DEV)
				special |= BIOSDEV;
			if (mib[2] == BIOS_DISKINFO)
				special |= BIOSGEO;
			break;
		}
#endif
#ifdef CPU_CHIPSET
		if (mib[1] == CPU_CHIPSET) {
			len = sysctl_chipset(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			break;
		}
#endif
		break;

	case CTL_FS:
		len = sysctl_fs(string, &bufp, mib, flags, &type);
		if (len >= 0)
			break;
		return;

	case CTL_VFS:
		if (mib[1])
			len = sysctl_vfs(string, &bufp, mib, flags, &type);
		else
			len = sysctl_vfsgen(string, &bufp, mib, flags, &type);
		if (len >= 0) {
			if (type == CTLTYPE_STRUCT) {
				if (flags)
					warnx("use nfsstat to view %s information",
					    MOUNT_NFS);
				return;
			} else
				break;
		}
		return;

	case CTL_DDB:
		break;

	default:
		warnx("illegal top level value: %d", mib[0]);
		return;

	}
	if (bufp) {
		warnx("name %s in %s is unknown", bufp, string);
		return;
	}
	if (newsize > 0) {
		switch (type) {
		case CTLTYPE_INT:
			errno = 0;
			if (special & UNSIGNED)
				intval = strtoul(newval, &cp, 10);
			else
				intval = strtol(newval, &cp, 10);
			if (*cp != '\0') {
				warnx("%s: illegal value: %s", string,
				    (char *)newval);
				return;
			}
			if (errno == ERANGE) {
				warnx("%s: value %s out of range", string,
				    (char *)newval);
				return;
			}
			newval = &intval;
			newsize = sizeof(intval);
			break;

		case CTLTYPE_QUAD:
			(void)sscanf(newval, "%lld", &quadval);
			newval = &quadval;
			newsize = sizeof(quadval);
			break;
		}
	}
	size = (special & SMALLBUF) ? 512 : SYSCTL_BUFSIZ;
	if (sysctl(mib, len, buf, &size, newval, newsize) == -1) {
		if (flags == 0)
			return;
		switch (errno) {
		case EOPNOTSUPP:
			warnx("%s: value is not available", string);
			return;
		case ENOTDIR:
			warnx("%s: specification is incomplete", string);
			return;
		case ENOMEM:
			warnx("%s: type is unknown to this program", string);
			return;
		case ENXIO:
			if (special & BIOSGEO)
				return;
		default:
			warn("%s", string);
			return;
		}
	}
	if (special & KMEMBUCKETS) {
		struct kmembuckets *kb = (struct kmembuckets *)buf;
		if (!nflag)
			(void)printf("%s%s", string, equ);
		printf("(");
		printf("calls = %llu ", (long long)kb->kb_calls);
		printf("total_allocated = %llu ", (long long)kb->kb_total);
		printf("total_free = %lld ", (long long)kb->kb_totalfree);
		printf("elements = %lld ", (long long)kb->kb_elmpercl);
		printf("high watermark = %lld ", (long long)kb->kb_highwat);
		printf("could_free = %lld", (long long)kb->kb_couldfree);
		printf(")\n");
		return;
	}
	if (special & KMEMSTATS) {
		struct kmemstats *km = (struct kmemstats *)buf;
		int j, first = 1;

		if (!nflag)
			(void)printf("%s%s", string, equ);
		(void)printf("(inuse = %ld, calls = %ld, memuse = %ldK, "
		    "limblocks = %d, mapblocks = %d, maxused = %ldK, "
		    "limit = %ldK, spare = %ld, sizes = (",
		    km->ks_inuse, km->ks_calls,
		    (km->ks_memuse + 1023) / 1024, km->ks_limblocks,
		    km->ks_mapblocks, (km->ks_maxused + 1023) / 1024,
		    (km->ks_limit + 1023) / 1024, km->ks_spare);
		for (j = 1 << MINBUCKET; j < 1 << (MINBUCKET + 16); j <<= 1) {
			if ((km->ks_size & j ) == 0)
				continue;
			if (first)
				(void)printf("%d", j);
			else
				(void)printf(",%d", j);
			first = 0;
		}
		if (first)
			(void)printf("none");
		(void)printf("))\n");
		return;
	}
	if (special & CLOCK) {
		struct clockinfo *clkp = (struct clockinfo *)buf;

		if (!nflag)
			(void)printf("%s%s", string, equ);
		(void)printf(
		    "tick = %d, tickadj = %d, hz = %d, profhz = %d, stathz = %d\n",
		    clkp->tick, clkp->tickadj, clkp->hz, clkp->profhz, clkp->stathz);
		return;
	}
	if (special & BOOTTIME) {
		struct timeval *btp = (struct timeval *)buf;
		time_t boottime;

		if (!nflag) {
			boottime = btp->tv_sec;
			(void)printf("%s%s%s", string, equ, ctime(&boottime));
		} else
			(void)printf("%lld\n", (long long)btp->tv_sec);
		return;
	}
	if (special & BLKDEV) {
		dev_t dev = *(dev_t *)buf;

		if (!nflag)
			(void)printf("%s%s%s\n", string, equ,
			    devname(dev, S_IFBLK));
		else
			(void)printf("0x%x\n", dev);
		return;
	}
	if (special & CHRDEV) {
		dev_t dev = *(dev_t *)buf;

		if (!nflag)
			(void)printf("%s%s%s\n", string, equ,
			    devname(dev, S_IFCHR));
		else
			(void)printf("0x%x\n", dev);
		return;
	}
#ifdef CPU_BIOS
	if (special & BIOSGEO) {
		bios_diskinfo_t *pdi = (bios_diskinfo_t *)buf;

		if (!nflag)
			(void)printf("%s%s", string, equ);
		(void)printf("bootdev = 0x%x, "
		    "cylinders = %u, heads = %u, sectors = %u\n",
		    pdi->bsd_dev, pdi->bios_cylinders,
		    pdi->bios_heads, pdi->bios_sectors);
		return;
	}
	if (special & BIOSDEV) {
		int dev = *(int*)buf;

		if (!nflag)
			(void)printf("%s%s", string, equ);
		(void) printf("0x%02x\n", dev);
		return;
	}
#endif
	if (special & UNSIGNED) {
		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s%s", string, equ);
			(void)printf("%u\n", *(u_int *)buf);
		} else {
			if (!qflag) {
				if (!nflag)
					(void)printf("%s: %u -> ", string,
					    *(u_int *)buf);
				(void)printf("%u\n", *(u_int *)newval);
			}
		}
		return;
	}
	if (special & BADDYNAMIC) {
		u_int port, lastport;
		u_int32_t *baddynamic = (u_int32_t *)buf;

		if (!qflag) {
			if (!nflag)
				(void)printf("%s%s", string,
				    newsize ? ": " : equ);
			lastport = 0;
			for (port = 0; port < 65536; port++)
				if (DP_ISSET(baddynamic, port)) {
					(void)printf("%s%u",
					    lastport ? "," : "", port);
					lastport = port;
				}
			if (newsize != 0) {
				if (!nflag)
					fputs(" -> ", stdout);
				baddynamic = (u_int32_t *)newval;
				lastport = 0;
				for (port = 0; port < 65536; port++)
					if (DP_ISSET(baddynamic, port)) {
						(void)printf("%s%u",
						    lastport ? "," : "", port);
						lastport = port;
					}
			}
			(void)putchar('\n');
		}
		return;
	}
	if (special & LONGARRAY) {
		long *la = (long *)buf;
		if (!nflag)
			printf("%s%s", string, equ);
		while (lal--)
			printf("%ld%s", *la++, lal? ",":"");
		putchar('\n');
		return;
	}
	if (special & SENSORS) {
		struct sensor *s = (struct sensor *)buf;

		if (size > 0 && (s->flags & SENSOR_FINVALID) == 0) {
			if (!nflag)
				printf("%s%s", string, equ);
			print_sensor(s);
			printf("\n");
		}
		return;
	}
	switch (type) {
	case CTLTYPE_INT:
		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s%s", string, equ);
			if (special & HEX)
				(void)printf("0x%x\n", *(int *)buf);
			else
				(void)printf("%d\n", *(int *)buf);
		} else {
			if (!qflag) {
				if (!nflag)
					(void)printf("%s: %d -> ", string,
					    *(int *)buf);
				if (special & HEX)
					(void)printf("0x%x\n", *(int *)newval);
				else
					(void)printf("%d\n", *(int *)newval);
			}
		}
		return;

	case CTLTYPE_STRING:
		if (newval == NULL) {
			if (!nflag)
				(void)printf("%s%s", string, equ);
			(void)puts(buf);
		} else {
			if (!qflag) {
				if (!nflag)
					(void)printf("%s: %s -> ", string, buf);
				(void)puts((char *)newval);
			}
		}
		return;

	case CTLTYPE_QUAD:
		if (newsize == 0) {
			int64_t tmp;

			memcpy(&tmp, buf, sizeof tmp);
			if (!nflag)
				(void)printf("%s%s", string, equ);
			(void)printf("%lld\n", tmp);
		} else {
			int64_t tmp;

			memcpy(&tmp, buf, sizeof tmp);
			if (!qflag) {
				if (!nflag)
					(void)printf("%s: %lld -> ",
					    string, tmp);
				memcpy(&tmp, newval, sizeof tmp);
				(void)printf("%lld\n", tmp);
			}
		}
		return;

	case CTLTYPE_STRUCT:
		warnx("%s: unknown structure returned", string);
		return;

	default:
	case CTLTYPE_NODE:
		warnx("%s: unknown type returned", string);
		return;
	}
}

static void
parse_ports(char *portspec, int *port, int *high_port)
{
	char *dash;
	const char *errstr;

	if ((dash = strchr(portspec, '-')) != NULL)
		*dash++ = '\0';
	*port = strtonum(portspec, 0, 65535, &errstr);
	if (errstr != NULL)
		errx(1, "port is %s: %s", errstr, portspec);
	if (dash != NULL) {
		*high_port = strtonum(dash, 0, 65535, &errstr);
		if (errstr != NULL)
			errx(1, "high port is %s: %s", errstr, dash);
		if (*high_port < *port)
			errx(1, "high port %d is lower than %d",
			    *high_port, *port);
	} else
		*high_port = *port;
}

void
parse_baddynamic(int mib[], size_t len, char *string, void **newvalp,
    size_t *newsizep, int flags, int nflag)
{
	static u_int32_t newbaddynamic[DP_MAPSIZE];
	int port, high_port, baddynamic_loaded = 0, full_list_set = 0;
	size_t size;
	char action, *cp;

	while (*newvalp && (cp = strsep((char **)newvalp, ", \t")) && *cp) {
		if (*cp == '+' || *cp == '-') {
			if (full_list_set)
				errx(1, "cannot mix +/- with full list");
			action = *cp++;
			if (!baddynamic_loaded) {
				size = sizeof(newbaddynamic);
				if (sysctl(mib, len, newbaddynamic,
				    &size, 0, 0) == -1) {
					if (flags == 0)
						return;
					if (!nflag)
						printf("%s: ", string);
					puts("kernel does not contain bad "
					    "dynamic port tables");
					return;
				}
				baddynamic_loaded = 1;
			}
			parse_ports(cp, &port, &high_port);
			for (; port <= high_port; port++) {
				if (action == '+')
					DP_SET(newbaddynamic, port);
				else
					DP_CLR(newbaddynamic, port);
			}
		} else {
			if (baddynamic_loaded)
				errx(1, "cannot mix +/- with full list");
			if (!full_list_set) {
				bzero(newbaddynamic, sizeof(newbaddynamic));
				full_list_set = 1;
			}
			parse_ports(cp, &port, &high_port);
			for (; port <= high_port; port++)
				DP_SET(newbaddynamic, port);
		}
	}
	*newvalp = (void *)newbaddynamic;
	*newsizep = sizeof(newbaddynamic);
}

/*
 * Initialize the set of debugging names
 */
void
debuginit(void)
{
	int mib[3], loc, i;
	size_t size;

	if (secondlevel[CTL_DEBUG].list != 0)
		return;
	secondlevel[CTL_DEBUG].list = debugname;
	mib[0] = CTL_DEBUG;
	mib[2] = CTL_DEBUG_NAME;
	for (loc = lastused, i = 0; i < CTL_DEBUG_MAXID; i++) {
		mib[1] = i;
		size = BUFSIZ - loc;
		if (sysctl(mib, 3, &names[loc], &size, NULL, 0) == -1)
			continue;
		debugname[i].ctl_name = &names[loc];
		debugname[i].ctl_type = CTLTYPE_INT;
		loc += size;
	}
	lastused = loc;
}

struct ctlname vfsgennames[] = CTL_VFSGENCTL_NAMES;
struct ctlname ffsname[] = FFS_NAMES;
struct ctlname nfsname[] = FS_NFS_NAMES;
struct ctlname fusefsname[] = FUSEFS_NAMES;
struct list *vfsvars;
int *vfs_typenums;

/*
 * Initialize the set of filesystem names
 */
void
vfsinit(void)
{
	int mib[4], maxtypenum, cnt, loc, size;
	struct vfsconf vfc;
	size_t buflen;

	if (secondlevel[CTL_VFS].list != 0)
		return;
	mib[0] = CTL_VFS;
	mib[1] = VFS_GENERIC;
	mib[2] = VFS_MAXTYPENUM;
	buflen = 4;
	if (sysctl(mib, 3, &maxtypenum, &buflen, NULL, 0) < 0)
		return;
	/*
         * We need to do 0..maxtypenum so add one, and then we offset them
	 * all by (another) one by inserting VFS_GENERIC entries at zero
	 */
	maxtypenum += 2;
	if ((vfs_typenums = calloc(maxtypenum, sizeof(int))) == NULL)
		return;
	if ((vfsvars = calloc(maxtypenum, sizeof(*vfsvars))) == NULL) {
		free(vfs_typenums);
		return;
	}
	if ((vfsname = calloc(maxtypenum, sizeof(*vfsname))) == NULL) {
		free(vfs_typenums);
		free(vfsvars);
		return;
	}
	mib[2] = VFS_CONF;
	buflen = sizeof vfc;
	for (loc = lastused, cnt = 1; cnt < maxtypenum; cnt++) {
		mib[3] = cnt - 1;
		if (sysctl(mib, 4, &vfc, &buflen, NULL, 0) < 0) {
			if (errno == EOPNOTSUPP)
				continue;
			warn("vfsinit");
			free(vfsname);
			free(vfsvars);
			free(vfs_typenums);
			return;
		}
		if (!strcmp(vfc.vfc_name, MOUNT_FFS)) {
			vfsvars[cnt].list = ffsname;
			vfsvars[cnt].size = FFS_MAXID;
		}
		if (!strcmp(vfc.vfc_name, MOUNT_NFS)) {
			vfsvars[cnt].list = nfsname;
			vfsvars[cnt].size = NFS_MAXID;
		}
		if (!strcmp(vfc.vfc_name, MOUNT_FUSEFS)) {
			vfsvars[cnt].list = fusefsname;
			vfsvars[cnt].size = FUSEFS_MAXID;
		}
		vfs_typenums[cnt] = vfc.vfc_typenum;
		strlcat(&names[loc], vfc.vfc_name, sizeof names - loc);
		vfsname[cnt].ctl_name = &names[loc];
		vfsname[cnt].ctl_type = CTLTYPE_NODE;
		size = strlen(vfc.vfc_name) + 1;
		loc += size;
	}
	lastused = loc;

	vfsname[0].ctl_name = "mounts";
	vfsname[0].ctl_type = CTLTYPE_NODE;
	vfsvars[0].list = vfsname + 1;
	vfsvars[0].size = maxtypenum - 1;

	secondlevel[CTL_VFS].list = vfsname;
	secondlevel[CTL_VFS].size = maxtypenum;
	return;
}

int
sysctl_vfsgen(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx;
	size_t size;
	struct vfsconf vfc;

	if (*bufpp == NULL) {
		listall(string, vfsvars);
		return (-1);
	}

	if ((indx = findname(string, "third", bufpp, vfsvars)) == -1)
		return (-1);

	mib[1] = VFS_GENERIC;
	mib[2] = VFS_CONF;
	mib[3] = indx;
	size = sizeof vfc;
	if (sysctl(mib, 4, &vfc, &size, NULL, 0) < 0) {
		if (errno != EOPNOTSUPP)
			warn("vfs print");
		return -1;
	}
	if (flags == 0 && vfc.vfc_refcount == 0)
		return -1;
	if (!nflag)
		fprintf(stdout, "%s has %d mounted instance%s\n",
		    string, vfc.vfc_refcount,
		    vfc.vfc_refcount != 1 ? "s" : "");
	else
		fprintf(stdout, "%d\n", vfc.vfc_refcount);

	return -1;
}

int
sysctl_vfs(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	struct list *lp = &vfsvars[mib[1]];
	int indx;

	if (lp->list == NULL) {
		if (flags)
			warnx("No variables defined for file system %s", string);
		return (-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, lp)) == -1)
		return (-1);

	mib[1] = vfs_typenums[mib[1]];
	mib[2] = indx;
	*typep = lp->list[indx].ctl_type;
	return (3);
}

struct ctlname posixname[] = CTL_FS_POSIX_NAMES;
struct list fslist = { posixname, FS_POSIX_MAXID };

/*
 * handle file system requests
 */
int
sysctl_fs(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &fslist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &fslist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = fslist.list[indx].ctl_type;
	return (3);
}

#ifdef CPU_BIOS
struct ctlname biosname[] = CTL_BIOS_NAMES;
struct list bioslist = { biosname, BIOS_MAXID };

/*
 * handle BIOS requests
 */
int
sysctl_bios(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	char *name;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &bioslist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &bioslist)) == -1)
		return (-1);
	mib[2] = indx;
	if (indx == BIOS_DISKINFO) {
		const char *errstr;

		if (*bufpp == NULL) {
			char name[BUFSIZ];

			/* scan all the bios devices */
			for (indx = 0; indx < 256; indx++) {
				snprintf(name, sizeof(name), "%s.%u",
				    string, indx);
				parse(name, 1);
			}
			return (-1);
		}
		if ((name = strsep(bufpp, ".")) == NULL) {
			warnx("%s: incomplete specification", string);
			return (-1);
		}
		mib[3] = strtonum(name, 0, INT_MAX, &errstr);
		if (errstr) {
			warnx("%s: %s", string, errstr);
			return (-1);
		}
		*typep = CTLTYPE_STRUCT;
		return (4);
	} else {
		*typep = bioslist.list[indx].ctl_type;
		return (3);
	}
}
#endif

struct ctlname swpencname[] = CTL_SWPENC_NAMES;
struct list swpenclist = { swpencname, SWPENC_MAXID };

/*
 * handle swap encrypt requests
 */
int
sysctl_swpenc(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &swpenclist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &swpenclist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = swpenclist.list[indx].ctl_type;
	return (3);
}

struct ctlname inetname[] = CTL_IPPROTO_NAMES;
struct ctlname ipname[] = IPCTL_NAMES;
struct ctlname icmpname[] = ICMPCTL_NAMES;
struct ctlname igmpname[] = IGMPCTL_NAMES;
struct ctlname ipipname[] = IPIPCTL_NAMES;
struct ctlname tcpname[] = TCPCTL_NAMES;
struct ctlname udpname[] = UDPCTL_NAMES;
struct ctlname espname[] = ESPCTL_NAMES;
struct ctlname ahname[] = AHCTL_NAMES;
struct ctlname etheripname[] = ETHERIPCTL_NAMES;
struct ctlname grename[] = GRECTL_NAMES;
struct ctlname mobileipname[] = MOBILEIPCTL_NAMES;
struct ctlname ipcompname[] = IPCOMPCTL_NAMES;
struct ctlname carpname[] = CARPCTL_NAMES;
struct ctlname pfsyncname[] = PFSYNCCTL_NAMES;
struct ctlname divertname[] = DIVERTCTL_NAMES;
struct ctlname bpfname[] = CTL_NET_BPF_NAMES;
struct ctlname ifqname[] = CTL_IFQ_NAMES;
struct ctlname pipexname[] = PIPEXCTL_NAMES;
struct list inetlist = { inetname, IPPROTO_MAXID };
struct list inetvars[] = {
	{ ipname, IPCTL_MAXID },	/* ip */
	{ icmpname, ICMPCTL_MAXID },	/* icmp */
	{ igmpname, IGMPCTL_MAXID },	/* igmp */
	{ 0, 0 },			/* ggmp */
	{ ipipname, IPIPCTL_MAXID },	/* ipencap */
	{ 0, 0 },
	{ tcpname, TCPCTL_MAXID },	/* tcp */
	{ 0, 0 },
	{ 0, 0 },			/* egp */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },			/* pup */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ udpname, UDPCTL_MAXID },	/* udp */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ grename, GRECTL_MAXID },	/* gre */
	{ 0, 0 },
	{ 0, 0 },
	{ espname, ESPCTL_MAXID },	/* esp */
	{ ahname, AHCTL_MAXID },	/* ah */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ mobileipname, MOBILEIPCTL_MAXID }, /* mobileip */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ etheripname, ETHERIPCTL_MAXID },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ ipcompname, IPCOMPCTL_MAXID },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ carpname, CARPCTL_MAXID },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ pfsyncname, PFSYNCCTL_MAXID },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ divertname, DIVERTCTL_MAXID },
};
struct list bpflist = { bpfname, NET_BPF_MAXID };
struct list ifqlist = { ifqname, IFQCTL_MAXID };
struct list pipexlist = { pipexname, PIPEXCTL_MAXID };

struct list kernmalloclist = { kernmallocname, KERN_MALLOC_MAXID };
struct list forkstatlist = { forkstatname, KERN_FORKSTAT_MAXID };
struct list nchstatslist = { nchstatsname, KERN_NCHSTATS_MAXID };
struct list ttylist = { ttysname, KERN_TTY_MAXID };
struct list semlist = { semname, KERN_SEMINFO_MAXID };
struct list shmlist = { shmname, KERN_SHMINFO_MAXID };
struct list watchdoglist = { watchdogname, KERN_WATCHDOG_MAXID };
struct list tclist = { tcname, KERN_TIMECOUNTER_MAXID };

/*
 * handle vfs namei cache statistics
 */
int
sysctl_nchstats(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	static struct nchstats nch;
	int indx;
	size_t size;
	static int keepvalue = 0;

	if (*bufpp == NULL) {
		bzero(&nch, sizeof(struct nchstats));
		listall(string, &nchstatslist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &nchstatslist)) == -1)
		return (-1);
	mib[2] = indx;
	if (*bufpp != NULL) {
		warnx("fourth level name in %s is invalid", string);
		return (-1);
	}
	if (keepvalue == 0) {
		size = sizeof(struct nchstats);
		if (sysctl(mib, 2, &nch, &size, NULL, 0) < 0)
			return (-1);
		keepvalue = 1;
	}
	if (!nflag)
		(void)printf("%s%s", string, equ);
	switch (indx) {
	case KERN_NCHSTATS_GOODHITS:
		(void)printf("%llu\n", nch.ncs_goodhits);
		break;
	case KERN_NCHSTATS_NEGHITS:
		(void)printf("%llu\n", nch.ncs_neghits);
		break;
	case KERN_NCHSTATS_BADHITS:
		(void)printf("%llu\n", nch.ncs_badhits);
		break;
	case KERN_NCHSTATS_FALSEHITS:
		(void)printf("%llu\n", nch.ncs_falsehits);
		break;
	case KERN_NCHSTATS_MISS:
		(void)printf("%llu\n", nch.ncs_miss);
		break;
	case KERN_NCHSTATS_LONG:
		(void)printf("%llu\n", nch.ncs_long);
		break;
	case KERN_NCHSTATS_PASS2:
		(void)printf("%llu\n", nch.ncs_pass2);
		break;
	case KERN_NCHSTATS_2PASSES:
		(void)printf("%llu\n", nch.ncs_2passes);
		break;
	case KERN_NCHSTATS_REVHITS:
		(void)printf("%llu\n", nch.ncs_revhits);
		break;
	case KERN_NCHSTATS_REVMISS:
		(void)printf("%llu\n", nch.ncs_revmiss);
		break;
	case KERN_NCHSTATS_DOTHITS:
		(void)printf("%llu\n", nch.ncs_dothits);
		break;
	case KERN_NCHSTATS_DOTDOTHITS:
		(void)printf("%llu\n", nch.ncs_dotdothits);
		break;
	}
	return (-1);
}

/*
 * handle tty statistics
 */
int
sysctl_tty(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &ttylist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &ttylist)) == -1)
		return (-1);
	mib[2] = indx;

	if ((*typep = ttylist.list[indx].ctl_type) == CTLTYPE_STRUCT) {
		if (flags)
			warnx("use pstat -t to view %s information",
			    string);
		return (-1);
	}
	return (3);
}

/*
 * handle fork statistics
 */
int
sysctl_forkstat(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	static struct forkstat fks;
	static int keepvalue = 0;
	int indx;
	size_t size;

	if (*bufpp == NULL) {
		bzero(&fks, sizeof(struct forkstat));
		listall(string, &forkstatlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &forkstatlist)) == -1)
		return (-1);
	if (*bufpp != NULL) {
		warnx("fourth level name in %s is invalid", string);
		return (-1);
	}
	if (keepvalue == 0) {
		size = sizeof(struct forkstat);
		if (sysctl(mib, 2, &fks, &size, NULL, 0) < 0)
			return (-1);
		keepvalue = 1;
	}
	if (!nflag)
		(void)printf("%s%s", string, equ);
	switch (indx)	{
	case KERN_FORKSTAT_FORK:
		(void)printf("%u\n", fks.cntfork);
		break;
	case KERN_FORKSTAT_VFORK:
		(void)printf("%u\n", fks.cntvfork);
		break;
	case KERN_FORKSTAT_TFORK:
		(void)printf("%u\n", fks.cnttfork);
		break;
	case KERN_FORKSTAT_KTHREAD:
		(void)printf("%u\n", fks.cntkthread);
		break;
	case KERN_FORKSTAT_SIZFORK:
		(void)printf("%llu\n", fks.sizfork);
		break;
	case KERN_FORKSTAT_SIZVFORK:
		(void)printf("%llu\n", fks.sizvfork);
		break;
	case KERN_FORKSTAT_SIZTFORK:
		(void)printf("%llu\n", fks.siztfork);
		break;
	case KERN_FORKSTAT_SIZKTHREAD:
		(void)printf("%llu\n", fks.sizkthread);
		break;
	}
	return (-1);
}

/*
 * handle malloc statistics
 */
int
sysctl_malloc(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx, stor, i;
	char *name, bufp[SYSCTL_BUFSIZ], *buf, *ptr;
	const char *errstr;
	struct list lp;
	size_t size;

	if (*bufpp == NULL) {
		listall(string, &kernmalloclist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &kernmalloclist)) == -1)
		return (-1);
	mib[2] = indx;
	if (mib[2] == KERN_MALLOC_BUCKET) {
		if ((name = strsep(bufpp, ".")) == NULL) {
			size = SYSCTL_BUFSIZ;
			stor = mib[2];
			mib[2] = KERN_MALLOC_BUCKETS;
			buf = bufp;
			if (sysctl(mib, 3, buf, &size, NULL, 0) < 0)
				return (-1);
			mib[2] = stor;
			for (stor = 0, i = 0; i < size; i++)
				if (buf[i] == ',')
					stor++;
			lp.list = calloc(stor + 2, sizeof(struct ctlname));
			if (lp.list == NULL)
				return (-1);
			lp.size = stor + 2;
			for (i = 1; (ptr = strsep(&buf, ",")) != NULL; i++) {
			        lp.list[i].ctl_name = ptr;
				lp.list[i].ctl_type = CTLTYPE_STRUCT;
			}
			listall(string, &lp);
			free(lp.list);
			return (-1);
		}
		mib[3] = strtonum(name, 0, INT_MAX, &errstr);
		if (errstr)
			return -1;
		return (4);
	} else if (mib[2] == KERN_MALLOC_BUCKETS) {
		*typep = CTLTYPE_STRING;
		return (3);
	} else if (mib[2] == KERN_MALLOC_KMEMSTATS) {
		size = SYSCTL_BUFSIZ;
		stor = mib[2];
		mib[2] = KERN_MALLOC_KMEMNAMES;
		buf = bufp;
		if (sysctl(mib, 3, buf, &size, NULL, 0) < 0)
			return (-1);
		mib[2] = stor;
		if ((name = strsep(bufpp, ".")) == NULL) {
			for (stor = 0, i = 0; i < size; i++)
				if (buf[i] == ',')
					stor++;
			lp.list = calloc(stor + 2, sizeof(struct ctlname));
			if (lp.list == NULL)
				return (-1);
			lp.size = stor + 2;
			for (i = 1; (ptr = strsep(&buf, ",")) != NULL; i++) {
				if (ptr[0] == '\0') {
					i--;
					continue;
				}
			    	lp.list[i].ctl_name = ptr;
				lp.list[i].ctl_type = CTLTYPE_STRUCT;
			}
			listall(string, &lp);
			free(lp.list);
			return (-1);
		}
		ptr = strstr(buf, name);
 tryagain:
		if (ptr == NULL) {
			warnx("fourth level name %s in %s is invalid", name,
			    string);
			return (-1);
		}
		if ((*(ptr + strlen(name)) != ',') &&
		    (*(ptr + strlen(name)) != '\0')) {
			ptr = strstr(ptr + 1, name); /* retry */
			goto tryagain;
		}
		if ((ptr != buf) && (*(ptr - 1) != ',')) {
			ptr = strstr(ptr + 1, name); /* retry */
			goto tryagain;
		}
		for (i = 0, stor = 0; buf + i < ptr; i++)
			if (buf[i] == ',')
				stor++;
		mib[3] = stor;
		return (4);
	} else if (mib[2] == KERN_MALLOC_KMEMNAMES) {
		*typep = CTLTYPE_STRING;
		return (3);
	}
	return (-1);
}

#ifdef CPU_CHIPSET
/*
 * handle machdep.chipset requests
 */
struct ctlname chipsetname[] = CTL_CHIPSET_NAMES;
struct list chipsetlist = { chipsetname, CPU_CHIPSET_MAXID };

int
sysctl_chipset(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx, bwx;
	static void *q;
	size_t len;
	char *p;

	if (*bufpp == NULL) {
		listall(string, &chipsetlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &chipsetlist)) == -1)
		return (-1);
	mib[2] = indx;
	if (!nflag)
		printf("%s%s", string, equ);
	switch(mib[2]) {
	case CPU_CHIPSET_MEM:
	case CPU_CHIPSET_DENSE:
	case CPU_CHIPSET_PORTS:
	case CPU_CHIPSET_HAE_MASK:
		len = sizeof(void *);
		if (sysctl(mib, 3, &q, &len, NULL, 0) < 0)
			goto done;
		printf("%p", q);
		break;
	case CPU_CHIPSET_BWX:
		len = sizeof(int);
		if (sysctl(mib, 3, &bwx, &len, NULL, 0) < 0)
			goto done;
		printf("%d", bwx);
		break;
	case CPU_CHIPSET_TYPE:
		if (sysctl(mib, 3, NULL, &len, NULL, 0) < 0)
			goto done;
		p = malloc(len + 1);
		if (p == NULL)
			goto done;
		if (sysctl(mib, 3, p, &len, NULL, 0) < 0) {
			free(p);
			goto done;
		}
		p[len] = '\0';
		printf("%s", p);
		free(p);
		break;
	}
done:
	printf("\n");
	return (-1);
}
#endif
/*
 * handle internet requests
 */
int
sysctl_inet(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &inetlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &inetlist)) == -1)
		return (-1);
	mib[2] = indx;
	if (indx < IPPROTO_MAXID && inetvars[indx].list != NULL)
		lp = &inetvars[indx];
	else if (!flags)
		return (-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return (-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return (-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return (-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	if (*typep == CTLTYPE_NODE) {
		int tindx;

		if (*bufpp == NULL) {
			listall(string, &ifqlist);
			return(-1);
		}
		lp = &ifqlist;
		if ((tindx = findname(string, "fifth", bufpp, lp)) == -1)
			return (-1);
		mib[4] = tindx;
		*typep = lp->list[tindx].ctl_type;
		return(5);
	}
	return (4);
}

struct ctlname inet6name[] = CTL_IPV6PROTO_NAMES;
struct ctlname ip6name[] = IPV6CTL_NAMES;
struct ctlname icmp6name[] = ICMPV6CTL_NAMES;
struct ctlname divert6name[] = DIVERT6CTL_NAMES;
struct list inet6list = { inet6name, IPV6PROTO_MAXID };
struct list inet6vars[] = {
/*0*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
/*10*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*20*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*30*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*40*/	{ 0, 0 },
	{ ip6name, IPV6CTL_MAXID },	/* ipv6 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*50*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ icmp6name, ICMPV6CTL_MAXID },	/* icmp6 */
	{ 0, 0 },
/*60*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*70*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*80*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*90*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*100*/	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },	/* pim6 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
/*110*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*120*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*130*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*140*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*150*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*160*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*170*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*180*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*190*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*200*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*210*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*220*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*230*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*240*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*250*/	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ divert6name, DIVERT6CTL_MAXID },
};

/*
 * handle internet6 requests
 */
int
sysctl_inet6(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &inet6list);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &inet6list)) == -1)
		return (-1);
	mib[2] = indx;
	if (indx < IPV6PROTO_MAXID && inet6vars[indx].list != NULL)
		lp = &inet6vars[indx];
	else if (!flags)
		return (-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return (-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return (-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return (-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	if (*typep == CTLTYPE_NODE) {
		int tindx;

		if (*bufpp == NULL) {
			listall(string, &ifqlist);
			return(-1);
		}
		lp = &ifqlist;
		if ((tindx = findname(string, "fifth", bufpp, lp)) == -1)
			return (-1);
		mib[4] = tindx;
		*typep = lp->list[tindx].ctl_type;
		return(5);
	}
	return (4);
}

/* handle bpf requests */
int
sysctl_bpf(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &bpflist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &bpflist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = CTLTYPE_INT;
	return (3);
}

struct ctlname mplsname[] = MPLSCTL_NAMES;
struct list mplslist = { mplsname, MPLSCTL_MAXID };

/* handle MPLS requests */
int
sysctl_mpls(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &mplslist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &mplslist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = mplslist.list[indx].ctl_type;
	if (*typep == CTLTYPE_NODE) {
		int tindx;

		if (*bufpp == NULL) {
			listall(string, &ifqlist);
			return(-1);
		}
		lp = &ifqlist;
		if ((tindx = findname(string, "fourth", bufpp, lp)) == -1)
			return (-1);
		mib[3] = tindx;
		*typep = lp->list[tindx].ctl_type;
		return(4);
	}
	return (3);
}

/* handle PIPEX requests */
int
sysctl_pipex(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &pipexlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &pipexlist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = pipexlist.list[indx].ctl_type;
	if (*typep == CTLTYPE_NODE) {
		int tindx;

		if (*bufpp == NULL) {
			listall(string, &ifqlist);
			return(-1);
		}
		lp = &ifqlist;
		if ((tindx = findname(string, "fourth", bufpp, lp)) == -1)
			return (-1);
		mib[3] = tindx;
		*typep = lp->list[tindx].ctl_type;
		return(4);
	}
	return (3);
}

/*
 * Handle SysV semaphore info requests
 */
int
sysctl_seminfo(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &semlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &semlist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = CTLTYPE_INT;
	return (3);
}

/*
 * Handle SysV shared memory info requests
 */
int
sysctl_shminfo(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &shmlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &shmlist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = CTLTYPE_INT;
	return (3);
}

/*
 * Handle watchdog support
 */
int
sysctl_watchdog(char *string, char **bufpp, int mib[], int flags,
    int *typep)
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &watchdoglist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &watchdoglist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = watchdoglist.list[indx].ctl_type;
	return (3);
}

/*
 * Handle timecounter support
 */
int
sysctl_tc(char *string, char **bufpp, int mib[], int flags,
    int *typep)
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &tclist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &tclist)) == -1)
		return (-1);
	mib[2] = indx;
	*typep = tclist.list[indx].ctl_type;
	return (3);
}

/*
 * Handle hardware monitoring sensors support
 */
int
sysctl_sensors(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	char *devname, *typename;
	int dev, numt, i;
	enum sensor_type type;
	struct sensordev snsrdev;
	size_t sdlen = sizeof(snsrdev);

	if (*bufpp == NULL) {
		char buf[SYSCTL_BUFSIZ];

		/* scan all sensor devices */
		for (dev = 0; ; dev++) {
			mib[2] = dev;
			if (sysctl(mib, 3, &snsrdev, &sdlen, NULL, 0) == -1) {
				if (errno == ENXIO)
					continue;
				if (errno == ENOENT)
					break;
			}
			snprintf(buf, sizeof(buf), "%s.%s",
			    string, snsrdev.xname);
			print_sensordev(buf, mib, 3, &snsrdev);
		}
		return (-1);
	}

	/*
	 * If we get this far, it means that some arguments were
	 * provided below hw.sensors tree.
	 * The first branch of hw.sensors tree is the device name.
	 */
	if ((devname = strsep(bufpp, ".")) == NULL) {
		warnx("%s: incomplete specification", string);
		return (-1);
	}
	/* convert sensor device string to an integer */
	for (dev = 0; ; dev++) {
		mib[2] = dev;
		if (sysctl(mib, 3, &snsrdev, &sdlen, NULL, 0) == -1) {
			if (errno == ENXIO)
				continue;
			if (errno == ENOENT)
				break;
		}
		if (strcmp(devname, snsrdev.xname) == 0)
			break;
	}
	if (strcmp(devname, snsrdev.xname) != 0) {
		warnx("%s: sensor device not found: %s", string, devname);
		return (-1);
	}
	if (*bufpp == NULL) {
		/* only device name was provided -- let's print all sensors
		 * that are attached to the specified device
		 */
		print_sensordev(string, mib, 3, &snsrdev);
		return (-1);
	}

	/*
	 * At this point we have identified the sensor device,
	 * now let's go further and identify sensor type.
	 */
	if ((typename = strsep(bufpp, ".")) == NULL) {
		warnx("%s: incomplete specification", string);
		return (-1);
	}
	numt = -1;
	for (i = 0; typename[i] != '\0'; i++)
		if (isdigit((unsigned char)typename[i])) {
			const char *errstr;

			numt = strtonum(&typename[i], 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("%s: %s", string, errstr);
				return (-1);
			}
			typename[i] = '\0';
			break;
		}
	for (type = 0; type < SENSOR_MAX_TYPES; type++)
		if (strcmp(typename, sensor_type_s[type]) == 0)
			break;
	if (type == SENSOR_MAX_TYPES) {
		warnx("%s: sensor type not recognised: %s", string, typename);
		return (-1);
	}
	mib[3] = type;

	/*
	 * If no integer was provided after sensor_type, let's
	 * print all sensors of the specified type.
	 */
	if (numt == -1) {
		print_sensordev(string, mib, 4, &snsrdev);
		return (-1);
	}

	/*
	 * At this point we know that we have received a direct request
	 * via command-line for a specific sensor. Let's have the parse()
	 * function deal with it further, and report any errors if such
	 * sensor node does not exist.
	 */
	mib[4] = numt;
	*typep = CTLTYPE_STRUCT;
	return (5);
}

/*
 * Print sensors from the specified device.
 */

void
print_sensordev(char *string, int mib[], u_int mlen, struct sensordev *snsrdev)
{
	char buf[SYSCTL_BUFSIZ];
	enum sensor_type type;

	if (mlen == 3) {
		for (type = 0; type < SENSOR_MAX_TYPES; type++) {
			mib[3] = type;
			snprintf(buf, sizeof(buf), "%s.%s",
			    string, sensor_type_s[type]);
			print_sensordev(buf, mib, mlen+1, snsrdev);
		}
		return;
	}

	if (mlen == 4) {
		int numt;

		type = mib[3];
		for (numt = 0; numt < snsrdev->maxnumt[type]; numt++) {
			mib[4] = numt;
			snprintf(buf, sizeof(buf), "%s%u", string, numt);
			print_sensordev(buf, mib, mlen+1, snsrdev);
		}
		return;
	}

	if (mlen == 5) {
		struct sensor snsr;
		size_t slen = sizeof(snsr);

		/* this function is only printing sensors in bulk, so we
		 * do not return any error messages if the requested sensor
		 * is not found by sysctl(3)
		 */
		if (sysctl(mib, 5, &snsr, &slen, NULL, 0) == -1)
			return;

		if (slen > 0 && (snsr.flags & SENSOR_FINVALID) == 0) {
			if (!nflag)
				printf("%s%s", string, equ);
			print_sensor(&snsr);
			printf("\n");
		}
		return;
	}
}

void
print_sensor(struct sensor *s)
{
	const char *name;

	if (s->flags & SENSOR_FUNKNOWN)
		printf("unknown");
	else {
		switch (s->type) {
		case SENSOR_TEMP:
			printf("%.2f degC",
			    (s->value - 273150000) / 1000000.0);
			break;
		case SENSOR_FANRPM:
			printf("%lld RPM", s->value);
			break;
		case SENSOR_VOLTS_DC:
			printf("%.2f VDC", s->value / 1000000.0);
			break;
		case SENSOR_VOLTS_AC:
			printf("%.2f VAC", s->value / 1000000.0);
			break;
		case SENSOR_OHMS:
			printf("%lld ohm", s->value);
			break;
		case SENSOR_WATTS:
			printf("%.2f W", s->value / 1000000.0);
			break;
		case SENSOR_AMPS:
			printf("%.2f A", s->value / 1000000.0);
			break;
		case SENSOR_WATTHOUR:
			printf("%.2f Wh", s->value / 1000000.0);
			break;
		case SENSOR_AMPHOUR:
			printf("%.2f Ah", s->value / 1000000.0);
			break;
		case SENSOR_INDICATOR:
			printf("%s", s->value ? "On" : "Off");
			break;
		case SENSOR_INTEGER:
			printf("%lld", s->value);
			break;
		case SENSOR_PERCENT:
			printf("%.2f%%", s->value / 1000.0);
			break;
		case SENSOR_LUX:
			printf("%.2f lx", s->value / 1000000.0);
			break;
		case SENSOR_DRIVE:
			switch (s->value) {
			case SENSOR_DRIVE_EMPTY:
				name = "empty";
				break;
			case SENSOR_DRIVE_READY:
				name = "ready";
				break;
			case SENSOR_DRIVE_POWERUP:
				name = "powering up";
				break;
			case SENSOR_DRIVE_ONLINE:
				name = "online";
				break;
			case SENSOR_DRIVE_IDLE:
				name = "idle";
				break;
			case SENSOR_DRIVE_ACTIVE:
				name = "active";
				break;
			case SENSOR_DRIVE_REBUILD:
				name = "rebuilding";
				break;
			case SENSOR_DRIVE_POWERDOWN:
				name = "powering down";
				break;
			case SENSOR_DRIVE_FAIL:
				name = "failed";
				break;
			case SENSOR_DRIVE_PFAIL:
				name = "degraded";
				break;
			default:
				name = "unknown";
				break;
			}
			printf("%s", name);
			break;
		case SENSOR_TIMEDELTA:
			printf("%.6f secs", s->value / 1000000000.0);
			break;
		case SENSOR_HUMIDITY:
			printf("%.2f%%", s->value / 1000.0);
			break;
		case SENSOR_FREQ:
			printf("%.2f Hz", s->value / 1000000.0);
			break;
		case SENSOR_ANGLE:
			printf("%3.4f degrees", s->value / 1000000.0);
			break;
		case SENSOR_DISTANCE:
			printf("%.2f mm", s->value / 1000.0);
			break;
		case SENSOR_PRESSURE:
			printf("%.2f Pa", s->value / 1000.0);
			break;
		case SENSOR_ACCEL:
			printf("%2.4f m/s^2", s->value / 1000000.0);
			break;
		default:
			printf("unknown");
		}
	}

	if (s->desc[0] != '\0')
		printf(" (%s)", s->desc);

	switch (s->status) {
	case SENSOR_S_UNSPEC:
		break;
	case SENSOR_S_OK:
		printf(", OK");
		break;
	case SENSOR_S_WARN:
		printf(", WARNING");
		break;
	case SENSOR_S_CRIT:
		printf(", CRITICAL");
		break;
	case SENSOR_S_UNKNOWN:
		printf(", UNKNOWN");
		break;
	}

	if (s->tv.tv_sec) {
		time_t t = s->tv.tv_sec;
		char ct[26];

		ctime_r(&t, ct);
		ct[19] = '\0';
		printf(", %s.%03ld", ct, s->tv.tv_usec / 1000);
	}
}

/*
 * Scan a list of names searching for a particular name.
 */
int
findname(char *string, char *level, char **bufp, struct list *namelist)
{
	char *name;
	int i;

	if (namelist->list == 0 || (name = strsep(bufp, ".")) == NULL) {
		warnx("%s: incomplete specification", string);
		return (-1);
	}
	for (i = 0; i < namelist->size; i++)
		if (namelist->list[i].ctl_name != NULL &&
		    strcmp(name, namelist->list[i].ctl_name) == 0)
			break;
	if (i == namelist->size) {
		warnx("%s level name %s in %s is invalid", level, name, string);
		return (-1);
	}
	return (i);
}

void
usage(void)
{

	(void)fprintf(stderr,
	    "usage: sysctl [-Aan]\n"
	    "       sysctl [-n] name ...\n"
	    "       sysctl [-nq] name=value ...\n");
	exit(1);
}
@


1.224
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.223 2016/10/18 09:31:05 otto Exp $	*/
d343 1
d345 1
a345 1
			if (sysctl(mib, 3, &state, &size, NULL, 0) == -1) {
@


1.223
log
@Rewrite the kern.malloc.kmemstat in the same style as previous. This one does
not overflow because the initial count includes empty slots; ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.222 2016/10/09 06:20:25 otto Exp $	*/
a78 1
#include <netinet6/pim6_var.h>
d567 1
a567 2
			if ((mib[2] == IPPROTO_PIM && mib[3] == PIM6CTL_STATS) ||
			    (mib[2] == IPPROTO_IPV6 && mib[3] == IPV6CTL_MRTMFC) ||
a1989 1
struct ctlname pim6name[] = PIM6CTL_NAMES;
d2028 1
a2028 1
	{ pim6name, PIM6CTL_MAXID },	/* pim6 */
@


1.222
log
@fix heap overflow by rewriting loop; detected by new malloc canaries
ok krw@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.221 2016/09/21 14:06:49 deraadt Exp $	*/
d1840 2
a1841 4
			for (i = 1;
			    (lp.list[i].ctl_name = strsep(&buf, ",")) != NULL;
			    i++) {
				if (lp.list[i].ctl_name[0] == '\0') {
d1845 1
a1847 2
			lp.list[i].ctl_name = buf;
			lp.list[i].ctl_type = CTLTYPE_STRUCT;
@


1.221
log
@sysctl KERN_ARND is no longer used (in ports, it only occurs in fallback
paths of libevent).  This interface was the first generation of what
eventually became getentropy(2) and arc4random(3) -- june 1997!
Ports scan by sthen, general agreement guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.220 2016/09/02 11:11:48 deraadt Exp $	*/
d1809 2
a1810 3
			for (i = 1;
			    (lp.list[i].ctl_name = strsep(&buf, ",")) != NULL;
			    i++) {
a1812 2
			lp.list[i].ctl_name = buf;
			lp.list[i].ctl_type = CTLTYPE_STRUCT;
@


1.220
log
@for reporting changes, hex and decimal were swapped
noticed by pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.219 2016/09/01 09:13:49 deraadt Exp $	*/
a399 1
		case KERN_ARND:
@


1.219
log
@Export machdep.cpufeature in hex, to avoid - values which made
yuo@@ grumpy.
ok tom guenther yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.218 2016/08/27 01:55:30 guenther Exp $	*/
d931 2
a933 2
				else
					(void)printf("0x%x\n", *(int *)newval);
@


1.218
log
@Pull in <sys/time.h> for struct timespec

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.217 2016/08/14 22:54:56 guenther Exp $	*/
d181 1
d614 4
d921 4
a924 1
			(void)printf("%d\n", *(int *)buf);
d930 4
a933 1
				(void)printf("%d\n", *(int *)newval);
@


1.217
log
@Use int64_t and %ll for CTLTYPE_QUAD nodes.
Use memcpy() instead of up-casting from char* to long long*

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.216 2016/07/27 14:44:59 tedu Exp $	*/
d40 1
@


1.216
log
@increase the size of forkstat fields to accomodate large values
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.215 2016/06/18 10:36:13 vgross Exp $	*/
d713 1
a713 2
			/* XXX - assumes sizeof(long long) == sizeof(quad_t) */
			(void)sscanf(newval, "%lld", (long long *)&quadval);
d942 1
a942 1
			long long tmp = *(quad_t *)buf;
d944 1
d949 1
a949 1
			long long tmp = *(quad_t *)buf;
d951 1
d956 2
a957 2
				tmp = *(quad_t *)newval;
				(void)printf("%qd\n", tmp);
@


1.215
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.214 2016/05/23 15:48:59 deraadt Exp $	*/
d1735 1
a1735 1
		(void)printf("%d\n", fks.cntfork);
d1738 1
a1738 1
		(void)printf("%d\n", fks.cntvfork);
d1741 1
a1741 1
		(void)printf("%d\n", fks.cnttfork);
d1744 1
a1744 1
		(void)printf("%d\n", fks.cntkthread);
d1747 1
a1747 1
		(void)printf("%d\n", fks.sizfork);
d1750 1
a1750 1
		(void)printf("%d\n", fks.sizvfork);
d1753 1
a1753 1
		(void)printf("%d\n", fks.siztfork);
d1756 1
a1756 1
		(void)printf("%d\n", fks.sizkthread);
@


1.214
log
@remove the sysctl kern.random counters, since none of the remaining
ones are capable of giving valuable works vs does-not-work evidence.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.213 2016/05/04 19:48:08 jca Exp $	*/
d548 2
a549 1
			    mib[3] == TCPCTL_BADDYNAMIC) ||
d551 2
a552 1
			    mib[3] == UDPCTL_BADDYNAMIC)) {
@


1.213
log
@Kill #ifdef INET6 occurrences in userland.

Prompted by and ok millert@@

(tcpdump and libpcap left untouched, the #ifdef force is too strong with
those)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.212 2016/02/29 19:44:07 naddy Exp $	*/
a169 1
#define	RNDSTATS	0x00000010
a396 3
		case KERN_RND:
			special |= RNDSTATS;
			break;
a855 30
		return;
	}
	if (special & RNDSTATS) {
		struct rndstats *rndstats = (struct rndstats *)buf;
		int i;

		if (!nflag)
			(void)printf("%s%s", string, equ);
		printf("tot: %llu used: %llu read: %llu stirs: %llu"
		    " enqs: %llu deqs: %llu drops: %llu ledrops: %llu",
		    rndstats->rnd_total, rndstats->rnd_used,
		    rndstats->arc4_reads, rndstats->arc4_nstirs,
		    rndstats->rnd_enqs, rndstats->rnd_deqs,
		    rndstats->rnd_drops, rndstats->rnd_drople);
		printf(" ed:");
		for (i = 0;
		    i < sizeof(rndstats->rnd_ed)/sizeof(rndstats->rnd_ed[0]);
		    i++)
			printf(" %llu", (unsigned long long)rndstats->rnd_ed[i]);
		printf(" sc:");
		for (i = 0;
		    i < sizeof(rndstats->rnd_sc)/sizeof(rndstats->rnd_sc[0]);
		    i++)
			printf(" %llu", (unsigned long long)rndstats->rnd_sc[i]);
		printf(" sb:");
		for (i = 0;
		    i < sizeof(rndstats->rnd_sb)/sizeof(rndstats->rnd_sb[0]);
		    i++)
			printf(" %llu", (unsigned long long)rndstats->rnd_sb[i]);
		printf("\n");
@


1.212
log
@delete the kern.emul/KERN_EMUL sysctl bits since there are no
emulations left; ok millert@@ deraadt@@, jmc@@ (man pages)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.211 2015/04/18 18:28:37 deraadt Exp $	*/
a74 1
#ifdef INET6
a79 1
#endif
a189 1
#ifdef INET6
a190 1
#endif
a563 1
#ifdef INET6
a580 1
#endif
a2014 1
#ifdef INET6
a2150 1
#endif
@


1.211
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.210 2015/02/13 00:02:21 guenther Exp $	*/
a213 1
int sysctl_emul(char *, char *, int);
a441 3
		case KERN_EMUL:
			sysctl_emul(string, newval, flags);
			return;
a2639 177
}

struct emulname {
	char *name;
	int index;
} *emul_names;
int	emul_num, nemuls;
int	emul_init(void);

int
sysctl_emul(char *string, char *newval, int flags)
{
	int mib[4], enabled, i, old, print, found = 0;
	char *head, *target;
	size_t len;

	if (emul_init() == -1) {
		warnx("emul_init: out of memory");
		return (1);
	}

	mib[0] = CTL_KERN;
	mib[1] = KERN_EMUL;
	mib[3] = KERN_EMUL_ENABLED;
	head = "kern.emul.";

	if (aflag || strcmp(string, "kern.emul") == 0) {
		if (newval) {
			warnx("%s: specification is incomplete", string);
			return (1);
		}
		if (nflag)
			printf("%d\n", nemuls);
		else
			printf("%snemuls%s%d\n", head, equ, nemuls);
		for (i = 0; i < emul_num; i++) {
			if (emul_names[i].name == NULL)
				break;
			if (i > 0 && strcmp(emul_names[i].name,
			    emul_names[i-1].name) == 0)
				continue;
			mib[2] = emul_names[i].index;
			len = sizeof(int);
			if (sysctl(mib, 4, &enabled, &len, NULL, 0) == -1) {
				warn("%s", string);
				continue;
			}
			if (nflag)
				printf("%d\n", enabled);
			else
				printf("%s%s%s%d\n", head, emul_names[i].name,
				    equ, enabled);
		}
		return (0);
	}
	/* User specified a third level name */
	target = strrchr(string, '.');
	target++;
	if (strcmp(target, "nemuls") == 0) {
		if (newval) {
			warnx("Operation not permitted");
			return (1);
		}
		if (nflag)
			printf("%d\n", nemuls);
		else
			printf("%snemuls = %d\n", head, nemuls);
		return (0);
	}
	print = 1;
	for (i = 0; i < emul_num; i++) {
		if (!emul_names[i].name || (strcmp(target, emul_names[i].name)))
			continue;
		found = 1;
		mib[2] = emul_names[i].index;
		len = sizeof(int);
		if (newval) {
			const char *errstr;

			enabled = strtonum(newval, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("%s: %s is %s", string, newval, errstr);
				print = 0;
				continue;
			}
			if (sysctl(mib, 4, &old, &len, &enabled, len) == -1) {
				warn("%s", string);
				print = 0;
				continue;
			}
			if (print) {
				if (nflag)
					printf("%d\n", enabled);
				else
					printf("%s%s: %d -> %d\n", head,
					    target, old, enabled);
			}
		} else {
			if (sysctl(mib, 4, &enabled, &len, NULL, 0) == -1) {
				warn("%s", string);
				continue;
			}
			if (print) {
				if (nflag)
					printf("%d\n", enabled);
				else
					printf("%s%s = %d\n", head, target,
					    enabled);
			}
		}
		print = 0;
	}
	if (!found)
		warnx("third level name %s in kern.emul is invalid",
		    string);
	return (0);


}

static int
emulcmp(const void *m, const void *n)
{
	const struct emulname *a = m, *b = n;

	if (!a || !a->name)
		return 1;
	if (!b || !b->name)
		return -1;
	return (strcmp(a->name, b->name));
}

int
emul_init(void)
{
	static int done;
	char string[16];
	int mib[4], i;
	size_t len;

	if (done)
		return (0);
	done = 1;

	mib[0] = CTL_KERN;
	mib[1] = KERN_EMUL;
	mib[2] = KERN_EMUL_NUM;
	len = sizeof(int);
	if (sysctl(mib, 3, &emul_num, &len, NULL, 0) == -1)
		return (-1);

	emul_names = calloc(emul_num, sizeof(*emul_names));
	if (emul_names == NULL)
		return (-1);

	nemuls = emul_num;
	for (i = 0; i < emul_num; i++) {
		emul_names[i].index = mib[2] = i + 1;
		mib[3] = KERN_EMUL_NAME;
		len = sizeof(string);
		if (sysctl(mib, 4, string, &len, NULL, 0) == -1)
			continue;
		if (strcmp(string, "native") == 0)
			continue;
		emul_names[i].name = strdup(string);
		if (emul_names[i].name == NULL) {
			free(emul_names);
			return (-1);
		}
	}
	qsort(emul_names, nemuls, sizeof(*emul_names), emulcmp);
	for (i = 0; i < emul_num; i++) {
		if (!emul_names[i].name || (i > 0 &&
		    strcmp(emul_names[i].name, emul_names[i - 1].name) == 0))
			nemuls--;
	}
	return (0);
@


1.210
log
@Direct people to netstat for the new multicast routing sysctls.

problem noted by dcoppa@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.209 2015/02/09 12:04:27 dlg Exp $	*/
d105 1
d1301 2
d1318 5
a1322 1
		mib[3] = atoi(name);
d1812 1
d1850 3
a1852 1
		mib[3] = atoi(name);
d2411 7
a2417 1
			numt = atoi(&typename[i]);
d2721 8
a2728 1
			enabled = atoi(newval);
@


1.209
log
@provide a net.inet6.ip6.ifq sysctl so people can see and fiddle
with the ip6intrq.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.208 2015/01/16 06:40:01 deraadt Exp $	*/
d539 2
d578 2
@


1.208
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.207 2014/11/19 18:04:54 tedu Exp $	*/
d2132 14
@


1.207
log
@delete the KERN_VNODE sysctl. it fails to provide any isolation from the
kernel struct vnode defintion, and the only consumer (pstat) still needs
kvm to read much of the required information. no great loss to always use
kvm until there's a better replacement interface.
ok deraadt millert uebayasi
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.206 2014/10/26 03:45:29 brad Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.206
log
@Add a format specifier for the printf.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.205 2014/10/25 03:18:13 lteo Exp $	*/
a389 5
			return;
		case KERN_VNODE:
			if (flags == 0)
				return;
			warnx("use pstat to view %s information", string);
@


1.205
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.204 2014/09/15 19:08:21 miod Exp $	*/
d2559 1
a2559 1
			printf(name);
@


1.204
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.203 2014/08/16 21:39:16 deraadt Exp $	*/
a50 1
#include <netinet/in_systm.h>
@


1.203
log
@repair operation of kern.arandom, which will only allow a buffer of
512 bytes.  As a result, it stopped working...
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.202 2014/05/07 01:49:36 tedu Exp $	*/
a40 1
#include <sys/dkstat.h>
d44 1
@


1.202
log
@missing word in error message. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.201 2014/05/07 01:41:18 tedu Exp $	*/
d182 1
d414 1
d733 1
a733 1
	size = SYSCTL_BUFSIZ;
@


1.201
log
@delete some crusty casts
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.200 2014/04/08 14:04:11 mpi Exp $	*/
d1057 2
a1058 2
					puts("kernel does contain bad dynamic "
					    "port tables");
@


1.200
log
@Use VM_UVMEXP instead of VM_METER for memory usages and directly
include <sys/vmmeter.h> where it is needed instead of relying on
it being included by <uvm/uvm_extern.h>.

miod@@ likes it, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.199 2014/01/23 03:00:04 guenther Exp $	*/
d1135 1
a1135 1
	if (sysctl(mib, 3, &maxtypenum, &buflen, (void *)0, (size_t)0) < 0)
d1157 1
a1157 1
		if (sysctl(mib, 4, &vfc, &buflen, (void *)0, (size_t)0) < 0) {
d1216 1
a1216 1
	if (sysctl(mib, 4, &vfc, &size, (void *)0, (size_t)0) < 0) {
@


1.199
log
@kern.intrcnt is viewable with vmstat+systat
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.198 2013/11/22 04:12:48 deraadt Exp $	*/
d46 1
@


1.198
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.197 2013/11/15 22:20:04 millert Exp $	*/
d427 6
@


1.197
log
@Include unistd.h as it is the standard location for getopt().
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.196 2013/11/12 19:42:47 deraadt Exp $	*/
d314 1
a314 1
		while (isspace(*cp))
d2379 1
a2379 1
		if (isdigit(typename[i])) {
@


1.196
log
@satisfy proto requirement
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.195 2013/10/22 16:40:28 guenther Exp $	*/
d105 1
@


1.195
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.194 2013/07/18 05:02:57 guenther Exp $	*/
d2719 1
a2719 1
int
@


1.194
log
@Revert 1.191 and 1.193 and fix the original problem (access to the last
filesystem, currently ext2fs) by increasing maxtypenum sufficiently.

suggested by Rafael Neves (rafaelneves (at) gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.193 2013/07/18 03:26:48 guenther Exp $	*/
a389 1
		case KERN_FILE:
d441 1
a441 1
		case KERN_FILE2:
@


1.193
log
@Correct off-by-one in naming of nodes below vfs.mounts.

problem noted by Rafael Neves (rafaelneves (at) gmail.com)
ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.192 2013/06/09 12:54:38 tedu Exp $	*/
d1130 5
a1134 1
	maxtypenum++;	/* + generic (0) */
d1149 1
a1149 1
		mib[3] = cnt;
d1207 1
a1207 1
	mib[3] = indx + 1;
@


1.192
log
@add fuse sysctls, from Sylvestre Gallon
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.191 2013/06/09 12:37:43 tedu Exp $	*/
d1203 1
a1203 1
	mib[3] = indx;
@


1.191
log
@fix an off by one preventing access to the last filesystem.
from Sylvestre Gallon
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.190 2013/06/08 14:24:39 yasuoka Exp $	*/
d91 2
d1108 1
d1162 4
@


1.190
log
@Add new sysctl for pipex packet input/output queue length and
counters.

ok guenther, feedback jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.189 2013/04/16 22:06:48 deraadt Exp $	*/
d1127 1
a1127 1
	maxtypenum++;	/* + generic */
d1142 1
a1142 1
		mib[3] = cnt - 1;
@


1.189
log
@handle big time_t types; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.188 2013/04/15 16:47:14 guenther Exp $	*/
d2178 1
d2189 14
@


1.188
log
@Remove CTL_USER hierarchy from sysctl()
(Use sysconf() or confstr() instead)

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.187 2013/03/29 01:35:37 tedu Exp $	*/
d803 1
a803 1
			(void)printf("%ld\n", btp->tv_sec);
@


1.187
log
@remove some of the unused fields from rndstats and stop printing zeroes.
print labels before stats so people can tell what's what.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.186 2013/03/29 01:29:16 tedu Exp $	*/
a115 1
struct ctlname username[] = CTL_USER_NAMES;
d154 1
a154 1
	{ username, USER_MAXID },	/* CTL_USER_NAMES */
a679 1
	case CTL_USER:
@


1.186
log
@sadly, we are going to need machine/cpu.h here for a while to get machdep
noticed by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.185 2013/03/28 16:39:14 deraadt Exp $	*/
d870 9
a878 19
		(void)printf(
		"%llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
		    (unsigned long long)rndstats->rnd_total,
		    (unsigned long long)rndstats->rnd_used,
		    (unsigned long long)rndstats->rnd_reads,
		    (unsigned long long)rndstats->arc4_reads,
		    (unsigned long long)rndstats->arc4_nstirs,
		    (unsigned long long)rndstats->arc4_stirs,
		    (unsigned long long)rndstats->rnd_pad[0],
		    (unsigned long long)rndstats->rnd_pad[1],
		    (unsigned long long)rndstats->rnd_pad[2],
		    (unsigned long long)rndstats->rnd_pad[3],
		    (unsigned long long)rndstats->rnd_pad[4],
		    (unsigned long long)rndstats->rnd_waits,
		    (unsigned long long)rndstats->rnd_enqs,
		    (unsigned long long)rndstats->rnd_deqs,
		    (unsigned long long)rndstats->rnd_drops,
		    (unsigned long long)rndstats->rnd_drople);
		for (i = 0; i < sizeof(rndstats->rnd_ed)/sizeof(rndstats->rnd_ed[0]);
d880 4
a883 2
			(void)printf(" %llu", (unsigned long long)rndstats->rnd_ed[i]);
		for (i = 0; i < sizeof(rndstats->rnd_sc)/sizeof(rndstats->rnd_sc[0]);
d885 4
a888 2
			(void)printf(" %llu", (unsigned long long)rndstats->rnd_sc[i]);
		for (i = 0; i < sizeof(rndstats->rnd_sb)/sizeof(rndstats->rnd_sb[0]);
d890 1
a890 1
			(void)printf(" %llu", (unsigned long long)rndstats->rnd_sb[i]);
@


1.185
log
@remove excesss includes
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.184 2012/09/20 20:11:58 yuo Exp $	*/
d103 2
@


1.184
log
@add more sensor types to sensor framework.
 - Pressure (10^-3 Pa)
 - distance (10^-6 m)
 - acceleration (10^-6 m/s^2)

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.183 2012/04/12 12:33:04 deraadt Exp $	*/
a35 1
#include <sys/stat.h>
a45 1
#include <machine/cpu.h>
a88 1
#include <ufs/ffs/fs.h>
a90 1
#include <nfs/rpcv2.h>
@


1.183
log
@remove rfork(); ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.182 2012/01/19 09:44:16 chl Exp $	*/
d2548 9
@


1.182
log
@remove unused variable.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.181 2012/01/15 16:00:50 dhill Exp $	*/
d1767 2
a1768 2
	case KERN_FORKSTAT_RFORK:
		(void)printf("%d\n", fks.cntrfork);
d1779 2
a1780 2
	case KERN_FORKSTAT_SIZRFORK:
		(void)printf("%d\n", fks.sizrfork);
@


1.181
log
@add missing sysctl_pipex declaration

ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.180 2011/09/16 20:52:48 yuo Exp $	*/
a2187 1
	struct list *lp;
@


1.180
log
@reorder SENSOR_* in switch() and add missing cases.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.179 2011/09/16 16:41:55 yuo Exp $	*/
d195 1
@


1.179
log
@fix typo
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.178 2011/09/16 15:44:31 yuo Exp $	*/
d2466 3
d2472 2
a2473 2
		case SENSOR_VOLTS_DC:
			printf("%.2f VDC", s->value / 1000000.0);
@


1.178
log
@apply following changes to sensor framework:
- change accuracy of SENSOR_FREQ from Hz to muHz
- add SENSOR_VOLTS_AC entry to userland programs

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.177 2011/07/08 18:30:17 yasuoka Exp $	*/
d2467 1
a2467 1
			printf("%.2f ADC", s->value / 1000000.0);
@


1.177
log
@Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.176 2011/05/23 01:33:20 djm Exp $	*/
d2466 3
d2541 1
a2541 1
			printf("%lld Hz", s->value);
@


1.176
log
@allow ranges for entering net.inet.(tcp|udp).baddynamic lists, e.g.

sysctl net.inet.tcp.baddynamic=1-32768
sysctl net.inet.udp.baddynamic=+40000-65535

ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.175 2011/03/12 04:54:28 guenther Exp $	*/
d75 1
d595 6
d1356 1
d1621 1
d2180 18
@


1.175
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.174 2010/11/02 10:24:34 dlg Exp $	*/
d1006 22
d1033 1
a1033 1
	in_port_t port;
a1035 12
	const char *errstr;

	if (strchr((char *)*newvalp, '+') || strchr((char *)*newvalp, '-')) {
		size = sizeof(newbaddynamic);
		if (sysctl(mib, len, newbaddynamic, &size, 0, 0) == -1) {
			if (flags == 0)
				return;
			if (!nflag)
				(void)printf("%s: ", string);
			(void)puts("kernel does contain bad dynamic port tables");
			return;
		}
d1037 3
a1039 2
		while (*newvalp && (cp = strsep((char **)newvalp, ", \t")) && *cp) {
			if (*cp != '+' && *cp != '-')
d1042 30
a1071 4
			port = strtonum(cp, 0, 65535, &errstr);
			if (errstr != NULL)
				errx(1, "port is %s: %s", errstr, cp);
			if (action == '+')
a1072 10
			else
				DP_CLR(newbaddynamic, port);
		}
	} else {
		(void)memset((void *)newbaddynamic, 0, sizeof(newbaddynamic));
		while (*newvalp && (cp = strsep((char **)newvalp, ", \t")) && *cp) {
			port = strtonum(cp, 0, 65535, &errstr);
			if (errstr != NULL)
				errx(1, "port is %s: %s", errstr, cp);
			DP_SET(newbaddynamic, port);
a1074 1

@


1.174
log
@expose the kernels network livelock counter
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.173 2010/08/19 18:14:14 kettenis Exp $	*/
a394 1
		case KERN_PROC2:
@


1.173
log
@Introduce an MI kern.consdev sysctl that will replace the MD
machdep.console_device that's only implemented on a few architectures.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.172 2010/04/21 19:40:59 deraadt Exp $	*/
d449 3
@


1.172
log
@scale angle by 1000000 to permit min.sec accuracy
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.171 2010/04/21 04:07:13 deraadt Exp $	*/
d447 3
@


1.171
log
@Add the "angle" sensor, measured in degrees; from Luis Pinto
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.170 2010/04/20 20:49:35 deraadt Exp $	*/
d2483 1
a2483 1
			printf("%lld deg", s->value);
@


1.170
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.169 2010/04/20 19:44:07 oga Exp $	*/
d2481 3
@


1.169
log
@Add "frequency" type for sensors. (and teach userland how to print that
type).  Measured in Hz.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.168 2010/04/15 04:57:29 yuo Exp $	*/
d2247 1
a2247 1
		for (dev = 0; dev < MAXSENSORDEVICES; dev++) {
d2249 6
a2254 2
			if (sysctl(mib, 3, &snsrdev, &sdlen, NULL, 0) == -1)
				continue;
d2272 1
a2272 1
	for (dev = 0; dev < MAXSENSORDEVICES; dev++) {
d2274 6
a2279 2
		if (sysctl(mib, 3, &snsrdev, &sdlen, NULL, 0) == -1)
			continue;
@


1.168
log
@add SENSOR_HUMIDITY to sensor framework to handle humidity values

ok kettenis@@ xsa@@ sobrado@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.167 2009/11/05 20:50:14 michele Exp $	*/
d2470 3
@


1.167
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.166 2009/10/27 23:59:34 deraadt Exp $	*/
d2467 3
@


1.166
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.165 2009/10/04 16:08:37 michele Exp $	*/
d81 1
d566 2
a567 1
			if ((mib[2] == IPPROTO_PIM && mib[3] == PIM6CTL_STATS)) {
d1971 1
d2010 43
@


1.165
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.164 2009/09/08 17:52:17 michele Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)sysctl.c	8.5 (Berkeley) 5/9/95";
#else
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.164 2009/09/08 17:52:17 michele Exp $";
#endif
#endif /* not lint */
@


1.164
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.162 2009/08/12 12:26:51 kettenis Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.162 2009/08/12 12:26:51 kettenis Exp $";
d85 1
d553 2
a554 1
			    (mib[2] == IPPROTO_PFSYNC && mib[3] == PFSYNCCTL_STATS)) {
d1327 1
d1582 9
@


1.163
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@a84 1
#include <netinet/ip_divert.h>
a1324 1
struct ctlname divertname[] = DIVERTCTL_NAMES;
d1570 1
a1570 1
	{ divertname, DIVERTCTL_MAXID },
@


1.162
log
@Add support for SENSOR_WATTS.

ok deraadt@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.161 2009/06/07 03:07:19 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.161 2009/06/07 03:07:19 millert Exp $";
d85 1
d1326 1
d1572 1
a1572 1
	{ 0, 0 },
@


1.161
log
@Add KERN_FILE2 sysctl analogous to KERN_PROC2 but for file structures,
along with vnode type-specific info to make it more useful for fstat(1).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.160 2008/08/04 04:26:42 miod Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.160 2008/08/04 04:26:42 miod Exp $";
d2358 3
@


1.160
log
@Properly output machdep.chipset values on alpha models without pci buses;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.159 2008/07/12 12:04:10 thib Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.159 2008/07/12 12:04:10 thib Exp $";
d453 5
@


1.159
log
@
fix printing of nchstats

ok art@@,dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.158 2008/07/09 20:20:46 djm Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.158 2008/07/09 20:20:46 djm Exp $";
d1883 2
a1884 2
			return (-1);
		printf("%p\n", q);
d1889 2
a1890 2
			return (-1);
		printf("%d\n", bwx);
d1894 1
a1894 1
			return (-1);
d1897 1
a1897 1
			return (-1);
d1900 1
a1900 1
			return (-1);
d1903 1
a1903 1
		printf("%s\n", p);
d1907 2
@


1.158
log
@expand the net.inet.(tcp|udp).baddynamic dynamic source port
skipping bitmasks to cover the entire 65536 port space - previously
they covered 512-1024 only.

sysctl needs to be updated to cope with this change; please
"make includes" before rebuilding it.

feedback millert@@ ok millert@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.157 2008/04/28 11:52:53 norby Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.157 2008/04/28 11:52:53 norby Exp $";
d1620 1
a1620 1
		(void)printf("%ld\n", nch.ncs_goodhits);
d1623 1
a1623 1
		(void)printf("%ld\n", nch.ncs_neghits);
d1626 1
a1626 1
		(void)printf("%ld\n", nch.ncs_badhits);
d1629 1
a1629 1
		(void)printf("%ld\n", nch.ncs_falsehits);
d1632 1
a1632 1
		(void)printf("%ld\n", nch.ncs_miss);
d1635 1
a1635 1
		(void)printf("%ld\n", nch.ncs_long);
d1638 1
a1638 1
		(void)printf("%ld\n", nch.ncs_pass2);
d1641 1
a1641 1
		(void)printf("%ld\n", nch.ncs_2passes);
d1644 1
a1644 1
		(void)printf("%ld\n", nch.ncs_revhits);
d1647 7
a1653 1
		(void)printf("%ld\n", nch.ncs_revmiss);
@


1.157
log
@Teach sysctl about mpls.

Claudio did all the code, I'm just comitting it...

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.156 2008/03/14 19:19:57 sobrado Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.156 2008/03/14 19:19:57 sobrado Exp $";
d147 3
d317 1
a317 1
	char *cp, *bufp, buf[BUFSIZ];
d718 1
a718 1
	size = BUFSIZ;
d895 1
a895 1
		in_port_t port, lastport;
d903 1
a903 2
			for (port = IPPORT_RESERVED/2; port < IPPORT_RESERVED;
			    port++)
d905 1
a905 1
					(void)printf("%s%hd",
d914 1
a914 2
				for (port = IPPORT_RESERVED/2;
				    port < IPPORT_RESERVED; port++)
d916 1
a916 1
						(void)printf("%s%hd",
d1014 1
d1031 3
a1033 4
			port = atoi(cp);
			if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
				errx(1, "invalid port, range is %d to %d",
				    IPPORT_RESERVED/2, IPPORT_RESERVED-1);
d1042 3
a1044 4
			port = atoi(cp);
			if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
				errx(1, "invalid port, range is %d to %d",
				    IPPORT_RESERVED/2, IPPORT_RESERVED-1);
d1744 1
a1744 1
	char *name, bufp[BUFSIZ], *buf, *ptr;
d1757 1
a1757 1
			size = BUFSIZ;
d1788 1
a1788 1
		size = BUFSIZ;
d2187 1
a2187 1
		char buf[BUFSIZ];
d2281 1
a2281 1
	char buf[BUFSIZ];
@


1.156
log
@"-Aa" are not required flags; sort synopses; improve description of "-a"

written with invaluable advice from jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.155 2008/02/09 15:10:58 kettenis Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.155 2008/02/09 15:10:58 kettenis Exp $";
d96 2
d202 1
d585 6
d2048 35
@


1.155
log
@Introduce HW_PHYSMEM64 and HW_USERMEM64 sysctls, which don't overflow on
machines with more than 4GB of memory.  Make sysctl(8) print values obtained
using these sysctls for hw.physmem and hw.usermem.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.154 2007/12/14 18:34:26 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.154 2007/12/14 18:34:26 deraadt Exp $";
d2597 4
a2600 3
	(void)fprintf(stderr, "usage:\t%s\n\t%s\n\t%s\n",
	    "sysctl [-n] name ...", "sysctl [-nq] name=value ...",
	    "sysctl [-Aan]");
@


1.154
log
@Bring in probing for protocols that was missing; ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.153 2007/12/13 20:29:03 reyk Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.153 2007/12/13 20:29:03 reyk Exp $";
d470 5
a474 2
			special |= UNSIGNED;
			break;
@


1.153
log
@the mib[] array will be modified by sysctl_inet, move the *CTL_STATS
checks after the call for this function. now it works (again) to skip
printing the ip/tcp/udp/icmp stats in sysctl output, use netstat instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.152 2007/12/13 20:00:53 reyk Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.152 2007/12/13 20:00:53 reyk Exp $";
d75 1
d86 3
d526 2
a527 1
			if ((mib[2] == IPPROTO_IP && mib[3] == IPCTL_STATS) ||
d530 9
a538 2
			    (mib[2] == IPPROTO_ICMP &&
			    mib[3] == ICMPCTL_STATS)) {
d563 7
d1296 1
d1307 1
d1314 1
a1314 1
	{ 0, 0 },			/* igmp */
d1359 1
a1359 1
	{ grename, GRECTL_MAXID }, /* GRE */
d1425 137
@


1.152
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.151 2007/11/26 13:36:33 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.151 2007/11/26 13:36:33 deraadt Exp $";
a516 12
		if (mib[1] == PF_INET &&
		    ((mib[2] == IPPROTO_IP && mib[3] == IPCTL_STATS) ||
		    (mib[2] == IPPROTO_TCP && mib[3] == TCPCTL_STATS) ||
		    (mib[2] == IPPROTO_UDP && mib[3] == UDPCTL_STATS) ||
		    (mib[2] == IPPROTO_ICMP && mib[3] == ICMPCTL_STATS))) {
			if (flags == 0)
				return;
			warnx("use netstat to view %s information",
			    string);
			return;
		}

d522 11
a532 1
			if ((mib[2] == IPPROTO_TCP &&
@


1.151
log
@if no arguments given, assume a nice default; ok miod jakemsr deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.150 2007/11/11 15:48:35 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.150 2007/11/11 15:48:35 jmc Exp $";
d517 12
@


1.150
log
@do not document -w: it is for compat only. just like we did for audioctl,
mixerctl, and wsconsctl.

also move to "name=value", as for the other *ctl apps.

problem spotted by Tim van der Molen, though this might not be the fix
he wanted;
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.149 2007/06/04 13:17:54 henning Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.149 2007/06/04 13:17:54 henning Exp $";
d255 1
a255 1
	if (argc == 0 && (Aflag || aflag)) {
a261 2
	if (argc == 0)
		usage();
d2428 1
a2428 1
	    "sysctl [-n] -Aa");
@


1.149
log
@no more ipx
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.148 2007/05/29 21:11:51 robert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.148 2007/05/29 21:11:51 robert Exp $";
d2429 1
a2429 1
	    "sysctl [-n] variable ...", "sysctl [-nqw] variable=value ...",
@


1.148
log
@remove the ztsscale sysctl; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.147 2007/05/21 21:36:07 cnst Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.147 2007/05/21 21:36:07 cnst Exp $";
a102 3
#include <netipx/ipx.h>
#include <netipx/ipx_var.h>
#include <netipx/spx_var.h>
a195 1
int sysctl_ipx(char *, char **, int *, int, int *);
a545 6
		if (mib[1] == PF_IPX) {
			len = sysctl_ipx(string, &bufp, mib, flags, &type);
			if (len >= 0)
				break;
			return;
		}
a1854 48

struct ctlname ipxname[] = CTL_IPXPROTO_NAMES;
struct ctlname ipxpname[] = IPXCTL_NAMES;
struct ctlname spxpname[] = SPXCTL_NAMES;
struct list ipxlist = { ipxname, IPXCTL_MAXID };
struct list ipxvars[] = {
	{ ipxpname, IPXCTL_MAXID },	/* ipx */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ spxpname, SPXCTL_MAXID },
};

/*
 * Handle internet requests
 */
int
sysctl_ipx(char *string, char **bufpp, int mib[], int flags, int *typep)
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &ipxlist);
		return (-1);
	}
	if ((indx = findname(string, "third", bufpp, &ipxlist)) == -1)
		return (-1);
	mib[2] = indx;
	if (indx <= IPXPROTO_SPX && ipxvars[indx].list != NULL)
		lp = &ipxvars[indx];
	else if (!flags)
		return (-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return (-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return (-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return (-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	return (4);
}
@


1.147
log
@small cleanups:
 * use NULL instead of 0 for pointers, as per style(9)
 * wrap a long for-loop line in sysctl_malloc()
 * fix -Wall complaint in print_sensor()

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.146 2007/02/20 00:02:56 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.146 2007/02/20 00:02:56 deraadt Exp $";
a185 1
#define	ZTSSCALE	0x00004000
a313 8
#ifdef CPU_ZTSSCALE
	struct ztsscale {
		int ts_minx;
		int ts_maxx;
		int ts_miny;
		int ts_maxy;
	} tsbuf;
#endif
a618 40
#ifdef CPU_ZTSSCALE
		if (mib[1] == CPU_ZTSSCALE) {
			special |= ZTSSCALE;
			if (newsize > 0) {
				const char *errstr = NULL;

				/* Unspecified values default to 0. */
				bzero(&tsbuf, sizeof tsbuf);
				newval = (void *)strtok(newval, ",");
				if (newval != NULL) {
					tsbuf.ts_minx = (int)strtonum(newval,
					    0, 32768, &errstr);
					newval = (void *)strtok(NULL, ",");
				}
				if (!errstr && newval != NULL) {
					tsbuf.ts_maxx = (int)strtonum(newval,
					    0, 32768, &errstr);
					newval = (void *)strtok(NULL, ",");
				}
				if (!errstr && newval != NULL) {
					tsbuf.ts_miny = (int)strtonum(newval,
					    0, 32768, &errstr);
					newval = (void *)strtok(NULL, ",");
				}
				if (!errstr && newval != NULL) {
					tsbuf.ts_maxy = (int)strtonum(newval,
					    0, 32768, &errstr);
					newval = (void *)strtok(NULL, ",");
				}
				if (errstr)
					errx(1, "calibration value is %s",
					    errstr);
				if (newval != NULL)
					errx(1, "too many calibration values");
				newval = &tsbuf;
				newsize = sizeof(tsbuf);
			}
			break;
		}
#endif
a914 26
#ifdef CPU_ZTSSCALE
	if (special & ZTSSCALE) {
		struct ztsscale *tsp;

		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s%s", string, equ);
			tsp = (struct ztsscale *)buf;
			(void)printf("%d,%d,%d,%d\n", tsp->ts_minx,
			    tsp->ts_maxx, tsp->ts_miny, tsp->ts_maxy);
		} else {
			if (!qflag) {
				if (!nflag) {
					tsp = (struct ztsscale *)buf;
					(void)printf("%s: %d,%d,%d,%d -> ",
					    string, tsp->ts_minx, tsp->ts_maxx,
					    tsp->ts_miny, tsp->ts_maxy);
				}
				tsp = (struct ztsscale *)newval;
				(void)printf("%d,%d,%d,%d\n", tsp->ts_minx,
				    tsp->ts_maxx, tsp->ts_miny, tsp->ts_maxy);
			}
		}
		return;
	}
#endif
@


1.146
log
@knf found while fixing another bug
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.145 2007/01/06 00:23:52 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.145 2007/01/06 00:23:52 deraadt Exp $";
d310 1
a310 1
	void *newval = 0;
d632 1
a632 1
				const char *errstr = 0;
d1711 2
a1712 1
			    (lp.list[i].ctl_name = strsep(&buf, ",")) != NULL; i++) {
d1846 1
a1846 1
		if (*bufpp == 0) {
d2337 2
@


1.145
log
@pretty up the sensor outputs a wee bit more; partly spotted by jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.144 2006/12/26 11:52:30 mbalmer Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.144 2006/12/26 11:52:30 mbalmer Exp $";
d2113 1
a2113 1
			snprintf(buf, sizeof(buf), "%s.%s", 
d2121 2
a2122 2
	 * If we get this far, it means that some arguments were 
	 * provided below hw.sensors tree. 
d2150 1
a2150 1
	 * At this point we have identified the sensor device, 
d2174 1
a2174 1
	 * If no integer was provided after sensor_type, let's 
d2182 5
a2186 5
	/* 
	 * At this point we know that we have received a direct request 
	 * via command-line for a specific sensor. Let's have the parse() 
	 * function deal with it further, and report any errors if such 
	 * sensor node does not exist. 
d2194 1
a2194 1
 * Print sensors from the specified device. 
d2197 1
a2197 1
void 
d2203 1
a2203 1
	if (mlen == 3){
d2229 2
a2230 2
		/* this function is only printing sensors in bulk, so we 
		 * do not return any error messages if the requested sensor 
@


1.144
log
@Show more digits in timedelta sensor output as the timedelta sensors become
increasingly more precise.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.143 2006/12/23 17:49:53 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.143 2006/12/23 17:49:53 deraadt Exp $";
d2263 1
a2263 1
			printf("%.2f V DC", s->value / 1000000.0);
d2333 1
a2333 1
		printf(", (%s)", s->desc);
@


1.143
log
@adapt to new two-level sensor sysctl framework; by Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.142 2006/10/19 03:49:26 marco Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.142 2006/10/19 03:49:26 marco Exp $";
d2325 1
a2325 1
			printf("%.2f secs", s->value / 1000000000.0);
@


1.142
log
@Add WATTHOUR and AMPHOUR

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.141 2006/06/05 06:34:44 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.141 2006/06/05 06:34:44 otto Exp $";
d215 1
d2099 5
a2103 2
	char *name;
	int indx;
d2108 8
a2115 4
		/* scan all sensors */
		for (indx = 0; indx < 256; indx++) {
			snprintf(buf, sizeof(buf), "%s.%u", string, indx);
			parse(buf, 0);
d2119 7
a2125 1
	if ((name = strsep(bufpp, ".")) == NULL) {
d2129 60
a2188 1
	mib[2] = atoi(name);
d2190 54
a2243 1
	return (3);
a2250 2
	printf("%s, %s, ", s->device, s->desc);

d2278 1
a2278 1
			printf("%lld raw", s->value);
d2322 1
a2322 1
			printf("drive %s", name);
d2331 3
@


1.141
log
@Simpler code for printing time sensors: no leak and no floating
point. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.140 2006/06/04 01:34:48 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.140 2006/06/04 01:34:48 deraadt Exp $";
d2143 6
@


1.140
log
@print time offsets much nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.139 2006/04/25 04:37:01 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.139 2006/04/25 04:37:01 deraadt Exp $";
d2219 1
a2219 2
		char decimal[10];
		char *ct;
d2221 3
a2223 8
		ct = ctime(&t);
		if (ct) {
			ct = strdup(ct);
			ct[19] = '\0';
			snprintf(decimal, sizeof decimal, "%.3f",
			    s->tv.tv_usec / 1000000.0);
			printf(", %s%s", ct, decimal+1);
		}
@


1.139
log
@for SENSOR_TIMEDELTA, store time in nanoseconds.  discussion with kettenis
mbalmer will have to cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.138 2006/04/25 03:14:46 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.138 2006/04/25 03:14:46 deraadt Exp $";
d2219 1
d2226 3
a2228 1
			printf(", %s.%2f", ct, s->tv.tv_usec / 1000.0);
@


1.138
log
@if the timeval has data, print it at the end of the line
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.137 2006/04/20 21:09:08 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.137 2006/04/20 21:09:08 deraadt Exp $";
d2195 1
a2195 1
			printf("%.2f secs", s->value / 1000.0);
@


1.137
log
@print timedelta; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.136 2006/04/18 03:07:44 marco Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.136 2006/04/18 03:07:44 marco Exp $";
d2215 12
@


1.136
log
@Discussed with jason@@ that pfail means "partial fail".  Now it translates
to "degraded".

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.135 2006/04/13 01:05:59 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.135 2006/04/13 01:05:59 deraadt Exp $";
d2194 3
a2196 1

@


1.135
log
@Change how hw.sensors prints.  Much simpler format, easier to read. While
there, stick to printing temperature measurements in just one sane unit.
ok various people, no objections for the latter
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.134 2006/04/02 21:38:56 djm Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.134 2006/04/02 21:38:56 djm Exp $";
d2186 1
a2186 1
				name = "pfailed";
@


1.134
log
@malloc(x * y) -> calloc(x, y) from adobriyan AT gmail.com, with tweaks
suggested by kjell@@; ok otto@@ pat@@ millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.133 2005/11/30 15:46:32 dlg Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.133 2005/11/30 15:46:32 dlg Exp $";
a2125 14
	switch (s->status) {
	case SENSOR_S_OK:
		printf("OK, ");
		break;
	case SENSOR_S_WARN:
		printf("WARNING, ");
		break;
	case SENSOR_S_CRIT:
		printf("CRITICAL, ");
		break;
	case SENSOR_S_UNKNOWN:
		printf("UNKNOWN, ");
		break;
	}
d2132 2
a2133 3
			printf("temp, %.2f degC / %.2f degF",
			    (s->value - 273150000) / 1000000.0,
			    (s->value - 273150000) / 1000000.0 * 9 / 5 + 32);
d2136 1
a2136 1
			printf("fanrpm, %lld RPM", s->value);
d2139 1
a2139 1
			printf("volts_dc, %.2f V", s->value / 1000000.0);
d2142 1
a2142 1
			printf("amps, %.2f A", s->value / 1000000.0);
d2145 1
a2145 1
			printf("indicator, %s", s->value ? "On" : "Off");
d2148 1
a2148 1
			printf("raw, %lld", s->value);
d2151 1
a2151 1
			printf("percent, %.2f%%", (float)s->value / 1000.0);
d2154 1
a2154 1
			printf("lux, %.2f lx", s->value / 1000000.0);
d2192 1
a2192 1
			printf("drive, %s", name);
d2198 15
@


1.133
log
@add a sensor type for drive status and hook esm up with it.

ok marco@@ grange@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.132 2005/11/15 22:12:07 kettenis Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.132 2005/11/15 22:12:07 kettenis Exp $";
d1149 1
a1149 1
	if ((vfs_typenums = malloc(maxtypenum * sizeof(int))) == NULL)
d1151 1
a1151 2
	memset(vfs_typenums, 0, maxtypenum * sizeof(int));
	if ((vfsvars = malloc(maxtypenum * sizeof(*vfsvars))) == NULL) {
d1155 1
a1155 2
	memset(vfsvars, 0, maxtypenum * sizeof(*vfsvars));
	if ((vfsname = malloc(maxtypenum * sizeof(*vfsname))) == NULL) {
a1159 1
	memset(vfsname, 0, maxtypenum * sizeof(*vfsname));
@


1.132
log
@Add support for light sensors.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.131 2005/11/12 15:20:33 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.131 2005/11/12 15:20:33 deraadt Exp $";
d2126 2
d2174 39
@


1.131
log
@more memleaks plugged; evol@@online.ptt.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.130 2005/11/12 02:23:11 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.130 2005/11/12 02:23:11 deraadt Exp $";
d2168 3
@


1.130
log
@memory leak; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.129 2005/10/23 13:53:09 kettenis Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.129 2005/10/23 13:53:09 kettenis Exp $";
d1172 2
d1800 2
a1801 1
		if (sysctl(mib, 3, p, &len, NULL, 0) < 0)
d1803 1
d2339 1
a2339 2
		    strcmp(emul_names[i].name, emul_names[i - 1].name) == 0)) {

a2340 1
		}
@


1.129
log
@Add support for SENSOR_AMPS.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.128 2005/08/05 03:07:40 dlg Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.128 2005/08/05 03:07:40 dlg Exp $";
d1802 1
@


1.128
log
@add a sensor type that can report percentage

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.127 2005/08/04 16:00:06 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.127 2005/08/04 16:00:06 deraadt Exp $";
d2151 3
@


1.127
log
@HW_PHYSMEM and HW_USERMEM should be unsigned; ok tdeval marco
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.126 2005/08/04 13:00:44 jsg Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.126 2005/08/04 13:00:44 jsg Exp $";
d2157 3
@


1.126
log
@Support for SENSOR_INTEGER.
ok grange@@, dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.125 2005/08/04 03:53:08 dlg Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.125 2005/08/04 03:53:08 dlg Exp $";
d477 4
@


1.125
log
@a quick diff for marco, who wanted to see if his power supplies were on or
off. adds printing of the INDICATOR sensor type

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.124 2005/08/03 14:53:39 dlg Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.124 2005/08/03 14:53:39 dlg Exp $";
d2150 3
@


1.124
log
@extend the sensors framework to allow it to report the state of the
sensor, not just its value.

ok henning@@ marco@@ deraadt@@ beck@@ fixes and tweaks grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.123 2005/07/20 16:56:12 miod Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.123 2005/07/20 16:56:12 miod Exp $";
d2147 3
@


1.123
log
@Print the last two kern.nchstats entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.122 2005/05/24 04:20:26 markus Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.122 2005/05/24 04:20:26 markus Exp $";
d215 1
d954 1
a954 18
			printf("%s, %s, ", s->device, s->desc);
			switch (s->type) {
			case SENSOR_TEMP:
				printf("temp, %.2f degC / %.2f degF",
				    (s->value - 273150000) / 1000000.0,
				    (s->value - 273150000) / 1000000.0 * 9 / 5 +
				    32);
				break;
			case SENSOR_FANRPM:
				printf("fanrpm, %lld RPM", s->value);
				break;
			case SENSOR_VOLTS_DC:
				printf("volts_dc, %.2f V",
				    s->value / 1000000.0);
				break;
			default:
				printf("unknown");
			}
d2112 40
@


1.122
log
@add net.inet.ip.ifq for monitoring and changing ifqueue; similar to netbsd
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.121 2005/04/24 21:48:15 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.121 2005/04/24 21:48:15 deraadt Exp $";
d1561 6
@


1.121
log
@it is nice if this compiles on other systems
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.120 2005/04/24 18:55:49 uwe Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.120 2005/04/24 18:55:49 uwe Exp $";
d63 1
d1377 1
d1495 1
d1845 14
@


1.120
log
@Do down-sampling of the high-resolution touch pad events in kernel,
and provide sysctls for fine-tuning the touch pad area that covers the
screen.  Reasonable defaults are provided, but each machine can be a
bit different due to the manufacturing process.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.119 2005/04/20 23:40:12 beck Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.119 2005/04/20 23:40:12 beck Exp $";
d974 1
d999 1
a999 1

@


1.119
log
@actually error out when we would overflow by using the return value from
strlcpy, instead of just warning about out, and clobbering stuff anyway.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.118 2005/04/13 04:02:06 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.118 2005/04/13 04:02:06 deraadt Exp $";
d185 1
d312 8
d621 40
d971 24
@


1.118
log
@avoid variable aliasing
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.117 2005/01/28 15:39:14 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.117 2005/01/28 15:39:14 millert Exp $";
d282 1
a282 1
		warn("%s: name too long", prefix);
@


1.117
log
@Allow setting of kern.tty.*; now we can set kern.tty.maxptys.  The kernel
itself will return an error if the user tries to set a read-only variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.116 2004/09/14 22:09:38 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.116 2004/09/14 22:09:38 deraadt Exp $";
d1247 1
a1247 1
					 string, indx);
d2015 1
a2015 1
		char name[BUFSIZ];
d2019 2
a2020 2
			snprintf(name, sizeof(name), "%s.%u", string, indx);
			parse(name, 0);
@


1.116
log
@do not alias over libc ttyname(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.115 2004/08/08 19:04:25 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.115 2004/08/08 19:04:25 deraadt Exp $";
a368 1
			newsize = 0;
@


1.115
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.114 2004/07/28 17:15:12 tholo Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.114 2004/07/28 17:15:12 tholo Exp $";
d130 1
a130 1
struct ctlname ttyname[] = CTL_KERN_TTY_NAMES;
d1424 1
a1424 1
struct list ttylist = { ttyname, KERN_TTY_MAXID };
@


1.114
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.113 2004/04/15 00:23:17 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.113 2004/04/15 00:23:17 tedu Exp $";
d523 1
a523 1
			     mib[3] == TCPCTL_BADDYNAMIC) ||
d525 1
a525 1
			     mib[3] == UDPCTL_BADDYNAMIC)) {
d791 3
a793 3
			     "cylinders = %u, heads = %u, sectors = %u\n",
			     pdi->bsd_dev, pdi->bios_cylinders,
			     pdi->bios_heads, pdi->bios_sectors);
d1657 3
a1659 3
		       warnx("fourth level name %s in %s is invalid", name,
			     string);
		       return (-1);
@


1.113
log
@new world order for emulations.  adjust, and become more robust.
testing ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.112 2004/03/21 01:46:42 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.112 2004/03/21 01:46:42 tedu Exp $";
d134 1
d211 1
d439 6
d1428 1
d1983 20
@


1.112
log
@CPU_LONGRUN is gone.  repair kern.emul.nemuls, strcmp on right string
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.111 2004/02/25 08:39:02 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.111 2004/02/25 08:39:02 jmc Exp $";
d2005 4
a2008 1
char	**emul_names;
d2039 4
a2042 1
			if (emul_names[i] == NULL)
d2044 1
a2044 1
			mib[2] = i + 1;
d2053 2
a2054 2
				printf("%s%s%s%d\n", head, emul_names[i], equ,
				    enabled);
d2072 1
d2074 1
a2074 6
		print = 1;
		if (!emul_names[i]) {
			print = 0;
			if (strcmp(target, emul_names[i-1]))
				continue;
		} else if (strcmp(target, emul_names[i]))
d2077 1
a2077 1
		mib[2] = i + 1;
d2083 1
d2106 1
d2117 12
d2147 1
a2147 1
	emul_names = calloc(emul_num, sizeof(char *));
d2153 1
a2153 1
		mib[2] = i + 1;
a2156 4
			break;
		if (i > 0 && emul_names[i - 1] &&
		    strcmp(string, emul_names[i - 1]) == 0) {
			nemuls--;
d2158 4
a2161 3
		}
		emul_names[i] = strdup(string);
		if (emul_names[i] == NULL) {
d2164 8
@


1.111
log
@note that -w is optional and adjust accordingly;
remove -w from EXAMPLES;

diffs from Paul de Weerd;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.110 2004/02/24 21:45:01 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.110 2004/02/24 21:45:01 tedu Exp $";
a604 5
#ifdef CPU_LONGRUN
		if (mib[1] == CPU_LONGRUN)
			return;
#endif

d2055 1
a2055 1
	if (strcmp(string, "nemuls") == 0) {
@


1.110
log
@deal with bpf node
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.109 2004/02/10 19:53:33 grange Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.109 2004/02/10 19:53:33 grange Exp $";
d2190 2
a2191 2
	    "sysctl [-n] variable ...", "sysctl [-nq] -w variable=value ...",
	    "sysctl -aA [-n]");
@


1.109
log
@Add flags field to the sensor structure and an only flag SENSOR_FINVALID
which allows to drop information from broken, unwired, disabled, etc
sensors.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.108 2004/02/10 03:52:53 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.108 2004/02/10 03:52:53 millert Exp $";
d196 1
d542 6
d1299 1
d1416 1
d1895 17
@


1.108
log
@Tell user to run pstat -t to get kern.tty.ttyinfo if they explicitly
ask for it, else just ignore it.  This is consistent with sysctl
behavior and other entries of type CTLTYPE_STRUCT.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.107 2004/02/10 01:20:12 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.107 2004/02/10 01:20:12 millert Exp $";
d891 1
a891 1
		if (size > 0) {
@


1.107
log
@Don't hard-code type for tty sysctls to CTLTYPE_QUAD; some values are
now int.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.106 2004/01/19 01:09:06 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.106 2004/01/19 01:09:06 tedu Exp $";
d1492 7
a1498 1
	*typep = ttylist.list[indx].ctl_type;
@


1.106
log
@little wflag fallout spotted by atle kristensen
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.105 2004/01/11 22:19:18 grange Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.105 2004/01/11 22:19:18 grange Exp $";
d1492 1
a1492 1
	*typep = CTLTYPE_QUAD;
@


1.105
log
@Trivial changes to pass through -Wall

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.104 2004/01/11 21:56:31 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: sysctl.c,v 1.104 2004/01/11 21:56:31 deraadt Exp $";
d2000 1
a2000 1
		if (strcmp(string, "kern.emul") == 0) {
@


1.104
log
@remove the temporary -O flag..
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.103 2004/01/11 21:54:27 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.103 2004/01/11 21:54:27 deraadt Exp $";
d2094 1
a2094 1
		return;
@


1.103
log
@Print output as "var=value" instead of "var = value".  Also, any assignment
implies -w.  I have despised the existing behaviour for years.  ok from
henning, millert, grange
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.102 2004/01/09 02:46:04 millert Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.102 2004/01/09 02:46:04 millert Exp $";
d223 1
a223 1
	while ((ch = getopt(argc, argv, "AanqwO")) != -1) {
a224 4

		case 'O':
			equ = " = ";
			break;
@


1.102
log
@Tell the user to run ps if they try to view things under KERN_PROC2
(same handling as KERN_PROC).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.101 2004/01/05 15:26:18 markus Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.101 2004/01/05 15:26:18 markus Exp $";
d165 1
a165 1
int	Aflag, aflag, nflag, qflag, wflag;
d216 2
d223 1
a223 1
	while ((ch = getopt(argc, argv, "Aanqw")) != -1) {
d226 4
d247 1
a247 1
			wflag = 1;
a315 2
		if (!wflag)
			errx(2, "must specify -w to set variables");
d472 1
a472 1
				(void)printf("%s = ", string);
d489 1
a489 1
				(void)printf("%s = ", string);
d699 1
a699 1
			(void)printf("%s = ", string);
d715 1
a715 1
			(void)printf("%s = ", string);
d741 1
a741 1
			(void)printf("%s = ", string);
d753 1
a753 1
			(void)printf("%s = %s", string, ctime(&boottime));
d762 1
a762 1
			(void)printf("%s = %s\n", string,
d772 1
a772 1
			(void)printf("%s = %s\n", string,
d783 1
a783 1
			(void)printf("%s = ", string);
d794 1
a794 1
			(void)printf("%s = ", string);
d802 1
a802 1
				(void)printf("%s = ", string);
d819 1
a819 1
			(void)printf("%s = ", string);
d857 1
a857 1
				    newsize ? ": " : " = ");
d886 1
a886 1
			printf("%s = ", string);
d897 1
a897 1
				printf("%s = ", string);
d925 1
a925 1
				(void)printf("%s = ", string);
d940 1
a940 1
				(void)printf("%s = ", string);
d956 1
a956 1
				(void)printf("%s = ", string);
d1451 1
a1451 1
		(void)printf("%s = ", string);
d1529 1
a1529 1
		(void)printf("%s = ", string);
d1690 1
a1690 1
		printf("%s = ", string);
d2004 1
a2004 1
		if (strcmp(string, "kern.emul") == 0 && wflag) {
d2011 1
a2011 1
			printf("%snemuls = %d\n", head, nemuls);
d2024 1
a2024 1
				printf("%s%s = %d\n", head, emul_names[i],
@


1.101
log
@0K == -273.15C and sync computation with drivers; ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.100 2003/10/17 21:04:57 mcbride Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.100 2003/10/17 21:04:57 mcbride Exp $";
d398 1
@


1.100
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.99 2003/09/26 16:09:27 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.99 2003/09/26 16:09:27 deraadt Exp $";
d897 2
a898 2
				    (s->value / 1000000.0) - 273.16,
				    ((s->value / 1000000.0) - 273.16) * 9 / 5 +
@


1.99
log
@check strdup failure; ok anil millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.98 2003/09/09 11:55:05 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.98 2003/09/09 11:55:05 jmc Exp $";
d82 1
d1290 1
d1402 4
@


1.98
log
@slight cleanup of man page and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.97 2003/08/24 01:30:26 tedu Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.97 2003/08/24 01:30:26 tedu Exp $";
d1973 1
a1973 1
void	emul_init(void);
d1982 4
a1985 1
	emul_init();
d2078 1
a2078 1
void
d2095 1
a2095 1
		return;
d2098 2
a2099 4
	if (emul_names == NULL) {
		warn("emul_init");
		return;
	}
d2114 4
d2119 1
@


1.97
log
@don't print info about duplicate emuls.  gives the illusion there is only
one linux emul and one freebsd emul.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.96 2003/08/21 18:56:07 tedu Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.96 2003/08/21 18:56:07 tedu Exp $";
d2144 1
a2144 1
	(void)fprintf(stderr, "usage:\t%s\n\t%s\n\t%s\n\t%s\n",
d2146 1
a2146 1
	    "sysctl [-n] -a", "sysctl [-n] -A");
@


1.96
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.95 2003/06/11 06:22:15 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.95 2003/06/11 06:22:15 deraadt Exp $";
d1972 1
a1972 1
int	emul_num;
d1978 1
a1978 1
	int mib[4], enabled, i, old, found = 0;
d1995 1
a1995 1
			printf("%d\n", emul_num);
d1997 1
a1997 1
			printf("%snemuls = %d\n", head, emul_num);
d1999 2
d2024 1
a2024 1
			printf("%d\n", emul_num);
d2026 1
a2026 1
			printf("%snemuls = %d\n", head, emul_num);
d2030 6
a2035 1
		if (strcmp(target, emul_names[i]))
d2046 7
a2052 5
			if (nflag)
				printf("%d\n", enabled);
			else
				printf("%s%s: %d -> %d\n", head, target, old,
				    enabled);
d2058 7
a2064 4
			if (nflag)
				printf("%d\n", enabled);
			else
				printf("%s%s = %d\n", head, target, enabled);
d2094 1
a2094 1
	emul_names = malloc(emul_num * sizeof(char *));
d2100 1
d2103 1
a2103 1
		mib[3] = 0;
d2107 5
@


1.95
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.94 2003/06/02 20:06:17 millert Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.94 2003/06/02 20:06:17 millert Exp $";
d209 1
d434 3
d1969 127
@


1.94
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.93 2003/05/26 08:35:05 tedu Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.93 2003/05/26 08:35:05 tedu Exp $";
d1610 2
a1611 1
			for (i = 1; (lp.list[i].ctl_name = strsep(&buf, ",")) != NULL; i++) {
@


1.93
log
@ignore longrun struct.  eliminates a warning
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.92 2003/05/14 01:50:33 jfb Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.92 2003/05/14 01:50:33 jfb Exp $";
@


1.92
log
@Add the -q flag to suppress all output when setting a variable
with -w

ok jsyn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.91 2003/05/06 19:30:14 henning Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.91 2003/05/06 19:30:14 henning Exp $";
d596 5
@


1.91
log
@KNF while I'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.90 2003/05/06 19:27:47 henning Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.90 2003/05/06 19:27:47 henning Exp $";
d168 1
a168 1
int	Aflag, aflag, nflag, wflag;
d223 1
a223 1
	while ((ch = getopt(argc, argv, "Aanw")) != -1) {
d238 4
d794 6
a799 4
			if (!nflag)
				(void)printf("%s: %u -> ", string,
				    *(u_int *)buf);
			(void)printf("%u\n", *(u_int *)newval);
d843 1
a843 10
		if (!nflag)
			(void)printf("%s%s", string, newsize ? ": " : " = ");
		lastport = 0;
		for (port = IPPORT_RESERVED/2; port < IPPORT_RESERVED; port++)
			if (DP_ISSET(baddynamic, port)) {
				(void)printf("%s%hd", lastport ? "," : "",
				    port);
				lastport = port;
			}
		if (newsize != 0) {
d845 2
a846 2
				fputs(" -> ", stdout);
			baddynamic = (u_int32_t *)newval;
d855 14
a869 1
		(void)putchar('\n');
d917 6
a922 4
			if (!nflag)
				(void)printf("%s: %d -> ", string,
				    *(int *)buf);
			(void)printf("%d\n", *(int *)newval);
d932 5
a936 3
			if (!nflag)
				(void)printf("%s: %s -> ", string, buf);
			(void)puts((char *)newval);
d950 7
a956 4
			if (!nflag)
				(void)printf("%s: %lld -> ", string, tmp);
			tmp = *(quad_t *)newval;
			(void)printf("%qd\n", tmp);
d1994 1
a1994 1
	    "sysctl [-n] variable ...", "sysctl [-n] -w variable=value ...",
@


1.90
log
@for hw.sensors, print stuff in a human friendly way - temperatures in
degC and degF, fan speed in RPM, and voltages in (surprise) V.
theo, millert, grange agree
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.89 2003/04/25 20:32:18 grange Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.89 2003/04/25 20:32:18 grange Exp $";
d1150 1
a1150 1
		return(-1);
d1178 1
a1178 1
		return(-1);
d1181 1
a1181 1
		return(-1);
d1184 1
a1184 1
	return(3);
d1202 1
a1202 1
		return(-1);
d1205 1
a1205 1
		return(-1);
d1217 1
a1217 1
			return(-1);
d1221 1
a1221 1
			return(-1);
d1225 1
a1225 1
		return(4);
d1228 1
a1228 1
		return(3);
d1246 1
a1246 1
		return(-1);
d1249 1
a1249 1
		return(-1);
d1252 1
a1252 1
	return(3);
d1402 1
a1402 1
		return(-1);
d1405 1
a1405 1
		return(-1);
d1409 1
a1409 1
		return(-1);
d1414 1
a1414 1
			return(-1);
d1445 1
a1445 1
	return(-1);
d1458 1
a1458 1
		return(-1);
d1461 1
a1461 1
		return(-1);
d1464 1
a1464 1
	return(3);
d1481 1
a1481 1
		return(-1);
d1484 1
a1484 1
		return(-1);
d1487 1
a1487 1
		return(-1);
d1492 1
a1492 1
			return(-1);
d1523 1
a1523 1
	return(-1);
d1539 1
a1539 1
		return(-1);
d1542 1
a1542 1
		return(-1);
d1551 1
a1551 1
				return(-1);
d1558 1
a1558 1
				return(-1);
d1569 1
a1569 1
			return(-1);
d1572 1
a1572 1
		return(4);
d1575 1
a1575 1
		return(3);
d1582 1
a1582 1
			return(-1);
d1590 1
a1590 1
				return(-1);
d1603 1
a1603 1
			return(-1);
d1610 1
a1610 1
		       return(-1);
d1625 1
a1625 1
		return(4);
d1628 1
a1628 1
		return(3);
d1630 1
a1630 1
	return(-1);
d1653 1
a1653 1
		return(-1);
d1699 1
a1699 1
		return(-1);
d1702 1
a1702 1
		return(-1);
d1707 1
a1707 1
		return(-1);
d1710 1
a1710 1
		return(-1);
d1714 1
a1714 1
		return(-1);
d1717 1
a1717 1
		return(-1);
d1720 1
a1720 1
	return(4);
d1779 1
a1779 1
		return(-1);
d1782 1
a1782 1
		return(-1);
d1787 1
a1787 1
		return(-1);
d1790 1
a1790 1
		return(-1);
d1794 1
a1794 1
		return(-1);
d1797 1
a1797 1
		return(-1);
d1800 1
a1800 1
	return(4);
d1828 1
a1828 1
		return(-1);
d1831 1
a1831 1
		return(-1);
d1836 1
a1836 1
		return(-1);
d1839 1
a1839 1
		return(-1);
d1843 1
a1843 1
		return(-1);
d1846 1
a1846 1
		return(-1);
d1849 1
a1849 1
	return(4);
d1867 1
a1867 1
		return(-1);
d1870 1
a1870 1
		return(-1);
d1873 1
a1873 1
	return(3);
d1891 1
a1891 1
		return(-1);
d1894 1
a1894 1
		return(-1);
d1897 1
a1897 1
	return(3);
d1911 1
a1911 1
		return(-1);
d1914 1
a1914 1
		return(-1);
d1917 1
a1917 1
	return(3);
d1959 1
a1959 1
		return(-1);
d1967 1
a1967 1
		return(-1);
d1969 1
a1969 1
	return(i);
@


1.89
log
@Support for accessing the information from the hardware monitoring sensors
via hw.sensors node. To get the information from the all sensors
just do
$ sysctl hw.sensors.
To get the information from the particular sensor (number 5 e.g.) do
$ sysctl hw.sensors.5

Tested and ok'ed by henning@@ and millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.88 2003/04/25 20:27:19 grange Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.88 2003/04/25 20:27:19 grange Exp $";
d877 1
a877 1
			printf("(device = %s, type = ", s->device);
d880 4
a883 1
				printf("temp");
d886 1
a886 1
				printf("fanrpm");
d889 2
a890 1
				printf("volts_dc");
d895 1
a895 1
			printf(", desc=%s, value=%ld)\n", s->desc, s->value);
@


1.88
log
@Very little tweak for consistency in space vs \t
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.87 2003/04/07 23:10:46 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.87 2003/04/07 23:10:46 deraadt Exp $";
d64 1
d186 1
d212 1
d447 6
d871 25
d1914 28
@


1.87
log
@strlcat; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.86 2003/01/21 16:59:23 markus Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.86 2003/01/21 16:59:23 markus Exp $";
d184 1
a184 1
#define KMEMSTATS	0x00001000
@


1.86
log
@add kern.watchdog sysctl and generic watchdog interface;
based on feedback and discussions with mickey, henric, fgsch and jakob.
ok art@@, mickey@@, jakob@@, henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.85 2002/12/17 23:11:32 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.85 2002/12/17 23:11:32 millert Exp $";
d1049 1
a1049 1
		strcat(&names[loc], vfc.vfc_name);
@


1.85
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.84 2002/07/06 19:14:20 nordin Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.84 2002/07/06 19:14:20 nordin Exp $";
d135 1
d209 1
d424 6
d1348 1
d1859 20
@


1.84
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.83 2002/07/03 22:32:34 deraadt Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)sysctl.c	8.5 (Berkeley) 5/9/95";
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.83 2002/07/03 22:32:34 deraadt Exp $";
d55 2
d133 2
d206 2
d412 10
d1338 2
d1803 48
@


1.83
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.82 2002/06/09 08:13:09 todd Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.82 2002/06/09 08:13:09 todd Exp $";
a387 5
			return;
		case KERN_NTPTIME:
			if (flags == 0)
				return;
			warnx("use xntpdc to view %s information", string);
@


1.82
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.81 2002/06/09 04:49:19 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.81 2002/06/09 04:49:19 angelos Exp $";
d208 1
a208 3
main(argc, argv)
	int argc;
	char *argv[];
d256 1
a256 3
listall(prefix, lp)
	char *prefix;
	struct list *lp;
d283 1
a283 3
parse(string, flags)
	char *string;
	int flags;
d673 7
a679 1
		(void)printf("(inuse = %ld, calls = %ld, memuse = %ldK, limblocks = %d, mapblocks = %d, maxused = %ldK, limit = %ldK, spare = %ld, sizes = (", km->ks_inuse, km->ks_calls, (km->ks_memuse + 1023) / 1024, km->ks_limblocks, km->ks_mapblocks, (km->ks_maxused + 1023) / 1024, (km->ks_limit + 1023) / 1024, km->ks_spare);
d681 1
a681 1
		 	if ((km->ks_size & j ) == 0)
d793 2
a794 1
		for (i = 0; i < sizeof(rndstats->rnd_ed)/sizeof(rndstats->rnd_ed[0]); i++)
d796 2
a797 1
		for (i = 0; i < sizeof(rndstats->rnd_sc)/sizeof(rndstats->rnd_sc[0]); i++)
d799 2
a800 1
		for (i = 0; i < sizeof(rndstats->rnd_sb)/sizeof(rndstats->rnd_sb[0]); i++)
d898 2
a899 8
parse_baddynamic(mib, len, string, newvalp, newsizep, flags, nflag)
	int mib[];
	size_t len;
	char *string;
	void **newvalp;
	size_t *newsizep;
	int flags;
	int nflag;
d949 1
a949 1
debuginit()
d981 1
a981 1
vfsinit()
d1049 1
a1049 6
sysctl_vfsgen(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1085 1
a1085 6
sysctl_vfs(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1115 1
a1115 6
sysctl_fs(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1138 1
a1138 6
sysctl_bios(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1183 1
a1183 6
sysctl_swpenc(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1332 1
a1332 6
sysctl_nchstats(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1392 1
a1392 6
sysctl_tty(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1411 1
a1411 6
sysctl_forkstat(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1470 1
a1470 6
sysctl_malloc(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1581 1
a1581 6
sysctl_chipset(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1632 1
a1632 6
sysctl_inet(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1712 1
a1712 6
sysctl_inet6(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1761 1
a1761 6
sysctl_ipx(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
d1796 1
a1796 5
findname(string, level, bufp, namelist)
	char *string;
	char *level;
	char **bufp;
	struct list *namelist;
d1817 1
a1817 1
usage()
@


1.81
log
@Print message for kern.mbstat (to use netstat)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.80 2002/05/26 07:55:01 matthieu Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.80 2002/05/26 07:55:01 matthieu Exp $";
d1648 1
a1648 1
	if (!nflag) 
d1662 1
a1662 1
		if (sysctl(mib, 3, &bwx, &len, NULL, 0) < 0) 
@


1.80
log
@- CPU_MAXID and CPU_CHIPSET were swapped in cpu.h
- add support to print machdep.chipset mib on alpha
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.79 2002/02/16 21:27:38 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.79 2002/02/16 21:27:38 millert Exp $";
d374 5
@


1.79
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.78 2001/12/04 14:57:27 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.78 2001/12/04 14:57:27 art Exp $";
d202 3
d557 8
d1616 60
@


1.78
log
@Support for the new uvm sysctls.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.77 2001/11/05 23:15:25 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.77 2001/11/05 23:15:25 art Exp $";
d182 7
a188 7
void debuginit __P((void));
void listall __P((char *, struct list *));
void parse __P((char *, int));
void parse_baddynamic __P((int *, size_t, char *, void **, size_t *, int, int));
void usage __P((void));
int findname __P((char *, char *, char **, struct list *));
int sysctl_inet __P((char *, char **, int *, int, int *));
d190 1
a190 1
int sysctl_inet6 __P((char *, char **, int *, int, int *));
d192 11
a202 11
int sysctl_ipx __P((char *, char **, int *, int, int *));
int sysctl_fs __P((char *, char **, int *, int, int *));
static int sysctl_vfs __P((char *, char **, int[], int, int *));
static int sysctl_vfsgen __P((char *, char **, int[], int, int *));
int sysctl_bios __P((char *, char **, int *, int, int *));
int sysctl_swpenc __P((char *, char **, int *, int, int *));
int sysctl_forkstat __P((char *, char **, int *, int, int *));
int sysctl_tty __P((char *, char **, int *, int, int *));
int sysctl_nchstats __P((char *, char **, int *, int, int *));
int sysctl_malloc __P((char *, char **, int *, int, int *));
void vfsinit __P((void));
@


1.77
log
@No need to vm_param.h here.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.76 2001/08/02 11:09:39 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.76 2001/08/02 11:09:39 art Exp $";
d458 4
a461 1
		} else if (mib[1] == VM_NKMEMPAGES) {
@


1.76
log
@nkmempages.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.75 2001/07/13 23:51:35 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.75 2001/07/13 23:51:35 mickey Exp $";
a61 1
#include <vm/vm_param.h>
@


1.75
log
@escape a wrning on msgbuf, under certain circumstances
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.74 2001/07/05 08:42:15 jjbg Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.74 2001/07/05 08:42:15 jjbg Exp $";
d453 1
a453 2
		}
		else if (mib[1] == VM_SWAPENCRYPT) {
d458 2
@


1.74
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.73 2001/06/27 06:16:47 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.73 2001/06/27 06:16:47 art Exp $";
d373 2
@


1.73
log
@UVM is no longer an option
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.72 2001/06/22 23:17:27 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.72 2001/06/22 23:17:27 art Exp $";
d83 1
d1216 1
d1317 11
@


1.72
log
@Fix more printf formats.
Add some missing prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.70 2001/06/22 22:14:39 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.70 2001/06/22 22:14:39 art Exp $";
a90 1
#ifdef UVM
a91 1
#endif
a450 1
#ifdef UVM
a457 1
#endif
a1176 1
#ifdef UVM
a1202 1
#endif
@


1.71
log
@Fix a bunch of u_int64_t formats.
@
text
@d200 4
d294 1
a294 1
	quad_t quadval;
d612 2
a613 1
			(void)sscanf(newval, "%qd", &quadval);
d650 2
a651 2
		printf("high watermark = %lld ", kb->kb_highwat);
		printf("could_free = %lld", kb->kb_couldfree);
d776 1
a776 1
			(void)printf(" %qu", rndstats->rnd_ed[i]);
d778 1
a778 1
			(void)printf(" %qu", rndstats->rnd_sc[i]);
d780 1
a780 1
			(void)printf(" %qu", rndstats->rnd_sb[i]);
d850 2
d854 1
a854 1
			(void)printf("%qd\n", *(quad_t *)buf);
d856 2
d859 3
a861 3
				(void)printf("%s: %qd -> ", string,
				    *(quad_t *)buf);
			(void)printf("%qd\n", *(quad_t *)newval);
@


1.70
log
@more arguments than format
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.69 2001/06/22 21:39:07 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.69 2001/06/22 21:39:07 mickey Exp $";
d753 17
a769 13
		"%qu %qu %qu %qu %qu %qu %qu %qu %qu %qu %qu %qu %qu %qu %qu %qu",
		    rndstats->rnd_total,
		    rndstats->rnd_used, rndstats->rnd_reads,
		    rndstats->arc4_reads, rndstats->arc4_nstirs,
		    rndstats->arc4_stirs,
		    rndstats->rnd_pad[0],
		    rndstats->rnd_pad[1],
		    rndstats->rnd_pad[2],
		    rndstats->rnd_pad[3],
		    rndstats->rnd_pad[4],
		    rndstats->rnd_waits,
		    rndstats->rnd_enqs, rndstats->rnd_deqs,
		    rndstats->rnd_drops, rndstats->rnd_drople);
@


1.69
log
@block on msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.68 2001/06/22 21:35:46 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.68 2001/06/22 21:35:46 art Exp $";
d807 1
a807 1
			printf("%s = ", string, lal);
@


1.68
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.67 2001/06/22 21:31:02 art Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.67 2001/06/22 21:31:02 art Exp $";
d369 3
@


1.67
log
@Nicer printing of kmem buckets.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.66 2001/06/01 20:08:31 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.66 2001/06/01 20:08:31 mickey Exp $";
a1179 1
	char *name;
@


1.66
log
@make listall immune to supuh long names; after deraadtification
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.65 2001/06/01 19:29:13 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.65 2001/06/01 19:29:13 mickey Exp $";
d637 8
a644 1
		(void)printf("(calls = %qu, total_allocated = %qu, total_free = %qu, elements = %qu, high_watermark = %qu, could_free = %qu)\n", kb->kb_calls, kb->kb_total, kb->kb_totalfree, kb->kb_elmpercl, kb->kb_highwat, kb->kb_couldfree);
@


1.65
log
@duh, main returns
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.64 2001/06/01 19:27:07 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.64 2001/06/01 19:27:07 mickey Exp $";
a256 1
	int lvl2;
d258 1
d262 3
a264 1
	cp = name + strlcpy(name, prefix, BUFSIZ);
d269 3
a271 1
		(void)strcpy(cp, lp->list[lvl2].ctl_name);
@


1.64
log
@do not use strlen after strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.63 2001/05/14 07:14:53 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.63 2001/05/14 07:14:53 angelos Exp $";
d240 1
a240 1
		exit(0);
d246 1
a246 1
	exit(0);
@


1.63
log
@Ignore empty strings in kern.malloc.kmemstat.<foo>, add tty stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.62 2001/05/12 06:47:17 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.62 2001/05/12 06:47:17 angelos Exp $";
d262 1
a262 2
	(void)strlcpy(name, prefix, BUFSIZ);
	cp = &name[strlen(name)];
@


1.62
log
@Better argument checking for kmemstats.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.61 2001/05/11 06:43:41 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.61 2001/05/11 06:43:41 angelos Exp $";
d60 1
d132 1
d347 6
d403 11
d1301 1
d1369 24
d1527 5
a1531 3
			for (i = 1;
			    (lp.list[i].ctl_name = strsep(&buf, ",")) != NULL;
			    i++) {
@


1.61
log
@Print the new sysctls (nchstats, kmemstats, nselcoll, forkstat)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.60 2001/02/23 16:46:36 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.60 2001/02/23 16:46:36 mickey Exp $";
d1495 6
a1500 3
		if (ptr == NULL)	/* Should never happen */
			return(-1);
		/* Catch weird prefix match -- XXX recovery ? */
d1502 8
a1509 2
		    (*(ptr + strlen(name)) != '\0'))
			return(-1);
@


1.60
log
@give cp_time a proper treatment
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.59 2001/01/22 23:10:33 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.59 2001/01/22 23:10:33 deraadt Exp $";
d59 2
d129 2
d179 1
d342 6
d354 2
d615 22
a636 1
		(void)printf("calls = %qu, total_allocated = %qu, total_free = %qu, elements = %qu, high_watermark = %qu, could_free = %qu\n", kb->kb_calls, kb->kb_total, kb->kb_totalfree, kb->kb_elmpercl, kb->kb_highwat, kb->kb_couldfree);
d688 2
a689 2
			     pdi->bsd_dev, pdi->bios_cylinders, pdi->bios_heads,
			     pdi->bios_sectors);
d1280 131
d1423 2
a1424 2
	int indx, size, stor, i;
	char *name, bufp[BUFSIZ], *buf;
d1426 1
d1433 1
a1433 1
		return (-1);
d1452 2
a1453 2
			     (lp.list[i].ctl_name = strsep(&buf, ",")) != NULL;
			     i++) {
d1464 43
a1506 1
	} else {
d1510 1
@


1.59
log
@attempting to sysctl clear a string was failing; checked by millert and aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.58 2001/01/04 22:02:02 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.58 2001/01/04 22:02:02 angelos Exp $";
d58 1
d173 2
a174 1
#define KMEMBUCKETS     0x00000400
d278 1
a278 1
	int special = 0;
d342 1
a342 1
			        special |= KMEMBUCKETS;
d374 4
d541 1
a541 1
	
d599 1
a599 1
	        struct kmembuckets *kb = (struct kmembuckets *)buf;
d601 1
a601 1
		        (void)printf("%s = ", string);
d738 9
d1260 1
a1260 1
        struct list lp;
d1267 1
a1267 1
	        return (-1);
d1270 2
a1271 2
	        if ((name = strsep(bufpp, ".")) == NULL) {
		        size = BUFSIZ;
d1276 1
a1276 1
			        return(-1);
d1279 2
a1280 2
			        if (buf[i] == ',')
				        stor++;
d1283 1
a1283 1
			        return(-1);
d1288 1
a1288 1
			        lp.list[i].ctl_type = CTLTYPE_STRUCT;
d1299 2
a1300 2
	        *typep = CTLTYPE_STRING;
	        return(3);
@


1.58
log
@Sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.57 2001/01/04 07:50:33 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.57 2001/01/04 07:50:33 angelos Exp $";
d571 1
a571 1
	if (sysctl(mib, len, buf, &size, newsize ? newval : 0, newsize) == -1) {
d747 1
a747 1
		if (newsize == 0) {
@


1.57
log
@Read a struct kmembuckets, rather than individual values.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.56 2001/01/04 06:07:22 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.56 2001/01/04 06:07:22 angelos Exp $";
a125 1
struct ctlname kernbucketname[] = CTL_KERN_MALLOC_BUCKET_NAMES;
a1230 1
struct list kernbucketlist = { kernbucketname, KERN_MALLOC_BUCKET_MAXID };
@


1.56
log
@Print the kern.malloc.* branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.55 2000/12/22 22:47:04 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.55 2000/12/22 22:47:04 deraadt Exp $";
d173 1
d340 2
d593 7
d1275 1
a1275 1
			        lp.list[i].ctl_type = CTLTYPE_QUAD;
d1278 1
a1278 1
			lp.list[i].ctl_type = CTLTYPE_QUAD;
d1284 1
a1284 10
		if (*bufpp == NULL) {
		        listall(string, &kernbucketlist);
			return(-1);
		}
		if ((indx = findname(string, "fifth", bufpp,
				     &kernbucketlist)) == -1)
		        return (-1);
		mib[4] = indx;
		*typep = CTLTYPE_QUAD;
		return(5);
@


1.55
log
@strlcpy is great
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.54 2000/11/21 06:18:27 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.54 2000/11/21 06:18:27 millert Exp $";
d57 1
d125 2
d335 6
d1070 1
a1070 1
		return 4;
d1220 69
@


1.54
log
@Fix an int * that should be a size_t * when calling sysctl(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.53 2000/06/30 16:00:10 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.53 2000/06/30 16:00:10 millert Exp $";
d250 1
a250 2
	(void)strncpy(name, prefix, BUFSIZ-1);
	name[BUFSIZ-1] = '\0';
d280 1
a280 2
	(void)strncpy(buf, string, sizeof(buf) - 1);
	buf[sizeof(buf) - 1] = '\0';
@


1.53
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.52 2000/06/14 16:54:46 provos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.52 2000/06/14 16:54:46 provos Exp $";
d382 2
a383 2
			len = sizeof(_ps);
			if (sysctl(mib, 2, &_ps, &len, NULL, 0) == -1) {
@


1.52
log
@add swapencrypt ctl level.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.51 2000/06/07 00:20:32 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.51 2000/06/07 00:20:32 itojun Exp $";
d579 1
a579 1
			warn(string);
@


1.51
log
@s/PIMCTL/PIM6CTL/ for less confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.50 2000/05/22 17:29:42 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.50 2000/05/22 17:29:42 mickey Exp $";
d86 4
d187 1
d397 7
a403 1
		if (mib[1] != VM_SWAPENCRYPT) {
d409 1
a409 3
#ifdef UVM
		}
#endif
d1068 30
@


1.50
log
@modify vfs subtree to accomodate for fs-specific variables.
in particular expose vfs.nfs.iothreads, which is a replacement
for nfsiod kludge.
this is not a netbsd port-over, since this particular
implementation builds up the needed variable indexes dynamically
(using the already existing `generic' vfs variables),
as opposed to netbsd which relies on static matching w/ kernel
definitions and configuration...
man changes to come soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.49 2000/04/10 19:50:50 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.49 2000/04/10 19:50:50 mickey Exp $";
d1219 1
a1219 1
struct ctlname pim6name[] = PIMCTL_NAMES;
d1257 1
a1257 1
	{ pim6name, PIMCTL_MAXID },	/* pim6 */
@


1.49
log
@this is how rnd stats are printed out now
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.48 2000/03/21 20:46:30 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.48 2000/03/21 20:46:30 mickey Exp $";
d86 9
d180 2
d267 2
a268 2
	int indx, type, state, intval;
	size_t size, len,  newsize = 0;
a272 1
	struct vfsconf vfc;
d495 12
a506 9
		mib[3] = mib[1];
		mib[1] = VFS_GENERIC;
		mib[2] = VFS_CONF;
		len = 4;
		size = sizeof vfc;
		if (sysctl(mib, 4, &vfc, &size, (void *)0, (size_t)0) < 0) {
			if (errno != EOPNOTSUPP)
				perror("vfs print");
			return;
a507 8
		if (flags == 0 && vfc.vfc_refcount == 0)
			return;
		if (!nflag)
			fprintf(stdout, "%s has %d mounted instance%s\n",
			    string, vfc.vfc_refcount,
			    vfc.vfc_refcount != 1 ? "s" : "");
		else
			fprintf(stdout, "%d\n", vfc.vfc_refcount);
d837 6
d861 6
a866 1
	if ((vfsname = malloc(maxtypenum * sizeof(*vfsname))) == 0)
d868 7
d878 2
a879 2
	for (loc = lastused, cnt = 0; cnt < maxtypenum; cnt++) {
		mib[3] = cnt;
d883 1
a883 1
			perror("vfsinit");
d887 9
d898 1
a898 1
		vfsname[cnt].ctl_type = CTLTYPE_INT;
d903 6
d912 70
@


1.49.2.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.49 2000/04/10 19:50:50 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.49 2000/04/10 19:50:50 mickey Exp $";
d565 1
a565 1
			warn("%s", string);
@


1.48
log
@more random stats
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.47 2000/02/06 16:58:01 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.47 2000/02/06 16:58:01 itojun Exp $";
d651 11
a661 6
		    "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu",
		    rndstats->rnd_total, rndstats->rnd_used,
		    rndstats->arc4_reads, rndstats->rnd_timer,
		    rndstats->rnd_mouse, rndstats->rnd_tty,
		    rndstats->rnd_disk, rndstats->rnd_net,
		    rndstats->rnd_reads, rndstats->rnd_waits,
d663 1
a663 3
		    rndstats->rnd_drops, rndstats->rnd_drople,
		    rndstats->rnd_asleep, rndstats->rnd_queued,
		    rndstats->arc4_stirs);
d665 5
a669 1
			(void)printf(" %lu", rndstats->rnd_ed[i]);
@


1.47
log
@do not directly include netinet6/{ip6,icmp6}.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.46 2000/01/21 02:53:06 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.46 2000/01/21 02:53:06 angelos Exp $";
d646 1
d651 1
a651 1
		    "%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u\n",
d659 5
a663 1
		    rndstats->rnd_asleep, rndstats->rnd_queued);
@


1.46
log
@ip4.allow -> ipip.allow
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.45 2000/01/07 21:34:58 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.45 2000/01/07 21:34:58 angelos Exp $";
d80 2
a81 2
#include <netinet6/ip6.h>
#include <netinet6/icmp6.h>
@


1.45
log
@gre.allow and mobileip.allow
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.44 1999/12/30 19:06:06 provos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.44 1999/12/30 19:06:06 provos Exp $";
d66 1
a66 1
#include <netinet/ip_ip4.h>
d945 1
a945 1
struct ctlname ip4name[] = IP4CTL_NAMES;
d959 1
a959 1
	{ ip4name, IP4CTL_MAXID },	/* ipencap */
@


1.44
log
@vm.swapencrypt for UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.43 1999/12/10 10:12:56 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.43 1999/12/10 10:12:56 itojun Exp $";
d77 1
d951 2
d1002 1
a1002 1
	{ 0, 0 },
d1010 1
a1010 1
	{ 0, 0 },
@


1.43
log
@add IPv6 support.  net.inet6.{ip6,icmp6} will be printed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.42 1999/10/28 03:34:03 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.42 1999/10/28 03:34:03 angelos Exp $";
d380 3
d387 4
@


1.42
log
@net.inet.etherip.allow sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.41 1999/09/02 22:04:38 pjanzen Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.41 1999/09/02 22:04:38 pjanzen Exp $";
d78 7
d165 3
d404 9
d1084 86
@


1.41
log
@Treat kern.hostid as a u_int, and clean up parsing of integers on the command
line.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.40 1999/07/01 15:45:18 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.40 1999/07/01 15:45:18 deraadt Exp $";
d67 1
d923 1
d978 46
@


1.40
log
@print kern.arandom unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.39 1999/04/11 19:41:41 niklas Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.39 1999/04/11 19:41:41 niklas Exp $";
d142 4
a145 4
#define RNDSTATS	0x00000010
#define BADDYNAMIC	0x00000020
#define BIOSGEO		0x00000040
#define BIOSDEV		0x00000080
d147 1
a147 1
#define UNSIGNED	0x00000200
d332 1
d493 15
a507 1
			intval = atoi(newval);
@


1.39
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.38 1999/04/09 23:30:06 niklas Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.38 1999/04/09 23:30:06 niklas Exp $";
d147 1
d332 3
d588 13
@


1.38
log
@The userland parts of a sysctl that can switch on/off IP-in-IP (protocol 4)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.37 1999/02/25 21:59:50 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.37 1999/02/25 21:59:50 deraadt Exp $";
d67 2
a81 2
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
a155 1
int sysctl_ipsec __P((char *, char **, int *, int, int *));
a393 6
		if (mib[1] == PF_KEY) {
			len = sysctl_ipsec(string, &bufp, mib, flags, &type);
			if (len >= 0)
				break;
			return;
		}
a881 47
struct ctlname encapname[] = PFKEYCTL_NAMES;
struct ctlname ipsecname[] = CTL_IPSEC_NAMES;
struct list ipseclist = { ipsecname, IPSECCTL_MAXID };
struct list ipsecvars[] = {
	{ encapname, IPSECCTL_MAXID }, 
};

/*
 * handle ipsec requests
 */
int
sysctl_ipsec(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &ipseclist);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &ipseclist)) == -1)
		return(-1);
	mib[2] = indx;
	if (indx <= IPSECCTL_MAXID && ipsecvars[indx].list != NULL)
		lp = &ipsecvars[indx];
	else if (!flags)
		return(-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return(-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return(-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return(-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	return(4);
}

d888 2
d910 34
d967 1
a967 1
	if (indx <= IPPROTO_UDP && inetvars[indx].list != NULL)
@


1.37
log
@mib for pf_key is PF_KEY not PF_KEY_V2
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.36 1999/02/24 22:59:43 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.36 1999/02/24 22:59:43 angelos Exp $";
d66 1
d939 1
d948 1
a948 1
	{ 0, 0 },
@


1.36
log
@New position for the encdebug variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.35 1998/03/19 07:36:11 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.35 1998/03/19 07:36:11 deraadt Exp $";
d394 1
a394 1
		if (mib[1] == PF_KEY_V2) {
@


1.35
log
@fix type botches
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.34 1998/03/15 17:48:48 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.34 1998/03/15 17:48:48 millert Exp $";
a58 1

d79 1
a79 1
#include <net/encap.h>
d394 1
a394 1
		if (mib[1] == PF_ENCAP) {
d888 1
a888 1
struct ctlname encapname[] = ENCAPCTL_NAMES;
d892 1
a892 1
	{ encapname, ENCAPCTL_MAXID }, 
@


1.34
log
@Add support for vfs.* from lite2
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.33 1998/02/17 20:51:24 matthieu Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.33 1998/02/17 20:51:24 matthieu Exp $";
d244 2
a245 2
	int indx, type, state, len;
	size_t size;
a247 1
	int intval, newsize = 0;
@


1.33
log
@use warn() instead of warnx() to print error message
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.32 1997/10/25 21:46:06 mickey Exp $	*/
d45 1
a45 1
static char sccsid[] = "@@(#)sysctl.c	8.1 (Berkeley) 6/6/93";
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.32 1997/10/25 21:46:06 mickey Exp $";
d53 1
d102 1
d108 1
d130 1
d160 1
d195 1
a195 1
	if (Aflag || aflag) {
d197 1
d204 2
a205 2
	while (argc-- > 0)
		parse(*argv++, 1);
d245 1
a249 1
	size_t size;
d251 1
d271 2
d459 21
d756 1
a756 1
	for (loc = 0, i = 0; i < CTL_DEBUG_MAXID; i++) {
d765 45
@


1.32
log
@fix diskinfo listing, support blk2chr,chr2blk
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.31 1997/10/25 08:23:38 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.31 1997/10/25 08:23:38 mickey Exp $";
d496 1
a496 1
			warnx(string);
@


1.31
log
@make diskinfo working; fix one bug and one exploit
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.30 1997/10/22 23:40:35 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.30 1997/10/22 23:40:35 mickey Exp $";
d136 7
a142 5
#define	CONSDEV		0x00000004
#define RNDSTATS	0x00000008
#define BADDYNAMIC	0x00000010
#define BIOSGEO		0x00000020
#define BIOSDEV		0x00000040
d406 23
a428 1
			special |= CONSDEV;
d521 11
a531 1
	if (special & CONSDEV) {
a789 2
		if (!flags)
			return(-1);
@


1.30
log
@newer bios stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.29 1997/10/15 19:30:55 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.29 1997/10/15 19:30:55 kstailey Exp $";
d215 1
d236 1
a236 1
	int indx, type, state;
d241 1
a241 1
	size_t size, len;
d409 4
d415 1
a415 5
			if (mib[2] == BIOS_DEV)
				special |= BIOSDEV;
			if (len >= 0)
				break;
			return;
d468 3
d509 1
a509 1
		bios_diskinfo_t di = *(bios_diskinfo_t *)buf;
d513 4
a516 2
		printf("Cylinders=%d Tracks=%d Sectors=%d (%08x)\n",
		       di.bios_cylinders, di.bios_heads, di.bios_sectors);
d524 1
a524 5
		if (dev & 0x80)
			dev = ('c' + dev) & 0x7f;
		else
			dev += 'a';
		(void) printf("%c:\n", dev);
d745 1
d755 25
a779 2
	*typep = bioslist.list[indx].ctl_type;
	return(3);
@


1.29
log
@s/xntpd/xntpdc/
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.28 1997/10/03 21:15:19 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.28 1997/10/03 21:15:19 deraadt Exp $";
d408 1
a408 1
			if (mib[2] == BIOS_GEOMETRY)
d505 1
a505 1
		u_int geo = *(int *)buf;
d510 1
a510 1
		    BIOSNTRACKS(geo), BIOSNHEADS(geo), BIOSNSECTS(geo), geo);
@


1.28
log
@put real geo field in ()
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.27 1997/10/03 20:58:04 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.27 1997/10/03 20:58:04 deraadt Exp $";
d310 1
a310 1
			warnx("use xntpd to view %s information", string);
@


1.27
log
@avoid sign extension on bios geometry!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.26 1997/09/21 23:02:03 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.26 1997/09/21 23:02:03 mickey Exp $";
d509 1
a509 1
		printf("Cylinders=%d Tracks=%d Sectors=%d %08x\n",
@


1.26
log
@new machdep.bios subtree
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.25 1997/09/12 03:56:08 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.25 1997/09/12 03:56:08 millert Exp $";
d505 1
a505 1
		int geo = *(int *)buf;
d509 2
a510 2
		(void) printf("spt = %d, tpc = %d\n",
			      BIOSNSECTS(geo), BIOSNHEADS(geo));
@


1.25
log
@Add parens to shut up -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.24 1997/08/29 02:40:40 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.24 1997/08/29 02:40:40 mickey Exp $";
d89 1
a89 1
#ifdef CPU_BIOSGEOMETRY
d153 1
d405 11
a415 7
#ifdef CPU_BIOSGEOMETRY
		if (mib[1] == CPU_BIOSGEOMETRY)
			special |= BIOSGEO;
#endif
#ifdef CPU_BIOSDEV
		if (mib[1] == CPU_BIOSDEV)
			special |= BIOSDEV;
d503 1
a503 1
#ifdef CPU_BIOSGEOMETRY
a512 1
#endif
d525 1
d727 29
@


1.24
log
@fix case we have no CPU_BIOS* defined
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.23 1997/08/28 19:39:20 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.23 1997/08/28 19:39:20 mickey Exp $";
d515 1
a515 1
			dev = 'c' + dev & 0x7f;
@


1.23
log
@symbolic bios bootdev, s/hpc/tpc/ for bios geonetry
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.22 1997/08/28 19:31:51 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.22 1997/08/28 19:31:51 mickey Exp $";
d498 1
d508 1
@


1.22
log
@grok bios geometry
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.21 1997/08/19 23:20:32 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.21 1997/08/19 23:20:32 millert Exp $";
d140 1
d408 4
d503 1
a503 1
		(void) printf("spt = %d, hpc = %d\n",
d505 12
@


1.21
log
@Some KNF, check a few return values and use err/warn.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.20 1997/08/19 22:38:31 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.20 1997/08/19 22:38:31 millert Exp $";
d89 4
d139 1
d403 4
d491 9
@


1.20
log
@Move bad dynamic port parsing into parse_baddynamic().
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.19 1997/08/19 06:42:42 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.19 1997/08/19 06:42:42 millert Exp $";
d82 1
d134 1
a134 1
#define BADDYNAMIC	0x00000020
d137 4
d142 5
a146 9
void debuginit __P((void));
void parse __P((char *string, int flags));
void parse_baddynamic __P((int mib[CTL_MAXNAME], size_t len, char *string, void **newvalp, size_t *newsizep, int flags, int nflag));
void listall __P((char *prefix, struct list *lp));
int findname __P((char *string, char *level, char **bufp, struct list *namelist));
int sysctl_inet __P((char *string, char **bufpp, int mib[], int flags, int *typep));
int sysctl_ipsec __P((char *string, char **bufpp, int mib[], int flags, int *typep));
int sysctl_ipx __P((char *string, char **bufpp, int mib[], int flags, int *typep));
int sysctl_fs __P((char *string, char **bufpp, int mib[], int flags, int *typep));
d207 1
a207 1
	strncpy(name, prefix, BUFSIZ-1);
d213 1
a213 1
		strcpy(cp, lp->list[lvl2].ctl_name);
d238 2
a240 1
	snprintf(buf, BUFSIZ, "%s", string);
d242 2
a243 4
		if (!wflag) {
			fprintf(stderr, "Must specify -w to set variables\n");
			exit(2);
		}
d258 1
a258 2
		fprintf(stderr, "%s: class is not implemented\n",
		    topname[indx].ctl_name);
d276 2
a277 2
			size = sizeof state;
			if (sysctl(mib, 3, &state, &size, NULL, 0) < 0) {
d281 2
a282 3
					fprintf(stdout, "%s: ", string);
				fprintf(stdout,
				    "kernel is not compiled for profiling\n");
d286 1
a286 1
				fprintf(stdout, "%s = %s\n", string,
d293 1
a293 2
			fprintf(stderr,
			    "Use pstat to view %s information\n", string);
d298 1
a298 2
			fprintf(stderr,
			    "Use ps to view %s information\n", string);
d303 1
a303 2
			fprintf(stderr,
			    "Use xntpd to view %s information\n", string);
d326 3
a328 3
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%.2f %.2f %.2f\n", 
			    loads[0], loads[1], loads[2]);
d334 8
a341 1
			sysctl(mib, 2, &_ps, &len, NULL, 0);
d343 2
a344 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%ld\n", _ps.val);
d349 1
a349 2
		fprintf(stderr,
		    "Use vmstat or systat to view %s information\n", string);
d385 1
a385 1
		fprintf(stderr, "Use netstat to view %s information\n", string);
d411 1
a411 1
		fprintf(stderr, "Illegal top level value: %d\n", mib[0]);
d416 1
a416 1
		fprintf(stderr, "name %s in %s is unknown\n", bufp, string);
d424 1
a424 1
			newsize = sizeof intval;
d428 1
a428 1
			sscanf(newval, "%qd", &quadval);
d430 1
a430 1
			newsize = sizeof quadval;
d440 1
a440 1
			fprintf(stderr, "%s: value is not available\n", string);
d443 1
a443 2
			fprintf(stderr, "%s: specification is incomplete\n",
			    string);
d446 1
a446 2
			fprintf(stderr, "%s: type is unknown to this program\n",
			    string);
d449 1
a449 1
			perror(string);
d457 2
a458 2
			fprintf(stdout, "%s = ", string);
		fprintf(stdout,
d469 1
a469 1
			fprintf(stdout, "%s = %s\n", string, ctime(&boottime));
d471 1
a471 1
			fprintf(stdout, "%ld\n", btp->tv_sec);
d478 1
a478 1
			fprintf(stdout, "%s = %s\n", string,
d481 1
a481 1
			fprintf(stdout, "0x%x\n", dev);
d486 1
d488 2
a489 2
			fprintf(stdout, "%s = ", string);
		fprintf(stdout,
d506 1
a506 1
			printf("%s%s", string, newsize ? ": " : " = ");
d510 2
a511 1
				printf("%s%hd", lastport ? "," : "", port);
d522 2
a523 2
					printf("%s%hd", lastport ? "," : "",
					    port);
d527 1
a527 1
		putchar('\n');
d534 2
a535 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%d\n", *(int *)buf);
d538 1
a538 1
				fprintf(stdout, "%s: %d -> ", string,
d540 1
a540 1
			fprintf(stdout, "%d\n", *(int *)newval);
d547 2
a548 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%s\n", buf);
d551 2
a552 2
				fprintf(stdout, "%s: %s -> ", string, buf);
			fprintf(stdout, "%s\n", (char *)newval);
d559 2
a560 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%qd\n", *(quad_t *)buf);
d563 1
a563 1
				fprintf(stdout, "%s: %qd -> ", string,
d565 1
a565 1
			fprintf(stdout, "%qd\n", *(quad_t *)newval);
d570 1
a570 2
		fprintf(stderr, "%s: unknown structure returned\n",
		    string);
d575 1
a575 2
		fprintf(stderr, "%s: unknown type returned\n",
		    string);
d582 1
a582 1
	int mib[CTL_MAXNAME];
d597 1
a597 1
		if (sysctl(mib, len, newbaddynamic, &size, 0, 0) < 0) {
d601 2
a602 2
				printf("%s: ", string);
			printf("kernel does contain bad dynamic port tables\n");
d677 1
a677 1
		return (-1);
d680 1
a680 1
		return (-1);
d683 1
a683 1
	return (3);
d709 1
a709 1
		return (-1);
d712 1
a712 1
		return (-1);
d717 1
a717 1
		return (-1);
d719 2
a720 3
		fprintf(stderr, "%s: no variables defined for this protocol\n",
		    string);
		return (-1);
d724 1
a724 1
		return (-1);
d727 1
a727 1
		return (-1);
d730 1
a730 1
	return (4);
d776 1
a776 1
		return (-1);
d779 1
a779 1
		return (-1);
d784 1
a784 1
		return (-1);
d786 2
a787 3
		fprintf(stderr, "%s: no variables defined for this protocol\n",
		    string);
		return (-1);
d791 1
a791 1
		return (-1);
d794 1
a794 1
		return (-1);
d797 1
a797 1
	return (4);
d814 1
a814 1
 * handle internet requests
d829 1
a829 1
		return (-1);
d832 1
a832 1
		return (-1);
d837 1
a837 1
		return (-1);
d839 2
a840 3
		fprintf(stderr, "%s: no variables defined for this protocol\n",
		    string);
		return (-1);
d844 1
a844 1
		return (-1);
d847 1
a847 1
		return (-1);
d850 1
a850 1
	return (4);
d867 2
a868 2
		fprintf(stderr, "%s: incomplete specification\n", string);
		return (-1);
d875 2
a876 3
		fprintf(stderr, "%s level name %s in %s is invalid\n",
		    level, name, string);
		return (-1);
d878 1
a878 1
	return (i);
@


1.19
log
@Add support for adding/subtracting ports from the current baddynamic
mask.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.17 1997/08/19 05:53:12 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.17 1997/08/19 05:53:12 millert Exp $";
d136 10
a145 9
void usage();
void debuginit();
void parse __P((	char *string, int flags));
void listall __P((char *prefix, 	struct list *lp));
int findname __P((char *string, 	char *level, char **bufp, struct list *namelist));
int sysctl_inet __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
int sysctl_ipsec __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
int sysctl_ipx __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
int sysctl_fs __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
a151 2
	extern char *optarg;
	extern int optind;
d356 1
a360 3
				u_int32_t newbaddynamic[DP_MAPSIZE];
				in_port_t port;
				char action;
a362 2
				if (newval == NULL)
					break;
d364 3
a366 53
				if (strchr((char *)newval, '+') ||
				    strchr((char *)newval, '-')) {
					size = sizeof(newbaddynamic);
					if (sysctl(mib, len, newbaddynamic,
					    &size, 0, 0) < 0) {
						if (flags == 0)
							return;
						if (!nflag)
							printf("%s: ", string);
						printf("kernel does not have "
						    "bad dynamic port tables "
						    "in it\n");
						return;
					}
					while (newval &&
					    (cp = strsep((char **)&newval,
					    ", \t")) && *cp) {
						if (*cp != '+' && *cp != '-')
							errx(1, "cannot mix +/-"
							    " with full list");
						action = *cp++;
						port = atoi(cp);
						if (port < IPPORT_RESERVED/2 ||
						    port >= IPPORT_RESERVED)
							errx(1, "invalid port, "
							    "range is %d to %d",
							    IPPORT_RESERVED/2,
							    IPPORT_RESERVED-1);
						if (action == '+')
							DP_SET(newbaddynamic,
							    port);
						else
							DP_CLR(newbaddynamic,
							    port);
					}
				} else {
					(void)memset((void *)newbaddynamic, 0,
					    sizeof(newbaddynamic));
					while (newval &&
					    (cp = strsep((char **)&newval,
					    ", \t")) && *cp) {
						port = atoi(cp);
						if (port < IPPORT_RESERVED/2 ||
						    port >= IPPORT_RESERVED)
							errx(1, "invalid port, "
							    "range is %d to %d",
							    IPPORT_RESERVED/2,
							    IPPORT_RESERVED-1);
						DP_SET(newbaddynamic, port);
					}
				}
				newval = (void *)newbaddynamic;
				newsize = sizeof(newbaddynamic);
d579 54
@


1.18
log
@typo
@
text
@d363 1
d369 50
a418 12
				(void)memset((void *)&newbaddynamic, 0,
				    sizeof(newbaddynamic));
				while (newval && (cp = strsep((char **)&newval,
				    ", \t")) && *cp) {
					port = atoi(cp);
					if (port < IPPORT_RESERVED/2 ||
					    port >= IPPORT_RESERVED)
						errx(1, "invalid port, "
						    "range is %d to %d",
						    IPPORT_RESERVED/2,
						    IPPORT_RESERVED-1);
					DP_SET(newbaddynamic, port);
@


1.17
log
@Make net.inet.tcp.baddynamic and net.inet.udp.baddynamic
comma-separated instead of space-separated when printing
so it is easy to cut and paste.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.16 1997/08/19 05:32:57 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.16 1997/08/19 05:32:57 millert Exp $";
d365 1
a365 1
				if (newval == NULL);
@


1.16
log
@Only print bad dynamic ports list for udp and tcp since that's all
that exist.  This fixes a bug where net.inet.ip.redirect,
net.inet.ip.directed-broadcast, and net.inet.tcp.keepinittimem
got interpreted as dynamic port lists.  Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.15 1997/08/09 23:36:31 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.15 1997/08/09 23:36:31 millert Exp $";
d365 15
a379 17
				if (newval != NULL) {
					(void)memset((void *)&newbaddynamic, 0,
					    sizeof(newbaddynamic));
					while (newval &&
					    (cp = strsep((char **)&newval,
					    ", \t")) && *cp) {
						port = atoi(cp);
						if (port < IPPORT_RESERVED/2 ||
						    port >= IPPORT_RESERVED)
							errx(1, "invalid port, "
							    "range is %d to %d",
							    IPPORT_RESERVED/2,
							    IPPORT_RESERVED-1);
						DP_SET(newbaddynamic, port);
					}
					newval = (void *)newbaddynamic;
					newsize = sizeof(newbaddynamic);
d381 2
d518 1
a518 1
		in_port_t port;
d522 2
a523 1
			printf("%s%s", string, newsize ? ":" : " =");
d525 4
a528 2
			if (DP_ISSET(baddynamic, port))
				printf(" %hd", port);
d531 1
a531 1
				fputs(" ->", stdout);
d533 1
d536 5
a540 2
				if (DP_ISSET(baddynamic, port))
					printf(" %hd", port);
@


1.15
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.14 1997/07/22 15:06:54 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.14 1997/07/22 15:06:54 kstailey Exp $";
d357 4
a360 2
			if (mib[3] == TCPCTL_BADDYNAMIC ||
			    mib[3] == UDPCTL_BADDYNAMIC) {
@


1.14
log
@tabify, use NULL for ptr ops, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.13 1997/07/22 14:43:19 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.13 1997/07/22 14:43:19 kstailey Exp $";
d59 2
d64 1
d133 1
d355 28
a382 3
			if (len >= 0)
				break;
			return;
d513 21
@


1.13
log
@re-tabify (angelos!)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.12 1997/07/15 00:38:15 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.12 1997/07/15 00:38:15 angelos Exp $";
d201 1
a201 1
	if (lp->list == 0)
d207 1
a207 1
		if (lp->list[lvl2].ctl_name == 0)
d594 1
a594 1
        { encapname, ENCAPCTL_MAXID }, 
d603 4
a606 4
        char **bufpp;
        int mib[];
        int flags;
        int *typep;
d608 2
a609 2
        struct list *lp;
        int indx;
d611 7
a617 7
        if (*bufpp == NULL) {
                listall(string, &ipseclist);
                return (-1);
        }
        if ((indx = findname(string, "third", bufpp, &ipseclist)) == -1)
                return (-1);
        mib[2] = indx;
d619 1
a619 1
	 	lp = &ipsecvars[indx];
d627 9
a635 9
        if (*bufpp == NULL) {
                listall(string, lp);
                return (-1);
        }
        if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
                return (-1);
        mib[3] = indx;
        *typep = lp->list[indx].ctl_type;
        return (4);
@


1.12
log
@sysctl for PF_ENCAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.11 1997/06/28 07:05:34 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.11 1997/06/28 07:05:34 deraadt Exp $";
d645 18
a662 18
        { ipname, IPCTL_MAXID },        /* ip */
        { icmpname, ICMPCTL_MAXID },    /* icmp */
        { 0, 0 },                       /* igmp */
        { 0, 0 },                       /* ggmp */
        { 0, 0 },
        { 0, 0 },
        { tcpname, TCPCTL_MAXID },      /* tcp */
        { 0, 0 },
        { 0, 0 },                       /* egp */
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },                       /* pup */
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },
        { udpname, UDPCTL_MAXID },      /* udp */
@


1.11
log
@fix the rnd types
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.10 1997/06/24 02:45:02 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.10 1997/06/24 02:45:02 mickey Exp $";
d76 2
d138 1
d361 6
d590 48
d645 18
a662 18
	{ ipname, IPCTL_MAXID },	/* ip */
	{ icmpname, ICMPCTL_MAXID },	/* icmp */
	{ 0, 0 },			/* igmp */
	{ 0, 0 },			/* ggmp */
	{ 0, 0 },
	{ 0, 0 },
	{ tcpname, TCPCTL_MAXID },	/* tcp */
	{ 0, 0 },
	{ 0, 0 },			/* egp */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },			/* pup */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ udpname, UDPCTL_MAXID },	/* udp */
@


1.10
log
@more accounting!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.9 1997/06/17 19:42:02 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.9 1997/06/17 19:42:02 mickey Exp $";
d466 9
a474 9
		        "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
			rndstats->rnd_total, rndstats->rnd_used,
			rndstats->arc4_reads, rndstats->rnd_timer,
			rndstats->rnd_mouse, rndstats->rnd_tty,
			rndstats->rnd_disk, rndstats->rnd_net,
			rndstats->rnd_reads, rndstats->rnd_waits,
			rndstats->rnd_enqs, rndstats->rnd_deqs,
			rndstats->rnd_drops, rndstats->rnd_drople,
			rndstats->rnd_asleep, rndstats->rnd_queued);
@


1.9
log
@count slow queue low entropy drops
bigger queue
use queue overflows for arc4_stir()
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.8 1997/06/14 21:37:12 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.8 1997/06/14 21:37:12 mickey Exp $";
d466 1
a466 1
		        "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
d473 2
a474 1
			rndstats->rnd_drops, rndstats->rnd_drople);
@


1.8
log
@split the treatment of the random events
event_q by flipk@@
spl fix by deraadt@@
gother statistics about whole processing
use 'sysctl kern.random' to view what had happened
also fix wrong vm.psstrings description
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.7 1997/04/06 20:19:22 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.7 1997/04/06 20:19:22 millert Exp $";
d282 1
a282 1
				fprintf(stdout, "%s: %s\n", string,
d325 1
a325 1
				fprintf(stdout, "%s: ", string);
d335 1
a335 1
				fprintf(stdout, "%s: ", string);
d434 1
a434 1
			fprintf(stdout, "%s: ", string);
d464 1
a464 1
			fprintf(stdout, "%s: ", string);
d466 1
a466 1
		        "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
d473 1
a473 1
			rndstats->rnd_drops);
@


1.7
log
@Use a size_t as arg 4 to sysctl(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.6 1997/01/16 03:57:31 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.6 1997/01/16 03:57:31 millert Exp $";
d75 1
d127 1
d277 1
a277 1
				fprintf(stderr,
d310 3
d459 15
@


1.6
log
@Support VM_PSSTRINGS.  Man, this has been sitting in my tree for a while...
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.5 1997/01/15 23:44:22 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.5 1997/01/15 23:44:22 millert Exp $";
d219 1
a219 1
	int indx, type, state, len;
d224 1
a224 1
	size_t size;
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.4 1996/11/25 08:22:43 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.4 1996/11/25 08:22:43 mickey Exp $";
d323 9
@


1.4
log
@ipx sysctl.
cleanup (protyping, printf formats and so)
1 (one) bug fix in printf's arg (struct instead of field)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD$";
d146 1
a146 1
	while ((ch = getopt(argc, argv, "Aanw")) != EOF) {
@


1.3
log
@Make {,f}chown(2) behaviour POSIX.1 compliant with SUID / SGID files
Enable CTL_FS processing by sysctl(3)
Add CTL_FS request to disable clearing SUID / SGID bit when a files owner
or group is changed by root
Make sysctl(8) understand CTL_FS requests
@
text
@d1 1
d47 1
a47 1
static char *rcsid = "$NetBSD: sysctl.c,v 1.9 1995/09/30 07:12:50 thorpej Exp $";
d70 4
d80 1
d127 10
d188 1
d198 1
a198 1
	strcpy(name, prefix);
d214 1
d227 1
a227 1
	char *cp, *bufp, buf[BUFSIZ], strval[BUFSIZ];
d251 1
a251 1
		    topname[indx]);
d338 6
d434 1
a434 1
			fprintf(stdout, "%d\n", btp->tv_sec);
d469 1
a469 1
			fprintf(stdout, "%s\n", newval);
d502 1
d530 1
a537 1
	struct list *lp;
d581 1
d619 54
d676 1
d702 1
@


1.2
log
@DDB support added.
@
text
@d79 1
d99 1
a99 1
	{ 0, 0 },			/* CTL_FS */
d278 6
d338 5
d497 27
@


1.1
log
@Initial revision
@
text
@d69 1
d86 1
d108 1
d332 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

