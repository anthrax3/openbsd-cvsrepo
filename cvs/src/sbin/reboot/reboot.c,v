head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.2
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.34.0.8
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.4
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.10
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.8
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.12
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.8
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.8
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.6
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.18.0.6
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.18.0.4
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2017.03.02.10.38.09;	author natano;	state Exp;
branches;
next	1.35;
commitid	EeVoCYFCx2tYicZQ;

1.35
date	2016.08.27.01.56.07;	author guenther;	state Exp;
branches;
next	1.34;
commitid	XB5bOflDUv67Sks3;

1.34
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2013.02.09.21.21.27;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.10.12.58.26;	author halex;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.23.20.14.23;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.11.01.53.07;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.01.17.22.14;	author dhill;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.06.21.36.17;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.09.18.49.57;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.19.17.41.22;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.09.07.04.46;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.04.14.59.49;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.30.17.30.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.09.03.18.11.50;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.08.16.18.43.11;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.07.19.00.10.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.08.07.20.17.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.08.05.07.37.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.07.12.07.17.28;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	98.04.25.00.09.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.03.21.18.38;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.19.13.10;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.22.22.19.11;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.04.11.09.06.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.12.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.41.38;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.22.09.20.59;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.11.23.29.09;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@/*	$OpenBSD: reboot.c,v 1.35 2016/08/27 01:56:07 guenther Exp $	*/
/*	$NetBSD: reboot.c,v 1.8 1995/10/05 05:36:22 mycroft Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/reboot.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <machine/cpu.h>
#include <signal.h>
#include <pwd.h>
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <termios.h>
#include <syslog.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <util.h>

void	usage(void);
extern char *__progname;

int	dohalt;

#define _PATH_RC	"/etc/rc"

int
main(int argc, char *argv[])
{
	unsigned int i;
	struct passwd *pw;
	int ch, howto, lflag, nflag, pflag, qflag;
	char *p, *user;
	sigset_t mask;

	p = __progname;

	/* Nuke login shell */
	if (*p == '-')
		p++;

	howto = dohalt = lflag = nflag = pflag = qflag = 0;
	if (!strcmp(p, "halt")) {
		dohalt = 1;
		howto = RB_HALT;
	}

	while ((ch = getopt(argc, argv, "dlnpq")) != -1)
		switch (ch) {
		case 'd':
			howto |= RB_DUMP;
			break;
		case 'l':	/* Undocumented; used by shutdown. */
			lflag = 1;
			break;
		case 'n':
			nflag = 1;
			howto |= RB_NOSYNC;
			break;
		case 'p':
			/* Only works if we're called as halt. */
			if (dohalt) {
				pflag = 1;
				howto |= RB_POWERDOWN;
			}
			break;
		case 'q':
			qflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc)
		usage();

	if (geteuid())
		errx(1, "%s", strerror(EPERM));

#ifdef CPU_LIDSUSPEND
	if (howto & RB_POWERDOWN) {
		/* Disable suspending on laptop lid close */
		int mib[] = {CTL_MACHDEP, CPU_LIDACTION};
		int lidaction = 0;

		if (sysctl(mib, 2, NULL, NULL, &lidaction,
		    sizeof(lidaction)) == -1 && errno != EOPNOTSUPP)
			warn("sysctl");
	}
#endif /* CPU_LIDSUSPEND */

	if (qflag) {
		reboot(howto);
		err(1, "reboot");
	}

	/* Log the reboot. */
	if (!lflag)  {
		if ((user = getlogin()) == NULL)
			user = (pw = getpwuid(getuid())) ?
			    pw->pw_name : "???";
		if (dohalt) {
			openlog("halt", 0, LOG_AUTH | LOG_CONS);
			if (pflag) {
				syslog(LOG_CRIT,
					"halted (with powerdown) by %s", user);
			} else {
				syslog(LOG_CRIT, "halted by %s", user);
			}
		} else {
			openlog("reboot", 0, LOG_AUTH | LOG_CONS);
			syslog(LOG_CRIT, "rebooted by %s", user);
		}
	}
	logwtmp("~", "shutdown", "");

	/*
	 * Do a sync early on, so disks start transfers while we're off
	 * killing processes.  Don't worry about writes done before the
	 * processes die, the reboot system call syncs the disks.
	 */
	if (!nflag)
		sync();

	/* Just stop init -- if we fail, we'll restart it. */
	if (kill(1, SIGTSTP) == -1)
		err(1, "SIGTSTP init");

	/* Ignore the SIGHUP we get when our parent shell dies. */
	(void)signal(SIGHUP, SIG_IGN);

	/*
	 * If we're running in a pipeline, we don't want to die
	 * after killing whatever we're writing to.
	 */
	(void)signal(SIGPIPE, SIG_IGN);

	if (access(_PATH_RC, R_OK) != -1) {
		pid_t pid;
		struct termios t;
		int fd, status;

		switch ((pid = fork())) {
		case -1:
			break;
		case 0:
			if (revoke(_PATH_CONSOLE) == -1)
				warn("revoke");
			if (setsid() == -1)
				warn("setsid");
			fd = open(_PATH_CONSOLE, O_RDWR);
			if (fd == -1)
				warn("open");
			dup2(fd, 0);
			dup2(fd, 1);
			dup2(fd, 2);
			if (fd > 2)
				close(fd);

			/* At a minimum... */
			tcgetattr(0, &t);
			t.c_oflag |= (ONLCR | OPOST);
			tcsetattr(0, TCSANOW, &t);

			execl(_PATH_BSHELL, "sh", _PATH_RC, "shutdown", (char *)NULL);
			_exit(1);
		default:
			/* rc exits 2 if powerdown=YES in rc.shutdown */
			waitpid(pid, &status, 0);
			if (dohalt && WIFEXITED(status) && WEXITSTATUS(status) == 2)
				howto |= RB_POWERDOWN;
		}
	}

	/*
	 * Point of no return, block all signals so we are sure to
	 * reach the call to reboot(2) unmolested.
	 */
	sigfillset(&mask);
	sigprocmask(SIG_BLOCK, &mask, NULL);

	/* Send a SIGTERM first, a chance to save the buffers. */
	if (kill(-1, SIGTERM) == -1) {
		/*
		 * If ESRCH, everything's OK: we're the only non-system
		 * process!  That can happen e.g. via 'exec reboot' in
		 * single-user mode.
		 */
		if (errno != ESRCH) {
			warn("SIGTERM processes");
			goto restart;
		}
	}

	/*
	 * After the processes receive the signal, start the rest of the
	 * buffers on their way.  Wait 5 seconds between the SIGTERM and
	 * the SIGKILL to give everybody a chance.
	 */
	sleep(2);
	if (!nflag)
		sync();
	sleep(3);

	for (i = 1;; ++i) {
		if (kill(-1, SIGKILL) == -1) {
			if (errno == ESRCH)
				break;
			goto restart;
		}
		if (i > 5) {
			warnx("WARNING: some process(es) wouldn't die");
			break;
		}
		(void)sleep(2 * i);
	}

	reboot(howto);
	/* FALLTHROUGH */

restart:
	errx(1, kill(1, SIGHUP) == -1 ? "(can't restart init): " : "");
	/* NOTREACHED */
}

void
usage(void)
{
	fprintf(stderr, "usage: %s [-dn%sq]\n", __progname,
	    dohalt ? "p" : "");
	exit(1);
}
@


1.35
log
@Pull in <sys/time.h> for struct timespec
<sys/fcntl.h> shouldn't be used by userspace; this already uses <fcntl.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.34 2015/01/16 06:40:00 deraadt Exp $	*/
d118 2
a119 2
		int mib[2];
		int lidsuspend = 0;
d121 2
a122 4
		mib[0] = CTL_MACHDEP;
		mib[1] = CPU_LIDSUSPEND;
		if (sysctl(mib, 2, NULL, NULL, &lidsuspend,
		    sizeof(lidsuspend)) == -1 && errno != EOPNOTSUPP)
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.33 2013/02/09 21:21:27 millert Exp $	*/
a34 1
#include <sys/fcntl.h>
d36 1
@


1.33
log
@Ignore sysctl failure for CPU_LIDSUSPEND when errno is EOPNOTSUPP.
Just because CPU_LIDSUSPEND is defined in cpu.h does mean it is
actually supported by the hardware.  OK miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.32 2012/07/10 12:58:26 halex Exp $	*/
a35 1
#include <sys/param.h>
@


1.32
log
@disable lidsuspend on shutdown

ok phessler@@ mpf@@ pirofti@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.31 2010/07/23 20:14:23 millert Exp $	*/
d125 1
a125 1
		    sizeof(lidsuspend)) == -1)
@


1.31
log
@Block all signals before sending SIGTERM to all non-system processes.
This ensures that we reach the call to reboot(2) without being killed
by some other process.  OK deraadt@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.30 2009/10/27 23:59:34 deraadt Exp $	*/
d36 2
d39 1
d115 14
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.29 2007/05/11 01:53:07 tedu Exp $	*/
d65 1
d195 7
@


1.29
log
@it's silly for reboot to poweroff.  adapted from diff by diana eichert
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.28 2006/06/01 17:22:14 dhill Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1986, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)reboot.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: reboot.c,v 1.28 2006/06/01 17:22:14 dhill Exp $";
#endif
#endif /* not lint */
@


1.28
log
@delint

ok moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.27 2006/04/06 21:36:17 henning Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.27 2006/04/06 21:36:17 henning Exp $";
d204 1
a204 1
			if (WIFEXITED(status) && WEXITSTATUS(status) == 2)
@


1.27
log
@if "/etc/rc shutdown" exits 2, attempt powerdown. it does so if
rc.shutdown sets powerdown to YES.
From: Michele 'mydecay' Marchetto <mydecay@@openbeer.it>
but didn't apply, so I redid & added comment to clarify
ok mickey theo
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.26 2004/07/09 18:49:57 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.26 2004/07/09 18:49:57 deraadt Exp $";
d75 1
a75 1
	int i;
@


1.26
log
@variety of cleanups; nofsk@@aanet.com.au and I
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.25 2003/06/02 20:06:16 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.25 2003/06/02 20:06:16 millert Exp $";
d175 1
a175 1
		int fd;
d202 4
a205 1
			waitpid(pid, NULL, 0);
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.24 2002/07/03 22:32:33 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.24 2002/07/03 22:32:33 deraadt Exp $";
d65 1
a65 1
void usage(void);
d68 2
d77 1
a77 1
	int ch, howto, dohalt, lflag, nflag, pflag, qflag, sverrno;
d83 2
a84 1
	if(*p == '-') p++;
d93 1
a93 1
		switch(ch) {
d97 1
a97 1
		case 'l':		/* Undocumented; used by shutdown. */
a113 1
		case '?':
d120 3
a245 1
	sverrno = errno;
d253 2
a254 1
	(void)fprintf(stderr, "usage: %s [-dlnpq]\n", __progname);
@


1.24
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.23 2002/02/16 21:27:37 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.23 2002/02/16 21:27:37 millert Exp $";
@


1.23
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.22 2001/11/05 07:39:17 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.22 2001/11/05 07:39:17 mpech Exp $";
d75 1
a75 3
main(argc, argv)
	int argc;
	char *argv[];
d251 1
a251 1
usage()
@


1.22
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.21 2001/07/19 17:41:22 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.21 2001/07/19 17:41:22 millert Exp $";
d69 1
a69 1
void usage __P((void));
@


1.21
log
@#include <termios.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.20 2001/07/09 07:04:46 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.20 2001/07/09 07:04:46 deraadt Exp $";
d79 1
a79 1
	register int i;
@


1.20
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.19 2001/06/04 14:59:49 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.19 2001/06/04 14:59:49 mickey Exp $";
d60 1
@


1.19
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.18 2000/04/30 17:30:34 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.18 2000/04/30 17:30:34 millert Exp $";
d199 1
a199 1
			execl(_PATH_BSHELL, "sh", _PATH_RC, "shutdown", NULL);
@


1.18
log
@Add missing fcntl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.17 1999/09/03 18:11:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.17 1999/09/03 18:11:50 deraadt Exp $";
d182 1
a182 1
				perror("revoke");
d184 1
a184 1
				perror("setsid");
d187 1
a187 1
				perror("open");
@


1.17
log
@have shutdown code run /etc/rc with arg of "shutdown"; rc.shutdown becomes  completely admin-editable
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.16 1999/08/16 18:43:11 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.16 1999/08/16 18:43:11 art Exp $";
d59 1
@


1.16
log
@we need to include sys/wait.h since we use waitpid here
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.15 1999/07/19 00:10:00 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.15 1999/07/19 00:10:00 deraadt Exp $";
d70 1
a70 1
#define _PATH_RCSHUTDOWN	"/etc/rc.shutdown"
d171 1
a171 1
	if (access(_PATH_RCSHUTDOWN, R_OK) != -1) {
d198 1
a198 1
			execl(_PATH_BSHELL, "sh", _PATH_RCSHUTDOWN, NULL);
@


1.15
log
@run /etc/rc.shutdown on /dev/console
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.14 1998/08/07 20:17:32 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.14 1998/08/07 20:17:32 deraadt Exp $";
d54 1
@


1.14
log
@delete the garbage which does not work
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.11 1998/04/25 00:09:03 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.11 1998/04/25 00:09:03 deraadt Exp $";
d53 1
d172 2
d179 18
d198 1
a198 1
			exit(1);
@


1.13
log
@12 seconds not 30.  But I am just about to remove the kill and wait
patch.  Obviously it was never tested on a machine running a regular
compliment of services.  On such a machine, it causes a full 12 (was
30) second delay *EVERY TIME*.  That's COMPLETELY unreasonable.
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.12 1998/07/12 07:17:28 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.12 1998/07/12 07:17:28 angelos Exp $";
d198 2
a199 1
	 * buffers on their way.
d204 1
a205 18
	/*
	 * Wait for up to 12 seconds for processes that need a long 
	 * time to shut down (e.g., X servers on old slow notebook PCs with
	 * only 8 MB of RAM and a slow disk; or databases), but probe at
	 * 1 second intervals and continue immediately if none are left.
	 */
	for (i=0; i<12; ++i) {
		if (kill(-1, 0) == -1) {
			if (errno == ESRCH)
				break;
			goto restart;
		}
		sleep(1);
	}

	/*
	 * They've had their chance. SIGKILL the remaining processes.
	 */
@


1.12
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.11 1998/04/25 00:09:03 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.11 1998/04/25 00:09:03 deraadt Exp $";
d205 1
a205 1
	 * Wait for up to 30 seconds for processes that need a long 
d210 1
a210 1
	for (i=0; i<30; ++i) {
@


1.11
log
@ignore SIGPIPE; nathanw@@MIT.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.10 1997/09/03 21:18:38 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.10 1997/09/03 21:18:38 mickey Exp $";
d198 1
a198 2
	 * buffers on their way.  Wait 5 seconds between the SIGTERM and
	 * the SIGKILL to give everybody a chance.
a202 1
	sleep(3);
d204 18
@


1.10
log
@use err()/warn()/__progname
document -d
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.9 1997/07/25 19:13:10 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.9 1997/07/25 19:13:10 mickey Exp $";
d162 6
@


1.9
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.8 1997/06/22 22:19:11 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.8 1997/06/22 22:19:11 downsj Exp $";
d51 1
d56 1
d63 1
a64 1
void err __P((const char *fmt, ...));
d66 1
a69 2
int dohalt;

d77 1
a77 1
	int ch, howto, lflag, nflag, pflag, qflag, sverrno;
d80 1
a80 4
	/* Get our name */
	p = strrchr(*argv, '/');
	if(p == NULL) p = *argv;
	else p++;
d85 1
d89 2
a90 3
	} else
		howto = 0;
	lflag = nflag = pflag = qflag = 0;
d121 1
a121 1
		err("%s", strerror(EPERM));
d125 1
a125 1
		err("%s", strerror(errno));
d158 1
a158 1
		err("SIGTSTP init: %s", strerror(errno));
d185 1
a185 2
			(void)fprintf(stderr, "%s: SIGTERM processes: %s",
			    dohalt ? "halt" : "reboot", strerror(errno));
d207 1
a207 2
			(void)fprintf(stderr,
			    "WARNING: some process(es) wouldn't die\n");
d218 1
a218 2
	err("%s%s", kill(1, SIGHUP) == -1 ? "(can't restart init): " : "",
	    strerror(sverrno));
d225 1
a225 29
	(void)fprintf(stderr, "usage: %s [-nqd]\n", dohalt ? "halt" : "reboot");
	exit(1);
}

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#ifdef __STDC__
err(const char *fmt, ...)
#else
err(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "%s: ", dohalt ? "halt" : "reboot");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
a226 1
	/* NOTREACHED */
@


1.8
log
@Support RB_POWERDOWN.
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.7 1997/04/11 09:06:42 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.7 1997/04/11 09:06:42 deraadt Exp $";
d234 1
a234 1
#if __STDC__
d241 1
a241 1
#if __STDC__
d250 1
a250 1
#if __STDC__
@


1.7
log
@add support for a script called /etc/rc.shutdown
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.6 1997/01/17 07:12:20 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.6 1997/01/17 07:12:20 millert Exp $";
d76 1
a76 1
	int ch, howto, lflag, nflag, qflag, sverrno;
d92 2
a93 2
	lflag = nflag = qflag = 0;
	while ((ch = getopt(argc, argv, "lnqd")) != -1)
d95 3
d105 7
a114 3
		case 'd':
			howto |= RB_DUMP;
			break;
d137 6
a142 1
			syslog(LOG_CRIT, "halted by %s", user);
@


1.6
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.5 1997/01/15 23:41:38 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.5 1997/01/15 23:41:38 millert Exp $";
d60 1
d65 2
d152 14
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.4 1996/07/22 09:20:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.4 1996/07/22 09:20:59 deraadt Exp $";
d77 1
a77 1
	p = rindex(*argv, '/');
@


1.4
log
@kill (-1, SIGTERM) may find no other processes; netbsd pr#2619, cgd
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.3 1996/07/11 23:29:09 weingart Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.3 1996/07/11 23:29:09 weingart Exp $";
d90 1
a90 1
	while ((ch = getopt(argc, argv, "lnqd")) != EOF)
@


1.3
log
@netbsd pr bin/2618 from cgd, fixed differently
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.2 1996/06/23 14:32:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.2 1996/06/23 14:32:12 deraadt Exp $";
d151 12
a162 2
	if (kill(-1, SIGTERM) == -1)
		err("SIGTERM processes: %s", strerror(errno));
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.8 1995/10/05 05:36:22 mycroft Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.8 1995/10/05 05:36:22 mycroft Exp $";
d76 9
a84 1
	if (!strcmp((p = rindex(*argv, '/')) ? p + 1 : *argv, "halt")) {
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: reboot.c,v 1.8 1995/10/05 05:36:22 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
