head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.6
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.10
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.6
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.16
	OPENBSD_5_0:1.25.0.14
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.12
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.10
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.8
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.10.03.13.03.49;	author jca;	state Exp;
branches;
next	1.31;
commitid	xBZhwvWtK3Qbygx8;

1.31
date	2016.09.30.12.07.23;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	yp3FsZCZ6wrbQJ0D;

1.30
date	2016.09.27.22.03.49;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	IXkv3kGA2BxL1UHh;

1.29
date	2016.09.26.21.19.02;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	F0rlRIT8AeoDeLNi;

1.28
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.03.26.05.22.26;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.13.10.15.19;	author shadchin;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.23.17.41.21;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.31.22.09.37;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.07.15.31.23;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.07.15.14.00;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.27.05.21.19;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.08.19.30.31;	author jaredy;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.08.17.26.35;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.08.13.23.41;	author jaredy;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.16.09.53.56;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.09.03.21.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.10.00.00.57;	author david;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.21.10.37;	author maja;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.30.19.10.00;	author jsyn;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.16.02.08.02;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.12.09.00.40;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.20.45.58;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.12.02.16.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.01.49.58;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.07.18.26.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.04.20.05.06;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.04.15.49.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.08.08.00.16;	author maja;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Those while loops look better written as for loops

ok kettenis@@
@
text
@/*	$OpenBSD: kbd_wscons.c,v 1.31 2016/09/30 12:07:23 kettenis Exp $ */

/*
 * Copyright (c) 2001 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymdef.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define	NUM_KBD	10

char *kbtype_tab[] = {
	"pc-xt/pc-at",
	"usb",
	"adb",
	"lk201",
	"sun",
	"sun5",
	"hil",
	"gsc",
	"sgi"
};
enum {	SA_PCKBD,
	SA_UKBD,
	SA_AKBD,
	SA_LKKBD,
	SA_SUNKBD,
	SA_SUN5KBD,
	SA_HILKBD,
	SA_GSCKBD,
	SA_SGIKBD,

	SA_MAX
};

struct nameint {
	int value;
	char *name;
};

struct nameint kbdenc_tab[] = {
	KB_ENCTAB
	,
	{ 0, NULL }
};

struct nameint kbdvar_tab[] = {
	KB_VARTAB
	,
	{ 0, NULL }
};

extern char *__progname;

void	kbd_show_enc(struct wskbd_encoding_data *encs, int idx);
void	kbd_get_encs(int fd, struct wskbd_encoding_data *encs);
void	kbd_list(void);
void	kbd_set(char *name, int verbose);

void
kbd_show_enc(struct wskbd_encoding_data *encs, int idx)
{
	int found;
	kbd_t encoding, variant;
	struct nameint *n;
	int i;

	printf("tables available for %s keyboard:\nencoding\n\n",
	    kbtype_tab[idx]);

	for (i = 0; i < encs->nencodings; i++) {
		found = 0;
		encoding = encs->encodings[i];
		for (n = &kbdenc_tab[0]; n->value; n++) {
			if (n->value == KB_ENCODING(encoding)) {
				printf("%s", n->name);
				found++;
			}
		}
		if (found == 0)
			printf("<encoding 0x%04x>", KB_ENCODING(encoding));
		found = 0;
		variant = KB_VARIANT(encoding);
		for (n = &kbdvar_tab[0]; n->value; n++) {
			if ((n->value & KB_VARIANT(encoding)) == n->value) {
				printf(".%s", n->name);
				variant &= ~n->value;
			}
		}
		if (variant != 0)
			printf(".<variant 0x%08x>", variant);
		printf("\n");
	}
	printf("\n");
}

void
kbd_get_encs(int fd, struct wskbd_encoding_data *encs)
{
	int nencodings = 64;

	encs->nencodings = nencodings;
	while (encs->nencodings == nencodings) {
		encs->encodings = reallocarray(encs->encodings,
		    encs->nencodings, sizeof(kbd_t));
		if (encs->encodings == NULL)
			err(1, NULL);
		if (ioctl(fd, WSKBDIO_GETENCODINGS, encs) < 0)
			err(1, "WSKBDIO_GETENCODINGS");
		if (encs->nencodings == nencodings) {
			nencodings *= 2;
			encs->nencodings = nencodings;
		}
	}
}

void
kbd_list(void)
{
	int	kbds[SA_MAX];
	struct wskbd_encoding_data encs[SA_MAX];
	int	fd, i, kbtype, t;
	char	device[PATH_MAX];

	memset(kbds, 0, sizeof(kbds));
	memset(encs, 0, sizeof(encs));

	/* Go through all keyboards. */
	for (i = 0; i < NUM_KBD; i++) {
		(void) snprintf(device, sizeof device, "/dev/wskbd%d", i);
		fd = open(device, O_WRONLY);
		if (fd < 0)
			fd = open(device, O_RDONLY);
		if (fd >= 0) {
			if (ioctl(fd, WSKBDIO_GTYPE, &kbtype) < 0)
				err(1, "WSKBDIO_GTYPE");
			switch (kbtype) {
			case WSKBD_TYPE_PC_XT:
			case WSKBD_TYPE_PC_AT:
				t = SA_PCKBD;
				break;
			case WSKBD_TYPE_USB:
				t = SA_UKBD;
				break;
			case WSKBD_TYPE_ADB:
				t = SA_AKBD;
				break;
			case WSKBD_TYPE_LK201:
			case WSKBD_TYPE_LK401:
				t = SA_LKKBD;
				break;
			case WSKBD_TYPE_SUN:
				t = SA_SUNKBD;
				break;
			case WSKBD_TYPE_SUN5:
				t = SA_SUN5KBD;
				break;
			case WSKBD_TYPE_HIL:
				t = SA_HILKBD;
				break;
			case WSKBD_TYPE_GSC:
				t = SA_GSCKBD;
				break;
			case WSKBD_TYPE_SGI:
				t = SA_SGIKBD;
				break;
			default:
				t = SA_MAX;
				break;
			};

			if (t != SA_MAX) {
				kbds[t]++;
				if (encs[t].encodings == NULL)
					kbd_get_encs(fd, &encs[t]);
			}
			close(fd);
		}
	}

	for (i = 0; i < SA_MAX; i++)
		if (kbds[i] != 0)
			kbd_show_enc(&encs[i], i);

	for (i = 0; i < SA_MAX; i++)
		free(encs[i].encodings);
}

void
kbd_set(char *name, int verbose)
{
	char	buf[LINE_MAX], *c, *b, device[sizeof "/dev/wskbd00"];
	int	map = 0, v, i, fd;
	struct nameint *n;

	c = name;
	b = buf;
	while (*c != '.' && *c != '\0' && b < buf + sizeof(buf) - 1)
		*b++ = *c++;
	*b = '\0';
	n = &kbdenc_tab[0];
	while (n->value) {
		if (strcmp(n->name, buf) == 0)
			map = n->value;
		n++;
	}
	if (map == 0)
		errx(1, "unknown encoding %s", buf);
	while (*c == '.') {
		b = buf;
		c++;
		while (*c != '.' && *c != '\0' && b < buf + sizeof(buf) - 1)
			*b++ = *c++;
		*b = '\0';
		v = 0;
		for (n = &kbdvar_tab[0]; n->value; n++) {
			if (strcmp(n->name, buf) == 0)
				v = n->value;
		}
		if (v == 0)
			errx(1, "unknown variant %s", buf);
		map |= v;
	}

	/* Go through all keyboards. */
	v = 0;
	for (i = 0; i < NUM_KBD; i++) {
		(void) snprintf(device, sizeof device, "/dev/wskbd%d", i);
		fd = open(device, O_WRONLY);
		if (fd < 0)
			fd = open(device, O_RDONLY);
		if (fd >= 0) {
			if (ioctl(fd, WSKBDIO_SETENCODING, &map) < 0) {
				if (errno == EINVAL) {
					fprintf(stderr,
					    "%s: unsupported encoding %s on %s\n",
					    __progname, name, device);
				} else
					err(1, "WSKBDIO_SETENCODING: %s", device);
				v--;
			}
			v++;
			close(fd);
		}
	}

	if (verbose && v > 0)
		fprintf(stderr, "kbd: keyboard mapping set to %s\n", name);
}
@


1.31
log
@Use WSKBDIO_GETENCODINGS ioctl to generate a list of supported keyboard
encodings.  Restores functionality lost when removing the kvm groveling
code.

ok deraadt@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.30 2016/09/27 22:03:49 deraadt Exp $ */
a102 1
		n = &kbdenc_tab[0];
d105 1
a105 1
		while (n->value) {
a109 1
			n++;
a112 1
		n = &kbdvar_tab[0];
d115 1
a115 1
		while (n->value) {
a119 1
			n++;
d247 1
a247 2
		n = &kbdvar_tab[0];
		while (n->value) {
a249 1
			n++;
@


1.30
log
@remove more kvm code
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.29 2016/09/26 21:19:02 kettenis Exp $ */
d37 1
d86 2
a87 1
void	kbd_show_enc(int idx);
d92 1
a92 1
kbd_show_enc(int idx)
d94 3
d102 27
a128 2
	for (i = 0; kbdenc_tab[i].value; i++)
		printf("%s\n", kbdenc_tab[i].name);
d133 20
d156 2
a157 1
	int	fd, i, kbtype;
d160 2
a161 1
	bzero(kbds, sizeof(kbds));
d175 1
a175 1
				kbds[SA_PCKBD]++;
d178 1
a178 1
				kbds[SA_UKBD]++;
d181 1
a181 1
				kbds[SA_AKBD]++;
d185 1
a185 1
				kbds[SA_LKKBD]++;
d188 1
a188 1
				kbds[SA_SUNKBD]++;
d191 1
a191 1
				kbds[SA_SUN5KBD]++;
d194 1
a194 1
				kbds[SA_HILKBD]++;
d197 1
a197 1
				kbds[SA_GSCKBD]++;
d200 4
a203 1
				kbds[SA_SGIKBD]++;
d206 6
d218 4
a221 1
			kbd_show_enc(i);
@


1.29
log
@Remove kvm groveling code.  To restore the lost functionality we need to
implement something like a WSKBDIO_GETENCODINGS ioctl that fetches a list
of possible encodings for the specified keyboard from the kernel.  Until
that happens, kbd -l will simple show the same harcoded list of possible
encodings as the installer does.

Prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.28 2015/01/16 06:39:59 deraadt Exp $ */
a33 1
#include <kvm.h>
a35 1
#include <nlist.h>
d85 1
a85 1
void	kbd_show_enc(kvm_t *kd, int idx);
d90 1
a90 1
kbd_show_enc(kvm_t *kd, int idx)
a107 1
	kvm_t	*kd = NULL;
d157 1
a157 1
			kbd_show_enc(kd, i);
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.27 2014/03/26 05:22:26 miod Exp $ */
a67 19
#ifndef NOKVM
struct nlist nl[] = {
	{ "_pckbd_keydesctab" },
	{ "_ukbd_keydesctab" },
	{ "_akbd_keydesctab" },
	{ "_lkkbd_keydesctab" },
	{ "_sunkbd_keydesctab" },
	{ "_sunkbd5_keydesctab" },
	{ "_hilkbd_keydesctab" },
	{ "_gsckbd_keydesctab" },
	{ "_wssgi_keydesctab" },
	{ NULL },
};
#endif /* NOKVM */

#ifndef NOKVM
int rebuild = 0;
#endif

a93 7
#ifndef NOKVM
	struct wscons_keydesc r;
	unsigned long p;
	int found;
	u_int32_t variant;
	struct nameint *n;
#else
a94 10
#endif /* NOKVM */

#ifndef NOKVM
	p = nl[idx].n_value;
	if (p == 0) {
		printf("no tables available for %s keyboard\n\n",
		    kbtype_tab[idx]);
		return;
	}
#endif
a98 1
#ifdef NOKVM
a100 35
#else
	kvm_read(kd, p, &r, sizeof(r));
	while (r.name != 0) {
		n = &kbdenc_tab[0];
		found = 0;
		while (n->value) {
			if (n->value == KB_ENCODING(r.name)) {
				printf("%s",n->name);
				found++;
			}
			n++;
		}
		if (found == 0) {
			printf("<encoding 0x%04x>",KB_ENCODING(r.name));
			rebuild++;
		}
		n = &kbdvar_tab[0];
		found = 0;
		variant = KB_VARIANT(r.name);
		while (n->value) {
			if ((n->value & KB_VARIANT(r.name)) == n->value) {
				printf(".%s",n->name);
				variant &= ~n->value;
			}
			n++;
		}
		if (variant != 0) {
			printf(".<variant 0x%08x>",variant);
			rebuild++;
		}
		printf("\n");
		p += sizeof(r);
		kvm_read(kd, p, &r, sizeof(r));
	}
#endif
a110 3
#ifndef NOKVM
	char	errbuf[LINE_MAX];
#endif
a157 8
#ifndef NOKVM
	if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL)
		errx(1, "kvm_openfiles: %s", errbuf);

	if (kvm_nlist(kd, nl) == -1)
		errx(1, "kvm_nlist: %s", kvm_geterr(kd));
#endif

a160 6

#ifndef NOKVM
	kvm_close(kd);
	if (rebuild > 0)
		printf("Unknown encoding or variant. kbd(8) needs to be rebuilt.\n");
#endif
@


1.27
log
@Drop Apollo Domain keyboard support, now that hp300 has bitten the dust.
Replace it with SGI serial keyboard support (zskbd@@zs@@hpc).
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.26 2012/07/13 10:15:19 shadchin Exp $ */
a26 1
#include <sys/param.h>
d181 1
a181 1
	char	device[MAXPATHLEN];
@


1.26
log
@Use NULL instead of 0 for pointers

ok gilles@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.25 2008/06/23 17:41:21 miod Exp $ */
d54 1
a54 1
	"domain"
d64 1
a64 1
	SA_DOMAINKBD,
d79 1
a79 1
	{ "_dnkbd_keydesctab" },
d226 2
a227 2
			case WSKBD_TYPE_DOMAIN:
				kbds[SA_DOMAINKBD]++;
@


1.25
log
@Do not compile the ``kbd needs to be rebuilt'' test if -DNOKVM. Should shave
a few bytes off the installation media filesystems.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.24 2006/07/31 22:09:37 miod Exp $ */
d96 1
a96 1
	{ 0, 0 }
d102 1
a102 1
	{ 0, 0 }
d235 1
a235 1
	if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == 0)
@


1.24
log
@Now that we can report either LK201 or LK401 as the keyboard type, do the
right thing there.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.23 2005/05/07 15:31:23 miod Exp $ */
d84 1
d86 1
a247 1
#endif
d250 1
@


1.23
log
@Add support for the domain keyboards, and simplify the kbd -l logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.22 2005/05/07 15:14:00 miod Exp $ */
d59 1
a59 1
	SA_ZSKBD,
d74 1
a74 1
	{ "_zskbd_keydesctab" },
d209 2
a210 1
				kbds[SA_ZSKBD]++;
@


1.22
log
@Check for kvm_nlist failure to retrieve all keyboard map symbols, and do
not dispaly garbage in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.21 2005/03/27 05:21:19 deraadt Exp $ */
d54 13
a67 8
#define SA_PCKBD 0
#define SA_UKBD  1
#define SA_AKBD	 2
#define SA_ZSKBD 3
#define SA_SUNKBD 4
#define SA_SUN5KBD 5
#define SA_HILKBD 6
#define	SA_GSCKBD 7
d79 1
d178 2
a179 3
	int	pc_kbd = 0, usb_kbd = 0, adb_kbd = 0;
	int	zs_kbd = 0, sun_kbd = 0, sun5_kbd = 0;
	int	hil_kbd = 0, gsc_kbd = 0, fd, i, kbtype;
d186 2
d197 30
a226 17
			if (kbtype == WSKBD_TYPE_PC_XT ||
			    kbtype == WSKBD_TYPE_PC_AT)
				pc_kbd++;
			if (kbtype == WSKBD_TYPE_USB)
				usb_kbd++;
			if (kbtype == WSKBD_TYPE_ADB)
				adb_kbd++;
			if (kbtype == WSKBD_TYPE_LK201)
				zs_kbd++;
			if (kbtype == WSKBD_TYPE_SUN)
				sun_kbd++;
			if (kbtype == WSKBD_TYPE_SUN5)
				sun5_kbd++;
			if (kbtype == WSKBD_TYPE_HIL)
				hil_kbd++;
			if (kbtype == WSKBD_TYPE_GSC)
				gsc_kbd++;
d239 4
a242 16
	if (pc_kbd > 0)
		kbd_show_enc(kd, SA_PCKBD);
	if (usb_kbd > 0)
		kbd_show_enc(kd, SA_UKBD);
	if (adb_kbd > 0)
		kbd_show_enc(kd, SA_AKBD);
	if (zs_kbd > 0)
		kbd_show_enc(kd, SA_ZSKBD);
	if (sun_kbd > 0)
		kbd_show_enc(kd, SA_SUNKBD);
	if (sun5_kbd > 0)
		kbd_show_enc(kd, SA_SUN5KBD);
	if (hil_kbd > 0)
		kbd_show_enc(kd, SA_HILKBD);
	if (gsc_kbd > 0)
		kbd_show_enc(kd, SA_GSCKBD);
@


1.21
log
@provide enough of a -l mode in non-kvm snooping mode, and krw can shrink
the install script even more
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.20 2004/10/08 19:30:31 jaredy Exp $ */
d116 9
a131 1
	p = nl[idx].n_value;
@


1.20
log
@it's kbd(8) not kbd(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.19 2004/10/08 17:26:35 millert Exp $ */
d45 10
d76 1
a76 11

char *kbtype_tab[] = {
	"pc-xt/pc-at",
	"usb",
	"adb",
	"lk201",
	"sun",
	"sun5",
	"hil",
	"gsc",
};
a79 2
#endif /* NOKVM */

a102 1
#ifndef NOKVM
d106 1
a108 1
	struct nameint *n;
d111 4
d117 6
a122 1
	       kbtype_tab[idx]);
d157 1
a159 1
#endif
d164 5
a168 1
	int	fd, i, kbtype;
a169 1
	kvm_t	*kd;
a171 9
	char	device[MAXPATHLEN];
	int	pc_kbd = 0;
	int	usb_kbd = 0;
	int	adb_kbd = 0;
	int	zs_kbd = 0;
	int	sun_kbd = 0;
	int	sun5_kbd = 0;
	int	hil_kbd = 0;
	int	gsc_kbd = 0;
d182 2
a183 2
			if ((kbtype == WSKBD_TYPE_PC_XT) ||
			    (kbtype == WSKBD_TYPE_PC_AT))
d209 1
a212 1

a214 1

a216 1

a218 1

a220 1

a222 1

a224 1

d227 1
a227 1

d229 2
a230 2

	if (rebuild > 0) {
a231 4
	}
#else
	printf("List not available; sorry.\n");
#endif
d237 2
a238 2
	char	buf[LINE_MAX];
	char	*c,*b;
a239 2
	int	map = 0,v,i,fd;
	char	device[sizeof "/dev/wskbd00"];
d243 1
a243 2
	while ((*c != '.') && (*c != '\0') &&
	    (b < buf + sizeof(buf) - 1)) {
a244 1
	}
d248 1
a248 1
		if (strcmp(n->name,buf) == 0) {
a249 1
		}
d257 1
a257 2
		while ((*c != '.') && (*c != '\0') &&
		    (b < buf + sizeof(buf) - 1)) {
a258 1
		}
d263 1
a263 1
			if (strcmp(n->name,buf) == 0) {
a264 1
			}
d285 1
a285 1
				} else {
a286 1
				}
@


1.19
log
@Use LINE_MAX, not _POSIX2_LINE_MAX.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.18 2004/10/08 13:23:41 jaredy Exp $ */
d237 1
a237 1
		printf("Unknown encoding or variant. kbd(1) needs to be rebuilt.\n");
@


1.18
log
@fix an overflow in the encoding/variant parsing.  ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.17 2004/09/16 09:53:56 deraadt Exp $ */
d161 1
a161 1
	char	errbuf[_POSIX2_LINE_MAX];
d247 1
a247 1
	char	buf[_POSIX2_LINE_MAX];
@


1.17
log
@shrink the code in the -DNOKVM case
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.16 2004/05/09 03:21:52 deraadt Exp $ */
d255 2
a256 1
	while ((*c != '.') && (*c != '\0')) {
d272 2
a273 1
		while ((*c != '.') && (*c != '\0')) {
@


1.16
log
@lint says toss unused variable away
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.15 2003/07/10 00:00:57 david Exp $ */
d54 1
d78 4
a99 1
int rebuild = 0;
d159 1
d161 2
a163 1
	char	errbuf[_POSIX2_LINE_MAX];
d312 1
a312 1
		fprintf(stderr, "keyboard mapping set to %s\n", name);
@


1.15
log
@add missing includes
ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.14 2003/07/02 21:44:58 deraadt Exp $ */
d154 1
a154 1
	int	fd, i, kbtype, ret;
d198 1
a198 1
	if ((kd = kvm_openfiles(NULL,NULL,NULL,O_RDONLY, errbuf)) == 0)
d201 1
a201 1
	if ((ret = kvm_nlist(kd, nl)) == -1)
@


1.14
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.13 2003/06/02 21:10:37 maja Exp $ */
d40 1
@


1.13
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.12 2003/03/30 19:10:00 jsyn Exp $ */
d95 4
@


1.12
log
@typos/grammar

these are the only instances of s/WSKBD/WDKBD/ needed
in the tree; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.11 2003/02/16 02:08:02 miod Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.11
log
@Provide a wskbd type for gsc keyboards, make gsckbd use it, and take advantage
of it in kbd(8) to work correctly with such a keyboard.
Reminded by maja some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.10 2003/02/12 09:00:40 maja Exp $ */
d175 1
a175 1
				err(1, "WDKBDIO_GTYPE");
d231 1
a231 1
		printf("Unknown encoding or variant. kbd(1) needs to be rebuild.\n");
d234 1
a234 1
	printf("List not available, sorry.\n");
d296 1
a296 1
					err(1, "WDKBDIO_SETENCODING: %s", device);
@


1.10
log
@Add support for WSKBD_TYPE_HIL. -moj ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.9 2002/07/03 22:32:33 deraadt Exp $ */
d56 1
d66 1
d78 1
d165 1
d191 2
d224 3
@


1.9
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.8 2002/05/29 20:45:58 maja Exp $ */
d55 1
d64 1
d75 1
d161 1
d185 2
d215 3
@


1.8
log
@Add support for WSKBD_TYPE_SUN5. -moj ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.7 2002/05/22 08:21:02 deraadt Exp $ */
d97 1
a97 3
kbd_show_enc(kd, idx)
	kvm_t *kd;
	int idx;
d146 1
a146 1
kbd_list()
d221 1
a221 3
kbd_set(name, verbose)
	char *name;
	int verbose;
@


1.7
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.6 2002/04/12 02:16:01 deraadt Exp $ */
d54 1
d62 1
d72 1
d159 1
d181 2
d208 3
@


1.6
log
@kbd setting code for the installer.  kbd needs to be compiled without KVM
support.  smat@@acm.org, miod, and krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.5 2002/02/19 01:49:58 maja Exp $ */
d32 1
d54 1
a54 1
	
d107 1
a107 1
	kvm_read(kd, p, &r, sizeof(r)); 
d111 1
a111 1
		while(n->value) {
d114 1
a114 1
				found++; 
d125 1
a125 1
		while(n->value) {
d138 1
a138 1
		kvm_read(kd, p, &r, sizeof(r)); 
d149 1
a149 1
	char	device[sizeof "/dev/wskbd00"];
d159 1
a159 1
		(void) sprintf(device, "/dev/wskbd%d", i);
d168 1
a168 1
		  		pc_kbd++;
d187 1
a187 1
	
d204 1
a204 1
	
d226 1
a226 1
	while((*c != '.') && (*c != '\0')) {
d231 1
a231 1
	while(n->value) {
d239 1
a239 1
	while(*c == '.') {
d242 1
a242 1
		while((*c != '.') && (*c != '\0')) {
d248 1
a248 1
		while(n->value) {
d262 1
a262 1
		(void) sprintf(device, "/dev/wskbd%d", i);
d269 3
a271 2
					fprintf(stderr, "%s: unsupported encoding %s on %s\n",
						__progname, name, device);
@


1.5
log
@Add support for sparc64 and sun keyboards. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.4 2001/07/07 18:26:14 deraadt Exp $ */
d91 1
d141 1
d180 1
d207 3
@


1.4
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.3 2001/06/04 20:05:06 maja Exp $ */
d52 1
d59 1
d68 1
d152 1
d172 2
d195 3
@


1.3
log
@Add support for vax lk201 keyboard. Add code to check if new variants or
encodings exists in kernel. If so suggest to rebuild kbd(1). -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.2 2001/05/04 15:49:10 millert Exp $ */
d32 5
d44 1
a44 4
#include <sys/ioctl.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymdef.h>
d97 1
a97 1
	long variant;
@


1.2
log
@Typo in error string; grange@@rt.mipt.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.1 2001/03/08 08:00:16 maja Exp $ */
d49 1
d55 1
d63 1
d84 1
d94 2
d103 1
d107 1
d111 4
d116 2
d121 1
d125 4
d146 1
d164 2
d169 1
a169 1
	
d185 3
d189 4
@


1.1
log
@Add support for wscons. Support for PC, USB and ADB keyboards.
Enabled for i386 and powerpc. This makes it possible to list
which encodings are known by the kernel.

kbd_wscons.c needs struct wscons_keydesc from the newly commited
<dev/wscons/wsksymvar.h>. -moj  ok @@aaron
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d191 1
a191 1
		errx(1, "unknown encodeing %s", buf);
@

