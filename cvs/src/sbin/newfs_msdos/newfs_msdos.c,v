head	1.27;
access;
symbols
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.15.0.12
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Cz19p5I1S6mVZIjV;

1.26
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	6b2lLILbgCR1fvia;

1.25
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2014.07.10.20.09.53;	author tobias;	state Exp;
branches;
next	1.23;
commitid	2g7Mh3EpDqqknr0G;

1.23
date	2014.07.10.19.31.07;	author tobias;	state Exp;
branches;
next	1.22;
commitid	KV1FGZS0cSWxDW7c;

1.22
date	2013.11.22.04.14.01;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.05.00.51.58;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.27.18.11.07;	author halex;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.28.09.57.01;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.26.18.49.03;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.01.04.08.45;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.29.09.19.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.21.07.32.55;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.07.18.26.17;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.06.22.52.13;	author imp;	state Exp;
branches;
next	1.9;

1.9
date	99.04.10.04.22.46;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.30.13.51.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.14.12.07.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.03.29.20.01.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.03.22.02.51.06;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.41.32;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.10.19.04.10;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.04.08.33.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.06.10.06.37.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@/*	$OpenBSD: newfs_msdos.c,v 1.26 2015/04/18 18:28:37 deraadt Exp $	*/

/*
 * Copyright (c) 1998 Robert Nordier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>	/* powerof2 */
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/mount.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define MAXU16	  0xffff	/* maximum unsigned 16-bit quantity */
#define BPN	  4		/* bits per nibble */
#define NPB	  2		/* nibbles per byte */

#define DOSMAGIC  0xaa55	/* DOS magic number */
#define MINBPS	  512		/* minimum bytes per sector */
#define MAXSPC	  128		/* maximum sectors per cluster */
#define MAXNFT	  16		/* maximum number of FATs */
#define DEFBLK	  4096		/* default block size */
#define DEFBLK16  2048		/* default block size FAT16 */
#define DEFRDE	  512		/* default root directory entries */
#define RESFTE	  2		/* reserved FAT entries */
#define MINCLS12  1		/* minimum FAT12 clusters */
#define MINCLS16  0x1000	/* minimum FAT16 clusters */
#define MINCLS32  2		/* minimum FAT32 clusters */
#define MAXCLS12  0xfed		/* maximum FAT12 clusters */
#define MAXCLS16  0xfff5	/* maximum FAT16 clusters */
#define MAXCLS32  0xffffff5	/* maximum FAT32 clusters */

#define mincls(fat)  ((fat) == 12 ? MINCLS12 :	\
		      (fat) == 16 ? MINCLS16 :	\
				    MINCLS32)

#define maxcls(fat)  ((fat) == 12 ? MAXCLS12 :	\
		      (fat) == 16 ? MAXCLS16 :	\
				    MAXCLS32)

#define mk1(p, x)				\
    (p) = (u_int8_t)(x)

#define mk2(p, x)				\
    (p)[0] = (u_int8_t)(x),			\
    (p)[1] = (u_int8_t)((x) >> 010)

#define mk4(p, x)				\
    (p)[0] = (u_int8_t)(x),			\
    (p)[1] = (u_int8_t)((x) >> 010),		\
    (p)[2] = (u_int8_t)((x) >> 020),		\
    (p)[3] = (u_int8_t)((x) >> 030)

#define argto1(arg, lo, msg)  argtou(arg, lo, 0xff, msg)
#define argto2(arg, lo, msg)  argtou(arg, lo, 0xffff, msg)
#define argto4(arg, lo, msg)  argtou(arg, lo, 0xffffffff, msg)
#define argtox(arg, lo, msg)  argtou(arg, lo, UINT_MAX, msg)

struct bs {
    u_int8_t jmp[3];		/* bootstrap entry point */
    u_int8_t oem[8];		/* OEM name and version */
};

struct bsbpb {
    u_int8_t bps[2];		/* bytes per sector */
    u_int8_t spc;		/* sectors per cluster */
    u_int8_t res[2];		/* reserved sectors */
    u_int8_t nft;		/* number of FATs */
    u_int8_t rde[2];		/* root directory entries */
    u_int8_t sec[2];		/* total sectors */
    u_int8_t mid;		/* media descriptor */
    u_int8_t spf[2];		/* sectors per FAT */
    u_int8_t spt[2];		/* sectors per track */
    u_int8_t hds[2];		/* drive heads */
    u_int8_t hid[4];		/* hidden sectors */
    u_int8_t bsec[4];		/* big total sectors */
};

struct bsxbpb {
    u_int8_t bspf[4];		/* big sectors per FAT */
    u_int8_t xflg[2];		/* FAT control flags */
    u_int8_t vers[2];		/* file system version */
    u_int8_t rdcl[4];		/* root directory start cluster */
    u_int8_t infs[2];		/* file system info sector */
    u_int8_t bkbs[2];		/* backup boot sector */
    u_int8_t rsvd[12];		/* reserved */
};

struct bsx {
    u_int8_t drv;		/* drive number */
    u_int8_t rsvd;		/* reserved */
    u_int8_t sig;		/* extended boot signature */
    u_int8_t volid[4];		/* volume ID number */
    u_int8_t label[11];		/* volume label */
    u_int8_t type[8];		/* file system type */
};

struct de {
    u_int8_t namext[11];	/* name and extension */
    u_int8_t attr;		/* attributes */
    u_int8_t rsvd[10];		/* reserved */
    u_int8_t time[2];		/* creation time */
    u_int8_t date[2];		/* creation date */
    u_int8_t clus[2];		/* starting cluster */
    u_int8_t size[4];		/* size */
};

struct bpb {
    u_int bps;			/* bytes per sector */
    u_int spc;			/* sectors per cluster */
    u_int res;			/* reserved sectors */
    u_int nft;			/* number of FATs */
    u_int rde;			/* root directory entries */
    u_int sec;			/* total sectors */
    u_int mid;			/* media descriptor */
    u_int spf;			/* sectors per FAT */
    u_int spt;			/* sectors per track */
    u_int hds;			/* drive heads */
    u_int hid;			/* hidden sectors */
    u_int bsec;			/* big total sectors */
    u_int bspf;			/* big sectors per FAT */
    u_int rdcl; 		/* root directory start cluster */
    u_int infs; 		/* file system info sector */
    u_int bkbs; 		/* backup boot sector */
};

static struct {
    const char *name;
    struct bpb bpb;
} stdfmt[] = {
    {"160",  {512, 1, 1, 2,  64,  320, 0xfe, 1,  8, 1}},
    {"180",  {512, 1, 1, 2,  64,  360, 0xfc, 2,  9, 1}},
    {"320",  {512, 2, 1, 2, 112,  640, 0xff, 1,  8, 2}},
    {"360",  {512, 2, 1, 2, 112,  720, 0xfd, 2,  9, 2}},
    {"720",  {512, 2, 1, 2, 112, 1440, 0xf9, 3,  9, 2}},
    {"1200", {512, 1, 1, 2, 224, 2400, 0xf9, 7, 15, 2}},
    {"1440", {512, 1, 1, 2, 224, 2880, 0xf0, 9, 18, 2}},
    {"2880", {512, 2, 1, 2, 240, 5760, 0xf0, 9, 36, 2}}
};

static u_int8_t bootcode[] = {
    0xfa,			/* cli		    */
    0x31, 0xc0, 		/* xor	   ax,ax    */
    0x8e, 0xd0, 		/* mov	   ss,ax    */
    0xbc, 0x00, 0x7c,		/* mov	   sp,7c00h */
    0xfb,			/* sti		    */
    0x8e, 0xd8, 		/* mov	   ds,ax    */
    0xe8, 0x00, 0x00,		/* call    $ + 3    */
    0x5e,			/* pop	   si	    */
    0x83, 0xc6, 0x19,		/* add	   si,+19h  */
    0xbb, 0x07, 0x00,		/* mov	   bx,0007h */
    0xfc,			/* cld		    */
    0xac,			/* lodsb	    */
    0x84, 0xc0, 		/* test    al,al    */
    0x74, 0x06, 		/* jz	   $ + 8    */
    0xb4, 0x0e, 		/* mov	   ah,0eh   */
    0xcd, 0x10, 		/* int	   10h	    */
    0xeb, 0xf5, 		/* jmp	   $ - 9    */
    0x30, 0xe4, 		/* xor	   ah,ah    */
    0xcd, 0x16, 		/* int	   16h	    */
    0xcd, 0x19, 		/* int	   19h	    */
    0x0d, 0x0a,
    'N', 'o', 'n', '-', 's', 'y', 's', 't',
    'e', 'm', ' ', 'd', 'i', 's', 'k',
    0x0d, 0x0a,
    'P', 'r', 'e', 's', 's', ' ', 'a', 'n',
    'y', ' ', 'k', 'e', 'y', ' ', 't', 'o',
    ' ', 'r', 'e', 'b', 'o', 'o', 't',
    0x0d, 0x0a,
    0
};

static void check_mounted(const char *, mode_t);
static void getstdfmt(const char *, struct bpb *);
static void getdiskinfo(int, const char *, const char *, int,
			struct bpb *);
static void print_bpb(struct bpb *);
static u_int ckgeom(const char *, u_int, const char *);
static u_int argtou(const char *, u_int, u_int, const char *);
static int oklabel(const char *);
static void mklabel(u_int8_t *, const char *);
static void setstr(u_int8_t *, const char *, size_t);
static __dead void usage(void);

/*
 * Construct a FAT12, FAT16, or FAT32 file system.
 */
int
main(int argc, char *argv[])
{
    static char opts[] = "NB:F:I:L:O:S:a:b:c:e:f:h:i:k:m:n:o:qr:s:t:u:";
    static const char *opt_B, *opt_L, *opt_O, *opt_f;
    static u_int opt_F, opt_I, opt_S, opt_a, opt_b, opt_c, opt_e;
    static u_int opt_h, opt_i, opt_k, opt_m, opt_n, opt_o, opt_r;
    static u_int opt_s, opt_u;
    static int opt_N;
    static int Iflag, mflag, oflag;
    char buf[PATH_MAX];
    struct stat sb;
    struct timeval tv;
    struct bpb bpb;
    struct tm *tm;
    struct bs *bs;
    struct bsbpb *bsbpb;
    struct bsxbpb *bsxbpb;
    struct bsx *bsx;
    struct de *de;
    u_int8_t *img;
    const char *dtype, *bname;
    char *sname, *fname;
    ssize_t n;
    time_t now;
    u_int fat, bss, rds, cls, dir, lsn, x, x1, x2;
    int ch, fd, fd1;

    if (pledge("stdio rpath wpath disklabel", NULL) == -1)
	err(1, "pledge");

    while ((ch = getopt(argc, argv, opts)) != -1)
	switch (ch) {
	case 'N':
	    opt_N = 1;
	    break;
	case 'B':
	    opt_B = optarg;
	    break;
	case 'F':
	    opt_F = strtonum(optarg, 1, INT_MAX, NULL);
	    if (!(opt_F == 12 || opt_F == 16 || opt_F == 32))
		errx(1, "%s: bad FAT type", optarg);
	    break;
	case 'I':
	    opt_I = argto4(optarg, 0, "volume ID");
	    Iflag = 1;
	    break;
	case 'L':
	    if (!oklabel(optarg))
		errx(1, "%s: bad volume label", optarg);
	    opt_L = optarg;
	    break;
	case 'O':
	    if (strlen(optarg) > 8)
		errx(1, "%s: bad OEM string", optarg);
	    opt_O = optarg;
	    break;
	case 'S':
	    opt_S = argto2(optarg, 1, "bytes/sector");
	    break;
	case 'a':
	    opt_a = argto4(optarg, 1, "sectors/FAT");
	    break;
	case 'b':
	    opt_b = argtox(optarg, 1, "block size");
	    opt_c = 0;
	    break;
	case 'c':
	    opt_c = argto1(optarg, 1, "sectors/cluster");
	    opt_b = 0;
	    break;
	case 'e':
	    opt_e = argto2(optarg, 1, "directory entries");
	    break;
	case 'f':
	    opt_f = optarg;
	    break;
	case 'h':
	    opt_h = argto2(optarg, 1, "drive heads");
	    break;
	case 'i':
	    opt_i = argto2(optarg, 1, "info sector");
	    break;
	case 'k':
	    opt_k = argto2(optarg, 1, "backup sector");
	    break;
	case 'm':
	    opt_m = argto1(optarg, 0, "media descriptor");
	    mflag = 1;
	    break;
	case 'n':
	    opt_n = argto1(optarg, 1, "number of FATs");
	    break;
	case 'o':
	    opt_o = argto4(optarg, 0, "hidden sectors");
	    oflag = 1;
	    break;
	case 'q':			/* Compat with newfs -q */
	    break;
	case 'r':
	    opt_r = argto2(optarg, 1, "reserved sectors");
	    break;
	case 's':
	    opt_s = argto4(optarg, 1, "file system size");
	    break;
	case 't':			/* Compat with newfs -t */
	    break;
	case 'u':
	    opt_u = argto2(optarg, 1, "sectors/track");
	    break;
	default:
	    usage();
	}
    argc -= optind;
    argv += optind;
    if (argc < 1 || argc > 2)
	usage();
    sname = *argv++;
    dtype = *argv;
    if ((fd = opendev(sname, opt_N ? O_RDONLY : O_RDWR, 0, &fname)) == -1 ||
	fstat(fd, &sb))
	err(1, "%s", fname);
    if (!opt_N)
	check_mounted(fname, sb.st_mode);
    if (S_ISBLK(sb.st_mode))
	errx(1, "%s: block device", fname);
    if (!S_ISCHR(sb.st_mode))
	warnx("warning: %s is not a character device", fname);
    memset(&bpb, 0, sizeof(bpb));
    if (opt_f) {
	getstdfmt(opt_f, &bpb);
	bpb.bsec = bpb.sec;
	bpb.sec = 0;
	bpb.bspf = bpb.spf;
	bpb.spf = 0;
    }
    if (opt_h)
	bpb.hds = opt_h;
    if (opt_u)
	bpb.spt = opt_u;
    if (opt_S)
	bpb.bps = opt_S;
    if (opt_s)
	bpb.bsec = opt_s;
    if (oflag)
	bpb.hid = opt_o;
    if (!(opt_f || (opt_h && opt_u && opt_S && opt_s && oflag)))
	getdiskinfo(fd, fname, dtype, oflag, &bpb);
    if (!powerof2(bpb.bps))
	errx(1, "bytes/sector (%u) is not a power of 2", bpb.bps);
    if (bpb.bps < MINBPS)
	errx(1, "bytes/sector (%u) is too small; minimum is %u",
	     bpb.bps, MINBPS);
    if (!(fat = opt_F)) {
	if (opt_f)
	    fat = 12;
	else if (!opt_e && (opt_i || opt_k))
	    fat = 32;
    }
    if ((fat == 32 && opt_e) || (fat != 32 && (opt_i || opt_k)))
	errx(1, "-%c is not a legal FAT%s option",
	     fat == 32 ? 'e' : opt_i ? 'i' : 'k',
	     fat == 32 ? "32" : "12/16");
    if (opt_f && fat == 32)
	bpb.rde = 0;
    if (opt_b) {
	if (!powerof2(opt_b))
	    errx(1, "block size (%u) is not a power of 2", opt_b);
	if (opt_b < bpb.bps)
	    errx(1, "block size (%u) is too small; minimum is %u",
		 opt_b, bpb.bps);
	if (opt_b > bpb.bps * MAXSPC)
	    errx(1, "block size (%u) is too large; maximum is %u",
		 opt_b, bpb.bps * MAXSPC);
	bpb.spc = opt_b / bpb.bps;
    }
    if (opt_c) {
	if (!powerof2(opt_c))
	    errx(1, "sectors/cluster (%u) is not a power of 2", opt_c);
	bpb.spc = opt_c;
    }
    if (opt_r)
	bpb.res = opt_r;
    if (opt_n) {
	if (opt_n > MAXNFT)
	    errx(1, "number of FATs (%u) is too large; maximum is %u",
		 opt_n, MAXNFT);
	bpb.nft = opt_n;
    }
    if (opt_e)
	bpb.rde = opt_e;
    if (mflag) {
	if (opt_m < 0xf0)
	    errx(1, "illegal media descriptor (%#x)", opt_m);
	bpb.mid = opt_m;
    }
    if (opt_a)
	bpb.bspf = opt_a;
    if (opt_i)
	bpb.infs = opt_i;
    if (opt_k)
	bpb.bkbs = opt_k;
    bss = 1;
    bname = NULL;
    fd1 = -1;
    if (opt_B) {
	bname = opt_B;
	if (!strchr(bname, '/')) {
	    snprintf(buf, sizeof(buf), "/boot/%s", bname);
	    if (!(bname = strdup(buf)))
		err(1, NULL);
	}
	if ((fd1 = open(bname, O_RDONLY)) == -1 || fstat(fd1, &sb))
	    err(1, "%s", bname);
	if (!S_ISREG(sb.st_mode) || sb.st_size % bpb.bps ||
	    sb.st_size < bpb.bps || sb.st_size > bpb.bps * MAXU16)
	    errx(1, "%s: inappropriate file type or format", bname);
	bss = sb.st_size / bpb.bps;
    }
    if (!bpb.nft)
	bpb.nft = 2;
    if (!fat) {
	if (bpb.bsec < (bpb.res ? bpb.res : bss) +
	    howmany((RESFTE + (bpb.spc ? MINCLS16 : MAXCLS12 + 1)) *
		    ((bpb.spc ? 16 : 12) / BPN), bpb.bps * NPB) *
	    bpb.nft +
	    howmany(bpb.rde ? bpb.rde : DEFRDE,
		    bpb.bps / sizeof(struct de)) +
	    (bpb.spc ? MINCLS16 : MAXCLS12 + 1) *
	    (bpb.spc ? bpb.spc : howmany(DEFBLK, bpb.bps)))
	    fat = 12;
	else if (bpb.rde || bpb.bsec <
		 (bpb.res ? bpb.res : bss) +
		 howmany((RESFTE + MAXCLS16) * 2, bpb.bps) * bpb.nft +
		 howmany(DEFRDE, bpb.bps / sizeof(struct de)) +
		 (MAXCLS16 + 1) *
		 (bpb.spc ? bpb.spc : howmany(8192, bpb.bps)))
	    fat = 16;
	else
	    fat = 32;
    }
    x = bss;
    if (fat == 32) {
	if (!bpb.infs) {
	    if (x == MAXU16 || x == bpb.bkbs)
		errx(1, "no room for info sector");
	    bpb.infs = x;
	}
	if (bpb.infs != MAXU16 && x <= bpb.infs)
	    x = bpb.infs + 1;
	if (!bpb.bkbs) {
	    if (x == MAXU16)
		errx(1, "no room for backup sector");
	    bpb.bkbs = x;
	} else if (bpb.bkbs != MAXU16 && bpb.bkbs == bpb.infs)
	    errx(1, "backup sector would overwrite info sector");
	if (bpb.bkbs != MAXU16 && x <= bpb.bkbs)
	    x = bpb.bkbs + 1;
    }
    if (!bpb.res)
	bpb.res = fat == 32 ? MAXIMUM(x, MAXIMUM(16384 / bpb.bps, 4)) : x;
    else if (bpb.res < x)
	errx(1, "too few reserved sectors");
    if (fat != 32 && !bpb.rde)
	bpb.rde = DEFRDE;
    rds = howmany(bpb.rde, bpb.bps / sizeof(struct de));
    if (!bpb.spc)
	for (bpb.spc = howmany(fat == 16 ? DEFBLK16 : DEFBLK, bpb.bps);
	     bpb.spc < MAXSPC &&
	     bpb.res +
	     howmany((RESFTE + maxcls(fat)) * (fat / BPN),
		     bpb.bps * NPB) * bpb.nft +
	     rds +
	     (u_int64_t)(maxcls(fat) + 1) * bpb.spc <= bpb.bsec;
	     bpb.spc <<= 1);
    if (fat != 32 && bpb.bspf > MAXU16)
	errx(1, "too many sectors/FAT for FAT12/16");
    x1 = bpb.res + rds;
    x = bpb.bspf ? bpb.bspf : 1;
    if (x1 + (u_int64_t)x * bpb.nft > bpb.bsec)
	errx(1, "meta data exceeds file system size");
    x1 += x * bpb.nft;
    x = (u_int64_t)(bpb.bsec - x1) * bpb.bps * NPB /
	(bpb.spc * bpb.bps * NPB + fat / BPN * bpb.nft);
    x2 = howmany((RESFTE + MINIMUM(x, maxcls(fat))) * (fat / BPN),
		 bpb.bps * NPB);
    if (!bpb.bspf) {
	bpb.bspf = x2;
	x1 += (bpb.bspf - 1) * bpb.nft;
    }
    cls = (bpb.bsec - x1) / bpb.spc;
    x = (u_int64_t)bpb.bspf * bpb.bps * NPB / (fat / BPN) - RESFTE;
    if (cls > x)
	cls = x;
    if (bpb.bspf < x2)
	warnx("warning: sectors/FAT limits file system to %u clusters",
	      cls);
    if (cls < mincls(fat))
	errx(1, "%u clusters too few clusters for FAT%u, need %u", cls, fat,
	    mincls(fat));
    if (cls > maxcls(fat)) {
	cls = maxcls(fat);
	bpb.bsec = x1 + (cls + 1) * bpb.spc - 1;
	warnx("warning: FAT type limits file system to %u sectors",
	      bpb.bsec);
    }
    printf("%s: %u sector%s in %u FAT%u cluster%s "
	   "(%u bytes/cluster)\n", fname, cls * bpb.spc,
	   cls * bpb.spc == 1 ? "" : "s", cls, fat,
	   cls == 1 ? "" : "s", bpb.bps * bpb.spc);
    if (!bpb.mid)
	bpb.mid = !bpb.hid ? 0xf0 : 0xf8;
    if (fat == 32)
	bpb.rdcl = RESFTE;
    if (bpb.hid + bpb.bsec <= MAXU16) {
	bpb.sec = bpb.bsec;
	bpb.bsec = 0;
    }
    if (fat != 32) {
	bpb.spf = bpb.bspf;
	bpb.bspf = 0;
    }
    print_bpb(&bpb);
    if (!opt_N) {
	gettimeofday(&tv, NULL);
	now = tv.tv_sec;
	tm = localtime(&now);
	if (!(img = malloc(bpb.bps)))
	    err(1, NULL);
	dir = bpb.res + (bpb.spf ? bpb.spf : bpb.bspf) * bpb.nft;
	for (lsn = 0; lsn < dir + (fat == 32 ? bpb.spc : rds); lsn++) {
	    x = lsn;
	    if (opt_B &&
		fat == 32 && bpb.bkbs != MAXU16 &&
		bss <= bpb.bkbs && x >= bpb.bkbs) {
		x -= bpb.bkbs;
		if (!x && lseek(fd1, 0, SEEK_SET))
		    err(1, "%s", bname);
	    }
	    if (opt_B && x < bss) {
		if ((n = read(fd1, img, bpb.bps)) == -1)
		    err(1, "%s", bname);
		if (n != bpb.bps)
		    errx(1, "%s: can't read sector %u", bname, x);
	    } else
		memset(img, 0, bpb.bps);
	    if (!lsn ||
	      (fat == 32 && bpb.bkbs != MAXU16 && lsn == bpb.bkbs)) {
		x1 = sizeof(struct bs);
		bsbpb = (struct bsbpb *)(img + x1);
		mk2(bsbpb->bps, bpb.bps);
		mk1(bsbpb->spc, bpb.spc);
		mk2(bsbpb->res, bpb.res);
		mk1(bsbpb->nft, bpb.nft);
		mk2(bsbpb->rde, bpb.rde);
		mk2(bsbpb->sec, bpb.sec);
		mk1(bsbpb->mid, bpb.mid);
		mk2(bsbpb->spf, bpb.spf);
		mk2(bsbpb->spt, bpb.spt);
		mk2(bsbpb->hds, bpb.hds);
		mk4(bsbpb->hid, bpb.hid);
		mk4(bsbpb->bsec, bpb.bsec);
		x1 += sizeof(struct bsbpb);
		if (fat == 32) {
		    bsxbpb = (struct bsxbpb *)(img + x1);
		    mk4(bsxbpb->bspf, bpb.bspf);
		    mk2(bsxbpb->xflg, 0);
		    mk2(bsxbpb->vers, 0);
		    mk4(bsxbpb->rdcl, bpb.rdcl);
		    mk2(bsxbpb->infs, bpb.infs);
		    mk2(bsxbpb->bkbs, bpb.bkbs);
		    x1 += sizeof(struct bsxbpb);
		}
		bsx = (struct bsx *)(img + x1);
		mk1(bsx->sig, 0x29);
		if (Iflag)
		    x = opt_I;
		else
		    x = (((u_int)(1 + tm->tm_mon) << 8 |
			  (u_int)tm->tm_mday) +
			 ((u_int)tm->tm_sec << 8 |
			  (u_int)(tv.tv_usec / 10))) << 16 |
			((u_int)(1900 + tm->tm_year) +
			 ((u_int)tm->tm_hour << 8 |
			  (u_int)tm->tm_min));
		mk4(bsx->volid, x);
		mklabel(bsx->label, opt_L ? opt_L : "NO NAME");
		snprintf(buf, sizeof buf, "FAT%u", fat);
		setstr(bsx->type, buf, sizeof(bsx->type));
		if (!opt_B) {
		    x1 += sizeof(struct bsx);
		    bs = (struct bs *)img;
		    mk1(bs->jmp[0], 0xeb);
		    mk1(bs->jmp[1], x1 - 2);
		    mk1(bs->jmp[2], 0x90);
		    setstr(bs->oem, opt_O ? opt_O : "BSD  4.4",
			   sizeof(bs->oem));
		    memcpy(img + x1, bootcode, sizeof(bootcode));
		    mk2(img + MINBPS - 2, DOSMAGIC);
		}
	    } else if (fat == 32 && bpb.infs != MAXU16 &&
		       (lsn == bpb.infs ||
			(bpb.bkbs != MAXU16 &&
			 lsn == bpb.bkbs + bpb.infs))) {
		mk4(img, 0x41615252);
		mk4(img + MINBPS - 28, 0x61417272);
		mk4(img + MINBPS - 24, 0xffffffff);
		mk4(img + MINBPS - 20, 0xffffffff);
		mk2(img + MINBPS - 2, DOSMAGIC);
	    } else if (lsn >= bpb.res && lsn < dir &&
		       !((lsn - bpb.res) %
			 (bpb.spf ? bpb.spf : bpb.bspf))) {
		mk1(img[0], bpb.mid);
		for (x = 1; x < fat * (fat == 32 ? 3 : 2) / 8; x++)
		    mk1(img[x], fat == 32 && x % 4 == 3 ? 0x0f : 0xff);
	    } else if (lsn == dir && opt_L) {
		de = (struct de *)img;
		mklabel(de->namext, opt_L);
		mk1(de->attr, 050);
		x = (u_int)tm->tm_hour << 11 |
		    (u_int)tm->tm_min << 5 |
		    (u_int)tm->tm_sec >> 1;
		mk2(de->time, x);
		x = (u_int)(tm->tm_year - 80) << 9 |
		    (u_int)(tm->tm_mon + 1) << 5 |
		    (u_int)tm->tm_mday;
		mk2(de->date, x);
	    }
	    if ((n = write(fd, img, bpb.bps)) == -1)
		err(1, "%s", fname);
	    if (n != bpb.bps)
		errx(1, "%s: can't write sector %u", fname, lsn);
	}
    }
    return 0;
}

/*
 * Exit with error if file system is mounted.
 */
static void
check_mounted(const char *fname, mode_t mode)
{
    struct statfs *mp;
    const char *s1, *s2;
    size_t len;
    int n, r;

    if (!(n = getmntinfo(&mp, MNT_NOWAIT)))
	err(1, "getmntinfo");
    len = sizeof(_PATH_DEV) - 1;
    s1 = fname;
    if (!strncmp(s1, _PATH_DEV, len))
	s1 += len;
    r = S_ISCHR(mode) && s1 != fname && *s1 == 'r';
    for (; n--; mp++) {
	s2 = mp->f_mntfromname;
	if (!strncmp(s2, _PATH_DEV, len))
	    s2 += len;
	if ((r && s2 != mp->f_mntfromname && !strcmp(s1 + 1, s2)) ||
	    !strcmp(s1, s2))
	    errx(1, "%s is mounted on %s", fname, mp->f_mntonname);
    }
}

/*
 * Get a standard format.
 */
static void
getstdfmt(const char *fmt, struct bpb *bpb)
{
    u_int x, i;

    x = sizeof(stdfmt) / sizeof(stdfmt[0]);
    for (i = 0; i < x && strcmp(fmt, stdfmt[i].name); i++);
    if (i == x)
	errx(1, "%s: unknown standard format", fmt);
    *bpb = stdfmt[i].bpb;
}

/*
 * Get disk slice, partition, and geometry information.
 */
static void
getdiskinfo(int fd, const char *fname, const char *dtype, int oflag,
	    struct bpb *bpb)
{
    struct disklabel dl, *lp;
    const char *s1, *s2;
    int part, i;

    part = -1;
    s1 = fname;
    if ((s2 = strrchr(s1, '/')))
	s1 = s2 + 1;
    for (s2 = s1; *s2 && !isdigit((unsigned char)*s2); s2++);
    if (!*s2 || s2 == s1)
	s2 = NULL;
    else
	while (isdigit((unsigned char)*++s2));
    s1 = s2;
    if (s2 && *s2 >= 'a' && *s2 <= 'a' + MAXPARTITIONS - 1) {
	part = *s2++ - 'a';
    }
    if (!s2 || (*s2 && *s2 != '.'))
	errx(1, "%s: can't figure out partition info", fname);
    if ((((!oflag && part != -1) || !bpb->bsec)) ||
	!bpb->bps || !bpb->spt || !bpb->hds) {
	lp = &dl;
	i = ioctl(fd, DIOCGDINFO, lp);
	if (i == -1) {
	    if (!dtype) {
		warn("ioctl (GDINFO)");
		errx(1, "%s: can't read disk label; "
		     "disk type must be specified", fname);
	    } else if (!(lp = getdiskbyname(dtype)))
		errx(1, "%s: unknown disk type", dtype);
	}
	if (part == -1)
	    part = RAW_PART;
	if (part >= lp->d_npartitions ||
	    !DL_GETPSIZE(&lp->d_partitions[part]))
	    errx(1, "%s: partition is unavailable", fname);
	if (!oflag && part != -1)
	    bpb->hid += DL_GETPOFFSET(&lp->d_partitions[part]);
	if (!bpb->bsec)
	    bpb->bsec = DL_GETPSIZE(&lp->d_partitions[part]);
	if (!bpb->bps)
	    bpb->bps = ckgeom(fname, lp->d_secsize, "bytes/sector");
	if (!bpb->spt)
	    bpb->spt = ckgeom(fname, lp->d_nsectors, "sectors/track");
	if (!bpb->hds)
	    bpb->hds = ckgeom(fname, lp->d_ntracks, "drive heads");
	if (bpb->spt > 63) {
	    bpb->hds = bpb->hds * bpb->spt / 63;
	    bpb->spt = 63;
	}
    }
}

/*
 * Print out BPB values.
 */
static void
print_bpb(struct bpb *bpb)
{
    printf("bps=%u spc=%u res=%u nft=%u", bpb->bps, bpb->spc, bpb->res,
	   bpb->nft);
    if (bpb->rde)
	printf(" rde=%u", bpb->rde);
    if (bpb->sec)
	printf(" sec=%u", bpb->sec);
    printf(" mid=%#x", bpb->mid);
    if (bpb->spf)
	printf(" spf=%u", bpb->spf);
    printf(" spt=%u hds=%u hid=%u", bpb->spt, bpb->hds, bpb->hid);
    if (bpb->bsec)
	printf(" bsec=%u", bpb->bsec);
    if (!bpb->spf) {
	printf(" bspf=%u rdcl=%u", bpb->bspf, bpb->rdcl);
	printf(" infs=");
	printf(bpb->infs == MAXU16 ? "%#x" : "%u", bpb->infs);
	printf(" bkbs=");
	printf(bpb->bkbs == MAXU16 ? "%#x" : "%u", bpb->bkbs);
    }
    printf("\n");
}

/*
 * Check a disk geometry value.
 */
static u_int
ckgeom(const char *fname, u_int val, const char *msg)
{
    if (!val)
	errx(1, "%s: no default %s", fname, msg);
    if (val > MAXU16)
	errx(1, "%s: illegal %s", fname, msg);
    return val;
}

/*
 * Convert and check a numeric option argument.
 */
static u_int
argtou(const char *arg, u_int lo, u_int hi, const char *msg)
{
    char *s;
    u_long x;

    errno = 0;
    x = strtoul(arg, &s, 0);
    if (errno || !*arg || *s || x < lo || x > hi)
	errx(1, "%s: bad %s", arg, msg);
    return x;
}

/*
 * Check a volume label.
 */
static int
oklabel(const char *src)
{
    int c = 0, i;

    for (i = 0; i <= 11; i++) {
	c = (u_char)*src++;
	if (c < ' ' + !i || strchr("\"*+,./:;<=>?[\\]|", c))
	    break;
    }
    return i && !c;
}

/*
 * Make a volume label.
 */
static void
mklabel(u_int8_t *dest, const char *src)
{
    int c, i;

    for (i = 0; i < 11; i++) {
	c = *src ? toupper((unsigned char)*src++) : ' ';
	*dest++ = !i && c == '\xe5' ? 5 : c;
    }
}

/*
 * Copy string, padding with spaces.
 */
static void
setstr(u_int8_t *dest, const char *src, size_t len)
{
    while (len--)
	*dest++ = *src ? *src++ : ' ';
}

/*
 * Print usage message.
 */
static __dead void
usage(void)
{
	extern const char	*__progname;

	fprintf(stderr, "usage: %s "
	    "[-N] [-a FAT-size] [-B boot] [-b block-size]\n"
	    "\t[-c cluster-size] [-e dirents] [-F FAT-type] [-f format]\n"
	    "\t[-h heads] [-I volid] [-i info] [-k backup] [-L label]\n"
	    "\t[-m media] [-n FATs] [-O OEM] [-o hidden] [-r reserved]\n"
	    "\t[-S sector-size] [-s total] [-u track-size] special\n"
	    "\t[disktype]\n",
	    __progname);
	exit(1);
}
@


1.26
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.25 2015/01/16 06:40:00 deraadt Exp $	*/
d253 3
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.24 2014/07/10 20:09:53 tobias Exp $	*/
d263 2
a264 3
	    if (strcmp(optarg, "12") &&
		strcmp(optarg, "16") &&
		strcmp(optarg, "32"))
a265 1
	    opt_F = atoi(optarg);
@


1.24
log
@Not initializing "next free cluster" is better than pointing at a cluster
that is in use.

Merged from NetBSD rev 1.9.

ok krw@@ (who came up with the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.23 2014/07/10 19:31:07 tobias Exp $	*/
d30 1
a30 1
#include <sys/param.h>
d46 1
d49 3
d236 1
a236 1
    char buf[MAXPATHLEN];
d486 1
a486 1
	bpb.res = fat == 32 ? MAX(x, MAX(16384 / bpb.bps, 4)) : x;
d510 1
a510 1
    x2 = howmany((RESFTE + MIN(x, maxcls(fat))) * (fat / BPN),
@


1.23
log
@Put boot signature always at end of 512 byte sector, even on disks with
larger sector sizes.  512 bytes is also the smallest valid sector size.

Merged from NetBSD's revision 1.24.

ok krw@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.22 2013/11/22 04:14:01 deraadt Exp $	*/
d629 1
a629 1
		mk4(img + MINBPS - 20, bpb.rdcl);
@


1.22
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.21 2013/11/05 00:51:58 krw Exp $	*/
d53 1
a53 1
#define MINBPS	  128		/* minimum bytes per sector */
d620 1
a620 1
		    mk2(img + bpb.bps - 2, DOSMAGIC);
d627 4
a630 4
		mk4(img + bpb.bps - 28, 0x61417272);
		mk4(img + bpb.bps - 24, 0xffffffff);
		mk4(img + bpb.bps - 20, bpb.rdcl);
		mk2(img + bpb.bps - 2, DOSMAGIC);
@


1.21
log
@Replace direct references to p_size, p_offset and d_secperunit with
DL_[GET|SET]PSIZE(), DL_[GET|SET]POFFSET(), DL_[GET|SET]DSIZE() in
order to get|set correct value that includes the high bits of the
value.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.20 2010/05/18 04:41:14 dlg Exp $	*/
d717 1
a717 1
    for (s2 = s1; *s2 && !isdigit(*s2); s2++);
d721 1
a721 1
	while (isdigit(*++s2));
d844 1
a844 1
	c = *src ? toupper(*src++) : ' ';
@


1.20
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.19 2009/10/27 23:59:33 deraadt Exp $	*/
d743 1
a743 1
	    !lp->d_partitions[part].p_size)
d746 1
a746 1
	    bpb->hid += lp->d_partitions[part].p_offset;
d748 1
a748 1
	    bpb->bsec = lp->d_partitions[part].p_size;
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.18 2009/07/27 18:11:07 halex Exp $	*/
d34 1
@


1.18
log
@As is already the case for ffs, do not allow creation of msdos file systems
on block devices

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.17 2007/09/28 09:57:01 jmc Exp $	*/
a28 5

#ifndef lint
static const char rcsid[] =
  "$FreeBSD: src/sbin/newfs_msdos/newfs_msdos.c,v 1.9 1999/08/28 00:13:52 peter Exp $";
#endif /* not lint */
@


1.17
log
@sort options;
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.16 2007/09/26 18:49:03 pyr Exp $	*/
d350 2
@


1.16
log
@some cleanup. remove #ifdef __FreeBSD__ code, last sync to FreeBSD was
7 years ago. this improves readability.
provide a standard usage message while there (synced with manpage).
ok millert@@, ``looks fine'' krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.15 2004/10/01 04:08:45 jsg Exp $	*/
d870 6
a875 5
	    "[-N] [-B boot] [-F FAT-type] [-I volid] [-L label] [-O OEM]\n"
	    "\t[-S sector-size] [-a FAT-size] [-b block-size]\n"
	    "\t[-c cluster-size] [-e dirents] [-f format] [-h heads]\n"
	    "\t[-i info] [-k backup] [-m media] [-n FATs] [-o hidden]\n"
	    "\t[-r reserved] [-s total] [-u track-size] special [disktype]\n",
@


1.15
log
@add some missing $, ok djm@@ 'That looks fine to me' millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 3
#ifdef __FreeBSD__
#include <sys/diskslice.h>
#endif
a37 1
#ifndef __FreeBSD__
a38 1
#endif
a49 1
#ifdef __OpenBSD__
a50 1
#endif
d221 1
a221 1
static void usage(void);
a246 4
#ifdef __FreeBSD__
    const char *fname, *dtype, *bname;
#endif
#ifdef __OpenBSD__
a248 1
#endif
a342 11
#ifdef __FreeBSD__
    fname = *argv++;
    if (!strchr(fname, '/')) {
	snprintf(buf, sizeof(buf), "%sr%s", _PATH_DEV, fname);
	if (stat(buf, &sb))
	    snprintf(buf, sizeof(buf), "%s%s", _PATH_DEV, fname);
	if (!(fname = strdup(buf)))
	    err(1, NULL);
    }
#endif
#ifdef __OpenBSD__
a343 1
#endif
a344 3
#ifdef __FreeBSD__
    if ((fd = open(fname, opt_N ? O_RDONLY : O_RDWR)) == -1 ||
#else
a345 1
#endif
a710 6
#ifdef __FreeBSD__
    struct diskslices ds;
    int slice = -1;
    char *s;
    int fd1, e;
#endif
a724 11
#ifdef __FreeBSD__
    if (s2 && *s2 == 's') {
	slice = strtol(s2 + 1, &s, 10);
	if (slice < 1 || slice > MAX_SLICES - BASE_SLICE)
	    s2 = NULL;
	else {
	    slice = BASE_SLICE + slice - 1;
	    s2 = s;
	}
    }
#endif
a725 4
#ifdef __FreeBSD__
	if (slice == -1)
	    slice = COMPATIBILITY_SLICE;
#endif
a729 58
#ifdef __FreeBSD__
    if (slice != -1 && (!oflag || (!bpb->bsec && part == -1))) {
	if (ioctl(fd, DIOCGSLICEINFO, &ds) == -1) {
	    warn("ioctl (GSLICEINFO)");
	    errx(1, "%s: can't get slice info", fname);
	}
	if (slice >= ds.dss_nslices || !ds.dss_slices[slice].ds_size)
	    errx(1, "%s: slice is unavailable", fname);
	if (!oflag)
	    bpb->hid = ds.dss_slices[slice].ds_offset;
	if (!bpb->bsec && part == -1)
	    bpb->bsec = ds.dss_slices[slice].ds_size;
    }
    if (((slice == -1 || part != -1) &&
	 ((!oflag && part != -1) || !bpb->bsec)) ||
	!bpb->bps || !bpb->spt || !bpb->hds) {
	lp = &dl;
	i = ioctl(fd, DIOCGDINFO, lp);
	if (i == -1 && slice != -1 && part == -1) {
	    e = errno;
	    if (!(s = strdup(fname)))
		err(1, NULL);
	    s[s1 - fname] = 0;
	    if ((fd1 = open(s, O_RDONLY)) != -1) {
		i = ioctl(fd1, DIOCGDINFO, lp);
		close(fd1);
	    }
	    free(s);
	    errno = e;
	}
	if (i == -1) {
	    if (!dtype) {
		warn("ioctl (GDINFO)");
		errx(1, "%s: can't read disk label; "
		     "disk type must be specified", fname);
	    } else if (!(lp = getdiskbyname(dtype)))
		errx(1, "%s: unknown disk type", dtype);
	}
	if (slice == -1 || part != -1) {
	    if (part == -1)
		part = RAW_PART;
	    if (part >= lp->d_npartitions ||
		!lp->d_partitions[part].p_size)
		errx(1, "%s: partition is unavailable", fname);
	    if (!oflag && part != -1)
		bpb->hid += lp->d_partitions[part].p_offset;
	    if (!bpb->bsec)
		bpb->bsec = lp->d_partitions[part].p_size;
	}
	if (!bpb->bps)
	    bpb->bps = ckgeom(fname, lp->d_secsize, "bytes/sector");
	if (!bpb->spt)
	    bpb->spt = ckgeom(fname, lp->d_nsectors, "sectors/track");
	if (!bpb->hds)
	    bpb->hds = ckgeom(fname, lp->d_ntracks, "drive heads");
    }
#endif
#ifdef __OpenBSD__
a761 1
#endif
d864 1
a864 1
static void
d867 10
a876 26
    fprintf(stderr,
	    "usage: newfs_msdos [ -options ] special [disktype]\n");
    fprintf(stderr, "where the options are:\n");
    fprintf(stderr, "\t-N don't create file system: "
	    "just print out parameters\n");
    fprintf(stderr, "\t-B get bootstrap from file\n");
    fprintf(stderr, "\t-F FAT type (12, 16, or 32)\n");
    fprintf(stderr, "\t-I volume ID\n");
    fprintf(stderr, "\t-L volume label\n");
    fprintf(stderr, "\t-O OEM string\n");
    fprintf(stderr, "\t-S bytes/sector\n");
    fprintf(stderr, "\t-a sectors/FAT\n");
    fprintf(stderr, "\t-b block size\n");
    fprintf(stderr, "\t-c sectors/cluster\n");
    fprintf(stderr, "\t-e root directory entries\n");
    fprintf(stderr, "\t-f standard format\n");
    fprintf(stderr, "\t-h drive heads\n");
    fprintf(stderr, "\t-i file system info sector\n");
    fprintf(stderr, "\t-k backup boot sector\n");
    fprintf(stderr, "\t-m media descriptor\n");
    fprintf(stderr, "\t-n number of FATs\n");
    fprintf(stderr, "\t-o hidden sectors\n");
    fprintf(stderr, "\t-r reserved sectors\n");
    fprintf(stderr, "\t-s file system size (sectors)\n");
    fprintf(stderr, "\t-u sectors/track\n");
    exit(1);
@


1.14
log
@boring cleanups
@
text
@d1 2
@


1.13
log
@more snprintf
@
text
@d72 1
a72 1
#define MAXCLS12  0xfed 	/* maximum FAT12 clusters */
d137 1
a137 1
    u_int8_t label[11]; 	/* volume label */
d163 2
a164 2
    u_int bsec; 		/* big total sectors */
    u_int bspf; 		/* big sectors per FAT */
@


1.12
log
@use sizeof w/ defines; niklas@@ millert@@ ok.
@
text
@d637 1
a637 1
		sprintf(buf, "FAT%u", fat);
@


1.11
log
@major -Wall cleanup, almost complete
@
text
@d700 1
a700 1
    len = strlen(_PATH_DEV);
@


1.10
log
@Upgrade newfs_msdos to latest freebsd version.  This one knows how to handle
msdos on hard disk as well as floppies.  ok millert@@
@
text
@d740 2
d745 1
a745 2
    char *s;
    int part, fd1, i, e;
d933 1
a933 1
    int c, i;
@


1.9
log
@ignore -q for now since we are already quiet.  Makes "newfs -q -t msdos" does not generate an error
@
text
@a0 2
/*	$OpenBSD: newfs_msdos.c,v 1.8 1997/04/30 13:51:51 deraadt Exp $ */

d2 1
a2 2
 * Copyright (c) 1995, 1996 Joerg Wunsch
 *
a4 2
 * This program is free software.
 *
d11 3
a13 2
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d15 11
a25 10
 * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE DEVELOPERS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d28 4
a31 5
/*
 * Create an MS-DOS (FAT) file system.
 *
 * from: FreeBSD Id: mkdosfs.c,v 1.2 1996/01/30 02:35:08 joerg Exp 
 */
d33 1
a33 1
#include <sys/types.h>
d35 3
d39 1
d41 8
d51 1
a51 1
#include <time.h>
d53 1
a53 5
#include <memory.h>
#include <err.h>
#include <errno.h>
#include <ctype.h>
#include <fcntl.h>
d55 1
d57 64
a120 2
#include "bootcode.h"
#include "dosfs.h"
d122 8
a129 23
struct descrip {
	/* our database key */
	u_int32_t	kilobytes;

	/* MSDOS 3.3 BPB fields */
	u_int16_t	sectsiz;
	u_int8_t	clustsiz;
	u_int16_t	ressecs;
	u_int8_t	fatcnt;
	u_int16_t	rootsiz;
	u_int16_t	totsecs;
	u_int8_t	media;
	u_int16_t	fatsize;
	u_int16_t	trksecs;
	u_int16_t	headcnt;
	u_int16_t	hidnsec;

	/* MSDOS 4 BPB extensions */
	u_int32_t	ext_totsecs;
	u_int16_t	ext_physdrv;
	u_int8_t	ext_extboot;
	int8_t		ext_label[11];
	int8_t		ext_fsysid[8];
d132 7
a138 15
struct descrip table[] = {
	/* NB: must be sorted, starting with the largest format! */
	/*
	 * kilobytes
	 * sec cls res fat  rot   tot   med fsz spt hds hid
	 * tot phs ebt    label	  fsysid
	 */
	{1440, 512, 1, 1, 2, 224, 2880, 0xf0, 9, 18, 2, 0,
		0, 0, 0, "4.4BSD     ", "FAT12   "},
	{1200, 512, 1, 1, 2, 224, 2400, 0xf9, 7, 15, 2, 0,
		0, 0, 0, "4.4BSD     ", "FAT12   "},
	{720,  512, 2, 1, 2, 112, 1440, 0xf9, 3, 9, 2, 0,
		0, 0, 0, "4.4BSD     ", "FAT12   "},
	{360,  512, 2, 1, 2, 112, 720, 0xfd, 2, 9, 2, 0,
		0, 0, 0, "4.4BSD     ", "FAT12   "},
d141 551
a691 4
struct disklabel *
getdisklabel(s, fd)
	char *s;
	int fd;
d693 21
a713 1
	static struct disklabel lab;
d715 125
a839 1
	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
d841 23
a863 1
		return (NULL);
d865 2
a866 1
	return (&lab);
d869 5
a873 2
void
usage(void)
d875 20
a894 2
	fprintf(stderr, "usage: ");
	errx(2, "[-s kbytes] [-L label] device");
d897 11
a907 53
unsigned
findformat(fd)
	int fd;
{
	struct stat sb;

	/*
	 * This is a bit tricky.  If the argument is a regular file, we can
	 * lseek() to its end and get the size reported.  If it's a device
	 * however, lseeking doesn't report us any useful number.  Instead,
	 * we try to seek just to the end of the device and try reading a
	 * block there.  In the case where we've hit exactly the device
	 * boundary, we get a zero read, and thus have found the size.
	 * Since our knowledge of distinct formats is limited anyway, this
	 * is not a big deal at all.
	 */

	if (fstat(fd, &sb) == -1)
		err(1, "Huh? Cannot fstat()");	/* Cannot happen */
	if (S_ISREG(sb.st_mode)) {
		off_t   o;
		if (lseek(fd, (off_t) 0, SEEK_END) == -1 ||
		    (o = lseek(fd, (off_t) 0, SEEK_CUR)) == -1)
			/* Hmm, hmm.  Hard luck. */
			return 0;
		return (int) (o / 1024);
	} else if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
		char    b[512];
		int     i, rv;
		struct descrip *dp;

		for (i = 0, dp = table;
		    i < sizeof table / sizeof(struct descrip);
		    i++, dp++) {
			if (lseek(fd, (off_t) (dp->kilobytes * 1024),
			    SEEK_SET) == 1)
				/* Uh-oh, lseek() is not supposed to
				 * fail. */
				return 0;
			if ((rv = read(fd, b, 512)) == 0)
				break;
			/* XXX The ENOSPC is for the bogus fd(4)
			 * driver return value. */
			if (rv == -1 && errno != EINVAL && errno != ENOSPC)
				return 0;
			/* else: continue */
		}
		if (i == sizeof table / sizeof(struct descrip))
			return 0;
		(void) lseek(fd, (off_t) 0, SEEK_SET);
		return dp->kilobytes;
	}
	return 0;
d910 8
d919 5
a923 32
void
setup_boot_sector_from_template(bs, dp)
	union bootsector *bs;
	struct descrip *dp;
{
	memcpy((void *)bs->raw, (void *)bootcode, 512);

	/* historical part of BPB */
	s_to_little_s(bs->bsec.sectsiz, dp->sectsiz);
	bs->bsec.clustsiz = dp->clustsiz;
	s_to_little_s(bs->bsec.ressecs, dp->ressecs);
	bs->bsec.fatcnt = dp->fatcnt;
	s_to_little_s(bs->bsec.rootsiz, dp->rootsiz);
	s_to_little_s(bs->bsec.totsecs, dp->totsecs);
	bs->bsec.media = dp->media;
	s_to_little_s(bs->bsec.fatsize, dp->fatsize);
	s_to_little_s(bs->bsec.trksecs, dp->trksecs);
	s_to_little_s(bs->bsec.headcnt, dp->headcnt);
	s_to_little_s(bs->bsec.hidnsec, dp->hidnsec);

	/* MSDOS 4 extensions */
	l_to_little_l(bs->bsec.variable_part.extended.totsecs, dp->ext_totsecs);
	s_to_little_s(bs->bsec.variable_part.extended.physdrv, dp->ext_physdrv);
	bs->bsec.variable_part.extended.extboot = dp->ext_extboot;

	/* assign a "serial number" :) */
	l_to_little_l(bs->bsec.variable_part.extended.serial, arc4random());

	memcpy((void *) bs->bsec.variable_part.extended.label,
	    (void *) dp->ext_label, 11);
	memcpy((void *) bs->bsec.variable_part.extended.fsysid,
	    (void *) dp->ext_fsysid, 8);
a924 1
#define roundup(dst, limit) dst = (((dst) | ((limit) - 1)) & ~(limit)) + 1
d926 7
a932 32
int
main(argc, argv)
	int argc;
	char *argv[];
{
	union bootsector bs;
	struct descrip *dp;
	struct fat *fat;
	struct direntry *rootdir;
	const char *label = 0;
	struct tm *tp;
	time_t  now;
	int	c, i, fd, format = 0, rootdirsize;
	char	*rdev;

	while ((c = getopt(argc, argv, "qs:L:t:")) != -1)
		switch (c) {
		case 's':
			format = atoi(optarg);
			break;
		case 'L':
			label = optarg;
			break;
		case 't':	/* compat with "-t fstype" in newfs */
		case 'q':	/* compat with "-q" in newfs */
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
d934 7
a940 2
	if (argc != 1)
		usage();
d942 7
a948 2
	if ((fd = opendev(argv[0], O_RDWR | O_EXCL, OPENDEV_PART, &rdev)) < 0)
		err(1, "%s", rdev);
d950 5
a954 84
	if (format == 0) {
		struct disklabel *lp;
		struct partition *pp;
		off_t size = 0;

		/*
		 * No format specified, try to figure it out.
		 */
		lp = getdisklabel(rdev, fd);
		if (lp) {
			char cc = rdev[strlen(rdev) - 1];

			if (isdigit(cc))
				pp = &lp->d_partitions[0];
			else if (cc >= 'a' && cc < 'a' + MAXPARTITIONS)
				pp = &lp->d_partitions[cc - 'a'];
			else
				errx(1, "unknown partition %c in %s", cc, rdev);
			if (pp->p_size == 0)
				errx(1, "%s: `%c' partition is unavailable",
				    rdev, cc);
			size = pp->p_size;
			format = size * lp->d_secsize / 1024;
		} else if ((format = findformat(fd)) == 0)
			errx(1, "cannot determine size, must use -s format");
	}
	for (i = 0, dp = table; i < sizeof table/sizeof(table[0]); i++, dp++)
		if (dp->kilobytes == format)
			break;
	if (i == sizeof table / sizeof(struct descrip))
		errx(1, "cannot find format description for %d KB", format);

	/* prepare and write the boot sector */
	setup_boot_sector_from_template(&bs, dp);

	/* if we've got an explicit label, use it */
	if (label)
		strncpy(bs.bsec.variable_part.extended.label, label, 11);

	if (write(fd, (char *) bs.raw, sizeof bs) != sizeof bs)
		err(1, "boot sector write()");

	/* now, go on with the FATs */
	if ((fat = (struct fat *) malloc(dp->sectsiz * dp->fatsize)) == 0)
		abort();
	memset((void *) fat, 0, dp->sectsiz * dp->fatsize);

	fat->media = dp->media;
	fat->padded = 0xff;
	fat->contents[0] = 0xff;
	if (dp->totsecs > 20740 || (dp->totsecs == 0 && dp->ext_totsecs > 20740))
		fat->contents[1] = 0xff;	/* 16-bit FAT */

	for (i = 0; i < dp->fatcnt; i++)
		if (write(fd, (char *) fat, dp->sectsiz * dp->fatsize) !=
		    dp->sectsiz * dp->fatsize)
			err(1, "FAT write()");

	free((void *) fat);

	/* finally, build the root dir */
	rootdirsize = dp->rootsiz * sizeof(struct direntry);
	roundup(rootdirsize, dp->clustsiz * dp->sectsiz);

	if ((rootdir = (struct direntry *) malloc(rootdirsize)) == 0)
		abort();
	memset((void *) fat, 0, rootdirsize);

	/* set up a volume label inside the root dir :) */
	if (label)
		strncpy(rootdir[0].name, label, 11);	/* XXX but safe */
	else
		memcpy(rootdir[0].name, dp->ext_label, 11);
	rootdir[0].attr = FA_VOLLABEL;
	now = time((time_t) 0);
	tp = localtime(&now);
	rootdir[0].fdate.time[0] = tp->tm_sec / 2;
	rootdir[0].fdate.time[0] |= (tp->tm_min & 7) << 5;
	rootdir[0].fdate.time[1] = ((tp->tm_min >> 3) & 7);
	rootdir[0].fdate.time[1] |= tp->tm_hour << 3;
	rootdir[0].fdate.date[0] = tp->tm_mday;
	rootdir[0].fdate.date[0] |= ((tp->tm_mon + 1) & 7) << 5;
	rootdir[0].fdate.date[1] = ((tp->tm_mon + 1) >> 3) & 1;
	rootdir[0].fdate.date[1] |= (tp->tm_year - 80) << 1;
d956 9
a964 2
	if (write(fd, (char *) rootdir, rootdirsize) != rootdirsize)
		err(1, "root dir write()");
d966 32
a997 2
	(void) close(fd);
	return 0;
@


1.8
log
@clone boot sector that existed there? bad idea. No idea why though
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.7 1997/04/14 12:07:04 deraadt Exp $ */
d224 1
a224 1
	while ((c = getopt(argc, argv, "s:L:t:")) != -1)
d233 1
@


1.7
log
@if -s not specified, attempt to grok the disklabel
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.6 1997/03/29 20:01:26 millert Exp $ */
a277 3

	if (read(fd, (char *)bs.raw, sizeof bs) != sizeof bs)
		err(1, "boot sector read()");
@


1.6
log
@Use arc4random() not random().
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.5 1997/03/22 02:51:06 kstailey Exp $ */
d39 2
d48 1
d80 1
a80 1
static struct descrip table[] = {
d97 14
d222 1
a222 1
	char *rdev;
d248 4
d255 16
a270 1
		if ((format = findformat(fd)) == 0)
d273 1
a273 1
	for (i = 0, dp = table; i < sizeof table / sizeof(struct descrip); i++, dp++)
d279 3
d301 1
a301 2
		/* 16-bit FAT */
		fat->contents[1] = 0xff;
d304 2
a305 2
		if (write(fd, (char *) fat, dp->sectsiz * dp->fatsize)
		    != dp->sectsiz * dp->fatsize)
d320 1
a320 1
		strncpy(rootdir[0].name, label, 11);
@


1.5
log
@removed code that was inside #if 0 ... #endif
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.4 1997/01/15 23:41:32 millert Exp $ */
d183 1
a183 2
	srandom((unsigned) time((time_t) 0));
	l_to_little_l(bs->bsec.variable_part.extended.serial, random());
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.3 1997/01/10 19:04:10 kstailey Exp $ */
a227 4
#if 0
	if ((fd = open(argv[0], O_RDWR | O_EXCL, 0)) == -1)
		err(1, "open(%s)", argv[0]);
#else
a229 1
#endif
@


1.3
log
@use opendev(3) + man page correction
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.2 1996/12/04 08:33:58 deraadt Exp $ */
d208 1
a208 1
	while ((c = getopt(argc, argv, "s:L:t:")) != EOF)
@


1.2
log
@do not freak out if we see a -t argument
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs_msdos.c,v 1.1 1996/06/10 06:37:16 deraadt Exp $ */
d47 1
d206 1
d228 1
d231 4
@


1.1
log
@add newfs_msdos (from freebsd); does not know how to make non-floppy filesystems yet
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d206 1
a206 1
	while ((c = getopt(argc, argv, "s:L:")) != EOF)
d213 2
@
