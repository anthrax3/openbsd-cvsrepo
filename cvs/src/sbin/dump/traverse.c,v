head	1.38;
access;
symbols
	OPENBSD_6_0:1.38.0.8
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.4
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.24.0.14
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.12
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.10
	OPENBSD_5_0:1.24.0.8
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.12
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.8
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.6
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.8
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	F55lwc3gS4GN2mLs;

1.37
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2014.07.10.09.33.43;	author krw;	state Exp;
branches;
next	1.35;
commitid	Gux7WxDfCo8WAJ2g;

1.35
date	2014.06.13.20.43.06;	author naddy;	state Exp;
branches;
next	1.34;
commitid	ZqQ42rJaAxHNKIBx;

1.34
date	2014.05.31.14.15.22;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.31.11.28.44;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.27.12.35.40;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.24.21.49.09;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.21.17.38.30;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.04.23.21.39.59;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.04.10.47.21;	author zhuk;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.15.21.07.17;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.11.16.50.33;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.06.03.27.14;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.04.22.36.54;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.26.20.57.54;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.02.00.48.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.14.08.45.56;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.20.41.50;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.22.20.24.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.11.24.01.25.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.05.05.35.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.04.01.41.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@/*	$OpenBSD: traverse.c,v 1.37 2015/01/16 06:39:57 deraadt Exp $	*/
/*	$NetBSD: traverse.c,v 1.17 1997/06/05 11:13:27 lukem Exp $	*/

/*-
 * Copyright (c) 1980, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE dbtob */
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dinode.h>

#include <protocols/dumprestore.h>

#include <ctype.h>
#include <errno.h>
#include <fts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "dump.h"

extern struct disklabel lab;

union dinode {
	struct ufs1_dinode dp1;
	struct ufs2_dinode dp2;
};
#define	DIP(dp, field) \
	((sblock->fs_magic == FS_UFS1_MAGIC) ? \
	(dp)->dp1.field : (dp)->dp2.field)

#define	HASDUMPEDFILE	0x1
#define	HASSUBDIRS	0x2

static	int dirindir(ino_t, daddr_t, int, off_t *, int64_t *, int);
static	void dmpindir(ino_t, daddr_t, int, off_t *);
static	int searchdir(ino_t, daddr_t, long, off_t, int64_t *, int);
void	fs_mapinodes(ino_t maxino, off_t *tapesize, int *anydirskipped);

/*
 * This is an estimation of the number of TP_BSIZE blocks in the file.
 * It estimates the number of blocks in files with holes by assuming
 * that all of the blocks accounted for by di_blocks are data blocks
 * (when some of the blocks are usually used for indirect pointers);
 * hence the estimate may be high.
 */
int64_t
blockest(union dinode *dp)
{
	int64_t blkest, sizeest;

	/*
	 * dp->di_size is the size of the file in bytes.
	 * dp->di_blocks stores the number of sectors actually in the file.
	 * If there are more sectors than the size would indicate, this just
	 *	means that there are indirect blocks in the file or unused
	 *	sectors in the last file block; we can safely ignore these
	 *	(blkest = sizeest below).
	 * If the file is bigger than the number of sectors would indicate,
	 *	then the file has holes in it.	In this case we must use the
	 *	block count to estimate the number of data blocks used, but
	 *	we use the actual size for estimating the number of indirect
	 *	dump blocks (sizeest vs. blkest in the indirect block
	 *	calculation).
	 */
	blkest = howmany(dbtob((int64_t)DIP(dp, di_blocks)), TP_BSIZE);
	sizeest = howmany((int64_t)DIP(dp, di_size), TP_BSIZE);
	if (blkest > sizeest)
		blkest = sizeest;
	if (DIP(dp, di_size) > sblock->fs_bsize * NDADDR) {
		/* calculate the number of indirect blocks on the dump tape */
		blkest +=
			howmany(sizeest - NDADDR * sblock->fs_bsize / TP_BSIZE,
			TP_NINDIR);
	}
	return (blkest + 1);
}

/* true if "nodump" flag has no effect here, i.e. dumping allowed */
#define CHECKNODUMP(dp) \
	(nonodump || (DIP((dp), di_flags) & UF_NODUMP) != UF_NODUMP)

/*
 * Determine if given inode should be dumped
 */
void
mapfileino(ino_t ino, int64_t *tapesize, int *dirskipped)
{
	int mode;
	union dinode *dp;

	dp = getino(ino, &mode);
	if (mode == 0)
		return;
	SETINO(ino, usedinomap);
	if (mode == IFDIR)
		SETINO(ino, dumpdirmap);
	if (CHECKNODUMP(dp) &&
	    (DIP(dp, di_mtime) >= spcl.c_ddate ||
	     DIP(dp, di_ctime) >= spcl.c_ddate)) {
		SETINO(ino, dumpinomap);
		if (mode != IFREG && mode != IFDIR && mode != IFLNK)
			*tapesize += 1;
		else
			*tapesize += blockest(dp);
		return;
	}
	if (mode == IFDIR) {
		if (!CHECKNODUMP(dp))
			CLRINO(ino, usedinomap);
		*dirskipped = 1;
	}
}

void
fs_mapinodes(ino_t maxino, int64_t *tapesize, int *anydirskipped)
{
	int i, cg, inosused;
	struct cg *cgp;
	ino_t ino;
	char *cp;

	if ((cgp = malloc(sblock->fs_cgsize)) == NULL)
		quit("fs_mapinodes: cannot allocate memory.\n");

	for (cg = 0; cg < sblock->fs_ncg; cg++) {
		ino = cg * sblock->fs_ipg;
		bread(fsbtodb(sblock, cgtod(sblock, cg)), (char *)cgp,
		    sblock->fs_cgsize);
		if (sblock->fs_magic == FS_UFS2_MAGIC)
			inosused = cgp->cg_initediblk;
		else
			inosused = sblock->fs_ipg;
		/*
		 * If we are using soft updates, then we can trust the
		 * cylinder group inode allocation maps to tell us which
		 * inodes are allocated. We will scan the used inode map
		 * to find the inodes that are really in use, and then
		 * read only those inodes in from disk.
		 */
		if (sblock->fs_flags & FS_DOSOFTDEP) {
			if (!cg_chkmagic(cgp))
				quit("mapfiles: cg %d: bad magic number\n", cg);
			cp = &cg_inosused(cgp)[(inosused - 1) / CHAR_BIT];
			for ( ; inosused > 0; inosused -= CHAR_BIT, cp--) {
				if (*cp == 0)
					continue;
				for (i = 1 << (CHAR_BIT - 1); i > 0; i >>= 1) {
					if (*cp & i)
						break;
					inosused--;
				}
				break;
			}
			if (inosused <= 0)
				continue;
		}
		for (i = 0; i < inosused; i++, ino++) {
			if (ino < ROOTINO)
				continue;
			mapfileino(ino, tapesize, anydirskipped);
		}
	}

	free(cgp);
}

/*
 * Dump pass 1.
 *
 * Walk the inode list for a filesystem to find all allocated inodes
 * that have been modified since the previous dump time. Also, find all
 * the directories in the filesystem.
 */
int
mapfiles(ino_t maxino, int64_t *tapesize, char *disk, char * const *dirv)
{
	int anydirskipped = 0;

	if (dirv != NULL) {
		char	 curdir[PATH_MAX];
		FTS	*dirh;
		FTSENT	*entry;
		int	 d;

		if (getcwd(curdir, sizeof(curdir)) == NULL) {
			msg("Can't determine cwd: %s\n", strerror(errno));
			dumpabort(0);
		}
		if ((dirh = fts_open(dirv, FTS_PHYSICAL|FTS_SEEDOT|FTS_XDEV,
		    NULL)) == NULL) {
			msg("fts_open failed: %s\n", strerror(errno));
			dumpabort(0);
		}
		while ((entry = fts_read(dirh)) != NULL) {
			switch (entry->fts_info) {
			case FTS_DNR:		/* an error */
			case FTS_ERR:
			case FTS_NS:
				msg("Can't fts_read %s: %s\n", entry->fts_path,
				    strerror(errno));
				/* FALLTHROUGH */
			case FTS_DP:		/* already seen dir */
				continue;
			}
			mapfileino(entry->fts_statp->st_ino, tapesize,
			    &anydirskipped);
		}
		if (errno) {
			msg("fts_read failed: %s\n", strerror(errno));
			dumpabort(0);
		}
		(void)fts_close(dirh);

		/*
		 * Add any parent directories
		 */
		for (d = 0 ; dirv[d] != NULL ; d++) {
			char path[PATH_MAX];

			if (dirv[d][0] != '/')
				(void)snprintf(path, sizeof(path), "%s/%s",
				    curdir, dirv[d]);
			else
				(void)snprintf(path, sizeof(path), "%s",
				    dirv[d]);
			while (strcmp(path, disk) != 0) {
				char *p;
				struct stat sb;

				if (*path == '\0')
					break;
				if ((p = strrchr(path, '/')) == NULL)
					break;
				if (p == path)
					break;
				*p = '\0';
				if (stat(path, &sb) == -1) {
					msg("Can't stat %s: %s\n", path,
					    strerror(errno));
					break;
				}
				mapfileino(sb.st_ino, tapesize, &anydirskipped);
			}
		}

		/*
		 * Ensure that the root inode actually appears in the
		 * file list for a subdir
		 */
		mapfileino(ROOTINO, tapesize, &anydirskipped);
	} else {
		fs_mapinodes(maxino, tapesize, &anydirskipped);
	}
	/*
	 * Restore gets very upset if the root is not dumped,
	 * so ensure that it always is dumped.
	 */
	SETINO(ROOTINO, dumpinomap);
	return (anydirskipped);
}

/*
 * Dump pass 2.
 *
 * Scan each directory on the filesystem to see if it has any modified
 * files in it. If it does, and has not already been added to the dump
 * list (because it was itself modified), then add it. If a directory
 * has not been modified itself, contains no modified files and has no
 * subdirectories, then it can be deleted from the dump list and from
 * the list of directories. By deleting it from the list of directories,
 * its parent may now qualify for the same treatment on this or a later
 * pass using this algorithm.
 */
int
mapdirs(ino_t maxino, int64_t *tapesize)
{
	union dinode *dp;
	int i, isdir, nodump;
	char *map;
	ino_t ino;
	union dinode di;
	off_t filesize;
	int ret, change = 0;

	isdir = 0;		/* XXX just to get gcc to shut up */
	for (map = dumpdirmap, ino = 1; ino < maxino; ino++) {
		if (((ino - 1) % NBBY) == 0)	/* map is offset by 1 */
			isdir = *map++;
		else
			isdir >>= 1;
                /*
		 * If a directory has been removed from usedinomap, it
		 * either has the nodump flag set, or has inherited
		 * it.  Although a directory can't be in dumpinomap if
		 * it isn't in usedinomap, we have to go through it to
		 * propagate the nodump flag.
		 */
		nodump = !nonodump && !TSTINO(ino, usedinomap);
		if ((isdir & 1) == 0 || (TSTINO(ino, dumpinomap) && !nodump))
			continue;
		dp = getino(ino, &i);
		/*
		 * inode buf may change in searchdir().
		 */
		if (sblock->fs_magic == FS_UFS1_MAGIC)
			di.dp1 = dp->dp1;
		else
			di.dp2 = dp->dp2;
		filesize = (off_t)DIP(dp, di_size);
		for (ret = 0, i = 0; filesize > 0 && i < NDADDR; i++) {
			if (DIP(&di, di_db[i]) != 0)
				ret |= searchdir(ino, DIP(&di, di_db[i]),
				    sblksize(sblock, DIP(dp, di_size), i),
				    filesize, tapesize, nodump);
			if (ret & HASDUMPEDFILE)
				filesize = 0;
			else
				filesize -= sblock->fs_bsize;
		}
		for (i = 0; filesize > 0 && i < NIADDR; i++) {
			if (DIP(&di, di_ib[i]) == 0)
				continue;
			ret |= dirindir(ino, DIP(&di, di_ib[i]), i, &filesize,
			    tapesize, nodump);
		}
		if (ret & HASDUMPEDFILE) {
			SETINO(ino, dumpinomap);
			*tapesize += blockest(dp);
			change = 1;
			continue;
		}
                if (nodump) {
                        if (ret & HASSUBDIRS)
                                change = 1;     /* subdirs inherit nodump */
                        CLRINO(ino, dumpdirmap);
                } else if ((ret & HASSUBDIRS) == 0) {
			if (!TSTINO(ino, dumpinomap)) {
				CLRINO(ino, dumpdirmap);
				change = 1;
			}
		}
	}
	return (change);
}

/*
 * Read indirect blocks, and pass the data blocks to be searched
 * as directories. Quit as soon as any entry is found that will
 * require the directory to be dumped.
 */
static int
dirindir(ino_t ino, daddr_t blkno, int ind_level, off_t *filesize,
    int64_t *tapesize, int nodump)
{
	int ret = 0;
	int i;
	char idblk[MAXBSIZE];

	bread(fsbtodb(sblock, blkno), idblk, (int)sblock->fs_bsize);
	if (ind_level <= 0) {
		for (i = 0; *filesize > 0 && i < NINDIR(sblock); i++) {
			if (sblock->fs_magic == FS_UFS1_MAGIC)
				blkno = ((int32_t *)idblk)[i];
			else
				blkno = ((int64_t *)idblk)[i];
			if (blkno != 0)
				ret |= searchdir(ino, blkno, sblock->fs_bsize,
					*filesize, tapesize, nodump);
			if (ret & HASDUMPEDFILE)
				*filesize = 0;
			else
				*filesize -= sblock->fs_bsize;
		}
		return (ret);
	}
	ind_level--;
	for (i = 0; *filesize > 0 && i < NINDIR(sblock); i++) {
		if (sblock->fs_magic == FS_UFS1_MAGIC)
			blkno = ((int32_t *)idblk)[i];
		else
			blkno = ((int64_t *)idblk)[i];
		if (blkno != 0)
			ret |= dirindir(ino, blkno, ind_level, filesize,
			    tapesize, nodump);
	}
	return (ret);
}

/*
 * Scan a disk block containing directory information looking to see if
 * any of the entries are on the dump list and to see if the directory
 * contains any subdirectories.
 */
static int
searchdir(ino_t ino, daddr_t blkno, long size, off_t filesize,
    int64_t *tapesize, int nodump)
{
	struct direct *dp;
	union dinode *ip;
	long loc;
	static caddr_t dblk;
	int mode, ret = 0;

	if (dblk == NULL && (dblk = malloc(sblock->fs_bsize)) == NULL)
		quit("searchdir: cannot allocate indirect memory.\n");
	bread(fsbtodb(sblock, blkno), dblk, (int)size);
	if (filesize < size)
		size = filesize;
	for (loc = 0; loc < size; ) {
		dp = (struct direct *)(dblk + loc);
		if (dp->d_reclen == 0) {
			msg("corrupted directory, inumber %llu\n",
			    (unsigned long long)ino);
			break;
		}
		loc += dp->d_reclen;
		if (dp->d_ino == 0)
			continue;
		if (dp->d_name[0] == '.') {
			if (dp->d_name[1] == '\0')
				continue;
			if (dp->d_name[1] == '.' && dp->d_name[2] == '\0')
				continue;
		}
		if (nodump) {
                        ip = getino(dp->d_ino, &mode);
                        if (TSTINO(dp->d_ino, dumpinomap)) {
                                CLRINO(dp->d_ino, dumpinomap);
                                *tapesize -= blockest(ip);
                        }
                        /*
                         * Add back to dumpdirmap and remove from usedinomap
                         * to propagate nodump.
                         */
                        if (mode == IFDIR) {
                                SETINO(dp->d_ino, dumpdirmap);
                                CLRINO(dp->d_ino, usedinomap);
                                ret |= HASSUBDIRS;
                        }
		} else {
			if (TSTINO(dp->d_ino, dumpinomap)) {
				ret |= HASDUMPEDFILE;
				if (ret & HASSUBDIRS)
					break;
			}
			if (TSTINO(dp->d_ino, dumpdirmap)) {
				ret |= HASSUBDIRS;
				if (ret & HASDUMPEDFILE)
					break;
			}
		}
	}
	return (ret);
}

/*
 * Dump passes 3 and 4.
 *
 * Dump the contents of an inode to tape.
 */
void
dumpino(union dinode *dp, ino_t ino)
{
	int ind_level, cnt;
	off_t size;
	char buf[TP_BSIZE];

	if (newtape) {
		newtape = 0;
		dumpmap(dumpinomap, TS_BITS, ino);
	}
	CLRINO(ino, dumpinomap);
	if (sblock->fs_magic == FS_UFS1_MAGIC) {
		spcl.c_mode = dp->dp1.di_mode;
		spcl.c_size = dp->dp1.di_size;
		spcl.c_old_atime = (time_t)dp->dp1.di_atime;
		spcl.c_atime = dp->dp1.di_atime;
		spcl.c_atimensec = dp->dp1.di_atimensec;
		spcl.c_old_mtime = (time_t)dp->dp1.di_mtime;
		spcl.c_mtime = dp->dp1.di_mtime;
		spcl.c_mtimensec = dp->dp1.di_mtimensec;
		spcl.c_birthtime = 0;
		spcl.c_birthtimensec = 0;
		spcl.c_rdev = dp->dp1.di_rdev;
		spcl.c_file_flags = dp->dp1.di_flags;
		spcl.c_uid = dp->dp1.di_uid;
		spcl.c_gid = dp->dp1.di_gid;
	} else {
		spcl.c_mode = dp->dp2.di_mode;
		spcl.c_size = dp->dp2.di_size;
		spcl.c_atime = dp->dp2.di_atime;
		spcl.c_atimensec = dp->dp2.di_atimensec;
		spcl.c_mtime = dp->dp2.di_mtime;
		spcl.c_mtimensec = dp->dp2.di_mtimensec;
		spcl.c_birthtime = dp->dp2.di_birthtime;
		spcl.c_birthtimensec = dp->dp2.di_birthnsec;
		spcl.c_rdev = dp->dp2.di_rdev;
		spcl.c_file_flags = dp->dp2.di_flags;
		spcl.c_uid = dp->dp2.di_uid;
		spcl.c_gid = dp->dp2.di_gid;
	}
	spcl.c_type = TS_INODE;
	spcl.c_count = 0;
	switch (DIP(dp, di_mode) & S_IFMT) {

	case 0:
		/*
		 * Freed inode.
		 */
		return;

	case IFLNK:
		/*
		 * Check for short symbolic link.
		 */
		if (DIP(dp, di_size) > 0 &&
#ifdef FS_44INODEFMT
		    (DIP(dp, di_size) < sblock->fs_maxsymlinklen ||
		     (sblock->fs_maxsymlinklen == 0 &&
			 DIP(dp, di_blocks) == 0))) {
#else
		    DIP(dp, di_blocks) == 0) {
#endif
			void *shortlink;

			spcl.c_addr[0] = 1;
			spcl.c_count = 1;
			writeheader(ino);
			if (sblock->fs_magic == FS_UFS1_MAGIC)
				shortlink = dp->dp1.di_shortlink;
			else
				shortlink = dp->dp2.di_shortlink;
			memcpy(buf, shortlink, DIP(dp, di_size));
			buf[DIP(dp, di_size)] = '\0';
			writerec(buf, 0);
			return;
		}
		/* FALLTHROUGH */

	case IFDIR:
	case IFREG:
		if (DIP(dp, di_size) > 0)
			break;
		/* FALLTHROUGH */

	case IFIFO:
	case IFSOCK:
	case IFCHR:
	case IFBLK:
		writeheader(ino);
		return;

	default:
		msg("Warning: undefined file type 0%o\n",
		    DIP(dp, di_mode) & IFMT);
		return;
	}
	if (DIP(dp, di_size) > NDADDR * sblock->fs_bsize)
		cnt = NDADDR * sblock->fs_frag;
	else
		cnt = howmany(DIP(dp, di_size), sblock->fs_fsize);
	if (sblock->fs_magic == FS_UFS1_MAGIC)
		ufs1_blksout(&dp->dp1.di_db[0], cnt, ino);
	else
		ufs2_blksout(&dp->dp2.di_db[0], cnt, ino);
	if ((size = DIP(dp, di_size) - NDADDR * sblock->fs_bsize) <= 0)
		return;
	for (ind_level = 0; ind_level < NIADDR; ind_level++) {
		dmpindir(ino, DIP(dp, di_ib[ind_level]), ind_level, &size);
		if (size <= 0)
			return;
	}
}

/*
 * Read indirect blocks, and pass the data blocks to be dumped.
 */
static void
dmpindir(ino_t ino, daddr_t  blk, int ind_level, off_t *size)
{
	int i, cnt;
	char idblk[MAXBSIZE];

	if (blk != 0)
		bread(fsbtodb(sblock, blk), idblk, (int) sblock->fs_bsize);
	else
		memset(idblk, 0, (int)sblock->fs_bsize);
	if (ind_level <= 0) {
		if (*size < NINDIR(sblock) * sblock->fs_bsize)
			cnt = howmany(*size, sblock->fs_fsize);
		else
			cnt = NINDIR(sblock) * sblock->fs_frag;
		*size -= NINDIR(sblock) * sblock->fs_bsize;
		if (sblock->fs_magic == FS_UFS1_MAGIC)
			ufs1_blksout((int32_t *)idblk, cnt, ino);
		else
			ufs2_blksout((int64_t *)idblk, cnt, ino);
		return;
	}
	ind_level--;
	for (i = 0; i < NINDIR(sblock); i++) {
		if (sblock->fs_magic == FS_UFS1_MAGIC)
			dmpindir(ino, ((int32_t *)idblk)[i], ind_level,
			    size);
		else
			dmpindir(ino, ((int64_t *)idblk)[i], ind_level,
			    size);
		if (*size <= 0)
			return;
	}
}

/*
 * Collect up the data into tape record sized buffers and output them.
 */
void
ufs1_blksout(int32_t *blkp, int frags, ino_t ino)
{
	int32_t *bp;
	int i, j, count, blks, tbperdb;

	blks = howmany(frags * sblock->fs_fsize, TP_BSIZE);
	tbperdb = sblock->fs_bsize >> tp_bshift;
	for (i = 0; i < blks; i += TP_NINDIR) {
		if (i + TP_NINDIR > blks)
			count = blks;
		else
			count = i + TP_NINDIR;
		for (j = i; j < count; j++)
			if (blkp[j / tbperdb] != 0)
				spcl.c_addr[j - i] = 1;
			else
				spcl.c_addr[j - i] = 0;
		spcl.c_count = count - i;
		writeheader(ino);
		bp = &blkp[i / tbperdb];
		for (j = i; j < count; j += tbperdb, bp++)
			if (*bp != 0) {
				if (j + tbperdb <= count)
					dumpblock(*bp, (int)sblock->fs_bsize);
				else
					dumpblock(*bp, (count - j) * TP_BSIZE);
			}
		spcl.c_type = TS_ADDR;
	}
}

/*
 * Collect up the data into tape record sized buffers and output them.
 */
void
ufs2_blksout(daddr_t *blkp, int frags, ino_t ino)
{
	daddr_t *bp;
	int i, j, count, blks, tbperdb;

	blks = howmany(frags * sblock->fs_fsize, TP_BSIZE);
	tbperdb = sblock->fs_bsize >> tp_bshift;
	for (i = 0; i < blks; i += TP_NINDIR) {
		if (i + TP_NINDIR > blks)
			count = blks;
		else
			count = i + TP_NINDIR;
		for (j = i; j < count; j++)
			if (blkp[j / tbperdb] != 0)
				spcl.c_addr[j - i] = 1;
			else
				spcl.c_addr[j - i] = 0;
		spcl.c_count = count - i;
		writeheader(ino);
		bp = &blkp[i / tbperdb];
		for (j = i; j < count; j += tbperdb, bp++)
			if (*bp != 0) {
				if (j + tbperdb <= count)
					dumpblock(*bp, (int)sblock->fs_bsize);
				else
					dumpblock(*bp, (count - j) * TP_BSIZE);
			}
		spcl.c_type = TS_ADDR;
	}
}

/*
 * Dump a map to the tape.
 */
void
dumpmap(map, type, ino)
	char *map;
	int type;
	ino_t ino;
{
	int i;
	char *cp;

	spcl.c_type = type;
	spcl.c_count = howmany(mapsize * sizeof(char), TP_BSIZE);
	writeheader(ino);
	for (i = 0, cp = map; i < spcl.c_count; i++, cp += TP_BSIZE)
		writerec(cp, 0);
}

/*
 * Write a header record to the dump tape.
 */
void
writeheader(ino)
	ino_t ino;
{
	int32_t sum, cnt, *lp;

	spcl.c_inumber = ino;
	if (sblock->fs_magic == FS_UFS2_MAGIC) {
		spcl.c_magic = FS_UFS2_MAGIC;
	} else {
		spcl.c_magic = NFS_MAGIC;
		spcl.c_old_date = (int32_t)spcl.c_date;
		spcl.c_old_ddate = (int32_t)spcl.c_ddate;
		spcl.c_old_tapea = (int32_t)spcl.c_tapea;
		spcl.c_old_firstrec = (int32_t)spcl.c_firstrec;
	}
	spcl.c_checksum = 0;
	lp = (int32_t *)&spcl;
	sum = 0;
	cnt = sizeof(union u_spcl) / (4 * sizeof(int32_t));
	while (--cnt >= 0) {
		sum += *lp++;
		sum += *lp++;
		sum += *lp++;
		sum += *lp++;
	}
	spcl.c_checksum = CHECKSUM - sum;
	writerec((char *)&spcl, 1);
}

union dinode *
getino(ino_t inum, int *modep)
{
	static ino_t minino, maxino;
	static void *inoblock;
	struct ufs1_dinode *dp1;
	struct ufs2_dinode *dp2;

	if (inoblock == NULL && (inoblock = malloc(sblock->fs_bsize)) == NULL)
		quit("cannot allocate inode memory.\n");
	curino = inum;
	if (inum >= minino && inum < maxino)
		goto gotit;
	bread(fsbtodb(sblock, ino_to_fsba(sblock, inum)), inoblock,
	    (int)sblock->fs_bsize);
	minino = inum - (inum % INOPB(sblock));
	maxino = minino + INOPB(sblock);
gotit:
	if (sblock->fs_magic == FS_UFS1_MAGIC) {
		dp1 = &((struct ufs1_dinode *)inoblock)[inum - minino];
		*modep = (dp1->di_mode & IFMT);
		return ((union dinode *)dp1);
	}
	dp2 = &((struct ufs2_dinode *)inoblock)[inum - minino];
	*modep = (dp2->di_mode & IFMT);
	return ((union dinode *)dp2);
}

/*
 * Read a chunk of data from the disk.
 * Try to recover from hard errors by reading in sector sized pieces.
 * Error recovery is attempted at most BREADEMAX times before seeking
 * consent from the operator to continue.
 */
int	breaderrors = 0;
#define	BREADEMAX 32

void
bread(daddr_t blkno, char *buf, int size)
{
	static char *mybuf = NULL;
	char *mybufp, *bufp, *np;
	static size_t mybufsz = 0;
	off_t offset;
	int cnt, i;
	u_int64_t secno, seccount;
	u_int32_t secoff, secsize = lab.d_secsize;

	/*
	 * We must read an integral number of sectors large enough to contain
	 * all the requested data. The read must begin at a sector.
	 */
	if (DL_BLKOFFSET(&lab, blkno) == 0 && size % secsize == 0) {
		secno = DL_BLKTOSEC(&lab, blkno);
		secoff = 0;
		seccount = size / secsize;
		bufp = buf;
	} else {
		secno = DL_BLKTOSEC(&lab, blkno);
		secoff = DL_BLKOFFSET(&lab, blkno);
		seccount = DL_BLKTOSEC(&lab, (size + secoff) / DEV_BSIZE);
		if (seccount * secsize < (size + secoff))
			seccount++;
		if (mybufsz < seccount * secsize) {
			np = reallocarray(mybuf, seccount, secsize);
			if (np == NULL) {
				msg("No memory to read %llu %u-byte sectors",
				    seccount, secsize);
				dumpabort(0);
			}
			mybufsz = seccount * secsize;
			mybuf = np;
		}
		bufp = mybuf;
	}

	offset = secno * secsize;

loop:
	if ((cnt = pread(diskfd, bufp, seccount * secsize, offset)) ==
	    seccount * secsize)
		goto done;
	if (blkno + (size / DEV_BSIZE) >
	    fsbtodb(sblock, sblock->fs_ffs1_size)) {
		/*
		 * Trying to read the final fragment.
		 *
		 * NB - dump only works in TP_BSIZE blocks, hence
		 * rounds `DEV_BSIZE' fragments up to TP_BSIZE pieces.
		 * It should be smarter about not actually trying to
		 * read more than it can get, but for the time being
		 * we punt and scale back the read only when it gets
		 * us into trouble. (mkm 9/25/83)
		 */
		size -= secsize;
		seccount--;
		goto loop;
	}
	if (cnt == -1)
		msg("read error from %s: %s: [block %lld]: count=%d\n",
		    disk, strerror(errno), (long long)blkno, size);
	else
		msg("short read error from %s: [block %lld]: count=%d, "
		    "got=%d\n", disk, (long long)blkno, size, cnt);
	if (++breaderrors > BREADEMAX) {
		msg("More than %d block read errors from %s\n",
			BREADEMAX, disk);
		broadcast("DUMP IS AILING!\n");
		msg("This is an unrecoverable error.\n");
		if (!query("Do you want to attempt to continue?")){
			dumpabort(0);
			/*NOTREACHED*/
		} else
			breaderrors = 0;
	}
	/*
	 * Zero buffer, then try to read each sector of buffer separately.
	 */
	if (bufp == mybuf)
		memset(bufp, 0, mybufsz);
	else
		memset(bufp, 0, size);
	for (i = 0, mybufp = bufp; i < size; i += secsize, mybufp += secsize) {
		if ((cnt = pread(diskfd, mybufp, secsize, offset + i)) ==
		    secsize)
			continue;
		if (cnt == -1) {
			msg("read error from %s: %s: [block %lld]: "
			    "count=%u\n", disk, strerror(errno),
			    (long long)(offset + i) / DEV_BSIZE, secsize);
			continue;
		}
		msg("short read error from %s: [block %lld]: count=%u, "
		    "got=%d\n", disk, (long long)(offset + i) / DEV_BSIZE,
		    secsize, cnt);
	}

done:
	/* If necessary, copy out data that was read. */
	if (bufp == mybuf)
		memcpy(buf, bufp + secoff, size);
}
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.36 2014/07/10 09:33:43 krw Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE dbtob */
@


1.36
log
@Add internal buffering when dumping a device with non-512 byte
sectors. This ensures that the requested data, and all the requested
data, is actually read from the device.

Should have no effect on 512-byte sector devices, but makes dump work
on 4096-byte sector devices.

Problem noted by and fix tested by David Vasek.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.35 2014/06/13 20:43:06 naddy Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d50 1
d213 1
a213 1
		char	 curdir[MAXPATHLEN];
d251 1
a251 1
			char path[MAXPATHLEN];
@


1.35
log
@Type cleanup:
* Move all off_t variables that don't look like file sizes to int64_t.
* Switch blockswritten to int64_t, so it won't wrap at 2TB.
* Same for blocksthisvol (from deraadt@@).
* Switch xferrate (from tedu@@) and blocksperfile from long to uint64_t.
* Since blocksperfile can be set with -B, move numarg() from long
to long long and don't mark small integer constant arguments as long.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.34 2014/05/31 14:15:22 krw Exp $	*/
d807 3
d812 2
a813 1
	u_int32_t secsize = lab.d_secsize;
d815 29
a843 1
	offset = blkno * DEV_BSIZE;
d846 3
a848 2
	if ((cnt = pread(diskfd, buf, size, offset)) == size)
		return;
d862 1
d885 6
a890 3
	memset(buf, 0, size);
	for (i = 0; i < size; i += secsize, buf += secsize) {
		if ((cnt = pread(diskfd, buf, secsize, offset + i)) ==
d903 5
@


1.34
log
@Oops. We're reporting DEV_BSIZE values in error messages, so call
them 'blocks' not 'sectors'.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.33 2014/05/31 11:28:44 krw Exp $	*/
d66 1
a66 1
static	int dirindir(ino_t, daddr_t, int, off_t *, off_t *, int);
d68 1
a68 1
static	int searchdir(ino_t, daddr_t, long, off_t, off_t *, int);
d78 1
a78 1
off_t
d81 1
a81 1
	off_t blkest, sizeest;
d97 2
a98 2
	blkest = howmany(dbtob((off_t)DIP(dp, di_blocks)), TP_BSIZE);
	sizeest = howmany((off_t)DIP(dp, di_size), TP_BSIZE);
d118 1
a118 1
mapfileino(ino_t ino, off_t *tapesize, int *dirskipped)
d147 1
a147 1
fs_mapinodes(ino_t maxino, off_t *tapesize, int *anydirskipped)
d207 1
a207 1
mapfiles(ino_t maxino, off_t *tapesize, char *disk, char * const *dirv)
d307 1
a307 1
mapdirs(ino_t maxino, off_t *tapesize)
d385 1
a385 1
    off_t *tapesize, int nodump)
d428 1
a428 1
    off_t *tapesize, int nodump)
@


1.33
log
@Cast daddr_t variable (blkno) to (long long) when printing with %lld.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.32 2014/05/27 12:35:40 krw Exp $	*/
d857 1
a857 1
			msg("read error from %s: %s: [sector %lld]: "
d862 1
a862 1
		msg("short read error from %s: [sector %lld]: count=%u, "
@


1.32
log
@Where trying to pread() a single disk sector, the i/o must be for the
actual disk sector size and not DEV_BSIZE. The sector size must be
obtained via the disklabel. Larger i/o's must be multiple sectors,
so when retrying with a smaller size shrink the attempt by one sector
and not DEV_BSIZE.

Of course if your d_secsize is DEV_BSIZE, this will all be a no-op.

This does not make non-512-byte sectors work, but puts in place the
logic to get and use the disklabel info. Which makes the next diffs
bite sized and focused.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.31 2014/05/24 21:49:09 krw Exp $	*/
d833 1
a833 1
			disk, strerror(errno), blkno, size);
d836 1
a836 1
		    "got=%d\n", disk, blkno, size, cnt);
@


1.31
log
@Nuke last of the illusionary 'dev_bsize' and 'dev_bshift' variables in
favour of DEV_BSIZE. No-op on 512-byte sector devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.30 2014/05/21 17:38:30 krw Exp $	*/
d36 1
d53 2
d809 1
d828 1
a828 1
		size -= DEV_BSIZE;
d852 3
a854 3
	for (i = 0; i < size; i += DEV_BSIZE, buf += DEV_BSIZE) {
		if ((cnt = pread(diskfd, buf, DEV_BSIZE, offset + i)) ==
		    DEV_BSIZE)
d858 2
a859 2
			    "count=%d\n", disk, strerror(errno),
			    (long long)(offset + i) / DEV_BSIZE, DEV_BSIZE);
d862 1
a862 1
		msg("short read error from %s: [sector %lld]: count=%d, "
d864 1
a864 1
		    DEV_BSIZE, cnt);
@


1.30
log
@Nuke some trailing whitespace and break some long lines to shrink
subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.29 2014/05/20 21:11:16 krw Exp $	*/
d804 1
d807 2
d810 1
a810 2
	if ((cnt = pread(diskfd, buf, size, (off_t)blkno << dev_bshift)) ==
		size)
d812 1
a812 1
	if (blkno + (size / dev_bsize) >
d818 1
a818 1
		 * rounds `dev_bsize' fragments up to TP_BSIZE pieces.
d824 1
a824 1
		size -= dev_bsize;
d848 3
a850 3
	for (i = 0; i < size; i += dev_bsize, buf += dev_bsize, blkno++) {
		if ((cnt = pread(diskfd, buf, dev_bsize,
			    (off_t)blkno << dev_bshift)) == dev_bsize)
d854 2
a855 2
			    "count=%ld\n", disk, strerror(errno), blkno,
			    dev_bsize);
d858 3
a860 2
		msg("short read error from %s: [sector %lld]: count=%ld, "
		    "got=%d\n", disk, blkno, dev_bsize, cnt);
@


1.29
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.28 2013/11/12 04:59:02 deraadt Exp $	*/
d502 1
a502 1
	if (sblock->fs_magic == FS_UFS1_MAGIC) {  
d548 2
a549 1
		     (sblock->fs_maxsymlinklen == 0 && DIP(dp, di_blocks) == 0))) {
d810 2
a811 1
	if (blkno + (size / dev_bsize) > fsbtodb(sblock, sblock->fs_ffs1_size)) {
d829 2
a830 2
		msg("short read error from %s: [block %lld]: count=%d, got=%d\n",
			disk, blkno, size, cnt);
d851 3
a853 2
			msg("read error from %s: %s: [sector %lld]: count=%ld\n",
				disk, strerror(errno), blkno, dev_bsize);
d856 2
a857 2
		msg("short read error from %s: [sector %lld]: count=%ld, got=%d\n",
			disk, blkno, dev_bsize, cnt);
@


1.28
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.27 2013/06/11 16:42:04 deraadt Exp $	*/
d806 2
a807 3
	if (lseek(diskfd, ((off_t)blkno << dev_bshift), SEEK_SET) < 0)
		msg("bread: lseek fails\n");
	if ((cnt = read(diskfd, buf, size)) == size)
d845 2
a846 3
		if (lseek(diskfd, ((off_t)blkno << dev_bshift), SEEK_SET) < 0)
			msg("bread: lseek2 fails!\n");
		if ((cnt = read(diskfd, buf, (int)dev_bsize)) == dev_bsize)
@


1.27
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.26 2013/04/23 21:39:59 deraadt Exp $	*/
d66 1
@


1.26
log
@handle large ino_t; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.25 2013/04/04 10:47:21 zhuk Exp $	*/
d63 3
a65 3
static	int dirindir(ino_t, daddr64_t, int, off_t *, off_t *, int);
static	void dmpindir(ino_t, daddr64_t, int, off_t *);
static	int searchdir(ino_t, daddr64_t, long, off_t, off_t *, int);
d380 1
a380 1
dirindir(ino_t ino, daddr64_t blkno, int ind_level, off_t *filesize,
d423 1
a423 1
searchdir(ino_t ino, daddr64_t blkno, long size, off_t filesize,
d606 1
a606 1
dmpindir(ino_t ino, daddr64_t  blk, int ind_level, off_t *size)
d679 1
a679 1
ufs2_blksout(daddr64_t *blkp, int frags, ino_t ino)
d681 1
a681 1
	daddr64_t *bp;
d800 1
a800 1
bread(daddr64_t blkno, char *buf, int size)
@


1.25
log
@Make our dump(8) honour the "nodump" flag for directories, effectively
disabling dumping their contents.

input and ok otto@@ millert@@
man page bits input and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.24 2009/10/27 23:59:32 deraadt Exp $	*/
d440 2
a441 1
			msg("corrupted directory, inumber %d\n", ino);
@


1.24
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.23 2007/06/15 21:07:17 otto Exp $	*/
d63 3
a65 3
static	int dirindir(ino_t ino, daddr64_t blkno, int level, off_t *size);
static	void dmpindir(ino_t ino, daddr64_t blk, int level, off_t *size);
static	int searchdir(ino_t ino, daddr64_t blkno, long size, off_t filesize);
d106 3
a108 12
/* Auxiliary macro to pick up files changed since previous dump. */
#define	CHANGEDSINCE(dp, t) \
	(DIP(dp, di_mtime) >= (t) || DIP(dp, di_ctime) >= (t))

/* The WANTTODUMP macro decides whether a file should be dumped. */
#ifdef UF_NODUMP
#define	WANTTODUMP(dp) \
	(CHANGEDSINCE(dp, spcl.c_ddate) && \
	 (nonodump || (DIP(dp, di_flags) & UF_NODUMP) != UF_NODUMP))
#else
#define	WANTTODUMP(dp) CHANGEDSINCE(dp, spcl.c_ddate)
#endif
d125 3
a127 1
	if (WANTTODUMP(dp)) {
d135 3
a137 1
	if (mode == IFDIR)
d139 1
d306 1
a306 1
	int i, isdir;
d319 9
a327 1
		if ((isdir & 1) == 0 || TSTINO(ino, dumpinomap))
d342 1
a342 1
				    filesize);
d351 2
a352 1
			ret |= dirindir(ino, DIP(&di, di_ib[i]), i, &filesize);
d360 5
a364 1
		if ((ret & HASSUBDIRS) == 0) {
d380 2
a381 1
dirindir(ino_t ino, daddr64_t blkno, int ind_level, off_t *filesize)
d396 1
a396 1
					*filesize);
d411 2
a412 1
			ret |= dirindir(ino, blkno, ind_level, filesize);
d423 2
a424 1
searchdir(ino_t ino, daddr64_t blkno, long size, off_t filesize)
d427 1
d430 1
a430 1
	int ret = 0;
d452 26
a477 9
		if (TSTINO(dp->d_ino, dumpinomap)) {
			ret |= HASDUMPEDFILE;
			if (ret & HASSUBDIRS)
				break;
		}
		if (TSTINO(dp->d_ino, dumpdirmap)) {
			ret |= HASSUBDIRS;
			if (ret & HASDUMPEDFILE)
				break;
@


1.23
log
@don't use static data in recursive functions; from FreeBSD; fixes PR 5509
and other reports about dump accessing wrong blocks; ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.22 2007/06/11 16:50:33 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)traverse.c	8.2 (Berkeley) 9/23/93";
#else
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.22 2007/06/11 16:50:33 millert Exp $";
#endif
#endif /* not lint */
@


1.22
log
@When dumping ffs1, store old_atime and old_mtime too.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.21 2007/06/03 20:16:08 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.21 2007/06/03 20:16:08 millert Exp $";
d383 1
a383 1
	static void *idblk;
a384 2
	if (idblk == NULL && (idblk = malloc(sblock->fs_bsize)) == NULL)
		quit("dirindir: cannot allocate indirect memory.\n");
d586 1
a586 1
	static void *idblk;
a587 2
	if (idblk == NULL && (idblk = malloc(sblock->fs_bsize)) == NULL)
		quit("dmpindir: cannot allocate indirect memory.\n");
@


1.21
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.20 2007/03/19 13:27:47 pedro Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.20 2007/03/19 13:27:47 pedro Exp $";
d483 2
a484 1
		spcl.c_atime = (time_t)dp->dp1.di_atime;
d486 2
a487 1
		spcl.c_mtime = (time_t)dp->dp1.di_mtime;
d498 1
a498 1
		spcl.c_atime = (time_t)dp->dp2.di_atime;
d500 1
a500 1
		spcl.c_mtime = (time_t)dp->dp2.di_mtime;
d502 1
a502 1
		spcl.c_birthtime = (time_t)dp->dp2.di_birthtime;
@


1.20
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.19 2007/03/06 03:27:14 ray Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.19 2007/03/06 03:27:14 ray Exp $";
d54 1
d60 8
d71 3
a73 3
static	int dirindir(ino_t ino, daddr_t blkno, int level, off_t *size);
static	void dmpindir(ino_t ino, daddr_t blk, int level, off_t *size);
static	int searchdir(ino_t ino, daddr_t blkno, long size, off_t filesize);
d83 1
a83 1
blockest(struct ufs1_dinode *dp)
d101 2
a102 2
	blkest = howmany(dbtob((off_t)dp->di_blocks), TP_BSIZE);
	sizeest = howmany(dp->di_size, TP_BSIZE);
d105 1
a105 1
	if (dp->di_size > sblock->fs_bsize * NDADDR) {
d116 1
a116 1
	((dp)->di_mtime >= (t) || (dp)->di_ctime >= (t))
d122 1
a122 1
	 (nonodump || ((dp)->di_flags & UF_NODUMP) != UF_NODUMP))
d134 1
a134 1
	struct ufs1_dinode *dp;
d136 2
a137 2
	dp = getino(ino);
	if ((mode = (dp->di_mode & IFMT)) == 0)
d154 53
d292 1
a292 5
		ino_t ino;

		for (ino = ROOTINO; ino < maxino; ino++) {
			mapfileino(ino, tapesize, &anydirskipped);
		}
d317 1
a317 1
	struct	ufs1_dinode *dp;
d321 1
d333 9
a341 2
		dp = getino(ino);
		filesize = dp->di_size;
d343 4
a346 3
			if (dp->di_db[i] != 0)
				ret |= searchdir(ino, dp->di_db[i],
				    dblksize(sblock, dp, i), filesize);
d353 1
a353 1
			if (dp->di_ib[i] == 0)
d355 1
a355 1
			ret |= dirindir(ino, dp->di_ib[i], i, &filesize);
d379 1
a379 1
dirindir(ino_t ino, daddr_t blkno, int ind_level, off_t *filesize)
d383 1
a383 1
	daddr_t	idblk[MAXNINDIR];
d385 3
a387 1
	bread(fsbtodb(sblock, blkno), (char *)idblk, (int)sblock->fs_bsize);
d390 4
a393 1
			blkno = idblk[i];
d406 4
a409 1
		blkno = idblk[i];
d422 1
a422 1
searchdir(ino_t ino, daddr_t blkno, long size, off_t filesize)
d426 1
a426 1
	char dblk[MAXBSIZE];
d429 2
d469 1
a469 1
dumpino(struct ufs1_dinode *dp, ino_t ino)
d480 27
a506 1
	spcl.c_dinode = *dp;
d509 1
a509 1
	switch (dp->di_mode & IFMT) {
d521 1
a521 1
		if (dp->di_size > 0 &&
d523 2
a524 2
		    (dp->di_size < sblock->fs_maxsymlinklen ||
		     (sblock->fs_maxsymlinklen == 0 && dp->di_blocks == 0))) {
d526 1
a526 1
		    dp->di_blocks == 0) {
d528 2
d533 6
a538 2
			memcpy(buf, dp->di_shortlink, (u_long)dp->di_size);
			buf[dp->di_size] = '\0';
d546 1
a546 1
		if (dp->di_size > 0)
d558 2
a559 1
		msg("Warning: undefined file type 0%o\n", dp->di_mode & IFMT);
d562 1
a562 1
	if (dp->di_size > NDADDR * sblock->fs_bsize)
d565 6
a570 3
		cnt = howmany(dp->di_size, sblock->fs_fsize);
	blksout(&dp->di_db[0], cnt, ino);
	if ((size = dp->di_size - NDADDR * sblock->fs_bsize) <= 0)
d573 1
a573 1
		dmpindir(ino, dp->di_ib[ind_level], ind_level, &size);
d583 1
a583 1
dmpindir(ino_t ino, daddr_t blk, int ind_level, off_t *size)
d586 1
a586 1
	daddr_t idblk[MAXNINDIR];
d588 2
d591 1
a591 1
		bread(fsbtodb(sblock, blk), (char *)idblk, (int) sblock->fs_bsize);
d600 4
a603 1
		blksout(&idblk[0], cnt, ino);
d608 6
a613 1
		dmpindir(ino, idblk[i], ind_level, size);
d623 1
a623 1
blksout(daddr_t *blkp, int frags, ino_t ino)
d625 36
a660 1
	daddr_t *bp;
d718 9
a726 1
	spcl.c_magic = NFS_MAGIC;
d741 2
a742 2
struct ufs1_dinode *
getino(ino_t inum)
d744 4
a747 2
	static daddr_t minino, maxino;
	static struct ufs1_dinode inoblock[MAXINOPB];
d749 2
d753 2
a754 2
		return (&inoblock[inum - minino]);
	bread(fsbtodb(sblock, ino_to_fsba(sblock, inum)), (char *)inoblock,
d758 9
a766 1
	return (&inoblock[inum - minino]);
d779 1
a779 1
bread(daddr_t blkno, char *buf, int size)
d803 1
a803 1
		msg("read error from %s: %s: [block %d]: count=%d\n",
d806 1
a806 1
		msg("short read error from %s: [block %d]: count=%d, got=%d\n",
d829 1
a829 1
			msg("read error from %s: %s: [sector %d]: count=%d\n",
d833 1
a833 1
		msg("short read error from %s: [sector %d]: count=%d, got=%d\n",
@


1.19
log
@Add and fix /* FALLTHROUGH */ comments.

From Jim Razmus.

OK millert@@ and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.18 2007/03/04 22:36:54 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.18 2007/03/04 22:36:54 deraadt Exp $";
d610 1
a610 1
	if (blkno + (size / dev_bsize) > fsbtodb(sblock, sblock->fs_size)) {
@


1.18
log
@delete sunos junk; Jim Razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.17 2006/12/26 20:57:54 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.17 2006/12/26 20:57:54 otto Exp $";
d179 1
d433 1
a433 1
		/* fall through */
d439 1
a439 1
		/* fall through */
@


1.17
log
@fts_read returning NULL and errno set is an error. ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.16 2006/04/02 00:48:35 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.16 2006/04/02 00:48:35 deraadt Exp $";
a43 7
#ifdef sunos
#include <sys/vnode.h>

#include <ufs/fs.h>
#include <ufs/fsdir.h>
#include <ufs/inode.h>
#else
a46 1
#endif
@


1.16
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.15 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.15 2003/08/25 23:28:15 tedu Exp $";
d192 4
@


1.15
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.14 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.14 2003/07/28 06:13:26 tedu Exp $";
d609 1
a609 1
	if (lseek(diskfd, ((off_t)blkno << dev_bshift), 0) < 0)
d649 1
a649 1
		if (lseek(diskfd, ((off_t)blkno << dev_bshift), 0) < 0)
@


1.14
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.13 2003/06/26 16:35:21 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: traverse.c,v 1.13 2003/06/26 16:35:21 deraadt Exp $";
d82 1
a82 1
blockest(struct dinode *dp)
d133 1
a133 1
	struct dinode *dp;
d262 1
a262 1
	struct	dinode *dp;
d395 1
a395 1
dumpino(struct dinode *dp, ino_t ino)
d578 1
a578 1
struct dinode *
d582 1
a582 1
	static struct dinode inoblock[MAXINOPB];
@


1.13
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.12 2003/06/02 20:06:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.12 2003/06/02 20:06:14 millert Exp $";
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.11 2003/05/14 08:45:56 cloder Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.11 2003/05/14 08:45:56 cloder Exp $";
d82 1
a82 2
blockest(dp)
	struct dinode *dp;
d130 1
a130 4
mapfileino(ino, tapesize, dirskipped)
	ino_t ino;
	off_t *tapesize;
	int *dirskipped;
d161 1
a161 5
mapfiles(maxino, tapesize, disk, dirv)
	ino_t maxino;
	off_t *tapesize;
	char *disk;
	char * const *dirv;
d176 1
a176 1
				    (int (*)())NULL)) == NULL) {
d260 1
a260 3
mapdirs(maxino, tapesize)
	ino_t maxino;
	off_t *tapesize;
d315 1
a315 5
dirindir(ino, blkno, ind_level, filesize)
	ino_t ino;
	daddr_t blkno;
	int ind_level;
	off_t *filesize;
d350 1
a350 5
searchdir(ino, blkno, size, filesize)
	ino_t ino;
	daddr_t blkno;
	long size;
	off_t filesize;
d395 1
a395 3
dumpino(dp, ino)
	struct dinode *dp;
	ino_t ino;
d473 1
a473 5
dmpindir(ino, blk, ind_level, size)
	ino_t ino;
	daddr_t blk;
	int ind_level;
	off_t *size;
d503 1
a503 4
blksout(blkp, frags, ino)
	daddr_t *blkp;
	int frags;
	ino_t ino;
d579 1
a579 2
getino(inum)
	ino_t inum;
d604 1
a604 4
bread(blkno, buf, size)
	daddr_t blkno;
	char *buf;
	int size;
@


1.11
log
@Minor format string correctness.
OK deraadt, ian darwin
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.10 2002/03/14 20:41:50 mickey Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.10 2002/03/14 20:41:50 mickey Exp $";
@


1.10
log
@fix a few overflows by using off_t, not 32bit longs; some parts are from lucq.org; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.9 2002/02/19 19:39:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.9 2002/02/19 19:39:38 millert Exp $";
d669 1
a669 1
		msg("More than %d block read errors from %d\n",
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.8 2002/02/16 21:27:33 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.8 2002/02/16 21:27:33 millert Exp $";
d74 3
a76 9
#ifdef	FS_44INODEFMT
typedef	quad_t fsizeT;
#else
typedef	int32_t fsizeT;
#endif

static	int dirindir(ino_t ino, daddr_t blkno, int level, long *size);
static	void dmpindir(ino_t ino, daddr_t blk, int level, fsizeT *size);
static	int searchdir(ino_t ino, daddr_t blkno, long size, long filesize);
d85 1
a85 1
long
d89 1
a89 1
	long blkest, sizeest;
d105 1
a105 1
	blkest = howmany(dbtob(dp->di_blocks), TP_BSIZE);
d137 1
a137 1
	u_int64_t *tapesize;
d171 1
a171 1
	u_int64_t *tapesize;
d188 1
a188 1
		    		    (int (*)())NULL)) == NULL) {
d274 1
a274 1
	u_int64_t *tapesize;
d280 1
a280 1
	long filesize;
d296 1
a296 2
					(long)dblksize(sblock, dp, i),
					filesize);
d333 1
a333 1
	long *filesize;
d372 1
a372 1
	long filesize;
d375 1
a375 1
	long loc, ret = 0;
d377 1
d422 1
a422 1
	fsizeT size;
d501 1
a501 1
	fsizeT *size;
d632 1
a632 1
int	breaderrors = 0;		
d639 1
a639 1
	int size;	
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.7 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.7 2001/11/05 07:39:16 mpech Exp $";
a65 1
#ifdef __STDC__
a67 1
#endif
@


1.7
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.6 2000/01/22 20:24:55 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.6 2000/01/22 20:24:55 deraadt Exp $";
d82 3
a84 3
static	int dirindir __P((ino_t ino, daddr_t blkno, int level, long *size));
static	void dmpindir __P((ino_t ino, daddr_t blk, int level, fsizeT *size));
static	int searchdir __P((ino_t ino, daddr_t blkno, long size, long filesize));
@


1.6
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.5 1998/11/24 01:25:47 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.5 1998/11/24 01:25:47 deraadt Exp $";
d95 1
a95 1
	register struct dinode *dp;
d284 4
a287 4
	register struct	dinode *dp;
	register int i, isdir;
	register char *map;
	register ino_t ino;
d345 1
a345 1
	register int i;
d380 1
a380 1
	register long size;
d383 2
a384 2
	register struct direct *dp;
	register long loc, ret = 0;
d426 1
a426 1
	register struct dinode *dp;
d544 1
a544 1
	register daddr_t *bp;
d582 1
a582 1
	register int i;
d599 1
a599 1
	register int32_t sum, cnt, *lp;
@


1.5
log
@Wall, and do not let tapesize overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.4 1997/07/05 05:35:59 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.4 1997/07/05 05:35:59 millert Exp $";
a649 1
	extern int errno;
@


1.4
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: traverse.c,v 1.3 1996/12/04 01:41:52 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.3 1996/12/04 01:41:52 deraadt Exp $";
d145 1
a145 1
	long *tapesize;
d179 1
a179 1
	long *tapesize;
d282 1
a282 1
	long *tapesize;
d563 1
a563 1
			if (*bp != 0)
d568 1
@


1.3
log
@64 bit patches, tih@@nhh.no
@
text
@d1 2
a2 2
/*	$OpenBSD: traverse.c,v 1.2 1996/06/23 14:30:13 deraadt Exp $	*/
/*	$NetBSD: traverse.c,v 1.15 1996/11/30 18:03:27 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.2 1996/06/23 14:30:13 deraadt Exp $";
d63 2
d140 30
d177 1
a177 1
mapfiles(maxino, tapesize)
d180 2
a182 3
	register int mode;
	register ino_t ino;
	register struct dinode *dp;
d185 39
a223 11
	for (ino = ROOTINO; ino < maxino; ino++) {
		dp = getino(ino);
		if ((mode = (dp->di_mode & IFMT)) == 0)
			continue;
		SETINO(ino, usedinomap);
		if (mode == IFDIR)
			SETINO(ino, dumpdirmap);
		if (WANTTODUMP(dp)) {
			SETINO(ino, dumpinomap);
			if (mode != IFREG && mode != IFDIR && mode != IFLNK)
				*tapesize += 1;
d225 32
a256 2
				*tapesize += blockest(dp);
			continue;
a257 2
		if (mode == IFDIR)
			anydirskipped = 1;
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: traverse.c,v 1.14 1995/06/18 21:35:33 cgd Exp $	*/
/*	$NetBSD: traverse.c,v 1.14 1995/06/18 21:35:33 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: traverse.c,v 1.14 1995/06/18 21:35:33 cgd Exp $";
d77 1
a77 1
typedef	long fsizeT;
d511 1
a511 1
	register long sum, cnt, *lp;
d516 1
a516 1
	lp = (long *)&spcl;
d518 1
a518 1
	cnt = sizeof(union u_spcl) / (4 * sizeof(long));
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: traverse.c,v 1.14 1995/06/18 21:35:33 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
