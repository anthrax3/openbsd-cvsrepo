head	1.43;
access;
symbols
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.31.0.12
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.10
	OPENBSD_5_0:1.31.0.8
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.10
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.24.0.6
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	0qPuuXwccpVXsXcV;

1.42
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	F55lwc3gS4GN2mLs;

1.41
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	Uu5nFG3wCl0LACBb;

1.40
date	2014.06.13.20.43.06;	author naddy;	state Exp;
branches;
next	1.39;
commitid	ZqQ42rJaAxHNKIBx;

1.39
date	2014.05.24.21.49.09;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.11.02.00.08.16;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.23.21.39.59;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.16.18.17.39;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2012.08.22.05.20.51;	author halex;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.11.07.04.22;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.04.22.36.54;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.02.05.09.35;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.30.20.09.53;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.13.00.48.48;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.13.19.10.49;	author cloder;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.23.18.49.19;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.23.18.33.12;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.04.20.10.07;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.07.01.25.30;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.19.17.57.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.02.28.06.50.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.02.21.00.07.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.02.20.21.46.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.04.26.18.11.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.25.15.09.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.05.23.17.12;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.07.05.05.35.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.02.03.11.53.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.43
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/*	$OpenBSD: tape.c,v 1.42 2015/01/20 18:22:20 deraadt Exp $	*/
/*	$NetBSD: tape.c,v 1.11 1997/06/05 11:13:26 lukem Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE */
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>

#include <protocols/dumprestore.h>

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "dump.h"
#include "pathnames.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

int	writesize;		/* size of malloc()ed buffer for tape */
int64_t	lastspclrec = -1;	/* tape block number of last written header */
int	trecno = 0;		/* next record to write in current block */
extern	int64_t blocksperfile;	/* number of blocks per output file */
int64_t	blocksthisvol;		/* number of blocks on current output file */
extern	int ntrec;		/* blocking factor on tape */
extern	int cartridge;
extern	char *host;
char	*nexttape;

static	ssize_t atomic(ssize_t (*)(int, void *, size_t), int, char *, int);
static	void doslave(int, int);
static	void enslave(void);
static	void flushtape(void);
static	void killall(void);
static	void rollforward(void);

void	tperror(int signo);
void	sigpipe(int signo);
void	proceed(int signo);

/*
 * Concurrent dump mods (Caltech) - disk block reading and tape writing
 * are exported to several slave processes.  While one slave writes the
 * tape, the others read disk blocks; they pass control of the tape in
 * a ring via signals. The parent process traverses the filesystem and
 * sends writeheader()'s and lists of daddr's to the slaves via pipes.
 * The following structure defines the instruction packets sent to slaves.
 */
struct req {
	daddr_t dblk;
	int count;
};
int reqsiz;

#define SLAVES 3		/* 1 slave writing, 1 reading, 1 for slack */
struct slave {
	int64_t tapea;		/* header number at start of this chunk */
	int64_t firstrec;	/* record number of this block */
	int count;		/* count to next header (used for TS_TAPE */
				/* after EOT) */
	int inode;		/* inode that we are currently dealing with */
	int fd;			/* FD for this slave */
	pid_t pid;		/* PID for this slave */
	int sent;		/* 1 == we've sent this slave requests */
	char (*tblock)[TP_BSIZE]; /* buffer for data blocks */
	struct req *req;	/* buffer for requests */
} slaves[SLAVES+1];
struct slave *slp;

char	(*nextblock)[TP_BSIZE];

static time_t tstart_volume;	/* time of volume start */
static int64_t tapea_volume;	/* value of spcl.c_tapea at volume start */

pid_t master;		/* pid of master, for sending error signals */
int tenths;		/* length of tape used per block written */
static volatile sig_atomic_t caught;	/* have we caught the signal to proceed? */

int
alloctape(void)
{
	int pgoff = getpagesize() - 1;
	char *buf;
	int i;

	writesize = ntrec * TP_BSIZE;
	reqsiz = (ntrec + 1) * sizeof(struct req);
	/*
	 * CDC 92181's and 92185's make 0.8" gaps in 1600-bpi start/stop mode
	 * (see DEC TU80 User's Guide).  The shorter gaps of 6250-bpi require
	 * repositioning after stopping, i.e, streaming mode, where the gap is
	 * variable, 0.30" to 0.45".  The gap is maximal when the tape stops.
	 */
	if (blocksperfile == 0 && !unlimited)
		tenths = writesize / density +
		    (cartridge ? 16 : density == 625 ? 5 : 8);
	/*
	 * Allocate tape buffer contiguous with the array of instruction
	 * packets, so flushtape() can write them together with one write().
	 * Align tape buffer on page boundary to speed up tape write().
	 */
	for (i = 0; i <= SLAVES; i++) {
		buf = malloc((unsigned)(reqsiz + writesize + pgoff + TP_BSIZE));
		if (buf == NULL)
			return(0);
		slaves[i].tblock = (char (*)[TP_BSIZE])
		    (((long)&buf[ntrec + 1] + pgoff) &~ pgoff);
		slaves[i].req = (struct req *)slaves[i].tblock - ntrec - 1;
	}
	slp = &slaves[0];
	slp->count = 1;
	slp->tapea = 0;
	slp->firstrec = 0;
	nextblock = slp->tblock;
	return(1);
}

void
writerec(char *dp, int isspcl)
{

	slp->req[trecno].dblk = 0;
	slp->req[trecno].count = 1;
	*(union u_spcl *)(*(nextblock)++) = *(union u_spcl *)dp;
	if (isspcl)
		lastspclrec = spcl.c_tapea;
	trecno++;
	spcl.c_tapea++;
	if (trecno >= ntrec)
		flushtape();
}

void
dumpblock(daddr_t blkno, int size)
{
	int avail, tpblks;
	daddr_t dblkno;

	dblkno = fsbtodb(sblock, blkno);
	tpblks = size >> tp_bshift;
	while ((avail = MINIMUM(tpblks, ntrec - trecno)) > 0) {
		slp->req[trecno].dblk = dblkno;
		slp->req[trecno].count = avail;
		trecno += avail;
		spcl.c_tapea += avail;
		if (trecno >= ntrec)
			flushtape();
		dblkno += avail << (tp_bshift - (ffs(DEV_BSIZE) - 1));
		tpblks -= avail;
	}
}

int	nogripe = 0;

/* ARGSUSED */
void
tperror(int signo)
{
	/* XXX - signal races */

	if (pipeout) {
		msg("write error on %s\n", tape);
		quit("Cannot recover\n");
		/* NOTREACHED */
	}
	msg("write error %lld blocks into volume %d\n",
	    (long long)blocksthisvol, tapeno);
	broadcast("DUMP WRITE ERROR!\n");
	if (!query("Do you want to restart?"))
		dumpabort(0);
	msg("Closing this volume.  Prepare to restart with new media;\n");
	msg("this dump volume will be rewritten.\n");
	killall();
	nogripe = 1;
	close_rewind();
	Exit(X_REWRITE);
}

/* ARGSUSED */
void
sigpipe(int signo)
{

	quit("Broken pipe\n");
}

/*
 * do_stats --
 *	Update xferrate stats
 */
time_t
do_stats(void)
{
	time_t tnow, ttaken;
	int64_t blocks;

	(void)time(&tnow);
	ttaken = tnow - tstart_volume;
	blocks = spcl.c_tapea - tapea_volume;
	msg("Volume %d completed at: %s", tapeno, ctime(&tnow));
	if (ttaken > 0) {
		msg("Volume %d took %lld:%02lld:%02lld\n", tapeno,
		    (long long)ttaken / 3600, ((long long)ttaken % 3600) / 60,
		    (long long)ttaken % 60);
		blocks /= ttaken;
		msg("Volume %d transfer rate: %lld KB/s\n", tapeno, blocks);
		xferrate += blocks;
	}
	return(tnow);
}

/*
 * statussig --
 *	information message upon receipt of SIGINFO
 *	(derived from optr.c::timeest())
 * XXX not safe
 */
/* ARGSUSED */
void
statussig(int signo)
{
	time_t	tnow, deltat;
	char	msgbuf[128];
	int save_errno = errno;

	if (blockswritten < 500)
		return;
	(void) time(&tnow);
	deltat = tstart_writing - tnow + (1.0 * (tnow - tstart_writing))
		/ blockswritten * tapesize;
	(void)snprintf(msgbuf, sizeof(msgbuf),
	    "dump: %s %3.2f%% done at %lld KB/s, finished in %d:%02d\n",
	    tape, (blockswritten * 100.0) / tapesize,
	    (spcl.c_tapea - tapea_volume) / (tnow - tstart_volume),
	    (int)(deltat / 3600), (int)((deltat % 3600) / 60));
	write(STDERR_FILENO, msgbuf, strlen(msgbuf));
	errno = save_errno;
}

static void
flushtape(void)
{
	int i, blks, got;
	int64_t lastfirstrec;

	int siz = (char *)nextblock - (char *)slp->req;

	slp->req[trecno].count = 0;			/* Sentinel */

	if (atomic((ssize_t (*)(int, void *, size_t))write, slp->fd,
	    (char *)slp->req, siz) != siz)
		quit("error writing command pipe: %s\n", strerror(errno));
	slp->sent = 1; /* we sent a request, read the response later */

	lastfirstrec = slp->firstrec;

	if (++slp >= &slaves[SLAVES])
		slp = &slaves[0];

	/* Read results back from next slave */
	if (slp->sent) {
		if (atomic(read, slp->fd, (char *)&got, sizeof(got))
		    != sizeof(got)) {
			perror("  DUMP: error reading command pipe in master");
			dumpabort(0);
		}
		slp->sent = 0;

		/* Check for end of tape */
		if (got < writesize) {
			msg("End of tape detected\n");

			/*
			 * Drain the results, don't care what the values were.
			 * If we read them here then trewind won't...
			 */
			for (i = 0; i < SLAVES; i++) {
				if (slaves[i].sent) {
					if (atomic(read, slaves[i].fd,
					    (char *)&got, sizeof(got))
					    != sizeof(got)) {
						perror("  DUMP: error reading command pipe in master");
						dumpabort(0);
					}
					slaves[i].sent = 0;
				}
			}

			close_rewind();
			rollforward();
			return;
		}
	}

	blks = 0;
	if (spcl.c_type != TS_END) {
		for (i = 0; i < spcl.c_count; i++)
			if (spcl.c_addr[i] != 0)
				blks++;
	}
	slp->count = lastspclrec + blks + 1 - spcl.c_tapea;
	slp->tapea = spcl.c_tapea;
	slp->firstrec = lastfirstrec + ntrec;
	slp->inode = curino;
	nextblock = slp->tblock;
	trecno = 0;
	asize += tenths;
	blockswritten += ntrec;
	blocksthisvol += ntrec;
	if (!pipeout && !unlimited && (blocksperfile ?
	    (blocksthisvol >= blocksperfile) : (asize > tsize))) {
		close_rewind();
		startnewtape(0);
	}
	timeest();
}

void
trewind(void)
{
	struct stat sb;
	int f, got;

	for (f = 0; f < SLAVES; f++) {
		/*
		 * Drain the results, but unlike EOT we DO (or should) care
		 * what the return values were, since if we detect EOT after
		 * we think we've written the last blocks to the tape anyway,
		 * we have to replay those blocks with rollforward.
		 *
		 * fixme: punt for now.
		 */
		if (slaves[f].sent) {
			if (atomic(read, slaves[f].fd, (char *)&got, sizeof(got))
			    != sizeof(got)) {
				perror("  DUMP: error reading command pipe in master");
				dumpabort(0);
			}
			slaves[f].sent = 0;
			if (got != writesize) {
				msg("EOT detected in last 2 tape records!\n");
				msg("Use a longer tape, decrease the size estimate\n");
				quit("or use no size estimate at all.\n");
			}
		}
		(void) close(slaves[f].fd);
	}
	while (wait((int *)NULL) >= 0)	/* wait for any signals from slaves */
		/* void */;

	if (pipeout)
		return;

	msg("Closing %s\n", tape);

#ifdef RDUMP
	if (host) {
		rmtclose();
		while (rmtopen(tape, O_RDONLY) < 0)
			sleep(10);
		rmtclose();
		return;
	}
#endif
	/*
	 * st(4) says: "Bit 1 of the minor number specifies whether an eject is
	 * attempted when the device is closed.  When it is set, the device
	 * will attempt to eject its media on close ...".
	 *
	 * If the tape has been ejected, looping on open() will generate 'Media
	 * not present' errors until a tape is loaded. Once loaded the tape
	 * will be immediately ejected as a result of the second close().
	 *
	 * So if the tape will be ejected, just close and return.
	 */
	if ((fstat(tapefd, &sb) == 0) && (minor(sb.st_rdev) & 0x02)) {
		(void) close(tapefd);
		return;
	}

	(void) close(tapefd);
	while ((f = open(tape, O_RDONLY)) < 0)
		sleep (10);
	(void) close(f);
}

void
close_rewind(void)
{
	trewind();
	(void)do_stats();
	if (nexttape)
		return;
	if (!nogripe) {
		msg("Change Volumes: Mount volume #%d\n", tapeno+1);
		broadcast("CHANGE DUMP VOLUMES!\7\7\n");
	}
	while (!query("Is the new volume mounted and ready to go?"))
		if (query("Do you want to abort?")) {
			dumpabort(0);
			/*NOTREACHED*/
		}
}

void
rollforward(void)
{
	struct req *p, *q, *prev;
	struct slave *tslp;
	int i, size, got;
	int64_t savedtapea;
	union u_spcl *ntb, *otb;
	tslp = &slaves[SLAVES];
	ntb = (union u_spcl *)tslp->tblock[1];

	/*
	 * Each of the N slaves should have requests that need to
	 * be replayed on the next tape.  Use the extra slave buffers
	 * (slaves[SLAVES]) to construct request lists to be sent to
	 * each slave in turn.
	 */
	for (i = 0; i < SLAVES; i++) {
		q = &tslp->req[1];
		otb = (union u_spcl *)slp->tblock;

		/*
		 * For each request in the current slave, copy it to tslp.
		 */

		prev = NULL;
		for (p = slp->req; p->count > 0; p += p->count) {
			*q = *p;
			if (p->dblk == 0)
				*ntb++ = *otb++; /* copy the datablock also */
			prev = q;
			q += q->count;
		}
		if (prev == NULL)
			quit("rollforward: protocol botch\n");
		if (prev->dblk != 0)
			prev->count -= 1;
		else
			ntb--;
		q -= 1;
		q->count = 0;
		q = &tslp->req[0];
		if (i == 0) {
			q->dblk = 0;
			q->count = 1;
			trecno = 0;
			nextblock = tslp->tblock;
			savedtapea = spcl.c_tapea;
			spcl.c_tapea = slp->tapea;
			startnewtape(0);
			spcl.c_tapea = savedtapea;
			lastspclrec = savedtapea - 1;
		}
		size = (char *)ntb - (char *)q;
		if (atomic((ssize_t (*)(int, void *, size_t))write,
		    slp->fd, (char *)q, size) != size) {
			perror("  DUMP: error writing command pipe");
			dumpabort(0);
		}
		slp->sent = 1;
		if (++slp >= &slaves[SLAVES])
			slp = &slaves[0];

		q->count = 1;

		if (prev->dblk != 0) {
			/*
			 * If the last one was a disk block, make the
			 * first of this one be the last bit of that disk
			 * block...
			 */
			q->dblk = prev->dblk +
				prev->count * (TP_BSIZE / DEV_BSIZE);
			ntb = (union u_spcl *)tslp->tblock;
		} else {
			/*
			 * It wasn't a disk block.  Copy the data to its
			 * new location in the buffer.
			 */
			q->dblk = 0;
			*((union u_spcl *)tslp->tblock) = *ntb;
			ntb = (union u_spcl *)tslp->tblock[1];
		}
	}
	slp->req[0] = *q;
	nextblock = slp->tblock;
	if (q->dblk == 0)
		nextblock++;
	trecno = 1;

	/*
	 * Clear the first slaves' response.  One hopes that it
	 * worked ok, otherwise the tape is much too short!
	 */
	if (slp->sent) {
		if (atomic(read, slp->fd, (char *)&got, sizeof(got))
		    != sizeof(got)) {
			perror("  DUMP: error reading command pipe in master");
			dumpabort(0);
		}
		slp->sent = 0;

		if (got != writesize) {
			quit("EOT detected at start of the tape!\n");
		}
	}
}

/*
 * We implement taking and restoring checkpoints on the tape level.
 * When each tape is opened, a new process is created by forking; this
 * saves all of the necessary context in the parent.  The child
 * continues the dump; the parent waits around, saving the context.
 * If the child returns X_REWRITE, then it had problems writing that tape;
 * this causes the parent to fork again, duplicating the context, and
 * everything continues as if nothing had happened.
 */
void
startnewtape(int top)
{
	pid_t	parentpid;
	pid_t	childpid;
	int	status;
	pid_t	waitingpid;
	char	*p;
	sig_t	interrupt_save;

	interrupt_save = signal(SIGINT, SIG_IGN);
	parentpid = getpid();
	tapea_volume = spcl.c_tapea;
	(void)time(&tstart_volume);

restore_check_point:
	(void)signal(SIGINT, interrupt_save);
	/*
	 *	All signals are inherited...
	 */
	childpid = fork();
	if (childpid < 0) {
		msg("Context save fork fails in parent %d\n", parentpid);
		Exit(X_ABORT);
	}
	if (childpid != 0) {
		/*
		 *	PARENT:
		 *	save the context by waiting
		 *	until the child doing all of the work returns.
		 *	don't catch the interrupt
		 */
		signal(SIGINT, SIG_IGN);
#ifdef TDEBUG
		msg("Tape: %d; parent process: %d child process %d\n",
			tapeno+1, parentpid, childpid);
#endif /* TDEBUG */
		while ((waitingpid = wait(&status)) != childpid)
			msg("Parent %d waiting for child %d has another child %d return\n",
				parentpid, childpid, waitingpid);
		if (status & 0xFF) {
			msg("Child %d returns LOB status %o\n",
				childpid, status&0xFF);
		}
		status = (status >> 8) & 0xFF;
#ifdef TDEBUG
		switch(status) {
			case X_FINOK:
				msg("Child %d finishes X_FINOK\n", childpid);
				break;
			case X_ABORT:
				msg("Child %d finishes X_ABORT\n", childpid);
				break;
			case X_REWRITE:
				msg("Child %d finishes X_REWRITE\n", childpid);
				break;
			default:
				msg("Child %d finishes unknown %d\n",
					childpid, status);
				break;
		}
#endif /* TDEBUG */
		switch(status) {
			case X_FINOK:
				Exit(X_FINOK);
				break;
			case X_ABORT:
				Exit(X_ABORT);
				break;
			case X_REWRITE:
				goto restore_check_point;
			default:
				msg("Bad return code from dump: %d\n", status);
				Exit(X_ABORT);
		}
		/*NOTREACHED*/
	} else {	/* we are the child; just continue */
#ifdef TDEBUG
		sleep(4);	/* allow time for parent's message to get out */
		msg("Child on Tape %d has parent %d, my pid = %d\n",
			tapeno+1, parentpid, getpid());
#endif /* TDEBUG */
		/*
		 * If we have a name like "/dev/rst0,/dev/rst1",
		 * use the name before the comma first, and save
		 * the remaining names for subsequent volumes.
		 */
		tapeno++;               /* current tape sequence */
		if (nexttape || strchr(tape, ',')) {
			if (nexttape && *nexttape)
				tape = nexttape;
			if ((p = strchr(tape, ',')) != NULL) {
				*p = '\0';
				nexttape = p + 1;
			} else
				nexttape = NULL;
			msg("Dumping volume %d on %s\n", tapeno, tape);
		}
#ifdef RDUMP
		while ((tapefd = (host ? rmtopen(tape, O_WRONLY|O_CREAT) :
			pipeout ? 1 : open(tape, O_WRONLY|O_CREAT, 0666))) < 0)
#else
		while ((tapefd = (pipeout ? 1 :
				  open(tape, O_WRONLY|O_CREAT, 0666))) < 0)
#endif
		    {
			msg("Cannot open output \"%s\".\n", tape);
			if (!query("Do you want to retry the open?"))
				dumpabort(0);
		}

		enslave();  /* Share open tape file descriptor with slaves */

		asize = 0;
		blocksthisvol = 0;
		if (top)
			newtape++;		/* new tape signal */
		spcl.c_count = slp->count;
		/*
		 * measure firstrec in TP_BSIZE units since restore doesn't
		 * know the correct ntrec value...
		 */
		spcl.c_firstrec = slp->firstrec;
		spcl.c_volume++;
		spcl.c_type = TS_TAPE;
		if (sblock->fs_magic != FS_UFS2_MAGIC)
			spcl.c_flags |= DR_NEWHEADER;
		writeheader((ino_t)slp->inode);
		if (sblock->fs_magic != FS_UFS2_MAGIC)
			spcl.c_flags &=~ DR_NEWHEADER;
		msg("Volume %d started at: %s", tapeno, ctime(&tstart_volume));
		if (tapeno > 1)
			msg("Volume %d begins with blocks from inode %llu\n",
			    tapeno, (unsigned long long)slp->inode);
	}
}

/* ARGSUSED */
void
dumpabort(int signo)
{

	if (master != 0 && master != getpid())
		/* Signals master to call dumpabort */
		(void) kill(master, SIGTERM);
	else {
		killall();
		msg("The ENTIRE dump is aborted.\n");
	}
#ifdef RDUMP
	rmtclose();
#endif
	Exit(X_ABORT);
}

__dead void
Exit(int status)
{

#ifdef TDEBUG
	msg("pid = %d exits with status %d\n", getpid(), status);
#endif /* TDEBUG */
	exit(status);
}

/*
 * proceed - handler for SIGUSR2, used to synchronize IO between the slaves.
 */
/* ARGSUSED */
void
proceed(int signo)
{
	caught++;
}

void
enslave(void)
{
	int cmd[2];
	int i, j;

	master = getpid();

	signal(SIGTERM, dumpabort);  /* Slave sends SIGTERM on dumpabort() */
	signal(SIGPIPE, sigpipe);
	signal(SIGUSR1, tperror);    /* Slave sends SIGUSR1 on tape errors */
	signal(SIGUSR2, proceed);    /* Slave sends SIGUSR2 to next slave */

	for (i = 0; i < SLAVES; i++) {
		if (i == slp - &slaves[0]) {
			caught = 1;
		} else {
			caught = 0;
		}

		if (socketpair(AF_UNIX, SOCK_STREAM, 0, cmd) < 0 ||
		    (slaves[i].pid = fork()) < 0)
			quit("too many slaves, %d (recompile smaller): %s\n",
			    i, strerror(errno));

		slaves[i].fd = cmd[1];
		slaves[i].sent = 0;
		if (slaves[i].pid == 0) { 	    /* Slave starts up here */
			for (j = 0; j <= i; j++)
			        (void) close(slaves[j].fd);
			signal(SIGINT, SIG_IGN);    /* Master handles this */
			signal(SIGINFO, SIG_IGN);
			doslave(cmd[0], i);
			Exit(X_FINOK);
		}
	}

	for (i = 0; i < SLAVES; i++)
		(void) atomic((ssize_t (*)(int, void *, size_t))write,
		    slaves[i].fd, (char *) &slaves[(i + 1) % SLAVES].pid,
		    sizeof(slaves[0].pid));
	master = 0;
}

void
killall(void)
{
	int i;

	for (i = 0; i < SLAVES; i++)
		if (slaves[i].pid > 0) {
			(void) kill(slaves[i].pid, SIGKILL);
			slaves[i].pid = 0;
		}
}

/*
 * Synchronization - each process has a lockfile, and shares file
 * descriptors to the following process's lockfile.  When our write
 * completes, we release our lock on the following process's lock-
 * file, allowing the following process to lock it and proceed. We
 * get the lock back for the next cycle by swapping descriptors.
 */
static void
doslave(int cmd, int slave_number)
{
	int nread, nextslave, size, wrote = 0, eot_count;
	sigset_t nsigset, osigset;

	/*
	 * Need our own seek pointer.
	 */
	(void) close(diskfd);
	if ((diskfd = open(disk, O_RDONLY)) < 0)
		quit("slave couldn't reopen disk: %s\n", strerror(errno));

	/*
	 * Need the pid of the next slave in the loop...
	 */
	if ((nread = atomic(read, cmd, (char *)&nextslave, sizeof(nextslave)))
	    != sizeof(nextslave)) {
		quit("master/slave protocol botched - didn't get pid of next slave.\n");
	}

	/*
	 * Get list of blocks to dump, read the blocks into tape buffer
	 */
	while ((nread = atomic(read, cmd, (char *)slp->req, reqsiz)) == reqsiz) {
		struct req *p = slp->req;

		for (trecno = 0; trecno < ntrec;
		     trecno += p->count, p += p->count) {
			if (p->dblk) {
				bread(p->dblk, slp->tblock[trecno],
					p->count * TP_BSIZE);
			} else {
				if (p->count != 1 || atomic(read, cmd,
				    (char *)slp->tblock[trecno],
				    TP_BSIZE) != TP_BSIZE)
				       quit("master/slave protocol botched.\n");
			}
		}

		sigemptyset(&nsigset);
		sigaddset(&nsigset, SIGUSR2);
		sigprocmask(SIG_BLOCK, &nsigset, &osigset);
		while (!caught)
			sigsuspend(&osigset);
		caught = 0;
		sigprocmask(SIG_SETMASK, &osigset, NULL);

		/* Try to write the data... */
		eot_count = 0;
		size = 0;

		while (eot_count < 10 && size < writesize) {
#ifdef RDUMP
			if (host)
				wrote = rmtwrite(slp->tblock[0]+size,
				    writesize-size);
			else
#endif
				wrote = write(tapefd, slp->tblock[0]+size,
				    writesize-size);
#ifdef WRITEDEBUG
			printf("slave %d wrote %d\n", slave_number, wrote);
#endif
			if (wrote < 0)
				break;
			if (wrote == 0)
				eot_count++;
			size += wrote;
		}

#ifdef WRITEDEBUG
		if (size != writesize)
		 printf("slave %d only wrote %d out of %d bytes and gave up.\n",
		     slave_number, size, writesize);
#endif

		if (eot_count > 0)
			size = 0;

		/*
		 * Handle ENOSPC as an EOT condition
		 */
		if (wrote < 0 && errno == ENOSPC) {
			wrote = 0;
			eot_count++;
		}

		if (size < 0) {
			(void) kill(master, SIGUSR1);
			sigemptyset(&nsigset);
			for (;;)
				sigsuspend(&nsigset);
		} else {
			/*
			 * pass size of write back to master
			 * (for EOT handling)
			 */
			(void) atomic((ssize_t (*)(int, void *, size_t))write,
			    cmd, (char *)&size, sizeof(size));
		}

		/*
		 * If partial write, don't want next slave to go.
		 * Also jolts him awake.
		 */
		(void) kill(nextslave, SIGUSR2);
	}
	if (nread != 0)
		quit("error reading command pipe: %s\n", strerror(errno));
}

/*
 * Since a read from a pipe may not return all we asked for,
 * or a write may not write all we ask if we get a signal,
 * loop until the count is satisfied (or error).
 */
static ssize_t
atomic(ssize_t (*func)(int, void *, size_t), int fd, char *buf, int count)
{
	ssize_t got, need = count;

	while ((got = (*func)(fd, buf, need)) > 0 && (need -= got) > 0)
		buf += got;
	return (got < 0 ? got : count - need);
}
@


1.42
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.41 2015/01/16 06:39:57 deraadt Exp $	*/
d141 1
a141 2
		buf = (char *)
		    malloc((unsigned)(reqsiz + writesize + pgoff + TP_BSIZE));
@


1.41
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.40 2014/06/13 20:43:06 naddy Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE */
@


1.40
log
@Type cleanup:
* Move all off_t variables that don't look like file sizes to int64_t.
* Switch blockswritten to int64_t, so it won't wrap at 2TB.
* Same for blocksthisvol (from deraadt@@).
* Switch xferrate (from tedu@@) and blocksperfile from long to uint64_t.
* Since blocksperfile can be set with -B, move numarg() from long
to long long and don't mark small integer constant arguments as long.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.39 2014/05/24 21:49:09 krw Exp $	*/
d33 1
a33 2
#include <sys/types.h>
#include <sys/param.h>
d51 1
d56 2
d180 1
a180 1
	while ((avail = MIN(tpblks, ntrec - trecno)) > 0) {
@


1.39
log
@Nuke last of the illusionary 'dev_bsize' and 'dev_bshift' variables in
favour of DEV_BSIZE. No-op on 512-byte sector devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.38 2013/11/12 04:59:02 deraadt Exp $	*/
d59 2
a60 2
extern	long blocksperfile;	/* number of blocks per output file */
long	blocksthisvol;		/* number of blocks on current output file */
d203 2
a204 1
	msg("write error %ld blocks into volume %d\n", blocksthisvol, tapeno);
@


1.38
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.37 2013/11/02 00:08:16 krw Exp $	*/
d185 1
a185 1
		dblkno += avail << (tp_bshift - dev_bshift);
@


1.37
log
@No need to cast constants or simple variables to (daddr_t). Use
(u_int64_t) instead of (daddr_t) when casting a variable in an
expression passed to DL_SETDSIZE().

Change a variable counting open files from daddr_t to int64_t.

ok deraadt@@ with the tweak to fix that pesky expression.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.36 2013/06/11 16:42:04 deraadt Exp $	*/
d72 4
@


1.36
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.35 2013/04/25 06:43:20 otto Exp $	*/
d155 1
a155 1
	slp->req[trecno].dblk = (daddr_t)0;
@


1.35
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.34 2013/04/23 21:39:59 deraadt Exp $	*/
d82 1
a82 1
	daddr64_t dblk;
d155 1
a155 1
	slp->req[trecno].dblk = (daddr64_t)0;
d167 1
a167 1
dumpblock(daddr64_t blkno, int size)
d170 1
a170 1
	daddr64_t dblkno;
@


1.34
log
@handle large ino_t; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.33 2013/04/16 18:17:39 deraadt Exp $	*/
d234 3
a236 2
		msg("Volume %d took %d:%02d:%02d\n", tapeno,
		    ttaken / 3600, (ttaken % 3600) / 60, ttaken % 60);
@


1.33
log
@do not need to cast type to same type
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.32 2012/08/22 05:20:51 halex Exp $	*/
d685 2
a686 2
			msg("Volume %d begins with blocks from inode %d\n",
				tapeno, slp->inode);
@


1.32
log
@- open a remote file/device with the same flags we use when opening a
  local one
- replace a few magic numbers with the appropriate constants

ok millert@@ (pre-lock)
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.31 2009/10/27 23:59:32 deraadt Exp $	*/
d259 1
a259 1
	(void) time((time_t *) &tnow);
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.30 2008/01/11 07:04:22 otto Exp $	*/
d390 1
a390 1
		while (rmtopen(tape, 0) < 0)
d413 1
a413 1
	while ((f = open(tape, 0)) < 0)
d652 1
a652 1
		while ((tapefd = (host ? rmtopen(tape, 2) :
@


1.30
log
@compute transfer rate using 64-bit arithmetic, ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.29 2007/06/03 20:16:08 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tape.c	8.2 (Berkeley) 3/17/94";
#else
static const char rcsid[] = "$OpenBSD: tape.c,v 1.29 2007/06/03 20:16:08 millert Exp $";
#endif
#endif /* not lint */
@


1.29
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.28 2007/03/04 22:36:54 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.28 2007/03/04 22:36:54 deraadt Exp $";
d235 1
a235 1
	int blocks;
d244 3
a246 3
		msg("Volume %d transfer rate: %d KB/s\n", tapeno,
		    blocks / ttaken);
		xferrate += blocks / ttaken;
@


1.28
log
@delete sunos junk; Jim Razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.27 2006/06/02 05:09:35 krw Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.27 2006/06/02 05:09:35 krw Exp $";
d65 1
a65 1
long	lastspclrec = -1;	/* tape block number of last written header */
d90 1
a90 1
	daddr_t dblk;
d97 2
a98 1
	int tapea;		/* header number at start of this chunk */
a104 1
	int firstrec;		/* record number of this block */
d113 1
a113 1
static int tapea_volume;	/* value of spcl.c_tapea at volume start */
d163 1
a163 1
	slp->req[trecno].dblk = (daddr_t)0;
d175 1
a175 1
dumpblock(daddr_t blkno, int size)
d177 2
a178 1
	int avail, tpblks, dblkno;
d207 1
a207 1
	msg("write error %d blocks into volume %d\n", blocksthisvol, tapeno);
d244 1
a244 1
		msg("Volume %d transfer rate: %ld KB/s\n", tapeno,
d271 1
a271 1
	    "dump: %s %3.2f%% done at %d KB/s, finished in %d:%02d\n",
d283 1
a283 1
	long lastfirstrec;
d449 2
a450 1
	int i, size, savedtapea, got;
d686 2
a687 1
		spcl.c_flags |= DR_NEWHEADER;
d689 2
a690 1
		spcl.c_flags &=~ DR_NEWHEADER;
d802 1
a802 1
	int nread, nextslave, size, wrote, eot_count;
@


1.27
log
@Fix comment to reflect updated st(4) verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.26 2006/05/30 20:09:53 krw Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.26 2006/05/30 20:09:53 krw Exp $";
a46 6
#ifdef sunos
#include <sys/vnode.h>

#include <ufs/fs.h>
#include <ufs/inode.h>
#else
a48 1
#endif
a566 3
#ifdef sunos
	void	(*interrupt_save)();
#else
a567 1
#endif
@


1.26
log
@Don't double-eject tapes. Once is enough. Closes PR#1282.

ok miod@@ beck@@, functionally equivalent diff ok deraadt@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.25 2006/04/13 00:48:48 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.25 2006/04/13 00:48:48 deraadt Exp $";
d411 3
a413 4
	 * st(4) says: "... bits 0 and 1 of the minor number are interpreted as
	 * `sub-modes'.  The sub-modes differ in the action taken when the
	 * device is closed ...". In short, if bit 1 is set the tape will be
	 * ejected on close.
@


1.25
log
@put "dump: filename " at the start of each ^T message...
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.24 2005/03/13 19:10:49 cloder Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.24 2005/03/13 19:10:49 cloder Exp $";
d41 1
d46 1
d366 2
a367 2
	int f;
	int got;
d410 17
@


1.24
log
@Use pid_t where appropriate.  From Bruno Rohee (thanks).
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.23 2005/01/23 18:49:19 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.23 2005/01/23 18:49:19 millert Exp $";
d275 2
a276 2
	    "%3.2f%% done at %d KB/s, finished in %d:%02d\n",
	    (blockswritten * 100.0) / tapesize,
@


1.23
log
@"caught" should be volatile sig_atomic_t; lukem@@netbsd.org
Also mark tperror handler as unsafe; dump needs a signal safety overhaul.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.22 2005/01/23 18:33:12 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.22 2005/01/23 18:33:12 millert Exp $";
d107 1
a107 1
	int pid;		/* PID for this slave */
d120 1
a120 1
int master;		/* pid of master, for sending error signals */
d551 2
a552 2
	int	parentpid;
	int	childpid;
d554 1
a554 1
	int	waitingpid;
@


1.22
log
@Avoid signal race condition.  If a slave gets SIGUSR2 between the
"setjmp" and the "ready = 1" statements, the slave will pause forever
and the whole dump hangs.  Fix by hannken@@netbsd.org
Closes PR 4070; also tested by henning@@ and marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.21 2004/11/04 20:10:07 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.21 2004/11/04 20:10:07 deraadt Exp $";
d122 1
a122 1
static int caught;	/* have we caught the signal to proceed? */
d204 1
@


1.21
log
@very basic de-lints
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.20 2003/07/29 18:38:35 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.20 2003/07/29 18:38:35 deraadt Exp $";
a58 1
#include <setjmp.h>
a122 4
static int ready;	/* have we reached the lock point without having */
			/* received the SIGUSR2 signal from the prev slave? */
static jmp_buf jmpbuf;	/* where to jump to if we are ready when the */
			/* SIGUSR2 arrives from the previous slave */
a720 3

	if (ready)
		longjmp(jmpbuf, 1);
d790 2
a791 4
	int nread;
	int nextslave, size, eot_count;
	volatile int wrote;
	sigset_t sigset;
d826 6
a831 6
		if (setjmp(jmpbuf) == 0) {
			ready = 1;
			if (!caught)
				(void) pause();
		}
		ready = 0;
d833 1
d877 1
a877 1
			sigemptyset(&sigset);
d879 1
a879 1
				sigsuspend(&sigset);
@


1.20
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.19 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.19 2003/07/28 06:13:26 tedu Exp $";
d205 1
d227 1
d265 1
d267 1
a267 1
statussig(int notused)
d558 1
a558 1
	int	waitpid;
d593 1
a593 1
		while ((waitpid = wait(&status)) != childpid)
d595 1
a595 1
				parentpid, childpid, waitpid);
d621 1
d624 1
d691 1
d722 1
@


1.19
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.18 2003/07/07 01:25:30 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.17 2003/06/26 16:35:21 deraadt Exp $";
d603 1
a603 1
			case X_ABORT:	
d761 1
a761 1
	
a765 1
		
@


1.18
log
@I never committed the fix for PR 3296, "Dump prints negative numbers for time"
Here it is...
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.17 2003/06/26 16:35:21 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.17 2003/06/26 16:35:21 deraadt Exp $";
@


1.17
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.16 2003/06/02 20:06:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.16 2003/06/02 20:06:14 millert Exp $";
a417 2
	time_t tstart_changevol, tend_changevol;

a421 1
	time(&tstart_changevol);
a430 2
	time(&tend_changevol);
	tstart_writing += (tend_changevol - tstart_changevol);
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.15 2002/02/19 19:39:38 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.15 2002/02/19 19:39:38 millert Exp $";
d80 1
a80 1
static	ssize_t atomic(ssize_t (*)(), int, char *, int);
d130 1
a130 1
alloctape()
d170 1
a170 3
writerec(dp, isspcl)
	char *dp;
	int isspcl;
d185 1
a185 3
dumpblock(blkno, size)
	daddr_t blkno;
	int size;
d206 1
a206 2
tperror(signo)
	int signo;
d227 1
a227 2
sigpipe(signo)
	int signo;
d238 1
a238 1
do_stats()
d264 1
a264 2
statussig(notused)
	int notused;
d285 1
a285 1
flushtape()
d294 2
a295 1
	if (atomic(write, slp->fd, (char *)slp->req, siz) != siz)
d363 1
a363 1
trewind()
d416 1
a416 1
close_rewind()
d439 1
a439 1
rollforward()
d491 2
a492 1
		if (atomic(write, slp->fd, (char *)q, size) != size) {
d555 1
a555 2
startnewtape(top)
	int top;
d692 1
a692 2
dumpabort(signo)
	int signo;
d709 1
a709 2
Exit(status)
	int status;
d722 1
a722 2
proceed(signo)
	int signo;
d731 1
a731 1
enslave()
d768 3
a770 3
		(void) atomic(write, slaves[i].fd,
			      (char *) &slaves[(i + 1) % SLAVES].pid,
		              sizeof(slaves[0].pid));
d776 1
a776 1
killall()
d795 1
a795 3
doslave(cmd, slave_number)
	int cmd;
        int slave_number;
d893 2
a894 1
			(void) atomic(write, cmd, (char *)&size, sizeof(size));
d913 1
a913 5
atomic(func, fd, buf, count)
	ssize_t (*func)();
	int fd;
	char *buf;
	int count;
@


1.15
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.14 2002/02/17 19:42:27 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.14 2002/02/17 19:42:27 millert Exp $";
@


1.14
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.13 2002/02/16 21:27:33 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.13 2002/02/16 21:27:33 millert Exp $";
a65 1
#ifdef __STDC__
a69 3
#else
int	write(), read();
#endif
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.12 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.12 2001/11/05 07:39:16 mpech Exp $";
d88 1
a88 1
static	ssize_t atomic __P((ssize_t (*)(), int, char *, int));
@


1.12
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.11 2001/01/19 17:57:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.11 2001/01/19 17:57:35 deraadt Exp $";
d89 5
a93 5
static	void doslave __P((int, int));
static	void enslave __P((void));
static	void flushtape __P((void));
static	void killall __P((void));
static	void rollforward __P((void));
@


1.11
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.10 1999/02/28 06:50:14 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.10 1999/02/28 06:50:14 deraadt Exp $";
d455 2
a456 2
	register struct req *p, *q, *prev;
	register struct slave *tslp;
d751 1
a751 1
	register int i, j;
d795 1
a795 1
	register int i;
d813 1
a813 1
	register int cmd;
d816 1
a816 1
	register int nread;
d840 1
a840 1
		register struct req *p = slp->req;
@


1.10
log
@if we kill, do not kill again
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.9 1999/02/21 00:07:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.9 1999/02/21 00:07:16 millert Exp $";
d275 1
@


1.9
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.8 1999/02/20 21:46:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.8 1999/02/20 21:46:06 deraadt Exp $";
d797 1
a797 1
		if (slaves[i].pid > 0)
d799 2
@


1.8
log
@quit() wants the \n
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.7 1998/04/26 18:11:04 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.7 1998/04/26 18:11:04 deraadt Exp $";
d290 1
a290 1
	    "%3.2f%% done at %ld KB/s, finished in %d:%02d\n",
d814 2
a815 1
	int nextslave, size, wrote, eot_count;
@


1.7
log
@handle ENOSPC as an end-of-tape marker; gibbs@@narnia.plutotech.com
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.6 1997/08/25 15:09:10 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.6 1997/08/25 15:09:10 deraadt Exp $";
d484 1
a484 1
			quit("rollforward: protocol botch");
@


1.6
log
@subtract take changing time from estimate; blank@@fox.uni-trier.de
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.5 1997/08/05 23:17:12 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.5 1997/08/05 23:17:12 angelos Exp $";
d891 1
a891 2
		 * fixme: Pyramids running OSx return ENOSPC
		 * at EOT on 1/2 inch drives.
d893 5
@


1.5
log
@Save/restore the errno when handling interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.4 1997/07/05 05:35:58 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.4 1997/07/05 05:35:58 millert Exp $";
d431 2
d437 1
d447 2
@


1.4
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.3 1997/02/03 11:53:27 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.3 1997/02/03 11:53:27 deraadt Exp $";
d282 1
d295 1
@


1.3
log
@new -a option autosizes, meaning it runs till it hits EOM (no need for
pesky sizing options) -- from FreeBSD.
also make -b option aware of MAXPHYS issues (via a little hack)
@
text
@d1 2
a2 2
/*	$OpenBSD: tape.c,v 1.2 1996/06/23 14:30:13 deraadt Exp $	*/
/*	$NetBSD: tape.c,v 1.7 1995/03/21 18:48:47 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.2 1996/06/23 14:30:13 deraadt Exp $";
d69 1
d126 3
d247 49
d317 2
a318 2
		if (atomic(read, slp->fd, (char *)&got, sizeof got)
		    != sizeof got) {
d335 2
a336 2
					    (char *)&got, sizeof got)
					    != sizeof got) {
d381 3
a383 3
		 * Drain the results, but unlike EOT we DO (or should) care 
		 * what the return values were, since if we detect EOT after 
		 * we think we've written the last blocks to the tape anyway, 
d386 1
a386 1
		 * fixme: punt for now.  
d389 2
a390 2
			if (atomic(read, slaves[f].fd, (char *)&got, sizeof got)
			    != sizeof got) {
d430 1
d455 3
a457 3
	 * Each of the N slaves should have requests that need to 
	 * be replayed on the next tape.  Use the extra slave buffers 
	 * (slaves[SLAVES]) to construct request lists to be sent to 
d465 1
a465 1
		 * For each request in the current slave, copy it to tslp. 
d509 2
a510 2
			 * If the last one was a disk block, make the 
			 * first of this one be the last bit of that disk 
d518 1
a518 1
			 * It wasn't a disk block.  Copy the data to its 
d537 2
a538 2
		if (atomic(read, slp->fd, (char *)&got, sizeof got)
		    != sizeof got) {
d576 2
d645 1
a645 1
		 * If we have a name like "/dev/rmt0,/dev/rmt1",
d664 1
a664 1
		while ((tapefd = (pipeout ? 1 : 
d679 1
a679 1
		spcl.c_count = slp->count; 
d690 1
d770 1
d777 3
a779 3
		(void) atomic(write, slaves[i].fd, 
			      (char *) &slaves[(i + 1) % SLAVES].pid, 
		              sizeof slaves[0].pid);
d781 1
a781 1
	master = 0; 
d820 2
a821 2
	if ((nread = atomic(read, cmd, (char *)&nextslave, sizeof nextslave))
	    != sizeof nextslave) {
d838 1
a838 1
				    (char *)slp->tblock[trecno], 
d867 1
a867 1
			if (wrote < 0) 
d875 1
a875 1
		if (size != writesize) 
d897 2
a898 2
			(void) atomic(write, cmd, (char *)&size, sizeof size);
		} 
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.7 1995/03/21 18:48:47 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tape.c,v 1.7 1995/03/21 18:48:47 mycroft Exp $";
d148 1
a148 1
	if (blocksperfile == 0)
d312 1
a312 1
	if (!pipeout && (blocksperfile ?
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: tape.c,v 1.7 1995/03/21 18:48:47 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
