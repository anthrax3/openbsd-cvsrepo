head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.8
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.8
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.02.12.59.35;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.04.22.36.54;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.04.20.10.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.13.09.09.25;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.21.16.16.26;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.19.17.57.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.22.20.24.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.01.04.08.11.53;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.11.24.01.25.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.07.14.19.04.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.04.26.18.10.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.05.05.35.55;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.25.18.07.55;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.15.20.14.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.02.22.15.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.01.15.31.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.06.17.02.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.21.00.15.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: dumprmt.c,v 1.28 2013/11/22 04:12:47 deraadt Exp $	*/
/*	$NetBSD: dumprmt.c,v 1.17 1997/06/05 16:10:47 mrg Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/mtio.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <ufs/ufs/dinode.h>

#include <netinet/in.h>
#include <netinet/tcp.h>

#include <protocols/dumprestore.h>

#include <ctype.h>
#include <err.h>
#include <netdb.h>
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "pathnames.h"
#include "dump.h"

#define	TS_CLOSED	0
#define	TS_OPEN		1

static	int rmtstate = TS_CLOSED;
static	int rmtape;
static	char *rmtpeer;

static	int okname(char *);
static	int rmtcall(char *, char *);
static	void rmtconnaborted(int);
static	int rmtgetb(void);
static	void rmtgetconn(void);
static	void rmtgets(char *, int);
static	int rmtreply(char *);

int	rmthost(char *host);
int	rmtopen(char *tape, int mode);
int	rmtread(char *buf, int count);
int	rmtwrite(char *buf, int count);
int	rmtseek(int offset, int pos);
int	rmtioctl(int cmd, int count);
void	rmtclose(void);

extern	int ntrec;		/* blocking factor on tape */

int
rmthost(char *host)
{
	int len = strlen(host) + 1;

	rmtpeer = malloc(len);
	if (rmtpeer)
		strlcpy(rmtpeer, host, len);
	else
		rmtpeer = host;
	signal(SIGPIPE, rmtconnaborted);
	rmtgetconn();
	if (rmtape < 0)
		return (0);
	return (1);
}

/* ARGSUSED */
static void
rmtconnaborted(int signo)
{
	/* XXX signal race */
	errx(X_ABORT, "Lost connection to remote host.");
}

void
rmtgetconn(void)
{
	char *cp;
	static struct servent *sp = NULL;
	static struct passwd *pwd = NULL;
	static int on = 1;
	char *tuser, *name;
	int size;
	int maxseg;

	if (sp == NULL) {
		sp = getservbyname("shell", "tcp");
		if (sp == NULL)
			errx(X_STARTUP, "shell/tcp: unknown service");
		pwd = getpwuid(getuid());
		if (pwd == NULL)
			errx(X_STARTUP, "who are you?");
	}
	if ((name = strdup(pwd->pw_name)) == NULL)
		err(X_STARTUP, "malloc");
	if ((cp = strchr(rmtpeer, '@@')) != NULL) {
		tuser = rmtpeer;
		*cp = '\0';
		if (!okname(tuser))
			exit(X_STARTUP);
		rmtpeer = ++cp;
	} else
		tuser = name;

	rmtape = rcmd(&rmtpeer, sp->s_port, name, tuser, _PATH_RMT, NULL);
	(void)free(name);
	if (rmtape < 0)
		return;

	size = ntrec * TP_BSIZE;
	if (size > 60 * 1024)		/* XXX */
		size = 60 * 1024;
	/* Leave some space for rmt request/response protocol */
	size += 2 * 1024;
	while (size > TP_BSIZE &&
	    setsockopt(rmtape, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) < 0)
		    size -= TP_BSIZE;
	(void)setsockopt(rmtape, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size));

	maxseg = 1024;
	(void)setsockopt(rmtape, IPPROTO_TCP, TCP_MAXSEG, &maxseg,
		sizeof(maxseg));

	(void) setsockopt(rmtape, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
}

static int
okname(char *cp0)
{
	char *cp;
	unsigned char c;

	for (cp = cp0; *cp; cp++) {
		c = *cp;
		if (!isascii(c) || !(isalnum(c) || c == '_' || c == '-')) {
			warnx("invalid user name: %s", cp0);
			return (0);
		}
	}
	return (1);
}

int
rmtopen(char *tape, int mode)
{
	char buf[256];

	(void)snprintf(buf, sizeof(buf), "O%s\n%d\n", tape, mode);
	rmtstate = TS_OPEN;
	return (rmtcall(tape, buf));
}

void
rmtclose(void)
{

	if (rmtstate != TS_OPEN)
		return;
	rmtcall("close", "C\n");
	rmtstate = TS_CLOSED;
}

int
rmtread(char *buf, int count)
{
	char line[30];
	int n, i, cc;

	(void)snprintf(line, sizeof(line), "R%d\n", count);
	n = rmtcall("read", line);
	if (n < 0) {
		errno = n;
		return (-1);
	}
	for (i = 0; i < n; i += cc) {
		cc = read(rmtape, buf+i, n - i);
		if (cc <= 0) {
			rmtconnaborted(0);
		}
	}
	return (n);
}

int
rmtwrite(char *buf, int count)
{
	char line[30];

	(void)snprintf(line, sizeof(line), "W%d\n", count);
	write(rmtape, line, strlen(line));
	write(rmtape, buf, count);
	return (rmtreply("write"));
}

int
rmtseek(int offset, int pos)
{
	char line[80];

	(void)snprintf(line, sizeof(line), "L%d\n%d\n", offset, pos);
	return (rmtcall("seek", line));
}

int
rmtioctl(int cmd, int count)
{
	char buf[256];

	if (count < 0)
		return (-1);
	(void)snprintf(buf, sizeof(buf), "I%d\n%d\n", cmd, count);
	return (rmtcall("ioctl", buf));
}

static int
rmtcall(char *cmd, char *buf)
{

	if (write(rmtape, buf, strlen(buf)) != strlen(buf))
		rmtconnaborted(0);
	return (rmtreply(cmd));
}

static int
rmtreply(char *cmd)
{
	char *cp;
	char code[30], emsg[BUFSIZ];

	rmtgets(code, sizeof(code));
	if (*code == 'E' || *code == 'F') {
		rmtgets(emsg, sizeof(emsg));
		msg("%s: %s", cmd, emsg);
		errno = atoi(&code[1]);
		if (*code == 'F')
			rmtstate = TS_CLOSED;
		return (-1);
	}
	if (*code != 'A') {
		/* Kill trailing newline */
		cp = code + strlen(code);
		if (cp > code && *--cp == '\n')
			*cp = '\0';

		msg("Protocol to remote tape server botched (code \"%s\").\n",
		    code);
		rmtconnaborted(0);
	}
	return (atoi(code + 1));
}

int
rmtgetb(void)
{
	char c;

	if (read(rmtape, &c, 1) != 1)
		rmtconnaborted(0);
	return (c);
}

/* Get a line (guaranteed to have a trailing newline). */
void
rmtgets(char *line, int len)
{
	char *cp = line;

	while (len > 1) {
		*cp = rmtgetb();
		if (*cp == '\n') {
			cp[1] = '\0';
			return;
		}
		cp++;
		len--;
	}
	*cp = '\0';
	msg("Protocol to remote tape server botched.\n");
	msg("(rmtgets got \"%s\").\n", line);
	rmtconnaborted(0);
}
@


1.28
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.27 2013/11/12 04:59:02 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d55 1
@


1.27
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.26 2009/10/27 23:59:32 deraadt Exp $	*/
d165 1
a165 1
	int c;
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.25 2008/01/02 12:59:35 chl Exp $	*/
d73 8
@


1.25
log
@remove unused functions

initially from tobias@@, and I removed an unused struct too

ok moritz@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.24 2007/03/04 22:36:54 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dumprmt.c	8.1 (Berkeley) 6/5/93";
#else
static const char rcsid[] = "$OpenBSD: dumprmt.c,v 1.24 2007/03/04 22:36:54 deraadt Exp $";
#endif
#endif /* not lint */
@


1.24
log
@delete sunos junk; Jim Razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.23 2004/11/04 20:10:06 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dumprmt.c,v 1.23 2004/11/04 20:10:06 deraadt Exp $";
a228 23
void
rmtwrite0(int count)
{
	char line[30];

	(void)snprintf(line, sizeof(line), "W%d\n", count);
	write(rmtape, line, strlen(line));
}

void
rmtwrite1(char *buf, int count)
{

	write(rmtape, buf, count);
}

int
rmtwrite2(void)
{

	return (rmtreply("write"));
}

a235 16
}

struct	mtget mts;

struct mtget *
rmtstatus(void)
{
	int i;
	char *cp;

	if (rmtstate != TS_OPEN)
		return (NULL);
	rmtcall("status", "S\n");
	for (i = 0, cp = (char *)&mts; i < sizeof(mts); i++)
		*cp++ = rmtgetb();
	return (&mts);
@


1.23
log
@very basic de-lints
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.22 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: dumprmt.c,v 1.22 2003/07/28 06:13:26 tedu Exp $";
a45 5
#ifdef sunos
#include <sys/vnode.h>

#include <ufs/inode.h>
#else
a46 1
#endif
@


1.22
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.21 2003/06/26 16:35:21 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD$";
d107 1
@


1.21
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.20 2003/06/02 20:06:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$NetBSD: dumprmt.c,v 1.10 1996/03/15 22:39:26 scottr Exp $";
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.19 2003/03/13 09:09:25 deraadt Exp $	*/
d91 1
a91 2
rmthost(host)
	char *host;
d108 1
a108 2
rmtconnaborted(signo)
	int signo;
d115 1
a115 1
rmtgetconn()
d167 1
a167 2
okname(cp0)
	char *cp0;
d183 1
a183 3
rmtopen(tape, mode)
	char *tape;
	int mode;
d193 1
a193 1
rmtclose()
d203 1
a203 3
rmtread(buf, count)
	char *buf;
	int count;
d224 1
a224 3
rmtwrite(buf, count)
	char *buf;
	int count;
d235 1
a235 2
rmtwrite0(count)
	int count;
d244 1
a244 3
rmtwrite1(buf, count)
	char *buf;
	int count;
d251 1
a251 1
rmtwrite2()
d258 1
a258 2
rmtseek(offset, pos)
	int offset, pos;
d269 1
a269 1
rmtstatus()
d283 1
a283 2
rmtioctl(cmd, count)
	int cmd, count;
d294 1
a294 2
rmtcall(cmd, buf)
	char *cmd, *buf;
d303 1
a303 2
rmtreply(cmd)
	char *cmd;
d331 1
a331 1
rmtgetb()
d342 1
a342 3
rmtgets(line, len)
	char *line;
	int len;
@


1.19
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.18 2002/02/21 16:16:26 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Fix signal handlers to take an int arg even though it is not used.
This allows us to use real prototypes for rmtconnaborted and alarmcatch
without causing a warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.17 2002/02/19 19:39:38 millert Exp $	*/
d98 1
d100 1
a100 1
	rmtpeer = malloc(strlen(host) + 1);
d102 1
a102 1
		strcpy(rmtpeer, host);
@


1.17
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.16 2002/02/16 21:27:33 millert Exp $	*/
d86 1
a86 1
static	void rmtconnaborted(/* int, int */);
d112 2
a113 1
rmtconnaborted()
d227 1
a227 1
			rmtconnaborted();
d316 1
a316 1
		rmtconnaborted();
d344 1
a344 1
		rmtconnaborted();
d355 1
a355 1
		rmtconnaborted();
d379 1
a379 1
	rmtconnaborted();
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.15 2001/11/05 07:39:16 mpech Exp $	*/
a69 1
#ifdef __STDC__
a72 1
#endif
@


1.15
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.14 2001/01/19 17:57:34 deraadt Exp $	*/
d86 7
a92 7
static	int okname __P((char *));
static	int rmtcall __P((char *, char *));
static	void rmtconnaborted __P((/* int, int */));
static	int rmtgetb __P((void));
static	void rmtgetconn __P((void));
static	void rmtgets __P((char *, int));
static	int rmtreply __P((char *));
@


1.14
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.13 2000/01/22 20:24:54 deraadt Exp $	*/
d123 1
a123 1
	register char *cp;
d176 2
a177 2
	register char *cp;
	register int c;
d288 2
a289 2
	register int i;
	register char *cp;
d325 1
a325 1
	register char *cp;
d366 1
a366 1
	register char *cp = line;
@


1.13
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.12 1999/01/04 08:11:53 deraadt Exp $	*/
d116 1
a116 1

@


1.12
log
@use TCP_NODELAY; giannici@@neomedia.it
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.11 1998/11/24 01:25:47 deraadt Exp $	*/
a217 1
	extern int errno;
@


1.11
log
@Wall, and do not let tapesize overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.10 1998/07/14 19:04:05 deraadt Exp $	*/
a125 1
#ifdef notdef
a126 1
#endif
d169 1
a169 4
#ifdef notdef
	if (setsockopt(rmtape, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) < 0)
		perror("TCP_NODELAY setsockopt");
#endif
@


1.10
log
@fix exit codes, adding X_STARTUP; jkoshy@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.9 1998/04/26 18:10:49 deraadt Exp $	*/
d223 1
a223 1
	extern errno;
@


1.9
log
@extract errno from rmt operation, assuming other machine has same errno values; gibbs@@narnia.plutotech.com
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.8 1997/07/05 05:35:55 millert Exp $	*/
d117 1
a117 1
	errx(1, "Lost connection to remote host.");
d136 1
a136 1
			errx(1, "shell/tcp: unknown service");
d139 1
a139 1
			errx(1, "who are you?");
d142 1
a142 1
		err(1, "malloc");
d147 1
a147 1
			exit(1);
@


1.8
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.7 1997/06/25 18:07:55 kstailey Exp $	*/
d66 1
d338 2
a339 1
		if (*code == 'F') {
a340 2
			return (-1);
		}
@


1.7
log
@(foo *)0 -> NULL
@
text
@d1 2
a2 2
/*	$OpenBSD: dumprmt.c,v 1.6 1996/09/15 20:14:08 millert Exp $	*/
/*	$NetBSD: dumprmt.c,v 1.10 1996/03/15 22:39:26 scottr Exp $	*/
d128 1
a128 1
	char *tuser;
d140 2
d149 1
a149 1
		tuser = pwd->pw_name;
d151 4
a154 2
	rmtape = rcmd(&rmtpeer, (u_short)sp->s_port, pwd->pw_name, tuser,
	    _PATH_RMT, NULL);
d162 1
a162 1
	    setsockopt(rmtape, SOL_SOCKET, SO_SNDBUF, &size, sizeof (size)) < 0)
d164 1
a164 1
	(void)setsockopt(rmtape, SOL_SOCKET, SO_RCVBUF, &size, sizeof (size));
d168 1
a168 1
		sizeof (maxseg));
d171 1
a171 1
	if (setsockopt(rmtape, IPPROTO_TCP, TCP_NODELAY, &on, sizeof (on)) < 0)
d200 1
a200 1
	(void)snprintf(buf, sizeof (buf), "O%s\n%d\n", tape, mode);
d224 1
a224 1
	(void)snprintf(line, sizeof (line), "R%d\n", count);
d246 1
a246 1
	(void)snprintf(line, sizeof (line), "W%d\n", count);
d258 1
a258 1
	(void)snprintf(line, sizeof (line), "W%d\n", count);
d284 1
a284 1
	(void)snprintf(line, sizeof (line), "L%d\n%d\n", offset, pos);
d312 1
a312 1
	(void)snprintf(buf, sizeof (buf), "I%d\n%d\n", cmd, count);
d333 1
a333 1
	rmtgets(code, sizeof (code));
d335 1
a335 1
		rmtgets(emsg, sizeof (emsg));
@


1.6
log
@sprintf -> snprintf (how'd that get missed?)
Don't complain if setsockopt() fails.  It will fail if we used rcmdsh()
instead of rcmd() and there's no easy way to detect which we used now.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.5 1996/09/02 22:15:02 millert Exp $	*/
d150 1
a150 1
	    _PATH_RMT, (int *)0);
@


1.5
log
@don't try to do setsockopt(TCP_MAXSEG) unless we are root.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.4 1996/09/01 15:31:02 deraadt Exp $	*/
d161 1
d163 2
a164 3
	if (getuid() == 0 && setsockopt(rmtape, IPPROTO_TCP, TCP_MAXSEG,
	    &maxseg, sizeof (maxseg)) < 0)
		perror("TCP_MAXSEG setsockopt");
d196 1
a196 1
	(void)snprintf(buf, sizeof buf, "O%s\n%d\n", tape, mode);
d220 1
a220 1
	(void)sprintf(line, "R%d\n", count);
d242 1
a242 1
	(void)sprintf(line, "W%d\n", count);
d254 1
a254 1
	(void)sprintf(line, "W%d\n", count);
d280 1
a280 1
	(void)sprintf(line, "L%d\n%d\n", offset, pos);
d308 1
a308 1
	(void)sprintf(buf, "I%d\n%d\n", cmd, count);
@


1.4
log
@kill setuid, fix setgid hole
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.3 1996/08/06 17:02:06 deraadt Exp $	*/
d162 1
a162 1
	if (setsockopt(rmtape, IPPROTO_TCP, TCP_MAXSEG,
@


1.3
log
@buf oflow, from joshd
@
text
@d1 1
a1 1
/*	$OpenBSD: dumprmt.c,v 1.2 1996/03/21 00:15:35 niklas Exp $	*/
a93 2
extern	uid_t uid;		/* real uid */
extern	uid_t euid;		/* effective uid */
a148 1
	(void) seteuid(euid);
a150 1
	(void) setuid(uid);	/* Just to be Really Really safe */
@


1.2
log
@From NetBSD: Merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d200 1
a200 1
	(void)sprintf(buf, "O%s\n%d\n", tape, mode);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: dumprmt.c,v 1.9 1995/03/18 14:54:59 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: dumprmt.c,v 1.9 1995/03/18 14:54:59 cgd Exp $";
d94 2
d150 2
d154 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
