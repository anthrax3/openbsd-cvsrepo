head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.31.0.14
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.12
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.10
	OPENBSD_5_0:1.31.0.8
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.12
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.8
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.8
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.6
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.6
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.16.0.14
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.12
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.10
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.8
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.6
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.4
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.10.12.15.12.44;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	aiqev0OPagnmtor8;

1.38
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	0qPuuXwccpVXsXcV;

1.37
date	2015.05.23.05.17.20;	author guenther;	state Exp;
branches;
next	1.36;
commitid	xRFGRK8SjUIGT2GW;

1.36
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.35;
commitid	IbVxlqGw2UipKdDr;

1.35
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2013.04.16.19.25.59;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.20.01.44.16;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.04.20.10.07;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.07.01.25.30;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.21.16.16.26;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.13.20.13.28;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.19.17.57.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.08.05.23.17.11;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	97.07.25.19.13.03;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.07.05.05.35.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.06.25.18.07.57;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	96.10.12.01.24.15;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.09.14.19.29.00;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.09.14.03.26.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.09.01.15.31.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.01.15.30.18;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.01.13.12.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.06.17.47.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.05.11.51.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.30.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.21.14.31.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.27.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Annotate an pretty obvious signal race... no time to fix it now.
@
text
@/*	$OpenBSD: optr.c,v 1.38 2015/08/20 22:02:20 deraadt Exp $	*/
/*	$NetBSD: optr.c,v 1.11 1997/05/27 08:34:36 mrg Exp $	*/

/*-
 * Copyright (c) 1980, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/wait.h>
#include <sys/time.h>

#include <ufs/ufs/dinode.h>

#include <errno.h>
#include <fstab.h>
#include <grp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <limits.h>
#include <utmp.h>

#include "dump.h"
#include "pathnames.h"

void	alarmcatch(int);
int	datesort(const void *, const void *);

/*
 *	Query the operator; This previously-fascist piece of code
 *	no longer requires an exact response.
 *	It is intended to protect dump aborting by inquisitive
 *	people banging on the console terminal to see what is
 *	happening which might cause dump to croak, destroying
 *	a large number of hours of work.
 *
 *	Every 2 minutes we reprint the message, alerting others
 *	that dump needs attention.
 */
static	int timeout;
static	char *attnmessage;		/* attention message */

struct fstab *allocfsent(struct fstab *fs);

int
query(char *question)
{
	char	replybuffer[64];
	int	back, errcount;
	FILE	*mytty;
	time_t	firstprompt, when_answered;

	(void) time(&firstprompt);

	if ((mytty = fopen(_PATH_TTY, "r")) == NULL)
		quit("fopen on %s fails: %s\n", _PATH_TTY, strerror(errno));
	attnmessage = question;
	timeout = 0;
	alarmcatch(0);
	back = -1;
	errcount = 0;
	do {
		if (fgets(replybuffer, sizeof(replybuffer), mytty) == NULL) {
			clearerr(mytty);
			if (++errcount > 30)	/* XXX	ugly */
				quit("excessive operator query failures\n");
		} else if (replybuffer[0] == 'y' || replybuffer[0] == 'Y') {
			back = 1;
		} else if (replybuffer[0] == 'n' || replybuffer[0] == 'N') {
			back = 0;
		} else {
			(void) fprintf(stderr,
			    "  DUMP: \"Yes\" or \"No\"?\n");
			(void) fprintf(stderr,
			    "  DUMP: %s: (\"yes\" or \"no\") ", question);
		}
	} while (back < 0);

	/*
	 *	Turn off the alarm, and reset the signal to trap out..
	 */
	(void) alarm(0);
	if (signal(SIGALRM, sig) == SIG_IGN)
		signal(SIGALRM, SIG_IGN);
	(void) fclose(mytty);
	(void) time(&when_answered);
	/*
	 * Adjust the base for time estimates to ignore time we spent waiting
	 * for operator input.
	 */
	if (when_answered - firstprompt > 0)
		tstart_writing += (when_answered - firstprompt);
	return (back);
}

char lastmsg[BUFSIZ];

/*
 *	Alert the console operator, and enable the alarm clock to
 *	sleep for 2 minutes in case nobody comes to satisfy dump
 * XXX not safe
 */
/* ARGSUSED */
void
alarmcatch(int signo)
{
	int save_errno = errno;

	if (notify == 0) {
		if (timeout == 0)
			(void) fprintf(stderr,
			    "  DUMP: %s: (\"yes\" or \"no\") ",
			    attnmessage);
		else
			msgtail("\7\7");
	} else {
		if (timeout) {
			msgtail("\n");
			broadcast("");		/* just print last msg */
		}
		(void) fprintf(stderr,"  DUMP: %s: (\"yes\" or \"no\") ",
		    attnmessage);
	}
	signal(SIGALRM, alarmcatch);
	(void) alarm(120);
	timeout = 1;
	errno = save_errno;
}

/*
 *	Here if an inquisitive operator interrupts the dump program
 */
/* ARGSUSED */
void
interrupt(int signo)
{
	msg("Interrupt received.\n");
	if (query("Do you want to abort dump?"))
		dumpabort(0);
}

/*
 *	We now use wall(1) to do the actual broadcasting.
 */
void
broadcast(char *message)
{
	FILE *fp;
	char buf[sizeof(_PATH_WALL) + sizeof(OPGRENT) + 3];

	if (!notify)
		return;

	(void)snprintf(buf, sizeof(buf), "%s -g %s", _PATH_WALL, OPGRENT);
	if ((fp = popen(buf, "w")) == NULL)
		return;

	(void) fputs("\7\7\7Message from the dump program to all operators\n\nDUMP: NEEDS ATTENTION: ", fp);
	if (lastmsg[0])
		(void) fputs(lastmsg, fp);
	if (message[0])
		(void) fputs(message, fp);

	(void) pclose(fp);
}

/*
 *	Print out an estimate of the amount of time left to do the dump
 */

time_t	tschedule = 0;

void
timeest(void)
{
	time_t	tnow, deltat;

	(void) time(&tnow);
	if (tnow >= tschedule) {
		tschedule = tnow + 300;
		if (blockswritten < 500)
			return;
		deltat = tstart_writing - tnow +
			(1.0 * (tnow - tstart_writing))
			/ blockswritten * tapesize;
		msg("%3.2f%% done, finished in %lld:%02lld\n",
		    (blockswritten * 100.0) / tapesize,
		    (long long)deltat / 3600,
		    ((long long)deltat % 3600) / 60);
	}
}

void
msg(const char *fmt, ...)
{
	va_list ap;

	(void) fprintf(stderr,"  DUMP: ");
#ifdef TDEBUG
	(void) fprintf(stderr, "pid=%d ", getpid());
#endif
	va_start(ap, fmt);
	(void) vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void) fflush(stdout);
	(void) fflush(stderr);
	va_start(ap, fmt);
	(void) vsnprintf(lastmsg, sizeof(lastmsg), fmt, ap);
	va_end(ap);
}

void
msgtail(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void) vfprintf(stderr, fmt, ap);
	va_end(ap);
}

/* XXX signal races */
void
quit(const char *fmt, ...)
{
	va_list ap;

	(void) fprintf(stderr,"  DUMP: ");
#ifdef TDEBUG
	(void) fprintf(stderr, "pid=%d ", getpid());
#endif
	va_start(ap, fmt);
	(void) vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void) fflush(stdout);
	(void) fflush(stderr);
	dumpabort(0);
}

/*
 *	Tell the operator what has to be done;
 *	we don't actually do it
 */

struct fstab *
allocfsent(struct fstab *fs)
{
	struct fstab *new;

	new = malloc(sizeof(*fs));
	if (new == NULL ||
	    (new->fs_file = strdup(fs->fs_file)) == NULL ||
	    (new->fs_type = strdup(fs->fs_type)) == NULL ||
	    (new->fs_spec = strdup(fs->fs_spec)) == NULL)
		quit("%s\n", strerror(errno));
	new->fs_passno = fs->fs_passno;
	new->fs_freq = fs->fs_freq;
	return (new);
}

struct	pfstab {
	struct	pfstab *pf_next;
	struct	fstab *pf_fstab;
};

static	struct pfstab *table;

void
getfstab(void)
{
	struct fstab *fs;
	struct pfstab *pf;

	if (setfsent() == 0) {
		msg("Can't open %s for dump table information: %s\n",
		    _PATH_FSTAB, strerror(errno));
		return;
	}
	while ((fs = getfsent()) != NULL) {
		if (strcmp(fs->fs_vfstype, "ffs") &&
		    strcmp(fs->fs_vfstype, "ufs"))
			continue;
		if (strcmp(fs->fs_type, FSTAB_RW) &&
		    strcmp(fs->fs_type, FSTAB_RO) &&
		    strcmp(fs->fs_type, FSTAB_RQ))
			continue;
		fs = allocfsent(fs);
		if ((pf = malloc(sizeof(*pf))) == NULL)
			quit("%s\n", strerror(errno));
		pf->pf_fstab = fs;
		pf->pf_next = table;
		table = pf;
	}
	(void) endfsent();
}

/*
 * Search in the fstab for a file name.
 * This file name can be either the special or the path file name.
 *
 * The entries in the fstab are the BLOCK special names, not the
 * character special names.
 * The caller of fstabsearch assures that the character device
 * is dumped (that is much faster)
 *
 * The file name can omit the leading '/'.
 */
struct fstab *
fstabsearch(char *key)
{
	struct pfstab *pf;
	struct fstab *fs;
	char *rn, *uid;

	for (pf = table; pf != NULL; pf = pf->pf_next) {
		fs = pf->pf_fstab;
		if (strcmp(fs->fs_file, key) == 0 ||
		    strcmp(fs->fs_spec, key) == 0)
			return (fs);
		rn = rawname(fs->fs_spec);
		if (rn != NULL && strcmp(rn, key) == 0)
			return (fs);
		uid = getduid(rn != NULL ? rn : fs->fs_spec);
		if (uid != NULL && strcmp(uid, key) == 0) {
			free(uid);
			return (fs);
		}
		free(uid);
		if (key[0] != '/') {
			if (*fs->fs_spec == '/' &&
			    strcmp(fs->fs_spec + 1, key) == 0)
				return (fs);
			if (*fs->fs_file == '/' &&
			    strcmp(fs->fs_file + 1, key) == 0)
				return (fs);
		}
	}
	return (NULL);
}

#define SECSPERDAY	(24 * 60 * 60)

/*
 *	Tell the operator what to do
 *	w ==> just what to do; W ==> most recent dumps
 */
void
lastdump(int arg)
{
	int i;
	struct fstab *dt;
	struct dumpdates *dtwalk;
	char *lastname, *date;
	int dumpme;
	time_t tnow;

	(void) time(&tnow);
	getfstab();		/* /etc/fstab input */
	initdumptimes();	/* /etc/dumpdates input */
	qsort((char *) ddatev, nddates, sizeof(struct dumpdates *), datesort);

	if (arg == 'w')
		(void) printf("Dump these file systems:\n");
	else
		(void) printf("Last dump(s) done (Dump '>' file systems):\n");
	lastname = "??";
	ITITERATE(i, dtwalk) {
		if (strncmp(lastname, dtwalk->dd_name,
		    sizeof(dtwalk->dd_name)) == 0)
			continue;
		date = (char *)ctime(&dtwalk->dd_ddate);
		date[16] = '\0';	/* blast away seconds and year */
		lastname = dtwalk->dd_name;
		dt = fstabsearch(dtwalk->dd_name);
		dumpme = (dt != NULL &&
		    dt->fs_freq != 0 &&
		    dtwalk->dd_ddate < tnow - (dt->fs_freq * SECSPERDAY));
		if (arg != 'w' || dumpme)
			(void) printf(
			    "%c %8s\t(%6s) Last dump: Level %c, Date %s\n",
			    dumpme && (arg != 'w') ? '>' : ' ',
			    dtwalk->dd_name,
			    dt ? dt->fs_file : "",
			    dtwalk->dd_level,
			    date);
	}
}

int
datesort(const void *a1, const void *a2)
{
	struct dumpdates *d1 = *(struct dumpdates **)a1;
	struct dumpdates *d2 = *(struct dumpdates **)a2;
	int diff;

	diff = strncmp(d1->dd_name, d2->dd_name, sizeof(d1->dd_name));
	if (diff == 0)
		return (d2->dd_ddate - d1->dd_ddate);
	return (diff);
}
@


1.38
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.37 2015/05/23 05:17:20 guenther Exp $	*/
d250 1
@


1.37
log
@Canonicalize all devices to DUIDs in order to make -w and -W output consistent.

Based on diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.36 2015/03/15 00:41:27 millert Exp $	*/
d277 1
a277 1
	new = (struct fstab *)malloc(sizeof(*fs));
d315 1
a315 1
		if ((pf = (struct pfstab *)malloc(sizeof(*pf))) == NULL)
@


1.36
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.35 2015/01/16 06:39:57 deraadt Exp $	*/
d340 1
a340 1
	char *rn;
d350 6
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.34 2013/11/12 04:59:02 deraadt Exp $	*/
a46 1
#include <tzfile.h>
d361 2
@


1.34
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.33 2013/04/25 06:43:20 otto Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d49 1
@


1.33
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.32 2013/04/16 19:25:59 deraadt Exp $	*/
d70 2
@


1.32
log
@remove casts to time_t * which are not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.31 2009/10/27 23:59:32 deraadt Exp $	*/
d212 4
a215 3
		msg("%3.2f%% done, finished in %d:%02d\n",
			(blockswritten * 100.0) / tapesize,
			deltat / 3600, (deltat % 3600) / 60);
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.30 2007/06/03 20:16:08 millert Exp $	*/
d204 1
a204 1
	(void) time((time_t *) &tnow);
@


1.30
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.29 2007/02/20 01:44:16 ray Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)optr.c	8.2 (Berkeley) 1/6/94";
#else
static const char rcsid[] = "$OpenBSD: optr.c,v 1.29 2007/02/20 01:44:16 ray Exp $";
#endif
#endif /* not lint */
@


1.29
log
@Change hard coded numbers to sizeof(buf).  Also change some
sizeof(buf) - 1 to sizeof(buf), since fgets takes the whole buffer size.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.28 2004/11/04 20:10:07 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: optr.c,v 1.28 2004/11/04 20:10:07 deraadt Exp $";
d44 2
@


1.28
log
@very basic de-lints
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.27 2003/07/29 18:38:35 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: optr.c,v 1.27 2003/07/29 18:38:35 deraadt Exp $";
d95 1
a95 1
		if (fgets(replybuffer, 63, mytty) == NULL) {
@


1.27
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.26 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: optr.c,v 1.26 2003/07/28 06:13:26 tedu Exp $";
d135 1
d165 1
@


1.26
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.25 2003/07/07 01:25:30 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: optr.c,v 1.24 2003/06/26 16:35:21 deraadt Exp $";
d212 1
a212 1
			return;	
@


1.25
log
@I never committed the fix for PR 3296, "Dump prints negative numbers for time"
Here it is...
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.24 2003/06/26 16:35:21 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.24 2003/06/26 16:35:21 deraadt Exp $";
@


1.24
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.23 2003/06/02 20:06:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.23 2003/06/02 20:06:14 millert Exp $";
d85 1
a85 1
	firstprompt = time(NULL);
d118 1
a118 1
	when_answered = time(NULL);
d123 3
a125 3
	if (tstart_writing != 0)
	    tstart_writing += (when_answered - firstprompt);
	return(back);
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.22 2002/02/21 16:16:26 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.22 2002/02/21 16:16:26 millert Exp $";
d78 1
a78 2
query(question)
	char	*question;
d136 1
a136 2
alarmcatch(signo)
	int signo;
d165 1
a165 2
interrupt(signo)
	int signo;
d176 1
a176 2
broadcast(message)
	char	*message;
d204 1
a204 1
timeest()
d274 1
a274 2
allocfsent(fs)
	struct fstab *fs;
d297 1
a297 1
getfstab()
d337 1
a337 2
fstabsearch(key)
	char *key;
d365 1
d368 1
a368 2
lastdump(arg)
	char	arg;	/* w ==> just what to do; W ==> most recent dumps */
d410 1
a410 2
datesort(a1, a2)
	const void *a1, *a2;
@


1.22
log
@Fix signal handlers to take an int arg even though it is not used.
This allows us to use real prototypes for rmtconnaborted and alarmcatch
without causing a warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.21 2002/02/19 19:39:38 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.21 2002/02/19 19:39:38 millert Exp $";
@


1.21
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.20 2002/02/16 21:27:33 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.20 2002/02/16 21:27:33 millert Exp $";
d64 1
a64 1
void	alarmcatch(/* int, int */);
d96 1
a96 1
	alarmcatch();
d141 2
a142 1
alarmcatch()
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.19 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.19 2001/11/05 07:39:16 mpech Exp $";
a53 1
#ifdef __STDC__
a56 1
#endif
a57 1
#ifdef __STDC__
a58 1
#endif
a59 3
#ifndef __STDC__
#include <varargs.h>
#endif
a229 1
#ifdef __STDC__
a230 5
#else
msg(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a237 1
#ifdef __STDC__
a238 3
#else
	va_start(ap);
#endif
a242 1
#ifdef __STDC__
a243 3
#else
	va_start(ap);
#endif
a248 1
#ifdef __STDC__
a249 5
#else
msgtail(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
d252 1
a252 1
#ifdef __STDC__
a253 3
#else
	va_start(ap);
#endif
a258 1
#ifdef __STDC__
a259 5
#else
quit(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a266 1
#ifdef __STDC__
a267 3
#else
	va_start(ap);
#endif
@


1.19
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.18 2001/06/13 20:13:28 markus Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.18 2001/06/13 20:13:28 markus Exp $";
d71 2
a72 2
void	alarmcatch __P((/* int, int */));
int	datesort __P((const void *, const void *));
@


1.18
log
@more va_start/end fixes, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.17 2001/01/19 17:57:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.17 2001/01/19 17:57:34 deraadt Exp $";
d322 1
a322 1
	register struct fstab *fs;
d324 1
a324 1
	register struct fstab *new;
d347 2
a348 2
	register struct fstab *fs;
	register struct pfstab *pf;
d388 2
a389 2
	register struct pfstab *pf;
	register struct fstab *fs;
d419 3
a421 3
	register int i;
	register struct fstab *dt;
	register struct dumpdates *dtwalk;
@


1.17
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.16 1997/08/05 23:17:11 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.16 1997/08/05 23:17:11 angelos Exp $";
d257 1
d260 5
@


1.16
log
@Save/restore the errno when handling interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.15 1997/07/25 19:13:03 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.15 1997/07/25 19:13:03 mickey Exp $";
d145 1
@


1.15
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.14 1997/07/05 05:35:57 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.14 1997/07/05 05:35:57 millert Exp $";
d149 2
d169 1
@


1.14
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.13 1997/06/25 18:07:57 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.13 1997/06/25 18:07:57 kstailey Exp $";
d233 1
a233 1
#if __STDC__
d247 1
a247 1
#if __STDC__
d260 1
a260 1
#if __STDC__
d269 1
a269 1
#if __STDC__
d279 1
a279 1
#if __STDC__
d293 1
a293 1
#if __STDC__
@


1.13
log
@(foo *)0 -> NULL
@
text
@d1 2
a2 2
/*	$OpenBSD: optr.c,v 1.12 1996/10/12 01:24:15 deraadt Exp $	*/
/*	$NetBSD: optr.c,v 1.4 1996/05/18 16:16:17 jtk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.12 1996/10/12 01:24:15 deraadt Exp $";
a72 1
static	void sendmes __P((char *, char *));
d181 1
a181 1
/*              
d183 1
a183 1
 */         
d189 1
a189 1
	char buf[sizeof(_PATH_WALL) + 12];
d194 1
a194 2
	(void) strcpy(buf, _PATH_WALL);
	(void) strcpy(buf + sizeof(_PATH_WALL) - 1, " -g operator");
d316 1
a316 1
	new = (struct fstab *)malloc(sizeof (*fs));
d354 1
a354 1
		if ((pf = (struct pfstab *)malloc(sizeof (*pf))) == NULL)
@


1.12
log
@permit ufs filesystem type too
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.11 1996/09/14 19:29:00 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.11 1996/09/14 19:29:00 deraadt Exp $";
d98 1
a98 1
	firstprompt = time((time_t *)0);
d131 1
a131 1
	when_answered = time((time_t *)0);
@


1.11
log
@setgid stuff goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.10 1996/09/14 03:26:02 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.10 1996/09/14 03:26:02 millert Exp $";
d348 2
a349 1
		if (strcmp(fs->fs_vfstype, "ffs"))
@


1.10
log
@Now uses "wall -g" so no need to be setgid tty.  This makes $RSH work.
Also fix buf oflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.9 1996/09/01 15:31:03 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.9 1996/09/01 15:31:03 deraadt Exp $";
a73 2

extern gid_t gid, egid;
@


1.9
log
@kill setuid, fix setgid hole
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.7 1996/09/01 13:12:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.7 1996/09/01 13:12:35 deraadt Exp $";
d143 1
a143 1
char lastmsg[100];
d184 3
a186 30
/*
 *	The following variables and routines manage alerting
 *	operators to the status of dump.
 *	This works much like wall(1) does.
 */
struct	group *gp;

/*
 *	Get the names from the group entry "operator" to notify.
 */	
void
set_operators()
{
	if (!notify)		/*not going to notify*/
		return;
	gp = getgrnam(OPGRENT);
	(void) endgrent();
	if (gp == NULL) {
		msg("No group entry for %s.\n", OPGRENT);
		notify = 0;
		return;
	}
}

struct tm *localclock;

/*
 *	We fork a child to do the actual broadcasting, so
 *	that the process control groups are not messed up
 */
d191 2
a192 5
	time_t		clock;
	FILE	*f_utmp;
	struct	utmp	utmp;
	char	**np;
	int	pid, s;
d194 1
a194 1
	if (!notify || gp == NULL)
d197 3
a199 2
	switch (pid = fork()) {
	case -1:
a200 7
	case 0:
		break;
	default:
		while (wait(&s) != pid)
			continue;
		return;
	}
d202 5
a206 2
	clock = time((time_t *)0);
	localclock = localtime(&clock);
d208 1
a208 61
	if ((f_utmp = fopen(_PATH_UTMP, "r")) == NULL) {
		msg("Cannot open %s: %s\n", _PATH_UTMP, strerror(errno));
		return;
	}

	while (!feof(f_utmp)) {
		if (fread((char *) &utmp, sizeof (struct utmp), 1, f_utmp) != 1)
			break;
		if (utmp.ut_name[0] == 0)
			continue;
		for (np = gp->gr_mem; *np; np++) {
			if (strncmp(*np, utmp.ut_name, sizeof(utmp.ut_name)) != 0)
				continue;
#ifdef DEBUG
			msg("Message to %s at %s\n", *np, utmp.ut_line);
#endif
			sendmes(utmp.ut_line, message);
		}
	}
	(void) fclose(f_utmp);
	Exit(0);	/* the wait in this same routine will catch this */
	/* NOTREACHED */
}

static void
sendmes(tty, message)
	char *tty, *message;
{
	char t[MAXPATHLEN], buf[BUFSIZ];
	register char *cp;
	int lmsg = 1;
	FILE *f_tty;

	(void) strcpy(t, _PATH_DEV);
	(void) strncat(t, tty, sizeof t - strlen(_PATH_DEV));

	setegid(egid);
	if ((f_tty = fopen(t, "w")) != NULL) {
		setbuf(f_tty, buf);
		(void) fprintf(f_tty,
		    "\n\
\7\7\7Message from the dump program to all operators at %d:%02d ...\r\n\n\
DUMP: NEEDS ATTENTION: ",
		    localclock->tm_hour, localclock->tm_min);
		for (cp = lastmsg; ; cp++) {
			if (*cp == '\0') {
				if (lmsg) {
					cp = message;
					if (*cp == '\0')
						break;
					lmsg = 0;
				} else
					break;
			}
			if (*cp == '\n')
				(void) putc('\r', f_tty);
			(void) putc(*cp, f_tty);
		}
		(void) fclose(f_tty);
	}
	setegid(gid);
d212 1
a212 1
 *	print out an estimate of the amount of time left to do the dump
d259 1
a259 1
	(void) vsprintf(lastmsg, fmt, ap);
@


1.8
log
@oflow protection
@
text
@d75 2
d277 1
d301 1
@


1.7
log
@dialup tty semantic is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.6 1996/08/06 17:47:15 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.6 1996/08/06 17:47:15 deraadt Exp $";
d273 1
a273 1
	(void) strncat(t, tty, sizeof t);
@


1.6
log
@whoops
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.5 1996/08/05 11:51:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.5 1996/08/05 11:51:16 deraadt Exp $";
a250 5
				continue;
			/*
			 *	Do not send messages to operators on dialups
			 */
			if (strncmp(utmp.ut_line, DIALUP, strlen(DIALUP)) == 0)
@


1.5
log
@careful about buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.4 1996/06/23 14:30:11 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.4 1996/06/23 14:30:11 deraadt Exp $";
d278 1
a278 1
	(void) strncat(t, sizeof t, tty);
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: optr.c,v 1.4 1996/05/18 16:16:17 jtk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: optr.c,v 1.4 1996/05/18 16:16:17 jtk Exp $";
d272 1
a272 1
	char t[50], buf[BUFSIZ];
d278 1
a278 1
	(void) strcat(t, tty);
@


1.3
log
@only deal with ffs filesystems; netbsd pr#2652, greywolf@@starwolf.com
(should we deal with mfs?)
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: optr.c,v 1.4 1996/05/18 16:16:17 jtk Exp $";
@


1.2
log
@from jtk; Adjust the base for time estimates to ignore time we spent
waiting for operator input. enhancements from PR #900
@
text
@d443 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: optr.c,v 1.3 1995/03/18 14:55:04 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: optr.c,v 1.3 1995/03/18 14:55:04 cgd Exp $";
d95 3
d130 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
