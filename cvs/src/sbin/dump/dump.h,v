head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.8
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.24
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.22
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.20
	OPENBSD_5_0:1.16.0.18
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.16
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.14
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.14.0.16
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.14
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.12
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.05.23.05.17.20;	author guenther;	state Exp;
branches;
next	1.23;
commitid	xRFGRK8SjUIGT2GW;

1.23
date	2015.05.03.01.44.34;	author guenther;	state Exp;
branches;
next	1.22;
commitid	VGweZq0m0ga9jNw5;

1.22
date	2014.09.03.02.34.34;	author guenther;	state Exp;
branches;
next	1.21;
commitid	0cd3Yyn5rjUYxEW5;

1.21
date	2014.07.11.16.01.41;	author halex;	state Exp;
branches;
next	1.20;
commitid	gCk3OFggNKp4mxan;

1.20
date	2014.06.13.20.43.06;	author naddy;	state Exp;
branches;
next	1.19;
commitid	ZqQ42rJaAxHNKIBx;

1.19
date	2014.05.24.21.49.09;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.21.17.38.30;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.10.04.45.37;	author moritz;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.22.07.56.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.20.41.50;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.11.24.01.25.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.07.14.19.04.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.08.19.24.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.05.05.35.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.03.11.53.25;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.01.13.12.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Canonicalize all devices to DUIDs in order to make -w and -W output consistent.

Based on diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@/*	$OpenBSD: dump.h,v 1.23 2015/05/03 01:44:34 guenther Exp $	*/
/*	$NetBSD: dump.h,v 1.11 1997/06/05 11:13:20 lukem Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)dump.h	8.1 (Berkeley) 6/5/93
 */

/*
 * Dump maps used to describe what is to be dumped.
 */
int	mapsize;	/* size of the state maps */
char	*usedinomap;	/* map of allocated inodes */
char	*dumpdirmap;	/* map of directories to be dumped */
char	*dumpinomap;	/* map of files to be dumped */
/*
 * Map manipulation macros.
 */
#define	SETINO(ino, map) \
	map[(u_int)((ino) - 1) / NBBY] |=  1 << ((u_int)((ino) - 1) % NBBY)
#define	CLRINO(ino, map) \
	map[(u_int)((ino) - 1) / NBBY] &=  ~(1 << ((u_int)((ino) - 1) % NBBY))
#define	TSTINO(ino, map) \
	(map[(u_int)((ino) - 1) / NBBY] &  (1 << ((u_int)((ino) - 1) % NBBY)))

/*
 *	All calculations done in 0.1" units!
 */
char	*disk;		/* name of the disk file */
char	*tape;		/* name of the tape file */
char	*dumpdates;	/* name of the file containing dump date information*/
char	*temp;		/* name of the file for doing rewrite of dumpdates */
char	*duid;		/* duid of the disk being dumped */
char	lastlevel;	/* dump level of previous dump */
char	level;		/* dump level of this dump */
int	uflag;		/* update flag */
int	diskfd;		/* disk file descriptor */
int	tapefd;		/* tape file descriptor */
int	pipeout;	/* true => output to standard output */
ino_t	curino;		/* current inumber; used globally */
int	newtape;	/* new tape flag */
int	density;	/* density in 0.1" units */
int64_t	tapesize;	/* estimated tape size, blocks */
int64_t	tsize;		/* tape size in 0.1" units */
int	unlimited;	/* if set, write to end of medium */
int64_t	asize;		/* number of 0.1" units written on current tape */
int	etapes;		/* estimated number of tapes */
int	nonodump;	/* if set, do not honor UF_NODUMP user flags */

int	notify;		/* notify operator flag */
int64_t	blockswritten;	/* number of blocks written on current tape */
int	tapeno;		/* current tape number */
time_t	tstart_writing;	/* when started writing the first tape block */
long	xferrate;	/* averaged transfer rate of all volumes */
struct	fs *sblock;	/* the file system super block */
char	sblock_buf[MAXBSIZE];
int	tp_bshift;	/* log2(TP_BSIZE) */

/* operator interface functions */
void	broadcast(char *message);
time_t	do_stats(void);
void	lastdump(int arg);	/* int should be char */
void	msg(const char *fmt, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	msgtail(const char *fmt, ...)
	    __attribute__((__format__ (printf, 1, 2)));
int	query(char *question);
__dead void quit(const char *fmt, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	statussig(int);
void	timeest(void);

/* mapping routines */
union	dinode;
int64_t	blockest(union dinode *dp);
void	mapfileino(ino_t, int64_t *, int *);
int	mapfiles(ino_t maxino, int64_t *tapesize, char *disk,
	    char * const *dirv);
int	mapdirs(ino_t maxino, int64_t *tapesize);

/* file dumping routines */
void	ufs1_blksout(int32_t *blkp, int frags, ino_t ino);
void	ufs2_blksout(daddr_t *blkp, int frags, ino_t ino);
void	bread(daddr_t blkno, char *buf, int size);
void	dumpino(union dinode *dp, ino_t ino);
void	dumpmap(char *map, int type, ino_t ino);
void	writeheader(ino_t ino);

/* tape writing routines */
int	alloctape(void);
void	close_rewind(void);
void	dumpblock(daddr_t blkno, int size);
void	startnewtape(int top);
void	trewind(void);
void	writerec(char *dp, int isspcl);

__dead void Exit(int status);
__dead void dumpabort(int signo);
void	getfstab(void);

char	*rawname(char *cp);
char	*getduid(char *path);
union	dinode *getino(ino_t inum, int *mode);

/* rdump routines */
#ifdef RDUMP
void	rmtclose(void);
int	rmthost(char *host);
int	rmtopen(char *tape, int mode);
int	rmtwrite(char *buf, int count);
#endif /* RDUMP */

void	interrupt(int signo);	/* in case operator bangs on console */

/*
 *	Exit status codes
 */
#define	X_FINOK		0	/* normal exit */
#define	X_STARTUP	1	/* startup error */
#define	X_REWRITE	2	/* restart writing from the check point */
#define	X_ABORT		3	/* abort dump; don't attempt checkpointing */

#define	OPGRENT	"operator"		/* group entry to notify */

struct	fstab *fstabsearch(char *key);	/* search fs_file and fs_spec */

/*
 *	The contents of the file _PATH_DUMPDATES is maintained both on
 *	a linked list, and then (eventually) arrayified.
 */
struct dumpdates {
	char	dd_name[NAME_MAX+3];
	char	dd_level;
	time_t	dd_ddate;
};
struct dumptime {
	struct	dumpdates dt_value;
	struct	dumptime *dt_next;
};
struct	dumptime *dthead;	/* head of the list version */
int	nddates;		/* number of records (might be zero) */
int	ddates_in;		/* we have read the increment file */
struct	dumpdates **ddatev;	/* the arrayfied version */
void	initdumptimes(void);
void	getdumptime(void);
void	putdumptime(void);
#define	ITITERATE(i, ddp) \
	for (i = 0; i < nddates && (ddp = ddatev[i]); i++)

void	sig(int signo);

@


1.23
log
@Eliminate the -U flag and make usage of DUID in /etc/dumpdates the default.
Correct old style entries so nothing has to be done for the admin.

diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.22 2014/09/03 02:34:34 guenther Exp $	*/
d128 1
@


1.22
log
@Kill off compat for systems that don't define NAME_MAX or that lack stuff
like, oh, strchr() and prototypes for read() and write().
Mark quit() as both __dead and printf-like, and dumpabort() as __dead.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.21 2014/07/11 16:01:41 halex Exp $	*/
a62 1
int	Uflag;		/* use duids in dumpdates flag */
@


1.21
log
@make dump support DUIDs for command line arguments and /etc/dumpdates (using
the new shiny -U switch)

dumpdates part originating from, and discussed with, Maximilian Fillinger

seems reasonable to krw@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.20 2014/06/13 20:43:06 naddy Exp $	*/
d91 1
a91 1
    __attribute__((__format__ (printf, 1, 2)));
d93 1
a93 1
    __attribute__((__format__ (printf, 1, 2)));
d95 2
a96 1
void	quit(const char *fmt, ...);
d125 1
a125 1
void	dumpabort(int signo);
a152 4
#ifndef NAME_MAX
#define NAME_MAX 255
#endif

a177 18
/*
 * Compatibility with old systems.
 */
#ifdef COMPAT
#include <sys/file.h>
#define	strchr(a,b)	index(a,b)
#define	strrchr(a,b)	rindex(a,b)
extern char *strdup(), *ctime();
extern int read(), write();
extern int errno;
#endif

#ifndef	_PATH_UTMP
#define	_PATH_UTMP	"/etc/utmp"
#endif
#ifndef	_PATH_FSTAB
#define	_PATH_FSTAB	"/etc/fstab"
#endif
@


1.20
log
@Type cleanup:
* Move all off_t variables that don't look like file sizes to int64_t.
* Switch blockswritten to int64_t, so it won't wrap at 2TB.
* Same for blocksthisvol (from deraadt@@).
* Switch xferrate (from tedu@@) and blocksperfile from long to uint64_t.
* Since blocksperfile can be set with -B, move numarg() from long
to long long and don't mark small integer constant arguments as long.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.19 2014/05/24 21:49:09 krw Exp $	*/
d59 1
d63 1
@


1.19
log
@Nuke last of the illusionary 'dev_bsize' and 'dev_bshift' variables in
favour of DEV_BSIZE. No-op on 512-byte sector devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.18 2014/05/21 17:38:30 krw Exp $	*/
d68 2
a69 2
off_t	tapesize;	/* estimated tape size, blocks */
off_t	tsize;		/* tape size in 0.1" units */
d71 1
a71 1
off_t	asize;		/* number of 0.1" units written on current tape */
d76 1
a76 1
int	blockswritten;	/* number of blocks written on current tape */
d99 5
a103 4
off_t	blockest(union dinode *dp);
void	mapfileino(ino_t, off_t *, int *);
int	mapfiles(ino_t maxino, off_t *tapesize, char *disk, char * const *dirv);
int	mapdirs(ino_t maxino, off_t *tapesize);
@


1.18
log
@Nuke some trailing whitespace and break some long lines to shrink
subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.17 2013/06/11 16:42:04 deraadt Exp $	*/
a81 2
long	dev_bsize;	/* block size of underlying disk device */
int	dev_bshift;	/* log2(dev_bsize) */
@


1.17
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.16 2007/06/03 20:16:08 millert Exp $	*/
d109 1
a109 1
void	bread(daddr_t blkno, char *buf, int size);	
@


1.16
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.15 2007/04/10 04:45:37 moritz Exp $	*/
d108 2
a109 2
void	ufs2_blksout(daddr64_t *blkp, int frags, ino_t ino);
void	bread(daddr64_t blkno, char *buf, int size);	
d117 1
a117 1
void	dumpblock(daddr64_t blkno, int size);
@


1.15
log
@Rewrite ITITERATE macro to prevent out-of-bounds memory access.
This makes dump -u work with malloc debugging enabled.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.14 2003/08/25 23:28:15 tedu Exp $	*/
a34 3
#define MAXINOPB	(MAXBSIZE / sizeof(struct ufs1_dinode))
#define MAXNINDIR	(MAXBSIZE / sizeof(daddr_t))

d90 4
a93 2
void	msg(const char *fmt, ...);
void	msgtail(const char *fmt, ...);
d100 2
a101 2
struct	ufs1_dinode;
off_t	blockest(struct ufs1_dinode *dp);
d107 4
a110 3
void	blksout(daddr_t *blkp, int frags, ino_t ino);
void	bread(daddr_t blkno, char *buf, int size);	
void	dumpino(struct ufs1_dinode *dp, ino_t ino);
d117 1
a117 1
void	dumpblock(daddr_t blkno, int size);
d127 1
a127 1
struct	ufs1_dinode *getino(ino_t inum);
@


1.14
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.13 2003/06/02 20:06:14 millert Exp $	*/
d176 1
a176 1
	for (ddp = ddatev[i = 0]; i < nddates; ddp = ddatev[++i])
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.12 2002/05/22 07:56:51 deraadt Exp $	*/
d35 1
a35 1
#define MAXINOPB	(MAXBSIZE / sizeof(struct dinode))
d101 2
a102 2
struct	dinode;
off_t	blockest(struct dinode *dp);
d110 1
a110 1
void	dumpino(struct dinode *dp, ino_t ino);
d127 1
a127 1
struct	dinode *getino(ino_t inum);
@


1.12
log
@remove crud
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.11 2002/03/14 20:41:50 mickey Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@fix a few overflows by using off_t, not 32bit longs; some parts are from lucq.org; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.10 2002/02/17 19:42:27 millert Exp $	*/
a200 14
#endif

#ifdef sunos
extern char *calloc();
extern char *malloc();
extern long atol();
extern char *strcpy();
extern char *strncpy();
extern char *strcat();
extern time_t time();
extern void endgrent();
extern __dead void exit();
extern off_t lseek();
extern const char *strerror();
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.9 2002/02/16 21:27:33 millert Exp $	*/
d75 2
a76 2
u_int64_t tapesize;	/* estimated tape size, blocks */
long	tsize;		/* tape size in 0.1" units */
d78 1
a78 1
long	asize;		/* number of 0.1" units written on current tape */
d106 4
a109 5
long	blockest(struct dinode *dp);
void	mapfileino(ino_t, u_int64_t *, int *);
int	mapfiles(ino_t maxino, u_int64_t *tapesize, char *disk,
	    char * const *dirv);
int	mapdirs(ino_t maxino, u_int64_t *tapesize);
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.8 1998/11/24 01:25:46 deraadt Exp $	*/
a92 4
#ifndef __P
#include <sys/cdefs.h>
#endif

d108 2
a109 2
int	mapfiles __P((ino_t maxino, u_int64_t *tapesize, char *disk,
		    char * const *dirv));
@


1.8
log
@Wall, and do not let tapesize overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.7 1998/07/14 19:04:03 deraadt Exp $	*/
d98 9
a106 9
void	broadcast __P((char *message));
time_t	do_stats __P((void));
void	lastdump __P((int arg));	/* int should be char */
void	msg __P((const char *fmt, ...));
void	msgtail __P((const char *fmt, ...));
int	query __P((char *question));
void	quit __P((const char *fmt, ...));
void	statussig __P((int));
void	timeest __P((void));
d110 2
a111 2
long	blockest __P((struct dinode *dp));
void	mapfileino __P((ino_t, u_int64_t *, int *));
d114 1
a114 1
int	mapdirs __P((ino_t maxino, u_int64_t *tapesize));
d117 5
a121 5
void	blksout __P((daddr_t *blkp, int frags, ino_t ino));
void	bread __P((daddr_t blkno, char *buf, int size));	
void	dumpino __P((struct dinode *dp, ino_t ino));
void	dumpmap __P((char *map, int type, ino_t ino));
void	writeheader __P((ino_t ino));
d124 10
a133 10
int	alloctape __P((void));
void	close_rewind __P((void));
void	dumpblock __P((daddr_t blkno, int size));
void	startnewtape __P((int top));
void	trewind __P((void));
void	writerec __P((char *dp, int isspcl));

__dead void Exit __P((int status));
void	dumpabort __P((int signo));
void	getfstab __P((void));
d135 2
a136 2
char	*rawname __P((char *cp));
struct	dinode *getino __P((ino_t inum));
d140 4
a143 4
void	rmtclose __P((void));
int	rmthost __P((char *host));
int	rmtopen __P((char *tape, int mode));
int	rmtwrite __P((char *buf, int count));
d146 1
a146 1
void	interrupt __P((int signo));	/* in case operator bangs on console */
d158 1
a158 1
struct	fstab *fstabsearch __P((char *key));	/* search fs_file and fs_spec */
d181 3
a183 3
void	initdumptimes __P((void));
void	getdumptime __P((void));
void	putdumptime __P((void));
d187 1
a187 1
void	sig __P((int signo));
@


1.7
log
@fix exit codes, adding X_STARTUP; jkoshy@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.6 1998/02/08 19:24:07 deraadt Exp $	*/
d75 1
a75 1
long	tapesize;	/* estimated tape size, blocks */
d111 2
a112 2
void	mapfileino __P((ino_t, long *, int *));
int	mapfiles __P((ino_t maxino, long *tapesize, char *disk,
d114 1
a114 1
int	mapdirs __P((ino_t maxino, long *tapesize));
@


1.6
log
@y2k fixes; netbsd & Andreas.Gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.5 1997/07/05 05:35:54 millert Exp $	*/
d152 1
@


1.5
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.4 1997/02/03 11:53:25 deraadt Exp $	*/
a106 1
time_t	unctime __P((char *str));
@


1.4
log
@new -a option autosizes, meaning it runs till it hits EOM (no need for
pesky sizing options) -- from FreeBSD.
also make -b option aware of MAXPHYS issues (via a little hack)
@
text
@d1 2
a2 2
/*	$OpenBSD: dump.h,v 1.3 1996/09/01 13:12:35 deraadt Exp $	*/
/*	$NetBSD: dump.h,v 1.9 1995/03/18 14:54:57 cgd Exp $	*/
d86 1
d99 1
d105 1
a105 1
void	set_operators __P((void));
d109 1
a109 1
/* mapping rouintes */
d112 3
a114 1
int	mapfiles __P((ino_t maxino, long *tapesize));
@


1.3
log
@dialup tty semantic is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.2 1996/06/23 14:30:10 deraadt Exp $	*/
d77 1
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.h,v 1.9 1995/03/18 14:54:57 cgd Exp $	*/
a151 1
#define DIALUP	"ttyd"			/* prefix for dialups */
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
