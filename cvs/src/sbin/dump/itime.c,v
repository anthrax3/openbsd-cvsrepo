head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.5.0.14
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.12.22.21.03.58;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	q4HL3nDyhnMyVyaS;

1.22
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	0qPuuXwccpVXsXcV;

1.21
date	2015.05.23.05.17.20;	author guenther;	state Exp;
branches;
next	1.20;
commitid	xRFGRK8SjUIGT2GW;

1.20
date	2015.05.03.01.44.34;	author guenther;	state Exp;
branches;
next	1.19;
commitid	VGweZq0m0ga9jNw5;

1.19
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2014.07.11.16.01.41;	author halex;	state Exp;
branches;
next	1.17;
commitid	gCk3OFggNKp4mxan;

1.17
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.04.22.37.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.04.22.36.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.04.20.10.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	98.08.07.17.29.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.02.08.19.24.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.05.05.35.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@assign pointers to NULL rather than 0, remove a needless cast
@
text
@/*	$OpenBSD: itime.c,v 1.22 2015/08/20 22:02:20 deraadt Exp $	*/
/*	$NetBSD: itime.c,v 1.4 1997/04/15 01:09:50 lukem Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/time.h>
#include <ufs/ufs/dinode.h>

#include <protocols/dumprestore.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "dump.h"

struct	dumpdates **ddatev = NULL;
int	nddates = 0;
int	ddates_in = 0;
struct	dumptime *dthead = NULL;

static	void dumprecout(FILE *, struct dumpdates *);
static	int getrecord(FILE *, struct dumpdates *);
static	int makedumpdate(struct dumpdates *, char *);
static	void readdumptimes(FILE *);

void
initdumptimes(void)
{
	FILE *df;

	if ((df = fopen(dumpdates, "r")) == NULL) {
		if (errno != ENOENT) {
			quit("cannot read %s: %s\n", dumpdates,
			    strerror(errno));
			/* NOTREACHED */
		}
		/*
		 * Dumpdates does not exist, make an empty one.
		 */
		msg("WARNING: no file `%s', making an empty one\n", dumpdates);
		if ((df = fopen(dumpdates, "w")) == NULL) {
			quit("cannot create %s: %s\n", dumpdates,
			    strerror(errno));
			/* NOTREACHED */
		}
		(void) fclose(df);
		if ((df = fopen(dumpdates, "r")) == NULL) {
			quit("cannot read %s even after creating it: %s\n",
			    dumpdates, strerror(errno));
			/* NOTREACHED */
		}
	}
	(void) flock(fileno(df), LOCK_SH);
	readdumptimes(df);
	(void) fclose(df);
}

static void
readdumptimes(FILE *df)
{
	int i;
	struct	dumptime *dtwalk;

	for (;;) {
		dtwalk = calloc(1, sizeof(struct dumptime));
		if (getrecord(df, &(dtwalk->dt_value)) < 0) {
			free(dtwalk);
			break;
		}
		nddates++;
		dtwalk->dt_next = dthead;
		dthead = dtwalk;
	}

	ddates_in = 1;
	/*
	 *	arrayify the list, leaving enough room for the additional
	 *	record that we may have to add to the ddate structure
	 */
	ddatev = calloc((unsigned) (nddates + 1), sizeof(struct dumpdates *));
	dtwalk = dthead;
	for (i = nddates - 1; i >= 0; i--, dtwalk = dtwalk->dt_next)
		ddatev[i] = &dtwalk->dt_value;
}

void
getdumptime(void)
{
	struct dumpdates *ddp;
	int i;
	char *fname;

	fname = duid ? duid : disk;
#ifdef FDEBUG
	msg("Looking for name %s in dumpdates = %s for level = %c\n",
		fname, dumpdates, level);
#endif
	spcl.c_ddate = 0;
	lastlevel = '0';

	initdumptimes();
	/*
	 *	Go find the entry with the same name for a lower increment
	 *	and older date
	 */
	ITITERATE(i, ddp) {
		if ((strncmp(fname, ddp->dd_name, sizeof(ddp->dd_name)) != 0) &&
		    (strncmp(disk, ddp->dd_name, sizeof(ddp->dd_name)) != 0))
			continue;
		if (ddp->dd_level >= level)
			continue;
		if (ddp->dd_ddate <= (time_t)spcl.c_ddate)
			continue;
		spcl.c_ddate = (int64_t)ddp->dd_ddate;
		lastlevel = ddp->dd_level;
	}
}

void
putdumptime(void)
{
	FILE *df;
	struct dumpdates *dtwalk;
	int fd, i;
	char *fname;
	time_t t;

	if(uflag == 0)
		return;
	if ((df = fopen(dumpdates, "r+")) == NULL)
		quit("cannot rewrite %s: %s\n", dumpdates, strerror(errno));
	fd = fileno(df);
	(void) flock(fd, LOCK_EX);
	fname = duid ? duid : disk;
	free(ddatev);
	ddatev = NULL;
	nddates = 0;
	dthead = NULL;
	ddates_in = 0;
	readdumptimes(df);
	if (fseek(df, 0L, SEEK_SET) < 0)
		quit("fseek: %s\n", strerror(errno));
	spcl.c_ddate = 0;
	ITITERATE(i, dtwalk) {
		if ((strncmp(fname, dtwalk->dd_name,
			     sizeof(dtwalk->dd_name)) != 0) &&
		    (strncmp(disk, dtwalk->dd_name,
			     sizeof(dtwalk->dd_name)) != 0))
			continue;
		if (dtwalk->dd_level != level)
			continue;
		goto found;
	}
	/*
	 *	construct the new upper bound;
	 *	Enough room has been allocated.
	 */
	dtwalk = ddatev[nddates] = calloc(1, sizeof(struct dumpdates));
	nddates += 1;
  found:
	(void) strlcpy(dtwalk->dd_name, fname, sizeof(dtwalk->dd_name));
	dtwalk->dd_level = level;
	dtwalk->dd_ddate = (time_t)spcl.c_date;

	ITITERATE(i, dtwalk) {
		dumprecout(df, dtwalk);
	}
	if (fflush(df))
		quit("%s: %s\n", dumpdates, strerror(errno));
	if (ftruncate(fd, ftello(df)))
		quit("ftruncate (%s): %s\n", dumpdates, strerror(errno));
	(void) fclose(df);
	t = (time_t)spcl.c_date;
	msg("level %c dump on %s", level, t == 0 ? "the epoch\n" : ctime(&t));
}

static void
dumprecout(FILE *file, struct dumpdates *what)
{

	if (fprintf(file, DUMPOUTFMT,
		    what->dd_name,
		    what->dd_level,
		    ctime(&what->dd_ddate)) < 0)
		quit("%s: %s\n", dumpdates, strerror(errno));
}

int	recno;

static int
getrecord(FILE *df, struct dumpdates *ddatep)
{
	char tbuf[BUFSIZ];

	recno = 0;
	if (fgets(tbuf, sizeof(tbuf), df) == NULL)
		return(-1);
	recno++;
	if (makedumpdate(ddatep, tbuf) < 0)
		msg("Unknown intermediate format in %s, line %d\n",
			dumpdates, recno);

#ifdef FDEBUG
	msg("getrecord: %s %c %s", ddatep->dd_name, ddatep->dd_level,
	    ddatep->dd_ddate == 0 ? "the epoch\n" : ctime(&ddatep->dd_ddate));
#endif
	return(0);
}

static int
makedumpdate(struct dumpdates *ddp, char *tbuf)
{
	char un_buf[BUFSIZ], *str;
	struct tm then;

	if (sscanf(tbuf, DUMPINFMT, ddp->dd_name, &ddp->dd_level, un_buf) != 3)
		return(-1);
	str = getduid(ddp->dd_name);
	if (str != NULL) {
		strlcpy(ddp->dd_name, str, sizeof(ddp->dd_name));
		free(str);
	}
	str = strptime(un_buf, "%a %b %e %H:%M:%S %Y", &then);
	then.tm_isdst = -1;
	if (str == NULL || (*str != '\n' && *str != '\0'))
		ddp->dd_ddate = (time_t) -1;
	else
		ddp->dd_ddate = mktime(&then);
	if (ddp->dd_ddate < 0)
		return(-1);
	return(0);
}
@


1.22
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.21 2015/05/23 05:17:20 guenther Exp $	*/
d50 1
a50 1
struct	dumpdates **ddatev = 0;
d53 1
a53 1
struct	dumptime *dthead = 0;
d169 2
a170 2
	free((char *)ddatev);
	ddatev = 0;
d172 1
a172 1
	dthead = 0;
@


1.21
log
@Canonicalize all devices to DUIDs in order to make -w and -W output consistent.

Based on diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.20 2015/05/03 01:44:34 guenther Exp $	*/
d99 1
a99 1
		dtwalk = (struct dumptime *)calloc(1, sizeof(struct dumptime));
d114 1
a114 2
	ddatev = (struct dumpdates **)
		calloc((unsigned) (nddates + 1), sizeof(struct dumpdates *));
d192 1
a192 2
	dtwalk = ddatev[nddates] =
		(struct dumpdates *)calloc(1, sizeof(struct dumpdates));
@


1.20
log
@Eliminate the -U flag and make usage of DUID in /etc/dumpdates the default.
Correct old style entries so nothing has to be done for the admin.

diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.19 2015/01/16 06:39:57 deraadt Exp $	*/
d254 5
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.18 2014/07/11 16:01:41 halex Exp $	*/
d128 1
a128 1
	fname = Uflag ? duid : disk;
d142 2
a143 1
		if (strncmp(fname, ddp->dd_name, sizeof(ddp->dd_name)) != 0)
d169 1
a169 1
	fname = Uflag ? duid : disk;
d180 4
a183 2
		if (strncmp(fname, dtwalk->dd_name,
				sizeof(dtwalk->dd_name)) != 0)
@


1.18
log
@make dump support DUIDs for command line arguments and /etc/dumpdates (using
the new shiny -U switch)

dumpdates part originating from, and discussed with, Maximilian Fillinger

seems reasonable to krw@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.17 2009/10/27 23:59:32 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d46 1
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.16 2007/09/10 14:29:53 tobias Exp $	*/
d127 1
a127 1
	fname = disk;
d167 1
a167 1
	fname = disk;
@


1.16
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.15 2007/06/03 20:16:08 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)itime.c	8.1 (Berkeley) 6/5/93";
#else
static const char rcsid[] = "$OpenBSD: itime.c,v 1.15 2007/06/03 20:16:08 millert Exp $";
#endif
#endif /* not lint */
@


1.15
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.14 2007/03/04 22:37:18 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: itime.c,v 1.14 2007/03/04 22:37:18 deraadt Exp $";
d182 1
a182 1
	if (fseek(df, 0L, 0) < 0)
@


1.14
log
@memory leak found by coverity; Jim Razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.13 2007/03/04 22:36:54 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: itime.c,v 1.13 2007/03/04 22:36:54 deraadt Exp $";
d153 1
a153 1
		if (ddp->dd_ddate <= spcl.c_ddate)
d155 1
a155 1
		spcl.c_ddate = ddp->dd_ddate;
d165 1
a165 2
	int i;
	int fd;
d167 1
d203 1
a203 1
	dtwalk->dd_ddate = spcl.c_date;
d213 2
a214 2
	msg("level %c dump on %s", level,
		spcl.c_date == 0 ? "the epoch\n" : ctime(&spcl.c_date));
@


1.13
log
@delete sunos junk; Jim Razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.12 2004/11/04 20:10:07 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: itime.c,v 1.12 2004/11/04 20:10:07 deraadt Exp $";
d107 2
a108 1
		if (getrecord(df, &(dtwalk->dt_value)) < 0)
d110 1
@


1.12
log
@very basic de-lints
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.11 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: itime.c,v 1.11 2003/07/28 06:13:26 tedu Exp $";
a42 7
#ifdef sunos
#include <sys/vnode.h>

#include <ufs/fsdir.h>
#include <ufs/inode.h>
#include <ufs/fs.h>
#else
a43 1
#endif
@


1.11
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.10 2003/06/26 16:35:21 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: itime.c,v 1.10 2003/06/26 16:35:21 deraadt Exp $";
d216 1
a216 1
	if (ftruncate(fd, ftell(df)))
@


1.10
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.9 2003/06/02 20:06:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.9 2003/06/02 20:06:14 millert Exp $";
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.8 2002/02/19 19:39:38 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.8 2002/02/19 19:39:38 millert Exp $";
d76 1
a76 1
initdumptimes()
d108 1
a108 2
readdumptimes(df)
	FILE *df;
d135 1
a135 1
getdumptime()
d167 1
a167 1
putdumptime()
d224 1
a224 3
dumprecout(file, what)
	FILE *file;
	struct dumpdates *what;
d237 1
a237 3
getrecord(df, ddatep)
	FILE *df;
	struct dumpdates *ddatep;
d257 1
a257 3
makedumpdate(ddp, tbuf)
	struct dumpdates *ddp;
	char *tbuf;
@


1.8
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.7 2002/02/16 21:27:33 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.7 2002/02/16 21:27:33 millert Exp $";
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.6 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.6 2001/11/05 07:39:16 mpech Exp $";
a62 1
#ifdef __STDC__
a65 1
#endif
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.5 1998/08/07 17:29:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.5 1998/08/07 17:29:24 millert Exp $";
d76 4
a79 4
static	void dumprecout __P((FILE *, struct dumpdates *));
static	int getrecord __P((FILE *, struct dumpdates *));
static	int makedumpdate __P((struct dumpdates *, char *));
static	void readdumptimes __P((FILE *));
@


1.5
log
@Use strlcpy() instead of strncpy().
Change the order of name -> raw device conversions
    1) statfs the name and use that info iff the name is the mount point
    2) look up name in fstab
    3) treat as a device
The reason for this is that the mounted filesystems may not agree with
what fstab says.  Anyone who has ever moved disks around and accidentally
dumped and empty filesystem will know what I mean.
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.4 1998/02/08 19:24:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.4 1998/02/08 19:24:08 deraadt Exp $";
d117 2
a118 2
	register int i;
	register struct	dumptime *dtwalk;
d144 2
a145 2
	register struct dumpdates *ddp;
	register int i;
d177 2
a178 2
	register struct dumpdates *dtwalk;
	register int i;
@


1.4
log
@y2k fixes; netbsd & Andreas.Gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.3 1997/07/05 05:35:56 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.3 1997/07/05 05:35:56 millert Exp $";
d214 1
a214 2
	(void) strncpy(dtwalk->dd_name, fname, sizeof(dtwalk->dd_name) - 1);
	dtwalk->dd_name[sizeof(dtwalk->dd_name) - 1] = '\0';
@


1.3
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: itime.c,v 1.2 1996/06/23 14:30:11 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.2 1996/06/23 14:30:11 deraadt Exp $";
d62 1
d273 2
a274 1
	char un_buf[128];
d276 8
a283 2
	(void) sscanf(tbuf, DUMPINFMT, ddp->dd_name, &ddp->dd_level, un_buf);
	ddp->dd_ddate = unctime(un_buf);
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: itime.c,v 1.3 1995/03/18 14:55:01 cgd Exp $	*/
/*	$NetBSD: itime.c,v 1.3 1995/03/18 14:55:01 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: itime.c,v 1.3 1995/03/18 14:55:01 cgd Exp $";
d120 1
a120 1
		dtwalk = (struct dumptime *)calloc(1, sizeof (struct dumptime));
d134 1
a134 1
		calloc((unsigned) (nddates + 1), sizeof (struct dumpdates *));
d161 1
a161 1
		if (strncmp(fname, ddp->dd_name, sizeof (ddp->dd_name)) != 0)
d199 1
a199 1
				sizeof (dtwalk->dd_name)) != 0)
d210 1
a210 1
		(struct dumpdates *)calloc(1, sizeof (struct dumpdates));
d213 2
a214 1
	(void) strncpy(dtwalk->dd_name, fname, sizeof (dtwalk->dd_name));
d253 1
a253 1
	if ( (fgets(tbuf, sizeof (tbuf), df)) != tbuf)
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: itime.c,v 1.3 1995/03/18 14:55:01 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
