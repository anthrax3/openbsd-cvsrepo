head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.6
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.46.0.6
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.8
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.6
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.4
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.44.0.6
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.4
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.42.0.10
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.6
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.4
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.38.0.6
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.4
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.6
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.36.0.4
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.31.0.6
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.4
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.29.0.6
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9:1.29.0.4
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	OPENBSD_2_6:1.26.0.4
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2016.08.31.21.00.31;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	FbtzMX2RToYL8RQu;

1.58
date	2016.06.07.01.29.38;	author tedu;	state Exp;
branches;
next	1.57;
commitid	aJp7bbwjTwgUYbAT;

1.57
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	0qPuuXwccpVXsXcV;

1.56
date	2015.05.23.05.17.20;	author guenther;	state Exp;
branches;
next	1.55;
commitid	xRFGRK8SjUIGT2GW;

1.55
date	2015.05.03.01.44.34;	author guenther;	state Exp;
branches;
next	1.54;
commitid	VGweZq0m0ga9jNw5;

1.54
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	F55lwc3gS4GN2mLs;

1.53
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	Uu5nFG3wCl0LACBb;

1.52
date	2014.07.11.16.01.41;	author halex;	state Exp;
branches;
next	1.51;
commitid	gCk3OFggNKp4mxan;

1.51
date	2014.06.13.20.43.06;	author naddy;	state Exp;
branches;
next	1.50;
commitid	ZqQ42rJaAxHNKIBx;

1.50
date	2014.05.31.08.28.13;	author jmc;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.30.20.48.21;	author stephan;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.27.12.35.40;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.24.21.49.09;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.16.18.17.39;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.25.15.24.16;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.12.16.25.22;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.04.22.36.54;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.25.16.48.46;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.24.21.28.50;	author moritz;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.04.20.10.07;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.25.23.51.01;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.09.23.19.26;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.04.02.53.49;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	99.12.24.22.32.24;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.02.20.21.46.05;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.11.24.01.25.47;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.08.22.07.44.03;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	98.08.11.20.26.59;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.08.11.20.00.14;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.08.07.17.29.25;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	98.07.28.23.27.58;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.07.14.19.04.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.02.08.19.24.08;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.07.05.05.35.56;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.04.16.04.09.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.02.25.17.37.20;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.02.10.04.19.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.02.04.10.06.20;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.03.11.53.25;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.12.16.17.11.32;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.09.14.19.28.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.14.03.26.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.09.01.15.31.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.10.22.26.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.02.10.29.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.02.10.26.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.21.00.15.37;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.22.11.26.23;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.01.01.20.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Delete SIGTRAP, SIGFPE, SIGBUS, and SIGSEGV handlers.  Such patterns
don't help improve code because they block core dumps and there reduce
inspection of bugs thus work on fixes.  Secondly, these handlers are
*stdio signal races* so they can produce different coredumps deep inside
stdio.
@
text
@/*	$OpenBSD: main.c,v 1.58 2016/06/07 01:29:38 tedu Exp $	*/
/*	$NetBSD: main.c,v 1.14 1997/06/05 11:13:24 lukem Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE roundup */
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>

#include <protocols/dumprestore.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fstab.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#include "dump.h"
#include "pathnames.h"

int	notify = 0;	/* notify operator flag */
int64_t	blockswritten = 0;	/* number of blocks written on current tape */
int	tapeno = 0;	/* current tape number */
int	density = 0;	/* density in bytes/0.1" */
int	ntrec = NTREC;	/* # tape blocks in each tape record */
int	cartridge = 0;	/* Assume non-cartridge tape */
int64_t	blocksperfile;	/* output blocks per file */
char	*host = NULL;	/* remote host (if any) */
int	maxbsize = 64*1024;	/* XXX MAXBSIZE from sys/param.h */

struct disklabel lab;

/*
 * Possible superblock locations ordered from most to least likely.
 */
static int sblock_try[] = SBLOCKSEARCH;

static long long numarg(char *, long long, long long);
static void obsolete(int *, char **[]);
static void usage(void);

int
main(int argc, char *argv[])
{
	ino_t ino;
	int dirty;
	union dinode *dp;
	struct	fstab *dt;
	char *map;
	int ch, mode;
	struct tm then;
	struct statfs fsbuf;
	int i, anydirskipped, bflag = 0, Tflag = 0, honorlevel = 1;
	ino_t maxino;
	time_t t;
	int dirlist;
	char *toplevel, *str, *mount_point = NULL, *realpath;
	int just_estimate = 0;
	u_int64_t zero_uid = 0;

	spcl.c_date = (int64_t)time(NULL);

	tsize = 0;	/* Default later, based on 'c' option for cart tapes */
	if ((tape = getenv("TAPE")) == NULL)
		tape = _PATH_DEFTAPE;
	dumpdates = _PATH_DUMPDATES;
	temp = _PATH_DTMP;
	if (TP_BSIZE / DEV_BSIZE == 0 || TP_BSIZE % DEV_BSIZE != 0)
		quit("TP_BSIZE must be a multiple of DEV_BSIZE\n");
	level = '0';

	if (argc < 2)
		usage();

	obsolete(&argc, &argv);
	while ((ch = getopt(argc, argv, "0123456789aB:b:cd:f:h:ns:ST:uWw")) != -1)
		switch (ch) {
		/* dump level */
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			level = ch;
			break;

		case 'B':		/* blocks per output file */
			blocksperfile = numarg("blocks per file", 1, 0);
			break;

		case 'b':		/* blocks per tape write */
			ntrec = numarg("blocks per write", 1, 1000);
			if (ntrec > maxbsize/1024) {
				msg("Please choose a blocksize <= %dKB\n",
				    maxbsize/1024);
				exit(X_STARTUP);
			}
			bflag = 1;
			break;

		case 'c':		/* Tape is cart. not 9-track */
			cartridge = 1;
			break;

		case 'd':		/* density, in bits per inch */
			density = numarg("density", 10, 327670) / 10;
			if (density >= 625 && !bflag)
				ntrec = HIGHDENSITYTREC;
			break;

		case 'f':		/* output file */
			tape = optarg;
			break;

		case 'h':
			honorlevel = numarg("honor level", 0, 10);
			break;

		case 'n':		/* notify operators */
			notify = 1;
			break;

		case 's':		/* tape size, feet */
			tsize = numarg("tape size", 1, 0) * 12 * 10;
			break;

		case 'S':		/* estimate blocks and # of tapes */
			just_estimate = 1;
			break;

		case 'T':		/* time of last dump */
			str = strptime(optarg, "%a %b %e %H:%M:%S %Y", &then);
			then.tm_isdst = -1;
			if (str == NULL || (*str != '\n' && *str != '\0'))
				spcl.c_ddate = -1;
			else
				spcl.c_ddate = (int64_t)mktime(&then);
			if (spcl.c_ddate < 0) {
				(void)fprintf(stderr, "bad time \"%s\"\n",
				    optarg);
				exit(X_STARTUP);
			}
			Tflag = 1;
			lastlevel = '?';
			break;

		case 'u':		/* update /etc/dumpdates */
			uflag = 1;
			break;

		case 'W':		/* what to do */
		case 'w':
			lastdump(ch);
			exit(X_FINOK);	/* do nothing else */
			break;

		case 'a':		/* `auto-size', Write to EOM. */
			unlimited = 1;
			break;

		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc < 1) {
		(void)fprintf(stderr, "Must specify disk or filesystem\n");
		exit(X_STARTUP);
	}

	/*
	 *	determine if disk is a subdirectory, and setup appropriately
	 */
	dirlist = 0;
	toplevel = NULL;
	for (i = 0; i < argc; i++) {
		struct stat sb;

		/* Convert potential duid into a device name */
		if ((diskfd = opendev(argv[i], O_RDONLY | O_NOFOLLOW, 0,
		    &realpath)) >= 0) {
			argv[i] = strdup(realpath);
			if (argv[i] == NULL) {
				msg("Cannot malloc realpath\n");
				exit(X_STARTUP);
			}
			(void)close(diskfd);
		}
		if (lstat(argv[i], &sb) == -1) {
			msg("Cannot lstat %s: %s\n", argv[i], strerror(errno));
			exit(X_STARTUP);
		}
		if (!S_ISDIR(sb.st_mode) && !S_ISREG(sb.st_mode))
			break;
		if (statfs(argv[i], &fsbuf) == -1) {
			msg("Cannot statfs %s: %s\n", argv[i], strerror(errno));
			exit(X_STARTUP);
		}
		if (strcmp(argv[i], fsbuf.f_mntonname) == 0) {
			if (dirlist != 0) {
				msg("Can't dump a mountpoint and a filelist\n");
				exit(X_STARTUP);
			}
			break;		/* exit if sole mountpoint */
		}
		if (!disk) {
			if ((toplevel = strdup(fsbuf.f_mntonname)) == NULL) {
				msg("Cannot malloc diskname\n");
				exit(X_STARTUP);
			}
			disk = toplevel;
			if (uflag) {
				msg("Ignoring u flag for subdir dump\n");
				uflag = 0;
			}
			if (level > '0') {
				msg("Subdir dump is done at level 0\n");
				level = '0';
			}
			msg("Dumping sub files/directories from %s\n", disk);
		} else {
			if (strcmp(disk, fsbuf.f_mntonname) != 0) {
				msg("%s is not on %s\n", argv[i], disk);
				exit(X_STARTUP);
			}
		}
		msg("Dumping file/directory %s\n", argv[i]);
		dirlist++;
	}
	if (dirlist == 0) {
		disk = *argv++;
		if (argc != 1) {
			(void)fputs("Excess arguments to dump:", stderr);
			while (--argc) {
				(void)putc(' ', stderr);
				(void)fputs(*argv++, stderr);
			}
			(void)putc('\n', stderr);
			exit(X_STARTUP);
		}
	}
	if (Tflag && uflag) {
	        (void)fprintf(stderr,
		    "You cannot use the T and u flags together.\n");
		exit(X_STARTUP);
	}
	if (strcmp(tape, "-") == 0) {
		pipeout++;
		tape = "standard output";
	}

	if (blocksperfile)
		blocksperfile = blocksperfile / ntrec * ntrec; /* round down */
	else if (!unlimited) {
		/*
		 * Determine how to default tape size and density
		 *
		 *         	density				tape size
		 * 9-track	1600 bpi (160 bytes/.1")	2300 ft.
		 * 9-track	6250 bpi (625 bytes/.1")	2300 ft.
		 * cartridge	8000 bpi (800 bytes/.1")	1700 ft.
		 *						(450*4 - slop)
		 */
		if (density == 0)
			density = cartridge ? 100 : 160;
		if (tsize == 0)
			tsize = cartridge ? 1700L*120L : 2300L*120L;
	}

	if (strchr(tape, ':')) {
		host = tape;
		tape = strchr(host, ':');
		*tape++ = '\0';
#ifdef RDUMP
		if (rmthost(host) == 0)
			exit(X_STARTUP);
#else
		(void)fprintf(stderr, "remote dump not enabled\n");
		exit(X_STARTUP);
#endif
	}

	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
		signal(SIGHUP, sig);
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, sig);
	if (signal(SIGINT, interrupt) == SIG_IGN)
		signal(SIGINT, SIG_IGN);

	getfstab();		/* /etc/fstab snarfed */

	/*
	 *	disk can be either the full special file name,
	 *	the suffix of the special file name,
	 *	the special name missing the leading '/',
	 *	the file system name with or without the leading '/'.
	 */
	if (!statfs(disk, &fsbuf) && !strcmp(fsbuf.f_mntonname, disk)) {
		/* mounted disk? */
		disk = rawname(fsbuf.f_mntfromname);
		if (!disk) {
			(void)fprintf(stderr, "cannot get raw name for %s\n",
			    fsbuf.f_mntfromname);
			exit(X_STARTUP);
		}
		mount_point = fsbuf.f_mntonname;
		(void)strlcpy(spcl.c_dev, fsbuf.f_mntfromname,
		    sizeof(spcl.c_dev));
		if (dirlist != 0) {
			(void)snprintf(spcl.c_filesys, sizeof(spcl.c_filesys),
			    "a subset of %s", mount_point);
		} else {
			(void)strlcpy(spcl.c_filesys, mount_point,
			    sizeof(spcl.c_filesys));
		}
	} else if ((dt = fstabsearch(disk)) != NULL) {
		/* in fstab? */
		if (strchr(dt->fs_spec, '/')) {
			/* fs_spec is a /dev/something */
			disk = rawname(dt->fs_spec);
		} else {
			/* fs_spec is a DUID */
			disk = rawname(disk);
		}
		mount_point = dt->fs_file;
		(void)strlcpy(spcl.c_dev, dt->fs_spec, sizeof(spcl.c_dev));
		if (dirlist != 0) {
			(void)snprintf(spcl.c_filesys, sizeof(spcl.c_filesys),
			    "a subset of %s", mount_point);
		} else {
			(void)strlcpy(spcl.c_filesys, mount_point,
			    sizeof(spcl.c_filesys));
		}
	} else {
		/* must be a device */
		(void)strlcpy(spcl.c_dev, disk, sizeof(spcl.c_dev));
		(void)strlcpy(spcl.c_filesys, "an unlisted file system",
		    sizeof(spcl.c_filesys));
	}
	(void)strlcpy(spcl.c_label, "none", sizeof(spcl.c_label));
	(void)gethostname(spcl.c_host, sizeof(spcl.c_host));
	spcl.c_level = level - '0';
	spcl.c_type = TS_TAPE;

	if ((diskfd = open(disk, O_RDONLY)) < 0) {
		msg("Cannot open %s\n", disk);
		exit(X_STARTUP);
	}
	if (ioctl(diskfd, DIOCGDINFO, (char *)&lab) < 0)
		err(1, "ioctl (DIOCGDINFO)");
	
	if (memcmp(lab.d_uid, &zero_uid, sizeof(lab.d_uid)) != 0) {
		if (asprintf(&duid,
		    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.%c",
		    lab.d_uid[0], lab.d_uid[1], lab.d_uid[2], lab.d_uid[3],
		    lab.d_uid[4], lab.d_uid[5], lab.d_uid[6], lab.d_uid[7],
		    disk[strlen(disk)-1]) == -1) {
			msg("Cannot malloc duid\n");
			exit(X_STARTUP);
		}
	}
	if (!Tflag)
	        getdumptime();		/* /etc/dumpdates snarfed */

	t = (time_t)spcl.c_date;
	msg("Date of this level %c dump: %s", level,
		t == 0 ? "the epoch\n" : ctime(&t));
	t = (time_t)spcl.c_ddate;
 	msg("Date of last level %c dump: %s", lastlevel,
		t == 0 ? "the epoch\n" : ctime(&t));
	msg("Dumping %s ", disk);
	if (mount_point != NULL)
		msgtail("(%s) ", mount_point);
	if (host)
		msgtail("to %s on host %s\n", tape, host);
	else
		msgtail("to %s\n", tape);

	if (ioctl(diskfd, DIOCGPDINFO, (char *)&lab) < 0)
		err(1, "ioctl (DIOCGPDINFO)");
	sync();
	sblock = (struct fs *)sblock_buf;
	for (i = 0; sblock_try[i] != -1; i++) {
		ssize_t n = pread(diskfd, sblock, SBLOCKSIZE,
		    (off_t)sblock_try[i]);
		if (n == SBLOCKSIZE && (sblock->fs_magic == FS_UFS1_MAGIC ||
		     (sblock->fs_magic == FS_UFS2_MAGIC &&
		      sblock->fs_sblockloc == sblock_try[i])) &&
		    sblock->fs_bsize <= MAXBSIZE &&
		    sblock->fs_bsize >= sizeof(struct fs))
			break;
	}
	if (sblock_try[i] == -1)
		quit("Cannot find filesystem superblock\n");
	tp_bshift = ffs(TP_BSIZE) - 1;
	if (TP_BSIZE != (1 << tp_bshift))
		quit("TP_BSIZE (%d) is not a power of 2\n", TP_BSIZE);
#ifdef FS_44INODEFMT
	if (sblock->fs_magic == FS_UFS2_MAGIC ||
	    sblock->fs_inodefmt >= FS_44INODEFMT)
		spcl.c_flags |= DR_NEWINODEFMT;
#endif
	maxino = sblock->fs_ipg * sblock->fs_ncg;
	mapsize = roundup(howmany(maxino, NBBY), TP_BSIZE);
	usedinomap = calloc((unsigned) mapsize, sizeof(char));
	dumpdirmap = calloc((unsigned) mapsize, sizeof(char));
	dumpinomap = calloc((unsigned) mapsize, sizeof(char));
	tapesize = 3 * (howmany(mapsize * sizeof(char), TP_BSIZE) + 1);

	nonodump = spcl.c_level < honorlevel;

	(void)signal(SIGINFO, statussig);

	msg("mapping (Pass I) [regular files]\n");
	anydirskipped = mapfiles(maxino, &tapesize, toplevel,
	    (dirlist ? argv : NULL));

	msg("mapping (Pass II) [directories]\n");
	while (anydirskipped) {
		anydirskipped = mapdirs(maxino, &tapesize);
	}

	if (pipeout || unlimited) {
		tapesize += 10;	/* 10 trailer blocks */
		msg("estimated %lld tape blocks.\n", tapesize);
	} else {
		double fetapes;

		if (blocksperfile)
			fetapes = (double) tapesize / blocksperfile;
		else if (cartridge) {
			/* Estimate number of tapes, assuming streaming stops at
			   the end of each block written, and not in mid-block.
			   Assume no erroneous blocks; this can be compensated
			   for with an artificially low tape size. */
			fetapes =
			(	  tapesize	/* blocks */
				* TP_BSIZE	/* bytes/block */
				* (1.0/density)	/* 0.1" / byte */
			  +
				  tapesize	/* blocks */
				* (1.0/ntrec)	/* streaming-stops per block */
				* 15.48		/* 0.1" / streaming-stop */
			) * (1.0 / tsize );	/* tape / 0.1" */
		} else {
			/* Estimate number of tapes, for old fashioned 9-track
			   tape */
			int tenthsperirg = (density == 625) ? 3 : 7;
			fetapes =
			(	  tapesize	/* blocks */
				* TP_BSIZE	/* bytes / block */
				* (1.0/density)	/* 0.1" / byte */
			  +
				  tapesize	/* blocks */
				* (1.0/ntrec)	/* IRG's / block */
				* tenthsperirg	/* 0.1" / IRG */
			) * (1.0 / tsize );	/* tape / 0.1" */
		}
		etapes = fetapes;		/* truncating assignment */
		etapes++;
		/* count the dumped inodes map on each additional tape */
		tapesize += (etapes - 1) *
			(howmany(mapsize * sizeof(char), TP_BSIZE) + 1);
		tapesize += etapes + 10;	/* headers + 10 trailer blks */
		msg("estimated %lld tape blocks on %3.2f tape(s).\n",
		    tapesize, fetapes);
	}

	/*
	 * Exit if user wants an estimate of blocks and # of tapes only.
	 */
	if (just_estimate)
		exit(X_FINOK);

	/*
	 * Allocate tape buffer.
	 */
	if (!alloctape())
		quit("can't allocate tape buffers - try a smaller blocking factor.\n");

	startnewtape(1);
	(void)time(&tstart_writing);
	xferrate = 0;
	dumpmap(usedinomap, TS_CLRI, maxino - 1);

	msg("dumping (Pass III) [directories]\n");
	dirty = 0;		/* XXX just to get gcc to shut up */
	for (map = dumpdirmap, ino = 1; ino < maxino; ino++) {
		if (((ino - 1) % NBBY) == 0)	/* map is offset by 1 */
			dirty = *map++;
		else
			dirty >>= 1;
		if ((dirty & 1) == 0)
			continue;
		/*
		 * Skip directory inodes deleted and maybe reallocated
		 */
		dp = getino(ino, &mode);
		if (mode != IFDIR)
			continue;
		(void)dumpino(dp, ino);
	}

	msg("dumping (Pass IV) [regular files]\n");
	for (map = dumpinomap, ino = 1; ino < maxino; ino++) {
		if (((ino - 1) % NBBY) == 0)	/* map is offset by 1 */
			dirty = *map++;
		else
			dirty >>= 1;
		if ((dirty & 1) == 0)
			continue;
		/*
		 * Skip inodes deleted and reallocated as directories.
		 */
		dp = getino(ino, &mode);
		if (mode == IFDIR)
			continue;
		(void)dumpino(dp, ino);
	}

	spcl.c_type = TS_END;
	for (i = 0; i < ntrec; i++)
		writeheader(maxino - 1);
	if (pipeout)
		msg("%lld tape blocks\n", spcl.c_tapea);
	else
		msg("%lld tape blocks on %d volume%s\n",
		    spcl.c_tapea, spcl.c_volume,
		    (spcl.c_volume == 1) ? "" : "s");
	t = (time_t)spcl.c_date;
	msg("Date of this level %c dump: %s", level,
	    t == 0 ? "the epoch\n" : ctime(&t));
	t = do_stats();
	msg("Date this dump completed:  %s", ctime(&t));
	msg("Average transfer rate: %ld KB/s\n", xferrate / tapeno);
	putdumptime();
	trewind();
	broadcast("DUMP IS DONE!\7\7\n");
	msg("DUMP IS DONE\n");
	Exit(X_FINOK);
	/* NOTREACHED */
}

static void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr, "usage: %s [-0123456789acnSuWw] [-B records] "
		      "[-b blocksize] [-d density]\n"
		      "\t[-f file] [-h level] [-s feet] "
		      "[-T date] files-to-dump\n",
		      __progname);
	exit(X_STARTUP);
}

/*
 * Pick up a numeric argument.  It must be nonnegative and in the given
 * range (except that a vmax of 0 means unlimited).
 */
static long long
numarg(char *meaning, long long vmin, long long vmax)
{
	long long val;
	const char *errstr;

	if (vmax == 0)
		vmax = LLONG_MAX;
	val = strtonum(optarg, vmin, vmax, &errstr);
	if (errstr)
		errx(X_STARTUP, "%s is %s [%lld - %lld]",
		    meaning, errstr, vmin, vmax);

	return (val);
}

void
sig(int signo)
{
	switch(signo) {
	case SIGALRM:
	case SIGHUP:
	case SIGTERM:
		/* XXX signal race */
		if (pipeout)
			quit("Signal on pipe: cannot recover\n");
		msg("Rewriting attempted as response to unknown signal.\n");
		(void)fflush(stderr);
		(void)fflush(stdout);
		close_rewind();
		exit(X_REWRITE);
		/* NOTREACHED */
	}
}

char *
rawname(char *cp)
{
	static char rawbuf[PATH_MAX];
	char *dp = strrchr(cp, '/');
	char *prefix;

	if (dp == NULL)
		return (NULL);
	prefix = dp[1] == 'r' ? "" : "r";
	*dp = '\0';
	(void)snprintf(rawbuf, sizeof(rawbuf), "%s/%s%s", cp, prefix, dp + 1);
	*dp = '/';
	return (rawbuf);
}

char *
getduid(char *path)
{
	int fd;
	struct disklabel lab;
	u_int64_t zero_uid = 0;
	char *duid;
	
	if ((fd = opendev(path, O_RDONLY | O_NOFOLLOW, 0, NULL)) >= 0) {
		if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
			close(fd);
			warn("ioctl(DIOCGDINFO)");
			return (NULL);
		}
		close(fd);
	
		if (memcmp(lab.d_uid, &zero_uid, sizeof(lab.d_uid)) != 0) {
			if (asprintf(&duid,
			    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.%c",
			    lab.d_uid[0], lab.d_uid[1], lab.d_uid[2],
			    lab.d_uid[3], lab.d_uid[4], lab.d_uid[5],
			    lab.d_uid[6], lab.d_uid[7],
			    path[strlen(path)-1]) == -1) {
				warn("Cannot malloc duid");
				return (NULL);
			}
			return (duid);
		}
	}

	return (NULL);
}

/*
 * obsolete --
 *	Change set of key letters and ordered arguments into something
 *	getopt(3) will like.
 */
static void
obsolete(int *argcp, char **argvp[])
{
	int argc, flags;
	char *ap, **argv, *flagsp, **nargv, *p;
	size_t len;

	/* Setup. */
	argv = *argvp;
	argc = *argcp;

	/* Return if no arguments or first argument has leading dash. */
	ap = argv[1];
	if (argc == 1 || *ap == '-')
		return;

	/* Allocate space for new arguments. */
	if ((*argvp = nargv = calloc(argc + 1, sizeof(char *))) == NULL ||
	    (p = flagsp = malloc(strlen(ap) + 2)) == NULL)
		err(1, NULL);

	*nargv++ = *argv;
	argv += 2;

	for (flags = 0; *ap; ++ap) {
		switch (*ap) {
		case 'B':
		case 'b':
		case 'd':
		case 'f':
		case 'h':
		case 's':
		case 'T':
			if (*argv == NULL) {
				warnx("option requires an argument -- %c", *ap);
				usage();
			}
			len = 2 + strlen(*argv) + 1;
			if ((nargv[0] = malloc(len)) == NULL)
				err(1, NULL);
			nargv[0][0] = '-';
			nargv[0][1] = *ap;
			(void)strlcpy(&nargv[0][2], *argv, len - 2);
			++argv;
			++nargv;
			break;
		default:
			if (!flags) {
				*p++ = '-';
				flags = 1;
			}
			*p++ = *ap;
			break;
		}
	}

	/* Terminate flags, or toss the buffer we did not use. */
	if (flags) {
		*p = '\0';
		*nargv++ = flagsp;
	} else
		free(flagsp);

	/* Copy remaining arguments. */
	while ((*nargv++ = *argv++))
		continue;

	/* Update argument count. */
	*argcp = nargv - *argvp - 1;
}
@


1.58
log
@per trending style, add continue to emtpy loop bodies.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2015/08/20 22:02:20 deraadt Exp $	*/
a324 8
	if (signal(SIGTRAP, SIG_IGN) != SIG_IGN)
		signal(SIGTRAP, sig);
	if (signal(SIGFPE, SIG_IGN) != SIG_IGN)
		signal(SIGFPE, sig);
	if (signal(SIGBUS, SIG_IGN) != SIG_IGN)
		signal(SIGBUS, sig);
	if (signal(SIGSEGV, SIG_IGN) != SIG_IGN)
		signal(SIGSEGV, sig);
a621 2
	case SIGBUS:
	case SIGFPE:
a623 1
	case SIGTRAP:
a631 6
		/* NOTREACHED */
	case SIGSEGV:
#define SIGSEGV_MSG "SIGSEGV: ABORTING!\n"
		write(STDERR_FILENO, SIGSEGV_MSG, strlen(SIGSEGV_MSG));
		(void)signal(SIGSEGV, SIG_DFL);
		(void)kill(0, SIGSEGV);
@


1.57
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2015/05/23 05:17:20 guenther Exp $	*/
d772 1
a772 1
		;
@


1.56
log
@Canonicalize all devices to DUIDs in order to make -w and -W output consistent.

Based on diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2015/05/03 01:44:34 guenther Exp $	*/
d453 3
a455 3
	usedinomap = (char *)calloc((unsigned) mapsize, sizeof(char));
	dumpdirmap = (char *)calloc((unsigned) mapsize, sizeof(char));
	dumpinomap = (char *)calloc((unsigned) mapsize, sizeof(char));
@


1.55
log
@Eliminate the -U flag and make usage of DUID in /etc/dumpdates the default.
Correct old style entries so nothing has to be done for the admin.

diff from Manuel Giraud (manuel (at) ledu-giraud.fr)  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2015/01/20 18:22:20 deraadt Exp $	*/
d301 1
a301 1
		 * cartridge	8000 bpi (100 bytes/.1")	1700 ft.
d366 7
a372 1
		disk = rawname(dt->fs_spec);
d658 1
d662 1
d664 1
a664 1
	(void)snprintf(rawbuf, sizeof(rawbuf), "%s/r%s", cp, dp + 1);
d667 33
@


1.54
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2015/01/16 06:39:57 deraadt Exp $	*/
d118 1
a118 1
	while ((ch = getopt(argc, argv, "0123456789aB:b:cd:f:h:ns:ST:UuWw")) != -1)
a185 4
		case 'U':
			Uflag = 1;	/* use duids */
			break;

d393 10
a402 12
	if (!Uflag)
		;
	else if (memcmp(lab.d_uid, &zero_uid, sizeof(lab.d_uid)) == 0) {
		msg("Cannot find DUID of disk %s\n", disk);
		exit(X_STARTUP);
	} else if (asprintf(&duid,
	    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.%c",
	    lab.d_uid[0], lab.d_uid[1], lab.d_uid[2], lab.d_uid[3],
	    lab.d_uid[4], lab.d_uid[5], lab.d_uid[6], lab.d_uid[7],
	    disk[strlen(disk)-1]) == -1) {
		msg("Cannot malloc duid\n");
		exit(X_STARTUP);
d591 1
a591 1
	(void)fprintf(stderr, "usage: %s [-0123456789acnSUuWw] [-B records] "
@


1.53
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2014/07/11 16:01:41 halex Exp $	*/
d33 1
a33 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE roundup */
@


1.52
log
@make dump support DUIDs for command line arguments and /etc/dumpdates (using
the new shiny -U switch)

dumpdates part originating from, and discussed with, Maximilian Fillinger

seems reasonable to krw@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2014/06/13 20:43:06 naddy Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d57 1
d656 1
a656 1
	static char rawbuf[MAXPATHLEN];
@


1.51
log
@Type cleanup:
* Move all off_t variables that don't look like file sizes to int64_t.
* Switch blockswritten to int64_t, so it won't wrap at 2TB.
* Same for blocksthisvol (from deraadt@@).
* Switch xferrate (from tedu@@) and blocksperfile from long to uint64_t.
* Since blocksperfile can be set with -B, move numarg() from long
to long long and don't mark small integer constant arguments as long.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2014/05/31 08:28:13 jmc Exp $	*/
d57 1
d98 1
a98 1
	char *toplevel, *str, *mount_point = NULL;
d100 1
d117 1
a117 1
	while ((ch = getopt(argc, argv, "0123456789aB:b:cd:f:h:ns:ST:uWw")) != -1)
d185 4
d222 10
d389 20
a425 4
	if ((diskfd = open(disk, O_RDONLY)) < 0) {
		msg("Cannot open %s\n", disk);
		exit(X_STARTUP);
	}
d596 1
a596 1
	(void)fprintf(stderr, "usage: %s [-0123456789acnSuWw] [-B records] "
@


1.50
log
@add -S to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2014/05/30 20:48:21 stephan Exp $	*/
d62 1
a62 1
int	blockswritten = 0;	/* number of blocks written on current tape */
d67 1
a67 1
long	blocksperfile;	/* output blocks per file */
d78 1
a78 1
static long numarg(char *, long, long);
d124 1
a124 1
			blocksperfile = numarg("blocks per file", 1L, 0L);
d128 1
a128 1
			ntrec = numarg("blocks per write", 1L, 1000L);
d142 1
a142 1
			density = numarg("density", 10L, 327670L) / 10;
d152 1
a152 1
			honorlevel = numarg("honor level", 0L, 10L);
d160 1
a160 1
			tsize = numarg("tape size", 1L, 0L) * 12 * 10;
d576 2
a577 2
static long
numarg(char *meaning, long vmin, long vmax)
d579 1
a579 1
	long val;
d583 1
a583 1
		vmax = LONG_MAX;
d586 1
a586 1
		errx(X_STARTUP, "%s is %s [%ld - %ld]",
@


1.49
log
@Add option -S to have dump(8) only estimate backup size and number of tapes
required (from NetBSD).

ok beck@@, krw@@ and sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2014/05/27 12:35:40 krw Exp $	*/
d564 1
a564 1
	(void)fprintf(stderr, "usage: %s [-0123456789acnuWw] [-B records] "
@


1.48
log
@Where trying to pread() a single disk sector, the i/o must be for the
actual disk sector size and not DEV_BSIZE. The sector size must be
obtained via the disklabel. Larger i/o's must be multiple sectors,
so when retrying with a smaller size shrink the attempt by one sector
and not DEV_BSIZE.

Of course if your d_secsize is DEV_BSIZE, this will all be a no-op.

This does not make non-512-byte sectors work, but puts in place the
logic to get and use the disklabel info. Which makes the next diffs
bite sized and focused.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2014/05/24 21:49:09 krw Exp $	*/
d98 1
d115 1
a115 1
	while ((ch = getopt(argc, argv, "0123456789aB:b:cd:f:h:ns:T:uWw")) != -1)
d163 4
d483 6
@


1.47
log
@Nuke last of the illusionary 'dev_bsize' and 'dev_bshift' variables in
favour of DEV_BSIZE. No-op on 512-byte sector devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2013/04/16 18:17:39 deraadt Exp $	*/
d37 3
d71 2
d389 2
@


1.46
log
@do not need to cast type to same type
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2011/04/25 15:24:16 deraadt Exp $	*/
a63 1
long	dev_bsize = 1;	/* recalculated below */
a397 4
	dev_bsize = sblock->fs_fsize / fsbtodb(sblock, 1);
	dev_bshift = ffs(dev_bsize) - 1;
	if (dev_bsize != (1 << dev_bshift))
		quit("dev_bsize (%d) is not a power of 2\n", dev_bsize);
@


1.45
log
@do not use stdio in the (stupid) SIGSEGV handler
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2009/11/12 16:25:22 deraadt Exp $	*/
d484 1
a484 1
	(void)time((time_t *)&(tstart_writing));
@


1.44
log
@free flagsp if flags variable indicates it was not used, found by parfait; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2009/10/27 23:59:32 deraadt Exp $	*/
d589 1
d599 2
a600 1
		msg("SIGSEGV: ABORTING!\n");
@


1.43
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2007/09/02 15:19:23 deraadt Exp $	*/
d680 1
a680 1
	/* Terminate flags. */
d684 2
a685 1
	}
@


1.42
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2007/06/03 20:16:08 millert Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1991, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.4 (Berkeley) 4/15/94";
#else
static const char rcsid[] = "$OpenBSD: main.c,v 1.41 2007/06/03 20:16:08 millert Exp $";
#endif
#endif /* not lint */
@


1.41
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2007/03/04 22:36:54 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.40 2007/03/04 22:36:54 deraadt Exp $";
d655 1
a655 1
	if ((*argvp = nargv = malloc((argc + 1) * sizeof(char *))) == NULL ||
@


1.40
log
@delete sunos junk; Jim Razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2007/02/25 16:48:46 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.39 2007/02/25 16:48:46 jmc Exp $";
a71 4
#ifndef SBOFF
#define SBOFF (SBLOCK * DEV_BSIZE)
#endif

d83 5
d97 1
a97 1
	struct ufs1_dinode *dp;
d100 1
a100 1
	int ch;
d105 1
a105 1
	time_t tnow;
d109 1
a109 2
	spcl.c_date = 0;
	(void)time((time_t *)&spcl.c_date);
d176 1
a176 1
				spcl.c_ddate = (time_t) -1;
d178 1
a178 1
				spcl.c_ddate = mktime(&then);
d381 1
d383 2
a384 1
		spcl.c_date == 0 ? "the epoch\n" : ctime(&spcl.c_date));
d386 1
a386 1
		spcl.c_ddate == 0 ? "the epoch\n" : ctime(&spcl.c_ddate));
d401 12
a412 3
	bread(SBOFF, (char *) sblock, SBSIZE);
	if (sblock->fs_magic != FS_MAGIC)
		quit("bad sblock magic number\n");
d421 2
a422 1
	if (sblock->fs_inodefmt >= FS_44INODEFMT)
d447 1
a447 1
		msg("estimated %qd tape blocks.\n", tapesize);
d487 1
a487 1
		msg("estimated %qd tape blocks on %3.2f tape(s).\n",
d514 2
a515 2
		dp = getino(ino);
		if ((dp->di_mode & IFMT) != IFDIR)
a521 2
		int mode;

d531 1
a531 2
		dp = getino(ino);
		mode = dp->di_mode & IFMT;
d541 1
a541 1
		msg("%ld tape blocks\n", spcl.c_tapea);
d543 1
a543 1
		msg("%ld tape blocks on %d volume%s\n",
d546 1
a546 1
	tnow = do_stats();
d548 3
a550 2
	    spcl.c_date == 0 ? "the epoch\n" : ctime(&spcl.c_date));
	msg("Date this dump completed:  %s", ctime(&tnow));
@


1.39
log
@the -W and -w flags do not need a separate synopsis;
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2005/05/24 21:28:50 moritz Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.38 2005/05/24 21:28:50 moritz Exp $";
a50 6
#ifdef sunos
#include <sys/vnode.h>

#include <ufs/inode.h>
#include <ufs/fs.h>
#else
a52 1
#endif
@


1.38
log
@fix minor ouput glitch, by using strtonum instead of strtol.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2004/11/04 20:10:07 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.37 2004/11/04 20:10:07 deraadt Exp $";
d562 5
a566 4
	(void)fprintf(stderr, "usage: %s [-0123456789acnu] [-B records]"
		      "[-b blocksize] [-d density] [-f file]\n"
		      "            [-h level] [-s feet] [-T date] filesystem\n"
		      "       %s [-W | -w]\n", __progname, __progname);
@


1.37
log
@very basic de-lints
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2003/08/25 23:28:15 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.36 2003/08/25 23:28:15 tedu Exp $";
a575 1
	char *p;
d577 8
a585 5
	val = strtol(optarg, &p, 10);
	if (*p)
		errx(X_STARTUP, "illegal %s -- %s", meaning, optarg);
	if (val < vmin || (vmax && val > vmax))
		errx(X_STARTUP, "%s must be between %ld and %ld", meaning, vmin, vmax);
@


1.36
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2003/07/28 06:13:26 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.35 2003/07/28 06:13:26 tedu Exp $";
d203 1
@


1.35
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2003/06/26 16:35:21 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD$";
d103 1
a103 1
	struct dinode *dp;
@


1.34
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2003/06/02 20:06:14 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: main.c,v 1.8 1996/03/15 22:39:32 scottr Exp $";
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2003/04/25 23:51:01 deraadt Exp $	*/
d99 1
a99 3
main(argc, argv)
	int argc;
	char *argv[];
d557 1
a557 1
usage()
d573 1
a573 3
numarg(meaning, vmin, vmax)
	char *meaning;
	long vmin, vmax;
d587 1
a587 2
sig(signo)
	int signo;
d613 1
a613 2
rawname(cp)
	char *cp;
d632 1
a632 3
obsolete(argcp, argvp)
	int *argcp;
	char **argvp[];
@


1.32
log
@string cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2002/02/16 21:27:33 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2001/11/05 07:39:16 mpech Exp $	*/
d648 1
d680 2
a681 1
			if ((nargv[0] = malloc(strlen(*argv) + 2 + 1)) == NULL)
d685 1
a685 1
			(void)strcpy(&nargv[0][2], *argv);
@


1.30
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2000/10/09 23:19:26 mickey Exp $	*/
d98 3
a100 3
static long numarg __P((char *, long, long));
static void obsolete __P((int *, char **[]));
static void usage __P((void));
@


1.29
log
@do not coredump if can't get raw device name, e.g. /tmp on mfs; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2000/01/04 02:53:49 millert Exp $	*/
d107 6
a112 6
	register ino_t ino;
	register int dirty;
	register struct dinode *dp;
	register struct	fstab *dt;
	register char *map;
	register int ch;
@


1.28
log
@Fix format string typo when printing estimated number of blocks;
naddy@@unix-ag.uni-kl.de
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 1999/12/24 22:32:24 angelos Exp $	*/
d353 5
@


1.27
log
@Use correct printf formatting (dwmalone@@maths.tcd.ie)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 1999/02/20 21:46:05 deraadt Exp $	*/
d442 1
a442 1
		msg("estimated %lq tape blocks.\n", tapesize);
@


1.26
log
@quit() wants the \n
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 1998/11/24 01:25:47 deraadt Exp $	*/
d442 1
a442 1
		msg("estimated %ld tape blocks.\n", tapesize);
@


1.25
log
@Wall, and do not let tapesize overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 1998/08/22 07:44:03 mickey Exp $	*/
d412 1
a412 1
		quit("dev_bsize (%d) is not a power of 2", dev_bsize);
d415 1
a415 1
		quit("TP_BSIZE (%d) is not a power of 2", TP_BSIZE);
@


1.24
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 1998/08/11 20:26:59 millert Exp $	*/
d482 1
a482 1
		msg("estimated %ld tape blocks on %3.2f tape(s).\n",
@


1.23
log
@Better fix.  Now print mount point in both the statfs and fstab cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 1998/08/07 17:29:25 millert Exp $	*/
d560 1
d562 4
a565 2
	(void)fprintf(stderr, "usage: dump [-0123456789cnu] [-B records] [-b blocksize] [-d density] [-f file]\n            [-h level] [-s feet] [-T date] filesystem\n");
	(void)fprintf(stderr, "       dump [-W | -w]\n");
@


1.22
log
@Fix unitialized value use introduce in last change; problem noted by hgweigand@@wiesbaden.netsurf.de
@
text
@d110 1
a110 1
	register struct	fstab *dt = NULL;
d119 1
a119 1
	char *toplevel, *str;
d353 1
d358 1
a358 1
			    "a subset of %s", fsbuf.f_mntonname);
d360 1
a360 1
			(void)strlcpy(spcl.c_filesys, fsbuf.f_mntonname,
d366 1
d370 1
a370 1
			    "a subset of %s", dt->fs_file);
d372 1
a372 1
			(void)strlcpy(spcl.c_filesys, dt->fs_file,
d393 2
a394 2
	if (dt != NULL)
		msgtail("(%s) ", dt->fs_file);
@


1.21
log
@Use strlcpy() instead of strncpy().
Change the order of name -> raw device conversions
    1) statfs the name and use that info iff the name is the mount point
    2) look up name in fstab
    3) treat as a device
The reason for this is that the mounted filesystems may not agree with
what fstab says.  Anyone who has ever moved disks around and accidentally
dumped and empty filesystem will know what I mean.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 1998/07/28 23:27:58 millert Exp $	*/
d110 1
a110 1
	register struct	fstab *dt;
@


1.20
log
@make dump work on filesystems not listed in fstab
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1998/07/14 19:04:08 deraadt Exp $	*/
d350 14
a363 2
	dt = fstabsearch(disk);
	if (dt != NULL) {
d365 1
a365 2
		(void)strncpy(spcl.c_dev, dt->fs_spec, sizeof(spcl.c_dev) - 1);
		spcl.c_dev[sizeof(spcl.c_dev) - 1] = '\0';
d370 2
a371 3
			(void)strncpy(spcl.c_filesys, dt->fs_file,
			    sizeof(spcl.c_filesys) - 1);
			spcl.c_filesys[sizeof(spcl.c_filesys) - 1] = '\0';
a372 8
	} else if (!statfs(disk, &fsbuf) && !strcmp(fsbuf.f_mntonname, disk)) {
		disk = rawname(fsbuf.f_mntfromname);
		(void)strncpy(spcl.c_dev, fsbuf.f_mntfromname,
		    sizeof(spcl.c_dev) - 1);
		spcl.c_dev[sizeof(spcl.c_dev) - 1] = '\0';
		(void)strncpy(spcl.c_filesys, fsbuf.f_mntonname,
		    sizeof(spcl.c_filesys) - 1);
		spcl.c_filesys[sizeof(spcl.c_filesys) - 1] = '\0';
d374 4
a377 5
		(void)strncpy(spcl.c_dev, disk, sizeof(spcl.c_dev) - 1);
		spcl.c_dev[sizeof(spcl.c_dev) - 1] = '\0';
		(void)strncpy(spcl.c_filesys, "an unlisted file system",
		    sizeof(spcl.c_filesys) - 1);
		spcl.c_filesys[sizeof(spcl.c_filesys) - 1] = '\0';
d379 1
a379 2
	(void)strncpy(spcl.c_label, "none", sizeof(spcl.c_label) - 1);
	spcl.c_label[sizeof(spcl.c_label) - 1] = '\0';
@


1.19
log
@fix exit codes, adding X_STARTUP; jkoshy@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1998/02/08 19:24:08 deraadt Exp $	*/
d114 1
a231 1
		struct statfs fsbuf;
d363 8
@


1.18
log
@y2k fixes; netbsd & Andreas.Gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1997/07/05 05:35:56 millert Exp $	*/
d153 1
a153 1
				exit(X_ABORT);
d194 1
a194 1
				exit(X_ABORT);
d207 1
a207 1
			exit(0);	/* do nothing else */
d221 1
a221 1
		exit(X_ABORT);
d235 1
a235 1
			exit(X_ABORT);
d241 1
a241 1
			exit(X_ABORT);
d246 1
a246 1
				exit(X_ABORT);
d253 1
a253 1
				exit(X_ABORT);
d268 1
a268 1
				exit(X_ABORT);
d283 1
a283 1
			exit(X_ABORT);
d289 1
a289 1
		exit(X_ABORT);
d320 1
a320 1
			exit(X_ABORT);
d323 1
a323 1
		exit(X_ABORT);
d392 1
a392 1
		exit(X_ABORT);
d553 1
a553 1
	exit(1);
d570 1
a570 1
		errx(1, "illegal %s -- %s", meaning, optarg);
d572 1
a572 1
		errx(1, "%s must be between %ld and %ld", meaning, vmin, vmax);
@


1.17
log
@Fix some incorrect strncpy usage.

From NetBSD (luke@@netbsd.org)
* verbosity additions displaying total & per-volume transfer times and rates
* Add the ability to dump specific files & directories of a single
  filesystem. This uses fts(3) to access the directory structure (and
  not the raw device), so the standard access permissions are adhered
  to (unlike dumping an entire filesystem, which just requires read
  access to the raw disk device).
* Support SIGINFO status reporting.
* Remove now unused variables that previously stored the (e)uid.
* Be more informative in a couple of error messages.

From NetBSD (mrg)
* fix NetBSD PR#3710, reported by Tatoku Ogaito <tacha@@trap.fukui-med.ac.jp>.
  don't pass pw->pw_name into functions; make a copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1997/04/16 04:09:21 millert Exp $	*/
d113 1
d118 1
a118 1
	char *toplevel;
d185 6
a190 1
			spcl.c_ddate = unctime(optarg);
@


1.16
log
@_PATH_DEFTAPE is now defined in <paths.h>
Change man page to reflect new default tape drive (/dev/rst0)
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.15 1997/02/25 17:37:20 millert Exp $	*/
/*	$NetBSD: main.c,v 1.8 1996/03/15 22:39:32 scottr Exp $	*/
d52 2
d77 1
a101 1

d108 1
a108 1
	register int dirty; 
d115 3
d217 62
a278 8
	disk = *argv++;
	argc--;
	if (argc >= 1) {
		(void)fprintf(stderr, "Unknown arguments to dump:");
		while (argc--)
			(void)fprintf(stderr, " %s", *argv++);
		(void)fprintf(stderr, "\n");
		exit(X_ABORT);
d337 1
d347 10
a356 2
		(void)strncpy(spcl.c_dev, dt->fs_spec, NAMELEN);
		(void)strncpy(spcl.c_filesys, dt->fs_file, NAMELEN);
d358 2
a359 1
		(void)strncpy(spcl.c_dev, disk, NAMELEN);
d361 2
a362 1
		    NAMELEN);
d364 3
a366 2
	(void)strcpy(spcl.c_label, "none");
	(void)gethostname(spcl.c_host, NAMELEN);
d413 2
d416 2
a417 1
	anydirskipped = mapfiles(maxino, &tapesize);
d437 1
a437 1
			fetapes = 
d478 1
d527 6
a532 1
		    spcl.c_volume > 1 ? "s" : "");
d607 1
a607 2
	(void)strncpy(rawbuf, cp, MAXPATHLEN-1);
	rawbuf[MAXPATHLEN-1] = '\0';
a608 2
	(void)strncat(rawbuf, "/r", MAXPATHLEN - strlen(rawbuf));
	(void)strncat(rawbuf, dp + 1, MAXPATHLEN - strlen(rawbuf));
@


1.15
log
@-b option was being ignored when used in conjunction with -d.
NetBSD PR #3254, fix from Juergen Hannken-Illjes <hannken@@eis.cs.tu-bs.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1997/02/10 04:19:55 millert Exp $	*/
d70 1
@


1.14
log
@Make dump(8) really honor -a.  Fix up formatting in man page and remove
duplicate entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1997/02/04 10:06:20 deraadt Exp $	*/
d148 1
@


1.13
log
@maxbsize hack i did was not portable
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/02/03 11:53:25 deraadt Exp $	*/
d129 1
a129 1
	while ((ch = getopt(argc, argv, "0123456789B:b:cd:f:h:ns:T:uWw")) != -1)
@


1.12
log
@new -a option autosizes, meaning it runs till it hits EOM (no need for
pesky sizing options) -- from FreeBSD.
also make -b option aware of MAXPHYS issues (via a little hack)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1996/12/16 17:11:32 deraadt Exp $	*/
d92 1
a97 1
extern int maxbsize;
@


1.11
log
@does noone know how to use strncat correctly?
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1996/09/14 19:28:58 deraadt Exp $	*/
d97 2
d143 5
d196 4
d231 1
a231 1
	else {
d348 1
a348 1
	if (pipeout) {
@


1.10
log
@setgid stuff goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1996/09/14 03:26:02 millert Exp $	*/
d514 2
a515 1
	(void)strncpy(rawbuf, cp, MAXPATHLEN);
d517 2
a518 2
	(void)strncat(rawbuf, "/r", MAXPATHLEN - 1 - strlen(rawbuf));
	(void)strncat(rawbuf, dp + 1, MAXPATHLEN - 1 - strlen(rawbuf));
@


1.9
log
@Now uses "wall -g" so no need to be setgid tty.  This makes $RSH work.
Also fix buf oflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1996/09/01 15:31:02 deraadt Exp $	*/
a91 1
gid_t	gid, egid;	/* real, effective gid */
a109 4

	gid = getgid();
	egid = getegid();
	setegid(gid);
@


1.8
log
@kill setuid, fix setgid hole
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1996/08/10 22:26:47 deraadt Exp $	*/
a268 1
	set_operators();	/* /etc/group snarfed */
@


1.7
log
@silence warning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1996/08/02 10:29:10 deraadt Exp $	*/
d92 1
a92 2
uid_t	uid;		/* real uid */
uid_t	euid;		/* effective uid */
d112 3
a114 3
	uid = getuid();
	euid = geteuid();
	(void) seteuid(uid);
a252 1
	(void) setuid(uid); /* rmthost() is the only reason to be setuid */
@


1.6
log
@kill extra DUMP: message
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/08/02 10:26:48 deraadt Exp $	*/
d597 2
a598 1
	while (*nargv++ = *argv++);
@


1.5
log
@mostly harmless buffer overflow
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d443 1
a443 1
		msg("DUMP: %ld tape blocks\n",spcl.c_tapea);
d445 1
a445 1
		msg("DUMP: %ld tape blocks on %d volume%s\n",
@


1.4
log
@From NetBSD: Merge of 960317
@
text
@d522 1
a522 1
	(void)strcpy(rawbuf, cp);
d524 2
a525 2
	(void)strcat(rawbuf, "/r");
	(void)strcat(rawbuf, dp + 1);
@


1.3
log
@From NetBSD:
support $TAPE.  update manual to reflect reality (#1937 from Matthew Green).
@
text
@d1 2
a2 1
/*	$NetBSD: main.c,v 1.7 1996/02/05 23:59:40 mrg Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.7 1996/02/05 23:59:40 mrg Exp $";
d92 2
d113 4
d254 1
a254 1
	(void)setuid(getuid()); /* rmthost() is the only reason to be setuid */
@


1.2
log
@correct typo pointed out by chuck (in the prettiest way possible
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.6 1995/03/18 14:55:02 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: main.c,v 1.6 1995/03/18 14:55:02 cgd Exp $";
d114 2
a115 1
	tape = _PATH_DEFTAPE;
@


1.1
log
@Initial revision
@
text
@d437 3
a439 2
		msg("DUMP: %ld tape blocks on %d volumes(s)\n",
		    spcl.c_tapea, spcl.c_volume);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
