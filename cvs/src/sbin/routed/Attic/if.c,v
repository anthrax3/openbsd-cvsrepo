head	1.9;
access;
symbols
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.20
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.18
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	mickey:1.1.1.2
	SGI082896:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2008.05.07.11.55.20;	author claudio;	state dead;
branches;
next	1.8;

1.8
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.08.14.00.24;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	97.07.30.23.28.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.30.22.24.41;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.02.06.51.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.05.14.31.21;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.05.13.58.48;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.9
log
@RIP routed.

You were a nice thing in the 4.2BSD times but now it is time for you to go.
Superseded by the shiny privseped ripd that does not have the evil habit to
use kernel internals in userland.

OK everybody in the onsen 'cause it unbreaks the tree
@
text
@/*	$OpenBSD: if.c,v 1.8 2003/06/02 20:06:17 millert Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint)
static char sccsid[] = "@@(#)if.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: if.c,v 1.8 2003/06/02 20:06:17 millert Exp $";
#endif

#include "defs.h"
#include "pathnames.h"

struct	interface *ifnet;		/* all interfaces */
int	tot_interfaces;			/* # of remote and local interfaces */
int	rip_interfaces;			/* # of interfaces doing RIP */
int	foundloopback;			/* valid flag for loopaddr */
naddr	loopaddr;			/* our address on loopback */

struct timeval ifinit_timer;

int	have_ripv1_out;			/* have a RIPv1 interface */
int	have_ripv1_in;


/* Find the interface with an address
 */
struct interface *
ifwithaddr(naddr addr,
	   int	bcast,			/* notice IFF_BROADCAST address */
	   int	remote)			/* include IS_REMOTE interfaces */
{
	struct interface *ifp, *possible = 0;

	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if (ifp->int_addr == addr
		    || ((ifp->int_if_flags & IFF_BROADCAST)
			&& ifp->int_brdaddr == addr
			&& bcast)) {
			if ((ifp->int_state & IS_REMOTE) && !remote)
				continue;

			if (!(ifp->int_state & IS_BROKE)
			    && !(ifp->int_state & IS_PASSIVE))
				return ifp;

			possible = ifp;
		}
	}

	return possible;
}


/* find the interface with a name
 */
struct interface *
ifwithname(char *name,			/* "ec0" or whatever */
	   naddr addr)			/* 0 or network address */
{
	struct interface *ifp;


	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (!strcmp(ifp->int_name, name)
		    && (ifp->int_addr == addr
			|| (addr == 0 && !(ifp->int_state & IS_ALIAS))))
			return ifp;
	}
	return 0;
}


struct interface *
ifwithindex(u_short index)
{
	struct interface *ifp;


	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_index == index)
			return ifp;
	}
	return 0;
}


/* Find an interface from which the specified address
 * should have come from.  Used for figuring out which
 * interface a packet came in on -- for tracing.
 */
struct interface *
iflookup(naddr addr)
{
	struct interface *ifp, *maybe;

	maybe = 0;
	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			if (ifp->int_dstaddr == addr)
				/* finished with a match */
				return ifp;

		} else {
			/* finished with an exact match */
			if (ifp->int_addr == addr)
				return ifp;
			if ((ifp->int_if_flags & IFF_BROADCAST)
			    && ifp->int_brdaddr == addr)
				return ifp;

			/* Look for the longest approximate match.
			 */
			if (on_net(addr, ifp->int_net, ifp->int_mask)
			    && (maybe == 0
				|| ifp->int_mask > maybe->int_mask))
				maybe = ifp;
		}
	}

	return maybe;
}


/* Return the classical netmask for an IP address.
 */
naddr
std_mask(naddr addr)			/* in network order */
{
	NTOHL(addr);			/* was a host, not a network */

	if (addr == 0)			/* default route has mask 0 */
		return 0;
	if (IN_CLASSA(addr))
		return IN_CLASSA_NET;
	if (IN_CLASSB(addr))
		return IN_CLASSB_NET;
	return IN_CLASSC_NET;
}


/* Find the netmask that would be inferred by RIPv1 listeners
 *	on the given interface for a given network.
 *	If no interface is specified, look for the best fitting	interface.
 */
naddr
ripv1_mask_net(naddr addr,		/* in network byte order */
	       struct interface *ifp)	/* as seen on this interface */
{
	naddr mask = 0;

	if (addr == 0)			/* default always has 0 mask */
		return mask;

	if (ifp != 0) {
		/* If the target network is that of the associated interface
		 * on which it arrived, then use the netmask of the interface.
		 */
		if (on_net(addr, ifp->int_net, ifp->int_std_mask))
			mask = ifp->int_ripv1_mask;

	} else {
		/* Examine all interfaces, and if it the target seems
		 * to have the same network number of an interface, use the
		 * netmask of that interface.  If there is more than one
		 * such interface, prefer the interface with the longest
		 * match.
		 */
		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (on_net(addr, ifp->int_std_net, ifp->int_std_mask)
			    && ifp->int_ripv1_mask > mask)
				mask = ifp->int_ripv1_mask;
		}
	}

	/* Otherwise, make the classic A/B/C guess.
	 */
	if (mask == 0)
		mask = std_mask(addr);

	return mask;
}


naddr
ripv1_mask_host(naddr addr,		/* in network byte order */
		struct interface *ifp)	/* as seen on this interface */
{
	naddr mask = ripv1_mask_net(addr, ifp);


	/* If the computed netmask does not mask the address,
	 * then assume it is a host address
	 */
	if ((ntohl(addr) & ~mask) != 0)
		mask = HOST_MASK;
	return mask;
}


/* See if a IP address looks reasonable as a destination
 */
int					/* 0=bad */
check_dst(naddr addr)
{
	NTOHL(addr);

	if (IN_CLASSA(addr)) {
		if (addr == 0)
			return 1;	/* default */

		addr >>= IN_CLASSA_NSHIFT;
		return (addr != 0 && addr != IN_LOOPBACKNET);
	}

	return (IN_CLASSB(addr) || IN_CLASSC(addr));
}


/* Delete an interface.
 */
static void
ifdel(struct interface *ifp)
{
	struct ip_mreq m;
	struct interface *ifp1;


	trace_if("Del", ifp);

	ifp->int_state |= IS_BROKE;

	/* unlink the interface
	 */
	if (rip_sock_mcast == ifp)
		rip_sock_mcast = 0;
	if (ifp->int_next != 0)
		ifp->int_next->int_prev = ifp->int_prev;
	if (ifp->int_prev != 0)
		ifp->int_prev->int_next = ifp->int_next;
	else
		ifnet = ifp->int_next;

	if (!(ifp->int_state & IS_ALIAS)) {
		/* delete aliases
		 */
		for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
			if (ifp1 != ifp
			    && !strcmp(ifp->int_name, ifp1->int_name))
				ifdel(ifp1);
		}

		if ((ifp->int_if_flags & IFF_MULTICAST)
#ifdef MCAST_PPP_BUG
		    && !(ifp->int_if_flags & IFF_POINTOPOINT)
#endif
		    && rip_sock >= 0) {
			m.imr_multiaddr.s_addr = htonl(INADDR_RIP_GROUP);
			m.imr_interface.s_addr = ((ifp->int_if_flags
						   & IFF_POINTOPOINT)
						  ? ifp->int_dstaddr
						  : ifp->int_addr);
			if (setsockopt(rip_sock,IPPROTO_IP,IP_DROP_MEMBERSHIP,
				       &m, sizeof(m)) < 0
			    && errno != EADDRNOTAVAIL
			    && !TRACEACTIONS)
				LOGERR("setsockopt(IP_DROP_MEMBERSHIP RIP)");
		}
		if (ifp->int_rip_sock >= 0) {
			(void)close(ifp->int_rip_sock);
			ifp->int_rip_sock = -1;
			fix_select();
		}

		tot_interfaces--;
		if (!IS_RIP_OFF(ifp->int_state))
			rip_interfaces--;

		/* Zap all routes associated with this interface.
		 * Assume routes just using gateways beyond this interface will
		 * timeout naturally, and have probably already died.
		 */
		(void)rn_walktree(rhead, walk_bad, 0);

		set_rdisc_mg(ifp, 0);
		if_bad_rdisc(ifp);
	}

	free(ifp);
}


/* Mark an interface ill.
 */
void
if_sick(struct interface *ifp)
{
	if (0 == (ifp->int_state & (IS_SICK | IS_BROKE))) {
		ifp->int_state |= IS_SICK;
		trace_if("Chg", ifp);

		LIM_SEC(ifinit_timer, now.tv_sec+CHECK_BAD_INTERVAL);
	}
}


/* Mark an interface dead.
 */
void
if_bad(struct interface *ifp)
{
	struct interface *ifp1;


	if (ifp->int_state & IS_BROKE)
		return;

	LIM_SEC(ifinit_timer, now.tv_sec+CHECK_BAD_INTERVAL);

	ifp->int_state |= (IS_BROKE | IS_SICK);
	ifp->int_state &= ~(IS_RIP_QUERIED | IS_ACTIVE);
	ifp->int_data.ts = 0;

	trace_if("Chg", ifp);

	if (!(ifp->int_state & IS_ALIAS)) {
		for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
			if (ifp1 != ifp
			    && !strcmp(ifp->int_name, ifp1->int_name))
				if_bad(ifp1);
		}
		(void)rn_walktree(rhead, walk_bad, 0);
		if_bad_rdisc(ifp);
	}
}


/* Mark an interface alive
 */
int					/* 1=it was dead */
if_ok(struct interface *ifp,
      char *type)
{
	struct interface *ifp1;


	if (!(ifp->int_state & IS_BROKE)) {
		if (ifp->int_state & IS_SICK) {
			trace_act("%sinterface %s to %s working better\n",
				  type,
				  ifp->int_name, naddr_ntoa(ifp->int_addr));
			ifp->int_state &= ~IS_SICK;
		}
		return 0;
	}

	msglog("%sinterface %s to %s restored",
	       type, ifp->int_name, naddr_ntoa(ifp->int_addr));
	ifp->int_state &= ~(IS_BROKE | IS_SICK);
	ifp->int_data.ts = 0;

	if (!(ifp->int_state & IS_ALIAS)) {
		for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
			if (ifp1 != ifp
			    && !strcmp(ifp->int_name, ifp1->int_name))
				if_ok(ifp1, type);
		}
		if_ok_rdisc(ifp);
	}
	return 1;
}


/* disassemble routing message
 */
void
rt_xaddrs(struct rt_addrinfo *info,
	  struct sockaddr *sa,
	  struct sockaddr *lim,
	  int addrs)
{
	int i;
#ifdef _HAVE_SA_LEN
	static struct sockaddr sa_zero;
#endif
#ifdef sgi
#define ROUNDUP(a) ((a) > 0 ? (1 + (((a) - 1) | (sizeof(__uint64_t) - 1))) \
		    : sizeof(__uint64_t))
#else
#define ROUNDUP(a) ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) \
		    : sizeof(long))
#endif


	bzero(info, sizeof(*info));
	info->rti_addrs = addrs;
	for (i = 0; i < RTAX_MAX && sa < lim; i++) {
		if ((addrs & (1 << i)) == 0)
			continue;
#ifdef _HAVE_SA_LEN
		info->rti_info[i] = (sa->sa_len != 0) ? sa : &sa_zero;
		sa = (struct sockaddr *)((char*)(sa)
					 + ROUNDUP(sa->sa_len));
#else
		info->rti_info[i] = sa;
		sa = (struct sockaddr *)((char*)(sa)
					 + ROUNDUP(_FAKE_SA_LEN_DST(sa)));
#endif
	}
}


/* Find the network interfaces which have configured themselves.
 *	This must be done regularly, if only for extra addresses
 *	that come and go on interfaces.
 */
void
ifinit(void)
{
	static char *sysctl_buf;
	static size_t sysctl_buf_size = 0;
	uint complaints = 0;
	static u_int prev_complaints = 0;
#	define COMP_NOT_INET	0x001
#	define COMP_WIERD	0x002
#	define COMP_NOADDR	0x004
#	define COMP_BADADDR	0x008
#	define COMP_NODST	0x010
#	define COMP_NOBADR	0x020
#	define COMP_NOMASK	0x040
#	define COMP_DUP		0x080
#	define COMP_BAD_METRIC	0x100
#	define COMP_NETMASK	0x200

	struct interface ifs, ifs0, *ifp, *ifp1;
	struct rt_entry *rt;
	size_t needed;
	int mib[6];
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam, *ifam_lim, *ifam2;
	struct sockaddr_dl *sdl;
	int in, ierr, out, oerr;
	struct intnet *intnetp;
	struct rt_addrinfo info;
#ifdef SIOCGIFMETRIC
	struct ifreq ifr;
#endif


	ifinit_timer.tv_sec = now.tv_sec + (supplier
					    ? CHECK_ACT_INTERVAL
					    : CHECK_QUIET_INTERVAL);

	/* mark all interfaces so we can get rid of thost that disappear */
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next)
		ifp->int_state &= ~(IS_CHECKED | IS_DUP);

	/* Fetch the interface list, without too many system calls
	 * since we do it repeatedly.
	 */
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;
	for (;;) {
		if ((needed = sysctl_buf_size) != 0) {
			if (sysctl(mib, 6, sysctl_buf,&needed, 0, 0) >= 0)
				break;
			if (errno != ENOMEM && errno != EFAULT)
				BADERR(1, "ifinit: get interface table");
			free(sysctl_buf);
			needed = 0;
		}
		if (sysctl(mib, 6, 0, &needed, 0, 0) < 0)
			BADERR(1,"ifinit: route-sysctl-estimate");
		sysctl_buf = rtmalloc(sysctl_buf_size = needed, "ifinit");
	}

	ifam_lim = (struct ifa_msghdr *)(sysctl_buf + needed);
	for (ifam = (struct ifa_msghdr *)sysctl_buf;
	     ifam < ifam_lim;
	     ifam = ifam2) {

		ifam2 = (struct ifa_msghdr*)((char*)ifam + ifam->ifam_msglen);

		if (ifam->ifam_type == RTM_IFINFO) {
			ifm = (struct if_msghdr *)ifam;
			/* make prototype structure for the IP aliases
			 */
			bzero(&ifs0, sizeof(ifs0));
			ifs0.int_rip_sock = -1;
			ifs0.int_index = ifm->ifm_index;
			ifs0.int_if_flags = ifm->ifm_flags;
			ifs0.int_state = IS_CHECKED;
			ifs0.int_act_time = now.tv_sec;
			ifs0.int_data.ts = now.tv_sec;
			ifs0.int_data.ipackets = ifm->ifm_data.ifi_ipackets;
			ifs0.int_data.ierrors = ifm->ifm_data.ifi_ierrors;
			ifs0.int_data.opackets = ifm->ifm_data.ifi_opackets;
			ifs0.int_data.oerrors = ifm->ifm_data.ifi_oerrors;
#ifdef sgi
			ifs0.int_data.odrops = ifm->ifm_data.ifi_odrops;
#endif
			sdl = (struct sockaddr_dl *)(ifm + 1);
			sdl->sdl_data[sdl->sdl_nlen] = 0;
			continue;
		}
		if (ifam->ifam_type != RTM_NEWADDR) {
			logbad(1,"ifinit: out of sync");
			continue;
		}

		rt_xaddrs(&info, (struct sockaddr *)(ifam+1),
			  (struct sockaddr *)ifam2,
			  ifam->ifam_addrs);

		if (INFO_IFA(&info) == 0) {
			if (iff_alive(ifs.int_if_flags)) {
				if (!(prev_complaints & COMP_NOADDR))
					msglog("%s has no address",
					       sdl->sdl_data);
				complaints |= COMP_NOADDR;
			}
			continue;
		}
		if (INFO_IFA(&info)->sa_family != AF_INET) {
			if (iff_alive(ifs.int_if_flags)) {
				if (!(prev_complaints & COMP_NOT_INET))
					trace_act("%s: not AF_INET\n",
						  sdl->sdl_data);
				complaints |= COMP_NOT_INET;
			}
			continue;
		}

		bcopy(&ifs0, &ifs, sizeof(ifs0));
		ifs0.int_state |= IS_ALIAS;	/* next will be an alias */

		ifs.int_addr = S_ADDR(INFO_IFA(&info));

		if (ntohl(ifs.int_addr)>>24 == 0
		    || ntohl(ifs.int_addr)>>24 == 0xff) {
			if (iff_alive(ifs.int_if_flags)) {
				if (!(prev_complaints & COMP_BADADDR))
					msglog("%s has a bad address",
					       sdl->sdl_data);
				complaints |= COMP_BADADDR;
			}
			continue;
		}

		if (ifs.int_if_flags & IFF_BROADCAST) {
			if (INFO_MASK(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOMASK))
						msglog("%s has no netmask",
						       sdl->sdl_data);
					complaints |= COMP_NOMASK;
				}
				continue;
			}
			ifs.int_dstaddr = ifs.int_addr;
			ifs.int_mask = ntohl(S_ADDR(INFO_MASK(&info)));
			ifs.int_ripv1_mask = ifs.int_mask;
			ifs.int_net = ntohl(ifs.int_addr) & ifs.int_mask;
			ifs.int_std_mask = std_mask(ifs.int_addr);
			if (ifs.int_mask != ifs.int_std_mask)
				ifs.int_state |= IS_SUBNET;

			if (INFO_BRD(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOBADR))
						msglog("%s has no"
						       " broadcast address",
						       sdl->sdl_data);
					complaints |= COMP_NOBADR;
				}
				continue;
			}
			ifs.int_brdaddr = S_ADDR(INFO_BRD(&info));

		} else if (ifs.int_if_flags & IFF_POINTOPOINT) {
			if (INFO_BRD(&info) == 0
			    || INFO_BRD(&info)->sa_family != AF_INET) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NODST))
						msglog("%s has a bad"
						       " destination address",
						       sdl->sdl_data);
					complaints |= COMP_NODST;
				}
				continue;
			}
			ifs.int_dstaddr = S_ADDR(INFO_BRD(&info));
			if (ntohl(ifs.int_dstaddr)>>24 == 0
			    || ntohl(ifs.int_dstaddr)>>24 == 0xff) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NODST))
						msglog("%s has a bad"
						       " destination address",
						       sdl->sdl_data);
					complaints |= COMP_NODST;
				}
				continue;
			}
			ifs.int_mask = HOST_MASK;
			ifs.int_ripv1_mask = ntohl(S_ADDR(INFO_MASK(&info)));
			ifs.int_net = ntohl(ifs.int_dstaddr);
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);

		} else if (ifs.int_if_flags & IFF_LOOPBACK) {
			ifs.int_state |= IS_PASSIVE | IS_NO_RIP;
			ifs.int_dstaddr = ifs.int_addr;
			ifs.int_mask = HOST_MASK;
			ifs.int_ripv1_mask = HOST_MASK;
			ifs.int_net = ntohl(ifs.int_dstaddr);
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);
			if (!foundloopback) {
				foundloopback = 1;
				loopaddr = ifs.int_addr;
			}

		} else {
			if (!(prev_complaints & COMP_WIERD))
				trace_act("%s is neither broadcast"
					  " nor point-to-point nor loopback",
					  sdl->sdl_data);
			complaints |= COMP_WIERD;
			continue;
		}
		ifs.int_std_net = ifs.int_net & ifs.int_std_mask;
		ifs.int_std_addr = htonl(ifs.int_std_net);

		/* Use a minimum metric of one.  Treat the interface metric
		 * (default 0) as an increment to the hop count of one.
		 *
		 * The metric obtained from the routing socket dump of
		 * interface addresses is wrong.  It is not set by the
		 * SIOCSIFMETRIC ioctl.
		 */
#ifdef SIOCGIFMETRIC
		strncpy(ifr.ifr_name, sdl->sdl_data, sizeof(ifr.ifr_name));
		if (ioctl(rt_sock, SIOCGIFMETRIC, &ifr) < 0) {
			DBGERR(1, "ioctl(SIOCGIFMETRIC)");
			ifs.int_metric = 0;
		} else {
			ifs.int_metric = ifr.ifr_metric;
		}
#else
		ifs.int_metric = ifam->ifam_metric;
#endif
		if (ifs.int_metric > HOPCNT_INFINITY) {
			ifs.int_metric = 0;
			if (!(prev_complaints & COMP_BAD_METRIC)
			    && iff_alive(ifs.int_if_flags)) {
				complaints |= COMP_BAD_METRIC;
				msglog("%s has a metric of %d",
				       sdl->sdl_data, ifs.int_metric);
			}
		}

		/* See if this is a familiar interface.
		 * If so, stop worrying about it if it is the same.
		 * Start it over if it now is to somewhere else, as happens
		 * frequently with PPP and SLIP.
		 */
		ifp = ifwithname(sdl->sdl_data, ((ifs.int_state & IS_ALIAS)
						 ? ifs.int_addr
						 : 0));
		if (ifp != 0) {
			ifp->int_state |= IS_CHECKED;

			if (0 != ((ifp->int_if_flags ^ ifs.int_if_flags)
				  & (IFF_BROADCAST
				     | IFF_LOOPBACK
				     | IFF_POINTOPOINT
				     | IFF_MULTICAST))
			    || 0 != ((ifp->int_state ^ ifs.int_state)
				     & IS_ALIAS)
			    || ifp->int_addr != ifs.int_addr
			    || ifp->int_brdaddr != ifs.int_brdaddr
			    || ifp->int_dstaddr != ifs.int_dstaddr
			    || ifp->int_mask != ifs.int_mask
			    || ifp->int_metric != ifs.int_metric) {
				/* Forget old information about
				 * a changed interface.
				 */
				trace_act("interface %s has changed\n",
					  ifp->int_name);
				ifdel(ifp);
				ifp = 0;
			}
		}

		if (ifp != 0) {
			/* The primary representative of an alias worries
			 * about how things are working.
			 */
			if (ifp->int_state & IS_ALIAS)
				continue;

			/* note interfaces that have been turned off
			 */
			if (!iff_alive(ifs.int_if_flags)) {
				if (iff_alive(ifp->int_if_flags)) {
					msglog("interface %s to %s turned off",
					       ifp->int_name,
					       naddr_ntoa(ifp->int_addr));
					if_bad(ifp);
					ifp->int_if_flags &= ~IFF_UP_RUNNING;
				}
				continue;
			}
			/* or that were off and are now ok */
			if (!iff_alive(ifp->int_if_flags)) {
				ifp->int_if_flags |= IFF_UP_RUNNING;
				(void)if_ok(ifp, "");
			}

			/* If it has been long enough,
			 * see if the interface is broken.
			 */
			if (now.tv_sec < ifp->int_data.ts+CHECK_BAD_INTERVAL)
				continue;

			in = ifs.int_data.ipackets - ifp->int_data.ipackets;
			ierr = ifs.int_data.ierrors - ifp->int_data.ierrors;
			out = ifs.int_data.opackets - ifp->int_data.opackets;
			oerr = ifs.int_data.oerrors - ifp->int_data.oerrors;
#ifdef sgi
			/* Through at least IRIX 6.2, PPP and SLIP
			 * count packets dropped by  the filters.
			 * But FDDI rings stuck non-operational count
			 * dropped packets as they wait for improvement.
			 */
			if (!(ifp->int_if_flags & IFF_POINTOPOINT))
				oerr += (ifs.int_data.odrops
					 - ifp->int_data.odrops);
#endif
			/* If the interface just awoke, restart the counters.
			 */
			if (ifp->int_data.ts == 0) {
				ifp->int_data = ifs.int_data;
				continue;
			}
			ifp->int_data = ifs.int_data;

			/* Withhold judgement when the short error
			 * counters wrap or the interface is reset.
			 */
			if (ierr < 0 || in < 0 || oerr < 0 || out < 0) {
				LIM_SEC(ifinit_timer,
					now.tv_sec+CHECK_BAD_INTERVAL);
				continue;
			}

			/* Withhold judgement when there is no traffic
			 */
			if (in == 0 && out == 0 && ierr == 0 && oerr == 0)
				continue;

			/* It is bad if input or output is not working.
			 * Require presistent problems before marking it dead.
			 */
			if ((in <= ierr && ierr > 0)
			    || (out <= oerr && oerr > 0)) {
				if (!(ifp->int_state & IS_SICK)) {
					trace_act("interface %s to %s"
						  " sick: in=%d ierr=%d"
						  " out=%d oerr=%d\n",
						  ifp->int_name,
						  naddr_ntoa(ifp->int_addr),
						  in, ierr, out, oerr);
					if_sick(ifp);
					continue;
				}
				if (!(ifp->int_state & IS_BROKE)) {
					msglog("interface %s to %s bad:"
					       " in=%d ierr=%d out=%d oerr=%d",
					       ifp->int_name,
					       naddr_ntoa(ifp->int_addr),
					       in, ierr, out, oerr);
					if_bad(ifp);
				}
				continue;
			}

			/* otherwise, it is active and healthy
			 */
			ifp->int_act_time = now.tv_sec;
			(void)if_ok(ifp, "");
			continue;
		}

		/* This is a new interface.
		 * If it is dead, forget it.
		 */
		if (!iff_alive(ifs.int_if_flags))
			continue;

		/* See if it duplicates an existing interface.
		 */
		for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_mask != ifs.int_mask)
				continue;
			if (((ifp->int_addr != ifs.int_addr
			      && ifs.int_mask != HOST_MASK)
			     || (ifp->int_dstaddr != ifs.int_dstaddr
				 && ifs.int_mask == HOST_MASK)))
				continue;
			if (!iff_alive(ifp->int_if_flags))
				continue;
			/* Let one of our real interfaces be marked
			 * passive.
			 */
			if ((ifp->int_state & IS_PASSIVE)
			    && !(ifp->int_state & IS_EXTERNAL))
				continue;

			/* It does duplicate an existing interface,
			 * so complain about it, mark the other one
			 * duplicated, and for get this one.
			 */
			if (!(prev_complaints & COMP_DUP)) {
				complaints |= COMP_DUP;
				msglog("%s is duplicated by %s at %s",
				       sdl->sdl_data, ifp->int_name,
				       naddr_ntoa(ifp->int_addr));
			}
			ifp->int_state |= IS_DUP;
			break;
		}
		if (ifp != 0)
			continue;

		/* It is new and ok.  So make it real
		 */
		strncpy(ifs.int_name, sdl->sdl_data,
			MIN(sizeof(ifs.int_name)-1, sdl->sdl_nlen));
		get_parms(&ifs);

		/* Add it to the list of interfaces
		 */
		ifp = (struct interface *)rtmalloc(sizeof(*ifp), "ifinit");
		bcopy(&ifs, ifp, sizeof(*ifp));
		if (ifnet != 0) {
			ifp->int_next = ifnet;
			ifnet->int_prev = ifp;
		}
		ifnet = ifp;
		trace_if("Add", ifp);

		/* Notice likely bad netmask.
		 */
		if (!(prev_complaints & COMP_NETMASK)
		    && !(ifp->int_if_flags & IFF_POINTOPOINT)) {
			for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
				if (ifp1->int_mask == ifp->int_mask)
					continue;
				if (ifp1->int_if_flags & IFF_POINTOPOINT)
					continue;
				if (on_net(ifp->int_addr,
					   ifp1->int_net, ifp1->int_mask)
				    || on_net(ifp1->int_addr,
					      ifp->int_net, ifp->int_mask)) {
					msglog("possible netmask problem"
					       " betwen %s:%s and %s:%s",
					       ifp->int_name,
					       addrname(htonl(ifp->int_net),
							ifp->int_mask, 1),
					       ifp1->int_name,
					       addrname(htonl(ifp1->int_net),
							ifp1->int_mask, 1));
					complaints |= COMP_NETMASK;
				}
			}
		}

		/* Count the # of directly connected networks.
		 */
		if (!(ifp->int_state & IS_ALIAS)) {
			if (!(ifp->int_if_flags & IFF_LOOPBACK))
				tot_interfaces++;
			if (!IS_RIP_OFF(ifp->int_state))
				rip_interfaces++;
		}

		if_ok_rdisc(ifp);
		rip_on(ifp);
	}

	/* If we are multi-homed and have at least one interface
	 * listening to RIP, then output by default.
	 */
	if (!supplier_set && rip_interfaces > 1)
		set_supplier();

	/* If we are multi-homed, optionally advertise a route to
	 * our main address.
	 */
	if (advertise_mhome
	    || (tot_interfaces > 1
		&& mhome
		&& (ifp = ifwithaddr(myaddr, 0, 0)) != 0
		&& foundloopback)) {
		advertise_mhome = 1;
		rt = rtget(myaddr, HOST_MASK);
		if (rt != 0) {
			if (rt->rt_ifp != ifp
			    || rt->rt_router != loopaddr) {
				rtdelete(rt);
				rt = 0;
			} else {
				rtchange(rt, rt->rt_state | RS_MHOME,
					 loopaddr, loopaddr,
					 0, 0, ifp, rt->rt_time, 0);
			}
		}
		if (rt == 0)
			rtadd(myaddr, HOST_MASK, loopaddr, loopaddr,
			      0, 0, RS_MHOME, ifp);
	}

	for (ifp = ifnet; ifp != 0; ifp = ifp1) {
		ifp1 = ifp->int_next;	/* because we may delete it */

		/* Forget any interfaces that have disappeared.
		 */
		if (!(ifp->int_state & (IS_CHECKED | IS_REMOTE))) {
			trace_act("interface %s has disappeared\n",
				  ifp->int_name);
			ifdel(ifp);
			continue;
		}

		if ((ifp->int_state & IS_BROKE)
		    && !(ifp->int_state & IS_PASSIVE))
			LIM_SEC(ifinit_timer, now.tv_sec+CHECK_BAD_INTERVAL);

		/* If we ever have a RIPv1 interface, assume we always will.
		 * It might come back if it ever goes away.
		 */
		if (!(ifp->int_state & IS_NO_RIPV1_OUT) && supplier)
			have_ripv1_out = 1;
		if (!(ifp->int_state & IS_NO_RIPV1_IN))
			have_ripv1_in = 1;
	}

	for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
		/* Ensure there is always a network route for interfaces,
		 * after any dead interfaces have been deleted, which
		 * might affect routes for point-to-point links.
		 */
		addrouteforif(ifp);

		/* Add routes to the local end of point-to-point interfaces
		 * using loopback.
		 */
		if ((ifp->int_if_flags & IFF_POINTOPOINT)
		    && !(ifp->int_state & IS_REMOTE)
		    && foundloopback) {
			/* Delete any routes to the network address through
			 * foreign routers. Remove even static routes.
			 */
			del_static(ifp->int_addr, HOST_MASK, 0);
			rt = rtget(ifp->int_addr, HOST_MASK);
			if (rt != 0 && rt->rt_router != loopaddr) {
				rtdelete(rt);
				rt = 0;
			}
			if (rt != 0) {
				if (!(rt->rt_state & RS_LOCAL)
				    || rt->rt_metric > ifp->int_metric) {
					ifp1 = ifp;
				} else {
					ifp1 = rt->rt_ifp;
				}
				rtchange(rt,((rt->rt_state & ~RS_NET_SYN)
					     | (RS_IF|RS_LOCAL)),
					 loopaddr, loopaddr,
					 0, 0, ifp1, rt->rt_time, 0);
			} else {
				rtadd(ifp->int_addr, HOST_MASK,
				      loopaddr, loopaddr,
				      0, 0, (RS_IF | RS_LOCAL), ifp);
			}
		}
	}

	/* add the authority routes */
	for (intnetp = intnets; intnetp!=0; intnetp = intnetp->intnet_next) {
		rt = rtget(intnetp->intnet_addr, intnetp->intnet_mask);
		if (rt != 0
		    && !(rt->rt_state & RS_NO_NET_SYN)
		    && !(rt->rt_state & RS_NET_INT)) {
			rtdelete(rt);
			rt = 0;
		}
		if (rt == 0)
			rtadd(intnetp->intnet_addr, intnetp->intnet_mask,
			      loopaddr, loopaddr, intnetp->intnet_metric-1,
			      0, RS_NET_SYN | RS_NET_INT, 0);
	}

	prev_complaints = complaints;
}


static void
check_net_syn(struct interface *ifp)
{
	struct rt_entry *rt;


	/* Turn on the need to automatically synthesize a network route
	 * for this interface only if we are running RIPv1 on some other
	 * interface that is on a different class-A,B,or C network.
	 */
	if (have_ripv1_out || have_ripv1_in) {
		ifp->int_state |= IS_NEED_NET_SYN;
		rt = rtget(ifp->int_std_addr, ifp->int_std_mask);
		if (rt != 0
		    && 0 == (rt->rt_state & RS_NO_NET_SYN)
		    && (!(rt->rt_state & RS_NET_SYN)
			|| rt->rt_metric > ifp->int_metric)) {
			rtdelete(rt);
			rt = 0;
		}
		if (rt == 0)
			rtadd(ifp->int_std_addr, ifp->int_std_mask,
			      ifp->int_addr, ifp->int_addr,
			      ifp->int_metric, 0, RS_NET_SYN, ifp);

	} else {
		ifp->int_state &= ~IS_NEED_NET_SYN;

		rt = rtget(ifp->int_std_addr,
			   ifp->int_std_mask);
		if (rt != 0
		    && (rt->rt_state & RS_NET_SYN)
		    && rt->rt_ifp == ifp)
			rtbad_sub(rt);
	}
}


/* Add route for interface if not currently installed.
 * Create route to other end if a point-to-point link,
 * otherwise a route to this (sub)network.
 */
void
addrouteforif(struct interface *ifp)
{
	struct rt_entry *rt;
	naddr dst, gate;


	/* skip sick interfaces
	 */
	if (ifp->int_state & IS_BROKE)
		return;

	/* If the interface on a subnet, then install a RIPv1 route to
	 * the network as well (unless it is sick).
	 */
	if (ifp->int_state & IS_SUBNET)
		check_net_syn(ifp);

	if (ifp->int_state & IS_REMOTE) {
		dst = ifp->int_addr;
		gate = ifp->int_dstaddr;
		/* If we are going to send packets to the gateway,
		 * it must be reachable using our physical interfaces
		 */
		if (!(ifp->int_state & IS_EXTERNAL)
		    && !rtfind(ifp->int_dstaddr)
		    && ifp->int_transitions == 0) {
			msglog("unreachable gateway %s in "
			       _PATH_GATEWAYS" entry %s",
			       naddr_ntoa(gate), ifp->int_name);
			return;
		}

	} else {
		dst = (0 != (ifp->int_if_flags & (IFF_POINTOPOINT
						  | IFF_LOOPBACK))
		       ? ifp->int_dstaddr
		       : htonl(ifp->int_net));
		gate = ifp->int_addr;
	}

	/* We are finished if the correct main interface route exists.
	 * The right route must be for the right interface, not synthesized
	 * from a subnet, be a "gateway" or not as appropriate, and so forth.
	 */
	del_static(dst, ifp->int_mask, 0);
	rt = rtget(dst, ifp->int_mask);
	if (rt != 0) {
		if ((rt->rt_ifp != ifp
		     || rt->rt_router != ifp->int_addr)
		    && (!(ifp->int_state & IS_DUP)
			|| rt->rt_ifp == 0
			|| (rt->rt_ifp->int_state & IS_BROKE))) {
			rtdelete(rt);
			rt = 0;
		} else {
			rtchange(rt, ((rt->rt_state | RS_IF)
				      & ~(RS_NET_SYN | RS_LOCAL)),
				 ifp->int_addr, ifp->int_addr,
				 ifp->int_metric, 0, ifp, now.tv_sec, 0);
		}
	}
	if (rt == 0) {
		if (ifp->int_transitions++ > 0)
			trace_act("re-install interface %s\n",
				  ifp->int_name);

		rtadd(dst, ifp->int_mask, gate, gate,
		      ifp->int_metric, 0, RS_IF, ifp);
	}
}
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.7 2002/08/08 14:00:24 aaron Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: if.c,v 1.7 2002/08/08 14:00:24 aaron Exp $";
@


1.7
log
@Use & to test if bits are set, not &&; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.6 1997/07/30 23:28:40 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
static char rcsid[] = "$OpenBSD: if.c,v 1.6 1997/07/30 23:28:40 deraadt Exp $";
@


1.6
log
@new routed DOES NOT EVEN COMPILE LET ALONE WORK.  TEST YOUR WORK!
Also, put back the damn security check in input.c that has been deleted
TWO SEPERATE TIMES NOW!  I CURSE anyone who deletes that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.4 1996/10/02 06:51:43 mickey Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: if.c,v 1.4 1996/10/02 06:51:43 mickey Exp $";
d1108 1
a1108 1
		if (!(ifp->int_state && IS_EXTERNAL)
@


1.5
log
@update to sgi-02apr97
still have problems w/ defaults from pppd
@
text
@d45 1
a45 24
struct interface *ifnet;		/* all interfaces */

/* hash table for all interfaces, big enough to tolerate ridiculous
 * numbers of IP aliases.  Crazy numbers of aliases such as 7000
 * still will not do well, but not just in looking up interfaces
 * by name or address.
 */
#define AHASH_LEN 211			/* must be prime */
#define AHASH(a) &ahash_tbl[(a)%AHASH_LEN]
struct interface *ahash_tbl[AHASH_LEN];

#define BHASH_LEN 211			/* must be prime */
#define BHASH(a) &bhash_tbl[(a)%BHASH_LEN]
struct interface *bhash_tbl[BHASH_LEN];

struct interface *remote_if;		/* remote interfaces */

/* hash for physical interface names.
 * Assume there are never more 100 or 200 real interfaces, and that
 * aliases are put on the end of the hash chains.
 */
#define NHASH_LEN 97
struct interface *nhash_tbl[NHASH_LEN];

a51 1
static struct timeval last_ifinit;
a56 61
static struct interface**
nhash(register char *p)
{
	register u_int i;

	for (i = 0; *p != '\0'; p++) {
		i = ((i<<1) & 0x7fffffff) | ((i>>31) & 1);
		i ^= *p;
	}
	return &nhash_tbl[i % NHASH_LEN];
}


/* Link a new interface into the lists and hash tables.
 */
void
if_link(struct interface *ifp)
{
	struct interface **hifp;

	ifp->int_prev = &ifnet;
	ifp->int_next = ifnet;
	if (ifnet != 0)
		ifnet->int_prev = &ifp->int_next;
	ifnet = ifp;

	hifp = AHASH(ifp->int_addr);
	ifp->int_ahash_prev = hifp;
	if ((ifp->int_ahash = *hifp) != 0)
		(*hifp)->int_ahash_prev = &ifp->int_ahash;
	*hifp = ifp;

	if (ifp->int_if_flags & IFF_BROADCAST) {
		hifp = BHASH(ifp->int_brdaddr);
		ifp->int_bhash_prev = hifp;
		if ((ifp->int_bhash = *hifp) != 0)
			(*hifp)->int_bhash_prev = &ifp->int_bhash;
		*hifp = ifp;
	}

	if (ifp->int_state & IS_REMOTE) {
		ifp->int_rlink_prev = &remote_if;
		ifp->int_rlink = remote_if;
		if (remote_if != 0)
			remote_if->int_rlink_prev = &ifp->int_rlink;
		remote_if = ifp;
	}

	hifp = nhash(ifp->int_name);
	if (ifp->int_state & IS_ALIAS) {
		/* put aliases on the end of the hash chain */
		while (*hifp != 0)
			hifp = &(*hifp)->int_nhash;
	}
	ifp->int_nhash_prev = hifp;
	if ((ifp->int_nhash = *hifp) != 0)
		(*hifp)->int_nhash_prev = &ifp->int_nhash;
	*hifp = ifp;
}


d66 7
a72 1
	remote = (remote == 0) ? IS_REMOTE : 0;
d74 3
a76 9
	for (ifp = *AHASH(addr); ifp; ifp = ifp->int_ahash) {
		if (ifp->int_addr != addr)
			continue;
		if ((ifp->int_state & remote) != 0)
			continue;
		if ((ifp->int_state & (IS_BROKE | IS_PASSIVE)) == 0)
			return ifp;
		possible = ifp;
	}
d78 2
a79 11
	if (possible || !bcast)
		return possible;

	for (ifp = *BHASH(addr); ifp; ifp = ifp->int_bhash) {
		if (ifp->int_brdaddr != addr)
			continue;
		if ((ifp->int_state & remote) != 0)
			continue;
		if ((ifp->int_state & (IS_BROKE | IS_PASSIVE)) == 0)
			return ifp;
		possible = ifp;
a93 11
	for (;;) {
		for (ifp = *nhash(name); ifp != 0; ifp = ifp->int_nhash) {
			/* If the network address is not specified,
			 * ignore any alias interfaces.  Otherwise, look
			 * for the interface with the target name and address.
			 */
			if (!strcmp(ifp->int_name, name)
			    && ((addr == 0 && !(ifp->int_state & IS_ALIAS))
				|| (ifp->int_addr == addr)))
				return ifp;
		}
d95 5
a99 7
		/* If there is no known interface, maybe there is a
		 * new interface.  So just once look for new interfaces.
		 */
		if (last_ifinit.tv_sec == now.tv_sec
		    && last_ifinit.tv_usec == now.tv_usec)
			return 0;
		ifinit();
d101 1
d106 1
a106 2
ifwithindex(u_short index,
	    int rescan_ok)
a109 5
	for (;;) {
		for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_index == index)
				return ifp;
		}
d111 3
a113 8
		/* If there is no known interface, maybe there is a
		 * new interface.  So just once look for new interfaces.
		 */
		if (!rescan_ok
		    || (last_ifinit.tv_sec == now.tv_sec
			&& last_ifinit.tv_usec == now.tv_usec))
			return 0;
		ifinit();
d115 1
d121 1
a121 1
 * interface a packet came in on.
d129 3
a131 3
	for (;;) {
		for (ifp = ifnet; ifp; ifp = ifp->int_next) {
			if (ifp->int_if_flags & IFF_POINTOPOINT) {
d133 1
a133 2
				if (ifp->int_dstaddr == addr)
					return ifp;
d135 7
a141 4
			} else {
				/* finished with an exact match */
				if (ifp->int_addr == addr)
					return ifp;
d143 6
a148 7
				/* Look for the longest approximate match.
				 */
				if (on_net(addr, ifp->int_net, ifp->int_mask)
				    && (maybe == 0
					|| ifp->int_mask > maybe->int_mask))
					maybe = ifp;
			}
d150 1
d152 1
a152 10
		if (maybe != 0
		    || (last_ifinit.tv_sec == now.tv_sec
			&& last_ifinit.tv_usec == now.tv_usec))
			return maybe;

		/* If there is no known interface, maybe there is a
		 * new interface.  So just once look for new interfaces.
		 */
		ifinit();
	}
d158 2
a159 2
naddr					/* host byte order */
std_mask(naddr addr)			/* network byte order */
a250 62
/* See a new interface duplicates an existing interface.
 */
struct interface *
check_dup(naddr addr,			/* IP address, so network byte order */
	  naddr dstaddr,		/* ditto */
	  naddr mask,			/* mask, so host byte order */
	  int if_flags)
{
	struct interface *ifp;

	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_mask != mask)
			continue;

		if (!iff_alive(ifp->int_if_flags))
			continue;

		/* The local address can only be shared with a point-to-point
		 * link.
		 */
		if (ifp->int_addr == addr
		    && (((if_flags|ifp->int_if_flags) & IFF_POINTOPOINT) == 0))
			return ifp;

		if (on_net(ifp->int_dstaddr, ntohl(dstaddr),mask))
			return ifp;
	}
	return 0;
}


/* See that a remote gateway is reachable.
 *	Note that the answer can change as real interfaces come and go.
 */
int					/* 0=bad */
check_remote(struct interface *ifp)
{
	struct rt_entry *rt;

	/* do not worry about other kinds */
	if (!(ifp->int_state & IS_REMOTE))
	    return 1;

	rt = rtfind(ifp->int_addr);
	if (rt != 0
	    && rt->rt_ifp != 0
	    &&on_net(ifp->int_addr,
		     rt->rt_ifp->int_net, rt->rt_ifp->int_mask))
		return 1;

	/* the gateway cannot be reached directly from one of our
	 * interfaces
	 */
	if (!(ifp->int_state & IS_BROKE)) {
		msglog("unreachable gateway %s in "_PATH_GATEWAYS,
		       naddr_ntoa(ifp->int_addr));
		if_bad(ifp);
	}
	return 0;
}


d266 2
a267 1
	*ifp->int_prev = ifp->int_next;
d270 4
a273 16
	*ifp->int_ahash_prev = ifp->int_ahash;
	if (ifp->int_ahash != 0)
		ifp->int_ahash->int_ahash_prev = ifp->int_ahash_prev;
	*ifp->int_nhash_prev = ifp->int_nhash;
	if (ifp->int_nhash != 0)
		ifp->int_nhash->int_nhash_prev = ifp->int_nhash_prev;
	if (ifp->int_if_flags & IFF_BROADCAST) {
		*ifp->int_bhash_prev = ifp->int_bhash;
		if (ifp->int_bhash != 0)
			ifp->int_bhash->int_bhash_prev = ifp->int_bhash_prev;
	}
	if (ifp->int_state & IS_REMOTE) {
		*ifp->int_rlink_prev = ifp->int_rlink;
		if (ifp->int_rlink != 0)
			ifp->int_rlink->int_rlink_prev = ifp->int_rlink_prev;
	}
d276 1
a276 1
		/* delete aliases when the main interface dies
a298 2
			if (rip_sock_mcast == ifp)
				rip_sock_mcast = 0;
a330 1
		ifp->int_act_time = NEVER;
d352 1
a352 2
	ifp->int_act_time = NEVER;
	ifp->int_query_time = NEVER;
d380 1
a380 1
			trace_act("%sinterface %s to %s working better",
d382 1
a382 1
				  ifp->int_name, naddr_ntoa(ifp->int_dstaddr));
d389 1
a389 1
	       type, ifp->int_name, naddr_ntoa(ifp->int_dstaddr));
a400 5

	if (ifp->int_state & IS_REMOTE) {
		if (!addrouteforif(ifp))
			return 0;
	}
d456 9
a464 8
#	define COMP_NOADDR	0x002
#	define COMP_BADADDR	0x004
#	define COMP_NODST	0x008
#	define COMP_NOBADR	0x010
#	define COMP_NOMASK	0x020
#	define COMP_DUP		0x040
#	define COMP_BAD_METRIC	0x080
#	define COMP_NETMASK	0x100
d472 1
a480 1
	last_ifinit = now;
a519 2
			struct sockaddr_dl *sdl;

a527 1
			ifs0.int_query_time = NEVER;
a538 2
			strncpy(ifs0.int_name, sdl->sdl_data,
				MIN(sizeof(ifs0.int_name), sdl->sdl_nlen));
d545 1
a549 7
		/* Prepare for the next address of this interface, which
		 * will be an alias.
		 * Do not output RIP or Router-Discovery packets via aliases.
		 */
		bcopy(&ifs0, &ifs, sizeof(ifs));
		ifs0.int_state |= (IS_ALIAS | IS_NO_RIP | IS_NO_RDISC);

d554 1
a554 1
					       ifs.int_name);
d562 2
a563 2
					trace_act("%s: not AF_INET",
						  ifs.int_name);
d569 3
d579 1
a579 1
					       ifs.int_name);
d585 10
a594 2
		if (ifs.int_if_flags & IFF_LOOPBACK) {
			ifs.int_state |= IS_PASSIVE | IS_NO_RIP | IS_NO_RDISC;
d596 16
a611 7
			ifs.int_mask = HOST_MASK;
			ifs.int_ripv1_mask = HOST_MASK;
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);
			ifs.int_net = ntohl(ifs.int_dstaddr);
			if (!foundloopback) {
				foundloopback = 1;
				loopaddr = ifs.int_addr;
d613 1
d622 1
a622 1
						       ifs.int_name);
d634 1
a634 1
						       ifs.int_name);
d641 1
d643 6
d650 4
a653 10

		}  else {
			if (INFO_MASK(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOMASK))
						msglog("%s has no netmask",
						       ifs.int_name);
					complaints |= COMP_NOMASK;
				}
				continue;
a654 7
			ifs.int_dstaddr = ifs.int_addr;
			ifs.int_mask = ntohl(S_ADDR(INFO_MASK(&info)));
			ifs.int_ripv1_mask = ifs.int_mask;
			ifs.int_std_mask = std_mask(ifs.int_addr);
			ifs.int_net = ntohl(ifs.int_addr) & ifs.int_mask;
			if (ifs.int_mask != ifs.int_std_mask)
				ifs.int_state |= IS_SUBNET;
d656 7
a662 14
			if (ifs.int_if_flags & IFF_BROADCAST) {
				if (INFO_BRD(&info) == 0) {
					if (iff_alive(ifs.int_if_flags)) {
					    if (!(prev_complaints
						  & COMP_NOBADR))
						msglog("%s has"
						       "no broadcast address",
						       ifs.int_name);
					    complaints |= COMP_NOBADR;
					}
					continue;
				}
				ifs.int_brdaddr = S_ADDR(INFO_BRD(&info));
			}
d675 1
a675 1
		strncpy(ifr.ifr_name, ifs.int_name, sizeof(ifr.ifr_name));
d691 1
a691 1
				       ifs.int_name, ifs.int_metric);
d700 3
a702 3
		ifp = ifwithname(ifs.int_name, ((ifs.int_state & IS_ALIAS)
						? ifs.int_addr
						: 0));
d721 1
a721 1
				trace_act("interface %s has changed",
d741 1
a741 1
					       naddr_ntoa(ifp->int_dstaddr));
d765 1
a765 1
			 * count packets dropped by the filters.
d803 1
a803 1
						  " out=%d oerr=%d",
d805 1
a805 1
						  naddr_ntoa(ifp->int_dstaddr),
d811 1
a811 1
					msglog("interface %s to %s broken:"
d814 1
a814 1
					       naddr_ntoa(ifp->int_dstaddr),
d834 1
a834 3
		/* If it duplicates an existing interface,
		 * complain about it, mark the other one
		 * duplicated, and forget this one.
d836 12
a847 5
		ifp = check_dup(ifs.int_addr,ifs.int_dstaddr,ifs.int_mask,
				ifs.int_if_flags);
		if (ifp != 0) {
			/* Ignore duplicates of itself, caused by having
			 * IP aliases on the same network.
d849 2
a850 1
			if (!strcmp(ifp->int_name, ifs.int_name))
d853 4
d859 3
a861 14
				msglog("%s (%s%s%s) is duplicated by"
				       " %s (%s%s%s)",
				       ifs.int_name,
				       addrname(ifs.int_addr,ifs.int_mask,1),
				       ((ifs.int_if_flags & IFF_POINTOPOINT)
					? "-->" : ""),
				       ((ifs.int_if_flags & IFF_POINTOPOINT)
					? naddr_ntoa(ifs.int_dstaddr) : ""),
				       ifp->int_name,
				       addrname(ifp->int_addr,ifp->int_mask,1),
				       ((ifp->int_if_flags & IFF_POINTOPOINT)
					? "-->" : ""),
				       ((ifp->int_if_flags & IFF_POINTOPOINT)
					? naddr_ntoa(ifp->int_dstaddr) : ""));
d864 3
a867 10
		}

		if (0 == (ifs.int_if_flags & (IFF_POINTOPOINT | IFF_BROADCAST))
		    && !(ifs.int_state & IS_PASSIVE)) {
			trace_act("%s is neither broadcast, point-to-point,"
				  " nor loopback",
				  ifs.int_name);
			if (!(ifs.int_state & IFF_MULTICAST))
				ifs.int_state |= IS_NO_RDISC;
		}
d869 5
d875 1
a875 1
		/* It is new and ok.   Add it to the list of interfaces
d879 5
a883 2
		get_parms(ifp);
		if_link(ifp);
d889 1
a889 2
		    && !(ifp->int_if_flags & IFF_POINTOPOINT)
		    && ifp->int_addr != RIP_DEFAULT) {
d895 1
a895 3
				if (ifp1->int_dstaddr == RIP_DEFAULT)
					continue;
				if (on_net(ifp->int_dstaddr,
d897 1
a897 1
				    || on_net(ifp1->int_dstaddr,
d900 1
a900 1
					       " between %s:%s and %s:%s",
d912 2
a914 2
			/* Count the # of directly connected networks.
			 */
d919 1
d921 2
a922 4
			/* turn on router discovery and RIP If needed */
			if_ok_rdisc(ifp);
			rip_on(ifp);
		}
d925 1
a925 1
	/* If we are multi-homed and have at least two interfaces
d963 1
a963 1
			trace_act("interface %s has disappeared",
d987 1
a987 2
		if (!addrouteforif(ifp))
			continue;
d1084 1
a1084 1
int					/* 0=bad interface */
d1094 1
a1094 1
		return 0;
d1102 14
a1115 4
	gate = ifp->int_addr;
	dst = (0 != (ifp->int_if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK))
	       ? ifp->int_dstaddr
	       : htonl(ifp->int_net));
d1117 7
a1123 7
	/* If we are going to send packets to the gateway,
	 * it must be reachable using our physical interfaces
	 */
	if ((ifp->int_state & IS_REMOTE)
	    && !(ifp->int_state & IS_EXTERNAL)
	    && !check_remote(ifp))
		return 0;
d1148 1
a1148 1
			trace_act("re-install interface %s",
a1153 2

	return 1;
@


1.4
log
@update to the latest version from Sep 12.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.3 1996/09/05 14:31:21 mickey Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: if.c,v 1.3 1996/09/05 14:31:21 mickey Exp $";
d45 24
a68 1
struct	interface *ifnet;		/* all interfaces */
d75 1
d81 61
d151 11
a161 7
	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if (ifp->int_addr == addr
		    || ((ifp->int_if_flags & IFF_BROADCAST)
			&& ifp->int_brdaddr == addr
			&& bcast)) {
			if ((ifp->int_state & IS_REMOTE) && !remote)
				continue;
d163 2
a164 3
			if (!(ifp->int_state & IS_BROKE)
			    && !(ifp->int_state & IS_PASSIVE))
				return ifp;
d166 8
a173 2
			possible = ifp;
		}
d188 11
d200 7
a206 5
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (!strcmp(ifp->int_name, name)
		    && (ifp->int_addr == addr
			|| (addr == 0 && !(ifp->int_state & IS_ALIAS))))
			return ifp;
a207 1
	return 0;
d212 2
a213 1
ifwithindex(u_short index)
d217 5
d223 8
a230 3
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_index == index)
			return ifp;
a231 1
	return 0;
d237 1
a237 1
 * interface a packet came in on -- for tracing.
d245 3
a247 3
	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			if (ifp->int_dstaddr == addr)
d249 2
a250 1
				return ifp;
d252 4
a255 7
		} else {
			/* finished with an exact match */
			if (ifp->int_addr == addr)
				return ifp;
			if ((ifp->int_if_flags & IFF_BROADCAST)
			    && ifp->int_brdaddr == addr)
				return ifp;
d257 7
a263 6
			/* Look for the longest approximate match.
			 */
			if (on_net(addr, ifp->int_net, ifp->int_mask)
			    && (maybe == 0
				|| ifp->int_mask > maybe->int_mask))
				maybe = ifp;
d265 10
a275 2

	return maybe;
d281 2
a282 2
naddr
std_mask(naddr addr)			/* in network order */
d374 62
d451 1
a451 2
	if (rip_sock_mcast == ifp)
		rip_sock_mcast = 0;
d454 16
a469 4
	if (ifp->int_prev != 0)
		ifp->int_prev->int_next = ifp->int_next;
	else
		ifnet = ifp->int_next;
d472 1
a472 1
		/* delete aliases
d495 2
d529 1
d551 2
a552 1
	ifp->int_state &= ~(IS_RIP_QUERIED | IS_ACTIVE);
d580 1
a580 1
			trace_act("%sinterface %s to %s working better\n",
d582 1
a582 1
				  ifp->int_name, naddr_ntoa(ifp->int_addr));
d589 1
a589 1
	       type, ifp->int_name, naddr_ntoa(ifp->int_addr));
d601 5
d661 8
a668 9
#	define COMP_WIERD	0x002
#	define COMP_NOADDR	0x004
#	define COMP_BADADDR	0x008
#	define COMP_NODST	0x010
#	define COMP_NOBADR	0x020
#	define COMP_NOMASK	0x040
#	define COMP_DUP		0x080
#	define COMP_BAD_METRIC	0x100
#	define COMP_NETMASK	0x200
a675 1
	struct sockaddr_dl *sdl;
d684 1
d724 2
d734 1
d746 2
a753 1

d758 7
d769 1
a769 1
					       sdl->sdl_data);
d777 2
a778 2
					trace_act("%s: not AF_INET\n",
						  sdl->sdl_data);
a783 3
		bcopy(&ifs0, &ifs, sizeof(ifs0));
		ifs0.int_state |= IS_ALIAS;	/* next will be an alias */

d791 1
a791 1
					       sdl->sdl_data);
d797 2
a798 10
		if (ifs.int_if_flags & IFF_BROADCAST) {
			if (INFO_MASK(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOMASK))
						msglog("%s has no netmask",
						       sdl->sdl_data);
					complaints |= COMP_NOMASK;
				}
				continue;
			}
d800 7
a806 16
			ifs.int_mask = ntohl(S_ADDR(INFO_MASK(&info)));
			ifs.int_ripv1_mask = ifs.int_mask;
			ifs.int_net = ntohl(ifs.int_addr) & ifs.int_mask;
			ifs.int_std_mask = std_mask(ifs.int_addr);
			if (ifs.int_mask != ifs.int_std_mask)
				ifs.int_state |= IS_SUBNET;

			if (INFO_BRD(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOBADR))
						msglog("%s has no"
						       " broadcast address",
						       sdl->sdl_data);
					complaints |= COMP_NOBADR;
				}
				continue;
a807 1
			ifs.int_brdaddr = S_ADDR(INFO_BRD(&info));
d816 1
a816 1
						       sdl->sdl_data);
d828 1
a828 1
						       sdl->sdl_data);
d835 1
a836 1
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);
d838 10
a847 2
		} else if (ifs.int_if_flags & IFF_LOOPBACK) {
			ifs.int_state |= IS_PASSIVE | IS_NO_RIP;
d849 20
a868 7
			ifs.int_mask = HOST_MASK;
			ifs.int_ripv1_mask = HOST_MASK;
			ifs.int_net = ntohl(ifs.int_dstaddr);
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);
			if (!foundloopback) {
				foundloopback = 1;
				loopaddr = ifs.int_addr;
a869 8

		} else {
			if (!(prev_complaints & COMP_WIERD))
				trace_act("%s is neither broadcast"
					  " nor point-to-point nor loopback",
					  sdl->sdl_data);
			complaints |= COMP_WIERD;
			continue;
d882 1
a882 1
		strncpy(ifr.ifr_name, sdl->sdl_data, sizeof(ifr.ifr_name));
d898 1
a898 1
				       sdl->sdl_data, ifs.int_metric);
d907 3
a909 3
		ifp = ifwithname(sdl->sdl_data, ((ifs.int_state & IS_ALIAS)
						 ? ifs.int_addr
						 : 0));
d928 1
a928 1
				trace_act("interface %s has changed\n",
d948 1
a948 1
					       naddr_ntoa(ifp->int_addr));
d972 1
a972 1
			 * count packets dropped by  the filters.
d1010 1
a1010 1
						  " out=%d oerr=%d\n",
d1012 1
a1012 1
						  naddr_ntoa(ifp->int_addr),
d1018 1
a1018 1
					msglog("interface %s to %s bad:"
d1021 1
a1021 1
					       naddr_ntoa(ifp->int_addr),
d1041 3
a1043 1
		/* See if it duplicates an existing interface.
d1045 5
a1049 12
		for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_mask != ifs.int_mask)
				continue;
			if (((ifp->int_addr != ifs.int_addr
			      && ifs.int_mask != HOST_MASK)
			     || (ifp->int_dstaddr != ifs.int_dstaddr
				 && ifs.int_mask == HOST_MASK)))
				continue;
			if (!iff_alive(ifp->int_if_flags))
				continue;
			/* Let one of our real interfaces be marked
			 * passive.
d1051 1
a1051 2
			if ((ifp->int_state & IS_PASSIVE)
			    && !(ifp->int_state & IS_EXTERNAL))
a1053 4
			/* It does duplicate an existing interface,
			 * so complain about it, mark the other one
			 * duplicated, and for get this one.
			 */
d1056 14
a1069 3
				msglog("%s is duplicated by %s at %s",
				       sdl->sdl_data, ifp->int_name,
				       naddr_ntoa(ifp->int_addr));
d1072 10
a1081 1
			break;
a1082 2
		if (ifp != 0)
			continue;
a1083 5
		/* It is new and ok.  So make it real
		 */
		strncpy(ifs.int_name, sdl->sdl_data,
			MIN(sizeof(ifs.int_name)-1, sdl->sdl_nlen));
		get_parms(&ifs);
d1085 1
a1085 1
		/* Add it to the list of interfaces
d1089 2
a1090 5
		if (ifnet != 0) {
			ifp->int_next = ifnet;
			ifnet->int_prev = ifp;
		}
		ifnet = ifp;
d1096 2
a1097 1
		    && !(ifp->int_if_flags & IFF_POINTOPOINT)) {
d1103 3
a1105 1
				if (on_net(ifp->int_addr,
d1107 1
a1107 1
				    || on_net(ifp1->int_addr,
d1110 1
a1110 1
					       " betwen %s:%s and %s:%s",
a1121 2
		/* Count the # of directly connected networks.
		 */
d1123 2
d1129 4
a1133 3

		if_ok_rdisc(ifp);
		rip_on(ifp);
d1136 1
a1136 1
	/* If we are multi-homed and have at least one interface
d1174 1
a1174 1
			trace_act("interface %s has disappeared\n",
d1198 2
a1199 1
		addrouteforif(ifp);
d1296 1
a1296 1
void
d1306 1
a1306 1
		return;
d1314 4
a1317 14
	if (ifp->int_state & IS_REMOTE) {
		dst = ifp->int_addr;
		gate = ifp->int_dstaddr;
		/* If we are going to send packets to the gateway,
		 * it must be reachable using our physical interfaces
		 */
		if (!(ifp->int_state && IS_EXTERNAL)
		    && !rtfind(ifp->int_dstaddr)
		    && ifp->int_transitions == 0) {
			msglog("unreachable gateway %s in "
			       _PATH_GATEWAYS" entry %s",
			       naddr_ntoa(gate), ifp->int_name);
			return;
		}
d1319 7
a1325 7
	} else {
		dst = (0 != (ifp->int_if_flags & (IFF_POINTOPOINT
						  | IFF_LOOPBACK))
		       ? ifp->int_dstaddr
		       : htonl(ifp->int_net));
		gate = ifp->int_addr;
	}
d1350 1
a1350 1
			trace_act("re-install interface %s\n",
d1356 2
@


1.3
log
@fix import.
mention that routed is from vjs@@sgi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.2 1996/06/23 14:32:26 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: if.c,v 1.2 1996/06/23 14:32:26 deraadt Exp $";
d458 7
a464 6
#	define COMP_NODST	0x008
#	define COMP_NOBADR	0x010
#	define COMP_NOMASK	0x020
#	define COMP_DUP		0x040
#	define COMP_BAD_METRIC	0x080
#	define COMP_NETMASK	0x100
d553 1
a553 1
					msglog("%s has a bad address",
d574 11
d628 11
d976 4
a979 6
		if (!(ifp->int_if_flags & IFF_LOOPBACK)) {
			if (!(ifp->int_state & IS_NO_RIPV1_OUT))
				have_ripv1_out = 1;
			if (!(ifp->int_state & IS_NO_RIPV1_IN))
				have_ripv1_in = 1;
		}
@


1.2
log
@update rcsid
@
text
@d1 1
a1 2
/*	$OpenBSD: if.c,v 1.8 1995/06/20 22:27:21 christos Exp $	*/
/*	$NetBSD: if.c,v 1.8 1995/06/20 22:27:21 christos Exp $	*/
d36 1
a36 2
#ifndef lint
#if 0
d39 1
a39 1
static char rcsid[] = "$OpenBSD: if.c,v 1.8 1995/06/20 22:27:21 christos Exp $";
a40 1
#endif /* not lint */
a41 3
/*
 * Routing Table Management Daemon
 */
d43 9
d53 2
a54 1
extern	struct interface *ifnet;
d56 2
a57 2
/*
 * Find the interface with address addr.
d60 3
a62 2
if_ifwithaddr(addr)
	struct sockaddr *addr;
d64 1
a64 1
	register struct interface *ifp;
a65 2
#define	same(a1, a2) \
	(memcmp((a1)->sa_data, (a2)->sa_data, 14) == 0)
d67 13
a79 9
		if (ifp->int_flags & IFF_REMOTE)
			continue;
		if (ifp->int_addr.sa_family != addr->sa_family)
			continue;
		if (same(&ifp->int_addr, addr))
			break;
		if ((ifp->int_flags & IFF_BROADCAST) &&
		    same(&ifp->int_broadaddr, addr))
			break;
d81 2
a82 1
	return (ifp);
d85 2
a86 2
/*
 * Find the point-to-point interface with destination address addr.
d89 2
a90 2
if_ifwithdstaddr(addr)
	struct sockaddr *addr;
d92 2
a93 1
	register struct interface *ifp;
d95 5
a99 5
	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if ((ifp->int_flags & IFF_POINTOPOINT) == 0)
			continue;
		if (same(&ifp->int_dstaddr, addr))
			break;
d101 1
a101 1
	return (ifp);
d104 1
a104 4
/*
 * Find the interface on the network 
 * of the specified address.
 */
d106 1
a106 2
if_ifwithnet(addr)
	register struct sockaddr *addr;
d108 6
a113 14
	register struct interface *ifp;
	register int af = addr->sa_family;
	register int (*netmatch) __P((struct sockaddr *, struct sockaddr *));

	if (af >= af_max)
		return (0);
	netmatch = afswitch[af].af_netmatch;
	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if (ifp->int_flags & IFF_REMOTE)
			continue;
		if (af != ifp->int_addr.sa_family)
			continue;
		if ((*netmatch)(addr, &ifp->int_addr))
			break;
d115 1
a115 1
	return (ifp);
d118 2
a119 2
/*
 * Find an interface from which the specified address
d124 1
a124 2
if_iflookup(addr)
	struct sockaddr *addr;
d126 1
a126 3
	register struct interface *ifp, *maybe;
	register int af = addr->sa_family;
	register int (*netmatch) __P((struct sockaddr *, struct sockaddr *));
a127 2
	if (af >= af_max)
		return (0);
a128 1
	netmatch = afswitch[af].af_netmatch;
d130 509
a638 1
		if (ifp->int_addr.sa_family != af)
d640 201
a840 1
		if (same(&ifp->int_addr, addr))
d842 290
a1131 8
		if ((ifp->int_flags & IFF_BROADCAST) &&
		    same(&ifp->int_broadaddr, addr))
			break;
		if ((ifp->int_flags & IFF_POINTOPOINT) &&
		    same(&ifp->int_dstaddr, addr))
			break;
		if (maybe == 0 && (*netmatch)(addr, &ifp->int_addr))
			maybe = ifp;
a1132 3
	if (ifp == 0)
		ifp = maybe;
	return (ifp);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: if.c,v 1.8 1995/06/20 22:27:21 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@new routed from SGI.
rip1, rip2, icmp, rdisc.
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
d36 2
a37 1
#if !defined(lint)
d39 2
d42 1
d44 3
a47 1
#include "pathnames.h"
d49 1
a49 5
struct	interface *ifnet;		/* all interfaces */
int	tot_interfaces;			/* # of remote and local interfaces */
int	rip_interfaces;			/* # of interfaces doing RIP */
int	foundloopback;			/* valid flag for loopaddr */
naddr	loopaddr;			/* our address on loopback */
d51 2
a52 7
struct timeval ifinit_timer;

int	have_ripv1_out;			/* have a RIPv1 interface */
int	have_ripv1_in;


/* Find the interface with an address
d55 2
a56 3
ifwithaddr(naddr addr,
	   int	bcast,			/* notice IFF_BROADCAST address */
	   int	remote)			/* include IS_REMOTE interfaces */
d58 1
a58 1
	struct interface *ifp, *possible = 0;
d60 2
d63 9
a71 13
		if (ifp->int_addr == addr
		    || ((ifp->int_if_flags & IFF_BROADCAST)
			&& ifp->int_brdaddr == addr
			&& bcast)) {
			if ((ifp->int_state & IS_REMOTE) && !remote)
				continue;

			if (!(ifp->int_state & IS_BROKE)
			    && !(ifp->int_state & IS_PASSIVE))
				return ifp;

			possible = ifp;
		}
d73 1
a73 2

	return possible;
d76 2
a77 2

/* find the interface with a name
d80 2
a81 2
ifwithname(char *name,			/* "ec0" or whatever */
	   naddr addr)			/* 0 or network address */
d83 1
a83 1
	struct interface *ifp;
d85 5
a89 6

	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (!strcmp(ifp->int_name, name)
		    && (ifp->int_addr == addr
			|| (addr == 0 && !(ifp->int_state & IS_ALIAS))))
			return ifp;
d91 1
a91 1
	return 0;
d94 4
a97 1

d99 2
a100 1
ifwithindex(u_short index)
d102 14
a115 6
	struct interface *ifp;


	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_index == index)
			return ifp;
d117 1
a117 1
	return 0;
d120 2
a121 2

/* Find an interface from which the specified address
d126 2
a127 1
iflookup(naddr addr)
d129 3
a131 1
	struct interface *ifp, *maybe;
d133 2
d136 1
d138 1
a138 300
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			if (ifp->int_dstaddr == addr)
				/* finished with a match */
				return ifp;

		} else {
			/* finished with an exact match */
			if (ifp->int_addr == addr)
				return ifp;
			if ((ifp->int_if_flags & IFF_BROADCAST)
			    && ifp->int_brdaddr == addr)
				return ifp;

			/* Look for the longest approximate match.
			 */
			if (on_net(addr, ifp->int_net, ifp->int_mask)
			    && (maybe == 0
				|| ifp->int_mask > maybe->int_mask))
				maybe = ifp;
		}
	}

	return maybe;
}


/* Return the classical netmask for an IP address.
 */
naddr
std_mask(naddr addr)			/* in network order */
{
	NTOHL(addr);			/* was a host, not a network */

	if (addr == 0)			/* default route has mask 0 */
		return 0;
	if (IN_CLASSA(addr))
		return IN_CLASSA_NET;
	if (IN_CLASSB(addr))
		return IN_CLASSB_NET;
	return IN_CLASSC_NET;
}


/* Find the netmask that would be inferred by RIPv1 listeners
 *	on the given interface for a given network.
 *	If no interface is specified, look for the best fitting	interface.
 */
naddr
ripv1_mask_net(naddr addr,		/* in network byte order */
	       struct interface *ifp)	/* as seen on this interface */
{
	naddr mask = 0;

	if (addr == 0)			/* default always has 0 mask */
		return mask;

	if (ifp != 0) {
		/* If the target network is that of the associated interface
		 * on which it arrived, then use the netmask of the interface.
		 */
		if (on_net(addr, ifp->int_net, ifp->int_std_mask))
			mask = ifp->int_ripv1_mask;

	} else {
		/* Examine all interfaces, and if it the target seems
		 * to have the same network number of an interface, use the
		 * netmask of that interface.  If there is more than one
		 * such interface, prefer the interface with the longest
		 * match.
		 */
		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (on_net(addr, ifp->int_std_net, ifp->int_std_mask)
			    && ifp->int_ripv1_mask > mask)
				mask = ifp->int_ripv1_mask;
		}
	}

	/* Otherwise, make the classic A/B/C guess.
	 */
	if (mask == 0)
		mask = std_mask(addr);

	return mask;
}


naddr
ripv1_mask_host(naddr addr,		/* in network byte order */
		struct interface *ifp)	/* as seen on this interface */
{
	naddr mask = ripv1_mask_net(addr, ifp);


	/* If the computed netmask does not mask the address,
	 * then assume it is a host address
	 */
	if ((ntohl(addr) & ~mask) != 0)
		mask = HOST_MASK;
	return mask;
}


/* See if a IP address looks reasonable as a destination
 */
int					/* 0=bad */
check_dst(naddr addr)
{
	NTOHL(addr);

	if (IN_CLASSA(addr)) {
		if (addr == 0)
			return 1;	/* default */

		addr >>= IN_CLASSA_NSHIFT;
		return (addr != 0 && addr != IN_LOOPBACKNET);
	}

	return (IN_CLASSB(addr) || IN_CLASSC(addr));
}


/* Delete an interface.
 */
static void
ifdel(struct interface *ifp)
{
	struct ip_mreq m;
	struct interface *ifp1;


	trace_if("Del", ifp);

	ifp->int_state |= IS_BROKE;

	/* unlink the interface
	 */
	if (rip_sock_mcast == ifp)
		rip_sock_mcast = 0;
	if (ifp->int_next != 0)
		ifp->int_next->int_prev = ifp->int_prev;
	if (ifp->int_prev != 0)
		ifp->int_prev->int_next = ifp->int_next;
	else
		ifnet = ifp->int_next;

	if (!(ifp->int_state & IS_ALIAS)) {
		/* delete aliases
		 */
		for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
			if (ifp1 != ifp
			    && !strcmp(ifp->int_name, ifp1->int_name))
				ifdel(ifp1);
		}

		if ((ifp->int_if_flags & IFF_MULTICAST)
#ifdef MCAST_PPP_BUG
		    && !(ifp->int_if_flags & IFF_POINTOPOINT)
#endif
		    && rip_sock >= 0) {
			m.imr_multiaddr.s_addr = htonl(INADDR_RIP_GROUP);
			m.imr_interface.s_addr = ((ifp->int_if_flags
						   & IFF_POINTOPOINT)
						  ? ifp->int_dstaddr
						  : ifp->int_addr);
			if (setsockopt(rip_sock,IPPROTO_IP,IP_DROP_MEMBERSHIP,
				       &m, sizeof(m)) < 0
			    && errno != EADDRNOTAVAIL
			    && !TRACEACTIONS)
				LOGERR("setsockopt(IP_DROP_MEMBERSHIP RIP)");
		}
		if (ifp->int_rip_sock >= 0) {
			(void)close(ifp->int_rip_sock);
			ifp->int_rip_sock = -1;
			fix_select();
		}

		tot_interfaces--;
		if (!IS_RIP_OFF(ifp->int_state))
			rip_interfaces--;

		/* Zap all routes associated with this interface.
		 * Assume routes just using gateways beyond this interface will
		 * timeout naturally, and have probably already died.
		 */
		(void)rn_walktree(rhead, walk_bad, 0);

		set_rdisc_mg(ifp, 0);
		if_bad_rdisc(ifp);
	}

	free(ifp);
}


/* Mark an interface ill.
 */
void
if_sick(struct interface *ifp)
{
	if (0 == (ifp->int_state & (IS_SICK | IS_BROKE))) {
		ifp->int_state |= IS_SICK;
		trace_if("Chg", ifp);

		LIM_SEC(ifinit_timer, now.tv_sec+CHECK_BAD_INTERVAL);
	}
}


/* Mark an interface dead.
 */
void
if_bad(struct interface *ifp)
{
	struct interface *ifp1;


	if (ifp->int_state & IS_BROKE)
		return;

	LIM_SEC(ifinit_timer, now.tv_sec+CHECK_BAD_INTERVAL);

	ifp->int_state |= (IS_BROKE | IS_SICK);
	ifp->int_state &= ~(IS_RIP_QUERIED | IS_ACTIVE);
	ifp->int_data.ts = 0;

	trace_if("Chg", ifp);

	if (!(ifp->int_state & IS_ALIAS)) {
		for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
			if (ifp1 != ifp
			    && !strcmp(ifp->int_name, ifp1->int_name))
				if_bad(ifp1);
		}
		(void)rn_walktree(rhead, walk_bad, 0);
		if_bad_rdisc(ifp);
	}
}


/* Mark an interface alive
 */
int					/* 1=it was dead */
if_ok(struct interface *ifp,
      char *type)
{
	struct interface *ifp1;


	if (!(ifp->int_state & IS_BROKE)) {
		if (ifp->int_state & IS_SICK) {
			trace_act("%sinterface %s to %s working better\n",
				  type,
				  ifp->int_name, naddr_ntoa(ifp->int_addr));
			ifp->int_state &= ~IS_SICK;
		}
		return 0;
	}

	msglog("%sinterface %s to %s restored",
	       type, ifp->int_name, naddr_ntoa(ifp->int_addr));
	ifp->int_state &= ~(IS_BROKE | IS_SICK);
	ifp->int_data.ts = 0;

	if (!(ifp->int_state & IS_ALIAS)) {
		for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
			if (ifp1 != ifp
			    && !strcmp(ifp->int_name, ifp1->int_name))
				if_ok(ifp1, type);
		}
		if_ok_rdisc(ifp);
	}
	return 1;
}


/* disassemble routing message
 */
void
rt_xaddrs(struct rt_addrinfo *info,
	  struct sockaddr *sa,
	  struct sockaddr *lim,
	  int addrs)
{
	int i;
#ifdef _HAVE_SA_LEN
	static struct sockaddr sa_zero;
#endif
#ifdef sgi
#define ROUNDUP(a) ((a) > 0 ? (1 + (((a) - 1) | (sizeof(__uint64_t) - 1))) \
		    : sizeof(__uint64_t))
#else
#define ROUNDUP(a) ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) \
		    : sizeof(long))
#endif


	bzero(info, sizeof(*info));
	info->rti_addrs = addrs;
	for (i = 0; i < RTAX_MAX && sa < lim; i++) {
		if ((addrs & (1 << i)) == 0)
d140 7
a146 410
#ifdef _HAVE_SA_LEN
		info->rti_info[i] = (sa->sa_len != 0) ? sa : &sa_zero;
		sa = (struct sockaddr *)((char*)(sa)
					 + ROUNDUP(sa->sa_len));
#else
		info->rti_info[i] = sa;
		sa = (struct sockaddr *)((char*)(sa)
					 + ROUNDUP(_FAKE_SA_LEN_DST(sa)));
#endif
	}
}


/* Find the network interfaces which have configured themselves.
 *	This must be done regularly, if only for extra addresses
 *	that come and go on interfaces.
 */
void
ifinit(void)
{
	static char *sysctl_buf;
	static size_t sysctl_buf_size = 0;
	uint complaints = 0;
	static u_int prev_complaints = 0;
#	define COMP_NOT_INET	0x001
#	define COMP_WIERD	0x002
#	define COMP_NOADDR	0x004
#	define COMP_NODST	0x008
#	define COMP_NOBADR	0x010
#	define COMP_NOMASK	0x020
#	define COMP_DUP		0x040
#	define COMP_BAD_METRIC	0x080
#	define COMP_NETMASK	0x100

	struct interface ifs, ifs0, *ifp, *ifp1;
	struct rt_entry *rt;
	size_t needed;
	int mib[6];
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam, *ifam_lim, *ifam2;
	struct sockaddr_dl *sdl;
	int in, ierr, out, oerr;
	struct intnet *intnetp;
	struct rt_addrinfo info;
#ifdef SIOCGIFMETRIC
	struct ifreq ifr;
#endif


	ifinit_timer.tv_sec = now.tv_sec + (supplier
					    ? CHECK_ACT_INTERVAL
					    : CHECK_QUIET_INTERVAL);

	/* mark all interfaces so we can get rid of thost that disappear */
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next)
		ifp->int_state &= ~(IS_CHECKED | IS_DUP);

	/* Fetch the interface list, without too many system calls
	 * since we do it repeatedly.
	 */
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;
	for (;;) {
		if ((needed = sysctl_buf_size) != 0) {
			if (sysctl(mib, 6, sysctl_buf,&needed, 0, 0) >= 0)
				break;
			if (errno != ENOMEM && errno != EFAULT)
				BADERR(1, "ifinit: get interface table");
			free(sysctl_buf);
			needed = 0;
		}
		if (sysctl(mib, 6, 0, &needed, 0, 0) < 0)
			BADERR(1,"ifinit: route-sysctl-estimate");
		sysctl_buf = rtmalloc(sysctl_buf_size = needed, "ifinit");
	}

	ifam_lim = (struct ifa_msghdr *)(sysctl_buf + needed);
	for (ifam = (struct ifa_msghdr *)sysctl_buf;
	     ifam < ifam_lim;
	     ifam = ifam2) {

		ifam2 = (struct ifa_msghdr*)((char*)ifam + ifam->ifam_msglen);

		if (ifam->ifam_type == RTM_IFINFO) {
			ifm = (struct if_msghdr *)ifam;
			/* make prototype structure for the IP aliases
			 */
			bzero(&ifs0, sizeof(ifs0));
			ifs0.int_rip_sock = -1;
			ifs0.int_index = ifm->ifm_index;
			ifs0.int_if_flags = ifm->ifm_flags;
			ifs0.int_state = IS_CHECKED;
			ifs0.int_act_time = now.tv_sec;
			ifs0.int_data.ts = now.tv_sec;
			ifs0.int_data.ipackets = ifm->ifm_data.ifi_ipackets;
			ifs0.int_data.ierrors = ifm->ifm_data.ifi_ierrors;
			ifs0.int_data.opackets = ifm->ifm_data.ifi_opackets;
			ifs0.int_data.oerrors = ifm->ifm_data.ifi_oerrors;
#ifdef sgi
			ifs0.int_data.odrops = ifm->ifm_data.ifi_odrops;
#endif
			sdl = (struct sockaddr_dl *)(ifm + 1);
			sdl->sdl_data[sdl->sdl_nlen] = 0;
			continue;
		}
		if (ifam->ifam_type != RTM_NEWADDR) {
			logbad(1,"ifinit: out of sync");
			continue;
		}

		rt_xaddrs(&info, (struct sockaddr *)(ifam+1),
			  (struct sockaddr *)ifam2,
			  ifam->ifam_addrs);

		if (INFO_IFA(&info) == 0) {
			if (iff_alive(ifs.int_if_flags)) {
				if (!(prev_complaints & COMP_NOADDR))
					msglog("%s has a bad address",
					       sdl->sdl_data);
				complaints |= COMP_NOADDR;
			}
			continue;
		}
		if (INFO_IFA(&info)->sa_family != AF_INET) {
			if (iff_alive(ifs.int_if_flags)) {
				if (!(prev_complaints & COMP_NOT_INET))
					trace_act("%s: not AF_INET\n",
						  sdl->sdl_data);
				complaints |= COMP_NOT_INET;
			}
			continue;
		}

		bcopy(&ifs0, &ifs, sizeof(ifs0));
		ifs0.int_state |= IS_ALIAS;	/* next will be an alias */

		ifs.int_addr = S_ADDR(INFO_IFA(&info));

		if (ifs.int_if_flags & IFF_BROADCAST) {
			if (INFO_MASK(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOMASK))
						msglog("%s has no netmask",
						       sdl->sdl_data);
					complaints |= COMP_NOMASK;
				}
				continue;
			}
			ifs.int_dstaddr = ifs.int_addr;
			ifs.int_mask = ntohl(S_ADDR(INFO_MASK(&info)));
			ifs.int_ripv1_mask = ifs.int_mask;
			ifs.int_net = ntohl(ifs.int_addr) & ifs.int_mask;
			ifs.int_std_mask = std_mask(ifs.int_addr);
			if (ifs.int_mask != ifs.int_std_mask)
				ifs.int_state |= IS_SUBNET;

			if (INFO_BRD(&info) == 0) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NOBADR))
						msglog("%s has no"
						       " broadcast address",
						       sdl->sdl_data);
					complaints |= COMP_NOBADR;
				}
				continue;
			}
			ifs.int_brdaddr = S_ADDR(INFO_BRD(&info));

		} else if (ifs.int_if_flags & IFF_POINTOPOINT) {
			if (INFO_BRD(&info) == 0
			    || INFO_BRD(&info)->sa_family != AF_INET) {
				if (iff_alive(ifs.int_if_flags)) {
					if (!(prev_complaints & COMP_NODST))
						msglog("%s has a bad"
						       " destination address",
						       sdl->sdl_data);
					complaints |= COMP_NODST;
				}
				continue;
			}
			ifs.int_dstaddr = S_ADDR(INFO_BRD(&info));
			ifs.int_mask = HOST_MASK;
			ifs.int_ripv1_mask = ntohl(S_ADDR(INFO_MASK(&info)));
			ifs.int_net = ntohl(ifs.int_dstaddr);
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);

		} else if (ifs.int_if_flags & IFF_LOOPBACK) {
			ifs.int_state |= IS_PASSIVE | IS_NO_RIP;
			ifs.int_dstaddr = ifs.int_addr;
			ifs.int_mask = HOST_MASK;
			ifs.int_ripv1_mask = HOST_MASK;
			ifs.int_net = ntohl(ifs.int_dstaddr);
			ifs.int_std_mask = std_mask(ifs.int_dstaddr);
			if (!foundloopback) {
				foundloopback = 1;
				loopaddr = ifs.int_addr;
			}

		} else {
			if (!(prev_complaints & COMP_WIERD))
				trace_act("%s is neither broadcast"
					  " nor point-to-point nor loopback",
					  sdl->sdl_data);
			complaints |= COMP_WIERD;
			continue;
		}
		ifs.int_std_net = ifs.int_net & ifs.int_std_mask;
		ifs.int_std_addr = htonl(ifs.int_std_net);

		/* Use a minimum metric of one.  Treat the interface metric
		 * (default 0) as an increment to the hop count of one.
		 *
		 * The metric obtained from the routing socket dump of
		 * interface addresses is wrong.  It is not set by the
		 * SIOCSIFMETRIC ioctl.
		 */
#ifdef SIOCGIFMETRIC
		strncpy(ifr.ifr_name, sdl->sdl_data, sizeof(ifr.ifr_name));
		if (ioctl(rt_sock, SIOCGIFMETRIC, &ifr) < 0) {
			DBGERR(1, "ioctl(SIOCGIFMETRIC)");
			ifs.int_metric = 0;
		} else {
			ifs.int_metric = ifr.ifr_metric;
		}
#else
		ifs.int_metric = ifam->ifam_metric;
#endif
		if (ifs.int_metric > HOPCNT_INFINITY) {
			ifs.int_metric = 0;
			if (!(prev_complaints & COMP_BAD_METRIC)
			    && iff_alive(ifs.int_if_flags)) {
				complaints |= COMP_BAD_METRIC;
				msglog("%s has a metric of %d",
				       sdl->sdl_data, ifs.int_metric);
			}
		}

		/* See if this is a familiar interface.
		 * If so, stop worrying about it if it is the same.
		 * Start it over if it now is to somewhere else, as happens
		 * frequently with PPP and SLIP.
		 */
		ifp = ifwithname(sdl->sdl_data, ((ifs.int_state & IS_ALIAS)
						 ? ifs.int_addr
						 : 0));
		if (ifp != 0) {
			ifp->int_state |= IS_CHECKED;

			if (0 != ((ifp->int_if_flags ^ ifs.int_if_flags)
				  & (IFF_BROADCAST
				     | IFF_LOOPBACK
				     | IFF_POINTOPOINT
				     | IFF_MULTICAST))
			    || 0 != ((ifp->int_state ^ ifs.int_state)
				     & IS_ALIAS)
			    || ifp->int_addr != ifs.int_addr
			    || ifp->int_brdaddr != ifs.int_brdaddr
			    || ifp->int_dstaddr != ifs.int_dstaddr
			    || ifp->int_mask != ifs.int_mask
			    || ifp->int_metric != ifs.int_metric) {
				/* Forget old information about
				 * a changed interface.
				 */
				trace_act("interface %s has changed\n",
					  ifp->int_name);
				ifdel(ifp);
				ifp = 0;
			}
		}

		if (ifp != 0) {
			/* The primary representative of an alias worries
			 * about how things are working.
			 */
			if (ifp->int_state & IS_ALIAS)
				continue;

			/* note interfaces that have been turned off
			 */
			if (!iff_alive(ifs.int_if_flags)) {
				if (iff_alive(ifp->int_if_flags)) {
					msglog("interface %s to %s turned off",
					       ifp->int_name,
					       naddr_ntoa(ifp->int_addr));
					if_bad(ifp);
					ifp->int_if_flags &= ~IFF_UP_RUNNING;
				}
				continue;
			}
			/* or that were off and are now ok */
			if (!iff_alive(ifp->int_if_flags)) {
				ifp->int_if_flags |= IFF_UP_RUNNING;
				(void)if_ok(ifp, "");
			}

			/* If it has been long enough,
			 * see if the interface is broken.
			 */
			if (now.tv_sec < ifp->int_data.ts+CHECK_BAD_INTERVAL)
				continue;

			in = ifs.int_data.ipackets - ifp->int_data.ipackets;
			ierr = ifs.int_data.ierrors - ifp->int_data.ierrors;
			out = ifs.int_data.opackets - ifp->int_data.opackets;
			oerr = ifs.int_data.oerrors - ifp->int_data.oerrors;
#ifdef sgi
			/* Through at least IRIX 6.2, PPP and SLIP
			 * count packets dropped by  the filters.
			 * But FDDI rings stuck non-operational count
			 * dropped packets as they wait for improvement.
			 */
			if (!(ifp->int_if_flags & IFF_POINTOPOINT))
				oerr += (ifs.int_data.odrops
					 - ifp->int_data.odrops);
#endif
			/* If the interface just awoke, restart the counters.
			 */
			if (ifp->int_data.ts == 0) {
				ifp->int_data = ifs.int_data;
				continue;
			}
			ifp->int_data = ifs.int_data;

			/* Withhold judgement when the short error
			 * counters wrap or the interface is reset.
			 */
			if (ierr < 0 || in < 0 || oerr < 0 || out < 0) {
				LIM_SEC(ifinit_timer,
					now.tv_sec+CHECK_BAD_INTERVAL);
				continue;
			}

			/* Withhold judgement when there is no traffic
			 */
			if (in == 0 && out == 0 && ierr == 0 && oerr == 0)
				continue;

			/* It is bad if input or output is not working.
			 * Require presistent problems before marking it dead.
			 */
			if ((in <= ierr && ierr > 0)
			    || (out <= oerr && oerr > 0)) {
				if (!(ifp->int_state & IS_SICK)) {
					trace_act("interface %s to %s"
						  " sick: in=%d ierr=%d"
						  " out=%d oerr=%d\n",
						  ifp->int_name,
						  naddr_ntoa(ifp->int_addr),
						  in, ierr, out, oerr);
					if_sick(ifp);
					continue;
				}
				if (!(ifp->int_state & IS_BROKE)) {
					msglog("interface %s to %s bad:"
					       " in=%d ierr=%d out=%d oerr=%d",
					       ifp->int_name,
					       naddr_ntoa(ifp->int_addr),
					       in, ierr, out, oerr);
					if_bad(ifp);
				}
				continue;
			}

			/* otherwise, it is active and healthy
			 */
			ifp->int_act_time = now.tv_sec;
			(void)if_ok(ifp, "");
			continue;
		}

		/* This is a new interface.
		 * If it is dead, forget it.
		 */
		if (!iff_alive(ifs.int_if_flags))
			continue;

		/* See if it duplicates an existing interface.
		 */
		for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_mask != ifs.int_mask)
				continue;
			if (((ifp->int_addr != ifs.int_addr
			      && ifs.int_mask != HOST_MASK)
			     || (ifp->int_dstaddr != ifs.int_dstaddr
				 && ifs.int_mask == HOST_MASK)))
				continue;
			if (!iff_alive(ifp->int_if_flags))
				continue;
			/* Let one of our real interfaces be marked
			 * passive.
			 */
			if ((ifp->int_state & IS_PASSIVE)
			    && !(ifp->int_state & IS_EXTERNAL))
				continue;

			/* It does duplicate an existing interface,
			 * so complain about it, mark the other one
			 * duplicated, and for get this one.
			 */
			if (!(prev_complaints & COMP_DUP)) {
				complaints |= COMP_DUP;
				msglog("%s is duplicated by %s at %s",
				       sdl->sdl_data, ifp->int_name,
				       naddr_ntoa(ifp->int_addr));
			}
			ifp->int_state |= IS_DUP;
d148 2
a149 290
		}
		if (ifp != 0)
			continue;

		/* It is new and ok.  So make it real
		 */
		strncpy(ifs.int_name, sdl->sdl_data,
			MIN(sizeof(ifs.int_name)-1, sdl->sdl_nlen));
		get_parms(&ifs);

		/* Add it to the list of interfaces
		 */
		ifp = (struct interface *)rtmalloc(sizeof(*ifp), "ifinit");
		bcopy(&ifs, ifp, sizeof(*ifp));
		if (ifnet != 0) {
			ifp->int_next = ifnet;
			ifnet->int_prev = ifp;
		}
		ifnet = ifp;
		trace_if("Add", ifp);

		/* Notice likely bad netmask.
		 */
		if (!(prev_complaints & COMP_NETMASK)
		    && !(ifp->int_if_flags & IFF_POINTOPOINT)) {
			for (ifp1 = ifnet; 0 != ifp1; ifp1 = ifp1->int_next) {
				if (ifp1->int_mask == ifp->int_mask)
					continue;
				if (ifp1->int_if_flags & IFF_POINTOPOINT)
					continue;
				if (on_net(ifp->int_addr,
					   ifp1->int_net, ifp1->int_mask)
				    || on_net(ifp1->int_addr,
					      ifp->int_net, ifp->int_mask)) {
					msglog("possible netmask problem"
					       " betwen %s:%s and %s:%s",
					       ifp->int_name,
					       addrname(htonl(ifp->int_net),
							ifp->int_mask, 1),
					       ifp1->int_name,
					       addrname(htonl(ifp1->int_net),
							ifp1->int_mask, 1));
					complaints |= COMP_NETMASK;
				}
			}
		}

		/* Count the # of directly connected networks.
		 */
		if (!(ifp->int_state & IS_ALIAS)) {
			if (!(ifp->int_if_flags & IFF_LOOPBACK))
				tot_interfaces++;
			if (!IS_RIP_OFF(ifp->int_state))
				rip_interfaces++;
		}

		if_ok_rdisc(ifp);
		rip_on(ifp);
	}

	/* If we are multi-homed and have at least one interface
	 * listening to RIP, then output by default.
	 */
	if (!supplier_set && rip_interfaces > 1)
		set_supplier();

	/* If we are multi-homed, optionally advertise a route to
	 * our main address.
	 */
	if (advertise_mhome
	    || (tot_interfaces > 1
		&& mhome
		&& (ifp = ifwithaddr(myaddr, 0, 0)) != 0
		&& foundloopback)) {
		advertise_mhome = 1;
		rt = rtget(myaddr, HOST_MASK);
		if (rt != 0) {
			if (rt->rt_ifp != ifp
			    || rt->rt_router != loopaddr) {
				rtdelete(rt);
				rt = 0;
			} else {
				rtchange(rt, rt->rt_state | RS_MHOME,
					 loopaddr, loopaddr,
					 0, 0, ifp, rt->rt_time, 0);
			}
		}
		if (rt == 0)
			rtadd(myaddr, HOST_MASK, loopaddr, loopaddr,
			      0, 0, RS_MHOME, ifp);
	}

	for (ifp = ifnet; ifp != 0; ifp = ifp1) {
		ifp1 = ifp->int_next;	/* because we may delete it */

		/* Forget any interfaces that have disappeared.
		 */
		if (!(ifp->int_state & (IS_CHECKED | IS_REMOTE))) {
			trace_act("interface %s has disappeared\n",
				  ifp->int_name);
			ifdel(ifp);
			continue;
		}

		if ((ifp->int_state & IS_BROKE)
		    && !(ifp->int_state & IS_PASSIVE))
			LIM_SEC(ifinit_timer, now.tv_sec+CHECK_BAD_INTERVAL);

		/* If we ever have a RIPv1 interface, assume we always will.
		 * It might come back if it ever goes away.
		 */
		if (!(ifp->int_if_flags & IFF_LOOPBACK)) {
			if (!(ifp->int_state & IS_NO_RIPV1_OUT))
				have_ripv1_out = 1;
			if (!(ifp->int_state & IS_NO_RIPV1_IN))
				have_ripv1_in = 1;
		}
	}

	for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
		/* Ensure there is always a network route for interfaces,
		 * after any dead interfaces have been deleted, which
		 * might affect routes for point-to-point links.
		 */
		addrouteforif(ifp);

		/* Add routes to the local end of point-to-point interfaces
		 * using loopback.
		 */
		if ((ifp->int_if_flags & IFF_POINTOPOINT)
		    && !(ifp->int_state & IS_REMOTE)
		    && foundloopback) {
			/* Delete any routes to the network address through
			 * foreign routers. Remove even static routes.
			 */
			del_static(ifp->int_addr, HOST_MASK, 0);
			rt = rtget(ifp->int_addr, HOST_MASK);
			if (rt != 0 && rt->rt_router != loopaddr) {
				rtdelete(rt);
				rt = 0;
			}
			if (rt != 0) {
				if (!(rt->rt_state & RS_LOCAL)
				    || rt->rt_metric > ifp->int_metric) {
					ifp1 = ifp;
				} else {
					ifp1 = rt->rt_ifp;
				}
				rtchange(rt,((rt->rt_state & ~RS_NET_SYN)
					     | (RS_IF|RS_LOCAL)),
					 loopaddr, loopaddr,
					 0, 0, ifp1, rt->rt_time, 0);
			} else {
				rtadd(ifp->int_addr, HOST_MASK,
				      loopaddr, loopaddr,
				      0, 0, (RS_IF | RS_LOCAL), ifp);
			}
		}
	}

	/* add the authority routes */
	for (intnetp = intnets; intnetp!=0; intnetp = intnetp->intnet_next) {
		rt = rtget(intnetp->intnet_addr, intnetp->intnet_mask);
		if (rt != 0
		    && !(rt->rt_state & RS_NO_NET_SYN)
		    && !(rt->rt_state & RS_NET_INT)) {
			rtdelete(rt);
			rt = 0;
		}
		if (rt == 0)
			rtadd(intnetp->intnet_addr, intnetp->intnet_mask,
			      loopaddr, loopaddr, intnetp->intnet_metric-1,
			      0, RS_NET_SYN | RS_NET_INT, 0);
	}

	prev_complaints = complaints;
}


static void
check_net_syn(struct interface *ifp)
{
	struct rt_entry *rt;


	/* Turn on the need to automatically synthesize a network route
	 * for this interface only if we are running RIPv1 on some other
	 * interface that is on a different class-A,B,or C network.
	 */
	if (have_ripv1_out || have_ripv1_in) {
		ifp->int_state |= IS_NEED_NET_SYN;
		rt = rtget(ifp->int_std_addr, ifp->int_std_mask);
		if (rt != 0
		    && 0 == (rt->rt_state & RS_NO_NET_SYN)
		    && (!(rt->rt_state & RS_NET_SYN)
			|| rt->rt_metric > ifp->int_metric)) {
			rtdelete(rt);
			rt = 0;
		}
		if (rt == 0)
			rtadd(ifp->int_std_addr, ifp->int_std_mask,
			      ifp->int_addr, ifp->int_addr,
			      ifp->int_metric, 0, RS_NET_SYN, ifp);

	} else {
		ifp->int_state &= ~IS_NEED_NET_SYN;

		rt = rtget(ifp->int_std_addr,
			   ifp->int_std_mask);
		if (rt != 0
		    && (rt->rt_state & RS_NET_SYN)
		    && rt->rt_ifp == ifp)
			rtbad_sub(rt);
	}
}


/* Add route for interface if not currently installed.
 * Create route to other end if a point-to-point link,
 * otherwise a route to this (sub)network.
 */
void
addrouteforif(struct interface *ifp)
{
	struct rt_entry *rt;
	naddr dst, gate;


	/* skip sick interfaces
	 */
	if (ifp->int_state & IS_BROKE)
		return;

	/* If the interface on a subnet, then install a RIPv1 route to
	 * the network as well (unless it is sick).
	 */
	if (ifp->int_state & IS_SUBNET)
		check_net_syn(ifp);

	if (ifp->int_state & IS_REMOTE) {
		dst = ifp->int_addr;
		gate = ifp->int_dstaddr;
		/* If we are going to send packets to the gateway,
		 * it must be reachable using our physical interfaces
		 */
		if (!(ifp->int_state && IS_EXTERNAL)
		    && !rtfind(ifp->int_dstaddr)
		    && ifp->int_transitions == 0) {
			msglog("unreachable gateway %s in "
			       _PATH_GATEWAYS" entry %s",
			       naddr_ntoa(gate), ifp->int_name);
			return;
		}

	} else {
		dst = (0 != (ifp->int_if_flags & (IFF_POINTOPOINT
						  | IFF_LOOPBACK))
		       ? ifp->int_dstaddr
		       : htonl(ifp->int_net));
		gate = ifp->int_addr;
	}

	/* We are finished if the correct main interface route exists.
	 * The right route must be for the right interface, not synthesized
	 * from a subnet, be a "gateway" or not as appropriate, and so forth.
	 */
	del_static(dst, ifp->int_mask, 0);
	rt = rtget(dst, ifp->int_mask);
	if (rt != 0) {
		if ((rt->rt_ifp != ifp
		     || rt->rt_router != ifp->int_addr)
		    && (!(ifp->int_state & IS_DUP)
			|| rt->rt_ifp == 0
			|| (rt->rt_ifp->int_state & IS_BROKE))) {
			rtdelete(rt);
			rt = 0;
		} else {
			rtchange(rt, ((rt->rt_state | RS_IF)
				      & ~(RS_NET_SYN | RS_LOCAL)),
				 ifp->int_addr, ifp->int_addr,
				 ifp->int_metric, 0, ifp, now.tv_sec, 0);
		}
	}
	if (rt == 0) {
		if (ifp->int_transitions++ > 0)
			trace_act("re-install interface %s\n",
				  ifp->int_name);

		rtadd(dst, ifp->int_mask, gate, gate,
		      ifp->int_metric, 0, RS_IF, ifp);
d151 3
@
