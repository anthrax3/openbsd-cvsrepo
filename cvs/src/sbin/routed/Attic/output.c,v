head	1.10;
access;
symbols
	OPENBSD_4_3:1.9.0.16
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.14
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.12
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.8
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	mickey:1.1.1.2
	SGI082896:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2008.05.07.11.55.20;	author claudio;	state dead;
branches;
next	1.9;

1.9
date	2004.07.05.20.22.56;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.07.18.26.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.05.05.23.46;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.30.23.28.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.30.22.24.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.05.14.31.36;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.05.13.58.53;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.10
log
@RIP routed.

You were a nice thing in the 4.2BSD times but now it is time for you to go.
Superseded by the shiny privseped ripd that does not have the evil habit to
use kernel internals in userland.

OK everybody in the onsen 'cause it unbreaks the tree
@
text
@/*	$OpenBSD: output.c,v 1.9 2004/07/05 20:22:56 henning Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint)
static char sccsid[] = "@@(#)output.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: output.c,v 1.9 2004/07/05 20:22:56 henning Exp $";
#endif

#include "defs.h"


int update_seqno;


/* walk the tree of routes with this for output
 */
struct {
	struct sockaddr_in to;
	naddr	to_mask;
	naddr	to_net;
	naddr	to_std_mask;
	naddr	to_std_net;
	struct interface *ifp;		/* usually output interface */
	struct ws_buf {			/* info for each buffer */
	    struct rip	*buf;
	    struct netinfo *n;
	    struct netinfo *base;
	    struct netinfo *lim;
	    enum output_type type;
	} v12, v2;
	char	metric;			/* adjust metrics by interface */
	int	npackets;
	int	gen_limit;
	u_int	state;
#define	    WS_ST_FLASH	    0x001	/* send only changed routes */
#define	    WS_ST_RIP2_SAFE 0x002	/* send RIPv2 safe for RIPv1 */
#define	    WS_ST_RIP2_ALL  0x004	/* send full featured RIPv2 */
#define	    WS_ST_AG	    0x008	/* ok to aggregate subnets */
#define	    WS_ST_SUPER_AG  0x010	/* ok to aggregate networks */
#define	    WS_ST_SUB_AG    0x020	/* aggregate subnets in odd case */
#define	    WS_ST_QUERY	    0x040	/* responding to a query */
#define	    WS_ST_TO_ON_NET 0x080	/* sending onto one of our nets */
#define	    WS_ST_DEFAULT   0x100	/* faking a default */
#define	    WS_ST_PM_RDISC  0x200	/* poor-man's router discovery */
} ws;

/* A buffer for what can be heard by both RIPv1 and RIPv2 listeners */
union pkt_buf ripv12_buf;

/* Another for only RIPv2 listeners */
union pkt_buf rip_v2_buf;



/* Send the contents of the global buffer via the non-multicast socket
 */
int					/* <0 on failure */
output(enum output_type type,
       struct sockaddr_in *dst,		/* send to here */
       struct interface *ifp,
       struct rip *buf,
       int size)			/* this many bytes */
{
	struct sockaddr_in sin;
	int flags;
	char *msg = NULL;
	int res;
	naddr tgt_mcast;
	int soc;
	int serrno;

	sin = *dst;
	if (sin.sin_port == 0)
		sin.sin_port = htons(RIP_PORT);
#ifdef _HAVE_SIN_LEN
	if (sin.sin_len == 0)
		sin.sin_len = sizeof(sin);
#endif

	soc = rip_sock;
	flags = 0;

	switch (type) {
	case OUT_QUERY:
		msg = "Answer Query";
		if (soc < 0)
			soc = ifp->int_rip_sock;
		break;
	case OUT_UNICAST:
		msg = "Send";
		if (soc < 0)
			soc = ifp->int_rip_sock;
		flags = MSG_DONTROUTE;
		break;
	case OUT_BROADCAST:
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			msg = "Send";
		} else {
			msg = "Send bcast";
		}
		flags = MSG_DONTROUTE;
		break;
	case OUT_MULTICAST:
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			msg = "Send pt-to-pt";
		} else if (ifp->int_state & IS_DUP) {
			trace_act("abort multicast output via %s"
				  " with duplicate address\n",
				  ifp->int_name);
			return 0;
		} else {
			msg = "Send mcast";
			if (rip_sock_mcast != ifp) {
#ifdef MCAST_PPP_BUG
				/* Do not specifiy the primary interface
				 * explicitly if we have the multicast
				 * point-to-point kernel bug, since the
				 * kernel will do the wrong thing if the
				 * local address of a point-to-point link
				 * is the same as the address of an ordinary
				 * interface.
				 */
				if (ifp->int_addr == myaddr) {
					tgt_mcast = 0;
				} else
#endif
				tgt_mcast = ifp->int_addr;
				if (0 > setsockopt(rip_sock,
						   IPPROTO_IP, IP_MULTICAST_IF,
						   &tgt_mcast,
						   sizeof(tgt_mcast))) {
					serrno = errno;
					LOGERR("setsockopt(rip_sock,"
					       "IP_MULTICAST_IF)");
					errno = serrno;
					ifp = 0;
					return -1;
				}
				rip_sock_mcast = ifp;
			}
			sin.sin_addr.s_addr = htonl(INADDR_RIP_GROUP);
		}

	case NO_OUT_MULTICAST:
	case NO_OUT_RIPV2:
		break;
	}

	trace_rip(msg, "to", &sin, ifp, buf, size);

	res = sendto(soc, buf, size, flags,
		     (struct sockaddr *)&sin, sizeof(sin));
	if (res < 0
	    && (ifp == 0 || !(ifp->int_state & IS_BROKE))) {
		serrno = errno;
		msglog("%s sendto(%s%s%s.%d): %s", msg,
		       ifp != 0 ? ifp->int_name : "",
		       ifp != 0 ? ", " : "",
		       inet_ntoa(sin.sin_addr),
		       ntohs(sin.sin_port),
		       strerror(errno));
		errno = serrno;
	}

	return res;
}


/* install authentication if appropriate
 */
static void
set_auth(struct ws_buf *w)
{
	struct netauth *nap;

	if (ws.ifp != 0
	    && ws.ifp->int_passwd[0] != '\0'
	    && (ws.state & WS_ST_RIP2_SAFE)) {
		nap = (struct netauth *)(&w->n->n_tag);
		w->n->n_family = RIP_AF_AUTH;
		nap->a_type = RIP_AUTH_PW;
		bcopy(ws.ifp->int_passwd, nap->au.au_pw,
		      sizeof(nap->au.au_pw));
		w->n++;
	}
}


/* Send the buffer
 */
static void
supply_write(struct ws_buf *wb)
{
	/* Output multicast only if legal.
	 * If we would multcast and it would be illegal, then discard the
	 * packet.
	 */
	switch (wb->type) {
	case NO_OUT_MULTICAST:
		trace_pkt("skip multicast to %s because impossible\n",
			  naddr_ntoa(ws.to.sin_addr.s_addr));
		break;
	case NO_OUT_RIPV2:
		break;
	default:
		if (output(wb->type, &ws.to, ws.ifp, wb->buf,
			   ((char *)wb->n - (char*)wb->buf)) < 0
		    && ws.ifp != 0)
			if_sick(ws.ifp);
		ws.npackets++;
		break;
	}

	bzero(wb->n = wb->base, sizeof(*wb->n)*NETS_LEN);
	if (wb->buf->rip_vers == RIPv2)
		set_auth(wb);
}


/* put an entry into the packet
 */
static void
supply_out(struct ag_info *ag)
{
	int i;
	naddr mask, v1_mask, s_mask, dst_h, ddst_h;
	struct ws_buf *wb;


	/* Skip this route if doing a flash update and it and the routes
	 * it aggregates have not changed recently.
	 */
	if (ag->ag_seqno < update_seqno
	    && (ws.state & WS_ST_FLASH))
		return;

	/* Skip this route if required by split-horizon.
	 */
	if (ag->ag_state & AGS_SPLIT_HZ)
		return;

	dst_h = ag->ag_dst_h;
	mask = ag->ag_mask;
	v1_mask = ripv1_mask_host(htonl(dst_h),
				  (ws.state & WS_ST_TO_ON_NET) ? ws.ifp : 0);
	s_mask = std_mask(htonl(dst_h));
	i = 0;

	/* If we are sending RIPv2 packets that cannot (or must not) be
	 * heard by RIPv1 listeners, do not worry about sub- or supernets.
	 * Subnets (from other networks) can only be sent via multicast.
	 * A pair of subnet routes might have been promoted so that they
	 * are legal to send by RIPv1.
	 * If RIPv1 is off, use the multicast buffer, unless this is the
	 * fake default route and it is acting as a poor-man's router-
	 * discovery mechanism.
	 */
	if (((ws.state & WS_ST_RIP2_ALL)
	     && (dst_h != RIP_DEFAULT || !(ws.state & WS_ST_PM_RDISC)))
	    || ((ag->ag_state & AGS_RIPV2) && v1_mask != mask)) {
		/* use the RIPv2-only buffer */
		wb = &ws.v2;

	} else {
		/* use the RIPv1-or-RIPv2 buffer */
		wb = &ws.v12;

		/* Convert supernet route into corresponding set of network
		 * routes for RIPv1, but leave non-contiguous netmasks
		 * to ag_check().
		 */
		if (v1_mask > mask
		    && mask + (mask & -mask) == 0) {
			ddst_h = v1_mask & -v1_mask;
			i = (v1_mask & ~mask)/ddst_h;

			if (i > ws.gen_limit) {
				/* Punt if we would have to generate an
				 * unreasonable number of routes.
				 */
#ifdef DEBUG
				msglog("sending %s to %s as 1 instead"
				       " of %d routes",
				       addrname(htonl(dst_h),mask,1),
				       naddr_ntoa(ws.to.sin_addr.s_addr),
				       i+1);
#endif
				i = 0;

			} else {
				mask = v1_mask;
				ws.gen_limit -= i;
			}
		}
	}

	do {
		wb->n->n_family = RIP_AF_INET;
		wb->n->n_dst = htonl(dst_h);
		/* If the route is from router-discovery or we are
		 * shutting down, admit only a bad metric.
		 */
		wb->n->n_metric = ((stopint || ag->ag_metric < 1)
				   ? HOPCNT_INFINITY
				   : ag->ag_metric);
		HTONL(wb->n->n_metric);
		if (wb->buf->rip_vers == RIPv2) {
			if (ag->ag_nhop != 0
			    && (ws.state & WS_ST_RIP2_SAFE)
			    && ((ws.state & WS_ST_QUERY)
				|| (ag->ag_nhop != ws.ifp->int_addr
				    && on_net(ag->ag_nhop,
					      ws.ifp->int_net,
					      ws.ifp->int_mask))))
				wb->n->n_nhop = ag->ag_nhop;
			if ((ws.state & WS_ST_RIP2_ALL)
			    || mask != s_mask)
				wb->n->n_mask = htonl(mask);
			wb->n->n_tag = ag->ag_tag;
		}
		dst_h += ddst_h;

		if (++wb->n >= wb->lim)
			supply_write(wb);
	} while (i-- != 0);
}


/* supply one route from the table
 */
/* ARGSUSED */
static int
walk_supply(struct radix_node *rn,
	    void *w)
{
#define RT ((struct rt_entry *)rn)
	u_short ags;
	char metric, pref;
	naddr dst, nhop;


	/* Do not advertise the loopback interface
	 * or external remote interfaces
	 */
	if ((RT->rt_state & RS_IF)
	    && RT->rt_ifp != 0
	    && ((RT->rt_ifp->int_if_flags & IFF_LOOPBACK)
		|| (RT->rt_ifp->int_state & IS_EXTERNAL))
	    && !(RT->rt_state & RS_MHOME))
		return 0;

	/* If being quiet about our ability to forward, then
	 * do not say anything unless responding to a query.
	 */
	if (!supplier && !(ws.state & WS_ST_QUERY))
		return 0;

	dst = RT->rt_dst;

	/* do not collide with the fake default route */
	if (dst == RIP_DEFAULT
	    && (ws.state & WS_ST_DEFAULT))
		return 0;

	if (RT->rt_state & RS_NET_SYN) {
		if (RT->rt_state & RS_NET_INT) {
			/* Do not send manual synthetic network routes
			 * into the subnet.
			 */
			if (on_net(ws.to.sin_addr.s_addr,
				   ntohl(dst), RT->rt_mask))
				return 0;

		} else {
			/* Do not send automatic synthetic network routes
			 * if they are not needed becaus no RIPv1 listeners
			 * can hear them.
			 */
			if (ws.state & WS_ST_RIP2_ALL)
				return 0;

			/* Do not send automatic synthetic network routes to
			 * the real subnet.
			 */
			if (on_net(ws.to.sin_addr.s_addr,
				   ntohl(dst), RT->rt_mask))
				return 0;
		}
		nhop = 0;

	} else {
		/* Advertise the next hop if this is not a route for one
		 * of our interfaces and the next hop is on the same
		 * network as the target.
		 */
		if (!(RT->rt_state & RS_IF)
		    && RT->rt_gate != myaddr
		    && RT->rt_gate != loopaddr)
			nhop = RT->rt_gate;
		else
			nhop = 0;
	}

	metric = RT->rt_metric;
	ags = 0;

	if (RT->rt_state & RS_MHOME) {
		/* retain host route of multi-homed servers */
		;

	} else if (RT_ISHOST(RT)) {
		/* We should always aggregate the host routes
		 * for the local end of our point-to-point links.
		 * If we are suppressing host routes in general, then do so.
		 * Avoid advertising host routes onto their own network,
		 * where they should be handled by proxy-ARP.
		 */
		if ((RT->rt_state & RS_LOCAL)
		    || ridhosts
		    || (ws.state & WS_ST_SUPER_AG)
		    || on_net(dst, ws.to_net, ws.to_mask))
			ags |= AGS_SUPPRESS;

		if (ws.state & WS_ST_SUPER_AG)
			ags |= AGS_PROMOTE;

	} else if (ws.state & WS_ST_AG) {
		/* Aggregate network routes, if we are allowed.
		 */
		ags |= AGS_SUPPRESS;

		/* Generate supernets if allowed.
		 * If we can be heard by RIPv1 systems, we will
		 * later convert back to ordinary nets.
		 * This unifies dealing with received supernets.
		 */
		if ((RT->rt_state & RS_SUBNET)
		    || (ws.state & WS_ST_SUPER_AG))
			ags |= AGS_PROMOTE;

	}

	/* Do not send RIPv1 advertisements of subnets to other
	 * networks. If possible, multicast them by RIPv2.
	 */
	if ((RT->rt_state & RS_SUBNET)
	    && !(ws.state & WS_ST_RIP2_ALL)
	    && !on_net(dst, ws.to_std_net, ws.to_std_mask)) {
		ags |= AGS_RIPV2 | AGS_PROMOTE;
		if (ws.state & WS_ST_SUB_AG)
			ags |= AGS_SUPPRESS;
	}

	/* Do not send a route back to where it came from, except in
	 * response to a query.  This is "split-horizon".  That means not
	 * advertising back to the same network	and so via the same interface.
	 *
	 * We want to suppress routes that might have been fragmented
	 * from this route by a RIPv1 router and sent back to us, and so we
	 * cannot forget this route here.  Let the split-horizon route
	 * aggregate (suppress) the fragmented routes and then itself be
	 * forgotten.
	 *
	 * Include the routes for both ends of point-to-point interfaces
	 * since the other side presumably knows them as well as we do.
	 */
	if (RT->rt_ifp == ws.ifp && ws.ifp != 0
	    && !(ws.state & WS_ST_QUERY)
	    && (ws.state & WS_ST_TO_ON_NET)
	    && (!(RT->rt_state & RS_IF)
		|| ws.ifp->int_if_flags & IFF_POINTOPOINT)) {
		/* Poison-reverse the route instead of only not advertising it
		 * it is recently changed from some other route.
		 * In almost all cases, if there is no spare for the route
		 * then it is either old or a brand new route, and if it
		 * is brand new, there is no need for poison-reverse.
		 */
		metric = HOPCNT_INFINITY;
		if (RT->rt_poison_time < now_expire
		    || RT->rt_spares[1].rts_gate ==0) {
			ags |= AGS_SPLIT_HZ;
			ags &= ~(AGS_PROMOTE | AGS_SUPPRESS);
		}
	}

	/* Adjust the outgoing metric by the cost of the link.
	 */
	pref = metric + ws.metric;
	if (pref < HOPCNT_INFINITY) {
		/* Keep track of the best metric with which the
		 * route has been advertised recently.
		 */
		if (RT->rt_poison_metric >= metric
		    || RT->rt_poison_time < now_expire) {
			RT->rt_poison_time = now.tv_sec;
			RT->rt_poison_metric = metric;
		}
		metric = pref;

	} else {
		/* Do not advertise stable routes that will be ignored,
		 * unless they are being held down and poisoned.  If the
		 * route recently was advertised with a metric that would
		 * have been less than infinity through this interface, we
		 * need to continue to advertise it in order to poison it.
		 */
		pref = RT->rt_poison_metric + ws.metric;
		if (pref >= HOPCNT_INFINITY
		    || RT->rt_poison_time < now_garbage )
			return 0;

		metric = HOPCNT_INFINITY;
	}

	ag_check(dst, RT->rt_mask, 0, nhop, metric, pref,
		 RT->rt_seqno, RT->rt_tag, ags, supply_out);
	return 0;
#undef RT
}


/* Supply dst with the contents of the routing tables.
 * If this won't fit in one packet, chop it up into several.
 */
void
supply(struct sockaddr_in *dst,
       struct interface *ifp,		/* output interface */
       enum output_type type,
       int flash,			/* 1=flash update */
       int vers)			/* RIP version */
{
	static int init = 1;
	struct rt_entry *rt;


	ws.state = 0;
	ws.gen_limit = 1024;

	ws.to = *dst;
	ws.to_std_mask = std_mask(ws.to.sin_addr.s_addr);
	ws.to_std_net = ntohl(ws.to.sin_addr.s_addr) & ws.to_std_mask;

	if (ifp != 0) {
		ws.to_mask = ifp->int_mask;
		ws.to_net = ifp->int_net;
		if (on_net(ws.to.sin_addr.s_addr, ws.to_net, ws.to_mask))
			ws.state |= WS_ST_TO_ON_NET;

	} else {
		ws.to_mask = ripv1_mask_net(ws.to.sin_addr.s_addr, 0);
		ws.to_net = ntohl(ws.to.sin_addr.s_addr) & ws.to_mask;
		rt = rtfind(dst->sin_addr.s_addr);
		if (rt)
			ifp = rt->rt_ifp;
	}

	ws.npackets = 0;
	if (flash)
		ws.state |= WS_ST_FLASH;
	if (type == OUT_QUERY)
		ws.state |= WS_ST_QUERY;

	if ((ws.ifp = ifp) == 0) {
		ws.metric = 1;
	} else {
		/* Adjust the advertised metric by the outgoing interface
		 * metric.
		 */
		ws.metric = ifp->int_metric+1;
	}

	if (init) {
		init = 0;

		bzero(&ripv12_buf, sizeof(ripv12_buf));
		ripv12_buf.rip.rip_cmd = RIPCMD_RESPONSE;
		ws.v12.buf = &ripv12_buf.rip;
		ws.v12.base = &ws.v12.buf->rip_nets[0];
		ws.v12.lim = ws.v12.base + NETS_LEN;

		bzero(&rip_v2_buf, sizeof(rip_v2_buf));
		rip_v2_buf.rip.rip_cmd = RIPCMD_RESPONSE;
		rip_v2_buf.rip.rip_vers = RIPv2;
		ws.v2.buf = &rip_v2_buf.rip;
		ws.v2.base = &ws.v2.buf->rip_nets[0];
		ws.v2.lim = ws.v2.base + NETS_LEN;
	}
	ripv12_buf.rip.rip_vers = vers;

	switch (type) {
	case OUT_BROADCAST:
		ws.v2.type = ((ws.ifp != 0
			       && (ws.ifp->int_if_flags & IFF_MULTICAST))
			      ? OUT_MULTICAST
			      : NO_OUT_MULTICAST);
		ws.v12.type = OUT_BROADCAST;
		break;
	case OUT_MULTICAST:
		ws.v2.type = ((ws.ifp != 0
			       && (ws.ifp->int_if_flags & IFF_MULTICAST))
			      ? OUT_MULTICAST
			      : NO_OUT_MULTICAST);
		ws.v12.type = OUT_BROADCAST;
		break;
	case OUT_UNICAST:
	case OUT_QUERY:
		ws.v2.type = (vers == RIPv2) ? type : NO_OUT_RIPV2;
		ws.v12.type = type;
		break;
	default:
		ws.v2.type = type;
		ws.v12.type = type;
		break;
	}

	if (vers == RIPv2) {
		/* if asked to send RIPv2, send at least that which can
		 * be safely heard by RIPv1 listeners.
		 */
		ws.state |= WS_ST_RIP2_SAFE;

		/* full RIPv2 only if cannot be heard by RIPv1 listeners */
		if (type != OUT_BROADCAST)
			ws.state |= WS_ST_RIP2_ALL;
		if (!(ws.state & WS_ST_TO_ON_NET)) {
			ws.state |= (WS_ST_AG | WS_ST_SUPER_AG);
		} else if (ws.ifp == 0 || !(ws.ifp->int_state & IS_NO_AG)) {
			ws.state |= WS_ST_AG;
			if (type != OUT_BROADCAST
			    && (ws.ifp == 0
				|| !(ws.ifp->int_state & IS_NO_SUPER_AG)))
				ws.state |= WS_ST_SUPER_AG;
		}

	} else if (ws.ifp == 0 || !(ws.ifp->int_state & IS_NO_AG)) {
		ws.state |= WS_ST_SUB_AG;
	}

	ws.v12.n = ws.v12.base;
	set_auth(&ws.v12);
	ws.v2.n = ws.v2.base;
	set_auth(&ws.v2);

	if (supplier && ifp != NULL) {
		/*  Fake a default route if asked, and if there is not
		 * a better, real default route.
		 */
		if (ifp->int_d_metric != 0
		    && (0 == (rt = rtget(RIP_DEFAULT, 0))
			|| rt->rt_metric+ws.metric >= ifp->int_d_metric)) {
			ws.state |= WS_ST_DEFAULT;
			ag_check(0, 0, 0, 0,
				 ifp->int_d_metric,ifp->int_d_metric,
				 0, 0, 0, supply_out);
		}
		if ((ws.state & WS_ST_RIP2_ALL)
		    && (ifp->int_state & IS_PM_RDISC)) {
			ws.state |= WS_ST_PM_RDISC;
			ripv12_buf.rip.rip_vers = RIPv1;
		}
	}

	(void)rn_walktree(rhead, walk_supply, 0);
	ag_flush(0,0,supply_out);

	/* Flush the packet buffers, provided they are not empty and
	 * do not contain only the password.
	 */
	if (ws.v12.n != ws.v12.base
	    && (ws.v12.n > ws.v12.base+1
		|| ws.v12.n->n_family != RIP_AF_AUTH))
		supply_write(&ws.v12);
	if (ws.v2.n != ws.v2.base
	    && (ws.v2.n > ws.v2.base+1
		|| ws.v2.n->n_family != RIP_AF_AUTH))
		supply_write(&ws.v2);

	/* If we sent nothing and this is an answer to a query, send
	 * an empty buffer.
	 */
	if (ws.npackets == 0
	    && (ws.state & WS_ST_QUERY))
		supply_write(&ws.v12);
}


/* send all of the routing table or just do a flash update
 */
void
rip_bcast(int flash)
{
#ifdef _HAVE_SIN_LEN
	static struct sockaddr_in dst = {sizeof(dst), AF_INET};
#else
	static struct sockaddr_in dst = {AF_INET};
#endif
	struct interface *ifp;
	enum output_type type;
	int vers;
	struct timeval rtime;


	need_flash = 0;
	intvl_random(&rtime, MIN_WAITTIME, MAX_WAITTIME);
	no_flash = rtime;
	timevaladd(&no_flash, &now);

	if (rip_sock < 0)
		return;

	trace_act("send %s and inhibit dynamic updates for %.3f sec\n",
		  flash ? "dynamic update" : "all routes",
		  rtime.tv_sec + ((float)rtime.tv_usec)/1000000.0);

	for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
		/* skip interfaces not doing RIP, those already queried,
		 * and aliases.  Do try broken interfaces to see
		 * if they have healed.
		 */
		if (0 != (ifp->int_state & (IS_PASSIVE | IS_ALIAS)))
			continue;

		/* skip turned off interfaces */
		if (!iff_alive(ifp->int_if_flags))
			continue;

		/* default to RIPv1 output */
		if (ifp->int_state & IS_NO_RIPV1_OUT) {
			/* Say nothing if this interface is turned off */
			if (ifp->int_state & IS_NO_RIPV2_OUT)
				continue;
			vers = RIPv2;
		} else {
			vers = RIPv1;
		}

		if (ifp->int_if_flags & IFF_BROADCAST) {
			/* ordinary, hardware interface */
			dst.sin_addr.s_addr = ifp->int_brdaddr;
			/* if RIPv1 is not turned off, then broadcast so
			 * that RIPv1 listeners can hear.
			 */
			if (vers == RIPv2
			    && (ifp->int_state & IS_NO_RIPV1_OUT)) {
				type = OUT_MULTICAST;
			} else {
				type = OUT_BROADCAST;
			}

		} else if (ifp->int_if_flags & IFF_POINTOPOINT) {
			/* point-to-point hardware interface */
			dst.sin_addr.s_addr = ifp->int_dstaddr;
			type = OUT_UNICAST;

		} else {
			/* remote interface */
			dst.sin_addr.s_addr = ifp->int_addr;
			type = OUT_UNICAST;
		}

		supply(&dst, ifp, type, flash, vers);
	}

	update_seqno++;			/* all routes are up to date */
}


/* Ask for routes
 * Do it only once to an interface, and not even after the interface
 * was broken and recovered.
 */
void
rip_query(void)
{
#ifdef _HAVE_SIN_LEN
	static struct sockaddr_in dst = {sizeof(dst), AF_INET};
#else
	static struct sockaddr_in dst = {AF_INET};
#endif
	struct interface *ifp;
	struct rip buf;
	enum output_type type;


	if (rip_sock < 0)
		return;

	bzero(&buf, sizeof(buf));

	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		/* skip interfaces not doing RIP, those already queried,
		 * and aliases.  Do try broken interfaces to see
		 * if they have healed.
		 */
		if (0 != (ifp->int_state & (IS_RIP_QUERIED
					    | IS_PASSIVE | IS_ALIAS)))
			continue;

		/* skip turned off interfaces */
		if (!iff_alive(ifp->int_if_flags))
			continue;

		/* default to RIPv1 output */
		if (ifp->int_state & IS_NO_RIPV2_OUT) {
			/* Say nothing if this interface is turned off */
			if (ifp->int_state & IS_NO_RIPV1_OUT)
				continue;
			buf.rip_vers = RIPv1;
		} else {
			buf.rip_vers = RIPv2;
		}

		buf.rip_cmd = RIPCMD_REQUEST;
		buf.rip_nets[0].n_family = RIP_AF_UNSPEC;
		buf.rip_nets[0].n_metric = htonl(HOPCNT_INFINITY);

		if (ifp->int_if_flags & IFF_BROADCAST) {
			/* ordinary, hardware interface */
			dst.sin_addr.s_addr = ifp->int_brdaddr;
			/* if RIPv1 is not turned off, then broadcast so
			 * that RIPv1 listeners can hear.
			 */
			if (buf.rip_vers == RIPv2
			    && (ifp->int_state & IS_NO_RIPV1_OUT)) {
				type = OUT_MULTICAST;
			} else {
				type = OUT_BROADCAST;
			}

		} else if (ifp->int_if_flags & IFF_POINTOPOINT) {
			/* point-to-point hardware interface */
			dst.sin_addr.s_addr = ifp->int_dstaddr;
			type = OUT_UNICAST;

		} else {
			/* remote interface */
			dst.sin_addr.s_addr = ifp->int_addr;
			type = OUT_UNICAST;
		}

		ifp->int_state |= IS_RIP_QUERIED;
		if (output(type, &dst, ifp, &buf, sizeof(buf)) < 0)
			if_sick(ifp);
	}
}
@


1.9
log
@when running as supplier and asked about a defualt route but we have no,
do not try to fake one when the query comes from a non-local network,
i. e. ifp is NULL, which caused a segfault.
PR3841, William J Hulley <jonny@@abduction.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.8 2003/06/02 20:06:17 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: output.c,v 1.8 2003/06/02 20:06:17 millert Exp $";
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.7 2001/07/07 18:26:20 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: output.c,v 1.7 2001/07/07 18:26:20 deraadt Exp $";
d673 1
a673 1
	if (supplier) {
@


1.7
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.6 2001/01/05 05:23:46 angelos Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
static char rcsid[] = "$OpenBSD: output.c,v 1.6 2001/01/05 05:23:46 angelos Exp $";
@


1.6
log
@Fix sending/receiving passwords (james@@oaktree.co.uk)
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.5 1997/07/30 23:28:43 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: output.c,v 1.5 1997/07/30 23:28:43 deraadt Exp $";
d99 1
a99 1
	char *msg;
@


1.5
log
@new routed DOES NOT EVEN COMPILE LET ALONE WORK.  TEST YOUR WORK!
Also, put back the damn security check in input.c that has been deleted
TWO SEPERATE TIMES NOW!  I CURSE anyone who deletes that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.3 1996/09/05 14:31:36 mickey Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: output.c,v 1.3 1996/09/05 14:31:36 mickey Exp $";
d207 2
d212 1
d214 3
a216 3
		((struct netauth*)w->n)->a_type = RIP_AUTH_PW;
		bcopy(ws.ifp->int_passwd, ((struct netauth*)w->n)->au.au_pw,
		      sizeof(((struct netauth*)w->n)->au.au_pw));
a622 5
	ws.v12.n = ws.v12.base;
	set_auth(&ws.v12);
	ws.v2.n = ws.v2.base;
	set_auth(&ws.v2);

d671 5
@


1.4
log
@update to sgi-02apr97
still have problems w/ defaults from pppd
@
text
@a42 1
#include <md5.h>
d57 7
a63 1
	struct auth *a;
d69 9
a77 7
#define	    WS_ST_RIP2_ALL  0x002	/* send full featured RIPv2 */
#define	    WS_ST_AG	    0x004	/* ok to aggregate subnets */
#define	    WS_ST_SUPER_AG  0x008	/* ok to aggregate networks */
#define	    WS_ST_SUB_AG    0x010	/* aggregate subnets in odd case */
#define	    WS_ST_QUERY	    0x020	/* responding to a query */
#define	    WS_ST_TO_ON_NET 0x040	/* sending onto one of our nets */
#define	    WS_ST_DEFAULT   0x080	/* faking a default */
a80 1
struct ws_buf v12buf;
a83 1
struct ws_buf v2buf;
a87 14
void
bufinit(void)
{
	ripv12_buf.rip.rip_cmd = RIPCMD_RESPONSE;
	v12buf.buf = &ripv12_buf.rip;
	v12buf.base = &v12buf.buf->rip_nets[0];

	rip_v2_buf.rip.rip_cmd = RIPCMD_RESPONSE;
	rip_v2_buf.rip.rip_vers = RIPv2;
	v2buf.buf = &rip_v2_buf.rip;
	v2buf.base = &v2buf.buf->rip_nets[0];
}


d141 1
a141 1
				  " with duplicate address",
a175 1
		break;
d179 1
a179 5
	default:
#ifdef DEBUG
		abort();
#endif
		return -1;
d202 1
a202 4
/* Find the first key for a packet to send.
 * Try for a key that is eligable and has not expired, but settle for
 * the last key if they have all expired.
 * If no key is ready yet, give up.
d204 2
a205 2
struct auth *
find_auth(struct interface *ifp)
d207 8
a214 28
	struct auth *ap, *res;
	int i;


	if (ifp == 0)
		return 0;

	res = 0;
	ap = ifp->int_auth;
	for (i = 0; i < MAX_AUTH_KEYS; i++, ap++) {
		/* stop looking after the last key */
		if (ap->type == RIP_AUTH_NONE)
			break;

		/* ignore keys that are not ready yet */
		if ((u_long)ap->start > (u_long)clk.tv_sec)
			continue;

		if ((u_long)ap->end < (u_long)clk.tv_sec) {
			/* note best expired password as a fall-back */
			if (res == 0 || (u_long)ap->end > (u_long)res->end)
				res = ap;
			continue;
		}

		/* note key with the best future */
		if (res == 0 || (u_long)res->end < (u_long)ap->end)
			res = ap;
a215 56
	return res;
}


void
clr_ws_buf(struct ws_buf *wb,
	   struct auth *ap)
{
	struct netauth *na;

	wb->lim = wb->base + NETS_LEN;
	wb->n = wb->base;
	bzero(wb->n, NETS_LEN*sizeof(*wb->n));

	/* install authentication if appropriate
	 */
	if (ap == 0)
		return;
	na = (struct netauth*)wb->n;
	if (ap->type == RIP_AUTH_PW) {
		na->a_family = RIP_AF_AUTH;
		na->a_type = RIP_AUTH_PW;
		bcopy(ap->key, na->au.au_pw, sizeof(na->au.au_pw));
		wb->n++;

	} else if (ap->type ==  RIP_AUTH_MD5) {
		na->a_family = RIP_AF_AUTH;
		na->a_type = RIP_AUTH_MD5;
		na->au.a_md5.md5_keyid = ap->keyid;
		na->au.a_md5.md5_auth_len = RIP_AUTH_PW_LEN;
		na->au.a_md5.md5_seqno = clk.tv_sec;
		wb->n++;
		wb->lim--;		/* make room for trailer */
	}
}


void
end_md5_auth(struct ws_buf *wb,
	     struct auth *ap)
{
	struct netauth *na, *na2;
	MD5_CTX md5_ctx;


	na = (struct netauth*)wb->base;
	na2 = (struct netauth*)wb->n;
	na2->a_family = RIP_AF_AUTH;
	na2->a_type = 1;
	bcopy(ap->key, na2->au.au_pw, sizeof(na2->au.au_pw));
	na->au.a_md5.md5_pkt_len = (char *)na2-(char *)(na+1);
	MD5Init(&md5_ctx);
	MD5Update(&md5_ctx, (u_char *)na,
		  (char *)(na2+1) - (char *)na);
	MD5Final(na2->au.au_pw, &md5_ctx);
	wb->n++;
d230 1
a230 1
		trace_pkt("skip multicast to %s because impossible",
a235 2
		if (ws.a != 0 && ws.a->type == RIP_AUTH_MD5)
			end_md5_auth(wb,ws.a);
d244 3
a246 1
	clr_ws_buf(wb,ws.a);
d256 1
a256 1
	naddr mask, v1_mask, dst_h, ddst_h = 0;
d276 1
d284 3
a286 1
	 * If RIPv1 is off, use the multicast buffer.
d288 2
a289 1
	if ((ws.state & WS_ST_RIP2_ALL)
d292 1
a292 1
		wb = &v2buf;
d296 1
a296 1
		wb = &v12buf;
d337 1
a337 6
		/* Any non-zero bits in the supposedly unused RIPv1 fields
		 * cause the old `routed` to ignore the route.
		 * That means the mask and so forth cannot be sent
		 * in the hybrid RIPv1/RIPv2 mode.
		 */
		if (ws.state & WS_ST_RIP2_ALL) {
d339 1
d346 3
a348 1
			wb->n->n_mask = htonl(mask);
a369 2
	struct rt_spare *rts;
	int i;
d372 2
a373 1
	/* Do not advertise external remote interfaces or passive interfaces.
d377 2
a378 1
	    && (RT->rt_ifp->int_if_flags & IS_PASSIVE)
d383 1
a383 2
	 * do not say anything unless responding to a query,
	 * except about our main interface.
d385 1
a385 2
	if (!supplier && !(ws.state & WS_ST_QUERY)
	    && !(RT->rt_state & RS_MHOME))
d495 1
a495 5
	 * among those suppressed by split-horizon, since the other side
	 * should knows them as well as we do.
	 *
	 * Notice spare routes with the same metric that we are about to
	 * advertise, to split the horizon on redunant, inactive paths.
d497 1
a497 1
	if (ws.ifp != 0
d502 11
a512 27
		for (rts = RT->rt_spares, i = NUM_SPARES; i != 0; i--, rts++) {
			if (rts->rts_ifp == ws.ifp
			    && rts->rts_metric <= metric)
				break;
		}
		if (i != 0) {
			/* If we do not mark the route with AGS_SPLIT_HZ here,
			 * it will be poisoned-reverse, or advertised back
			 * toward its source with an infinite metric.
			 * If we have recently advertised the route with a
			 * better metric than we now have, then we should
			 * poison-reverse the route before suppressing it for
			 * split-horizon.
			 *
			 * In almost all cases, if there is no spare for the
			 * route then it is either old and dead or a brand
			 * new route. If it is brand new, there is no need
			 * for poison-reverse. If it is old and dead, it
			 * is already poisoned.
			 */
			if (RT->rt_poison_time < now_expire
			    || RT->rt_poison_metric >= metric
			    || RT->rt_spares[1].rts_gate == 0) {
				ags |= AGS_SPLIT_HZ;
				ags &= ~(AGS_PROMOTE | AGS_SUPPRESS);
			}
			metric = HOPCNT_INFINITY;
a515 9
	/* Keep track of the best metric with which the
	 * route has been advertised recently.
	 */
	if (RT->rt_poison_metric >= metric
	    || RT->rt_poison_time < now_expire) {
		RT->rt_poison_time = now.tv_sec;
		RT->rt_poison_metric = metric;
	}

a516 1
	 * Avoid aggregation when a route is counting to infinity.
d518 11
a528 2
	pref = RT->rt_poison_metric + ws.metric;
	metric += ws.metric;
d530 10
a539 10
	/* Do not advertise stable routes that will be ignored,
	 * unless we are answering a query.
	 * If the route recently was advertised with a metric that
	 * would have been less than infinity through this interface,
	 * we need to continue to advertise it in order to poison it.
	 */
	if (metric >= HOPCNT_INFINITY) {
		if (!(ws.state & WS_ST_QUERY)
		    && (pref >= HOPCNT_INFINITY
			|| RT->rt_poison_time < now_garbage))
d560 1
a560 2
       int vers,			/* RIP version */
       int passwd_ok)			/* OK to include cleartext password */
d562 1
a563 1
	int def_metric;
d602 16
d620 5
d627 2
a628 1
		v2buf.type = ((ifp != 0 && (ifp->int_if_flags & IFF_MULTICAST))
d631 1
a631 1
		v12buf.type = OUT_BROADCAST;
d634 2
a635 1
		v2buf.type = ((ifp != 0 && (ifp->int_if_flags & IFF_MULTICAST))
d638 1
a638 1
		v12buf.type = OUT_BROADCAST;
d642 2
a643 2
		v2buf.type = (vers == RIPv2) ? type : NO_OUT_RIPV2;
		v12buf.type = type;
d646 2
a647 2
		v2buf.type = type;
		v12buf.type = type;
d652 5
d662 1
a662 1
		} else if (ifp == 0 || !(ifp->int_state & IS_NO_AG)) {
d665 2
a666 1
			    && (ifp == 0 || !(ifp->int_state&IS_NO_SUPER_AG)))
d670 1
a670 1
	} else if (ifp == 0 || !(ifp->int_state & IS_NO_AG)) {
d674 7
a680 12
	ws.a = (vers == RIPv2) ? find_auth(ifp) : 0;
	if (!passwd_ok && ws.a != 0 && ws.a->type == RIP_AUTH_PW)
		ws.a = 0;
	clr_ws_buf(&v12buf,ws.a);
	clr_ws_buf(&v2buf,ws.a);

	/*  Fake a default route if asked and if there is not already
	 * a better, real default route.
	 */
	if (supplier && (def_metric = ifp->int_d_metric) != 0) {
		if (0 == (rt = rtget(RIP_DEFAULT, 0))
		    || rt->rt_metric+ws.metric >= def_metric) {
d682 2
a683 1
			ag_check(0, 0, 0, 0, def_metric, def_metric,
a684 2
		} else {
			def_metric = rt->rt_metric+ws.metric;
a685 5

		/* If both RIPv2 and the poor-man's router discovery
		 * kludge are on, arrange to advertise an extra
		 * default route via RIPv1.
		 */
d688 1
a689 4
			v12buf.n->n_family = RIP_AF_INET;
			v12buf.n->n_dst = htonl(RIP_DEFAULT);
			v12buf.n->n_metric = htonl(def_metric);
			v12buf.n++;
d699 8
a706 8
	if (v12buf.n != v12buf.base
	    && (v12buf.n > v12buf.base+1
		|| v12buf.base->n_family != RIP_AF_AUTH))
		supply_write(&v12buf);
	if (v2buf.n != v2buf.base
	    && (v2buf.n > v2buf.base+1
		|| v2buf.base->n_family != RIP_AF_AUTH))
		supply_write(&v2buf);
d713 1
a713 1
		supply_write(&v12buf);
d741 1
a741 1
	trace_act("send %s and inhibit dynamic updates for %.3f sec",
d746 3
a748 2
		/* Skip interfaces not doing RIP.
		 * Do try broken interfaces to see if they have healed.
d750 1
a750 1
		if (IS_RIP_OUT_OFF(ifp->int_state))
d757 9
a765 1
		vers = (ifp->int_state & IS_NO_RIPV1_OUT) ? RIPv2 : RIPv1;
d770 1
a770 2

			/* If RIPv1 is not turned off, then broadcast so
d785 1
a785 1
		} else if (ifp->int_state & IS_REMOTE) {
a788 4

		} else {
			/* ATM, HIPPI, etc. */
			continue;
d791 1
a791 1
		supply(&dst, ifp, type, flash, vers, 1);
d821 3
a823 5
		/* Skip interfaces those already queried.
		 * Do not ask via interfaces through which we don't
		 * accept input.  Do not ask via interfaces that cannot
		 * send RIP packets.
		 * Do try broken interfaces to see if they have healed.
d825 2
a826 2
		if (IS_RIP_IN_OFF(ifp->int_state)
		    || ifp->int_query_time != NEVER)
d833 10
a842 1
		buf.rip_vers = (ifp->int_state&IS_NO_RIPV1_OUT) ? RIPv2:RIPv1;
d865 1
a865 1
		} else if (ifp->int_state & IS_REMOTE) {
a868 4

		} else {
			/* ATM, HIPPI, etc. */
			continue;
d871 1
a871 1
		ifp->int_query_time = now.tv_sec+SUPPLY_INTERVAL;
@


1.3
log
@fix import.
mention that routed is from vjs@@sgi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.2 1996/06/23 14:32:29 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: output.c,v 1.2 1996/06/23 14:32:29 deraadt Exp $";
d43 1
d58 1
a58 7
	struct ws_buf {			/* info for each buffer */
	    struct rip	*buf;
	    struct netinfo *n;
	    struct netinfo *base;
	    struct netinfo *lim;
	    enum output_type type;
	} v12, v2;
d64 7
a70 9
#define	    WS_ST_RIP2_SAFE 0x002	/* send RIPv2 safe for RIPv1 */
#define	    WS_ST_RIP2_ALL  0x004	/* send full featured RIPv2 */
#define	    WS_ST_AG	    0x008	/* ok to aggregate subnets */
#define	    WS_ST_SUPER_AG  0x010	/* ok to aggregate networks */
#define	    WS_ST_SUB_AG    0x020	/* aggregate subnets in odd case */
#define	    WS_ST_QUERY	    0x040	/* responding to a query */
#define	    WS_ST_TO_ON_NET 0x080	/* sending onto one of our nets */
#define	    WS_ST_DEFAULT   0x100	/* faking a default */
#define	    WS_ST_PM_RDISC  0x200	/* poor-man's router discovery */
d74 1
d78 1
d83 14
d150 1
a150 1
				  " with duplicate address\n",
d185 1
d189 5
a193 1
		break;
d216 4
a219 1
/* install authentication if appropriate
d221 39
a259 2
static void
set_auth(struct ws_buf *w)
d261 25
a285 8
	if (ws.ifp != 0
	    && ws.ifp->int_passwd[0] != '\0'
	    && (ws.state & WS_ST_RIP2_SAFE)) {
		w->n->n_family = RIP_AF_AUTH;
		((struct netauth*)w->n)->a_type = RIP_AUTH_PW;
		bcopy(ws.ifp->int_passwd, ((struct netauth*)w->n)->au.au_pw,
		      sizeof(((struct netauth*)w->n)->au.au_pw));
		w->n++;
d290 22
d323 1
a323 1
		trace_pkt("skip multicast to %s because impossible\n",
d329 2
d339 1
a339 3
	bzero(wb->n = wb->base, sizeof(*wb->n)*NETS_LEN);
	if (wb->buf->rip_vers == RIPv2)
		set_auth(wb);
d349 1
a349 1
	naddr mask, v1_mask, s_mask, dst_h, ddst_h;
a368 1
	s_mask = std_mask(htonl(dst_h));
d376 1
a376 3
	 * If RIPv1 is off, use the multicast buffer, unless this is the
	 * fake default route and it is acting as a poor-man's router-
	 * discovery mechanism.
d378 1
a378 2
	if (((ws.state & WS_ST_RIP2_ALL)
	     && (dst_h != RIP_DEFAULT || !(ws.state & WS_ST_PM_RDISC)))
d381 1
a381 1
		wb = &ws.v2;
d385 1
a385 1
		wb = &ws.v12;
d426 6
a431 1
		if (wb->buf->rip_vers == RIPv2) {
a432 1
			    && (ws.state & WS_ST_RIP2_SAFE)
d439 1
a439 3
			if ((ws.state & WS_ST_RIP2_ALL)
			    || mask != s_mask)
				wb->n->n_mask = htonl(mask);
d461 2
d465 1
a465 2
	/* Do not advertise the loopback interface
	 * or external remote interfaces
d469 1
a469 2
	    && ((RT->rt_ifp->int_if_flags & IFF_LOOPBACK)
		|| (RT->rt_ifp->int_state & IS_EXTERNAL))
d474 2
a475 1
	 * do not say anything unless responding to a query.
d477 2
a478 1
	if (!supplier && !(ws.state & WS_ST_QUERY))
d588 5
a592 1
	 * since the other side presumably knows them as well as we do.
d594 1
a594 1
	if (RT->rt_ifp == ws.ifp && ws.ifp != 0
d599 27
a625 11
		/* Poison-reverse the route instead of only not advertising it
		 * it is recently changed from some other route.
		 * In almost all cases, if there is no spare for the route
		 * then it is either old or a brand new route, and if it
		 * is brand new, there is no need for poison-reverse.
		 */
		metric = HOPCNT_INFINITY;
		if (RT->rt_poison_time < now_expire
		    || RT->rt_spares[1].rts_gate ==0) {
			ags |= AGS_SPLIT_HZ;
			ags &= ~(AGS_PROMOTE | AGS_SUPPRESS);
d629 9
d639 1
d641 2
a642 11
	pref = metric + ws.metric;
	if (pref < HOPCNT_INFINITY) {
		/* Keep track of the best metric with which the
		 * route has been advertised recently.
		 */
		if (RT->rt_poison_metric >= metric
		    || RT->rt_poison_time < now_expire) {
			RT->rt_poison_time = now.tv_sec;
			RT->rt_poison_metric = metric;
		}
		metric = pref;
d644 10
a653 10
	} else {
		/* Do not advertise stable routes that will be ignored,
		 * unless they are being held down and poisoned.  If the
		 * route recently was advertised with a metric that would
		 * have been less than infinity through this interface, we
		 * need to continue to advertise it in order to poison it.
		 */
		pref = RT->rt_poison_metric + ws.metric;
		if (pref >= HOPCNT_INFINITY
		    || RT->rt_poison_time < now_garbage )
d674 2
a675 1
       int vers)			/* RIP version */
a676 1
	static int init = 1;
d678 1
a716 16
	if (init) {
		init = 0;

		bzero(&ripv12_buf, sizeof(ripv12_buf));
		ripv12_buf.rip.rip_cmd = RIPCMD_RESPONSE;
		ws.v12.buf = &ripv12_buf.rip;
		ws.v12.base = &ws.v12.buf->rip_nets[0];
		ws.v12.lim = ws.v12.base + NETS_LEN;

		bzero(&rip_v2_buf, sizeof(rip_v2_buf));
		rip_v2_buf.rip.rip_cmd = RIPCMD_RESPONSE;
		rip_v2_buf.rip.rip_vers = RIPv2;
		ws.v2.buf = &rip_v2_buf.rip;
		ws.v2.base = &ws.v2.buf->rip_nets[0];
		ws.v2.lim = ws.v2.base + NETS_LEN;
	}
a718 5
	ws.v12.n = ws.v12.base;
	set_auth(&ws.v12);
	ws.v2.n = ws.v2.base;
	set_auth(&ws.v2);

d721 1
a721 2
		ws.v2.type = ((ws.ifp != 0
			       && (ws.ifp->int_if_flags & IFF_MULTICAST))
d724 1
a724 1
		ws.v12.type = OUT_BROADCAST;
d727 1
a727 2
		ws.v2.type = ((ws.ifp != 0
			       && (ws.ifp->int_if_flags & IFF_MULTICAST))
d730 1
a730 1
		ws.v12.type = OUT_BROADCAST;
d734 2
a735 2
		ws.v2.type = (vers == RIPv2) ? type : NO_OUT_RIPV2;
		ws.v12.type = type;
d738 2
a739 2
		ws.v2.type = type;
		ws.v12.type = type;
a743 5
		/* if asked to send RIPv2, send at least that which can
		 * be safely heard by RIPv1 listeners.
		 */
		ws.state |= WS_ST_RIP2_SAFE;

d749 1
a749 1
		} else if (ws.ifp == 0 || !(ws.ifp->int_state & IS_NO_AG)) {
d752 1
a752 2
			    && (ws.ifp == 0
				|| !(ws.ifp->int_state & IS_NO_SUPER_AG)))
d756 1
a756 1
	} else if (ws.ifp == 0 || !(ws.ifp->int_state & IS_NO_AG)) {
d760 12
a771 7
	if (supplier) {
		/*  Fake a default route if asked, and if there is not
		 * a better, real default route.
		 */
		if (ifp->int_d_metric != 0
		    && (0 == (rt = rtget(RIP_DEFAULT, 0))
			|| rt->rt_metric+ws.metric >= ifp->int_d_metric)) {
d773 1
a773 2
			ag_check(0, 0, 0, 0,
				 ifp->int_d_metric,ifp->int_d_metric,
d775 2
d778 5
a784 1
			ws.state |= WS_ST_PM_RDISC;
d786 4
d799 8
a806 8
	if (ws.v12.n != ws.v12.base
	    && (ws.v12.n > ws.v12.base+1
		|| ws.v12.n->n_family != RIP_AF_AUTH))
		supply_write(&ws.v12);
	if (ws.v2.n != ws.v2.base
	    && (ws.v2.n > ws.v2.base+1
		|| ws.v2.n->n_family != RIP_AF_AUTH))
		supply_write(&ws.v2);
d813 1
a813 1
		supply_write(&ws.v12);
d841 1
a841 1
	trace_act("send %s and inhibit dynamic updates for %.3f sec\n",
d846 2
a847 3
		/* skip interfaces not doing RIP, those already queried,
		 * and aliases.  Do try broken interfaces to see
		 * if they have healed.
d849 1
a849 1
		if (0 != (ifp->int_state & (IS_PASSIVE | IS_ALIAS)))
d856 1
a856 9
		/* default to RIPv1 output */
		if (ifp->int_state & IS_NO_RIPV1_OUT) {
			/* Say nothing if this interface is turned off */
			if (ifp->int_state & IS_NO_RIPV2_OUT)
				continue;
			vers = RIPv2;
		} else {
			vers = RIPv1;
		}
d861 2
a862 1
			/* if RIPv1 is not turned off, then broadcast so
d877 1
a877 1
		} else {
d881 4
d887 1
a887 1
		supply(&dst, ifp, type, flash, vers);
d917 5
a921 3
		/* skip interfaces not doing RIP, those already queried,
		 * and aliases.  Do try broken interfaces to see
		 * if they have healed.
d923 2
a924 2
		if (0 != (ifp->int_state & (IS_RIP_QUERIED
					    | IS_PASSIVE | IS_ALIAS)))
d931 1
a931 10
		/* default to RIPv1 output */
		if (ifp->int_state & IS_NO_RIPV2_OUT) {
			/* Say nothing if this interface is turned off */
			if (ifp->int_state & IS_NO_RIPV1_OUT)
				continue;
			buf.rip_vers = RIPv1;
		} else {
			buf.rip_vers = RIPv2;
		}

d954 1
a954 1
		} else {
d958 4
d964 1
a964 1
		ifp->int_state |= IS_RIP_QUERIED;
@


1.2
log
@update rcsid
@
text
@d1 1
a1 2
/*	$OpenBSD: output.c,v 1.9 1995/06/20 22:27:54 christos Exp $	*/
/*	$NetBSD: output.c,v 1.9 1995/06/20 22:27:54 christos Exp $	*/
d36 1
a36 2
#ifndef lint
#if 0
d39 1
a39 1
static char rcsid[] = "$OpenBSD: output.c,v 1.9 1995/06/20 22:27:54 christos Exp $";
a40 1
#endif /* not lint */
d42 209
a250 2
/*
 * Routing Table Management Daemon
d252 106
a357 1
#include "defs.h"
d359 1
a359 5
/*
 * Apply the function "f" to all non-passive
 * interfaces.  If the interface supports the
 * use of broadcasting use it, otherwise address
 * the output to the known router.
d361 180
a540 10
void
toall(f, rtstate, skipif)
	void (*f) __P((struct sockaddr *, int, struct interface *, int));
	int rtstate;
	struct interface *skipif;
{
	register struct interface *ifp;
	register struct sockaddr *dst;
	register int flags;
	extern struct interface *ifnet;
d542 1
a542 8
	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		if (ifp->int_flags & IFF_PASSIVE || ifp == skipif)
			continue;
		dst = ifp->int_flags & IFF_BROADCAST ? &ifp->int_broadaddr :
		      ifp->int_flags & IFF_POINTOPOINT ? &ifp->int_dstaddr :
		      &ifp->int_addr;
		flags = ifp->int_flags & IFF_INTERFACE ? MSG_DONTROUTE : 0;
		(*f)(dst, flags, ifp, rtstate);
d544 5
d551 3
a553 2
/*
 * Output a preformed packet.
a554 1
/*ARGSUSED*/
d556 5
a560 5
sndmsg(dst, flags, ifp, rtstate)
	struct sockaddr *dst;
	int flags;
	struct interface *ifp;
	int rtstate;
d562 133
d696 18
a713 3
	(*afswitch[dst->sa_family].af_output)(s, flags,
		dst, sizeof (struct rip));
	TRACE_OUTPUT(ifp, dst, sizeof (struct rip));
d716 2
a717 3
/*
 * Supply dst with the contents of the routing tables.
 * If this won't fit in one packet, chop it up into several.
d720 7
a726 3
supply(dst, flags, ifp, rtstate)
	struct sockaddr *dst;
	int flags;
d728 21
a748 23
	int rtstate;
{
	register struct rt_entry *rt;
	register struct netinfo *n = msg->rip_nets;
	register struct rthash *rh;
	struct rthash *base = hosthash;
	int doinghost = 1, size;
	void (*output) __P((int, int, struct sockaddr *, int)) =
		afswitch[dst->sa_family].af_output;
	int (*sendroute) __P((struct rt_entry *, struct sockaddr *)) =
		afswitch[dst->sa_family].af_sendroute;
	int npackets = 0;

	msg->rip_cmd = RIPCMD_RESPONSE;
	msg->rip_vers = RIP_VERSION_1;
	memset(msg->rip_res1, 0, sizeof(msg->rip_res1));
again:
	for (rh = base; rh < &base[ROUTEHASHSIZ]; rh++)
	for (rt = rh->cqh_first; rt != (void *) rh; rt = rt->rt_entry.cqe_next) {
		/*
		 * Don't resend the information on the network
		 * from which it was received (unless sending
		 * in response to a query).
d750 1
a750 2
		if (ifp && rt->rt_ifp == ifp &&
		    (rt->rt_state & RTS_INTERFACE) == 0)
d752 3
a754 1
		if (rt->rt_state & RTS_EXTERNAL)
d756 68
a823 3
		/*
		 * For dynamic updates, limit update to routes
		 * with the specified state.
d825 6
a830 1
		if (rtstate && (rt->rt_state & rtstate) == 0)
d832 5
a836 8
		/*
		 * Limit the spread of subnet information
		 * to those who are interested.
		 */
		if (doinghost == 0 && rt->rt_state & RTS_SUBNET) {
			if (rt->rt_dst.sa_family != dst->sa_family)
				continue;
			if ((*sendroute)(rt, dst) == 0)
d838 3
d842 10
a851 7
		size = (char *)n - packet;
		if (size > MAXPACKETSIZE - sizeof (struct netinfo)) {
			TRACE_OUTPUT(ifp, dst, size);
			(*output)(s, flags, dst, size);
			/*
			 * If only sending to ourselves,
			 * one packet is enough to monitor interface.
d853 21
a873 19
			if (ifp && (ifp->int_flags &
			   (IFF_BROADCAST | IFF_POINTOPOINT | IFF_REMOTE)) == 0)
				return;
			n = msg->rip_nets;
			npackets++;
		}
		(*afswitch[rt->rt_dst.sa_family].af_put)(n, &rt->rt_dst);
		n->rip_metric = htonl(rt->rt_metric);
		n++;
	}
	if (doinghost) {
		doinghost = 0;
		base = nethash;
		goto again;
	}
	if (n != msg->rip_nets || (npackets == 0 && rtstate == 0)) {
		size = (char *)n - packet;
		TRACE_OUTPUT(ifp, dst, size);
		(*output)(s, flags, dst, size);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: output.c,v 1.9 1995/06/20 22:27:54 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@new routed from SGI.
rip1, rip2, icmp, rdisc.
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
d36 2
a37 1
#if !defined(lint)
d39 2
d42 1
d44 3
d49 5
a53 5

int update_seqno;


/* walk the tree of routes with this for output
d55 10
a64 29
struct {
	struct sockaddr_in to;
	naddr	to_mask;
	naddr	to_net;
	naddr	to_std_mask;
	naddr	to_std_net;
	struct interface *ifp;		/* usually output interface */
	struct ws_buf {			/* info for each buffer */
	    struct rip	*buf;
	    struct netinfo *n;
	    struct netinfo *base;
	    struct netinfo *lim;
	    enum output_type type;
	} v12, v2;
	char	metric;			/* adjust metrics by interface */
	int	npackets;
	int	gen_limit;
	u_int	state;
#define	    WS_ST_FLASH	    0x001	/* send only changed routes */
#define	    WS_ST_RIP2_SAFE 0x002	/* send RIPv2 safe for RIPv1 */
#define	    WS_ST_RIP2_ALL  0x004	/* send full featured RIPv2 */
#define	    WS_ST_AG	    0x008	/* ok to aggregate subnets */
#define	    WS_ST_SUPER_AG  0x010	/* ok to aggregate networks */
#define	    WS_ST_SUB_AG    0x020	/* aggregate subnets in odd case */
#define	    WS_ST_QUERY	    0x040	/* responding to a query */
#define	    WS_ST_TO_ON_NET 0x080	/* sending onto one of our nets */
#define	    WS_ST_DEFAULT   0x100	/* faking a default */
#define	    WS_ST_PM_RDISC  0x200	/* poor-man's router discovery */
} ws;
d66 8
a73 100
/* A buffer for what can be heard by both RIPv1 and RIPv2 listeners */
union pkt_buf ripv12_buf;

/* Another for only RIPv2 listeners */
union pkt_buf rip_v2_buf;



/* Send the contents of the global buffer via the non-multicast socket
 */
int					/* <0 on failure */
output(enum output_type type,
       struct sockaddr_in *dst,		/* send to here */
       struct interface *ifp,
       struct rip *buf,
       int size)			/* this many bytes */
{
	struct sockaddr_in sin;
	int flags;
	char *msg;
	int res;
	naddr tgt_mcast;
	int soc;
	int serrno;

	sin = *dst;
	if (sin.sin_port == 0)
		sin.sin_port = htons(RIP_PORT);
#ifdef _HAVE_SIN_LEN
	if (sin.sin_len == 0)
		sin.sin_len = sizeof(sin);
#endif

	soc = rip_sock;
	flags = 0;

	switch (type) {
	case OUT_QUERY:
		msg = "Answer Query";
		if (soc < 0)
			soc = ifp->int_rip_sock;
		break;
	case OUT_UNICAST:
		msg = "Send";
		if (soc < 0)
			soc = ifp->int_rip_sock;
		flags = MSG_DONTROUTE;
		break;
	case OUT_BROADCAST:
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			msg = "Send";
		} else {
			msg = "Send bcast";
		}
		flags = MSG_DONTROUTE;
		break;
	case OUT_MULTICAST:
		if (ifp->int_if_flags & IFF_POINTOPOINT) {
			msg = "Send pt-to-pt";
		} else if (ifp->int_state & IS_DUP) {
			trace_act("abort multicast output via %s"
				  " with duplicate address\n",
				  ifp->int_name);
			return 0;
		} else {
			msg = "Send mcast";
			if (rip_sock_mcast != ifp) {
#ifdef MCAST_PPP_BUG
				/* Do not specifiy the primary interface
				 * explicitly if we have the multicast
				 * point-to-point kernel bug, since the
				 * kernel will do the wrong thing if the
				 * local address of a point-to-point link
				 * is the same as the address of an ordinary
				 * interface.
				 */
				if (ifp->int_addr == myaddr) {
					tgt_mcast = 0;
				} else
#endif
				tgt_mcast = ifp->int_addr;
				if (0 > setsockopt(rip_sock,
						   IPPROTO_IP, IP_MULTICAST_IF,
						   &tgt_mcast,
						   sizeof(tgt_mcast))) {
					serrno = errno;
					LOGERR("setsockopt(rip_sock,"
					       "IP_MULTICAST_IF)");
					errno = serrno;
					ifp = 0;
					return -1;
				}
				rip_sock_mcast = ifp;
			}
			sin.sin_addr.s_addr = htonl(INADDR_RIP_GROUP);
		}

	case NO_OUT_MULTICAST:
	case NO_OUT_RIPV2:
		break;
a74 18

	trace_rip(msg, "to", &sin, ifp, buf, size);

	res = sendto(soc, buf, size, flags,
		     (struct sockaddr *)&sin, sizeof(sin));
	if (res < 0
	    && (ifp == 0 || !(ifp->int_state & IS_BROKE))) {
		serrno = errno;
		msglog("%s sendto(%s%s%s.%d): %s", msg,
		       ifp != 0 ? ifp->int_name : "",
		       ifp != 0 ? ", " : "",
		       inet_ntoa(sin.sin_addr),
		       ntohs(sin.sin_port),
		       strerror(errno));
		errno = serrno;
	}

	return res;
d77 2
a78 2

/* install authentication if appropriate
d80 7
a86 19
static void
set_auth(struct ws_buf *w)
{
	if (ws.ifp != 0
	    && ws.ifp->int_passwd[0] != '\0'
	    && (ws.state & WS_ST_RIP2_SAFE)) {
		w->n->n_family = RIP_AF_AUTH;
		((struct netauth*)w->n)->a_type = RIP_AUTH_PW;
		bcopy(ws.ifp->int_passwd, ((struct netauth*)w->n)->au.au_pw,
		      sizeof(((struct netauth*)w->n)->au.au_pw));
		w->n++;
	}
}


/* Send the buffer
 */
static void
supply_write(struct ws_buf *wb)
a87 19
	/* Output multicast only if legal.
	 * If we would multcast and it would be illegal, then discard the
	 * packet.
	 */
	switch (wb->type) {
	case NO_OUT_MULTICAST:
		trace_pkt("skip multicast to %s because impossible\n",
			  naddr_ntoa(ws.to.sin_addr.s_addr));
		break;
	case NO_OUT_RIPV2:
		break;
	default:
		if (output(wb->type, &ws.to, ws.ifp, wb->buf,
			   ((char *)wb->n - (char*)wb->buf)) < 0
		    && ws.ifp != 0)
			if_sick(ws.ifp);
		ws.npackets++;
		break;
	}
d89 3
a91 3
	bzero(wb->n = wb->base, sizeof(*wb->n)*NETS_LEN);
	if (wb->buf->rip_vers == RIPv2)
		set_auth(wb);
d94 2
a95 304

/* put an entry into the packet
 */
static void
supply_out(struct ag_info *ag)
{
	int i;
	naddr mask, v1_mask, s_mask, dst_h, ddst_h;
	struct ws_buf *wb;


	/* Skip this route if doing a flash update and it and the routes
	 * it aggregates have not changed recently.
	 */
	if (ag->ag_seqno < update_seqno
	    && (ws.state & WS_ST_FLASH))
		return;

	/* Skip this route if required by split-horizon.
	 */
	if (ag->ag_state & AGS_SPLIT_HZ)
		return;

	dst_h = ag->ag_dst_h;
	mask = ag->ag_mask;
	v1_mask = ripv1_mask_host(htonl(dst_h),
				  (ws.state & WS_ST_TO_ON_NET) ? ws.ifp : 0);
	s_mask = std_mask(htonl(dst_h));
	i = 0;

	/* If we are sending RIPv2 packets that cannot (or must not) be
	 * heard by RIPv1 listeners, do not worry about sub- or supernets.
	 * Subnets (from other networks) can only be sent via multicast.
	 * A pair of subnet routes might have been promoted so that they
	 * are legal to send by RIPv1.
	 * If RIPv1 is off, use the multicast buffer, unless this is the
	 * fake default route and it is acting as a poor-man's router-
	 * discovery mechanism.
	 */
	if (((ws.state & WS_ST_RIP2_ALL)
	     && (dst_h != RIP_DEFAULT || !(ws.state & WS_ST_PM_RDISC)))
	    || ((ag->ag_state & AGS_RIPV2) && v1_mask != mask)) {
		/* use the RIPv2-only buffer */
		wb = &ws.v2;

	} else {
		/* use the RIPv1-or-RIPv2 buffer */
		wb = &ws.v12;

		/* Convert supernet route into corresponding set of network
		 * routes for RIPv1, but leave non-contiguous netmasks
		 * to ag_check().
		 */
		if (v1_mask > mask
		    && mask + (mask & -mask) == 0) {
			ddst_h = v1_mask & -v1_mask;
			i = (v1_mask & ~mask)/ddst_h;

			if (i > ws.gen_limit) {
				/* Punt if we would have to generate an
				 * unreasonable number of routes.
				 */
#ifdef DEBUG
				msglog("sending %s to %s as 1 instead"
				       " of %d routes",
				       addrname(htonl(dst_h),mask,1),
				       naddr_ntoa(ws.to.sin_addr.s_addr),
				       i+1);
#endif
				i = 0;

			} else {
				mask = v1_mask;
				ws.gen_limit -= i;
			}
		}
	}

	do {
		wb->n->n_family = RIP_AF_INET;
		wb->n->n_dst = htonl(dst_h);
		/* If the route is from router-discovery or we are
		 * shutting down, admit only a bad metric.
		 */
		wb->n->n_metric = ((stopint || ag->ag_metric < 1)
				   ? HOPCNT_INFINITY
				   : ag->ag_metric);
		HTONL(wb->n->n_metric);
		if (wb->buf->rip_vers == RIPv2) {
			if (ag->ag_nhop != 0
			    && (ws.state & WS_ST_RIP2_SAFE)
			    && ((ws.state & WS_ST_QUERY)
				|| (ag->ag_nhop != ws.ifp->int_addr
				    && on_net(ag->ag_nhop,
					      ws.ifp->int_net,
					      ws.ifp->int_mask))))
				wb->n->n_nhop = ag->ag_nhop;
			if ((ws.state & WS_ST_RIP2_ALL)
			    || mask != s_mask)
				wb->n->n_mask = htonl(mask);
			wb->n->n_tag = ag->ag_tag;
		}
		dst_h += ddst_h;

		if (++wb->n >= wb->lim)
			supply_write(wb);
	} while (i-- != 0);
}


/* supply one route from the table
 */
/* ARGSUSED */
static int
walk_supply(struct radix_node *rn,
	    void *w)
{
#define RT ((struct rt_entry *)rn)
	u_short ags;
	char metric, pref;
	naddr dst, nhop;


	/* Do not advertise the loopback interface
	 * or external remote interfaces
	 */
	if ((RT->rt_state & RS_IF)
	    && RT->rt_ifp != 0
	    && ((RT->rt_ifp->int_if_flags & IFF_LOOPBACK)
		|| (RT->rt_ifp->int_state & IS_EXTERNAL))
	    && !(RT->rt_state & RS_MHOME))
		return 0;

	/* If being quiet about our ability to forward, then
	 * do not say anything unless responding to a query.
	 */
	if (!supplier && !(ws.state & WS_ST_QUERY))
		return 0;

	dst = RT->rt_dst;

	/* do not collide with the fake default route */
	if (dst == RIP_DEFAULT
	    && (ws.state & WS_ST_DEFAULT))
		return 0;

	if (RT->rt_state & RS_NET_SYN) {
		if (RT->rt_state & RS_NET_INT) {
			/* Do not send manual synthetic network routes
			 * into the subnet.
			 */
			if (on_net(ws.to.sin_addr.s_addr,
				   ntohl(dst), RT->rt_mask))
				return 0;

		} else {
			/* Do not send automatic synthetic network routes
			 * if they are not needed becaus no RIPv1 listeners
			 * can hear them.
			 */
			if (ws.state & WS_ST_RIP2_ALL)
				return 0;

			/* Do not send automatic synthetic network routes to
			 * the real subnet.
			 */
			if (on_net(ws.to.sin_addr.s_addr,
				   ntohl(dst), RT->rt_mask))
				return 0;
		}
		nhop = 0;

	} else {
		/* Advertise the next hop if this is not a route for one
		 * of our interfaces and the next hop is on the same
		 * network as the target.
		 */
		if (!(RT->rt_state & RS_IF)
		    && RT->rt_gate != myaddr
		    && RT->rt_gate != loopaddr)
			nhop = RT->rt_gate;
		else
			nhop = 0;
	}

	metric = RT->rt_metric;
	ags = 0;

	if (RT->rt_state & RS_MHOME) {
		/* retain host route of multi-homed servers */
		;

	} else if (RT_ISHOST(RT)) {
		/* We should always aggregate the host routes
		 * for the local end of our point-to-point links.
		 * If we are suppressing host routes in general, then do so.
		 * Avoid advertising host routes onto their own network,
		 * where they should be handled by proxy-ARP.
		 */
		if ((RT->rt_state & RS_LOCAL)
		    || ridhosts
		    || (ws.state & WS_ST_SUPER_AG)
		    || on_net(dst, ws.to_net, ws.to_mask))
			ags |= AGS_SUPPRESS;

		if (ws.state & WS_ST_SUPER_AG)
			ags |= AGS_PROMOTE;

	} else if (ws.state & WS_ST_AG) {
		/* Aggregate network routes, if we are allowed.
		 */
		ags |= AGS_SUPPRESS;

		/* Generate supernets if allowed.
		 * If we can be heard by RIPv1 systems, we will
		 * later convert back to ordinary nets.
		 * This unifies dealing with received supernets.
		 */
		if ((RT->rt_state & RS_SUBNET)
		    || (ws.state & WS_ST_SUPER_AG))
			ags |= AGS_PROMOTE;

	}

	/* Do not send RIPv1 advertisements of subnets to other
	 * networks. If possible, multicast them by RIPv2.
	 */
	if ((RT->rt_state & RS_SUBNET)
	    && !(ws.state & WS_ST_RIP2_ALL)
	    && !on_net(dst, ws.to_std_net, ws.to_std_mask)) {
		ags |= AGS_RIPV2 | AGS_PROMOTE;
		if (ws.state & WS_ST_SUB_AG)
			ags |= AGS_SUPPRESS;
	}

	/* Do not send a route back to where it came from, except in
	 * response to a query.  This is "split-horizon".  That means not
	 * advertising back to the same network	and so via the same interface.
	 *
	 * We want to suppress routes that might have been fragmented
	 * from this route by a RIPv1 router and sent back to us, and so we
	 * cannot forget this route here.  Let the split-horizon route
	 * aggregate (suppress) the fragmented routes and then itself be
	 * forgotten.
	 *
	 * Include the routes for both ends of point-to-point interfaces
	 * since the other side presumably knows them as well as we do.
	 */
	if (RT->rt_ifp == ws.ifp && ws.ifp != 0
	    && !(ws.state & WS_ST_QUERY)
	    && (ws.state & WS_ST_TO_ON_NET)
	    && (!(RT->rt_state & RS_IF)
		|| ws.ifp->int_if_flags & IFF_POINTOPOINT)) {
		/* Poison-reverse the route instead of only not advertising it
		 * it is recently changed from some other route.
		 * In almost all cases, if there is no spare for the route
		 * then it is either old or a brand new route, and if it
		 * is brand new, there is no need for poison-reverse.
		 */
		metric = HOPCNT_INFINITY;
		if (RT->rt_poison_time < now_expire
		    || RT->rt_spares[1].rts_gate ==0) {
			ags |= AGS_SPLIT_HZ;
			ags &= ~(AGS_PROMOTE | AGS_SUPPRESS);
		}
	}

	/* Adjust the outgoing metric by the cost of the link.
	 */
	pref = metric + ws.metric;
	if (pref < HOPCNT_INFINITY) {
		/* Keep track of the best metric with which the
		 * route has been advertised recently.
		 */
		if (RT->rt_poison_metric >= metric
		    || RT->rt_poison_time < now_expire) {
			RT->rt_poison_time = now.tv_sec;
			RT->rt_poison_metric = metric;
		}
		metric = pref;

	} else {
		/* Do not advertise stable routes that will be ignored,
		 * unless they are being held down and poisoned.  If the
		 * route recently was advertised with a metric that would
		 * have been less than infinity through this interface, we
		 * need to continue to advertise it in order to poison it.
		 */
		pref = RT->rt_poison_metric + ws.metric;
		if (pref >= HOPCNT_INFINITY
		    || RT->rt_poison_time < now_garbage )
			return 0;

		metric = HOPCNT_INFINITY;
	}

	ag_check(dst, RT->rt_mask, 0, nhop, metric, pref,
		 RT->rt_seqno, RT->rt_tag, ags, supply_out);
	return 0;
#undef RT
}


/* Supply dst with the contents of the routing tables.
d99 5
a103 5
supply(struct sockaddr_in *dst,
       struct interface *ifp,		/* output interface */
       enum output_type type,
       int flash,			/* 1=flash update */
       int vers)			/* RIP version */
d105 21
a125 36
	static int init = 1;
	struct rt_entry *rt;


	ws.state = 0;
	ws.gen_limit = 1024;

	ws.to = *dst;
	ws.to_std_mask = std_mask(ws.to.sin_addr.s_addr);
	ws.to_std_net = ntohl(ws.to.sin_addr.s_addr) & ws.to_std_mask;

	if (ifp != 0) {
		ws.to_mask = ifp->int_mask;
		ws.to_net = ifp->int_net;
		if (on_net(ws.to.sin_addr.s_addr, ws.to_net, ws.to_mask))
			ws.state |= WS_ST_TO_ON_NET;

	} else {
		ws.to_mask = ripv1_mask_net(ws.to.sin_addr.s_addr, 0);
		ws.to_net = ntohl(ws.to.sin_addr.s_addr) & ws.to_mask;
		rt = rtfind(dst->sin_addr.s_addr);
		if (rt)
			ifp = rt->rt_ifp;
	}

	ws.npackets = 0;
	if (flash)
		ws.state |= WS_ST_FLASH;
	if (type == OUT_QUERY)
		ws.state |= WS_ST_QUERY;

	if ((ws.ifp = ifp) == 0) {
		ws.metric = 1;
	} else {
		/* Adjust the advertised metric by the outgoing interface
		 * metric.
d127 2
a128 152
		ws.metric = ifp->int_metric+1;
	}

	if (init) {
		init = 0;

		bzero(&ripv12_buf, sizeof(ripv12_buf));
		ripv12_buf.rip.rip_cmd = RIPCMD_RESPONSE;
		ws.v12.buf = &ripv12_buf.rip;
		ws.v12.base = &ws.v12.buf->rip_nets[0];
		ws.v12.lim = ws.v12.base + NETS_LEN;

		bzero(&rip_v2_buf, sizeof(rip_v2_buf));
		rip_v2_buf.rip.rip_cmd = RIPCMD_RESPONSE;
		rip_v2_buf.rip.rip_vers = RIPv2;
		ws.v2.buf = &rip_v2_buf.rip;
		ws.v2.base = &ws.v2.buf->rip_nets[0];
		ws.v2.lim = ws.v2.base + NETS_LEN;
	}
	ripv12_buf.rip.rip_vers = vers;

	ws.v12.n = ws.v12.base;
	set_auth(&ws.v12);
	ws.v2.n = ws.v2.base;
	set_auth(&ws.v2);

	switch (type) {
	case OUT_BROADCAST:
		ws.v2.type = ((ws.ifp != 0
			       && (ws.ifp->int_if_flags & IFF_MULTICAST))
			      ? OUT_MULTICAST
			      : NO_OUT_MULTICAST);
		ws.v12.type = OUT_BROADCAST;
		break;
	case OUT_MULTICAST:
		ws.v2.type = ((ws.ifp != 0
			       && (ws.ifp->int_if_flags & IFF_MULTICAST))
			      ? OUT_MULTICAST
			      : NO_OUT_MULTICAST);
		ws.v12.type = OUT_BROADCAST;
		break;
	case OUT_UNICAST:
	case OUT_QUERY:
		ws.v2.type = (vers == RIPv2) ? type : NO_OUT_RIPV2;
		ws.v12.type = type;
		break;
	default:
		ws.v2.type = type;
		ws.v12.type = type;
		break;
	}

	if (vers == RIPv2) {
		/* if asked to send RIPv2, send at least that which can
		 * be safely heard by RIPv1 listeners.
		 */
		ws.state |= WS_ST_RIP2_SAFE;

		/* full RIPv2 only if cannot be heard by RIPv1 listeners */
		if (type != OUT_BROADCAST)
			ws.state |= WS_ST_RIP2_ALL;
		if (!(ws.state & WS_ST_TO_ON_NET)) {
			ws.state |= (WS_ST_AG | WS_ST_SUPER_AG);
		} else if (ws.ifp == 0 || !(ws.ifp->int_state & IS_NO_AG)) {
			ws.state |= WS_ST_AG;
			if (type != OUT_BROADCAST
			    && (ws.ifp == 0
				|| !(ws.ifp->int_state & IS_NO_SUPER_AG)))
				ws.state |= WS_ST_SUPER_AG;
		}

	} else if (ws.ifp == 0 || !(ws.ifp->int_state & IS_NO_AG)) {
		ws.state |= WS_ST_SUB_AG;
	}

	if (supplier) {
		/*  Fake a default route if asked, and if there is not
		 * a better, real default route.
		 */
		if (ifp->int_d_metric != 0
		    && (0 == (rt = rtget(RIP_DEFAULT, 0))
			|| rt->rt_metric+ws.metric >= ifp->int_d_metric)) {
			ws.state |= WS_ST_DEFAULT;
			ag_check(0, 0, 0, 0,
				 ifp->int_d_metric,ifp->int_d_metric,
				 0, 0, 0, supply_out);
		}
		if ((ws.state & WS_ST_RIP2_ALL)
		    && (ifp->int_state & IS_PM_RDISC)) {
			ws.state |= WS_ST_PM_RDISC;
			ripv12_buf.rip.rip_vers = RIPv1;
		}
	}

	(void)rn_walktree(rhead, walk_supply, 0);
	ag_flush(0,0,supply_out);

	/* Flush the packet buffers, provided they are not empty and
	 * do not contain only the password.
	 */
	if (ws.v12.n != ws.v12.base
	    && (ws.v12.n > ws.v12.base+1
		|| ws.v12.n->n_family != RIP_AF_AUTH))
		supply_write(&ws.v12);
	if (ws.v2.n != ws.v2.base
	    && (ws.v2.n > ws.v2.base+1
		|| ws.v2.n->n_family != RIP_AF_AUTH))
		supply_write(&ws.v2);

	/* If we sent nothing and this is an answer to a query, send
	 * an empty buffer.
	 */
	if (ws.npackets == 0
	    && (ws.state & WS_ST_QUERY))
		supply_write(&ws.v12);
}


/* send all of the routing table or just do a flash update
 */
void
rip_bcast(int flash)
{
#ifdef _HAVE_SIN_LEN
	static struct sockaddr_in dst = {sizeof(dst), AF_INET};
#else
	static struct sockaddr_in dst = {AF_INET};
#endif
	struct interface *ifp;
	enum output_type type;
	int vers;
	struct timeval rtime;


	need_flash = 0;
	intvl_random(&rtime, MIN_WAITTIME, MAX_WAITTIME);
	no_flash = rtime;
	timevaladd(&no_flash, &now);

	if (rip_sock < 0)
		return;

	trace_act("send %s and inhibit dynamic updates for %.3f sec\n",
		  flash ? "dynamic update" : "all routes",
		  rtime.tv_sec + ((float)rtime.tv_usec)/1000000.0);

	for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
		/* skip interfaces not doing RIP, those already queried,
		 * and aliases.  Do try broken interfaces to see
		 * if they have healed.
		 */
		if (0 != (ifp->int_state & (IS_PASSIVE | IS_ALIAS)))
d130 1
a130 3

		/* skip turned off interfaces */
		if (!iff_alive(ifp->int_if_flags))
d132 3
a134 68

		/* default to RIPv1 output */
		if (ifp->int_state & IS_NO_RIPV1_OUT) {
			/* Say nothing if this interface is turned off */
			if (ifp->int_state & IS_NO_RIPV2_OUT)
				continue;
			vers = RIPv2;
		} else {
			vers = RIPv1;
		}

		if (ifp->int_if_flags & IFF_BROADCAST) {
			/* ordinary, hardware interface */
			dst.sin_addr.s_addr = ifp->int_brdaddr;
			/* if RIPv1 is not turned off, then broadcast so
			 * that RIPv1 listeners can hear.
			 */
			if (vers == RIPv2
			    && (ifp->int_state & IS_NO_RIPV1_OUT)) {
				type = OUT_MULTICAST;
			} else {
				type = OUT_BROADCAST;
			}

		} else if (ifp->int_if_flags & IFF_POINTOPOINT) {
			/* point-to-point hardware interface */
			dst.sin_addr.s_addr = ifp->int_dstaddr;
			type = OUT_UNICAST;

		} else {
			/* remote interface */
			dst.sin_addr.s_addr = ifp->int_addr;
			type = OUT_UNICAST;
		}

		supply(&dst, ifp, type, flash, vers);
	}

	update_seqno++;			/* all routes are up to date */
}


/* Ask for routes
 * Do it only once to an interface, and not even after the interface
 * was broken and recovered.
 */
void
rip_query(void)
{
#ifdef _HAVE_SIN_LEN
	static struct sockaddr_in dst = {sizeof(dst), AF_INET};
#else
	static struct sockaddr_in dst = {AF_INET};
#endif
	struct interface *ifp;
	struct rip buf;
	enum output_type type;


	if (rip_sock < 0)
		return;

	bzero(&buf, sizeof(buf));

	for (ifp = ifnet; ifp; ifp = ifp->int_next) {
		/* skip interfaces not doing RIP, those already queried,
		 * and aliases.  Do try broken interfaces to see
		 * if they have healed.
d136 1
a136 2
		if (0 != (ifp->int_state & (IS_RIP_QUERIED
					    | IS_PASSIVE | IS_ALIAS)))
d138 8
a145 9

		/* skip turned off interfaces */
		if (!iff_alive(ifp->int_if_flags))
			continue;

		/* default to RIPv1 output */
		if (ifp->int_state & IS_NO_RIPV2_OUT) {
			/* Say nothing if this interface is turned off */
			if (ifp->int_state & IS_NO_RIPV1_OUT)
a146 3
			buf.rip_vers = RIPv1;
		} else {
			buf.rip_vers = RIPv2;
d148 7
a154 10

		buf.rip_cmd = RIPCMD_REQUEST;
		buf.rip_nets[0].n_family = RIP_AF_UNSPEC;
		buf.rip_nets[0].n_metric = htonl(HOPCNT_INFINITY);

		if (ifp->int_if_flags & IFF_BROADCAST) {
			/* ordinary, hardware interface */
			dst.sin_addr.s_addr = ifp->int_brdaddr;
			/* if RIPv1 is not turned off, then broadcast so
			 * that RIPv1 listeners can hear.
d156 19
a174 21
			if (buf.rip_vers == RIPv2
			    && (ifp->int_state & IS_NO_RIPV1_OUT)) {
				type = OUT_MULTICAST;
			} else {
				type = OUT_BROADCAST;
			}

		} else if (ifp->int_if_flags & IFF_POINTOPOINT) {
			/* point-to-point hardware interface */
			dst.sin_addr.s_addr = ifp->int_dstaddr;
			type = OUT_UNICAST;

		} else {
			/* remote interface */
			dst.sin_addr.s_addr = ifp->int_addr;
			type = OUT_UNICAST;
		}

		ifp->int_state |= IS_RIP_QUERIED;
		if (output(type, &dst, ifp, &buf, sizeof(buf)) < 0)
			if_sick(ifp);
@
