head	1.17;
access;
symbols
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.16
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	mickey:1.1.1.2
	SGI082896:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2008.05.07.11.55.21;	author claudio;	state dead;
branches;
next	1.16;

1.16
date	2007.12.28.19.19.22;	author chl;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.12.15.26.47;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.03.02.47.03;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.06.22.15;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.21.02.06.52;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.13.09.09.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.05.22.32.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.23.28.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.30.22.24.47;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.02.27.08.31.28;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	96.10.02.06.51.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.06.13.05.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.05.14.31.52;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.49;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.05.13.58.59;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.17
log
@RIP routed.

You were a nice thing in the 4.2BSD times but now it is time for you to go.
Superseded by the shiny privseped ripd that does not have the evil habit to
use kernel internals in userland.

OK everybody in the onsen 'cause it unbreaks the tree
@
text
@/*	$OpenBSD: trace.c,v 1.16 2007/12/28 19:19:22 chl Exp $	*/
/*	$NetBSD: trace.c,v 1.13 1995/06/20 22:28:03 christos Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint)
static char sccsid[] = "@@(#)trace.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: trace.c,v 1.16 2007/12/28 19:19:22 chl Exp $";
#endif

#define	RIPCMDS
#include "defs.h"
#include "pathnames.h"
#include <sys/stat.h>
#include <sys/signal.h>
#include <fcntl.h>


#ifdef sgi
/* use *stat64 for files on large filesystems */
#define stat	stat64
#endif

#define	NRECORDS	50		/* size of circular trace buffer */

u_int	tracelevel, new_tracelevel;
FILE	*ftrace = stdout;		/* output trace file */
static char *tracelevel_pat = "%s\n";

char savetracename[MAXPATHLEN];

static void trace_dump(void);


/* convert IP address to a string, but not into a single buffer
 */
char *
naddr_ntoa(naddr a)
{
#define NUM_BUFS 4
	static int bufno;
	static struct {
	    char    str[16];		/* xxx.xxx.xxx.xxx\0 */
	} bufs[NUM_BUFS];
	struct in_addr addr;

	addr.s_addr = a;
	strlcpy(bufs[bufno].str, inet_ntoa(addr),
	    sizeof bufs[bufno].str);
	bufno = (bufno+1) % NUM_BUFS;
	return bufs[bufno].str;
#undef NUM_BUFS
}


char *
saddr_ntoa(struct sockaddr *sa)
{
	return (sa == 0) ? "?" : naddr_ntoa(S_ADDR(sa));
}


static char *
ts(time_t secs)
{
	static char s[20];

	secs += epoch.tv_sec;
#ifdef sgi
	(void)cftime(s, "%T", &secs);
#else
	bcopy(ctime(&secs)+11, s, 8);
	s[8] = '\0';
#endif
	return s;
}


/* On each event, display a time stamp.
 * This assumes that 'now' is update once for each event, and
 * that at least now.tv_usec changes.
 */
void
lastlog(void)
{
	static struct timeval last;

	if (last.tv_sec != now.tv_sec
	    || last.tv_usec != now.tv_usec) {
		(void)fprintf(ftrace, "-- %s --\n", ts(now.tv_sec));
		last = now;
	}
}


static void
tmsg(char *p, ...)
{
	va_list args;

	if (ftrace != 0) {
		lastlog();
		va_start(args, p);
		vfprintf(ftrace, p, args);
		fflush(ftrace);
		va_end(args);
	}
}


static void
trace_close(void)
{
	int fd;


	fflush(stdout);
	fflush(stderr);

	if (ftrace != 0
	    && savetracename[0] != '\0') {
		fd = open(_PATH_DEVNULL, O_RDWR);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		(void)close(fd);
		fclose(ftrace);
		ftrace = 0;
	}
}


void
trace_flush(void)
{
	if (ftrace != 0) {
		fflush(ftrace);
		if (ferror(ftrace))
			trace_off("tracing off: %s", strerror(ferror(ftrace)));
	}
}


void
trace_off(char *p, ...)
{
	va_list args;


	if (ftrace != 0) {
		lastlog();
		va_start(args, p);
		vfprintf(ftrace, p, args);
		fflush(ftrace);
		va_end(args);
	}
	trace_close();

	new_tracelevel = tracelevel = 0;
}


void
trace_on(char *filename, int trusted)
{
	struct stat stbuf;
	FILE *n_ftrace;


	/* Given a null filename when tracing is already on, increase the
	 * debugging level and re-open the file in case it has been unlinked.
	 */
	if (filename[0] == '\0') {
		if (tracelevel != 0) {
			new_tracelevel++;
			tracelevel_pat = "trace command: %s\n";
		} else if (savetracename[0] == '\0') {
			msglog("missing trace file name");
			return;
		}
		filename = savetracename;

	} else if (!strcmp(filename,"dump/../table")) {
		trace_dump();
		return;

	} else {
		if (stat(filename, &stbuf) >= 0
		    && (stbuf.st_mode & S_IFMT) != S_IFREG) {
			msglog("wrong type (%#x) of trace file \"%s\"",
			       stbuf.st_mode, filename);
			return;
		}

		if (!trusted
#ifdef _PATH_TRACE
		    && (strncmp(filename, _PATH_TRACE, sizeof(_PATH_TRACE)-1)
			|| strstr(filename,"../")
			|| 0 > stat(_PATH_TRACE, &stbuf))
#endif
		    && strcmp(filename, savetracename)) {
			msglog("wrong directory for trace file \"%s\"",
			       filename);
			return;
		}
	}

	n_ftrace = fopen(filename, "a");
	if (n_ftrace == 0) {
		msglog("failed to open trace file \"%s\" %s",
		       filename, strerror(errno));
		return;
	}

	tmsg("switch to trace file %s\n", filename);
	trace_close();
	if (filename != savetracename)
		strlcpy(savetracename, filename, sizeof(savetracename));
	ftrace = n_ftrace;

	fflush(stdout);
	fflush(stderr);
	dup2(fileno(ftrace), STDOUT_FILENO);
	dup2(fileno(ftrace), STDERR_FILENO);

	if (new_tracelevel == 0)
		new_tracelevel = 1;
	set_tracelevel();
}


/* ARGSUSED */
void
sigtrace_on(int s)
{
	new_tracelevel++;
	tracelevel_pat = "SIGUSR1: %s\n";
}


/* ARGSUSED */
void
sigtrace_off(int s)
{
	new_tracelevel--;
	tracelevel_pat = "SIGUSR2: %s\n";
}


/* Move to next higher level of tracing when -t option processed or
 * SIGUSR1 is received.  Successive levels are:
 *	actions
 *	actions + packets
 *	actions + packets + contents
 */
void
set_tracelevel(void)
{
	static char *off_msgs[MAX_TRACELEVEL] = {
		"Tracing actions stopped",
		"Tracing packets stopped",
		"Tracing packet contents stopped",
		"Tracing kernel changes stopped",
	};
	static char *on_msgs[MAX_TRACELEVEL] = {
		"Tracing actions started",
		"Tracing packets started",
		"Tracing packet contents started",
		"Tracing kernel changes started",
	};


	if (new_tracelevel > MAX_TRACELEVEL) {
		new_tracelevel = MAX_TRACELEVEL;
		if (new_tracelevel == tracelevel) {
			tmsg(tracelevel_pat, on_msgs[tracelevel-1]);
			return;
		}
	}
	while (new_tracelevel != tracelevel) {
		if (new_tracelevel < tracelevel) {
			if (--tracelevel == 0)
				trace_off(tracelevel_pat, off_msgs[0]);
			else
				tmsg(tracelevel_pat, off_msgs[tracelevel]);
		} else {
			if (ftrace == 0) {
				if (savetracename[0] != '\0')
					trace_on(savetracename, 1);
				else
					ftrace = stdout;
			}
			tmsg(tracelevel_pat, on_msgs[tracelevel++]);
		}
	}
	tracelevel_pat = "%s\n";
}


/* display an address
 */
char *
addrname(naddr	addr,			/* in network byte order */
	 naddr	mask,
	 int	force)			/* 0=show mask if nonstandard, */
{					/*	1=always show mask, 2=never */
#define NUM_BUFS 4
	static int bufno;
	static struct {
	    char    str[15+20];
	} bufs[NUM_BUFS];
	char *s, *sp;
	naddr dmask;
	size_t l;
	int i;

	strlcpy(bufs[bufno].str, naddr_ntoa(addr),
	    sizeof bufs[bufno].str);
	bufno = (bufno+1) % NUM_BUFS;
	s = bufs[bufno].str;
	l = sizeof(bufs[bufno].str);

	if (force == 1 || (force == 0 && mask != std_mask(addr))) {
		sp = &s[strlen(s)];

		dmask = mask & -mask;
		if (mask + dmask == 0) {
			for (i = 0; i != 32 && ((1<<i) & mask) == 0; i++)
				continue;
			(void)snprintf(sp, s + l - sp, "/%d", 32-i);

		} else {
			(void)snprintf(sp, s + l - sp, " (mask %#x)", (u_int)mask);
		}
	}

	return s;
#undef NUM_BUFS
}


/* display a bit-field
 */
struct bits {
	int	bits_mask;
	int	bits_clear;
	char	*bits_name;
};

static struct bits if_bits[] = {
	{ IFF_LOOPBACK,		0,		"LOOPBACK" },
	{ IFF_POINTOPOINT,	0,		"PT-TO-PT" },
	{ 0,			0,		0}
};

static struct bits is_bits[] = {
	{ IS_SUBNET,		0,		"" },
	{ IS_REMOTE,		0,		"REMOTE" },
	{ IS_PASSIVE,		(IS_NO_RDISC
				 | IS_BCAST_RDISC
				 | IS_NO_RIP
				 | IS_NO_SUPER_AG
				 | IS_PM_RDISC
				 | IS_NO_AG),	"PASSIVE" },
	{ IS_EXTERNAL,		0,		"EXTERNAL" },
	{ IS_CHECKED,		0,		"" },
	{ IS_ALL_HOSTS,		0,		"" },
	{ IS_ALL_ROUTERS,	0,		"" },
	{ IS_RIP_QUERIED,	0,		"" },
	{ IS_BROKE,		IS_SICK,	"BROKEN" },
	{ IS_SICK,		0,		"SICK" },
	{ IS_ACTIVE,		0,		"ACTIVE" },
	{ IS_NEED_NET_SYN,	0,		"" },
	{ IS_NO_AG,		IS_NO_SUPER_AG,	"NO_AG" },
	{ IS_NO_SUPER_AG,	0,		"NO_SUPER_AG" },
	{ (IS_NO_RIPV1_IN
	   | IS_NO_RIPV2_IN
	   | IS_NO_RIPV1_OUT
	   | IS_NO_RIPV2_OUT),	0,		"NO_RIP" },
	{ (IS_NO_RIPV1_IN
	   | IS_NO_RIPV1_OUT),	0,		"RIPV2" },
	{ IS_NO_RIPV1_IN,	0,		"NO_RIPV1_IN" },
	{ IS_NO_RIPV2_IN,	0,		"NO_RIPV2_IN" },
	{ IS_NO_RIPV1_OUT,	0,		"NO_RIPV1_OUT" },
	{ IS_NO_RIPV2_OUT,	0,		"NO_RIPV2_OUT" },
	{ (IS_NO_ADV_IN
	   | IS_NO_SOL_OUT
	   | IS_NO_ADV_OUT),	IS_BCAST_RDISC,	"NO_RDISC" },
	{ IS_NO_SOL_OUT,	0,		"NO_SOLICIT" },
	{ IS_SOL_OUT,		0,		"SEND_SOLICIT" },
	{ IS_NO_ADV_OUT,	IS_BCAST_RDISC,	"NO_RDISC_ADV" },
	{ IS_ADV_OUT,		0,		"RDISC_ADV" },
	{ IS_BCAST_RDISC,	0,		"BCAST_RDISC" },
	{ IS_PM_RDISC,		0,		"PM_RDISC" },
	{ 0,			0,		"%#x"}
};

static struct bits rs_bits[] = {
	{ RS_IF,		0,		"IF" },
	{ RS_NET_INT,		RS_NET_SYN,	"NET_INT" },
	{ RS_NET_SYN,		0,		"NET_SYN" },
	{ RS_SUBNET,		0,		"" },
	{ RS_LOCAL,		0,		"LOCAL" },
	{ RS_MHOME,		0,		"MHOME" },
	{ RS_STATIC,		0,		"STATIC" },
	{ RS_RDISC,		0,		"RDISC" },
	{ 0,			0,		"%#x"}
};


static void
trace_bits(struct bits *tbl, u_int field, int force)
{
	int b;
	char c;

	if (force) {
		(void)putc('<', ftrace);
		c = 0;
	} else {
		c = '<';
	}

	while (field != 0
	       && (b = tbl->bits_mask) != 0) {
		if ((b & field) == b) {
			if (tbl->bits_name[0] != '\0') {
				if (c)
					(void)putc(c, ftrace);
				(void)fprintf(ftrace, "%s", tbl->bits_name);
				c = '|';
			}
			if (0 == (field &= ~(b | tbl->bits_clear)))
				break;
		}
		tbl++;
	}
	if (field != 0 && tbl->bits_name != 0) {
		if (c)
			(void)putc(c, ftrace);
		(void)fprintf(ftrace, tbl->bits_name, field);
		c = '|';
	}

	if (c != '<' || force)
		(void)fputs("> ", ftrace);
}


static char *
trace_pair(naddr dst, naddr mask, char *gate)
{
	static char buf[3*4+3+1+2+3	/* "xxx.xxx.xxx.xxx/xx-->" */
			+3*4+3+1];	/* "xxx.xxx.xxx.xxx" */
	int i;

	i = snprintf(buf, sizeof buf, "%-16s-->", addrname(dst, mask, 0));
	if (i >= sizeof buf || i == -1)
		return buf;
	(void)snprintf(&buf[i], sizeof buf - i, "%-*s", 15+20-MAX(20,i), gate);
	return buf;
}


void
trace_if(char *act, struct interface *ifp)
{
	if (!TRACEACTIONS || ftrace == 0)
		return;

	lastlog();
	(void)fprintf(ftrace, "%s interface %-4s ", act, ifp->int_name);
	(void)fprintf(ftrace, "%-15s-->%-15s ",
		      naddr_ntoa(ifp->int_addr),
		      addrname(htonl((ifp->int_if_flags & IFF_POINTOPOINT)
				     ? ifp->int_dstaddr
				     : ifp->int_net),
			       ifp->int_mask, 1));
	if (ifp->int_metric != 0)
		(void)fprintf(ftrace, "metric=%d ", ifp->int_metric);
	trace_bits(if_bits, ifp->int_if_flags, 0);
	trace_bits(is_bits, ifp->int_state, 0);
	(void)fputc('\n',ftrace);
}


void
trace_upslot(struct rt_entry *rt, struct rt_spare *rts, naddr gate,
    naddr router, struct interface *ifp, int metric, u_short tag,
    time_t new_time)
{
	if (!TRACEACTIONS || ftrace == 0)
		return;
	if (rts->rts_gate == gate
	    && rts->rts_router == router
	    && rts->rts_metric == metric
	    && rts->rts_tag == tag)
		return;

	lastlog();
	if (rts->rts_gate != RIP_DEFAULT) {
		(void)fprintf(ftrace, "Chg #%d %-35s ",
			      rts - rt->rt_spares,
			      trace_pair(rt->rt_dst, rt->rt_mask,
					 naddr_ntoa(rts->rts_gate)));
		if (rts->rts_gate != rts->rts_gate)
			(void)fprintf(ftrace, "router=%s ",
				      naddr_ntoa(rts->rts_gate));
		if (rts->rts_tag != 0)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(rts->rts_tag));
		(void)fprintf(ftrace, "metric=%-2d ", rts->rts_metric);
		if (rts->rts_ifp != 0)
			(void)fprintf(ftrace, "%s ",
				      rts->rts_ifp->int_name);
		(void)fprintf(ftrace, "%s\n", ts(rts->rts_time));

		(void)fprintf(ftrace, "       %19s%-16s ",
			      "",
			      gate != rts->rts_gate ? naddr_ntoa(gate) : "");
		if (gate != router)
			(void)fprintf(ftrace,"router=%s ",naddr_ntoa(router));
		if (tag != rts->rts_tag)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
		if (metric != rts->rts_metric)
			(void)fprintf(ftrace, "metric=%-2d ", metric);
		if (ifp != rts->rts_ifp && ifp != 0 )
			(void)fprintf(ftrace, "%s ", ifp->int_name);
		(void)fprintf(ftrace, "%s\n",
			      new_time != rts->rts_time ? ts(new_time) : "");

	} else {
		(void)fprintf(ftrace, "Add #%d %-35s ",
			      rts - rt->rt_spares,
			      trace_pair(rt->rt_dst, rt->rt_mask,
					 naddr_ntoa(gate)));
		if (gate != router)
			(void)fprintf(ftrace, "router=%s ", naddr_ntoa(gate));
		if (tag != 0)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
		(void)fprintf(ftrace, "metric=%-2d ", metric);
		if (ifp != 0)
			(void)fprintf(ftrace, "%s ", ifp->int_name);
		(void)fprintf(ftrace, "%s\n", ts(new_time));
	}
}


/* talk about a change made to the kernel table
 */
void
trace_kernel(char *p, ...)
{
	va_list args;

	if (!TRACEKERNEL || ftrace == 0)
		return;

	lastlog();
	va_start(args, p);
	vfprintf(ftrace, p, args);
	va_end(args);
}


/* display a message if tracing actions
 */
void
trace_act(char *p, ...)
{
	va_list args;

	if (!TRACEACTIONS || ftrace == 0)
		return;

	lastlog();
	va_start(args, p);
	vfprintf(ftrace, p, args);
	va_end(args);
}


/* display a message if tracing packets
 */
void
trace_pkt(char *p, ...)
{
	va_list args;

	if (!TRACEPACKETS || ftrace == 0)
		return;

	lastlog();
	va_start(args, p);
	vfprintf(ftrace, p, args);
	va_end(args);
}


void
trace_change(struct rt_entry *rt,
	     u_int	state,
	     naddr	gate,		/* forward packets here */
	     naddr	router,		/* on the authority of this router */
	     int	metric,
	     u_short	tag,
	     struct interface *ifp,
	     time_t	new_time,
	     char	*label)
{
	if (ftrace == 0)
		return;

	if (rt->rt_metric == metric
	    && rt->rt_gate == gate
	    && rt->rt_router == router
	    && rt->rt_state == state
	    && rt->rt_tag == tag)
		return;

	lastlog();
	(void)fprintf(ftrace, "%s %-35s metric=%-2d ",
		      label,
		      trace_pair(rt->rt_dst, rt->rt_mask,
				 naddr_ntoa(rt->rt_gate)),
		      rt->rt_metric);
	if (rt->rt_router != rt->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rt->rt_router));
	if (rt->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(rt->rt_tag));
	trace_bits(rs_bits, rt->rt_state, rt->rt_state != state);
	(void)fprintf(ftrace, "%s ",
		      rt->rt_ifp == 0 ? "?" : rt->rt_ifp->int_name);
	(void)fprintf(ftrace, "%s\n",
		      AGE_RT(rt->rt_state, rt->rt_ifp) ? ts(rt->rt_time) : "");

	(void)fprintf(ftrace, "%*s %19s%-16s ",
		      (int)strlen(label), "", "",
		      rt->rt_gate != gate ? naddr_ntoa(gate) : "");
	if (rt->rt_metric != metric)
		(void)fprintf(ftrace, "metric=%-2d ", metric);
	if (router != gate)
		(void)fprintf(ftrace, "router=%s ", naddr_ntoa(router));
	if (rt->rt_tag != tag)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
	if (rt->rt_state != state)
		trace_bits(rs_bits, state, 1);
	if (rt->rt_ifp != ifp)
		(void)fprintf(ftrace, "%s ",
			      ifp != 0 ? ifp->int_name : "?");
	(void)fprintf(ftrace, "%s\n",
		      ((rt->rt_time == new_time || !AGE_RT(rt->rt_state, ifp))
		       ? "" : ts(new_time)));
}


void
trace_add_del(char * action, struct rt_entry *rt)
{
	u_int state = rt->rt_state;

	if (ftrace == 0)
		return;

	lastlog();
	(void)fprintf(ftrace, "%s    %-35s metric=%-2d ",
		      action,
		      trace_pair(rt->rt_dst, rt->rt_mask,
				 naddr_ntoa(rt->rt_gate)),
		      rt->rt_metric);
	if (rt->rt_router != rt->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rt->rt_router));
	if (rt->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(rt->rt_tag));
	trace_bits(rs_bits, state, 0);
	(void)fprintf(ftrace, "%s ",
		      rt->rt_ifp != 0 ? rt->rt_ifp->int_name : "?");
	(void)fprintf(ftrace, "%s\n", ts(rt->rt_time));
}


/* ARGSUSED */
static int
walk_trace(struct radix_node *rn,
	   void *w)
{
#define RT ((struct rt_entry *)rn)
	struct rt_spare *rts;
	int i, age;

	(void)fprintf(ftrace, "  %-35s metric=%-2d ",
		      trace_pair(RT->rt_dst, RT->rt_mask,
				 naddr_ntoa(RT->rt_gate)),
		      RT->rt_metric);
	if (RT->rt_router != RT->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(RT->rt_router));
	if (RT->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ",
			      ntohs(RT->rt_tag));
	trace_bits(rs_bits, RT->rt_state, 0);
	(void)fprintf(ftrace, "%s ",
		      RT->rt_ifp == 0 ? "?" : RT->rt_ifp->int_name);
	age = AGE_RT(RT->rt_state, RT->rt_ifp);
	if (age)
		(void)fprintf(ftrace, "%s", ts(RT->rt_time));

	rts = &RT->rt_spares[1];
	for (i = 1; i < NUM_SPARES; i++, rts++) {
		if (rts->rts_metric != HOPCNT_INFINITY) {
			(void)fprintf(ftrace,"\n    #%d%15s%-16s metric=%-2d ",
				      i, "", naddr_ntoa(rts->rts_gate),
				      rts->rts_metric);
			if (rts->rts_router != rts->rts_gate)
				(void)fprintf(ftrace, "router=%s ",
					      naddr_ntoa(rts->rts_router));
			if (rts->rts_tag != 0)
				(void)fprintf(ftrace, "tag=%#x ",
					      ntohs(rts->rts_tag));
			(void)fprintf(ftrace, "%s ",
				      (rts->rts_ifp == 0
				       ? "?" : rts->rts_ifp->int_name));
			if (age)
				(void)fprintf(ftrace, "%s", ts(rts->rts_time));
		}
	}
	(void)fputc('\n',ftrace);

	return 0;
}


static void
trace_dump(void)
{
	if (ftrace == 0)
		return;
	lastlog();

	(void)rn_walktree(rhead, walk_trace, 0);
}


void
trace_rip(char *dir1, char *dir2,
	  struct sockaddr_in *who,
	  struct interface *ifp,
	  struct rip *msg,
	  int size)			/* total size of message */
{
	struct netinfo *n, *lim;
	struct netauth *a;
	int i;

	if (!TRACEPACKETS || ftrace == 0)
		return;

	lastlog();
	if (msg->rip_cmd >= RIPCMD_MAX
	    || msg->rip_vers == 0) {
		(void)fprintf(ftrace, "%s bad RIPv%d cmd=%d %s"
			      " %s.%d size=%d\n",
			      dir1, msg->rip_vers, msg->rip_cmd, dir2,
			      naddr_ntoa(who->sin_addr.s_addr),
			      ntohs(who->sin_port),
			      size);
		return;
	}

	(void)fprintf(ftrace, "%s RIPv%d %s %s %s.%d%s%s\n",
		      dir1, msg->rip_vers, ripcmds[msg->rip_cmd], dir2,
		      naddr_ntoa(who->sin_addr.s_addr), ntohs(who->sin_port),
		      ifp ? " via " : "", ifp ? ifp->int_name : "");
	if (!TRACECONTENTS)
		return;

	switch (msg->rip_cmd) {
	case RIPCMD_REQUEST:
	case RIPCMD_RESPONSE:
		n = msg->rip_nets;
		lim = (struct netinfo *)((char*)msg + size);
		for (; n < lim; n++) {
			if (n->n_family == RIP_AF_UNSPEC
			    && ntohl(n->n_metric) == HOPCNT_INFINITY
			    && n+1 == lim
			    && n == msg->rip_nets
			    && msg->rip_cmd == RIPCMD_REQUEST) {
				(void)fputs("\tQUERY ", ftrace);
				if (n->n_dst != 0)
					(void)fprintf(ftrace, "%s ",
						      naddr_ntoa(n->n_dst));
				if (n->n_mask != 0)
					(void)fprintf(ftrace, "mask=%#x ",
						      (u_int)ntohl(n->n_mask));
				if (n->n_nhop != 0)
					(void)fprintf(ftrace, " nhop=%s ",
						      naddr_ntoa(n->n_nhop));
				if (n->n_tag != 0)
					(void)fprintf(ftrace, "tag=%#x",
						      ntohs(n->n_tag));
				(void)fputc('\n',ftrace);
				continue;
			}

			if (n->n_family == RIP_AF_AUTH) {
				a = (struct netauth*)n;
				(void)fprintf(ftrace,
					      "\tAuthentication type %d: ",
					      ntohs(a->a_type));
				for (i = 0;
				     i < sizeof(a->au.au_pw);
				     i++)
					(void)fprintf(ftrace, "%02x ",
						      a->au.au_pw[i]);
				(void)fputc('\n',ftrace);
				continue;
			}

			if (n->n_family != RIP_AF_INET) {
				(void)fprintf(ftrace,
					      "\t(af %d) %-18s mask=%#x",
					      ntohs(n->n_family),
					      naddr_ntoa(n->n_dst),
					      (u_int)ntohl(n->n_mask));
			} else if (msg->rip_vers == RIPv1) {
				(void)fprintf(ftrace, "\t%-18s ",
					      addrname(n->n_dst,
						       ntohl(n->n_mask),
						       n->n_mask==0 ? 2 : 1));
			} else {
				(void)fprintf(ftrace, "\t%-18s ",
					      addrname(n->n_dst,
						       ntohl(n->n_mask),
						       n->n_mask==0 ? 2 : 0));
			}
			(void)fprintf(ftrace, "metric=%-2d ",
				      (u_int)ntohl(n->n_metric));
			if (n->n_nhop != 0)
				(void)fprintf(ftrace, " nhop=%s ",
					      naddr_ntoa(n->n_nhop));
			if (n->n_tag != 0)
				(void)fprintf(ftrace, "tag=%#x",
					      ntohs(n->n_tag));
			(void)fputc('\n',ftrace);
		}
		if (size != (char *)n - (char *)msg)
			(void)fprintf(ftrace, "truncated record, len %d\n",
				size);
		break;

	case RIPCMD_TRACEON:
		fprintf(ftrace, "\tfile=%*s\n", size-4, msg->rip_tracefile);
		break;

	case RIPCMD_TRACEOFF:
		break;
	}
}
@


1.16
log
@printf field widths are always int, so add a cast to remove
"warning: field width is not type int"

"looks good" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.15 2005/04/12 15:26:47 cloder Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.15 2005/04/12 15:26:47 cloder Exp $";
@


1.15
log
@A little bit of cleanup (missing format string arguments, some signed/
unsigned conversion). OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.14 2003/07/03 02:47:03 avsm Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.14 2003/07/03 02:47:03 avsm Exp $";
d665 1
a665 1
		      strlen(label), "", "",
@


1.14
log
@strncpy->strlcpy
krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.13 2003/06/11 06:22:15 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.13 2003/06/11 06:22:15 deraadt Exp $";
d166 1
a166 1
			trace_off("tracing off: ", strerror(ferror(ftrace)));
@


1.13
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.12 2003/06/02 20:06:17 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.12 2003/06/02 20:06:17 millert Exp $";
d58 1
a58 1
char savetracename[MAXPATHLEN+1];
d245 1
a245 1
		strncpy(savetracename, filename, sizeof(savetracename)-1);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.11 2003/04/21 02:06:52 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.11 2003/04/21 02:06:52 deraadt Exp $";
d92 2
a93 1
ts(time_t secs) {
d191 1
a191 2
trace_on(char *filename,
	 int trusted)
d439 1
a439 3
trace_bits(struct bits *tbl,
	   u_int field,
	   int force)
d478 1
a478 3
trace_pair(naddr dst,
	   naddr mask,
	   char *gate)
d493 1
a493 2
trace_if(char *act,
	  struct interface *ifp)
d515 3
a517 8
trace_upslot(struct rt_entry *rt,
	     struct rt_spare *rts,
	     naddr	gate,
	     naddr	router,
	     struct interface *ifp,
	     int	metric,
	     u_short	tag,
	     time_t	new_time)
@


1.11
log
@a few string cleanups; ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.10 2003/03/13 09:09:27 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.10 2003/03/13 09:09:27 deraadt Exp $";
@


1.10
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.9 2001/09/05 22:32:38 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.9 2001/09/05 22:32:38 deraadt Exp $";
d345 1
d352 1
d361 1
a361 1
			(void)sprintf(sp, "/%d", 32-i);
d364 1
a364 1
			(void)sprintf(sp, " (mask %#x)", (u_int)mask);
d493 1
a493 1
	if (i >= sizeof buf)
@


1.9
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.8 1997/07/30 23:28:46 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.8 1997/07/30 23:28:46 deraadt Exp $";
a76 1
	char *s;
d80 2
a81 1
	s = strcpy(bufs[bufno].str, inet_ntoa(addr));
d83 1
a83 1
	return s;
d347 2
a348 1
	s = strcpy(bufs[bufno].str, naddr_ntoa(addr));
d350 1
d490 4
a493 2
	i = sprintf(buf, "%-16s-->", addrname(dst, mask, 0));
	(void)sprintf(&buf[i], "%-*s", 15+20-MAX(20,i), gate);
@


1.8
log
@new routed DOES NOT EVEN COMPILE LET ALONE WORK.  TEST YOUR WORK!
Also, put back the damn security check in input.c that has been deleted
TWO SEPERATE TIMES NOW!  I CURSE anyone who deletes that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.6 1997/02/27 08:31:28 angelos Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.6 1997/02/27 08:31:28 angelos Exp $";
d137 1
d185 1
d596 1
d613 1
d630 1
@


1.7
log
@update to sgi-02apr97
still have problems w/ defaults from pppd
@
text
@d58 1
a58 1
int	tracelevel, new_tracelevel;
d60 3
a62 4
static char *sigtrace_pat = "%s";
static char savetracename[MAXPATHLEN+1];
char	inittracename[MAXPATHLEN+1];
int	file_trace;			/* 1=tracing to file, not stdout */
a66 53
/* convert string to printable characters
 */
static char *
qstring(u_char *s, int len)
{
	static char buf[8*20+1];
	char *p;
	u_char *s2, c;


	for (p = buf; len != 0 && p < &buf[sizeof(buf)-1]; len--) {
		c = *s++;
		if (c == '\0') {
			for (s2 = s+1; s2 < &s[len]; s2++) {
				if (*s2 != '\0')
					break;
			}
			if (s2 >= &s[len])
			    goto exit;
		}

		if (c >= ' ' && c < 0x7f && c != '\\') {
			*p++ = c;
			continue;
		}
		*p++ = '\\';
		switch (c) {
		case '\\':
			*p++ = '\\';
			break;
		case '\n':
			*p++= 'n';
			break;
		case '\r':
			*p++= 'r';
			break;
		case '\t':
			*p++ = 't';
			break;
		case '\b':
			*p++ = 'b';
			break;
		default:
			p += sprintf(p,"%o",c);
			break;
		}
	}
exit:
	*p = '\0';
	return buf;
}


a113 2
static struct timeval lastlog_time;

d117 4
a120 2
	if (lastlog_time.tv_sec != now.tv_sec
	    || lastlog_time.tv_usec != now.tv_usec) {
d122 1
a122 1
		lastlog_time = now;
a135 1
		(void)fputc('\n',ftrace);
d150 2
a151 4
	if (ftrace != 0 && file_trace) {
		if (ftrace != stdout)
			fclose(ftrace);
		ftrace = 0;
a152 1
		(void)dup2(fd, STDIN_FILENO);
d156 2
a158 1
	lastlog_time.tv_sec = 0;
d183 1
a183 1
		(void)fputc('\n',ftrace);
a190 2
/* log a change in tracing
 */
d192 2
a193 47
tracelevel_msg(char *pat,
	       int dump)		/* -1=no dump, 0=default, 1=force */
{
	static char *off_msgs[MAX_TRACELEVEL] = {
		"Tracing actions stopped",
		"Tracing packets stopped",
		"Tracing packet contents stopped",
		"Tracing kernel changes stopped",
	};
	static char *on_msgs[MAX_TRACELEVEL] = {
		"Tracing actions started",
		"Tracing packets started",
		"Tracing packet contents started",
		"Tracing kernel changes started",
	};
	u_int old_tracelevel = tracelevel;


	if (new_tracelevel < 0)
		new_tracelevel = 0;
	else if (new_tracelevel > MAX_TRACELEVEL)
		new_tracelevel = MAX_TRACELEVEL;

	if (new_tracelevel < tracelevel) {
		if (new_tracelevel <= 0) {
			trace_off(pat, off_msgs[0]);
		} else do {
			tmsg(pat, off_msgs[tracelevel]);
		}
		while (--tracelevel != new_tracelevel);

	} else if (new_tracelevel > tracelevel) {
		do {
			tmsg(pat, on_msgs[tracelevel++]);
		} while (tracelevel != new_tracelevel);
	}

	if (dump > 0
	    || (dump == 0 && old_tracelevel == 0 && tracelevel != 0))
		trace_dump();
}


void
set_tracefile(char *filename,
	      char *pat,
	      int dump)			/* -1=no dump, 0=default, 1=force */
a196 1
	char *fn;
d199 2
a200 3
	/* Allow a null filename to increase the level if the trace file
	 * is already open or if coming from a trusted source, such as
	 * a signal or the command line.
d202 7
a208 10
	if (filename == 0 || filename[0] == '\0') {
		filename = 0;
		if (ftrace == 0) {
			if (inittracename[0] == '\0') {
				msglog("missing trace file name");
				return;
			}
			fn = inittracename;
		} else {
			fn = 0;
d210 1
a216 18
		/* Allow the file specified with "-T file" to be reopened,
		 * but require all other names specified over the net to
		 * match the official path.  The path can specify a directory
		 * in which the file is to be created.
		 */
		if (strcmp(filename, inittracename)
#ifdef _PATH_TRACE
		    && (strncmp(filename, _PATH_TRACE, sizeof(_PATH_TRACE)-1)
			|| strstr(filename,"../")
			|| 0 > stat(_PATH_TRACE, &stbuf))
#endif
		    ) {
			msglog("wrong trace file \"%s\"", filename);
			return;
		}

		/* If the new tracefile exists, it must be a regular file.
		 */
d224 9
a232 10
		fn = filename;
	}

	if (fn != 0) {
		n_ftrace = fopen(fn, "a");
		if (n_ftrace == 0) {
			msglog("failed to open trace file \"%s\" %s",
			       fn, strerror(errno));
			if (fn == inittracename)
				inittracename[0] = '\0';
d235 1
d237 6
a242 1
		tmsg("switch to trace file %s", fn);
d244 5
a248 2
		file_trace = 1;
		trace_close();
d250 4
a253 9
		if (fn != savetracename)
			strncpy(savetracename, fn, sizeof(savetracename)-1);
		ftrace = n_ftrace;

		fflush(stdout);
		fflush(stderr);
		dup2(fileno(ftrace), STDOUT_FILENO);
		dup2(fileno(ftrace), STDERR_FILENO);
	}
d255 3
a257 3
	if (new_tracelevel == 0 || filename == 0)
		new_tracelevel++;
	tracelevel_msg(pat, dump != 0 ? dump : (filename != 0));
d266 1
a266 1
	sigtrace_pat = "SIGUSR1: %s";
d275 1
a275 1
	sigtrace_pat = "SIGUSR2: %s";
d279 5
a283 1
/* Set tracing after a signal.
d288 13
a300 2
	if (new_tracelevel == tracelevel)
		return;
d302 13
a314 8
	/* If tracing entirely off, and there was no tracefile specified
	 * on the command line, then leave it off.
	 */
	if (new_tracelevel > tracelevel && ftrace == 0) {
		if (savetracename[0] != '\0') {
			set_tracefile(savetracename,sigtrace_pat,0);
		} else if (inittracename[0] != '\0') {
				set_tracefile(inittracename,sigtrace_pat,0);
d316 7
a322 2
			new_tracelevel = 0;
			return;
a323 2
	} else {
		tracelevel_msg(sigtrace_pat, 0);
d325 1
a381 1
	{ IS_ALIAS,		0,		"ALIAS" },
d383 1
a383 2
	{ IS_REMOTE,		(IS_NO_RDISC
				 | IS_BCAST_RDISC), "REMOTE" },
d385 1
d394 1
a394 1
	{ IS_DISTRUST,		0,		"DISTRUST" },
d397 1
a397 2
	{ IS_DUP,		0,		"DUPLICATE" },
	{ IS_REDIRECT_OK,	0,		"REDIRECT_OK" },
d419 1
a419 1
	{ IS_PM_RDISC,		0,		"" },
d477 4
a480 4
char *
rtname(naddr dst,
       naddr mask,
       naddr gate)
d487 1
a487 1
	(void)sprintf(&buf[i], "%-*s", 15+20-MAX(20,i), naddr_ntoa(gate));
a491 26
static void
print_rts(struct rt_spare *rts,
	  int force_metric,		/* -1=suppress, 0=default */
	  int force_ifp,		/* -1=suppress, 0=default */
	  int force_router,		/* -1=suppress, 0=default, 1=display */
	  int force_tag,		/* -1=suppress, 0=default, 1=display */
	  int force_time)		/* 0=suppress, 1=display */
{
	if (force_metric >= 0)
		(void)fprintf(ftrace, "metric=%-2d ", rts->rts_metric);
	if (force_ifp >= 0)
		(void)fprintf(ftrace, "%s ", (rts->rts_ifp == 0 ?
					      "if?" : rts->rts_ifp->int_name));
	if (force_router > 0
	    || (force_router == 0 && rts->rts_router != rts->rts_gate))
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rts->rts_router));
	if (force_time > 0)
		(void)fprintf(ftrace, "%s ", ts(rts->rts_time));
	if (force_tag > 0
	    || (force_tag == 0 && rts->rts_tag != 0))
		(void)fprintf(ftrace, "tag=%#x ",
			      ntohs(rts->rts_tag));
}


d500 1
a500 1
	(void)fprintf(ftrace, "%-3s interface %-4s ", act, ifp->int_name);
d503 3
a505 3
		      addrname(((ifp->int_if_flags & IFF_POINTOPOINT)
				? ifp->int_dstaddr
				: htonl(ifp->int_net)),
a508 3
	if (!IS_RIP_OUT_OFF(ifp->int_state)
	    && ifp->int_d_metric != 0)
		(void)fprintf(ftrace, "fake_default=%d ", ifp->int_d_metric);
a524 2
	struct rt_spare new;

a526 1

a531 6
	new.rts_ifp = ifp;
	new.rts_gate = gate;
	new.rts_router = router;
	new.rts_metric = metric;
	new.rts_time = new_time;
	new.rts_tag = tag;
d534 1
a534 8
	if (gate == 0) {
		(void)fprintf(ftrace, "Del #%d %-35s ",
			      rts - rt->rt_spares,
			      rtname(rt->rt_dst, rt->rt_mask, rts->rts_gate));
		print_rts(&new, 0,0,0,0,
			  rts != rt->rt_spares || AGE_RT(rt->rt_state,ifp));

	} else if (rts->rts_gate != RIP_DEFAULT) {
d537 12
a548 6
			      rtname(rt->rt_dst, rt->rt_mask, rts->rts_gate));
		print_rts(rts, 0,0,
			  rts->rts_gate != gate,
			  rts->rts_tag != tag,
			  rts != rt->rt_spares || AGE_RT(rt->rt_state,
							rt->rt_ifp));
d550 2
a551 1
		(void)fprintf(ftrace, "\n       %19s%-16s ", "",
d553 10
a562 8
		print_rts(&new,
			  -(metric == rts->rts_metric),
			  -(ifp == rts->rts_ifp),
			  0,
			  rts->rts_tag != tag,
			  new_time != rts->rts_time && (rts != rt->rt_spares
							|| AGE_RT(rt->rt_state,
							    ifp)));
d567 10
a576 3
			      rtname(rt->rt_dst, rt->rt_mask, gate));
		print_rts(&new, 0,0,0,0,
			  rts != rt->rt_spares || AGE_RT(rt->rt_state,ifp));
a577 1
	(void)fputc('\n',ftrace);
a593 1
	(void)fputc('\n',ftrace);
a609 1
	(void)fputc('\n',ftrace);
a625 1
	(void)fputc('\n',ftrace);
a639 2
	struct rt_spare new;

a648 6
	new.rts_ifp = ifp;
	new.rts_gate = gate;
	new.rts_router = router;
	new.rts_metric = metric;
	new.rts_time = new_time;
	new.rts_tag = tag;
d651 1
a651 1
	(void)fprintf(ftrace, "%s %-35s ",
d653 8
a660 3
		      rtname(rt->rt_dst, rt->rt_mask, rt->rt_gate));
	print_rts(rt->rt_spares,
		  0,0,0,0, AGE_RT(rt->rt_state, rt->rt_ifp));
d662 4
d667 1
a667 1
	(void)fprintf(ftrace, "\n%*s %19s%-16s ",
d670 6
a675 6
	print_rts(&new,
		  -(metric == rt->rt_metric),
		  -(ifp == rt->rt_ifp),
		  0,
		  rt->rt_tag != tag,
		  rt->rt_time != new_time && AGE_RT(rt->rt_state,ifp));
d678 6
a683 1
	(void)fputc('\n',ftrace);
d690 2
d696 1
a696 1
	(void)fprintf(ftrace, "%s    %-35s ",
d698 12
a709 4
		      rtname(rt->rt_dst, rt->rt_mask, rt->rt_gate));
	print_rts(rt->rt_spares, 0,0,0,0,AGE_RT(rt->rt_state,rt->rt_ifp));
	trace_bits(rs_bits, rt->rt_state, 0);
	(void)fputc('\n',ftrace);
d720 1
a720 1
	int i, age = AGE_RT(RT->rt_state, RT->rt_ifp);
d722 10
a731 3
	(void)fprintf(ftrace, "  %-35s ",
		      rtname(RT->rt_dst, RT->rt_mask, RT->rt_gate));
	print_rts(&RT->rt_spares[0], 0,0,0,0,age);
d733 5
a737 4
	if (RT->rt_poison_time >= now_garbage
	    && RT->rt_poison_metric < RT->rt_metric)
		(void)fprintf(ftrace, "pm=%d@@%s",
			      RT->rt_poison_metric, ts(RT->rt_poison_time));
d741 15
a755 4
		if (rts->rts_gate != RIP_DEFAULT) {
			(void)fprintf(ftrace,"\n    #%d%15s%-16s ",
				      i, "", naddr_ntoa(rts->rts_gate));
			print_rts(rts, 0,0,0,0,1);
a766 2
	struct interface *ifp;

a770 3
	(void)fputs("current daemon state:\n", ftrace);
	for (ifp = ifnet; ifp != 0; ifp = ifp->int_next)
		trace_if("", ifp);
d783 2
a784 2
#	define NA (msg->rip_auths)
	int i, seen_route;
a807 1
	seen_route = 0;
d814 1
a814 2
			if (!seen_route
			    && n->n_family == RIP_AF_UNSPEC
d816 3
a818 4
			    && msg->rip_cmd == RIPCMD_REQUEST
			    && (n+1 == lim
				|| (n+2 == lim
				    && (n+1)->n_family == RIP_AF_AUTH))) {
d827 1
a827 1
					(void)fprintf(ftrace, "nhop=%s ",
d830 1
a830 1
					(void)fprintf(ftrace, "tag=%#x ",
d837 1
a837 24
				if (NA->a_type == RIP_AUTH_PW
				    && n == msg->rip_nets) {
					(void)fprintf(ftrace, "\tPassword"
						      " Authentication:"
						      " \"%s\"\n",
						      qstring(NA->au.au_pw,
							  RIP_AUTH_PW_LEN));
					continue;
				}

				if (NA->a_type == RIP_AUTH_MD5
				    && n == msg->rip_nets) {
					(void)fprintf(ftrace,
						      "\tMD5 Authentication"
						      " len=%d KeyID=%u"
						      " seqno=%u"
						      " rsvd=%#x,%#x\n",
						      NA->au.a_md5.md5_pkt_len,
						      NA->au.a_md5.md5_keyid,
						      NA->au.a_md5.md5_seqno,
						      NA->au.a_md5.rsvd[0],
						      NA->au.a_md5.rsvd[1]);
					continue;
				}
d839 2
a840 3
					      "\tAuthentication"
					      " type %d: ",
					      ntohs(NA->a_type));
d842 1
a842 1
				     i < sizeof(NA->au.au_pw);
d845 1
a845 1
						      NA->au.au_pw[i]);
a849 1
			seen_route = 1;
d852 1
a852 1
					      "\t(af %d) %-18s mask=%#x ",
d883 1
a883 2
		fprintf(ftrace, "\tfile=\"%.*s\"\n", size-4,
			msg->rip_tracefile);
@


1.6
log
@Fix function decl, get rid of a couple of warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.4 1996/09/06 13:05:02 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.4 1996/09/06 13:05:02 deraadt Exp $";
d58 1
a58 1
u_int	tracelevel, new_tracelevel;
d60 4
a63 1
static char *tracelevel_pat = "%s\n";
d65 23
a87 1
char savetracename[MAXPATHLEN+1];
d89 30
a118 1
static void trace_dump(void);
d168 2
d173 2
a174 4
	static struct timeval last;

	if (last.tv_sec != now.tv_sec
	    || last.tv_usec != now.tv_usec) {
d176 1
a176 1
		last = now;
d190 1
d205 4
a208 2
	if (ftrace != 0
	    && savetracename[0] != '\0') {
d210 1
a213 2
		fclose(ftrace);
		ftrace = 0;
d215 1
d240 1
a240 1
		fflush(ftrace);
d248 2
d251 47
a297 2
trace_on(char *filename,
	 int trusted)
d301 1
d304 3
a306 2
	/* Given a null filename when tracing is already on, increase the
	 * debugging level and re-open the file in case it has been unlinked.
d308 10
a317 7
	if (filename[0] == '\0') {
		if (tracelevel != 0) {
			new_tracelevel++;
			tracelevel_pat = "trace command: %s\n";
		} else if (savetracename[0] == '\0') {
			msglog("missing trace file name");
			return;
a318 1
		filename = savetracename;
d325 18
d350 10
a359 9
		if (!trusted
#ifdef _PATH_TRACE
		    && (strncmp(filename, _PATH_TRACE, sizeof(_PATH_TRACE)-1)
			|| strstr(filename,"../")
			|| 0 > stat(_PATH_TRACE, &stbuf))
#endif
		    && strcmp(filename, savetracename)) {
			msglog("wrong directory for trace file \"%s\"",
			       filename);
a361 1
	}
d363 4
a366 6
	n_ftrace = fopen(filename, "a");
	if (n_ftrace == 0) {
		msglog("failed to open trace file \"%s\" %s",
		       filename, strerror(errno));
		return;
	}
d368 3
a370 5
	tmsg("switch to trace file %s\n", filename);
	trace_close();
	if (filename != savetracename)
		strncpy(savetracename, filename, sizeof(savetracename)-1);
	ftrace = n_ftrace;
d372 5
a376 4
	fflush(stdout);
	fflush(stderr);
	dup2(fileno(ftrace), STDOUT_FILENO);
	dup2(fileno(ftrace), STDERR_FILENO);
d378 3
a380 3
	if (new_tracelevel == 0)
		new_tracelevel = 1;
	set_tracelevel();
d389 1
a389 1
	tracelevel_pat = "SIGUSR1: %s\n";
d398 1
a398 1
	tracelevel_pat = "SIGUSR2: %s\n";
d402 1
a402 5
/* Move to next higher level of tracing when -t option processed or
 * SIGUSR1 is received.  Successive levels are:
 *	actions
 *	actions + packets
 *	actions + packets + contents
d407 2
a408 12
	static char *off_msgs[MAX_TRACELEVEL] = {
		"Tracing actions stopped",
		"Tracing packets stopped",
		"Tracing packet contents stopped",
		"Tracing kernel changes stopped",
	};
	static char *on_msgs[MAX_TRACELEVEL] = {
		"Tracing actions started",
		"Tracing packets started",
		"Tracing packet contents started",
		"Tracing kernel changes started",
	};
d410 10
a419 5

	if (new_tracelevel > MAX_TRACELEVEL) {
		new_tracelevel = MAX_TRACELEVEL;
		if (new_tracelevel == tracelevel) {
			tmsg(tracelevel_pat, on_msgs[tracelevel-1]);
d422 2
a424 17
	while (new_tracelevel != tracelevel) {
		if (new_tracelevel < tracelevel) {
			if (--tracelevel == 0)
				trace_off(tracelevel_pat, off_msgs[0]);
			else
				tmsg(tracelevel_pat, off_msgs[tracelevel]);
		} else {
			if (ftrace == 0) {
				if (savetracename[0] != '\0')
					trace_on(savetracename, 1);
				else
					ftrace = stdout;
			}
			tmsg(tracelevel_pat, on_msgs[tracelevel++]);
		}
	}
	tracelevel_pat = "%s\n";
d481 1
d483 2
a484 1
	{ IS_REMOTE,		0,		"REMOTE" },
a485 1
				 | IS_BCAST_RDISC
d494 1
a494 1
	{ IS_RIP_QUERIED,	0,		"" },
d497 2
a498 1
	{ IS_ACTIVE,		0,		"ACTIVE" },
d520 1
a520 1
	{ IS_PM_RDISC,		0,		"PM_RDISC" },
d578 4
a581 4
static char *
trace_pair(naddr dst,
	   naddr mask,
	   char *gate)
d588 1
a588 1
	(void)sprintf(&buf[i], "%-*s", 15+20-MAX(20,i), gate);
d593 26
d627 1
a627 1
	(void)fprintf(ftrace, "%s interface %-4s ", act, ifp->int_name);
d630 3
a632 3
		      addrname(htonl((ifp->int_if_flags & IFF_POINTOPOINT)
				     ? ifp->int_dstaddr
				     : ifp->int_net),
d636 3
d655 2
d659 1
d665 6
d673 8
a680 1
	if (rts->rts_gate != RIP_DEFAULT) {
d683 6
a688 12
			      trace_pair(rt->rt_dst, rt->rt_mask,
					 naddr_ntoa(rts->rts_gate)));
		if (rts->rts_gate != rts->rts_gate)
			(void)fprintf(ftrace, "router=%s ",
				      naddr_ntoa(rts->rts_gate));
		if (rts->rts_tag != 0)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(rts->rts_tag));
		(void)fprintf(ftrace, "metric=%-2d ", rts->rts_metric);
		if (rts->rts_ifp != 0)
			(void)fprintf(ftrace, "%s ",
				      rts->rts_ifp->int_name);
		(void)fprintf(ftrace, "%s\n", ts(rts->rts_time));
d690 1
a690 2
		(void)fprintf(ftrace, "       %19s%-16s ",
			      "",
d692 8
a699 10
		if (gate != router)
			(void)fprintf(ftrace,"router=%s ",naddr_ntoa(router));
		if (tag != rts->rts_tag)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
		if (metric != rts->rts_metric)
			(void)fprintf(ftrace, "metric=%-2d ", metric);
		if (ifp != rts->rts_ifp && ifp != 0 )
			(void)fprintf(ftrace, "%s ", ifp->int_name);
		(void)fprintf(ftrace, "%s\n",
			      new_time != rts->rts_time ? ts(new_time) : "");
d704 3
a706 10
			      trace_pair(rt->rt_dst, rt->rt_mask,
					 naddr_ntoa(gate)));
		if (gate != router)
			(void)fprintf(ftrace, "router=%s ", naddr_ntoa(gate));
		if (tag != 0)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
		(void)fprintf(ftrace, "metric=%-2d ", metric);
		if (ifp != 0)
			(void)fprintf(ftrace, "%s ", ifp->int_name);
		(void)fprintf(ftrace, "%s\n", ts(new_time));
d708 1
d725 1
d742 1
d759 1
d774 2
d785 6
d793 1
a793 1
	(void)fprintf(ftrace, "%s %-35s metric=%-2d ",
d795 3
a797 8
		      trace_pair(rt->rt_dst, rt->rt_mask,
				 naddr_ntoa(rt->rt_gate)),
		      rt->rt_metric);
	if (rt->rt_router != rt->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rt->rt_router));
	if (rt->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(rt->rt_tag));
a798 4
	(void)fprintf(ftrace, "%s ",
		      rt->rt_ifp == 0 ? "?" : rt->rt_ifp->int_name);
	(void)fprintf(ftrace, "%s\n",
		      AGE_RT(rt->rt_state, rt->rt_ifp) ? ts(rt->rt_time) : "");
d800 1
a800 1
	(void)fprintf(ftrace, "%*s %19s%-16s ",
d803 6
a808 6
	if (rt->rt_metric != metric)
		(void)fprintf(ftrace, "metric=%-2d ", metric);
	if (router != gate)
		(void)fprintf(ftrace, "router=%s ", naddr_ntoa(router));
	if (rt->rt_tag != tag)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
d811 1
a811 6
	if (rt->rt_ifp != ifp)
		(void)fprintf(ftrace, "%s ",
			      ifp != 0 ? ifp->int_name : "?");
	(void)fprintf(ftrace, "%s\n",
		      ((rt->rt_time == new_time || !AGE_RT(rt->rt_state, ifp))
		       ? "" : ts(new_time)));
a817 2
	u_int state = rt->rt_state;

d822 1
a822 1
	(void)fprintf(ftrace, "%s    %-35s metric=%-2d ",
d824 4
a827 12
		      trace_pair(rt->rt_dst, rt->rt_mask,
				 naddr_ntoa(rt->rt_gate)),
		      rt->rt_metric);
	if (rt->rt_router != rt->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rt->rt_router));
	if (rt->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(rt->rt_tag));
	trace_bits(rs_bits, state, 0);
	(void)fprintf(ftrace, "%s ",
		      rt->rt_ifp != 0 ? rt->rt_ifp->int_name : "?");
	(void)fprintf(ftrace, "%s\n", ts(rt->rt_time));
d838 1
a838 1
	int i, age;
d840 3
a842 10
	(void)fprintf(ftrace, "  %-35s metric=%-2d ",
		      trace_pair(RT->rt_dst, RT->rt_mask,
				 naddr_ntoa(RT->rt_gate)),
		      RT->rt_metric);
	if (RT->rt_router != RT->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(RT->rt_router));
	if (RT->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ",
			      ntohs(RT->rt_tag));
d844 4
a847 5
	(void)fprintf(ftrace, "%s ",
		      RT->rt_ifp == 0 ? "?" : RT->rt_ifp->int_name);
	age = AGE_RT(RT->rt_state, RT->rt_ifp);
	if (age)
		(void)fprintf(ftrace, "%s", ts(RT->rt_time));
d851 4
a854 15
		if (rts->rts_metric != HOPCNT_INFINITY) {
			(void)fprintf(ftrace,"\n    #%d%15s%-16s metric=%-2d ",
				      i, "", naddr_ntoa(rts->rts_gate),
				      rts->rts_metric);
			if (rts->rts_router != rts->rts_gate)
				(void)fprintf(ftrace, "router=%s ",
					      naddr_ntoa(rts->rts_router));
			if (rts->rts_tag != 0)
				(void)fprintf(ftrace, "tag=%#x ",
					      ntohs(rts->rts_tag));
			(void)fprintf(ftrace, "%s ",
				      (rts->rts_ifp == 0
				       ? "?" : rts->rts_ifp->int_name));
			if (age)
				(void)fprintf(ftrace, "%s", ts(rts->rts_time));
d866 2
d872 3
d887 2
a888 2
	struct netauth *a;
	int i;
d912 1
d919 2
a920 1
			if (n->n_family == RIP_AF_UNSPEC
d922 4
a925 3
			    && n+1 == lim
			    && n == msg->rip_nets
			    && msg->rip_cmd == RIPCMD_REQUEST) {
d934 1
a934 1
					(void)fprintf(ftrace, " nhop=%s ",
d937 1
a937 1
					(void)fprintf(ftrace, "tag=%#x",
d944 24
a967 1
				a = (struct netauth*)n;
d969 3
a971 2
					      "\tAuthentication type %d: ",
					      ntohs(a->a_type));
d973 1
a973 1
				     i < sizeof(a->au.au_pw);
d976 1
a976 1
						      a->au.au_pw[i]);
d981 1
d984 1
a984 1
					      "\t(af %d) %-18s mask=%#x",
d1015 2
a1016 1
		fprintf(ftrace, "\tfile=%*s\n", size-4, msg->rip_tracefile);
@


1.5
log
@update to the latest version from Sep 12.
@
text
@d716 1
a716 1
	   struct walkarg *w)
@


1.4
log
@note a race
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.3 1996/09/05 14:31:52 mickey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.3 1996/09/05 14:31:52 mickey Exp $";
d64 2
d212 7
a218 6
	} else if (lstat(filename, &stbuf) >= 0) {
		if (!trusted) {
			msglog("trace file \"%s\" already exists");
			return;
		}
		if ((stbuf.st_mode & S_IFMT) != S_IFREG) {
d225 7
a231 3
		    && strcmp(filename, savetracename)
		    && strncmp(filename, _PATH_TRACE, sizeof(_PATH_TRACE)-1)) {
			msglog("wrong directory for trace file: \"%s\"",
a236 1
	/* XXX lstat -> fopen race */
d710 62
@


1.3
log
@fix import.
mention that routed is from vjs@@sgi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.2 1996/06/23 14:32:34 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.2 1996/06/23 14:32:34 deraadt Exp $";
d210 1
a210 1
	} else if (stat(filename, &stbuf) >= 0) {
d230 1
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: trace.c,v 1.13 1995/06/20 22:28:03 christos Exp $	*/
d37 1
a37 2
#ifndef lint
#if 0
d40 1
a40 1
static char rcsid[] = "$OpenBSD: trace.c,v 1.13 1995/06/20 22:28:03 christos Exp $";
a41 1
#endif /* not lint */
a42 3
/*
 * Routing Table Management Daemon
 */
d45 1
d47 1
a47 1
#include <signal.h>
d49 6
a54 1
#include "pathnames.h"
d57 46
a102 3
#ifdef DEBUG
FILE	*ftrace = stdout;
int	traceactions = 0;
d104 2
a105 2
static	struct timeval lastlog;
static	char *savetracename;
a106 3
static int iftraceinit __P((struct interface *, struct ifdebug *));
void dumpif __P((FILE *, struct interface *));
void dumptrace __P((FILE *, char *, struct ifdebug *));
d108 4
d113 1
a113 2
traceinit(ifp)
	register struct interface *ifp;
d115 7
a121 5
	if (iftraceinit(ifp, &ifp->int_input) &&
	    iftraceinit(ifp, &ifp->int_output))
		return;
	tracehistory = 0;
	fprintf(stderr, "traceinit: can't init %s\n", ifp->int_name);
d124 3
a126 4
static int
iftraceinit(ifp, ifd)
	struct interface *ifp;
	register struct ifdebug *ifd;
d128 1
a128 1
	register struct iftrace *t;
d130 5
a134 9
	ifd->ifd_records =
	  (struct iftrace *)malloc(NRECORDS * sizeof (struct iftrace));
	if (ifd->ifd_records == 0)
		return (0);
	ifd->ifd_front = ifd->ifd_records;
	ifd->ifd_count = 0;
	for (t = ifd->ifd_records; t < ifd->ifd_records + NRECORDS; t++) {
		t->ift_size = 0;
		t->ift_packet = 0;
a135 2
	ifd->ifd_if = ifp;
	return (1);
d138 3
a140 3
void
traceon(file)
	char *file;
d142 5
a146 1
	struct stat stbuf;
d148 9
a156 13
	if (ftrace != NULL)
		return;
	if (stat(file, &stbuf) >= 0 && !S_ISREG(stbuf.st_mode))
		return;
	savetracename = file;
	(void) gettimeofday(&now, NULL);
	ftrace = fopen(file, "a");
	if (ftrace == NULL)
		return;
	dup2(fileno(ftrace), 1);
	dup2(fileno(ftrace), 2);
	traceactions = 1;
	fprintf(ftrace, "Tracing enabled %s\n", ctime((time_t *)&now.tv_sec));
d159 1
d161 1
a161 1
traceoff()
d163 1
a163 7
	if (!traceactions)
		return;
	if (ftrace != NULL) {
		int fd = open(_PATH_DEVNULL, O_RDWR);

		fprintf(ftrace, "Tracing disabled %s\n",
		    ctime((time_t *)&now.tv_sec));
d165 2
a166 5
		(void) dup2(fd, 1);
		(void) dup2(fd, 2);
		(void) close(fd);
		fclose(ftrace);
		ftrace = NULL;
a167 4
	traceactions = 0;
	tracehistory = 0;
	tracepackets = 0;
	tracecontents = 0;
d170 1
d172 1
a172 2
sigtrace(s)
	int s;
d174 2
d177 9
a185 6
	if (s == SIGUSR2)
		traceoff();
	else if (ftrace == NULL && savetracename)
		traceon(savetracename);
	else
		bumploglevel();
d188 1
a188 8
/*
 * Move to next higher level of tracing when -t option processed or
 * SIGUSR1 is received.  Successive levels are:
 *	traceactions
 *	traceactions + tracepackets
 *	traceactions + tracehistory (packets and contents after change)
 *	traceactions + tracepackets + tracecontents
 */
d190 2
a191 1
bumploglevel()
d193 16
d210 25
a234 25
	(void) gettimeofday(&now, NULL);
	if (traceactions == 0) {
		traceactions++;
		if (ftrace)
			fprintf(ftrace, "Tracing actions started %s\n",
			    ctime((time_t *)&now.tv_sec));
	} else if (tracepackets == 0) {
		tracepackets++;
		tracehistory = 0;
		tracecontents = 0;
		if (ftrace)
			fprintf(ftrace, "Tracing packets started %s\n",
			    ctime((time_t *)&now.tv_sec));
	} else if (tracehistory == 0) {
		tracehistory++;
		if (ftrace)
			fprintf(ftrace, "Tracing history started %s\n",
			    ctime((time_t *)&now.tv_sec));
	} else {
		tracepackets++;
		tracecontents++;
		tracehistory = 0;
		if (ftrace)
			fprintf(ftrace, "Tracing packet contents started %s\n",
			    ctime((time_t *)&now.tv_sec));
d236 24
a259 2
	if (ftrace)
		fflush(ftrace);
d262 2
d265 4
a268 30
trace(ifd, who, p, len, m)
	register struct ifdebug *ifd;
	struct sockaddr *who;
	char *p;
	int len, m;
{
	register struct iftrace *t;

	if (ifd->ifd_records == 0)
		return;
	t = ifd->ifd_front++;
	if (ifd->ifd_front >= ifd->ifd_records + NRECORDS)
		ifd->ifd_front = ifd->ifd_records;
	if (ifd->ifd_count < NRECORDS)
		ifd->ifd_count++;
	if (t->ift_size > 0 && t->ift_size < len && t->ift_packet) {
		free(t->ift_packet);
		t->ift_packet = 0;
	}
	t->ift_stamp = now;
	t->ift_who = *who;
	if (len > 0 && t->ift_packet == 0) {
		t->ift_packet = malloc(len);
		if (t->ift_packet == 0)
			len = 0;
	}
	if (len > 0)
		memcpy(t->ift_packet, p, len);
	t->ift_size = len;
	t->ift_metric = m;
d271 7
d279 7
a285 23
traceaction(fd, action, rt)
	FILE *fd;
	char *action;
	struct rt_entry *rt;
{
	struct sockaddr_in *dst, *gate, *netmask;
	static struct bits {
		int	t_bits;
		char	*t_name;
	} flagbits[] = {
		{ RTF_UP,	"UP" },
		{ RTF_GATEWAY,	"GATEWAY" },
		{ RTF_HOST,	"HOST" },
		{ 0 }
	}, statebits[] = {
		{ RTS_PASSIVE,	"PASSIVE" },
		{ RTS_REMOTE,	"REMOTE" },
		{ RTS_INTERFACE,"INTERFACE" },
		{ RTS_CHANGED,	"CHANGED" },
		{ RTS_INTERNAL,	"INTERNAL" },
		{ RTS_EXTERNAL,	"EXTERNAL" },
		{ RTS_SUBNET,	"SUBNET" },
		{ 0 }
d287 13
a299 26
	register struct bits *p;
	register int first;
	char *cp;

	if (fd == NULL)
		return;
	if (lastlog.tv_sec != now.tv_sec || lastlog.tv_usec != now.tv_usec) {
		fprintf(fd, "\n%.19s:\n", ctime((time_t *)&now.tv_sec));
		lastlog = now;
	}
	fprintf(fd, "%s ", action);
	dst = (struct sockaddr_in *)&rt->rt_dst;
	gate = (struct sockaddr_in *)&rt->rt_router;
	netmask = (struct sockaddr_in *)&rt->rt_netmask;
	fprintf(fd, "dst %s, ", inet_ntoa(dst->sin_addr));
	fprintf(fd, "router %s, ", inet_ntoa(gate->sin_addr));
	fprintf(fd, " netmask %s, metric %d, flags",
	        inet_ntoa(netmask->sin_addr), rt->rt_metric);
	cp = " %s";
	for (first = 1, p = flagbits; p->t_bits > 0; p++) {
		if ((rt->rt_flags & p->t_bits) == 0)
			continue;
		fprintf(fd, cp, p->t_name);
		if (first) {
			cp = "|%s";
			first = 0;
d302 153
a454 9
	fprintf(fd, " state");
	cp = " %s";
	for (first = 1, p = statebits; p->t_bits > 0; p++) {
		if ((rt->rt_state & p->t_bits) == 0)
			continue;
		fprintf(fd, cp, p->t_name);
		if (first) {
			cp = "|%s";
			first = 0;
d456 114
a570 7
	fprintf(fd, " timer %d\n", rt->rt_timer);
	if (tracehistory && !tracepackets &&
	    (rt->rt_state & RTS_PASSIVE) == 0 && rt->rt_ifp)
		dumpif(fd, rt->rt_ifp);
	fflush(fd);
	if (ferror(fd))
		traceoff();
d573 3
d577 1
a577 4
tracenewmetric(fd, rt, newmetric)
	FILE *fd;
	struct rt_entry *rt;
	int newmetric;
d579 1
a579 1
	struct sockaddr_in *dst, *gate;
d581 1
a581 1
	if (fd == NULL)
d583 36
a618 12
	if (lastlog.tv_sec != now.tv_sec || lastlog.tv_usec != now.tv_usec) {
		fprintf(fd, "\n%.19s:\n", ctime((time_t *)&now.tv_sec));
		lastlog = now;
	}
	dst = (struct sockaddr_in *)&rt->rt_dst;
	gate = (struct sockaddr_in *)&rt->rt_router;
	fprintf(fd, "CHANGE metric dst %s, ", inet_ntoa(dst->sin_addr));
	fprintf(fd, "router %s, from %d to %d\n",
	     inet_ntoa(gate->sin_addr), rt->rt_metric, newmetric);
	fflush(fd);
	if (ferror(fd))
		traceoff();
d621 1
d623 9
a631 3
dumpif(fd, ifp)
	FILE *fd;
	register struct interface *ifp;
d633 44
a676 9
	if (ifp->int_input.ifd_count || ifp->int_output.ifd_count) {
		fprintf(fd, "*** Packet history for interface %s ***\n",
			ifp->int_name);
#ifdef notneeded
		dumptrace(fd, "to", &ifp->int_output);
#endif
		dumptrace(fd, "from", &ifp->int_input);
		fprintf(fd, "*** end packet history ***\n");
	}
d679 1
d681 1
a681 4
dumptrace(fd, dir, ifd)
	FILE *fd;
	char *dir;
	register struct ifdebug *ifd;
d683 1
a683 2
	register struct iftrace *t;
	char *cp = !strcmp(dir, "to") ? "Output" : "Input";
d685 1
a685 4
	if (ifd->ifd_front == ifd->ifd_records &&
	    ifd->ifd_front->ift_size == 0) {
		fprintf(fd, "%s: no packets.\n", cp);
		fflush(fd);
d687 16
a702 13
	}
	fprintf(fd, "%s trace:\n", cp);
	t = ifd->ifd_front - ifd->ifd_count;
	if (t < ifd->ifd_records)
		t += NRECORDS;
	for ( ; ifd->ifd_count; ifd->ifd_count--, t++) {
		if (t >= ifd->ifd_records + NRECORDS)
			t = ifd->ifd_records;
		if (t->ift_size == 0)
			continue;
		dumppacket(fd, dir, (struct sockaddr_in *)&t->ift_who,
		    t->ift_packet, t->ift_size, &t->ift_stamp);
	}
d705 1
d707 5
a711 6
dumppacket(fd, dir, who, cp, size, stamp)
	FILE *fd;
	struct sockaddr_in *who;		/* should be sockaddr */
	char *dir, *cp;
	register int size;
	struct timeval *stamp;
d713 3
a715 2
	register struct rip *msg = (struct rip *)cp;
	register struct netinfo *n;
d717 1
a717 1
	if (fd == NULL)
d719 10
a728 11
	if (msg->rip_cmd && msg->rip_cmd < RIPCMD_MAX)
		fprintf(fd, "%s %s %s.%d %.19s:\n", ripcmds[msg->rip_cmd],
		    dir, inet_ntoa(who->sin_addr), ntohs(who->sin_port),
		    ctime((time_t *)&stamp->tv_sec));
	else {
		fprintf(fd, "Bad cmd 0x%x %s %s.%d %.19s\n", msg->rip_cmd,
		    dir, inet_ntoa(who->sin_addr), ntohs(who->sin_port),
		    ctime((time_t *)&stamp->tv_sec));
		fprintf(fd, "size=%d cp=%lx packet=%lx\n", size,
			(u_long) cp, (u_long) packet);
		fflush(fd);
d731 6
a736 2
	if (tracepackets && tracecontents == 0) {
		fflush(fd);
d738 1
a738 1
	}
a739 1

a741 1
		size -= 4 * sizeof (char);
d743 22
a764 5
		for (; size > 0; n++, size -= sizeof (struct netinfo)) {
			if (size < sizeof (struct netinfo)) {
				fprintf(fd, "(truncated record, len %d)\n",
				    size);
				break;
a765 1
			switch (n->rip_family) {
d767 13
a779 16
			case AF_INET:
				{
					struct sockaddr_in sa;
					sa.sin_addr.s_addr = n->rip_dst;
					fprintf(fd, "\tdst %s",
						inet_ntoa(sa.sin_addr));
					if (msg->rip_vers > RIP_VERSION_1) {
						fprintf(fd, ", mask 0x%.8x",
							n->rip_netmask);
						sa.sin_addr.s_addr =
							n->rip_router;
						fprintf(fd, ", router %s",
							inet_ntoa(sa.sin_addr));
					}
				}
				break;
d781 16
a796 3
			default:
				fprintf(fd, "\taf %d?", n->rip_family);
				break;
d798 9
a806 1
			fprintf(fd, ", metric %d\n", ntohl(n->rip_metric));
d808 3
d814 1
a814 1
		fprintf(fd, "\tfile=%*s\n", size, msg->rip_tracefile);
a819 3
	fflush(fd);
	if (ferror(fd))
		traceoff();
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: trace.c,v 1.13 1995/06/20 22:28:03 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@new routed from SGI.
rip1, rip2, icmp, rdisc.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
a37 1
#if !defined(lint)
d39 2
d42 1
d44 3
a48 1
#include "pathnames.h"
d50 1
a50 1
#include <sys/signal.h>
d52 1
a52 6


#ifdef sgi
/* use *stat64 for files on large filesystems */
#define stat	stat64
#endif
d55 3
a57 46

u_int	tracelevel, new_tracelevel;
FILE	*ftrace = stdout;		/* output trace file */
static char *tracelevel_pat = "%s\n";

char savetracename[MAXPATHLEN+1];


/* convert IP address to a string, but not into a single buffer
 */
char *
naddr_ntoa(naddr a)
{
#define NUM_BUFS 4
	static int bufno;
	static struct {
	    char    str[16];		/* xxx.xxx.xxx.xxx\0 */
	} bufs[NUM_BUFS];
	char *s;
	struct in_addr addr;

	addr.s_addr = a;
	s = strcpy(bufs[bufno].str, inet_ntoa(addr));
	bufno = (bufno+1) % NUM_BUFS;
	return s;
#undef NUM_BUFS
}


char *
saddr_ntoa(struct sockaddr *sa)
{
	return (sa == 0) ? "?" : naddr_ntoa(S_ADDR(sa));
}


static char *
ts(time_t secs) {
	static char s[20];

	secs += epoch.tv_sec;
#ifdef sgi
	(void)cftime(s, "%T", &secs);
#else
	bcopy(ctime(&secs)+11, s, 8);
	s[8] = '\0';
d59 2
a60 2
	return s;
}
d62 3
a65 4
/* On each event, display a time stamp.
 * This assumes that 'now' is update once for each event, and
 * that at least now.tv_usec changes.
 */
d67 2
a68 1
lastlog(void)
d70 5
a74 7
	static struct timeval last;

	if (last.tv_sec != now.tv_sec
	    || last.tv_usec != now.tv_usec) {
		(void)fprintf(ftrace, "-- %s --\n", ts(now.tv_sec));
		last = now;
	}
d77 4
a80 3

static void
tmsg(char *p, ...)
d82 1
a82 1
	va_list args;
d84 9
a92 5
	if (ftrace != 0) {
		lastlog();
		va_start(args, p);
		vfprintf(ftrace, p, args);
		fflush(ftrace);
d94 2
d98 3
a100 3

static void
trace_close(void)
d102 1
a102 1
	int fd;
d104 13
a116 13

	fflush(stdout);
	fflush(stderr);

	if (ftrace != 0
	    && savetracename[0] != '\0') {
		fd = open(_PATH_DEVNULL, O_RDWR);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		(void)close(fd);
		fclose(ftrace);
		ftrace = 0;
	}
a118 1

d120 1
a120 1
trace_flush(void)
d122 7
a128 1
	if (ftrace != 0) {
d130 5
a134 2
		if (ferror(ftrace))
			trace_off("tracing off: ", strerror(ferror(ftrace)));
d136 4
a141 1

d143 2
a144 1
trace_off(char *p, ...)
a145 1
	va_list args;
d147 6
a152 10

	if (ftrace != 0) {
		lastlog();
		va_start(args, p);
		vfprintf(ftrace, p, args);
		fflush(ftrace);
	}
	trace_close();

	new_tracelevel = tracelevel = 0;
d155 8
a162 1

d164 1
a164 2
trace_on(char *filename,
	 int trusted)
a165 2
	struct stat stbuf;
	FILE *n_ftrace;
d167 25
a191 32

	/* Given a null filename when tracing is already on, increase the
	 * debugging level and re-open the file in case it has been unlinked.
	 */
	if (filename[0] == '\0') {
		if (tracelevel != 0) {
			new_tracelevel++;
			tracelevel_pat = "trace command: %s\n";
		} else if (savetracename[0] == '\0') {
			msglog("missing trace file name");
			return;
		}
		filename = savetracename;

	} else if (stat(filename, &stbuf) >= 0) {
		if (!trusted) {
			msglog("trace file \"%s\" already exists");
			return;
		}
		if ((stbuf.st_mode & S_IFMT) != S_IFREG) {
			msglog("wrong type (%#x) of trace file \"%s\"",
			       stbuf.st_mode, filename);
			return;
		}

		if (!trusted
		    && strcmp(filename, savetracename)
		    && strncmp(filename, _PATH_TRACE, sizeof(_PATH_TRACE)-1)) {
			msglog("wrong directory for trace file: \"%s\"",
			       filename);
			return;
		}
d193 2
a194 22

	n_ftrace = fopen(filename, "a");
	if (n_ftrace == 0) {
		msglog("failed to open trace file \"%s\" %s",
		       filename, strerror(errno));
		return;
	}

	tmsg("switch to trace file %s\n", filename);
	trace_close();
	if (filename != savetracename)
		strncpy(savetracename, filename, sizeof(savetracename)-1);
	ftrace = n_ftrace;

	fflush(stdout);
	fflush(stderr);
	dup2(fileno(ftrace), STDOUT_FILENO);
	dup2(fileno(ftrace), STDERR_FILENO);

	if (new_tracelevel == 0)
		new_tracelevel = 1;
	set_tracelevel();
a196 2

/* ARGSUSED */
d198 30
a227 4
sigtrace_on(int s)
{
	new_tracelevel++;
	tracelevel_pat = "SIGUSR1: %s\n";
a229 2

/* ARGSUSED */
d231 23
a253 21
sigtrace_off(int s)
{
	new_tracelevel--;
	tracelevel_pat = "SIGUSR2: %s\n";
}


/* Move to next higher level of tracing when -t option processed or
 * SIGUSR1 is received.  Successive levels are:
 *	actions
 *	actions + packets
 *	actions + packets + contents
 */
void
set_tracelevel(void)
{
	static char *off_msgs[MAX_TRACELEVEL] = {
		"Tracing actions stopped",
		"Tracing packets stopped",
		"Tracing packet contents stopped",
		"Tracing kernel changes stopped",
d255 26
a280 13
	static char *on_msgs[MAX_TRACELEVEL] = {
		"Tracing actions started",
		"Tracing packets started",
		"Tracing packet contents started",
		"Tracing kernel changes started",
	};


	if (new_tracelevel > MAX_TRACELEVEL) {
		new_tracelevel = MAX_TRACELEVEL;
		if (new_tracelevel == tracelevel) {
			tmsg(tracelevel_pat, on_msgs[tracelevel-1]);
			return;
d283 9
a291 153
	while (new_tracelevel != tracelevel) {
		if (new_tracelevel < tracelevel) {
			if (--tracelevel == 0)
				trace_off(tracelevel_pat, off_msgs[0]);
			else
				tmsg(tracelevel_pat, off_msgs[tracelevel]);
		} else {
			if (ftrace == 0) {
				if (savetracename[0] != '\0')
					trace_on(savetracename, 1);
				else
					ftrace = stdout;
			}
			tmsg(tracelevel_pat, on_msgs[tracelevel++]);
		}
	}
	tracelevel_pat = "%s\n";
}


/* display an address
 */
char *
addrname(naddr	addr,			/* in network byte order */
	 naddr	mask,
	 int	force)			/* 0=show mask if nonstandard, */
{					/*	1=always show mask, 2=never */
#define NUM_BUFS 4
	static int bufno;
	static struct {
	    char    str[15+20];
	} bufs[NUM_BUFS];
	char *s, *sp;
	naddr dmask;
	int i;

	s = strcpy(bufs[bufno].str, naddr_ntoa(addr));
	bufno = (bufno+1) % NUM_BUFS;

	if (force == 1 || (force == 0 && mask != std_mask(addr))) {
		sp = &s[strlen(s)];

		dmask = mask & -mask;
		if (mask + dmask == 0) {
			for (i = 0; i != 32 && ((1<<i) & mask) == 0; i++)
				continue;
			(void)sprintf(sp, "/%d", 32-i);

		} else {
			(void)sprintf(sp, " (mask %#x)", (u_int)mask);
		}
	}

	return s;
#undef NUM_BUFS
}


/* display a bit-field
 */
struct bits {
	int	bits_mask;
	int	bits_clear;
	char	*bits_name;
};

static struct bits if_bits[] = {
	{ IFF_LOOPBACK,		0,		"LOOPBACK" },
	{ IFF_POINTOPOINT,	0,		"PT-TO-PT" },
	{ 0,			0,		0}
};

static struct bits is_bits[] = {
	{ IS_SUBNET,		0,		"" },
	{ IS_REMOTE,		0,		"REMOTE" },
	{ IS_PASSIVE,		(IS_NO_RDISC
				 | IS_BCAST_RDISC
				 | IS_NO_RIP
				 | IS_NO_SUPER_AG
				 | IS_PM_RDISC
				 | IS_NO_AG),	"PASSIVE" },
	{ IS_EXTERNAL,		0,		"EXTERNAL" },
	{ IS_CHECKED,		0,		"" },
	{ IS_ALL_HOSTS,		0,		"" },
	{ IS_ALL_ROUTERS,	0,		"" },
	{ IS_RIP_QUERIED,	0,		"" },
	{ IS_BROKE,		IS_SICK,	"BROKEN" },
	{ IS_SICK,		0,		"SICK" },
	{ IS_ACTIVE,		0,		"ACTIVE" },
	{ IS_NEED_NET_SYN,	0,		"" },
	{ IS_NO_AG,		IS_NO_SUPER_AG,	"NO_AG" },
	{ IS_NO_SUPER_AG,	0,		"NO_SUPER_AG" },
	{ (IS_NO_RIPV1_IN
	   | IS_NO_RIPV2_IN
	   | IS_NO_RIPV1_OUT
	   | IS_NO_RIPV2_OUT),	0,		"NO_RIP" },
	{ (IS_NO_RIPV1_IN
	   | IS_NO_RIPV1_OUT),	0,		"RIPV2" },
	{ IS_NO_RIPV1_IN,	0,		"NO_RIPV1_IN" },
	{ IS_NO_RIPV2_IN,	0,		"NO_RIPV2_IN" },
	{ IS_NO_RIPV1_OUT,	0,		"NO_RIPV1_OUT" },
	{ IS_NO_RIPV2_OUT,	0,		"NO_RIPV2_OUT" },
	{ (IS_NO_ADV_IN
	   | IS_NO_SOL_OUT
	   | IS_NO_ADV_OUT),	IS_BCAST_RDISC,	"NO_RDISC" },
	{ IS_NO_SOL_OUT,	0,		"NO_SOLICIT" },
	{ IS_SOL_OUT,		0,		"SEND_SOLICIT" },
	{ IS_NO_ADV_OUT,	IS_BCAST_RDISC,	"NO_RDISC_ADV" },
	{ IS_ADV_OUT,		0,		"RDISC_ADV" },
	{ IS_BCAST_RDISC,	0,		"BCAST_RDISC" },
	{ IS_PM_RDISC,		0,		"PM_RDISC" },
	{ 0,			0,		"%#x"}
};

static struct bits rs_bits[] = {
	{ RS_IF,		0,		"IF" },
	{ RS_NET_INT,		RS_NET_SYN,	"NET_INT" },
	{ RS_NET_SYN,		0,		"NET_SYN" },
	{ RS_SUBNET,		0,		"" },
	{ RS_LOCAL,		0,		"LOCAL" },
	{ RS_MHOME,		0,		"MHOME" },
	{ RS_STATIC,		0,		"STATIC" },
	{ RS_RDISC,		0,		"RDISC" },
	{ 0,			0,		"%#x"}
};


static void
trace_bits(struct bits *tbl,
	   u_int field,
	   int force)
{
	int b;
	char c;

	if (force) {
		(void)putc('<', ftrace);
		c = 0;
	} else {
		c = '<';
	}

	while (field != 0
	       && (b = tbl->bits_mask) != 0) {
		if ((b & field) == b) {
			if (tbl->bits_name[0] != '\0') {
				if (c)
					(void)putc(c, ftrace);
				(void)fprintf(ftrace, "%s", tbl->bits_name);
				c = '|';
			}
			if (0 == (field &= ~(b | tbl->bits_clear)))
				break;
a292 114
		tbl++;
	}
	if (field != 0 && tbl->bits_name != 0) {
		if (c)
			(void)putc(c, ftrace);
		(void)fprintf(ftrace, tbl->bits_name, field);
		c = '|';
	}

	if (c != '<' || force)
		(void)fputs("> ", ftrace);
}


static char *
trace_pair(naddr dst,
	   naddr mask,
	   char *gate)
{
	static char buf[3*4+3+1+2+3	/* "xxx.xxx.xxx.xxx/xx-->" */
			+3*4+3+1];	/* "xxx.xxx.xxx.xxx" */
	int i;

	i = sprintf(buf, "%-16s-->", addrname(dst, mask, 0));
	(void)sprintf(&buf[i], "%-*s", 15+20-MAX(20,i), gate);
	return buf;
}


void
trace_if(char *act,
	  struct interface *ifp)
{
	if (!TRACEACTIONS || ftrace == 0)
		return;

	lastlog();
	(void)fprintf(ftrace, "%s interface %-4s ", act, ifp->int_name);
	(void)fprintf(ftrace, "%-15s-->%-15s ",
		      naddr_ntoa(ifp->int_addr),
		      addrname(htonl((ifp->int_if_flags & IFF_POINTOPOINT)
				     ? ifp->int_dstaddr
				     : ifp->int_net),
			       ifp->int_mask, 1));
	if (ifp->int_metric != 0)
		(void)fprintf(ftrace, "metric=%d ", ifp->int_metric);
	trace_bits(if_bits, ifp->int_if_flags, 0);
	trace_bits(is_bits, ifp->int_state, 0);
	(void)fputc('\n',ftrace);
}


void
trace_upslot(struct rt_entry *rt,
	     struct rt_spare *rts,
	     naddr	gate,
	     naddr	router,
	     struct interface *ifp,
	     int	metric,
	     u_short	tag,
	     time_t	new_time)
{
	if (!TRACEACTIONS || ftrace == 0)
		return;
	if (rts->rts_gate == gate
	    && rts->rts_router == router
	    && rts->rts_metric == metric
	    && rts->rts_tag == tag)
		return;

	lastlog();
	if (rts->rts_gate != RIP_DEFAULT) {
		(void)fprintf(ftrace, "Chg #%d %-35s ",
			      rts - rt->rt_spares,
			      trace_pair(rt->rt_dst, rt->rt_mask,
					 naddr_ntoa(rts->rts_gate)));
		if (rts->rts_gate != rts->rts_gate)
			(void)fprintf(ftrace, "router=%s ",
				      naddr_ntoa(rts->rts_gate));
		if (rts->rts_tag != 0)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(rts->rts_tag));
		(void)fprintf(ftrace, "metric=%-2d ", rts->rts_metric);
		if (rts->rts_ifp != 0)
			(void)fprintf(ftrace, "%s ",
				      rts->rts_ifp->int_name);
		(void)fprintf(ftrace, "%s\n", ts(rts->rts_time));

		(void)fprintf(ftrace, "       %19s%-16s ",
			      "",
			      gate != rts->rts_gate ? naddr_ntoa(gate) : "");
		if (gate != router)
			(void)fprintf(ftrace,"router=%s ",naddr_ntoa(router));
		if (tag != rts->rts_tag)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
		if (metric != rts->rts_metric)
			(void)fprintf(ftrace, "metric=%-2d ", metric);
		if (ifp != rts->rts_ifp && ifp != 0 )
			(void)fprintf(ftrace, "%s ", ifp->int_name);
		(void)fprintf(ftrace, "%s\n",
			      new_time != rts->rts_time ? ts(new_time) : "");

	} else {
		(void)fprintf(ftrace, "Add #%d %-35s ",
			      rts - rt->rt_spares,
			      trace_pair(rt->rt_dst, rt->rt_mask,
					 naddr_ntoa(gate)));
		if (gate != router)
			(void)fprintf(ftrace, "router=%s ", naddr_ntoa(gate));
		if (tag != 0)
			(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
		(void)fprintf(ftrace, "metric=%-2d ", metric);
		if (ifp != 0)
			(void)fprintf(ftrace, "%s ", ifp->int_name);
		(void)fprintf(ftrace, "%s\n", ts(new_time));
d294 7
a302 3

/* talk about a change made to the kernel table
 */
d304 4
a307 1
trace_kernel(char *p, ...)
d309 1
a309 1
	va_list args;
d311 1
a311 1
	if (!TRACEKERNEL || ftrace == 0)
d313 12
a324 4

	lastlog();
	va_start(args, p);
	vfprintf(ftrace, p, args);
a326 3

/* display a message if tracing actions
 */
d328 3
a330 1
trace_act(char *p, ...)
d332 9
a340 8
	va_list args;

	if (!TRACEACTIONS || ftrace == 0)
		return;

	lastlog();
	va_start(args, p);
	vfprintf(ftrace, p, args);
a342 3

/* display a message if tracing packets
 */
d344 4
a347 1
trace_pkt(char *p, ...)
d349 2
a350 1
	va_list args;
d352 4
a355 1
	if (!TRACEPACKETS || ftrace == 0)
d357 13
a369 4

	lastlog();
	va_start(args, p);
	vfprintf(ftrace, p, args);
a371 1

d373 6
a378 9
trace_change(struct rt_entry *rt,
	     u_int	state,
	     naddr	gate,		/* forward packets here */
	     naddr	router,		/* on the authority of this router */
	     int	metric,
	     u_short	tag,
	     struct interface *ifp,
	     time_t	new_time,
	     char	*label)
d380 2
a381 2
	if (ftrace == 0)
		return;
d383 1
a383 5
	if (rt->rt_metric == metric
	    && rt->rt_gate == gate
	    && rt->rt_router == router
	    && rt->rt_state == state
	    && rt->rt_tag == tag)
d385 11
a395 44

	lastlog();
	(void)fprintf(ftrace, "%s %-35s metric=%-2d ",
		      label,
		      trace_pair(rt->rt_dst, rt->rt_mask,
				 naddr_ntoa(rt->rt_gate)),
		      rt->rt_metric);
	if (rt->rt_router != rt->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rt->rt_router));
	if (rt->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(rt->rt_tag));
	trace_bits(rs_bits, rt->rt_state, rt->rt_state != state);
	(void)fprintf(ftrace, "%s ",
		      rt->rt_ifp == 0 ? "?" : rt->rt_ifp->int_name);
	(void)fprintf(ftrace, "%s\n",
		      AGE_RT(rt->rt_state, rt->rt_ifp) ? ts(rt->rt_time) : "");

	(void)fprintf(ftrace, "%*s %19s%-16s ",
		      strlen(label), "", "",
		      rt->rt_gate != gate ? naddr_ntoa(gate) : "");
	if (rt->rt_metric != metric)
		(void)fprintf(ftrace, "metric=%-2d ", metric);
	if (router != gate)
		(void)fprintf(ftrace, "router=%s ", naddr_ntoa(router));
	if (rt->rt_tag != tag)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(tag));
	if (rt->rt_state != state)
		trace_bits(rs_bits, state, 1);
	if (rt->rt_ifp != ifp)
		(void)fprintf(ftrace, "%s ",
			      ifp != 0 ? ifp->int_name : "?");
	(void)fprintf(ftrace, "%s\n",
		      ((rt->rt_time == new_time || !AGE_RT(rt->rt_state, ifp))
		       ? "" : ts(new_time)));
}


void
trace_add_del(char * action, struct rt_entry *rt)
{
	u_int state = rt->rt_state;

	if (ftrace == 0)
d397 3
a399 42

	lastlog();
	(void)fprintf(ftrace, "%s    %-35s metric=%-2d ",
		      action,
		      trace_pair(rt->rt_dst, rt->rt_mask,
				 naddr_ntoa(rt->rt_gate)),
		      rt->rt_metric);
	if (rt->rt_router != rt->rt_gate)
		(void)fprintf(ftrace, "router=%s ",
			      naddr_ntoa(rt->rt_router));
	if (rt->rt_tag != 0)
		(void)fprintf(ftrace, "tag=%#x ", ntohs(rt->rt_tag));
	trace_bits(rs_bits, state, 0);
	(void)fprintf(ftrace, "%s ",
		      rt->rt_ifp != 0 ? rt->rt_ifp->int_name : "?");
	(void)fprintf(ftrace, "%s\n", ts(rt->rt_time));
}


void
trace_rip(char *dir1, char *dir2,
	  struct sockaddr_in *who,
	  struct interface *ifp,
	  struct rip *msg,
	  int size)			/* total size of message */
{
	struct netinfo *n, *lim;
	struct netauth *a;
	int i;

	if (!TRACEPACKETS || ftrace == 0)
		return;

	lastlog();
	if (msg->rip_cmd >= RIPCMD_MAX
	    || msg->rip_vers == 0) {
		(void)fprintf(ftrace, "%s bad RIPv%d cmd=%d %s"
			      " %s.%d size=%d\n",
			      dir1, msg->rip_vers, msg->rip_cmd, dir2,
			      naddr_ntoa(who->sin_addr.s_addr),
			      ntohs(who->sin_port),
			      size);
d402 1
a403 8
	(void)fprintf(ftrace, "%s RIPv%d %s %s %s.%d%s%s\n",
		      dir1, msg->rip_vers, ripcmds[msg->rip_cmd], dir2,
		      naddr_ntoa(who->sin_addr.s_addr), ntohs(who->sin_port),
		      ifp ? " via " : "", ifp ? ifp->int_name : "");
	if (!TRACECONTENTS)
		return;

	switch (msg->rip_cmd) {
d406 1
d408 5
a412 22
		lim = (struct netinfo *)((char*)msg + size);
		for (; n < lim; n++) {
			if (n->n_family == RIP_AF_UNSPEC
			    && ntohl(n->n_metric) == HOPCNT_INFINITY
			    && n+1 == lim
			    && n == msg->rip_nets
			    && msg->rip_cmd == RIPCMD_REQUEST) {
				(void)fputs("\tQUERY ", ftrace);
				if (n->n_dst != 0)
					(void)fprintf(ftrace, "%s ",
						      naddr_ntoa(n->n_dst));
				if (n->n_mask != 0)
					(void)fprintf(ftrace, "mask=%#x ",
						      (u_int)ntohl(n->n_mask));
				if (n->n_nhop != 0)
					(void)fprintf(ftrace, " nhop=%s ",
						      naddr_ntoa(n->n_nhop));
				if (n->n_tag != 0)
					(void)fprintf(ftrace, "tag=%#x",
						      ntohs(n->n_tag));
				(void)fputc('\n',ftrace);
				continue;
d414 1
d416 16
a431 13
			if (n->n_family == RIP_AF_AUTH) {
				a = (struct netauth*)n;
				(void)fprintf(ftrace,
					      "\tAuthentication type %d: ",
					      ntohs(a->a_type));
				for (i = 0;
				     i < sizeof(a->au.au_pw);
				     i++)
					(void)fprintf(ftrace, "%02x ",
						      a->au.au_pw[i]);
				(void)fputc('\n',ftrace);
				continue;
			}
d433 3
a435 16
			if (n->n_family != RIP_AF_INET) {
				(void)fprintf(ftrace,
					      "\t(af %d) %-18s mask=%#x",
					      ntohs(n->n_family),
					      naddr_ntoa(n->n_dst),
					      (u_int)ntohl(n->n_mask));
			} else if (msg->rip_vers == RIPv1) {
				(void)fprintf(ftrace, "\t%-18s ",
					      addrname(n->n_dst,
						       ntohl(n->n_mask),
						       n->n_mask==0 ? 2 : 1));
			} else {
				(void)fprintf(ftrace, "\t%-18s ",
					      addrname(n->n_dst,
						       ntohl(n->n_mask),
						       n->n_mask==0 ? 2 : 0));
d437 1
a437 9
			(void)fprintf(ftrace, "metric=%-2d ",
				      (u_int)ntohl(n->n_metric));
			if (n->n_nhop != 0)
				(void)fprintf(ftrace, " nhop=%s ",
					      naddr_ntoa(n->n_nhop));
			if (n->n_tag != 0)
				(void)fprintf(ftrace, "tag=%#x",
					      ntohs(n->n_tag));
			(void)fputc('\n',ftrace);
a438 3
		if (size != (char *)n - (char *)msg)
			(void)fprintf(ftrace, "truncated record, len %d\n",
				size);
d442 1
a442 1
		fprintf(ftrace, "\tfile=%*s\n", size-4, msg->rip_tracefile);
d448 3
@
