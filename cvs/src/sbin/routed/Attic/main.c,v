head	1.21;
access;
symbols
	OPENBSD_4_3:1.19.0.12
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	mickey:1.1.1.2
	SGI082896:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2008.05.07.11.55.20;	author claudio;	state dead;
branches;
next	1.20;

1.20
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.23.18.06.07;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.11.08.39.48;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.08.11.06.17;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.20.25.02;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.07.18.26.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.13.20.13.29;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.19.17.57.42;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.16.03.06.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.07.09.06.12.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.30.23.28.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.30.22.24.43;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.41.12;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.02.06.51.45;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.05.14.31.32;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.05.13.58.51;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.21
log
@RIP routed.

You were a nice thing in the 4.2BSD times but now it is time for you to go.
Superseded by the shiny privseped ripd that does not have the evil habit to
use kernel internals in userland.

OK everybody in the onsen 'cause it unbreaks the tree
@
text
@/*	$OpenBSD: main.c,v 1.20 2008/04/13 00:22:17 djm Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

char copyright[] =
"@@(#) Copyright (c) 1983, 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#if !defined(lint)
static char sccsid[] = "@@(#)main.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.20 2008/04/13 00:22:17 djm Exp $";
#endif

#include "defs.h"
#include "pathnames.h"
#ifdef sgi
#include "math.h"
#endif
#include <sys/file.h>
#include <fcntl.h>
#include <err.h>
#include <signal.h>

pid_t	mypid;

naddr	myaddr;				/* system address */
char	myname[MAXHOSTNAMELEN];

int	supplier;			/* supply or broadcast updates */
int	supplier_set;
int	ipforwarding = 1;		/* kernel forwarding on */

int	default_gateway;		/* 1=advertise default */
int	background = 1;
int	ridhosts;			/* 1=reduce host routes */
int	mhome;				/* 1=want multi-homed host route */
int	advertise_mhome;		/* 1=must continue adverising it */
int	auth_ok = 1;			/* 1=ignore auth if we do not care */

struct timeval epoch;			/* when started */
struct timeval clk, prev_clk;
struct timeval now;			/* current idea of time */
time_t	now_stale;
time_t	now_expire;
time_t	now_garbage;

struct timeval next_bcast;		/* next general broadcast */
struct timeval no_flash = {EPOCH+SUPPLY_INTERVAL};  /* inhibit flash update */

fd_set	*fdbitsp;
int	sock_max;
int	rip_sock = -1;			/* RIP socket */
struct interface *rip_sock_mcast;	/* current multicast interface */
int	rt_sock;			/* routing socket */
int	rt_sock_seqno;


static  int get_rip_sock(naddr, int);
static void timevalsub(struct timeval *, struct timeval *, struct timeval *);

int
main(int argc,
     char *argv[])
{
	int n, mib[4], off;
	size_t len;
	char *p, *q;
	struct timeval wtime, t2;
	time_t dt;
	fd_set *ibitsp = NULL;
	naddr p_addr, p_mask;
	struct interface *ifp;
	struct parm parm;
	char *tracename = 0;


	openlog("routed", LOG_PID | LOG_ODELAY, LOG_DAEMON);
	ftrace = stdout;

	gettimeofday(&clk, 0);
	prev_clk = clk;
	epoch = clk;
	epoch.tv_sec -= EPOCH;
	now.tv_sec = EPOCH;
	now_stale = EPOCH - STALE_TIME;
	now_expire = EPOCH - EXPIRE_TIME;
	now_garbage = EPOCH - GARBAGE_TIME;
	wtime.tv_sec = 0;

	(void)gethostname(myname, sizeof(myname));
	(void)gethost(myname, &myaddr);

	while ((n = getopt(argc, argv, "sqdghmAtT:F:P:")) != -1) {
		switch (n) {
		case 's':
			supplier = 1;
			supplier_set = 1;
			break;

		case 'q':
			supplier = 0;
			supplier_set = 1;
			break;

		case 'd':
			background = 0;
			break;

		case 'g':
			bzero(&parm, sizeof(parm));
			parm.parm_d_metric = 1;
			p = check_parms(&parm);
			if (p != 0)
				msglog("bad -g: %s", p);
			else
				default_gateway = 1;
			break;

		case 'h':		/* suppress extra host routes */
			ridhosts = 1;
			break;

		case 'm':		/* advertise host route */
			mhome = 1;	/* on multi-homed hosts */
			break;

		case 'A':
			/* Ignore authentication if we do not care.
			 * Crazy as it is, that is what RFC 1723 requires.
			 */
			auth_ok = 0;
			break;

		case 't':
			new_tracelevel++;
			break;

		case 'T':
			tracename = optarg;
			break;

		case 'F':		/* minimal routes for SLIP */
			n = HOPCNT_INFINITY-2;
			p = strchr(optarg,',');
			if (p && *p != '\0') {
				n = (int)strtoul(p+1, &q, 0);
				if (*q == '\0'
				    && n <= HOPCNT_INFINITY-1
				    && n >= 1)
					*p = '\0';
			}
			if (!getnet(optarg, &p_addr, &p_mask)) {
				msglog("bad network; \"-F %s\"",
				       optarg);
				break;
			}
			bzero(&parm, sizeof(parm));
			parm.parm_addr_h = p_addr;
			parm.parm_mask = p_mask;
			parm.parm_d_metric = n;
			p = check_parms(&parm);
			if (p != 0)
				msglog("bad -F: %s", p);
			break;

		case 'P':
			/* handle arbirary, (usually) per-interface
			 * parameters.
			 */
			p = parse_parms(optarg);
			if (p != 0)
				msglog("bad \"%s\" in \"%s\"",
				       p, optarg);
			break;

		default:
			goto usage;
		}
	}
	argc -= optind;
	argv += optind;

	if (tracename == 0 && argc >= 1) {
		tracename = *argv++;
		argc--;
	}
	if (argc != 0) {
usage:
		logbad(0, "usage: routed [-Adghmqst] [-F net[/mask][,metric]]"
		       " [-P parms] [-T tracefile]");
	}
	if (geteuid() != 0)
		logbad(0, "requires UID 0");

	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, 0, 0) < 0)
		LOGERR("sysctl(IPCTL_FORWARDING)");

	if (!ipforwarding) {
		if (supplier)
			msglog("-s incompatible with ipforwarding=0");
		if (default_gateway) {
			msglog("-g incompatible with ipforwarding=0");
			default_gateway = 0;
		}
		supplier = 0;
		supplier_set = 1;
	}
	if (default_gateway) {
		if (supplier_set && !supplier) {
			msglog("-g and -q incompatible");
		} else {
			supplier = 1;
			supplier_set = 1;
		}
	}


	signal(SIGALRM, sigalrm);
	if (!background)
		signal(SIGHUP, sigterm);    /* SIGHUP fatal during debugging */
	else
		signal(SIGHUP, SIG_IGN);
	signal(SIGTERM, sigterm);
	signal(SIGINT, sigterm);
	signal(SIGUSR1, sigtrace_on);
	signal(SIGUSR2, sigtrace_off);

	/* get into the background */
	if (background) {
#ifdef sgi
		if (0 > _daemonize(_DF_NOCHDIR,
				   new_tracelevel == 0 ? -1 : STDOUT_FILENO,
				   new_tracelevel == 0 ? -1 : STDERR_FILENO,
				   -1))
			BADERR(0, "_daemonize()");
#else
		if (daemon(1, 1) < 0)
			BADERR(0,"daemon()");
#endif
	}

	mypid = getpid();

	/* prepare socket connected to the kernel.
	 */
	rt_sock = socket(AF_ROUTE, SOCK_RAW, 0);
	if (rt_sock < 0)
		BADERR(1,"rt_sock = socket()");
	if (fcntl(rt_sock, F_SETFL, O_NONBLOCK) == -1)
		logbad(1, "fcntl(rt_sock) O_NONBLOCK: %s", strerror(errno));
	off = 0;
	if (setsockopt(rt_sock, SOL_SOCKET,SO_USELOOPBACK,
		       &off,sizeof(off)) < 0)
		LOGERR("setsockopt(SO_USELOOPBACK,0)");

	fix_select();


	if (background && new_tracelevel == 0)
		ftrace = 0;
	if (tracename != 0) {
		trace_on(tracename, 1);
		if (new_tracelevel == 0)	/* use stdout if file is bad */
			new_tracelevel = 1;
	}
	set_tracelevel();

	/* initialize radix tree */
	rtinit();

	/* Pick a random part of the second for our output to minimize
	 * collisions.
	 *
	 * Start broadcasting after hearing from other routers, and
	 * at a random time so a bunch of systems do not get synchronized
	 * after a power failure.
	 */
	intvl_random(&next_bcast, EPOCH+MIN_WAITTIME, EPOCH+SUPPLY_INTERVAL);
	age_timer.tv_usec = next_bcast.tv_usec;
	age_timer.tv_sec = EPOCH+MIN_WAITTIME;
	rdisc_timer = next_bcast;
	ifinit_timer.tv_usec = next_bcast.tv_usec;

	/* Collect an initial view of the world by checking the interface
	 * configuration and the kludge file.
	 */
	gwkludge();
	ifinit();
	flush_kern();

	/* Ask for routes */
	rip_query();
	if (!supplier)
		rdisc_sol();

	/* Loop forever, listening and broadcasting.
	 */
	for (;;) {
		prev_clk = clk;
		gettimeofday(&clk, 0);
		timevalsub(&t2, &clk, &prev_clk);
		if (t2.tv_sec < 0
		    || t2.tv_sec > wtime.tv_sec + 5) {
			/* Deal with time changes before other housekeeping to
			 * keep everything straight.
			 */
			dt = t2.tv_sec;
			if (dt > 0)
				dt -= wtime.tv_sec;
			trace_act("time changed by %d sec\n", dt);
			epoch.tv_sec += dt;
		}
		timevalsub(&now, &clk, &epoch);
		now_stale = now.tv_sec - STALE_TIME;
		now_expire = now.tv_sec - EXPIRE_TIME;
		now_garbage = now.tv_sec - GARBAGE_TIME;

		/* deal with interrupts that should affect tracing */
		set_tracelevel();

		if (stopint != 0) {
			if (supplier) {
				rip_bcast(0);
				rdisc_adv();
			}
			trace_off("exiting with signal %d\n", stopint);
			exit(stopint | 128);
		}

		/* look for new or dead interfaces */
		timevalsub(&wtime, &ifinit_timer, &now);
		if (wtime.tv_sec <= 0) {
			wtime.tv_sec = 0;
			ifinit();
			rip_query();
			continue;
		}

		/* If it is time, then broadcast our routes.
		 */
		if (supplier || advertise_mhome) {
			timevalsub(&t2, &next_bcast, &now);
			if (t2.tv_sec <= 0) {
				/* Synchronize the aging and broadcast
				 * timers to minimize awakenings
				 */
				age(0);

				rip_bcast(0);

				/* It is desirable to send routing updates
				 * regularly.  So schedule the next update
				 * 30 seconds after the previous one was
				 * secheduled, instead of 30 seconds after
				 * the previous update was finished.
				 * Even if we just started after discovering
				 * a 2nd interface or were otherwise delayed,
				 * pick a 30-second aniversary of the
				 * original broadcast time.
				 */
				n = 1 + (0-t2.tv_sec)/SUPPLY_INTERVAL;
				next_bcast.tv_sec += n*SUPPLY_INTERVAL;

				continue;
			}

			if (timercmp(&t2, &wtime, <))
				wtime = t2;
		}

		/* If we need a flash update, either do it now or
		 * set the delay to end when it is time.
		 *
		 * If we are within MIN_WAITTIME seconds of a full update,
		 * do not bother.
		 */
		if (need_flash
		    && supplier
		    && no_flash.tv_sec+MIN_WAITTIME < next_bcast.tv_sec) {
			/* accurate to the millisecond */
			if (!timercmp(&no_flash, &now, >))
				rip_bcast(1);
			timevalsub(&t2, &no_flash, &now);
			if (timercmp(&t2, &wtime, <))
				wtime = t2;
		}

		/* trigger the main aging timer.
		 */
		timevalsub(&t2, &age_timer, &now);
		if (t2.tv_sec <= 0) {
			age(0);
			continue;
		}
		if (timercmp(&t2, &wtime, <))
			wtime = t2;

		/* update the kernel routing table
		 */
		timevalsub(&t2, &need_kern, &now);
		if (t2.tv_sec <= 0) {
			age(0);
			continue;
		}
		if (timercmp(&t2, &wtime, <))
			wtime = t2;

		/* take care of router discovery,
		 * but do it to the millisecond
		 */
		if (!timercmp(&rdisc_timer, &now, >)) {
			rdisc_age(0);
			continue;
		}
		timevalsub(&t2, &rdisc_timer, &now);
		if (timercmp(&t2, &wtime, <))
			wtime = t2;


		/* wait for input or a timer to expire.
		 */
		trace_flush();
		if (ibitsp)
			free(ibitsp);
		ibitsp = (fd_set *)calloc(howmany(sock_max, NFDBITS),
		    sizeof(fd_mask));
		if (ibitsp == NULL)
			err(1, "calloc");
		memcpy(ibitsp, fdbitsp, howmany(sock_max, NFDBITS) *
		    sizeof(fd_mask));
		n = select(sock_max, ibitsp, 0, 0, &wtime);
		if (n <= 0) {
			if (n < 0 && errno != EINTR && errno != EAGAIN)
				BADERR(1,"select");
			continue;
		}

		if (FD_ISSET(rt_sock, ibitsp)) {
			read_rt();
			n--;
		}
		if (rdisc_sock >= 0 && FD_ISSET(rdisc_sock, ibitsp)) {
			read_d();
			n--;
		}
		if (rip_sock >= 0 && FD_ISSET(rip_sock, ibitsp)) {
			read_rip(rip_sock, 0);
			n--;
		}

		for (ifp = ifnet; n > 0 && 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_rip_sock >= 0
			    && FD_ISSET(ifp->int_rip_sock, ibitsp)) {
				read_rip(ifp->int_rip_sock, ifp);
				n--;
			}
		}
	}
}


/* ARGSUSED */
void
sigalrm(int sig)
{
	/* Historically, SIGALRM would cause the daemon to check for
	 * new and broken interfaces.
	 */
	ifinit_timer.tv_sec = now.tv_sec;
	trace_act("SIGALRM\n");		/* XXX signal race */
}


/* watch for fatal signals */
void
sigterm(int sig)
{
	stopint = sig;
	(void)signal(sig, SIG_DFL);	/* catch it only once */
}


void
fix_select(void)
{
	struct interface *ifp;

	sock_max = 0;

	if (sock_max <= rt_sock)
		sock_max = rt_sock+1;
	if (rip_sock >= 0 && sock_max <= rip_sock)
		sock_max = rip_sock+1;
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_rip_sock >= 0 && sock_max <= ifp->int_rip_sock)
			sock_max = ifp->int_rip_sock+1;
	}
	if (rdisc_sock >= 0 && sock_max <= rdisc_sock)
		sock_max = rdisc_sock+1;

	if (fdbitsp)
		free(fdbitsp);
	fdbitsp = (fd_set *)calloc(howmany(sock_max, NFDBITS),
	    sizeof(fd_mask));
	if (fdbitsp == NULL)
		err(1, "calloc");

	FD_SET(rt_sock, fdbitsp);
	if (rip_sock >= 0)
		FD_SET(rip_sock, fdbitsp);
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_rip_sock >= 0)
			FD_SET(ifp->int_rip_sock, fdbitsp);
	}
	if (rdisc_sock >= 0)
		FD_SET(rdisc_sock, fdbitsp);
}


void
fix_sock(int sock,
	 char *name)
{
	int on;
#define MIN_SOCKBUF (4*1024)
	static int rbuf;

	if (fcntl(sock, F_SETFL, O_NONBLOCK) == -1)
		logbad(1, "fcntl(%s) O_NONBLOCK: %s",
		       name, strerror(errno));
	on = 1;
	if (setsockopt(sock, SOL_SOCKET,SO_BROADCAST,
		       &on,sizeof(on)) < 0)
		msglog("setsockopt(%s,SO_BROADCAST): %s",
		       name, strerror(errno));
	if (rbuf >= MIN_SOCKBUF) {
		if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
			       &rbuf, sizeof(rbuf)) < 0)
			msglog("setsockopt(%s,SO_RCVBUF=%d): %s",
			       name, rbuf, strerror(errno));
	} else {
		for (rbuf = 60*1024; ; rbuf -= 4096) {
			if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
				       &rbuf, sizeof(rbuf)) == 0) {
				trace_act("RCVBUF=%d\n", rbuf);
				break;
			}
			if (rbuf < MIN_SOCKBUF) {
				msglog("setsockopt(%s,SO_RCVBUF = %d): %s",
				       name, rbuf, strerror(errno));
				break;
			}
		}
	}
}


/* get a rip socket
 */
static int				/* <0 or file descriptor */
get_rip_sock(naddr addr,
	     int serious)		/* 1=failure to bind is serious */
{
	struct sockaddr_in sin;
	unsigned char ttl;
	int s;


	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		BADERR(1,"rip_sock = socket()");

	bzero(&sin,sizeof(sin));
#ifdef _HAVE_SIN_LEN
	sin.sin_len = sizeof(sin);
#endif
	sin.sin_family = AF_INET;
	sin.sin_port = htons(RIP_PORT);
	sin.sin_addr.s_addr = addr;
	if (bind(s, (struct sockaddr *)&sin,sizeof(sin)) < 0) {
		if (serious)
			BADERR(errno != EADDRINUSE, "bind(rip_sock)");
		return -1;
	}
	fix_sock(s,"rip_sock");

	ttl = 1;
	if (setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL,
		       &ttl, sizeof(ttl)) < 0)
		DBGERR(1,"rip_sock setsockopt(IP_MULTICAST_TTL)");

	return s;
}


/* turn off main RIP socket */
void
rip_off(void)
{
	struct interface *ifp;
	naddr addr;


	if (rip_sock >= 0 && !mhome) {
		trace_act("turn off RIP\n");

		(void)close(rip_sock);
		rip_sock = -1;

		/* get non-broadcast sockets to listen to queries.
		 */
		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (ifp->int_rip_sock < 0
			    && !(ifp->int_state & IS_ALIAS)) {
				addr = ((ifp->int_if_flags & IFF_POINTOPOINT)
					? ifp->int_dstaddr
					: ifp->int_addr);
				ifp->int_rip_sock = get_rip_sock(addr, 0);
			}
		}

		fix_select();

		age(0);
	}
}


/* turn on RIP multicast input via an interface
 */
static void
rip_mcast_on(struct interface *ifp)
{
	struct ip_mreq m;

	if (!IS_RIP_IN_OFF(ifp->int_state)
	    && (ifp->int_if_flags & IFF_MULTICAST)
#ifdef MCAST_PPP_BUG
	    && !(ifp->int_if_flags & IFF_POINTOPOINT)
#endif
	    && !(ifp->int_state & IS_ALIAS)) {
		m.imr_multiaddr.s_addr = htonl(INADDR_RIP_GROUP);
		m.imr_interface.s_addr = ((ifp->int_if_flags & IFF_POINTOPOINT)
					  ? ifp->int_dstaddr
					  : ifp->int_addr);
		if (setsockopt(rip_sock,IPPROTO_IP, IP_ADD_MEMBERSHIP,
			       &m, sizeof(m)) < 0)
			LOGERR("setsockopt(IP_ADD_MEMBERSHIP RIP)");
	}
}


/* Prepare socket used for RIP.
 */
void
rip_on(struct interface *ifp)
{
	/* If the main RIP socket is already alive, only start receiving
	 * multicasts for this interface.
	 */
	if (rip_sock >= 0) {
		if (ifp != 0)
			rip_mcast_on(ifp);
		return;
	}

	/* If the main RIP socket is off, and it makes sense to turn it on,
	 * turn it on for all of the interfaces.
	 */
	if (rip_interfaces > 0 && !rdisc_ok) {
		trace_act("turn on RIP\n");

		/* Close all of the query sockets so that we can open
		 * the main socket.  SO_REUSEPORT is not a solution,
		 * since that would let two daemons bind to the broadcast
		 * socket.
		 */
		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (ifp->int_rip_sock >= 0) {
				(void)close(ifp->int_rip_sock);
				ifp->int_rip_sock = -1;
			}
		}

		rip_sock = get_rip_sock(INADDR_ANY, 1);
		rip_sock_mcast = 0;

		/* Do not advertise anything until we have heard something
		 */
		if (next_bcast.tv_sec < now.tv_sec+MIN_WAITTIME)
			next_bcast.tv_sec = now.tv_sec+MIN_WAITTIME;

		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (!IS_RIP_IN_OFF(ifp->int_state))
				ifp->int_state &= ~IS_RIP_QUERIED;
			rip_mcast_on(ifp);
		}

		ifinit_timer.tv_sec = now.tv_sec;

		fix_select();

	} else if (ifp != 0
		   && ifp->int_rip_sock < 0
		   && !(ifp->int_state & IS_ALIAS)) {
		/* RIP is off, so ensure there are sockets on which
		 * to listen for queries.
		 */
		ifp->int_rip_sock = get_rip_sock(ifp->int_addr, 0);

		fix_select();
	}
}


/* die if malloc(3) fails
 */
void *
rtmalloc(size_t size,
	 char *msg)
{
	void *p = malloc(size);
	if (p == 0)
		logbad(1,"malloc() failed in %s", msg);
	return p;
}


/* get a random instant in an interval
 */
void
intvl_random(struct timeval *tp,	/* put value here */
	     u_long lo,			/* value is after this second */
	     u_long hi)			/* and before this */
{
	tp->tv_sec = (time_t)(hi == lo
			      ? lo
			      : (lo + arc4random_uniform(1 + hi - lo)));
	tp->tv_usec = arc4random_uniform(1000000);
}


void
timevaladd(struct timeval *t1,
	   struct timeval *t2)
{

	t1->tv_sec += t2->tv_sec;
	if ((t1->tv_usec += t2->tv_usec) > 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
	}
}


/* t1 = t2 - t3
 */
static void
timevalsub(struct timeval *t1,
	   struct timeval *t2,
	   struct timeval *t3)
{
	t1->tv_sec = t2->tv_sec - t3->tv_sec;
	if ((t1->tv_usec = t2->tv_usec - t3->tv_usec) < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
}


void
msglog(char *p, ...)
{
	va_list args;

	trace_flush();

	va_start(args, p);
	vsyslog(LOG_ERR, p, args);
	va_end(args);

	if (ftrace != 0) {
		if (ftrace == stdout)
			(void)fputs("routed: ", ftrace);
		va_start(args, p);
		(void)vfprintf(ftrace, p, args);
		va_end(args);
		(void)fputc('\n', ftrace);
	}
}


void
logbad(int dump, char *p, ...)
{
	va_list args;

	trace_flush();

	va_start(args, p);
	vsyslog(LOG_ERR, p, args);
	va_end(args);

	(void)fputs("routed: ", stderr);
	va_start(args, p);
	(void)vfprintf(stderr, p, args);
	va_end(args);
	(void)fputs("; giving up\n",stderr);
	(void)fflush(stderr);

	if (dump)
		abort();
	exit(1);
}
@


1.20
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2005/03/23 18:06:07 jmc Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 2005/03/23 18:06:07 jmc Exp $";
@


1.19
log
@ - remove non-existent -p option
 - sort options
 - sync usage()
 - various formatting tweaks
 - -A reworded for clarity
 - update SEE ALSO

much help + ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2004/04/07 14:09:35 aaron Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 2004/04/07 14:09:35 aaron Exp $";
d769 2
a770 2
			      : (lo + arc4random() % ((1 + hi - lo))));
	tp->tv_usec = arc4random() % 1000000;
@


1.18
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2004/03/11 08:39:48 otto Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2004/03/11 08:39:48 otto Exp $";
d216 2
a217 2
		logbad(0, "usage: routed [-sqdghmpAt] [-T /tracefile]"
		       " [-F net[,metric]] [-P parms]");
@


1.17
log
@Fix byte ordering problems with network info read from /etc/gateways
or -P and -F options. Based on NetBSD. Resolves PR 3704.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2003/06/02 20:06:17 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 2003/06/02 20:06:17 millert Exp $";
d120 1
a120 1
	while ((n = getopt(argc, argv, "sqdghmpAtT:F:P:")) != -1) {
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2002/03/14 16:44:24 mpech Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 2002/03/14 16:44:24 mpech Exp $";
d185 1
a185 1
			parm.parm_addr_h = ntohl(p_addr);
@


1.15
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2002/03/08 11:06:17 mpech Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d38 1
a38 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2002/03/08 11:06:17 mpech Exp $";
@


1.14
log
@Fix arc4random() usage; add more randomness to intvl_random().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2002/02/16 20:25:02 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 2002/02/16 20:25:02 millert Exp $";
d636 1
a636 1
	register naddr addr;
@


1.13
log
@Instead of #defining random() as arc4random(), just use arc4random() inline
instead of srandom() / random().
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2001/07/07 18:26:20 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 2001/07/07 18:26:20 deraadt Exp $";
d773 1
a773 1
			      : (lo + arc4random() % ((hi - lo))));
@


1.12
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2001/06/13 20:13:29 markus Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 2001/06/13 20:13:29 markus Exp $";
a278 1
	srandom((int)(clk.tv_sec ^ clk.tv_usec ^ mypid));
d773 2
a774 2
			      : (lo + random() % ((hi - lo))));
	tp->tv_usec = random() % 1000000;
@


1.11
log
@more va_start/end fixes, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2001/01/19 17:57:42 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 2001/01/19 17:57:42 deraadt Exp $";
d50 3
a53 2
#include <fcntl.h>
#include <sys/file.h>
@


1.10
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2001/01/16 03:06:08 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 2001/01/16 03:06:08 deraadt Exp $";
d815 1
d820 1
d822 1
d837 1
d840 1
d842 1
@


1.9
log
@fd_set overflow handling
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1998/07/09 06:12:45 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1998/07/09 06:12:45 deraadt Exp $";
d506 1
a506 1
	trace_act("SIGALRM\n");
@


1.8
log
@MAXHOSTNAMELEN, not MAXHOSTNAMELEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/07/30 23:28:42 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/07/30 23:28:42 deraadt Exp $";
d80 1
a80 1
fd_set	fdbits;
d100 1
a100 1
	fd_set ibits;
d459 9
a467 2
		ibits = fdbits;
		n = select(sock_max, &ibits, 0, 0, &wtime);
d474 1
a474 1
		if (FD_ISSET(rt_sock, &ibits)) {
d478 1
a478 1
		if (rdisc_sock >= 0 && FD_ISSET(rdisc_sock, &ibits)) {
d482 1
a482 1
		if (rip_sock >= 0 && FD_ISSET(rip_sock, &ibits)) {
d489 1
a489 1
			    && FD_ISSET(ifp->int_rip_sock, &ibits)) {
a523 2

	FD_ZERO(&fdbits);
a525 1
	FD_SET(rt_sock, &fdbits);
d528 5
a532 4
	if (rip_sock >= 0) {
		FD_SET(rip_sock, &fdbits);
		if (sock_max <= rip_sock)
			sock_max = rip_sock+1;
d534 13
d548 2
a549 10
		if (ifp->int_rip_sock >= 0) {
			FD_SET(ifp->int_rip_sock, &fdbits);
			if (sock_max <= ifp->int_rip_sock)
				sock_max = ifp->int_rip_sock+1;
		}
	}
	if (rdisc_sock >= 0) {
		FD_SET(rdisc_sock, &fdbits);
		if (sock_max <= rdisc_sock)
			sock_max = rdisc_sock+1;
d551 2
@


1.7
log
@new routed DOES NOT EVEN COMPILE LET ALONE WORK.  TEST YOUR WORK!
Also, put back the damn security check in input.c that has been deleted
TWO SEPERATE TIMES NOW!  I CURSE anyone who deletes that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1997/01/15 23:41:12 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1997/01/15 23:41:12 millert Exp $";
d57 1
a57 1
char	myname[MAXHOSTNAMELEN+1];
d120 1
a120 1
	(void)gethostname(myname, sizeof(myname)-1);
@


1.6
log
@update to sgi-02apr97
still have problems w/ defaults from pppd
@
text
@a52 8
#if defined(sgi) && !defined(PRE_KUDZU)
#include <sys/capability.h>
int tirix_socket(int,int,int);
int tirix_bind(int, const struct sockaddr *, int);
#else
#define tirix_socket socket
#define tirix_bind bind
#endif
d101 1
a101 1
	naddr p_net, p_mask;
a106 5
	/* Some shells are badly broken and send SIGHUP to backgrounded
	 * processes.
	 */
	signal(SIGHUP, SIG_IGN);

d173 1
a173 1
			n = FAKE_METRIC;
d182 1
a182 1
			if (!getnet(optarg, &p_net, &p_mask)) {
d188 1
a188 1
			parm.parm_net = p_net;
d200 4
a203 7
			p = parse_parms(optarg, 0);
			if (p != 0) {
				if (strcasecmp(p,optarg))
					msglog("%s in \"%s\"", p, optarg);
				else
					msglog("bad \"-P %s\"", optarg);
			}
a216 2
	if (tracename != 0 && tracename[0] == '\0')
		goto usage;
d219 1
a219 1
		logbad(0, "usage: routed [-sqdghmpAt] [-T tracefile]"
d256 2
d264 1
d266 5
a270 5
	if (0 > _daemonize(background ? 0 : (_DF_NOCHDIR|_DF_NOFORK),
			   new_tracelevel == 0 ? -1 : STDOUT_FILENO,
			   new_tracelevel == 0 ? -1 : STDERR_FILENO,
			   -1))
		BADERR(0, "_daemonize()");
d272 2
a273 2
	if (background && daemon(0, new_tracelevel) < 0)
		BADERR(0,"daemon()");
d275 1
d282 1
a282 1
	rt_sock = tirix_socket(AF_ROUTE, SOCK_RAW, 0);
d298 3
a300 4
		strncpy(inittracename, tracename, sizeof(inittracename)-1);
		set_tracefile(inittracename, "%s", -1);
	} else {
		tracelevel_msg("%s", -1);   /* turn on tracing to stdio */
d302 1
a302 2

	bufinit();
d329 2
a330 1
	rdisc_sol();
d346 1
a346 1
			trace_act("time changed by %d sec", dt);
d354 1
a354 1
		/* deal with signals that should affect tracing */
d358 5
a362 3
			rip_bcast(0);
			rdisc_adv();
			trace_off("exiting with signal %d", stopint);
d493 1
a493 1
sigalrm(int s)
d499 1
a499 1
	trace_act("SIGALRM");
d556 2
a557 1
	if (setsockopt(sock, SOL_SOCKET,SO_BROADCAST, &on,sizeof(on)) < 0)
a559 7
#ifdef USE_PASSIFNAME
	on = 1;
	if (setsockopt(sock, SOL_SOCKET, SO_PASSIFNAME, &on,sizeof(on)) < 0)
		msglog("setsockopt(%s,SO_PASSIFNAME): %s",
		       name, strerror(errno));
#endif

d569 1
a569 1
				trace_act("RCVBUF=%d", rbuf);
d603 1
a603 1
	if (tirix_bind(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
d628 1
a628 1
		trace_act("turn off RIP");
d636 2
a637 3
			if (ifp->int_state & IS_REMOTE)
				continue;
			if (ifp->int_rip_sock < 0) {
d690 2
a691 2
	/* If the main RIP socket is off and it makes sense to turn it on,
	 * then turn it on for all of the interfaces.
d694 1
a694 1
		trace_act("turn on RIP");
d717 2
a718 1
			ifp->int_query_time = NEVER;
d721 1
d724 2
d727 2
a728 2
		   && !(ifp->int_state & IS_REMOTE)
		   && ifp->int_rip_sock < 0) {
d733 2
a735 2

	fix_select();
a793 2
/* put a message into the system log
 */
a812 62
/* Put a message about a bad system into the system log if
 * we have not complained about it recently.
 *
 * It is desirable to complain about all bad systems, but not too often.
 * In the worst case, it is not practical to keep track of all bad systems.
 * For example, there can be many systems with the wrong password.
 */
void
msglim(struct msg_limit *lim, naddr addr, char *p, ...)
{
	va_list args;
	int i;
	struct msg_sub *ms1, *ms;
	char *p1;

	va_start(args, p);

	/* look for the oldest slot in the table
	 * or the slot for the bad router.
	 */
	ms = ms1 = lim->subs;
	for (i = MSG_SUBJECT_N; ; i--, ms1++) {
		if (i == 0) {
			/* Reuse a slot at most once every 10 minutes.
			 */
			if (lim->reuse > now.tv_sec) {
				ms = 0;
			} else {
				ms = ms1;
				lim->reuse = now.tv_sec + 10*60;
			}
			break;
		}
		if (ms->addr == addr) {
			/* Repeat a complaint about a given system at
			 * most once an hour.
			 */
			if (ms->until > now.tv_sec)
				ms = 0;
			break;
		}
		if (ms->until < ms1->until)
			ms = ms1;
	}
	if (ms != 0) {
		ms->addr = addr;
		ms->until = now.tv_sec + 60*60;	/* 60 minutes */

		trace_flush();
		for (p1 = p; *p1 == ' '; p1++)
			continue;
		vsyslog(LOG_ERR, p1, args);
	}

	/* always display the message if tracing */
	if (ftrace != 0) {
		(void)vfprintf(ftrace, p, args);
		(void)fputc('\n', ftrace);
	}
}


a831 30
#if defined(sgi) && !defined(PRE_KUDZU)


int
tirix_socket(int domain ,int type, int protocol)
{
	cap_t ocap;
	cap_value_t cap_priv_port = CAP_PRIV_PORT;
	int r;

	ocap = cap_acquire(1, &cap_priv_port);
	r = socket(domain, type, protocol);
	cap_surrender(ocap);
	return r;
}


int
tirix_bind(int s, const struct sockaddr *name, int namelen)
{
	int r;
	cap_t ocap;
	cap_value_t cap_priv_port = CAP_PRIV_PORT;

	ocap = cap_acquire(1, &cap_priv_port);
	r = bind(s, name, namelen);
	cap_surrender(ocap);
	return r;
}
#endif
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/10/02 06:51:45 mickey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1996/10/02 06:51:45 mickey Exp $";
d53 8
d109 1
a109 1
	naddr p_addr, p_mask;
d115 5
d186 1
a186 1
			n = HOPCNT_INFINITY-2;
d195 1
a195 1
			if (!getnet(optarg, &p_addr, &p_mask)) {
d201 1
a201 1
			parm.parm_addr_h = ntohl(p_addr);
d213 7
a219 4
			p = parse_parms(optarg);
			if (p != 0)
				msglog("bad \"%s\" in \"%s\"",
				       p, optarg);
d233 2
d237 1
a237 1
		logbad(0, "usage: routed [-sqdghmpAt] [-T /tracefile]"
a273 2
	else
		signal(SIGHUP, SIG_IGN);
a279 1
	if (background) {
d281 5
a285 5
		if (0 > _daemonize(_DF_NOCHDIR,
				   new_tracelevel == 0 ? -1 : STDOUT_FILENO,
				   new_tracelevel == 0 ? -1 : STDERR_FILENO,
				   -1))
			BADERR(0, "_daemonize()");
d287 2
a288 2
		if (daemon(1, 1) < 0)
			BADERR(0,"daemon()");
a289 1
	}
d296 1
a296 1
	rt_sock = socket(AF_ROUTE, SOCK_RAW, 0);
d312 4
a315 3
		trace_on(tracename, 1);
		if (new_tracelevel == 0)	/* use stdout if file is bad */
			new_tracelevel = 1;
d317 2
a318 1
	set_tracelevel();
d345 1
a345 2
	if (!supplier)
		rdisc_sol();
d361 1
a361 1
			trace_act("time changed by %d sec\n", dt);
d369 1
a369 1
		/* deal with interrupts that should affect tracing */
d373 3
a375 5
			if (supplier) {
				rip_bcast(0);
				rdisc_adv();
			}
			trace_off("exiting with signal %d\n", stopint);
d506 1
a506 1
sigalrm(int sig)
d512 1
a512 1
	trace_act("SIGALRM\n");
d569 1
a569 2
	if (setsockopt(sock, SOL_SOCKET,SO_BROADCAST,
		       &on,sizeof(on)) < 0)
d572 7
d588 1
a588 1
				trace_act("RCVBUF=%d\n", rbuf);
d622 1
a622 1
	if (bind(s, (struct sockaddr *)&sin,sizeof(sin)) < 0) {
d647 1
a647 1
		trace_act("turn off RIP\n");
d655 3
a657 2
			if (ifp->int_rip_sock < 0
			    && !(ifp->int_state & IS_ALIAS)) {
d710 2
a711 2
	/* If the main RIP socket is off, and it makes sense to turn it on,
	 * turn it on for all of the interfaces.
d714 1
a714 1
		trace_act("turn on RIP\n");
d737 1
a737 2
			if (!IS_RIP_IN_OFF(ifp->int_state))
				ifp->int_state &= ~IS_RIP_QUERIED;
a739 1

a741 2
		fix_select();

d743 2
a744 2
		   && ifp->int_rip_sock < 0
		   && !(ifp->int_state & IS_ALIAS)) {
d749 1
d751 1
a751 2
		fix_select();
	}
d810 2
d831 62
d912 30
@


1.4
log
@update to the latest version from Sep 12.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/09/05 14:31:32 mickey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1996/09/05 14:31:32 mickey Exp $";
d123 1
a123 1
	while ((n = getopt(argc, argv, "sqdghmpAtT:F:P:")) != EOF) {
@


1.3
log
@fix import.
mention that routed is from vjs@@sgi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/06/23 14:32:29 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.2 1996/06/23 14:32:29 deraadt Exp $";
d253 10
a318 7

	signal(SIGALRM, sigalrm);
	signal(SIGHUP, sigterm);
	signal(SIGTERM, sigterm);
	signal(SIGINT, sigterm);
	signal(SIGUSR1, sigtrace_on);
	signal(SIGUSR2, sigtrace_off);
@


1.2
log
@update rcsid
@
text
@d1 1
a1 2
/*	$OpenBSD: main.c,v 1.13 1995/06/20 22:27:53 christos Exp $	*/
/*	$NetBSD: main.c,v 1.13 1995/06/20 22:27:53 christos Exp $	*/
d36 1
a36 2
#ifndef lint
static char copyright[] =
d39 1
a39 4
#endif /* not lint */

#ifndef lint
#if 0
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 1995/06/20 22:27:53 christos Exp $";
a43 1
#endif /* not lint */
a44 3
/*
 * Routing Table Management Daemon
 */
d46 6
a51 1
#include <sys/ioctl.h>
d54 1
a54 1
#include <net/if.h>
d56 30
a85 4
#include <errno.h>
#include <signal.h>
#include <syslog.h>
#include "pathnames.h"
a86 5
int	supplier = -1;		/* process should supply updates */
int	gateway = 0;		/* 1 if we are a gateway to parts beyond */
int	debug = 0;
int	bufspace = 127*1024;	/* max. input buffer size to request */
struct	rip *msg = (struct rip *)packet;
d88 2
a89 2
int getsocket __P((int, int, struct sockaddr_in *));
void process __P((int));
d92 8
a99 8
main(argc, argv)
	int argc;
	char *argv[];
{
	int n, nfd, tflags = 0;
	struct timeval *tvp, waittime;
	struct itimerval itval;
	register struct rip *query = msg;
d101 6
a106 4
	sigset_t sigset, osigset;
	
	argv0 = argv;
#if BSD >= 43
d108 153
a260 1
	setlogmask(LOG_UPTO(LOG_WARNING));
d262 2
a263 3
	openlog("routed", LOG_PID);
#define LOG_UPTO(x) (x)
#define setlogmask(x) (x)
d265 104
a368 23
	sp = getservbyname("router", "udp");
	if (sp == NULL) {
		fprintf(stderr, "routed: router/udp: unknown service\n");
		exit(1);
	}
	addr.sin_family = AF_INET;
	addr.sin_port = sp->s_port;
	r = socket(AF_ROUTE, SOCK_RAW, 0);
	/* later, get smart about lookingforinterfaces */
	if (r)
		shutdown(r, 0); /* for now, don't want reponses */
	else {
		fprintf(stderr, "routed: no routing socket\n");
		exit(1);
	}
	s = getsocket(AF_INET, SOCK_DGRAM, &addr);
	if (s < 0)
		exit(1);
	argv++, argc--;
	while (argc > 0 && **argv == '-') {
		if (strcmp(*argv, "-s") == 0) {
			supplier = 1;
			argv++, argc--;
d371 55
a425 3
		if (strcmp(*argv, "-q") == 0) {
			supplier = 0;
			argv++, argc--;
d428 8
a435 4
		if (strcmp(*argv, "-t") == 0) {
			tflags++;
			setlogmask(LOG_UPTO(LOG_DEBUG));
			argv++, argc--;
d438 8
a445 4
		if (strcmp(*argv, "-d") == 0) {
			debug++;
			setlogmask(LOG_UPTO(LOG_DEBUG));
			argv++, argc--;
d448 13
a460 3
		if (strcmp(*argv, "-g") == 0) {
			gateway = 1;
			argv++, argc--;
d463 21
a483 3
		fprintf(stderr,
			"usage: routed [ -s ] [ -q ] [ -t ] [ -g ]\n");
		exit(1);
d485 2
d488 6
a493 5
	if (debug == 0 && tflags == 0)
		daemon(0, 0);
	/*
	 * Any extra argument is considered
	 * a tracing log file.
d495 53
a547 41
	if (argc > 0)
		traceon(*argv);
	while (tflags-- > 0)
		bumploglevel();

	(void) gettimeofday(&now, NULL);
	/*
	 * Collect an initial view of the world by
	 * checking the interface configuration and the gateway kludge
	 * file.  Then, send a request packet on all
	 * directly connected networks to find out what
	 * everyone else thinks.
	 */
	rtinit();
	ifinit();
	gwkludge();
	if (gateway > 0)
		rtdefault();
	if (supplier < 0)
		supplier = 0;
	query->rip_cmd = RIPCMD_REQUEST;
	query->rip_vers = RIP_VERSION_1;
	if (sizeof(query->rip_nets[0].rip_family) > 1)	/* XXX */
		query->rip_nets[0].rip_family = htons((u_short)AF_UNSPEC);
	else
		query->rip_nets[0].rip_family = AF_UNSPEC;
	query->rip_nets[0].rip_metric = htonl((u_long)HOPCNT_INFINITY);
	toall(sndmsg, 0, NULL);
	signal(SIGALRM, timer);
	signal(SIGHUP, hup);
	signal(SIGTERM, hup);
	signal(SIGINT, rtdeleteall);
	signal(SIGUSR1, sigtrace);
	signal(SIGUSR2, sigtrace);
	itval.it_interval.tv_sec = TIMER_RATE;
	itval.it_value.tv_sec = TIMER_RATE;
	itval.it_interval.tv_usec = 0;
	itval.it_value.tv_usec = 0;
	srandom(getpid());
	if (setitimer(ITIMER_REAL, &itval, NULL) < 0)
		syslog(LOG_ERR, "setitimer: %m\n");
d549 19
a567 17
	FD_ZERO(&ibits);
	nfd = s + 1;			/* 1 + max(fd's) */
	for (;;) {
		FD_SET(s, &ibits);
		/*
		 * If we need a dynamic update that was held off,
		 * needupdate will be set, and nextbcast is the time
		 * by which we want select to return.  Compute time
		 * until dynamic update should be sent, and select only
		 * until then.  If we have already passed nextbcast,
		 * just poll.
		 */
		if (needupdate) {
			timersub(&nextbcast, &now, &waittime);
			if (waittime.tv_sec < 0) {
				waittime.tv_sec = 0;
				waittime.tv_usec = 0;
d569 4
a572 18
			if (traceactions)
				fprintf(ftrace,
				 "select until dynamic update %d/%d sec/usec\n",
				    waittime.tv_sec, waittime.tv_usec);
			tvp = &waittime;
		} else
			tvp = NULL;
		n = select(nfd, &ibits, 0, 0, tvp);
		if (n <= 0) {
			/*
			 * Need delayed dynamic update if select returned
			 * nothing and we timed out.  Otherwise, ignore
			 * errors (e.g. EINTR).
			 */
			if (n < 0) {
				if (errno == EINTR)
					continue;
				syslog(LOG_ERR, "select: %m");
d574 65
a638 12
			sigemptyset(&sigset);
			sigaddset(&sigset, SIGALRM);
			sigprocmask(SIG_BLOCK, &sigset, &osigset);
			if (n == 0 && needupdate) {
				if (traceactions)
					fprintf(ftrace,
					    "send delayed dynamic update\n");
				(void) gettimeofday(&now, NULL);
				toall(supply, RTS_CHANGED, NULL);
				lastbcast = now;
				needupdate = 0;
				nextbcast.tv_sec = 0;
a639 2
			sigprocmask(SIG_SETMASK, &osigset, NULL);
			continue;
d641 19
a659 19
		(void) gettimeofday(&now, NULL);
		sigemptyset(&sigset);
		sigaddset(&sigset, SIGALRM);
		sigprocmask(SIG_BLOCK, &sigset, &osigset);
#ifdef doesntwork
/*
printf("s %d, ibits %x index %d, mod %d, sh %x, or %x &ibits %x\n",
	s,
	ibits.fds_bits[0],
	(s)/(sizeof(fd_mask) * 8),
	((s) % (sizeof(fd_mask) * 8)),
	(1 << ((s) % (sizeof(fd_mask) * 8))),
	ibits.fds_bits[(s)/(sizeof(fd_mask) * 8)] & (1 << ((s) % (sizeof(fd_mask) * 8))),
	&ibits
	);
*/
		if (FD_ISSET(s, &ibits))
#else
		if (ibits.fds_bits[s/32] & (1 << s))
d661 8
a668 3
			process(s);
		/* handle ICMP redirects */
		sigprocmask(SIG_SETMASK, &osigset, NULL);
d672 3
d676 1
a676 2
process(fd)
	int fd;
d678 34
a711 6
	struct sockaddr from;
	int fromlen, cc;
	union {
		char	buf[MAXPACKETSIZE+1];
		struct	rip rip;
	} inbuf;
d713 4
a716 7
	for (;;) {
		fromlen = sizeof (from);
		cc = recvfrom(fd, &inbuf, sizeof (inbuf), 0, &from, &fromlen);
		if (cc <= 0) {
			if (cc < 0 && errno != EWOULDBLOCK)
				perror("recvfrom");
			break;
d718 14
a731 3
		if (fromlen != sizeof (struct sockaddr_in))
			break;
		rip_input(&from, &inbuf.rip, cc);
d735 37
a771 17
int
getsocket(domain, type, sin)
	int domain, type;
	struct sockaddr_in *sin;
{
	int sock, on = 1;

	if ((sock = socket(domain, type, 0)) < 0) {
		perror("socket");
		syslog(LOG_ERR, "socket: %m");
		return (-1);
	}
#ifdef SO_BROADCAST
	if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0) {
		syslog(LOG_ERR, "setsockopt SO_BROADCAST: %m");
		close(sock);
		return (-1);
d773 14
a786 10
#endif
#ifdef SO_RCVBUF
	for (on = bufspace; ; on -= 1024) {
		if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
		    &on, sizeof (on)) == 0)
			break;
		if (on <= 8*1024) {
			syslog(LOG_ERR, "setsockopt SO_RCVBUF: %m");
			break;
		}
d788 18
a805 8
	if (traceactions)
		fprintf(ftrace, "recv buf %d\n", on);
#endif
	if (bind(sock, (struct sockaddr *)sin, sizeof (*sin)) < 0) {
		perror("bind");
		syslog(LOG_ERR, "bind: %m");
		close(sock);
		return (-1);
d807 21
a827 3
	if (fcntl(sock, F_SETFL, O_NONBLOCK) == -1)
		syslog(LOG_ERR, "fcntl O_NONBLOCK: %m\n");
	return (sock);
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.13 1995/06/20 22:27:53 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@new routed from SGI.
rip1, rip2, icmp, rdisc.
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
d36 2
a37 1
char copyright[] =
d40 4
a43 1
#if !defined(lint)
d45 2
d48 1
d50 3
d54 1
a54 6
#include "pathnames.h"
#ifdef sgi
#include "math.h"
#endif
#include <signal.h>
#include <fcntl.h>
d57 1
a57 1
pid_t	mypid;
d59 4
a62 30
naddr	myaddr;				/* system address */
char	myname[MAXHOSTNAMELEN+1];

int	supplier;			/* supply or broadcast updates */
int	supplier_set;
int	ipforwarding = 1;		/* kernel forwarding on */

int	default_gateway;		/* 1=advertise default */
int	background = 1;
int	ridhosts;			/* 1=reduce host routes */
int	mhome;				/* 1=want multi-homed host route */
int	advertise_mhome;		/* 1=must continue adverising it */
int	auth_ok = 1;			/* 1=ignore auth if we do not care */

struct timeval epoch;			/* when started */
struct timeval clk, prev_clk;
struct timeval now;			/* current idea of time */
time_t	now_stale;
time_t	now_expire;
time_t	now_garbage;

struct timeval next_bcast;		/* next general broadcast */
struct timeval no_flash = {EPOCH+SUPPLY_INTERVAL};  /* inhibit flash update */

fd_set	fdbits;
int	sock_max;
int	rip_sock = -1;			/* RIP socket */
struct interface *rip_sock_mcast;	/* current multicast interface */
int	rt_sock;			/* routing socket */
int	rt_sock_seqno;
d64 5
d70 2
a71 2
static  int get_rip_sock(naddr, int);
static void timevalsub(struct timeval *, struct timeval *, struct timeval *);
d74 8
a81 8
main(int argc,
     char *argv[])
{
	int n, mib[4], off;
	size_t len;
	char *p, *q;
	struct timeval wtime, t2;
	time_t dt;
d83 4
a86 6
	naddr p_addr, p_mask;
	struct interface *ifp;
	struct parm parm;
	char *tracename = 0;


d88 1
a88 153
	ftrace = stdout;

	gettimeofday(&clk, 0);
	prev_clk = clk;
	epoch = clk;
	epoch.tv_sec -= EPOCH;
	now.tv_sec = EPOCH;
	now_stale = EPOCH - STALE_TIME;
	now_expire = EPOCH - EXPIRE_TIME;
	now_garbage = EPOCH - GARBAGE_TIME;
	wtime.tv_sec = 0;

	(void)gethostname(myname, sizeof(myname)-1);
	(void)gethost(myname, &myaddr);

	while ((n = getopt(argc, argv, "sqdghmpAtT:F:P:")) != EOF) {
		switch (n) {
		case 's':
			supplier = 1;
			supplier_set = 1;
			break;

		case 'q':
			supplier = 0;
			supplier_set = 1;
			break;

		case 'd':
			background = 0;
			break;

		case 'g':
			bzero(&parm, sizeof(parm));
			parm.parm_d_metric = 1;
			p = check_parms(&parm);
			if (p != 0)
				msglog("bad -g: %s", p);
			else
				default_gateway = 1;
			break;

		case 'h':		/* suppress extra host routes */
			ridhosts = 1;
			break;

		case 'm':		/* advertise host route */
			mhome = 1;	/* on multi-homed hosts */
			break;

		case 'A':
			/* Ignore authentication if we do not care.
			 * Crazy as it is, that is what RFC 1723 requires.
			 */
			auth_ok = 0;
			break;

		case 't':
			new_tracelevel++;
			break;

		case 'T':
			tracename = optarg;
			break;

		case 'F':		/* minimal routes for SLIP */
			n = HOPCNT_INFINITY-2;
			p = strchr(optarg,',');
			if (p && *p != '\0') {
				n = (int)strtoul(p+1, &q, 0);
				if (*q == '\0'
				    && n <= HOPCNT_INFINITY-1
				    && n >= 1)
					*p = '\0';
			}
			if (!getnet(optarg, &p_addr, &p_mask)) {
				msglog("bad network; \"-F %s\"",
				       optarg);
				break;
			}
			bzero(&parm, sizeof(parm));
			parm.parm_addr_h = ntohl(p_addr);
			parm.parm_mask = p_mask;
			parm.parm_d_metric = n;
			p = check_parms(&parm);
			if (p != 0)
				msglog("bad -F: %s", p);
			break;

		case 'P':
			/* handle arbirary, (usually) per-interface
			 * parameters.
			 */
			p = parse_parms(optarg);
			if (p != 0)
				msglog("bad \"%s\" in \"%s\"",
				       p, optarg);
			break;

		default:
			goto usage;
		}
	}
	argc -= optind;
	argv += optind;

	if (tracename == 0 && argc >= 1) {
		tracename = *argv++;
		argc--;
	}
	if (argc != 0) {
usage:
		logbad(0, "usage: routed [-sqdghmpAt] [-T /tracefile]"
		       " [-F net[,metric]] [-P parms]");
	}
	if (geteuid() != 0)
		logbad(0, "requires UID 0");

	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, 0, 0) < 0)
		LOGERR("sysctl(IPCTL_FORWARDING)");

	if (!ipforwarding) {
		if (supplier)
			msglog("-s incompatible with ipforwarding=0");
		if (default_gateway) {
			msglog("-g incompatible with ipforwarding=0");
			default_gateway = 0;
		}
		supplier = 0;
		supplier_set = 1;
	}
	if (default_gateway) {
		if (supplier_set && !supplier) {
			msglog("-g and -q incompatible");
		} else {
			supplier = 1;
			supplier_set = 1;
		}
	}


	/* get into the background */
	if (background) {
#ifdef sgi
		if (0 > _daemonize(_DF_NOCHDIR,
				   new_tracelevel == 0 ? -1 : STDOUT_FILENO,
				   new_tracelevel == 0 ? -1 : STDERR_FILENO,
				   -1))
			BADERR(0, "_daemonize()");
d90 3
a92 2
		if (daemon(1, 1) < 0)
			BADERR(0,"daemon()");
d94 23
a116 104
	}

	mypid = getpid();
	srandom((int)(clk.tv_sec ^ clk.tv_usec ^ mypid));

	/* prepare socket connected to the kernel.
	 */
	rt_sock = socket(AF_ROUTE, SOCK_RAW, 0);
	if (rt_sock < 0)
		BADERR(1,"rt_sock = socket()");
	if (fcntl(rt_sock, F_SETFL, O_NONBLOCK) == -1)
		logbad(1, "fcntl(rt_sock) O_NONBLOCK: %s", strerror(errno));
	off = 0;
	if (setsockopt(rt_sock, SOL_SOCKET,SO_USELOOPBACK,
		       &off,sizeof(off)) < 0)
		LOGERR("setsockopt(SO_USELOOPBACK,0)");

	fix_select();


	if (background && new_tracelevel == 0)
		ftrace = 0;
	if (tracename != 0) {
		trace_on(tracename, 1);
		if (new_tracelevel == 0)	/* use stdout if file is bad */
			new_tracelevel = 1;
	}
	set_tracelevel();

	/* initialize radix tree */
	rtinit();

	/* Pick a random part of the second for our output to minimize
	 * collisions.
	 *
	 * Start broadcasting after hearing from other routers, and
	 * at a random time so a bunch of systems do not get synchronized
	 * after a power failure.
	 */
	intvl_random(&next_bcast, EPOCH+MIN_WAITTIME, EPOCH+SUPPLY_INTERVAL);
	age_timer.tv_usec = next_bcast.tv_usec;
	age_timer.tv_sec = EPOCH+MIN_WAITTIME;
	rdisc_timer = next_bcast;
	ifinit_timer.tv_usec = next_bcast.tv_usec;

	signal(SIGALRM, sigalrm);
	signal(SIGHUP, sigterm);
	signal(SIGTERM, sigterm);
	signal(SIGINT, sigterm);
	signal(SIGUSR1, sigtrace_on);
	signal(SIGUSR2, sigtrace_off);

	/* Collect an initial view of the world by checking the interface
	 * configuration and the kludge file.
	 */
	gwkludge();
	ifinit();
	flush_kern();

	/* Ask for routes */
	rip_query();
	if (!supplier)
		rdisc_sol();

	/* Loop forever, listening and broadcasting.
	 */
	for (;;) {
		prev_clk = clk;
		gettimeofday(&clk, 0);
		timevalsub(&t2, &clk, &prev_clk);
		if (t2.tv_sec < 0
		    || t2.tv_sec > wtime.tv_sec + 5) {
			/* Deal with time changes before other housekeeping to
			 * keep everything straight.
			 */
			dt = t2.tv_sec;
			if (dt > 0)
				dt -= wtime.tv_sec;
			trace_act("time changed by %d sec\n", dt);
			epoch.tv_sec += dt;
		}
		timevalsub(&now, &clk, &epoch);
		now_stale = now.tv_sec - STALE_TIME;
		now_expire = now.tv_sec - EXPIRE_TIME;
		now_garbage = now.tv_sec - GARBAGE_TIME;

		/* deal with interrupts that should affect tracing */
		set_tracelevel();

		if (stopint != 0) {
			if (supplier) {
				rip_bcast(0);
				rdisc_adv();
			}
			trace_off("exiting with signal %d\n", stopint);
			exit(stopint | 128);
		}

		/* look for new or dead interfaces */
		timevalsub(&wtime, &ifinit_timer, &now);
		if (wtime.tv_sec <= 0) {
			wtime.tv_sec = 0;
			ifinit();
			rip_query();
d119 3
a121 55

		/* If it is time, then broadcast our routes.
		 */
		if (supplier || advertise_mhome) {
			timevalsub(&t2, &next_bcast, &now);
			if (t2.tv_sec <= 0) {
				/* Synchronize the aging and broadcast
				 * timers to minimize awakenings
				 */
				age(0);

				rip_bcast(0);

				/* It is desirable to send routing updates
				 * regularly.  So schedule the next update
				 * 30 seconds after the previous one was
				 * secheduled, instead of 30 seconds after
				 * the previous update was finished.
				 * Even if we just started after discovering
				 * a 2nd interface or were otherwise delayed,
				 * pick a 30-second aniversary of the
				 * original broadcast time.
				 */
				n = 1 + (0-t2.tv_sec)/SUPPLY_INTERVAL;
				next_bcast.tv_sec += n*SUPPLY_INTERVAL;

				continue;
			}

			if (timercmp(&t2, &wtime, <))
				wtime = t2;
		}

		/* If we need a flash update, either do it now or
		 * set the delay to end when it is time.
		 *
		 * If we are within MIN_WAITTIME seconds of a full update,
		 * do not bother.
		 */
		if (need_flash
		    && supplier
		    && no_flash.tv_sec+MIN_WAITTIME < next_bcast.tv_sec) {
			/* accurate to the millisecond */
			if (!timercmp(&no_flash, &now, >))
				rip_bcast(1);
			timevalsub(&t2, &no_flash, &now);
			if (timercmp(&t2, &wtime, <))
				wtime = t2;
		}

		/* trigger the main aging timer.
		 */
		timevalsub(&t2, &age_timer, &now);
		if (t2.tv_sec <= 0) {
			age(0);
d124 4
a127 8
		if (timercmp(&t2, &wtime, <))
			wtime = t2;

		/* update the kernel routing table
		 */
		timevalsub(&t2, &need_kern, &now);
		if (t2.tv_sec <= 0) {
			age(0);
d130 4
a133 8
		if (timercmp(&t2, &wtime, <))
			wtime = t2;

		/* take care of router discovery,
		 * but do it to the millisecond
		 */
		if (!timercmp(&rdisc_timer, &now, >)) {
			rdisc_age(0);
d136 3
a138 13
		timevalsub(&t2, &rdisc_timer, &now);
		if (timercmp(&t2, &wtime, <))
			wtime = t2;


		/* wait for input or a timer to expire.
		 */
		trace_flush();
		ibits = fdbits;
		n = select(sock_max, &ibits, 0, 0, &wtime);
		if (n <= 0) {
			if (n < 0 && errno != EINTR && errno != EAGAIN)
				BADERR(1,"select");
d141 3
a143 21

		if (FD_ISSET(rt_sock, &ibits)) {
			read_rt();
			n--;
		}
		if (rdisc_sock >= 0 && FD_ISSET(rdisc_sock, &ibits)) {
			read_d();
			n--;
		}
		if (rip_sock >= 0 && FD_ISSET(rip_sock, &ibits)) {
			read_rip(rip_sock, 0);
			n--;
		}

		for (ifp = ifnet; n > 0 && 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_rip_sock >= 0
			    && FD_ISSET(ifp->int_rip_sock, &ibits)) {
				read_rip(ifp->int_rip_sock, ifp);
				n--;
			}
		}
a144 1
}
d146 18
a163 7

/* ARGSUSED */
void
sigalrm(int sig)
{
	/* Historically, SIGALRM would cause the daemon to check for
	 * new and broken interfaces.
d165 28
a192 3
	ifinit_timer.tv_sec = now.tv_sec;
	trace_act("SIGALRM\n");
}
d194 36
a229 69

/* watch for fatal signals */
void
sigterm(int sig)
{
	stopint = sig;
	(void)signal(sig, SIG_DFL);	/* catch it only once */
}


void
fix_select(void)
{
	struct interface *ifp;


	FD_ZERO(&fdbits);
	sock_max = 0;

	FD_SET(rt_sock, &fdbits);
	if (sock_max <= rt_sock)
		sock_max = rt_sock+1;
	if (rip_sock >= 0) {
		FD_SET(rip_sock, &fdbits);
		if (sock_max <= rip_sock)
			sock_max = rip_sock+1;
	}
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
		if (ifp->int_rip_sock >= 0) {
			FD_SET(ifp->int_rip_sock, &fdbits);
			if (sock_max <= ifp->int_rip_sock)
				sock_max = ifp->int_rip_sock+1;
		}
	}
	if (rdisc_sock >= 0) {
		FD_SET(rdisc_sock, &fdbits);
		if (sock_max <= rdisc_sock)
			sock_max = rdisc_sock+1;
	}
}


void
fix_sock(int sock,
	 char *name)
{
	int on;
#define MIN_SOCKBUF (4*1024)
	static int rbuf;

	if (fcntl(sock, F_SETFL, O_NONBLOCK) == -1)
		logbad(1, "fcntl(%s) O_NONBLOCK: %s",
		       name, strerror(errno));
	on = 1;
	if (setsockopt(sock, SOL_SOCKET,SO_BROADCAST,
		       &on,sizeof(on)) < 0)
		msglog("setsockopt(%s,SO_BROADCAST): %s",
		       name, strerror(errno));
	if (rbuf >= MIN_SOCKBUF) {
		if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
			       &rbuf, sizeof(rbuf)) < 0)
			msglog("setsockopt(%s,SO_RCVBUF=%d): %s",
			       name, rbuf, strerror(errno));
	} else {
		for (rbuf = 60*1024; ; rbuf -= 4096) {
			if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
				       &rbuf, sizeof(rbuf)) == 0) {
				trace_act("RCVBUF=%d\n", rbuf);
				break;
d231 12
a242 4
			if (rbuf < MIN_SOCKBUF) {
				msglog("setsockopt(%s,SO_RCVBUF = %d): %s",
				       name, rbuf, strerror(errno));
				break;
d244 2
d247 19
a265 21
	}
}


/* get a rip socket
 */
static int				/* <0 or file descriptor */
get_rip_sock(naddr addr,
	     int serious)		/* 1=failure to bind is serious */
{
	struct sockaddr_in sin;
	unsigned char ttl;
	int s;


	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		BADERR(1,"rip_sock = socket()");

	bzero(&sin,sizeof(sin));
#ifdef _HAVE_SIN_LEN
	sin.sin_len = sizeof(sin);
d267 3
a269 7
	sin.sin_family = AF_INET;
	sin.sin_port = htons(RIP_PORT);
	sin.sin_addr.s_addr = addr;
	if (bind(s, (struct sockaddr *)&sin,sizeof(sin)) < 0) {
		if (serious)
			BADERR(errno != EADDRINUSE, "bind(rip_sock)");
		return -1;
a270 8
	fix_sock(s,"rip_sock");

	ttl = 1;
	if (setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL,
		       &ttl, sizeof(ttl)) < 0)
		DBGERR(1,"rip_sock setsockopt(IP_MULTICAST_TTL)");

	return s;
a272 2

/* turn off main RIP socket */
d274 2
a275 1
rip_off(void)
d277 6
a282 2
	struct interface *ifp;
	register naddr addr;
d284 7
a290 17

	if (rip_sock >= 0 && !mhome) {
		trace_act("turn off RIP\n");

		(void)close(rip_sock);
		rip_sock = -1;

		/* get non-broadcast sockets to listen to queries.
		 */
		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (ifp->int_rip_sock < 0
			    && !(ifp->int_state & IS_ALIAS)) {
				addr = ((ifp->int_if_flags & IFF_POINTOPOINT)
					? ifp->int_dstaddr
					: ifp->int_addr);
				ifp->int_rip_sock = get_rip_sock(addr, 0);
			}
d292 3
a294 4

		fix_select();

		age(0);
d298 18
a315 12

/* turn on RIP multicast input via an interface
 */
static void
rip_mcast_on(struct interface *ifp)
{
	struct ip_mreq m;

	if (!IS_RIP_IN_OFF(ifp->int_state)
	    && (ifp->int_if_flags & IFF_MULTICAST)
#ifdef MCAST_PPP_BUG
	    && !(ifp->int_if_flags & IFF_POINTOPOINT)
d317 8
a324 42
	    && !(ifp->int_state & IS_ALIAS)) {
		m.imr_multiaddr.s_addr = htonl(INADDR_RIP_GROUP);
		m.imr_interface.s_addr = ((ifp->int_if_flags & IFF_POINTOPOINT)
					  ? ifp->int_dstaddr
					  : ifp->int_addr);
		if (setsockopt(rip_sock,IPPROTO_IP, IP_ADD_MEMBERSHIP,
			       &m, sizeof(m)) < 0)
			LOGERR("setsockopt(IP_ADD_MEMBERSHIP RIP)");
	}
}


/* Prepare socket used for RIP.
 */
void
rip_on(struct interface *ifp)
{
	/* If the main RIP socket is already alive, only start receiving
	 * multicasts for this interface.
	 */
	if (rip_sock >= 0) {
		if (ifp != 0)
			rip_mcast_on(ifp);
		return;
	}

	/* If the main RIP socket is off, and it makes sense to turn it on,
	 * turn it on for all of the interfaces.
	 */
	if (rip_interfaces > 0 && !rdisc_ok) {
		trace_act("turn on RIP\n");

		/* Close all of the query sockets so that we can open
		 * the main socket.  SO_REUSEPORT is not a solution,
		 * since that would let two daemons bind to the broadcast
		 * socket.
		 */
		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (ifp->int_rip_sock >= 0) {
				(void)close(ifp->int_rip_sock);
				ifp->int_rip_sock = -1;
			}
a325 28

		rip_sock = get_rip_sock(INADDR_ANY, 1);
		rip_sock_mcast = 0;

		/* Do not advertise anything until we have heard something
		 */
		if (next_bcast.tv_sec < now.tv_sec+MIN_WAITTIME)
			next_bcast.tv_sec = now.tv_sec+MIN_WAITTIME;

		for (ifp = ifnet; ifp != 0; ifp = ifp->int_next) {
			if (!IS_RIP_IN_OFF(ifp->int_state))
				ifp->int_state &= ~IS_RIP_QUERIED;
			rip_mcast_on(ifp);
		}

		ifinit_timer.tv_sec = now.tv_sec;

		fix_select();

	} else if (ifp != 0
		   && ifp->int_rip_sock < 0
		   && !(ifp->int_state & IS_ALIAS)) {
		/* RIP is off, so ensure there are sockets on which
		 * to listen for queries.
		 */
		ifp->int_rip_sock = get_rip_sock(ifp->int_addr, 0);

		fix_select();
d327 8
a334 39
}


/* die if malloc(3) fails
 */
void *
rtmalloc(size_t size,
	 char *msg)
{
	void *p = malloc(size);
	if (p == 0)
		logbad(1,"malloc() failed in %s", msg);
	return p;
}


/* get a random instant in an interval
 */
void
intvl_random(struct timeval *tp,	/* put value here */
	     u_long lo,			/* value is after this second */
	     u_long hi)			/* and before this */
{
	tp->tv_sec = (time_t)(hi == lo
			      ? lo
			      : (lo + random() % ((hi - lo))));
	tp->tv_usec = random() % 1000000;
}


void
timevaladd(struct timeval *t1,
	   struct timeval *t2)
{

	t1->tv_sec += t2->tv_sec;
	if ((t1->tv_usec += t2->tv_usec) > 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
d336 3
a338 55
}


/* t1 = t2 - t3
 */
static void
timevalsub(struct timeval *t1,
	   struct timeval *t2,
	   struct timeval *t3)
{
	t1->tv_sec = t2->tv_sec - t3->tv_sec;
	if ((t1->tv_usec = t2->tv_usec - t3->tv_usec) < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
}


void
msglog(char *p, ...)
{
	va_list args;

	trace_flush();

	va_start(args, p);
	vsyslog(LOG_ERR, p, args);

	if (ftrace != 0) {
		if (ftrace == stdout)
			(void)fputs("routed: ", ftrace);
		(void)vfprintf(ftrace, p, args);
		(void)fputc('\n', ftrace);
	}
}


void
logbad(int dump, char *p, ...)
{
	va_list args;

	trace_flush();

	va_start(args, p);
	vsyslog(LOG_ERR, p, args);

	(void)fputs("routed: ", stderr);
	(void)vfprintf(stderr, p, args);
	(void)fputs("; giving up\n",stderr);
	(void)fflush(stderr);

	if (dump)
		abort();
	exit(1);
@
