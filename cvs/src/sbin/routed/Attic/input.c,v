head	1.15;
access;
symbols
	OPENBSD_4_3:1.14.0.20
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.18
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.16
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.14
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	mickey:1.1.1.2
	SGI082896:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2008.05.07.11.55.20;	author claudio;	state dead;
branches;
next	1.14;

1.14
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.06.21.12.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.06.18.15.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.26.19.45.17;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.05.05.23.46;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.07.30.23.28.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.22.24.42;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.02.06.51.44;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.06.13.22.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.06.13.05.52;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.05.14.31.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.32.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.13.15.59.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.05.13.58.50;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.15
log
@RIP routed.

You were a nice thing in the 4.2BSD times but now it is time for you to go.
Superseded by the shiny privseped ripd that does not have the evil habit to
use kernel internals in userland.

OK everybody in the onsen 'cause it unbreaks the tree
@
text
@/*	$OpenBSD: input.c,v 1.14 2003/06/02 20:06:17 millert Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint)
static char sccsid[] = "@@(#)input.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: input.c,v 1.14 2003/06/02 20:06:17 millert Exp $";
#endif

#include "defs.h"

static void input(struct sockaddr_in *, struct interface*, struct rip *, int);
static void input_route(struct interface *, naddr,
			naddr, naddr, naddr, struct netinfo *);


/* process RIP input
 */
void
read_rip(int sock,
	 struct interface *ifp)
{
	struct sockaddr_in from;
	socklen_t fromlen;
	int cc;
	union pkt_buf inbuf;


	for (;;) {
		fromlen = sizeof(from);
		cc = recvfrom(sock, &inbuf, sizeof(inbuf), 0,
			      (struct sockaddr*)&from, &fromlen);
		if (cc <= 0) {
			if (cc < 0 && errno != EWOULDBLOCK)
				LOGERR("recvfrom(rip)");
			break;
		}
		if (fromlen != sizeof(struct sockaddr_in))
			logbad(1,"impossible recvfrom(rip) fromlen=%u",
			       fromlen);

		input(&from, ifp, &inbuf.rip, cc);
	}
}


/* Process a RIP packet
 */
static void
input(struct sockaddr_in *from,		/* received from this IP address */
      struct interface *sifp,		/* interface by which it arrived */
      struct rip *rip,
      int size)
{
#	define FROM_NADDR from->sin_addr.s_addr
	static naddr use_auth, bad_len, bad_mask;
	static naddr unk_router, bad_router, bad_nhop;

	struct interface *aifp;		/* interface if via 1 hop */
	struct rt_entry *rt;
	struct netinfo *n, *lim;
	struct netauth *nap;
	struct interface *ifp1;
	naddr gate, mask, v1_mask, dst, ddst_h;
	int i;

	aifp = iflookup(from->sin_addr.s_addr);
	if (sifp == 0)
		sifp = aifp;

	if (sifp != 0)
		sifp->int_state |= IS_ACTIVE;

	trace_rip("Recv", "from", from, sifp, rip, size);

	if (rip->rip_vers == 0) {
		if (from->sin_addr.s_addr != bad_router)
			msglog("RIP version 0, cmd %d, packet received"
			       " from %s",
			       rip->rip_cmd, naddr_ntoa(FROM_NADDR));
		bad_router = from->sin_addr.s_addr;
		return;
	} else if (rip->rip_vers > RIPv2) {
		rip->rip_vers = RIPv2;
	}
	if (size > MAXPACKETSIZE) {
		if (from->sin_addr.s_addr != bad_router)
			msglog("packet at least %d bytes too long received"
			       " from %s",
			       size-MAXPACKETSIZE, naddr_ntoa(FROM_NADDR));
		bad_router = from->sin_addr.s_addr;
		return;
	}

	n = rip->rip_nets;
	lim = (struct netinfo *)((char*)rip + size);

	/* Notice authentication.
	 * As required by section 4.2 in RFC 1723, discard authenticated
	 * RIPv2 messages, but only if configured for that silliness.
	 *
	 * RIPv2 authentication is lame, since snooping on the wire makes
	 * its simple passwords evident.  Also, why authenticate queries?
	 * Why should a RIPv2 implementation with authentication disabled
	 * not be able to listen to RIPv2 packets with authentication, while
	 * RIPv1 systems will listen?  Crazy!
	 */
	if (!auth_ok
	    && rip->rip_vers == RIPv2
	    && n < lim && n->n_family == RIP_AF_AUTH) {
		if (from->sin_addr.s_addr != use_auth)
			msglog("RIPv2 message with authentication"
			       " from %s discarded",
			       naddr_ntoa(FROM_NADDR));
		use_auth = from->sin_addr.s_addr;
		trace_pkt("discard authenticated RIPv2 message\n");
		return;
	}

	switch (rip->rip_cmd) {
	case RIPCMD_REQUEST:
		/* did the request come from a router?
		 */
		if (from->sin_port == htons(RIP_PORT)) {
			/* yes, ignore it if RIP is off so that it does not
			 * depend on us.
			 */
			if (rip_sock < 0) {
				trace_pkt("ignore request while RIP off\n");
				return;
			}

			/* Ignore the request if we talking to ourself
			 * (and not a remote gateway).
			 */
			if (ifwithaddr(FROM_NADDR, 0, 0) != 0) {
				trace_pkt("discard our own RIP request\n");
				return;
			}
		}

		/* According to RFC 1723, we should ignore unathenticated
		 * queries.  That is too silly to bother with.  Sheesh!
		 * Are forwarding tables supposed to be secret?  When
		 * a bad guy can infer them with test traffic?
		 * Maybe on firewalls you'd care, but not enough to
		 * give up the diagnostic facilities of remote probing.
		 */

		if (n >= lim
		    || size%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			if (from->sin_addr.s_addr != bad_len)
				msglog("request of bad length (%d) from %s",
				       size, naddr_ntoa(FROM_NADDR));
			bad_len = from->sin_addr.s_addr;
		}
		for (; n < lim; n++) {
			n->n_metric = ntohl(n->n_metric);

			/* A single entry with family RIP_AF_UNSPEC and
			 * metric HOPCNT_INFINITY means "all routes".
			 * We respond to routers only if we are acting
			 * as a supplier, or to anyone other than a router
			 * (i.e. a query).
			 */
			if (n->n_family == RIP_AF_UNSPEC
			    && n->n_metric == HOPCNT_INFINITY
			    && n == rip->rip_nets
			    && n+1 == lim) {
				if (from->sin_port != htons(RIP_PORT)) {
					/* Answer a query from a utility
					 * program with all we know.
					 */
					supply(from, sifp, OUT_QUERY, 0,
					       rip->rip_vers);
					return;
				}
				/* A router trying to prime its tables.
				 * Filter the answer in the about same way
				 * broadcasts are filtered.
				 *
				 * Only answer a router if we are a supplier
				 * to keep an unwary host that is just starting
				 * from picking us as a router.  Respond with
				 * RIPv1 instead of RIPv2 if that is what we
				 * are broadcasting on the interface to keep
				 * the remote router from getting the wrong
				 * initial idea of the routes we send.
				 */
				if (!supplier
				    || aifp == 0
				    || (aifp->int_state & IS_PASSIVE)
				    || (aifp->int_state & IS_ALIAS)
				    || ((aifp->int_state & IS_NO_RIPV1_OUT)
					&& (aifp->int_state&IS_NO_RIPV2_OUT)))
					return;

				supply(from, aifp, OUT_UNICAST, 0,
				       (aifp->int_state&IS_NO_RIPV1_OUT)
				       ? RIPv2 : RIPv1);
				return;
			}

			if (n->n_family != RIP_AF_INET) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("request from %s"
					       " for unsupported (af %d) %s",
					       naddr_ntoa(FROM_NADDR),
					       ntohs(n->n_family),
					       naddr_ntoa(n->n_dst));
				bad_router = from->sin_addr.s_addr;
				return;
			}

			dst = n->n_dst;
			if (!check_dst(dst)) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad queried destination"
					       " %s from %s",
					       naddr_ntoa(dst),
					       naddr_ntoa(FROM_NADDR));
				bad_router = from->sin_addr.s_addr;
				return;
			}

			if (rip->rip_vers == RIPv1
			    || 0 == (mask = ntohl(n->n_mask))
			    || 0 != (ntohl(dst) & ~mask))
				mask = ripv1_mask_host(dst,sifp);

			rt = rtget(dst, mask);
			if (!rt && dst != RIP_DEFAULT)
				rt = rtfind(n->n_dst);

			n->n_tag = 0;
			n->n_nhop = 0;
			if (rip->rip_vers == RIPv1) {
				n->n_mask = 0;
			} else {
				n->n_mask = mask;
			}
			if (rt == 0) {
				n->n_metric = HOPCNT_INFINITY;
			} else {
				n->n_metric = rt->rt_metric+1;
				n->n_metric += (sifp!=0)?sifp->int_metric : 1;
				if (n->n_metric > HOPCNT_INFINITY)
					n->n_metric = HOPCNT_INFINITY;
				if (rip->rip_vers != RIPv1) {
					n->n_tag = rt->rt_tag;
					if (sifp != 0
					    && on_net(rt->rt_gate,
						      sifp->int_net,
						      sifp->int_mask)
					    && rt->rt_gate != sifp->int_addr)
						n->n_nhop = rt->rt_gate;
				}
			}
			HTONL(n->n_metric);
		}
		/* Answer about specific routes.
		 * Only answer a router if we are a supplier
		 * to keep an unwary host that is just starting
		 * from picking us an a router.
		 */
		rip->rip_cmd = RIPCMD_RESPONSE;
		rip->rip_res1 = 0;
		if (rip->rip_vers != RIPv1)
			rip->rip_vers = RIPv2;
		if (from->sin_port != htons(RIP_PORT)) {
			/* query */
			(void)output(OUT_QUERY, from, sifp, rip, size);
		} else if (supplier) {
			(void)output(OUT_UNICAST, from, sifp, rip, size);
		}
		return;

	case RIPCMD_TRACEON:
	case RIPCMD_TRACEOFF:
		/* verify message came from a privileged port */
		if (ntohs(from->sin_port) > IPPORT_RESERVED) {
			msglog("trace command from untrusted port on %s",
			       naddr_ntoa(FROM_NADDR));
			return;
		}
		if (aifp == 0) {
			msglog("trace command from unknown router %s",
			       naddr_ntoa(FROM_NADDR));
			return;
		}
#if PERMIT_TRACE
		if (rip->rip_cmd == RIPCMD_TRACEON) {
			rip->rip_tracefile[size-4] = '\0';
			trace_on((char*)rip->rip_tracefile, 0);
		} else {
			trace_off("tracing turned off by %s\n",
				  naddr_ntoa(FROM_NADDR));
		}
#else
		msglog("trace command from %s ignored: %s\n",
		    naddr_ntoa(FROM_NADDR), rip->rip_tracefile);
#endif
		return;

	case RIPCMD_RESPONSE:
		if (size%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			if (from->sin_addr.s_addr != bad_len)
				msglog("response of bad length (%d) from %s",
				       size, naddr_ntoa(FROM_NADDR));
			bad_len = from->sin_addr.s_addr;
		}

		/* verify message came from a router */
		if (from->sin_port != ntohs(RIP_PORT)) {
			trace_pkt("discard RIP response from unknown port\n");
			return;
		}

		if (rip_sock < 0) {
			trace_pkt("discard response while RIP off\n");
			return;
		}

		/* Are we talking to ourself or a remote gateway?
		 */
		ifp1 = ifwithaddr(FROM_NADDR, 0, 1);
		if (ifp1) {
			if (ifp1->int_state & IS_REMOTE) {
				if (ifp1->int_state & IS_PASSIVE) {
					msglog("bogus input from %s on"
					       " supposedly passive %s",
					       naddr_ntoa(FROM_NADDR),
					       ifp1->int_name);
				} else {
					ifp1->int_act_time = now.tv_sec;
					if (if_ok(ifp1, "remote "))
						addrouteforif(ifp1);
				}
			} else {
				trace_pkt("discard our own RIP response\n");
			}
			return;
		}

		/* Check the router from which message originated. We accept
		 * routing packets from routers directly connected via
		 * broadcast or point-to-point networks, and from
		 * those listed in /etc/gateways.
		 */
		if (!aifp) {
			if (from->sin_addr.s_addr != unk_router)
				msglog("discard packet from unknown router %s"
				       " or via unidentified interface",
				       naddr_ntoa(FROM_NADDR));
			unk_router = from->sin_addr.s_addr;
			return;
		}
		if (aifp->int_state & IS_PASSIVE) {
			trace_act("discard packet from %s"
				  " via passive interface %s\n",
				  naddr_ntoa(FROM_NADDR),
				  aifp->int_name);
			return;
		}

		/* Check required version
		 */
		if (((aifp->int_state & IS_NO_RIPV1_IN)
		     && rip->rip_vers == RIPv1)
		    || ((aifp->int_state & IS_NO_RIPV2_IN)
			&& rip->rip_vers != RIPv1)) {
			trace_pkt("discard RIPv%d response\n",
				  rip->rip_vers);
			return;
		}

		/* Ignore routes via dead interface.
		 */
		if (aifp->int_state & IS_BROKE) {
			trace_pkt("discard response via broken interface %s\n",
				  aifp->int_name);
			return;
		}

		/* Authenticate the packet if we have a secret.
		 */
		if (aifp->int_passwd[0] != '\0') {
			nap = (struct netauth *)(&n->n_tag);
			if (n >= lim
			    || n->n_family != RIP_AF_AUTH
			    || nap->a_type != RIP_AUTH_PW) {
				if (from->sin_addr.s_addr != use_auth)
					msglog("missing password from %s",
					       naddr_ntoa(FROM_NADDR));
				use_auth = from->sin_addr.s_addr;
				return;
			} else if (0 != bcmp(nap->au.au_pw, aifp->int_passwd,
					     sizeof(aifp->int_passwd))) {
				if (from->sin_addr.s_addr != use_auth)
					msglog("bad password from %s",
					       naddr_ntoa(FROM_NADDR));
				use_auth = from->sin_addr.s_addr;
				return;
			}
		}

		for (; n < lim; n++) {
			if (n->n_family == RIP_AF_AUTH)
				continue;

			NTOHL(n->n_metric);
			dst = n->n_dst;
			if (n->n_family != RIP_AF_INET
			    && (n->n_family != RIP_AF_UNSPEC
				|| dst != RIP_DEFAULT)) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("route from %s to unsupported"
					       " address family %d,"
					       " destination %s",
					       naddr_ntoa(FROM_NADDR),
					       n->n_family,
					       naddr_ntoa(dst));
				bad_router = from->sin_addr.s_addr;
				continue;
			}
			if (!check_dst(dst)) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad destination %s from %s",
					       naddr_ntoa(dst),
					       naddr_ntoa(FROM_NADDR));
				bad_router = from->sin_addr.s_addr;
				return;
			}
			if (n->n_metric == 0
			    || n->n_metric > HOPCNT_INFINITY) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad metric %d from %s"
					       " for destination %s",
					       n->n_metric,
					       naddr_ntoa(FROM_NADDR),
					       naddr_ntoa(dst));
				bad_router = from->sin_addr.s_addr;
				return;
			}

			/* Notice the next-hop.
			 */
			gate = from->sin_addr.s_addr;
			if (n->n_nhop != 0) {
				if (rip->rip_vers == RIPv2) {
					n->n_nhop = 0;
				} else {
				    /* Use it only if it is valid. */
				    if (on_net(n->n_nhop,
					       aifp->int_net, aifp->int_mask)
					&& check_dst(n->n_nhop)) {
					    gate = n->n_nhop;
				    } else {
					if (bad_nhop != from->sin_addr.s_addr)
						msglog("router %s to %s has"
						       " bad next hop %s",
						       naddr_ntoa(FROM_NADDR),
						       naddr_ntoa(dst),
						       naddr_ntoa(n->n_nhop));
					bad_nhop = from->sin_addr.s_addr;
					n->n_nhop = 0;
				    }
				}
			}

			if (rip->rip_vers == RIPv1
			    || 0 == (mask = ntohl(n->n_mask))) {
				mask = ripv1_mask_host(dst,aifp);
			} else if ((ntohl(dst) & ~mask) != 0) {
				if (bad_mask != from->sin_addr.s_addr) {
					msglog("router %s sent bad netmask"
					       " %#x with %s",
					       naddr_ntoa(FROM_NADDR),
					       mask,
					       naddr_ntoa(dst));
					bad_mask = from->sin_addr.s_addr;
				}
				continue;
			}
			if (rip->rip_vers == RIPv1)
				n->n_tag = 0;

			/* Adjust metric according to incoming interface..
			 */
			n->n_metric += aifp->int_metric;
			if (n->n_metric > HOPCNT_INFINITY)
				n->n_metric = HOPCNT_INFINITY;

			/* Recognize and ignore a default route we faked
			 * which is being sent back to us by a machine with
			 * broken split-horizon.
			 * Be a little more paranoid than that, and reject
			 * default routes with the same metric we advertised.
			 */
			if (aifp->int_d_metric != 0
			    && dst == RIP_DEFAULT
			    && n->n_metric >= aifp->int_d_metric)
				continue;

			/* We can receive aggregated RIPv2 routes that must
			 * be broken down before they are transmitted by
			 * RIPv1 via an interface on a subnet.
			 * We might also receive the same routes aggregated
			 * via other RIPv2 interfaces.
			 * This could cause duplicate routes to be sent on
			 * the RIPv1 interfaces.  "Longest matching variable
			 * length netmasks" lets RIPv2 listeners understand,
			 * but breaking down the aggregated routes for RIPv1
			 * listeners can produce duplicate routes.
			 *
			 * Breaking down aggregated routes here bloats
			 * the daemon table, but does not hurt the kernel
			 * table, since routes are always aggregated for
			 * the kernel.
			 *
			 * Notice that this does not break down network
			 * routes corresponding to subnets.  This is part
			 * of the defense against RS_NET_SYN.
			 */
			if (have_ripv1_out
			    && (v1_mask = ripv1_mask_net(dst,0)) > mask
			    && (((rt = rtget(dst,mask)) == 0
				 || !(rt->rt_state & RS_NET_SYN)))) {
				ddst_h = v1_mask & -v1_mask;
				i = (v1_mask & ~mask)/ddst_h;
				if (i >= 511) {
					/* Punt if we would have to generate
					 * an unreasonable number of routes.
					 */
#ifdef DEBUG
					msglog("accept %s from %s as 1"
					       " instead of %d routes",
					       addrname(dst,mask,0),
					       naddr_ntoa(FROM_NADDR),
					       i+1);
#endif
					i = 0;
				} else {
					mask = v1_mask;
				}
			} else {
				i = 0;
			}

			for (;;) {
				input_route(aifp, FROM_NADDR,
					    dst, mask, gate, n);
				if (i-- == 0)
					break;
				dst = htonl(ntohl(dst) + ddst_h);
			}
		}
		break;
	}
}


/* Process a single input route.
 */
static void
input_route(struct interface *ifp,
	    naddr from,
	    naddr dst,
	    naddr mask,
	    naddr gate,
	    struct netinfo *n)
{
	int i;
	struct rt_entry *rt;
	struct rt_spare *rts, *rts0;
	struct interface *ifp1;
	time_t new_time;


	/* See if the other guy is telling us to send our packets to him.
	 * Sometimes network routes arrive over a point-to-point link for
	 * the network containing the address(es) of the link.
	 *
	 * If our interface is broken, switch to using the other guy.
	 */
	ifp1 = ifwithaddr(dst, 1, 1);
	if (ifp1 != 0
	    && !(ifp1->int_state & IS_BROKE))
		return;

	/* Look for the route in our table.
	 */
	rt = rtget(dst, mask);

	/* Consider adding the route if we do not already have it.
	 */
	if (rt == 0) {
		/* Ignore unknown routes being poisoned.
		 */
		if (n->n_metric == HOPCNT_INFINITY)
			return;

		/* Ignore the route if it points to us */
		if (n->n_nhop != 0
		    && 0 != ifwithaddr(n->n_nhop, 1, 0))
			return;

		/* If something has not gone crazy and tried to fill
		 * our memory, accept the new route.
		 */
		if (total_routes < MAX_ROUTES)
			rtadd(dst, mask, gate, from, n->n_metric,
			      n->n_tag, 0, ifp);
		return;
	}

	/* We already know about the route.  Consider this update.
	 *
	 * If (rt->rt_state & RS_NET_SYN), then this route
	 * is the same as a network route we have inferred
	 * for subnets we know, in order to tell RIPv1 routers
	 * about the subnets.
	 *
	 * It is impossible to tell if the route is coming
	 * from a distant RIPv2 router with the standard
	 * netmask because that router knows about the entire
	 * network, or if it is a round-about echo of a
	 * synthetic, RIPv1 network route of our own.
	 * The worst is that both kinds of routes might be
	 * received, and the bad one might have the smaller
	 * metric.  Partly solve this problem by never
	 * aggregating into such a route.  Also keep it
	 * around as long as the interface exists.
	 */

	rts0 = rt->rt_spares;
	for (rts = rts0, i = NUM_SPARES; i != 0; i--, rts++) {
		if (rts->rts_router == from)
			break;
		/* Note the worst slot to reuse,
		 * other than the current slot.
		 */
		if (rts0 == rt->rt_spares
		    || BETTER_LINK(rt, rts0, rts))
			rts0 = rts;
	}
	if (i != 0) {
		/* Found the router
		 */
		int old_metric = rts->rts_metric;

		/* Keep poisoned routes around only long enough to pass
		 * the poison on.  Get a new timestamp for good routes.
		 */
		new_time =((old_metric == HOPCNT_INFINITY)
			   ? rts->rts_time
			   : now.tv_sec);

		/* If this is an update for the router we currently prefer,
		 * then note it.
		 */
		if (i == NUM_SPARES) {
			rtchange(rt,rt->rt_state, gate,rt->rt_router,
				 n->n_metric, n->n_tag, ifp, new_time, 0);
			/* If the route got worse, check for something better.
			 */
			if (n->n_metric > old_metric)
				rtswitch(rt, 0);
			return;
		}

		/* This is an update for a spare route.
		 * Finished if the route is unchanged.
		 */
		if (rts->rts_gate == gate
		    && old_metric == n->n_metric
		    && rts->rts_tag == n->n_tag) {
			rts->rts_time = new_time;
			return;
		}

	} else {
		/* The update is for a route we know about,
		 * but not from a familiar router.
		 *
		 * Ignore the route if it points to us.
		 */
		if (n->n_nhop != 0
		    && 0 != ifwithaddr(n->n_nhop, 1, 0))
			return;

		rts = rts0;

		/* Save the route as a spare only if it has
		 * a better metric than our worst spare.
		 * This also ignores poisoned routes (those
		 * received with metric HOPCNT_INFINITY).
		 */
		if (n->n_metric >= rts->rts_metric)
			return;

		new_time = now.tv_sec;
	}

	trace_upslot(rt, rts, gate, from, ifp, n->n_metric,n->n_tag, new_time);

	rts->rts_gate = gate;
	rts->rts_router = from;
	rts->rts_metric = n->n_metric;
	rts->rts_tag = n->n_tag;
	rts->rts_time = new_time;
	rts->rts_ifp = ifp;

	/* try to switch to a better route */
	rtswitch(rt, rts);
}
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.13 2002/09/06 21:12:52 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: input.c,v 1.13 2002/09/06 21:12:52 deraadt Exp $";
@


1.13
log
@socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.12 2002/09/06 18:15:55 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
static char rcsid[] = "$OpenBSD: input.c,v 1.12 2002/09/06 18:15:55 deraadt Exp $";
@


1.12
log
@missing arg in a msglog(); silvio@@big.net.au
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.11 2001/02/26 19:45:17 todd Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.11 2001/02/26 19:45:17 todd Exp $";
d56 2
a57 1
	int fromlen, cc;
d71 1
a71 1
			logbad(1,"impossible recvfrom(rip) fromlen=%d",
@


1.11
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.10 2001/01/05 05:23:46 angelos Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.10 2001/01/05 05:23:46 angelos Exp $";
d332 1
a332 1
		    rip->rip_tracefile);
@


1.10
log
@Fix sending/receiving passwords (james@@oaktree.co.uk)
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.9 1997/07/30 23:28:41 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.9 1997/07/30 23:28:41 deraadt Exp $";
d136 1
a136 1
	 * not be able to listen to RIPv2 packets with authenication, while
@


1.9
log
@new routed DOES NOT EVEN COMPILE LET ALONE WORK.  TEST YOUR WORK!
Also, put back the damn security check in input.c that has been deleted
TWO SEPERATE TIMES NOW!  I CURSE anyone who deletes that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.5 1996/09/06 13:05:52 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.7 1996/10/02 06:51:44 mickey Exp $";
d93 1
d419 1
d422 1
a422 1
			    || ((struct netauth*)n)->a_type != RIP_AUTH_PW) {
d428 1
a428 3

			} else if (0 != bcmp(((struct netauth*)n)->au.au_pw,
					     aifp->int_passwd,
@


1.8
log
@update to sgi-02apr97
still have problems w/ defaults from pppd
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.7 1996/10/02 06:51:44 mickey Exp $	*/
a42 1
#include <md5.h>
d44 1
a44 2
static void input(struct sockaddr_in *, struct interface *, struct interface *,
		  struct rip *, int);
a46 2
static int ck_passwd(struct interface *, struct rip *, void *,
		     naddr, struct msg_limit *);
d53 1
a53 1
	 struct interface *sifp)
d56 2
a57 13
	struct interface *aifp;
  	int fromlen, cc;
#ifdef USE_PASSIFNAME
	static struct msg_limit  bad_name;
	struct {
		char	ifname[IFNAMSIZ];
		union pkt_buf pbuf;
	} inbuf;
#else
	struct {
		union pkt_buf pbuf;
	} inbuf;
#endif
d73 1
a73 42
		/* aifp is the "authenticated" interface via which the packet
		 *	arrived.  In fact, it is only the interface on which
		 *	the packet should have arrived based on is source
		 *	address.
		 * sifp is interface associated with the socket through which
		 *	the packet was received.
		 */
#ifdef USE_PASSIFNAME
		if ((cc -= sizeof(inbuf.ifname)) < 0)
			logbad(0,"missing USE_PASSIFNAME; only %d bytes",
			       cc+sizeof(inbuf.ifname));

		/* check the remote interfaces first */
		for (aifp = remote_if; aifp; aifp = aifp->int_rlink) {
			if (aifp->int_addr == from.sin_addr.s_addr)
				break;
		}
		if (aifp == 0) {
			aifp = ifwithname(inbuf.ifname, 0);
			if (aifp == 0) {
				msglim(&bad_name, from.sin_addr.s_addr,
				       "impossible interface name %.*s",
				       IFNAMSIZ, inbuf.ifname);
			} else if (((aifp->int_if_flags & IFF_POINTOPOINT)
				    && aifp->int_dstaddr!=from.sin_addr.s_addr)
				   || (!(aifp->int_if_flags & IFF_POINTOPOINT)
				       && !on_net(from.sin_addr.s_addr,
						  aifp->int_net,
						  aifp->int_mask))) {
				/* If it came via the wrong interface, do not
				 * trust it.
				 */
				aifp = 0;
			}
		}
#else
		aifp = iflookup(from.sin_addr.s_addr);
#endif
		if (sifp == 0)
			sifp = aifp;

		input(&from, sifp, aifp, &inbuf.pbuf.rip, cc);
d82 1
a82 2
      struct interface *sifp,		/* interface of incoming socket */
      struct interface *aifp,		/* "authenticated" interface */
d84 1
a84 1
      int cc)
d87 2
a88 2
	static struct msg_limit use_auth, bad_len, bad_mask;
	static struct msg_limit  unk_router, bad_router, bad_nhop;
d90 1
a94 1
	struct auth *ap;
d97 6
a102 5
	/* Notice when we hear from a remote gateway
	 */
	if (aifp != 0
	    && (aifp->int_state & IS_REMOTE))
		aifp->int_act_time = now.tv_sec;
d104 1
a104 1
	trace_rip("Recv", "from", from, sifp, rip, cc);
d107 5
a111 3
		msglim(&bad_router, FROM_NADDR,
		       "RIP version 0, cmd %d, packet received from %s",
		       rip->rip_cmd, naddr_ntoa(FROM_NADDR));
d116 6
a121 4
	if (cc > OVER_MAXPACKETSIZE) {
		msglim(&bad_router, FROM_NADDR,
		       "packet at least %d bytes too long received from %s",
		       cc-MAXPACKETSIZE, naddr_ntoa(FROM_NADDR));
d126 1
a126 1
	lim = (struct netinfo *)((char*)rip + cc);
d132 2
a133 1
	 * RIPv2 authentication is lame.  Why authenticate queries?
d141 6
a146 3
		msglim(&use_auth, FROM_NADDR,
		       "RIPv2 message with authentication from %s discarded",
		       naddr_ntoa(FROM_NADDR));
d152 1
a152 1
		/* For mere requests, be a little sloppy about the source
d154 6
a159 16
		if (aifp == 0)
			aifp = sifp;

		/* Are we talking to ourself or a remote gateway?
		 */
		ifp1 = ifwithaddr(FROM_NADDR, 0, 1);
		if (ifp1) {
			if (ifp1->int_state & IS_REMOTE) {
				/* remote gateway */
				aifp = ifp1;
				if (check_remote(aifp)) {
					aifp->int_act_time = now.tv_sec;
					(void)if_ok(aifp, "remote ");
				}
			} else if (from->sin_port == htons(RIP_PORT)) {
				trace_pkt("    discard our own RIP request");
a161 1
		}
d163 2
a164 5
		/* did the request come from a router?
		 */
		if (from->sin_port == htons(RIP_PORT)) {
			/* yes, ignore the request if RIP is off so that
			 * the router does not depend on us.
d166 2
a167 4
			if (rip_sock < 0
			    || (aifp != 0
				&& IS_RIP_OUT_OFF(aifp->int_state))) {
				trace_pkt("    discard request while RIP off");
d174 2
a175 5
		 * Are forwarding tables supposed to be secret, when
		 * a bad guy can infer them with test traffic?  When RIP
		 * is still the most common router-discovery protocol
		 * and so hosts need to send queries that will be answered?
		 * What about `rtquery`?
d180 6
a185 26
		if (n >= lim) {
			msglim(&bad_len, FROM_NADDR, "empty request from %s",
			       naddr_ntoa(FROM_NADDR));
			return;
		}
		if (cc%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			msglim(&bad_len, FROM_NADDR,
			       "request of bad length (%d) from %s",
			       cc, naddr_ntoa(FROM_NADDR));
		}

		if (rip->rip_vers == RIPv2
		    && (aifp == 0 || (aifp->int_state & IS_NO_RIPV1_OUT))) {
			v12buf.buf->rip_vers = RIPv2;
			/* If we have a secret but it is a cleartext secret,
			 * do not disclose our secret unless the other guy
			 * already knows it.
			 */
			ap = find_auth(aifp);
			if (ap != 0 && ap->type == RIP_AUTH_PW
			    && n->n_family == RIP_AF_AUTH
			    && !ck_passwd(aifp,rip,lim,FROM_NADDR,&use_auth))
				ap = 0;
		} else {
			v12buf.buf->rip_vers = RIPv1;
			ap = 0;
d187 2
a188 4
		clr_ws_buf(&v12buf, ap);

		do {
			NTOHL(n->n_metric);
d197 3
a199 1
			    && n->n_metric == HOPCNT_INFINITY) {
d204 2
a205 2
					supply(from, aifp, OUT_QUERY, 0,
					       rip->rip_vers, ap != 0);
a207 1

a219 4
				if (aifp == 0) {
					trace_pkt("ignore distant router");
					return;
				}
d221 5
a225 2
				    || IS_RIP_OFF(aifp->int_state)) {
					trace_pkt("ignore; not supplying");
a226 1
				}
d230 1
a230 2
				       ? RIPv2 : RIPv1,
				       ap != 0);
a233 4
			/* Ignore authentication */
			if (n->n_family == RIP_AF_AUTH)
				continue;

d235 7
a241 6
				msglim(&bad_router, FROM_NADDR,
				       "request from %s for unsupported (af"
				       " %d) %s",
				       naddr_ntoa(FROM_NADDR),
				       ntohs(n->n_family),
				       naddr_ntoa(n->n_dst));
a244 2
			/* We are being asked about a specific destination.
			 */
d247 6
a252 4
				msglim(&bad_router, FROM_NADDR,
				       "bad queried destination %s from %s",
				       naddr_ntoa(dst),
				       naddr_ntoa(FROM_NADDR));
a255 1
			/* decide what mask was intended */
d259 1
a259 1
				mask = ripv1_mask_host(dst, aifp);
a260 1
			/* try to find the answer */
d265 7
a271 2
			if (v12buf.buf->rip_vers != RIPv1)
				v12buf.n->n_mask = mask;
d273 1
a273 2
				/* we do not have the answer */
				v12buf.n->n_metric = HOPCNT_INFINITY;
d275 7
a281 15
				/* we have the answer, so compute the
				 * right metric and next hop.
				 */
				v12buf.n->n_family = RIP_AF_INET;
				v12buf.n->n_dst = dst;
				v12buf.n->n_metric = (rt->rt_metric+1
						      + ((aifp!=0)
							  ? aifp->int_metric
							  : 1));
				if (v12buf.n->n_metric > HOPCNT_INFINITY)
					v12buf.n->n_metric = HOPCNT_INFINITY;
				if (v12buf.buf->rip_vers != RIPv1) {
					v12buf.n->n_tag = rt->rt_tag;
					v12buf.n->n_mask = mask;
					if (aifp != 0
d283 4
a286 4
						      aifp->int_net,
						      aifp->int_mask)
					    && rt->rt_gate != aifp->int_addr)
					    v12buf.n->n_nhop = rt->rt_gate;
d289 11
a299 13
			HTONL(v12buf.n->n_metric);

			/* Stop paying attention if we fill the output buffer.
			 */
			if (++v12buf.n >= v12buf.lim)
				break;
		} while (++n < lim);

		/* Send the answer about specific routes.
		 */
		if (ap != 0 && ap->type == RIP_AUTH_MD5)
			end_md5_auth(&v12buf, ap);

d302 1
a302 3
			(void)output(OUT_QUERY, from, aifp,
				     v12buf.buf,
				     ((char *)v12buf.n - (char*)v12buf.buf));
d304 1
a304 9
			(void)output(OUT_UNICAST, from, aifp,
				     v12buf.buf,
				     ((char *)v12buf.n - (char*)v12buf.buf));
		} else {
			/* Only answer a router if we are a supplier
			 * to keep an unwary host that is just starting
			 * from picking us an a router.
			 */
			;
d321 1
d323 2
a324 3
			rip->rip_tracefile[cc-4] = '\0';
			set_tracefile((char*)rip->rip_tracefile,
				      "trace command: %s\n", 0);
d326 1
a326 1
			trace_off("tracing turned off by %s",
d329 4
d336 5
a340 4
		if (cc%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			msglim(&bad_len, FROM_NADDR,
			       "response of bad length (%d) from %s",
			       cc, naddr_ntoa(FROM_NADDR));
d345 1
a345 3
			msglim(&bad_router, FROM_NADDR,
			       "    discard RIP response from unknown port"
			       " %d", from->sin_port);
d350 1
a350 1
			trace_pkt("    discard response while RIP off");
d359 9
a367 5
				/* remote gateway */
				aifp = ifp1;
				if (check_remote(aifp)) {
					aifp->int_act_time = now.tv_sec;
					(void)if_ok(aifp, "remote ");
d370 1
a370 2
				trace_pkt("    discard our own RIP response");
				return;
d372 1
d375 3
a377 2
		/* Accept routing packets from routers directly connected
		 * via broadcast or point-to-point networks, and from
d380 6
a385 5
		if (aifp == 0) {
			msglim(&unk_router, FROM_NADDR,
			       "   discard response from %s"
			       " via unexpected interface",
			       naddr_ntoa(FROM_NADDR));
d388 5
a392 10
		if (IS_RIP_IN_OFF(aifp->int_state)) {
			trace_pkt("    discard RIPv%d response"
				  " via disabled interface %s",
				  rip->rip_vers, aifp->int_name);
			return;
		}

		if (n >= lim) {
			msglim(&bad_len, FROM_NADDR, "empty response from %s",
			       naddr_ntoa(FROM_NADDR));
d396 2
d402 1
a402 1
			trace_pkt("    discard RIPv%d response",
d410 1
a410 1
			trace_pkt("%sdiscard response via broken interface %s",
d415 20
a434 14
		/* If the interface cares, ignore bad routers.
		 * Trace but do not log this problem, because where it
		 * happens, it happens frequently.
		 */
		if (aifp->int_state & IS_DISTRUST) {
			struct tgate *tg = tgates;
			while (tg->tgate_addr != FROM_NADDR) {
				tg = tg->tgate_next;
				if (tg == 0) {
					trace_pkt("    discard RIP response"
						  " from untrusted router %s",
						  naddr_ntoa(FROM_NADDR));
					return;
				}
d438 1
a438 10
		/* Authenticate the packet if we have a secret.
		 * If we do not have any secrets, ignore the error in
		 * RFC 1723 and accept it regardless.
		 */
		if (aifp->int_auth[0].type != RIP_AUTH_NONE
		    && rip->rip_vers != RIPv1
		    && !ck_passwd(aifp,rip,lim,FROM_NADDR,&use_auth))
			return;

		do {
d447 8
a454 6
				msglim(&bad_router, FROM_NADDR,
				       "route from %s to unsupported"
				       " address family=%d destination=%s",
				       naddr_ntoa(FROM_NADDR),
				       n->n_family,
				       naddr_ntoa(dst));
d458 5
a462 4
				msglim(&bad_router, FROM_NADDR,
				       "bad destination %s from %s",
				       naddr_ntoa(dst),
				       naddr_ntoa(FROM_NADDR));
d467 7
a473 6
				msglim(&bad_router, FROM_NADDR,
				       "bad metric %d from %s"
				       " for destination %s",
				       n->n_metric,
				       naddr_ntoa(FROM_NADDR),
				       naddr_ntoa(dst));
d479 1
a479 1
			gate = FROM_NADDR;
d490 8
a497 7
					    msglim(&bad_nhop, FROM_NADDR,
						   "router %s to %s"
						   " has bad next hop %s",
						   naddr_ntoa(FROM_NADDR),
						   naddr_ntoa(dst),
						   naddr_ntoa(n->n_nhop));
					    n->n_nhop = 0;
d506 8
a513 6
				msglim(&bad_mask, FROM_NADDR,
				       "router %s sent bad netmask"
				       " %#x with %s",
				       naddr_ntoa(FROM_NADDR),
				       mask,
				       naddr_ntoa(dst));
d557 1
d559 1
a559 2
				 || !(rt->rt_state & RS_NET_SYN)))
			    && (v1_mask = ripv1_mask_net(dst,0)) > mask) {
d588 1
a588 1
		} while (++n < lim);
a590 1
#undef FROM_NADDR
d619 1
a619 2
	    && (!(ifp1->int_state & IS_BROKE)
		|| (ifp1->int_state & IS_PASSIVE)))
a704 1
		 * Forget it if it has gone bad.
a710 3
		} else if (n->n_metric == HOPCNT_INFINITY) {
			rts_delete(rt, rts);
			return;
d737 1
a746 71
}


static int				/* 0 if bad */
ck_passwd(struct interface *aifp,
	  struct rip *rip,
	  void *lim,
	  naddr from,
	  struct msg_limit *use_authp)
{
#	define NA (rip->rip_auths)
	struct netauth *na2;
	struct auth *ap;
	MD5_CTX md5_ctx;
	u_char hash[RIP_AUTH_PW_LEN];
	int i;


	if ((void *)NA >= lim || NA->a_family != RIP_AF_AUTH) {
		msglim(use_authp, from, "missing password from %s",
		       naddr_ntoa(from));
		return 0;
	}

	/* accept any current (+/- 24 hours) password
	 */
	for (ap = aifp->int_auth, i = 0; i < MAX_AUTH_KEYS; i++, ap++) {
		if (ap->type != NA->a_type
		    || (u_long)ap->start > (u_long)clk.tv_sec+DAY
		    || (u_long)ap->end+DAY < (u_long)clk.tv_sec)
			continue;

		if (NA->a_type == RIP_AUTH_PW) {
			if (!bcmp(NA->au.au_pw, ap->key, RIP_AUTH_PW_LEN))
				return 1;

		} else {
			/* accept MD5 secret with the right key ID
			 */
			if (NA->au.a_md5.md5_keyid != ap->keyid)
				continue;

			na2 = (struct netauth *)((char *)(NA+1)
						 + NA->au.a_md5.md5_pkt_len);
			if (NA->au.a_md5.md5_pkt_len % sizeof(*NA) != 0
			    || lim < (void *)(na2+1)) {
				msglim(use_authp, from,
				       "bad MD5 RIP-II pkt length %d from %s",
				       NA->au.a_md5.md5_pkt_len,
				       naddr_ntoa(from));
				return 0;
			}
			MD5Init(&md5_ctx);
			MD5Update(&md5_ctx, (u_char *)NA,
				  (char *)na2->au.au_pw - (char *)NA);
			MD5Update(&md5_ctx,
				  (u_char *)ap->key, sizeof(ap->key));
			MD5Final(hash, &md5_ctx);
			if (na2->a_family != RIP_AF_AUTH
			    || na2->a_type != 1
			    || NA->au.a_md5.md5_auth_len != RIP_AUTH_PW_LEN
			    || bcmp(hash, na2->au.au_pw, sizeof(hash)))
				return 0;
			return 1;
		}
	}

	msglim(use_authp, from, "bad password from %s",
	       naddr_ntoa(from));
	return 0;
#undef NA
@


1.7
log
@update to the latest version from Sep 12.
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.6 1996/09/06 13:22:07 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.6 1996/09/06 13:22:07 deraadt Exp $";
d43 1
d45 2
a46 1
static void input(struct sockaddr_in *, struct interface*, struct rip *, int);
d49 2
d57 1
a57 1
	 struct interface *ifp)
d60 13
a72 2
	int fromlen, cc;
	union pkt_buf inbuf;
d88 42
a129 1
		input(&from, ifp, &inbuf.rip, cc);
d138 2
a139 1
      struct interface *sifp,		/* interface by which it arrived */
d141 1
a141 1
      int size)
d144 2
a145 2
	static naddr use_auth, bad_len, bad_mask;
	static naddr unk_router, bad_router, bad_nhop;
a146 1
	struct interface *aifp;		/* interface if via 1 hop */
d151 1
d154 5
a158 3
	aifp = iflookup(from->sin_addr.s_addr);
	if (sifp == 0)
		sifp = aifp;
d160 1
a160 4
	if (sifp != 0)
		sifp->int_state |= IS_ACTIVE;

	trace_rip("Recv", "from", from, sifp, rip, size);
d163 3
a165 5
		if (from->sin_addr.s_addr != bad_router)
			msglog("RIP version 0, cmd %d, packet received"
			       " from %s",
			       rip->rip_cmd, naddr_ntoa(FROM_NADDR));
		bad_router = from->sin_addr.s_addr;
d170 4
a173 6
	if (size > MAXPACKETSIZE) {
		if (from->sin_addr.s_addr != bad_router)
			msglog("packet at least %d bytes too long received"
			       " from %s",
			       size-MAXPACKETSIZE, naddr_ntoa(FROM_NADDR));
		bad_router = from->sin_addr.s_addr;
d178 1
a178 1
	lim = (struct netinfo *)((char*)rip + size);
d184 1
a184 2
	 * RIPv2 authentication is lame, since snooping on the wire makes
	 * its simple passwords evident.  Also, why authenticate queries?
d192 3
a194 6
		if (from->sin_addr.s_addr != use_auth)
			msglog("RIPv2 message with authentication"
			       " from %s discarded",
			       naddr_ntoa(FROM_NADDR));
		use_auth = from->sin_addr.s_addr;
		trace_pkt("discard authenticated RIPv2 message\n");
d200 6
a205 1
		/* did the request come from a router?
d207 11
a217 6
		if (from->sin_port == htons(RIP_PORT)) {
			/* yes, ignore it if RIP is off so that it does not
			 * depend on us.
			 */
			if (rip_sock < 0) {
				trace_pkt("ignore request while RIP off\n");
d220 1
d222 5
a226 2
			/* Ignore the request if we talking to ourself
			 * (and not a remote gateway).
d228 4
a231 2
			if (ifwithaddr(FROM_NADDR, 0, 0) != 0) {
				trace_pkt("discard our own RIP request\n");
d238 5
a242 2
		 * Are forwarding tables supposed to be secret?  When
		 * a bad guy can infer them with test traffic?
d247 9
a255 6
		if (n >= lim
		    || size%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			if (from->sin_addr.s_addr != bad_len)
				msglog("request of bad length (%d) from %s",
				       size, naddr_ntoa(FROM_NADDR));
			bad_len = from->sin_addr.s_addr;
d257 21
a277 2
		for (; n < lim; n++) {
			n->n_metric = ntohl(n->n_metric);
d286 1
a286 3
			    && n->n_metric == HOPCNT_INFINITY
			    && n == rip->rip_nets
			    && n+1 == lim) {
d291 2
a292 2
					supply(from, sifp, OUT_QUERY, 0,
					       rip->rip_vers);
d295 1
d308 4
d313 2
a314 5
				    || aifp == 0
				    || (aifp->int_state & IS_PASSIVE)
				    || (aifp->int_state & IS_ALIAS)
				    || ((aifp->int_state & IS_NO_RIPV1_OUT)
					&& (aifp->int_state&IS_NO_RIPV2_OUT)))
d316 1
d320 2
a321 1
				       ? RIPv2 : RIPv1);
d325 4
d330 6
a335 7
				if (from->sin_addr.s_addr != bad_router)
					msglog("request from %s"
					       " for unsupported (af %d) %s",
					       naddr_ntoa(FROM_NADDR),
					       ntohs(n->n_family),
					       naddr_ntoa(n->n_dst));
				bad_router = from->sin_addr.s_addr;
d339 2
d343 4
a346 6
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad queried destination"
					       " %s from %s",
					       naddr_ntoa(dst),
					       naddr_ntoa(FROM_NADDR));
				bad_router = from->sin_addr.s_addr;
d350 1
d354 1
a354 1
				mask = ripv1_mask_host(dst,sifp);
d356 1
d361 2
a362 7
			n->n_tag = 0;
			n->n_nhop = 0;
			if (rip->rip_vers == RIPv1) {
				n->n_mask = 0;
			} else {
				n->n_mask = mask;
			}
d364 2
a365 1
				n->n_metric = HOPCNT_INFINITY;
d367 15
a381 7
				n->n_metric = rt->rt_metric+1;
				n->n_metric += (sifp!=0)?sifp->int_metric : 1;
				if (n->n_metric > HOPCNT_INFINITY)
					n->n_metric = HOPCNT_INFINITY;
				if (rip->rip_vers != RIPv1) {
					n->n_tag = rt->rt_tag;
					if (sifp != 0
d383 4
a386 4
						      sifp->int_net,
						      sifp->int_mask)
					    && rt->rt_gate != sifp->int_addr)
						n->n_nhop = rt->rt_gate;
d389 13
a401 11
			HTONL(n->n_metric);
		}
		/* Answer about specific routes.
		 * Only answer a router if we are a supplier
		 * to keep an unwary host that is just starting
		 * from picking us an a router.
		 */
		rip->rip_cmd = RIPCMD_RESPONSE;
		rip->rip_res1 = 0;
		if (rip->rip_vers != RIPv1)
			rip->rip_vers = RIPv2;
d404 3
a406 1
			(void)output(OUT_QUERY, from, sifp, rip, size);
d408 9
a416 1
			(void)output(OUT_UNICAST, from, sifp, rip, size);
d434 3
a436 2
			rip->rip_tracefile[size-4] = '\0';
			trace_on((char*)rip->rip_tracefile, 0);
d438 1
a438 1
			trace_off("tracing turned off by %s\n",
d444 4
a447 5
		if (size%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			if (from->sin_addr.s_addr != bad_len)
				msglog("response of bad length (%d) from %s",
				       size, naddr_ntoa(FROM_NADDR));
			bad_len = from->sin_addr.s_addr;
d452 3
a454 1
			trace_pkt("discard RIP response from unknown port\n");
d459 1
a459 1
			trace_pkt("discard response while RIP off\n");
d468 5
a472 9
				if (ifp1->int_state & IS_PASSIVE) {
					msglog("bogus input from %s on"
					       " supposedly passive %s",
					       naddr_ntoa(FROM_NADDR),
					       ifp1->int_name);
				} else {
					ifp1->int_act_time = now.tv_sec;
					if (if_ok(ifp1, "remote "))
						addrouteforif(ifp1);
d475 2
a476 1
				trace_pkt("discard our own RIP response\n");
a477 1
			return;
d480 2
a481 3
		/* Check the router from which message originated. We accept
		 * routing packets from routers directly connected via
		 * broadcast or point-to-point networks, and from
d484 11
a494 6
		if (!aifp) {
			if (from->sin_addr.s_addr != unk_router)
				msglog("discard packet from unknown router %s"
				       " or via unidentified interface",
				       naddr_ntoa(FROM_NADDR));
			unk_router = from->sin_addr.s_addr;
d497 4
a500 5
		if (aifp->int_state & IS_PASSIVE) {
			trace_act("discard packet from %s"
				  " via passive interface %s\n",
				  naddr_ntoa(FROM_NADDR),
				  aifp->int_name);
a503 2
		/* Check required version
		 */
d508 1
a508 1
			trace_pkt("discard RIPv%d response\n",
d516 1
a516 1
			trace_pkt("discard response via broken interface %s\n",
d521 17
d539 2
d542 4
a545 20
		if (aifp->int_passwd[0] != '\0') {
			if (n >= lim
			    || n->n_family != RIP_AF_AUTH
			    || ((struct netauth*)n)->a_type != RIP_AUTH_PW) {
				if (from->sin_addr.s_addr != use_auth)
					msglog("missing password from %s",
					       naddr_ntoa(FROM_NADDR));
				use_auth = from->sin_addr.s_addr;
				return;

			} else if (0 != bcmp(((struct netauth*)n)->au.au_pw,
					     aifp->int_passwd,
					     sizeof(aifp->int_passwd))) {
				if (from->sin_addr.s_addr != use_auth)
					msglog("bad password from %s",
					       naddr_ntoa(FROM_NADDR));
				use_auth = from->sin_addr.s_addr;
				return;
			}
		}
d547 1
a547 1
		for (; n < lim; n++) {
d556 6
a561 8
				if (from->sin_addr.s_addr != bad_router)
					msglog("route from %s to unsupported"
					       " address family %d,"
					       " destination %s",
					       naddr_ntoa(FROM_NADDR),
					       n->n_family,
					       naddr_ntoa(dst));
				bad_router = from->sin_addr.s_addr;
d565 4
a568 5
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad destination %s from %s",
					       naddr_ntoa(dst),
					       naddr_ntoa(FROM_NADDR));
				bad_router = from->sin_addr.s_addr;
d573 6
a578 7
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad metric %d from %s"
					       " for destination %s",
					       n->n_metric,
					       naddr_ntoa(FROM_NADDR),
					       naddr_ntoa(dst));
				bad_router = from->sin_addr.s_addr;
d584 1
a584 1
			gate = from->sin_addr.s_addr;
d595 7
a601 8
					if (bad_nhop != from->sin_addr.s_addr)
						msglog("router %s to %s has"
						       " bad next hop %s",
						       naddr_ntoa(FROM_NADDR),
						       naddr_ntoa(dst),
						       naddr_ntoa(n->n_nhop));
					bad_nhop = from->sin_addr.s_addr;
					n->n_nhop = 0;
d610 6
a615 8
				if (bad_mask != from->sin_addr.s_addr) {
					msglog("router %s sent bad netmask"
					       " %#x with %s",
					       naddr_ntoa(FROM_NADDR),
					       mask,
					       naddr_ntoa(dst));
					bad_mask = from->sin_addr.s_addr;
				}
a658 1
			    && (v1_mask = ripv1_mask_net(dst,0)) > mask
d660 2
a661 1
				 || !(rt->rt_state & RS_NET_SYN)))) {
d690 1
a690 1
		}
d693 1
d722 2
a723 1
	    && !(ifp1->int_state & IS_BROKE))
d809 1
d816 3
a844 1

d854 71
@


1.6
log
@bitblt found a typo in a comment!
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.5 1996/09/06 13:05:52 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.5 1996/09/06 13:05:52 deraadt Exp $";
d73 1
a73 3
		input(&from,
		      (ifp != 0) ? ifp : iflookup(from.sin_addr.s_addr),
		      &inbuf.rip, cc);
d82 1
a82 1
      struct interface *ifp,
d90 1
d97 3
d101 2
a102 2
	if (ifp != 0)
		ifp->int_state |= IS_ACTIVE;
d104 1
a104 1
	trace_rip("Recv", "from", from, ifp, rip, size);
d113 2
d139 1
a139 1
	    && rip->rip_vers >= RIPv2
a194 9
			 *
			 * Answer a query from a stray program with all
			 * we know. Filter the answer to a query from a
			 * router in the about same way broadcasts are
			 * filtered.
			 *
			 * Only answer a router if we are a supplier
			 * to keep an unwary host that is just starting
			 * from picking us as a router.
d201 2
a202 7
					/* query from `rtquery` or similar
					 */
					supply(from, ifp,
					       OUT_QUERY, 0, rip->rip_vers);
				} else if (supplier) {
					/* a router trying to prime its
					 * tables.
d204 3
a206 2
					supply(from, ifp,
					       OUT_UNICAST, 0, rip->rip_vers);
d208 23
d259 1
a259 1
				mask = ripv1_mask_host(dst,ifp);
d276 1
a276 1
				n->n_metric += (ifp!=0) ? ifp->int_metric : 1;
d281 1
a281 1
					if (ifp != 0
d283 3
a285 3
						      ifp->int_net,
						      ifp->int_mask)
					    && rt->rt_gate != ifp->int_addr)
d302 1
a302 1
			(void)output(OUT_QUERY, from, ifp, rip, size);
d304 1
a304 1
			(void)output(OUT_UNICAST, from, ifp, rip, size);
d316 1
a316 1
		if (ifp == 0) {
a320 1
#if PERMIT_TRACE
a327 4
#else
		msglog("trace command from %s ignored: %s\n",
		    rip->rip_tracefile);
#endif
d375 1
a375 1
		if (!ifp) {
d383 1
a383 1
		if (ifp->int_state & IS_PASSIVE) {
d387 1
a387 1
				  ifp->int_name);
d393 1
a393 1
		if (((ifp->int_state & IS_NO_RIPV1_IN)
d395 1
a395 1
		    || ((ifp->int_state & IS_NO_RIPV2_IN)
d404 1
a404 1
		if (ifp->int_state & IS_BROKE) {
d406 1
a406 1
				  ifp->int_name);
d412 1
a412 1
		if (ifp->int_passwd[0] != '\0') {
d423 2
a424 2
					     ifp->int_passwd,
					     sizeof(ifp->int_passwd))) {
d481 1
a481 1
					       ifp->int_net, ifp->int_mask)
d499 1
a499 1
				mask = ripv1_mask_host(dst,ifp);
d516 1
a516 1
			n->n_metric += ifp->int_metric;
d526 1
a526 1
			if (ifp->int_d_metric != 0
d528 1
a528 1
			    && n->n_metric >= ifp->int_d_metric)
d577 1
a577 1
				input_route(ifp, FROM_NADDR,
d657 2
a658 4
	 * metric.  Partly solve this problem by faking the
	 * RIPv1 route with a metric that reflects the most
	 * distant part of the subnet.  Also never
	 * aggregate into such a route.  Also keep it
@


1.5
log
@turn logging off again, it is still unsafe
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.4 1996/09/05 14:31:27 mickey Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.4 1996/09/05 14:31:27 mickey Exp $";
d199 1
a199 1
			 * from picking us an a router.
@


1.4
log
@fix import.
mention that routed is from vjs@@sgi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: input.c,v 1.3 1996/06/23 14:32:27 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.3 1996/06/23 14:32:27 deraadt Exp $";
d307 1
d315 4
@


1.3
log
@update rcsid
@
text
@d1 1
a1 2
/*	$OpenBSD: input.c,v 1.16 1995/07/13 23:20:10 christos Exp $	*/
/*	$NetBSD: input.c,v 1.16 1995/07/13 23:20:10 christos Exp $	*/
d36 1
a36 2
#ifndef lint
#if 0
d39 1
a39 1
static char rcsid[] = "$OpenBSD: input.c,v 1.16 1995/07/13 23:20:10 christos Exp $";
a40 1
#endif /* not lint */
a41 3
/*
 * Routing Table Management Daemon
 */
d43 4
a46 1
#include <syslog.h>
d49 1
a49 5
/*
 * "Authenticate" router from which message originated.
 * We accept routing packets from routers directly connected
 * via broadcast or point-to-point networks,
 * and from those listed in /etc/gateways.
d51 3
a53 3
static struct interface *
rip_verify(from)
	struct sockaddr *from;
d55 3
a57 2
	struct interface *ifp;
	char buf[256];
a58 6
	if ((ifp = if_iflookup(from)) == 0) {
		syslog(LOG_ERR, "trace command from unknown router, %s",
		       (*afswitch[from->sa_family].af_format)(from, buf,
							      sizeof(buf)));
		return NULL;
	}
d60 16
a75 8
	if ((ifp->int_flags & 
		(IFF_BROADCAST|IFF_POINTOPOINT|IFF_REMOTE)) == 0) {
		syslog(LOG_ERR,
		       "trace command from router %s, with bad flags %x",
		       (*afswitch[from->sa_family].af_format)(from, buf,
							      sizeof(buf)),
		       ifp->int_flags);
		return NULL;
a76 10

	if ((ifp->int_flags & IFF_PASSIVE) != 0) {
		syslog(LOG_ERR,
		       "trace command from %s on an active interface",
		       (*afswitch[from->sa_family].af_format)(from, buf,
							      sizeof(buf)));
		return NULL;
	}

	return ifp;
d80 1
a80 2
/*
 * Process a newly received packet.
d82 5
a86 5
void
rip_input(from, rip, size)
	struct sockaddr *from;
	register struct rip *rip;
	int size;
d88 30
a117 16
	register struct rt_entry *rt;
	register struct netinfo *n;
	register struct interface *ifp;
	struct sockaddr dst, gateway, netmask;
	int count, changes = 0;
	register struct afswitch *afp;
	static struct sockaddr badfrom;
	char buf1[256], buf2[256];

	ifp = 0;
	TRACE_INPUT(ifp, from, (char *)rip, size);
	if (from->sa_family >= af_max ||
	    (afp = &afswitch[from->sa_family])->af_hash == NULL) {
		syslog(LOG_INFO,
	 "\"from\" address in unsupported address family (%d), cmd %d\n",
		    from->sa_family, rip->rip_cmd);
d120 23
a142 6
	if (rip->rip_vers == 0) {
		syslog(LOG_ERR,
		    "RIP version 0 packet received from %s! (cmd %d)",
		    (*afswitch[from->sa_family].af_format)(from, buf1,
							   sizeof(buf1)),
		    rip->rip_cmd);
d147 11
d159 29
a187 15
	case RIPCMD_REQUEST:
		n = rip->rip_nets;
		count = size - ((char *)n - (char *)rip);
		if (count < sizeof (struct netinfo))
			return;
		for (; count > 0; n++) {
			if (count < sizeof (struct netinfo))
				break;
			count -= sizeof (struct netinfo);

			n->rip_metric = ntohl(n->rip_metric);
			n->rip_family = ntohs(n->rip_family);
			/* 
			 * A single entry with sa_family == AF_UNSPEC and
			 * metric ``infinity'' means ``all routes''.
d190 10
a199 1
			 * (eg, query).
d201 38
a238 4
			if (n->rip_family == AF_UNSPEC &&
			    n->rip_metric == HOPCNT_INFINITY && count == 0) {
			    	if (supplier || (*afp->af_portmatch)(from) == 0)
					supply(from, 0, 0, 0);
d241 35
a275 13
			if (n->rip_family < af_max &&
			    afswitch[n->rip_family].af_hash) {
				if (!(*afswitch[n->rip_family].af_get)(
					DESTINATION, n, &dst))
					return;
				rt = rtlookup(&dst);
			}
			else
				rt = 0;
#define min(a, b) (a < b ? a : b)
			n->rip_metric = rt == 0 ? HOPCNT_INFINITY :
				min(rt->rt_metric + 1, HOPCNT_INFINITY);
			n->rip_metric = htonl(n->rip_metric);
d277 5
d283 9
a291 2
		memcpy(packet, rip, size);
		(*afp->af_output)(s, 0, from, size);
d297 3
a299 2
#ifdef TRACING
		if ((*afp->af_portcheck)(from) == 0)
d301 4
a304 2

		if ((ifp = rip_verify(from)) == NULL)
d306 8
a313 7

		((char *)rip)[size] = '\0';
		if (rip->rip_cmd == RIPCMD_TRACEON)
			traceon(rip->rip_tracefile);
		else
			traceoff();
#endif
d317 7
d325 7
a331 1
		if ((*afp->af_portmatch)(from) == 0)
d333 82
a414 9
		(*afp->af_canon)(from);
		/* are we talking to ourselves? */
		ifp = if_ifwithaddr(from);
		if (ifp) {
			if (ifp->int_flags & IFF_PASSIVE) {
				syslog(LOG_ERR,
				  "bogus input (from passive interface, %s)",
				  (*afswitch[from->sa_family].af_format)(from,
							 buf1, sizeof(buf1)));
d417 4
a420 32
			rt = rtfind(from);
			if (rt == 0 || (((rt->rt_state & RTS_INTERFACE) == 0) &&
			    rt->rt_metric >= ifp->int_metric))
				addrouteforif(ifp);
			else
				rt->rt_timer = 0;
			return;
		}
		/*
		 * Update timer for interface on which the packet arrived.
		 * If from other end of a point-to-point link that isn't
		 * in the routing tables, (re-)add the route.
		 */
		if ((rt = rtfind(from)) &&
		    (rt->rt_state & (RTS_INTERFACE | RTS_REMOTE)))
			rt->rt_timer = 0;
		else if ((ifp = if_ifwithdstaddr(from)) &&
		    (rt == 0 || rt->rt_metric >= ifp->int_metric))
			addrouteforif(ifp);

		if ((ifp = rip_verify(from)) == NULL)
			return;

		size -= 4 * sizeof (char);
		n = rip->rip_nets;
		for (; size > 0; size -= sizeof (struct netinfo), n++) {
			if (size < sizeof (struct netinfo))
				break;
			n->rip_metric = ntohl(n->rip_metric);
			n->rip_family = ntohs(n->rip_family);
			if (!(*afswitch[n->rip_family].af_get)(DESTINATION, n,
							       &dst))
d422 14
a435 14
			if (!(*afswitch[n->rip_family].af_get)(NETMASK,
							       n, &netmask))
				memset(&netmask, 0, sizeof(netmask));
			if (!(*afswitch[n->rip_family].af_get)(GATEWAY,
							       n, &gateway))
				memcpy(&gateway, from, sizeof(gateway));
			if (dst.sa_family >= af_max ||
			    (afp = &afswitch[dst.sa_family])->af_hash == NULL) {
				syslog(LOG_INFO,
		"route in unsupported address family (%d), from %s (af %d)\n",
				   dst.sa_family,
				   (*afswitch[from->sa_family].af_format)(from,
							  buf1, sizeof(buf1)),
				   from->sa_family);
d438 43
a480 9
			if (((*afp->af_checkhost)(&dst)) == 0) {
				syslog(LOG_DEBUG,
				   "bad host %s in route from %s (af %d)\n",
				   (*afswitch[dst.sa_family].af_format)(
					&dst, buf1, sizeof(buf1)),
				   (*afswitch[from->sa_family].af_format)(from,
					buf2, sizeof(buf2)),
				   from->sa_family);
				continue;
d482 12
a493 10
			if (n->rip_metric == 0 ||
			    (unsigned) n->rip_metric > HOPCNT_INFINITY) {
				if (memcmp(from, &badfrom,
					   sizeof(badfrom)) != 0) {
					syslog(LOG_ERR,
					    "bad metric (%d) from %s\n",
					    n->rip_metric,
				  (*afswitch[from->sa_family].af_format)(from,
						buf1, sizeof(buf1)));
					badfrom = *from;
d497 14
a510 2
			/*
			 * Adjust metric according to incoming interface.
d512 45
a556 28
			if ((unsigned) n->rip_metric < HOPCNT_INFINITY)
				n->rip_metric += ifp->int_metric;
			if ((unsigned) n->rip_metric > HOPCNT_INFINITY)
				n->rip_metric = HOPCNT_INFINITY;
			rt = rtlookup(&dst);
			if (rt == 0 ||
			    (rt->rt_state & (RTS_INTERNAL|RTS_INTERFACE)) ==
			    (RTS_INTERNAL|RTS_INTERFACE)) {
				/*
				 * If we're hearing a logical network route
				 * back from a peer to which we sent it,
				 * ignore it.
				 */
				if (rt && rt->rt_state & RTS_SUBNET &&
				    (*afp->af_sendroute)(rt, from))
					continue;
				if ((unsigned)n->rip_metric < HOPCNT_INFINITY) {
				    /*
				     * Look for an equivalent route that
				     * includes this one before adding
				     * this route.
				     */
				    rt = rtfind(&dst);
				    if (rt && equal(&gateway, &rt->rt_router))
					    continue;
				    rtadd(&dst, &gateway, &netmask,
					  n->rip_metric, 0);
				    changes++;
d558 2
a559 1
				continue;
d562 6
a567 23
			/*
			 * Update if from gateway and different,
			 * shorter, or equivalent but old route
			 * is getting stale.
			 */
			if (equal(&gateway, &rt->rt_router)) {
				if (n->rip_metric != rt->rt_metric) {
					rtchange(rt, &gateway,
						 &netmask, n->rip_metric);
					changes++;
					rt->rt_timer = 0;
					if (rt->rt_metric >= HOPCNT_INFINITY)
						rt->rt_timer =
						    GARBAGE_TIME - EXPIRE_TIME;
				} else if (rt->rt_metric < HOPCNT_INFINITY)
					rt->rt_timer = 0;
			} else if ((unsigned) n->rip_metric < rt->rt_metric ||
			    (rt->rt_metric == n->rip_metric &&
			    rt->rt_timer > (EXPIRE_TIME/2) &&
			    (unsigned) n->rip_metric < HOPCNT_INFINITY)) {
				rtchange(rt, &gateway, &netmask, n->rip_metric);
				changes++;
				rt->rt_timer = 0;
d572 2
d575 22
a596 11
	/*
	 * If changes have occurred, and if we have not sent a broadcast
	 * recently, send a dynamic update.  This update is sent only
	 * on interfaces other than the one on which we received notice
	 * of the change.  If we are within MIN_WAITTIME of a full update,
	 * don't bother sending; if we just sent a dynamic update
	 * and set a timer (nextbcast), delay until that time.
	 * If we just sent a full update, delay the dynamic update.
	 * Set a timer for a randomized value to suppress additional
	 * dynamic updates until it expires; if we delayed sending
	 * the current changes, set needupdate.
d598 82
a679 35
	if (changes && supplier &&
	   now.tv_sec - lastfullupdate.tv_sec < SUPPLY_INTERVAL-MAX_WAITTIME) {
		u_long delay;

		if (now.tv_sec - lastbcast.tv_sec >= MIN_WAITTIME &&
		    timercmp(&nextbcast, &now, <)) {
			if (traceactions)
				fprintf(ftrace, "send dynamic update\n");
			toall(supply, RTS_CHANGED, ifp);
			lastbcast = now;
			needupdate = 0;
			nextbcast.tv_sec = 0;
		} else {
			needupdate++;
			if (traceactions)
				fprintf(ftrace, "delay dynamic update\n");
		}
#define RANDOMDELAY()	(MIN_WAITTIME * 1000000 + \
		(u_long)random() % ((MAX_WAITTIME - MIN_WAITTIME) * 1000000))

		if (nextbcast.tv_sec == 0) {
			delay = RANDOMDELAY();
			if (traceactions)
				fprintf(ftrace,
				    "inhibit dynamic update for %d usec\n",
				    delay);
			nextbcast.tv_sec = delay / 1000000;
			nextbcast.tv_usec = delay % 1000000;
			timeradd(&nextbcast, &now, &nextbcast);
			/*
			 * If the next possibly dynamic update
			 * is within MIN_WAITTIME of the next full update,
			 * force the delay past the full update,
			 * or we might send a dynamic update just before
			 * the full update.
d681 13
a693 4
			if (nextbcast.tv_sec > lastfullupdate.tv_sec +
			    SUPPLY_INTERVAL - MIN_WAITTIME)
				nextbcast.tv_sec = lastfullupdate.tv_sec +
				    SUPPLY_INTERVAL + 1;
d695 22
d718 12
@


1.2
log
@do not allow network-induced tracing
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: input.c,v 1.16 1995/07/13 23:20:10 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d178 1
d190 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@new routed from SGI.
rip1, rip2, icmp, rdisc.
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
d36 2
a37 1
#if !defined(lint)
d39 2
d42 1
d44 3
d48 1
a49 3
static void input(struct sockaddr_in *, struct interface*, struct rip *, int);
static void input_route(struct interface *, naddr,
			naddr, naddr, naddr, struct netinfo *);
d51 5
a55 2

/* process RIP input
d57 3
a59 3
void
read_rip(int sock,
	 struct interface *ifp)
d61 2
a62 3
	struct sockaddr_in from;
	int fromlen, cc;
	union pkt_buf inbuf;
d64 16
d81 6
a86 16
	for (;;) {
		fromlen = sizeof(from);
		cc = recvfrom(sock, &inbuf, sizeof(inbuf), 0,
			      (struct sockaddr*)&from, &fromlen);
		if (cc <= 0) {
			if (cc < 0 && errno != EWOULDBLOCK)
				LOGERR("recvfrom(rip)");
			break;
		}
		if (fromlen != sizeof(struct sockaddr_in))
			logbad(1,"impossible recvfrom(rip) fromlen=%d",
			       fromlen);

		input(&from,
		      (ifp != 0) ? ifp : iflookup(from.sin_addr.s_addr),
		      &inbuf.rip, cc);
d88 2
d93 2
a94 1
/* Process a RIP packet
d96 5
a100 5
static void
input(struct sockaddr_in *from,		/* received from this IP address */
      struct interface *ifp,
      struct rip *rip,
      int size)
d102 16
a117 22
#	define FROM_NADDR from->sin_addr.s_addr
	static naddr use_auth, bad_len, bad_mask;
	static naddr unk_router, bad_router, bad_nhop;

	struct rt_entry *rt;
	struct netinfo *n, *lim;
	struct interface *ifp1;
	naddr gate, mask, v1_mask, dst, ddst_h;
	int i;


	if (ifp != 0)
		ifp->int_state |= IS_ACTIVE;

	trace_rip("Recv", "from", from, ifp, rip, size);

	if (rip->rip_vers == 0) {
		if (from->sin_addr.s_addr != bad_router)
			msglog("RIP version 0, cmd %d, packet received"
			       " from %s",
			       rip->rip_cmd, naddr_ntoa(FROM_NADDR));
		bad_router = from->sin_addr.s_addr;
d120 6
a125 6
	if (size > MAXPACKETSIZE) {
		if (from->sin_addr.s_addr != bad_router)
			msglog("packet at least %d bytes too long received"
			       " from %s",
			       size-MAXPACKETSIZE, naddr_ntoa(FROM_NADDR));
		bad_router = from->sin_addr.s_addr;
d129 1
a129 2
	n = rip->rip_nets;
	lim = (struct netinfo *)((char*)rip + size);
a130 23
	/* Notice authentication.
	 * As required by section 4.2 in RFC 1723, discard authenticated
	 * RIPv2 messages, but only if configured for that silliness.
	 *
	 * RIPv2 authentication is lame, since snooping on the wire makes
	 * its simple passwords evident.  Also, why authenticate queries?
	 * Why should a RIPv2 implementation with authentication disabled
	 * not be able to listen to RIPv2 packets with authenication, while
	 * RIPv1 systems will listen?  Crazy!
	 */
	if (!auth_ok
	    && rip->rip_vers >= RIPv2
	    && n < lim && n->n_family == RIP_AF_AUTH) {
		if (from->sin_addr.s_addr != use_auth)
			msglog("RIPv2 message with authentication"
			       " from %s discarded",
			       naddr_ntoa(FROM_NADDR));
		use_auth = from->sin_addr.s_addr;
		trace_pkt("discard authenticated RIPv2 message\n");
		return;
	}

	switch (rip->rip_cmd) {
d132 14
a145 40
		/* did the request come from a router?
		 */
		if (from->sin_port == htons(RIP_PORT)) {
			/* yes, ignore it if RIP is off so that it does not
			 * depend on us.
			 */
			if (rip_sock < 0) {
				trace_pkt("ignore request while RIP off\n");
				return;
			}

			/* Ignore the request if we talking to ourself
			 * (and not a remote gateway).
			 */
			if (ifwithaddr(FROM_NADDR, 0, 0) != 0) {
				trace_pkt("discard our own RIP request\n");
				return;
			}
		}

		/* According to RFC 1723, we should ignore unathenticated
		 * queries.  That is too silly to bother with.  Sheesh!
		 * Are forwarding tables supposed to be secret?  When
		 * a bad guy can infer them with test traffic?
		 * Maybe on firewalls you'd care, but not enough to
		 * give up the diagnostic facilities of remote probing.
		 */

		if (n >= lim
		    || size%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			if (from->sin_addr.s_addr != bad_len)
				msglog("request of bad length (%d) from %s",
				       size, naddr_ntoa(FROM_NADDR));
			bad_len = from->sin_addr.s_addr;
		}
		for (; n < lim; n++) {
			n->n_metric = ntohl(n->n_metric);

			/* A single entry with family RIP_AF_UNSPEC and
			 * metric HOPCNT_INFINITY means "all routes".
d148 1
a148 10
			 * (i.e. a query).
			 *
			 * Answer a query from a stray program with all
			 * we know. Filter the answer to a query from a
			 * router in the about same way broadcasts are
			 * filtered.
			 *
			 * Only answer a router if we are a supplier
			 * to keep an unwary host that is just starting
			 * from picking us an a router.
d150 4
a153 38
			if (n->n_family == RIP_AF_UNSPEC
			    && n->n_metric == HOPCNT_INFINITY
			    && n == rip->rip_nets
			    && n+1 == lim) {
				if (from->sin_port != htons(RIP_PORT)) {
					/* query from `rtquery` or similar
					 */
					supply(from, ifp,
					       OUT_QUERY, 0, rip->rip_vers);
				} else if (supplier) {
					/* a router trying to prime its
					 * tables.
					 */
					supply(from, ifp,
					       OUT_UNICAST, 0, rip->rip_vers);
				}
				return;
			}

			if (n->n_family != RIP_AF_INET) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("request from %s"
					       " for unsupported (af %d) %s",
					       naddr_ntoa(FROM_NADDR),
					       ntohs(n->n_family),
					       naddr_ntoa(n->n_dst));
				bad_router = from->sin_addr.s_addr;
				return;
			}

			dst = n->n_dst;
			if (!check_dst(dst)) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad queried destination"
					       " %s from %s",
					       naddr_ntoa(dst),
					       naddr_ntoa(FROM_NADDR));
				bad_router = from->sin_addr.s_addr;
d156 13
a168 35

			if (rip->rip_vers == RIPv1
			    || 0 == (mask = ntohl(n->n_mask))
			    || 0 != (ntohl(dst) & ~mask))
				mask = ripv1_mask_host(dst,ifp);

			rt = rtget(dst, mask);
			if (!rt && dst != RIP_DEFAULT)
				rt = rtfind(n->n_dst);

			n->n_tag = 0;
			n->n_nhop = 0;
			if (rip->rip_vers == RIPv1) {
				n->n_mask = 0;
			} else {
				n->n_mask = mask;
			}
			if (rt == 0) {
				n->n_metric = HOPCNT_INFINITY;
			} else {
				n->n_metric = rt->rt_metric+1;
				n->n_metric += (ifp!=0) ? ifp->int_metric : 1;
				if (n->n_metric > HOPCNT_INFINITY)
					n->n_metric = HOPCNT_INFINITY;
				if (rip->rip_vers != RIPv1) {
					n->n_tag = rt->rt_tag;
					if (ifp != 0
					    && on_net(rt->rt_gate,
						      ifp->int_net,
						      ifp->int_mask)
					    && rt->rt_gate != ifp->int_addr)
						n->n_nhop = rt->rt_gate;
				}
			}
			HTONL(n->n_metric);
a169 5
		/* Answer about specific routes.
		 * Only answer a router if we are a supplier
		 * to keep an unwary host that is just starting
		 * from picking us an a router.
		 */
d171 2
a172 9
		rip->rip_res1 = 0;
		if (rip->rip_vers != RIPv1)
			rip->rip_vers = RIPv2;
		if (from->sin_port != htons(RIP_PORT)) {
			/* query */
			(void)output(OUT_QUERY, from, ifp, rip, size);
		} else if (supplier) {
			(void)output(OUT_UNICAST, from, ifp, rip, size);
		}
d178 1
a178 3
		if (ntohs(from->sin_port) > IPPORT_RESERVED) {
			msglog("trace command from untrusted port on %s",
			       naddr_ntoa(FROM_NADDR));
d180 2
a181 4
		}
		if (ifp == 0) {
			msglog("trace command from unknown router %s",
			       naddr_ntoa(FROM_NADDR));
d183 6
a188 8
		}
		if (rip->rip_cmd == RIPCMD_TRACEON) {
			rip->rip_tracefile[size-4] = '\0';
			trace_on((char*)rip->rip_tracefile, 0);
		} else {
			trace_off("tracing turned off by %s\n",
				  naddr_ntoa(FROM_NADDR));
		}
a191 7
		if (size%sizeof(*n) != sizeof(struct rip)%sizeof(*n)) {
			if (from->sin_addr.s_addr != bad_len)
				msglog("response of bad length (%d) from %s",
				       size, naddr_ntoa(FROM_NADDR));
			bad_len = from->sin_addr.s_addr;
		}

d193 1
a193 68
		if (from->sin_port != ntohs(RIP_PORT)) {
			trace_pkt("discard RIP response from unknown port\n");
			return;
		}

		if (rip_sock < 0) {
			trace_pkt("discard response while RIP off\n");
			return;
		}

		/* Are we talking to ourself or a remote gateway?
		 */
		ifp1 = ifwithaddr(FROM_NADDR, 0, 1);
		if (ifp1) {
			if (ifp1->int_state & IS_REMOTE) {
				if (ifp1->int_state & IS_PASSIVE) {
					msglog("bogus input from %s on"
					       " supposedly passive %s",
					       naddr_ntoa(FROM_NADDR),
					       ifp1->int_name);
				} else {
					ifp1->int_act_time = now.tv_sec;
					if (if_ok(ifp1, "remote "))
						addrouteforif(ifp1);
				}
			} else {
				trace_pkt("discard our own RIP response\n");
			}
			return;
		}

		/* Check the router from which message originated. We accept
		 * routing packets from routers directly connected via
		 * broadcast or point-to-point networks, and from
		 * those listed in /etc/gateways.
		 */
		if (!ifp) {
			if (from->sin_addr.s_addr != unk_router)
				msglog("discard packet from unknown router %s"
				       " or via unidentified interface",
				       naddr_ntoa(FROM_NADDR));
			unk_router = from->sin_addr.s_addr;
			return;
		}
		if (ifp->int_state & IS_PASSIVE) {
			trace_act("discard packet from %s"
				  " via passive interface %s\n",
				  naddr_ntoa(FROM_NADDR),
				  ifp->int_name);
			return;
		}

		/* Check required version
		 */
		if (((ifp->int_state & IS_NO_RIPV1_IN)
		     && rip->rip_vers == RIPv1)
		    || ((ifp->int_state & IS_NO_RIPV2_IN)
			&& rip->rip_vers != RIPv1)) {
			trace_pkt("discard RIPv%d response\n",
				  rip->rip_vers);
			return;
		}

		/* Ignore routes via dead interface.
		 */
		if (ifp->int_state & IS_BROKE) {
			trace_pkt("discard response via broken interface %s\n",
				  ifp->int_name);
d195 9
a203 21
		}

		/* Authenticate the packet if we have a secret.
		 */
		if (ifp->int_passwd[0] != '\0') {
			if (n >= lim
			    || n->n_family != RIP_AF_AUTH
			    || ((struct netauth*)n)->a_type != RIP_AUTH_PW) {
				if (from->sin_addr.s_addr != use_auth)
					msglog("missing password from %s",
					       naddr_ntoa(FROM_NADDR));
				use_auth = from->sin_addr.s_addr;
				return;

			} else if (0 != bcmp(((struct netauth*)n)->au.au_pw,
					     ifp->int_passwd,
					     sizeof(ifp->int_passwd))) {
				if (from->sin_addr.s_addr != use_auth)
					msglog("bad password from %s",
					       naddr_ntoa(FROM_NADDR));
				use_auth = from->sin_addr.s_addr;
d206 32
a237 4
		}

		for (; n < lim; n++) {
			if (n->n_family == RIP_AF_AUTH)
d239 14
a252 14

			NTOHL(n->n_metric);
			dst = n->n_dst;
			if (n->n_family != RIP_AF_INET
			    && (n->n_family != RIP_AF_UNSPEC
				|| dst != RIP_DEFAULT)) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("route from %s to unsupported"
					       " address family %d,"
					       " destination %s",
					       naddr_ntoa(FROM_NADDR),
					       n->n_family,
					       naddr_ntoa(dst));
				bad_router = from->sin_addr.s_addr;
d255 9
a263 7
			if (!check_dst(dst)) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad destination %s from %s",
					       naddr_ntoa(dst),
					       naddr_ntoa(FROM_NADDR));
				bad_router = from->sin_addr.s_addr;
				return;
d265 12
a276 10
			if (n->n_metric == 0
			    || n->n_metric > HOPCNT_INFINITY) {
				if (from->sin_addr.s_addr != bad_router)
					msglog("bad metric %d from %s"
					       " for destination %s",
					       n->n_metric,
					       naddr_ntoa(FROM_NADDR),
					       naddr_ntoa(dst));
				bad_router = from->sin_addr.s_addr;
				return;
d278 2
a279 2

			/* Notice the next-hop.
d281 28
a308 34
			gate = from->sin_addr.s_addr;
			if (n->n_nhop != 0) {
				if (rip->rip_vers == RIPv2) {
					n->n_nhop = 0;
				} else {
				    /* Use it only if it is valid. */
				    if (on_net(n->n_nhop,
					       ifp->int_net, ifp->int_mask)
					&& check_dst(n->n_nhop)) {
					    gate = n->n_nhop;
				    } else {
					if (bad_nhop != from->sin_addr.s_addr)
						msglog("router %s to %s has"
						       " bad next hop %s",
						       naddr_ntoa(FROM_NADDR),
						       naddr_ntoa(dst),
						       naddr_ntoa(n->n_nhop));
					bad_nhop = from->sin_addr.s_addr;
					n->n_nhop = 0;
				    }
				}
			}

			if (rip->rip_vers == RIPv1
			    || 0 == (mask = ntohl(n->n_mask))) {
				mask = ripv1_mask_host(dst,ifp);
			} else if ((ntohl(dst) & ~mask) != 0) {
				if (bad_mask != from->sin_addr.s_addr) {
					msglog("router %s sent bad netmask"
					       " %#x with %s",
					       naddr_ntoa(FROM_NADDR),
					       mask,
					       naddr_ntoa(dst));
					bad_mask = from->sin_addr.s_addr;
a311 19
			if (rip->rip_vers == RIPv1)
				n->n_tag = 0;

			/* Adjust metric according to incoming interface..
			 */
			n->n_metric += ifp->int_metric;
			if (n->n_metric > HOPCNT_INFINITY)
				n->n_metric = HOPCNT_INFINITY;

			/* Recognize and ignore a default route we faked
			 * which is being sent back to us by a machine with
			 * broken split-horizon.
			 * Be a little more paranoid than that, and reject
			 * default routes with the same metric we advertised.
			 */
			if (ifp->int_d_metric != 0
			    && dst == RIP_DEFAULT
			    && n->n_metric >= ifp->int_d_metric)
				continue;
d313 4
a316 19
			/* We can receive aggregated RIPv2 routes that must
			 * be broken down before they are transmitted by
			 * RIPv1 via an interface on a subnet.
			 * We might also receive the same routes aggregated
			 * via other RIPv2 interfaces.
			 * This could cause duplicate routes to be sent on
			 * the RIPv1 interfaces.  "Longest matching variable
			 * length netmasks" lets RIPv2 listeners understand,
			 * but breaking down the aggregated routes for RIPv1
			 * listeners can produce duplicate routes.
			 *
			 * Breaking down aggregated routes here bloats
			 * the daemon table, but does not hurt the kernel
			 * table, since routes are always aggregated for
			 * the kernel.
			 *
			 * Notice that this does not break down network
			 * routes corresponding to subnets.  This is part
			 * of the defense against RS_NET_SYN.
d318 18
a335 31
			if (have_ripv1_out
			    && (v1_mask = ripv1_mask_net(dst,0)) > mask
			    && (((rt = rtget(dst,mask)) == 0
				 || !(rt->rt_state & RS_NET_SYN)))) {
				ddst_h = v1_mask & -v1_mask;
				i = (v1_mask & ~mask)/ddst_h;
				if (i >= 511) {
					/* Punt if we would have to generate
					 * an unreasonable number of routes.
					 */
#ifdef DEBUG
					msglog("accept %s from %s as 1"
					       " instead of %d routes",
					       addrname(dst,mask,0),
					       naddr_ntoa(FROM_NADDR),
					       i+1);
#endif
					i = 0;
				} else {
					mask = v1_mask;
				}
			} else {
				i = 0;
			}

			for (;;) {
				input_route(ifp, FROM_NADDR,
					    dst, mask, gate, n);
				if (i-- == 0)
					break;
				dst = htonl(ntohl(dst) + ddst_h);
a339 2
}

d341 11
a351 22
/* Process a single input route.
 */
static void
input_route(struct interface *ifp,
	    naddr from,
	    naddr dst,
	    naddr mask,
	    naddr gate,
	    struct netinfo *n)
{
	int i;
	struct rt_entry *rt;
	struct rt_spare *rts, *rts0;
	struct interface *ifp1;
	time_t new_time;


	/* See if the other guy is telling us to send our packets to him.
	 * Sometimes network routes arrive over a point-to-point link for
	 * the network containing the address(es) of the link.
	 *
	 * If our interface is broken, switch to using the other guy.
d353 35
a387 82
	ifp1 = ifwithaddr(dst, 1, 1);
	if (ifp1 != 0
	    && !(ifp1->int_state & IS_BROKE))
		return;

	/* Look for the route in our table.
	 */
	rt = rtget(dst, mask);

	/* Consider adding the route if we do not already have it.
	 */
	if (rt == 0) {
		/* Ignore unknown routes being poisoned.
		 */
		if (n->n_metric == HOPCNT_INFINITY)
			return;

		/* Ignore the route if it points to us */
		if (n->n_nhop != 0
		    && 0 != ifwithaddr(n->n_nhop, 1, 0))
			return;

		/* If something has not gone crazy and tried to fill
		 * our memory, accept the new route.
		 */
		if (total_routes < MAX_ROUTES)
			rtadd(dst, mask, gate, from, n->n_metric,
			      n->n_tag, 0, ifp);
		return;
	}

	/* We already know about the route.  Consider this update.
	 *
	 * If (rt->rt_state & RS_NET_SYN), then this route
	 * is the same as a network route we have inferred
	 * for subnets we know, in order to tell RIPv1 routers
	 * about the subnets.
	 *
	 * It is impossible to tell if the route is coming
	 * from a distant RIPv2 router with the standard
	 * netmask because that router knows about the entire
	 * network, or if it is a round-about echo of a
	 * synthetic, RIPv1 network route of our own.
	 * The worst is that both kinds of routes might be
	 * received, and the bad one might have the smaller
	 * metric.  Partly solve this problem by faking the
	 * RIPv1 route with a metric that reflects the most
	 * distant part of the subnet.  Also never
	 * aggregate into such a route.  Also keep it
	 * around as long as the interface exists.
	 */

	rts0 = rt->rt_spares;
	for (rts = rts0, i = NUM_SPARES; i != 0; i--, rts++) {
		if (rts->rts_router == from)
			break;
		/* Note the worst slot to reuse,
		 * other than the current slot.
		 */
		if (rts0 == rt->rt_spares
		    || BETTER_LINK(rt, rts0, rts))
			rts0 = rts;
	}
	if (i != 0) {
		/* Found the router
		 */
		int old_metric = rts->rts_metric;

		/* Keep poisoned routes around only long enough to pass
		 * the poison on.  Get a new timestamp for good routes.
		 */
		new_time =((old_metric == HOPCNT_INFINITY)
			   ? rts->rts_time
			   : now.tv_sec);

		/* If this is an update for the router we currently prefer,
		 * then note it.
		 */
		if (i == NUM_SPARES) {
			rtchange(rt,rt->rt_state, gate,rt->rt_router,
				 n->n_metric, n->n_tag, ifp, new_time, 0);
			/* If the route got worse, check for something better.
d389 4
a392 13
			if (n->n_metric > old_metric)
				rtswitch(rt, 0);
			return;
		}

		/* This is an update for a spare route.
		 * Finished if the route is unchanged.
		 */
		if (rts->rts_gate == gate
		    && old_metric == n->n_metric
		    && rts->rts_tag == n->n_tag) {
			rts->rts_time = new_time;
			return;
a393 22

	} else {
		/* The update is for a route we know about,
		 * but not from a familiar router.
		 *
		 * Ignore the route if it points to us.
		 */
		if (n->n_nhop != 0
		    && 0 != ifwithaddr(n->n_nhop, 1, 0))
			return;

		rts = rts0;

		/* Save the route as a spare only if it has
		 * a better metric than our worst spare.
		 * This also ignores poisoned routes (those
		 * received with metric HOPCNT_INFINITY).
		 */
		if (n->n_metric >= rts->rts_metric)
			return;

		new_time = now.tv_sec;
a394 12

	trace_upslot(rt, rts, gate, from, ifp, n->n_metric,n->n_tag, new_time);

	rts->rts_gate = gate;
	rts->rts_router = from;
	rts->rts_metric = n->n_metric;
	rts->rts_tag = n->n_tag;
	rts->rts_time = new_time;
	rts->rts_ifp = ifp;

	/* try to switch to a better route */
	rtswitch(rt, rts);
@
