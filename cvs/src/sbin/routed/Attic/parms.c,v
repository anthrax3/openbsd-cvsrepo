head	1.16;
access;
symbols
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.20
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.18
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	mickey:1.1.1.1
	SGI082896:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2008.05.07.11.55.20;	author claudio;	state dead;
branches;
next	1.15;

1.15
date	2007.02.20.01.44.16;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.24.19.44.29;	author moritz;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.12.15.26.47;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.14.22.21.31;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.11.08.39.48;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.03.18.04.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.13.09.09.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.08.14.00.24;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	97.07.30.23.28.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.30.22.24.44;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.12.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.02.06.51.45;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.09.22.20.48.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.09.05.13.58.55;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.05.13.58.55;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.16
log
@RIP routed.

You were a nice thing in the 4.2BSD times but now it is time for you to go.
Superseded by the shiny privseped ripd that does not have the evil habit to
use kernel internals in userland.

OK everybody in the onsen 'cause it unbreaks the tree
@
text
@/*	$OpenBSD: parms.c,v 1.15 2007/02/20 01:44:16 ray Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(lint)
static char sccsid[] = "@@(#)if.c	8.1 (Berkeley) 6/5/93";
#endif

#include "defs.h"
#include "pathnames.h"


struct parm *parms;
struct intnet *intnets;


/* use configured parameters
 */
void
get_parms(struct interface *ifp)
{
	struct parm *parmp;

	/* get all relevant parameters
	 */
	for (parmp = parms; parmp != 0; parmp = parmp->parm_next) {
		if ((parmp->parm_name[0] == '\0'
		     && on_net(ifp->int_addr,
			       parmp->parm_addr_h, parmp->parm_mask))
		    || (parmp->parm_name[0] != '\0'
			&& !strcmp(ifp->int_name, parmp->parm_name))) {
			/* this group of parameters is relevant,
			 * so get its settings
			 */
			ifp->int_state |= parmp->parm_int_state;
			if (parmp->parm_passwd[0] != '\0')
				bcopy(parmp->parm_passwd, ifp->int_passwd,
				      sizeof(ifp->int_passwd));
			if (parmp->parm_rdisc_pref != 0)
				ifp->int_rdisc_pref = parmp->parm_rdisc_pref;
			if (parmp->parm_rdisc_int != 0)
				ifp->int_rdisc_int = parmp->parm_rdisc_int;
			if (parmp->parm_d_metric != 0)
				ifp->int_d_metric = parmp->parm_d_metric;
			}
	}
	/* default poor-man's router discovery to a metric that will
	 * be heard by old versions of routed.
	 */
	if ((ifp->int_state & IS_PM_RDISC)
	    && ifp->int_d_metric == 0)
		ifp->int_d_metric = HOPCNT_INFINITY-2;

	if (IS_RIP_IN_OFF(ifp->int_state))
		ifp->int_state |= IS_NO_RIP_OUT;

	if (ifp->int_rdisc_int == 0)
		ifp->int_rdisc_int = DefMaxAdvertiseInterval;

	if (!(ifp->int_if_flags & IFF_MULTICAST)
	    && !(ifp->int_if_flags & IFF_POINTOPOINT))
		ifp->int_state |= IS_NO_RIPV2_OUT;

	if (!(ifp->int_if_flags & IFF_MULTICAST))
		ifp->int_state |= IS_BCAST_RDISC;

	if (ifp->int_if_flags & IFF_POINTOPOINT) {
		ifp->int_state |= IS_BCAST_RDISC;
		/* By default, point-to-point links should be passive
		 * about router-discovery for the sake of demand-dialing.
		 */
		if (0 == (ifp->int_state & GROUP_IS_SOL))
			ifp->int_state |= IS_NO_SOL_OUT;
		if (0 == (ifp->int_state & GROUP_IS_ADV))
			ifp->int_state |= IS_NO_ADV_OUT;
	}

	if (0 != (ifp->int_state & (IS_PASSIVE | IS_REMOTE)))
		ifp->int_state |= IS_NO_RDISC;
	if (ifp->int_state & IS_PASSIVE)
		ifp->int_state |= (IS_NO_RIP | IS_NO_RDISC);
	if ((ifp->int_state & (IS_NO_RIP | IS_NO_RDISC))
	    == (IS_NO_RIP|IS_NO_RDISC))
		ifp->int_state |= IS_PASSIVE;
}


/* Read a list of gateways from /etc/gateways and add them to our tables.
 *
 * This file contains a list of "remote" gateways.  That is usually
 * a gateway which we cannot immediately determine if it is present or
 * not as we can do for those provided by directly connected hardware.
 *
 * If a gateway is marked "passive" in the file, then we assume it
 * does not understand RIP and assume it is always present.  Those
 * not marked passive are treated as if they were directly connected
 * and assumed to be broken if they do not send us advertisements.
 * All remote interfaces are added to our list, and those not marked
 * passive are sent routing updates.
 *
 * A passive interface can also be local, hardware interface exempt
 * from RIP.
 */
void
gwkludge(void)
{
	FILE *fp;
	char *p, *lptr;
	char lbuf[200], net_host[5], dname[64+1+64+1], gname[64+1], qual[9];
	struct interface *ifp;
	naddr dst, netmask, gate;
	int metric, n;
	u_int state;
	char *type;

	fp = fopen(_PATH_GATEWAYS, "r");
	if (fp == NULL)
		return;

	for (;;) {
		if (fgets(lbuf, sizeof(lbuf), fp) == NULL)
			break;
		lptr = lbuf;
		while (*lptr == ' ')
			lptr++;
		/* ignore null and comment lines */
		if (*lptr == '\0' || *lptr == '\n' || *lptr == '#')
			continue;
		p = lptr+strlen(lptr)-1;
		while (*p == '\n'
		       || *p == ' ')
			*p-- = '\0';

		/* notice newfangled parameter lines
		 */
		if (strncasecmp("net", lptr, 3)
		    && strncasecmp("host", lptr, 4)) {
			p = parse_parms(lptr);
			if (p != 0) {
				if (strcmp(p,lptr))
					msglog("bad \"%s\" in "_PATH_GATEWAYS
					       " entry \"%s\"", lptr, p);
				else
					msglog("bad \"%s\" in "_PATH_GATEWAYS,
					       lptr);
			}
			continue;
		}

/*  {net | host} XX[/M] XX gateway XX metric DD [passive | external]\n */
		n = sscanf(lptr, "%4s %129[^ \t] gateway"
			   " %64[^ / \t] metric %d %8s\n",
			   net_host, dname, gname, &metric, qual);
		if (n != 5) {
			msglog("bad "_PATH_GATEWAYS" entry \"%s\"", lptr);
			continue;
		}
		if (metric < 0 || metric >= HOPCNT_INFINITY) {
			msglog("bad metric in "_PATH_GATEWAYS" entry \"%s\"",
			       lptr);
			continue;
		}
		if (!strcmp(net_host, "host")) {
			if (!gethost(dname, &dst)) {
				msglog("bad host \"%s\" in "_PATH_GATEWAYS
				       " entry \"%s\"", dname, lptr);
				continue;
			}
			netmask = HOST_MASK;
		} else if (!strcmp(net_host, "net")) {
			if (!getnet(dname, &dst, &netmask)) {
				msglog("bad net \"%s\" in "_PATH_GATEWAYS
				       " entry \"%s\"", dname, lptr);
				continue;
			}
			HTONL(dst);	/* make network # into IP address */
		} else {
			msglog("bad \"%s\" in "_PATH_GATEWAYS
			       " entry \"%s\"", net_host, lptr);
			continue;
		}

		if (!gethost(gname, &gate)) {
			msglog("bad gateway \"%s\" in "_PATH_GATEWAYS
			       " entry \"%s\"", gname, lptr);
			continue;
		}

		if (strcmp(qual, type = "passive") == 0) {
			/* Passive entries are not placed in our tables,
			 * only the kernel's, so we don't copy all of the
			 * external routing information within a net.
			 * Internal machines should use the default
			 * route to a suitable gateway (like us).
			 */
			state = IS_REMOTE | IS_PASSIVE;
			if (metric == 0)
				metric = 1;

		} else if (strcmp(qual, type = "external") == 0) {
			/* External entries are handled by other means
			 * such as EGP, and are placed only in the daemon
			 * tables to prevent overriding them with something
			 * else.
			 */
			state = IS_REMOTE | IS_PASSIVE | IS_EXTERNAL;
			if (metric == 0)
				metric = 1;

		} else if (qual[0] == '\0') {
			if (metric != 0) {
				/* Entries that are neither "passive" nor
				 * "external" are "remote" and must behave
				 * like physical interfaces.  If they are not
				 * heard from regularly, they are deleted.
				 */
				state = IS_REMOTE;
				type = "remote";
			} else {
				/* "remote" entries with a metric of 0
				 * are aliases for our own interfaces
				 */
				state = IS_REMOTE | IS_PASSIVE;
				type = "alias";
			}

		} else {
			msglog("bad "_PATH_GATEWAYS" entry \"%s\"", lptr);
			continue;
		}

		/* Remember to advertise the corresponding logical network.
		 */
		if (!(state & IS_EXTERNAL)
		    && netmask != std_mask(dst))
			state |= IS_SUBNET;

		if (0 != (state & (IS_PASSIVE | IS_REMOTE)))
			state |= IS_NO_RDISC;
		if (state & IS_PASSIVE)
			state |= (IS_NO_RIP | IS_NO_RDISC);
		if ((state & (IS_NO_RIP | IS_NO_RDISC))
		    == (IS_NO_RIP|IS_NO_RDISC))
			state |= IS_PASSIVE;

		/* See if this new interface duplicates an existing
		 * interface.
		 */
		for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_mask == netmask
			    && ((ifp->int_addr == dst
				 && netmask != HOST_MASK)
				|| (ifp->int_dstaddr == dst
				    && netmask == HOST_MASK)))
				break;
		}
		if (ifp != 0) {
			/* Let one of our real interfaces be marked passive.
			 */
			if ((state & IS_PASSIVE) && !(state & IS_EXTERNAL)) {
				ifp->int_state |= state;
			} else {
				msglog("%s is duplicated in "_PATH_GATEWAYS
				       " by %s",
				       ifp->int_name, lptr);
			}
			continue;
		}

		tot_interfaces++;

		ifp = (struct interface *)malloc(sizeof(*ifp));
		bzero(ifp, sizeof(*ifp));
		if (ifnet != 0) {
			ifp->int_next = ifnet;
			ifnet->int_prev = ifp;
		}
		ifnet = ifp;

		ifp->int_state = state;
		ifp->int_net = ntohl(dst) & netmask;
		ifp->int_mask = netmask;
		if (netmask == HOST_MASK)
			ifp->int_if_flags |= IFF_POINTOPOINT;
		ifp->int_dstaddr = dst;
		ifp->int_addr = gate;
		ifp->int_metric = metric;
		(void)snprintf(ifp->int_name, sizeof(ifp->int_name),
		    "%s-%s", type, naddr_ntoa(dst));
		ifp->int_index = -1;

		get_parms(ifp);

		trace_if("Add", ifp);
	}
	fclose(fp);
}


/* parse a set of parameters for an interface
 */
char *					/* 0 or error message */
parse_parms(char *line)
{
#define PARS(str) (0 == (tgt = str, strcasecmp(tok, tgt)))
#define PARSE(str) (0 == (tgt = str, strncasecmp(tok, str "=", sizeof(str))))
#define CKF(g,b) {if (0 != (parm.parm_int_state & ((g) & ~(b)))) break;	\
	parm.parm_int_state |= (b);}
#define DELIMS " ,\t\n"
	struct parm parm;
	struct intnet *intnetp;
	char *tok, *tgt, *p;


	/* "subnet=x.y.z.u/mask" must be alone on the line */
	if (!strncasecmp("subnet=",line,7)) {
		intnetp = (struct intnet*)malloc(sizeof(*intnetp));
		if (intnetp == NULL)
			return "out of memory";
		intnetp->intnet_metric = 1;
		if ((p = strrchr(line,','))) {
			*p++ = '\0';
			intnetp->intnet_metric = (int)strtol(p,&p,0);
			if (*p != '\0'
			    || intnetp->intnet_metric <= 0
			    || intnetp->intnet_metric >= HOPCNT_INFINITY) {
				free(intnetp);
				return line;
			}
		}
		if (!getnet(&line[7], &intnetp->intnet_addr,
			    &intnetp->intnet_mask)
		    || intnetp->intnet_mask == HOST_MASK
		    || intnetp->intnet_addr == RIP_DEFAULT) {
			free(intnetp);
			return line;
		}
		HTONL(intnetp->intnet_addr);
		intnetp->intnet_next = intnets;
		intnets = intnetp;
		return NULL;
	}

	bzero(&parm, sizeof(parm));

	tgt = "null";
	for (tok = strtok(line, DELIMS);
	     tok != 0 && tok[0] != '\0';
	     tgt = 0, tok = strtok(0,DELIMS)) {
		if (PARSE("if")) {
			if (parm.parm_name[0] != '\0'
			    || tok[3] == '\0'
			    || strlen(tok) > IFNAMSIZ+3)
				break;
			strlcpy(parm.parm_name, tok+3, sizeof parm.parm_name);

		} else if (PARSE("passwd")) {
			if (tok[7] == '\0'
			    || strlen(tok) > RIP_AUTH_PW_LEN+7)
				break;
			strlcpy(parm.parm_passwd, tok+7,
			    sizeof parm.parm_passwd);

		} else if (PARS("no_ag")) {
			parm.parm_int_state |= (IS_NO_AG | IS_NO_SUPER_AG);

		} else if (PARS("no_super_ag")) {
			parm.parm_int_state |= IS_NO_SUPER_AG;

		} else if (PARS("no_ripv1_in")) {
			parm.parm_int_state |= IS_NO_RIPV1_IN;

		} else if (PARS("no_ripv2_in")) {
			parm.parm_int_state |= IS_NO_RIPV2_IN;

		} else if (PARS("ripv2_out")) {
			if (parm.parm_int_state & IS_NO_RIPV2_OUT)
				break;
			parm.parm_int_state |= IS_NO_RIPV1_OUT;

		} else if (PARS("no_rip")) {
			parm.parm_int_state |= IS_NO_RIP;

		} else if (PARS("no_rdisc")) {
			CKF((GROUP_IS_SOL|GROUP_IS_ADV), IS_NO_RDISC);

		} else if (PARS("no_solicit")) {
			CKF(GROUP_IS_SOL, IS_NO_SOL_OUT);

		} else if (PARS("send_solicit")) {
			CKF(GROUP_IS_SOL, IS_SOL_OUT);

		} else if (PARS("no_rdisc_adv")) {
			CKF(GROUP_IS_ADV, IS_NO_ADV_OUT);

		} else if (PARS("rdisc_adv")) {
			CKF(GROUP_IS_ADV, IS_ADV_OUT);

		} else if (PARS("bcast_rdisc")) {
			parm.parm_int_state |= IS_BCAST_RDISC;

		} else if (PARS("passive")) {
			CKF((GROUP_IS_SOL|GROUP_IS_ADV), IS_NO_RDISC);
			parm.parm_int_state |= IS_NO_RIP;

		} else if (PARSE("rdisc_pref")) {
			if (parm.parm_rdisc_pref != 0
			    || tok[11] == '\0'
			    || (parm.parm_rdisc_pref = (int)strtol(&tok[11],
								   &p,0),
				*p != '\0'))
				break;

		} else if (PARS("pm_rdisc")) {
			parm.parm_int_state |= IS_PM_RDISC;

		} else if (PARSE("rdisc_interval")) {
			if (parm.parm_rdisc_int != 0
			    || tok[15] == '\0'
			    || (parm.parm_rdisc_int = (int)strtol(&tok[15],
								  &p,0),
				*p != '\0')
			    || parm.parm_rdisc_int < MinMaxAdvertiseInterval
			    || parm.parm_rdisc_int > MaxMaxAdvertiseInterval)
				break;

		} else if (PARSE("fake_default")) {
			if (parm.parm_d_metric != 0
			    || tok[13] == '\0'
			    || (parm.parm_d_metric=(int)strtol(&tok[13],&p,0),
				*p != '\0')
			    || parm.parm_d_metric > HOPCNT_INFINITY-1)
				break;

		} else {
			tgt = tok;
			break;
		}
	}
	if (tgt != 0)
		return tgt;

	return check_parms(&parm);
#undef DELIMS
#undef PARS
#undef PARSE
}


/* check for duplicate parameter specifications */
char *					/* 0 or error message */
check_parms(struct parm *new)
{
	struct parm *parmp;


	/* set implicit values
	 */
	if (!supplier && supplier_set)
		new->parm_int_state |= (IS_NO_RIPV1_OUT
					| IS_NO_RIPV2_OUT
					| IS_NO_ADV_OUT);
	if (new->parm_int_state & IS_NO_ADV_IN)
		new->parm_int_state |= IS_NO_SOL_OUT;

	if ((new->parm_int_state & (IS_NO_RIP | IS_NO_RDISC))
	    == (IS_NO_RIP | IS_NO_RDISC))
		new->parm_int_state |= IS_PASSIVE;

	/* compare with existing sets of parameters
	 */
	for (parmp = parms; parmp != 0; parmp = parmp->parm_next) {
		if (strcmp(new->parm_name, parmp->parm_name))
			continue;
		if (!on_net(htonl(parmp->parm_addr_h),
			    new->parm_addr_h, new->parm_mask)
		    && !on_net(htonl(new->parm_addr_h),
			       parmp->parm_addr_h, parmp->parm_mask))
			continue;

		if (strcmp(parmp->parm_passwd, new->parm_passwd)
		    || (0 != (new->parm_int_state & GROUP_IS_SOL)
			&& 0 != (parmp->parm_int_state & GROUP_IS_SOL)
			&& 0 != ((new->parm_int_state ^ parmp->parm_int_state)
				 & GROUP_IS_SOL))
		    || (0 != (new->parm_int_state & GROUP_IS_ADV)
			&& 0 != (parmp->parm_int_state & GROUP_IS_ADV)
			&& 0 != ((new->parm_int_state ^ parmp->parm_int_state)
				 & GROUP_IS_ADV))
		    || (new->parm_rdisc_pref != 0
			&& parmp->parm_rdisc_pref != 0
			&& new->parm_rdisc_pref != parmp->parm_rdisc_pref)
		    || (new->parm_rdisc_int != 0
			&& parmp->parm_rdisc_int != 0
			&& new->parm_rdisc_int != parmp->parm_rdisc_int)
		    || (new->parm_d_metric != 0
			&& parmp->parm_d_metric != 0
			&& new->parm_d_metric != parmp->parm_d_metric))
			return "duplicate";
	}

	parmp = (struct parm*)malloc(sizeof(*parmp));
	bcopy(new, parmp, sizeof(*parmp));
	parmp->parm_next = parms;
	parms = parmp;

	return 0;
}


/* get a network number as a name or a number, with an optional "/xx"
 * netmask.
 */
int					/* 0=bad */
getnet(char *name,
       naddr *addrp,			/* network in host byte order */
       naddr *maskp)			/* masks are always in host order */
{
	int i;
	struct netent *np;
	naddr mask;			/* in host byte order */
	struct in_addr in;		/* a network and so host byte order */
	char hname[MAXHOSTNAMELEN+1];
	char *mname, *p;


	/* Detect and separate "1.2.3.4/24"
	 */
	if (0 != (mname = strrchr(name,'/'))) {
		i = (int)(mname - name);
		if (i > sizeof(hname)-1)	/* name too long */
			return 0;
		bcopy(name, hname, i);
		hname[i] = '\0';
		mname++;
		name = hname;
	}

	np = getnetbyname(name);
	if (np != 0) {
		in.s_addr = (naddr)np->n_net;
	} else if (inet_aton(name, &in) == 1) {
		NTOHL(in.s_addr);
	} else {
		return 0;
	}

	if (mname == 0) {
		/* we cannot use the interfaces here because we have not
		 * looked at them yet.
		 */
		mask = std_mask(htonl(in.s_addr));
		if ((~mask & in.s_addr) != 0)
			mask = HOST_MASK;
	} else {
		mask = (naddr)strtoul(mname, &p, 0);
		if (*p != '\0' || mask > 32)
			return 0;
		mask = HOST_MASK << (32-mask);
	}
	if (mask != 0 && in.s_addr == RIP_DEFAULT)
		return 0;
	if ((~mask & in.s_addr) != 0)
		return 0;

	*addrp = in.s_addr;
	*maskp = mask;
	return 1;
}


int					/* 0=bad */
gethost(char *name,
	naddr *addrp)
{
	struct hostent *hp;
	struct in_addr in;


	/* Try for a number first, even in IRIX where gethostbyname()
	 * is smart.  This avoids hitting the name server which
	 * might be sick because routing is.
	 */
	if (inet_aton(name, &in) == 1) {
		*addrp = in.s_addr;
		return 1;
	}

	hp = gethostbyname(name);
	if (hp) {
		bcopy(hp->h_addr, addrp, sizeof(*addrp));
		return 1;
	}

	return 0;
}
@


1.15
log
@Change hard coded numbers to sizeof(buf).  Also change some
sizeof(buf) - 1 to sizeof(buf), since fgets takes the whole buffer size.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.14 2006/10/24 19:44:29 moritz Exp $	*/
@


1.14
log
@Ignore NUL lines returned by fgets(3), so we don't
access one byte before the lbuf buffer.

OK cloder@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.13 2005/04/12 15:26:47 cloder Exp $	*/
d148 1
a148 1
		if (fgets(lbuf, sizeof(lbuf)-1, fp) == NULL)
@


1.13
log
@A little bit of cleanup (missing format string arguments, some signed/
unsigned conversion). OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.12 2004/03/14 22:21:31 tedu Exp $	*/
d148 1
a148 1
		if (0 == fgets(lbuf, sizeof(lbuf)-1, fp))
d153 2
a154 2
		if (*lptr == '\n'	/* ignore null and comment lines */
		    || *lptr == '#')
@


1.12
log
@fd and mem leak, most of patch from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.11 2004/03/11 08:39:48 otto Exp $	*/
d206 1
a206 1
			       " entry \"%s\"", lptr);
@


1.11
log
@Fix byte ordering problems with network info read from /etc/gateways
or -P and -F options. Based on NetBSD. Resolves PR 3704.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.10 2003/06/02 20:06:17 millert Exp $	*/
d144 1
a144 1
	if (fp == 0)
d323 1
d345 2
d353 2
a354 1
			    || intnetp->intnet_metric >= HOPCNT_INFINITY)
d356 1
d368 1
a368 1
		return 0;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.9 2003/04/03 18:04:03 deraadt Exp $	*/
a141 2
	struct parm *parmp;

d203 1
a272 9
		parmp = (struct parm*)malloc(sizeof(*parmp));
		bzero(parmp, sizeof(*parmp));
		parmp->parm_next = parms;
		parms = parmp;
		parmp->parm_addr_h = ntohl(dst);
		parmp->parm_mask = -1;
		parmp->parm_d_metric = 0;
		parmp->parm_int_state = state;

d360 1
d538 2
a539 2
       naddr *addrp,			/* host byte order */
       naddr *maskp)
d543 2
a544 2
	naddr mask;
	struct in_addr in;
d565 1
a565 1
		HTONL(in.s_addr);
d574 2
a575 2
		mask = std_mask(in.s_addr);
		if ((~mask & ntohl(in.s_addr)) != 0)
d585 1
a585 1
	if ((~mask & ntohl(in.s_addr)) != 0)
@


1.9
log
@trivial snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.8 2003/03/13 09:09:27 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.7 2002/08/08 14:00:24 aaron Exp $	*/
d329 2
a330 1
		(void)sprintf(ifp->int_name, "%s-%s", type, naddr_ntoa(dst));
@


1.7
log
@Use & to test if bits are set, not &&; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.6 1997/07/30 23:28:43 deraadt Exp $	*/
d389 1
a389 1
			strcpy(parm.parm_name, tok+3);
d395 2
a396 1
			strcpy(parm.parm_passwd, tok+7);
@


1.6
log
@new routed DOES NOT EVEN COMPILE LET ALONE WORK.  TEST YOUR WORK!
Also, put back the damn security check in input.c that has been deleted
TWO SEPERATE TIMES NOW!  I CURSE anyone who deletes that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parms.c,v 1.4 1997/01/17 07:12:22 millert Exp $	*/
d518 1
a518 1
				 && GROUP_IS_SOL))
d522 1
a522 1
				 && GROUP_IS_ADV))
@


1.5
log
@update to sgi-02apr97
still have problems w/ defaults from pppd
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
a41 1
#include <sys/stat.h>
a45 1
struct tgate *tgates;
a52 1
	static warned_auth_in, warned_auth_out;
a53 1
	int i, num_passwds = 0;
d58 6
a63 7
		if (parmp->parm_name[0] == '\0'
		    || !strcmp(ifp->int_name, parmp->parm_name)
		    || (parmp->parm_name[0] == '\n'
			&& on_net(ifp->int_addr,
				  parmp->parm_net, parmp->parm_mask))) {

			/* This group of parameters is relevant,
d67 3
a69 8
			for (i = 0; i < MAX_AUTH_KEYS; i++) {
				if (parmp->parm_auth[0].type == RIP_AUTH_NONE
				    || num_passwds >= MAX_AUTH_KEYS)
					break;
				bcopy(&parmp->parm_auth[i],
				      &ifp->int_auth[num_passwds++],
				      sizeof(ifp->int_auth[0]));
			}
d76 1
a76 1
		}
d78 2
a79 6

	/* Set general defaults.
	 *
	 * Default poor-man's router discovery to a metric that will
	 * be heard by old versions of `routed`.  They ignored received
	 * routes with metric 15.
d83 4
a86 1
		ifp->int_d_metric = FAKE_METRIC;
d92 4
a95 1
	    && !(ifp->int_state & IS_REMOTE))
d112 4
a115 21
		ifp->int_state |= IS_NO_RIP;

	if (!IS_RIP_IN_OFF(ifp->int_state)
	    && ifp->int_auth[0].type != RIP_AUTH_NONE
	    && !(ifp->int_state & IS_NO_RIPV1_IN)
	    && !warned_auth_in) {
		msglog("Warning: RIPv1 input via %s"
		       " will be accepted without authentication",
		       ifp->int_name);
		warned_auth_in = 1;
	}
	if (!IS_RIP_OUT_OFF(ifp->int_state)
	    && ifp->int_auth[0].type != RIP_AUTH_NONE
	    && !(ifp->int_state & IS_NO_RIPV1_OUT)) {
		if (!warned_auth_out) {
			msglog("Warning: RIPv1 output via %s"
			       " will be sent without authentication",
			       ifp->int_name);
			warned_auth_out = 1;
		}
	}
a143 1
	struct stat sb;
d146 1
a152 6
	if (0 > fstat(fileno(fp), &sb)) {
		msglog("could not stat() "_PATH_GATEWAYS);
		(void)fclose(fp);
		return;
	}

d163 2
a164 1
		while (*p == '\n' || *p == ' ')
d171 1
a171 3
			p = parse_parms(lptr,
					(sb.st_uid == 0
					 && !(sb.st_mode&(S_IRWXG|S_IRWXO))));
d173 3
a175 3
				if (strcasecmp(p,lptr))
					msglog("%s in "_PATH_GATEWAYS
					       " entry \"%s\"", p, lptr);
a183 1
		qual[0] = '\0';
d185 1
a185 1
			   " %64[^ / \t] metric %u %8s\n",
d187 2
a188 3
		if (n != 4 && n != 5) {
			msglog("bad "_PATH_GATEWAYS" entry \"%s\"; %d values",
			       lptr, n);
d191 1
a191 1
		if (metric >= HOPCNT_INFINITY) {
d196 1
a196 1
		if (!strcasecmp(net_host, "host")) {
d203 1
a203 1
		} else if (!strcasecmp(net_host, "net")) {
a208 1
			HTONL(dst);	/* make network # into IP address */
d221 1
a221 1
		if (!strcasecmp(qual, type = "passive")) {
d232 1
a232 1
		} else if (!strcasecmp(qual, type = "external")) {
a237 1
			strcpy(qual,"external");
d242 1
a242 2
		} else if (!strcasecmp(qual, "active")
			   || qual[0] == '\0') {
d255 1
a255 1
				state = IS_REMOTE | IS_PASSIVE | IS_ALIAS;
d260 1
a260 2
			msglog("bad "_PATH_GATEWAYS" entry \"%s\";"
			       " unknown type %s", lptr, qual);
d264 6
d273 13
a285 1
			state |= IS_NO_RIP;
d287 11
a297 1
		ifp = check_dup(gate,dst,netmask,0);
d299 9
a307 1
			msglog("duplicate "_PATH_GATEWAYS" entry \"%s\"",lptr);
d311 2
d315 5
d322 2
d325 2
a326 4
			ifp->int_if_flags = IFF_POINTOPOINT | IFF_UP_RUNNING;
		else
			ifp->int_if_flags = IFF_UP_RUNNING;
		ifp->int_act_time = NEVER;
a327 7
		ifp->int_dstaddr = dst;
		ifp->int_mask = netmask;
		ifp->int_ripv1_mask = netmask;
		ifp->int_std_mask = std_mask(gate);
		ifp->int_net = ntohl(dst);
		ifp->int_std_net = ifp->int_net & ifp->int_std_mask;
		ifp->int_std_addr = htonl(ifp->int_std_net);
d329 1
a329 4
		if (!(state & IS_EXTERNAL)
		    && ifp->int_mask != ifp->int_std_mask)
			ifp->int_state |= IS_SUBNET;
		(void)sprintf(ifp->int_name, "%s(%s)", type, gname);
a331 7
		if_link(ifp);
	}

	/* After all of the parameter lines have been read,
	 * apply them to any remote interfaces.
	 */
	for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
a333 4
		tot_interfaces++;
		if (!IS_RIP_OFF(ifp->int_state))
			rip_interfaces++;

a335 2

	(void)fclose(fp);
d339 1
a339 183
/* strtok(), but honoring backslash
 */
static int				/* 0=ok, -1=bad */
parse_quote(char **linep,
	    char *delims,
	    char *delimp,
	    char *buf,
	    int	lim)
{
	char c, *pc, *p;


	pc = *linep;
	if (*pc == '\0')
		return -1;

	while (lim != 0) {
		c = *pc++;
		if (c == '\0')
			break;

		if (c == '\\' && pc != '\0') {
			if ((c = *pc++) == 'n') {
				c = '\n';
			} else if (c == 'r') {
				c = '\r';
			} else if (c == 't') {
				c = '\t';
			} else if (c == 'b') {
				c = '\b';
			} else if (c >= '0' && c <= '7') {
				c -= '0';
				if (*pc >= '0' && *pc <= '7') {
					c = (c<<3)+(*pc++ - '0');
					if (*pc >= '0' && *pc <= '7')
					    c = (c<<3)+(*pc++ - '0');
				}
			}

		} else {
			for (p = delims; *p != '\0'; ++p) {
				if (*p == c)
					goto exit;
			}
		}

		*buf++ = c;
		--lim;
	}
exit:
	if (lim == 0)
		return -1;

	*buf = '\0';
	if (delimp != 0)
		*delimp = c;
	*linep = pc-1;
	return 0;
}


/* Parse password timestamp
 */
static char *
parse_ts(time_t *tp,
	 char **valp,
	 char *val0,
	 char *delimp,
	 char *buf,
	 u_int bufsize)
{
	struct tm tm;

	if (0 > parse_quote(valp, "| ,\n\r", delimp,
			    buf,bufsize)
	    || buf[bufsize-1] != '\0'
	    || buf[bufsize-2] != '\0') {
		sprintf(buf,"bad timestamp %.25s", val0);
		return buf;
	}
	strcat(buf,"\n");
	bzero(&tm, sizeof(tm));
	if (5 != sscanf(buf, "%u/%u/%u@@%u:%u\n",
			&tm.tm_year, &tm.tm_mon, &tm.tm_mday,
			&tm.tm_hour, &tm.tm_min)) {
		sprintf(buf,"bad timestamp %.25s", val0);
		return buf;
	}
	if (tm.tm_year <= 37)
		tm.tm_year += 100;

	if ((*tp = mktime(&tm)) == -1) {
		sprintf(buf,"bad timestamp %.25s", val0);
		return buf;
	}

	return 0;
}


/* Get a password, key ID, and expiration date in the format
 *	passwd|keyID|year/mon/day@@hour:min|year/mon/day@@hour:min
 */
static char *				/* 0 or error message */
get_passwd(char *tgt,
	   char *val,
	   struct parm *parmp,
	   u_char type,
	   int safe)			/* 1=from secure file */
{
	static char buf[80];
	char *val0, *p, delim;
	struct auth k, *ap, *ap2;
	int i;
	u_long l;


	if (!safe)
		return "ignore unsafe password";

	for (ap = parmp->parm_auth, i = 0;
	     ap->type != RIP_AUTH_NONE; i++, ap++) {
		if (i >= MAX_AUTH_KEYS)
			return "too many passwords";
	}

	bzero(&k, sizeof(k));
	k.type = type;
	k.end = -1-DAY;

	val0 = val;
	if (0 > parse_quote(&val, "| ,\n\r", &delim,
			    (char *)k.key, sizeof(k.key)))
		return tgt;

	if (delim != '|') {
		if (type == RIP_AUTH_MD5)
			return "missing Keyid";
	} else {
		val0 = ++val;
		buf[sizeof(buf)-1] = '\0';
		if (0 > parse_quote(&val, "| ,\n\r", &delim, buf,sizeof(buf))
		    || buf[sizeof(buf)-1] != '\0'
		    || (l = strtoul(buf,&p,0)) > 255
		    || *p != '\0') {
			sprintf(buf,"bad KeyID \"%.20s\"", val0);
			return buf;
		}
		for (ap2 = parmp->parm_auth; ap2 < ap; ap2++) {
			if (ap2->keyid == l) {
				sprintf(buf,"duplicate KeyID \"%.20s\"", val0);
				return buf;
			}
		}
		k.keyid = (int)l;

		if (delim == '|') {
			val0 = ++val;
			if (0 != (p = parse_ts(&k.start,&val,val0,&delim,
					       buf,sizeof(buf))))
				return p;
			if (delim != '|')
				return "missing second timestamp";
			val0 = ++val;
			if (0 != (p = parse_ts(&k.end,&val,val0,&delim,
					       buf,sizeof(buf))))
				return p;
			if ((u_long)k.start > (u_long)k.end) {
				sprintf(buf,"out of order timestamp %.30s",
					val0);
				return buf;
			}
		}
	}
	if (delim != '\0')
		return tgt;

	bcopy(&k, ap, sizeof(*ap));
	return 0;
}


/* Parse a set of parameters for an interface.
d342 1
a342 2
parse_parms(char *line,
	    int safe)			/* 1=from secure file */
d344 2
a345 2
#define PARS(str) (!strcasecmp(tgt, str))
#define PARSEQ(str) (!strncasecmp(tgt, str"=", sizeof(str)))
d348 1
d351 1
a351 4
	struct tgate *tg;
	naddr addr, mask;
	char delim, *val0, *tgt, *val, *p;
	char buf[64];
d354 2
a355 3
	/* "subnet=x.y.z.u/mask,metric" must be alone on the line */
	if (!strncasecmp(line, "subnet=", sizeof("subnet=")-1)
	    && *(val = &line[sizeof("subnet=")-1]) != '\0') {
d358 1
a358 1
		if ((p = strrchr(val,','))) {
d366 2
a367 1
		if (!getnet(val, &intnetp->intnet_addr, &intnetp->intnet_mask)
a372 1
		HTONL(intnetp->intnet_addr);
d381 4
a384 17
	for (;;) {
		tgt = line + strspn(line, " ,\n\r");
		if (*tgt == '\0')
			break;

		line += strcspn(tgt, "= ,\n\r");
		delim = *line;
		if (delim == '=') {
			val0 = ++line;
			if (0 > parse_quote(&line," ,\n\r",&delim,
					    buf,sizeof(buf)))
				return tgt;
		}
		if (delim != '\0')
			*line++ = '\0';

		if (PARSEQ("if")) {
d386 10
a395 34
			    || strlen(buf) > IFNAMSIZ)
				return tgt;
			strcpy(parm.parm_name, buf);

		} else if (PARSEQ("addr")) {
			/* This is a bad idea, because the address based
			 * sets of parameters cannot be checked for
			 * consistency with the interface name parameters.
			 * The parm_net stuff is needed to allow several
			 * -F settings.
			 */
			if (!getnet(val0, &addr, &mask)
			    || parm.parm_name[0] != '\0')
				return tgt;
			parm.parm_net = addr;
			parm.parm_mask = mask;
			parm.parm_name[0] = '\n';

		} else if (PARSEQ("passwd")) {
			/* since cleartext passwords are so weak allow
			 * them anywhere
			 */
			tgt = get_passwd(tgt,val0,&parm,RIP_AUTH_PW,1);
			if (tgt) {
				*val0 = '\0';
				return tgt;
			}

		} else if (PARSEQ("md5_passwd")) {
			tgt = get_passwd(tgt,val0,&parm,RIP_AUTH_MD5,safe);
			if (tgt) {
				*val0 = '\0';
				return tgt;
			}
d411 1
a411 1
				return tgt;
a413 7
		} else if (PARS("ripv2")) {
			if ((parm.parm_int_state & IS_NO_RIPV2_OUT)
			    || (parm.parm_int_state & IS_NO_RIPV2_IN))
				return tgt;
			parm.parm_int_state |= (IS_NO_RIPV1_IN
						| IS_NO_RIPV1_OUT);

d415 1
a415 1
			CKF(IS_PM_RDISC, IS_NO_RIP);
d439 1
a439 1
		} else if (PARSEQ("rdisc_pref")) {
d441 3
a443 1
			    || (parm.parm_rdisc_pref = (int)strtoul(buf, &p,0),
d445 1
a445 1
				return tgt;
a447 2
			if (IS_RIP_OUT_OFF(parm.parm_int_state))
				return tgt;
d450 1
a450 1
		} else if (PARSEQ("rdisc_interval")) {
d452 3
a454 1
			    || (parm.parm_rdisc_int = (int)strtoul(buf,&p,0),
d458 1
a458 1
				return tgt;
d460 1
a460 1
		} else if (PARSEQ("fake_default")) {
d462 2
a463 2
			    || IS_RIP_OUT_OFF(parm.parm_int_state)
			    || (parm.parm_d_metric = (int)strtoul(buf,&p,0),
d466 1
a466 13
				return tgt;

		} else if (PARSEQ("trust_gateway")) {
			if (!gethost(buf,&addr))
				return tgt;
			tg = (struct tgate *)malloc(sizeof(*tg));
			tg->tgate_next = tgates;
			tg->tgate_addr = addr;
			tgates = tg;
			parm.parm_int_state |= IS_DISTRUST;

		} else if (PARS("redirect_ok")) {
			parm.parm_int_state |= IS_REDIRECT_OK;
d469 2
a470 1
			return tgt;	/* error */
d473 2
d477 1
d479 1
a479 1
#undef PARSEQ
d487 2
a488 2
	struct parm *parmp, **parmpp;
	int i, num_passwds;
d492 4
d499 3
a501 4
	for (i = num_passwds = 0; i < MAX_AUTH_KEYS; i++) {
		if (new->parm_auth[i].type != RIP_AUTH_NONE)
			num_passwds++;
	}
d505 1
a505 3
	for (parmpp = &parms;
	     (parmp = *parmpp) != 0;
	     parmpp = &parmp->parm_next) {
d508 4
a511 4
		if (!on_net(htonl(parmp->parm_net),
			    new->parm_net, new->parm_mask)
		    && !on_net(htonl(new->parm_net),
			       parmp->parm_net, parmp->parm_mask))
d514 5
a518 11
		for (i = 0; i < MAX_AUTH_KEYS; i++) {
			if (parmp->parm_auth[i].type != RIP_AUTH_NONE)
				num_passwds++;
		}
		if (num_passwds > MAX_AUTH_KEYS)
			return "too many conflicting passwords";

		if ((0 != (new->parm_int_state & GROUP_IS_SOL)
		     && 0 != (parmp->parm_int_state & GROUP_IS_SOL)
		     && 0 != ((new->parm_int_state ^ parmp->parm_int_state)
			      && GROUP_IS_SOL))
d528 5
a532 12
			&& new->parm_rdisc_int != parmp->parm_rdisc_int)) {
			return ("conflicting, duplicate router discovery"
				" parameters");

		}

		if (new->parm_d_metric != 0
		     && parmp->parm_d_metric != 0
		     && new->parm_d_metric != parmp->parm_d_metric) {
			return ("conflicting, duplicate poor man's router"
				" discovery or fake default metric");
		}
a534 3
	/* link new entry on the so that when the entries are scanned,
	 * they affect the result in the order the operator specified.
	 */
d537 2
a538 1
	*parmpp = parmp;
d549 2
a550 2
       naddr *netp,			/* a network so host byte order */
       naddr *maskp)			/* masks are always in host order */
d554 2
a555 2
	naddr mask;			/* in host byte order */
	struct in_addr in;		/* a network and so host byte order */
d576 1
a576 3
		NTOHL(in.s_addr);
	} else if (!mname && !strcasecmp(name,"default")) {
		in.s_addr = RIP_DEFAULT;
d581 1
a581 1
	if (!mname) {
d585 2
a586 2
		mask = std_mask(htonl(in.s_addr));
		if ((~mask & in.s_addr) != 0)
a593 2

	/* must have mask of 0 with default */
d596 1
a596 9
	/* no host bits allowed in a network number */
	if ((~mask & in.s_addr) != 0)
		return 0;
	/* require non-zero network number */
	if ((mask & in.s_addr) == 0 && in.s_addr != RIP_DEFAULT)
		return 0;
	if (in.s_addr>>24 == 0 && in.s_addr != RIP_DEFAULT)
		return 0;
	if (in.s_addr>>24 == 0xff)
d599 1
a599 1
	*netp = in.s_addr;
a617 6
		/* get a good number, but check that it it makes some
		 * sense.
		 */
		if (ntohl(in.s_addr)>>24 == 0
		    || ntohl(in.s_addr)>>24 == 0xff)
			return 0;
@


1.4
log
@r?index -> strr?chr
@
text
@d42 1
d47 1
d55 1
d57 1
d62 7
a68 6
		if ((parmp->parm_name[0] == '\0'
		     && on_net(ifp->int_addr,
			       parmp->parm_addr_h, parmp->parm_mask))
		    || (parmp->parm_name[0] != '\0'
			&& !strcmp(ifp->int_name, parmp->parm_name))) {
			/* this group of parameters is relevant,
d72 8
a79 3
			if (parmp->parm_passwd[0] != '\0')
				bcopy(parmp->parm_passwd, ifp->int_passwd,
				      sizeof(ifp->int_passwd));
d86 1
a86 1
			}
d88 6
a93 2
	/* default poor-man's router discovery to a metric that will
	 * be heard by old versions of routed.
d97 1
a97 4
		ifp->int_d_metric = HOPCNT_INFINITY-2;

	if (IS_RIP_IN_OFF(ifp->int_state))
		ifp->int_state |= IS_NO_RIP_OUT;
d103 1
a103 4
	    && !(ifp->int_if_flags & IFF_POINTOPOINT))
		ifp->int_state |= IS_NO_RIPV2_OUT;

	if (!(ifp->int_if_flags & IFF_MULTICAST))
d120 21
a140 4
		ifp->int_state |= (IS_NO_RIP | IS_NO_RDISC);
	if ((ifp->int_state & (IS_NO_RIP | IS_NO_RDISC))
	    == (IS_NO_RIP|IS_NO_RDISC))
		ifp->int_state |= IS_PASSIVE;
d169 1
a171 1
	struct parm *parmp;
d178 6
d194 1
a194 2
		while (*p == '\n'
		       || *p == ' ')
d201 3
a203 1
			p = parse_parms(lptr);
d205 3
a207 3
				if (strcmp(p,lptr))
					msglog("bad \"%s\" in "_PATH_GATEWAYS
					       " entry \"%s\"", lptr, p);
d216 1
d218 1
a218 1
			   " %64[^ / \t] metric %d %8s\n",
d220 3
a222 2
		if (n != 5) {
			msglog("bad "_PATH_GATEWAYS" entry \"%s\"", lptr);
d225 1
a225 1
		if (metric < 0 || metric >= HOPCNT_INFINITY) {
d230 1
a230 1
		if (!strcmp(net_host, "host")) {
d237 1
a237 1
		} else if (!strcmp(net_host, "net")) {
d243 1
d256 1
a256 1
		if (strcmp(qual, type = "passive") == 0) {
d267 1
a267 1
		} else if (strcmp(qual, type = "external") == 0) {
d273 1
d278 2
a279 1
		} else if (qual[0] == '\0') {
d292 1
a292 1
				state = IS_REMOTE | IS_PASSIVE;
d297 2
a298 1
			msglog("bad "_PATH_GATEWAYS" entry \"%s\"", lptr);
a301 6
		/* Remember to advertise the corresponding logical network.
		 */
		if (!(state & IS_EXTERNAL)
		    && netmask != std_mask(dst))
			state |= IS_SUBNET;

d305 1
a305 13
			state |= (IS_NO_RIP | IS_NO_RDISC);
		if ((state & (IS_NO_RIP | IS_NO_RDISC))
		    == (IS_NO_RIP|IS_NO_RDISC))
			state |= IS_PASSIVE;

		parmp = (struct parm*)malloc(sizeof(*parmp));
		bzero(parmp, sizeof(*parmp));
		parmp->parm_next = parms;
		parms = parmp;
		parmp->parm_addr_h = ntohl(dst);
		parmp->parm_mask = -1;
		parmp->parm_d_metric = 0;
		parmp->parm_int_state = state;
d307 1
a307 11
		/* See if this new interface duplicates an existing
		 * interface.
		 */
		for (ifp = ifnet; 0 != ifp; ifp = ifp->int_next) {
			if (ifp->int_mask == netmask
			    && ((ifp->int_addr == dst
				 && netmask != HOST_MASK)
				|| (ifp->int_dstaddr == dst
				    && netmask == HOST_MASK)))
				break;
		}
d309 1
a309 9
			/* Let one of our real interfaces be marked passive.
			 */
			if ((state & IS_PASSIVE) && !(state & IS_EXTERNAL)) {
				ifp->int_state |= state;
			} else {
				msglog("%s is duplicated in "_PATH_GATEWAYS
				       " by %s",
				       ifp->int_name, lptr);
			}
a312 2
		tot_interfaces++;

a314 5
		if (ifnet != 0) {
			ifp->int_next = ifnet;
			ifnet->int_prev = ifp;
		}
		ifnet = ifp;
a316 2
		ifp->int_net = ntohl(dst) & netmask;
		ifp->int_mask = netmask;
d318 5
a322 1
			ifp->int_if_flags |= IFF_POINTOPOINT;
d324 6
a329 1
		ifp->int_addr = gate;
d331 4
a334 1
		(void)sprintf(ifp->int_name, "%s-%s", type, naddr_ntoa(dst));
d337 7
d346 4
d352 2
d357 183
a539 1
/* parse a set of parameters for an interface
d542 2
a543 1
parse_parms(char *line)
d545 2
a546 2
#define PARS(str) (0 == (tgt = str, strcasecmp(tok, tgt)))
#define PARSE(str) (0 == (tgt = str, strncasecmp(tok, str "=", sizeof(str))))
a548 1
#define DELIMS " ,\t\n"
d551 4
a554 1
	char *tok, *tgt, *p;
d557 3
a559 2
	/* "subnet=x.y.z.u/mask" must be alone on the line */
	if (!strncasecmp("subnet=",line,7)) {
d562 1
a562 1
		if ((p = strrchr(line,','))) {
d570 1
a570 2
		if (!getnet(&line[7], &intnetp->intnet_addr,
			    &intnetp->intnet_mask)
d576 1
d585 17
a601 4
	for (tok = strtok(line, DELIMS);
	     tok != 0 && tok[0] != '\0';
	     tgt = 0, tok = strtok(0,DELIMS)) {
		if (PARSE("if")) {
d603 34
a636 10
			    || tok[3] == '\0'
			    || strlen(tok) > IFNAMSIZ+3)
				break;
			strcpy(parm.parm_name, tok+3);

		} else if (PARSE("passwd")) {
			if (tok[7] == '\0'
			    || strlen(tok) > RIP_AUTH_PW_LEN+7)
				break;
			strcpy(parm.parm_passwd, tok+7);
d652 1
a652 1
				break;
d655 7
d663 1
a663 1
			parm.parm_int_state |= IS_NO_RIP;
d687 1
a687 1
		} else if (PARSE("rdisc_pref")) {
d689 1
a689 3
			    || tok[11] == '\0'
			    || (parm.parm_rdisc_pref = (int)strtol(&tok[11],
								   &p,0),
d691 1
a691 1
				break;
d694 2
d698 1
a698 1
		} else if (PARSE("rdisc_interval")) {
d700 1
a700 3
			    || tok[15] == '\0'
			    || (parm.parm_rdisc_int = (int)strtol(&tok[15],
								  &p,0),
d704 1
a704 1
				break;
d706 1
a706 1
		} else if (PARSE("fake_default")) {
d708 2
a709 2
			    || tok[13] == '\0'
			    || (parm.parm_d_metric=(int)strtol(&tok[13],&p,0),
d712 13
a724 1
				break;
d727 1
a727 2
			tgt = tok;
			break;
a729 2
	if (tgt != 0)
		return tgt;
a731 1
#undef DELIMS
d733 1
a733 1
#undef PARSE
d741 2
a742 2
	struct parm *parmp;

a745 4
	if (!supplier && supplier_set)
		new->parm_int_state |= (IS_NO_RIPV1_OUT
					| IS_NO_RIPV2_OUT
					| IS_NO_ADV_OUT);
d749 4
a752 3
	if ((new->parm_int_state & (IS_NO_RIP | IS_NO_RDISC))
	    == (IS_NO_RIP | IS_NO_RDISC))
		new->parm_int_state |= IS_PASSIVE;
d756 3
a758 1
	for (parmp = parms; parmp != 0; parmp = parmp->parm_next) {
d761 4
a764 4
		if (!on_net(htonl(parmp->parm_addr_h),
			    new->parm_addr_h, new->parm_mask)
		    && !on_net(htonl(new->parm_addr_h),
			       parmp->parm_addr_h, parmp->parm_mask))
d767 11
a777 5
		if (strcmp(parmp->parm_passwd, new->parm_passwd)
		    || (0 != (new->parm_int_state & GROUP_IS_SOL)
			&& 0 != (parmp->parm_int_state & GROUP_IS_SOL)
			&& 0 != ((new->parm_int_state ^ parmp->parm_int_state)
				 && GROUP_IS_SOL))
d787 12
a798 5
			&& new->parm_rdisc_int != parmp->parm_rdisc_int)
		    || (new->parm_d_metric != 0
			&& parmp->parm_d_metric != 0
			&& new->parm_d_metric != parmp->parm_d_metric))
			return "duplicate";
d801 3
d806 1
a806 2
	parmp->parm_next = parms;
	parms = parmp;
d817 2
a818 2
       naddr *addrp,			/* host byte order */
       naddr *maskp)
d822 2
a823 2
	naddr mask;
	struct in_addr in;
d844 3
a846 1
		HTONL(in.s_addr);
d851 1
a851 1
	if (mname == 0) {
d855 2
a856 2
		mask = std_mask(in.s_addr);
		if ((~mask & ntohl(in.s_addr)) != 0)
d864 2
d868 9
a876 1
	if ((~mask & ntohl(in.s_addr)) != 0)
d879 1
a879 1
	*addrp = in.s_addr;
d898 6
@


1.3
log
@update to the latest version from Sep 12.
@
text
@d562 1
a562 1
	if (0 != (mname = rindex(name,'/'))) {
@


1.2
log
@Fix OpenBSD tags
@
text
@a475 7
	if (parm.parm_int_state & IS_NO_ADV_IN)
		parm.parm_int_state |= IS_NO_SOL_OUT;

	if ((parm.parm_int_state & (IS_NO_RIP | IS_NO_RDISC))
	    == (IS_NO_RIP | IS_NO_RDISC))
		parm.parm_int_state |= IS_PASSIVE;

d490 15
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
@


1.1.1.1
log
@new routed from SGI.
rip1, rip2, icmp, rdisc.
@
text
@@
