head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.6
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.4
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.2
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.03.17.20.55.35;	author jca;	state Exp;
branches;
next	1.34;
commitid	7kEboGGTHwBL47tj;

1.34
date	2015.07.19.17.41.49;	author martynas;	state Exp;
branches;
next	1.33;
commitid	SO80DjoceWaac0xy;

1.33
date	2014.05.03.16.13.03;	author martynas;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.06.19.04.50;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2012.12.05.23.19.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.06.00.02.42;	author martynas;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.25.21.46.49;	author martynas;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.28.18.05.39;	author martynas;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.14.11.16.15;	author martynas;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.25.11.38.09;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.08.23.09.50;	author martynas;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.11.12.08.27;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.09.20.02.02;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.09.20.42.55;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.07.20.36.07;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.24.09.41.58;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.24.09.35.30;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.22.16.01.46;	author martynas;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.21.20.50.54;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.16.15.01.19;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.11.21.16.43;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.12.07.26.07;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.12.06.43.31;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.05.20.10.25;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.13.00.35.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.17.20.07.40;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.06.20.36.23;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.26.22.40.27;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.26.22.27.14;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.26.01.49.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.01.22.27.13;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	98.03.02.23.58.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.09.21.10.45.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Remove #ifdef __vax__ bits

ok deraadt@@ tb@@ (who had the same diff)
@
text
@/*	$OpenBSD: math.h,v 1.34 2015/07/19 17:41:49 martynas Exp $	*/
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * from: @@(#)fdlibm.h 5.1 93/09/24
 */

#ifndef _MATH_H_
#define _MATH_H_

#include <sys/_types.h>
#include <sys/limits.h>

__BEGIN_DECLS
/*
 * ANSI/POSIX
 */
extern char __infinity[];
#if __GNUC_PREREQ__(3, 3)
#define HUGE_VAL	__builtin_huge_val()
#else /* __GNUC_PREREQ__(3, 3) */
#define HUGE_VAL	(*(double *)(void *)__infinity)
#endif /* __GNUC_PREREQ__(3, 3) */

/*
 * C99
 */
#if __ISO_C_VISIBLE >= 1999
typedef	__double_t	double_t;
typedef	__float_t	float_t;

#if __GNUC_PREREQ__(3, 3)
#define	HUGE_VALF	__builtin_huge_valf()
#define	HUGE_VALL	__builtin_huge_vall()
#define	INFINITY	__builtin_inff()
#define	NAN		__builtin_nanf("")
#else /* __GNUC_PREREQ__(3, 3) */
#define	HUGE_VALF	((float)HUGE_VAL)
#define	HUGE_VALL	((long double)HUGE_VAL)
#define	INFINITY	HUGE_VALF
extern char __nan[];
#define	NAN		(*(float *)(void *)__nan)
#endif /* __GNUC_PREREQ__(3, 3) */

#define	FP_INFINITE	0x01
#define	FP_NAN		0x02
#define	FP_NORMAL	0x04
#define	FP_SUBNORMAL	0x08
#define	FP_ZERO		0x10

#define FP_ILOGB0	(-INT_MAX)
#define FP_ILOGBNAN	INT_MAX

#ifdef	__FP_FAST_FMA
#define	FP_FAST_FMA	1
#endif	/* __FP_FAST_FMA */

#ifdef	__FP_FAST_FMAF
#define	FP_FAST_FMAF	1
#endif	/* __FP_FAST_FMAF */

#ifdef	__FP_FAST_FMAL
#define	FP_FAST_FMAL	1
#endif	/* __FP_FAST_FMAL */

#define	MATH_ERRNO	1
#define	MATH_ERREXCEPT	2
#define	math_errhandling	MATH_ERREXCEPT

#define fpclassify(x) \
	((sizeof (x) == sizeof (float)) ? \
		__fpclassifyf(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__fpclassify(x) \
	:	__fpclassifyl(x))
#define isfinite(x) \
	((sizeof (x) == sizeof (float)) ? \
		__isfinitef(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__isfinite(x) \
	:	__isfinitel(x))
#define isnormal(x) \
	((sizeof (x) == sizeof (float)) ? \
		__isnormalf(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__isnormal(x) \
	:	__isnormall(x))
#define signbit(x) \
	((sizeof (x) == sizeof (float)) ? \
		__signbitf(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__signbit(x) \
	:	__signbitl(x))

#define	isgreater(x, y)		(!isunordered((x), (y)) && (x) > (y))
#define	isgreaterequal(x, y)	(!isunordered((x), (y)) && (x) >= (y))
#define	isless(x, y)		(!isunordered((x), (y)) && (x) < (y))
#define	islessequal(x, y)	(!isunordered((x), (y)) && (x) <= (y))
#define	islessgreater(x, y)	(!isunordered((x), (y)) && \
					((x) > (y) || (y) > (x)))
#define	isunordered(x, y)	(isnan(x) || isnan(y))
#endif /* __ISO_C_VISIBLE >= 1999 */

#define isinf(x) \
	((sizeof (x) == sizeof (float)) ? \
		__isinff(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__isinf(x) \
	:	__isinfl(x))
#define isnan(x) \
	((sizeof (x) == sizeof (float)) ? \
		__isnanf(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__isnan(x) \
	:	__isnanl(x))

/*
 * XOPEN/SVID
 */
#if __BSD_VISIBLE || __XPG_VISIBLE
#define	M_E		((double)2.7182818284590452354)  /* e */
#define	M_LOG2E		((double)1.4426950408889634074)  /* log 2e */
#define	M_LOG10E	((double)0.43429448190325182765) /* log 10e */
#define	M_LN2		((double)0.69314718055994530942) /* log e2 */
#define	M_LN10		((double)2.30258509299404568402) /* log e10 */
#define	M_PI		((double)3.14159265358979323846) /* pi */
#define	M_PI_2		((double)1.57079632679489661923) /* pi/2 */
#define	M_PI_4		((double)0.78539816339744830962) /* pi/4 */
#define	M_1_PI		((double)0.31830988618379067154) /* 1/pi */
#define	M_2_PI		((double)0.63661977236758134308) /* 2/pi */
#define	M_2_SQRTPI	((double)1.12837916709551257390) /* 2/sqrt(pi) */
#define	M_SQRT2		((double)1.41421356237309504880) /* sqrt(2) */
#define	M_SQRT1_2	((double)0.70710678118654752440) /* 1/sqrt(2) */

#define	MAXFLOAT	((float)3.40282346638528860e+38)

extern int signgam;
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */

#if __POSIX_VISIBLE >= 201403
#define	M_El		2.718281828459045235360287471352662498L /* e */
#define	M_LOG2El	1.442695040888963407359924681001892137L /* log 2e */
#define	M_LOG10El	0.434294481903251827651128918916605082L /* log 10e */
#define	M_LN2l		0.693147180559945309417232121458176568L /* log e2 */
#define	M_LN10l		2.302585092994045684017991454684364208L /* log e10 */
#define	M_PIl		3.141592653589793238462643383279502884L /* pi */
#define	M_PI_2l		1.570796326794896619231321691639751442L /* pi/2 */
#define	M_PI_4l		0.785398163397448309615660845819875721L /* pi/4 */
#define	M_1_PIl		0.318309886183790671537767526745028724L /* 1/pi */
#define	M_2_PIl		0.636619772367581343075535053490057448L /* 2/pi */
#define	M_2_SQRTPIl	1.128379167095512573896158903121545172L /* 2/sqrt(pi) */
#define	M_SQRT2l	1.414213562373095048801688724209698079L /* sqrt(2) */
#define	M_SQRT1_2l	0.707106781186547524400844362104849039L /* 1/sqrt(2) */
#endif /* __POSIX_VISIBLE >= 201403 */

#if __BSD_VISIBLE
#define	HUGE		MAXFLOAT
#endif /* __BSD_VISIBLE */

/*
 * ANSI/POSIX
 */
double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double cos(double);
double sin(double);
double tan(double);

double cosh(double);
double sinh(double);
double tanh(double);

double exp(double);
double frexp(double, int *);
double ldexp(double, int);
double log(double);
double log10(double);
double modf(double, double *);

double pow(double, double);
double sqrt(double);

double ceil(double);
double fabs(double);
double floor(double);
double fmod(double, double);

/*
 * C99
 */
#if __BSD_VISIBLE || __ISO_C_VISIBLE >= 1999 || __XPG_VISIBLE
double acosh(double);
double asinh(double);
double atanh(double);

double exp2(double);
double expm1(double);
int ilogb(double);
double log1p(double);
double log2(double);
double logb(double);
double scalbn(double, int);
double scalbln(double, long int);

double cbrt(double);
double hypot(double, double);

double erf(double);
double erfc(double);
double lgamma(double);
double tgamma(double);

double nearbyint(double);
double rint(double);
long int lrint(double);
long long int llrint(double);
double round(double);
long int lround(double);
long long int llround(double);
double trunc(double);

double remainder(double, double);
double remquo(double, double, int *);

double copysign(double, double);
double nan(const char *);
double nextafter(double, double);
double nexttoward(double, long double);

double fdim(double, double);
double fmax(double, double);
double fmin(double, double);

double fma(double, double, double);
#endif /* __BSD_VISIBLE || __ISO_C_VISIBLE >= 1999 || __XPG_VISIBLE */

#if __BSD_VISIBLE || __XPG_VISIBLE
double j0(double);
double j1(double);
double jn(int, double);
double scalb(double, double);
double y0(double);
double y1(double);
double yn(int, double);
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */

#if __BSD_VISIBLE || __XPG_VISIBLE <= 500
double gamma(double);
#endif /* __BSD_VISIBLE || __XPG_VISIBLE <= 500 */

/*
 * BSD math library entry points
 */
#if __BSD_VISIBLE
double drem(double, double);
int finite(double);

/*
 * Reentrant version of gamma & lgamma; passes signgam back by reference
 * as the second argument; user must allocate space for signgam.
 */
double gamma_r(double, int *);
double lgamma_r(double, int *);

/*
 * IEEE Test Vector
 */
double significand(double);
#endif /* __BSD_VISIBLE */

/*
 * Float versions of C99 functions
 */
#if __ISO_C_VISIBLE >= 1999
float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float cosf(float);
float sinf(float);
float tanf(float);

float acoshf(float);
float asinhf(float);
float atanhf(float);
float coshf(float);
float sinhf(float);
float tanhf(float);

float expf(float);
float exp2f(float);
float expm1f(float);
float frexpf(float, int *);
int ilogbf(float);
float ldexpf(float, int);
float logf(float);
float log10f(float);
float log1pf(float);
float log2f(float);
float logbf(float);
float modff(float, float *);
float scalbnf(float, int);
float scalblnf(float, long int);

float cbrtf(float);
float fabsf(float);
float hypotf(float, float);
float powf(float, float);
float sqrtf(float);

float erff(float);
float erfcf(float);
float lgammaf(float);
float tgammaf(float);

float ceilf(float);
float floorf(float);
float nearbyintf(float);
float rintf(float);
long int lrintf(float);
long long int llrintf(float);
float roundf(float);
long int lroundf(float);
long long int llroundf(float);
float truncf(float);

float fmodf(float, float);
float remainderf(float, float);
float remquof(float, float, int *);

float copysignf(float, float);
float nanf(const char *);
float nextafterf(float, float);
float nexttowardf(float, long double);

float fdimf(float, float);
float fmaxf(float, float);
float fminf(float, float);

float fmaf(float, float, float);
#endif /* __ISO_C_VISIBLE >= 1999 */

#if __BSD_VISIBLE || __XPG_VISIBLE
float j0f(float);
float j1f(float);
float jnf(int, float);
float scalbf(float, float);
float y0f(float);
float y1f(float);
float ynf(int, float);
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */

#if __BSD_VISIBLE || __XPG_VISIBLE <= 500
float gammaf(float);
#endif /* __BSD_VISIBLE || __XPG_VISIBLE <= 500 */

/*
 * Float versions of BSD math library entry points
 */
#if __BSD_VISIBLE
float dremf(float, float);
int finitef(float);
int isinff(float);
int isnanf(float);

/*
 * Float versions of reentrant version of gamma & lgamma; passes
 * signgam back by reference as the second argument; user must
 * allocate space for signgam.
 */
float gammaf_r(float, int *);
float lgammaf_r(float, int *);

/*
 * Float version of IEEE Test Vector
 */
float significandf(float);
#endif /* __BSD_VISIBLE */

/*
 * Long double versions of C99 functions
 */
#if __ISO_C_VISIBLE >= 1999
long double acosl(long double);
long double asinl(long double);
long double atanl(long double);
long double atan2l(long double, long double);
long double cosl(long double);
long double sinl(long double);
long double tanl(long double);

long double acoshl(long double);
long double asinhl(long double);
long double atanhl(long double);
long double coshl(long double);
long double sinhl(long double);
long double tanhl(long double);

long double expl(long double);
long double exp2l(long double);
long double expm1l(long double);
long double frexpl(long double, int *);
int ilogbl(long double);
long double ldexpl(long double, int);
long double logl(long double);
long double log10l(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long double modfl(long double, long double *);
long double scalbnl(long double, int);
long double scalblnl(long double, long int);

long double cbrtl(long double);
long double fabsl(long double);
long double hypotl(long double, long double);
long double powl(long double, long double);
long double sqrtl(long double);

long double erfl(long double);
long double erfcl(long double);
long double lgammal(long double);
long double tgammal(long double);

long double ceill(long double);
long double floorl(long double);
long double nearbyintl(long double);
long double rintl(long double);
long int lrintl(long double);
long long int llrintl(long double);
long double roundl(long double);
long int lroundl(long double);
long long int llroundl(long double);
long double truncl(long double);

long double fmodl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int *);

long double copysignl(long double, long double);
long double nanl(const char *);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);

long double fdiml(long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);

long double fmal(long double, long double, long double);
#endif /* __ISO_C_VISIBLE >= 1999 */

/*
 * Library implementation
 */
int __fpclassify(double);
int __fpclassifyf(float);
int __fpclassifyl(long double);
int __isfinite(double);
int __isfinitef(float);
int __isfinitel(long double);
int __isinf(double);
int __isinff(float);
int __isinfl(long double);
int __isnan(double);
int __isnanf(float);
int __isnanl(long double);
int __isnormal(double);
int __isnormalf(float);
int __isnormall(long double);
int __signbit(double);
int __signbitf(float);
int __signbitl(long double);
__END_DECLS

#endif /* !_MATH_H_ */
@


1.34
log
@Define new C99 macros:
- MATH_ERRNO, MATH_ERREXCEPTION and math_errhandling
- Optional FP_FAST_FMA{,F,L} macros if fma() executes as fast or faster
than (x * y) + z;  which in practice is achievable if gcc implements
__FP_FAST_FMA{,F,L}
Reported by John Marino @@ DragonFlyBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.33 2014/05/03 16:13:03 martynas Exp $	*/
d28 1
a28 1
#if __GNUC_PREREQ__(3, 3) && !defined(__vax__)
d30 1
a30 1
#else /* __GNUC_PREREQ__(3, 3) && !__vax__ */
d32 1
a32 1
#endif /* __GNUC_PREREQ__(3, 3) && !__vax__ */
d41 1
a41 1
#if __GNUC_PREREQ__(3, 3) && !defined(__vax__)
d46 1
a46 5
#else /* __GNUC_PREREQ__(3, 3) && !__vax__ */
#ifdef __vax__
extern char __infinityf[];
#define	HUGE_VALF	(*(float *)(void *)__infinityf)
#else /* __vax__ */
a47 1
#endif /* __vax__ */
a49 1
#ifndef __vax__
d52 1
a52 2
#endif /* !__vax__ */
#endif /* __GNUC_PREREQ__(3, 3) && !__vax__ */
a143 3
#ifdef __vax__
#define	MAXFLOAT	((float)1.70141173319264430e+38)
#else
a144 1
#endif /* __vax__ */
a483 4

#if __BSD_VISIBLE && defined(__vax__)
double infnan(int);
#endif /* __BSD_VISIBLE && defined(__vax__) */
@


1.33
log
@- Provide extended-precision math constants req'd by POSIX
- Explicitly cast double-precision constants as needed for
FLT_EVAL_METHOD = 2 archs
OK guenther@@, ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.32 2013/08/06 19:04:50 miod Exp $	*/
d69 16
@


1.32
log
@Try and avoid using __builtin_huge_val*() and __builtin_{inf,nan}* on vax
running gcc 3, for gcc will output a reserved operand for these.

ok martynas@@ matthew@@ espie@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.31 2012/12/05 23:19:57 deraadt Exp $	*/
d121 13
a133 13
#define	M_E		2.7182818284590452354	/* e */
#define	M_LOG2E		1.4426950408889634074	/* log 2e */
#define	M_LOG10E	0.43429448190325182765	/* log 10e */
#define	M_LN2		0.69314718055994530942	/* log e2 */
#define	M_LN10		2.30258509299404568402	/* log e10 */
#define	M_PI		3.14159265358979323846	/* pi */
#define	M_PI_2		1.57079632679489661923	/* pi/2 */
#define	M_PI_4		0.78539816339744830962	/* pi/4 */
#define	M_1_PI		0.31830988618379067154	/* 1/pi */
#define	M_2_PI		0.63661977236758134308	/* 2/pi */
#define	M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
#define	M_SQRT2		1.41421356237309504880	/* sqrt(2) */
#define	M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
d143 16
@


1.31
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.30 2011/07/06 00:02:42 martynas Exp $	*/
d28 1
a28 1
#if __GNUC_PREREQ__(3, 3)
d30 1
a30 1
#else /* __GNUC_PREREQ__(3, 3) */
d32 1
a32 1
#endif /* __GNUC_PREREQ__(3, 3) */
d41 1
a41 1
#if __GNUC_PREREQ__(3, 3)
d46 1
a46 1
#else /* __GNUC_PREREQ__(3, 3) */
d59 1
a59 1
#endif /* __GNUC_PREREQ__(3, 3) */
@


1.30
log
@Finalize work on the math library.  It's time to do this monster
commit, and deal with problems (if any) in tree.

Note that this adds the following functions.  Ports with hacks might
need adjustments.

nexttoward(3), fma(3), nexttowardf(3), fmaf(3), acoshl(3), asinhl(3),
atanhl(3), coshl(3), sinhl(3), tanhl(3), expl(3), expm1l(3), logl(3),
log10l(3), log1pl(3), log2l(3), modfl(3), cbrtl(3), hypotl(3),
powl(3), erfl(3), erfcl(3), lgammal(3), tgammal(3), ceill(3),
floorl(3), lrintl(3), llrintl(3), roundl(3), lroundl(3), llroundl(3),
truncl(3), fmodl(3), remainderl(3), remquol(3), nextafterl(3),
nexttowardl(3), fmal(3).

With this commit, our library implements all functionality required
by C99.  Documentation bits will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.29 2011/05/25 21:46:49 martynas Exp $	*/
a20 1
#include <sys/cdefs.h>
@


1.29
log
@Also enclose variable names with external linkage in __BEGIN_DECLS.

Doesn't matter much since C++ ABI used by GCC doesn't mangle variable
names;  however technically is required by Section 7.5 of the C++ spec.

Discussed with/OK guenther@@, matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.28 2011/04/28 18:05:39 martynas Exp $	*/
a218 1
#if 0
a219 1
#endif
a224 1
#if 0
a225 1
#endif
a324 1
#if 0
a325 1
#endif
a330 1
#if 0
a331 1
#endif
a382 1
#if 0
a388 1
#endif
a389 1
#if 0
a390 1
#endif
a391 1
#if 0
a392 1
#endif
a395 1
#if 0
a399 1
#endif
a400 1
#if 0
a401 1
#endif
a404 1
#if 0
a405 1
#endif
a406 1
#if 0
a408 1
#endif
a410 1
#if 0
a414 1
#endif
a415 1
#if 0
a417 1
#endif
a419 1
#if 0
a425 1
#endif
a426 1
#if 0
a429 1
#endif
a432 1
#if 0
a434 1
#endif
a439 1
#if 0
a440 1
#endif
@


1.28
log
@- enable fenv
- add nearbyint, nearbyintf and nearbyintl implemented using fenv
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.27 2010/12/14 11:16:15 martynas Exp $	*/
d24 1
a148 1
__BEGIN_DECLS
@


1.27
log
@- make HUGE_VAL, HUGE_VALF, HUGE_VALL, INFINITY, NAN expand to the
constant expressions with the help of gcc post-3.3.
ok millert@@, mikeb@@.  been in snaps for weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.26 2009/07/25 11:38:09 martynas Exp $	*/
a203 1
#if 0
a204 1
#endif
a312 1
#if 0
a313 1
#endif
d443 1
a444 1
#endif
@


1.26
log
@int is big enough to fully represent exponents of all supported fp
formats.  which even for 80-bit & 128-bit long doubles is only 15
bits.  therefore, scalbln, scalblnf, scalblnl are essentially the
same as scalbn, scalbnf, scalbnl with bounds checking so that
LONG_MIN..INT_MIN, and INT_MAX..LONG_MAX ranges properly raise
exceptions & yield correct values.  looks good to millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.25 2009/04/08 23:09:50 martynas Exp $	*/
d28 3
d32 1
d41 6
d59 1
@


1.25
log
@nuke extern from func decls.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.24 2008/12/11 12:08:27 martynas Exp $	*/
a182 1
#if 0
a183 1
#endif
a288 1
#if 0
a289 1
#endif
a413 1
#if 0
a414 1
#endif
@


1.24
log
@add __infinityf declaration.  (only affects vax).  pointed out by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.23 2008/12/09 20:02:02 martynas Exp $	*/
d141 26
a166 26
extern double acos(double);
extern double asin(double);
extern double atan(double);
extern double atan2(double, double);
extern double cos(double);
extern double sin(double);
extern double tan(double);

extern double cosh(double);
extern double sinh(double);
extern double tanh(double);

extern double exp(double);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double log(double);
extern double log10(double);
extern double modf(double, double *);

extern double pow(double, double);
extern double sqrt(double);

extern double ceil(double);
extern double fabs(double);
extern double floor(double);
extern double fmod(double, double);
d172 3
a174 3
extern double acosh(double);
extern double asinh(double);
extern double atanh(double);
d176 7
a182 7
extern double exp2(double);
extern double expm1(double);
extern int ilogb(double);
extern double log1p(double);
extern double log2(double);
extern double logb(double);
extern double scalbn(double, int);
d184 1
a184 1
extern double scalbln(double, long int);
d187 2
a188 2
extern double cbrt(double);
extern double hypot(double, double);
d190 4
a193 4
extern double erf(double);
extern double erfc(double);
extern double lgamma(double);
extern double tgamma(double);
d196 1
a196 1
extern double nearbyint(double);
d198 7
a204 7
extern double rint(double);
extern long int lrint(double);
extern long long int llrint(double);
extern double round(double);
extern long int lround(double);
extern long long int llround(double);
extern double trunc(double);
d206 2
a207 2
extern double remainder(double, double);
extern double remquo(double, double, int *);
d209 3
a211 3
extern double copysign(double, double);
extern double nan(const char *);
extern double nextafter(double, double);
d213 1
a213 1
extern double nexttoward(double, long double);
d216 3
a218 3
extern double fdim(double, double);
extern double fmax(double, double);
extern double fmin(double, double);
d221 1
a221 1
extern double fma(double, double, double);
d226 7
a232 7
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double scalb(double, double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
d236 1
a236 1
extern double gamma(double);
d243 2
a244 2
extern double drem(double, double);
extern int finite(double);
d250 2
a251 2
extern double gamma_r(double, int *);
extern double lgamma_r(double, int *);
d256 1
a256 1
extern double significand(double);
d263 70
a332 70
extern float acosf(float);
extern float asinf(float);
extern float atanf(float);
extern float atan2f(float, float);
extern float cosf(float);
extern float sinf(float);
extern float tanf(float);

extern float acoshf(float);
extern float asinhf(float);
extern float atanhf(float);
extern float coshf(float);
extern float sinhf(float);
extern float tanhf(float);

extern float expf(float);
extern float exp2f(float);
extern float expm1f(float);
extern float frexpf(float, int *);
extern int ilogbf(float);
extern float ldexpf(float, int);
extern float logf(float);
extern float log10f(float);
extern float log1pf(float);
extern float log2f(float);
extern float logbf(float);
extern float modff(float, float *);
extern float scalbnf(float, int);
#if 0
extern float scalblnf(float, long int);
#endif

extern float cbrtf(float);
extern float fabsf(float);
extern float hypotf(float, float);
extern float powf(float, float);
extern float sqrtf(float);

extern float erff(float);
extern float erfcf(float);
extern float lgammaf(float);
extern float tgammaf(float);

extern float ceilf(float);
extern float floorf(float);
#if 0
extern float nearbyintf(float);
#endif
extern float rintf(float);
extern long int lrintf(float);
extern long long int llrintf(float);
extern float roundf(float);
extern long int lroundf(float);
extern long long int llroundf(float);
extern float truncf(float);

extern float fmodf(float, float);
extern float remainderf(float, float);
extern float remquof(float, float, int *);

extern float copysignf(float, float);
extern float nanf(const char *);
extern float nextafterf(float, float);
#if 0
extern float nexttowardf(float, long double);
#endif

extern float fdimf(float, float);
extern float fmaxf(float, float);
extern float fminf(float, float);
d335 1
a335 1
extern float fmaf(float, float, float);
d340 7
a346 7
extern float j0f(float);
extern float j1f(float);
extern float jnf(int, float);
extern float scalbf(float, float);
extern float y0f(float);
extern float y1f(float);
extern float ynf(int, float);
d350 1
a350 1
extern float gammaf(float);
d357 4
a360 4
extern float dremf(float, float);
extern int finitef(float);
extern int isinff(float);
extern int isnanf(float);
d367 2
a368 2
extern float gammaf_r(float, int *);
extern float lgammaf_r(float, int *);
d373 1
a373 1
extern float significandf(float);
d380 7
a386 7
extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
d389 6
a394 6
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
d398 1
a398 1
extern long double expl(long double);
d400 1
a400 1
extern long double exp2l(long double);
d402 1
a402 1
extern long double expm1l(long double);
d404 3
a406 3
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double ldexpl(long double, int);
d408 4
a411 4
extern long double logl(long double);
extern long double log10l(long double);
extern long double log1pl(long double);
extern long double log2l(long double);
d413 1
a413 1
extern long double logbl(long double);
d415 1
a415 1
extern long double modfl(long double, long double *);
d417 1
a417 1
extern long double scalbnl(long double, int);
d419 1
a419 1
extern long double scalblnl(long double, long int);
d423 1
a423 1
extern long double cbrtl(long double);
d425 1
a425 1
extern long double fabsl(long double);
d427 2
a428 2
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
d430 1
a430 1
extern long double sqrtl(long double);
d433 4
a436 4
extern long double erfl(long double);
extern long double erfcl(long double);
extern long double lgammal(long double);
extern long double tgammal(long double);
d440 3
a442 3
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
d444 1
a444 1
extern long double rintl(long double);
d446 6
a451 6
extern long int lrintl(long double);
extern long long int llrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);
extern long long int llroundl(long double);
extern long double truncl(long double);
d455 3
a457 3
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
d460 2
a461 2
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
d463 2
a464 2
extern long double nextafterl(long double, long double);
extern long double nexttowardl(long double, long double);
d467 3
a469 3
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
d472 1
a472 1
extern long double fmal(long double, long double, long double);
d479 18
a496 18
extern int __fpclassify(double);
extern int __fpclassifyf(float);
extern int __fpclassifyl(long double);
extern int __isfinite(double);
extern int __isfinitef(float);
extern int __isfinitel(long double);
extern int __isinf(double);
extern int __isinff(float);
extern int __isinfl(long double);
extern int __isnan(double);
extern int __isnanf(float);
extern int __isnanl(long double);
extern int __isnormal(double);
extern int __isnormalf(float);
extern int __isnormall(long double);
extern int __signbit(double);
extern int __signbitf(float);
extern int __signbitl(long double);
d499 1
a499 1
extern double infnan(int);
@


1.23
log
@expose extended-precision definitions.     ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.22 2008/09/09 20:42:55 martynas Exp $	*/
d38 1
@


1.22
log
@sigh, gamma got lost
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.21 2008/09/07 20:36:07 martynas Exp $	*/
d37 3
d41 1
d94 1
a94 1
		isinff(x) \
d100 1
a100 1
		isnanf(x) \
a378 1
#if 0
d387 1
d394 1
d396 1
d398 1
d400 1
d402 1
d406 1
d411 1
d413 1
d415 1
d417 1
d419 1
d421 1
d423 1
d425 1
d428 1
d431 1
d436 1
d438 1
d442 1
d444 1
d451 1
d453 1
d457 1
d461 1
d464 1
d470 1
d485 1
d488 1
@


1.21
log
@- replace dtoa w/ David's gdtoa, version 2008-03-15
- provide proper dtoa locks
- use the real strtof implementation
- add strtold, __hdtoa, __hldtoa
- add %a/%A support
- don't lose precision in printf, don't round to double anymore
- implement extended-precision versions of libc functions: fpclassify,
isnan, isinf, signbit, isnormal, isfinite, now that the ieee.h is
fixed
- separate vax versions of strtof, and __hdtoa
- add complex math support.  added functions: cacos, casin, catan,
ccos, csin, ctan, cacosh, casinh, catanh, ccosh, csinh, ctanh, cexp,
clog, cabs, cpow, csqrt, carg, cimag, conj, cproj, creal, cacosf,
casinf, catanf, ccosf, csinf, ctanf, cacoshf, casinhf, catanhf,
ccoshf, csinhf, ctanhf, cexpf, clogf, cabsf, cpowf, csqrtf, cargf,
cimagf, conjf, cprojf, crealf
- add fdim, fmax, fmin
- add log2. (adapted implementation e_log.c.  could be more acruate
& faster, but it's good enough for now)
- remove wrappers & cruft in libm, supposed to work-around mistakes
in SVID, etc.;  use ieee versions.  fixes issues in python 2.6 for
djm@@
- make _digittoint static
- proper definitions for i386, and amd64 in ieee.h
- sh, powerpc don't really have extended-precision
- add missing definitions for mips64 (quad), m{6,8}k (96-bit) float.h
for LDBL_*
- merge lead to frac for m{6,8}k, for gdtoa to work properly
- add FRAC*BITS & EXT_TO_ARRAY32 definitions in ieee.h, for hdtoa&ldtoa
to use
- add EXT_IMPLICIT_NBIT definition, which indicates implicit
normalization bit
- add regression tests for libc: fpclassify and printf
- arith.h & gd_qnan.h definitions
- update ieee.h: hppa doesn't have quad-precision, hppa64 does
- add missing prototypes to gdtoaimp
- on 64-bit platforms make sure gdtoa doesn't use a long when it
really wants an int
- etc., what i may have forgotten...
- bump libm major, due to removed&changed symbols
- no libc bump, since this is riding on djm's libc major crank from
a day ago

discussed with / requested by / testing theo, sthen@@, djm@@, jsg@@,
merdely@@, jsing@@, tedu@@, brad@@, jakemsr@@, and others.
looks good to millert@@
parts of the diff ok kettenis@@

this commit does not include:
- man page changes
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.20 2008/07/24 09:41:58 martynas Exp $	*/
a281 1
#if 0
a282 1
#endif
@


1.20
log
@unXXX prototypes: exp2, remquo, nan, exp2f, remquof, nanf
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.19 2008/07/24 09:35:30 martynas Exp $	*/
a65 12
#define isinf(x) \
	((sizeof (x) == sizeof (float)) ? \
		isinff(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__isinf(x) \
	:	__isinfl(x))
#define isnan(x) \
	((sizeof (x) == sizeof (float)) ? \
		isnanf(x) \
	: (sizeof (x) == sizeof (double)) ? \
		__isnan(x) \
	:	__isnanl(x))
d88 13
a128 29
enum fdversion {fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix};

#define _LIB_VERSION_TYPE enum fdversion
#define _LIB_VERSION _fdlib_version

/* if global variable _LIB_VERSION is not desirable, one may
 * change the following to be a constant by:
 *	#define _LIB_VERSION_TYPE const enum version
 * In that case, after one initializes the value _LIB_VERSION (see
 * s_lib_version.c) during compile time, it cannot be modified
 * in the middle of a program
 */
extern _LIB_VERSION_TYPE	_LIB_VERSION;

#define _IEEE_	fdlibm_ieee
#define _SVID_	fdlibm_svid
#define _XOPEN_	fdlibm_xopen
#define _POSIX_	fdlibm_posix

#ifndef __cplusplus
struct exception {
	int type;
	char *name;
	double arg1;
	double arg2;
	double retval;
};
#endif /* !__cplusplus */

a129 15

/*
 * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>
 * (one may replace the following line by "#include <values.h>")
 */

#define X_TLOSS		1.41484755040568800000e+16

#define	DOMAIN		1
#define	SING		2
#define	OVERFLOW	3
#define	UNDERFLOW	4
#define	TLOSS		5
#define	PLOSS		6

a174 1
#if 0
a175 1
#endif
a210 1
#if 0
a213 1
#endif
a247 4
#ifdef __LIBM_PRIVATE
extern int matherr(struct exception *);
#endif /* __LIBM_PRIVATE */

a326 1
#if 0
a329 1
#endif
@


1.19
log
@- add NAN definition (except on VAX)
- add C99 real-floating macros fpclassify isfinite isinf isnan
isnormal signbit
- add C99 macros isgreater isgreaterequal isless islessequal
islessgreater isunordered
- add function prototypes, __fpclassify __fpclassifyf __fpclassifyl
__isfinite __isfinitef __isfinitel __isinf __isinfl __isnan __isnanl
__isnormal __isnormalf __isnormall __signbit __signbitf __signbitl
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.18 2008/07/22 16:01:46 martynas Exp $	*/
a213 1
#if 0	/* XXX */
a214 1
#endif	/* XXX */
a246 1
#if 0	/* XXX */
a247 1
#endif	/* XXX */
a249 1
#if 0	/* XXX */
a250 1
#endif	/* XXX */
a324 1
#if 0	/* XXX */
a325 1
#endif	/* XXX */
a368 1
#if 0	/* XXX */
a369 1
#endif	/* XXX */
a371 1
#if 0	/* XXX */
a372 1
#endif	/* XXX */
@


1.18
log
@- added HUGE_VALF, HUGE_VALL, INFINITY, FP_INFINITE, FP_NAN,
FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_ILOGB0, FP_ILOGBNAN definitions,
per C99
- classify functions into sections, add missing definitions, add
and some '#if 0' functions, and long double definitions, so we see
what's needed to be done
- other stuff is XXX'd, and will be uncommented soon
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.17 2008/07/21 20:50:54 martynas Exp $	*/
d40 4
a43 3
#if 0	/* XXX */
#define	NAN		nan("")
#endif	/* XXX */
a53 1
#if 0	/* XXX */
a97 4
#else	/* XXX */
extern int isinf(double);
extern int isnan(double);
#endif	/* XXX */
a514 1
#if 0	/* XXX */
a530 1
#endif	/* XXX */
@


1.17
log
@- add proper double_t and float_t definitions for each arch
- math.h shouldn't define FLT_EVAL_METHOD, but float.h should (per
C99).  remove from math.h, and add proper definitions in float.h
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.16 2008/07/16 15:01:19 martynas Exp $	*/
d22 1
d30 1
a30 1
/* 
d33 70
a102 3

typedef __double_t	double_t;
typedef __float_t	float_t;
d123 1
a123 1
#define	MAXFLOAT        ((float)1.70141173319264430e+38)
d126 1
a126 1
#endif
d135 1
a135 1
#define _LIB_VERSION _fdlib_version  
d137 2
a138 2
/* if global variable _LIB_VERSION is not desirable, one may 
 * change the following to be a constant by: 
d143 2
a144 2
 */ 
extern  _LIB_VERSION_TYPE  _LIB_VERSION;
d146 4
a149 4
#define _IEEE_  fdlibm_ieee
#define _SVID_  fdlibm_svid
#define _XOPEN_ fdlibm_xopen
#define _POSIX_ fdlibm_posix
d159 1
a159 1
#endif
d163 1
a163 1
/* 
d168 1
a168 1
#define X_TLOSS		1.41484755040568800000e+16 
d210 37
d248 2
d252 25
a277 7
extern double erf(double);
extern double erfc(double);
extern double gamma(double);
extern double hypot(double, double);
extern int isinf(double);
extern int isnan(double);
extern int finite(double);
d281 1
a281 2
extern double lgamma(double);
extern double tgamma(double);
d285 1
d287 3
a289 30
#if __BSD_VISIBLE || __XPG_VISIBLE >= 500
extern double acosh(double);
extern double asinh(double);
extern double atanh(double);
extern double cbrt(double);
extern double logb(double);
extern double nextafter(double, double);
extern double remainder(double, double);
extern double scalb(double, double);

#ifdef __LIBM_PRIVATE
extern int matherr(struct exception *);
#endif

/*
 * IEEE Test Vector
 */
extern double significand(double);

/*
 * Functions callable from C, intended to support IEEE arithmetic.
 */
extern double copysign(double, double);
extern int ilogb(double);
extern double rint(double);
extern long int lrint(double);
extern long int lround(double);
extern long long int llrint(double);
extern long long int llround(double);
extern double scalbn(double, int);
d294 1
a294 1
extern double cabs();
d296 1
a296 2
extern double expm1(double);
extern double log1p(double);
a301 1
#if __BSD_VISIBLE || defined(_REENTRANT)
a303 1
#endif /* __BSD_VISIBLE || _REENTRANT */
d305 9
d315 4
a318 1
/* float versions of ANSI/POSIX functions */
d327 3
d335 4
d340 1
d344 5
d350 4
d355 3
d361 5
a366 1
extern float fabsf(float);
d368 11
d380 13
d394 10
a403 2
extern float roundf(float);
extern float truncf(float);
d405 1
a405 7
extern float erff(float);
extern float erfcf(float);
extern float gammaf(float);
extern float hypotf(float, float);
extern int isinff(float);
extern int isnanf(float);
extern int finitef(float);
d409 1
a409 2
extern float lgammaf(float);
extern float tgammaf(float);
d413 1
d415 3
a417 8
extern float acoshf(float);
extern float asinhf(float);
extern float atanhf(float);
extern float cbrtf(float);
extern float logbf(float);
extern float nextafterf(float, float);
extern float remainderf(float, float);
extern float scalbf(float, float);
d420 1
a420 1
 * float version of IEEE Test Vector
d422 5
a426 1
extern float significandf(float);
d429 3
a431 2
 * Float versions of functions callable from C, intended to support
 * IEEE arithmetic.
d433 2
a434 8
extern float copysignf(float, float);
extern int ilogbf(float);
extern float rintf(float);
extern long int lrintf(float);
extern long int lroundf(float);
extern long long int llrintf(float);
extern long long int llroundf(float);
extern float scalbnf(float, int);
d437 1
a437 1
 * float versions of BSD math library entry points
d439 2
a440 4
extern float cabsf ();
extern float dremf(float, float);
extern float expm1f(float);
extern float log1pf(float);
d443 1
a443 3
 * Float versions of reentrant version of gamma & lgamma; passes
 * signgam back by reference as the second argument; user must
 * allocate space for signgam.
d445 70
a514 4
#if __BSD_VISIBLE || defined(_REENTRANT)
extern float gammaf_r(float, int *);
extern float lgammaf_r(float, int *);
#endif /* __BSD_VISIBLE || _REENTRANT */
d516 21
a536 2
#endif /* __BSD_VISIBLE || __XPG_VISIBLE >= 500 */
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */
d543 1
a543 1
#endif /* _MATH_H_ */
@


1.16
log
@infnan always returned wrong values, because compiler assumed it
returns integer value, so add missing prototype
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.15 2008/06/11 21:16:43 martynas Exp $	*/
d20 1
d33 2
a34 5
/* XXX just appease the committee for now, needs proper defs... */

typedef float float_t;
typedef double double_t;
#define FLT_EVAL_METHOD (-1)
@


1.15
log
@tgamma and tgammaf
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.14 2006/07/12 07:26:07 brad Exp $	*/
d307 4
@


1.14
log
@add some more C99 functions: round(3) and roundf(3).

By Steven G. Kargl <kargl at troutmask dot apl dot washington.edu>
From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.13 2006/07/12 06:43:31 brad Exp $	*/
d159 1
d255 1
@


1.13
log
@add missing prototypes for trunc/truncf.
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.12 2006/05/05 20:10:25 otto Exp $	*/
d144 1
d240 1
@


1.12
log
@delint; ok millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.11 2005/12/13 00:35:22 millert Exp $	*/
d144 2
d238 2
@


1.11
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.10 2005/11/17 20:07:40 otto Exp $	*/
d26 1
a26 1
#define HUGE_VAL	(*(double *) __infinity)
@


1.10
log
@Introduce a few c99 functions: {l,ll}{rint,round}{,f}. From NetBSD via
jason@@. Man page fixes by jmc@@, prodding by jsg@@. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.9 2005/01/06 20:36:23 espie Exp $	*/
d20 2
d41 1
a41 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
d63 1
d65 1
a65 1
#if !defined(_XOPEN_SOURCE)
d111 1
a111 2
#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
a112 2

#include <sys/cdefs.h>
d144 1
a144 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
d160 1
a160 1
#if !defined(_XOPEN_SOURCE)
d203 1
a203 1
#ifdef _REENTRANT
d206 1
a206 1
#endif /* _REENTRANT */
d292 1
a292 1
#ifdef _REENTRANT
d295 1
a295 1
#endif	/* _REENTRANT */
d297 2
a298 2
#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
@


1.9
log
@provide float_t, double_t, FLT_EVAL_METHOD (dummy C99 constructs)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.8 2003/06/26 22:40:27 jason Exp $	*/
d185 4
d273 4
@


1.8
log
@Better value for vax MAXFLOAT
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.7 2003/06/26 22:27:14 jason Exp $	*/
d25 10
@


1.7
log
@redefine MAXFLOAT in vax terms
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.6 2002/02/16 21:27:17 millert Exp $	*/
d45 1
a45 1
#define	MAXFLOAT	((float)1.7e38)
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.5 2001/05/26 01:49:25 millert Exp $	*/
d44 3
d48 2
@


1.5
log
@Change protection of struct exception back from #ifdef __LIBM_PRIVATE
to #ifndef __cplusplus.  It turns out there is code outside of libm
that wants to use this.  I suppose that's why it is in math.h instead
of math_private.h ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.4 2000/03/01 22:27:13 todd Exp $	*/
d102 26
a127 26
extern double acos __P((double));
extern double asin __P((double));
extern double atan __P((double));
extern double atan2 __P((double, double));
extern double cos __P((double));
extern double sin __P((double));
extern double tan __P((double));

extern double cosh __P((double));
extern double sinh __P((double));
extern double tanh __P((double));

extern double exp __P((double));
extern double frexp __P((double, int *));
extern double ldexp __P((double, int));
extern double log __P((double));
extern double log10 __P((double));
extern double modf __P((double, double *));

extern double pow __P((double, double));
extern double sqrt __P((double));

extern double ceil __P((double));
extern double fabs __P((double));
extern double floor __P((double));
extern double fmod __P((double, double));
d130 14
a143 14
extern double erf __P((double));
extern double erfc __P((double));
extern double gamma __P((double));
extern double hypot __P((double, double));
extern int isinf __P((double));
extern int isnan __P((double));
extern int finite __P((double));
extern double j0 __P((double));
extern double j1 __P((double));
extern double jn __P((int, double));
extern double lgamma __P((double));
extern double y0 __P((double));
extern double y1 __P((double));
extern double yn __P((int, double));
d146 8
a153 8
extern double acosh __P((double));
extern double asinh __P((double));
extern double atanh __P((double));
extern double cbrt __P((double));
extern double logb __P((double));
extern double nextafter __P((double, double));
extern double remainder __P((double, double));
extern double scalb __P((double, double));
d156 1
a156 1
extern int matherr __P((struct exception *));
d162 1
a162 1
extern double significand __P((double));
d167 4
a170 4
extern double copysign __P((double, double));
extern int ilogb __P((double));
extern double rint __P((double));
extern double scalbn __P((double, int));
d176 3
a178 3
extern double drem __P((double, double));
extern double expm1 __P((double));
extern double log1p __P((double));
d185 2
a186 2
extern double gamma_r __P((double, int *));
extern double lgamma_r __P((double, int *));
d191 50
a240 50
extern float acosf __P((float));
extern float asinf __P((float));
extern float atanf __P((float));
extern float atan2f __P((float, float));
extern float cosf __P((float));
extern float sinf __P((float));
extern float tanf __P((float));

extern float coshf __P((float));
extern float sinhf __P((float));
extern float tanhf __P((float));

extern float expf __P((float));
extern float frexpf __P((float, int *));
extern float ldexpf __P((float, int));
extern float logf __P((float));
extern float log10f __P((float));
extern float modff __P((float, float *));

extern float powf __P((float, float));
extern float sqrtf __P((float));

extern float ceilf __P((float));
extern float fabsf __P((float));
extern float floorf __P((float));
extern float fmodf __P((float, float));

extern float erff __P((float));
extern float erfcf __P((float));
extern float gammaf __P((float));
extern float hypotf __P((float, float));
extern int isinff __P((float));
extern int isnanf __P((float));
extern int finitef __P((float));
extern float j0f __P((float));
extern float j1f __P((float));
extern float jnf __P((int, float));
extern float lgammaf __P((float));
extern float y0f __P((float));
extern float y1f __P((float));
extern float ynf __P((int, float));

extern float acoshf __P((float));
extern float asinhf __P((float));
extern float atanhf __P((float));
extern float cbrtf __P((float));
extern float logbf __P((float));
extern float nextafterf __P((float, float));
extern float remainderf __P((float, float));
extern float scalbf __P((float, float));
d245 1
a245 1
extern float significandf __P((float));
d251 4
a254 4
extern float copysignf __P((float, float));
extern int ilogbf __P((float));
extern float rintf __P((float));
extern float scalbnf __P((float, int));
d260 3
a262 3
extern float dremf __P((float, float));
extern float expm1f __P((float));
extern float log1pf __P((float));
d270 2
a271 2
extern float gammaf_r __P((float, int *));
extern float lgammaf_r __P((float, int *));
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
#ifdef __LIBM_PRIVATE
@


1.3
log
@We don't need two math.h headers incvs server: nothing known about
`math.h'.  The one in libm is more up to date but the one in the
include dir is what gets installed.
@
text
@d1 1
a14 1
 * $Id: math.h,v 1.4 1998/03/02 23:34:46 millert Exp $
@


1.2
log
@Well, as we are heading for a release people are encouraged to rebuild their
entire trees for testing anyway, I might as well do this intrusive touching
of include files now.  Added openBSD tags.
@
text
@a0 3
/*	$OpenBSD: math.h,v 1.10 1994/10/26 00:56:05 cgd Exp $	*/
/*	$NetBSD: math.h,v 1.10 1994/10/26 00:56:05 cgd Exp $	*/

d13 2
a14 1
 * @@(#)fdlibm.h 5.1 93/09/24
d67 1
d75 1
d155 1
d157 1
d222 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

