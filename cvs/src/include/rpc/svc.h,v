head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.18
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.8
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.08.27.04.28.28;	author guenther;	state Exp;
branches;
next	1.15;
commitid	dAsUsbHv6S1kEc3Y;

1.15
date	2015.09.14.08.16.14;	author guenther;	state Exp;
branches;
next	1.14;
commitid	6SDgVrKiCVDNNKz2;

1.14
date	2015.09.13.15.36.57;	author guenther;	state Exp;
branches;
next	1.13;
commitid	FxNpAvmgpSFQVav0;

1.13
date	2014.10.29.04.34.21;	author guenther;	state Exp;
branches;
next	1.12;
commitid	gF7QksPFBnx5clbs;

1.12
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.22.21.48.02;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.31.03.27.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.17.19.42.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.15.13.51.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.03.06.50.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.22.18.44.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.09.21.10.46.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@/*	$OpenBSD: svc.h,v 1.15 2015/09/14 08:16:14 guenther Exp $	*/
/*	$NetBSD: svc.h,v 1.9 1995/04/29 05:28:01 cgd Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	from: @@(#)svc.h 1.20 88/02/08 SMI 
 *	@@(#)svc.h	2.2 88/07/29 4.0 RPCSRC
 */

/*
 * svc.h, Server-side remote procedure call interface.
 */

#ifndef _RPC_SVC_H
#define _RPC_SVC_H
#include <sys/cdefs.h>
#include <poll.h>

/*
 * This interface must manage two items concerning remote procedure calling:
 *
 * 1) An arbitrary number of transport connections upon which rpc requests
 * are received.  The two most notable transports are TCP and UDP;  they are
 * created and registered by routines in svc_tcp.c and svc_udp.c, respectively;
 * they in turn call xprt_register and xprt_unregister.
 *
 * 2) An arbitrary number of locally registered services.  Services are
 * described by the following four data: program number, version number,
 * "service dispatch" function, a transport handle, and a boolean that
 * indicates whether or not the exported program should be registered with a
 * local binder service;  if true the program's number and version and the
 * port number from the transport handle are registered with the binder.
 * These data are registered with the rpc svc system via svc_register.
 *
 * A service's dispatch function is called whenever an rpc request comes in
 * on a transport.  The request's program and version numbers must match
 * those of the registered service.  The dispatch function is passed two
 * parameters, struct svc_req * and SVCXPRT *, defined below.
 */

enum xprt_stat {
	XPRT_DIED,
	XPRT_MOREREQS,
	XPRT_IDLE
};

/*
 * Server side transport handle
 */
typedef struct __rpc_svcxprt {
	int		xp_sock;
	unsigned short	xp_port;	 /* associated port number */
	struct xp_ops {
		/* receive incoming requests */
		bool_t	(*xp_recv)(struct __rpc_svcxprt *,
			    struct rpc_msg *);
		/* get transport status */
		enum xprt_stat (*xp_stat)(struct __rpc_svcxprt *);
		/* get arguments */
		bool_t	(*xp_getargs)(struct __rpc_svcxprt *, xdrproc_t,
			    caddr_t);
		/* send reply */
		bool_t	(*xp_reply)(struct __rpc_svcxprt *, struct rpc_msg *);
		/* free mem allocated for args */
		bool_t	(*xp_freeargs)(struct __rpc_svcxprt *, xdrproc_t,
			    caddr_t);
		/* destroy this struct */
		void	(*xp_destroy)(struct __rpc_svcxprt *);
	} *xp_ops;
	socklen_t	xp_addrlen;	 /* length of remote address */
	struct sockaddr_in xp_raddr;	 /* remote address */
	struct opaque_auth xp_verf;	 /* raw response verifier */
	caddr_t		xp_p1;		 /* private */
	caddr_t		xp_p2;		 /* private */
} SVCXPRT;

/*
 *  Approved way of getting address of caller
 */
#define svc_getcaller(x) (&(x)->xp_raddr)

/*
 * Operations defined on an SVCXPRT handle
 *
 * SVCXPRT		*xprt;
 * struct rpc_msg	*msg;
 * xdrproc_t		 xargs;
 * caddr_t		 argsp;
 */
#define SVC_RECV(xprt, msg)				\
	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
#define svc_recv(xprt, msg)				\
	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))

#define SVC_STAT(xprt)					\
	(*(xprt)->xp_ops->xp_stat)(xprt)
#define svc_stat(xprt)					\
	(*(xprt)->xp_ops->xp_stat)(xprt)

#define SVC_GETARGS(xprt, xargs, argsp)			\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt, xargs, argsp)			\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))

#define SVC_REPLY(xprt, msg)				\
	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
#define svc_reply(xprt, msg)				\
	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))

#define SVC_FREEARGS(xprt, xargs, argsp)		\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
#define svc_freeargs(xprt, xargs, argsp)		\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))

#define SVC_DESTROY(xprt)				\
	(*(xprt)->xp_ops->xp_destroy)(xprt)
#define svc_destroy(xprt)				\
	(*(xprt)->xp_ops->xp_destroy)(xprt)


/*
 * Service request
 */
struct svc_req {
	u_int32_t	rq_prog;	/* service program number */
	u_int32_t	rq_vers;	/* service protocol version */
	u_int32_t	rq_proc;	/* the desired procedure */
	struct opaque_auth rq_cred;	/* raw creds from the wire */
	caddr_t		rq_clntcred;	/* read only cooked cred */
	SVCXPRT	*rq_xprt;		/* associated transport */
};


/*
 * Service registration
 *
 * svc_register(xprt, prog, vers, dispatch, protocol)
 *	SVCXPRT *xprt;
 *	unsigned long prog;
 *	unsigned long vers;
 *	void (*dispatch)();
 *	int protocol;    like TCP or UDP, zero means do not register 
 */
__BEGIN_DECLS
extern bool_t	svc_register(SVCXPRT *, unsigned long, unsigned long,
		    void (*)(struct svc_req *, SVCXPRT *), int);
__END_DECLS

/*
 * Service un-registration
 *
 * svc_unregister(prog, vers)
 *	unsigned long prog;
 *	unsigned long vers;
 */
__BEGIN_DECLS
extern void	svc_unregister(unsigned long, unsigned long);
__END_DECLS

/*
 * Transport registration.
 *
 * xprt_register(xprt)
 *	SVCXPRT *xprt;
 */
__BEGIN_DECLS
extern void	xprt_register(SVCXPRT *);
__END_DECLS

/*
 * Transport un-register
 *
 * xprt_unregister(xprt)
 *	SVCXPRT *xprt;
 */
__BEGIN_DECLS
extern void	xprt_unregister(SVCXPRT *);
__END_DECLS




/*
 * When the service routine is called, it must first check to see if it
 * knows about the procedure;  if not, it should call svcerr_noproc
 * and return.  If so, it should deserialize its arguments via 
 * SVC_GETARGS (defined above).  If the deserialization does not work,
 * svcerr_decode should be called followed by a return.  Successful
 * decoding of the arguments should be followed the execution of the
 * procedure's code and a call to svc_sendreply.
 *
 * Also, if the service refuses to execute the procedure due to too-
 * weak authentication parameters, svcerr_weakauth should be called.
 * Note: do not confuse access-control failure with weak authentication!
 *
 * NB: In pure implementations of rpc, the caller always waits for a reply
 * msg.  This message is sent when svc_sendreply is called.  
 * Therefore pure service implementations should always call
 * svc_sendreply even if the function logically returns void;  use
 * xdr.h - xdr_void for the xdr routine.  HOWEVER, tcp based rpc allows
 * for the abuse of pure rpc via batched calling or pipelining.  In the
 * case of a batched call, svc_sendreply should NOT be called since
 * this would send a return message, which is what batching tries to avoid.
 * It is the service/protocol writer's responsibility to know which calls are
 * batched and which are not.  Warning: responding to batch calls may
 * deadlock the caller and server processes!
 */

__BEGIN_DECLS
extern bool_t	svc_sendreply(SVCXPRT *, xdrproc_t, char *);
extern void	svcerr_decode(SVCXPRT *);
extern void	svcerr_weakauth(SVCXPRT *);
extern void	svcerr_noproc(SVCXPRT *);
extern void	svcerr_progvers(SVCXPRT *, unsigned long, unsigned long);
extern void	svcerr_auth(SVCXPRT *, enum auth_stat);
extern void	svcerr_noprog(SVCXPRT *);
extern void	svcerr_systemerr(SVCXPRT *);
__END_DECLS
    
/*
 * Lowest level dispatching -OR- who owns this process anyway.
 * Somebody has to wait for incoming requests and then call the correct
 * service routine.  The routine svc_run does infinite waiting; i.e.,
 * svc_run never returns.
 * Since another (co-existent) package may wish to selectively wait for
 * incoming calls or other events outside of the rpc architecture, the
 * routine svc_getreq is provided.  It must be passed readfds, the
 * "in-place" results of a select system call (see select, section 2).
 */

/*
 * Global keeper of rpc service descriptors in use
 * dynamic; must be inspected before each call to select 
 */
#include <sys/select.h>			/* for fd_set */
extern fd_set svc_fdset;
#define svc_fds svc_fdset.fds_bits[0]	/* compatibility */
extern struct pollfd *svc_pollfd;
extern int svc_max_pollfd;
extern int svc_maxfd;			/* non-standard */

/*
 * a small program implemented by the svc_rpc implementation itself;
 * also see clnt.h for protocol numbers.
 */
extern void rpctest_service();				/* XXX relic? */

__BEGIN_DECLS
extern void	svc_getreq(int);
extern void	svc_getreq_common(int);
extern void	svc_getreq_poll(struct pollfd *, const int);
extern void	svc_getreqset(fd_set *);
extern void	svc_getreqset2(fd_set *, int);
extern void	svc_run(void);
__END_DECLS

/*
 * Socket to use on svcxxx_create call to get default socket
 */
#define	RPC_ANYSOCK	-1

/*
 * These are the existing service side transport implementations
 */

/*
 * Memory based rpc for testing and timing.
 */
__BEGIN_DECLS
extern SVCXPRT *svcraw_create(void);
__END_DECLS


/*
 * Udp based rpc.
 */
__BEGIN_DECLS
extern SVCXPRT *svcudp_create(int);
extern SVCXPRT *svcudp_bufcreate(int, unsigned int, unsigned int);
extern int svcudp_enablecache(SVCXPRT *, u_long);
__END_DECLS


/*
 * Tcp based rpc.
 */
__BEGIN_DECLS
extern SVCXPRT *svctcp_create(int, unsigned int, unsigned int);
__END_DECLS

/*
 * Fd based rpc.
 */
__BEGIN_DECLS
extern SVCXPRT *svcfd_create(int, unsigned int, unsigned int);
__END_DECLS

#endif /* !_RPC_SVC_H */
@


1.15
log
@Prefer the standardized <poll.h> over <sys/poll.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.14 2015/09/13 15:36:57 guenther Exp $	*/
d263 1
@


1.14
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.13 2014/10/29 04:34:21 guenther Exp $	*/
d45 1
a45 1
#include <sys/poll.h>
@


1.13
log
@Add prototypes for xdr_{accepted,rejected}_reply() and svcudp_enablecache()
(Both NetBSD and FreeBSD provide these prototypes)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.12 2010/09/01 14:43:34 millert Exp $	*/
a195 1
extern int	__xprt_register(SVCXPRT *);
@


1.12
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.11 2010/05/01 08:14:26 mk Exp $	*/
d308 1
@


1.11
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.10 2007/11/24 12:59:28 jmc Exp $	*/
d5 28
a32 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a39 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.10
log
@some spelling fixes from Martynas Venckus
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.9 2004/01/22 21:48:02 espie Exp $	*/
d82 1
a82 1
		/* receive incomming requests */
@


1.9
log
@Remove unnecessary typedef usage.

u_char -> unsigned char
u_short -> unsigned short
u_long -> unsigned long
u_int -> unsigned int

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.8 2003/12/31 03:27:23 millert Exp $	*/
d254 1
a254 1
 * Since another (co-existant) package may wish to selectively wait for
@


1.8
log
@Implement svc_getreq_poll(3) and friends and use poll(2) instead of select(2)
in the libc rpc code.  The main difference between this and the previous
version is the use of a simple free list that simplifies the logic when
adding a socket to svc_pollfd.  I've also added code to pack svc_pollfd
when the free list gets too big.  The idea general idea is to keep
svc_pollfd as tightly packed as possible to make poll(2) efficient.
Tested by many people and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.7 2002/02/17 19:42:21 millert Exp $	*/
d80 1
a80 1
	u_short		xp_port;	 /* associated port number */
d167 2
a168 2
 *	u_long prog;
 *	u_long vers;
d173 1
a173 1
extern bool_t	svc_register(SVCXPRT *, u_long, u_long,
d181 2
a182 2
 *	u_long prog;
 *	u_long vers;
d185 1
a185 1
extern void	svc_unregister(u_long, u_long);
d243 1
a243 1
extern void	svcerr_progvers(SVCXPRT *, u_long, u_long);
d307 1
a307 1
extern SVCXPRT *svcudp_bufcreate(int, u_int, u_int);
d315 1
a315 1
extern SVCXPRT *svctcp_create(int, u_int, u_int);
d322 1
a322 1
extern SVCXPRT *svcfd_create(int, u_int, u_int);
@


1.7
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.6 2002/02/16 21:27:18 millert Exp $	*/
d45 1
a263 2
extern int svc_maxfd;
#ifdef FD_SETSIZE
d266 3
a268 3
#else
extern int svc_fds;
#endif /* def FD_SETSIZE */
d278 2
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.5 2001/09/15 13:51:00 deraadt Exp $	*/
d82 2
a83 2
		bool_t	(*xp_recv) __P((struct __rpc_svcxprt *,
			    struct rpc_msg *));
d87 2
a88 2
		bool_t	(*xp_getargs) __P((struct __rpc_svcxprt *, xdrproc_t,
			    caddr_t));
d90 1
a90 2
		bool_t	(*xp_reply) __P((struct __rpc_svcxprt *,
			    struct rpc_msg *));
d92 2
a93 2
		bool_t	(*xp_freeargs) __P((struct __rpc_svcxprt *, xdrproc_t,
			    caddr_t));
d172 2
a173 2
extern bool_t	svc_register __P((SVCXPRT *, u_long, u_long,
		    void (*)(struct svc_req *, SVCXPRT *), int));
@


1.5
log
@prototype cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.4 2001/03/03 06:50:27 deraadt Exp $	*/
d85 1
a85 1
		enum xprt_stat (*xp_stat) __P((struct __rpc_svcxprt *));
d96 1
a96 1
		void	(*xp_destroy) __P((struct __rpc_svcxprt *));
d174 1
a174 1
		    void (*) __P((struct svc_req *, SVCXPRT *)), int));
d185 1
a185 1
extern void	svc_unregister __P((u_long, u_long));
d195 2
a196 2
extern void	xprt_register	__P((SVCXPRT *));
extern int	__xprt_register	__P((SVCXPRT *));
d206 1
a206 1
extern void	xprt_unregister	__P((SVCXPRT *));
d239 8
a246 8
extern bool_t	svc_sendreply	__P((SVCXPRT *, xdrproc_t, char *));
extern void	svcerr_decode	__P((SVCXPRT *));
extern void	svcerr_weakauth	__P((SVCXPRT *));
extern void	svcerr_noproc	__P((SVCXPRT *));
extern void	svcerr_progvers	__P((SVCXPRT *, u_long, u_long));
extern void	svcerr_auth	__P((SVCXPRT *, enum auth_stat));
extern void	svcerr_noprog	__P((SVCXPRT *));
extern void	svcerr_systemerr __P((SVCXPRT *));
d279 4
a282 4
extern void	svc_getreq	__P((int));
extern void	svc_getreqset	__P((fd_set *));
extern void	svc_getreqset2	__P((fd_set *, int));
extern void	svc_run		__P((void));
d298 1
a298 1
extern SVCXPRT *svcraw_create __P((void));
d306 2
a307 2
extern SVCXPRT *svcudp_create __P((int));
extern SVCXPRT *svcudp_bufcreate __P((int, u_int, u_int));
d315 1
a315 1
extern SVCXPRT *svctcp_create __P((int, u_int, u_int));
d322 1
a322 1
extern SVCXPRT *svcfd_create __P((int, u_int, u_int));
@


1.4
log
@plug many memory leaks
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.3 2000/08/22 18:44:48 deraadt Exp $	*/
d98 1
a98 1
	int		xp_addrlen;	 /* length of remote address */
@


1.3
log
@proto svc_getreqset2
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.2 1997/09/21 10:46:16 niklas Exp $	*/
d196 1
@


1.2
log
@Well, as we are heading for a release people are encouraged to rebuild their
entire trees for testing anyway, I might as well do this intrusive touching
of include files now.  Added openBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.h,v 1.9 1995/04/29 05:28:01 cgd Exp $	*/
d280 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
