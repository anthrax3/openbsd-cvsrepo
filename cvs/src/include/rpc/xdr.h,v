head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.26
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.28
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.24
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.20
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.22
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.14
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.18
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.18
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.16
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.14
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.09.19.40.10;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.13.21.12.11;	author sturm;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.08.19.47.38;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.08.19.17.39;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.22.21.48.02;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.10.03.45.20;	author david;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.11.22.55.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.17.19.42.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.09.21.10.46.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@/*	$OpenBSD: xdr.h,v 1.11 2008/12/09 19:40:10 otto Exp $	*/
/*	$NetBSD: xdr.h,v 1.7 1995/04/29 05:28:06 cgd Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	from: @@(#)xdr.h 1.19 87/04/22 SMI
 *	@@(#)xdr.h	2.2 88/07/29 4.0 RPCSRC
 */

/*
 * xdr.h, External Data Representation Serialization Routines.
 */

#ifndef _RPC_XDR_H
#define _RPC_XDR_H
#include <sys/cdefs.h>

/*
 * XDR provides a conventional way for converting between C data
 * types and an external bit-string representation.  Library supplied
 * routines provide for the conversion on built-in C data types.  These
 * routines and utility routines defined here are used to help implement
 * a type encode/decode routine for each user-defined type.
 *
 * Each data type provides a single procedure which takes two arguments:
 *
 *	bool_t
 *	xdrproc(xdrs, argresp)
 *		XDR *xdrs;
 *		<type> *argresp;
 *
 * xdrs is an instance of a XDR handle, to which or from which the data
 * type is to be converted.  argresp is a pointer to the structure to be
 * converted.  The XDR handle contains an operation field which indicates
 * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
 *
 * XDR_DECODE may allocate space if the pointer argresp is null.  This
 * data can be freed with the XDR_FREE operation.
 *
 * We write only one procedure per data type to make it easy
 * to keep the encode and decode procedures for a data type consistent.
 * In many cases the same code performs all operations on a user defined type,
 * because all the hard work is done in the component type routines.
 * decode as a series of calls on the nested data types.
 */

/*
 * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
 * stream.  XDR_DECODE causes the type to be extracted from the stream.
 * XDR_FREE can be used to release the space allocated by an XDR_DECODE
 * request.
 */
enum xdr_op {
	XDR_ENCODE=0,
	XDR_DECODE=1,
	XDR_FREE=2
};

/*
 * This is the number of bytes per unit of external data.
 */
#define BYTES_PER_XDR_UNIT	(4)
#define RNDUP(x)  ((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \
		    * BYTES_PER_XDR_UNIT)

/*
 * The XDR handle.
 * Contains operation which is being applied to the stream,
 * an operations vector for the paticular implementation (e.g. see xdr_mem.c),
 * and two private fields for the use of the particular impelementation.
 */
typedef struct __rpc_xdr {
	enum xdr_op	x_op;		/* operation; fast additional param */
	struct xdr_ops {
		/* get a long from underlying stream */
		bool_t	(*x_getlong)(struct __rpc_xdr *, long *);
		/* put a long to " */
		bool_t	(*x_putlong)(struct __rpc_xdr *, long *);
		/* get some bytes from " */
		bool_t	(*x_getbytes)(struct __rpc_xdr *, caddr_t, 
		    unsigned int);
		/* put some bytes to " */
		bool_t	(*x_putbytes)(struct __rpc_xdr *, caddr_t, 
		    unsigned int);
		/* returns bytes off from beginning */
		unsigned int	(*x_getpostn)(struct __rpc_xdr *);
		/* lets you reposition the stream */
		bool_t  (*x_setpostn)(struct __rpc_xdr *, unsigned int);
		/* buf quick ptr to buffered data */
		int32_t	*(*x_inline)(struct __rpc_xdr *, unsigned int);
		/* free privates of this xdr_stream */
		void	(*x_destroy)(struct __rpc_xdr *);
		bool_t	(*x_control)(struct __rpc_xdr *, int, void *);
	} *x_ops;
	caddr_t 	x_public;	/* users' data */
	caddr_t		x_private;	/* pointer to private data */
	caddr_t 	x_base;		/* private used for position info */
	unsigned int	x_handy;	/* extra private word */
} XDR;

/*
 * A xdrproc_t exists for each data type which is to be encoded or decoded.
 *
 * The second argument to the xdrproc_t is a pointer to an opaque pointer.
 * The opaque pointer generally points to a structure of the data type
 * to be decoded.  If this pointer is 0, then the type routines should
 * allocate dynamic storage of the appropriate size and return it.
 *
 * XXX can't actually prototype it, because some take three args!!!
 */
typedef	bool_t (*xdrproc_t)(/* XDR *, void *, unsigned int */);

/*
 * Operations defined on a XDR handle
 *
 * XDR		*xdrs;
 * long		*longp;
 * caddr_t	 addr;
 * unsigned int	 len;
 * unsigned int	 pos;
 */
#define XDR_GETLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)

#define XDR_PUTLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)

#define XDR_GETBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)

#define XDR_PUTBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)

#define XDR_GETPOS(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define xdr_getpos(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)

#define XDR_SETPOS(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)

#define	XDR_INLINE(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define	xdr_inline(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)

#define	XDR_DESTROY(xdrs)				\
	if ((xdrs)->x_ops->x_destroy) 			\
		(*(xdrs)->x_ops->x_destroy)(xdrs)
#define	xdr_destroy(xdrs)				\
	if ((xdrs)->x_ops->x_destroy) 			\
		(*(xdrs)->x_ops->x_destroy)(xdrs)

/*
 * Support struct for discriminated unions.
 * You create an array of xdrdiscrim structures, terminated with
 * a entry with a null procedure pointer.  The xdr_union routine gets
 * the discriminant value and then searches the array of structures
 * for a matching value.  If a match is found the associated xdr routine
 * is called to handle that part of the union.  If there is
 * no match, then a default routine may be called.
 * If there is no match and no default routine it is an error.
 */
#define NULL_xdrproc_t ((xdrproc_t)0)
struct xdr_discrim {
	int	value;
	xdrproc_t proc;
};

/*
 * In-line routines for fast encode/decode of primitive data types.
 * Caveat emptor: these use single memory cycles to get the
 * data from the underlying buffer, and will fail to operate
 * properly if the data is not aligned.  The standard way to use these
 * is to say:
 *	if ((buf = XDR_INLINE(xdrs, count)) == NULL)
 *		return (FALSE);
 *	<<< macro calls >>>
 * where ``count'' is the number of bytes of data occupied
 * by the primitive data types.
 *
 * N.B. and frozen for all time: each data type here uses 4 bytes
 * of external representation.
 */
#define IXDR_GET_LONG(buf)		((long)ntohl((unsigned long)*(buf)++))
#define IXDR_PUT_LONG(buf, v)		(*(buf)++ = (long)htonl((unsigned long)v))

#define IXDR_GET_BOOL(buf)		((bool_t)IXDR_GET_LONG(buf))
#define IXDR_GET_ENUM(buf, t)		((t)IXDR_GET_LONG(buf))
#define IXDR_GET_U_LONG(buf)		((unsigned long)IXDR_GET_LONG(buf))
#define IXDR_GET_SHORT(buf)		((short)IXDR_GET_LONG(buf))
#define IXDR_GET_U_SHORT(buf)		((unsigned short)IXDR_GET_LONG(buf))

#define IXDR_PUT_BOOL(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_ENUM(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_LONG(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_SHORT(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_SHORT(buf, v)	IXDR_PUT_LONG((buf), ((long)(v)))

/*
 * These are the "generic" xdr routines.
 */
__BEGIN_DECLS
extern bool_t	xdr_void(void);
extern bool_t	xdr_int(XDR *, int *);
extern bool_t	xdr_u_int(XDR *, unsigned int *);
extern bool_t	xdr_long(XDR *, long *);
extern bool_t	xdr_u_long(XDR *, unsigned long *);
extern bool_t	xdr_short(XDR *, short *);
extern bool_t	xdr_u_short(XDR *, unsigned short *);
extern bool_t	xdr_int16_t(XDR *, int16_t *);
extern bool_t	xdr_u_int16_t(XDR *, u_int16_t *);
extern bool_t	xdr_int32_t(XDR *, int32_t *);
extern bool_t	xdr_u_int32_t(XDR *, u_int32_t *);
extern bool_t	xdr_int64_t(XDR *, int64_t *);
extern bool_t	xdr_u_int64_t(XDR *, u_int64_t *);
extern bool_t	xdr_bool(XDR *, bool_t *);
extern bool_t	xdr_enum(XDR *, enum_t *);
extern bool_t	xdr_array(XDR *, char **, unsigned int *, unsigned int, 
    unsigned int, xdrproc_t);
extern bool_t	xdr_bytes(XDR *, char **, unsigned int *, unsigned int);
extern bool_t	xdr_opaque(XDR *, caddr_t, unsigned int);
extern bool_t	xdr_string(XDR *, char **, unsigned int);
extern bool_t	xdr_union(XDR *, enum_t *, char *, struct xdr_discrim *, 
    xdrproc_t);
extern bool_t	xdr_char(XDR *, char *);
extern bool_t	xdr_u_char(XDR *, unsigned char *);
extern bool_t	xdr_vector(XDR *, char *, unsigned int, unsigned int, 
    xdrproc_t);
extern bool_t	xdr_float(XDR *, float *);
extern bool_t	xdr_double(XDR *, double *);
extern bool_t	xdr_reference(XDR *, caddr_t *, unsigned int, xdrproc_t);
extern bool_t	xdr_pointer(XDR *, caddr_t *, unsigned int, xdrproc_t);
extern bool_t	xdr_wrapstring(XDR *, char **);
extern void	xdr_free(xdrproc_t, char *);
__END_DECLS

/*
 * Common opaque bytes objects used by many rpc protocols;
 * declared here due to commonality.
 */
#define MAX_NETOBJ_SZ 1024 
struct netobj {
	unsigned int	 n_len;
	char		*n_bytes;
};
typedef struct netobj netobj;
extern bool_t   xdr_netobj(XDR *, struct netobj *);

/*
 * These are the public routines for the various implementations of
 * xdr streams.
 */
__BEGIN_DECLS
/* XDR using memory buffers */
extern void   xdrmem_create(XDR *, char *, unsigned int, enum xdr_op);

#ifdef _STDIO_H_
/* XDR using stdio library */
extern void   xdrstdio_create(XDR *, FILE *, enum xdr_op);
#endif

/* XDR pseudo records for tcp */
extern void   xdrrec_create(XDR *, unsigned int, unsigned int, char *,
			    int (*)(caddr_t, caddr_t, int),
			    int (*)(caddr_t, caddr_t, int));

/* make end of xdr record */
extern bool_t xdrrec_endofrecord(XDR *, int);

/* move to beginning of next record */
extern bool_t xdrrec_skiprecord(XDR *);

/* true if no more input */
extern bool_t xdrrec_eof(XDR *);
__END_DECLS

#endif /* !_RPC_XDR_H */
@


1.11
log
@Commit requested by marco:
Add nonblock support for xdrrecs
ok millert blambert & otto; from NetBSD. libc bump to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.10 2008/06/13 21:12:11 sturm Exp $	*/
d5 28
a32 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a39 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.10
log
@implement xdr_int64_t, xdr_u_int64_t

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.9 2005/01/08 19:47:38 krw Exp $	*/
d121 1
@


1.9
log
@Oops. Too much 'KNF'. We don't use NULL_xdrproc_t, but someone might
use it in a vararg function call that needs the type info.

Pointed out by otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.8 2005/01/08 19:17:39 krw Exp $	*/
d252 2
@


1.8
log
@Bit of KNF - replace (<type> *)0 and (<type> *)NULL with NULL. Pointed
out by mickey@@, seconded by millert@@.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.7 2004/01/22 21:48:02 espie Exp $	*/
d201 1
a201 1
#define NULL_xdrproc_t NULL
@


1.7
log
@Remove unnecessary typedef usage.

u_char -> unsigned char
u_short -> unsigned short
u_long -> unsigned long
u_int -> unsigned int

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.6 2003/03/10 03:45:20 david Exp $	*/
d201 1
a201 1
#define NULL_xdrproc_t ((xdrproc_t)0)
@


1.6
log
@fix spelling in comment
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.5 2002/12/11 22:55:39 millert Exp $	*/
d108 2
a109 1
		bool_t	(*x_getbytes)(struct __rpc_xdr *, caddr_t, u_int);
d111 2
a112 1
		bool_t	(*x_putbytes)(struct __rpc_xdr *, caddr_t, u_int);
d114 1
a114 1
		u_int	(*x_getpostn)(struct __rpc_xdr *);
d116 1
a116 1
		bool_t  (*x_setpostn)(struct __rpc_xdr *, u_int);
d118 1
a118 1
		int32_t	*(*x_inline)(struct __rpc_xdr *, u_int);
d125 1
a125 1
	u_int		x_handy;	/* extra private word */
d138 1
a138 1
typedef	bool_t (*xdrproc_t)(/* XDR *, void *, u_int */);
d146 2
a147 2
 * u_int	 len;
 * u_int	 pos;
d222 2
a223 2
#define IXDR_GET_LONG(buf)		((long)ntohl((u_long)*(buf)++))
#define IXDR_PUT_LONG(buf, v)		(*(buf)++ = (long)htonl((u_long)v))
d227 1
a227 1
#define IXDR_GET_U_LONG(buf)		((u_long)IXDR_GET_LONG(buf))
d229 1
a229 1
#define IXDR_GET_U_SHORT(buf)		((u_short)IXDR_GET_LONG(buf))
d243 1
a243 1
extern bool_t	xdr_u_int(XDR *, u_int *);
d245 1
a245 1
extern bool_t	xdr_u_long(XDR *, u_long *);
d247 1
a247 1
extern bool_t	xdr_u_short(XDR *, u_short *);
d254 7
a260 5
extern bool_t	xdr_array(XDR *, char **, u_int *, u_int, u_int, xdrproc_t);
extern bool_t	xdr_bytes(XDR *, char **, u_int *, u_int);
extern bool_t	xdr_opaque(XDR *, caddr_t, u_int);
extern bool_t	xdr_string(XDR *, char **, u_int);
extern bool_t	xdr_union(XDR *, enum_t *, char *, struct xdr_discrim *, xdrproc_t);
d262 3
a264 2
extern bool_t	xdr_u_char(XDR *, u_char *);
extern bool_t	xdr_vector(XDR *, char *, u_int, u_int, xdrproc_t);
d267 2
a268 2
extern bool_t	xdr_reference(XDR *, caddr_t *, u_int, xdrproc_t);
extern bool_t	xdr_pointer(XDR *, caddr_t *, u_int, xdrproc_t);
d279 2
a280 2
	u_int	n_len;
	char	*n_bytes;
d291 1
a291 1
extern void   xdrmem_create(XDR *, char *, u_int, enum xdr_op);
d299 1
a299 1
extern void   xdrrec_create(XDR *, u_int, u_int, char *,
@


1.5
log
@Make x_handy in XDR u_int, not int since there are places in the
code that assign a u_int value to x_handy.  However, this means
that we need to be careful checking for overflow as we can no longer
subtract a value and check the result for < 0.  We reorder the
expression instead to avoid this problem (basic algebra).
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.4 2002/02/17 19:42:21 millert Exp $	*/
d206 1
a206 1
 * In-line routines for fast encode/decode of primitve data types.
@


1.4
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.3 2002/02/16 21:27:18 millert Exp $	*/
d123 1
a123 1
	int		x_handy;	/* extra private word */
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.2 1997/09/21 10:46:18 niklas Exp $	*/
d294 3
a296 3
extern void   xdrrec_create	__P((XDR *, u_int, u_int, char *,
				    int (*)(caddr_t, caddr_t, int),
				    int (*)(caddr_t, caddr_t, int)));
@


1.2
log
@Well, as we are heading for a release people are encouraged to rebuild their
entire trees for testing anyway, I might as well do this intrusive touching
of include files now.  Added openBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr.h,v 1.7 1995/04/29 05:28:06 cgd Exp $	*/
d104 1
a104 1
		bool_t	(*x_getlong) __P((struct __rpc_xdr *, long *));
d106 1
a106 1
		bool_t	(*x_putlong) __P((struct __rpc_xdr *, long *));
d108 1
a108 1
		bool_t	(*x_getbytes) __P((struct __rpc_xdr *, caddr_t, u_int));
d110 1
a110 1
		bool_t	(*x_putbytes) __P((struct __rpc_xdr *, caddr_t, u_int));
d112 1
a112 1
		u_int	(*x_getpostn) __P((struct __rpc_xdr *));
d114 1
a114 1
		bool_t  (*x_setpostn) __P((struct __rpc_xdr *, u_int));
d116 1
a116 1
		int32_t	*(*x_inline) __P((struct __rpc_xdr *, u_int));
d118 1
a118 1
		void	(*x_destroy) __P((struct __rpc_xdr *));
d136 1
a136 1
typedef	bool_t (*xdrproc_t) __P((/* XDR *, void *, u_int */));
d239 27
a265 27
extern bool_t	xdr_void	__P((void));
extern bool_t	xdr_int		__P((XDR *, int *));
extern bool_t	xdr_u_int	__P((XDR *, u_int *));
extern bool_t	xdr_long	__P((XDR *, long *));
extern bool_t	xdr_u_long	__P((XDR *, u_long *));
extern bool_t	xdr_short	__P((XDR *, short *));
extern bool_t	xdr_u_short	__P((XDR *, u_short *));
extern bool_t	xdr_int16_t	__P((XDR *, int16_t *));
extern bool_t	xdr_u_int16_t	__P((XDR *, u_int16_t *));
extern bool_t	xdr_int32_t	__P((XDR *, int32_t *));
extern bool_t	xdr_u_int32_t	__P((XDR *, u_int32_t *));
extern bool_t	xdr_bool	__P((XDR *, bool_t *));
extern bool_t	xdr_enum	__P((XDR *, enum_t *));
extern bool_t	xdr_array	__P((XDR *, char **, u_int *, u_int, u_int, xdrproc_t));
extern bool_t	xdr_bytes	__P((XDR *, char **, u_int *, u_int));
extern bool_t	xdr_opaque	__P((XDR *, caddr_t, u_int));
extern bool_t	xdr_string	__P((XDR *, char **, u_int));
extern bool_t	xdr_union	__P((XDR *, enum_t *, char *, struct xdr_discrim *, xdrproc_t));
extern bool_t	xdr_char	__P((XDR *, char *));
extern bool_t	xdr_u_char	__P((XDR *, u_char *));
extern bool_t	xdr_vector	__P((XDR *, char *, u_int, u_int, xdrproc_t));
extern bool_t	xdr_float	__P((XDR *, float *));
extern bool_t	xdr_double	__P((XDR *, double *));
extern bool_t	xdr_reference	__P((XDR *, caddr_t *, u_int, xdrproc_t));
extern bool_t	xdr_pointer	__P((XDR *, caddr_t *, u_int, xdrproc_t));
extern bool_t	xdr_wrapstring	__P((XDR *, char **));
extern void	xdr_free 	__P((xdrproc_t, char *));
d278 1
a278 1
extern bool_t   xdr_netobj __P((XDR *, struct netobj *));
d286 1
a286 1
extern void   xdrmem_create	__P((XDR *, char *, u_int, enum xdr_op));
d290 1
a290 1
extern void   xdrstdio_create	__P((XDR *, FILE *, enum xdr_op));
d295 2
a296 2
				    int (*) __P((caddr_t, caddr_t, int)),
				    int (*) __P((caddr_t, caddr_t, int))));
d299 1
a299 1
extern bool_t xdrrec_endofrecord __P((XDR *, int));
d302 1
a302 1
extern bool_t xdrrec_skiprecord	__P((XDR *));
d305 1
a305 1
extern bool_t xdrrec_eof	__P((XDR *));
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
