head	1.53;
access;
symbols
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.50.0.4
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.4
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.38.0.6
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.35.0.18
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.14
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.12
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.10
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.8
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.6
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2016.09.09.18.12.37;	author millert;	state Exp;
branches;
next	1.52;
commitid	mBDdb9HYWgUfDo7E;

1.52
date	2016.03.16.04.56.08;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	1QLzxrvTKdJVx00f;

1.51
date	2016.03.14.20.43.03;	author millert;	state Exp;
branches;
next	1.50;
commitid	R2x0h2aB8DPNCbSo;

1.50
date	2015.01.20.22.09.50;	author tedu;	state Exp;
branches;
next	1.49;
commitid	LtnBZYs1Bq8B1STb;

1.49
date	2014.03.27.15.28.16;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.25.15.55.15;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2014.03.25.15.24.12;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2013.12.04.22.58.24;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.28.16.37.14;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2013.01.30.00.08.13;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2012.03.21.23.44.35;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.18.17.29.49;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.03.18.51.01;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.06.11.39.42;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.13.18.10.09;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.06.18.53.04;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.13.00.35.22;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.11.18.39.19;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.30.09.25.17;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.01.17.38.33;	author avsm;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.26.19.34.17;	author avsm;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.26.18.35.13;	author avsm;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.19.34.12;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.30.21.36.06;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.29.03.02.34;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.25.21.55.28;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.17.19.42.21;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.17;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.02.00.19.10;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.04.22.17.44;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.30.17.47.57;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.30.07.38.27;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.06.17.18.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.04.17.16.02;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.22.17.29.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.21.22.11.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.09.17.13.13.46;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.11.20.11.18.26;	author d;	state Exp;
branches;
next	1.9;

1.9
date	97.11.29.20.01.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.11.29.19.54.51;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.28.06.51.05;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.07.26.10.34.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.25.05.47.59;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.05.01.13.07.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.24.17.07.33;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.05.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Move the 10 (!) defintions of NULL to their own mini header file and
update the NULL definition for C++11.  OK deraadt@@ guenther@@ kettenis@@
@
text
@/*	$OpenBSD: stdio.h,v 1.52 2016/03/16 04:56:08 deraadt Exp $	*/
/*	$NetBSD: stdio.h,v 1.18 1996/04/25 18:29:21 jtc Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)stdio.h	5.17 (Berkeley) 6/3/91
 */

#ifndef	_STDIO_H_
#define	_STDIO_H_

#include <sys/cdefs.h>
#include <sys/_null.h>
#include <sys/_types.h>

#if __BSD_VISIBLE || __POSIX_VISIBLE || __XPG_VISIBLE
#include <sys/types.h>	/* XXX should be removed */
#endif

#ifndef	_SIZE_T_DEFINED_
#define	_SIZE_T_DEFINED_
typedef	__size_t	size_t;
#endif

#ifndef	_OFF_T_DEFINED_
#define	_OFF_T_DEFINED_
typedef	__off_t	off_t;
#endif

#define	_FSTDIO			/* Define for new stdio with functions. */

typedef off_t fpos_t;		/* stdio file position type */

/*
 * NB: to fit things in six character monocase externals, the stdio
 * code uses the prefix `__s' for stdio objects, typically followed
 * by a three-character attempt at a mnemonic.
 */

/* stdio buffers */
struct __sbuf {
	unsigned char *_base;
	int	_size;
};

/*
 * stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 */
typedef	struct __sFILE {
	unsigned char *_p;	/* current position in (some) buffer */
	int	_r;		/* read space left for getc() */
	int	_w;		/* write space left for putc() */
	short	_flags;		/* flags, below; this FILE is free if 0 */
	short	_file;		/* fileno, if Unix descriptor, else -1 */
	struct	__sbuf _bf;	/* the buffer (at least 1 byte, if !NULL) */
	int	_lbfsize;	/* 0 or -_bf._size, for inline putc */

	/* operations */
	void	*_cookie;	/* cookie passed to io functions */
	int	(*_close)(void *);
	int	(*_read)(void *, char *, int);
	fpos_t	(*_seek)(void *, fpos_t, int);
	int	(*_write)(void *, const char *, int);

	/* extension data, to avoid further ABI breakage */
	struct	__sbuf _ext;
	/* data for long sequences of ungetc() */
	unsigned char *_up;	/* saved _p when _p is doing ungetc data */
	int	_ur;		/* saved _r when _r is counting ungetc data */

	/* tricks to meet minimum requirements even when malloc() fails */
	unsigned char _ubuf[3];	/* guarantee an ungetc() buffer */
	unsigned char _nbuf[1];	/* guarantee a getc() buffer */

	/* separate buffer for fgetln() when line crosses buffer boundary */
	struct	__sbuf _lb;	/* buffer for fgetln() */

	/* Unix stdio files get aligned to block boundaries on fseek() */
	int	_blksize;	/* stat.st_blksize (may be != _bf._size) */
	fpos_t	_offset;	/* current lseek offset */
} FILE;

__BEGIN_DECLS
extern FILE __sF[];
__END_DECLS

#define	__SLBF	0x0001		/* line buffered */
#define	__SNBF	0x0002		/* unbuffered */
#define	__SRD	0x0004		/* OK to read */
#define	__SWR	0x0008		/* OK to write */
	/* RD and WR are never simultaneously asserted */
#define	__SRW	0x0010		/* open for reading & writing */
#define	__SEOF	0x0020		/* found EOF */
#define	__SERR	0x0040		/* found error */
#define	__SMBF	0x0080		/* _buf is from malloc */
#define	__SAPP	0x0100		/* fdopen()ed in append mode */
#define	__SSTR	0x0200		/* this is an sprintf/snprintf string */
#define	__SOPT	0x0400		/* do fseek() optimisation */
#define	__SNPT	0x0800		/* do not do fseek() optimisation */
#define	__SOFF	0x1000		/* set iff _offset is in fact correct */
#define	__SMOD	0x2000		/* true => fgetln modified _p text */
#define	__SALC	0x4000		/* allocate string space dynamically */
#define __SIGN	0x8000		/* ignore this file in _fwalk */

/*
 * The following three definitions are for ANSI C, which took them
 * from System V, which brilliantly took internal interface macros and
 * made them official arguments to setvbuf(), without renaming them.
 * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
 *
 * Although numbered as their counterparts above, the implementation
 * does not rely on this.
 */
#define	_IOFBF	0		/* setvbuf should set fully buffered */
#define	_IOLBF	1		/* setvbuf should set line buffered */
#define	_IONBF	2		/* setvbuf should set unbuffered */

#define	BUFSIZ	1024		/* size of buffer used by setbuf */

#define	EOF	(-1)

/*
 * FOPEN_MAX is a minimum maximum, and should be the number of descriptors
 * that the kernel can provide without allocation of a resource that can
 * fail without the process sleeping.  Do not use this for anything.
 */
#define	FOPEN_MAX	20	/* must be <= OPEN_MAX <sys/syslimits.h> */
#define	FILENAME_MAX	1024	/* must be <= PATH_MAX <sys/syslimits.h> */

/* System V/ANSI C; this is the wrong way to do this, do *not* use these. */
#if __BSD_VISIBLE || __XPG_VISIBLE
#define	P_tmpdir	"/tmp/"
#endif
#define	L_tmpnam	1024	/* XXX must be == PATH_MAX */
#define	TMP_MAX		0x7fffffff	/* more, but don't overflow int */

#ifndef SEEK_SET
#define	SEEK_SET	0	/* set file offset to offset */
#endif
#ifndef SEEK_CUR
#define	SEEK_CUR	1	/* set file offset to current plus offset */
#endif
#ifndef SEEK_END
#define	SEEK_END	2	/* set file offset to EOF plus offset */
#endif

#define	stdin	(&__sF[0])
#define	stdout	(&__sF[1])
#define	stderr	(&__sF[2])

/*
 * Functions defined in ANSI C standard.
 */
__BEGIN_DECLS
void	 clearerr(FILE *);
#if __POSIX_VISIBLE >= 200809
int	 dprintf(int, const char * __restrict, ...);
#endif
int	 fclose(FILE *);
int	 feof(FILE *);
int	 ferror(FILE *);
int	 fflush(FILE *);
int	 fgetc(FILE *);
int	 fgetpos(FILE *, fpos_t *);
char	*fgets(char *, int, FILE *)
		__attribute__((__bounded__ (__string__,1,2)));
FILE	*fopen(const char *, const char *);
int	 fprintf(FILE *, const char *, ...);
int	 fputc(int, FILE *);
int	 fputs(const char *, FILE *);
size_t	 fread(void *, size_t, size_t, FILE *)
		__attribute__((__bounded__ (__size__,1,3,2)));
FILE	*freopen(const char *, const char *, FILE *);
int	 fscanf(FILE *, const char *, ...);
int	 fseek(FILE *, long, int);
int	 fseeko(FILE *, off_t, int);
int	 fsetpos(FILE *, const fpos_t *);
long	 ftell(FILE *);
off_t	 ftello(FILE *);
size_t	 fwrite(const void *, size_t, size_t, FILE *)
		__attribute__((__bounded__ (__size__,1,3,2)));
int	 getc(FILE *);
int	 getchar(void);
#if __POSIX_VISIBLE >= 200809
ssize_t	 getdelim(char ** __restrict, size_t * __restrict, int,
	    FILE * __restrict);
ssize_t	 getline(char ** __restrict, size_t * __restrict,
	    FILE * __restrict);
#endif
#if __BSD_VISIBLE && !defined(__SYS_ERRLIST)
#define __SYS_ERRLIST

extern int sys_nerr;			/* perror(3) external variables */
extern char *sys_errlist[];
#endif
void	 perror(const char *);
int	 printf(const char *, ...);
int	 putc(int, FILE *);
int	 putchar(int);
int	 puts(const char *);
int	 remove(const char *);
int	 rename(const char *, const char *);
#if __POSIX_VISIBLE >= 200809
int	 renameat(int, const char *, int, const char *);
#endif
void	 rewind(FILE *);
int	 scanf(const char *, ...);
void	 setbuf(FILE *, char *);
int	 setvbuf(FILE *, char *, int, size_t);
int	 sprintf(char *, const char *, ...);
int	 sscanf(const char *, const char *, ...);
FILE	*tmpfile(void);
char	*tmpnam(char *);
int	 ungetc(int, FILE *);
int	 vfprintf(FILE *, const char *, __va_list);
int	 vprintf(const char *, __va_list);
int	 vsprintf(char *, const char *, __va_list);
#if __POSIX_VISIBLE >= 200809
int	 vdprintf(int, const char * __restrict, __va_list);
#endif

#if __ISO_C_VISIBLE >= 1999 || __XPG_VISIBLE >= 500 || __BSD_VISIBLE
int	 snprintf(char *, size_t, const char *, ...)
		__attribute__((__format__ (printf, 3, 4)))
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__ (__string__,1,2)));
int	 vsnprintf(char *, size_t, const char *, __va_list)
		__attribute__((__format__ (printf, 3, 0)))
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__(__string__,1,2)));
#endif /* __ISO_C_VISIBLE >= 1999 || __XPG_VISIBLE >= 500 || __BSD_VISIBLE */

#if __ISO_C_VISIBLE >= 1999 || __BSD_VISIBLE
int	 vfscanf(FILE *, const char *, __va_list)
		__attribute__((__format__ (scanf, 2, 0)))
		__attribute__((__nonnull__ (2)));
int	 vscanf(const char *, __va_list)
		__attribute__((__format__ (scanf, 1, 0)))
		__attribute__((__nonnull__ (1)));
int	 vsscanf(const char *, const char *, __va_list)
		__attribute__((__format__ (scanf, 2, 0)))
		__attribute__((__nonnull__ (2)));
#endif /* __ISO_C_VISIBLE >= 1999 || __BSD_VISIBLE */

__END_DECLS


/*
 * Functions defined in POSIX 1003.1.
 */
#if __BSD_VISIBLE || __POSIX_VISIBLE || __XPG_VISIBLE
#define	L_ctermid	1024	/* size for ctermid(); PATH_MAX */

__BEGIN_DECLS
char	*ctermid(char *);
FILE	*fdopen(int, const char *);
int	 fileno(FILE *);

#if __POSIX_VISIBLE >= 199209
int	 pclose(FILE *);
FILE	*popen(const char *, const char *);
#endif

#if __POSIX_VISIBLE >= 199506
void	 flockfile(FILE *);
int	 ftrylockfile(FILE *);
void	 funlockfile(FILE *);

/*
 * These are normally used through macros as defined below, but POSIX
 * requires functions as well.
 */
int	 getc_unlocked(FILE *);
int	 getchar_unlocked(void);
int	 putc_unlocked(int, FILE *);
int	 putchar_unlocked(int);
#endif /* __POSIX_VISIBLE >= 199506 */

#if __POSIX_VISIBLE >= 200809
FILE	*fmemopen(void *, size_t, const char *);
FILE	*open_memstream(char **, size_t *);
#endif /* __POSIX_VISIBLE >= 200809 */

#if __XPG_VISIBLE
char	*tempnam(const char *, const char *);
#endif
__END_DECLS

#endif /* __BSD_VISIBLE || __POSIX_VISIBLE || __XPG_VISIBLE */

/*
 * Routines that are purely local.
 */
#if __BSD_VISIBLE
__BEGIN_DECLS
int	 asprintf(char **, const char *, ...)
		__attribute__((__format__ (printf, 2, 3)))
		__attribute__((__nonnull__ (2)));
char	*fgetln(FILE *, size_t *);
int	 fpurge(FILE *);
int	 getw(FILE *);
int	 putw(int, FILE *);
void	 setbuffer(FILE *, char *, int);
int	 setlinebuf(FILE *);
int	 vasprintf(char **, const char *, __va_list)
		__attribute__((__format__ (printf, 2, 0)))
		__attribute__((__nonnull__ (2)));
__END_DECLS

/*
 * Stdio function-access interface.
 */
__BEGIN_DECLS
FILE	*funopen(const void *,
		int (*)(void *, char *, int),
		int (*)(void *, const char *, int),
		fpos_t (*)(void *, fpos_t, int),
		int (*)(void *));
__END_DECLS
#define	fropen(cookie, fn) funopen(cookie, fn, 0, 0, 0)
#define	fwopen(cookie, fn) funopen(cookie, 0, fn, 0, 0)
#endif /* __BSD_VISIBLE */

/*
 * Functions internal to the implementation.
 */
__BEGIN_DECLS
int	__srget(FILE *);
int	__swbuf(int, FILE *);
__END_DECLS

/*
 * The __sfoo macros are here so that we can 
 * define function versions in the C library.
 */
#define	__sgetc(p) (--(p)->_r < 0 ? __srget(p) : (int)(*(p)->_p++))
static __inline int __sputc(int _c, FILE *_p) {
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
		return (*_p->_p++ = _c);
	else
		return (__swbuf(_c, _p));
}

#define	__sfeof(p)	(((p)->_flags & __SEOF) != 0)
#define	__sferror(p)	(((p)->_flags & __SERR) != 0)
#define	__sclearerr(p)	((void)((p)->_flags &= ~(__SERR|__SEOF)))
#define	__sfileno(p)	((p)->_file)

extern int __isthreaded;

#define feof(p)		(!__isthreaded ? __sfeof(p) : (feof)(p))
#define ferror(p)	(!__isthreaded ? __sferror(p) : (ferror)(p))
#define clearerr(p)	(!__isthreaded ? __sclearerr(p) : (clearerr)(p))

#if __POSIX_VISIBLE
#define fileno(p)	(!__isthreaded ? __sfileno(p) : (fileno)(p))
#endif

#define getc(fp)	(!__isthreaded ? __sgetc(fp) : (getc)(fp))

#if __BSD_VISIBLE
/*
 * The macro implementations of putc and putc_unlocked are not
 * fully POSIX compliant; they do not set errno on failure
 */
#define putc(x, fp)	(!__isthreaded ? __sputc(x, fp) : (putc)(x, fp))
#endif /* __BSD_VISIBLE */

#if __POSIX_VISIBLE >= 199506
#define	getc_unlocked(fp)	__sgetc(fp)
/*
 * The macro implementations of putc and putc_unlocked are not
 * fully POSIX compliant; they do not set errno on failure
 */
#if __BSD_VISIBLE
#define putc_unlocked(x, fp)	__sputc(x, fp)
#endif /* __BSD_VISIBLE */
#endif /* __POSIX_VISIBLE >= 199506 */

#define	getchar()	getc(stdin)
#define	putchar(x)	putc(x, stdout)
#define getchar_unlocked()	getc_unlocked(stdin)
#define putchar_unlocked(c)	putc_unlocked(c, stdout)

#endif /* _STDIO_H_ */
@


1.52
log
@remove cpp version of __sputc, since the inline version is all we have
ever used.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.51 2016/03/14 20:43:03 millert Exp $	*/
d42 1
a56 10
#endif

#ifndef NULL
#ifdef 	__GNUG__
#define	NULL	__null
#elif defined(__cplusplus)
#define	NULL	0L
#else
#define	NULL	((void *)0)
#endif
@


1.51
log
@Expose snprintf() and vsnprintf() for XPG 5.  It predates C99 but
still specified snprintf() and vsnprintf() based on earlier drafts.
Allows snprintf() and vsnprintf() to be used when _XOPEN_SOURCE is
defined as 500.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.50 2015/01/20 22:09:50 tedu Exp $	*/
a395 1
#if defined(__GNUC__)
a401 13
#else
/*
 * This has been tuned to generate reasonable code on the vax using pcc.
 */
#define	__sputc(c, p) \
	(--(p)->_w < 0 ? \
		(p)->_w >= (p)->_lbfsize ? \
			(*(p)->_p = (c)), *(p)->_p != '\n' ? \
				(int)*(p)->_p++ : \
				__swbuf('\n', p) : \
			__swbuf((int)(c), p) : \
		(*(p)->_p = (c), (int)*(p)->_p++))
#endif
@


1.50
log
@increase TMP_MAX to the equivalent of INT_MAX. it's actually more,
but safer not to wraparound by accident.
ok deraadt millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.49 2014/03/27 15:28:16 tedu Exp $	*/
d281 1
a281 1
#if __ISO_C_VISIBLE >= 1999 || __BSD_VISIBLE
d286 7
a298 4
int	 vsnprintf(char *, size_t, const char *, __va_list)
		__attribute__((__format__ (printf, 3, 0)))
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__(__string__,1,2)));
@


1.49
log
@safe to remove gets, now that's gone from cstdio too
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.48 2014/03/25 15:55:15 tedu Exp $	*/
d194 1
a194 1
#define	TMP_MAX		308915776
@


1.48
log
@try to put the pin back in.
removing gets means removing it from libstdc++ and guenther tells me
that will require changing version numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.46 2014/03/16 18:38:30 guenther Exp $	*/
a248 1
char	*gets(char *);
@


1.47
log
@no gets
@
text
@d249 1
a249 1

@


1.46
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.45 2013/12/04 22:58:24 deraadt Exp $	*/
d249 1
a249 1
char	*gets(char *);
@


1.45
log
@express final disapproval of the interfaces in libcompat, such as
them ftime(), gtty(), stty(), re_comp(), cuserid() and others.
Discussion and ongoing work to fix the ports tree from many, especially
naddy.
ok naddy
[There is a bit more cleanup possible after that, but this is considered
the current safe step]
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.44 2013/03/28 16:37:14 eric Exp $	*/
a439 1
#ifndef lint
a449 1
#endif /* lint */
@


1.44
log
@Enable fmemopen(3) and open_{w,}memstream(3)

commiting on behalf of mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.43 2013/01/30 00:08:13 brad Exp $	*/
a309 1
#define L_cuserid	9	/* size for cuserid(); UT_NAMESIZE + 1 */
a312 1
char	*cuserid(char *);
@


1.43
log
@Add support for POSIX.1-2008 functions dprintf(3) and vdprintf(3).

Feedback from millert@@ guenther@@
OK guenther@@ man page bits OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.42 2012/03/21 23:44:35 fgsch Exp $	*/
d337 5
@


1.42
log
@Implement getdelim(3) and getline(3).
Prompted in a mail to tech@@ by Jan Klemkow (j-dot-klemkow-at-wemelug-dot-de)
but this is based on NetBSD's implementation instead with some tweaks by me.
Further improvements would happen in tree.

ok millert@@; discussed with many others
ports cleanup by naddy@@, sthen@@. Antti Harri, Gonzalo L. R. and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.41 2011/07/18 17:29:49 matthew Exp $	*/
d215 3
d278 3
@


1.41
log
@Expose a bunch of new functionality from POSIX 2008: openat(2),
fchmodat(2), fstatat(2), mkdirat(2), mkfifoat(2), mknodat(2),
faccessat(2), fchownat(2), linkat(2), readlinkat(2), renameat(2),
symlinkat(2), unlinkat(2), utimensat(2), futimens(2), and
fdopendir(3).

"Minor" libc bump.

Tested in a bulk build by naddy@@
Much help from guenther@@, thib@@, tedu@@, oga@@, and others.
ok deraadt@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.40 2011/07/03 18:51:01 jsg Exp $	*/
d240 6
@


1.40
log
@As pointed out by Richard Guenther our definition
of NULL was incorrect for c++ compilers that aren't
gcc (or pretend to be gcc like clang).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.39 2011/04/06 11:39:42 miod Exp $	*/
d254 3
@


1.39
log
@Define NULL as a void * instead of a long integer, as required by Single Unix.
Kernel and bootblocks still use the old 0L value until all the NULL abuses
in the code are fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.38 2009/11/09 00:18:27 kurt Exp $	*/
d61 2
@


1.38
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.37 2009/10/22 01:23:16 guenther Exp $	*/
d62 1
a62 1
#define	NULL	0L
@


1.37
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.36 2009/10/21 16:04:23 guenther Exp $	*/
d160 1
a325 6
#ifndef _POSIX_THREADS
#  define flockfile(fp)			/* nothing */
#  define ftrylockfile(fp)		(0)
#  define funlockfile(fp)		/* nothing */
#endif

d400 1
a400 2
#define	feof(p)		__sfeof(p)
#define	ferror(p)	__sferror(p)
d402 3
a404 3
#ifndef _POSIX_THREADS
#define	clearerr(p)	__sclearerr(p)
#endif
d407 1
a407 1
#define	fileno(p)	__sfileno(p)
d410 10
d421 1
a421 3
#ifndef _POSIX_THREADS
#define	getc(fp)	__sgetc(fp)
#endif /* _POSIX_THREADS */
a427 3
#ifndef _POSIX_THREADS
#define putc(x, fp)	__sputc(x, fp)
#endif /* _POSIX_THREADS */
d430 1
@


1.36
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.35 2006/01/13 18:10:09 miod Exp $	*/
a159 1
#define __SIGN	0x8000		/* ignore this file in _fwalk */
d325 6
d405 2
a406 1
extern int __isthreaded;
d408 3
a410 3
#define feof(p)		(!__isthreaded ? __sfeof(p) : (feof)(p))
#define ferror(p)	(!__isthreaded ? __sferror(p) : (ferror)(p))
#define clearerr(p)	(!__isthreaded ? __sclearerr(p) : (clearerr)(p))
d413 1
a413 1
#define fileno(p)	(!__isthreaded ? __sfileno(p) : (fileno)(p))
a415 10
#define getc(fp)	(!__isthreaded ? __sgetc(fp) : (getc)(fp))

#if __BSD_VISIBLE
/*
 * The macro implementations of putc and putc_unlocked are not
 * fully POSIX compliant; they do not set errno on failure
 */
#define putc(x, fp)	(!__isthreaded ? __sputc(x, fp) : (putc)(x, fp))
#endif /* __BSD_VISIBLE */

d417 3
a419 1
#if __POSIX_VISIBLE >= 199506
d426 3
a430 1
#endif /* __POSIX_VISIBLE >= 199506 */
@


1.35
log
@Remove neither documented nor found in any spec ctermid_r() function - ctermid()
is reentrant in its current implementation anyway.
Surfing on the recent major version bump, ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.34 2006/01/06 18:53:04 millert Exp $	*/
d160 1
a325 6
#ifndef _POSIX_THREADS
#  define flockfile(fp)			/* nothing */
#  define ftrylockfile(fp)		(0)
#  define funlockfile(fp)		/* nothing */
#endif

d400 1
a400 2
#define	feof(p)		__sfeof(p)
#define	ferror(p)	__sferror(p)
d402 3
a404 3
#ifndef _POSIX_THREADS
#define	clearerr(p)	__sclearerr(p)
#endif
d407 1
a407 1
#define	fileno(p)	__sfileno(p)
d410 10
d421 1
a421 3
#ifndef _POSIX_THREADS
#define	getc(fp)	__sgetc(fp)
#endif /* _POSIX_THREADS */
a427 3
#ifndef _POSIX_THREADS
#define putc(x, fp)	__sputc(x, fp)
#endif /* _POSIX_THREADS */
d430 1
@


1.34
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.33 2005/12/13 00:35:22 millert Exp $	*/
a295 1
char	*ctermid_r(char *);
@


1.33
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.32 2005/05/11 18:39:19 espie Exp $	*/
d42 1
d45 1
a45 1
#include <sys/types.h>
d48 3
a50 5
#include <machine/ansi.h>

#ifdef	_BSD_SIZE_T_
typedef	_BSD_SIZE_T_	size_t;
#undef	_BSD_SIZE_T_
d53 3
a55 3
#ifdef	_BSD_OFF_T_
typedef	_BSD_OFF_T_	off_t;
#undef	_BSD_OFF_T_
d260 3
a262 3
int	 vfprintf(FILE *, const char *, _BSD_VA_LIST_);
int	 vprintf(const char *, _BSD_VA_LIST_);
int	 vsprintf(char *, const char *, _BSD_VA_LIST_);
d269 1
a269 1
int	 vfscanf(FILE *, const char *, _BSD_VA_LIST_)
d272 1
a272 1
int	 vscanf(const char *, _BSD_VA_LIST_)
d275 1
a275 1
int	 vsnprintf(char *, size_t, const char *, _BSD_VA_LIST_)
d279 1
a279 1
int	 vsscanf(const char *, const char *, _BSD_VA_LIST_)
d348 1
a348 1
int	 vasprintf(char **, const char *, _BSD_VA_LIST_)
@


1.32
log
@let vfscanf be a real function. Use a weak_alias on systems where this
is feasible.

Okay millert@@

There's a major libc bump coming that is going to cover this as well...
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.30 2004/06/07 21:11:23 marc Exp $	*/
d41 3
a43 1
#if !defined(_ANSI_SOURCE) && !defined(__STRICT_ANSI__)
a46 1
#include <sys/cdefs.h>
d188 1
a188 1
#ifndef _ANSI_SOURCE
d239 1
a239 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE) && !defined(__SYS_ERRLIST)
d264 21
d287 1
d291 1
a291 1
#ifndef _ANSI_SOURCE
d301 7
d311 5
d317 1
a318 1
int	 getchar_unlocked(void);
d320 5
d333 1
a333 2

#endif /* not ANSI */
d338 1
a338 1
#if !defined (_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
a345 2
int	 pclose(FILE *);
FILE	*popen(const char *, const char *);
a348 5
char	*tempnam(const char *, const char *);
int	 snprintf(char *, size_t, const char *, ...)
		__attribute__((__format__ (printf, 3, 4)))
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__ (__string__,1,2)));
a351 13
int	 vsnprintf(char *, size_t, const char *, _BSD_VA_LIST_)
		__attribute__((__format__ (printf, 3, 0)))
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__(__string__,1,2)));
int	 vscanf(const char *, _BSD_VA_LIST_)
		__attribute__((__format__ (scanf, 1, 0)))
		__attribute__((__nonnull__ (1)));
int	 vsscanf(const char *, const char *, _BSD_VA_LIST_)
		__attribute__((__format__ (scanf, 2, 0)))
		__attribute__((__nonnull__ (2)));
int	 vfscanf(FILE *, const char *, _BSD_VA_LIST_)
		__attribute__((__format__ (scanf, 2, 0)))
		__attribute__((__nonnull__ (2)));
d366 1
a366 1
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
d414 1
a414 1
#ifndef _ANSI_SOURCE
d427 1
a427 1
#ifndef _POSIX_SOURCE
d432 1
a432 1
#endif /* _POSIX_SOURCE */
@


1.31
log
@Change internals of FILE: reuse the unget buffer field to access an
extended attribute data structure (pimpl idiom). Idea taken from citrus.
Much discussion with deraadt@@, otto@@, millert@@...

This is the least disruptive way to extend FILE, since its size can't really
change without this being a flag day. So the size doesn't change.

Actual additions to the structure will come in separate steps, since this
change is nasty enough on its own.

Tests by otto@@ and others, careful reading of code by otto@@ and millert@@.

This is definitely a major bump, and has been checked to not impact a
full ports build.
@
text
@d330 3
a335 7
 * This is a #define because the function is used internally and
 * (unlike vfscanf) the name __svfscanf is guaranteed not to collide
 * with a user function when _ANSI_SOURCE or _POSIX_SOURCE is defined.
 */
#define	 vfscanf	__svfscanf

/*
a353 1
int	__svfscanf(FILE *, const char *, _BSD_VA_LIST_);
@


1.30
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.29 2003/08/01 17:38:33 avsm Exp $	*/
d122 3
a124 2
	/* separate buffer for long sequences of ungetc() */
	struct	__sbuf _ub;	/* ungetc buffer */
@


1.29
log
@add __bounded__ attributes for userland headers; enabled with -Wbounded
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.28 2003/06/26 19:34:17 avsm Exp $	*/
a279 1
void	 _flockfile_debug(FILE *, char *, int);
a289 1
#  define _flockfile_debug(fp,f,l)	/* nothing */
a291 3
#if 0 /* defined(DEBUG_FLOCKFILE) && defined(_POSIX_THREADS) */
#  define flockfile(fp)		_flockfile_debug(fp, __FILE__, __LINE__)
#endif
@


1.28
log
@backout the __bounded__ attributes for a while; requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.26 2003/06/02 19:34:12 millert Exp $	*/
d217 2
a218 1
char	*fgets(char *, int, FILE *);
d223 2
a224 1
size_t	 fread(void *, size_t, size_t, FILE *);
d232 2
a233 1
size_t	 fwrite(const void *, size_t, size_t, FILE *);
d319 2
a320 1
		__attribute__((__nonnull__ (3)));
d326 2
a327 1
		__attribute__((__nonnull__ (3)));
@


1.27
log
@Mark various standard library functions with the __bounded__ attribute.
You must have an up-to-date gcc for this!
deraadt@@ ok
@
text
@d217 1
a217 2
char	*fgets(char *, int, FILE *)
		__attribute__((__bounded__ (__string__,1,2)));
d222 1
a222 2
size_t	 fread(void *, size_t, size_t, FILE *)
		__attribute__((__bounded__ (__size__,1,3,2)));
d230 1
a230 2
size_t	 fwrite(const void *, size_t, size_t, FILE *)
		__attribute__((__bounded__ (__size__,1,3,2)));
d316 1
a316 2
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__ (__string__,1,2)));
d322 1
a322 2
		__attribute__((__nonnull__ (3)))
		__attribute__((__bounded__(__string__,1,2)));
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.25 2002/12/30 21:36:06 millert Exp $	*/
d217 2
a218 1
char	*fgets(char *, int, FILE *);
d223 2
a224 1
size_t	 fread(void *, size_t, size_t, FILE *);
d232 2
a233 1
size_t	 fwrite(const void *, size_t, size_t, FILE *);
d319 2
a320 1
		__attribute__((__nonnull__ (3)));
d326 2
a327 1
		__attribute__((__nonnull__ (3)));
@


1.25
log
@Back out __EOF stuff and just use -1 in ctype.h.  This is OK since
we don't want any user defines to change how the inlined ctype
functions behave.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.24 2002/12/29 03:02:34 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@Don't define EOF In ctype.h, some 3rd party code checks whether or
not EOF is defined to determine if stdio.h has been included.
Instead, use __EOF which should be OK wrt namespace safety.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.23 2002/10/25 21:55:28 millert Exp $	*/
d179 1
a179 4
#ifndef	__EOF
#define	__EOF	(-1)
#endif
#define	EOF	__EOF
@


1.23
log
@NULL is now 0L so it is the same size as a pointer.
OK mickey@@ and discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.22 2002/02/19 19:39:36 millert Exp $	*/
d178 5
a182 1
#define	EOF	(-1)
@


1.22
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.21 2002/02/17 19:42:21 millert Exp $	*/
d66 1
a66 1
#define	NULL	0
@


1.21
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.20 2002/02/16 21:27:17 millert Exp $	*/
d369 1
a369 1
#if defined(__GNUC__) && defined(__STDC__)
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.19 2001/11/02 00:19:10 espie Exp $	*/
d345 1
a345 1
FILE	*funopen __P((const void *,
d349 1
a349 1
		int (*)(void *)));
@


1.19
log
@attribute(format) no longer implies nonnull...
ok millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.18 2001/09/04 22:17:44 fgsch Exp $	*/
d121 4
a124 4
	int	(*_close) __P((void *));
	int	(*_read)  __P((void *, char *, int));
	fpos_t	(*_seek)  __P((void *, fpos_t, int));
	int	(*_write) __P((void *, const char *, int));
d213 24
a236 24
void	 clearerr __P((FILE *));
int	 fclose __P((FILE *));
int	 feof __P((FILE *));
int	 ferror __P((FILE *));
int	 fflush __P((FILE *));
int	 fgetc __P((FILE *));
int	 fgetpos __P((FILE *, fpos_t *));
char	*fgets __P((char *, int, FILE *));
FILE	*fopen __P((const char *, const char *));
int	 fprintf __P((FILE *, const char *, ...));
int	 fputc __P((int, FILE *));
int	 fputs __P((const char *, FILE *));
size_t	 fread __P((void *, size_t, size_t, FILE *));
FILE	*freopen __P((const char *, const char *, FILE *));
int	 fscanf __P((FILE *, const char *, ...));
int	 fseek __P((FILE *, long, int));
int	 fseeko __P((FILE *, off_t, int));
int	 fsetpos __P((FILE *, const fpos_t *));
long	 ftell __P((FILE *));
off_t	 ftello __P((FILE *));
size_t	 fwrite __P((const void *, size_t, size_t, FILE *));
int	 getc __P((FILE *));
int	 getchar __P((void));
char	*gets __P((char *));
d243 19
a261 19
void	 perror __P((const char *));
int	 printf __P((const char *, ...));
int	 putc __P((int, FILE *));
int	 putchar __P((int));
int	 puts __P((const char *));
int	 remove __P((const char *));
int	 rename  __P((const char *, const char *));
void	 rewind __P((FILE *));
int	 scanf __P((const char *, ...));
void	 setbuf __P((FILE *, char *));
int	 setvbuf __P((FILE *, char *, int, size_t));
int	 sprintf __P((char *, const char *, ...));
int	 sscanf __P((const char *, const char *, ...));
FILE	*tmpfile __P((void));
char	*tmpnam __P((char *));
int	 ungetc __P((int, FILE *));
int	 vfprintf __P((FILE *, const char *, _BSD_VA_LIST_));
int	 vprintf __P((const char *, _BSD_VA_LIST_));
int	 vsprintf __P((char *, const char *, _BSD_VA_LIST_));
d272 13
a284 13
char	*ctermid __P((char *));
char	*ctermid_r __P((char *));
char	*cuserid __P((char *));
FILE	*fdopen __P((int, const char *));
int	 fileno __P((FILE *));
void	 flockfile __P((FILE *));
int	 ftrylockfile __P((FILE *));
void	 funlockfile __P((FILE *));
void	 _flockfile_debug __P((FILE *, char *, int));
int	 getc_unlocked __P((FILE *));
int	 putc_unlocked __P((int, FILE *));
int	 getchar_unlocked __P((void));
int	 putchar_unlocked __P((int));
d305 1
a305 1
int	 asprintf __P((char **, const char *, ...))
d308 10
a317 10
char	*fgetln __P((FILE *, size_t *));
int	 fpurge __P((FILE *));
int	 getw __P((FILE *));
int	 pclose __P((FILE *));
FILE	*popen __P((const char *, const char *));
int	 putw __P((int, FILE *));
void	 setbuffer __P((FILE *, char *, int));
int	 setlinebuf __P((FILE *));
char	*tempnam __P((const char *, const char *));
int	 snprintf __P((char *, size_t, const char *, ...))
d320 1
a320 1
int	 vasprintf __P((char **, const char *, _BSD_VA_LIST_))
d323 1
a323 1
int	 vsnprintf __P((char *, size_t, const char *, _BSD_VA_LIST_))
d326 1
a326 1
int	 vscanf __P((const char *, _BSD_VA_LIST_))
d329 1
a329 1
int	 vsscanf __P((const char *, const char *, _BSD_VA_LIST_))
d359 3
a361 3
int	__srget __P((FILE *));
int	__svfscanf __P((FILE *, const char *, _BSD_VA_LIST_));
int	__swbuf __P((int, FILE *));
@


1.18
log
@put changes back, this time ALL the files.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.17 2001/08/30 17:47:57 todd Exp $	*/
d306 2
a307 1
		__attribute__((__format__ (printf, 2, 3)));
d318 2
a319 1
		__attribute__((__format__ (printf, 3, 4)));
d321 2
a322 1
		__attribute__((__format__ (printf, 2, 0)));
d324 2
a325 1
		__attribute__((__format__ (printf, 3, 0)));
d327 2
a328 1
		__attribute__((__format__ (scanf, 1, 0)));
d330 2
a331 1
		__attribute__((__format__ (scanf, 2, 0)));
@


1.17
log
@Back out fgsch@@'s tree breaking commits.
Test next time, ok?
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.16 2001/08/30 07:38:27 fgsch Exp $	*/
d280 1
a280 1
void	 _flockfile_debug __P((FILE *, const char *, int));
@


1.16
log
@fix some const warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.15 2000/12/06 17:18:42 deraadt Exp $	*/
d280 1
a280 1
void	 _flockfile_debug __P((FILE *, char *, int));
@


1.15
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.14 2000/03/04 17:16:02 millert Exp $	*/
d280 1
a280 1
void	 _flockfile_debug __P((FILE *, const char *, int));
@


1.14
log
@Make P_tmpdir point to /tmp/ not /var/tmp
Really, there should be a way to make configurable by the admin
at runtime (say, a gettmpdir() function).
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.13 2000/02/22 17:29:12 millert Exp $	*/
d306 1
a306 1
		__attribute__((format (printf, 2, 3)));
d317 1
a317 1
		__attribute__((format (printf, 3, 4)));
d319 1
a319 1
		__attribute__((format (printf, 2, 0)));
d321 1
a321 1
		__attribute__((format (printf, 3, 0)));
d323 1
a323 1
		__attribute__((format (scanf, 1, 0)));
d325 1
a325 1
		__attribute__((format (scanf, 2, 0)));
@


1.13
log
@Use an _BSD_FOO_T_ type declaration for off_t in machine/ansi.h to allow
off_t to be visible in stdio.h even in strict ansi mode.  This is needed
for ftello()/fseeko() and it allows us to remove the horrible fpos_t hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.12 2000/02/21 22:11:20 millert Exp $	*/
d190 1
a190 1
#define	P_tmpdir	"/var/tmp/"
@


1.12
log
@Add fseeko() and ftello() -- versions of fseek() and ftell() that use off_t.
Also make fsetpos() and fgetpos() use fseeko() and ftello() respectively
since fpos_t is actually a 64bit type.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.11 1999/09/17 13:13:46 espie Exp $	*/
d50 1
a51 1
#include <machine/ansi.h>
d57 5
d70 1
a70 13
/*      
 * This is fairly grotesque, but pure ANSI code must not inspect the
 * innards of an fpos_t anyway.  The library internally uses off_t,
 * which we assume is exactly as big as eight chars.
 */
#if !defined(_ANSI_SOURCE) && !defined(__STRICT_ANSI__)
typedef off_t fpos_t;
#else
typedef struct __sfpos {
	/* LONGLONG */
	long long _pos;			/* XXX must be the same as off_t */
} fpos_t;
#endif
d72 1
a72 1
#define	_FSTDIO			/* Define for new stdio with functions. */
@


1.11
log
@Be thorough about NULL as __null for C++.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.10 1998/11/20 11:18:26 d Exp $	*/
d236 1
d239 1
@


1.10
log
@Add thread-safety to libc, so that libc_r will build (on i386 at least).
All POSIX libc api now there (to P1003.1c/D10)
  (more md stuff is needed for other libc/arch/*)
  (setlogin is no longer a special syscall)
Add -pthread option to gcc (that makes it use -lc_r and -D_POSIX_THREADS).
Doc some re-entrant routines
Add libc_r to intro(3)
dig() uses some libc srcs and an extra -I was needed there.
Add more md stuff to libc_r.
Update includes for the pthreads api
Update libc_r TODO
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.9 1997/11/29 20:01:03 millert Exp $	*/
d58 3
d62 1
@


1.9
log
@Add __attribute__ for asprintf.
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.8 1997/11/29 19:54:51 millert Exp $	*/
d274 1
d278 8
d287 12
d392 2
d395 1
d402 1
d404 2
d407 2
a408 2
 * The macro implementation of putc is not fully POSIX
 * compliant; it does not set errno on failure
d411 1
d413 2
d420 3
@


1.8
log
@Implement asprintf(3) and vasprintf(3) functions similar to the
ones in the glibc.  Some man pages changes from FreeBSD
(asprintf.c/vasprintf.c are not based on GNU or FreeBSD code).
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.7 1996/10/28 06:51:05 tholo Exp $	*/
d285 2
a286 1
int	 asprintf __P((char **, const char *, ...));
@


1.7
log
@Do not enable putc() macro implementation if _POSIX_SOURCE is defined;
it is not fully compliant
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.6 1996/07/26 10:34:25 deraadt Exp $	*/
d165 1
d285 1
d297 2
@


1.6
log
@export non-constipated sys_errlist[] to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: stdio.h,v 1.5 1996/07/25 05:47:59 downsj Exp $	*/
d374 5
d380 1
@


1.5
log
@Partially revert back to the old behaviour of declaring sys_errlist here.

sys/errno.h can declare it as well.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d241 1
a241 1
extern const char *const sys_errlist[];
@


1.4
log
@typo in __STRICT_ANSI__
@
text
@d1 1
d237 6
@


1.3
log
@Prefix "long long" with "/* LONGLONG */" to shut up lint(1)
@
text
@d1 1
a1 1
/*	$NetBSD: stdio.h,v 1.17 1996/01/20 01:36:30 jtc Exp $	*/
d44 1
a44 1
#if !defined(_ANSI_SOURCE) && !defined(__STRICT_ANSI_)
@


1.2
log
@from netbsd; move sys_nerr/sys_errlist decls to errno.h
@
text
@d69 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: stdio.h,v 1.16 1995/03/25 02:51:02 jtc Exp $	*/
a234 4
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
extern int sys_nerr;			/* perror(3) external variables */
extern const char *const sys_errlist[];
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
