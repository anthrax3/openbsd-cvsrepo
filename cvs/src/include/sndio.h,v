head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.10
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.14
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.10
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.20.11.29.29;	author ratchov;	state Exp;
branches;
next	1.8;
commitid	6m1XWJevm3uKBS61;

1.8
date	2012.08.22.08.56.46;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.08.17.55.50;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.23.19.25.11;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.06.20.25.42;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.25.11.27.14;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.25.08.44.26;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.21.19.14.33;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Expose internal functions necessary to open audio devices and midi
ports using existing file descriptors.
@
text
@/*	$OpenBSD: sndio.h,v 1.8 2012/08/22 08:56:46 espie Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef SNDIO_H
#define SNDIO_H

#include <sys/types.h>

/*
 * default audio device and MIDI port
 */
#define SIO_DEVANY	"default"
#define MIO_PORTANY	"default"

/*
 * private ``handle'' structure
 */
struct sio_hdl;
struct mio_hdl;

/*
 * parameters of a full-duplex stream
 */
struct sio_par {
	unsigned int bits;	/* bits per sample */
	unsigned int bps;	/* bytes per sample */
	unsigned int sig;	/* 1 = signed, 0 = unsigned */
	unsigned int le;	/* 1 = LE, 0 = BE byte order */
	unsigned int msb;	/* 1 = MSB, 0 = LSB aligned */
	unsigned int rchan;	/* number channels for recording direction */
	unsigned int pchan;	/* number channels for playback direction */
	unsigned int rate;	/* frames per second */
	unsigned int bufsz;	/* end-to-end buffer size */
#define SIO_IGNORE	0	/* pause during xrun */
#define SIO_SYNC	1	/* resync after xrun */
#define SIO_ERROR	2	/* terminate on xrun */
	unsigned int xrun;	/* what to do on overruns/underruns */
	unsigned int round;	/* optimal bufsz divisor */
	unsigned int appbufsz;	/* minimum buffer size */
	int __pad[3];		/* for future use */
	unsigned int __magic;	/* for internal/debug purposes only */
};

/*
 * capabilities of a stream
 */
struct sio_cap {
#define SIO_NENC	8
#define SIO_NCHAN	8
#define SIO_NRATE	16
#define SIO_NCONF	4
	struct sio_enc {			/* allowed sample encodings */
		unsigned int bits;
		unsigned int bps;
		unsigned int sig;
		unsigned int le;
		unsigned int msb;
	} enc[SIO_NENC];
	unsigned int rchan[SIO_NCHAN];	/* allowed values for rchan */
	unsigned int pchan[SIO_NCHAN];	/* allowed values for pchan */
	unsigned int rate[SIO_NRATE];	/* allowed rates */
	int __pad[7];			/* for future use */
	unsigned int nconf;		/* number of elements in confs[] */
	struct sio_conf {
		unsigned int enc;	/* mask of enc[] indexes */
		unsigned int rchan;	/* mask of chan[] indexes (rec) */
		unsigned int pchan;	/* mask of chan[] indexes (play) */
		unsigned int rate;	/* mask of rate[] indexes */
	} confs[SIO_NCONF];
};

#define SIO_XSTRINGS { "ignore", "sync", "error" }

/*
 * mode bitmap
 */
#define SIO_PLAY	1
#define SIO_REC		2
#define MIO_OUT		4
#define MIO_IN		8

/*
 * default bytes per sample for the given bits per sample
 */
#define SIO_BPS(bits) (((bits) <= 8) ? 1 : (((bits) <= 16) ? 2 : 4))

/*
 * default value of "sio_par->le" flag
 */
#if BYTE_ORDER == LITTLE_ENDIAN
#define SIO_LE_NATIVE 1
#else
#define SIO_LE_NATIVE 0
#endif

/*
 * maximum value of volume, eg. for sio_setvol()
 */
#define SIO_MAXVOL 127

#ifdef __cplusplus
extern "C" {
#endif

struct pollfd;

void sio_initpar(struct sio_par *);
struct sio_hdl *sio_open(const char *, unsigned int, int);
void sio_close(struct sio_hdl *);
int sio_setpar(struct sio_hdl *, struct sio_par *);
int sio_getpar(struct sio_hdl *, struct sio_par *);
int sio_getcap(struct sio_hdl *, struct sio_cap *);
void sio_onmove(struct sio_hdl *, void (*)(void *, int), void *);
size_t sio_write(struct sio_hdl *, const void *, size_t);
size_t sio_read(struct sio_hdl *, void *, size_t);
int sio_start(struct sio_hdl *);
int sio_stop(struct sio_hdl *);
int sio_nfds(struct sio_hdl *);
int sio_pollfd(struct sio_hdl *, struct pollfd *, int);
int sio_revents(struct sio_hdl *, struct pollfd *);
int sio_eof(struct sio_hdl *);
int sio_setvol(struct sio_hdl *, unsigned int);
int sio_onvol(struct sio_hdl *, void (*)(void *, unsigned int), void *);

struct mio_hdl *mio_open(const char *, unsigned int, int);
void mio_close(struct mio_hdl *);
size_t mio_write(struct mio_hdl *, const void *, size_t);
size_t mio_read(struct mio_hdl *, void *, size_t);
int mio_nfds(struct mio_hdl *);
int mio_pollfd(struct mio_hdl *, struct pollfd *, int);
int mio_revents(struct mio_hdl *, struct pollfd *);
int mio_eof(struct mio_hdl *);

int mio_rmidi_getfd(const char *, unsigned int, int);
struct mio_hdl *mio_rmidi_fdopen(int, unsigned int, int);
int sio_sun_getfd(const char *, unsigned int, int);
struct sio_hdl *sio_sun_fdopen(int, unsigned int, int);

#ifdef __cplusplus
}
#endif

#endif /* !defined(SNDIO_H) */
@


1.8
log
@hex constants unsigned, prevents some gcc warnings
okay ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.7 2012/07/08 17:55:50 ratchov Exp $	*/
d146 5
@


1.7
log
@Include sys/types.h rather than sys/param.h to pull BYTE_ORDER macros.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.6 2012/05/23 19:25:11 ratchov Exp $	*/
d54 1
a54 1
	int __magic;		/* for internal/debug purposes only */
@


1.6
log
@Make the "default" string a valid device name that has the same effect
as NULL has. This will (hopefully) simplify ports where the user
passes the device string.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.5 2012/04/11 06:05:43 ratchov Exp $	*/
d20 1
a20 1
#include <sys/param.h>
@


1.5
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.4 2010/11/06 20:25:42 ratchov Exp $	*/
d21 6
@


1.4
log
@make sio_onvol(3) return a integer exposing whether a volume knob
is available for the stream. As we're at it, remove macros and
functions that are neither used nor documented.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 9
a40 9
	unsigned bits;		/* bits per sample */
	unsigned bps;		/* bytes per sample */
	unsigned sig;		/* 1 = signed, 0 = unsigned */
	unsigned le;		/* 1 = LE, 0 = BE byte order */
	unsigned msb;		/* 1 = MSB, 0 = LSB aligned */
	unsigned rchan;		/* number channels for recording direction */
	unsigned pchan;		/* number channels for playback direction */
	unsigned rate;		/* frames per second */
	unsigned bufsz;		/* end-to-end buffer size */
d44 3
a46 3
	unsigned xrun;		/* what to do on overruns/underruns */
	unsigned round;		/* optimal bufsz divisor */
	unsigned appbufsz;	/* minimum buffer size */
d60 5
a64 5
		unsigned bits;
		unsigned bps;
		unsigned sig;
		unsigned le;
		unsigned msb;
d66 3
a68 3
	unsigned rchan[SIO_NCHAN];	/* allowed values for rchan */
	unsigned pchan[SIO_NCHAN];	/* allowed values for pchan */
	unsigned rate[SIO_NRATE];	/* allowed rates */
d70 1
a70 1
	unsigned nconf;			/* number of elements in confs[] */
d72 4
a75 4
		unsigned enc;		/* mask of enc[] indexes */
		unsigned rchan;		/* mask of chan[] indexes (rec) */
		unsigned pchan;		/* mask of chan[] indexes (play) */
		unsigned rate;		/* mask of rate[] indexes */
d115 1
a115 1
struct sio_hdl *sio_open(const char *, unsigned, int);
d129 2
a130 2
int sio_setvol(struct sio_hdl *, unsigned);
int sio_onvol(struct sio_hdl *, void (*)(void *, unsigned), void *);
d132 1
a132 1
struct mio_hdl *mio_open(const char *, unsigned, int);
@


1.3
log
@use const qualifier in libsndio, making it slightly more consistent
with open(2) and write(2) syscalls.
from Thomas Pfaff, jakemsr is fine with it
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.2 2009/07/25 08:44:26 ratchov Exp $	*/
a89 6
 * maximum size of the encording string (the longest possible
 * encoding is ``s24le3msb'')
 */
#define SIO_ENCMAX	10

/*
a103 10
 * default device for the sun audio(4) back-end
 */
#define SIO_SUN_PATH	"/dev/audio"

/*
 * default socket name for the aucat(1) back-end
 */
#define SIO_AUCAT_PATH	"default"

/*
a113 2
int sio_strtoenc(struct sio_par *, char *);
int sio_enctostr(struct sio_par *, char *);
a114 1

d130 1
a130 1
void sio_onvol(struct sio_hdl *, void (*)(void *, unsigned), void *);
@


1.2
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.1 2009/04/21 19:14:33 ratchov Exp $	*/
d134 1
a134 1
struct sio_hdl *sio_open(char *, unsigned, int);
d140 1
a140 1
size_t sio_write(struct sio_hdl *, void *, size_t);
d151 1
a151 1
struct mio_hdl *mio_open(char *, unsigned, int);
d153 1
a153 1
size_t mio_write(struct mio_hdl *, void *, size_t);
@


1.1
log
@move src/lib/libsndio/sndio.h into src/include where other include
files leave.

requested by deraadt@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.h,v 1.8 2009/04/13 16:05:50 ratchov Exp $	*/
d26 1
d86 2
d150 9
@

