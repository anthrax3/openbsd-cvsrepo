head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.14
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.6
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.10
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.12
	OPENBSD_5_0:1.17.0.10
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.8
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.6
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.16
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.14
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.09.12.19.35.31;	author guenther;	state Exp;
branches;
next	1.20;
commitid	Fdu065lFXFlsyIuh;

1.20
date	2015.09.25.23.32.51;	author guenther;	state Exp;
branches;
next	1.19;
commitid	6Sqt5EBBE8LeTnNQ;

1.19
date	2012.12.05.23.19.57;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.10.11.46.23;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.04.18.06.35;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.22.21.48.02;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.01.17.38.33;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.26.19.34.17;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.26.18.35.13;	author avsm;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.19.34.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.03.12.14.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.19.42.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.31.22.02.18;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.11.10.06.02;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.21.37.11;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.22.07.31.18;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	97.03.13.19.11.51;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.02.19.19.53.15;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Change the (unused) restimespec member of __res_state from a timespec
to a local equivalent to eliminate a dependency on <sys/time.h> being
included

ok deraadt@@ millert@@
@
text
@/*	$OpenBSD: resolv.h,v 1.20 2015/09/25 23:32:51 guenther Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * ++Copyright++ 1983, 1987, 1989, 1993
 * -
 * Copyright (c) 1983, 1987, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

/*
 *	@@(#)resolv.h	8.1 (Berkeley) 6/2/93
 *	$From: resolv.h,v 8.17 1996/11/26 10:11:20 vixie Exp $
 */

#ifndef _RESOLV_H_
#define	_RESOLV_H_

#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>

/*
 * Revision information.  This is the release date in YYYYMMDD format.
 * It can change every day so the right thing to do with it is use it
 * in preprocessor commands such as "#if (__RES > 19931104)".  Do not
 * compare for equality; rather, use it to determine whether your resolver
 * is new enough to contain a certain feature.
 */

#define	__RES	19960801

/*
 * Resolver configuration file.
 * Normally not present, but may contain the address of the
 * initial name server(s) to query and the domain search list.
 */

#ifndef _PATH_RESCONF
#define _PATH_RESCONF        "/etc/resolv.conf"
#endif

/*
 * Global defines and variables for resolver stub.
 */
#define	MAXNS			3	/* max # name servers we'll track */
#define	MAXDFLSRCH		3	/* # default domain levels to try */
#define	MAXDNSRCH		6	/* max # domains in search path */
#define	LOCALDOMAINPARTS	2	/* min levels in name that is "local" */
#define MAXDNSLUS		4	/* max # of host lookup types */

#define	RES_TIMEOUT		5	/* min. seconds between retries */
#define	MAXRESOLVSORT		10	/* number of net to sort on */
#define	RES_MAXNDOTS		15	/* should reflect bit field size */

struct __res_state {
	int	retrans;	 	/* retransmission time interval */
	int	retry;			/* number of times to retransmit */
	unsigned int	options;	/* option flags - see below. */
	int	nscount;		/* number of name servers */
	int	family[2];		/* specifies which address
					 * families will be queried and
					 * in which order */
	struct sockaddr_in
		nsaddr_list[MAXNS];	/* address of name server */
#define	nsaddr	nsaddr_list[0]		/* for backward compatibility */
	unsigned short	id;		/* current message id */
	char	*dnsrch[MAXDNSRCH+1];	/* components of domain to search */
	char	defdname[256];		/* default domain (deprecated) */
	unsigned int	pfcode;		/* RES_PRF_ flags - see below. */
	unsigned ndots:4;		/* threshold for initial abs. query */
	unsigned nsort:4;		/* number of elements in sort_list[] */
	char	unused[3];
	struct {
		struct in_addr	addr;
		u_int32_t	mask;
	} sort_list[MAXRESOLVSORT];
	char    lookups[MAXDNSLUS];
	struct { time_t __res_sec; long __res_nsec; } restimespec;
	time_t	reschktime;
};

#if 1 /* INET6 */
/*
 * replacement of __res_state, separated to keep binary compatibility.
 */
struct __res_state_ext {
	struct sockaddr_storage nsaddr_list[MAXNS];
	struct {
		int	af;		/* address family for addr, mask */
		union {
			struct in_addr ina;
			struct in6_addr in6a;
		} addr, mask;
	} sort_list[MAXRESOLVSORT];
};
#endif


/*
 * Resolver options (keep these in synch with res_debug.c, please)
 */
#define RES_INIT	0x00000001	/* address initialized */
#define RES_DEBUG	0x00000002	/* print debug messages */
#define RES_AAONLY	0x00000004	/* authoritative answers only (!IMPL)*/
#define RES_USEVC	0x00000008	/* use virtual circuit */
#define RES_PRIMARY	0x00000010	/* query primary server only (!IMPL) */
#define RES_IGNTC	0x00000020	/* ignore trucation errors */
#define RES_RECURSE	0x00000040	/* recursion desired */
#define RES_DEFNAMES	0x00000080	/* use default domain name */
#define RES_STAYOPEN	0x00000100	/* Keep TCP socket open */
#define RES_DNSRCH	0x00000200	/* search up local domain tree */
#define	RES_INSECURE1	0x00000400	/* type 1 security disabled */
#define	RES_INSECURE2	0x00000800	/* type 2 security disabled */
#define	RES_NOALIASES	0x00001000	/* shuts off HOSTALIASES feature */
#define	RES_USE_INET6	0x00002000	/* use/map IPv6 in gethostbyname() */
/* KAME extensions: use higher bit to avoid conflict with ISC use */
#define	RES_USE_EDNS0	0x40000000	/* use EDNS0 */
/* DNSSEC extensions: use higher bit to avoid conflict with ISC use */
#define	RES_USE_DNSSEC	0x20000000	/* use DNSSEC using OK bit in OPT */

#define RES_DEFAULT	(RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)

/*
 * Resolver "pfcode" values.  Used by dig.
 */
#define RES_PRF_STATS	0x00000001
/*			0x00000002	*/
#define RES_PRF_CLASS   0x00000004
#define RES_PRF_CMD	0x00000008
#define RES_PRF_QUES	0x00000010
#define RES_PRF_ANS	0x00000020
#define RES_PRF_AUTH	0x00000040
#define RES_PRF_ADD	0x00000080
#define RES_PRF_HEAD1	0x00000100
#define RES_PRF_HEAD2	0x00000200
#define RES_PRF_TTLID	0x00000400
#define RES_PRF_HEADX	0x00000800
#define RES_PRF_QUERY	0x00001000
#define RES_PRF_REPLY	0x00002000
#define RES_PRF_INIT    0x00004000
/*			0x00008000	*/

/* hooks are still experimental as of 4.9.2 */
typedef enum { res_goahead, res_nextns, res_modified, res_done, res_error }
	res_sendhookact;

typedef res_sendhookact (*res_send_qhook)(struct sockaddr_in * const *ns,
					      const unsigned char **query,
					      int *querylen,
					      unsigned char *ans,
					      int anssiz,
					      int *resplen);

typedef res_sendhookact (*res_send_rhook)(const struct sockaddr_in *ns,
					      const unsigned char *query,
					      int querylen,
					      unsigned char *ans,
					      int anssiz,
					      int *resplen);

struct res_sym {
	int	number;		/* Identifying number, like T_MX */
	char *	name;		/* Its symbolic name, like "MX" */
	char *	humanname;	/* Its fun name, like "mail exchanger" */
};

extern struct __res_state _res;
#if 1 /* INET6 */
extern struct __res_state_ext _res_ext;
#endif
extern const struct res_sym __p_class_syms[];
extern const struct res_sym __p_type_syms[];

/* Private routines shared between libc/net, named, nslookup and others. */
#define	res_hnok	__res_hnok
#define	res_ownok	__res_ownok
#define	res_mailok	__res_mailok
#define	res_dnok	__res_dnok
#define	sym_ntos	__sym_ntos
#define b64_ntop	__b64_ntop
#define	b64_pton	__b64_pton
#define	dn_skipname	__dn_skipname
#define	putlong		__putlong
#define	putshort	__putshort
#define p_class		__p_class
#define p_type		__p_type
#define	dn_count_labels	__dn_count_labels
#define	dn_comp		__dn_comp
#define	res_randomid	__res_randomid
#define	res_send	__res_send
#define	res_opt		__res_opt

#ifdef BIND_RES_POSIX3
#define	dn_expand	__dn_expand
#define	res_init	__res_init
#define	res_query	__res_query
#define	res_search	__res_search
#define	res_querydomain	__res_querydomain
#define	res_mkquery	__res_mkquery
#endif

__BEGIN_DECLS
int			res_hnok(const char *);
int			res_ownok(const char *);
int			res_mailok(const char *);
int			res_dnok(const char *);
const char *		sym_ntos(const struct res_sym *, int, int *);
int			b64_ntop(unsigned char const *, size_t, char *, size_t);
int			b64_pton(char const *, unsigned char *, size_t);
int			dn_skipname(const unsigned char *, 
			    const unsigned char *);
void			putlong(u_int32_t, unsigned char *);
void			putshort(u_int16_t, unsigned char *);
const char *		p_class(int);
const char *		p_type(int);
int			dn_comp(const char *, unsigned char *, int,
			    unsigned char **, unsigned char **);
int			dn_expand(const unsigned char *, const unsigned char *, 
			    const unsigned char *, char *, int);
int			res_init(void);
unsigned int		res_randomid(void);
int			res_query(const char *, int, int, unsigned char *, int)
			__attribute__((__bounded__(__string__,4,5)));
int			res_search(const char *, int, int, unsigned char *, int)
			    __attribute__((__bounded__(__string__,4,5)));
int			res_querydomain(const char *, const char *, int, int,
			    unsigned char *, int)
			__attribute__((__bounded__(__string__,5,6)));
int			res_mkquery(int, const char *, int, int, 
			    const unsigned char *, int, const unsigned char *, 
			    unsigned char *, int)
			__attribute__((__bounded__(__string__,5,6)))
			__attribute__((__bounded__(__string__,8,9)));
int			res_send(const unsigned char *, int, unsigned char *, 
			    int)
			__attribute__((__bounded__(__string__,3,4)));
__END_DECLS

#endif /* !_RESOLV_H_ */
@


1.20
log
@Trim symbols that aren't part of our new resolver

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.19 2012/12/05 23:19:57 deraadt Exp $	*/
d151 1
a151 1
	struct timespec	restimespec;
@


1.19
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.18 2012/07/10 11:46:23 guenther Exp $	*/
a251 1
#define	sym_ston	__sym_ston
a252 1
#define	sym_ntop	__sym_ntop
a254 2
#define	loc_ntoa	__loc_ntoa
#define	loc_aton	__loc_aton
a255 4
#define	fp_resstat	__fp_resstat
#define	fp_query	__fp_query
#define	fp_nquery	__fp_nquery
#define	hostalias	__hostalias
a258 1
#define p_time		__p_time
a259 8
#define	p_query		__p_query
#define	p_cdnname	__p_cdnname
#define	p_cdname	__p_cdname
#define	p_fqnname	__p_fqnname
#define	p_fqname	__p_fqname
#define	p_rr		__p_rr
#define	p_option	__p_option
#define	p_secstodate	__p_secstodate
a263 4
#define	res_isourserver	__res_isourserver
#define	res_nameinquery	__res_nameinquery
#define	res_queriesmatch __res_queriesmatch
#define	res_close	__res_close
a279 1
int			sym_ston(const struct res_sym *, char *, int *);
a280 1
const char *		sym_ntop(const struct res_sym *, int, int *);
a282 2
int			loc_aton(const char *, unsigned char *);
const char *		loc_ntoa(const unsigned char *, char *);
a284 4
void			fp_resstat(struct __res_state *, FILE *);
void			fp_query(const unsigned char *, FILE *);
void			fp_nquery(const unsigned char *, int, FILE *);
const char *		hostalias(const char *);
a287 1
const char *		p_time(u_int32_t);
a288 14
void			p_query(const unsigned char *);
const unsigned char *	p_cdnname(const unsigned char *, const unsigned char *,
			    int, FILE *);
const unsigned char *	p_cdname(const unsigned char *, const unsigned char *, 
			    FILE *);
const unsigned char *	p_fqnname(const unsigned char *, const unsigned char *,
			    int, char *, int);
const unsigned char *	p_fqname(const unsigned char *, const unsigned char *, 
			    FILE *);
const unsigned char *	p_rr(const unsigned char *, const unsigned char *, 
			    FILE *);
const char *		p_option(unsigned long);
char *			p_secstodate(unsigned long);
int			dn_count_labels(char *);
a293 1
int			_res_init(int);
a309 7
int			res_isourserver(const struct sockaddr_in *);
int			res_nameinquery(const char *, int, int,
			    const unsigned char *, const unsigned char *);
int			res_queriesmatch(const unsigned char *, 
			    const unsigned char *, const unsigned char *, 
			    const unsigned char *);
void			res_close(void);
@


1.18
log
@Stop pulling in <sys/param.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.17 2009/06/04 18:06:35 pyr Exp $	*/
a90 1
#include <sys/cdefs.h>
@


1.17
log
@Add a resolv.conf option to specify the order in which getaddrinfo
PF_UNSPEC queries are made. While there change the default from inet6
first then inet4 to inet4 first then inet6, this prevents the many
people with IPv4 only connectivity from constantly trying to contact
IPv6 addresses, and also unbreaks many ports who don't use getaddrinfo
right.

ok deraadt@@, plenty of cheering in the room wrt the idea, not loud
enough complaining from the v6 crowd.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.16 2005/03/30 02:58:28 tedu Exp $	*/
a90 6
#include <sys/param.h>
#if (!defined(BSD)) || (BSD < 199306)
# include <sys/bitypes.h>
#else
# include <sys/types.h>
#endif
d92 1
@


1.16
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.15 2004/01/22 21:48:02 espie Exp $	*/
d139 3
@


1.15
log
@Remove unnecessary typedef usage.

u_char -> unsigned char
u_short -> unsigned short
u_long -> unsigned long
u_int -> unsigned int

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.14 2003/08/01 17:38:33 avsm Exp $	*/
d137 1
a137 1
	unsigned long	options;	/* option flags - see below. */
d145 1
a145 1
	unsigned long	pfcode;		/* RES_PRF_ flags - see below. */
d154 2
a155 1
	char	pad[68];		/* on an i386 this means 512b total */
d341 1
@


1.14
log
@add __bounded__ attributes for userland headers; enabled with -Wbounded
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.13 2003/06/26 19:34:17 avsm Exp $	*/
d137 1
a137 1
	u_long	options;		/* option flags - see below. */
d142 1
a142 1
	u_short	id;			/* current message id */
d145 1
a145 1
	u_long	pfcode;			/* RES_PRF_ flags - see below. */
d223 1
a223 1
					      const u_char **query,
d225 1
a225 1
					      u_char *ans,
d230 1
a230 1
					      const u_char *query,
d232 1
a232 1
					      u_char *ans,
d299 43
a341 38
int		res_hnok(const char *);
int		res_ownok(const char *);
int		res_mailok(const char *);
int		res_dnok(const char *);
int		sym_ston(const struct res_sym *, char *, int *);
const char *	sym_ntos(const struct res_sym *, int, int *);
const char *	sym_ntop(const struct res_sym *, int, int *);
int		b64_ntop(u_char const *, size_t, char *, size_t);
int		b64_pton(char const *, u_char *, size_t);
int		loc_aton(const char *, u_char *);
const char *	loc_ntoa(const u_char *, char *);
int		dn_skipname(const u_char *, const u_char *);
void		fp_resstat(struct __res_state *, FILE *);
void		fp_query(const u_char *, FILE *);
void		fp_nquery(const u_char *, int, FILE *);
const char *	hostalias(const char *);
void		putlong(u_int32_t, u_char *);
void		putshort(u_int16_t, u_char *);
const char *	p_class(int);
const char *	p_time(u_int32_t);
const char *	p_type(int);
void		p_query(const u_char *);
const u_char *	p_cdnname(const u_char *, const u_char *, int, FILE *);
const u_char *	p_cdname(const u_char *, const u_char *, FILE *);
const u_char *	p_fqnname(const u_char *cp, const u_char *msg,
		    int, char *, int);
const u_char *	p_fqname(const u_char *, const u_char *, FILE *);
const u_char *	p_rr(const u_char *, const u_char *, FILE *);
const char *	p_option(u_long option);
char *		p_secstodate(u_long);
int		dn_count_labels(char *);
int		dn_comp(const char *, u_char *, int,
		    u_char **, u_char **);
int		dn_expand(const u_char *, const u_char *, const u_char *,
		    char *, int);
int		res_init(void);
u_int		res_randomid(void);
int		res_query(const char *, int, int, u_char *, int)
d343 4
a346 4
int		res_search(const char *, int, int, u_char *, int)
			__attribute__((__bounded__(__string__,4,5)));
int		res_querydomain(const char *, const char *, int, int,
		    u_char *, int)
d348 3
a350 2
int		res_mkquery(int, const char *, int, int, const u_char *, int,
		    const u_char *, u_char *, int)
d353 2
a354 1
int		res_send(const u_char *, int, u_char *, int)
d356 7
a362 6
int		res_isourserver(const struct sockaddr_in *);
int		res_nameinquery(const char *, int, int,
		    const u_char *, const u_char *);
int		res_queriesmatch(const u_char *, const u_char *,
		    const u_char *, const u_char *);
void		res_close(void);
@


1.13
log
@backout the __bounded__ attributes for a while; requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.11 2003/06/02 19:34:12 millert Exp $	*/
d336 4
a339 2
int		res_query(const char *, int, int, u_char *, int);
int		res_search(const char *, int, int, u_char *, int);
d341 2
a342 1
		    u_char *, int);
d344 5
a348 2
		    const u_char *, u_char *, int);
int		res_send(const u_char *, int, u_char *, int);
@


1.12
log
@Mark various standard library functions with the __bounded__ attribute.
You must have an up-to-date gcc for this!
deraadt@@ ok
@
text
@d336 2
a337 4
int		res_query(const char *, int, int, u_char *, int)
			__attribute__((__bounded__(__string__,4,5)));
int		res_search(const char *, int, int, u_char *, int)
			__attribute__((__bounded__(__string__,4,5)));
d339 1
a339 2
		    u_char *, int)
			__attribute__((__bounded__(__string__,5,6)));
d341 2
a342 5
		    const u_char *, u_char *, int)
			__attribute__((__bounded__(__string__,5,6)))
			__attribute__((__bounded__(__string__,8,9)));
int		res_send(const u_char *, int, u_char *, int)
			__attribute__((__bounded__(__string__,3,4)));
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.10 2002/06/03 12:14:30 deraadt Exp $	*/
d336 4
a339 2
int		res_query(const char *, int, int, u_char *, int);
int		res_search(const char *, int, int, u_char *, int);
d341 2
a342 1
		    u_char *, int);
d344 5
a348 2
		    const u_char *, u_char *, int);
int		res_send(const u_char *, int, u_char *, int);
@


1.10
log
@compatiblity -> compatibility
decriptor -> descriptor
authentciated -> authenticated
transmition -> transmission
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.9 2002/02/17 19:42:21 millert Exp $	*/
d46 1
a46 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.8 2002/02/16 21:27:17 millert Exp $	*/
d139 1
a139 1
	int	retrans;	 	/* retransmition time interval */
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.7 2001/07/31 22:02:18 jakob Exp $	*/
d226 1
a226 1
typedef res_sendhookact (*res_send_qhook)__P((struct sockaddr_in * const *ns,
d231 1
a231 1
					      int *resplen));
d233 1
a233 1
typedef res_sendhookact (*res_send_rhook)__P((const struct sockaddr_in *ns,
d238 1
a238 1
					      int *resplen));
d327 2
a328 2
const u_char *	p_fqnname __P((const u_char *cp, const u_char *msg,
			       int, char *, int));
d334 4
a337 4
int		dn_comp __P((const char *, u_char *, int,
			     u_char **, u_char **));
int		dn_expand __P((const u_char *, const u_char *, const u_char *,
			       char *, int));
d342 4
a345 4
int		res_querydomain __P((const char *, const char *, int, int,
				     u_char *, int));
int		res_mkquery __P((int, const char *, int, int, const u_char *, int,
				 const u_char *, u_char *, int));
d348 4
a351 4
int		res_nameinquery __P((const char *, int, int,
				     const u_char *, const u_char *));
int		res_queriesmatch __P((const u_char *, const u_char *,
				      const u_char *, const u_char *));
@


1.7
log
@add support for EDNS0 extended flag DNSSEC OK (aka DO). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.6 2001/06/11 10:06:02 itojun Exp $	*/
d303 24
a326 24
int		res_hnok __P((const char *));
int		res_ownok __P((const char *));
int		res_mailok __P((const char *));
int		res_dnok __P((const char *));
int		sym_ston __P((const struct res_sym *, char *, int *));
const char *	sym_ntos __P((const struct res_sym *, int, int *));
const char *	sym_ntop __P((const struct res_sym *, int, int *));
int		b64_ntop __P((u_char const *, size_t, char *, size_t));
int		b64_pton __P((char const *, u_char *, size_t));
int		loc_aton __P((const char *, u_char *));
const char *	loc_ntoa __P((const u_char *, char *));
int		dn_skipname __P((const u_char *, const u_char *));
void		fp_resstat __P((struct __res_state *, FILE *));
void		fp_query __P((const u_char *, FILE *));
void		fp_nquery __P((const u_char *, int, FILE *));
const char *	hostalias __P((const char *));
void		putlong __P((u_int32_t, u_char *));
void		putshort __P((u_int16_t, u_char *));
const char *	p_class __P((int));
const char *	p_time __P((u_int32_t));
const char *	p_type __P((int));
void		p_query __P((const u_char *));
const u_char *	p_cdnname __P((const u_char *, const u_char *, int, FILE *));
const u_char *	p_cdname __P((const u_char *, const u_char *, FILE *));
d329 5
a333 5
const u_char *	p_fqname __P((const u_char *, const u_char *, FILE *));
const u_char *	p_rr __P((const u_char *, const u_char *, FILE *));
const char *	p_option __P((u_long option));
char *		p_secstodate __P((u_long));
int		dn_count_labels __P((char *));
d338 4
a341 4
int		res_init __P((void));
u_int		res_randomid __P((void));
int		res_query __P((const char *, int, int, u_char *, int));
int		res_search __P((const char *, int, int, u_char *, int));
d346 2
a347 2
int		res_send __P((const u_char *, int, u_char *, int));
int		res_isourserver __P((const struct sockaddr_in *));
d352 1
a352 1
void		res_close __P((void));
@


1.6
log
@support EDNS0 (RFC2671) buffer size notification on DNS queries.
"options edns0" in /etc/resolv.conf will enable the behavior.  no behavior
change if you don't have the line.  see resolv.conf(5) for more details.

EDNS0 is useful for avoiding TCP DNS queries/replies on larger DNS responses.
also, draft-ietf-dnsext-message-size-* plans to mandate EDNS0 support for DNS
clients that support IPv6 transport.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.5 2001/01/04 21:37:11 todd Exp $	*/
d197 2
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.4 2000/06/22 07:31:18 itojun Exp $	*/
d195 2
d289 1
@


1.4
log
@ipv6 support in resolver.  "nameserver" line in /etc/resolv.conf now takes
ipv6 address.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolv.h,v 1.3 1997/03/13 19:11:51 downsj Exp $	*/
d118 1
a118 1
 * inital name server(s) to query and the domain search list.
@


1.3
log
@BIND 4.9.5 includes.
@
text
@d1 30
a30 1
/*	$OpenBSD: resolv.h,v 1.2 1997/03/12 11:21:15 downsj Exp $	*/
d102 1
d161 17
d243 3
@


1.2
log
@netbsd: bind 4.9.3
@
text
@d1 2
d60 1
a60 1
 *	$Id: resolv.h,v 8.5 1995/12/22 10:20:27 vixie Exp 
d76 3
a78 3
 * revision information.  this is the release date in YYYYMMDD format.
 * it can change every day so the right thing to do with it is use it
 * in preprocessor commands such as "#if (__RES > 19931104)".  do not
d83 1
a83 1
#define	__RES	19951031
d102 1
a102 1
#define	MAXDNSLUS		4	/* max # of host lookup types */
d116 1
a116 1
	u_short	id;			/* current packet id */
d118 1
a118 1
	char	defdname[MAXDNAME];	/* default domain */
d127 2
a128 1
	char	lookups[MAXDNSLUS];
d147 1
d189 6
d196 2
d200 11
d212 1
d221 1
d224 1
d228 3
d232 1
d236 11
d248 50
a297 36
int	 __dn_skipname __P((const u_char *, const u_char *));
void	 __fp_resstat __P((struct __res_state *, FILE *));
void	 __fp_query __P((const u_char *, FILE *));
void	 __fp_nquery __P((const u_char *, int, FILE *));
char	*__hostalias __P((const char *));
void	 __putlong __P((u_int32_t, u_char *));
void	 __putshort __P((u_int16_t, u_char *));
char	*__p_time __P((u_int32_t));
void	 __p_query __P((const u_char *));
const u_char *__p_cdnname __P((const u_char *, const u_char *, int, FILE *));
const u_char *__p_cdname __P((const u_char *, const u_char *, FILE *));
const u_char *__p_fqname __P((const u_char *, const u_char *, FILE *));
const u_char *__p_rr __P((const u_char *, const u_char *, FILE *));
const char *__p_type __P((int));
const char *__p_class __P((int));
const char *__p_option __P((u_long option));
int	 dn_comp __P((const char *, u_char *, int, u_char **, u_char **));
int	 dn_expand __P((const u_char *, const u_char *, const u_char *,
			char *, int));
int	 res_init __P((void));
u_int16_t res_randomid __P((void));
int	 res_query __P((const char *, int, int, u_char *, int));
int	 res_search __P((const char *, int, int, u_char *, int));
int	 res_querydomain __P((const char *, const char *, int, int,
			      u_char *, int));
int	 res_mkquery __P((int, const char *, int, int, const u_char *, int,
			  const u_char *, u_char *, int));
int	 res_send __P((const u_char *, int, u_char *, int));
int	 res_isourserver __P((const struct sockaddr_in *));
int	 res_nameinquery __P((const char *, int, int,
			      const u_char *, const u_char *));
int	 res_queriesmatch __P((const u_char *, const u_char *,
			       const u_char *, const u_char *));
/* XXX - these last two don't belong in the resolver */
u_int	 inet_nsap_addr __P((const char *, u_char *, int maxlen));
char	*inet_nsap_ntoa __P((int, const u_char *, char *ascii));
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: resolv.h,v 1.8 1994/10/26 00:56:16 cgd Exp $	*/

d2 5
a6 3
 * Copyright (c) 1983, 1987, 1989 The Regents of the University of California.
 * All rights reserved.
 *
d17 2
a18 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d22 1
a22 1
 *
d34 25
a58 2
 *
 *	@@(#)resolv.h	5.15 (Berkeley) 4/3/91
d64 9
d81 1
a81 1
#define	__RES		19931104
d103 2
a104 2
#define MAXRESOLVSORT		10	/* number of net to sort on */
#define RES_MAXNDOTS		15	/* should reflect bit field size */
d109 1
a109 1
	long	options;		/* option flags - see below. */
d111 2
a112 1
	struct	sockaddr_in nsaddr_list[MAXNS];	/* address of name server */
d117 3
a119 3
	long	pfcode;			/* RES_PRF_ flags - see below. */
	u_char	ndots:4;		/* threshold for initial abs. query */
	u_char	nsort:4;		/* number of elements in sort_list[] */
d122 2
a123 2
		struct in_addr addr;
		u_int32_t mask;
d129 1
a129 1
 * Resolver options
d131 13
a143 10
#define RES_INIT	0x0001		/* address initialized */
#define RES_DEBUG	0x0002		/* print debug messages */
#define RES_AAONLY	0x0004		/* authoritative answers only */
#define RES_USEVC	0x0008		/* use virtual circuit */
#define RES_PRIMARY	0x0010		/* query primary server only */
#define RES_IGNTC	0x0020		/* ignore trucation errors */
#define RES_RECURSE	0x0040		/* recursion desired */
#define RES_DEFNAMES	0x0080		/* use default domain name */
#define RES_STAYOPEN	0x0100		/* Keep TCP socket open */
#define RES_DNSRCH	0x0200		/* search up local domain tree */
d150 34
a183 16
#define	RES_PRF_STATS	0x0001
/*			0x0002  */
#define	RES_PRF_CLASS	0x0004
#define	RES_PRF_CMD	0x0008
#define	RES_PRF_QUES	0x0010
#define	RES_PRF_ANS	0x0020
#define	RES_PRF_AUTH	0x0040
#define	RES_PRF_ADD	0x0080
#define	RES_PRF_HEAD1	0x0100
#define	RES_PRF_HEAD2	0x0200
#define	RES_PRF_TTLID	0x0400
#define	RES_PRF_HEADX	0x0800
#define	RES_PRF_QUERY	0x1000
#define	RES_PRF_REPLY	0x2000
#define	RES_PRF_INIT	0x4000
/*			0x8000  */
a186 3
#include <sys/cdefs.h>
#include <stdio.h>

d190 1
d197 9
d208 3
a210 1
void	 __fp_query __P((char *, FILE *));
a213 1
char	*__p_class __P((int));
d215 9
a223 3
char	*__p_type __P((int));

int	 dn_comp __P((const u_char *, u_char *, int, u_char **, u_char **));
d225 1
a225 1
		u_char *, int));
d227 2
a228 1
int	 res_query __P((char *, int, int, u_char *, int));
d230 13
a242 3
int	 res_mkquery __P((int, const char *, int, int, const char *, int,
		const char *, char *, int));
int	 res_send __P((const char *, int, char *, int));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
