head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.5;

1.5
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.14.08.15.03;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.29.16.20.29;	author biorn;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.19.14.20.17;	author biorn;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.36;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.36;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.21.53;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.54.54;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.33;	author hin;	state Exp;
branches
	1.1.1.4.2.1
	1.1.1.4.4.1;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.32;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.32.45;	author biorn;	state Exp;
branches;
next	;

1.1.1.4.2.1
date	2004.05.26.09.02.38;	author brad;	state Exp;
branches;
next	;

1.1.1.4.4.1
date	2004.05.26.08.17.47;	author brad;	state Exp;
branches;
next	;


desc
@@


1.6
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2007 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kdc_locl.h"

#define MAX_TIME ((time_t)((1U << 31) - 1))

void
_kdc_fix_time(time_t **t)
{
    if(*t == NULL){
	ALLOC(*t);
	**t = MAX_TIME;
    }
    if(**t == 0) **t = MAX_TIME; /* fix for old clients */
}

static int
realloc_method_data(METHOD_DATA *md)
{
    PA_DATA *pa;
    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));
    if(pa == NULL)
	return ENOMEM;
    md->val = pa;
    md->len++;
    return 0;
}

static void
set_salt_padata(METHOD_DATA *md, Salt *salt)
{
    if (salt) {
       realloc_method_data(md);
       md->val[md->len - 1].padata_type = salt->type;
       der_copy_octet_string(&salt->salt,
                             &md->val[md->len - 1].padata_value);
    }
}

const PA_DATA*
_kdc_find_padata(const KDC_REQ *req, int *start, int type)
{
    if (req->padata == NULL)
	return NULL;

    while((size_t)*start < req->padata->len){
	(*start)++;
	if(req->padata->val[*start - 1].padata_type == (unsigned)type)
	    return &req->padata->val[*start - 1];
    }
    return NULL;
}

/*
 * This is a hack to allow predefined weak services, like afs to
 * still use weak types
 */

krb5_boolean
_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)
{
    if (principal->name.name_string.len > 0 &&
	strcmp(principal->name.name_string.val[0], "afs") == 0 &&
	(etype == ETYPE_DES_CBC_CRC
	 || etype == ETYPE_DES_CBC_MD4
	 || etype == ETYPE_DES_CBC_MD5))
	return TRUE;
    return FALSE;
}


/*
 * Detect if `key' is the using the the precomputed `default_salt'.
 */

static krb5_boolean
is_default_salt_p(const krb5_salt *default_salt, const Key *key)
{
    if (key->salt == NULL)
	return TRUE;
    if (default_salt->salttype != key->salt->type)
	return FALSE;
    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))
	return FALSE;
    return TRUE;
}

/*
 * return the first appropriate key of `princ' in `ret_key'.  Look for
 * all the etypes in (`etypes', `len'), stopping as soon as we find
 * one, but preferring one that has default salt
 */

krb5_error_code
_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,
		krb5_boolean is_preauth, hdb_entry_ex *princ,
		krb5_enctype *etypes, unsigned len,
		krb5_enctype *ret_enctype, Key **ret_key)
{
    krb5_error_code ret;
    krb5_salt def_salt;
    krb5_enctype enctype = ETYPE_NULL;
    Key *key;
    int i;

    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */
    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);
    if (ret)
	return ret;

    ret = KRB5KDC_ERR_ETYPE_NOSUPP;

    if (use_strongest_session_key) {
	const krb5_enctype *p;
	krb5_enctype clientbest = ETYPE_NULL;
	int j;

	/*
	 * Pick the strongest key that the KDC, target service, and
	 * client all support, using the local cryptosystem enctype
	 * list in strongest-to-weakest order to drive the search.
	 *
	 * This is not what RFC4120 says to do, but it encourages
	 * adoption of stronger enctypes.  This doesn't play well with
	 * clients that have multiple Kerberos client implementations
	 * available with different supported enctype lists.
	 */

	/* drive the search with local supported enctypes list */
	p = krb5_kerberos_enctypes(context);
	for (i = 0; p[i] != ETYPE_NULL && enctype == ETYPE_NULL; i++) {
	    if (krb5_enctype_valid(context, p[i]) != 0)
		continue;

	    /* check that the client supports it too */
	    for (j = 0; j < len && enctype == ETYPE_NULL; j++) {
		if (p[i] != etypes[j])
		    continue;
		/* save best of union of { client, crypto system } */
		if (clientbest == ETYPE_NULL)
		    clientbest = p[i];
		/* check target princ support */
		ret = hdb_enctype2key(context, &princ->entry, p[i], &key);
		if (ret)
		    continue;
		if (is_preauth && !is_default_salt_p(&def_salt, key))
		    continue;
		enctype = p[i];
	    }
	}
	if (clientbest != ETYPE_NULL && enctype == ETYPE_NULL)
	    enctype = clientbest;
	else if (enctype == ETYPE_NULL)
	    ret = KRB5KDC_ERR_ETYPE_NOSUPP;
	if (ret == 0 && ret_enctype != NULL)
	    *ret_enctype = enctype;
	if (ret == 0 && ret_key != NULL)
	    *ret_key = key;
    } else {
	/*
	 * Pick the first key from the client's enctype list that is
	 * supported by the cryptosystem and by the given principal.
	 *
	 * RFC4120 says we SHOULD pick the first _strong_ key from the
	 * client's list... not the first key...  If the admin disallows
	 * weak enctypes in krb5.conf and selects this key selection
	 * algorithm, then we get exactly what RFC4120 says.
	 */
	for(key = NULL, i = 0; ret != 0 && i < len; i++, key = NULL) {

	    if (krb5_enctype_valid(context, etypes[i]) != 0 &&
		!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))
		continue;

	    while (hdb_next_enctype2key(context, &princ->entry, etypes[i], &key) == 0) {
		if (key->key.keyvalue.length == 0) {
		    ret = KRB5KDC_ERR_NULL_KEY;
		    continue;
		}
		if (ret_key != NULL)
		    *ret_key = key;
		if (ret_enctype != NULL)
		    *ret_enctype = etypes[i];
		ret = 0;
		if (is_preauth && is_default_salt_p(&def_salt, key))
		    goto out;
	    }
	}
    }

out:
    krb5_free_salt (context, def_salt);
    return ret;
}

krb5_error_code
_kdc_make_anonymous_principalname (PrincipalName *pn)
{
    pn->name_type = KRB5_NT_PRINCIPAL;
    pn->name_string.len = 1;
    pn->name_string.val = malloc(sizeof(*pn->name_string.val));
    if (pn->name_string.val == NULL)
	return ENOMEM;
    pn->name_string.val[0] = strdup("anonymous");
    if (pn->name_string.val[0] == NULL) {
	free(pn->name_string.val);
	pn->name_string.val = NULL;
	return ENOMEM;
    }
    return 0;
}

void
_kdc_log_timestamp(krb5_context context,
		   krb5_kdc_configuration *config,
		   const char *type,
		   KerberosTime authtime, KerberosTime *starttime,
		   KerberosTime endtime, KerberosTime *renew_till)
{
    char authtime_str[100], starttime_str[100],
	endtime_str[100], renewtime_str[100];

    krb5_format_time(context, authtime,
		     authtime_str, sizeof(authtime_str), TRUE);
    if (starttime)
	krb5_format_time(context, *starttime,
			 starttime_str, sizeof(starttime_str), TRUE);
    else
	strlcpy(starttime_str, "unset", sizeof(starttime_str));
    krb5_format_time(context, endtime,
		     endtime_str, sizeof(endtime_str), TRUE);
    if (renew_till)
	krb5_format_time(context, *renew_till,
			 renewtime_str, sizeof(renewtime_str), TRUE);
    else
	strlcpy(renewtime_str, "unset", sizeof(renewtime_str));

    kdc_log(context, config, 5,
	    "%s authtime: %s starttime: %s endtime: %s renew till: %s",
	    type, authtime_str, starttime_str, endtime_str, renewtime_str);
}

static void
log_patypes(krb5_context context,
	    krb5_kdc_configuration *config,
	    METHOD_DATA *padata)
{
    struct rk_strpool *p = NULL;
    char *str;
    size_t i;

    for (i = 0; i < padata->len; i++) {
	switch(padata->val[i].padata_type) {
	case KRB5_PADATA_PK_AS_REQ:
	    p = rk_strpoolprintf(p, "PK-INIT(ietf)");
	    break;
	case KRB5_PADATA_PK_AS_REQ_WIN:
	    p = rk_strpoolprintf(p, "PK-INIT(win2k)");
	    break;
	case KRB5_PADATA_PA_PK_OCSP_RESPONSE:
	    p = rk_strpoolprintf(p, "OCSP");
	    break;
	case KRB5_PADATA_ENC_TIMESTAMP:
	    p = rk_strpoolprintf(p, "encrypted-timestamp");
	    break;
	default:
	    p = rk_strpoolprintf(p, "%d", padata->val[i].padata_type);
	    break;
	}
	if (p && i + 1 < padata->len)
	    p = rk_strpoolprintf(p, ", ");
	if (p == NULL) {
	    kdc_log(context, config, 0, "out of memory");
	    return;
	}
    }
    if (p == NULL)
	p = rk_strpoolprintf(p, "none");

    str = rk_strpoolcollect(p);
    kdc_log(context, config, 0, "Client sent patypes: %s", str);
    free(str);
}

/*
 *
 */


krb5_error_code
_kdc_encode_reply(krb5_context context,
		  krb5_kdc_configuration *config,
		  KDC_REP *rep, const EncTicketPart *et, EncKDCRepPart *ek,
		  krb5_enctype etype,
		  int skvno, const EncryptionKey *skey,
		  int ckvno, const EncryptionKey *reply_key,
		  int rk_is_subkey,
		  const char **e_text,
		  krb5_data *reply)
{
    unsigned char *buf;
    size_t buf_size;
    size_t len = 0;
    krb5_error_code ret;
    krb5_crypto crypto;

    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);
    if(ret) {
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "Failed to encode ticket: %s", msg);
	krb5_free_error_message(context, msg);
	return ret;
    }
    if(buf_size != len) {
	free(buf);
	kdc_log(context, config, 0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	return KRB5KRB_ERR_GENERIC;
    }

    ret = krb5_crypto_init(context, skey, etype, &crypto);
    if (ret) {
        const char *msg;
	free(buf);
	msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "krb5_crypto_init failed: %s", msg);
	krb5_free_error_message(context, msg);
	return ret;
    }

    ret = krb5_encrypt_EncryptedData(context,
				     crypto,
				     KRB5_KU_TICKET,
				     buf,
				     len,
				     skvno,
				     &rep->ticket.enc_part);
    free(buf);
    krb5_crypto_destroy(context, crypto);
    if(ret) {
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "Failed to encrypt data: %s", msg);
	krb5_free_error_message(context, msg);
	return ret;
    }

    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)
	ASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);
    else
	ASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);
    if(ret) {
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "Failed to encode KDC-REP: %s", msg);
	krb5_free_error_message(context, msg);
	return ret;
    }
    if(buf_size != len) {
	free(buf);
	kdc_log(context, config, 0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	return KRB5KRB_ERR_GENERIC;
    }
    ret = krb5_crypto_init(context, reply_key, 0, &crypto);
    if (ret) {
	const char *msg = krb5_get_error_message(context, ret);
	free(buf);
	kdc_log(context, config, 0, "krb5_crypto_init failed: %s", msg);
	krb5_free_error_message(context, msg);
	return ret;
    }
    if(rep->msg_type == krb_as_rep) {
	krb5_encrypt_EncryptedData(context,
				   crypto,
				   KRB5_KU_AS_REP_ENC_PART,
				   buf,
				   len,
				   ckvno,
				   &rep->enc_part);
	free(buf);
	ASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);
    } else {
	krb5_encrypt_EncryptedData(context,
				   crypto,
				   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,
				   buf,
				   len,
				   ckvno,
				   &rep->enc_part);
	free(buf);
	ASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);
    }
    krb5_crypto_destroy(context, crypto);
    if(ret) {
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "Failed to encode KDC-REP: %s", msg);
	krb5_free_error_message(context, msg);
	return ret;
    }
    if(buf_size != len) {
	free(buf);
	kdc_log(context, config, 0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	return KRB5KRB_ERR_GENERIC;
    }
    reply->data = buf;
    reply->length = buf_size;
    return 0;
}

/*
 * Return 1 if the client have only older enctypes, this is for
 * determining if the server should send ETYPE_INFO2 or not.
 */

static int
older_enctype(krb5_enctype enctype)
{
    switch (enctype) {
    case ETYPE_DES_CBC_CRC:
    case ETYPE_DES_CBC_MD4:
    case ETYPE_DES_CBC_MD5:
    case ETYPE_DES3_CBC_SHA1:
    case ETYPE_ARCFOUR_HMAC_MD5:
    case ETYPE_ARCFOUR_HMAC_MD5_56:
    /*
     * The following three is "old" windows enctypes and is needed for
     * windows 2000 hosts.
     */
    case ETYPE_ARCFOUR_MD4:
    case ETYPE_ARCFOUR_HMAC_OLD:
    case ETYPE_ARCFOUR_HMAC_OLD_EXP:
	return 1;
    default:
	return 0;
    }
}

/*
 *
 */

static krb5_error_code
make_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)
{
    ent->etype = key->key.keytype;
    if(key->salt){
#if 0
	ALLOC(ent->salttype);

	if(key->salt->type == hdb_pw_salt)
	    *ent->salttype = 0; /* or 1? or NULL? */
	else if(key->salt->type == hdb_afs3_salt)
	    *ent->salttype = 2;
	else {
	    kdc_log(context, config, 0, "unknown salt-type: %d",
		    key->salt->type);
	    return KRB5KRB_ERR_GENERIC;
	}
	/* according to `the specs', we can't send a salt if
	   we have AFS3 salted key, but that requires that you
	   *know* what cell you are using (e.g by assuming
	   that the cell is the same as the realm in lower
	   case) */
#elif 0
	ALLOC(ent->salttype);
	*ent->salttype = key->salt->type;
#else
	/*
	 * We shouldn't sent salttype since it is incompatible with the
	 * specification and it breaks windows clients.  The afs
	 * salting problem is solved by using KRB5-PADATA-AFS3-SALT
	 * implemented in Heimdal 0.7 and later.
	 */
	ent->salttype = NULL;
#endif
	krb5_copy_data(context, &key->salt->salt,
		       &ent->salt);
    } else {
	/* we return no salt type at all, as that should indicate
	 * the default salt type and make everybody happy.  some
	 * systems (like w2k) dislike being told the salt type
	 * here. */

	ent->salttype = NULL;
	ent->salt = NULL;
    }
    return 0;
}

static krb5_error_code
get_pa_etype_info(krb5_context context,
		  krb5_kdc_configuration *config,
		  METHOD_DATA *md, Key *ckey)
{
    krb5_error_code ret = 0;
    ETYPE_INFO pa;
    unsigned char *buf;
    size_t len;


    pa.len = 1;
    pa.val = calloc(1, sizeof(pa.val[0]));
    if(pa.val == NULL)
	return ENOMEM;

    ret = make_etype_info_entry(context, &pa.val[0], ckey);
    if (ret) {
	free_ETYPE_INFO(&pa);
	return ret;
    }

    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);
    free_ETYPE_INFO(&pa);
    if(ret)
	return ret;
    ret = realloc_method_data(md);
    if(ret) {
	free(buf);
	return ret;
    }
    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;
    md->val[md->len - 1].padata_value.length = len;
    md->val[md->len - 1].padata_value.data = buf;
    return 0;
}

/*
 *
 */

extern int _krb5_AES_string_to_default_iterator;

static krb5_error_code
make_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)
{
    ent->etype = key->key.keytype;
    if(key->salt) {
	ALLOC(ent->salt);
	if (ent->salt == NULL)
	    return ENOMEM;
	*ent->salt = malloc(key->salt->salt.length + 1);
	if (*ent->salt == NULL) {
	    free(ent->salt);
	    ent->salt = NULL;
	    return ENOMEM;
	}
	memcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);
	(*ent->salt)[key->salt->salt.length] = '\0';
    } else
	ent->salt = NULL;

    ent->s2kparams = NULL;

    switch (key->key.keytype) {
    case ETYPE_AES128_CTS_HMAC_SHA1_96:
    case ETYPE_AES256_CTS_HMAC_SHA1_96:
	ALLOC(ent->s2kparams);
	if (ent->s2kparams == NULL)
	    return ENOMEM;
	ent->s2kparams->length = 4;
	ent->s2kparams->data = malloc(ent->s2kparams->length);
	if (ent->s2kparams->data == NULL) {
	    free(ent->s2kparams);
	    ent->s2kparams = NULL;
	    return ENOMEM;
	}
	_krb5_put_int(ent->s2kparams->data,
		      _krb5_AES_string_to_default_iterator,
		      ent->s2kparams->length);
	break;
    case ETYPE_DES_CBC_CRC:
    case ETYPE_DES_CBC_MD4:
    case ETYPE_DES_CBC_MD5:
	/* Check if this was a AFS3 salted key */
	if(key->salt && key->salt->type == hdb_afs3_salt){
	    ALLOC(ent->s2kparams);
	    if (ent->s2kparams == NULL)
		return ENOMEM;
	    ent->s2kparams->length = 1;
	    ent->s2kparams->data = malloc(ent->s2kparams->length);
	    if (ent->s2kparams->data == NULL) {
		free(ent->s2kparams);
		ent->s2kparams = NULL;
		return ENOMEM;
	    }
	    _krb5_put_int(ent->s2kparams->data,
			  1,
			  ent->s2kparams->length);
	}
	break;
    default:
	break;
    }
    return 0;
}

/*
 * Return an ETYPE-INFO2. Enctypes are storted the same way as in the
 * database (client supported enctypes first, then the unsupported
 * enctypes).
 */

static krb5_error_code
get_pa_etype_info2(krb5_context context,
		   krb5_kdc_configuration *config,
		   METHOD_DATA *md, Key *ckey)
{
    krb5_error_code ret = 0;
    ETYPE_INFO2 pa;
    unsigned char *buf;
    size_t len;

    pa.len = 1;
    pa.val = calloc(1, sizeof(pa.val[0]));
    if(pa.val == NULL)
	return ENOMEM;

    ret = make_etype_info2_entry(&pa.val[0], ckey);
    if (ret) {
	free_ETYPE_INFO2(&pa);
	return ret;
    }

    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);
    free_ETYPE_INFO2(&pa);
    if(ret)
	return ret;
    ret = realloc_method_data(md);
    if(ret) {
	free(buf);
	return ret;
    }
    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;
    md->val[md->len - 1].padata_value.length = len;
    md->val[md->len - 1].padata_value.data = buf;
    return 0;
}

/*
 *
 */

static void
log_as_req(krb5_context context,
	   krb5_kdc_configuration *config,
	   krb5_enctype cetype,
	   krb5_enctype setype,
	   const KDC_REQ_BODY *b)
{
    krb5_error_code ret;
    struct rk_strpool *p;
    char *str;
    size_t i;

    p = rk_strpoolprintf(NULL, "%s", "Client supported enctypes: ");

    for (i = 0; i < b->etype.len; i++) {
	ret = krb5_enctype_to_string(context, b->etype.val[i], &str);
	if (ret == 0) {
	    p = rk_strpoolprintf(p, "%s", str);
	    free(str);
	} else
	    p = rk_strpoolprintf(p, "%d", b->etype.val[i]);
	if (p && i + 1 < b->etype.len)
	    p = rk_strpoolprintf(p, ", ");
	if (p == NULL) {
	    kdc_log(context, config, 0, "out of memory");
	    return;
	}
    }
    if (p == NULL)
	p = rk_strpoolprintf(p, "no encryption types");

    {
	char *cet;
	char *set;

	ret = krb5_enctype_to_string(context, cetype, &cet);
	if(ret == 0) {
	    ret = krb5_enctype_to_string(context, setype, &set);
	    if (ret == 0) {
		p = rk_strpoolprintf(p, ", using %s/%s", cet, set);
		free(set);
	    }
	    free(cet);
	}
	if (ret != 0)
	    p = rk_strpoolprintf(p, ", using enctypes %d/%d",
				 cetype, setype);
    }

    str = rk_strpoolcollect(p);
    kdc_log(context, config, 0, "%s", str);
    free(str);

    {
	char fixedstr[128];
	unparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),
		      fixedstr, sizeof(fixedstr));
	if(*fixedstr)
	    kdc_log(context, config, 0, "Requested flags: %s", fixedstr);
    }
}

/*
 * verify the flags on `client' and `server', returning 0
 * if they are OK and generating an error messages and returning
 * and error code otherwise.
 */

krb5_error_code
kdc_check_flags(krb5_context context,
		krb5_kdc_configuration *config,
		hdb_entry_ex *client_ex, const char *client_name,
		hdb_entry_ex *server_ex, const char *server_name,
		krb5_boolean is_as_req)
{
    if(client_ex != NULL) {
	hdb_entry *client = &client_ex->entry;

	/* check client */
	if (client->flags.locked_out) {
	    kdc_log(context, config, 0,
		    "Client (%s) is locked out", client_name);
	    return KRB5KDC_ERR_POLICY;
	}

	if (client->flags.invalid) {
	    kdc_log(context, config, 0,
		    "Client (%s) has invalid bit set", client_name);
	    return KRB5KDC_ERR_POLICY;
	}

	if(!client->flags.client){
	    kdc_log(context, config, 0,
		    "Principal may not act as client -- %s", client_name);
	    return KRB5KDC_ERR_POLICY;
	}

	if (client->valid_start && *client->valid_start > kdc_time) {
	    char starttime_str[100];
	    krb5_format_time(context, *client->valid_start,
			     starttime_str, sizeof(starttime_str), TRUE);
	    kdc_log(context, config, 0,
		    "Client not yet valid until %s -- %s",
		    starttime_str, client_name);
	    return KRB5KDC_ERR_CLIENT_NOTYET;
	}

	if (client->valid_end && *client->valid_end < kdc_time) {
	    char endtime_str[100];
	    krb5_format_time(context, *client->valid_end,
			     endtime_str, sizeof(endtime_str), TRUE);
	    kdc_log(context, config, 0,
		    "Client expired at %s -- %s",
		    endtime_str, client_name);
	    return KRB5KDC_ERR_NAME_EXP;
	}

	if (client->pw_end && *client->pw_end < kdc_time
	    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {
	    char pwend_str[100];
	    krb5_format_time(context, *client->pw_end,
			     pwend_str, sizeof(pwend_str), TRUE);
	    kdc_log(context, config, 0,
		    "Client's key has expired at %s -- %s",
		    pwend_str, client_name);
	    return KRB5KDC_ERR_KEY_EXPIRED;
	}
    }

    /* check server */

    if (server_ex != NULL) {
	hdb_entry *server = &server_ex->entry;

	if (server->flags.locked_out) {
	    kdc_log(context, config, 0,
		    "Client server locked out -- %s", server_name);
	    return KRB5KDC_ERR_POLICY;
	}
	if (server->flags.invalid) {
	    kdc_log(context, config, 0,
		    "Server has invalid flag set -- %s", server_name);
	    return KRB5KDC_ERR_POLICY;
	}

	if(!server->flags.server){
	    kdc_log(context, config, 0,
		    "Principal may not act as server -- %s", server_name);
	    return KRB5KDC_ERR_POLICY;
	}

	if(!is_as_req && server->flags.initial) {
	    kdc_log(context, config, 0,
		    "AS-REQ is required for server -- %s", server_name);
	    return KRB5KDC_ERR_POLICY;
	}

	if (server->valid_start && *server->valid_start > kdc_time) {
	    char starttime_str[100];
	    krb5_format_time(context, *server->valid_start,
			     starttime_str, sizeof(starttime_str), TRUE);
	    kdc_log(context, config, 0,
		    "Server not yet valid until %s -- %s",
		    starttime_str, server_name);
	    return KRB5KDC_ERR_SERVICE_NOTYET;
	}

	if (server->valid_end && *server->valid_end < kdc_time) {
	    char endtime_str[100];
	    krb5_format_time(context, *server->valid_end,
			     endtime_str, sizeof(endtime_str), TRUE);
	    kdc_log(context, config, 0,
		    "Server expired at %s -- %s",
		    endtime_str, server_name);
	    return KRB5KDC_ERR_SERVICE_EXP;
	}

	if (server->pw_end && *server->pw_end < kdc_time) {
	    char pwend_str[100];
	    krb5_format_time(context, *server->pw_end,
			     pwend_str, sizeof(pwend_str), TRUE);
	    kdc_log(context, config, 0,
		    "Server's key has expired at -- %s",
		    pwend_str, server_name);
	    return KRB5KDC_ERR_KEY_EXPIRED;
	}
    }
    return 0;
}

/*
 * Return TRUE if `from' is part of `addresses' taking into consideration
 * the configuration variables that tells us how strict we should be about
 * these checks
 */

krb5_boolean
_kdc_check_addresses(krb5_context context,
		     krb5_kdc_configuration *config,
		     HostAddresses *addresses, const struct sockaddr *from)
{
    krb5_error_code ret;
    krb5_address addr;
    krb5_boolean result;
    krb5_boolean only_netbios = TRUE;
    size_t i;

    if(config->check_ticket_addresses == 0)
	return TRUE;

    if(addresses == NULL)
	return config->allow_null_ticket_addresses;

    for (i = 0; i < addresses->len; ++i) {
	if (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {
	    only_netbios = FALSE;
	}
    }

    /* Windows sends it's netbios name, which I can only assume is
     * used for the 'allowed workstations' check.  This is painful,
     * but we still want to check IP addresses if they happen to be
     * present.
     */

    if(only_netbios)
	return config->allow_null_ticket_addresses;

    ret = krb5_sockaddr2address (context, from, &addr);
    if(ret)
	return FALSE;

    result = krb5_address_search(context, &addr, addresses);
    krb5_free_address (context, &addr);
    return result;
}

/*
 *
 */

static krb5_boolean
send_pac_p(krb5_context context, KDC_REQ *req)
{
    krb5_error_code ret;
    PA_PAC_REQUEST pacreq;
    const PA_DATA *pa;
    int i = 0;

    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);
    if (pa == NULL)
	return TRUE;

    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,
				pa->padata_value.length,
				&pacreq,
				NULL);
    if (ret)
	return TRUE;
    i = pacreq.include_pac;
    free_PA_PAC_REQUEST(&pacreq);
    if (i == 0)
	return FALSE;
    return TRUE;
}

krb5_boolean
_kdc_is_anonymous(krb5_context context, krb5_principal principal)
{
    if (principal->name.name_type != KRB5_NT_WELLKNOWN ||
	principal->name.name_string.len != 2 ||
	strcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||
	strcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)
	return 0;
    return 1;
}

/*
 *
 */

krb5_error_code
_kdc_as_rep(krb5_context context,
	    krb5_kdc_configuration *config,
	    KDC_REQ *req,
	    const krb5_data *req_buffer,
	    krb5_data *reply,
	    const char *from,
	    struct sockaddr *from_addr,
	    int datagram_reply)
{
    KDC_REQ_BODY *b = &req->req_body;
    AS_REP rep;
    KDCOptions f = b->kdc_options;
    hdb_entry_ex *client = NULL, *server = NULL;
    HDB *clientdb;
    krb5_enctype setype, sessionetype;
    krb5_data e_data;
    EncTicketPart et;
    EncKDCRepPart ek;
    krb5_principal client_princ = NULL, server_princ = NULL;
    char *client_name = NULL, *server_name = NULL;
    krb5_error_code ret = 0;
    const char *e_text = NULL;
    krb5_crypto crypto;
    Key *ckey, *skey;
    EncryptionKey *reply_key = NULL, session_key;
    int flags = HDB_F_FOR_AS_REQ;
#ifdef PKINIT
    pk_client_params *pkp = NULL;
#endif

    memset(&rep, 0, sizeof(rep));
    memset(&session_key, 0, sizeof(session_key));
    krb5_data_zero(&e_data);

    ALLOC(rep.padata);
    rep.padata->len = 0;
    rep.padata->val = NULL;

    if (f.canonicalize)
	flags |= HDB_F_CANON;

    if(b->sname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	e_text = "No server in request";
    } else{
	ret = _krb5_principalname2krb5_principal (context,
						  &server_princ,
						  *(b->sname),
						  b->realm);
	if (ret == 0)
	    ret = krb5_unparse_name(context, server_princ, &server_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		"AS-REQ malformed server name from %s", from);
	goto out;
    }
    if(b->cname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	e_text = "No client in request";
    } else {
	ret = _krb5_principalname2krb5_principal (context,
						  &client_princ,
						  *(b->cname),
						  b->realm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, client_princ, &client_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		"AS-REQ malformed client name from %s", from);
	goto out;
    }

    kdc_log(context, config, 0, "AS-REQ %s from %s for %s",
	    client_name, from, server_name);

    /*
     *
     */

    if (_kdc_is_anonymous(context, client_princ)) {
	if (!b->kdc_options.request_anonymous) {
	    kdc_log(context, config, 0, "Anonymous ticket w/o anonymous flag");
	    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    goto out;
	}
    } else if (b->kdc_options.request_anonymous) {
	kdc_log(context, config, 0,
		"Request for a anonymous ticket with non "
		"anonymous client name: %s", client_name);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     *
     */

    ret = _kdc_db_fetch(context, config, client_princ,
			HDB_F_GET_CLIENT | flags, NULL,
			&clientdb, &client);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, "client %s does not have secrets at this KDC, need to proxy", client_name);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "UNKNOWN -- %s: %s", client_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }
    ret = _kdc_db_fetch(context, config, server_princ,
			HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
			NULL, NULL, &server);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, "target %s does not have secrets at this KDC, need to proxy", server_name);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, "UNKNOWN -- %s: %s", server_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	goto out;
    }

    memset(&et, 0, sizeof(et));
    memset(&ek, 0, sizeof(ek));

    /*
     * Select a session enctype from the list of the crypto system
     * supported enctypes that is supported by the client and is one of
     * the enctype of the enctype of the service (likely krbtgt).
     *
     * The latter is used as a hint of what enctypes all KDC support,
     * to make sure a newer version of KDC won't generate a session
     * enctype that an older version of a KDC in the same realm can't
     * decrypt.
     */
    ret = _kdc_find_etype(context,
			  krb5_principal_is_krbtgt(context, server_princ) ?
			  config->tgt_use_strongest_session_key :
			  config->svc_use_strongest_session_key, FALSE,
			  client, b->etype.val, b->etype.len, &sessionetype,
			  NULL);
    if (ret) {
	kdc_log(context, config, 0,
		"Client (%s) from %s has no common enctypes with KDC "
		"to use for the session key",
		client_name, from);
	goto out;
    }
    /*
     * But if the KDC admin is paranoid and doesn't want to have "not
     * the best" enctypes on the krbtgt, lets save the best pick from
     * the client list and hope that that will work for any other
     * KDCs.
     */

    /*
     * Pre-auth processing
     */

    if(req->padata){
	int i;
	const PA_DATA *pa;
	int found_pa = 0;

	log_patypes(context, config, req->padata);

#ifdef PKINIT
	kdc_log(context, config, 5,
		"Looking for PKINIT pa-data -- %s", client_name);

	e_text = "No PKINIT PA found";

	i = 0;
	pa = _kdc_find_padata(req, &i, KRB5_PADATA_PK_AS_REQ);
	if (pa == NULL) {
	    i = 0;
	    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PK_AS_REQ_WIN);
	}
	if (pa) {
	    char *client_cert = NULL;

	    ret = _kdc_pk_rd_padata(context, config, req, pa, client, &pkp);
	    if (ret) {
		ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
		kdc_log(context, config, 5,
			"Failed to decode PKINIT PA-DATA -- %s",
			client_name);
		goto ts_enc;
	    }
	    if (ret == 0 && pkp == NULL)
		goto ts_enc;

	    ret = _kdc_pk_check_client(context,
				       config,
				       clientdb,
				       client,
				       pkp,
				       &client_cert);
	    if (ret) {
		e_text = "PKINIT certificate not allowed to "
		    "impersonate principal";
		_kdc_pk_free_client_param(context, pkp);

		kdc_log(context, config, 0, "%s", e_text);
		pkp = NULL;
		goto out;
	    }

	    found_pa = 1;
	    et.flags.pre_authent = 1;
	    kdc_log(context, config, 0,
		    "PKINIT pre-authentication succeeded -- %s using %s",
		    client_name, client_cert);
	    free(client_cert);
	    if (pkp)
		goto preauth_done;
	}
    ts_enc:
#endif
	kdc_log(context, config, 5, "Looking for ENC-TS pa-data -- %s",
		client_name);

	i = 0;
	e_text = "No ENC-TS found";
	while((pa = _kdc_find_padata(req, &i, KRB5_PADATA_ENC_TIMESTAMP))){
	    krb5_data ts_data;
	    PA_ENC_TS_ENC p;
	    size_t len;
	    EncryptedData enc_data;
	    Key *pa_key;
	    char *str;

	    found_pa = 1;

	    if (b->kdc_options.request_anonymous) {
		ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
		kdc_log(context, config, 0, "ENC-TS doesn't support anon");
		goto out;
	    }

	    ret = decode_EncryptedData(pa->padata_value.data,
				       pa->padata_value.length,
				       &enc_data,
				       &len);
	    if (ret) {
		ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
		kdc_log(context, config, 5, "Failed to decode PA-DATA -- %s",
			client_name);
		goto out;
	    }

	    ret = hdb_enctype2key(context, &client->entry,
				  enc_data.etype, &pa_key);
	    if(ret){
		char *estr;
		e_text = "No key matches pa-data";
		ret = KRB5KDC_ERR_ETYPE_NOSUPP;
		if(krb5_enctype_to_string(context, enc_data.etype, &estr))
		    estr = NULL;
		if(estr == NULL)
		    kdc_log(context, config, 5,
			    "No client key matching pa-data (%d) -- %s",
			    enc_data.etype, client_name);
		else
		    kdc_log(context, config, 5,
			    "No client key matching pa-data (%s) -- %s",
			    estr, client_name);
		free(estr);
		free_EncryptedData(&enc_data);

		continue;
	    }

	try_next_key:
	    ret = krb5_crypto_init(context, &pa_key->key, 0, &crypto);
	    if (ret) {
		const char *msg = krb5_get_error_message(context, ret);
		kdc_log(context, config, 0, "krb5_crypto_init failed: %s", msg);
		krb5_free_error_message(context, msg);
		free_EncryptedData(&enc_data);
		continue;
	    }

	    ret = krb5_decrypt_EncryptedData (context,
					      crypto,
					      KRB5_KU_PA_ENC_TIMESTAMP,
					      &enc_data,
					      &ts_data);
	    krb5_crypto_destroy(context, crypto);
	    /*
	     * Since the user might have several keys with the same
	     * enctype but with diffrent salting, we need to try all
	     * the keys with the same enctype.
	     */
	    if(ret){
		krb5_error_code ret2;
		const char *msg = krb5_get_error_message(context, ret);

		ret2 = krb5_enctype_to_string(context,
					      pa_key->key.keytype, &str);
		if (ret2)
		    str = NULL;
		kdc_log(context, config, 5,
			"Failed to decrypt PA-DATA -- %s "
			"(enctype %s) error %s",
			client_name, str ? str : "unknown enctype", msg);
		krb5_free_error_message(context, msg);
		free(str);

		if(hdb_next_enctype2key(context, &client->entry,
					enc_data.etype, &pa_key) == 0)
		    goto try_next_key;
		e_text = "Failed to decrypt PA-DATA";

		free_EncryptedData(&enc_data);

		if (clientdb->hdb_auth_status)
		    (clientdb->hdb_auth_status)(context, clientdb, client, HDB_AUTH_WRONG_PASSWORD);

		ret = KRB5KDC_ERR_PREAUTH_FAILED;
		continue;
	    }
	    free_EncryptedData(&enc_data);
	    ret = decode_PA_ENC_TS_ENC(ts_data.data,
				       ts_data.length,
				       &p,
				       &len);
	    krb5_data_free(&ts_data);
	    if(ret){
		e_text = "Failed to decode PA-ENC-TS-ENC";
		ret = KRB5KDC_ERR_PREAUTH_FAILED;
		kdc_log(context, config,
			5, "Failed to decode PA-ENC-TS_ENC -- %s",
			client_name);
		continue;
	    }
	    free_PA_ENC_TS_ENC(&p);
	    if (abs(kdc_time - p.patimestamp) > context->max_skew) {
		char client_time[100];

		krb5_format_time(context, p.patimestamp,
				 client_time, sizeof(client_time), TRUE);

 		ret = KRB5KRB_AP_ERR_SKEW;
 		kdc_log(context, config, 0,
			"Too large time skew, "
			"client time %s is out by %u > %u seconds -- %s",
			client_time,
			(unsigned)abs(kdc_time - p.patimestamp),
			context->max_skew,
			client_name);

		/*
		 * The following is needed to make windows clients to
		 * retry using the timestamp in the error message, if
		 * there is a e_text, they become unhappy.
		 */
		e_text = NULL;
		goto out;
	    }
	    et.flags.pre_authent = 1;

	    set_salt_padata(rep.padata, pa_key->salt);

	    reply_key = &pa_key->key;

	    ret = krb5_enctype_to_string(context, pa_key->key.keytype, &str);
	    if (ret)
		str = NULL;

	    kdc_log(context, config, 2,
		    "ENC-TS Pre-authentication succeeded -- %s using %s",
		    client_name, str ? str : "unknown enctype");
	    free(str);
	    break;
	}
#ifdef PKINIT
    preauth_done:
#endif
	if(found_pa == 0 && config->require_preauth)
	    goto use_pa;
	/* We come here if we found a pa-enc-timestamp, but if there
           was some problem with it, other than too large skew */
	if(found_pa && et.flags.pre_authent == 0){
	    kdc_log(context, config, 0, "%s -- %s", e_text, client_name);
	    e_text = NULL;
	    goto out;
	}
    }else if (config->require_preauth
	      || b->kdc_options.request_anonymous /* hack to force anon */
	      || client->entry.flags.require_preauth
	      || server->entry.flags.require_preauth) {
	METHOD_DATA method_data;
	PA_DATA *pa;
	unsigned char *buf;
	size_t len;

    use_pa:
	method_data.len = 0;
	method_data.val = NULL;

	ret = realloc_method_data(&method_data);
	if (ret) {
	    free_METHOD_DATA(&method_data);
	    goto out;
	}
	pa = &method_data.val[method_data.len-1];
	pa->padata_type		= KRB5_PADATA_ENC_TIMESTAMP;
	pa->padata_value.length	= 0;
	pa->padata_value.data	= NULL;

#ifdef PKINIT
	ret = realloc_method_data(&method_data);
	if (ret) {
	    free_METHOD_DATA(&method_data);
	    goto out;
	}
	pa = &method_data.val[method_data.len-1];
	pa->padata_type		= KRB5_PADATA_PK_AS_REQ;
	pa->padata_value.length	= 0;
	pa->padata_value.data	= NULL;

	ret = realloc_method_data(&method_data);
	if (ret) {
	    free_METHOD_DATA(&method_data);
	    goto out;
	}
	pa = &method_data.val[method_data.len-1];
	pa->padata_type		= KRB5_PADATA_PK_AS_REQ_WIN;
	pa->padata_value.length	= 0;
	pa->padata_value.data	= NULL;
#endif

	/*
	 * If there is a client key, send ETYPE_INFO{,2}
	 */
	ret = _kdc_find_etype(context,
			      config->preauth_use_strongest_session_key, TRUE,
			      client, b->etype.val, b->etype.len, NULL, &ckey);
	if (ret == 0) {

	    /*
	     * RFC4120 requires:
	     * - If the client only knows about old enctypes, then send
	     *   both info replies (we send 'info' first in the list).
	     * - If the client is 'modern', because it knows about 'new'
	     *   enctype types, then only send the 'info2' reply.
	     *
	     * Before we send the full list of etype-info data, we pick
	     * the client key we would have used anyway below, just pick
	     * that instead.
	     */

	    if (older_enctype(ckey->key.keytype)) {
		ret = get_pa_etype_info(context, config,
					&method_data, ckey);
		if (ret) {
		    free_METHOD_DATA(&method_data);
		    goto out;
		}
	    }
	    ret = get_pa_etype_info2(context, config,
				     &method_data, ckey);
	    if (ret) {
		free_METHOD_DATA(&method_data);
		goto out;
	    }
	}

	ASN1_MALLOC_ENCODE(METHOD_DATA, buf, len, &method_data, &len, ret);
	free_METHOD_DATA(&method_data);

	e_data.data   = buf;
	e_data.length = len;
	e_text ="Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ",

	ret = KRB5KDC_ERR_PREAUTH_REQUIRED;

	kdc_log(context, config, 0,
		"No preauth found, returning PREAUTH-REQUIRED -- %s",
		client_name);
	goto out;
    }

    if (clientdb->hdb_auth_status)
	(clientdb->hdb_auth_status)(context, clientdb, client,
				    HDB_AUTH_SUCCESS);

    /*
     * Verify flags after the user been required to prove its identity
     * with in a preauth mech.
     */

    ret = _kdc_check_access(context, config, client, client_name,
			    server, server_name,
			    req, &e_data);
    if(ret)
	goto out;

    /*
     * Selelct the best encryption type for the KDC with out regard to
     * the client since the client never needs to read that data.
     */

    ret = _kdc_get_preferred_key(context, config,
				 server, server_name,
				 &setype, &skey);
    if(ret)
	goto out;

    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
       || (f.request_anonymous && !config->allow_anonymous)) {
	ret = KRB5KDC_ERR_BADOPTION;
	e_text = "Bad KDC options";
	kdc_log(context, config, 0, "Bad KDC options -- %s", client_name);
	goto out;
    }

    rep.pvno = 5;
    rep.msg_type = krb_as_rep;

    ret = copy_Realm(&client->entry.principal->realm, &rep.crealm);
    if (ret)
	goto out;
    ret = _krb5_principal2principalname(&rep.cname, client->entry.principal);
    if (ret)
	goto out;

    rep.ticket.tkt_vno = 5;
    copy_Realm(&server->entry.principal->realm, &rep.ticket.realm);
    _krb5_principal2principalname(&rep.ticket.sname,
				  server->entry.principal);
    /* java 1.6 expects the name to be the same type, lets allow that
     * uncomplicated name-types. */
#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
	rep.ticket.sname.name_type = b->sname->name_type;
#undef CNT

    et.flags.initial = 1;
    if(client->entry.flags.forwardable && server->entry.flags.forwardable)
	et.flags.forwardable = f.forwardable;
    else if (f.forwardable) {
	e_text = "Ticket may not be forwardable";
	ret = KRB5KDC_ERR_POLICY;
	kdc_log(context, config, 0,
		"Ticket may not be forwardable -- %s", client_name);
	goto out;
    }
    if(client->entry.flags.proxiable && server->entry.flags.proxiable)
	et.flags.proxiable = f.proxiable;
    else if (f.proxiable) {
	e_text = "Ticket may not be proxiable";
	ret = KRB5KDC_ERR_POLICY;
	kdc_log(context, config, 0,
		"Ticket may not be proxiable -- %s", client_name);
	goto out;
    }
    if(client->entry.flags.postdate && server->entry.flags.postdate)
	et.flags.may_postdate = f.allow_postdate;
    else if (f.allow_postdate){
	e_text = "Ticket may not be postdate";
	ret = KRB5KDC_ERR_POLICY;
	kdc_log(context, config, 0,
		"Ticket may not be postdatable -- %s", client_name);
	goto out;
    }

    /* check for valid set of addresses */
    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
	e_text = "Bad address list in requested";
	ret = KRB5KRB_AP_ERR_BADADDR;
	kdc_log(context, config, 0,
		"Bad address list requested -- %s", client_name);
	goto out;
    }

    ret = copy_PrincipalName(&rep.cname, &et.cname);
    if (ret)
	goto out;
    ret = copy_Realm(&rep.crealm, &et.crealm);
    if (ret)
	goto out;

    {
	time_t start;
	time_t t;

	start = et.authtime = kdc_time;

	if(f.postdated && req->req_body.from){
	    ALLOC(et.starttime);
	    start = *et.starttime = *req->req_body.from;
	    et.flags.invalid = 1;
	    et.flags.postdated = 1; /* XXX ??? */
	}
	_kdc_fix_time(&b->till);
	t = *b->till;

	/* be careful not overflowing */

	if(client->entry.max_life)
	    t = start + min(t - start, *client->entry.max_life);
	if(server->entry.max_life)
	    t = start + min(t - start, *server->entry.max_life);
#if 0
	t = min(t, start + realm->max_life);
#endif
	et.endtime = t;
	if(f.renewable_ok && et.endtime < *b->till){
	    f.renewable = 1;
	    if(b->rtime == NULL){
		ALLOC(b->rtime);
		*b->rtime = 0;
	    }
	    if(*b->rtime < *b->till)
		*b->rtime = *b->till;
	}
	if(f.renewable && b->rtime){
	    t = *b->rtime;
	    if(t == 0)
		t = MAX_TIME;
	    if(client->entry.max_renew)
		t = start + min(t - start, *client->entry.max_renew);
	    if(server->entry.max_renew)
		t = start + min(t - start, *server->entry.max_renew);
#if 0
	    t = min(t, start + realm->max_renew);
#endif
	    ALLOC(et.renew_till);
	    *et.renew_till = t;
	    et.flags.renewable = 1;
	}
    }

    if (f.request_anonymous)
	et.flags.anonymous = 1;

    if(b->addresses){
	ALLOC(et.caddr);
	copy_HostAddresses(b->addresses, et.caddr);
    }

    et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&et.transited.contents);

    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded
     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus
     * incapable of correctly decoding SEQUENCE OF's of zero length.
     *
     * To fix this, always send at least one no-op last_req
     *
     * If there's a pw_end or valid_end we will use that,
     * otherwise just a dummy lr.
     */
    ek.last_req.val = malloc(2 * sizeof(*ek.last_req.val));
    if (ek.last_req.val == NULL) {
	ret = ENOMEM;
	goto out;
    }
    ek.last_req.len = 0;
    if (client->entry.pw_end
	&& (config->kdc_warn_pwexpire == 0
	    || kdc_time + config->kdc_warn_pwexpire >= *client->entry.pw_end)) {
	ek.last_req.val[ek.last_req.len].lr_type  = LR_PW_EXPTIME;
	ek.last_req.val[ek.last_req.len].lr_value = *client->entry.pw_end;
	++ek.last_req.len;
    }
    if (client->entry.valid_end) {
	ek.last_req.val[ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
	ek.last_req.val[ek.last_req.len].lr_value = *client->entry.valid_end;
	++ek.last_req.len;
    }
    if (ek.last_req.len == 0) {
	ek.last_req.val[ek.last_req.len].lr_type  = LR_NONE;
	ek.last_req.val[ek.last_req.len].lr_value = 0;
	++ek.last_req.len;
    }
    ek.nonce = b->nonce;
    if (client->entry.valid_end || client->entry.pw_end) {
	ALLOC(ek.key_expiration);
	if (client->entry.valid_end) {
	    if (client->entry.pw_end)
		*ek.key_expiration = min(*client->entry.valid_end,
					 *client->entry.pw_end);
	    else
		*ek.key_expiration = *client->entry.valid_end;
	} else
	    *ek.key_expiration = *client->entry.pw_end;
    } else
	ek.key_expiration = NULL;
    ek.flags = et.flags;
    ek.authtime = et.authtime;
    if (et.starttime) {
	ALLOC(ek.starttime);
	*ek.starttime = *et.starttime;
    }
    ek.endtime = et.endtime;
    if (et.renew_till) {
	ALLOC(ek.renew_till);
	*ek.renew_till = *et.renew_till;
    }
    copy_Realm(&rep.ticket.realm, &ek.srealm);
    copy_PrincipalName(&rep.ticket.sname, &ek.sname);
    if(et.caddr){
	ALLOC(ek.caddr);
	copy_HostAddresses(et.caddr, ek.caddr);
    }

#if PKINIT
    if (pkp) {
        e_text = "Failed to build PK-INIT reply";
	ret = _kdc_pk_mk_pa_reply(context, config, pkp, client,
				  sessionetype, req, req_buffer,
				  &reply_key, &et.key, rep.padata);
	if (ret)
	    goto out;
	ret = _kdc_add_inital_verified_cas(context,
					   config,
					   pkp,
					   &et);
	if (ret)
	    goto out;

    } else
#endif
    {
	ret = krb5_generate_random_keyblock(context, sessionetype, &et.key);
	if (ret)
	    goto out;
    }

    if (reply_key == NULL) {
	e_text = "Client have no reply key";
	ret = KRB5KDC_ERR_CLIENT_NOTYET;
	goto out;
    }

    ret = copy_EncryptionKey(&et.key, &ek.key);
    if (ret)
	goto out;

    /* Add signing of alias referral */
    if (f.canonicalize) {
	PA_ClientCanonicalized canon;
	krb5_data data;
	PA_DATA pa;
	krb5_crypto cryptox;
	size_t len = 0;

	memset(&canon, 0, sizeof(canon));

	canon.names.requested_name = *b->cname;
	canon.names.mapped_name = client->entry.principal->name;

	ASN1_MALLOC_ENCODE(PA_ClientCanonicalizedNames, data.data, data.length,
			   &canon.names, &len, ret);
	if (ret)
	    goto out;
	if (data.length != len)
	    krb5_abortx(context, "internal asn.1 error");

	/* sign using "returned session key" */
	ret = krb5_crypto_init(context, &et.key, 0, &cryptox);
	if (ret) {
	    free(data.data);
	    goto out;
	}

	ret = krb5_create_checksum(context, cryptox,
				   KRB5_KU_CANONICALIZED_NAMES, 0,
				   data.data, data.length,
				   &canon.canon_checksum);
	free(data.data);
	krb5_crypto_destroy(context, cryptox);
	if (ret)
	    goto out;

	ASN1_MALLOC_ENCODE(PA_ClientCanonicalized, data.data, data.length,
			   &canon, &len, ret);
	free_Checksum(&canon.canon_checksum);
	if (ret)
	    goto out;
	if (data.length != len)
	    krb5_abortx(context, "internal asn.1 error");

	pa.padata_type = KRB5_PADATA_CLIENT_CANONICALIZED;
	pa.padata_value = data;
	ret = add_METHOD_DATA(rep.padata, &pa);
	free(data.data);
	if (ret)
	    goto out;
    }

    if (rep.padata->len == 0) {
	free(rep.padata);
	rep.padata = NULL;
    }

    /* Add the PAC */
    if (send_pac_p(context, req)) {
	krb5_pac p = NULL;
	krb5_data data;

	ret = _kdc_pac_generate(context, client, &p);
	if (ret) {
	    kdc_log(context, config, 0, "PAC generation failed for -- %s",
		    client_name);
	    goto out;
	}
	if (p != NULL) {
	    ret = _krb5_pac_sign(context, p, et.authtime,
				 client->entry.principal,
				 &skey->key, /* Server key */
				 &skey->key, /* FIXME: should be krbtgt key */
				 &data);
	    krb5_pac_free(context, p);
	    if (ret) {
		kdc_log(context, config, 0, "PAC signing failed for -- %s",
			client_name);
		goto out;
	    }

	    ret = _kdc_tkt_add_if_relevant_ad(context, &et,
					      KRB5_AUTHDATA_WIN2K_PAC,
					      &data);
	    krb5_data_free(&data);
	    if (ret)
		goto out;
	}
    }

    _kdc_log_timestamp(context, config, "AS-REQ", et.authtime, et.starttime,
		       et.endtime, et.renew_till);

    /* do this as the last thing since this signs the EncTicketPart */
    ret = _kdc_add_KRB5SignedPath(context,
				  config,
				  server,
				  setype,
				  client->entry.principal,
				  NULL,
				  NULL,
				  &et);
    if (ret)
	goto out;

    log_as_req(context, config, reply_key->keytype, setype, b);

    ret = _kdc_encode_reply(context, config,
			    &rep, &et, &ek, setype, server->entry.kvno,
			    &skey->key, client->entry.kvno,
			    reply_key, 0, &e_text, reply);
    free_EncTicketPart(&et);
    free_EncKDCRepPart(&ek);
    if (ret)
	goto out;

    /* */
    if (datagram_reply && reply->length > config->max_datagram_reply_length) {
	krb5_data_free(reply);
	ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
	e_text = "Reply packet too large";
    }

out:
    free_AS_REP(&rep);
    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE){
	krb5_mk_error(context,
		      ret,
		      e_text,
		      (e_data.data ? &e_data : NULL),
		      client_princ,
		      server_princ,
		      NULL,
		      NULL,
		      reply);
	ret = 0;
    }
#ifdef PKINIT
    if (pkp)
	_kdc_pk_free_client_param(context, pkp);
#endif
    if (e_data.data)
        free(e_data.data);
    if (client_princ)
	krb5_free_principal(context, client_princ);
    free(client_name);
    if (server_princ)
	krb5_free_principal(context, server_princ);
    free(server_name);
    if(client)
	_kdc_free_ent(context, client);
    if(server)
	_kdc_free_ent(context, server);
    return ret;
}

/*
 * Add the AuthorizationData `dataÂ´ of `typeÂ´ to the last element in
 * the sequence of authorization_data in `tktÂ´ wrapped in an IF_RELEVANT
 */

krb5_error_code
_kdc_tkt_add_if_relevant_ad(krb5_context context,
			    EncTicketPart *tkt,
			    int type,
			    const krb5_data *data)
{
    krb5_error_code ret;
    size_t size = 0;

    if (tkt->authorization_data == NULL) {
	tkt->authorization_data = calloc(1, sizeof(*tkt->authorization_data));
	if (tkt->authorization_data == NULL) {
	    krb5_set_error_message(context, ENOMEM, "out of memory");
	    return ENOMEM;
	}
    }

    /* add the entry to the last element */
    {
	AuthorizationData ad = { 0, NULL };
	AuthorizationDataElement ade;

	ade.ad_type = type;
	ade.ad_data = *data;

	ret = add_AuthorizationData(&ad, &ade);
	if (ret) {
	    krb5_set_error_message(context, ret, "add AuthorizationData failed");
	    return ret;
	}

	ade.ad_type = KRB5_AUTHDATA_IF_RELEVANT;

	ASN1_MALLOC_ENCODE(AuthorizationData,
			   ade.ad_data.data, ade.ad_data.length,
			   &ad, &size, ret);
	free_AuthorizationData(&ad);
	if (ret) {
	    krb5_set_error_message(context, ret, "ASN.1 encode of "
				   "AuthorizationData failed");
	    return ret;
	}
	if (ade.ad_data.length != size)
	    krb5_abortx(context, "internal asn.1 encoder error");

	ret = add_AuthorizationData(tkt->authorization_data, &ade);
	der_free_octet_string(&ade.ad_data);
	if (ret) {
	    krb5_set_error_message(context, ret, "add AuthorizationData failed");
	    return ret;
	}
    }

    return 0;
}
@


1.5
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.4
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a35 2
RCSID("$KTH: kerberos5.c,v 1.173.2.2 2005/06/15 11:33:33 lha Exp $");

d38 2
a39 2
static void
fix_time(time_t **t)
d61 1
a61 1
set_salt_padata (METHOD_DATA *md, Salt *salt)
d64 4
a67 4
	realloc_method_data(md);
	md->val[md->len - 1].padata_type = salt->type;
	copy_octet_string(&salt->salt,
			  &md->val[md->len - 1].padata_value);
d71 2
a72 2
static PA_DATA*
find_padata(KDC_REQ *req, int *start, int type)
d74 4
a77 1
    while(*start < req->padata->len){
d79 1
a79 1
	if(req->padata->val[*start - 1].padata_type == type)
d86 34
d125 5
a129 3
static krb5_error_code
find_etype(hdb_entry *princ, krb5_enctype *etypes, unsigned len, 
	   Key **ret_key, krb5_enctype *ret_etype)
d131 4
a135 1
    krb5_error_code ret = KRB5KDC_ERR_ETYPE_NOSUPP;
d137 4
a140 2
    for(i = 0; ret != 0 && i < len ; i++) {
	Key *key = NULL;
d142 1
a142 2
	if (krb5_enctype_valid(context, etypes[i]) != 0)
	    continue;
d144 20
a163 3
	while (hdb_next_enctype2key(context, princ, etypes[i], &key) == 0) {
	    if (key->key.keyvalue.length == 0) {
		ret = KRB5KDC_ERR_NULL_KEY;
d165 15
a180 5
	    *ret_key   = key;
	    *ret_etype = etypes[i];
	    ret = 0;
	    if (key->salt == NULL)
		return ret;
d182 19
a200 3
    }
    return ret;
}
d202 3
a204 13
static krb5_error_code
find_keys(hdb_entry *client,
	  hdb_entry *server, 
	  Key **ckey,
	  krb5_enctype *cetype,
	  Key **skey,
	  krb5_enctype *setype, 
	  krb5_enctype *etypes,
	  unsigned num_etypes)
{
    char unparse_name[] = "krb5_unparse_name failed";
    krb5_error_code ret;
    char *name;
d206 13
a218 10
    if(client){
	/* find client key */
	ret = find_etype(client, etypes, num_etypes, ckey, cetype);
	if (ret) {
	    if (krb5_unparse_name(context, client->principal, &name) != 0)
		name = unparse_name;
	    kdc_log(0, "Client (%s) has no support for etypes", name);
	    if (name != unparse_name)
		free(name);
	    return ret;
d222 3
a224 13
    if(server){
	/* find server key */
	ret = find_etype(server, etypes, num_etypes, skey, setype);
	if (ret) {
	    if (krb5_unparse_name(context, server->principal, &name) != 0)
		name = unparse_name;
	    kdc_log(0, "Server (%s) has no support for etypes", name);
	    if (name != unparse_name)
		free(name);
	    return ret;
	}
    }
    return 0;
d227 2
a228 2
static krb5_error_code
make_anonymous_principalname (PrincipalName *pn)
d244 87
a330 7
static krb5_error_code
encode_reply(KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek, 
	     krb5_enctype etype, 
	     int skvno, EncryptionKey *skey,
	     int ckvno, EncryptionKey *ckey,
	     const char **e_text,
	     krb5_data *reply)
d334 1
a334 1
    size_t len;
d340 3
a342 2
	kdc_log(0, "Failed to encode ticket: %s", 
		krb5_get_err_text(context, ret));
d347 1
a347 1
	kdc_log(0, "Internal error in ASN.1 encoder");
d354 1
d356 3
a358 2
	kdc_log(0, "krb5_crypto_init failed: %s",
		krb5_get_err_text(context, ret));
d362 1
a362 1
    ret = krb5_encrypt_EncryptedData(context, 
d372 3
a374 2
	kdc_log(0, "Failed to encrypt data: %s",
		krb5_get_err_text(context, ret));
d377 2
a378 2
    
    if(rep->msg_type == krb_as_rep && !encode_as_rep_as_tgs_rep)
d383 3
a385 2
	kdc_log(0, "Failed to encode KDC-REP: %s", 
		krb5_get_err_text(context, ret));
d390 1
a390 1
	kdc_log(0, "Internal error in ASN.1 encoder");
d394 1
a394 1
    ret = krb5_crypto_init(context, ckey, 0, &crypto);
d396 1
d398 2
a399 2
	kdc_log(0, "krb5_crypto_init failed: %s",
		krb5_get_err_text(context, ret));
d415 1
a415 1
				   KRB5_KU_TGS_REP_ENC_PART_SESSION,
d425 3
a427 2
	kdc_log(0, "Failed to encode KDC-REP: %s", 
		krb5_get_err_text(context, ret));
d432 1
a432 1
	kdc_log(0, "Internal error in ASN.1 encoder");
d441 32
d474 1
a474 1
make_etype_info_entry(ETYPE_INFO_ENTRY *ent, Key *key)
d478 1
d480 1
a480 1
#if 0
d486 1
a486 1
	    kdc_log(0, "unknown salt-type: %d", 
d495 3
d499 7
a505 1
	*ent->salttype = key->salt->type;
d522 3
a524 2
get_pa_etype_info(METHOD_DATA *md, hdb_entry *client, 
		  ENCTYPE *etypes, unsigned int etypes_len)
a526 2
    int i, j;
    unsigned int n = 0;
a529 1
    
d531 3
a533 4
    pa.len = client->keys.len;
    if(pa.len > UINT_MAX/sizeof(*pa.val))
	return ERANGE;
    pa.val = malloc(pa.len * sizeof(*pa.val));
a535 1
    memset(pa.val, 0, pa.len * sizeof(*pa.val));
d537 4
a540 42
    for(j = 0; j < etypes_len; j++) {
	for (i = 0; i < n; i++)
	    if (pa.val[i].etype == etypes[j])
		goto skip1;
	for(i = 0; i < client->keys.len; i++) {
	    if(client->keys.val[i].key.keytype == etypes[j]) {
 		if (krb5_enctype_valid(context, etypes[j]) != 0)
 		    continue;
		if((ret = make_etype_info_entry(&pa.val[n++], 
						&client->keys.val[i])) != 0) {
		    free_ETYPE_INFO(&pa);
		    return ret;
		}
	    }
	}
    skip1:;
    }
    for(i = 0; i < client->keys.len; i++) {
	for(j = 0; j < etypes_len; j++) {
	    if(client->keys.val[i].key.keytype == etypes[j])
		goto skip2;
	}
	if (krb5_enctype_valid(context, client->keys.val[i].key.keytype) != 0)
	    continue;
	if((ret = make_etype_info_entry(&pa.val[n++], 
					&client->keys.val[i])) != 0) {
	    free_ETYPE_INFO(&pa);
	    return ret;
	}
    skip2:;
    }
    
    if(n != pa.len) {
	char *name;
	ret = krb5_unparse_name(context, client->principal, &name);
	if (ret)
	    name = "<unparse_name failed>";
	kdc_log(0, "internal error in get_pa_etype_info(%s): %d != %d", 
		name, n, pa.len);
	if (ret == 0)
	    free(name);
 	pa.len = n;
d586 2
a587 2
    case KEYTYPE_AES128:
    case KEYTYPE_AES256:
d598 2
a599 2
	_krb5_put_int(ent->s2kparams->data, 
		      _krb5_AES_string_to_default_iterator, 
d602 20
d629 3
a631 27
 * Return 1 if the client have only older enctypes, this is for
 * determining if the server should send ETYPE_INFO2 or not.
 */

static int
only_older_enctype_p(const KDC_REQ *req)
{
    int i;

    for(i = 0; i < req->req_body.etype.len; i++) {
	switch (req->req_body.etype.val[i]) {
	case ETYPE_DES_CBC_CRC:
	case ETYPE_DES_CBC_MD4:
	case ETYPE_DES_CBC_MD5:
	case ETYPE_DES3_CBC_SHA1:
	case ETYPE_ARCFOUR_HMAC_MD5:
	case ETYPE_ARCFOUR_HMAC_MD5_56:
	    break;
	default:
	    return 0;
	}
    }
    return 1;
}

/*
 *
d635 3
a637 2
get_pa_etype_info2(METHOD_DATA *md, hdb_entry *client, 
		   ENCTYPE *etypes, unsigned int etypes_len)
a639 2
    int i, j;
    unsigned int n = 0;
d644 2
a645 4
    pa.len = client->keys.len;
    if(pa.len > UINT_MAX/sizeof(*pa.val))
	return ERANGE;
    pa.val = malloc(pa.len * sizeof(*pa.val));
a647 1
    memset(pa.val, 0, pa.len * sizeof(*pa.val));
d649 4
a652 42
    for(j = 0; j < etypes_len; j++) {
	for (i = 0; i < n; i++)
	    if (pa.val[i].etype == etypes[j])
		goto skip1;
	for(i = 0; i < client->keys.len; i++) {
	    if(client->keys.val[i].key.keytype == etypes[j]) {
		if (krb5_enctype_valid(context, etypes[j]) != 0)
		    continue;
		if((ret = make_etype_info2_entry(&pa.val[n++], 
						 &client->keys.val[i])) != 0) {
		    free_ETYPE_INFO2(&pa);
		    return ret;
		}
	    }
	}
    skip1:;
    }
    for(i = 0; i < client->keys.len; i++) {
	for(j = 0; j < etypes_len; j++) {
	    if(client->keys.val[i].key.keytype == etypes[j])
		goto skip2;
	}
	if (krb5_enctype_valid(context, client->keys.val[i].key.keytype) != 0)
	    continue;
	if((ret = make_etype_info2_entry(&pa.val[n++],
					 &client->keys.val[i])) != 0) {
	    free_ETYPE_INFO2(&pa);
	    return ret;
	}
      skip2:;
    }
    
    if(n != pa.len) {
	char *name;
	ret = krb5_unparse_name(context, client->principal, &name);
	if (ret)
	    name = "<unparse_name failed>";
	kdc_log(0, "internal error in get_pa_etype_info2(%s): %d != %d", 
		name, n, pa.len);
	if (ret == 0)
	    free(name);
 	pa.len = n;
d671 66
d743 5
a747 3
check_flags(hdb_entry *client, const char *client_name,
	    hdb_entry *server, const char *server_name,
	    krb5_boolean is_as_req)
d749 3
a751 1
    if(client != NULL) {
d753 6
d760 2
a761 1
	    kdc_log(0, "Client (%s) has invalid bit set", client_name);
d764 1
a764 1
	
d766 2
a767 2
	    kdc_log(0, "Principal may not act as client -- %s", 
		    client_name);
d770 1
a770 1
	
d772 6
a777 1
	    kdc_log(0, "Client not yet valid -- %s", client_name);
d780 1
a780 1
	
d782 6
a787 1
	    kdc_log(0, "Client expired -- %s", client_name);
d790 1
a790 1
	
d792 7
a798 2
	    && !server->flags.change_pw) {
	    kdc_log(0, "Client's key has expired -- %s", client_name);
d804 9
a812 2
    
    if (server != NULL) {
d814 2
a815 1
	    kdc_log(0, "Server has invalid flag set -- %s", server_name);
d820 2
a821 2
	    kdc_log(0, "Principal may not act as server -- %s", 
		    server_name);
d826 2
a827 1
	    kdc_log(0, "AS-REQ is required for server -- %s", server_name);
d832 6
a837 1
	    kdc_log(0, "Server not yet valid -- %s", server_name);
d842 6
a847 1
	    kdc_log(0, "Server expired -- %s", server_name);
d852 6
a857 1
	    kdc_log(0, "Server's key has expired -- %s", server_name);
d870 4
a873 2
static krb5_boolean
check_addresses(HostAddresses *addresses, const struct sockaddr *from)
d878 4
a881 2
    
    if(check_ticket_addresses == 0)
d885 17
a901 2
	return allow_null_ticket_addresses;
    
d911 44
d956 8
a963 4
as_rep(KDC_REQ *req, 
       krb5_data *reply,
       const char *from,
       struct sockaddr *from_addr)
d968 4
a971 2
    hdb_entry *client = NULL, *server = NULL;
    krb5_enctype cetype, setype;
d980 2
a981 1
    EncryptionKey *reply_key;
d987 9
d1001 6
a1006 3
	_krb5_principalname2krb5_principal (&server_princ,
					    *(b->sname), b->realm);
	ret = krb5_unparse_name(context, server_princ, &server_name);
d1009 2
a1010 1
	kdc_log(0, "AS-REQ malformed server name from %s", from);
a1012 1
    
d1017 7
a1023 2
	_krb5_principalname2krb5_principal (&client_princ,
					    *(b->cname), b->realm);
d1027 2
a1028 1
	kdc_log(0, "AS-REQ malformed client name from %s", from);
d1032 1
a1032 1
    kdc_log(0, "AS-REQ %s from %s for %s", 
d1035 14
a1048 4
    ret = db_fetch(client_princ, &client);
    if(ret){
	kdc_log(0, "UNKNOWN -- %s: %s", client_name,
		krb5_get_err_text(context, ret));
d1053 27
a1079 4
    ret = db_fetch(server_princ, &server);
    if(ret){
	kdc_log(0, "UNKNOWN -- %s: %s", server_name,
		krb5_get_err_text(context, ret));
a1083 4
    ret = check_flags(client, client_name, server, server_name, TRUE);
    if(ret)
	goto out;

d1087 34
d1122 2
a1123 2
	int i = 0;
	PA_DATA *pa;
d1126 2
d1129 2
a1130 1
	kdc_log(5, "Looking for PKINIT pa-data -- %s", client_name);
d1135 1
a1135 7
	if ((pa = find_padata(req, &i, KRB5_PADATA_PK_AS_REQ)))
	    ;
	if (pa == NULL) {
	    i = 0;
	    if((pa = find_padata(req, &i, KRB5_PADATA_PK_AS_REQ_19)))
		;
	}
d1138 1
a1138 2
	    if((pa = find_padata(req, &i, KRB5_PADATA_PK_AS_REQ_WIN)))
		;
d1143 1
a1143 1
	    ret = pk_rd_padata(context, req, pa, &pkp);
d1146 2
a1147 1
		kdc_log(5, "Failed to decode PKINIT PA-DATA -- %s", 
d1154 6
a1159 5
	    ret = pk_check_client(context, 
				  client_princ, 
				  client,
				  pkp,
				  &client_cert);
d1163 3
a1165 1
		pk_free_client_param(context, pkp);
d1167 1
a1167 1
		goto ts_enc;
d1169 1
d1172 2
a1173 1
	    kdc_log(2, "PKINIT pre-authentication succeeded -- %s using %s", 
d1181 2
a1182 1
	kdc_log(5, "Looking for ENC-TS pa-data -- %s", client_name);
d1186 1
a1186 1
	while((pa = find_padata(req, &i, KRB5_PADATA_ENC_TIMESTAMP))){
d1192 2
a1193 1
	    
d1195 7
a1201 1
	    
d1208 1
a1208 1
		kdc_log(5, "Failed to decode PA-DATA -- %s", 
d1212 3
a1214 2
	    
	    ret = hdb_enctype2key(context, client, enc_data.etype, &pa_key);
d1218 1
a1218 1
		ret = KRB5KDC_ERR_PREAUTH_FAILED;
d1222 2
a1223 1
		    kdc_log(5, "No client key matching pa-data (%d) -- %s", 
d1226 2
a1227 1
		    kdc_log(5, "No client key matching pa-data (%s) -- %s", 
a1229 1
		    
d1231 1
d1235 1
a1235 1
	  try_next_key:
d1238 3
a1240 2
		kdc_log(0, "krb5_crypto_init failed: %s",
			krb5_get_err_text(context, ret));
d1251 5
d1257 15
a1271 1
		if(hdb_next_enctype2key(context, client, 
d1274 2
d1277 5
a1281 4
		e_text = "Failed to decrypt PA-DATA";
		kdc_log (5, "Failed to decrypt PA-DATA -- %s",
			 client_name);
		ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
d1292 4
a1295 3
		ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
		kdc_log (5, "Failed to decode PA-ENC-TS_ENC -- %s",
			 client_name);
d1300 20
a1319 3
		ret = KRB5KDC_ERR_PREAUTH_FAILED;
		e_text = "Too large time skew";
		kdc_log(0, "Too large time skew -- %s", client_name);
d1323 13
a1335 2
	    kdc_log(2, "ENC-TS Pre-authentication succeeded -- %s", 
		    client_name);
d1341 1
a1341 1
	if(found_pa == 0 && require_preauth)
d1346 1
a1346 1
	    kdc_log(0, "%s -- %s", e_text, client_name);
d1350 4
a1353 3
    }else if (require_preauth
	      || client->flags.require_preauth
	      || server->flags.require_preauth) {
a1357 1
	krb5_data foo_data;
d1359 1
a1359 1
      use_pa: 
d1364 4
d1375 4
d1385 4
d1390 1
a1390 1
	pa->padata_type		= KRB5_PADATA_PK_AS_REQ_19;
d1395 35
a1429 7
	/* XXX check ret */
	if (only_older_enctype_p(req))
	    ret = get_pa_etype_info(&method_data, client, 
				    b->etype.val, b->etype.len); 
	/* XXX check ret */
	ret = get_pa_etype_info2(&method_data, client, 
				 b->etype.val, b->etype.len);
a1430 1
	
d1433 5
a1437 3
	foo_data.data   = buf;
	foo_data.length = len;
	
d1439 3
a1441 11
	krb5_mk_error(context,
		      ret,
		      "Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ",
		      &foo_data,
		      client_princ,
		      server_princ,
		      NULL,
		      NULL,
		      reply);
	free(buf);
	kdc_log(0, "No preauth found, returning PREAUTH-REQUIRED -- %s",
d1443 1
a1443 2
	ret = 0;
	goto out2;
d1445 14
a1458 5
    
    ret = find_keys(client, server, &ckey, &cetype, &skey, &setype,
		    b->etype.val, b->etype.len);
    if(ret) {
	kdc_log(0, "Server/client has no support for etypes");
a1459 5
    }
	
    {
	char *cet;
	char *set;
d1461 10
a1470 21
	ret = krb5_enctype_to_string(context, cetype, &cet);
	if(ret == 0) {
	    ret = krb5_enctype_to_string(context, setype, &set);
	    if (ret == 0) {
		kdc_log(5, "Using %s/%s", cet, set);
		free(set);
	    }
	    free(cet);
	}
	if (ret != 0)
	    kdc_log(5, "Using e-types %d/%d", cetype, setype);
    }
    
    {
	char str[128];
	unparse_flags(KDCOptions2int(f), asn1_KDCOptions_units(), 
		      str, sizeof(str));
	if(*str)
	    kdc_log(2, "Requested flags: %s", str);
    }
    
d1473 1
a1473 1
       || (f.request_anonymous && !allow_anonymous)) {
d1475 2
a1476 1
	kdc_log(0, "Bad KDC options -- %s", client_name);
d1479 1
a1479 1
    
d1482 8
a1489 5
    copy_Realm(&b->realm, &rep.crealm);
    if (f.request_anonymous)
	make_anonymous_principalname (&rep.cname);
    else
	copy_PrincipalName(b->cname, &rep.cname);
d1491 9
a1499 2
    copy_Realm(&b->realm, &rep.ticket.realm);
    copy_PrincipalName(b->sname, &rep.ticket.sname);
d1502 1
a1502 1
    if(client->flags.forwardable && server->flags.forwardable)
d1505 1
d1507 2
a1508 1
	kdc_log(0, "Ticket may not be forwardable -- %s", client_name);
d1511 1
a1511 1
    if(client->flags.proxiable && server->flags.proxiable)
d1514 1
d1516 2
a1517 1
	kdc_log(0, "Ticket may not be proxiable -- %s", client_name);
d1520 1
a1520 1
    if(client->flags.postdate && server->flags.postdate)
d1523 1
d1525 2
a1526 1
	kdc_log(0, "Ticket may not be postdatable -- %s", client_name);
d1531 2
a1532 1
    if(!check_addresses(b->addresses, from_addr)) {
d1534 2
a1535 1
	kdc_log(0, "Bad address list requested -- %s", client_name);
d1539 7
a1545 4
    krb5_generate_random_keyblock(context, setype, &et.key);
    copy_PrincipalName(&rep.cname, &et.cname);
    copy_Realm(&b->realm, &et.crealm);
    
d1549 1
a1549 1
	
d1551 1
a1551 1
    
d1558 1
a1558 1
	fix_time(&b->till);
d1563 4
a1566 4
	if(client->max_life)
	    t = start + min(t - start, *client->max_life);
	if(server->max_life)
	    t = start + min(t - start, *server->max_life);
d1584 4
a1587 4
	    if(client->max_renew)
		t = start + min(t - start, *client->max_renew);
	    if(server->max_renew)
		t = start + min(t - start, *server->max_renew);
d1599 1
a1599 1
    
d1604 1
a1604 1
    
d1606 1
a1606 3
    krb5_data_zero(&et.transited.contents); 
     
    copy_EncryptionKey(&et.key, &ek.key);
d1618 4
d1623 3
a1625 3
    if (client->pw_end
	&& (kdc_warn_pwexpire == 0
	    || kdc_time + kdc_warn_pwexpire <= *client->pw_end)) {
d1627 1
a1627 1
	ek.last_req.val[ek.last_req.len].lr_value = *client->pw_end;
d1630 1
a1630 1
    if (client->valid_end) {
d1632 1
a1632 1
	ek.last_req.val[ek.last_req.len].lr_value = *client->valid_end;
d1641 1
a1641 1
    if (client->valid_end || client->pw_end) {
d1643 4
a1646 3
	if (client->valid_end) {
	    if (client->pw_end)
		*ek.key_expiration = min(*client->valid_end, *client->pw_end);
d1648 1
a1648 1
		*ek.key_expiration = *client->valid_end;
d1650 1
a1650 1
	    *ek.key_expiration = *client->pw_end;
a1670 5
    ALLOC(rep.padata);
    rep.padata->len = 0;
    rep.padata->val = NULL;

    reply_key = &ckey->key;
d1673 17
a1689 2
	ret = pk_mk_pa_reply(context, pkp, client, req,
			     &reply_key, rep.padata);
a1692 1
#endif
d1694 61
a1754 1
    set_salt_padata (rep.padata, ckey->salt);
d1761 54
a1814 2
    ret = encode_reply(&rep, &et, &ek, setype, server->kvno, &skey->key,
		       client->kvno, reply_key, &e_text, reply);
d1817 11
a1827 1
  out:
d1829 1
a1829 1
    if(ret){
d1833 1
a1833 1
		      NULL,
a1840 1
  out2:
d1843 1
a1843 1
	pk_free_client_param(context, pkp);
d1845 2
d1854 1
a1854 1
	free_ent(client);
d1856 1
a1856 476
	free_ent(server);
    return ret;
}


static krb5_error_code
check_tgs_flags(KDC_REQ_BODY *b, EncTicketPart *tgt, EncTicketPart *et)
{
    KDCOptions f = b->kdc_options;
	
    if(f.validate){
	if(!tgt->flags.invalid || tgt->starttime == NULL){
	    kdc_log(0, "Bad request to validate ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	if(*tgt->starttime > kdc_time){
	    kdc_log(0, "Early request to validate ticket");
	    return KRB5KRB_AP_ERR_TKT_NYV;
	}
	/* XXX  tkt = tgt */
	et->flags.invalid = 0;
    }else if(tgt->flags.invalid){
	kdc_log(0, "Ticket-granting ticket has INVALID flag set");
	return KRB5KRB_AP_ERR_TKT_INVALID;
    }

    if(f.forwardable){
	if(!tgt->flags.forwardable){
	    kdc_log(0, "Bad request for forwardable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	et->flags.forwardable = 1;
    }
    if(f.forwarded){
	if(!tgt->flags.forwardable){
	    kdc_log(0, "Request to forward non-forwardable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	et->flags.forwarded = 1;
	et->caddr = b->addresses;
    }
    if(tgt->flags.forwarded)
	et->flags.forwarded = 1;
	
    if(f.proxiable){
	if(!tgt->flags.proxiable){
	    kdc_log(0, "Bad request for proxiable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	et->flags.proxiable = 1;
    }
    if(f.proxy){
	if(!tgt->flags.proxiable){
	    kdc_log(0, "Request to proxy non-proxiable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	et->flags.proxy = 1;
	et->caddr = b->addresses;
    }
    if(tgt->flags.proxy)
	et->flags.proxy = 1;

    if(f.allow_postdate){
	if(!tgt->flags.may_postdate){
	    kdc_log(0, "Bad request for post-datable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	et->flags.may_postdate = 1;
    }
    if(f.postdated){
	if(!tgt->flags.may_postdate){
	    kdc_log(0, "Bad request for postdated ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	if(b->from)
	    *et->starttime = *b->from;
	et->flags.postdated = 1;
	et->flags.invalid = 1;
    }else if(b->from && *b->from > kdc_time + context->max_skew){
	kdc_log(0, "Ticket cannot be postdated");
	return KRB5KDC_ERR_CANNOT_POSTDATE;
    }

    if(f.renewable){
	if(!tgt->flags.renewable){
	    kdc_log(0, "Bad request for renewable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	et->flags.renewable = 1;
	ALLOC(et->renew_till);
	fix_time(&b->rtime);
	*et->renew_till = *b->rtime;
    }
    if(f.renew){
	time_t old_life;
	if(!tgt->flags.renewable || tgt->renew_till == NULL){
	    kdc_log(0, "Request to renew non-renewable ticket");
	    return KRB5KDC_ERR_BADOPTION;
	}
	old_life = tgt->endtime;
	if(tgt->starttime)
	    old_life -= *tgt->starttime;
	else
	    old_life -= tgt->authtime;
	et->endtime = *et->starttime + old_life;
	if (et->renew_till != NULL)
	    et->endtime = min(*et->renew_till, et->endtime);
    }	    
    
    /* checks for excess flags */
    if(f.request_anonymous && !allow_anonymous){
	kdc_log(0, "Request for anonymous ticket");
	return KRB5KDC_ERR_BADOPTION;
    }
    return 0;
}

static krb5_error_code
fix_transited_encoding(krb5_boolean check_policy,
		       TransitedEncoding *tr, 
		       EncTicketPart *et, 
		       const char *client_realm, 
		       const char *server_realm, 
		       const char *tgt_realm)
{
    krb5_error_code ret = 0;
    char **realms, **tmp;
    int num_realms;
    int i;

    if(tr->tr_type != DOMAIN_X500_COMPRESS) {
	kdc_log(0, "Unknown transited type: %u", tr->tr_type);
	return KRB5KDC_ERR_TRTYPE_NOSUPP;
    }

    ret = krb5_domain_x500_decode(context, 
				  tr->contents,
				  &realms, 
				  &num_realms,
				  client_realm,
				  server_realm);
    if(ret){
	krb5_warn(context, ret, "Decoding transited encoding");
	return ret;
    }
    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {
	/* not us, so add the previous realm to transited set */
	if (num_realms < 0 || num_realms + 1 > UINT_MAX/sizeof(*realms)) {
	    ret = ERANGE;
	    goto free_realms;
	}
	tmp = realloc(realms, (num_realms + 1) * sizeof(*realms));
	if(tmp == NULL){
	    ret = ENOMEM;
	    goto free_realms;
	}
	realms = tmp;
	realms[num_realms] = strdup(tgt_realm);
	if(realms[num_realms] == NULL){
	    ret = ENOMEM;
	    goto free_realms;
	}
	num_realms++;
    }
    if(num_realms == 0) {
	if(strcmp(client_realm, server_realm)) 
	    kdc_log(0, "cross-realm %s -> %s", client_realm, server_realm);
    } else {
	size_t l = 0;
	char *rs;
	for(i = 0; i < num_realms; i++)
	    l += strlen(realms[i]) + 2;
	rs = malloc(l);
	if(rs != NULL) {
	    *rs = '\0';
	    for(i = 0; i < num_realms; i++) {
		if(i > 0)
		    strlcat(rs, ", ", l);
		strlcat(rs, realms[i], l);
	    }
	    kdc_log(0, "cross-realm %s -> %s via [%s]", client_realm, server_realm, rs);
	    free(rs);
	}
    }
    if(check_policy) {
	ret = krb5_check_transited(context, client_realm, 
				   server_realm, 
				   realms, num_realms, NULL);
	if(ret) {
	    krb5_warn(context, ret, "cross-realm %s -> %s", 
		      client_realm, server_realm);
	    goto free_realms;
	}
	et->flags.transited_policy_checked = 1;
    }
    et->transited.tr_type = DOMAIN_X500_COMPRESS;
    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);
    if(ret)
	krb5_warn(context, ret, "Encoding transited encoding");
  free_realms:
    for(i = 0; i < num_realms; i++)
	free(realms[i]);
    free(realms);
    return ret;
}


static krb5_error_code
tgs_make_reply(KDC_REQ_BODY *b, 
	       EncTicketPart *tgt, 
	       EncTicketPart *adtkt, 
	       AuthorizationData *auth_data,
	       hdb_entry *server, 
	       hdb_entry *client, 
	       krb5_principal client_principal, 
	       hdb_entry *krbtgt,
	       krb5_enctype cetype,
	       const char **e_text,
	       krb5_data *reply)
{
    KDC_REP rep;
    EncKDCRepPart ek;
    EncTicketPart et;
    KDCOptions f = b->kdc_options;
    krb5_error_code ret;
    krb5_enctype etype;
    Key *skey;
    EncryptionKey *ekey;
    
    if(adtkt) {
	int i;
	krb5_keytype kt;
	ekey = &adtkt->key;
	for(i = 0; i < b->etype.len; i++){
	    ret = krb5_enctype_to_keytype(context, b->etype.val[i], &kt);
	    if(ret)
		continue;
	    if(adtkt->key.keytype == kt)
		break;
	}
	if(i == b->etype.len)
	    return KRB5KDC_ERR_ETYPE_NOSUPP;
	etype = b->etype.val[i];
    }else{
	ret = find_keys(NULL, server, NULL, NULL, &skey, &etype, 
			b->etype.val, b->etype.len);
	if(ret) {
	    kdc_log(0, "Server has no support for etypes");
	    return ret;
	}
	ekey = &skey->key;
    }
    
    memset(&rep, 0, sizeof(rep));
    memset(&et, 0, sizeof(et));
    memset(&ek, 0, sizeof(ek));
    
    rep.pvno = 5;
    rep.msg_type = krb_tgs_rep;

    et.authtime = tgt->authtime;
    fix_time(&b->till);
    et.endtime = min(tgt->endtime, *b->till);
    ALLOC(et.starttime);
    *et.starttime = kdc_time;
    
    ret = check_tgs_flags(b, tgt, &et);
    if(ret)
	goto out;

    /* We should check the transited encoding if:
       1) the request doesn't ask not to be checked
       2) globally enforcing a check
       3) principal requires checking
       4) we allow non-check per-principal, but principal isn't marked as allowing this
       5) we don't globally allow this
    */

#define GLOBAL_FORCE_TRANSITED_CHECK		(trpolicy == TRPOLICY_ALWAYS_CHECK)
#define GLOBAL_ALLOW_PER_PRINCIPAL		(trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)
#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK	(trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)
/* these will consult the database in future release */
#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)		0
#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)	0

    ret = fix_transited_encoding(!f.disable_transited_check ||
				 GLOBAL_FORCE_TRANSITED_CHECK ||
				 PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||
				 !((GLOBAL_ALLOW_PER_PRINCIPAL && 
				    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||
				   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),
				 &tgt->transited, &et,
				 *krb5_princ_realm(context, client_principal),
				 *krb5_princ_realm(context, server->principal),
				 *krb5_princ_realm(context, krbtgt->principal));
    if(ret)
	goto out;

    copy_Realm(krb5_princ_realm(context, server->principal), 
	       &rep.ticket.realm);
    _krb5_principal2principalname(&rep.ticket.sname, server->principal);
    copy_Realm(&tgt->crealm, &rep.crealm);
    if (f.request_anonymous)
	make_anonymous_principalname (&tgt->cname);
    else
	copy_PrincipalName(&tgt->cname, &rep.cname);
    rep.ticket.tkt_vno = 5;

    ek.caddr = et.caddr;
    if(et.caddr == NULL)
	et.caddr = tgt->caddr;

    {
	time_t life;
	life = et.endtime - *et.starttime;
	if(client && client->max_life)
	    life = min(life, *client->max_life);
	if(server->max_life)
	    life = min(life, *server->max_life);
	et.endtime = *et.starttime + life;
    }
    if(f.renewable_ok && tgt->flags.renewable && 
       et.renew_till == NULL && et.endtime < *b->till){
	et.flags.renewable = 1;
	ALLOC(et.renew_till);
	*et.renew_till = *b->till;
    }
    if(et.renew_till){
	time_t renew;
	renew = *et.renew_till - et.authtime;
	if(client && client->max_renew)
	    renew = min(renew, *client->max_renew);
	if(server->max_renew)
	    renew = min(renew, *server->max_renew);
	*et.renew_till = et.authtime + renew;
    }
	    
    if(et.renew_till){
	*et.renew_till = min(*et.renew_till, *tgt->renew_till);
	*et.starttime = min(*et.starttime, *et.renew_till);
	et.endtime = min(et.endtime, *et.renew_till);
    }
    
    *et.starttime = min(*et.starttime, et.endtime);

    if(*et.starttime == et.endtime){
	ret = KRB5KDC_ERR_NEVER_VALID;
	goto out;
    }
    if(et.renew_till && et.endtime == *et.renew_till){
	free(et.renew_till);
	et.renew_till = NULL;
	et.flags.renewable = 0;
    }
    
    et.flags.pre_authent = tgt->flags.pre_authent;
    et.flags.hw_authent  = tgt->flags.hw_authent;
    et.flags.anonymous   = tgt->flags.anonymous;
    et.flags.ok_as_delegate = server->flags.ok_as_delegate;
	    
    /* XXX Check enc-authorization-data */
    et.authorization_data = auth_data;

    krb5_generate_random_keyblock(context, etype, &et.key);
    et.crealm = tgt->crealm;
    et.cname = tgt->cname;
	    
    ek.key = et.key;
    /* MIT must have at least one last_req */
    ek.last_req.len = 1;
    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));
    ek.nonce = b->nonce;
    ek.flags = et.flags;
    ek.authtime = et.authtime;
    ek.starttime = et.starttime;
    ek.endtime = et.endtime;
    ek.renew_till = et.renew_till;
    ek.srealm = rep.ticket.realm;
    ek.sname = rep.ticket.sname;
	    
    /* It is somewhat unclear where the etype in the following
       encryption should come from. What we have is a session
       key in the passed tgt, and a list of preferred etypes
       *for the new ticket*. Should we pick the best possible
       etype, given the keytype in the tgt, or should we look
       at the etype list here as well?  What if the tgt
       session key is DES3 and we want a ticket with a (say)
       CAST session key. Should the DES3 etype be added to the
       etype list, even if we don't want a session key with
       DES3? */
    ret = encode_reply(&rep, &et, &ek, etype, adtkt ? 0 : server->kvno, ekey,
		       0, &tgt->key, e_text, reply);
  out:
    free_TGS_REP(&rep);
    free_TransitedEncoding(&et.transited);
    if(et.starttime)
	free(et.starttime);
    if(et.renew_till)
	free(et.renew_till);
    free_LastReq(&ek.last_req);
    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);
    free_EncryptionKey(&et.key);
    return ret;
}

static krb5_error_code
tgs_check_authenticator(krb5_auth_context ac,
			KDC_REQ_BODY *b, 
			const char **e_text,
			krb5_keyblock *key)
{
    krb5_authenticator auth;
    size_t len;
    unsigned char *buf;
    size_t buf_size;
    krb5_error_code ret;
    krb5_crypto crypto;
    
    krb5_auth_con_getauthenticator(context, ac, &auth);
    if(auth->cksum == NULL){
	kdc_log(0, "No authenticator in request");
	ret = KRB5KRB_AP_ERR_INAPP_CKSUM;
	goto out;
    }
    /*
     * according to RFC1510 it doesn't need to be keyed,
     * but according to the latest draft it needs to.
     */
    if (
#if 0
!krb5_checksum_is_keyed(context, auth->cksum->cksumtype)
	||
#endif
 !krb5_checksum_is_collision_proof(context, auth->cksum->cksumtype)) {
	kdc_log(0, "Bad checksum type in authenticator: %d", 
		auth->cksum->cksumtype);
	ret =  KRB5KRB_AP_ERR_INAPP_CKSUM;
	goto out;
    }
		
    /* XXX should not re-encode this */
    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, b, &len, ret);
    if(ret){
	kdc_log(0, "Failed to encode KDC-REQ-BODY: %s", 
		krb5_get_err_text(context, ret));
	goto out;
    }
    if(buf_size != len) {
	free(buf);
	kdc_log(0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	ret = KRB5KRB_ERR_GENERIC;
	goto out;
    }
    ret = krb5_crypto_init(context, key, 0, &crypto);
    if (ret) {
	free(buf);
	kdc_log(0, "krb5_crypto_init failed: %s",
		krb5_get_err_text(context, ret));
	goto out;
    }
    ret = krb5_verify_checksum(context,
			       crypto,
			       KRB5_KU_TGS_REQ_AUTH_CKSUM,
			       buf, 
			       len,
			       auth->cksum);
    free(buf);
    krb5_crypto_destroy(context, crypto);
    if(ret){
	kdc_log(0, "Failed to verify checksum: %s", 
		krb5_get_err_text(context, ret));
    }
out:
    free_Authenticator(auth);
    free(auth);
d1861 2
a1862 1
 * return the realm of a krbtgt-ticket or NULL
d1865 5
a1869 25
static Realm 
get_krbtgt_realm(const PrincipalName *p)
{
    if(p->name_string.len == 2
       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)
	return p->name_string.val[1];
    else
	return NULL;
}

static Realm
find_rpath(Realm crealm, Realm srealm)
{
    const char *new_realm = krb5_config_get_string(context,
						   NULL,
						   "capaths", 
						   crealm,
						   srealm,
						   NULL);
    return (Realm)new_realm;
}
	    

static krb5_boolean
need_referral(krb5_principal server, krb5_realm **realms)
a1870 18
    if(server->name.name_type != KRB5_NT_SRV_INST ||
       server->name.name_string.len != 2)
	return FALSE;
 
    return _krb5_get_host_realm_int(context, server->name.name_string.val[1],
				    FALSE, realms) == 0;
}

static krb5_error_code
tgs_rep2(KDC_REQ_BODY *b,
	 PA_DATA *tgs_req,
	 krb5_data *reply,
	 const char *from,
	 const struct sockaddr *from_addr,
	 time_t **csec,
	 int **cusec)
{
    krb5_ap_req ap_req;
d1872 1
a1872 7
    krb5_principal princ;
    krb5_auth_context ac = NULL;
    krb5_ticket *ticket = NULL;
    krb5_flags ap_req_options;
    krb5_flags verify_ap_req_flags;
    const char *e_text = NULL;
    krb5_crypto crypto;
d1874 6
a1879 94
    hdb_entry *krbtgt = NULL;
    EncTicketPart *tgt;
    Key *tkey;
    krb5_enctype cetype;
    krb5_principal cp = NULL;
    krb5_principal sp = NULL;
    AuthorizationData *auth_data = NULL;

    *csec  = NULL;
    *cusec = NULL;

    memset(&ap_req, 0, sizeof(ap_req));
    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);
    if(ret){
	kdc_log(0, "Failed to decode AP-REQ: %s", 
		krb5_get_err_text(context, ret));
	goto out2;
    }
    
    if(!get_krbtgt_realm(&ap_req.ticket.sname)){
	/* XXX check for ticket.sname == req.sname */
	kdc_log(0, "PA-DATA is not a ticket-granting ticket");
	ret = KRB5KDC_ERR_POLICY; /* ? */
	goto out2;
    }
    
    _krb5_principalname2krb5_principal(&princ,
				       ap_req.ticket.sname,
				       ap_req.ticket.realm);
    
    ret = db_fetch(princ, &krbtgt);

    if(ret) {
	char *p;
	ret = krb5_unparse_name(context, princ, &p);
	if (ret != 0)
	    p = "<unparse_name failed>";
	krb5_free_principal(context, princ);
	kdc_log(0, "Ticket-granting ticket not found in database: %s: %s",
		p, krb5_get_err_text(context, ret));
	if (ret == 0)
	    free(p);
	ret = KRB5KRB_AP_ERR_NOT_US;
	goto out2;
    }
    
    if(ap_req.ticket.enc_part.kvno && 
       *ap_req.ticket.enc_part.kvno != krbtgt->kvno){
	char *p;

	ret = krb5_unparse_name (context, princ, &p);
	krb5_free_principal(context, princ);
	if (ret != 0)
	    p = "<unparse_name failed>";
	kdc_log(0, "Ticket kvno = %d, DB kvno = %d (%s)", 
		*ap_req.ticket.enc_part.kvno,
		krbtgt->kvno,
		p);
	if (ret == 0)
	    free (p);
	ret = KRB5KRB_AP_ERR_BADKEYVER;
	goto out2;
    }

    ret = hdb_enctype2key(context, krbtgt, ap_req.ticket.enc_part.etype, &tkey);
    if(ret){
	char *str;
	krb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);
	kdc_log(0, "No server key found for %s", str);
	free(str);
	ret = KRB5KRB_AP_ERR_BADKEYVER;
	goto out2;
    }
    
    if (b->kdc_options.validate)
	verify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;
    else
	verify_ap_req_flags = 0;

    ret = krb5_verify_ap_req2(context,
			      &ac,
			      &ap_req,
			      princ,
			      &tkey->key,
			      verify_ap_req_flags,
			      &ap_req_options,
			      &ticket,
			      KRB5_KU_TGS_REQ_AUTH);
			     
    krb5_free_principal(context, princ);
    if(ret) {
	kdc_log(0, "Failed to verify AP-REQ: %s", 
		krb5_get_err_text(context, ret));
	goto out2;
d1882 1
d1884 2
a1885 1
	krb5_authenticator auth;
d1887 2
a1888 21
	ret = krb5_auth_con_getauthenticator(context, ac, &auth);
	if (ret == 0) {
	    *csec   = malloc(sizeof(**csec));
	    if (*csec == NULL) {
		krb5_free_authenticator(context, &auth);
		kdc_log(0, "malloc failed");
		goto out2;
	    }
	    **csec  = auth->ctime;
	    *cusec  = malloc(sizeof(**cusec));
	    if (*cusec == NULL) {
		krb5_free_authenticator(context, &auth);
		kdc_log(0, "malloc failed");
		goto out2;
	    }
	    **csec  = auth->cusec;
	    krb5_free_authenticator(context, &auth);
	}
    }

    cetype = ap_req.authenticator.etype;
d1890 1
a1890 32
    tgt = &ticket->ticket;

    ret = tgs_check_authenticator(ac, b, &e_text, &tgt->key);

    if (b->enc_authorization_data) {
	krb5_keyblock *subkey;
	krb5_data ad;
	ret = krb5_auth_con_getremotesubkey(context,
					    ac,
					    &subkey);
	if(ret){
	    krb5_auth_con_free(context, ac);
	    kdc_log(0, "Failed to get remote subkey: %s", 
		    krb5_get_err_text(context, ret));
	    goto out2;
	}
	if(subkey == NULL){
	    ret = krb5_auth_con_getkey(context, ac, &subkey);
	    if(ret) {
		krb5_auth_con_free(context, ac);
		kdc_log(0, "Failed to get session key: %s", 
			krb5_get_err_text(context, ret));
		goto out2;
	    }
	}
	if(subkey == NULL){
	    krb5_auth_con_free(context, ac);
	    kdc_log(0, "Failed to get key for enc-authorization-data");
	    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */
	    goto out2;
	}
	ret = krb5_crypto_init(context, subkey, 0, &crypto);
d1892 2
a1893 27
	    krb5_auth_con_free(context, ac);
	    kdc_log(0, "krb5_crypto_init failed: %s",
		    krb5_get_err_text(context, ret));
	    goto out2;
	}
	ret = krb5_decrypt_EncryptedData (context,
					  crypto,
					  KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY,
					  b->enc_authorization_data,
					  &ad);
	krb5_crypto_destroy(context, crypto);
	if(ret){
	    krb5_auth_con_free(context, ac);
	    kdc_log(0, "Failed to decrypt enc-authorization-data");
	    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */
	    goto out2;
	}
	krb5_free_keyblock(context, subkey);
	ALLOC(auth_data);
	ret = decode_AuthorizationData(ad.data, ad.length, auth_data, NULL);
	if(ret){
	    krb5_auth_con_free(context, ac);
	    free(auth_data);
	    auth_data = NULL;
	    kdc_log(0, "Failed to decode authorization data");
	    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */
	    goto out2;
a1894 1
    }
d1896 1
a1896 51
    krb5_auth_con_free(context, ac);

    if(ret){
	kdc_log(0, "Failed to verify authenticator: %s", 
		krb5_get_err_text(context, ret));
	goto out2;
    }
    
    {
	PrincipalName *s;
	Realm r;
	char *spn = NULL, *cpn = NULL;
	hdb_entry *server = NULL, *client = NULL;
	int loop = 0;
	EncTicketPart adtkt;
	char opt_str[128];

	s = b->sname;
	r = b->realm;
	if(b->kdc_options.enc_tkt_in_skey){
	    Ticket *t;
	    hdb_entry *uu;
	    krb5_principal p;
	    Key *tkey;
	    
	    if(b->additional_tickets == NULL || 
	       b->additional_tickets->len == 0){
		ret = KRB5KDC_ERR_BADOPTION; /* ? */
		kdc_log(0, "No second ticket present in request");
		goto out;
	    }
	    t = &b->additional_tickets->val[0];
	    if(!get_krbtgt_realm(&t->sname)){
		kdc_log(0, "Additional ticket is not a ticket-granting ticket");
		ret = KRB5KDC_ERR_POLICY;
		goto out2;
	    }
	    _krb5_principalname2krb5_principal(&p, t->sname, t->realm);
	    ret = db_fetch(p, &uu);
	    krb5_free_principal(context, p);
	    if(ret){
		if (ret == HDB_ERR_NOENTRY)
		    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
		goto out;
	    }
	    ret = hdb_enctype2key(context, uu, t->enc_part.etype, &tkey);
	    if(ret){
		ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */
		goto out;
	    }
	    ret = krb5_decrypt_ticket(context, t, &tkey->key, &adtkt, 0);
d1898 8
a1905 4
	    if(ret)
		goto out;
	    s = &adtkt.cname;
	    r = adtkt.crealm;
d1907 2
d1910 5
a1914 61
	_krb5_principalname2krb5_principal(&sp, *s, r);
	ret = krb5_unparse_name(context, sp, &spn);	
	if (ret)
	    goto out;
	_krb5_principalname2krb5_principal(&cp, tgt->cname, tgt->crealm);
	ret = krb5_unparse_name(context, cp, &cpn);
	if (ret)
	    goto out;
	unparse_flags (KDCOptions2int(b->kdc_options),
		       asn1_KDCOptions_units(),
		       opt_str, sizeof(opt_str));
	if(*opt_str)
	    kdc_log(0, "TGS-REQ %s from %s for %s [%s]", 
		    cpn, from, spn, opt_str);
	else
	    kdc_log(0, "TGS-REQ %s from %s for %s", cpn, from, spn);
    server_lookup:
	ret = db_fetch(sp, &server);

	if(ret){
	    Realm req_rlm, new_rlm;
	    krb5_realm *realms;

	    if ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {
		if(loop++ < 2) {
		    new_rlm = find_rpath(tgt->crealm, req_rlm);
		    if(new_rlm) {
			kdc_log(5, "krbtgt for realm %s not found, trying %s", 
				req_rlm, new_rlm);
			krb5_free_principal(context, sp);
			free(spn);
			krb5_make_principal(context, &sp, r, 
					    KRB5_TGS_NAME, new_rlm, NULL);
			ret = krb5_unparse_name(context, sp, &spn);	
			if (ret)
			    goto out;
			goto server_lookup;
		    }
		}
	    } else if(need_referral(sp, &realms)) {
		if (strcmp(realms[0], sp->realm) != 0) {
		    kdc_log(5, "returning a referral to realm %s for "
			    "server %s that was not found",
			    realms[0], spn);
		    krb5_free_principal(context, sp);
		    free(spn);
		    krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,
					realms[0], NULL);
		    ret = krb5_unparse_name(context, sp, &spn);
		    if (ret)
			goto out;
		    krb5_free_host_realm(context, realms);
		    goto server_lookup;
		}
		krb5_free_host_realm(context, realms);
	    }
	    kdc_log(0, "Server not found in database: %s: %s", spn,
		    krb5_get_err_text(context, ret));
	    if (ret == HDB_ERR_NOENTRY)
		ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	    goto out;
a1915 118

	ret = db_fetch(cp, &client);
	if(ret)
	    kdc_log(1, "Client not found in database: %s: %s",
		    cpn, krb5_get_err_text(context, ret));
#if 0
	/* XXX check client only if same realm as krbtgt-instance */
	if(ret){
	    kdc_log(0, "Client not found in database: %s: %s",
		    cpn, krb5_get_err_text(context, ret));
	    if (ret == HDB_ERR_NOENTRY)
		ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    goto out;
	}
#endif

	if(strcmp(krb5_principal_get_realm(context, sp),
		  krb5_principal_get_comp_string(context, krbtgt->principal, 1)) != 0) {
	    char *tpn;
	    ret = krb5_unparse_name(context, krbtgt->principal, &tpn);
	    kdc_log(0, "Request with wrong krbtgt: %s", (ret == 0) ? tpn : "<unknown>");
	    if(ret == 0)
		free(tpn);
	    ret = KRB5KRB_AP_ERR_NOT_US;
	    goto out;
	    
	}

	ret = check_flags(client, cpn, server, spn, FALSE);
	if(ret)
	    goto out;

	if((b->kdc_options.validate || b->kdc_options.renew) && 
	   !krb5_principal_compare(context, 
				   krbtgt->principal,
				   server->principal)){
	    kdc_log(0, "Inconsistent request.");
	    ret = KRB5KDC_ERR_SERVER_NOMATCH;
	    goto out;
	}

	/* check for valid set of addresses */
	if(!check_addresses(tgt->caddr, from_addr)) {
	    ret = KRB5KRB_AP_ERR_BADADDR;
	    kdc_log(0, "Request from wrong address");
	    goto out;
	}
	
	ret = tgs_make_reply(b, 
			     tgt, 
			     b->kdc_options.enc_tkt_in_skey ? &adtkt : NULL, 
			     auth_data,
			     server, 
			     client, 
			     cp, 
			     krbtgt, 
			     cetype, 
			     &e_text,
			     reply);
	
    out:
	free(spn);
	free(cpn);
	    
	if(server)
	    free_ent(server);
	if(client)
	    free_ent(client);
    }
out2:
    if(ret) {
	krb5_mk_error(context,
		      ret,
		      e_text,
		      NULL,
		      cp,
		      sp,
		      NULL,
		      NULL,
		      reply);
	free(*csec);
	free(*cusec);
	*csec  = NULL;
	*cusec = NULL;
    }
    krb5_free_principal(context, cp);
    krb5_free_principal(context, sp);
    if (ticket)
	krb5_free_ticket(context, ticket);
    free_AP_REQ(&ap_req);
    if(auth_data){
	free_AuthorizationData(auth_data);
	free(auth_data);
    }

    if(krbtgt)
	free_ent(krbtgt);

    return ret;
}


krb5_error_code
tgs_rep(KDC_REQ *req, 
	krb5_data *data,
	const char *from,
	struct sockaddr *from_addr)
{
    krb5_error_code ret;
    int i = 0;
    PA_DATA *tgs_req = NULL;
    time_t *csec = NULL;
    int *cusec = NULL;

    if(req->padata == NULL){
	ret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */
	kdc_log(0, "TGS-REQ from %s without PA-DATA", from);
	goto out;
a1916 2
    
    tgs_req = find_padata(req, &i, KRB5_PADATA_TGS_REQ);
a1917 22
    if(tgs_req == NULL){
	ret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;
	
	kdc_log(0, "TGS-REQ from %s without PA-TGS-REQ", from);
	goto out;
    }
    ret = tgs_rep2(&req->req_body, tgs_req, data, from, from_addr,
		   &csec, &cusec);
out:
    if(ret && data->data == NULL){
	krb5_mk_error(context,
		      ret,
		      NULL,
		      NULL,
		      NULL,
		      NULL,
		      csec,
		      cusec,
		      data);
    }
    free(csec);
    free(cusec);
@


1.3
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.145.2.4 2004/08/13 19:28:26 lha Exp $");
d50 12
d63 1
a63 1
set_salt_padata (METHOD_DATA **m, Salt *salt)
d66 2
a67 4
	ALLOC(*m);
	(*m)->len = 1;
	ALLOC((*m)->val);
	(*m)->val->padata_type = salt->type;
d69 1
a69 1
			  &(*m)->val->padata_value);
d100 3
d128 1
d130 1
d136 5
a140 1
	    kdc_log(0, "Client has no support for etypes");
d149 5
a153 1
	    kdc_log(0, "Server has no support for etypes");
a286 12
static int
realloc_method_data(METHOD_DATA *md)
{
    PA_DATA *pa;
    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));
    if(pa == NULL)
	return ENOMEM;
    md->val = pa;
    md->len++;
    return 0;
}

d343 1
d350 3
a352 1
	    if(client->keys.val[i].key.keytype == etypes[j])
d358 1
d367 2
d374 1
a374 1
      skip2:;
d379 3
a381 1
	krb5_unparse_name(context, client->principal, &name);
d384 3
a386 2
	free(name);
	pa.len = n;
d405 158
d687 4
d698 3
a700 2
	principalname2krb5_principal (&server_princ, *(b->sname), b->realm);
	krb5_unparse_name(context, server_princ, &server_name);
d711 3
a713 2
	principalname2krb5_principal (&client_princ, *(b->cname), b->realm);
	krb5_unparse_name(context, client_princ, &client_name);
d720 2
a721 1
    kdc_log(0, "AS-REQ %s from %s for %s", client_name, from, server_name);
d750 58
a807 1
	kdc_log(5, "Looking for pa-data -- %s", client_name);
a810 1
	    time_t patime;
a885 1
	    patime = p.patimestamp;
d894 2
a895 1
	    kdc_log(2, "Pre-authentication succeded -- %s", client_name);
d898 3
d929 22
a950 2
	ret = get_pa_etype_info(&method_data, client, 
				b->etype.val, b->etype.len); /* XXX check ret */
d960 1
a960 1
		      "Need to use PA-ENC-TIMESTAMP",
d968 2
a969 1
	kdc_log(0, "No PA-ENC-TIMESTAMP -- %s", client_name);
d1000 2
a1001 1
	unparse_flags(KDCOptions2int(f), KDCOptions_units, str, sizeof(str));
d1181 21
a1201 1
    set_salt_padata (&rep.padata, ckey->salt);
d1203 1
a1203 1
		       client->kvno, &ckey->key, &e_text, reply);
d1221 4
d1534 1
a1534 1
    krb5_principal2principalname(&rep.ticket.sname, server->principal);
d1592 1
d1747 2
a1748 2
    return krb5_get_host_realm_int(context, server->name.name_string.val[1],
				   FALSE, realms) == 0;
d1796 3
a1798 3
    principalname2krb5_principal(&princ,
				 ap_req.ticket.sname,
				 ap_req.ticket.realm);
d1804 3
a1806 1
	krb5_unparse_name(context, princ, &p);
d1810 2
a1811 1
	free(p);
d1820 1
a1820 1
	krb5_unparse_name (context, princ, &p);
d1822 2
d1828 2
a1829 1
	free (p);
d1991 1
a1991 1
	    principalname2krb5_principal(&p, t->sname, t->realm);
d2012 10
a2021 5
	principalname2krb5_principal(&sp, *s, r);
	krb5_unparse_name(context, sp, &spn);	
	principalname2krb5_principal(&cp, tgt->cname, tgt->crealm);
	krb5_unparse_name(context, cp, &cpn);
	unparse_flags (KDCOptions2int(b->kdc_options), KDCOptions_units,
d2045 3
a2047 1
			krb5_unparse_name(context, sp, &spn);	
d2060 3
a2062 1
		    krb5_unparse_name(context, sp, &spn);
d2161 1
a2161 1
    if (ticket) {
a2162 2
	free(ticket);
    }
@


1.2
log
@Fix cross-realm trust vulnerability. Adapted from FreeBSD patch.

ok beck@@ hin@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.145 2003/04/15 11:07:39 lha Exp $");
d334 3
d345 1
d350 1
a350 1
		goto skip;
d357 1
a357 1
      skip:;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.123 2001/01/30 01:44:08 assar Exp $");
d81 1
a81 1
find_etype(hdb_entry *princ, unsigned *etypes, unsigned len, 
d112 1
a112 1
	  int *etypes,
d159 1
d162 2
a163 1
    unsigned char buf[8192]; /* XXX The data could be indefinite */
d168 1
a168 1
    ret = encode_EncTicketPart(buf + sizeof(buf) - 1, sizeof(buf), et, &len);
d174 6
a179 1
    
d183 1
d189 8
a196 8
    krb5_encrypt_EncryptedData(context, 
			       crypto,
			       KRB5_KU_TICKET,
			       buf + sizeof(buf) - len,
			       len,
			       skvno,
			       &rep->ticket.enc_part);

d198 5
d205 1
a205 2
	ret = encode_EncASRepPart(buf + sizeof(buf) - 1, sizeof(buf), 
				  ek, &len);
d207 1
a207 2
	ret = encode_EncTGSRepPart(buf + sizeof(buf) - 1, sizeof(buf), 
				   ek, &len);
d213 6
d221 1
d230 1
a230 1
				   buf + sizeof(buf) - len,
d234 2
a235 1
	ret = encode_AS_REP(buf + sizeof(buf) - 1, sizeof(buf), rep, &len);
d240 1
a240 1
				   buf + sizeof(buf) - len,
d244 2
a245 1
	ret = encode_TGS_REP(buf + sizeof(buf) - 1, sizeof(buf), rep, &len);
d253 8
a260 1
    krb5_data_copy(reply, buf + sizeof(buf) - len, len);
d277 40
a316 1
get_pa_etype_info(METHOD_DATA *md, hdb_entry *client)
d319 2
a320 1
    int i;
d327 2
d332 11
d344 19
a362 39
	pa.val[i].etype = client->keys.val[i].key.keytype;
	if(client->keys.val[i].salt){
	    ALLOC(pa.val[i].salttype);
#if 0
	    if(client->keys.val[i].salt->type == hdb_pw_salt)
		*pa.val[i].salttype = 0; /* or 1? or NULL? */
	    else if(client->keys.val[i].salt->type == hdb_afs3_salt)
		*pa.val[i].salttype = 2;
	    else {
		free_ETYPE_INFO(&pa);
		kdc_log(0, "unknown salt-type: %d", 
			client->keys.val[i].salt->type);
		return KRB5KRB_ERR_GENERIC;
	    }
	    /* according to `the specs', we can't send a salt if
	       we have AFS3 salted key, but that requires that you
	       *know* what cell you are using (e.g by assuming
	       that the cell is the same as the realm in lower
	       case) */
#else
	    *pa.val[i].salttype = client->keys.val[i].salt->type;
#endif
	    krb5_copy_data(context, &client->keys.val[i].salt->salt,
			   &pa.val[i].salt);
	} else {
	    /* we return no salt type at all, as that should indicate
	     * the default salt type and make everybody happy.  some
	     * systems (like w2k) dislike being told the salt type
	     * here. */

	    pa.val[i].salttype = NULL;
	    pa.val[i].salt = NULL;
	}
    }
    len = length_ETYPE_INFO(&pa);
    buf = malloc(len);
    if (buf == NULL) {
	free_ETYPE_INFO(&pa);
	return ENOMEM;
d364 2
a365 1
    ret = encode_ETYPE_INFO(buf + len - 1, len, &pa, &len);
d367 1
a367 2
    if(ret) {
	free(buf);
a368 1
    }
d477 1
a477 1
    ret = krb5_sockaddr2address (from, &addr);
d499 2
a500 2
    krb5_principal client_princ, server_princ;
    char *client_name, *server_name;
a508 1
	server_name = "<unknown server>";
d515 4
a520 1
	client_name = "<unknown client>";
d527 4
a530 2
    kdc_log(0, "AS-REQ %s from %s for %s", 
	    client_name, from, server_name);
d532 1
a532 2
    if(ret)
	goto out;
d601 2
a602 1
	    
a616 1
	    free_EncryptedData(&enc_data);
d618 4
d628 1
d671 1
a671 1
    use_pa: 
d681 2
a682 1
	ret = get_pa_etype_info(&method_data, client); /* XXX check ret */
d684 1
a684 6
	len = length_METHOD_DATA(&method_data);
	buf = malloc(len);
	encode_METHOD_DATA(buf + len - 1,
			   len,
			   &method_data,
			   &len);
d686 1
a687 1
	foo_data.data   = buf;
d696 2
a697 1
		      0,
d722 1
a722 1
	    } else
d724 2
a725 1
	} else
d848 2
a849 7
    {
	krb5_data empty_string;
      
	krb5_data_zero(&empty_string); 
	et.transited.tr_type = DOMAIN_X500_COMPRESS;
	et.transited.contents = empty_string;
    }
d867 1
a867 1
	ek.last_req.val[ek.last_req.len].lr_type  = 6;
d872 1
a872 1
	ek.last_req.val[ek.last_req.len].lr_type  = 7;
d877 1
a877 1
	ek.last_req.val[ek.last_req.len].lr_type  = 0;
d913 1
a913 1
		       client->kvno, &ckey->key, reply);
d916 1
a917 1
out:
d925 2
a926 1
		      0,
d930 3
a932 2
out2:
    krb5_free_principal(context, client_princ);
d934 2
a935 1
    krb5_free_principal(context, server_princ);
d1044 3
a1046 1
	et->endtime = min(*et->renew_till, *et->starttime + old_life);
d1058 3
a1060 1
fix_transited_encoding(TransitedEncoding *tr, 
d1066 24
a1089 19
    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)){
	char **realms = NULL, **tmp;
	int num_realms = 0;
	int i;
	if(tr->tr_type && tr->contents.length != 0) {
	    if(tr->tr_type != DOMAIN_X500_COMPRESS){
		kdc_log(0, "Unknown transited type: %u", 
			tr->tr_type);
		return KRB5KDC_ERR_TRTYPE_NOSUPP;
	    }
	    ret = krb5_domain_x500_decode(tr->contents,
					  &realms, 
					  &num_realms,
					  client_realm,
					  server_realm);
	    if(ret){
		krb5_warn(context, ret, "Decoding transited encoding");
		return ret;
	    }
d1103 7
a1109 6
	free_TransitedEncoding(tr);
	tr->tr_type = DOMAIN_X500_COMPRESS;
	ret = krb5_domain_x500_encode(realms, num_realms, &tr->contents);
	if(ret)
	    krb5_warn(context, ret, "Encoding transited encoding");
    free_realms:
d1111 12
a1122 2
	    free(realms[i]);
	free(realms);
d1124 19
d1157 1
d1208 1
a1208 1
	return ret;
d1210 22
a1231 2
    copy_TransitedEncoding(&tgt->transited, &et.transited);
    ret = fix_transited_encoding(&et.transited,
d1235 2
a1236 5
    if(ret){
	free_TransitedEncoding(&et.transited);
	return ret;
    }

d1330 2
a1331 2
		       0, &tgt->key, reply);
out:
d1347 1
d1352 2
a1353 1
    unsigned char buf[8192];
d1357 1
a1357 1
    krb5_auth_getauthenticator(context, ac, &auth);
d1380 1
a1380 2
    ret = encode_KDC_REQ_BODY(buf + sizeof(buf) - 1, sizeof(buf),
			      b, &len);
d1386 7
d1395 1
d1403 1
a1403 1
			       buf + sizeof(buf) - len, 
d1406 1
d1418 4
d1423 1
a1423 1
is_krbtgt(PrincipalName *p)
d1425 2
a1426 1
    if(p->name_string.len == 2 && strcmp(p->name_string.val[0], "krbtgt") == 0)
d1433 1
a1433 1
find_rpath(Realm r)
d1437 3
a1439 3
						   "libdefaults", 
						   "capath", 
						   r, 
d1445 11
d1461 3
a1463 1
	 struct sockaddr *from_addr)
d1483 3
d1494 1
a1494 1
    if(!is_krbtgt(&ap_req.ticket.sname)){
d1510 1
d1523 1
d1565 23
d1592 1
a1592 1
    ret = tgs_check_authenticator(ac, b, &tgt->key);
d1685 1
a1685 1
	    if(!is_krbtgt(&t->sname)){
d1694 1
a1694 1
		if (ret == ENOENT)
d1727 21
a1747 5
	    if(loop++ < 2 && (req_rlm = is_krbtgt(&sp->name))){
		new_rlm = find_rpath(req_rlm);
		if(new_rlm) {
		    kdc_log(5, "krbtgt for realm %s not found, trying %s", 
			    req_rlm, new_rlm);
d1750 4
a1753 3
		    krb5_make_principal(context, &sp, r, 
					"krbtgt", new_rlm, NULL);
		    krb5_unparse_name(context, sp, &spn);	
d1756 1
d1760 1
a1760 1
	    if (ret == ENOENT)
d1774 1
a1774 1
	    if (ret == ENOENT)
d1780 12
d1821 1
d1834 1
a1834 1
    if(ret)
d1841 2
a1842 1
		      0,
d1844 5
d1863 1
d1877 2
d1894 2
a1895 1
    ret = tgs_rep2(&req->req_body, tgs_req, data, from, from_addr);
d1904 2
a1905 1
		      0,
d1908 2
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.133 2001/05/22 20:16:22 assar Exp $");
d418 1
a418 1
    ret = krb5_sockaddr2address (context, from, &addr);
d633 1
a633 2
		      NULL,
		      NULL,
d807 1
a807 1
	ek.last_req.val[ek.last_req.len].lr_type  = LR_PW_EXPTIME;
d812 1
a812 1
	ek.last_req.val[ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
d817 1
a817 1
	ek.last_req.val[ek.last_req.len].lr_type  = LR_NONE;
d865 1
a865 2
		      NULL,
		      NULL,
d981 1
a981 3
	et->endtime = *et->starttime + old_life;
	if (et->renew_till != NULL)
	    et->endtime = min(*et->renew_till, et->endtime);
d1009 1
a1009 2
	    ret = krb5_domain_x500_decode(context, 
					  tr->contents,
a1287 4
/*
 * return the realm of a krbtgt-ticket or NULL
 */

d1289 1
a1289 1
get_krbtgt_realm(const PrincipalName *p)
d1291 1
a1291 2
    if(p->name_string.len == 2
       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)
a1309 11
static krb5_boolean
need_referral(krb5_principal server, krb5_realm **realms)
{
    if(server->name.name_type != KRB5_NT_SRV_INST ||
       server->name.name_string.len != 2)
	return FALSE;
 
    return krb5_get_host_realm_int(context, server->name.name_string.val[1],
				   FALSE, realms) == 0;
}

d1315 1
a1315 3
	 const struct sockaddr *from_addr,
	 time_t **csec,
	 int **cusec)
a1334 3
    *csec  = NULL;
    *cusec = NULL;

d1343 1
a1343 1
    if(!get_krbtgt_realm(&ap_req.ticket.sname)){
a1411 23
    {
	krb5_authenticator auth;

	ret = krb5_auth_getauthenticator(context, ac, &auth);
	if (ret == 0) {
	    *csec   = malloc(sizeof(**csec));
	    if (*csec == NULL) {
		krb5_free_authenticator(context, &auth);
		kdc_log(0, "malloc failed");
		goto out2;
	    }
	    **csec  = auth->ctime;
	    *cusec  = malloc(sizeof(**cusec));
	    if (*cusec == NULL) {
		krb5_free_authenticator(context, &auth);
		kdc_log(0, "malloc failed");
		goto out2;
	    }
	    **csec  = auth->cusec;
	    krb5_free_authenticator(context, &auth);
	}
    }

d1509 1
a1509 1
	    if(!get_krbtgt_realm(&t->sname)){
d1551 5
a1555 21
	    krb5_realm *realms;

	    if ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {
		if(loop++ < 2) {
		    new_rlm = find_rpath(req_rlm);
		    if(new_rlm) {
			kdc_log(5, "krbtgt for realm %s not found, trying %s", 
				req_rlm, new_rlm);
			krb5_free_principal(context, sp);
			free(spn);
			krb5_make_principal(context, &sp, r, 
					    KRB5_TGS_NAME, new_rlm, NULL);
			krb5_unparse_name(context, sp, &spn);	
			goto server_lookup;
		    }
		}
	    } else if(need_referral(sp, &realms)) {
		if (strcmp(realms[0], sp->realm) != 0) {
		    kdc_log(5, "returning a referral to realm %s for "
			    "server %s that was not found",
			    realms[0], spn);
d1558 3
a1560 4
		    krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,
					realms[0], NULL);
		    krb5_unparse_name(context, sp, &spn);
		    krb5_free_host_realm(context, realms);
a1562 1
		krb5_free_host_realm(context, realms);
d1627 1
a1627 1
    if(ret) {
d1634 1
a1634 2
		      NULL,
		      NULL,
a1635 5
	free(*csec);
	free(*cusec);
	*csec  = NULL;
	*cusec = NULL;
    }
a1649 1

a1662 2
    time_t *csec = NULL;
    int *cusec = NULL;
d1678 1
a1678 2
    ret = tgs_rep2(&req->req_body, tgs_req, data, from, from_addr,
		   &csec, &cusec);
d1687 1
a1687 2
		      csec,
		      cusec,
a1689 2
    free(csec);
    free(cusec);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.134 2001/06/18 04:08:37 assar Exp $");
d1240 1
a1240 1
    krb5_auth_con_getauthenticator(context, ac, &auth);
d1441 1
a1441 1
	ret = krb5_auth_con_getauthenticator(context, ac, &auth);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.145 2003/04/15 11:07:39 lha Exp $");
d81 1
a81 1
find_etype(hdb_entry *princ, krb5_enctype *etypes, unsigned len, 
d112 1
a112 1
	  krb5_enctype *etypes,
a158 1
	     const char **e_text,
d161 1
a161 2
    unsigned char *buf;
    size_t buf_size;
d166 1
a166 1
    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);
d172 1
a172 6
    if(buf_size != len) {
	free(buf);
	kdc_log(0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	return KRB5KRB_ERR_GENERIC;
    }
a175 1
	free(buf);
d181 8
a188 8
    ret = krb5_encrypt_EncryptedData(context, 
				     crypto,
				     KRB5_KU_TICKET,
				     buf,
				     len,
				     skvno,
				     &rep->ticket.enc_part);
    free(buf);
a189 5
    if(ret) {
	kdc_log(0, "Failed to encrypt data: %s",
		krb5_get_err_text(context, ret));
	return ret;
    }
d192 2
a193 1
	ASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);
d195 2
a196 1
	ASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);
a201 6
    if(buf_size != len) {
	free(buf);
	kdc_log(0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	return KRB5KRB_ERR_GENERIC;
    }
a203 1
	free(buf);
d212 1
a212 1
				   buf,
d216 1
a216 2
	free(buf);
	ASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);
d221 1
a221 1
				   buf,
d225 1
a225 2
	free(buf);
	ASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);
d233 1
a233 8
    if(buf_size != len) {
	free(buf);
	kdc_log(0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	return KRB5KRB_ERR_GENERIC;
    }
    reply->data = buf;
    reply->length = buf_size;
d250 1
a250 40
make_etype_info_entry(ETYPE_INFO_ENTRY *ent, Key *key)
{
    ent->etype = key->key.keytype;
    if(key->salt){
	ALLOC(ent->salttype);
#if 0
	if(key->salt->type == hdb_pw_salt)
	    *ent->salttype = 0; /* or 1? or NULL? */
	else if(key->salt->type == hdb_afs3_salt)
	    *ent->salttype = 2;
	else {
	    kdc_log(0, "unknown salt-type: %d", 
		    key->salt->type);
	    return KRB5KRB_ERR_GENERIC;
	}
	/* according to `the specs', we can't send a salt if
	   we have AFS3 salted key, but that requires that you
	   *know* what cell you are using (e.g by assuming
	   that the cell is the same as the realm in lower
	   case) */
#else
	*ent->salttype = key->salt->type;
#endif
	krb5_copy_data(context, &key->salt->salt,
		       &ent->salt);
    } else {
	/* we return no salt type at all, as that should indicate
	 * the default salt type and make everybody happy.  some
	 * systems (like w2k) dislike being told the salt type
	 * here. */

	ent->salttype = NULL;
	ent->salt = NULL;
    }
    return 0;
}

static krb5_error_code
get_pa_etype_info(METHOD_DATA *md, hdb_entry *client, 
		  ENCTYPE *etypes, unsigned int etypes_len)
d253 1
a253 2
    int i, j;
    unsigned int n = 0;
a259 2
    if(pa.len > UINT_MAX/sizeof(*pa.val))
	return ERANGE;
a262 11

    for(j = 0; j < etypes_len; j++) {
	for(i = 0; i < client->keys.len; i++) {
	    if(client->keys.val[i].key.keytype == etypes[j])
		if((ret = make_etype_info_entry(&pa.val[n++], 
						&client->keys.val[i])) != 0) {
		    free_ETYPE_INFO(&pa);
		    return ret;
		}
	}
    }
d264 39
a302 19
	for(j = 0; j < etypes_len; j++) {
	    if(client->keys.val[i].key.keytype == etypes[j])
		goto skip;
	}
	if((ret = make_etype_info_entry(&pa.val[n++], 
					&client->keys.val[i])) != 0) {
	    free_ETYPE_INFO(&pa);
	    return ret;
	}
      skip:;
    }
    
    if(n != pa.len) {
	char *name;
	krb5_unparse_name(context, client->principal, &name);
	kdc_log(0, "internal error in get_pa_etype_info(%s): %d != %d", 
		name, n, pa.len);
	free(name);
	pa.len = n;
d304 1
a304 2

    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);
d306 2
a307 1
    if(ret)
d309 1
d539 1
a539 2

	  try_next_key:
d554 1
a555 4
		if(hdb_next_enctype2key(context, client, 
					enc_data.etype, &pa_key) == 0)
		    goto try_next_key;
		free_EncryptedData(&enc_data);
a561 1
	    free_EncryptedData(&enc_data);
d604 1
a604 1
      use_pa: 
d614 1
a614 2
	ret = get_pa_etype_info(&method_data, client, 
				b->etype.val, b->etype.len); /* XXX check ret */
d616 6
a621 1
	ASN1_MALLOC_ENCODE(METHOD_DATA, buf, len, &method_data, &len, ret);
d623 1
a624 1
	foo_data.length = len;
d659 1
a659 1
	    }
d661 1
a661 2
	}
	if (ret != 0)
d854 1
a854 1
		       client->kvno, &ckey->key, &e_text, reply);
a856 1
  out:
d858 1
d871 1
a871 1
  out2:
a1023 4
	if (num_realms < 0 || num_realms + 1 > UINT_MAX/sizeof(*realms)) {
	    ret = ERANGE;
	    goto free_realms;
	}
a1059 1
	       const char **e_text,
d1110 1
a1110 1
	goto out;
d1117 5
a1121 2
    if(ret)
	goto out;
d1215 1
a1215 1
		       0, &tgt->key, e_text, reply);
a1231 1
			const char **e_text,
d1236 1
a1236 2
    unsigned char *buf;
    size_t buf_size;
d1263 2
a1264 1
    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, b, &len, ret);
a1269 7
    if(buf_size != len) {
	free(buf);
	kdc_log(0, "Internal error in ASN.1 encoder");
	*e_text = "KDC internal error";
	ret = KRB5KRB_ERR_GENERIC;
	goto out;
    }
a1271 1
	free(buf);
d1279 1
a1279 1
			       buf, 
a1281 1
    free(buf);
a1384 1
	krb5_free_principal(context, princ);
a1396 1
	krb5_free_principal(context, princ);
d1465 1
a1465 1
    ret = tgs_check_authenticator(ac, b, &e_text, &tgt->key);
d1567 1
a1567 1
		if (ret == HDB_ERR_NOENTRY)
d1633 1
a1633 1
	    if (ret == HDB_ERR_NOENTRY)
d1647 1
a1647 1
	    if (ret == HDB_ERR_NOENTRY)
a1681 1
			     &e_text,
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.145.2.4 2004/08/13 19:28:26 lha Exp $");
a333 3
	for (i = 0; i < n; i++)
	    if (pa.val[i].etype == etypes[j])
		goto skip1;
a341 1
    skip1:;
d346 1
a346 1
		goto skip2;
d353 1
a353 1
      skip2:;
d499 2
a500 2
    krb5_principal client_princ = NULL, server_princ = NULL;
    char *client_name = NULL, *server_name = NULL;
d509 1
a515 4
    if (ret) {
	kdc_log(0, "AS-REQ malformed server name from %s", from);
	goto out;
    }
d518 1
d525 4
a528 2
    if (ret) {
	kdc_log(0, "AS-REQ malformed client name from %s", from);
a529 3
    }

    kdc_log(0, "AS-REQ %s from %s for %s", client_name, from, server_name);
d845 7
a851 2
    et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&et.transited.contents); 
d933 1
a933 2
    if (client_princ)
	krb5_free_principal(context, client_princ);
d935 1
a935 2
    if (server_princ)
	krb5_free_principal(context, server_princ);
d1058 1
a1058 3
fix_transited_encoding(krb5_boolean check_policy,
		       TransitedEncoding *tr, 
		       EncTicketPart *et, 
d1064 21
a1084 21
    char **realms, **tmp;
    int num_realms;
    int i;

    if(tr->tr_type != DOMAIN_X500_COMPRESS) {
	kdc_log(0, "Unknown transited type: %u", tr->tr_type);
	return KRB5KDC_ERR_TRTYPE_NOSUPP;
    }

    ret = krb5_domain_x500_decode(context, 
				  tr->contents,
				  &realms, 
				  &num_realms,
				  client_realm,
				  server_realm);
    if(ret){
	krb5_warn(context, ret, "Decoding transited encoding");
	return ret;
    }
    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {
	/* not us, so add the previous realm to transited set */
d1101 6
a1106 7
    }
    if(num_realms == 0) {
	if(strcmp(client_realm, server_realm)) 
	    kdc_log(0, "cross-realm %s -> %s", client_realm, server_realm);
    } else {
	size_t l = 0;
	char *rs;
d1108 2
a1109 12
	    l += strlen(realms[i]) + 2;
	rs = malloc(l);
	if(rs != NULL) {
	    *rs = '\0';
	    for(i = 0; i < num_realms; i++) {
		if(i > 0)
		    strlcat(rs, ", ", l);
		strlcat(rs, realms[i], l);
	    }
	    kdc_log(0, "cross-realm %s -> %s via [%s]", client_realm, server_realm, rs);
	    free(rs);
	}
a1110 19
    if(check_policy) {
	ret = krb5_check_transited(context, client_realm, 
				   server_realm, 
				   realms, num_realms, NULL);
	if(ret) {
	    krb5_warn(context, ret, "cross-realm %s -> %s", 
		      client_realm, server_realm);
	    goto free_realms;
	}
	et->flags.transited_policy_checked = 1;
    }
    et->transited.tr_type = DOMAIN_X500_COMPRESS;
    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);
    if(ret)
	krb5_warn(context, ret, "Encoding transited encoding");
  free_realms:
    for(i = 0; i < num_realms; i++)
	free(realms[i]);
    free(realms);
d1178 2
a1179 22
    /* We should check the transited encoding if:
       1) the request doesn't ask not to be checked
       2) globally enforcing a check
       3) principal requires checking
       4) we allow non-check per-principal, but principal isn't marked as allowing this
       5) we don't globally allow this
    */

#define GLOBAL_FORCE_TRANSITED_CHECK		(trpolicy == TRPOLICY_ALWAYS_CHECK)
#define GLOBAL_ALLOW_PER_PRINCIPAL		(trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)
#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK	(trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)
/* these will consult the database in future release */
#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)		0
#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)	0

    ret = fix_transited_encoding(!f.disable_transited_check ||
				 GLOBAL_FORCE_TRANSITED_CHECK ||
				 PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||
				 !((GLOBAL_ALLOW_PER_PRINCIPAL && 
				    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||
				   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),
				 &tgt->transited, &et,
d1279 1
a1279 1
  out:
d1381 1
a1381 1
find_rpath(Realm crealm, Realm srealm)
d1385 3
a1387 3
						   "capaths", 
						   crealm,
						   srealm,
d1679 1
a1679 1
		    new_rlm = find_rpath(tgt->crealm, req_rlm);
a1726 12

	if(strcmp(krb5_principal_get_realm(context, sp),
		  krb5_principal_get_comp_string(context, krbtgt->principal, 1)) != 0) {
	    char *tpn;
	    ret = krb5_unparse_name(context, krbtgt->principal, &tpn);
	    kdc_log(0, "Request with wrong krbtgt: %s", (ret == 0) ? tpn : "<unknown>");
	    if(ret == 0)
		free(tpn);
	    ret = KRB5KRB_AP_ERR_NOT_US;
	    goto out;
	    
	}
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos5.c,v 1.173.2.2 2005/06/15 11:33:33 lha Exp $");
a49 12
static int
realloc_method_data(METHOD_DATA *md)
{
    PA_DATA *pa;
    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));
    if(pa == NULL)
	return ENOMEM;
    md->val = pa;
    md->len++;
    return 0;
}

d51 1
a51 1
set_salt_padata (METHOD_DATA *md, Salt *salt)
d54 4
a57 2
	realloc_method_data(md);
	md->val[md->len - 1].padata_type = salt->type;
d59 1
a59 1
			  &md->val[md->len - 1].padata_value);
a89 3
	if (krb5_enctype_valid(context, etypes[i]) != 0)
	    continue;

a114 1
    char unparse_name[] = "krb5_unparse_name failed";
a115 1
    char *name;
d121 1
a121 5
	    if (krb5_unparse_name(context, client->principal, &name) != 0)
		name = unparse_name;
	    kdc_log(0, "Client (%s) has no support for etypes", name);
	    if (name != unparse_name)
		free(name);
d130 1
a130 5
	    if (krb5_unparse_name(context, server->principal, &name) != 0)
		name = unparse_name;
	    kdc_log(0, "Server (%s) has no support for etypes", name);
	    if (name != unparse_name)
		free(name);
d264 12
a331 1
    memset(pa.val, 0, pa.len * sizeof(*pa.val));
d338 1
a338 3
	    if(client->keys.val[i].key.keytype == etypes[j]) {
 		if (krb5_enctype_valid(context, etypes[j]) != 0)
 		    continue;
a343 1
	    }
a351 2
	if (krb5_enctype_valid(context, client->keys.val[i].key.keytype) != 0)
	    continue;
d357 1
a357 1
    skip2:;
d362 1
a362 3
	ret = krb5_unparse_name(context, client->principal, &name);
	if (ret)
	    name = "<unparse_name failed>";
d365 2
a366 3
	if (ret == 0)
	    free(name);
 	pa.len = n;
a384 158
 *
 */

extern int _krb5_AES_string_to_default_iterator;

static krb5_error_code
make_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)
{
    ent->etype = key->key.keytype;
    if(key->salt) {
	ALLOC(ent->salt);
	if (ent->salt == NULL)
	    return ENOMEM;
	*ent->salt = malloc(key->salt->salt.length + 1);
	if (*ent->salt == NULL) {
	    free(ent->salt);
	    ent->salt = NULL;
	    return ENOMEM;
	}
	memcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);
	(*ent->salt)[key->salt->salt.length] = '\0';
    } else
	ent->salt = NULL;

    ent->s2kparams = NULL;

    switch (key->key.keytype) {
    case KEYTYPE_AES128:
    case KEYTYPE_AES256:
	ALLOC(ent->s2kparams);
	if (ent->s2kparams == NULL)
	    return ENOMEM;
	ent->s2kparams->length = 4;
	ent->s2kparams->data = malloc(ent->s2kparams->length);
	if (ent->s2kparams->data == NULL) {
	    free(ent->s2kparams);
	    ent->s2kparams = NULL;
	    return ENOMEM;
	}
	_krb5_put_int(ent->s2kparams->data, 
		      _krb5_AES_string_to_default_iterator, 
		      ent->s2kparams->length);
	break;
    default:
	break;
    }
    return 0;
}

/*
 * Return 1 if the client have only older enctypes, this is for
 * determining if the server should send ETYPE_INFO2 or not.
 */

static int
only_older_enctype_p(const KDC_REQ *req)
{
    int i;

    for(i = 0; i < req->req_body.etype.len; i++) {
	switch (req->req_body.etype.val[i]) {
	case ETYPE_DES_CBC_CRC:
	case ETYPE_DES_CBC_MD4:
	case ETYPE_DES_CBC_MD5:
	case ETYPE_DES3_CBC_SHA1:
	case ETYPE_ARCFOUR_HMAC_MD5:
	case ETYPE_ARCFOUR_HMAC_MD5_56:
	    break;
	default:
	    return 0;
	}
    }
    return 1;
}

/*
 *
 */

static krb5_error_code
get_pa_etype_info2(METHOD_DATA *md, hdb_entry *client, 
		   ENCTYPE *etypes, unsigned int etypes_len)
{
    krb5_error_code ret = 0;
    int i, j;
    unsigned int n = 0;
    ETYPE_INFO2 pa;
    unsigned char *buf;
    size_t len;

    pa.len = client->keys.len;
    if(pa.len > UINT_MAX/sizeof(*pa.val))
	return ERANGE;
    pa.val = malloc(pa.len * sizeof(*pa.val));
    if(pa.val == NULL)
	return ENOMEM;
    memset(pa.val, 0, pa.len * sizeof(*pa.val));

    for(j = 0; j < etypes_len; j++) {
	for (i = 0; i < n; i++)
	    if (pa.val[i].etype == etypes[j])
		goto skip1;
	for(i = 0; i < client->keys.len; i++) {
	    if(client->keys.val[i].key.keytype == etypes[j]) {
		if (krb5_enctype_valid(context, etypes[j]) != 0)
		    continue;
		if((ret = make_etype_info2_entry(&pa.val[n++], 
						 &client->keys.val[i])) != 0) {
		    free_ETYPE_INFO2(&pa);
		    return ret;
		}
	    }
	}
    skip1:;
    }
    for(i = 0; i < client->keys.len; i++) {
	for(j = 0; j < etypes_len; j++) {
	    if(client->keys.val[i].key.keytype == etypes[j])
		goto skip2;
	}
	if (krb5_enctype_valid(context, client->keys.val[i].key.keytype) != 0)
	    continue;
	if((ret = make_etype_info2_entry(&pa.val[n++],
					 &client->keys.val[i])) != 0) {
	    free_ETYPE_INFO2(&pa);
	    return ret;
	}
      skip2:;
    }
    
    if(n != pa.len) {
	char *name;
	ret = krb5_unparse_name(context, client->principal, &name);
	if (ret)
	    name = "<unparse_name failed>";
	kdc_log(0, "internal error in get_pa_etype_info2(%s): %d != %d", 
		name, n, pa.len);
	if (ret == 0)
	    free(name);
 	pa.len = n;
    }

    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);
    free_ETYPE_INFO2(&pa);
    if(ret)
	return ret;
    ret = realloc_method_data(md);
    if(ret) {
	free(buf);
	return ret;
    }
    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;
    md->val[md->len - 1].padata_value.length = len;
    md->val[md->len - 1].padata_value.data = buf;
    return 0;
}

/*
a508 4
    EncryptionKey *reply_key;
#ifdef PKINIT
    pk_client_params *pkp = NULL;
#endif
d516 2
a517 3
	_krb5_principalname2krb5_principal (&server_princ,
					    *(b->sname), b->realm);
	ret = krb5_unparse_name(context, server_princ, &server_name);
d528 2
a529 3
	_krb5_principalname2krb5_principal (&client_princ,
					    *(b->cname), b->realm);
	ret = krb5_unparse_name(context, client_princ, &client_name);
d536 1
a536 2
    kdc_log(0, "AS-REQ %s from %s for %s", 
	    client_name, from, server_name);
d565 1
a565 58

#ifdef PKINIT
	kdc_log(5, "Looking for PKINIT pa-data -- %s", client_name);

	e_text = "No PKINIT PA found";

	i = 0;
	if ((pa = find_padata(req, &i, KRB5_PADATA_PK_AS_REQ)))
	    ;
	if (pa == NULL) {
	    i = 0;
	    if((pa = find_padata(req, &i, KRB5_PADATA_PK_AS_REQ_19)))
		;
	}
	if (pa == NULL) {
	    i = 0;
	    if((pa = find_padata(req, &i, KRB5_PADATA_PK_AS_REQ_WIN)))
		;
	}
	if (pa) {
	    char *client_cert = NULL;

	    ret = pk_rd_padata(context, req, pa, &pkp);
	    if (ret) {
		ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
		kdc_log(5, "Failed to decode PKINIT PA-DATA -- %s", 
			client_name);
		goto ts_enc;
	    }
	    if (ret == 0 && pkp == NULL)
		goto ts_enc;

	    ret = pk_check_client(context, 
				  client_princ, 
				  client,
				  pkp,
				  &client_cert);
	    if (ret) {
		e_text = "PKINIT certificate not allowed to "
		    "impersonate principal";
		pk_free_client_param(context, pkp);
		pkp = NULL;
		goto ts_enc;
	    }
	    found_pa = 1;
	    et.flags.pre_authent = 1;
	    kdc_log(2, "PKINIT pre-authentication succeeded -- %s using %s", 
		    client_name, client_cert);
	    free(client_cert);
	    if (pkp)
		goto preauth_done;
	}
    ts_enc:
#endif
	kdc_log(5, "Looking for ENC-TS pa-data -- %s", client_name);

	i = 0;
	e_text = "No ENC-TS found";
d569 1
d645 1
d654 1
a654 2
	    kdc_log(2, "ENC-TS Pre-authentication succeeded -- %s", 
		    client_name);
a656 3
#ifdef PKINIT
    preauth_done:
#endif
d685 2
a686 22
#ifdef PKINIT
	ret = realloc_method_data(&method_data);
	pa = &method_data.val[method_data.len-1];
	pa->padata_type		= KRB5_PADATA_PK_AS_REQ;
	pa->padata_value.length	= 0;
	pa->padata_value.data	= NULL;

	ret = realloc_method_data(&method_data);
	pa = &method_data.val[method_data.len-1];
	pa->padata_type		= KRB5_PADATA_PK_AS_REQ_19;
	pa->padata_value.length	= 0;
	pa->padata_value.data	= NULL;
#endif

	/* XXX check ret */
	if (only_older_enctype_p(req))
	    ret = get_pa_etype_info(&method_data, client, 
				    b->etype.val, b->etype.len); 
	/* XXX check ret */
	ret = get_pa_etype_info2(&method_data, client, 
				 b->etype.val, b->etype.len);

d696 1
a696 1
		      "Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ",
d704 1
a704 2
	kdc_log(0, "No preauth found, returning PREAUTH-REQUIRED -- %s",
		client_name);
d735 1
a735 2
	unparse_flags(KDCOptions2int(f), asn1_KDCOptions_units(), 
		      str, sizeof(str));
d915 1
a915 21
    ALLOC(rep.padata);
    rep.padata->len = 0;
    rep.padata->val = NULL;

    reply_key = &ckey->key;
#if PKINIT
    if (pkp) {
	ret = pk_mk_pa_reply(context, pkp, client, req,
			     &reply_key, rep.padata);
	if (ret)
	    goto out;
    }
#endif

    set_salt_padata (rep.padata, ckey->salt);

    if (rep.padata->len == 0) {
	free(rep.padata);
	rep.padata = NULL;
    }

d917 1
a917 1
		       client->kvno, reply_key, &e_text, reply);
a934 4
#ifdef PKINIT
    if (pkp)
	pk_free_client_param(context, pkp);
#endif
d1244 1
a1244 1
    _krb5_principal2principalname(&rep.ticket.sname, server->principal);
a1301 1
    et.flags.ok_as_delegate = server->flags.ok_as_delegate;
d1456 2
a1457 2
    return _krb5_get_host_realm_int(context, server->name.name_string.val[1],
				    FALSE, realms) == 0;
d1505 3
a1507 3
    _krb5_principalname2krb5_principal(&princ,
				       ap_req.ticket.sname,
				       ap_req.ticket.realm);
d1513 1
a1513 3
	ret = krb5_unparse_name(context, princ, &p);
	if (ret != 0)
	    p = "<unparse_name failed>";
d1517 1
a1517 2
	if (ret == 0)
	    free(p);
d1526 1
a1526 1
	ret = krb5_unparse_name (context, princ, &p);
a1527 2
	if (ret != 0)
	    p = "<unparse_name failed>";
d1532 1
a1532 2
	if (ret == 0)
	    free (p);
d1694 1
a1694 1
	    _krb5_principalname2krb5_principal(&p, t->sname, t->realm);
d1715 5
a1719 10
	_krb5_principalname2krb5_principal(&sp, *s, r);
	ret = krb5_unparse_name(context, sp, &spn);	
	if (ret)
	    goto out;
	_krb5_principalname2krb5_principal(&cp, tgt->cname, tgt->crealm);
	ret = krb5_unparse_name(context, cp, &cpn);
	if (ret)
	    goto out;
	unparse_flags (KDCOptions2int(b->kdc_options),
		       asn1_KDCOptions_units(),
d1743 1
a1743 3
			ret = krb5_unparse_name(context, sp, &spn);	
			if (ret)
			    goto out;
d1756 1
a1756 3
		    ret = krb5_unparse_name(context, sp, &spn);
		    if (ret)
			goto out;
d1855 1
a1855 1
    if (ticket)
d1857 2
@


1.1.1.4.2.1
log
@MFC:
Fix by biorn:

Fix cross-realm trust vulnerability. Adapted from FreeBSD patch.
@
text
@d499 2
a500 2
    krb5_principal client_princ = NULL, server_princ = NULL;
    char *client_name = NULL, *server_name = NULL;
d509 1
a515 4
    if (ret) {
	kdc_log(0, "AS-REQ malformed server name from %s", from);
	goto out;
    }
d518 1
d525 4
a528 2
    if (ret) {
	kdc_log(0, "AS-REQ malformed client name from %s", from);
a529 3
    }

    kdc_log(0, "AS-REQ %s from %s for %s", client_name, from, server_name);
d845 7
a851 2
    et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&et.transited.contents); 
d933 1
a933 2
    if (client_princ)
	krb5_free_principal(context, client_princ);
d935 1
a935 2
    if (server_princ)
	krb5_free_principal(context, server_princ);
d1058 1
a1058 3
fix_transited_encoding(krb5_boolean check_policy,
		       TransitedEncoding *tr, 
		       EncTicketPart *et, 
d1064 21
a1084 21
    char **realms, **tmp;
    int num_realms;
    int i;

    if(tr->tr_type != DOMAIN_X500_COMPRESS) {
	kdc_log(0, "Unknown transited type: %u", tr->tr_type);
	return KRB5KDC_ERR_TRTYPE_NOSUPP;
    }

    ret = krb5_domain_x500_decode(context, 
				  tr->contents,
				  &realms, 
				  &num_realms,
				  client_realm,
				  server_realm);
    if(ret){
	krb5_warn(context, ret, "Decoding transited encoding");
	return ret;
    }
    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {
	/* not us, so add the previous realm to transited set */
d1101 6
a1106 7
    }
    if(num_realms == 0) {
	if(strcmp(client_realm, server_realm)) 
	    kdc_log(0, "cross-realm %s -> %s", client_realm, server_realm);
    } else {
	size_t l = 0;
	char *rs;
d1108 2
a1109 12
	    l += strlen(realms[i]) + 2;
	rs = malloc(l);
	if(rs != NULL) {
	    *rs = '\0';
	    for(i = 0; i < num_realms; i++) {
		if(i > 0)
		    strlcat(rs, ", ", l);
		strlcat(rs, realms[i], l);
	    }
	    kdc_log(0, "cross-realm %s -> %s via [%s]", client_realm, server_realm, rs);
	    free(rs);
	}
a1110 19
    if(check_policy) {
	ret = krb5_check_transited(context, client_realm, 
				   server_realm, 
				   realms, num_realms, NULL);
	if(ret) {
	    krb5_warn(context, ret, "cross-realm %s -> %s", 
		      client_realm, server_realm);
	    goto free_realms;
	}
	et->flags.transited_policy_checked = 1;
    }
    et->transited.tr_type = DOMAIN_X500_COMPRESS;
    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);
    if(ret)
	krb5_warn(context, ret, "Encoding transited encoding");
  free_realms:
    for(i = 0; i < num_realms; i++)
	free(realms[i]);
    free(realms);
d1178 2
a1179 22
    /* We should check the transited encoding if:
       1) the request doesn't ask not to be checked
       2) globally enforcing a check
       3) principal requires checking
       4) we allow non-check per-principal, but principal isn't marked as allowing this
       5) we don't globally allow this
    */

#define GLOBAL_FORCE_TRANSITED_CHECK		(trpolicy == TRPOLICY_ALWAYS_CHECK)
#define GLOBAL_ALLOW_PER_PRINCIPAL		(trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)
#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK	(trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)
/* these will consult the database in future release */
#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)		0
#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)	0

    ret = fix_transited_encoding(!f.disable_transited_check ||
				 GLOBAL_FORCE_TRANSITED_CHECK ||
				 PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||
				 !((GLOBAL_ALLOW_PER_PRINCIPAL && 
				    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||
				   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),
				 &tgt->transited, &et,
d1279 1
a1279 1
  out:
d1381 1
a1381 1
find_rpath(Realm crealm, Realm srealm)
d1385 3
a1387 3
						   "capaths", 
						   crealm,
						   srealm,
d1679 1
a1679 1
		    new_rlm = find_rpath(tgt->crealm, req_rlm);
a1726 12

	if(strcmp(krb5_principal_get_realm(context, sp),
		  krb5_principal_get_comp_string(context, krbtgt->principal, 1)) != 0) {
	    char *tpn;
	    ret = krb5_unparse_name(context, krbtgt->principal, &tpn);
	    kdc_log(0, "Request with wrong krbtgt: %s", (ret == 0) ? tpn : "<unknown>");
	    if(ret == 0)
		free(tpn);
	    ret = KRB5KRB_AP_ERR_NOT_US;
	    goto out;
	    
	}
@


1.1.1.4.4.1
log
@MFC:
Fix by biorn:

Fix cross-realm trust vulnerability. Adapted from FreeBSD patch.
@
text
@d499 2
a500 2
    krb5_principal client_princ = NULL, server_princ = NULL;
    char *client_name = NULL, *server_name = NULL;
d509 1
a515 4
    if (ret) {
	kdc_log(0, "AS-REQ malformed server name from %s", from);
	goto out;
    }
d518 1
d525 4
a528 2
    if (ret) {
	kdc_log(0, "AS-REQ malformed client name from %s", from);
a529 3
    }

    kdc_log(0, "AS-REQ %s from %s for %s", client_name, from, server_name);
d845 7
a851 2
    et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&et.transited.contents); 
d933 1
a933 2
    if (client_princ)
	krb5_free_principal(context, client_princ);
d935 1
a935 2
    if (server_princ)
	krb5_free_principal(context, server_princ);
d1058 1
a1058 3
fix_transited_encoding(krb5_boolean check_policy,
		       TransitedEncoding *tr, 
		       EncTicketPart *et, 
d1064 21
a1084 21
    char **realms, **tmp;
    int num_realms;
    int i;

    if(tr->tr_type != DOMAIN_X500_COMPRESS) {
	kdc_log(0, "Unknown transited type: %u", tr->tr_type);
	return KRB5KDC_ERR_TRTYPE_NOSUPP;
    }

    ret = krb5_domain_x500_decode(context, 
				  tr->contents,
				  &realms, 
				  &num_realms,
				  client_realm,
				  server_realm);
    if(ret){
	krb5_warn(context, ret, "Decoding transited encoding");
	return ret;
    }
    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {
	/* not us, so add the previous realm to transited set */
d1101 6
a1106 7
    }
    if(num_realms == 0) {
	if(strcmp(client_realm, server_realm)) 
	    kdc_log(0, "cross-realm %s -> %s", client_realm, server_realm);
    } else {
	size_t l = 0;
	char *rs;
d1108 2
a1109 12
	    l += strlen(realms[i]) + 2;
	rs = malloc(l);
	if(rs != NULL) {
	    *rs = '\0';
	    for(i = 0; i < num_realms; i++) {
		if(i > 0)
		    strlcat(rs, ", ", l);
		strlcat(rs, realms[i], l);
	    }
	    kdc_log(0, "cross-realm %s -> %s via [%s]", client_realm, server_realm, rs);
	    free(rs);
	}
a1110 19
    if(check_policy) {
	ret = krb5_check_transited(context, client_realm, 
				   server_realm, 
				   realms, num_realms, NULL);
	if(ret) {
	    krb5_warn(context, ret, "cross-realm %s -> %s", 
		      client_realm, server_realm);
	    goto free_realms;
	}
	et->flags.transited_policy_checked = 1;
    }
    et->transited.tr_type = DOMAIN_X500_COMPRESS;
    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);
    if(ret)
	krb5_warn(context, ret, "Encoding transited encoding");
  free_realms:
    for(i = 0; i < num_realms; i++)
	free(realms[i]);
    free(realms);
d1178 2
a1179 22
    /* We should check the transited encoding if:
       1) the request doesn't ask not to be checked
       2) globally enforcing a check
       3) principal requires checking
       4) we allow non-check per-principal, but principal isn't marked as allowing this
       5) we don't globally allow this
    */

#define GLOBAL_FORCE_TRANSITED_CHECK		(trpolicy == TRPOLICY_ALWAYS_CHECK)
#define GLOBAL_ALLOW_PER_PRINCIPAL		(trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)
#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK	(trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)
/* these will consult the database in future release */
#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)		0
#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)	0

    ret = fix_transited_encoding(!f.disable_transited_check ||
				 GLOBAL_FORCE_TRANSITED_CHECK ||
				 PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||
				 !((GLOBAL_ALLOW_PER_PRINCIPAL && 
				    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||
				   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),
				 &tgt->transited, &et,
d1279 1
a1279 1
  out:
d1381 1
a1381 1
find_rpath(Realm crealm, Realm srealm)
d1385 3
a1387 3
						   "capaths", 
						   crealm,
						   srealm,
d1679 1
a1679 1
		    new_rlm = find_rpath(tgt->crealm, req_rlm);
a1726 12

	if(strcmp(krb5_principal_get_realm(context, sp),
		  krb5_principal_get_comp_string(context, krbtgt->principal, 1)) != 0) {
	    char *tpn;
	    ret = krb5_unparse_name(context, krbtgt->principal, &tpn);
	    kdc_log(0, "Request with wrong krbtgt: %s", (ret == 0) ? tpn : "<unknown>");
	    if(ret == 0)
		free(tpn);
	    ret = KRB5KRB_AP_ERR_NOT_US;
	    goto out;
	    
	}
@


