head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.8;

1.8
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.16.21.23.21;	author weingart;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.14.08.15.03;	author biorn;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.11.03.39.59;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.19.01.05.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.05.16.16.49;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.31;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.31;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.21.48;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.54.51;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.31;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.32.43;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.9
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define KRB5_DEPRECATED /* uses v4 functions that will die */

#include "hprop.h"

static int version_flag;
static int help_flag;
static const char *ktname = HPROP_KEYTAB;
static const char *database;
static char *mkeyfile;
static int to_stdout;
static int verbose_flag;
static int encrypt_flag;
static int decrypt_flag;
static hdb_master_key mkey5;

static char *source_type;

static char *local_realm=NULL;

static int
open_socket(krb5_context context, const char *hostname, const char *port)
{
    struct addrinfo *ai, *a;
    struct addrinfo hints;
    int error;

    memset (&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    error = getaddrinfo (hostname, port, &hints, &ai);
    if (error) {
	warnx ("%s: %s", hostname, gai_strerror(error));
	return -1;
    }

    for (a = ai; a != NULL; a = a->ai_next) {
	int s;

	s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
	if (s < 0)
	    continue;
	if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
	    warn ("connect(%s)", hostname);
	    close (s);
	    continue;
	}
	freeaddrinfo (ai);
	return s;
    }
    warnx ("failed to contact %s", hostname);
    freeaddrinfo (ai);
    return -1;
}

krb5_error_code
v5_prop(krb5_context context, HDB *db, hdb_entry_ex *entry, void *appdata)
{
    krb5_error_code ret;
    struct prop_data *pd = appdata;
    krb5_data data;

    if(encrypt_flag) {
	ret = hdb_seal_keys_mkey(context, &entry->entry, mkey5);
	if (ret) {
	    krb5_warn(context, ret, "hdb_seal_keys_mkey");
	    return ret;
	}
    }
    if(decrypt_flag) {
	ret = hdb_unseal_keys_mkey(context, &entry->entry, mkey5);
	if (ret) {
	    krb5_warn(context, ret, "hdb_unseal_keys_mkey");
	    return ret;
	}
    }

    ret = hdb_entry2value(context, &entry->entry, &data);
    if(ret) {
	krb5_warn(context, ret, "hdb_entry2value");
	return ret;
    }

    if(to_stdout)
	ret = krb5_write_message(context, &pd->sock, &data);
    else
	ret = krb5_write_priv_message(context, pd->auth_context,
				      &pd->sock, &data);
    krb5_data_free(&data);
    return ret;
}

struct getargs args[] = {
    { "master-key", 'm', arg_string, &mkeyfile, "v5 master key file", "file" },
    { "database", 'd',	arg_string, rk_UNCONST(&database), "database", "file" },
    { "source",   0,	arg_string, &source_type, "type of database to read",
      "heimdal"
      "|mit-dump"
    },

    { "keytab",   'k',	arg_string, rk_UNCONST(&ktname),
      "keytab to use for authentication", "keytab" },
    { "v5-realm", 'R',  arg_string, &local_realm, "v5 realm to use", NULL },
    { "decrypt",  'D',  arg_flag,   &decrypt_flag,   "decrypt keys", NULL },
    { "encrypt",  'E',  arg_flag,   &encrypt_flag,   "encrypt keys", NULL },
    { "stdout",	  'n',  arg_flag,   &to_stdout, "dump to stdout", NULL },
    { "verbose",  'v',	arg_flag, &verbose_flag, NULL, NULL },
    { "version",   0,	arg_flag, &version_flag, NULL, NULL },
    { "help",     'h',	arg_flag, &help_flag, NULL, NULL }
};

static int num_args = sizeof(args) / sizeof(args[0]);

static void
usage(int ret)
{
    arg_printusage (args, num_args, NULL, "[host[:port]] ...");
    exit (ret);
}

static void
get_creds(krb5_context context, krb5_ccache *cache)
{
    krb5_keytab keytab;
    krb5_principal client;
    krb5_error_code ret;
    krb5_get_init_creds_opt *init_opts;
    krb5_preauthtype preauth = KRB5_PADATA_ENC_TIMESTAMP;
    krb5_creds creds;

    ret = krb5_kt_register(context, &hdb_kt_ops);
    if(ret) krb5_err(context, 1, ret, "krb5_kt_register");

    ret = krb5_kt_resolve(context, ktname, &keytab);
    if(ret) krb5_err(context, 1, ret, "krb5_kt_resolve");

    ret = krb5_make_principal(context, &client, NULL,
			      "kadmin", HPROP_NAME, NULL);
    if(ret) krb5_err(context, 1, ret, "krb5_make_principal");

    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);
    if(ret) krb5_err(context, 1, ret, "krb5_get_init_creds_opt_alloc");
    krb5_get_init_creds_opt_set_preauth_list(init_opts, &preauth, 1);

    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, init_opts);
    if(ret) krb5_err(context, 1, ret, "krb5_get_init_creds");

    krb5_get_init_creds_opt_free(context, init_opts);

    ret = krb5_kt_close(context, keytab);
    if(ret) krb5_err(context, 1, ret, "krb5_kt_close");

    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_new_unique");

    ret = krb5_cc_initialize(context, *cache, client);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_initialize");

    krb5_free_principal(context, client);

    ret = krb5_cc_store_cred(context, *cache, &creds);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_store_cred");

    krb5_free_cred_contents(context, &creds);
}

enum hprop_source {
    HPROP_HEIMDAL = 1,
    HPROP_MIT_DUMP
};

struct {
    int type;
    const char *name;
} types[] = {
    { HPROP_HEIMDAL,	"heimdal" },
    { HPROP_MIT_DUMP,	"mit-dump" }
};

static int
parse_source_type(const char *s)
{
    size_t i;
    for(i = 0; i < sizeof(types) / sizeof(types[0]); i++) {
	if(strstr(types[i].name, s) == types[i].name)
	    return types[i].type;
    }
    return 0;
}

static int
iterate (krb5_context context,
	 const char *database_name,
	 HDB *db,
	 int type,
	 struct prop_data *pd)
{
    int ret;

    switch(type) {
    case HPROP_MIT_DUMP:
	ret = mit_prop_dump(pd, database_name);
	if (ret)
	    krb5_warn(context, ret, "mit_prop_dump");
	break;
    case HPROP_HEIMDAL:
	ret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);
	if(ret)
	    krb5_warn(context, ret, "hdb_foreach");
	break;
    default:
	krb5_errx(context, 1, "unknown prop type: %d", type);
    }
    return ret;
}

static int
dump_database (krb5_context context, int type,
	       const char *database_name, HDB *db)
{
    krb5_error_code ret;
    struct prop_data pd;
    krb5_data data;

    pd.context      = context;
    pd.auth_context = NULL;
    pd.sock         = STDOUT_FILENO;

    ret = iterate (context, database_name, db, type, &pd);
    if (ret)
	krb5_errx(context, 1, "iterate failure");
    krb5_data_zero (&data);
    ret = krb5_write_message (context, &pd.sock, &data);
    if (ret)
	krb5_err(context, 1, ret, "krb5_write_message");

    return 0;
}

static int
propagate_database (krb5_context context, int type,
		    const char *database_name,
		    HDB *db, krb5_ccache ccache,
		    int optidx, int argc, char **argv)
{
    krb5_principal server;
    krb5_error_code ret;
    int i, failed = 0;

    for(i = optidx; i < argc; i++){
	krb5_auth_context auth_context;
	int fd;
	struct prop_data pd;
	krb5_data data;

	char *port, portstr[NI_MAXSERV];
	char *host = argv[i];

	port = strchr(host, ':');
	if(port == NULL) {
	    snprintf(portstr, sizeof(portstr), "%u",
		     ntohs(krb5_getportbyname (context, "hprop", "tcp",
					       HPROP_PORT)));
	    port = portstr;
	} else
	    *port++ = '\0';

	fd = open_socket(context, host, port);
	if(fd < 0) {
	    failed++;
	    krb5_warn (context, errno, "connect %s", host);
	    continue;
	}

	ret = krb5_sname_to_principal(context, argv[i],
				      HPROP_NAME, KRB5_NT_SRV_HST, &server);
	if(ret) {
	    failed++;
	    krb5_warn(context, ret, "krb5_sname_to_principal(%s)", host);
	    close(fd);
	    continue;
	}

        if (local_realm) {
            krb5_realm my_realm;
            krb5_get_default_realm(context,&my_realm);
            krb5_principal_set_realm(context,server,my_realm);
	    krb5_xfree(my_realm);
        }

	auth_context = NULL;
	ret = krb5_sendauth(context,
			    &auth_context,
			    &fd,
			    HPROP_VERSION,
			    NULL,
			    server,
			    AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,
			    NULL, /* in_data */
			    NULL, /* in_creds */
			    ccache,
			    NULL,
			    NULL,
			    NULL);

	krb5_free_principal(context, server);

	if(ret) {
	    failed++;
	    krb5_warn(context, ret, "krb5_sendauth (%s)", host);
	    close(fd);
	    goto next_host;
	}

	pd.context      = context;
	pd.auth_context = auth_context;
	pd.sock         = fd;

	ret = iterate (context, database_name, db, type, &pd);
	if (ret) {
	    krb5_warnx(context, "iterate to host %s failed", host);
	    failed++;
	    goto next_host;
	}

	krb5_data_zero (&data);
	ret = krb5_write_priv_message(context, auth_context, &fd, &data);
	if(ret) {
	    krb5_warn(context, ret, "krb5_write_priv_message");
	    failed++;
	    goto next_host;
	}

	ret = krb5_read_priv_message(context, auth_context, &fd, &data);
	if(ret) {
	    krb5_warn(context, ret, "krb5_read_priv_message: %s", host);
	    failed++;
	    goto next_host;
	} else
	    krb5_data_free (&data);

    next_host:
	krb5_auth_con_free(context, auth_context);
	close(fd);
    }
    if (failed)
	return 1;
    return 0;
}

int
main(int argc, char **argv)
{
    krb5_error_code ret;
    krb5_context context;
    krb5_ccache ccache = NULL;
    HDB *db = NULL;
    int optidx = 0;

    int type, exit_code;

    setprogname(argv[0]);

    if(getarg(args, num_args, argc, argv, &optidx))
	usage(1);

    if(help_flag)
	usage(0);

    if(version_flag){
	print_version(NULL);
	exit(0);
    }

    ret = krb5_init_context(&context);
    if(ret)
	exit(1);

    /* We may be reading an old database encrypted with a DES master key. */
    ret = krb5_allow_weak_crypto(context, 1);
    if(ret)
        krb5_err(context, 1, ret, "krb5_allow_weak_crypto");

    if(local_realm)
	krb5_set_default_realm(context, local_realm);

    if(encrypt_flag && decrypt_flag)
	krb5_errx(context, 1,
		  "only one of `--encrypt' and `--decrypt' is meaningful");

    if(source_type != NULL) {
	type = parse_source_type(source_type);
	if(type == 0)
	    krb5_errx(context, 1, "unknown source type `%s'", source_type);
    } else
	type = HPROP_HEIMDAL;

    if(!to_stdout)
	get_creds(context, &ccache);

    if(decrypt_flag || encrypt_flag) {
	ret = hdb_read_master_key(context, mkeyfile, &mkey5);
	if(ret && ret != ENOENT)
	    krb5_err(context, 1, ret, "hdb_read_master_key");
	if(ret)
	    krb5_errx(context, 1, "No master key file found");
    }

    switch(type) {
    case HPROP_MIT_DUMP:
	if (database == NULL)
	    krb5_errx(context, 1, "no dump file specified");
	break;
    case HPROP_HEIMDAL:
	ret = hdb_create (context, &db, database);
	if(ret)
	    krb5_err(context, 1, ret, "hdb_create: %s", database);
	ret = db->hdb_open(context, db, O_RDONLY, 0);
	if(ret)
	    krb5_err(context, 1, ret, "db->hdb_open");
	break;
    default:
	krb5_errx(context, 1, "unknown dump type `%d'", type);
	break;
    }

    if (to_stdout)
	exit_code = dump_database (context, type, database, db);
    else
	exit_code = propagate_database (context, type, database,
					db, ccache, optidx, argc, argv);

    if(ccache != NULL)
	krb5_cc_destroy(context, ccache);

    if(db != NULL)
	(*db->hdb_destroy)(context, db);

    krb5_free_context(context);
    return exit_code;
}
@


1.8
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.7
log
@Fix ovious uninitialized variable.

Ok deraadt@@
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d34 2
a37 9
#ifdef KRB4
#include <krb.h>
#include <prot.h>
#define Principal Principal4
#include <krb_db.h>
#endif

RCSID("$KTH: hprop.c,v 1.76 2005/04/24 13:48:37 lha Exp $");

a50 6
static char *afs_cell;
static char *v4_realm;

static int kaspecials_flag;
static int ka_use_null_salt;

d69 1
a69 1
    
d90 1
a90 1
v5_prop(krb5_context context, HDB *db, hdb_entry *entry, void *appdata)
d97 1
a97 1
	ret = hdb_seal_keys_mkey(context, entry, mkey5);
d104 1
a104 1
	ret = hdb_unseal_keys_mkey(context, entry, mkey5);
d109 1
a109 1
    }	
d111 1
a111 1
    ret = hdb_entry2value(context, entry, &data);
d120 1
a120 1
	ret = krb5_write_priv_message(context, pd->auth_context, 
a125 333
#ifdef KRB4

static char realm_buf[REALM_SZ];

static int
kdb_prop(void *arg, Principal *p)
{
    int ret;
    struct v4_principal pr;

    memset(&pr, 0, sizeof(pr));

    if(p->attributes != 0) {
	warnx("%s.%s has non-zero attributes - skipping", 
	      p->name, p->instance);
	    return 0;
    }
    strlcpy(pr.name, p->name, sizeof(pr.name));
    strlcpy(pr.instance, p->instance, sizeof(pr.instance));

    copy_to_key(&p->key_low, &p->key_high, pr.key);
    pr.exp_date = p->exp_date;
    pr.mod_date = p->mod_date;
    strlcpy(pr.mod_name, p->mod_name, sizeof(pr.mod_name));
    strlcpy(pr.mod_instance, p->mod_instance, sizeof(pr.mod_instance));
    pr.max_life = p->max_life;
    pr.mkvno = p->kdc_key_ver;
    pr.kvno = p->key_version;
    
    ret = v4_prop(arg, &pr);
    memset(&pr, 0, sizeof(pr));
    return ret;
}

#endif /* KRB4 */

#ifndef KRB4
static time_t
krb_life_to_time(time_t start, int life)
{
    static int lifetimes[] = {
	  38400,   41055,   43894,   46929,   50174,   53643,   57352,   61318,
	  65558,   70091,   74937,   80119,   85658,   91581,   97914,  104684,
	 111922,  119661,  127935,  136781,  146239,  156350,  167161,  178720,
	 191077,  204289,  218415,  233517,  249664,  266926,  285383,  305116,
	 326213,  348769,  372885,  398668,  426234,  455705,  487215,  520904,
	 556921,  595430,  636601,  680618,  727680,  777995,  831789,  889303,
	 950794, 1016537, 1086825, 1161973, 1242318, 1328218, 1420057, 1518247,
	1623226, 1735464, 1855462, 1983758, 2120925, 2267576, 2424367, 2592000
    };

#if 0
    int i;
    double q = exp((log(2592000.0) - log(38400.0)) / 63);
    double x = 38400;
    for(i = 0; i < 64; i++) {
	lifetimes[i] = (int)x;
	x *= q;
    }
#endif

    if(life == 0xff)
	return NEVERDATE;
    if(life < 0x80)
	return start + life * 5 * 60;
    if(life > 0xbf)
	life = 0xbf;
    return start + lifetimes[life - 0x80];
}
#endif /* !KRB4 */

int
v4_prop(void *arg, struct v4_principal *p)
{
    struct prop_data *pd = arg;
    hdb_entry ent;
    krb5_error_code ret;

    memset(&ent, 0, sizeof(ent));

    ret = krb5_425_conv_principal(pd->context, p->name, p->instance, v4_realm,
				  &ent.principal);
    if(ret) {
	krb5_warn(pd->context, ret,
		  "krb5_425_conv_principal %s.%s@@%s",
		  p->name, p->instance, v4_realm);
	return 0;
    }

    if(verbose_flag) {
	char *s;
	krb5_unparse_name_short(pd->context, ent.principal, &s);
	krb5_warnx(pd->context, "%s.%s -> %s", p->name, p->instance, s);
	free(s);
    }

    ent.kvno = p->kvno;
    ent.keys.len = 3;
    ent.keys.val = malloc(ent.keys.len * sizeof(*ent.keys.val));
    if(p->mkvno != -1) {
	ent.keys.val[0].mkvno = malloc (sizeof(*ent.keys.val[0].mkvno));
	*(ent.keys.val[0].mkvno) = p->mkvno;
    } else
	ent.keys.val[0].mkvno = NULL;
    ent.keys.val[0].salt = calloc(1, sizeof(*ent.keys.val[0].salt));
    ent.keys.val[0].salt->type = KRB5_PADATA_PW_SALT;
    ent.keys.val[0].key.keytype = ETYPE_DES_CBC_MD5;
    krb5_data_alloc(&ent.keys.val[0].key.keyvalue, DES_KEY_SZ);
    memcpy(ent.keys.val[0].key.keyvalue.data, p->key, 8);

    copy_Key(&ent.keys.val[0], &ent.keys.val[1]);
    ent.keys.val[1].key.keytype = ETYPE_DES_CBC_MD4;
    copy_Key(&ent.keys.val[0], &ent.keys.val[2]);
    ent.keys.val[2].key.keytype = ETYPE_DES_CBC_CRC;

    {
	int life = krb_life_to_time(0, p->max_life);
	if(life == NEVERDATE){
	    ent.max_life = NULL;
	} else {
	    /* clean up lifetime a bit */
	    if(life > 86400)
		life = (life + 86399) / 86400 * 86400;
	    else if(life > 3600)
		life = (life + 3599) / 3600 * 3600;
	    ALLOC(ent.max_life);
	    *ent.max_life = life;
	}
    }

    ALLOC(ent.valid_end);
    *ent.valid_end = p->exp_date;

    ret = krb5_make_principal(pd->context, &ent.created_by.principal,
			      v4_realm,
			      "kadmin",
			      "hprop",
			      NULL);
    if(ret){
	krb5_warn(pd->context, ret, "krb5_make_principal");
	ret = 0;
	goto out;
    }
    ent.created_by.time = time(NULL);
    ALLOC(ent.modified_by);
    ret = krb5_425_conv_principal(pd->context, p->mod_name, p->mod_instance, 
				  v4_realm, &ent.modified_by->principal);
    if(ret){
	krb5_warn(pd->context, ret, "%s.%s@@%s", p->name, p->instance, v4_realm);
	ent.modified_by->principal = NULL;
	ret = 0;
	goto out;
    }
    ent.modified_by->time = p->mod_date;

    ent.flags.forwardable = 1;
    ent.flags.renewable = 1;
    ent.flags.proxiable = 1;
    ent.flags.postdate = 1;
    ent.flags.client = 1;
    ent.flags.server = 1;
    
    /* special case password changing service */
    if(strcmp(p->name, "changepw") == 0 && 
       strcmp(p->instance, "kerberos") == 0) {
	ent.flags.forwardable = 0;
	ent.flags.renewable = 0;
	ent.flags.proxiable = 0;
	ent.flags.postdate = 0;
	ent.flags.initial = 1;
	ent.flags.change_pw = 1;
    }

    ret = v5_prop(pd->context, NULL, &ent, pd);

    if (strcmp (p->name, "krbtgt") == 0
	&& strcmp (v4_realm, p->instance) != 0) {
	krb5_free_principal (pd->context, ent.principal);
	ret = krb5_425_conv_principal (pd->context, p->name,
				       v4_realm, p->instance,
				       &ent.principal);
	if (ret == 0)
	    ret = v5_prop (pd->context, NULL, &ent, pd);
    }

  out:
    hdb_free_entry(pd->context, &ent);
    return ret;
}

#include "kadb.h"

/* read a `ka_entry' from `fd' at offset `pos' */
static void
read_block(krb5_context context, int fd, int32_t pos, void *buf, size_t len)
{
    krb5_error_code ret;
#ifdef HAVE_PREAD
    if((ret = pread(fd, buf, len, 64 + pos)) < 0)
	krb5_err(context, 1, errno, "pread(%u)", 64 + pos);
#else
    if(lseek(fd, 64 + pos, SEEK_SET) == (off_t)-1)
	krb5_err(context, 1, errno, "lseek(%u)", 64 + pos);
    ret = read(fd, buf, len);
    if(ret < 0)
	krb5_err(context, 1, errno, "read(%lu)", (unsigned long)len);
#endif
    if(ret != len)
	krb5_errx(context, 1, "read(%lu) = %u", (unsigned long)len, ret);
}

static int
ka_convert(struct prop_data *pd, int fd, struct ka_entry *ent)
{
    int32_t flags = ntohl(ent->flags);
    krb5_error_code ret;
    hdb_entry hdb;

    if(!kaspecials_flag
       && (flags & KAFNORMAL) == 0) /* remove special entries */
	return 0;
    memset(&hdb, 0, sizeof(hdb));
    ret = krb5_425_conv_principal(pd->context, ent->name, ent->instance, 
				  v4_realm, &hdb.principal);
    if(ret) {
	krb5_warn(pd->context, ret,
		  "krb5_425_conv_principal (%s.%s@@%s)",
		  ent->name, ent->instance, v4_realm);
	return 0;
    }
    hdb.kvno = ntohl(ent->kvno);
    hdb.keys.len = 3;
    hdb.keys.val = malloc(hdb.keys.len * sizeof(*hdb.keys.val));
    hdb.keys.val[0].mkvno = NULL;
    hdb.keys.val[0].salt = calloc(1, sizeof(*hdb.keys.val[0].salt));
    if (ka_use_null_salt) {
	hdb.keys.val[0].salt->type = hdb_pw_salt;
	hdb.keys.val[0].salt->salt.data = NULL;
	hdb.keys.val[0].salt->salt.length = 0;
    } else {
	hdb.keys.val[0].salt->type = hdb_afs3_salt;
	hdb.keys.val[0].salt->salt.data = strdup(afs_cell);
	hdb.keys.val[0].salt->salt.length = strlen(afs_cell);
    }
    
    hdb.keys.val[0].key.keytype = ETYPE_DES_CBC_MD5;
    krb5_data_copy(&hdb.keys.val[0].key.keyvalue, ent->key, sizeof(ent->key));
    copy_Key(&hdb.keys.val[0], &hdb.keys.val[1]);
    hdb.keys.val[1].key.keytype = ETYPE_DES_CBC_MD4;
    copy_Key(&hdb.keys.val[0], &hdb.keys.val[2]);
    hdb.keys.val[2].key.keytype = ETYPE_DES_CBC_CRC;

    ALLOC(hdb.max_life);
    *hdb.max_life = ntohl(ent->max_life);

    if(ntohl(ent->valid_end) != NEVERDATE && ntohl(ent->valid_end) != 0xffffffff) {
	ALLOC(hdb.valid_end);
	*hdb.valid_end = ntohl(ent->valid_end);
    }
    
    if (ntohl(ent->pw_change) != NEVERDATE && 
	ent->pw_expire != 255 &&
	ent->pw_expire != 0) {
	ALLOC(hdb.pw_end);
	*hdb.pw_end = ntohl(ent->pw_change)
	    + 24 * 60 * 60 * ent->pw_expire;
    }

    ret = krb5_make_principal(pd->context, &hdb.created_by.principal,
			      v4_realm,
			      "kadmin",
			      "hprop",
			      NULL);
    hdb.created_by.time = time(NULL);

    if(ent->mod_ptr){
	struct ka_entry mod;
	ALLOC(hdb.modified_by);
	read_block(pd->context, fd, ntohl(ent->mod_ptr), &mod, sizeof(mod));
	
	krb5_425_conv_principal(pd->context, mod.name, mod.instance, v4_realm, 
				&hdb.modified_by->principal);
	hdb.modified_by->time = ntohl(ent->mod_time);
	memset(&mod, 0, sizeof(mod));
    }

    hdb.flags.forwardable = 1;
    hdb.flags.renewable = 1;
    hdb.flags.proxiable = 1;
    hdb.flags.postdate = 1;
    /* XXX - AFS 3.4a creates krbtgt.REALMOFCELL as NOTGS+NOSEAL */
    if (strcmp(ent->name, "krbtgt") == 0 &&
	(flags & (KAFNOTGS|KAFNOSEAL)) == (KAFNOTGS|KAFNOSEAL))
	flags &= ~(KAFNOTGS|KAFNOSEAL);

    hdb.flags.client = (flags & KAFNOTGS) == 0;
    hdb.flags.server = (flags & KAFNOSEAL) == 0;

    ret = v5_prop(pd->context, NULL, &hdb, pd);
    hdb_free_entry(pd->context, &hdb);
    return ret;
}

static int
ka_dump(struct prop_data *pd, const char *file)
{
    struct ka_header header;
    int i;
    int fd = open(file, O_RDONLY);

    if(fd < 0)
	krb5_err(pd->context, 1, errno, "open(%s)", file);
    read_block(pd->context, fd, 0, &header, sizeof(header));
    if(header.version1 != header.version2)
	krb5_errx(pd->context, 1, "Version mismatch in header: %ld/%ld",
		  (long)ntohl(header.version1), (long)ntohl(header.version2));
    if(ntohl(header.version1) != 5)
	krb5_errx(pd->context, 1, "Unknown database version %ld (expected 5)", 
		  (long)ntohl(header.version1));
    for(i = 0; i < ntohl(header.hashsize); i++){
	int32_t pos = ntohl(header.hash[i]);
	while(pos){
	    struct ka_entry ent;
	    read_block(pd->context, fd, pos, &ent, sizeof(ent));
	    ka_convert(pd, fd, &ent);
	    pos = ntohl(ent.next);
	}
    }
    return 0;
}



d128 2
a129 2
    { "database", 'd',	arg_string, &database, "database", "file" },
    { "source",   0,	arg_string, &source_type, "type of database to read", 
a131 5
      "|krb4-dump"
#ifdef KRB4
      "|krb4-db"
#endif
      "|kaserver"
d133 10
a142 12
      
    { "v4-realm", 'r',  arg_string, &v4_realm, "v4 realm to use" },
    { "cell",	  'c',  arg_string, &afs_cell, "name of AFS cell" },
    { "kaspecials", 'S', arg_flag,   &kaspecials_flag, "dump KASPECIAL keys"},
    { "keytab",   'k',	arg_string, &ktname, "keytab to use for authentication", "keytab" },
    { "v5-realm", 'R',  arg_string, &local_realm, "v5 realm to use" },
    { "decrypt",  'D',  arg_flag,   &decrypt_flag,   "decrypt keys" },
    { "encrypt",  'E',  arg_flag,   &encrypt_flag,   "encrypt keys" },
    { "stdout",	  'n',  arg_flag,   &to_stdout, "dump to stdout" },
    { "verbose",  'v',	arg_flag, &verbose_flag },
    { "version",   0,	arg_flag, &version_flag },
    { "help",     'h',	arg_flag, &help_flag }
d163 1
a163 1
    
d169 2
a170 2
    
    ret = krb5_make_principal(context, &client, NULL, 
d181 2
a182 2
    krb5_get_init_creds_opt_free(init_opts);
    
d185 3
a187 3
    
    ret = krb5_cc_gen_new(context, &krb5_mcc_ops, cache);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_gen_new");
a201 3
    HPROP_KRB4_DB,
    HPROP_KRB4_DUMP,
    HPROP_KASERVER,
a204 2
#define IS_TYPE_V4(X) ((X) == HPROP_KRB4_DB || (X) == HPROP_KRB4_DUMP || (X) == HPROP_KASERVER)

a209 5
    { HPROP_KRB4_DUMP,	"krb4-dump" },
#ifdef KRB4
    { HPROP_KRB4_DB,	"krb4-db" },
#endif
    { HPROP_KASERVER, 	"kaserver" },
d216 1
a216 1
    int i;
d224 1
a224 1
static void
d226 1
a226 1
	 const char *database,
a233 16
    case HPROP_KRB4_DUMP:
	ret = v4_prop_dump(pd, database);
	break;
#ifdef KRB4
    case HPROP_KRB4_DB:
	ret = kerb_db_iterate ((k_iter_proc_t)kdb_prop, pd);
	if(ret)
	    krb5_errx(context, 1, "kerb_db_iterate: %s", 
		      krb_get_err_text(ret));
	break;
#endif /* KRB4 */
    case HPROP_KASERVER:
	ret = ka_dump(pd, database);
	if(ret)
	    krb5_err(context, 1, ret, "ka_dump");
	break;
d235 1
a235 1
	ret = mit_prop_dump(pd, database);
d237 1
a237 2
	    krb5_errx(context, 1, "mit_prop_dump: %s",
		      krb5_get_err_text(context, ret));
d242 1
a242 1
	    krb5_err(context, 1, ret, "hdb_foreach");
d244 2
d247 1
d252 1
a252 1
	       const char *database, HDB *db)
d261 4
a264 2
	
    iterate (context, database, db, type, &pd);
d275 1
a275 1
		    const char *database, 
d277 1
a277 1
		    int optind, int argc, char **argv)
d281 1
a281 1
    int i;
d283 1
a283 1
    for(i = optind; i < argc; i++){
d290 3
a292 2
	
	port = strchr(argv[i], ':');
d294 2
a295 2
	    snprintf(portstr, sizeof(portstr), "%u", 
		     ntohs(krb5_getportbyname (context, "hprop", "tcp", 
d301 1
a301 1
	fd = open_socket(context, argv[i], port);
d303 2
a304 1
	    krb5_warn (context, errno, "connect %s", argv[i]);
d311 2
a312 1
	    krb5_warn(context, ret, "krb5_sname_to_principal(%s)", argv[i]);
d320 3
a323 4
	    free (*krb5_princ_realm(context, server));
            krb5_princ_set_realm(context,server,&my_realm);
        }
    
d342 2
a343 1
	    krb5_warn(context, ret, "krb5_sendauth");
d345 1
a345 1
	    continue;
d347 1
a347 1
	
d352 6
a357 1
	iterate (context, database, db, type, &pd);
d361 1
a361 1
	if(ret)
d363 3
d368 5
a372 3
	if(ret)
	    krb5_warn(context, ret, "krb5_read_priv_message");
	else
d374 2
a375 1
	
d379 2
d391 3
a393 1
    int optind = 0;
d395 1
a395 1
    int type = 0;
d397 1
a397 1
    if(getarg(args, num_args, argc, argv, &optind))
d402 1
a402 1
    
d412 5
a419 14
    if(v4_realm == NULL) {
	ret = krb5_get_default_realm(context, &v4_realm);
	if(ret)
	    krb5_err(context, 1, ret, "krb5_get_default_realm");
    }

    if(afs_cell == NULL) {
	afs_cell = strdup(v4_realm);
	if(afs_cell == NULL)
	    krb5_errx(context, 1, "out of memory");
	strlwr(afs_cell);
    }


d421 1
a421 1
	krb5_errx(context, 1, 
d428 1
a428 1
    } else if(type == 0)
d433 1
a433 1
    
a440 14
    
#ifdef KRB4
    if (IS_TYPE_V4(type)) {
	int e;

	if (v4_realm == NULL) {
	    e = krb_get_lrealm(realm_buf, 1);
	    if(e)
		krb5_errx(context, 1, "krb_get_lrealm: %s",
			  krb_get_err_text(e));
	    v4_realm = realm_buf;
	}
    }
#endif
a442 20
#ifdef KRB4
    case HPROP_KRB4_DB:
	if (database == NULL)
	    krb5_errx(context, 1, "no database specified");
	break;
#endif
    case HPROP_KASERVER:
	if (database == NULL)
	    database = DEFAULT_DATABASE;
	ka_use_null_salt = krb5_config_get_bool_default(context, NULL, FALSE, 
							"hprop", 
							"afs_uses_null_salt", 
							NULL);

	break;
    case HPROP_KRB4_DUMP:
	if (database == NULL)
	    krb5_errx(context, 1, "no dump file specified");
	
	break;
d461 1
a461 1
	dump_database (context, type, database, db);
d463 2
a464 2
	propagate_database (context, type, database, 
			    db, ccache, optind, argc, argv);
d468 1
a468 1
	
d473 1
a473 1
    return 0;
@


1.6
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d752 1
a752 1
    int type;
@


1.5
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d752 1
a752 1
    int type = 0;
a790 2
	if(type != 0)
	    krb5_errx(context, 1, "more than one database type specified");
@


1.4
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 8
a43 1
RCSID("$KTH: hprop.c,v 1.70 2002/09/04 18:19:41 joda Exp $");
d246 1
a246 1
    krb5_data_alloc(&ent.keys.val[0].key.keyvalue, sizeof(des_cblock));
d394 1
a394 1
    if(ntohl(ent->valid_end) != NEVERDATE && ntohl(ent->valid_end) != -1){
d513 1
a513 1
    krb5_get_init_creds_opt init_opts;
d527 3
a529 2
    krb5_get_init_creds_opt_init(&init_opts);
    krb5_get_init_creds_opt_set_preauth_list(&init_opts, &preauth, 1);
d531 1
a531 1
    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, &init_opts);
d533 2
d550 1
a550 1
    krb5_free_creds_contents(context, &creds);
d853 1
a853 1
	ret = db->open(context, db, O_RDONLY, 0);
d855 1
a855 1
	    krb5_err(context, 1, ret, "db->open");
d872 1
a872 1
	(*db->destroy)(context, db);
@


1.3
log
@correct size_t printing
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: hprop.c,v 1.66 2001/07/19 16:29:35 assar Exp $");
d40 2
a41 2
static char *ktname = HPROP_KEYTAB;
static char *database;
d340 1
a340 2
	krb5_errx(context, 1, "read(%lu) = %lu", (unsigned long)len,
	    (unsigned long)ret);
d535 2
d539 2
d683 1
d694 1
a694 1
			    AP_OPTS_MUTUAL_REQUIRED,
d702 2
d709 1
a709 1

d738 2
a739 2
    krb5_ccache ccache;
    HDB *db;
d857 8
@


1.2
log
@Remove all uses of setprogname() and getprogname() in kerberosV subtree.
@
text
@d337 1
a337 1
	krb5_err(context, 1, errno, "read(%u)", len);
d340 2
a341 1
	krb5_errx(context, 1, "read(%u) = %u", len, ret);
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
RCSID("$KTH: hprop.c,v 1.60 2001/02/05 03:40:00 assar Exp $");
d52 1
a52 1
static char *realm;
a53 7
#ifdef KRB4
static int v4_db;

static des_cblock mkey4;
static des_key_schedule msched4;

#ifdef KASERVER_DB
a54 1
static int ka_db;
a55 2
#endif
#endif
a152 1
    kdb_encrypt_key(&pr.key, &pr.key, &mkey4, msched4, DES_DECRYPT);
d158 1
a158 1
    pr.mkvno = -1; /* p->kdc_key_ver; */
d212 1
a212 1
    ret = krb5_425_conv_principal(pd->context, p->name, p->instance, realm,
d214 1
a214 1
    if(ret){
d217 1
a217 1
		  p->name, p->instance, realm);
d233 1
a233 5
#if 0
	*(ent.keys.val[0].mkvno) = p->mkvno; /* XXX */
#else
	*(ent.keys.val[0].mkvno) = 0;
#endif
d266 1
a266 1
			      realm,
d278 1
a278 1
				  realm, &ent.modified_by->principal);
d280 1
a280 1
	krb5_warn(pd->context, ret, "%s.%s@@%s", p->name, p->instance, realm);
d308 1
a308 1
	&& strcmp (realm, p->instance) != 0) {
d311 1
a311 1
				       realm, p->instance,
a321 3
#ifdef KRB4
#ifdef KASERVER_DB

d329 4
d338 1
d344 1
a344 2
ka_convert(struct prop_data *pd, int fd, struct ka_entry *ent,
	   const char *cell)
d354 2
a355 2
    ret = krb5_425_conv_principal(pd->context, ent->name, ent->instance, realm,
				  &hdb.principal);
d359 1
a359 1
		  ent->name, ent->instance, realm);
d373 2
a374 2
	hdb.keys.val[0].salt->salt.data = strdup(cell);
	hdb.keys.val[0].salt->salt.length = strlen(cell);
d401 1
a401 1
			      realm,
d412 1
a412 1
	krb5_425_conv_principal(pd->context, mod.name, mod.instance, realm, 
d436 1
a436 1
ka_dump(struct prop_data *pd, const char *file, const char *cell)
d446 2
a447 2
	krb5_errx(pd->context, 1, "Version mismatch in header: %d/%d", 
		  ntohl(header.version1), ntohl(header.version2));
d449 2
a450 2
	krb5_errx(pd->context, 1, "Unknown database version %d (expected 5)", 
		  ntohl(header.version1));
d456 1
a456 1
	    ka_convert(pd, fd, &ent, cell);
a462 3
#endif /* KASERVER_DB */

#endif /* KRB4 */
d474 1
a474 1
#ifdef KASERVER_DB
a475 2
#endif
#endif
d478 1
a478 6
#ifdef KRB4
    { "v4-db",    '4',	arg_flag, &v4_db },
#endif
    { "v4-realm", 'r',  arg_string, &realm, "v4 realm to use" },
#ifdef KASERVER_DB
    { "ka-db",	  'K',  arg_flag, &ka_db },
a480 1
#endif
d496 1
a496 1
    arg_printusage (args, num_args, NULL, "host ...");
d557 1
a557 1
#ifdef KASERVER_DB
a558 2
#endif
#endif
a575 1
	 const char *afs_cell,
d593 1
a593 1
#ifdef KASERVER_DB
d595 1
a595 1
	ret = ka_dump(pd, database, afs_cell);
d597 1
a597 1
	    krb5_errx(context, 1, "ka_dump: %s", krb_get_err_text(ret));
a598 2
#endif
#endif /* KRB4 */
d615 1
a615 2
	       const char *database, const char *afs_cell,
	       HDB *db)
d625 1
a625 1
    iterate (context, database, afs_cell, db, type, &pd);
d636 1
a636 1
		    const char *database, const char *afs_cell,
d707 1
a707 1
	iterate (context, database, afs_cell, db, type, &pd);
a725 22
#ifdef KRB4

static void
v4_get_masterkey (krb5_context context, char *database)
{
    int e;

    e = kerb_db_set_name (database);
    if(e)
	krb5_errx(context, 1, "kerb_db_set_name: %s",
		  krb_get_err_text(e));
    e = kdb_get_master_key(0, &mkey4, msched4);
    if(e)
	krb5_errx(context, 1, "kdb_get_master_key: %s",
		  krb_get_err_text(e));
    e = kdb_verify_master_key(&mkey4, msched4, NULL);
    if (e < 0)
	krb5_errx(context, 1, "kdb_verify_master_key failed");
}

#endif

a736 2
    set_progname(argv[0]);

d755 13
a772 15
#ifdef KRB4
    if(v4_db) {
	if(type != 0)
	    krb5_errx(context, 1, "more than one database type specified");
	type = HPROP_KRB4_DB;
    }
#ifdef KASERVER_DB
    if(ka_db) {
	if(type != 0)
	    krb5_errx(context, 1, "more than one database type specified");
	type = HPROP_KASERVER;
    }
#endif
#endif

d797 1
a797 1
	if (realm == NULL) {
d802 1
a802 1
	    realm = realm_buf;
a811 1
	v4_get_masterkey (context, database);
d813 1
a813 1
#ifdef KASERVER_DB
a822 2
#endif
#endif /* KRB4 */
d826 1
a826 3
#ifdef KRB4
	v4_get_masterkey (context, database);
#endif
d846 1
a846 1
	dump_database (context, type, database, afs_cell, db);
d848 1
a848 1
	propagate_database (context, type, database, afs_cell,
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d36 1
a36 1
RCSID("$KTH: hprop.c,v 1.62 2001/02/20 01:44:50 assar Exp $");
d460 2
a461 2
	krb5_errx(pd->context, 1, "Version mismatch in header: %ld/%ld",
		  (long)ntohl(header.version1), (long)ntohl(header.version2));
d463 2
a464 2
	krb5_errx(pd->context, 1, "Unknown database version %ld (expected 5)", 
		  (long)ntohl(header.version1));
d790 1
a790 1
    setprogname(argv[0]);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: hprop.c,v 1.66 2001/07/19 16:29:35 assar Exp $");
d52 1
a52 1
static char *v4_realm;
d54 7
d62 1
d64 2
d163 1
d169 1
a169 1
    pr.mkvno = p->kdc_key_ver;
d223 1
a223 1
    ret = krb5_425_conv_principal(pd->context, p->name, p->instance, v4_realm,
d225 1
a225 1
    if(ret) {
d228 1
a228 1
		  p->name, p->instance, v4_realm);
d244 5
a248 1
	*(ent.keys.val[0].mkvno) = p->mkvno;
d281 1
a281 1
			      v4_realm,
d293 1
a293 1
				  v4_realm, &ent.modified_by->principal);
d295 1
a295 1
	krb5_warn(pd->context, ret, "%s.%s@@%s", p->name, p->instance, v4_realm);
d323 1
a323 1
	&& strcmp (v4_realm, p->instance) != 0) {
d326 1
a326 1
				       v4_realm, p->instance,
d337 3
a346 4
#ifdef HAVE_PREAD
    if((ret = pread(fd, buf, len, 64 + pos)) < 0)
	krb5_err(context, 1, errno, "pread(%u)", 64 + pos);
#else
a351 1
#endif
d357 2
a358 1
ka_convert(struct prop_data *pd, int fd, struct ka_entry *ent)
d368 2
a369 2
    ret = krb5_425_conv_principal(pd->context, ent->name, ent->instance, 
				  v4_realm, &hdb.principal);
d373 1
a373 1
		  ent->name, ent->instance, v4_realm);
d387 2
a388 2
	hdb.keys.val[0].salt->salt.data = strdup(afs_cell);
	hdb.keys.val[0].salt->salt.length = strlen(afs_cell);
d415 1
a415 1
			      v4_realm,
d426 1
a426 1
	krb5_425_conv_principal(pd->context, mod.name, mod.instance, v4_realm, 
d450 1
a450 1
ka_dump(struct prop_data *pd, const char *file)
d470 1
a470 1
	    ka_convert(pd, fd, &ent);
d477 3
d491 3
a494 1
      "|kaserver"
d497 6
a502 1
    { "v4-realm", 'r',  arg_string, &v4_realm, "v4 realm to use" },
d505 1
d521 1
a521 1
    arg_printusage (args, num_args, NULL, "[host[:port]] ...");
d582 3
a585 1
    { HPROP_KASERVER, 	"kaserver" },
d603 1
d621 1
a621 1
#endif /* KRB4 */
d623 1
a623 1
	ret = ka_dump(pd, database);
d625 1
a625 1
	    krb5_err(context, 1, ret, "ka_dump");
d627 2
d645 2
a646 1
	       const char *database, HDB *db)
d656 1
a656 1
    iterate (context, database, db, type, &pd);
d667 1
a667 1
		    const char *database, 
d738 1
a738 1
	iterate (context, database, db, type, &pd);
d757 22
a809 13
    if(v4_realm == NULL) {
	ret = krb5_get_default_realm(context, &v4_realm);
	if(ret)
	    krb5_err(context, 1, ret, "krb5_get_default_realm");
    }

    if(afs_cell == NULL) {
	afs_cell = strdup(v4_realm);
	if(afs_cell == NULL)
	    krb5_errx(context, 1, "out of memory");
	strlwr(afs_cell);
    }

d815 15
d854 1
a854 1
	if (v4_realm == NULL) {
d859 1
a859 1
	    v4_realm = realm_buf;
d869 1
d871 1
a871 1
#endif
d881 2
d886 3
a888 1
	
d908 1
a908 1
	dump_database (context, type, database, db);
d910 1
a910 1
	propagate_database (context, type, database, 
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: hprop.c,v 1.70 2002/09/04 18:19:41 joda Exp $");
d40 2
a41 2
static const char *ktname = HPROP_KEYTAB;
static const char *database;
d337 1
a337 1
	krb5_err(context, 1, errno, "read(%lu)", (unsigned long)len);
d340 1
a340 1
	krb5_errx(context, 1, "read(%lu) = %u", (unsigned long)len, ret);
a534 2
    krb5_free_principal(context, client);

a536 2

    krb5_free_creds_contents(context, &creds);
a678 1
	    free (*krb5_princ_realm(context, server));
d689 1
a689 1
			    AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,
a696 2
	krb5_free_principal(context, server);

d702 1
a702 1
	
d731 2
a732 2
    krb5_ccache ccache = NULL;
    HDB *db = NULL;
a851 8

    if(ccache != NULL)
	krb5_cc_destroy(context, ccache);
	
    if(db != NULL)
	(*db->destroy)(context, db);

    krb5_free_context(context);
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d36 1
a36 8
#ifdef KRB4
#include <krb.h>
#include <prot.h>
#define Principal Principal4
#include <krb_db.h>
#endif

RCSID("$KTH: hprop.c,v 1.76 2005/04/24 13:48:37 lha Exp $");
d239 1
a239 1
    krb5_data_alloc(&ent.keys.val[0].key.keyvalue, DES_KEY_SZ);
d387 1
a387 1
    if(ntohl(ent->valid_end) != NEVERDATE && ntohl(ent->valid_end) != 0xffffffff) {
d506 1
a506 1
    krb5_get_init_creds_opt *init_opts;
d520 2
a521 3
    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);
    if(ret) krb5_err(context, 1, ret, "krb5_get_init_creds_opt_alloc");
    krb5_get_init_creds_opt_set_preauth_list(init_opts, &preauth, 1);
d523 1
a523 1
    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, init_opts);
a524 2

    krb5_get_init_creds_opt_free(init_opts);
d540 1
a540 1
    krb5_free_cred_contents(context, &creds);
d845 1
a845 1
	ret = db->hdb_open(context, db, O_RDONLY, 0);
d847 1
a847 1
	    krb5_err(context, 1, ret, "db->hdb_open");
d864 1
a864 1
	(*db->hdb_destroy)(context, db);
@


