head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.26
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.24
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.22
	OPENBSD_5_0:1.2.0.20
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.18
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.16
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	HEIMDAL_0_7_2:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.20
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.18
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.16
	OPENBSD_3_7_BASE:1.1.1.1
	HEIMDAL_0_6_3:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.14
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.12
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.10
	OPENBSD_3_4_BASE:1.1.1.1
	HEIMDAL_0_6:1.1.1.1
	HEIMDAL_0_6RC1:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.37;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.37;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.04.14.07.32.46;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 2000 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "hprop.h"

/*
can have any number of princ stanzas.
format is as follows (only \n indicates newlines)
princ\t%d\t (%d is KRB5_KDB_V1_BASE_LENGTH, always 38)
%d\t (strlen of principal e.g. shadow/foo@@ANDREW.CMU.EDU)
%d\t (number of tl_data)
%d\t (number of key data, e.g. how many keys for this user)
%d\t (extra data length)
%s\t (principal name)
%d\t (attributes)
%d\t (max lifetime, seconds)
%d\t (max renewable life, seconds)
%d\t (expiration, seconds since epoch or 2145830400 for never)
%d\t (password expiration, seconds, 0 for never)
%d\t (last successful auth, seconds since epoch)
%d\t (last failed auth, per above)
%d\t (failed auth count)
foreach tl_data 0 to number of tl_data - 1 as above
  %d\t%d\t (data type, data length)
  foreach tl_data 0 to length-1
    %02x (tl data contents[element n])
  except if tl_data length is 0
    %d (always -1)
  \t
foreach key 0 to number of keys - 1 as above
  %d\t%d\t (key data version, kvno)
  foreach version 0 to key data version - 1 (a key or a salt)
    %d\t%d\t(data type for this key, data length for this key)
    foreach key data length 0 to length-1
      %02x (key data contents[element n])
    except if key_data length is 0
      %d (always -1)
    \t
foreach extra data length 0 to length - 1
  %02x (extra data part)
unless no extra data
  %d (always -1)
;\n

*/

static int
hex_to_octet_string(const char *ptr, krb5_data *data)
{
    size_t i;
    unsigned int v;
    for(i = 0; i < data->length; i++) {
	if(sscanf(ptr + 2 * i, "%02x", &v) != 1)
	    return -1;
	((unsigned char*)data->data)[i] = v;
    }
    return 2 * i;
}

static char *
nexttoken(char **p)
{
    char *q;
    do {
	q = strsep(p, " \t");
    } while(q && *q == '\0');
    return q;
}

static size_t
getdata(char **p, unsigned char *buf, size_t len)
{
    size_t i;
    int v;
    char *q = nexttoken(p);
    i = 0;
    while(*q && i < len) {
	if(sscanf(q, "%02x", &v) != 1)
	    break;
	buf[i++] = v;
	q += 2;
    }
    return i;
}

static int
getint(char **p)
{
    int val;
    char *q = nexttoken(p);
    sscanf(q, "%d", &val);
    return val;
}

#include <kadm5/admin.h>

static void
attr_to_flags(unsigned attr, HDBFlags *flags)
{
    flags->postdate =		!(attr & KRB5_KDB_DISALLOW_POSTDATED);
    flags->forwardable =	!(attr & KRB5_KDB_DISALLOW_FORWARDABLE);
    flags->initial =	       !!(attr & KRB5_KDB_DISALLOW_TGT_BASED);
    flags->renewable =		!(attr & KRB5_KDB_DISALLOW_RENEWABLE);
    flags->proxiable =		!(attr & KRB5_KDB_DISALLOW_PROXIABLE);
    /* DUP_SKEY */
    flags->invalid =	       !!(attr & KRB5_KDB_DISALLOW_ALL_TIX);
    flags->require_preauth =   !!(attr & KRB5_KDB_REQUIRES_PRE_AUTH);
    flags->require_hwauth =    !!(attr & KRB5_KDB_REQUIRES_HW_AUTH);
    flags->server =		!(attr & KRB5_KDB_DISALLOW_SVR);
    flags->change_pw = 	       !!(attr & KRB5_KDB_PWCHANGE_SERVICE);
    flags->client =	        1; /* XXX */
}

#define KRB5_KDB_SALTTYPE_NORMAL	0
#define KRB5_KDB_SALTTYPE_V4		1
#define KRB5_KDB_SALTTYPE_NOREALM	2
#define KRB5_KDB_SALTTYPE_ONLYREALM	3
#define KRB5_KDB_SALTTYPE_SPECIAL	4
#define KRB5_KDB_SALTTYPE_AFS3		5

static krb5_error_code
fix_salt(krb5_context context, hdb_entry *ent, int key_num)
{
    krb5_error_code ret;
    Salt *salt = ent->keys.val[key_num].salt;
    /* fix salt type */
    switch((int)salt->type) {
    case KRB5_KDB_SALTTYPE_NORMAL:
	salt->type = KRB5_PADATA_PW_SALT;
	break;
    case KRB5_KDB_SALTTYPE_V4:
	krb5_data_free(&salt->salt);
	salt->type = KRB5_PADATA_PW_SALT;
	break;
    case KRB5_KDB_SALTTYPE_NOREALM:
    {
	size_t len;
	size_t i;
	char *p;

	len = 0;
	for (i = 0; i < ent->principal->name.name_string.len; ++i)
	    len += strlen(ent->principal->name.name_string.val[i]);
	ret = krb5_data_alloc (&salt->salt, len);
	if (ret)
	    return ret;
	p = salt->salt.data;
	for (i = 0; i < ent->principal->name.name_string.len; ++i) {
	    memcpy (p,
		    ent->principal->name.name_string.val[i],
		    strlen(ent->principal->name.name_string.val[i]));
	    p += strlen(ent->principal->name.name_string.val[i]);
	}

	salt->type = KRB5_PADATA_PW_SALT;
	break;
    }
    case KRB5_KDB_SALTTYPE_ONLYREALM:
	krb5_data_free(&salt->salt);
	ret = krb5_data_copy(&salt->salt,
			     ent->principal->realm,
			     strlen(ent->principal->realm));
	if(ret)
	    return ret;
	salt->type = KRB5_PADATA_PW_SALT;
	break;
    case KRB5_KDB_SALTTYPE_SPECIAL:
	salt->type = KRB5_PADATA_PW_SALT;
	break;
    case KRB5_KDB_SALTTYPE_AFS3:
	krb5_data_free(&salt->salt);
	ret = krb5_data_copy(&salt->salt,
		       ent->principal->realm,
		       strlen(ent->principal->realm));
	if(ret)
	    return ret;
	salt->type = KRB5_PADATA_AFS3_SALT;
	break;
    default:
	abort();
    }
    return 0;
}

int
mit_prop_dump(void *arg, const char *file)
{
    krb5_error_code ret;
    char line [2048];
    FILE *f;
    int lineno = 0;
    struct hdb_entry_ex ent;

    struct prop_data *pd = arg;

    f = fopen(file, "r");
    if(f == NULL)
	return errno;

    while(fgets(line, sizeof(line), f)) {
	char *p = line, *q;

	int i;

	int num_tl_data;
	int num_key_data;
	int high_kvno;
	int attributes;

	int tmp;

	lineno++;

	memset(&ent, 0, sizeof(ent));

	q = nexttoken(&p);
	if(strcmp(q, "kdb5_util") == 0) {
	    int major;
	    q = nexttoken(&p); /* load_dump */
	    if(strcmp(q, "load_dump"))
		errx(1, "line %d: unknown version", lineno);
	    q = nexttoken(&p); /* load_dump */
	    if(strcmp(q, "version"))
		errx(1, "line %d: unknown version", lineno);
	    q = nexttoken(&p); /* x.0 */
	    if(sscanf(q, "%d", &major) != 1)
		errx(1, "line %d: unknown version", lineno);
	    if(major != 4 && major != 5 && major != 6)
		errx(1, "unknown dump file format, got %d, expected 4-6",
		     major);
	    continue;
	} else if(strcmp(q, "policy") == 0) {
	    continue;
	} else if(strcmp(q, "princ") != 0) {
	    warnx("line %d: not a principal", lineno);
	    continue;
	}
	tmp = getint(&p);
	if(tmp != 38) {
	    warnx("line %d: bad base length %d != 38", lineno, tmp);
	    continue;
	}
	nexttoken(&p); /* length of principal */
	num_tl_data = getint(&p); /* number of tl-data */
	num_key_data = getint(&p); /* number of key-data */
	getint(&p);  /* length of extra data */
	q = nexttoken(&p); /* principal name */
	krb5_parse_name(pd->context, q, &ent.entry.principal);
	attributes = getint(&p); /* attributes */
	attr_to_flags(attributes, &ent.entry.flags);
	tmp = getint(&p); /* max life */
	if(tmp != 0) {
	    ALLOC(ent.entry.max_life);
	    *ent.entry.max_life = tmp;
	}
	tmp = getint(&p); /* max renewable life */
	if(tmp != 0) {
	    ALLOC(ent.entry.max_renew);
	    *ent.entry.max_renew = tmp;
	}
	tmp = getint(&p); /* expiration */
	if(tmp != 0 && tmp != 2145830400) {
	    ALLOC(ent.entry.valid_end);
	    *ent.entry.valid_end = tmp;
	}
	tmp = getint(&p); /* pw expiration */
	if(tmp != 0) {
	    ALLOC(ent.entry.pw_end);
	    *ent.entry.pw_end = tmp;
	}
	nexttoken(&p); /* last auth */
	nexttoken(&p); /* last failed auth */
	nexttoken(&p); /* fail auth count */
	for(i = 0; i < num_tl_data; i++) {
	    unsigned long val;
	    int tl_type, tl_length;
	    unsigned char *buf;
	    krb5_principal princ;

	    tl_type = getint(&p); /* data type */
	    tl_length = getint(&p); /* data length */

#define mit_KRB5_TL_LAST_PWD_CHANGE	1
#define mit_KRB5_TL_MOD_PRINC		2
	    switch(tl_type) {
	    case mit_KRB5_TL_LAST_PWD_CHANGE:
		buf = malloc(tl_length);
		if (buf == NULL)
		    errx(ENOMEM, "malloc");
		getdata(&p, buf, tl_length); /* data itself */
		val = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
		free(buf);
		ALLOC(ent.entry.extensions);
		ALLOC_SEQ(ent.entry.extensions, 1);
		ent.entry.extensions->val[0].mandatory = 0;
		ent.entry.extensions->val[0].data.element
		    = choice_HDB_extension_data_last_pw_change;
		ent.entry.extensions->val[0].data.u.last_pw_change = val;
		break;
	    case mit_KRB5_TL_MOD_PRINC:
		buf = malloc(tl_length);
		if (buf == NULL)
		    errx(ENOMEM, "malloc");
		getdata(&p, buf, tl_length); /* data itself */
		val = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
		ret = krb5_parse_name(pd->context, (char *)buf + 4, &princ);
		if (ret)
		    krb5_err(pd->context, 1, ret,
			     "parse_name: %s", (char *)buf + 4);
		free(buf);
		ALLOC(ent.entry.modified_by);
		ent.entry.modified_by->time = val;
		ent.entry.modified_by->principal = princ;
		break;
	    default:
		nexttoken(&p);
		break;
	    }
	}
	ALLOC_SEQ(&ent.entry.keys, num_key_data);
	high_kvno = -1;
	for(i = 0; i < num_key_data; i++) {
	    int key_versions;
	    int kvno;
	    key_versions = getint(&p); /* key data version */
	    kvno = getint(&p);

	    /*
	     * An MIT dump file may contain multiple sets of keys with
	     * different kvnos.  Since the Heimdal database can only represent
	     * one kvno per principal, we only want the highest set.  Assume
	     * that set will be given first, and discard all keys with lower
	     * kvnos.
	     */
	    if (kvno > high_kvno && high_kvno != -1)
		errx(1, "line %d: high kvno keys given after low kvno keys",
		     lineno);
	    else if (kvno < high_kvno) {
		nexttoken(&p); /* key type */
		nexttoken(&p); /* key length */
		nexttoken(&p); /* key */
		if (key_versions > 1) {
		    nexttoken(&p); /* salt type */
		    nexttoken(&p); /* salt length */
		    nexttoken(&p); /* salt */
		}
		ent.entry.keys.len--;
		continue;
	    }
	    ent.entry.kvno = kvno;
	    high_kvno = kvno;
	    ALLOC(ent.entry.keys.val[i].mkvno);
	    *ent.entry.keys.val[i].mkvno = 1;

	    /* key version 0 -- actual key */
	    ent.entry.keys.val[i].key.keytype = getint(&p); /* key type */
	    tmp = getint(&p); /* key length */
	    /* the first two bytes of the key is the key length --
	       skip it */
	    krb5_data_alloc(&ent.entry.keys.val[i].key.keyvalue, tmp - 2);
	    q = nexttoken(&p); /* key itself */
	    hex_to_octet_string(q + 4, &ent.entry.keys.val[i].key.keyvalue);

	    if(key_versions > 1) {
		/* key version 1 -- optional salt */
		ALLOC(ent.entry.keys.val[i].salt);
		ent.entry.keys.val[i].salt->type = getint(&p); /* salt type */
		tmp = getint(&p); /* salt length */
		if(tmp > 0) {
		    krb5_data_alloc(&ent.entry.keys.val[i].salt->salt, tmp - 2);
		    q = nexttoken(&p); /* salt itself */
		    hex_to_octet_string(q + 4,
					&ent.entry.keys.val[i].salt->salt);
		} else {
		    ent.entry.keys.val[i].salt->salt.length = 0;
		    ent.entry.keys.val[i].salt->salt.data = NULL;
		    getint(&p);	/* -1, if no data. */
		}
		fix_salt(pd->context, &ent.entry, i);
	    }
	}
	nexttoken(&p); /* extra data */
	v5_prop(pd->context, NULL, &ent, arg);
    }
    fclose(f);
    return 0;
}
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.2
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Kungliga Tekniska Högskolan
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d12 1
a12 1
 * 
d16 1
a16 1
 * 
d20 1
a20 1
 * 
a35 2
RCSID("$KTH: mit_dump.c,v 1.5 2005/06/02 09:55:43 lha Exp $");

d43 1
a43 1
%d\t (extra data length) 
d49 1
a49 1
%d\t (password expiration, seconds, 0 for never) 
d68 1
a68 1
    \t    
d80 1
a80 1
    int i;
d138 1
a138 1
    /* HW_AUTH */
d168 1
a168 2
	int i;
	krb5_error_code ret;
d170 1
a170 1
	    
d190 2
a191 2
	ret = krb5_data_copy(&salt->salt, 
			     ent->principal->realm, 
d202 2
a203 2
	ret = krb5_data_copy(&salt->salt, 
		       ent->principal->realm, 
d219 1
a219 1
    char buf [1024];
d222 1
a222 1
    struct hdb_entry ent;
d229 3
a231 3
    
    while(fgets(buf, sizeof(buf), f)) {
	char *p = buf, *q;
d237 1
a237 1
	int extra_data_length;
d258 5
a262 2
	    if(major != 4)
		errx(1, "unknown dump file format, got %d, expected 4", major);
d273 1
a273 1
	q = nexttoken(&p); /* length of principal */
d276 1
a276 1
	extra_data_length = getint(&p);  /* length of extra data */
d278 1
a278 1
	krb5_parse_name(pd->context, q, &ent.principal);
d280 1
a280 1
	attr_to_flags(attributes, &ent.flags);
d283 2
a284 2
	    ALLOC(ent.max_life);
	    *ent.max_life = tmp;
d288 2
a289 2
	    ALLOC(ent.max_renew);
	    *ent.max_renew = tmp;
d293 2
a294 2
	    ALLOC(ent.valid_end);
	    *ent.valid_end = tmp;
d298 2
a299 2
	    ALLOC(ent.pw_end);
	    *ent.pw_end = tmp;
d301 3
a303 3
	q = nexttoken(&p); /* last auth */
	q = nexttoken(&p); /* last failed auth */
	q = nexttoken(&p); /* fail auth count */
d316 14
d332 2
d337 3
d341 3
a343 3
		ALLOC(ent.modified_by);
		ent.modified_by->time = val;
		ent.modified_by->principal = princ;
d350 2
a351 1
	ALLOC_SEQ(&ent.keys, num_key_data);
d354 1
d356 29
a384 5
	    ent.kvno = getint(&p); /* XXX kvno */
	    
	    ALLOC(ent.keys.val[i].mkvno);
	    *ent.keys.val[i].mkvno = 0;
	    
d386 1
a386 1
	    ent.keys.val[i].key.keytype = getint(&p); /* key type */
d390 1
a390 1
	    krb5_data_alloc(&ent.keys.val[i].key.keyvalue, tmp - 2);
d392 1
a392 1
	    hex_to_octet_string(q + 4, &ent.keys.val[i].key.keyvalue);
d396 2
a397 2
		ALLOC(ent.keys.val[i].salt);
		ent.keys.val[i].salt->type = getint(&p); /* salt type */
d400 1
a400 1
		    krb5_data_alloc(&ent.keys.val[i].salt->salt, tmp - 2);
d402 2
a403 1
		    hex_to_octet_string(q + 4, &ent.keys.val[i].salt->salt);
d405 3
a407 3
		    ent.keys.val[i].salt->salt.length = 0;
		    ent.keys.val[i].salt->salt.data = NULL;
		    tmp = getint(&p);	/* -1, if no data. */
d409 1
a409 1
		fix_salt(pd->context, &ent, i);
d412 1
a412 1
	q = nexttoken(&p); /* extra data */
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
RCSID("$KTH: mit_dump.c,v 1.3 2000/08/09 09:57:37 joda Exp $");
d313 2
a314 2
#define KRB5_TL_LAST_PWD_CHANGE	1
#define KRB5_TL_MOD_PRINC	2
d316 1
a316 1
	    case KRB5_TL_MOD_PRINC:
d320 1
a320 1
		ret = krb5_parse_name(pd->context, buf + 4, &princ);
d369 1
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: mit_dump.c,v 1.5 2005/06/02 09:55:43 lha Exp $");
d313 2
a314 2
#define mit_KRB5_TL_LAST_PWD_CHANGE	1
#define mit_KRB5_TL_MOD_PRINC		2
d316 1
a316 1
	    case mit_KRB5_TL_MOD_PRINC:
d320 1
a320 1
		ret = krb5_parse_name(pd->context, (char *)buf + 4, &princ);
@

