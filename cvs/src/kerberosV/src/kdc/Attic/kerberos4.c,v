head	1.7;
access;
symbols
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.06.17.18.57.41;	author robert;	state dead;
branches;
next	1.6;

1.6
date	2006.04.14.08.15.03;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.29.16.20.29;	author biorn;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.11.03.39.59;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.21.09.50.07;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.06.00.37.36;	author hin;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.05.25.07.49.33;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.33;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.54.52;	author hin;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.32;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.32;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.32.44;	author biorn;	state Exp;
branches;
next	;

1.1.1.2.2.1
date	2003.03.22.06.57.21;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2003.03.22.21.26.30;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.7
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@/*
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 */

#include "kdc_locl.h"

#include <krb5-v4compat.h>

RCSID("$KTH: kerberos4.c,v 1.52 2005/04/23 20:11:55 lha Exp $");

#ifndef swap32
static u_int32_t
swap32(u_int32_t x)
{
    return ((x << 24) & 0xff000000) |
	((x << 8) & 0xff0000) |
	((x >> 8) & 0xff00) |
	((x >> 24) & 0xff);
}
#endif /* swap32 */

int
maybe_version4(unsigned char *buf, int len)
{
    return len > 0 && *buf == 4;
}

static void
make_err_reply(krb5_context context, krb5_data *reply,
	       int code, const char *msg)
{
    _krb5_krb_cr_err_reply(context, "", "", "", 
			   kdc_time, code, msg, reply);
}

static krb5_boolean
valid_princ(krb5_context context, krb5_principal princ)
{
    krb5_error_code ret;
    char *s;
    hdb_entry *ent;

    ret = krb5_unparse_name(context, princ, &s);
    if (ret)
	return FALSE;
    ret = db_fetch(princ, &ent);
    if (ret) {
	kdc_log(7, "Lookup %s failed: %s", s,
		krb5_get_err_text (context, ret));
	free(s);
	return FALSE;
    }
    kdc_log(7, "Lookup %s succeeded", s);
    free(s);
    free_ent(ent);
    return TRUE;
}

krb5_error_code
db_fetch4(const char *name, const char *instance, const char *realm,
	  hdb_entry **ent)
{
    krb5_principal p;
    krb5_error_code ret;
    
    ret = krb5_425_conv_principal_ext(context, name, instance, realm, 
				      valid_princ, 0, &p);
    if(ret)
	return ret;
    ret = db_fetch(p, ent);
    krb5_free_principal(context, p);
    return ret;
}

#define RCHECK(X, L) if(X){make_err_reply(context, reply, KFAILURE, "Packet too short"); goto L;}

/*
 * Process the v4 request in `buf, len' (received from `addr'
 * (with string `from').
 * Return an error code and a reply in `reply'.
 */

krb5_error_code
do_version4(unsigned char *buf,
	    size_t len,
	    krb5_data *reply,
	    const char *from,
	    struct sockaddr_in *addr)
{
    krb5_storage *sp;
    krb5_error_code ret;
    hdb_entry *client = NULL, *server = NULL;
    Key *ckey, *skey;
    int8_t pvno;
    int8_t msg_type;
    int lsb;
    char *name = NULL, *inst = NULL, *realm = NULL;
    char *sname = NULL, *sinst = NULL;
    int32_t req_time;
    time_t max_life;
    u_int8_t life;
    char client_name[256];
    char server_name[256];

    if(!enable_v4) {
	kdc_log(0, "Rejected version 4 request from %s", from);
	make_err_reply(context, reply, KDC_GEN_ERR, "function not enabled");
	return 0;
    }

    sp = krb5_storage_from_mem(buf, len);
    RCHECK(krb5_ret_int8(sp, &pvno), out);
    if(pvno != 4){
	kdc_log(0, "Protocol version mismatch (krb4) (%d)", pvno);
	make_err_reply(context, reply, KDC_PKT_VER, "protocol mismatch");
	goto out;
    }
    RCHECK(krb5_ret_int8(sp, &msg_type), out);
    lsb = msg_type & 1;
    msg_type &= ~1;
    switch(msg_type){
    case AUTH_MSG_KDC_REQUEST: {
	krb5_data ticket, cipher;
	krb5_keyblock session;
	
	krb5_data_zero(&ticket);
	krb5_data_zero(&cipher);

	RCHECK(krb5_ret_stringz(sp, &name), out1);
	RCHECK(krb5_ret_stringz(sp, &inst), out1);
	RCHECK(krb5_ret_stringz(sp, &realm), out1);
	RCHECK(krb5_ret_int32(sp, &req_time), out1);
	if(lsb)
	    req_time = swap32(req_time);
	RCHECK(krb5_ret_int8(sp, &life), out1);
	RCHECK(krb5_ret_stringz(sp, &sname), out1);
	RCHECK(krb5_ret_stringz(sp, &sinst), out1);
	snprintf (client_name, sizeof(client_name),
		  "%s.%s@@%s", name, inst, realm);
	snprintf (server_name, sizeof(server_name),
		  "%s.%s@@%s", sname, sinst, v4_realm);
	
	kdc_log(0, "AS-REQ (krb4) %s from %s for %s",
		client_name, from, server_name);

	ret = db_fetch4(name, inst, realm, &client);
	if(ret) {
	    kdc_log(0, "Client not found in database: %s: %s",
		    client_name, krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN,
			   "principal unknown");
	    goto out1;
	}
	ret = db_fetch4(sname, sinst, v4_realm, &server);
	if(ret){
	    kdc_log(0, "Server not found in database: %s: %s",
		    server_name, krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN,
			   "principal unknown");
	    goto out1;
	}

	ret = check_flags (client, client_name,
			   server, server_name,
			   TRUE);
	if (ret) {
	    /* good error code? */
	    make_err_reply(context, reply, KERB_ERR_NAME_EXP,
			   "operation not allowed");
	    goto out1;
	}

	/*
	 * There's no way to do pre-authentication in v4 and thus no
	 * good error code to return if preauthentication is required.
	 */

	if (require_preauth
	    || client->flags.require_preauth
	    || server->flags.require_preauth) {
	    kdc_log(0,
		    "Pre-authentication required for v4-request: "
		    "%s for %s",
		    client_name, server_name);
	    make_err_reply(context, reply, KERB_ERR_NULL_KEY,
			   "preauth required");
	    goto out1;
	}

	ret = get_des_key(client, FALSE, FALSE, &ckey);
	if(ret){
	    kdc_log(0, "no suitable DES key for client");
	    make_err_reply(context, reply, KDC_NULL_KEY, 
			   "no suitable DES key for client");
	    goto out1;
	}

#if 0
	/* this is not necessary with the new code in libkrb */
	/* find a properly salted key */
	while(ckey->salt == NULL || ckey->salt->salt.length != 0)
	    ret = hdb_next_keytype2key(context, client, KEYTYPE_DES, &ckey);
	if(ret){
	    kdc_log(0, "No version-4 salted key in database -- %s.%s@@%s", 
		    name, inst, realm);
	    make_err_reply(context, reply, KDC_NULL_KEY, 
			   "No version-4 salted key in database");
	    goto out1;
	}
#endif
	
	ret = get_des_key(server, TRUE, FALSE, &skey);
	if(ret){
	    kdc_log(0, "no suitable DES key for server");
	    /* XXX */
	    make_err_reply(context, reply, KDC_NULL_KEY, 
			   "no suitable DES key for server");
	    goto out1;
	}

	max_life = _krb5_krb_life_to_time(0, life);
	if(client->max_life)
	    max_life = min(max_life, *client->max_life);
	if(server->max_life)
	    max_life = min(max_life, *server->max_life);

	life = krb_time_to_life(kdc_time, kdc_time + max_life);
    
	ret = krb5_generate_random_keyblock(context,
					    ETYPE_DES_PCBC_NONE,
					    &session);
	if (ret) {
	    make_err_reply(context, reply, KFAILURE,
			   "Not enough random i KDC");
	    goto out1;
	}
	
	ret = _krb5_krb_create_ticket(context,
				      0,
				      name,
				      inst,
				      v4_realm,
				      addr->sin_addr.s_addr,
				      &session,
				      life,
				      kdc_time,
				      sname,
				      sinst,
				      &skey->key,
				      &ticket);
	if (ret) {
	    krb5_free_keyblock_contents(context, &session);
	    make_err_reply(context, reply, KFAILURE,
			   "failed to create v4 ticket");
	    goto out1;
	}

	ret = _krb5_krb_create_ciph(context,
				    &session,
				    sname,
				    sinst,
				    v4_realm,
				    life,
				    server->kvno % 255,
				    &ticket,
				    kdc_time,
				    &ckey->key,
				    &cipher);
	krb5_free_keyblock_contents(context, &session);
	krb5_data_free(&ticket);
	if (ret) {
	    make_err_reply(context, reply, KFAILURE, 
			   "Failed to create v4 cipher");
	    goto out1;
	}
	
	ret = _krb5_krb_create_auth_reply(context,
					  name,
					  inst,
					  realm,
					  req_time,
					  0,
					  client->pw_end ? *client->pw_end : 0,
					  client->kvno % 256,
					  &cipher,
					  reply);
	krb5_data_free(&cipher);

    out1:
	break;
    }
    case AUTH_MSG_APPL_REQUEST: {
	struct _krb5_krb_auth_data ad;
	int8_t kvno;
	int8_t ticket_len;
	int8_t req_len;
	krb5_data auth;
	int32_t address;
	size_t pos;
	krb5_principal tgt_princ = NULL;
	hdb_entry *tgt = NULL;
	Key *tkey;
	time_t max_end, actual_end, issue_time;
	
	memset(&ad, 0, sizeof(ad));
	krb5_data_zero(&auth);

	RCHECK(krb5_ret_int8(sp, &kvno), out2);
	RCHECK(krb5_ret_stringz(sp, &realm), out2);
	
	ret = krb5_425_conv_principal(context, "krbtgt", realm, v4_realm,
				      &tgt_princ);
	if(ret){
	    kdc_log(0, "Converting krbtgt principal (krb4): %s", 
		    krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KFAILURE, 
			   "Failed to convert v4 principal (krbtgt)");
	    goto out2;
	}

	ret = db_fetch(tgt_princ, &tgt);
	if(ret){
	    char *s;
	    s = kdc_log_msg(0, "Ticket-granting ticket not "
			    "found in database (krb4): krbtgt.%s@@%s: %s", 
			    realm, v4_realm,
			    krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KFAILURE, s);
	    free(s);
	    goto out2;
	}
	
	if(tgt->kvno % 256 != kvno){
	    kdc_log(0, "tgs-req (krb4) with old kvno %d (current %d) for "
		    "krbtgt.%s@@%s", kvno, tgt->kvno % 256, realm, v4_realm);
	    make_err_reply(context, reply, KDC_AUTH_EXP,
			   "old krbtgt kvno used");
	    goto out2;
	}

	ret = get_des_key(tgt, TRUE, FALSE, &tkey);
	if(ret){
	    kdc_log(0, "no suitable DES key for krbtgt (krb4)");
	    /* XXX */
	    make_err_reply(context, reply, KDC_NULL_KEY, 
			   "no suitable DES key for krbtgt");
	    goto out2;
	}

	RCHECK(krb5_ret_int8(sp, &ticket_len), out2);
	RCHECK(krb5_ret_int8(sp, &req_len), out2);
	
	pos = krb5_storage_seek(sp, ticket_len + req_len, SEEK_CUR);
	
	auth.data = buf;
	auth.length = pos;

	if (check_ticket_addresses)
	    address = addr->sin_addr.s_addr;
	else
	    address = 0;

	ret = _krb5_krb_rd_req(context, &auth, "krbtgt", realm, v4_realm,
			       address, &tkey->key, &ad);
	if(ret){
	    kdc_log(0, "krb_rd_req: %d", ret);
	    make_err_reply(context, reply, ret, "failed to parse request");
	    goto out2;
	}
	
	RCHECK(krb5_ret_int32(sp, &req_time), out2);
	if(lsb)
	    req_time = swap32(req_time);
	RCHECK(krb5_ret_int8(sp, &life), out2);
	RCHECK(krb5_ret_stringz(sp, &sname), out2);
	RCHECK(krb5_ret_stringz(sp, &sinst), out2);
	snprintf (server_name, sizeof(server_name),
		  "%s.%s@@%s",
		  sname, sinst, v4_realm);
	snprintf (client_name, sizeof(client_name),
		  "%s.%s@@%s",
		  ad.pname, ad.pinst, ad.prealm);

	kdc_log(0, "TGS-REQ (krb4) %s from %s for %s",
		client_name, from, server_name);
	
	if(strcmp(ad.prealm, realm)){
	    kdc_log(0, "Can't hop realms (krb4) %s -> %s", realm, ad.prealm);
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't hop realms");
	    goto out2;
	}

	if (!enable_v4_cross_realm && strcmp(realm, v4_realm) != 0) {
	    kdc_log(0, "krb4 Cross-realm %s -> %s disabled", realm, v4_realm);
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't hop realms");
	    goto out2;
	}

	if(strcmp(sname, "changepw") == 0){
	    kdc_log(0, "Bad request for changepw ticket (krb4)");
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't authorize password change based on TGT");
	    goto out2;
	}
	
	ret = db_fetch4(ad.pname, ad.pinst, ad.prealm, &client);
	if(ret && ret != HDB_ERR_NOENTRY) {
	    char *s;
	    s = kdc_log_msg(0, "Client not found in database: (krb4) %s: %s",
			    client_name, krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
	    free(s);
	    goto out2;
	}
	if (client == NULL && strcmp(ad.prealm, v4_realm) == 0) {
	    char *s;
	    s = kdc_log_msg(0, "Local client not found in database: (krb4) "
			    "%s", client_name);
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
	    free(s);
	    goto out2;
	}

	ret = db_fetch4(sname, sinst, v4_realm, &server);
	if(ret){
	    char *s;
	    s = kdc_log_msg(0, "Server not found in database (krb4): %s: %s",
			    server_name, krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
	    free(s);
	    goto out2;
	}

	ret = check_flags (client, client_name,
			   server, server_name,
			   FALSE);
	if (ret) {
	    /* good error code? */
	    make_err_reply(context, reply, KERB_ERR_NAME_EXP,
			   "operation not allowed");
	    goto out2;
	}

	ret = get_des_key(server, TRUE, FALSE, &skey);
	if(ret){
	    kdc_log(0, "no suitable DES key for server (krb4)");
	    /* XXX */
	    make_err_reply(context, reply, KDC_NULL_KEY, 
			   "no suitable DES key for server");
	    goto out2;
	}

	max_end = _krb5_krb_life_to_time(ad.time_sec, ad.life);
	max_end = min(max_end, _krb5_krb_life_to_time(kdc_time, life));
	if(server->max_life)
	    max_end = min(max_end, kdc_time + *server->max_life);
	if(client && client->max_life)
	    max_end = min(max_end, kdc_time + *client->max_life);
	life = min(life, krb_time_to_life(kdc_time, max_end));
	
	issue_time = kdc_time;
	actual_end = _krb5_krb_life_to_time(issue_time, life);
	while (actual_end > max_end && life > 1) {
	    /* move them into the next earlier lifetime bracket */
	    life--;
	    actual_end = _krb5_krb_life_to_time(issue_time, life);
	}
	if (actual_end > max_end) {
	    /* if life <= 1 and it's still too long, backdate the ticket */
	    issue_time -= actual_end - max_end;
	}

	{
	    krb5_data ticket, cipher;
	    krb5_keyblock session;

	    krb5_data_zero(&ticket);
	    krb5_data_zero(&cipher);

	    ret = krb5_generate_random_keyblock(context,
						ETYPE_DES_PCBC_NONE,
						&session);
	    if (ret) {
		make_err_reply(context, reply, KFAILURE,
			       "Not enough random i KDC");
		goto out2;
	    }
	
	    ret = _krb5_krb_create_ticket(context,
					  0,
					  ad.pname,
					  ad.pinst,
					  ad.prealm,
					  addr->sin_addr.s_addr,
					  &session,
					  life,
					  issue_time,
					  sname,
					  sinst,
					  &skey->key,
					  &ticket);
	    if (ret) {
		krb5_free_keyblock_contents(context, &session);
		make_err_reply(context, reply, KFAILURE,
			       "failed to create v4 ticket");
		goto out2;
	    }

	    ret = _krb5_krb_create_ciph(context,
					&session,
					sname,
					sinst,
					v4_realm,
					life,
					server->kvno % 255,
					&ticket,
					issue_time,
					&ad.session,
					&cipher);
	    krb5_free_keyblock_contents(context, &session);
	    if (ret) {
		make_err_reply(context, reply, KFAILURE,
			       "failed to create v4 cipher");
		goto out2;
	    }
	    
	    ret = _krb5_krb_create_auth_reply(context,
					      ad.pname,
					      ad.pinst,
					      ad.prealm,
					      req_time,
					      0,
					      0,
					      0,
					      &cipher,
					      reply);
	    krb5_data_free(&cipher);
	}
    out2:
	_krb5_krb_free_auth_data(context, &ad);
	if(tgt_princ)
	    krb5_free_principal(context, tgt_princ);
	if(tgt)
	    free_ent(tgt);
	break;
    }
    case AUTH_MSG_ERR_REPLY:
	break;
    default:
	kdc_log(0, "Unknown message type (krb4): %d from %s", 
		msg_type, from);
	
	make_err_reply(context, reply, KFAILURE, "Unknown message type");
    }
 out:
    if(name)
	free(name);
    if(inst)
	free(inst);
    if(realm)
	free(realm);
    if(sname)
	free(sname);
    if(sinst)
	free(sinst);
    if(client)
	free_ent(client);
    if(server)
	free_ent(server);
    krb5_storage_free(sp);
    return 0;
}

krb5_error_code
encode_v4_ticket(void *buf, size_t len, const EncTicketPart *et,
		 const PrincipalName *service, size_t *size)
{
    krb5_storage *sp;
    krb5_error_code ret;
    char name[40], inst[40], realm[40];
    char sname[40], sinst[40];

    {
	krb5_principal princ;
	_krb5_principalname2krb5_principal(&princ,
					   *service,
					   et->crealm);
	ret = krb5_524_conv_principal(context, 
				      princ,
				      sname,
				      sinst,
				      realm);
	krb5_free_principal(context, princ);
	if(ret)
	    return ret;

	_krb5_principalname2krb5_principal(&princ,
					   et->cname,
					   et->crealm);
				     
	ret = krb5_524_conv_principal(context, 
				      princ,
				      name,
				      inst,
				      realm);
	krb5_free_principal(context, princ);
    }
    if(ret)
	return ret;

    sp = krb5_storage_emem();
    
    krb5_store_int8(sp, 0); /* flags */
    krb5_store_stringz(sp, name);
    krb5_store_stringz(sp, inst);
    krb5_store_stringz(sp, realm);
    {
	unsigned char tmp[4] = { 0, 0, 0, 0 };
	int i;
	if(et->caddr){
	    for(i = 0; i < et->caddr->len; i++)
		if(et->caddr->val[i].addr_type == AF_INET &&
		   et->caddr->val[i].address.length == 4){
		    memcpy(tmp, et->caddr->val[i].address.data, 4);
		    break;
		}
	}
	krb5_storage_write(sp, tmp, sizeof(tmp));
    }

    if((et->key.keytype != ETYPE_DES_CBC_MD5 &&
	et->key.keytype != ETYPE_DES_CBC_MD4 &&
	et->key.keytype != ETYPE_DES_CBC_CRC) || 
       et->key.keyvalue.length != 8)
	return -1;
    krb5_storage_write(sp, et->key.keyvalue.data, 8);
    
    {
	time_t start = et->starttime ? *et->starttime : et->authtime;
	krb5_store_int8(sp, krb_time_to_life(start, et->endtime));
	krb5_store_int32(sp, start);
    }

    krb5_store_stringz(sp, sname);
    krb5_store_stringz(sp, sinst);
    
    {
	krb5_data data;
	krb5_storage_to_data(sp, &data);
	krb5_storage_free(sp);
	*size = (data.length + 7) & ~7; /* pad to 8 bytes */
	if(*size > len)
	    return -1;
	memset((unsigned char*)buf - *size + 1, 0, *size);
	memcpy((unsigned char*)buf - *size + 1, data.data, data.length);
	krb5_data_free(&data);
    }
    return 0;
}

krb5_error_code
get_des_key(hdb_entry *principal, krb5_boolean is_server, 
	    krb5_boolean prefer_afs_key, Key **ret_key)
{
    Key *v5_key = NULL, *v4_key = NULL, *afs_key = NULL, *server_key = NULL;
    int i;
    krb5_enctype etypes[] = { ETYPE_DES_CBC_MD5, 
			      ETYPE_DES_CBC_MD4, 
			      ETYPE_DES_CBC_CRC };

    for(i = 0;
	i < sizeof(etypes)/sizeof(etypes[0])
	    && (v5_key == NULL || v4_key == NULL || 
		afs_key == NULL || server_key == NULL);
	++i) {
	Key *key = NULL;
	while(hdb_next_enctype2key(context, principal, etypes[i], &key) == 0) {
	    if(key->salt == NULL) {
		if(v5_key == NULL)
		    v5_key = key;
	    } else if(key->salt->type == hdb_pw_salt && 
		      key->salt->salt.length == 0) {
		if(v4_key == NULL)
		    v4_key = key;
	    } else if(key->salt->type == hdb_afs3_salt) {
		if(afs_key == NULL)
		    afs_key = key;
	    } else if(server_key == NULL)
		server_key = key;
	}
    }

    if(prefer_afs_key) {
	if(afs_key)
	    *ret_key = afs_key;
	else if(v4_key)
	    *ret_key = v4_key;
	else if(v5_key)
	    *ret_key = v5_key;
	else if(is_server && server_key)
	    *ret_key = server_key;
	else
	    return KERB_ERR_NULL_KEY;
    } else {
	if(v4_key)
	    *ret_key = v4_key;
	else if(afs_key)
	    *ret_key = afs_key;
	else  if(v5_key)
	    *ret_key = v5_key;
	else if(is_server && server_key)
	    *ret_key = server_key;
	else
	    return KERB_ERR_NULL_KEY;
    }

    if((*ret_key)->key.keyvalue.length == 0)
	return KERB_ERR_NULL_KEY;
    return 0;
}

@


1.6
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@@


1.5
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.45.2.1 2004/03/30 10:29:27 lha Exp $");
d38 1
a38 1
#ifdef KRB4
d58 2
a59 1
make_err_reply(krb5_data *reply, int code, const char *msg)
d61 2
a62 10
    KTEXT_ST er;

    /* name, instance and realm are not checked in most (all?)
       implementations; msg is also never used, but we send it anyway
       (for debugging purposes) */

    if(msg == NULL)
	msg = krb_get_err_text(code);
    cr_err_reply(&er, "", "", "", kdc_time, code, (char*)msg);
    krb5_data_copy(reply, er.dat, er.length);
d104 1
a104 1
#define RCHECK(X, L) if(X){make_err_reply(reply, KFAILURE, "Packet too short"); goto L;}
d129 1
a129 1
    time_t max_life, max_end, actual_end, issue_time;
d136 1
a136 1
	make_err_reply(reply, KDC_GEN_ERR, "function not enabled");
d144 1
a144 1
	make_err_reply(reply, KDC_PKT_VER, NULL);
d151 7
a157 1
    case AUTH_MSG_KDC_REQUEST:
d179 2
a180 1
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, NULL);
d187 2
a188 1
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, NULL);
d197 2
a198 1
	    make_err_reply(reply, KERB_ERR_NAME_EXP, NULL);
d214 2
a215 1
	    make_err_reply(reply, KERB_ERR_NULL_KEY, NULL);
d222 1
a222 1
	    make_err_reply(reply, KDC_NULL_KEY, 
d235 1
a235 1
	    make_err_reply(reply, KDC_NULL_KEY, 
d245 1
a245 1
	    make_err_reply(reply, KDC_NULL_KEY, 
d250 1
a250 1
	max_life = krb_life_to_time(0, life);
d258 46
a303 21
	{
	    KTEXT_ST cipher, ticket;
	    KTEXT r;
	    des_cblock session;

	    des_new_random_key((unsigned char *)&session);

	    krb_create_ticket(&ticket, 0, name, inst, v4_realm,
			      addr->sin_addr.s_addr, session, life, kdc_time, 
			      sname, sinst, skey->key.keyvalue.data);
	
	    create_ciph(&cipher, session, sname, sinst, v4_realm,
			life, server->kvno % 256, &ticket, kdc_time, 
			ckey->key.keyvalue.data);
	    memset(&session, 0, sizeof(session));
	    r = create_auth_reply(name, inst, realm, req_time, 0, 
				  client->pw_end ? *client->pw_end : 0, 
				  client->kvno % 256, &cipher);
	    krb5_data_copy(reply, r->dat, r->length);
	    memset(&cipher, 0, sizeof(cipher));
	    memset(&ticket, 0, sizeof(ticket));
d305 13
d320 1
d322 1
d326 2
a327 2
	KTEXT_ST auth;
	AUTH_DAT ad;
d332 1
d334 3
d345 1
a345 1
	    make_err_reply(reply, KFAILURE, 
d357 1
a357 1
	    make_err_reply(reply, KFAILURE, s);
d365 1
a365 1
	    make_err_reply(reply, KDC_AUTH_EXP,
d374 1
a374 1
	    make_err_reply(reply, KDC_NULL_KEY, 
d384 1
a384 2
	memset(&auth, 0, sizeof(auth));
	memcpy(&auth.dat, buf, pos);
a385 1
	krb_set_key(tkey->key.keyvalue.data, 0);
d387 4
a390 1
	krb_ignore_ip_address = !check_ticket_addresses;
d392 2
a393 2
	ret = krb_rd_req(&auth, "krbtgt", realm, 
			 addr->sin_addr.s_addr, &ad, 0);
d395 2
a396 2
	    kdc_log(0, "krb_rd_req: %s", krb_get_err_text(ret));
	    make_err_reply(reply, ret, NULL);
d409 3
d413 2
a414 2
	kdc_log(0, "TGS-REQ (krb4) %s.%s@@%s from %s for %s",
		ad.pname, ad.pinst, ad.prealm, from, server_name);
d418 1
a418 1
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
d425 1
a425 8
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't hop realms");
	    goto out2;
	}

	if (!enable_v4_cross_realm && strcmp(realm, v4_realm) != 0) {
	    kdc_log(0, "krb4 Cross-realm %s -> %s disabled", realm, v4_realm);
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
d432 1
a432 1
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
a436 1
#if 0
d438 9
a446 1
	if(ret){
d448 3
a450 5
	    s = kdc_log_msg(0, "Client not found in database: (krb4) "
			    "%s.%s@@%s: %s",
			    ad.pname, ad.pinst, ad.prealm,
			    krb5_get_err_text(context, ret));
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
d454 1
a454 2
#endif
	
d460 1
a460 1
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
d465 1
a465 1
	ret = check_flags (NULL, NULL,
d470 2
a471 1
	    make_err_reply(reply, KERB_ERR_NAME_EXP, NULL);
d479 1
a479 1
	    make_err_reply(reply, KDC_NULL_KEY, 
d484 6
a489 2
	max_end = krb_life_to_time(ad.time_sec, ad.life);
	max_end = min(max_end, krb_life_to_time(kdc_time, life));
d493 1
a493 1
	actual_end = krb_life_to_time(issue_time, life);
d497 1
a497 1
	    actual_end = krb_life_to_time(issue_time, life);
d505 52
a556 12
	    KTEXT_ST cipher, ticket;
	    KTEXT r;
	    des_cblock session;
	    des_new_random_key((unsigned char *)&session);
	    krb_create_ticket(&ticket, 0, ad.pname, ad.pinst, ad.prealm,
			      addr->sin_addr.s_addr, &session, life, 
			      issue_time,
			      sname, sinst, skey->key.keyvalue.data);
	    
	    create_ciph(&cipher, session, sname, sinst, v4_realm,
			life, server->kvno % 256, &ticket,
			issue_time, &ad.session);
d558 11
a568 8
	    memset(&session, 0, sizeof(session));
	    memset(ad.session, 0, sizeof(ad.session));

	    r = create_auth_reply(ad.pname, ad.pinst, ad.prealm, 
				  req_time, 0, 0, 0, &cipher);
	    krb5_data_copy(reply, r->dat, r->length);
	    memset(&cipher, 0, sizeof(cipher));
	    memset(&ticket, 0, sizeof(ticket));
d571 1
a577 1
    
d584 1
a584 1
	make_err_reply(reply, KFAILURE, "Unknown message type");
d586 1
a586 1
out:
a604 6
#else /* KRB4 */

#include <krb5-v4compat.h>

#endif /* KRB4 */

d616 3
a618 3
	principalname2krb5_principal(&princ,
				     *service,
				     et->crealm);
d628 3
a630 3
	principalname2krb5_principal(&princ,
				     et->cname,
				     et->crealm);
@


1.4
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.45 2003/03/17 05:37:55 assar Exp $");
d136 1
a136 1
    time_t max_life;
d435 16
a450 11
	max_life = krb_life_to_time(ad.time_sec, ad.life);
	max_life = min(max_life, krb_life_to_time(kdc_time, life));
	life = min(life, krb_time_to_life(kdc_time, max_life));
	max_life = krb_life_to_time(0, life);
#if 0
	if(client->max_life)
	    max_life = min(max_life, *client->max_life);
#endif
	if(server->max_life)
	    max_life = min(max_life, *server->max_life);
	
d457 2
a458 1
			      addr->sin_addr.s_addr, &session, life, kdc_time,
d463 2
a464 2
			kdc_time, &ad.session);

@


1.3
log
@Add a new option to disable krb4 cross-realm authentication, disabled by
default. This works around a recently found vulnerability in the krb4
protocol, see

	http://web.mit.edu/kerberos/www/advisories/MITKRB5-SA-2003-004-krb4.txt

Patch created by adopting the changes in heimdal-0.5.2, with invaluable help
provided by lha@@stacken.kth.se and janj@@stacken.kth.se.

ok beck@@ miod@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.38 2001/08/21 23:00:16 assar Exp $");
d81 1
a81 1
	return 0;
d87 1
a87 1
	return 0;
d92 1
a92 1
    return 1;
a110 61
krb5_error_code
get_des_key(hdb_entry *principal, krb5_boolean is_server, 
	    krb5_boolean prefer_afs_key, Key **ret_key)
{
    Key *v5_key = NULL, *v4_key = NULL, *afs_key = NULL, *server_key = NULL;
    int i;
    krb5_enctype etypes[] = { ETYPE_DES_CBC_MD5, 
			      ETYPE_DES_CBC_MD4, 
			      ETYPE_DES_CBC_CRC };

    for(i = 0;
	i < sizeof(etypes)/sizeof(etypes[0])
	    && (v5_key == NULL || v4_key == NULL || 
		afs_key == NULL || server_key == NULL);
	++i) {
	Key *key = NULL;
	while(hdb_next_enctype2key(context, principal, etypes[i], &key) == 0) {
	    if(key->salt == NULL) {
		if(v5_key == NULL)
		    v5_key = key;
	    } else if(key->salt->type == hdb_pw_salt && 
		      key->salt->salt.length == 0) {
		if(v4_key == NULL)
		    v4_key = key;
	    } else if(key->salt->type == hdb_afs3_salt) {
		if(afs_key == NULL)
		    afs_key = key;
	    } else if(server_key == NULL)
		server_key = key;
	}
    }

    if(prefer_afs_key) {
	if(afs_key)
	    *ret_key = afs_key;
	else if(v4_key)
	    *ret_key = v4_key;
	else if(v5_key)
	    *ret_key = v5_key;
	else if(is_server && server_key)
	    *ret_key = server_key;
	else
	    return KERB_ERR_NULL_KEY;
    } else {
	if(v4_key)
	    *ret_key = v4_key;
	else if(afs_key)
	    *ret_key = afs_key;
	else  if(v5_key)
	    *ret_key = v5_key;
	else if(is_server && server_key)
	    *ret_key = server_key;
	else
	    return KERB_ERR_NULL_KEY;
    }

    if((*ret_key)->key.keyvalue.length == 0)
	return KERB_ERR_NULL_KEY;
    return 0;
}

d150 1
a150 1
	kdc_log(0, "Protocol version mismatch (%d)", pvno);
d173 1
a173 1
	kdc_log(0, "AS-REQ %s from %s for %s",
d267 1
a267 1
			life, server->kvno, &ticket, kdc_time, 
d272 1
a272 1
				  client->kvno, &cipher);
d296 1
a296 1
	    kdc_log(0, "Converting krbtgt principal: %s", 
d307 1
a307 1
			    "found in database: krbtgt.%s@@%s: %s", 
d315 3
a317 3
	if(tgt->kvno != kvno){
	    kdc_log(0, "tgs-req with old kvno %d (current %d) for "
		    "krbtgt.%s@@%s", kvno, tgt->kvno, realm, v4_realm);
d325 1
a325 1
	    kdc_log(0, "no suitable DES key for krbtgt");
d335 1
a335 1
	pos = sp->seek(sp, ticket_len + req_len, SEEK_CUR);
d362 1
a362 1
	kdc_log(0, "TGS-REQ %s.%s@@%s from %s for %s",
d366 8
a373 1
	    kdc_log(0, "Can't hop realms %s -> %s", realm, ad.prealm);
d387 1
a387 1
	    kdc_log(0, "Bad request for changepw ticket");
d397 2
a398 1
	    s = kdc_log_msg(0, "Client not found in database: %s.%s@@%s: %s", 
d410 1
a410 1
	    s = kdc_log_msg(0, "Server not found in database: %s: %s",
d428 1
a428 1
	    kdc_log(0, "no suitable DES key for server");
d456 1
a456 1
			life, server->kvno, &ticket,
d479 1
a479 1
	kdc_log(0, "Unknown message type: %d from %s", 
d503 1
d505 1
a505 1
#define ETYPE_DES_PCBC 17 /* XXX */
d507 1
a507 21
krb5_error_code
encrypt_v4_ticket(void *buf, size_t len, des_cblock *key, EncryptedData *reply)
{
    des_key_schedule schedule;

    reply->etype = ETYPE_DES_PCBC;
    reply->kvno = NULL;
    reply->cipher.length = len;
    reply->cipher.data = malloc(len);
    if(len != 0 && reply->cipher.data == NULL)
	return ENOMEM;
    des_set_key(key, schedule);
    des_pcbc_encrypt(buf,
		     reply->cipher.data,
		     len,
		     schedule,
		     key,
		     DES_ENCRYPT);
    memset(schedule, 0, sizeof(schedule));
    return 0;
}
d563 1
a563 1
	sp->store(sp, tmp, sizeof(tmp));
d571 1
a571 1
    sp->store(sp, et->key.keyvalue.data, 8);
d596 61
a656 1
#endif /* KRB4 */
@


1.2
log
@-Wall -Werror sweep on i386.
@
text
@d433 7
@


1.2.2.1
log
@Errata #13 (hin):
A protocol flaw in the Kerberos 4 protocol allows an attacker to
impersonate any principal in a realm, if a Kerberos KDC is configured to
do cross-realm authentication.

Fix this by restricting the functionality of the protocol to prevent
responding to Kerberos 4 requests originating from foreign realms,
unless explicitely configured to do so by the user.
@
text
@a432 7
	if (!enable_v4_cross_realm && strcmp(realm, v4_realm) != 0) {
	    kdc_log(0, "krb4 Cross-realm %s -> %s disabled", realm, v4_realm);
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't hop realms");
	    goto out2;
	}

@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.36 2001/01/30 01:44:08 assar Exp $");
d112 2
a113 1
get_des_key(hdb_entry *principal, krb5_boolean prefer_afs_key, Key **ret_key)
d115 1
a115 1
    Key *v5_key = NULL, *v4_key = NULL, *afs_key = NULL;
d123 2
a124 1
	    && (v5_key == NULL || v4_key == NULL || afs_key == NULL);
d138 2
a139 1
	    }
d150 2
d161 2
d277 1
a277 1
	ret = get_des_key(client, FALSE, &ckey);
d279 1
a279 2
	    kdc_log(0, "%s", krb5_get_err_text(context, ret));
	    /* XXX */
d281 1
a281 1
			   "No DES key in database (client)");
d299 1
a299 1
	ret = get_des_key(server, FALSE, &skey);
d301 1
a301 1
	    kdc_log(0, "%s", krb5_get_err_text(context, ret));
d304 1
a304 1
			   "No DES key in database (server)");
d321 1
a321 1
	    des_new_random_key(&session);
d384 1
a384 1
	ret = get_des_key(tgt, FALSE, &tkey);
d386 1
a386 1
	    kdc_log(0, "%s", krb5_get_err_text(context, ret));
d389 1
a389 1
			   "No DES key in database (krbtgt)");
d472 1
a472 1
	ret = get_des_key(server, FALSE, &skey);
d474 1
a474 1
	    kdc_log(0, "%s", krb5_get_err_text(context, ret));
d477 1
a477 1
			   "No DES key in database (server)");
d496 1
a496 1
	    des_new_random_key(&session);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.38 2001/08/21 23:00:16 assar Exp $");
d112 1
a112 2
get_des_key(hdb_entry *principal, krb5_boolean is_server, 
	    krb5_boolean prefer_afs_key, Key **ret_key)
d114 1
a114 1
    Key *v5_key = NULL, *v4_key = NULL, *afs_key = NULL, *server_key = NULL;
d122 1
a122 2
	    && (v5_key == NULL || v4_key == NULL || 
		afs_key == NULL || server_key == NULL);
d136 1
a136 2
	    } else if(server_key == NULL)
		server_key = key;
a146 2
	else if(is_server && server_key)
	    *ret_key = server_key;
a155 2
	else if(is_server && server_key)
	    *ret_key = server_key;
d270 1
a270 1
	ret = get_des_key(client, FALSE, FALSE, &ckey);
d272 2
a273 1
	    kdc_log(0, "no suitable DES key for client");
d275 1
a275 1
			   "no suitable DES key for client");
d293 1
a293 1
	ret = get_des_key(server, TRUE, FALSE, &skey);
d295 1
a295 1
	    kdc_log(0, "no suitable DES key for server");
d298 1
a298 1
			   "no suitable DES key for server");
d378 1
a378 1
	ret = get_des_key(tgt, TRUE, FALSE, &tkey);
d380 1
a380 1
	    kdc_log(0, "no suitable DES key for krbtgt");
d383 1
a383 1
			   "no suitable DES key for krbtgt");
d466 1
a466 1
	ret = get_des_key(server, TRUE, FALSE, &skey);
d468 1
a468 1
	    kdc_log(0, "no suitable DES key for server");
d471 1
a471 1
			   "no suitable DES key for server");
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.45 2003/03/17 05:37:55 assar Exp $");
d81 1
a81 1
	return FALSE;
d87 1
a87 1
	return FALSE;
d92 1
a92 1
    return TRUE;
d111 61
d211 1
a211 1
	kdc_log(0, "Protocol version mismatch (krb4) (%d)", pvno);
d234 1
a234 1
	kdc_log(0, "AS-REQ (krb4) %s from %s for %s",
d328 1
a328 1
			life, server->kvno % 256, &ticket, kdc_time, 
d333 1
a333 1
				  client->kvno % 256, &cipher);
d357 1
a357 1
	    kdc_log(0, "Converting krbtgt principal (krb4): %s", 
d368 1
a368 1
			    "found in database (krb4): krbtgt.%s@@%s: %s", 
d376 3
a378 3
	if(tgt->kvno % 256 != kvno){
	    kdc_log(0, "tgs-req (krb4) with old kvno %d (current %d) for "
		    "krbtgt.%s@@%s", kvno, tgt->kvno % 256, realm, v4_realm);
d386 1
a386 1
	    kdc_log(0, "no suitable DES key for krbtgt (krb4)");
d396 1
a396 1
	pos = krb5_storage_seek(sp, ticket_len + req_len, SEEK_CUR);
d423 1
a423 1
	kdc_log(0, "TGS-REQ (krb4) %s.%s@@%s from %s for %s",
d427 1
a427 8
	    kdc_log(0, "Can't hop realms (krb4) %s -> %s", realm, ad.prealm);
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't hop realms");
	    goto out2;
	}

	if (!enable_v4_cross_realm && strcmp(realm, v4_realm) != 0) {
	    kdc_log(0, "krb4 Cross-realm %s -> %s disabled", realm, v4_realm);
d434 1
a434 1
	    kdc_log(0, "Bad request for changepw ticket (krb4)");
d444 1
a444 2
	    s = kdc_log_msg(0, "Client not found in database: (krb4) "
			    "%s.%s@@%s: %s",
d456 1
a456 1
	    s = kdc_log_msg(0, "Server not found in database (krb4): %s: %s",
d474 1
a474 1
	    kdc_log(0, "no suitable DES key for server (krb4)");
a496 1

d502 1
a502 1
			life, server->kvno % 256, &ticket,
d525 1
a525 1
	kdc_log(0, "Unknown message type (krb4): %d from %s", 
a548 1
#else /* KRB4 */
d550 1
a550 1
#include <krb5-v4compat.h>
d552 21
a572 1
#endif /* KRB4 */
d628 1
a628 1
	krb5_storage_write(sp, tmp, sizeof(tmp));
d636 1
a636 1
    krb5_storage_write(sp, et->key.keyvalue.data, 8);
d661 1
a661 61
krb5_error_code
get_des_key(hdb_entry *principal, krb5_boolean is_server, 
	    krb5_boolean prefer_afs_key, Key **ret_key)
{
    Key *v5_key = NULL, *v4_key = NULL, *afs_key = NULL, *server_key = NULL;
    int i;
    krb5_enctype etypes[] = { ETYPE_DES_CBC_MD5, 
			      ETYPE_DES_CBC_MD4, 
			      ETYPE_DES_CBC_CRC };

    for(i = 0;
	i < sizeof(etypes)/sizeof(etypes[0])
	    && (v5_key == NULL || v4_key == NULL || 
		afs_key == NULL || server_key == NULL);
	++i) {
	Key *key = NULL;
	while(hdb_next_enctype2key(context, principal, etypes[i], &key) == 0) {
	    if(key->salt == NULL) {
		if(v5_key == NULL)
		    v5_key = key;
	    } else if(key->salt->type == hdb_pw_salt && 
		      key->salt->salt.length == 0) {
		if(v4_key == NULL)
		    v4_key = key;
	    } else if(key->salt->type == hdb_afs3_salt) {
		if(afs_key == NULL)
		    afs_key = key;
	    } else if(server_key == NULL)
		server_key = key;
	}
    }

    if(prefer_afs_key) {
	if(afs_key)
	    *ret_key = afs_key;
	else if(v4_key)
	    *ret_key = v4_key;
	else if(v5_key)
	    *ret_key = v5_key;
	else if(is_server && server_key)
	    *ret_key = server_key;
	else
	    return KERB_ERR_NULL_KEY;
    } else {
	if(v4_key)
	    *ret_key = v4_key;
	else if(afs_key)
	    *ret_key = afs_key;
	else  if(v5_key)
	    *ret_key = v5_key;
	else if(is_server && server_key)
	    *ret_key = server_key;
	else
	    return KERB_ERR_NULL_KEY;
    }

    if((*ret_key)->key.keyvalue.length == 0)
	return KERB_ERR_NULL_KEY;
    return 0;
}

@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: kerberos4.c,v 1.45.2.1 2004/03/30 10:29:27 lha Exp $");
d136 1
a136 1
    time_t max_life, max_end, actual_end, issue_time;
d428 11
a438 16
	max_end = krb_life_to_time(ad.time_sec, ad.life);
	max_end = min(max_end, krb_life_to_time(kdc_time, life));
	life = min(life, krb_time_to_life(kdc_time, max_end));
	
	issue_time = kdc_time;
	actual_end = krb_life_to_time(issue_time, life);
	while (actual_end > max_end && life > 1) {
	    /* move them into the next earlier lifetime bracket */
	    life--;
	    actual_end = krb_life_to_time(issue_time, life);
	}
	if (actual_end > max_end) {
	    /* if life <= 1 and it's still too long, backdate the ticket */
	    issue_time -= actual_end - max_end;
	}

d446 1
a446 2
			      addr->sin_addr.s_addr, &session, life, 
			      issue_time,
d451 2
a452 2
			issue_time, &ad.session);
	    
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
d36 1
a36 1
#include <krb5-v4compat.h>
d38 1
a38 1
RCSID("$KTH: kerberos4.c,v 1.52 2005/04/23 20:11:55 lha Exp $");
d58 1
a58 2
make_err_reply(krb5_context context, krb5_data *reply,
	       int code, const char *msg)
d60 10
a69 2
    _krb5_krb_cr_err_reply(context, "", "", "", 
			   kdc_time, code, msg, reply);
d111 1
a111 1
#define RCHECK(X, L) if(X){make_err_reply(context, reply, KFAILURE, "Packet too short"); goto L;}
d136 1
a136 1
    time_t max_life;
d143 1
a143 1
	make_err_reply(context, reply, KDC_GEN_ERR, "function not enabled");
d151 1
a151 1
	make_err_reply(context, reply, KDC_PKT_VER, "protocol mismatch");
d158 1
a158 7
    case AUTH_MSG_KDC_REQUEST: {
	krb5_data ticket, cipher;
	krb5_keyblock session;
	
	krb5_data_zero(&ticket);
	krb5_data_zero(&cipher);

d180 1
a180 2
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN,
			   "principal unknown");
d187 1
a187 2
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN,
			   "principal unknown");
d196 1
a196 2
	    make_err_reply(context, reply, KERB_ERR_NAME_EXP,
			   "operation not allowed");
d212 1
a212 2
	    make_err_reply(context, reply, KERB_ERR_NULL_KEY,
			   "preauth required");
d219 1
a219 1
	    make_err_reply(context, reply, KDC_NULL_KEY, 
d232 1
a232 1
	    make_err_reply(context, reply, KDC_NULL_KEY, 
d242 1
a242 1
	    make_err_reply(context, reply, KDC_NULL_KEY, 
d247 1
a247 1
	max_life = _krb5_krb_life_to_time(0, life);
d255 21
a275 7
	ret = krb5_generate_random_keyblock(context,
					    ETYPE_DES_PCBC_NONE,
					    &session);
	if (ret) {
	    make_err_reply(context, reply, KFAILURE,
			   "Not enough random i KDC");
	    goto out1;
a276 52
	
	ret = _krb5_krb_create_ticket(context,
				      0,
				      name,
				      inst,
				      v4_realm,
				      addr->sin_addr.s_addr,
				      &session,
				      life,
				      kdc_time,
				      sname,
				      sinst,
				      &skey->key,
				      &ticket);
	if (ret) {
	    krb5_free_keyblock_contents(context, &session);
	    make_err_reply(context, reply, KFAILURE,
			   "failed to create v4 ticket");
	    goto out1;
	}

	ret = _krb5_krb_create_ciph(context,
				    &session,
				    sname,
				    sinst,
				    v4_realm,
				    life,
				    server->kvno % 255,
				    &ticket,
				    kdc_time,
				    &ckey->key,
				    &cipher);
	krb5_free_keyblock_contents(context, &session);
	krb5_data_free(&ticket);
	if (ret) {
	    make_err_reply(context, reply, KFAILURE, 
			   "Failed to create v4 cipher");
	    goto out1;
	}
	
	ret = _krb5_krb_create_auth_reply(context,
					  name,
					  inst,
					  realm,
					  req_time,
					  0,
					  client->pw_end ? *client->pw_end : 0,
					  client->kvno % 256,
					  &cipher,
					  reply);
	krb5_data_free(&cipher);

a278 1
    }
a279 1
	struct _krb5_krb_auth_data ad;
d283 2
a284 2
	krb5_data auth;
	int32_t address;
a288 1
	time_t max_end, actual_end, issue_time;
a289 3
	memset(&ad, 0, sizeof(ad));
	krb5_data_zero(&auth);

d298 1
a298 1
	    make_err_reply(context, reply, KFAILURE, 
d310 1
a310 1
	    make_err_reply(context, reply, KFAILURE, s);
d318 1
a318 1
	    make_err_reply(context, reply, KDC_AUTH_EXP,
d327 1
a327 1
	    make_err_reply(context, reply, KDC_NULL_KEY, 
d337 2
a338 1
	auth.data = buf;
d340 1
d342 1
a342 4
	if (check_ticket_addresses)
	    address = addr->sin_addr.s_addr;
	else
	    address = 0;
d344 2
a345 2
	ret = _krb5_krb_rd_req(context, &auth, "krbtgt", realm, v4_realm,
			       address, &tkey->key, &ad);
d347 2
a348 2
	    kdc_log(0, "krb_rd_req: %d", ret);
	    make_err_reply(context, reply, ret, "failed to parse request");
a360 3
	snprintf (client_name, sizeof(client_name),
		  "%s.%s@@%s",
		  ad.pname, ad.pinst, ad.prealm);
d362 2
a363 2
	kdc_log(0, "TGS-REQ (krb4) %s from %s for %s",
		client_name, from, server_name);
d367 1
a367 1
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
d374 1
a374 1
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
d381 1
a381 1
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
d386 1
d388 1
a388 1
	if(ret && ret != HDB_ERR_NOENTRY) {
d390 5
a394 3
	    s = kdc_log_msg(0, "Client not found in database: (krb4) %s: %s",
			    client_name, krb5_get_err_text(context, ret));
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
d398 2
a399 9
	if (client == NULL && strcmp(ad.prealm, v4_realm) == 0) {
	    char *s;
	    s = kdc_log_msg(0, "Local client not found in database: (krb4) "
			    "%s", client_name);
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
	    free(s);
	    goto out2;
	}

d405 1
a405 1
	    make_err_reply(context, reply, KERB_ERR_PRINCIPAL_UNKNOWN, s);
d410 1
a410 1
	ret = check_flags (client, client_name,
d415 1
a415 2
	    make_err_reply(context, reply, KERB_ERR_NAME_EXP,
			   "operation not allowed");
d423 1
a423 1
	    make_err_reply(context, reply, KDC_NULL_KEY, 
d428 2
a429 6
	max_end = _krb5_krb_life_to_time(ad.time_sec, ad.life);
	max_end = min(max_end, _krb5_krb_life_to_time(kdc_time, life));
	if(server->max_life)
	    max_end = min(max_end, kdc_time + *server->max_life);
	if(client && client->max_life)
	    max_end = min(max_end, kdc_time + *client->max_life);
d433 1
a433 1
	actual_end = _krb5_krb_life_to_time(issue_time, life);
d437 1
a437 1
	    actual_end = _krb5_krb_life_to_time(issue_time, life);
d445 16
a460 5
	    krb5_data ticket, cipher;
	    krb5_keyblock session;

	    krb5_data_zero(&ticket);
	    krb5_data_zero(&cipher);
d462 5
a466 58
	    ret = krb5_generate_random_keyblock(context,
						ETYPE_DES_PCBC_NONE,
						&session);
	    if (ret) {
		make_err_reply(context, reply, KFAILURE,
			       "Not enough random i KDC");
		goto out2;
	    }
	
	    ret = _krb5_krb_create_ticket(context,
					  0,
					  ad.pname,
					  ad.pinst,
					  ad.prealm,
					  addr->sin_addr.s_addr,
					  &session,
					  life,
					  issue_time,
					  sname,
					  sinst,
					  &skey->key,
					  &ticket);
	    if (ret) {
		krb5_free_keyblock_contents(context, &session);
		make_err_reply(context, reply, KFAILURE,
			       "failed to create v4 ticket");
		goto out2;
	    }

	    ret = _krb5_krb_create_ciph(context,
					&session,
					sname,
					sinst,
					v4_realm,
					life,
					server->kvno % 255,
					&ticket,
					issue_time,
					&ad.session,
					&cipher);
	    krb5_free_keyblock_contents(context, &session);
	    if (ret) {
		make_err_reply(context, reply, KFAILURE,
			       "failed to create v4 cipher");
		goto out2;
	    }
	    
	    ret = _krb5_krb_create_auth_reply(context,
					      ad.pname,
					      ad.pinst,
					      ad.prealm,
					      req_time,
					      0,
					      0,
					      0,
					      &cipher,
					      reply);
	    krb5_data_free(&cipher);
a468 1
	_krb5_krb_free_auth_data(context, &ad);
d475 1
d482 1
a482 1
	make_err_reply(context, reply, KFAILURE, "Unknown message type");
d484 1
a484 1
 out:
d503 6
d520 3
a522 3
	_krb5_principalname2krb5_principal(&princ,
					   *service,
					   et->crealm);
d532 3
a534 3
	_krb5_principalname2krb5_principal(&princ,
					   et->cname,
					   et->crealm);
@


1.1.1.2.2.1
log
@Errata #026 (hin):
A protocol flaw in the Kerberos 4 protocol allows an attacker to
impersonate any principal in a realm, if a Kerberos KDC is configured to
do cross-realm authentication.

Fix this by restricting the functionality of the protocol to prevent
responding to Kerberos 4 requests originating from foreign realms,
unless explicitely configured to do so by the user.
@
text
@a432 7
	if (!enable_v4_cross_realm && strcmp(realm, v4_realm) != 0) {
	    kdc_log(0, "krb4 Cross-realm %s -> %s disabled", realm, v4_realm);
	    make_err_reply(reply, KERB_ERR_PRINCIPAL_UNKNOWN, 
			   "Can't hop realms");
	    goto out2;
	}

@


