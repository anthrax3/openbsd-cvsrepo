head	1.5;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.14
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.12
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.6.0.16
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.12
	OPENBSD_4_5_BASE:1.1.1.6
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.6
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.4;

1.4
date	2014.04.18.09.47.35;	author ajacoutot;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.10.18.36.34;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.30;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.30;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.21.47;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.54.50;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.31;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.32;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.32.43;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kdc_locl.h"

/* Should we enable the HTTP hack? */
int enable_http = -1;

/* Log over requests to the KDC */
const char *request_log;

/* A string describing on what ports to listen */
const char *port_str;

krb5_addresses explicit_addresses;

size_t max_request_udp;
size_t max_request_tcp;

/*
 * a tuple describing on what to listen
 */

struct port_desc{
    int family;
    int type;
    int port;
};

/* the current ones */

static struct port_desc *ports;
static size_t num_ports;

/*
 * add `family, port, protocol' to the list with duplicate suppresion.
 */

static void
add_port(krb5_context context,
	 int family, int port, const char *protocol)
{
    int type;
    size_t i;

    if(strcmp(protocol, "udp") == 0)
	type = SOCK_DGRAM;
    else if(strcmp(protocol, "tcp") == 0)
	type = SOCK_STREAM;
    else
	return;
    for(i = 0; i < num_ports; i++){
	if(ports[i].type == type
	   && ports[i].port == port
	   && ports[i].family == family)
	    return;
    }
    ports = realloc(ports, (num_ports + 1) * sizeof(*ports));
    if (ports == NULL)
	krb5_err (context, 1, errno, "realloc");
    ports[num_ports].family = family;
    ports[num_ports].type   = type;
    ports[num_ports].port   = port;
    num_ports++;
}

/*
 * add a triple but with service -> port lookup
 * (this prints warnings for stuff that does not exist)
 */

static void
add_port_service(krb5_context context,
		 int family, const char *service, int port,
		 const char *protocol)
{
    port = krb5_getportbyname (context, service, protocol, port);
    add_port (context, family, port, protocol);
}

/*
 * add the port with service -> port lookup or string -> number
 * (no warning is printed)
 */

static void
add_port_string (krb5_context context,
		 int family, const char *str, const char *protocol)
{
    struct servent *sp;
    int port;

    sp = roken_getservbyname (str, protocol);
    if (sp != NULL) {
	port = sp->s_port;
    } else {
	char *end;

	port = htons(strtol(str, &end, 0));
	if (end == str)
	    return;
    }
    add_port (context, family, port, protocol);
}

/*
 * add the standard collection of ports for `family'
 */

static void
add_standard_ports (krb5_context context,
		    krb5_kdc_configuration *config,
		    int family)
{
    add_port_service(context, family, "kerberos", 88, "udp");
    add_port_service(context, family, "kerberos", 88, "tcp");
    add_port_service(context, family, "kerberos-sec", 88, "udp");
    add_port_service(context, family, "kerberos-sec", 88, "tcp");
    if(enable_http)
	add_port_service(context, family, "http", 80, "tcp");
    if(config->enable_kx509) {
	add_port_service(context, family, "kca_service", 9878, "udp");
	add_port_service(context, family, "kca_service", 9878, "tcp");
    }

}

/*
 * parse the set of space-delimited ports in `str' and add them.
 * "+" => all the standard ones
 * otherwise it's port|service[/protocol]
 */

static void
parse_ports(krb5_context context,
	    krb5_kdc_configuration *config,
	    const char *str)
{
    char *pos = NULL;
    char *p;
    char *str_copy = strdup (str);

    p = strtok_r(str_copy, " \t", &pos);
    while(p != NULL) {
	if(strcmp(p, "+") == 0) {
#ifdef HAVE_IPV6
	    add_standard_ports(context, config, AF_INET6);
#endif
	    add_standard_ports(context, config, AF_INET);
	} else {
	    char *q = strchr(p, '/');
	    if(q){
		*q++ = 0;
#ifdef HAVE_IPV6
		add_port_string(context, AF_INET6, p, q);
#endif
		add_port_string(context, AF_INET, p, q);
	    }else {
#ifdef HAVE_IPV6
		add_port_string(context, AF_INET6, p, "udp");
		add_port_string(context, AF_INET6, p, "tcp");
#endif
		add_port_string(context, AF_INET, p, "udp");
		add_port_string(context, AF_INET, p, "tcp");
	    }
	}

	p = strtok_r(NULL, " \t", &pos);
    }
    free (str_copy);
}

/*
 * every socket we listen on
 */

struct descr {
    krb5_socket_t s;
    int type;
    int port;
    unsigned char *buf;
    size_t size;
    size_t len;
    time_t timeout;
    struct sockaddr_storage __ss;
    struct sockaddr *sa;
    socklen_t sock_len;
    char addr_string[128];
};

static void
init_descr(struct descr *d)
{
    memset(d, 0, sizeof(*d));
    d->sa = (struct sockaddr *)&d->__ss;
    d->s = rk_INVALID_SOCKET;
}

/*
 * re-initialize all `n' ->sa in `d'.
 */

static void
reinit_descrs (struct descr *d, int n)
{
    int i;

    for (i = 0; i < n; ++i)
	d[i].sa = (struct sockaddr *)&d[i].__ss;
}

/*
 * Create the socket (family, type, port) in `d'
 */

static void
init_socket(krb5_context context,
	    krb5_kdc_configuration *config,
	    struct descr *d, krb5_address *a, int family, int type, int port)
{
    krb5_error_code ret;
    struct sockaddr_storage __ss;
    struct sockaddr *sa = (struct sockaddr *)&__ss;
    krb5_socklen_t sa_size = sizeof(__ss);

    init_descr (d);

    ret = krb5_addr2sockaddr (context, a, sa, &sa_size, port);
    if (ret) {
	krb5_warn(context, ret, "krb5_addr2sockaddr");
	rk_closesocket(d->s);
	d->s = rk_INVALID_SOCKET;
	return;
    }

    if (sa->sa_family != family)
	return;

    d->s = socket(family, type, 0);
    if(rk_IS_BAD_SOCKET(d->s)){
	krb5_warn(context, errno, "socket(%d, %d, 0)", family, type);
	d->s = rk_INVALID_SOCKET;
	return;
    }
#if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_REUSEADDR)
    {
	int one = 1;
	setsockopt(d->s, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));
    }
#endif
    d->type = type;
    d->port = port;

    if(rk_IS_SOCKET_ERROR(bind(d->s, sa, sa_size))){
	char a_str[256];
	size_t len;

	krb5_print_address (a, a_str, sizeof(a_str), &len);
	krb5_warn(context, errno, "bind %s/%d", a_str, ntohs(port));
	rk_closesocket(d->s);
	d->s = rk_INVALID_SOCKET;
	return;
    }
    if(type == SOCK_STREAM && rk_IS_SOCKET_ERROR(listen(d->s, SOMAXCONN))){
	char a_str[256];
	size_t len;

	krb5_print_address (a, a_str, sizeof(a_str), &len);
	krb5_warn(context, errno, "listen %s/%d", a_str, ntohs(port));
	rk_closesocket(d->s);
	d->s = rk_INVALID_SOCKET;
	return;
    }
}

/*
 * Allocate descriptors for all the sockets that we should listen on
 * and return the number of them.
 */

static int
init_sockets(krb5_context context,
	     krb5_kdc_configuration *config,
	     struct descr **desc)
{
    krb5_error_code ret;
    size_t i, j;
    struct descr *d;
    int num = 0;
    krb5_addresses addresses;

    if (explicit_addresses.len) {
	addresses = explicit_addresses;
    } else {
	ret = krb5_get_all_server_addrs (context, &addresses);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_get_all_server_addrs");
    }
    parse_ports(context, config, port_str);
    d = malloc(addresses.len * num_ports * sizeof(*d));
    if (d == NULL)
	krb5_errx(context, 1, "malloc(%lu) failed",
		  (unsigned long)num_ports * sizeof(*d));

    for (i = 0; i < num_ports; i++){
	for (j = 0; j < addresses.len; ++j) {
	    init_socket(context, config, &d[num], &addresses.val[j],
			ports[i].family, ports[i].type, ports[i].port);
	    if(d[num].s != rk_INVALID_SOCKET){
		char a_str[80];
		size_t len;

		krb5_print_address (&addresses.val[j], a_str,
				    sizeof(a_str), &len);

		kdc_log(context, config, 5, "listening on %s port %u/%s",
			a_str,
			ntohs(ports[i].port),
			(ports[i].type == SOCK_STREAM) ? "tcp" : "udp");
		/* XXX */
		num++;
	    }
	}
    }
    krb5_free_addresses (context, &addresses);
    d = realloc(d, num * sizeof(*d));
    if (d == NULL && num != 0)
	krb5_errx(context, 1, "realloc(%lu) failed",
		  (unsigned long)num * sizeof(*d));
    reinit_descrs (d, num);
    *desc = d;
    return num;
}

/*
 *
 */

static const char *
descr_type(struct descr *d)
{
    if (d->type == SOCK_DGRAM)
	return "udp";
    else if (d->type == SOCK_STREAM)
	return "tcp";
    return "unknown";
}

static void
addr_to_string(krb5_context context,
	       struct sockaddr *addr, size_t addr_len, char *str, size_t len)
{
    krb5_address a;
    if(krb5_sockaddr2address(context, addr, &a) == 0) {
	if(krb5_print_address(&a, str, len, &len) == 0) {
	    krb5_free_address(context, &a);
	    return;
	}
	krb5_free_address(context, &a);
    }
    snprintf(str, len, "<family=%d>", addr->sa_family);
}

/*
 *
 */

static void
send_reply(krb5_context context,
	   krb5_kdc_configuration *config,
	   krb5_boolean prependlength,
	   struct descr *d,
	   krb5_data *reply)
{
    kdc_log(context, config, 5,
	    "sending %lu bytes to %s", (unsigned long)reply->length,
	    d->addr_string);
    if(prependlength){
	unsigned char l[4];
	l[0] = (reply->length >> 24) & 0xff;
	l[1] = (reply->length >> 16) & 0xff;
	l[2] = (reply->length >> 8) & 0xff;
	l[3] = reply->length & 0xff;
	if(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {
	    kdc_log (context, config,
		     0, "sendto(%s): %s", d->addr_string,
		     strerror(rk_SOCK_ERRNO));
	    return;
	}
    }
    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {
	kdc_log (context, config, 0, "sendto(%s): %s", d->addr_string,
		 strerror(rk_SOCK_ERRNO));
	return;
    }
}

/*
 * Handle the request in `buf, len' to socket `d'
 */

static void
do_request(krb5_context context,
	   krb5_kdc_configuration *config,
	   void *buf, size_t len, krb5_boolean prependlength,
	   struct descr *d)
{
    krb5_error_code ret;
    krb5_data reply;
    int datagram_reply = (d->type == SOCK_DGRAM);

    krb5_kdc_update_time(NULL);

    krb5_data_zero(&reply);
    ret = krb5_kdc_process_request(context, config,
				   buf, len, &reply, &prependlength,
				   d->addr_string, d->sa,
				   datagram_reply);
    if(request_log)
	krb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);
    if(reply.length){
	send_reply(context, config, prependlength, d, &reply);
	krb5_data_free(&reply);
    }
    if(ret)
	kdc_log(context, config, 0,
		"Failed processing %lu byte request from %s",
		(unsigned long)len, d->addr_string);
}

/*
 * Handle incoming data to the UDP socket in `d'
 */

static void
handle_udp(krb5_context context,
	   krb5_kdc_configuration *config,
	   struct descr *d)
{
    unsigned char *buf;
    ssize_t n;

    buf = malloc(max_request_udp);
    if(buf == NULL){
	kdc_log(context, config, 0, "Failed to allocate %lu bytes", (unsigned long)max_request_udp);
	return;
    }

    d->sock_len = sizeof(d->__ss);
    n = recvfrom(d->s, buf, max_request_udp, 0, d->sa, &d->sock_len);
    if(rk_IS_SOCKET_ERROR(n))
	krb5_warn(context, rk_SOCK_ERRNO, "recvfrom");
    else {
	addr_to_string (context, d->sa, d->sock_len,
			d->addr_string, sizeof(d->addr_string));
	if ((size_t)n == max_request_udp) {
	    krb5_data data;
	    krb5_warn(context, errno,
		      "recvfrom: truncated packet from %s, asking for TCP",
		      d->addr_string);
	    krb5_mk_error(context,
			  KRB5KRB_ERR_RESPONSE_TOO_BIG,
			  NULL,
			  NULL,
			  NULL,
			  NULL,
			  NULL,
			  NULL,
			  &data);
	    send_reply(context, config, FALSE, d, &data);
	    krb5_data_free(&data);
	} else {
	    do_request(context, config, buf, n, FALSE, d);
	}
    }
    free (buf);
}

static void
clear_descr(struct descr *d)
{
    if(d->buf)
	memset(d->buf, 0, d->size);
    d->len = 0;
    if(d->s != rk_INVALID_SOCKET)
	rk_closesocket(d->s);
    d->s = rk_INVALID_SOCKET;
}


/* remove HTTP %-quoting from buf */
static int
de_http(char *buf)
{
    unsigned char *p, *q;
    for(p = q = (unsigned char *)buf; *p; p++, q++) {
	if(*p == '%' && isxdigit(p[1]) && isxdigit(p[2])) {
	    unsigned int x;
	    if(sscanf((char *)p + 1, "%2x", &x) != 1)
		return -1;
	    *q = x;
	    p += 2;
	} else
	    *q = *p;
    }
    *q = '\0';
    return 0;
}

#define TCP_TIMEOUT 4

/*
 * accept a new TCP connection on `d[parent]' and store it in `d[child]'
 */

static void
add_new_tcp (krb5_context context,
	     krb5_kdc_configuration *config,
	     struct descr *d, int parent, int child)
{
    krb5_socket_t s;

    if (child == -1)
	return;

    d[child].sock_len = sizeof(d[child].__ss);
    s = accept(d[parent].s, d[child].sa, &d[child].sock_len);
    if(rk_IS_BAD_SOCKET(s)) {
	krb5_warn(context, rk_SOCK_ERRNO, "accept");
	return;
    }

#ifdef FD_SETSIZE
    if (s >= FD_SETSIZE) {
	krb5_warnx(context, "socket FD too large");
	rk_closesocket (s);
	return;
    }
#endif

    d[child].s = s;
    d[child].timeout = time(NULL) + TCP_TIMEOUT;
    d[child].type = SOCK_STREAM;
    addr_to_string (context,
		    d[child].sa, d[child].sock_len,
		    d[child].addr_string, sizeof(d[child].addr_string));
}

/*
 * Grow `d' to handle at least `n'.
 * Return != 0 if fails
 */

static int
grow_descr (krb5_context context,
	    krb5_kdc_configuration *config,
	    struct descr *d, size_t n)
{
    if (d->size - d->len < n) {
	unsigned char *tmp;
	size_t grow;

	grow = max(1024, d->len + n);
	if (d->size + grow > max_request_tcp) {
	    kdc_log(context, config, 0, "Request exceeds max request size (%lu bytes).",
		    (unsigned long)d->size + grow);
	    clear_descr(d);
	    return -1;
	}
	tmp = realloc (d->buf, d->size + grow);
	if (tmp == NULL) {
	    kdc_log(context, config, 0, "Failed to re-allocate %lu bytes.",
		    (unsigned long)d->size + grow);
	    clear_descr(d);
	    return -1;
	}
	d->size += grow;
	d->buf = tmp;
    }
    return 0;
}

/*
 * Try to handle the TCP data at `d->buf, d->len'.
 * Return -1 if failed, 0 if succesful, and 1 if data is complete.
 */

static int
handle_vanilla_tcp (krb5_context context,
		    krb5_kdc_configuration *config,
		    struct descr *d)
{
    krb5_storage *sp;
    uint32_t len;

    sp = krb5_storage_from_mem(d->buf, d->len);
    if (sp == NULL) {
	kdc_log (context, config, 0, "krb5_storage_from_mem failed");
	return -1;
    }
    krb5_ret_uint32(sp, &len);
    krb5_storage_free(sp);
    if(d->len - 4 >= len) {
	memmove(d->buf, d->buf + 4, d->len - 4);
	d->len -= 4;
	return 1;
    }
    return 0;
}

/*
 * Try to handle the TCP/HTTP data at `d->buf, d->len'.
 * Return -1 if failed, 0 if succesful, and 1 if data is complete.
 */

static int
handle_http_tcp (krb5_context context,
		 krb5_kdc_configuration *config,
		 struct descr *d)
{
    char *s, *p, *t;
    void *data;
    char *proto;
    int len;

    s = (char *)d->buf;

    /* If its a multi line query, truncate off the first line */
    p = strstr(s, "\r\n");
    if (p)
	*p = 0;

    p = NULL;
    t = strtok_r(s, " \t", &p);
    if (t == NULL) {
	kdc_log(context, config, 0,
		"Missing HTTP operand (GET) request from %s", d->addr_string);
	return -1;
    }

    t = strtok_r(NULL, " \t", &p);
    if(t == NULL) {
	kdc_log(context, config, 0,
		"Missing HTTP GET data in request from %s", d->addr_string);
	return -1;
    }

    data = malloc(strlen(t));
    if (data == NULL) {
	kdc_log(context, config, 0, "Failed to allocate %lu bytes",
		(unsigned long)strlen(t));
	return -1;
    }
    if(*t == '/')
	t++;
    if(de_http(t) != 0) {
	kdc_log(context, config, 0, "Malformed HTTP request from %s", d->addr_string);
	kdc_log(context, config, 5, "HTTP request: %s", t);
	free(data);
	return -1;
    }
    proto = strtok_r(NULL, " \t", &p);
    if (proto == NULL) {
	kdc_log(context, config, 0, "Malformed HTTP request from %s", d->addr_string);
	free(data);
	return -1;
    }
    len = base64_decode(t, data);
    if(len <= 0){
	const char *msg =
	    " 404 Not found\r\n"
	    "Server: Heimdal/" VERSION "\r\n"
	    "Cache-Control: no-cache\r\n"
	    "Pragma: no-cache\r\n"
	    "Content-type: text/html\r\n"
	    "Content-transfer-encoding: 8bit\r\n\r\n"
	    "<TITLE>404 Not found</TITLE>\r\n"
	    "<H1>404 Not found</H1>\r\n"
	    "That page doesn't exist, maybe you are looking for "
	    "<A HREF=\"http://www.h5l.org/\">Heimdal</A>?\r\n";
	kdc_log(context, config, 0, "HTTP request from %s is non KDC request", d->addr_string);
	kdc_log(context, config, 5, "HTTP request: %s", t);
	free(data);
	if (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {
	    kdc_log(context, config, 0, "HTTP write failed: %s: %s",
		    d->addr_string, strerror(rk_SOCK_ERRNO));
	    return -1;
	}
	if (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {
	    kdc_log(context, config, 0, "HTTP write failed: %s: %s",
		    d->addr_string, strerror(rk_SOCK_ERRNO));
	    return -1;
	}
	return -1;
    }
    {
	const char *msg =
	    " 200 OK\r\n"
	    "Server: Heimdal/" VERSION "\r\n"
	    "Cache-Control: no-cache\r\n"
	    "Pragma: no-cache\r\n"
	    "Content-type: application/octet-stream\r\n"
	    "Content-transfer-encoding: binary\r\n\r\n";
	if (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {
	    free(data);
	    kdc_log(context, config, 0, "HTTP write failed: %s: %s",
		    d->addr_string, strerror(rk_SOCK_ERRNO));
	    return -1;
	}
	if (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {
	    free(data);
	    kdc_log(context, config, 0, "HTTP write failed: %s: %s",
		    d->addr_string, strerror(rk_SOCK_ERRNO));
	    return -1;
	}
    }
    if ((size_t)len > d->len)
        len = d->len;
    memcpy(d->buf, data, len);
    d->len = len;
    free(data);
    return 1;
}

/*
 * Handle incoming data to the TCP socket in `d[index]'
 */

static void
handle_tcp(krb5_context context,
	   krb5_kdc_configuration *config,
	   struct descr *d, int idx, int min_free)
{
    unsigned char buf[1024];
    int n;
    int ret = 0;

    if (d[idx].timeout == 0) {
	add_new_tcp (context, config, d, idx, min_free);
	return;
    }

    n = recvfrom(d[idx].s, buf, sizeof(buf), 0, NULL, NULL);
    if(rk_IS_SOCKET_ERROR(n)){
	krb5_warn(context, rk_SOCK_ERRNO, "recvfrom failed from %s to %s/%d",
		  d[idx].addr_string, descr_type(d + idx),
		  ntohs(d[idx].port));
	return;
    } else if (n == 0) {
	krb5_warnx(context, "connection closed before end of data after %lu "
		   "bytes from %s to %s/%d", (unsigned long)d[idx].len,
		   d[idx].addr_string, descr_type(d + idx),
		   ntohs(d[idx].port));
	clear_descr (d + idx);
	return;
    }
    if (grow_descr (context, config, &d[idx], n))
	return;
    memcpy(d[idx].buf + d[idx].len, buf, n);
    d[idx].len += n;
    if(d[idx].len > 4 && d[idx].buf[0] == 0) {
	ret = handle_vanilla_tcp (context, config, &d[idx]);
    } else if(enable_http &&
	      d[idx].len >= 4 &&
	      strncmp((char *)d[idx].buf, "GET ", 4) == 0 &&
	      strncmp((char *)d[idx].buf + d[idx].len - 4,
		      "\r\n\r\n", 4) == 0) {

        /* remove the trailing \r\n\r\n so the string is NUL terminated */
        d[idx].buf[d[idx].len - 4] = '\0';

	ret = handle_http_tcp (context, config, &d[idx]);
	if (ret < 0)
	    clear_descr (d + idx);
    } else if (d[idx].len > 4) {
	kdc_log (context, config,
		 0, "TCP data of strange type from %s to %s/%d",
		 d[idx].addr_string, descr_type(d + idx),
		 ntohs(d[idx].port));
	if (d[idx].buf[0] & 0x80) {
	    krb5_data reply;

	    kdc_log (context, config, 0, "TCP extension not supported");

	    ret = krb5_mk_error(context,
				KRB5KRB_ERR_FIELD_TOOLONG,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				&reply);
	    if (ret == 0) {
		send_reply(context, config, TRUE, d + idx, &reply);
		krb5_data_free(&reply);
	    }
	}
	clear_descr(d + idx);
	return;
    }
    if (ret < 0)
	return;
    else if (ret == 1) {
	do_request(context, config,
		   d[idx].buf, d[idx].len, TRUE, &d[idx]);
	clear_descr(d + idx);
    }
}

krb5_boolean
realloc_descrs(struct descr **d, unsigned int *ndescr)
{
    struct descr *tmp;
    size_t i;

    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));
    if(tmp == NULL)
        return FALSE;

    *d = tmp;
    reinit_descrs (*d, *ndescr);
    memset(*d + *ndescr, 0, 4 * sizeof(**d));
    for(i = *ndescr; i < *ndescr + 4; i++)
        init_descr (*d + i);

    *ndescr += 4;

    return TRUE;
}

int
next_min_free(krb5_context context, struct descr **d, unsigned int *ndescr)
{
    size_t i;
    int min_free;

    for(i = 0; i < *ndescr; i++) {
        int s = (*d + i)->s;
        if(rk_IS_BAD_SOCKET(s))
            return i;
    }

    min_free = *ndescr;
    if(!realloc_descrs(d, ndescr)) {
        min_free = -1;
        krb5_warnx(context, "No memory");
    }

    return min_free;
}

void
loop(krb5_context context,
     krb5_kdc_configuration *config)
{
    struct descr *d;
    unsigned int ndescr;

    ndescr = init_sockets(context, config, &d);
    if(ndescr <= 0)
	krb5_errx(context, 1, "No sockets!");
    kdc_log(context, config, 0, "KDC started");
    while(exit_flag == 0){
	struct timeval tmout;
	fd_set fds;
	int min_free = -1;
	int max_fd = 0;
	size_t i;

	FD_ZERO(&fds);
	for(i = 0; i < ndescr; i++) {
	    if(!rk_IS_BAD_SOCKET(d[i].s)){
		if(d[i].type == SOCK_STREAM &&
		   d[i].timeout && d[i].timeout < time(NULL)) {
		    kdc_log(context, config, 1,
			    "TCP-connection from %s expired after %lu bytes",
			    d[i].addr_string, (unsigned long)d[i].len);
		    clear_descr(&d[i]);
		    continue;
		}
#ifndef NO_LIMIT_FD_SETSIZE
		if(max_fd < d[i].s)
		    max_fd = d[i].s;
#ifdef FD_SETSIZE
		if (max_fd >= FD_SETSIZE)
		    krb5_errx(context, 1, "fd too large");
#endif
#endif
		FD_SET(d[i].s, &fds);
	    }
	}

	tmout.tv_sec = TCP_TIMEOUT;
	tmout.tv_usec = 0;
	switch(select(max_fd + 1, &fds, 0, 0, &tmout)){
	case 0:
	    break;
	case -1:
	    if (errno != EINTR)
		krb5_warn(context, rk_SOCK_ERRNO, "select");
	    break;
	default:
	    for(i = 0; i < ndescr; i++)
		if(!rk_IS_BAD_SOCKET(d[i].s) && FD_ISSET(d[i].s, &fds)) {
            min_free = next_min_free(context, &d, &ndescr);

            if(d[i].type == SOCK_DGRAM)
                handle_udp(context, config, &d[i]);
            else if(d[i].type == SOCK_STREAM)
                handle_tcp(context, config, d, i, min_free);
		}
	}
    }
    if (0);
#ifdef SIGXCPU
    else if(exit_flag == SIGXCPU)
	kdc_log(context, config, 0, "CPU time limit exceeded");
#endif
    else if(exit_flag == SIGINT || exit_flag == SIGTERM)
	kdc_log(context, config, 0, "Terminated");
    else
	kdc_log(context, config, 0, "Unexpected exit reason: %d", exit_flag);
    free (d);
}
@


1.4
log
@Upgrade our KerberosV to Heimdal 1.5.3 (minor update).

- Fix leaking file descriptors in KDC
- Better socket/timeout handling in libkrb5
- General bug fixes

ok robert@@
@
text
@@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d841 42
a920 16
	    } else if(min_free < 0 || i < (size_t)min_free)
		min_free = i;
	}
	if(min_free == -1){
	    struct descr *tmp;
	    tmp = realloc(d, (ndescr + 4) * sizeof(*d));
	    if(tmp == NULL)
		krb5_warnx(context, "No memory");
	    else {
		d = tmp;
		reinit_descrs (d, ndescr);
		memset(d + ndescr, 0, 4 * sizeof(*d));
		for(i = ndescr; i < ndescr + 4; i++)
		    init_descr (&d[i]);
		min_free = ndescr;
		ndescr += 4;
d936 6
a941 4
		    if(d[i].type == SOCK_DGRAM)
			handle_udp(context, config, &d[i]);
		    else if(d[i].type == SOCK_STREAM)
			handle_tcp(context, config, d, i, min_free);
@


1.2
log
@Change nasty realloc call to a more correct looking ideom - noticed while
looking at some parfait false positives in here.

ok deraadt@@
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d36 13
a48 1
RCSID("$KTH: connect.c,v 1.104 2005/05/30 20:56:18 joda Exp $");
d63 1
a63 1
static int num_ports;
d70 2
a71 1
add_port(int family, int port, const char *protocol)
d74 1
a74 1
    int i;
d103 2
a104 1
add_port_service(int family, const char *service, int port,
d108 1
a108 1
    add_port (family, port, protocol);
d117 2
a118 1
add_port_string (int family, const char *port_str, const char *protocol)
d123 1
a123 1
    sp = roken_getservbyname (port_str, protocol);
d129 2
a130 2
	port = htons(strtol(port_str, &end, 0));
	if (end == port_str)
d133 1
a133 1
    add_port (family, port, protocol);
d141 8
a148 6
add_standard_ports (int family)
{
    add_port_service(family, "kerberos", 88, "udp");
    add_port_service(family, "kerberos", 88, "tcp");
    add_port_service(family, "kerberos-sec", 88, "udp");
    add_port_service(family, "kerberos-sec", 88, "tcp");
d150 4
a153 8
	add_port_service(family, "http", 80, "tcp");
    if(enable_524) {
	add_port_service(family, "krb524", 4444, "udp");
	add_port_service(family, "krb524", 4444, "tcp");
    }
    if(enable_v4) {
	add_port_service(family, "kerberos-iv", 750, "udp");
	add_port_service(family, "kerberos-iv", 750, "tcp");
d155 1
a155 2
    if (enable_kaserver)
	add_port_service(family, "afs3-kaserver", 7004, "udp");
d165 3
a167 1
parse_ports(const char *str)
d177 1
a177 1
	    add_standard_ports(AF_INET6);
d179 1
a179 1
	    add_standard_ports(AF_INET);
d185 1
a185 1
		add_port_string(AF_INET6, p, q);
d187 1
a187 1
		add_port_string(AF_INET, p, q);
d190 2
a191 2
		add_port_string(AF_INET6, p, "udp");
		add_port_string(AF_INET6, p, "tcp");
d193 2
a194 2
		add_port_string(AF_INET, p, "udp");
		add_port_string(AF_INET, p, "tcp");
d197 1
a197 1
	    
d208 1
a208 1
    int s;
d226 1
a226 1
    d->s = -1;
d246 4
a249 2
static void 
init_socket(struct descr *d, krb5_address *a, int family, int type, int port)
d261 2
a262 2
	close(d->s);
	d->s = -1;
d270 1
a270 1
    if(d->s < 0){
d272 1
a272 1
	d->s = -1;
d284 1
a284 1
    if(bind(d->s, sa, sa_size) < 0){
d290 2
a291 2
	close(d->s);
	d->s = -1;
d294 1
a294 1
    if(type == SOCK_STREAM && listen(d->s, SOMAXCONN) < 0){
d300 2
a301 2
	close(d->s);
	d->s = -1;
d312 3
a314 1
init_sockets(struct descr **desc)
d317 2
a318 2
    int i, j;
    struct descr *d, *tmp;
d329 1
a329 1
    parse_ports(port_str);
d337 1
a337 1
	    init_socket(&d[num], &addresses.val[j],
d339 1
a339 1
	    if(d[num].s != -1){
d346 1
a346 1
		kdc_log(5, "listening on %s port %u/%s",
d348 1
a348 1
			ntohs(ports[i].port), 
d356 2
a357 3
    tmp = realloc(d, num * sizeof(*d));
    if (tmp == NULL && num != 0) {
	free(d);
a359 2
    }
    d = tmp;
a378 43
/*
 * handle the request in `buf, len', from `addr' (or `from' as a string),
 * sending a reply in `reply'.
 */

static int
process_request(unsigned char *buf, 
		size_t len, 
		krb5_data *reply,
		krb5_boolean *prependlength,
		const char *from,
		struct sockaddr *addr)
{
    KDC_REQ req;
    Ticket ticket;
    krb5_error_code ret;
    size_t i;

    gettimeofday(&now, NULL);
    if(decode_AS_REQ(buf, len, &req, &i) == 0){
	ret = as_rep(&req, reply, from, addr);
	free_AS_REQ(&req);
	return ret;
    }else if(decode_TGS_REQ(buf, len, &req, &i) == 0){
	ret = tgs_rep(&req, reply, from, addr);
	free_TGS_REQ(&req);
	return ret;
    }else if(decode_Ticket(buf, len, &ticket, &i) == 0){
	ret = do_524(&ticket, reply, from, addr);
	free_Ticket(&ticket);
	return ret;
    } else if(maybe_version4(buf, len)){
	*prependlength = FALSE; /* elbitapmoc sdrawkcab XXX */
	do_version4(buf, len, reply, from, (struct sockaddr_in*)addr);
	return 0;
    } else if (enable_kaserver) {
	ret = do_kaserver (buf, len, reply, from, (struct sockaddr_in*)addr);
	return ret;
    }
			  
    return -1;
}

d380 2
a381 1
addr_to_string(struct sockaddr *addr, size_t addr_len, char *str, size_t len)
d395 34
d433 3
a435 1
do_request(void *buf, size_t len, krb5_boolean prependlength,
d440 11
a450 4
    
    reply.length = 0;
    ret = process_request(buf, len, &reply, &prependlength,
			  d->addr_string, d->sa);
d452 1
a452 19
	kdc_log(5, "sending %lu bytes to %s", (unsigned long)reply.length,
		d->addr_string);
	if(prependlength){
	    unsigned char len[4];
	    len[0] = (reply.length >> 24) & 0xff;
	    len[1] = (reply.length >> 16) & 0xff;
	    len[2] = (reply.length >> 8) & 0xff;
	    len[3] = reply.length & 0xff;
	    if(sendto(d->s, len, sizeof(len), 0, d->sa, d->sock_len) < 0) {
		kdc_log (0, "sendto(%s): %s", d->addr_string, strerror(errno));
		krb5_data_free(&reply);
		return;
	    }
	}
	if(sendto(d->s, reply.data, reply.length, 0, d->sa, d->sock_len) < 0) {
	    kdc_log (0, "sendto(%s): %s", d->addr_string, strerror(errno));
	    krb5_data_free(&reply);
	    return;
	}
d456 2
a457 1
	kdc_log(0, "Failed processing %lu byte request from %s", 
d466 3
a468 1
handle_udp(struct descr *d)
d471 1
a471 1
    int n;
d473 1
a473 1
    buf = malloc(max_request);
d475 1
a475 1
	kdc_log(0, "Failed to allocate %lu bytes", (unsigned long)max_request);
d480 3
a482 3
    n = recvfrom(d->s, buf, max_request, 0, d->sa, &d->sock_len);
    if(n < 0)
	krb5_warn(context, errno, "recvfrom");
d484 1
a484 1
	addr_to_string (d->sa, d->sock_len,
d486 19
a504 1
	do_request(buf, n, FALSE, d);
d515 3
a517 3
    if(d->s != -1)
	close(d->s);
    d->s = -1;
d529 1
a529 1
	    if(sscanf(p + 1, "%2x", &x) != 1)
d547 3
a549 1
add_new_tcp (struct descr *d, int parent, int child)
d551 1
a551 1
    int s;
d558 2
a559 2
    if(s < 0) {
	krb5_warn(context, errno, "accept");
d562 2
a563 1
	    
d566 1
a566 1
	close (s);
d569 1
d574 2
a575 1
    addr_to_string (d[child].sa, d[child].sock_len,
d585 3
a587 1
grow_descr (struct descr *d, size_t n)
d591 1
a591 1
	size_t grow; 
d594 2
a595 2
	if (d->size + grow > max_request) {
	    kdc_log(0, "Request exceeds max request size (%lu bytes).",
d602 1
a602 1
	    kdc_log(0, "Failed to re-allocate %lu bytes.",
d619 3
a621 1
handle_vanilla_tcp (struct descr *d)
d624 1
a624 1
    int32_t len;
d628 1
a628 1
	kdc_log (0, "krb5_storage_from_mem failed");
d631 1
a631 1
    krb5_ret_int32(sp, &len);
d635 1
d647 3
a649 1
handle_http_tcp (struct descr *d)
d658 1
d660 2
a661 5
    if (p == NULL) {
	kdc_log(0, "Malformed HTTP request from %s", d->addr_string);
	return -1;
    }
    *p = 0;
d666 2
a667 1
	kdc_log(0, "Malformed HTTP request from %s", d->addr_string);
d670 1
d673 2
a674 1
	kdc_log(0, "Malformed HTTP request from %s", d->addr_string);
d677 1
d680 1
a680 1
	kdc_log(0, "Failed to allocate %lu bytes",
d687 2
a688 2
	kdc_log(0, "Malformed HTTP request from %s", d->addr_string);
	kdc_log(5, "HTTP request: %s", t);
d694 1
a694 1
	kdc_log(0, "Malformed HTTP request from %s", d->addr_string);
d700 1
a700 1
	const char *msg = 
d710 3
a712 3
	    "<A HREF=\"http://www.pdc.kth.se/heimdal/\">Heimdal</A>?\r\n";
	kdc_log(0, "HTTP request from %s is non KDC request", d->addr_string);
	kdc_log(5, "HTTP request: %s", t);
d714 3
a716 3
	if (write(d->s, proto, strlen(proto)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
d719 3
a721 3
	if (write(d->s, msg, strlen(msg)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
d727 1
a727 1
	const char *msg = 
d734 4
a737 3
	if (write(d->s, proto, strlen(proto)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
d740 4
a743 3
	if (write(d->s, msg, strlen(msg)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
d747 2
d760 3
a762 1
handle_tcp(struct descr *d, int index, int min_free)
d768 2
a769 2
    if (d[index].timeout == 0) {
	add_new_tcp (d, index, min_free);
d773 5
a777 5
    n = recvfrom(d[index].s, buf, sizeof(buf), 0, NULL, NULL);
    if(n < 0){
	krb5_warn(context, errno, "recvfrom failed from %s to %s/%d",
		  d[index].addr_string, descr_type(d + index), 
		  ntohs(d[index].port));
d781 4
a784 4
		   "bytes from %s to %s/%d", (unsigned long)d[index].len, 
		   d[index].addr_string, descr_type(d + index), 
		   ntohs(d[index].port));
	clear_descr (d + index);
d787 6
a792 6
    if (grow_descr (&d[index], n))
	return;
    memcpy(d[index].buf + d[index].len, buf, n);
    d[index].len += n;
    if(d[index].len > 4 && d[index].buf[0] == 0) {
	ret = handle_vanilla_tcp (&d[index]);
d794 3
a796 3
	      d[index].len >= 4 &&
	      strncmp((char *)d[index].buf, "GET ", 4) == 0 && 
	      strncmp((char *)d[index].buf + d[index].len - 4,
d798 5
a802 1
	ret = handle_http_tcp (&d[index]);
d804 26
a829 6
	    clear_descr (d + index);
    } else if (d[index].len > 4) {
	kdc_log (0, "TCP data of strange type from %s to %s/%d",
		 d[index].addr_string, descr_type(d + index), 
		 ntohs(d[index].port));
	clear_descr(d + index);
d835 3
a837 2
	do_request(d[index].buf, d[index].len, TRUE, &d[index]);
	clear_descr(d + index);
d842 2
a843 1
loop(void)
d846 1
a846 1
    int ndescr;
d848 1
a848 1
    ndescr = init_sockets(&d);
d851 1
d857 1
a857 1
	int i;
d861 2
a862 2
	    if(d[i].s >= 0){
		if(d[i].type == SOCK_STREAM && 
d864 2
a865 1
		    kdc_log(1, "TCP-connection from %s expired after %lu bytes",
d870 1
d873 1
d876 2
d879 1
a879 1
	    } else if(min_free < 0 || i < min_free)
d897 1
a897 1
    
d905 1
a905 1
		krb5_warn(context, errno, "select");
d909 1
a909 1
		if(d[i].s >= 0 && FD_ISSET(d[i].s, &fds)) {
d911 1
a911 1
			handle_udp(&d[i]);
d913 1
a913 1
			handle_tcp(d, i, min_free);
d917 5
a921 2
    if(exit_flag == SIGXCPU)
	kdc_log(0, "CPU time limit exceeded");
d923 1
a923 1
	kdc_log(0, "Terminated");
d925 1
a925 1
	kdc_log(0, "Unexpected exit reason: %d", exit_flag);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: connect.c,v 1.80 2000/10/08 21:36:29 assar Exp $");
d134 4
a137 1
#ifdef KRB4
a141 6
    if(enable_524) {
	add_port_service(family, "krb524", 4444, "udp");
	add_port_service(family, "krb524", 4444, "tcp");
    }
#endif
#ifdef KASERVER
a143 1
#endif
d196 1
d216 1
a216 1
 * re-intialize all `n' ->sa in `d'.
d238 1
a238 1
    int sa_size;
d242 1
a242 1
    ret = krb5_addr2sockaddr (a, sa, &sa_size, port);
d266 1
d300 1
a300 1
    struct descr *d;
d338 3
a340 2
    d = realloc(d, num * sizeof(*d));
    if (d == NULL && num != 0)
d343 2
d351 14
d373 1
a373 1
		int *sendlength,
a377 1
#ifdef KRB4
a378 1
#endif
a390 6
    }
#ifdef KRB4
    else if(maybe_version4(buf, len)){
	*sendlength = 0; /* elbitapmoc sdrawkcab XXX */
	do_version4(buf, len, reply, from, (struct sockaddr_in*)addr);
	return 0;
d395 5
a399 4
    }
#endif
#ifdef KASERVER
    else if (enable_kaserver) {
a402 1
#endif
d411 5
a415 2
    krb5_sockaddr2address(addr, &a);
    if(krb5_print_address(&a, str, len, &len) == 0) {
a416 1
	return;
a417 1
    krb5_free_address(context, &a);
d426 1
a426 1
do_request(void *buf, size_t len, int sendlength,
d433 1
a433 1
    ret = process_request(buf, len, &reply, &sendlength,
d436 3
a438 2
	kdc_log(5, "sending %d bytes to %s", reply.length, d->addr_string);
	if(sendlength){
d474 1
a474 1
	kdc_log(0, "Failed to allocate %u bytes", max_request);
d485 1
a485 1
	do_request(buf, n, 0, d);
d506 3
a508 3
    char *p, *q;
    for(p = q = buf; *p; p++, q++) {
	if(*p == '%') {
d565 1
d567 4
a570 4
	d->size += max(1024, d->len + n);
	if (d->size >= max_request) {
	    kdc_log(0, "Request exceeds max request size (%u bytes).",
		    d->size);
d574 1
a574 1
	tmp = realloc (d->buf, d->size);
d576 2
a577 1
	    kdc_log(0, "Failed to re-allocate %u bytes.", d->size);
d581 1
d647 2
a648 1
	kdc_log(0, "Failed to allocate %u bytes", strlen(t));
d655 1
a655 1
	kdc_log(5, "Request: %s", t);
d670 2
d677 1
a677 3
	    "<A HREF=\"http://www.pdc.kth.se/heimdal\">Heimdal</A>?\r\n";
	write(d->s, proto, strlen(proto));
	write(d->s, msg, strlen(msg));
d679 1
a679 1
	kdc_log(5, "Request: %s", t);
d681 10
d697 2
d701 10
a710 2
	write(d->s, proto, strlen(proto));
	write(d->s, msg, strlen(msg));
d736 10
a745 1
	krb5_warn(context, errno, "recvfrom");
d763 4
a766 1
	kdc_log (0, "TCP data of strange type from %s", d[index].addr_string);
d772 1
a772 1
	do_request(d[index].buf, d[index].len, 1, &d[index]);
d798 2
a799 2
		    kdc_log(1, "TCP-connection from %s expired after %u bytes",
			    d[i].addr_string, d[i].len);
d846 6
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: connect.c,v 1.82 2001/05/14 06:18:11 assar Exp $");
d245 1
a245 1
    ret = krb5_addr2sockaddr (context, a, sa, &sa_size, port);
d404 1
a404 1
    krb5_sockaddr2address(context, addr, &a);
d465 1
a465 1
	kdc_log(0, "Failed to allocate %lu bytes", (unsigned long)max_request);
d559 2
a560 2
	    kdc_log(0, "Request exceeds max request size (%lu bytes).",
		    (unsigned long)d->size);
d566 1
a566 2
	    kdc_log(0, "Failed to re-allocate %lu bytes.",
		    (unsigned long)d->size);
d635 1
a635 2
	kdc_log(0, "Failed to allocate %lu bytes",
		(unsigned long)strlen(t));
d753 2
a754 2
		    kdc_log(1, "TCP-connection from %s expired after %lu bytes",
			    d[i].addr_string, (unsigned long)d[i].len);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: connect.c,v 1.84 2001/08/21 10:10:25 assar Exp $");
d143 2
d388 4
a391 1
    } else if (enable_kaserver) {
d428 1
a428 2
	kdc_log(5, "sending %lu bytes to %s", (unsigned long)reply.length,
		d->addr_string);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: connect.c,v 1.90 2003/02/18 15:39:10 lha Exp $");
a133 4
    if(enable_524) {
	add_port_service(family, "krb524", 4444, "udp");
	add_port_service(family, "krb524", 4444, "tcp");
    }
d139 4
d217 1
a217 1
 * re-initialize all `n' ->sa in `d'.
d239 1
a239 1
    int sa_size = sizeof(__ss);
d361 1
d363 1
d376 6
a385 5
#ifdef KRB4
    } else if(maybe_version4(buf, len)){
	*sendlength = 0; /* elbitapmoc sdrawkcab XXX */
	do_version4(buf, len, reply, from, (struct sockaddr_in*)addr);
	return 0;
d389 1
a390 1
    }
d399 2
a400 5
    if(krb5_sockaddr2address(context, addr, &a) == 0) {
	if(krb5_print_address(&a, str, len, &len) == 0) {
	    krb5_free_address(context, &a);
	    return;
	}
d402 1
d404 1
d495 1
a495 1
	if(*p == '%' && isxdigit(p[1]) && isxdigit(p[2])) {
a654 2
	    "Cache-Control: no-cache\r\n"
	    "Pragma: no-cache\r\n"
d660 1
a660 1
	    "<A HREF=\"http://www.pdc.kth.se/heimdal/\">Heimdal</A>?\r\n";
a671 2
	    "Cache-Control: no-cache\r\n"
	    "Pragma: no-cache\r\n"
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: connect.c,v 1.90.2.2 2004/04/02 20:50:53 lha Exp $");
a549 1
	size_t grow; 
d551 2
a552 2
	grow = max(1024, d->len + n);
	if (d->size + grow > max_request) {
d554 1
a554 1
		    (unsigned long)d->size + grow);
d558 1
a558 1
	tmp = realloc (d->buf, d->size + grow);
d561 1
a561 1
		    (unsigned long)d->size + grow);
a564 1
	d->size += grow;
a703 6
	return;
    } else if (n == 0) {
	krb5_warnx(context, "connection closed before end of data after %lu "
		   "bytes from %s",
		   (unsigned long)d[index].len, d[index].addr_string);
	clear_descr (d + index);
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: connect.c,v 1.104 2005/05/30 20:56:18 joda Exp $");
d138 1
d145 1
a197 1
    int port;
d239 1
a239 1
    krb5_socklen_t sa_size = sizeof(__ss);
a266 1
    d->port = port;
a347 14
 *
 */

static const char *
descr_type(struct descr *d)
{
    if (d->type == SOCK_DGRAM)
	return "udp";
    else if (d->type == SOCK_STREAM)
	return "tcp";
    return "unknown";
}

/*
d356 1
a356 1
		krb5_boolean *prependlength,
d378 1
d380 1
a380 1
	*prependlength = FALSE; /* elbitapmoc sdrawkcab XXX */
d386 1
d411 1
a411 1
do_request(void *buf, size_t len, krb5_boolean prependlength,
d418 1
a418 1
    ret = process_request(buf, len, &reply, &prependlength,
d423 1
a423 1
	if(prependlength){
d470 1
a470 1
	do_request(buf, n, FALSE, d);
d491 2
a492 2
    unsigned char *p, *q;
    for(p = q = (unsigned char *)buf; *p; p++, q++) {
d640 1
a640 1
	kdc_log(5, "HTTP request: %s", t);
d663 2
d666 1
a666 1
	kdc_log(5, "HTTP request: %s", t);
a667 10
	if (write(d->s, proto, strlen(proto)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
	    return -1;
	}
	if (write(d->s, msg, strlen(msg)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
	    return -1;
	}
d678 2
a679 10
	if (write(d->s, proto, strlen(proto)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
	    return -1;
	}
	if (write(d->s, msg, strlen(msg)) < 0) {
	    kdc_log(0, "HTTP write failed: %s: %s", 
		    d->addr_string, strerror(errno));
	    return -1;
	}
d705 1
a705 3
	krb5_warn(context, errno, "recvfrom failed from %s to %s/%d",
		  d[index].addr_string, descr_type(d + index), 
		  ntohs(d[index].port));
d709 2
a710 3
		   "bytes from %s to %s/%d", (unsigned long)d[index].len, 
		   d[index].addr_string, descr_type(d + index), 
		   ntohs(d[index].port));
d729 1
a729 4
	kdc_log (0, "TCP data of strange type from %s to %s/%d",
		 d[index].addr_string, descr_type(d + index), 
		 ntohs(d[index].port));
	clear_descr(d + index);
d735 1
a735 1
	do_request(d[index].buf, d[index].len, TRUE, &d[index]);
a808 6
    if(exit_flag == SIGXCPU)
	kdc_log(0, "CPU time limit exceeded");
    else if(exit_flag == SIGINT || exit_flag == SIGTERM)
	kdc_log(0, "Terminated");
    else
	kdc_log(0, "Unexpected exit reason: %d", exit_flag);
@


