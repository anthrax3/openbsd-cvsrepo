head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.2
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.18;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.19.11.36;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.17.18.43;	author hin;	state dead;
branches;
next	1.1;

1.1
date	2001.05.25.07.46.22;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.46.22;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.10.29.15.55.27;	author biorn;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.14.07.32.21;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1995 - 2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kx.h"

RCSID("$Id: krb5.c,v 1.3 2013/06/17 19:11:36 robert Exp $");

#ifdef KRB5

struct krb5_kx_context {
    krb5_context context;
    krb5_keyblock *keyblock;
    krb5_crypto crypto;
    krb5_principal client;
    krb5_log_facility *log;

};

typedef struct krb5_kx_context krb5_kx_context;

#define K5DATA(kc) ((krb5_kx_context*)kc->data)
#define CONTEXT(kc) (K5DATA(kc)->context)

/*
 *
 */

static void
ksyslog(krb5_context context, krb5_error_code ret, const char *fmt, ...)
	__attribute__((__format__(__printf__, 3, 0)));

static void
ksyslog(krb5_context context, krb5_error_code ret, const char *fmt, ...)
{
    const char *msg;
    char *str = NULL;
    va_list va;

    msg = krb5_get_error_message(context, ret);

    va_start(va, fmt);
    vasprintf(&str, fmt, va);
    va_end(va);

    syslog(LOG_ERR, "%s: %s", str, msg);

    krb5_free_error_message(context, msg);
    free(str);
}

/*
 * Destroy the krb5 context in `c'.
 */

static void
krb5_destroy (kx_context *kc)
{
    if (K5DATA(kc)->keyblock)
	krb5_free_keyblock (CONTEXT(kc), K5DATA(kc)->keyblock);
    if (K5DATA(kc)->crypto)
	krb5_crypto_destroy (CONTEXT(kc), K5DATA(kc)->crypto);
    if (K5DATA(kc)->client)
	krb5_free_principal (CONTEXT(kc), K5DATA(kc)->client);
    if (CONTEXT(kc))
	krb5_free_context (CONTEXT(kc));
    memset (kc->data, 0, sizeof(krb5_kx_context));
    free (kc->data);
}

/*
 * Read the authentication information from `s' and return 0 if
 * succesful, else -1.
 */

static int
krb5_authenticate (kx_context *kc, int s)
{
    krb5_auth_context auth_context = NULL;
    krb5_error_code ret;
    krb5_principal server;
    const char *host = kc->host;

    ret = krb5_sname_to_principal (CONTEXT(kc),
				   host, "host", KRB5_NT_SRV_HST, &server);
    if (ret) {
	krb5_warn (CONTEXT(kc), ret, "krb5_sname_to_principal: %s", host);
	return 1;
    }

    ret = krb5_sendauth (CONTEXT(kc),
			 &auth_context,
			 &s,
			 KX_VERSION,
			 NULL,
			 server,
			 AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,
			 NULL,
			 NULL,
			 NULL,
			 NULL,
			 NULL,
			 NULL);
    if (ret) {
	if(ret != KRB5_SENDAUTH_BADRESPONSE)
	    krb5_warn (CONTEXT(kc), ret, "krb5_sendauth: %s", host);
	return 1;
    }

    ret = krb5_auth_con_getkey (CONTEXT(kc), auth_context,
				&K5DATA(kc)->keyblock);
    if (ret) {
	krb5_warn (CONTEXT(kc), ret, "krb5_auth_con_getkey: %s", host);
	krb5_auth_con_free (CONTEXT(kc), auth_context);
	return 1;
    }

    ret = krb5_crypto_init (CONTEXT(kc), K5DATA(kc)->keyblock,
			    0, &K5DATA(kc)->crypto);
    if (ret) {
	krb5_warn (CONTEXT(kc), ret, "krb5_crypto_init");
	krb5_auth_con_free (CONTEXT(kc), auth_context);
	return 1;
    }
    return 0;
}

/*
 * Read an encapsulated krb5 packet from `fd' into `buf' (of size
 * `len').  Return the number of bytes read or 0 on EOF or -1 on
 * error.
 */

static ssize_t
krb5_read (kx_context *kc,
	   int fd, void *buf, size_t len)
{
    size_t data_len, outer_len;
    krb5_error_code ret;
    unsigned char tmp[4];
    krb5_data data;
    int l;

    l = krb5_net_read (CONTEXT(kc), &fd, tmp, 4);
    if (l == 0)
	return l;
    if (l != 4)
	return -1;
    data_len  = (tmp[0] << 24) | (tmp[1] << 16) | (tmp[2] << 8) | tmp[3];
    outer_len = krb5_get_wrapped_length (CONTEXT(kc),
					 K5DATA(kc)->crypto, data_len);
    if (outer_len > len)
	return -1;
    if (krb5_net_read (CONTEXT(kc), &fd, buf, outer_len) != outer_len)
	return -1;

    ret = krb5_decrypt (CONTEXT(kc), K5DATA(kc)->crypto,
			KRB5_KU_OTHER_ENCRYPTED,
			buf, outer_len, &data);
    if (ret) {
	krb5_warn (CONTEXT(kc), ret, "krb5_decrypt");
	return -1;
    }
    if (data_len > data.length) {
	krb5_data_free (&data);
	return -1;
    }
    memmove (buf, data.data, data_len);
    krb5_data_free (&data);
    return data_len;
}

/*
 * Write an encapsulated krb5 packet on `fd' with the data in `buf,
 * len'.  Return len or -1 on error.
 */

static ssize_t
krb5_write(kx_context *kc,
	   int fd, const void *buf, size_t len)
{
    krb5_data data;
    krb5_error_code ret;
    unsigned char tmp[4];
    size_t outlen;

    ret = krb5_encrypt (CONTEXT(kc), K5DATA(kc)->crypto,
			KRB5_KU_OTHER_ENCRYPTED,
			buf, len, &data);
    if (ret){
	krb5_warn (CONTEXT(kc), ret, "krb5_write");
	return -1;
    }

    outlen = data.length;
    tmp[0] = (len >> 24) & 0xFF;
    tmp[1] = (len >> 16) & 0xFF;
    tmp[2] = (len >>  8) & 0xFF;
    tmp[3] = (len >>  0) & 0xFF;

    if (krb5_net_write (CONTEXT(kc), &fd, tmp, 4) != 4 ||
	krb5_net_write (CONTEXT(kc), &fd, data.data, outlen) != outlen) {
	krb5_data_free (&data);
	return -1;
    }
    krb5_data_free (&data);
    return len;
}

/*
 * Copy from the unix socket `from_fd' encrypting to `to_fd'.
 * Return 0, -1 or len.
 */

static int
copy_out (kx_context *kc, int from_fd, int to_fd)
{
    char buf[32768];
    ssize_t len;

    len = read (from_fd, buf, sizeof(buf));
    if (len == 0)
	return 0;
    if (len < 0) {
	krb5_warn (CONTEXT(kc), errno, "read");
	return len;
    }
    return krb5_write (kc, to_fd, buf, len);
}

/*
 * Copy from the socket `from_fd' decrypting to `to_fd'.
 * Return 0, -1 or len.
 */

static int
copy_in (kx_context *kc, int from_fd, int to_fd)
{
    char buf[33000];		/* XXX */

    ssize_t len;

    len = krb5_read (kc, from_fd, buf, sizeof(buf));
    if (len == 0)
	return 0;
    if (len < 0) {
	krb5_warn (CONTEXT(kc), errno, "krb5_read");
	return len;
    }

    return krb5_net_write (CONTEXT(kc), &to_fd, buf, len);
}

/*
 * Copy data between `fd1' and `fd2', encrypting in one direction and
 * decrypting in the other.
 */

static int
krb5_copy_encrypted (kx_context *kc, int fd1, int fd2)
{
    for (;;) {
	fd_set fdset;
	int ret;

	if (fd1 >= FD_SETSIZE || fd2 >= FD_SETSIZE) {
	    krb5_warnx (CONTEXT(kc), "fd too large");
	    return 1;
	}

	FD_ZERO(&fdset);
	FD_SET(fd1, &fdset);
	FD_SET(fd2, &fdset);

	ret = select (max(fd1, fd2)+1, &fdset, NULL, NULL, NULL);
	if (ret < 0 && errno != EINTR) {
	    krb5_warn (CONTEXT(kc), errno, "select");
	    return 1;
	}
	if (FD_ISSET(fd1, &fdset)) {
	    ret = copy_out (kc, fd1, fd2);
	    if (ret <= 0)
		return ret;
	}
	if (FD_ISSET(fd2, &fdset)) {
	    ret = copy_in (kc, fd2, fd1);
	    if (ret <= 0)
		return ret;
	}
    }
}

/*
 * Return 0 if the user authenticated on `kc' is allowed to login as
 * `user'.
 */

static int
krb5_userok (kx_context *kc, char *user)
{
    krb5_error_code ret;
    char *tmp;

    ret = krb5_unparse_name (CONTEXT(kc), K5DATA(kc)->client, &tmp);
    if (ret)
	krb5_err (CONTEXT(kc), 1, ret, "krb5_unparse_name");
    kc->user = tmp;

    return !krb5_kuserok (CONTEXT(kc), K5DATA(kc)->client, user);
}

/*
 * Create an instance of an krb5 context.
 */

void
krb5_make_context (kx_context *kc)
{
    krb5_kx_context *c;
    krb5_error_code ret;

    kc->authenticate	= krb5_authenticate;
    kc->userok		= krb5_userok;
    kc->read		= krb5_read;
    kc->write		= krb5_write;
    kc->copy_encrypted	= krb5_copy_encrypted;
    kc->destroy		= krb5_destroy;
    kc->user		= NULL;
    kc->data		= malloc(sizeof(krb5_kx_context));

    if (kc->data == NULL) {
	syslog (LOG_ERR, "failed to malloc %lu bytes",
		(unsigned long)sizeof(krb5_kx_context));
	exit(1);
    }
    memset (kc->data, 0, sizeof(krb5_kx_context));
    c = (krb5_kx_context *)kc->data;
    ret = krb5_init_context (&c->context);
    if (ret) {
	syslog (LOG_ERR, "failed initialise krb5 context");
	exit(1);
    }
}

/*
 * Receive authentication information on `sock' (first four bytes
 * in `buf').
 */

int
recv_v5_auth (kx_context *kc, int sock, u_char *buf)
{
    uint32_t len;
    krb5_error_code ret;
    krb5_principal server;
    krb5_auth_context auth_context = NULL;
    krb5_ticket *ticket;

    if (memcmp (buf, "\x00\x00\x00\x13", 4) != 0)
	return 1;
    len = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | (buf[3]);
    if (net_read(sock, buf, len) != len) {
	syslog (LOG_ERR, "read: %m");
	exit (1);
    }
    if (len != sizeof(KRB5_SENDAUTH_VERSION)
	|| memcmp (buf, KRB5_SENDAUTH_VERSION, len) != 0) {
	syslog (LOG_ERR, "bad sendauth version: %.8s", buf);
	exit (1);
    }

    krb5_make_context (kc);
    krb5_openlog(CONTEXT(kc), "kxd", &K5DATA(kc)->log);
    krb5_set_warn_dest(CONTEXT(kc), K5DATA(kc)->log);

    ret = krb5_sock_to_principal (CONTEXT(kc), sock, "host",
				  KRB5_NT_SRV_HST, &server);
    if (ret) {
	ksyslog (CONTEXT(kc), ret, "krb5_sock_to_principal");
	exit (1);
    }

    ret = krb5_recvauth (CONTEXT(kc),
			 &auth_context,
			 &sock,
			 KX_VERSION,
			 server,
			 KRB5_RECVAUTH_IGNORE_VERSION,
			 NULL,
			 &ticket);
    krb5_free_principal (CONTEXT(kc), server);
    if (ret) {
	ksyslog (CONTEXT(kc), ret, "krb5_recvauth");
	exit (1);
    }

    ret = krb5_auth_con_getkey (CONTEXT(kc), auth_context, &K5DATA(kc)->keyblock);
    if (ret) {
	ksyslog (CONTEXT(kc), ret, "krb5_auth_con_getkey");
	exit (1);
    }

    ret = krb5_crypto_init (CONTEXT(kc), K5DATA(kc)->keyblock, 0, &K5DATA(kc)->crypto);
    if (ret) {
	ksyslog (CONTEXT(kc), ret, "krb5_crypto_init");
	exit (1);
    }

    K5DATA(kc)->client = ticket->client;
    ticket->client = NULL;
    krb5_free_ticket (CONTEXT(kc), ticket);

    krb5_auth_con_free(CONTEXT(kc), auth_context);

    return 0;
}

#endif /* KRB5 */
@


1.3
log
@2nd part of:
update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.
@
text
@d36 1
a36 1
RCSID("$Id$");
@


1.2
log
@These files are not use by us, so they're removed to make the tree
a little bit leaner, and to get rid of some bad string functions.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d12 1
a12 1
 * 
d16 1
a16 1
 * 
d20 1
a20 1
 * 
d36 1
a36 1
RCSID("$KTH: krb5.c,v 1.7 2000/12/31 07:32:03 assar Exp $");
d45 2
d51 30
d86 1
a86 1
krb5_destroy (kx_context *c)
d88 10
a97 11
    krb5_kx_context *kc = (krb5_kx_context *)c->data;

    if (kc->keyblock)
	krb5_free_keyblock (kc->context, kc->keyblock);
    if (kc->crypto)
	krb5_crypto_destroy (kc->context, kc->crypto);
    if (kc->client)
	krb5_free_principal (kc->context, kc->client);
    if (kc->context)
	krb5_free_context (kc->context);
    free (kc);
a107 2
    krb5_kx_context *c = (krb5_kx_context *)kc->data;
    krb5_context context = c->context;
d113 1
a113 1
    ret = krb5_sname_to_principal (context,
d116 1
a116 2
	warnx ("krb5_sname_to_principal: %s: %s", host,
	       krb5_get_err_text(context, ret));
d120 1
a120 1
    ret = krb5_sendauth (context,
d126 1
a126 1
			 AP_OPTS_MUTUAL_REQUIRED,
d134 2
a135 2
	warnx ("krb5_sendauth: %s: %s", host,
	       krb5_get_err_text(context, ret));
d139 2
a140 1
    ret = krb5_auth_con_getkey (context, auth_context, &c->keyblock);
d142 2
a143 3
	warnx ("krb5_auth_con_getkey: %s: %s", host,
	       krb5_get_err_text(context, ret));
	krb5_auth_con_free (context, auth_context);
d146 3
a148 2
    
    ret = krb5_crypto_init (context, c->keyblock, 0, &c->crypto);
d150 2
a151 2
	warnx ("krb5_crypto_init: %s", krb5_get_err_text (context, ret));
	krb5_auth_con_free (context, auth_context);
a166 2
    krb5_kx_context *c = (krb5_kx_context *)kc->data;
    krb5_context context = c->context;
d173 1
a173 1
    l = krb5_net_read (context, &fd, tmp, 4);
d179 2
a180 1
    outer_len = krb5_get_wrapped_length (context, c->crypto, data_len);
d183 1
a183 1
    if (krb5_net_read (context, &fd, buf, outer_len) != outer_len)
d186 2
a187 1
    ret = krb5_decrypt (context, c->crypto, KRB5_KU_OTHER_ENCRYPTED,
d190 1
a190 1
	warnx ("krb5_decrypt: %s", krb5_get_err_text(context, ret));
a210 2
    krb5_kx_context *c = (krb5_kx_context *)kc->data;
    krb5_context context = c->context;
d216 3
a218 2
    ret = krb5_encrypt (context, c->crypto, KRB5_KU_OTHER_ENCRYPTED,
			(void *)buf, len, &data);
d220 1
a220 1
	warnx ("krb5_write: %s", krb5_get_err_text (context, ret));
d230 2
a231 2
    if (krb5_net_write (context, &fd, tmp, 4) != 4 ||
	krb5_net_write (context, &fd, data.data, outlen) != outlen) {
d254 1
a254 1
	warn ("read");
d259 1
a259 1
	
a267 1
    krb5_kx_context *c = (krb5_kx_context *)kc->data;
d276 1
a276 1
	warn ("krb5_read");
d280 1
a280 1
    return krb5_net_write (c->context, &to_fd, buf, len);
d296 1
a296 1
	    warnx ("fd too large");
d306 1
a306 1
	    warn ("select");
a329 2
    krb5_kx_context *c = (krb5_kx_context *)kc->data;
    krb5_context context = c->context;
d333 1
a333 1
    ret = krb5_unparse_name (context, c->client, &tmp);
d335 1
a335 1
	krb5_err (context, 1, ret, "krb5_unparse_name");
d338 1
a338 1
    return !krb5_kuserok (context, c->client, user);
d360 5
a364 2
    if (kc->data == NULL)
	err (1, "malloc");
d368 4
a371 2
    if (ret)
	errx (1, "krb5_init_context failed: %d", ret);
d382 1
a382 1
    u_int32_t len;
a383 2
    krb5_kx_context *c;
    krb5_context context;
d402 2
a403 2
    c = (krb5_kx_context *)kc->data;
    context = c->context;
d405 1
a405 1
    ret = krb5_sock_to_principal (context, sock, "host",
d408 1
a408 2
	syslog (LOG_ERR, "krb5_sock_to_principal: %s",
		krb5_get_err_text (context, ret));
d412 1
a412 1
    ret = krb5_recvauth (context,
d420 1
a420 1
    krb5_free_principal (context, server);
d422 1
a422 2
	syslog (LOG_ERR, "krb5_sock_to_principal: %s",
		krb5_get_err_text (context, ret));
d426 1
a426 1
    ret = krb5_auth_con_getkey (context, auth_context, &c->keyblock);
d428 1
a428 2
	syslog (LOG_ERR, "krb5_auth_con_getkey: %s",
		krb5_get_err_text (context, ret));
d432 1
a432 1
    ret = krb5_crypto_init (context, c->keyblock, 0, &c->crypto);
d434 1
a434 2
	syslog (LOG_ERR, "krb5_crypto_init: %s",
		krb5_get_err_text (context, ret));
d438 1
a438 1
    c->client = ticket->client;
d440 3
a442 1
    krb5_free_ticket (context, ticket);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2004 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: krb5.c,v 1.10.6.2 2004/03/16 11:33:48 lha Exp $");
a44 2
    krb5_log_facility *log;
    
a48 3
#define K5DATA(kc) ((krb5_kx_context*)kc->data)
#define CONTEXT(kc) (K5DATA(kc)->context)

d54 1
a54 1
krb5_destroy (kx_context *kc)
d56 11
a66 10
    if (K5DATA(kc)->keyblock)
	krb5_free_keyblock (CONTEXT(kc), K5DATA(kc)->keyblock);
    if (K5DATA(kc)->crypto)
	krb5_crypto_destroy (CONTEXT(kc), K5DATA(kc)->crypto);
    if (K5DATA(kc)->client)
	krb5_free_principal (CONTEXT(kc), K5DATA(kc)->client);
    if (CONTEXT(kc))
	krb5_free_context (CONTEXT(kc));
    memset (kc->data, 0, sizeof(krb5_kx_context));
    free (kc->data);
d77 2
d84 1
a84 1
    ret = krb5_sname_to_principal (CONTEXT(kc),
d87 2
a88 1
	krb5_warn (CONTEXT(kc), ret, "krb5_sname_to_principal: %s", host);
d92 1
a92 1
    ret = krb5_sendauth (CONTEXT(kc),
d98 1
a98 1
			 AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,
d106 2
a107 2
	if(ret != KRB5_SENDAUTH_BADRESPONSE)
	    krb5_warn (CONTEXT(kc), ret, "krb5_sendauth: %s", host);
d111 1
a111 2
    ret = krb5_auth_con_getkey (CONTEXT(kc), auth_context, 
				&K5DATA(kc)->keyblock);
d113 3
a115 2
	krb5_warn (CONTEXT(kc), ret, "krb5_auth_con_getkey: %s", host);
	krb5_auth_con_free (CONTEXT(kc), auth_context);
d119 1
a119 2
    ret = krb5_crypto_init (CONTEXT(kc), K5DATA(kc)->keyblock, 
			    0, &K5DATA(kc)->crypto);
d121 2
a122 2
	krb5_warn (CONTEXT(kc), ret, "krb5_crypto_init");
	krb5_auth_con_free (CONTEXT(kc), auth_context);
d138 2
d146 1
a146 1
    l = krb5_net_read (CONTEXT(kc), &fd, tmp, 4);
d152 1
a152 2
    outer_len = krb5_get_wrapped_length (CONTEXT(kc), 
					 K5DATA(kc)->crypto, data_len);
d155 1
a155 1
    if (krb5_net_read (CONTEXT(kc), &fd, buf, outer_len) != outer_len)
d158 1
a158 2
    ret = krb5_decrypt (CONTEXT(kc), K5DATA(kc)->crypto, 
			KRB5_KU_OTHER_ENCRYPTED,
d161 1
a161 1
	krb5_warn (CONTEXT(kc), ret, "krb5_decrypt");
d182 2
d189 1
a189 2
    ret = krb5_encrypt (CONTEXT(kc), K5DATA(kc)->crypto, 
			KRB5_KU_OTHER_ENCRYPTED,
d192 1
a192 1
	krb5_warn (CONTEXT(kc), ret, "krb5_write");
d202 2
a203 2
    if (krb5_net_write (CONTEXT(kc), &fd, tmp, 4) != 4 ||
	krb5_net_write (CONTEXT(kc), &fd, data.data, outlen) != outlen) {
d226 1
a226 1
	krb5_warn (CONTEXT(kc), errno, "read");
d240 1
d249 1
a249 1
	krb5_warn (CONTEXT(kc), errno, "krb5_read");
d253 1
a253 1
    return krb5_net_write (CONTEXT(kc), &to_fd, buf, len);
d269 1
a269 1
	    krb5_warnx (CONTEXT(kc), "fd too large");
d279 1
a279 1
	    krb5_warn (CONTEXT(kc), errno, "select");
d303 2
d308 1
a308 1
    ret = krb5_unparse_name (CONTEXT(kc), K5DATA(kc)->client, &tmp);
d310 1
a310 1
	krb5_err (CONTEXT(kc), 1, ret, "krb5_unparse_name");
d313 1
a313 1
    return !krb5_kuserok (CONTEXT(kc), K5DATA(kc)->client, user);
d335 2
a336 4
    if (kc->data == NULL) {
	syslog (LOG_ERR, "failed to malloc %u bytes", sizeof(krb5_kx_context));
	exit(1);
    }
d340 2
a341 4
    if (ret) {
	syslog (LOG_ERR, "failed initialise krb5 context");
	exit(1);
    }
d354 2
d374 2
a375 2
    krb5_openlog(CONTEXT(kc), "kxd", &K5DATA(kc)->log);
    krb5_set_warn_dest(CONTEXT(kc), K5DATA(kc)->log);
d377 1
a377 1
    ret = krb5_sock_to_principal (CONTEXT(kc), sock, "host",
d381 1
a381 1
		krb5_get_err_text (CONTEXT(kc), ret));
d385 1
a385 1
    ret = krb5_recvauth (CONTEXT(kc),
d393 1
a393 1
    krb5_free_principal (CONTEXT(kc), server);
d396 1
a396 1
		krb5_get_err_text (CONTEXT(kc), ret));
d400 1
a400 1
    ret = krb5_auth_con_getkey (CONTEXT(kc), auth_context, &K5DATA(kc)->keyblock);
d403 1
a403 1
		krb5_get_err_text (CONTEXT(kc), ret));
d407 1
a407 1
    ret = krb5_crypto_init (CONTEXT(kc), K5DATA(kc)->keyblock, 0, &K5DATA(kc)->crypto);
d410 1
a410 1
		krb5_get_err_text (CONTEXT(kc), ret));
d414 1
a414 1
    K5DATA(kc)->client = ticket->client;
d416 1
a416 1
    krb5_free_ticket (CONTEXT(kc), ticket);
@


1.1.1.3
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: krb5.c,v 1.13 2005/04/20 10:39:33 lha Exp $");
d334 1
a334 2
	syslog (LOG_ERR, "failed to malloc %lu bytes", 
		(unsigned long)sizeof(krb5_kx_context));
@


