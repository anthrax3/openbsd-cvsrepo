head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	HEIMDAL_0_7_2:1.1.1.5
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.04.22.10.01.19;	author reyk;	state dead;
branches;
next	1.4;

1.4
date	2013.06.17.19.11.38;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.17.18.44;	author hin;	state dead;
branches;
next	1.2;

1.2
date	2002.06.05.16.16.49;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.45.26;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.45.26;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.14.50;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.52.25;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.24;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.31.59;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2004 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rsh_locl.h"
RCSID("$Id: rsh.c,v 1.4 2013/06/17 19:11:38 robert Exp $");

enum auth_method auth_method;
#if defined(KRB5)
int do_encrypt       = -1;
#endif
#ifdef KRB5
int do_unique_tkfile = 0;
char *unique_tkfile  = NULL;
char tkfile[MAXPATHLEN];
int do_forward       = -1;
int do_forwardable   = -1;
krb5_context context;
krb5_keyblock *keyblock;
krb5_crypto crypto;
#endif
int sock_debug	     = 0;

#ifdef KRB5
static int use_v5 = -1;
#endif
#if defined(KRB5)
static int use_only_broken = 0;
#else
static int use_only_broken = 1;
#endif
static int use_broken = 1;
static char *port_str;
static const char *user;
static int do_version;
static int do_help;
static int do_errsock = 1;
#ifdef KRB5
static char *protocol_version_str;
static int protocol_version = 2;
#endif

/*
 *
 */

static int input = 1;		/* Read from stdin */

static int
rsh_loop (int s, int errsock)
{
    fd_set real_readset;
    int count = 1;

#ifdef KRB5
    if(auth_method == AUTH_KRB5 && protocol_version == 2)
	init_ivecs(1, errsock != -1);
#endif

    if (s >= FD_SETSIZE || (errsock != -1 && errsock >= FD_SETSIZE))
	errx (1, "fd too large");

    FD_ZERO(&real_readset);
    FD_SET(s, &real_readset);
    if (errsock != -1) {
	FD_SET(errsock, &real_readset);
	++count;
    }
    if(input)
	FD_SET(STDIN_FILENO, &real_readset);

    for (;;) {
	int ret;
	fd_set readset;
	char buf[RSH_BUFSIZ];

	readset = real_readset;
	ret = select (max(s, errsock) + 1, &readset, NULL, NULL, NULL);
	if (ret < 0) {
	    if (errno == EINTR)
		continue;
	    else
		err (1, "select");
	}
	if (FD_ISSET(s, &readset)) {
	    ret = do_read (s, buf, sizeof(buf), ivec_in[0]);
	    if (ret < 0)
		err (1, "read");
	    else if (ret == 0) {
		close (s);
		FD_CLR(s, &real_readset);
		if (--count == 0)
		    return 0;
	    } else
		net_write (STDOUT_FILENO, buf, ret);
	}
	if (errsock != -1 && FD_ISSET(errsock, &readset)) {
	    ret = do_read (errsock, buf, sizeof(buf), ivec_in[1]);
	    if (ret < 0)
		err (1, "read");
	    else if (ret == 0) {
		close (errsock);
		FD_CLR(errsock, &real_readset);
		if (--count == 0)
		    return 0;
	    } else
		net_write (STDERR_FILENO, buf, ret);
	}
	if (FD_ISSET(STDIN_FILENO, &readset)) {
	    ret = read (STDIN_FILENO, buf, sizeof(buf));
	    if (ret < 0)
		err (1, "read");
	    else if (ret == 0) {
		close (STDIN_FILENO);
		FD_CLR(STDIN_FILENO, &real_readset);
		shutdown (s, SHUT_WR);
	    } else
		do_write (s, buf, ret, ivec_out[0]);
	}
    }
}

#ifdef KRB5
/*
 * Send forward information on `s' for host `hostname', them being
 * forwardable themselves if `forwardable'
 */

static int
krb5_forward_cred (krb5_auth_context auth_context,
		   int s,
		   const char *hostname,
		   int forwardable)
{
    krb5_error_code ret;
    krb5_ccache     ccache;
    krb5_creds      creds;
    krb5_kdc_flags  flags;
    krb5_data       out_data;
    krb5_principal  principal;

    memset (&creds, 0, sizeof(creds));

    ret = krb5_cc_default (context, &ccache);
    if (ret) {
	warnx ("could not forward creds: krb5_cc_default: %s",
	       krb5_get_err_text (context, ret));
	return 1;
    }

    ret = krb5_cc_get_principal (context, ccache, &principal);
    if (ret) {
	warnx ("could not forward creds: krb5_cc_get_principal: %s",
	       krb5_get_err_text (context, ret));
	return 1;
    }

    creds.client = principal;

    ret = krb5_make_principal(context,
			      &creds.server,
			      principal->realm,
			      "krbtgt",
			      principal->realm,
			      NULL);

    if (ret) {
	warnx ("could not forward creds: krb5_make_principal: %s",
	       krb5_get_err_text (context, ret));
	return 1;
    }

    creds.times.endtime = 0;

    flags.i = 0;
    flags.b.forwarded   = 1;
    flags.b.forwardable = forwardable;

    ret = krb5_get_forwarded_creds (context,
				    auth_context,
				    ccache,
				    flags.i,
				    hostname,
				    &creds,
				    &out_data);
    if (ret) {
	warnx ("could not forward creds: krb5_get_forwarded_creds: %s",
	       krb5_get_err_text (context, ret));
	return 1;
    }

    ret = krb5_write_message (context,
			      (void *)&s,
			      &out_data);
    krb5_data_free (&out_data);

    if (ret)
	warnx ("could not forward creds: krb5_write_message: %s",
	       krb5_get_err_text (context, ret));
    return 0;
}

static int sendauth_version_error;

static int
send_krb5_auth(int s,
	       struct sockaddr *thisaddr,
	       struct sockaddr *thataddr,
	       const char *hostname,
	       const char *remote_user,
	       const char *local_user,
	       size_t cmd_len,
	       const char *cmd)
{
    krb5_principal server;
    krb5_data cksum_data;
    int status;
    size_t len;
    krb5_auth_context auth_context = NULL;
    const char *protocol_string = NULL;
    krb5_flags ap_opts;
    char *str;

    status = krb5_sname_to_principal(context,
				     hostname,
				     "host",
				     KRB5_NT_SRV_HST,
				     &server);
    if (status) {
	warnx ("%s: %s", hostname, krb5_get_err_text(context, status));
	return 1;
    }

    if(do_encrypt == -1) {
	krb5_appdefault_boolean(context, NULL,
				krb5_principal_get_realm(context, server),
				"encrypt",
				FALSE,
				&do_encrypt);
    }

    cksum_data.length = asprintf (&str,
				  "%u:%s%s%s",
				  ntohs(socket_get_port(thataddr)),
				  do_encrypt ? "-x " : "",
				  cmd,
				  remote_user);
    if (str == NULL) {
	warnx ("%s: failed to allocate command", hostname);
	return 1;
    }
    cksum_data.data = str;

    ap_opts = 0;

    if(do_encrypt)
	ap_opts |= AP_OPTS_MUTUAL_REQUIRED;

    switch(protocol_version) {
    case 2:
	ap_opts |= AP_OPTS_USE_SUBKEY;
	protocol_string = KCMD_NEW_VERSION;
	break;
    case 1:
	protocol_string = KCMD_OLD_VERSION;
	key_usage = KRB5_KU_OTHER_ENCRYPTED;
	break;
    default:
	abort();
    }

    status = krb5_sendauth (context,
			    &auth_context,
			    &s,
			    protocol_string,
			    NULL,
			    server,
			    ap_opts,
			    &cksum_data,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    NULL);

    /* do this while we have a principal */
    if(do_forward == -1 || do_forwardable == -1) {
	krb5_const_realm realm = krb5_principal_get_realm(context, server);
	if (do_forwardable == -1)
	    krb5_appdefault_boolean(context, NULL, realm,
				    "forwardable", FALSE,
				    &do_forwardable);
	if (do_forward == -1)
	    krb5_appdefault_boolean(context, NULL, realm,
				    "forward", FALSE,
				    &do_forward);
    }

    krb5_free_principal(context, server);
    krb5_data_free(&cksum_data);

    if (status) {
	if(status == KRB5_SENDAUTH_REJECTED &&
	   protocol_version == 2 && protocol_version_str == NULL)
	    sendauth_version_error = 1;
	else
	    krb5_warn(context, status, "%s", hostname);
	return 1;
    }

    status = krb5_auth_con_getlocalsubkey (context, auth_context, &keyblock);
    if(keyblock == NULL)
	status = krb5_auth_con_getkey (context, auth_context, &keyblock);
    if (status) {
	warnx ("krb5_auth_con_getkey: %s", krb5_get_err_text(context, status));
	return 1;
    }

    status = krb5_auth_con_setaddrs_from_fd (context,
					     auth_context,
					     &s);
    if (status) {
        warnx("krb5_auth_con_setaddrs_from_fd: %s",
	      krb5_get_err_text(context, status));
        return(1);
    }

    status = krb5_crypto_init(context, keyblock, 0, &crypto);
    if(status) {
	warnx ("krb5_crypto_init: %s", krb5_get_err_text(context, status));
	return 1;
    }

    len = strlen(remote_user) + 1;
    if (net_write (s, remote_user, len) != len) {
	warn ("write");
	return 1;
    }
    if (do_encrypt && net_write (s, "-x ", 3) != 3) {
	warn ("write");
	return 1;
    }
    if (net_write (s, cmd, cmd_len) != cmd_len) {
	warn ("write");
	return 1;
    }

    if (do_unique_tkfile) {
	if (net_write (s, tkfile, strlen(tkfile)) != strlen(tkfile)) {
	    warn ("write");
	    return 1;
	}
    }
    len = strlen(local_user) + 1;
    if (net_write (s, local_user, len) != len) {
	warn ("write");
	return 1;
    }

    if (!do_forward
	|| krb5_forward_cred (auth_context, s, hostname, do_forwardable)) {
	/* Empty forwarding info */

	u_char zero[4] = {0, 0, 0, 0};
	write (s, &zero, 4);
    }
    krb5_auth_con_free (context, auth_context);
    return 0;
}

#endif /* KRB5 */

static int
send_broken_auth(int s,
		 struct sockaddr *thisaddr,
		 struct sockaddr *thataddr,
		 const char *hostname,
		 const char *remote_user,
		 const char *local_user,
		 size_t cmd_len,
		 const char *cmd)
{
    size_t len;

    len = strlen(local_user) + 1;
    if (net_write (s, local_user, len) != len) {
	warn ("write");
	return 1;
    }
    len = strlen(remote_user) + 1;
    if (net_write (s, remote_user, len) != len) {
	warn ("write");
	return 1;
    }
    if (net_write (s, cmd, cmd_len) != cmd_len) {
	warn ("write");
	return 1;
    }
    return 0;
}

static int
proto (int s, int errsock,
       const char *hostname, const char *local_user, const char *remote_user,
       const char *cmd, size_t cmd_len,
       int (*auth_func)(int s,
			struct sockaddr *this, struct sockaddr *that,
			const char *hostname, const char *remote_user,
			const char *local_user, size_t cmd_len,
			const char *cmd))
{
    int errsock2;
    char buf[BUFSIZ];
    char *p;
    size_t len;
    char reply;
    struct sockaddr_storage thisaddr_ss;
    struct sockaddr *thisaddr = (struct sockaddr *)&thisaddr_ss;
    struct sockaddr_storage thataddr_ss;
    struct sockaddr *thataddr = (struct sockaddr *)&thataddr_ss;
    struct sockaddr_storage erraddr_ss;
    struct sockaddr *erraddr = (struct sockaddr *)&erraddr_ss;
    socklen_t addrlen;
    int ret;

    addrlen = sizeof(thisaddr_ss);
    if (getsockname (s, thisaddr, &addrlen) < 0) {
	warn ("getsockname(%s)", hostname);
	return 1;
    }
    addrlen = sizeof(thataddr_ss);
    if (getpeername (s, thataddr, &addrlen) < 0) {
	warn ("getpeername(%s)", hostname);
	return 1;
    }

    if (errsock != -1) {

	addrlen = sizeof(erraddr_ss);
	if (getsockname (errsock, erraddr, &addrlen) < 0) {
	    warn ("getsockname");
	    return 1;
	}

	if (listen (errsock, 1) < 0) {
	    warn ("listen");
	    return 1;
	}

	p = buf;
	snprintf (p, sizeof(buf), "%u",
		  ntohs(socket_get_port(erraddr)));
	len = strlen(buf) + 1;
	if(net_write (s, buf, len) != len) {
	    warn ("write");
	    close (errsock);
	    return 1;
	}


	for (;;) {
	    fd_set fdset;

	    if (errsock >= FD_SETSIZE || s >= FD_SETSIZE)
		errx (1, "fd too large");

	    FD_ZERO(&fdset);
	    FD_SET(errsock, &fdset);
	    FD_SET(s, &fdset);

	    ret = select (max(errsock, s) + 1, &fdset, NULL, NULL, NULL);
	    if (ret < 0) {
		if (errno == EINTR)
		    continue;
		warn ("select");
		close (errsock);
		return 1;
	    }
	    if (FD_ISSET(errsock, &fdset)) {
		errsock2 = accept (errsock, NULL, NULL);
		close (errsock);
		if (errsock2 < 0) {
		    warn ("accept");
		    return 1;
		}
		break;
	    }

	    /*
	     * there should not arrive any data on this fd so if it's
	     * readable it probably indicates that the other side when
	     * away.
	     */

	    if (FD_ISSET(s, &fdset)) {
		warnx ("socket closed");
		close (errsock);
		errsock2 = -1;
		break;
	    }
	}
    } else {
	if (net_write (s, "0", 2) != 2) {
	    warn ("write");
	    return 1;
	}
	errsock2 = -1;
    }

    if ((*auth_func)(s, thisaddr, thataddr, hostname,
		     remote_user, local_user,
		     cmd_len, cmd)) {
	close (errsock2);
	return 1;
    }

    ret = net_read (s, &reply, 1);
    if (ret < 0) {
	warn ("read");
	close (errsock2);
	return 1;
    } else if (ret == 0) {
	warnx ("unexpected EOF from %s", hostname);
	close (errsock2);
	return 1;
    }
    if (reply != 0) {

	warnx ("Error from rshd at %s:", hostname);

	while ((ret = read (s, buf, sizeof(buf))) > 0)
	    write (STDOUT_FILENO, buf, ret);
        write (STDOUT_FILENO,"\n",1);
	close (errsock2);
	return 1;
    }

    if (sock_debug) {
	int one = 1;
	if (setsockopt(s, SOL_SOCKET, SO_DEBUG, (void *)&one, sizeof(one)) < 0)
	    warn("setsockopt remote");
	if (errsock2 != -1 &&
	    setsockopt(errsock2, SOL_SOCKET, SO_DEBUG,
		       (void *)&one, sizeof(one)) < 0)
	    warn("setsockopt stderr");
    }

    return rsh_loop (s, errsock2);
}

/*
 * Return in `res' a copy of the concatenation of `argc, argv' into
 * malloced space.  */

static size_t
construct_command (char **res, int argc, char **argv)
{
    int i;
    size_t len = 0;
    char *tmp;

    for (i = 0; i < argc; ++i)
	len += strlen(argv[i]) + 1;
    len = max (1, len);
    tmp = malloc (len);
    if (tmp == NULL)
	errx (1, "malloc %lu failed", (unsigned long)len);

    *tmp = '\0';
    for (i = 0; i < argc - 1; ++i) {
	strlcat (tmp, argv[i], len);
	strlcat (tmp, " ", len);
    }
    if (argc > 0)
	strlcat (tmp, argv[argc-1], len);
    *res = tmp;
    return len;
}

static char *
print_addr (const struct sockaddr *sa)
{
    char addr_str[256];
    char *res;
    const char *as = NULL;

    if(sa->sa_family == AF_INET)
	as = inet_ntop (sa->sa_family, &((struct sockaddr_in*)sa)->sin_addr,
			addr_str, sizeof(addr_str));
#ifdef HAVE_INET6
    else if(sa->sa_family == AF_INET6)
	as = inet_ntop (sa->sa_family, &((struct sockaddr_in6*)sa)->sin6_addr,
			addr_str, sizeof(addr_str));
#endif
    if(as == NULL)
	return NULL;
    res = strdup(as);
    if (res == NULL)
	errx (1, "malloc: out of memory");
    return res;
}

static int
doit_broken (int argc,
	     char **argv,
	     int hostindex,
	     struct addrinfo *ai,
	     const char *remote_user,
	     const char *local_user,
	     int priv_socket1,
	     int priv_socket2,
	     const char *cmd,
	     size_t cmd_len)
{
    struct addrinfo *a;

    if (connect (priv_socket1, ai->ai_addr, ai->ai_addrlen) < 0) {
	int save_errno = errno;

	close(priv_socket1);
	close(priv_socket2);

	for (a = ai->ai_next; a != NULL; a = a->ai_next) {
	    pid_t pid;
	    char *adr = print_addr(a->ai_addr);
	    if(adr == NULL)
		continue;

	    pid = fork();
	    if (pid < 0)
		err (1, "fork");
	    else if(pid == 0) {
		char **new_argv;
		int i = 0;

		new_argv = malloc((argc + 2) * sizeof(*new_argv));
		if (new_argv == NULL)
		    errx (1, "malloc: out of memory");
		new_argv[i] = argv[i];
		++i;
		if (hostindex == i)
		    new_argv[i++] = adr;
		new_argv[i++] = "-K";
		for(; i <= argc; ++i)
		    new_argv[i] = argv[i - 1];
		if (hostindex > 1)
		    new_argv[hostindex + 1] = adr;
		new_argv[argc + 1] = NULL;
		execv(PATH_RSH, new_argv);
		err(1, "execv(%s)", PATH_RSH);
	    } else {
		int status;
		free(adr);

		while(waitpid(pid, &status, 0) < 0)
		    ;
		if(WIFEXITED(status) && WEXITSTATUS(status) == 0)
		    return 0;
	    }
	}
	errno = save_errno;
	warn("%s", argv[hostindex]);
	return 1;
    } else {
	int ret;

	ret = proto (priv_socket1, priv_socket2,
		     argv[hostindex],
		     local_user, remote_user,
		     cmd, cmd_len,
		     send_broken_auth);
	return ret;
    }
}

#if defined(KRB5)
static int
doit (const char *hostname,
      struct addrinfo *ai,
      const char *remote_user,
      const char *local_user,
      const char *cmd,
      size_t cmd_len,
      int (*auth_func)(int s,
		       struct sockaddr *this, struct sockaddr *that,
		       const char *hostname, const char *remote_user,
		       const char *local_user, size_t cmd_len,
		       const char *cmd))
{
    int error;
    struct addrinfo *a;
    int socketfailed = 1;
    int ret;

    for (a = ai; a != NULL; a = a->ai_next) {
	int s;
	int errsock;

	s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
	if (s < 0)
	    continue;
	socketfailed = 0;
	if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
	    char addr[128];
	    if(getnameinfo(a->ai_addr, a->ai_addrlen,
			   addr, sizeof(addr), NULL, 0, NI_NUMERICHOST) == 0)
		warn ("connect(%s [%s])", hostname, addr);
	    else
		warn ("connect(%s)", hostname);
	    close (s);
	    continue;
	}
	if (do_errsock) {
	    struct addrinfo *ea, *eai;
	    struct addrinfo hints;

	    memset (&hints, 0, sizeof(hints));
	    hints.ai_socktype = a->ai_socktype;
	    hints.ai_protocol = a->ai_protocol;
	    hints.ai_family   = a->ai_family;
	    hints.ai_flags    = AI_PASSIVE;

	    errsock = -1;

	    error = getaddrinfo (NULL, "0", &hints, &eai);
	    if (error)
		errx (1, "getaddrinfo: %s", gai_strerror(error));
	    for (ea = eai; ea != NULL; ea = ea->ai_next) {
		errsock = socket (ea->ai_family, ea->ai_socktype,
				  ea->ai_protocol);
		if (errsock < 0)
		    continue;
		if (bind (errsock, ea->ai_addr, ea->ai_addrlen) < 0)
		    err (1, "bind");
		break;
	    }
	    if (errsock < 0)
		err (1, "socket");
	    freeaddrinfo (eai);
	} else
	    errsock = -1;

	ret = proto (s, errsock,
		     hostname,
		     local_user, remote_user,
		     cmd, cmd_len, auth_func);
	close (s);
	return ret;
    }
    if(socketfailed)
	warnx ("failed to contact %s", hostname);
    return -1;
}
#endif /* KRB5 */

struct getargs args[] = {
#ifdef KRB5
    { "krb5",	'5', arg_flag,		&use_v5,	"Use Kerberos V5" },
    { "forward", 'f', arg_flag,		&do_forward,	"Forward credentials [krb5]"},
    { "forwardable", 'F', arg_flag,	&do_forwardable,
      "Forward forwardable credentials [krb5]" },
    { NULL, 'G', arg_negative_flag,&do_forward,	"Don't forward credentials" },
    { "unique", 'u', arg_flag,	&do_unique_tkfile,
      "Use unique remote credentials cache [krb5]" },
    { "tkfile", 'U', arg_string,  &unique_tkfile,
      "Specifies remote credentials cache [krb5]" },
    { "protocol", 'P', arg_string,      &protocol_version_str,
      "Protocol version [krb5]", "protocol" },
#endif
    { "broken", 'K', arg_flag,		&use_only_broken, "Use only priv port" },
#if defined(KRB5)
    { "encrypt", 'x', arg_flag,		&do_encrypt,	"Encrypt connection" },
    { NULL, 	'z', arg_negative_flag,      &do_encrypt,
      "Don't encrypt connection", NULL },
#endif
    { NULL,	'd', arg_flag,		&sock_debug, "Enable socket debugging" },
    { "input",	'n', arg_negative_flag,	&input,		"Close stdin" },
    { "port",	'p', arg_string,	&port_str,	"Use this port",
      "port" },
    { "user",	'l', arg_string,	&user,		"Run as this user", "login" },
    { "stderr", 'e', arg_negative_flag, &do_errsock,	"Don't open stderr"},
#ifdef KRB5
#endif
    { "version", 0,  arg_flag,		&do_version,	NULL },
    { "help",	 0,  arg_flag,		&do_help,	NULL }
};

static void
usage (int ret)
{
    arg_printusage (args,
		    sizeof(args) / sizeof(args[0]),
		    NULL,
		    "[login@@]host [command]");
    exit (ret);
}

/*
 *
 */

int
main(int argc, char **argv)
{
    int priv_port1, priv_port2;
    int priv_socket1, priv_socket2;
    int argindex = 0;
    int error;
    struct addrinfo hints, *ai;
    int ret = 1;
    char *cmd;
    char *tmp;
    size_t cmd_len;
    const char *local_user;
    char *host = NULL;
    int host_index = -1;
#ifdef KRB5
    int status;
#endif
    uid_t uid;

    priv_port1 = priv_port2 = IPPORT_RESERVED-1;
    priv_socket1 = rresvport(&priv_port1);
    priv_socket2 = rresvport(&priv_port2);
    uid = getuid ();
    if (setuid (uid) || (uid != 0 && setuid(0) == 0))
	err (1, "setuid");

    setprogname (argv[0]);

    if (argc >= 2 && argv[1][0] != '-') {
	host = argv[host_index = 1];
	argindex = 1;
    }

    if (getarg (args, sizeof(args) / sizeof(args[0]), argc, argv,
		&argindex))
	usage (1);

    if (do_help)
	usage (0);

    if (do_version) {
	print_version (NULL);
	return 0;
    }

#ifdef KRB5
    if(protocol_version_str != NULL) {
	if(strcasecmp(protocol_version_str, "N") == 0)
	    protocol_version = 2;
	else if(strcasecmp(protocol_version_str, "O") == 0)
	    protocol_version = 1;
	else {
	    char *end;
	    int v;
	    v = strtol(protocol_version_str, &end, 0);
	    if(*end != '\0' || (v != 1 && v != 2)) {
		errx(1, "unknown protocol version \"%s\"",
		     protocol_version_str);
	    }
	    protocol_version = v;
	}
    }

    status = krb5_init_context (&context);
    if (status) {
	if(use_v5 == 1)
	    errx(1, "krb5_init_context failed: %d", status);
	else
	    use_v5 = 0;
    }

    /* request for forwardable on the command line means we should
       also forward */
    if (do_forwardable == 1)
	do_forward = 1;

#endif

    if (use_only_broken) {
#ifdef KRB5
	use_v5 = 0;
#endif
    }

    if(priv_socket1 < 0) {
	if (use_only_broken)
	    errx (1, "unable to bind reserved port: is rsh setuid root?");
	use_broken = 0;
    }

#if defined(KRB5)
    if (do_encrypt == 1 && use_only_broken)
	errx (1, "encryption not supported with old style authentication");
#endif



#ifdef KRB5
    if (do_unique_tkfile && unique_tkfile != NULL)
	errx (1, "Only one of -u and -U allowed.");

    if (do_unique_tkfile)
	strlcpy(tkfile,"-u ", sizeof(tkfile));
    else if (unique_tkfile != NULL) {
	if (strchr(unique_tkfile,' ') != NULL) {
	    warnx("Space is not allowed in tkfilename");
	    usage(1);
	}
	do_unique_tkfile = 1;
	snprintf (tkfile, sizeof(tkfile), "-U %s ", unique_tkfile);
    }
#endif

    if (host == NULL) {
	if (argc - argindex < 1)
	    usage (1);
	else
	    host = argv[host_index = argindex++];
    }

    if((tmp = strchr(host, '@@')) != NULL) {
	*tmp++ = '\0';
	user = host;
	host = tmp;
    }

    if (argindex == argc) {
	close (priv_socket1);
	close (priv_socket2);
	argv[0] = "rlogin";
	execvp ("rlogin", argv);
	err (1, "execvp rlogin");
    }

    local_user = get_default_username ();
    if (local_user == NULL)
	errx (1, "who are you?");

    if (user == NULL)
	user = local_user;

    cmd_len = construct_command(&cmd, argc - argindex, argv + argindex);

    /*
     * Try all different authentication methods
     */

#ifdef KRB5
    if (ret && use_v5) {
	memset (&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if(port_str == NULL) {
	    error = getaddrinfo(host, "kshell", &hints, &ai);
	    if(error == EAI_NONAME)
		error = getaddrinfo(host, "544", &hints, &ai);
	} else
	    error = getaddrinfo(host, port_str, &hints, &ai);

	if(error)
	    errx (1, "getaddrinfo: %s", gai_strerror(error));

	auth_method = AUTH_KRB5;
      again:
	ret = doit (host, ai, user, local_user, cmd, cmd_len,
		    send_krb5_auth);
	if(ret != 0 && sendauth_version_error &&
	   protocol_version == 2) {
	    protocol_version = 1;
	    goto again;
	}
	freeaddrinfo(ai);
    }
#endif
    if (ret && use_broken) {
	memset (&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if(port_str == NULL) {
	    error = getaddrinfo(host, "shell", &hints, &ai);
	    if(error == EAI_NONAME)
		error = getaddrinfo(host, "514", &hints, &ai);
	} else
	    error = getaddrinfo(host, port_str, &hints, &ai);

	if(error)
	    errx (1, "getaddrinfo: %s", gai_strerror(error));

	auth_method = AUTH_BROKEN;
	ret = doit_broken (argc, argv, host_index, ai,
			   user, local_user,
			   priv_socket1,
			   do_errsock ? priv_socket2 : -1,
			   cmd, cmd_len);
	freeaddrinfo(ai);
    }
    free(cmd);
    return ret;
}
@


1.4
log
@2nd part of:
update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.
@
text
@d35 1
a35 1
RCSID("$Id$");
@


1.3
log
@These files are not use by us, so they're removed to make the tree
a little bit leaner, and to get rid of some bad string functions.
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d35 1
a35 1
RCSID("$KTH: rsh.c,v 1.62 2001/08/15 19:42:59 joda Exp $");
d38 1
d40 2
a41 2
int do_forward       = -1;
int do_forwardable   = -1;
d45 2
a49 3
#ifdef KRB4
des_key_schedule schedule;
des_cblock iv;
d53 2
a54 2
#ifdef KRB4
static int use_v4 = -1;
d56 1
a56 1
static int use_v5 = -1;
d58 3
d67 4
d79 1
a79 1
loop (int s, int errsock)
d84 6
a89 1
    if (s >= FD_SETSIZE || errsock >= FD_SETSIZE)
d91 1
a91 1
    
d115 1
a115 1
	    ret = do_read (s, buf, sizeof(buf));
d127 1
a127 1
	    ret = do_read (errsock, buf, sizeof(buf));
d147 1
a147 1
		do_write (s, buf, ret);
d152 1
a152 43
#ifdef KRB4
static int
send_krb4_auth(int s,
	       struct sockaddr *thisaddr,
	       struct sockaddr *thataddr,
	       const char *hostname,
	       const char *remote_user,
	       const char *local_user,
	       size_t cmd_len,
	       const char *cmd)
{
    KTEXT_ST text;
    CREDENTIALS cred;
    MSG_DAT msg;
    int status;
    size_t len;

    status = krb_sendauth (do_encrypt ? KOPT_DO_MUTUAL : 0,
			   s, &text, "rcmd",
			   (char *)hostname, krb_realmofhost (hostname),
			   getpid(), &msg, &cred, schedule,
			   (struct sockaddr_in *)thisaddr,
			   (struct sockaddr_in *)thataddr,
			   KCMD_VERSION);
    if (status != KSUCCESS) {
	warnx("%s: %s", hostname, krb_get_err_text(status));
	return 1;
    }
    memcpy (iv, cred.session, sizeof(iv));

    len = strlen(remote_user) + 1;
    if (net_write (s, remote_user, len) != len) {
	warn("write");
	return 1;
    }
    if (net_write (s, cmd, cmd_len) != cmd_len) {
	warn("write");
	return 1;
    }
    return 0;
}
#endif /* KRB4 */

d188 7
a194 8
    
    ret = krb5_build_principal (context,
				&creds.server,
				strlen(principal->realm),
				principal->realm,
				"krbtgt",
				principal->realm,
				NULL);
d197 1
a197 1
	warnx ("could not forward creds: krb5_build_principal: %s",
d232 2
d249 3
d263 9
a271 1
    cksum_data.length = asprintf ((char **)&cksum_data.data,
d277 23
d304 1
a304 1
			    KCMD_VERSION,
d307 1
a307 1
			    do_encrypt ? AP_OPTS_MUTUAL_REQUIRED : 0,
d314 17
d332 5
a336 1
	warnx("%s: %s", hostname, krb5_get_err_text(context, status));
d340 3
a342 1
    status = krb5_auth_con_getkey (context, auth_context, &keyblock);
d400 2
d544 1
a544 1
    } 
d569 1
a569 1
	if (setsockopt(s, SOL_SOCKET, SO_DEBUG, &one, sizeof(one)) < 0)
d572 2
a573 1
	    setsockopt(errsock2, SOL_SOCKET, SO_DEBUG, &one, sizeof(one)) < 0)
d577 1
a577 1
    return loop (s, errsock2);
d596 1
a596 1
	errx (1, "malloc %u failed", len);
d600 2
a601 2
	strcat (tmp, argv[i]);
	strcat (tmp, " ");
d604 1
a604 1
	strcat (tmp, argv[argc-1]);
d610 1
a610 1
print_addr (const struct sockaddr_in *sin)
d614 1
d616 11
a626 2
    inet_ntop (AF_INET, &sin->sin_addr, addr_str, sizeof(addr_str));
    res = strdup(addr_str);
d635 2
a636 2
	     int optind,
	     const char *host,
a638 1
	     int port,
d644 1
a644 9
    struct addrinfo *ai, *a;
    struct addrinfo hints;
    int error;
    char portstr[NI_MAXSERV];

    memset (&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    hints.ai_family   = AF_INET;
a645 8
    snprintf (portstr, sizeof(portstr), "%u", ntohs(port));

    error = getaddrinfo (host, portstr, &hints, &ai);
    if (error) {
	warnx ("%s: %s", host, gai_strerror(error));
	return 1;
    }
    
d647 1
a647 4
	if (ai->ai_next == NULL) {
	    freeaddrinfo (ai);
	    return 1;
	}
d654 3
a663 1
		struct sockaddr_in *sin = (struct sockaddr_in *)a->ai_addr;
d670 2
a671 2
		if (optind == i)
		    new_argv[i++] = print_addr (sin);
d675 2
a676 2
		if (optind > 1)
		    new_argv[optind + 1] = print_addr(sin);
d682 1
a682 2

		freeaddrinfo (ai);
d690 2
a695 2
	freeaddrinfo (ai);

d697 1
a697 1
		     argv[optind],
d705 1
d708 1
a710 1
      int port,
a712 1
      int do_errsock,
a718 2
    struct addrinfo *ai, *a;
    struct addrinfo hints;
d720 1
a720 1
    char portstr[NI_MAXSERV];
a723 12
    memset (&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    snprintf (portstr, sizeof(portstr), "%u", ntohs(port));

    error = getaddrinfo (hostname, portstr, &hints, &ai);
    if (error) {
	errx (1, "%s: %s", hostname, gai_strerror(error));
	return -1;
    }
    
d729 1
a729 1
	if (s < 0) 
d734 1
a734 1
	    if(getnameinfo(a->ai_addr, a->ai_addrlen, 
d771 1
a771 2
    
	freeaddrinfo (ai);
a780 1
    freeaddrinfo (ai);
d783 1
d786 12
a797 2
#ifdef KRB4
    { "krb4",	'4', arg_flag,		&use_v4,	"Use Kerberos V4" },
a798 1
    { "krb5",	'5', arg_flag,		&use_v5,	"Use Kerberos V5" },
d800 1
a800 2
    { NULL,	'd', arg_flag,		&sock_debug, "Enable socket debugging" },
    { "input",	'n', arg_negative_flag,	&input,		"Close stdin" },
d804 3
a806 8
    { "forward", 'f', arg_flag,		&do_forward,	"Forward credentials"},
    { NULL, 'G', arg_negative_flag,&do_forward,	"Don't forward credentials" },
    { "forwardable", 'F', arg_flag,	&do_forwardable,
      "Forward forwardable credentials" },
    { "unique", 'u', arg_flag,	&do_unique_tkfile,
      "Use unique remote tkfile" },
    { "tkfile", 'U', arg_string,  &unique_tkfile,
      "Use that remote tkfile" },
d808 2
a809 2
      "number-or-service" },
    { "user",	'l', arg_string,	&user,		"Run as this user" },
d811 2
d823 1
a823 1
		    "host [command]");
d836 3
a838 2
    int port = 0;
    int optind = 0;
d846 1
d848 1
d857 3
a859 1
    
d862 1
a862 1
	optind = 1;
d864 1
a864 5
    
    status = krb5_init_context (&context);
    if (status)
        errx(1, "krb5_init_context failed: %d", status);
      
d866 1
a866 1
		&optind))
d876 25
a900 23
	
    if (do_forwardable == -1)
	do_forwardable = krb5_config_get_bool (context, NULL,
					       "libdefaults",
					       "forwardable",
					       NULL);
	
    if (do_forward == -1)
	do_forward = krb5_config_get_bool (context, NULL,
					   "libdefaults",
					   "forward",
					   NULL);
    else if (do_forward == 0)
	do_forwardable = 0;

    if (do_encrypt == -1) {
	/* we want to tell the -x flag from the default encryption
           option */
	if(!krb5_config_get_bool (context, NULL,
				  "libdefaults",
				  "encrypt",
				  NULL))
	    do_encrypt = 0;
d903 3
a905 1
    if (do_forwardable)
d908 1
a908 6
#if defined(KRB4) && defined(KRB5)
    if(use_v4 == -1 && use_v5 == 1)
	use_v4 = 0;
    if(use_v5 == -1 && use_v4 == 1)
	use_v5 = 0;
#endif    
d911 2
a912 2
#ifdef KRB4
	use_v4 = 0;
a913 1
	use_v5 = 0;
d922 1
d925 2
d929 1
d934 1
a934 1
	strcpy(tkfile,"-u ");
d943 1
d946 1
a946 1
	if (argc - optind < 1)
d949 1
a949 1
	    host = argv[host_index = optind++];
d951 1
a951 1
    
d958 1
a958 1
    if (optind == argc) {
a965 15
    if (port_str) {
	struct servent *s = roken_getservbyname (port_str, "tcp");

	if (s)
	    port = s->s_port;
	else {
	    char *ptr;

	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		errx (1, "Bad port `%s'", port_str);
	    port = htons(port);
	}
    }

d973 2
a974 2
    cmd_len = construct_command(&cmd, argc - optind, argv + optind);
    
d979 1
d981 10
a990 1
	int tmp_port;
d992 2
a993 4
	if (port)
	    tmp_port = port;
	else
	    tmp_port = krb5_getportbyname (context, "kshell", "tcp", 544);
d996 2
a997 2
	ret = doit (host, user, local_user, tmp_port, cmd, cmd_len,
		    do_errsock,
d999 6
a1004 16
    }
#ifdef KRB4
    if (ret && use_v4) {
	int tmp_port;

	if (port)
	    tmp_port = port;
	else if (do_encrypt)
	    tmp_port = krb5_getportbyname (context, "ekshell", "tcp", 545);
	else
	    tmp_port = krb5_getportbyname (context, "kshell", "tcp", 544);

	auth_method = AUTH_KRB4;
	ret = doit (host, user, local_user, tmp_port, cmd, cmd_len,
		    do_errsock,
		    send_krb4_auth);
d1008 13
a1020 1
	int tmp_port;
a1021 4
	if(port)
	    tmp_port = port;
	else
	    tmp_port = krb5_getportbyname(context, "shell", "tcp", 514);
d1023 1
a1023 1
	ret = doit_broken (argc, argv, host_index, host,
a1024 1
			   tmp_port,
d1028 1
d1030 1
@


1.2
log
@Remove all uses of setprogname() and getprogname() in kerberosV subtree.
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: rsh.c,v 1.57 2000/12/31 07:36:54 assar Exp $");
d51 1
d53 11
d165 1
a165 1
	warnx ("%s: %s", hostname, krb_get_err_text(status));
d310 1
a310 1
	warnx ("%s: %s", hostname, krb5_get_err_text(context, status));
d537 9
a608 5
    if (priv_socket1 < 0) {
	warnx ("unable to bind reserved port: is rsh setuid root?");
	return 1;
    }

d701 1
d721 1
a721 1
	if (s < 0)
d723 1
d725 6
a730 1
	    warn ("connect(%s)", hostname);
d772 2
a773 1
    warnx ("failed to contact %s", hostname);
a777 12
#ifdef KRB4
static int use_v4 = -1;
#endif
static int use_v5 = -1;
static int use_only_broken = 0;
static int use_broken = 1;
static char *port_str;
static const char *user;
static int do_version;
static int do_help;
static int do_errsock = 1;

d780 1
a780 2
    { "krb4",	'4', arg_flag,		&use_v4,	"Use Kerberos V4",
      NULL },
d782 5
a786 8
    { "krb5",	'5', arg_flag,		&use_v5,	"Use Kerberos V5",
      NULL },
    { "broken", 'K', arg_flag,		&use_only_broken, "Use priv port",
      NULL },
    { "input",	'n', arg_negative_flag,	&input,		"Close stdin",
      NULL },
    { "encrypt", 'x', arg_flag,		&do_encrypt,	"Encrypt connection",
      NULL },
d789 2
a790 4
    { "forward", 'f', arg_flag,		&do_forward,	"Forward credentials",
      NULL },
    { "forward", 'G', arg_negative_flag,&do_forward,	"Forward credentials",
      NULL },
d792 1
a792 1
      "Forward forwardable credentials", NULL },
d794 1
a794 1
      "Use unique remote tkfile", NULL },
d796 1
a796 1
      "Use that remote tkfile", NULL },
d799 4
a802 7
    { "user",	'l', arg_string,	&user,		"Run as this user",
      NULL },
    { "stderr", 'e', arg_negative_flag, &do_errsock,	"don't open stderr"},
    { "version", 0,  arg_flag,		&do_version,	"Print version",
      NULL },
    { "help",	 0,  arg_flag,		&do_help,	NULL,
      NULL }
d828 1
a842 2
    set_progname (argv[0]);

d856 8
d878 9
a886 5
    if (do_encrypt == -1)
	do_encrypt = krb5_config_get_bool (context, NULL,
					   "libdefaults",
					   "encrypt",
					   NULL);
d905 9
a913 2
    if (do_help)
	usage (0);
a914 5
    if (do_version) {
	print_version (NULL);
	return 0;
    }
	
d935 6
d973 1
a973 1

a1015 2
	if (do_encrypt)
	    errx (1, "encryption not supported with priv port authentication");
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 1
RCSID("$KTH: rsh.c,v 1.58 2001/02/20 01:44:47 assar Exp $");
d839 1
a839 1
    setprogname (argv[0]);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: rsh.c,v 1.62 2001/08/15 19:42:59 joda Exp $");
a50 1
int sock_debug	     = 0;
a51 11
#ifdef KRB4
static int use_v4 = -1;
#endif
static int use_v5 = -1;
static int use_only_broken = 0;
static int use_broken = 1;
static char *port_str;
static const char *user;
static int do_version;
static int do_help;
static int do_errsock = 1;
d153 1
a153 1
	warnx("%s: %s", hostname, krb_get_err_text(status));
d298 1
a298 1
	warnx("%s: %s", hostname, krb5_get_err_text(context, status));
a524 9
    if (sock_debug) {
	int one = 1;
	if (setsockopt(s, SOL_SOCKET, SO_DEBUG, &one, sizeof(one)) < 0)
	    warn("setsockopt remote");
	if (errsock2 != -1 &&
	    setsockopt(errsock2, SOL_SOCKET, SO_DEBUG, &one, sizeof(one)) < 0)
	    warn("setsockopt stderr");
    }

d588 5
a684 1
    int socketfailed = 1;
d704 1
a704 1
	if (s < 0) 
a705 1
	socketfailed = 0;
d707 1
a707 6
	    char addr[128];
	    if(getnameinfo(a->ai_addr, a->ai_addrlen, 
			   addr, sizeof(addr), NULL, 0, NI_NUMERICHOST) == 0)
		warn ("connect(%s [%s])", hostname, addr);
	    else
		warn ("connect(%s)", hostname);
d749 1
a749 2
    if(socketfailed)
	warnx ("failed to contact %s", hostname);
d754 12
d768 2
a769 1
    { "krb4",	'4', arg_flag,		&use_v4,	"Use Kerberos V4" },
d771 8
a778 5
    { "krb5",	'5', arg_flag,		&use_v5,	"Use Kerberos V5" },
    { "broken", 'K', arg_flag,		&use_only_broken, "Use only priv port" },
    { NULL,	'd', arg_flag,		&sock_debug, "Enable socket debugging" },
    { "input",	'n', arg_negative_flag,	&input,		"Close stdin" },
    { "encrypt", 'x', arg_flag,		&do_encrypt,	"Encrypt connection" },
d781 4
a784 2
    { "forward", 'f', arg_flag,		&do_forward,	"Forward credentials"},
    { NULL, 'G', arg_negative_flag,&do_forward,	"Don't forward credentials" },
d786 1
a786 1
      "Forward forwardable credentials" },
d788 1
a788 1
      "Use unique remote tkfile" },
d790 1
a790 1
      "Use that remote tkfile" },
d793 7
a799 4
    { "user",	'l', arg_string,	&user,		"Run as this user" },
    { "stderr", 'e', arg_negative_flag, &do_errsock,	"Don't open stderr"},
    { "version", 0,  arg_flag,		&do_version,	NULL },
    { "help",	 0,  arg_flag,		&do_help,	NULL }
a824 1
    char *tmp;
a853 8
    if (do_help)
	usage (0);

    if (do_version) {
	print_version (NULL);
	return 0;
    }
	
d868 5
a872 9
    if (do_encrypt == -1) {
	/* we want to tell the -x flag from the default encryption
           option */
	if(!krb5_config_get_bool (context, NULL,
				  "libdefaults",
				  "encrypt",
				  NULL))
	    do_encrypt = 0;
    }
d891 6
a896 4
    if(priv_socket1 < 0) {
	if (use_only_broken)
	    errx (1, "unable to bind reserved port: is rsh setuid root?");
	use_broken = 0;
d898 1
a898 5

    if (do_encrypt == 1 && use_only_broken)
	errx (1, "encryption not supported with old style authentication");


a918 6
    
    if((tmp = strchr(host, '@@')) != NULL) {
	*tmp++ = '\0';
	user = host;
	host = tmp;
    }
d951 1
a951 1
    
d994 2
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: rsh.c,v 1.71 2003/04/16 20:37:20 joda Exp $");
a37 1
#if defined(KRB4) || defined(KRB5)
d39 2
a40 2
#endif
#ifdef KRB5
a43 2
int do_forward       = -1;
int do_forwardable   = -1;
a46 1
#endif
a55 1
#ifdef KRB5
a56 1
#endif
a63 2
static char *protocol_version_str;
static int protocol_version = 2;
d77 1
a77 6
#ifdef KRB5
    if(auth_method == AUTH_KRB5 && protocol_version == 2)
	init_ivecs(1);
#endif

    if (s >= FD_SETSIZE || (errsock != -1 && errsock >= FD_SETSIZE))
d103 1
a103 1
	    ret = do_read (s, buf, sizeof(buf), ivec_in[0]);
d115 1
a115 1
	    ret = do_read (errsock, buf, sizeof(buf), ivec_in[1]);
d135 1
a135 1
		do_write (s, buf, ret, ivec_out[0]);
d157 1
a157 2
    /* the normal default for krb4 should be to disable encryption */
    status = krb_sendauth ((do_encrypt == 1) ? KOPT_DO_MUTUAL : 0,
d163 1
a163 1
			   KCMD_OLD_VERSION);
a182 1
#ifdef KRB5
a262 2
static int sendauth_version_error;

a277 2
    const char *protocol_string = NULL;
    krb5_flags ap_opts;
a288 8
    if(do_encrypt == -1) {
	krb5_appdefault_boolean(context, NULL, 
				krb5_principal_get_realm(context, server), 
				"encrypt", 
				FALSE, 
				&do_encrypt);
    }

a295 18
    ap_opts = 0;

    if(do_encrypt)
	ap_opts |= AP_OPTS_MUTUAL_REQUIRED;

    switch(protocol_version) {
    case 2:
	ap_opts |= AP_OPTS_USE_SUBKEY;
	protocol_string = KCMD_NEW_VERSION;
	break;
    case 1:
	protocol_string = KCMD_OLD_VERSION;
	key_usage = KRB5_KU_OTHER_ENCRYPTED;
	break;
    default:
	abort();
    }
	
d299 1
a299 1
			    protocol_string,
d302 1
a302 1
			    ap_opts,
a308 17

    /* do this while we have a principal */
    if(do_forward == -1 || do_forwardable == -1) {
	krb5_const_realm realm = krb5_principal_get_realm(context, server);
	if (do_forwardable == -1)
	    krb5_appdefault_boolean(context, NULL, realm,
				    "forwardable", FALSE, 
				    &do_forwardable);
	if (do_forward == -1)
	    krb5_appdefault_boolean(context, NULL, realm,
				    "forward", FALSE, 
				    &do_forward);
    }
    
    krb5_free_principal(context, server);
    krb5_data_free(&cksum_data);

d310 1
a310 5
	if(status == KRB5_SENDAUTH_REJECTED && 
	   protocol_version == 2 && protocol_version_str == NULL)
	    sendauth_version_error = 1;
	else
	    krb5_warn(context, status, "%s", hostname);
d314 1
a314 3
    status = krb5_auth_con_getlocalsubkey (context, auth_context, &keyblock);
    if(keyblock == NULL)
	status = krb5_auth_con_getkey (context, auth_context, &keyblock);
a371 2
#endif /* KRB5 */

d539 1
a539 1
	if (setsockopt(s, SOL_SOCKET, SO_DEBUG, (void *)&one, sizeof(one)) < 0)
d542 1
a542 2
	    setsockopt(errsock2, SOL_SOCKET, SO_DEBUG,
		       (void *)&one, sizeof(one)) < 0)
d545 1
a545 1
    
d579 1
a579 1
print_addr (const struct sockaddr *sa)
a582 1
    const char *as = NULL;
d584 2
a585 11
    if(sa->sa_family == AF_INET)
	as = inet_ntop (sa->sa_family, &((struct sockaddr_in*)sa)->sin_addr, 
			addr_str, sizeof(addr_str));
#ifdef HAVE_INET6
    else if(sa->sa_family == AF_INET6)
	as = inet_ntop (sa->sa_family, &((struct sockaddr_in6*)sa)->sin6_addr, 
			addr_str, sizeof(addr_str));
#endif
    if(as == NULL)
	return NULL;
    res = strdup(as);
d594 2
a595 2
	     int hostindex,
	     struct addrinfo *ai,
d598 1
d604 4
a607 1
    struct addrinfo *a;
d609 13
d623 5
a627 2
	int save_errno = errno;
	
a632 3
	    char *adr = print_addr(a->ai_addr);
	    if(adr == NULL)
		continue;
d640 1
d647 2
a648 2
		if (hostindex == i)
		    new_argv[i++] = adr;
d652 2
a653 2
		if (hostindex > 1)
		    new_argv[hostindex + 1] = adr;
d659 2
a660 1
		free(adr);
a667 2
	errno = save_errno;
	warn("%s", argv[hostindex]);
d672 2
d675 1
a675 1
		     argv[hostindex],
a682 1
#if defined(KRB4) || defined(KRB5)
a684 1
      struct addrinfo *ai,
d687 1
d697 2
d700 1
a700 1
    struct addrinfo *a;
d704 12
d764 1
d774 1
a776 1
#endif /* KRB4 || KRB5 */
a781 1
#ifdef KRB5
a782 6
    { "forward", 'f', arg_flag,		&do_forward,	"Forward credentials (krb5)"},
    { NULL, 'G', arg_negative_flag,&do_forward,	"Don't forward credentials" },
    { "forwardable", 'F', arg_flag,	&do_forwardable,
      "Forward forwardable credentials" },
#endif
#if defined(KRB4) || defined(KRB5)
d784 2
d789 4
a792 2
#endif
#ifdef KRB5
d794 1
a794 1
      "Use unique remote tkfile (krb5)" },
d796 1
a796 4
      "Use that remote tkfile (krb5)" },
#endif
    { NULL,	'd', arg_flag,		&sock_debug, "Enable socket debugging" },
    { "input",	'n', arg_negative_flag,	&input,		"Close stdin" },
d798 2
a799 2
      "port" },
    { "user",	'l', arg_string,	&user,		"Run as this user", "login" },
a800 2
    { "protocol", 'P', arg_string,      &protocol_version_str, 
      "Protocol version", "protocol" },
d811 1
a811 1
		    "[login@@]host [command]");
d824 2
a825 3
    int argindex = 0;
    int error;
    struct addrinfo hints, *ai;
a832 1
#ifdef KRB5
a833 1
#endif
d847 1
a847 1
	argindex = 1;
d850 4
d855 1
a855 1
		&argindex))
d865 23
a887 16

    if(protocol_version_str != NULL) {
	if(strcasecmp(protocol_version_str, "N") == 0)
	    protocol_version = 2;
	else if(strcasecmp(protocol_version_str, "O") == 0)
	    protocol_version = 1;
	else {
	    char *end;
	    int v;
	    v = strtol(protocol_version_str, &end, 0);
	    if(*end != '\0' || (v != 1 && v != 2)) {
		errx(1, "unknown protocol version \"%s\"", 
		     protocol_version_str);
	    }
	    protocol_version = v;
	}
d890 1
a890 12
#ifdef KRB5
    status = krb5_init_context (&context);
    if (status) {
	if(use_v5 == 1)
	    errx(1, "krb5_init_context failed: %d", status);
	else
	    use_v5 = 0;
    }

    /* request for forwardable on the command line means we should
       also forward */
    if (do_forwardable == 1)
a892 2
#endif

a903 1
#ifdef KRB5
a904 1
#endif
a912 1
#if defined(KRB4) || defined(KRB5)
a914 2
#endif

a916 1
#ifdef KRB5
a929 1
#endif
d932 1
a932 1
	if (argc - argindex < 1)
d935 1
a935 1
	    host = argv[host_index = argindex++];
d944 1
a944 1
    if (argindex == argc) {
d952 15
d974 1
a974 1
    cmd_len = construct_command(&cmd, argc - argindex, argv + argindex);
a979 1
#ifdef KRB5
d981 1
a981 10
	memset (&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if(port_str == NULL) {
	    error = getaddrinfo(host, "kshell", &hints, &ai);
	    if(error == EAI_NONAME)
		error = getaddrinfo(host, "544", &hints, &ai);
	} else
	    error = getaddrinfo(host, port_str, &hints, &ai);
d983 4
a986 2
	if(error)
	    errx (1, "getaddrinfo: %s", gai_strerror(error));
d989 1
a989 2
      again:
	ret = doit (host, ai, user, local_user, cmd, cmd_len,
a991 6
	if(ret != 0 && sendauth_version_error && 
	   protocol_version == 2) {
	    protocol_version = 1;
	    goto again;
	}
	freeaddrinfo(ai);
a992 1
#endif
d995 8
a1002 16
	memset (&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if(port_str == NULL) {
	    if(do_encrypt) {
		error = getaddrinfo(host, "ekshell", &hints, &ai);
		if(error == EAI_NONAME)
		    error = getaddrinfo(host, "545", &hints, &ai);
	    } else {
		error = getaddrinfo(host, "kshell", &hints, &ai);
		if(error == EAI_NONAME)
		    error = getaddrinfo(host, "544", &hints, &ai);
	    }
	} else
	    error = getaddrinfo(host, port_str, &hints, &ai);
a1003 2
	if(error)
	    errx (1, "getaddrinfo: %s", gai_strerror(error));
d1005 1
a1005 1
	ret = doit (host, ai, user, local_user, cmd, cmd_len,
a1007 1
	freeaddrinfo(ai);
d1011 1
a1011 13
	memset (&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if(port_str == NULL) {
	    error = getaddrinfo(host, "shell", &hints, &ai);
	    if(error == EAI_NONAME)
		error = getaddrinfo(host, "514", &hints, &ai);
	} else
	    error = getaddrinfo(host, port_str, &hints, &ai);

	if(error)
	    errx (1, "getaddrinfo: %s", gai_strerror(error));
d1013 4
d1018 1
a1018 1
	ret = doit_broken (argc, argv, host_index, ai,
d1020 1
a1023 1
	freeaddrinfo(ai);
a1024 1
    free(cmd);
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: rsh.c,v 1.78.2.1 2005/12/28 18:00:05 lha Exp $");
a62 1
#if defined(KRB4) || defined(KRB5)
a63 3
#else
static int use_only_broken = 1;
#endif
a69 1
#ifdef KRB5
a71 1
#endif
d80 1
a80 1
rsh_loop (int s, int errsock)
d87 1
a87 1
	init_ivecs(1, errsock != -1);
a321 4
    if (cksum_data.length == -1) {
	warnx ("%s: failed to allocate command", hostname);
	return 1;
    }
d617 1
a617 1
    return rsh_loop (s, errsock2);
d636 1
a636 1
	errx (1, "malloc %lu failed", (unsigned long)len);
d640 2
a641 2
	strlcat (tmp, argv[i], len);
	strlcat (tmp, " ", len);
d644 1
a644 1
	strlcat (tmp, argv[argc-1], len);
d753 1
d832 2
a833 1
    { "forward", 'f', arg_flag,		&do_forward,	"Forward credentials [krb5]"},
d835 1
a835 8
      "Forward forwardable credentials [krb5]" },
    { NULL, 'G', arg_negative_flag,&do_forward,	"Don't forward credentials" },
    { "unique", 'u', arg_flag,	&do_unique_tkfile,
      "Use unique remote credentials cache [krb5]" },
    { "tkfile", 'U', arg_string,  &unique_tkfile,
      "Specifies remote credentials cache [krb5]" },
    { "protocol", 'P', arg_string,      &protocol_version_str, 
      "Protocol version [krb5]", "protocol" },
d837 1
a838 1
#if defined(KRB4) || defined(KRB5)
d843 6
d855 2
a856 2
#ifdef KRB5
#endif
a920 1
#ifdef KRB5
d938 1
d988 1
a988 1
	strlcpy(tkfile,"-u ", sizeof(tkfile));
d1052 1
d1085 1
@


