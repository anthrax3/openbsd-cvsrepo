head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	HEIMDAL_0_7_2:1.1.1.5
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.04.22.10.01.19;	author reyk;	state dead;
branches;
next	1.6;

1.6
date	2013.06.17.19.11.38;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.17.18.44;	author hin;	state dead;
branches;
next	1.4;

1.4
date	2002.06.05.16.16.49;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.06.09.10.01;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.09.07.05.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.45.27;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.45.27;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.14.52;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.52.25;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.24;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.31.59;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.7
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2007 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rsh_locl.h"
#include "login_locl.h"
RCSID("$Id: rshd.c,v 1.6 2013/06/17 19:11:38 robert Exp $");

int
login_access( struct passwd *user, char *from);
int
read_limits_conf(const char *file, const struct passwd *pwd);

#ifdef NEED_IRUSEROK_PROTO
int iruserok(uint32_t, int, const char *, const char *);
#endif

enum auth_method auth_method;

#ifdef KRB5
krb5_context context;
krb5_keyblock *keyblock;
krb5_crypto crypto;
#endif

#ifdef KRB5
krb5_ccache ccache, ccache2;
int kerberos_status = 0;
#endif

int do_encrypt = 0;

static int do_unique_tkfile           = 0;
static char tkfile[MAXPATHLEN] = "";

static int do_inetd = 1;
static char *port_str;
static int do_rhosts = 1;
static int do_kerberos = 0;
#define DO_KRB5 4
static int do_vacuous = 0;
static int do_log = 1;
static int do_newpag = 1;
static int do_addr_verify = 0;
static int do_keepalive = 1;
static int do_version;
static int do_help = 0;

static void
syslog_and_die (const char *m, ...)
    __attribute__ ((format (printf, 1, 2)));

static void
syslog_and_die (const char *m, ...)
{
    va_list args;

    va_start(args, m);
    vsyslog (LOG_ERR, m, args);
    va_end(args);
    exit (1);
}

static void
fatal (int, const char*, const char *, ...)
    __attribute__ ((noreturn, format (printf, 3, 4)));

static void
fatal (int sock, const char *what, const char *m, ...)
{
    va_list args;
    char buf[BUFSIZ];
    size_t len;

    *buf = 1;
    va_start(args, m);
    len = vsnprintf (buf + 1, sizeof(buf) - 1, m, args);
    len = min(len, sizeof(buf) - 1);
    va_end(args);
    if(what != NULL)
	syslog (LOG_ERR, "%s: %s: %s", what, strerror(errno), buf + 1);
    else
	syslog (LOG_ERR, "%s", buf + 1);
    net_write (sock, buf, len + 1);
    exit (1);
}

static char *
read_str (int s, size_t sz, char *expl)
{
    char *str = malloc(sz);
    char *p = str;
    if(str == NULL)
	fatal(s, NULL, "%s too long", expl);
    while(p < str + sz) {
	if(net_read(s, p, 1) != 1)
	    syslog_and_die("read: %s", strerror(errno));
	if(*p == '\0')
	    return str;
	p++;
    }
    fatal(s, NULL, "%s too long", expl);
}

static int
recv_bsd_auth (int s, u_char *buf,
	       struct sockaddr_in *thisaddr,
	       struct sockaddr_in *thataddr,
	       char **client_username,
	       char **server_username,
	       char **cmd)
{
    struct passwd *pwd;

    *client_username = read_str (s, USERNAME_SZ, "local username");
    *server_username = read_str (s, USERNAME_SZ, "remote username");
    *cmd = read_str (s, ARG_MAX + 1, "command");
    pwd = getpwnam(*server_username);
    if (pwd == NULL)
	fatal(s, NULL, "Login incorrect.");
    if (iruserok(thataddr->sin_addr.s_addr, pwd->pw_uid == 0,
		 *client_username, *server_username))
	fatal(s, NULL, "Login incorrect.");
    return 0;
}

#ifdef KRB5
static int
save_krb5_creds (int s,
                 krb5_auth_context auth_context,
                 krb5_principal client)

{
    int ret;
    krb5_data remote_cred;

    krb5_data_zero (&remote_cred);
    ret= krb5_read_message (context, (void *)&s, &remote_cred);
    if (ret) {
	krb5_data_free(&remote_cred);
	return 0;
    }
    if (remote_cred.length == 0)
	return 0;

    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, &ccache);
    if (ret) {
	krb5_data_free(&remote_cred);
	return 0;
    }

    krb5_cc_initialize(context,ccache,client);
    ret = krb5_rd_cred2(context, auth_context, ccache, &remote_cred);
    if(ret != 0)
	syslog(LOG_INFO|LOG_AUTH,
	       "reading creds: %s", krb5_get_err_text(context, ret));
    krb5_data_free (&remote_cred);
    if (ret)
	return 0;
    return 1;
}

static void
krb5_start_session (void)
{
    krb5_error_code ret;
    char *estr;

    ret = krb5_cc_resolve (context, tkfile, &ccache2);
    if (ret) {
	estr = krb5_get_error_string(context);
	syslog(LOG_WARNING, "resolve cred cache %s: %s",
	       tkfile,
	       estr ? estr : krb5_get_err_text(context, ret));
	free(estr);
	krb5_cc_destroy(context, ccache);
	return;
    }

    ret = krb5_cc_copy_cache (context, ccache, ccache2);
    if (ret) {
	estr = krb5_get_error_string(context);
	syslog(LOG_WARNING, "storing credentials: %s",
	       estr ? estr : krb5_get_err_text(context, ret));
	free(estr);
	krb5_cc_destroy(context, ccache);
	return ;
    }

    krb5_cc_close(context, ccache2);
    krb5_cc_destroy(context, ccache);
    return;
}

static int protocol_version;

static krb5_boolean
match_kcmd_version(const void *data, const char *version)
{
    if(strcmp(version, KCMD_NEW_VERSION) == 0) {
	protocol_version = 2;
	return TRUE;
    }
    if(strcmp(version, KCMD_OLD_VERSION) == 0) {
	protocol_version = 1;
	key_usage = KRB5_KU_OTHER_ENCRYPTED;
	return TRUE;
    }
    return FALSE;
}


static int
recv_krb5_auth (int s, u_char *buf,
		struct sockaddr *thisaddr,
		struct sockaddr *thataddr,
		char **client_username,
		char **server_username,
		char **cmd)
{
    uint32_t len;
    krb5_auth_context auth_context = NULL;
    krb5_ticket *ticket;
    krb5_error_code status;
    krb5_data cksum_data;
    krb5_principal server;
    char *str;

    if (memcmp (buf, "\x00\x00\x00\x13", 4) != 0)
	return -1;
    len = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | (buf[3]);

    if (net_read(s, buf, len) != len)
	syslog_and_die ("reading auth info: %s", strerror(errno));
    if (len != sizeof(KRB5_SENDAUTH_VERSION)
	|| memcmp (buf, KRB5_SENDAUTH_VERSION, len) != 0)
	syslog_and_die ("bad sendauth version: %.8s", buf);

    status = krb5_sock_to_principal (context,
				     s,
				     "host",
				     KRB5_NT_SRV_HST,
				     &server);
    if (status)
	syslog_and_die ("krb5_sock_to_principal: %s",
			krb5_get_err_text(context, status));

    status = krb5_recvauth_match_version(context,
					 &auth_context,
					 &s,
					 match_kcmd_version,
					 NULL,
					 server,
					 KRB5_RECVAUTH_IGNORE_VERSION,
					 NULL,
					 &ticket);
    krb5_free_principal (context, server);
    if (status)
	syslog_and_die ("krb5_recvauth: %s",
			krb5_get_err_text(context, status));

    *server_username = read_str (s, USERNAME_SZ, "remote username");
    *cmd = read_str (s, ARG_MAX + 1, "command");
    *client_username = read_str (s, ARG_MAX + 1, "local username");

    if(protocol_version == 2) {
	status = krb5_auth_con_getremotesubkey(context, auth_context,
					       &keyblock);
	if(status != 0 || keyblock == NULL)
	    syslog_and_die("failed to get remote subkey");
    } else if(protocol_version == 1) {
	status = krb5_auth_con_getkey (context, auth_context, &keyblock);
	if(status != 0 || keyblock == NULL)
	    syslog_and_die("failed to get key");
    }
    if (status != 0 || keyblock == NULL)
       syslog_and_die ("krb5_auth_con_getkey: %s",
                       krb5_get_err_text(context, status));

    status = krb5_crypto_init(context, keyblock, 0, &crypto);
    if(status)
	syslog_and_die("krb5_crypto_init: %s",
		       krb5_get_err_text(context, status));


    cksum_data.length = asprintf (&str,
				  "%u:%s%s",
				  ntohs(socket_get_port (thisaddr)),
				  *cmd,
				  *server_username);
    if (str == NULL)
	syslog_and_die ("asprintf: out of memory");
    cksum_data.data = str;

    status = krb5_verify_authenticator_checksum(context,
						auth_context,
						cksum_data.data,
						cksum_data.length);

    if (status)
	syslog_and_die ("krb5_verify_authenticator_checksum: %s",
			krb5_get_err_text(context, status));

    free (cksum_data.data);

    if (strncmp (*client_username, "-u ", 3) == 0) {
	do_unique_tkfile = 1;
	memmove (*client_username, *client_username + 3,
		 strlen(*client_username) - 2);
    }

    if (strncmp (*client_username, "-U ", 3) == 0) {
	char *end, *temp_tkfile;

	do_unique_tkfile = 1;
	if (strncmp (*client_username + 3, "FILE:", 5) == 0) {
	    temp_tkfile = tkfile;
	} else {
	    strlcpy (tkfile, "FILE:", sizeof(tkfile));
	    temp_tkfile = tkfile + 5;
	}
	end = strchr(*client_username + 3,' ');
	if (end == NULL)
	    syslog_and_die("missing argument after -U");
	snprintf(temp_tkfile, sizeof(tkfile) - (temp_tkfile - tkfile),
		 "%.*s",
		 (int)(end - *client_username - 3),
		 *client_username + 3);
	memmove (*client_username, end + 1, strlen(end+1)+1);
    }

    kerberos_status = save_krb5_creds (s, auth_context, ticket->client);

    if(!krb5_kuserok (context,
		      ticket->client,
		      *server_username))
	fatal (s, NULL, "Permission denied.");

    if (strncmp (*cmd, "-x ", 3) == 0) {
	do_encrypt = 1;
	memmove (*cmd, *cmd + 3, strlen(*cmd) - 2);
    } else {
	if(do_encrypt)
	    fatal (s, NULL, "Encryption is required.");
	do_encrypt = 0;
    }

    {
	char *name;

	if (krb5_unparse_name (context, ticket->client, &name) == 0) {
	    char addr_str[256];

	    if (inet_ntop (thataddr->sa_family,
			   socket_get_address (thataddr),
			   addr_str, sizeof(addr_str)) == NULL)
		strlcpy (addr_str, "unknown address",
				 sizeof(addr_str));

	    syslog(LOG_INFO|LOG_AUTH,
		   "kerberos v5 shell from %s on %s as %s, cmd '%.80s'",
		   name,
		   addr_str,
		   *server_username,
		   *cmd);
	    free (name);
	}
    }

    krb5_auth_con_free(context, auth_context);

    return 0;
}
#endif /* KRB5 */

static void
rshd_loop (int from0, int to0,
	   int to1,   int from1,
	   int to2,   int from2,
	   int have_errsock)
{
    fd_set real_readset;
    int max_fd;
    int count = 2;
    char *buf;

    if(from0 >= FD_SETSIZE || from1 >= FD_SETSIZE || from2 >= FD_SETSIZE)
	errx (1, "fd too large");

#ifdef KRB5
    if(auth_method == AUTH_KRB5 && protocol_version == 2)
	init_ivecs(0, have_errsock);
#endif

    FD_ZERO(&real_readset);
    FD_SET(from0, &real_readset);
    FD_SET(from1, &real_readset);
    FD_SET(from2, &real_readset);
    max_fd = max(from0, max(from1, from2)) + 1;

    buf = malloc(max(RSHD_BUFSIZ, RSH_BUFSIZ));
    if (buf == NULL)
	syslog_and_die("out of memory");

    for (;;) {
	int ret;
	fd_set readset = real_readset;

	ret = select (max_fd, &readset, NULL, NULL, NULL);
	if (ret < 0) {
	    if (errno == EINTR)
		continue;
	    else
		syslog_and_die ("select: %s", strerror(errno));
	}
	if (FD_ISSET(from0, &readset)) {
	    ret = do_read (from0, buf, RSHD_BUFSIZ, ivec_in[0]);
	    if (ret < 0)
		syslog_and_die ("read: %s", strerror(errno));
	    else if (ret == 0) {
		close (from0);
		close (to0);
		FD_CLR(from0, &real_readset);
	    } else
		net_write (to0, buf, ret);
	}
	if (FD_ISSET(from1, &readset)) {
	    ret = read (from1, buf, RSH_BUFSIZ);
	    if (ret < 0)
		syslog_and_die ("read: %s", strerror(errno));
	    else if (ret == 0) {
		close (from1);
		close (to1);
		FD_CLR(from1, &real_readset);
		if (--count == 0)
		    exit (0);
	    } else
		do_write (to1, buf, ret, ivec_out[0]);
	}
	if (FD_ISSET(from2, &readset)) {
	    ret = read (from2, buf, RSH_BUFSIZ);
	    if (ret < 0)
		syslog_and_die ("read: %s", strerror(errno));
	    else if (ret == 0) {
		close (from2);
		close (to2);
		FD_CLR(from2, &real_readset);
		if (--count == 0)
		    exit (0);
	    } else
		do_write (to2, buf, ret, ivec_out[1]);
	}
   }
}

/*
 * Used by `setup_copier' to create some pipe-like means of
 * communcation.  Real pipes would probably be the best thing, but
 * then the shell doesn't understand it's talking to rshd.  If
 * socketpair doesn't work everywhere, some autoconf magic would have
 * to be added here.
 *
 * If it fails creating the `pipe', it aborts by calling fatal.
 */

static void
pipe_a_like (int fd[2])
{
    if (socketpair (AF_UNIX, SOCK_STREAM, 0, fd) < 0)
	fatal (STDOUT_FILENO, "socketpair", "Pipe creation failed.");
}

/*
 * Start a child process and leave the parent copying data to and from it.  */

static void
setup_copier (int have_errsock)
{
    int p0[2], p1[2], p2[2];
    pid_t pid;

    pipe_a_like(p0);
    pipe_a_like(p1);
    pipe_a_like(p2);
    pid = fork ();
    if (pid < 0)
	fatal (STDOUT_FILENO, "fork", "Could not create child process.");
    if (pid == 0) { /* child */
	close (p0[1]);
	close (p1[0]);
	close (p2[0]);
	dup2 (p0[0], STDIN_FILENO);
	dup2 (p1[1], STDOUT_FILENO);
	dup2 (p2[1], STDERR_FILENO);
	close (p0[0]);
	close (p1[1]);
	close (p2[1]);
    } else { /* parent */
	close (p0[0]);
	close (p1[1]);
	close (p2[1]);

	if (net_write (STDOUT_FILENO, "", 1) != 1)
	    fatal (STDOUT_FILENO, "net_write", "Write failure.");

	rshd_loop (STDIN_FILENO, p0[1],
	      STDOUT_FILENO, p1[0],
	      STDERR_FILENO, p2[0],
	      have_errsock);
    }
}

/*
 * Is `port' a ``reserverd'' port?
 */

static int
is_reserved(u_short port)
{
    return ntohs(port) < IPPORT_RESERVED;
}

/*
 * Set the necessary part of the environment in `env'.
 */

static void
setup_environment (char ***env, const struct passwd *pwd)
{
    int i, j, path;
    char **e;

    i = 0;
    path = 0;
    *env = NULL;

    i = read_environment(_PATH_ETC_ENVIRONMENT, env);
    e = *env;
    for (j = 0; j < i; j++) {
	if (!strncmp(e[j], "PATH=", 5)) {
	    path = 1;
	}
    }

    e = *env;
    e = realloc(e, (i + 7) * sizeof(char *));

    if (asprintf (&e[i++], "USER=%s",  pwd->pw_name) == -1)
	syslog_and_die ("asprintf: out of memory");
    if (asprintf (&e[i++], "HOME=%s",  pwd->pw_dir) == -1)
	syslog_and_die ("asprintf: out of memory");
    if (asprintf (&e[i++], "SHELL=%s", pwd->pw_shell) == -1)
	syslog_and_die ("asprintf: out of memory");
    if (! path) {
	if (asprintf (&e[i++], "PATH=%s",  _PATH_DEFPATH) == -1)
	    syslog_and_die ("asprintf: out of memory");
    }
    asprintf (&e[i++], "SSH_CLIENT=only_to_make_bash_happy");
    if (do_unique_tkfile)
	if (asprintf (&e[i++], "KRB5CCNAME=%s", tkfile) == -1)
	    syslog_and_die ("asprintf: out of memory");
    e[i++] = NULL;
    *env = e;
}

static void
doit (void)
{
    u_char buf[BUFSIZ];
    u_char *p;
    struct sockaddr_storage thisaddr_ss;
    struct sockaddr *thisaddr = (struct sockaddr *)&thisaddr_ss;
    struct sockaddr_storage thataddr_ss;
    struct sockaddr *thataddr = (struct sockaddr *)&thataddr_ss;
    struct sockaddr_storage erraddr_ss;
    struct sockaddr *erraddr = (struct sockaddr *)&erraddr_ss;
    socklen_t thisaddr_len, thataddr_len;
    int port;
    int errsock = -1;
    char *client_user = NULL, *server_user = NULL, *cmd = NULL;
    struct passwd *pwd;
    int s = STDIN_FILENO;
    char **env;
    int ret;
    char that_host[NI_MAXHOST];

    thisaddr_len = sizeof(thisaddr_ss);
    if (getsockname (s, thisaddr, &thisaddr_len) < 0)
	syslog_and_die("getsockname: %s", strerror(errno));
    thataddr_len = sizeof(thataddr_ss);
    if (getpeername (s, thataddr, &thataddr_len) < 0)
	syslog_and_die ("getpeername: %s", strerror(errno));

    /* check for V4MAPPED addresses? */

    if (do_kerberos == 0 && !is_reserved(socket_get_port(thataddr)))
	fatal(s, NULL, "Permission denied.");

    p = buf;
    port = 0;
    for(;;) {
	if (net_read (s, p, 1) != 1)
	    syslog_and_die ("reading port number: %s", strerror(errno));
	if (*p == '\0')
	    break;
	else if (isdigit(*p))
	    port = port * 10 + *p - '0';
	else
	    syslog_and_die ("non-digit in port number: %c", *p);
    }

    if (do_kerberos  == 0 && !is_reserved(htons(port)))
	fatal(s, NULL, "Permission denied.");

    if (port) {
	int priv_port = IPPORT_RESERVED - 1;

	/*
	 * There's no reason to require a ``privileged'' port number
	 * here, but for some reason the brain dead rsh clients
	 * do... :-(
	 */

	erraddr->sa_family = thataddr->sa_family;
	socket_set_address_and_port (erraddr,
				     socket_get_address (thataddr),
				     htons(port));

	/*
	 * we only do reserved port for IPv4
	 */

	if (erraddr->sa_family == AF_INET)
	    errsock = rresvport (&priv_port);
	else
	    errsock = socket (erraddr->sa_family, SOCK_STREAM, 0);
	if (errsock < 0)
	    syslog_and_die ("socket: %s", strerror(errno));
	if (connect (errsock,
		     erraddr,
		     socket_sockaddr_size (erraddr)) < 0) {
	    syslog (LOG_WARNING, "connect: %s", strerror(errno));
	    close (errsock);
	}
    }

    if(do_kerberos) {
	if (net_read (s, buf, 4) != 4)
	    syslog_and_die ("reading auth info: %s", strerror(errno));

#ifdef KRB5
	    if((do_kerberos & DO_KRB5) &&
	       recv_krb5_auth (s, buf, thisaddr, thataddr,
			       &client_user,
			       &server_user,
			       &cmd) == 0)
		auth_method = AUTH_KRB5;
	    else
#endif /* KRB5 */
		syslog_and_die ("unrecognized auth protocol: %x %x %x %x",
				buf[0], buf[1], buf[2], buf[3]);
    } else {
	if(recv_bsd_auth (s, buf,
			  (struct sockaddr_in *)thisaddr,
			  (struct sockaddr_in *)thataddr,
			  &client_user,
			  &server_user,
			  &cmd) == 0) {
	    auth_method = AUTH_BROKEN;
	    if(do_vacuous) {
		printf("Remote host requires Kerberos authentication\n");
		exit(0);
	    }
	} else
	    syslog_and_die("recv_bsd_auth failed");
    }

    if (client_user == NULL || server_user == NULL || cmd == NULL)
	syslog_and_die("mising client/server/cmd");

    pwd = getpwnam (server_user);
    if (pwd == NULL)
	fatal (s, NULL, "Login incorrect.");

    if (*pwd->pw_shell == '\0')
	pwd->pw_shell = _PATH_BSHELL;

    if (pwd->pw_uid != 0 && access (_PATH_NOLOGIN, F_OK) == 0)
	fatal (s, NULL, "Login disabled.");


    ret = getnameinfo_verified (thataddr, thataddr_len,
				that_host, sizeof(that_host),
				NULL, 0, 0);
    if (ret)
	fatal (s, NULL, "getnameinfo: %s", gai_strerror(ret));

    if (login_access(pwd, that_host) == 0) {
	syslog(LOG_NOTICE, "Kerberos rsh denied to %s from %s",
	       server_user, that_host);
	fatal(s, NULL, "Permission denied.");
    }

#ifdef HAVE_GETSPNAM
    {
	struct spwd *sp;
	long    today;

	sp = getspnam(server_user);
	if (sp != NULL) {
	    today = time(0)/(24L * 60 * 60);
	    if (sp->sp_expire > 0)
		if (today > sp->sp_expire)
		    fatal(s, NULL, "Account has expired.");
	}
    }
#endif


#ifdef HAVE_SETLOGIN
    if (setlogin(pwd->pw_name) < 0)
	syslog(LOG_ERR, "setlogin() failed: %s", strerror(errno));
#endif

#ifdef HAVE_SETPCRED
    if (setpcred (pwd->pw_name, NULL) == -1)
	syslog(LOG_ERR, "setpcred() failure: %s", strerror(errno));
#endif /* HAVE_SETPCRED */

    /* Apply limits if not root */
    if(pwd->pw_uid != 0) {
	 const char *file = _PATH_LIMITS_CONF;
	 read_limits_conf(file, pwd);
    }

    if (initgroups (pwd->pw_name, pwd->pw_gid) < 0)
	fatal (s, "initgroups", "Login incorrect.");

    if (setgid(pwd->pw_gid) < 0)
	fatal (s, "setgid", "Login incorrect.");

    if (setuid (pwd->pw_uid) < 0)
	fatal (s, "setuid", "Login incorrect.");

    if (chdir (pwd->pw_dir) < 0)
	fatal (s, "chdir", "Remote directory.");

    if (errsock >= 0) {
	if (dup2 (errsock, STDERR_FILENO) < 0)
	    fatal (s, "dup2", "Cannot dup stderr.");
	close (errsock);
    } else {
	if (dup2 (STDOUT_FILENO, STDERR_FILENO) < 0)
	    fatal (s, "dup2", "Cannot dup stderr.");
    }

#ifdef KRB5
    {
	int fd;

	if (!do_unique_tkfile)
	    snprintf(tkfile,sizeof(tkfile),"FILE:/tmp/krb5cc_%lu",
		     (unsigned long)pwd->pw_uid);
	else if (*tkfile=='\0') {
	    snprintf(tkfile,sizeof(tkfile),"FILE:/tmp/krb5cc_XXXXXX");
	    fd = mkstemp(tkfile+5);
	    close(fd);
	    unlink(tkfile+5);
	}

	if (kerberos_status)
	    krb5_start_session();
    }
#endif

    setup_environment (&env, pwd);

    if (do_encrypt) {
	setup_copier (errsock >= 0);
    } else {
	if (net_write (s, "", 1) != 1)
	    fatal (s, "net_write", "write failed");
    }

#if defined(KRB5)
    if(k_hasafs()) {
	char cell[64];

	if(do_newpag)
	    k_setpag();

	/* XXX */
       if (kerberos_status) {
	   krb5_ccache ccache;
	   krb5_error_code status;

	   status = krb5_cc_resolve (context, tkfile, &ccache);
	   if (!status) {
	       if (k_afs_cell_of_file (pwd->pw_dir, cell, sizeof(cell)) == 0)
		   krb5_afslog_uid_home(context, ccache, cell, NULL,
					pwd->pw_uid, pwd->pw_dir);
	       krb5_afslog_uid_home(context, ccache, NULL, NULL,
				    pwd->pw_uid, pwd->pw_dir);
	       krb5_cc_close (context, ccache);
	   }
       }
    }
#endif /* KRB5 */
    execle (pwd->pw_shell, pwd->pw_shell, "-c", cmd, NULL, env);
    err(1, "exec %s", pwd->pw_shell);
}

struct getargs args[] = {
    { NULL,		'a',	arg_flag,	&do_addr_verify },
    { "keepalive",	'n',	arg_negative_flag,	&do_keepalive },
    { "inetd",		'i',	arg_negative_flag,	&do_inetd,
      "Not started from inetd" },
#if defined(KRB5)
    { "kerberos",	'k',	arg_flag,	&do_kerberos,
      "Implement kerberised services" },
    { "encrypt",	'x',	arg_flag,		&do_encrypt,
      "Implement encrypted service" },
#endif
    { "rhosts",		'l',	arg_negative_flag, &do_rhosts,
      "Don't check users .rhosts" },
    { "port",		'p',	arg_string,	&port_str,	"Use this port",
      "port" },
    { "vacuous",	'v',	arg_flag, &do_vacuous,
      "Don't accept non-kerberised connections" },
#if defined(KRB5)
    { NULL,		'P',	arg_negative_flag, &do_newpag,
      "Don't put process in new PAG" },
#endif
    /* compatibility flag: */
    { NULL,		'L',	arg_flag, &do_log },
    { "version",	0, 	arg_flag,		&do_version },
    { "help",		0, 	arg_flag,		&do_help }
};

static void
usage (int ret)
{
    if(isatty(STDIN_FILENO))
	arg_printusage (args,
			sizeof(args) / sizeof(args[0]),
			NULL,
			"");
    else
	syslog (LOG_ERR, "Usage: %s [-ikxlvPL] [-p port]", getprogname());
    exit (ret);
}


int
main(int argc, char **argv)
{
    int optind = 0;
    int on = 1;

    setprogname (argv[0]);
    roken_openlog ("rshd", LOG_ODELAY | LOG_PID, LOG_AUTH);

    if (getarg(args, sizeof(args) / sizeof(args[0]), argc, argv,
	       &optind))
	usage(1);

    if(do_help)
	usage (0);

    if (do_version) {
	print_version(NULL);
	exit(0);
    }

#if defined(KRB5)
    if (do_encrypt)
	do_kerberos = 1;

    if(do_kerberos)
	do_kerberos = DO_KRB5;
#endif

#ifdef KRB5
    if((do_kerberos & DO_KRB5) && krb5_init_context (&context) != 0)
	do_kerberos &= ~DO_KRB5;
#endif

    if (!do_inetd) {
	int error;
	struct addrinfo *ai = NULL, hints;
	char portstr[NI_MAXSERV];

	memset (&hints, 0, sizeof(hints));
	hints.ai_flags    = AI_PASSIVE;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_family   = PF_UNSPEC;

	if(port_str != NULL) {
	    error = getaddrinfo (NULL, port_str, &hints, &ai);
	    if (error)
		errx (1, "getaddrinfo: %s", gai_strerror (error));
	}
	if (ai == NULL) {
#if defined(KRB5)
	    if (do_kerberos) {
		if (do_encrypt) {
		    error = getaddrinfo(NULL, "ekshell", &hints, &ai);
		    if(error == EAI_NONAME) {
			snprintf(portstr, sizeof(portstr), "%d", 545);
			error = getaddrinfo(NULL, portstr, &hints, &ai);
		    }
		    if(error)
			errx (1, "getaddrinfo: %s", gai_strerror (error));
		} else {
		    error = getaddrinfo(NULL, "kshell", &hints, &ai);
		    if(error == EAI_NONAME) {
			snprintf(portstr, sizeof(portstr), "%d", 544);
			error = getaddrinfo(NULL, portstr, &hints, &ai);
		    }
		    if(error)
			errx (1, "getaddrinfo: %s", gai_strerror (error));
		}
	    } else
#endif
		{
		    error = getaddrinfo(NULL, "shell", &hints, &ai);
		    if(error == EAI_NONAME) {
			snprintf(portstr, sizeof(portstr), "%d", 514);
			error = getaddrinfo(NULL, portstr, &hints, &ai);
		    }
		    if(error)
			errx (1, "getaddrinfo: %s", gai_strerror (error));
		}
	}
	mini_inetd_addrinfo (ai, NULL);
	freeaddrinfo(ai);
    }

    if (do_keepalive &&
	setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
		   sizeof(on)) < 0)
	syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %s", strerror(errno));

    /* set SO_LINGER? */

    signal (SIGPIPE, SIG_IGN);

    doit ();
    return 0;
}
@


1.6
log
@2nd part of:
update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.
@
text
@d36 1
a36 1
RCSID("$Id$");
@


1.5
log
@These files are not use by us, so they're removed to make the tree
a little bit leaner, and to get rid of some bad string functions.
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d35 2
a36 1
RCSID("$KTH: rshd.c,v 1.43 2001/07/31 09:05:45 joda Exp $");
d40 6
d49 1
a52 4

#ifdef KRB4
des_key_schedule schedule;
des_cblock iv;
d55 1
d58 1
d69 1
a77 7
#if defined(DCE)
int dfsk5ok = 0;
int dfspag = 0;
int dfsfwd = 0;
krb5_ticket *user_ticket;
#endif

d94 2
a95 2
fatal (int sock, const char *m, ...)
    __attribute__ ((format (printf, 2, 3)));
d98 1
a98 1
fatal (int sock, const char *m, ...)
d109 4
a112 1
    syslog (LOG_ERR, "%s", buf + 1);
d117 2
a118 2
static void
read_str (int s, char *str, size_t sz, char *expl)
d120 10
a129 7
    while (sz > 0) {
	if (net_read (s, str, 1) != 1)
	    syslog_and_die ("read: %m");
	if (*str == '\0')
	    return;
	--sz;
	++str;
d131 1
a131 1
    fatal (s, "%s too long", expl);
d138 3
a140 3
	       char *client_username,
	       char *server_username,
	       char *cmd)
d144 4
a147 4
    read_str (s, client_username, USERNAME_SZ, "local username");
    read_str (s, server_username, USERNAME_SZ, "remote username");
    read_str (s, cmd, COMMAND_SZ, "command");
    pwd = getpwnam(server_username);
d149 1
a149 1
	fatal(s, "Login incorrect.");
d151 2
a152 2
		 client_username, server_username))
	fatal(s, "Login incorrect.");
d156 1
a156 1
#ifdef KRB4
a157 63
recv_krb4_auth (int s, u_char *buf,
		struct sockaddr *thisaddr,
		struct sockaddr *thataddr,
		char *client_username,
		char *server_username,
		char *cmd)
{
    int status;
    int32_t options;
    KTEXT_ST ticket;
    AUTH_DAT auth;
    char instance[INST_SZ + 1];
    char version[KRB_SENDAUTH_VLEN + 1];

    if (memcmp (buf, KRB_SENDAUTH_VERS, 4) != 0)
	return -1;
    if (net_read (s, buf + 4, KRB_SENDAUTH_VLEN - 4) !=
	KRB_SENDAUTH_VLEN - 4)
	syslog_and_die ("reading auth info: %m");
    if (memcmp (buf, KRB_SENDAUTH_VERS, KRB_SENDAUTH_VLEN) != 0)
	syslog_and_die("unrecognized auth protocol: %.8s", buf);

    options = KOPT_IGNORE_PROTOCOL;
    if (do_encrypt)
	options |= KOPT_DO_MUTUAL;
    k_getsockinst (s, instance, sizeof(instance));
    status = krb_recvauth (options,
			   s,
			   &ticket,
			   "rcmd",
			   instance,
			   (struct sockaddr_in *)thataddr,
			   (struct sockaddr_in *)thisaddr,
			   &auth,
			   "",
			   schedule,
			   version);
    if (status != KSUCCESS)
	syslog_and_die ("recvauth: %s", krb_get_err_text(status));
    if (strncmp (version, KCMD_VERSION, KRB_SENDAUTH_VLEN) != 0)
	syslog_and_die ("bad version: %s", version);

    read_str (s, server_username, USERNAME_SZ, "remote username");
    if (kuserok (&auth, server_username) != 0)
	fatal (s, "Permission denied");
    read_str (s, cmd, COMMAND_SZ, "command");

    syslog(LOG_INFO|LOG_AUTH,
	   "kerberos v4 shell from %s on %s as %s, cmd '%.80s'",
	   krb_unparse_name_long(auth.pname, auth.pinst, auth.prealm),

	   inet_ntoa(((struct sockaddr_in *)thataddr)->sin_addr),
	   server_username,
	   cmd);

    memcpy (iv, auth.session, sizeof(iv));

    return 0;
}

#endif /* KRB4 */

static int 
d165 1
a165 1
 
d174 2
a175 2
 
    ret = krb5_cc_gen_new(context, &krb5_mcc_ops, &ccache);
d180 1
a180 1
  
d183 3
d196 1
d200 5
d211 4
d224 18
d246 3
a248 3
		char *client_username,
		char *server_username,
		char *cmd)
d250 1
a250 1
    u_int32_t len;
d256 1
d261 1
a261 1
	
d263 1
a263 1
	syslog_and_die ("reading auth info: %m");
d267 1
a267 1
    
d277 9
a285 8
    status = krb5_recvauth(context,
			   &auth_context,
			   &s,
			   KCMD_VERSION,
			   server,
			   KRB5_RECVAUTH_IGNORE_VERSION,
			   NULL,
			   &ticket);
d291 15
a305 6
    read_str (s, server_username, USERNAME_SZ, "remote username");
    read_str (s, cmd, COMMAND_SZ, "command");
    read_str (s, client_username, COMMAND_SZ, "local username");

    status = krb5_auth_con_getkey (context, auth_context, &keyblock);
    if (status)
d311 1
a311 1
	syslog_and_die("krb5_crypto_init: %s", 
d314 2
a315 2
    
    cksum_data.length = asprintf ((char **)&cksum_data.data,
d318 5
a322 2
				  cmd,
				  server_username);
d324 1
a324 1
    status = krb5_verify_authenticator_checksum(context, 
d326 1
a326 1
						cksum_data.data, 
d335 1
a335 1
    if (strncmp (client_username, "-u ", 3) == 0) {
d337 2
a338 2
	memmove (client_username, client_username + 3,
		 strlen(client_username) - 2);
d341 1
a341 1
    if (strncmp (client_username, "-U ", 3) == 0) {
d345 1
a345 1
	if (strncmp (server_username + 3, "FILE:", 5) == 0) {
d348 1
a348 1
	    strcpy (tkfile, "FILE:");
d351 8
a358 4
	end = strchr(client_username + 3,' ');
	strncpy(temp_tkfile, client_username + 3, end - client_username - 3);
	temp_tkfile[end - client_username - 3] = '\0';
	memmove (client_username, end +1, strlen(end+1)+1);
d364 3
a366 3
		     ticket->client,
		     server_username))
	fatal (s, "Permission denied");
d368 1
a368 1
    if (strncmp (cmd, "-x ", 3) == 0) {
d370 1
a370 1
	memmove (cmd, cmd + 3, strlen(cmd) - 2);
d373 1
a373 1
	    fatal (s, "Encryption required");
d393 2
a394 2
		   server_username,
		   cmd);
d397 1
a397 1
    }	   
d399 1
a399 3
#if defined(DCE)
    user_ticket = ticket;
#endif
d403 1
d406 4
a409 3
loop (int from0, int to0,
      int to1,   int from1,
      int to2,   int from2)
d414 1
d419 5
d429 5
a436 1
	char buf[RSH_BUFSIZ];
d443 1
a443 1
		syslog_and_die ("select: %m");
d446 1
a446 1
	    ret = do_read (from0, buf, sizeof(buf));
d448 1
a448 1
		syslog_and_die ("read: %m");
d457 1
a457 1
	    ret = read (from1, buf, sizeof(buf));
d459 1
a459 1
		syslog_and_die ("read: %m");
d467 1
a467 1
		do_write (to1, buf, ret);
d470 1
a470 1
	    ret = read (from2, buf, sizeof(buf));
d472 1
a472 1
		syslog_and_die ("read: %m");
d480 1
a480 1
		do_write (to2, buf, ret);
d499 1
a499 1
	fatal (STDOUT_FILENO, "socketpair: %m");
d506 1
a506 1
setup_copier (void)
d516 1
a516 1
	fatal (STDOUT_FILENO, "fork: %m");
d533 1
a533 1
	    fatal (STDOUT_FILENO, "write failed");
d535 1
a535 1
	loop (STDIN_FILENO, p0[1],
d537 2
a538 1
	      STDERR_FILENO, p2[0]);
d577 6
a582 3
    asprintf (&e[i++], "USER=%s",  pwd->pw_name);
    asprintf (&e[i++], "HOME=%s",  pwd->pw_dir);
    asprintf (&e[i++], "SHELL=%s", pwd->pw_shell);
d584 2
a585 1
	asprintf (&e[i++], "PATH=%s",  _PATH_DEFPATH);
a587 4
#if defined(DCE)
    if (getenv("KRB5CCNAME"))
	asprintf (&e[i++], "KRB5CCNAME=%s",  getenv("KRB5CCNAME"));
#else
d589 2
a590 2
	asprintf (&e[i++], "KRB5CCNAME=%s", tkfile);
#endif
d596 1
a596 1
doit (int do_kerberos, int check_rhosts)
d609 1
a609 2
    char client_user[COMMAND_SZ], server_user[USERNAME_SZ];
    char cmd[COMMAND_SZ];
d618 1
a618 1
	syslog_and_die("getsockname: %m");
d621 1
a621 1
	syslog_and_die ("getpeername: %m");
d623 4
a626 2
    if (!do_kerberos && !is_reserved(socket_get_port(thataddr)))
	fatal(s, "Permission denied");
d632 1
a632 1
	    syslog_and_die ("reading port number: %m");
d641 2
a642 2
    if (!do_kerberos && !is_reserved(htons(port)))
	fatal(s, "Permission denied");
d647 1
a647 1
	/* 
d667 1
a667 1
	    syslog_and_die ("socket: %m");
d671 1
a671 1
	    syslog (LOG_WARNING, "connect: %m");
d675 1
a675 1
    
d678 8
a685 14
	    syslog_and_die ("reading auth info: %m");
    
#ifdef KRB4
	if (recv_krb4_auth (s, buf, thisaddr, thataddr,
			    client_user,
			    server_user,
			    cmd) == 0)
	    auth_method = AUTH_KRB4;
	else
#endif /* KRB4 */
	    if(recv_krb5_auth (s, buf, thisaddr, thataddr,
			       client_user,
			       server_user,
			       cmd) == 0)
d688 1
d695 3
a697 3
			  client_user,
			  server_user,
			  cmd) == 0) {
d707 2
a708 3
#if defined(DCE) && defined(_AIX)
    esetenv("AUTHSTATE", "DCE", 1);
#endif
d712 1
a712 1
	fatal (s, "Login incorrect.");
d718 1
a718 1
	fatal (s, "Login disabled.");
d725 1
a725 1
	fatal (s, "getnameinfo: %s", gai_strerror(ret));
d730 1
a730 1
	fatal(s, "Permission denied");
d737 1
a737 1
    
d741 3
a743 19
	    if (sp->sp_expire > 0) 
		if (today > sp->sp_expire) 
		    fatal(s, "Account has expired.");
	}
    }
#endif
    

#ifdef KRB5
    {
	int fd;
 
	if (!do_unique_tkfile)
	    snprintf(tkfile,sizeof(tkfile),"FILE:/tmp/krb5cc_%u",pwd->pw_uid);
	else if (*tkfile=='\0') {
	    snprintf(tkfile,sizeof(tkfile),"FILE:/tmp/krb5cc_XXXXXX");
	    fd = mkstemp(tkfile+5);
	    close(fd);
	    unlink(tkfile+5);
a744 10
 
	if (kerberos_status)
	    krb5_start_session();
    }
    chown(tkfile + 5, pwd->pw_uid, -1);

#if defined(DCE)
    if (kerberos_status) {
	esetenv("KRB5CCNAME", tkfile, 1);
	dfspag = krb5_dfs_pag(context, kerberos_status, user_ticket->client, server_user);
a747 1
#endif
d751 1
a751 1
	syslog(LOG_ERR, "setlogin() failed: %m");
d756 1
a756 1
	syslog(LOG_ERR, "setpcred() failure: %m");
d759 6
d766 1
a766 1
	fatal (s, "Login incorrect.");
d769 1
a769 1
	fatal (s, "Login incorrect.");
d772 1
a772 1
	fatal (s, "Login incorrect.");
d775 1
a775 1
	fatal (s, "Remote directory.");
d779 1
a779 1
	    fatal (s, "Dup2 failed.");
d781 21
d803 1
d808 1
a808 1
	setup_copier ();
d811 1
a811 1
	    fatal (s, "write failed");
d814 1
a814 1
#ifdef KRB4
a819 2
	if (k_afs_cell_of_file (pwd->pw_dir, cell, sizeof(cell)) == 0)
	    krb_afslog_uid_home (cell, NULL, pwd->pw_uid, pwd->pw_dir);
a820 3
	krb_afslog_uid_home(NULL, NULL, pwd->pw_uid, pwd->pw_dir);

#ifdef KRB5
d828 4
a831 1
	       krb5_afslog_uid_home(context,ccache,NULL,NULL,
d836 1
d838 1
a838 3
    }
#endif /* KRB4 */
    execle (pwd->pw_shell, pwd->pw_shell, "-c", cmd, (char *)NULL, env);
d847 1
d852 1
d859 1
d862 1
d878 1
a878 1
	syslog (LOG_ERR, "Usage: %s [-ikxlvPL] [-p port]", __progname);
d887 1
a887 1
    int port = 0;
d889 1
d904 3
a906 3
#ifdef KRB5
    {
	krb5_error_code ret;
d908 3
a910 20
	ret = krb5_init_context (&context);
	if (ret)
	    errx (1, "krb5_init_context failed: %d", ret);
    }	
#endif

    if(port_str) {
	struct servent *s = roken_getservbyname (port_str, "tcp");

	if (s)
	    port = s->s_port;
	else {
	    char *ptr;

	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		syslog_and_die("Bad port `%s'", port_str);
	    port = htons(port);
	}
    }
d912 4
a915 2
    if (do_encrypt)
	do_kerberos = 1;
d918 16
a933 1
	if (port == 0) {
d935 39
a973 10
		if (do_encrypt)
		    port = krb5_getportbyname (context, "ekshell", "tcp", 545);
		else
		    port = krb5_getportbyname (context, "kshell",  "tcp", 544);
	    } else {
		port = krb5_getportbyname(context, "shell", "tcp", 514);
	    }
	}
	mini_inetd (port);
    }
d977 1
a977 1
    doit (do_kerberos, do_rhosts);
@


1.4
log
@Remove all uses of setprogname() and getprogname() in kerberosV subtree.
@
text
@@


1.3
log
@Merge heimdal-0.4e
@
text
@d878 1
a878 1
	syslog (LOG_ERR, "Usage: %s [-ikxlvPL] [-p port]", getprogname());
a888 1
    setprogname (argv[0]);
@


1.2
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d35 1
a35 1
RCSID("$KTH: rshd.c,v 1.41 2001/02/20 01:44:48 assar Exp $");
d61 1
a61 1
static int do_rhosts;
d66 2
d107 1
d847 2
d855 2
a856 2
    { "rhosts",		'l',	arg_flag, &do_rhosts,
      "Check users .rhosts" },
@


1.1
log
@Initial revision
@
text
@d35 4
a38 1
RCSID("$KTH: rshd.c,v 1.39 2001/01/09 18:44:29 assar Exp $");
d78 4
d93 4
d600 1
a600 1
    socklen_t addrlen;
d608 2
d611 2
a612 2
    addrlen = sizeof(thisaddr_ss);
    if (getsockname (s, thisaddr, &addrlen) < 0)
d614 2
a615 2
    addrlen = sizeof(thataddr_ss);
    if (getpeername (s, thataddr, &addrlen) < 0)
d705 1
a705 1
#if defined(DCE) && defined(AIX)
d719 13
d839 1
a839 1
    execle (pwd->pw_shell, pwd->pw_shell, "-c", cmd, NULL, env);
d873 1
a873 1
	syslog (LOG_ERR, "Usage: %s [-ikxlvPL] [-p port]", __progname);
d884 1
a884 1
    set_progname (argv[0]);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 4
RCSID("$KTH: rshd.c,v 1.41 2001/02/20 01:44:48 assar Exp $");

int
login_access( struct passwd *user, char *from);
a74 4
    __attribute__ ((format (printf, 1, 2)));

static void
syslog_and_die (const char *m, ...)
a85 4
    __attribute__ ((format (printf, 2, 3)));

static void
fatal (int sock, const char *m, ...)
d589 1
a589 1
    socklen_t thisaddr_len, thataddr_len;
a596 2
    int ret;
    char that_host[NI_MAXHOST];
d598 2
a599 2
    thisaddr_len = sizeof(thisaddr_ss);
    if (getsockname (s, thisaddr, &thisaddr_len) < 0)
d601 2
a602 2
    thataddr_len = sizeof(thataddr_ss);
    if (getpeername (s, thataddr, &thataddr_len) < 0)
d692 1
a692 1
#if defined(DCE) && defined(_AIX)
a705 13

    ret = getnameinfo_verified (thataddr, thataddr_len,
				that_host, sizeof(that_host),
				NULL, 0, 0);
    if (ret)
	fatal (s, "getnameinfo: %s", gai_strerror(ret));

    if (login_access(pwd, that_host) == 0) {
	syslog(LOG_NOTICE, "Kerberos rsh denied to %s from %s",
	       server_user, that_host);
	fatal(s, "Permission denied");
    }

d847 1
a847 1
	syslog (LOG_ERR, "Usage: %s [-ikxlvPL] [-p port]", getprogname());
d858 1
a858 1
    setprogname (argv[0]);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d35 1
a35 1
RCSID("$KTH: rshd.c,v 1.43 2001/07/31 09:05:45 joda Exp $");
d61 1
a61 1
static int do_rhosts = 1;
a65 2
static int do_addr_verify = 0;
static int do_keepalive = 1;
a104 1
    len = min(len, sizeof(buf) - 1);
a843 2
    { NULL,		'a',	arg_flag,	&do_addr_verify },
    { "keepalive",	'n',	arg_negative_flag,	&do_keepalive },
d850 2
a851 2
    { "rhosts",		'l',	arg_negative_flag, &do_rhosts,
      "Don't check users .rhosts" },
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: rshd.c,v 1.51.2.1 2003/08/19 11:36:17 joda Exp $");
a41 1
#ifdef KRB5
a44 1
#endif
a50 1
#ifdef KRB5
a52 1
#endif
a62 2
#define DO_KRB4 2
#define DO_KRB5 4
d71 1
a71 1
#if defined(KRB5) && defined(DCE)
d94 2
a95 2
fatal (int, const char*, const char *, ...)
    __attribute__ ((noreturn, format (printf, 3, 4)));
d98 1
a98 1
fatal (int sock, const char *what, const char *m, ...)
d109 1
a109 4
    if(what != NULL)
	syslog (LOG_ERR, "%s: %m: %s", what, buf + 1);
    else
	syslog (LOG_ERR, "%s", buf + 1);
d114 2
a115 2
static char *
read_str (int s, size_t sz, char *expl)
d117 7
a123 10
    char *str = malloc(sz);
    char *p = str;
    if(str == NULL)
	fatal(s, NULL, "%s too long", expl);
    while(p < str + sz) {
	if(net_read(s, p, 1) != 1)
	    syslog_and_die("read: %m");
	if(*p == '\0')
	    return str;
	p++;
d125 1
a125 1
    fatal(s, NULL, "%s too long", expl);
d132 3
a134 3
	       char **client_username,
	       char **server_username,
	       char **cmd)
d137 5
a141 5
    
    *client_username = read_str (s, USERNAME_SZ, "local username");
    *server_username = read_str (s, USERNAME_SZ, "remote username");
    *cmd = read_str (s, ARG_MAX + 1, "command");
    pwd = getpwnam(*server_username);
d143 1
a143 1
	fatal(s, NULL, "Login incorrect.");
d145 2
a146 2
		 *client_username, *server_username))
	fatal(s, NULL, "Login incorrect.");
d155 3
a157 3
		char **client_username,
		char **server_username,
		char **cmd)
d191 1
a191 1
    if (strncmp (version, KCMD_OLD_VERSION, KRB_SENDAUTH_VLEN) != 0)
d194 4
a197 4
    *server_username = read_str (s, USERNAME_SZ, "remote username");
    if (kuserok (&auth, *server_username) != 0)
	fatal (s, NULL, "Permission denied.");
    *cmd = read_str (s, ARG_MAX + 1, "command");
d204 2
a205 2
	   *server_username,
	   *cmd);
a213 1
#ifdef KRB5
a239 3
    if(ret != 0)
	syslog(LOG_INFO|LOG_AUTH,
	       "reading creds: %s", krb5_get_err_text(context, ret));
a267 18
static int protocol_version;

static krb5_boolean
match_kcmd_version(const void *data, const char *version)
{
    if(strcmp(version, KCMD_NEW_VERSION) == 0) {
	protocol_version = 2;
	return TRUE;
    }
    if(strcmp(version, KCMD_OLD_VERSION) == 0) {
	protocol_version = 1;
	key_usage = KRB5_KU_OTHER_ENCRYPTED;
	return TRUE;
    }
    return FALSE;
}


d272 3
a274 3
		char **client_username,
		char **server_username,
		char **cmd)
d302 8
a309 9
    status = krb5_recvauth_match_version(context,
					 &auth_context,
					 &s,
					 match_kcmd_version,
					 NULL,
					 server,
					 KRB5_RECVAUTH_IGNORE_VERSION,
					 NULL,
					 &ticket);
d315 6
a320 15
    *server_username = read_str (s, USERNAME_SZ, "remote username");
    *cmd = read_str (s, ARG_MAX + 1, "command");
    *client_username = read_str (s, ARG_MAX + 1, "local username");

    if(protocol_version == 2) {
	status = krb5_auth_con_getremotesubkey(context, auth_context, 
					       &keyblock);
	if(status != 0 || keyblock == NULL)
	    syslog_and_die("failed to get remote subkey");
    } else if(protocol_version == 1) {
	status = krb5_auth_con_getkey (context, auth_context, &keyblock);
	if(status != 0 || keyblock == NULL)
	    syslog_and_die("failed to get key");
    }
    if (status != 0 || keyblock == NULL)
d333 2
a334 2
				  *cmd,
				  *server_username);
d347 1
a347 1
    if (strncmp (*client_username, "-u ", 3) == 0) {
d349 2
a350 2
	memmove (*client_username, *client_username + 3,
		 strlen(*client_username) - 2);
d353 1
a353 1
    if (strncmp (*client_username, "-U ", 3) == 0) {
d357 1
a357 1
	if (strncmp (*client_username + 3, "FILE:", 5) == 0) {
d363 4
a366 4
	end = strchr(*client_username + 3,' ');
	strncpy(temp_tkfile, *client_username + 3, end - *client_username - 3);
	temp_tkfile[end - *client_username - 3] = '\0';
	memmove (*client_username, end + 1, strlen(end+1)+1);
d372 3
a374 3
		      ticket->client,
		      *server_username))
	fatal (s, NULL, "Permission denied.");
d376 1
a376 1
    if (strncmp (*cmd, "-x ", 3) == 0) {
d378 1
a378 1
	memmove (*cmd, *cmd + 3, strlen(*cmd) - 2);
d381 1
a381 1
	    fatal (s, NULL, "Encryption is required.");
d401 2
a402 2
		   *server_username,
		   *cmd);
a412 1
#endif /* KRB5 */
a425 5
#ifdef KRB5
    if(auth_method == AUTH_KRB5 && protocol_version == 2)
	init_ivecs(0);
#endif

d444 1
a444 1
	    ret = do_read (from0, buf, sizeof(buf), ivec_in[0]);
d465 1
a465 1
		do_write (to1, buf, ret, ivec_out[0]);
d478 1
a478 1
		do_write (to2, buf, ret, ivec_out[1]);
d497 1
a497 1
	fatal (STDOUT_FILENO, "socketpair", "Pipe creation failed.");
d514 1
a514 1
	fatal (STDOUT_FILENO, "fork", "Could not create child process.");
d531 1
a531 1
	    fatal (STDOUT_FILENO, "net_write", "Write failure.");
d593 1
a593 1
doit (void)
d606 2
a607 1
    char *client_user, *server_user, *cmd;
d621 2
a622 4
    /* check for V4MAPPED addresses? */

    if (do_kerberos == 0 && !is_reserved(socket_get_port(thataddr)))
	fatal(s, NULL, "Permission denied.");
d637 2
a638 2
    if (do_kerberos  == 0 && !is_reserved(htons(port)))
	fatal(s, NULL, "Permission denied.");
d677 4
a680 5
	if ((do_kerberos & DO_KRB4) && 
	    recv_krb4_auth (s, buf, thisaddr, thataddr,
			    &client_user,
			    &server_user,
			    &cmd) == 0)
d684 4
a687 6
#ifdef KRB5
	    if((do_kerberos & DO_KRB5) &&
	       recv_krb5_auth (s, buf, thisaddr, thataddr,
			       &client_user,
			       &server_user,
			       &cmd) == 0)
a689 1
#endif /* KRB5 */
d696 3
a698 3
			  &client_user,
			  &server_user,
			  &cmd) == 0) {
d714 1
a714 1
	fatal (s, NULL, "Login incorrect.");
d720 1
a720 1
	fatal (s, NULL, "Login disabled.");
d727 1
a727 1
	fatal (s, NULL, "getnameinfo: %s", gai_strerror(ret));
d732 1
a732 1
	fatal(s, NULL, "Permission denied.");
d745 1
a745 1
		    fatal(s, NULL, "Account has expired.");
d789 1
a789 1
	fatal (s, "initgroups", "Login incorrect.");
d792 1
a792 1
	fatal (s, "setgid", "Login incorrect.");
d795 1
a795 1
	fatal (s, "setuid", "Login incorrect.");
d798 1
a798 1
	fatal (s, "chdir", "Remote directory.");
d802 1
a802 1
	    fatal (s, "dup2", "Cannot dup stderr.");
d812 1
a812 1
	    fatal (s, "net_write", "write failed");
d815 1
a815 1
#if defined(KRB4) || defined(KRB5)
a820 1
#ifdef KRB4
d823 1
a824 1
#endif
d834 1
a834 4
	       if (k_afs_cell_of_file (pwd->pw_dir, cell, sizeof(cell)) == 0)
		   krb5_afslog_uid_home(context, ccache, cell, NULL,
					pwd->pw_uid, pwd->pw_dir);
	       krb5_afslog_uid_home(context, ccache, NULL, NULL,
d841 1
a841 1
#endif /* KRB5 || KRB4 */
a850 1
#if defined(KRB4) || defined(KRB5)
a854 1
#endif
a860 1
#if defined(KRB4) || defined(KRB5)
a862 1
#endif
d887 1
a887 1
    int on = 1;
d904 25
a928 1
#if defined(KRB4) || defined(KRB5)
a931 16
    if(do_kerberos)
	do_kerberos = DO_KRB4 | DO_KRB5;
#endif

    if (do_keepalive &&
	setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
		   sizeof(on)) < 0)
	syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");

    /* set SO_LINGER? */

#ifdef KRB5
    if((do_kerberos & DO_KRB5) && krb5_init_context (&context) != 0)
	do_kerberos &= ~DO_KRB5;
#endif

d933 1
a933 16
	int error;
	struct addrinfo *ai = NULL, hints;
	char portstr[NI_MAXSERV];
	
	memset (&hints, 0, sizeof(hints));
	hints.ai_flags    = AI_PASSIVE;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_family   = PF_UNSPEC;
	
	if(port_str != NULL) {
	    error = getaddrinfo (NULL, port_str, &hints, &ai);
	    if (error)
		errx (1, "getaddrinfo: %s", gai_strerror (error));
	}
	if (ai == NULL) {
#if defined(KRB4) || defined(KRB5)
d935 7
a941 28
		if (do_encrypt) {
		    error = getaddrinfo(NULL, "ekshell", &hints, &ai);
		    if(error == EAI_NONAME) {
			snprintf(portstr, sizeof(portstr), "%d", 545);
			error = getaddrinfo(NULL, portstr, &hints, &ai);
		    }
		    if(error) 
			errx (1, "getaddrinfo: %s", gai_strerror (error));
		} else {
		    error = getaddrinfo(NULL, "kshell", &hints, &ai);
		    if(error == EAI_NONAME) {
			snprintf(portstr, sizeof(portstr), "%d", 544);
			error = getaddrinfo(NULL, portstr, &hints, &ai);
		    }
		    if(error) 
			errx (1, "getaddrinfo: %s", gai_strerror (error));
		}
	    } else
#endif
		{
		    error = getaddrinfo(NULL, "shell", &hints, &ai);
		    if(error == EAI_NONAME) {
			snprintf(portstr, sizeof(portstr), "%d", 514);
			error = getaddrinfo(NULL, portstr, &hints, &ai);
		    }
		    if(error) 
			errx (1, "getaddrinfo: %s", gai_strerror (error));
		}
d943 1
a943 2
	mini_inetd_addrinfo (ai);
	freeaddrinfo(ai);
d948 1
a948 1
    doit ();
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2006 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: rshd.c,v 1.60.2.2 2006/02/03 14:48:10 lha Exp $");
d77 7
a265 1
    char *estr;
a268 5
	estr = krb5_get_error_string(context);
	syslog(LOG_WARNING, "resolve cred cache %s: %s", 
	       tkfile, 
	       estr ? estr : krb5_get_err_text(context, ret));
	free(estr);
a274 4
	estr = krb5_get_error_string(context);
	syslog(LOG_WARNING, "storing credentials: %s", 
	       estr ? estr : krb5_get_err_text(context, ret));
	free(estr);
a378 2
    if (cksum_data.length == -1)
	syslog_and_die ("asprintf: out of memory");
d404 1
a404 1
	    strlcpy (tkfile, "FILE:", sizeof(tkfile));
d408 2
a409 6
	if (end == NULL)
	    syslog_and_die("missing argument after -U");
	snprintf(temp_tkfile, sizeof(tkfile) - (temp_tkfile - tkfile),
		 "%.*s",
		 (int)(end - *client_username - 3),
		 *client_username + 3);
d451 4
d460 3
a462 4
rshd_loop (int from0, int to0,
	   int to1,   int from1,
	   int to2,   int from2,
	   int have_errsock)
a466 1
    char *buf;
d473 1
a473 1
	init_ivecs(0, have_errsock);
a480 5

    buf = malloc(max(RSHD_BUFSIZ, RSH_BUFSIZ));
    if (buf == NULL)
	syslog_and_die("out of memory");

d484 1
d494 1
a494 1
	    ret = do_read (from0, buf, RSHD_BUFSIZ, ivec_in[0]);
d505 1
a505 1
	    ret = read (from1, buf, RSH_BUFSIZ);
d518 1
a518 1
	    ret = read (from2, buf, RSH_BUFSIZ);
d554 1
a554 1
setup_copier (int have_errsock)
d583 1
a583 1
	rshd_loop (STDIN_FILENO, p0[1],
d585 1
a585 2
	      STDERR_FILENO, p2[0],
	      have_errsock);
d624 3
a626 6
    if (asprintf (&e[i++], "USER=%s",  pwd->pw_name) == -1)
	syslog_and_die ("asprintf: out of memory");
    if (asprintf (&e[i++], "HOME=%s",  pwd->pw_dir) == -1)
	syslog_and_die ("asprintf: out of memory");
    if (asprintf (&e[i++], "SHELL=%s", pwd->pw_shell) == -1)
	syslog_and_die ("asprintf: out of memory");
d628 1
a628 2
	if (asprintf (&e[i++], "PATH=%s",  _PATH_DEFPATH) == -1)
	    syslog_and_die ("asprintf: out of memory");
d631 4
d636 2
a637 2
	if (asprintf (&e[i++], "KRB5CCNAME=%s", tkfile) == -1)
	    syslog_and_die ("asprintf: out of memory");
d656 1
a656 1
    char *client_user = NULL, *server_user = NULL, *cmd = NULL;
d763 3
a765 2
    if (client_user == NULL || server_user == NULL || cmd == NULL)
	syslog_and_die("mising client/server/cmd");
d806 27
a858 3
    } else {
	if (dup2 (STDOUT_FILENO, STDERR_FILENO) < 0)
	    fatal (s, "dup2", "Cannot dup stderr.");
a860 19
#ifdef KRB5
    {
	int fd;
 
	if (!do_unique_tkfile)
	    snprintf(tkfile,sizeof(tkfile),"FILE:/tmp/krb5cc_%lu",
		     (unsigned long)pwd->pw_uid);
	else if (*tkfile=='\0') {
	    snprintf(tkfile,sizeof(tkfile),"FILE:/tmp/krb5cc_XXXXXX");
	    fd = mkstemp(tkfile+5);
	    close(fd);
	    unlink(tkfile+5);
	}
 
	if (kerberos_status)
	    krb5_start_session();
    }
#endif

d864 1
a864 1
	setup_copier (errsock >= 0);
d975 7
a1036 7

    if (do_keepalive &&
	setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
		   sizeof(on)) < 0)
	syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");

    /* set SO_LINGER? */
@


