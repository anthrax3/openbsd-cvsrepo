head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.2
	HEIMDAL_0_6_3:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.18;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.40;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.17.18.43;	author hin;	state dead;
branches;
next	1.1;

1.1
date	2001.05.25.07.46.12;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.46.12;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.04.14.07.32.16;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1989 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#include <popper.h>
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif

RCSID("$Id: pop_pass.c,v 1.3 2013/06/17 18:57:40 robert Exp $");

#ifdef KRB5
static int
krb5_verify_password (POP *p)
{
    krb5_preauthtype pre_auth_types[] = {KRB5_PADATA_ENC_TIMESTAMP};
    krb5_get_init_creds_opt *get_options;
    krb5_verify_init_creds_opt verify_options;
    krb5_error_code ret;
    krb5_principal client, server;
    krb5_creds creds;

    ret = krb5_get_init_creds_opt_alloc (p->context, &get_options);
    if (ret) {
	pop_log(p, POP_PRIORITY, "krb5_get_init_creds_opt_alloc: %s",
		krb5_get_err_text (p->context, ret));
	return 1;
    }

    krb5_get_init_creds_opt_set_preauth_list (get_options,
					      pre_auth_types,
					      1);

    krb5_verify_init_creds_opt_init (&verify_options);

    ret = krb5_parse_name (p->context, p->user, &client);
    if (ret) {
	krb5_get_init_creds_opt_free(p->context, get_options);
	pop_log(p, POP_PRIORITY, "krb5_parse_name: %s",
		krb5_get_err_text (p->context, ret));
	return 1;
    }

    ret = krb5_get_init_creds_password (p->context,
					&creds,
					client,
					p->pop_parm[1],
					NULL,
					NULL,
					0,
					NULL,
					get_options);
    krb5_get_init_creds_opt_free(p->context, get_options);
    if (ret) {
	pop_log(p, POP_PRIORITY,
		"krb5_get_init_creds_password: %s",
		krb5_get_err_text (p->context, ret));
	return 1;
    }

    ret = krb5_sname_to_principal (p->context,
				   p->myhost,
				   "pop",
				   KRB5_NT_SRV_HST,
				   &server);
    if (ret) {
	pop_log(p, POP_PRIORITY,
		"krb5_get_init_creds_password: %s",
		krb5_get_err_text (p->context, ret));
	return 1;
    }

    ret = krb5_verify_init_creds (p->context,
				  &creds,
				  server,
				  NULL,
				  NULL,
				  &verify_options);
    krb5_free_principal (p->context, client);
    krb5_free_principal (p->context, server);
    krb5_free_cred_contents (p->context, &creds);
    return ret;
}
#endif
/*
 *  pass:   Obtain the user password from a POP client
 */

int
login_user(POP *p)
{
    struct stat st;
    struct passwd *pw;

    /*  Look for the user in the password file */
    if ((pw = k_getpwnam(p->user)) == NULL) {
	pop_log(p, POP_PRIORITY, "user %s (from %s) not found",
		p->user, p->ipaddr);
	return pop_msg(p, POP_FAILURE, "Login incorrect.");
    }

    pop_log(p, POP_INFO, "login from %s as %s", p->ipaddr, p->user);

    /*  Build the name of the user's maildrop */
    snprintf(p->drop_name, sizeof(p->drop_name), "%s/%s", POP_MAILDIR, p->user);
    if(stat(p->drop_name, &st) < 0 || !S_ISDIR(st.st_mode)){
	/*  Make a temporary copy of the user's maildrop */
	/*    and set the group and user id */
	if (pop_dropcopy(p, pw) != POP_SUCCESS) return (POP_FAILURE);

	/*  Get information about the maildrop */
	if (pop_dropinfo(p) != POP_SUCCESS) return(POP_FAILURE);
    } else {
	if(changeuser(p, pw) != POP_SUCCESS) return POP_FAILURE;
	if(pop_maildir_info(p) != POP_SUCCESS) return POP_FAILURE;
    }
    /*  Initialize the last-message-accessed number */
    p->last_msg = 0;
    return POP_SUCCESS;
}

int
pop_pass (POP *p)
{
    struct passwd  *pw;
    int i;
    int status;

    /* Make one string of all these parameters */

    for (i = 1; i < p->parm_count; ++i)
	p->pop_parm[i][strlen(p->pop_parm[i])] = ' ';

    /*  Look for the user in the password file */
    if ((pw = k_getpwnam(p->user)) == NULL)
	return (pop_msg(p,POP_FAILURE,
			"Password supplied for \"%s\" is incorrect.",
			p->user));

    if (p->kerberosp) {
#ifdef KRB5
	if (p->version == 5) {
	    char *name;

	    if (!krb5_kuserok (p->context, p->principal, p->user)) {
		pop_log (p, POP_PRIORITY,
			 "krb5 permission denied");
		return pop_msg(p, POP_FAILURE,
			       "Popping not authorized");
	    }
	    if(krb5_unparse_name (p->context, p->principal, &name) == 0) {
		pop_log(p, POP_INFO, "%s: %s -> %s",
			p->ipaddr, name, p->user);
		free (name);
	    }
	} else {
	    pop_log (p, POP_PRIORITY, "kerberos authentication failed");
	    return pop_msg (p, POP_FAILURE,
			    "kerberos authentication failed");
	}
#endif
	{ }
    } else {
	 /*  We don't accept connections from users with null passwords */
	 if (pw->pw_passwd == NULL)
	      return (pop_msg(p,
			      POP_FAILURE,
			      "Password supplied for \"%s\" is incorrect.",
			      p->user));

#ifdef OTP
	 if (otp_verify_user (&p->otp_ctx, p->pop_parm[1]) == 0)
	     /* pass OK */;
	 else
#endif
	 /*  Compare the supplied password with the password file entry */
	 if (p->auth_level != AUTH_NONE)
	     return pop_msg(p, POP_FAILURE,
			    "Password supplied for \"%s\" is incorrect.",
			    p->user);
	 else if (!strcmp(crypt(p->pop_parm[1], pw->pw_passwd), pw->pw_passwd))
	     /* pass OK */;
	 else {
	     int ret = -1;
#ifdef KRB5
	     if(ret)
		 ret = krb5_verify_password (p);
#endif
	     if(ret)
		 return pop_msg(p, POP_FAILURE,
				"Password incorrect");
	 }
    }
    status = login_user(p);
    if(status != POP_SUCCESS)
	return status;

    /*  Authorization completed successfully */
    return (pop_msg (p, POP_SUCCESS,
		     "%s has %d message(s) (%ld octets).",
		     p->user, p->msg_count, p->drop_size));
}
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d12 1
a12 1
RCSID("$Id$");
@


1.2
log
@These files are not use by us, so they're removed to make the tree
a little bit leaner, and to get rid of some bad string functions.
@
text
@d8 3
a10 19
RCSID("$KTH: pop_pass.c,v 1.41 2000/04/12 15:37:46 assar Exp $");

#ifdef KRB4
static int
krb4_verify_password (POP *p)
{
    int status;
    char lrealm[REALM_SZ];
    char tkt[MaxPathLen];

    status = krb_get_lrealm(lrealm,1);
    if (status == KFAILURE) {
        pop_log(p, POP_PRIORITY, "%s: (%s.%s@@%s) %s", p->client,
		p->kdata.pname, p->kdata.pinst, p->kdata.prealm,
		krb_get_err_text(status));
	return 1;
    }
    snprintf(tkt, sizeof(tkt), "%s_popper.%u", TKT_ROOT, (unsigned)getpid());
    krb_set_tkt_string (tkt);
d12 1
a12 6
    status = krb_verify_user(p->user, "", lrealm,
			     p->pop_parm[1], KRB_VERIFY_SECURE, "pop");
    dest_tkt(); /* no point in keeping the tickets */
    return status;
}
#endif /* KRB4 */
d19 1
a19 1
    krb5_get_init_creds_opt get_options;
d25 6
a30 1
    krb5_get_init_creds_opt_init (&get_options);
d32 1
a32 1
    krb5_get_init_creds_opt_set_preauth_list (&get_options,
d37 1
a37 1
    
d40 1
d54 2
a55 1
					&get_options);
d83 1
a83 1
    krb5_free_creds_contents (p->context, &creds);
d87 1
a87 1
/* 
d92 33
d129 1
a129 1
    struct stat st;
d132 1
a132 1
    
a142 16
#ifdef KRB4
	if (p->version == 4) {
	    if(kuserok (&p->kdata, p->user)) {
		pop_log(p, POP_PRIORITY,
			"%s: (%s.%s@@%s) tried to retrieve mail for %s.",
			p->client, p->kdata.pname, p->kdata.pinst,
			p->kdata.prealm, p->user);
		return(pop_msg(p,POP_FAILURE,
			       "Popping not authorized"));
	    }
	    pop_log(p, POP_INFO, "%s: %s.%s@@%s -> %s",
		    p->ipaddr,
		    p->kdata.pname, p->kdata.pinst, p->kdata.prealm,
		    p->user);
	} else
#endif /* KRB4 */
d146 1
a146 1
	    
a186 3
#ifdef KRB4
	     ret = krb4_verify_password (p);
#endif
d196 3
a198 19
    pop_log(p, POP_INFO, "login from %s as %s",
	    p->ipaddr, p->user);

    /*  Build the name of the user's maildrop */
    snprintf(p->drop_name, sizeof(p->drop_name), "%s/%s", POP_MAILDIR, p->user);

    if(stat(p->drop_name, &st) < 0 || !S_ISDIR(st.st_mode)){
	/*  Make a temporary copy of the user's maildrop */
	/*    and set the group and user id */
	if (pop_dropcopy(p, pw) != POP_SUCCESS) return (POP_FAILURE);
	
	/*  Get information about the maildrop */
	if (pop_dropinfo(p) != POP_SUCCESS) return(POP_FAILURE);
    } else {
	if(changeuser(p, pw) != POP_SUCCESS) return POP_FAILURE;
	if(pop_maildir_info(p) != POP_SUCCESS) return POP_FAILURE;
    }
    /*  Initialize the last-message-accessed number */
    p->last_msg = 0;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.7.2
@
text
@d8 1
a8 5
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif

RCSID("$KTH: pop_pass.c,v 1.46 2005/05/11 07:33:38 lha Exp $");
d40 1
a40 1
    krb5_get_init_creds_opt *get_options;
d46 1
a46 6
    ret = krb5_get_init_creds_opt_alloc (p->context, &get_options);
    if (ret) {
	pop_log(p, POP_PRIORITY, "krb5_get_init_creds_opt_init: %s",
		krb5_get_err_text (p->context, ret));
	return 1;
    }
d48 1
a48 1
    krb5_get_init_creds_opt_set_preauth_list (get_options,
d69 1
a69 2
					get_options);
    krb5_get_init_creds_opt_free(get_options);
d97 1
a97 1
    krb5_free_cred_contents (p->context, &creds);
a105 33
login_user(POP *p)
{
    struct stat st;
    struct passwd *pw;

    /*  Look for the user in the password file */
    if ((pw = k_getpwnam(p->user)) == NULL) {
	pop_log(p, POP_PRIORITY, "user %s (from %s) not found",
		p->user, p->ipaddr);
	return pop_msg(p, POP_FAILURE, "Login incorrect.");
    }

    pop_log(p, POP_INFO, "login from %s as %s", p->ipaddr, p->user);
    
    /*  Build the name of the user's maildrop */
    snprintf(p->drop_name, sizeof(p->drop_name), "%s/%s", POP_MAILDIR, p->user);
    if(stat(p->drop_name, &st) < 0 || !S_ISDIR(st.st_mode)){
	/*  Make a temporary copy of the user's maildrop */
	/*    and set the group and user id */
	if (pop_dropcopy(p, pw) != POP_SUCCESS) return (POP_FAILURE);
	
	/*  Get information about the maildrop */
	if (pop_dropinfo(p) != POP_SUCCESS) return(POP_FAILURE);
    } else {
	if(changeuser(p, pw) != POP_SUCCESS) return POP_FAILURE;
	if(pop_maildir_info(p) != POP_SUCCESS) return POP_FAILURE;
    }
    /*  Initialize the last-message-accessed number */
    p->last_msg = 0;
    return POP_SUCCESS;
}

int
d110 1
a110 1
    int status;
d196 19
a214 3
    status = login_user(p);
    if(status != POP_SUCCESS)
	return status;
@

