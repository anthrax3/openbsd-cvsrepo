head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.2
	HEIMDAL_0_6_3:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.18;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.40;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.17.18.43;	author hin;	state dead;
branches;
next	1.1;

1.1
date	2001.05.25.07.46.10;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.46.10;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.04.14.07.32.16;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 2004 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <popper.h>
#ifdef SASL
#include <base64.h>
#include <pop_auth.h>
RCSID("$Id: pop_auth.c,v 1.3 2013/06/17 18:57:40 robert Exp $");

/*
 *  auth: RFC1734
 */

static char *
getline(POP *p)
{
    char *buf = NULL;
    size_t size = 1024;
    buf = malloc(size);
    if(buf == NULL)
	return NULL;
    *buf = '\0';
    while(fgets(buf + strlen(buf), size - strlen(buf), p->input) != NULL) {
	char *p;
	if((p = strchr(buf, '\n')) != NULL) {
	    while(p > buf && p[-1] == '\r')
		p--;
	    *p = '\0';
	    return buf;
	}
	/* just assume we ran out of buffer space, we'll catch eof
           next round */
	size += 1024;
	p = realloc(buf, size);
	if(p == NULL)
	    break;
	buf = p;
    }
    free(buf);
    return NULL;
}

static char auth_msg[128];
void
pop_auth_set_error(const char *message)
{
    strlcpy(auth_msg, message, sizeof(auth_msg));
}

static struct auth_mech *methods[] = {
#ifdef KRB5
    &gssapi_mech,
#endif
    NULL
};

static int
auth_execute(POP *p, struct auth_mech *m, void *state, const char *line)
{
    void *input, *output;
    size_t input_length, output_length;
    int status;

    if(line == NULL) {
	input = NULL;
	input_length = 0;
    } else {
	input = strdup(line);
	if(input == NULL) {
	    pop_auth_set_error("out of memory");
	    return POP_AUTH_FAILURE;
	}
	input_length = base64_decode(line, input);
	if(input_length == (size_t)-1) {
	    pop_auth_set_error("base64 decode error");
	    return POP_AUTH_FAILURE;
	}
    }
    output = NULL; output_length = 0;
    status = (*m->loop)(p, state, input, input_length, &output, &output_length);
    if(output_length > 0) {
	char *s;
	base64_encode(output, output_length, &s);
	fprintf(p->output, "+ %s\r\n", s);
	fflush(p->output);
	free(output);
	free(s);
    }
    return status;
}

static int
auth_loop(POP *p, struct auth_mech *m)
{
    int status;
    void *state = NULL;
    char *line;

    status = (*m->init)(p, &state);

    status = auth_execute(p, m, state, p->pop_parm[2]);

    while(status == POP_AUTH_CONTINUE) {
	line = getline(p);
	if(line == NULL) {
	    (*m->cleanup)(p, state);
	    return pop_msg(p, POP_FAILURE, "error reading data");
	}
	if(strcmp(line, "*") == 0) {
	    (*m->cleanup)(p, state);
	    return pop_msg(p, POP_FAILURE, "terminated by client");
	}
	status = auth_execute(p, m, state, line);
	free(line);
    }


    (*m->cleanup)(p, state);
    if(status == POP_AUTH_FAILURE)
	return pop_msg(p, POP_FAILURE, "%s", auth_msg);

    status = login_user(p);
    if(status != POP_SUCCESS)
	return status;
    return pop_msg(p, POP_SUCCESS, "authentication complete");
}

int
pop_auth (POP *p)
{
    int i;

    for (i = 0; methods[i] != NULL; ++i)
	if (strcasecmp(p->pop_parm[1], methods[i]->name) == 0)
	    return auth_loop(p, methods[i]);
    return pop_msg(p, POP_FAILURE,
		   "Authentication method %s unknown", p->pop_parm[1]);
}

void
pop_capa_sasl(POP *p)
{
    int i;

    if(methods[0] == NULL)
	return;

    fprintf(p->output, "SASL");
    for (i = 0; methods[i] != NULL; ++i)
	fprintf(p->output, " %s", methods[i]->name);
    fprintf(p->output, "\r\n");
}
#endif
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d38 1
a38 1
RCSID("$Id$");
@


1.2
log
@These files are not use by us, so they're removed to make the tree
a little bit leaner, and to get rid of some bad string functions.
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d12 1
a12 1
 * 
d16 2
a17 7
 * 
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d20 1
a20 1
 * 
d35 1
d37 2
a38 1
RCSID("$KTH: pop_auth.c,v 1.2 2000/04/12 15:37:45 assar Exp $");
d40 3
a42 7
#ifdef KRB4

enum {
    NO_PROT   = 1,
    INT_PROT  = 2,
    PRIV_PROT = 4
};
d44 2
a45 2
static int
auth_krb4(POP *p)
d47 21
a67 33
    int ret;
    des_cblock key;
    u_int32_t nonce, nonce_reply;
    u_int32_t max_client_packet;
    int protocols = NO_PROT | INT_PROT | PRIV_PROT;
    char data[8];
    int len;
    char *s;
    char instance[INST_SZ];  
    KTEXT_ST authent;
    des_key_schedule schedule;
    struct passwd *pw;

    /* S -> C: 32 bit nonce in MSB base64 */

    des_new_random_key(&key);
    nonce = (key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24)
	     | key[4] | (key[5] << 8) | (key[6] << 16) | (key[7] << 24));
    krb_put_int(nonce, data, 4, 8);
    len = base64_encode(data, 4, &s);

    pop_msg(p, POP_CONTINUE, "%s", s);
    free(s);

    /* C -> S: ticket and authenticator */

    ret = sch_readline(p->input, &s);
    if (ret <= 0 || strcmp (s, "*") == 0)
	return pop_msg(p, POP_FAILURE,
		       "authentication aborted by client");
    len = strlen(s);
    if (len > sizeof(authent.dat)) {
	return pop_msg(p, POP_FAILURE, "data packet too long");
d69 3
d73 6
a78 1
    authent.length = base64_decode(s, authent.dat);
d80 6
a85 11
    k_getsockinst (0, instance, sizeof(instance));
    ret = krb_rd_req(&authent, "pop", instance,
		     p->in_addr.sin_addr.s_addr,
		     &p->kdata, NULL);
    if (ret != 0) {
	return pop_msg(p, POP_FAILURE, "rd_req: %s",
		       krb_get_err_text(ret));
    }
    if (p->kdata.checksum != nonce) {
	return pop_msg(p, POP_FAILURE, "data stream modified");
    }
d87 31
a117 49
    /* S -> C: nonce + 1 | bit | max segment */

    krb_put_int(nonce + 1, data, 4, 7);
    data[4] = protocols;
    krb_put_int(1024, data + 5, 3, 3); /* XXX */
    des_key_sched(&p->kdata.session, schedule);
    des_pcbc_encrypt((des_cblock*)data,
		     (des_cblock*)data, 8,
		     schedule,
		     &p->kdata.session,
		     DES_ENCRYPT);
    len = base64_encode(data, 8, &s);
    pop_msg(p, POP_CONTINUE, "%s", s);

    free(s);

    /* C -> S: nonce | bit | max segment | username */

    ret = sch_readline(p->input, &s);
    if (ret <= 0 || strcmp (s, "*") == 0)
	return pop_msg(p, POP_FAILURE,
		       "authentication aborted");
    len = strlen(s);
    if (len > sizeof(authent.dat)) {
	return pop_msg(p, POP_FAILURE, "data packet too long");
    }

    authent.length = base64_decode(s, authent.dat);
    
    if (authent.length % 8 != 0) {
	return pop_msg(p, POP_FAILURE, "reply is not a multiple of 8 bytes");
    }

    des_key_sched(&p->kdata.session, schedule);
    des_pcbc_encrypt((des_cblock*)authent.dat,
		     (des_cblock*)authent.dat,
		     authent.length,
		     schedule,
		     &p->kdata.session,
		     DES_DECRYPT);

    krb_get_int(authent.dat, &nonce_reply, 4, 0);
    if (nonce_reply != nonce) {
	return pop_msg(p, POP_FAILURE, "data stream modified");
    }
    protocols &= authent.dat[4];
    krb_get_int(authent.dat + 5, &max_client_packet, 3, 0);
    if(authent.dat[authent.length - 1] != '\0') {
	return pop_msg(p, POP_FAILURE, "bad format of username");
d119 1
a119 29
    strncpy (p->user, authent.dat + 8, sizeof(p->user));
    pw = k_getpwnam(p->user);
    if (pw == NULL) {
	return (pop_msg(p,POP_FAILURE,
			"Password supplied for \"%s\" is incorrect.",
			p->user));
    }

    if (kuserok(&p->kdata, p->user)) {
	pop_log(p, POP_PRIORITY,
		"%s: (%s.%s@@%s) tried to retrieve mail for %s.",
		p->client, p->kdata.pname, p->kdata.pinst,
		p->kdata.prealm, p->user);
	return(pop_msg(p,POP_FAILURE,
		       "Popping not authorized"));
    }
    pop_log(p, POP_INFO, "%s: %s.%s@@%s -> %s",
	    p->ipaddr,
	    p->kdata.pname, p->kdata.pinst, p->kdata.prealm,
	    p->user);
    ret = pop_login(p, pw);
    if (protocols & PRIV_PROT)
	;
    else if (protocols & INT_PROT)
	;
    else
	;
    
    return ret;
a120 1
#endif /* KRB4 */
a121 1
#ifdef KRB5
d123 1
a123 1
auth_gssapi(POP *p)
d125 21
a145 3
    
}
#endif /* KRB5 */
a146 3
/* 
 *  auth: RFC1734
 */
d148 9
a156 12
static struct {
    const char *name;
    int (*func)(POP *);
} methods[] = {
#ifdef KRB4
    {"KERBEROS_V4",	auth_krb4},
#endif
#ifdef KRB5
    {"GSSAPI",		auth_gssapi},
#endif
    {NULL,		NULL}
};
d163 3
a165 3
    for (i = 0; methods[i].name != NULL; ++i)
	if (strcasecmp(p->pop_parm[1], methods[i].name) == 0)
	    return (*methods[i].func)(p);
d169 15
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.7.2
@
text
@d2 35
a36 30
 * Copyright (c) 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a39 1
#ifdef SASL
d41 1
a41 2
#include <pop_auth.h>
RCSID("$KTH: pop_auth.c,v 1.5 2004/07/14 09:11:52 joda Exp $");
d43 7
a49 3
/* 
 *  auth: RFC1734
 */
d51 2
a52 2
static char *
getline(POP *p)
d54 74
a127 21
    char *buf = NULL;
    size_t size = 1024;
    buf = malloc(size);
    if(buf == NULL)
	return NULL;
    *buf = '\0';
    while(fgets(buf + strlen(buf), size - strlen(buf), p->input) != NULL) {
	char *p;
	if((p = strchr(buf, '\n')) != NULL) {
	    while(p > buf && p[-1] == '\r')
		p--;
	    *p = '\0';
	    return buf;
	} 
	/* just assume we ran out of buffer space, we'll catch eof
           next round */
	size += 1024;
	p = realloc(buf, size);
	if(p == NULL)
	    break;
	buf = p;
a128 3
    free(buf);
    return NULL;
}
d130 5
a134 6
static char auth_msg[128];
void
pop_auth_set_error(const char *message)
{
    strlcpy(auth_msg, message, sizeof(auth_msg));
}
d136 24
a159 9
static struct auth_mech *methods[] = {
#ifdef KRB5
    &gssapi_mech,
#endif
#ifdef KRB4
    &krb4_mech,
#endif
    NULL
};
d161 7
a167 31
static int
auth_execute(POP *p, struct auth_mech *m, void *state, const char *line)
{
    void *input, *output;
    size_t input_length, output_length;
    int status;

    if(line == NULL) {
	input = NULL;
	input_length = 0;
    } else {
	input = strdup(line);
	if(input == NULL) {
	    pop_auth_set_error("out of memory");
	    return POP_AUTH_FAILURE;
	}
	input_length = base64_decode(line, input);
	if(input_length == (size_t)-1) {
	    pop_auth_set_error("base64 decode error");
	    return POP_AUTH_FAILURE;
	}
    }
    output = NULL; output_length = 0;
    status = (*m->loop)(p, state, input, input_length, &output, &output_length);
    if(output_length > 0) {
	char *s;
	base64_encode(output, output_length, &s);
	fprintf(p->output, "+ %s\r\n", s);
	fflush(p->output);
	free(output);
	free(s);
d169 13
a181 1
    return status;
d183 1
d185 1
d187 1
a187 1
auth_loop(POP *p, struct auth_mech *m)
a188 21
    int status;
    void *state = NULL;
    char *line;

    status = (*m->init)(p, &state);

    status = auth_execute(p, m, state, p->pop_parm[2]);

    while(status == POP_AUTH_CONTINUE) {
	line = getline(p);
	if(line == NULL) {
	    (*m->cleanup)(p, state);
	    return pop_msg(p, POP_FAILURE, "error reading data");
	}
	if(strcmp(line, "*") == 0) {
	    (*m->cleanup)(p, state);
	    return pop_msg(p, POP_FAILURE, "terminated by client");
	}
	status = auth_execute(p, m, state, line);
	free(line);
    }
d190 6
d197 12
a208 9
    (*m->cleanup)(p, state);
    if(status == POP_AUTH_FAILURE)
	return pop_msg(p, POP_FAILURE, "%s", auth_msg);

    status = login_user(p);
    if(status != POP_SUCCESS)
	return status;
    return pop_msg(p, POP_SUCCESS, "authentication complete");
}
d215 3
a217 3
    for (i = 0; methods[i] != NULL; ++i)
	if (strcasecmp(p->pop_parm[1], methods[i]->name) == 0)
	    return auth_loop(p, methods[i]);
a220 15

void
pop_capa_sasl(POP *p)
{
    int i;

    if(methods[0] == NULL)
	return;
    
    fprintf(p->output, "SASL");
    for (i = 0; methods[i] != NULL; ++i)
	fprintf(p->output, " %s", methods[i]->name);
    fprintf(p->output, "\r\n");
}
#endif
@

