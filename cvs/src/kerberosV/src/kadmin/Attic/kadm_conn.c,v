head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.22.10.01.25;	author reyk;	state dead;
branches;
next	1.7;

1.7
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.14.08.15.03;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.11.03.39.59;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.14.53.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.02.02.34.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.18.00.48.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.43;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.43;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.21.37;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.28;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.32.38;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 2000 - 2004 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kadmin_locl.h"
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

struct kadm_port {
    char *port;
    unsigned short def_port;
    struct kadm_port *next;
} *kadm_ports;

static void
add_kadm_port(krb5_context contextp, const char *service, unsigned int port)
{
    struct kadm_port *p;
    p = malloc(sizeof(*p));
    if(p == NULL) {
	krb5_warnx(contextp, "failed to allocate %lu bytes\n",
		   (unsigned long)sizeof(*p));
	return;
    }

    p->port = strdup(service);
    p->def_port = port;

    p->next = kadm_ports;
    kadm_ports = p;
}

static void
add_standard_ports (krb5_context contextp)
{
    add_kadm_port(contextp, "kerberos-adm", 749);
}

/*
 * parse the set of space-delimited ports in `str' and add them.
 * "+" => all the standard ones
 * otherwise it's port|service[/protocol]
 */

void
parse_ports(krb5_context contextp, const char *str)
{
    char p[128];

    while(strsep_copy(&str, " \t", p, sizeof(p)) != -1) {
	if(strcmp(p, "+") == 0)
	    add_standard_ports(contextp);
	else
	    add_kadm_port(contextp, p, 0);
    }
}

static pid_t pgrp;
sig_atomic_t term_flag, doing_useful_work;

static RETSIGTYPE
sigchld(int sig)
{
    int status;
    /*
     * waitpid() is async safe. will return -1 or 0 on no more zombie
     * children
     */
    while ((waitpid(-1, &status, WNOHANG)) > 0)
	;
    SIGRETURN(0);
}

static RETSIGTYPE
terminate(int sig)
{
    if(getpid() == pgrp) {
	/* parent */
	term_flag = 1;
	signal(sig, SIG_IGN);
	killpg(pgrp, sig);
    } else {
	/* child */
	if(doing_useful_work)
	    term_flag = 1;
	else
	    exit(0);
    }
    SIGRETURN(0);
}

static int
spawn_child(krb5_context contextp, int *socks,
	    unsigned int num_socks, int this_sock)
{
    int e;
    size_t i;
    struct sockaddr_storage __ss;
    struct sockaddr *sa = (struct sockaddr *)&__ss;
    socklen_t sa_size = sizeof(__ss);
    krb5_socket_t s;
    pid_t pid;
    krb5_address addr;
    char buf[128];
    size_t buf_len;

    s = accept(socks[this_sock], sa, &sa_size);
    if(rk_IS_BAD_SOCKET(s)) {
	krb5_warn(contextp, rk_SOCK_ERRNO, "accept");
	return 1;
    }
    e = krb5_sockaddr2address(contextp, sa, &addr);
    if(e)
	krb5_warn(contextp, e, "krb5_sockaddr2address");
    else {
	e = krb5_print_address (&addr, buf, sizeof(buf),
				&buf_len);
	if(e)
	    krb5_warn(contextp, e, "krb5_print_address");
	else
	    krb5_warnx(contextp, "connection from %s", buf);
	krb5_free_address(contextp, &addr);
    }

    pid = fork();
    if(pid == 0) {
	for(i = 0; i < num_socks; i++)
	    rk_closesocket(socks[i]);
	dup2(s, STDIN_FILENO);
	dup2(s, STDOUT_FILENO);
	if(s != STDIN_FILENO && s != STDOUT_FILENO)
	    rk_closesocket(s);
	return 0;
    } else {
	rk_closesocket(s);
    }
    return 1;
}

static void
wait_for_connection(krb5_context contextp,
		    krb5_socket_t *socks, unsigned int num_socks)
{
    unsigned int i;
    int e;
    fd_set orig_read_set, read_set;
    int status, max_fd = -1;

    FD_ZERO(&orig_read_set);

    for(i = 0; i < num_socks; i++) {
#ifdef FD_SETSIZE
	if (socks[i] >= FD_SETSIZE)
	    errx (1, "fd too large");
#endif
	FD_SET(socks[i], &orig_read_set);
	max_fd = max(max_fd, socks[i]);
    }

    pgrp = getpid();

    if(setpgid(0, pgrp) < 0)
	err(1, "setpgid");

    signal(SIGTERM, terminate);
    signal(SIGINT, terminate);
    signal(SIGCHLD, sigchld);

    while (term_flag == 0) {
	read_set = orig_read_set;
	e = select(max_fd + 1, &read_set, NULL, NULL, NULL);
	if(rk_IS_SOCKET_ERROR(e)) {
	    if(rk_SOCK_ERRNO != EINTR)
		krb5_warn(contextp, rk_SOCK_ERRNO, "select");
	} else if(e == 0)
	    krb5_warnx(contextp, "select returned 0");
	else {
	    for(i = 0; i < num_socks; i++) {
		if(FD_ISSET(socks[i], &read_set))
		    if(spawn_child(contextp, socks, num_socks, i) == 0)
			return;
	    }
	}
    }
    signal(SIGCHLD, SIG_IGN);

    while ((waitpid(-1, &status, WNOHANG)) > 0)
	;

    exit(0);
}


void
start_server(krb5_context contextp, const char *port_str)
{
    int e;
    struct kadm_port *p;

    krb5_socket_t *socks = NULL, *tmp;
    unsigned int num_socks = 0;
    int i;

    if (port_str == NULL)
	port_str = "+";

    parse_ports(contextp, port_str);

    for(p = kadm_ports; p; p = p->next) {
	struct addrinfo hints, *ai, *ap;
	char portstr[32];
	memset (&hints, 0, sizeof(hints));
	hints.ai_flags    = AI_PASSIVE;
	hints.ai_socktype = SOCK_STREAM;

	e = getaddrinfo(NULL, p->port, &hints, &ai);
	if(e) {
	    snprintf(portstr, sizeof(portstr), "%u", p->def_port);
	    e = getaddrinfo(NULL, portstr, &hints, &ai);
	}

	if(e) {
	    krb5_warn(contextp, krb5_eai_to_heim_errno(e, errno),
		      "%s", portstr);
	    continue;
	}
	i = 0;
	for(ap = ai; ap; ap = ap->ai_next)
	    i++;
	tmp = realloc(socks, (num_socks + i) * sizeof(*socks));
	if(tmp == NULL) {
	    krb5_warnx(contextp, "failed to reallocate %lu bytes",
		       (unsigned long)(num_socks + i) * sizeof(*socks));
	    continue;
	}
	socks = tmp;
	for(ap = ai; ap; ap = ap->ai_next) {
	    krb5_socket_t s = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);
	    if(rk_IS_BAD_SOCKET(s)) {
		krb5_warn(contextp, rk_SOCK_ERRNO, "socket");
		continue;
	    }

	    socket_set_reuseaddr(s, 1);
	    socket_set_ipv6only(s, 1);

	    if (rk_IS_SOCKET_ERROR(bind (s, ap->ai_addr, ap->ai_addrlen))) {
		krb5_warn(contextp, rk_SOCK_ERRNO, "bind");
		rk_closesocket(s);
		continue;
	    }
	    if (rk_IS_SOCKET_ERROR(listen (s, SOMAXCONN))) {
		krb5_warn(contextp, rk_SOCK_ERRNO, "listen");
		rk_closesocket(s);
		continue;
	    }
	    socks[num_socks++] = s;
	}
	freeaddrinfo (ai);
    }
    if(num_socks == 0)
	krb5_errx(contextp, 1, "no sockets to listen to - exiting");

    wait_for_connection(contextp, socks, num_socks);
}
@


1.7
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.6
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 2000 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a38 2
RCSID("$KTH: kadm_conn.c,v 1.15 2004/05/13 17:46:20 joda Exp $");

d46 1
a46 1
add_kadm_port(krb5_context context, const char *service, unsigned int port)
d51 1
a51 1
	krb5_warnx(context, "failed to allocate %lu bytes\n", 
d55 1
a55 1
    
d64 1
a64 1
add_standard_ports (krb5_context context)
d66 1
a66 1
    add_kadm_port(context, "kerberos-adm", 749);
d76 1
a76 1
parse_ports(krb5_context context, const char *str)
d82 1
a82 1
	    add_standard_ports(context);
d84 1
a84 1
	    add_kadm_port(context, p, 0);
d89 1
a89 1
volatile sig_atomic_t term_flag, doing_useful_work;
a93 1
    int save_errno = errno;
d95 6
a100 2
    waitpid(-1, &status, 0);
    errno = save_errno;
a106 1
    int save_errno = errno;
d117 1
a117 1
	    _exit(0);
a118 1
    errno = save_errno;
d123 2
a124 1
spawn_child(krb5_context context, int *socks, int num_socks, int this_sock)
d126 2
a127 1
    int e, i;
d131 1
a131 1
    int s;
d138 2
a139 2
    if(s < 0) {
	krb5_warn(context, errno, "accept");
d142 1
a142 1
    e = krb5_sockaddr2address(context, sa, &addr);
d144 1
a144 1
	krb5_warn(context, e, "krb5_sockaddr2address");
d146 1
a146 1
	e = krb5_print_address (&addr, buf, sizeof(buf), 
d148 2
a149 2
	if(e) 
	    krb5_warn(context, e, "krb5_print_address");
d151 2
a152 2
	    krb5_warnx(context, "connection from %s", buf);
	krb5_free_address(context, &addr);
d154 1
a154 1
    
d158 1
a158 1
	    close(socks[i]);
d162 1
a162 1
	    close(s);
d165 1
a165 1
	close(s);
d170 3
a172 3
static int
wait_for_connection(krb5_context context,
		    int *socks, int num_socks)
d174 2
a175 1
    int i, e;
d177 2
a178 2
    int max_fd = -1;
    
d180 1
a180 1
    
d182 1
d185 1
d189 1
a189 1
    
d202 3
a204 3
	if(e < 0) {
	    if(errno != EINTR)
		krb5_warn(context, errno, "select");
d206 1
a206 1
	    krb5_warnx(context, "select returned 0");
d210 2
a211 2
		    if(spawn_child(context, socks, num_socks, i) == 0)
			return 0;
d215 5
a219 8
    signal(SIGCHLD, SIG_DFL);
    while(1) {
	int status;
	pid_t pid;
	pid = waitpid(-1, &status, 0);
	if(pid == -1 && errno == ECHILD)
	    break;
    }
d224 2
a225 2
int
start_server(krb5_context context)
d230 2
a231 2
    int *socks = NULL, *tmp;
    int num_socks = 0;
d234 5
d253 1
a253 1
	    krb5_warn(context, krb5_eai_to_heim_errno(e, errno),
d258 1
a258 1
	for(ap = ai; ap; ap = ap->ai_next) 
d262 1
a262 1
	    krb5_warnx(context, "failed to reallocate %lu bytes", 
d268 3
a270 4
	    int one = 1;
	    int s = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);
	    if(s < 0) {
		krb5_warn(context, errno, "socket");
d273 7
a279 8
#if defined(SO_REUSEADDR) && defined(HAVE_SETSOCKOPT)
	    if(setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
			  sizeof(one)) < 0)
		krb5_warn(context, errno, "setsockopt");
#endif
	    if (bind (s, ap->ai_addr, ap->ai_addrlen) < 0) {
		krb5_warn(context, errno, "bind");
		close(s);
d282 3
a284 3
	    if (listen (s, SOMAXCONN) < 0) {
		krb5_warn(context, errno, "listen");
		close(s);
d292 3
a294 2
	krb5_errx(context, 1, "no sockets to listen to - exiting");
    return wait_for_connection(context, socks, num_socks);
@


1.5
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2001 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: kadm_conn.c,v 1.14 2002/10/21 13:21:24 joda Exp $");
a64 2
extern int do_kerberos4;

a68 4
#ifdef KRB4
    if(do_kerberos4)
	add_kadm_port(context, "kerberos-master", 751);
#endif
@


1.4
log
@Use SIG_DFL to reset SIGCHLD handlers, not SIG_IGN which has a different
meaning now.
@
text
@d39 1
a39 1
RCSID("$KTH: kadm_conn.c,v 1.13 2001/05/16 22:06:44 assar Exp $");
d65 2
d72 2
a73 1
    add_kadm_port(context, "kerberos-master", 751);
@


1.3
log
@fix simple signal handlers
@
text
@d214 1
a214 1
    signal(SIGCHLD, SIG_IGN);
@


1.2
log
@volatile sig_atomic_t
@
text
@d99 1
d102 1
d109 1
d120 1
a120 1
	    exit(0);
d122 1
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
RCSID("$KTH: kadm_conn.c,v 1.11 2001/01/29 08:43:01 assar Exp $");
d94 1
a94 1
sig_atomic_t term_flag, doing_useful_work;
d140 1
a140 1
    e = krb5_sockaddr2address(sa, &addr);
d147 1
a147 1
	    krb5_warn(context, e, "krb5_sockaddr2address");
d246 2
a247 1
	    krb5_warn(context, krb5_eai_to_heim_errno(e), "%s", portstr);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d39 1
a39 1
RCSID("$KTH: kadm_conn.c,v 1.13 2001/05/16 22:06:44 assar Exp $");
d140 1
a140 1
    e = krb5_sockaddr2address(context, sa, &addr);
d147 1
a147 1
	    krb5_warn(context, e, "krb5_print_address");
d246 1
a246 2
	    krb5_warn(context, krb5_eai_to_heim_errno(e, errno),
		      "%s", portstr);
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d39 1
a39 1
RCSID("$KTH: kadm_conn.c,v 1.14 2002/10/21 13:21:24 joda Exp $");
a64 2
extern int do_kerberos4;

d70 1
a70 2
    if(do_kerberos4)
	add_kadm_port(context, "kerberos-master", 751);
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2004 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: kadm_conn.c,v 1.15 2004/05/13 17:46:20 joda Exp $");
d65 2
d71 4
@


