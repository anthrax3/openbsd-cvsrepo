head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.4.0.28
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.26
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.24
	OPENBSD_5_0:1.1.1.4.0.22
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.20
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.18
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.14
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.6
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.4
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.2
	OPENBSD_3_4_BASE:1.1.1.2
	HEIMDAL_0_6:1.1.1.2
	HEIMDAL_0_6RC1:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2013.06.17.18.57.41;	author robert;	state dead;
branches;
next	1.1;

1.1
date	2003.05.11.02.14.25;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.05.11.02.14.25;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.13.02.58.26;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.10.29.15.55.28;	author biorn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.32.34;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@This is heimdal.info, produced by makeinfo version 4.5 from
heimdal.texi.

INFO-DIR-SECTION Heimdal
START-INFO-DIR-ENTRY
* Heimdal: (heimdal).           The Kerberos 5 distribution from KTH
END-INFO-DIR-ENTRY


File: heimdal.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Heimdal
*******

* Menu:

* Introduction::
* What is Kerberos?::
* Building and Installing::
* Setting up a realm::
* Things in search for a better place::
* Kerberos 4 issues::
* Windows 2000 compatability::
* Programming with Kerberos::
* Migration::
* Acknowledgments::


File: heimdal.info,  Node: Introduction,  Next: What is Kerberos?,  Prev: Top,  Up: Top

Introduction
************

What is Heimdal?
================

Heimdal is a free implementation of Kerberos 5. The goals are to:

   * have an implementation that can be freely used by anyone

   * be protocol compatible with existing implementations and, if not in
     conflict, with RFC 1510 (and any future updated RFC)

   * be reasonably compatible with the M.I.T Kerberos V5 API

   * have support for Kerberos V5 over GSS-API (RFC1964)

   * include the most important and useful application programs (rsh,
     telnet, popper, etc.)

   * include enough backwards compatibility with Kerberos V4

Status
======

Heimdal has the following features (this does not mean any of this
works):

   * a stub generator and a library to encode/decode/whatever ASN.1/DER
     stuff

   * a `libkrb5' library that should be possible to get to work with
     simple applications

   * a GSS-API library that should have all the important functions for
     building applications

   * Eric Young's `libdes'

   * `kinit', `klist', `kdestroy'

   * `telnet', `telnetd'

   * `rsh', `rshd'

   * `popper', `push' (a movemail equivalent)

   * `ftp', and `ftpd'

   * a library `libkafs' for authenticating to AFS and a program
     `afslog' that uses it

   * some simple test programs

   * a KDC that supports most things; optionally, it may also support
     Kerberos V4 and kaserver,

   * simple programs for distributing databases between a KDC master and
     slaves

   * a password changing daemon `kpasswdd', library functions for
     changing passwords and a simple client

   * some kind of administration system

   * Kerberos V4 support in many of the applications.

Bug reports
===========

If you find bugs in this software, make sure it is a genuine bug and not
just a part of the code that isn't implemented.

Bug reports should be sent to <heimdal-bugs@@pdc.kth.se>. Please include
information on what machine and operating system (including version)
you are running, what you are trying to do, what happens, what you
think should have happened, an example for us to repeat, the output you
get when trying the example, and a patch for the problem if you have
one. Please make any patches with `diff -u' or `diff -c'.

Suggestions, comments and other non bug reports are also welcome.

Mailing list
============

There are two mailing lists with talk about Heimdal.
<heimdal-announce@@sics.se> is a low-volume announcement list, while
<heimdal-discuss@@sics.se> is for general discussion.  Send a message to
<majordomo@@sics.se> to subscribe.

Heimdal source code, binaries and the manual
============================================

The source code for heimdal, links to binaries and the manual (this
document) can be found on our web-page at
<http://www.pdc.kth.se/heimdal/>.


File: heimdal.info,  Node: What is Kerberos?,  Next: Building and Installing,  Prev: Introduction,  Up: Top

What is Kerberos?
*****************

     Now this Cerberus had three heads of dogs,
             the tail of a dragon, and on his back the
             heads of all sorts of snakes.
             -- Pseudo-Apollodorus Library 2.5.12

Kerberos is a system for authenticating users and services on a network.
It is built upon the assumption that the network is "unsafe".  For
example, data sent over the network can be eavesdropped and altered, and
addresses can also be faked.  Therefore they cannot be used for
authentication purposes.

Kerberos is a trusted third-party service.  That means that there is a
third party (the kerberos server) that is trusted by all the entities on
the network (users and services, usually called "principals").  All
principals share a secret password (or key) with the kerberos server and
this enables principals to verify that the messages from the kerberos
server are authentic.  Thus trusting the kerberos server, users and
services can authenticate each other.

Basic mechanism
===============

     *Note:* This discussion is about Kerberos version 4, but version 5
     works similarly.

In Kerberos, principals use "tickets" to prove that they are who they
claim to be. In the following example, A is the initiator of the
authentication exchange, usually a user, and B is the service that A
wishes to use.

To obtain a ticket for a specific service, A sends a ticket request to
the kerberos server. The request contains A's and B's names (along with
some other fields). The kerberos server checks that both A and B are
valid principals.

Having verified the validity of the principals, it creates a packet
containing A's and B's names, A's network address (A<ADDR>), the
current time (T<ISSUE>), the lifetime of the ticket (LIFE), and a
secret "session key" (K<AB>). This packet is encrypted with B's secret
key (K<B>).  The actual ticket (T<AB>) looks like this: ({A, B,
A<ADDR>, T<ISSUE>, LIFE, K<AB>}K<B>).

The reply to A consists of the ticket (T<AB>), B's name, the current
time, the lifetime of the ticket, and the session key, all encrypted in
A's secret key ({B, T<ISSUE>, LIFE, K<AB>, T<AB>}K<A>). A decrypts the
reply and retains it for later use.


Before sending a message to B, A creates an authenticator consisting of
A's name, A's address, the current time, and a "checksum" chosen by A,
all encrypted with the secret session key ({A, A<ADDR>, T<CURRENT>,
CHECKSUM}K<AB>). This is sent together with the ticket received from
the kerberos server to B.  Upon reception, B decrypts the ticket using
B's secret key.  Since the ticket contains the session key that the
authenticator was encrypted with, B can now also decrypt the
authenticator. To verify that A really is A, B now has to compare the
contents of the ticket with that of the authenticator. If everything
matches, B now considers A as properly authenticated.

Different attacks
=================

Impersonating A
---------------

An impostor, C could steal the authenticator and the ticket as it is
transmitted across the network, and use them to impersonate A. The
address in the ticket and the authenticator was added to make it more
difficult to perform this attack.  To succeed C will have to either use
the same machine as A or fake the source addresses of the packets. By
including the time stamp in the authenticator, C does not have much
time in which to mount the attack.

Impersonating B
---------------

C can hijack B's network address, and when A sends her credentials, C
just pretend to verify them. C can't be sure that she is talking to A.

Defense strategies
==================

It would be possible to add a "replay cache" to the server side.  The
idea is to save the authenticators sent during the last few minutes, so
that B can detect when someone is trying to retransmit an already used
message. This is somewhat impractical (mostly regarding efficiency),
and is not part of Kerberos 4; MIT Kerberos 5 contains it.

To authenticate B, A might request that B sends something back that
proves that B has access to the session key. An example of this is the
checksum that A sent as part of the authenticator. One typical
procedure is to add one to the checksum, encrypt it with the session
key and send it back to A.  This is called "mutual authentication".

The session key can also be used to add cryptographic checksums to the
messages sent between A and B (known as "message integrity").
Encryption can also be added ("message confidentiality"). This is
probably the best approach in all cases.

Further reading
===============

The original paper on Kerberos from 1988 is `Kerberos: An
Authentication Service for Open Network Systems', by Jennifer Steiner,
Clifford Neuman and Jeffrey I. Schiller.

A less technical description can be found in `Designing an
Authentication System: a Dialogue in Four Scenes' by Bill Bryant, also
from 1988.

These documents can be found on our web-page at
<http://www.pdc.kth.se/kth-krb/>.


File: heimdal.info,  Node: Building and Installing,  Next: Setting up a realm,  Prev: What is Kerberos?,  Up: Top

Building and Installing
***********************

Heimdal uses GNU Autoconf to configure for specific hosts, and GNU
Automake to manage makefiles. If this is new to you, the short
instruction is to run the `configure' script in the top level
directory, and when that finishes `make'.

If you want to build the distribution in a different directory from the
source directory, you will need a make that implements VPATH correctly,
such as GNU make.

You will need to build the distribution:

   * A compiler that supports a "loose" ANSI C mode, such as `gcc'.

   * lex or flex

   * awk

   * yacc or bison

   * a socket library

   * NDBM or Berkeley DB for building the server side.

When everything is built, you can install by doing `make install'. The
default location for installation is `/usr/heimdal', but this can be
changed by running `configure' with `--prefix=/some/other/place'.

If you need to change the default behavior, configure understands the
following options:

`--without-berkeley-db'
     DB is preferred before NDBM, but if you for some reason want to
     use NDBM instead, you can use this option.

`--with-krb4=`dir''
     Gives the location of Kerberos 4 libraries and headers. This
     enables Kerberos 4 support in the applications (telnet, rsh,
     popper, etc) and the KDC. It is automatically check for in
     `/usr/athena'. If you keep libraries and headers in different
     places, you can instead give the path to each with the
     `--with-krb4-lib=`dir'', and `--with-krb4-include=`dir'' options.

     You will need a fairly recent version of our Kerberos 4
     distribution for `rshd' and `popper' to support version 4 clients.

`--enable-dce'
     Enables support for getting DCE credentials and tokens.  See the
     README files in `appl/dceutils' for more information.

`--disable-otp'
     By default some of the application programs will build with
     support for one-time passwords (OTP).  Use this option to disable
     that support.

`--enable-osfc2'
     Enable some C2 support for OSF/Digital Unix/Tru64.  Use this
     option if you are running your OSF operating system in C2 mode.

`--with-readline=`dir''
     Gives the path for the GNU Readline library, which will be used in
     some programs. If no readline library is found, the (simpler)
     editline library will be used instead.

`--with-hesiod=`dir''
     Enables hesiod support in push.

`--enable-netinfo'
     Add support for using netinfo to lookup configuration information.
     Probably only useful (and working) on NextStep/Mac OS X.

`--without-ipv6'
     Disable the IPv6 support.

`--with-openldap'
     Compile Heimdal with support for storing the database in LDAP.
     Requires OpenLDAP <http://www.openldap.org>.  See
     <http://www.padl.com/~lukeh/heimdal/> for more information.

`--enable-bigendian'

`--enable-littleendian'
     Normally, the build process will figure out by itself if the
     machine is big or little endian.  It might fail in some cases when
     cross-compiling.  If it does fail to figure it out, use the
     relevant of these two options.

`--with-mips-abi=ABI'
     On Irix there are three different ABIs that can be used (`32',
     `n32', or `64').  This option allows you to override the automatic
     selection.

`--disable-mmap'
     Do not use the mmap system call.  Normally, configure detects if
     there is a working mmap and it is only used if there is one.  Only
     try this option if it fails to work anyhow.



File: heimdal.info,  Node: Setting up a realm,  Next: Things in search for a better place,  Prev: Building and Installing,  Up: Top

Setting up a realm
******************

* Menu:

* Configuration file::
* Creating the database::
* keytabs::
* Serving Kerberos 4/524/kaserver::
* Remote administration::
* Password changing::
* Testing clients and servers::
* Slave Servers::
* Incremental propagation::
* Salting::

A realm is an administrative domain.  The name of a Kerberos realm is
usually the Internet domain name in uppercase.  Call your realm the same
as your Internet domain name if you do not have strong reasons for not
doing so.  It will make life easier for you and everyone else.


File: heimdal.info,  Node: Configuration file,  Next: Creating the database,  Prev: Setting up a realm,  Up: Setting up a realm

Configuration file
==================

To setup a realm you will first have to create a configuration file:
`/etc/krb5.conf'. The `krb5.conf' file can contain many configuration
options, some of which are described here.

There is a sample `krb5.conf' supplied with the distribution.

The configuration file is a hierarchical structure consisting of
sections, each containing a list of bindings (either variable
assignments or subsections). A section starts with `[section-name]'.  A
binding consists of a left hand side, an equal (`=') and a right hand
side (the left hand side tag must be separated from the equal with some
whitespace.) Subsections has a `{' as the first non-whitespace
character after the equal. All other bindings are treated as variable
assignments. The value of a variable extends to the end of the line.

     [section1]
             a-subsection = {
                     var = value1
                     other-var = value with {}
                     sub-sub-section = {
                             var = 123
                     }
             }
             var = some other value
     [section2]
             var = yet another value

In this manual, names of sections and bindings will be given as strings
separated by slashes (`/'). The `other-var' variable will thus be
`section1/a-subsection/other-var'.

For in-depth information about the contents of the config file, refer to
the `krb5.conf' manual page. Some of the more important sections are
briefly described here.

The `libdefaults' section contains a list of library configuration
parameters, such as the default realm and the timeout for kdc
responses. The `realms' section contains information about specific
realms, such as where they hide their KDC. This section serves the same
purpose as the Kerberos 4 `krb.conf' file, but can contain more
information. Finally the `domain_realm' section contains a list of
mappings from domains to realms, equivalent to the Kerberos 4
`krb.realms' file.

To continue with the realm setup, you will have to create a config file,
with contents similar to the following.

     [libdefaults]
             default_realm = MY.REALM
     [realms]
             MY.REALM = {
                     kdc = my.kdc
             }
     [domain_realm]
             .my.domain = MY.REALM

If you use a realm name equal to your domain name, you can omit the
`libdefaults', and `domain_realm', sections. If you have a SRV-record
for your realm, or your kerberos server has CNAME called
`kerberos.my.realm', you can omit the `realms' section too.


File: heimdal.info,  Node: Creating the database,  Next: keytabs,  Prev: Configuration file,  Up: Setting up a realm

Creating the database
=====================

The database library will look for the database in `/var/heimdal', so
you should probably create that directory.

The keys of all the principals are stored in the database.  If you
choose to, these can be encrypted with a master key.  You do not have to
remember this key (or password), but just to enter it once and it will
be stored in a file (`/var/heimdal/m-key').  If you want to have a
master key, run `kstash' to create this master key:

     # kstash
     Master key:
     Verifying password - Master key:

To initialise the database use the `kadmin' program, with the `-l'
option (to enable local database mode). First issue a `init MY.REALM'
command. This will create the database and insert default principals
for that realm. You can have more than one realm in one database, so
`init' does not destroy any old database.

Before creating the database, `init' will ask you some questions about
max ticket lifetimes.

After creating the database you should probably add yourself to it. You
do this with the `add' command. It takes as argument the name of a
principal. The principal should contain a realm, so if you haven't setup
a default realm, you will need to explicitly include the realm.

     # kadmin -l
     kadmin> init MY.REALM
     Realm max ticket life [unlimited]:
     Realm max renewable ticket life [unlimited]:
     kadmin> add me
     Max ticket life [unlimited]:
     Max renewable life [unlimited]:
     Attributes []:
     Password:
     Verifying password - Password:

Now start the KDC and try getting a ticket.

     # kdc &
     # kinit me
     me@@MY.REALMS's Password:
     # klist
     Credentials cache: /tmp/krb5cc_0
             Principal: me@@MY.REALM
     
       Issued           Expires          Principal
     Aug 25 07:25:55  Aug 25 17:25:55  krbtgt/MY.REALM@@MY.REALM

If you are curious you can use the `dump' command to list all the
entries in the database.  It should look something similar to the
following example (note that the entries here are truncated for
typographical reasons):

     kadmin> dump
     me@@MY.REALM 1:0:1:0b01d3cb7c293b57:-:0:7:8aec316b9d1629e3baf8 ...
     kadmin/admin@@MY.REALM 1:0:1:e5c8a2675b37a443:-:0:7:cb913ebf85 ...
     krbtgt/MY.REALM@@MY.REALM 1:0:1:52b53b61c875ce16:-:0:7:c8943be ...
     kadmin/changepw@@MY.REALM 1:0:1:f48c8af2b340e9fb:-:0:7:e3e6088 ...


File: heimdal.info,  Node: keytabs,  Next: Serving Kerberos 4/524/kaserver,  Prev: Creating the database,  Up: Setting up a realm

keytabs
=======

To extract a service ticket from the database and put it in a keytab you
need to first create the principal in the database with `ank' (using
the `--random-key' flag to get a random key) and then extract it with
`ext_keytab'.

     kadmin> add --random-key host/my.host.name
     Max ticket life [unlimited]:
     Max renewable life [unlimited]:
     Attributes []:
     kadmin> ext host/my.host.name
     # ktutil list
     Version  Type             Principal
          1   des-cbc-md5      host/my.host.name@@MY.REALM
          1   des-cbc-md4      host/my.host.name@@MY.REALM
          1   des-cbc-crc      host/my.host.name@@MY.REALM
          1   des3-cbc-sha1    host/my.host.name@@MY.REALM


File: heimdal.info,  Node: Serving Kerberos 4/524/kaserver,  Next: Remote administration,  Prev: keytabs,  Up: Setting up a realm

Serving Kerberos 4/524/kaserver
===============================

Heimdal can be configured to support 524, Kerberos 4 or kaserver. All
theses services are default turned off. Kerberos 4 support also depends
on if Kerberos 4 support is compiled in with heimdal.

524
---

524 is a service that allows the kdc to convert Kerberos 5 tickets to
Kerberos 4 tickets for backward compatibility. See also Using 2b tokens
with AFS in *Note Things in search for a better place::.

524 can be turned on by adding this to the configuration file

     [kdc]
     	enable-524 = yes

Kerberos 4
----------

Kerberos 4 is the predecessor to to Kerberos 5. It only support single
DES. You should only enable Kerberos 4 support if you have a need for
for compatibility with an installed base of Kerberos 4 clients/servers.

Kerberos 4 can be turned on by adding this to the configuration file

     [kdc]
     	enable-kerberos4 = yes

kaserver
--------

Kaserver is a Kerberos 4 that is used in AFS, the protocol have some
features over plain Kerberos 4, but like kerberos 4 only use single DES
too.

You should only enable Kerberos 4 support if you have a need for for
compatibility with an installed base of AFS machines.

Kaserver can be turned on by adding this to the configuration file

     [kdc]
     	enable-kaserver = yes


File: heimdal.info,  Node: Remote administration,  Next: Password changing,  Prev: Serving Kerberos 4/524/kaserver,  Up: Setting up a realm

Remote administration
=====================

The administration server, `kadmind', can be started by `inetd' (which
isn't recommended) or run as a normal daemon. If you want to start it
from `inetd' you should add a line similar to the one below to your
`/etc/inetd.conf'.

     kerberos-adm stream     tcp     nowait  root /usr/heimdal/libexec/kadmind kadmind

You might need to add `kerberos-adm' to your `/etc/services' as 749/tcp.

Access to the admin server is controlled by an acl-file, (default
`/var/heimdal/kadmind.acl'.) The lines in the access file, has the
following syntax:
     principal       [priv1,priv2,...]       [glob-pattern]

The matching is from top to bottom for matching principal (and if given,
glob-pattern).  When there is a match, the rights of that lines are
used.

The privileges you can assign to a principal are: `add',
`change-password' (or `cpw' for short), `delete', `get', `list', and
`modify', or the special privilege `all'. All of these roughly
corresponds to the different commands in `kadmin'.

If a GLOB-PATTERN is given on a line, it restricts the right for the
principal to only apply for the subjects that match the pattern.  The
patters are of the same type as those used in shell globbing, see
<none,,fnmatch(3)>.

In the example below `lha/admin' can change every principal in the
database. `jimmy/admin' can only modify principals that belong to the
realm `E.KTH.SE'. `mille/admin' is working at the helpdesk, so he
should only be able to change the passwords for single component
principals (ordinary users). He will not be able to change any `/admin'
principal.

     lha/admin@@E.KTH.SE	all
     jimmy/admin@@E.KTH.SE	all		*@@E.KTH.SE
     jimmy/admin@@E.KTH.SE	all		*/*@@E.KTH.SE
     mille/admin@@E.KTH.SE	change-password	*@@E.KTH.SE


File: heimdal.info,  Node: Password changing,  Next: Testing clients and servers,  Prev: Remote administration,  Up: Setting up a realm

Password changing
=================

To allow users to change their passwords, you should run `kpasswdd'.
It is not run from `inetd'.

You might need to add `kpasswd' to your `/etc/services' as 464/udp.

Password quality assurance
--------------------------

It is important that users have good passwords, both to make it harder
to guess them and to avoid off-line attacks (pre-authentication provides
some defense against off-line attacks).  To ensure that the users choose
good passwords, you can enable password quality controls in `kpasswdd'.
The controls themselves are done in a shared library that is used by
`kpasswdd'.  To configure in these controls, add lines similar to the
following to your `/etc/krb5.conf':

     [password_quality]
             check_library = LIBRARY
             check_function = FUNCTION

The function FUNCTION in the shared library LIBRARY will be called for
proposed new passwords.  The function should be declared as:

     const char *
     function(krb5_context context, krb5_principal principal, krb5_data *pwd);

The function should verify that PWD is a good password for PRINCIPAL
and if so return `NULL'.  If it is deemed to be of low quality, it
should return a string explaining why that password should not be used.

Code for a password quality checking function that uses the cracklib
library can be found in `lib/kadm5/sample_password_check.c' in the
source code distribution.  It requires the cracklib library built with
the patch available at
<ftp://ftp.pdc.kth.se/pub/krb/src/cracklib.patch>.

If no password quality checking function is configured, it is only
verified that it is at least six characters of length.


File: heimdal.info,  Node: Testing clients and servers,  Next: Slave Servers,  Prev: Password changing,  Up: Setting up a realm

Testing clients and servers
===========================

Now you should be able to run all the clients and servers.  Refer to the
appropriate man pages for information on how to use them.


File: heimdal.info,  Node: Slave Servers,  Next: Incremental propagation,  Prev: Testing clients and servers,  Up: Setting up a realm

Slave servers, Incremental propagation, Testing clients and servers, Setting up a realm
=======================================================================================

It is desirable to have at least one backup (slave) server in case the
master server fails. It is possible to have any number of such slave
servers but more than three usually doesn't buy much more redundancy.

All Kerberos servers for a realm shall have the same database so that
they present the same service to all the users.  The `hprop' program,
running on the master, will propagate the database to the slaves,
running `hpropd' processes.

Every slave needs a keytab with a principal, `hprop/HOSTNAME'.  Add
that with the `ktutil' command and start `propd', as follows:

     slave# ktutil get -p foo/admin hprop/`hostname`
     slave# hpropd

The master will use the principal `kadmin/hprop' to authenticate to the
slaves.  This principal should be added when running `kadmin -l init'
but if you do not have it in your database for whatever reason, please
add it with `kadmin -l add'.

Then run `hprop' on the master:

     master# hprop slave

This was just an on-hands example to make sure that everything was
working properly.  Doing it manually is of course the wrong way and to
automate this you will want to start `hpropd' from `inetd' on the
slave(s) and regularly run `hprop' on the master to regularly propagate
the database.  Starting the propagation once an hour from `cron' is
probably a good idea.


File: heimdal.info,  Node: Incremental propagation,  Next: Salting,  Prev: Slave Servers,  Up: Setting up a realm

Incremental propagation
=======================

There is also a newer and still somewhat experimental mechanism for
doing incremental propagation in Heimdal.  Instead of sending the whole
database regularly, it sends the changes as they happen on the master to
the slaves.  The master keeps track of all the changes by assigned a
version number to every change to the database.  The slaves know which
was the latest version they saw and in this way it can be determined if
they are in sync or not.  A log of all the changes is kept on the master
and when a slave is at an older versioner than the oldest one in the
log, the whole database has to be sent.

Protocol-wise, all the slaves connects to the master and as a greeting
tell it the latest version that they have (`IHAVE' message).  The
master then responds by sending all the changes between that version and
the current version at the master (a series of `FORYOU' messages) or
the whole database in a `TELLYOUEVERYTHING' message.

Configuring incremental propagation
-----------------------------------

The program that runs on the master is `ipropd-master' and all clients
run `ipropd-slave'.

Create the file `/var/heimdal/slaves' on the master containing all the
slaves that the database should be propagated to.  Each line contains
the full name of the principal (for example
`iprop/hemligare.foo.se@@FOO.SE').

You should already have `iprop/tcp' defined as 2121, in your
`/etc/services'.  Otherwise, or if you need to use a different port for
some peculiar reason, you can use the `--port' option.  This is useful
when you have multiple realms to distribute from one server.

Then you need to create these principals that you added in the
configuration file.  Create one `iprop/hostname' for the master and for
every slave.

     master# /usr/heimdal/sbin/ktutil get iprop/`hostname`

The next step is to start the `ipropd-master' process on the master
server.  The `ipropd-master' listens on the UNIX-socket
`/var/heimdal/signal' to know when changes have been made to the
database so they can be propagated to the slaves.  There is also a
safety feature of testing the version number regularly (every 30
seconds) to see if it has been modified by some means that do not raise
this signal.  Then, start `ipropd-slave' on all the slaves:

     master# /usr/heimdal/libexec/ipropd-master &
     slave#  /usr/heimdal/libexec/ipropd-slave master &


File: heimdal.info,  Node: Salting,  Prev: Incremental propagation,  Up: Setting up a realm

Salting
=======

Salting is used to make it harder to precalculate all possible keys.
Using a salt increases the search space to make it almost impossible to
precalculate all keys. Salting is the process of mixing a public string
(the salt) with the password, then sending it through an
encryption-type specific string-to-key function that will output the
fixed size encryption key.

In Kerberos 5 the salt is determined by the encryption-type, except in
some special cases.

In `des' there is the Kerberos 4 salt (none at all) or the afs-salt
(using the cell (realm in afs-lingo)).

In `arcfour' (the encryption type that Microsoft Windows 2000 uses)
there is no salt. This is to be compatible with NTLM keys in Windows NT
4.

`[kadmin]default_keys' in `krb5.conf' controls what salting to use,

The syntax of `[kadmin]default_keys' is
`[etype:]salt-type[:salt-string]'. `etype' is the encryption type (des,
des3, arcfour), `salt-type' is the type of salt (pw-salt or afs3-salt),
and the salt-string is the string that will be used as salt (remember
that if the salt is appened/prepended, the empty salt "" is the same
thing as no salt at all).

Common types of salting includes

   * `v4' (or `des:pw-salt:')

     The Kerberos 4 salting is using no salt att all. Reason there is
     colon that the end or the salt string is that it makes the salt
     the empty string (same as no salt).

   * `v5' (or `pw-salt')

     `pw-salt' means all regular encryption-types that is regular

   * `afs3-salt'

     `afs3-salt' is the salting that is used with Transarc kaserver. Its
     the cell appended to the password.



File: heimdal.info,  Node: Things in search for a better place,  Next: Kerberos 4 issues,  Prev: Setting up a realm,  Up: Top

Things in search for a better place
***********************************

Making things work on Ciscos
============================

Modern versions of Cisco IOS has some support for authenticating via
Kerberos 5. This can be used both by having the router get a ticket when
you login (boring), and by using Kerberos authenticated telnet to access
your router (less boring). The following has been tested on IOS
11.2(12), things might be different with other versions. Old versions
are known to have bugs.

To make this work, you will first have to configure your router to use
Kerberos (this is explained in the documentation). A sample
configuration looks like the following:

     aaa new-model
     aaa authentication login default krb5-telnet krb5 enable
     aaa authorization exec krb5-instance
     kerberos local-realm FOO.SE
     kerberos srvtab entry host/router.foo.se 0 891725446 4 1 8 012345678901234567
     kerberos server FOO.SE 10.0.0.1
     kerberos instance map admin 15

This tells you (among other things) that when logging in, the router
should try to authenticate with kerberised telnet, and if that fails try
to verify a plain text password via a Kerberos ticket exchange (as
opposed to a local database, RADIUS or something similar), and if that
fails try the local enable password. If you're not careful when you
specify the `login default' authentication mechanism, you might not be
able to login at all. The `instance map' and `authorization exec' lines
says that people with `admin' instances should be given `enabled' shells
when logging in.

The numbers after the principal on the `srvtab' line are principal type,
time stamp (in seconds since 1970), key version number (4), keytype (1
== des), key length (always 8 with des), and then the key.

To make the Heimdal KDC produce tickets that the Cisco can decode you
might have to turn on the `encode_as_rep_as_tgs_rep' flag in the KDC.
You will also have to specify that the router can't handle anything but
`des-cbc-crc'. This can be done with the `del_enctype' command of
`kadmin'.

This all fine and so, but unless you have an IOS version with encryption
(available only in the U.S) it doesn't really solve any problems. Sure
you don't have to send your password over the wire, but since the telnet
connection isn't protected it's still possible for someone to steal your
session. This won't be fixed until someone adds integrity to the telnet
protocol.

A working solution would be to hook up a machine with a real operating
system to the console of the Cisco and then use it as a backwards
terminal server.

Making things work on Transarc/OpenAFS AFS
==========================================

How to get a KeyFile
--------------------

`ktutil -k AFSKEYFILE:KeyFile get afs@@MY.REALM'

or you can extract it with kadmin

     kadmin> ext -k AFSKEYFILE:/usr/afs/etc/KeyFile afs@@My.CELL.NAME

You have to make sure you have a `des-cbc-md5' encryption type since
that is the key that will be converted.

How to convert a srvtab to a KeyFile
------------------------------------

You need a `/usr/vice/etc/ThisCell' containing the cellname of you
AFS-cell.

`ktutil copy krb4:/root/afs-srvtab AFSKEYFILE:/usr/afs/etc/KeyFile'.

If keyfile already exists, this will add the new key in afs-srvtab to
KeyFile.

Using 2b tokens with AFS
========================

What is 2b ?
------------

2b is the name of the proposal that was implemented to give basic
Kerberos 5 support to AFS in rxkad. Its not real Kerberos 5 support
since it still uses fcrypt for data encryption and not Kerberos
encryption types.

Its only possible (in all cases) to do this for DES encryption types
because only then the token (the AFS equivalent of a ticket) will be be
smaller than the maximum size that can fit in the token cache in
OpenAFS/Transarc client. Its so tight fit that some extra wrapping on
the ASN1/DER encoding is removed from the Kerberos ticket.

2b uses a Kerberos 5 EncTicketPart instead of a Kerberos 4 ditto for
the part of the ticket that is encrypted with the service's key. The
client doesn't know what's inside the encrypted data so to the client
it doesn't matter.

To  differentiate between Kerberos 4 tickets and Kerberos 5 tickets 2b
uses a special kvno, 213 for 2b tokens and 255 for Kerberos 5 tokens.

Its a requirement that all AFS servers that support 2b also support
native Kerberos 5 in rxkad.

Configuring Heimdal to use 2b tokens
------------------------------------

Support for 2b tokens are turned on for specific principals by adding
them to the string list option `[kdc]use_2b' in the kdc's `krb5.conf'
file.

     [kdc]
     	use_2b = {
     		afs@@SU.SE = yes
     		afs/it.su.se@@SU.SE = yes
     	}

Configuring AFS clients
-----------------------

There is no need to configure AFS clients. The only software that needs
to be installed/upgrade is a Kerberos 5 enabled `afslog'.


File: heimdal.info,  Node: Kerberos 4 issues,  Next: Windows 2000 compatability,  Prev: Things in search for a better place,  Up: Top

Kerberos 4 issues
*****************

If compiled with version 4 support, the KDC can serve requests from a
Kerberos 4 client. There are a few things you must do for this to work.

The KDC will also have kaserver emulation and be able to handle
AFS-clients that use `klog'.

* Menu:

* Principal conversion issues::
* Converting a version 4 database::
* kaserver::


File: heimdal.info,  Node: Principal conversion issues,  Next: Converting a version 4 database,  Prev: Kerberos 4 issues,  Up: Kerberos 4 issues

Principal conversion issues
===========================

First, Kerberos 4 and Kerberos 5 principals are different. A version 4
principal consists of a name, an instance, and a realm. A version 5
principal has one or more components, and a realm (the terms "name" and
"instance" are still used, for the first and second component,
respectively).    Also, in some cases the name of a version 4 principal
differs from the first component of the corresponding version 5
principal. One notable example is the "host" type principals, where the
version 4 name is `rcmd' (for "remote command"), and the version 5 name
is `host'. For the class of principals that has a hostname as instance,
there is an other major difference, Kerberos 4 uses only the first
component of the hostname, whereas Kerberos 5 uses the fully qualified
hostname.

Because of this it can be hard or impossible to correctly convert a
version 4 principal to a version 5 principal (1). The biggest problem is
to know if the conversion resulted in a valid principal. To give an
example, suppose you want to convert the principal `rcmd.foo'.

The `rcmd' name suggests that the instance is a hostname (even if there
are exceptions to this rule). To correctly convert the instance `foo'
to a hostname, you have to know which host it is referring to. You can
to this by either guessing (from the realm) which domain name to
append, or you have to have a list of possible hostnames. In the
simplest cases you can cover most principals with the first rule. If you
have several domains sharing a single realm this will not usually work.
If the exceptions are few you can probably come by with a lookup table
for the exceptions.

In a complex scenario you will need some kind of host lookup mechanism.
Using DNS for this is tempting, but DNS is error prone, slow and unsafe
(2).

Fortunately, the KDC has a trump on hand: it can easily tell if a
principal exists in the database. The KDC will use
`krb5_425_conv_principal_ext' to convert principals when handling to
version 4 requests.

---------- Footnotes ----------

(1) the other way is not always trivial either, but usually easier

(2) at least until secure DNS is commonly available


File: heimdal.info,  Node: Converting a version 4 database,  Next: kaserver,  Prev: Principal conversion issues,  Up: Kerberos 4 issues

Converting a version 4 database
===============================

If you want to convert an existing version 4 database, the principal
conversion issue arises too.

If you decide to convert your database once and for all, you will only
have to do this conversion once. It is also possible to run a version 5
KDC as a slave to a version 4 KDC. In this case this conversion will
happen every time the database is propagated.  When doing this
conversion, there are a few things to look out for. If you have stale
entries in the database, these entries will not be converted. This might
be because these principals are not used anymore, or it might be just
because the principal couldn't be converted.

You might also see problems with a many-to-one mapping of principals.
For instance, if you are using DNS lookups and you have two principals
`rcmd.foo' and `rcmd.bar', where `foo' is a CNAME for `bar', the
resulting principals will be the same. Since the conversion function
can't tell which is correct, these conflicts will have to be resolved
manually.

Conversion example
------------------

Given the following set of hosts and services:

     foo.se          rcmd
     mail.foo.se     rcmd, pop
     ftp.bar.se      rcmd, ftp

you have a database that consists of the following principals:

`rcmd.foo', `rcmd.mail', `pop.mail', `rcmd.ftp', and `ftp.ftp'.

lets say you also got these extra principals: `rcmd.gone',
`rcmd.old-mail', where `gone.foo.se' was a machine that has now passed
away, and `old-mail.foo.se' was an old mail machine that is now a CNAME
for `mail.foo.se'.

When you convert this database you want the following conversions to be
done:
     rcmd.foo         host/foo.se
     rcmd.mail        host/mail.foo.se
     pop.mail         pop/mail.foo.se
     rcmd.ftp         host/ftp.bar.se
     ftp.ftp          ftp/ftp.bar.se
     rcmd.gone        removed
     rcmd.old-mail    removed

A `krb5.conf' that does this looks like:

     [realms]
             FOO.SE = {
                     v4_name_convert = {
                             host = {
                                     ftp = ftp
                                     pop = pop
                                     rcmd = host
                             }
                     }
                     v4_instance_convert = {
                             foo = foo.se
                             ftp = ftp.bar.se
                     }
                     default_domain = foo.se
             }

The `v4_name_convert' section says which names should be considered
having an instance consisting of a hostname, and it also says how the
names should be converted (for instance `rcmd' should be converted to
`host'). The `v4_instance_convert' section says how a hostname should
be qualified (this is just a hosts-file in disguise). Host-instances
that aren't covered by `v4_instance_convert' are qualified by appending
the contents of the `default_domain'.

Actually, this example doesn't work. Or rather, it works to well. Since
it has no way of knowing which hostnames are valid and which are not, it
will happily convert `rcmd.gone' to `host/gone.foo.se'. This isn't a
big problem, but if you have run your kerberos realm for a few years,
chances are big that you have quite a few `junk' principals.

If you don't want this you can remove the `default_domain' statement,
but then you will have to add entries for _all_ your hosts in the
`v4_instance_convert' section.

Instead of doing this you can use DNS to convert instances. This is not
a solution without problems, but it is probably easier than adding lots
of static host entries.

To enable DNS lookup you should turn on `v4_instance_resolve' in the
`[libdefaults]' section.

Converting a database
---------------------

The database conversion is done with `hprop'. You can run this command
to propagate the database to the machine called `slave-server' (which
should be running a `hpropd').

     hprop --source=krb4-db --master-key=/.m slave-server

This command can also be to use for converting the v4 database on the
server:

     hprop -n --source=krb4-db -d /var/kerberos/principal --master-key=/.m | hpropd -n

Version 4 Kadmin
================

`kadmind' can act as a version 4 kadmind, and you can do most
operations, but with some restrictions (since the version 4 kadmin
protocol is, lets say, very ad hoc.) One example is that it only passes
des keys when creating principals and changing passwords (modern kpasswd
clients do send the password, so it's possible to to password quality
checks). Because of this you can only create principals with des keys,
and you can't set any flags or do any other fancy stuff.

To get this to work, you have to add another entry to inetd (since
version 4 uses port 751, not 749).

_And then there are a many more things you can do; more on this in a
later version of this manual. Until then, UTSL._


File: heimdal.info,  Node: kaserver,  Prev: Converting a version 4 database,  Up: Kerberos 4 issues

kaserver
========

kaserver emulation
------------------

The Heimdal kdc can emulate a kaserver. The kaserver is a Kerberos 4
server with pre-authentication using Rx as the on-wire protocol. The kdc
contains a minimalistic Rx implementation.

There are three parts of the kaserver; KAA (Authentication), KAT (Ticket
Granting), and KAM (Maintenance). The KAA interface and KAT interface
both passes over DES encrypted data-blobs (just like the
Kerberos-protocol) and thus do not need any other protection.  The KAM
interface uses `rxkad' (Kerberos authentication layer for Rx) for
security and data protection, and is used for example for changing
passwords.  This part is not implemented in the kdc.

Another difference between the ka-protocol and the Kerberos 4 protocol
is that the pass-phrase is salted with the cellname in the `string to
key' function in the ka-protocol, while in the Kerberos 4 protocol there
is no salting of the password at all. To make sure AFS-compatible keys
are added to each principals when they are created or their password are
changed, `afs3-salt' should be added to `[kadmin]default_keys'.

Transarc AFS Windows client
---------------------------

The Transarc Windows client uses Kerberos 4 to obtain tokens, and thus
does not need a kaserver. The Windows client assumes that the Kerberos
server is on the same machine as the AFS-database server. If you do not
like to do that you can add a small program that runs on the database
servers that forward all kerberos requests to the real kerberos server.
A program that does this is `krb-forward'
(<ftp://ftp.stacken.kth.se/pub/projekts/krb-forward>).


File: heimdal.info,  Node: Windows 2000 compatability,  Next: Programming with Kerberos,  Prev: Kerberos 4 issues,  Up: Top

Windows 2000 compatability
**************************

Windows 2000 (formerly known as Windows NT 5) from Microsoft implements
Kerberos 5.  Their implementation, however, has some quirks,
peculiarities, and bugs.  This chapter is a short summary of the things
that we have found out while trying to test Heimdal against Windows
2000.  Another big problem with the Kerberos implementation in Windows
2000 is that the available documentation is more focused on getting
things to work rather than how they work and not that useful in figuring
out how things really work.

This information should apply to Heimdal 0.3a and Windows 2000
Professional.  It's of course subject all the time and mostly consists
of our not so inspired guesses.  Hopefully it's still somewhat useful.

* Menu:

* Configuring Windows 2000 to use a Heimdal KDC::
* Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC::
* Create account mappings::
* Encryption types::
* Authorization data::
* Quirks of Windows 2000 KDC::
* Useful links when reading about the Windows 2000::


File: heimdal.info,  Node: Configuring Windows 2000 to use a Heimdal KDC,  Next: Inter-Realm keys (trust) between Windows 2000 and a Heimdal KDC,  Prev: Windows 2000 compatability,  Up: Windows 2000 compatability

Configuring Windows 2000 to use a Heimdal KDC
=============================================

You need the command line program called `ksetup.exe' which is available
in the file `SUPPORT/TOOLS/SUPPORT.CAB' on the Windows 2000 Professional
CD-ROM. This program is used to configure the Kerberos settings on a
Workstation.

`Ksetup' store the domain information under the registry key:
`HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\LSA\Kerberos\Domains'.

Use the kadmin program in Heimdal to create a host principal in the
Kerberos realm.

     unix% kadmin
     kadmin> ank -pw password host/datan.my.domain

You must configure the Workstation as a member of a workgroup, as
opposed to a member in an NT domain, and specify the KDC server of the
realm as follows:
     C:> ksetup /setdomain MY.REALM
     C:> ksetup /addkdc MY.REALM kdc.my.domain

Set the machine password, i.e. create the local keytab:
     C:> ksetup /setmachpassword password

The workstation must now be rebooted.

A mapping between local NT users and Kerberos principals must be
specified, you have two choices:

     C:> ksetup /mapuser user@@MY.REALM nt_user

This will map a user to a specific principal, this allows you to have
other usernames in the realm than in your NT user database. (Don't ask
me why on earth you would want that...)

You can also say:
     C:> ksetup /mapuser * *
The Windows machine will now map any user to the corresponding
principal, for example `nisse' to the principal `nisse@@MY.REALM'.
(This is most likely what you want.)

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of heimdal-0.6rc1
@
text
@@


1.1.1.2
log
@Import of heimdal-0.6, released earlier today.
@
text
@d1 1
a1 1
This is heimdal.info, produced by makeinfo version 4.0 from
d348 1
@


1.1.1.3
log
@Import of heimdal-0.6.3
@
text
@d1 2
a2 2
This is Info file heimdal.info, produced by Makeinfo version 1.68 from
the input file heimdal.texi.
d126 1
a126 1
`http://www.pdc.kth.se/heimdal/'.
d181 1
d245 1
a245 1
`http://www.pdc.kth.se/kth-krb/'.
d328 2
a329 2
     Requires OpenLDAP `http://www.openldap.org'.  See
     `http://www.padl.com/~lukeh/heimdal/' for more information.
a366 3
* Cross realm::
* Transit policy::
* Setting up DNS::
d410 3
a412 3
For in-depth information about the contents of the configuration file,
refer to the `krb5.conf' manual page. Some of the more important
sections are briefly described here.
d415 1
a415 1
parameters, such as the default realm and the timeout for KDC
d423 2
a424 2
To continue with the realm setup, you will have to create a
configuration file, with contents similar to the following.
d430 1
a430 2
                     kdc = my.kdc my.slave.kdc
                     kdc = my.third.kdc
d437 1
a437 1
for your realm, or your Kerberos server has CNAME called
d446 2
a447 5
The database library will look for the database in the directory
`/var/heimdal', so you should probably create that directory.  Make
sure the directory have restrictive permissions.

     # mkdir /var/heimdal
d538 1
a538 1
on if Kerberos 4 support is compiled in with Heimdal.
d543 1
a543 1
524 is a service that allows the KDC to convert Kerberos 5 tickets to
d568 1
a568 1
features over plain Kerberos 4, but like Kerberos 4 only use single DES
d594 3
a596 3
Access to the administration server is controlled by an acl-file,
(default `/var/heimdal/kadmind.acl'.) The lines in the access file, has
the following syntax:
d611 1
a611 1
`none,,fnmatch(3)'.
d615 1
a615 1
realm `E.KTH.SE'. `mille/admin' is working at the help desk, so he
d665 1
a665 1
`ftp://ftp.pdc.kth.se/pub/krb/src/cracklib.patch'.
d694 2
a695 4
Every slave needs a database directory, the master key (if it was used
for the database) and a keytab with the principal `hprop/HOSTNAME'.
Add the principal with the `ktutil' command and start `propd', as
follows:
a697 1
     slave# mkdir /var/heimdal
d772 1
a772 1
File: heimdal.info,  Node: Salting,  Next: Cross realm,  Prev: Incremental propagation,  Up: Setting up a realm
d800 1
a800 1
that if the salt is appended/prepended, the empty salt "" is the same
a819 135

File: heimdal.info,  Node: Cross realm,  Next: Transit policy,  Prev: Salting,  Up: Setting up a realm

Cross realm
===========

Suppose you are residing in the realm `MY.REALM', how do you
authenticate to a server in `OTHER.REALM'? Having valid tickets in
`MY.REALM' allows you to communicate with kerberised services in that
realm. However, the computer in the other realm does not have a secret
key shared with the Kerberos server in your realm.

It is possible to add a share keys between two realms that trust each
other. When a client program, such as `telnet' or `ssh', finds that the
other computer is in a different realm, it will try to get a ticket
granting ticket for that other realm, but from the local Kerberos
server. With that ticket granting ticket, it will then obtain service
tickets from the Kerberos server in the other realm.

For a two way trust between `MY.REALM' and `OTHER.REALM' add the
following principals to each realm. The principals should be
`krbtgt/OTHER.REALM@@MY.REALM' and `krbtgt/MY.REALM@@OTHER.REALM' in
`MY.REALM', and `krbtgt/MY.REALM@@OTHER.REALM' and
`krbtgt/OTHER.REALM@@MY.REALM'in `OTHER.REALM'.

In Kerberos 5 the trust can be one configured to be one way. So that
users from `MY.REALM' can authenticate to services in `OTHER.REALM',
but not the opposite. In the example above, the
`krbtgt/MY.REALM@@OTHER.REALM' then should be removed.

The two principals must have the same key, key version number, and the
same set of encryption types. Remember to transfer the two keys in a
safe manner.

     vr$ klist
     Credentials cache: FILE:/tmp/krb5cc_913.console
             Principal: lha@@E.KTH.SE
     
       Issued           Expires          Principal
     May  3 13:55:52  May  3 23:55:54  krbtgt/E.KTH.SE@@E.KTH.SE
     
     vr$ telnet -l lha hummel.it.su.se
     Trying 2001:6b0:5:1095:250:fcff:fe24:dbf...
     Connected to hummel.it.su.se.
     Escape character is '^]'.
     Waiting for encryption to be negotiated...
     [ Trying mutual KERBEROS5 (host/hummel.it.su.se@@SU.SE)... ]
     [ Kerberos V5 accepts you as ``lha@@E.KTH.SE'' ]
     Encryption negotiated.
     Last login: Sat May  3 14:11:47 from vr.l.nxs.se
     hummel$ exit
     
     vr$ klist
     Credentials cache: FILE:/tmp/krb5cc_913.console
             Principal: lha@@E.KTH.SE
     
       Issued           Expires          Principal
     May  3 13:55:52  May  3 23:55:54  krbtgt/E.KTH.SE@@E.KTH.SE
     May  3 13:55:56  May  3 23:55:54  krbtgt/SU.SE@@E.KTH.SE
     May  3 14:10:54  May  3 23:55:54  host/hummel.it.su.se@@SU.SE


File: heimdal.info,  Node: Transit policy,  Next: Setting up DNS,  Prev: Cross realm,  Up: Setting up a realm

Transit policy
==============

If you want to use cross realm authentication through an intermediate
realm it must be explicitly allowed by either the KDCs or the server
receiving the request. This is done in `krb5.conf' in the `[capaths]'
section.

When the ticket transits through a realm to another realm, the
destination realm adds its peer to the "transited-realms" field in the
ticket. The field is unordered, this is since there is no way to know if
know if one of the transited-realms changed the order of the list.

The syntax for `[capaths]' section:

     [capaths]
             CLIENT-REALM = {
                     SERVER-REALM = PERMITTED-CROSS-REALMS ...
             }

The realm `STACKEN.KTH.SE' allows clients from `SU.SE' and `DSV.SU.SE'
to cross in. Since `STACKEN.KTH.SE' only have direct cross realm with
`KTH.SE', and `DSV.SU.SE' only have direct cross realm with `SU.SE'
they need to use both `SU.SE' and `KTH.SE' as transit realms.

     [capaths]
     	SU.SE = {
                         STACKEN.KTH.SE = KTH.SE
     	}
     	DSV.SU.SE = {
                         STACKEN.KTH.SE = SU.SE KTH.SE
     	}


File: heimdal.info,  Node: Setting up DNS,  Prev: Transit policy,  Up: Setting up a realm

Setting up DNS
==============

If there is information about where to find the KDC or kadmind for a
realm in the `krb5.conf' for a realm, that information will be
preferred and DNS will not be queried.

Heimdal will try to use DNS to find the KDCs for a realm. First it will
try to find `SRV' resource record (RR) for the realm. If no SRV RRs are
found, it will fall back to looking for a `A' RR for a machine named
kerberos.REALM, and then kerberos-1.REALM, etc

Adding this information to DNS makes the client have less configuration
(in the common case, no configuration) and allows the system
administrator to change the number of KDCs and on what machines they
are running without caring about clients.

The backside of using DNS that the client might be fooled to use the
wrong server if someone fakes DNS replies/data, but storing the IP
addresses of the KDC on all the clients makes it very hard to change
the infrastructure.

Example of the configuration for the realm `EXAMPLE.COM',


     $ORIGIN example.com.
     _kerberos._tcp          SRV     10 1 88 kerberos.example.com.
     _kerberos._udp          SRV     10 1 88 kerberos.example.com.
     _kerberos._tcp          SRV     10 1 88 kerberos-1.example.com.
     _kerberos._udp          SRV     10 1 88 kerberos-1.example.com.
     _kpasswd._udp           SRV     10 1 464 kerberos.example.com.
     _kerberos-adm._tcp	SRV	10 1 749 kerberos.example.com.

More information about DNS SRV resource records can be found in
RFC-2782 (A DNS RR for specifying the location of services (DNS SRV)).
d1106 1
a1106 1
but then you will have to add entries for *all* your hosts in the
d1144 116
a1259 2
*And then there are a many more things you can do; more on this in a
later version of this manual. Until then, UTSL.*
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d1 2
a2 2
This is heimdal.info, produced by makeinfo version 4.0 from
heimdal.texi.
a20 1
* Applications::
d126 1
a126 1
<http://www.pdc.kth.se/heimdal/>.
d156 1
a156 1
     *Note* This discussion is about Kerberos version 4, but version 5
a180 1

d244 1
a244 1
<http://www.pdc.kth.se/kth-krb/>.
d327 2
a328 2
     Requires OpenLDAP <http://www.openldap.org>.  See
     <http://www.padl.com/Research/Heimdal.html> for more information.
d349 1
a349 1
File: heimdal.info,  Node: Setting up a realm,  Next: Applications,  Prev: Building and Installing,  Up: Top
a357 1
* Modifying the database::
a368 2
* Using LDAP to store the database::
* Providing Kerberos credentials to servers and programs::
d389 2
a390 2
assignments or subsections). A section starts with `[`section-name']'.
A binding consists of a left hand side, an equal (`=') and a right hand
d392 1
a392 1
whitespace). Subsections has a `{' as the first non-whitespace
d439 2
a440 2
`libdefaults', and `domain_realm', sections. If you have a DNS
SRV-record for your realm, or your Kerberos server has DNS CNAME
d444 1
a444 1
File: heimdal.info,  Node: Creating the database,  Next: Modifying the database,  Prev: Configuration file,  Up: Setting up a realm
d451 1
a451 1
sure the directory has restrictive permissions.
a464 7
If you want to generate a random master key you can use the -random-key
to kstash. This will make sure you have a good key on which attackers
can't do a dictionary attack.

If you have a master key, make sure you make a backup of your master
key file; without it backups of the database are of no use.

d472 1
a472 1
maximum ticket lifetimes.
d476 2
a477 2
principal. The principal should contain a realm, so if you haven't set
up a default realm, you will need to explicitly include the realm.
d514 1
a514 60
File: heimdal.info,  Node: Modifying the database,  Next: keytabs,  Prev: Creating the database,  Up: Setting up a realm

Modifying the database
======================

All modifications of principals are done with with kadmin.

A principal have several attributes and lifetimes associated with it.

Principals are added, renamed, modified, and deleted with the kadmin
commands `add', `rename', `modify', `delete'.  Both interactive editing
and command switches can be used (use -help to list the available
options).

There are different kind of types for the fields in the database,
attributes, absolute time times and relative times.

Attributes
----------

When doing interactive editing, attributes are listed with `?'.

The attributes are given in a comma (`,') separated list.  Attributes
are removed from the list by prefixing them with `-'.

     kadmin> modify me
     Max ticket life [1 day]:
     Max renewable life [1 week]:
     Principal expiration time [never]:
     Password expiration time [never]:
     Attributes [disallow-renewable]: requires-pre-auth,-disallow-renewable
     kadmin> get me
                 Principal: me@@MY.REALM
     [...]
                Attributes: requires-pre-auth

Absolute times
--------------

The format for absolute times are any of the following

     never
     now
     YYYY-mm-dd
     YYYY-mm-dd HH:MM:SS

Relative times
--------------

The format for relative times are any of the following combined

     N year
     M month
     O day
     P hour
     Q minute
     R second


File: heimdal.info,  Node: keytabs,  Next: Serving Kerberos 4/524/kaserver,  Prev: Modifying the database,  Up: Setting up a realm
d519 4
a522 4
To extract a service ticket from the database and put it in a keytab,
you need to first create the principal in the database with `ank'
(using the `--random-key' flag to get a random key) and then extract it
with `ext_keytab'.
a528 1
     kadmin> exit
d543 2
a544 2
these services turned off by default. Kerberos 4 support also depends
on if Kerberos 4 support being compiled in with Heimdal.
d561 1
a561 1
Kerberos 4 is the predecessor to to Kerberos 5. It only supports single
d573 3
a575 3
Kaserver is a Kerberos 4 that is used in AFS.  The protocol have some
extra features over plain Kerberos 4, but like Kerberos 4, only use
single DES.
d577 1
a577 1
You should only enable Kaserver support if you have a need for for
d598 1
a598 2
You might need to add `kerberos-adm' to your `/etc/services' as
`749/tcp'.
d600 3
a602 3
Access to the administration server is controlled by an ACL file,
(default `/var/heimdal/kadmind.acl'.) The lines in the access file,
have the following syntax:
d605 3
a607 3
The matching is from top to bottom for matching principals (and if
given, glob-pattern).  When there is a match, the access rights of that
line are used.
d614 4
a617 4
If a GLOB-PATTERN is given on a line, it restricts the access rights for
the principal to only apply for the subjects that match the pattern.
The patterns are of the same type as those used in shell globbing, see
<none,,fnmatch(3)>.
d640 1
a640 1
You might need to add `kpasswd' to your `/etc/services' as `464/udp'.
d646 4
a649 5
to guess them and to avoid off-line attacks (although
pre-authentication provides some defense against off-line attacks).  To
ensure that the users choose good passwords, you can enable password
quality controls in `kpasswdd' and `kadmind'.  The controls themselves
are done in a shared library or an external program that is used by
d654 2
a655 3
     	policies = external-check builtin:minimum-length module:policyname
     	external_program = /bin/false
     	policy_libraries = LIBRARY1.SO LIBRARY2.SO
d657 2
a658 2
In `[password_quality]policies' the module name is optional if the
policy name is unique in all modules (members of `policy_libraries').
d660 2
a661 1
The builtin polices are
d663 3
a665 39
   * external-check

     Executes the program specified by
     `[password_quality]external_program'.

     A number of key/value pairs is passed as input to the program, one
     per line, ending with the string `end'.  The key/value lines are of
     the form
          principal: PRINCIPAL
          new-password: PASSWORD
     where PASSWORD is the password to check for the previous PRINCIPAL.

     If the external application approves the password, it should return
     `APPROVED' on standard out and exit with exit code 0.  If it
     doesn't approve the password, a one line error message explaining
     the problem should be returned on standard error and the
     application should exit with exit code 0.  In case of a fatal
     error, the application should, if possible, print an error message
     on standard error and exit with a non-zero error code.

   * minimum-length

     The minimum length password quality check reads the configuration
     file stanza `[password_quality]min_length' and requires the
     password to be at least this length.

   * character-class

     The character-class password quality check reads the configuration
     file stanza `[password_quality]min_classes'. The policy requires
     the password to have characters from at least that many characters
     classes. Default value if not given is 3.

     The four diffrent characters classes are, uppercase, lowercase,
     number, special characters.


If you want to write you own shared object that checks password
policies, see the manual page `kadm5_pwcheck(3)'.
d671 1
a671 4
<ftp://ftp.pdc.kth.se/pub/krb/src/cracklib.patch>.

A sample policy external program is included in
`lib/kadm5/check-cracklib.pl'.
d674 1
a674 7
verified that it is at least six characters long.

The program `test_pw_quality', which is built in `lib/kadm5', but not
installed, can be used to check password policy settings.  It may be
convenient to set the environment variable `KRB5_CONFIG' to point to a
test version of `krb5.conf' while you're testing the
`[password_quality]' stanza that way.
d695 1
a695 1
All Kerberos servers for a realm must have the same database so that
d702 1
a702 1
Add the principal with the `ktutil' command and start `hpropd', as
d718 2
a719 2
This was just an hands-on example to make sure that everything was
working properly.  Doing it manually is of course the wrong way, and to
d731 1
a731 1
There is also a newer, and still somewhat experimental, mechanism for
d734 1
a734 1
the slaves.  The master keeps track of all the changes by assigning a
d737 3
a739 3
they are in sync or not.  A log of all the changes is kept on the
master, and when a slave is at an older version than the oldest one in
the log, the whole database has to be sent.
d741 1
a741 1
Protocol-wise, all the slaves connect to the master and as a greeting
d745 1
a745 2
the whole database in a `TELLYOUEVERYTHING' message.  There is also a
keep-alive protocol that makes sure all slaves are up and running.
d763 1
a763 1
Then you need to create those principals that you added in the
d770 1
a770 1
server.  The `ipropd-master' listens on the UNIX domain socket
d789 3
a791 3
(the salt) with the password, then sending it through an encryption
type specific string-to-key function that will output the fixed size
encryption key.
d797 1
a797 1
(using the cell (realm in AFS lingo)).
d812 1
a812 1
Common types of salting include
d816 3
a818 3
     The Kerberos 4 salting is using no salt at all. Reason there is
     colon at the end of the salt string is that it makes the salt the
     empty string (same as no salt).
d822 1
a822 3
     `pw-salt' uses the default salt for each encryption type is
     specified for. If the encryption type `etype' isn't given, all
     default encryption will be used.
d826 2
a827 3
     `afs3-salt' is the salt that is used with Transarc kaserver. Its
     the cell name appended to the password.

d835 12
a846 12
Suppose you reside in the realm `MY.REALM', how do you authenticate to
a server in `OTHER.REALM'? Having valid tickets in `MY.REALM' allows
you to communicate with Kerberised services in that realm. However, the
computer in the other realm does not have a secret key shared with the
Kerberos server in your realm.

It is possible to share keys between two realms that trust each other.
When a client program, such as `telnet' or `ssh', finds that the other
computer is in a different realm, it will try to get a ticket granting
ticket for that other realm, but from the local Kerberos server. With
that ticket granting ticket, it will then obtain service tickets from
the Kerberos server in the other realm.
d854 4
a857 4
In Kerberos 5 the trust can be configured to be one way. So that users
from `MY.REALM' can authenticate to services in `OTHER.REALM', but not
the opposite. In the example above, the `krbtgt/MY.REALM@@OTHER.REALM'
then should be removed.
d897 1
a897 1
realm, it must be explicitly allowed by either the KDCs or the server
d903 2
a904 2
ticket. The field is unordered, since there is no way to know if know
if one of the transited-realms changed the order of the list.
d914 1
a914 1
to cross it. Since `STACKEN.KTH.SE' only have direct cross realm with
a925 9
The order of the `PERMITTED-CROSS-REALMS' is not important when doing
transit cross realm verification.

However the order is important when the `[capaths]' section is used to
figure out the intermediate realm to go to when doing multi-realm
transit. When figuring out the next realm, the first realm of the list
of `PERMITTED-CROSS-REALMS' is chosen. This is done in both the client
kerberos library and the KDC.

d927 1
a927 1
File: heimdal.info,  Node: Setting up DNS,  Next: Using LDAP to store the database,  Prev: Transit policy,  Up: Setting up a realm
a931 3
Using DNS to find KDC
---------------------

d934 1
a934 1
preferred, and DNS will not be queried.
d937 3
a939 3
try to find a `SRV' resource record (RR) for the realm. If no SRV RRs
are found, it will fall back to looking for an `A' RR for a machine
named kerberos.REALM, and then kerberos-1.REALM, etc
d946 1
a946 1
The down side of using DNS that the client might be fooled to use the
d951 1
a951 1
An example of the configuration for the realm `EXAMPLE.COM',
d965 8
a972 2
Using DNS to map hostname to Kerberos realm
-------------------------------------------
d974 110
a1083 9
Heimdal also supports a way to lookup a realm from a hostname. This to
minimize configuration needed on clients. Using this has the drawback
that clients can be redirected by an attacker to realms within the same
cross realm trust and made to believe they are talking to the right
server (since Kerberos authentication will succeed).

An example configuration that informs clients that for the realms
it.example.com and srv.example.com, they should use the realm
EXAMPLE.COM:
d1085 5
d1091 5
a1095 3
     $ORIGIN example.com.
     _kerberos.it		TXT     "EXAMPLE.COM"
     _kerberos.srv		TXT     "EXAMPLE.COM"
d1098 1
a1098 1
File: heimdal.info,  Node: Using LDAP to store the database,  Next: Providing Kerberos credentials to servers and programs,  Prev: Setting up DNS,  Up: Setting up a realm
d1100 2
a1101 2
Using LDAP to store the database
================================
d1103 2
a1104 112
This document describes how to install the LDAP backend for Heimdal.
Note that before attempting to configure such an installation, you
should be aware of the implications of storing private information
(such as users' keys) in a directory service primarily designed for
public information. Nonetheless, with a suitable authorization policy,
it is possible to set this up in a secure fashion. A knowledge of LDAP,
Kerberos, and C is necessary to install this backend. The HDB schema
was devised by Leif Johansson.

Requirements:

   * A current release of Heimdal, configured with
     `--with-openldap=/usr/local' (adjust according to where you have
     installed OpenLDAP).

     You can verify that you manage to configure LDAP support by running
     `kdc --builtin-hdb', and checking that `ldap:' is one entry in the
     list.

     Its also possible to configure the ldap backend as a shared module,
     see option -hdb-openldap-module to configure.

   * OpenLDAP 2.0.x. Configure OpenLDAP with `--enable-local' to enable
     the local transport. (A patch to support SASL EXTERNAL
     authentication is necessary in order to use OpenLDAP 2.1.x.)

   * Add the hdb schema to the LDAP server, its included in the
     source-tree in `lib/hdb/hdb.schema'. Example from slapd.conf:

          include /usr/local/etc/openldap/schema/hdb.schema

   * Configure the LDAP server ACLs to accept writes from clients over
     the local transport. For example:

          access to *
                  by dn.exact="uid=heimdal,dc=services,dc=example,dc=com" write
                  ...
          
          sasl-regexp "uidNumber=0\\\+gidNumber=.*,cn=peercred,cn=external,cn=auth"
          	"uid=heimdal,dc=services,dc=example,dc=com"

     The sasl-regexp is for mapping between the SASL/EXTERNAL and a
     user in a tree.  The user that the key is mapped to should be have
     a krb5Principal aux object with krb5PrincipalName set so that the
     "creator" and "modifier" is right in `kadmin'.

     Another option is to create an admins group and add the dn to that
     group.

     Since Heimdal talkes to the LDAP server over a UNIX domain socket,
     and uses external sasl authentication, its not possible to require
     security layer quality (ssf in cyrus-sasl lingo). So that
     requirement has to be turned off in OpenLDAP `slapd' configuration
     file `slapd.conf'.

          sasl-secprops minssf=0

   *  Start `slapd' with the local listener (as well as the default
     TCP/IP listener on port 389) as follows:

              slapd -h "ldapi:/// ldap:///"

     Note: These is a bug in `slapd' where it appears to corrupt the
     krb5Key binary attribute on shutdown. This may be related to our
     use of the V3 schema definition syntax instead of the old
     UMich-style, V2 syntax.

   * You should specify the distinguished name under which your
     principals will be stored in `krb5.conf':

          [kdc]
                  database = {
                          dbname = ldap:ou=KerberosPrincipals,dc=example,dc=com
                          mkey_file = /path/to/mkey
                  }

     `mkey_file' can be excluded if you feel that you trust your ldap
     directory to have the raw keys inside it.

   * Once you have built Heimdal and started the LDAP server, run kadmin
     (as usual) to initialize the database. Note that the instructions
     for stashing a master key are as per any Heimdal installation.

          kdc# kadmin -l
          kadmin> init EXAMPLE.COM
          Realm max ticket life [unlimited]:
          Realm max renewable ticket life [unlimited]:
          kadmin> ank lukeh
          Max ticket life [1 day]:
          Max renewable life [1 week]:
          Principal expiration time [never]:
          Password expiration time [never]:
          Attributes []:
          lukeh@@EXAMPLE.COM's Password:
          Verifying password - lukeh@@EXAMPLE.COM's Password:
          kadmin> exit

     Verify that the principal database has indeed been stored in the
     directory with the following command:

          kdc# ldapsearch -L -h localhost -D cn=manager \
           -w secret -b ou=KerberosPrincipals,dc=example,dc=com \
           'objectclass=krb5KDCEntry'

   * Now consider adding indexes to the database to speed up the
     access, at least theses should be added to slapd.conf.

          index	objectClass		eq
          index	cn			eq,sub,pres
          index	uid			eq,sub,pres
          index	displayName		eq,sub,pres
          index	krb5PrincipalName	eq
d1106 2
d1109 1
a1109 2
Troubleshooting guide
---------------------
d1111 3
a1113 1
<https://sec.miljovern.no/bin/view/Info/TroubleshootingGuide>
d1115 2
a1116 2
Using Samba LDAP password database
----------------------------------
d1118 2
a1119 4
Samba domain and the Kerberos realm can have diffrent names since
arcfour's string to key function principal/realm independent.  So now
will be your first and only chance name your Kerberos without needing
to deal with old configuration files.
d1121 38
a1158 1
First you should set up Samba and get that working with LDAP backend.
d1160 3
a1162 3
Now you can proceed as in *Note Using LDAP to store the database::,
Heimdal will pick up the Samba LDAP entries if they are in the same
search space as the Kerberos entries.
d1165 1
a1165 1
File: heimdal.info,  Node: Providing Kerberos credentials to servers and programs,  Prev: Using LDAP to store the database,  Up: Setting up a realm
d1167 2
a1168 2
Providing Kerberos credentials to servers and programs
======================================================
d1170 2
a1171 2
Some service require Kerberos credentials when they start to make
connections to other services or use them when they have started.
d1173 43
a1215 7
The easiest way to get ticket for the a service is to store the key in
a keytab. Both ktutil get and kadmin ext can be used to get a keytab.
ktutil get is better in that way it changes the key/password for the
user. This the problem with the ktutil. It ktutil is used for the same
service principal on several hosts, they keytab will only useful on the
last host. In that case, run the command on host and copy the keytab
around to all other hosts that needs it.
d1217 1
a1217 3
     host# ktutil -k /etc/krb5-service.keytab \
           get -p lha/admin@@EXAMPLE.ORG service-principal@@EXAMPLE.ORG
     lha/admin@@EXAMPLE.ORG's Password:
d1219 15
a1233 3
To get a Kerberos credential file for the service, use kinit in the
-keytab mode, this will not ask for a password but rather that the key
from the keytab.
d1235 21
a1255 3
     service@@host$ kinit --cache=/var/run/service_krb5_cache \
                    --keytab=/etc/krb5-service.keytab \
            service-principal@@EXAMPLE.ORG
d1257 2
a1258 7
Long running services might need credentials longer then the expiration
time of the tickets. kinit can run in a mode that refreshes the tickets
before they expire. This is useful for services that write into AFS and
other distributed file systems using Kerberos. To run the long running
script, just append the program and arguments (if any) after the
principal. kinit will stop refreshing credentials and remove the
credentials when the script-to-start-service exits.
d1260 2
a1261 4
     service@@host$ kinit --cache=/var/run/service_krb5_cache \
            --keytab=/etc/krb5-service.keytab \
            service-principal@@EXAMPLE.ORG \
            script-to-start-service argument1 argument2
d1263 3
a1265 2

File: heimdal.info,  Node: Applications,  Next: Things in search for a better place,  Prev: Setting up a realm,  Up: Top
d1267 1
a1267 2
Applications
************
d1269 2
a1270 1
* Menu:
d1272 1
a1272 2
* Authentication modules::
* AFS::
d1274 2
a1275 5

File: heimdal.info,  Node: Authentication modules,  Next: AFS,  Prev: Applications,  Up: Applications

Authentication modules
======================
d1277 7
a1283 6
The problem of having different authentication mechanisms has been
recognised by several vendors, and several solutions has appeared. In
most cases these solutions involve some kind of shared modules that are
loaded at run-time.  Modules for some of these systems can be found in
`lib/auth'.  Presently there are modules for Digital's SIA, and IRIX'
`login' and `xdm' (in `lib/auth/afskauthlib').
d1285 2
a1286 1
* Menu:
d1288 2
a1289 2
* Digital SIA::
* IRIX::
@


