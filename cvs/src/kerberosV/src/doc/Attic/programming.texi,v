head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.4.0.28
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.26
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.24
	OPENBSD_5_0:1.1.1.4.0.22
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.20
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.18
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.14
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.12
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.10
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.8
	OPENBSD_3_7_BASE:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.2
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2014.04.22.10.01.21;	author reyk;	state dead;
branches;
next	1.2;

1.2
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.22.21.17.20;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.06.22.21.17.20;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.02.14.24;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.13.02.58.25;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.32.32;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.3
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@@@c $Id: programming.texi,v 1.2 2013/06/17 18:57:41 robert Exp $

@@node Programming with Kerberos, Migration, Windows compatibility, Top
@@chapter Programming with Kerberos

See the Kerberos 5 API introduction and documentation on the Heimdal
webpage.
@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d1 1
a1 1
@@c $Id$
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
@@c $KTH: programming.texi,v 1.2 2001/05/16 22:11:00 assar Exp $
d3 1
a3 1
@@node Programming with Kerberos
d6 2
a7 282
First you need to know how the Kerberos model works, go read the
introduction text (@@pxref{What is Kerberos?}).

@@macro manpage{man, section}
@@cite{\man\(\section\)}
@@end macro

@@menu
* Kerberos 5 API Overview::     
* Walkthru a sample Kerberos 5 client::  
* Validating a password in a server application::  
@@end menu

@@node Kerberos 5 API Overview, Walkthru a sample Kerberos 5 client, Programming with Kerberos, Programming with Kerberos
@@section Kerberos 5 API Overview

Most functions are documenteded in manual pages.  This overview only
tries to point to where to look for a specific function.

@@subsection Kerberos context

A kerberos context (@@code{krb5_context}) holds all per thread state. All global variables that
are context specific are stored in this struture, including default
encryption types, credential-cache (ticket file), and default realms.

See the manual pages for @@manpage{krb5_context,3} and
@@manpage{krb5_init_context,3}.

@@subsection Kerberos authenication context

Kerberos authentication context (@@code{krb5_auth_context}) holds all
context related to an authenticated connection, in a similar way to the
kerberos context that holds the context for the thread or process.

The @@code{krb5_auth_context} is used by various functions that are
directly related to authentication between the server/client. Example of
data that this structure contains are various flags, addresses of client
and server, port numbers, keyblocks (and subkeys), sequence numbers,
replay cache, and checksum types.

See the manual page for @@manpage{krb5_auth_context,3}.

@@subsection Keytab managment

A keytab is a storage for locally stored keys. Heimdal includes keytab
support for Kerberos 5 keytabs, Kerberos 4 srvtab, AFS-KeyFile's,
and for storing keys in memory.

See also manual page for @@manpage{krb5_keytab,3}

@@node Walkthru a sample Kerberos 5 client, Validating a password in a server application, Kerberos 5 API Overview, Programming with Kerberos
@@section Walkthru a sample Kerberos 5 client

This example contains parts of a sample TCP Kerberos 5 clients, if you
want a real working client, please look in @@file{appl/test} directory in
the Heimdal distribution.

All Kerberos error-codes that are returned from kerberos functions in
this program are passed to @@code{krb5_err}, that will print a
descriptive text of the error code and exit. Graphical programs can
convert error-code to a humal readable error-string with the
@@manpage{krb5_get_err_text,3} function.

Note that you should not use any Kerberos function before
@@code{krb5_init_context()} have completed successfully. That is the
reson @@code{err()} is used when @@code{krb5_init_context()} fails.

First the client needs to call @@code{krb5_init_context} to initialize
the Kerberos 5 library. This is only needed once per thread
in the program. If the function returns a non-zero value it indicates
that either the Kerberos implemtation is failing or its disabled on
this host.

@@example
#include <krb5.h>

int
main(int argc, char **argv)
@@{
        krb5_context context;

        if (krb5_context(&context))
                errx (1, "krb5_context");
@@end example

Now the client wants to connect to the host at the other end. The
preferred way of doing this is using @@manpage{getaddrinfo,3} (for
operating system that have this function implemented), since getaddrinfo
is neutral to the address type and can use any protocol that is available.

@@example
        struct addrinfo *ai, *a;
        struct addrinfo hints;
        int error;

        memset (&hints, 0, sizeof(hints));
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_protocol = IPPROTO_TCP;

        error = getaddrinfo (hostname, "pop3", &hints, &ai);
        if (error)
                errx (1, "%s: %s", hostname, gai_strerror(error));

        for (a = ai; a != NULL; a = a->ai_next) @@{
                int s;

                s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
                if (s < 0)
                        continue;
                if (connect (s, a->ai_addr, a->ai_addrlen) < 0) @@{
                        warn ("connect(%s)", hostname);
                            close (s);
                            continue;
                @@}
                freeaddrinfo (ai);
                ai = NULL;
        @@}
        if (ai) @@{
                    freeaddrinfo (ai);
                    errx ("failed to contact %s", hostname);
        @@}
@@end example

Before authenticating, an authentication context needs to be
created. This context keeps all information for one (to be) authenticated
connection (see @@manpage{krb5_auth_context,3}).

@@example
        status = krb5_auth_con_init (context, &auth_context);
        if (status)
                krb5_err (context, 1, status, "krb5_auth_con_init");
@@end example

For setting the address in the authentication there is a help function
@@code{krb5_auth_con_setaddrs_from_fd} that does everthing that is needed
when given a connected file descriptor to the socket.

@@example
        status = krb5_auth_con_setaddrs_from_fd (context,
                                                 auth_context,
                                                 &sock);
        if (status)
                krb5_err (context, 1, status, 
                          "krb5_auth_con_setaddrs_from_fd");
@@end example

The next step is to build a server principal for the service we want
to connect to. (See also @@manpage{krb5_sname_to_principal,3}.)

@@example
        status = krb5_sname_to_principal (context,
                                          hostname,
                                          service,
                                          KRB5_NT_SRV_HST,
                                          &server);
        if (status)
                krb5_err (context, 1, status, "krb5_sname_to_principal");
@@end example

The client principal is not passed to @@manpage{krb5_sendauth,3}
function, this causes the @@code{krb5_sendauth} function to try to figure it
out itself.

The server program is using the function @@manpage{krb5_recvauth,3} to
receive the Kerberos 5 authenticator.

In this case, mutual authenication will be tried. That means that the server
will authenticate to the client. Using mutual authenication
is good since it enables the user to verify that they are talking to the
right server (a server that knows the key).

If you are using a non-blocking socket you will need to do all work of
@@code{krb5_sendauth} yourself. Basically you need to send over the
authenticator from @@manpage{krb5_mk_req,3} and, in case of mutual
authentication, verifying the result from the server with
@@manpage{krb5_rd_rep,3}.

@@example
        status = krb5_sendauth (context,
                                &auth_context,
                                &sock,
                                VERSION,
                                NULL,
                                server,
                                AP_OPTS_MUTUAL_REQUIRED,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
        if (status)
                krb5_err (context, 1, status, "krb5_sendauth");
@@end example

Once authentication has been performed, it is time to send some
data. First we create a krb5_data structure, then we sign it with
@@manpage{krb5_mk_safe,3} using the @@code{auth_context} that contains the
session-key that was exchanged in the
@@manpage{krb5_sendauth,3}/@@manpage{krb5_recvauth,3} authentication
sequence.

@@example
        data.data   = "hej";
        data.length = 3;

        krb5_data_zero (&packet);

        status = krb5_mk_safe (context,
                               auth_context,
                               &data,
                               &packet,
                               NULL);
        if (status)
                krb5_err (context, 1, status, "krb5_mk_safe");
@@end example

And send it over the network.

@@example
        len = packet.length;
        net_len = htonl(len);

        if (krb5_net_write (context, &sock, &net_len, 4) != 4)
                err (1, "krb5_net_write");
        if (krb5_net_write (context, &sock, packet.data, len) != len)
                err (1, "krb5_net_write");
@@end example

To send encrypted (and signed) data @@manpage{krb5_mk_priv,3} should be
used instead. @@manpage{krb5_mk_priv,3} works the same way as
@@manpage{krb5_mk_safe,3}, with the exception that it encrypts the data
in addition to signing it.

@@example
        data.data   = "hemligt";
        data.length = 7;

        krb5_data_free (&packet);

        status = krb5_mk_priv (context,
                               auth_context,
                               &data,
                               &packet,
                               NULL);
        if (status)
                krb5_err (context, 1, status, "krb5_mk_priv");
@@end example

And send it over the network.

@@example
        len = packet.length;
        net_len = htonl(len);

        if (krb5_net_write (context, &sock, &net_len, 4) != 4)
                err (1, "krb5_net_write");
        if (krb5_net_write (context, &sock, packet.data, len) != len)
                err (1, "krb5_net_write");

@@end example

The server is using @@manpage{krb5_rd_safe,3} and
@@manpage{krb5_rd_priv,3} to verify the signature and decrypt the packet.

@@node Validating a password in a server application,  , Walkthru a sample Kerberos 5 client, Programming with Kerberos
@@section Validating a password in an application

See the manual page for @@manpage{krb5_verify_user,3}.

@@c @@node Why you should use GSS-API for new applications, Walkthru a sample GSS-API client, Validating a password in a server application, Programming with Kerberos
@@c @@section Why you should use GSS-API for new applications
@@c 
@@c SSPI, bah, bah, microsoft, bah, bah, almost GSS-API.
@@c 
@@c It would also be possible for other mechanisms then Kerberos, but that
@@c doesn't exist any other GSS-API implementations today.
@@c 
@@c @@node Walkthru a sample GSS-API client, , Why you should use GSS-API for new applications, Programming with Kerberos
@@c @@section Walkthru a sample GSS-API client
@@c 
@@c Write about how gssapi_clent.c works.
@


1.1.1.1
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes


@
text
@@


1.1.1.2
log
@Import of heimdal-0.6rc1
@
text
@d1 1
a1 1
@@c $Id$
d48 1
a48 1
@@subsection Keytab management
@


1.1.1.3
log
@Import of heimdal-0.6, released earlier today.
@
text
@d1 1
a1 1
@@c $KTH: programming.texi,v 1.2.8.1 2003/04/24 11:55:45 lha Exp $
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d1 1
a1 1
@@c $KTH: programming.texi,v 1.7 2005/06/07 00:50:09 lha Exp $
d9 4
a16 1
* API diffrences to MIT Kerberos::
a55 10
@@subsection Kerberos principal

See also manual page for @@manpage{krb5_principal,3}

@@subsection Kerberos crypto

See also manual page for @@manpage{krb5_crypto_init,3},
@@manpage{krb5_keyblock,3}, @@manpage{krb5_create_checksum,3}, 
and @@manpage{krb5_encrypt,3}.

d73 1
a73 1
First the client needs to call @@code{krb5_init_context} to initialise
d271 1
a271 1
@@node Validating a password in a server application, API diffrences to MIT Kerberos, Walkthru a sample Kerberos 5 client, Programming with Kerberos
a274 36

@@node API diffrences to MIT Kerberos, , Validating a password in a server application, Programming with Kerberos
@@section API diffrences to MIT Kerberos

This section is somewhat disorganised, but so far there is no overall
structure to the differences, though some of the have their root in
that Heimdal uses an ASN.1 compiler and MIT doesn't.

@@subsection Principal and realms

Heimdal stores the realm as a @@code{krb5_realm}, that is a @@code{char *}.
MIT Kerberos uses a @@code{krb5_data} to store a realm.

In Heimdal @@code{krb5_principal} doesn't contain the component
@@code{name_type}; it's instead stored in component
@@code{name.name_type}. To get and set the nametype in Heimdal, use
@@manpage{krb5_principal_get_type,3} and
@@manpage{krb5_principal_set_type,3}.

For more information about principal and realms, see
@@manpage{krb5_principal,3}.

@@subsection Error messages

To get the error string, Heimdal uses
@@manpage{krb5_get_error_string,3} or, if @@code{NULL} is returned,
@@manpage{krb5_get_err_text,3}. This is to return custom error messages
(like ``Can't find host/datan.example.com@@@@EXAMPLE.COM in
/etc/krb5.conf.'' instead of a ``Key table entry not found'' that
@@manpage{error_message,3} returns.

Heimdal uses a threadsafe(r) version of the com_err interface; the
global @@code{com_err} table isn't initialised.  Then
@@manpage{error_message,3} returns quite a boring error string (just
the error code itself).

@


