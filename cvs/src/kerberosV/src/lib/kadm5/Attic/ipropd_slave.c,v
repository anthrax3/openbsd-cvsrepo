head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.28
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.8;

1.8
date	2013.06.17.18.57.43;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.29.16.20.30;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.06.00.37.37;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.06.09.10.02;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.27.15.22.45;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.26;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.26;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.17;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.45;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.35;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.07;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.9
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2008 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "iprop.h"

RCSID("$Id: ipropd_slave.c,v 1.8 2013/06/17 18:57:43 robert Exp $");

static const char *config_name = "ipropd-slave";

static krb5_log_facility *log_facility;
static char five_min[] = "5 min";
static char *server_time_lost = five_min;
static int time_before_lost;
const char *slave_str = NULL;

static int
connect_to_master (krb5_context context, const char *master,
		   const char *port_str)
{
    char port[NI_MAXSERV];
    struct addrinfo *ai, *a;
    struct addrinfo hints;
    int error;
    int s = -1;

    memset (&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;

    if (port_str == NULL) {
	snprintf(port, sizeof(port), "%u", IPROP_PORT);
	port_str = port;
    }

    error = getaddrinfo (master, port_str, &hints, &ai);
    if (error) {
	krb5_warnx(context, "Failed to get address of to %s: %s",
		   master, gai_strerror(error));
	return -1;
    }

    for (a = ai; a != NULL; a = a->ai_next) {
	char node[NI_MAXHOST];
	error = getnameinfo(a->ai_addr, a->ai_addrlen,
			    node, sizeof(node), NULL, 0, NI_NUMERICHOST);
	if (error)
	    strlcpy(node, "[unknown-addr]", sizeof(node));

	s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
	if (s < 0)
	    continue;
	if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
	    krb5_warn(context, errno, "connection failed to %s[%s]",
		      master, node);
	    close (s);
	    continue;
	}
	krb5_warnx(context, "connection successful "
		   "to master: %s[%s]", master, node);
	break;
    }
    freeaddrinfo (ai);

    if (a == NULL)
	return -1;

    return s;
}

static void
get_creds(krb5_context context, const char *keytab_str,
	  krb5_ccache *cache, const char *serverhost)
{
    krb5_keytab keytab;
    krb5_principal client;
    krb5_error_code ret;
    krb5_get_init_creds_opt *init_opts;
    krb5_creds creds;
    char *server;
    char keytab_buf[256];

    if (keytab_str == NULL) {
	ret = krb5_kt_default_name (context, keytab_buf, sizeof(keytab_buf));
	if (ret)
	    krb5_err (context, 1, ret, "krb5_kt_default_name");
	keytab_str = keytab_buf;
    }

    ret = krb5_kt_resolve(context, keytab_str, &keytab);
    if(ret)
	krb5_err(context, 1, ret, "%s", keytab_str);


    ret = krb5_sname_to_principal (context, slave_str, IPROP_NAME,
				   KRB5_NT_SRV_HST, &client);
    if (ret) krb5_err(context, 1, ret, "krb5_sname_to_principal");

    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);
    if (ret) krb5_err(context, 1, ret, "krb5_get_init_creds_opt_alloc");

    asprintf (&server, "%s/%s", IPROP_NAME, serverhost);
    if (server == NULL)
	krb5_errx (context, 1, "malloc: no memory");

    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab,
				     0, server, init_opts);
    free (server);
    krb5_get_init_creds_opt_free(context, init_opts);
    if(ret) krb5_err(context, 1, ret, "krb5_get_init_creds");

    ret = krb5_kt_close(context, keytab);
    if(ret) krb5_err(context, 1, ret, "krb5_kt_close");

    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_new_unique");

    ret = krb5_cc_initialize(context, *cache, client);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_initialize");

    ret = krb5_cc_store_cred(context, *cache, &creds);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_store_cred");

    krb5_free_cred_contents(context, &creds);
    krb5_free_principal(context, client);
}

static krb5_error_code
ihave (krb5_context context, krb5_auth_context auth_context,
       int fd, uint32_t version)
{
    int ret;
    u_char buf[8];
    krb5_storage *sp;
    krb5_data data;

    sp = krb5_storage_from_mem (buf, 8);
    krb5_store_int32 (sp, I_HAVE);
    krb5_store_int32 (sp, version);
    krb5_storage_free (sp);
    data.length = 8;
    data.data   = buf;

    ret = krb5_write_priv_message(context, auth_context, &fd, &data);
    if (ret)
	krb5_warn (context, ret, "krb5_write_message");
    return ret;
}

static void
receive_loop (krb5_context context,
	      krb5_storage *sp,
	      kadm5_server_context *server_context)
{
    int ret;
    off_t left, right;
    void *buf;
    int32_t vers, vers2;
    ssize_t sret;

    /*
     * Seek to the current version of the local database.
     */
    do {
	int32_t len, timestamp, tmp;
	enum kadm_ops op;

	if(krb5_ret_int32 (sp, &vers) != 0)
	    return;
	krb5_ret_int32 (sp, &timestamp);
	krb5_ret_int32 (sp, &tmp);
	op = tmp;
	krb5_ret_int32 (sp, &len);
	if ((uint32_t)vers <= server_context->log_context.version)
	    krb5_storage_seek(sp, len + 8, SEEK_CUR);
    } while((uint32_t)vers <= server_context->log_context.version);

    /*
     * Read up rest of the entires into the memory...
     */
    left  = krb5_storage_seek (sp, -16, SEEK_CUR);
    right = krb5_storage_seek (sp, 0, SEEK_END);
    buf = malloc (right - left);
    if (buf == NULL && (right - left) != 0)
	krb5_errx (context, 1, "malloc: no memory");

    /*
     * ...and then write them out to the on-disk log.
     */
    krb5_storage_seek (sp, left, SEEK_SET);
    krb5_storage_read (sp, buf, right - left);
    sret = write (server_context->log_context.log_fd, buf, right-left);
    if (sret != right - left)
	krb5_err(context, 1, errno, "Failed to write log to disk");
    ret = fsync (server_context->log_context.log_fd);
    if (ret)
	krb5_err(context, 1, errno, "Failed to sync log to disk");
    free (buf);

    /*
     * Go back to the startpoint and start to commit the entires to
     * the database.
     */
    krb5_storage_seek (sp, left, SEEK_SET);

    for(;;) {
	int32_t len, len2, timestamp, tmp;
	off_t cur, cur2;
	enum kadm_ops op;

	if(krb5_ret_int32 (sp, &vers) != 0)
	    break;
	ret = krb5_ret_int32 (sp, &timestamp);
	if (ret) krb5_errx(context, 1, "entry %ld: too short", (long)vers);
	ret = krb5_ret_int32 (sp, &tmp);
	if (ret) krb5_errx(context, 1, "entry %ld: too short", (long)vers);
	op = tmp;
	ret = krb5_ret_int32 (sp, &len);
	if (ret) krb5_errx(context, 1, "entry %ld: too short", (long)vers);
	if (len < 0)
	    krb5_errx(context, 1, "log is corrupted, "
		      "negative length of entry version %ld: %ld",
		      (long)vers, (long)len);
	cur = krb5_storage_seek(sp, 0, SEEK_CUR);

	krb5_warnx (context, "replaying entry %d", (int)vers);

	ret = kadm5_log_replay (server_context,
				op, vers, len, sp);
	if (ret) {
	    const char *s = krb5_get_error_message(server_context->context, ret);
	    krb5_warnx (context,
			"kadm5_log_replay: %ld. Lost entry entry, "
			"Database out of sync ?: %s (%d)",
			(long)vers, s ? s : "unknown error", ret);
	    krb5_free_error_message(context, s);
	}

	{
	    /*
	     * Make sure the krb5_log_replay does the right thing wrt
	     * reading out data from the sp.
	     */
	    cur2 = krb5_storage_seek(sp, 0, SEEK_CUR);
	    if (cur + len != cur2)
		krb5_errx(context, 1,
			  "kadm5_log_reply version: %ld didn't read the whole entry",
			  (long)vers);
	}

	if (krb5_ret_int32 (sp, &len2) != 0)
	    krb5_errx(context, 1, "entry %ld: postamble too short", (long)vers);
	if(krb5_ret_int32 (sp, &vers2) != 0)
	    krb5_errx(context, 1, "entry %ld: postamble too short", (long)vers);

	if (len != len2)
	    krb5_errx(context, 1, "entry %ld: len != len2", (long)vers);
	if (vers != vers2)
	    krb5_errx(context, 1, "entry %ld: vers != vers2", (long)vers);
    }

    /*
     * Update version
     */

    server_context->log_context.version = vers;
}

static void
receive (krb5_context context,
	 krb5_storage *sp,
	 kadm5_server_context *server_context)
{
    int ret;

    ret = server_context->db->hdb_open(context,
				       server_context->db,
				       O_RDWR | O_CREAT, 0600);
    if (ret)
	krb5_err (context, 1, ret, "db->open");

    receive_loop (context, sp, server_context);

    ret = server_context->db->hdb_close (context, server_context->db);
    if (ret)
	krb5_err (context, 1, ret, "db->close");
}

static void
send_im_here (krb5_context context, int fd,
	      krb5_auth_context auth_context)
{
    krb5_storage *sp;
    krb5_data data;
    int ret;

    ret = krb5_data_alloc (&data, 4);
    if (ret)
	krb5_err (context, 1, ret, "send_im_here");

    sp = krb5_storage_from_data (&data);
    if (sp == NULL)
	krb5_errx (context, 1, "krb5_storage_from_data");
    krb5_store_int32(sp, I_AM_HERE);
    krb5_storage_free(sp);

    ret = krb5_write_priv_message(context, auth_context, &fd, &data);
    krb5_data_free(&data);

    if (ret)
	krb5_err (context, 1, ret, "krb5_write_priv_message");
}

static krb5_error_code
receive_everything (krb5_context context, int fd,
		    kadm5_server_context *server_context,
		    krb5_auth_context auth_context)
{
    int ret;
    krb5_data data;
    int32_t vno = 0;
    int32_t opcode;
    krb5_storage *sp;

    char *dbname;
    HDB *mydb;

    krb5_warnx(context, "receive complete database");

    asprintf(&dbname, "%s-NEW", server_context->db->hdb_name);
    ret = hdb_create(context, &mydb, dbname);
    if(ret)
	krb5_err(context,1, ret, "hdb_create");
    free(dbname);

    ret = hdb_set_master_keyfile (context,
				  mydb, server_context->config.stash_file);
    if(ret)
	krb5_err(context,1, ret, "hdb_set_master_keyfile");

    /* I really want to use O_EXCL here, but given that I can't easily clean
       up on error, I won't */
    ret = mydb->hdb_open(context, mydb, O_RDWR | O_CREAT | O_TRUNC, 0600);
    if (ret)
	krb5_err (context, 1, ret, "db->open");

    sp = NULL;
    do {
	ret = krb5_read_priv_message(context, auth_context, &fd, &data);

	if (ret) {
	    krb5_warn (context, ret, "krb5_read_priv_message");
	    goto cleanup;
	}

	sp = krb5_storage_from_data (&data);
	if (sp == NULL)
	    krb5_errx (context, 1, "krb5_storage_from_data");
	krb5_ret_int32 (sp, &opcode);
	if (opcode == ONE_PRINC) {
	    krb5_data fake_data;
	    hdb_entry_ex entry;

	    krb5_storage_free(sp);

	    fake_data.data   = (char *)data.data + 4;
	    fake_data.length = data.length - 4;

	    memset(&entry, 0, sizeof(entry));

	    ret = hdb_value2entry (context, &fake_data, &entry.entry);
	    if (ret)
		krb5_err (context, 1, ret, "hdb_value2entry");
	    ret = mydb->hdb_store(server_context->context,
				  mydb,
				  0, &entry);
	    if (ret)
		krb5_err (context, 1, ret, "hdb_store");

	    hdb_free_entry (context, &entry);
	    krb5_data_free (&data);
	} else if (opcode == NOW_YOU_HAVE)
	    ;
	else
	    krb5_errx (context, 1, "strange opcode %d", opcode);
    } while (opcode == ONE_PRINC);

    if (opcode != NOW_YOU_HAVE)
	krb5_errx (context, 1, "receive_everything: strange %d", opcode);

    krb5_ret_int32 (sp, &vno);
    krb5_storage_free(sp);

    ret = kadm5_log_reinit (server_context);
    if (ret)
	krb5_err(context, 1, ret, "kadm5_log_reinit");

    ret = kadm5_log_set_version (server_context, vno - 1);
    if (ret)
	krb5_err (context, 1, ret, "kadm5_log_set_version");

    ret = kadm5_log_nop (server_context);
    if (ret)
	krb5_err (context, 1, ret, "kadm5_log_nop");

    ret = mydb->hdb_rename (context, mydb, server_context->db->hdb_name);
    if (ret)
	krb5_err (context, 1, ret, "db->rename");

 cleanup:
    krb5_data_free (&data);

    ret = mydb->hdb_close (context, mydb);
    if (ret)
	krb5_err (context, 1, ret, "db->close");

    ret = mydb->hdb_destroy (context, mydb);
    if (ret)
	krb5_err (context, 1, ret, "db->destroy");

    krb5_warnx(context, "receive complete database, version %ld", (long)vno);
    return ret;
}

static char *config_file;
static char *realm;
static int version_flag;
static int help_flag;
static char *keytab_str;
static char *port_str;
#ifdef SUPPORT_DETACH
static int detach_from_console = 0;
#endif

static struct getargs args[] = {
    { "config-file", 'c', arg_string, &config_file, NULL, NULL },
    { "realm", 'r', arg_string, &realm, NULL, NULL },
    { "keytab", 'k', arg_string, &keytab_str,
      "keytab to get authentication from", "kspec" },
    { "time-lost", 0, arg_string, &server_time_lost,
      "time before server is considered lost", "time" },
    { "port", 0, arg_string, &port_str,
      "port ipropd-slave will connect to", "port"},
#ifdef SUPPORT_DETACH
    { "detach", 0, arg_flag, &detach_from_console,
      "detach from console", NULL },
#endif
    { "hostname", 0, arg_string, rk_UNCONST(&slave_str),
      "hostname of slave (if not same as hostname)", "hostname" },
    { "version", 0, arg_flag, &version_flag, NULL, NULL },
    { "help", 0, arg_flag, &help_flag, NULL, NULL }
};

static int num_args = sizeof(args) / sizeof(args[0]);

static void
usage(int status)
{
    arg_printusage(args, num_args, NULL, "master");
    exit(status);
}

int
main(int argc, char **argv)
{
    krb5_error_code ret;
    krb5_context context;
    krb5_auth_context auth_context;
    void *kadm_handle;
    kadm5_server_context *server_context;
    kadm5_config_params conf;
    int master_fd;
    krb5_ccache ccache;
    krb5_principal server;
    char **files;
    int optidx = 0;
    time_t reconnect_min;
    time_t backoff;
    time_t reconnect_max;
    time_t reconnect;
    time_t before = 0;

    const char *master;

    setprogname(argv[0]);

    if(getarg(args, num_args, argc, argv, &optidx))
	usage(1);

    if(help_flag)
	usage(0);
    if(version_flag) {
	print_version(NULL);
	exit(0);
    }

    ret = krb5_init_context(&context);
    if (ret)
	errx (1, "krb5_init_context failed: %d", ret);

    setup_signal();

    if (config_file == NULL) {
	if (asprintf(&config_file, "%s/kdc.conf", hdb_db_dir(context)) == -1
	    || config_file == NULL)
	    errx(1, "out of memory");
    }

    ret = krb5_prepend_config_files_default(config_file, &files);
    if (ret)
	krb5_err(context, 1, ret, "getting configuration files");

    ret = krb5_set_config_files(context, files);
    krb5_free_config_files(files);
    if (ret)
	krb5_err(context, 1, ret, "reading configuration files");

    argc -= optidx;
    argv += optidx;

    if (argc != 1)
	usage(1);

    master = argv[0];

#ifdef SUPPORT_DETACH
    if (detach_from_console)
	daemon(0, 0);
#endif
    pidfile (NULL);
    krb5_openlog (context, "ipropd-slave", &log_facility);
    krb5_set_warn_dest(context, log_facility);

    ret = krb5_kt_register(context, &hdb_kt_ops);
    if(ret)
	krb5_err(context, 1, ret, "krb5_kt_register");

    time_before_lost = parse_time (server_time_lost,  "s");
    if (time_before_lost < 0)
	krb5_errx (context, 1, "couldn't parse time: %s", server_time_lost);

    memset(&conf, 0, sizeof(conf));
    if(realm) {
	conf.mask |= KADM5_CONFIG_REALM;
	conf.realm = realm;
    }
    ret = kadm5_init_with_password_ctx (context,
					KADM5_ADMIN_SERVICE,
					NULL,
					KADM5_ADMIN_SERVICE,
					&conf, 0, 0,
					&kadm_handle);
    if (ret)
	krb5_err (context, 1, ret, "kadm5_init_with_password_ctx");

    server_context = (kadm5_server_context *)kadm_handle;

    ret = kadm5_log_init (server_context);
    if (ret)
	krb5_err (context, 1, ret, "kadm5_log_init");

    get_creds(context, keytab_str, &ccache, master);

    ret = krb5_sname_to_principal (context, master, IPROP_NAME,
				   KRB5_NT_SRV_HST, &server);
    if (ret)
	krb5_err (context, 1, ret, "krb5_sname_to_principal");

    auth_context = NULL;
    master_fd = -1;

    krb5_appdefault_time(context, config_name, NULL, "reconnect-min",
			 10, &reconnect_min);
    krb5_appdefault_time(context, config_name, NULL, "reconnect-max",
			 300, &reconnect_max);
    krb5_appdefault_time(context, config_name, NULL, "reconnect-backoff",
			 10, &backoff);
    reconnect = reconnect_min;

    while (!exit_flag) {
	time_t now, elapsed;
	int connected = FALSE;

	now = time(NULL);
	elapsed = now - before;

	if (elapsed < reconnect) {
	    time_t left = reconnect - elapsed;
	    krb5_warnx(context, "sleeping %d seconds before "
		       "retrying to connect", (int)left);
	    sleep(left);
	}
	before = now;

	master_fd = connect_to_master (context, master, port_str);
	if (master_fd < 0)
	    goto retry;

	reconnect = reconnect_min;

	if (auth_context) {
	    krb5_auth_con_free(context, auth_context);
	    auth_context = NULL;
	    krb5_cc_destroy(context, ccache);
	    get_creds(context, keytab_str, &ccache, master);
	}
	ret = krb5_sendauth (context, &auth_context, &master_fd,
			     IPROP_VERSION, NULL, server,
			     AP_OPTS_MUTUAL_REQUIRED, NULL, NULL,
			     ccache, NULL, NULL, NULL);
	if (ret) {
	    krb5_warn (context, ret, "krb5_sendauth");
	    goto retry;
	}

	krb5_warnx(context, "ipropd-slave started at version: %ld",
		   (long)server_context->log_context.version);

	ret = ihave (context, auth_context, master_fd,
		     server_context->log_context.version);
	if (ret)
	    goto retry;

	connected = TRUE;

	while (connected && !exit_flag) {
	    krb5_data out;
	    krb5_storage *sp;
	    int32_t tmp;
	    fd_set readset;
	    struct timeval to;

#ifndef NO_LIMIT_FD_SETSIZE
	    if (master_fd >= FD_SETSIZE)
		krb5_errx (context, 1, "fd too large");
#endif

	    FD_ZERO(&readset);
	    FD_SET(master_fd, &readset);

	    to.tv_sec = time_before_lost;
	    to.tv_usec = 0;

	    ret = select (master_fd + 1,
			  &readset, NULL, NULL, &to);
	    if (ret < 0) {
		if (errno == EINTR)
		    continue;
		else
		    krb5_err (context, 1, errno, "select");
	    }
	    if (ret == 0)
		krb5_errx (context, 1, "server didn't send a message "
			   "in %d seconds", time_before_lost);

	    ret = krb5_read_priv_message(context, auth_context, &master_fd, &out);
	    if (ret) {
		krb5_warn (context, ret, "krb5_read_priv_message");
		connected = FALSE;
		continue;
	    }

	    sp = krb5_storage_from_mem (out.data, out.length);
	    krb5_ret_int32 (sp, &tmp);
	    switch (tmp) {
	    case FOR_YOU :
		receive (context, sp, server_context);
		ret = ihave (context, auth_context, master_fd,
			     server_context->log_context.version);
		if (ret)
		    connected = FALSE;
		break;
	    case TELL_YOU_EVERYTHING :
		ret = receive_everything (context, master_fd, server_context,
					  auth_context);
		if (ret)
		    connected = FALSE;
		break;
	    case ARE_YOU_THERE :
		send_im_here (context, master_fd, auth_context);
		break;
	    case NOW_YOU_HAVE :
	    case I_HAVE :
	    case ONE_PRINC :
	    case I_AM_HERE :
	    default :
		krb5_warnx (context, "Ignoring command %d", tmp);
		break;
	    }
	    krb5_storage_free (sp);
	    krb5_data_free (&out);

	}
    retry:
	if (connected == FALSE)
	    krb5_warnx (context, "disconnected for server");
	if (exit_flag)
	    krb5_warnx (context, "got an exit signal");

	if (master_fd >= 0)
	    close(master_fd);

	reconnect += backoff;
	if (reconnect > reconnect_max)
	    reconnect = reconnect_max;
    }

    if (0);
#ifndef NO_SIGXCPU
    else if(exit_flag == SIGXCPU)
	krb5_warnx(context, "%s CPU time limit exceeded", getprogname());
#endif
    else if(exit_flag == SIGINT || exit_flag == SIGTERM)
	krb5_warnx(context, "%s terminated", getprogname());
    else
	krb5_warnx(context, "%s unexpected exit reason: %ld",
		       getprogname(), (long)exit_flag);

    return 0;
}
@


1.8
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d36 1
a36 1
RCSID("$Id$");
@


1.7
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a34 1
#include <util.h>
d36 3
a38 1
RCSID("$KTH: ipropd_slave.c,v 1.39 2005/05/23 17:39:35 lha Exp $");
d41 2
a42 1
static char *server_time_lost = "5 min";
d44 1
d50 36
a85 21
    int fd;
    struct sockaddr_in addr;
    struct hostent *he;

    fd = socket (AF_INET, SOCK_STREAM, 0);
    if (fd < 0)
	krb5_err (context, 1, errno, "socket AF_INET");
    memset (&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    if (port_str) {
	addr.sin_port = krb5_getportbyname (context,
					    port_str, "tcp", 
					    0);
	if (addr.sin_port == 0) {
	    char *ptr;
	    long port;
	    
	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		krb5_errx (context, 1, "bad port `%s'", port_str);
	    addr.sin_port = htons(port);
d87 3
a89 3
    } else {
	addr.sin_port = krb5_getportbyname (context, IPROP_SERVICE, 
					    "tcp", IPROP_PORT);
d91 6
a96 7
    he = roken_gethostbyname (master);
    if (he == NULL)
	krb5_errx (context, 1, "gethostbyname: %s", hstrerror(h_errno));
    memcpy (&addr.sin_addr, he->h_addr, sizeof(addr.sin_addr));
    if(connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	krb5_err (context, 1, errno, "connect");
    return fd;
d101 1
a101 1
	  krb5_ccache *cache, const char *host)
d110 1
a110 1
    
d121 3
a123 2
    
    ret = krb5_sname_to_principal (context, NULL, IPROP_NAME,
d130 1
a130 1
    asprintf (&server, "%s/%s", IPROP_NAME, host);
d137 1
a137 1
    krb5_get_init_creds_opt_free(init_opts);
d139 1
a139 1
    
d142 3
a144 3
    
    ret = krb5_cc_gen_new(context, &krb5_mcc_ops, cache);
    if(ret) krb5_err(context, 1, ret, "krb5_cc_gen_new");
d151 3
d156 1
a156 1
static void
d158 1
a158 1
       int fd, u_int32_t version)
d171 1
a171 1
    
d174 2
a175 1
	krb5_err (context, 1, ret, "krb5_write_priv_message");
d186 2
a187 1
    int32_t vers;
d189 3
d202 1
a202 1
	if (vers <= server_context->log_context.version)
d204 1
a204 1
    } while(vers <= server_context->log_context.version);
d206 3
d212 6
a217 4
    if (buf == NULL && (right - left) != 0) {
	krb5_warnx (context, "malloc: no memory");
	return;
    }
d220 6
a225 2
    write (server_context->log_context.log_fd, buf, right-left);
    fsync (server_context->log_context.log_fd);
d228 4
d235 2
a236 1
	int32_t len, timestamp, tmp;
d241 4
a244 2
	krb5_ret_int32 (sp, &timestamp);
	krb5_ret_int32 (sp, &tmp);
d246 9
a254 1
	krb5_ret_int32 (sp, &len);
d258 30
a287 5
	if (ret)
	    krb5_warn (context, ret, "kadm5_log_replay: %d", (int)vers);
	else
	    server_context->log_context.version = vers;
	krb5_storage_seek (sp, 8, SEEK_CUR);
d289 6
d342 1
a342 1
static void
d349 1
a349 1
    int32_t vno;
d355 3
a357 1
  
d363 1
a363 1
 
d368 1
a368 1
 
a371 1

d379 4
a382 2
	if (ret)
	    krb5_err (context, 1, ret, "krb5_read_priv_message");
d390 1
a390 1
	    hdb_entry entry;
d397 3
a399 1
	    ret = hdb_value2entry (context, &fake_data, &entry);
a433 2
    krb5_data_free (&data);

d438 3
d448 3
d459 1
d461 1
d464 2
a465 2
    { "config-file", 'c', arg_string, &config_file },
    { "realm", 'r', arg_string, &realm },
d472 8
a479 4
    { "detach", 0, arg_flag, &detach_from_console, 
      "detach from console" },
    { "version", 0, arg_flag, &version_flag },
    { "help", 0, arg_flag, &help_flag }
d485 1
a485 1
usage (int code, struct getargs *args, int num_args)
d487 2
a488 2
    arg_printusage (args, num_args, NULL, "master");
    exit (code);
d504 6
a510 1
    int optind;
d512 6
a517 3
    
    optind = krb5_program_setup(&context, argc, argv, args, num_args, usage);
    
d519 1
a519 1
	usage (0, args, num_args);
d525 11
a535 2
    if (config_file == NULL)
	config_file = HDB_DB_DIR "/kdc.conf";
d546 2
a547 2
    argc -= optind;
    argv += optind;
d550 1
a550 1
	usage (1, args, num_args);
d554 1
d557 1
d579 1
a579 1
					&conf, 0, 0, 
a591 2
    master_fd = connect_to_master (context, master, port_str);

d598 44
a641 34
    ret = krb5_sendauth (context, &auth_context, &master_fd,
			 IPROP_VERSION, NULL, server,
			 AP_OPTS_MUTUAL_REQUIRED, NULL, NULL,
			 ccache, NULL, NULL, NULL);
    if (ret)
	krb5_err (context, 1, ret, "krb5_sendauth");

    ihave (context, auth_context, master_fd,
	   server_context->log_context.version);

    for (;;) {
	int ret;
	krb5_data out;
	krb5_storage *sp;
	int32_t tmp;
	fd_set readset;
	struct timeval to;

	if (master_fd >= FD_SETSIZE)
	    krb5_errx (context, 1, "fd too large");

	FD_ZERO(&readset);
	FD_SET(master_fd, &readset);

	to.tv_sec = time_before_lost;
	to.tv_usec = 0;

	ret = select (master_fd + 1,
		      &readset, NULL, NULL, &to);
	if (ret < 0) {
	    if (errno == EINTR)
		continue;
	    else
		krb5_err (context, 1, errno, "select");
a642 3
	if (ret == 0)
	    krb5_errx (context, 1, "server didn't send a message "
		       "in %d seconds", time_before_lost);
d644 2
a645 1
	ret = krb5_read_priv_message(context, auth_context, &master_fd, &out);
d647 2
d650 70
a719 1
	    krb5_err (context, 1, ret, "krb5_read_priv_message");
a720 22
	sp = krb5_storage_from_mem (out.data, out.length);
	krb5_ret_int32 (sp, &tmp);
	switch (tmp) {
	case FOR_YOU :
	    receive (context, sp, server_context);
	    ihave (context, auth_context, master_fd,
		   server_context->log_context.version);
	    break;
	case TELL_YOU_EVERYTHING :
	    receive_everything (context, master_fd, server_context,
				auth_context);
	    break;
	case ARE_YOU_THERE :
	    send_im_here (context, master_fd, auth_context);
	    break;
	case NOW_YOU_HAVE :
	case I_HAVE :
	case ONE_PRINC :
	case I_AM_HERE :
	default :
	    krb5_warnx (context, "Ignoring command %d", tmp);
	    break;
d722 12
a733 2
	krb5_storage_free (sp);
	krb5_data_free (&out);
d735 12
a746 1
    
@


1.6
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: ipropd_slave.c,v 1.27.2.1 2003/08/15 16:45:15 lha Exp $");
d40 2
d44 2
a45 1
connect_to_master (krb5_context context, const char *master)
d56 17
a72 2
    addr.sin_port   = krb5_getportbyname (context,
					  IPROP_SERVICE, "tcp", IPROP_PORT);
d89 1
a89 1
    krb5_get_init_creds_opt init_opts;
d109 2
a110 1
    krb5_get_init_creds_opt_init(&init_opts);
d117 1
a117 1
				     0, server, &init_opts);
d119 1
d142 1
a142 1
    krb5_data data, priv_data;
d151 1
a151 5
    ret = krb5_mk_priv (context, auth_context, &data, &priv_data, NULL);
    if (ret)
	krb5_err (context, 1, ret, "krb_mk_priv");

    ret = krb5_write_message (context, &fd, &priv_data);
d153 1
a153 3
	krb5_err (context, 1, ret, "krb5_write_message");

    krb5_data_free (&priv_data);
d177 1
a177 1
	    krb5_storage_seek(sp, len, SEEK_CUR);
d209 1
a209 1
	    krb5_warn (context, ret, "kadm5_log_replay");
d223 3
a225 3
    ret = server_context->db->open(context,
				   server_context->db,
				   O_RDWR | O_CREAT, 0600);
d231 1
a231 1
    ret = server_context->db->close (context, server_context->db);
d237 25
d270 1
a270 1
    unsigned long tmp;
d275 1
a275 1
    asprintf(&dbname, "%s-NEW", server_context->db->name);
d288 1
a288 1
    ret = mydb->open(context, mydb, O_RDWR | O_CREAT | O_TRUNC, 0600);
d293 1
a294 2
	krb5_storage *sp;

d301 2
d308 2
d316 3
a318 3
	    ret = mydb->store(server_context->context,
			      mydb,
			      0, &entry);
d324 4
a327 1
	}
d333 2
a334 2
    _krb5_get_int ((char *)data.data + 4, &tmp, 4);
    vno = tmp;
d350 1
a350 1
    ret = mydb->rename (context, mydb, server_context->db->name);
d354 1
a354 1
    ret = mydb->close (context, mydb);
d358 1
a358 1
    ret = mydb->destroy (context, mydb);
d363 1
d368 2
d372 1
d376 6
d407 1
d421 12
d441 2
d451 4
d477 1
a477 1
    master_fd = connect_to_master (context, master);
d500 23
d541 3
d547 1
@


1.5
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: ipropd_slave.c,v 1.27 2002/10/21 15:51:44 joda Exp $");
d305 4
d312 1
a312 3
    ret = mydb->rename (context, mydb, server_context->db->name);
    if (ret)
	krb5_err (context, 1, ret, "db->rename");
@


1.4
log
@-Wall -Werror sweep on i386.
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: ipropd_slave.c,v 1.24 2001/08/31 03:12:17 assar Exp $");
d163 1
a163 1
	    sp->seek(sp, len, SEEK_CUR);
d166 2
a167 2
    left  = sp->seek (sp, -16, SEEK_CUR);
    right = sp->seek (sp, 0, SEEK_END);
d173 2
a174 2
    sp->seek (sp, left, SEEK_SET);
    sp->fetch (sp, buf, right - left);
d179 1
a179 1
    sp->seek (sp, left, SEEK_SET);
d198 1
a198 1
	sp->seek (sp, 8, SEEK_CUR);
d231 19
a250 3
    ret = server_context->db->open(context,
				   server_context->db,
				   O_RDWR | O_CREAT | O_TRUNC, 0600);
d274 3
a276 3
	    ret = server_context->db->store(server_context->context,
					    server_context->db,
					    0, &entry);
d288 2
a289 1
    _krb5_get_int ((char *)data.data + 4, (void *)&vno, 4);
d305 1
a305 1
    ret = server_context->db->close (context, server_context->db);
d308 6
@


1.3
log
@Merge heimdal-0.4e
@
text
@d35 1
@


1.2
log
@-Wall
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: ipropd_slave.c,v 1.21 2000/08/06 02:06:19 assar Exp $");
a74 4
    ret = krb5_kt_register(context, &hdb_kt_ops);
    if(ret)
	krb5_err(context, 1, ret, "krb5_kt_register");

d347 2
a348 1
    krb5_openlog (context, "ipropd-master", &log_facility);
d430 1
a430 1
    }
@


1.1
log
@Initial revision
@
text
@d275 1
a275 1
    _krb5_get_int ((char *)data.data + 4, &vno, 4);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: ipropd_slave.c,v 1.24 2001/08/31 03:12:17 assar Exp $");
d75 4
d351 1
a351 2
    pidfile (NULL);
    krb5_openlog (context, "ipropd-slave", &log_facility);
d433 1
a433 1
}
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: ipropd_slave.c,v 1.27 2002/10/21 15:51:44 joda Exp $");
d162 1
a162 1
	    krb5_storage_seek(sp, len, SEEK_CUR);
d165 2
a166 2
    left  = krb5_storage_seek (sp, -16, SEEK_CUR);
    right = krb5_storage_seek (sp, 0, SEEK_END);
d172 2
a173 2
    krb5_storage_seek (sp, left, SEEK_SET);
    krb5_storage_read (sp, buf, right - left);
d178 1
a178 1
    krb5_storage_seek (sp, left, SEEK_SET);
d197 1
a197 1
	krb5_storage_seek (sp, 8, SEEK_CUR);
a229 19
    unsigned long tmp;

    char *dbname;
    HDB *mydb;
  
    asprintf(&dbname, "%s-NEW", server_context->db->name);
    ret = hdb_create(context, &mydb, dbname);
    if(ret)
	krb5_err(context,1, ret, "hdb_create");
    free(dbname);
 
    ret = hdb_set_master_keyfile (context,
				  mydb, server_context->config.stash_file);
    if(ret)
	krb5_err(context,1, ret, "hdb_set_master_keyfile");
 
    /* I really want to use O_EXCL here, but given that I can't easily clean
       up on error, I won't */
    ret = mydb->open(context, mydb, O_RDWR | O_CREAT | O_TRUNC, 0600);
d231 3
d257 3
a259 3
	    ret = mydb->store(server_context->context,
			      mydb,
			      0, &entry);
d271 1
a271 2
    _krb5_get_int ((char *)data.data + 4, &tmp, 4);
    vno = tmp;
d287 1
a287 1
    ret = mydb->close (context, mydb);
a289 6
    ret = mydb->rename (context, mydb, server_context->db->name);
    if (ret)
	krb5_err (context, 1, ret, "db->rename");
    ret = mydb->destroy (context, mydb);
    if (ret)
	krb5_err (context, 1, ret, "db->destroy");
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: ipropd_slave.c,v 1.27.2.1 2003/08/15 16:45:15 lha Exp $");
d304 3
a309 5

    ret = mydb->close (context, mydb);
    if (ret)
	krb5_err (context, 1, ret, "db->close");

@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: ipropd_slave.c,v 1.39 2005/05/23 17:39:35 lha Exp $");
a38 2
static char *server_time_lost = "5 min";
static int time_before_lost;
d41 1
a41 2
connect_to_master (krb5_context context, const char *master,
		   const char *port_str)
d52 2
a53 17
    if (port_str) {
	addr.sin_port = krb5_getportbyname (context,
					    port_str, "tcp", 
					    0);
	if (addr.sin_port == 0) {
	    char *ptr;
	    long port;
	    
	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		krb5_errx (context, 1, "bad port `%s'", port_str);
	    addr.sin_port = htons(port);
	}
    } else {
	addr.sin_port = krb5_getportbyname (context, IPROP_SERVICE, 
					    "tcp", IPROP_PORT);
    }
d70 1
a70 1
    krb5_get_init_creds_opt *init_opts;
d90 1
a90 2
    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);
    if (ret) krb5_err(context, 1, ret, "krb5_get_init_creds_opt_alloc");
d97 1
a97 1
				     0, server, init_opts);
a98 1
    krb5_get_init_creds_opt_free(init_opts);
d121 1
a121 1
    krb5_data data;
d130 5
a134 1
    ret = krb5_write_priv_message(context, auth_context, &fd, &data);
d136 3
a138 1
	krb5_err (context, 1, ret, "krb5_write_priv_message");
d162 1
a162 1
	    krb5_storage_seek(sp, len + 8, SEEK_CUR);
d194 1
a194 1
	    krb5_warn (context, ret, "kadm5_log_replay: %d", (int)vers);
d208 3
a210 3
    ret = server_context->db->hdb_open(context,
				       server_context->db,
				       O_RDWR | O_CREAT, 0600);
d216 1
a216 1
    ret = server_context->db->hdb_close (context, server_context->db);
a221 25
send_im_here (krb5_context context, int fd,
	      krb5_auth_context auth_context)
{
    krb5_storage *sp;
    krb5_data data;
    int ret;

    ret = krb5_data_alloc (&data, 4);
    if (ret)
	krb5_err (context, 1, ret, "send_im_here");

    sp = krb5_storage_from_data (&data);
    if (sp == NULL)
	krb5_errx (context, 1, "krb5_storage_from_data");
    krb5_store_int32(sp, I_AM_HERE);
    krb5_storage_free(sp);

    ret = krb5_write_priv_message(context, auth_context, &fd, &data);
    krb5_data_free(&data);

    if (ret)
	krb5_err (context, 1, ret, "krb5_write_priv_message");
}

static void
d230 1
a230 1
    krb5_storage *sp;
d235 1
a235 1
    asprintf(&dbname, "%s-NEW", server_context->db->hdb_name);
d248 1
a248 1
    ret = mydb->hdb_open(context, mydb, O_RDWR | O_CREAT | O_TRUNC, 0600);
a252 1
    sp = NULL;
d254 2
a261 2
	if (sp == NULL)
	    krb5_errx (context, 1, "krb5_storage_from_data");
a266 2
	    krb5_storage_free(sp);

d273 3
a275 3
	    ret = mydb->hdb_store(server_context->context,
				  mydb,
				  0, &entry);
d281 1
a281 4
	} else if (opcode == NOW_YOU_HAVE)
	    ;
	else
	    krb5_errx (context, 1, "strange opcode %d", opcode);
d287 2
a288 2
    krb5_ret_int32 (sp, &vno);
    krb5_storage_free(sp);
d304 1
a304 1
    ret = mydb->hdb_rename (context, mydb, server_context->db->hdb_name);
d308 1
a308 1
    ret = mydb->hdb_close (context, mydb);
d312 1
a312 1
    ret = mydb->hdb_destroy (context, mydb);
a316 1
static char *config_file;
a320 2
static char *port_str;
static int detach_from_console = 0;
a322 1
    { "config-file", 'c', arg_string, &config_file },
a325 6
    { "time-lost", 0, arg_string, &server_time_lost,
      "time before server is considered lost", "time" },
    { "port", 0, arg_string, &port_str,
      "port ipropd-slave will connect to", "port"},
    { "detach", 0, arg_flag, &detach_from_console, 
      "detach from console" },
a350 1
    char **files;
a363 12
    if (config_file == NULL)
	config_file = HDB_DB_DIR "/kdc.conf";

    ret = krb5_prepend_config_files_default(config_file, &files);
    if (ret)
	krb5_err(context, 1, ret, "getting configuration files");

    ret = krb5_set_config_files(context, files);
    krb5_free_config_files(files);
    if (ret)
	krb5_err(context, 1, ret, "reading configuration files");

a371 2
    if (detach_from_console)
	daemon(0, 0);
a379 4
    time_before_lost = parse_time (server_time_lost,  "s");
    if (time_before_lost < 0)
	krb5_errx (context, 1, "couldn't parse time: %s", server_time_lost);

d402 1
a402 1
    master_fd = connect_to_master (context, master, port_str);
a424 23
	fd_set readset;
	struct timeval to;

	if (master_fd >= FD_SETSIZE)
	    krb5_errx (context, 1, "fd too large");

	FD_ZERO(&readset);
	FD_SET(master_fd, &readset);

	to.tv_sec = time_before_lost;
	to.tv_usec = 0;

	ret = select (master_fd + 1,
		      &readset, NULL, NULL, &to);
	if (ret < 0) {
	    if (errno == EINTR)
		continue;
	    else
		krb5_err (context, 1, errno, "select");
	}
	if (ret == 0)
	    krb5_errx (context, 1, "server didn't send a message "
		       "in %d seconds", time_before_lost);
a442 3
	case ARE_YOU_THERE :
	    send_im_here (context, master_fd, auth_context);
	    break;
a445 1
	case I_AM_HERE :
@


