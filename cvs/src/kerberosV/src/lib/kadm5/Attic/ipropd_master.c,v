head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.26
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.24
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.22
	OPENBSD_5_0:1.6.0.20
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.18
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.16
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.12
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.14
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.10
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.7;

1.7
date	2013.06.17.18.57.43;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.18.21.08.28;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.16.21.19.55;	author ray;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.06.00.37.37;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.26;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.26;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.09;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.17;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.45;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.07;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2008 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "iprop.h"
#include <rtbl.h>

static krb5_log_facility *log_facility;

const char *slave_stats_file;
const char *slave_time_missing = "2 min";
const char *slave_time_gone = "5 min";

static int time_before_missing;
static int time_before_gone;

const char *master_hostname;

static krb5_socket_t
make_signal_socket (krb5_context context)
{
#ifndef NO_UNIX_SOCKETS
    struct sockaddr_un addr;
    const char *fn;
    krb5_socket_t fd;

    fn = kadm5_log_signal_socket(context);

    fd = socket (AF_UNIX, SOCK_DGRAM, 0);
    if (fd < 0)
	krb5_err (context, 1, errno, "socket AF_UNIX");
    memset (&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strlcpy (addr.sun_path, fn, sizeof(addr.sun_path));
    unlink (addr.sun_path);
    if (bind (fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	krb5_err (context, 1, errno, "bind %s", addr.sun_path);
    return fd;
#else
    struct addrinfo *ai = NULL;
    krb5_socket_t fd;

    kadm5_log_signal_socket_info(context, 1, &ai);

    fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if (rk_IS_BAD_SOCKET(fd))
	krb5_err (context, 1, rk_SOCK_ERRNO, "socket AF=%d", ai->ai_family);

    if (rk_IS_SOCKET_ERROR( bind (fd, ai->ai_addr, ai->ai_addrlen) ))
	krb5_err (context, 1, rk_SOCK_ERRNO, "bind");
    return fd;
#endif
}

static krb5_socket_t
make_listen_socket (krb5_context context, const char *port_str)
{
    krb5_socket_t fd;
    int one = 1;
    struct sockaddr_in addr;

    fd = socket (AF_INET, SOCK_STREAM, 0);
    if (rk_IS_BAD_SOCKET(fd))
	krb5_err (context, 1, rk_SOCK_ERRNO, "socket AF_INET");
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));
    memset (&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;

    if (port_str) {
	addr.sin_port = krb5_getportbyname (context,
					      port_str, "tcp",
					      0);
	if (addr.sin_port == 0) {
	    char *ptr;
	    long port;

	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		krb5_errx (context, 1, "bad port `%s'", port_str);
	    addr.sin_port = htons(port);
	}
    } else {
	addr.sin_port = krb5_getportbyname (context, IPROP_SERVICE,
					    "tcp", IPROP_PORT);
    }
    if(bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	krb5_err (context, 1, errno, "bind");
    if (listen(fd, SOMAXCONN) < 0)
	krb5_err (context, 1, errno, "listen");
    return fd;
}

struct slave {
    krb5_socket_t fd;
    struct sockaddr_in addr;
    char *name;
    krb5_auth_context ac;
    uint32_t version;
    time_t seen;
    unsigned long flags;
#define SLAVE_F_DEAD	0x1
#define SLAVE_F_AYT	0x2
    struct slave *next;
};

typedef struct slave slave;

static int
check_acl (krb5_context context, const char *name)
{
    const char *fn;
    FILE *fp;
    char buf[256];
    int ret = 1;
    char *slavefile = NULL;

    if (asprintf(&slavefile, "%s/slaves", hdb_db_dir(context)) == -1
	|| slavefile == NULL)
	errx(1, "out of memory");

    fn = krb5_config_get_string_default(context,
					NULL,
					slavefile,
					"kdc",
					"iprop-acl",
					NULL);

    fp = fopen (fn, "r");
    free(slavefile);
    if (fp == NULL)
	return 1;
    while (fgets(buf, sizeof(buf), fp) != NULL) {
	buf[strcspn(buf, "\r\n")] = '\0';
	if (strcmp (buf, name) == 0) {
	    ret = 0;
	    break;
	}
    }
    fclose (fp);
    return ret;
}

static void
slave_seen(slave *s)
{
    s->flags &= ~SLAVE_F_AYT;
    s->seen = time(NULL);
}

static int
slave_missing_p (slave *s)
{
    if (time(NULL) > s->seen + time_before_missing)
	return 1;
    return 0;
}

static int
slave_gone_p (slave *s)
{
    if (time(NULL) > s->seen + time_before_gone)
	return 1;
    return 0;
}

static void
slave_dead(krb5_context context, slave *s)
{
    krb5_warnx(context, "slave %s dead", s->name);

    if (!rk_IS_BAD_SOCKET(s->fd)) {
	rk_closesocket (s->fd);
	s->fd = rk_INVALID_SOCKET;
    }
    s->flags |= SLAVE_F_DEAD;
    slave_seen(s);
}

static void
remove_slave (krb5_context context, slave *s, slave **root)
{
    slave **p;

    if (!rk_IS_BAD_SOCKET(s->fd))
	rk_closesocket (s->fd);
    if (s->name)
	free (s->name);
    if (s->ac)
	krb5_auth_con_free (context, s->ac);

    for (p = root; *p; p = &(*p)->next)
	if (*p == s) {
	    *p = s->next;
	    break;
	}
    free (s);
}

static void
add_slave (krb5_context context, krb5_keytab keytab, slave **root,
	   krb5_socket_t fd)
{
    krb5_principal server;
    krb5_error_code ret;
    slave *s;
    socklen_t addr_len;
    krb5_ticket *ticket = NULL;
    char hostname[128];

    s = malloc(sizeof(*s));
    if (s == NULL) {
	krb5_warnx (context, "add_slave: no memory");
	return;
    }
    s->name = NULL;
    s->ac = NULL;

    addr_len = sizeof(s->addr);
    s->fd = accept (fd, (struct sockaddr *)&s->addr, &addr_len);
    if (rk_IS_BAD_SOCKET(s->fd)) {
	krb5_warn (context, rk_SOCK_ERRNO, "accept");
	goto error;
    }
    if (master_hostname)
	strlcpy(hostname, master_hostname, sizeof(hostname));
    else
	gethostname(hostname, sizeof(hostname));

    ret = krb5_sname_to_principal (context, hostname, IPROP_NAME,
				   KRB5_NT_SRV_HST, &server);
    if (ret) {
	krb5_warn (context, ret, "krb5_sname_to_principal");
	goto error;
    }

    ret = krb5_recvauth (context, &s->ac, &s->fd,
			 IPROP_VERSION, server, 0, keytab, &ticket);
    krb5_free_principal (context, server);
    if (ret) {
	krb5_warn (context, ret, "krb5_recvauth");
	goto error;
    }
    ret = krb5_unparse_name (context, ticket->client, &s->name);
    krb5_free_ticket (context, ticket);
    if (ret) {
	krb5_warn (context, ret, "krb5_unparse_name");
	goto error;
    }
    if (check_acl (context, s->name)) {
	krb5_warnx (context, "%s not in acl", s->name);
	goto error;
    }

    {
	slave *l = *root;

	while (l) {
	    if (strcmp(l->name, s->name) == 0)
		break;
	    l = l->next;
	}
	if (l) {
	    if (l->flags & SLAVE_F_DEAD) {
		remove_slave(context, l, root);
	    } else {
		krb5_warnx (context, "second connection from %s", s->name);
		goto error;
	    }
	}
    }

    krb5_warnx (context, "connection from %s", s->name);

    s->version = 0;
    s->flags = 0;
    slave_seen(s);
    s->next = *root;
    *root = s;
    return;
error:
    remove_slave(context, s, root);
}

struct prop_context {
    krb5_auth_context auth_context;
    krb5_socket_t fd;
};

static int
prop_one (krb5_context context, HDB *db, hdb_entry_ex *entry, void *v)
{
    krb5_error_code ret;
    krb5_storage *sp;
    krb5_data data;
    struct slave *s = (struct slave *)v;

    ret = hdb_entry2value (context, &entry->entry, &data);
    if (ret)
	return ret;
    ret = krb5_data_realloc (&data, data.length + 4);
    if (ret) {
	krb5_data_free (&data);
	return ret;
    }
    memmove ((char *)data.data + 4, data.data, data.length - 4);
    sp = krb5_storage_from_data(&data);
    if (sp == NULL) {
	krb5_data_free (&data);
	return ENOMEM;
    }
    krb5_store_int32(sp, ONE_PRINC);
    krb5_storage_free(sp);

    ret = krb5_write_priv_message (context, s->ac, &s->fd, &data);
    krb5_data_free (&data);
    return ret;
}

static int
send_complete (krb5_context context, slave *s,
	       const char *database, uint32_t current_version)
{
    krb5_error_code ret;
    krb5_storage *sp;
    HDB *db;
    krb5_data data;
    char buf[8];

    ret = hdb_create (context, &db, database);
    if (ret)
	krb5_err (context, 1, ret, "hdb_create: %s", database);
    ret = db->hdb_open (context, db, O_RDONLY, 0);
    if (ret)
	krb5_err (context, 1, ret, "db->open");

    sp = krb5_storage_from_mem (buf, 4);
    if (sp == NULL)
	krb5_errx (context, 1, "krb5_storage_from_mem");
    krb5_store_int32 (sp, TELL_YOU_EVERYTHING);
    krb5_storage_free (sp);

    data.data   = buf;
    data.length = 4;

    ret = krb5_write_priv_message(context, s->ac, &s->fd, &data);

    if (ret) {
	krb5_warn (context, ret, "krb5_write_priv_message");
	slave_dead(context, s);
	return ret;
    }

    ret = hdb_foreach (context, db, HDB_F_ADMIN_DATA, prop_one, s);
    if (ret) {
	krb5_warn (context, ret, "hdb_foreach");
	slave_dead(context, s);
	return ret;
    }

    (*db->hdb_close)(context, db);
    (*db->hdb_destroy)(context, db);

    sp = krb5_storage_from_mem (buf, 8);
    if (sp == NULL)
	krb5_errx (context, 1, "krb5_storage_from_mem");
    krb5_store_int32 (sp, NOW_YOU_HAVE);
    krb5_store_int32 (sp, current_version);
    krb5_storage_free (sp);

    data.length = 8;

    s->version = current_version;

    ret = krb5_write_priv_message(context, s->ac, &s->fd, &data);
    if (ret) {
	slave_dead(context, s);
	krb5_warn (context, ret, "krb5_write_priv_message");
	return ret;
    }

    slave_seen(s);

    return 0;
}

static int
send_are_you_there (krb5_context context, slave *s)
{
    krb5_storage *sp;
    krb5_data data;
    char buf[4];
    int ret;

    if (s->flags & (SLAVE_F_DEAD|SLAVE_F_AYT))
	return 0;

    krb5_warnx(context, "slave %s missing, sending AYT", s->name);

    s->flags |= SLAVE_F_AYT;

    data.data = buf;
    data.length = 4;

    sp = krb5_storage_from_mem (buf, 4);
    if (sp == NULL) {
	krb5_warnx (context, "are_you_there: krb5_data_alloc");
	slave_dead(context, s);
	return 1;
    }
    krb5_store_int32 (sp, ARE_YOU_THERE);
    krb5_storage_free (sp);

    ret = krb5_write_priv_message(context, s->ac, &s->fd, &data);

    if (ret) {
	krb5_warn (context, ret, "are_you_there: krb5_write_priv_message");
	slave_dead(context, s);
	return 1;
    }

    return 0;
}

static int
send_diffs (krb5_context context, slave *s, int log_fd,
	    const char *database, uint32_t current_version)
{
    krb5_storage *sp;
    uint32_t ver;
    time_t timestamp;
    enum kadm_ops op;
    uint32_t len;
    off_t right, left;
    krb5_data data;
    int ret = 0;

    if (s->version == current_version) {
	krb5_warnx(context, "slave %s in sync already at version %ld",
		   s->name, (long)s->version);
	return 0;
    }

    if (s->flags & SLAVE_F_DEAD)
	return 0;

    /* if slave is a fresh client, starting over */
    if (s->version == 0) {
	krb5_warnx(context, "sending complete log to fresh slave %s",
		   s->name);
	return send_complete (context, s, database, current_version);
    }

    sp = kadm5_log_goto_end (log_fd);
    right = krb5_storage_seek(sp, 0, SEEK_CUR);
    for (;;) {
	ret = kadm5_log_previous (context, sp, &ver, &timestamp, &op, &len);
	if (ret)
	    krb5_err(context, 1, ret,
		     "send_diffs: failed to find previous entry");
	left = krb5_storage_seek(sp, -16, SEEK_CUR);
	if (ver == s->version)
	    return 0;
	if (ver == s->version + 1)
	    break;
	if (left == 0) {
	    krb5_storage_free(sp);
	    krb5_warnx(context,
		       "slave %s (version %lu) out of sync with master "
		       "(first version in log %lu), sending complete database",
		       s->name, (unsigned long)s->version, (unsigned long)ver);
	    return send_complete (context, s, database, current_version);
	}
    }

    krb5_warnx(context,
	       "syncing slave %s from version %lu to version %lu",
	       s->name, (unsigned long)s->version,
	       (unsigned long)current_version);

    ret = krb5_data_alloc (&data, right - left + 4);
    if (ret) {
	krb5_storage_free(sp);
	krb5_warn (context, ret, "send_diffs: krb5_data_alloc");
	slave_dead(context, s);
	return 1;
    }
    krb5_storage_read (sp, (char *)data.data + 4, data.length - 4);
    krb5_storage_free(sp);

    sp = krb5_storage_from_data (&data);
    if (sp == NULL) {
	krb5_warnx (context, "send_diffs: krb5_storage_from_data");
	slave_dead(context, s);
	return 1;
    }
    krb5_store_int32 (sp, FOR_YOU);
    krb5_storage_free(sp);

    ret = krb5_write_priv_message(context, s->ac, &s->fd, &data);
    krb5_data_free(&data);

    if (ret) {
	krb5_warn (context, ret, "send_diffs: krb5_write_priv_message");
	slave_dead(context, s);
	return 1;
    }
    slave_seen(s);

    s->version = current_version;

    return 0;
}

static int
process_msg (krb5_context context, slave *s, int log_fd,
	     const char *database, uint32_t current_version)
{
    int ret = 0;
    krb5_data out;
    krb5_storage *sp;
    int32_t tmp;

    ret = krb5_read_priv_message(context, s->ac, &s->fd, &out);
    if(ret) {
	krb5_warn (context, ret, "error reading message from %s", s->name);
	return 1;
    }

    sp = krb5_storage_from_mem (out.data, out.length);
    if (sp == NULL) {
	krb5_warnx (context, "process_msg: no memory");
	krb5_data_free (&out);
	return 1;
    }
    if (krb5_ret_int32 (sp, &tmp) != 0) {
	krb5_warnx (context, "process_msg: client send too short command");
	krb5_data_free (&out);
	return 1;
    }
    switch (tmp) {
    case I_HAVE :
	ret = krb5_ret_int32 (sp, &tmp);
	if (ret != 0) {
	    krb5_warnx (context, "process_msg: client send too I_HAVE data");
	    break;
	}
	/* new started slave that have old log */
	if (s->version == 0 && tmp != 0) {
	    if (current_version < (uint32_t)tmp) {
		krb5_warnx (context, "Slave %s (version %lu) have later version "
			    "the master (version %lu) OUT OF SYNC",
			    s->name, (unsigned long)tmp,
			    (unsigned long)current_version);
	    }
	    s->version = tmp;
	}
	if ((uint32_t)tmp < s->version) {
	    krb5_warnx (context, "Slave claims to not have "
			"version we already sent to it");
	} else {
	    ret = send_diffs (context, s, log_fd, database, current_version);
	}
	break;
    case I_AM_HERE :
	break;
    case ARE_YOU_THERE:
    case FOR_YOU :
    default :
	krb5_warnx (context, "Ignoring command %d", tmp);
	break;
    }

    krb5_data_free (&out);
    krb5_storage_free (sp);

    slave_seen(s);

    return ret;
}

#define SLAVE_NAME	"Name"
#define SLAVE_ADDRESS	"Address"
#define SLAVE_VERSION	"Version"
#define SLAVE_STATUS	"Status"
#define SLAVE_SEEN	"Last Seen"

static FILE *
open_stats(krb5_context context)
{
    char *statfile = NULL;
    const char *fn;
    FILE *f;

    if (slave_stats_file)
	fn = slave_stats_file;
    else {
	asprintf(&statfile,  "%s/slaves-stats", hdb_db_dir(context));
	fn = krb5_config_get_string_default(context,
					    NULL,
					    statfile,
					    "kdc",
					    "iprop-stats",
					    NULL);
    }
    f = fopen(fn, "w");
    if (statfile)
	free(statfile);

    return f;
}

static void
write_master_down(krb5_context context)
{
    char str[100];
    time_t t = time(NULL);
    FILE *fp;

    fp = open_stats(context);
    if (fp == NULL)
	return;
    krb5_format_time(context, t, str, sizeof(str), TRUE);
    fprintf(fp, "master down at %s\n", str);

    fclose(fp);
}

static void
write_stats(krb5_context context, slave *slaves, uint32_t current_version)
{
    char str[100];
    rtbl_t tbl;
    time_t t = time(NULL);
    FILE *fp;

    fp = open_stats(context);
    if (fp == NULL)
	return;

    krb5_format_time(context, t, str, sizeof(str), TRUE);
    fprintf(fp, "Status for slaves, last updated: %s\n\n", str);

    fprintf(fp, "Master version: %lu\n\n", (unsigned long)current_version);

    tbl = rtbl_create();
    if (tbl == NULL) {
	fclose(fp);
	return;
    }

    rtbl_add_column(tbl, SLAVE_NAME, 0);
    rtbl_add_column(tbl, SLAVE_ADDRESS, 0);
    rtbl_add_column(tbl, SLAVE_VERSION, RTBL_ALIGN_RIGHT);
    rtbl_add_column(tbl, SLAVE_STATUS, 0);
    rtbl_add_column(tbl, SLAVE_SEEN, 0);

    rtbl_set_prefix(tbl, "  ");
    rtbl_set_column_prefix(tbl, SLAVE_NAME, "");

    while (slaves) {
	krb5_address addr;
	krb5_error_code ret;
	rtbl_add_column_entry(tbl, SLAVE_NAME, slaves->name);
	ret = krb5_sockaddr2address (context,
				     (struct sockaddr*)&slaves->addr, &addr);
	if(ret == 0) {
	    krb5_print_address(&addr, str, sizeof(str), NULL);
	    krb5_free_address(context, &addr);
	    rtbl_add_column_entry(tbl, SLAVE_ADDRESS, str);
	} else
	    rtbl_add_column_entry(tbl, SLAVE_ADDRESS, "<unknown>");

	snprintf(str, sizeof(str), "%u", (unsigned)slaves->version);
	rtbl_add_column_entry(tbl, SLAVE_VERSION, str);

	if (slaves->flags & SLAVE_F_DEAD)
	    rtbl_add_column_entry(tbl, SLAVE_STATUS, "Down");
	else
	    rtbl_add_column_entry(tbl, SLAVE_STATUS, "Up");

	ret = krb5_format_time(context, slaves->seen, str, sizeof(str), TRUE);
	rtbl_add_column_entry(tbl, SLAVE_SEEN, str);

	slaves = slaves->next;
    }

    rtbl_format(tbl, fp);
    rtbl_destroy(tbl);

    fclose(fp);
}


static char sHDB[] = "HDB:";
static char *realm;
static int version_flag;
static int help_flag;
static char *keytab_str = sHDB;
static char *database;
static char *config_file;
static char *port_str;
#ifdef SUPPORT_DETACH
static int detach_from_console = 0;
#endif

static struct getargs args[] = {
    { "config-file", 'c', arg_string, &config_file, NULL, NULL },
    { "realm", 'r', arg_string, &realm, NULL, NULL },
    { "keytab", 'k', arg_string, &keytab_str,
      "keytab to get authentication from", "kspec" },
    { "database", 'd', arg_string, &database, "database", "file"},
    { "slave-stats-file", 0, arg_string, rk_UNCONST(&slave_stats_file),
      "file for slave status information", "file"},
    { "time-missing", 0, arg_string, rk_UNCONST(&slave_time_missing),
      "time before slave is polled for presence", "time"},
    { "time-gone", 0, arg_string, rk_UNCONST(&slave_time_gone),
      "time of inactivity after which a slave is considered gone", "time"},
    { "port", 0, arg_string, &port_str,
      "port ipropd will listen to", "port"},
#ifdef SUPPORT_DETACH
    { "detach", 0, arg_flag, &detach_from_console,
      "detach from console", NULL },
#endif
    { "hostname", 0, arg_string, rk_UNCONST(&master_hostname),
      "hostname of master (if not same as hostname)", "hostname" },
    { "version", 0, arg_flag, &version_flag, NULL, NULL },
    { "help", 0, arg_flag, &help_flag, NULL, NULL }
};
static int num_args = sizeof(args) / sizeof(args[0]);

int
main(int argc, char **argv)
{
    krb5_error_code ret;
    krb5_context context;
    void *kadm_handle;
    kadm5_server_context *server_context;
    kadm5_config_params conf;
    krb5_socket_t signal_fd, listen_fd;
    int log_fd;
    slave *slaves = NULL;
    uint32_t current_version = 0, old_version = 0;
    krb5_keytab keytab;
    int optidx;
    char **files;

    optidx = krb5_program_setup(&context, argc, argv, args, num_args, NULL);

    if(help_flag)
	krb5_std_usage(0, args, num_args);
    if(version_flag) {
	print_version(NULL);
	exit(0);
    }

    setup_signal();

    if (config_file == NULL) {
	asprintf(&config_file, "%s/kdc.conf", hdb_db_dir(context));
	if (config_file == NULL)
	    errx(1, "out of memory");
    }

    ret = krb5_prepend_config_files_default(config_file, &files);
    if (ret)
	krb5_err(context, 1, ret, "getting configuration files");

    ret = krb5_set_config_files(context, files);
    krb5_free_config_files(files);
    if (ret)
	krb5_err(context, 1, ret, "reading configuration files");

    time_before_gone = parse_time (slave_time_gone,  "s");
    if (time_before_gone < 0)
	krb5_errx (context, 1, "couldn't parse time: %s", slave_time_gone);
    time_before_missing = parse_time (slave_time_missing,  "s");
    if (time_before_missing < 0)
	krb5_errx (context, 1, "couldn't parse time: %s", slave_time_missing);

#ifdef SUPPORT_DETACH
    if (detach_from_console)
	daemon(0, 0);
#endif
    pidfile (NULL);
    krb5_openlog (context, "ipropd-master", &log_facility);
    krb5_set_warn_dest(context, log_facility);

    ret = krb5_kt_register(context, &hdb_kt_ops);
    if(ret)
	krb5_err(context, 1, ret, "krb5_kt_register");

    ret = krb5_kt_resolve(context, keytab_str, &keytab);
    if(ret)
	krb5_err(context, 1, ret, "krb5_kt_resolve: %s", keytab_str);

    memset(&conf, 0, sizeof(conf));
    if(realm) {
	conf.mask |= KADM5_CONFIG_REALM;
	conf.realm = realm;
    }
    ret = kadm5_init_with_skey_ctx (context,
				    KADM5_ADMIN_SERVICE,
				    NULL,
				    KADM5_ADMIN_SERVICE,
				    &conf, 0, 0,
				    &kadm_handle);
    if (ret)
	krb5_err (context, 1, ret, "kadm5_init_with_password_ctx");

    server_context = (kadm5_server_context *)kadm_handle;

    log_fd = open (server_context->log_context.log_file, O_RDONLY, 0);
    if (log_fd < 0)
	krb5_err (context, 1, errno, "open %s",
		  server_context->log_context.log_file);

    signal_fd = make_signal_socket (context);
    listen_fd = make_listen_socket (context, port_str);

    kadm5_log_get_version_fd (log_fd, &current_version);

    krb5_warnx(context, "ipropd-master started at version: %lu",
	       (unsigned long)current_version);

    while(exit_flag == 0){
	slave *p;
	fd_set readset;
	int max_fd = 0;
	struct timeval to = {30, 0};
	uint32_t vers;

#ifndef NO_LIMIT_FD_SETSIZE
	if (signal_fd >= FD_SETSIZE || listen_fd >= FD_SETSIZE)
	    krb5_errx (context, 1, "fd too large");
#endif

	FD_ZERO(&readset);
	FD_SET(signal_fd, &readset);
	max_fd = max(max_fd, signal_fd);
	FD_SET(listen_fd, &readset);
	max_fd = max(max_fd, listen_fd);

	for (p = slaves; p != NULL; p = p->next) {
	    if (p->flags & SLAVE_F_DEAD)
		continue;
	    FD_SET(p->fd, &readset);
	    max_fd = max(max_fd, p->fd);
	}

	ret = select (max_fd + 1,
		      &readset, NULL, NULL, &to);
	if (ret < 0) {
	    if (errno == EINTR)
		continue;
	    else
		krb5_err (context, 1, errno, "select");
	}

	if (ret == 0) {
	    old_version = current_version;
	    kadm5_log_get_version_fd (log_fd, &current_version);

	    if (current_version > old_version) {
		krb5_warnx(context,
			   "Missed a signal, updating slaves %lu to %lu",
			   (unsigned long)old_version,
			   (unsigned long)current_version);
		for (p = slaves; p != NULL; p = p->next) {
		    if (p->flags & SLAVE_F_DEAD)
			continue;
		    send_diffs (context, p, log_fd, database, current_version);
		}
	    }
	}

	if (ret && FD_ISSET(signal_fd, &readset)) {
#ifndef NO_UNIX_SOCKETS
	    struct sockaddr_un peer_addr;
#else
	    struct sockaddr_storage peer_addr;
#endif
	    socklen_t peer_len = sizeof(peer_addr);

	    if(recvfrom(signal_fd, (void *)&vers, sizeof(vers), 0,
			(struct sockaddr *)&peer_addr, &peer_len) < 0) {
		krb5_warn (context, errno, "recvfrom");
		continue;
	    }
	    --ret;
	    assert(ret >= 0);
	    old_version = current_version;
	    kadm5_log_get_version_fd (log_fd, &current_version);
	    if (current_version > old_version) {
		krb5_warnx(context,
			   "Got a signal, updating slaves %lu to %lu",
			   (unsigned long)old_version,
			   (unsigned long)current_version);
		for (p = slaves; p != NULL; p = p->next) {
		    if (p->flags & SLAVE_F_DEAD)
			continue;
		    send_diffs (context, p, log_fd, database, current_version);
		}
	    } else {
		krb5_warnx(context,
			   "Got a signal, but no update in log version %lu",
			   (unsigned long)current_version);
	    }
        }

	for(p = slaves; p != NULL; p = p->next) {
	    if (p->flags & SLAVE_F_DEAD)
	        continue;
	    if (ret && FD_ISSET(p->fd, &readset)) {
		--ret;
		assert(ret >= 0);
		if(process_msg (context, p, log_fd, database, current_version))
		    slave_dead(context, p);
	    } else if (slave_gone_p (p))
		slave_dead(context, p);
	    else if (slave_missing_p (p))
		send_are_you_there (context, p);
	}

	if (ret && FD_ISSET(listen_fd, &readset)) {
	    add_slave (context, keytab, &slaves, listen_fd);
	    --ret;
	    assert(ret >= 0);
	}
	write_stats(context, slaves, current_version);
    }

    if(exit_flag == SIGINT || exit_flag == SIGTERM)
	krb5_warnx(context, "%s terminated", getprogname());
#ifdef SIGXCPU
    else if(exit_flag == SIGXCPU)
	krb5_warnx(context, "%s CPU time limit exceeded", getprogname());
#endif
    else
	krb5_warnx(context, "%s unexpected exit reason: %ld",
		   getprogname(), (long)exit_flag);

    write_master_down(context);

    return 0;
}
@


1.7
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.6
log
@Sync with heimdal; clearer and might generet fewer conflicts on next import.

looks ok, beck@@ ray@@
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a36 2
RCSID("$KTH: ipropd_master.c,v 1.42 2005/05/23 17:38:46 lha Exp $");

d39 1
a39 1
const char *slave_stats_file = KADM5_SLAVE_STATS;
d46 3
a48 1
static int
d51 1
d53 4
a56 1
    int fd;
d63 1
a63 1
    strlcpy (addr.sun_path, KADM5_LOG_SIGNAL, sizeof(addr.sun_path));
d68 14
d84 1
a84 1
static int
d87 1
a87 1
    int fd;
d92 2
a93 2
    if (fd < 0)
	krb5_err (context, 1, errno, "socket AF_INET");
d100 1
a100 1
					      port_str, "tcp", 
d112 1
a112 1
	addr.sin_port = krb5_getportbyname (context, IPROP_SERVICE, 
d123 1
a123 1
    int fd;
d127 1
a127 1
    u_int32_t version;
d140 1
d144 1
d146 13
a158 1
    fp = fopen (KADM5_SLAVE_ACL, "r");
d196 1
a196 1
slave_dead(slave *s)
d198 5
a202 3
    if (s->fd >= 0) {
	close (s->fd);
	s->fd = -1;
d213 2
a214 2
    if (s->fd >= 0)
	close (s->fd);
d229 2
a230 1
add_slave (krb5_context context, krb5_keytab keytab, slave **root, int fd)
d249 2
a250 2
    if (s->fd < 0) {
	krb5_warn (context, errno, "accept");
d253 5
a257 1
    gethostname(hostname, sizeof(hostname));
d273 1
a281 2
    krb5_free_ticket (context, ticket);
    ticket = NULL;
d315 1
a315 1
    int fd;
d319 1
a319 1
prop_one (krb5_context context, HDB *db, hdb_entry *entry, void *v)
d324 1
a324 1
    struct slave *slave = (struct slave *)v;
d326 1
a326 1
    ret = hdb_entry2value (context, entry, &data);
d343 1
a343 1
    ret = krb5_write_priv_message (context, slave->ac, &slave->fd, &data);
d350 1
a350 1
	       const char *database, u_int32_t current_version)
d378 1
a378 1
	slave_dead(s);
d382 1
a382 1
    ret = hdb_foreach (context, db, 0, prop_one, s);
d385 1
a385 1
	slave_dead(s);
d405 1
a405 1
	slave_dead(s);
d426 2
d436 1
a436 1
	slave_dead(s);
d446 1
a446 1
	slave_dead(s);
d455 1
a455 1
	    const char *database, u_int32_t current_version)
d458 1
a458 1
    u_int32_t ver;
d461 1
a461 1
    u_int32_t len;
d466 3
a468 1
    if (s->version == current_version)
d470 1
d475 7
d485 4
a488 2
	if (kadm5_log_previous (sp, &ver, &timestamp, &op, &len))
	    abort ();
d494 6
a499 1
	if (left == 0)
d501 1
d503 6
d511 1
d513 1
a513 1
	slave_dead(s);
d522 1
a522 1
	slave_dead(s);
d533 1
a533 1
	slave_dead(s);
d538 2
d545 1
a545 1
	     const char *database, u_int32_t current_version)
d576 16
a591 2
	s->version = tmp;
	ret = send_diffs (context, s, log_fd, database, current_version);
d603 1
d616 25
d642 17
a658 1
write_stats(krb5_context context, slave *slaves, u_int32_t current_version)
d665 1
a665 1
    fp = fopen(slave_stats_file, "w");
d669 1
a669 1
    krb5_format_time(context, t, str, sizeof(str), TRUE); 
d693 1
a693 1
	ret = krb5_sockaddr2address (context, 
d701 1
a701 1
	
d710 1
a710 1
	ret = krb5_format_time(context, slaves->seen, str, sizeof(str), TRUE); 
d723 1
d727 1
a727 1
static char *keytab_str = "HDB:";
d731 1
d733 1
d736 2
a737 2
    { "config-file", 'c', arg_string, &config_file },
    { "realm", 'r', arg_string, &realm },
d741 1
a741 1
    { "slave-stats-file", 0, arg_string, &slave_stats_file, 
d743 1
a743 1
    { "time-missing", 0, arg_string, &slave_time_missing, 
d745 1
a745 1
    { "time-gone", 0, arg_string, &slave_time_gone,
d749 8
a756 4
    { "detach", 0, arg_flag, &detach_from_console, 
      "detach from console" },
    { "version", 0, arg_flag, &version_flag },
    { "help", 0, arg_flag, &help_flag }
d768 1
a768 1
    int signal_fd, listen_fd;
d771 1
a771 1
    u_int32_t current_version = 0, old_version = 0;
d773 1
a773 1
    int optind;
d775 3
a777 3
    
    optind = krb5_program_setup(&context, argc, argv, args, num_args, NULL);
    
d785 7
a791 2
    if (config_file == NULL)
	config_file = HDB_DB_DIR "/kdc.conf";
d809 1
d812 1
d824 1
a824 1
    
d834 1
a834 1
				    &conf, 0, 0, 
d849 4
a852 1
    signal (SIGPIPE, SIG_IGN);
d854 1
a854 1
    for (;;) {
d859 1
a859 1
	u_int32_t vers;
d861 1
d864 1
d893 4
d906 1
d908 3
d922 15
a936 2
	    for (p = slaves; p != NULL; p = p->next)
		send_diffs (context, p, log_fd, database, current_version);
d946 1
a946 1
		    slave_dead(p);
d948 1
a948 1
		slave_dead (p);
d960 12
@


1.5
log
@Check that string length != 0 before setting buf[strlen(buf) - 1].

OK cloder@@.
@
text
@d130 1
a130 2
	if (buf[0] != '\0' && buf[strlen(buf) - 1 ] == '\n')
	    buf[strlen(buf) - 1 ] = '\0';
@


1.4
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d130 1
a130 1
	if (buf[strlen(buf) - 1 ] == '\n')
@


1.3
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: ipropd_master.c,v 1.29 2003/03/19 11:56:38 lha Exp $");
d42 5
d67 1
a67 1
make_listen_socket (krb5_context context)
d79 18
a96 2
    addr.sin_port   = krb5_getportbyname (context,
					  IPROP_SERVICE, "tcp", IPROP_PORT);
d113 1
d144 1
d148 16
d285 1
d298 7
a304 1
    _krb5_put_int (data.data, ONE_PRINC, 4);
d316 1
d324 1
a324 1
    ret = db->open (context, db, O_RDONLY, 0);
d328 5
a332 1
    _krb5_put_int(buf, TELL_YOU_EVERYTHING, 4);
d352 10
a361 2
    _krb5_put_int (buf, NOW_YOU_HAVE, 4);
    _krb5_put_int (buf + 4, current_version, 4);
d379 36
d446 6
a451 1
    krb5_data_alloc (&data, right - left + 4);
d455 8
a462 1
    _krb5_put_int(data.data, FOR_YOU, 4);
d468 1
a468 1
	krb5_warn (context, ret, "krb5_write_priv_message");
d493 10
a502 1
    krb5_ret_int32 (sp, &tmp);
d505 5
a509 1
	krb5_ret_int32 (sp, &tmp);
d513 3
d547 1
a547 2
    strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S",
	     localtime(&t));
d588 1
a588 3
	if (strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S %Z", 
		     localtime(&slaves->seen)) == 0)
	    strlcpy(str, "Unknown time", sizeof(str));
d606 3
d611 1
d616 10
a625 1
    { "slave-stats-file", 0, arg_string, &slave_stats_file, "file"},
d642 1
a642 1
    u_int32_t current_version, old_version = 0;
d645 1
d656 21
d711 1
a711 1
    listen_fd = make_listen_socket (context);
d751 1
a751 1
	    if (current_version > old_version)
d757 1
d770 1
d775 1
a775 1
	}
d777 1
a777 1
	for(p = slaves; ret && p != NULL; p = p->next) {
d779 2
a780 2
		continue;
	    if (FD_ISSET(p->fd, &readset)) {
d782 1
d785 4
a788 1
	    }
d794 1
@


1.2
log
@-Wall -Werror sweep on i386.
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
#include <util.h>
d37 1
a37 1
RCSID("$KTH: ipropd_master.c,v 1.23 2001/08/30 15:15:50 nectar Exp $");
d41 2
d71 1
a71 1
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
d89 3
d120 37
d205 20
d228 2
d234 1
a234 25
    if (s->name)
	free (s->name);
    if (s->ac)
	krb5_auth_con_free(context, s->ac);
    if (ticket)
    krb5_free_ticket (context, ticket);
    close (s->fd);
    free(s);
}

static void
remove_slave (krb5_context context, slave *s, slave **root)
{
    slave **p;

    close (s->fd);
    free (s->name);
    krb5_auth_con_free (context, s->ac);

    for (p = root; *p; p = &(*p)->next)
	if (*p == s) {
	    *p = s->next;
	    break;
	}
    free (s);
d288 5
a292 2
    if (ret)
	krb5_err (context, 1, ret, "krb5_write_priv_message");
d295 5
a299 2
    if (ret)
	krb5_err (context, 1, ret, "hdb_foreach");
d305 2
d308 5
d314 1
a314 2
    if (ret)
	krb5_err (context, 1, ret, "krb5_write_priv_message");
d335 3
d339 1
a339 1
    right = sp->seek(sp, 0, SEEK_CUR);
d343 1
a343 1
	left = sp->seek(sp, -16, SEEK_CUR);
d352 1
a352 1
    sp->fetch (sp, (char *)data.data + 4, data.length - 4);
d358 1
d362 1
d365 2
d400 3
d406 75
d492 1
d577 2
d597 3
a599 1
		for (p = slaves; p != NULL; p = p->next)
d601 1
d608 1
a608 1
	    if(recvfrom(signal_fd, &vers, sizeof(vers), 0,
d620 3
a622 1
	for(p = slaves; p != NULL; p = p->next)
d626 1
a626 1
		    remove_slave (context, p, &slaves);
d628 1
d634 1
a634 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d35 1
d37 1
a37 1
RCSID("$KTH: ipropd_master.c,v 1.21 2000/11/15 23:12:45 assar Exp $");
d384 1
d477 1
a477 1
	for(p = slaves; p != NULL && ret--; p = p->next)
d479 1
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: ipropd_master.c,v 1.22 2001/02/14 23:00:16 assar Exp $");
d475 1
a475 1
	for(p = slaves; p != NULL; p = p->next)
a476 1
		--ret;
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: ipropd_master.c,v 1.23 2001/08/30 15:15:50 nectar Exp $");
a382 1
    pidfile (NULL);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
a34 1
#include <rtbl.h>
d36 1
a36 1
RCSID("$KTH: ipropd_master.c,v 1.29 2003/03/19 11:56:38 lha Exp $");
a39 2
const char *slave_stats_file = KADM5_SLAVE_STATS;

d68 1
a68 1
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));
a85 3
    time_t seen;
    unsigned long flags;
#define SLAVE_F_DEAD	0x1
a113 37
slave_seen(slave *s)
{
    s->seen = time(NULL);
}

static void
slave_dead(slave *s)
{
    if (s->fd >= 0) {
	close (s->fd);
	s->fd = -1;
    }
    s->flags |= SLAVE_F_DEAD;
    slave_seen(s);
}

static void
remove_slave (krb5_context context, slave *s, slave **root)
{
    slave **p;

    if (s->fd >= 0)
	close (s->fd);
    if (s->name)
	free (s->name);
    if (s->ac)
	krb5_auth_con_free (context, s->ac);

    for (p = root; *p; p = &(*p)->next)
	if (*p == s) {
	    *p = s->next;
	    break;
	}
    free (s);
}

static void
a161 20
    ticket = NULL;

    {
	slave *l = *root;

	while (l) {
	    if (strcmp(l->name, s->name) == 0)
		break;
	    l = l->next;
	}
	if (l) {
	    if (l->flags & SLAVE_F_DEAD) {
		remove_slave(context, l, root);
	    } else {
		krb5_warnx (context, "second connection from %s", s->name);
		goto error;
	    }
	}
    }

a164 2
    s->flags = 0;
    slave_seen(s);
d169 25
a193 1
    remove_slave(context, s, root);
d247 2
a248 5
    if (ret) {
	krb5_warn (context, ret, "krb5_write_priv_message");
	slave_dead(s);
	return ret;
    }
d251 2
a252 5
    if (ret) {
	krb5_warn (context, ret, "hdb_foreach");
	slave_dead(s);
	return ret;
    }
a257 2
    s->version = current_version;

a258 5
    if (ret) {
	slave_dead(s);
	krb5_warn (context, ret, "krb5_write_priv_message");
	return ret;
    }
d260 2
a261 1
    slave_seen(s);
a281 3
    if (s->flags & SLAVE_F_DEAD)
	return 0;

d283 1
a283 1
    right = krb5_storage_seek(sp, 0, SEEK_CUR);
d287 1
a287 1
	left = krb5_storage_seek(sp, -16, SEEK_CUR);
d296 1
a296 1
    krb5_storage_read (sp, (char *)data.data + 4, data.length - 4);
a301 1
    krb5_data_free(&data);
a304 1
	slave_dead(s);
a306 2
    slave_seen(s);

a339 3

    slave_seen(s);

a342 75
#define SLAVE_NAME	"Name"
#define SLAVE_ADDRESS	"Address"
#define SLAVE_VERSION	"Version"
#define SLAVE_STATUS	"Status"
#define SLAVE_SEEN	"Last Seen"

static void
write_stats(krb5_context context, slave *slaves, u_int32_t current_version)
{
    char str[100];
    rtbl_t tbl;
    time_t t = time(NULL);
    FILE *fp;

    fp = fopen(slave_stats_file, "w");
    if (fp == NULL)
	return;

    strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S",
	     localtime(&t));
    fprintf(fp, "Status for slaves, last updated: %s\n\n", str);

    fprintf(fp, "Master version: %lu\n\n", (unsigned long)current_version);

    tbl = rtbl_create();
    if (tbl == NULL) {
	fclose(fp);
	return;
    }

    rtbl_add_column(tbl, SLAVE_NAME, 0);
    rtbl_add_column(tbl, SLAVE_ADDRESS, 0);
    rtbl_add_column(tbl, SLAVE_VERSION, RTBL_ALIGN_RIGHT);
    rtbl_add_column(tbl, SLAVE_STATUS, 0);
    rtbl_add_column(tbl, SLAVE_SEEN, 0);

    rtbl_set_prefix(tbl, "  ");
    rtbl_set_column_prefix(tbl, SLAVE_NAME, "");

    while (slaves) {
	krb5_address addr;
	krb5_error_code ret;
	rtbl_add_column_entry(tbl, SLAVE_NAME, slaves->name);
	ret = krb5_sockaddr2address (context, 
				     (struct sockaddr*)&slaves->addr, &addr);
	if(ret == 0) {
	    krb5_print_address(&addr, str, sizeof(str), NULL);
	    krb5_free_address(context, &addr);
	    rtbl_add_column_entry(tbl, SLAVE_ADDRESS, str);
	} else
	    rtbl_add_column_entry(tbl, SLAVE_ADDRESS, "<unknown>");
	
	snprintf(str, sizeof(str), "%u", (unsigned)slaves->version);
	rtbl_add_column_entry(tbl, SLAVE_VERSION, str);

	if (slaves->flags & SLAVE_F_DEAD)
	    rtbl_add_column_entry(tbl, SLAVE_STATUS, "Down");
	else
	    rtbl_add_column_entry(tbl, SLAVE_STATUS, "Up");

	if (strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S %Z", 
		     localtime(&slaves->seen)) == 0)
	    strlcpy(str, "Unknown time", sizeof(str));
	rtbl_add_column_entry(tbl, SLAVE_SEEN, str);

	slaves = slaves->next;
    }

    rtbl_format(tbl, fp);
    rtbl_destroy(tbl);

    fclose(fp);
}


a353 1
    { "slave-stats-file", 0, arg_string, &slave_stats_file, "file"},
a437 2
	    if (p->flags & SLAVE_F_DEAD)
		continue;
d456 1
a456 3
		for (p = slaves; p != NULL; p = p->next) {
		    if (p->flags & SLAVE_F_DEAD)
			continue;
a457 1
		}
d464 1
a464 1
	    if(recvfrom(signal_fd, (void *)&vers, sizeof(vers), 0,
d476 1
a476 3
	for(p = slaves; ret && p != NULL; p = p->next) {
	    if (p->flags & SLAVE_F_DEAD)
		continue;
d480 1
a480 1
		    slave_dead(p);
a481 1
	}
d487 1
a487 1
	write_stats(context, slaves, current_version);
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: ipropd_master.c,v 1.42 2005/05/23 17:38:46 lha Exp $");
a41 5
const char *slave_time_missing = "2 min";
const char *slave_time_gone = "5 min";

static int time_before_missing;
static int time_before_gone;
d62 1
a62 1
make_listen_socket (krb5_context context, const char *port_str)
d74 2
a75 18

    if (port_str) {
	addr.sin_port = krb5_getportbyname (context,
					      port_str, "tcp", 
					      0);
	if (addr.sin_port == 0) {
	    char *ptr;
	    long port;

	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		krb5_errx (context, 1, "bad port `%s'", port_str);
	    addr.sin_port = htons(port);
	}
    } else {
	addr.sin_port = krb5_getportbyname (context, IPROP_SERVICE, 
					    "tcp", IPROP_PORT);
    }
a91 1
#define SLAVE_F_AYT	0x2
a121 1
    s->flags &= ~SLAVE_F_AYT;
a124 16
static int
slave_missing_p (slave *s)
{
    if (time(NULL) > s->seen + time_before_missing)
	return 1;
    return 0;
}

static int
slave_gone_p (slave *s)
{
    if (time(NULL) > s->seen + time_before_gone)
	return 1;
    return 0;
}

a245 1
    krb5_storage *sp;
d258 1
a258 7
    sp = krb5_storage_from_data(&data);
    if (sp == NULL) {
	krb5_data_free (&data);
	return ENOMEM;
    }
    krb5_store_int32(sp, ONE_PRINC);
    krb5_storage_free(sp);
a269 1
    krb5_storage *sp;
d277 1
a277 1
    ret = db->hdb_open (context, db, O_RDONLY, 0);
d281 1
a281 5
    sp = krb5_storage_from_mem (buf, 4);
    if (sp == NULL)
	krb5_errx (context, 1, "krb5_storage_from_mem");
    krb5_store_int32 (sp, TELL_YOU_EVERYTHING);
    krb5_storage_free (sp);
d301 2
a302 10
    (*db->hdb_close)(context, db);
    (*db->hdb_destroy)(context, db);

    sp = krb5_storage_from_mem (buf, 8);
    if (sp == NULL)
	krb5_errx (context, 1, "krb5_storage_from_mem");
    krb5_store_int32 (sp, NOW_YOU_HAVE);
    krb5_store_int32 (sp, current_version);
    krb5_storage_free (sp);

a319 36
send_are_you_there (krb5_context context, slave *s)
{
    krb5_storage *sp;
    krb5_data data;
    char buf[4];
    int ret;

    if (s->flags & (SLAVE_F_DEAD|SLAVE_F_AYT))
	return 0;

    s->flags |= SLAVE_F_AYT;

    data.data = buf;
    data.length = 4;

    sp = krb5_storage_from_mem (buf, 4);
    if (sp == NULL) {
	krb5_warnx (context, "are_you_there: krb5_data_alloc");
	slave_dead(s);
	return 1;
    }
    krb5_store_int32 (sp, ARE_YOU_THERE);
    krb5_storage_free (sp);

    ret = krb5_write_priv_message(context, s->ac, &s->fd, &data);

    if (ret) {
	krb5_warn (context, ret, "are_you_there: krb5_write_priv_message");
	slave_dead(s);
	return 1;
    }

    return 0;
}

static int
d351 1
a351 6
    ret = krb5_data_alloc (&data, right - left + 4);
    if (ret) {
	krb5_warn (context, ret, "send_diffs: krb5_data_alloc");
	slave_dead(s);
	return 1;
    }
d355 1
a355 8
    sp = krb5_storage_from_data (&data);
    if (sp == NULL) {
	krb5_warnx (context, "send_diffs: krb5_storage_from_data");
	slave_dead(s);
	return 1;
    }
    krb5_store_int32 (sp, FOR_YOU);
    krb5_storage_free(sp);
d361 1
a361 1
	krb5_warn (context, ret, "send_diffs: krb5_write_priv_message");
d386 1
a386 10
    if (sp == NULL) {
	krb5_warnx (context, "process_msg: no memory");
	krb5_data_free (&out);
	return 1;
    }
    if (krb5_ret_int32 (sp, &tmp) != 0) {
	krb5_warnx (context, "process_msg: client send too short command");
	krb5_data_free (&out);
	return 1;
    }
d389 1
a389 5
	ret = krb5_ret_int32 (sp, &tmp);
	if (ret != 0) {
	    krb5_warnx (context, "process_msg: client send too I_HAVE data");
	    break;
	}
a392 3
    case I_AM_HERE :
	break;
    case ARE_YOU_THERE:
d424 2
a425 1
    krb5_format_time(context, t, str, sizeof(str), TRUE); 
d466 3
a468 1
	ret = krb5_format_time(context, slaves->seen, str, sizeof(str), TRUE); 
a485 3
static char *config_file;
static char *port_str;
static int detach_from_console = 0;
a487 1
    { "config-file", 'c', arg_string, &config_file },
d492 1
a492 10
    { "slave-stats-file", 0, arg_string, &slave_stats_file, 
      "file for slave status information", "file"},
    { "time-missing", 0, arg_string, &slave_time_missing, 
      "time before slave is polled for presence", "time"},
    { "time-gone", 0, arg_string, &slave_time_gone,
      "time of inactivity after which a slave is considered gone", "time"},
    { "port", 0, arg_string, &port_str,
      "port ipropd will listen to", "port"},
    { "detach", 0, arg_flag, &detach_from_console, 
      "detach from console" },
d509 1
a509 1
    u_int32_t current_version = 0, old_version = 0;
a511 1
    char **files;
a521 21
    if (config_file == NULL)
	config_file = HDB_DB_DIR "/kdc.conf";

    ret = krb5_prepend_config_files_default(config_file, &files);
    if (ret)
	krb5_err(context, 1, ret, "getting configuration files");

    ret = krb5_set_config_files(context, files);
    krb5_free_config_files(files);
    if (ret)
	krb5_err(context, 1, ret, "reading configuration files");

    time_before_gone = parse_time (slave_time_gone,  "s");
    if (time_before_gone < 0)
	krb5_errx (context, 1, "couldn't parse time: %s", slave_time_gone);
    time_before_missing = parse_time (slave_time_missing,  "s");
    if (time_before_missing < 0)
	krb5_errx (context, 1, "couldn't parse time: %s", slave_time_missing);

    if (detach_from_console)
	daemon(0, 0);
d556 1
a556 1
    listen_fd = make_listen_socket (context, port_str);
d596 1
a596 1
	    if (current_version > old_version) {
a601 1
	    }
a613 1
	    assert(ret >= 0);
d618 1
a618 1
        }
d620 1
a620 1
	for(p = slaves; p != NULL; p = p->next) {
d622 2
a623 2
	        continue;
	    if (ret && FD_ISSET(p->fd, &readset)) {
a624 1
		assert(ret >= 0);
d627 1
a627 4
	    } else if (slave_gone_p (p))
		slave_dead (p);
	    else if (slave_missing_p (p))
		send_are_you_there (context, p);
a632 1
	    assert(ret >= 0);
@


