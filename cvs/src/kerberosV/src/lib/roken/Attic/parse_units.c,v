head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.28
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.26
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.24
	OPENBSD_5_0:1.3.0.22
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.20
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.18
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.14
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.16
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.12
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.10
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.3.0.8
	OPENBSD_3_7_BASE:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.8
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.04.22.10.01.33;	author reyk;	state dead;
branches;
next	1.4;

1.4
date	2013.06.17.18.57.45;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.14.08.15.05;	author biorn;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.20.20.26.40;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.16;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.16;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.25.17;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.16.07;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.33.42;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2001 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "roken.h"
#include "parse_units.h"

/*
 * Parse string in `s' according to `units' and return value.
 * def_unit defines the default unit.
 */

static int
parse_something (const char *s, const struct units *units,
		 const char *def_unit,
		 int (*func)(int res, int val, unsigned mult),
		 int init,
		 int accept_no_val_p)
{
    const char *p;
    int res = init;
    unsigned def_mult = 1;

    if (def_unit != NULL) {
	const struct units *u;

	for (u = units; u->name; ++u) {
	    if (strcasecmp (u->name, def_unit) == 0) {
		def_mult = u->mult;
		break;
	    }
	}
	if (u->name == NULL)
	    return -1;
    }

    p = s;
    while (*p) {
	int val;
	char *next;
	const struct units *u, *partial_unit;
	size_t u_len;
	unsigned partial;
	int no_val_p = 0;

	while(isspace((unsigned char)*p) || *p == ',')
	    ++p;

	val = strtol(p, &next, 0);
	if (p == next) {
	    val = 0;
	    if(!accept_no_val_p)
		return -1;
	    no_val_p = 1;
	}
	p = next;
	while (isspace((unsigned char)*p))
	    ++p;
	if (*p == '\0') {
	    res = (*func)(res, val, def_mult);
	    if (res < 0)
		return res;
	    break;
	} else if (*p == '+') {
	    ++p;
	    val = 1;
	} else if (*p == '-') {
	    ++p;
	    val = -1;
	}
	if (no_val_p && val == 0)
	    val = 1;
	u_len = strcspn (p, ", \t");
	partial = 0;
	partial_unit = NULL;
	if (u_len > 1 && p[u_len - 1] == 's')
	    --u_len;
	for (u = units; u->name; ++u) {
	    if (strncasecmp (p, u->name, u_len) == 0) {
		if (u_len == strlen (u->name)) {
		    p += u_len;
		    res = (*func)(res, val, u->mult);
		    if (res < 0)
			return res;
		    break;
		} else {
		    ++partial;
		    partial_unit = u;
		}
	    }
	}
	if (u->name == NULL) {
	    if (partial == 1) {
		p += u_len;
		res = (*func)(res, val, partial_unit->mult);
		if (res < 0)
		    return res;
	    } else {
		return -1;
	    }
	}
	if (*p == 's')
	    ++p;
    }
    return res;
}

/*
 * The string consists of a sequence of `n unit'
 */

static int
acc_units(int res, int val, unsigned mult)
{
    return res + val * mult;
}

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
parse_units (const char *s, const struct units *units,
	     const char *def_unit)
{
    return parse_something (s, units, def_unit, acc_units, 0, 0);
}

/*
 * The string consists of a sequence of `[+-]flag'.  `orig' consists
 * the original set of flags, those are then modified and returned as
 * the function value.
 */

static int
acc_flags(int res, int val, unsigned mult)
{
    if(val == 1)
	return res | mult;
    else if(val == -1)
	return res & ~mult;
    else if (val == 0)
	return mult;
    else
	return -1;
}

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
parse_flags (const char *s, const struct units *units,
	     int orig)
{
    return parse_something (s, units, NULL, acc_flags, orig, 1);
}

/*
 * Return a string representation according to `units' of `num' in `s'
 * with maximum length `len'.  The actual length is the function value.
 */

static int
unparse_something (int num, const struct units *units, char *s, size_t len,
		   int (*print) (char *, size_t, int, const char *, int),
		   int (*update) (int, unsigned),
		   const char *zero_string)
{
    const struct units *u;
    int ret = 0, tmp;

    if (num == 0)
	return snprintf (s, len, "%s", zero_string);

    for (u = units; num > 0 && u->name; ++u) {
	int divisor;

	divisor = num / u->mult;
	if (divisor) {
	    num = (*update) (num, u->mult);
	    tmp = (*print) (s, len, divisor, u->name, num);
	    if (tmp < 0)
		return tmp;
	    if (tmp > (int) len) {
		len = 0;
		s = NULL;
	    } else {
		len -= tmp;
		s += tmp;
	    }
	    ret += tmp;
	}
    }
    return ret;
}

static int
print_unit (char *s, size_t len, int divisor, const char *name, int rem)
{
    return snprintf (s, len, "%u %s%s%s",
		     divisor, name,
		     divisor == 1 ? "" : "s",
		     rem > 0 ? " " : "");
}

static int
update_unit (int in, unsigned mult)
{
    return in % mult;
}

static int
update_unit_approx (int in, unsigned mult)
{
    if (in / mult > 0)
	return 0;
    else
	return update_unit (in, mult);
}

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
unparse_units (int num, const struct units *units, char *s, size_t len)
{
    return unparse_something (num, units, s, len,
			      print_unit,
			      update_unit,
			      "0");
}

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
unparse_units_approx (int num, const struct units *units, char *s, size_t len)
{
    return unparse_something (num, units, s, len,
			      print_unit,
			      update_unit_approx,
			      "0");
}

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
print_units_table (const struct units *units, FILE *f)
{
    const struct units *u, *u2;
    size_t max_sz = 0;

    for (u = units; u->name; ++u) {
	max_sz = max(max_sz, strlen(u->name));
    }

    for (u = units; u->name;) {
	char buf[1024];
	const struct units *next;

	for (next = u + 1; next->name && next->mult == u->mult; ++next)
	    ;

	if (next->name) {
	    for (u2 = next;
		 u2->name && u->mult % u2->mult != 0;
		 ++u2)
		;
	    if (u2->name == NULL)
		--u2;
	    unparse_units (u->mult, u2, buf, sizeof(buf));
	    fprintf (f, "1 %*s = %s\n", (int)max_sz, u->name, buf);
	} else {
	    fprintf (f, "1 %s\n", u->name);
	}
	u = next;
    }
}

static int
print_flag (char *s, size_t len, int divisor, const char *name, int rem)
{
    return snprintf (s, len, "%s%s", name, rem > 0 ? ", " : "");
}

static int
update_flag (int in, unsigned mult)
{
    return in - mult;
}

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
unparse_flags (int num, const struct units *units, char *s, size_t len)
{
    return unparse_something (num, units, s, len,
			      print_flag,
			      update_flag,
			      "");
}

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
print_flags_table (const struct units *units, FILE *f)
{
    const struct units *u;

    for(u = units; u->name; ++u)
	fprintf(f, "%s%s", u->name, (u+1)->name ? ", " : "\n");
}
@


1.4
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.3
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a33 1
#ifdef HAVE_CONFIG_H
a34 2
RCSID("$KTH: parse_units.c,v 1.18 2005/04/12 11:28:59 lha Exp $");
#endif
d39 1
a39 1
#include <roken.h>
d73 1
a73 1
	double val;
d83 1
a83 1
	val = strtod (p, &next); /* strtol(p, &next, 0); */
d152 1
a152 1
int ROKEN_LIB_FUNCTION
d178 1
a178 1
int ROKEN_LIB_FUNCTION
d187 1
a187 2
 * with maximum length `len'.  The actual length of the returned string
 * is the returned value.
d199 2
a200 8
    /* snprintf doesn't nul terminate on 0 length */	
    if (len == 0)
	return(0);

    if (num == 0) {
	(void) snprintf (s, len, "%s", zero_string);
	return(strlen(s));
    }
d211 1
a211 1
	    if (tmp > len) {
d248 1
a248 1
int ROKEN_LIB_FUNCTION
d257 1
a257 1
int ROKEN_LIB_FUNCTION
d266 1
a266 1
void ROKEN_LIB_FUNCTION
d270 1
a270 1
    unsigned max_sz = 0;
d291 1
a291 1
	    fprintf (f, "1 %*s = %s\n", max_sz, u->name, buf);
d302 1
a302 4
    if (len == 0)
	return(0);	
    (void) snprintf (s, len, "%s%s", name, rem > 0 ? ", " : "");
    return(strlen(s));
d311 1
a311 1
int ROKEN_LIB_FUNCTION
d320 1
a320 1
void ROKEN_LIB_FUNCTION
@


1.2
log
@fix snprintf abuse and strlcpy abuse, return the string length, which
is at least safe for the pointer arithmatic case
ok cloder@@
@
text
@d36 1
a36 1
RCSID("$KTH: parse_units.c,v 1.14 2001/09/04 09:56:00 assar Exp $");
d155 1
a155 1
int
d181 1
a181 1
int
d196 2
a197 3
		   int (*print) (char *s, size_t len, int div,
				const char *name, int rem),
		   int (*update) (int in, unsigned mult),
d213 1
a213 1
	int div;
d215 2
a216 2
	div = num / u->mult;
	if (div) {
d218 1
a218 1
	    tmp = (*print) (s, len, div, u->name, num);
d221 7
a227 3

	    len -= tmp;
	    s += tmp;
d235 1
a235 1
print_unit (char *s, size_t len, int div, const char *name, int rem)
d237 4
a240 5
    if (len == 0)
	return(0);	
    (void) snprintf (s, len, "%u %s%s%s",
	div, name, div == 1 ? "" : "s", rem > 0 ? " " : "");
    return(strlen(s));
d258 1
a258 1
int
d267 1
a267 1
int
d276 1
a276 1
void
d310 1
a310 1
print_flag (char *s, size_t len, int div, const char *name, int rem)
d324 1
a324 1
int
d333 1
a333 1
void
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 1998, 1999 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: parse_units.c,v 1.12 1999/12/02 16:58:51 joda Exp $");
d87 2
a88 1
	if (val == 0 && p == next) {
d190 2
a191 1
 * with maximum length `len'.  The actual length is the function value.
d194 1
a194 1
static size_t
d202 1
a202 1
    size_t ret = 0, tmp;
d204 8
a211 2
    if (num == 0)
	return snprintf (s, len, "%s", zero_string);
d220 2
d234 5
a238 4
    return snprintf (s, len, "%u %s%s%s",
		     div, name,
		     div == 1 ? "" : "s",
		     rem > 0 ? " " : "");
d256 1
a256 1
size_t
d265 1
a265 1
size_t
d310 4
a313 1
    return snprintf (s, len, "%s%s", name, rem > 0 ? ", " : "");
d322 1
a322 1
size_t
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: parse_units.c,v 1.13 2001/03/26 00:47:06 assar Exp $");
d87 1
a87 2
	if (p == next) {
	    val = 0;
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d36 1
a36 1
RCSID("$KTH: parse_units.c,v 1.14 2001/09/04 09:56:00 assar Exp $");
d193 1
a193 1
static int
d201 1
a201 1
    int ret = 0, tmp;
a212 2
	    if (tmp < 0)
		return tmp;
d246 1
a246 1
int
d255 1
a255 1
int
d309 1
a309 1
int
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: parse_units.c,v 1.18 2005/04/12 11:28:59 lha Exp $");
d155 1
a155 1
int ROKEN_LIB_FUNCTION
d181 1
a181 1
int ROKEN_LIB_FUNCTION
d195 3
a197 2
		   int (*print) (char *, size_t, int, const char *, int),
		   int (*update) (int, unsigned),
d207 1
a207 1
	int divisor;
d209 2
a210 2
	divisor = num / u->mult;
	if (divisor) {
d212 1
a212 1
	    tmp = (*print) (s, len, divisor, u->name, num);
d215 3
a217 7
	    if (tmp > len) {
		len = 0;
		s = NULL;
	    } else {
		len -= tmp;
		s += tmp;
	    }
d225 1
a225 1
print_unit (char *s, size_t len, int divisor, const char *name, int rem)
d228 2
a229 2
		     divisor, name,
		     divisor == 1 ? "" : "s",
d248 1
a248 1
int ROKEN_LIB_FUNCTION
d257 1
a257 1
int ROKEN_LIB_FUNCTION
d266 1
a266 1
void ROKEN_LIB_FUNCTION
d300 1
a300 1
print_flag (char *s, size_t len, int divisor, const char *name, int rem)
d311 1
a311 1
int ROKEN_LIB_FUNCTION
d320 1
a320 1
void ROKEN_LIB_FUNCTION
@


