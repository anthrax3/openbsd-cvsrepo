head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_7:1.1.1.3.0.8
	OPENBSD_3_7_BASE:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.6
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.4
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.34;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.45;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.20.20.26.40;	author beck;	state dead;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.21;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.21;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.52;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.16.09;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.33.44;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1995-2003 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "roken.h"
#include <assert.h>

enum format_flags {
    minus_flag     =  1,
    plus_flag      =  2,
    space_flag     =  4,
    alternate_flag =  8,
    zero_flag      = 16
};

/*
 * Common state
 */

struct snprintf_state {
    unsigned char *str;
    unsigned char *s;
    unsigned char *theend;
    size_t sz;
    size_t max_sz;
    void (*append_char)(struct snprintf_state *, unsigned char);
    /* XXX - methods */
};

#if !defined(HAVE_VSNPRINTF) || defined(TEST_SNPRINTF)
static int
sn_reserve (struct snprintf_state *state, size_t n)
{
    return state->s + n > state->theend;
}

static void
sn_append_char (struct snprintf_state *state, unsigned char c)
{
    if (!sn_reserve (state, 1))
	*state->s++ = c;
}
#endif

static int
as_reserve (struct snprintf_state *state, size_t n)
{
    if (state->s + n > state->theend) {
	int off = state->s - state->str;
	unsigned char *tmp;

	if (state->max_sz && state->sz >= state->max_sz)
	    return 1;

	state->sz = max(state->sz * 2, state->sz + n);
	if (state->max_sz)
	    state->sz = min(state->sz, state->max_sz);
	tmp = realloc (state->str, state->sz);
	if (tmp == NULL)
	    return 1;
	state->str = tmp;
	state->s = state->str + off;
	state->theend = state->str + state->sz - 1;
    }
    return 0;
}

static void
as_append_char (struct snprintf_state *state, unsigned char c)
{
    if(!as_reserve (state, 1))
	*state->s++ = c;
}

/* longest integer types */

#ifdef HAVE_LONG_LONG
typedef unsigned long long u_longest;
typedef long long longest;
#else
typedef unsigned long u_longest;
typedef long longest;
#endif



static size_t
pad(struct snprintf_state *state, int width, char c)
{
    size_t len = 0;
    while(width-- > 0){
	(*state->append_char)(state,  c);
	++len;
    }
    return len;
}

/* return true if we should use alternatve hex form */
static int
use_alternative (int flags, u_longest num, unsigned base)
{
    return (flags & alternate_flag) && base == 16 && num != 0;
}

static int
append_number(struct snprintf_state *state,
	      u_longest num, unsigned base, const char *rep,
	      int width, int prec, int flags, int minusp)
{
    int len = 0;
    u_longest n = num;
    char nstr[64]; /* enough for <192 bit octal integers */
    int nstart, nlen;
    char signchar;

    /* given precision, ignore zero flag */
    if(prec != -1)
	flags &= ~zero_flag;
    else
	prec = 1;

    /* format number as string */
    nstart = sizeof(nstr);
    nlen = 0;
    nstr[--nstart] = '\0';
    do {
	assert(nstart > 0);
	nstr[--nstart] = rep[n % base];
	++nlen;
	n /= base;
    } while(n);

    /* zero value with zero precision should produce no digits */
    if(prec == 0 && num == 0) {
	nlen--;
	nstart++;
    }

    /* figure out what char to use for sign */
    if(minusp)
	signchar = '-';
    else if((flags & plus_flag))
	signchar = '+';
    else if((flags & space_flag))
	signchar = ' ';
    else
	signchar = '\0';

    if((flags & alternate_flag) && base == 8) {
	/* if necessary, increase the precision to
	   make first digit a zero */

	/* XXX C99 claims (regarding # and %o) that "if the value and
           precision are both 0, a single 0 is printed", but there is
           no such wording for %x. This would mean that %#.o would
           output "0", but %#.x "". This does not make sense, and is
           also not what other printf implementations are doing. */

	if(prec <= nlen && nstr[nstart] != '0' && nstr[nstart] != '\0')
	    prec = nlen + 1;
    }

    /* possible formats:
       pad | sign | alt | zero | digits
       sign | alt | zero | digits | pad   minus_flag
       sign | alt | zero | digits zero_flag */

    /* if not right justifying or padding with zeros, we need to
       compute the length of the rest of the string, and then pad with
       spaces */
    if(!(flags & (minus_flag | zero_flag))) {
	if(prec > nlen)
	    width -= prec;
	else
	    width -= nlen;

	if(use_alternative(flags, num, base))
	    width -= 2;

	if(signchar != '\0')
	    width--;

	/* pad to width */
	len += pad(state, width, ' ');
    }
    if(signchar != '\0') {
	(*state->append_char)(state, signchar);
	++len;
    }
    if(use_alternative(flags, num, base)) {
	(*state->append_char)(state, '0');
	(*state->append_char)(state, rep[10] + 23); /* XXX */
	len += 2;
    }
    if(flags & zero_flag) {
	/* pad to width with zeros */
	if(prec - nlen > width - len - nlen)
	    len += pad(state, prec - nlen, '0');
	else
	    len += pad(state, width - len - nlen, '0');
    } else
	/* pad to prec with zeros */
	len += pad(state, prec - nlen, '0');

    while(nstr[nstart] != '\0') {
	(*state->append_char)(state, nstr[nstart++]);
	++len;
    }

    if(flags & minus_flag)
	len += pad(state, width - len, ' ');

    return len;
}

/*
 * return length
 */

static size_t
append_string (struct snprintf_state *state,
	       const unsigned char *arg,
	       int width,
	       int prec,
	       int flags)
{
    size_t len = 0;

    if(arg == NULL)
	arg = (const unsigned char*)"(null)";

    if(prec != -1)
	width -= prec;
    else
	width -= strlen((const char *)arg);
    if(!(flags & minus_flag))
	len += pad(state, width, ' ');

    if (prec != -1) {
	while (*arg && prec--) {
	    (*state->append_char) (state, *arg++);
	    ++len;
	}
    } else {
	while (*arg) {
	    (*state->append_char) (state, *arg++);
	    ++len;
	}
    }
    if(flags & minus_flag)
	len += pad(state, width, ' ');
    return len;
}

static int
append_char(struct snprintf_state *state,
	    unsigned char arg,
	    int width,
	    int flags)
{
    int len = 0;

    while(!(flags & minus_flag) && --width > 0) {
	(*state->append_char) (state, ' ')    ;
	++len;
    }
    (*state->append_char) (state, arg);
    ++len;
    while((flags & minus_flag) && --width > 0) {
	(*state->append_char) (state, ' ');
	++len;
    }
    return 0;
}

/*
 * This can't be made into a function...
 */

#ifdef HAVE_LONG_LONG

#define PARSE_INT_FORMAT(res, arg, unsig) \
if (long_long_flag) \
     res = (unsig long long)va_arg(arg, unsig long long); \
else if (long_flag) \
     res = (unsig long)va_arg(arg, unsig long); \
else if (size_t_flag) \
     res = (unsig long)va_arg(arg, size_t); \
else if (short_flag) \
     res = (unsig short)va_arg(arg, unsig int); \
else \
     res = (unsig int)va_arg(arg, unsig int)

#else

#define PARSE_INT_FORMAT(res, arg, unsig) \
if (long_flag) \
     res = (unsig long)va_arg(arg, unsig long); \
else if (size_t_flag) \
     res = (unsig long)va_arg(arg, size_t); \
else if (short_flag) \
     res = (unsig short)va_arg(arg, unsig int); \
else \
     res = (unsig int)va_arg(arg, unsig int)

#endif

/*
 * zyxprintf - return length, as snprintf
 */

static size_t
xyzprintf (struct snprintf_state *state, const char *char_format, va_list ap)
{
    const unsigned char *format = (const unsigned char *)char_format;
    unsigned char c;
    size_t len = 0;

    while((c = *format++)) {
	if (c == '%') {
	    int flags          = 0;
	    int width          = 0;
	    int prec           = -1;
	    int size_t_flag    = 0;
	    int long_long_flag = 0;
	    int long_flag      = 0;
	    int short_flag     = 0;

	    /* flags */
	    while((c = *format++)){
		if(c == '-')
		    flags |= minus_flag;
		else if(c == '+')
		    flags |= plus_flag;
		else if(c == ' ')
		    flags |= space_flag;
		else if(c == '#')
		    flags |= alternate_flag;
		else if(c == '0')
		    flags |= zero_flag;
		else if(c == '\'')
		    ; /* just ignore */
		else
		    break;
	    }

	    if((flags & space_flag) && (flags & plus_flag))
		flags ^= space_flag;

	    if((flags & minus_flag) && (flags & zero_flag))
		flags ^= zero_flag;

	    /* width */
	    if (isdigit(c))
		do {
		    width = width * 10 + c - '0';
		    c = *format++;
		} while(isdigit(c));
	    else if(c == '*') {
		width = va_arg(ap, int);
		c = *format++;
	    }

	    /* precision */
	    if (c == '.') {
		prec = 0;
		c = *format++;
		if (isdigit(c))
		    do {
			prec = prec * 10 + c - '0';
			c = *format++;
		    } while(isdigit(c));
		else if (c == '*') {
		    prec = va_arg(ap, int);
		    c = *format++;
		}
	    }

	    /* size */

	    if (c == 'h') {
		short_flag = 1;
		c = *format++;
	    } else if (c == 'z') {
		size_t_flag = 1;
		c = *format++;
	    } else if (c == 'l') {
		long_flag = 1;
		c = *format++;
		if (c == 'l') {
		    long_long_flag = 1;
		    c = *format++;
		}
	    }

	    if(c != 'd' && c != 'i')
		flags &= ~(plus_flag | space_flag);

	    switch (c) {
	    case 'c' :
		append_char(state, va_arg(ap, int), width, flags);
		++len;
		break;
	    case 's' :
		len += append_string(state,
				     va_arg(ap, unsigned char*),
				     width,
				     prec,
				     flags);
		break;
	    case 'd' :
	    case 'i' : {
		longest arg;
		u_longest num;
		int minusp = 0;

		PARSE_INT_FORMAT(arg, ap, signed);

		if (arg < 0) {
		    minusp = 1;
		    num = -arg;
		} else
		    num = arg;

		len += append_number (state, num, 10, "0123456789",
				      width, prec, flags, minusp);
		break;
	    }
	    case 'u' : {
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 10, "0123456789",
				      width, prec, flags, 0);
		break;
	    }
	    case 'o' : {
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 010, "01234567",
				      width, prec, flags, 0);
		break;
	    }
	    case 'x' : {
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 0x10, "0123456789abcdef",
				      width, prec, flags, 0);
		break;
	    }
	    case 'X' :{
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 0x10, "0123456789ABCDEF",
				      width, prec, flags, 0);
		break;
	    }
	    case 'p' : {
		u_longest arg = (u_longest)va_arg(ap, void*);

		len += append_number (state, arg, 0x10, "0123456789ABCDEF",
				      width, prec, flags, 0);
		break;
	    }
	    case 'n' : {
		int *arg = va_arg(ap, int*);
		*arg = state->s - state->str;
		break;
	    }
	    case '\0' :
		--format;
		/* FALLTHROUGH */
	    case '%' :
		(*state->append_char)(state, c);
		++len;
		break;
	    default :
		(*state->append_char)(state, '%');
		(*state->append_char)(state, c);
		len += 2;
		break;
	    }
	} else {
	    (*state->append_char) (state, c);
	    ++len;
	}
    }
    return len;
}

#if !defined(HAVE_SNPRINTF) || defined(TEST_SNPRINTF)
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_snprintf (char *str, size_t sz, const char *format, ...)
{
    va_list args;
    int ret;

    va_start(args, format);
    ret = vsnprintf (str, sz, format, args);
    va_end(args);

#ifdef PARANOIA
    {
	int ret2;
	char *tmp;

	tmp = malloc (sz);
	if (tmp == NULL)
	    abort ();

	va_start(args, format);
	ret2 = vsprintf (tmp, format, args);
	va_end(args);
	if (ret != ret2 || strcmp(str, tmp))
	    abort ();
	free (tmp);
    }
#endif

    return ret;
}
#endif

#if !defined(HAVE_ASPRINTF) || defined(TEST_SNPRINTF)
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_asprintf (char **ret, const char *format, ...)
{
    va_list args;
    int val;

    va_start(args, format);
    val = vasprintf (ret, format, args);
    va_end(args);

#ifdef PARANOIA
    {
	int ret2;
	char *tmp;
	tmp = malloc (val + 1);
	if (tmp == NULL)
	    abort ();

	va_start(args, format);
	ret2 = vsprintf (tmp, format, args);
	va_end(args);
	if (val != ret2 || strcmp(*ret, tmp))
	    abort ();
	free (tmp);
    }
#endif

    return val;
}
#endif

#if !defined(HAVE_ASNPRINTF) || defined(TEST_SNPRINTF)
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_asnprintf (char **ret, size_t max_sz, const char *format, ...)
{
    va_list args;
    int val;

    va_start(args, format);
    val = vasnprintf (ret, max_sz, format, args);

#ifdef PARANOIA
    {
	int ret2;
	char *tmp;
	tmp = malloc (val + 1);
	if (tmp == NULL)
	    abort ();

	ret2 = vsprintf (tmp, format, args);
	if (val != ret2 || strcmp(*ret, tmp))
	    abort ();
	free (tmp);
    }
#endif

    va_end(args);
    return val;
}
#endif

#if !defined(HAVE_VASPRINTF) || defined(TEST_SNPRINTF)
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_vasprintf (char **ret, const char *format, va_list args)
{
    return vasnprintf (ret, 0, format, args);
}
#endif


#if !defined(HAVE_VASNPRINTF) || defined(TEST_SNPRINTF)
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_vasnprintf (char **ret, size_t max_sz, const char *format, va_list args)
{
    size_t st;
    struct snprintf_state state;

    state.max_sz = max_sz;
    state.sz     = 1;
    state.str    = malloc(state.sz);
    if (state.str == NULL) {
	*ret = NULL;
	return -1;
    }
    state.s = state.str;
    state.theend = state.s + state.sz - 1;
    state.append_char = as_append_char;

    st = xyzprintf (&state, format, args);
    if (st > state.sz) {
	free (state.str);
	*ret = NULL;
	return -1;
    } else {
	char *tmp;

	*state.s = '\0';
	tmp = realloc (state.str, st+1);
	if (tmp == NULL) {
	    free (state.str);
	    *ret = NULL;
	    return -1;
	}
	*ret = tmp;
	return st;
    }
}
#endif

#if !defined(HAVE_VSNPRINTF) || defined(TEST_SNPRINTF)
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_vsnprintf (char *str, size_t sz, const char *format, va_list args)
{
    struct snprintf_state state;
    int ret;
    unsigned char *ustr = (unsigned char *)str;

    state.max_sz = 0;
    state.sz     = sz;
    state.str    = ustr;
    state.s      = ustr;
    state.theend = ustr + sz - (sz > 0);
    state.append_char = sn_append_char;

    ret = xyzprintf (&state, format, args);
    if (state.s != NULL && sz != 0)
	*state.s = '\0';
    return ret;
}
#endif
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.2
log
@fix snprintf abuse and strlcpy abuse, return the string length, which
is at least safe for the pointer arithmatic case
ok cloder@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2000 Kungliga Tekniska Högskolan
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d12 1
a12 1
 * 
d16 1
a16 1
 * 
d20 1
a20 1
 * 
a33 1
#ifdef HAVE_CONFIG_H
a34 2
RCSID("$KTH: snprintf.c,v 1.28 2000/12/15 14:04:42 joda Exp $");
#endif
d40 2
a41 1
#include <roken.h>
d55 8
a62 9
struct state {
  unsigned char *str;
  unsigned char *s;
  unsigned char *theend;
  size_t sz;
  size_t max_sz;
  int (*append_char)(struct state *, unsigned char);
  int (*reserve)(struct state *, size_t);
  /* XXX - methods */
d65 1
a65 1
#ifndef HAVE_VSNPRINTF
d67 1
a67 1
sn_reserve (struct state *state, size_t n)
d69 1
a69 1
  return state->s + n > state->theend;
d72 8
d81 1
a81 1
sn_append_char (struct state *state, unsigned char c)
d83 17
a99 4
  if (sn_reserve (state, 1)) {
    return 1;
  } else {
    *state->s++ = c;
a100 1
  }
d102 16
d120 4
a123 2
static int
as_reserve (struct state *state, size_t n)
d125 6
a130 18
  if (state->s + n > state->theend) {
    int off = state->s - state->str;
    unsigned char *tmp;

    if (state->max_sz && state->sz >= state->max_sz)
      return 1;

    state->sz = max(state->sz * 2, state->sz + n);
    if (state->max_sz)
      state->sz = min(state->sz, state->max_sz);
    tmp = realloc (state->str, state->sz);
    if (tmp == NULL)
      return 1;
    state->str = tmp;
    state->s = state->str + off;
    state->theend = state->str + state->sz - 1;
  }
  return 0;
d133 1
d135 1
a135 1
as_append_char (struct state *state, unsigned char c)
d137 1
a137 6
  if(as_reserve (state, 1))
    return 1;
  else {
    *state->s++ = c;
    return 0;
  }
d141 2
a142 2
append_number(struct state *state,
	      unsigned long num, unsigned base, char *rep,
d145 38
a182 2
  int len = 0;
  int i;
d184 59
a242 76
  /* given precision, ignore zero flag */
  if(prec != -1)
    flags &= ~zero_flag;
  else
    prec = 1;
  /* zero value with zero precision -> "" */
  if(prec == 0 && num == 0)
    return 0;
  do{
    if((*state->append_char)(state, rep[num % base]))
      return 1;
    len++;
    num /= base;
  }while(num);
  prec -= len;
  /* pad with prec zeros */
  while(prec-- > 0){
    if((*state->append_char)(state, '0'))
      return 1;
    len++;
  }
  /* add length of alternate prefix (added later) to len */
  if(flags & alternate_flag && (base == 16 || base == 8))
    len += base / 8;
  /* pad with zeros */
  if(flags & zero_flag){
    width -= len;
    if(minusp || (flags & space_flag) || (flags & plus_flag))
      width--;
    while(width-- > 0){
      if((*state->append_char)(state, '0'))
	return 1;
      len++;
    }
  }
  /* add alternate prefix */
  if(flags & alternate_flag && (base == 16 || base == 8)){
    if(base == 16)
      if((*state->append_char)(state, rep[10] + 23)) /* XXX */
	return 1;
    if((*state->append_char)(state, '0'))
      return 1;
  }
  /* add sign */
  if(minusp){
    if((*state->append_char)(state, '-'))
      return 1;
    len++;
  } else if(flags & plus_flag) {
    if((*state->append_char)(state, '+'))
      return 1;
    len++;
  } else if(flags & space_flag) {
    if((*state->append_char)(state, ' '))
      return 1;
    len++;
  }
  if(flags & minus_flag)
    /* swap before padding with spaces */
    for(i = 0; i < len / 2; i++){
      char c = state->s[-i-1];
      state->s[-i-1] = state->s[-len+i];
      state->s[-len+i] = c;
    }
  width -= len;
  while(width-- > 0){
    if((*state->append_char)(state,  ' '))
      return 1;
    len++;
  }
  if(!(flags & minus_flag))
    /* swap after padding with spaces */
    for(i = 0; i < len / 2; i++){
      char c = state->s[-i-1];
      state->s[-i-1] = state->s[-len+i];
      state->s[-len+i] = c;
d244 5
a248 2
    
  return 0;
d251 7
a257 3
static int
append_string (struct state *state,
	       unsigned char *arg,
d262 2
d265 1
a265 1
	arg = (unsigned char*)"(null)";
d270 1
a270 1
	width -= strlen((char *)arg);
d272 2
a273 3
	while(width-- > 0)
	    if((*state->append_char) (state, ' '))
		return 1;
d275 4
a278 3
	while (*arg && prec--)
	    if ((*state->append_char) (state, *arg++))
		return 1;
d280 4
a283 3
	while (*arg)
	    if ((*state->append_char) (state, *arg++))
		return 1;
d286 2
a287 4
	while(width-- > 0)
	    if((*state->append_char) (state, ' '))
		return 1;
    return 0;
d291 1
a291 1
append_char(struct state *state,
d296 13
a308 11
  while(!(flags & minus_flag) && --width > 0)
    if((*state->append_char) (state, ' '))
      return 1;
    
  if((*state->append_char) (state, arg))
    return 1;
  while((flags & minus_flag) && --width > 0)
    if((*state->append_char) (state, ' '))
      return 1;
    
  return 0;
d315 16
d334 2
d341 2
d344 1
a344 1
 * zyxprintf - return 0 or -1
d347 2
a348 2
static int
xyzprintf (struct state *state, const char *char_format, va_list ap)
d350 182
a531 2
  const unsigned char *format = (const unsigned char *)char_format;
  unsigned char c;
d533 10
a542 55
  while((c = *format++)) {
    if (c == '%') {
      int flags      = 0;
      int width      = 0;
      int prec       = -1;
      int long_flag  = 0;
      int short_flag = 0;

      /* flags */
      while((c = *format++)){
	if(c == '-')
	  flags |= minus_flag;
	else if(c == '+')
	  flags |= plus_flag;
	else if(c == ' ')
	  flags |= space_flag;
	else if(c == '#')
	  flags |= alternate_flag;
	else if(c == '0')
	  flags |= zero_flag;
	else
	  break;
      }
      
      if((flags & space_flag) && (flags & plus_flag))
	flags ^= space_flag;

      if((flags & minus_flag) && (flags & zero_flag))
	flags ^= zero_flag;

      /* width */
      if (isdigit(c))
	do {
	  width = width * 10 + c - '0';
	  c = *format++;
	} while(isdigit(c));
      else if(c == '*') {
	width = va_arg(ap, int);
	c = *format++;
      }

      /* precision */
      if (c == '.') {
	prec = 0;
	c = *format++;
	if (isdigit(c))
	  do {
	    prec = prec * 10 + c - '0';
	    c = *format++;
	  } while(isdigit(c));
	else if (c == '*') {
	  prec = va_arg(ap, int);
	  c = *format++;
	}
      }
d544 17
a560 1
      /* size */
d562 1
a562 111
      if (c == 'h') {
	short_flag = 1;
	c = *format++;
      } else if (c == 'l') {
	long_flag = 1;
	c = *format++;
      }

      switch (c) {
      case 'c' :
	if(append_char(state, va_arg(ap, int), width, flags))
	  return -1;
	break;
      case 's' :
	if (append_string(state,
			  va_arg(ap, unsigned char*),
			  width,
			  prec, 
			  flags))
	  return -1;
	break;
      case 'd' :
      case 'i' : {
	long arg;
	unsigned long num;
	int minusp = 0;

	PARSE_INT_FORMAT(arg, ap, signed);

	if (arg < 0) {
	  minusp = 1;
	  num = -arg;
	} else
	  num = arg;

	if (append_number (state, num, 10, "0123456789",
			   width, prec, flags, minusp))
	  return -1;
	break;
      }
      case 'u' : {
	unsigned long arg;

	PARSE_INT_FORMAT(arg, ap, unsigned);

	if (append_number (state, arg, 10, "0123456789",
			   width, prec, flags, 0))
	  return -1;
	break;
      }
      case 'o' : {
	unsigned long arg;

	PARSE_INT_FORMAT(arg, ap, unsigned);

	if (append_number (state, arg, 010, "01234567",
			   width, prec, flags, 0))
	  return -1;
	break;
      }
      case 'x' : {
	unsigned long arg;

	PARSE_INT_FORMAT(arg, ap, unsigned);

	if (append_number (state, arg, 0x10, "0123456789abcdef",
			   width, prec, flags, 0))
	  return -1;
	break;
      }
      case 'X' :{
	unsigned long arg;

	PARSE_INT_FORMAT(arg, ap, unsigned);

	if (append_number (state, arg, 0x10, "0123456789ABCDEF",
			   width, prec, flags, 0))
	  return -1;
	break;
      }
      case 'p' : {
	unsigned long arg = (unsigned long)va_arg(ap, void*);

	if (append_number (state, arg, 0x10, "0123456789ABCDEF",
			   width, prec, flags, 0))
	  return -1;
	break;
      }
      case 'n' : {
	int *arg = va_arg(ap, int*);
	*arg = state->s - state->str;
	break;
      }
      case '\0' :
	  --format;
	  /* FALLTHROUGH */
      case '%' :
	if ((*state->append_char)(state, c))
	  return -1;
	break;
      default :
	if (   (*state->append_char)(state, '%')
	    || (*state->append_char)(state, c))
	  return -1;
	break;
      }
    } else
      if ((*state->append_char) (state, c))
	return -1;
  }
  return 0;
d564 1
d566 3
a568 3
#ifndef HAVE_SNPRINTF
int
snprintf (char *str, size_t sz, const char *format, ...)
d570 2
a571 2
  va_list args;
  int ret;
d573 3
a575 2
  va_start(args, format);
  ret = vsnprintf (str, sz, format, args);
d578 14
a591 13
  {
    int ret2;
    char *tmp;

    tmp = malloc (sz);
    if (tmp == NULL)
      abort ();

    ret2 = vsprintf (tmp, format, args);
    if (ret != ret2 || strcmp(str, tmp))
      abort ();
    free (tmp);
  }
d594 1
a594 2
  va_end(args);
  return ret;
d598 3
a600 3
#ifndef HAVE_ASPRINTF
int
asprintf (char **ret, const char *format, ...)
d602 2
a603 2
  va_list args;
  int val;
d605 2
a606 2
  va_start(args, format);
  val = vasprintf (ret, format, args);
d609 13
a621 6
  {
    int ret2;
    char *tmp;
    tmp = malloc (val + 1);
    if (tmp == NULL)
      abort ();
d623 3
a625 5
    ret2 = vsprintf (tmp, format, args);
    if (val != ret2 || strcmp(*ret, tmp))
      abort ();
    free (tmp);
  }
d628 5
a632 2
  va_end(args);
  return val;
d636 4
a639 3
#ifndef HAVE_ASNPRINTF
int
asnprintf (char **ret, size_t max_sz, const char *format, ...)
d641 2
a642 2
  va_list args;
  int val;
d644 18
a661 2
  va_start(args, format);
  val = vasnprintf (ret, max_sz, format, args);
d663 9
a671 64
#ifdef PARANOIA
  {
    int ret2;
    char *tmp;
    tmp = malloc (val + 1);
    if (tmp == NULL)
      abort ();

    ret2 = vsprintf (tmp, format, args);
    if (val != ret2 || strcmp(*ret, tmp))
      abort ();
    free (tmp);
  }
#endif

  va_end(args);
  return val;
}
#endif

#ifndef HAVE_VASPRINTF
int
vasprintf (char **ret, const char *format, va_list args)
{
  return vasnprintf (ret, 0, format, args);
}
#endif


#ifndef HAVE_VASNPRINTF
int
vasnprintf (char **ret, size_t max_sz, const char *format, va_list args)
{
  int st;
  size_t len;
  struct state state;

  state.max_sz = max_sz;
  state.sz     = 1;
  state.str    = malloc(state.sz);
  if (state.str == NULL) {
    *ret = NULL;
    return -1;
  }
  state.s = state.str;
  state.theend = state.s + state.sz - 1;
  state.append_char = as_append_char;
  state.reserve     = as_reserve;

  st = xyzprintf (&state, format, args);
  if (st) {
    free (state.str);
    *ret = NULL;
    return -1;
  } else {
    char *tmp;

    *state.s = '\0';
    len = state.s - state.str;
    tmp = realloc (state.str, len+1);
    if (tmp == NULL) {
      free (state.str);
      *ret = NULL;
      return -1;
a672 3
    *ret = tmp;
    return len;
  }
d676 19
a694 22
#ifndef HAVE_VSNPRINTF
int
vsnprintf (char *str, size_t sz, const char *format, va_list args)
{
  struct state state;
  int ret;
  unsigned char *ustr = (unsigned char *)str;

  state.max_sz = 0;
  state.sz     = sz;
  state.str    = ustr;
  state.s      = ustr;
  state.theend = ustr + sz - 1;
  state.append_char = sn_append_char;
  state.reserve     = sn_reserve;

  ret = xyzprintf (&state, format, args);
  *state.s = '\0';
  if (ret)
    return sz;
  else
    return state.s - state.str;
a696 1

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: snprintf.c,v 1.31 2001/07/17 15:27:00 assar Exp $");
d63 2
a64 1
  void (*append_char)(struct state *, unsigned char);
d68 1
a68 5
#if TEST_SNPRINTF
#include "snprintf-test.h"
#endif /* TEST_SNPRINTF */

#if !defined(HAVE_VSNPRINTF) || defined(TEST_SNPRINTF)
d75 1
a75 1
static void
d78 3
a80 1
  if (!sn_reserve (state, 1))
d82 2
d110 1
a110 1
static void
d113 3
a115 1
  if(!as_reserve (state, 1))
d117 2
a118 20
}

/* longest integer types */

#ifdef HAVE_LONG_LONG
typedef unsigned long long u_longest;
typedef long long longest;
#else
typedef unsigned long u_longest;
typedef long longest;
#endif

/*
 * is # supposed to do anything?
 */

static int
use_alternative (int flags, u_longest num, unsigned base)
{
  return flags & alternate_flag && (base == 16 || base == 8) && num != 0;
d123 1
a123 1
	      u_longest num, unsigned base, char *rep,
a127 1
  u_longest n = num;
d135 1
a135 1
  if(prec == 0 && n == 0)
d138 5
a142 4
    (*state->append_char)(state, rep[n % base]);
    ++len;
    n /= base;
  } while(n);
d146 3
a148 2
    (*state->append_char)(state, '0');
    ++len;
d151 1
a151 1
  if(use_alternative(flags, num, base))
d159 2
a160 1
      (*state->append_char)(state, '0');
d165 1
a165 1
  if(use_alternative(flags, num, base)){
d167 4
a170 2
      (*state->append_char)(state, rep[10] + 23); /* XXX */
    (*state->append_char)(state, '0');
d174 3
a176 2
    (*state->append_char)(state, '-');
    ++len;
d178 3
a180 2
    (*state->append_char)(state, '+');
    ++len;
d182 3
a184 2
    (*state->append_char)(state, ' ');
    ++len;
d195 3
a197 2
    (*state->append_char)(state,  ' ');
    ++len;
d206 2
a207 1
  return len;
a209 4
/*
 * return length
 */

d212 1
a212 1
	       const unsigned char *arg,
a216 2
    int len = 0;

d218 1
a218 1
	arg = (const unsigned char*)"(null)";
d223 1
a223 1
	width -= strlen((const char *)arg);
d225 3
a227 4
	while(width-- > 0) {
	    (*state->append_char) (state, ' ');
	    ++len;
	}
d229 3
a231 4
	while (*arg && prec--) {
	    (*state->append_char) (state, *arg++);
	    ++len;
	}
d233 3
a235 4
	while (*arg) {
	    (*state->append_char) (state, *arg++);
	    ++len;
	}
d238 4
a241 5
	while(width-- > 0) {
	    (*state->append_char) (state, ' ');
	    ++len;
	}
    return len;
d250 10
a259 12
  int len = 0;

  while(!(flags & minus_flag) && --width > 0) {
    (*state->append_char) (state, ' ')    ;
    ++len;
  }
  (*state->append_char) (state, arg);
  ++len;
  while((flags & minus_flag) && --width > 0) {
    (*state->append_char) (state, ' ');
    ++len;
  }
a266 14
#ifdef HAVE_LONG_LONG

#define PARSE_INT_FORMAT(res, arg, unsig) \
if (long_long_flag) \
     res = (unsig long long)va_arg(arg, unsig long long); \
else if (long_flag) \
     res = (unsig long)va_arg(arg, unsig long); \
else if (short_flag) \
     res = (unsig short)va_arg(arg, unsig int); \
else \
     res = (unsig int)va_arg(arg, unsig int)

#else

a274 2
#endif

d276 1
a276 1
 * zyxprintf - return length, as snprintf
a283 1
  int len = 0;
d287 5
a291 6
      int flags          = 0;
      int width          = 0;
      int prec           = -1;
      int long_long_flag = 0;
      int long_flag      = 0;
      int short_flag     = 0;
a348 4
	if (c == 'l') {
	    long_long_flag = 1;
	    c = *format++;
	}
d353 2
a354 2
	append_char(state, va_arg(ap, int), width, flags);
	++len;
d357 6
a362 5
	len += append_string(state,
			     va_arg(ap, unsigned char*),
			     width,
			     prec, 
			     flags);
d366 2
a367 2
	longest arg;
	u_longest num;
d378 3
a380 2
	len += append_number (state, num, 10, "0123456789",
			      width, prec, flags, minusp);
d384 1
a384 1
	u_longest arg;
d388 3
a390 2
	len += append_number (state, arg, 10, "0123456789",
			      width, prec, flags, 0);
d394 1
a394 1
	u_longest arg;
d398 3
a400 2
	len += append_number (state, arg, 010, "01234567",
			      width, prec, flags, 0);
d404 1
a404 1
	u_longest arg;
d408 3
a410 2
	len += append_number (state, arg, 0x10, "0123456789abcdef",
			      width, prec, flags, 0);
d414 1
a414 1
	u_longest arg;
d418 3
a420 2
	len += append_number (state, arg, 0x10, "0123456789ABCDEF",
			      width, prec, flags, 0);
d426 3
a428 2
	len += append_number (state, arg, 0x10, "0123456789ABCDEF",
			      width, prec, flags, 0);
d440 2
a441 2
	(*state->append_char)(state, c);
	++len;
d444 3
a446 3
	(*state->append_char)(state, '%');
	(*state->append_char)(state, c);
	len += 2;
d449 3
a451 4
    } else {
      (*state->append_char) (state, c);
      ++len;
    }
d453 1
a453 1
  return len;
d456 1
a456 1
#if !defined(HAVE_SNPRINTF) || defined(TEST_SNPRINTF)
d487 1
a487 1
#if !defined(HAVE_ASPRINTF) || defined(TEST_SNPRINTF)
d517 1
a517 1
#if !defined(HAVE_ASNPRINTF) || defined(TEST_SNPRINTF)
d547 1
a547 1
#if !defined(HAVE_VASPRINTF) || defined(TEST_SNPRINTF)
d556 1
a556 1
#if !defined(HAVE_VASNPRINTF) || defined(TEST_SNPRINTF)
d561 1
d574 1
d577 1
a577 1
  if (st > state.sz) {
d585 2
a586 1
    tmp = realloc (state.str, st+1);
d593 1
a593 1
    return st;
d598 1
a598 1
#if !defined(HAVE_VSNPRINTF) || defined(TEST_SNPRINTF)
d610 1
a610 1
  state.theend = ustr + sz - (sz > 0);
d612 1
d615 5
a619 3
  if (state.s != NULL)
    *state.s = '\0';
  return ret;
d622 1
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: snprintf.c,v 1.35 2003/03/26 10:05:48 joda Exp $");
d57 1
a57 1
struct snprintf_state {
d63 1
a63 1
  void (*append_char)(struct snprintf_state *, unsigned char);
d73 1
a73 1
sn_reserve (struct snprintf_state *state, size_t n)
d79 1
a79 1
sn_append_char (struct snprintf_state *state, unsigned char c)
d87 1
a87 1
as_reserve (struct snprintf_state *state, size_t n)
d110 1
a110 1
as_append_char (struct snprintf_state *state, unsigned char c)
d137 2
a138 2
append_number(struct snprintf_state *state,
	      u_longest num, unsigned base, const char *rep,
d221 1
a221 1
append_string (struct snprintf_state *state,
d261 1
a261 1
append_char(struct snprintf_state *state,
d314 1
a314 1
xyzprintf (struct snprintf_state *state, const char *char_format, va_list ap)
a340 2
	else if(c == '\'')
	    ; /* just ignore */
a498 1
  va_end(args);
a508 1
    va_start(args, format);
a509 1
    va_end(args);
d516 1
a529 1
  va_end(args);
a538 1
    va_start(args, format);
a539 1
    va_end(args);
d546 1
d595 1
a595 1
  struct snprintf_state state;
d633 1
a633 1
  struct snprintf_state state;
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: snprintf.c,v 1.40 2005/05/03 16:49:34 lha Exp $");
a37 3
#if defined(TEST_SNPRINTF)
#include "snprintf-test.h"
#endif /* TEST_SNPRINTF */
a43 1
#include <assert.h>
d58 7
a64 7
    unsigned char *str;
    unsigned char *s;
    unsigned char *theend;
    size_t sz;
    size_t max_sz;
    void (*append_char)(struct snprintf_state *, unsigned char);
    /* XXX - methods */
d67 4
d75 1
a75 1
    return state->s + n > state->theend;
d81 2
a82 2
    if (!sn_reserve (state, 1))
	*state->s++ = c;
d89 18
a106 18
    if (state->s + n > state->theend) {
	int off = state->s - state->str;
	unsigned char *tmp;

	if (state->max_sz && state->sz >= state->max_sz)
	    return 1;

	state->sz = max(state->sz * 2, state->sz + n);
	if (state->max_sz)
	    state->sz = min(state->sz, state->max_sz);
	tmp = realloc (state->str, state->sz);
	if (tmp == NULL)
	    return 1;
	state->str = tmp;
	state->s = state->str + off;
	state->theend = state->str + state->sz - 1;
    }
    return 0;
d112 2
a113 2
    if(!as_reserve (state, 1))
	*state->s++ = c;
d126 3
a128 1

a130 12
pad(struct snprintf_state *state, int width, char c)
{
    int len = 0;
    while(width-- > 0){
	(*state->append_char)(state,  c);
	++len;
    }
    return len;
}

/* return true if we should use alternatve hex form */
static int
d133 1
a133 1
    return (flags & alternate_flag) && base == 16 && num != 0;
d141 34
a174 27
    int len = 0;
    u_longest n = num;
    char nstr[64]; /* enough for <192 bit octal integers */
    int nstart, nlen;
    char signchar;

    /* given precision, ignore zero flag */
    if(prec != -1)
	flags &= ~zero_flag;
    else
	prec = 1;

    /* format number as string */
    nstart = sizeof(nstr);
    nlen = 0;
    nstr[--nstart] = '\0';
    do {
	assert(nstart > 0);
	nstr[--nstart] = rep[n % base];
	++nlen;
	n /= base;
    } while(n);

    /* zero value with zero precision should produce no digits */
    if(prec == 0 && num == 0) {
	nlen--;
	nstart++;
d176 36
a211 23

    /* figure out what char to use for sign */
    if(minusp)
	signchar = '-';
    else if((flags & plus_flag))
	signchar = '+';
    else if((flags & space_flag))
	signchar = ' ';
    else
	signchar = '\0';
    
    if((flags & alternate_flag) && base == 8) {
	/* if necessary, increase the precision to 
	   make first digit a zero */

	/* XXX C99 claims (regarding # and %o) that "if the value and
           precision are both 0, a single 0 is printed", but there is
           no such wording for %x. This would mean that %#.o would
           output "0", but %#.x "". This does not make sense, and is
           also not what other printf implementations are doing. */
	
	if(prec <= nlen && nstr[nstart] != '0' && nstr[nstart] != '\0')
	    prec = nlen + 1;
d213 1
a213 52

    /* possible formats:
       pad | sign | alt | zero | digits
       sign | alt | zero | digits | pad   minus_flag
       sign | alt | zero | digits zero_flag */

    /* if not right justifying or padding with zeros, we need to
       compute the length of the rest of the string, and then pad with
       spaces */
    if(!(flags & (minus_flag | zero_flag))) {
	if(prec > nlen)
	    width -= prec;
	else
	    width -= nlen;
	
	if(use_alternative(flags, num, base))
	    width -= 2;
	
	if(signchar != '\0')
	    width--;
	
	/* pad to width */
	len += pad(state, width, ' ');
    }
    if(signchar != '\0') {
	(*state->append_char)(state, signchar);
	++len;
    }
    if(use_alternative(flags, num, base)) {
	(*state->append_char)(state, '0');
	(*state->append_char)(state, rep[10] + 23); /* XXX */
	len += 2;
    }
    if(flags & zero_flag) {
	/* pad to width with zeros */
	if(prec - nlen > width - len - nlen)
	    len += pad(state, prec - nlen, '0');
	else
	    len += pad(state, width - len - nlen, '0');
    } else
	/* pad to prec with zeros */
	len += pad(state, prec - nlen, '0');
	
    while(nstr[nstart] != '\0') {
	(*state->append_char)(state, nstr[nstart++]);
	++len;
    }
	
    if(flags & minus_flag)
	len += pad(state, width - len, ' ');

    return len;
d237 4
a240 2
	len += pad(state, width, ' ');

d253 4
a256 1
	len += pad(state, width, ' ');
d266 1
a266 1
    int len = 0;
d268 8
a275 5
    while(!(flags & minus_flag) && --width > 0) {
	(*state->append_char) (state, ' ')    ;
	++len;
    }
    (*state->append_char) (state, arg);
d277 2
a278 5
    while((flags & minus_flag) && --width > 0) {
	(*state->append_char) (state, ' ');
	++len;
    }
    return 0;
d316 36
a351 3
    const unsigned char *format = (const unsigned char *)char_format;
    unsigned char c;
    int len = 0;
d353 25
a377 29
    while((c = *format++)) {
	if (c == '%') {
	    int flags          = 0;
	    int width          = 0;
	    int prec           = -1;
	    int long_long_flag = 0;
	    int long_flag      = 0;
	    int short_flag     = 0;

	    /* flags */
	    while((c = *format++)){
		if(c == '-')
		    flags |= minus_flag;
		else if(c == '+')
		    flags |= plus_flag;
		else if(c == ' ')
		    flags |= space_flag;
		else if(c == '#')
		    flags |= alternate_flag;
		else if(c == '0')
		    flags |= zero_flag;
		else if(c == '\'')
		    ; /* just ignore */
		else
		    break;
	    }
      
	    if((flags & space_flag) && (flags & plus_flag))
		flags ^= space_flag;
d379 1
a379 2
	    if((flags & minus_flag) && (flags & zero_flag))
		flags ^= zero_flag;
d381 9
a389 137
	    /* width */
	    if (isdigit(c))
		do {
		    width = width * 10 + c - '0';
		    c = *format++;
		} while(isdigit(c));
	    else if(c == '*') {
		width = va_arg(ap, int);
		c = *format++;
	    }

	    /* precision */
	    if (c == '.') {
		prec = 0;
		c = *format++;
		if (isdigit(c))
		    do {
			prec = prec * 10 + c - '0';
			c = *format++;
		    } while(isdigit(c));
		else if (c == '*') {
		    prec = va_arg(ap, int);
		    c = *format++;
		}
	    }

	    /* size */

	    if (c == 'h') {
		short_flag = 1;
		c = *format++;
	    } else if (c == 'l') {
		long_flag = 1;
		c = *format++;
		if (c == 'l') {
		    long_long_flag = 1;
		    c = *format++;
		}
	    }

	    if(c != 'd' && c != 'i')
		flags &= ~(plus_flag | space_flag);

	    switch (c) {
	    case 'c' :
		append_char(state, va_arg(ap, int), width, flags);
		++len;
		break;
	    case 's' :
		len += append_string(state,
				     va_arg(ap, unsigned char*),
				     width,
				     prec, 
				     flags);
		break;
	    case 'd' :
	    case 'i' : {
		longest arg;
		u_longest num;
		int minusp = 0;

		PARSE_INT_FORMAT(arg, ap, signed);

		if (arg < 0) {
		    minusp = 1;
		    num = -arg;
		} else
		    num = arg;

		len += append_number (state, num, 10, "0123456789",
				      width, prec, flags, minusp);
		break;
	    }
	    case 'u' : {
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 10, "0123456789",
				      width, prec, flags, 0);
		break;
	    }
	    case 'o' : {
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 010, "01234567",
				      width, prec, flags, 0);
		break;
	    }
	    case 'x' : {
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 0x10, "0123456789abcdef",
				      width, prec, flags, 0);
		break;
	    }
	    case 'X' :{
		u_longest arg;

		PARSE_INT_FORMAT(arg, ap, unsigned);

		len += append_number (state, arg, 0x10, "0123456789ABCDEF",
				      width, prec, flags, 0);
		break;
	    }
	    case 'p' : {
		unsigned long arg = (unsigned long)va_arg(ap, void*);

		len += append_number (state, arg, 0x10, "0123456789ABCDEF",
				      width, prec, flags, 0);
		break;
	    }
	    case 'n' : {
		int *arg = va_arg(ap, int*);
		*arg = state->s - state->str;
		break;
	    }
	    case '\0' :
		--format;
		/* FALLTHROUGH */
	    case '%' :
		(*state->append_char)(state, c);
		++len;
		break;
	    default :
		(*state->append_char)(state, '%');
		(*state->append_char)(state, c);
		len += 2;
		break;
	    }
	} else {
	    (*state->append_char) (state, c);
	    ++len;
d391 96
d488 2
a489 1
    return len;
d493 1
a493 1
int ROKEN_LIB_FUNCTION
d496 15
a510 2
    va_list args;
    int ret;
d513 1
a513 1
    ret = vsnprintf (str, sz, format, args);
d515 4
a518 17

#ifdef PARANOIA
    {
	int ret2;
	char *tmp;

	tmp = malloc (sz);
	if (tmp == NULL)
	    abort ();

	va_start(args, format);
	ret2 = vsprintf (tmp, format, args);
	va_end(args);
	if (ret != ret2 || strcmp(str, tmp))
	    abort ();
	free (tmp);
    }
d521 1
a521 1
    return ret;
d526 1
a526 1
int ROKEN_LIB_FUNCTION
d529 14
a542 2
    va_list args;
    int val;
d545 1
a545 1
    val = vasprintf (ret, format, args);
d547 4
a550 16

#ifdef PARANOIA
    {
	int ret2;
	char *tmp;
	tmp = malloc (val + 1);
	if (tmp == NULL)
	    abort ();

	va_start(args, format);
	ret2 = vsprintf (tmp, format, args);
	va_end(args);
	if (val != ret2 || strcmp(*ret, tmp))
	    abort ();
	free (tmp);
    }
d553 1
a553 1
    return val;
d558 1
a558 1
int ROKEN_LIB_FUNCTION
d561 2
a562 2
    va_list args;
    int val;
d564 2
a565 2
    va_start(args, format);
    val = vasnprintf (ret, max_sz, format, args);
d568 12
a579 12
    {
	int ret2;
	char *tmp;
	tmp = malloc (val + 1);
	if (tmp == NULL)
	    abort ();

	ret2 = vsprintf (tmp, format, args);
	if (val != ret2 || strcmp(*ret, tmp))
	    abort ();
	free (tmp);
    }
d582 2
a583 2
    va_end(args);
    return val;
d588 1
a588 1
int ROKEN_LIB_FUNCTION
d591 1
a591 1
    return vasnprintf (ret, 0, format, args);
d597 1
a597 1
int ROKEN_LIB_FUNCTION
d600 2
a601 2
    int st;
    struct snprintf_state state;
d603 29
a631 29
    state.max_sz = max_sz;
    state.sz     = 1;
    state.str    = malloc(state.sz);
    if (state.str == NULL) {
	*ret = NULL;
	return -1;
    }
    state.s = state.str;
    state.theend = state.s + state.sz - 1;
    state.append_char = as_append_char;

    st = xyzprintf (&state, format, args);
    if (st > state.sz) {
	free (state.str);
	*ret = NULL;
	return -1;
    } else {
	char *tmp;

	*state.s = '\0';
	tmp = realloc (state.str, st+1);
	if (tmp == NULL) {
	    free (state.str);
	    *ret = NULL;
	    return -1;
	}
	*ret = tmp;
	return st;
    }
d636 1
a636 1
int ROKEN_LIB_FUNCTION
d639 15
a653 15
    struct snprintf_state state;
    int ret;
    unsigned char *ustr = (unsigned char *)str;

    state.max_sz = 0;
    state.sz     = sz;
    state.str    = ustr;
    state.s      = ustr;
    state.theend = ustr + sz - (sz > 0);
    state.append_char = sn_append_char;

    ret = xyzprintf (&state, format, args);
    if (state.s != NULL && sz != 0)
	*state.s = '\0';
    return ret;
@


