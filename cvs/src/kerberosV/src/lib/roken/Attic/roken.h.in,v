head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.5.0.28
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.26
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.24
	OPENBSD_5_0:1.1.1.5.0.22
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.20
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.18
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.14
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.12
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.10
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.8
	OPENBSD_3_7_BASE:1.1.1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.6
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2014.04.22.10.01.33;	author reyk;	state dead;
branches;
next	1.2;

1.2
date	2013.06.17.18.57.45;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.18;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.18;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.25.26;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.51;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.16.08;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.43;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.3
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/* -*- C -*- */
/*
 * Copyright (c) 1995-2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#include <string.h>
#include <signal.h>

#ifndef ROKEN_LIB_FUNCTION
#ifdef _WIN32
#  define ROKEN_LIB_CALL     __cdecl
#  ifdef ROKEN_LIB_DYNAMIC
#    define ROKEN_LIB_FUNCTION __declspec(dllimport)
#    define ROKEN_LIB_VARIABLE __declspec(dllimport)
#  else
#    define ROKEN_LIB_FUNCTION
#    define ROKEN_LIB_VARIABLE
#  endif
#else
#define ROKEN_LIB_FUNCTION
#define ROKEN_LIB_CALL
#define ROKEN_LIB_VARIABLE
#endif
#endif

#ifdef HAVE_WINSOCK
/* Declarations for Microsoft Windows */

#include <winsock2.h>
#include <ws2tcpip.h>

/*
 * error codes for inet_ntop/inet_pton 
 */
#define EAFNOSUPPORT WSAEAFNOSUPPORT

typedef SOCKET rk_socket_t;

#define rk_closesocket(x) closesocket(x)
#define rk_INVALID_SOCKET INVALID_SOCKET
#define rk_IS_BAD_SOCKET(s) ((s) == INVALID_SOCKET)
#define rk_IS_SOCKET_ERROR(rv) ((rv) == SOCKET_ERROR)
#define rk_SOCK_ERRNO WSAGetLastError()

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL rk_SOCK_IOCTL(SOCKET s, long cmd, int * argp);

/* Microsoft VC 2010 POSIX definitions */
#ifndef ENOTSOCK
#define ENOTSOCK		128
#endif
#ifndef ENOTSUP
#define ENOTSUP                 129
#endif
#ifndef EOVERFLOW
#define EOVERFLOW               132
#endif
#ifndef ETIMEDOUT
#define ETIMEDOUT               138
#endif
#ifndef EWOULDBLOCK
#define EWOULDBLOCK             140
#endif

#define rk_SOCK_INIT() rk_WSAStartup()
#define rk_SOCK_EXIT() rk_WSACleanup()

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL rk_WSAStartup(void);
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL rk_WSACleanup(void);

#else  /* not WinSock */

typedef int rk_socket_t;

#define rk_closesocket(x) close(x)
#define rk_SOCK_IOCTL(s,c,a) ioctl((s),(c),(a))
#define rk_IS_BAD_SOCKET(s) ((s) < 0)
#define rk_IS_SOCKET_ERROR(rv) ((rv) < 0)
#define rk_SOCK_ERRNO errno
#define rk_INVALID_SOCKET (-1)

#define rk_SOCK_INIT() 0
#define rk_SOCK_EXIT() do { } while(0)

#endif

#ifndef IN_LOOPBACKNET
#define IN_LOOPBACKNET 127
#endif

#ifdef _MSC_VER
/* Declarations for Microsoft Visual C runtime on Windows */

#include<process.h>

#include<io.h>

#ifndef __BIT_TYPES_DEFINED__
#define __BIT_TYPES_DEFINED__

typedef __int8             int8_t;
typedef __int16            int16_t;
typedef __int32            int32_t;
typedef __int64            int64_t;
typedef unsigned __int8    uint8_t;
typedef unsigned __int16   uint16_t;
typedef unsigned __int32   uint32_t;
typedef unsigned __int64   uint64_t;
typedef uint8_t            u_int8_t;
typedef uint16_t           u_int16_t;
typedef uint32_t           u_int32_t;
typedef uint64_t           u_int64_t;

#endif  /* __BIT_TYPES_DEFINED__ */

#define UNREACHABLE(x) x
#define UNUSED_ARGUMENT(x) ((void) x)

#define RETSIGTYPE void

#define VOID_RETSIGTYPE 1

#ifdef VOID_RETSIGTYPE
#define SIGRETURN(x) return
#else
#define SIGRETURN(x) return (RETSIGTYPE)(x)
#endif

#ifndef CPP_ONLY

typedef int pid_t;

typedef unsigned int gid_t;

typedef unsigned int uid_t;

typedef unsigned short mode_t;

#endif

#ifndef __cplusplus
#define inline __inline
#endif

#else

#define UNREACHABLE(x)
#define UNUSED_ARGUMENT(x)

#endif

#ifdef _AIX
struct ether_addr;
struct sockaddr_dl;
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_BITYPES_H
#include <sys/bitypes.h>
#endif
#ifdef HAVE_BIND_BITYPES_H
#include <bind/bitypes.h>
#endif
#ifdef HAVE_NETINET_IN6_MACHTYPES_H
#include <netinet/in6_machtypes.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif
#ifdef HAVE_GRP_H
#include <grp.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
#ifdef HAVE_NETINET_IN6_H
#include <netinet/in6.h>
#endif
#ifdef HAVE_NETINET6_IN6_H
#include <netinet6/in6.h>
#endif
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif
#ifdef HAVE_ARPA_NAMESER_H
#include <arpa/nameser.h>
#endif
#ifdef HAVE_RESOLV_H
#include <resolv.h>
#endif
#ifdef HAVE_SYSLOG_H
#include <syslog.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif
#include <err.h>
#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef TIME_WITH_SYS_TIME
#include <sys/time.h>
#include <time.h>
#elif defined(HAVE_SYS_TIME_H)
#include <sys/time.h>
#else
#include <time.h>
#endif

#ifdef HAVE_PATHS_H
#include <paths.h>
#endif

#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif

#ifdef BACKSLASH_PATH_DELIM
#define rk_PATH_DELIM '\\'
#endif

#ifndef HAVE_SSIZE_T
#ifndef SSIZE_T_DEFINED
#ifdef ssize_t
#undef ssize_t
#endif
#ifdef _WIN64
typedef __int64 ssize_t;
#else
typedef int ssize_t;
#endif
#define SSIZE_T_DEFINED
#endif  /* SSIZE_T_DEFINED */
#endif  /* HAVE_SSIZE_T */

#include <roken-common.h>

ROKEN_CPP_START

#ifdef HAVE_UINTPTR_T
#define rk_UNCONST(x) ((void *)(uintptr_t)(const void *)(x))
#else
#define rk_UNCONST(x) ((void *)(unsigned long)(const void *)(x))
#endif

#if !defined(HAVE_SETSID) && defined(HAVE__SETSID)
#define setsid _setsid
#endif

#ifdef _MSC_VER
/* Additional macros for Visual C/C++ runtime */

#define close	_close

#define getpid	_getpid

#define open	_open

#define chdir   _chdir

#define fsync   _commit

/* The MSVC implementation of snprintf is not C99 compliant.  */
#define snprintf    rk_snprintf
#define vsnprintf   rk_vsnprintf
#define vasnprintf  rk_vasnprintf
#define vasprintf   rk_vasprintf
#define asnprintf   rk_asnprintf
#define asprintf    rk_asprintf

#define _PIPE_BUFFER_SZ 8192
#define pipe(fds) _pipe((fds), _PIPE_BUFFER_SZ, O_BINARY);

#define ftruncate(fd, sz) _chsize((fd), (sz))

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_snprintf (char *str, size_t sz, const char *format, ...);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_asprintf (char **ret, const char *format, ...);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_asnprintf (char **ret, size_t max_sz, const char *format, ...);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_vasprintf (char **ret, const char *format, va_list args);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_vasnprintf (char **ret, size_t max_sz, const char *format, va_list args);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_vsnprintf (char *str, size_t sz, const char *format, va_list args);

/* missing stat.h predicates */

#define S_ISREG(m) (((m) & _S_IFREG) == _S_IFREG)

#define S_ISDIR(m) (((m) & _S_IFDIR) == _S_IFDIR)

#define S_ISCHR(m) (((m) & _S_IFCHR) == _S_IFCHR)

#define S_ISFIFO(m) (((m) & _S_IFIFO) == _S_IFIFO)

/* The following are not implemented:

 S_ISLNK(m)
 S_ISSOCK(m)
 S_ISBLK(m)
*/

#endif  /* _MSC_VER */

#ifdef HAVE_WINSOCK

/* While we are at it, define WinSock specific scatter gather socket
   I/O. */

#define iovec    _WSABUF
#define iov_base buf
#define iov_len  len

struct msghdr {
    void           *msg_name;
    socklen_t       msg_namelen;
    struct iovec   *msg_iov;
    size_t          msg_iovlen;
    void           *msg_control;
    socklen_t       msg_controllen;
    int             msg_flags;
};

#define sendmsg sendmsg_w32

ROKEN_LIB_FUNCTION ssize_t ROKEN_LIB_CALL
sendmsg_w32(rk_socket_t s, const struct msghdr * msg, int flags);

#endif	/* HAVE_WINSOCK */

#ifndef HAVE_PUTENV
#define putenv rk_putenv
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL putenv(const char *);
#endif

#if !defined(HAVE_SETENV) || defined(NEED_SETENV_PROTO)
#ifndef HAVE_SETENV
#define setenv rk_setenv
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL setenv(const char *, const char *, int);
#endif

#if !defined(HAVE_UNSETENV) || defined(NEED_UNSETENV_PROTO)
#ifndef HAVE_UNSETENV
#define unsetenv rk_unsetenv
#endif
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL unsetenv(const char *);
#endif

#if !defined(HAVE_GETUSERSHELL) || defined(NEED_GETUSERSHELL_PROTO)
#ifndef HAVE_GETUSERSHELL
#define getusershell rk_getusershell
#define endusershell rk_endusershell
#endif
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL getusershell(void);
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL endusershell(void);
#endif

#if !defined(HAVE_SNPRINTF) || defined(NEED_SNPRINTF_PROTO)
#ifndef HAVE_SNPRINTF
#define snprintf rk_snprintf
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
     rk_snprintf (char *, size_t, const char *, ...)
     __attribute__ ((format (printf, 3, 4)));
#endif

#if !defined(HAVE_VSNPRINTF) || defined(NEED_VSNPRINTF_PROTO)
#ifndef HAVE_VSNPRINTF
#define vsnprintf rk_vsnprintf
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL 
     rk_vsnprintf (char *, size_t, const char *, va_list)
     __attribute__((format (printf, 3, 0)));
#endif

#if !defined(HAVE_ASPRINTF) || defined(NEED_ASPRINTF_PROTO)
#ifndef HAVE_ASPRINTF
#define asprintf rk_asprintf
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
     rk_asprintf (char **, const char *, ...)
     __attribute__ ((format (printf, 2, 3)));
#endif

#if !defined(HAVE_VASPRINTF) || defined(NEED_VASPRINTF_PROTO)
#ifndef HAVE_VASPRINTF
#define vasprintf rk_vasprintf
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
    rk_vasprintf (char **, const char *, va_list)
     __attribute__((format (printf, 2, 0)));
#endif

#if !defined(HAVE_ASNPRINTF) || defined(NEED_ASNPRINTF_PROTO)
#ifndef HAVE_ASNPRINTF
#define asnprintf rk_asnprintf
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
    rk_asnprintf (char **, size_t, const char *, ...)
     __attribute__ ((format (printf, 3, 4)));
#endif

#if !defined(HAVE_VASNPRINTF) || defined(NEED_VASNPRINTF_PROTO)
#ifndef HAVE_VASNPRINTF
#define vasnprintf rk_vasnprintf
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
    vasnprintf (char **, size_t, const char *, va_list)
     __attribute__((format (printf, 3, 0)));
#endif

#ifndef HAVE_STRDUP
#define strdup rk_strdup
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strdup(const char *);
#endif

#if !defined(HAVE_STRNDUP) || defined(NEED_STRNDUP_PROTO)
#ifndef HAVE_STRNDUP
#define strndup rk_strndup
#endif
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strndup(const char *, size_t);
#endif

#ifndef HAVE_STRLWR
#define strlwr rk_strlwr
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strlwr(char *);
#endif

#ifndef HAVE_STRNLEN
#define strnlen rk_strnlen
ROKEN_LIB_FUNCTION size_t ROKEN_LIB_CALL strnlen(const char*, size_t);
#endif

#if !defined(HAVE_STRSEP) || defined(NEED_STRSEP_PROTO)
#ifndef HAVE_STRSEP
#define strsep rk_strsep
#endif
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strsep(char**, const char*);
#endif

#if !defined(HAVE_STRSEP_COPY) || defined(NEED_STRSEP_COPY_PROTO)
#ifndef HAVE_STRSEP_COPY
#define strsep_copy rk_strsep_copy
#endif
ROKEN_LIB_FUNCTION ssize_t ROKEN_LIB_CALL strsep_copy(const char**, const char*, char*, size_t);
#endif

#ifndef HAVE_STRCASECMP
#define strcasecmp rk_strcasecmp
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL strcasecmp(const char *, const char *);
#endif

#ifdef NEED_FCLOSE_PROTO
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL fclose(FILE *);
#endif

#ifdef NEED_STRTOK_R_PROTO
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strtok_r(char *, const char *, char **);
#endif

#ifndef HAVE_STRUPR
#define strupr rk_strupr
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strupr(char *);
#endif

#ifndef HAVE_STRLCPY
#define strlcpy rk_strlcpy
ROKEN_LIB_FUNCTION size_t ROKEN_LIB_CALL strlcpy (char *, const char *, size_t);
#endif

#ifndef HAVE_STRLCAT
#define strlcat rk_strlcat
ROKEN_LIB_FUNCTION size_t ROKEN_LIB_CALL strlcat (char *, const char *, size_t);
#endif

#ifndef HAVE_GETDTABLESIZE
#define getdtablesize rk_getdtablesize
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL getdtablesize(void);
#endif

#if !defined(HAVE_STRERROR) && !defined(strerror)
#define strerror rk_strerror
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL strerror(int);
#endif

#if (!defined(HAVE_STRERROR_R) && !defined(strerror_r)) || (!defined(STRERROR_R_PROTO_COMPATIBLE) && defined(HAVE_STRERROR_R))
int ROKEN_LIB_FUNCTION rk_strerror_r(int, char *, size_t);
#else
#define rk_strerror_r strerror_r
#endif

#if !defined(HAVE_HSTRERROR) || defined(NEED_HSTRERROR_PROTO)
#ifndef HAVE_HSTRERROR
#define hstrerror rk_hstrerror
#endif
/* This causes a fatal error under Psoriasis */
#ifndef SunOS
ROKEN_LIB_FUNCTION const char * ROKEN_LIB_CALL hstrerror(int);
#endif
#endif

#if !HAVE_DECL_H_ERRNO
extern int h_errno;
#endif

#if !defined(HAVE_INET_ATON) || defined(NEED_INET_ATON_PROTO)
#ifndef HAVE_INET_ATON
#define inet_aton rk_inet_aton
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL inet_aton(const char *, struct in_addr *);
#endif

#ifndef HAVE_INET_NTOP
#define inet_ntop rk_inet_ntop
ROKEN_LIB_FUNCTION const char * ROKEN_LIB_CALL
inet_ntop(int af, const void *src, char *dst, size_t size);
#endif

#ifndef HAVE_INET_PTON
#define inet_pton rk_inet_pton
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
inet_pton(int, const char *, void *);
#endif

#ifndef HAVE_GETCWD
#define getcwd rk_getcwd
ROKEN_LIB_FUNCTION char* ROKEN_LIB_CALL getcwd(char *, size_t);
#endif

#ifdef HAVE_PWD_H
#include <pwd.h>
ROKEN_LIB_FUNCTION struct passwd * ROKEN_LIB_CALL k_getpwnam (const char *);
ROKEN_LIB_FUNCTION struct passwd * ROKEN_LIB_CALL k_getpwuid (uid_t);
#endif

ROKEN_LIB_FUNCTION const char * ROKEN_LIB_CALL get_default_username (void);

#ifndef HAVE_SETEUID
#define seteuid rk_seteuid
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL seteuid(uid_t);
#endif

#ifndef HAVE_SETEGID
#define setegid rk_setegid
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL setegid(gid_t);
#endif

#ifndef HAVE_LSTAT
#define lstat rk_lstat
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL lstat(const char *, struct stat *);
#endif

#if !defined(HAVE_MKSTEMP) || defined(NEED_MKSTEMP_PROTO)
#ifndef HAVE_MKSTEMP
#define mkstemp rk_mkstemp
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL mkstemp(char *);
#endif

#ifndef HAVE_CGETENT
#define cgetent rk_cgetent
#define cgetstr rk_cgetstr
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL cgetent(char **, char **, const char *);
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL cgetstr(char *, const char *, char **);
#endif

#ifndef HAVE_INITGROUPS
#define initgroups rk_initgroups
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL initgroups(const char *, gid_t);
#endif

#ifndef HAVE_FCHOWN
#define fchown rk_fchown
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL fchown(int, uid_t, gid_t);
#endif

#ifdef RENAME_DOES_NOT_UNLINK
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL rk_rename(const char *, const char *);
#else
#define rk_rename(__rk_rn_from,__rk_rn_to) rename(__rk_rn_from,__rk_rn_to)
#endif

#if !defined(HAVE_DAEMON) || defined(NEED_DAEMON_PROTO)
#ifndef HAVE_DAEMON
#define daemon rk_daemon
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL daemon(int, int);
#endif

#ifndef HAVE_CHOWN
#define chown rk_chown
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL chown(const char *, uid_t, gid_t);
#endif

#ifndef HAVE_RCMD
#define rcmd rk_rcmd
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
    rcmd(char **, unsigned short, const char *,
	 const char *, const char *, int *);
#endif

#if !defined(HAVE_INNETGR) || defined(NEED_INNETGR_PROTO)
#ifndef HAVE_INNETGR
#define innetgr rk_innetgr
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL innetgr(const char*, const char*,
    const char*, const char*);
#endif

#ifndef HAVE_IRUSEROK
#define iruserok rk_iruserok
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL iruserok(unsigned, int, 
    const char *, const char *);
#endif

#if !defined(HAVE_GETHOSTNAME) || defined(NEED_GETHOSTNAME_PROTO)
#ifndef HAVE_GETHOSTNAME
#define gethostname rk_gethostname
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL gethostname(char *, int);
#endif

#ifndef HAVE_WRITEV
#define writev rk_writev
ROKEN_LIB_FUNCTION ssize_t ROKEN_LIB_CALL
writev(int, const struct iovec *, int);
#endif

#ifndef HAVE_READV
#define readv rk_readv
ROKEN_LIB_FUNCTION ssize_t ROKEN_LIB_CALL
readv(int, const struct iovec *, int);
#endif

#ifndef HAVE_PIDFILE
#ifdef NO_PIDFILES
#define pidfile(x) ((void) 0)
#else
#define pidfile rk_pidfile
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL pidfile (const char*);
#endif
#endif

#ifndef HAVE_BSWAP32
#define bswap32 rk_bswap32
ROKEN_LIB_FUNCTION unsigned int ROKEN_LIB_CALL bswap32(unsigned int);
#endif

#ifndef HAVE_BSWAP16
#define bswap16 rk_bswap16
ROKEN_LIB_FUNCTION unsigned short ROKEN_LIB_CALL bswap16(unsigned short);
#endif

#ifndef HAVE_FLOCK
#ifndef LOCK_SH
#define LOCK_SH   1		/* Shared lock */
#endif
#ifndef	LOCK_EX
#define LOCK_EX   2		/* Exclusive lock */
#endif
#ifndef LOCK_NB
#define LOCK_NB   4		/* Don't block when locking */
#endif
#ifndef LOCK_UN
#define LOCK_UN   8		/* Unlock */
#endif

#define flock(_x,_y) rk_flock(_x,_y)
int rk_flock(int fd, int operation);
#endif /* HAVE_FLOCK */

#ifndef HAVE_DIRFD
#ifdef HAVE_DIR_DD_FD
#define dirfd(x) ((x)->dd_fd)
#else
#ifndef _WIN32 /* Windows code never calls dirfd */
#error Missing dirfd() and ->dd_fd
#endif
#endif
#endif

ROKEN_LIB_FUNCTION time_t ROKEN_LIB_CALL tm2time (struct tm, int);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL unix_verify_user(char *, char *);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL roken_concat (char *, size_t, ...);

ROKEN_LIB_FUNCTION size_t ROKEN_LIB_CALL roken_mconcat (char **, size_t, ...);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL roken_vconcat (char *, size_t, va_list);

ROKEN_LIB_FUNCTION size_t ROKEN_LIB_CALL
    roken_vmconcat (char **, size_t, va_list);

ROKEN_LIB_FUNCTION ssize_t ROKEN_LIB_CALL
    net_write (rk_socket_t, const void *, size_t);

ROKEN_LIB_FUNCTION ssize_t ROKEN_LIB_CALL
    net_read (rk_socket_t, void *, size_t);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
    issuid(void);

#ifndef HAVE_STRUCT_WINSIZE
struct winsize {
	unsigned short ws_row, ws_col;
	unsigned short ws_xpixel, ws_ypixel;
};
#endif

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL get_window_size(int fd, int *, int *);

#ifndef HAVE_VSYSLOG
#define vsyslog rk_vsyslog
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL vsyslog(int, const char *, va_list);
#endif

#ifndef HAVE_GETOPT
#define getopt rk_getopt
#define optarg rk_optarg
#define optind rk_optind
#define opterr rk_opterr
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
getopt(int nargc, char * const *nargv, const char *ostr);
#endif

#if !HAVE_DECL_OPTARG
ROKEN_LIB_VARIABLE extern char *optarg;
#endif
#if !HAVE_DECL_OPTIND
ROKEN_LIB_VARIABLE extern int optind;
#endif
#if !HAVE_DECL_OPTERR
ROKEN_LIB_VARIABLE extern int opterr;
#endif

#ifndef HAVE_GETIPNODEBYNAME
#define getipnodebyname rk_getipnodebyname
ROKEN_LIB_FUNCTION struct hostent * ROKEN_LIB_CALL
getipnodebyname (const char *, int, int, int *);
#endif

#ifndef HAVE_GETIPNODEBYADDR
#define getipnodebyaddr rk_getipnodebyaddr
ROKEN_LIB_FUNCTION struct hostent * ROKEN_LIB_CALL
getipnodebyaddr (const void *, size_t, int, int *);
#endif

#ifndef HAVE_FREEHOSTENT
#define freehostent rk_freehostent
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
freehostent (struct hostent *);
#endif

#ifndef HAVE_COPYHOSTENT
#define copyhostent rk_copyhostent
ROKEN_LIB_FUNCTION struct hostent * ROKEN_LIB_CALL
copyhostent (const struct hostent *);
#endif

#ifndef HAVE_SOCKLEN_T
typedef int socklen_t;
#endif

#ifndef HAVE_STRUCT_SOCKADDR_STORAGE

#ifndef HAVE_SA_FAMILY_T
typedef unsigned short sa_family_t;
#endif

#ifdef HAVE_IPV6
#define _SS_MAXSIZE sizeof(struct sockaddr_in6)
#else
#define _SS_MAXSIZE sizeof(struct sockaddr_in)
#endif

#define _SS_ALIGNSIZE	sizeof(unsigned long)

#if HAVE_STRUCT_SOCKADDR_SA_LEN

typedef unsigned char roken_sa_family_t;

#define _SS_PAD1SIZE   ((2 * _SS_ALIGNSIZE - sizeof (roken_sa_family_t) - sizeof(unsigned char)) % _SS_ALIGNSIZE)
#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (roken_sa_family_t) + sizeof(unsigned char) + _SS_PAD1SIZE + _SS_ALIGNSIZE))

struct sockaddr_storage {
    unsigned char	ss_len;
    roken_sa_family_t	ss_family;
    char		__ss_pad1[_SS_PAD1SIZE];
    unsigned long	__ss_align[_SS_PAD2SIZE / sizeof(unsigned long) + 1];
};

#else /* !HAVE_STRUCT_SOCKADDR_SA_LEN */

typedef unsigned short roken_sa_family_t;

#define _SS_PAD1SIZE   ((2 * _SS_ALIGNSIZE - sizeof (roken_sa_family_t)) % _SS_ALIGNSIZE)
#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (roken_sa_family_t) + _SS_PAD1SIZE + _SS_ALIGNSIZE))

struct sockaddr_storage {
    roken_sa_family_t	ss_family;
    char		__ss_pad1[_SS_PAD1SIZE];
    unsigned long	__ss_align[_SS_PAD2SIZE / sizeof(unsigned long) + 1];
};

#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */

#endif /* HAVE_STRUCT_SOCKADDR_STORAGE */

#ifndef HAVE_STRUCT_ADDRINFO
struct addrinfo {
    int    ai_flags;
    int    ai_family;
    int    ai_socktype;
    int    ai_protocol;
    size_t ai_addrlen;
    char  *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfo *ai_next;
};
#endif

#ifndef HAVE_GETADDRINFO
#define getaddrinfo rk_getaddrinfo
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
getaddrinfo(const char *,
	    const char *,
	    const struct addrinfo *,
	    struct addrinfo **);
#endif

#ifndef HAVE_GETNAMEINFO
#define getnameinfo rk_getnameinfo
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
getnameinfo(const struct sockaddr *, socklen_t,
		char *, size_t,
		char *, size_t,
		int);
#endif

#ifndef HAVE_FREEADDRINFO
#define freeaddrinfo rk_freeaddrinfo
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
freeaddrinfo(struct addrinfo *);
#endif

#ifndef HAVE_GAI_STRERROR
#define gai_strerror rk_gai_strerror
ROKEN_LIB_FUNCTION const char * ROKEN_LIB_CALL
gai_strerror(int);
#endif

#ifdef NO_SLEEP

ROKEN_LIB_FUNCTION unsigned int ROKEN_LIB_CALL
sleep(unsigned int seconds);

#endif

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
getnameinfo_verified(const struct sockaddr *, socklen_t,
		     char *, size_t,
		     char *, size_t,
		     int);

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
roken_getaddrinfo_hostspec(const char *, int, struct addrinfo **); 
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
roken_getaddrinfo_hostspec2(const char *, int, int, struct addrinfo **);

#ifndef HAVE_STRFTIME
#define strftime rk_strftime
ROKEN_LIB_FUNCTION size_t ROKEN_LIB_CALL
strftime (char *, size_t, const char *, const struct tm *);
#endif

#ifndef HAVE_STRPTIME
#define strptime rk_strptime
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
strptime (const char *, const char *, struct tm *);
#endif

#ifndef HAVE_GETTIMEOFDAY
#define gettimeofday rk_gettimeofday
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
gettimeofday (struct timeval *, void *);
#endif

#ifndef HAVE_EMALLOC
#define emalloc rk_emalloc
ROKEN_LIB_FUNCTION void * ROKEN_LIB_CALL emalloc (size_t);
#endif
#ifndef HAVE_ECALLOC
#define ecalloc rk_ecalloc
ROKEN_LIB_FUNCTION void * ROKEN_LIB_CALL ecalloc(size_t, size_t);
#endif
#ifndef HAVE_EREALLOC
#define erealloc rk_erealloc
ROKEN_LIB_FUNCTION void * ROKEN_LIB_CALL erealloc (void *, size_t);
#endif
#ifndef HAVE_ESTRDUP
#define estrdup rk_estrdup
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL estrdup (const char *);
#endif

/*
 * kludges and such
 */

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
roken_gethostby_setup(const char*, const char*);
ROKEN_LIB_FUNCTION struct hostent* ROKEN_LIB_CALL
roken_gethostbyname(const char*);
ROKEN_LIB_FUNCTION struct hostent* ROKEN_LIB_CALL 
roken_gethostbyaddr(const void*, size_t, int);

#ifdef GETSERVBYNAME_PROTO_COMPATIBLE
#define roken_getservbyname(x,y) getservbyname(x,y)
#else
#define roken_getservbyname(x,y) getservbyname((char *)x, (char *)y)
#endif

#ifdef OPENLOG_PROTO_COMPATIBLE
#define roken_openlog(a,b,c) openlog(a,b,c)
#else
#define roken_openlog(a,b,c) openlog((char *)a,b,c)
#endif

#ifdef GETSOCKNAME_PROTO_COMPATIBLE
#define roken_getsockname(a,b,c) getsockname(a,b,c)
#else
#define roken_getsockname(a,b,c) getsockname(a, b, (void*)c)
#endif

#ifndef HAVE_SETPROGNAME
#define setprogname rk_setprogname
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL setprogname(const char *);
#endif

#ifndef HAVE_GETPROGNAME
#define getprogname rk_getprogname
ROKEN_LIB_FUNCTION const char * ROKEN_LIB_CALL getprogname(void);
#endif

#if !defined(HAVE_SETPROGNAME) && !defined(HAVE_GETPROGNAME) && !HAVE_DECL___PROGNAME
extern const char *__progname;
#endif

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
mini_inetd_addrinfo (struct addrinfo*, rk_socket_t *);

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
mini_inetd (int, rk_socket_t *);

#ifndef HAVE_LOCALTIME_R
#define localtime_r rk_localtime_r
ROKEN_LIB_FUNCTION struct tm * ROKEN_LIB_CALL
localtime_r(const time_t *, struct tm *);
#endif

#if !defined(HAVE_STRSVIS) || defined(NEED_STRSVIS_PROTO)
#ifndef HAVE_STRSVIS
#define strsvis rk_strsvis
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
strsvis(char *, const char *, int, const char *);
#endif

#if !defined(HAVE_STRSVISX) || defined(NEED_STRSVISX_PROTO)
#ifndef HAVE_STRSVISX
#define strsvisx rk_strsvisx
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
strsvisx(char *, const char *, size_t, int, const char *);
#endif

#if !defined(HAVE_STRUNVIS) || defined(NEED_STRUNVIS_PROTO)
#ifndef HAVE_STRUNVIS
#define strunvis rk_strunvis
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
strunvis(char *, const char *);
#endif

#if !defined(HAVE_STRVIS) || defined(NEED_STRVIS_PROTO)
#ifndef HAVE_STRVIS
#define strvis rk_strvis
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
strvis(char *, const char *, int);
#endif

#if !defined(HAVE_STRVISX) || defined(NEED_STRVISX_PROTO)
#ifndef HAVE_STRVISX
#define strvisx rk_strvisx
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
strvisx(char *, const char *, size_t, int);
#endif

#if !defined(HAVE_SVIS) || defined(NEED_SVIS_PROTO)
#ifndef HAVE_SVIS
#define svis rk_svis
#endif
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
svis(char *, int, int, int, const char *);
#endif

#if !defined(HAVE_UNVIS) || defined(NEED_UNVIS_PROTO)
#ifndef HAVE_UNVIS
#define unvis rk_unvis
#endif
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
unvis(char *, int, int *, int);
#endif

#if !defined(HAVE_VIS) || defined(NEED_VIS_PROTO)
#ifndef HAVE_VIS
#define vis rk_vis
#endif
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
vis(char *, int, int, int);
#endif

#if !defined(HAVE_CLOSEFROM)
#define closefrom rk_closefrom
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
closefrom(int);
#endif

#if !defined(HAVE_TIMEGM)
#define timegm rk_timegm
ROKEN_LIB_FUNCTION time_t ROKEN_LIB_CALL
rk_timegm(struct tm *tm);
#endif

#ifdef NEED_QSORT
#define qsort rk_qsort
void
rk_qsort(void *, size_t, size_t, int (*)(const void *, const void *));
#endif

#if defined(HAVE_ARC4RANDOM)
#define rk_random() arc4random()
#elif defined(HAVE_RANDOM)
#define rk_random() random()
#else
#define rk_random() rand()
#endif

#ifndef HAVE_TDELETE
#define tdelete(a,b,c) rk_tdelete(a,b,c)
#endif
#ifndef HAVE_TFIND
#define tfind(a,b,c) rk_tfind(a,b,c)
#endif
#ifndef HAVE_TSEARCH
#define tsearch(a,b,c) rk_tsearch(a,b,c)
#endif
#ifndef HAVE_TWALK
#define twalk(a,b) rk_twalk(a,b)
#endif

#if defined(__linux__) && defined(SOCK_CLOEXEC) && !defined(SOCKET_WRAPPER_REPLACE) && !defined(__SOCKET_WRAPPER_H__)
#undef socket
#define socket(_fam,_type,_prot) rk_socket(_fam,_type,_prot)
int ROKEN_LIB_FUNCTION rk_socket(int, int, int);
#endif

#ifdef SOCKET_WRAPPER_REPLACE
#include <socket_wrapper.h>
#endif

ROKEN_CPP_END
@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
a34 2
/* $KTH: roken.h.in,v 1.148 2001/01/27 05:28:09 assar Exp $ */

d38 3
d44 142
d193 3
d199 9
d238 6
a246 3
#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#endif
a252 1
#ifdef HAVE_ERR_H
a253 1
#endif
d257 1
a257 1
#if defined(HAVE_SYS_IOCTL_H) && SunOS != 40
d273 3
d277 11
a287 5
#ifndef ROKEN_LIB_FUNCTION
#if defined(__BORLANDC__)
#define ROKEN_LIB_FUNCTION /* not-ready-definition-yet */
#elif defined(_MSC_VER)
#define ROKEN_LIB_FUNCTION /* not-ready-definition-yet2 */
d289 1
a289 2
#define ROKEN_LIB_FUNCTION
#endif
d291 3
d299 6
d309 89
d399 2
a400 1
int putenv(const char *string);
d404 4
a407 1
int setenv(const char *var, const char *val, int rewrite);
d411 4
a414 1
void unsetenv(const char *name);
d418 6
a423 2
char *getusershell(void);
void endusershell(void);
d427 5
a431 1
int snprintf (char *str, size_t sz, const char *format, ...)
d436 5
a440 1
int vsnprintf (char *str, size_t sz, const char *format, va_list ap)
d445 5
a449 1
int asprintf (char **ret, const char *format, ...)
d454 5
a458 1
int vasprintf (char **ret, const char *format, va_list ap)
d463 5
a467 1
int asnprintf (char **ret, size_t max_sz, const char *format, ...)
d472 5
a476 1
int vasnprintf (char **ret, size_t max_sz, const char *format, va_list ap)
d481 2
a482 1
char * strdup(const char *old);
d485 1
d487 3
a489 1
char * strndup(const char *old, size_t sz);
d493 2
a494 1
char * strlwr(char *);
d498 2
a499 1
size_t strnlen(const char*, size_t);
d503 4
a506 1
char *strsep(char**, const char*);
d510 4
a513 1
ssize_t strsep_copy(const char**, const char*, char*, size_t);
d517 2
a518 1
int strcasecmp(const char *s1, const char *s2);
d522 1
a522 1
int fclose(FILE *);
d526 1
a526 1
char *strtok_r(char *s1, const char *s2, char **lasts);
d530 2
a531 1
char * strupr(char *);
d535 2
a536 1
size_t strlcpy (char *dst, const char *src, size_t dst_sz);
d540 2
a541 1
size_t strlcat (char *dst, const char *src, size_t dst_sz);
d545 2
a546 1
int getdtablesize(void);
d550 8
a557 1
char *strerror(int eno);
d561 3
d565 2
a566 2
#if !(defined(SunOS) && (SunOS >= 50))
const char *hstrerror(int herr);
d570 1
a570 1
#ifndef HAVE_H_ERRNO_DECLARATION
d575 4
a578 1
int inet_aton(const char *cp, struct in_addr *adr);
d582 2
a583 1
const char *
d588 3
a590 2
int
inet_pton(int af, const char *src, void *dst);
d593 3
a595 2
#if !defined(HAVE_GETCWD)
char* getcwd(char *path, size_t size);
d600 2
a601 2
struct passwd *k_getpwnam (const char *user);
struct passwd *k_getpwuid (uid_t uid);
d604 1
a604 1
const char *get_default_username (void);
d607 2
a608 1
int seteuid(uid_t euid);
d612 2
a613 1
int setegid(gid_t egid);
d617 2
a618 1
int lstat(const char *path, struct stat *buf);
d622 4
a625 1
int mkstemp(char *);
d629 4
a632 2
int cgetent(char **buf, char **db_array, const char *name);
int cgetstr(char *buf, const char *cap, char **str);
d636 2
a637 1
int initgroups(const char *name, gid_t basegid);
d641 2
a642 1
int fchown(int fd, uid_t owner, gid_t group);
d645 7
d653 1
a653 1
int daemon(int nochdir, int noclose);
d655 1
a655 4

#ifndef HAVE_INNETGR
int innetgr(const char *netgroup, const char *machine, 
	    const char *user, const char *domain);
d659 2
a660 1
int chown(const char *path, uid_t owner, gid_t group);
d664 4
a667 2
int rcmd(char **ahost, unsigned short inport, const char *locuser,
	 const char *remuser, const char *cmd, int *fd2p);
d671 5
a675 1
int innetgr(const char*, const char*, const char*, const char*);
d679 3
a681 2
int iruserok(unsigned raddr, int superuser, const char *ruser,
	     const char *luser);
d685 4
a688 1
int gethostname(char *name, int namelen);
d692 3
a694 2
ssize_t
writev(int d, const struct iovec *iov, int iovcnt);
d698 3
a700 2
ssize_t
readv(int d, const struct iovec *iov, int iovcnt);
d703 12
a714 3
#ifndef HAVE_MKSTEMP
int
mkstemp(char *template);
d717 3
a719 2
#ifndef HAVE_PIDFILE
void pidfile (const char*);
d736 2
a737 1
int flock(int fd, int operation);
d740 9
a748 1
time_t tm2time (struct tm tm, int local);
d750 1
a750 1
int unix_verify_user(char *user, char *password);
d752 1
a752 1
void mini_inetd (int port);
d754 1
a754 1
int roken_concat (char *s, size_t len, ...);
d756 1
a756 1
size_t roken_mconcat (char **s, size_t max_len, ...);
d758 1
a758 1
int roken_vconcat (char *s, size_t len, va_list args);
d760 2
a761 1
size_t roken_vmconcat (char **s, size_t max_len, va_list args);
d763 2
a764 1
ssize_t net_write (int fd, const void *buf, size_t nbytes);
d766 2
a767 1
ssize_t net_read (int fd, void *buf, size_t nbytes);
d769 2
a770 1
int issuid(void);
d779 1
a779 1
int get_window_size(int fd, struct winsize *);
d782 2
a783 1
void vsyslog(int pri, const char *fmt, va_list ap);
d786 7
a792 2
#ifndef HAVE_OPTARG_DECLARATION
extern char *optarg;
d794 3
a796 5
#ifndef HAVE_OPTIND_DECLARATION
extern int optind;
#endif
#ifndef HAVE_OPTERR_DECLARATION
extern int opterr;
d798 2
a799 3

#ifndef HAVE___PROGNAME_DECLARATION
extern const char *__progname;
d801 2
a802 3

#ifndef HAVE_ENVIRON_DECLARATION
extern char **environ;
d806 3
a808 2
struct hostent *
getipnodebyname (const char *name, int af, int flags, int *error_num);
d812 3
a814 2
struct hostent *
getipnodebyaddr (const void *src, size_t len, int af, int *error_num);
d818 3
a820 2
void
freehostent (struct hostent *h);
d824 3
a826 2
struct hostent *
copyhostent (const struct hostent *h);
d892 6
a897 5
int
getaddrinfo(const char *nodename,
	    const char *servname,
	    const struct addrinfo *hints,
	    struct addrinfo **res);
d901 6
a906 4
int getnameinfo(const struct sockaddr *sa, socklen_t salen,
		char *host, size_t hostlen,
		char *serv, size_t servlen,
		int flags);
d910 3
a912 2
void
freeaddrinfo(struct addrinfo *ai);
d916 10
a925 2
char *
gai_strerror(int ecode);
d928 5
a932 5
int
getnameinfo_verified(const struct sockaddr *sa, socklen_t salen,
		     char *host, size_t hostlen,
		     char *serv, size_t servlen,
		     int flags);
d934 4
a937 2
int roken_getaddrinfo_hostspec(const char *, int, struct addrinfo **); 
int roken_getaddrinfo_hostspec2(const char *, int, int, struct addrinfo **);
d940 3
a942 3
size_t
strftime (char *buf, size_t maxsize, const char *format,
	  const struct tm *tm);
d946 26
a971 2
char *
strptime (const char *buf, const char *format, struct tm *timeptr);
d978 6
a983 17
#if 1
int roken_gethostby_setup(const char*, const char*);
struct hostent* roken_gethostbyname(const char*);
struct hostent* roken_gethostbyaddr(const void*, size_t, int);
#else
#ifdef GETHOSTBYNAME_PROTO_COMPATIBLE
#define roken_gethostbyname(x) gethostbyname(x)
#else
#define roken_gethostbyname(x) gethostbyname((char *)x)
#endif

#ifdef GETHOSTBYADDR_PROTO_COMPATIBLE
#define roken_gethostbyaddr(a, l, t) gethostbyaddr(a, l, t)
#else
#define roken_gethostbyaddr(a, l, t) gethostbyaddr((char *)a, l, t)
#endif
#endif
d1003 138
a1140 2
void set_progname(char *argv0);
const char *get_progname(void);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 1
/* $KTH: roken.h.in,v 1.157 2001/05/18 18:00:12 assar Exp $ */
a49 3
#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif
a52 9
#ifdef HAVE_SYS_BITYPES_H
#include <sys/bitypes.h>
#endif
#ifdef HAVE_BIND_BITYPES_H
#include <bind/bitypes.h>
#endif
#ifdef HAVE_NETINET_IN6_MACHTYPES_H
#include <netinet/in6_machtypes.h>
#endif
a354 8
#ifndef HAVE_BSWAP32
unsigned int bswap32(unsigned int);
#endif

#ifndef HAVE_BSWAP16
unsigned short bswap16(unsigned short);
#endif

a587 8
#endif

#ifndef HAVE_SETPROGNAME
void setprogname(const char *argv0);
#endif

#ifndef HAVE_GETPROGNAME
const char *getprogname(void);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d35 1
a35 1
/* $KTH: roken.h.in,v 1.159 2001/08/21 15:32:05 assar Exp $ */
d98 3
a567 13
#endif

#ifndef HAVE_EMALLOC
void *emalloc (size_t);
#endif
#ifndef HAVE_ECALLOC
void *ecalloc(size_t num, size_t sz);
#endif
#ifndef HAVE_EREALLOC
void *erealloc (void *, size_t);
#endif
#ifndef HAVE_ESTRDUP
char *estrdup (const char *);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d3 1
a3 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
/* $KTH: roken.h.in,v 1.169 2002/08/26 21:43:38 assar Exp $ */
a94 6
#ifdef HAVE_ARPA_NAMESER_H
#include <arpa/nameser.h>
#endif
#ifdef HAVE_RESOLV_H
#include <resolv.h>
#endif
a136 4
#ifndef HAVE_SSIZE_T
typedef int ssize_t;
#endif

d196 1
a196 1
#if !defined(HAVE_STRNDUP) || defined(NEED_STRNDUP_PROTO)
d393 2
a627 3
void mini_inetd_addrinfo (struct addrinfo*);
void mini_inetd (int port);

a629 40

#ifndef HAVE_LOCALTIME_R
struct tm *
localtime_r(const time_t *timer, struct tm *result);
#endif

#if !defined(HAVE_STRSVIS) || defined(NEED_STRSVIS_PROTO)
int
strsvis(char *dst, const char *src, int flag, const char *extra);
#endif

#if !defined(HAVE_STRUNVIS) || defined(NEED_STRUNVIS_PROTO)
int
strunvis(char *dst, const char *src);
#endif

#if !defined(HAVE_STRVIS) || defined(NEED_STRVIS_PROTO)
int
strvis(char *dst, const char *src, int flag);
#endif

#if !defined(HAVE_STRVISX) || defined(NEED_STRVISX_PROTO)
int
strvisx(char *dst, const char *src, size_t len, int flag);
#endif

#if !defined(HAVE_SVIS) || defined(NEED_SVIS_PROTO)
char *
svis(char *dst, int c, int flag, int nextc, const char *extra);
#endif

#if !defined(HAVE_UNVIS) || defined(NEED_UNVIS_PROTO)
int
unvis(char *cp, int c, int *astate, int flag);
#endif

#if !defined(HAVE_VIS) || defined(NEED_VIS_PROTO)
char *
vis(char *dst, int c, int flag, int nextc);
#endif
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d3 1
a3 1
 * Copyright (c) 1995-2005 Kungliga Tekniska Högskolan
d35 1
a35 1
/* $KTH: roken.h.in,v 1.174 2005/05/11 13:04:04 lha Exp $ */
d110 1
d112 1
d132 11
d156 1
a156 1
int ROKEN_LIB_FUNCTION putenv(const char *string);
d160 1
a160 1
int ROKEN_LIB_FUNCTION setenv(const char *var, const char *val, int rewrite);
d164 1
a164 1
void ROKEN_LIB_FUNCTION unsetenv(const char *name);
d168 2
a169 2
char * ROKEN_LIB_FUNCTION getusershell(void);
void ROKEN_LIB_FUNCTION endusershell(void);
d173 1
a173 1
int ROKEN_LIB_FUNCTION snprintf (char *str, size_t sz, const char *format, ...)
d178 1
a178 2
int ROKEN_LIB_FUNCTION 
     vsnprintf (char *str, size_t sz, const char *format, va_list ap)
d183 1
a183 2
int ROKEN_LIB_FUNCTION
     asprintf (char **ret, const char *format, ...)
d188 1
a188 2
int ROKEN_LIB_FUNCTION
    vasprintf (char **ret, const char *format, va_list ap)
d193 1
a193 2
int ROKEN_LIB_FUNCTION
    asnprintf (char **ret, size_t max_sz, const char *format, ...)
d198 1
a198 2
int ROKEN_LIB_FUNCTION
    vasnprintf (char **ret, size_t max_sz, const char *format, va_list ap)
d203 1
a203 1
char * ROKEN_LIB_FUNCTION strdup(const char *old);
d207 1
a207 1
char * ROKEN_LIB_FUNCTION strndup(const char *old, size_t sz);
d211 1
a211 1
char * ROKEN_LIB_FUNCTION strlwr(char *);
d215 1
a215 1
size_t ROKEN_LIB_FUNCTION strnlen(const char*, size_t);
d219 1
a219 1
char * ROKEN_LIB_FUNCTION strsep(char**, const char*);
d223 1
a223 1
ssize_t ROKEN_LIB_FUNCTION strsep_copy(const char**, const char*, char*, size_t);
d227 1
a227 1
int ROKEN_LIB_FUNCTION strcasecmp(const char *s1, const char *s2);
d231 1
a231 1
int ROKEN_LIB_FUNCTION fclose(FILE *);
d235 1
a235 1
char * ROKEN_LIB_FUNCTION strtok_r(char *s1, const char *s2, char **lasts);
d239 1
a239 1
char * ROKEN_LIB_FUNCTION strupr(char *);
d243 1
a243 1
size_t ROKEN_LIB_FUNCTION strlcpy (char *dst, const char *src, size_t dst_sz);
d247 1
a247 1
size_t ROKEN_LIB_FUNCTION strlcat (char *dst, const char *src, size_t dst_sz);
d251 1
a251 1
int ROKEN_LIB_FUNCTION getdtablesize(void);
d255 1
a255 1
char * ROKEN_LIB_FUNCTION strerror(int eno);
d261 1
a261 1
const char * ROKEN_LIB_FUNCTION hstrerror(int herr);
d265 1
a265 1
#if !HAVE_DECL_H_ERRNO
d270 1
a270 1
int ROKEN_LIB_FUNCTION inet_aton(const char *cp, struct in_addr *adr);
d274 1
a274 1
const char * ROKEN_LIB_FUNCTION
d279 1
a279 1
int ROKEN_LIB_FUNCTION
d284 1
a284 1
char* ROKEN_LIB_FUNCTION getcwd(char *path, size_t size);
d289 2
a290 2
struct passwd * ROKEN_LIB_FUNCTION k_getpwnam (const char *user);
struct passwd * ROKEN_LIB_FUNCTION k_getpwuid (uid_t uid);
d293 1
a293 1
const char * ROKEN_LIB_FUNCTION get_default_username (void);
d296 1
a296 1
int ROKEN_LIB_FUNCTION seteuid(uid_t euid);
d300 1
a300 1
int ROKEN_LIB_FUNCTION setegid(gid_t egid);
d304 1
a304 1
int ROKEN_LIB_FUNCTION lstat(const char *path, struct stat *buf);
d308 1
a308 1
int ROKEN_LIB_FUNCTION mkstemp(char *);
d312 2
a313 2
int ROKEN_LIB_FUNCTION cgetent(char **buf, char **db_array, const char *name);
int ROKEN_LIB_FUNCTION cgetstr(char *buf, const char *cap, char **str);
d317 1
a317 1
int ROKEN_LIB_FUNCTION initgroups(const char *name, gid_t basegid);
d321 1
a321 1
int ROKEN_LIB_FUNCTION fchown(int fd, uid_t owner, gid_t group);
d324 2
a325 2
#if !defined(HAVE_DAEMON) || defined(NEED_DAEMON_PROTO)
int ROKEN_LIB_FUNCTION daemon(int nochdir, int noclose);
d329 1
a329 1
int ROKEN_LIB_FUNCTION innetgr(const char *netgroup, const char *machine, 
d334 1
a334 1
int ROKEN_LIB_FUNCTION chown(const char *path, uid_t owner, gid_t group);
d338 1
a338 2
int ROKEN_LIB_FUNCTION
    rcmd(char **ahost, unsigned short inport, const char *locuser,
d343 1
a343 2
int ROKEN_LIB_FUNCTION innetgr(const char*, const char*,
    const char*, const char*);
d347 2
a348 2
int ROKEN_LIB_FUNCTION iruserok(unsigned raddr, int superuser, 
    const char *ruser, const char *luser);
d352 1
a352 1
int ROKEN_LIB_FUNCTION gethostname(char *name, int namelen);
d356 1
a356 1
ssize_t ROKEN_LIB_FUNCTION
d361 1
a361 1
ssize_t ROKEN_LIB_FUNCTION
d366 1
a366 1
int ROKEN_LIB_FUNCTION
d371 1
a371 1
void ROKEN_LIB_FUNCTION pidfile (const char*);
d375 1
a375 1
unsigned int ROKEN_LIB_FUNCTION bswap32(unsigned int);
d379 1
a379 1
unsigned short ROKEN_LIB_FUNCTION bswap16(unsigned short);
d399 1
a399 1
time_t ROKEN_LIB_FUNCTION tm2time (struct tm tm, int local);
d401 1
a401 1
int ROKEN_LIB_FUNCTION unix_verify_user(char *user, char *password);
d403 1
a403 1
int ROKEN_LIB_FUNCTION roken_concat (char *s, size_t len, ...);
d405 1
a405 1
size_t ROKEN_LIB_FUNCTION roken_mconcat (char **s, size_t max_len, ...);
d407 1
a407 1
int ROKEN_LIB_FUNCTION roken_vconcat (char *s, size_t len, va_list args);
d409 1
a409 2
size_t ROKEN_LIB_FUNCTION
    roken_vmconcat (char **s, size_t max_len, va_list args);
d411 1
a411 1
ssize_t ROKEN_LIB_FUNCTION net_write (int fd, const void *buf, size_t nbytes);
d413 1
a413 1
ssize_t ROKEN_LIB_FUNCTION net_read (int fd, void *buf, size_t nbytes);
d415 1
a415 1
int ROKEN_LIB_FUNCTION issuid(void);
d424 1
a424 1
int ROKEN_LIB_FUNCTION get_window_size(int fd, struct winsize *);
d427 1
a427 1
void ROKEN_LIB_FUNCTION vsyslog(int pri, const char *fmt, va_list ap);
d430 1
a430 1
#if !HAVE_DECL_OPTARG
d433 1
a433 1
#if !HAVE_DECL_OPTIND
d436 1
a436 1
#if !HAVE_DECL_OPTERR
d440 5
a444 1
#if !HAVE_DECL_ENVIRON
d449 1
a449 1
struct hostent * ROKEN_LIB_FUNCTION
d454 1
a454 1
struct hostent * ROKEN_LIB_FUNCTION
d459 1
a459 1
void ROKEN_LIB_FUNCTION
d464 1
a464 1
struct hostent * ROKEN_LIB_FUNCTION
d531 1
a531 1
int ROKEN_LIB_FUNCTION
d539 1
a539 2
int ROKEN_LIB_FUNCTION
getnameinfo(const struct sockaddr *sa, socklen_t salen,
d546 1
a546 1
void ROKEN_LIB_FUNCTION
d551 1
a551 1
char * ROKEN_LIB_FUNCTION
d555 1
a555 1
int ROKEN_LIB_FUNCTION
d561 2
a562 4
int ROKEN_LIB_FUNCTION
roken_getaddrinfo_hostspec(const char *, int, struct addrinfo **); 
int ROKEN_LIB_FUNCTION
roken_getaddrinfo_hostspec2(const char *, int, int, struct addrinfo **);
d565 1
a565 1
size_t ROKEN_LIB_FUNCTION
d571 1
a571 1
char * ROKEN_LIB_FUNCTION
d576 1
a576 1
void * ROKEN_LIB_FUNCTION emalloc (size_t);
d579 1
a579 1
void * ROKEN_LIB_FUNCTION ecalloc(size_t num, size_t sz);
d582 1
a582 1
void * ROKEN_LIB_FUNCTION erealloc (void *, size_t);
d585 1
a585 1
char * ROKEN_LIB_FUNCTION estrdup (const char *);
d593 3
a595 6
int ROKEN_LIB_FUNCTION
roken_gethostby_setup(const char*, const char*);
struct hostent* ROKEN_LIB_FUNCTION
roken_gethostbyname(const char*);
struct hostent* ROKEN_LIB_FUNCTION 
roken_gethostbyaddr(const void*, size_t, int);
d629 1
a629 1
void ROKEN_LIB_FUNCTION setprogname(const char *argv0);
d633 1
a633 1
const char * ROKEN_LIB_FUNCTION getprogname(void);
d636 2
a637 3
#if !defined(HAVE_SETPROGNAME) && !defined(HAVE_GETPROGNAME) && !HAVE_DECL___PROGNAME
extern const char *__progname;
#endif
d639 2
a640 2
void ROKEN_LIB_FUNCTION mini_inetd_addrinfo (struct addrinfo*);
void ROKEN_LIB_FUNCTION mini_inetd (int port);
d643 1
a643 1
struct tm * ROKEN_LIB_FUNCTION
d648 1
a648 1
int ROKEN_LIB_FUNCTION
d653 1
a653 1
int ROKEN_LIB_FUNCTION
d658 1
a658 1
int ROKEN_LIB_FUNCTION
d663 1
a663 1
int ROKEN_LIB_FUNCTION
d668 1
a668 1
char * ROKEN_LIB_FUNCTION
d673 1
a673 1
int ROKEN_LIB_FUNCTION
d678 1
a678 1
char * ROKEN_LIB_FUNCTION
a679 5
#endif

#if !defined(HAVE_CLOSEFROM)
int ROKEN_LIB_FUNCTION
closefrom(int);
@


