head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.3.0.28
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.26
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.24
	OPENBSD_5_0:1.1.1.3.0.22
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.20
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.18
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.14
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.16
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.12
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	HEIMDAL_0_7_2:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.12
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.10
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.8
	OPENBSD_3_7_BASE:1.1.1.2
	HEIMDAL_0_6_3:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.6
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.4
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.2
	OPENBSD_3_4_BASE:1.1.1.2
	HEIMDAL_0_6:1.1.1.2
	HEIMDAL_0_6RC1:1.1.1.2
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@.\" @;


1.3
date	2014.04.22.10.01.33;	author reyk;	state dead;
branches;
next	1.2;

1.2
date	2013.06.17.18.57.45;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.10;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.10;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.02.16.04;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.14.07.33.38;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.3
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@.\" Copyright (c) 1999 - 2002 Kungliga Tekniska HÃ¶gskolan
.\" (Royal Institute of Technology, Stockholm, Sweden).
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\"
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" 3. Neither the name of the Institute nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" $Id: getarg.3,v 1.2 2013/06/17 18:57:45 robert Exp $
.Dd September 24, 1999
.Dt GETARG 3
.Os ROKEN
.Sh NAME
.Nm getarg ,
.Nm arg_printusage
.Nd collect command line options
.Sh SYNOPSIS
.In getarg.h
.Ft int
.Fn getarg "struct getargs *args" "size_t num_args" "int argc" "char **argv" "int *optind"
.Ft void
.Fn arg_printusage "struct getargs *args" "size_t num_args" "const char *progname" "const char *extra_string"
.Sh DESCRIPTION
.Fn getarg
collects any command line options given to a program in an easily used way.
.Fn arg_printusage
pretty-prints the available options, with a short help text.
.Pp
.Fa args
is the option specification to use, and it's an array of
.Fa struct getargs
elements.
.Fa num_args
is the size of
.Fa args
(in elements).
.Fa argc
and
.Fa argv
are the argument count and argument vector to extract option from.
.Fa optind
is a pointer to an integer where the index to the last processed
argument is stored, it must be initialised to the first index (minus
one) to process (normally 0) before the first call.
.Pp
.Fa arg_printusage
take the same
.Fa args
and
.Fa num_args
as getarg;
.Fa progname
is the name of the program (to be used in the help text), and
.Fa extra_string
is a string to print after the actual options to indicate more
arguments. The usefulness of this function is realised only be people
who has used programs that has help strings that doesn't match what
the code does.
.Pp
The
.Fa getargs
struct has the following elements.
.Bd -literal
struct getargs{
    const char *long_name;
    char short_name;
    enum { arg_integer,
	   arg_string,
	   arg_flag,
	   arg_negative_flag,
	   arg_strings,
	   arg_double,
           arg_collect
    } type;
    void *value;
    const char *help;
    const char *arg_help;
};
.Ed
.Pp
.Fa long_name
is the long name of the option, it can be
.Dv NULL ,
if you don't want a long name.
.Fa short_name
is the characted to use as short option, it can be zero. If the option
has a value the
.Fa value
field gets filled in with that value interpreted as specified by the
.Fa type
field.
.Fa help
is a longer help string for the option as a whole, if it's
.Dv NULL
the help text for the option is omitted (but it's still displayed in
the synopsis).
.Fa arg_help
is a description of the argument, if
.Dv NULL
a default value will be used, depending on the type of the option:
.Pp
.Bl -hang -width arg_negative_flag
.It arg_integer
the argument is a signed integer, and
.Fa value
should point to an
.Fa int .
.It Fa arg_string
the argument is a string, and
.Fa value
should point to a
.Fa char* .
.It Fa arg_flag
the argument is a flag, and
.Fa value
should point to a
.Fa int .
It gets filled in with either zero or one, depending on how the option
is given, the normal case being one. Note that if the option isn't
given, the value isn't altered, so it should be initialised to some
useful default.
.It Fa arg_negative_flag
this is the same as
.Fa arg_flag
but it reverses the meaning of the flag (a given short option clears
the flag), and the synopsis of a long option is negated.
.It Fa arg_strings
the argument can be given multiple times, and the values are collected
in an array;
.Fa value
should be a pointer to a
.Fa struct getarg_strings
structure, which holds a length and a string pointer.
.It Fa arg_double
argument is a double precision floating point value, and
.Fa value
should point to a
.Fa double .
.It Fa arg_collect
allows more fine-grained control of the option parsing process.
.Fa value
should be a pointer to a
.Fa getarg_collect_info
structure:
.Bd -literal
typedef int (*getarg_collect_func)(int short_opt,
				   int argc,
				   char **argv,
				   int *optind,
				   int *optarg,
				   void *data);

typedef struct getarg_collect_info {
    getarg_collect_func func;
    void *data;
} getarg_collect_info;
.Ed
.Pp
With the
.Fa func
member set to a function to call, and
.Fa data
to some application specific data. The parameters to the collect function are:
.Bl -inset
.It Fa short_flag
non-zero if this call is via a short option flag, zero otherwise
.It Fa argc , argv
the whole argument list
.It Fa optind
pointer to the index in argv where the flag is
.It Fa optarg
pointer to the index in argv[*optind] where the flag name starts
.It Fa data
application specific data
.El
.Pp
You can modify
.Fa *optind ,
and
.Fa *optarg ,
but to do this correct you (more or less) have to know about the inner
workings of getarg.
.Pp
You can skip parts of arguments by increasing
.Fa *optarg
(you could
implement the
.Fl z Ns Ar 3
set of flags from
.Nm gzip
with this), or whole argument strings by increasing
.Fa *optind
(let's say you want a flag
.Fl c Ar x y z
to specify a coordinate); if you also have to set
.Fa *optarg
to a sane value.
.Pp
The collect function should return one of
.Dv ARG_ERR_NO_MATCH , ARG_ERR_BAD_ARG , ARG_ERR_NO_ARG, ENOMEM
on error, zero otherwise.
.Pp
For your convenience there is a function,
.Fn getarg_optarg ,
that returns the traditional argument string, and you pass it all
arguments, sans data, that where given to the collection function.
.Pp
Don't use this more this unless you absolutely have to.
.El
.Pp
Option parsing is similar to what
.Xr getopt
uses. Short options without arguments can be compressed
.Pf ( Fl xyz
is the same as
.Fl x y z ) ,
and short
options with arguments take these as either the rest of the
argv-string or as the next option
.Pf ( Fl o Ns Ar foo ,
or
.Fl o Ar foo ) .
.Pp
Long option names are prefixed with -- (double dash), and the value
with a = (equal),
.Fl Fl foo= Ns Ar bar .
Long option flags can either be specified as they are
.Pf ( Fl Fl help ) ,
or with an (boolean parsable) option
.Pf ( Fl Fl help= Ns Ar yes ,
.Fl Fl help= Ns Ar true ,
or similar), or they can also be negated
.Pf ( Fl Fl no-help
is the same as
.Fl Fl help= Ns no ) ,
and if you're really confused you can do it multiple times
.Pf ( Fl Fl no-no-help= Ns Ar false ,
or even
.Fl Fl no-no-help= Ns Ar maybe ) .
.Sh EXAMPLE
.Bd -literal
#include <stdio.h>
#include <string.h>
#include <getarg.h>

char *source = "Ouagadougou";
char *destination;
int weight;
int include_catalog = 1;
int help_flag;

struct getargs args[] = {
    { "source",      's', arg_string,  &source,
      "source of shippment", "city" },
    { "destination", 'd', arg_string,  &destination,
      "destination of shippment", "city" },
    { "weight",      'w', arg_integer, &weight,
      "weight of shippment", "tons" },
    { "catalog",     'c', arg_negative_flag, &include_catalog,
      "include product catalog" },
    { "help",        'h', arg_flag, &help_flag }
};

int num_args = sizeof(args) / sizeof(args[0]); /* number of elements in args */

const char *progname = "ship++";

int
main(int argc, char **argv)
{
    int optind = 0;
    if (getarg(args, num_args, argc, argv, &optind)) {
	arg_printusage(args, num_args, progname, "stuff...");
	exit (1);
    }
    if (help_flag) {
	arg_printusage(args, num_args, progname, "stuff...");
	exit (0);
    }
    if (destination == NULL) {
	fprintf(stderr, "%s: must specify destination\en", progname);
	exit(1);
    }
    if (strcmp(source, destination) == 0) {
	fprintf(stderr, "%s: destination must be different from source\en");
	exit(1);
    }
    /* include more stuff here ... */
    exit(2);
}
.Ed
.Pp
The output help output from this program looks like this:
.Bd -literal
$ ship++ --help
Usage: ship++ [--source=city] [-s city] [--destination=city] [-d city]
   [--weight=tons] [-w tons] [--no-catalog] [-c] [--help] [-h] stuff...
-s city, --source=city      source of shippment
-d city, --destination=city destination of shippment
-w tons, --weight=tons      weight of shippment
-c, --no-catalog            include product catalog
.Ed
.Sh BUGS
It should be more flexible, so it would be possible to use other more
complicated option syntaxes, such as what
.Xr ps 1 ,
and
.Xr tar 1 ,
uses, or the AFS model where you can skip the flag names as long as
the options come in the correct order.
.Pp
Options with multiple arguments should be handled better.
.Pp
Should be integreated with SL.
.Pp
It's very confusing that the struct you pass in is called getargS.
.Sh SEE ALSO
.Xr getopt 3
@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d32 1
a32 1
.\" $Id$
@


1.1
log
@Initial revision
@
text
@d1 32
a32 2
.\" Copyright (c) 1999 Kungliga Tekniska Högskolan
.\" $KTH: getarg.3,v 1.3 2001/01/11 16:16:30 assar Exp $
d37 1
a37 1
.Nm getarg , 
d41 1
a41 1
.Fd #include <getarg.h>
d48 2
a49 2
collects any command line options given to a program in an easily used way. 
.Fn arg_printusage 
d53 1
a53 1
is the option specification to use, and it's an array of 
d76 1
a76 1
is the name of the program (to be used in the help text), and 
d90 4
a93 4
    enum { arg_integer, 
	   arg_string, 
	   arg_flag, 
	   arg_negative_flag, 
d105 1
a105 1
is the long name of the option, it can be 
d108 1
a108 1
.Fa short_name 
d112 1
a112 1
field gets filled in with that value interpreted as specified by the 
d140 1
a140 1
.Fa int . 
d142 1
a142 1
is given, the normal case beeing one. Note that if the option isn't
d146 1
a146 1
this is the same as 
d154 1
a154 1
should be a pointer to a 
d165 1
a165 1
should be a pointer to a 
d184 1
a184 1
member set to a function to call, and 
d202 1
a202 1
and 
d206 1
a206 1
.Pp 
d210 1
a210 1
implement the 
d216 1
a216 1
(let's say you want a flag 
d222 2
a223 2
The collect function should return one of 
.Dv ARG_ERR_NO_MATCH , ARG_ERR_BAD_ARG , ARG_ERR_NO_ARG
d234 1
a234 1
Option parsing is similar to what 
d249 3
a251 3
.Fl -foo= Ns Ar bar .
Long option flags can either be specified as they are 
.Pf ( Fl -help ) ,
d253 6
a258 6
.Pf ( Fl -help= Ns Ar yes ,
.Fl -help= Ns Ar true ,
or similar), or they can also be negated 
.Pf ( Fl -no-help
is the same as 
.Fl -help= Ns no ) ,
d260 3
a262 3
.Pf ( Fl -no-no-help= Ns Ar false ,
or even 
.Fl -no-no-help= Ns Ar maybe ) .
d276 1
a276 1
    { "source",      's', arg_string,  &source, 
d278 1
a278 1
    { "destination", 'd', arg_string,  &destination, 
d280 1
a280 1
    { "weight",      'w', arg_integer, &weight, 
d282 1
a282 1
    { "catalog",     'c', arg_negative_flag, &include_catalog, 
d318 1
a318 1
$ ship++ --help                                            
d330 1
a330 1
and 
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.6rc1
@
text
@d1 2
a2 32
.\" Copyright (c) 1999 - 2002 Kungliga Tekniska Högskolan
.\" (Royal Institute of Technology, Stockholm, Sweden). 
.\" All rights reserved. 
.\"
.\" Redistribution and use in source and binary forms, with or without 
.\" modification, are permitted provided that the following conditions 
.\" are met: 
.\"
.\" 1. Redistributions of source code must retain the above copyright 
.\"    notice, this list of conditions and the following disclaimer. 
.\"
.\" 2. Redistributions in binary form must reproduce the above copyright 
.\"    notice, this list of conditions and the following disclaimer in the 
.\"    documentation and/or other materials provided with the distribution. 
.\"
.\" 3. Neither the name of the Institute nor the names of its contributors 
.\"    may be used to endorse or promote products derived from this software 
.\"    without specific prior written permission. 
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
.\" SUCH DAMAGE. 
.\" 
.\" $KTH: getarg.3,v 1.7 2003/04/16 13:58:24 lha Exp $
d7 1
a7 1
.Nm getarg ,
d11 1
a11 1
.In getarg.h
d18 2
a19 2
collects any command line options given to a program in an easily used way.
.Fn arg_printusage
d23 1
a23 1
is the option specification to use, and it's an array of
d46 1
a46 1
is the name of the program (to be used in the help text), and
d60 4
a63 4
    enum { arg_integer,
	   arg_string,
	   arg_flag,
	   arg_negative_flag,
d75 1
a75 1
is the long name of the option, it can be
d78 1
a78 1
.Fa short_name
d82 1
a82 1
field gets filled in with that value interpreted as specified by the
d110 1
a110 1
.Fa int .
d112 1
a112 1
is given, the normal case being one. Note that if the option isn't
d116 1
a116 1
this is the same as
d124 1
a124 1
should be a pointer to a
d135 1
a135 1
should be a pointer to a
d154 1
a154 1
member set to a function to call, and
d172 1
a172 1
and
d176 1
a176 1
.Pp
d180 1
a180 1
implement the
d186 1
a186 1
(let's say you want a flag
d192 1
a192 1
The collect function should return one of
d204 1
a204 1
Option parsing is similar to what
d220 1
a220 1
Long option flags can either be specified as they are
d225 1
a225 1
or similar), or they can also be negated
d227 1
a227 1
is the same as
d231 1
a231 1
or even
d246 1
a246 1
    { "source",      's', arg_string,  &source,
d248 1
a248 1
    { "destination", 'd', arg_string,  &destination,
d250 1
a250 1
    { "weight",      'w', arg_integer, &weight,
d252 1
a252 1
    { "catalog",     'c', arg_negative_flag, &include_catalog,
d288 1
a288 1
$ ship++ --help
d300 1
a300 1
and
@


1.1.1.3
log
@Import of heimdal-0.7.2
@
text
@d32 1
a32 1
.\" $KTH: getarg.3,v 1.8 2004/02/17 12:04:59 lha Exp $
d223 1
a223 1
.Dv ARG_ERR_NO_MATCH , ARG_ERR_BAD_ARG , ARG_ERR_NO_ARG, ENOMEM
@


