head	1.10;
access;
symbols
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.28
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.26
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.24
	OPENBSD_5_0:1.8.0.22
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.20
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.18
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.14
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.04.22.10.01.33;	author reyk;	state dead;
branches;
next	1.9;

1.9
date	2013.06.17.18.57.45;	author robert;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.14.08.15.05;	author biorn;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.13.03.09.16;	author hin;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.20.14.44.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.12.23.20.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.28.21.31.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.06.00.37.37;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.17;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.17;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.50;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.16.07;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.13.03.00.27;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.43;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.10
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1995 - 2006 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include <config.h>

#include "roken.h"
#ifdef HAVE_ARPA_NAMESER_H
#include <arpa/nameser.h>
#endif
#ifdef HAVE_RESOLV_H
#include <resolv.h>
#endif
#ifdef HAVE_DNS_H
#include <dns.h>
#endif
#include "resolve.h"

#include <assert.h>

#ifdef _AIX /* AIX have broken res_nsearch() in 5.1 (5.0 also ?) */
#undef HAVE_RES_NSEARCH
#endif

#define DECL(X) {#X, rk_ns_t_##X}

static struct stot{
    const char *name;
    int type;
}stot[] = {
    DECL(a),
    DECL(aaaa),
    DECL(ns),
    DECL(cname),
    DECL(soa),
    DECL(ptr),
    DECL(mx),
    DECL(txt),
    DECL(afsdb),
    DECL(sig),
    DECL(key),
    DECL(srv),
    DECL(naptr),
    DECL(sshfp),
    DECL(ds),
    {NULL, 	0}
};

int _resolve_debug = 0;

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_dns_string_to_type(const char *name)
{
    struct stot *p = stot;
    for(p = stot; p->name; p++)
	if(strcasecmp(name, p->name) == 0)
	    return p->type;
    return -1;
}

ROKEN_LIB_FUNCTION const char * ROKEN_LIB_CALL
rk_dns_type_to_string(int type)
{
    struct stot *p = stot;
    for(p = stot; p->name; p++)
	if(type == p->type)
	    return p->name;
    return NULL;
}

#if ((defined(HAVE_RES_SEARCH) || defined(HAVE_RES_NSEARCH)) && defined(HAVE_DN_EXPAND)) || defined(HAVE_WINDNS)

static void
dns_free_rr(struct rk_resource_record *rr)
{
    if(rr->domain)
	free(rr->domain);
    if(rr->u.data)
	free(rr->u.data);
    free(rr);
}

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
rk_dns_free_data(struct rk_dns_reply *r)
{
    struct rk_resource_record *rr;
    if(r->q.domain)
	free(r->q.domain);
    for(rr = r->head; rr;){
	struct rk_resource_record *tmp = rr;
	rr = rr->next;
	dns_free_rr(tmp);
    }
    free (r);
}

#ifndef HAVE_WINDNS

static int
parse_record(const unsigned char *data, const unsigned char *end_data,
	     const unsigned char **pp, struct rk_resource_record **ret_rr)
{
    struct rk_resource_record *rr;
    int type, class, ttl;
    unsigned size;
    int status;
    char host[MAXDNAME];
    const unsigned char *p = *pp;

    *ret_rr = NULL;

    status = dn_expand(data, end_data, p, host, sizeof(host));
    if(status < 0)
	return -1;
    if (p + status + 10 > end_data)
	return -1;

    p += status;
    type = (p[0] << 8) | p[1];
    p += 2;
    class = (p[0] << 8) | p[1];
    p += 2;
    ttl = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
    p += 4;
    size = (p[0] << 8) | p[1];
    p += 2;

    if (p + size > end_data)
	return -1;

    rr = calloc(1, sizeof(*rr));
    if(rr == NULL)
	return -1;
    rr->domain = strdup(host);
    if(rr->domain == NULL) {
	dns_free_rr(rr);
	return -1;
    }
    rr->type = type;
    rr->class = class;
    rr->ttl = ttl;
    rr->size = size;
    switch(type){
    case rk_ns_t_ns:
    case rk_ns_t_cname:
    case rk_ns_t_ptr:
	status = dn_expand(data, end_data, p, host, sizeof(host));
	if(status < 0) {
	    dns_free_rr(rr);
	    return -1;
	}
	rr->u.txt = strdup(host);
	if(rr->u.txt == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}
	break;
    case rk_ns_t_mx:
    case rk_ns_t_afsdb:{
	size_t hostlen;

	status = dn_expand(data, end_data, p + 2, host, sizeof(host));
	if(status < 0){
	    dns_free_rr(rr);
	    return -1;
	}
	if ((size_t)status + 2 > size) {
	    dns_free_rr(rr);
	    return -1;
	}

	hostlen = strlen(host);
	rr->u.mx = (struct mx_record*)malloc(sizeof(struct mx_record) +
						hostlen);
	if(rr->u.mx == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}
	rr->u.mx->preference = (p[0] << 8) | p[1];
	strlcpy(rr->u.mx->domain, host, hostlen + 1);
	break;
    }
    case rk_ns_t_srv:{
	size_t hostlen;
	status = dn_expand(data, end_data, p + 6, host, sizeof(host));
	if(status < 0){
	    dns_free_rr(rr);
	    return -1;
	}
	if ((size_t)status + 6 > size) {
	    dns_free_rr(rr);
	    return -1;
	}

	hostlen = strlen(host);
	rr->u.srv =
	    (struct srv_record*)malloc(sizeof(struct srv_record) +
				       hostlen);
	if(rr->u.srv == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}
	rr->u.srv->priority = (p[0] << 8) | p[1];
	rr->u.srv->weight = (p[2] << 8) | p[3];
	rr->u.srv->port = (p[4] << 8) | p[5];
	strlcpy(rr->u.srv->target, host, hostlen + 1);
	break;
    }
    case rk_ns_t_txt:{
	if(size == 0 || size < (unsigned)(*p + 1)) {
	    dns_free_rr(rr);
	    return -1;
	}
	rr->u.txt = (char*)malloc(*p + 1);
	if(rr->u.txt == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}
	strncpy(rr->u.txt, (const char*)(p + 1), *p);
	rr->u.txt[*p] = '\0';
	break;
    }
    case rk_ns_t_key : {
	size_t key_len;

	if (size < 4) {
	    dns_free_rr(rr);
	    return -1;
	}

	key_len = size - 4;
	rr->u.key = malloc (sizeof(*rr->u.key) + key_len - 1);
	if (rr->u.key == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}

	rr->u.key->flags     = (p[0] << 8) | p[1];
	rr->u.key->protocol  = p[2];
	rr->u.key->algorithm = p[3];
	rr->u.key->key_len   = key_len;
	memcpy (rr->u.key->key_data, p + 4, key_len);
	break;
    }
    case rk_ns_t_sig : {
	size_t sig_len, hostlen;

	if(size <= 18) {
	    dns_free_rr(rr);
	    return -1;
	}
	status = dn_expand (data, end_data, p + 18, host, sizeof(host));
	if (status < 0) {
	    dns_free_rr(rr);
	    return -1;
	}
	if ((size_t)status + 18 > size) {
	    dns_free_rr(rr);
	    return -1;
	}

	/* the signer name is placed after the sig_data, to make it
           easy to free this structure; the size calculation below
           includes the zero-termination if the structure itself.
	   don't you just love C?
	*/
	sig_len = size - 18 - status;
	hostlen = strlen(host);
	rr->u.sig = malloc(sizeof(*rr->u.sig)
			      + hostlen + sig_len);
	if (rr->u.sig == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}
	rr->u.sig->type           = (p[0] << 8) | p[1];
	rr->u.sig->algorithm      = p[2];
	rr->u.sig->labels         = p[3];
	rr->u.sig->orig_ttl       = (p[4] << 24) | (p[5] << 16)
	    | (p[6] << 8) | p[7];
	rr->u.sig->sig_expiration = (p[8] << 24) | (p[9] << 16)
	    | (p[10] << 8) | p[11];
	rr->u.sig->sig_inception  = (p[12] << 24) | (p[13] << 16)
	    | (p[14] << 8) | p[15];
	rr->u.sig->key_tag        = (p[16] << 8) | p[17];
	rr->u.sig->sig_len        = sig_len;
	memcpy (rr->u.sig->sig_data, p + 18 + status, sig_len);
	rr->u.sig->signer         = &rr->u.sig->sig_data[sig_len];
	strlcpy(rr->u.sig->signer, host, hostlen + 1);
	break;
    }

    case rk_ns_t_cert : {
	size_t cert_len;

	if (size < 5) {
	    dns_free_rr(rr);
	    return -1;
	}

	cert_len = size - 5;
	rr->u.cert = malloc (sizeof(*rr->u.cert) + cert_len - 1);
	if (rr->u.cert == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}

	rr->u.cert->type      = (p[0] << 8) | p[1];
	rr->u.cert->tag       = (p[2] << 8) | p[3];
	rr->u.cert->algorithm = p[4];
	rr->u.cert->cert_len  = cert_len;
	memcpy (rr->u.cert->cert_data, p + 5, cert_len);
	break;
    }
    case rk_ns_t_sshfp : {
	size_t sshfp_len;

	if (size < 2) {
	    dns_free_rr(rr);
	    return -1;
	}

	sshfp_len = size - 2;

	rr->u.sshfp = malloc (sizeof(*rr->u.sshfp) + sshfp_len - 1);
	if (rr->u.sshfp == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}

	rr->u.sshfp->algorithm = p[0];
	rr->u.sshfp->type      = p[1];
	rr->u.sshfp->sshfp_len  = sshfp_len;
	memcpy (rr->u.sshfp->sshfp_data, p + 2, sshfp_len);
	break;
    }
    case rk_ns_t_ds: {
	size_t digest_len;

	if (size < 4) {
	    dns_free_rr(rr);
	    return -1;
	}

	digest_len = size - 4;

	rr->u.ds = malloc (sizeof(*rr->u.ds) + digest_len - 1);
	if (rr->u.ds == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}

	rr->u.ds->key_tag     = (p[0] << 8) | p[1];
	rr->u.ds->algorithm   = p[2];
	rr->u.ds->digest_type = p[3];
	rr->u.ds->digest_len  = digest_len;
	memcpy (rr->u.ds->digest_data, p + 4, digest_len);
	break;
    }
    default:
	rr->u.data = (unsigned char*)malloc(size);
	if(size != 0 && rr->u.data == NULL) {
	    dns_free_rr(rr);
	    return -1;
	}
	if (size)
	    memcpy(rr->u.data, p, size);
    }
    *pp = p + size;
    *ret_rr = rr;

    return 0;
}

#ifndef TEST_RESOLVE
static
#endif
struct rk_dns_reply*
parse_reply(const unsigned char *data, size_t len)
{
    const unsigned char *p;
    int status;
    size_t i;
    char host[MAXDNAME];
    const unsigned char *end_data = data + len;
    struct rk_dns_reply *r;
    struct rk_resource_record **rr;

    r = calloc(1, sizeof(*r));
    if (r == NULL)
	return NULL;

    p = data;

    r->h.id = (p[0] << 8) | p[1];
    r->h.flags = 0;
    if (p[2] & 0x01)
	r->h.flags |= rk_DNS_HEADER_RESPONSE_FLAG;
    r->h.opcode = (p[2] >> 1) & 0xf;
    if (p[2] & 0x20)
	r->h.flags |= rk_DNS_HEADER_AUTHORITIVE_ANSWER;
    if (p[2] & 0x40)
	r->h.flags |= rk_DNS_HEADER_TRUNCATED_MESSAGE;
    if (p[2] & 0x80)
	r->h.flags |= rk_DNS_HEADER_RECURSION_DESIRED;
    if (p[3] & 0x01)
	r->h.flags |= rk_DNS_HEADER_RECURSION_AVAILABLE;
    if (p[3] & 0x04)
	r->h.flags |= rk_DNS_HEADER_AUTHORITIVE_ANSWER;
    if (p[3] & 0x08)
	r->h.flags |= rk_DNS_HEADER_CHECKING_DISABLED;
    r->h.response_code = (p[3] >> 4) & 0xf;
    r->h.qdcount = (p[4] << 8) | p[5];
    r->h.ancount = (p[6] << 8) | p[7];
    r->h.nscount = (p[8] << 8) | p[9];
    r->h.arcount = (p[10] << 8) | p[11];

    p += 12;

    if(r->h.qdcount != 1) {
	free(r);
	return NULL;
    }
    status = dn_expand(data, end_data, p, host, sizeof(host));
    if(status < 0){
	rk_dns_free_data(r);
	return NULL;
    }
    r->q.domain = strdup(host);
    if(r->q.domain == NULL) {
	rk_dns_free_data(r);
	return NULL;
    }
    if (p + status + 4 > end_data) {
	rk_dns_free_data(r);
	return NULL;
    }
    p += status;
    r->q.type = (p[0] << 8 | p[1]);
    p += 2;
    r->q.class = (p[0] << 8 | p[1]);
    p += 2;

    rr = &r->head;
    for(i = 0; i < r->h.ancount; i++) {
	if(parse_record(data, end_data, &p, rr) != 0) {
	    rk_dns_free_data(r);
	    return NULL;
	}
	rr = &(*rr)->next;
    }
    for(i = 0; i < r->h.nscount; i++) {
	if(parse_record(data, end_data, &p, rr) != 0) {
	    rk_dns_free_data(r);
	    return NULL;
	}
	rr = &(*rr)->next;
    }
    for(i = 0; i < r->h.arcount; i++) {
	if(parse_record(data, end_data, &p, rr) != 0) {
	    rk_dns_free_data(r);
	    return NULL;
	}
	rr = &(*rr)->next;
    }
    *rr = NULL;
    return r;
}

#ifdef HAVE_RES_NSEARCH
#ifdef HAVE_RES_NDESTROY
#define rk_res_free(x) res_ndestroy(x)
#else
#define rk_res_free(x) res_nclose(x)
#endif
#endif

#if defined(HAVE_DNS_SEARCH)
#define resolve_search(h,n,c,t,r,l) \
    	((int)dns_search(h,n,c,t,r,l,(struct sockaddr *)&from,&fromsize))
#define resolve_free_handle(h) dns_free(h)
#elif defined(HAVE_RES_NSEARCH)
#define resolve_search(h,n,c,t,r,l) res_nsearch(h,n,c,t,r,l)
#define resolve_free_handle(h) rk_res_free(h);
#else
#define resolve_search(h,n,c,t,r,l) res_search(n,c,t,r,l)
#define handle 0
#define resolve_free_handle(h)
#endif


static struct rk_dns_reply *
dns_lookup_int(const char *domain, int rr_class, int rr_type)
{
    struct rk_dns_reply *r;
    void *reply = NULL;
    int size, len;
#if defined(HAVE_DNS_SEARCH)
    struct sockaddr_storage from;
    uint32_t fromsize = sizeof(from);
    dns_handle_t handle;

    handle = dns_open(NULL);
    if (handle == NULL)
	return NULL;
#elif defined(HAVE_RES_NSEARCH)
    struct __res_state state;
    struct __res_state *handle = &state;

    memset(&state, 0, sizeof(state));
    if(res_ninit(handle))
	return NULL; /* is this the best we can do? */
#endif

    len = 1500;
    while(1) {
	if (reply) {
	    free(reply);
	    reply = NULL;
	}
	if (_resolve_debug) {
#if defined(HAVE_DNS_SEARCH)
	    dns_set_debug(handle, 1);
#elif defined(HAVE_RES_NSEARCH)
	    state.options |= RES_DEBUG;
#endif
	    fprintf(stderr, "dns_lookup(%s, %d, %s), buffer size %d\n", domain,
		    rr_class, rk_dns_type_to_string(rr_type), len);
	}
	reply = malloc(len);
	if (reply == NULL) {
	    resolve_free_handle(handle);
	    return NULL;
	}

	size = resolve_search(handle, domain, rr_class, rr_type, reply, len);

	if (_resolve_debug) {
	    fprintf(stderr, "dns_lookup(%s, %d, %s) --> %d\n",
		    domain, rr_class, rk_dns_type_to_string(rr_type), size);
	}
	if (size > len) {
	    /* resolver thinks it know better, go for it */
	    len = size;
	} else if (size > 0) {
	    /* got a good reply */
	    break;
	} else if (size <= 0 && len < rk_DNS_MAX_PACKET_SIZE) {
	    len *= 2;
	    if (len > rk_DNS_MAX_PACKET_SIZE)
		len = rk_DNS_MAX_PACKET_SIZE;
	} else {
	    /* the end, leave */
	    resolve_free_handle(handle);
	    free(reply);
	    return NULL;
	}
    }

    len = min(len, size);
    r = parse_reply(reply, len);
    free(reply);

    resolve_free_handle(handle);

    return r;
}

ROKEN_LIB_FUNCTION struct rk_dns_reply * ROKEN_LIB_CALL
rk_dns_lookup(const char *domain, const char *type_name)
{
    int type;

    type = rk_dns_string_to_type(type_name);
    if(type == -1) {
	if(_resolve_debug)
	    fprintf(stderr, "dns_lookup: unknown resource type: `%s'\n",
		    type_name);
	return NULL;
    }
    return dns_lookup_int(domain, rk_ns_c_in, type);
}

#endif	/* !HAVE_WINDNS */

static int
compare_srv(const void *a, const void *b)
{
    const struct rk_resource_record *const* aa = a, *const* bb = b;

    if((*aa)->u.srv->priority == (*bb)->u.srv->priority)
	return ((*aa)->u.srv->weight - (*bb)->u.srv->weight);
    return ((*aa)->u.srv->priority - (*bb)->u.srv->priority);
}

/* try to rearrange the srv-records by the algorithm in RFC2782 */
ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
rk_dns_srv_order(struct rk_dns_reply *r)
{
    struct rk_resource_record **srvs, **ss, **headp;
    struct rk_resource_record *rr;
    int num_srv = 0;

    rk_random_init();

    for(rr = r->head; rr; rr = rr->next)
	if(rr->type == rk_ns_t_srv)
	    num_srv++;

    if(num_srv == 0)
	return;

    srvs = malloc(num_srv * sizeof(*srvs));
    if(srvs == NULL)
	return; /* XXX not much to do here */

    /* unlink all srv-records from the linked list and put them in
       a vector */
    for(ss = srvs, headp = &r->head; *headp; )
	if((*headp)->type == rk_ns_t_srv) {
	    *ss = *headp;
	    *headp = (*headp)->next;
	    (*ss)->next = NULL;
	    ss++;
	} else
	    headp = &(*headp)->next;

    /* sort them by priority and weight */
    qsort(srvs, num_srv, sizeof(*srvs), compare_srv);

    headp = &r->head;

    for(ss = srvs; ss < srvs + num_srv; ) {
	int sum, rnd, count;
	struct rk_resource_record **ee, **tt;
	/* find the last record with the same priority and count the
           sum of all weights */
	for(sum = 0, tt = ss; tt < srvs + num_srv; tt++) {
	    assert(*tt != NULL);
	    if((*tt)->u.srv->priority != (*ss)->u.srv->priority)
		break;
	    sum += (*tt)->u.srv->weight;
	}
	ee = tt;
	/* ss is now the first record of this priority and ee is the
           first of the next */
	while(ss < ee) {
	    rnd = rk_random() % (sum + 1);
	    for(count = 0, tt = ss; ; tt++) {
		if(*tt == NULL)
		    continue;
		count += (*tt)->u.srv->weight;
		if(count >= rnd)
		    break;
	    }

	    assert(tt < ee);

	    /* insert the selected record at the tail (of the head) of
               the list */
	    (*tt)->next = *headp;
	    *headp = *tt;
	    headp = &(*tt)->next;
	    sum -= (*tt)->u.srv->weight;
	    *tt = NULL;
	    while(ss < ee && *ss == NULL)
		ss++;
	}
    }

    free(srvs);
    return;
}

#ifdef HAVE_WINDNS

#include <WinDNS.h>

static struct rk_resource_record *
parse_dns_record(PDNS_RECORD pRec)
{
    struct rk_resource_record * rr;

    if (pRec == NULL)
	return NULL;

    rr = calloc(1, sizeof(*rr));

    rr->domain = strdup(pRec->pName);
    rr->type = pRec->wType;
    rr->class = 0;
    rr->ttl = pRec->dwTtl;
    rr->size = 0;

    switch (rr->type) {
    case rk_ns_t_ns:
    case rk_ns_t_cname:
    case rk_ns_t_ptr:
	rr->u.txt = strdup(pRec->Data.NS.pNameHost);
	if(rr->u.txt == NULL) {
	    dns_free_rr(rr);
	    return NULL;
	}
	break;

    case rk_ns_t_mx:
    case rk_ns_t_afsdb:{
	size_t hostlen = strnlen(pRec->Data.MX.pNameExchange, DNS_MAX_NAME_LENGTH);

	rr->u.mx = (struct mx_record *)malloc(sizeof(struct mx_record) +
					      hostlen);
	if (rr->u.mx == NULL) {
	    dns_free_rr(rr);
	    return NULL;
	}

	strcpy_s(rr->u.mx->domain, hostlen + 1, pRec->Data.MX.pNameExchange);
	rr->u.mx->preference = pRec->Data.MX.wPreference;
	break;
    }

    case rk_ns_t_srv:{
	size_t hostlen = strnlen(pRec->Data.SRV.pNameTarget, DNS_MAX_NAME_LENGTH);

	rr->u.srv =
	    (struct srv_record*)malloc(sizeof(struct srv_record) +
				       hostlen);
	if(rr->u.srv == NULL) {
	    dns_free_rr(rr);
	    return NULL;
	}

	rr->u.srv->priority = pRec->Data.SRV.wPriority;
	rr->u.srv->weight = pRec->Data.SRV.wWeight;
	rr->u.srv->port = pRec->Data.SRV.wPort;
	strcpy_s(rr->u.srv->target, hostlen + 1, pRec->Data.SRV.pNameTarget);

	break;
    }

    case rk_ns_t_txt:{
	size_t len;

	if (pRec->Data.TXT.dwStringCount == 0) {
	    rr->u.txt = strdup("");
	    break;
	}

	len = strnlen(pRec->Data.TXT.pStringArray[0], DNS_MAX_TEXT_STRING_LENGTH);

	rr->u.txt = (char *)malloc(len + 1);
	strcpy_s(rr->u.txt, len + 1, pRec->Data.TXT.pStringArray[0]);

	break;
    }

    case rk_ns_t_key : {
	size_t key_len;

	if (pRec->wDataLength < 4) {
	    dns_free_rr(rr);
	    return NULL;
	}

	key_len = pRec->wDataLength - 4;
	rr->u.key = malloc (sizeof(*rr->u.key) + key_len - 1);
	if (rr->u.key == NULL) {
	    dns_free_rr(rr);
	    return NULL;
	}

	rr->u.key->flags     = pRec->Data.KEY.wFlags;
	rr->u.key->protocol  = pRec->Data.KEY.chProtocol;
	rr->u.key->algorithm = pRec->Data.KEY.chAlgorithm;
	rr->u.key->key_len   = key_len;
	memcpy_s (rr->u.key->key_data, key_len,
		  pRec->Data.KEY.Key, key_len);
	break;
    }

    case rk_ns_t_sig : {
	size_t sig_len, hostlen;

	if(pRec->wDataLength <= 18) {
	    dns_free_rr(rr);
	    return NULL;
	}

	sig_len = pRec->wDataLength;

	hostlen = strnlen(pRec->Data.SIG.pNameSigner, DNS_MAX_NAME_LENGTH);

	rr->u.sig = malloc(sizeof(*rr->u.sig)
			      + hostlen + sig_len);
	if (rr->u.sig == NULL) {
	    dns_free_rr(rr);
	    return NULL;
	}
	rr->u.sig->type           = pRec->Data.SIG.wTypeCovered;
	rr->u.sig->algorithm      = pRec->Data.SIG.chAlgorithm;
	rr->u.sig->labels         = pRec->Data.SIG.chLabelCount;
	rr->u.sig->orig_ttl       = pRec->Data.SIG.dwOriginalTtl;
	rr->u.sig->sig_expiration = pRec->Data.SIG.dwExpiration;
	rr->u.sig->sig_inception  = pRec->Data.SIG.dwTimeSigned;
	rr->u.sig->key_tag        = pRec->Data.SIG.wKeyTag;
	rr->u.sig->sig_len        = sig_len;
	memcpy_s (rr->u.sig->sig_data, sig_len,
		  pRec->Data.SIG.Signature, sig_len);
	rr->u.sig->signer         = &rr->u.sig->sig_data[sig_len];
	strcpy_s(rr->u.sig->signer, hostlen + 1, pRec->Data.SIG.pNameSigner);
	break;
    }

#ifdef DNS_TYPE_DS
    case rk_ns_t_ds: {
	rr->u.ds = malloc (sizeof(*rr->u.ds) + pRec->Data.DS.wDigestLength - 1);
	if (rr->u.ds == NULL) {
	    dns_free_rr(rr);
	    return NULL;
	}

	rr->u.ds->key_tag     = pRec->Data.DS.wKeyTag;
	rr->u.ds->algorithm   = pRec->Data.DS.chAlgorithm;
	rr->u.ds->digest_type = pRec->Data.DS.chDigestType;
	rr->u.ds->digest_len  = pRec->Data.DS.wDigestLength;
	memcpy_s (rr->u.ds->digest_data, pRec->Data.DS.wDigestLength,
		  pRec->Data.DS.Digest, pRec->Data.DS.wDigestLength);
	break;
    }
#endif

    default:
	dns_free_rr(rr);
	return NULL;
    }

    rr->next = parse_dns_record(pRec->pNext);
    return rr;
}

ROKEN_LIB_FUNCTION struct rk_dns_reply * ROKEN_LIB_CALL
rk_dns_lookup(const char *domain, const char *type_name)
{
    DNS_STATUS status;
    int type;
    PDNS_RECORD pRec = NULL;
    struct rk_dns_reply * r = NULL;

    __try {

	type = rk_dns_string_to_type(type_name);
	if(type == -1) {
	    if(_resolve_debug)
		fprintf(stderr, "dns_lookup: unknown resource type: `%s'\n",
			type_name);
	    return NULL;
	}

	status = DnsQuery_UTF8(domain, type, DNS_QUERY_STANDARD, NULL,
			       &pRec, NULL);
	if (status != ERROR_SUCCESS)
	    return NULL;

	r = calloc(1, sizeof(*r));
	r->q.domain = strdup(domain);
	r->q.type = type;
	r->q.class = 0;

	r->head = parse_dns_record(pRec);

	if (r->head == NULL) {
	    rk_dns_free_data(r);
	    return NULL;
	} else {
	    return r;
	}

    } __finally {

	if (pRec)
	    DnsRecordListFree(pRec, DnsFreeRecordList);

    }
}
#endif	/* HAVE_WINDNS */

#else /* NOT defined(HAVE_RES_SEARCH) && defined(HAVE_DN_EXPAND) */

ROKEN_LIB_FUNCTION struct rk_dns_reply * ROKEN_LIB_CALL
rk_dns_lookup(const char *domain, const char *type_name)
{
    return NULL;
}

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
rk_dns_free_data(struct rk_dns_reply *r)
{
}

ROKEN_LIB_FUNCTION void ROKEN_LIB_CALL
rk_dns_srv_order(struct rk_dns_reply *r)
{
}

#endif
@


1.9
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.8
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2004 Kungliga Tekniska Högskolan
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d12 1
a12 1
 * 
d16 1
a16 1
 * 
d20 1
a20 1
 * 
d34 1
a34 1
#ifdef HAVE_CONFIG_H
d36 1
a36 1
#endif
d44 3
a50 2
RCSID("$KTH: resolve.c,v 1.50 2005/04/12 11:29:01 lha Exp $");

d81 2
a82 2
int ROKEN_LIB_FUNCTION
dns_string_to_type(const char *name)
d91 2
a92 2
const char * ROKEN_LIB_FUNCTION
dns_type_to_string(int type)
d101 1
a101 1
#if (defined(HAVE_RES_SEARCH) || defined(HAVE_RES_NSEARCH)) && defined(HAVE_DN_EXPAND)
d103 2
a104 2
void ROKEN_LIB_FUNCTION
dns_free_data(struct dns_reply *r)
d106 11
a116 1
    struct resource_record *rr;
d120 1
a120 5
	struct resource_record *tmp = rr;
	if(rr->domain)
	    free(rr->domain);
	if(rr->u.data)
	    free(rr->u.data);
d122 1
a122 1
	free(tmp);
d127 2
d130 2
a131 2
parse_record(const unsigned char *data, const unsigned char *end_data, 
	     const unsigned char **pp, struct resource_record **rr)
d133 3
a135 1
    int type, class, ttl, size;
d139 3
d143 1
a143 1
    if(status < 0) 
d147 1
d161 2
a162 2
    *rr = calloc(1, sizeof(**rr));
    if(*rr == NULL) 
d164 3
a166 3
    (*rr)->domain = strdup(host);
    if((*rr)->domain == NULL) {
	free(*rr);
d169 4
a172 4
    (*rr)->type = type;
    (*rr)->class = class;
    (*rr)->ttl = ttl;
    (*rr)->size = size;
d179 1
a179 1
	    free(*rr);
d182 3
a184 3
	(*rr)->u.txt = strdup(host);
	if((*rr)->u.txt == NULL) {
	    free(*rr);
d194 1
a194 1
	    free(*rr);
d197 2
a198 2
	if (status + 2 > size) {
	    free(*rr);
d203 1
a203 1
	(*rr)->u.mx = (struct mx_record*)malloc(sizeof(struct mx_record) + 
d205 2
a206 2
	if((*rr)->u.mx == NULL) {
	    free(*rr);
d209 2
a210 2
	(*rr)->u.mx->preference = (p[0] << 8) | p[1];
	strlcpy((*rr)->u.mx->domain, host, hostlen + 1);
d217 1
a217 1
	    free(*rr);
d220 2
a221 2
	if (status + 6 > size) {
	    free(*rr);
d226 2
a227 2
	(*rr)->u.srv = 
	    (struct srv_record*)malloc(sizeof(struct srv_record) + 
d229 2
a230 2
	if((*rr)->u.srv == NULL) {
	    free(*rr);
d233 4
a236 4
	(*rr)->u.srv->priority = (p[0] << 8) | p[1];
	(*rr)->u.srv->weight = (p[2] << 8) | p[3];
	(*rr)->u.srv->port = (p[4] << 8) | p[5];
	strlcpy((*rr)->u.srv->target, host, hostlen + 1);
d240 2
a241 2
	if(size == 0 || size < *p + 1) {
	    free(*rr);
d244 3
a246 3
	(*rr)->u.txt = (char*)malloc(*p + 1);
	if((*rr)->u.txt == NULL) {
	    free(*rr);
d249 2
a250 2
	strncpy((*rr)->u.txt, (char*)p + 1, *p);
	(*rr)->u.txt[*p] = '\0';
d257 1
a257 1
	    free(*rr);
d262 3
a264 3
	(*rr)->u.key = malloc (sizeof(*(*rr)->u.key) + key_len - 1);
	if ((*rr)->u.key == NULL) {
	    free(*rr);
d268 5
a272 5
	(*rr)->u.key->flags     = (p[0] << 8) | p[1];
	(*rr)->u.key->protocol  = p[2];
	(*rr)->u.key->algorithm = p[3];
	(*rr)->u.key->key_len   = key_len;
	memcpy ((*rr)->u.key->key_data, p + 4, key_len);
d279 1
a279 1
	    free(*rr);
d284 1
a284 1
	    free(*rr);
d287 2
a288 2
	if (status + 18 > size) {
	    free(*rr);
d293 1
a293 1
           easy to free this struture; the size calculation below
d299 1
a299 1
	(*rr)->u.sig = malloc(sizeof(*(*rr)->u.sig)
d301 2
a302 2
	if ((*rr)->u.sig == NULL) {
	    free(*rr);
d305 4
a308 4
	(*rr)->u.sig->type           = (p[0] << 8) | p[1];
	(*rr)->u.sig->algorithm      = p[2];
	(*rr)->u.sig->labels         = p[3];
	(*rr)->u.sig->orig_ttl       = (p[4] << 24) | (p[5] << 16)
d310 1
a310 1
	(*rr)->u.sig->sig_expiration = (p[8] << 24) | (p[9] << 16)
d312 1
a312 1
	(*rr)->u.sig->sig_inception  = (p[12] << 24) | (p[13] << 16)
d314 5
a318 5
	(*rr)->u.sig->key_tag        = (p[16] << 8) | p[17];
	(*rr)->u.sig->sig_len        = sig_len;
	memcpy ((*rr)->u.sig->sig_data, p + 18 + status, sig_len);
	(*rr)->u.sig->signer         = &(*rr)->u.sig->sig_data[sig_len];
	strlcpy((*rr)->u.sig->signer, host, hostlen + 1);
d326 1
a326 1
	    free(*rr);
d331 3
a333 3
	(*rr)->u.cert = malloc (sizeof(*(*rr)->u.cert) + cert_len - 1);
	if ((*rr)->u.cert == NULL) {
	    free(*rr);
d337 5
a341 5
	(*rr)->u.cert->type      = (p[0] << 8) | p[1];
	(*rr)->u.cert->tag       = (p[2] << 8) | p[3];
	(*rr)->u.cert->algorithm = p[4];
	(*rr)->u.cert->cert_len  = cert_len;
	memcpy ((*rr)->u.cert->cert_data, p + 5, cert_len);
d348 1
a348 1
	    free(*rr);
d354 3
a356 3
	(*rr)->u.sshfp = malloc (sizeof(*(*rr)->u.sshfp) + sshfp_len - 1);
	if ((*rr)->u.sshfp == NULL) {
	    free(*rr);
d360 4
a363 4
	(*rr)->u.sshfp->algorithm = p[0];
	(*rr)->u.sshfp->type      = p[1];
	(*rr)->u.sshfp->sshfp_len  = sshfp_len;
	memcpy ((*rr)->u.sshfp->sshfp_data, p + 2, sshfp_len);
d370 1
a370 1
	    free(*rr);
d376 3
a378 3
	(*rr)->u.ds = malloc (sizeof(*(*rr)->u.ds) + digest_len - 1);
	if ((*rr)->u.ds == NULL) {
	    free(*rr);
d382 5
a386 5
	(*rr)->u.ds->key_tag     = (p[0] << 8) | p[1];
	(*rr)->u.ds->algorithm   = p[2];
	(*rr)->u.ds->digest_type = p[3];
	(*rr)->u.ds->digest_len  = digest_len;
	memcpy ((*rr)->u.ds->digest_data, p + 4, digest_len);
d390 3
a392 3
	(*rr)->u.data = (unsigned char*)malloc(size);
	if(size != 0 && (*rr)->u.data == NULL) {
	    free(*rr);
d395 2
a396 1
	memcpy((*rr)->u.data, p, size);
d399 2
d407 1
a407 1
struct dns_reply*
d412 1
a412 1
    int i;
d415 3
a417 3
    struct dns_reply *r;
    struct resource_record **rr;
    
d455 1
a455 1
	dns_free_data(r);
d460 1
a460 1
	dns_free_data(r);
d464 1
a464 1
	dns_free_data(r);
d472 1
a472 1
    
d476 1
a476 1
	    dns_free_data(r);
d483 1
a483 1
	    dns_free_data(r);
d490 1
a490 1
	    dns_free_data(r);
d499 23
a521 1
static struct dns_reply *
d524 12
a535 5
    struct dns_reply *r;
    unsigned char *reply = NULL;
    int size;
    int len;
#ifdef HAVE_RES_NSEARCH
d537 2
d540 1
a540 1
    if(res_ninit(&state))
a541 2
#elif defined(HAVE__RES)
    u_long old_options = 0;
d543 3
a545 4
    
    size = 0;
    len = 1000;
    do {
a549 2
	if (size <= len)
	    size = len;
d551 3
a553 1
#ifdef HAVE_RES_NSEARCH
a554 3
#elif defined(HAVE__RES)
	    old_options = _res.options;
	    _res.options |= RES_DEBUG;
d557 1
a557 1
		    rr_class, dns_type_to_string(rr_type), size);
d559 1
a559 1
	reply = malloc(size);
d561 1
a561 3
#ifdef HAVE_RES_NSEARCH
	    res_nclose(&state);
#endif
d564 3
a566 5
#ifdef HAVE_RES_NSEARCH
	len = res_nsearch(&state, domain, rr_class, rr_type, reply, size);
#else
	len = res_search(domain, rr_class, rr_type, reply, size);
#endif
a567 3
#if defined(HAVE__RES) && !defined(HAVE_RES_NSEARCH)
	    _res.options = old_options;
#endif
d569 1
a569 1
		    domain, rr_class, dns_type_to_string(rr_type), len);
d571 13
a583 4
	if (len < 0) {
#ifdef HAVE_RES_NSEARCH
	    res_nclose(&state);
#endif
d587 1
a587 4
    } while (size < len && len < rk_DNS_MAX_PACKET_SIZE);
#ifdef HAVE_RES_NSEARCH
    res_nclose(&state);
#endif
d592 3
d598 2
a599 2
struct dns_reply * ROKEN_LIB_FUNCTION
dns_lookup(const char *domain, const char *type_name)
d602 2
a603 2
    
    type = dns_string_to_type(type_name);
d606 1
a606 1
	    fprintf(stderr, "dns_lookup: unknown resource type: `%s'\n", 
d610 1
a610 1
    return dns_lookup_int(domain, C_IN, type);
d613 2
d618 1
a618 1
    const struct resource_record *const* aa = a, *const* bb = b;
a624 4
#ifndef HAVE_RANDOM
#define random() rand()
#endif

d626 2
a627 2
void ROKEN_LIB_FUNCTION
dns_srv_order(struct dns_reply *r)
d629 2
a630 2
    struct resource_record **srvs, **ss, **headp;
    struct resource_record *rr;
d633 1
a633 4
#if defined(HAVE_INITSTATE) && defined(HAVE_SETSTATE)
    int state[256 / sizeof(int)];
    char *oldstate;
#endif
d635 1
a635 1
    for(rr = r->head; rr; rr = rr->next) 
d645 1
a645 1
    
d656 1
a656 1
    
d660 1
a660 3
#if defined(HAVE_INITSTATE) && defined(HAVE_SETSTATE)
    oldstate = initstate(time(NULL), (char*)state, sizeof(state));
#endif
a661 2
    headp = &r->head;
    
d664 1
a664 1
	struct resource_record **ee, **tt;
d668 1
a668 2
	    if(*tt == NULL)
		continue;
d677 1
a677 1
	    rnd = random() % (sum + 1);
d699 1
a699 4
    
#if defined(HAVE_INITSTATE) && defined(HAVE_SETSTATE)
    setstate(oldstate);
#endif
d704 212
d918 2
a919 2
struct dns_reply * ROKEN_LIB_FUNCTION
dns_lookup(const char *domain, const char *type_name)
d924 2
a925 2
void ROKEN_LIB_FUNCTION
dns_free_data(struct dns_reply *r)
d929 2
a930 2
void ROKEN_LIB_FUNCTION
dns_srv_order(struct dns_reply *r)
@


1.7
log
@Merge with heimdal-0.6
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d48 1
a48 1
RCSID("$KTH: resolve.c,v 1.38.2.1 2003/04/22 15:02:47 lha Exp $");
d50 1
d52 1
a52 1
#if (defined(HAVE_RES_SEARCH) || defined(HAVE_RES_NSEARCH)) && defined(HAVE_DN_EXPAND)
d54 1
a54 1
#define DECL(X) {#X, T_##X}
d60 15
a74 12
    DECL(A),
    DECL(NS),
    DECL(CNAME),
    DECL(SOA),
    DECL(PTR),
    DECL(MX),
    DECL(TXT),
    DECL(AFSDB),
    DECL(SIG),
    DECL(KEY),
    DECL(SRV),
    DECL(NAPTR),
d80 1
a80 1
int
d90 1
a90 1
const char *
d100 3
a102 1
void
d159 3
a161 3
    case T_NS:
    case T_CNAME:
    case T_PTR:
d173 2
a174 2
    case T_MX:
    case T_AFSDB:{
d198 1
a198 1
    case T_SRV:{
d224 1
a224 1
    case T_TXT:{
d238 1
a238 1
    case T_KEY : {
d260 1
a260 1
    case T_SIG : {
d307 1
a307 1
    case T_CERT : {
d329 45
d405 24
a428 6
#if 0
    /* doesn't work on Crays */
    memcpy(&r->h, p, sizeof(HEADER));
    p += sizeof(HEADER);
#else
    memcpy(&r->h, p, 12); /* XXX this will probably be mostly garbage */
d430 2
a431 2
#endif
    if(ntohs(r->h.qdcount) != 1) {
d456 1
a456 1
    for(i = 0; i < ntohs(r->h.ancount); i++) {
d463 1
a463 1
    for(i = 0; i < ntohs(r->h.nscount); i++) {
d470 1
a470 1
    for(i = 0; i < ntohs(r->h.arcount); i++) {
d484 3
a486 1
    unsigned char reply[1024];
d489 3
a491 3
    struct __res_state stat;
    memset(&stat, 0, sizeof(stat));
    if(res_ninit(&stat))
d497 10
a506 1
    if (_resolve_debug) {
d508 1
a508 1
	stat.options |= RES_DEBUG;
d510 2
a511 2
        old_options = _res.options;
	_res.options |= RES_DEBUG;
d513 10
a522 3
	fprintf(stderr, "dns_lookup(%s, %d, %s)\n", domain,
		rr_class, dns_type_to_string(rr_type));
    }
d524 1
a524 1
    len = res_nsearch(&stat, domain, rr_class, rr_type, reply, sizeof(reply));
d526 1
a526 1
    len = res_search(domain, rr_class, rr_type, reply, sizeof(reply));
d528 1
a528 1
    if (_resolve_debug) {
d530 8
a537 1
        _res.options = old_options;
d539 4
a542 3
	fprintf(stderr, "dns_lookup(%s, %d, %s) --> %d\n",
		domain, rr_class, dns_type_to_string(rr_type), len);
    }
d544 7
a550 8
    res_nclose(&stat);
#endif    
    if(len < 0) {
	return NULL;
    } else {
	len = min(len, sizeof(reply));
	return parse_reply(reply, len);
    }
d553 1
a553 1
struct dns_reply *
d583 1
a583 1
void
d596 1
a596 1
	if(rr->type == T_SRV)
d609 1
a609 1
	if((*headp)->type == T_SRV) {
d674 1
a674 1
struct dns_reply *
d680 1
a680 1
void
d685 1
a685 1
void
a689 68
#endif

#ifdef TEST
int 
main(int argc, char **argv)
{
    struct dns_reply *r;
    struct resource_record *rr;
    r = dns_lookup(argv[1], argv[2]);
    if(r == NULL){
	printf("No reply.\n");
	return 1;
    }
    if(r->q.type == T_SRV)
	dns_srv_order(r);

    for(rr = r->head; rr;rr=rr->next){
	printf("%-30s %-5s %-6d ", rr->domain, dns_type_to_string(rr->type), rr->ttl);
	switch(rr->type){
	case T_NS:
	case T_CNAME:
	case T_PTR:
	    printf("%s\n", (char*)rr->u.data);
	    break;
	case T_A:
	    printf("%s\n", inet_ntoa(*rr->u.a));
	    break;
	case T_MX:
	case T_AFSDB:{
	    printf("%d %s\n", rr->u.mx->preference, rr->u.mx->domain);
	    break;
	}
	case T_SRV:{
	    struct srv_record *srv = rr->u.srv;
	    printf("%d %d %d %s\n", srv->priority, srv->weight, 
		   srv->port, srv->target);
	    break;
	}
	case T_TXT: {
	    printf("%s\n", rr->u.txt);
	    break;
	}
	case T_SIG : {
	    struct sig_record *sig = rr->u.sig;
	    const char *type_string = dns_type_to_string (sig->type);

	    printf ("type %u (%s), algorithm %u, labels %u, orig_ttl %u, sig_expiration %u, sig_inception %u, key_tag %u, signer %s\n",
		    sig->type, type_string ? type_string : "",
		    sig->algorithm, sig->labels, sig->orig_ttl,
		    sig->sig_expiration, sig->sig_inception, sig->key_tag,
		    sig->signer);
	    break;
	}
	case T_KEY : {
	    struct key_record *key = rr->u.key;

	    printf ("flags %u, protocol %u, algorithm %u\n",
		    key->flags, key->protocol, key->algorithm);
	    break;
	}
	default:
	    printf("\n");
	    break;
	}
    }
    
    return 0;
}
@


1.6
log
@Merge 0.6rc1
@
text
@d48 1
a48 1
RCSID("$Id: resolve.c,v 1.1.1.3 2003/05/11 02:16:07 hin Exp $");
@


1.5
log
@correct strlpcy; spotted by janj+openbsd@@wenf.org
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d48 1
a48 1
RCSID("$KTH: resolve.c,v 1.28 2001/08/07 21:57:01 assar Exp $");
d50 2
a51 1
#if defined(HAVE_RES_SEARCH) && defined(HAVE_DN_EXPAND)
d114 3
a116 2
static struct dns_reply*
parse_reply(unsigned char *data, int len)
d118 1
a118 2
    unsigned char *p;
    char host[128];
d120 226
a345 2
    size_t l;
    
d362 5
a366 1
    status = dn_expand(data, data + len, p, host, sizeof(host));
d376 4
d385 1
d387 2
a388 4
    while(p < data + len){
	int type, class, ttl, size;
	status = dn_expand(data, data + len, p, host, sizeof(host));
	if(status < 0){
d392 4
a395 12
	p += status;
	type = (p[0] << 8) | p[1];
	p += 2;
	class = (p[0] << 8) | p[1];
	p += 2;
	ttl = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
	p += 4;
	size = (p[0] << 8) | p[1];
	p += 2;
	*rr = (struct resource_record*)calloc(1, 
					      sizeof(struct resource_record));
	if(*rr == NULL) {
d399 4
a402 2
	(*rr)->domain = strdup(host);
	if((*rr)->domain == NULL) {
a405 142
	(*rr)->type = type;
	(*rr)->class = class;
	(*rr)->ttl = ttl;
	(*rr)->size = size;
	switch(type){
	case T_NS:
	case T_CNAME:
	case T_PTR:
	    status = dn_expand(data, data + len, p, host, sizeof(host));
	    if(status < 0){
		dns_free_data(r);
		return NULL;
	    }
	    (*rr)->u.txt = strdup(host);
	    if((*rr)->u.txt == NULL) {
		dns_free_data(r);
		return NULL;
	    }
	    break;
	case T_MX:
	case T_AFSDB:{
	    status = dn_expand(data, data + len, p + 2, host, sizeof(host));
	    if(status < 0){
		dns_free_data(r);
		return NULL;
	    }
	    l = strlen(host);		/* NUL in struct */
	    (*rr)->u.mx = (struct mx_record*)malloc(sizeof(struct mx_record) + 
						    l);
	    if((*rr)->u.mx == NULL) {
		dns_free_data(r);
		return NULL;
	    }
	    (*rr)->u.mx->preference = (p[0] << 8) | p[1];
	    strlcpy((*rr)->u.mx->domain, host, l + 1);
	    break;
	}
	case T_SRV:{
	    status = dn_expand(data, data + len, p + 6, host, sizeof(host));
	    if(status < 0){
		dns_free_data(r);
		return NULL;
	    }
	    l = strlen(host);		/* NUL in struct */
	    (*rr)->u.srv = 
		(struct srv_record*)malloc(sizeof(struct srv_record) + l);
	    if((*rr)->u.srv == NULL) {
		dns_free_data(r);
		return NULL;
	    }
	    (*rr)->u.srv->priority = (p[0] << 8) | p[1];
	    (*rr)->u.srv->weight = (p[2] << 8) | p[3];
	    (*rr)->u.srv->port = (p[4] << 8) | p[5];
	    strlcpy((*rr)->u.srv->target, host, l + 1);
	    break;
	}
	case T_TXT:{
	    (*rr)->u.txt = (char*)malloc(size + 1);
	    if((*rr)->u.txt == NULL) {
		dns_free_data(r);
		return NULL;
	    }
	    strncpy((*rr)->u.txt, (char*)p + 1, *p);
	    (*rr)->u.txt[*p] = 0;
	    break;
	}
	case T_KEY : {
	    size_t key_len;

	    key_len = size - 4;
	    (*rr)->u.key = malloc (sizeof(*(*rr)->u.key) + key_len - 1);
	    if ((*rr)->u.key == NULL) {
		dns_free_data (r);
		return NULL;
	    }

	    (*rr)->u.key->flags     = (p[0] << 8) | p[1];
	    (*rr)->u.key->protocol  = p[2];
	    (*rr)->u.key->algorithm = p[3];
	    (*rr)->u.key->key_len   = key_len;
	    memcpy ((*rr)->u.key->key_data, p + 4, key_len);
	    break;
	}
	case T_SIG : {
	    size_t sig_len;

	    status = dn_expand (data, data + len, p + 18, host, sizeof(host));
	    if (status < 0) {
		dns_free_data (r);
		return NULL;
	    }
	    sig_len = len - 18 - status;
	    l = strlen(host);		/* NUL in struct */
	    (*rr)->u.sig = malloc(sizeof(*(*rr)->u.sig)
				  + l + sig_len);
	    if ((*rr)->u.sig == NULL) {
		dns_free_data (r);
		return NULL;
	    }
	    (*rr)->u.sig->type           = (p[0] << 8) | p[1];
	    (*rr)->u.sig->algorithm      = p[2];
	    (*rr)->u.sig->labels         = p[3];
	    (*rr)->u.sig->orig_ttl       = (p[4] << 24) | (p[5] << 16)
		| (p[6] << 8) | p[7];
	    (*rr)->u.sig->sig_expiration = (p[8] << 24) | (p[9] << 16)
		| (p[10] << 8) | p[11];
	    (*rr)->u.sig->sig_inception  = (p[12] << 24) | (p[13] << 16)
		| (p[14] << 8) | p[15];
	    (*rr)->u.sig->key_tag        = (p[16] << 8) | p[17];
	    (*rr)->u.sig->sig_len        = sig_len;
	    memcpy ((*rr)->u.sig->sig_data, p + 18 + status, sig_len);
	    (*rr)->u.sig->signer         = &(*rr)->u.sig->sig_data[sig_len];
	    strlcpy((*rr)->u.sig->signer, host, l + 1);
	    break;
	}

	case T_CERT : {
	    size_t cert_len;

	    cert_len = size - 5;
	    (*rr)->u.cert = malloc (sizeof(*(*rr)->u.cert) + cert_len - 1);
	    if ((*rr)->u.cert == NULL) {
		dns_free_data (r);
		return NULL;
	    }

	    (*rr)->u.cert->type      = (p[0] << 8) | p[1];
	    (*rr)->u.cert->tag       = (p[2] << 8) | p[3];
	    (*rr)->u.cert->algorithm = p[4];
	    (*rr)->u.cert->cert_len  = cert_len;
	    memcpy ((*rr)->u.cert->cert_data, p + 5, cert_len);
	    break;
	}
	default:
	    (*rr)->u.data = (unsigned char*)malloc(size);
	    if(size != 0 && (*rr)->u.data == NULL) {
		dns_free_data(r);
		return NULL;
	    }
	    memcpy((*rr)->u.data, p, size);
	}
	p += size;
d417 6
a422 1
    struct dns_reply *r = NULL;
d424 1
d427 3
d432 1
d436 3
d440 1
d442 1
d444 1
d448 9
a456 3
    if (len >= 0)
	r = parse_reply(reply, len);
    return r;
d497 2
a498 1
    char state[256], *oldstate;
d527 1
a527 1
    oldstate = initstate(time(NULL), state, sizeof(state));
d613 1
a613 1
	printf("%s %s %d ", rr->domain, dns_type_to_string(rr->type), rr->ttl);
@


1.4
log
@string cleaning; parts by me, then parts by hin, then more parts by me.
since this is not a very important part of the source tree, and since it
does compile, i am dumping it in now.
@
text
@d119 1
d206 1
d208 1
a208 1
						    strlen(host));
d214 1
a214 1
	    strlcpy((*rr)->u.mx->domain, host, strlen(host));
d223 1
d225 1
a225 2
		(struct srv_record*)malloc(sizeof(struct srv_record) + 
					   strlen(host));
d233 1
a233 1
	    strlcpy((*rr)->u.srv->target, host, strlen(host));
d272 1
d274 1
a274 1
				  + strlen(host) + sig_len);
d292 1
a292 1
	    strlcpy((*rr)->u.sig->signer, host, strlen(host));
@


1.3
log
@Fix a bug found by propolice on sparc64; Jan Johansson
@
text
@d212 1
a212 1
	    strcpy((*rr)->u.mx->domain, host);
d231 1
a231 1
	    strcpy((*rr)->u.srv->target, host);
d289 1
a289 1
	    strcpy((*rr)->u.sig->signer, host);
@


1.2
log
@-Wall -Werror sweep on i386.
@
text
@d456 1
a456 1
	    while(*ss == NULL)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d46 3
a48 1
RCSID("$KTH: resolve.c,v 1.26 2000/06/27 01:15:53 assar Exp $");
d365 103
d481 5
d499 3
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d46 1
a46 3
#include <assert.h>

RCSID("$KTH: resolve.c,v 1.28 2001/08/07 21:57:01 assar Exp $");
a362 103
static int
compare_srv(const void *a, const void *b)
{
    const struct resource_record *const* aa = a, *const* bb = b;

    if((*aa)->u.srv->priority == (*bb)->u.srv->priority)
	return ((*aa)->u.srv->weight - (*bb)->u.srv->weight);
    return ((*aa)->u.srv->priority - (*bb)->u.srv->priority);
}

#ifndef HAVE_RANDOM
#define random() rand()
#endif

/* try to rearrange the srv-records by the algorithm in RFC2782 */
void
dns_srv_order(struct dns_reply *r)
{
    struct resource_record **srvs, **ss, **headp;
    struct resource_record *rr;
    int num_srv = 0;

#if defined(HAVE_INITSTATE) && defined(HAVE_SETSTATE)
    char state[256], *oldstate;
#endif

    for(rr = r->head; rr; rr = rr->next) 
	if(rr->type == T_SRV)
	    num_srv++;

    if(num_srv == 0)
	return;

    srvs = malloc(num_srv * sizeof(*srvs));
    if(srvs == NULL)
	return; /* XXX not much to do here */
    
    /* unlink all srv-records from the linked list and put them in
       a vector */
    for(ss = srvs, headp = &r->head; *headp; )
	if((*headp)->type == T_SRV) {
	    *ss = *headp;
	    *headp = (*headp)->next;
	    (*ss)->next = NULL;
	    ss++;
	} else
	    headp = &(*headp)->next;
    
    /* sort them by priority and weight */
    qsort(srvs, num_srv, sizeof(*srvs), compare_srv);

#if defined(HAVE_INITSTATE) && defined(HAVE_SETSTATE)
    oldstate = initstate(time(NULL), state, sizeof(state));
#endif

    headp = &r->head;
    
    for(ss = srvs; ss < srvs + num_srv; ) {
	int sum, rnd, count;
	struct resource_record **ee, **tt;
	/* find the last record with the same priority and count the
           sum of all weights */
	for(sum = 0, tt = ss; tt < srvs + num_srv; tt++) {
	    if(*tt == NULL)
		continue;
	    if((*tt)->u.srv->priority != (*ss)->u.srv->priority)
		break;
	    sum += (*tt)->u.srv->weight;
	}
	ee = tt;
	/* ss is now the first record of this priority and ee is the
           first of the next */
	while(ss < ee) {
	    rnd = random() % (sum + 1);
	    for(count = 0, tt = ss; ; tt++) {
		if(*tt == NULL)
		    continue;
		count += (*tt)->u.srv->weight;
		if(count >= rnd)
		    break;
	    }

	    assert(tt < ee);

	    /* insert the selected record at the tail (of the head) of
               the list */
	    (*tt)->next = *headp;
	    *headp = *tt;
	    headp = &(*tt)->next;
	    sum -= (*tt)->u.srv->weight;
	    *tt = NULL;
	    while(*ss == NULL)
		ss++;
	}
    }
    
#if defined(HAVE_INITSTATE) && defined(HAVE_SETSTATE)
    setstate(oldstate);
#endif
    free(srvs);
    return;
}

a375 6
void
dns_srv_order(struct dns_reply *r)
{
    return 0;
}

a388 3
    if(r->q.type == T_SRV)
	dns_srv_order(r);

@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d48 1
a48 1
RCSID("$Id$");
d50 1
a50 2
#undef HAVE_RES_NSEARCH
#if (defined(HAVE_RES_SEARCH) || defined(HAVE_RES_NSEARCH)) && defined(HAVE_DN_EXPAND)
d113 2
a114 3
static int
parse_record(const unsigned char *data, const unsigned char *end_data, 
	     const unsigned char **pp, struct resource_record **rr)
d116 2
a117 1
    int type, class, ttl, size;
d119 1
a119 226
    char host[MAXDNAME];
    const unsigned char *p = *pp;
    status = dn_expand(data, end_data, p, host, sizeof(host));
    if(status < 0) 
	return -1;
    if (p + status + 10 > end_data)
	return -1;
    p += status;
    type = (p[0] << 8) | p[1];
    p += 2;
    class = (p[0] << 8) | p[1];
    p += 2;
    ttl = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
    p += 4;
    size = (p[0] << 8) | p[1];
    p += 2;

    if (p + size > end_data)
	return -1;

    *rr = calloc(1, sizeof(**rr));
    if(*rr == NULL) 
	return -1;
    (*rr)->domain = strdup(host);
    if((*rr)->domain == NULL) {
	free(*rr);
	return -1;
    }
    (*rr)->type = type;
    (*rr)->class = class;
    (*rr)->ttl = ttl;
    (*rr)->size = size;
    switch(type){
    case T_NS:
    case T_CNAME:
    case T_PTR:
	status = dn_expand(data, end_data, p, host, sizeof(host));
	if(status < 0) {
	    free(*rr);
	    return -1;
	}
	(*rr)->u.txt = strdup(host);
	if((*rr)->u.txt == NULL) {
	    free(*rr);
	    return -1;
	}
	break;
    case T_MX:
    case T_AFSDB:{
	size_t hostlen;

	status = dn_expand(data, end_data, p + 2, host, sizeof(host));
	if(status < 0){
	    free(*rr);
	    return -1;
	}
	if (status + 2 > size) {
	    free(*rr);
	    return -1;
	}

	hostlen = strlen(host);
	(*rr)->u.mx = (struct mx_record*)malloc(sizeof(struct mx_record) + 
						hostlen);
	if((*rr)->u.mx == NULL) {
	    free(*rr);
	    return -1;
	}
	(*rr)->u.mx->preference = (p[0] << 8) | p[1];
	strlcpy((*rr)->u.mx->domain, host, hostlen + 1);
	break;
    }
    case T_SRV:{
	size_t hostlen;
	status = dn_expand(data, end_data, p + 6, host, sizeof(host));
	if(status < 0){
	    free(*rr);
	    return -1;
	}
	if (status + 6 > size) {
	    free(*rr);
	    return -1;
	}

	hostlen = strlen(host);
	(*rr)->u.srv = 
	    (struct srv_record*)malloc(sizeof(struct srv_record) + 
				       hostlen);
	if((*rr)->u.srv == NULL) {
	    free(*rr);
	    return -1;
	}
	(*rr)->u.srv->priority = (p[0] << 8) | p[1];
	(*rr)->u.srv->weight = (p[2] << 8) | p[3];
	(*rr)->u.srv->port = (p[4] << 8) | p[5];
	strlcpy((*rr)->u.srv->target, host, hostlen + 1);
	break;
    }
    case T_TXT:{
	if(size == 0 || size < *p + 1) {
	    free(*rr);
	    return -1;
	}
	(*rr)->u.txt = (char*)malloc(*p + 1);
	if((*rr)->u.txt == NULL) {
	    free(*rr);
	    return -1;
	}
	strncpy((*rr)->u.txt, (char*)p + 1, *p);
	(*rr)->u.txt[*p] = '\0';
	break;
    }
    case T_KEY : {
	size_t key_len;

	if (size < 4) {
	    free(*rr);
	    return -1;
	}

	key_len = size - 4;
	(*rr)->u.key = malloc (sizeof(*(*rr)->u.key) + key_len - 1);
	if ((*rr)->u.key == NULL) {
	    free(*rr);
	    return -1;
	}

	(*rr)->u.key->flags     = (p[0] << 8) | p[1];
	(*rr)->u.key->protocol  = p[2];
	(*rr)->u.key->algorithm = p[3];
	(*rr)->u.key->key_len   = key_len;
	memcpy ((*rr)->u.key->key_data, p + 4, key_len);
	break;
    }
    case T_SIG : {
	size_t sig_len, hostlen;

	if(size <= 18) {
	    free(*rr);
	    return -1;
	}
	status = dn_expand (data, end_data, p + 18, host, sizeof(host));
	if (status < 0) {
	    free(*rr);
	    return -1;
	}
	if (status + 18 > size) {
	    free(*rr);
	    return -1;
	}

	/* the signer name is placed after the sig_data, to make it
           easy to free this struture; the size calculation below
           includes the zero-termination if the structure itself.
	   don't you just love C?
	*/
	sig_len = size - 18 - status;
	hostlen = strlen(host);
	(*rr)->u.sig = malloc(sizeof(*(*rr)->u.sig)
			      + hostlen + sig_len);
	if ((*rr)->u.sig == NULL) {
	    free(*rr);
	    return -1;
	}
	(*rr)->u.sig->type           = (p[0] << 8) | p[1];
	(*rr)->u.sig->algorithm      = p[2];
	(*rr)->u.sig->labels         = p[3];
	(*rr)->u.sig->orig_ttl       = (p[4] << 24) | (p[5] << 16)
	    | (p[6] << 8) | p[7];
	(*rr)->u.sig->sig_expiration = (p[8] << 24) | (p[9] << 16)
	    | (p[10] << 8) | p[11];
	(*rr)->u.sig->sig_inception  = (p[12] << 24) | (p[13] << 16)
	    | (p[14] << 8) | p[15];
	(*rr)->u.sig->key_tag        = (p[16] << 8) | p[17];
	(*rr)->u.sig->sig_len        = sig_len;
	memcpy ((*rr)->u.sig->sig_data, p + 18 + status, sig_len);
	(*rr)->u.sig->signer         = &(*rr)->u.sig->sig_data[sig_len];
	strlcpy((*rr)->u.sig->signer, host, hostlen + 1);
	break;
    }

    case T_CERT : {
	size_t cert_len;

	if (size < 5) {
	    free(*rr);
	    return -1;
	}

	cert_len = size - 5;
	(*rr)->u.cert = malloc (sizeof(*(*rr)->u.cert) + cert_len - 1);
	if ((*rr)->u.cert == NULL) {
	    free(*rr);
	    return -1;
	}

	(*rr)->u.cert->type      = (p[0] << 8) | p[1];
	(*rr)->u.cert->tag       = (p[2] << 8) | p[3];
	(*rr)->u.cert->algorithm = p[4];
	(*rr)->u.cert->cert_len  = cert_len;
	memcpy ((*rr)->u.cert->cert_data, p + 5, cert_len);
	break;
    }
    default:
	(*rr)->u.data = (unsigned char*)malloc(size);
	if(size != 0 && (*rr)->u.data == NULL) {
	    free(*rr);
	    return -1;
	}
	memcpy((*rr)->u.data, p, size);
    }
    *pp = p + size;
    return 0;
}

#ifndef TEST_RESOLVE
static
#endif
struct dns_reply*
parse_reply(const unsigned char *data, size_t len)
{
    const unsigned char *p;
    int status;
    int i;
    char host[MAXDNAME];
    const unsigned char *end_data = data + len;
d136 1
a136 5
    if(ntohs(r->h.qdcount) != 1) {
	free(r);
	return NULL;
    }
    status = dn_expand(data, end_data, p, host, sizeof(host));
a145 4
    if (p + status + 4 > end_data) {
	dns_free_data(r);
	return NULL;
    }
a150 1
    
d152 4
a155 2
    for(i = 0; i < ntohs(r->h.ancount); i++) {
	if(parse_record(data, end_data, &p, rr) != 0) {
d159 12
a170 4
	rr = &(*rr)->next;
    }
    for(i = 0; i < ntohs(r->h.nscount); i++) {
	if(parse_record(data, end_data, &p, rr) != 0) {
d174 2
a175 4
	rr = &(*rr)->next;
    }
    for(i = 0; i < ntohs(r->h.arcount); i++) {
	if(parse_record(data, end_data, &p, rr) != 0) {
d179 140
d330 1
a330 6
#ifdef HAVE_RES_NSEARCH
    struct __res_state stat;
    memset(&stat, 0, sizeof(stat));
    if(res_ninit(&stat))
	return NULL; /* is this the best we can do? */
#elif defined(HAVE__RES)
a331 1
#endif
a333 3
#ifdef HAVE_RES_NSEARCH
	stat.options |= RES_DEBUG;
#elif defined(HAVE__RES)
a335 1
#endif
a338 3
#ifdef HAVE_RES_NSEARCH
    len = res_nsearch(&stat, domain, rr_class, rr_type, reply, sizeof(reply));
#else
a339 1
#endif
a340 1
#if defined(HAVE__RES) && !defined(HAVE_RES_NSEARCH)
a341 1
#endif
d345 3
a347 9
#ifdef HAVE_RES_NSEARCH
    res_nclose(&stat);
#endif    
    if(len < 0) {
	return NULL;
    } else {
	len = min(len, sizeof(reply));
	return parse_reply(reply, len);
    }
d388 1
a388 2
    int state[256 / sizeof(int)];
    char *oldstate;
d417 1
a417 1
    oldstate = initstate(time(NULL), (char*)state, sizeof(state));
d456 1
a456 1
	    while(ss < ee && *ss == NULL)
d484 1
d504 1
a504 1
	printf("%-30s %-5s %-6d ", rr->domain, dns_type_to_string(rr->type), rr->ttl);
@


1.1.1.4
log
@Import of heimdal-0.6, released earlier today.
@
text
@d48 1
a48 1
RCSID("$KTH: resolve.c,v 1.38.2.1 2003/04/22 15:02:47 lha Exp $");
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2004 Kungliga Tekniska Högskolan
d48 1
a48 1
RCSID("$KTH: resolve.c,v 1.50 2005/04/12 11:29:01 lha Exp $");
a49 1
#ifdef _AIX /* AIX have broken res_nsearch() in 5.1 (5.0 also ?) */
d51 1
a51 1
#endif
d53 1
a53 1
#define DECL(X) {#X, rk_ns_t_##X}
d59 12
a70 15
    DECL(a),
    DECL(aaaa),
    DECL(ns),
    DECL(cname),
    DECL(soa),
    DECL(ptr),
    DECL(mx),
    DECL(txt),
    DECL(afsdb),
    DECL(sig),
    DECL(key),
    DECL(srv),
    DECL(naptr),
    DECL(sshfp),
    DECL(ds),
d76 1
a76 1
int ROKEN_LIB_FUNCTION
d86 1
a86 1
const char * ROKEN_LIB_FUNCTION
d96 1
a96 3
#if (defined(HAVE_RES_SEARCH) || defined(HAVE_RES_NSEARCH)) && defined(HAVE_DN_EXPAND)

void ROKEN_LIB_FUNCTION
d153 3
a155 3
    case rk_ns_t_ns:
    case rk_ns_t_cname:
    case rk_ns_t_ptr:
d167 2
a168 2
    case rk_ns_t_mx:
    case rk_ns_t_afsdb:{
d192 1
a192 1
    case rk_ns_t_srv:{
d218 1
a218 1
    case rk_ns_t_txt:{
d232 1
a232 1
    case rk_ns_t_key : {
d254 1
a254 1
    case rk_ns_t_sig : {
d301 1
a301 1
    case rk_ns_t_cert : {
a322 45
    case rk_ns_t_sshfp : {
	size_t sshfp_len;

	if (size < 2) {
	    free(*rr);
	    return -1;
	}

	sshfp_len = size - 2;

	(*rr)->u.sshfp = malloc (sizeof(*(*rr)->u.sshfp) + sshfp_len - 1);
	if ((*rr)->u.sshfp == NULL) {
	    free(*rr);
	    return -1;
	}

	(*rr)->u.sshfp->algorithm = p[0];
	(*rr)->u.sshfp->type      = p[1];
	(*rr)->u.sshfp->sshfp_len  = sshfp_len;
	memcpy ((*rr)->u.sshfp->sshfp_data, p + 2, sshfp_len);
	break;
    }
    case rk_ns_t_ds: {
	size_t digest_len;

	if (size < 4) {
	    free(*rr);
	    return -1;
	}

	digest_len = size - 4;

	(*rr)->u.ds = malloc (sizeof(*(*rr)->u.ds) + digest_len - 1);
	if ((*rr)->u.ds == NULL) {
	    free(*rr);
	    return -1;
	}

	(*rr)->u.ds->key_tag     = (p[0] << 8) | p[1];
	(*rr)->u.ds->algorithm   = p[2];
	(*rr)->u.ds->digest_type = p[3];
	(*rr)->u.ds->digest_len  = digest_len;
	memcpy ((*rr)->u.ds->digest_data, p + 4, digest_len);
	break;
    }
d354 6
a359 24

    r->h.id = (p[0] << 8) | p[1];
    r->h.flags = 0;
    if (p[2] & 0x01)
	r->h.flags |= rk_DNS_HEADER_RESPONSE_FLAG;
    r->h.opcode = (p[2] >> 1) & 0xf;
    if (p[2] & 0x20)
	r->h.flags |= rk_DNS_HEADER_AUTHORITIVE_ANSWER;
    if (p[2] & 0x40)
	r->h.flags |= rk_DNS_HEADER_TRUNCATED_MESSAGE;
    if (p[2] & 0x80)
	r->h.flags |= rk_DNS_HEADER_RECURSION_DESIRED;
    if (p[3] & 0x01)
	r->h.flags |= rk_DNS_HEADER_RECURSION_AVAILABLE;
    if (p[3] & 0x04)
	r->h.flags |= rk_DNS_HEADER_AUTHORITIVE_ANSWER;
    if (p[3] & 0x08)
	r->h.flags |= rk_DNS_HEADER_CHECKING_DISABLED;
    r->h.response_code = (p[3] >> 4) & 0xf;
    r->h.qdcount = (p[4] << 8) | p[5];
    r->h.ancount = (p[6] << 8) | p[7];
    r->h.nscount = (p[8] << 8) | p[9];
    r->h.arcount = (p[10] << 8) | p[11];

d361 2
a362 2

    if(r->h.qdcount != 1) {
d387 1
a387 1
    for(i = 0; i < r->h.ancount; i++) {
d394 1
a394 1
    for(i = 0; i < r->h.nscount; i++) {
d401 1
a401 1
    for(i = 0; i < r->h.arcount; i++) {
d415 1
a415 3
    struct dns_reply *r;
    unsigned char *reply = NULL;
    int size;
d418 3
a420 3
    struct __res_state state;
    memset(&state, 0, sizeof(state));
    if(res_ninit(&state))
d426 1
a426 10
    size = 0;
    len = 1000;
    do {
	if (reply) {
	    free(reply);
	    reply = NULL;
	}
	if (size <= len)
	    size = len;
	if (_resolve_debug) {
d428 1
a428 1
	    state.options |= RES_DEBUG;
d430 2
a431 2
	    old_options = _res.options;
	    _res.options |= RES_DEBUG;
d433 3
a435 10
	    fprintf(stderr, "dns_lookup(%s, %d, %s), buffer size %d\n", domain,
		    rr_class, dns_type_to_string(rr_type), size);
	}
	reply = malloc(size);
	if (reply == NULL) {
#ifdef HAVE_RES_NSEARCH
	    res_nclose(&state);
#endif
	    return NULL;
	}
d437 1
a437 1
	len = res_nsearch(&state, domain, rr_class, rr_type, reply, size);
d439 1
a439 1
	len = res_search(domain, rr_class, rr_type, reply, size);
d441 1
a441 1
	if (_resolve_debug) {
d443 1
a443 1
	    _res.options = old_options;
d445 3
a447 4
	    fprintf(stderr, "dns_lookup(%s, %d, %s) --> %d\n",
		    domain, rr_class, dns_type_to_string(rr_type), len);
	}
	if (len < 0) {
d449 8
a456 14
	    res_nclose(&state);
#endif
	    free(reply);
	    return NULL;
	}
    } while (size < len && len < rk_DNS_MAX_PACKET_SIZE);
#ifdef HAVE_RES_NSEARCH
    res_nclose(&state);
#endif

    len = min(len, size);
    r = parse_reply(reply, len);
    free(reply);
    return r;
d459 1
a459 1
struct dns_reply * ROKEN_LIB_FUNCTION
d489 1
a489 1
void ROKEN_LIB_FUNCTION
d502 1
a502 1
	if(rr->type == rk_ns_t_srv)
d515 1
a515 1
	if((*headp)->type == rk_ns_t_srv) {
d580 1
a580 1
struct dns_reply * ROKEN_LIB_FUNCTION
d586 1
a586 1
void ROKEN_LIB_FUNCTION
d591 1
a591 1
void ROKEN_LIB_FUNCTION
d596 68
@


