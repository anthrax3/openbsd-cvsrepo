head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.18
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.16
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.14
	OPENBSD_5_0:1.4.0.12
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.10
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.10
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.6
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.4
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.04.22.10.01.34;	author reyk;	state dead;
branches;
next	1.5;

1.5
date	2013.06.17.18.57.45;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.17.18.30.19;	author okan;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.14.08.15.05;	author biorn;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.02.23.18.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.24;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.24;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.54;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.16.10;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.33.46;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.6
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*	$NetBSD: vis.c,v 1.37 2008/07/25 22:29:23 dsl Exp $	*/

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1999, 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if 1
#include <config.h>
#include "roken.h"
#ifndef _DIAGASSERT
#define _DIAGASSERT(X)
#endif
#else /* heimdal */
#include <sys/cdefs.h>
#if defined(LIBC_SCCS) && !defined(lint)
__RCSID("$NetBSD: vis.c,v 1.37 2008/07/25 22:29:23 dsl Exp $");
#endif /* LIBC_SCCS and not lint */

#include "namespace.h"
#endif /* heimdal */

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <vis.hin>
#include <stdlib.h>

#if 0
#ifdef __weak_alias
__weak_alias(strsvis,_strsvis)
__weak_alias(strsvisx,_strsvisx)
__weak_alias(strvis,_strvis)
__weak_alias(strvisx,_strvisx)
__weak_alias(svis,_svis)
__weak_alias(vis,_vis)
#endif
#endif

#if !HAVE_VIS || !HAVE_SVIS
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

static char *do_svis(char *, int, int, int, const char *);

#undef BELL
#if defined(__STDC__)
#define BELL '\a'
#else
#define BELL '\007'
#endif

ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
	rk_vis (char *, int, int, int);
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
	rk_svis (char *, int, int, int, const char *);
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
	rk_strvis (char *, const char *, int);
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
	rk_strsvis (char *, const char *, int, const char *);
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
	rk_strvisx (char *, const char *, size_t, int);
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
	rk_strsvisx (char *, const char *, size_t, int, const char *);


#define isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
#define iswhite(c)	(c == ' ' || c == '\t' || c == '\n')
#define issafe(c)	(c == '\b' || c == BELL || c == '\r')
#define xtoa(c)		"0123456789abcdef"[c]

#define MAXEXTRAS	5

#define MAKEEXTRALIST(flag, extra, orig_str)				      \
do {									      \
	const char *orig = orig_str;					      \
	const char *o = orig;						      \
	char *e;							      \
	while (*o++)							      \
		continue;						      \
	extra = malloc((size_t)((o - orig) + MAXEXTRAS));		      \
	if (!extra) break;						      \
	for (o = orig, e = extra; (*e++ = *o++) != '\0';)		      \
		continue;						      \
	e--;								      \
	if (flag & VIS_SP) *e++ = ' ';					      \
	if (flag & VIS_TAB) *e++ = '\t';				      \
	if (flag & VIS_NL) *e++ = '\n';					      \
	if ((flag & VIS_NOSLASH) == 0) *e++ = '\\';			      \
	*e = '\0';							      \
} while (/*CONSTCOND*/0)

/*
 * This is do_hvis, for HTTP style (RFC 1808)
 */
static char *
do_hvis(char *dst, int c, int flag, int nextc, const char *extra)
{
	if (!isascii(c) || !isalnum(c) || strchr("$-_.+!*'(),", c) != NULL) {
		*dst++ = '%';
		*dst++ = xtoa(((unsigned int)c >> 4) & 0xf);
		*dst++ = xtoa((unsigned int)c & 0xf);
	} else {
		dst = do_svis(dst, c, flag, nextc, extra);
	}
	return dst;
}

/*
 * This is do_vis, the central code of vis.
 * dst:	      Pointer to the destination buffer
 * c:	      Character to encode
 * flag:      Flag word
 * nextc:     The character following 'c'
 * extra:     Pointer to the list of extra characters to be
 *	      backslash-protected.
 */
static char *
do_svis(char *dst, int c, int flag, int nextc, const char *extra)
{
	int isextra;
	isextra = strchr(extra, c) != NULL;
	if (!isextra && isascii(c) && (isgraph(c) || iswhite(c) ||
	    ((flag & VIS_SAFE) && issafe(c)))) {
		*dst++ = c;
		return dst;
	}
	if (flag & VIS_CSTYLE) {
		switch (c) {
		case '\n':
			*dst++ = '\\'; *dst++ = 'n';
			return dst;
		case '\r':
			*dst++ = '\\'; *dst++ = 'r';
			return dst;
		case '\b':
			*dst++ = '\\'; *dst++ = 'b';
			return dst;
		case BELL:
			*dst++ = '\\'; *dst++ = 'a';
			return dst;
		case '\v':
			*dst++ = '\\'; *dst++ = 'v';
			return dst;
		case '\t':
			*dst++ = '\\'; *dst++ = 't';
			return dst;
		case '\f':
			*dst++ = '\\'; *dst++ = 'f';
			return dst;
		case ' ':
			*dst++ = '\\'; *dst++ = 's';
			return dst;
		case '\0':
			*dst++ = '\\'; *dst++ = '0';
			if (isoctal(nextc)) {
				*dst++ = '0';
				*dst++ = '0';
			}
			return dst;
		default:
			if (isgraph(c)) {
				*dst++ = '\\'; *dst++ = c;
				return dst;
			}
		}
	}
	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {
		*dst++ = '\\';
		*dst++ = (u_char)(((unsigned int)(u_char)c >> 6) & 03) + '0';
		*dst++ = (u_char)(((unsigned int)(u_char)c >> 3) & 07) + '0';
		*dst++ = (u_char)(			 c       & 07) + '0';
	} else {
		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';
		if (c & 0200) {
			c &= 0177; *dst++ = 'M';
		}
		if (iscntrl(c)) {
			*dst++ = '^';
			if (c == 0177)
				*dst++ = '?';
			else
				*dst++ = c + '@@';
		} else {
			*dst++ = '-'; *dst++ = c;
		}
	}
	return dst;
}


/*
 * svis - visually encode characters, also encoding the characters
 *	  pointed to by `extra'
 */
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
rk_svis(char *dst, int c, int flag, int nextc, const char *extra)
{
	char *nextra = NULL;

	_DIAGASSERT(dst != NULL);
	_DIAGASSERT(extra != NULL);
	MAKEEXTRALIST(flag, nextra, extra);
	if (!nextra) {
		*dst = '\0';		/* can't create nextra, return "" */
		return dst;
	}
	if (flag & VIS_HTTPSTYLE)
		dst = do_hvis(dst, c, flag, nextc, nextra);
	else
		dst = do_svis(dst, c, flag, nextc, nextra);
	free(nextra);
	*dst = '\0';
	return dst;
}


/*
 * strsvis, strsvisx - visually encode characters from src into dst
 *
 *	Extra is a pointer to a \0-terminated list of characters to
 *	be encoded, too. These functions are useful e. g. to
 *	encode strings in such a way so that they are not interpreted
 *	by a shell.
 *
 *	Dst must be 4 times the size of src to account for possible
 *	expansion.  The length of dst, not including the trailing NULL,
 *	is returned.
 *
 *	Strsvisx encodes exactly len bytes from src into dst.
 *	This is useful for encoding a block of data.
 */

ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_strsvis(char *dst, const char *csrc, int flag, const char *extra)
{
	int c;
	char *start;
	char *nextra = NULL;
	const unsigned char *src = (const unsigned char *)csrc;

	_DIAGASSERT(dst != NULL);
	_DIAGASSERT(src != NULL);
	_DIAGASSERT(extra != NULL);
	MAKEEXTRALIST(flag, nextra, extra);
	if (!nextra) {
		*dst = '\0';		/* can't create nextra, return "" */
		return 0;
	}
	if (flag & VIS_HTTPSTYLE) {
		for (start = dst; (c = *src++) != '\0'; /* empty */)
			dst = do_hvis(dst, c, flag, *src, nextra);
	} else {
		for (start = dst; (c = *src++) != '\0'; /* empty */)
			dst = do_svis(dst, c, flag, *src, nextra);
	}
	free(nextra);
	*dst = '\0';
	return (dst - start);
}


ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_strsvisx(char *dst, const char *csrc, size_t len, int flag, const char *extra)
{
	unsigned char c;
	char *start;
	char *nextra = NULL;
	const unsigned char *src = (const unsigned char *)csrc;

	_DIAGASSERT(dst != NULL);
	_DIAGASSERT(src != NULL);
	_DIAGASSERT(extra != NULL);
	MAKEEXTRALIST(flag, nextra, extra);
	if (! nextra) {
		*dst = '\0';		/* can't create nextra, return "" */
		return 0;
	}

	if (flag & VIS_HTTPSTYLE) {
		for (start = dst; len > 0; len--) {
			c = *src++;
			dst = do_hvis(dst, c, flag, len ? *src : '\0', nextra);
		}
	} else {
		for (start = dst; len > 0; len--) {
			c = *src++;
			dst = do_svis(dst, c, flag, len ? *src : '\0', nextra);
		}
	}
	free(nextra);
	*dst = '\0';
	return (dst - start);
}
#endif

#if !HAVE_VIS
/*
 * vis - visually encode characters
 */
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
rk_vis(char *dst, int c, int flag, int nextc)
{
	char *extra = NULL;
	unsigned char uc = (unsigned char)c;

	_DIAGASSERT(dst != NULL);

	MAKEEXTRALIST(flag, extra, "");
	if (! extra) {
		*dst = '\0';		/* can't create extra, return "" */
		return dst;
	}
	if (flag & VIS_HTTPSTYLE)
		dst = do_hvis(dst, uc, flag, nextc, extra);
	else
		dst = do_svis(dst, uc, flag, nextc, extra);
	free(extra);
	*dst = '\0';
	return dst;
}


/*
 * strvis, strvisx - visually encode characters from src into dst
 *
 *	Dst must be 4 times the size of src to account for possible
 *	expansion.  The length of dst, not including the trailing NULL,
 *	is returned.
 *
 *	Strvisx encodes exactly len bytes from src into dst.
 *	This is useful for encoding a block of data.
 */
ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_strvis(char *dst, const char *src, int flag)
{
	char *extra = NULL;
	int rv;

	MAKEEXTRALIST(flag, extra, "");
	if (!extra) {
		*dst = '\0';		/* can't create extra, return "" */
		return 0;
	}
	rv = strsvis(dst, src, flag, extra);
	free(extra);
	return rv;
}


ROKEN_LIB_FUNCTION int ROKEN_LIB_CALL
rk_strvisx(char *dst, const char *src, size_t len, int flag)
{
	char *extra = NULL;
	int rv;

	MAKEEXTRALIST(flag, extra, "");
	if (!extra) {
		*dst = '\0';		/* can't create extra, return "" */
		return 0;
	}
	rv = strsvisx(dst, src, len, flag, extra);
	free(extra);
	return rv;
}
#endif
@


1.5
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.4
log
@Remove clauses 3 and 4 from NetBSD license.

from ray; ok ray, deraadt
@
text
@d1 1
a1 1
/*	$NetBSD: vis.c,v 1.4 2003/08/07 09:15:32 agc Exp $	*/
d33 2
a34 1
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
d45 11
a55 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a57 1

a58 1
#ifdef HAVE_CONFIG_H
d60 1
a60 3
RCSID("$KTH: vis.c,v 1.9 2005/04/12 11:29:15 lha Exp $");
#endif
#include <roken.h>
d64 1
a64 1
#else
d66 3
a68 4
#if !defined(lint)
__RCSID("$NetBSD: vis.c,v 1.4 2003/08/07 09:15:32 agc Exp $");
#endif /* not lint */
#endif
a69 1
#if 0
d71 2
a72 1
#endif
d80 2
a81 1
#include <vis.h>
d94 8
d109 14
d126 1
d128 1
a128 1
#define MAXEXTRAS       5
d130 1
a130 2

#define MAKEEXTRALIST(flag, extra)					      \
d132 15
a146 6
	char *pextra = extra;						      \
	if (flag & VIS_SP) *pextra++ = ' ';				      \
	if (flag & VIS_TAB) *pextra++ = '\t';				      \
	if (flag & VIS_NL) *pextra++ = '\n';				      \
	if ((flag & VIS_NOSLASH) == 0) *pextra++ = '\\';		      \
	*pextra = '\0';							      \
d150 17
a166 1
 * This is SVIS, the central macro of vis.
d174 72
a245 68
#define SVIS(dst, c, flag, nextc, extra)				   \
do {									   \
	int isextra, isc;						   \
	isextra = strchr(extra, c) != NULL;				   \
	if (!isextra &&							   \
	    isascii((unsigned char)c) &&				   \
	    (isgraph((unsigned char)c) || iswhite(c) ||			   \
	    ((flag & VIS_SAFE) && issafe(c)))) {			   \
		*dst++ = c;						   \
		break;							   \
	}								   \
	isc = 0;							   \
	if (flag & VIS_CSTYLE) {					   \
		switch (c) {						   \
		case '\n':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'n';		   \
			break;						   \
		case '\r':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'r';		   \
			break;						   \
		case '\b':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'b';		   \
			break;						   \
		case BELL:						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'a';		   \
			break;						   \
		case '\v':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'v';		   \
			break;						   \
		case '\t':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 't';		   \
			break;						   \
		case '\f':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'f';		   \
			break;						   \
		case ' ':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 's';		   \
			break;						   \
		case '\0':						   \
			isc = 1; *dst++ = '\\'; *dst++ = '0';		   \
			if (isoctal(nextc)) {				   \
				*dst++ = '0';				   \
				*dst++ = '0';				   \
			}						   \
		}							   \
	}								   \
	if (isc) break;							   \
	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	   \
		*dst++ = '\\';						   \
		*dst++ = (u_char)(((unsigned)(u_char)c >> 6) & 03) + '0';  \
		*dst++ = (u_char)(((unsigned)(u_char)c >> 3) & 07) + '0';  \
		*dst++ =			     (c	      & 07) + '0'; \
	} else {							   \
		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		   \
		if (c & 0200) {						   \
			c &= 0177; *dst++ = 'M';			   \
		}							   \
		if (iscntrl((unsigned char)c)) {			   \
			*dst++ = '^';					   \
			if (c == 0177)					   \
				*dst++ = '?';				   \
			else						   \
				*dst++ = c + '@@';			   \
		} else {						   \
			*dst++ = '-'; *dst++ = c;			   \
		}							   \
	}								   \
} while (/*CONSTCOND*/0)
d250 1
a250 1
 * 	  pointed to by `extra'
d252 2
a253 3
#ifndef HAVE_SVIS
char * ROKEN_LIB_FUNCTION
svis(char *dst, int c, int flag, int nextc, const char *extra)
d255 2
d259 10
a268 2

	SVIS(dst, c, flag, nextc, extra);
d270 1
a270 1
	return(dst);
a271 1
#endif
d281 1
a281 1
 *	
d284 1
a284 1
 *	is returned. 
d289 3
a291 3
#ifndef HAVE_STRSVIS
int ROKEN_LIB_FUNCTION
strsvis(char *dst, const char *src, int flag, const char *extra)
d293 1
a293 1
	char c;
d295 2
d301 13
a313 3

	for (start = dst; (c = *src++) != '\0'; /* empty */)
	    SVIS(dst, c, flag, *src, extra);
a316 1
#endif
d319 2
a320 3
#ifndef HAVE_STRVISX
int ROKEN_LIB_FUNCTION
strsvisx(char *dst, const char *src, size_t len, int flag, const char *extra)
d322 1
a322 1
	char c;
d324 2
d330 5
d336 10
a345 3
	for (start = dst; len > 0; len--) {
		c = *src++;
		SVIS(dst, c, flag, len ? *src : '\0', extra);
d347 1
d353 1
a353 1

d357 2
a358 3
#ifndef HAVE_VIS
char * ROKEN_LIB_FUNCTION
vis(char *dst, int c, int flag, int nextc)
d360 2
a361 1
	char extra[MAXEXTRAS];
d365 10
a374 2
	MAKEEXTRALIST(flag, extra);
	SVIS(dst, c, flag, nextc, extra);
d376 1
a376 1
	return (dst);
a377 1
#endif
d382 1
a382 1
 *	
d385 1
a385 1
 *	is returned. 
d390 2
a391 3
#ifndef HAVE_STRVIS
int ROKEN_LIB_FUNCTION
strvis(char *dst, const char *src, int flag)
d393 2
a394 1
	char extra[MAXEXTRAS];
d396 8
a403 2
	MAKEEXTRALIST(flag, extra);
	return (strsvis(dst, src, flag, extra));
a404 1
#endif
d407 2
a408 3
#ifndef HAVE_STRVISX
int ROKEN_LIB_FUNCTION
strvisx(char *dst, const char *src, size_t len, int flag)
d410 2
a411 1
	char extra[MAXEXTRAS];
d413 8
a420 2
	MAKEEXTRALIST(flag, extra);
	return (strsvisx(dst, src, len, flag, extra));
@


1.3
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@a42 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.2
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$NetBSD: vis.c,v 1.19 2000/01/22 22:42:45 mycroft Exp $	*/
a3 1
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
d32 32
d68 1
a68 1
RCSID("$KTH: vis.c,v 1.5 2001/09/03 05:37:23 assar Exp $");
d77 1
a77 1
__RCSID("$NetBSD: vis.c,v 1.19 2000/01/22 22:42:45 mycroft Exp $");
d212 1
a212 1
char *
d241 1
a241 1
int
d260 1
a260 1
int
d284 1
a284 1
char *
d310 1
a310 1
int
d322 1
a322 1
int
@


1.1
log
@Initial revision
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
RCSID("$KTH: vis.c,v 1.3 2000/12/10 23:10:48 assar Exp $");
d106 67
a172 65
#define SVIS(dst, c, flag, nextc, extra)				      \
do {									      \
	int isextra, isc;						      \
	isextra = strchr(extra, c) != NULL;				      \
	if (!isextra && isascii(c) && (isgraph(c) || iswhite(c) ||	      \
	    ((flag & VIS_SAFE) && issafe(c)))) {			      \
		*dst++ = c;						      \
		break;							      \
	}								      \
	isc = 0;							      \
	if (flag & VIS_CSTYLE) {					      \
		switch (c) {						      \
		case '\n':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 'n';		      \
			break;						      \
		case '\r':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 'r';		      \
			break;						      \
		case '\b':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 'b';		      \
			break;						      \
		case BELL:						      \
			isc = 1; *dst++ = '\\'; *dst++ = 'a';		      \
			break;						      \
		case '\v':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 'v';		      \
			break;						      \
		case '\t':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 't';		      \
			break;						      \
		case '\f':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 'f';		      \
			break;						      \
		case ' ':						      \
			isc = 1; *dst++ = '\\'; *dst++ = 's';		      \
			break;						      \
		case '\0':						      \
			isc = 1; *dst++ = '\\'; *dst++ = '0';		      \
			if (isoctal(nextc)) {				      \
				*dst++ = '0';				      \
				*dst++ = '0';				      \
			}						      \
		}							      \
	}								      \
	if (isc) break;							      \
	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	      \
		*dst++ = '\\';						      \
		*dst++ = (u_char)(((unsigned)(u_char)c >> 6) & 03) + '0';     \
		*dst++ = (u_char)(((unsigned)(u_char)c >> 3) & 07) + '0';     \
		*dst++ =			     (c	      & 07) + '0';    \
	} else {							      \
		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		      \
		if (c & 0200) {						      \
			c &= 0177; *dst++ = 'M';			      \
		}							      \
		if (iscntrl(c)) {					      \
			*dst++ = '^';					      \
			if (c == 0177)					      \
				*dst++ = '?';				      \
			else						      \
				*dst++ = c + '@@';			      \
		} else {						      \
			*dst++ = '-'; *dst++ = c;			      \
		}							      \
	}								      \
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d41 1
a41 1
RCSID("$KTH: vis.c,v 1.4 2001/07/03 19:22:01 assar Exp $");
d110 65
a174 67
#define SVIS(dst, c, flag, nextc, extra)				   \
do {									   \
	int isextra, isc;						   \
	isextra = strchr(extra, c) != NULL;				   \
	if (!isextra &&							   \
	    isascii((unsigned char)c) &&				   \
	    (isgraph((unsigned char)c) || iswhite(c) ||			   \
	    ((flag & VIS_SAFE) && issafe(c)))) {			   \
		*dst++ = c;						   \
		break;							   \
	}								   \
	isc = 0;							   \
	if (flag & VIS_CSTYLE) {					   \
		switch (c) {						   \
		case '\n':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'n';		   \
			break;						   \
		case '\r':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'r';		   \
			break;						   \
		case '\b':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'b';		   \
			break;						   \
		case BELL:						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'a';		   \
			break;						   \
		case '\v':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'v';		   \
			break;						   \
		case '\t':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 't';		   \
			break;						   \
		case '\f':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 'f';		   \
			break;						   \
		case ' ':						   \
			isc = 1; *dst++ = '\\'; *dst++ = 's';		   \
			break;						   \
		case '\0':						   \
			isc = 1; *dst++ = '\\'; *dst++ = '0';		   \
			if (isoctal(nextc)) {				   \
				*dst++ = '0';				   \
				*dst++ = '0';				   \
			}						   \
		}							   \
	}								   \
	if (isc) break;							   \
	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	   \
		*dst++ = '\\';						   \
		*dst++ = (u_char)(((unsigned)(u_char)c >> 6) & 03) + '0';  \
		*dst++ = (u_char)(((unsigned)(u_char)c >> 3) & 07) + '0';  \
		*dst++ =			     (c	      & 07) + '0'; \
	} else {							   \
		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		   \
		if (c & 0200) {						   \
			c &= 0177; *dst++ = 'M';			   \
		}							   \
		if (iscntrl(c)) {					   \
			*dst++ = '^';					   \
			if (c == 0177)					   \
				*dst++ = '?';				   \
			else						   \
				*dst++ = c + '@@';			   \
		} else {						   \
			*dst++ = '-'; *dst++ = c;			   \
		}							   \
	}								   \
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d41 1
a41 1
RCSID("$KTH: vis.c,v 1.5 2001/09/03 05:37:23 assar Exp $");
d167 1
a167 1
		if (iscntrl((unsigned char)c)) {			   \
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d1 1
a1 1
/*	$NetBSD: vis.c,v 1.4 2003/08/07 09:15:32 agc Exp $	*/
d4 1
a15 28
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d41 1
a41 1
RCSID("$KTH: vis.c,v 1.9 2005/04/12 11:29:15 lha Exp $");
d50 1
a50 1
__RCSID("$NetBSD: vis.c,v 1.4 2003/08/07 09:15:32 agc Exp $");
d185 1
a185 1
char * ROKEN_LIB_FUNCTION
d214 1
a214 1
int ROKEN_LIB_FUNCTION
d233 1
a233 1
int ROKEN_LIB_FUNCTION
d257 1
a257 1
char * ROKEN_LIB_FUNCTION
d283 1
a283 1
int ROKEN_LIB_FUNCTION
d295 1
a295 1
int ROKEN_LIB_FUNCTION
@


