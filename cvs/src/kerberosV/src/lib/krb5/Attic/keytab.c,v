head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.4.0.28
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.26
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.24
	OPENBSD_5_0:1.1.1.4.0.22
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.20
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.18
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.14
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.12
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.10
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.8
	OPENBSD_3_7_BASE:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.8
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.2;

1.2
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.47;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.47;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.55;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.53;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.33.20;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.3
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"

/**
 * @@page krb5_keytab_intro The keytab handing functions
 * @@section section_krb5_keytab Kerberos Keytabs
 *
 * See the library functions here: @@ref krb5_keytab
 *
 * Keytabs are long term key storage for servers, their equvalment of
 * password files.
 *
 * Normally the only function that useful for server are to specify
 * what keytab to use to other core functions like krb5_rd_req()
 * krb5_kt_resolve(), and krb5_kt_close().
 *
 * @@subsection krb5_keytab_names Keytab names
 *
 * A keytab name is on the form type:residual. The residual part is
 * specific to each keytab-type.
 *
 * When a keytab-name is resolved, the type is matched with an internal
 * list of keytab types. If there is no matching keytab type,
 * the default keytab is used. The current default type is FILE.
 *
 * The default value can be changed in the configuration file
 * /etc/krb5.conf by setting the variable
 * [defaults]default_keytab_name.
 *
 * The keytab types that are implemented in Heimdal are:
 * - file
 *   store the keytab in a file, the type's name is FILE .  The
 *   residual part is a filename. For compatibility with other
 *   Kerberos implemtation WRFILE and JAVA14 is also accepted.  WRFILE
 *   has the same format as FILE. JAVA14 have a format that is
 *   compatible with older versions of MIT kerberos and SUN's Java
 *   based installation.  They store a truncted kvno, so when the knvo
 *   excess 255, they are truncted in this format.
 *
 * - keytab
 *   store the keytab in a AFS keyfile (usually /usr/afs/etc/KeyFile ),
 *   the type's name is AFSKEYFILE. The residual part is a filename.
 *
 * - memory
 *   The keytab is stored in a memory segment. This allows sensitive
 *   and/or temporary data not to be stored on disk. The type's name
 *   is MEMORY. Each MEMORY keytab is referenced counted by and
 *   opened by the residual name, so two handles can point to the
 *   same memory area.  When the last user closes using krb5_kt_close()
 *   the keytab, the keys in they keytab is memset() to zero and freed
 *   and can no longer be looked up by name.
 *
 *
 * @@subsection krb5_keytab_example Keytab example
 *
 *  This is a minimalistic version of ktutil.
 *
 * @@code
int
main (int argc, char **argv)
{
    krb5_context context;
    krb5_keytab keytab;
    krb5_kt_cursor cursor;
    krb5_keytab_entry entry;
    krb5_error_code ret;
    char *principal;

    if (krb5_init_context (&context) != 0)
	errx(1, "krb5_context");

    ret = krb5_kt_default (context, &keytab);
    if (ret)
	krb5_err(context, 1, ret, "krb5_kt_default");

    ret = krb5_kt_start_seq_get(context, keytab, &cursor);
    if (ret)
	krb5_err(context, 1, ret, "krb5_kt_start_seq_get");
    while((ret = krb5_kt_next_entry(context, keytab, &entry, &cursor)) == 0){
	krb5_unparse_name(context, entry.principal, &principal);
	printf("principal: %s\n", principal);
	free(principal);
	krb5_kt_free_entry(context, &entry);
    }
    ret = krb5_kt_end_seq_get(context, keytab, &cursor);
    if (ret)
	krb5_err(context, 1, ret, "krb5_kt_end_seq_get");
    ret = krb5_kt_close(context, keytab);
    if (ret)
	krb5_err(context, 1, ret, "krb5_kt_close");
    krb5_free_context(context);
    return 0;
}
 * @@endcode
 *
 */


/**
 * Register a new keytab backend.
 *
 * @@param context a Keberos context.
 * @@param ops a backend to register.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_register(krb5_context context,
		 const krb5_kt_ops *ops)
{
    struct krb5_keytab_data *tmp;

    if (strlen(ops->prefix) > KRB5_KT_PREFIX_MAX_LEN - 1) {
	krb5_set_error_message(context, KRB5_KT_BADNAME,
			       N_("can't register cache type, prefix too long", ""));
	return KRB5_KT_BADNAME;
    }

    tmp = realloc(context->kt_types,
		  (context->num_kt_types + 1) * sizeof(*context->kt_types));
    if(tmp == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy(&tmp[context->num_kt_types], ops,
	   sizeof(tmp[context->num_kt_types]));
    context->kt_types = tmp;
    context->num_kt_types++;
    return 0;
}

static const char *
keytab_name(const char *name, const char **type, size_t *type_len)
{
    const char *residual;

    residual = strchr(name, ':');

    if (residual == NULL ||
	name[0] == '/'
#ifdef _WIN32
        /* Avoid treating <drive>:<path> as a keytab type
         * specification */
        || name + 1 == residual
#endif
        ) {

        *type = "FILE";
        *type_len = strlen(*type);
        residual = name;
    } else {
        *type = name;
        *type_len = residual - name;
        residual++;
    }

    return residual;
}

/**
 * Resolve the keytab name (of the form `type:residual') in `name'
 * into a keytab in `id'.
 *
 * @@param context a Keberos context.
 * @@param name name to resolve
 * @@param id resulting keytab, free with krb5_kt_close().
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_resolve(krb5_context context,
		const char *name,
		krb5_keytab *id)
{
    krb5_keytab k;
    int i;
    const char *type, *residual;
    size_t type_len;
    krb5_error_code ret;

    residual = keytab_name(name, &type, &type_len);

    for(i = 0; i < context->num_kt_types; i++) {
	if(strncasecmp(type, context->kt_types[i].prefix, type_len) == 0)
	    break;
    }
    if(i == context->num_kt_types) {
	krb5_set_error_message(context, KRB5_KT_UNKNOWN_TYPE,
			       N_("unknown keytab type %.*s", "type"),
			       (int)type_len, type);
	return KRB5_KT_UNKNOWN_TYPE;
    }

    k = malloc (sizeof(*k));
    if (k == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy(k, &context->kt_types[i], sizeof(*k));
    k->data = NULL;
    ret = (*k->resolve)(context, residual, k);
    if(ret) {
	free(k);
	k = NULL;
    }
    *id = k;
    return ret;
}

/**
 * copy the name of the default keytab into `name'.
 *
 * @@param context a Keberos context.
 * @@param name buffer where the name will be written
 * @@param namesize length of name
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_default_name(krb5_context context, char *name, size_t namesize)
{
    if (strlcpy (name, context->default_keytab, namesize) >= namesize) {
	krb5_clear_error_message (context);
	return KRB5_CONFIG_NOTENUFSPACE;
    }
    return 0;
}

/**
 * Copy the name of the default modify keytab into `name'.
 *
 * @@param context a Keberos context.
 * @@param name buffer where the name will be written
 * @@param namesize length of name
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_default_modify_name(krb5_context context, char *name, size_t namesize)
{
    const char *kt = NULL;
    if(context->default_keytab_modify == NULL) {
	if(strncasecmp(context->default_keytab, "ANY:", 4) != 0)
	    kt = context->default_keytab;
	else {
	    size_t len = strcspn(context->default_keytab + 4, ",");
	    if(len >= namesize) {
		krb5_clear_error_message(context);
		return KRB5_CONFIG_NOTENUFSPACE;
	    }
	    strlcpy(name, context->default_keytab + 4, namesize);
	    name[len] = '\0';
	    return 0;
	}
    } else
	kt = context->default_keytab_modify;
    if (strlcpy (name, kt, namesize) >= namesize) {
	krb5_clear_error_message (context);
	return KRB5_CONFIG_NOTENUFSPACE;
    }
    return 0;
}

/**
 * Set `id' to the default keytab.
 *
 * @@param context a Keberos context.
 * @@param id the new default keytab.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_default(krb5_context context, krb5_keytab *id)
{
    return krb5_kt_resolve (context, context->default_keytab, id);
}

/**
 * Read the key identified by `(principal, vno, enctype)' from the
 * keytab in `keyprocarg' (the default if == NULL) into `*key'.
 *
 * @@param context a Keberos context.
 * @@param keyprocarg
 * @@param principal
 * @@param vno
 * @@param enctype
 * @@param key
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_read_service_key(krb5_context context,
			 krb5_pointer keyprocarg,
			 krb5_principal principal,
			 krb5_kvno vno,
			 krb5_enctype enctype,
			 krb5_keyblock **key)
{
    krb5_keytab keytab;
    krb5_keytab_entry entry;
    krb5_error_code ret;

    if (keyprocarg)
	ret = krb5_kt_resolve (context, keyprocarg, &keytab);
    else
	ret = krb5_kt_default (context, &keytab);

    if (ret)
	return ret;

    ret = krb5_kt_get_entry (context, keytab, principal, vno, enctype, &entry);
    krb5_kt_close (context, keytab);
    if (ret)
	return ret;
    ret = krb5_copy_keyblock (context, &entry.keyblock, key);
    krb5_kt_free_entry(context, &entry);
    return ret;
}

/**
 * Return the type of the `keytab' in the string `prefix of length
 * `prefixsize'.
 *
 * @@param context a Keberos context.
 * @@param keytab the keytab to get the prefix for
 * @@param prefix prefix buffer
 * @@param prefixsize length of prefix buffer
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_get_type(krb5_context context,
		 krb5_keytab keytab,
		 char *prefix,
		 size_t prefixsize)
{
    strlcpy(prefix, keytab->prefix, prefixsize);
    return 0;
}

/**
 * Retrieve the name of the keytab `keytab' into `name', `namesize'
 *
 * @@param context a Keberos context.
 * @@param keytab the keytab to get the name for.
 * @@param name name buffer.
 * @@param namesize size of name buffer.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_get_name(krb5_context context,
		 krb5_keytab keytab,
		 char *name,
		 size_t namesize)
{
    return (*keytab->get_name)(context, keytab, name, namesize);
}

/**
 * Retrieve the full name of the keytab `keytab' and store the name in
 * `str'.
 *
 * @@param context a Keberos context.
 * @@param keytab keytab to get name for.
 * @@param str the name of the keytab name, usee krb5_xfree() to free
 *        the string.  On error, *str is set to NULL.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_get_full_name(krb5_context context,
		      krb5_keytab keytab,
		      char **str)
{
    char type[KRB5_KT_PREFIX_MAX_LEN];
    char name[MAXPATHLEN];
    krb5_error_code ret;

    *str = NULL;

    ret = krb5_kt_get_type(context, keytab, type, sizeof(type));
    if (ret)
	return ret;

    ret = krb5_kt_get_name(context, keytab, name, sizeof(name));
    if (ret)
	return ret;

    if (asprintf(str, "%s:%s", type, name) == -1) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	*str = NULL;
	return ENOMEM;
    }

    return 0;
}

/**
 * Finish using the keytab in `id'.  All resources will be released,
 * even on errors.
 *
 * @@param context a Keberos context.
 * @@param id keytab to close.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_close(krb5_context context,
	      krb5_keytab id)
{
    krb5_error_code ret;

    ret = (*id->close)(context, id);
    memset(id, 0, sizeof(*id));
    free(id);
    return ret;
}

/**
 * Destroy (remove) the keytab in `id'.  All resources will be released,
 * even on errors, does the equvalment of krb5_kt_close() on the resources.
 *
 * @@param context a Keberos context.
 * @@param id keytab to destroy.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_destroy(krb5_context context,
		krb5_keytab id)
{
    krb5_error_code ret;

    ret = (*id->destroy)(context, id);
    krb5_kt_close(context, id);
    return ret;
}

/*
 * Match any aliases in keytab `entry' with `principal'.
 */

static krb5_boolean
compare_aliseses(krb5_context context,
		 krb5_keytab_entry *entry,
		 krb5_const_principal principal)
{
    unsigned int i;
    if (entry->aliases == NULL)
	return FALSE;
    for (i = 0; i < entry->aliases->len; i++)
	if (krb5_principal_compare(context, &entry->aliases->val[i], principal))
	    return TRUE;
    return FALSE;
}

/**
 * Compare `entry' against `principal, vno, enctype'.
 * Any of `principal, vno, enctype' might be 0 which acts as a wildcard.
 * Return TRUE if they compare the same, FALSE otherwise.
 *
 * @@param context a Keberos context.
 * @@param entry an entry to match with.
 * @@param principal principal to match, NULL matches all principals.
 * @@param vno key version to match, 0 matches all key version numbers.
 * @@param enctype encryption type to match, 0 matches all encryption types.
 *
 * @@return Return TRUE or match, FALSE if not matched.
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_kt_compare(krb5_context context,
		krb5_keytab_entry *entry,
		krb5_const_principal principal,
		krb5_kvno vno,
		krb5_enctype enctype)
{
    if(principal != NULL &&
       !(krb5_principal_compare(context, entry->principal, principal) ||
	 compare_aliseses(context, entry, principal)))
	return FALSE;
    if(vno && vno != entry->vno)
	return FALSE;
    if(enctype && enctype != entry->keyblock.keytype)
	return FALSE;
    return TRUE;
}

krb5_error_code
_krb5_kt_principal_not_found(krb5_context context,
			     krb5_error_code ret,
			     krb5_keytab id,
			     krb5_const_principal principal,
			     krb5_enctype enctype,
			     int kvno)
{
    char princ[256], kvno_str[25], *kt_name;
    char *enctype_str = NULL;

    krb5_unparse_name_fixed (context, principal, princ, sizeof(princ));
    krb5_kt_get_full_name (context, id, &kt_name);
    krb5_enctype_to_string(context, enctype, &enctype_str);

    if (kvno)
	snprintf(kvno_str, sizeof(kvno_str), "(kvno %d)", kvno);
    else
	kvno_str[0] = '\0';

    krb5_set_error_message (context, ret,
			    N_("Failed to find %s%s in keytab %s (%s)",
			       "principal, kvno, keytab file, enctype"),
			    princ,
			    kvno_str,
			    kt_name ? kt_name : "unknown keytab",
			    enctype_str ? enctype_str : "unknown enctype");
    free(kt_name);
    free(enctype_str);
    return ret;
}


/**
 * Retrieve the keytab entry for `principal, kvno, enctype' into `entry'
 * from the keytab `id'. Matching is done like krb5_kt_compare().
 *
 * @@param context a Keberos context.
 * @@param id a keytab.
 * @@param principal principal to match, NULL matches all principals.
 * @@param kvno key version to match, 0 matches all key version numbers.
 * @@param enctype encryption type to match, 0 matches all encryption types.
 * @@param entry the returned entry, free with krb5_kt_free_entry().
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_get_entry(krb5_context context,
		  krb5_keytab id,
		  krb5_const_principal principal,
		  krb5_kvno kvno,
		  krb5_enctype enctype,
		  krb5_keytab_entry *entry)
{
    krb5_keytab_entry tmp;
    krb5_error_code ret;
    krb5_kt_cursor cursor;

    if(id->get)
	return (*id->get)(context, id, principal, kvno, enctype, entry);

    ret = krb5_kt_start_seq_get (context, id, &cursor);
    if (ret) {
	/* This is needed for krb5_verify_init_creds, but keep error
	 * string from previous error for the human. */
	context->error_code = KRB5_KT_NOTFOUND;
	return KRB5_KT_NOTFOUND;
    }

    entry->vno = 0;
    while (krb5_kt_next_entry(context, id, &tmp, &cursor) == 0) {
	if (krb5_kt_compare(context, &tmp, principal, 0, enctype)) {
	    /* the file keytab might only store the lower 8 bits of
	       the kvno, so only compare those bits */
	    if (kvno == tmp.vno
		|| (tmp.vno < 256 && kvno % 256 == tmp.vno)) {
		krb5_kt_copy_entry_contents (context, &tmp, entry);
		krb5_kt_free_entry (context, &tmp);
		krb5_kt_end_seq_get(context, id, &cursor);
		return 0;
	    } else if (kvno == 0 && tmp.vno > entry->vno) {
		if (entry->vno)
		    krb5_kt_free_entry (context, entry);
		krb5_kt_copy_entry_contents (context, &tmp, entry);
	    }
	}
	krb5_kt_free_entry(context, &tmp);
    }
    krb5_kt_end_seq_get (context, id, &cursor);
    if (entry->vno == 0)
	return _krb5_kt_principal_not_found(context, KRB5_KT_NOTFOUND,
					    id, principal, enctype, kvno);
    return 0;
}

/**
 * Copy the contents of `in' into `out'.
 *
 * @@param context a Keberos context.
 * @@param in the keytab entry to copy.
 * @@param out the copy of the keytab entry, free with krb5_kt_free_entry().
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_copy_entry_contents(krb5_context context,
			    const krb5_keytab_entry *in,
			    krb5_keytab_entry *out)
{
    krb5_error_code ret;

    memset(out, 0, sizeof(*out));
    out->vno = in->vno;

    ret = krb5_copy_principal (context, in->principal, &out->principal);
    if (ret)
	goto fail;
    ret = krb5_copy_keyblock_contents (context,
				       &in->keyblock,
				       &out->keyblock);
    if (ret)
	goto fail;
    out->timestamp = in->timestamp;
    return 0;
fail:
    krb5_kt_free_entry (context, out);
    return ret;
}

/**
 * Free the contents of `entry'.
 *
 * @@param context a Keberos context.
 * @@param entry the entry to free
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_free_entry(krb5_context context,
		   krb5_keytab_entry *entry)
{
    krb5_free_principal (context, entry->principal);
    krb5_free_keyblock_contents (context, &entry->keyblock);
    memset(entry, 0, sizeof(*entry));
    return 0;
}

/**
 * Set `cursor' to point at the beginning of `id'.
 *
 * @@param context a Keberos context.
 * @@param id a keytab.
 * @@param cursor a newly allocated cursor, free with krb5_kt_end_seq_get().
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_start_seq_get(krb5_context context,
		      krb5_keytab id,
		      krb5_kt_cursor *cursor)
{
    if(id->start_seq_get == NULL) {
	krb5_set_error_message(context, HEIM_ERR_OPNOTSUPP,
			       N_("start_seq_get is not supported "
				  "in the %s keytab type", ""),
			       id->prefix);
	return HEIM_ERR_OPNOTSUPP;
    }
    return (*id->start_seq_get)(context, id, cursor);
}

/**
 * Get the next entry from keytab, advance the cursor.  On last entry
 * the function will return KRB5_KT_END.
 *
 * @@param context a Keberos context.
 * @@param id a keytab.
 * @@param entry the returned entry, free with krb5_kt_free_entry().
 * @@param cursor the cursor of the iteration.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_next_entry(krb5_context context,
		   krb5_keytab id,
		   krb5_keytab_entry *entry,
		   krb5_kt_cursor *cursor)
{
    if(id->next_entry == NULL) {
	krb5_set_error_message(context, HEIM_ERR_OPNOTSUPP,
			       N_("next_entry is not supported in the %s "
				  " keytab", ""),
			       id->prefix);
	return HEIM_ERR_OPNOTSUPP;
    }
    return (*id->next_entry)(context, id, entry, cursor);
}

/**
 * Release all resources associated with `cursor'.
 *
 * @@param context a Keberos context.
 * @@param id a keytab.
 * @@param cursor the cursor to free.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_end_seq_get(krb5_context context,
		    krb5_keytab id,
		    krb5_kt_cursor *cursor)
{
    if(id->end_seq_get == NULL) {
	krb5_set_error_message(context, HEIM_ERR_OPNOTSUPP,
			       "end_seq_get is not supported in the %s "
			       " keytab", id->prefix);
	return HEIM_ERR_OPNOTSUPP;
    }
    return (*id->end_seq_get)(context, id, cursor);
}

/**
 * Add the entry in `entry' to the keytab `id'.
 *
 * @@param context a Keberos context.
 * @@param id a keytab.
 * @@param entry the entry to add
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_add_entry(krb5_context context,
		  krb5_keytab id,
		  krb5_keytab_entry *entry)
{
    if(id->add == NULL) {
	krb5_set_error_message(context, KRB5_KT_NOWRITE,
			       N_("Add is not supported in the %s keytab", ""),
			       id->prefix);
	return KRB5_KT_NOWRITE;
    }
    entry->timestamp = time(NULL);
    return (*id->add)(context, id,entry);
}

/**
 * Remove an entry from the keytab, matching is done using
 * krb5_kt_compare().

 * @@param context a Keberos context.
 * @@param id a keytab.
 * @@param entry the entry to remove
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_kt_remove_entry(krb5_context context,
		     krb5_keytab id,
		     krb5_keytab_entry *entry)
{
    if(id->remove == NULL) {
	krb5_set_error_message(context, KRB5_KT_NOWRITE,
			       N_("Remove is not supported in the %s keytab", ""),
			       id->prefix);
	return KRB5_KT_NOWRITE;
    }
    return (*id->remove)(context, id, entry);
}

/**
 * Return true if the keytab exists and have entries
 *
 * @@param context a Keberos context.
 * @@param id a keytab.
 *
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_keytab
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_kt_have_content(krb5_context context,
		     krb5_keytab id)
{
    krb5_keytab_entry entry;
    krb5_kt_cursor cursor;
    krb5_error_code ret;
    char *name;

    ret = krb5_kt_start_seq_get(context, id, &cursor);
    if (ret)
	goto notfound;

    ret = krb5_kt_next_entry(context, id, &entry, &cursor);
    krb5_kt_end_seq_get(context, id, &cursor);
    if (ret)
	goto notfound;

    krb5_kt_free_entry(context, &entry);

    return 0;

 notfound:
    ret = krb5_kt_get_full_name(context, id, &name);
    if (ret == 0) {
	krb5_set_error_message(context, KRB5_KT_NOTFOUND,
			       N_("No entry in keytab: %s", ""), name);
	free(name);
    }
    return KRB5_KT_NOTFOUND;
}
@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.1
log
@Initial revision
@
text
@d2 30
a31 30
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d36 94
a129 1
RCSID("$KTH: keytab.c,v 1.46 2000/02/07 03:18:05 assar Exp $");
d131 9
a139 3
/*
 * Register a new keytab in `ops'
 * Return 0 or an error.
d142 1
a142 1
krb5_error_code
d148 6
d156 3
a158 1
    if(tmp == NULL)
d160 1
d168 29
a196 1
/*
d199 8
a206 1
 * Return 0 or an error
d209 2
a210 1
krb5_error_code
d221 2
a222 11
    residual = strchr(name, ':');
    if(residual == NULL) {
	type = "FILE";
	type_len = strlen(type);
	residual = name;
    } else {
	type = name;
	type_len = residual - name;
	residual++;
    }
    
d224 1
a224 1
	if(strncmp(type, context->kt_types[i].prefix, type_len) == 0)
d227 4
a230 1
    if(i == context->num_kt_types)
d232 2
a233 1
    
d235 2
a236 1
    if (k == NULL)
d238 1
d250 1
a250 1
/*
d252 8
a259 1
 * Return 0 or KRB5_CONFIG_NOTENUFSPACE if `namesize' is too short.
d262 1
a262 1
krb5_error_code
d265 2
a266 1
    if (strlcpy (name, context->default_keytab, namesize) >= namesize)
d268 1
d272 39
a310 1
/*
d312 7
a318 1
 * Return 0 or an error.
d321 1
a321 1
krb5_error_code
d327 1
a327 1
/*
d330 11
a340 1
 * Return 0 or an error.
d343 1
a343 1
krb5_error_code
d372 25
a396 1
/*
d398 9
a406 1
 * Return 0 or an error.
d409 2
a410 2
krb5_error_code
krb5_kt_get_name(krb5_context context, 
d418 52
a469 3
/*
 * Finish using the keytab in `id'.  All resources will be released.
 * Return 0 or an error.
d472 2
a473 2
krb5_error_code
krb5_kt_close(krb5_context context, 
d479 25
a503 2
    if(ret == 0)
	free(id);
d508 18
d529 10
d541 1
a541 1
krb5_boolean
d543 1
a543 1
		krb5_keytab_entry *entry, 
d548 3
a550 2
    if(principal != NULL && 
       !krb5_principal_compare(context, entry->principal, principal))
d559 34
a592 1
/*
d594 12
a605 2
 * from the keytab `id'.
 * Return 0 or an error.
d608 1
a608 1
krb5_error_code
d624 6
a629 2
    if (ret)
	return KRB5_KT_NOTFOUND; /* XXX i.e. file not found */
d634 4
a637 1
	    if (kvno == tmp.vno) {
d651 4
a654 4
    if (entry->vno)
	return 0;
    else
	return KRB5_KT_NOTFOUND;
d657 1
a657 1
/*
d659 8
a666 1
 * Return 0 or an error.
d669 1
a669 1
krb5_error_code
d694 1
a694 1
/*
d696 7
d705 1
a705 1
krb5_error_code
d709 3
a711 14
  krb5_free_principal (context, entry->principal);
  krb5_free_keyblock_contents (context, &entry->keyblock);
  return 0;
}

#if 0
static int
xxxlock(int fd, int write)
{
    if(flock(fd, (write ? LOCK_EX : LOCK_SH) | LOCK_NB) < 0) {
	sleep(1);
	if(flock(fd, (write ? LOCK_EX : LOCK_SH) | LOCK_NB) < 0) 
	    return -1;
    }
d715 1
a715 8
static void
xxxunlock(int fd)
{
    flock(fd, LOCK_UN);
}
#endif

/*
d717 8
a724 1
 * Return 0 or an error.
d727 1
a727 1
krb5_error_code
d732 5
a736 1
    if(id->start_seq_get == NULL)
d738 1
d742 12
a753 4
/*
 * Get the next entry from `id' pointed to by `cursor' and advance the
 * `cursor'.
 * Return 0 or an error.
d756 1
a756 1
krb5_error_code
d762 5
a766 1
    if(id->next_entry == NULL)
d768 1
d772 1
a772 1
/*
d774 8
d784 1
a784 1
krb5_error_code
d789 4
a792 1
    if(id->end_seq_get == NULL)
d794 1
d798 1
a798 1
/*
d800 8
a807 1
 * Return 0 or an error.
d810 1
a810 1
krb5_error_code
d815 4
a818 1
    if(id->add == NULL)
d820 1
d825 11
a835 3
/*
 * Remove the entry `entry' from the keytab `id'.
 * Return 0 or an error.
d838 1
a838 1
krb5_error_code
d843 4
a846 1
    if(id->remove == NULL)
d848 1
d850 43
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: keytab.c,v 1.50 2001/05/14 06:14:48 assar Exp $");
d51 1
a51 2
    if(tmp == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a52 1
    }
d92 1
a92 3
    if(i == context->num_kt_types) {
	krb5_set_error_string(context, "unknown keytab type %.*s", 
			      (int)type_len, type);
a93 1
    }
d96 1
a96 2
    if (k == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a97 1
    }
d117 1
a117 2
    if (strlcpy (name, context->default_keytab, namesize) >= namesize) {
	krb5_clear_error_string (context);
a118 16
    }
    return 0;
}

/*
 * copy the name of the default modify keytab into `name'.
 * Return 0 or KRB5_CONFIG_NOTENUFSPACE if `namesize' is too short.
 */

krb5_error_code
krb5_kt_default_modify_name(krb5_context context, char *name, size_t namesize)
{
    if (strlcpy (name, context->default_keytab_modify, namesize) >= namesize) {
	krb5_clear_error_string (context);
	return KRB5_CONFIG_NOTENUFSPACE;
    }
d264 1
a264 1
    if (entry->vno) {
d266 1
a266 9
    } else {
	char princ[256], kt_name[256];

	krb5_unparse_name_fixed (context, principal, princ, sizeof(princ));
	krb5_kt_get_name (context, id, kt_name, sizeof(kt_name));

	krb5_set_error_string (context,
 			       "failed to find %s in keytab %s",
			       princ, kt_name);
a267 1
    }
d342 1
a342 4
    if(id->start_seq_get == NULL) {
	krb5_set_error_string(context,
			      "start_seq_get is not supported in the %s "
			      " keytab", id->prefix);
a343 1
    }
d359 1
a359 4
    if(id->next_entry == NULL) {
	krb5_set_error_string(context,
			      "next_entry is not supported in the %s "
			      " keytab", id->prefix);
a360 1
    }
d373 1
a373 4
    if(id->end_seq_get == NULL) {
	krb5_set_error_string(context,
			      "end_seq_get is not supported in the %s "
			      " keytab", id->prefix);
a374 1
    }
d388 1
a388 3
    if(id->add == NULL) {
	krb5_set_error_string(context, "Add is not supported in the %s keytab",
			      id->prefix);
a389 1
    }
d404 1
a404 4
    if(id->remove == NULL) {
	krb5_set_error_string(context,
			      "Remove is not supported in the %s keytab",
			      id->prefix);
a405 1
    }
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: keytab.c,v 1.55 2003/03/27 03:45:01 lha Exp $");
a48 5
    if (strlen(ops->prefix) > KRB5_KT_PREFIX_MAX_LEN - 1) {
	krb5_set_error_string(context, "krb5_kt_register; prefix too long");
	return KRB5_KT_NAME_TOOLONG;
    }

d91 1
a91 1
	if(strncasecmp(type, context->kt_types[i].prefix, type_len) == 0)
d139 1
a139 17
    const char *kt = NULL;
    if(context->default_keytab_modify == NULL) {
	if(strncasecmp(context->default_keytab, "ANY:", 4) != 0)
	    kt = context->default_keytab;
	else {
	    size_t len = strcspn(context->default_keytab + 4, ",");
	    if(len >= namesize) {
		krb5_clear_error_string(context);
		return KRB5_CONFIG_NOTENUFSPACE;
	    }
	    strlcpy(name, context->default_keytab + 4, namesize);
	    name[len] = '\0';
	    return 0;
	}    
    } else
	kt = context->default_keytab_modify;
    if (strlcpy (name, kt, namesize) >= namesize) {
a192 15
 * Return the type of the `keytab' in the string `prefix of length
 * `prefixsize'.
 */

krb5_error_code
krb5_kt_get_type(krb5_context context,
		 krb5_keytab keytab,
		 char *prefix,
		 size_t prefixsize)
{
    strlcpy(prefix, keytab->prefix, prefixsize);
    return 0;
}

/*
a248 1
 * kvno == 0 is a wildcard and gives the keytab with the highest vno.
d274 1
a274 4
	    /* the file keytab might only store the lower 8 bits of
	       the kvno, so only compare those bits */
	    if (kvno == tmp.vno
		|| (tmp.vno < 256 && kvno % 256 == tmp.vno)) {
d291 1
a291 1
	char princ[256], kt_name[256], kvno_str[25];
a295 5
	if (kvno)
	    snprintf(kvno_str, sizeof(kvno_str), "(kvno %d)", kvno);
	else
	    kvno_str[0] = '\0';

d297 2
a298 4
 			       "failed to find %s%s in keytab %s",
			       princ,
			       kvno_str,
			       kt_name);
d305 2
a306 1
 * Return 0 or an error.  */
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: keytab.c,v 1.60 2005/05/19 14:04:45 lha Exp $");
d43 1
a43 1
krb5_error_code KRB5_LIB_FUNCTION
d51 1
a51 1
	return KRB5_KT_BADNAME;
d73 1
a73 1
krb5_error_code KRB5_LIB_FUNCTION
d126 1
a126 1
krb5_error_code KRB5_LIB_FUNCTION
d141 1
a141 1
krb5_error_code KRB5_LIB_FUNCTION
d172 1
a172 1
krb5_error_code KRB5_LIB_FUNCTION
d184 1
a184 1
krb5_error_code KRB5_LIB_FUNCTION
d218 1
a218 1
krb5_error_code KRB5_LIB_FUNCTION
d233 1
a233 1
krb5_error_code KRB5_LIB_FUNCTION
d247 1
a247 1
krb5_error_code KRB5_LIB_FUNCTION
d265 1
a265 1
krb5_boolean KRB5_LIB_FUNCTION
d289 1
a289 1
krb5_error_code KRB5_LIB_FUNCTION
a331 1
	char *enctype_str = NULL;
a334 1
	krb5_enctype_to_string(context, enctype, &enctype_str);
d342 1
a342 1
 			       "failed to find %s%s in keytab %s (%s)",
d345 1
a345 3
			       kt_name,
			       enctype_str ? enctype_str : "unknown enctype");
	free(enctype_str);
d354 1
a354 1
krb5_error_code KRB5_LIB_FUNCTION
d383 1
a383 1
krb5_error_code KRB5_LIB_FUNCTION
d387 14
a400 3
    krb5_free_principal (context, entry->principal);
    krb5_free_keyblock_contents (context, &entry->keyblock);
    memset(entry, 0, sizeof(*entry));
d404 7
d416 1
a416 1
krb5_error_code KRB5_LIB_FUNCTION
d436 1
a436 1
krb5_error_code KRB5_LIB_FUNCTION
d455 1
a455 1
krb5_error_code KRB5_LIB_FUNCTION
d474 1
a474 1
krb5_error_code KRB5_LIB_FUNCTION
d493 1
a493 1
krb5_error_code KRB5_LIB_FUNCTION
@


