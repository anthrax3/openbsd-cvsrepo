head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.22.10.01.32;	author reyk;	state dead;
branches;
next	1.7;

1.7
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.14.08.15.05;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.29.16.20.31;	author biorn;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.26.11.07.00;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.05.16.16.50;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.51.01;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.51.01;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.24.47;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.40;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.16.00;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.37;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.33.33;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1999 - 2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"
#include <getarg.h>
#include <parse_bytes.h>
#include <err.h>

/* verify krb5.conf */

static int dumpconfig_flag = 0;
static int version_flag = 0;
static int help_flag	= 0;
static int warn_mit_syntax_flag = 0;

static struct getargs args[] = {
    {"dumpconfig", 0,      arg_flag,       &dumpconfig_flag,
     "show the parsed config files", NULL },
    {"warn-mit-syntax", 0, arg_flag,       &warn_mit_syntax_flag,
     "show the parsed config files", NULL },
    {"version",	0,	arg_flag,	&version_flag,
     "print version", NULL },
    {"help",	0,	arg_flag,	&help_flag,
     NULL, NULL }
};

static void
usage (int ret)
{
    arg_printusage (args,
		    sizeof(args)/sizeof(*args),
		    NULL,
		    "[config-file]");
    exit (ret);
}

static int
check_bytes(krb5_context context, const char *path, char *data)
{
    if(parse_bytes(data, NULL) == -1) {
	krb5_warnx(context, "%s: failed to parse \"%s\" as size", path, data);
	return 1;
    }
    return 0;
}

static int
check_time(krb5_context context, const char *path, char *data)
{
    if(parse_time(data, NULL) == -1) {
	krb5_warnx(context, "%s: failed to parse \"%s\" as time", path, data);
	return 1;
    }
    return 0;
}

static int
check_numeric(krb5_context context, const char *path, char *data)
{
    long v;
    char *end;
    v = strtol(data, &end, 0);

    if ((v == LONG_MIN || v == LONG_MAX) && errno != 0) {
	krb5_warnx(context, "%s: over/under flow for \"%s\"",
		   path, data);
	return 1;
    }
    if(*end != '\0') {
	krb5_warnx(context, "%s: failed to parse \"%s\" as a number",
		   path, data);
	return 1;
    }
    return 0;
}

static int
check_boolean(krb5_context context, const char *path, char *data)
{
    long int v;
    char *end;
    if(strcasecmp(data, "yes") == 0 ||
       strcasecmp(data, "true") == 0 ||
       strcasecmp(data, "no") == 0 ||
       strcasecmp(data, "false") == 0)
	return 0;
    v = strtol(data, &end, 0);
    if(*end != '\0') {
	krb5_warnx(context, "%s: failed to parse \"%s\" as a boolean",
		   path, data);
	return 1;
    }
    if(v != 0 && v != 1)
	krb5_warnx(context, "%s: numeric value \"%s\" is treated as \"true\"",
		   path, data);
    return 0;
}

static int
check_524(krb5_context context, const char *path, char *data)
{
    if(strcasecmp(data, "yes") == 0 ||
       strcasecmp(data, "no") == 0 ||
       strcasecmp(data, "2b") == 0 ||
       strcasecmp(data, "local") == 0)
	return 0;

    krb5_warnx(context, "%s: didn't contain a valid option `%s'",
	       path, data);
    return 1;
}

static int
check_host(krb5_context context, const char *path, char *data)
{
    int ret;
    char hostname[128];
    const char *p = data;
    struct addrinfo hints;
    char service[32];
    int defport;
    struct addrinfo *ai;

    hints.ai_flags = 0;
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = 0;
    hints.ai_protocol = 0;

    hints.ai_addrlen = 0;
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    /* XXX data could be a list of hosts that this code can't handle */
    /* XXX copied from krbhst.c */
    if(strncmp(p, "http://", 7) == 0){
        p += 7;
	hints.ai_socktype = SOCK_STREAM;
	strlcpy(service, "http", sizeof(service));
	defport = 80;
    } else if(strncmp(p, "http/", 5) == 0) {
        p += 5;
	hints.ai_socktype = SOCK_STREAM;
	strlcpy(service, "http", sizeof(service));
	defport = 80;
    }else if(strncmp(p, "tcp/", 4) == 0){
        p += 4;
	hints.ai_socktype = SOCK_STREAM;
	strlcpy(service, "kerberos", sizeof(service));
	defport = 88;
    } else if(strncmp(p, "udp/", 4) == 0) {
        p += 4;
	hints.ai_socktype = SOCK_DGRAM;
	strlcpy(service, "kerberos", sizeof(service));
	defport = 88;
    } else {
	hints.ai_socktype = SOCK_DGRAM;
	strlcpy(service, "kerberos", sizeof(service));
	defport = 88;
    }
    if(strsep_copy(&p, ":", hostname, sizeof(hostname)) < 0) {
	return 1;
    }
    hostname[strcspn(hostname, "/")] = '\0';
    if(p != NULL) {
	char *end;
	int tmp = strtol(p, &end, 0);
	if(end == p) {
	    krb5_warnx(context, "%s: failed to parse port number in %s",
		       path, data);
	    return 1;
	}
	defport = tmp;
	snprintf(service, sizeof(service), "%u", defport);
    }
    ret = getaddrinfo(hostname, service, &hints, &ai);
    if(ret == EAI_SERVICE && !isdigit((unsigned char)service[0])) {
	snprintf(service, sizeof(service), "%u", defport);
	ret = getaddrinfo(hostname, service, &hints, &ai);
    }
    if(ret != 0) {
	krb5_warnx(context, "%s: %s (%s)", path, gai_strerror(ret), hostname);
	return 1;
    }
    return 0;
}

static int
mit_entry(krb5_context context, const char *path, char *data)
{
    if (warn_mit_syntax_flag)
	krb5_warnx(context, "%s is only used by MIT Kerberos", path);
    return 0;
}

struct s2i {
    const char *s;
    int val;
};

#define L(X) { #X, LOG_ ## X }

static struct s2i syslogvals[] = {
    /* severity */
    L(EMERG),
    L(ALERT),
    L(CRIT),
    L(ERR),
    L(WARNING),
    L(NOTICE),
    L(INFO),
    L(DEBUG),
    /* facility */
    L(AUTH),
#ifdef LOG_AUTHPRIV
    L(AUTHPRIV),
#endif
#ifdef LOG_CRON
    L(CRON),
#endif
    L(DAEMON),
#ifdef LOG_FTP
    L(FTP),
#endif
    L(KERN),
    L(LPR),
    L(MAIL),
#ifdef LOG_NEWS
    L(NEWS),
#endif
    L(SYSLOG),
    L(USER),
#ifdef LOG_UUCP
    L(UUCP),
#endif
    L(LOCAL0),
    L(LOCAL1),
    L(LOCAL2),
    L(LOCAL3),
    L(LOCAL4),
    L(LOCAL5),
    L(LOCAL6),
    L(LOCAL7),
    { NULL, -1 }
};

static int
find_value(const char *s, struct s2i *table)
{
    while(table->s && strcasecmp(table->s, s))
	table++;
    return table->val;
}

static int
check_log(krb5_context context, const char *path, char *data)
{
    /* XXX sync with log.c */
    int min = 0, max = -1, n;
    char c;
    const char *p = data;

    n = sscanf(p, "%d%c%d/", &min, &c, &max);
    if(n == 2){
	if(c == '/') {
	    if(min < 0){
		max = -min;
		min = 0;
	    }else{
		max = min;
	    }
	}
    }
    if(n){
	p = strchr(p, '/');
	if(p == NULL) {
	    krb5_warnx(context, "%s: failed to parse \"%s\"", path, data);
	    return 1;
	}
	p++;
    }
    if(strcmp(p, "STDERR") == 0 ||
       strcmp(p, "CONSOLE") == 0 ||
       (strncmp(p, "FILE", 4) == 0 && (p[4] == ':' || p[4] == '=')) ||
       (strncmp(p, "DEVICE", 6) == 0 && p[6] == '='))
	return 0;
    if(strncmp(p, "SYSLOG", 6) == 0){
	int ret = 0;
	char severity[128] = "";
	char facility[128] = "";
	p += 6;
	if(*p != '\0')
	    p++;
	if(strsep_copy(&p, ":", severity, sizeof(severity)) != -1)
	    strsep_copy(&p, ":", facility, sizeof(facility));
	if(*severity == '\0')
	    strlcpy(severity, "ERR", sizeof(severity));
 	if(*facility == '\0')
	    strlcpy(facility, "AUTH", sizeof(facility));
	if(find_value(severity, syslogvals) == -1) {
	    krb5_warnx(context, "%s: unknown syslog facility \"%s\"",
		       path, facility);
	    ret++;
	}
	if(find_value(severity, syslogvals) == -1) {
	    krb5_warnx(context, "%s: unknown syslog severity \"%s\"",
		       path, severity);
	    ret++;
	}
	return ret;
    }else{
	krb5_warnx(context, "%s: unknown log type: \"%s\"", path, data);
	return 1;
    }
}

typedef int (*check_func_t)(krb5_context, const char*, char*);
struct entry {
    const char *name;
    int type;
    void *check_data;
    int deprecated;
};

struct entry all_strings[] = {
    { "", krb5_config_string, NULL },
    { NULL }
};

struct entry all_boolean[] = {
    { "", krb5_config_string, check_boolean },
    { NULL }
};


struct entry v4_name_convert_entries[] = {
    { "host", krb5_config_list, all_strings },
    { "plain", krb5_config_list, all_strings },
    { NULL }
};

struct entry libdefaults_entries[] = {
    { "accept_null_addresses", krb5_config_string, check_boolean },
    { "allow_weak_crypto", krb5_config_string, check_boolean },
    { "capath", krb5_config_list, all_strings, 1 },
    { "check_pac", krb5_config_string, check_boolean },
    { "clockskew", krb5_config_string, check_time },
    { "date_format", krb5_config_string, NULL },
    { "default_cc_name", krb5_config_string, NULL },
    { "default_etypes", krb5_config_string, NULL },
    { "default_etypes_des", krb5_config_string, NULL },
    { "default_keytab_modify_name", krb5_config_string, NULL },
    { "default_keytab_name", krb5_config_string, NULL },
    { "default_realm", krb5_config_string, NULL },
    { "dns_canonize_hostname", krb5_config_string, check_boolean },
    { "dns_proxy", krb5_config_string, NULL },
    { "dns_lookup_kdc", krb5_config_string, check_boolean },
    { "dns_lookup_realm", krb5_config_string, check_boolean },
    { "dns_lookup_realm_labels", krb5_config_string, NULL },
    { "egd_socket", krb5_config_string, NULL },
    { "encrypt", krb5_config_string, check_boolean },
    { "extra_addresses", krb5_config_string, NULL },
    { "fcache_version", krb5_config_string, check_numeric },
    { "fcc-mit-ticketflags", krb5_config_string, check_boolean },
    { "forward", krb5_config_string, check_boolean },
    { "forwardable", krb5_config_string, check_boolean },
    { "http_proxy", krb5_config_string, check_host /* XXX */ },
    { "ignore_addresses", krb5_config_string, NULL },
    { "kdc_timeout", krb5_config_string, check_time },
    { "kdc_timesync", krb5_config_string, check_boolean },
    { "log_utc", krb5_config_string, check_boolean },
    { "maxretries", krb5_config_string, check_numeric },
    { "scan_interfaces", krb5_config_string, check_boolean },
    { "srv_lookup", krb5_config_string, check_boolean },
    { "srv_try_txt", krb5_config_string, check_boolean },
    { "ticket_lifetime", krb5_config_string, check_time },
    { "time_format", krb5_config_string, NULL },
    { "transited_realms_reject", krb5_config_string, NULL },
    { "no-addresses", krb5_config_string, check_boolean },
    { "v4_instance_resolve", krb5_config_string, check_boolean },
    { "v4_name_convert", krb5_config_list, v4_name_convert_entries },
    { "verify_ap_req_nofail", krb5_config_string, check_boolean },
    { "max_retries", krb5_config_string, check_time },
    { "renew_lifetime", krb5_config_string, check_time },
    { "proxiable", krb5_config_string, check_boolean },
    { "warn_pwexpire", krb5_config_string, check_time },
    /* MIT stuff */
    { "permitted_enctypes", krb5_config_string, mit_entry },
    { "default_tgs_enctypes", krb5_config_string, mit_entry },
    { "default_tkt_enctypes", krb5_config_string, mit_entry },
    { NULL }
};

struct entry appdefaults_entries[] = {
    { "afslog", krb5_config_string, check_boolean },
    { "afs-use-524", krb5_config_string, check_524 },
    { "encrypt", krb5_config_string, check_boolean },
    { "forward", krb5_config_string, check_boolean },
    { "forwardable", krb5_config_string, check_boolean },
    { "proxiable", krb5_config_string, check_boolean },
    { "ticket_lifetime", krb5_config_string, check_time },
    { "renew_lifetime", krb5_config_string, check_time },
    { "no-addresses", krb5_config_string, check_boolean },
    { "krb4_get_tickets", krb5_config_string, check_boolean },
    { "pkinit_anchors", krb5_config_string, NULL },
    { "pkinit_win2k", krb5_config_string, NULL },
    { "pkinit_win2k_require_binding", krb5_config_string, NULL },
    { "pkinit_require_eku", krb5_config_string, NULL },
    { "pkinit_require_krbtgt_otherName", krb5_config_string, NULL },
    { "pkinit_require_hostname_match", krb5_config_string, NULL },
#if 0
    { "anonymous", krb5_config_string, check_boolean },
#endif
    { "", krb5_config_list, appdefaults_entries },
    { NULL }
};

struct entry realms_entries[] = {
    { "forwardable", krb5_config_string, check_boolean },
    { "proxiable", krb5_config_string, check_boolean },
    { "ticket_lifetime", krb5_config_string, check_time },
    { "renew_lifetime", krb5_config_string, check_time },
    { "warn_pwexpire", krb5_config_string, check_time },
    { "kdc", krb5_config_string, check_host },
    { "admin_server", krb5_config_string, check_host },
    { "kpasswd_server", krb5_config_string, check_host },
    { "krb524_server", krb5_config_string, check_host },
    { "v4_name_convert", krb5_config_list, v4_name_convert_entries },
    { "v4_instance_convert", krb5_config_list, all_strings },
    { "v4_domains", krb5_config_string, NULL },
    { "default_domain", krb5_config_string, NULL },
    { "win2k_pkinit", krb5_config_string, NULL },
    /* MIT stuff */
    { "admin_keytab", krb5_config_string, mit_entry },
    { "acl_file", krb5_config_string, mit_entry },
    { "dict_file", krb5_config_string, mit_entry },
    { "kadmind_port", krb5_config_string, mit_entry },
    { "kpasswd_port", krb5_config_string, mit_entry },
    { "master_key_name", krb5_config_string, mit_entry },
    { "master_key_type", krb5_config_string, mit_entry },
    { "key_stash_file", krb5_config_string, mit_entry },
    { "max_life", krb5_config_string, mit_entry },
    { "max_renewable_life", krb5_config_string, mit_entry },
    { "default_principal_expiration", krb5_config_string, mit_entry },
    { "default_principal_flags", krb5_config_string, mit_entry },
    { "supported_enctypes", krb5_config_string, mit_entry },
    { "database_name", krb5_config_string, mit_entry },
    { NULL }
};

struct entry realms_foobar[] = {
    { "", krb5_config_list, realms_entries },
    { NULL }
};


struct entry kdc_database_entries[] = {
    { "realm", krb5_config_string, NULL },
    { "dbname", krb5_config_string, NULL },
    { "mkey_file", krb5_config_string, NULL },
    { "acl_file", krb5_config_string, NULL },
    { "log_file", krb5_config_string, NULL },
    { NULL }
};

struct entry kdc_entries[] = {
    { "database", krb5_config_list, kdc_database_entries },
    { "key-file", krb5_config_string, NULL },
    { "logging", krb5_config_string, check_log },
    { "max-request", krb5_config_string, check_bytes },
    { "require-preauth", krb5_config_string, check_boolean },
    { "ports", krb5_config_string, NULL },
    { "addresses", krb5_config_string, NULL },
    { "enable-kerberos4", krb5_config_string, check_boolean },
    { "enable-524", krb5_config_string, check_boolean },
    { "enable-http", krb5_config_string, check_boolean },
    { "check-ticket-addresses", krb5_config_string, check_boolean },
    { "allow-null-ticket-addresses", krb5_config_string, check_boolean },
    { "allow-anonymous", krb5_config_string, check_boolean },
    { "v4_realm", krb5_config_string, NULL },
    { "enable-kaserver", krb5_config_string, check_boolean, 1 },
    { "encode_as_rep_as_tgs_rep", krb5_config_string, check_boolean },
    { "kdc_warn_pwexpire", krb5_config_string, check_time },
    { "use_2b", krb5_config_list, NULL },
    { "enable-pkinit", krb5_config_string, check_boolean },
    { "pkinit_identity", krb5_config_string, NULL },
    { "pkinit_anchors", krb5_config_string, NULL },
    { "pkinit_pool", krb5_config_string, NULL },
    { "pkinit_revoke", krb5_config_string, NULL },
    { "pkinit_kdc_ocsp", krb5_config_string, NULL },
    { "pkinit_principal_in_certificate", krb5_config_string, NULL },
    { "pkinit_dh_min_bits", krb5_config_string, NULL },
    { "pkinit_allow_proxy_certificate", krb5_config_string, NULL },
    { "hdb-ldap-create-base", krb5_config_string, NULL },
    { "v4-realm", krb5_config_string, NULL },
    { NULL }
};

struct entry kadmin_entries[] = {
    { "password_lifetime", krb5_config_string, check_time },
    { "default_keys", krb5_config_string, NULL },
    { "use_v4_salt", krb5_config_string, NULL },
    { "require-preauth", krb5_config_string, check_boolean },
    { NULL }
};
struct entry log_strings[] = {
    { "", krb5_config_string, check_log },
    { NULL }
};


/* MIT stuff */
struct entry kdcdefaults_entries[] = {
    { "kdc_ports", krb5_config_string, mit_entry },
    { "v4_mode", krb5_config_string, mit_entry },
    { NULL }
};

struct entry capaths_entries[] = {
    { "", krb5_config_list, all_strings },
    { NULL }
};

struct entry password_quality_entries[] = {
    { "policies", krb5_config_string, NULL },
    { "external_program", krb5_config_string, NULL },
    { "min_classes", krb5_config_string, check_numeric },
    { "min_length", krb5_config_string, check_numeric },
    { "", krb5_config_list, all_strings },
    { NULL }
};

struct entry toplevel_sections[] = {
    { "libdefaults" , krb5_config_list, libdefaults_entries },
    { "realms", krb5_config_list, realms_foobar },
    { "domain_realm", krb5_config_list, all_strings },
    { "logging", krb5_config_list, log_strings },
    { "kdc", krb5_config_list, kdc_entries },
    { "kadmin", krb5_config_list, kadmin_entries },
    { "appdefaults", krb5_config_list, appdefaults_entries },
    { "gssapi", krb5_config_list, NULL },
    { "capaths", krb5_config_list, capaths_entries },
    { "password_quality", krb5_config_list, password_quality_entries },
    /* MIT stuff */
    { "kdcdefaults", krb5_config_list, kdcdefaults_entries },
    { NULL }
};


static int
check_section(krb5_context context, const char *path, krb5_config_section *cf,
	      struct entry *entries)
{
    int error = 0;
    krb5_config_section *p;
    struct entry *e;

    char *local;

    for(p = cf; p != NULL; p = p->next) {
	local = NULL;
	if (asprintf(&local, "%s/%s", path, p->name) < 0 || local == NULL)
	    errx(1, "out of memory");
	for(e = entries; e->name != NULL; e++) {
	    if(*e->name == '\0' || strcmp(e->name, p->name) == 0) {
		if(e->type != p->type) {
		    krb5_warnx(context, "%s: unknown or wrong type", local);
		    error |= 1;
		} else if(p->type == krb5_config_string && e->check_data != NULL) {
		    error |= (*(check_func_t)e->check_data)(context, local, p->u.string);
		} else if(p->type == krb5_config_list && e->check_data != NULL) {
		    error |= check_section(context, local, p->u.list, e->check_data);
		}
		if(e->deprecated) {
		    krb5_warnx(context, "%s: is a deprecated entry", local);
		    error |= 1;
		}
		break;
	    }
	}
	if(e->name == NULL) {
	    krb5_warnx(context, "%s: unknown entry", local);
	    error |= 1;
	}
	free(local);
    }
    return error;
}


static void
dumpconfig(int level, krb5_config_section *top)
{
    krb5_config_section *x;
    for(x = top; x; x = x->next) {
	switch(x->type) {
	case krb5_config_list:
	    if(level == 0) {
		printf("[%s]\n", x->name);
	    } else {
		printf("%*s%s = {\n", 4 * level, " ", x->name);
	    }
	    dumpconfig(level + 1, x->u.list);
	    if(level > 0)
		printf("%*s}\n", 4 * level, " ");
	    break;
	case krb5_config_string:
	    printf("%*s%s = %s\n", 4 * level, " ", x->name, x->u.string);
	    break;
	}
    }
}

int
main(int argc, char **argv)
{
    krb5_context context;
    krb5_error_code ret;
    krb5_config_section *tmp_cf;
    int optidx = 0;

    setprogname (argv[0]);

    ret = krb5_init_context(&context);
    if (ret == KRB5_CONFIG_BADFORMAT)
	errx (1, "krb5_init_context failed to parse configuration file");
    else if (ret)
	errx (1, "krb5_init_context failed with %d", ret);

    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optidx))
	usage(1);

    if (help_flag)
	usage (0);

    if(version_flag){
	print_version(NULL);
	exit(0);
    }

    argc -= optidx;
    argv += optidx;

    tmp_cf = NULL;
    if(argc == 0)
	krb5_get_default_config_files(&argv);

    while(*argv) {
	ret = krb5_config_parse_file_multi(context, *argv, &tmp_cf);
	if (ret != 0)
	    krb5_warn (context, ret, "krb5_config_parse_file");
	argv++;
    }

    if(dumpconfig_flag)
	dumpconfig(0, tmp_cf);

    return check_section(context, "", tmp_cf, toplevel_sections);
}
@


1.7
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.6
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1999 - 2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a37 1
RCSID("$KTH: verify_krb5_conf.c,v 1.33 2005/06/14 00:06:17 lha Exp $");
d47 1
a47 1
    {"dumpconfig", 0,      arg_flag,       &dumpconfig_flag, 
d49 1
a49 1
    {"warn-mit-syntax", 0, arg_flag,       &warn_mit_syntax_flag, 
d90 1
a90 1
    long int v;
d93 6
d100 1
a100 1
	krb5_warnx(context, "%s: failed to parse \"%s\" as a number", 
d119 1
a119 1
	krb5_warnx(context, "%s: failed to parse \"%s\" as a boolean", 
d124 1
a124 1
	krb5_warnx(context, "%s: numeric value \"%s\" is treated as \"true\"", 
d138 1
a138 1
    krb5_warnx(context, "%s: didn't contain a valid option `%s'", 
d163 1
a163 1
    
d199 1
a199 1
	    krb5_warnx(context, "%s: failed to parse port number in %s", 
d312 1
a312 1
    if(strcmp(p, "STDERR") == 0 || 
d331 1
a331 1
	    krb5_warnx(context, "%s: unknown syslog facility \"%s\"", 
d336 1
a336 1
	    krb5_warnx(context, "%s: unknown syslog severity \"%s\"", 
d352 1
d374 3
a376 1
    { "capath", krb5_config_list, all_strings },
d379 1
d385 1
d405 1
a405 1
    { "srv_try_txt", krb5_config_string, check_boolean }, 
a412 1
    { "pkinit-openssl-engine", krb5_config_string, NULL },
d435 6
a440 1
    { "pkinit-anchors", krb5_config_string, NULL },
d511 1
a511 1
    { "enable-kaserver", krb5_config_string, check_boolean },
d516 8
a523 2
    { "pki-identity", krb5_config_string, NULL },
    { "pki-anchors", krb5_config_string, NULL },
d557 2
d581 1
a581 1
check_section(krb5_context context, const char *path, krb5_config_section *cf, 
d587 1
a587 1
    
d589 1
a589 1
    
d591 3
a593 1
	asprintf(&local, "%s/%s", path, p->name);
d604 4
d650 3
a652 1
    int optind = 0;
d660 1
a660 1
    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optind))
d662 1
a662 1
    
d671 2
a672 2
    argc -= optind;
    argv += optind;
d687 1
a687 1
    
@


1.5
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2003 Kungliga Tekniska Högskolan
d38 1
a38 1
RCSID("$KTH: verify_krb5_conf.c,v 1.17.2.2 2004/02/13 16:19:44 lha Exp $");
d45 1
d50 2
d144 3
d148 11
d163 3
d168 3
d173 3
d178 7
d190 16
a205 1
    ret = getaddrinfo(hostname, "telnet" /* XXX */, NULL, &ai);
a212 1
#if 0
d216 2
a217 1
    krb5_warnx(context, "%s is only used by MIT Kerberos", path);
a219 1
#endif
d222 1
a222 1
    char *s;
d354 6
d384 1
d399 1
d403 9
d418 2
d426 1
d448 1
a448 1
#if 0
a463 1
#endif
d477 2
d493 2
a494 2
    { "check_ticket-addresses", krb5_config_string, check_boolean },
    { "allow-null-addresses", krb5_config_string, check_boolean },
d500 6
d513 1
d522 1
a522 1
#if 0
d528 12
a539 1
#endif
d549 3
a551 1
#if 0
a553 1
#endif
d625 4
a628 2
    if (ret)
	errx (1, "krb5_init_context failed");
@


1.4
log
@Make source valid preprocessor tokens.
ok hin@@
@
text
@d38 1
a38 1
RCSID("$KTH: verify_krb5_conf.c,v 1.17 2003/03/29 09:52:50 lha Exp $");
d159 1
a159 4
	if(ret == EAI_NODATA)
	    krb5_warnx(context, "%s: host not found (%s)", path, hostname);
	else
	    krb5_warnx(context, "%s: %s (%s)", path, gai_strerror(ret), hostname);
@


1.3
log
@Merge 0.6rc1
@
text
@d452 2
a453 2
    { "kdc_ports, krb5_config_string, mit_entry },
    { "v4_mode, krb5_config_string, mit_entry },
@


1.2
log
@Remove all uses of setprogname() and getprogname() in kerberosV subtree.
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2001 Kungliga Tekniska Högskolan
d37 2
a38 1
RCSID("$KTH: verify_krb5_conf.c,v 1.6 2001/08/30 18:57:27 joda Exp $");
d42 1
d47 2
d115 3
d122 14
d168 130
d327 3
a339 1
    { "krb4_get_tickets", krb5_config_string, check_boolean },
d355 2
d362 1
d384 17
d420 1
a420 1
    { "logging", krb5_config_string, NULL },
d444 14
d462 1
a462 1
    { "logging", krb5_config_list, all_strings },
d466 4
d509 23
a535 1
    const char *config_file = NULL;
d558 9
a566 8
    if (argc == 0) {
	config_file = getenv("KRB5_CONFIG");
	if (config_file == NULL)
	    config_file = krb5_config_file;
    } else if (argc == 1) {
	config_file = argv[0];
    } else {
	usage (1);
d568 3
a571 6
    ret = krb5_config_parse_file (context, config_file, &tmp_cf);
    if (ret != 0) {
	krb5_warn (context, ret, "krb5_config_parse_file");
	return 1;
    }

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Kungliga Tekniska Högskolan
d36 2
a37 1
RCSID("$KTH: verify_krb5_conf.c,v 1.3 1999/12/02 17:05:13 joda Exp $");
d61 257
d321 1
a324 2
    unsigned lineno;
    char *error_message;
d327 3
a329 1
    set_progname (argv[0]);
d355 7
a361 6
    ret = krb5_config_parse_file_debug (config_file, &tmp_cf, &lineno,
					&error_message);
    if (ret == 0)
	return 0;
    fprintf (stderr, "%s:%u: %s\n", config_file, lineno, error_message);
    return 1;
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: verify_krb5_conf.c,v 1.5 2001/05/14 06:14:52 assar Exp $");
a62 1
    krb5_context context;
d66 2
d70 1
a70 5
    setprogname (argv[0]);

    ret = krb5_init_context(&context);
    if (ret)
	errx (1, "krb5_init_context failed");
d96 2
a97 1
    ret = krb5_config_parse_file (context, config_file, &tmp_cf);
d100 1
a100 1
    krb5_warn (context, ret, "krb5_config_parse_file");
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 2
#include <parse_bytes.h>
RCSID("$KTH: verify_krb5_conf.c,v 1.6 2001/08/30 18:57:27 joda Exp $");
a59 257
static int
check_bytes(krb5_context context, const char *path, char *data)
{
    if(parse_bytes(data, NULL) == -1) {
	krb5_warnx(context, "%s: failed to parse \"%s\" as size", path, data);
	return 1;
    }
    return 0;
}

static int
check_time(krb5_context context, const char *path, char *data)
{
    if(parse_time(data, NULL) == -1) {
	krb5_warnx(context, "%s: failed to parse \"%s\" as time", path, data);
	return 1;
    }
    return 0;
}

static int
check_numeric(krb5_context context, const char *path, char *data)
{
    long int v;
    char *end;
    v = strtol(data, &end, 0);
    if(*end != '\0') {
	krb5_warnx(context, "%s: failed to parse \"%s\" as a number", 
		   path, data);
	return 1;
    }
    return 0;
}

static int
check_boolean(krb5_context context, const char *path, char *data)
{
    long int v;
    char *end;
    if(strcasecmp(data, "yes") == 0 ||
       strcasecmp(data, "true") == 0 ||
       strcasecmp(data, "no") == 0 ||
       strcasecmp(data, "false") == 0)
	return 0;
    v = strtol(data, &end, 0);
    if(*end != '\0') {
	krb5_warnx(context, "%s: failed to parse \"%s\" as a boolean", 
		   path, data);
	return 1;
    }
    return 0;
}

static int
check_host(krb5_context context, const char *path, char *data)
{
    int ret;
    char hostname[128];
    const char *p = data;
    struct addrinfo *ai;
    /* XXX data could be a list of hosts that this code can't handle */
    /* XXX copied from krbhst.c */
    if(strncmp(p, "http://", 7) == 0){
        p += 7;
    } else if(strncmp(p, "http/", 5) == 0) {
        p += 5;
    }else if(strncmp(p, "tcp/", 4) == 0){
        p += 4;
    } else if(strncmp(p, "udp/", 4) == 0) {
        p += 4;
    }
    if(strsep_copy(&p, ":", hostname, sizeof(hostname)) < 0) {
	return 1;
    }
    hostname[strcspn(hostname, "/")] = '\0';
    ret = getaddrinfo(hostname, "telnet" /* XXX */, NULL, &ai);
    if(ret != 0) {
	if(ret == EAI_NODATA)
	    krb5_warnx(context, "%s: host not found (%s)", path, hostname);
	else
	    krb5_warnx(context, "%s: %s (%s)", path, gai_strerror(ret), hostname);
	return 1;
    }
    return 0;
}

typedef int (*check_func_t)(krb5_context, const char*, char*);
struct entry {
    const char *name;
    int type;
    void *check_data;
};

struct entry all_strings[] = {
    { "", krb5_config_string, NULL },
    { NULL }
};

struct entry v4_name_convert_entries[] = {
    { "host", krb5_config_list, all_strings },
    { "plain", krb5_config_list, all_strings },
    { NULL }
};

struct entry libdefaults_entries[] = {
    { "accept_null_addresses", krb5_config_string, check_boolean },
    { "capath", krb5_config_list, all_strings },
    { "clockskew", krb5_config_string, check_time },
    { "date_format", krb5_config_string, NULL },
    { "default_etypes", krb5_config_string, NULL },
    { "default_etypes_des", krb5_config_string, NULL },
    { "default_keytab_modify_name", krb5_config_string, NULL },
    { "default_keytab_name", krb5_config_string, NULL },
    { "default_realm", krb5_config_string, NULL },
    { "dns_proxy", krb5_config_string, NULL },
    { "egd_socket", krb5_config_string, NULL },
    { "encrypt", krb5_config_string, check_boolean },
    { "extra_addresses", krb5_config_string, NULL },
    { "fcache_version", krb5_config_string, check_numeric },
    { "forward", krb5_config_string, check_boolean },
    { "forwardable", krb5_config_string, check_boolean },
    { "http_proxy", krb5_config_string, check_host /* XXX */ },
    { "ignore_addresses", krb5_config_string, NULL },
    { "kdc_timeout", krb5_config_string, check_time },
    { "kdc_timesync", krb5_config_string, check_boolean },
    { "krb4_get_tickets", krb5_config_string, check_boolean },
    { "log_utc", krb5_config_string, check_boolean },
    { "maxretries", krb5_config_string, check_numeric },
    { "scan_interfaces", krb5_config_string, check_boolean },
    { "srv_lookup", krb5_config_string, check_boolean },
    { "srv_try_txt", krb5_config_string, check_boolean }, 
    { "ticket_lifetime", krb5_config_string, check_time },
    { "time_format", krb5_config_string, NULL },
    { "transited_realms_reject", krb5_config_string, NULL },
    { "v4_instance_resolve", krb5_config_string, check_boolean },
    { "v4_name_convert", krb5_config_list, v4_name_convert_entries },
    { "verify_ap_req_nofail", krb5_config_string, check_boolean },
    { NULL }
};

struct entry appdefaults_entries[] = {
    { "forwardable", krb5_config_string, check_boolean },
    { "proxiable", krb5_config_string, check_boolean },
    { "ticket_lifetime", krb5_config_string, check_time },
    { "renew_lifetime", krb5_config_string, check_time },
    { "no-addresses", krb5_config_string, check_boolean },
#if 0
    { "anonymous", krb5_config_string, check_boolean },
#endif
    { "", krb5_config_list, appdefaults_entries },
    { NULL }
};

struct entry realms_entries[] = {
    { "forwardable", krb5_config_string, check_boolean },
    { "proxiable", krb5_config_string, check_boolean },
    { "ticket_lifetime", krb5_config_string, check_time },
    { "renew_lifetime", krb5_config_string, check_time },
    { "warn_pwexpire", krb5_config_string, check_time },
    { "kdc", krb5_config_string, check_host },
    { "admin_server", krb5_config_string, check_host },
    { "kpasswd_server", krb5_config_string, check_host },
    { "krb524_server", krb5_config_string, check_host },
    { "v4_name_convert", krb5_config_list, v4_name_convert_entries },
    { "v4_instance_convert", krb5_config_list, all_strings },
    { "v4_domains", krb5_config_string, NULL },
    { "default_domain", krb5_config_string, NULL },
    { NULL }
};

struct entry realms_foobar[] = {
    { "", krb5_config_list, realms_entries },
    { NULL }
};


struct entry kdc_database_entries[] = {
    { "realm", krb5_config_string, NULL },
    { "dbname", krb5_config_string, NULL },
    { "mkey_file", krb5_config_string, NULL },
    { NULL }
};

struct entry kdc_entries[] = {
    { "database", krb5_config_list, kdc_database_entries },
    { "key-file", krb5_config_string, NULL },
    { "logging", krb5_config_string, NULL },
    { "max-request", krb5_config_string, check_bytes },
    { "require-preauth", krb5_config_string, check_boolean },
    { "ports", krb5_config_string, NULL },
    { "addresses", krb5_config_string, NULL },
    { "enable-kerberos4", krb5_config_string, check_boolean },
    { "enable-524", krb5_config_string, check_boolean },
    { "enable-http", krb5_config_string, check_boolean },
    { "check_ticket-addresses", krb5_config_string, check_boolean },
    { "allow-null-addresses", krb5_config_string, check_boolean },
    { "allow-anonymous", krb5_config_string, check_boolean },
    { "v4_realm", krb5_config_string, NULL },
    { "enable-kaserver", krb5_config_string, check_boolean },
    { "encode_as_rep_as_tgs_rep", krb5_config_string, check_boolean },
    { "kdc_warn_pwexpire", krb5_config_string, check_time },
    { NULL }
};

struct entry kadmin_entries[] = {
    { "password_lifetime", krb5_config_string, check_time },
    { "default_keys", krb5_config_string, NULL },
    { "use_v4_salt", krb5_config_string, NULL },
    { NULL }
};
struct entry toplevel_sections[] = {
    { "libdefaults" , krb5_config_list, libdefaults_entries },
    { "realms", krb5_config_list, realms_foobar },
    { "domain_realm", krb5_config_list, all_strings },
    { "logging", krb5_config_list, all_strings },
    { "kdc", krb5_config_list, kdc_entries },
    { "kadmin", krb5_config_list, kadmin_entries },
    { "appdefaults", krb5_config_list, appdefaults_entries },
    { NULL }
};


static int
check_section(krb5_context context, const char *path, krb5_config_section *cf, 
	      struct entry *entries)
{
    int error = 0;
    krb5_config_section *p;
    struct entry *e;
    
    char *local;
    
    for(p = cf; p != NULL; p = p->next) {
	asprintf(&local, "%s/%s", path, p->name);
	for(e = entries; e->name != NULL; e++) {
	    if(*e->name == '\0' || strcmp(e->name, p->name) == 0) {
		if(e->type != p->type) {
		    krb5_warnx(context, "%s: unknown or wrong type", local);
		    error |= 1;
		} else if(p->type == krb5_config_string && e->check_data != NULL) {
		    error |= (*(check_func_t)e->check_data)(context, local, p->u.string);
		} else if(p->type == krb5_config_list && e->check_data != NULL) {
		    error |= check_section(context, local, p->u.list, e->check_data);
		}
		break;
	    }
	}
	if(e->name == NULL) {
	    krb5_warnx(context, "%s: unknown entry", local);
	    error |= 1;
	}
	free(local);
    }
    return error;
}


d100 4
a103 6
    if (ret != 0) {
	krb5_warn (context, ret, "krb5_config_parse_file");
	return 1;
    }

    return check_section(context, "", tmp_cf, toplevel_sections);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2003 Kungliga Tekniska Högskolan
d37 1
a37 2
#include <err.h>
RCSID("$KTH: verify_krb5_conf.c,v 1.17 2003/03/29 09:52:50 lha Exp $");
a40 1
static int dumpconfig_flag = 0;
a44 2
    {"dumpconfig", 0,      arg_flag,       &dumpconfig_flag, 
     "show the parsed config files", NULL },
a110 3
    if(v != 0 && v != 1)
	krb5_warnx(context, "%s: numeric value \"%s\" is treated as \"true\"", 
		   path, data);
a114 14
check_524(krb5_context context, const char *path, char *data)
{
    if(strcasecmp(data, "yes") == 0 ||
       strcasecmp(data, "no") == 0 ||
       strcasecmp(data, "2b") == 0 ||
       strcasecmp(data, "local") == 0)
	return 0;

    krb5_warnx(context, "%s: didn't contain a valid option `%s'", 
	       path, data);
    return 1;
}

static int
a146 130
#if 0
static int
mit_entry(krb5_context context, const char *path, char *data)
{
    krb5_warnx(context, "%s is only used by MIT Kerberos", path);
    return 0;
}
#endif

struct s2i {
    char *s;
    int val;
};

#define L(X) { #X, LOG_ ## X }

static struct s2i syslogvals[] = {
    /* severity */
    L(EMERG),
    L(ALERT),
    L(CRIT),
    L(ERR),
    L(WARNING),
    L(NOTICE),
    L(INFO),
    L(DEBUG),
    /* facility */
    L(AUTH),
#ifdef LOG_AUTHPRIV
    L(AUTHPRIV),
#endif
#ifdef LOG_CRON
    L(CRON),
#endif
    L(DAEMON),
#ifdef LOG_FTP
    L(FTP),
#endif
    L(KERN),
    L(LPR),
    L(MAIL),
#ifdef LOG_NEWS
    L(NEWS),
#endif
    L(SYSLOG),
    L(USER),
#ifdef LOG_UUCP
    L(UUCP),
#endif
    L(LOCAL0),
    L(LOCAL1),
    L(LOCAL2),
    L(LOCAL3),
    L(LOCAL4),
    L(LOCAL5),
    L(LOCAL6),
    L(LOCAL7),
    { NULL, -1 }
};

static int
find_value(const char *s, struct s2i *table)
{
    while(table->s && strcasecmp(table->s, s))
	table++;
    return table->val;
}

static int
check_log(krb5_context context, const char *path, char *data)
{
    /* XXX sync with log.c */
    int min = 0, max = -1, n;
    char c;
    const char *p = data;

    n = sscanf(p, "%d%c%d/", &min, &c, &max);
    if(n == 2){
	if(c == '/') {
	    if(min < 0){
		max = -min;
		min = 0;
	    }else{
		max = min;
	    }
	}
    }
    if(n){
	p = strchr(p, '/');
	if(p == NULL) {
	    krb5_warnx(context, "%s: failed to parse \"%s\"", path, data);
	    return 1;
	}
	p++;
    }
    if(strcmp(p, "STDERR") == 0 || 
       strcmp(p, "CONSOLE") == 0 ||
       (strncmp(p, "FILE", 4) == 0 && (p[4] == ':' || p[4] == '=')) ||
       (strncmp(p, "DEVICE", 6) == 0 && p[6] == '='))
	return 0;
    if(strncmp(p, "SYSLOG", 6) == 0){
	int ret = 0;
	char severity[128] = "";
	char facility[128] = "";
	p += 6;
	if(*p != '\0')
	    p++;
	if(strsep_copy(&p, ":", severity, sizeof(severity)) != -1)
	    strsep_copy(&p, ":", facility, sizeof(facility));
	if(*severity == '\0')
	    strlcpy(severity, "ERR", sizeof(severity));
 	if(*facility == '\0')
	    strlcpy(facility, "AUTH", sizeof(facility));
	if(find_value(severity, syslogvals) == -1) {
	    krb5_warnx(context, "%s: unknown syslog facility \"%s\"", 
		       path, facility);
	    ret++;
	}
	if(find_value(severity, syslogvals) == -1) {
	    krb5_warnx(context, "%s: unknown syslog severity \"%s\"", 
		       path, severity);
	    ret++;
	}
	return ret;
    }else{
	krb5_warnx(context, "%s: unknown log type: \"%s\"", path, data);
	return 1;
    }
}

a175 3
    { "dns_lookup_kdc", krb5_config_string, check_boolean },
    { "dns_lookup_realm", krb5_config_string, check_boolean },
    { "dns_lookup_realm_labels", krb5_config_string, NULL },
d186 1
a201 2
    { "afslog", krb5_config_string, check_boolean },
    { "afs-use-524", krb5_config_string, check_524 },
a206 1
    { "krb4_get_tickets", krb5_config_string, check_boolean },
a227 17
#if 0
    /* MIT stuff */
    { "admin_keytab", krb5_config_string, mit_entry },
    { "acl_file", krb5_config_string, mit_entry },
    { "dict_file", krb5_config_string, mit_entry },
    { "kadmind_port", krb5_config_string, mit_entry },
    { "kpasswd_port", krb5_config_string, mit_entry },
    { "master_key_name", krb5_config_string, mit_entry },
    { "master_key_type", krb5_config_string, mit_entry },
    { "key_stash_file", krb5_config_string, mit_entry },
    { "max_life", krb5_config_string, mit_entry },
    { "max_renewable_life", krb5_config_string, mit_entry },
    { "default_principal_expiration", krb5_config_string, mit_entry },
    { "default_principal_flags", krb5_config_string, mit_entry },
    { "supported_enctypes", krb5_config_string, mit_entry },
    { "database_name", krb5_config_string, mit_entry },
#endif
d247 1
a247 1
    { "logging", krb5_config_string, check_log },
a270 14
struct entry log_strings[] = {
    { "", krb5_config_string, check_log },
    { NULL }
};


#if 0
struct entry kdcdefaults_entries[] = {
    { "kdc_ports, krb5_config_string, mit_entry },
    { "v4_mode, krb5_config_string, mit_entry },
    { NULL }
};
#endif

d275 1
a275 1
    { "logging", krb5_config_list, log_strings },
a278 4
#if 0
    /* MIT stuff */
    { "kdcdefaults", krb5_config_list, kdcdefaults_entries },
#endif
a317 23
static void
dumpconfig(int level, krb5_config_section *top)
{
    krb5_config_section *x;
    for(x = top; x; x = x->next) {
	switch(x->type) {
	case krb5_config_list:
	    if(level == 0) {
		printf("[%s]\n", x->name);
	    } else {
		printf("%*s%s = {\n", 4 * level, " ", x->name);
	    }
	    dumpconfig(level + 1, x->u.list);
	    if(level > 0)
		printf("%*s}\n", 4 * level, " ");
	    break;
	case krb5_config_string:
	    printf("%*s%s = %s\n", 4 * level, " ", x->name, x->u.string);
	    break;
	}
    }
}

d322 1
d347 14
a360 9
    tmp_cf = NULL;
    if(argc == 0)
	krb5_get_default_config_files(&argv);

    while(*argv) {
	ret = krb5_config_parse_file_multi(context, *argv, &tmp_cf);
	if (ret != 0)
	    krb5_warn (context, ret, "krb5_config_parse_file");
	argv++;
a362 3
    if(dumpconfig_flag)
	dumpconfig(0, tmp_cf);
    
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d38 1
a38 1
RCSID("$KTH: verify_krb5_conf.c,v 1.17.2.2 2004/02/13 16:19:44 lha Exp $");
d159 4
a162 1
	krb5_warnx(context, "%s: %s (%s)", path, gai_strerror(ret), hostname);
d452 2
a453 2
    { "kdc_ports", krb5_config_string, mit_entry },
    { "v4_mode", krb5_config_string, mit_entry },
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2005 Kungliga Tekniska Högskolan
d38 1
a38 1
RCSID("$KTH: verify_krb5_conf.c,v 1.33 2005/06/14 00:06:17 lha Exp $");
a44 1
static int warn_mit_syntax_flag = 0;
a48 2
    {"warn-mit-syntax", 0, arg_flag,       &warn_mit_syntax_flag, 
     "show the parsed config files", NULL },
a140 3
    struct addrinfo hints;
    char service[32];
    int defport;
a141 11

    hints.ai_flags = 0;
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = 0;
    hints.ai_protocol = 0;

    hints.ai_addrlen = 0;
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    
a145 3
	hints.ai_socktype = SOCK_STREAM;
	strlcpy(service, "http", sizeof(service));
	defport = 80;
a147 3
	hints.ai_socktype = SOCK_STREAM;
	strlcpy(service, "http", sizeof(service));
	defport = 80;
a149 3
	hints.ai_socktype = SOCK_STREAM;
	strlcpy(service, "kerberos", sizeof(service));
	defport = 88;
a151 7
	hints.ai_socktype = SOCK_DGRAM;
	strlcpy(service, "kerberos", sizeof(service));
	defport = 88;
    } else {
	hints.ai_socktype = SOCK_DGRAM;
	strlcpy(service, "kerberos", sizeof(service));
	defport = 88;
d157 1
a157 16
    if(p != NULL) {
	char *end;
	int tmp = strtol(p, &end, 0);
	if(end == p) {
	    krb5_warnx(context, "%s: failed to parse port number in %s", 
		       path, data);
	    return 1;
	}
	defport = tmp;
	snprintf(service, sizeof(service), "%u", defport);
    }
    ret = getaddrinfo(hostname, service, &hints, &ai);
    if(ret == EAI_SERVICE && !isdigit((unsigned char)service[0])) {
	snprintf(service, sizeof(service), "%u", defport);
	ret = getaddrinfo(hostname, service, &hints, &ai);
    }
d165 1
d169 1
a169 2
    if (warn_mit_syntax_flag)
	krb5_warnx(context, "%s is only used by MIT Kerberos", path);
d172 1
d175 1
a175 1
    const char *s;
a306 6
struct entry all_boolean[] = {
    { "", krb5_config_string, check_boolean },
    { NULL }
};


a330 1
    { "fcc-mit-ticketflags", krb5_config_string, check_boolean },
a344 1
    { "no-addresses", krb5_config_string, check_boolean },
a347 9
    { "pkinit-openssl-engine", krb5_config_string, NULL },
    { "max_retries", krb5_config_string, check_time },
    { "renew_lifetime", krb5_config_string, check_time },
    { "proxiable", krb5_config_string, check_boolean },
    { "warn_pwexpire", krb5_config_string, check_time },
    /* MIT stuff */
    { "permitted_enctypes", krb5_config_string, mit_entry },
    { "default_tgs_enctypes", krb5_config_string, mit_entry },
    { "default_tkt_enctypes", krb5_config_string, mit_entry },
a353 2
    { "encrypt", krb5_config_string, check_boolean },
    { "forward", krb5_config_string, check_boolean },
a359 1
    { "pkinit-anchors", krb5_config_string, NULL },
d381 1
a381 1
    { "win2k_pkinit", krb5_config_string, NULL },
d397 1
a410 2
    { "acl_file", krb5_config_string, NULL },
    { "log_file", krb5_config_string, NULL },
d425 2
a426 2
    { "check-ticket-addresses", krb5_config_string, check_boolean },
    { "allow-null-ticket-addresses", krb5_config_string, check_boolean },
a431 6
    { "use_2b", krb5_config_list, NULL },
    { "enable-pkinit", krb5_config_string, check_boolean },
    { "pki-identity", krb5_config_string, NULL },
    { "pki-anchors", krb5_config_string, NULL },
    { "hdb-ldap-create-base", krb5_config_string, NULL },
    { "v4-realm", krb5_config_string, NULL },
a438 1
    { "require-preauth", krb5_config_string, check_boolean },
d447 1
a447 1
/* MIT stuff */
d453 1
a453 12

struct entry capaths_entries[] = {
    { "", krb5_config_list, all_strings },
    { NULL }
};

struct entry password_quality_entries[] = {
    { "policies", krb5_config_string, NULL },
    { "external_program", krb5_config_string, NULL },
    { "", krb5_config_list, all_strings },
    { NULL }
};
d463 1
a463 3
    { "gssapi", krb5_config_list, NULL },
    { "capaths", krb5_config_list, capaths_entries },
    { "password_quality", krb5_config_list, password_quality_entries },
d466 1
d540 2
a541 4
    if (ret == KRB5_CONFIG_BADFORMAT)
	errx (1, "krb5_init_context failed to parse configuration file");
    else if (ret)
	errx (1, "krb5_init_context failed with %d", ret);
@


