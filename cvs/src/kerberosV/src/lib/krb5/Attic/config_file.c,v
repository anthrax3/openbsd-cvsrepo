head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.26
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.24
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.22
	OPENBSD_5_0:1.7.0.20
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.18
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.16
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.12
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.14
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.2.0.8
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.8;

1.8
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.18.21.08.28;	author biorn;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.16.21.19.55;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.29.16.20.30;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.03.39.25;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.37;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.37;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.25;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.49;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.36;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.14;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.9
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2004 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Portions Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"

#ifdef __APPLE__
#include <CoreFoundation/CoreFoundation.h>
#endif

/* Gaah! I want a portable funopen */
struct fileptr {
    const char *s;
    FILE *f;
};

static char *
config_fgets(char *str, size_t len, struct fileptr *ptr)
{
    /* XXX this is not correct, in that they don't do the same if the
       line is longer than len */
    if(ptr->f != NULL)
	return fgets(str, len, ptr->f);
    else {
	/* this is almost strsep_copy */
	const char *p;
	ssize_t l;
	if(*ptr->s == '\0')
	    return NULL;
	p = ptr->s + strcspn(ptr->s, "\n");
	if(*p == '\n')
	    p++;
	l = min(len, (size_t)(p - ptr->s));
	if(len > 0) {
	    memcpy(str, ptr->s, l);
	    str[l] = '\0';
	}
	ptr->s = p;
	return str;
    }
}

static krb5_error_code parse_section(char *p, krb5_config_section **s,
				     krb5_config_section **res,
				     const char **err_message);
static krb5_error_code parse_binding(struct fileptr *f, unsigned *lineno, char *p,
				     krb5_config_binding **b,
				     krb5_config_binding **parent,
				     const char **err_message);
static krb5_error_code parse_list(struct fileptr *f, unsigned *lineno,
				  krb5_config_binding **parent,
				  const char **err_message);

krb5_config_section *
_krb5_config_get_entry(krb5_config_section **parent, const char *name, int type)
{
    krb5_config_section **q;

    for(q = parent; *q != NULL; q = &(*q)->next)
	if(type == krb5_config_list &&
	   (unsigned)type == (*q)->type &&
	   strcmp(name, (*q)->name) == 0)
	    return *q;
    *q = calloc(1, sizeof(**q));
    if(*q == NULL)
	return NULL;
    (*q)->name = strdup(name);
    (*q)->type = type;
    if((*q)->name == NULL) {
	free(*q);
	*q = NULL;
	return NULL;
    }
    return *q;
}

/*
 * Parse a section:
 *
 * [section]
 *	foo = bar
 *	b = {
 *		a
 *	    }
 * ...
 *
 * starting at the line in `p', storing the resulting structure in
 * `s' and hooking it into `parent'.
 * Store the error message in `err_message'.
 */

static krb5_error_code
parse_section(char *p, krb5_config_section **s, krb5_config_section **parent,
	      const char **err_message)
{
    char *p1;
    krb5_config_section *tmp;

    p1 = strchr (p + 1, ']');
    if (p1 == NULL) {
	*err_message = "missing ]";
	return KRB5_CONFIG_BADFORMAT;
    }
    *p1 = '\0';
    tmp = _krb5_config_get_entry(parent, p + 1, krb5_config_list);
    if(tmp == NULL) {
	*err_message = "out of memory";
	return KRB5_CONFIG_BADFORMAT;
    }
    *s = tmp;
    return 0;
}

/*
 * Parse a brace-enclosed list from `f', hooking in the structure at
 * `parent'.
 * Store the error message in `err_message'.
 */

static krb5_error_code
parse_list(struct fileptr *f, unsigned *lineno, krb5_config_binding **parent,
	   const char **err_message)
{
    char buf[KRB5_BUFSIZ];
    krb5_error_code ret;
    krb5_config_binding *b = NULL;
    unsigned beg_lineno = *lineno;

    while(config_fgets(buf, sizeof(buf), f) != NULL) {
	char *p;

	++*lineno;
	buf[strcspn(buf, "\r\n")] = '\0';
	p = buf;
	while(isspace((unsigned char)*p))
	    ++p;
	if (*p == '#' || *p == ';' || *p == '\0')
	    continue;
	while(isspace((unsigned char)*p))
	    ++p;
	if (*p == '}')
	    return 0;
	if (*p == '\0')
	    continue;
	ret = parse_binding (f, lineno, p, &b, parent, err_message);
	if (ret)
	    return ret;
    }
    *lineno = beg_lineno;
    *err_message = "unclosed {";
    return KRB5_CONFIG_BADFORMAT;
}

/*
 *
 */

static krb5_error_code
parse_binding(struct fileptr *f, unsigned *lineno, char *p,
	      krb5_config_binding **b, krb5_config_binding **parent,
	      const char **err_message)
{
    krb5_config_binding *tmp;
    char *p1, *p2;
    krb5_error_code ret = 0;

    p1 = p;
    while (*p && *p != '=' && !isspace((unsigned char)*p))
	++p;
    if (*p == '\0') {
	*err_message = "missing =";
	return KRB5_CONFIG_BADFORMAT;
    }
    p2 = p;
    while (isspace((unsigned char)*p))
	++p;
    if (*p != '=') {
	*err_message = "missing =";
	return KRB5_CONFIG_BADFORMAT;
    }
    ++p;
    while(isspace((unsigned char)*p))
	++p;
    *p2 = '\0';
    if (*p == '{') {
	tmp = _krb5_config_get_entry(parent, p1, krb5_config_list);
	if (tmp == NULL) {
	    *err_message = "out of memory";
	    return KRB5_CONFIG_BADFORMAT;
	}
	ret = parse_list (f, lineno, &tmp->u.list, err_message);
    } else {
	tmp = _krb5_config_get_entry(parent, p1, krb5_config_string);
	if (tmp == NULL) {
	    *err_message = "out of memory";
	    return KRB5_CONFIG_BADFORMAT;
	}
	p1 = p;
	p = p1 + strlen(p1);
	while(p > p1 && isspace((unsigned char)*(p-1)))
	    --p;
	*p = '\0';
	tmp->u.string = strdup(p1);
    }
    *b = tmp;
    return ret;
}

#if defined(__APPLE__)

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
#define HAVE_CFPROPERTYLISTCREATEWITHSTREAM 1
#endif

static char *
cfstring2cstring(CFStringRef string)
{
    CFIndex len;
    char *str;

    str = (char *) CFStringGetCStringPtr(string, kCFStringEncodingUTF8);
    if (str)
	return strdup(str);

    len = CFStringGetLength(string);
    len = 1 + CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
    str = malloc(len);
    if (str == NULL)
	return NULL;

    if (!CFStringGetCString (string, str, len, kCFStringEncodingUTF8)) {
	free (str);
	return NULL;
    }
    return str;
}

static void
convert_content(const void *key, const void *value, void *context)
{
    krb5_config_section *tmp, **parent = context;
    char *k;

    if (CFGetTypeID(key) != CFStringGetTypeID())
	return;

    k = cfstring2cstring(key);
    if (k == NULL)
	return;

    if (CFGetTypeID(value) == CFStringGetTypeID()) {
	tmp = _krb5_config_get_entry(parent, k, krb5_config_string);
	tmp->u.string = cfstring2cstring(value);
    } else if (CFGetTypeID(value) == CFDictionaryGetTypeID()) {
	tmp = _krb5_config_get_entry(parent, k, krb5_config_list);
	CFDictionaryApplyFunction(value, convert_content, &tmp->u.list);
    } else {
	/* log */
    }
    free(k);
}

static krb5_error_code
parse_plist_config(krb5_context context, const char *path, krb5_config_section **parent)
{
    CFReadStreamRef s;
    CFDictionaryRef d;
    CFURLRef url;

    url = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, (UInt8 *)path, strlen(path), FALSE);
    if (url == NULL) {
	krb5_clear_error_message(context);
	return ENOMEM;
    }

    s = CFReadStreamCreateWithFile(kCFAllocatorDefault, url);
    CFRelease(url);
    if (s == NULL) {
	krb5_clear_error_message(context);
	return ENOMEM;
    }

    if (!CFReadStreamOpen(s)) {
	CFRelease(s);
	krb5_clear_error_message(context);
	return ENOENT;
    }

#ifdef HAVE_CFPROPERTYLISTCREATEWITHSTREAM
    d = (CFDictionaryRef)CFPropertyListCreateWithStream(NULL, s, 0, kCFPropertyListImmutable, NULL, NULL);
#else
    d = (CFDictionaryRef)CFPropertyListCreateFromStream(NULL, s, 0, kCFPropertyListImmutable, NULL, NULL);
#endif
    CFRelease(s);
    if (d == NULL) {
	krb5_clear_error_message(context);
	return ENOENT;
    }

    CFDictionaryApplyFunction(d, convert_content, parent);
    CFRelease(d);

    return 0;
}

#endif


/*
 * Parse the config file `fname', generating the structures into `res'
 * returning error messages in `err_message'
 */

static krb5_error_code
krb5_config_parse_debug (struct fileptr *f,
			 krb5_config_section **res,
			 unsigned *lineno,
			 const char **err_message)
{
    krb5_config_section *s = NULL;
    krb5_config_binding *b = NULL;
    char buf[KRB5_BUFSIZ];
    krb5_error_code ret;

    while (config_fgets(buf, sizeof(buf), f) != NULL) {
	char *p;

	++*lineno;
	buf[strcspn(buf, "\r\n")] = '\0';
	p = buf;
	while(isspace((unsigned char)*p))
	    ++p;
	if (*p == '#' || *p == ';')
	    continue;
	if (*p == '[') {
	    ret = parse_section(p, &s, res, err_message);
	    if (ret)
		return ret;
	    b = NULL;
	} else if (*p == '}') {
	    *err_message = "unmatched }";
	    return EINVAL;	/* XXX */
	} else if(*p != '\0') {
	    if (s == NULL) {
		*err_message = "binding before section";
		return EINVAL;
	    }
	    ret = parse_binding(f, lineno, p, &b, &s->u.list, err_message);
	    if (ret)
		return ret;
	}
    }
    return 0;
}

static int
is_plist_file(const char *fname)
{
    size_t len = strlen(fname);
    char suffix[] = ".plist";
    if (len < sizeof(suffix))
	return 0;
    if (strcasecmp(&fname[len - (sizeof(suffix) - 1)], suffix) != 0)
	return 0;
    return 1;
}

/**
 * Parse a configuration file and add the result into res. This
 * interface can be used to parse several configuration files into one
 * resulting krb5_config_section by calling it repeatably.
 *
 * @@param context a Kerberos 5 context.
 * @@param fname a file name to a Kerberos configuration file
 * @@param res the returned result, must be free with krb5_free_config_files().
 * @@return Return an error code or 0, see krb5_get_error_message().
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_config_parse_file_multi (krb5_context context,
			      const char *fname,
			      krb5_config_section **res)
{
    const char *str;
    char *newfname = NULL;
    unsigned lineno = 0;
    krb5_error_code ret;
    struct fileptr f;

    /**
     * If the fname starts with "~/" parse configuration file in the
     * current users home directory. The behavior can be disabled and
     * enabled by calling krb5_set_home_dir_access().
     */
    if (fname[0] == '~' && fname[1] == '/') {
#ifndef KRB5_USE_PATH_TOKENS
	const char *home = NULL;

	if (!_krb5_homedir_access(context)) {
	    krb5_set_error_message(context, EPERM,
				   "Access to home directory not allowed");
	    return EPERM;
	}

	if(!issuid())
	    home = getenv("HOME");

	if (home == NULL) {
	    struct passwd *pw = getpwuid(getuid());
	    if(pw != NULL)
		home = pw->pw_dir;
	}
	if (home) {
	    asprintf(&newfname, "%s%s", home, &fname[1]);
	    if (newfname == NULL) {
		krb5_set_error_message(context, ENOMEM,
				       N_("malloc: out of memory", ""));
		return ENOMEM;
	    }
	    fname = newfname;
	}
#else  /* KRB5_USE_PATH_TOKENS */
	if (asprintf(&newfname, "%%{USERCONFIG}%s", &fname[1]) < 0 ||
	    newfname == NULL)
	{
	    krb5_set_error_message(context, ENOMEM,
				   N_("malloc: out of memory", ""));
	    return ENOMEM;
	}
	fname = newfname;
#endif
    }

    if (is_plist_file(fname)) {
#ifdef __APPLE__
	ret = parse_plist_config(context, fname, res);
	if (ret) {
	    krb5_set_error_message(context, ret,
				   "Failed to parse plist %s", fname);
	    if (newfname)
		free(newfname);
	    return ret;
	}
#else
	krb5_set_error_message(context, ENOENT,
			       "no support for plist configuration files");
	return ENOENT;
#endif
    } else {
#ifdef KRB5_USE_PATH_TOKENS
	char * exp_fname = NULL;

	ret = _krb5_expand_path_tokens(context, fname, &exp_fname);
	if (ret) {
	    if (newfname)
		free(newfname);
	    return ret;
	}

	if (newfname)
	    free(newfname);
	fname = newfname = exp_fname;
#endif

	f.f = fopen(fname, "r");
	f.s = NULL;
	if(f.f == NULL) {
	    ret = errno;
	    krb5_set_error_message (context, ret, "open %s: %s",
				    fname, strerror(ret));
	    if (newfname)
		free(newfname);
	    return ret;
	}

	ret = krb5_config_parse_debug (&f, res, &lineno, &str);
	fclose(f.f);
	if (ret) {
	    krb5_set_error_message (context, ret, "%s:%u: %s",
				    fname, lineno, str);
	    if (newfname)
		free(newfname);
	    return ret;
	}
    }
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_config_parse_file (krb5_context context,
			const char *fname,
			krb5_config_section **res)
{
    *res = NULL;
    return krb5_config_parse_file_multi(context, fname, res);
}

static void
free_binding (krb5_context context, krb5_config_binding *b)
{
    krb5_config_binding *next_b;

    while (b) {
	free (b->name);
	if (b->type == krb5_config_string)
	    free (b->u.string);
	else if (b->type == krb5_config_list)
	    free_binding (context, b->u.list);
	else
	    krb5_abortx(context, "unknown binding type (%d) in free_binding",
			b->type);
	next_b = b->next;
	free (b);
	b = next_b;
    }
}

/**
 * Free configuration file section, the result of
 * krb5_config_parse_file() and krb5_config_parse_file_multi().
 *
 * @@param context A Kerberos 5 context
 * @@param s the configuration section to free
 *
 * @@return returns 0 on successes, otherwise an error code, see
 *          krb5_get_error_message()
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_config_file_free (krb5_context context, krb5_config_section *s)
{
    free_binding (context, s);
    return 0;
}

#ifndef HEIMDAL_SMALLER

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
_krb5_config_copy(krb5_context context,
		  krb5_config_section *c,
		  krb5_config_section **head)
{
    krb5_config_binding *d, *previous = NULL;

    *head = NULL;

    while (c) {
	d = calloc(1, sizeof(*d));

	if (*head == NULL)
	    *head = d;

	d->name = strdup(c->name);
	d->type = c->type;
	if (d->type == krb5_config_string)
	    d->u.string = strdup(c->u.string);
	else if (d->type == krb5_config_list)
	    _krb5_config_copy (context, c->u.list, &d->u.list);
	else
	    krb5_abortx(context,
			"unknown binding type (%d) in krb5_config_copy",
			d->type);
	if (previous)
	    previous->next = d;

	previous = d;
	c = c->next;
    }
    return 0;
}

#endif /* HEIMDAL_SMALLER */

KRB5_LIB_FUNCTION const void * KRB5_LIB_CALL
_krb5_config_get_next (krb5_context context,
		       const krb5_config_section *c,
		       const krb5_config_binding **pointer,
		       int type,
		       ...)
{
    const char *ret;
    va_list args;

    va_start(args, type);
    ret = _krb5_config_vget_next (context, c, pointer, type, args);
    va_end(args);
    return ret;
}

static const void *
vget_next(krb5_context context,
	  const krb5_config_binding *b,
	  const krb5_config_binding **pointer,
	  int type,
	  const char *name,
	  va_list args)
{
    const char *p = va_arg(args, const char *);
    while(b != NULL) {
	if(strcmp(b->name, name) == 0) {
	    if(b->type == (unsigned)type && p == NULL) {
		*pointer = b;
		return b->u.generic;
	    } else if(b->type == krb5_config_list && p != NULL) {
		return vget_next(context, b->u.list, pointer, type, p, args);
	    }
	}
	b = b->next;
    }
    return NULL;
}

KRB5_LIB_FUNCTION const void * KRB5_LIB_CALL
_krb5_config_vget_next (krb5_context context,
			const krb5_config_section *c,
			const krb5_config_binding **pointer,
			int type,
			va_list args)
{
    const krb5_config_binding *b;
    const char *p;

    if(c == NULL)
	c = context->cf;

    if (c == NULL)
	return NULL;

    if (*pointer == NULL) {
	/* first time here, walk down the tree looking for the right
           section */
	p = va_arg(args, const char *);
	if (p == NULL)
	    return NULL;
	return vget_next(context, c, pointer, type, p, args);
    }

    /* we were called again, so just look for more entries with the
       same name and type */
    for (b = (*pointer)->next; b != NULL; b = b->next) {
	if(strcmp(b->name, (*pointer)->name) == 0 && b->type == (unsigned)type) {
	    *pointer = b;
	    return b->u.generic;
	}
    }
    return NULL;
}

KRB5_LIB_FUNCTION const void * KRB5_LIB_CALL
_krb5_config_get (krb5_context context,
		  const krb5_config_section *c,
		  int type,
		  ...)
{
    const void *ret;
    va_list args;

    va_start(args, type);
    ret = _krb5_config_vget (context, c, type, args);
    va_end(args);
    return ret;
}


const void *
_krb5_config_vget (krb5_context context,
		   const krb5_config_section *c,
		   int type,
		   va_list args)
{
    const krb5_config_binding *foo = NULL;

    return _krb5_config_vget_next (context, c, &foo, type, args);
}

/**
 * Get a list of configuration binding list for more processing
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return NULL if configuration list is not found, a list otherwise
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION const krb5_config_binding * KRB5_LIB_CALL
krb5_config_get_list (krb5_context context,
		      const krb5_config_section *c,
		      ...)
{
    const krb5_config_binding *ret;
    va_list args;

    va_start(args, c);
    ret = krb5_config_vget_list (context, c, args);
    va_end(args);
    return ret;
}

/**
 * Get a list of configuration binding list for more processing
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param args a va_list of arguments
 *
 * @@return NULL if configuration list is not found, a list otherwise
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION const krb5_config_binding * KRB5_LIB_CALL
krb5_config_vget_list (krb5_context context,
		       const krb5_config_section *c,
		       va_list args)
{
    return _krb5_config_vget (context, c, krb5_config_list, args);
}

/**
 * Returns a "const char *" to a string in the configuration database.
 * The string may not be valid after a reload of the configuration
 * database so a caller should make a local copy if it needs to keep
 * the string.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return NULL if configuration string not found, a string otherwise
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION const char* KRB5_LIB_CALL
krb5_config_get_string (krb5_context context,
			const krb5_config_section *c,
			...)
{
    const char *ret;
    va_list args;

    va_start(args, c);
    ret = krb5_config_vget_string (context, c, args);
    va_end(args);
    return ret;
}

/**
 * Like krb5_config_get_string(), but uses a va_list instead of ...
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param args a va_list of arguments
 *
 * @@return NULL if configuration string not found, a string otherwise
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION const char* KRB5_LIB_CALL
krb5_config_vget_string (krb5_context context,
			 const krb5_config_section *c,
			 va_list args)
{
    return _krb5_config_vget (context, c, krb5_config_string, args);
}

/**
 * Like krb5_config_vget_string(), but instead of returning NULL,
 * instead return a default value.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param def_value the default value to return if no configuration
 *        found in the database.
 * @@param args a va_list of arguments
 *
 * @@return a configuration string
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION const char* KRB5_LIB_CALL
krb5_config_vget_string_default (krb5_context context,
				 const krb5_config_section *c,
				 const char *def_value,
				 va_list args)
{
    const char *ret;

    ret = krb5_config_vget_string (context, c, args);
    if (ret == NULL)
	ret = def_value;
    return ret;
}

/**
 * Like krb5_config_get_string(), but instead of returning NULL,
 * instead return a default value.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param def_value the default value to return if no configuration
 *        found in the database.
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return a configuration string
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION const char* KRB5_LIB_CALL
krb5_config_get_string_default (krb5_context context,
				const krb5_config_section *c,
				const char *def_value,
				...)
{
    const char *ret;
    va_list args;

    va_start(args, def_value);
    ret = krb5_config_vget_string_default (context, c, def_value, args);
    va_end(args);
    return ret;
}

static char *
next_component_string(char * begin, const char * delims, char **state)
{
    char * end;

    if (begin == NULL)
        begin = *state;

    if (*begin == '\0')
        return NULL;

    end = begin;
    while (*end == '"') {
        char * t = strchr(end + 1, '"');

        if (t)
            end = ++t;
        else
            end += strlen(end);
    }

    if (*end != '\0') {
        size_t pos;

        pos = strcspn(end, delims);
        end = end + pos;
    }

    if (*end != '\0') {
        *end = '\0';
        *state = end + 1;
        if (*begin == '"' && *(end - 1) == '"' && begin + 1 < end) {
            begin++; *(end - 1) = '\0';
        }
        return begin;
    }

    *state = end;
    if (*begin == '"' && *(end - 1) == '"' && begin + 1 < end) {
        begin++; *(end - 1) = '\0';
    }
    return begin;
}

/**
 * Get a list of configuration strings, free the result with
 * krb5_config_free_strings().
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param args a va_list of arguments
 *
 * @@return TRUE or FALSE
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION char ** KRB5_LIB_CALL
krb5_config_vget_strings(krb5_context context,
			 const krb5_config_section *c,
			 va_list args)
{
    char **strings = NULL;
    int nstr = 0;
    const krb5_config_binding *b = NULL;
    const char *p;

    while((p = _krb5_config_vget_next(context, c, &b,
				      krb5_config_string, args))) {
	char *tmp = strdup(p);
	char *pos = NULL;
	char *s;
	if(tmp == NULL)
	    goto cleanup;
	s = next_component_string(tmp, " \t", &pos);
	while(s){
	    char **tmp2 = realloc(strings, (nstr + 1) * sizeof(*strings));
	    if(tmp2 == NULL)
		goto cleanup;
	    strings = tmp2;
	    strings[nstr] = strdup(s);
	    nstr++;
	    if(strings[nstr-1] == NULL)
		goto cleanup;
	    s = next_component_string(NULL, " \t", &pos);
	}
	free(tmp);
    }
    if(nstr){
	char **tmp = realloc(strings, (nstr + 1) * sizeof(*strings));
	if(tmp == NULL)
	    goto cleanup;
	strings = tmp;
	strings[nstr] = NULL;
    }
    return strings;
cleanup:
    while(nstr--)
	free(strings[nstr]);
    free(strings);
    return NULL;

}

/**
 * Get a list of configuration strings, free the result with
 * krb5_config_free_strings().
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return TRUE or FALSE
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION char** KRB5_LIB_CALL
krb5_config_get_strings(krb5_context context,
			const krb5_config_section *c,
			...)
{
    va_list ap;
    char **ret;
    va_start(ap, c);
    ret = krb5_config_vget_strings(context, c, ap);
    va_end(ap);
    return ret;
}

/**
 * Free the resulting strings from krb5_config-get_strings() and
 * krb5_config_vget_strings().
 *
 * @@param strings strings to free
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_config_free_strings(char **strings)
{
    char **s = strings;
    while(s && *s){
	free(*s);
	s++;
    }
    free(strings);
}

/**
 * Like krb5_config_get_bool_default() but with a va_list list of
 * configuration selection.
 *
 * Configuration value to a boolean value, where yes/true and any
 * non-zero number means TRUE and other value is FALSE.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param def_value the default value to return if no configuration
 *        found in the database.
 * @@param args a va_list of arguments
 *
 * @@return TRUE or FALSE
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_config_vget_bool_default (krb5_context context,
			       const krb5_config_section *c,
			       krb5_boolean def_value,
			       va_list args)
{
    const char *str;
    str = krb5_config_vget_string (context, c, args);
    if(str == NULL)
	return def_value;
    if(strcasecmp(str, "yes") == 0 ||
       strcasecmp(str, "true") == 0 ||
       atoi(str)) return TRUE;
    return FALSE;
}

/**
 * krb5_config_get_bool() will convert the configuration
 * option value to a boolean value, where yes/true and any non-zero
 * number means TRUE and other value is FALSE.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param args a va_list of arguments
 *
 * @@return TRUE or FALSE
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_config_vget_bool  (krb5_context context,
			const krb5_config_section *c,
			va_list args)
{
    return krb5_config_vget_bool_default (context, c, FALSE, args);
}

/**
 * krb5_config_get_bool_default() will convert the configuration
 * option value to a boolean value, where yes/true and any non-zero
 * number means TRUE and other value is FALSE.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param def_value the default value to return if no configuration
 *        found in the database.
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return TRUE or FALSE
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_config_get_bool_default (krb5_context context,
			      const krb5_config_section *c,
			      krb5_boolean def_value,
			      ...)
{
    va_list ap;
    krb5_boolean ret;
    va_start(ap, def_value);
    ret = krb5_config_vget_bool_default(context, c, def_value, ap);
    va_end(ap);
    return ret;
}

/**
 * Like krb5_config_get_bool() but with a va_list list of
 * configuration selection.
 *
 * Configuration value to a boolean value, where yes/true and any
 * non-zero number means TRUE and other value is FALSE.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return TRUE or FALSE
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_config_get_bool (krb5_context context,
		      const krb5_config_section *c,
		      ...)
{
    va_list ap;
    krb5_boolean ret;
    va_start(ap, c);
    ret = krb5_config_vget_bool (context, c, ap);
    va_end(ap);
    return ret;
}

/**
 * Get the time from the configuration file using a relative time.
 *
 * Like krb5_config_get_time_default() but with a va_list list of
 * configuration selection.
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param def_value the default value to return if no configuration
 *        found in the database.
 * @@param args a va_list of arguments
 *
 * @@return parsed the time (or def_value on parse error)
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_vget_time_default (krb5_context context,
			       const krb5_config_section *c,
			       int def_value,
			       va_list args)
{
    const char *str;
    krb5_deltat t;

    str = krb5_config_vget_string (context, c, args);
    if(str == NULL)
	return def_value;
    if (krb5_string_to_deltat(str, &t))
	return def_value;
    return t;
}

/**
 * Get the time from the configuration file using a relative time, for example: 1h30s
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param args a va_list of arguments
 *
 * @@return parsed the time or -1 on error
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_vget_time  (krb5_context context,
			const krb5_config_section *c,
			va_list args)
{
    return krb5_config_vget_time_default (context, c, -1, args);
}

/**
 * Get the time from the configuration file using a relative time, for example: 1h30s
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param def_value the default value to return if no configuration
 *        found in the database.
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return parsed the time (or def_value on parse error)
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_get_time_default (krb5_context context,
			      const krb5_config_section *c,
			      int def_value,
			      ...)
{
    va_list ap;
    int ret;
    va_start(ap, def_value);
    ret = krb5_config_vget_time_default(context, c, def_value, ap);
    va_end(ap);
    return ret;
}

/**
 * Get the time from the configuration file using a relative time, for example: 1h30s
 *
 * @@param context A Kerberos 5 context.
 * @@param c a configuration section, or NULL to use the section from context
 * @@param ... a list of names, terminated with NULL.
 *
 * @@return parsed the time or -1 on error
 *
 * @@ingroup krb5_support
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_get_time (krb5_context context,
		      const krb5_config_section *c,
		      ...)
{
    va_list ap;
    int ret;
    va_start(ap, c);
    ret = krb5_config_vget_time (context, c, ap);
    va_end(ap);
    return ret;
}


KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_vget_int_default (krb5_context context,
			      const krb5_config_section *c,
			      int def_value,
			      va_list args)
{
    const char *str;
    str = krb5_config_vget_string (context, c, args);
    if(str == NULL)
	return def_value;
    else {
	char *endptr;
	long l;
	l = strtol(str, &endptr, 0);
	if (endptr == str)
	    return def_value;
	else
	    return l;
    }
}

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_vget_int  (krb5_context context,
		       const krb5_config_section *c,
		       va_list args)
{
    return krb5_config_vget_int_default (context, c, -1, args);
}

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_get_int_default (krb5_context context,
			     const krb5_config_section *c,
			     int def_value,
			     ...)
{
    va_list ap;
    int ret;
    va_start(ap, def_value);
    ret = krb5_config_vget_int_default(context, c, def_value, ap);
    va_end(ap);
    return ret;
}

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_config_get_int (krb5_context context,
		     const krb5_config_section *c,
		     ...)
{
    va_list ap;
    int ret;
    va_start(ap, c);
    ret = krb5_config_vget_int (context, c, ap);
    va_end(ap);
    return ret;
}


#ifndef HEIMDAL_SMALLER

/**
 * Deprecated: configuration files are not strings
 *
 * @@ingroup krb5_deprecated
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_config_parse_string_multi(krb5_context context,
			       const char *string,
			       krb5_config_section **res)
    KRB5_DEPRECATED_FUNCTION("Use X instead")
{
    const char *str;
    unsigned lineno = 0;
    krb5_error_code ret;
    struct fileptr f;
    f.f = NULL;
    f.s = string;

    ret = krb5_config_parse_debug (&f, res, &lineno, &str);
    if (ret) {
	krb5_set_error_message (context, ret, "%s:%u: %s",
				"<constant>", lineno, str);
	return ret;
    }
    return 0;
}

#endif
@


1.8
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.7
log
@Sync with heimdal; clearer and might generet fewer conflicts on next import.

looks ok, beck@@ ray@@
@
text
@d2 32
a33 30
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a36 1
RCSID("$KTH: config_file.c,v 1.52 2004/09/30 11:22:48 lha Exp $");
d38 3
a40 1
#ifndef HAVE_NETINFO
d64 1
a64 1
	l = min(len, p - ptr->s);
d76 1
a76 1
				     const char **error_message);
d80 1
a80 1
				     const char **error_message);
d83 1
a83 1
				  const char **error_message);
d85 2
a86 2
static krb5_config_section *
get_entry(krb5_config_section **parent, const char *name, int type)
d91 2
a92 2
	if(type == krb5_config_list && 
	   type == (*q)->type &&
d117 1
a117 1
 * 
d120 1
a120 1
 * Store the error message in `error_message'.
d125 1
a125 1
	      const char **error_message)
d132 1
a132 1
	*error_message = "missing ]";
d136 1
a136 1
    tmp = get_entry(parent, p + 1, krb5_config_list);
d138 1
a138 1
	*error_message = "out of memory";
d148 1
a148 1
 * Store the error message in `error_message'.
d153 1
a153 1
	   const char **error_message)
d155 1
a155 1
    char buf[BUFSIZ];
d176 1
a176 1
	ret = parse_binding (f, lineno, p, &b, parent, error_message);
d181 1
a181 1
    *error_message = "unclosed {";
d192 1
a192 1
	      const char **error_message)
d202 1
a202 1
	*error_message = "missing =";
d209 1
a209 1
	*error_message = "missing =";
d217 1
a217 1
	tmp = get_entry(parent, p1, krb5_config_list);
d219 1
a219 1
	    *error_message = "out of memory";
d222 1
a222 1
	ret = parse_list (f, lineno, &tmp->u.list, error_message);
d224 1
a224 1
	tmp = get_entry(parent, p1, krb5_config_string);
d226 1
a226 1
	    *error_message = "out of memory";
d240 100
d342 1
a342 1
 * returning error messages in `error_message'
d349 1
a349 1
			 const char **error_message)
d353 1
a353 1
    char buf[BUFSIZ];
d367 2
a368 2
	    ret = parse_section(p, &s, res, error_message);
	    if (ret) 
d372 1
a372 1
	    *error_message = "unmatched }";
d376 1
a376 1
		*error_message = "binding before section";
d379 1
a379 1
	    ret = parse_binding(f, lineno, p, &b, &s->u.list, error_message);
d387 2
a388 4
krb5_error_code KRB5_LIB_FUNCTION
krb5_config_parse_string_multi(krb5_context context,
			       const char *string,
			       krb5_config_section **res)
d390 21
a410 14
    const char *str;
    unsigned lineno = 0;
    krb5_error_code ret;
    struct fileptr f;
    f.f = NULL;
    f.s = string;

    ret = krb5_config_parse_debug (&f, res, &lineno, &str);
    if (ret) {
	krb5_set_error_string (context, "%s:%u: %s", "<constant>", lineno, str);
	return ret;
    }
    return 0;
}
d412 1
a412 1
krb5_error_code KRB5_LIB_FUNCTION
d418 1
d422 43
a464 6
    f.f = fopen(fname, "r");
    f.s = NULL;
    if(f.f == NULL) {
	ret = errno;
	krb5_set_error_string (context, "open %s: %s", fname, strerror(ret));
	return ret;
d467 51
a517 5
    ret = krb5_config_parse_debug (&f, res, &lineno, &str);
    fclose(f.f);
    if (ret) {
	krb5_set_error_string (context, "%s:%u: %s", fname, lineno, str);
	return ret;
d522 1
a522 1
krb5_error_code KRB5_LIB_FUNCTION
a530 2
#endif /* !HAVE_NETINFO */

d543 1
a543 1
	    krb5_abortx(context, "unknown binding type (%d) in free_binding", 
d551 14
a564 1
krb5_error_code KRB5_LIB_FUNCTION
d571 44
a614 6
const void *
krb5_config_get_next (krb5_context context,
		      const krb5_config_section *c,
		      const krb5_config_binding **pointer,
		      int type,
		      ...)
d620 1
a620 1
    ret = krb5_config_vget_next (context, c, pointer, type, args);
d636 1
a636 1
	    if(b->type == type && p == NULL) {
d648 6
a653 6
const void *
krb5_config_vget_next (krb5_context context,
		       const krb5_config_section *c,
		       const krb5_config_binding **pointer,
		       int type,
		       va_list args)
d676 1
a676 1
	if(strcmp(b->name, (*pointer)->name) == 0 && b->type == type) {
d684 5
a688 5
const void *
krb5_config_get (krb5_context context,
		 const krb5_config_section *c,
		 int type,
		 ...)
d694 1
a694 1
    ret = krb5_config_vget (context, c, type, args);
d699 1
d701 4
a704 4
krb5_config_vget (krb5_context context,
		  const krb5_config_section *c,
		  int type,
		  va_list args)
d708 1
a708 1
    return krb5_config_vget_next (context, c, &foo, type, args);
d711 13
a723 1
const krb5_config_binding *
d737 13
a749 1
const krb5_config_binding *
d754 1
a754 1
    return krb5_config_vget (context, c, krb5_config_list, args);
d757 16
a772 1
const char* KRB5_LIB_FUNCTION
d786 13
a798 1
const char* KRB5_LIB_FUNCTION
d803 1
a803 1
    return krb5_config_vget (context, c, krb5_config_string, args);
d806 16
a821 1
const char* KRB5_LIB_FUNCTION
d835 16
a850 1
const char* KRB5_LIB_FUNCTION
d865 58
a922 1
char ** KRB5_LIB_FUNCTION
d932 2
a933 2
    while((p = krb5_config_vget_next(context, c, &b, 
				     krb5_config_string, args))) {
d939 1
a939 1
	s = strtok_r(tmp, " \t", &pos);
d941 2
a942 2
	    char **tmp = realloc(strings, (nstr + 1) * sizeof(*strings));
	    if(tmp == NULL)
d944 1
a944 1
	    strings = tmp;
d949 1
a949 1
	    s = strtok_r(NULL, " \t", &pos);
d955 1
a955 1
	if(strings == NULL)
d969 14
a982 1
char**
d995 10
a1004 1
void KRB5_LIB_FUNCTION
d1015 19
a1033 1
krb5_boolean KRB5_LIB_FUNCTION
d1049 15
a1063 1
krb5_boolean KRB5_LIB_FUNCTION
d1071 17
a1087 1
krb5_boolean KRB5_LIB_FUNCTION
d1101 17
a1117 1
krb5_boolean KRB5_LIB_FUNCTION
d1130 18
a1147 1
int KRB5_LIB_FUNCTION
d1164 13
a1176 1
int KRB5_LIB_FUNCTION
d1184 15
a1198 1
int KRB5_LIB_FUNCTION
d1212 13
a1224 1
int KRB5_LIB_FUNCTION
d1238 1
a1238 1
int KRB5_LIB_FUNCTION
d1248 7
a1254 7
    else { 
	char *endptr; 
	long l; 
	l = strtol(str, &endptr, 0); 
	if (endptr == str) 
	    return def_value; 
	else 
d1259 1
a1259 1
int KRB5_LIB_FUNCTION
d1267 1
a1267 1
int KRB5_LIB_FUNCTION
d1281 1
a1281 1
int KRB5_LIB_FUNCTION
d1293 33
@


1.6
log
@Check that string length != 0 before setting buf[strlen(buf) - 1].

OK cloder@@.
@
text
@d161 1
a161 2
	if (buf[0] != '\0' && buf[strlen(buf) - 1] == '\n')
	    buf[strlen(buf) - 1] = '\0';
d257 1
a257 2
	if(buf[0] != '\0' && buf[strlen(buf) - 1] == '\n')
	    buf[strlen(buf) - 1] = '\0';
@


1.5
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d161 1
a161 1
	if (buf[strlen(buf) - 1] == '\n')
d258 1
a258 1
	if(buf[strlen(buf) - 1] == '\n')
@


1.4
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.46.4.2 2003/10/13 13:46:10 lha Exp $");
d39 32
d74 1
a74 1
static krb5_error_code parse_binding(FILE *f, unsigned *lineno, char *p,
d78 1
a78 1
static krb5_error_code parse_list(FILE *f, unsigned *lineno,
d149 1
a149 1
parse_list(FILE *f, unsigned *lineno, krb5_config_binding **parent,
d157 1
a157 1
    while(fgets(buf, sizeof(buf), f) != NULL) {
d188 1
a188 1
parse_binding(FILE *f, unsigned *lineno, char *p,
d244 4
a247 4
krb5_config_parse_file_debug (const char *fname,
			      krb5_config_section **res,
			      unsigned *lineno,
			      const char **error_message)
d249 2
a250 3
    FILE *f;
    krb5_config_section *s;
    krb5_config_binding *b;
d252 1
a252 1
    krb5_error_code ret = 0;
d254 1
a254 9
    s = NULL;
    b = NULL;
    *lineno = 0;
    f = fopen (fname, "r");
    if (f == NULL) {
	*error_message = "cannot open file";
	return ENOENT;
    }
    while (fgets(buf, sizeof(buf), f) != NULL) {
d267 2
a268 3
	    if (ret) {
		goto out;
	    }
d272 1
a272 2
	    ret = EINVAL;	/* XXX */
	    goto out;
d276 1
a276 2
		ret = EINVAL;
		goto out;
d280 1
a280 1
		goto out;
d283 21
a303 3
out:
    fclose (f);
    return ret;
d306 1
a306 1
krb5_error_code
d312 1
a312 1
    unsigned lineno;
d314 8
d323 2
a324 1
    ret = krb5_config_parse_file_debug (fname, res, &lineno, &str);
d332 1
a332 1
krb5_error_code
d363 1
a363 1
krb5_error_code
d493 1
a493 1
const char *
d507 1
a507 1
const char *
d515 1
a515 1
const char *
d529 1
a529 1
const char *
d544 1
a544 1
char **
d604 1
a604 1
void
d615 1
a615 1
krb5_boolean
d631 1
a631 1
krb5_boolean
d639 1
a639 1
krb5_boolean
d653 1
a653 1
krb5_boolean
d666 1
a666 1
int
d673 2
d678 3
a680 1
    return parse_time (str, NULL);
d683 1
a683 1
int
d691 1
a691 1
int
d705 1
a705 1
int
d719 1
a719 1
int
d740 1
a740 1
int
d748 1
a748 1
int
d762 1
a762 1
int
@


1.3
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.46 2002/09/10 19:04:55 joda Exp $");
d116 1
a116 1
static int
d121 1
a121 1
    int ret;
d155 1
a155 1
static int
d162 1
a162 1
    int ret = 0;
d253 5
@


1.2
log
@/etc/krb5.conf -> /etc/kerberosV/krb5.conf
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.42 2001/05/14 06:14:45 assar Exp $");
d41 1
a41 1
				     char **error_message);
d45 1
a45 1
				     char **error_message);
d48 24
a71 1
				  char **error_message);
d90 1
a90 1
	      char **error_message)
d101 2
a102 2
    tmp = malloc(sizeof(*tmp));
    if (tmp == NULL) {
a105 12
    tmp->name = strdup(p+1);
    if (tmp->name == NULL) {
	*error_message = "out of memory";
	return KRB5_CONFIG_BADFORMAT;
    }
    tmp->type = krb5_config_list;
    tmp->u.list = NULL;
    tmp->next = NULL;
    if (*s)
	(*s)->next = tmp;
    else
	*parent = tmp;
d118 1
a118 1
	   char **error_message)
d158 1
a158 1
	      char **error_message)
d168 1
a168 1
	*error_message = "no =";
d175 1
a175 1
	*error_message = "no =";
a180 5
    tmp = malloc(sizeof(*tmp));
    if (tmp == NULL) {
	*error_message = "out of memory";
	return KRB5_CONFIG_BADFORMAT;
    }
a181 2
    tmp->name = strdup(p1);
    tmp->next = NULL;
d183 5
a187 2
	tmp->type = krb5_config_list;
	tmp->u.list = NULL;
d190 5
a199 1
	tmp->type = krb5_config_string;
a201 4
    if (*b)
	(*b)->next = tmp;
    else
	*parent = tmp;
d215 1
a215 1
			      char **error_message)
a230 1
    *res = NULL;
d264 3
a266 3
krb5_config_parse_file (krb5_context context,
			const char *fname,
			krb5_config_section **res)
d268 1
a268 1
    char *str;
d280 9
d320 2
a321 2
		      krb5_config_section *c,
		      krb5_config_binding **pointer,
d334 23
d359 2
a360 2
		       krb5_config_section *c,
		       krb5_config_binding **pointer,
d364 1
a364 1
    krb5_config_binding *b;
d374 2
a375 1
	b = (c != NULL) ? c : context->cf;
d379 1
a379 4
    } else {
	b = *pointer;
	p = b->name;
	b = b->next;
d382 6
a387 16
    while (b) {
	if (strcmp (b->name, p) == 0) {
	    if (*pointer == NULL)
		p = va_arg(args, const char *);
	    else
		p = NULL;
	    if (type == b->type && p == NULL) {
		*pointer = b;
		return b->u.generic;
	    } else if(b->type == krb5_config_list && p != NULL) {
		b = b->u.list;
	    } else {
		return NULL;
	    }
	} else {
	    b = b->next;
d395 1
a395 1
		 krb5_config_section *c,
d410 1
a410 1
		  krb5_config_section *c,
d414 1
a414 1
    krb5_config_binding *foo = NULL;
d421 1
a421 1
		      krb5_config_section *c,
d435 1
a435 1
		       krb5_config_section *c,
d443 1
a443 1
			krb5_config_section *c,
d457 1
a457 1
			 krb5_config_section *c,
d465 1
a465 1
				 krb5_config_section *c,
d479 1
a479 1
				krb5_config_section *c,
d494 1
a494 1
			 krb5_config_section *c,
d499 1
a499 1
    krb5_config_binding *b = NULL;
d541 1
a541 1
			krb5_config_section *c,
d565 1
a565 1
			       krb5_config_section *c,
d581 1
a581 1
			krb5_config_section *c,
d589 1
a589 1
			      krb5_config_section *c,
d603 1
a603 1
		      krb5_config_section *c,
d616 1
a616 1
			       krb5_config_section *c,
d629 1
a629 1
			krb5_config_section *c,
d637 1
a637 1
			      krb5_config_section *c,
d651 1
a651 1
		      krb5_config_section *c,
d665 1
a665 1
			      krb5_config_section *c,
d686 1
a686 1
		       krb5_config_section *c,
d694 1
a694 1
			     krb5_config_section *c,
d708 1
a708 1
		     krb5_config_section *c,
a717 100

#ifdef TEST

static int print_list (krb5_context context, FILE *f, 
		       krb5_config_binding *l, unsigned level);
static int print_binding (krb5_context context, FILE *f, 
			  krb5_config_binding *b, unsigned level);
static int print_section (krb5_context context, FILE *f, 
			  krb5_config_section *s, unsigned level);
static int print_config (krb5_context context, FILE *f, 
			 krb5_config_section *c);

static void
tab (FILE *f, unsigned count)
{
    while(count--)
	fprintf (f, "\t");
}

static int
print_list (krb5_context context, 
	    FILE *f, 
	    krb5_config_binding *l, 
	    unsigned level)
{
    while(l) {
	print_binding (context, f, l, level);
	l = l->next;
    }
    return 0;
}

static int
print_binding (krb5_context context, 
	       FILE *f, 
	       krb5_config_binding *b, 
	       unsigned level)
{
    tab (f, level);
    fprintf (f, "%s = ", b->name);
    if (b->type == krb5_config_string)
	fprintf (f, "%s\n", b->u.string);
    else if (b->type == krb5_config_list) {
	fprintf (f, "{\n");
	print_list (f, b->u.list, level + 1);
	tab (f, level);
	fprintf (f, "}\n");
    } else
	krb5_abortx(context, "unknown binding type (%d) in print_binding", 
		    b->type);
    return 0;
}

static int
print_section (FILE *f, krb5_config_section *s, unsigned level)
{
    fprintf (f, "[%s]\n", s->name);
    print_list (f, s->u.list, level + 1);
    return 0;
}

static int
print_config (FILE *f, krb5_config_section *c)
{
    while (c) {
	print_section (f, c, 0);
	c = c->next;
    }
    return 0;
}


int
main(void)
{
    krb5_config_section *c;

    printf ("%d\n", krb5_config_parse_file ("/etc/kerberosV/krb5.conf", &c));
    print_config (stdout, c);
    printf ("[libdefaults]ticket_lifetime = %s\n",
	    krb5_config_get_string (context, c,
			       "libdefaults",
			       "ticket_lifetime",
			       NULL));
    printf ("[realms]foo = %s\n",
	    krb5_config_get_string (context, c,
			       "realms",
			       "foo",
			       NULL));
    printf ("[realms]ATHENA.MIT.EDU/v4_instance_convert/lithium = %s\n",
	    krb5_config_get_string (context, c,
			       "realms",
			       "ATHENA.MIT.EDU",
			       "v4_instance_convert",
			       "lithium",
			       NULL));
    return 0;
}

#endif /* TEST */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 1998, 1999, 2000 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.41 2000/08/16 07:40:36 assar Exp $");
d39 10
a48 9
static int parse_section(char *p, krb5_config_section **s,
			 krb5_config_section **res,
			 char **error_message);
static int parse_binding(FILE *f, unsigned *lineno, char *p,
			 krb5_config_binding **b,
			 krb5_config_binding **parent,
			 char **error_message);
static int parse_list(FILE *f, unsigned *lineno, krb5_config_binding **parent,
		      char **error_message);
d65 1
a65 1
static int
d75 1
a75 1
	return -1;
d81 1
a81 1
	return -1;
d86 1
a86 1
	return -1;
d137 1
a137 1
    return -1;
d158 1
a158 1
	return -1;
d165 1
a165 1
	return -1;
d173 1
a173 1
	return -1;
d204 1
a204 1
krb5_error_code
d214 1
a214 1
    int ret = 0;
d244 1
a244 1
	    ret = -1;
d258 3
a260 1
krb5_config_parse_file (const char *fname, krb5_config_section **res)
d262 1
a262 1
    char *foo;
d264 1
d266 6
a271 1
    return krb5_config_parse_file_debug (fname, res, &lineno, &foo);
d769 1
a769 1
    printf ("%d\n", krb5_config_parse_file ("/etc/krb5.conf", &c));
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.42 2001/05/14 06:14:45 assar Exp $");
d39 9
a47 10
static krb5_error_code parse_section(char *p, krb5_config_section **s,
				     krb5_config_section **res,
				     char **error_message);
static krb5_error_code parse_binding(FILE *f, unsigned *lineno, char *p,
				     krb5_config_binding **b,
				     krb5_config_binding **parent,
				     char **error_message);
static krb5_error_code parse_list(FILE *f, unsigned *lineno,
				  krb5_config_binding **parent,
				  char **error_message);
d64 1
a64 1
static krb5_error_code
d74 1
a74 1
	return KRB5_CONFIG_BADFORMAT;
d80 1
a80 1
	return KRB5_CONFIG_BADFORMAT;
d85 1
a85 1
	return KRB5_CONFIG_BADFORMAT;
d136 1
a136 1
    return KRB5_CONFIG_BADFORMAT;
d157 1
a157 1
	return KRB5_CONFIG_BADFORMAT;
d164 1
a164 1
	return KRB5_CONFIG_BADFORMAT;
d172 1
a172 1
	return KRB5_CONFIG_BADFORMAT;
d203 1
a203 1
static krb5_error_code
d213 1
a213 1
    krb5_error_code ret = 0;
d243 1
a243 1
	    ret = EINVAL;	/* XXX */
d257 1
a257 3
krb5_config_parse_file (krb5_context context,
			const char *fname,
			krb5_config_section **res)
d259 1
a259 1
    char *str;
a260 1
    krb5_error_code ret;
d262 1
a262 6
    ret = krb5_config_parse_file_debug (fname, res, &lineno, &str);
    if (ret) {
	krb5_set_error_string (context, "%s:%u: %s", fname, lineno, str);
	return ret;
    }
    return 0;
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.46 2002/09/10 19:04:55 joda Exp $");
d41 1
a41 1
				     const char **error_message);
d45 1
a45 1
				     const char **error_message);
d48 1
a48 24
				  const char **error_message);

static krb5_config_section *
get_entry(krb5_config_section **parent, const char *name, int type)
{
    krb5_config_section **q;

    for(q = parent; *q != NULL; q = &(*q)->next)
	if(type == krb5_config_list && 
	   type == (*q)->type &&
	   strcmp(name, (*q)->name) == 0)
	    return *q;
    *q = calloc(1, sizeof(**q));
    if(*q == NULL)
	return NULL;
    (*q)->name = strdup(name);
    (*q)->type = type;
    if((*q)->name == NULL) {
	free(*q);
	*q = NULL;
	return NULL;
    }
    return *q;
}
d67 1
a67 1
	      const char **error_message)
d78 2
a79 2
    tmp = get_entry(parent, p + 1, krb5_config_list);
    if(tmp == NULL) {
d83 12
d107 1
a107 1
	   const char **error_message)
d147 1
a147 1
	      const char **error_message)
d157 1
a157 1
	*error_message = "missing =";
d164 1
a164 1
	*error_message = "missing =";
d170 5
d176 2
d179 2
a180 5
	tmp = get_entry(parent, p1, krb5_config_list);
	if (tmp == NULL) {
	    *error_message = "out of memory";
	    return KRB5_CONFIG_BADFORMAT;
	}
a182 5
	tmp = get_entry(parent, p1, krb5_config_string);
	if (tmp == NULL) {
	    *error_message = "out of memory";
	    return KRB5_CONFIG_BADFORMAT;
	}
d188 1
d191 4
d208 1
a208 1
			      const char **error_message)
d224 1
d258 3
a260 3
krb5_config_parse_file_multi (krb5_context context,
			      const char *fname,
			      krb5_config_section **res)
d262 1
a262 1
    const char *str;
a273 9
krb5_error_code
krb5_config_parse_file (krb5_context context,
			const char *fname,
			krb5_config_section **res)
{
    *res = NULL;
    return krb5_config_parse_file_multi(context, fname, res);
}

d305 2
a306 2
		      const krb5_config_section *c,
		      const krb5_config_binding **pointer,
a318 23
static const void *
vget_next(krb5_context context,
	  const krb5_config_binding *b,
	  const krb5_config_binding **pointer,
	  int type,
	  const char *name,
	  va_list args)
{
    const char *p = va_arg(args, const char *);
    while(b != NULL) {
	if(strcmp(b->name, name) == 0) {
	    if(b->type == type && p == NULL) {
		*pointer = b;
		return b->u.generic;
	    } else if(b->type == krb5_config_list && p != NULL) {
		return vget_next(context, b->u.list, pointer, type, p, args);
	    }
	}
	b = b->next;
    }
    return NULL;
}

d321 2
a322 2
		       const krb5_config_section *c,
		       const krb5_config_binding **pointer,
d326 1
a326 1
    const krb5_config_binding *b;
d336 1
a336 2
	/* first time here, walk down the tree looking for the right
           section */
d340 4
a343 1
	return vget_next(context, c, pointer, type, p, args);
d346 16
a361 6
    /* we were called again, so just look for more entries with the
       same name and type */
    for (b = (*pointer)->next; b != NULL; b = b->next) {
	if(strcmp(b->name, (*pointer)->name) == 0 && b->type == type) {
	    *pointer = b;
	    return b->u.generic;
d369 1
a369 1
		 const krb5_config_section *c,
d384 1
a384 1
		  const krb5_config_section *c,
d388 1
a388 1
    const krb5_config_binding *foo = NULL;
d395 1
a395 1
		      const krb5_config_section *c,
d409 1
a409 1
		       const krb5_config_section *c,
d417 1
a417 1
			const krb5_config_section *c,
d431 1
a431 1
			 const krb5_config_section *c,
d439 1
a439 1
				 const krb5_config_section *c,
d453 1
a453 1
				const krb5_config_section *c,
d468 1
a468 1
			 const krb5_config_section *c,
d473 1
a473 1
    const krb5_config_binding *b = NULL;
d515 1
a515 1
			const krb5_config_section *c,
d539 1
a539 1
			       const krb5_config_section *c,
d555 1
a555 1
			const krb5_config_section *c,
d563 1
a563 1
			      const krb5_config_section *c,
d577 1
a577 1
		      const krb5_config_section *c,
d590 1
a590 1
			       const krb5_config_section *c,
d603 1
a603 1
			const krb5_config_section *c,
d611 1
a611 1
			      const krb5_config_section *c,
d625 1
a625 1
		      const krb5_config_section *c,
d639 1
a639 1
			      const krb5_config_section *c,
d660 1
a660 1
		       const krb5_config_section *c,
d668 1
a668 1
			     const krb5_config_section *c,
d682 1
a682 1
		     const krb5_config_section *c,
d692 100
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.46.4.2 2003/10/13 13:46:10 lha Exp $");
d116 1
a116 1
static krb5_error_code
d121 1
a121 1
    krb5_error_code ret;
d155 1
a155 1
static krb5_error_code
d162 1
a162 1
    krb5_error_code ret = 0;
a252 5
	    if (s == NULL) {
		*error_message = "binding before section";
		ret = EINVAL;
		goto out;
	    }
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: config_file.c,v 1.52 2004/09/30 11:22:48 lha Exp $");
a38 32
/* Gaah! I want a portable funopen */
struct fileptr {
    const char *s;
    FILE *f;
};

static char *
config_fgets(char *str, size_t len, struct fileptr *ptr)
{
    /* XXX this is not correct, in that they don't do the same if the
       line is longer than len */
    if(ptr->f != NULL)
	return fgets(str, len, ptr->f);
    else {
	/* this is almost strsep_copy */
	const char *p;
	ssize_t l;
	if(*ptr->s == '\0')
	    return NULL;
	p = ptr->s + strcspn(ptr->s, "\n");
	if(*p == '\n')
	    p++;
	l = min(len, p - ptr->s);
	if(len > 0) {
	    memcpy(str, ptr->s, l);
	    str[l] = '\0';
	}
	ptr->s = p;
	return str;
    }
}

d42 1
a42 1
static krb5_error_code parse_binding(struct fileptr *f, unsigned *lineno, char *p,
d46 1
a46 1
static krb5_error_code parse_list(struct fileptr *f, unsigned *lineno,
d117 1
a117 1
parse_list(struct fileptr *f, unsigned *lineno, krb5_config_binding **parent,
d125 1
a125 1
    while(config_fgets(buf, sizeof(buf), f) != NULL) {
d156 1
a156 1
parse_binding(struct fileptr *f, unsigned *lineno, char *p,
d212 4
a215 4
krb5_config_parse_debug (struct fileptr *f,
			 krb5_config_section **res,
			 unsigned *lineno,
			 const char **error_message)
d217 3
a219 2
    krb5_config_section *s = NULL;
    krb5_config_binding *b = NULL;
d221 1
a221 1
    krb5_error_code ret;
d223 9
a231 1
    while (config_fgets(buf, sizeof(buf), f) != NULL) {
d244 3
a246 2
	    if (ret) 
		return ret;
d250 2
a251 1
	    return EINVAL;	/* XXX */
d255 2
a256 1
		return EINVAL;
d260 1
a260 1
		return ret;
d263 3
a265 1
    return 0;
d268 1
a268 21
krb5_error_code KRB5_LIB_FUNCTION
krb5_config_parse_string_multi(krb5_context context,
			       const char *string,
			       krb5_config_section **res)
{
    const char *str;
    unsigned lineno = 0;
    krb5_error_code ret;
    struct fileptr f;
    f.f = NULL;
    f.s = string;

    ret = krb5_config_parse_debug (&f, res, &lineno, &str);
    if (ret) {
	krb5_set_error_string (context, "%s:%u: %s", "<constant>", lineno, str);
	return ret;
    }
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
d274 1
a274 1
    unsigned lineno = 0;
a275 8
    struct fileptr f;
    f.f = fopen(fname, "r");
    f.s = NULL;
    if(f.f == NULL) {
	ret = errno;
	krb5_set_error_string (context, "open %s: %s", fname, strerror(ret));
	return ret;
    }
d277 1
a277 2
    ret = krb5_config_parse_debug (&f, res, &lineno, &str);
    fclose(f.f);
d285 1
a285 1
krb5_error_code KRB5_LIB_FUNCTION
d316 1
a316 1
krb5_error_code KRB5_LIB_FUNCTION
d446 1
a446 1
const char* KRB5_LIB_FUNCTION
d460 1
a460 1
const char* KRB5_LIB_FUNCTION
d468 1
a468 1
const char* KRB5_LIB_FUNCTION
d482 1
a482 1
const char* KRB5_LIB_FUNCTION
d497 1
a497 1
char ** KRB5_LIB_FUNCTION
d557 1
a557 1
void KRB5_LIB_FUNCTION
d568 1
a568 1
krb5_boolean KRB5_LIB_FUNCTION
d584 1
a584 1
krb5_boolean KRB5_LIB_FUNCTION
d592 1
a592 1
krb5_boolean KRB5_LIB_FUNCTION
d606 1
a606 1
krb5_boolean KRB5_LIB_FUNCTION
d619 1
a619 1
int KRB5_LIB_FUNCTION
a625 2
    krb5_deltat t;

d629 1
a629 3
    if (krb5_string_to_deltat(str, &t))
	return def_value;
    return t;
d632 1
a632 1
int KRB5_LIB_FUNCTION
d640 1
a640 1
int KRB5_LIB_FUNCTION
d654 1
a654 1
int KRB5_LIB_FUNCTION
d668 1
a668 1
int KRB5_LIB_FUNCTION
d689 1
a689 1
int KRB5_LIB_FUNCTION
d697 1
a697 1
int KRB5_LIB_FUNCTION
d711 1
a711 1
int KRB5_LIB_FUNCTION
@


