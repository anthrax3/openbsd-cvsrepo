head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	HEIMDAL_0_6:1.1.1.5
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.22.10.01.32;	author reyk;	state dead;
branches;
next	1.7;

1.7
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.13.03.09.16;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.20.14.35.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.12.23.20.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.52;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.52;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.24.32;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.34;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.57;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.13.03.00.16;	author hin;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.33.26;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 2001 - 2003 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"
#include <resolve.h>
#include "locate_plugin.h"

static int
string_to_proto(const char *string)
{
    if(strcasecmp(string, "udp") == 0)
	return KRB5_KRBHST_UDP;
    else if(strcasecmp(string, "tcp") == 0)
	return KRB5_KRBHST_TCP;
    else if(strcasecmp(string, "http") == 0)
	return KRB5_KRBHST_HTTP;
    return -1;
}

/*
 * set `res' and `count' to the result of looking up SRV RR in DNS for
 * `proto', `proto', `realm' using `dns_type'.
 * if `port' != 0, force that port number
 */

static krb5_error_code
srv_find_realm(krb5_context context, krb5_krbhst_info ***res, int *count,
	       const char *realm, const char *dns_type,
	       const char *proto, const char *service, int port)
{
    char domain[1024];
    struct rk_dns_reply *r;
    struct rk_resource_record *rr;
    int num_srv;
    int proto_num;
    int def_port;

    *res = NULL;
    *count = 0;

    proto_num = string_to_proto(proto);
    if(proto_num < 0) {
	krb5_set_error_message(context, EINVAL,
			       N_("unknown protocol `%s' to lookup", ""),
			       proto);
	return EINVAL;
    }

    if(proto_num == KRB5_KRBHST_HTTP)
	def_port = ntohs(krb5_getportbyname (context, "http", "tcp", 80));
    else if(port == 0)
	def_port = ntohs(krb5_getportbyname (context, service, proto, 88));
    else
	def_port = port;

    snprintf(domain, sizeof(domain), "_%s._%s.%s.", service, proto, realm);

    r = rk_dns_lookup(domain, dns_type);
    if(r == NULL) {
	_krb5_debug(context, 0,
		    "DNS lookup failed domain: %s", domain);
	return KRB5_KDC_UNREACH;
    }

    for(num_srv = 0, rr = r->head; rr; rr = rr->next)
	if(rr->type == rk_ns_t_srv)
	    num_srv++;

    *res = malloc(num_srv * sizeof(**res));
    if(*res == NULL) {
	rk_dns_free_data(r);
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    rk_dns_srv_order(r);

    for(num_srv = 0, rr = r->head; rr; rr = rr->next)
	if(rr->type == rk_ns_t_srv) {
	    krb5_krbhst_info *hi;
	    size_t len = strlen(rr->u.srv->target);

	    hi = calloc(1, sizeof(*hi) + len);
	    if(hi == NULL) {
		rk_dns_free_data(r);
		while(--num_srv >= 0)
		    free((*res)[num_srv]);
		free(*res);
		*res = NULL;
		return ENOMEM;
	    }
	    (*res)[num_srv++] = hi;

	    hi->proto = proto_num;

	    hi->def_port = def_port;
	    if (port != 0)
		hi->port = port;
	    else
		hi->port = rr->u.srv->port;

	    strlcpy(hi->hostname, rr->u.srv->target, len + 1);
	}

    *count = num_srv;

    rk_dns_free_data(r);
    return 0;
}


struct krb5_krbhst_data {
    char *realm;
    unsigned int flags;
    int def_port;
    int port;			/* hardwired port number if != 0 */
#define KD_CONFIG		 1
#define KD_SRV_UDP		 2
#define KD_SRV_TCP		 4
#define KD_SRV_HTTP		 8
#define KD_FALLBACK		16
#define KD_CONFIG_EXISTS	32
#define KD_LARGE_MSG		64
#define KD_PLUGIN	       128
    krb5_error_code (*get_next)(krb5_context, struct krb5_krbhst_data *,
				krb5_krbhst_info**);

    unsigned int fallback_count;

    struct krb5_krbhst_info *hosts, **index, **end;
};

static krb5_boolean
krbhst_empty(const struct krb5_krbhst_data *kd)
{
    return kd->index == &kd->hosts;
}

/*
 * Return the default protocol for the `kd' (either TCP or UDP)
 */

static int
krbhst_get_default_proto(struct krb5_krbhst_data *kd)
{
    if (kd->flags & KD_LARGE_MSG)
	return KRB5_KRBHST_TCP;
    return KRB5_KRBHST_UDP;
}

/*
 *
 */

const char *
_krb5_krbhst_get_realm(krb5_krbhst_handle handle)
{
    return handle->realm;
}

/*
 * parse `spec' into a krb5_krbhst_info, defaulting the port to `def_port'
 * and forcing it to `port' if port != 0
 */

static struct krb5_krbhst_info*
parse_hostspec(krb5_context context, struct krb5_krbhst_data *kd,
	       const char *spec, int def_port, int port)
{
    const char *p = spec, *q;
    struct krb5_krbhst_info *hi;

    hi = calloc(1, sizeof(*hi) + strlen(spec));
    if(hi == NULL)
	return NULL;

    hi->proto = krbhst_get_default_proto(kd);

    if(strncmp(p, "http://", 7) == 0){
	hi->proto = KRB5_KRBHST_HTTP;
	p += 7;
    } else if(strncmp(p, "http/", 5) == 0) {
	hi->proto = KRB5_KRBHST_HTTP;
	p += 5;
	def_port = ntohs(krb5_getportbyname (context, "http", "tcp", 80));
    }else if(strncmp(p, "tcp/", 4) == 0){
	hi->proto = KRB5_KRBHST_TCP;
	p += 4;
    } else if(strncmp(p, "udp/", 4) == 0) {
	p += 4;
    }

    if (p[0] == '[' && (q = strchr(p, ']')) != NULL) {
	/* if address looks like [foo:bar] or [foo:bar]: its a ipv6
	   adress, strip of [] */
	memcpy(hi->hostname, &p[1], q - p - 1);
	hi->hostname[q - p - 1] = '\0';
	p = q + 1;
	/* get trailing : */
	if (p[0] == ':')
	    p++;
    } else if(strsep_copy(&p, ":", hi->hostname, strlen(spec) + 1) < 0) {
	/* copy everything before : */
	free(hi);
	return NULL;
    }
    /* get rid of trailing /, and convert to lower case */
    hi->hostname[strcspn(hi->hostname, "/")] = '\0';
    strlwr(hi->hostname);

    hi->port = hi->def_port = def_port;
    if(p != NULL && p[0]) {
	char *end;
	hi->port = strtol(p, &end, 0);
	if(end == p) {
	    free(hi);
	    return NULL;
	}
    }
    if (port)
	hi->port = port;
    return hi;
}

void
_krb5_free_krbhst_info(krb5_krbhst_info *hi)
{
    if (hi->ai != NULL)
	freeaddrinfo(hi->ai);
    free(hi);
}

krb5_error_code
_krb5_krbhost_info_move(krb5_context context,
			krb5_krbhst_info *from,
			krb5_krbhst_info **to)
{
    size_t hostnamelen = strlen(from->hostname);
    /* trailing NUL is included in structure */
    *to = calloc(1, sizeof(**to) + hostnamelen);
    if(*to == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    (*to)->proto = from->proto;
    (*to)->port = from->port;
    (*to)->def_port = from->def_port;
    (*to)->ai = from->ai;
    from->ai = NULL;
    (*to)->next = NULL;
    memcpy((*to)->hostname, from->hostname, hostnamelen + 1);
    return 0;
}


static void
append_host_hostinfo(struct krb5_krbhst_data *kd, struct krb5_krbhst_info *host)
{
    struct krb5_krbhst_info *h;

    for(h = kd->hosts; h; h = h->next)
	if(h->proto == host->proto &&
	   h->port == host->port &&
	   strcmp(h->hostname, host->hostname) == 0) {
	    _krb5_free_krbhst_info(host);
	    return;
	}
    *kd->end = host;
    kd->end = &host->next;
}

static krb5_error_code
append_host_string(krb5_context context, struct krb5_krbhst_data *kd,
		   const char *host, int def_port, int port)
{
    struct krb5_krbhst_info *hi;

    hi = parse_hostspec(context, kd, host, def_port, port);
    if(hi == NULL)
	return ENOMEM;

    append_host_hostinfo(kd, hi);
    return 0;
}

/*
 * return a readable representation of `host' in `hostname, hostlen'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_krbhst_format_string(krb5_context context, const krb5_krbhst_info *host,
			  char *hostname, size_t hostlen)
{
    const char *proto = "";
    char portstr[7] = "";
    if(host->proto == KRB5_KRBHST_TCP)
	proto = "tcp/";
    else if(host->proto == KRB5_KRBHST_HTTP)
	proto = "http://";
    if(host->port != host->def_port)
	snprintf(portstr, sizeof(portstr), ":%d", host->port);
    snprintf(hostname, hostlen, "%s%s%s", proto, host->hostname, portstr);
    return 0;
}

/*
 * create a getaddrinfo `hints' based on `proto'
 */

static void
make_hints(struct addrinfo *hints, int proto)
{
    memset(hints, 0, sizeof(*hints));
    hints->ai_family = AF_UNSPEC;
    switch(proto) {
    case KRB5_KRBHST_UDP :
	hints->ai_socktype = SOCK_DGRAM;
	break;
    case KRB5_KRBHST_HTTP :
    case KRB5_KRBHST_TCP :
	hints->ai_socktype = SOCK_STREAM;
	break;
    }
}

/**
 * Return an `struct addrinfo *' for a KDC host.
 *
 * Returns an the struct addrinfo in in that corresponds to the
 * information in `host'.  free:ing is handled by krb5_krbhst_free, so
 * the returned ai must not be released.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_krbhst_get_addrinfo(krb5_context context, krb5_krbhst_info *host,
			 struct addrinfo **ai)
{
    int ret = 0;

    if (host->ai == NULL) {
	struct addrinfo hints;
	char portstr[NI_MAXSERV];
	char *hostname = host->hostname;

	snprintf (portstr, sizeof(portstr), "%d", host->port);
	make_hints(&hints, host->proto);

	/**
	 * First try this as an IP address, this allows us to add a
	 * dot at the end to stop using the search domains.
	 */

	hints.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;

	ret = getaddrinfo(host->hostname, portstr, &hints, &host->ai);
	if (ret == 0)
	    goto out;

	/**
	 * If the hostname contains a dot, assumes it's a FQDN and
	 * don't use search domains since that might be painfully slow
	 * when machine is disconnected from that network.
	 */

	hints.ai_flags &= ~(AI_NUMERICHOST);

	if (strchr(hostname, '.') && hostname[strlen(hostname) - 1] != '.') {
	    ret = asprintf(&hostname, "%s.", host->hostname);
	    if (ret < 0 || hostname == NULL)
		return ENOMEM;
	}

	ret = getaddrinfo(hostname, portstr, &hints, &host->ai);
	if (hostname != host->hostname)
	    free(hostname);
	if (ret) {
	    ret = krb5_eai_to_heim_errno(ret, errno);
	    goto out;
	}
    }
 out:
    *ai = host->ai;
    return ret;
}

static krb5_boolean
get_next(struct krb5_krbhst_data *kd, krb5_krbhst_info **host)
{
    struct krb5_krbhst_info *hi = *kd->index;
    if(hi != NULL) {
	*host = hi;
	kd->index = &(*kd->index)->next;
	return TRUE;
    }
    return FALSE;
}

static void
srv_get_hosts(krb5_context context, struct krb5_krbhst_data *kd,
	      const char *proto, const char *service)
{
    krb5_error_code ret;
    krb5_krbhst_info **res;
    int count, i;

    ret = srv_find_realm(context, &res, &count, kd->realm, "SRV", proto, service,
			 kd->port);
    _krb5_debug(context, 2, "searching DNS for realm %s %s.%s -> %d",
		kd->realm, proto, service, ret);
    if (ret)
	return;
    for(i = 0; i < count; i++)
	append_host_hostinfo(kd, res[i]);
    free(res);
}

/*
 * read the configuration for `conf_string', defaulting to kd->def_port and
 * forcing it to `kd->port' if kd->port != 0
 */

static void
config_get_hosts(krb5_context context, struct krb5_krbhst_data *kd,
		 const char *conf_string)
{
    int i;
    char **hostlist;
    hostlist = krb5_config_get_strings(context, NULL,
				       "realms", kd->realm, conf_string, NULL);

    _krb5_debug(context, 2, "configuration file for realm %s%s found",
		kd->realm, hostlist ? "" : " not");

    if(hostlist == NULL)
	return;
    kd->flags |= KD_CONFIG_EXISTS;
    for(i = 0; hostlist && hostlist[i] != NULL; i++)
	append_host_string(context, kd, hostlist[i], kd->def_port, kd->port);

    krb5_config_free_strings(hostlist);
}

/*
 * as a fallback, look for `serv_string.kd->realm' (typically
 * kerberos.REALM, kerberos-1.REALM, ...
 * `port' is the default port for the service, and `proto' the
 * protocol
 */

static krb5_error_code
fallback_get_hosts(krb5_context context, struct krb5_krbhst_data *kd,
		   const char *serv_string, int port, int proto)
{
    char *host = NULL;
    int ret;
    struct addrinfo *ai;
    struct addrinfo hints;
    char portstr[NI_MAXSERV];

    _krb5_debug(context, 2, "fallback lookup %d for realm %s (service %s)",
		kd->fallback_count, kd->realm, serv_string);

    /*
     * Don't try forever in case the DNS server keep returning us
     * entries (like wildcard entries or the .nu TLD)
     */
    if(kd->fallback_count >= 5) {
	kd->flags |= KD_FALLBACK;
	return 0;
    }

    if(kd->fallback_count == 0)
	ret = asprintf(&host, "%s.%s.", serv_string, kd->realm);
    else
	ret = asprintf(&host, "%s-%d.%s.",
		       serv_string, kd->fallback_count, kd->realm);

    if (ret < 0 || host == NULL)
	return ENOMEM;

    make_hints(&hints, proto);
    snprintf(portstr, sizeof(portstr), "%d", port);
    ret = getaddrinfo(host, portstr, &hints, &ai);
    if (ret) {
	/* no more hosts, so we're done here */
	free(host);
	kd->flags |= KD_FALLBACK;
    } else {
	struct krb5_krbhst_info *hi;
	size_t hostlen = strlen(host);

	hi = calloc(1, sizeof(*hi) + hostlen);
	if(hi == NULL) {
	    free(host);
	    return ENOMEM;
	}

	hi->proto = proto;
	hi->port  = hi->def_port = port;
	hi->ai    = ai;
	memmove(hi->hostname, host, hostlen);
	hi->hostname[hostlen] = '\0';
	free(host);
	append_host_hostinfo(kd, hi);
	kd->fallback_count++;
    }
    return 0;
}

/*
 * Fetch hosts from plugin
 */

static krb5_error_code
add_locate(void *ctx, int type, struct sockaddr *addr)
{
    struct krb5_krbhst_info *hi;
    struct krb5_krbhst_data *kd = ctx;
    char host[NI_MAXHOST], port[NI_MAXSERV];
    struct addrinfo hints, *ai;
    socklen_t socklen;
    size_t hostlen;
    int ret;

    socklen = socket_sockaddr_size(addr);

    ret = getnameinfo(addr, socklen, host, sizeof(host), port, sizeof(port),
		      NI_NUMERICHOST|NI_NUMERICSERV);
    if (ret != 0)
	return 0;

    make_hints(&hints, krbhst_get_default_proto(kd));
    ret = getaddrinfo(host, port, &hints, &ai);
    if (ret)
	return 0;

    hostlen = strlen(host);

    hi = calloc(1, sizeof(*hi) + hostlen);
    if(hi == NULL)
	return ENOMEM;

    hi->proto = krbhst_get_default_proto(kd);
    hi->port  = hi->def_port = socket_get_port(addr);
    hi->ai    = ai;
    memmove(hi->hostname, host, hostlen);
    hi->hostname[hostlen] = '\0';
    append_host_hostinfo(kd, hi);

    return 0;
}

static void
plugin_get_hosts(krb5_context context,
		 struct krb5_krbhst_data *kd,
		 enum locate_service_type type)
{
    struct krb5_plugin *list = NULL, *e;
    krb5_error_code ret;

    ret = _krb5_plugin_find(context, PLUGIN_TYPE_DATA,
			    KRB5_PLUGIN_LOCATE, &list);
    if(ret != 0 || list == NULL)
	return;

    for (e = list; e != NULL; e = _krb5_plugin_get_next(e)) {
	krb5plugin_service_locate_ftable *service;
	void *ctx;

	service = _krb5_plugin_get_symbol(e);
	if (service->minor_version != 0)
	    continue;

	(*service->init)(context, &ctx);
	ret = (*service->lookup)(ctx, type, kd->realm, 0, 0, add_locate, kd);
	(*service->fini)(ctx);
	if (ret && ret != KRB5_PLUGIN_NO_HANDLE) {
	    krb5_set_error_message(context, ret,
				   N_("Locate plugin failed to lookup realm %s: %d", ""),
				   kd->realm, ret);
	    break;
	} else if (ret == 0) {
	    _krb5_debug(context, 2, "plugin found result for realm %s", kd->realm);
	    kd->flags |= KD_CONFIG_EXISTS;
	}

    }
    _krb5_plugin_free(list);
}

/*
 *
 */

static krb5_error_code
kdc_get_next(krb5_context context,
	     struct krb5_krbhst_data *kd,
	     krb5_krbhst_info **host)
{
    krb5_error_code ret;

    if ((kd->flags & KD_PLUGIN) == 0) {
	plugin_get_hosts(context, kd, locate_service_kdc);
	kd->flags |= KD_PLUGIN;
	if(get_next(kd, host))
	    return 0;
    }

    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "kdc");
	kd->flags |= KD_CONFIG;
	if(get_next(kd, host))
	    return 0;
    }

    if (kd->flags & KD_CONFIG_EXISTS) {
	_krb5_debug(context, 1,
		    "Configuration exists for realm %s, wont go to DNS",
		    kd->realm);
	return KRB5_KDC_UNREACH;
    }

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_UDP) == 0 && (kd->flags & KD_LARGE_MSG) == 0) {
	    srv_get_hosts(context, kd, "udp", "kerberos");
	    kd->flags |= KD_SRV_UDP;
	    if(get_next(kd, host))
		return 0;
	}

	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "kerberos");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
	if((kd->flags & KD_SRV_HTTP) == 0) {
	    srv_get_hosts(context, kd, "http", "kerberos");
	    kd->flags |= KD_SRV_HTTP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    while((kd->flags & KD_FALLBACK) == 0) {
	ret = fallback_get_hosts(context, kd, "kerberos",
				 kd->def_port,
				 krbhst_get_default_proto(kd));
	if(ret)
	    return ret;
	if(get_next(kd, host))
	    return 0;
    }

    _krb5_debug(context, 0, "No KDC entries found for %s", kd->realm);

    return KRB5_KDC_UNREACH; /* XXX */
}

static krb5_error_code
admin_get_next(krb5_context context,
	       struct krb5_krbhst_data *kd,
	       krb5_krbhst_info **host)
{
    krb5_error_code ret;

    if ((kd->flags & KD_PLUGIN) == 0) {
	plugin_get_hosts(context, kd, locate_service_kadmin);
	kd->flags |= KD_PLUGIN;
	if(get_next(kd, host))
	    return 0;
    }

    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "admin_server");
	kd->flags |= KD_CONFIG;
	if(get_next(kd, host))
	    return 0;
    }

    if (kd->flags & KD_CONFIG_EXISTS) {
	_krb5_debug(context, 1,
		    "Configuration exists for realm %s, wont go to DNS",
		    kd->realm);
	return KRB5_KDC_UNREACH;
    }

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "kerberos-adm");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    if (krbhst_empty(kd)
	&& (kd->flags & KD_FALLBACK) == 0) {
	ret = fallback_get_hosts(context, kd, "kerberos",
				 kd->def_port,
				 krbhst_get_default_proto(kd));
	if(ret)
	    return ret;
	kd->flags |= KD_FALLBACK;
	if(get_next(kd, host))
	    return 0;
    }

    _krb5_debug(context, 0, "No admin entries found for realm %s", kd->realm);

    return KRB5_KDC_UNREACH;	/* XXX */
}

static krb5_error_code
kpasswd_get_next(krb5_context context,
		 struct krb5_krbhst_data *kd,
		 krb5_krbhst_info **host)
{
    krb5_error_code ret;

    if ((kd->flags & KD_PLUGIN) == 0) {
	plugin_get_hosts(context, kd, locate_service_kpasswd);
	kd->flags |= KD_PLUGIN;
	if(get_next(kd, host))
	    return 0;
    }

    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "kpasswd_server");
	kd->flags |= KD_CONFIG;
	if(get_next(kd, host))
	    return 0;
    }

    if (kd->flags & KD_CONFIG_EXISTS) {
	_krb5_debug(context, 1,
		    "Configuration exists for realm %s, wont go to DNS",
		    kd->realm);
	return KRB5_KDC_UNREACH;
    }

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_UDP) == 0) {
	    srv_get_hosts(context, kd, "udp", "kpasswd");
	    kd->flags |= KD_SRV_UDP;
	    if(get_next(kd, host))
		return 0;
	}
	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "kpasswd");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    /* no matches -> try admin */

    if (krbhst_empty(kd)) {
	kd->flags = 0;
	kd->port  = kd->def_port;
	kd->get_next = admin_get_next;
	ret = (*kd->get_next)(context, kd, host);
	if (ret == 0)
	    (*host)->proto = krbhst_get_default_proto(kd);
	return ret;
    }

    _krb5_debug(context, 0, "No kpasswd entries found for realm %s", kd->realm);

    return KRB5_KDC_UNREACH;
}

static krb5_error_code
krb524_get_next(krb5_context context,
		struct krb5_krbhst_data *kd,
		krb5_krbhst_info **host)
{
    if ((kd->flags & KD_PLUGIN) == 0) {
	plugin_get_hosts(context, kd, locate_service_krb524);
	kd->flags |= KD_PLUGIN;
	if(get_next(kd, host))
	    return 0;
    }

    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "krb524_server");
	if(get_next(kd, host))
	    return 0;
	kd->flags |= KD_CONFIG;
    }

    if (kd->flags & KD_CONFIG_EXISTS) {
	_krb5_debug(context, 1,
		    "Configuration exists for realm %s, wont go to DNS",
		    kd->realm);
	return KRB5_KDC_UNREACH;
    }

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_UDP) == 0) {
	    srv_get_hosts(context, kd, "udp", "krb524");
	    kd->flags |= KD_SRV_UDP;
	    if(get_next(kd, host))
		return 0;
	}

	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "krb524");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    /* no matches -> try kdc */

    if (krbhst_empty(kd)) {
	kd->flags = 0;
	kd->port  = kd->def_port;
	kd->get_next = kdc_get_next;
	return (*kd->get_next)(context, kd, host);
    }

    _krb5_debug(context, 0, "No kpasswd entries found for realm %s", kd->realm);

    return KRB5_KDC_UNREACH;
}

static struct krb5_krbhst_data*
common_init(krb5_context context,
	    const char *service,
	    const char *realm,
	    int flags)
{
    struct krb5_krbhst_data *kd;

    if((kd = calloc(1, sizeof(*kd))) == NULL)
	return NULL;

    if((kd->realm = strdup(realm)) == NULL) {
	free(kd);
	return NULL;
    }

    _krb5_debug(context, 2, "Trying to find service %s for realm %s flags %x",
		service, realm, flags);

    /* For 'realms' without a . do not even think of going to DNS */
    if (!strchr(realm, '.'))
	kd->flags |= KD_CONFIG_EXISTS;

    if (flags & KRB5_KRBHST_FLAGS_LARGE_MSG)
	kd->flags |= KD_LARGE_MSG;
    kd->end = kd->index = &kd->hosts;
    return kd;
}

/*
 * initialize `handle' to look for hosts of type `type' in realm `realm'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_krbhst_init(krb5_context context,
		 const char *realm,
		 unsigned int type,
		 krb5_krbhst_handle *handle)
{
    return krb5_krbhst_init_flags(context, realm, type, 0, handle);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_krbhst_init_flags(krb5_context context,
		       const char *realm,
		       unsigned int type,
		       int flags,
		       krb5_krbhst_handle *handle)
{
    struct krb5_krbhst_data *kd;
    krb5_error_code (*next)(krb5_context, struct krb5_krbhst_data *,
			    krb5_krbhst_info **);
    int def_port;
    const char *service;

    switch(type) {
    case KRB5_KRBHST_KDC:
	next = kdc_get_next;
	def_port = ntohs(krb5_getportbyname (context, "kerberos", "udp", 88));
	service = "kdc";
	break;
    case KRB5_KRBHST_ADMIN:
	next = admin_get_next;
	def_port = ntohs(krb5_getportbyname (context, "kerberos-adm",
					     "tcp", 749));
	service = "admin";
	break;
    case KRB5_KRBHST_CHANGEPW:
	next = kpasswd_get_next;
	def_port = ntohs(krb5_getportbyname (context, "kpasswd", "udp",
					     KPASSWD_PORT));
	service = "change_password";
	break;
    case KRB5_KRBHST_KRB524:
	next = krb524_get_next;
	def_port = ntohs(krb5_getportbyname (context, "krb524", "udp", 4444));
	service = "524";
	break;
    default:
	krb5_set_error_message(context, ENOTTY,
			       N_("unknown krbhst type (%u)", ""), type);
	return ENOTTY;
    }
    if((kd = common_init(context, service, realm, flags)) == NULL)
	return ENOMEM;
    kd->get_next = next;
    kd->def_port = def_port;
    *handle = kd;
    return 0;
}

/*
 * return the next host information from `handle' in `host'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_krbhst_next(krb5_context context,
		 krb5_krbhst_handle handle,
		 krb5_krbhst_info **host)
{
    if(get_next(handle, host))
	return 0;

    return (*handle->get_next)(context, handle, host);
}

/*
 * return the next host information from `handle' as a host name
 * in `hostname' (or length `hostlen)
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_krbhst_next_as_string(krb5_context context,
			   krb5_krbhst_handle handle,
			   char *hostname,
			   size_t hostlen)
{
    krb5_error_code ret;
    krb5_krbhst_info *host;
    ret = krb5_krbhst_next(context, handle, &host);
    if(ret)
	return ret;
    return krb5_krbhst_format_string(context, host, hostname, hostlen);
}


KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_krbhst_reset(krb5_context context, krb5_krbhst_handle handle)
{
    handle->index = &handle->hosts;
}

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_krbhst_free(krb5_context context, krb5_krbhst_handle handle)
{
    krb5_krbhst_info *h, *next;

    if (handle == NULL)
	return;

    for (h = handle->hosts; h != NULL; h = next) {
	next = h->next;
	_krb5_free_krbhst_info(h);
    }

    free(handle->realm);
    free(handle);
}

/* backwards compatibility ahead */

static krb5_error_code
gethostlist(krb5_context context, const char *realm,
	    unsigned int type, char ***hostlist)
{
    krb5_error_code ret;
    int nhost = 0;
    krb5_krbhst_handle handle;
    char host[MAXHOSTNAMELEN];
    krb5_krbhst_info *hostinfo;

    ret = krb5_krbhst_init(context, realm, type, &handle);
    if (ret)
	return ret;

    while(krb5_krbhst_next(context, handle, &hostinfo) == 0)
	nhost++;
    if(nhost == 0) {
	krb5_set_error_message(context, KRB5_KDC_UNREACH,
			       N_("No KDC found for realm %s", ""), realm);
	return KRB5_KDC_UNREACH;
    }
    *hostlist = calloc(nhost + 1, sizeof(**hostlist));
    if(*hostlist == NULL) {
	krb5_krbhst_free(context, handle);
	return ENOMEM;
    }

    krb5_krbhst_reset(context, handle);
    nhost = 0;
    while(krb5_krbhst_next_as_string(context, handle,
				     host, sizeof(host)) == 0) {
	if(((*hostlist)[nhost++] = strdup(host)) == NULL) {
	    krb5_free_krbhst(context, *hostlist);
	    krb5_krbhst_free(context, handle);
	    return ENOMEM;
	}
    }
    (*hostlist)[nhost] = NULL;
    krb5_krbhst_free(context, handle);
    return 0;
}

/*
 * return an malloced list of kadmin-hosts for `realm' in `hostlist'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_krb_admin_hst (krb5_context context,
			const krb5_realm *realm,
			char ***hostlist)
{
    return gethostlist(context, *realm, KRB5_KRBHST_ADMIN, hostlist);
}

/*
 * return an malloced list of changepw-hosts for `realm' in `hostlist'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_krb_changepw_hst (krb5_context context,
			   const krb5_realm *realm,
			   char ***hostlist)
{
    return gethostlist(context, *realm, KRB5_KRBHST_CHANGEPW, hostlist);
}

/*
 * return an malloced list of 524-hosts for `realm' in `hostlist'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_krb524hst (krb5_context context,
		    const krb5_realm *realm,
		    char ***hostlist)
{
    return gethostlist(context, *realm, KRB5_KRBHST_KRB524, hostlist);
}


/*
 * return an malloced list of KDC's for `realm' in `hostlist'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_krbhst (krb5_context context,
		 const krb5_realm *realm,
		 char ***hostlist)
{
    return gethostlist(context, *realm, KRB5_KRBHST_KDC, hostlist);
}

/*
 * free all the memory allocated in `hostlist'
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_free_krbhst (krb5_context context,
		  char **hostlist)
{
    char **p;

    for (p = hostlist; *p; ++p)
	free (*p);
    free (hostlist);
    return 0;
}
@


1.7
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.6
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 2001 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d36 1
a36 2

RCSID("$KTH: krbhst.c,v 1.51 2005/05/20 09:09:42 lha Exp $");
d43 1
a43 1
    else if(strcasecmp(string, "tcp") == 0) 
d45 1
a45 1
    else if(strcasecmp(string, "http") == 0) 
d57 1
a57 1
srv_find_realm(krb5_context context, krb5_krbhst_info ***res, int *count, 
d62 2
a63 2
    struct dns_reply *r;
    struct resource_record *rr;
d73 3
a75 1
	krb5_set_error_string(context, "unknown protocol `%s'", proto);
d88 4
a91 2
    r = dns_lookup(domain, dns_type);
    if(r == NULL)
d93 1
d95 2
a96 2
    for(num_srv = 0, rr = r->head; rr; rr = rr->next) 
	if(rr->type == T_SRV)
d101 3
a103 2
	dns_free_data(r);
	krb5_set_error_string(context, "malloc: out of memory");
d107 1
a107 1
    dns_srv_order(r);
d109 2
a110 2
    for(num_srv = 0, rr = r->head; rr; rr = rr->next) 
	if(rr->type == T_SRV) {
d116 1
a116 1
		dns_free_data(r);
d126 1
a126 1
	    
d137 2
a138 2
	    
    dns_free_data(r);
d155 2
a156 1
    krb5_error_code (*get_next)(krb5_context, struct krb5_krbhst_data *, 
d182 9
d201 1
a201 1
    const char *p = spec;
d203 1
a203 1
    
d207 1
a207 1
       
d224 11
a234 1
    if(strsep_copy(&p, ":", hi->hostname, strlen(spec) + 1) < 0) {
d243 1
a243 1
    if(p != NULL) {
d256 2
a257 2
static void
free_krbhst_info(krb5_krbhst_info *hi)
d264 25
d295 2
a296 2
	if(h->proto == host->proto && 
	   h->port == host->port && 
d298 1
a298 1
	    free_krbhst_info(host);
d314 1
a314 1
    
d323 2
a324 2
krb5_error_code KRB5_LIB_FUNCTION
krb5_krbhst_format_string(krb5_context context, const krb5_krbhst_info *host, 
d359 8
a366 3
/*
 * return an `struct addrinfo *' in `ai' corresponding to the information
 * in `host'.  free:ing is handled by krb5_krbhst_free.
d369 1
a369 1
krb5_error_code KRB5_LIB_FUNCTION
d373 1
a373 3
    struct addrinfo hints;
    char portstr[NI_MAXSERV];
    int ret;
d376 5
d382 8
a389 1
	snprintf (portstr, sizeof(portstr), "%d", host->port);
d391 24
a414 2
	if (ret)
	    return krb5_eai_to_heim_errno(ret, errno);
d416 1
d418 1
a418 1
    return 0;
d434 1
a434 1
srv_get_hosts(krb5_context context, struct krb5_krbhst_data *kd, 
d437 1
d441 5
a445 2
    if (srv_find_realm(context, &res, &count, kd->realm, "SRV", proto, service,
		       kd->port))
d458 1
a458 1
config_get_hosts(krb5_context context, struct krb5_krbhst_data *kd, 
a461 1
	
d463 1
a463 1
    hostlist = krb5_config_get_strings(context, NULL, 
d466 3
d481 1
a481 1
 * `port' is the default port for the service, and `proto' the 
d486 1
a486 1
fallback_get_hosts(krb5_context context, struct krb5_krbhst_data *kd, 
d489 1
a489 1
    char *host;
d495 12
d508 1
a508 1
	asprintf(&host, "%s.%s.", serv_string, kd->realm);
d510 2
a511 2
	asprintf(&host, "%s-%d.%s.", 
		 serv_string, kd->fallback_count, kd->realm);	    
d513 1
a513 1
    if (host == NULL)
d515 1
a515 1
    
d536 2
a537 2
	memmove(hi->hostname, host, hostlen - 1);
	hi->hostname[hostlen - 1] = '\0';
d545 85
d637 7
d651 6
a656 2
    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */
d682 1
a682 1
				 kd->def_port, 
d690 2
d702 7
d716 6
a721 2
    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */
d744 2
d756 7
d770 6
a775 2
    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */
d804 3
a806 1
    return KRB5_KDC_UNREACH; /* XXX */
d814 7
d828 6
a833 2
    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */
d860 3
a862 1
    return KRB5_KDC_UNREACH; /* XXX */
d867 1
d881 7
d898 1
a898 1
krb5_error_code KRB5_LIB_FUNCTION
d907 1
a907 1
krb5_error_code KRB5_LIB_FUNCTION
d915 2
a916 2
    krb5_error_code (*get_next)(krb5_context, struct krb5_krbhst_data *, 
				krb5_krbhst_info **);
d918 1
d922 1
a922 1
	get_next = kdc_get_next;
d924 1
d927 1
a927 1
	get_next = admin_get_next;
d930 1
d933 1
a933 1
	get_next = kpasswd_get_next;
d936 1
d939 1
a939 1
	get_next = krb524_get_next;
d941 1
d944 2
a945 1
	krb5_set_error_string(context, "unknown krbhst type (%u)", type);
d948 1
a948 1
    if((kd = common_init(context, realm, flags)) == NULL)
d950 1
a950 1
    kd->get_next = get_next;
d960 1
a960 1
krb5_error_code KRB5_LIB_FUNCTION
d976 1
a976 1
krb5_error_code KRB5_LIB_FUNCTION
d991 1
a991 1
void KRB5_LIB_FUNCTION
d997 1
a997 1
void KRB5_LIB_FUNCTION
d1007 1
a1007 1
	free_krbhst_info(h);
d1017 1
a1017 1
gethostlist(krb5_context context, const char *realm, 
d1032 3
a1034 1
    if(nhost == 0)
d1036 1
d1045 1
a1045 1
    while(krb5_krbhst_next_as_string(context, handle, 
d1053 1
a1053 1
    (*hostlist)[nhost++] = NULL;
d1062 1
a1062 1
krb5_error_code KRB5_LIB_FUNCTION
d1074 1
a1074 1
krb5_error_code KRB5_LIB_FUNCTION
d1086 1
a1086 1
krb5_error_code KRB5_LIB_FUNCTION
d1099 1
a1099 1
krb5_error_code KRB5_LIB_FUNCTION
d1111 1
a1111 1
krb5_error_code KRB5_LIB_FUNCTION
@


1.5
log
@Merge with heimdal-0.6
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: krbhst.c,v 1.43.2.1 2003/04/22 15:00:38 lha Exp $");
d69 3
d88 1
a88 3
    if(r == NULL) {
	*res = NULL;
	*count = 0;
a89 1
    }
d115 1
d143 7
a149 7
#define KD_CONFIG		1
#define KD_SRV_UDP		2
#define KD_SRV_TCP		4
#define KD_SRV_HTTP		8
#define KD_FALLBACK	       16
#define KD_CONFIG_EXISTS       32

d165 13
d183 2
a184 1
parse_hostspec(krb5_context context, const char *spec, int def_port, int port)
d193 1
a193 1
    hi->proto = KRB5_KRBHST_UDP;
d261 1
a261 1
    hi = parse_hostspec(context, host, def_port, port);
d273 1
a273 1
krb5_error_code
d314 1
a314 1
krb5_error_code
d347 1
a347 1
	const char *proto, const char *service)
d352 3
a354 2
    srv_find_realm(context, &res, &count, kd->realm, "SRV", proto, service,
		   kd->port);
d457 1
a457 1
	if((kd->flags & KD_SRV_UDP) == 0) {
d480 2
a481 1
				 kd->def_port, KRB5_KRBHST_UDP);
d520 2
a521 1
				 kd->def_port, KRB5_KRBHST_UDP);
d541 1
d556 6
d572 1
a572 1
	    (*host)->proto = KRB5_KRBHST_UDP;
d624 2
a625 1
	    const char *realm)
d637 2
d647 1
a647 1
krb5_error_code
d653 10
d691 1
a691 1
    if((kd = common_init(context, realm)) == NULL)
d703 1
a703 1
krb5_error_code
d719 1
a719 1
krb5_error_code
d734 1
a734 1
void
d740 1
a740 1
void
d802 1
a802 1
krb5_error_code
d814 1
a814 1
krb5_error_code
d826 1
a826 1
krb5_error_code
d839 1
a839 1
krb5_error_code
d851 1
a851 1
krb5_error_code
@


1.4
log
@Merge 0.6rc1
@
text
@d37 1
a37 1
RCSID("$Id: krbhst.c,v 1.1.1.4 2003/05/11 02:15:57 hin Exp $");
@


1.3
log
@move the NULL too; janj+openbsd@@wenf.org
@
text
@d37 1
a37 1
RCSID("$KTH: krbhst.c,v 1.40 2001/07/19 16:57:15 assar Exp $");
d107 1
a107 1
	    size_t len;
a108 1
	    len = strlen(rr->u.srv->target);
d519 2
d545 4
a548 1
	return (*kd->get_next)(context, kd, host);
@


1.2
log
@string cleaning; parts by me, then parts by hin, then more parts by me.
since this is not a very important part of the source tree, and since it
does compile, i am dumping it in now.
@
text
@d128 1
a128 1
	    strlcpy(hi->hostname, rr->u.srv->target, len);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d37 13
a49 1
RCSID("$KTH: krbhst.c,v 1.25 2001/01/19 04:30:54 assar Exp $");
d52 3
a54 1
 * assuming that `*res' contains `*count' strings, add a copy of `string'.
d57 4
a60 2
static int
add_string(char ***res, int *count, const char *string)
d62 28
a89 1
    char **tmp = realloc(*res, (*count + 1) * sizeof(**res));
d91 8
a98 1
    if(tmp == NULL)
d100 34
a133 8
    *res = tmp;
    if(string) {
	tmp[*count] = strdup(string);
	if(tmp[*count] == NULL)
	    return ENOMEM;
    } else
	tmp[*count] = NULL;
    (*count)++;
d137 27
d165 2
a166 2
 * do a SRV lookup for `realm, proto, service' returning the result
 * in `res, count'
d169 72
d242 2
a243 2
srv_find_realm(krb5_context context, char ***res, int *count, 
	       const char *realm, const char *proto, const char *service)
d245 1
a245 5
    char domain[1024];
    char alt_domain[1024];
    krb5_error_code ret;
    struct dns_reply *r;
    struct resource_record *rr;
d247 3
a249 1
    snprintf(domain, sizeof(domain), "_%s._%s.%s.", service, proto, realm);
d251 43
a293 12
    r = dns_lookup(domain, "srv");
    if(r == NULL && context->srv_try_rfc2052) {
	snprintf(alt_domain, sizeof(alt_domain), "%s.%s.%s.", 
		 service, proto, realm);
	r = dns_lookup(alt_domain, "srv");
    }
    if(r == NULL && context->srv_try_txt)
	r = dns_lookup(domain, "txt");
    if(r == NULL && context->srv_try_rfc2052 && context->srv_try_txt)
	r = dns_lookup(alt_domain, "txt");
    if(r == NULL)
	return 0;
d295 4
a298 4
    for(rr = r->head; rr; rr = rr->next){
	if(rr->type == T_SRV){
	    char buf[1024];
	    char **tmp;
d300 14
a313 17
	    tmp = realloc(*res, (*count + 1) * sizeof(**res));
	    if (tmp == NULL)
		return ENOMEM;
	    *res = tmp;
	    snprintf (buf, sizeof(buf),
		      "%s/%s:%u",
		      proto,
		      rr->u.srv->target,
		      rr->u.srv->port);
	    ret = add_string(res, count, buf);
	    if(ret)
		return ret;
	}else if(rr->type == T_TXT) {
	    ret = add_string(res, count, rr->u.txt);
	    if(ret)
		return ret;
	}
d315 1
a315 1
    dns_free_data(r);
d319 50
d370 4
a373 3
 * lookup the servers for realm `realm', looking for the config string
 * `conf_string' in krb5.conf or for `serv_string' in SRV records.
 * return a malloc-ed list of servers in hostlist.
d377 102
a478 5
get_krbhst (krb5_context context,
	    const krb5_realm *realm,
	    const char *conf_string,
	    const char *serv_string,
	    char ***hostlist)
a479 2
    char **res, **r;
    int count;
d482 16
a497 13
    res = krb5_config_get_strings(context, NULL, 
				  "realms", *realm, conf_string, NULL);
    for(r = res, count = 0; r && *r; r++, count++);

    if(count == 0 && context->srv_lookup) {
	char *s[] = { "udp", "tcp", "http" }, **q;
	for(q = s; q < s + sizeof(s) / sizeof(s[0]); q++) {
	    ret = srv_find_realm(context, &res, &count, *realm, *q,
				 serv_string);
	    if(ret) {
		krb5_config_free_strings(res);
		return ret;
	    }
d501 5
a505 6
    if(count == 0) {
	char buf[1024];
	snprintf(buf, sizeof(buf), "kerberos.%s", *realm);
	ret = add_string(&res, &count, buf);
	if(ret) {
	    krb5_config_free_strings(res);
d507 64
d572 76
d649 5
a653 2
    add_string(&res, &count, NULL);
    *hostlist = res;
d658 100
a757 1
 * set `hostlist' to a malloced list of kadmin servers.
d765 1
a765 2
    return get_krbhst (context, realm, "admin_server", "kerberos-adm",
		       hostlist);
d769 1
a769 1
 * set `hostlist' to a malloced list of changepw servers.
d777 6
a782 1
    krb5_error_code ret;
d784 6
a789 7
    ret = get_krbhst (context, realm, "kpasswd_server", "kpasswd",
		      hostlist);
    if (ret)
	return ret;
    ret = get_krbhst (context, realm, "admin_server", "kpasswd",
		      hostlist);
    return ret;
d792 1
d794 1
a794 1
 * set `hostlist' to a malloced list of kerberos servers.
d802 1
a802 1
    return get_krbhst (context, realm, "kdc", "kerberos", hostlist);
d806 1
a806 1
 * free all memory associated with `hostlist'
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d37 1
a37 1
RCSID("$KTH: krbhst.c,v 1.26 2001/05/14 06:14:49 assar Exp $");
d44 1
a44 1
add_string(krb5_context context, char ***res, int *count, const char *string)
d48 1
a48 2
    if(tmp == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a49 1
    }
d53 1
a53 2
	if(tmp[*count] == NULL) {
	    krb5_set_error_string (context, "malloc: out of memory");
a54 1
	}
d97 1
a97 2
	    if (tmp == NULL) {
		krb5_set_error_string (context, "malloc: out of memory");
a98 1
	    }
d105 1
a105 1
	    ret = add_string(context, res, count, buf);
d109 1
a109 1
	    ret = add_string(context, res, count, rr->u.txt);
d154 1
a154 1
	ret = add_string(context, &res, &count, buf);
d160 1
a160 1
    add_string(context, &res, &count, NULL);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Kungliga Tekniska Högskolan
d37 1
a37 13
RCSID("$KTH: krbhst.c,v 1.40 2001/07/19 16:57:15 assar Exp $");

static int
string_to_proto(const char *string)
{
    if(strcasecmp(string, "udp") == 0)
	return KRB5_KRBHST_UDP;
    else if(strcasecmp(string, "tcp") == 0) 
	return KRB5_KRBHST_TCP;
    else if(strcasecmp(string, "http") == 0) 
	return KRB5_KRBHST_HTTP;
    return -1;
}
d40 1
a40 3
 * set `res' and `count' to the result of looking up SRV RR in DNS for
 * `proto', `proto', `realm' using `dns_type'.
 * if `port' != 0, force that port number
d43 2
a44 4
static krb5_error_code
srv_find_realm(krb5_context context, krb5_krbhst_info ***res, int *count, 
	       const char *realm, const char *dns_type,
	       const char *proto, const char *service, int port)
d46 1
a46 28
    char domain[1024];
    struct dns_reply *r;
    struct resource_record *rr;
    int num_srv;
    int proto_num;
    int def_port;

    proto_num = string_to_proto(proto);
    if(proto_num < 0) {
	krb5_set_error_string(context, "unknown protocol `%s'", proto);
	return EINVAL;
    }

    if(proto_num == KRB5_KRBHST_HTTP)
	def_port = ntohs(krb5_getportbyname (context, "http", "tcp", 80));
    else if(port == 0)
	def_port = ntohs(krb5_getportbyname (context, service, proto, 88));
    else
	def_port = port;

    snprintf(domain, sizeof(domain), "_%s._%s.%s.", service, proto, realm);

    r = dns_lookup(domain, dns_type);
    if(r == NULL) {
	*res = NULL;
	*count = 0;
	return KRB5_KDC_UNREACH;
    }
d48 2
a49 8
    for(num_srv = 0, rr = r->head; rr; rr = rr->next) 
	if(rr->type == T_SRV)
	    num_srv++;

    *res = malloc(num_srv * sizeof(**res));
    if(*res == NULL) {
	dns_free_data(r);
	krb5_set_error_string(context, "malloc: out of memory");
d52 6
a57 25

    dns_srv_order(r);

    for(num_srv = 0, rr = r->head; rr; rr = rr->next) 
	if(rr->type == T_SRV) {
	    krb5_krbhst_info *hi;
	    hi = calloc(1, sizeof(*hi) + strlen(rr->u.srv->target));
	    if(hi == NULL) {
		dns_free_data(r);
		while(--num_srv >= 0)
		    free((*res)[num_srv]);
		free(*res);
		return ENOMEM;
	    }
	    (*res)[num_srv++] = hi;

	    hi->proto = proto_num;
	    
	    hi->def_port = def_port;
	    if (port != 0)
		hi->port = port;
	    else
		hi->port = rr->u.srv->port;

	    strcpy(hi->hostname, rr->u.srv->target);
d59 3
a61 4

    *count = num_srv;
	    
    dns_free_data(r);
a64 27

struct krb5_krbhst_data {
    char *realm;
    unsigned int flags;
    int def_port;
    int port;			/* hardwired port number if != 0 */
#define KD_CONFIG		1
#define KD_SRV_UDP		2
#define KD_SRV_TCP		4
#define KD_SRV_HTTP		8
#define KD_FALLBACK	       16
#define KD_CONFIG_EXISTS       32

    krb5_error_code (*get_next)(krb5_context, struct krb5_krbhst_data *, 
				krb5_krbhst_info**);

    unsigned int fallback_count;

    struct krb5_krbhst_info *hosts, **index, **end;
};

static krb5_boolean
krbhst_empty(const struct krb5_krbhst_data *kd)
{
    return kd->index == &kd->hosts;
}

d66 2
a67 2
 * parse `spec' into a krb5_krbhst_info, defaulting the port to `def_port'
 * and forcing it to `port' if port != 0
a69 72
static struct krb5_krbhst_info*
parse_hostspec(krb5_context context, const char *spec, int def_port, int port)
{
    const char *p = spec;
    struct krb5_krbhst_info *hi;
    
    hi = calloc(1, sizeof(*hi) + strlen(spec));
    if(hi == NULL)
	return NULL;
       
    hi->proto = KRB5_KRBHST_UDP;

    if(strncmp(p, "http://", 7) == 0){
	hi->proto = KRB5_KRBHST_HTTP;
	p += 7;
    } else if(strncmp(p, "http/", 5) == 0) {
	hi->proto = KRB5_KRBHST_HTTP;
	p += 5;
	def_port = ntohs(krb5_getportbyname (context, "http", "tcp", 80));
    }else if(strncmp(p, "tcp/", 4) == 0){
	hi->proto = KRB5_KRBHST_TCP;
	p += 4;
    } else if(strncmp(p, "udp/", 4) == 0) {
	p += 4;
    }

    if(strsep_copy(&p, ":", hi->hostname, strlen(spec) + 1) < 0) {
	free(hi);
	return NULL;
    }
    /* get rid of trailing /, and convert to lower case */
    hi->hostname[strcspn(hi->hostname, "/")] = '\0';
    strlwr(hi->hostname);

    hi->port = hi->def_port = def_port;
    if(p != NULL) {
	char *end;
	hi->port = strtol(p, &end, 0);
	if(end == p) {
	    free(hi);
	    return NULL;
	}
    }
    if (port)
	hi->port = port;
    return hi;
}

static void
free_krbhst_info(krb5_krbhst_info *hi)
{
    if (hi->ai != NULL)
	freeaddrinfo(hi->ai);
    free(hi);
}

static void
append_host_hostinfo(struct krb5_krbhst_data *kd, struct krb5_krbhst_info *host)
{
    struct krb5_krbhst_info *h;

    for(h = kd->hosts; h; h = h->next)
	if(h->proto == host->proto && 
	   h->port == host->port && 
	   strcmp(h->hostname, host->hostname) == 0) {
	    free_krbhst_info(host);
	    return;
	}
    *kd->end = host;
    kd->end = &host->next;
}

d71 2
a72 2
append_host_string(krb5_context context, struct krb5_krbhst_data *kd,
		   const char *host, int def_port, int port)
d74 5
a78 1
    struct krb5_krbhst_info *hi;
d80 1
a80 3
    hi = parse_hostspec(context, host, def_port, port);
    if(hi == NULL)
	return ENOMEM;
d82 12
a93 3
    append_host_hostinfo(kd, hi);
    return 0;
}
d95 24
a118 37
/*
 * return a readable representation of `host' in `hostname, hostlen'
 */

krb5_error_code
krb5_krbhst_format_string(krb5_context context, const krb5_krbhst_info *host, 
			  char *hostname, size_t hostlen)
{
    const char *proto = "";
    char portstr[7] = "";
    if(host->proto == KRB5_KRBHST_TCP)
	proto = "tcp/";
    else if(host->proto == KRB5_KRBHST_HTTP)
	proto = "http://";
    if(host->port != host->def_port)
	snprintf(portstr, sizeof(portstr), ":%d", host->port);
    snprintf(hostname, hostlen, "%s%s%s", proto, host->hostname, portstr);
    return 0;
}

/*
 * create a getaddrinfo `hints' based on `proto'
 */

static void
make_hints(struct addrinfo *hints, int proto)
{
    memset(hints, 0, sizeof(*hints));
    hints->ai_family = AF_UNSPEC;
    switch(proto) {
    case KRB5_KRBHST_UDP :
	hints->ai_socktype = SOCK_DGRAM;
	break;
    case KRB5_KRBHST_HTTP :
    case KRB5_KRBHST_TCP :
	hints->ai_socktype = SOCK_STREAM;
	break;
d120 1
a120 23
}

/*
 * return an `struct addrinfo *' in `ai' corresponding to the information
 * in `host'.  free:ing is handled by krb5_krbhst_free.
 */

krb5_error_code
krb5_krbhst_get_addrinfo(krb5_context context, krb5_krbhst_info *host,
			 struct addrinfo **ai)
{
    struct addrinfo hints;
    char portstr[NI_MAXSERV];
    int ret;

    if (host->ai == NULL) {
	make_hints(&hints, host->proto);
	snprintf (portstr, sizeof(portstr), "%d", host->port);
	ret = getaddrinfo(host->hostname, portstr, &hints, &host->ai);
	if (ret)
	    return krb5_eai_to_heim_errno(ret, errno);
    }
    *ai = host->ai;
a123 50
static krb5_boolean
get_next(struct krb5_krbhst_data *kd, krb5_krbhst_info **host)
{
    struct krb5_krbhst_info *hi = *kd->index;
    if(hi != NULL) {
	*host = hi;
	kd->index = &(*kd->index)->next;
	return TRUE;
    }
    return FALSE;
}

static void
srv_get_hosts(krb5_context context, struct krb5_krbhst_data *kd, 
	const char *proto, const char *service)
{
    krb5_krbhst_info **res;
    int count, i;

    srv_find_realm(context, &res, &count, kd->realm, "SRV", proto, service,
		   kd->port);
    for(i = 0; i < count; i++)
	append_host_hostinfo(kd, res[i]);
    free(res);
}

/*
 * read the configuration for `conf_string', defaulting to kd->def_port and
 * forcing it to `kd->port' if kd->port != 0
 */

static void
config_get_hosts(krb5_context context, struct krb5_krbhst_data *kd, 
		 const char *conf_string)
{
    int i;
	
    char **hostlist;
    hostlist = krb5_config_get_strings(context, NULL, 
				       "realms", kd->realm, conf_string, NULL);

    if(hostlist == NULL)
	return;
    kd->flags |= KD_CONFIG_EXISTS;
    for(i = 0; hostlist && hostlist[i] != NULL; i++)
	append_host_string(context, kd, hostlist[i], kd->def_port, kd->port);

    krb5_config_free_strings(hostlist);
}

d125 3
a127 4
 * as a fallback, look for `serv_string.kd->realm' (typically
 * kerberos.REALM, kerberos-1.REALM, ...
 * `port' is the default port for the service, and `proto' the 
 * protocol
d131 5
a135 51
fallback_get_hosts(krb5_context context, struct krb5_krbhst_data *kd, 
		   const char *serv_string, int port, int proto)
{
    char *host;
    int ret;
    struct addrinfo *ai;
    struct addrinfo hints;
    char portstr[NI_MAXSERV];

    if(kd->fallback_count == 0)
	asprintf(&host, "%s.%s.", serv_string, kd->realm);
    else
	asprintf(&host, "%s-%d.%s.", 
		 serv_string, kd->fallback_count, kd->realm);	    

    if (host == NULL)
	return ENOMEM;
    
    make_hints(&hints, proto);
    snprintf(portstr, sizeof(portstr), "%d", port);
    ret = getaddrinfo(host, portstr, &hints, &ai);
    if (ret) {
	/* no more hosts, so we're done here */
	free(host);
	kd->flags |= KD_FALLBACK;
    } else {
	struct krb5_krbhst_info *hi;
	size_t hostlen = strlen(host);

	hi = calloc(1, sizeof(*hi) + hostlen);
	if(hi == NULL) {
	    free(host);
	    return ENOMEM;
	}

	hi->proto = proto;
	hi->port  = hi->def_port = port;
	hi->ai    = ai;
	memmove(hi->hostname, host, hostlen - 1);
	hi->hostname[hostlen - 1] = '\0';
	free(host);
	append_host_hostinfo(kd, hi);
	kd->fallback_count++;
    }
    return 0;
}

static krb5_error_code
kdc_get_next(krb5_context context,
	     struct krb5_krbhst_data *kd,
	     krb5_krbhst_info **host)
d137 2
d141 13
a153 29
    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "kdc");
	kd->flags |= KD_CONFIG;
	if(get_next(kd, host))
	    return 0;
    }

    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_UDP) == 0) {
	    srv_get_hosts(context, kd, "udp", "kerberos");
	    kd->flags |= KD_SRV_UDP;
	    if(get_next(kd, host))
		return 0;
	}

	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "kerberos");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
	if((kd->flags & KD_SRV_HTTP) == 0) {
	    srv_get_hosts(context, kd, "http", "kerberos");
	    kd->flags |= KD_SRV_HTTP;
	    if(get_next(kd, host))
		return 0;
d157 6
a162 4
    while((kd->flags & KD_FALLBACK) == 0) {
	ret = fallback_get_hosts(context, kd, "kerberos",
				 kd->def_port, KRB5_KRBHST_UDP);
	if(ret)
a163 103
	if(get_next(kd, host))
	    return 0;
    }

    return KRB5_KDC_UNREACH; /* XXX */
}

static krb5_error_code
admin_get_next(krb5_context context,
	       struct krb5_krbhst_data *kd,
	       krb5_krbhst_info **host)
{
    krb5_error_code ret;

    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "admin_server");
	kd->flags |= KD_CONFIG;
	if(get_next(kd, host))
	    return 0;
    }

    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "kerberos-adm");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    if (krbhst_empty(kd)
	&& (kd->flags & KD_FALLBACK) == 0) {
	ret = fallback_get_hosts(context, kd, "kerberos",
				 kd->def_port, KRB5_KRBHST_UDP);
	if(ret)
	    return ret;
	kd->flags |= KD_FALLBACK;
	if(get_next(kd, host))
	    return 0;
    }

    return KRB5_KDC_UNREACH;	/* XXX */
}

static krb5_error_code
kpasswd_get_next(krb5_context context,
		 struct krb5_krbhst_data *kd,
		 krb5_krbhst_info **host)
{
    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "kpasswd_server");
	if(get_next(kd, host))
	    return 0;
    }

    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_UDP) == 0) {
	    srv_get_hosts(context, kd, "udp", "kpasswd");
	    kd->flags |= KD_SRV_UDP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    /* no matches -> try admin */

    if (krbhst_empty(kd)) {
	kd->flags = 0;
	kd->port  = kd->def_port;
	kd->get_next = admin_get_next;
	return (*kd->get_next)(context, kd, host);
    }

    return KRB5_KDC_UNREACH; /* XXX */
}

static krb5_error_code
krb524_get_next(krb5_context context,
		struct krb5_krbhst_data *kd,
		krb5_krbhst_info **host)
{
    if((kd->flags & KD_CONFIG) == 0) {
	config_get_hosts(context, kd, "krb524_server");
	if(get_next(kd, host))
	    return 0;
	kd->flags |= KD_CONFIG;
    }

    if (kd->flags & KD_CONFIG_EXISTS)
	return KRB5_KDC_UNREACH; /* XXX */

    if(context->srv_lookup) {
	if((kd->flags & KD_SRV_UDP) == 0) {
	    srv_get_hosts(context, kd, "udp", "krb524");
	    kd->flags |= KD_SRV_UDP;
	    if(get_next(kd, host))
		return 0;
a164 76

	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "krb524");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
    }

    /* no matches -> try kdc */

    if (krbhst_empty(kd)) {
	kd->flags = 0;
	kd->port  = kd->def_port;
	kd->get_next = kdc_get_next;
	return (*kd->get_next)(context, kd, host);
    }

    return KRB5_KDC_UNREACH; /* XXX */
}

static struct krb5_krbhst_data*
common_init(krb5_context context,
	    const char *realm)
{
    struct krb5_krbhst_data *kd;

    if((kd = calloc(1, sizeof(*kd))) == NULL)
	return NULL;

    if((kd->realm = strdup(realm)) == NULL) {
	free(kd);
	return NULL;
    }

    kd->end = kd->index = &kd->hosts;
    return kd;
}

/*
 * initialize `handle' to look for hosts of type `type' in realm `realm'
 */

krb5_error_code
krb5_krbhst_init(krb5_context context,
		 const char *realm,
		 unsigned int type,
		 krb5_krbhst_handle *handle)
{
    struct krb5_krbhst_data *kd;
    krb5_error_code (*get_next)(krb5_context, struct krb5_krbhst_data *, 
				krb5_krbhst_info **);
    int def_port;

    switch(type) {
    case KRB5_KRBHST_KDC:
	get_next = kdc_get_next;
	def_port = ntohs(krb5_getportbyname (context, "kerberos", "udp", 88));
	break;
    case KRB5_KRBHST_ADMIN:
	get_next = admin_get_next;
	def_port = ntohs(krb5_getportbyname (context, "kerberos-adm",
					     "tcp", 749));
	break;
    case KRB5_KRBHST_CHANGEPW:
	get_next = kpasswd_get_next;
	def_port = ntohs(krb5_getportbyname (context, "kpasswd", "udp",
					     KPASSWD_PORT));
	break;
    case KRB5_KRBHST_KRB524:
	get_next = krb524_get_next;
	def_port = ntohs(krb5_getportbyname (context, "krb524", "udp", 4444));
	break;
    default:
	krb5_set_error_string(context, "unknown krbhst type (%u)", type);
	return ENOTTY;
d166 2
a167 5
    if((kd = common_init(context, realm)) == NULL)
	return ENOMEM;
    kd->get_next = get_next;
    kd->def_port = def_port;
    *handle = kd;
d172 1
a172 100
 * return the next host information from `handle' in `host'
 */

krb5_error_code
krb5_krbhst_next(krb5_context context,
		 krb5_krbhst_handle handle,
		 krb5_krbhst_info **host)
{
    if(get_next(handle, host))
	return 0;

    return (*handle->get_next)(context, handle, host);
}

/*
 * return the next host information from `handle' as a host name
 * in `hostname' (or length `hostlen)
 */

krb5_error_code
krb5_krbhst_next_as_string(krb5_context context,
			   krb5_krbhst_handle handle,
			   char *hostname,
			   size_t hostlen)
{
    krb5_error_code ret;
    krb5_krbhst_info *host;
    ret = krb5_krbhst_next(context, handle, &host);
    if(ret)
	return ret;
    return krb5_krbhst_format_string(context, host, hostname, hostlen);
}


void
krb5_krbhst_reset(krb5_context context, krb5_krbhst_handle handle)
{
    handle->index = &handle->hosts;
}

void
krb5_krbhst_free(krb5_context context, krb5_krbhst_handle handle)
{
    krb5_krbhst_info *h, *next;

    if (handle == NULL)
	return;

    for (h = handle->hosts; h != NULL; h = next) {
	next = h->next;
	free_krbhst_info(h);
    }

    free(handle->realm);
    free(handle);
}

/* backwards compatibility ahead */

static krb5_error_code
gethostlist(krb5_context context, const char *realm, 
	    unsigned int type, char ***hostlist)
{
    krb5_error_code ret;
    int nhost = 0;
    krb5_krbhst_handle handle;
    char host[MAXHOSTNAMELEN];
    krb5_krbhst_info *hostinfo;

    ret = krb5_krbhst_init(context, realm, type, &handle);
    if (ret)
	return ret;

    while(krb5_krbhst_next(context, handle, &hostinfo) == 0)
	nhost++;
    if(nhost == 0)
	return KRB5_KDC_UNREACH;
    *hostlist = calloc(nhost + 1, sizeof(**hostlist));
    if(*hostlist == NULL) {
	krb5_krbhst_free(context, handle);
	return ENOMEM;
    }

    krb5_krbhst_reset(context, handle);
    nhost = 0;
    while(krb5_krbhst_next_as_string(context, handle, 
				     host, sizeof(host)) == 0) {
	if(((*hostlist)[nhost++] = strdup(host)) == NULL) {
	    krb5_free_krbhst(context, *hostlist);
	    krb5_krbhst_free(context, handle);
	    return ENOMEM;
	}
    }
    (*hostlist)[nhost++] = NULL;
    krb5_krbhst_free(context, handle);
    return 0;
}

/*
 * return an malloced list of kadmin-hosts for `realm' in `hostlist'
d180 2
a181 1
    return gethostlist(context, *realm, KRB5_KRBHST_ADMIN, hostlist);
d185 1
a185 1
 * return an malloced list of changepw-hosts for `realm' in `hostlist'
d193 1
a193 2
    return gethostlist(context, *realm, KRB5_KRBHST_CHANGEPW, hostlist);
}
d195 7
a201 10
/*
 * return an malloced list of 524-hosts for `realm' in `hostlist'
 */

krb5_error_code
krb5_get_krb524hst (krb5_context context,
		    const krb5_realm *realm,
		    char ***hostlist)
{
    return gethostlist(context, *realm, KRB5_KRBHST_KRB524, hostlist);
a203 1

d205 1
a205 1
 * return an malloced list of KDC's for `realm' in `hostlist'
d213 1
a213 1
    return gethostlist(context, *realm, KRB5_KRBHST_KDC, hostlist);
d217 1
a217 1
 * free all the memory allocated in `hostlist'
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d37 1
a37 1
RCSID("$Id$");
d107 1
a107 3
	    size_t len = strlen(rr->u.srv->target);

	    hi = calloc(1, sizeof(*hi) + len);
d125 1
a125 1
	    strlcpy(hi->hostname, rr->u.srv->target, len + 1);
a516 2
    krb5_error_code ret;

d541 1
a541 4
	ret = (*kd->get_next)(context, kd, host);
	if (ret == 0)
	    (*host)->proto = KRB5_KRBHST_UDP;
	return ret;
@


1.1.1.5
log
@Import of heimdal-0.6, released earlier today.
@
text
@d37 1
a37 1
RCSID("$KTH: krbhst.c,v 1.43.2.1 2003/04/22 15:00:38 lha Exp $");
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 2001 - 2003 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: krbhst.c,v 1.51 2005/05/20 09:09:42 lha Exp $");
a68 3
    *res = NULL;
    *count = 0;

d85 3
a87 1
    if(r == NULL)
d89 1
a114 1
		*res = NULL;
d142 7
a148 7
#define KD_CONFIG		 1
#define KD_SRV_UDP		 2
#define KD_SRV_TCP		 4
#define KD_SRV_HTTP		 8
#define KD_FALLBACK		16
#define KD_CONFIG_EXISTS	32
#define KD_LARGE_MSG		64
a163 13
 * Return the default protocol for the `kd' (either TCP or UDP)
 */

static int
krbhst_get_default_proto(struct krb5_krbhst_data *kd)
{
    if (kd->flags & KD_LARGE_MSG)
	return KRB5_KRBHST_TCP;
    return KRB5_KRBHST_UDP;
}


/*
d169 1
a169 2
parse_hostspec(krb5_context context, struct krb5_krbhst_data *kd,
	       const char *spec, int def_port, int port)
d178 1
a178 1
    hi->proto = krbhst_get_default_proto(kd);
d246 1
a246 1
    hi = parse_hostspec(context, kd, host, def_port, port);
d258 1
a258 1
krb5_error_code KRB5_LIB_FUNCTION
d299 1
a299 1
krb5_error_code KRB5_LIB_FUNCTION
d332 1
a332 1
	      const char *proto, const char *service)
d337 2
a338 3
    if (srv_find_realm(context, &res, &count, kd->realm, "SRV", proto, service,
		       kd->port))
	return;
d441 1
a441 1
	if((kd->flags & KD_SRV_UDP) == 0 && (kd->flags & KD_LARGE_MSG) == 0) {
d464 1
a464 2
				 kd->def_port, 
				 krbhst_get_default_proto(kd));
d503 1
a503 2
				 kd->def_port,
				 krbhst_get_default_proto(kd));
a522 1
	kd->flags |= KD_CONFIG;
a536 6
	if((kd->flags & KD_SRV_TCP) == 0) {
	    srv_get_hosts(context, kd, "tcp", "kpasswd");
	    kd->flags |= KD_SRV_TCP;
	    if(get_next(kd, host))
		return 0;
	}
d547 1
a547 1
	    (*host)->proto = krbhst_get_default_proto(kd);
d599 1
a599 2
	    const char *realm,
	    int flags)
a610 2
    if (flags & KRB5_KRBHST_FLAGS_LARGE_MSG)
	kd->flags |= KD_LARGE_MSG;
d619 1
a619 1
krb5_error_code KRB5_LIB_FUNCTION
a624 10
    return krb5_krbhst_init_flags(context, realm, type, 0, handle);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_krbhst_init_flags(krb5_context context,
		       const char *realm,
		       unsigned int type,
		       int flags,
		       krb5_krbhst_handle *handle)
{
d653 1
a653 1
    if((kd = common_init(context, realm, flags)) == NULL)
d665 1
a665 1
krb5_error_code KRB5_LIB_FUNCTION
d681 1
a681 1
krb5_error_code KRB5_LIB_FUNCTION
d696 1
a696 1
void KRB5_LIB_FUNCTION
d702 1
a702 1
void KRB5_LIB_FUNCTION
d764 1
a764 1
krb5_error_code KRB5_LIB_FUNCTION
d776 1
a776 1
krb5_error_code KRB5_LIB_FUNCTION
d788 1
a788 1
krb5_error_code KRB5_LIB_FUNCTION
d801 1
a801 1
krb5_error_code KRB5_LIB_FUNCTION
d813 1
a813 1
krb5_error_code KRB5_LIB_FUNCTION
@


