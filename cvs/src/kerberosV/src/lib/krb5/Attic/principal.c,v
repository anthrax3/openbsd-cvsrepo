head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.26
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.24
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.22
	OPENBSD_5_0:1.2.0.20
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.18
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.16
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.6
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.32;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.56;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.56;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.24.37;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.36;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.58;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.37;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.33.29;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2007 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * @@page krb5_principal_intro The principal handing functions.
 *
 * A Kerberos principal is a email address looking string that
 * contains to parts separeted by a @@.  The later part is the kerbero
 * realm the principal belongs to and the former is a list of 0 or
 * more components. For example
 * @@verbatim
lha@@SU.SE
host/hummel.it.su.se@@SU.SE
host/admin@@H5L.ORG
@@endverbatim
 *
 * See the library functions here: @@ref krb5_principal
 */

#include "krb5_locl.h"
#ifdef HAVE_RES_SEARCH
#define USE_RESOLVER
#endif
#ifdef HAVE_ARPA_NAMESER_H
#include <arpa/nameser.h>
#endif
#include <fnmatch.h>
#include "resolve.h"

#define princ_num_comp(P) ((P)->name.name_string.len)
#define princ_type(P) ((P)->name.name_type)
#define princ_comp(P) ((P)->name.name_string.val)
#define princ_ncomp(P, N) ((P)->name.name_string.val[(N)])
#define princ_realm(P) ((P)->realm)

/**
 * Frees a Kerberos principal allocated by the library with
 * krb5_parse_name(), krb5_make_principal() or any other related
 * principal functions.
 *
 * @@param context A Kerberos context.
 * @@param p a principal to free.
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_free_principal(krb5_context context,
		    krb5_principal p)
{
    if(p){
	free_Principal(p);
	free(p);
    }
}

/**
 * Set the type of the principal
 *
 * @@param context A Kerberos context.
 * @@param principal principal to set the type for
 * @@param type the new type
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_principal_set_type(krb5_context context,
			krb5_principal principal,
			int type)
{
    princ_type(principal) = type;
}

/**
 * Get the type of the principal
 *
 * @@param context A Kerberos context.
 * @@param principal principal to get the type for
 *
 * @@return the type of principal
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_principal_get_type(krb5_context context,
			krb5_const_principal principal)
{
    return princ_type(principal);
}

/**
 * Get the realm of the principal
 *
 * @@param context A Kerberos context.
 * @@param principal principal to get the realm for
 *
 * @@return realm of the principal, don't free or use after krb5_principal is freed
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION const char* KRB5_LIB_CALL
krb5_principal_get_realm(krb5_context context,
			 krb5_const_principal principal)
{
    return princ_realm(principal);
}

KRB5_LIB_FUNCTION const char* KRB5_LIB_CALL
krb5_principal_get_comp_string(krb5_context context,
			       krb5_const_principal principal,
			       unsigned int component)
{
    if(component >= princ_num_comp(principal))
       return NULL;
    return princ_ncomp(principal, component);
}

/**
 * Get number of component is principal.
 *
 * @@param context Kerberos 5 context
 * @@param principal principal to query
 *
 * @@return number of components in string
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION unsigned int KRB5_LIB_CALL
krb5_principal_get_num_comp(krb5_context context,
			    krb5_const_principal principal)
{
    return princ_num_comp(principal);
}

/**
 * Parse a name into a krb5_principal structure, flags controls the behavior.
 *
 * @@param context Kerberos 5 context
 * @@param name name to parse into a Kerberos principal
 * @@param flags flags to control the behavior
 * @@param principal returned principal, free with krb5_free_principal().
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_parse_name_flags(krb5_context context,
		      const char *name,
		      int flags,
		      krb5_principal *principal)
{
    krb5_error_code ret;
    heim_general_string *comp;
    heim_general_string realm = NULL;
    int ncomp;

    const char *p;
    char *q;
    char *s;
    char *start;

    int n;
    char c;
    int got_realm = 0;
    int first_at = 1;
    int enterprise = (flags & KRB5_PRINCIPAL_PARSE_ENTERPRISE);

    *principal = NULL;

#define RFLAGS (KRB5_PRINCIPAL_PARSE_NO_REALM|KRB5_PRINCIPAL_PARSE_REQUIRE_REALM)

    if ((flags & RFLAGS) == RFLAGS) {
	krb5_set_error_message(context, KRB5_ERR_NO_SERVICE,
			       N_("Can't require both realm and "
				  "no realm at the same time", ""));
	return KRB5_ERR_NO_SERVICE;
    }
#undef RFLAGS

    /* count number of component,
     * enterprise names only have one component
     */
    ncomp = 1;
    if (!enterprise) {
	for(p = name; *p; p++){
	    if(*p=='\\'){
		if(!p[1]) {
		    krb5_set_error_message(context, KRB5_PARSE_MALFORMED,
					   N_("trailing \\ in principal name", ""));
		    return KRB5_PARSE_MALFORMED;
		}
		p++;
	    } else if(*p == '/')
		ncomp++;
	    else if(*p == '@@')
		break;
	}
    }
    comp = calloc(ncomp, sizeof(*comp));
    if (comp == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    n = 0;
    p = start = q = s = strdup(name);
    if (start == NULL) {
	free (comp);
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    while(*p){
	c = *p++;
	if(c == '\\'){
	    c = *p++;
	    if(c == 'n')
		c = '\n';
	    else if(c == 't')
		c = '\t';
	    else if(c == 'b')
		c = '\b';
	    else if(c == '0')
		c = '\0';
	    else if(c == '\0') {
		ret = KRB5_PARSE_MALFORMED;
		krb5_set_error_message(context, ret,
				       N_("trailing \\ in principal name", ""));
		goto exit;
	    }
	}else if(enterprise && first_at) {
	    if (c == '@@')
		first_at = 0;
	}else if((c == '/' && !enterprise) || c == '@@'){
	    if(got_realm){
		ret = KRB5_PARSE_MALFORMED;
		krb5_set_error_message(context, ret,
				       N_("part after realm in principal name", ""));
		goto exit;
	    }else{
		comp[n] = malloc(q - start + 1);
		if (comp[n] == NULL) {
		    ret = ENOMEM;
		    krb5_set_error_message(context, ret,
					   N_("malloc: out of memory", ""));
		    goto exit;
		}
		memcpy(comp[n], start, q - start);
		comp[n][q - start] = 0;
		n++;
	    }
	    if(c == '@@')
		got_realm = 1;
	    start = q;
	    continue;
	}
	if(got_realm && (c == '/' || c == '\0')) {
	    ret = KRB5_PARSE_MALFORMED;
	    krb5_set_error_message(context, ret,
				   N_("part after realm in principal name", ""));
	    goto exit;
	}
	*q++ = c;
    }
    if(got_realm){
	if (flags & KRB5_PRINCIPAL_PARSE_NO_REALM) {
	    ret = KRB5_PARSE_MALFORMED;
	    krb5_set_error_message(context, ret,
				   N_("realm found in 'short' principal "
				      "expected to be without one", ""));
	    goto exit;
	}
	realm = malloc(q - start + 1);
	if (realm == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret,
				   N_("malloc: out of memory", ""));
	    goto exit;
	}
	memcpy(realm, start, q - start);
	realm[q - start] = 0;
    }else{
	if (flags & KRB5_PRINCIPAL_PARSE_REQUIRE_REALM) {
	    ret = KRB5_PARSE_MALFORMED;
	    krb5_set_error_message(context, ret,
				   N_("realm NOT found in principal "
				      "expected to be with one", ""));
	    goto exit;
	} else if (flags & KRB5_PRINCIPAL_PARSE_NO_REALM) {
	    realm = NULL;
	} else {
	    ret = krb5_get_default_realm (context, &realm);
	    if (ret)
		goto exit;
	}

	comp[n] = malloc(q - start + 1);
	if (comp[n] == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret,
				   N_("malloc: out of memory", ""));
	    goto exit;
	}
	memcpy(comp[n], start, q - start);
	comp[n][q - start] = 0;
	n++;
    }
    *principal = malloc(sizeof(**principal));
    if (*principal == NULL) {
	ret = ENOMEM;
	krb5_set_error_message(context, ret,
			       N_("malloc: out of memory", ""));
	goto exit;
    }
    if (enterprise)
	(*principal)->name.name_type = KRB5_NT_ENTERPRISE_PRINCIPAL;
    else
	(*principal)->name.name_type = KRB5_NT_PRINCIPAL;
    (*principal)->name.name_string.val = comp;
    princ_num_comp(*principal) = n;
    (*principal)->realm = realm;
    free(s);
    return 0;
exit:
    while(n>0){
	free(comp[--n]);
    }
    free(comp);
    free(realm);
    free(s);
    return ret;
}

/**
 * Parse a name into a krb5_principal structure
 *
 * @@param context Kerberos 5 context
 * @@param name name to parse into a Kerberos principal
 * @@param principal returned principal, free with krb5_free_principal().
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_parse_name(krb5_context context,
		const char *name,
		krb5_principal *principal)
{
    return krb5_parse_name_flags(context, name, 0, principal);
}

static const char quotable_chars[] = " \n\t\b\\/@@";
static const char replace_chars[] = " ntb\\/@@";
static const char nq_chars[] = "    \\/@@";

#define add_char(BASE, INDEX, LEN, C) do { if((INDEX) < (LEN)) (BASE)[(INDEX)++] = (C); }while(0);

static size_t
quote_string(const char *s, char *out, size_t idx, size_t len, int display)
{
    const char *p, *q;
    for(p = s; *p && idx < len; p++){
	q = strchr(quotable_chars, *p);
	if (q && display) {
	    add_char(out, idx, len, replace_chars[q - quotable_chars]);
	} else if (q) {
	    add_char(out, idx, len, '\\');
	    add_char(out, idx, len, replace_chars[q - quotable_chars]);
	}else
	    add_char(out, idx, len, *p);
    }
    if(idx < len)
	out[idx] = '\0';
    return idx;
}


static krb5_error_code
unparse_name_fixed(krb5_context context,
		   krb5_const_principal principal,
		   char *name,
		   size_t len,
		   int flags)
{
    size_t idx = 0;
    size_t i;
    int short_form = (flags & KRB5_PRINCIPAL_UNPARSE_SHORT) != 0;
    int no_realm = (flags & KRB5_PRINCIPAL_UNPARSE_NO_REALM) != 0;
    int display = (flags & KRB5_PRINCIPAL_UNPARSE_DISPLAY) != 0;

    if (!no_realm && princ_realm(principal) == NULL) {
	krb5_set_error_message(context, ERANGE,
			       N_("Realm missing from principal, "
				  "can't unparse", ""));
	return ERANGE;
    }

    for(i = 0; i < princ_num_comp(principal); i++){
	if(i)
	    add_char(name, idx, len, '/');
	idx = quote_string(princ_ncomp(principal, i), name, idx, len, display);
	if(idx == len) {
	    krb5_set_error_message(context, ERANGE,
				   N_("Out of space printing principal", ""));
	    return ERANGE;
	}
    }
    /* add realm if different from default realm */
    if(short_form && !no_realm) {
	krb5_realm r;
	krb5_error_code ret;
	ret = krb5_get_default_realm(context, &r);
	if(ret)
	    return ret;
	if(strcmp(princ_realm(principal), r) != 0)
	    short_form = 0;
	free(r);
    }
    if(!short_form && !no_realm) {
	add_char(name, idx, len, '@@');
	idx = quote_string(princ_realm(principal), name, idx, len, display);
	if(idx == len) {
	    krb5_set_error_message(context, ERANGE,
				   N_("Out of space printing "
				      "realm of principal", ""));
	    return ERANGE;
	}
    }
    return 0;
}

/**
 * Unparse the principal name to a fixed buffer
 *
 * @@param context A Kerberos context.
 * @@param principal principal to unparse
 * @@param name buffer to write name to
 * @@param len length of buffer
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_unparse_name_fixed(krb5_context context,
			krb5_const_principal principal,
			char *name,
			size_t len)
{
    return unparse_name_fixed(context, principal, name, len, 0);
}

/**
 * Unparse the principal name to a fixed buffer. The realm is skipped
 * if its a default realm.
 *
 * @@param context A Kerberos context.
 * @@param principal principal to unparse
 * @@param name buffer to write name to
 * @@param len length of buffer
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_unparse_name_fixed_short(krb5_context context,
			      krb5_const_principal principal,
			      char *name,
			      size_t len)
{
    return unparse_name_fixed(context, principal, name, len,
			      KRB5_PRINCIPAL_UNPARSE_SHORT);
}

/**
 * Unparse the principal name with unparse flags to a fixed buffer.
 *
 * @@param context A Kerberos context.
 * @@param principal principal to unparse
 * @@param flags unparse flags
 * @@param name buffer to write name to
 * @@param len length of buffer
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_unparse_name_fixed_flags(krb5_context context,
			      krb5_const_principal principal,
			      int flags,
			      char *name,
			      size_t len)
{
    return unparse_name_fixed(context, principal, name, len, flags);
}

static krb5_error_code
unparse_name(krb5_context context,
	     krb5_const_principal principal,
	     char **name,
	     int flags)
{
    size_t len = 0, plen;
    size_t i;
    krb5_error_code ret;
    /* count length */
    if (princ_realm(principal)) {
	plen = strlen(princ_realm(principal));

	if(strcspn(princ_realm(principal), quotable_chars) == plen)
	    len += plen;
	else
	    len += 2*plen;
	len++; /* '@@' */
    }
    for(i = 0; i < princ_num_comp(principal); i++){
	plen = strlen(princ_ncomp(principal, i));
	if(strcspn(princ_ncomp(principal, i), quotable_chars) == plen)
	    len += plen;
	else
	    len += 2*plen;
	len++;
    }
    len++; /* '\0' */
    *name = malloc(len);
    if(*name == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    ret = unparse_name_fixed(context, principal, *name, len, flags);
    if(ret) {
	free(*name);
	*name = NULL;
    }
    return ret;
}

/**
 * Unparse the Kerberos name into a string
 *
 * @@param context Kerberos 5 context
 * @@param principal principal to query
 * @@param name resulting string, free with krb5_xfree()
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_unparse_name(krb5_context context,
		  krb5_const_principal principal,
		  char **name)
{
    return unparse_name(context, principal, name, 0);
}

/**
 * Unparse the Kerberos name into a string
 *
 * @@param context Kerberos 5 context
 * @@param principal principal to query
 * @@param flags flag to determine the behavior
 * @@param name resulting string, free with krb5_xfree()
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_unparse_name_flags(krb5_context context,
			krb5_const_principal principal,
			int flags,
			char **name)
{
    return unparse_name(context, principal, name, flags);
}

/**
 * Unparse the principal name to a allocated buffer. The realm is
 * skipped if its a default realm.
 *
 * @@param context A Kerberos context.
 * @@param principal principal to unparse
 * @@param name returned buffer, free with krb5_xfree()
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_unparse_name_short(krb5_context context,
			krb5_const_principal principal,
			char **name)
{
    return unparse_name(context, principal, name, KRB5_PRINCIPAL_UNPARSE_SHORT);
}

/**
 * Set a new realm for a principal, and as a side-effect free the
 * previous realm.
 *
 * @@param context A Kerberos context.
 * @@param principal principal set the realm for
 * @@param realm the new realm to set
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_principal_set_realm(krb5_context context,
			 krb5_principal principal,
			 krb5_const_realm realm)
{
    if (princ_realm(principal))
	free(princ_realm(principal));

    princ_realm(principal) = strdup(realm);
    if (princ_realm(principal) == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    return 0;
}

#ifndef HEIMDAL_SMALLER
/**
 * Build a principal using vararg style building
 *
 * @@param context A Kerberos context.
 * @@param principal returned principal
 * @@param rlen length of realm
 * @@param realm realm name
 * @@param ... a list of components ended with NULL.
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_build_principal(krb5_context context,
		     krb5_principal *principal,
		     int rlen,
		     krb5_const_realm realm,
		     ...)
{
    krb5_error_code ret;
    va_list ap;
    va_start(ap, realm);
    ret = krb5_build_principal_va(context, principal, rlen, realm, ap);
    va_end(ap);
    return ret;
}
#endif

/**
 * Build a principal using vararg style building
 *
 * @@param context A Kerberos context.
 * @@param principal returned principal
 * @@param realm realm name
 * @@param ... a list of components ended with NULL.
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_make_principal(krb5_context context,
		    krb5_principal *principal,
		    krb5_const_realm realm,
		    ...)
{
    krb5_error_code ret;
    krb5_realm r = NULL;
    va_list ap;
    if(realm == NULL) {
	ret = krb5_get_default_realm(context, &r);
	if(ret)
	    return ret;
	realm = r;
    }
    va_start(ap, realm);
    ret = krb5_build_principal_va(context, principal, strlen(realm), realm, ap);
    va_end(ap);
    if(r)
	free(r);
    return ret;
}

static krb5_error_code
append_component(krb5_context context, krb5_principal p,
		 const char *comp,
		 size_t comp_len)
{
    heim_general_string *tmp;
    size_t len = princ_num_comp(p);

    tmp = realloc(princ_comp(p), (len + 1) * sizeof(*tmp));
    if(tmp == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    princ_comp(p) = tmp;
    princ_ncomp(p, len) = malloc(comp_len + 1);
    if (princ_ncomp(p, len) == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy (princ_ncomp(p, len), comp, comp_len);
    princ_ncomp(p, len)[comp_len] = '\0';
    princ_num_comp(p)++;
    return 0;
}

static void
va_ext_princ(krb5_context context, krb5_principal p, va_list ap)
{
    while(1){
	const char *s;
	int len;
	len = va_arg(ap, int);
	if(len == 0)
	    break;
	s = va_arg(ap, const char*);
	append_component(context, p, s, len);
    }
}

static void
va_princ(krb5_context context, krb5_principal p, va_list ap)
{
    while(1){
	const char *s;
	s = va_arg(ap, const char*);
	if(s == NULL)
	    break;
	append_component(context, p, s, strlen(s));
    }
}

static krb5_error_code
build_principal(krb5_context context,
		krb5_principal *principal,
		int rlen,
		krb5_const_realm realm,
		void (*func)(krb5_context, krb5_principal, va_list),
		va_list ap)
{
    krb5_principal p;

    p = calloc(1, sizeof(*p));
    if (p == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    princ_type(p) = KRB5_NT_PRINCIPAL;

    princ_realm(p) = strdup(realm);
    if(p->realm == NULL){
	free(p);
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    (*func)(context, p, ap);
    *principal = p;
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_build_principal_va(krb5_context context,
			krb5_principal *principal,
			int rlen,
			krb5_const_realm realm,
			va_list ap)
{
    return build_principal(context, principal, rlen, realm, va_princ, ap);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_build_principal_va_ext(krb5_context context,
			    krb5_principal *principal,
			    int rlen,
			    krb5_const_realm realm,
			    va_list ap)
{
    return build_principal(context, principal, rlen, realm, va_ext_princ, ap);
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_build_principal_ext(krb5_context context,
			 krb5_principal *principal,
			 int rlen,
			 krb5_const_realm realm,
			 ...)
{
    krb5_error_code ret;
    va_list ap;
    va_start(ap, realm);
    ret = krb5_build_principal_va_ext(context, principal, rlen, realm, ap);
    va_end(ap);
    return ret;
}

/**
 * Copy a principal
 *
 * @@param context A Kerberos context.
 * @@param inprinc principal to copy
 * @@param outprinc copied principal, free with krb5_free_principal()
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_copy_principal(krb5_context context,
		    krb5_const_principal inprinc,
		    krb5_principal *outprinc)
{
    krb5_principal p = malloc(sizeof(*p));
    if (p == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    if(copy_Principal(inprinc, p)) {
	free(p);
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    *outprinc = p;
    return 0;
}

/**
 * Return TRUE iff princ1 == princ2 (without considering the realm)
 *
 * @@param context Kerberos 5 context
 * @@param princ1 first principal to compare
 * @@param princ2 second principal to compare
 *
 * @@return non zero if equal, 0 if not
 *
 * @@ingroup krb5_principal
 * @@see krb5_principal_compare()
 * @@see krb5_realm_compare()
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_principal_compare_any_realm(krb5_context context,
				 krb5_const_principal princ1,
				 krb5_const_principal princ2)
{
    size_t i;
    if(princ_num_comp(princ1) != princ_num_comp(princ2))
	return FALSE;
    for(i = 0; i < princ_num_comp(princ1); i++){
	if(strcmp(princ_ncomp(princ1, i), princ_ncomp(princ2, i)) != 0)
	    return FALSE;
    }
    return TRUE;
}

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
_krb5_principal_compare_PrincipalName(krb5_context context,
				      krb5_const_principal princ1,
				      PrincipalName *princ2)
{
    size_t i;
    if (princ_num_comp(princ1) != princ2->name_string.len)
	return FALSE;
    for(i = 0; i < princ_num_comp(princ1); i++){
	if(strcmp(princ_ncomp(princ1, i), princ2->name_string.val[i]) != 0)
	    return FALSE;
    }
    return TRUE;
}


/**
 * Compares the two principals, including realm of the principals and returns
 * TRUE if they are the same and FALSE if not.
 *
 * @@param context Kerberos 5 context
 * @@param princ1 first principal to compare
 * @@param princ2 second principal to compare
 *
 * @@ingroup krb5_principal
 * @@see krb5_principal_compare_any_realm()
 * @@see krb5_realm_compare()
 */

/*
 * return TRUE iff princ1 == princ2
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_principal_compare(krb5_context context,
		       krb5_const_principal princ1,
		       krb5_const_principal princ2)
{
    if(!krb5_realm_compare(context, princ1, princ2))
	return FALSE;
    return krb5_principal_compare_any_realm(context, princ1, princ2);
}

/**
 * return TRUE iff realm(princ1) == realm(princ2)
 *
 * @@param context Kerberos 5 context
 * @@param princ1 first principal to compare
 * @@param princ2 second principal to compare
 *
 * @@ingroup krb5_principal
 * @@see krb5_principal_compare_any_realm()
 * @@see krb5_principal_compare()
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_realm_compare(krb5_context context,
		   krb5_const_principal princ1,
		   krb5_const_principal princ2)
{
    return strcmp(princ_realm(princ1), princ_realm(princ2)) == 0;
}

/**
 * return TRUE iff princ matches pattern
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_principal_match(krb5_context context,
		     krb5_const_principal princ,
		     krb5_const_principal pattern)
{
    size_t i;
    if(princ_num_comp(princ) != princ_num_comp(pattern))
	return FALSE;
    if(fnmatch(princ_realm(pattern), princ_realm(princ), 0) != 0)
	return FALSE;
    for(i = 0; i < princ_num_comp(princ); i++){
	if(fnmatch(princ_ncomp(pattern, i), princ_ncomp(princ, i), 0) != 0)
	    return FALSE;
    }
    return TRUE;
}

/**
 * Create a principal for the service running on hostname. If
 * KRB5_NT_SRV_HST is used, the hostname is canonization using DNS (or
 * some other service), this is potentially insecure.
 *
 * @@param context A Kerberos context.
 * @@param hostname hostname to use
 * @@param sname Service name to use
 * @@param type name type of pricipal, use KRB5_NT_SRV_HST or KRB5_NT_UNKNOWN.
 * @@param ret_princ return principal, free with krb5_free_principal().
 *
 * @@return An krb5 error code, see krb5_get_error_message().
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sname_to_principal (krb5_context context,
			 const char *hostname,
			 const char *sname,
			 int32_t type,
			 krb5_principal *ret_princ)
{
    krb5_error_code ret;
    char localhost[MAXHOSTNAMELEN];
    char **realms, *host = NULL;

    if(type != KRB5_NT_SRV_HST && type != KRB5_NT_UNKNOWN) {
	krb5_set_error_message(context, KRB5_SNAME_UNSUPP_NAMETYPE,
			       N_("unsupported name type %d", ""),
			       (int)type);
	return KRB5_SNAME_UNSUPP_NAMETYPE;
    }
    if(hostname == NULL) {
	ret = gethostname(localhost, sizeof(localhost) - 1);
	if (ret != 0) {
	    ret = errno;
	    krb5_set_error_message(context, ret,
				   N_("Failed to get local hostname", ""));
	    return ret;
	}
	localhost[sizeof(localhost) - 1] = '\0';
	hostname = localhost;
    }
    if(sname == NULL)
	sname = "host";
    if(type == KRB5_NT_SRV_HST) {
	ret = krb5_expand_hostname_realms (context, hostname,
					   &host, &realms);
	if (ret)
	    return ret;
	strlwr(host);
	hostname = host;
    } else {
	ret = krb5_get_host_realm(context, hostname, &realms);
	if(ret)
	    return ret;
    }

    ret = krb5_make_principal(context, ret_princ, realms[0], sname,
			      hostname, NULL);
    if(host)
	free(host);
    krb5_free_host_realm(context, realms);
    return ret;
}

static const struct {
    const char *type;
    int32_t value;
} nametypes[] = {
    { "UNKNOWN", KRB5_NT_UNKNOWN },
    { "PRINCIPAL", KRB5_NT_PRINCIPAL },
    { "SRV_INST", KRB5_NT_SRV_INST },
    { "SRV_HST", KRB5_NT_SRV_HST },
    { "SRV_XHST", KRB5_NT_SRV_XHST },
    { "UID", KRB5_NT_UID },
    { "X500_PRINCIPAL", KRB5_NT_X500_PRINCIPAL },
    { "SMTP_NAME", KRB5_NT_SMTP_NAME },
    { "ENTERPRISE_PRINCIPAL", KRB5_NT_ENTERPRISE_PRINCIPAL },
    { "ENT_PRINCIPAL_AND_ID", KRB5_NT_ENT_PRINCIPAL_AND_ID },
    { "MS_PRINCIPAL", KRB5_NT_MS_PRINCIPAL },
    { "MS_PRINCIPAL_AND_ID", KRB5_NT_MS_PRINCIPAL_AND_ID },
    { NULL, 0 }
};

/**
 * Parse nametype string and return a nametype integer
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_parse_nametype(krb5_context context, const char *str, int32_t *nametype)
{
    size_t i;

    for(i = 0; nametypes[i].type; i++) {
	if (strcasecmp(nametypes[i].type, str) == 0) {
	    *nametype = nametypes[i].value;
	    return 0;
	}
    }
    krb5_set_error_message(context, KRB5_PARSE_MALFORMED,
			   N_("Failed to find name type %s", ""), str);
    return KRB5_PARSE_MALFORMED;
}

/**
 * Check if the cname part of the principal is a krbtgt principal
 *
 * @@ingroup krb5_principal
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_principal_is_krbtgt(krb5_context context, krb5_const_principal p)
{
    return p->name.name_string.len == 2 &&
	strcmp(p->name.name_string.val[0], KRB5_TGS_NAME) == 0;

}
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.2
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d2 46
a47 30
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a59 2
RCSID("$KTH: principal.c,v 1.88 2004/12/29 01:54:54 lha Exp $");

d66 14
a79 1
void KRB5_LIB_FUNCTION
d89 13
a101 1
void KRB5_LIB_FUNCTION
d109 12
a120 1
int KRB5_LIB_FUNCTION
d122 1
a122 1
			krb5_principal principal)
d127 12
a138 1
const char* KRB5_LIB_FUNCTION
d140 1
a140 1
			 krb5_principal principal)
d143 1
a143 1
}			 
d145 1
a145 1
const char* KRB5_LIB_FUNCTION
d147 1
a147 1
			       krb5_principal principal,
d155 36
a190 4
krb5_error_code KRB5_LIB_FUNCTION
krb5_parse_name(krb5_context context,
		const char *name,
		krb5_principal *principal)
d205 18
a222 2
  
    /* count number of component */
d224 14
a237 10
    for(p = name; *p; p++){
	if(*p=='\\'){
	    if(!p[1]) {
		krb5_set_error_string (context,
				       "trailing \\ in principal name");
		return KRB5_PARSE_MALFORMED;
	    }
	    p++;
	} else if(*p == '/')
	    ncomp++;
d241 2
a242 1
	krb5_set_error_string (context, "malloc: out of memory");
d245 1
a245 1
  
d250 2
a251 1
	krb5_set_error_string (context, "malloc: out of memory");
a266 2
		krb5_set_error_string (context,
				       "trailing \\ in principal name");
d268 2
d272 4
a275 1
	}else if(c == '/' || c == '@@'){
a276 2
		krb5_set_error_string (context,
				       "part after realm in principal name");
d278 2
a283 1
		    krb5_set_error_string (context, "malloc: out of memory");
d285 2
d298 1
a298 3
	if(got_realm && (c == ':' || c == '/' || c == '\0')) {
	    krb5_set_error_string (context,
				   "part after realm in principal name");
d300 2
d307 7
a315 1
	    krb5_set_error_string (context, "malloc: out of memory");
d317 2
d324 5
a328 2
	ret = krb5_get_default_realm (context, &realm);
	if (ret)
d330 7
a339 1
	    krb5_set_error_string (context, "malloc: out of memory");
d341 2
a350 1
	krb5_set_error_string (context, "malloc: out of memory");
d352 2
d356 4
a359 1
    (*principal)->name.name_type = KRB5_NT_PRINCIPAL;
d375 20
d397 1
d402 1
a402 1
quote_string(const char *s, char *out, size_t index, size_t len)
d405 7
a411 4
    for(p = s; *p && index < len; p++){
	if((q = strchr(quotable_chars, *p))){
	    add_char(out, index, len, '\\');
	    add_char(out, index, len, replace_chars[q - quotable_chars]);
d413 1
a413 1
	    add_char(out, index, len, *p);
d415 3
a417 3
    if(index < len)
	out[index] = '\0';
    return index;
d426 1
a426 1
		   krb5_boolean short_form)
d428 13
a440 2
    size_t index = 0;
    int i;
d443 5
a447 3
	    add_char(name, index, len, '/');
	index = quote_string(princ_ncomp(principal, i), name, index, len);
	if(index == len)
d449 2
a450 1
    } 
d452 1
a452 1
    if(short_form) {
d462 7
a468 4
    if(!short_form) {
	add_char(name, index, len, '@@');
	index = quote_string(princ_realm(principal), name, index, len);
	if(index == len)
d470 1
d475 14
a488 1
krb5_error_code KRB5_LIB_FUNCTION
d494 1
a494 1
    return unparse_name_fixed(context, principal, name, len, FALSE);
d497 15
a511 1
krb5_error_code KRB5_LIB_FUNCTION
d517 26
a542 1
    return unparse_name_fixed(context, principal, name, len, TRUE);
d549 1
a549 1
	     krb5_boolean short_flag)
d552 1
a552 1
    int i;
d555 9
a563 6
    plen = strlen(princ_realm(principal));
    if(strcspn(princ_realm(principal), quotable_chars) == plen)
	len += plen;
    else
	len += 2*plen;
    len++;
d572 1
a572 1
    len++;
d575 2
a576 1
	krb5_set_error_string (context, "malloc: out of memory");
d579 1
a579 1
    ret = unparse_name_fixed(context, principal, *name, len, short_flag);
d587 13
a599 1
krb5_error_code KRB5_LIB_FUNCTION
d604 1
a604 1
    return unparse_name(context, principal, name, FALSE);
d607 15
a621 2
krb5_error_code KRB5_LIB_FUNCTION
krb5_unparse_name_short(krb5_context context,
d623 1
d626 1
a626 1
    return unparse_name(context, principal, name, TRUE);
d629 12
a640 1
#if 0 /* not implemented */
d642 4
a645 5
krb5_error_code KRB5_LIB_FUNCTION
krb5_unparse_name_ext(krb5_context context,
		      krb5_const_principal principal,
		      char **name,
		      size_t *size)
d647 1
a647 1
    krb5_abortx(context, "unimplemented krb5_unparse_name_ext called");
d650 12
a661 1
#endif
d663 15
a677 14
krb5_realm*
krb5_princ_realm(krb5_context context,
		 krb5_principal principal)
{
    return &princ_realm(principal);
}


void KRB5_LIB_FUNCTION
krb5_princ_set_realm(krb5_context context,
		     krb5_principal principal,
		     krb5_realm *realm)
{
    princ_realm(principal) = *realm;
d680 14
d695 1
a695 1
krb5_error_code KRB5_LIB_FUNCTION
d709 37
d748 1
a748 1
append_component(krb5_context context, krb5_principal p, 
d757 2
a758 1
	krb5_set_error_string (context, "malloc: out of memory");
d764 2
a765 1
	krb5_set_error_string (context, "malloc: out of memory");
a799 1

d809 1
a809 1
  
d812 2
a813 1
	krb5_set_error_string (context, "malloc: out of memory");
d821 2
a822 1
	krb5_set_error_string (context, "malloc: out of memory");
d825 1
a825 1
  
d831 3
a833 26
krb5_error_code KRB5_LIB_FUNCTION
krb5_make_principal(krb5_context context,
		    krb5_principal *principal,
		    krb5_const_realm realm,
		    ...)
{
    krb5_error_code ret;
    krb5_realm r = NULL;
    va_list ap;
    if(realm == NULL) {
	ret = krb5_get_default_realm(context, &r);
	if(ret)
	    return ret;
	realm = r;
    }
    va_start(ap, realm);
    ret = krb5_build_principal_va(context, principal, strlen(realm), realm, ap);
    va_end(ap);
    if(r)
	free(r);
    return ret;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_build_principal_va(krb5_context context, 
			krb5_principal *principal, 
d841 3
a843 3
krb5_error_code KRB5_LIB_FUNCTION
krb5_build_principal_va_ext(krb5_context context, 
			    krb5_principal *principal, 
d852 1
a852 1
krb5_error_code KRB5_LIB_FUNCTION
d867 11
d879 2
a880 1
krb5_error_code KRB5_LIB_FUNCTION
d887 2
a888 1
	krb5_set_error_string (context, "malloc: out of memory");
d893 2
a894 1
	krb5_set_error_string (context, "malloc: out of memory");
d901 12
a912 2
/*
 * return TRUE iff princ1 == princ2 (without considering the realm)
d915 1
a915 1
krb5_boolean KRB5_LIB_FUNCTION
d920 1
a920 1
    int i;
d930 29
d963 1
a963 1
krb5_boolean KRB5_LIB_FUNCTION
d973 1
a973 1
/*
d975 8
d985 1
a985 1
krb5_boolean KRB5_LIB_FUNCTION
d993 1
a993 1
/*
d995 2
d999 1
a999 1
krb5_boolean KRB5_LIB_FUNCTION
d1004 1
a1004 1
    int i;
d1016 14
a1029 18

static struct v4_name_convert {
    const char *from;
    const char *to; 
} default_v4_name_convert[] = {
    { "ftp",	"ftp" },
    { "hprop",	"hprop" },
    { "pop",	"pop" },
    { "imap",	"imap" },
    { "rcmd",	"host" },
    { "smtp",	"smtp" },
    { NULL, NULL }
};

/*
 * return the converted instance name of `name' in `realm'.
 * look in the configuration file and then in the default set above.
 * return NULL if no conversion is appropriate.
d1032 1
a1032 402
static const char*
get_name_conversion(krb5_context context, const char *realm, const char *name)
{
    struct v4_name_convert *q;
    const char *p;

    p = krb5_config_get_string(context, NULL, "realms", realm,
			       "v4_name_convert", "host", name, NULL);
    if(p == NULL)
	p = krb5_config_get_string(context, NULL, "libdefaults", 
				   "v4_name_convert", "host", name, NULL);
    if(p)
	return p;

    /* XXX should be possible to override default list */
    p = krb5_config_get_string(context, NULL,
			       "realms",
			       realm,
			       "v4_name_convert",
			       "plain",
			       name,
			       NULL);
    if(p)
	return NULL;
    p = krb5_config_get_string(context, NULL,
			       "libdefaults",
			       "v4_name_convert",
			       "plain",
			       name,
			       NULL);
    if(p)
	return NULL;
    for(q = default_v4_name_convert; q->from; q++)
	if(strcmp(q->from, name) == 0)
	    return q->to;
    return NULL;
}

/*
 * convert the v4 principal `name.instance@@realm' to a v5 principal in `princ'.
 * if `resolve', use DNS.
 * if `func', use that function for validating the conversion
 */

krb5_error_code KRB5_LIB_FUNCTION
krb5_425_conv_principal_ext(krb5_context context,
			    const char *name,
			    const char *instance,
			    const char *realm,
			    krb5_boolean (*func)(krb5_context, krb5_principal),
			    krb5_boolean resolve,
			    krb5_principal *princ)
{
    const char *p;
    krb5_error_code ret;
    krb5_principal pr;
    char host[MAXHOSTNAMELEN];
    char local_hostname[MAXHOSTNAMELEN];

    /* do the following: if the name is found in the
       `v4_name_convert:host' part, is is assumed to be a `host' type
       principal, and the instance is looked up in the
       `v4_instance_convert' part. if not found there the name is
       (optionally) looked up as a hostname, and if that doesn't yield
       anything, the `default_domain' is appended to the instance
       */

    if(instance == NULL)
	goto no_host;
    if(instance[0] == 0){
	instance = NULL;
	goto no_host;
    }
    p = get_name_conversion(context, realm, name);
    if(p == NULL)
	goto no_host;
    name = p;
    p = krb5_config_get_string(context, NULL, "realms", realm, 
			       "v4_instance_convert", instance, NULL);
    if(p){
	instance = p;
	ret = krb5_make_principal(context, &pr, realm, name, instance, NULL);
	if(func == NULL || (*func)(context, pr)){
	    *princ = pr;
	    return 0;
	}
	krb5_free_principal(context, pr);
	*princ = NULL;
	krb5_clear_error_string (context);
	return HEIM_ERR_V4_PRINC_NO_CONV;
    }
    if(resolve){
	krb5_boolean passed = FALSE;
	char *inst = NULL;
#ifdef USE_RESOLVER
	struct dns_reply *r;

	r = dns_lookup(instance, "aaaa");
	if (r && r->head && r->head->type == T_AAAA) {
	    inst = strdup(r->head->domain);
	    dns_free_data(r);
	    passed = TRUE;
	} else {
	    r = dns_lookup(instance, "a");
	    if(r && r->head && r->head->type == T_A) {
		inst = strdup(r->head->domain);
		dns_free_data(r);
		passed = TRUE;
	    }
	}
#else
	struct addrinfo hints, *ai;
	int ret;
	
	memset (&hints, 0, sizeof(hints));
	hints.ai_flags = AI_CANONNAME;
	ret = getaddrinfo(instance, NULL, &hints, &ai);
	if (ret == 0) {
	    const struct addrinfo *a;
	    for (a = ai; a != NULL; a = a->ai_next) {
		if (a->ai_canonname != NULL) {
		    inst = strdup (a->ai_canonname);
		    passed = TRUE;
		    break;
		}
	    }
	    freeaddrinfo (ai);
	}
#endif
	if (passed) {
	    if (inst == NULL) {
		krb5_set_error_string (context, "malloc: out of memory");
		return ENOMEM;
	    }
	    strlwr(inst);
	    ret = krb5_make_principal(context, &pr, realm, name, inst,
				      NULL);
	    free (inst);
	    if(ret == 0) {
		if(func == NULL || (*func)(context, pr)){
		    *princ = pr;
		    return 0;
		}
		krb5_free_principal(context, pr);
	    }
	}
    }
    if(func != NULL) {
	snprintf(host, sizeof(host), "%s.%s", instance, realm);
	strlwr(host);
	ret = krb5_make_principal(context, &pr, realm, name, host, NULL);
	if((*func)(context, pr)){
	    *princ = pr;
	    return 0;
	}
	krb5_free_principal(context, pr);
    }

    /*
     * if the instance is the first component of the local hostname,
     * the converted host should be the long hostname.
     */

    if (func == NULL && 
        gethostname (local_hostname, sizeof(local_hostname)) == 0 &&
        strncmp(instance, local_hostname, strlen(instance)) == 0 && 
	local_hostname[strlen(instance)] == '.') {
	strlcpy(host, local_hostname, sizeof(host));
	goto local_host;
    }

    {
	char **domains, **d;
	domains = krb5_config_get_strings(context, NULL, "realms", realm,
					  "v4_domains", NULL);
	for(d = domains; d && *d; d++){
	    snprintf(host, sizeof(host), "%s.%s", instance, *d);
	    ret = krb5_make_principal(context, &pr, realm, name, host, NULL);
	    if(func == NULL || (*func)(context, pr)){
		*princ = pr;
		krb5_config_free_strings(domains);
		return 0;
	    }
	    krb5_free_principal(context, pr);
	}
	krb5_config_free_strings(domains);
    }

    
    p = krb5_config_get_string(context, NULL, "realms", realm, 
			       "default_domain", NULL);
    if(p == NULL){
	/* this should be an error, just faking a name is not good */
	krb5_clear_error_string (context);
	return HEIM_ERR_V4_PRINC_NO_CONV;
    }
	
    if (*p == '.')
	++p;
    snprintf(host, sizeof(host), "%s.%s", instance, p);
local_host:
    ret = krb5_make_principal(context, &pr, realm, name, host, NULL);
    if(func == NULL || (*func)(context, pr)){
	*princ = pr;
	return 0;
    }
    krb5_free_principal(context, pr);
    krb5_clear_error_string (context);
    return HEIM_ERR_V4_PRINC_NO_CONV;
no_host:
    p = krb5_config_get_string(context, NULL,
			       "realms",
			       realm,
			       "v4_name_convert",
			       "plain",
			       name,
			       NULL);
    if(p == NULL)
	p = krb5_config_get_string(context, NULL,
				   "libdefaults",
				   "v4_name_convert",
				   "plain",
				   name,
				   NULL);
    if(p)
	name = p;
    
    ret = krb5_make_principal(context, &pr, realm, name, instance, NULL);
    if(func == NULL || (*func)(context, pr)){
	*princ = pr;
	return 0;
    }
    krb5_free_principal(context, pr);
    krb5_clear_error_string (context);
    return HEIM_ERR_V4_PRINC_NO_CONV;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_425_conv_principal(krb5_context context,
			const char *name,
			const char *instance,
			const char *realm,
			krb5_principal *princ)
{
    krb5_boolean resolve = krb5_config_get_bool(context,
						NULL,
						"libdefaults", 
						"v4_instance_resolve", 
						NULL);

    return krb5_425_conv_principal_ext(context, name, instance, realm, 
				       NULL, resolve, princ);
}


static int
check_list(const krb5_config_binding *l, const char *name, const char **out)
{
    while(l){
	if (l->type != krb5_config_string)
	    continue;
	if(strcmp(name, l->u.string) == 0) {
	    *out = l->name;
	    return 1;
	}
	l = l->next;
    }
    return 0;
}

static int
name_convert(krb5_context context, const char *name, const char *realm, 
	     const char **out)
{
    const krb5_config_binding *l;
    l = krb5_config_get_list (context,
			      NULL,
			      "realms",
			      realm,
			      "v4_name_convert",
			      "host",
			      NULL);
    if(l && check_list(l, name, out))
	return KRB5_NT_SRV_HST;
    l = krb5_config_get_list (context,
			      NULL,
			      "libdefaults",
			      "v4_name_convert",
			      "host",
			      NULL);
    if(l && check_list(l, name, out))
	return KRB5_NT_SRV_HST;
    l = krb5_config_get_list (context,
			      NULL,
			      "realms",
			      realm,
			      "v4_name_convert",
			      "plain",
			      NULL);
    if(l && check_list(l, name, out))
	return KRB5_NT_UNKNOWN;
    l = krb5_config_get_list (context,
			      NULL,
			      "libdefaults",
			      "v4_name_convert",
			      "host",
			      NULL);
    if(l && check_list(l, name, out))
	return KRB5_NT_UNKNOWN;
    
    /* didn't find it in config file, try built-in list */
    {
	struct v4_name_convert *q;
	for(q = default_v4_name_convert; q->from; q++) {
	    if(strcmp(name, q->to) == 0) {
		*out = q->from;
		return KRB5_NT_SRV_HST;
	    }
	}
    }
    return -1;
}

/*
 * convert the v5 principal in `principal' into a v4 corresponding one
 * in `name, instance, realm'
 * this is limited interface since there's no length given for these
 * three parameters.  They have to be 40 bytes each (ANAME_SZ).
 */

krb5_error_code KRB5_LIB_FUNCTION
krb5_524_conv_principal(krb5_context context,
			const krb5_principal principal,
			char *name, 
			char *instance,
			char *realm)
{
    const char *n, *i, *r;
    char tmpinst[40];
    int type = princ_type(principal);
    const int aname_sz = 40;

    r = principal->realm;

    switch(principal->name.name_string.len){
    case 1:
	n = principal->name.name_string.val[0];
	i = "";
	break;
    case 2:
	n = principal->name.name_string.val[0];
	i = principal->name.name_string.val[1];
	break;
    default:
	krb5_set_error_string (context,
			       "cannot convert a %d component principal",
			       principal->name.name_string.len);
	return KRB5_PARSE_MALFORMED;
    }

    {
	const char *tmp;
	int t = name_convert(context, n, r, &tmp);
	if(t >= 0) {
	    type = t;
	    n = tmp;
	}
    }

    if(type == KRB5_NT_SRV_HST){
	char *p;

	strlcpy (tmpinst, i, sizeof(tmpinst));
	p = strchr(tmpinst, '.');
	if(p)
	    *p = 0;
	i = tmpinst;
    }
    
    if (strlcpy (name, n, aname_sz) >= aname_sz) {
	krb5_set_error_string (context,
			       "too long name component to convert");
	return KRB5_PARSE_MALFORMED;
    }
    if (strlcpy (instance, i, aname_sz) >= aname_sz) {
	krb5_set_error_string (context,
			       "too long instance component to convert");
	return KRB5_PARSE_MALFORMED;
    }
    if (strlcpy (realm, r, aname_sz) >= aname_sz) {
	krb5_set_error_string (context,
			       "too long realm component to convert");
	return KRB5_PARSE_MALFORMED;
    }
    return 0;
}

/*
 * Create a principal in `ret_princ' for the service `sname' running
 * on host `hostname'.  */
			
krb5_error_code KRB5_LIB_FUNCTION
d1042 1
a1042 1
	
d1044 3
a1046 2
	krb5_set_error_string (context, "unsupported name type %d",
			       type);
d1050 8
a1057 1
	gethostname(localhost, sizeof(localhost));
d1081 55
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2000 Kungliga Tekniska Högskolan
d44 1
a44 1
RCSID("$KTH: principal.c,v 1.73 2000/10/16 03:42:14 assar Exp $");
d52 1
a52 1
void
d62 33
a94 1
krb5_error_code
d100 2
a101 2
    general_string *comp;
    general_string realm;
d104 1
a104 1
    char *p;
d115 1
a115 1
    for(p = (char*)name; *p; p++){
d117 3
a119 1
	    if(!p[1])
d121 1
d127 2
a128 1
    if (comp == NULL)
d130 1
d133 1
a133 1
    start = q = p = s = strdup(name);
d136 1
d151 6
d159 2
d166 1
d180 2
d190 1
d203 1
d213 1
d228 1
d291 1
a291 1
krb5_error_code
d300 1
a300 1
krb5_error_code
d333 1
d335 2
a336 1
    if(len != 0 && *name == NULL)
d338 1
d340 1
a340 1
    if(ret)
d342 2
d347 1
a347 1
krb5_error_code
d355 1
a355 1
krb5_error_code
d365 1
a365 1
krb5_error_code
d384 1
a384 1
void
d393 1
a393 1
krb5_error_code
d413 1
a413 1
    general_string *tmp;
d417 2
a418 1
    if(tmp == NULL)
d420 1
d423 2
a424 1
    if (princ_ncomp(p, len) == NULL)
d426 1
d471 2
a472 1
    if (p == NULL)
d474 1
d480 1
d489 1
a489 1
krb5_error_code
d512 1
a512 1
krb5_error_code
d522 1
a522 1
krb5_error_code
d533 1
a533 1
krb5_error_code
d549 1
a549 1
krb5_error_code
d555 2
a556 1
    if (p == NULL)
d558 4
a561 1
    if(copy_Principal(inprinc, p))
d563 1
d572 1
a572 1
krb5_boolean
d591 1
a591 1
krb5_boolean
d605 1
a605 1
krb5_boolean
d617 1
a617 1
krb5_boolean
d635 1
a635 1
struct v4_name_convert {
d644 1
d698 1
a698 1
krb5_error_code
d711 1
d742 1
d746 2
a747 1
	const char *inst = NULL;
a749 10
	r = dns_lookup(instance, "a");
	if(r && r->head && r->head->type == T_A)
	    inst = r->head->domain;
#else
	struct hostent *hp = roken_gethostbyname(instance);
	if(hp)
	    inst = hp->h_name;
#endif
	if(inst) {
	    char *low_inst = strdup(inst);
d751 9
a759 2
	    if (low_inst == NULL) {
#ifdef USE_RESOLVER
d761 21
d783 3
d788 2
a789 1
	    ret = krb5_make_principal(context, &pr, realm, name, low_inst,
d791 1
a791 1
	    free (low_inst);
a794 3
#ifdef USE_RESOLVER
		    dns_free_data(r);
#endif
a799 4
#ifdef USE_RESOLVER
	if(r) 
	    dns_free_data(r);
#endif
d801 24
d841 1
a841 1
    
d847 1
d854 1
d861 1
d887 1
d891 1
a891 1
krb5_error_code
d984 1
a984 1
krb5_error_code
d1008 3
d1033 3
a1035 1
    if (strlcpy (name, n, aname_sz) >= aname_sz)
d1037 4
a1040 1
    if (strlcpy (instance, i, aname_sz) >= aname_sz)
d1042 4
a1045 1
    if (strlcpy (realm, r, aname_sz) >= aname_sz)
d1047 1
d1055 1
a1055 1
krb5_error_code
d1066 3
a1068 1
    if(type != KRB5_NT_SRV_HST && type != KRB5_NT_UNKNOWN)
d1070 1
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d44 1
a44 1
RCSID("$KTH: principal.c,v 1.74 2001/05/14 06:14:50 assar Exp $");
d85 1
a85 3
	    if(!p[1]) {
		krb5_set_error_string (context,
				       "trailing \\ in principal name");
a86 1
	    }
d92 1
a92 2
    if (comp == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a93 1
    }
a98 1
	krb5_set_error_string (context, "malloc: out of memory");
a114 2
		krb5_set_error_string (context,
				       "part after realm in principal name");
a119 1
		    krb5_set_error_string (context, "malloc: out of memory");
a132 2
	    krb5_set_error_string (context,
				   "part after realm in principal name");
a140 1
	    krb5_set_error_string (context, "malloc: out of memory");
a152 1
	    krb5_set_error_string (context, "malloc: out of memory");
a161 1
	krb5_set_error_string (context, "malloc: out of memory");
d281 1
a281 2
    if(len != 0 && *name == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a282 1
    }
d359 1
a359 2
    if(tmp == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a360 1
    }
d363 1
a363 2
    if (princ_ncomp(p, len) == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a364 1
    }
d409 1
a409 2
    if (p == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a410 1
    }
a415 1
	krb5_set_error_string (context, "malloc: out of memory");
d490 1
a490 2
    if (p == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
d492 1
a492 4
    }
    if(copy_Principal(inprinc, p)) {
	free(p);
	krb5_set_error_string (context, "malloc: out of memory");
a493 1
    }
a669 1
	krb5_clear_error_string (context);
a690 1
		krb5_set_error_string (context, "malloc: out of memory");
a733 1
	krb5_clear_error_string (context);
a745 1
    krb5_clear_error_string (context);
a770 1
    krb5_clear_error_string (context);
a890 3
	krb5_set_error_string (context,
			       "cannot convert a %d component principal",
			       principal->name.name_string.len);
d913 1
a913 3
    if (strlcpy (name, n, aname_sz) >= aname_sz) {
	krb5_set_error_string (context,
			       "too long name component to convert");
d915 1
a915 4
    }
    if (strlcpy (instance, i, aname_sz) >= aname_sz) {
	krb5_set_error_string (context,
			       "too long instance component to convert");
d917 1
a917 4
    }
    if (strlcpy (realm, r, aname_sz) >= aname_sz) {
	krb5_set_error_string (context,
			       "too long realm component to convert");
a918 1
    }
d937 1
a937 3
    if(type != KRB5_NT_SRV_HST && type != KRB5_NT_UNKNOWN) {
	krb5_set_error_string (context, "unsupported name type %d",
			       type);
a938 1
    }
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d44 1
a44 1
RCSID("$KTH: principal.c,v 1.77 2001/07/19 15:51:24 assar Exp $");
a61 24
int
krb5_principal_get_type(krb5_context context,
			krb5_principal principal)
{
    return princ_type(principal);
}

const char *
krb5_principal_get_realm(krb5_context context,
			 krb5_principal principal)
{
    return princ_realm(principal);
}			 

const char *
krb5_principal_get_comp_string(krb5_context context,
			       krb5_principal principal,
			       unsigned int component)
{
    if(component >= princ_num_comp(principal))
       return NULL;
    return princ_ncomp(principal, component);
}

a601 1
    { "smtp",	"smtp" },
a667 1
    char local_hostname[MAXHOSTNAMELEN];
a741 14

    /*
     * if the instance is the first component of the local hostname,
     * the converted host should be the long hostname.
     */

    if (func == NULL && 
        gethostname (local_hostname, sizeof(local_hostname)) == 0 &&
        strncmp(instance, local_hostname, strlen(instance)) == 0 && 
	local_hostname[strlen(instance)] == '.') {
	strlcpy(host, local_hostname, sizeof(host));
	goto local_host;
    }

d758 1
a758 1

a770 1
local_host:
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d44 1
a44 1
RCSID("$KTH: principal.c,v 1.82 2002/10/21 15:30:53 joda Exp $");
d96 1
a96 1
    const char *p;
d107 1
a107 1
    for(p = name; *p; p++){
d125 1
a125 1
    p = start = q = s = strdup(name);
a142 6
	    else if(c == '\0') {
		krb5_set_error_string (context,
				       "trailing \\ in principal name");
		ret = KRB5_PARSE_MALFORMED;
		goto exit;
	    }
d728 1
a728 2
	krb5_boolean passed = FALSE;
	char *inst = NULL;
d731 10
d742 2
a743 9
	r = dns_lookup(instance, "aaaa");
	if (r && r->head && r->head->type == T_AAAA) {
	    inst = strdup(r->head->domain);
	    dns_free_data(r);
	    passed = TRUE;
	} else {
	    r = dns_lookup(instance, "a");
	    if(r && r->head && r->head->type == T_A) {
		inst = strdup(r->head->domain);
a744 21
		passed = TRUE;
	    }
	}
#else
	struct addrinfo hints, *ai;
	int ret;
	
	memset (&hints, 0, sizeof(hints));
	hints.ai_flags = AI_CANONNAME;
	ret = getaddrinfo(instance, NULL, &hints, &ai);
	if (ret == 0) {
	    const struct addrinfo *a;
	    for (a = ai; a != NULL; a = a->ai_next) {
		if (a->ai_canonname != NULL) {
		    inst = strdup (a->ai_canonname);
		    passed = TRUE;
		    break;
		}
	    }
	    freeaddrinfo (ai);
	}
a745 2
	if (passed) {
	    if (inst == NULL) {
d749 1
a749 2
	    strlwr(inst);
	    ret = krb5_make_principal(context, &pr, realm, name, inst,
d751 1
a751 1
	    free (inst);
d755 3
d763 4
a766 10
    }
    if(func != NULL) {
	snprintf(host, sizeof(host), "%s.%s", instance, realm);
	strlwr(host);
	ret = krb5_make_principal(context, &pr, realm, name, host, NULL);
	if((*func)(context, pr)){
	    *princ = pr;
	    return 0;
	}
	krb5_free_principal(context, pr);
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d44 1
a44 1
RCSID("$KTH: principal.c,v 1.82.2.1 2003/08/15 14:30:07 lha Exp $");
a323 1
    len++;
d325 1
a325 1
    if(*name == NULL) {
d330 1
a330 1
    if(ret) {
a331 2
	*name = NULL;
    }
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d44 1
a44 1
RCSID("$KTH: principal.c,v 1.88 2004/12/29 01:54:54 lha Exp $");
d52 1
a52 1
void KRB5_LIB_FUNCTION
d62 1
a62 9
void KRB5_LIB_FUNCTION
krb5_principal_set_type(krb5_context context,
			krb5_principal principal,
			int type)
{
    princ_type(principal) = type;
}

int KRB5_LIB_FUNCTION
d69 1
a69 1
const char* KRB5_LIB_FUNCTION
d76 1
a76 1
const char* KRB5_LIB_FUNCTION
d86 1
a86 1
krb5_error_code KRB5_LIB_FUNCTION
d92 2
a93 2
    heim_general_string *comp;
    heim_general_string realm;
d282 1
a282 1
krb5_error_code KRB5_LIB_FUNCTION
d291 1
a291 1
krb5_error_code KRB5_LIB_FUNCTION
d338 1
a338 1
krb5_error_code KRB5_LIB_FUNCTION
d346 1
a346 1
krb5_error_code KRB5_LIB_FUNCTION
d356 1
a356 1
krb5_error_code KRB5_LIB_FUNCTION
d375 1
a375 1
void KRB5_LIB_FUNCTION
d384 1
a384 1
krb5_error_code KRB5_LIB_FUNCTION
d404 1
a404 1
    heim_general_string *tmp;
d480 1
a480 1
krb5_error_code KRB5_LIB_FUNCTION
d503 1
a503 1
krb5_error_code KRB5_LIB_FUNCTION
d513 1
a513 1
krb5_error_code KRB5_LIB_FUNCTION
d524 1
a524 1
krb5_error_code KRB5_LIB_FUNCTION
d540 1
a540 1
krb5_error_code KRB5_LIB_FUNCTION
d563 1
a563 1
krb5_boolean KRB5_LIB_FUNCTION
d582 1
a582 1
krb5_boolean KRB5_LIB_FUNCTION
d596 1
a596 1
krb5_boolean KRB5_LIB_FUNCTION
d608 1
a608 1
krb5_boolean KRB5_LIB_FUNCTION
d626 1
a626 1
static struct v4_name_convert {
d689 1
a689 1
krb5_error_code KRB5_LIB_FUNCTION
d882 1
a882 1
krb5_error_code KRB5_LIB_FUNCTION
d975 1
a975 1
krb5_error_code KRB5_LIB_FUNCTION
d1046 1
a1046 1
krb5_error_code KRB5_LIB_FUNCTION
@


