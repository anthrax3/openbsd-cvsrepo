head	1.4;
access;
symbols
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.5.0.28
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.26
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.24
	OPENBSD_5_0:1.1.1.5.0.22
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.20
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.18
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.14
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.12
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.10
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.8
	OPENBSD_3_7_BASE:1.1.1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.6
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.32;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2014.04.18.09.47.36;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.59;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.24.40;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.38;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.59;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.30;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2002 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"
#include "send_to_kdc_plugin.h"

struct send_to_kdc {
    krb5_send_to_kdc_func func;
    void *data;
};

/*
 * connect to a remote host and in the case of stream sockets, provide
 * a timeout for the connexion.
 */

static int
timed_connect(int s, struct addrinfo *addr, time_t tmout)
{
#ifdef HAVE_POLL
    socklen_t sl;
    int err;
    int flags;
    int ret;

    if (addr->ai_socktype != SOCK_STREAM)
	return connect(s, addr->ai_addr, addr->ai_addrlen);

    flags = fcntl(s, F_GETFL);
    if (flags == -1)
	return -1;

    fcntl(s, F_SETFL, flags | O_NONBLOCK);
    ret = connect(s, addr->ai_addr, addr->ai_addrlen);
    if (ret == -1 && errno != EINPROGRESS)
	return -1;

    for (;;) {
	struct pollfd fds;

	fds.fd = s;
	fds.events = POLLIN | POLLOUT;
	fds.revents = 0;

	ret = poll(&fds, 1, tmout * 1000);
	if (ret != -1 || errno != EINTR)
	    break;
    }
    fcntl(s, F_SETFL, flags);

    if (ret != 1)
	return -1;

    sl = sizeof(err);
    ret = getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &sl);
    if (ret == -1)
	return -1;
    if (err != 0)
	return -1;

    return 0;
#else
    return connect(s, addr->ai_addr, addr->ai_addrlen);
#endif
}

/*
 * send the data in `req' on the socket `fd' (which is datagram iff udp)
 * waiting `tmout' for a reply and returning the reply in `rep'.
 * iff limit read up to this many bytes
 * returns 0 and data in `rep' if succesful, otherwise -1
 */

static int
recv_loop (krb5_socket_t fd,
	   time_t tmout,
	   int udp,
	   size_t limit,
	   krb5_data *rep)
{
     fd_set fdset;
     struct timeval timeout;
     int ret;
     int nbytes;

#ifndef NO_LIMIT_FD_SETSIZE
     if (fd >= FD_SETSIZE) {
	 return -1;
     }
#endif

     krb5_data_zero(rep);
     do {
	 FD_ZERO(&fdset);
	 FD_SET(fd, &fdset);
	 timeout.tv_sec  = tmout;
	 timeout.tv_usec = 0;
	 ret = select (fd + 1, &fdset, NULL, NULL, &timeout);
	 if (ret < 0) {
	     if (errno == EINTR)
		 continue;
	     return -1;
	 } else if (ret == 0) {
	     return 0;
	 } else {
	     void *tmp;

	     if (rk_SOCK_IOCTL (fd, FIONREAD, &nbytes) < 0) {
		 krb5_data_free (rep);
		 return -1;
	     }
	     if(nbytes <= 0)
		 return 0;

	     if (limit)
		 nbytes = min((size_t)nbytes, limit - rep->length);

	     tmp = realloc (rep->data, rep->length + nbytes);
	     if (tmp == NULL) {
		 krb5_data_free (rep);
		 return -1;
	     }
	     rep->data = tmp;
	     ret = recv (fd, (char*)tmp + rep->length, nbytes, 0);
	     if (ret < 0) {
		 krb5_data_free (rep);
		 return -1;
	     }
	     rep->length += ret;
	 }
     } while(!udp && (limit == 0 || rep->length < limit));
     return 0;
}

/*
 * Send kerberos requests and receive a reply on a udp or any other kind
 * of a datagram socket.  See `recv_loop'.
 */

static int
send_and_recv_udp(krb5_socket_t fd,
		  time_t tmout,
		  const krb5_data *req,
		  krb5_data *rep)
{
    if (send (fd, req->data, req->length, 0) < 0)
	return -1;

    return recv_loop(fd, tmout, 1, 0, rep);
}

/*
 * `send_and_recv' for a TCP (or any other stream) socket.
 * Since there are no record limits on a stream socket the protocol here
 * is to prepend the request with 4 bytes of its length and the reply
 * is similarly encoded.
 */

static int
send_and_recv_tcp(krb5_socket_t fd,
		  time_t tmout,
		  const krb5_data *req,
		  krb5_data *rep)
{
    unsigned char len[4];
    unsigned long rep_len;
    krb5_data len_data;

    _krb5_put_int(len, req->length, 4);
    if(net_write (fd, len, sizeof(len)) < 0)
	return -1;
    if(net_write (fd, req->data, req->length) < 0)
	return -1;
    if (recv_loop (fd, tmout, 0, 4, &len_data) < 0)
	return -1;
    if (len_data.length != 4) {
	krb5_data_free (&len_data);
	return -1;
    }
    _krb5_get_int(len_data.data, &rep_len, 4);
    krb5_data_free (&len_data);
    if (recv_loop (fd, tmout, 0, rep_len, rep) < 0)
	return -1;
    if(rep->length != rep_len) {
	krb5_data_free (rep);
	return -1;
    }
    return 0;
}

int
_krb5_send_and_recv_tcp(krb5_socket_t fd,
			time_t tmout,
			const krb5_data *req,
			krb5_data *rep)
{
    return send_and_recv_tcp(fd, tmout, req, rep);
}

/*
 * `send_and_recv' tailored for the HTTP protocol.
 */

static int
send_and_recv_http(krb5_socket_t fd,
		   time_t tmout,
		   const char *prefix,
		   const krb5_data *req,
		   krb5_data *rep)
{
    char *request = NULL;
    char *str;
    int ret;
    int len = base64_encode(req->data, req->length, &str);

    if(len < 0)
	return -1;
    ret = asprintf(&request, "GET %s%s HTTP/1.0\r\n\r\n", prefix, str);
    free(str);
    if (ret < 0 || request == NULL)
	return -1;
    ret = net_write (fd, request, strlen(request));
    free (request);
    if (ret < 0)
	return ret;
    ret = recv_loop(fd, tmout, 0, 0, rep);
    if(ret)
	return ret;
    {
	unsigned long rep_len;
	char *s, *p;

	s = realloc(rep->data, rep->length + 1);
	if (s == NULL) {
	    krb5_data_free (rep);
	    return -1;
	}
	s[rep->length] = 0;
	p = strstr(s, "\r\n\r\n");
	if(p == NULL) {
	    krb5_data_zero(rep);
	    free(s);
	    return -1;
	}
	p += 4;
	rep->data = s;
	rep->length -= p - s;
	if(rep->length < 4) { /* remove length */
	    krb5_data_zero(rep);
	    free(s);
	    return -1;
	}
	rep->length -= 4;
	_krb5_get_int(p, &rep_len, 4);
	if (rep_len != rep->length) {
	    krb5_data_zero(rep);
	    free(s);
	    return -1;
	}
	memmove(rep->data, p + 4, rep->length);
    }
    return 0;
}

static int
init_port(const char *s, int fallback)
{
    if (s) {
	int tmp;

	sscanf (s, "%d", &tmp);
	return htons(tmp);
    } else
	return fallback;
}

/*
 * Return 0 if succesful, otherwise 1
 */

static int
send_via_proxy (krb5_context context,
		const krb5_krbhst_info *hi,
		const krb5_data *send_data,
		krb5_data *receive)
{
    char *proxy2 = strdup(context->http_proxy);
    char *proxy  = proxy2;
    char *prefix = NULL;
    char *colon;
    struct addrinfo hints;
    struct addrinfo *ai, *a;
    int ret;
    krb5_socket_t s = rk_INVALID_SOCKET;
    char portstr[NI_MAXSERV];

    if (proxy == NULL)
	return ENOMEM;
    if (strncmp (proxy, "http://", 7) == 0)
	proxy += 7;

    colon = strchr(proxy, ':');
    if(colon != NULL)
	*colon++ = '\0';
    memset (&hints, 0, sizeof(hints));
    hints.ai_family   = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    snprintf (portstr, sizeof(portstr), "%d",
	      ntohs(init_port (colon, htons(80))));
    ret = getaddrinfo (proxy, portstr, &hints, &ai);
    free (proxy2);
    if (ret)
	return krb5_eai_to_heim_errno(ret, errno);

    for (a = ai; a != NULL; a = a->ai_next) {
	s = socket (a->ai_family, a->ai_socktype | SOCK_CLOEXEC, a->ai_protocol);
	if (s < 0)
	    continue;
	rk_cloexec(s);
	if (timed_connect (s, a, context->kdc_timeout) < 0) {
	    rk_closesocket (s);
	    continue;
	}
	break;
    }
    if (a == NULL) {
	freeaddrinfo (ai);
	return 1;
    }
    freeaddrinfo (ai);

    ret = asprintf(&prefix, "http://%s/", hi->hostname);
    if(ret < 0 || prefix == NULL) {
	close(s);
	return 1;
    }
    ret = send_and_recv_http(s, context->kdc_timeout,
			     prefix, send_data, receive);
    rk_closesocket (s);
    free(prefix);
    if(ret == 0 && receive->length != 0)
	return 0;
    return 1;
}

static krb5_error_code
send_via_plugin(krb5_context context,
		krb5_krbhst_info *hi,
		time_t timeout,
		const krb5_data *send_data,
		krb5_data *receive)
{
    struct krb5_plugin *list = NULL, *e;
    krb5_error_code ret;

    ret = _krb5_plugin_find(context, PLUGIN_TYPE_DATA, KRB5_PLUGIN_SEND_TO_KDC, &list);
    if(ret != 0 || list == NULL)
	return KRB5_PLUGIN_NO_HANDLE;

    for (e = list; e != NULL; e = _krb5_plugin_get_next(e)) {
	krb5plugin_send_to_kdc_ftable *service;
	void *ctx;

	service = _krb5_plugin_get_symbol(e);
	if (service->minor_version != 0)
	    continue;

	(*service->init)(context, &ctx);
	ret = (*service->send_to_kdc)(context, ctx, hi,
				      timeout, send_data, receive);
	(*service->fini)(ctx);
	if (ret == 0)
	    break;
	if (ret != KRB5_PLUGIN_NO_HANDLE) {
	    krb5_set_error_message(context, ret,
				   N_("Plugin send_to_kdc failed to "
				      "lookup with error: %d", ""), ret);
	    break;
	}
    }
    _krb5_plugin_free(list);
    return KRB5_PLUGIN_NO_HANDLE;
}


/*
 * Send the data `send' to one host from `handle` and get back the reply
 * in `receive'.
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sendto (krb5_context context,
	     const krb5_data *send_data,
	     krb5_krbhst_handle handle,
	     krb5_data *receive)
{
     krb5_error_code ret;
     krb5_socket_t fd;
     size_t i;

     krb5_data_zero(receive);

     for (i = 0; i < context->max_retries; ++i) {
	 krb5_krbhst_info *hi;

	 while (krb5_krbhst_next(context, handle, &hi) == 0) {
	     struct addrinfo *ai, *a;

	     _krb5_debug(context, 2,
			 "trying to communicate with host %s in realm %s",
			 hi->hostname, _krb5_krbhst_get_realm(handle));

	     if (context->send_to_kdc) {
		 struct send_to_kdc *s = context->send_to_kdc;

		 ret = (*s->func)(context, s->data, hi,
				  context->kdc_timeout, send_data, receive);
		 if (ret == 0 && receive->length != 0)
		     goto out;
		 continue;
	     }

	     ret = send_via_plugin(context, hi, context->kdc_timeout,
				   send_data, receive);
	     if (ret == 0 && receive->length != 0)
		 goto out;
	     else if (ret != KRB5_PLUGIN_NO_HANDLE)
		 continue;

	     if(hi->proto == KRB5_KRBHST_HTTP && context->http_proxy) {
		 if (send_via_proxy (context, hi, send_data, receive) == 0) {
		     ret = 0;
		     goto out;
		 }
		 continue;
	     }

	     ret = krb5_krbhst_get_addrinfo(context, hi, &ai);
	     if (ret)
		 continue;

	     for (a = ai; a != NULL; a = a->ai_next) {
		 fd = socket (a->ai_family, a->ai_socktype | SOCK_CLOEXEC, a->ai_protocol);
		 if (rk_IS_BAD_SOCKET(fd))
		     continue;
		 rk_cloexec(fd);
		 if (timed_connect (fd, a, context->kdc_timeout) < 0) {
		     rk_closesocket (fd);
		     continue;
		 }
		 switch (hi->proto) {
		 case KRB5_KRBHST_HTTP :
		     ret = send_and_recv_http(fd, context->kdc_timeout,
					      "", send_data, receive);
		     break;
		 case KRB5_KRBHST_TCP :
		     ret = send_and_recv_tcp (fd, context->kdc_timeout,
					      send_data, receive);
		     break;
		 case KRB5_KRBHST_UDP :
		     ret = send_and_recv_udp (fd, context->kdc_timeout,
					      send_data, receive);
		     break;
		 }
		 rk_closesocket (fd);
		 if(ret == 0 && receive->length != 0)
		     goto out;
	     }
	 }
	 krb5_krbhst_reset(context, handle);
     }
     krb5_clear_error_message (context);
     ret = KRB5_KDC_UNREACH;
out:
     _krb5_debug(context, 2,
		 "result of trying to talk to realm %s = %d",
		 _krb5_krbhst_get_realm(handle), ret);
     return ret;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sendto_kdc(krb5_context context,
		const krb5_data *send_data,
		const krb5_realm *realm,
		krb5_data *receive)
{
    return krb5_sendto_kdc_flags(context, send_data, realm, receive, 0);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sendto_kdc_flags(krb5_context context,
		      const krb5_data *send_data,
		      const krb5_realm *realm,
		      krb5_data *receive,
		      int flags)
{
    krb5_error_code ret;
    krb5_sendto_ctx ctx;

    ret = krb5_sendto_ctx_alloc(context, &ctx);
    if (ret)
	return ret;
    krb5_sendto_ctx_add_flags(ctx, flags);
    krb5_sendto_ctx_set_func(ctx, _krb5_kdc_retry, NULL);

    ret = krb5_sendto_context(context, ctx, send_data, *realm, receive);
    krb5_sendto_ctx_free(context, ctx);
    return ret;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_send_to_kdc_func(krb5_context context,
			  krb5_send_to_kdc_func func,
			  void *data)
{
    free(context->send_to_kdc);
    if (func == NULL) {
	context->send_to_kdc = NULL;
	return 0;
    }

    context->send_to_kdc = malloc(sizeof(*context->send_to_kdc));
    if (context->send_to_kdc == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    context->send_to_kdc->func = func;
    context->send_to_kdc->data = data;
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
_krb5_copy_send_to_kdc_func(krb5_context context, krb5_context to)
{
    if (context->send_to_kdc)
	return krb5_set_send_to_kdc_func(to,
					 context->send_to_kdc->func,
					 context->send_to_kdc->data);
    else
	return krb5_set_send_to_kdc_func(to, NULL, NULL);
}



struct krb5_sendto_ctx_data {
    int flags;
    int type;
    krb5_sendto_ctx_func func;
    void *data;
};

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sendto_ctx_alloc(krb5_context context, krb5_sendto_ctx *ctx)
{
    *ctx = calloc(1, sizeof(**ctx));
    if (*ctx == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    return 0;
}

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_sendto_ctx_add_flags(krb5_sendto_ctx ctx, int flags)
{
    ctx->flags |= flags;
}

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_sendto_ctx_get_flags(krb5_sendto_ctx ctx)
{
    return ctx->flags;
}

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_sendto_ctx_set_type(krb5_sendto_ctx ctx, int type)
{
    ctx->type = type;
}


KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_sendto_ctx_set_func(krb5_sendto_ctx ctx,
			 krb5_sendto_ctx_func func,
			 void *data)
{
    ctx->func = func;
    ctx->data = data;
}

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_sendto_ctx_free(krb5_context context, krb5_sendto_ctx ctx)
{
    memset(ctx, 0, sizeof(*ctx));
    free(ctx);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sendto_context(krb5_context context,
		    krb5_sendto_ctx ctx,
		    const krb5_data *send_data,
		    const krb5_realm realm,
		    krb5_data *receive)
{
    krb5_error_code ret;
    krb5_krbhst_handle handle = NULL;
    int type, freectx = 0;
    int action;

    krb5_data_zero(receive);

    if (ctx == NULL) {
	freectx = 1;
	ret = krb5_sendto_ctx_alloc(context, &ctx);
	if (ret)
	    return ret;
    }

    type = ctx->type;
    if (type == 0) {
	if ((ctx->flags & KRB5_KRBHST_FLAGS_MASTER) || context->use_admin_kdc)
	    type = KRB5_KRBHST_ADMIN;
	else
	    type = KRB5_KRBHST_KDC;
    }

    if ((int)send_data->length > context->large_msg_size)
	ctx->flags |= KRB5_KRBHST_FLAGS_LARGE_MSG;

    /* loop until we get back a appropriate response */

    do {
	action = KRB5_SENDTO_DONE;

	krb5_data_free(receive);

	if (handle == NULL) {
	    ret = krb5_krbhst_init_flags(context, realm, type,
					 ctx->flags, &handle);
	    if (ret) {
		if (freectx)
		    krb5_sendto_ctx_free(context, ctx);
		return ret;
	    }
	}

	ret = krb5_sendto(context, send_data, handle, receive);
	if (ret)
	    break;
	if (ctx->func) {
	    ret = (*ctx->func)(context, ctx, ctx->data, receive, &action);
	    if (ret)
		break;
	}
	if (action != KRB5_SENDTO_CONTINUE) {
	    krb5_krbhst_free(context, handle);
	    handle = NULL;
	}
    } while (action != KRB5_SENDTO_DONE);
    if (handle)
	krb5_krbhst_free(context, handle);
    if (ret == KRB5_KDC_UNREACH)
	krb5_set_error_message(context, ret,
			       N_("unable to reach any KDC in realm %s", ""),
			       realm);
    if (ret)
	krb5_data_free(receive);
    if (freectx)
	krb5_sendto_ctx_free(context, ctx);
    return ret;
}

krb5_error_code KRB5_CALLCONV
_krb5_kdc_retry(krb5_context context, krb5_sendto_ctx ctx, void *data,
		const krb5_data *reply, int *action)
{
    krb5_error_code ret;
    KRB_ERROR error;

    if(krb5_rd_error(context, reply, &error))
	return 0;

    ret = krb5_error_from_rd_error(context, &error, NULL);
    krb5_free_error_contents(context, &error);

    switch(ret) {
    case KRB5KRB_ERR_RESPONSE_TOO_BIG: {
	if (krb5_sendto_ctx_get_flags(ctx) & KRB5_KRBHST_FLAGS_LARGE_MSG)
	    break;
	krb5_sendto_ctx_add_flags(ctx, KRB5_KRBHST_FLAGS_LARGE_MSG);
	*action = KRB5_SENDTO_RESTART;
	break;
    }
    case KRB5KDC_ERR_SVC_UNAVAILABLE:
	*action = KRB5_SENDTO_CONTINUE;
	break;
    }
    return 0;
}
@


1.3
log
@Upgrade our KerberosV to Heimdal 1.5.3 (minor update).

- Fix leaking file descriptors in KDC
- Better socket/timeout handling in libkrb5
- General bug fixes

ok robert@@
@
text
@@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d43 55
d350 1
a350 1
	if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
d477 1
a477 1
		 if (connect (fd, a->ai_addr, a->ai_addrlen) < 0) {
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d35 1
d37 4
a40 1
RCSID("$KTH: send_to_kdc.c,v 1.40 2000/11/15 01:48:23 assar Exp $");
d50 1
a50 1
recv_loop (int fd,
d61 1
d65 1
d83 1
a83 1
	     if (ioctl (fd, FIONREAD, &nbytes) < 0) {
d87 1
a87 1
	     if(nbytes == 0)
d91 1
a91 1
		 nbytes = min(nbytes, limit - rep->length);
d116 1
a116 1
send_and_recv_udp(int fd, 
d135 1
a135 1
send_and_recv_tcp(int fd, 
d145 1
a145 1
    if(net_write(fd, len, sizeof(len)) < 0)
d147 1
a147 1
    if(net_write(fd, req->data, req->length) < 0)
d166 9
d180 1
a180 1
send_and_recv_http(int fd, 
d186 1
a186 1
    char *request;
d193 1
a193 1
    asprintf(&request, "GET %s%s HTTP/1.0\r\n\r\n", prefix, str);
d195 1
a195 1
    if (request == NULL)
d216 1
d224 1
d231 1
d258 2
a259 2
		const char *hostname,
		const krb5_data *send,
d264 1
a264 1
    char *prefix;
d269 1
a269 1
    int s;
d271 1
a271 1
		 
d288 1
a288 1
	return krb5_eai_to_heim_errno(ret);
d291 1
a291 1
	s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
d294 1
d296 1
a296 1
	    close (s);
d307 2
a308 2
    asprintf(&prefix, "http://%s/", hostname);
    if(prefix == NULL) {
d313 2
a314 2
			     prefix, send, receive);
    close (s);
d321 40
d362 1
a362 1
 * Send the data `send' to one KDC in `realm' and get back the reply
d366 1
a366 1
krb5_error_code
d368 2
a369 3
	     const krb5_data *send,
	     char **hostlist,
	     int port,
d372 10
a381 10
     krb5_error_code ret = 0;
     char **hp, *p;
     int fd;
     int i;

     for (i = 0; i < context->max_retries; ++i)
	 for (hp = hostlist; (p = *hp); ++hp) {
	     char *colon;
	     int http_flag = 0;
	     int tcp_flag = 0;
a382 2
	     struct addrinfo hints;
	     char portstr[NI_MAXSERV];
d384 12
a395 13
	     if(strncmp(p, "http://", 7) == 0){
		 p += 7;
		 http_flag = 1;
		 port = htons(80);
	     } else if(strncmp(p, "http/", 5) == 0) {
		 p += 5;
		 http_flag = 1;
		 port = htons(80);
	     }else if(strncmp(p, "tcp/", 4) == 0){
		 p += 4;
		 tcp_flag = 1;
	     } else if(strncmp(p, "udp/", 4) == 0) {
		 p += 4;
d397 11
a407 4
	     if(http_flag && context->http_proxy) {
		 if (send_via_proxy (context, p, send, receive))
		     continue;
		 else
d409 2
d412 2
a413 13
	     colon = strchr (p, ':');
	     if (colon)
		 *colon++ = '\0';

	     memset (&hints, 0, sizeof(hints));
	     hints.ai_family = PF_UNSPEC;
	     if (tcp_flag || http_flag)
		 hints.ai_socktype = SOCK_STREAM;
	     else
		 hints.ai_socktype = SOCK_DGRAM;
	     snprintf (portstr, sizeof(portstr), "%d",
		       ntohs(init_port (colon, port)));
	     ret = getaddrinfo (p, portstr, &hints, &ai);
d416 1
d418 2
a419 2
		 fd = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
		 if (fd < 0)
d421 1
d423 1
a423 1
		     close (fd);
d426 17
a442 5
		 break;
	     }
	     if (a == NULL) {
		 freeaddrinfo (ai);
		 continue;
a443 14
	     freeaddrinfo (ai);

	     if(http_flag)
		 ret = send_and_recv_http(fd, context->kdc_timeout,
					  "", send, receive);
	     else if(tcp_flag)
		 ret = send_and_recv_tcp (fd, context->kdc_timeout,
					  send, receive);
	     else
		 ret = send_and_recv_udp (fd, context->kdc_timeout,
					  send, receive);
	     close (fd);
	     if(ret == 0 && receive->length != 0)
		 goto out;
d445 3
d450 3
d456 15
a470 6
krb5_error_code
krb5_sendto_kdc2(krb5_context context,
		 const krb5_data *send,
		 const krb5_realm *realm,
		 krb5_data *receive,
		 krb5_boolean master)
d473 43
a515 7
    char **hostlist;
    int port;
    
    port = krb5_getportbyname (context, "kerberos", "udp", 88);
    
    if (master || context->use_admin_kdc)
	ret = krb5_get_krb_admin_hst (context, realm, &hostlist);
d517 127
a643 1
	ret = krb5_get_krbhst (context, realm, &hostlist);
d645 3
a647 3
	return ret;
    ret = krb5_sendto(context, send, hostlist, port, receive);
    krb5_free_krbhst (context, hostlist);
d651 3
a653 5
krb5_error_code
krb5_sendto_kdc(krb5_context context,
		const krb5_data *send,
		const krb5_realm *realm,
		krb5_data *receive)
d655 22
a676 1
    return krb5_sendto_kdc2(context, send, realm, receive, FALSE);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: send_to_kdc.c,v 1.44 2001/05/14 22:49:56 assar Exp $");
d270 1
a270 1
	return krb5_eai_to_heim_errno(ret, errno);
d303 1
a303 1
 * Send the data `send' to one hots in `hostlist' and get back the reply
d319 1
a319 1
     for (i = 0; i < context->max_retries; ++i) {
d371 5
a375 14
		 if(http_flag)
		     ret = send_and_recv_http(fd, context->kdc_timeout,
					      "", send, receive);
		 else if(tcp_flag)
		     ret = send_and_recv_tcp (fd, context->kdc_timeout,
					      send, receive);
		 else
		     ret = send_and_recv_udp (fd, context->kdc_timeout,
					      send, receive);
		 close (fd);
		 if(ret == 0 && receive->length != 0) {
		     freeaddrinfo(ai);
		     goto out;
		 }
d377 14
a390 1
	     freeaddrinfo(ai);
a391 2
     }
     krb5_clear_error_string (context);
a417 3
    if (ret == KRB5_KDC_UNREACH)
	krb5_set_error_string(context,
			      "unable to reach any KDC in realm %s", *realm);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: send_to_kdc.c,v 1.47 2001/07/03 19:35:46 assar Exp $");
d240 1
a240 1
		const krb5_krbhst_info *hi,
d251 1
a251 1
    int s = -1;
d288 1
a288 1
    asprintf(&prefix, "http://%s/", hi->hostname);
d303 1
a303 1
 * Send the data `send' to one host from `handle` and get back the reply
d310 2
a311 1
	     krb5_krbhst_handle handle,	     
d315 1
d320 4
a323 4
	 krb5_krbhst_info *hi;

	 while (krb5_krbhst_next(context, handle, &hi) == 0) {
	     int ret;
d325 2
d328 16
a343 2
	     if(hi->proto == KRB5_KRBHST_HTTP && context->http_proxy) {
		 if (send_via_proxy (context, hi, send, receive))
d348 13
a360 2

	     ret = krb5_krbhst_get_addrinfo(context, hi, &ai);
a362 1

d371 1
a371 2
		 switch (hi->proto) {
		 case KRB5_KRBHST_HTTP :
d374 1
a374 2
		     break;
		 case KRB5_KRBHST_TCP :
d377 1
a377 2
		     break;
		 case KRB5_KRBHST_UDP :
a379 2
		     break;
		 }
d381 2
a382 1
		 if(ret == 0 && receive->length != 0)
d384 1
d386 1
a387 1
	 krb5_krbhst_reset(context, handle);
d403 5
a407 3
    krb5_krbhst_handle handle;
    int type;

d409 1
a409 1
	type = KRB5_KRBHST_ADMIN;
d411 1
a411 3
	type = KRB5_KRBHST_KDC;

    ret = krb5_krbhst_init(context, *realm, type, &handle);
d414 2
a415 3

    ret = krb5_sendto(context, send, handle, receive);
    krb5_krbhst_free(context, handle);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: send_to_kdc.c,v 1.48 2002/03/27 09:32:50 joda Exp $");
d241 1
a241 1
		const krb5_data *send_data,
d294 1
a294 1
			     prefix, send_data, receive);
d309 1
a309 1
	     const krb5_data *send_data,
d325 1
a325 1
		 if (send_via_proxy (context, hi, send_data, receive))
d346 1
a346 1
					      "", send_data, receive);
d350 1
a350 1
					      send_data, receive);
d354 1
a354 1
					      send_data, receive);
d372 1
a372 1
		 const krb5_data *send_data,
d390 1
a390 1
    ret = krb5_sendto(context, send_data, handle, receive);
d400 1
a400 1
		const krb5_data *send_data,
d404 1
a404 1
    return krb5_sendto_kdc2(context, send_data, realm, receive, FALSE);
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: send_to_kdc.c,v 1.55 2005/02/02 20:05:30 lha Exp $");
a159 9
int
_krb5_send_and_recv_tcp(int fd,
			time_t tmout,
			const krb5_data *req,
			krb5_data *rep)
{
    return send_and_recv_tcp(fd, tmout, req, rep);
}

d307 1
a307 1
krb5_error_code KRB5_LIB_FUNCTION
d370 6
a375 15
krb5_error_code KRB5_LIB_FUNCTION
krb5_sendto_kdc(krb5_context context,
		const krb5_data *send_data,
		const krb5_realm *realm,
		krb5_data *receive)
{
    return krb5_sendto_kdc_flags(context, send_data, realm, receive, 0);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_sendto_kdc_flags(krb5_context context,
		      const krb5_data *send_data,
		      const krb5_realm *realm,
		      krb5_data *receive,
		      int flags)
d381 1
a381 1
    if ((flags & KRB5_KRBHST_FLAGS_MASTER) || context->use_admin_kdc)
d386 1
a386 4
    if (send_data->length > context->large_msg_size)
	flags |= KRB5_KRBHST_FLAGS_LARGE_MSG;

    ret = krb5_krbhst_init_flags(context, *realm, type, flags, &handle);
d396 9
@


