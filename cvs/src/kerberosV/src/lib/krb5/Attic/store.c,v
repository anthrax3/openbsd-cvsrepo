head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.26
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.24
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.22
	OPENBSD_5_0:1.2.0.20
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.18
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.16
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.8
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.32;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.59;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.24.43;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.59;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.37;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.31;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2008 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"
#include "store-int.h"

#define BYTEORDER_IS(SP, V) (((SP)->flags & KRB5_STORAGE_BYTEORDER_MASK) == (V))
#define BYTEORDER_IS_LE(SP) BYTEORDER_IS((SP), KRB5_STORAGE_BYTEORDER_LE)
#define BYTEORDER_IS_BE(SP) BYTEORDER_IS((SP), KRB5_STORAGE_BYTEORDER_BE)
#define BYTEORDER_IS_HOST(SP) (BYTEORDER_IS((SP), KRB5_STORAGE_BYTEORDER_HOST) || \
			       krb5_storage_is_flags((SP), KRB5_STORAGE_HOST_BYTEORDER))

/**
 * Add the flags on a storage buffer by or-ing in the flags to the buffer.
 *
 * @@param sp the storage buffer to set the flags on
 * @@param flags the flags to set
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_storage_set_flags(krb5_storage *sp, krb5_flags flags)
{
    sp->flags |= flags;
}

/**
 * Clear the flags on a storage buffer
 *
 * @@param sp the storage buffer to clear the flags on
 * @@param flags the flags to clear
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_storage_clear_flags(krb5_storage *sp, krb5_flags flags)
{
    sp->flags &= ~flags;
}

/**
 * Return true or false depending on if the storage flags is set or
 * not. NB testing for the flag 0 always return true.
 *
 * @@param sp the storage buffer to check flags on
 * @@param flags The flags to test for
 *
 * @@return true if all the flags are set, false if not.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_storage_is_flags(krb5_storage *sp, krb5_flags flags)
{
    return (sp->flags & flags) == flags;
}

/**
 * Set the new byte order of the storage buffer.
 *
 * @@param sp the storage buffer to set the byte order for.
 * @@param byteorder the new byte order.
 *
 * The byte order are: KRB5_STORAGE_BYTEORDER_BE,
 * KRB5_STORAGE_BYTEORDER_LE and KRB5_STORAGE_BYTEORDER_HOST.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_storage_set_byteorder(krb5_storage *sp, krb5_flags byteorder)
{
    sp->flags &= ~KRB5_STORAGE_BYTEORDER_MASK;
    sp->flags |= byteorder;
}

/**
 * Return the current byteorder for the buffer. See krb5_storage_set_byteorder() for the list or byte order contants.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_flags KRB5_LIB_CALL
krb5_storage_get_byteorder(krb5_storage *sp)
{
    return sp->flags & KRB5_STORAGE_BYTEORDER_MASK;
}

/**
 * Set the max alloc value
 *
 * @@param sp the storage buffer set the max allow for
 * @@param size maximum size to allocate, use 0 to remove limit
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_storage_set_max_alloc(krb5_storage *sp, size_t size)
{
    sp->max_alloc = size;
}

/* don't allocate unresonable amount of memory */
static krb5_error_code
size_too_large(krb5_storage *sp, size_t size)
{
    if (sp->max_alloc && sp->max_alloc < size)
	return HEIM_ERR_TOO_BIG;
    return 0;
}

static krb5_error_code
size_too_large_num(krb5_storage *sp, size_t count, size_t size)
{
    if (sp->max_alloc == 0 || size == 0)
	return 0;
    size = sp->max_alloc / size;
    if (size < count)
	return HEIM_ERR_TOO_BIG;
    return 0;
}

/**
 * Seek to a new offset.
 *
 * @@param sp the storage buffer to seek in.
 * @@param offset the offset to seek
 * @@param whence relateive searching, SEEK_CUR from the current
 * position, SEEK_END from the end, SEEK_SET absolute from the start.
 *
 * @@return The new current offset
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION off_t KRB5_LIB_CALL
krb5_storage_seek(krb5_storage *sp, off_t offset, int whence)
{
    return (*sp->seek)(sp, offset, whence);
}

/**
 * Truncate the storage buffer in sp to offset.
 *
 * @@param sp the storage buffer to truncate.
 * @@param offset the offset to truncate too.
 *
 * @@return An Kerberos 5 error code.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_storage_truncate(krb5_storage *sp, off_t offset)
{
    return (*sp->trunc)(sp, offset);
}

/**
 * Read to the storage buffer.
 *
 * @@param sp the storage buffer to read from
 * @@param buf the buffer to store the data in
 * @@param len the length to read
 *
 * @@return The length of data read (can be shorter then len), or negative on error.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_ssize_t KRB5_LIB_CALL
krb5_storage_read(krb5_storage *sp, void *buf, size_t len)
{
    return sp->fetch(sp, buf, len);
}

/**
 * Write to the storage buffer.
 *
 * @@param sp the storage buffer to write to
 * @@param buf the buffer to write to the storage buffer
 * @@param len the length to write
 *
 * @@return The length of data written (can be shorter then len), or negative on error.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_ssize_t KRB5_LIB_CALL
krb5_storage_write(krb5_storage *sp, const void *buf, size_t len)
{
    return sp->store(sp, buf, len);
}

/**
 * Set the return code that will be used when end of storage is reached.
 *
 * @@param sp the storage
 * @@param code the error code to return on end of storage
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_storage_set_eof_code(krb5_storage *sp, int code)
{
    sp->eof_code = code;
}

/**
 * Get the return code that will be used when end of storage is reached.
 *
 * @@param sp the storage
 *
 * @@return storage error code
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_storage_get_eof_code(krb5_storage *sp)
{
    return sp->eof_code;
}

/**
 * Free a krb5 storage.
 *
 * @@param sp the storage to free.
 *
 * @@return An Kerberos 5 error code.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_storage_free(krb5_storage *sp)
{
    if(sp->free)
	(*sp->free)(sp);
    free(sp->data);
    free(sp);
    return 0;
}

/**
 * Copy the contnent of storage
 *
 * @@param sp the storage to copy to a data
 * @@param data the copied data, free with krb5_data_free()
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_storage_to_data(krb5_storage *sp, krb5_data *data)
{
    off_t pos, size;
    krb5_error_code ret;

    pos = sp->seek(sp, 0, SEEK_CUR);
    if (pos < 0)
	return HEIM_ERR_NOT_SEEKABLE;
    size = sp->seek(sp, 0, SEEK_END);
    ret = size_too_large(sp, size);
    if (ret)
	return ret;
    ret = krb5_data_alloc(data, size);
    if (ret) {
	sp->seek(sp, pos, SEEK_SET);
	return ret;
    }
    if (size) {
	sp->seek(sp, 0, SEEK_SET);
	sp->fetch(sp, data->data, data->length);
	sp->seek(sp, pos, SEEK_SET);
    }
    return 0;
}

static krb5_error_code
krb5_store_int(krb5_storage *sp,
	       int32_t value,
	       size_t len)
{
    int ret;
    unsigned char v[16];

    if(len > sizeof(v))
	return EINVAL;
    _krb5_put_int(v, value, len);
    ret = sp->store(sp, v, len);
    if (ret < 0)
	return errno;
    if ((size_t)ret != len)
	return sp->eof_code;
    return 0;
}

/**
 * Store a int32 to storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value to store
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_int32(krb5_storage *sp,
		 int32_t value)
{
    if(BYTEORDER_IS_HOST(sp))
	value = htonl(value);
    else if(BYTEORDER_IS_LE(sp))
	value = bswap32(value);
    return krb5_store_int(sp, value, 4);
}

/**
 * Store a uint32 to storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value to store
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_uint32(krb5_storage *sp,
		  uint32_t value)
{
    return krb5_store_int32(sp, (int32_t)value);
}

static krb5_error_code
krb5_ret_int(krb5_storage *sp,
	     int32_t *value,
	     size_t len)
{
    int ret;
    unsigned char v[4];
    unsigned long w;
    ret = sp->fetch(sp, v, len);
    if (ret < 0)
	return errno;
    if ((size_t)ret != len)
	return sp->eof_code;
    _krb5_get_int(v, &w, len);
    *value = w;
    return 0;
}

/**
 * Read a int32 from storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value read from the buffer
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_int32(krb5_storage *sp,
	       int32_t *value)
{
    krb5_error_code ret = krb5_ret_int(sp, value, 4);
    if(ret)
	return ret;
    if(BYTEORDER_IS_HOST(sp))
	*value = htonl(*value);
    else if(BYTEORDER_IS_LE(sp))
	*value = bswap32(*value);
    return 0;
}

/**
 * Read a uint32 from storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value read from the buffer
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_uint32(krb5_storage *sp,
		uint32_t *value)
{
    krb5_error_code ret;
    int32_t v;

    ret = krb5_ret_int32(sp, &v);
    if (ret == 0)
	*value = (uint32_t)v;

    return ret;
}

/**
 * Store a int16 to storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value to store
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_int16(krb5_storage *sp,
		 int16_t value)
{
    if(BYTEORDER_IS_HOST(sp))
	value = htons(value);
    else if(BYTEORDER_IS_LE(sp))
	value = bswap16(value);
    return krb5_store_int(sp, value, 2);
}

/**
 * Store a uint16 to storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value to store
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_uint16(krb5_storage *sp,
		  uint16_t value)
{
    return krb5_store_int16(sp, (int16_t)value);
}

/**
 * Read a int16 from storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value read from the buffer
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_int16(krb5_storage *sp,
	       int16_t *value)
{
    int32_t v;
    int ret;
    ret = krb5_ret_int(sp, &v, 2);
    if(ret)
	return ret;
    *value = v;
    if(BYTEORDER_IS_HOST(sp))
	*value = htons(*value);
    else if(BYTEORDER_IS_LE(sp))
	*value = bswap16(*value);
    return 0;
}

/**
 * Read a int16 from storage, byte order is controlled by the settings
 * on the storage, see krb5_storage_set_byteorder().
 *
 * @@param sp the storage to write too
 * @@param value the value read from the buffer
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_uint16(krb5_storage *sp,
		uint16_t *value)
{
    krb5_error_code ret;
    int16_t v;

    ret = krb5_ret_int16(sp, &v);
    if (ret == 0)
	*value = (uint16_t)v;

    return ret;
}

/**
 * Store a int8 to storage.
 *
 * @@param sp the storage to write too
 * @@param value the value to store
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_int8(krb5_storage *sp,
		int8_t value)
{
    int ret;

    ret = sp->store(sp, &value, sizeof(value));
    if (ret != sizeof(value))
	return (ret<0)?errno:sp->eof_code;
    return 0;
}

/**
 * Store a uint8 to storage.
 *
 * @@param sp the storage to write too
 * @@param value the value to store
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_uint8(krb5_storage *sp,
		 uint8_t value)
{
    return krb5_store_int8(sp, (int8_t)value);
}

/**
 * Read a int8 from storage
 *
 * @@param sp the storage to write too
 * @@param value the value read from the buffer
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_int8(krb5_storage *sp,
	      int8_t *value)
{
    int ret;

    ret = sp->fetch(sp, value, sizeof(*value));
    if (ret != sizeof(*value))
	return (ret<0)?errno:sp->eof_code;
    return 0;
}

/**
 * Read a uint8 from storage
 *
 * @@param sp the storage to write too
 * @@param value the value read from the buffer
 *
 * @@return 0 for success, or a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_uint8(krb5_storage *sp,
	       uint8_t *value)
{
    krb5_error_code ret;
    int8_t v;

    ret = krb5_ret_int8(sp, &v);
    if (ret == 0)
	*value = (uint8_t)v;

    return ret;
}

/**
 * Store a data to the storage. The data is stored with an int32 as
 * lenght plus the data (not padded).
 *
 * @@param sp the storage buffer to write to
 * @@param data the buffer to store.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_data(krb5_storage *sp,
		krb5_data data)
{
    int ret;
    ret = krb5_store_int32(sp, data.length);
    if(ret < 0)
	return ret;
    ret = sp->store(sp, data.data, data.length);
    if(ret < 0)
	return errno;
    if((size_t)ret != data.length)
	return sp->eof_code;
    return 0;
}

/**
 * Parse a data from the storage.
 *
 * @@param sp the storage buffer to read from
 * @@param data the parsed data
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_data(krb5_storage *sp,
	      krb5_data *data)
{
    int ret;
    int32_t size;

    ret = krb5_ret_int32(sp, &size);
    if(ret)
	return ret;
    ret = size_too_large(sp, size);
    if (ret)
	return ret;
    ret = krb5_data_alloc (data, size);
    if (ret)
	return ret;
    if (size) {
	ret = sp->fetch(sp, data->data, size);
	if(ret != size)
	    return (ret < 0)? errno : sp->eof_code;
    }
    return 0;
}

/**
 * Store a string to the buffer. The data is formated as an len:uint32
 * plus the string itself (not padded).
 *
 * @@param sp the storage buffer to write to
 * @@param s the string to store.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_string(krb5_storage *sp, const char *s)
{
    krb5_data data;
    data.length = strlen(s);
    data.data = rk_UNCONST(s);
    return krb5_store_data(sp, data);
}

/**
 * Parse a string from the storage.
 *
 * @@param sp the storage buffer to read from
 * @@param string the parsed string
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_string(krb5_storage *sp,
		char **string)
{
    int ret;
    krb5_data data;
    ret = krb5_ret_data(sp, &data);
    if(ret)
	return ret;
    *string = realloc(data.data, data.length + 1);
    if(*string == NULL){
	free(data.data);
	return ENOMEM;
    }
    (*string)[data.length] = 0;
    return 0;
}

/**
 * Store a zero terminated string to the buffer. The data is stored
 * one character at a time until a NUL is stored.
 *
 * @@param sp the storage buffer to write to
 * @@param s the string to store.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_stringz(krb5_storage *sp, const char *s)
{
    size_t len = strlen(s) + 1;
    ssize_t ret;

    ret = sp->store(sp, s, len);
    if(ret < 0)
	return ret;
    if((size_t)ret != len)
	return sp->eof_code;
    return 0;
}

/**
 * Parse zero terminated string from the storage.
 *
 * @@param sp the storage buffer to read from
 * @@param string the parsed string
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_stringz(krb5_storage *sp,
		char **string)
{
    char c;
    char *s = NULL;
    size_t len = 0;
    ssize_t ret;

    while((ret = sp->fetch(sp, &c, 1)) == 1){
	char *tmp;

	len++;
	ret = size_too_large(sp, len);
	if (ret)
	    break;
	tmp = realloc (s, len);
	if (tmp == NULL) {
	    free (s);
	    return ENOMEM;
	}
	s = tmp;
	s[len - 1] = c;
	if(c == 0)
	    break;
    }
    if(ret != 1){
	free(s);
	if(ret == 0)
	    return sp->eof_code;
	return ret;
    }
    *string = s;
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_stringnl(krb5_storage *sp, const char *s)
{
    size_t len = strlen(s);
    ssize_t ret;

    ret = sp->store(sp, s, len);
    if(ret < 0)
	return ret;
    if((size_t)ret != len)
	return sp->eof_code;
    ret = sp->store(sp, "\n", 1);
    if(ret != 1) {
	if(ret < 0)
	    return ret;
	else
	    return sp->eof_code;
    }

    return 0;

}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_stringnl(krb5_storage *sp,
		  char **string)
{
    int expect_nl = 0;
    char c;
    char *s = NULL;
    size_t len = 0;
    ssize_t ret;

    while((ret = sp->fetch(sp, &c, 1)) == 1){
	char *tmp;

	if (c == '\r') {
	    expect_nl = 1;
	    continue;
	}
	if (expect_nl && c != '\n') {
	    free(s);
	    return KRB5_BADMSGTYPE;
	}

	len++;
	ret = size_too_large(sp, len);
	if (ret)
	    break;
	tmp = realloc (s, len);
	if (tmp == NULL) {
	    free (s);
	    return ENOMEM;
	}
	s = tmp;
	if(c == '\n') {
	    s[len - 1] = '\0';
	    break;
	}
	s[len - 1] = c;
    }
    if(ret != 1){
	free(s);
	if(ret == 0)
	    return sp->eof_code;
	return ret;
    }
    *string = s;
    return 0;
}

/**
 * Write a principal block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param p the principal block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_principal(krb5_storage *sp,
		     krb5_const_principal p)
{
    size_t i;
    int ret;

    if(!krb5_storage_is_flags(sp, KRB5_STORAGE_PRINCIPAL_NO_NAME_TYPE)) {
	ret = krb5_store_int32(sp, p->name.name_type);
	if(ret) return ret;
    }
    if(krb5_storage_is_flags(sp, KRB5_STORAGE_PRINCIPAL_WRONG_NUM_COMPONENTS))
	ret = krb5_store_int32(sp, p->name.name_string.len + 1);
    else
	ret = krb5_store_int32(sp, p->name.name_string.len);

    if(ret) return ret;
    ret = krb5_store_string(sp, p->realm);
    if(ret) return ret;
    for(i = 0; i < p->name.name_string.len; i++){
	ret = krb5_store_string(sp, p->name.name_string.val[i]);
	if(ret) return ret;
    }
    return 0;
}

/**
 * Parse principal from the storage.
 *
 * @@param sp the storage buffer to read from
 * @@param princ the parsed principal
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_principal(krb5_storage *sp,
		   krb5_principal *princ)
{
    int i;
    int ret;
    krb5_principal p;
    int32_t type;
    int32_t ncomp;

    p = calloc(1, sizeof(*p));
    if(p == NULL)
	return ENOMEM;

    if(krb5_storage_is_flags(sp, KRB5_STORAGE_PRINCIPAL_NO_NAME_TYPE))
	type = KRB5_NT_UNKNOWN;
    else if((ret = krb5_ret_int32(sp, &type))){
	free(p);
	return ret;
    }
    if((ret = krb5_ret_int32(sp, &ncomp))){
	free(p);
	return ret;
    }
    if(krb5_storage_is_flags(sp, KRB5_STORAGE_PRINCIPAL_WRONG_NUM_COMPONENTS))
	ncomp--;
    if (ncomp < 0) {
	free(p);
	return EINVAL;
    }
    ret = size_too_large_num(sp, ncomp, sizeof(p->name.name_string.val[0]));
    if (ret) {
	free(p);
	return ret;
    }
    p->name.name_type = type;
    p->name.name_string.len = ncomp;
    ret = krb5_ret_string(sp, &p->realm);
    if(ret) {
	free(p);
	return ret;
    }
    p->name.name_string.val = calloc(ncomp, sizeof(p->name.name_string.val[0]));
    if(p->name.name_string.val == NULL && ncomp != 0){
	free(p->realm);
	free(p);
	return ENOMEM;
    }
    for(i = 0; i < ncomp; i++){
	ret = krb5_ret_string(sp, &p->name.name_string.val[i]);
	if(ret) {
	    while (i >= 0)
		free(p->name.name_string.val[i--]);
	    free(p->realm);
	    free(p);
	    return ret;
	}
    }
    *princ = p;
    return 0;
}

/**
 * Store a keyblock to the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param p the keyblock to write
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_keyblock(krb5_storage *sp, krb5_keyblock p)
{
    int ret;
    ret = krb5_store_int16(sp, p.keytype);
    if(ret) return ret;

    if(krb5_storage_is_flags(sp, KRB5_STORAGE_KEYBLOCK_KEYTYPE_TWICE)){
	/* this should really be enctype, but it is the same as
           keytype nowadays */
    ret = krb5_store_int16(sp, p.keytype);
    if(ret) return ret;
    }

    ret = krb5_store_data(sp, p.keyvalue);
    return ret;
}

/**
 * Read a keyblock from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param p the keyblock read from storage, free using krb5_free_keyblock()
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_keyblock(krb5_storage *sp, krb5_keyblock *p)
{
    int ret;
    int16_t tmp;

    ret = krb5_ret_int16(sp, &tmp);
    if(ret) return ret;
    p->keytype = tmp;

    if(krb5_storage_is_flags(sp, KRB5_STORAGE_KEYBLOCK_KEYTYPE_TWICE)){
    ret = krb5_ret_int16(sp, &tmp);
    if(ret) return ret;
    }

    ret = krb5_ret_data(sp, &p->keyvalue);
    return ret;
}

/**
 * Write a times block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param times the times block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_times(krb5_storage *sp, krb5_times times)
{
    int ret;
    ret = krb5_store_int32(sp, times.authtime);
    if(ret) return ret;
    ret = krb5_store_int32(sp, times.starttime);
    if(ret) return ret;
    ret = krb5_store_int32(sp, times.endtime);
    if(ret) return ret;
    ret = krb5_store_int32(sp, times.renew_till);
    return ret;
}

/**
 * Read a times block from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param times the times block read from storage
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_times(krb5_storage *sp, krb5_times *times)
{
    int ret;
    int32_t tmp;
    ret = krb5_ret_int32(sp, &tmp);
    times->authtime = tmp;
    if(ret) return ret;
    ret = krb5_ret_int32(sp, &tmp);
    times->starttime = tmp;
    if(ret) return ret;
    ret = krb5_ret_int32(sp, &tmp);
    times->endtime = tmp;
    if(ret) return ret;
    ret = krb5_ret_int32(sp, &tmp);
    times->renew_till = tmp;
    return ret;
}

/**
 * Write a address block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param p the address block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_address(krb5_storage *sp, krb5_address p)
{
    int ret;
    ret = krb5_store_int16(sp, p.addr_type);
    if(ret) return ret;
    ret = krb5_store_data(sp, p.address);
    return ret;
}

/**
 * Read a address block from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param adr the address block read from storage
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_address(krb5_storage *sp, krb5_address *adr)
{
    int16_t t;
    int ret;
    ret = krb5_ret_int16(sp, &t);
    if(ret) return ret;
    adr->addr_type = t;
    ret = krb5_ret_data(sp, &adr->address);
    return ret;
}

/**
 * Write a addresses block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param p the addresses block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_addrs(krb5_storage *sp, krb5_addresses p)
{
    size_t i;
    int ret;
    ret = krb5_store_int32(sp, p.len);
    if(ret) return ret;
    for(i = 0; i<p.len; i++){
	ret = krb5_store_address(sp, p.val[i]);
	if(ret) break;
    }
    return ret;
}

/**
 * Read a addresses block from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param adr the addresses block read from storage
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_addrs(krb5_storage *sp, krb5_addresses *adr)
{
    size_t i;
    int ret;
    int32_t tmp;

    ret = krb5_ret_int32(sp, &tmp);
    if(ret) return ret;
    ret = size_too_large_num(sp, tmp, sizeof(adr->val[0]));
    if (ret) return ret;
    adr->len = tmp;
    ALLOC(adr->val, adr->len);
    if (adr->val == NULL && adr->len != 0)
	return ENOMEM;
    for(i = 0; i < adr->len; i++){
	ret = krb5_ret_address(sp, &adr->val[i]);
	if(ret) break;
    }
    return ret;
}

/**
 * Write a auth data block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param auth the auth data block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_authdata(krb5_storage *sp, krb5_authdata auth)
{
    krb5_error_code ret;
    size_t i;
    ret = krb5_store_int32(sp, auth.len);
    if(ret) return ret;
    for(i = 0; i < auth.len; i++){
	ret = krb5_store_int16(sp, auth.val[i].ad_type);
	if(ret) break;
	ret = krb5_store_data(sp, auth.val[i].ad_data);
	if(ret) break;
    }
    return 0;
}

/**
 * Read a auth data from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param auth the auth data block read from storage
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_authdata(krb5_storage *sp, krb5_authdata *auth)
{
    krb5_error_code ret;
    int32_t tmp;
    int16_t tmp2;
    int i;
    ret = krb5_ret_int32(sp, &tmp);
    if(ret) return ret;
    ret = size_too_large_num(sp, tmp, sizeof(auth->val[0]));
    if (ret) return ret;
    ALLOC_SEQ(auth, tmp);
    if (auth->val == NULL && tmp != 0)
	return ENOMEM;
    for(i = 0; i < tmp; i++){
	ret = krb5_ret_int16(sp, &tmp2);
	if(ret) break;
	auth->val[i].ad_type = tmp2;
	ret = krb5_ret_data(sp, &auth->val[i].ad_data);
	if(ret) break;
    }
    return ret;
}

static int32_t
bitswap32(int32_t b)
{
    int32_t r = 0;
    int i;
    for (i = 0; i < 32; i++) {
	r = r << 1 | (b & 1);
	b = b >> 1;
    }
    return r;
}

/**
 * Write a credentials block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param creds the creds block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_creds(krb5_storage *sp, krb5_creds *creds)
{
    int ret;

    ret = krb5_store_principal(sp, creds->client);
    if(ret)
	return ret;
    ret = krb5_store_principal(sp, creds->server);
    if(ret)
	return ret;
    ret = krb5_store_keyblock(sp, creds->session);
    if(ret)
	return ret;
    ret = krb5_store_times(sp, creds->times);
    if(ret)
	return ret;
    ret = krb5_store_int8(sp, creds->second_ticket.length != 0); /* is_skey */
    if(ret)
	return ret;

    if(krb5_storage_is_flags(sp, KRB5_STORAGE_CREDS_FLAGS_WRONG_BITORDER))
	ret = krb5_store_int32(sp, creds->flags.i);
    else
	ret = krb5_store_int32(sp, bitswap32(TicketFlags2int(creds->flags.b)));
    if(ret)
	return ret;

    ret = krb5_store_addrs(sp, creds->addresses);
    if(ret)
	return ret;
    ret = krb5_store_authdata(sp, creds->authdata);
    if(ret)
	return ret;
    ret = krb5_store_data(sp, creds->ticket);
    if(ret)
	return ret;
    ret = krb5_store_data(sp, creds->second_ticket);
    return ret;
}

/**
 * Read a credentials block from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param creds the credentials block read from storage
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_creds(krb5_storage *sp, krb5_creds *creds)
{
    krb5_error_code ret;
    int8_t dummy8;
    int32_t dummy32;

    memset(creds, 0, sizeof(*creds));
    ret = krb5_ret_principal (sp,  &creds->client);
    if(ret) goto cleanup;
    ret = krb5_ret_principal (sp,  &creds->server);
    if(ret) goto cleanup;
    ret = krb5_ret_keyblock (sp,  &creds->session);
    if(ret) goto cleanup;
    ret = krb5_ret_times (sp,  &creds->times);
    if(ret) goto cleanup;
    ret = krb5_ret_int8 (sp,  &dummy8);
    if(ret) goto cleanup;
    ret = krb5_ret_int32 (sp,  &dummy32);
    if(ret) goto cleanup;
    /*
     * Runtime detect the what is the higher bits of the bitfield. If
     * any of the higher bits are set in the input data, it's either a
     * new ticket flag (and this code need to be removed), or it's a
     * MIT cache (or new Heimdal cache), lets change it to our current
     * format.
     */
    {
	uint32_t mask = 0xffff0000;
	creds->flags.i = 0;
	creds->flags.b.anonymous = 1;
	if (creds->flags.i & mask)
	    mask = ~mask;
	if (dummy32 & mask)
	    dummy32 = bitswap32(dummy32);
    }
    creds->flags.i = dummy32;
    ret = krb5_ret_addrs (sp,  &creds->addresses);
    if(ret) goto cleanup;
    ret = krb5_ret_authdata (sp,  &creds->authdata);
    if(ret) goto cleanup;
    ret = krb5_ret_data (sp,  &creds->ticket);
    if(ret) goto cleanup;
    ret = krb5_ret_data (sp,  &creds->second_ticket);
cleanup:
    if(ret) {
#if 0
	krb5_free_cred_contents(context, creds); /* XXX */
#endif
    }
    return ret;
}

#define SC_CLIENT_PRINCIPAL	    0x0001
#define SC_SERVER_PRINCIPAL	    0x0002
#define SC_SESSION_KEY		    0x0004
#define SC_TICKET		    0x0008
#define SC_SECOND_TICKET	    0x0010
#define SC_AUTHDATA		    0x0020
#define SC_ADDRESSES		    0x0040

/**
 * Write a tagged credentials block to storage.
 *
 * @@param sp the storage buffer to write to
 * @@param creds the creds block to write.
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_store_creds_tag(krb5_storage *sp, krb5_creds *creds)
{
    int ret;
    int32_t header = 0;

    if (creds->client)
	header |= SC_CLIENT_PRINCIPAL;
    if (creds->server)
	header |= SC_SERVER_PRINCIPAL;
    if (creds->session.keytype != ETYPE_NULL)
	header |= SC_SESSION_KEY;
    if (creds->ticket.data)
	header |= SC_TICKET;
    if (creds->second_ticket.length)
	header |= SC_SECOND_TICKET;
    if (creds->authdata.len)
	header |= SC_AUTHDATA;
    if (creds->addresses.len)
	header |= SC_ADDRESSES;

    ret = krb5_store_int32(sp, header);
    if (ret)
	return ret;

    if (creds->client) {
	ret = krb5_store_principal(sp, creds->client);
	if(ret)
	    return ret;
    }

    if (creds->server) {
	ret = krb5_store_principal(sp, creds->server);
	if(ret)
	    return ret;
    }

    if (creds->session.keytype != ETYPE_NULL) {
	ret = krb5_store_keyblock(sp, creds->session);
	if(ret)
	    return ret;
    }

    ret = krb5_store_times(sp, creds->times);
    if(ret)
	return ret;
    ret = krb5_store_int8(sp, creds->second_ticket.length != 0); /* is_skey */
    if(ret)
	return ret;

    ret = krb5_store_int32(sp, bitswap32(TicketFlags2int(creds->flags.b)));
    if(ret)
	return ret;

    if (creds->addresses.len) {
	ret = krb5_store_addrs(sp, creds->addresses);
	if(ret)
	    return ret;
    }

    if (creds->authdata.len) {
	ret = krb5_store_authdata(sp, creds->authdata);
	if(ret)
	    return ret;
    }

    if (creds->ticket.data) {
	ret = krb5_store_data(sp, creds->ticket);
	if(ret)
	    return ret;
    }

    if (creds->second_ticket.data) {
	ret = krb5_store_data(sp, creds->second_ticket);
	if (ret)
	    return ret;
    }

    return ret;
}

/**
 * Read a tagged credentials block from the storage.
 *
 * @@param sp the storage buffer to write to
 * @@param creds the credentials block read from storage
 *
 * @@return 0 on success, a Kerberos 5 error code on failure.
 *
 * @@ingroup krb5_storage
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_ret_creds_tag(krb5_storage *sp,
		   krb5_creds *creds)
{
    krb5_error_code ret;
    int8_t dummy8;
    int32_t dummy32, header;

    memset(creds, 0, sizeof(*creds));

    ret = krb5_ret_int32 (sp, &header);
    if (ret) goto cleanup;

    if (header & SC_CLIENT_PRINCIPAL) {
	ret = krb5_ret_principal (sp,  &creds->client);
	if(ret) goto cleanup;
    }
    if (header & SC_SERVER_PRINCIPAL) {
	ret = krb5_ret_principal (sp,  &creds->server);
	if(ret) goto cleanup;
    }
    if (header & SC_SESSION_KEY) {
	ret = krb5_ret_keyblock (sp,  &creds->session);
	if(ret) goto cleanup;
    }
    ret = krb5_ret_times (sp,  &creds->times);
    if(ret) goto cleanup;
    ret = krb5_ret_int8 (sp,  &dummy8);
    if(ret) goto cleanup;
    ret = krb5_ret_int32 (sp,  &dummy32);
    if(ret) goto cleanup;
    /*
     * Runtime detect the what is the higher bits of the bitfield. If
     * any of the higher bits are set in the input data, it's either a
     * new ticket flag (and this code need to be removed), or it's a
     * MIT cache (or new Heimdal cache), lets change it to our current
     * format.
     */
    {
	uint32_t mask = 0xffff0000;
	creds->flags.i = 0;
	creds->flags.b.anonymous = 1;
	if (creds->flags.i & mask)
	    mask = ~mask;
	if (dummy32 & mask)
	    dummy32 = bitswap32(dummy32);
    }
    creds->flags.i = dummy32;
    if (header & SC_ADDRESSES) {
	ret = krb5_ret_addrs (sp,  &creds->addresses);
	if(ret) goto cleanup;
    }
    if (header & SC_AUTHDATA) {
	ret = krb5_ret_authdata (sp,  &creds->authdata);
	if(ret) goto cleanup;
    }
    if (header & SC_TICKET) {
	ret = krb5_ret_data (sp,  &creds->ticket);
	if(ret) goto cleanup;
    }
    if (header & SC_SECOND_TICKET) {
	ret = krb5_ret_data (sp,  &creds->second_ticket);
	if(ret) goto cleanup;
    }

cleanup:
    if(ret) {
#if 0
	krb5_free_cred_contents(context, creds); /* XXX */
#endif
    }
    return ret;
}
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.2
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d2 30
a31 30
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a36 2
RCSID("$KTH: store.c,v 1.49 2005/06/01 10:40:05 lha Exp $");

d43 10
a52 1
void KRB5_LIB_FUNCTION
d58 10
a67 1
void KRB5_LIB_FUNCTION
d73 13
a85 1
krb5_boolean KRB5_LIB_FUNCTION
d91 13
a103 1
void KRB5_LIB_FUNCTION
d110 8
a117 2
krb5_flags KRB5_LIB_FUNCTION
krb5_storage_get_byteorder(krb5_storage *sp, krb5_flags byteorder)
d122 49
a170 1
off_t KRB5_LIB_FUNCTION
d176 30
a205 1
krb5_ssize_t KRB5_LIB_FUNCTION
d211 13
a223 1
krb5_ssize_t KRB5_LIB_FUNCTION
d229 10
a238 1
void KRB5_LIB_FUNCTION
d244 12
a255 2
krb5_ssize_t KRB5_LIB_FUNCTION
_krb5_put_int(void *buffer, unsigned long value, size_t size)
d257 1
a257 7
    unsigned char *p = buffer;
    int i;
    for (i = size - 1; i >= 0; i--) {
	p[i] = value & 0xff;
	value >>= 8;
    }
    return size;
d260 9
a268 11
krb5_ssize_t KRB5_LIB_FUNCTION
_krb5_get_int(void *buffer, unsigned long *value, size_t size)
{
    unsigned char *p = buffer;
    unsigned long v = 0;
    int i;
    for (i = 0; i < size; i++)
	v = (v << 8) + p[i];
    *value = v;
    return size;
}
d270 1
a270 1
krb5_error_code KRB5_LIB_FUNCTION
d280 12
a291 1
krb5_error_code KRB5_LIB_FUNCTION
d294 1
a294 2
    off_t pos;
    size_t size;
d298 7
a304 2
    size = (size_t)sp->seek(sp, 0, SEEK_END);
    ret = krb5_data_alloc (data, size);
d329 4
a332 2
    if (ret != len)
	return (ret<0)?errno:sp->eof_code;
d336 13
a348 1
krb5_error_code KRB5_LIB_FUNCTION
d359 19
d387 4
a390 2
    if(ret != len)
	return (ret<0)?errno:sp->eof_code;
d396 13
a408 1
krb5_error_code KRB5_LIB_FUNCTION
d422 39
a460 1
krb5_error_code KRB5_LIB_FUNCTION
d471 32
a502 1
krb5_error_code KRB5_LIB_FUNCTION
d519 38
a556 1
krb5_error_code KRB5_LIB_FUNCTION
d568 30
a597 1
krb5_error_code KRB5_LIB_FUNCTION
d609 38
a646 1
krb5_error_code KRB5_LIB_FUNCTION
d655 3
a657 3
    if(ret != data.length){
	if(ret < 0)
	    return errno;
a658 1
    }
d662 12
a673 1
krb5_error_code KRB5_LIB_FUNCTION
d683 3
d697 13
a709 1
krb5_error_code KRB5_LIB_FUNCTION
d714 1
a714 1
    data.data = (void*)s;
d718 13
a730 1
krb5_error_code KRB5_LIB_FUNCTION
d748 13
a760 1
krb5_error_code KRB5_LIB_FUNCTION
d767 67
a833 1
    if(ret != len) {
d839 1
d841 1
d844 3
a846 3
krb5_error_code KRB5_LIB_FUNCTION
krb5_ret_stringz(krb5_storage *sp,
		char **string)
d848 1
d857 9
d867 3
d876 4
a880 2
	if(c == 0)
	    break;
d892 10
d903 1
a903 1
krb5_error_code KRB5_LIB_FUNCTION
d905 1
a905 1
		     krb5_principal p)
d907 1
a907 1
    int i;
d911 2
a912 2
    ret = krb5_store_int32(sp, p->name.name_type);
    if(ret) return ret;
d917 2
a918 2
    ret = krb5_store_int32(sp, p->name.name_string.len);
    
d929 12
a940 1
krb5_error_code KRB5_LIB_FUNCTION
d949 1
a949 1
    
d970 5
d982 1
a982 1
    p->name.name_string.val = calloc(ncomp, sizeof(*p->name.name_string.val));
d985 1
d1002 12
a1013 1
krb5_error_code KRB5_LIB_FUNCTION
d1031 12
a1042 1
krb5_error_code KRB5_LIB_FUNCTION
d1061 12
a1072 1
krb5_error_code KRB5_LIB_FUNCTION
d1086 12
a1097 1
krb5_error_code KRB5_LIB_FUNCTION
d1116 12
a1127 1
krb5_error_code KRB5_LIB_FUNCTION
d1137 12
a1148 1
krb5_error_code KRB5_LIB_FUNCTION
d1160 12
a1171 1
krb5_error_code KRB5_LIB_FUNCTION
d1174 1
a1174 1
    int i;
d1185 12
a1196 1
krb5_error_code KRB5_LIB_FUNCTION
d1199 1
a1199 1
    int i;
d1205 2
d1218 12
a1229 1
krb5_error_code KRB5_LIB_FUNCTION
d1233 1
a1233 1
    int i;
d1245 12
a1256 1
krb5_error_code KRB5_LIB_FUNCTION
d1265 2
d1292 7
a1298 2

/*
d1300 1
d1303 1
a1303 1
krb5_error_code KRB5_LIB_FUNCTION
d1344 12
a1355 1
krb5_error_code KRB5_LIB_FUNCTION
d1377 2
a1378 2
     * any of the higher bits are set in the input data, its either a
     * new ticket flag (and this code need to be removed), or its a
d1383 1
a1383 1
	u_int32_t mask = 0xffff0000;
d1401 1
a1401 1
#if 0	
d1416 5
a1420 1
/*
d1422 3
d1427 2
a1428 3
krb5_error_code KRB5_LIB_FUNCTION
krb5_store_creds_tag(krb5_storage *sp,
		     krb5_creds *creds)
d1437 1
a1437 1
    if (creds->session.keyvalue.data)
d1449 2
d1464 1
a1464 1
    if (creds->session.keyvalue.data) {
d1508 12
a1519 1
krb5_error_code KRB5_LIB_FUNCTION
d1552 2
a1553 2
     * any of the higher bits are set in the input data, its either a
     * new ticket flag (and this code need to be removed), or its a
d1558 1
a1558 1
	u_int32_t mask = 0xffff0000;
d1586 1
a1586 1
#if 0	
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2000 Kungliga Tekniska Högskolan
d35 1
d37 1
a37 1
RCSID("$KTH: store.c,v 1.34 2000/04/11 00:46:09 assar Exp $");
d39 7
a45 1
void
d51 1
a51 1
void
d57 1
a57 1
krb5_boolean
d63 38
a100 1
ssize_t
d112 1
a112 1
ssize_t
d124 1
a124 1
krb5_error_code
d134 1
a134 1
krb5_error_code
d162 1
a162 1
    unsigned char v[4];
d164 2
d169 1
a169 1
	return (ret<0)?errno:KRB5_CC_END;
d173 1
a173 1
krb5_error_code
d177 1
a177 1
    if(krb5_storage_is_flags(sp, KRB5_STORAGE_HOST_BYTEORDER))
d179 2
d194 1
a194 1
	return (ret<0)?errno:KRB5_CC_END;
d200 1
a200 1
krb5_error_code
d207 4
a210 2
    if(krb5_storage_is_flags(sp, KRB5_STORAGE_HOST_BYTEORDER))
	*value = ntohl(*value);
d214 1
a214 1
krb5_error_code
d218 1
a218 1
    if(krb5_storage_is_flags(sp, KRB5_STORAGE_HOST_BYTEORDER))
d220 2
d225 1
a225 1
krb5_error_code
d235 4
a238 2
    if(krb5_storage_is_flags(sp, KRB5_STORAGE_HOST_BYTEORDER))
	*value = ntohs(*value);
d242 1
a242 1
krb5_error_code
d250 1
a250 1
	return (ret<0)?errno:KRB5_CC_END;
d254 1
a254 1
krb5_error_code
d262 1
a262 1
	return (ret<0)?errno:KRB5_CC_END;
d266 1
a266 1
krb5_error_code
d278 1
a278 1
	return KRB5_CC_END;
d283 1
a283 1
krb5_error_code
d299 1
a299 1
	    return (ret < 0)? errno : KRB5_CC_END;
d304 1
a304 1
krb5_error_code
d313 1
a313 1
krb5_error_code
d331 1
a331 1
krb5_error_code
d342 1
a342 1
	    return KRB5_CC_END;
d347 1
a347 1
krb5_error_code
d373 1
a373 1
	    return KRB5_CC_END;
d381 1
a381 1
krb5_error_code
d407 1
a407 1
krb5_error_code
d423 1
a423 1
    else 	if((ret = krb5_ret_int32(sp, &type))){
d433 4
d440 4
a443 1
    if(ret) return ret;
d445 1
a445 1
    if(p->name.name_string.val == NULL){
d451 7
a457 1
	if(ret) return ret; /* XXX */
d463 1
a463 1
krb5_error_code
d481 1
a481 1
krb5_error_code
d500 1
a500 1
krb5_error_code
d514 1
a514 1
krb5_error_code
d533 1
a533 1
krb5_error_code
d543 1
a543 1
krb5_error_code
d555 1
a555 1
krb5_error_code
d569 1
a569 1
krb5_error_code
d580 2
d589 1
a589 1
krb5_error_code
d605 1
a605 1
krb5_error_code
d615 2
d627 13
d641 1
a641 1
 * store `creds' on `sp' returning error or zero
d644 1
a644 1
krb5_error_code
d650 1
a650 1
    if (ret)
d653 1
a653 1
    if (ret)
d656 1
a656 1
    if (ret)
d659 1
a659 1
    if (ret)
d661 2
a662 3
    ret = krb5_store_int8(sp, 0);  /* this is probably the
				enc-tkt-in-skey bit from KDCOptions */
    if (ret)
d664 6
a669 2
    ret = krb5_store_int32(sp, creds->flags.i);
    if (ret)
d671 1
d673 1
a673 1
    if (ret)
d676 1
a676 1
    if (ret)
d679 1
a679 1
    if (ret)
d682 1
a682 3
    if (ret)
	return ret;
    return 0;
d685 1
a685 1
krb5_error_code
d705 16
d730 70
d801 96
d898 1
a898 1
	krb5_free_creds_contents(context, creds) /* XXX */
d900 1
a900 1
	    ;
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d36 1
a36 7
RCSID("$KTH: store.c,v 1.35 2001/05/11 13:01:43 joda Exp $");

#define BYTEORDER_IS(SP, V) (((SP)->flags & KRB5_STORAGE_BYTEORDER_MASK) == (V))
#define BYTEORDER_IS_LE(SP) BYTEORDER_IS((SP), KRB5_STORAGE_BYTEORDER_LE)
#define BYTEORDER_IS_BE(SP) BYTEORDER_IS((SP), KRB5_STORAGE_BYTEORDER_BE)
#define BYTEORDER_IS_HOST(SP) (BYTEORDER_IS((SP), KRB5_STORAGE_BYTEORDER_HOST) || \
			       krb5_storage_is_flags((SP), KRB5_STORAGE_HOST_BYTEORDER))
a55 14
void
krb5_storage_set_byteorder(krb5_storage *sp, krb5_flags byteorder)
{
    sp->flags &= ~KRB5_STORAGE_BYTEORDER_MASK;
    sp->flags |= byteorder;
}

krb5_flags
krb5_storage_get_byteorder(krb5_storage *sp, krb5_flags byteorder)
{
    return sp->flags & KRB5_STORAGE_BYTEORDER_MASK;
}


d118 1
a118 1
    unsigned char v[16];
a119 2
    if(len > sizeof(v))
	return EINVAL;
d131 1
a131 1
    if(BYTEORDER_IS_HOST(sp))
a132 2
    else if(BYTEORDER_IS_LE(sp))
	value = bswap32(value);
d159 2
a160 4
    if(BYTEORDER_IS_HOST(sp))
	*value = htonl(*value);
    else if(BYTEORDER_IS_LE(sp))
	*value = bswap32(*value);
d168 1
a168 1
    if(BYTEORDER_IS_HOST(sp))
a169 2
    else if(BYTEORDER_IS_LE(sp))
	value = bswap16(value);
d183 2
a184 4
    if(BYTEORDER_IS_HOST(sp))
	*value = htons(*value);
    else if(BYTEORDER_IS_LE(sp))
	*value = bswap16(*value);
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
a34 1
#include "store-int.h"
d36 1
a36 1
RCSID("$KTH: store.c,v 1.38 2002/08/21 12:21:57 joda Exp $");
a74 23
off_t
krb5_storage_seek(krb5_storage *sp, off_t offset, int whence)
{
    return (*sp->seek)(sp, offset, whence);
}

krb5_ssize_t
krb5_storage_read(krb5_storage *sp, void *buf, size_t len)
{
    return sp->fetch(sp, buf, len);
}

krb5_ssize_t
krb5_storage_write(krb5_storage *sp, const void *buf, size_t len)
{
    return sp->store(sp, buf, len);
}

void
krb5_storage_set_eof_code(krb5_storage *sp, int code)
{
    sp->eof_code = code;
}
d76 1
a76 1
krb5_ssize_t
d88 1
a88 1
krb5_ssize_t
d145 1
a145 1
	return (ret<0)?errno:sp->eof_code;
d170 1
a170 1
	return (ret<0)?errno:sp->eof_code;
d226 1
a226 1
	return (ret<0)?errno:sp->eof_code;
d238 1
a238 1
	return (ret<0)?errno:sp->eof_code;
d254 1
a254 1
	return sp->eof_code;
d275 1
a275 1
	    return (ret < 0)? errno : sp->eof_code;
d318 1
a318 1
	    return sp->eof_code;
d349 1
a349 1
	    return sp->eof_code;
d596 1
a596 1
    if(ret)
d599 1
a599 1
    if(ret)
d602 1
a602 1
    if(ret)
d605 1
a605 1
    if(ret)
d609 1
a609 1
    if(ret)
d612 1
a612 1
    if(ret)
d615 1
a615 1
    if(ret)
d618 1
a618 1
    if(ret)
d621 1
a621 1
    if(ret)
d624 3
a626 1
    return ret;
d658 1
a658 1
    if(ret) {
d660 1
a660 1
	krb5_free_creds_contents(context, creds); /* XXX */
d662 1
a662 1
    }
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d37 1
a37 1
RCSID("$KTH: store.c,v 1.38.4.1 2004/03/09 19:32:14 lha Exp $");
a609 13
static int32_t
bitswap32(int32_t b)
{
    int32_t r = 0;
    int i;
    for (i = 0; i < 32; i++) {
	r = r << 1 | (b & 1);
	b = b >> 1;
    }
    return r;
}


d611 1
a611 1
 *
d615 1
a615 1
_krb5_store_creds_internal(krb5_storage *sp, krb5_creds *creds, int v0_6)
d635 3
a637 9
    if (v0_6) {
	ret = krb5_store_int32(sp, creds->flags.i);
	if(ret)
	    return ret;
    } else {
	ret = krb5_store_int32(sp, bitswap32(TicketFlags2int(creds->flags.b)));
	if(ret)
	    return ret;
    }
a650 22
/*
 * store `creds' on `sp' returning error or zero
 */

krb5_error_code
krb5_store_creds(krb5_storage *sp, krb5_creds *creds)
{
    return _krb5_store_creds_internal(sp, creds, 1);
}

krb5_error_code
_krb5_store_creds_heimdal_0_7(krb5_storage *sp, krb5_creds *creds)
{
    return _krb5_store_creds_internal(sp, creds, 0);
}

krb5_error_code
_krb5_store_creds_heimdal_pre_0_7(krb5_storage *sp, krb5_creds *creds)
{
    return _krb5_store_creds_internal(sp, creds, 1);
}

a670 16
    /*
     * Runtime detect the what is the higher bits of the bitfield. If
     * any of the higher bits are set in the input data, its either a
     * new ticket flag (and this code need to be removed), or its a
     * MIT cache (or new Heimdal cache), lets change it to our current
     * format.
     */
    {
	u_int32_t mask = 0xffff0000;
	creds->flags.i = 0;
	creds->flags.b.anonymous = 1;
	if (creds->flags.i & mask)
	    mask = ~mask;
	if (dummy32 & mask)
	    dummy32 = bitswap32(dummy32);
    }
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: store.c,v 1.49 2005/06/01 10:40:05 lha Exp $");
d45 1
a45 1
void KRB5_LIB_FUNCTION
d51 1
a51 1
void KRB5_LIB_FUNCTION
d57 1
a57 1
krb5_boolean KRB5_LIB_FUNCTION
d63 1
a63 1
void KRB5_LIB_FUNCTION
d70 1
a70 1
krb5_flags KRB5_LIB_FUNCTION
d76 1
a76 1
off_t KRB5_LIB_FUNCTION
d82 1
a82 1
krb5_ssize_t KRB5_LIB_FUNCTION
d88 1
a88 1
krb5_ssize_t KRB5_LIB_FUNCTION
d94 1
a94 1
void KRB5_LIB_FUNCTION
d100 1
a100 1
krb5_ssize_t KRB5_LIB_FUNCTION
d112 1
a112 1
krb5_ssize_t KRB5_LIB_FUNCTION
d124 1
a124 1
krb5_error_code KRB5_LIB_FUNCTION
d134 1
a134 1
krb5_error_code KRB5_LIB_FUNCTION
d173 1
a173 1
krb5_error_code KRB5_LIB_FUNCTION
d200 1
a200 1
krb5_error_code KRB5_LIB_FUNCTION
d214 1
a214 1
krb5_error_code KRB5_LIB_FUNCTION
d225 1
a225 1
krb5_error_code KRB5_LIB_FUNCTION
d242 1
a242 1
krb5_error_code KRB5_LIB_FUNCTION
d254 1
a254 1
krb5_error_code KRB5_LIB_FUNCTION
d266 1
a266 1
krb5_error_code KRB5_LIB_FUNCTION
d283 1
a283 1
krb5_error_code KRB5_LIB_FUNCTION
d304 1
a304 1
krb5_error_code KRB5_LIB_FUNCTION
d313 1
a313 1
krb5_error_code KRB5_LIB_FUNCTION
d331 1
a331 1
krb5_error_code KRB5_LIB_FUNCTION
d347 1
a347 1
krb5_error_code KRB5_LIB_FUNCTION
d381 1
a381 1
krb5_error_code KRB5_LIB_FUNCTION
d407 1
a407 1
krb5_error_code KRB5_LIB_FUNCTION
d450 1
a450 1
krb5_error_code KRB5_LIB_FUNCTION
d468 1
a468 1
krb5_error_code KRB5_LIB_FUNCTION
d487 1
a487 1
krb5_error_code KRB5_LIB_FUNCTION
d501 1
a501 1
krb5_error_code KRB5_LIB_FUNCTION
d520 1
a520 1
krb5_error_code KRB5_LIB_FUNCTION
d530 1
a530 1
krb5_error_code KRB5_LIB_FUNCTION
d542 1
a542 1
krb5_error_code KRB5_LIB_FUNCTION
d556 1
a556 1
krb5_error_code KRB5_LIB_FUNCTION
a566 2
    if (adr->val == NULL && adr->len != 0)
	return ENOMEM;
d574 1
a574 1
krb5_error_code KRB5_LIB_FUNCTION
d590 1
a590 1
krb5_error_code KRB5_LIB_FUNCTION
a599 2
    if (auth->val == NULL && tmp != 0)
	return ENOMEM;
d627 2
a628 2
krb5_error_code KRB5_LIB_FUNCTION
krb5_store_creds(krb5_storage *sp, krb5_creds *creds)
d644 2
a645 1
    ret = krb5_store_int8(sp, creds->second_ticket.length != 0); /* is_skey */
d648 1
a648 2

    if(krb5_storage_is_flags(sp, KRB5_STORAGE_CREDS_FLAGS_WRONG_BITORDER))
d650 3
a652 1
    else
d654 3
a656 3
    if(ret)
	return ret;

d670 23
a692 1
krb5_error_code KRB5_LIB_FUNCTION
d739 1
a739 167
	krb5_free_cred_contents(context, creds); /* XXX */
#endif
    }
    return ret;
}

#define SC_CLIENT_PRINCIPAL	    0x0001
#define SC_SERVER_PRINCIPAL	    0x0002
#define SC_SESSION_KEY		    0x0004
#define SC_TICKET		    0x0008
#define SC_SECOND_TICKET	    0x0010
#define SC_AUTHDATA		    0x0020
#define SC_ADDRESSES		    0x0040

/*
 *
 */

krb5_error_code KRB5_LIB_FUNCTION
krb5_store_creds_tag(krb5_storage *sp,
		     krb5_creds *creds)
{
    int ret;
    int32_t header = 0;

    if (creds->client)
	header |= SC_CLIENT_PRINCIPAL;
    if (creds->server)
	header |= SC_SERVER_PRINCIPAL;
    if (creds->session.keyvalue.data)
	header |= SC_SESSION_KEY;
    if (creds->ticket.data)
	header |= SC_TICKET;
    if (creds->second_ticket.length)
	header |= SC_SECOND_TICKET;
    if (creds->authdata.len)
	header |= SC_AUTHDATA;
    if (creds->addresses.len)
	header |= SC_ADDRESSES;

    ret = krb5_store_int32(sp, header);

    if (creds->client) {
	ret = krb5_store_principal(sp, creds->client);
	if(ret)
	    return ret;
    }

    if (creds->server) {
	ret = krb5_store_principal(sp, creds->server);
	if(ret)
	    return ret;
    }

    if (creds->session.keyvalue.data) {
	ret = krb5_store_keyblock(sp, creds->session);
	if(ret)
	    return ret;
    }

    ret = krb5_store_times(sp, creds->times);
    if(ret)
	return ret;
    ret = krb5_store_int8(sp, creds->second_ticket.length != 0); /* is_skey */
    if(ret)
	return ret;

    ret = krb5_store_int32(sp, bitswap32(TicketFlags2int(creds->flags.b)));
    if(ret)
	return ret;

    if (creds->addresses.len) {
	ret = krb5_store_addrs(sp, creds->addresses);
	if(ret)
	    return ret;
    }

    if (creds->authdata.len) {
	ret = krb5_store_authdata(sp, creds->authdata);
	if(ret)
	    return ret;
    }

    if (creds->ticket.data) {
	ret = krb5_store_data(sp, creds->ticket);
	if(ret)
	    return ret;
    }

    if (creds->second_ticket.data) {
	ret = krb5_store_data(sp, creds->second_ticket);
	if (ret)
	    return ret;
    }

    return ret;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_ret_creds_tag(krb5_storage *sp,
		   krb5_creds *creds)
{
    krb5_error_code ret;
    int8_t dummy8;
    int32_t dummy32, header;

    memset(creds, 0, sizeof(*creds));

    ret = krb5_ret_int32 (sp, &header);
    if (ret) goto cleanup;

    if (header & SC_CLIENT_PRINCIPAL) {
	ret = krb5_ret_principal (sp,  &creds->client);
	if(ret) goto cleanup;
    }
    if (header & SC_SERVER_PRINCIPAL) {
	ret = krb5_ret_principal (sp,  &creds->server);
	if(ret) goto cleanup;
    }
    if (header & SC_SESSION_KEY) {
	ret = krb5_ret_keyblock (sp,  &creds->session);
	if(ret) goto cleanup;
    }
    ret = krb5_ret_times (sp,  &creds->times);
    if(ret) goto cleanup;
    ret = krb5_ret_int8 (sp,  &dummy8);
    if(ret) goto cleanup;
    ret = krb5_ret_int32 (sp,  &dummy32);
    if(ret) goto cleanup;
    /*
     * Runtime detect the what is the higher bits of the bitfield. If
     * any of the higher bits are set in the input data, its either a
     * new ticket flag (and this code need to be removed), or its a
     * MIT cache (or new Heimdal cache), lets change it to our current
     * format.
     */
    {
	u_int32_t mask = 0xffff0000;
	creds->flags.i = 0;
	creds->flags.b.anonymous = 1;
	if (creds->flags.i & mask)
	    mask = ~mask;
	if (dummy32 & mask)
	    dummy32 = bitswap32(dummy32);
    }
    creds->flags.i = dummy32;
    if (header & SC_ADDRESSES) {
	ret = krb5_ret_addrs (sp,  &creds->addresses);
	if(ret) goto cleanup;
    }
    if (header & SC_AUTHDATA) {
	ret = krb5_ret_authdata (sp,  &creds->authdata);
	if(ret) goto cleanup;
    }
    if (header & SC_TICKET) {
	ret = krb5_ret_data (sp,  &creds->ticket);
	if(ret) goto cleanup;
    }
    if (header & SC_SECOND_TICKET) {
	ret = krb5_ret_data (sp,  &creds->second_ticket);
	if(ret) goto cleanup;
    }

cleanup:
    if(ret) {
#if 0	
	krb5_free_cred_contents(context, creds); /* XXX */
@


