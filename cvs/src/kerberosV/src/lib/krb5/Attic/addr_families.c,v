head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.26
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.24
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.22
	OPENBSD_5_0:1.4.0.20
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.18
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.16
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.12
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.14
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.10
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.8
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.4.0.8
	OPENBSD_3_7_BASE:1.1.1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.6
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.5;

1.5
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.20.20.28.54;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.33;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.33;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.18;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.22;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.48;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.12;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.6
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2007 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"

struct addr_operations {
    int af;
    krb5_address_type atype;
    size_t max_sockaddr_size;
    krb5_error_code (*sockaddr2addr)(const struct sockaddr *, krb5_address *);
    krb5_error_code (*sockaddr2port)(const struct sockaddr *, int16_t *);
    void (*addr2sockaddr)(const krb5_address *, struct sockaddr *,
			  krb5_socklen_t *sa_size, int port);
    void (*h_addr2sockaddr)(const char *, struct sockaddr *, krb5_socklen_t *, int);
    krb5_error_code (*h_addr2addr)(const char *, krb5_address *);
    krb5_boolean (*uninteresting)(const struct sockaddr *);
    krb5_boolean (*is_loopback)(const struct sockaddr *);
    void (*anyaddr)(struct sockaddr *, krb5_socklen_t *, int);
    int (*print_addr)(const krb5_address *, char *, size_t);
    int (*parse_addr)(krb5_context, const char*, krb5_address *);
    int (*order_addr)(krb5_context, const krb5_address*, const krb5_address*);
    int (*free_addr)(krb5_context, krb5_address*);
    int (*copy_addr)(krb5_context, const krb5_address*, krb5_address*);
    int (*mask_boundary)(krb5_context, const krb5_address*, unsigned long,
			 krb5_address*, krb5_address*);
};

/*
 * AF_INET - aka IPv4 implementation
 */

static krb5_error_code
ipv4_sockaddr2addr (const struct sockaddr *sa, krb5_address *a)
{
    const struct sockaddr_in *sin4 = (const struct sockaddr_in *)sa;
    unsigned char buf[4];

    a->addr_type = KRB5_ADDRESS_INET;
    memcpy (buf, &sin4->sin_addr, 4);
    return krb5_data_copy(&a->address, buf, 4);
}

static krb5_error_code
ipv4_sockaddr2port (const struct sockaddr *sa, int16_t *port)
{
    const struct sockaddr_in *sin4 = (const struct sockaddr_in *)sa;

    *port = sin4->sin_port;
    return 0;
}

static void
ipv4_addr2sockaddr (const krb5_address *a,
		    struct sockaddr *sa,
		    krb5_socklen_t *sa_size,
		    int port)
{
    struct sockaddr_in tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.sin_family = AF_INET;
    memcpy (&tmp.sin_addr, a->address.data, 4);
    tmp.sin_port = port;
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
}

static void
ipv4_h_addr2sockaddr(const char *addr,
		     struct sockaddr *sa,
		     krb5_socklen_t *sa_size,
		     int port)
{
    struct sockaddr_in tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.sin_family = AF_INET;
    tmp.sin_port   = port;
    tmp.sin_addr   = *((const struct in_addr *)addr);
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
}

static krb5_error_code
ipv4_h_addr2addr (const char *addr,
		  krb5_address *a)
{
    unsigned char buf[4];

    a->addr_type = KRB5_ADDRESS_INET;
    memcpy(buf, addr, 4);
    return krb5_data_copy(&a->address, buf, 4);
}

/*
 * Are there any addresses that should be considered `uninteresting'?
 */

static krb5_boolean
ipv4_uninteresting (const struct sockaddr *sa)
{
    const struct sockaddr_in *sin4 = (const struct sockaddr_in *)sa;

    if (sin4->sin_addr.s_addr == INADDR_ANY)
	return TRUE;

    return FALSE;
}

static krb5_boolean
ipv4_is_loopback (const struct sockaddr *sa)
{
    const struct sockaddr_in *sin4 = (const struct sockaddr_in *)sa;

    if ((ntohl(sin4->sin_addr.s_addr) >> 24) == IN_LOOPBACKNET)
	return TRUE;

    return FALSE;
}

static void
ipv4_anyaddr (struct sockaddr *sa, krb5_socklen_t *sa_size, int port)
{
    struct sockaddr_in tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.sin_family = AF_INET;
    tmp.sin_port   = port;
    tmp.sin_addr.s_addr = INADDR_ANY;
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
}

static int
ipv4_print_addr (const krb5_address *addr, char *str, size_t len)
{
    struct in_addr ia;

    memcpy (&ia, addr->address.data, 4);

    return snprintf (str, len, "IPv4:%s", inet_ntoa(ia));
}

static int
ipv4_parse_addr (krb5_context context, const char *address, krb5_address *addr)
{
    const char *p;
    struct in_addr a;

    p = strchr(address, ':');
    if(p) {
	p++;
	if(strncasecmp(address, "ip:", p - address) != 0 &&
	   strncasecmp(address, "ip4:", p - address) != 0 &&
	   strncasecmp(address, "ipv4:", p - address) != 0 &&
	   strncasecmp(address, "inet:", p - address) != 0)
	    return -1;
    } else
	p = address;
    if(inet_aton(p, &a) == 0)
	return -1;
    addr->addr_type = KRB5_ADDRESS_INET;
    if(krb5_data_alloc(&addr->address, 4) != 0)
	return -1;
    _krb5_put_int(addr->address.data, ntohl(a.s_addr), addr->address.length);
    return 0;
}

static int
ipv4_mask_boundary(krb5_context context, const krb5_address *inaddr,
		   unsigned long len, krb5_address *low, krb5_address *high)
{
    unsigned long ia;
    uint32_t l, h, m = 0xffffffff;

    if (len > 32) {
	krb5_set_error_message(context, KRB5_PROG_ATYPE_NOSUPP,
			       N_("IPv4 prefix too large (%ld)", "len"), len);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    m = m << (32 - len);

    _krb5_get_int(inaddr->address.data, &ia, inaddr->address.length);

    l = ia & m;
    h = l | ~m;

    low->addr_type = KRB5_ADDRESS_INET;
    if(krb5_data_alloc(&low->address, 4) != 0)
	return -1;
    _krb5_put_int(low->address.data, l, low->address.length);

    high->addr_type = KRB5_ADDRESS_INET;
    if(krb5_data_alloc(&high->address, 4) != 0) {
	krb5_free_address(context, low);
	return -1;
    }
    _krb5_put_int(high->address.data, h, high->address.length);

    return 0;
}


/*
 * AF_INET6 - aka IPv6 implementation
 */

#ifdef HAVE_IPV6

static krb5_error_code
ipv6_sockaddr2addr (const struct sockaddr *sa, krb5_address *a)
{
    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)sa;

    if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
	unsigned char buf[4];

	a->addr_type      = KRB5_ADDRESS_INET;
#ifndef IN6_ADDR_V6_TO_V4
#ifdef IN6_EXTRACT_V4ADDR
#define IN6_ADDR_V6_TO_V4(x) (&IN6_EXTRACT_V4ADDR(x))
#else
#define IN6_ADDR_V6_TO_V4(x) ((const struct in_addr *)&(x)->s6_addr[12])
#endif
#endif
	memcpy (buf, IN6_ADDR_V6_TO_V4(&sin6->sin6_addr), 4);
	return krb5_data_copy(&a->address, buf, 4);
    } else {
	a->addr_type = KRB5_ADDRESS_INET6;
	return krb5_data_copy(&a->address,
			      &sin6->sin6_addr,
			      sizeof(sin6->sin6_addr));
    }
}

static krb5_error_code
ipv6_sockaddr2port (const struct sockaddr *sa, int16_t *port)
{
    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)sa;

    *port = sin6->sin6_port;
    return 0;
}

static void
ipv6_addr2sockaddr (const krb5_address *a,
		    struct sockaddr *sa,
		    krb5_socklen_t *sa_size,
		    int port)
{
    struct sockaddr_in6 tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.sin6_family = AF_INET6;
    memcpy (&tmp.sin6_addr, a->address.data, sizeof(tmp.sin6_addr));
    tmp.sin6_port = port;
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
}

static void
ipv6_h_addr2sockaddr(const char *addr,
		     struct sockaddr *sa,
		     krb5_socklen_t *sa_size,
		     int port)
{
    struct sockaddr_in6 tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.sin6_family = AF_INET6;
    tmp.sin6_port   = port;
    tmp.sin6_addr   = *((const struct in6_addr *)addr);
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
}

static krb5_error_code
ipv6_h_addr2addr (const char *addr,
		  krb5_address *a)
{
    a->addr_type = KRB5_ADDRESS_INET6;
    return krb5_data_copy(&a->address, addr, sizeof(struct in6_addr));
}

/*
 *
 */

static krb5_boolean
ipv6_uninteresting (const struct sockaddr *sa)
{
    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)sa;
    const struct in6_addr *in6 = (const struct in6_addr *)&sin6->sin6_addr;

    return IN6_IS_ADDR_LINKLOCAL(in6)
	|| IN6_IS_ADDR_V4COMPAT(in6);
}

static krb5_boolean
ipv6_is_loopback (const struct sockaddr *sa)
{
    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)sa;
    const struct in6_addr *in6 = (const struct in6_addr *)&sin6->sin6_addr;

    return (IN6_IS_ADDR_LOOPBACK(in6));
}

static void
ipv6_anyaddr (struct sockaddr *sa, krb5_socklen_t *sa_size, int port)
{
    struct sockaddr_in6 tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.sin6_family = AF_INET6;
    tmp.sin6_port   = port;
    tmp.sin6_addr   = in6addr_any;
    *sa_size = sizeof(tmp);
}

static int
ipv6_print_addr (const krb5_address *addr, char *str, size_t len)
{
    char buf[128], buf2[3];
    if(inet_ntop(AF_INET6, addr->address.data, buf, sizeof(buf)) == NULL)
	{
	    /* XXX this is pretty ugly, but better than abort() */
	    size_t i;
	    unsigned char *p = addr->address.data;
	    buf[0] = '\0';
	    for(i = 0; i < addr->address.length; i++) {
		snprintf(buf2, sizeof(buf2), "%02x", p[i]);
		if(i > 0 && (i & 1) == 0)
		    strlcat(buf, ":", sizeof(buf));
		strlcat(buf, buf2, sizeof(buf));
	    }
	}
    return snprintf(str, len, "IPv6:%s", buf);
}

static int
ipv6_parse_addr (krb5_context context, const char *address, krb5_address *addr)
{
    int ret;
    struct in6_addr in6;
    const char *p;

    p = strchr(address, ':');
    if(p) {
	p++;
	if(strncasecmp(address, "ip6:", p - address) == 0 ||
	   strncasecmp(address, "ipv6:", p - address) == 0 ||
	   strncasecmp(address, "inet6:", p - address) == 0)
	    address = p;
    }

    ret = inet_pton(AF_INET6, address, &in6.s6_addr);
    if(ret == 1) {
	addr->addr_type = KRB5_ADDRESS_INET6;
	ret = krb5_data_alloc(&addr->address, sizeof(in6.s6_addr));
	if (ret)
	    return -1;
	memcpy(addr->address.data, in6.s6_addr, sizeof(in6.s6_addr));
	return 0;
    }
    return -1;
}

static int
ipv6_mask_boundary(krb5_context context, const krb5_address *inaddr,
		   unsigned long len, krb5_address *low, krb5_address *high)
{
    struct in6_addr addr, laddr, haddr;
    uint32_t m;
    int i, sub_len;

    if (len > 128) {
	krb5_set_error_message(context, KRB5_PROG_ATYPE_NOSUPP,
			       N_("IPv6 prefix too large (%ld)", "length"), len);
	return KRB5_PROG_ATYPE_NOSUPP;
    }

    if (inaddr->address.length != sizeof(addr)) {
	krb5_set_error_message(context, KRB5_PROG_ATYPE_NOSUPP,
			       N_("IPv6 addr bad length", ""));
	return KRB5_PROG_ATYPE_NOSUPP;
    }

    memcpy(&addr, inaddr->address.data, inaddr->address.length);

    for (i = 0; i < 16; i++) {
	sub_len = min(8, len);

	m = 0xff << (8 - sub_len);

	laddr.s6_addr[i] = addr.s6_addr[i] & m;
	haddr.s6_addr[i] = (addr.s6_addr[i] & m) | ~m;

	if (len > 8)
	    len -= 8;
	else
	    len = 0;
    }

    low->addr_type = KRB5_ADDRESS_INET6;
    if (krb5_data_alloc(&low->address, sizeof(laddr.s6_addr)) != 0)
	return -1;
    memcpy(low->address.data, laddr.s6_addr, sizeof(laddr.s6_addr));

    high->addr_type = KRB5_ADDRESS_INET6;
    if (krb5_data_alloc(&high->address, sizeof(haddr.s6_addr)) != 0) {
	krb5_free_address(context, low);
	return -1;
    }
    memcpy(high->address.data, haddr.s6_addr, sizeof(haddr.s6_addr));

    return 0;
}

#endif /* IPv6 */

#ifndef HEIMDAL_SMALLER

/*
 * table
 */

#define KRB5_ADDRESS_ARANGE	(-100)

struct arange {
    krb5_address low;
    krb5_address high;
};

static int
arange_parse_addr (krb5_context context,
		   const char *address, krb5_address *addr)
{
    char buf[1024], *p;
    krb5_address low0, high0;
    struct arange *a;
    krb5_error_code ret;

    if(strncasecmp(address, "RANGE:", 6) != 0)
	return -1;

    address += 6;

    p = strrchr(address, '/');
    if (p) {
	krb5_addresses addrmask;
	char *q;
	long num;

	if (strlcpy(buf, address, sizeof(buf)) > sizeof(buf))
	    return -1;
	buf[p - address] = '\0';
	ret = krb5_parse_address(context, buf, &addrmask);
	if (ret)
	    return ret;
	if(addrmask.len != 1) {
	    krb5_free_addresses(context, &addrmask);
	    return -1;
	}

	address += p - address + 1;

	num = strtol(address, &q, 10);
	if (q == address || *q != '\0' || num < 0) {
	    krb5_free_addresses(context, &addrmask);
	    return -1;
	}

	ret = krb5_address_prefixlen_boundary(context, &addrmask.val[0], num,
					      &low0, &high0);
	krb5_free_addresses(context, &addrmask);
	if (ret)
	    return ret;

    } else {
	krb5_addresses low, high;

	strsep_copy(&address, "-", buf, sizeof(buf));
	ret = krb5_parse_address(context, buf, &low);
	if(ret)
	    return ret;
	if(low.len != 1) {
	    krb5_free_addresses(context, &low);
	    return -1;
	}

	strsep_copy(&address, "-", buf, sizeof(buf));
	ret = krb5_parse_address(context, buf, &high);
	if(ret) {
	    krb5_free_addresses(context, &low);
	    return ret;
	}

	if(high.len != 1 && high.val[0].addr_type != low.val[0].addr_type) {
	    krb5_free_addresses(context, &low);
	    krb5_free_addresses(context, &high);
	    return -1;
	}

	ret = krb5_copy_address(context, &high.val[0], &high0);
	if (ret == 0) {
	    ret = krb5_copy_address(context, &low.val[0], &low0);
	    if (ret)
		krb5_free_address(context, &high0);
	}
	krb5_free_addresses(context, &low);
	krb5_free_addresses(context, &high);
	if (ret)
	    return ret;
    }

    krb5_data_alloc(&addr->address, sizeof(*a));
    addr->addr_type = KRB5_ADDRESS_ARANGE;
    a = addr->address.data;

    if(krb5_address_order(context, &low0, &high0) < 0) {
	a->low = low0;
	a->high = high0;
    } else {
	a->low = high0;
	a->high = low0;
    }
    return 0;
}

static int
arange_free (krb5_context context, krb5_address *addr)
{
    struct arange *a;
    a = addr->address.data;
    krb5_free_address(context, &a->low);
    krb5_free_address(context, &a->high);
    krb5_data_free(&addr->address);
    return 0;
}


static int
arange_copy (krb5_context context, const krb5_address *inaddr,
	     krb5_address *outaddr)
{
    krb5_error_code ret;
    struct arange *i, *o;

    outaddr->addr_type = KRB5_ADDRESS_ARANGE;
    ret = krb5_data_alloc(&outaddr->address, sizeof(*o));
    if(ret)
	return ret;
    i = inaddr->address.data;
    o = outaddr->address.data;
    ret = krb5_copy_address(context, &i->low, &o->low);
    if(ret) {
	krb5_data_free(&outaddr->address);
	return ret;
    }
    ret = krb5_copy_address(context, &i->high, &o->high);
    if(ret) {
	krb5_free_address(context, &o->low);
	krb5_data_free(&outaddr->address);
	return ret;
    }
    return 0;
}

static int
arange_print_addr (const krb5_address *addr, char *str, size_t len)
{
    struct arange *a;
    krb5_error_code ret;
    size_t l, size, ret_len;

    a = addr->address.data;

    l = strlcpy(str, "RANGE:", len);
    ret_len = l;
    if (l > len)
	l = len;
    size = l;

    ret = krb5_print_address (&a->low, str + size, len - size, &l);
    if (ret)
	return ret;
    ret_len += l;
    if (len - size > l)
	size += l;
    else
	size = len;

    l = strlcat(str + size, "-", len - size);
    ret_len += l;
    if (len - size > l)
	size += l;
    else
	size = len;

    ret = krb5_print_address (&a->high, str + size, len - size, &l);
    if (ret)
	return ret;
    ret_len += l;

    return ret_len;
}

static int
arange_order_addr(krb5_context context,
		  const krb5_address *addr1,
		  const krb5_address *addr2)
{
    int tmp1, tmp2, sign;
    struct arange *a;
    const krb5_address *a2;

    if(addr1->addr_type == KRB5_ADDRESS_ARANGE) {
	a = addr1->address.data;
	a2 = addr2;
	sign = 1;
    } else if(addr2->addr_type == KRB5_ADDRESS_ARANGE) {
	a = addr2->address.data;
	a2 = addr1;
	sign = -1;
    } else {
	abort();
        UNREACHABLE(return 0);
    }

    if(a2->addr_type == KRB5_ADDRESS_ARANGE) {
	struct arange *b = a2->address.data;
	tmp1 = krb5_address_order(context, &a->low, &b->low);
	if(tmp1 != 0)
	    return sign * tmp1;
	return sign * krb5_address_order(context, &a->high, &b->high);
    } else if(a2->addr_type == a->low.addr_type) {
	tmp1 = krb5_address_order(context, &a->low, a2);
	if(tmp1 > 0)
	    return sign;
	tmp2 = krb5_address_order(context, &a->high, a2);
	if(tmp2 < 0)
	    return -sign;
	return 0;
    } else {
	return sign * (addr1->addr_type - addr2->addr_type);
    }
}

#endif /* HEIMDAL_SMALLER */

static int
addrport_print_addr (const krb5_address *addr, char *str, size_t len)
{
    krb5_error_code ret;
    krb5_address addr1, addr2;
    uint16_t port = 0;
    size_t ret_len = 0, l, size = 0;
    krb5_storage *sp;

    sp = krb5_storage_from_data((krb5_data*)rk_UNCONST(&addr->address));
    if (sp == NULL)
        return ENOMEM;

    /* for totally obscure reasons, these are not in network byteorder */
    krb5_storage_set_byteorder(sp, KRB5_STORAGE_BYTEORDER_LE);

    krb5_storage_seek(sp, 2, SEEK_CUR); /* skip first two bytes */
    krb5_ret_address(sp, &addr1);

    krb5_storage_seek(sp, 2, SEEK_CUR); /* skip two bytes */
    krb5_ret_address(sp, &addr2);
    krb5_storage_free(sp);
    if(addr2.addr_type == KRB5_ADDRESS_IPPORT && addr2.address.length == 2) {
	unsigned long value;
	_krb5_get_int(addr2.address.data, &value, 2);
	port = value;
    }
    l = strlcpy(str, "ADDRPORT:", len);
    ret_len += l;
    if (len > l)
	size += l;
    else
	size = len;

    ret = krb5_print_address(&addr1, str + size, len - size, &l);
    if (ret)
	return ret;
    ret_len += l;
    if (len - size > l)
	size += l;
    else
	size = len;

    ret = snprintf(str + size, len - size, ",PORT=%u", port);
    if (ret < 0)
	return EINVAL;
    ret_len += ret;
    return ret_len;
}

static struct addr_operations at[] = {
    {
	AF_INET,	KRB5_ADDRESS_INET, sizeof(struct sockaddr_in),
	ipv4_sockaddr2addr,
	ipv4_sockaddr2port,
	ipv4_addr2sockaddr,
	ipv4_h_addr2sockaddr,
	ipv4_h_addr2addr,
	ipv4_uninteresting,
	ipv4_is_loopback,
	ipv4_anyaddr,
	ipv4_print_addr,
	ipv4_parse_addr,
	NULL,
	NULL,
	NULL,
     ipv4_mask_boundary
    },
#ifdef HAVE_IPV6
    {
	AF_INET6,	KRB5_ADDRESS_INET6, sizeof(struct sockaddr_in6),
	ipv6_sockaddr2addr,
	ipv6_sockaddr2port,
	ipv6_addr2sockaddr,
	ipv6_h_addr2sockaddr,
	ipv6_h_addr2addr,
	ipv6_uninteresting,
	ipv6_is_loopback,
	ipv6_anyaddr,
	ipv6_print_addr,
	ipv6_parse_addr,
	NULL,
	NULL,
	NULL,
	ipv6_mask_boundary
    } ,
#endif
#ifndef HEIMDAL_SMALLER
    /* fake address type */
    {
	KRB5_ADDRESS_ARANGE, KRB5_ADDRESS_ARANGE, sizeof(struct arange),
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	arange_print_addr,
	arange_parse_addr,
	arange_order_addr,
	arange_free,
	arange_copy,
	NULL
    },
#endif
    {
	KRB5_ADDRESS_ADDRPORT, KRB5_ADDRESS_ADDRPORT, 0,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	addrport_print_addr,
	NULL,
	NULL,
	NULL,
	NULL
    }
};

static int num_addrs = sizeof(at) / sizeof(at[0]);

static size_t max_sockaddr_size = 0;

/*
 * generic functions
 */

static struct addr_operations *
find_af(int af)
{
    struct addr_operations *a;

    for (a = at; a < at + num_addrs; ++a)
	if (af == a->af)
	    return a;
    return NULL;
}

static struct addr_operations *
find_atype(krb5_address_type atype)
{
    struct addr_operations *a;

    for (a = at; a < at + num_addrs; ++a)
	if (atype == a->atype)
	    return a;
    return NULL;
}

/**
 * krb5_sockaddr2address stores a address a "struct sockaddr" sa in
 * the krb5_address addr.
 *
 * @@param context a Keberos context
 * @@param sa a struct sockaddr to extract the address from
 * @@param addr an Kerberos 5 address to store the address in.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sockaddr2address (krb5_context context,
		       const struct sockaddr *sa, krb5_address *addr)
{
    struct addr_operations *a = find_af(sa->sa_family);
    if (a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address family %d not supported", ""),
				sa->sa_family);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    return (*a->sockaddr2addr)(sa, addr);
}

/**
 * krb5_sockaddr2port extracts a port (if possible) from a "struct
 * sockaddr.
 *
 * @@param context a Keberos context
 * @@param sa a struct sockaddr to extract the port from
 * @@param port a pointer to an int16_t store the port in.
 *
 * @@return Return an error code or 0. Will return
 * KRB5_PROG_ATYPE_NOSUPP in case address type is not supported.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_sockaddr2port (krb5_context context,
		    const struct sockaddr *sa, int16_t *port)
{
    struct addr_operations *a = find_af(sa->sa_family);
    if (a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address family %d not supported", ""),
				sa->sa_family);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    return (*a->sockaddr2port)(sa, port);
}

/**
 * krb5_addr2sockaddr sets the "struct sockaddr sockaddr" from addr
 * and port. The argument sa_size should initially contain the size of
 * the sa and after the call, it will contain the actual length of the
 * address. In case of the sa is too small to fit the whole address,
 * the up to *sa_size will be stored, and then *sa_size will be set to
 * the required length.
 *
 * @@param context a Keberos context
 * @@param addr the address to copy the from
 * @@param sa the struct sockaddr that will be filled in
 * @@param sa_size pointer to length of sa, and after the call, it will
 * contain the actual length of the address.
 * @@param port set port in sa.
 *
 * @@return Return an error code or 0. Will return
 * KRB5_PROG_ATYPE_NOSUPP in case address type is not supported.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_addr2sockaddr (krb5_context context,
		    const krb5_address *addr,
		    struct sockaddr *sa,
		    krb5_socklen_t *sa_size,
		    int port)
{
    struct addr_operations *a = find_atype(addr->addr_type);

    if (a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address type %d not supported",
				   "krb5_address type"),
				addr->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    if (a->addr2sockaddr == NULL) {
	krb5_set_error_message (context,
				KRB5_PROG_ATYPE_NOSUPP,
				N_("Can't convert address type %d to sockaddr", ""),
				addr->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    (*a->addr2sockaddr)(addr, sa, sa_size, port);
    return 0;
}

/**
 * krb5_max_sockaddr_size returns the max size of the .Li struct
 * sockaddr that the Kerberos library will return.
 *
 * @@return Return an size_t of the maximum struct sockaddr.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION size_t KRB5_LIB_CALL
krb5_max_sockaddr_size (void)
{
    if (max_sockaddr_size == 0) {
	struct addr_operations *a;

	for(a = at; a < at + num_addrs; ++a)
	    max_sockaddr_size = max(max_sockaddr_size, a->max_sockaddr_size);
    }
    return max_sockaddr_size;
}

/**
 * krb5_sockaddr_uninteresting returns TRUE for all .Fa sa that the
 * kerberos library thinks are uninteresting.  One example are link
 * local addresses.
 *
 * @@param sa pointer to struct sockaddr that might be interesting.
 *
 * @@return Return a non zero for uninteresting addresses.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_sockaddr_uninteresting(const struct sockaddr *sa)
{
    struct addr_operations *a = find_af(sa->sa_family);
    if (a == NULL || a->uninteresting == NULL)
	return TRUE;
    return (*a->uninteresting)(sa);
}

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_sockaddr_is_loopback(const struct sockaddr *sa)
{
    struct addr_operations *a = find_af(sa->sa_family);
    if (a == NULL || a->is_loopback == NULL)
	return TRUE;
    return (*a->is_loopback)(sa);
}

/**
 * krb5_h_addr2sockaddr initializes a "struct sockaddr sa" from af and
 * the "struct hostent" (see gethostbyname(3) ) h_addr_list
 * component. The argument sa_size should initially contain the size
 * of the sa, and after the call, it will contain the actual length of
 * the address.
 *
 * @@param context a Keberos context
 * @@param af addresses
 * @@param addr address
 * @@param sa returned struct sockaddr
 * @@param sa_size size of sa
 * @@param port port to set in sa.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_h_addr2sockaddr (krb5_context context,
		      int af,
		      const char *addr, struct sockaddr *sa,
		      krb5_socklen_t *sa_size,
		      int port)
{
    struct addr_operations *a = find_af(af);
    if (a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				"Address family %d not supported", af);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    (*a->h_addr2sockaddr)(addr, sa, sa_size, port);
    return 0;
}

/**
 * krb5_h_addr2addr works like krb5_h_addr2sockaddr with the exception
 * that it operates on a krb5_address instead of a struct sockaddr.
 *
 * @@param context a Keberos context
 * @@param af address family
 * @@param haddr host address from struct hostent.
 * @@param addr returned krb5_address.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_h_addr2addr (krb5_context context,
		  int af,
		  const char *haddr, krb5_address *addr)
{
    struct addr_operations *a = find_af(af);
    if (a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address family %d not supported", ""), af);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    return (*a->h_addr2addr)(haddr, addr);
}

/**
 * krb5_anyaddr fills in a "struct sockaddr sa" that can be used to
 * bind(2) to.  The argument sa_size should initially contain the size
 * of the sa, and after the call, it will contain the actual length
 * of the address.
 *
 * @@param context a Keberos context
 * @@param af address family
 * @@param sa sockaddr
 * @@param sa_size lenght of sa.
 * @@param port for to fill into sa.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_anyaddr (krb5_context context,
	      int af,
	      struct sockaddr *sa,
	      krb5_socklen_t *sa_size,
	      int port)
{
    struct addr_operations *a = find_af (af);

    if (a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address family %d not supported", ""), af);
	return KRB5_PROG_ATYPE_NOSUPP;
    }

    (*a->anyaddr)(sa, sa_size, port);
    return 0;
}

/**
 * krb5_print_address prints the address in addr to the string string
 * that have the length len. If ret_len is not NULL, it will be filled
 * with the length of the string if size were unlimited (not including
 * the final NUL) .
 *
 * @@param addr address to be printed
 * @@param str pointer string to print the address into
 * @@param len length that will fit into area pointed to by "str".
 * @@param ret_len return length the str.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_print_address (const krb5_address *addr,
		    char *str, size_t len, size_t *ret_len)
{
    struct addr_operations *a = find_atype(addr->addr_type);
    int ret;

    if (a == NULL || a->print_addr == NULL) {
	char *s;
	int l;
	size_t i;

	s = str;
	l = snprintf(s, len, "TYPE_%d:", addr->addr_type);
	if (l < 0 || (size_t)l >= len)
	    return EINVAL;
	s += l;
	len -= l;
	for(i = 0; i < addr->address.length; i++) {
	    l = snprintf(s, len, "%02x", ((char*)addr->address.data)[i]);
	    if (l < 0 || (size_t)l >= len)
		return EINVAL;
	    len -= l;
	    s += l;
	}
	if(ret_len != NULL)
	    *ret_len = s - str;
	return 0;
    }
    ret = (*a->print_addr)(addr, str, len);
    if (ret < 0)
	return EINVAL;
    if(ret_len != NULL)
	*ret_len = ret;
    return 0;
}

/**
 * krb5_parse_address returns the resolved hostname in string to the
 * krb5_addresses addresses .
 *
 * @@param context a Keberos context
 * @@param string
 * @@param addresses
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_parse_address(krb5_context context,
		   const char *string,
		   krb5_addresses *addresses)
{
    int i, n;
    struct addrinfo *ai, *a;
    int error;
    int save_errno;

    addresses->len = 0;
    addresses->val = NULL;

    for(i = 0; i < num_addrs; i++) {
	if(at[i].parse_addr) {
	    krb5_address addr;
	    if((*at[i].parse_addr)(context, string, &addr) == 0) {
		ALLOC_SEQ(addresses, 1);
		if (addresses->val == NULL) {
		    krb5_set_error_message(context, ENOMEM,
					   N_("malloc: out of memory", ""));
		    return ENOMEM;
		}
		addresses->val[0] = addr;
		return 0;
	    }
	}
    }

    error = getaddrinfo (string, NULL, NULL, &ai);
    if (error) {
	krb5_error_code ret2;
	save_errno = errno;
	ret2 = krb5_eai_to_heim_errno(error, save_errno);
	krb5_set_error_message (context, ret2, "%s: %s",
				string, gai_strerror(error));
	return ret2;
    }

    n = 0;
    for (a = ai; a != NULL; a = a->ai_next)
	++n;

    ALLOC_SEQ(addresses, n);
    if (addresses->val == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	freeaddrinfo(ai);
	return ENOMEM;
    }

    addresses->len = 0;
    for (a = ai, i = 0; a != NULL; a = a->ai_next) {
	if (krb5_sockaddr2address (context, ai->ai_addr, &addresses->val[i]))
	    continue;
	if(krb5_address_search(context, &addresses->val[i], addresses)) {
	    krb5_free_address(context, &addresses->val[i]);
	    continue;
	}
	i++;
	addresses->len = i;
    }
    freeaddrinfo (ai);
    return 0;
}

/**
 * krb5_address_order compares the addresses addr1 and addr2 so that
 * it can be used for sorting addresses. If the addresses are the same
 * address krb5_address_order will return 0. Behavies like memcmp(2).
 *
 * @@param context a Keberos context
 * @@param addr1 krb5_address to compare
 * @@param addr2 krb5_address to compare
 *
 * @@return < 0 if address addr1 in "less" then addr2. 0 if addr1 and
 * addr2 is the same address, > 0 if addr2 is "less" then addr1.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION int KRB5_LIB_CALL
krb5_address_order(krb5_context context,
		   const krb5_address *addr1,
		   const krb5_address *addr2)
{
    /* this sucks; what if both addresses have order functions, which
       should we call? this works for now, though */
    struct addr_operations *a;
    a = find_atype(addr1->addr_type);
    if(a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address family %d not supported", ""),
				addr1->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    if(a->order_addr != NULL)
	return (*a->order_addr)(context, addr1, addr2);
    a = find_atype(addr2->addr_type);
    if(a == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ATYPE_NOSUPP,
				N_("Address family %d not supported", ""),
				addr2->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    if(a->order_addr != NULL)
	return (*a->order_addr)(context, addr1, addr2);

    if(addr1->addr_type != addr2->addr_type)
	return addr1->addr_type - addr2->addr_type;
    if(addr1->address.length != addr2->address.length)
	return addr1->address.length - addr2->address.length;
    return memcmp (addr1->address.data,
		   addr2->address.data,
		   addr1->address.length);
}

/**
 * krb5_address_compare compares the addresses  addr1 and addr2.
 * Returns TRUE if the two addresses are the same.
 *
 * @@param context a Keberos context
 * @@param addr1 address to compare
 * @@param addr2 address to compare
 *
 * @@return Return an TRUE is the address are the same FALSE if not
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_address_compare(krb5_context context,
		     const krb5_address *addr1,
		     const krb5_address *addr2)
{
    return krb5_address_order (context, addr1, addr2) == 0;
}

/**
 * krb5_address_search checks if the address addr is a member of the
 * address set list addrlist .
 *
 * @@param context a Keberos context.
 * @@param addr address to search for.
 * @@param addrlist list of addresses to look in for addr.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_address_search(krb5_context context,
		    const krb5_address *addr,
		    const krb5_addresses *addrlist)
{
    size_t i;

    for (i = 0; i < addrlist->len; ++i)
	if (krb5_address_compare (context, addr, &addrlist->val[i]))
	    return TRUE;
    return FALSE;
}

/**
 * krb5_free_address frees the data stored in the address that is
 * alloced with any of the krb5_address functions.
 *
 * @@param context a Keberos context
 * @@param address addresss to be freed.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_free_address(krb5_context context,
		  krb5_address *address)
{
    struct addr_operations *a = find_atype (address->addr_type);
    if(a != NULL && a->free_addr != NULL)
	return (*a->free_addr)(context, address);
    krb5_data_free (&address->address);
    memset(address, 0, sizeof(*address));
    return 0;
}

/**
 * krb5_free_addresses frees the data stored in the address that is
 * alloced with any of the krb5_address functions.
 *
 * @@param context a Keberos context
 * @@param addresses addressses to be freed.
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_free_addresses(krb5_context context,
		    krb5_addresses *addresses)
{
    size_t i;
    for(i = 0; i < addresses->len; i++)
	krb5_free_address(context, &addresses->val[i]);
    free(addresses->val);
    addresses->len = 0;
    addresses->val = NULL;
    return 0;
}

/**
 * krb5_copy_address copies the content of address
 * inaddr to outaddr.
 *
 * @@param context a Keberos context
 * @@param inaddr pointer to source address
 * @@param outaddr pointer to destination address
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_copy_address(krb5_context context,
		  const krb5_address *inaddr,
		  krb5_address *outaddr)
{
    struct addr_operations *a = find_af (inaddr->addr_type);
    if(a != NULL && a->copy_addr != NULL)
	return (*a->copy_addr)(context, inaddr, outaddr);
    return copy_HostAddress(inaddr, outaddr);
}

/**
 * krb5_copy_addresses copies the content of addresses
 * inaddr to outaddr.
 *
 * @@param context a Keberos context
 * @@param inaddr pointer to source addresses
 * @@param outaddr pointer to destination addresses
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_copy_addresses(krb5_context context,
		    const krb5_addresses *inaddr,
		    krb5_addresses *outaddr)
{
    size_t i;
    ALLOC_SEQ(outaddr, inaddr->len);
    if(inaddr->len > 0 && outaddr->val == NULL)
	return ENOMEM;
    for(i = 0; i < inaddr->len; i++)
	krb5_copy_address(context, &inaddr->val[i], &outaddr->val[i]);
    return 0;
}

/**
 * krb5_append_addresses adds the set of addresses in source to
 * dest. While copying the addresses, duplicates are also sorted out.
 *
 * @@param context a Keberos context
 * @@param dest destination of copy operation
 * @@param source adresses that are going to be added to dest
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_append_addresses(krb5_context context,
		      krb5_addresses *dest,
		      const krb5_addresses *source)
{
    krb5_address *tmp;
    krb5_error_code ret;
    size_t i;
    if(source->len > 0) {
	tmp = realloc(dest->val, (dest->len + source->len) * sizeof(*tmp));
	if(tmp == NULL) {
	    krb5_set_error_message (context, ENOMEM,
				    N_("malloc: out of memory", ""));
	    return ENOMEM;
	}
	dest->val = tmp;
	for(i = 0; i < source->len; i++) {
	    /* skip duplicates */
	    if(krb5_address_search(context, &source->val[i], dest))
		continue;
	    ret = krb5_copy_address(context,
				    &source->val[i],
				    &dest->val[dest->len]);
	    if(ret)
		return ret;
	    dest->len++;
	}
    }
    return 0;
}

/**
 * Create an address of type KRB5_ADDRESS_ADDRPORT from (addr, port)
 *
 * @@param context a Keberos context
 * @@param res built address from addr/port
 * @@param addr address to use
 * @@param port port to use
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_make_addrport (krb5_context context,
		    krb5_address **res, const krb5_address *addr, int16_t port)
{
    krb5_error_code ret;
    size_t len = addr->address.length + 2 + 4 * 4;
    u_char *p;

    *res = malloc (sizeof(**res));
    if (*res == NULL) {
	krb5_set_error_message (context, ENOMEM,
				N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    (*res)->addr_type = KRB5_ADDRESS_ADDRPORT;
    ret = krb5_data_alloc (&(*res)->address, len);
    if (ret) {
	krb5_set_error_message (context, ret,
				N_("malloc: out of memory", ""));
	free (*res);
	*res = NULL;
	return ret;
    }
    p = (*res)->address.data;
    *p++ = 0;
    *p++ = 0;
    *p++ = (addr->addr_type     ) & 0xFF;
    *p++ = (addr->addr_type >> 8) & 0xFF;

    *p++ = (addr->address.length      ) & 0xFF;
    *p++ = (addr->address.length >>  8) & 0xFF;
    *p++ = (addr->address.length >> 16) & 0xFF;
    *p++ = (addr->address.length >> 24) & 0xFF;

    memcpy (p, addr->address.data, addr->address.length);
    p += addr->address.length;

    *p++ = 0;
    *p++ = 0;
    *p++ = (KRB5_ADDRESS_IPPORT     ) & 0xFF;
    *p++ = (KRB5_ADDRESS_IPPORT >> 8) & 0xFF;

    *p++ = (2      ) & 0xFF;
    *p++ = (2 >>  8) & 0xFF;
    *p++ = (2 >> 16) & 0xFF;
    *p++ = (2 >> 24) & 0xFF;

    memcpy (p, &port, 2);

    return 0;
}

/**
 * Calculate the boundary addresses of `inaddr'/`prefixlen' and store
 * them in `low' and `high'.
 *
 * @@param context a Keberos context
 * @@param inaddr address in prefixlen that the bondery searched
 * @@param prefixlen width of boundery
 * @@param low lowest address
 * @@param high highest address
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_address
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_address_prefixlen_boundary(krb5_context context,
				const krb5_address *inaddr,
				unsigned long prefixlen,
				krb5_address *low,
				krb5_address *high)
{
    struct addr_operations *a = find_atype (inaddr->addr_type);
    if(a != NULL && a->mask_boundary != NULL)
	return (*a->mask_boundary)(context, inaddr, prefixlen, low, high);
    krb5_set_error_message(context, KRB5_PROG_ATYPE_NOSUPP,
			   N_("Address family %d doesn't support "
			      "address mask operation", ""),
			   inaddr->addr_type);
    return KRB5_PROG_ATYPE_NOSUPP;
}
@


1.5
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.4
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d2 30
a31 30
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a35 2
RCSID("$KTH: addr_families.c,v 1.47 2005/05/18 04:20:36 lha Exp $");

d47 1
d54 2
a55 2
    int (*mask_boundary)(krb5_context, const krb5_address*, unsigned long, 
				     krb5_address*, krb5_address*);
d65 1
a65 1
    const struct sockaddr_in *sin = (const struct sockaddr_in *)sa;
d69 1
a69 1
    memcpy (buf, &sin->sin_addr, 4);
d76 1
a76 1
    const struct sockaddr_in *sin = (const struct sockaddr_in *)sa;
d78 1
a78 1
    *port = sin->sin_port;
d132 12
a143 1
    const struct sockaddr_in *sin = (const struct sockaddr_in *)sa;
d145 1
a145 1
    if (sin->sin_addr.s_addr == INADDR_ANY)
a189 1
#ifdef HAVE_INET_ATON
a191 7
#elif defined(HAVE_INET_ADDR)
    a.s_addr = inet_addr(p);
    if(a.s_addr == INADDR_NONE)
	return -1;
#else
    return -1;
#endif
d204 1
a204 1
    u_int32_t l, h, m = 0xffffffff;
d207 2
a208 1
	krb5_set_error_string(context, "IPv4 prefix too large (%ld)", len);
d316 1
a316 1
 * 
d324 2
a325 3
    
    return
	IN6_IS_ADDR_LINKLOCAL(in6)
d329 9
a353 1
#ifdef HAVE_INET_NTOP
a354 1
#endif
d357 1
a357 1
	    int i;
d403 1
a403 1
    u_int32_t m;
d407 2
a408 1
	krb5_set_error_string(context, "IPv6 prefix too large (%ld)", len);
d413 2
a414 1
	krb5_set_error_string(context, "IPv6 addr bad length");
d424 1
a424 1
	
d451 2
d465 1
a465 1
arange_parse_addr (krb5_context context, 
d472 1
a472 1
    
d475 1
a475 1
    
d494 1
a494 1
	
d511 1
a511 1
	
d520 1
a520 1
	
d527 1
a527 1
	
d567 1
d573 1
a573 1
arange_copy (krb5_context context, const krb5_address *inaddr, 
d613 1
a613 1
	
d639 2
a640 2
arange_order_addr(krb5_context context, 
		  const krb5_address *addr1, 
d655 1
a655 1
    } else
d657 3
a659 1
	
d679 2
d688 6
a693 1
    krb5_storage *sp = krb5_storage_from_data((krb5_data*)&addr->address);
d732 17
a748 8
    {AF_INET,	KRB5_ADDRESS_INET, sizeof(struct sockaddr_in),
     ipv4_sockaddr2addr, 
     ipv4_sockaddr2port,
     ipv4_addr2sockaddr,
     ipv4_h_addr2sockaddr,
     ipv4_h_addr2addr,
     ipv4_uninteresting, ipv4_anyaddr, ipv4_print_addr, ipv4_parse_addr,
     NULL, NULL, NULL, ipv4_mask_boundary },
d750 17
a766 8
    {AF_INET6,	KRB5_ADDRESS_INET6, sizeof(struct sockaddr_in6),
     ipv6_sockaddr2addr, 
     ipv6_sockaddr2port,
     ipv6_addr2sockaddr,
     ipv6_h_addr2sockaddr,
     ipv6_h_addr2addr,
     ipv6_uninteresting, ipv6_anyaddr, ipv6_print_addr, ipv6_parse_addr,
     NULL, NULL, NULL, ipv6_mask_boundary } ,
d768 1
a768 3
    {KRB5_ADDRESS_ADDRPORT, KRB5_ADDRESS_ADDRPORT, 0,
     NULL, NULL, NULL, NULL, NULL, 
     NULL, NULL, addrport_print_addr, NULL, NULL, NULL, NULL },
d770 34
a803 4
    {KRB5_ADDRESS_ARANGE, KRB5_ADDRESS_ARANGE, sizeof(struct arange),
     NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     arange_print_addr, arange_parse_addr, 
     arange_order_addr, arange_free, arange_copy }
d826 1
a826 1
find_atype(int atype)
d836 14
a849 1
krb5_error_code KRB5_LIB_FUNCTION
d855 3
a857 2
	krb5_set_error_string (context, "Address family %d not supported",
			       sa->sa_family);
d863 15
a877 1
krb5_error_code KRB5_LIB_FUNCTION
d883 3
a885 2
	krb5_set_error_string (context, "Address family %d not supported",
			       sa->sa_family);
d891 22
a912 1
krb5_error_code KRB5_LIB_FUNCTION
d922 4
a925 2
	krb5_set_error_string (context, "Address type %d not supported",
			       addr->addr_type);
d929 4
a932 2
	krb5_set_error_string (context, "Can't convert address type %d to sockaddr",
			       addr->addr_type);
d939 10
a948 1
size_t KRB5_LIB_FUNCTION
d960 13
a972 1
krb5_boolean KRB5_LIB_FUNCTION
d981 29
a1009 1
krb5_error_code KRB5_LIB_FUNCTION
d1018 2
a1019 1
	krb5_set_error_string (context, "Address family %d not supported", af);
d1026 15
a1040 1
krb5_error_code KRB5_LIB_FUNCTION
d1047 2
a1048 1
	krb5_set_error_string (context, "Address family %d not supported", af);
d1054 18
a1071 1
krb5_error_code KRB5_LIB_FUNCTION
d1081 2
a1082 1
	krb5_set_error_string (context, "Address family %d not supported", af);
d1090 18
a1107 2
krb5_error_code KRB5_LIB_FUNCTION
krb5_print_address (const krb5_address *addr, 
d1116 1
a1116 1
	int i;
d1120 1
a1120 1
	if (l < 0 || l >= len)
d1126 1
a1126 1
	    if (l < 0 || l >= len)
d1143 14
a1156 1
krb5_error_code KRB5_LIB_FUNCTION
d1175 2
a1176 1
		    krb5_set_error_string(context, "malloc: out of memory");
d1187 1
d1189 4
a1192 2
	krb5_set_error_string (context, "%s: %s", string, gai_strerror(error));
	return krb5_eai_to_heim_errno(error, save_errno);
d1194 1
a1194 1
    
d1201 2
a1202 1
	krb5_set_error_string(context, "malloc: out of memory");
d1211 2
a1212 1
	if(krb5_address_search(context, &addresses->val[i], addresses))
d1214 2
a1216 1
	i++;
d1222 16
a1237 1
int KRB5_LIB_FUNCTION
d1245 1
a1245 1
    a = find_atype(addr1->addr_type); 
d1247 3
a1249 2
	krb5_set_error_string (context, "Address family %d not supported", 
			       addr1->addr_type);
d1252 3
a1254 3
    if(a->order_addr != NULL) 
	return (*a->order_addr)(context, addr1, addr2); 
    a = find_atype(addr2->addr_type); 
d1256 3
a1258 2
	krb5_set_error_string (context, "Address family %d not supported", 
			       addr2->addr_type);
d1261 1
a1261 1
    if(a->order_addr != NULL) 
d1273 14
a1286 1
krb5_boolean KRB5_LIB_FUNCTION
d1294 14
a1307 1
krb5_boolean KRB5_LIB_FUNCTION
d1312 1
a1312 1
    int i;
d1320 13
a1332 1
krb5_error_code KRB5_LIB_FUNCTION
d1344 13
a1356 1
krb5_error_code KRB5_LIB_FUNCTION
d1360 1
a1360 1
    int i;
d1369 14
a1382 1
krb5_error_code KRB5_LIB_FUNCTION
d1393 14
a1406 1
krb5_error_code KRB5_LIB_FUNCTION
d1411 1
a1411 1
    int i;
d1420 14
a1433 1
krb5_error_code KRB5_LIB_FUNCTION
d1440 1
a1440 1
    int i;
d1444 2
a1445 1
	    krb5_set_error_string(context, "realloc: out of memory");
d1453 2
a1454 2
	    ret = krb5_copy_address(context, 
				    &source->val[i], 
d1464 1
a1464 1
/*
d1466 9
d1477 1
a1477 1
krb5_error_code KRB5_LIB_FUNCTION
d1487 2
a1488 1
	krb5_set_error_string(context, "malloc: out of memory");
d1494 2
a1495 1
	krb5_set_error_string(context, "malloc: out of memory");
d1497 1
a1524 1
    p += 2;
d1529 1
a1529 1
/*
d1532 10
d1544 1
a1544 1
krb5_error_code KRB5_LIB_FUNCTION
d1554 4
a1557 2
    krb5_set_error_string(context, "Address family %d doesn't support "
			  "address mask operation", inaddr->addr_type);
@


1.3
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d931 3
d939 4
d1055 2
@


1.2
log
@fix snprintf and strlcpy abuse, returning the string length is at least
save in the case where this is being used in pointer arithmatic
ok cloder@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: addr_families.c,v 1.38 2003/03/25 12:37:02 joda Exp $");
d55 2
a158 3
    if (len == 0)
	return(0);

d161 1
a161 2
    (void) snprintf (str, len, "IPv4:%s", inet_ntoa(ia));
    return(strlen(str));
d197 34
d342 2
a343 1
    char buf[128];
d345 14
a358 5
	return (0);
    if (len == 0)
	return(0);
    (void) snprintf(str, len, "IPv6:%s", buf);
    return(strlen(str));
d389 49
d455 2
a456 2
    char buf[1024];
    krb5_addresses low, high;
d465 30
a494 9
    /* should handle netmasks */
    strsep_copy(&address, "-", buf, sizeof(buf));
    ret = krb5_parse_address(context, buf, &low);
    if(ret)
	return ret;
    if(low.len != 1) {
	krb5_free_addresses(context, &low);
	return -1;
    }
d496 24
a519 6
    strsep_copy(&address, "-", buf, sizeof(buf));
    ret = krb5_parse_address(context, buf, &high);
    if(ret) {
	krb5_free_addresses(context, &low);
	return ret;
    }
d521 6
a526 1
    if(high.len != 1 || high.val[0].addr_type != low.val[0].addr_type) {
d529 2
a530 1
	return -1;
d537 3
a539 3
    if(krb5_address_order(context, &low.val[0], &high.val[0]) < 0) {
	a->low = low.val[0];
	a->high = high.val[0];
d541 2
a542 2
	a->low = high.val[0];
	a->high = low.val[0];
d590 1
a590 4
    size_t l, ret_len = 0;

    if (len == 0)
	return(0);
d594 14
a607 2
    (void) strlcpy(str, "RANGE:", len);
    ret_len += strlen(str); /* truncate if too long */
d609 1
a609 1
    ret = krb5_print_address (&a->low, str + ret_len, len - ret_len, &l);
d611 4
d616 3
a618 4
    (void) strlcat(str, "-", len);
    ret_len += strlen(str); /* truncate if too long */

    ret = krb5_print_address (&a->high, str + ret_len, len - ret_len, &l);
d666 1
d669 1
a669 1
    size_t ret_len = 0, l;
a685 2
    ret_len += strlen(str); /* truncate if too long */
    krb5_print_address(&addr1, str + ret_len, len - ret_len, &l);
d687 19
a705 5
    /* XXX oh the horror */
    if ((len - ret_len) == 0)
	return(ret_len);		
    (void) snprintf(str + ret_len, len - ret_len, ",PORT=%u", port);
    return(strlen(str));
d715 2
a716 1
     ipv4_uninteresting, ipv4_anyaddr, ipv4_print_addr, ipv4_parse_addr},
d724 2
a725 1
     ipv6_uninteresting, ipv6_anyaddr, ipv6_print_addr, ipv6_parse_addr} ,
d767 1
a767 1
krb5_error_code
d780 1
a780 1
krb5_error_code
d793 1
a793 1
krb5_error_code
d816 1
a816 1
size_t
d828 1
a828 1
krb5_boolean
d837 1
a837 1
krb5_error_code
d853 1
a853 1
krb5_error_code
d866 1
a866 1
krb5_error_code
d884 1
a884 1
krb5_error_code
a887 2
    size_t ret;
    int r = 0;	
d889 1
a889 6

    if (len == 0) {
	ret = 0;
	r = EINVAL;
	goto out;
    }
d898 2
a899 5
	if (l < 0 || l > (len - 1)) {
	    ret = 0;	
	    r = EINVAL;
	    goto out;
	}	
d904 2
a905 5
	    if (l < 0 || l > (len - 1)) {
		ret = 0;
		r = EINVAL;
		goto out;
	    }
d909 3
a911 2
	ret = s - str;
	goto out;
d914 2
a915 5
    if (ret <= 0 || ret > (len - 1)) {
	ret = 0;
	r = EINVAL;	
    }
out:
d918 1
a918 1
    return r;
d921 1
a921 1
krb5_error_code
d954 5
d960 1
d962 6
a967 3
	if(krb5_sockaddr2address (context, ai->ai_addr, 
				  &addresses->val[i]) == 0)
	    i++;
d973 1
a973 1
int
d1007 1
a1007 1
krb5_boolean
d1015 1
a1015 1
krb5_boolean
d1028 1
a1028 1
krb5_error_code
d1032 1
a1032 1
    struct addr_operations *a = find_af (address->addr_type);
d1036 1
d1040 1
a1040 1
krb5_error_code
d1051 1
a1051 1
krb5_error_code
d1062 1
a1062 1
krb5_error_code
d1076 1
a1076 1
krb5_error_code
d1110 1
a1110 1
krb5_error_code
d1158 20
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997-1999 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: addr_families.c,v 1.24 2000/07/08 13:05:43 joda Exp $");
d45 2
a46 2
			  int *sa_size, int port);
    void (*h_addr2sockaddr)(const char *, struct sockaddr *, int *, int);
d49 1
a49 1
    void (*anyaddr)(struct sockaddr *, int *, int);
d51 4
a54 1
    int (*parse_addr)(const char*, krb5_address *);
d84 1
a84 1
		    int *sa_size,
d87 1
a87 1
    struct sockaddr_in *sin = (struct sockaddr_in *)sa;
d89 6
a94 5
    memset (sin, 0, sizeof(*sin));
    sin->sin_family = AF_INET;
    memcpy (&sin->sin_addr, a->address.data, 4);
    sin->sin_port = port;
    *sa_size = sizeof(*sin);
d99 3
a101 1
		     struct sockaddr *sa, int *sa_size, int port)
d103 1
a103 1
    struct sockaddr_in *sin = (struct sockaddr_in *)sa;
d105 6
a110 5
    memset (sin, 0, sizeof(*sin));
    *sa_size = sizeof(*sin);
    sin->sin_family = AF_INET;
    sin->sin_port   = port;
    sin->sin_addr   = *((const struct in_addr *)addr);
d140 1
a140 1
ipv4_anyaddr (struct sockaddr *sa, int *sa_size, int port)
d142 1
a142 1
    struct sockaddr_in *sin = (struct sockaddr_in *)sa;
d144 6
a149 5
    memset (sin, 0, sizeof(*sin));
    *sa_size = sizeof(*sin);
    sin->sin_family = AF_INET;
    sin->sin_port   = port;
    sin->sin_addr.s_addr = INADDR_ANY;
d157 3
d162 2
a163 1
    return snprintf (str, len, "IPv4:%s", inet_ntoa(ia));
d167 1
a167 1
ipv4_parse_addr (const char *address, krb5_address *addr)
d243 1
a243 1
		    int *sa_size,
d246 1
a246 1
    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;
d248 6
a253 5
    memset (sin6, 0, sizeof(*sin6));
    sin6->sin6_family = AF_INET6;
    memcpy (&sin6->sin6_addr, a->address.data, sizeof(sin6->sin6_addr));
    sin6->sin6_port = port;
    *sa_size = sizeof(*sin6);
d259 1
a259 1
		     int *sa_size,
d262 1
a262 1
    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;
d264 6
a269 5
    memset (sin6, 0, sizeof(*sin6));
    *sa_size = sizeof(*sin6);
    sin6->sin6_family = AF_INET6;
    sin6->sin6_port   = port;
    sin6->sin6_addr   = *((const struct in6_addr *)addr);
d296 1
a296 1
ipv6_anyaddr (struct sockaddr *sa, int *sa_size, int port)
d298 1
a298 1
    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;
d300 5
a304 5
    memset (sin6, 0, sizeof(*sin6));
    *sa_size = sizeof(*sin6);
    sin6->sin6_family = AF_INET6;
    sin6->sin6_port   = port;
    sin6->sin6_addr   = in6addr_any;
d310 1
a310 2
    char buf[128], buf2[3];
#ifdef HAVE_INET_NTOP
d312 5
a316 14
#endif
	{
	    /* XXX this is pretty ugly, but better than abort() */
	    int i;
	    unsigned char *p = addr->address.data;
	    buf[0] = '\0';
	    for(i = 0; i < addr->address.length; i++) {
		snprintf(buf2, sizeof(buf2), "%02x", p[i]);
		if(i > 0 && (i & 1) == 0)
		    strlcat(buf, ":", sizeof(buf));
		strlcat(buf, buf2, sizeof(buf));
	    }
	}
    return snprintf(str, len, "IPv6:%s", buf);
d320 1
a320 1
ipv6_parse_addr (const char *address, krb5_address *addr)
d324 10
d353 194
d562 1
a562 1
     ipv6_uninteresting, ipv6_anyaddr, ipv6_print_addr, ipv6_parse_addr}
d564 8
d605 2
a606 1
krb5_sockaddr2address (const struct sockaddr *sa, krb5_address *addr)
d609 3
a611 1
    if (a == NULL)
d613 1
d618 2
a619 1
krb5_sockaddr2port (const struct sockaddr *sa, int16_t *port)
d622 3
a624 1
    if (a == NULL)
d626 1
d631 2
a632 1
krb5_addr2sockaddr (const krb5_address *addr,
d634 1
a634 1
		    int *sa_size,
d639 3
a641 1
    if (a == NULL)
d643 6
d669 1
a669 1
    if (a == NULL)
d675 4
a678 2
krb5_h_addr2sockaddr (int af,
		      const char *addr, struct sockaddr *sa, int *sa_size,
d682 2
a683 1
    if (a == NULL)
d685 1
d691 2
a692 1
krb5_h_addr2addr (int af,
d696 2
a697 1
    if (a == NULL)
d699 1
d704 2
a705 1
krb5_anyaddr (int af,
d707 1
a707 1
	      int *sa_size,
d712 2
a713 1
    if (a == NULL)
d715 1
d725 2
d729 7
a735 1
    if (a == NULL) {
d737 1
a737 1
	size_t l;
d739 1
d742 5
d748 1
a748 1
	len -= len;
d751 5
d759 7
a765 2
	*ret_len = s - str;
	return 0;
d767 4
a770 2
    *ret_len = (*a->print_addr)(addr, str, len);
    return 0;
d781 1
d785 2
a786 2
	    krb5_address a;
	    if((*at[i].parse_addr)(string, &a) == 0) {
d788 1
a788 1
		addresses->val[0] = a;
d795 5
a799 2
    if (error)
	return krb5_eai_to_heim_errno(error);
d807 4
a810 2
    for (a = ai, i = 0; a != NULL; a = a->ai_next, ++i) {
	krb5_sockaddr2address (ai->ai_addr, &addresses->val[i]);
d813 186
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: addr_families.c,v 1.26 2001/05/14 22:49:55 assar Exp $");
d389 1
a389 2
krb5_sockaddr2address (krb5_context context,
		       const struct sockaddr *sa, krb5_address *addr)
d392 1
a392 3
    if (a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported",
			       sa->sa_family);
a393 1
    }
d398 1
a398 2
krb5_sockaddr2port (krb5_context context,
		    const struct sockaddr *sa, int16_t *port)
d401 1
a401 3
    if (a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported",
			       sa->sa_family);
a402 1
    }
d407 1
a407 2
krb5_addr2sockaddr (krb5_context context,
		    const krb5_address *addr,
d414 1
a414 3
    if (a == NULL) {
	krb5_set_error_string (context, "Address type %d not supported",
			       addr->addr_type);
a415 1
    }
d442 1
a442 2
krb5_h_addr2sockaddr (krb5_context context,
		      int af,
d447 1
a447 2
    if (a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported", af);
a448 1
    }
d454 1
a454 2
krb5_h_addr2addr (krb5_context context,
		  int af,
d458 1
a458 2
    if (a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported", af);
a459 1
    }
d464 1
a464 2
krb5_anyaddr (krb5_context context,
	      int af,
d471 1
a471 2
    if (a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported", af);
a472 1
    }
a511 1
    int save_errno;
d525 2
a526 5
    if (error) {
	save_errno = errno;
	krb5_set_error_string (context, "%s: %s", string, gai_strerror(error));
	return krb5_eai_to_heim_errno(error, save_errno);
    }
d535 1
a535 1
	krb5_sockaddr2address (context, ai->ai_addr, &addresses->val[i]);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: addr_families.c,v 1.31 2001/09/03 19:45:53 assar Exp $");
d51 1
a51 4
    int (*parse_addr)(krb5_context, const char*, krb5_address *);
    int (*order_addr)(krb5_context, const krb5_address*, const krb5_address*);
    int (*free_addr)(krb5_context, krb5_address*);
    int (*copy_addr)(krb5_context, const krb5_address*, krb5_address*);
d155 1
a155 1
ipv4_parse_addr (krb5_context context, const char *address, krb5_address *addr)
d316 1
a316 1
ipv6_parse_addr (krb5_context context, const char *address, krb5_address *addr)
a319 10
    const char *p;

    p = strchr(address, ':');
    if(p) {
	p++;
	if(strncasecmp(address, "ip6:", p - address) == 0 ||
	   strncasecmp(address, "ipv6:", p - address) == 0 ||
	   strncasecmp(address, "inet6:", p - address) == 0)
	    address = p;
    }
a338 159
#define KRB5_ADDRESS_ARANGE	(-100)

struct arange {
    krb5_address low;
    krb5_address high;
};

static int
arange_parse_addr (krb5_context context, 
			  const char *address, krb5_address *addr)
{
    char buf[1024];
    krb5_addresses low, high;
    struct arange *a;
    krb5_error_code ret;
    
    if(strncasecmp(address, "RANGE:", 6) != 0)
	return -1;
    
    address += 6;

    /* should handle netmasks */
    strsep_copy(&address, "-", buf, sizeof(buf));
    ret = krb5_parse_address(context, buf, &low);
    if(ret)
	return ret;
    if(low.len != 1) {
	krb5_free_addresses(context, &low);
	return -1;
    }

    strsep_copy(&address, "-", buf, sizeof(buf));
    ret = krb5_parse_address(context, buf, &high);
    if(ret) {
	krb5_free_addresses(context, &low);
	return ret;
    }

    if(high.len != 1 || high.val[0].addr_type != low.val[0].addr_type) {
	krb5_free_addresses(context, &low);
	krb5_free_addresses(context, &high);
	return -1;
    }

    krb5_data_alloc(&addr->address, sizeof(*a));
    addr->addr_type = KRB5_ADDRESS_ARANGE;
    a = addr->address.data;

    if(krb5_address_order(context, &low.val[0], &high.val[0]) < 0) {
	a->low = low.val[0];
	a->high = high.val[0];
    } else {
	a->low = high.val[0];
	a->high = low.val[0];
    }
    return 0;
}

static int
arange_free (krb5_context context, krb5_address *addr)
{
    struct arange *a;
    a = addr->address.data;
    krb5_free_address(context, &a->low);
    krb5_free_address(context, &a->high);
    return 0;
}


static int
arange_copy (krb5_context context, const krb5_address *inaddr, 
	     krb5_address *outaddr)
{
    krb5_error_code ret;
    struct arange *i, *o;

    outaddr->addr_type = KRB5_ADDRESS_ARANGE;
    ret = krb5_data_alloc(&outaddr->address, sizeof(*o));
    if(ret)
	return ret;
    i = inaddr->address.data;
    o = outaddr->address.data;
    ret = krb5_copy_address(context, &i->low, &o->low);
    if(ret) {
	krb5_data_free(&outaddr->address);
	return ret;
    }
    ret = krb5_copy_address(context, &i->high, &o->high);
    if(ret) {
	krb5_free_address(context, &o->low);
	krb5_data_free(&outaddr->address);
	return ret;
    }
    return 0;
}

static int
arange_print_addr (const krb5_address *addr, char *str, size_t len)
{
    struct arange *a;
    krb5_error_code ret;
    size_t l, ret_len = 0;

    a = addr->address.data;

    l = strlcpy(str, "RANGE:", len);
    ret_len += l;

    ret = krb5_print_address (&a->low, str + ret_len, len - ret_len, &l);
    ret_len += l;

    l = strlcat(str, "-", len);
    ret_len += l;

    ret = krb5_print_address (&a->high, str + ret_len, len - ret_len, &l);
    ret_len += l;

    return ret_len;
}

static int
arange_order_addr(krb5_context context, 
			 const krb5_address *addr1, 
			 const krb5_address *addr2)
{
    int tmp1, tmp2, sign;
    struct arange *a;
    const krb5_address *a2;

    if(addr1->addr_type == KRB5_ADDRESS_ARANGE) {
	a = addr1->address.data;
	a2 = addr2;
	sign = 1;
    } else if(addr2->addr_type == KRB5_ADDRESS_ARANGE) {
	a = addr2->address.data;
	a2 = addr1;
	sign = -1;
    } else
	abort();
	
    if(a2->addr_type == KRB5_ADDRESS_ARANGE) {
	struct arange *b = a2->address.data;
	tmp1 = krb5_address_order(context, &a->low, &b->low);
	if(tmp1 != 0)
	    return sign * tmp1;
	return sign * krb5_address_order(context, &a->high, &b->high);
    } else if(a2->addr_type == a->low.addr_type) {
	tmp1 = krb5_address_order(context, &a->low, a2);
	if(tmp1 > 0)
	    return sign;
	tmp2 = krb5_address_order(context, &a->high, a2);
	if(tmp2 < 0)
	    return -sign;
	return 0;
    } else {
	return sign * (addr1->addr_type - addr2->addr_type);
    }
}

d354 1
a354 1
     ipv6_uninteresting, ipv6_anyaddr, ipv6_print_addr, ipv6_parse_addr} ,
a355 7
    {KRB5_ADDRESS_ADDRPORT, KRB5_ADDRESS_ADDRPORT, 0,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
    /* fake address type */
    {KRB5_ADDRESS_ARANGE, KRB5_ADDRESS_ARANGE, sizeof(struct arange),
     NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     arange_print_addr, arange_parse_addr, 
     arange_order_addr, arange_free, arange_copy }
a427 5
    if (a->addr2sockaddr == NULL) {
	krb5_set_error_string (context, "Can't convert address type %d to sockaddr",
			       addr->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
d448 1
a448 1
    if (a == NULL || a->uninteresting == NULL)
d512 1
a512 1
	len -= l;
d538 1
a538 1
	    if((*at[i].parse_addr)(context, string, &a) == 0) {
a562 186
    return 0;
}

int
krb5_address_order(krb5_context context,
		   const krb5_address *addr1,
		   const krb5_address *addr2)
{
    /* this sucks; what if both addresses have order functions, which
       should we call? this works for now, though */
    struct addr_operations *a;
    a = find_atype(addr1->addr_type); 
    if(a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported", 
			       addr1->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    if(a->order_addr != NULL) 
	return (*a->order_addr)(context, addr1, addr2); 
    a = find_atype(addr2->addr_type); 
    if(a == NULL) {
	krb5_set_error_string (context, "Address family %d not supported", 
			       addr2->addr_type);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    if(a->order_addr != NULL) 
	return (*a->order_addr)(context, addr1, addr2);

    if(addr1->addr_type != addr2->addr_type)
	return addr1->addr_type - addr2->addr_type;
    if(addr1->address.length != addr2->address.length)
	return addr1->address.length - addr2->address.length;
    return memcmp (addr1->address.data,
		   addr2->address.data,
		   addr1->address.length);
}

krb5_boolean
krb5_address_compare(krb5_context context,
		     const krb5_address *addr1,
		     const krb5_address *addr2)
{
    return krb5_address_order (context, addr1, addr2) == 0;
}

krb5_boolean
krb5_address_search(krb5_context context,
		    const krb5_address *addr,
		    const krb5_addresses *addrlist)
{
    int i;

    for (i = 0; i < addrlist->len; ++i)
	if (krb5_address_compare (context, addr, &addrlist->val[i]))
	    return TRUE;
    return FALSE;
}

krb5_error_code
krb5_free_address(krb5_context context,
		  krb5_address *address)
{
    struct addr_operations *a = find_af (address->addr_type);
    if(a != NULL && a->free_addr != NULL)
	return (*a->free_addr)(context, address);
    krb5_data_free (&address->address);
    return 0;
}

krb5_error_code
krb5_free_addresses(krb5_context context,
		    krb5_addresses *addresses)
{
    int i;
    for(i = 0; i < addresses->len; i++)
	krb5_free_address(context, &addresses->val[i]);
    free(addresses->val);
    return 0;
}

krb5_error_code
krb5_copy_address(krb5_context context,
		  const krb5_address *inaddr,
		  krb5_address *outaddr)
{
    struct addr_operations *a = find_af (inaddr->addr_type);
    if(a != NULL && a->copy_addr != NULL)
	return (*a->copy_addr)(context, inaddr, outaddr);
    return copy_HostAddress(inaddr, outaddr);
}

krb5_error_code
krb5_copy_addresses(krb5_context context,
		    const krb5_addresses *inaddr,
		    krb5_addresses *outaddr)
{
    int i;
    ALLOC_SEQ(outaddr, inaddr->len);
    if(inaddr->len > 0 && outaddr->val == NULL)
	return ENOMEM;
    for(i = 0; i < inaddr->len; i++)
	krb5_copy_address(context, &inaddr->val[i], &outaddr->val[i]);
    return 0;
}

krb5_error_code
krb5_append_addresses(krb5_context context,
		      krb5_addresses *dest,
		      const krb5_addresses *source)
{
    krb5_address *tmp;
    krb5_error_code ret;
    int i;
    if(source->len > 0) {
	tmp = realloc(dest->val, (dest->len + source->len) * sizeof(*tmp));
	if(tmp == NULL) {
	    krb5_set_error_string(context, "realloc: out of memory");
	    return ENOMEM;
	}
	dest->val = tmp;
	for(i = 0; i < source->len; i++) {
	    /* skip duplicates */
	    if(krb5_address_search(context, &source->val[i], dest))
		continue;
	    ret = krb5_copy_address(context, 
				    &source->val[i], 
				    &dest->val[dest->len]);
	    if(ret)
		return ret;
	    dest->len++;
	}
    }
    return 0;
}

/*
 * Create an address of type KRB5_ADDRESS_ADDRPORT from (addr, port)
 */

krb5_error_code
krb5_make_addrport (krb5_context context,
		    krb5_address **res, const krb5_address *addr, int16_t port)
{
    krb5_error_code ret;
    size_t len = addr->address.length + 2 + 4 * 4;
    u_char *p;

    *res = malloc (sizeof(**res));
    if (*res == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
    }
    (*res)->addr_type = KRB5_ADDRESS_ADDRPORT;
    ret = krb5_data_alloc (&(*res)->address, len);
    if (ret) {
	krb5_set_error_string(context, "malloc: out of memory");
	free (*res);
	return ret;
    }
    p = (*res)->address.data;
    *p++ = 0;
    *p++ = 0;
    *p++ = (addr->addr_type     ) & 0xFF;
    *p++ = (addr->addr_type >> 8) & 0xFF;

    *p++ = (addr->address.length      ) & 0xFF;
    *p++ = (addr->address.length >>  8) & 0xFF;
    *p++ = (addr->address.length >> 16) & 0xFF;
    *p++ = (addr->address.length >> 24) & 0xFF;

    memcpy (p, addr->address.data, addr->address.length);
    p += addr->address.length;

    *p++ = 0;
    *p++ = 0;
    *p++ = (KRB5_ADDRESS_IPPORT     ) & 0xFF;
    *p++ = (KRB5_ADDRESS_IPPORT >> 8) & 0xFF;

    *p++ = (2      ) & 0xFF;
    *p++ = (2 >>  8) & 0xFF;
    *p++ = (2 >> 16) & 0xFF;
    *p++ = (2 >> 24) & 0xFF;

    memcpy (p, &port, 2);
    p += 2;

@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: addr_families.c,v 1.38 2003/03/25 12:37:02 joda Exp $");
d45 2
a46 2
			  krb5_socklen_t *sa_size, int port);
    void (*h_addr2sockaddr)(const char *, struct sockaddr *, krb5_socklen_t *, int);
d49 1
a49 1
    void (*anyaddr)(struct sockaddr *, krb5_socklen_t *, int);
d84 1
a84 1
		    krb5_socklen_t *sa_size,
d87 1
a87 1
    struct sockaddr_in tmp;
d89 5
a93 6
    memset (&tmp, 0, sizeof(tmp));
    tmp.sin_family = AF_INET;
    memcpy (&tmp.sin_addr, a->address.data, 4);
    tmp.sin_port = port;
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
d98 1
a98 3
		     struct sockaddr *sa,
		     krb5_socklen_t *sa_size,
		     int port)
d100 1
a100 1
    struct sockaddr_in tmp;
d102 5
a106 6
    memset (&tmp, 0, sizeof(tmp));
    tmp.sin_family = AF_INET;
    tmp.sin_port   = port;
    tmp.sin_addr   = *((const struct in_addr *)addr);
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
d136 1
a136 1
ipv4_anyaddr (struct sockaddr *sa, krb5_socklen_t *sa_size, int port)
d138 1
a138 1
    struct sockaddr_in tmp;
d140 5
a144 6
    memset (&tmp, 0, sizeof(tmp));
    tmp.sin_family = AF_INET;
    tmp.sin_port   = port;
    tmp.sin_addr.s_addr = INADDR_ANY;
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
d234 1
a234 1
		    krb5_socklen_t *sa_size,
d237 1
a237 1
    struct sockaddr_in6 tmp;
d239 5
a243 6
    memset (&tmp, 0, sizeof(tmp));
    tmp.sin6_family = AF_INET6;
    memcpy (&tmp.sin6_addr, a->address.data, sizeof(tmp.sin6_addr));
    tmp.sin6_port = port;
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
d249 1
a249 1
		     krb5_socklen_t *sa_size,
d252 1
a252 1
    struct sockaddr_in6 tmp;
d254 5
a258 6
    memset (&tmp, 0, sizeof(tmp));
    tmp.sin6_family = AF_INET6;
    tmp.sin6_port   = port;
    tmp.sin6_addr   = *((const struct in6_addr *)addr);
    memcpy(sa, &tmp, min(sizeof(tmp), *sa_size));
    *sa_size = sizeof(tmp);
d285 1
a285 1
ipv6_anyaddr (struct sockaddr *sa, krb5_socklen_t *sa_size, int port)
d287 1
a287 1
    struct sockaddr_in6 tmp;
d289 5
a293 5
    memset (&tmp, 0, sizeof(tmp));
    tmp.sin6_family = AF_INET6;
    tmp.sin6_port   = port;
    tmp.sin6_addr   = in6addr_any;
    *sa_size = sizeof(tmp);
d361 1
a361 1
		   const char *address, krb5_address *addr)
d474 2
a475 2
		  const krb5_address *addr1, 
		  const krb5_address *addr2)
a510 30
static int
addrport_print_addr (const krb5_address *addr, char *str, size_t len)
{
    krb5_address addr1, addr2;
    uint16_t port = 0;
    size_t ret_len = 0, l;
    krb5_storage *sp = krb5_storage_from_data((krb5_data*)&addr->address);
    /* for totally obscure reasons, these are not in network byteorder */
    krb5_storage_set_byteorder(sp, KRB5_STORAGE_BYTEORDER_LE);

    krb5_storage_seek(sp, 2, SEEK_CUR); /* skip first two bytes */
    krb5_ret_address(sp, &addr1);

    krb5_storage_seek(sp, 2, SEEK_CUR); /* skip two bytes */
    krb5_ret_address(sp, &addr2);
    krb5_storage_free(sp);
    if(addr2.addr_type == KRB5_ADDRESS_IPPORT && addr2.address.length == 2) {
	unsigned long value;
	_krb5_get_int(addr2.address.data, &value, 2);
	port = value;
    }
    l = strlcpy(str, "ADDRPORT:", len);
    ret_len += l;
    krb5_print_address(&addr1, str + ret_len, len - ret_len, &l);
    ret_len += l;
    l = snprintf(str + ret_len, len - ret_len, ",PORT=%u", port);
    ret_len += l;
    return ret_len;
}

d529 1
a529 2
     NULL, NULL, NULL, NULL, NULL, 
     NULL, NULL, addrport_print_addr, NULL, NULL, NULL, NULL },
d597 1
a597 1
		    krb5_socklen_t *sa_size,
d640 1
a640 2
		      const char *addr, struct sockaddr *sa,
		      krb5_socklen_t *sa_size,
d669 1
a669 1
	      krb5_socklen_t *sa_size,
a686 1
    size_t ret;
d689 1
a689 1
    if (a == NULL || a->print_addr == NULL) {
d691 1
a691 1
	int l;
a692 1

a694 2
	if (l < 0)
	    return EINVAL;
a698 2
	    if (l < 0)
		return EINVAL;
d702 1
a702 2
	if(ret_len != NULL)
	    *ret_len = s - str;
d705 1
a705 3
    ret = (*a->print_addr)(addr, str, len);
    if(ret_len != NULL)
	*ret_len = ret;
d721 2
a722 2
	    krb5_address addr;
	    if((*at[i].parse_addr)(context, string, &addr) == 0) {
d724 1
a724 1
		addresses->val[0] = addr;
d743 2
a744 4
    for (a = ai, i = 0; a != NULL; a = a->ai_next) {
	if(krb5_sockaddr2address (context, ai->ai_addr, 
				  &addresses->val[i]) == 0)
	    i++;
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: addr_families.c,v 1.47 2005/05/18 04:20:36 lha Exp $");
a54 2
    int (*mask_boundary)(krb5_context, const krb5_address*, unsigned long, 
				     krb5_address*, krb5_address*);
a194 34
static int
ipv4_mask_boundary(krb5_context context, const krb5_address *inaddr,
		   unsigned long len, krb5_address *low, krb5_address *high)
{
    unsigned long ia;
    u_int32_t l, h, m = 0xffffffff;

    if (len > 32) {
	krb5_set_error_string(context, "IPv4 prefix too large (%ld)", len);
	return KRB5_PROG_ATYPE_NOSUPP;
    }
    m = m << (32 - len);

    _krb5_get_int(inaddr->address.data, &ia, inaddr->address.length);

    l = ia & m;
    h = l | ~m;

    low->addr_type = KRB5_ADDRESS_INET;
    if(krb5_data_alloc(&low->address, 4) != 0)
	return -1;
    _krb5_put_int(low->address.data, l, low->address.length);

    high->addr_type = KRB5_ADDRESS_INET;
    if(krb5_data_alloc(&high->address, 4) != 0) {
	krb5_free_address(context, low);
	return -1;
    }
    _krb5_put_int(high->address.data, h, high->address.length);

    return 0;
}


a352 49
static int
ipv6_mask_boundary(krb5_context context, const krb5_address *inaddr,
		   unsigned long len, krb5_address *low, krb5_address *high)
{
    struct in6_addr addr, laddr, haddr;
    u_int32_t m;
    int i, sub_len;

    if (len > 128) {
	krb5_set_error_string(context, "IPv6 prefix too large (%ld)", len);
	return KRB5_PROG_ATYPE_NOSUPP;
    }

    if (inaddr->address.length != sizeof(addr)) {
	krb5_set_error_string(context, "IPv6 addr bad length");
	return KRB5_PROG_ATYPE_NOSUPP;
    }

    memcpy(&addr, inaddr->address.data, inaddr->address.length);

    for (i = 0; i < 16; i++) {
	sub_len = min(8, len);

	m = 0xff << (8 - sub_len);
	
	laddr.s6_addr[i] = addr.s6_addr[i] & m;
	haddr.s6_addr[i] = (addr.s6_addr[i] & m) | ~m;

	if (len > 8)
	    len -= 8;
	else
	    len = 0;
    }

    low->addr_type = KRB5_ADDRESS_INET6;
    if (krb5_data_alloc(&low->address, sizeof(laddr.s6_addr)) != 0)
	return -1;
    memcpy(low->address.data, laddr.s6_addr, sizeof(laddr.s6_addr));

    high->addr_type = KRB5_ADDRESS_INET6;
    if (krb5_data_alloc(&high->address, sizeof(haddr.s6_addr)) != 0) {
	krb5_free_address(context, low);
	return -1;
    }
    memcpy(high->address.data, haddr.s6_addr, sizeof(haddr.s6_addr));

    return 0;
}

d370 2
a371 2
    char buf[1024], *p;
    krb5_address low0, high0;
d380 9
a388 5
    p = strrchr(address, '/');
    if (p) {
	krb5_addresses addrmask;
	char *q;
	long num;
d390 6
a395 18
	if (strlcpy(buf, address, sizeof(buf)) > sizeof(buf))
	    return -1;
	buf[p - address] = '\0';
	ret = krb5_parse_address(context, buf, &addrmask);
	if (ret)
	    return ret;
	if(addrmask.len != 1) {
	    krb5_free_addresses(context, &addrmask);
	    return -1;
	}
	
	address += p - address + 1;

	num = strtol(address, &q, 10);
	if (q == address || *q != '\0' || num < 0) {
	    krb5_free_addresses(context, &addrmask);
	    return -1;
	}
d397 1
a397 37
	ret = krb5_address_prefixlen_boundary(context, &addrmask.val[0], num,
					      &low0, &high0);
	krb5_free_addresses(context, &addrmask);
	if (ret)
	    return ret;

    } else {
	krb5_addresses low, high;
	
	strsep_copy(&address, "-", buf, sizeof(buf));
	ret = krb5_parse_address(context, buf, &low);
	if(ret)
	    return ret;
	if(low.len != 1) {
	    krb5_free_addresses(context, &low);
	    return -1;
	}
	
	strsep_copy(&address, "-", buf, sizeof(buf));
	ret = krb5_parse_address(context, buf, &high);
	if(ret) {
	    krb5_free_addresses(context, &low);
	    return ret;
	}
	
	if(high.len != 1 && high.val[0].addr_type != low.val[0].addr_type) {
	    krb5_free_addresses(context, &low);
	    krb5_free_addresses(context, &high);
	    return -1;
	}

	ret = krb5_copy_address(context, &high.val[0], &high0);
	if (ret == 0) {
	    ret = krb5_copy_address(context, &low.val[0], &low0);
	    if (ret)
		krb5_free_address(context, &high0);
	}
d400 1
a400 2
	if (ret)
	    return ret;
d407 3
a409 3
    if(krb5_address_order(context, &low0, &high0) < 0) {
	a->low = low0;
	a->high = high0;
d411 2
a412 2
	a->low = high0;
	a->high = low0;
d460 1
a460 1
    size_t l, size, ret_len;
a464 8
    ret_len = l;
    if (l > len)
	l = len;
    size = l;
	
    ret = krb5_print_address (&a->low, str + size, len - size, &l);
    if (ret)
	return ret;
a465 4
    if (len - size > l)
	size += l;
    else
	size = len;
d467 4
a470 1
    l = strlcat(str + size, "-", len - size);
a471 4
    if (len - size > l)
	size += l;
    else
	size = len;
d473 1
a473 3
    ret = krb5_print_address (&a->high, str + size, len - size, &l);
    if (ret)
	return ret;
a520 1
    krb5_error_code ret;
d523 1
a523 1
    size_t ret_len = 0, l, size = 0;
d541 3
a543 8
    if (len > l)
	size += l;
    else
	size = len;

    ret = krb5_print_address(&addr1, str + size, len - size, &l);
    if (ret)
	return ret;
a544 9
    if (len - size > l)
	size += l;
    else
	size = len;

    ret = snprintf(str + size, len - size, ",PORT=%u", port);
    if (ret < 0)
	return EINVAL;
    ret_len += ret;
d555 1
a555 2
     ipv4_uninteresting, ipv4_anyaddr, ipv4_print_addr, ipv4_parse_addr,
     NULL, NULL, NULL, ipv4_mask_boundary },
d563 1
a563 2
     ipv6_uninteresting, ipv6_anyaddr, ipv6_print_addr, ipv6_parse_addr,
     NULL, NULL, NULL, ipv6_mask_boundary } ,
d605 1
a605 1
krb5_error_code KRB5_LIB_FUNCTION
d618 1
a618 1
krb5_error_code KRB5_LIB_FUNCTION
d631 1
a631 1
krb5_error_code KRB5_LIB_FUNCTION
d654 1
a654 1
size_t KRB5_LIB_FUNCTION
d666 1
a666 1
krb5_boolean KRB5_LIB_FUNCTION
d675 1
a675 1
krb5_error_code KRB5_LIB_FUNCTION
d691 1
a691 1
krb5_error_code KRB5_LIB_FUNCTION
d704 1
a704 1
krb5_error_code KRB5_LIB_FUNCTION
d722 1
a722 1
krb5_error_code KRB5_LIB_FUNCTION
d726 1
a727 1
    int ret;
d736 1
a736 1
	if (l < 0 || l >= len)
d742 1
a742 1
	    if (l < 0 || l >= len)
a751 2
    if (ret < 0)
	return EINVAL;
d757 1
a757 1
krb5_error_code KRB5_LIB_FUNCTION
a789 5
    if (addresses->val == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	freeaddrinfo(ai);
	return ENOMEM;
    }
a790 1
    addresses->len = 0;
d792 3
a794 6
	if (krb5_sockaddr2address (context, ai->ai_addr, &addresses->val[i]))
	    continue;
	if(krb5_address_search(context, &addresses->val[i], addresses))
	    continue;
	addresses->len = i;
	i++;
d800 1
a800 1
int KRB5_LIB_FUNCTION
d834 1
a834 1
krb5_boolean KRB5_LIB_FUNCTION
d842 1
a842 1
krb5_boolean KRB5_LIB_FUNCTION
d855 1
a855 1
krb5_error_code KRB5_LIB_FUNCTION
d859 1
a859 1
    struct addr_operations *a = find_atype (address->addr_type);
a862 1
    memset(address, 0, sizeof(*address));
d866 1
a866 1
krb5_error_code KRB5_LIB_FUNCTION
d877 1
a877 1
krb5_error_code KRB5_LIB_FUNCTION
d888 1
a888 1
krb5_error_code KRB5_LIB_FUNCTION
d902 1
a902 1
krb5_error_code KRB5_LIB_FUNCTION
d936 1
a936 1
krb5_error_code KRB5_LIB_FUNCTION
a983 20
}

/*
 * Calculate the boundary addresses of `inaddr'/`prefixlen' and store
 * them in `low' and `high'.
 */

krb5_error_code KRB5_LIB_FUNCTION
krb5_address_prefixlen_boundary(krb5_context context,
				const krb5_address *inaddr,
				unsigned long prefixlen,
				krb5_address *low,
				krb5_address *high)
{
    struct addr_operations *a = find_atype (inaddr->addr_type);
    if(a != NULL && a->mask_boundary != NULL)
	return (*a->mask_boundary)(context, inaddr, prefixlen, low, high);
    krb5_set_error_string(context, "Address family %d doesn't support "
			  "address mask operation", inaddr->addr_type);
    return KRB5_PROG_ATYPE_NOSUPP;
@


