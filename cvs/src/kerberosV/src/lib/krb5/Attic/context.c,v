head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.6;

1.6
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.29.16.20.30;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.02.10.20;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.38;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.38;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.27;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.24;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.49;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.36;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.33.15;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.7
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2010 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Portions Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"
#include <assert.h>
#include <com_err.h>

#define INIT_FIELD(C, T, E, D, F)					\
    (C)->E = krb5_config_get_ ## T ## _default ((C), NULL, (D), 	\
						"libdefaults", F, NULL)

#define INIT_FLAG(C, O, V, D, F)					\
    do {								\
	if (krb5_config_get_bool_default((C), NULL, (D),"libdefaults", F, NULL)) { \
	    (C)->O |= V;						\
        }								\
    } while(0)

/*
 * Set the list of etypes `ret_etypes' from the configuration variable
 * `name'
 */

static krb5_error_code
set_etypes (krb5_context context,
	    const char *name,
	    krb5_enctype **ret_enctypes)
{
    char **etypes_str;
    krb5_enctype *etypes = NULL;

    etypes_str = krb5_config_get_strings(context, NULL, "libdefaults",
					 name, NULL);
    if(etypes_str){
	int i, j, k;
	for(i = 0; etypes_str[i]; i++);
	etypes = malloc((i+1) * sizeof(*etypes));
	if (etypes == NULL) {
	    krb5_config_free_strings (etypes_str);
	    krb5_set_error_message (context, ENOMEM, N_("malloc: out of memory", ""));
	    return ENOMEM;
	}
	for(j = 0, k = 0; j < i; j++) {
	    krb5_enctype e;
	    if(krb5_string_to_enctype(context, etypes_str[j], &e) != 0)
		continue;
	    if (krb5_enctype_valid(context, e) != 0)
		continue;
	    etypes[k++] = e;
	}
	etypes[k] = ETYPE_NULL;
	krb5_config_free_strings(etypes_str);
    }
    *ret_enctypes = etypes;
    return 0;
}

/*
 * read variables from the configuration file and set in `context'
 */

static krb5_error_code
init_context_from_config_file(krb5_context context)
{
    krb5_error_code ret;
    const char * tmp;
    char **s;
    krb5_enctype *tmptypes;

    INIT_FIELD(context, time, max_skew, 5 * 60, "clockskew");
    INIT_FIELD(context, time, kdc_timeout, 3, "kdc_timeout");
    INIT_FIELD(context, int, max_retries, 3, "max_retries");

    INIT_FIELD(context, string, http_proxy, NULL, "http_proxy");

    ret = krb5_config_get_bool_default(context, NULL, FALSE,
				       "libdefaults",
				       "allow_weak_crypto", NULL);
    if (ret) {
	krb5_enctype_enable(context, ETYPE_DES_CBC_CRC);
	krb5_enctype_enable(context, ETYPE_DES_CBC_MD4);
	krb5_enctype_enable(context, ETYPE_DES_CBC_MD5);
	krb5_enctype_enable(context, ETYPE_DES_CBC_NONE);
	krb5_enctype_enable(context, ETYPE_DES_CFB64_NONE);
	krb5_enctype_enable(context, ETYPE_DES_PCBC_NONE);
    }

    ret = set_etypes (context, "default_etypes", &tmptypes);
    if(ret)
	return ret;
    free(context->etypes);
    context->etypes = tmptypes;

    ret = set_etypes (context, "default_etypes_des", &tmptypes);
    if(ret)
	return ret;
    free(context->etypes_des);
    context->etypes_des = tmptypes;

    ret = set_etypes (context, "default_as_etypes", &tmptypes);
    if(ret)
	return ret;
    free(context->as_etypes);
    context->as_etypes = tmptypes;

    ret = set_etypes (context, "default_tgs_etypes", &tmptypes);
    if(ret)
	return ret;
    free(context->tgs_etypes);
    context->tgs_etypes = tmptypes;

    ret = set_etypes (context, "permitted_enctypes", &tmptypes);
    if(ret)
	return ret;
    free(context->permitted_enctypes);
    context->permitted_enctypes = tmptypes;

    /* default keytab name */
    tmp = NULL;
    if(!issuid())
	tmp = getenv("KRB5_KTNAME");
    if(tmp != NULL)
	context->default_keytab = tmp;
    else
	INIT_FIELD(context, string, default_keytab,
		   KEYTAB_DEFAULT, "default_keytab_name");

    INIT_FIELD(context, string, default_keytab_modify,
	       NULL, "default_keytab_modify_name");

    INIT_FIELD(context, string, time_fmt,
	       "%Y-%m-%dT%H:%M:%S", "time_format");

    INIT_FIELD(context, string, date_fmt,
	       "%Y-%m-%d", "date_format");

    INIT_FIELD(context, bool, log_utc,
	       FALSE, "log_utc");



    /* init dns-proxy slime */
    tmp = krb5_config_get_string(context, NULL, "libdefaults",
				 "dns_proxy", NULL);
    if(tmp)
	roken_gethostby_setup(context->http_proxy, tmp);
    krb5_free_host_realm (context, context->default_realms);
    context->default_realms = NULL;

    {
	krb5_addresses addresses;
	char **adr, **a;

	krb5_set_extra_addresses(context, NULL);
	adr = krb5_config_get_strings(context, NULL,
				      "libdefaults",
				      "extra_addresses",
				      NULL);
	memset(&addresses, 0, sizeof(addresses));
	for(a = adr; a && *a; a++) {
	    ret = krb5_parse_address(context, *a, &addresses);
	    if (ret == 0) {
		krb5_add_extra_addresses(context, &addresses);
		krb5_free_addresses(context, &addresses);
	    }
	}
	krb5_config_free_strings(adr);

	krb5_set_ignore_addresses(context, NULL);
	adr = krb5_config_get_strings(context, NULL,
				      "libdefaults",
				      "ignore_addresses",
				      NULL);
	memset(&addresses, 0, sizeof(addresses));
	for(a = adr; a && *a; a++) {
	    ret = krb5_parse_address(context, *a, &addresses);
	    if (ret == 0) {
		krb5_add_ignore_addresses(context, &addresses);
		krb5_free_addresses(context, &addresses);
	    }
	}
	krb5_config_free_strings(adr);
    }

    INIT_FIELD(context, bool, scan_interfaces, TRUE, "scan_interfaces");
    INIT_FIELD(context, int, fcache_vno, 0, "fcache_version");
    /* prefer dns_lookup_kdc over srv_lookup. */
    INIT_FIELD(context, bool, srv_lookup, TRUE, "srv_lookup");
    INIT_FIELD(context, bool, srv_lookup, context->srv_lookup, "dns_lookup_kdc");
    INIT_FIELD(context, int, large_msg_size, 1400, "large_message_size");
    INIT_FLAG(context, flags, KRB5_CTX_F_DNS_CANONICALIZE_HOSTNAME, TRUE, "dns_canonicalize_hostname");
    INIT_FLAG(context, flags, KRB5_CTX_F_CHECK_PAC, TRUE, "check_pac");
    context->default_cc_name = NULL;
    context->default_cc_name_set = 0;

    s = krb5_config_get_strings(context, NULL, "logging", "krb5", NULL);
    if(s) {
	char **p;
	krb5_initlog(context, "libkrb5", &context->debug_dest);
	for(p = s; *p; p++)
	    krb5_addlog_dest(context, context->debug_dest, *p);
	krb5_config_free_strings(s);
    }

    tmp = krb5_config_get_string(context, NULL, "libdefaults",
				 "check-rd-req-server", NULL);
    if (tmp == NULL && !issuid())
	tmp = getenv("KRB5_CHECK_RD_REQ_SERVER");
    if(tmp) {
	if (strcasecmp(tmp, "ignore") == 0)
	    context->flags |= KRB5_CTX_F_RD_REQ_IGNORE;
    }

    return 0;
}

static krb5_error_code
cc_ops_register(krb5_context context)
{
    context->cc_ops = NULL;
    context->num_cc_ops = 0;

#ifndef KCM_IS_API_CACHE
    krb5_cc_register(context, &krb5_acc_ops, TRUE);
#endif
    krb5_cc_register(context, &krb5_fcc_ops, TRUE);
    krb5_cc_register(context, &krb5_mcc_ops, TRUE);
#ifdef HAVE_SCC
    krb5_cc_register(context, &krb5_scc_ops, TRUE);
#endif
#ifdef HAVE_KCM
#ifdef KCM_IS_API_CACHE
    krb5_cc_register(context, &krb5_akcm_ops, TRUE);
#endif
    krb5_cc_register(context, &krb5_kcm_ops, TRUE);
#endif
    _krb5_load_ccache_plugins(context);
    return 0;
}

static krb5_error_code
cc_ops_copy(krb5_context context, const krb5_context src_context)
{
    const krb5_cc_ops **cc_ops;

    context->cc_ops = NULL;
    context->num_cc_ops = 0;

    if (src_context->num_cc_ops == 0)
	return 0;

    cc_ops = malloc(sizeof(cc_ops[0]) * src_context->num_cc_ops);
    if (cc_ops == NULL) {
	krb5_set_error_message(context, KRB5_CC_NOMEM,
			       N_("malloc: out of memory", ""));
	return KRB5_CC_NOMEM;
    }

    memcpy(rk_UNCONST(cc_ops), src_context->cc_ops,
	   sizeof(cc_ops[0]) * src_context->num_cc_ops);
    context->cc_ops = cc_ops;
    context->num_cc_ops = src_context->num_cc_ops;

    return 0;
}

static krb5_error_code
kt_ops_register(krb5_context context)
{
    context->num_kt_types = 0;
    context->kt_types     = NULL;

    krb5_kt_register (context, &krb5_fkt_ops);
    krb5_kt_register (context, &krb5_wrfkt_ops);
    krb5_kt_register (context, &krb5_javakt_ops);
    krb5_kt_register (context, &krb5_mkt_ops);
#ifndef HEIMDAL_SMALLER
    krb5_kt_register (context, &krb5_akf_ops);
#endif
    krb5_kt_register (context, &krb5_any_ops);
    return 0;
}

static krb5_error_code
kt_ops_copy(krb5_context context, const krb5_context src_context)
{
    context->num_kt_types = 0;
    context->kt_types     = NULL;

    if (src_context->num_kt_types == 0)
	return 0;

    context->kt_types = malloc(sizeof(context->kt_types[0]) * src_context->num_kt_types);
    if (context->kt_types == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    context->num_kt_types = src_context->num_kt_types;
    memcpy(context->kt_types, src_context->kt_types,
	   sizeof(context->kt_types[0]) * src_context->num_kt_types);

    return 0;
}

static const char *sysplugin_dirs[] =  {
    LIBDIR "/plugin/krb5",
#ifdef __APPLE__
    "/Library/KerberosPlugins/KerberosFrameworkPlugins",
    "/System/Library/KerberosPlugins/KerberosFrameworkPlugins",
#endif
    NULL
};

static void
init_context_once(void *ctx)
{
    krb5_context context = ctx;

    _krb5_load_plugins(context, "krb5", sysplugin_dirs);

    bindtextdomain(HEIMDAL_TEXTDOMAIN, HEIMDAL_LOCALEDIR);
}


/**
 * Initializes the context structure and reads the configuration file
 * /etc/krb5.conf. The structure should be freed by calling
 * krb5_free_context() when it is no longer being used.
 *
 * @@param context pointer to returned context
 *
 * @@return Returns 0 to indicate success.  Otherwise an errno code is
 * returned.  Failure means either that something bad happened during
 * initialization (typically ENOMEM) or that Kerberos should not be
 * used ENXIO.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_init_context(krb5_context *context)
{
    static heim_base_once_t init_context = HEIM_BASE_ONCE_INIT;
    krb5_context p;
    krb5_error_code ret;
    char **files;

    *context = NULL;

    p = calloc(1, sizeof(*p));
    if(!p)
	return ENOMEM;

    p->mutex = malloc(sizeof(HEIMDAL_MUTEX));
    if (p->mutex == NULL) {
	free(p);
	return ENOMEM;
    }
    HEIMDAL_MUTEX_init(p->mutex);

    p->flags |= KRB5_CTX_F_HOMEDIR_ACCESS;

    ret = krb5_get_default_config_files(&files);
    if(ret)
	goto out;
    ret = krb5_set_config_files(p, files);
    krb5_free_config_files(files);
    if(ret)
	goto out;

    /* init error tables */
    krb5_init_ets(p);
    cc_ops_register(p);
    kt_ops_register(p);

#ifdef PKINIT
    ret = hx509_context_init(&p->hx509ctx);
    if (ret)
	goto out;
#endif
    if (rk_SOCK_INIT())
	p->flags |= KRB5_CTX_F_SOCKETS_INITIALIZED;

out:
    if(ret) {
	krb5_free_context(p);
	p = NULL;
    } else {
	heim_base_once_f(&init_context, p, init_context_once);
    }
    *context = p;
    return ret;
}

#ifndef HEIMDAL_SMALLER

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_permitted_enctypes(krb5_context context,
			    krb5_enctype **etypes)
{
    return krb5_get_default_in_tkt_etypes(context, KRB5_PDU_NONE, etypes);
}

/*
 *
 */

static krb5_error_code
copy_etypes (krb5_context context,
	     krb5_enctype *enctypes,
	     krb5_enctype **ret_enctypes)
{
    unsigned int i;

    for (i = 0; enctypes[i]; i++)
	;
    i++;

    *ret_enctypes = malloc(sizeof(ret_enctypes[0]) * i);
    if (*ret_enctypes == NULL) {
	krb5_set_error_message(context, ENOMEM,
			       N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy(*ret_enctypes, enctypes, sizeof(ret_enctypes[0]) * i);
    return 0;
}

/**
 * Make a copy for the Kerberos 5 context, the new krb5_context shoud
 * be freed with krb5_free_context().
 *
 * @@param context the Kerberos context to copy
 * @@param out the copy of the Kerberos, set to NULL error.
 *
 * @@return Returns 0 to indicate success.  Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_copy_context(krb5_context context, krb5_context *out)
{
    krb5_error_code ret;
    krb5_context p;

    *out = NULL;

    p = calloc(1, sizeof(*p));
    if (p == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    p->mutex = malloc(sizeof(HEIMDAL_MUTEX));
    if (p->mutex == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	free(p);
	return ENOMEM;
    }
    HEIMDAL_MUTEX_init(p->mutex);


    if (context->default_cc_name)
	p->default_cc_name = strdup(context->default_cc_name);
    if (context->default_cc_name_env)
	p->default_cc_name_env = strdup(context->default_cc_name_env);

    if (context->etypes) {
	ret = copy_etypes(context, context->etypes, &p->etypes);
	if (ret)
	    goto out;
    }
    if (context->etypes_des) {
	ret = copy_etypes(context, context->etypes_des, &p->etypes_des);
	if (ret)
	    goto out;
    }

    if (context->default_realms) {
	ret = krb5_copy_host_realm(context,
				   context->default_realms, &p->default_realms);
	if (ret)
	    goto out;
    }

    ret = _krb5_config_copy(context, context->cf, &p->cf);
    if (ret)
	goto out;

    /* XXX should copy */
    krb5_init_ets(p);

    cc_ops_copy(p, context);
    kt_ops_copy(p, context);

#if 0 /* XXX */
    if(context->warn_dest != NULL)
	;
    if(context->debug_dest != NULL)
	;
#endif

    ret = krb5_set_extra_addresses(p, context->extra_addresses);
    if (ret)
	goto out;
    ret = krb5_set_extra_addresses(p, context->ignore_addresses);
    if (ret)
	goto out;

    ret = _krb5_copy_send_to_kdc_func(p, context);
    if (ret)
	goto out;

    *out = p;

    return 0;

 out:
    krb5_free_context(p);
    return ret;
}

#endif

/**
 * Frees the krb5_context allocated by krb5_init_context().
 *
 * @@param context context to be freed.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_free_context(krb5_context context)
{
    if (context->default_cc_name)
	free(context->default_cc_name);
    if (context->default_cc_name_env)
	free(context->default_cc_name_env);
    free(context->etypes);
    free(context->etypes_des);
    krb5_free_host_realm (context, context->default_realms);
    krb5_config_file_free (context, context->cf);
    free_error_table (context->et_list);
    free(rk_UNCONST(context->cc_ops));
    free(context->kt_types);
    krb5_clear_error_message(context);
    if(context->warn_dest != NULL)
	krb5_closelog(context, context->warn_dest);
    if(context->debug_dest != NULL)
	krb5_closelog(context, context->debug_dest);
    krb5_set_extra_addresses(context, NULL);
    krb5_set_ignore_addresses(context, NULL);
    krb5_set_send_to_kdc_func(context, NULL, NULL);

#ifdef PKINIT
    if (context->hx509ctx)
	hx509_context_free(&context->hx509ctx);
#endif

    HEIMDAL_MUTEX_destroy(context->mutex);
    free(context->mutex);
    if (context->flags & KRB5_CTX_F_SOCKETS_INITIALIZED) {
 	rk_SOCK_EXIT();
    }

    memset(context, 0, sizeof(*context));
    free(context);
}

/**
 * Reinit the context from a new set of filenames.
 *
 * @@param context context to add configuration too.
 * @@param filenames array of filenames, end of list is indicated with a NULL filename.
 *
 * @@return Returns 0 to indicate success.  Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_config_files(krb5_context context, char **filenames)
{
    krb5_error_code ret;
    krb5_config_binding *tmp = NULL;
    while(filenames != NULL && *filenames != NULL && **filenames != '\0') {
	ret = krb5_config_parse_file_multi(context, *filenames, &tmp);
	if(ret != 0 && ret != ENOENT && ret != EACCES && ret != EPERM) {
	    krb5_config_file_free(context, tmp);
	    return ret;
	}
	filenames++;
    }
#if 0
    /* with this enabled and if there are no config files, Kerberos is
       considererd disabled */
    if(tmp == NULL)
	return ENXIO;
#endif

#ifdef _WIN32
    _krb5_load_config_from_registry(context, &tmp);
#endif

    krb5_config_file_free(context, context->cf);
    context->cf = tmp;
    ret = init_context_from_config_file(context);
    return ret;
}

static krb5_error_code
add_file(char ***pfilenames, int *len, char *file)
{
    char **pp = *pfilenames;
    int i;

    for(i = 0; i < *len; i++) {
	if(strcmp(pp[i], file) == 0) {
	    free(file);
	    return 0;
	}
    }

    pp = realloc(*pfilenames, (*len + 2) * sizeof(*pp));
    if (pp == NULL) {
	free(file);
	return ENOMEM;
    }

    pp[*len] = file;
    pp[*len + 1] = NULL;
    *pfilenames = pp;
    *len += 1;
    return 0;
}

/*
 *  `pq' isn't free, it's up the the caller
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_prepend_config_files(const char *filelist, char **pq, char ***ret_pp)
{
    krb5_error_code ret;
    const char *p, *q;
    char **pp;
    int len;
    char *fn;

    pp = NULL;

    len = 0;
    p = filelist;
    while(1) {
	ssize_t l;
	q = p;
	l = strsep_copy(&q, PATH_SEP, NULL, 0);
	if(l == -1)
	    break;
	fn = malloc(l + 1);
	if(fn == NULL) {
	    krb5_free_config_files(pp);
	    return ENOMEM;
	}
	(void)strsep_copy(&p, PATH_SEP, fn, l + 1);
	ret = add_file(&pp, &len, fn);
	if (ret) {
	    krb5_free_config_files(pp);
	    return ret;
	}
    }

    if (pq != NULL) {
	int i;

	for (i = 0; pq[i] != NULL; i++) {
	    fn = strdup(pq[i]);
	    if (fn == NULL) {
		krb5_free_config_files(pp);
		return ENOMEM;
	    }
	    ret = add_file(&pp, &len, fn);
	    if (ret) {
		krb5_free_config_files(pp);
		return ret;
	    }
	}
    }

    *ret_pp = pp;
    return 0;
}

/**
 * Prepend the filename to the global configuration list.
 *
 * @@param filelist a filename to add to the default list of filename
 * @@param pfilenames return array of filenames, should be freed with krb5_free_config_files().
 *
 * @@return Returns 0 to indicate success.  Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_prepend_config_files_default(const char *filelist, char ***pfilenames)
{
    krb5_error_code ret;
    char **defpp, **pp = NULL;

    ret = krb5_get_default_config_files(&defpp);
    if (ret)
	return ret;

    ret = krb5_prepend_config_files(filelist, defpp, &pp);
    krb5_free_config_files(defpp);
    if (ret) {
	return ret;
    }
    *pfilenames = pp;
    return 0;
}

#ifdef _WIN32

/**
 * Checks the registry for configuration file location
 *
 * Kerberos for Windows and other legacy Kerberos applications expect
 * to find the configuration file location in the
 * SOFTWARE\MIT\Kerberos registry key under the value "config".
 */
char *
_krb5_get_default_config_config_files_from_registry()
{
    static const char * KeyName = "Software\\MIT\\Kerberos";
    char *config_file = NULL;
    LONG rcode;
    HKEY key;

    rcode = RegOpenKeyEx(HKEY_CURRENT_USER, KeyName, 0, KEY_READ, &key);
    if (rcode == ERROR_SUCCESS) {
        config_file = _krb5_parse_reg_value_as_multi_string(NULL, key, "config",
                                                            REG_NONE, 0, PATH_SEP);
        RegCloseKey(key);
    }

    if (config_file)
        return config_file;

    rcode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KeyName, 0, KEY_READ, &key);
    if (rcode == ERROR_SUCCESS) {
        config_file = _krb5_parse_reg_value_as_multi_string(NULL, key, "config",
                                                            REG_NONE, 0, PATH_SEP);
        RegCloseKey(key);
    }

    return config_file;
}

#endif

/**
 * Get the global configuration list.
 *
 * @@param pfilenames return array of filenames, should be freed with krb5_free_config_files().
 *
 * @@return Returns 0 to indicate success.  Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_default_config_files(char ***pfilenames)
{
    const char *files = NULL;

    if (pfilenames == NULL)
        return EINVAL;
    if(!issuid())
	files = getenv("KRB5_CONFIG");

#ifdef _WIN32
    if (files == NULL) {
        char * reg_files;
        reg_files = _krb5_get_default_config_config_files_from_registry();
        if (reg_files != NULL) {
            krb5_error_code code;

            code = krb5_prepend_config_files(reg_files, NULL, pfilenames);
            free(reg_files);

            return code;
        }
    }
#endif

    if (files == NULL)
	files = krb5_config_file;

    return krb5_prepend_config_files(files, NULL, pfilenames);
}

/**
 * Free a list of configuration files.
 *
 * @@param filenames list, terminated with a NULL pointer, to be
 * freed. NULL is an valid argument.
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_free_config_files(char **filenames)
{
    char **p;
    for(p = filenames; p && *p != NULL; p++)
	free(*p);
    free(filenames);
}

/**
 * Returns the list of Kerberos encryption types sorted in order of
 * most preferred to least preferred encryption type.  Note that some
 * encryption types might be disabled, so you need to check with
 * krb5_enctype_valid() before using the encryption type.
 *
 * @@return list of enctypes, terminated with ETYPE_NULL. Its a static
 * array completed into the Kerberos library so the content doesn't
 * need to be freed.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION const krb5_enctype * KRB5_LIB_CALL
krb5_kerberos_enctypes(krb5_context context)
{
    static const krb5_enctype p[] = {
	ETYPE_AES256_CTS_HMAC_SHA1_96,
	ETYPE_AES128_CTS_HMAC_SHA1_96,
	ETYPE_DES3_CBC_SHA1,
	ETYPE_DES3_CBC_MD5,
	ETYPE_ARCFOUR_HMAC_MD5,
	ETYPE_DES_CBC_MD5,
	ETYPE_DES_CBC_MD4,
	ETYPE_DES_CBC_CRC,
	ETYPE_NULL
    };
    return p;
}

/*
 *
 */

static krb5_error_code
copy_enctypes(krb5_context context,
	      const krb5_enctype *in,
	      krb5_enctype **out)
{
    krb5_enctype *p = NULL;
    size_t m, n;

    for (n = 0; in[n]; n++)
	;
    n++;
    ALLOC(p, n);
    if(p == NULL)
	return krb5_enomem(context);
    for (n = 0, m = 0; in[n]; n++) {
	if (krb5_enctype_valid(context, in[n]) != 0)
	    continue;
	p[m++] = in[n];
    }
    p[m] = KRB5_ENCTYPE_NULL;
    if (m == 0) {
	free(p);
	krb5_set_error_message (context, KRB5_PROG_ETYPE_NOSUPP,
				N_("no valid enctype set", ""));
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    *out = p;
    return 0;
}


/*
 * set `etype' to a malloced list of the default enctypes
 */

static krb5_error_code
default_etypes(krb5_context context, krb5_enctype **etype)
{
    const krb5_enctype *p = krb5_kerberos_enctypes(context);
    return copy_enctypes(context, p, etype);
}

/**
 * Set the default encryption types that will be use in communcation
 * with the KDC, clients and servers.
 *
 * @@param context Kerberos 5 context.
 * @@param etypes Encryption types, array terminated with ETYPE_NULL (0).
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_default_in_tkt_etypes(krb5_context context,
			       const krb5_enctype *etypes)
{
    krb5_error_code ret;
    krb5_enctype *p = NULL;

    if(etypes) {
	ret = copy_enctypes(context, etypes, &p);
	if (ret)
	    return ret;
    }
    if(context->etypes)
	free(context->etypes);
    context->etypes = p;
    return 0;
}

/**
 * Get the default encryption types that will be use in communcation
 * with the KDC, clients and servers.
 *
 * @@param context Kerberos 5 context.
 * @@param etypes Encryption types, array terminated with
 * ETYPE_NULL(0), caller should free array with krb5_xfree():
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_default_in_tkt_etypes(krb5_context context,
			       krb5_pdu pdu_type,
			       krb5_enctype **etypes)
{
    krb5_enctype *enctypes = NULL;
    krb5_error_code ret;
    krb5_enctype *p;

    heim_assert(pdu_type == KRB5_PDU_AS_REQUEST || 
		pdu_type == KRB5_PDU_TGS_REQUEST ||
		pdu_type == KRB5_PDU_NONE, "pdu contant not as expected");

    if (pdu_type == KRB5_PDU_AS_REQUEST && context->as_etypes != NULL)
	enctypes = context->as_etypes;
    else if (pdu_type == KRB5_PDU_TGS_REQUEST && context->tgs_etypes != NULL)
	enctypes = context->tgs_etypes;
    else if (context->etypes != NULL)
	enctypes = context->etypes;

    if (enctypes != NULL) {
	ret = copy_enctypes(context, enctypes, &p);
	if (ret)
	    return ret;
    } else {
	ret = default_etypes(context, &p);
	if (ret)
	    return ret;
    }
    *etypes = p;
    return 0;
}

/**
 * Init the built-in ets in the Kerberos library.
 *
 * @@param context kerberos context to add the ets too
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_init_ets(krb5_context context)
{
    if(context->et_list == NULL){
	krb5_add_et_list(context, initialize_krb5_error_table_r);
	krb5_add_et_list(context, initialize_asn1_error_table_r);
	krb5_add_et_list(context, initialize_heim_error_table_r);

	krb5_add_et_list(context, initialize_k524_error_table_r);

#ifdef COM_ERR_BINDDOMAIN_krb5
	bindtextdomain(COM_ERR_BINDDOMAIN_krb5, HEIMDAL_LOCALEDIR);
	bindtextdomain(COM_ERR_BINDDOMAIN_asn1, HEIMDAL_LOCALEDIR);
	bindtextdomain(COM_ERR_BINDDOMAIN_heim, HEIMDAL_LOCALEDIR);
	bindtextdomain(COM_ERR_BINDDOMAIN_k524, HEIMDAL_LOCALEDIR);
#endif

#ifdef PKINIT
	krb5_add_et_list(context, initialize_hx_error_table_r);
#ifdef COM_ERR_BINDDOMAIN_hx
	bindtextdomain(COM_ERR_BINDDOMAIN_hx, HEIMDAL_LOCALEDIR);
#endif
#endif
    }
}

/**
 * Make the kerberos library default to the admin KDC.
 *
 * @@param context Kerberos 5 context.
 * @@param flag boolean flag to select if the use the admin KDC or not.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_set_use_admin_kdc (krb5_context context, krb5_boolean flag)
{
    context->use_admin_kdc = flag;
}

/**
 * Make the kerberos library default to the admin KDC.
 *
 * @@param context Kerberos 5 context.
 *
 * @@return boolean flag to telling the context will use admin KDC as the default KDC.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_get_use_admin_kdc (krb5_context context)
{
    return context->use_admin_kdc;
}

/**
 * Add extra address to the address list that the library will add to
 * the client's address list when communicating with the KDC.
 *
 * @@param context Kerberos 5 context.
 * @@param addresses addreses to add
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_add_extra_addresses(krb5_context context, krb5_addresses *addresses)
{

    if(context->extra_addresses)
	return krb5_append_addresses(context,
				     context->extra_addresses, addresses);
    else
	return krb5_set_extra_addresses(context, addresses);
}

/**
 * Set extra address to the address list that the library will add to
 * the client's address list when communicating with the KDC.
 *
 * @@param context Kerberos 5 context.
 * @@param addresses addreses to set
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_extra_addresses(krb5_context context, const krb5_addresses *addresses)
{
    if(context->extra_addresses)
	krb5_free_addresses(context, context->extra_addresses);

    if(addresses == NULL) {
	if(context->extra_addresses != NULL) {
	    free(context->extra_addresses);
	    context->extra_addresses = NULL;
	}
	return 0;
    }
    if(context->extra_addresses == NULL) {
	context->extra_addresses = malloc(sizeof(*context->extra_addresses));
	if(context->extra_addresses == NULL) {
	    krb5_set_error_message (context, ENOMEM, N_("malloc: out of memory", ""));
	    return ENOMEM;
	}
    }
    return krb5_copy_addresses(context, addresses, context->extra_addresses);
}

/**
 * Get extra address to the address list that the library will add to
 * the client's address list when communicating with the KDC.
 *
 * @@param context Kerberos 5 context.
 * @@param addresses addreses to set
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_extra_addresses(krb5_context context, krb5_addresses *addresses)
{
    if(context->extra_addresses == NULL) {
	memset(addresses, 0, sizeof(*addresses));
	return 0;
    }
    return krb5_copy_addresses(context,context->extra_addresses, addresses);
}

/**
 * Add extra addresses to ignore when fetching addresses from the
 * underlaying operating system.
 *
 * @@param context Kerberos 5 context.
 * @@param addresses addreses to ignore
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_add_ignore_addresses(krb5_context context, krb5_addresses *addresses)
{

    if(context->ignore_addresses)
	return krb5_append_addresses(context,
				     context->ignore_addresses, addresses);
    else
	return krb5_set_ignore_addresses(context, addresses);
}

/**
 * Set extra addresses to ignore when fetching addresses from the
 * underlaying operating system.
 *
 * @@param context Kerberos 5 context.
 * @@param addresses addreses to ignore
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_ignore_addresses(krb5_context context, const krb5_addresses *addresses)
{
    if(context->ignore_addresses)
	krb5_free_addresses(context, context->ignore_addresses);
    if(addresses == NULL) {
	if(context->ignore_addresses != NULL) {
	    free(context->ignore_addresses);
	    context->ignore_addresses = NULL;
	}
	return 0;
    }
    if(context->ignore_addresses == NULL) {
	context->ignore_addresses = malloc(sizeof(*context->ignore_addresses));
	if(context->ignore_addresses == NULL) {
	    krb5_set_error_message (context, ENOMEM, N_("malloc: out of memory", ""));
	    return ENOMEM;
	}
    }
    return krb5_copy_addresses(context, addresses, context->ignore_addresses);
}

/**
 * Get extra addresses to ignore when fetching addresses from the
 * underlaying operating system.
 *
 * @@param context Kerberos 5 context.
 * @@param addresses list addreses ignored
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_ignore_addresses(krb5_context context, krb5_addresses *addresses)
{
    if(context->ignore_addresses == NULL) {
	memset(addresses, 0, sizeof(*addresses));
	return 0;
    }
    return krb5_copy_addresses(context, context->ignore_addresses, addresses);
}

/**
 * Set version of fcache that the library should use.
 *
 * @@param context Kerberos 5 context.
 * @@param version version number.
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_fcache_version(krb5_context context, int version)
{
    context->fcache_vno = version;
    return 0;
}

/**
 * Get version of fcache that the library should use.
 *
 * @@param context Kerberos 5 context.
 * @@param version version number.
 *
 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_fcache_version(krb5_context context, int *version)
{
    *version = context->fcache_vno;
    return 0;
}

/**
 * Runtime check if the Kerberos library was complied with thread support.
 *
 * @@return TRUE if the library was compiled with thread support, FALSE if not.
 *
 * @@ingroup krb5
 */


KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_is_thread_safe(void)
{
#ifdef ENABLE_PTHREAD_SUPPORT
    return TRUE;
#else
    return FALSE;
#endif
}

/**
 * Set if the library should use DNS to canonicalize hostnames.
 *
 * @@param context Kerberos 5 context.
 * @@param flag if its dns canonicalizion is used or not.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_set_dns_canonicalize_hostname (krb5_context context, krb5_boolean flag)
{
    if (flag)
	context->flags |= KRB5_CTX_F_DNS_CANONICALIZE_HOSTNAME;
    else
	context->flags &= ~KRB5_CTX_F_DNS_CANONICALIZE_HOSTNAME;
}

/**
 * Get if the library uses DNS to canonicalize hostnames.
 *
 * @@param context Kerberos 5 context.
 *
 * @@return return non zero if the library uses DNS to canonicalize hostnames.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_get_dns_canonicalize_hostname (krb5_context context)
{
    return (context->flags & KRB5_CTX_F_DNS_CANONICALIZE_HOSTNAME) ? 1 : 0;
}

/**
 * Get current offset in time to the KDC.
 *
 * @@param context Kerberos 5 context.
 * @@param sec seconds part of offset.
 * @@param usec micro seconds part of offset.
 *
 * @@return returns zero
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_get_kdc_sec_offset (krb5_context context, int32_t *sec, int32_t *usec)
{
    if (sec)
	*sec = context->kdc_sec_offset;
    if (usec)
	*usec = context->kdc_usec_offset;
    return 0;
}

/**
 * Set current offset in time to the KDC.
 *
 * @@param context Kerberos 5 context.
 * @@param sec seconds part of offset.
 * @@param usec micro seconds part of offset.
 *
 * @@return returns zero
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_set_kdc_sec_offset (krb5_context context, int32_t sec, int32_t usec)
{
    context->kdc_sec_offset = sec;
    if (usec >= 0)
	context->kdc_usec_offset = usec;
    return 0;
}

/**
 * Get max time skew allowed.
 *
 * @@param context Kerberos 5 context.
 *
 * @@return timeskew in seconds.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION time_t KRB5_LIB_CALL
krb5_get_max_time_skew (krb5_context context)
{
    return context->max_skew;
}

/**
 * Set max time skew allowed.
 *
 * @@param context Kerberos 5 context.
 * @@param t timeskew in seconds.
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION void KRB5_LIB_CALL
krb5_set_max_time_skew (krb5_context context, time_t t)
{
    context->max_skew = t;
}

/*
 * Init encryption types in len, val with etypes.
 *
 * @@param context Kerberos 5 context.
 * @@param pdu_type type of pdu
 * @@param len output length of val.
 * @@param val output array of enctypes.
 * @@param etypes etypes to set val and len to, if NULL, use default enctypes.

 * @@return Returns 0 to indicate success. Otherwise an kerberos et
 * error code is returned, see krb5_get_error_message().
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
_krb5_init_etype(krb5_context context,
		 krb5_pdu pdu_type,
		 unsigned *len,
		 krb5_enctype **val,
		 const krb5_enctype *etypes)
{
    krb5_error_code ret;

    if (etypes == NULL)
	ret = krb5_get_default_in_tkt_etypes(context, pdu_type, val);
    else
	ret = copy_enctypes(context, etypes, val);
    if (ret)
	return ret;

    if (len) {
	*len = 0;
	while ((*val)[*len] != KRB5_ENCTYPE_NULL)
	    (*len)++;
    }
    return 0;
}

/*
 * Allow homedir accces
 */

static HEIMDAL_MUTEX homedir_mutex = HEIMDAL_MUTEX_INITIALIZER;
static krb5_boolean allow_homedir = TRUE;

krb5_boolean
_krb5_homedir_access(krb5_context context)
{
    krb5_boolean allow;

#ifdef HAVE_GETEUID
    /* is never allowed for root */
    if (geteuid() == 0)
	return FALSE;
#endif

    if (context && (context->flags & KRB5_CTX_F_HOMEDIR_ACCESS) == 0)
	return FALSE;

    HEIMDAL_MUTEX_lock(&homedir_mutex);
    allow = allow_homedir;
    HEIMDAL_MUTEX_unlock(&homedir_mutex);
    return allow;
}

/**
 * Enable and disable home directory access on either the global state
 * or the krb5_context state. By calling krb5_set_home_dir_access()
 * with context set to NULL, the global state is configured otherwise
 * the state for the krb5_context is modified.
 *
 * For home directory access to be allowed, both the global state and
 * the krb5_context state have to be allowed.
 *
 * Administrator (root user), never uses the home directory.
 *
 * @@param context a Kerberos 5 context or NULL
 * @@param allow allow if TRUE home directory
 * @@return the old value
 *
 * @@ingroup krb5
 */

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_set_home_dir_access(krb5_context context, krb5_boolean allow)
{
    krb5_boolean old;
    if (context) {
	old = (context->flags & KRB5_CTX_F_HOMEDIR_ACCESS) ? TRUE : FALSE;
	if (allow)
	    context->flags |= KRB5_CTX_F_HOMEDIR_ACCESS;
	else
	    context->flags &= ~KRB5_CTX_F_HOMEDIR_ACCESS;
    } else {
	HEIMDAL_MUTEX_lock(&homedir_mutex);
	old = allow_homedir;
	allow_homedir = allow;
	HEIMDAL_MUTEX_unlock(&homedir_mutex);
    }

    return old;
}
@


1.6
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.5
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 32
a33 30
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d37 1
a39 2
RCSID("$KTH: context.c,v 1.102 2005/05/18 04:20:50 lha Exp $");

d44 7
d64 1
a64 1
    etypes_str = krb5_config_get_strings(context, NULL, "libdefaults", 
d72 1
a72 1
	    krb5_set_error_string (context, "malloc: out of memory");
d85 1
a85 1
    } 
d99 1
d107 13
a119 1
    
d125 1
a125 1
    
d132 18
d157 1
a157 1
	INIT_FIELD(context, string, default_keytab, 
d160 1
a160 1
    INIT_FIELD(context, string, default_keytab_modify, 
d163 1
a163 1
    INIT_FIELD(context, string, time_fmt, 
d166 1
a166 1
    INIT_FIELD(context, string, date_fmt, 
d169 1
a169 1
    INIT_FIELD(context, bool, log_utc, 
d173 1
a173 1
    
d175 1
a175 1
    tmp = krb5_config_get_string(context, NULL, "libdefaults", 
d177 1
a177 1
    if(tmp) 
d187 3
a189 3
	adr = krb5_config_get_strings(context, NULL, 
				      "libdefaults", 
				      "extra_addresses", 
d202 3
a204 3
	adr = krb5_config_get_strings(context, NULL, 
				      "libdefaults", 
				      "ignore_addresses", 
d216 1
a216 1
    
d222 3
a224 1
    INIT_FIELD(context, int, large_msg_size, 6000, "large_message_size");
d226 70
d299 76
a374 1
krb5_error_code KRB5_LIB_FUNCTION
d377 1
d395 2
d398 1
a398 1
    if(ret) 
d402 1
a402 1
    if(ret) 
d407 2
d410 4
a413 7
    p->cc_ops = NULL;
    p->num_cc_ops = 0;
    krb5_cc_register(p, &krb5_acc_ops, TRUE);
    krb5_cc_register(p, &krb5_fcc_ops, TRUE);
    krb5_cc_register(p, &krb5_mcc_ops, TRUE);
#ifdef HAVE_KCM
    krb5_cc_register(p, &krb5_kcm_ops, TRUE);
d415 2
a416 11

    p->num_kt_types = 0;
    p->kt_types     = NULL;
    krb5_kt_register (p, &krb5_fkt_ops);
    krb5_kt_register (p, &krb5_wrfkt_ops);
    krb5_kt_register (p, &krb5_javakt_ops);
    krb5_kt_register (p, &krb5_mkt_ops);
    krb5_kt_register (p, &krb5_akf_ops);
    krb5_kt_register (p, &krb4_fkt_ops);
    krb5_kt_register (p, &krb5_srvtab_fkt_ops);
    krb5_kt_register (p, &krb5_any_ops);
d422 2
d429 141
a569 1
void KRB5_LIB_FUNCTION
d574 2
d581 1
a581 1
    free(context->cc_ops);
d583 1
a583 1
    krb5_clear_error_string(context);
d586 2
d590 11
a600 3
    if (context->mutex != NULL) {
	HEIMDAL_MUTEX_destroy(context->mutex);
	free(context->mutex);
d602 1
d607 13
a619 1
krb5_error_code KRB5_LIB_FUNCTION
d626 1
a626 1
	if(ret != 0 && ret != ENOENT && ret != EACCES) {
d638 5
d676 1
a676 1
 *  `pq' isn't free, its up the the caller
d679 1
a679 1
krb5_error_code KRB5_LIB_FUNCTION
d695 1
a695 1
	l = strsep_copy(&q, ":", NULL, 0);
d703 1
a703 1
	l = strsep_copy(&p, ":", fn, l + 1);
d732 13
a744 1
krb5_error_code KRB5_LIB_FUNCTION
d749 1
a749 1
    
d758 1
a758 1
    }	
d763 51
a813 1
krb5_error_code KRB5_LIB_FUNCTION 
d822 16
d844 13
a856 1
void KRB5_LIB_FUNCTION
d860 1
a860 1
    for(p = filenames; *p != NULL; p++)
d865 11
a875 2
/*
 * set `etype' to a malloced list of the default enctypes
d878 2
a879 2
static krb5_error_code
default_etypes(krb5_context context, krb5_enctype **etype)
d881 1
a881 1
    krb5_enctype p[] = {
d889 2
a890 1
	ETYPE_DES_CBC_CRC
d892 2
a893 2
    krb5_enctype *e = NULL, *ep;
    int i, n = 0;
d895 20
a914 2
    for (i = 0; i < sizeof(p)/sizeof(p[0]); i++) {
	if (krb5_enctype_valid(context, p[i]) != 0)
d916 8
a923 10
	ep = realloc(e, (n + 2) * sizeof(*e));
	if (ep == NULL) {
	    free(e);
	    krb5_set_error_string (context, "malloc: out of memory");
	    return ENOMEM;
	}
	e = ep;
	e[n] = p[i];
	e[n + 1] = ETYPE_NULL;
	n++;
d925 1
a925 1
    *etype = e;
d929 27
a955 2
krb5_error_code KRB5_LIB_FUNCTION
krb5_set_default_in_tkt_etypes(krb5_context context, 
d958 1
a959 1
    int i;
d962 3
a964 13
	for (i = 0; etypes[i]; ++i) {
	    krb5_error_code ret;
	    ret = krb5_enctype_valid(context, etypes[i]);
	    if (ret)
		return ret;
	}
	++i;
	ALLOC(p, i);
	if(!p) {
	    krb5_set_error_string (context, "malloc: out of memory");
	    return ENOMEM;
	}
	memmove(p, etypes, i * sizeof(krb5_enctype));
d972 13
d986 1
a986 1
krb5_error_code KRB5_LIB_FUNCTION
d988 1
d991 26
a1016 20
  krb5_enctype *p;
  int i;
  krb5_error_code ret;

  if(context->etypes) {
    for(i = 0; context->etypes[i]; i++);
    ++i;
    ALLOC(p, i);
    if(!p) {
      krb5_set_error_string (context, "malloc: out of memory");
      return ENOMEM;
    }
    memmove(p, context->etypes, i * sizeof(krb5_enctype));
  } else {
    ret = default_etypes(context, &p);
    if (ret)
      return ret;
  }
  *etypes = p;
  return 0;
d1019 7
a1025 12
const char* KRB5_LIB_FUNCTION
krb5_get_err_text(krb5_context context, krb5_error_code code)
{
    const char *p = NULL;
    if(context != NULL)
	p = com_right(context->et_list, code);
    if(p == NULL)
	p = strerror(code);
    if (p == NULL)
	p = "Unknown error";
    return p;
}
d1027 1
a1027 1
void KRB5_LIB_FUNCTION
d1034 1
d1036 14
d1053 10
a1062 1
void KRB5_LIB_FUNCTION
d1068 11
a1078 1
krb5_boolean KRB5_LIB_FUNCTION
d1084 14
a1097 1
krb5_error_code KRB5_LIB_FUNCTION
d1102 1
a1102 1
	return krb5_append_addresses(context, 
d1108 14
a1121 1
krb5_error_code KRB5_LIB_FUNCTION
d1137 1
a1137 1
	    krb5_set_error_string (context, "malloc: out of memory");
d1144 14
a1157 1
krb5_error_code KRB5_LIB_FUNCTION
d1167 14
a1180 1
krb5_error_code KRB5_LIB_FUNCTION
d1185 1
a1185 1
	return krb5_append_addresses(context, 
d1191 14
a1204 1
krb5_error_code KRB5_LIB_FUNCTION
d1219 1
a1219 1
	    krb5_set_error_string (context, "malloc: out of memory");
d1226 14
a1239 1
krb5_error_code KRB5_LIB_FUNCTION
d1249 13
a1261 1
krb5_error_code KRB5_LIB_FUNCTION
d1268 13
a1280 1
krb5_error_code KRB5_LIB_FUNCTION
d1287 10
a1296 1
krb5_boolean KRB5_LIB_FUNCTION
d1304 212
@


1.4
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: context.c,v 1.83.2.1 2004/08/20 15:30:24 lha Exp $");
d68 6
a73 2
	    if(krb5_string_to_enctype(context, etypes_str[j], &etypes[k]) == 0)
		k++;
d183 1
d188 1
a188 1
krb5_error_code
d195 2
d201 7
d221 1
d224 3
d231 2
d248 1
a248 1
void
d265 5
d273 1
a273 1
krb5_error_code
d280 1
a280 1
	if(ret != 0 && ret != ENOENT) {
d298 32
a329 2
krb5_error_code 
krb5_get_default_config_files(char ***pfilenames)
d331 1
d334 2
a335 9
    int n, i;

    const char *files = NULL;
    if (pfilenames == NULL)
        return EINVAL;
    if(!issuid())
	files = getenv("KRB5_CONFIG");
    if (files == NULL)
	files = krb5_config_file;
d337 1
a337 4
    for(n = 0, p = files; strsep_copy(&p, ":", NULL, 0) != -1; n++);
    pp = malloc((n + 1) * sizeof(*pp));
    if(pp == NULL)
	return ENOMEM;
d339 2
a340 2
    n = 0;
    p = files;
d347 2
a348 2
	pp[n] = malloc(l + 1);
	if(pp[n] == NULL) {
d352 16
a367 5
	l = strsep_copy(&p, ":", pp[n], l + 1);
	for(i = 0; i < n; i++)
	    if(strcmp(pp[i], pp[n]) == 0) {
		free(pp[n]);
		goto skip;
d369 6
a374 2
	n++;
    skip:;
d376 20
a395 1
    pp[n] = NULL;
d400 16
a415 1
void
d432 2
d439 1
a439 2
	ETYPE_DES_CBC_CRC,
	ETYPE_NULL
d441 2
d444 13
a456 4
    *etype = malloc(sizeof(p));
    if(*etype == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
	return ENOMEM;
d458 1
a458 1
    memcpy(*etype, p, sizeof(p));
d462 1
a462 1
krb5_error_code
d466 1
a467 1
    krb5_enctype *p = NULL;
d470 6
a475 6
	for (i = 0; etypes[i]; ++i)
	    if(!krb5_enctype_valid(context, etypes[i])) {
		krb5_set_error_string(context, "enctype %d not supported",
				      etypes[i]);
		return KRB5_PROG_ETYPE_NOSUPP;
	    }
d491 1
a491 1
krb5_error_code
d517 1
a517 1
const char *
d530 1
a530 1
void
d541 1
a541 1
void
d547 1
a547 1
krb5_boolean
d553 1
a553 1
krb5_error_code
d564 1
a564 1
krb5_error_code
d587 1
a587 1
krb5_error_code
d597 1
a597 1
krb5_error_code
d608 1
a608 1
krb5_error_code
d630 1
a630 1
krb5_error_code
d640 1
a640 1
krb5_error_code
d647 1
a647 1
krb5_error_code
d652 10
@


1.3
log
@Merge 0.6rc1
@
text
@d37 1
a37 1
RCSID("$KTH: context.c,v 1.83 2003/03/10 00:24:13 lha Exp $");
d418 2
@


1.2
log
@Use issetugid() instead of the wrapper called issuid() in libroken.
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d35 1
d37 1
a37 1
RCSID("$KTH: context.c,v 1.71 2001/08/31 08:00:15 joda Exp $");
d54 1
a54 1
    krb5_enctype *etypes;
d73 2
a74 2
	*ret_enctypes = etypes;
    }
d87 1
d94 12
a105 3

    set_etypes (context, "default_etypes", &context->etypes);
    set_etypes (context, "default_etypes_des", &context->etypes_des);
d108 8
a115 2
    INIT_FIELD(context, string, default_keytab, 
	       KEYTAB_DEFAULT, "default_keytab_name");
d118 1
a118 1
	       KEYTAB_DEFAULT_MODIFY, "default_keytab_modify_name");
d136 1
d142 2
d158 1
d175 2
d178 2
a179 15
    INIT_FIELD(context, int, fcache_vno, 0, "fcache_version");

    context->cc_ops       = NULL;
    context->num_cc_ops	  = 0;
    krb5_cc_register(context, &krb5_fcc_ops, TRUE);
    krb5_cc_register(context, &krb5_mcc_ops, TRUE);

    context->num_kt_types = 0;
    context->kt_types     = NULL;
    krb5_kt_register (context, &krb5_fkt_ops);
    krb5_kt_register (context, &krb5_mkt_ops);
    krb5_kt_register (context, &krb5_akf_ops);
    krb5_kt_register (context, &krb4_fkt_ops);
    krb5_kt_register (context, &krb5_srvtab_fkt_ops);
    krb5_kt_register (context, &krb5_any_ops);
a186 2
    const char *config_file = NULL;
    krb5_config_section *tmp_cf;
d188 1
d190 1
a190 1
    ALLOC(p, 1);
d193 8
a200 1
    memset(p, 0, sizeof(krb5_context_data));
d205 13
a217 14
    if(!issetugid())
	config_file = getenv("KRB5_CONFIG");
    if (config_file == NULL)
	config_file = krb5_config_file;

    ret = krb5_config_parse_file (p, config_file, &tmp_cf);

    if (ret == 0)
	p->cf = tmp_cf;
#if 0
    else
	krb5_warnx (p, "Unable to parse config file %s.  Ignoring.",
		    config_file); /* XXX */
#endif
d219 1
a219 1
    ret = init_context_from_config_file(p);
d222 1
a222 1
	return ret;
a223 1

d225 1
a225 1
    return 0;
d231 2
a232 2
    int i;

a237 2
    for(i = 0; i < context->num_cc_ops; ++i)
	free(context->cc_ops[i].prefix);
d248 81
d413 3
a415 1
    const char *p = com_right(context->et_list, code);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: context.c,v 1.59 2000/12/15 17:11:51 joda Exp $");
d63 1
d84 1
d86 1
d100 3
d130 19
a148 3
	    krb5_parse_address(context, *a, &addresses);
	    krb5_add_extra_addresses(context, &addresses);
	    krb5_free_addresses(context, &addresses);
a154 1
    INIT_FIELD(context, bool, srv_try_txt, FALSE, "srv_try_txt");
d168 2
d189 1
a189 1
    if(!issuid())
d194 1
a194 1
    ret = krb5_config_parse_file (config_file, &tmp_cf);
d217 1
a217 1
  int i;
d219 15
a233 10
  free(context->etypes);
  free(context->etypes_des);
  krb5_free_host_realm (context, context->default_realms);
  krb5_config_file_free (context, context->cf);
  free_error_table (context->et_list);
  for(i = 0; i < context->num_cc_ops; ++i)
    free(context->cc_ops[i].prefix);
  free(context->cc_ops);
  free(context->kt_types);
  free(context);
d241 1
a241 1
default_etypes(krb5_enctype **etype)
d252 1
d254 2
a255 1
    if(*etype == NULL)
d257 1
d270 4
a273 3
	i = 0;
	while(etypes[i])
	    if(!krb5_enctype_valid(context, etypes[i++]))
d275 1
d278 2
a279 1
	if(!p)
d281 1
d297 1
d303 2
a304 1
    if(!p)
d306 1
d308 5
a312 3
  } else
    if(default_etypes(&p))
      return ENOMEM;
d330 4
a333 3
	initialize_krb5_error_table_r(&context->et_list);
	initialize_asn1_error_table_r(&context->et_list);
	initialize_heim_error_table_r(&context->et_list);
d363 1
a363 1
    if(context->extra_addresses) {
d365 7
a371 1
	free(context->extra_addresses);
d375 2
a376 1
	if(context->extra_addresses == NULL)
d378 1
d390 44
a433 1
    return copy_HostAddresses(context->extra_addresses, addresses);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: context.c,v 1.64 2001/05/16 22:24:42 assar Exp $");
a62 1
	    krb5_set_error_string (context, "malloc: out of memory");
a96 3
    INIT_FIELD(context, string, default_keytab_modify, 
	       KEYTAB_DEFAULT_MODIFY, "default_keytab_modify_name");

a146 2
    krb5_kt_register (context, &krb5_srvtab_fkt_ops);
    krb5_kt_register (context, &krb5_any_ops);
d171 1
a171 1
    ret = krb5_config_parse_file (p, config_file, &tmp_cf);
d213 1
a213 1
default_etypes(krb5_context context, krb5_enctype **etype)
a223 1

d225 1
a225 2
    if(*etype == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
a226 1
    }
d239 3
a241 4
	for (i = 0; etypes[i]; ++i)
	    if(!krb5_enctype_valid(context, etypes[i])) {
		krb5_set_error_string(context, "enctype %d not supported",
				      etypes[i]);
a242 1
	    }
d245 1
a245 2
	if(!p) {
	    krb5_set_error_string (context, "malloc: out of memory");
a246 1
	}
a261 1
  krb5_error_code ret;
d267 1
a267 2
    if(!p) {
      krb5_set_error_string (context, "malloc: out of memory");
a268 1
    }
d270 3
a272 5
  } else {
    ret = default_etypes(context, &p);
    if (ret)
      return ret;
  }
d290 3
a292 3
	krb5_add_et_list(context, initialize_krb5_error_table_r);
	krb5_add_et_list(context, initialize_asn1_error_table_r);
	krb5_add_et_list(context, initialize_heim_error_table_r);
d328 1
a328 2
	if(context->extra_addresses == NULL) {
	    krb5_set_error_string (context, "malloc: out of memory");
a329 1
	}
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d36 1
a36 1
RCSID("$KTH: context.c,v 1.71 2001/08/31 08:00:15 joda Exp $");
a83 1
    krb5_error_code ret;
a84 1

d128 3
a130 19
	    ret = krb5_parse_address(context, *a, &addresses);
	    if (ret == 0) {
		krb5_add_extra_addresses(context, &addresses);
		krb5_free_addresses(context, &addresses);
	    }
	}
	krb5_config_free_strings(adr);

	adr = krb5_config_get_strings(context, NULL, 
				      "libdefaults", 
				      "ignore_addresses", 
				      NULL);
	memset(&addresses, 0, sizeof(addresses));
	for(a = adr; a && *a; a++) {
	    ret = krb5_parse_address(context, *a, &addresses);
	    if (ret == 0) {
		krb5_add_ignore_addresses(context, &addresses);
		krb5_free_addresses(context, &addresses);
	    }
d137 1
d200 1
a200 1
    int i;
d202 10
a211 15
    free(context->etypes);
    free(context->etypes_des);
    krb5_free_host_realm (context, context->default_realms);
    krb5_config_file_free (context, context->cf);
    free_error_table (context->et_list);
    for(i = 0; i < context->num_cc_ops; ++i)
	free(context->cc_ops[i].prefix);
    free(context->cc_ops);
    free(context->kt_types);
    krb5_clear_error_string(context);
    if(context->warn_dest != NULL)
	krb5_closelog(context, context->warn_dest);
    krb5_set_extra_addresses(context, NULL);
    krb5_set_ignore_addresses(context, NULL);
    free(context);
a310 1
	krb5_add_et_list(context, initialize_k524_error_table_r);
d340 1
a340 1
    if(context->extra_addresses)
d342 1
a342 7

    if(addresses == NULL) {
	if(context->extra_addresses != NULL) {
	    free(context->extra_addresses);
	    context->extra_addresses = NULL;
	}
	return 0;
d361 1
a361 44
    return krb5_copy_addresses(context,context->extra_addresses, addresses);
}

krb5_error_code
krb5_add_ignore_addresses(krb5_context context, krb5_addresses *addresses)
{

    if(context->ignore_addresses)
	return krb5_append_addresses(context, 
				     context->ignore_addresses, addresses);
    else
	return krb5_set_ignore_addresses(context, addresses);
}

krb5_error_code
krb5_set_ignore_addresses(krb5_context context, const krb5_addresses *addresses)
{
    if(context->ignore_addresses)
	krb5_free_addresses(context, context->ignore_addresses);
    if(addresses == NULL) {
	if(context->ignore_addresses != NULL) {
	    free(context->ignore_addresses);
	    context->ignore_addresses = NULL;
	}
	return 0;
    }
    if(context->ignore_addresses == NULL) {
	context->ignore_addresses = malloc(sizeof(*context->ignore_addresses));
	if(context->ignore_addresses == NULL) {
	    krb5_set_error_string (context, "malloc: out of memory");
	    return ENOMEM;
	}
    }
    return krb5_copy_addresses(context, addresses, context->ignore_addresses);
}

krb5_error_code
krb5_get_ignore_addresses(krb5_context context, krb5_addresses *addresses)
{
    if(context->ignore_addresses == NULL) {
	memset(addresses, 0, sizeof(*addresses));
	return 0;
    }
    return krb5_copy_addresses(context, context->ignore_addresses, addresses);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
a34 1
#include <com_err.h>
d36 1
a36 1
RCSID("$KTH: context.c,v 1.83 2003/03/10 00:24:13 lha Exp $");
d53 1
a53 1
    krb5_enctype *etypes = NULL;
d72 2
a73 2
    } 
    *ret_enctypes = etypes;
a85 1
    krb5_enctype *tmptypes;
d92 3
a94 12
    
    ret = set_etypes (context, "default_etypes", &tmptypes);
    if(ret)
	return ret;
    free(context->etypes);
    context->etypes = tmptypes;
    
    ret = set_etypes (context, "default_etypes_des", &tmptypes);
    if(ret)
	return ret;
    free(context->etypes_des);
    context->etypes_des = tmptypes;
d97 2
a98 8
    tmp = NULL;
    if(!issuid())
	tmp = getenv("KRB5_KTNAME");
    if(tmp != NULL)
	context->default_keytab = tmp;
    else
	INIT_FIELD(context, string, default_keytab, 
		   KEYTAB_DEFAULT, "default_keytab_name");
d101 1
a101 1
	       NULL, "default_keytab_modify_name");
a118 1
    krb5_free_host_realm (context, context->default_realms);
a123 2

	krb5_set_extra_addresses(context, NULL);
a137 1
	krb5_set_ignore_addresses(context, NULL);
d154 1
d156 14
a169 4
    /* prefer dns_lookup_kdc over srv_lookup. */
    INIT_FIELD(context, bool, srv_lookup, TRUE, "srv_lookup");
    INIT_FIELD(context, bool, srv_lookup, context->srv_lookup, "dns_lookup_kdc");
    context->default_cc_name = NULL;
d177 2
a179 1
    char **files;
d181 1
a181 1
    p = calloc(1, sizeof(*p));
d184 1
a184 8

    ret = krb5_get_default_config_files(&files);
    if(ret) 
	goto out;
    ret = krb5_set_config_files(p, files);
    krb5_free_config_files(files);
    if(ret) 
	goto out;
d189 4
a192 13
    p->cc_ops = NULL;
    p->num_cc_ops = 0;
    krb5_cc_register(p, &krb5_fcc_ops, TRUE);
    krb5_cc_register(p, &krb5_mcc_ops, TRUE);

    p->num_kt_types = 0;
    p->kt_types     = NULL;
    krb5_kt_register (p, &krb5_fkt_ops);
    krb5_kt_register (p, &krb5_mkt_ops);
    krb5_kt_register (p, &krb5_akf_ops);
    krb5_kt_register (p, &krb4_fkt_ops);
    krb5_kt_register (p, &krb5_srvtab_fkt_ops);
    krb5_kt_register (p, &krb5_any_ops);
d194 11
a204 1
out:
d207 1
a207 1
	p = NULL;
d209 1
d211 1
a211 1
    return ret;
d217 2
a218 2
    if (context->default_cc_name)
	free(context->default_cc_name);
d224 2
a235 81
krb5_error_code
krb5_set_config_files(krb5_context context, char **filenames)
{
    krb5_error_code ret;
    krb5_config_binding *tmp = NULL;
    while(filenames != NULL && *filenames != NULL && **filenames != '\0') {
	ret = krb5_config_parse_file_multi(context, *filenames, &tmp);
	if(ret != 0 && ret != ENOENT) {
	    krb5_config_file_free(context, tmp);
	    return ret;
	}
	filenames++;
    }
#if 0
    /* with this enabled and if there are no config files, Kerberos is
       considererd disabled */
    if(tmp == NULL)
	return ENXIO;
#endif
    krb5_config_file_free(context, context->cf);
    context->cf = tmp;
    ret = init_context_from_config_file(context);
    return ret;
}

krb5_error_code 
krb5_get_default_config_files(char ***pfilenames)
{
    const char *p, *q;
    char **pp;
    int n, i;

    const char *files = NULL;
    if (pfilenames == NULL)
        return EINVAL;
    if(!issuid())
	files = getenv("KRB5_CONFIG");
    if (files == NULL)
	files = krb5_config_file;

    for(n = 0, p = files; strsep_copy(&p, ":", NULL, 0) != -1; n++);
    pp = malloc((n + 1) * sizeof(*pp));
    if(pp == NULL)
	return ENOMEM;

    n = 0;
    p = files;
    while(1) {
	ssize_t l;
	q = p;
	l = strsep_copy(&q, ":", NULL, 0);
	if(l == -1)
	    break;
	pp[n] = malloc(l + 1);
	if(pp[n] == NULL) {
	    krb5_free_config_files(pp);
	    return ENOMEM;
	}
	l = strsep_copy(&p, ":", pp[n], l + 1);
	for(i = 0; i < n; i++)
	    if(strcmp(pp[i], pp[n]) == 0) {
		free(pp[n]);
		goto skip;
	    }
	n++;
    skip:;
    }
    pp[n] = NULL;
    *pfilenames = pp;
    return 0;
}

void
krb5_free_config_files(char **filenames)
{
    char **p;
    for(p = filenames; *p != NULL; p++)
	free(*p);
    free(filenames);
}

d320 1
a320 3
    const char *p = NULL;
    if(context != NULL)
	p = com_right(context->et_list, code);
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d37 1
a37 1
RCSID("$KTH: context.c,v 1.83.2.1 2004/08/20 15:30:24 lha Exp $");
a417 2
    if (p == NULL)
	p = "Unknown error";
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: context.c,v 1.102 2005/05/18 04:20:50 lha Exp $");
d68 2
a69 6
	    krb5_enctype e;
	    if(krb5_string_to_enctype(context, etypes_str[j], &e) != 0)
		continue;
	    if (krb5_enctype_valid(context, e) != 0)
		continue;
	    etypes[k++] = e;
a178 1
    INIT_FIELD(context, int, large_msg_size, 6000, "large_message_size");
d183 1
a183 1
krb5_error_code KRB5_LIB_FUNCTION
a189 2
    *context = NULL;

a193 7
    p->mutex = malloc(sizeof(HEIMDAL_MUTEX));
    if (p->mutex == NULL) {
	free(p);
	return ENOMEM;
    }
    HEIMDAL_MUTEX_init(p->mutex);

a206 1
    krb5_cc_register(p, &krb5_acc_ops, TRUE);
a208 3
#ifdef HAVE_KCM
    krb5_cc_register(p, &krb5_kcm_ops, TRUE);
#endif
a212 2
    krb5_kt_register (p, &krb5_wrfkt_ops);
    krb5_kt_register (p, &krb5_javakt_ops);
d228 1
a228 1
void KRB5_LIB_FUNCTION
a244 5
    if (context->mutex != NULL) {
	HEIMDAL_MUTEX_destroy(context->mutex);
	free(context->mutex);
    }
    memset(context, 0, sizeof(*context));
d248 1
a248 1
krb5_error_code KRB5_LIB_FUNCTION
d255 1
a255 1
	if(ret != 0 && ret != ENOENT && ret != EACCES) {
d273 2
a274 2
static krb5_error_code
add_file(char ***pfilenames, int *len, char *file)
d276 3
a278 2
    char **pp = *pfilenames;
    int i;
d280 7
a286 6
    for(i = 0; i < *len; i++) {
	if(strcmp(pp[i], file) == 0) {
	    free(file);
	    return 0;
	}
    }
d288 3
a290 3
    pp = realloc(*pfilenames, (*len + 2) * sizeof(*pp));
    if (pp == NULL) {
	free(file);
a291 21
    }

    pp[*len] = file;
    pp[*len + 1] = NULL;
    *pfilenames = pp;
    *len += 1;
    return 0;
}

/*
 *  `pq' isn't free, its up the the caller
 */

krb5_error_code KRB5_LIB_FUNCTION
krb5_prepend_config_files(const char *filelist, char **pq, char ***ret_pp)
{
    krb5_error_code ret;
    const char *p, *q;
    char **pp;
    int len;
    char *fn;
d293 2
a294 4
    pp = NULL;

    len = 0;
    p = filelist;
d301 2
a302 2
	fn = malloc(l + 1);
	if(fn == NULL) {
d306 5
a310 16
	l = strsep_copy(&p, ":", fn, l + 1);
	ret = add_file(&pp, &len, fn);
	if (ret) {
	    krb5_free_config_files(pp);
	    return ret;
	}
    }

    if (pq != NULL) {
	int i;

	for (i = 0; pq[i] != NULL; i++) {
	    fn = strdup(pq[i]);
	    if (fn == NULL) {
		krb5_free_config_files(pp);
		return ENOMEM;
d312 2
a313 6
	    ret = add_file(&pp, &len, fn);
	    if (ret) {
		krb5_free_config_files(pp);
		return ret;
	    }
	}
d315 1
a315 20

    *ret_pp = pp;
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_prepend_config_files_default(const char *filelist, char ***pfilenames)
{
    krb5_error_code ret;
    char **defpp, **pp = NULL;
    
    ret = krb5_get_default_config_files(&defpp);
    if (ret)
	return ret;

    ret = krb5_prepend_config_files(filelist, defpp, &pp);
    krb5_free_config_files(defpp);
    if (ret) {
	return ret;
    }	
d320 1
a320 16
krb5_error_code KRB5_LIB_FUNCTION 
krb5_get_default_config_files(char ***pfilenames)
{
    const char *files = NULL;

    if (pfilenames == NULL)
        return EINVAL;
    if(!issuid())
	files = getenv("KRB5_CONFIG");
    if (files == NULL)
	files = krb5_config_file;

    return krb5_prepend_config_files(files, NULL, pfilenames);
}

void KRB5_LIB_FUNCTION
a336 2
	ETYPE_AES256_CTS_HMAC_SHA1_96,
	ETYPE_AES128_CTS_HMAC_SHA1_96,
d342 2
a343 1
	ETYPE_DES_CBC_CRC
a344 2
    krb5_enctype *e = NULL, *ep;
    int i, n = 0;
d346 4
a349 13
    for (i = 0; i < sizeof(p)/sizeof(p[0]); i++) {
	if (krb5_enctype_valid(context, p[i]) != 0)
	    continue;
	ep = realloc(e, (n + 2) * sizeof(*e));
	if (ep == NULL) {
	    free(e);
	    krb5_set_error_string (context, "malloc: out of memory");
	    return ENOMEM;
	}
	e = ep;
	e[n] = p[i];
	e[n + 1] = ETYPE_NULL;
	n++;
d351 1
a351 1
    *etype = e;
d355 1
a355 1
krb5_error_code KRB5_LIB_FUNCTION
d359 1
a360 1
    int i;
d363 6
a368 6
	for (i = 0; etypes[i]; ++i) {
	    krb5_error_code ret;
	    ret = krb5_enctype_valid(context, etypes[i]);
	    if (ret)
		return ret;
	}
d384 1
a384 1
krb5_error_code KRB5_LIB_FUNCTION
d410 1
a410 1
const char* KRB5_LIB_FUNCTION
d423 1
a423 1
void KRB5_LIB_FUNCTION
d434 1
a434 1
void KRB5_LIB_FUNCTION
d440 1
a440 1
krb5_boolean KRB5_LIB_FUNCTION
d446 1
a446 1
krb5_error_code KRB5_LIB_FUNCTION
d457 1
a457 1
krb5_error_code KRB5_LIB_FUNCTION
d480 1
a480 1
krb5_error_code KRB5_LIB_FUNCTION
d490 1
a490 1
krb5_error_code KRB5_LIB_FUNCTION
d501 1
a501 1
krb5_error_code KRB5_LIB_FUNCTION
d523 1
a523 1
krb5_error_code KRB5_LIB_FUNCTION
d533 1
a533 1
krb5_error_code KRB5_LIB_FUNCTION
d540 1
a540 1
krb5_error_code KRB5_LIB_FUNCTION
a544 10
}

krb5_boolean KRB5_LIB_FUNCTION
krb5_is_thread_safe(void)
{
#ifdef ENABLE_PTHREAD_SUPPORT
    return TRUE;
#else
    return FALSE;
#endif
@


