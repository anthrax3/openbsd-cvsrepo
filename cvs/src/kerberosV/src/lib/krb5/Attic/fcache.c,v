head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.8
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.6;

1.6
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.04.09.21.17;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.29.16.20.31;	author biorn;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.02.02.19.02;	author avsm;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.41;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.41;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.35;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.51;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.36;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.17;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.7
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2008 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Portions Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"

typedef struct krb5_fcache{
    char *filename;
    int version;
}krb5_fcache;

struct fcc_cursor {
    int fd;
    krb5_storage *sp;
};

#define KRB5_FCC_FVNO_1 1
#define KRB5_FCC_FVNO_2 2
#define KRB5_FCC_FVNO_3 3
#define KRB5_FCC_FVNO_4 4

#define FCC_TAG_DELTATIME 1

#define FCACHE(X) ((krb5_fcache*)(X)->data.data)

#define FILENAME(X) (FCACHE(X)->filename)

#define FCC_CURSOR(C) ((struct fcc_cursor*)(C))

static const char* KRB5_CALLCONV
fcc_get_name(krb5_context context,
	     krb5_ccache id)
{
    if (FCACHE(id) == NULL)
        return NULL;

    return FILENAME(id);
}

int
_krb5_xlock(krb5_context context, int fd, krb5_boolean exclusive,
	    const char *filename)
{
    int ret;
#ifdef HAVE_FCNTL
    struct flock l;

    l.l_start = 0;
    l.l_len = 0;
    l.l_type = exclusive ? F_WRLCK : F_RDLCK;
    l.l_whence = SEEK_SET;
    ret = fcntl(fd, F_SETLKW, &l);
#else
    ret = flock(fd, exclusive ? LOCK_EX : LOCK_SH);
#endif
    if(ret < 0)
	ret = errno;
    if(ret == EACCES) /* fcntl can return EACCES instead of EAGAIN */
	ret = EAGAIN;

    switch (ret) {
    case 0:
	break;
    case EINVAL: /* filesystem doesn't support locking, let the user have it */
	ret = 0;
	break;
    case EAGAIN:
	krb5_set_error_message(context, ret,
			       N_("timed out locking cache file %s", "file"),
			       filename);
	break;
    default: {
	char buf[128];
	rk_strerror_r(ret, buf, sizeof(buf));
	krb5_set_error_message(context, ret,
			       N_("error locking cache file %s: %s",
				  "file, error"), filename, buf);
	break;
    }
    }
    return ret;
}

int
_krb5_xunlock(krb5_context context, int fd)
{
    int ret;
#ifdef HAVE_FCNTL
    struct flock l;
    l.l_start = 0;
    l.l_len = 0;
    l.l_type = F_UNLCK;
    l.l_whence = SEEK_SET;
    ret = fcntl(fd, F_SETLKW, &l);
#else
    ret = flock(fd, LOCK_UN);
#endif
    if (ret < 0)
	ret = errno;
    switch (ret) {
    case 0:
	break;
    case EINVAL: /* filesystem doesn't support locking, let the user have it */
	ret = 0;
	break;
    default: {
	char buf[128];
	rk_strerror_r(ret, buf, sizeof(buf));
	krb5_set_error_message(context, ret,
			       N_("Failed to unlock file: %s", ""), buf);
	break;
    }
    }
    return ret;
}

static krb5_error_code
write_storage(krb5_context context, krb5_storage *sp, int fd)
{
    krb5_error_code ret;
    krb5_data data;
    ssize_t sret;

    ret = krb5_storage_to_data(sp, &data);
    if (ret) {
	krb5_set_error_message(context, ret, N_("malloc: out of memory", ""));
	return ret;
    }
    sret = write(fd, data.data, data.length);
    ret = (sret != (ssize_t)data.length);
    krb5_data_free(&data);
    if (ret) {
	ret = errno;
	krb5_set_error_message(context, ret,
			       N_("Failed to write FILE credential data", ""));
	return ret;
    }
    return 0;
}


static krb5_error_code KRB5_CALLCONV
fcc_lock(krb5_context context, krb5_ccache id,
	 int fd, krb5_boolean exclusive)
{
    return _krb5_xlock(context, fd, exclusive, fcc_get_name(context, id));
}

static krb5_error_code KRB5_CALLCONV
fcc_unlock(krb5_context context, int fd)
{
    return _krb5_xunlock(context, fd);
}

static krb5_error_code KRB5_CALLCONV
fcc_resolve(krb5_context context, krb5_ccache *id, const char *res)
{
    krb5_fcache *f;
    f = malloc(sizeof(*f));
    if(f == NULL) {
	krb5_set_error_message(context, KRB5_CC_NOMEM,
			       N_("malloc: out of memory", ""));
	return KRB5_CC_NOMEM;
    }
    f->filename = strdup(res);
    if(f->filename == NULL){
	free(f);
	krb5_set_error_message(context, KRB5_CC_NOMEM,
			       N_("malloc: out of memory", ""));
	return KRB5_CC_NOMEM;
    }
    f->version = 0;
    (*id)->data.data = f;
    (*id)->data.length = sizeof(*f);
    return 0;
}

/*
 * Try to scrub the contents of `filename' safely.
 */

static int
scrub_file (int fd)
{
    off_t pos;
    char buf[128];

    pos = lseek(fd, 0, SEEK_END);
    if (pos < 0)
        return errno;
    if (lseek(fd, 0, SEEK_SET) < 0)
        return errno;
    memset(buf, 0, sizeof(buf));
    while(pos > 0) {
        ssize_t tmp = write(fd, buf, min((off_t)sizeof(buf), pos));

	if (tmp < 0)
	    return errno;
	pos -= tmp;
    }
#ifdef _MSC_VER
    _commit (fd);
#else
    fsync (fd);
#endif
    return 0;
}

/*
 * Erase `filename' if it exists, trying to remove the contents if
 * it's `safe'.  We always try to remove the file, it it exists.  It's
 * only overwritten if it's a regular file (not a symlink and not a
 * hardlink)
 */

krb5_error_code
_krb5_erase_file(krb5_context context, const char *filename)
{
    int fd;
    struct stat sb1, sb2;
    int ret;

    ret = lstat (filename, &sb1);
    if (ret < 0)
	return errno;

    fd = open(filename, O_RDWR | O_BINARY);
    if(fd < 0) {
	if(errno == ENOENT)
	    return 0;
	else
	    return errno;
    }
    rk_cloexec(fd);
    ret = _krb5_xlock(context, fd, 1, filename);
    if (ret) {
	close(fd);
	return ret;
    }
    if (unlink(filename) < 0) {
	_krb5_xunlock(context, fd);
        close (fd);
        return errno;
    }
    ret = fstat (fd, &sb2);
    if (ret < 0) {
	_krb5_xunlock(context, fd);
	close (fd);
	return errno;
    }

    /* check if someone was playing with symlinks */

    if (sb1.st_dev != sb2.st_dev || sb1.st_ino != sb2.st_ino) {
	_krb5_xunlock(context, fd);
	close (fd);
	return EPERM;
    }

    /* there are still hard links to this file */

    if (sb2.st_nlink != 0) {
	_krb5_xunlock(context, fd);
        close (fd);
        return 0;
    }

    ret = scrub_file (fd);
    if (ret) {
	_krb5_xunlock(context, fd);
	close(fd);
	return ret;
    }
    ret = _krb5_xunlock(context, fd);
    close (fd);
    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_gen_new(krb5_context context, krb5_ccache *id)
{
    char *file = NULL, *exp_file = NULL;
    krb5_error_code ret;
    krb5_fcache *f;
    int fd;

    f = malloc(sizeof(*f));
    if(f == NULL) {
	krb5_set_error_message(context, KRB5_CC_NOMEM,
			       N_("malloc: out of memory", ""));
	return KRB5_CC_NOMEM;
    }
    ret = asprintf (&file, "%sXXXXXX", KRB5_DEFAULT_CCFILE_ROOT);
    if(ret < 0 || file == NULL) {
	free(f);
	krb5_set_error_message(context, KRB5_CC_NOMEM,
			       N_("malloc: out of memory", ""));
	return KRB5_CC_NOMEM;
    }
    ret = _krb5_expand_path_tokens(context, file, &exp_file);
    free(file);
    if (ret)
	return ret;

    file = exp_file;

    fd = mkstemp(exp_file);
    if(fd < 0) {
	int xret = errno;
	krb5_set_error_message(context, xret, N_("mkstemp %s failed", ""), exp_file);
	free(f);
	free(exp_file);
	return xret;
    }
    close(fd);
    f->filename = exp_file;
    f->version = 0;
    (*id)->data.data = f;
    (*id)->data.length = sizeof(*f);
    return 0;
}

static void
storage_set_flags(krb5_context context, krb5_storage *sp, int vno)
{
    int flags = 0;
    switch(vno) {
    case KRB5_FCC_FVNO_1:
	flags |= KRB5_STORAGE_PRINCIPAL_WRONG_NUM_COMPONENTS;
	flags |= KRB5_STORAGE_PRINCIPAL_NO_NAME_TYPE;
	flags |= KRB5_STORAGE_HOST_BYTEORDER;
	break;
    case KRB5_FCC_FVNO_2:
	flags |= KRB5_STORAGE_HOST_BYTEORDER;
	break;
    case KRB5_FCC_FVNO_3:
	flags |= KRB5_STORAGE_KEYBLOCK_KEYTYPE_TWICE;
	break;
    case KRB5_FCC_FVNO_4:
	break;
    default:
	krb5_abortx(context,
		    "storage_set_flags called with bad vno (%x)", vno);
    }
    krb5_storage_set_flags(sp, flags);
}

static krb5_error_code KRB5_CALLCONV
fcc_open(krb5_context context,
	 krb5_ccache id,
	 int *fd_ret,
	 int flags,
	 mode_t mode)
{
    krb5_boolean exclusive = ((flags | O_WRONLY) == flags ||
			      (flags | O_RDWR) == flags);
    krb5_error_code ret;
    const char *filename;
    int fd;

    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    filename = FILENAME(id);

    fd = open(filename, flags, mode);
    if(fd < 0) {
	char buf[128];
	ret = errno;
	rk_strerror_r(ret, buf, sizeof(buf));
	krb5_set_error_message(context, ret, N_("open(%s): %s", "file, error"),
			       filename, buf);
	return ret;
    }
    rk_cloexec(fd);

    if((ret = fcc_lock(context, id, fd, exclusive)) != 0) {
	close(fd);
	return ret;
    }
    *fd_ret = fd;
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_initialize(krb5_context context,
	       krb5_ccache id,
	       krb5_principal primary_principal)
{
    krb5_fcache *f = FCACHE(id);
    int ret = 0;
    int fd;

    if (f == NULL)
        return krb5_einval(context, 2);

    unlink (f->filename);

    ret = fcc_open(context, id, &fd, O_RDWR | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, 0600);
    if(ret)
	return ret;
    {
	krb5_storage *sp;
	sp = krb5_storage_emem();
	krb5_storage_set_eof_code(sp, KRB5_CC_END);
	if(context->fcache_vno != 0)
	    f->version = context->fcache_vno;
	else
	    f->version = KRB5_FCC_FVNO_4;
	ret |= krb5_store_int8(sp, 5);
	ret |= krb5_store_int8(sp, f->version);
	storage_set_flags(context, sp, f->version);
	if(f->version == KRB5_FCC_FVNO_4 && ret == 0) {
	    /* V4 stuff */
	    if (context->kdc_sec_offset) {
		ret |= krb5_store_int16 (sp, 12); /* length */
		ret |= krb5_store_int16 (sp, FCC_TAG_DELTATIME); /* Tag */
		ret |= krb5_store_int16 (sp, 8); /* length of data */
		ret |= krb5_store_int32 (sp, context->kdc_sec_offset);
		ret |= krb5_store_int32 (sp, context->kdc_usec_offset);
	    } else {
		ret |= krb5_store_int16 (sp, 0);
	    }
	}
	ret |= krb5_store_principal(sp, primary_principal);

	ret |= write_storage(context, sp, fd);

	krb5_storage_free(sp);
    }
    fcc_unlock(context, fd);
    if (close(fd) < 0)
	if (ret == 0) {
	    char buf[128];
	    ret = errno;
	    rk_strerror_r(ret, buf, sizeof(buf));
	    krb5_set_error_message (context, ret, N_("close %s: %s", ""),
				    FILENAME(id), buf);
	}
    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_close(krb5_context context,
	  krb5_ccache id)
{
    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    free (FILENAME(id));
    krb5_data_free(&id->data);
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_destroy(krb5_context context,
	    krb5_ccache id)
{
    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    _krb5_erase_file(context, FILENAME(id));
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_store_cred(krb5_context context,
	       krb5_ccache id,
	       krb5_creds *creds)
{
    int ret;
    int fd;

    ret = fcc_open(context, id, &fd, O_WRONLY | O_APPEND | O_BINARY | O_CLOEXEC, 0);
    if(ret)
	return ret;
    {
	krb5_storage *sp;

	sp = krb5_storage_emem();
	krb5_storage_set_eof_code(sp, KRB5_CC_END);
	storage_set_flags(context, sp, FCACHE(id)->version);
	if (!krb5_config_get_bool_default(context, NULL, TRUE,
					  "libdefaults",
					  "fcc-mit-ticketflags",
					  NULL))
	    krb5_storage_set_flags(sp, KRB5_STORAGE_CREDS_FLAGS_WRONG_BITORDER);
	ret = krb5_store_creds(sp, creds);
	if (ret == 0)
	    ret = write_storage(context, sp, fd);
	krb5_storage_free(sp);
    }
    fcc_unlock(context, fd);
    if (close(fd) < 0) {
	if (ret == 0) {
	    char buf[128];
	    rk_strerror_r(ret, buf, sizeof(buf));
	    ret = errno;
	    krb5_set_error_message (context, ret, N_("close %s: %s", ""),
				    FILENAME(id), buf);
	}
    }
    return ret;
}

static krb5_error_code
init_fcc (krb5_context context,
	  krb5_ccache id,
	  krb5_storage **ret_sp,
	  int *ret_fd,
	  krb5_deltat *kdc_offset)
{
    int fd;
    int8_t pvno, tag;
    krb5_storage *sp;
    krb5_error_code ret;

    if (kdc_offset)
	*kdc_offset = 0;

    ret = fcc_open(context, id, &fd, O_RDONLY | O_BINARY | O_CLOEXEC, 0);
    if(ret)
	return ret;

    sp = krb5_storage_from_fd(fd);
    if(sp == NULL) {
	krb5_clear_error_message(context);
	ret = ENOMEM;
	goto out;
    }
    krb5_storage_set_eof_code(sp, KRB5_CC_END);
    ret = krb5_ret_int8(sp, &pvno);
    if(ret != 0) {
	if(ret == KRB5_CC_END) {
	    ret = ENOENT;
	    krb5_set_error_message(context, ret,
				   N_("Empty credential cache file: %s", ""),
				   FILENAME(id));
	} else
	    krb5_set_error_message(context, ret, N_("Error reading pvno "
						    "in cache file: %s", ""),
				   FILENAME(id));
	goto out;
    }
    if(pvno != 5) {
	ret = KRB5_CCACHE_BADVNO;
	krb5_set_error_message(context, ret, N_("Bad version number in credential "
						"cache file: %s", ""),
			       FILENAME(id));
	goto out;
    }
    ret = krb5_ret_int8(sp, &tag); /* should not be host byte order */
    if(ret != 0) {
	ret = KRB5_CC_FORMAT;
	krb5_set_error_message(context, ret, "Error reading tag in "
			      "cache file: %s", FILENAME(id));
	goto out;
    }
    FCACHE(id)->version = tag;
    storage_set_flags(context, sp, FCACHE(id)->version);
    switch (tag) {
    case KRB5_FCC_FVNO_4: {
	int16_t length;

	ret = krb5_ret_int16 (sp, &length);
	if(ret) {
	    ret = KRB5_CC_FORMAT;
	    krb5_set_error_message(context, ret,
				   N_("Error reading tag length in "
				      "cache file: %s", ""), FILENAME(id));
	    goto out;
	}
	while(length > 0) {
	    int16_t dtag, data_len;
	    int i;
	    int8_t dummy;

	    ret = krb5_ret_int16 (sp, &dtag);
	    if(ret) {
		ret = KRB5_CC_FORMAT;
		krb5_set_error_message(context, ret, N_("Error reading dtag in "
							"cache file: %s", ""),
				       FILENAME(id));
		goto out;
	    }
	    ret = krb5_ret_int16 (sp, &data_len);
	    if(ret) {
		ret = KRB5_CC_FORMAT;
		krb5_set_error_message(context, ret,
				       N_("Error reading dlength "
					  "in cache file: %s",""),
				       FILENAME(id));
		goto out;
	    }
	    switch (dtag) {
	    case FCC_TAG_DELTATIME : {
		int32_t offset;

		ret = krb5_ret_int32 (sp, &offset);
		ret |= krb5_ret_int32 (sp, &context->kdc_usec_offset);
		if(ret) {
		    ret = KRB5_CC_FORMAT;
		    krb5_set_error_message(context, ret,
					   N_("Error reading kdc_sec in "
					      "cache file: %s", ""),
					   FILENAME(id));
		    goto out;
		}
		context->kdc_sec_offset = offset;
		if (kdc_offset)
		    *kdc_offset = offset;
		break;
	    }
	    default :
		for (i = 0; i < data_len; ++i) {
		    ret = krb5_ret_int8 (sp, &dummy);
		    if(ret) {
			ret = KRB5_CC_FORMAT;
			krb5_set_error_message(context, ret,
					       N_("Error reading unknown "
						  "tag in cache file: %s", ""),
					       FILENAME(id));
			goto out;
		    }
		}
		break;
	    }
	    length -= 4 + data_len;
	}
	break;
    }
    case KRB5_FCC_FVNO_3:
    case KRB5_FCC_FVNO_2:
    case KRB5_FCC_FVNO_1:
	break;
    default :
	ret = KRB5_CCACHE_BADVNO;
	krb5_set_error_message(context, ret,
			       N_("Unknown version number (%d) in "
				  "credential cache file: %s", ""),
			       (int)tag, FILENAME(id));
	goto out;
    }
    *ret_sp = sp;
    *ret_fd = fd;

    return 0;
  out:
    if(sp != NULL)
	krb5_storage_free(sp);
    fcc_unlock(context, fd);
    close(fd);
    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_get_principal(krb5_context context,
		  krb5_ccache id,
		  krb5_principal *principal)
{
    krb5_error_code ret;
    int fd;
    krb5_storage *sp;

    ret = init_fcc (context, id, &sp, &fd, NULL);
    if (ret)
	return ret;
    ret = krb5_ret_principal(sp, principal);
    if (ret)
	krb5_clear_error_message(context);
    krb5_storage_free(sp);
    fcc_unlock(context, fd);
    close(fd);
    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_end_get (krb5_context context,
	     krb5_ccache id,
	     krb5_cc_cursor *cursor);

static krb5_error_code KRB5_CALLCONV
fcc_get_first (krb5_context context,
	       krb5_ccache id,
	       krb5_cc_cursor *cursor)
{
    krb5_error_code ret;
    krb5_principal principal;

    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    *cursor = malloc(sizeof(struct fcc_cursor));
    if (*cursor == NULL) {
        krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memset(*cursor, 0, sizeof(struct fcc_cursor));

    ret = init_fcc (context, id, &FCC_CURSOR(*cursor)->sp,
		    &FCC_CURSOR(*cursor)->fd, NULL);
    if (ret) {
	free(*cursor);
	*cursor = NULL;
	return ret;
    }
    ret = krb5_ret_principal (FCC_CURSOR(*cursor)->sp, &principal);
    if(ret) {
	krb5_clear_error_message(context);
	fcc_end_get(context, id, cursor);
	return ret;
    }
    krb5_free_principal (context, principal);
    fcc_unlock(context, FCC_CURSOR(*cursor)->fd);
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_get_next (krb5_context context,
	      krb5_ccache id,
	      krb5_cc_cursor *cursor,
	      krb5_creds *creds)
{
    krb5_error_code ret;

    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    if (FCC_CURSOR(*cursor) == NULL)
        return krb5_einval(context, 3);

    if((ret = fcc_lock(context, id, FCC_CURSOR(*cursor)->fd, FALSE)) != 0)
	return ret;

    ret = krb5_ret_creds(FCC_CURSOR(*cursor)->sp, creds);
    if (ret)
	krb5_clear_error_message(context);

    fcc_unlock(context, FCC_CURSOR(*cursor)->fd);
    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_end_get (krb5_context context,
	     krb5_ccache id,
	     krb5_cc_cursor *cursor)
{

    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    if (FCC_CURSOR(*cursor) == NULL)
        return krb5_einval(context, 3);

    krb5_storage_free(FCC_CURSOR(*cursor)->sp);
    close (FCC_CURSOR(*cursor)->fd);
    free(*cursor);
    *cursor = NULL;
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_remove_cred(krb5_context context,
		 krb5_ccache id,
		 krb5_flags which,
		 krb5_creds *cred)
{
    krb5_error_code ret;
    krb5_ccache copy, newfile;
    char *newname = NULL;
    int fd;

    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, &copy);
    if (ret)
	return ret;

    ret = krb5_cc_copy_cache(context, id, copy);
    if (ret) {
	krb5_cc_destroy(context, copy);
	return ret;
    }

    ret = krb5_cc_remove_cred(context, copy, which, cred);
    if (ret) {
	krb5_cc_destroy(context, copy);
	return ret;
    }

    ret = asprintf(&newname, "FILE:%s.XXXXXX", FILENAME(id));
    if (ret < 0 || newname == NULL) {
	krb5_cc_destroy(context, copy);
	return ENOMEM;
    }

    fd = mkstemp(&newname[5]);
    if (fd < 0) {
	ret = errno;
	krb5_cc_destroy(context, copy);
	return ret;
    }
    close(fd);

    ret = krb5_cc_resolve(context, newname, &newfile);
    if (ret) {
	unlink(&newname[5]);
	free(newname);
	krb5_cc_destroy(context, copy);
	return ret;
    }

    ret = krb5_cc_copy_cache(context, copy, newfile);
    krb5_cc_destroy(context, copy);
    if (ret) {
	free(newname);
	krb5_cc_destroy(context, newfile);
	return ret;
    }

    ret = rk_rename(&newname[5], FILENAME(id));
    if (ret)
	ret = errno;
    free(newname);
    krb5_cc_close(context, newfile);

    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_set_flags(krb5_context context,
	      krb5_ccache id,
	      krb5_flags flags)
{
    if (FCACHE(id) == NULL)
        return krb5_einval(context, 2);

    return 0; /* XXX */
}

static int KRB5_CALLCONV
fcc_get_version(krb5_context context,
		krb5_ccache id)
{
    if (FCACHE(id) == NULL)
        return -1;

    return FCACHE(id)->version;
}

struct fcache_iter {
    int first;
};

static krb5_error_code KRB5_CALLCONV
fcc_get_cache_first(krb5_context context, krb5_cc_cursor *cursor)
{
    struct fcache_iter *iter;

    iter = calloc(1, sizeof(*iter));
    if (iter == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    iter->first = 1;
    *cursor = iter;
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_get_cache_next(krb5_context context, krb5_cc_cursor cursor, krb5_ccache *id)
{
    struct fcache_iter *iter = cursor;
    krb5_error_code ret;
    const char *fn;
    char *expandedfn = NULL;

    if (iter == NULL)
        return krb5_einval(context, 2);

    if (!iter->first) {
	krb5_clear_error_message(context);
	return KRB5_CC_END;
    }
    iter->first = 0;

    fn = krb5_cc_default_name(context);
    if (fn == NULL || strncasecmp(fn, "FILE:", 5) != 0) {
	ret = _krb5_expand_default_cc_name(context,
					   KRB5_DEFAULT_CCNAME_FILE,
					   &expandedfn);
	if (ret)
	    return ret;
	fn = expandedfn;
    }
    /* check if file exists, don't return a non existant "next" */
    if (strncasecmp(fn, "FILE:", 5) == 0) {
	struct stat sb;
	ret = stat(fn + 5, &sb);
	if (ret) {
	    ret = KRB5_CC_END;
	    goto out;
	}
    }
    ret = krb5_cc_resolve(context, fn, id);
 out:
    if (expandedfn)
	free(expandedfn);

    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_end_cache_get(krb5_context context, krb5_cc_cursor cursor)
{
    struct fcache_iter *iter = cursor;

    if (iter == NULL)
        return krb5_einval(context, 2);

    free(iter);
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_move(krb5_context context, krb5_ccache from, krb5_ccache to)
{
    krb5_error_code ret = 0;

    ret = rk_rename(FILENAME(from), FILENAME(to));

    if (ret && errno != EXDEV) {
	char buf[128];
	ret = errno;
	rk_strerror_r(ret, buf, sizeof(buf));
	krb5_set_error_message(context, ret,
			       N_("Rename of file from %s "
				  "to %s failed: %s", ""),
			       FILENAME(from), FILENAME(to), buf);
	return ret;
    } else if (ret && errno == EXDEV) {
	/* make a copy and delete the orignal */
	krb5_ssize_t sz1, sz2;
	int fd1, fd2;
	char buf[BUFSIZ];

	ret = fcc_open(context, from, &fd1, O_RDONLY | O_BINARY | O_CLOEXEC, 0);
	if(ret)
	    return ret;

	unlink(FILENAME(to));

	ret = fcc_open(context, to, &fd2,
		       O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, 0600);
	if(ret)
	    goto out1;

	while((sz1 = read(fd1, buf, sizeof(buf))) > 0) {
	    sz2 = write(fd2, buf, sz1);
	    if (sz1 != sz2) {
		ret = EIO;
		krb5_set_error_message(context, ret,
				       N_("Failed to write data from one file "
					  "credential cache to the other", ""));
		goto out2;
	    }
	}
	if (sz1 < 0) {
	    ret = EIO;
	    krb5_set_error_message(context, ret,
				   N_("Failed to read data from one file "
				      "credential cache to the other", ""));
	    goto out2;
	}
    out2:
	fcc_unlock(context, fd2);
	close(fd2);

    out1:
	fcc_unlock(context, fd1);
	close(fd1);

	_krb5_erase_file(context, FILENAME(from));

	if (ret) {
	    _krb5_erase_file(context, FILENAME(to));
	    return ret;
	}
    }

    /* make sure ->version is uptodate */
    {
	krb5_storage *sp;
	int fd;
	if ((ret = init_fcc (context, to, &sp, &fd, NULL)) == 0) {
	    if (sp)
		krb5_storage_free(sp);
	    fcc_unlock(context, fd);
	    close(fd);
	}
    }

    fcc_close(context, from);

    return ret;
}

static krb5_error_code KRB5_CALLCONV
fcc_get_default_name(krb5_context context, char **str)
{
    return _krb5_expand_default_cc_name(context,
					KRB5_DEFAULT_CCNAME_FILE,
					str);
}

static krb5_error_code KRB5_CALLCONV
fcc_lastchange(krb5_context context, krb5_ccache id, krb5_timestamp *mtime)
{
    krb5_error_code ret;
    struct stat sb;
    int fd;

    ret = fcc_open(context, id, &fd, O_RDONLY | O_BINARY | O_CLOEXEC, 0);
    if(ret)
	return ret;
    ret = fstat(fd, &sb);
    close(fd);
    if (ret) {
	ret = errno;
	krb5_set_error_message(context, ret, N_("Failed to stat cache file", ""));
	return ret;
    }
    *mtime = sb.st_mtime;
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_set_kdc_offset(krb5_context context, krb5_ccache id, krb5_deltat kdc_offset)
{
    return 0;
}

static krb5_error_code KRB5_CALLCONV
fcc_get_kdc_offset(krb5_context context, krb5_ccache id, krb5_deltat *kdc_offset)
{
    krb5_error_code ret;
    krb5_storage *sp = NULL;
    int fd;
    ret = init_fcc(context, id, &sp, &fd, kdc_offset);
    if (sp)
	krb5_storage_free(sp);
    fcc_unlock(context, fd);
    close(fd);

    return ret;
}


/**
 * Variable containing the FILE based credential cache implemention.
 *
 * @@ingroup krb5_ccache
 */

KRB5_LIB_VARIABLE const krb5_cc_ops krb5_fcc_ops = {
    KRB5_CC_OPS_VERSION,
    "FILE",
    fcc_get_name,
    fcc_resolve,
    fcc_gen_new,
    fcc_initialize,
    fcc_destroy,
    fcc_close,
    fcc_store_cred,
    NULL, /* fcc_retrieve */
    fcc_get_principal,
    fcc_get_first,
    fcc_get_next,
    fcc_end_get,
    fcc_remove_cred,
    fcc_set_flags,
    fcc_get_version,
    fcc_get_cache_first,
    fcc_get_cache_next,
    fcc_end_cache_get,
    fcc_move,
    fcc_get_default_name,
    NULL,
    fcc_lastchange,
    fcc_set_kdc_offset,
    fcc_get_kdc_offset
};
@


1.6
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.5
log
@fix use after free in error paths
ok sthen@@ fgsch@@
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 1
a6 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d8 3
a10 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d12 2
a13 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d15 3
a17 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d19 15
a33 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a37 2
RCSID("$KTH: fcache.c,v 1.48 2005/05/31 22:06:15 lha Exp $");

d61 1
a61 1
static const char*
d65 3
d96 1
a96 1
	ret = 0; 
d99 3
a101 2
	krb5_set_error_string(context, "timed out locking cache file %s", 
			      filename);
d103 6
a108 3
    default:
	krb5_set_error_string(context, "error locking cache file %s: %s",
			      filename, strerror(ret));
d111 1
d119 1
a119 1
#ifdef HAVE_FCNTL_LOCK
d135 1
a135 1
	ret = 0; 
d137 5
a141 3
    default:
	krb5_set_error_string(context, 
			      "Failed to unlock file: %s", strerror(ret));
d144 1
d149 25
d180 1
a180 1
static krb5_error_code
d186 1
a186 1
static krb5_error_code
d192 2
a193 1
	krb5_set_error_string(context, "malloc: out of memory");
d199 2
a200 1
	krb5_set_error_string(context, "malloc: out of memory");
d226 1
a226 1
        ssize_t tmp = write(fd, buf, min(sizeof(buf), pos));
d232 3
d236 1
d247 2
a248 2
static krb5_error_code
erase_file(const char *filename)
d265 6
d272 1
d278 1
d286 1
d294 1
d300 6
d310 1
a310 1
static krb5_error_code
d313 2
a316 1
    char *file;
d320 2
a321 1
	krb5_set_error_string(context, "malloc: out of memory");
d324 2
a325 2
    asprintf (&file, "%sXXXXXXXXXX", KRB5_DEFAULT_CCFILE_ROOT);
    if(file == NULL) {
d327 2
a328 1
	krb5_set_error_string(context, "malloc: out of memory");
d331 8
a338 1
    fd = mkstemp(file);
d340 2
d343 2
a344 3
	krb5_set_error_string(context, "mkstemp %s", file);
	free(file);
	return errno;
d347 1
a347 1
    f->filename = file;
d373 1
a373 1
	krb5_abortx(context, 
d379 1
a379 1
static krb5_error_code
d389 1
a389 1
    const char *filename = FILENAME(id);
d391 6
d399 1
d401 3
a403 2
	krb5_set_error_string(context, "open(%s): %s", filename,
			      strerror(ret));
d406 2
a407 1
	
d416 1
a416 1
static krb5_error_code
a423 1
    char *filename = f->filename;
d425 6
a430 3
    unlink (filename);
  
    ret = fcc_open(context, id, &fd, O_RDWR | O_CREAT | O_EXCL | O_BINARY, 0600);
d434 2
a435 2
	krb5_storage *sp;    
	sp = krb5_storage_from_fd(fd);
d457 3
a459 1
	
d465 1
d467 3
a469 2
	    krb5_set_error_string (context, "close %s: %s", 
				   FILENAME(id), strerror(ret));
d474 1
a474 1
static krb5_error_code
d478 3
d486 1
a486 1
static krb5_error_code
d490 4
a493 1
    erase_file(FILENAME(id));
d497 1
a497 1
static krb5_error_code
d505 1
a505 1
    ret = fcc_open(context, id, &fd, O_WRONLY | O_APPEND | O_BINARY, 0);
d510 2
a511 1
	sp = krb5_storage_from_fd(fd);
d520 2
d525 1
a525 1
    if (close(fd) < 0)
d527 2
d530 2
a531 2
	    krb5_set_error_string (context, "close %s: %s", 
				   FILENAME(id), strerror(ret));
d533 1
d541 2
a542 1
	  int *ret_fd)
d549 4
a552 1
    ret = fcc_open(context, id, &fd, O_RDONLY | O_BINARY, 0);
d555 1
a555 1
    
d558 1
a558 1
	krb5_clear_error_string(context);
d565 9
a573 3
	if(ret == KRB5_CC_END)
	    ret = ENOENT; /* empty file */
	krb5_clear_error_string(context);
a576 2
	krb5_set_error_string(context, "Bad version number in credential "
			      "cache file: %s", FILENAME(id));
d578 3
a584 1
	krb5_clear_error_string(context);
d586 2
d599 3
a601 1
	    krb5_clear_error_string(context);
d605 1
a605 1
	    int16_t tag, data_len;
d609 1
a609 1
	    ret = krb5_ret_int16 (sp, &tag);
a610 1
		krb5_clear_error_string(context);
d612 3
a618 1
		krb5_clear_error_string(context);
d620 4
d626 6
a631 9
	    switch (tag) {
	    case FCC_TAG_DELTATIME :
		ret = krb5_ret_int32 (sp, &context->kdc_sec_offset);
		if(ret) {
		    krb5_clear_error_string(context);
		    ret = KRB5_CC_FORMAT;
		    goto out;
		}
		ret = krb5_ret_int32 (sp, &context->kdc_usec_offset);
a632 1
		    krb5_clear_error_string(context);
d634 4
d640 3
d644 1
a648 1
			krb5_clear_error_string(context);
d650 4
d669 4
a672 3
	krb5_set_error_string(context, "Unknown version number (%d) in "
			      "credential cache file: %s",
			      (int)tag, FILENAME(id));
d677 1
a677 1
    
d687 1
a687 1
static krb5_error_code
d696 1
a696 1
    ret = init_fcc (context, id, &sp, &fd);
d701 1
a701 1
	krb5_clear_error_string(context);
d708 1
a708 1
static krb5_error_code
d713 1
a713 1
static krb5_error_code
d721 3
d726 1
a726 1
        krb5_set_error_string (context, "malloc: out of memory");
d731 2
a732 2
    ret = init_fcc (context, id, &FCC_CURSOR(*cursor)->sp, 
		    &FCC_CURSOR(*cursor)->fd);
d740 1
a740 1
	krb5_clear_error_string(context);
d749 1
a749 1
static krb5_error_code
d756 7
d768 1
a768 1
	krb5_clear_error_string(context);
d774 1
a774 1
static krb5_error_code
d779 7
d793 1
a793 1
static krb5_error_code
d800 6
a805 1
    krb5_ccache copy;
d807 1
a807 1
    ret = krb5_cc_gen_new(context, &krb5_mcc_ops, &copy);
d823 13
a835 1
    fcc_destroy(context, id);
d837 9
a845 1
    ret = krb5_cc_copy_cache(context, copy, id);
d847 11
d862 1
a862 1
static krb5_error_code
d867 3
d873 1
a873 1
static krb5_error_code
d877 3
d882 217
a1098 2
		    
const krb5_cc_ops krb5_fcc_ops = {
d1114 10
a1123 1
    fcc_get_version
@


1.4
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d273 1
a274 1
	krb5_set_error_string(context, "mkstemp %s", file);
@


1.3
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.34.6.6 2004/03/10 13:30:59 lha Exp $");
d108 1
a108 1
_krb5_xunlock(int fd)
d110 1
d117 1
a117 1
    return fcntl(fd, F_SETLKW, &l);
d119 1
a119 1
    return flock(fd, LOCK_UN);
d121 14
d147 1
a147 1
    return _krb5_xunlock(fd);
d423 6
a428 7
	if (krb5_config_get_bool_default(context, NULL, FALSE,
					 "libdefaults",
					 "fcc-mit-ticketflags",
					 NULL))
	    ret = _krb5_store_creds_heimdal_0_7(sp, creds);
	else
	    ret = _krb5_store_creds_heimdal_pre_0_7(sp, creds);
a452 1

d458 1
d467 1
d471 2
d478 1
d491 1
d501 1
d507 1
d515 1
d521 1
d530 1
d547 3
d577 2
d599 5
d609 1
d614 1
d634 2
d659 25
a683 1
    return 0; /* XXX */
@


1.2
log
@bump mktemp randomness from 6 to 10 X's
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.34 2002/04/18 14:01:29 joda Exp $");
d68 67
a211 1

d296 28
d335 2
a336 5
    fd = open(filename, O_RDWR | O_CREAT | O_EXCL | O_BINARY, 0600);
    if(fd == -1) {
	ret = errno;
	krb5_set_error_string(context, "open(%s): %s", filename,
			      strerror(ret));
a337 1
    }
d362 1
d365 2
a366 1
    if(close(fd) < 0)
d369 2
a370 2
	    krb5_set_error_string (context, "close %s: %s", filename,
				   strerror(ret));
a371 1
	
d388 1
a388 5
    char *f;
    f = FILENAME(id);

    erase_file(f);
  
a398 1
    char *f;
d400 2
a401 6
    f = FILENAME(id);

    fd = open(f, O_WRONLY | O_APPEND | O_BINARY);
    if(fd < 0) {
	ret = errno;
	krb5_set_error_string (context, "open(%s): %s", f, strerror(ret));
a402 1
    }
d408 7
a414 1
	ret = krb5_store_creds(sp, creds);
d417 1
d421 2
a422 1
	    krb5_set_error_string (context, "close %s: %s", f, strerror(ret));
a427 14
fcc_read_cred (krb5_context context,
	       krb5_fcache *fc,
	       krb5_storage *sp,
	       krb5_creds *creds)
{
    krb5_error_code ret;

    storage_set_flags(context, sp, fc->version);
    
    ret = krb5_ret_creds(sp, creds);
    return ret;
}

static krb5_error_code
d429 1
a429 1
	  krb5_fcache *fcache,
d438 3
a440 5
    fd = open(fcache->filename, O_RDONLY | O_BINARY);
    if(fd < 0) {
	ret = errno;
	krb5_set_error_string(context, "open(%s): %s", fcache->filename,
			      strerror(ret));
d442 5
a447 1
    sp = krb5_storage_from_fd(fd);
d450 5
a454 4
    if(ret == KRB5_CC_END)
	return ENOENT;
    if(ret)
	return ret;
d456 7
a462 3
	krb5_storage_free(sp);
	close(fd);
	return KRB5_CCACHE_BADVNO;
d464 2
a465 3
    krb5_ret_int8(sp, &tag); /* should not be host byte order */
    fcache->version = tag;
    storage_set_flags(context, sp, fcache->version);
d470 5
a474 1
	krb5_ret_int16 (sp, &length);
d480 10
a489 2
	    krb5_ret_int16 (sp, &tag);
	    krb5_ret_int16 (sp, &data_len);
d492 10
a501 2
		krb5_ret_int32 (sp, &context->kdc_sec_offset);
		krb5_ret_int32 (sp, &context->kdc_usec_offset);
d504 7
a510 2
		for (i = 0; i < data_len; ++i)
		    krb5_ret_int8 (sp, &dummy);
d522 2
a523 3
	krb5_storage_free (sp);
	close (fd);
	return KRB5_CCACHE_BADVNO;
d527 1
d529 6
a542 1
    krb5_fcache *f = FCACHE(id);
d546 1
a546 1
    ret = init_fcc (context, f, &sp, &fd);
d551 1
d557 5
a567 1
    krb5_fcache *f = FCACHE(id);
d571 1
a571 1
    ret = init_fcc (context, f, &FCC_CURSOR(*cursor)->sp, 
d573 7
a579 1
    if (ret)
d581 1
a581 1
    krb5_ret_principal (FCC_CURSOR(*cursor)->sp, &principal);
d583 1
d593 8
a600 1
    return fcc_read_cred (context, FCACHE(id), FCC_CURSOR(*cursor)->sp, creds);
d611 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.31 2000/12/05 09:15:10 joda Exp $");
d61 1
a61 1
static char*
d73 2
a74 1
    if(f == NULL)
d76 1
d80 1
d177 1
d179 2
a180 1
    if(f == NULL)
d182 2
a183 1
    asprintf (&file, "%sXXXXXX", KRB5_DEFAULT_CCFILE_ROOT);
d186 1
d193 1
d242 6
a247 2
    if(fd == -1)
	return errno;
d251 1
d275 1
a275 1
	if (ret == 0)
d277 3
d317 5
a321 2
    if(fd < 0)
	return errno;
d325 1
d331 1
a331 1
	if (ret == 0)
d333 2
d364 6
a369 2
    if(fd < 0)
	return errno;
d371 1
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.33 2001/05/14 06:14:46 assar Exp $");
d73 1
a73 2
    if(f == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a74 1
    }
a77 1
	krb5_set_error_string(context, "malloc: out of memory");
a173 1

d175 1
a175 2
    if(f == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a176 1
    }
a179 1
	krb5_set_error_string(context, "malloc: out of memory");
a185 1
	krb5_set_error_string(context, "mkstemp %s", file);
d234 2
a235 6
    if(fd == -1) {
	ret = errno;
	krb5_set_error_string(context, "open(%s): %s", filename,
			      strerror(ret));
	return ret;
    }
d262 1
a262 1
	if (ret == 0) {
a263 3
	    krb5_set_error_string (context, "close %s: %s", filename,
				   strerror(ret));
	}
d301 2
a302 5
    if(fd < 0) {
	ret = errno;
	krb5_set_error_string (context, "open(%s): %s", f, strerror(ret));
	return ret;
    }
d311 1
a311 1
	if (ret == 0) {
a312 2
	    krb5_set_error_string (context, "close %s: %s", f, strerror(ret));
	}
d342 2
a343 6
    if(fd < 0) {
	ret = errno;
	krb5_set_error_string(context, "open(%s): %s", fcache->filename,
			      strerror(ret));
	return ret;
    }
d346 1
a346 2
    if(ret == KRB5_CC_END) {

a347 1
    }
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.34 2002/04/18 14:01:29 joda Exp $");
d61 1
a61 1
static const char*
a250 1
	krb5_storage_set_eof_code(sp, KRB5_CC_END);
a323 1
	krb5_storage_set_eof_code(sp, KRB5_CC_END);
a368 1
    krb5_storage_set_eof_code(sp, KRB5_CC_END);
d370 2
a371 1
    if(ret == KRB5_CC_END)
d373 1
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.34.6.6 2004/03/10 13:30:59 lha Exp $");
a67 67
int
_krb5_xlock(krb5_context context, int fd, krb5_boolean exclusive,
	    const char *filename)
{
    int ret;
#ifdef HAVE_FCNTL
    struct flock l;

    l.l_start = 0;
    l.l_len = 0;
    l.l_type = exclusive ? F_WRLCK : F_RDLCK;
    l.l_whence = SEEK_SET;
    ret = fcntl(fd, F_SETLKW, &l);
#else
    ret = flock(fd, exclusive ? LOCK_EX : LOCK_SH);
#endif
    if(ret < 0)
	ret = errno;
    if(ret == EACCES) /* fcntl can return EACCES instead of EAGAIN */
	ret = EAGAIN;

    switch (ret) {
    case 0:
	break;
    case EINVAL: /* filesystem doesn't support locking, let the user have it */
	ret = 0; 
	break;
    case EAGAIN:
	krb5_set_error_string(context, "timed out locking cache file %s", 
			      filename);
	break;
    default:
	krb5_set_error_string(context, "error locking cache file %s: %s",
			      filename, strerror(ret));
	break;
    }
    return ret;
}

int
_krb5_xunlock(int fd)
{
#ifdef HAVE_FCNTL_LOCK
    struct flock l;
    l.l_start = 0;
    l.l_len = 0;
    l.l_type = F_UNLCK;
    l.l_whence = SEEK_SET;
    return fcntl(fd, F_SETLKW, &l);
#else
    return flock(fd, LOCK_UN);
#endif
}

static krb5_error_code
fcc_lock(krb5_context context, krb5_ccache id,
	 int fd, krb5_boolean exclusive)
{
    return _krb5_xlock(context, fd, exclusive, fcc_get_name(context, id));
}

static krb5_error_code
fcc_unlock(krb5_context context, int fd)
{
    return _krb5_xunlock(fd);
}

d145 1
a229 28
fcc_open(krb5_context context,
	 krb5_ccache id,
	 int *fd_ret,
	 int flags,
	 mode_t mode)
{
    krb5_boolean exclusive = ((flags | O_WRONLY) == flags ||
			      (flags | O_RDWR) == flags);
    krb5_error_code ret;
    const char *filename = FILENAME(id);
    int fd;
    fd = open(filename, flags, mode);
    if(fd < 0) {
	ret = errno;
	krb5_set_error_string(context, "open(%s): %s", filename,
			      strerror(ret));
	return ret;
    }
	
    if((ret = fcc_lock(context, id, fd, exclusive)) != 0) {
	close(fd);
	return ret;
    }
    *fd_ret = fd;
    return 0;
}

static krb5_error_code
d241 5
a245 2
    ret = fcc_open(context, id, &fd, O_RDWR | O_CREAT | O_EXCL | O_BINARY, 0600);
    if(ret)
d247 1
a271 1
	
d274 1
a274 2
    fcc_unlock(context, fd);
    if (close(fd) < 0)
d277 2
a278 2
	    krb5_set_error_string (context, "close %s: %s", 
				   FILENAME(id), strerror(ret));
d280 1
d297 5
a301 1
    erase_file(FILENAME(id));
d312 1
d314 6
a319 2
    ret = fcc_open(context, id, &fd, O_WRONLY | O_APPEND | O_BINARY, 0);
    if(ret)
d321 1
d327 1
a327 7
	if (krb5_config_get_bool_default(context, NULL, FALSE,
					 "libdefaults",
					 "fcc-mit-ticketflags",
					 NULL))
	    ret = _krb5_store_creds_heimdal_0_7(sp, creds);
	else
	    ret = _krb5_store_creds_heimdal_pre_0_7(sp, creds);
a329 1
    fcc_unlock(context, fd);
d333 1
a333 2
	    krb5_set_error_string (context, "close %s: %s", 
				   FILENAME(id), strerror(ret));
d339 14
d354 1
a354 1
	  krb5_ccache id,
d363 5
a367 3
    ret = fcc_open(context, id, &fd, O_RDONLY | O_BINARY, 0);

    if(ret)
d369 1
a369 1
    
a370 4
    if(sp == NULL) {
	ret = ENOMEM;
	goto out;
    }
d373 4
a376 5
    if(ret != 0) {
	if(ret == KRB5_CC_END)
	    ret = ENOENT; /* empty file */
	goto out;
    }
d378 3
a380 2
	ret = KRB5_CCACHE_BADVNO;
	goto out;
d382 3
a384 7
    ret = krb5_ret_int8(sp, &tag); /* should not be host byte order */
    if(ret != 0) {
	ret = KRB5_CC_FORMAT;
	goto out;
    }
    FCACHE(id)->version = tag;
    storage_set_flags(context, sp, FCACHE(id)->version);
d389 1
a389 5
	ret = krb5_ret_int16 (sp, &length);
	if(ret) {
	    ret = KRB5_CC_FORMAT;
	    goto out;
	}
d395 2
a396 10
	    ret = krb5_ret_int16 (sp, &tag);
	    if(ret) {
		ret = KRB5_CC_FORMAT;
		goto out;
	    }
	    ret = krb5_ret_int16 (sp, &data_len);
	    if(ret) {
		ret = KRB5_CC_FORMAT;
		goto out;
	    }
d399 2
a400 10
		ret = krb5_ret_int32 (sp, &context->kdc_sec_offset);
		if(ret) {
		    ret = KRB5_CC_FORMAT;
		    goto out;
		}
		ret = krb5_ret_int32 (sp, &context->kdc_usec_offset);
		if(ret) {
		    ret = KRB5_CC_FORMAT;
		    goto out;
		}
d403 2
a404 7
		for (i = 0; i < data_len; ++i) {
		    ret = krb5_ret_int8 (sp, &dummy);
		    if(ret) {
			ret = KRB5_CC_FORMAT;
			goto out;
		    }
		}
d416 3
a418 2
	ret = KRB5_CCACHE_BADVNO;
	goto out;
a421 1
    
a422 6
  out:
    if(sp != NULL)
	krb5_storage_free(sp);
    fcc_unlock(context, fd);
    close(fd);
    return ret;
d431 1
d435 1
a435 1
    ret = init_fcc (context, id, &sp, &fd);
a439 1
    fcc_unlock(context, fd);
a444 5
fcc_end_get (krb5_context context,
	     krb5_ccache id,
	     krb5_cc_cursor *cursor);

static krb5_error_code
d451 1
d455 1
a455 1
    ret = init_fcc (context, id, &FCC_CURSOR(*cursor)->sp, 
d457 1
a457 7
    if (ret) {
	free(*cursor);
	return ret;
    }
    ret = krb5_ret_principal (FCC_CURSOR(*cursor)->sp, &principal);
    if(ret) {
	fcc_end_get(context, id, cursor);
d459 1
a459 1
    }
a460 1
    fcc_unlock(context, FCC_CURSOR(*cursor)->fd);
d470 1
a470 8
    krb5_error_code ret;
    if((ret = fcc_lock(context, id, FCC_CURSOR(*cursor)->fd, FALSE)) != 0)
	return ret;

    ret = krb5_ret_creds(FCC_CURSOR(*cursor)->sp, creds);

    fcc_unlock(context, FCC_CURSOR(*cursor)->fd);
    return ret;
a480 1
    *cursor = NULL;
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: fcache.c,v 1.48 2005/05/31 22:06:15 lha Exp $");
d108 1
a108 1
_krb5_xunlock(krb5_context context, int fd)
a109 1
    int ret;
d116 1
a116 1
    ret = fcntl(fd, F_SETLKW, &l);
d118 1
a118 1
    ret = flock(fd, LOCK_UN);
a119 14
    if (ret < 0)
	ret = errno;
    switch (ret) {
    case 0:
	break;
    case EINVAL: /* filesystem doesn't support locking, let the user have it */
	ret = 0; 
	break;
    default:
	krb5_set_error_string(context, 
			      "Failed to unlock file: %s", strerror(ret));
	break;
    }
    return ret;
d132 1
a132 1
    return _krb5_xunlock(context, fd);
d408 7
a414 6
	if (!krb5_config_get_bool_default(context, NULL, TRUE,
					  "libdefaults",
					  "fcc-mit-ticketflags",
					  NULL))
	    krb5_storage_set_flags(sp, KRB5_STORAGE_CREDS_FLAGS_WRONG_BITORDER);
	ret = krb5_store_creds(sp, creds);
d439 1
a444 1
	krb5_clear_error_string(context);
a452 1
	krb5_clear_error_string(context);
a455 2
	krb5_set_error_string(context, "Bad version number in credential "
			      "cache file: %s", FILENAME(id));
a460 1
	krb5_clear_error_string(context);
a472 1
	    krb5_clear_error_string(context);
a481 1
		krb5_clear_error_string(context);
a486 1
		krb5_clear_error_string(context);
a493 1
		    krb5_clear_error_string(context);
a498 1
		    krb5_clear_error_string(context);
a506 1
			krb5_clear_error_string(context);
a522 3
	krb5_set_error_string(context, "Unknown version number (%d) in "
			      "credential cache file: %s",
			      (int)tag, FILENAME(id));
a549 2
    if (ret)
	krb5_clear_error_string(context);
a569 5
    if (*cursor == NULL) {
        krb5_set_error_string (context, "malloc: out of memory");
	return ENOMEM;
    }
    memset(*cursor, 0, sizeof(struct fcc_cursor));
a574 1
	*cursor = NULL;
a578 1
	krb5_clear_error_string(context);
a597 2
    if (ret)
	krb5_clear_error_string(context);
d621 1
a621 25
    krb5_error_code ret;
    krb5_ccache copy;

    ret = krb5_cc_gen_new(context, &krb5_mcc_ops, &copy);
    if (ret)
	return ret;

    ret = krb5_cc_copy_cache(context, id, copy);
    if (ret) {
	krb5_cc_destroy(context, copy);
	return ret;
    }

    ret = krb5_cc_remove_cred(context, copy, which, cred);
    if (ret) {
	krb5_cc_destroy(context, copy);
	return ret;
    }

    fcc_destroy(context, id);

    ret = krb5_cc_copy_cache(context, copy, id);
    krb5_cc_destroy(context, copy);

    return ret;
@


