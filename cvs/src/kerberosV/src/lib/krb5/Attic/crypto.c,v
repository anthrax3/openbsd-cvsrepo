head	1.17;
access;
symbols
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.12
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.14
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.10
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.16;

1.16
date	2014.04.18.09.47.36;	author ajacoutot;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.17.18.57.44;	author robert;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.05.19.38.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.21.07.35.26;	author blambert;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.28.20.28.17;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.26.16.16.26;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches
	1.10.10.1
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.26.22.03.58;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.29.16.20.30;	author biorn;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.15.05.43.52;	author mho;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.06.00.37.37;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.06.09.10.02;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.27.15.22.46;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.41;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.41;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.23.34;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.26;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.51;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.36;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.33.16;	author biorn;	state Exp;
branches;
next	;

1.10.10.1
date	2010.03.31.12.15.01;	author jasper;	state Exp;
branches;
next	;

1.10.12.1
date	2010.03.31.12.15.30;	author jasper;	state Exp;
branches;
next	;

1.10.14.1
date	2010.03.31.12.15.13;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.17
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2008 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb5_locl.h"

struct _krb5_key_usage {
    unsigned usage;
    struct _krb5_key_data key;
};


#ifndef HEIMDAL_SMALLER
#define DES3_OLD_ENCTYPE 1
#endif

static krb5_error_code _get_derived_key(krb5_context, krb5_crypto,
					unsigned, struct _krb5_key_data**);
static struct _krb5_key_data *_new_derived_key(krb5_crypto crypto, unsigned usage);

static void free_key_schedule(krb5_context,
			      struct _krb5_key_data *,
			      struct _krb5_encryption_type *);

/* 
 * Converts etype to a user readable string and sets as a side effect
 * the krb5_error_message containing this string. Returns
 * KRB5_PROG_ETYPE_NOSUPP in not the conversion of the etype failed in
 * which case the error code of the etype convesion is returned.
 */

static krb5_error_code
unsupported_enctype(krb5_context context, krb5_enctype etype)
{
    krb5_error_code ret;
    char *name;

    ret = krb5_enctype_to_string(context, etype, &name);
    if (ret)
	return ret;

    krb5_set_error_message(context, KRB5_PROG_ETYPE_NOSUPP,
			   N_("Encryption type %s not supported", ""),
			   name);
    free(name);
    return KRB5_PROG_ETYPE_NOSUPP;
}

/*
 *
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_keysize(krb5_context context,
		     krb5_enctype type,
		     size_t *keysize)
{
    struct _krb5_encryption_type *et = _krb5_find_enctype(type);
    if(et == NULL) {
        return unsupported_enctype (context, type);
    }
    *keysize = et->keytype->size;
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_keybits(krb5_context context,
		     krb5_enctype type,
		     size_t *keybits)
{
    struct _krb5_encryption_type *et = _krb5_find_enctype(type);
    if(et == NULL) {
        return unsupported_enctype (context, type);
    }
    *keybits = et->keytype->bits;
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_generate_random_keyblock(krb5_context context,
			      krb5_enctype type,
			      krb5_keyblock *key)
{
    krb5_error_code ret;
    struct _krb5_encryption_type *et = _krb5_find_enctype(type);
    if(et == NULL) {
        return unsupported_enctype (context, type);
    }
    ret = krb5_data_alloc(&key->keyvalue, et->keytype->size);
    if(ret)
	return ret;
    key->keytype = type;
    if(et->keytype->random_key)
	(*et->keytype->random_key)(context, key);
    else
	krb5_generate_random_block(key->keyvalue.data,
				   key->keyvalue.length);
    return 0;
}

static krb5_error_code
_key_schedule(krb5_context context,
	      struct _krb5_key_data *key)
{
    krb5_error_code ret;
    struct _krb5_encryption_type *et = _krb5_find_enctype(key->key->keytype);
    struct _krb5_key_type *kt;

    if (et == NULL) {
        return unsupported_enctype (context,
                               key->key->keytype);
    }

    kt = et->keytype;

    if(kt->schedule == NULL)
	return 0;
    if (key->schedule != NULL)
	return 0;
    ALLOC(key->schedule, 1);
    if(key->schedule == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    ret = krb5_data_alloc(key->schedule, kt->schedule_size);
    if(ret) {
	free(key->schedule);
	key->schedule = NULL;
	return ret;
    }
    (*kt->schedule)(context, kt, key);
    return 0;
}

/************************************************************
 *                                                          *
 ************************************************************/

static krb5_error_code
SHA1_checksum(krb5_context context,
	      struct _krb5_key_data *key,
	      const void *data,
	      size_t len,
	      unsigned usage,
	      Checksum *C)
{
    if (EVP_Digest(data, len, C->checksum.data, NULL, EVP_sha1(), NULL) != 1)
	krb5_abortx(context, "sha1 checksum failed");
    return 0;
}

/* HMAC according to RFC2104 */
krb5_error_code
_krb5_internal_hmac(krb5_context context,
		    struct _krb5_checksum_type *cm,
		    const void *data,
		    size_t len,
		    unsigned usage,
		    struct _krb5_key_data *keyblock,
		    Checksum *result)
{
    unsigned char *ipad, *opad;
    unsigned char *key;
    size_t key_len;
    size_t i;

    ipad = malloc(cm->blocksize + len);
    if (ipad == NULL)
	return ENOMEM;
    opad = malloc(cm->blocksize + cm->checksumsize);
    if (opad == NULL) {
	free(ipad);
	return ENOMEM;
    }
    memset(ipad, 0x36, cm->blocksize);
    memset(opad, 0x5c, cm->blocksize);

    if(keyblock->key->keyvalue.length > cm->blocksize){
	(*cm->checksum)(context,
			keyblock,
			keyblock->key->keyvalue.data,
			keyblock->key->keyvalue.length,
			usage,
			result);
	key = result->checksum.data;
	key_len = result->checksum.length;
    } else {
	key = keyblock->key->keyvalue.data;
	key_len = keyblock->key->keyvalue.length;
    }
    for(i = 0; i < key_len; i++){
	ipad[i] ^= key[i];
	opad[i] ^= key[i];
    }
    memcpy(ipad + cm->blocksize, data, len);
    (*cm->checksum)(context, keyblock, ipad, cm->blocksize + len,
		    usage, result);
    memcpy(opad + cm->blocksize, result->checksum.data,
	   result->checksum.length);
    (*cm->checksum)(context, keyblock, opad,
		    cm->blocksize + cm->checksumsize, usage, result);
    memset(ipad, 0, cm->blocksize + len);
    free(ipad);
    memset(opad, 0, cm->blocksize + cm->checksumsize);
    free(opad);

    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_hmac(krb5_context context,
	  krb5_cksumtype cktype,
	  const void *data,
	  size_t len,
	  unsigned usage,
	  krb5_keyblock *key,
	  Checksum *result)
{
    struct _krb5_checksum_type *c = _krb5_find_checksum(cktype);
    struct _krb5_key_data kd;
    krb5_error_code ret;

    if (c == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %d not supported", ""),
				cktype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    kd.key = key;
    kd.schedule = NULL;

    ret = _krb5_internal_hmac(context, c, data, len, usage, &kd, result);

    if (kd.schedule)
	krb5_free_data(context, kd.schedule);

    return ret;
}

krb5_error_code
_krb5_SP_HMAC_SHA1_checksum(krb5_context context,
			    struct _krb5_key_data *key,
			    const void *data,
			    size_t len,
			    unsigned usage,
			    Checksum *result)
{
    struct _krb5_checksum_type *c = _krb5_find_checksum(CKSUMTYPE_SHA1);
    Checksum res;
    char sha1_data[20];
    krb5_error_code ret;

    res.checksum.data = sha1_data;
    res.checksum.length = sizeof(sha1_data);

    ret = _krb5_internal_hmac(context, c, data, len, usage, key, &res);
    if (ret)
	krb5_abortx(context, "hmac failed");
    memcpy(result->checksum.data, res.checksum.data, result->checksum.length);
    return 0;
}

struct _krb5_checksum_type _krb5_checksum_sha1 = {
    CKSUMTYPE_SHA1,
    "sha1",
    64,
    20,
    F_CPROOF,
    SHA1_checksum,
    NULL
};

struct _krb5_checksum_type *
_krb5_find_checksum(krb5_cksumtype type)
{
    int i;
    for(i = 0; i < _krb5_num_checksums; i++)
	if(_krb5_checksum_types[i]->type == type)
	    return _krb5_checksum_types[i];
    return NULL;
}

static krb5_error_code
get_checksum_key(krb5_context context,
		 krb5_crypto crypto,
		 unsigned usage,  /* not krb5_key_usage */
		 struct _krb5_checksum_type *ct,
		 struct _krb5_key_data **key)
{
    krb5_error_code ret = 0;

    if(ct->flags & F_DERIVED)
	ret = _get_derived_key(context, crypto, usage, key);
    else if(ct->flags & F_VARIANT) {
	size_t i;

	*key = _new_derived_key(crypto, 0xff/* KRB5_KU_RFC1510_VARIANT */);
	if(*key == NULL) {
	    krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	    return ENOMEM;
	}
	ret = krb5_copy_keyblock(context, crypto->key.key, &(*key)->key);
	if(ret)
	    return ret;
	for(i = 0; i < (*key)->key->keyvalue.length; i++)
	    ((unsigned char*)(*key)->key->keyvalue.data)[i] ^= 0xF0;
    } else {
	*key = &crypto->key;
    }
    if(ret == 0)
	ret = _key_schedule(context, *key);
    return ret;
}

static krb5_error_code
create_checksum (krb5_context context,
		 struct _krb5_checksum_type *ct,
		 krb5_crypto crypto,
		 unsigned usage,
		 void *data,
		 size_t len,
		 Checksum *result)
{
    krb5_error_code ret;
    struct _krb5_key_data *dkey;
    int keyed_checksum;

    if (ct->flags & F_DISABLED) {
	krb5_clear_error_message (context);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    keyed_checksum = (ct->flags & F_KEYED) != 0;
    if(keyed_checksum && crypto == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("Checksum type %s is keyed but no "
				   "crypto context (key) was passed in", ""),
				ct->name);
	return KRB5_PROG_SUMTYPE_NOSUPP; /* XXX */
    }
    if(keyed_checksum) {
	ret = get_checksum_key(context, crypto, usage, ct, &dkey);
	if (ret)
	    return ret;
    } else
	dkey = NULL;
    result->cksumtype = ct->type;
    ret = krb5_data_alloc(&result->checksum, ct->checksumsize);
    if (ret)
	return (ret);
    return (*ct->checksum)(context, dkey, data, len, usage, result);
}

static int
arcfour_checksum_p(struct _krb5_checksum_type *ct, krb5_crypto crypto)
{
    return (ct->type == CKSUMTYPE_HMAC_MD5) &&
	(crypto->key.key->keytype == KEYTYPE_ARCFOUR);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_create_checksum(krb5_context context,
		     krb5_crypto crypto,
		     krb5_key_usage usage,
		     int type,
		     void *data,
		     size_t len,
		     Checksum *result)
{
    struct _krb5_checksum_type *ct = NULL;
    unsigned keyusage;

    /* type 0 -> pick from crypto */
    if (type) {
	ct = _krb5_find_checksum(type);
    } else if (crypto) {
	ct = crypto->et->keyed_checksum;
	if (ct == NULL)
	    ct = crypto->et->checksum;
    }

    if(ct == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %d not supported", ""),
				type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    if (arcfour_checksum_p(ct, crypto)) {
	keyusage = usage;
	_krb5_usage2arcfour(context, &keyusage);
    } else
	keyusage = CHECKSUM_USAGE(usage);

    return create_checksum(context, ct, crypto, keyusage,
			   data, len, result);
}

static krb5_error_code
verify_checksum(krb5_context context,
		krb5_crypto crypto,
		unsigned usage, /* not krb5_key_usage */
		void *data,
		size_t len,
		Checksum *cksum)
{
    krb5_error_code ret;
    struct _krb5_key_data *dkey;
    int keyed_checksum;
    Checksum c;
    struct _krb5_checksum_type *ct;

    ct = _krb5_find_checksum(cksum->cksumtype);
    if (ct == NULL || (ct->flags & F_DISABLED)) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %d not supported", ""),
				cksum->cksumtype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    if(ct->checksumsize != cksum->checksum.length) {
	krb5_clear_error_message (context);
	krb5_set_error_message(context, KRB5KRB_AP_ERR_BAD_INTEGRITY,
			       N_("Decrypt integrity check failed for checksum type %s, "
				  "length was %u, expected %u", ""),
			       ct->name, (unsigned)cksum->checksum.length,
			       (unsigned)ct->checksumsize);

	return KRB5KRB_AP_ERR_BAD_INTEGRITY; /* XXX */
    }
    keyed_checksum = (ct->flags & F_KEYED) != 0;
    if(keyed_checksum) {
	struct _krb5_checksum_type *kct;
	if (crypto == NULL) {
	    krb5_set_error_message(context, KRB5_PROG_SUMTYPE_NOSUPP,
				   N_("Checksum type %s is keyed but no "
				      "crypto context (key) was passed in", ""),
				   ct->name);
	    return KRB5_PROG_SUMTYPE_NOSUPP; /* XXX */
	}
	kct = crypto->et->keyed_checksum;
	if (kct == NULL || kct->type != ct->type) {
	    krb5_set_error_message(context, KRB5_PROG_SUMTYPE_NOSUPP,
				   N_("Checksum type %s is keyed, but "
				      "the key type %s passed didnt have that checksum "
				      "type as the keyed type", ""),
				    ct->name, crypto->et->name);
	    return KRB5_PROG_SUMTYPE_NOSUPP; /* XXX */
	}

	ret = get_checksum_key(context, crypto, usage, ct, &dkey);
	if (ret)
	    return ret;
    } else
	dkey = NULL;

    /*
     * If checksum have a verify function, lets use that instead of
     * calling ->checksum and then compare result.
     */

    if(ct->verify) {
	ret = (*ct->verify)(context, dkey, data, len, usage, cksum);
	if (ret)
	    krb5_set_error_message(context, ret,
				   N_("Decrypt integrity check failed for checksum "
				      "type %s, key type %s", ""),
				   ct->name, (crypto != NULL)? crypto->et->name : "(none)");
	return ret;
    }

    ret = krb5_data_alloc (&c.checksum, ct->checksumsize);
    if (ret)
	return ret;

    ret = (*ct->checksum)(context, dkey, data, len, usage, &c);
    if (ret) {
	krb5_data_free(&c.checksum);
	return ret;
    }

    if(krb5_data_ct_cmp(&c.checksum, &cksum->checksum) != 0) {
	ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
	krb5_set_error_message(context, ret,
			       N_("Decrypt integrity check failed for checksum "
				  "type %s, key type %s", ""),
			       ct->name, crypto ? crypto->et->name : "(unkeyed)");
    } else {
	ret = 0;
    }
    krb5_data_free (&c.checksum);
    return ret;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_verify_checksum(krb5_context context,
		     krb5_crypto crypto,
		     krb5_key_usage usage,
		     void *data,
		     size_t len,
		     Checksum *cksum)
{
    struct _krb5_checksum_type *ct;
    unsigned keyusage;

    ct = _krb5_find_checksum(cksum->cksumtype);
    if(ct == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %d not supported", ""),
				cksum->cksumtype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    if (arcfour_checksum_p(ct, crypto)) {
	keyusage = usage;
	_krb5_usage2arcfour(context, &keyusage);
    } else
	keyusage = CHECKSUM_USAGE(usage);

    return verify_checksum(context, crypto, keyusage,
			   data, len, cksum);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_get_checksum_type(krb5_context context,
                              krb5_crypto crypto,
			      krb5_cksumtype *type)
{
    struct _krb5_checksum_type *ct = NULL;

    if (crypto != NULL) {
        ct = crypto->et->keyed_checksum;
        if (ct == NULL)
            ct = crypto->et->checksum;
    }

    if (ct == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type not found", ""));
        return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    *type = ct->type;

    return 0;
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_checksumsize(krb5_context context,
		  krb5_cksumtype type,
		  size_t *size)
{
    struct _krb5_checksum_type *ct = _krb5_find_checksum(type);
    if(ct == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %d not supported", ""),
				type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    *size = ct->checksumsize;
    return 0;
}

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_checksum_is_keyed(krb5_context context,
		       krb5_cksumtype type)
{
    struct _krb5_checksum_type *ct = _krb5_find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				    N_("checksum type %d not supported", ""),
				    type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    return ct->flags & F_KEYED;
}

KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_checksum_is_collision_proof(krb5_context context,
				 krb5_cksumtype type)
{
    struct _krb5_checksum_type *ct = _krb5_find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				    N_("checksum type %d not supported", ""),
				    type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    return ct->flags & F_CPROOF;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_checksum_disable(krb5_context context,
		      krb5_cksumtype type)
{
    struct _krb5_checksum_type *ct = _krb5_find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				    N_("checksum type %d not supported", ""),
				    type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    ct->flags |= F_DISABLED;
    return 0;
}

/************************************************************
 *                                                          *
 ************************************************************/

struct _krb5_encryption_type *
_krb5_find_enctype(krb5_enctype type)
{
    int i;
    for(i = 0; i < _krb5_num_etypes; i++)
	if(_krb5_etypes[i]->type == type)
	    return _krb5_etypes[i];
    return NULL;
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_to_string(krb5_context context,
		       krb5_enctype etype,
		       char **string)
{
    struct _krb5_encryption_type *e;
    e = _krb5_find_enctype(etype);
    if(e == NULL) {
	krb5_set_error_message (context, KRB5_PROG_ETYPE_NOSUPP,
				N_("encryption type %d not supported", ""),
				etype);
	*string = NULL;
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    *string = strdup(e->name);
    if(*string == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_string_to_enctype(krb5_context context,
		       const char *string,
		       krb5_enctype *etype)
{
    int i;
    for(i = 0; i < _krb5_num_etypes; i++)
	if(strcasecmp(_krb5_etypes[i]->name, string) == 0){
	    *etype = _krb5_etypes[i]->type;
	    return 0;
	}
    krb5_set_error_message (context, KRB5_PROG_ETYPE_NOSUPP,
			    N_("encryption type %s not supported", ""),
			    string);
    return KRB5_PROG_ETYPE_NOSUPP;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_to_keytype(krb5_context context,
			krb5_enctype etype,
			krb5_keytype *keytype)
{
    struct _krb5_encryption_type *e = _krb5_find_enctype(etype);
    if(e == NULL) {
        return unsupported_enctype (context, etype);
    }
    *keytype = e->keytype->type; /* XXX */
    return 0;
}

/**
 * Check if a enctype is valid, return 0 if it is.
 *
 * @@param context Kerberos context
 * @@param etype enctype to check if its valid or not
 *
 * @@return Return an error code for an failure or 0 on success (enctype valid).
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_valid(krb5_context context,
		   krb5_enctype etype)
{
    struct _krb5_encryption_type *e = _krb5_find_enctype(etype);
    if(e && (e->flags & F_DISABLED) == 0)
	return 0;
    if (context == NULL)
	return KRB5_PROG_ETYPE_NOSUPP;
    if(e == NULL) {
        return unsupported_enctype (context, etype);
    }
    /* Must be (e->flags & F_DISABLED) */
    krb5_set_error_message (context, KRB5_PROG_ETYPE_NOSUPP,
			    N_("encryption type %s is disabled", ""),
			    e->name);
    return KRB5_PROG_ETYPE_NOSUPP;
}

/**
 * Return the coresponding encryption type for a checksum type.
 *
 * @@param context Kerberos context
 * @@param ctype The checksum type to get the result enctype for
 * @@param etype The returned encryption, when the matching etype is
 * not found, etype is set to ETYPE_NULL.
 *
 * @@return Return an error code for an failure or 0 on success.
 * @@ingroup krb5_crypto
 */


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_cksumtype_to_enctype(krb5_context context,
			  krb5_cksumtype ctype,
			  krb5_enctype *etype)
{
    int i;

    *etype = ETYPE_NULL;

    for(i = 0; i < _krb5_num_etypes; i++) {
	if(_krb5_etypes[i]->keyed_checksum &&
	   _krb5_etypes[i]->keyed_checksum->type == ctype)
	    {
		*etype = _krb5_etypes[i]->type;
		return 0;
	    }
    }

    krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
			    N_("checksum type %d not supported", ""),
			    (int)ctype);
    return KRB5_PROG_SUMTYPE_NOSUPP;
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_cksumtype_valid(krb5_context context,
		     krb5_cksumtype ctype)
{
    struct _krb5_checksum_type *c = _krb5_find_checksum(ctype);
    if (c == NULL) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %d not supported", ""),
				ctype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    if (c->flags & F_DISABLED) {
	krb5_set_error_message (context, KRB5_PROG_SUMTYPE_NOSUPP,
				N_("checksum type %s is disabled", ""),
				c->name);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    return 0;
}


static krb5_boolean
derived_crypto(krb5_context context,
	       krb5_crypto crypto)
{
    return (crypto->et->flags & F_DERIVED) != 0;
}

static krb5_boolean
special_crypto(krb5_context context,
	       krb5_crypto crypto)
{
    return (crypto->et->flags & F_SPECIAL) != 0;
}

#define CHECKSUMSIZE(C) ((C)->checksumsize)
#define CHECKSUMTYPE(C) ((C)->type)

static krb5_error_code
encrypt_internal_derived(krb5_context context,
			 krb5_crypto crypto,
			 unsigned usage,
			 const void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
{
    size_t sz, block_sz, checksum_sz, total_sz;
    Checksum cksum;
    unsigned char *p, *q;
    krb5_error_code ret;
    struct _krb5_key_data *dkey;
    const struct _krb5_encryption_type *et = crypto->et;

    checksum_sz = CHECKSUMSIZE(et->keyed_checksum);

    sz = et->confoundersize + len;
    block_sz = (sz + et->padsize - 1) &~ (et->padsize - 1); /* pad */
    total_sz = block_sz + checksum_sz;
    p = calloc(1, total_sz);
    if(p == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    q = p;
    krb5_generate_random_block(q, et->confoundersize); /* XXX */
    q += et->confoundersize;
    memcpy(q, data, len);

    ret = create_checksum(context,
			  et->keyed_checksum,
			  crypto,
			  INTEGRITY_USAGE(usage),
			  p,
			  block_sz,
			  &cksum);
    if(ret == 0 && cksum.checksum.length != checksum_sz) {
	free_Checksum (&cksum);
	krb5_clear_error_message (context);
	ret = KRB5_CRYPTO_INTERNAL;
    }
    if(ret)
	goto fail;
    memcpy(p + block_sz, cksum.checksum.data, cksum.checksum.length);
    free_Checksum (&cksum);
    ret = _get_derived_key(context, crypto, ENCRYPTION_USAGE(usage), &dkey);
    if(ret)
	goto fail;
    ret = _key_schedule(context, dkey);
    if(ret)
	goto fail;
    ret = (*et->encrypt)(context, dkey, p, block_sz, 1, usage, ivec);
    if (ret)
	goto fail;
    result->data = p;
    result->length = total_sz;
    return 0;
 fail:
    memset(p, 0, total_sz);
    free(p);
    return ret;
}


static krb5_error_code
encrypt_internal(krb5_context context,
		 krb5_crypto crypto,
		 const void *data,
		 size_t len,
		 krb5_data *result,
		 void *ivec)
{
    size_t sz, block_sz, checksum_sz;
    Checksum cksum;
    unsigned char *p, *q;
    krb5_error_code ret;
    const struct _krb5_encryption_type *et = crypto->et;

    checksum_sz = CHECKSUMSIZE(et->checksum);

    sz = et->confoundersize + checksum_sz + len;
    block_sz = (sz + et->padsize - 1) &~ (et->padsize - 1); /* pad */
    p = calloc(1, block_sz);
    if(p == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }

    q = p;
    krb5_generate_random_block(q, et->confoundersize); /* XXX */
    q += et->confoundersize;
    memset(q, 0, checksum_sz);
    q += checksum_sz;
    memcpy(q, data, len);

    ret = create_checksum(context,
			  et->checksum,
			  crypto,
			  0,
			  p,
			  block_sz,
			  &cksum);
    if(ret == 0 && cksum.checksum.length != checksum_sz) {
	krb5_clear_error_message (context);
	free_Checksum(&cksum);
	ret = KRB5_CRYPTO_INTERNAL;
    }
    if(ret)
	goto fail;
    memcpy(p + et->confoundersize, cksum.checksum.data, cksum.checksum.length);
    free_Checksum(&cksum);
    ret = _key_schedule(context, &crypto->key);
    if(ret)
	goto fail;
    ret = (*et->encrypt)(context, &crypto->key, p, block_sz, 1, 0, ivec);
    if (ret) {
	memset(p, 0, block_sz);
	free(p);
	return ret;
    }
    result->data = p;
    result->length = block_sz;
    return 0;
 fail:
    memset(p, 0, block_sz);
    free(p);
    return ret;
}

static krb5_error_code
encrypt_internal_special(krb5_context context,
			 krb5_crypto crypto,
			 int usage,
			 const void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
{
    struct _krb5_encryption_type *et = crypto->et;
    size_t cksum_sz = CHECKSUMSIZE(et->checksum);
    size_t sz = len + cksum_sz + et->confoundersize;
    char *tmp, *p;
    krb5_error_code ret;

    tmp = malloc (sz);
    if (tmp == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    p = tmp;
    memset (p, 0, cksum_sz);
    p += cksum_sz;
    krb5_generate_random_block(p, et->confoundersize);
    p += et->confoundersize;
    memcpy (p, data, len);
    ret = (*et->encrypt)(context, &crypto->key, tmp, sz, TRUE, usage, ivec);
    if (ret) {
	memset(tmp, 0, sz);
	free(tmp);
	return ret;
    }
    result->data   = tmp;
    result->length = sz;
    return 0;
}

static krb5_error_code
decrypt_internal_derived(krb5_context context,
			 krb5_crypto crypto,
			 unsigned usage,
			 void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
{
    size_t checksum_sz;
    Checksum cksum;
    unsigned char *p;
    krb5_error_code ret;
    struct _krb5_key_data *dkey;
    struct _krb5_encryption_type *et = crypto->et;
    unsigned long l;

    checksum_sz = CHECKSUMSIZE(et->keyed_checksum);
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_message(context, KRB5_BAD_MSIZE,
			       N_("Encrypted data shorter then "
				  "checksum + confunder", ""));
	return KRB5_BAD_MSIZE;
    }

    if (((len - checksum_sz) % et->padsize) != 0) {
	krb5_clear_error_message(context);
	return KRB5_BAD_MSIZE;
    }

    p = malloc(len);
    if(len != 0 && p == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy(p, data, len);

    len -= checksum_sz;

    ret = _get_derived_key(context, crypto, ENCRYPTION_USAGE(usage), &dkey);
    if(ret) {
	free(p);
	return ret;
    }
    ret = _key_schedule(context, dkey);
    if(ret) {
	free(p);
	return ret;
    }
    ret = (*et->encrypt)(context, dkey, p, len, 0, usage, ivec);
    if (ret) {
	free(p);
	return ret;
    }

    cksum.checksum.data   = p + len;
    cksum.checksum.length = checksum_sz;
    cksum.cksumtype       = CHECKSUMTYPE(et->keyed_checksum);

    ret = verify_checksum(context,
			  crypto,
			  INTEGRITY_USAGE(usage),
			  p,
			  len,
			  &cksum);
    if(ret) {
	free(p);
	return ret;
    }
    l = len - et->confoundersize;
    memmove(p, p + et->confoundersize, l);
    result->data = realloc(p, l);
    if(result->data == NULL && l != 0) {
	free(p);
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    result->length = l;
    return 0;
}

static krb5_error_code
decrypt_internal(krb5_context context,
		 krb5_crypto crypto,
		 void *data,
		 size_t len,
		 krb5_data *result,
		 void *ivec)
{
    krb5_error_code ret;
    unsigned char *p;
    Checksum cksum;
    size_t checksum_sz, l;
    struct _krb5_encryption_type *et = crypto->et;

    if ((len % et->padsize) != 0) {
	krb5_clear_error_message(context);
	return KRB5_BAD_MSIZE;
    }
    checksum_sz = CHECKSUMSIZE(et->checksum);
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_message(context, KRB5_BAD_MSIZE,
			       N_("Encrypted data shorter then "
				  "checksum + confunder", ""));
	return KRB5_BAD_MSIZE;
    }

    p = malloc(len);
    if(len != 0 && p == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy(p, data, len);

    ret = _key_schedule(context, &crypto->key);
    if(ret) {
	free(p);
	return ret;
    }
    ret = (*et->encrypt)(context, &crypto->key, p, len, 0, 0, ivec);
    if (ret) {
	free(p);
	return ret;
    }
    ret = krb5_data_copy(&cksum.checksum, p + et->confoundersize, checksum_sz);
    if(ret) {
 	free(p);
 	return ret;
    }
    memset(p + et->confoundersize, 0, checksum_sz);
    cksum.cksumtype = CHECKSUMTYPE(et->checksum);
    ret = verify_checksum(context, NULL, 0, p, len, &cksum);
    free_Checksum(&cksum);
    if(ret) {
	free(p);
	return ret;
    }
    l = len - et->confoundersize - checksum_sz;
    memmove(p, p + et->confoundersize + checksum_sz, l);
    result->data = realloc(p, l);
    if(result->data == NULL && l != 0) {
	free(p);
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    result->length = l;
    return 0;
}

static krb5_error_code
decrypt_internal_special(krb5_context context,
			 krb5_crypto crypto,
			 int usage,
			 void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
{
    struct _krb5_encryption_type *et = crypto->et;
    size_t cksum_sz = CHECKSUMSIZE(et->checksum);
    size_t sz = len - cksum_sz - et->confoundersize;
    unsigned char *p;
    krb5_error_code ret;

    if ((len % et->padsize) != 0) {
	krb5_clear_error_message(context);
	return KRB5_BAD_MSIZE;
    }
    if (len < cksum_sz + et->confoundersize) {
	krb5_set_error_message(context, KRB5_BAD_MSIZE,
			       N_("Encrypted data shorter then "
				  "checksum + confunder", ""));
	return KRB5_BAD_MSIZE;
    }

    p = malloc (len);
    if (p == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    memcpy(p, data, len);

    ret = (*et->encrypt)(context, &crypto->key, p, len, FALSE, usage, ivec);
    if (ret) {
	free(p);
	return ret;
    }

    memmove (p, p + cksum_sz + et->confoundersize, sz);
    result->data = realloc(p, sz);
    if(result->data == NULL && sz != 0) {
	free(p);
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    result->length = sz;
    return 0;
}

static krb5_crypto_iov *
find_iv(krb5_crypto_iov *data, size_t num_data, unsigned type)
{
    size_t i;
    for (i = 0; i < num_data; i++)
	if (data[i].flags == type)
	    return &data[i];
    return NULL;
}

/**
 * Inline encrypt a kerberos message
 *
 * @@param context Kerberos context
 * @@param crypto Kerberos crypto context
 * @@param usage Key usage for this buffer
 * @@param data array of buffers to process
 * @@param num_data length of array
 * @@param ivec initial cbc/cts vector
 *
 * @@return Return an error code or 0.
 * @@ingroup krb5_crypto
 *
 * Kerberos encrypted data look like this:
 *
 * 1. KRB5_CRYPTO_TYPE_HEADER
 * 2. array [1,...] KRB5_CRYPTO_TYPE_DATA and array [0,...]
 *    KRB5_CRYPTO_TYPE_SIGN_ONLY in any order, however the receiver
 *    have to aware of the order. KRB5_CRYPTO_TYPE_SIGN_ONLY is
 *    commonly used headers and trailers.
 * 3. KRB5_CRYPTO_TYPE_PADDING, at least on padsize long if padsize > 1
 * 4. KRB5_CRYPTO_TYPE_TRAILER
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_encrypt_iov_ivec(krb5_context context,
		      krb5_crypto crypto,
		      unsigned usage,
		      krb5_crypto_iov *data,
		      int num_data,
		      void *ivec)
{
    size_t headersz, trailersz, len;
    int i;
    size_t sz, block_sz, pad_sz;
    Checksum cksum;
    unsigned char *p, *q;
    krb5_error_code ret;
    struct _krb5_key_data *dkey;
    const struct _krb5_encryption_type *et = crypto->et;
    krb5_crypto_iov *tiv, *piv, *hiv;

    if (num_data < 0) {
        krb5_clear_error_message(context);
	return KRB5_CRYPTO_INTERNAL;
    }

    if(!derived_crypto(context, crypto)) {
	krb5_clear_error_message(context);
	return KRB5_CRYPTO_INTERNAL;
    }

    headersz = et->confoundersize;
    trailersz = CHECKSUMSIZE(et->keyed_checksum);

    for (len = 0, i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA)
	    continue;
	len += data[i].data.length;
    }

    sz = headersz + len;
    block_sz = (sz + et->padsize - 1) &~ (et->padsize - 1); /* pad */

    pad_sz = block_sz - sz;

    /* header */

    hiv = find_iv(data, num_data, KRB5_CRYPTO_TYPE_HEADER);
    if (hiv == NULL || hiv->data.length != headersz)
	return KRB5_BAD_MSIZE;

    krb5_generate_random_block(hiv->data.data, hiv->data.length);

    /* padding */
    piv = find_iv(data, num_data, KRB5_CRYPTO_TYPE_PADDING);
    /* its ok to have no TYPE_PADDING if there is no padding */
    if (piv == NULL && pad_sz != 0)
	return KRB5_BAD_MSIZE;
    if (piv) {
	if (piv->data.length < pad_sz)
	    return KRB5_BAD_MSIZE;
	piv->data.length = pad_sz;
	if (pad_sz)
	    memset(piv->data.data, pad_sz, pad_sz);
	else
	    piv = NULL;
    }

    /* trailer */
    tiv = find_iv(data, num_data, KRB5_CRYPTO_TYPE_TRAILER);
    if (tiv == NULL || tiv->data.length != trailersz)
	return KRB5_BAD_MSIZE;

    /*
     * XXX replace with EVP_Sign? at least make create_checksum an iov
     * function.
     * XXX CTS EVP is broken, can't handle multi buffers :(
     */

    len = block_sz;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	len += data[i].data.length;
    }

    p = q = malloc(len);

    memcpy(q, hiv->data.data, hiv->data.length);
    q += hiv->data.length;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA &&
	    data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	memcpy(q, data[i].data.data, data[i].data.length);
	q += data[i].data.length;
    }
    if (piv)
	memset(q, 0, piv->data.length);

    ret = create_checksum(context,
			  et->keyed_checksum,
			  crypto,
			  INTEGRITY_USAGE(usage),
			  p,
			  len,
			  &cksum);
    free(p);
    if(ret == 0 && cksum.checksum.length != trailersz) {
	free_Checksum (&cksum);
	krb5_clear_error_message (context);
	ret = KRB5_CRYPTO_INTERNAL;
    }
    if(ret)
	return ret;

    /* save cksum at end */
    memcpy(tiv->data.data, cksum.checksum.data, cksum.checksum.length);
    free_Checksum (&cksum);

    /* XXX replace with EVP_Cipher */
    p = q = malloc(block_sz);
    if(p == NULL)
	return ENOMEM;

    memcpy(q, hiv->data.data, hiv->data.length);
    q += hiv->data.length;

    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA)
	    continue;
	memcpy(q, data[i].data.data, data[i].data.length);
	q += data[i].data.length;
    }
    if (piv)
	memset(q, 0, piv->data.length);


    ret = _get_derived_key(context, crypto, ENCRYPTION_USAGE(usage), &dkey);
    if(ret) {
	free(p);
	return ret;
    }
    ret = _key_schedule(context, dkey);
    if(ret) {
	free(p);
	return ret;
    }

    ret = (*et->encrypt)(context, dkey, p, block_sz, 1, usage, ivec);
    if (ret) {
	free(p);
	return ret;
    }

    /* now copy data back to buffers */
    q = p;

    memcpy(hiv->data.data, q, hiv->data.length);
    q += hiv->data.length;

    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA)
	    continue;
	memcpy(data[i].data.data, q, data[i].data.length);
	q += data[i].data.length;
    }
    if (piv)
	memcpy(piv->data.data, q, pad_sz);

    free(p);

    return ret;
}

/**
 * Inline decrypt a Kerberos message.
 *
 * @@param context Kerberos context
 * @@param crypto Kerberos crypto context
 * @@param usage Key usage for this buffer
 * @@param data array of buffers to process
 * @@param num_data length of array
 * @@param ivec initial cbc/cts vector
 *
 * @@return Return an error code or 0.
 * @@ingroup krb5_crypto
 *
 * 1. KRB5_CRYPTO_TYPE_HEADER
 * 2. one KRB5_CRYPTO_TYPE_DATA and array [0,...] of KRB5_CRYPTO_TYPE_SIGN_ONLY in
 *  any order, however the receiver have to aware of the
 *  order. KRB5_CRYPTO_TYPE_SIGN_ONLY is commonly used unencrypoted
 *  protocol headers and trailers. The output data will be of same
 *  size as the input data or shorter.
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_decrypt_iov_ivec(krb5_context context,
		      krb5_crypto crypto,
		      unsigned usage,
		      krb5_crypto_iov *data,
		      unsigned int num_data,
		      void *ivec)
{
    unsigned int i;
    size_t headersz, trailersz, len;
    Checksum cksum;
    unsigned char *p, *q;
    krb5_error_code ret;
    struct _krb5_key_data *dkey;
    struct _krb5_encryption_type *et = crypto->et;
    krb5_crypto_iov *tiv, *hiv;

    if(!derived_crypto(context, crypto)) {
	krb5_clear_error_message(context);
	return KRB5_CRYPTO_INTERNAL;
    }

    headersz = et->confoundersize;

    hiv = find_iv(data, num_data, KRB5_CRYPTO_TYPE_HEADER);
    if (hiv == NULL || hiv->data.length != headersz)
	return KRB5_BAD_MSIZE;

    /* trailer */
    trailersz = CHECKSUMSIZE(et->keyed_checksum);

    tiv = find_iv(data, num_data, KRB5_CRYPTO_TYPE_TRAILER);
    if (tiv->data.length != trailersz)
	return KRB5_BAD_MSIZE;

    /* Find length of data we will decrypt */

    len = headersz;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA)
	    continue;
	len += data[i].data.length;
    }

    if ((len % et->padsize) != 0) {
	krb5_clear_error_message(context);
	return KRB5_BAD_MSIZE;
    }

    /* XXX replace with EVP_Cipher */

    p = q = malloc(len);
    if (p == NULL)
	return ENOMEM;

    memcpy(q, hiv->data.data, hiv->data.length);
    q += hiv->data.length;

    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA)
	    continue;
	memcpy(q, data[i].data.data, data[i].data.length);
	q += data[i].data.length;
    }

    ret = _get_derived_key(context, crypto, ENCRYPTION_USAGE(usage), &dkey);
    if(ret) {
	free(p);
	return ret;
    }
    ret = _key_schedule(context, dkey);
    if(ret) {
	free(p);
	return ret;
    }

    ret = (*et->encrypt)(context, dkey, p, len, 0, usage, ivec);
    if (ret) {
	free(p);
	return ret;
    }

    /* copy data back to buffers */
    memcpy(hiv->data.data, p, hiv->data.length);
    q = p + hiv->data.length;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA)
	    continue;
	memcpy(data[i].data.data, q, data[i].data.length);
	q += data[i].data.length;
    }

    free(p);

    /* check signature */
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	len += data[i].data.length;
    }

    p = q = malloc(len);
    if (p == NULL)
	return ENOMEM;

    memcpy(q, hiv->data.data, hiv->data.length);
    q += hiv->data.length;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA &&
	    data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	memcpy(q, data[i].data.data, data[i].data.length);
	q += data[i].data.length;
    }

    cksum.checksum.data   = tiv->data.data;
    cksum.checksum.length = tiv->data.length;
    cksum.cksumtype       = CHECKSUMTYPE(et->keyed_checksum);

    ret = verify_checksum(context,
			  crypto,
			  INTEGRITY_USAGE(usage),
			  p,
			  len,
			  &cksum);
    free(p);
    return ret;
}

/**
 * Create a Kerberos message checksum.
 *
 * @@param context Kerberos context
 * @@param crypto Kerberos crypto context
 * @@param usage Key usage for this buffer
 * @@param data array of buffers to process
 * @@param num_data length of array
 * @@param type output data
 *
 * @@return Return an error code or 0.
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_create_checksum_iov(krb5_context context,
			 krb5_crypto crypto,
			 unsigned usage,
			 krb5_crypto_iov *data,
			 unsigned int num_data,
			 krb5_cksumtype *type)
{
    Checksum cksum;
    krb5_crypto_iov *civ;
    krb5_error_code ret;
    size_t i;
    size_t len;
    char *p, *q;

    if(!derived_crypto(context, crypto)) {
	krb5_clear_error_message(context);
	return KRB5_CRYPTO_INTERNAL;
    }

    civ = find_iv(data, num_data, KRB5_CRYPTO_TYPE_CHECKSUM);
    if (civ == NULL)
	return KRB5_BAD_MSIZE;

    len = 0;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA &&
	    data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	len += data[i].data.length;
    }

    p = q = malloc(len);

    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA &&
	    data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	memcpy(q, data[i].data.data, data[i].data.length);
	q += data[i].data.length;
    }

    ret = krb5_create_checksum(context, crypto, usage, 0, p, len, &cksum);
    free(p);
    if (ret)
	return ret;

    if (type)
	*type = cksum.cksumtype;

    if (cksum.checksum.length > civ->data.length) {
	krb5_set_error_message(context, KRB5_BAD_MSIZE,
			       N_("Checksum larger then input buffer", ""));
	free_Checksum(&cksum);
	return KRB5_BAD_MSIZE;
    }

    civ->data.length = cksum.checksum.length;
    memcpy(civ->data.data, cksum.checksum.data, civ->data.length);
    free_Checksum(&cksum);

    return 0;
}

/**
 * Verify a Kerberos message checksum.
 *
 * @@param context Kerberos context
 * @@param crypto Kerberos crypto context
 * @@param usage Key usage for this buffer
 * @@param data array of buffers to process
 * @@param num_data length of array
 * @@param type return checksum type if not NULL
 *
 * @@return Return an error code or 0.
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_verify_checksum_iov(krb5_context context,
			 krb5_crypto crypto,
			 unsigned usage,
			 krb5_crypto_iov *data,
			 unsigned int num_data,
			 krb5_cksumtype *type)
{
    struct _krb5_encryption_type *et = crypto->et;
    Checksum cksum;
    krb5_crypto_iov *civ;
    krb5_error_code ret;
    size_t i;
    size_t len;
    char *p, *q;

    if(!derived_crypto(context, crypto)) {
	krb5_clear_error_message(context);
	return KRB5_CRYPTO_INTERNAL;
    }

    civ = find_iv(data, num_data, KRB5_CRYPTO_TYPE_CHECKSUM);
    if (civ == NULL)
	return KRB5_BAD_MSIZE;

    len = 0;
    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA &&
	    data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	len += data[i].data.length;
    }

    p = q = malloc(len);

    for (i = 0; i < num_data; i++) {
	if (data[i].flags != KRB5_CRYPTO_TYPE_DATA &&
	    data[i].flags != KRB5_CRYPTO_TYPE_SIGN_ONLY)
	    continue;
	memcpy(q, data[i].data.data, data[i].data.length);
	q += data[i].data.length;
    }

    cksum.cksumtype = CHECKSUMTYPE(et->keyed_checksum);
    cksum.checksum.length = civ->data.length;
    cksum.checksum.data = civ->data.data;

    ret = krb5_verify_checksum(context, crypto, usage, p, len, &cksum);
    free(p);

    if (ret == 0 && type)
	*type = cksum.cksumtype;

    return ret;
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_length(krb5_context context,
		   krb5_crypto crypto,
		   int type,
		   size_t *len)
{
    if (!derived_crypto(context, crypto)) {
	krb5_set_error_message(context, EINVAL, "not a derived crypto");
	return EINVAL;
    }

    switch(type) {
    case KRB5_CRYPTO_TYPE_EMPTY:
	*len = 0;
	return 0;
    case KRB5_CRYPTO_TYPE_HEADER:
	*len = crypto->et->blocksize;
	return 0;
    case KRB5_CRYPTO_TYPE_DATA:
    case KRB5_CRYPTO_TYPE_SIGN_ONLY:
	/* len must already been filled in */
	return 0;
    case KRB5_CRYPTO_TYPE_PADDING:
	if (crypto->et->padsize > 1)
	    *len = crypto->et->padsize;
	else
	    *len = 0;
	return 0;
    case KRB5_CRYPTO_TYPE_TRAILER:
	*len = CHECKSUMSIZE(crypto->et->keyed_checksum);
	return 0;
    case KRB5_CRYPTO_TYPE_CHECKSUM:
	if (crypto->et->keyed_checksum)
	    *len = CHECKSUMSIZE(crypto->et->keyed_checksum);
	else
	    *len = CHECKSUMSIZE(crypto->et->checksum);
	return 0;
    }
    krb5_set_error_message(context, EINVAL,
			   "%d not a supported type", type);
    return EINVAL;
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_length_iov(krb5_context context,
		       krb5_crypto crypto,
		       krb5_crypto_iov *data,
		       unsigned int num_data)
{
    krb5_error_code ret;
    size_t i;

    for (i = 0; i < num_data; i++) {
	ret = krb5_crypto_length(context, crypto,
				 data[i].flags,
				 &data[i].data.length);
	if (ret)
	    return ret;
    }
    return 0;
}


KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_encrypt_ivec(krb5_context context,
		  krb5_crypto crypto,
		  unsigned usage,
		  const void *data,
		  size_t len,
		  krb5_data *result,
		  void *ivec)
{
    if(derived_crypto(context, crypto))
	return encrypt_internal_derived(context, crypto, usage,
					data, len, result, ivec);
    else if (special_crypto(context, crypto))
	return encrypt_internal_special (context, crypto, usage,
					 data, len, result, ivec);
    else
	return encrypt_internal(context, crypto, data, len, result, ivec);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_encrypt(krb5_context context,
	     krb5_crypto crypto,
	     unsigned usage,
	     const void *data,
	     size_t len,
	     krb5_data *result)
{
    return krb5_encrypt_ivec(context, crypto, usage, data, len, result, NULL);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_encrypt_EncryptedData(krb5_context context,
			   krb5_crypto crypto,
			   unsigned usage,
			   void *data,
			   size_t len,
			   int kvno,
			   EncryptedData *result)
{
    result->etype = CRYPTO_ETYPE(crypto);
    if(kvno){
	ALLOC(result->kvno, 1);
	*result->kvno = kvno;
    }else
	result->kvno = NULL;
    return krb5_encrypt(context, crypto, usage, data, len, &result->cipher);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_decrypt_ivec(krb5_context context,
		  krb5_crypto crypto,
		  unsigned usage,
		  void *data,
		  size_t len,
		  krb5_data *result,
		  void *ivec)
{
    if(derived_crypto(context, crypto))
	return decrypt_internal_derived(context, crypto, usage,
					data, len, result, ivec);
    else if (special_crypto (context, crypto))
	return decrypt_internal_special(context, crypto, usage,
					data, len, result, ivec);
    else
	return decrypt_internal(context, crypto, data, len, result, ivec);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_decrypt(krb5_context context,
	     krb5_crypto crypto,
	     unsigned usage,
	     void *data,
	     size_t len,
	     krb5_data *result)
{
    return krb5_decrypt_ivec (context, crypto, usage, data, len, result,
			      NULL);
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_decrypt_EncryptedData(krb5_context context,
			   krb5_crypto crypto,
			   unsigned usage,
			   const EncryptedData *e,
			   krb5_data *result)
{
    return krb5_decrypt(context, crypto, usage,
			e->cipher.data, e->cipher.length, result);
}

/************************************************************
 *                                                          *
 ************************************************************/

krb5_error_code
_krb5_derive_key(krb5_context context,
		 struct _krb5_encryption_type *et,
		 struct _krb5_key_data *key,
		 const void *constant,
		 size_t len)
{
    unsigned char *k = NULL;
    unsigned int nblocks = 0, i;
    krb5_error_code ret = 0;
    struct _krb5_key_type *kt = et->keytype;

    ret = _key_schedule(context, key);
    if(ret)
	return ret;
    if(et->blocksize * 8 < kt->bits || len != et->blocksize) {
	nblocks = (kt->bits + et->blocksize * 8 - 1) / (et->blocksize * 8);
	k = malloc(nblocks * et->blocksize);
	if(k == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, N_("malloc: out of memory", ""));
	    goto out;
	}
	ret = _krb5_n_fold(constant, len, k, et->blocksize);
	if (ret) {
	    krb5_set_error_message(context, ret, N_("malloc: out of memory", ""));
	    goto out;
	}

	for(i = 0; i < nblocks; i++) {
	    if(i > 0)
		memcpy(k + i * et->blocksize,
		       k + (i - 1) * et->blocksize,
		       et->blocksize);
	    (*et->encrypt)(context, key, k + i * et->blocksize, et->blocksize,
			   1, 0, NULL);
	}
    } else {
	/* this case is probably broken, but won't be run anyway */
	void *c = malloc(len);
	size_t res_len = (kt->bits + 7) / 8;

	if(len != 0 && c == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, N_("malloc: out of memory", ""));
	    goto out;
	}
	memcpy(c, constant, len);
	(*et->encrypt)(context, key, c, len, 1, 0, NULL);
	k = malloc(res_len);
	if(res_len != 0 && k == NULL) {
	    free(c);
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, N_("malloc: out of memory", ""));
	    goto out;
	}
	ret = _krb5_n_fold(c, len, k, res_len);
	free(c);
	if (ret) {
	    krb5_set_error_message(context, ret, N_("malloc: out of memory", ""));
	    goto out;
	}
    }

    /* XXX keytype dependent post-processing */
    switch(kt->type) {
    case ETYPE_OLD_DES3_CBC_SHA1:
	_krb5_DES3_random_to_key(context, key->key, k, nblocks * et->blocksize);
	break;
    case ENCTYPE_AES128_CTS_HMAC_SHA1_96:
    case ENCTYPE_AES256_CTS_HMAC_SHA1_96:
	memcpy(key->key->keyvalue.data, k, key->key->keyvalue.length);
	break;
    default:
	ret = KRB5_CRYPTO_INTERNAL;
	krb5_set_error_message(context, ret,
			       N_("derive_key() called with unknown keytype (%u)", ""),
			       kt->type);
	break;
    }
 out:
    if (key->schedule) {
	free_key_schedule(context, key, et);
	key->schedule = NULL;
    }
    if (k) {
	memset(k, 0, nblocks * et->blocksize);
	free(k);
    }
    return ret;
}

static struct _krb5_key_data *
_new_derived_key(krb5_crypto crypto, unsigned usage)
{
    struct _krb5_key_usage *d = crypto->key_usage;
    d = realloc(d, (crypto->num_key_usage + 1) * sizeof(*d));
    if(d == NULL)
	return NULL;
    crypto->key_usage = d;
    d += crypto->num_key_usage++;
    memset(d, 0, sizeof(*d));
    d->usage = usage;
    return &d->key;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_derive_key(krb5_context context,
		const krb5_keyblock *key,
		krb5_enctype etype,
		const void *constant,
		size_t constant_len,
		krb5_keyblock **derived_key)
{
    krb5_error_code ret;
    struct _krb5_encryption_type *et;
    struct _krb5_key_data d;

    *derived_key = NULL;

    et = _krb5_find_enctype (etype);
    if (et == NULL) {
        return unsupported_enctype (context, etype);
    }

    ret = krb5_copy_keyblock(context, key, &d.key);
    if (ret)
	return ret;

    d.schedule = NULL;
    ret = _krb5_derive_key(context, et, &d, constant, constant_len);
    if (ret == 0)
	ret = krb5_copy_keyblock(context, d.key, derived_key);
    _krb5_free_key_data(context, &d, et);
    return ret;
}

static krb5_error_code
_get_derived_key(krb5_context context,
		 krb5_crypto crypto,
		 unsigned usage,
		 struct _krb5_key_data **key)
{
    int i;
    struct _krb5_key_data *d;
    unsigned char constant[5];

    for(i = 0; i < crypto->num_key_usage; i++)
	if(crypto->key_usage[i].usage == usage) {
	    *key = &crypto->key_usage[i].key;
	    return 0;
	}
    d = _new_derived_key(crypto, usage);
    if(d == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    krb5_copy_keyblock(context, crypto->key.key, &d->key);
    _krb5_put_int(constant, usage, 5);
    _krb5_derive_key(context, crypto->et, d, constant, sizeof(constant));
    *key = d;
    return 0;
}

/**
 * Create a crypto context used for all encryption and signature
 * operation. The encryption type to use is taken from the key, but
 * can be overridden with the enctype parameter.  This can be useful
 * for encryptions types which is compatiable (DES for example).
 *
 * To free the crypto context, use krb5_crypto_destroy().
 *
 * @@param context Kerberos context
 * @@param key the key block information with all key data
 * @@param etype the encryption type
 * @@param crypto the resulting crypto context
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_init(krb5_context context,
		 const krb5_keyblock *key,
		 krb5_enctype etype,
		 krb5_crypto *crypto)
{
    krb5_error_code ret;
    ALLOC(*crypto, 1);
    if(*crypto == NULL) {
	krb5_set_error_message(context, ENOMEM, N_("malloc: out of memory", ""));
	return ENOMEM;
    }
    if(etype == ETYPE_NULL)
	etype = key->keytype;
    (*crypto)->et = _krb5_find_enctype(etype);
    if((*crypto)->et == NULL || ((*crypto)->et->flags & F_DISABLED)) {
	free(*crypto);
	*crypto = NULL;
	return unsupported_enctype(context, etype);
    }
    if((*crypto)->et->keytype->size != key->keyvalue.length) {
	free(*crypto);
	*crypto = NULL;
	krb5_set_error_message (context, KRB5_BAD_KEYSIZE,
				"encryption key has bad length");
	return KRB5_BAD_KEYSIZE;
    }
    ret = krb5_copy_keyblock(context, key, &(*crypto)->key.key);
    if(ret) {
	free(*crypto);
	*crypto = NULL;
	return ret;
    }
    (*crypto)->key.schedule = NULL;
    (*crypto)->num_key_usage = 0;
    (*crypto)->key_usage = NULL;
    return 0;
}

static void
free_key_schedule(krb5_context context,
		  struct _krb5_key_data *key,
		  struct _krb5_encryption_type *et)
{
    if (et->keytype->cleanup)
	(*et->keytype->cleanup)(context, key);
    memset(key->schedule->data, 0, key->schedule->length);
    krb5_free_data(context, key->schedule);
}

void
_krb5_free_key_data(krb5_context context, struct _krb5_key_data *key,
	      struct _krb5_encryption_type *et)
{
    krb5_free_keyblock(context, key->key);
    if(key->schedule) {
	free_key_schedule(context, key, et);
	key->schedule = NULL;
    }
}

static void
free_key_usage(krb5_context context, struct _krb5_key_usage *ku,
	       struct _krb5_encryption_type *et)
{
    _krb5_free_key_data(context, &ku->key, et);
}

/**
 * Free a crypto context created by krb5_crypto_init().
 *
 * @@param context Kerberos context
 * @@param crypto crypto context to free
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_destroy(krb5_context context,
		    krb5_crypto crypto)
{
    int i;

    for(i = 0; i < crypto->num_key_usage; i++)
	free_key_usage(context, &crypto->key_usage[i], crypto->et);
    free(crypto->key_usage);
    _krb5_free_key_data(context, &crypto->key, crypto->et);
    free (crypto);
    return 0;
}

/**
 * Return the blocksize used algorithm referenced by the crypto context
 *
 * @@param context Kerberos context
 * @@param crypto crypto context to query
 * @@param blocksize the resulting blocksize
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_getblocksize(krb5_context context,
			 krb5_crypto crypto,
			 size_t *blocksize)
{
    *blocksize = crypto->et->blocksize;
    return 0;
}

/**
 * Return the encryption type used by the crypto context
 *
 * @@param context Kerberos context
 * @@param crypto crypto context to query
 * @@param enctype the resulting encryption type
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_getenctype(krb5_context context,
		       krb5_crypto crypto,
		       krb5_enctype *enctype)
{
    *enctype = crypto->et->type;
    return 0;
}

/**
 * Return the padding size used by the crypto context
 *
 * @@param context Kerberos context
 * @@param crypto crypto context to query
 * @@param padsize the return padding size
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_getpadsize(krb5_context context,
                       krb5_crypto crypto,
                       size_t *padsize)
{
    *padsize = crypto->et->padsize;
    return 0;
}

/**
 * Return the confounder size used by the crypto context
 *
 * @@param context Kerberos context
 * @@param crypto crypto context to query
 * @@param confoundersize the returned confounder size
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_getconfoundersize(krb5_context context,
                              krb5_crypto crypto,
                              size_t *confoundersize)
{
    *confoundersize = crypto->et->confoundersize;
    return 0;
}


/**
 * Disable encryption type
 *
 * @@param context Kerberos 5 context
 * @@param enctype encryption type to disable
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_disable(krb5_context context,
		     krb5_enctype enctype)
{
    struct _krb5_encryption_type *et = _krb5_find_enctype(enctype);
    if(et == NULL) {
	if (context)
	    krb5_set_error_message (context, KRB5_PROG_ETYPE_NOSUPP,
				    N_("encryption type %d not supported", ""),
				    enctype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    et->flags |= F_DISABLED;
    return 0;
}

/**
 * Enable encryption type
 *
 * @@param context Kerberos 5 context
 * @@param enctype encryption type to enable
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_enctype_enable(krb5_context context,
		    krb5_enctype enctype)
{
    struct _krb5_encryption_type *et = _krb5_find_enctype(enctype);
    if(et == NULL) {
	if (context)
	    krb5_set_error_message (context, KRB5_PROG_ETYPE_NOSUPP,
				    N_("encryption type %d not supported", ""),
				    enctype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    et->flags &= ~F_DISABLED;
    return 0;
}

/**
 * Enable or disable all weak encryption types
 *
 * @@param context Kerberos 5 context
 * @@param enable true to enable, false to disable
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_allow_weak_crypto(krb5_context context,
		       krb5_boolean enable)
{
    int i;

    for(i = 0; i < _krb5_num_etypes; i++)
	if(_krb5_etypes[i]->flags & F_WEAK) {
	    if(enable)
		_krb5_etypes[i]->flags &= ~F_DISABLED;
	    else
		_krb5_etypes[i]->flags |= F_DISABLED;
	}
    return 0;
}

static size_t
wrapped_length (krb5_context context,
		krb5_crypto  crypto,
		size_t       data_len)
{
    struct _krb5_encryption_type *et = crypto->et;
    size_t padsize = et->padsize;
    size_t checksumsize = CHECKSUMSIZE(et->checksum);
    size_t res;

    res =  et->confoundersize + checksumsize + data_len;
    res =  (res + padsize - 1) / padsize * padsize;
    return res;
}

static size_t
wrapped_length_dervied (krb5_context context,
			krb5_crypto  crypto,
			size_t       data_len)
{
    struct _krb5_encryption_type *et = crypto->et;
    size_t padsize = et->padsize;
    size_t res;

    res =  et->confoundersize + data_len;
    res =  (res + padsize - 1) / padsize * padsize;
    if (et->keyed_checksum)
	res += et->keyed_checksum->checksumsize;
    else
	res += et->checksum->checksumsize;
    return res;
}

/*
 * Return the size of an encrypted packet of length `data_len'
 */

KRB5_LIB_FUNCTION size_t KRB5_LIB_CALL
krb5_get_wrapped_length (krb5_context context,
			 krb5_crypto  crypto,
			 size_t       data_len)
{
    if (derived_crypto (context, crypto))
	return wrapped_length_dervied (context, crypto, data_len);
    else
	return wrapped_length (context, crypto, data_len);
}

/*
 * Return the size of an encrypted packet of length `data_len'
 */

static size_t
crypto_overhead (krb5_context context,
		 krb5_crypto  crypto)
{
    struct _krb5_encryption_type *et = crypto->et;
    size_t res;

    res = CHECKSUMSIZE(et->checksum);
    res += et->confoundersize;
    if (et->padsize > 1)
	res += et->padsize;
    return res;
}

static size_t
crypto_overhead_dervied (krb5_context context,
			 krb5_crypto  crypto)
{
    struct _krb5_encryption_type *et = crypto->et;
    size_t res;

    if (et->keyed_checksum)
	res = CHECKSUMSIZE(et->keyed_checksum);
    else
	res = CHECKSUMSIZE(et->checksum);
    res += et->confoundersize;
    if (et->padsize > 1)
	res += et->padsize;
    return res;
}

KRB5_LIB_FUNCTION size_t KRB5_LIB_CALL
krb5_crypto_overhead (krb5_context context, krb5_crypto crypto)
{
    if (derived_crypto (context, crypto))
	return crypto_overhead_dervied (context, crypto);
    else
	return crypto_overhead (context, crypto);
}

/**
 * Converts the random bytestring to a protocol key according to
 * Kerberos crypto frame work. It may be assumed that all the bits of
 * the input string are equally random, even though the entropy
 * present in the random source may be limited.
 *
 * @@param context Kerberos 5 context
 * @@param type the enctype resulting key will be of
 * @@param data input random data to convert to a key
 * @@param size size of input random data, at least krb5_enctype_keysize() long
 * @@param key key, output key, free with krb5_free_keyblock_contents()
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_random_to_key(krb5_context context,
		   krb5_enctype type,
		   const void *data,
		   size_t size,
		   krb5_keyblock *key)
{
    krb5_error_code ret;
    struct _krb5_encryption_type *et = _krb5_find_enctype(type);
    if(et == NULL) {
	krb5_set_error_message(context, KRB5_PROG_ETYPE_NOSUPP,
			       N_("encryption type %d not supported", ""),
			       type);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    if ((et->keytype->bits + 7) / 8 > size) {
	krb5_set_error_message(context, KRB5_PROG_ETYPE_NOSUPP,
			       N_("encryption key %s needs %d bytes "
				  "of random to make an encryption key "
				  "out of it", ""),
			       et->name, (int)et->keytype->size);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    ret = krb5_data_alloc(&key->keyvalue, et->keytype->size);
    if(ret)
	return ret;
    key->keytype = type;
    if (et->keytype->random_to_key)
 	(*et->keytype->random_to_key)(context, key, data, size);
    else
	memcpy(key->keyvalue.data, data, et->keytype->size);

    return 0;
}



KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_prf_length(krb5_context context,
		       krb5_enctype type,
		       size_t *length)
{
    struct _krb5_encryption_type *et = _krb5_find_enctype(type);

    if(et == NULL || et->prf_length == 0) {
	krb5_set_error_message(context, KRB5_PROG_ETYPE_NOSUPP,
			       N_("encryption type %d not supported", ""),
			       type);
	return KRB5_PROG_ETYPE_NOSUPP;
    }

    *length = et->prf_length;
    return 0;
}

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_prf(krb5_context context,
		const krb5_crypto crypto,
		const krb5_data *input,
		krb5_data *output)
{
    struct _krb5_encryption_type *et = crypto->et;

    krb5_data_zero(output);

    if(et->prf == NULL) {
	krb5_set_error_message(context, KRB5_PROG_ETYPE_NOSUPP,
			       "kerberos prf for %s not supported",
			       et->name);
	return KRB5_PROG_ETYPE_NOSUPP;
    }

    return (*et->prf)(context, crypto, input, output);
}

static krb5_error_code
krb5_crypto_prfplus(krb5_context context,
		    const krb5_crypto crypto,
		    const krb5_data *input,
		    size_t length,
		    krb5_data *output)
{
    krb5_error_code ret;
    krb5_data input2;
    unsigned char i = 1;
    unsigned char *p;

    krb5_data_zero(&input2);
    krb5_data_zero(output);

    krb5_clear_error_message(context);

    ret = krb5_data_alloc(output, length);
    if (ret) goto out;
    ret = krb5_data_alloc(&input2, input->length + 1);
    if (ret) goto out;

    krb5_clear_error_message(context);

    memcpy(((unsigned char *)input2.data) + 1, input->data, input->length);

    p = output->data;

    while (length) {
	krb5_data block;

	((unsigned char *)input2.data)[0] = i++;

	ret = krb5_crypto_prf(context, crypto, &input2, &block);
	if (ret)
	    goto out;

	if (block.length < length) {
	    memcpy(p, block.data, block.length);
	    length -= block.length;
	} else {
	    memcpy(p, block.data, length);
	    length = 0;
	}
	p += block.length;
	krb5_data_free(&block);
    }

 out:
    krb5_data_free(&input2);
    if (ret)
	krb5_data_free(output);
    return ret;
}

/**
 * The FX-CF2 key derivation function, used in FAST and preauth framework.
 *
 * @@param context Kerberos 5 context
 * @@param crypto1 first key to combine
 * @@param crypto2 second key to combine
 * @@param pepper1 factor to combine with first key to garante uniqueness
 * @@param pepper2 factor to combine with second key to garante uniqueness
 * @@param enctype the encryption type of the resulting key
 * @@param res allocated key, free with krb5_free_keyblock_contents()
 *
 * @@return Return an error code or 0.
 *
 * @@ingroup krb5_crypto
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_crypto_fx_cf2(krb5_context context,
		   const krb5_crypto crypto1,
		   const krb5_crypto crypto2,
		   krb5_data *pepper1,
		   krb5_data *pepper2,
		   krb5_enctype enctype,
		   krb5_keyblock *res)
{
    krb5_error_code ret;
    krb5_data os1, os2;
    size_t i, keysize;

    memset(res, 0, sizeof(*res));
    krb5_data_zero(&os1);
    krb5_data_zero(&os2);

    ret = krb5_enctype_keysize(context, enctype, &keysize);
    if (ret)
	return ret;

    ret = krb5_data_alloc(&res->keyvalue, keysize);
    if (ret)
	goto out;
    ret = krb5_crypto_prfplus(context, crypto1, pepper1, keysize, &os1);
    if (ret)
	goto out;
    ret = krb5_crypto_prfplus(context, crypto2, pepper2, keysize, &os2);
    if (ret)
	goto out;

    res->keytype = enctype;
    {
	unsigned char *p1 = os1.data, *p2 = os2.data, *p3 = res->keyvalue.data;
	for (i = 0; i < keysize; i++)
	    p3[i] = p1[i] ^ p2[i];
    }
 out:
    if (ret)
	krb5_data_free(&res->keyvalue);
    krb5_data_free(&os1);
    krb5_data_free(&os2);

    return ret;
}



#ifndef HEIMDAL_SMALLER

/**
 * Deprecated: keytypes doesn't exists, they are really enctypes.
 *
 * @@ingroup krb5_deprecated
 */

KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL
krb5_keytype_to_enctypes (krb5_context context,
			  krb5_keytype keytype,
			  unsigned *len,
			  krb5_enctype **val)
    KRB5_DEPRECATED_FUNCTION("Use X instead")
{
    int i;
    unsigned n = 0;
    krb5_enctype *ret;

    for (i = _krb5_num_etypes - 1; i >= 0; --i) {
	if (_krb5_etypes[i]->keytype->type == keytype
	    && !(_krb5_etypes[i]->flags & F_PSEUDO)
	    && krb5_enctype_valid(context, _krb5_etypes[i]->type) == 0)
	    ++n;
    }
    if (n == 0) {
	krb5_set_error_message(context, KRB5_PROG_KEYTYPE_NOSUPP,
			       "Keytype have no mapping");
	return KRB5_PROG_KEYTYPE_NOSUPP;
    }

    ret = malloc(n * sizeof(*ret));
    if (ret == NULL && n != 0) {
	krb5_set_error_message(context, ENOMEM, "malloc: out of memory");
	return ENOMEM;
    }
    n = 0;
    for (i = _krb5_num_etypes - 1; i >= 0; --i) {
	if (_krb5_etypes[i]->keytype->type == keytype
	    && !(_krb5_etypes[i]->flags & F_PSEUDO)
	    && krb5_enctype_valid(context, _krb5_etypes[i]->type) == 0)
	    ret[n++] = _krb5_etypes[i]->type;
    }
    *len = n;
    *val = ret;
    return 0;
}

/**
 * Deprecated: keytypes doesn't exists, they are really enctypes.
 *
 * @@ingroup krb5_deprecated
 */

/* if two enctypes have compatible keys */
KRB5_LIB_FUNCTION krb5_boolean KRB5_LIB_CALL
krb5_enctypes_compatible_keys(krb5_context context,
			      krb5_enctype etype1,
			      krb5_enctype etype2)
    KRB5_DEPRECATED_FUNCTION("Use X instead")
{
    struct _krb5_encryption_type *e1 = _krb5_find_enctype(etype1);
    struct _krb5_encryption_type *e2 = _krb5_find_enctype(etype2);
    return e1 != NULL && e2 != NULL && e1->keytype == e2->keytype;
}

#endif /* HEIMDAL_SMALLER */
@


1.16
log
@Upgrade our KerberosV to Heimdal 1.5.3 (minor update).

- Fix leaking file descriptors in KDC
- Better socket/timeout handling in libkrb5
- General bug fixes

ok robert@@
@
text
@@


1.15
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d2519 1
a2519 1
    return 0;
d2552 2
@


1.14
log
@fix an incorrect memset use of sizeof
found by jsg, "looks right" tedu jsg
@
text
@d2 30
a31 30
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a34 7
RCSID("$KTH: crypto.c,v 1.120.2.1 2005/08/11 07:56:11 lha Exp $");

#undef CRYPTO_DEBUG
#ifdef CRYPTO_DEBUG
static void krb5_crypto_debug(krb5_context, int, size_t, krb5_keyblock*);
#endif

d36 1
a36 6
struct key_data {
    krb5_keyblock *key;
    krb5_data *schedule;
};

struct key_usage {
d38 1
a38 9
    struct key_data key;
};

struct krb5_crypto_data {
    struct encryption_type *et;
    struct key_data key;
    int num_key_usage;
    struct key_usage *key_usage;
    void *params;
a40 1
#define kcrypto_oid_enc(n) { sizeof(n)/sizeof(n[0]), n }
d42 2
a43 28
#define CRYPTO_ETYPE(C) ((C)->et->type)

/* bits for `flags' below */
#define F_KEYED		 1	/* checksum is keyed */
#define F_CPROOF	 2	/* checksum is collision proof */
#define F_DERIVED	 4	/* uses derived keys */
#define F_VARIANT	 8	/* uses `variant' keys (6.4.3) */
#define F_PSEUDO	16	/* not a real protocol type */
#define F_SPECIAL	32	/* backwards */
#define F_DISABLED	64	/* enctype/checksum disabled */
#define F_PADCMS	128	/* padding done like in CMS */

struct salt_type {
    krb5_salttype type;
    const char *name;
    krb5_error_code (*string_to_key)(krb5_context, krb5_enctype, krb5_data, 
				     krb5_salt, krb5_data, krb5_keyblock*);
};

struct key_type {
    krb5_keytype type; /* XXX */
    const char *name;
    size_t bits;
    size_t size;
    size_t minsize;
    size_t schedule_size;
#if 0
    krb5_enctype best_etype;
a44 9
    void (*random_key)(krb5_context, krb5_keyblock*);
    void (*schedule)(krb5_context, struct key_data *, const void *);
    struct salt_type *string_to_key;
    void (*random_to_key)(krb5_context, krb5_keyblock*, const void*, size_t);
    krb5_error_code (*get_params)(krb5_context, const krb5_data *,
				  void **, krb5_data *);
    krb5_error_code (*set_params)(krb5_context, const void *,
				  const krb5_data *, krb5_data *);
};
d46 3
a48 17
struct checksum_type {
    krb5_cksumtype type;
    const char *name;
    size_t blocksize;
    size_t checksumsize;
    unsigned flags;
    void (*checksum)(krb5_context context,
		     struct key_data *key,
		     const void *buf, size_t len,
		     unsigned usage,
		     Checksum *csum);
    krb5_error_code (*verify)(krb5_context context,
			      struct key_data *key,
			      const void *buf, size_t len,
			      unsigned usage,
			      Checksum *csum);
};
d50 3
a52 18
struct encryption_type {
    krb5_enctype type;
    const char *name;
    heim_oid *oid;
    size_t blocksize;
    size_t padsize;
    size_t confoundersize;
    struct key_type *keytype;
    struct checksum_type *checksum;
    struct checksum_type *keyed_checksum;
    unsigned flags;
    krb5_error_code (*encrypt)(krb5_context context,
			       struct key_data *key,
			       void *data, size_t len,
			       krb5_boolean encrypt,
			       int usage,
			       void *ivec);
};
d54 6
a59 84
#define ENCRYPTION_USAGE(U) (((U) << 8) | 0xAA)
#define INTEGRITY_USAGE(U) (((U) << 8) | 0x55)
#define CHECKSUM_USAGE(U) (((U) << 8) | 0x99)

static struct checksum_type *_find_checksum(krb5_cksumtype type);
static struct encryption_type *_find_enctype(krb5_enctype type);
static struct key_type *_find_keytype(krb5_keytype type);
static krb5_error_code _get_derived_key(krb5_context, krb5_crypto, 
					unsigned, struct key_data**);
static struct key_data *_new_derived_key(krb5_crypto crypto, unsigned usage);
static krb5_error_code derive_key(krb5_context context,
				  struct encryption_type *et,
				  struct key_data *key,
				  const void *constant,
				  size_t len);
static krb5_error_code hmac(krb5_context context,
			    struct checksum_type *cm, 
			    const void *data, 
			    size_t len, 
			    unsigned usage,
			    struct key_data *keyblock,
			    Checksum *result);
static void free_key_data(krb5_context context, struct key_data *key);
static krb5_error_code usage2arcfour (krb5_context, unsigned *);
static void xor (DES_cblock *, const unsigned char *);

/************************************************************
 *                                                          *
 ************************************************************/

static HEIMDAL_MUTEX crypto_mutex = HEIMDAL_MUTEX_INITIALIZER;


static void
krb5_DES_random_key(krb5_context context,
	       krb5_keyblock *key)
{
    DES_cblock *k = key->keyvalue.data;
    do {
	krb5_generate_random_block(k, sizeof(DES_cblock));
	DES_set_odd_parity(k);
    } while(DES_is_weak_key(k));
}

static void
krb5_DES_schedule(krb5_context context,
		  struct key_data *key,
		  const void *params)
{
    DES_set_key(key->key->keyvalue.data, key->schedule->data);
}

static void
DES_string_to_key_int(unsigned char *data, size_t length, DES_cblock *key)
{
    DES_key_schedule schedule;
    int i;
    int reverse = 0;
    unsigned char *p;

    unsigned char swap[] = { 0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe, 
			     0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf };
    memset(key, 0, 8);
    
    p = (unsigned char*)key;
    for (i = 0; i < length; i++) {
	unsigned char tmp = data[i];
	if (!reverse)
	    *p++ ^= (tmp << 1);
	else
	    *--p ^= (swap[tmp & 0xf] << 4) | swap[(tmp & 0xf0) >> 4];
	if((i % 8) == 7)
	    reverse = !reverse;
    }
    DES_set_odd_parity(key);
    if(DES_is_weak_key(key))
	(*key)[7] ^= 0xF0;
    DES_set_key(key, &schedule);
    DES_cbc_cksum((void*)data, key, length, &schedule, key);
    memset(&schedule, 0, sizeof(schedule));
    DES_set_odd_parity(key);
    if(DES_is_weak_key(key))
	(*key)[7] ^= 0xF0;
}
d62 1
a62 6
krb5_DES_string_to_key(krb5_context context,
		  krb5_enctype enctype,
		  krb5_data password,
		  krb5_salt salt,
		  krb5_data opaque,
		  krb5_keyblock *key)
d64 2
a65 3
    unsigned char *s;
    size_t len;
    DES_cblock tmp;
d67 3
a69 16
    len = password.length + salt.saltvalue.length;
    s = malloc(len);
    if(len > 0 && s == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
    }
    memcpy(s, password.data, password.length);
    memcpy(s + password.length, salt.saltvalue.data, salt.saltvalue.length);
    DES_string_to_key_int(s, len, &tmp);
    key->keytype = enctype;
    krb5_data_copy(&key->keyvalue, tmp, sizeof(tmp));
    memset(&tmp, 0, sizeof(tmp));
    memset(s, 0, len);
    free(s);
    return 0;
}
d71 5
a75 107
/* This defines the Andrew string_to_key function.  It accepts a password
 * string as input and converts its via a one-way encryption algorithm to a DES
 * encryption key.  It is compatible with the original Andrew authentication
 * service password database.
 */

/*
 * Short passwords, i.e 8 characters or less.
 */
static void
krb5_DES_AFS3_CMU_string_to_key (krb5_data pw,
			    krb5_data cell,
			    DES_cblock *key)
{
    char  password[8+1];	/* crypt is limited to 8 chars anyway */
    int   i;
    
    for(i = 0; i < 8; i++) {
	char c = ((i < pw.length) ? ((char*)pw.data)[i] : 0) ^
		 ((i < cell.length) ?
		  tolower(((unsigned char*)cell.data)[i]) : 0);
	password[i] = c ? c : 'X';
    }
    password[8] = '\0';

    memcpy(key, crypt(password, "p1") + 2, sizeof(DES_cblock));

    /* parity is inserted into the LSB so left shift each byte up one
       bit. This allows ascii characters with a zero MSB to retain as
       much significance as possible. */
    for (i = 0; i < sizeof(DES_cblock); i++)
	((unsigned char*)key)[i] <<= 1;
    DES_set_odd_parity (key);
}

/*
 * Long passwords, i.e 9 characters or more.
 */
static void
krb5_DES_AFS3_Transarc_string_to_key (krb5_data pw,
				 krb5_data cell,
				 DES_cblock *key)
{
    DES_key_schedule schedule;
    DES_cblock temp_key;
    DES_cblock ivec;
    char password[512];
    size_t passlen;

    memcpy(password, pw.data, min(pw.length, sizeof(password)));
    if(pw.length < sizeof(password)) {
	int len = min(cell.length, sizeof(password) - pw.length);
	int i;

	memcpy(password + pw.length, cell.data, len);
	for (i = pw.length; i < pw.length + len; ++i)
	    password[i] = tolower((unsigned char)password[i]);
    }
    passlen = min(sizeof(password), pw.length + cell.length);
    memcpy(&ivec, "kerberos", 8);
    memcpy(&temp_key, "kerberos", 8);
    DES_set_odd_parity (&temp_key);
    DES_set_key (&temp_key, &schedule);
    DES_cbc_cksum ((void*)password, &ivec, passlen, &schedule, &ivec);

    memcpy(&temp_key, &ivec, 8);
    DES_set_odd_parity (&temp_key);
    DES_set_key (&temp_key, &schedule);
    DES_cbc_cksum ((void*)password, key, passlen, &schedule, &ivec);
    memset(&schedule, 0, sizeof(schedule));
    memset(&temp_key, 0, sizeof(temp_key));
    memset(&ivec, 0, sizeof(ivec));
    memset(password, 0, sizeof(password));

    DES_set_odd_parity (key);
}

static krb5_error_code
DES_AFS3_string_to_key(krb5_context context,
		       krb5_enctype enctype,
		       krb5_data password,
		       krb5_salt salt,
		       krb5_data opaque,
		       krb5_keyblock *key)
{
    DES_cblock tmp;
    if(password.length > 8)
	krb5_DES_AFS3_Transarc_string_to_key(password, salt.saltvalue, &tmp);
    else
	krb5_DES_AFS3_CMU_string_to_key(password, salt.saltvalue, &tmp);
    key->keytype = enctype;
    krb5_data_copy(&key->keyvalue, tmp, sizeof(tmp));
    memset(&key, 0, sizeof(key));
    return 0;
}

static void
krb5_DES_random_to_key(krb5_context context,
		       krb5_keyblock *key,
		       const void *data,
		       size_t size)
{
    DES_cblock *k = key->keyvalue.data;
    memcpy(k, data, key->keyvalue.length);
    DES_set_odd_parity(k);
    if(DES_is_weak_key(k))
	xor(k, (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
d82 4
a85 3
static void
DES3_random_key(krb5_context context,
		krb5_keyblock *key)
d87 6
a92 9
    DES_cblock *k = key->keyvalue.data;
    do {
	krb5_generate_random_block(k, 3 * sizeof(DES_cblock));
	DES_set_odd_parity(&k[0]);
	DES_set_odd_parity(&k[1]);
	DES_set_odd_parity(&k[2]);
    } while(DES_is_weak_key(&k[0]) ||
	    DES_is_weak_key(&k[1]) ||
	    DES_is_weak_key(&k[2]));
d95 4
a98 18
static void
DES3_schedule(krb5_context context,
	      struct key_data *key,
	      const void *params)
{
    DES_cblock *k = key->key->keyvalue.data;
    DES_key_schedule *s = key->schedule->data;
    DES_set_key(&k[0], &s[0]);
    DES_set_key(&k[1], &s[1]);
    DES_set_key(&k[2], &s[2]);
}

/*
 * A = A xor B. A & B are 8 bytes.
 */

static void
xor (DES_cblock *key, const unsigned char *b)
d100 6
a105 9
    unsigned char *a = (unsigned char*)key;
    a[0] ^= b[0];
    a[1] ^= b[1];
    a[2] ^= b[2];
    a[3] ^= b[3];
    a[4] ^= b[4];
    a[5] ^= b[5];
    a[6] ^= b[6];
    a[7] ^= b[7];
d108 4
a111 7
static krb5_error_code
DES3_string_to_key(krb5_context context,
		   krb5_enctype enctype,
		   krb5_data password,
		   krb5_salt salt,
		   krb5_data opaque,
		   krb5_keyblock *key)
d113 4
a116 10
    char *str;
    size_t len;
    unsigned char tmp[24];
    DES_cblock keys[3];
    
    len = password.length + salt.saltvalue.length;
    str = malloc(len);
    if(len != 0 && str == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
d118 9
a126 35
    memcpy(str, password.data, password.length);
    memcpy(str + password.length, salt.saltvalue.data, salt.saltvalue.length);
    {
	DES_cblock ivec;
	DES_key_schedule s[3];
	int i;
	
	_krb5_n_fold(str, len, tmp, 24);
	
	for(i = 0; i < 3; i++){
	    memcpy(keys + i, tmp + i * 8, sizeof(keys[i]));
	    DES_set_odd_parity(keys + i);
	    if(DES_is_weak_key(keys + i))
		xor(keys + i, (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
	    DES_set_key(keys + i, &s[i]);
	}
	memset(&ivec, 0, sizeof(ivec));
	DES_ede3_cbc_encrypt(tmp,
			     tmp, sizeof(tmp), 
			     &s[0], &s[1], &s[2], &ivec, DES_ENCRYPT);
	memset(s, 0, sizeof(s));
	memset(&ivec, 0, sizeof(ivec));
	for(i = 0; i < 3; i++){
	    memcpy(keys + i, tmp + i * 8, sizeof(keys[i]));
	    DES_set_odd_parity(keys + i);
	    if(DES_is_weak_key(keys + i))
		xor(keys + i, (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
	}
	memset(tmp, 0, sizeof(tmp));
    }
    key->keytype = enctype;
    krb5_data_copy(&key->keyvalue, keys, sizeof(keys));
    memset(keys, 0, sizeof(keys));
    memset(str, 0, len);
    free(str);
d131 2
a132 6
DES3_string_to_key_derived(krb5_context context,
			   krb5_enctype enctype,
			   krb5_data password,
			   krb5_salt salt,
			   krb5_data opaque,
			   krb5_keyblock *key)
d135 2
a136 2
    size_t len = password.length + salt.saltvalue.length;
    char *s;
d138 3
a140 4
    s = malloc(len);
    if(len != 0 && s == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
a141 11
    memcpy(s, password.data, password.length);
    memcpy(s + password.length, salt.saltvalue.data, salt.saltvalue.length);
    ret = krb5_string_to_key_derived(context,
				     s,
				     len,
				     enctype,
				     key);
    memset(s, 0, len);
    free(s);
    return ret;
}
d143 1
a143 16
static void
DES3_random_to_key(krb5_context context,
		   krb5_keyblock *key,
		   const void *data,
		   size_t size)
{
    unsigned char *x = key->keyvalue.data;
    const u_char *q = data;
    DES_cblock *k;
    int i, j;

    memset(key->keyvalue.data, 0, key->keyvalue.length);
    for (i = 0; i < 3; ++i) {
	unsigned char foo;
	for (j = 0; j < 7; ++j) {
	    unsigned char b = q[7 * i + j];
d145 14
a158 8
	    x[8 * i + j] = b;
	}
	foo = 0;
	for (j = 6; j >= 0; --j) {
	    foo |= q[7 * i + j] & 1;
	    foo <<= 1;
	}
	x[8 * i + 7] = foo;
d160 2
a161 6
    k = key->keyvalue.data;
    for (i = 0; i < 3; i++) {
	DES_set_odd_parity(&k[i]);
	if(DES_is_weak_key(&k[i]))
	    xor(&k[i], (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
    }    
d164 3
a166 3
/*
 * ARCFOUR
 */
d168 7
a174 4
static void
ARCFOUR_schedule(krb5_context context, 
		 struct key_data *kd,
		 const void *params)
d176 3
a178 2
    RC4_set_key (kd->schedule->data,
		 kd->key->keyvalue.length, kd->key->keyvalue.data);
d181 9
a189 7
static krb5_error_code
ARCFOUR_string_to_key(krb5_context context,
		  krb5_enctype enctype,
		  krb5_data password,
		  krb5_salt salt,
		  krb5_data opaque,
		  krb5_keyblock *key)
d191 4
a194 4
    char *s, *p;
    size_t len;
    int i;
    MD4_CTX m;
d196 2
a197 4
    len = 2 * password.length;
    s = malloc (len);
    if (len != 0 && s == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d199 3
a201 68
    }
    for (p = s, i = 0; i < password.length; ++i) {
	*p++ = ((char *)password.data)[i];
	*p++ = 0;
    }
    MD4_Init (&m);
    MD4_Update (&m, s, len);
    key->keytype = enctype;
    krb5_data_alloc (&key->keyvalue, 16);
    MD4_Final (key->keyvalue.data, &m);
    memset (s, 0, len);
    free (s);
    return 0;
}

/*
 * AES
 */

/* iter is really 1 based, so iter == 0 will be 1 iteration */

krb5_error_code KRB5_LIB_FUNCTION
_krb5_PKCS5_PBKDF2(krb5_context context, krb5_cksumtype cktype,
		   krb5_data password, krb5_salt salt, u_int32_t iter,
		   krb5_keytype type, krb5_keyblock *key)
{
    struct checksum_type *c = _find_checksum(cktype);
    struct key_type *kt;
    size_t datalen, leftofkey;
    krb5_error_code ret;
    u_int32_t keypart;
    struct key_data ksign;
    krb5_keyblock kb;
    Checksum result;
    char *data, *tmpcksum;
    int i, j;
    char *p;
    
    if (c == NULL) {
	krb5_set_error_string(context, "checksum %d not supported", cktype);
	return KRB5_PROG_KEYTYPE_NOSUPP;
    }

    kt = _find_keytype(type);
    if (kt == NULL) {
	krb5_set_error_string(context, "key type %d not supported", type);
	return KRB5_PROG_KEYTYPE_NOSUPP;
    }
    
    key->keytype = type;
    ret = krb5_data_alloc (&key->keyvalue, kt->bits / 8);
    if (ret) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ret;
    }
	
    ret = krb5_data_alloc (&result.checksum, c->checksumsize);
    if (ret) {
	krb5_set_error_string(context, "malloc: out of memory");
	krb5_data_free (&key->keyvalue);
	return ret;
    }

    tmpcksum = malloc(c->checksumsize);
    if (tmpcksum == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	krb5_data_free (&key->keyvalue);
	krb5_data_free (&result.checksum);
d204 2
d207 12
a218 8
    datalen = salt.saltvalue.length + 4;
    data = malloc(datalen);
    if (data == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	free(tmpcksum);
	krb5_data_free (&key->keyvalue);
	krb5_data_free (&result.checksum);
	return ENOMEM;
d220 3
a222 38

    kb.keyvalue = password;
    ksign.key = &kb;

    memcpy(data, salt.saltvalue.data, salt.saltvalue.length);

    keypart = 1;
    leftofkey = key->keyvalue.length;
    p = key->keyvalue.data;

    while (leftofkey) {
	int len;

	if (leftofkey > c->checksumsize)
	    len = c->checksumsize;
	else
	    len = leftofkey;

	_krb5_put_int(data + datalen - 4, keypart, 4);

	ret = hmac(context, c, data, datalen, 0, &ksign, &result);
	if (ret)
	    krb5_abortx(context, "hmac failed");
	memcpy(p, result.checksum.data, len);
	memcpy(tmpcksum, result.checksum.data, result.checksum.length);
	for (i = 0; i < iter; i++) {
	    ret = hmac(context, c, tmpcksum, result.checksum.length,
		       0, &ksign, &result);
	    if (ret)
		krb5_abortx(context, "hmac failed");
	    memcpy(tmpcksum, result.checksum.data, result.checksum.length);
	    for (j = 0; j < len; j++)
		p[j] ^= tmpcksum[j];
	}

	p += len;
	leftofkey -= len;
	keypart++;
d224 11
a234 4

    free(data);
    free(tmpcksum);
    krb5_data_free (&result.checksum);
d239 8
a246 9
int _krb5_AES_string_to_default_iterator = 4096;

static krb5_error_code
AES_string_to_key(krb5_context context,
		  krb5_enctype enctype,
		  krb5_data password,
		  krb5_salt salt,
		  krb5_data opaque,
		  krb5_keyblock *key)
d248 2
a250 13
    u_int32_t iter;
    struct encryption_type *et;
    struct key_data kd;

    if (opaque.length == 0)
	iter = _krb5_AES_string_to_default_iterator - 1;
    else if (opaque.length == 4) {
	unsigned long v;
	_krb5_get_int(opaque.data, &v, 4);
	iter = ((u_int32_t)v) - 1;
    } else
	return KRB5_PROG_KEYTYPE_NOSUPP; /* XXX */
	
d252 6
a257 3
    et = _find_enctype(enctype);
    if (et == NULL)
	return KRB5_PROG_KEYTYPE_NOSUPP;
d259 2
a260 4
    ret = _krb5_PKCS5_PBKDF2(context, CKSUMTYPE_SHA1, password, salt, 
			     iter, enctype, key);
    if (ret)
	return ret;
d262 1
a262 2
    ret = krb5_copy_keyblock(context, key, &kd.key);
    kd.schedule = NULL;
d264 2
a265 6
    ret = derive_key(context, et, &kd, "kerberos", strlen("kerberos"));
    krb5_free_keyblock_contents(context, key);
    if (ret == 0) {
	ret = krb5_copy_keyblock_contents(context, kd.key, key);
	free_key_data(context, &kd);
    }
d270 15
a284 4
struct krb5_aes_schedule {
    AES_KEY ekey;
    AES_KEY dkey;
};
d286 5
a290 11
static void
AES_schedule(krb5_context context,
	     struct key_data *kd,
	     const void *params)
{
    struct krb5_aes_schedule *key = kd->schedule->data;
    int bits = kd->key->keyvalue.length * 8;

    memset(key, 0, sizeof(*key));
    AES_set_encrypt_key(kd->key->keyvalue.data, bits, &key->ekey);
    AES_set_decrypt_key(kd->key->keyvalue.data, bits, &key->dkey);
d293 9
a301 3
/*
 * RC2
 */
d303 9
a311 3
struct _RC2_params {
    int maximum_effective_key;
};
d314 5
a318 4
rc2_get_params(krb5_context context,
	       const krb5_data *data,
	       void **params,
	       krb5_data *ivec)
d320 6
a325 4
    RC2CBCParameter rc2params;
    struct _RC2_params *p;
    krb5_error_code ret;
    size_t size;
d327 12
a338 4
    ret = decode_RC2CBCParameter(data->data, data->length, &rc2params, &size);
    if (ret) {
	krb5_set_error_string(context, "Can't decode RC2 parameters");
	return ret;
d340 2
a341 24
    p = malloc(sizeof(*p));
    if (p == NULL) {
	free_RC2CBCParameter(&rc2params);
	krb5_set_error_string(context, "malloc - out of memory");
	return ENOMEM;
    }
    /* XXX  */
    switch(rc2params.rc2ParameterVersion) {
    case 160:
	p->maximum_effective_key = 40;
	break;
    case 120:
	p->maximum_effective_key = 64;
	break;
    case 58:
	p->maximum_effective_key = 128;
	break;
	
    }
    if (ivec)
	ret = copy_octet_string(&rc2params.iv, ivec);
    free_RC2CBCParameter(&rc2params);
    *params = p;

d346 8
a353 8
rc2_set_params(krb5_context context,
	       const void *params,
	       const krb5_data *ivec,
	       krb5_data *data)
{
    RC2CBCParameter rc2params;
    const struct _RC2_params *p = params;
    int maximum_effective_key = 128;
d355 2
a356 1
    size_t size;
d358 11
a368 16
    memset(&rc2params, 0, sizeof(rc2params));

    if (p)
	maximum_effective_key = p->maximum_effective_key;

    /* XXX */
    switch(maximum_effective_key) {
    case 40:
	rc2params.rc2ParameterVersion = 160;
	break;
    case 64:
	rc2params.rc2ParameterVersion = 120;
	break;
    case 128:
	rc2params.rc2ParameterVersion = 58;
	break;
d370 8
a377 1
    ret = copy_octet_string(ivec, &rc2params.iv);
d379 2
a380 9
	return ret;

    ASN1_MALLOC_ENCODE(RC2CBCParameter, data->data, data->length,
		       &rc2params, &size, ret);
    if (ret == 0 && size != data->length)
	krb5_abortx(context, "Internal asn1 encoder failure");
    free_RC2CBCParameter(&rc2params);

    return ret;
d383 5
a387 13
static void
rc2_schedule(krb5_context context,
	     struct key_data *kd,
	     const void *params)
{
    const struct _RC2_params *p = params;
    int maximum_effective_key = 128;
    if (p)
	maximum_effective_key = p->maximum_effective_key;
    RC2_set_key (kd->schedule->data,
		 kd->key->keyvalue.length,
		 kd->key->keyvalue.data,
		 maximum_effective_key);
d390 11
d402 8
a409 3
/*
 *
 */
d411 6
a416 13
static struct salt_type des_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	krb5_DES_string_to_key
    },
    {
	KRB5_AFS3_SALT,
	"afs3-salt",
	DES_AFS3_string_to_key
    },
    { 0 }
};
d418 5
a422 8
static struct salt_type des3_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	DES3_string_to_key
    },
    { 0 }
};
d424 3
a426 8
static struct salt_type des3_salt_derived[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	DES3_string_to_key_derived
    },
    { 0 }
};
d428 13
a440 8
static struct salt_type AES_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	AES_string_to_key
    },
    { 0 }
};
d442 14
a455 8
static struct salt_type arcfour_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	ARCFOUR_string_to_key
    },
    { 0 }
};
d457 21
a477 3
/*
 *
 */
d479 5
a483 11
static struct key_type keytype_null = {
    KEYTYPE_NULL,
    "null",
    0,
    0,
    0,
    0,
    NULL,
    NULL,
    NULL
};
d485 4
a488 12
static struct key_type keytype_des = {
    KEYTYPE_DES,
    "des",
    56,
    sizeof(DES_cblock),
    sizeof(DES_cblock),
    sizeof(DES_key_schedule),
    krb5_DES_random_key,
    krb5_DES_schedule,
    des_salt,
    krb5_DES_random_to_key
};
d490 9
a498 12
static struct key_type keytype_des3 = {
    KEYTYPE_DES3,
    "des3",
    168,
    3 * sizeof(DES_cblock), 
    3 * sizeof(DES_cblock), 
    3 * sizeof(DES_key_schedule), 
    DES3_random_key,
    DES3_schedule,
    des3_salt,
    DES3_random_to_key
};
d500 3
a502 12
static struct key_type keytype_des3_derived = {
    KEYTYPE_DES3,
    "des3",
    168,
    3 * sizeof(DES_cblock),
    3 * sizeof(DES_cblock),
    3 * sizeof(DES_key_schedule), 
    DES3_random_key,
    DES3_schedule,
    des3_salt_derived,
    DES3_random_to_key
};
d504 5
a508 11
static struct key_type keytype_aes128 = {
    KEYTYPE_AES128,
    "aes-128",
    128,
    16,
    16,
    sizeof(struct krb5_aes_schedule),
    NULL,
    AES_schedule,
    AES_salt
};
d510 12
a521 11
static struct key_type keytype_aes192 = {
    KEYTYPE_AES192,
    "aes-192",
    192,
    24,
    24,
    sizeof(struct krb5_aes_schedule),
    NULL,
    AES_schedule,
    AES_salt
};
d523 10
a532 11
static struct key_type keytype_aes256 = {
    KEYTYPE_AES256,
    "aes-256",
    256,
    32,
    32,
    sizeof(struct krb5_aes_schedule),
    NULL,
    AES_schedule,
    AES_salt
};
d534 7
a540 11
static struct key_type keytype_arcfour = {
    KEYTYPE_ARCFOUR,
    "arcfour",
    128,
    16,
    16,
    sizeof(RC4_KEY),
    NULL,
    ARCFOUR_schedule,
    arcfour_salt
};
d542 5
a546 14
static struct key_type keytype_rc2 = {
    KEYTYPE_RC2,
    "rc2",
    128,
    16,
    1,
    sizeof(RC2_KEY),
    NULL,
    rc2_schedule,
    NULL, /* XXX salt */
    NULL,
    rc2_get_params,
    rc2_set_params
};
d548 3
a550 11
static struct key_type *keytypes[] = {
    &keytype_null,
    &keytype_des,
    &keytype_des3_derived,
    &keytype_des3,
    &keytype_aes128,
    &keytype_aes192,
    &keytype_aes256,
    &keytype_rc2,
    &keytype_arcfour
};
d552 4
a555 4
static int num_keytypes = sizeof(keytypes) / sizeof(keytypes[0]);

static struct key_type *
_find_keytype(krb5_keytype type)
d557 1
a557 6
    int i;
    for(i = 0; i < num_keytypes; i++)
	if(keytypes[i]->type == type)
	    return keytypes[i];
    return NULL;
}
d559 5
d565 4
a568 14
krb5_error_code KRB5_LIB_FUNCTION
krb5_salttype_to_string (krb5_context context,
			 krb5_enctype etype,
			 krb5_salttype stype,
			 char **string)
{
    struct encryption_type *e;
    struct salt_type *st;

    e = _find_enctype (etype);
    if (e == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      etype);
	return KRB5_PROG_ETYPE_NOSUPP;
d570 4
a573 12
    for (st = e->keytype->string_to_key; st && st->type; st++) {
	if (st->type == stype) {
	    *string = strdup (st->name);
	    if (*string == NULL) {
		krb5_set_error_string(context, "malloc: out of memory");
		return ENOMEM;
	    }
	    return 0;
	}
    }
    krb5_set_error_string(context, "salttype %d not supported", stype);
    return HEIM_ERR_SALTTYPE_NOSUPP;
a575 24
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_salttype (krb5_context context,
			 krb5_enctype etype,
			 const char *string,
			 krb5_salttype *salttype)
{
    struct encryption_type *e;
    struct salt_type *st;

    e = _find_enctype (etype);
    if (e == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      etype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    for (st = e->keytype->string_to_key; st && st->type; st++) {
	if (strcasecmp (st->name, string) == 0) {
	    *salttype = st->type;
	    return 0;
	}
    }
    krb5_set_error_string(context, "salttype %s not supported", string);
    return HEIM_ERR_SALTTYPE_NOSUPP;
}
d577 4
a580 4
krb5_error_code KRB5_LIB_FUNCTION
krb5_get_pw_salt(krb5_context context,
		 krb5_const_principal principal,
		 krb5_salt *salt)
d582 6
a587 20
    size_t len;
    int i;
    krb5_error_code ret;
    char *p;
     
    salt->salttype = KRB5_PW_SALT;
    len = strlen(principal->realm);
    for (i = 0; i < principal->name.name_string.len; ++i)
	len += strlen(principal->name.name_string.val[i]);
    ret = krb5_data_alloc (&salt->saltvalue, len);
    if (ret)
	return ret;
    p = salt->saltvalue.data;
    memcpy (p, principal->realm, strlen(principal->realm));
    p += strlen(principal->realm);
    for (i = 0; i < principal->name.name_string.len; ++i) {
	memcpy (p,
		principal->name.name_string.val[i],
		strlen(principal->name.name_string.val[i]));
	p += strlen(principal->name.name_string.val[i]);
d589 1
d593 3
a595 3
krb5_error_code KRB5_LIB_FUNCTION
krb5_free_salt(krb5_context context, 
	       krb5_salt salt)
d597 9
a605 2
    krb5_data_free(&salt.saltvalue);
    return 0;
d608 3
a610 6
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_data (krb5_context context,
			 krb5_enctype enctype,
			 krb5_data password,
			 krb5_principal principal,
			 krb5_keyblock *key)
d612 9
a620 9
    krb5_error_code ret;
    krb5_salt salt;

    ret = krb5_get_pw_salt(context, principal, &salt);
    if(ret)
	return ret;
    ret = krb5_string_to_key_data_salt(context, enctype, password, salt, key);
    krb5_free_salt(context, salt);
    return ret;
d623 3
a625 19
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key (krb5_context context,
		    krb5_enctype enctype,
		    const char *password,
		    krb5_principal principal,
		    krb5_keyblock *key)
{
    krb5_data pw;
    pw.data = (void*)password;
    pw.length = strlen(password);
    return krb5_string_to_key_data(context, enctype, pw, principal, key);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_data_salt (krb5_context context,
			      krb5_enctype enctype,
			      krb5_data password,
			      krb5_salt salt,
			      krb5_keyblock *key)
d627 10
a636 4
    krb5_data opaque;
    krb5_data_zero(&opaque);
    return krb5_string_to_key_data_salt_opaque(context, enctype, password, 
					       salt, opaque, key);
d639 3
a641 5
/*
 * Do a string -> key for encryption type `enctype' operation on
 * `password' (with salt `salt' and the enctype specific data string
 * `opaque'), returning the resulting key in `key'
 */
d643 2
a644 7
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_data_salt_opaque (krb5_context context,
				     krb5_enctype enctype,
				     krb5_data password,
				     krb5_salt salt,
				     krb5_data opaque,
				     krb5_keyblock *key)
d646 5
a650 14
    struct encryption_type *et =_find_enctype(enctype);
    struct salt_type *st;
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      enctype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    for(st = et->keytype->string_to_key; st && st->type; st++) 
	if(st->type == salt.salttype)
	    return (*st->string_to_key)(context, enctype, password, 
					salt, opaque, key);
    krb5_set_error_string(context, "salt type %d not supported",
			  salt.salttype);
    return HEIM_ERR_SALTTYPE_NOSUPP;
a652 5
/*
 * Do a string -> key for encryption type `enctype' operation on the
 * string `password' (with salt `salt'), returning the resulting key
 * in `key'
 */
d654 3
a656 31
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_salt (krb5_context context,
			 krb5_enctype enctype,
			 const char *password,
			 krb5_salt salt,
			 krb5_keyblock *key)
{
    krb5_data pw;
    pw.data = (void*)password;
    pw.length = strlen(password);
    return krb5_string_to_key_data_salt(context, enctype, pw, salt, key);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_salt_opaque (krb5_context context,
				krb5_enctype enctype,
				const char *password,
				krb5_salt salt,
				krb5_data opaque,
				krb5_keyblock *key)
{
    krb5_data pw;
    pw.data = (void*)password;
    pw.length = strlen(password);
    return krb5_string_to_key_data_salt_opaque(context, enctype, 
					       pw, salt, opaque, key);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_keytype_to_string(krb5_context context,
		       krb5_keytype keytype,
d659 8
a666 4
    struct key_type *kt = _find_keytype(keytype);
    if(kt == NULL) {
	krb5_set_error_string(context, "key type %d not supported", keytype);
	return KRB5_PROG_KEYTYPE_NOSUPP;
d668 1
a668 1
    *string = strdup(kt->name);
d670 1
a670 1
	krb5_set_error_string(context, "malloc: out of memory");
d676 2
a677 2
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_keytype(krb5_context context,
d679 1
a679 1
		       krb5_keytype *keytype)
d682 3
a684 3
    for(i = 0; i < num_keytypes; i++)
	if(strcasecmp(keytypes[i]->name, string) == 0){
	    *keytype = keytypes[i]->type;
d687 4
a690 2
    krb5_set_error_string(context, "key type %s not supported", string);
    return KRB5_PROG_KEYTYPE_NOSUPP;
d693 4
a696 4
krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_keysize(krb5_context context,
		     krb5_enctype type,
		     size_t *keysize)
d698 3
a700 5
    struct encryption_type *et = _find_enctype(type);
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      type);
	return KRB5_PROG_ETYPE_NOSUPP;
d702 1
a702 1
    *keysize = et->keytype->size;
d706 13
a718 4
krb5_error_code KRB5_LIB_FUNCTION
krb5_generate_random_keyblock(krb5_context context,
			      krb5_enctype type,
			      krb5_keyblock *key)
d720 4
a723 5
    krb5_error_code ret;
    struct encryption_type *et = _find_enctype(type);
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      type);
d725 2
d728 5
a732 10
    ret = krb5_data_alloc(&key->keyvalue, et->keytype->size);
    if(ret) 
	return ret;
    key->keytype = type;
    if(et->keytype->random_key)
	(*et->keytype->random_key)(context, key);
    else
	krb5_generate_random_block(key->keyvalue.data, 
				   key->keyvalue.length);
    return 0;
d735 17
a751 4
static krb5_error_code
_key_schedule(krb5_context context,
	      struct key_data *key,
	      const void *params)
d753 19
a771 3
    krb5_error_code ret;
    struct encryption_type *et = _find_enctype(key->key->keytype);
    struct key_type *kt = et->keytype;
d773 10
a782 8
    if(kt->schedule == NULL)
	return 0;
    if (key->schedule != NULL)
	return 0;
    ALLOC(key->schedule, 1);
    if(key->schedule == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
d784 5
a788 5
    ret = krb5_data_alloc(key->schedule, kt->schedule_size);
    if(ret) {
	free(key->schedule);
	key->schedule = NULL;
	return ret;
a789 1
    (*kt->schedule)(context, key, params);
a792 3
/************************************************************
 *                                                          *
 ************************************************************/
d794 3
a796 7
static void
NONE_checksum(krb5_context context,
	      struct key_data *key,
	      const void *data,
	      size_t len,
	      unsigned usage,
	      Checksum *C)
d798 1
d801 5
a805 16
static void
CRC32_checksum(krb5_context context,
	       struct key_data *key,
	       const void *data,
	       size_t len,
	       unsigned usage,
	       Checksum *C)
{
    u_int32_t crc;
    unsigned char *r = C->checksum.data;
    _krb5_crc_init_table ();
    crc = _krb5_crc_update (data, len, 0);
    r[0] = crc & 0xff;
    r[1] = (crc >> 8)  & 0xff;
    r[2] = (crc >> 16) & 0xff;
    r[3] = (crc >> 24) & 0xff;
d808 11
a818 7
static void
RSA_MD4_checksum(krb5_context context,
		 struct key_data *key,
		 const void *data,
		 size_t len,
		 unsigned usage,
		 Checksum *C)
d820 6
a825 1
    MD4_CTX m;
d827 1
a827 4
    MD4_Init (&m);
    MD4_Update (&m, data, len);
    MD4_Final (C->checksum.data, &m);
}
d829 8
a836 25
static void
RSA_MD4_DES_checksum(krb5_context context, 
		     struct key_data *key,
		     const void *data, 
		     size_t len, 
		     unsigned usage,
		     Checksum *cksum)
{
    MD4_CTX md4;
    DES_cblock ivec;
    unsigned char *p = cksum->checksum.data;
    
    krb5_generate_random_block(p, 8);
    MD4_Init (&md4);
    MD4_Update (&md4, p, 8);
    MD4_Update (&md4, data, len);
    MD4_Final (p + 8, &md4);
    memset (&ivec, 0, sizeof(ivec));
    DES_cbc_encrypt(p, 
		    p, 
		    24, 
		    key->schedule->data, 
		    &ivec, 
		    DES_ENCRYPT);
}
d838 4
a841 13
static krb5_error_code
RSA_MD4_DES_verify(krb5_context context,
		   struct key_data *key,
		   const void *data,
		   size_t len,
		   unsigned usage,
		   Checksum *C)
{
    MD4_CTX md4;
    unsigned char tmp[24];
    unsigned char res[16];
    DES_cblock ivec;
    krb5_error_code ret = 0;
d843 11
a853 14
    memset(&ivec, 0, sizeof(ivec));
    DES_cbc_encrypt(C->checksum.data,
		    (void*)tmp, 
		    C->checksum.length, 
		    key->schedule->data,
		    &ivec,
		    DES_DECRYPT);
    MD4_Init (&md4);
    MD4_Update (&md4, tmp, 8); /* confounder */
    MD4_Update (&md4, data, len);
    MD4_Final (res, &md4);
    if(memcmp(res, tmp + 8, sizeof(res)) != 0) {
	krb5_clear_error_string (context);
	ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
d855 19
a873 2
    memset(tmp, 0, sizeof(tmp));
    memset(res, 0, sizeof(res));
d877 4
a880 3
static void
RSA_MD5_checksum(krb5_context context,
		 struct key_data *key,
d883 2
a884 2
		 unsigned usage,
		 Checksum *C)
d886 5
a890 1
    MD5_CTX m;
d892 1
a892 4
    MD5_Init  (&m);
    MD5_Update(&m, data, len);
    MD5_Final (C->checksum.data, &m);
}
d894 7
a900 25
static void
RSA_MD5_DES_checksum(krb5_context context,
		     struct key_data *key,
		     const void *data,
		     size_t len,
		     unsigned usage,
		     Checksum *C)
{
    MD5_CTX md5;
    DES_cblock ivec;
    unsigned char *p = C->checksum.data;
    
    krb5_generate_random_block(p, 8);
    MD5_Init (&md5);
    MD5_Update (&md5, p, 8);
    MD5_Update (&md5, data, len);
    MD5_Final (p + 8, &md5);
    memset (&ivec, 0, sizeof(ivec));
    DES_cbc_encrypt(p, 
		    p, 
		    24, 
		    key->schedule->data, 
		    &ivec, 
		    DES_ENCRYPT);
}
d902 6
a907 14
static krb5_error_code
RSA_MD5_DES_verify(krb5_context context,
		   struct key_data *key,
		   const void *data,
		   size_t len,
		   unsigned usage,
		   Checksum *C)
{
    MD5_CTX md5;
    unsigned char tmp[24];
    unsigned char res[16];
    DES_cblock ivec;
    DES_key_schedule *sched = key->schedule->data;
    krb5_error_code ret = 0;
d909 24
a932 14
    memset(&ivec, 0, sizeof(ivec));
    DES_cbc_encrypt(C->checksum.data, 
		    (void*)tmp, 
		    C->checksum.length, 
		    &sched[0],
		    &ivec,
		    DES_DECRYPT);
    MD5_Init (&md5);
    MD5_Update (&md5, tmp, 8); /* confounder */
    MD5_Update (&md5, data, len);
    MD5_Final (res, &md5);
    if(memcmp(res, tmp + 8, sizeof(res)) != 0) {
	krb5_clear_error_string (context);
	ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
d934 6
a939 2
    memset(tmp, 0, sizeof(tmp));
    memset(res, 0, sizeof(res));
a942 27
static void
RSA_MD5_DES3_checksum(krb5_context context,
		      struct key_data *key,
		      const void *data,
		      size_t len,
		      unsigned usage,
		      Checksum *C)
{
    MD5_CTX md5;
    DES_cblock ivec;
    unsigned char *p = C->checksum.data;
    DES_key_schedule *sched = key->schedule->data;
    
    krb5_generate_random_block(p, 8);
    MD5_Init (&md5);
    MD5_Update (&md5, p, 8);
    MD5_Update (&md5, data, len);
    MD5_Final (p + 8, &md5);
    memset (&ivec, 0, sizeof(ivec));
    DES_ede3_cbc_encrypt(p, 
			 p, 
			 24, 
			 &sched[0], &sched[1], &sched[2],
			 &ivec, 
			 DES_ENCRYPT);
}

d944 7
a950 6
RSA_MD5_DES3_verify(krb5_context context,
		    struct key_data *key,
		    const void *data,
		    size_t len,
		    unsigned usage,
		    Checksum *C)
d952 5
a956 6
    MD5_CTX md5;
    unsigned char tmp[24];
    unsigned char res[16];
    DES_cblock ivec;
    DES_key_schedule *sched = key->schedule->data;
    krb5_error_code ret = 0;
d958 3
a960 56
    memset(&ivec, 0, sizeof(ivec));
    DES_ede3_cbc_encrypt(C->checksum.data, 
			 (void*)tmp, 
			 C->checksum.length, 
			 &sched[0], &sched[1], &sched[2],
			 &ivec,
			 DES_DECRYPT);
    MD5_Init (&md5);
    MD5_Update (&md5, tmp, 8); /* confounder */
    MD5_Update (&md5, data, len);
    MD5_Final (res, &md5);
    if(memcmp(res, tmp + 8, sizeof(res)) != 0) {
	krb5_clear_error_string (context);
	ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
    }
    memset(tmp, 0, sizeof(tmp));
    memset(res, 0, sizeof(res));
    return ret;
}

static void
SHA1_checksum(krb5_context context,
	      struct key_data *key,
	      const void *data,
	      size_t len,
	      unsigned usage,
	      Checksum *C)
{
    SHA_CTX m;

    SHA1_Init(&m);
    SHA1_Update(&m, data, len);
    SHA1_Final(C->checksum.data, &m);
}

/* HMAC according to RFC2104 */
static krb5_error_code
hmac(krb5_context context,
     struct checksum_type *cm, 
     const void *data, 
     size_t len, 
     unsigned usage,
     struct key_data *keyblock,
     Checksum *result)
{
    unsigned char *ipad, *opad;
    unsigned char *key;
    size_t key_len;
    int i;
    
    ipad = malloc(cm->blocksize + len);
    if (ipad == NULL)
	return ENOMEM;
    opad = malloc(cm->blocksize + cm->checksumsize);
    if (opad == NULL) {
	free(ipad);
d963 11
a973 854
    memset(ipad, 0x36, cm->blocksize);
    memset(opad, 0x5c, cm->blocksize);

    if(keyblock->key->keyvalue.length > cm->blocksize){
	(*cm->checksum)(context, 
			keyblock, 
			keyblock->key->keyvalue.data, 
			keyblock->key->keyvalue.length, 
			usage,
			result);
	key = result->checksum.data;
	key_len = result->checksum.length;
    } else {
	key = keyblock->key->keyvalue.data;
	key_len = keyblock->key->keyvalue.length;
    }
    for(i = 0; i < key_len; i++){
	ipad[i] ^= key[i];
	opad[i] ^= key[i];
    }
    memcpy(ipad + cm->blocksize, data, len);
    (*cm->checksum)(context, keyblock, ipad, cm->blocksize + len,
		    usage, result);
    memcpy(opad + cm->blocksize, result->checksum.data, 
	   result->checksum.length);
    (*cm->checksum)(context, keyblock, opad, 
		    cm->blocksize + cm->checksumsize, usage, result);
    memset(ipad, 0, cm->blocksize + len);
    free(ipad);
    memset(opad, 0, cm->blocksize + cm->checksumsize);
    free(opad);

    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_hmac(krb5_context context,
	  krb5_cksumtype cktype,
	  const void *data,
	  size_t len,
	  unsigned usage, 
	  krb5_keyblock *key,
	  Checksum *result)
{
    struct checksum_type *c = _find_checksum(cktype);
    struct key_data kd;
    krb5_error_code ret;

    if (c == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       cktype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    kd.key = key;
    kd.schedule = NULL;

    ret = hmac(context, c, data, len, usage, &kd, result);

    if (kd.schedule)
	krb5_free_data(context, kd.schedule);

    return ret;
 }

static void
SP_HMAC_SHA1_checksum(krb5_context context,
		      struct key_data *key, 
		      const void *data, 
		      size_t len, 
		      unsigned usage,
		      Checksum *result)
{
    struct checksum_type *c = _find_checksum(CKSUMTYPE_SHA1);
    Checksum res;
    char sha1_data[20];
    krb5_error_code ret;

    res.checksum.data = sha1_data;
    res.checksum.length = sizeof(sha1_data);

    ret = hmac(context, c, data, len, usage, key, &res);
    if (ret)
	krb5_abortx(context, "hmac failed");
    memcpy(result->checksum.data, res.checksum.data, result->checksum.length);
}

/*
 * checksum according to section 5. of draft-brezak-win2k-krb-rc4-hmac-03.txt
 */

static void
HMAC_MD5_checksum(krb5_context context,
		  struct key_data *key,
		  const void *data,
		  size_t len,
		  unsigned usage,
		  Checksum *result)
{
    MD5_CTX md5;
    struct checksum_type *c = _find_checksum (CKSUMTYPE_RSA_MD5);
    const char signature[] = "signaturekey";
    Checksum ksign_c;
    struct key_data ksign;
    krb5_keyblock kb;
    unsigned char t[4];
    unsigned char tmp[16];
    unsigned char ksign_c_data[16];
    krb5_error_code ret;

    ksign_c.checksum.length = sizeof(ksign_c_data);
    ksign_c.checksum.data   = ksign_c_data;
    ret = hmac(context, c, signature, sizeof(signature), 0, key, &ksign_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
    ksign.key = &kb;
    kb.keyvalue = ksign_c.checksum;
    MD5_Init (&md5);
    t[0] = (usage >>  0) & 0xFF;
    t[1] = (usage >>  8) & 0xFF;
    t[2] = (usage >> 16) & 0xFF;
    t[3] = (usage >> 24) & 0xFF;
    MD5_Update (&md5, t, 4);
    MD5_Update (&md5, data, len);
    MD5_Final (tmp, &md5);
    ret = hmac(context, c, tmp, sizeof(tmp), 0, &ksign, result);
    if (ret)
	krb5_abortx(context, "hmac failed");
}

/*
 * same as previous but being used while encrypting.
 */

static void
HMAC_MD5_checksum_enc(krb5_context context,
		      struct key_data *key,
		      const void *data,
		      size_t len,
		      unsigned usage,
		      Checksum *result)
{
    struct checksum_type *c = _find_checksum (CKSUMTYPE_RSA_MD5);
    Checksum ksign_c;
    struct key_data ksign;
    krb5_keyblock kb;
    unsigned char t[4];
    unsigned char ksign_c_data[16];
    krb5_error_code ret;

    t[0] = (usage >>  0) & 0xFF;
    t[1] = (usage >>  8) & 0xFF;
    t[2] = (usage >> 16) & 0xFF;
    t[3] = (usage >> 24) & 0xFF;

    ksign_c.checksum.length = sizeof(ksign_c_data);
    ksign_c.checksum.data   = ksign_c_data;
    ret = hmac(context, c, t, sizeof(t), 0, key, &ksign_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
    ksign.key = &kb;
    kb.keyvalue = ksign_c.checksum;
    ret = hmac(context, c, data, len, 0, &ksign, result);
    if (ret)
	krb5_abortx(context, "hmac failed");
}

static struct checksum_type checksum_none = {
    CKSUMTYPE_NONE, 
    "none", 
    1, 
    0, 
    0,
    NONE_checksum, 
    NULL
};
static struct checksum_type checksum_crc32 = {
    CKSUMTYPE_CRC32,
    "crc32",
    1,
    4,
    0,
    CRC32_checksum,
    NULL
};
static struct checksum_type checksum_rsa_md4 = {
    CKSUMTYPE_RSA_MD4,
    "rsa-md4",
    64,
    16,
    F_CPROOF,
    RSA_MD4_checksum,
    NULL
};
static struct checksum_type checksum_rsa_md4_des = {
    CKSUMTYPE_RSA_MD4_DES,
    "rsa-md4-des",
    64,
    24,
    F_KEYED | F_CPROOF | F_VARIANT,
    RSA_MD4_DES_checksum,
    RSA_MD4_DES_verify
};
#if 0
static struct checksum_type checksum_des_mac = { 
    CKSUMTYPE_DES_MAC,
    "des-mac",
    0,
    0,
    0,
    DES_MAC_checksum
};
static struct checksum_type checksum_des_mac_k = {
    CKSUMTYPE_DES_MAC_K,
    "des-mac-k",
    0,
    0,
    0,
    DES_MAC_K_checksum
};
static struct checksum_type checksum_rsa_md4_des_k = {
    CKSUMTYPE_RSA_MD4_DES_K, 
    "rsa-md4-des-k", 
    0, 
    0, 
    0, 
    RSA_MD4_DES_K_checksum,
    RSA_MD4_DES_K_verify
};
#endif
static struct checksum_type checksum_rsa_md5 = {
    CKSUMTYPE_RSA_MD5,
    "rsa-md5",
    64,
    16,
    F_CPROOF,
    RSA_MD5_checksum,
    NULL
};
static struct checksum_type checksum_rsa_md5_des = {
    CKSUMTYPE_RSA_MD5_DES,
    "rsa-md5-des",
    64,
    24,
    F_KEYED | F_CPROOF | F_VARIANT,
    RSA_MD5_DES_checksum,
    RSA_MD5_DES_verify
};
static struct checksum_type checksum_rsa_md5_des3 = {
    CKSUMTYPE_RSA_MD5_DES3,
    "rsa-md5-des3",
    64,
    24,
    F_KEYED | F_CPROOF | F_VARIANT,
    RSA_MD5_DES3_checksum,
    RSA_MD5_DES3_verify
};
static struct checksum_type checksum_sha1 = {
    CKSUMTYPE_SHA1,
    "sha1",
    64,
    20,
    F_CPROOF,
    SHA1_checksum,
    NULL
};
static struct checksum_type checksum_hmac_sha1_des3 = {
    CKSUMTYPE_HMAC_SHA1_DES3,
    "hmac-sha1-des3",
    64,
    20,
    F_KEYED | F_CPROOF | F_DERIVED,
    SP_HMAC_SHA1_checksum,
    NULL
};

static struct checksum_type checksum_hmac_sha1_aes128 = {
    CKSUMTYPE_HMAC_SHA1_96_AES_128,
    "hmac-sha1-96-aes128",
    64,
    12,
    F_KEYED | F_CPROOF | F_DERIVED,
    SP_HMAC_SHA1_checksum,
    NULL
};

static struct checksum_type checksum_hmac_sha1_aes256 = {
    CKSUMTYPE_HMAC_SHA1_96_AES_256,
    "hmac-sha1-96-aes256",
    64,
    12,
    F_KEYED | F_CPROOF | F_DERIVED,
    SP_HMAC_SHA1_checksum,
    NULL
};

static struct checksum_type checksum_hmac_md5 = {
    CKSUMTYPE_HMAC_MD5,
    "hmac-md5",
    64,
    16,
    F_KEYED | F_CPROOF,
    HMAC_MD5_checksum,
    NULL
};

static struct checksum_type checksum_hmac_md5_enc = {
    CKSUMTYPE_HMAC_MD5_ENC,
    "hmac-md5-enc",
    64,
    16,
    F_KEYED | F_CPROOF | F_PSEUDO,
    HMAC_MD5_checksum_enc,
    NULL
};

static struct checksum_type *checksum_types[] = {
    &checksum_none,
    &checksum_crc32,
    &checksum_rsa_md4,
    &checksum_rsa_md4_des,
#if 0
    &checksum_des_mac, 
    &checksum_des_mac_k,
    &checksum_rsa_md4_des_k,
#endif
    &checksum_rsa_md5,
    &checksum_rsa_md5_des,
    &checksum_rsa_md5_des3,
    &checksum_sha1,
    &checksum_hmac_sha1_des3,
    &checksum_hmac_sha1_aes128,
    &checksum_hmac_sha1_aes256,
    &checksum_hmac_md5,
    &checksum_hmac_md5_enc
};

static int num_checksums = sizeof(checksum_types) / sizeof(checksum_types[0]);

static struct checksum_type *
_find_checksum(krb5_cksumtype type)
{
    int i;
    for(i = 0; i < num_checksums; i++)
	if(checksum_types[i]->type == type)
	    return checksum_types[i];
    return NULL;
}

static krb5_error_code
get_checksum_key(krb5_context context, 
		 krb5_crypto crypto,
		 unsigned usage,  /* not krb5_key_usage */
		 struct checksum_type *ct, 
		 struct key_data **key)
{
    krb5_error_code ret = 0;

    if(ct->flags & F_DERIVED)
	ret = _get_derived_key(context, crypto, usage, key);
    else if(ct->flags & F_VARIANT) {
	int i;

	*key = _new_derived_key(crypto, 0xff/* KRB5_KU_RFC1510_VARIANT */);
	if(*key == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    return ENOMEM;
	}
	ret = krb5_copy_keyblock(context, crypto->key.key, &(*key)->key);
	if(ret) 
	    return ret;
	for(i = 0; i < (*key)->key->keyvalue.length; i++)
	    ((unsigned char*)(*key)->key->keyvalue.data)[i] ^= 0xF0;
    } else {
	*key = &crypto->key; 
    }
    if(ret == 0)
	ret = _key_schedule(context, *key, crypto->params);
    return ret;
}

static krb5_error_code
create_checksum (krb5_context context,
		 struct checksum_type *ct,
		 krb5_crypto crypto,
		 unsigned usage,
		 void *data,
		 size_t len,
		 Checksum *result)
{
    krb5_error_code ret;
    struct key_data *dkey;
    int keyed_checksum;
    
    if (ct->flags & F_DISABLED) {
	krb5_clear_error_string (context);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    keyed_checksum = (ct->flags & F_KEYED) != 0;
    if(keyed_checksum && crypto == NULL) {
	krb5_clear_error_string (context);
	return KRB5_PROG_SUMTYPE_NOSUPP; /* XXX */
    }
    if(keyed_checksum) {
	ret = get_checksum_key(context, crypto, usage, ct, &dkey);
	if (ret)
	    return ret;
    } else
	dkey = NULL;
    result->cksumtype = ct->type;
    krb5_data_alloc(&result->checksum, ct->checksumsize);
    (*ct->checksum)(context, dkey, data, len, usage, result);
    return 0;
}

static int
arcfour_checksum_p(struct checksum_type *ct, krb5_crypto crypto)
{
    return (ct->type == CKSUMTYPE_HMAC_MD5) &&
	(crypto->key.key->keytype == KEYTYPE_ARCFOUR);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_create_checksum(krb5_context context,
		     krb5_crypto crypto,
		     krb5_key_usage usage,
		     int type,
		     void *data,
		     size_t len,
		     Checksum *result)
{
    struct checksum_type *ct = NULL;
    unsigned keyusage;

    /* type 0 -> pick from crypto */
    if (type) {
	ct = _find_checksum(type);
    } else if (crypto) {
	ct = crypto->et->keyed_checksum;
	if (ct == NULL)
	    ct = crypto->et->checksum;
    }

    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    if (arcfour_checksum_p(ct, crypto)) {
	keyusage = usage;
	usage2arcfour(context, &keyusage);
    } else
	keyusage = CHECKSUM_USAGE(usage);

    return create_checksum(context, ct, crypto, keyusage,
			   data, len, result);
}

static krb5_error_code
verify_checksum(krb5_context context,
		krb5_crypto crypto,
		unsigned usage, /* not krb5_key_usage */
		void *data,
		size_t len,
		Checksum *cksum)
{
    krb5_error_code ret;
    struct key_data *dkey;
    int keyed_checksum;
    Checksum c;
    struct checksum_type *ct;

    ct = _find_checksum(cksum->cksumtype);
    if (ct == NULL || (ct->flags & F_DISABLED)) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       cksum->cksumtype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    if(ct->checksumsize != cksum->checksum.length) {
	krb5_clear_error_string (context);
	return KRB5KRB_AP_ERR_BAD_INTEGRITY; /* XXX */
    }
    keyed_checksum = (ct->flags & F_KEYED) != 0;
    if(keyed_checksum && crypto == NULL) {
	krb5_clear_error_string (context);
	return KRB5_PROG_SUMTYPE_NOSUPP; /* XXX */
    }
    if(keyed_checksum)
	ret = get_checksum_key(context, crypto, usage, ct, &dkey);
    else
	dkey = NULL;
    if(ct->verify)
	return (*ct->verify)(context, dkey, data, len, usage, cksum);

    ret = krb5_data_alloc (&c.checksum, ct->checksumsize);
    if (ret)
	return ret;

    (*ct->checksum)(context, dkey, data, len, usage, &c);

    if(c.checksum.length != cksum->checksum.length || 
       memcmp(c.checksum.data, cksum->checksum.data, c.checksum.length)) {
	krb5_clear_error_string (context);
	ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;
    } else {
	ret = 0;
    }
    krb5_data_free (&c.checksum);
    return ret;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_verify_checksum(krb5_context context,
		     krb5_crypto crypto,
		     krb5_key_usage usage, 
		     void *data,
		     size_t len,
		     Checksum *cksum)
{
    struct checksum_type *ct;
    unsigned keyusage;

    ct = _find_checksum(cksum->cksumtype);
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       cksum->cksumtype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    if (arcfour_checksum_p(ct, crypto)) {
	keyusage = usage;
	usage2arcfour(context, &keyusage);
    } else
	keyusage = CHECKSUM_USAGE(usage);

    return verify_checksum(context, crypto, keyusage,
			   data, len, cksum);
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_get_checksum_type(krb5_context context,
                              krb5_crypto crypto,
			      krb5_cksumtype *type)
{
    struct checksum_type *ct = NULL;
    
    if (crypto != NULL) {
        ct = crypto->et->keyed_checksum;
        if (ct == NULL)
            ct = crypto->et->checksum;
    }
    
    if (ct == NULL) {
	krb5_set_error_string (context, "checksum type not found");
        return KRB5_PROG_SUMTYPE_NOSUPP;
    }    

    *type = ct->type;
    
    return 0;      
}


krb5_error_code KRB5_LIB_FUNCTION
krb5_checksumsize(krb5_context context,
		  krb5_cksumtype type,
		  size_t *size)
{
    struct checksum_type *ct = _find_checksum(type);
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    *size = ct->checksumsize;
    return 0;
}

krb5_boolean KRB5_LIB_FUNCTION
krb5_checksum_is_keyed(krb5_context context,
		       krb5_cksumtype type)
{
    struct checksum_type *ct = _find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_string (context, "checksum type %d not supported",
				   type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    return ct->flags & F_KEYED;
}

krb5_boolean KRB5_LIB_FUNCTION
krb5_checksum_is_collision_proof(krb5_context context,
				 krb5_cksumtype type)
{
    struct checksum_type *ct = _find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_string (context, "checksum type %d not supported",
				   type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    return ct->flags & F_CPROOF;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_checksum_disable(krb5_context context,
		      krb5_cksumtype type)
{
    struct checksum_type *ct = _find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_string (context, "checksum type %d not supported",
				   type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    ct->flags |= F_DISABLED;
    return 0;
}

/************************************************************
 *                                                          *
 ************************************************************/

static krb5_error_code
NULL_encrypt(krb5_context context,
	     struct key_data *key, 
	     void *data, 
	     size_t len, 
	     krb5_boolean encrypt,
	     int usage,
	     void *ivec)
{
    return 0;
}

static krb5_error_code
DES_CBC_encrypt_null_ivec(krb5_context context,
			  struct key_data *key, 
			  void *data, 
			  size_t len, 
			  krb5_boolean encrypt,
			  int usage,
			  void *ignore_ivec)
{
    DES_cblock ivec;
    DES_key_schedule *s = key->schedule->data;
    memset(&ivec, 0, sizeof(ivec));
    DES_cbc_encrypt(data, data, len, s, &ivec, encrypt);
    return 0;
}

static krb5_error_code
DES_CBC_encrypt_key_ivec(krb5_context context,
			 struct key_data *key, 
			 void *data, 
			 size_t len, 
			 krb5_boolean encrypt,
			 int usage,
			 void *ignore_ivec)
{
    DES_cblock ivec;
    DES_key_schedule *s = key->schedule->data;
    memcpy(&ivec, key->key->keyvalue.data, sizeof(ivec));
    DES_cbc_encrypt(data, data, len, s, &ivec, encrypt);
    return 0;
}

static krb5_error_code
DES3_CBC_encrypt(krb5_context context,
		 struct key_data *key, 
		 void *data, 
		 size_t len, 
		 krb5_boolean encrypt,
		 int usage,
		 void *ivec)
{
    DES_cblock local_ivec;
    DES_key_schedule *s = key->schedule->data;
    if(ivec == NULL) {
	ivec = &local_ivec;
	memset(local_ivec, 0, sizeof(local_ivec));
    }
    DES_ede3_cbc_encrypt(data, data, len, &s[0], &s[1], &s[2], ivec, encrypt);
    return 0;
}

static krb5_error_code
DES_CFB64_encrypt_null_ivec(krb5_context context,
			    struct key_data *key, 
			    void *data, 
			    size_t len, 
			    krb5_boolean encrypt,
			    int usage,
			    void *ignore_ivec)
{
    DES_cblock ivec;
    int num = 0;
    DES_key_schedule *s = key->schedule->data;
    memset(&ivec, 0, sizeof(ivec));

    DES_cfb64_encrypt(data, data, len, s, &ivec, &num, encrypt);
    return 0;
}

static krb5_error_code
DES_PCBC_encrypt_key_ivec(krb5_context context,
			  struct key_data *key, 
			  void *data, 
			  size_t len, 
			  krb5_boolean encrypt,
			  int usage,
			  void *ignore_ivec)
{
    DES_cblock ivec;
    DES_key_schedule *s = key->schedule->data;
    memcpy(&ivec, key->key->keyvalue.data, sizeof(ivec));

    DES_pcbc_encrypt(data, data, len, s, &ivec, encrypt);
    return 0;
}

/*
 * AES draft-raeburn-krb-rijndael-krb-02
 */

void KRB5_LIB_FUNCTION
_krb5_aes_cts_encrypt(const unsigned char *in, unsigned char *out,
		      size_t len, const void *aes_key,
		      unsigned char *ivec, const int encrypt)
{
    unsigned char tmp[AES_BLOCK_SIZE];
    const AES_KEY *key = aes_key; /* XXX remove this when we always have AES */
    int i;

    /*
     * In the framework of kerberos, the length can never be shorter
     * than at least one blocksize.
     */

    if (encrypt) {

	while(len > AES_BLOCK_SIZE) {
	    for (i = 0; i < AES_BLOCK_SIZE; i++)
		tmp[i] = in[i] ^ ivec[i];
	    AES_encrypt(tmp, out, key);
	    memcpy(ivec, out, AES_BLOCK_SIZE);
	    len -= AES_BLOCK_SIZE;
	    in += AES_BLOCK_SIZE;
	    out += AES_BLOCK_SIZE;
	}

	for (i = 0; i < len; i++)
	    tmp[i] = in[i] ^ ivec[i];
	for (; i < AES_BLOCK_SIZE; i++)
	    tmp[i] = 0 ^ ivec[i];

	AES_encrypt(tmp, out - AES_BLOCK_SIZE, key);

	memcpy(out, ivec, len);
	memcpy(ivec, out - AES_BLOCK_SIZE, AES_BLOCK_SIZE);

    } else {
	unsigned char tmp2[AES_BLOCK_SIZE];
	unsigned char tmp3[AES_BLOCK_SIZE];

	while(len > AES_BLOCK_SIZE * 2) {
	    memcpy(tmp, in, AES_BLOCK_SIZE);
	    AES_decrypt(in, out, key);
	    for (i = 0; i < AES_BLOCK_SIZE; i++)
		out[i] ^= ivec[i];
	    memcpy(ivec, tmp, AES_BLOCK_SIZE);
	    len -= AES_BLOCK_SIZE;
	    in += AES_BLOCK_SIZE;
	    out += AES_BLOCK_SIZE;
	}

	len -= AES_BLOCK_SIZE;

	memcpy(tmp, in, AES_BLOCK_SIZE); /* save last iv */
	AES_decrypt(in, tmp2, key);

	memcpy(tmp3, in + AES_BLOCK_SIZE, len);
	memcpy(tmp3 + len, tmp2 + len, AES_BLOCK_SIZE - len); /* xor 0 */

	for (i = 0; i < len; i++)
	    out[i + AES_BLOCK_SIZE] = tmp2[i] ^ tmp3[i];

	AES_decrypt(tmp3, out, key);
	for (i = 0; i < AES_BLOCK_SIZE; i++)
	    out[i] ^= ivec[i];
	memcpy(ivec, tmp, AES_BLOCK_SIZE);
    }
}

static krb5_error_code
AES_CTS_encrypt(krb5_context context,
		struct key_data *key,
		void *data,
		size_t len,
		krb5_boolean encrypt,
		int usage,
		void *ivec)
{
    struct krb5_aes_schedule *aeskey = key->schedule->data;
    char local_ivec[AES_BLOCK_SIZE];
    AES_KEY *k;

    if (encrypt)
	k = &aeskey->ekey;
    else
	k = &aeskey->dkey;
    
    if (len < AES_BLOCK_SIZE)
	krb5_abortx(context, "invalid use of AES_CTS_encrypt");
    if (len == AES_BLOCK_SIZE) {
	if (encrypt)
	    AES_encrypt(data, data, k);
	else
	    AES_decrypt(data, data, k);
    } else {
	if(ivec == NULL) {
	    memset(local_ivec, 0, sizeof(local_ivec));
	    ivec = local_ivec;
	}
	_krb5_aes_cts_encrypt(data, data, len, k, ivec, encrypt);
    }

    return 0;
}

static krb5_error_code 
AES_CBC_encrypt(krb5_context context,
                struct key_data *key, 
                void *data,
                size_t len,  
                krb5_boolean encrypt, 
                int usage,
                void *ivec)
{
    struct krb5_aes_schedule *aeskey = key->schedule->data;
    char local_ivec[AES_BLOCK_SIZE];
    AES_KEY *k;

    if (encrypt)
	k = &aeskey->ekey;
    else
	k = &aeskey->dkey;

    if(ivec == NULL) {
        ivec = &local_ivec;
        memset(local_ivec, 0, sizeof(local_ivec));
d975 2
a976 24
    AES_cbc_encrypt(data, data, len, k, ivec, encrypt);
    return 0;
}

/*
 * RC2
 */

static krb5_error_code 
RC2_CBC_encrypt(krb5_context context,
                struct key_data *key, 
                void *data,
                size_t len,  
                krb5_boolean encrypt, 
                int usage,
                void *ivec)
{
    unsigned char local_ivec[8];
    RC2_KEY *s = key->schedule->data; 
    if(ivec == NULL) {
        ivec = &local_ivec;
        memset(local_ivec, 0, sizeof(local_ivec));
    }
    RC2_cbc_encrypt(data, data, len, s, ivec, encrypt);
a979 6
/*
 * section 6 of draft-brezak-win2k-krb-rc4-hmac-03
 *
 * warning: not for small children
 */

d981 11
a991 15
ARCFOUR_subencrypt(krb5_context context,
		   struct key_data *key,
		   void *data,
		   size_t len,
		   unsigned usage,
		   void *ivec)
{
    struct checksum_type *c = _find_checksum (CKSUMTYPE_RSA_MD5);
    Checksum k1_c, k2_c, k3_c, cksum;
    struct key_data ke;
    krb5_keyblock kb;
    unsigned char t[4];
    RC4_KEY rc4_key;
    unsigned char *cdata = data;
    unsigned char k1_c_data[16], k2_c_data[16], k3_c_data[16];
d993 3
d997 6
a1002 113
    t[0] = (usage >>  0) & 0xFF;
    t[1] = (usage >>  8) & 0xFF;
    t[2] = (usage >> 16) & 0xFF;
    t[3] = (usage >> 24) & 0xFF;

    k1_c.checksum.length = sizeof(k1_c_data);
    k1_c.checksum.data   = k1_c_data;

    ret = hmac(NULL, c, t, sizeof(t), 0, key, &k1_c);
    if (ret)
	krb5_abortx(context, "hmac failed");

    memcpy (k2_c_data, k1_c_data, sizeof(k1_c_data));

    k2_c.checksum.length = sizeof(k2_c_data);
    k2_c.checksum.data   = k2_c_data;

    ke.key = &kb;
    kb.keyvalue = k2_c.checksum;

    cksum.checksum.length = 16;
    cksum.checksum.data   = data;

    ret = hmac(NULL, c, cdata + 16, len - 16, 0, &ke, &cksum);
    if (ret)
	krb5_abortx(context, "hmac failed");

    ke.key = &kb;
    kb.keyvalue = k1_c.checksum;

    k3_c.checksum.length = sizeof(k3_c_data);
    k3_c.checksum.data   = k3_c_data;

    ret = hmac(NULL, c, data, 16, 0, &ke, &k3_c);
    if (ret)
	krb5_abortx(context, "hmac failed");

    RC4_set_key (&rc4_key, k3_c.checksum.length, k3_c.checksum.data);
    RC4 (&rc4_key, len - 16, cdata + 16, cdata + 16);
    memset (k1_c_data, 0, sizeof(k1_c_data));
    memset (k2_c_data, 0, sizeof(k2_c_data));
    memset (k3_c_data, 0, sizeof(k3_c_data));
    return 0;
}

static krb5_error_code
ARCFOUR_subdecrypt(krb5_context context,
		   struct key_data *key,
		   void *data,
		   size_t len,
		   unsigned usage,
		   void *ivec)
{
    struct checksum_type *c = _find_checksum (CKSUMTYPE_RSA_MD5);
    Checksum k1_c, k2_c, k3_c, cksum;
    struct key_data ke;
    krb5_keyblock kb;
    unsigned char t[4];
    RC4_KEY rc4_key;
    unsigned char *cdata = data;
    unsigned char k1_c_data[16], k2_c_data[16], k3_c_data[16];
    unsigned char cksum_data[16];
    krb5_error_code ret;

    t[0] = (usage >>  0) & 0xFF;
    t[1] = (usage >>  8) & 0xFF;
    t[2] = (usage >> 16) & 0xFF;
    t[3] = (usage >> 24) & 0xFF;

    k1_c.checksum.length = sizeof(k1_c_data);
    k1_c.checksum.data   = k1_c_data;

    ret = hmac(NULL, c, t, sizeof(t), 0, key, &k1_c);
    if (ret)
	krb5_abortx(context, "hmac failed");

    memcpy (k2_c_data, k1_c_data, sizeof(k1_c_data));

    k2_c.checksum.length = sizeof(k2_c_data);
    k2_c.checksum.data   = k2_c_data;

    ke.key = &kb;
    kb.keyvalue = k1_c.checksum;

    k3_c.checksum.length = sizeof(k3_c_data);
    k3_c.checksum.data   = k3_c_data;

    ret = hmac(NULL, c, cdata, 16, 0, &ke, &k3_c);
    if (ret)
	krb5_abortx(context, "hmac failed");

    RC4_set_key (&rc4_key, k3_c.checksum.length, k3_c.checksum.data);
    RC4 (&rc4_key, len - 16, cdata + 16, cdata + 16);

    ke.key = &kb;
    kb.keyvalue = k2_c.checksum;

    cksum.checksum.length = 16;
    cksum.checksum.data   = cksum_data;

    ret = hmac(NULL, c, cdata + 16, len - 16, 0, &ke, &cksum);
    if (ret)
	krb5_abortx(context, "hmac failed");

    memset (k1_c_data, 0, sizeof(k1_c_data));
    memset (k2_c_data, 0, sizeof(k2_c_data));
    memset (k3_c_data, 0, sizeof(k3_c_data));

    if (memcmp (cksum.checksum.data, data, 16) != 0) {
	krb5_clear_error_string (context);
	return KRB5KRB_AP_ERR_BAD_INTEGRITY;
    } else {
	return 0;
a1003 1
}
d1005 3
a1007 25
/*
 * convert the usage numbers used in
 * draft-ietf-cat-kerb-key-derivation-00.txt to the ones in
 * draft-brezak-win2k-krb-rc4-hmac-04.txt
 */

static krb5_error_code
usage2arcfour (krb5_context context, unsigned *usage)
{
    switch (*usage) {
    case KRB5_KU_AS_REP_ENC_PART : /* 3 */
    case KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : /* 9 */
	*usage = 8;
	return 0;
    case KRB5_KU_USAGE_SEAL :  /* 22 */
	*usage = 13;
	return 0;
    case KRB5_KU_USAGE_SIGN : /* 23 */
        *usage = 15;
        return 0;
    case KRB5_KU_USAGE_SEQ: /* 24 */
	*usage = 0;
	return 0;
    default :
	return 0;
a1008 1
}
d1010 3
a1012 335
static krb5_error_code
ARCFOUR_encrypt(krb5_context context,
		struct key_data *key,
		void *data,
		size_t len,
		krb5_boolean encrypt,
		int usage,
		void *ivec)
{
    krb5_error_code ret;
    unsigned keyusage = usage;

    if((ret = usage2arcfour (context, &keyusage)) != 0)
	return ret;

    if (encrypt)
	return ARCFOUR_subencrypt (context, key, data, len, keyusage, ivec);
    else
	return ARCFOUR_subdecrypt (context, key, data, len, keyusage, ivec);
}


/*
 * these should currently be in reverse preference order.
 * (only relevant for !F_PSEUDO) */

static struct encryption_type enctype_null = {
    ETYPE_NULL,
    "null",
    NULL,
    1,
    1,
    0,
    &keytype_null,
    &checksum_none,
    NULL,
    F_DISABLED,
    NULL_encrypt,
};
static struct encryption_type enctype_des_cbc_crc = {
    ETYPE_DES_CBC_CRC,
    "des-cbc-crc",
    NULL,
    8,
    8,
    8,
    &keytype_des,
    &checksum_crc32,
    NULL,
    0,
    DES_CBC_encrypt_key_ivec,
};
static struct encryption_type enctype_des_cbc_md4 = {
    ETYPE_DES_CBC_MD4,
    "des-cbc-md4",
    NULL,
    8,
    8,
    8,
    &keytype_des,
    &checksum_rsa_md4,
    &checksum_rsa_md4_des,
    0,
    DES_CBC_encrypt_null_ivec,
};
static struct encryption_type enctype_des_cbc_md5 = {
    ETYPE_DES_CBC_MD5,
    "des-cbc-md5",
    NULL,
    8,
    8,
    8,
    &keytype_des,
    &checksum_rsa_md5,
    &checksum_rsa_md5_des,
    0,
    DES_CBC_encrypt_null_ivec,
};
static struct encryption_type enctype_arcfour_hmac_md5 = {
    ETYPE_ARCFOUR_HMAC_MD5,
    "arcfour-hmac-md5",
    NULL,
    1,
    1,
    8,
    &keytype_arcfour,
    &checksum_hmac_md5,
    NULL,
    F_SPECIAL,
    ARCFOUR_encrypt
};
static struct encryption_type enctype_des3_cbc_md5 = { 
    ETYPE_DES3_CBC_MD5,
    "des3-cbc-md5",
    NULL,
    8,
    8,
    8,
    &keytype_des3,
    &checksum_rsa_md5,
    &checksum_rsa_md5_des3,
    0,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_des3_cbc_sha1 = {
    ETYPE_DES3_CBC_SHA1,
    "des3-cbc-sha1",
    NULL,
    8,
    8,
    8,
    &keytype_des3_derived,
    &checksum_sha1,
    &checksum_hmac_sha1_des3,
    F_DERIVED,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_old_des3_cbc_sha1 = {
    ETYPE_OLD_DES3_CBC_SHA1,
    "old-des3-cbc-sha1",
    NULL,
    8,
    8,
    8,
    &keytype_des3,
    &checksum_sha1,
    &checksum_hmac_sha1_des3,
    0,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_aes128_cts_hmac_sha1 = {
    ETYPE_AES128_CTS_HMAC_SHA1_96,
    "aes128-cts-hmac-sha1-96",
    NULL,
    16,
    1,
    16,
    &keytype_aes128,
    &checksum_sha1,
    &checksum_hmac_sha1_aes128,
    F_DERIVED,
    AES_CTS_encrypt,
};
static struct encryption_type enctype_aes256_cts_hmac_sha1 = {
    ETYPE_AES256_CTS_HMAC_SHA1_96,
    "aes256-cts-hmac-sha1-96",
    NULL,
    16,
    1,
    16,
    &keytype_aes256,
    &checksum_sha1,
    &checksum_hmac_sha1_aes256,
    F_DERIVED,
    AES_CTS_encrypt,
};
static unsigned aes_128_cbc_num[] = { 2, 16, 840, 1, 101, 3, 4, 1, 2 };
static heim_oid aes_128_cbc_oid = kcrypto_oid_enc(aes_128_cbc_num);
static struct encryption_type enctype_aes128_cbc_none = {
    ETYPE_AES128_CBC_NONE,
    "aes128-cbc-none",
    &aes_128_cbc_oid,
    16,
    16,
    16,
    &keytype_aes128,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    AES_CBC_encrypt,
};
static unsigned aes_192_cbc_num[] = { 2, 16, 840, 1, 101, 3, 4, 1, 22 };
static heim_oid aes_192_cbc_oid = kcrypto_oid_enc(aes_192_cbc_num);
static struct encryption_type enctype_aes192_cbc_none = {
    ETYPE_AES192_CBC_NONE,
    "aes192-cbc-none",
    &aes_192_cbc_oid,
    16,
    16,
    16,
    &keytype_aes192,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    AES_CBC_encrypt,
};
static unsigned aes_256_cbc_num[] = { 2, 16, 840, 1, 101, 3, 4, 1, 42 };
static heim_oid aes_256_cbc_oid = kcrypto_oid_enc(aes_256_cbc_num);
static struct encryption_type enctype_aes256_cbc_none = {
    ETYPE_AES256_CBC_NONE,
    "aes256-cbc-none",
    &aes_256_cbc_oid,
    16,
    16,
    16,
    &keytype_aes256,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    AES_CBC_encrypt,
};
static struct encryption_type enctype_des_cbc_none = {
    ETYPE_DES_CBC_NONE,
    "des-cbc-none",
    NULL,
    8,
    8,
    0,
    &keytype_des,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES_CBC_encrypt_null_ivec,
};
static struct encryption_type enctype_des_cfb64_none = {
    ETYPE_DES_CFB64_NONE,
    "des-cfb64-none",
    NULL,
    1,
    1,
    0,
    &keytype_des,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES_CFB64_encrypt_null_ivec,
};
static struct encryption_type enctype_des_pcbc_none = {
    ETYPE_DES_PCBC_NONE,
    "des-pcbc-none",
    NULL,
    8,
    8,
    0,
    &keytype_des,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES_PCBC_encrypt_key_ivec,
};
static unsigned des_ede3_cbc_num[] = { 1, 2, 840, 113549, 3, 7 };
static heim_oid des_ede3_cbc_oid = kcrypto_oid_enc(des_ede3_cbc_num);
static struct encryption_type enctype_des3_cbc_none_cms = {
    ETYPE_DES3_CBC_NONE_CMS,
    "des3-cbc-none-cms",
    &des_ede3_cbc_oid,
    8,
    8,
    0,
    &keytype_des3_derived,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_des3_cbc_none = {
    ETYPE_DES3_CBC_NONE,
    "des3-cbc-none",
    NULL,
    8,
    8,
    0,
    &keytype_des3_derived,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES3_CBC_encrypt,
};
static unsigned rc2CBC_num[] = { 1, 2, 840, 113549, 3, 2 };
static heim_oid rc2CBC_oid = kcrypto_oid_enc(rc2CBC_num);
static struct encryption_type enctype_rc2_cbc_none = {
    ETYPE_RC2_CBC_NONE,
    "rc2-cbc-none",
    &rc2CBC_oid,
    8,
    8,
    0,
    &keytype_rc2,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    RC2_CBC_encrypt,
};

static struct encryption_type *etypes[] = {
    &enctype_null,
    &enctype_des_cbc_crc,
    &enctype_des_cbc_md4,
    &enctype_des_cbc_md5,
    &enctype_arcfour_hmac_md5,
    &enctype_des3_cbc_md5, 
    &enctype_des3_cbc_sha1,
    &enctype_old_des3_cbc_sha1,
    &enctype_aes128_cts_hmac_sha1,
    &enctype_aes256_cts_hmac_sha1,
    &enctype_aes128_cbc_none,
    &enctype_aes192_cbc_none,
    &enctype_aes256_cbc_none,
    &enctype_des_cbc_none,
    &enctype_des_cfb64_none,
    &enctype_des_pcbc_none,
    &enctype_des3_cbc_none,
    &enctype_des3_cbc_none_cms,
    &enctype_rc2_cbc_none
};

static unsigned num_etypes = sizeof(etypes) / sizeof(etypes[0]);


static struct encryption_type *
_find_enctype(krb5_enctype type)
{
    int i;
    for(i = 0; i < num_etypes; i++)
	if(etypes[i]->type == type)
	    return etypes[i];
    return NULL;
}


krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_to_string(krb5_context context,
		       krb5_enctype etype,
		       char **string)
{
    struct encryption_type *e;
    e = _find_enctype(etype);
    if(e == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    *string = strdup(e->name);
    if(*string == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d1015 1
a1015 2
    return 0;
}
d1017 1
a1017 15
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_enctype(krb5_context context,
		       const char *string,
		       krb5_enctype *etype)
{
    int i;
    for(i = 0; i < num_etypes; i++)
	if(strcasecmp(etypes[i]->name, string) == 0){
	    *etype = etypes[i]->type;
	    return 0;
	}
    krb5_set_error_string (context, "encryption type %s not supported",
			   string);
    return KRB5_PROG_ETYPE_NOSUPP;
}
d1019 4
a1022 10
krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_to_oid(krb5_context context,
		    krb5_enctype etype,
		    heim_oid *oid)
{
    struct encryption_type *et = _find_enctype(etype);
    if(et == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
d1024 4
a1027 3
    if(et->oid == NULL) {
	krb5_set_error_string (context, "%s have not oid", et->name);
	return KRB5_PROG_ETYPE_NOSUPP;
d1029 4
a1032 15
    krb5_clear_error_string(context);
    return copy_oid(et->oid, oid);
}

krb5_error_code KRB5_LIB_FUNCTION
_krb5_oid_to_enctype(krb5_context context,
		     const heim_oid *oid,
		     krb5_enctype *etype)
{
    int i;
    for(i = 0; i < num_etypes; i++) {
	if(etypes[i]->oid && heim_oid_cmp(etypes[i]->oid, oid) == 0) {
	    *etype = etypes[i]->type;
	    return 0;
	}
a1033 3
    krb5_set_error_string(context, "enctype for oid not supported");
    return KRB5_PROG_ETYPE_NOSUPP;
}
d1035 3
a1037 14
krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_to_keytype(krb5_context context,
			krb5_enctype etype,
			krb5_keytype *keytype)
{
    struct encryption_type *e = _find_enctype(etype);
    if(e == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    *keytype = e->keytype->type; /* XXX */
    return 0;
}
d1039 9
a1047 29
#if 0
krb5_error_code KRB5_LIB_FUNCTION
krb5_keytype_to_enctype(krb5_context context,
			krb5_keytype keytype,
			krb5_enctype *etype)
{
    struct key_type *kt = _find_keytype(keytype);
    krb5_warnx(context, "krb5_keytype_to_enctype(%u)", keytype);
    if(kt == NULL)
	return KRB5_PROG_KEYTYPE_NOSUPP;
    *etype = kt->best_etype;
    return 0;
}
#endif
    
krb5_error_code KRB5_LIB_FUNCTION
krb5_keytype_to_enctypes (krb5_context context,
			  krb5_keytype keytype,
			  unsigned *len,
			  krb5_enctype **val)
{
    int i;
    unsigned n = 0;
    krb5_enctype *ret;

    for (i = num_etypes - 1; i >= 0; --i) {
	if (etypes[i]->keytype->type == keytype
	    && !(etypes[i]->flags & F_PSEUDO))
	    ++n;
d1049 6
a1054 3
    ret = malloc(n * sizeof(*ret));
    if (ret == NULL && n != 0) {
	krb5_set_error_string(context, "malloc: out of memory");
d1057 1
a1057 8
    n = 0;
    for (i = num_etypes - 1; i >= 0; --i) {
	if (etypes[i]->keytype->type == keytype
	    && !(etypes[i]->flags & F_PSEUDO))
	    ret[n++] = etypes[i]->type;
    }
    *len = n;
    *val = ret;
d1061 7
a1067 10
/*
 * First take the configured list of etypes for `keytype' if available,
 * else, do `krb5_keytype_to_enctypes'.
 */

krb5_error_code KRB5_LIB_FUNCTION
krb5_keytype_to_enctypes_default (krb5_context context,
				  krb5_keytype keytype,
				  unsigned *len,
				  krb5_enctype **val)
d1069 5
a1073 2
    int i, n;
    krb5_enctype *ret;
d1075 11
a1085 2
    if (keytype != KEYTYPE_DES || context->etypes_des == NULL)
	return krb5_keytype_to_enctypes (context, keytype, len, val);
d1087 3
a1089 5
    for (n = 0; context->etypes_des[n]; ++n)
	;
    ret = malloc (n * sizeof(*ret));
    if (ret == NULL && n != 0) {
	krb5_set_error_string(context, "malloc: out of memory");
d1092 1
a1092 6
    for (i = 0; i < n; ++i)
	ret[i] = context->etypes_des[i];
    *len = n;
    *val = ret;
    return 0;
}
d1094 9
a1102 9
krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_valid(krb5_context context, 
		 krb5_enctype etype)
{
    struct encryption_type *e = _find_enctype(etype);
    if(e == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
d1104 4
a1107 4
    if (e->flags & F_DISABLED) {
	krb5_set_error_string (context, "encryption type %s is disabled",
			       e->name);
	return KRB5_PROG_ETYPE_NOSUPP;
d1109 7
a1115 12
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_cksumtype_valid(krb5_context context, 
		     krb5_cksumtype ctype)
{
    struct checksum_type *c = _find_checksum(ctype);
    if (c == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       ctype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
d1117 7
a1123 4
    if (c->flags & F_DISABLED) {
	krb5_set_error_string (context, "checksum type %s is disabled",
			       c->name);
	return KRB5_PROG_SUMTYPE_NOSUPP;
d1125 1
a1128 29

/* if two enctypes have compatible keys */
krb5_boolean KRB5_LIB_FUNCTION
krb5_enctypes_compatible_keys(krb5_context context,
			      krb5_enctype etype1,
			      krb5_enctype etype2)
{
    struct encryption_type *e1 = _find_enctype(etype1);
    struct encryption_type *e2 = _find_enctype(etype2);
    return e1 != NULL && e2 != NULL && e1->keytype == e2->keytype;
}

static krb5_boolean
derived_crypto(krb5_context context,
	       krb5_crypto crypto)
{
    return (crypto->et->flags & F_DERIVED) != 0;
}

static krb5_boolean
special_crypto(krb5_context context,
	       krb5_crypto crypto)
{
    return (crypto->et->flags & F_SPECIAL) != 0;
}

#define CHECKSUMSIZE(C) ((C)->checksumsize)
#define CHECKSUMTYPE(C) ((C)->type)

d1130 1
a1130 1
encrypt_internal_derived(krb5_context context,
d1132 1
a1132 1
			 unsigned usage,
d1138 4
a1141 3
    size_t sz, block_sz, checksum_sz, total_sz;
    Checksum cksum;
    unsigned char *p, *q;
a1142 4
    struct key_data *dkey;
    const struct encryption_type *et = crypto->et;
    
    checksum_sz = CHECKSUMSIZE(et->keyed_checksum);
d1144 14
a1157 6
    sz = et->confoundersize + len;
    block_sz = (sz + et->padsize - 1) &~ (et->padsize - 1); /* pad */
    total_sz = block_sz + checksum_sz;
    p = calloc(1, total_sz);
    if(p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d1160 14
a1173 17
    
    q = p;
    krb5_generate_random_block(q, et->confoundersize); /* XXX */
    q += et->confoundersize;
    memcpy(q, data, len);
    
    ret = create_checksum(context, 
			  et->keyed_checksum,
			  crypto, 
			  INTEGRITY_USAGE(usage),
			  p, 
			  block_sz,
			  &cksum);
    if(ret == 0 && cksum.checksum.length != checksum_sz) {
	free_Checksum (&cksum);
	krb5_clear_error_string (context);
	ret = KRB5_CRYPTO_INTERNAL;
d1175 1
a1175 18
    if(ret)
	goto fail;
    memcpy(p + block_sz, cksum.checksum.data, cksum.checksum.length);
    free_Checksum (&cksum);
    ret = _get_derived_key(context, crypto, ENCRYPTION_USAGE(usage), &dkey);
    if(ret)
	goto fail;
    ret = _key_schedule(context, dkey, crypto->params);
    if(ret)
	goto fail;
#ifdef CRYPTO_DEBUG
    krb5_crypto_debug(context, 1, block_sz, dkey->key);
#endif
    ret = (*et->encrypt)(context, dkey, p, block_sz, 1, usage, ivec);
    if (ret)
	goto fail;
    result->data = p;
    result->length = total_sz;
a1176 4
 fail:
    memset(p, 0, total_sz);
    free(p);
    return ret;
d1179 33
d1213 7
a1219 7
static krb5_error_code
encrypt_internal(krb5_context context,
		 krb5_crypto crypto,
		 void *data,
		 size_t len,
		 krb5_data *result,
		 void *ivec)
d1221 3
a1223 1
    size_t sz, block_sz, checksum_sz, padsize = 0;
d1227 24
a1250 5
    const struct encryption_type *et = crypto->et;
    
    checksum_sz = CHECKSUMSIZE(et->checksum);
    
    sz = et->confoundersize + checksum_sz + len;
d1252 24
a1275 4
    if ((et->flags & F_PADCMS) && et->padsize != 1) {
	padsize = et->padsize - (sz % et->padsize);
	if (padsize == et->padsize)
	    block_sz += et->padsize;
d1277 29
a1305 4
    p = calloc(1, block_sz);
    if(p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
d1307 2
a1308 7
    
    q = p;
    krb5_generate_random_block(q, et->confoundersize); /* XXX */
    q += et->confoundersize;
    memset(q, 0, checksum_sz);
    q += checksum_sz;
    memcpy(q, data, len);
d1310 2
a1311 2
    ret = create_checksum(context, 
			  et->checksum,
d1313 3
a1315 3
			  0,
			  p, 
			  block_sz,
d1317 4
a1320 3
    if(ret == 0 && cksum.checksum.length != checksum_sz) {
	krb5_clear_error_string (context);
	free_Checksum(&cksum);
d1324 19
a1342 11
	goto fail;
    memcpy(p + et->confoundersize, cksum.checksum.data, cksum.checksum.length);
    free_Checksum(&cksum);
    ret = _key_schedule(context, &crypto->key, crypto->params);
    if(ret)
	goto fail;
    if (et->flags & F_PADCMS) {
	int i;
	q = p + len + checksum_sz + et->confoundersize;
	for (i = 0; i < padsize; i++)
	    q[i] = padsize;
d1344 6
a1349 6
#ifdef CRYPTO_DEBUG
    krb5_crypto_debug(context, 1, block_sz, crypto->key.key);
#endif
    ret = (*et->encrypt)(context, &crypto->key, p, block_sz, 1, 0, ivec);
    if (ret) {
	memset(p, 0, block_sz);
d1353 4
a1356 28
    result->data = p;
    result->length = block_sz;
    return 0;
 fail:
    memset(p, 0, block_sz);
    free(p);
    return ret;
}

static krb5_error_code
encrypt_internal_special(krb5_context context,
			 krb5_crypto crypto,
			 int usage,
			 void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
{
    struct encryption_type *et = crypto->et;
    size_t cksum_sz = CHECKSUMSIZE(et->checksum);
    size_t sz = len + cksum_sz + et->confoundersize;
    char *tmp, *p;
    krb5_error_code ret;

    tmp = malloc (sz);
    if (tmp == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
d1358 2
a1359 7
    p = tmp;
    memset (p, 0, cksum_sz);
    p += cksum_sz;
    krb5_generate_random_block(p, et->confoundersize);
    p += et->confoundersize;
    memcpy (p, data, len);
    ret = (*et->encrypt)(context, &crypto->key, tmp, sz, TRUE, usage, ivec);
d1361 1
a1361 2
	memset(tmp, 0, sz);
	free(tmp);
d1364 19
a1382 3
    result->data   = tmp;
    result->length = sz;
    return 0;
d1385 28
a1412 8
static krb5_error_code
decrypt_internal_derived(krb5_context context,
			 krb5_crypto crypto,
			 unsigned usage,
			 void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
d1414 2
a1415 1
    size_t checksum_sz;
d1417 1
a1417 1
    unsigned char *p;
d1419 7
a1425 8
    struct key_data *dkey;
    struct encryption_type *et = crypto->et;
    unsigned long l;
    
    checksum_sz = CHECKSUMSIZE(et->keyed_checksum);
    if (len < checksum_sz) {
	krb5_clear_error_string (context);
	return EINVAL;		/* XXX - better error code? */
d1428 11
a1438 2
    if (((len - checksum_sz) % et->padsize) != 0) {
	krb5_clear_error_string(context);
d1440 8
d1450 2
a1451 3
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter than "
				  "checksum + confounder");
d1455 4
a1458 3
    p = malloc(len);
    if(len != 0 && p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d1460 9
a1469 3
    memcpy(p, data, len);

    len -= checksum_sz;
d1476 1
a1476 1
    ret = _key_schedule(context, dkey, crypto->params);
d1481 1
a1481 3
#ifdef CRYPTO_DEBUG
    krb5_crypto_debug(context, 0, len, dkey->key);
#endif
d1488 35
a1522 2
    cksum.checksum.data   = p + len;
    cksum.checksum.length = checksum_sz;
d1531 2
a1532 14
    if(ret) {
	free(p);
	return ret;
    }
    l = len - et->confoundersize;
    memmove(p, p + et->confoundersize, l);
    result->data = realloc(p, l);
    if(result->data == NULL) {
	free(p);
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
    }
    result->length = l;
    return 0;
d1535 21
a1555 7
static krb5_error_code
decrypt_internal(krb5_context context,
		 krb5_crypto crypto,
		 void *data,
		 size_t len,
		 krb5_data *result,
		 void *ivec)
d1557 2
d1560 11
a1570 7
    unsigned char *p;
    Checksum cksum;
    size_t checksum_sz, l;
    struct encryption_type *et = crypto->et;
    
    if ((len % et->padsize) != 0) {
	krb5_clear_error_string(context);
d1572 7
d1581 1
a1581 1
    checksum_sz = CHECKSUMSIZE(et->checksum);
d1583 6
a1588 4
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
d1591 3
a1593 10
    p = malloc(len);
    if(len != 0 && p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
    }
    memcpy(p, data, len);
    
    ret = _key_schedule(context, &crypto->key, crypto->params);
    if(ret) {
	free(p);
d1595 9
d1605 3
a1607 16
#ifdef CRYPTO_DEBUG
    krb5_crypto_debug(context, 0, len, crypto->key.key);
#endif
    ret = (*et->encrypt)(context, &crypto->key, p, len, 0, 0, ivec);
    if (ret) {
	free(p);
	return ret;
    }
    ret = krb5_data_copy(&cksum.checksum, p + et->confoundersize, checksum_sz);
    if(ret) {
 	free(p);
 	return ret;
    }
    memset(p + et->confoundersize, 0, checksum_sz);
    cksum.cksumtype = CHECKSUMTYPE(et->checksum);
    ret = verify_checksum(context, NULL, 0, p, len, &cksum);
d1609 1
a1609 13
    if(ret) {
	free(p);
	return ret;
    }
    l = len - et->confoundersize - checksum_sz;
    memmove(p, p + et->confoundersize + checksum_sz, l);
    result->data = realloc(p, l);
    if(result->data == NULL) {
	free(p);
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
    }
    result->length = l;
d1613 16
a1628 2
static krb5_error_code
decrypt_internal_special(krb5_context context,
d1630 4
a1633 5
			 int usage,
			 void *data,
			 size_t len,
			 krb5_data *result,
			 void *ivec)
d1635 3
a1637 4
    struct encryption_type *et = crypto->et;
    size_t cksum_sz = CHECKSUMSIZE(et->checksum);
    size_t sz = len - cksum_sz - et->confoundersize;
    unsigned char *p;
d1639 3
d1643 7
a1649 2
    if ((len % et->padsize) != 0) {
	krb5_clear_error_string(context);
d1651 7
d1660 8
a1667 4
    if (len < cksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
d1670 23
a1692 4
    p = malloc (len);
    if (p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
d1694 27
a1720 6
    memcpy(p, data, len);
    
    ret = (*et->encrypt)(context, &crypto->key, p, len, FALSE, usage, ivec);
    if (ret) {
	free(p);
	return ret;
d1722 14
d1737 6
a1742 6
    memmove (p, p + cksum_sz + et->confoundersize, sz);
    result->data = realloc(p, sz);
    if(result->data == NULL) {
	free(p);
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
a1743 1
    result->length = sz;
d1748 1
a1748 1
krb5_error_code KRB5_LIB_FUNCTION
d1752 1
a1752 1
		  void *data,
d1758 1
a1758 1
	return encrypt_internal_derived(context, crypto, usage, 
d1767 1
a1767 1
krb5_error_code KRB5_LIB_FUNCTION
d1771 1
a1771 1
	     void *data,
d1778 1
a1778 1
krb5_error_code KRB5_LIB_FUNCTION
d1796 1
a1796 1
krb5_error_code KRB5_LIB_FUNCTION
d1806 1
a1806 1
	return decrypt_internal_derived(context, crypto, usage, 
d1815 1
a1815 1
krb5_error_code KRB5_LIB_FUNCTION
d1827 6
a1832 118
krb5_error_code KRB5_LIB_FUNCTION
krb5_decrypt_EncryptedData(krb5_context context,
			   krb5_crypto crypto,
			   unsigned usage,
			   const EncryptedData *e,
			   krb5_data *result)
{
    return krb5_decrypt(context, crypto, usage, 
			e->cipher.data, e->cipher.length, result);
}

/************************************************************
 *                                                          *
 ************************************************************/

#ifdef HAVE_OPENSSL
#include <openssl/rand.h>

/* From openssl/crypto/rand/rand_lcl.h */
#define ENTROPY_NEEDED 20
static int
seed_something(void)
{
    char buf[1024], seedfile[256];

    /* If there is a seed file, load it. But such a file cannot be trusted,
       so use 0 for the entropy estimate */
    if (RAND_file_name(seedfile, sizeof(seedfile))) {
	int fd;
	fd = open(seedfile, O_RDONLY);
	if (fd >= 0) {
	    ssize_t ret;
	    ret = read(fd, buf, sizeof(buf));
	    if (ret > 0)
		RAND_add(buf, ret, 0.0);
	    close(fd);
	} else
	    seedfile[0] = '\0';
    } else
	seedfile[0] = '\0';

    /* Calling RAND_status() will try to use /dev/urandom if it exists so
       we do not have to deal with it. */
    if (RAND_status() != 1) {
	krb5_context context;
	const char *p;

	/* Try using egd */
	if (!krb5_init_context(&context)) {
	    p = krb5_config_get_string(context, NULL, "libdefaults",
		"egd_socket", NULL);
	    if (p != NULL)
		RAND_egd_bytes(p, ENTROPY_NEEDED);
	    krb5_free_context(context);
	}
    }
    
    if (RAND_status() == 1)	{
	/* Update the seed file */
	if (seedfile[0])
	    RAND_write_file(seedfile);

	return 0;
    } else
	return -1;
}

void KRB5_LIB_FUNCTION
krb5_generate_random_block(void *buf, size_t len)
{
    static int rng_initialized = 0;
    
    HEIMDAL_MUTEX_lock(&crypto_mutex);
    if (!rng_initialized) {
	if (seed_something())
	    krb5_abortx(NULL, "Fatal: could not seed the random number generator");
	
	rng_initialized = 1;
    }
    HEIMDAL_MUTEX_unlock(&crypto_mutex);
    RAND_bytes(buf, len);
}

#else

void KRB5_LIB_FUNCTION
krb5_generate_random_block(void *buf, size_t len)
{
    DES_cblock key, out;
    static DES_cblock counter;
    static DES_key_schedule schedule;
    int i;
    static int initialized = 0;

    HEIMDAL_MUTEX_lock(&crypto_mutex);
    if(!initialized) {
	DES_new_random_key(&key);
	DES_set_key(&key, &schedule);
	memset(&key, 0, sizeof(key));
	DES_new_random_key(&counter);
	initialized = 1;
    }
    HEIMDAL_MUTEX_unlock(&crypto_mutex);
    while(len > 0) {
	DES_ecb_encrypt(&counter, &out, &schedule, DES_ENCRYPT);
	for(i = 7; i >=0; i--)
	    if(counter[i]++)
		break;
	memcpy(buf, out, min(len, sizeof(out)));
	len -= min(len, sizeof(out));
	buf = (char*)buf + sizeof(out);
    }
}
#endif

static void
DES3_postproc(krb5_context context,
	      unsigned char *k, size_t len, struct key_data *key)
d1834 3
a1836 1
    DES3_random_to_key(context, key->key, k, len);
d1838 3
a1840 5
    if (key->schedule) {
	krb5_free_data(context, key->schedule);
	key->schedule = NULL;
    }
}
d1842 6
a1847 6
static krb5_error_code
derive_key(krb5_context context,
	   struct encryption_type *et,
	   struct key_data *key,
	   const void *constant,
	   size_t len)
d1849 1
a1849 1
    unsigned char *k;
d1852 3
a1854 5
    
    struct key_type *kt = et->keytype;
    /* since RC2 is only the weird crypto alg with parameter and this
     * function not defined with work with RC2, this is ok */
    ret = _key_schedule(context, key, NULL);
d1857 1
a1857 2
    if(et->blocksize * 8 < kt->bits || 
       len != et->blocksize) {
d1861 8
a1868 2
	    krb5_set_error_string(context, "malloc: out of memory");
	    return ENOMEM;
d1870 1
a1870 1
	_krb5_n_fold(constant, len, k, et->blocksize);
d1873 1
a1873 1
		memcpy(k + i * et->blocksize, 
d1885 3
a1887 2
	    krb5_set_error_string(context, "malloc: out of memory");
	    return ENOMEM;
d1894 3
a1896 2
	    krb5_set_error_string(context, "malloc: out of memory");
	    return ENOMEM;
d1898 1
a1898 1
	_krb5_n_fold(c, len, k, res_len);
d1900 4
d1905 1
a1905 1
    
d1908 2
a1909 2
    case KEYTYPE_DES3:
	DES3_postproc(context, k, nblocks * et->blocksize, key);
d1911 2
a1912 2
    case KEYTYPE_AES128:
    case KEYTYPE_AES256:
a1915 3
	krb5_set_error_string(context,
			      "derive_key() called with unknown keytype (%u)", 
			      kt->type);
d1917 3
d1922 1
d1924 1
a1924 1
	krb5_free_data(context, key->schedule);
d1927 4
a1930 2
    memset(k, 0, nblocks * et->blocksize);
    free(k);
d1934 1
a1934 1
static struct key_data *
d1937 1
a1937 1
    struct key_usage *d = crypto->key_usage;
d1948 1
a1948 1
krb5_error_code KRB5_LIB_FUNCTION
d1957 2
a1958 2
    struct encryption_type *et;
    struct key_data d;
d1960 3
a1962 1
    et = _find_enctype (etype);
d1964 1
a1964 3
	krb5_set_error_string(context, "encryption type %d not supported",
			      etype);
	return KRB5_PROG_ETYPE_NOSUPP;
d1967 1
a1967 1
    ret = krb5_copy_keyblock(context, key, derived_key);
a1970 1
    d.key = *derived_key;
d1972 4
a1975 4
    ret = derive_key(context, et, &d, constant, constant_len);
    if (ret)
	return ret;
    ret = krb5_copy_keyblock(context, d.key, derived_key);
d1980 4
a1983 4
_get_derived_key(krb5_context context, 
		 krb5_crypto crypto, 
		 unsigned usage, 
		 struct key_data **key)
d1986 1
a1986 1
    struct key_data *d;
d1996 1
a1996 1
	krb5_set_error_string(context, "malloc: out of memory");
d2001 1
a2001 1
    derive_key(context, crypto->et, d, constant, sizeof(constant));
d2006 17
d2024 1
a2024 1
krb5_error_code KRB5_LIB_FUNCTION
d2033 1
a2033 1
	krb5_set_error_string(context, "malloc: out of memory");
d2038 1
a2038 1
    (*crypto)->et = _find_enctype(etype);
d2042 1
a2042 3
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
d2044 1
a2044 1
    if((*crypto)->et->keytype->minsize > key->keyvalue.length) {
d2047 2
a2048 1
	krb5_set_error_string (context, "encryption key has bad length");
a2059 1
    (*crypto)->params = NULL;
d2064 13
a2076 1
free_key_data(krb5_context context, struct key_data *key)
d2080 2
a2081 2
	memset(key->schedule->data, 0, key->schedule->length);
	krb5_free_data(context, key->schedule);
d2086 2
a2087 1
free_key_usage(krb5_context context, struct key_usage *ku)
d2089 1
a2089 1
    free_key_data(context, &ku->key);
d2092 12
a2103 1
krb5_error_code KRB5_LIB_FUNCTION
d2108 1
a2108 1
    
d2110 1
a2110 1
	free_key_usage(context, &crypto->key_usage[i]);
d2112 1
a2112 2
    free_key_data(context, &crypto->key);
    free(crypto->params);
d2117 11
a2127 67
krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_get_params(krb5_context context,
		       const krb5_crypto crypto,
		       const krb5_data *params,
		       krb5_data *ivec)
{
    krb5_error_code (*gp)(krb5_context, const krb5_data *,void **,krb5_data *);
    krb5_error_code ret;

    gp = crypto->et->keytype->get_params;
    if (gp) {
	if (crypto->params) {
	    krb5_set_error_string(context,
				  "krb5_crypto_get_params called "
				  "more than once");
	    return KRB5_PROG_ETYPE_NOSUPP;
	}
	ret = (*gp)(context, params, &crypto->params, ivec);
    } else {
	size_t size;
	if (ivec == NULL)
	    return 0;
	ret = decode_CBCParameter(params->data, params->length, ivec, &size);
    }
    if (ret)
	return ret;
    if (ivec->length < crypto->et->blocksize) {
	krb5_data_free(ivec);
	krb5_set_error_string(context, "%s IV of wrong size", 
			      crypto->et->name);
	return ASN1_PARSE_ERROR;
    }
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_set_params(krb5_context context,
		       const krb5_crypto crypto,
		       const krb5_data *ivec,
		       krb5_data *params)
{
    krb5_error_code (*sp)(krb5_context, const void *,
			  const krb5_data *, krb5_data *);
    krb5_error_code ret;

    sp = crypto->et->keytype->set_params;
    if (sp == NULL) {
	size_t size;
	if (ivec == NULL)
	    return 0;
	ASN1_MALLOC_ENCODE(CBCParameter, params->data, params->length,
			   ivec, &size, ret);
	if (ret)
	    return ret;
	if (size != params->length)
	    krb5_abortx(context, "Internal asn1 encoder failure");
	return 0;
    }
    if (crypto->params) {
	krb5_set_error_string(context,
			      "krb5_crypto_set_params called "
			      "more than once");
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    return (*sp)(context, crypto->params, ivec, params);
}

d2129 1
a2129 1
krb5_error_code KRB5_LIB_FUNCTION
d2138 13
a2150 1
krb5_error_code KRB5_LIB_FUNCTION
d2156 1
a2156 1
     return 0;
d2159 13
a2171 1
krb5_error_code KRB5_LIB_FUNCTION
d2174 1
a2174 1
                       size_t *padsize)      
d2180 13
a2192 1
krb5_error_code KRB5_LIB_FUNCTION
d2201 13
a2213 1
krb5_error_code KRB5_LIB_FUNCTION
d2217 1
a2217 1
    struct encryption_type *et = _find_enctype(enctype);
d2220 3
a2222 2
	    krb5_set_error_string (context, "encryption type %d not supported",
				   enctype);
d2229 14
a2242 6
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_derived(krb5_context context,
			   const void *str,
			   size_t len,
			   krb5_enctype etype,
			   krb5_keyblock *key)
d2244 1
a2244 6
    struct encryption_type *et = _find_enctype(etype);
    krb5_error_code ret;
    struct key_data kd;
    size_t keylen;
    u_char *tmp;

d2246 4
a2249 2
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
d2252 20
a2271 1
    keylen = et->keytype->bits / 8;
d2273 8
a2280 30
    ALLOC(kd.key, 1);
    if(kd.key == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
	return ENOMEM;
    }
    ret = krb5_data_alloc(&kd.key->keyvalue, et->keytype->size);
    if(ret) {
	free(kd.key);
	return ret;
    }
    kd.key->keytype = etype;
    tmp = malloc (keylen);
    if(tmp == NULL) {
	krb5_free_keyblock(context, kd.key);
	krb5_set_error_string (context, "malloc: out of memory");
	return ENOMEM;
    }
    _krb5_n_fold(str, len, tmp, keylen);
    kd.schedule = NULL;
    DES3_postproc (context, tmp, keylen, &kd); /* XXX */
    memset(tmp, 0, keylen);
    free(tmp);
    ret = derive_key(context, 
		     et,
		     &kd,
		     "kerberos", /* XXX well known constant */
		     strlen("kerberos"));
    ret = krb5_copy_keyblock_contents(context, kd.key, key);
    free_key_data(context, &kd);
    return ret;
d2288 1
a2288 1
    struct encryption_type *et = crypto->et;
d2303 1
a2303 1
    struct encryption_type *et = crypto->et;
d2320 1
a2320 1
size_t
d2331 62
a2392 1
krb5_error_code KRB5_LIB_FUNCTION
d2400 1
a2400 1
    struct encryption_type *et = _find_enctype(type);
d2402 3
a2404 2
	krb5_set_error_string(context, "encryption type %d not supported",
			      type);
d2408 5
a2412 3
	krb5_set_error_string(context, "encryption key %s needs %d bytes "
			      "of random to make an encryption key out of it",
			      et->name, (int)et->keytype->size);
d2416 1
a2416 1
    if(ret) 
a2426 1
#ifdef CRYPTO_DEBUG
d2428 16
a2443 12
static krb5_error_code
krb5_get_keyid(krb5_context context,
	       krb5_keyblock *key,
	       u_int32_t *keyid)
{
    MD5_CTX md5;
    unsigned char tmp[16];

    MD5_Init (&md5);
    MD5_Update (&md5, key->keyvalue.data, key->keyvalue.length);
    MD5_Final (tmp, &md5);
    *keyid = (tmp[12] << 24) | (tmp[13] << 16) | (tmp[14] << 8) | tmp[15];
d2447 5
a2451 5
static void
krb5_crypto_debug(krb5_context context,
		  int encrypt,
		  size_t len,
		  krb5_keyblock *key)
d2453 20
a2472 17
    u_int32_t keyid;
    char *kt;
    krb5_get_keyid(context, key, &keyid);
    krb5_enctype_to_string(context, key->keytype, &kt);
    krb5_warnx(context, "%s %lu bytes with key-id %#x (%s)", 
	       encrypt ? "encrypting" : "decrypting",
	       (unsigned long)len,
	       keyid,
	       kt);
    free(kt);
}

#endif /* CRYPTO_DEBUG */

#if 0
int
main()
a2473 8
#if 0
    int i;
    krb5_context context;
    krb5_crypto crypto;
    struct key_data *d;
    krb5_keyblock key;
    char constant[4];
    unsigned usage = ENCRYPTION_USAGE(3);
d2475 19
d2495 4
a2498 3
    ret = krb5_init_context(&context);
    if (ret)
	errx (1, "krb5_init_context failed: %d", ret);
d2500 3
a2502 5
    key.keytype = ETYPE_NEW_DES3_CBC_SHA1;
    key.keyvalue.data = "\xb3\x85\x58\x94\xd9\xdc\x7c\xc8"
	"\x25\xe9\x85\xab\x3e\xb5\xfb\x0e"
	"\xc8\xdf\xab\x26\x86\x64\x15\x25";
    key.keyvalue.length = 24;
d2504 10
a2513 1
    krb5_crypto_init(context, &key, 0, &crypto);
d2515 4
a2518 6
    d = _new_derived_key(crypto, usage);
    if(d == NULL)
	return ENOMEM;
    krb5_copy_keyblock(context, crypto->key.key, &d->key);
    _krb5_put_int(constant, usage, 4);
    derive_key(context, crypto->et, d, constant, sizeof(constant));
d2520 27
a2546 6
#else
    int i;
    krb5_context context;
    krb5_crypto crypto;
    struct key_data *d;
    krb5_keyblock key;
d2548 4
a2551 1
    Checksum res;
d2553 3
a2555 1
    char *data = "what do ya want for nothing?";
d2557 1
a2557 1
    ret = krb5_init_context(&context);
d2559 43
a2601 1
	errx (1, "krb5_init_context failed: %d", ret);
d2603 11
a2613 12
    key.keytype = ETYPE_NEW_DES3_CBC_SHA1;
    key.keyvalue.data = "Jefe";
    /* "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
       "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"; */
    key.keyvalue.length = 4;

    d = calloc(1, sizeof(*d));

    d->key = &key;
    res.checksum.length = 20;
    res.checksum.data = malloc(res.checksum.length);
    SP_HMAC_SHA1_checksum(context, d, data, 28, &res);
d2615 14
a2629 1
#endif
d2631 20
a2650 1
#endif
@


1.13
log
@spelling fixes from Richard Toohey

ok deraadt@@
@
text
@d508 1
a508 1
    memset(x, 0, sizeof(x));
@


1.12
log
@- add another check in decrypt_internal_special()

prompted by miod@@
ok miod@@ deraadt@@
@
text
@d2381 1
a2381 1
     * then at least one blocksize.
d3455 2
a3456 2
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
@


1.11
log
@- merge a fix from heimdal's 2010-03-21 advisory to add more paranoid
checking for underruns when decrypting packets.

ok beck@@ "sure" deraadt@@
@
text
@d3606 6
@


1.10
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d3454 6
d3534 7
@


1.10.12.1
log
@MFC:
-----------------------------------------------
- merge a fix from heimdal's 2010-03-21 advisory to add more paranoid
checking for underruns when decrypting packets.

ok beck@@ "sure" deraadt@@

- add another check in decrypt_internal_special()

prompted by miod@@
ok miod@@ deraadt@@
-----------------------------------------------

ok sthen@@
@
text
@a3453 6
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
    }

a3527 7

    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
    }

a3589 6
	return KRB5_BAD_MSIZE;
    }

    if (len < cksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
@


1.10.14.1
log
@MFC:
-----------------------------------------------
- merge a fix from heimdal's 2010-03-21 advisory to add more paranoid
checking for underruns when decrypting packets.

ok beck@@ "sure" deraadt@@

- add another check in decrypt_internal_special()

prompted by miod@@
ok miod@@ deraadt@@
-----------------------------------------------

ok sthen@@
@
text
@a3453 6
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
    }

a3527 7

    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
    }

a3589 6
	return KRB5_BAD_MSIZE;
    }

    if (len < cksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
@


1.10.10.1
log
@MFC:
-----------------------------------------------
- merge a fix from heimdal's 2010-03-21 advisory to add more paranoid
checking for underruns when decrypting packets.

ok beck@@ "sure" deraadt@@

- add another check in decrypt_internal_special()

prompted by miod@@
ok miod@@ deraadt@@
-----------------------------------------------

ok sthen@@
@
text
@a3453 6
    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
    }

a3527 7

    if (len < checksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
	return KRB5_BAD_MSIZE;
    }

a3589 6
	return KRB5_BAD_MSIZE;
    }

    if (len < cksum_sz + et->confoundersize) {
	krb5_set_error_string(context, "Encrypted data shorter then "
				  "checksum + confunder");
@


1.9
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d4179 1
a4179 1
    size_t keylen = et->keytype->bits / 8;
d4187 2
@


1.8
log
@Get rid of an lvalue cast that was making lint angry.
OK otto, deraadt
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.73.2.4 2004/03/06 16:38:00 lha Exp $");
d58 1
d61 2
d72 2
d87 1
d93 1
a93 1
    void (*schedule)(krb5_context, struct key_data *);
d95 5
d123 1
d162 2
a163 1
static krb5_error_code usage2arcfour (krb5_context, int *);
d169 3
d176 1
a176 1
    des_cblock *k = key->keyvalue.data;
d178 3
a180 3
	krb5_generate_random_block(k, sizeof(des_cblock));
	des_set_odd_parity(k);
    } while(des_is_weak_key(k));
d185 2
a186 1
	     struct key_data *key)
d188 1
a188 1
    des_set_key(key->key->keyvalue.data, key->schedule->data);
d192 1
a192 1
DES_string_to_key_int(unsigned char *data, size_t length, des_cblock *key)
d194 1
a194 1
    des_key_schedule schedule;
d213 8
a220 2
    des_set_odd_parity(key);
    if(des_is_weak_key(key))
a221 4
    des_set_key(key, schedule);
    des_cbc_cksum((void*)data, key, length, schedule, key);
    memset(schedule, 0, sizeof(schedule));
    des_set_odd_parity(key);
d234 1
a234 1
    des_cblock tmp;
d265 1
a265 1
			    des_cblock *key)
d278 1
a278 1
    memcpy(key, crypt(password, "p1") + 2, sizeof(des_cblock));
d283 1
a283 1
    for (i = 0; i < sizeof(des_cblock); i++)
d285 1
a285 1
    des_set_odd_parity (key);
d294 1
a294 1
				 des_cblock *key)
d296 3
a298 3
    des_key_schedule schedule;
    des_cblock temp_key;
    des_cblock ivec;
d314 3
a316 3
    des_set_odd_parity (&temp_key);
    des_set_key (&temp_key, schedule);
    des_cbc_cksum ((des_cblock *) password, &ivec, passlen, schedule, &ivec);
d319 3
a321 4
    des_set_odd_parity (&temp_key);
    des_set_key (&temp_key, schedule);
    des_cbc_cksum ((des_cblock *) password, (des_cblock *) key, passlen,
		   schedule, &ivec);
d327 1
a327 1
    des_set_odd_parity (key);
d338 1
a338 1
    des_cblock tmp;
d350 17
d370 1
a370 1
    des_cblock *k = key->keyvalue.data;
d372 7
a378 7
	krb5_generate_random_block(k, 3 * sizeof(des_cblock));
	des_set_odd_parity(&k[0]);
	des_set_odd_parity(&k[1]);
	des_set_odd_parity(&k[2]);
    } while(des_is_weak_key(&k[0]) ||
	    des_is_weak_key(&k[1]) ||
	    des_is_weak_key(&k[2]));
d383 2
a384 1
	      struct key_data *key)
d386 5
a390 5
    des_cblock *k = key->key->keyvalue.data;
    des_key_schedule *s = key->schedule->data;
    des_set_key(&k[0], s[0]);
    des_set_key(&k[1], s[1]);
    des_set_key(&k[2], s[2]);
d398 1
a398 1
xor (des_cblock *key, const unsigned char *b)
d422 1
a422 1
    des_cblock keys[3];
d433 2
a434 2
	des_cblock ivec;
	des_key_schedule s[3];
d441 2
a442 2
	    des_set_odd_parity(keys + i);
	    if(des_is_weak_key(keys + i))
d444 1
a444 1
	    des_set_key(keys + i, s[i]);
d447 3
a449 3
	des_ede3_cbc_encrypt((des_cblock *) tmp,
			     (des_cblock *) tmp, sizeof(tmp), 
			     s[0], s[1], s[2], &ivec, DES_ENCRYPT);
d454 2
a455 2
	    des_set_odd_parity(keys + i);
	    if(des_is_weak_key(keys + i))
d497 34
d536 3
a538 8
ARCFOUR_random_key(krb5_context context, krb5_keyblock *key)
{
    krb5_generate_random_block (key->keyvalue.data,
				key->keyvalue.length);
}

static void
ARCFOUR_schedule(krb5_context context, struct key_data *kd)
a576 1
#ifdef ENABLE_AES
d583 4
a586 4
krb5_error_code
krb5_PKCS5_PBKDF2(krb5_context context, krb5_cksumtype cktype,
		  krb5_data password, krb5_salt salt, u_int32_t iter,
		  krb5_keytype type, krb5_keyblock *key)
d689 2
d705 1
a705 1
	iter = 45056 - 1;
d718 2
a719 2
    ret = krb5_PKCS5_PBKDF2(context, CKSUMTYPE_SHA1, password, salt, 
			    iter, enctype, key);
d727 2
a728 4

    if (ret) {
	krb5_data_free(&key->keyvalue);
    } else {
d736 5
d742 3
a744 1
AES_schedule(krb5_context context, struct key_data *kd)
d746 1
a746 1
    AES_KEY *key = kd->schedule->data;
d748 112
a859 3
    
    AES_set_encrypt_key(kd->key->keyvalue.data, bits, &key[0]);
    AES_set_decrypt_key(kd->key->keyvalue.data, bits, &key[1]);
d862 1
d867 40
a906 1
extern struct salt_type AES_salt[];
d908 8
a915 1
#endif /* ENABLE_AES */
d917 3
a919 2
extern struct salt_type des_salt[], 
    des3_salt[], des3_salt_derived[], arcfour_salt[];
d921 1
a921 1
struct key_type keytype_null = {
d927 1
d933 1
a933 1
struct key_type keytype_des = {
d937 3
a939 2
    sizeof(des_cblock),
    sizeof(des_key_schedule),
d942 2
a943 1
    des_salt
d946 1
a946 1
struct key_type keytype_des3 = {
d950 3
a952 2
    3 * sizeof(des_cblock), 
    3 * sizeof(des_key_schedule), 
d955 2
a956 1
    des3_salt
d959 1
a959 1
struct key_type keytype_des3_derived = {
d963 3
a965 2
    3 * sizeof(des_cblock),
    3 * sizeof(des_key_schedule), 
d968 2
a969 1
    des3_salt_derived
d972 1
a972 2
#ifdef ENABLE_AES
struct key_type keytype_aes128 = {
d977 2
a978 1
    sizeof(AES_KEY) * 2,
d984 13
a996 1
struct key_type keytype_aes256 = {
d1000 3
a1002 2
    16,
    sizeof(AES_KEY) * 2,
a1006 1
#endif /* ENABLE_AES */
d1008 1
a1008 1
struct key_type keytype_arcfour = {
d1013 1
d1015 1
a1015 1
    ARCFOUR_random_key,
d1020 16
a1035 1
struct key_type *keytypes[] = {
a1039 1
#ifdef ENABLE_AES
d1041 1
d1043 1
a1043 1
#endif /* ENABLE_AES */
d1060 1
a1060 53
struct salt_type des_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	krb5_DES_string_to_key
    },
    {
	KRB5_AFS3_SALT,
	"afs3-salt",
	DES_AFS3_string_to_key
    },
    { 0 }
};

struct salt_type des3_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	DES3_string_to_key
    },
    { 0 }
};

struct salt_type des3_salt_derived[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	DES3_string_to_key_derived
    },
    { 0 }
};

#ifdef ENABLE_AES
struct salt_type AES_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	AES_string_to_key
    },
    { 0 }
};
#endif /* ENABLE_AES */

struct salt_type arcfour_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	ARCFOUR_string_to_key
    },
    { 0 }
};

krb5_error_code
d1089 1
a1089 1
krb5_error_code
d1114 1
a1114 1
krb5_error_code
d1143 1
a1143 1
krb5_error_code
d1151 1
a1151 1
krb5_error_code
d1169 1
a1169 1
krb5_error_code
d1182 1
a1182 1
krb5_error_code
d1201 1
a1201 1
krb5_error_code
d1231 1
a1231 1
krb5_error_code
d1244 16
a1259 1
krb5_error_code
d1277 1
a1277 1
krb5_error_code
d1292 1
a1292 1
krb5_error_code
d1307 1
a1307 1
krb5_error_code
d1333 2
a1334 1
	      struct key_data *key)
d1355 1
a1355 1
    (*kt->schedule)(context, key);
d1415 1
a1415 1
    des_cblock ivec;
d1424 2
a1425 2
    des_cbc_encrypt((des_cblock *) p, 
		    (des_cblock *) p, 
d1443 1
a1443 1
    des_cblock ivec;
d1447 1
a1447 1
    des_cbc_encrypt(C->checksum.data,
d1490 1
a1490 1
    des_cblock ivec;
d1499 2
a1500 2
    des_cbc_encrypt((des_cblock *) p, 
		    (des_cblock *) p, 
d1518 2
a1519 2
    des_cblock ivec;
    des_key_schedule *sched = key->schedule->data;
d1523 1
a1523 1
    des_cbc_encrypt(C->checksum.data, 
d1526 1
a1526 1
		    sched[0],
d1551 1
a1551 1
    des_cblock ivec;
d1553 1
a1553 1
    des_key_schedule *sched = key->schedule->data;
d1561 2
a1562 2
    des_ede3_cbc_encrypt((des_cblock *)p, 
			 (des_cblock *)p, 
d1564 1
a1564 1
			 sched[0], sched[1], sched[2],
d1580 2
a1581 2
    des_cblock ivec;
    des_key_schedule *sched = key->schedule->data;
d1585 1
a1585 1
    des_ede3_cbc_encrypt(C->checksum.data, 
d1588 1
a1588 1
			 sched[0], sched[1], sched[2],
d1677 1
a1677 1
krb5_error_code
d1809 1
a1809 1
struct checksum_type checksum_none = {
d1814 1
a1814 1
    0, 
d1818 1
a1818 1
struct checksum_type checksum_crc32 = {
d1827 1
a1827 1
struct checksum_type checksum_rsa_md4 = {
d1836 1
a1836 1
struct checksum_type checksum_rsa_md4_des = {
d1846 1
a1846 1
struct checksum_type checksum_des_mac = { 
d1854 1
a1854 1
struct checksum_type checksum_des_mac_k = {
d1862 1
a1862 1
struct checksum_type checksum_rsa_md4_des_k = {
d1872 1
a1872 1
struct checksum_type checksum_rsa_md5 = {
d1881 1
a1881 1
struct checksum_type checksum_rsa_md5_des = {
d1890 1
a1890 1
struct checksum_type checksum_rsa_md5_des3 = {
d1899 1
a1899 1
struct checksum_type checksum_sha1 = {
d1908 1
a1908 1
struct checksum_type checksum_hmac_sha1_des3 = {
d1918 1
a1918 2
#ifdef ENABLE_AES
struct checksum_type checksum_hmac_sha1_aes128 = {
d1928 1
a1928 1
struct checksum_type checksum_hmac_sha1_aes256 = {
a1936 1
#endif /* ENABLE_AES */
d1938 1
a1938 1
struct checksum_type checksum_hmac_md5 = {
d1948 1
a1948 1
struct checksum_type checksum_hmac_md5_enc = {
d1958 1
a1958 1
struct checksum_type *checksum_types[] = {
a1972 1
#ifdef ENABLE_AES
a1974 1
#endif
d2019 1
a2019 1
	ret = _key_schedule(context, *key);
d2036 4
d2064 1
a2064 1
krb5_error_code
d2116 1
a2116 1
    if (ct == NULL) {
d2154 1
a2154 1
krb5_error_code
d2182 25
a2206 1
krb5_error_code
d2221 1
a2221 1
krb5_boolean
d2227 3
a2229 2
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
d2235 1
a2235 1
krb5_boolean
d2241 3
a2243 2
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
d2249 15
d2289 2
a2290 2
    des_cblock ivec;
    des_key_schedule *s = key->schedule->data;
d2292 1
a2292 1
    des_cbc_encrypt(data, data, len, *s, &ivec, encrypt);
d2305 2
a2306 2
    des_cblock ivec;
    des_key_schedule *s = key->schedule->data;
d2308 1
a2308 1
    des_cbc_encrypt(data, data, len, *s, &ivec, encrypt);
d2321 2
a2322 2
    des_cblock local_ivec;
    des_key_schedule *s = key->schedule->data;
d2327 1
a2327 1
    des_ede3_cbc_encrypt(data, data, len, s[0], s[1], s[2], ivec, encrypt);
d2340 1
a2340 1
    des_cblock ivec;
d2342 1
a2342 1
    des_key_schedule *s = key->schedule->data;
d2345 1
a2345 1
    des_cfb64_encrypt(data, data, len, *s, &ivec, &num, encrypt);
d2358 2
a2359 2
    des_cblock ivec;
    des_key_schedule *s = key->schedule->data;
d2362 1
a2362 1
    des_pcbc_encrypt(data, data, len, *s, &ivec, encrypt);
a2365 2
#ifdef ENABLE_AES

d2370 1
a2370 1
void
d2373 1
a2373 1
		      unsigned char *ivec, const int enc)
d2384 1
a2384 1
    if (enc == AES_ENCRYPT) {
d2404 1
d2407 2
a2408 2
	char tmp2[AES_BLOCK_SIZE];
	char tmp3[AES_BLOCK_SIZE];
d2423 1
d2435 1
d2448 1
a2448 1
    AES_KEY *k = key->schedule->data;
d2450 1
d2453 1
a2453 1
	k = &k[0];
d2455 1
a2455 1
	k = &k[1];
d2474 49
a2522 1
#endif /* ENABLE_AES */
d2535 1
a2535 1
		   int usage,
d2598 1
a2598 1
		   int usage,
d2671 1
a2671 1
usage2arcfour (krb5_context context, int *usage)
d2702 3
a2704 1
    if((ret = usage2arcfour (context, &usage)) != 0)
d2708 1
a2708 1
	return ARCFOUR_subencrypt (context, key, data, len, usage, ivec);
d2710 1
a2710 1
	return ARCFOUR_subdecrypt (context, key, data, len, usage, ivec);
d2721 1
d2728 1
a2728 1
    0,
d2734 1
d2747 1
d2760 1
d2773 1
d2779 1
a2779 1
    /* &checksum_hmac_md5_enc */ NULL,
d2786 1
d2799 1
d2812 1
a2821 1
#ifdef ENABLE_AES
d2825 1
d2832 1
a2832 1
    0,
d2838 1
d2845 1
a2845 1
    0,
d2848 45
a2892 1
#endif /* ENABLE_AES */
d2896 1
d2909 1
d2922 1
d2932 15
d2950 1
d2960 15
a2984 1
#ifdef ENABLE_AES
d2987 3
a2989 1
#endif
d2993 3
a2995 1
    &enctype_des3_cbc_none
d3012 1
a3012 1
krb5_error_code
d3032 1
a3032 1
krb5_error_code
d3048 36
a3083 1
krb5_error_code
d3099 1
a3099 1
krb5_error_code
d3113 1
a3113 1
krb5_error_code
d3149 1
a3149 1
krb5_error_code
d3175 1
a3175 1
krb5_error_code
d3179 30
a3208 1
    return _find_enctype(etype) != NULL;
d3211 1
d3213 1
a3213 1
krb5_boolean
d3291 1
a3291 1
    ret = _key_schedule(context, dkey);
d3318 1
a3318 1
    size_t sz, block_sz, checksum_sz;
d3328 5
d3362 1
a3362 1
    ret = _key_schedule(context, &crypto->key);
d3365 6
d3468 1
a3468 1
    ret = _key_schedule(context, dkey);
d3535 1
a3535 1
    ret = _key_schedule(context, &crypto->key);
d3618 1
a3618 1
krb5_error_code
d3637 1
a3637 1
krb5_error_code
d3648 1
a3648 1
krb5_error_code
d3666 1
a3666 1
krb5_error_code
d3685 1
a3685 1
krb5_error_code
d3697 1
a3697 1
krb5_error_code
a3719 1
    int fd = -1;
d3725 1
d3728 5
a3732 3
	    read(fd, buf, sizeof(buf));
	    /* Use the full buffer anyway */
	    RAND_add(buf, sizeof(buf), 0.0);
d3764 1
a3764 1
void
d3769 1
d3776 1
d3782 1
a3782 1
void
d3785 3
a3787 3
    des_cblock key, out;
    static des_cblock counter;
    static des_key_schedule schedule;
d3791 1
d3793 2
a3794 2
	des_new_random_key(&key);
	des_set_key(&key, schedule);
d3796 2
a3797 1
	des_new_random_key(&counter);
d3799 1
d3801 1
a3801 1
	des_ecb_encrypt(&counter, &out, schedule, DES_ENCRYPT);
d3816 1
a3816 9
    unsigned char x[24];
    int i, j;

    memset(x, 0, sizeof(x));
    for (i = 0; i < 3; ++i) {
	unsigned char foo;

	for (j = 0; j < 7; ++j) {
	    unsigned char b = k[7 * i + j];
a3817 12
	    x[8 * i + j] = b;
	}
	foo = 0;
	for (j = 6; j >= 0; --j) {
	    foo |= k[7 * i + j] & 1;
	    foo <<= 1;
	}
	x[8 * i + 7] = foo;
    }
    k = key->key->keyvalue.data;
    memcpy(k, x, 24);
    memset(x, 0, sizeof(x));
a3821 3
    des_set_odd_parity((des_cblock*)k);
    des_set_odd_parity((des_cblock*)(k + 8));
    des_set_odd_parity((des_cblock*)(k + 16));
d3836 3
a3838 1
    ret = _key_schedule(context, key);
a3883 1
#ifdef ENABLE_AES
a3887 1
#endif /* ENABLE_AES */
d3895 4
d3918 1
a3918 1
krb5_error_code
d3978 1
a3978 1
krb5_error_code
d3993 1
a3993 1
    if((*crypto)->et == NULL) {
d3995 1
d4000 1
a4000 1
    if((*crypto)->et->keytype->size != key->keyvalue.length) {
d4002 1
d4009 1
d4015 1
d4035 1
a4035 1
krb5_error_code
d4045 1
d4050 69
a4118 1
krb5_error_code
d4127 43
a4169 1
krb5_error_code
d4226 1
d4229 1
a4229 1
    res =  et->confoundersize + et->checksum->checksumsize + data_len;
d4245 4
a4248 1
    res += et->checksum->checksumsize;
d4265 32
@


1.7
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d3258 1
a3258 1
	    (const char *)p = krb5_config_get_string(context, NULL, "libdefaults",
@


1.6
log
@-Wall; ok hin@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.73 2003/04/01 16:51:54 lha Exp $");
d142 7
a148 7
static void hmac(krb5_context context,
		 struct checksum_type *cm, 
		 const void *data, 
		 size_t len, 
		 unsigned usage,
		 struct key_data *keyblock,
		 Checksum *result);
d150 1
d598 3
a600 1
	hmac(context, c, data, datalen, 0, &ksign, &result);
d604 4
a607 2
	    hmac(context, c, tmpcksum, result.checksum.length,
		 0, &ksign, &result);
d1393 1
a1393 1
static void
d1407 11
a1430 4
    ipad = malloc(cm->blocksize + len);
    opad = malloc(cm->blocksize + cm->checksumsize);
    memset(ipad, 0x36, cm->blocksize);
    memset(opad, 0x5c, cm->blocksize);
d1446 2
d1450 30
d1491 1
d1496 3
a1498 1
    hmac(context, c, data, len, usage, key, &res);
d1523 1
d1527 3
a1529 1
    hmac(context, c, signature, sizeof(signature), 0, key, &ksign_c);
d1540 3
a1542 1
    hmac(context, c, tmp, sizeof(tmp), 0, &ksign, result);
d1563 1
d1572 3
a1574 1
    hmac(context, c, t, sizeof(t), 0, key, &ksign_c);
d1577 3
a1579 1
    hmac(context, c, data, len, 0, &ksign, result);
d1801 7
a1807 7
do_checksum (krb5_context context,
	     struct checksum_type *ct,
	     krb5_crypto crypto,
	     unsigned usage,
	     void *data,
	     size_t len,
	     Checksum *result)
d1812 1
a1812 1

d1830 15
a1844 8
static krb5_error_code
create_checksum(krb5_context context,
		krb5_crypto crypto,
		unsigned usage, /* not krb5_key_usage */
		krb5_cksumtype type, /* 0 -> pick from crypto */
		void *data,
		size_t len,
		Checksum *result)
d1847 1
d1849 1
a1862 2
    return do_checksum (context, ct, crypto, usage, data, len, result);
}
d1864 8
a1871 12
krb5_error_code
krb5_create_checksum(krb5_context context,
		     krb5_crypto crypto,
		     krb5_key_usage usage,
		     int type,
		     void *data,
		     size_t len,
		     Checksum *result)
{
    return create_checksum(context, crypto, 
			   CHECKSUM_USAGE(usage), 
			   type, data, len, result);
d1889 1
a1889 1
    if(ct == NULL) {
d1935 18
a1952 2
    return verify_checksum(context, crypto, 
			   CHECKSUM_USAGE(usage), data, len, cksum);
d2188 1
a2188 1
	abort();
d2228 1
d2238 3
a2240 1
    hmac(NULL, c, t, sizeof(t), 0, key, &k1_c);
d2253 3
a2255 1
    hmac(NULL, c, cdata + 16, len - 16, 0, &ke, &cksum);
d2263 3
a2265 1
    hmac(NULL, c, data, 16, 0, &ke, &k3_c);
d2292 1
d2302 3
a2304 1
    hmac(NULL, c, t, sizeof(t), 0, key, &k1_c);
d2317 3
a2319 1
    hmac(NULL, c, cdata, 16, 0, &ke, &k3_c);
d2330 3
a2332 1
    hmac(NULL, c, cdata + 16, len - 16, 0, &ke, &cksum);
d2349 1
a2349 1
 * draft-brezak-win2k-krb-rc4-hmac-03.txt
d2356 2
a2357 17
    case KRB5_KU_PA_ENC_TIMESTAMP :
	*usage = 1;
	return 0;
    case KRB5_KU_TICKET :
	*usage = 2;
	return 0;
    case KRB5_KU_AS_REP_ENC_PART :
	*usage = 8;
	return 0;
    case KRB5_KU_TGS_REQ_AUTH_DAT_SESSION :
    case KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY :
    case KRB5_KU_TGS_REQ_AUTH_CKSUM :
    case KRB5_KU_TGS_REQ_AUTH :
	*usage = 7;
	return 0;
    case KRB5_KU_TGS_REP_ENC_PART_SESSION :
    case KRB5_KU_TGS_REP_ENC_PART_SUB_KEY :
d2360 2
a2361 4
    case KRB5_KU_AP_REQ_AUTH_CKSUM :
    case KRB5_KU_AP_REQ_AUTH :
    case KRB5_KU_AP_REQ_ENC_PART :
	*usage = 11;
d2363 4
a2366 1
    case KRB5_KU_KRB_PRIV :
a2368 11
    case KRB5_KU_KRB_CRED :
    case KRB5_KU_KRB_SAFE_CKSUM :
    case KRB5_KU_OTHER_ENCRYPTED :
    case KRB5_KU_OTHER_CKSUM :
    case KRB5_KU_KRB_ERROR :
    case KRB5_KU_AD_KDC_ISSUED :
    case KRB5_KU_MANDATORY_TICKET_EXTENSION :
    case KRB5_KU_AUTH_DATA_TICKET_EXTENSION :
    case KRB5_KU_USAGE_SEAL :
    case KRB5_KU_USAGE_SIGN :
    case KRB5_KU_USAGE_SEQ :
d2370 1
a2370 2
	krb5_set_error_string(context, "unknown arcfour usage type %d", *usage);
	return KRB5_PROG_ETYPE_NOSUPP;
d2798 1
a2800 1
			  et->keyed_checksum->type,
d2867 1
a2869 1
			  et->checksum->type,
d2963 5
d3036 5
d3099 1
a3099 2
    char *cdata = (char *)data;
    char *tmp;
d3102 7
a3108 2
    tmp = malloc (sz);
    if (tmp == NULL) {
d3112 1
d3114 1
a3114 1
    ret = (*et->encrypt)(context, &crypto->key, data, len, FALSE, usage, ivec);
d3116 1
a3116 1
	free(tmp);
d3120 7
a3126 3
    memcpy (tmp, cdata + cksum_sz + et->confoundersize, sz);

    result->data   = tmp;
@


1.5
log
@Merge 0.6rc1
@
text
@d296 1
a296 1
    des_cbc_cksum (password, &ivec, passlen, schedule, &ivec);
d301 2
a302 1
    des_cbc_cksum (password, key, passlen, schedule, &ivec);
d410 2
a411 2
	des_ede3_cbc_encrypt(tmp,
			     tmp, sizeof(tmp), 
d1192 2
a1193 2
    des_cbc_encrypt(p, 
		    p, 
d1267 2
a1268 2
    des_cbc_encrypt(p, 
		    p, 
@


1.4
log
@-Wall -Werror sweep on i386.
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.53 2001/08/22 20:30:29 assar Exp $");
d74 1
a74 1
				     krb5_salt, krb5_keyblock*);
d113 1
d137 13
d156 1
a156 1
DES_random_key(krb5_context context,
d167 1
a167 1
DES_schedule(krb5_context context,
d173 31
d205 1
a205 1
DES_string_to_key(krb5_context context,
d209 1
d212 1
a212 1
    char *s;
d216 1
a216 1
    len = password.length + salt.saltvalue.length + 1;
d218 1
a218 1
    if(s == NULL) {
d224 1
a224 2
    s[len - 1] = '\0';
    des_string_to_key(s, &tmp);
d243 1
a243 1
DES_AFS3_CMU_string_to_key (krb5_data pw,
d258 1
a258 1
    memcpy(key, crypt(password, "#~") + 2, sizeof(des_cblock));
d272 1
a272 1
DES_AFS3_Transarc_string_to_key (krb5_data pw,
d296 1
a296 1
    des_cbc_cksum ((des_cblock *)password, &ivec, passlen, schedule, &ivec);
d301 1
a301 1
    des_cbc_cksum ((des_cblock *)password, key, passlen, schedule, &ivec);
d315 1
d320 1
a320 1
	DES_AFS3_Transarc_string_to_key(password, salt.saltvalue, &tmp);
d322 1
a322 1
	DES_AFS3_CMU_string_to_key(password, salt.saltvalue, &tmp);
d378 1
d405 1
a405 1
		xor(keys + i, (unsigned char*)"\0\0\0\0\0\0\0\xf0");
d409 3
a411 3
	des_ede3_cbc_encrypt((des_cblock *)tmp, (des_cblock *)tmp,
			     sizeof(tmp), s[0], s[1], s[2], &ivec,
			     DES_ENCRYPT);
d418 1
a418 1
		xor(keys + i, (unsigned char*)"\0\0\0\0\0\0\0\xf0");
d435 1
d482 1
d510 174
d704 2
a705 2
    DES_random_key,
    DES_schedule,
d731 24
d771 4
d795 1
a795 1
	DES_string_to_key
d823 11
a964 5
/*
 * Do a string -> key for encryption type `enctype' operation on
 * `password' (with salt `salt'), returning the resulting key in `key'
 */

d972 20
d1001 2
a1002 1
	    return (*st->string_to_key)(context, enctype, password, salt, key);
d1061 15
d1191 2
a1192 2
    des_cbc_encrypt((des_cblock *)p, 
		    (des_cblock *)p, 
d1266 2
a1267 2
    des_cbc_encrypt((des_cblock *)p, 
		    (des_cblock *)p, 
d1436 6
a1441 6
HMAC_SHA1_DES3_checksum(krb5_context context,
			struct key_data *key, 
			const void *data, 
			size_t len, 
			unsigned usage,
			Checksum *result)
d1444 5
d1450 2
a1451 1
    hmac(context, c, data, len, usage, key, result);
d1629 12
a1640 1
    HMAC_SHA1_DES3_checksum,
d1644 11
d1690 4
d1775 1
a1775 1
		krb5_key_usage usage, /* not krb5_key_usage */
d1974 1
a1974 1
		 void *ignore_ivec)
d1976 1
a1976 1
    des_cblock ivec;
d1978 4
a1981 16
    memset(&ivec, 0, sizeof(ivec));
    des_ede3_cbc_encrypt(data, data, len, s[0], s[1], s[2], &ivec, encrypt);
    return 0;
}

static krb5_error_code
DES3_CBC_encrypt_ivec(krb5_context context,
		      struct key_data *key, 
		      void *data, 
		      size_t len, 
		      krb5_boolean encrypt,
		      int usage,
		      void *ivec)
{
    des_key_schedule *s = key->schedule->data;

d2021 108
d2261 2
a2262 2
static int
usage2arcfour (int usage)
d2264 1
a2264 1
    switch (usage) {
d2266 2
a2267 1
	return 1;
d2269 2
a2270 1
	return 8;
d2272 2
a2273 1
	return 8;
d2278 2
a2279 1
	return 7;
d2282 2
a2283 1
	return 8;
d2287 2
a2288 1
	return 11;
d2290 1
d2304 2
a2305 1
	abort ();
d2318 3
a2320 1
    usage = usage2arcfour (usage);
d2337 1
d2350 1
d2362 1
d2374 1
d2385 1
d2388 2
a2389 2
    &checksum_hmac_md5_enc,
    &checksum_hmac_md5_enc,
d2398 1
d2410 1
d2422 1
d2429 26
d2459 1
d2471 1
d2483 1
d2495 1
a2502 11
static struct encryption_type enctype_des3_cbc_none_ivec = {
    ETYPE_DES3_CBC_NONE_IVEC,
    "des3-cbc-none-ivec",
    8,
    0,
    &keytype_des3_derived,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES3_CBC_encrypt_ivec,
};
d2513 4
d2520 1
a2520 2
    &enctype_des3_cbc_none,
    &enctype_des3_cbc_none_ivec
d2607 1
a2607 1
			  int **val)
d2611 1
a2611 1
    int *ret;
d2618 1
a2618 1
    ret = malloc(n * sizeof(int));
d2643 1
a2643 1
				  int **val)
d2646 1
a2646 1
    int *ret;
d2709 1
a2709 1
    size_t sz, block_sz, checksum_sz;
d2714 1
a2714 1
    struct encryption_type *et = crypto->et;
d2718 6
a2723 4
    sz = et->confoundersize + /* 4 - length */ len;
    block_sz = (sz + et->blocksize - 1) &~ (et->blocksize - 1); /* pad */
    p = calloc(1, block_sz + checksum_sz);
    if(p == NULL)
d2725 1
d2744 2
a2745 5
    if(ret) {
	memset(p, 0, block_sz + checksum_sz);
	free(p);
	return ret;
    }
d2749 2
a2750 5
    if(ret) {
	memset(p, 0, block_sz + checksum_sz);
	free(p);
	return ret;
    }
d2752 2
a2753 5
    if(ret) {
	memset(p, 0, block_sz);
	free(p);
	return ret;
    }
d2757 3
a2759 1
    (*et->encrypt)(context, dkey, p, block_sz, 1, usage, ivec);
d2761 1
a2761 1
    result->length = block_sz + checksum_sz;
d2763 4
d2769 1
d2782 1
a2782 1
    struct encryption_type *et = crypto->et;
d2787 1
a2787 1
    block_sz = (sz + et->blocksize - 1) &~ (et->blocksize - 1); /* pad */
d2810 1
d2813 2
a2814 6
    if(ret) {
	memset(p, 0, block_sz);
	free(p);
	free_Checksum(&cksum);
	return ret;
    }
d2818 7
a2824 1
    if(ret) {
a2828 4
#ifdef CRYPTO_DEBUG
    krb5_crypto_debug(context, 1, block_sz, crypto->key.key);
#endif
    (*et->encrypt)(context, &crypto->key, p, block_sz, 1, 0, ivec);
d2832 4
d2851 1
d2864 6
a2869 1
    (*et->encrypt)(context, &crypto->key, tmp, sz, TRUE, usage, ivec);
d2920 5
a2924 1
    (*et->encrypt)(context, dkey, p, len, 0, usage, ivec);
d2982 5
a2986 1
    (*et->encrypt)(context, &crypto->key, p, len, 0, 0, ivec);
d3026 1
d3034 5
a3038 1
    (*et->encrypt)(context, &crypto->key, data, len, FALSE, usage, ivec);
d3328 6
d3441 5
d3488 9
d3552 1
a3552 1
    size_t blocksize = et->blocksize;
d3556 1
a3556 1
    res =  (res + blocksize - 1) / blocksize * blocksize;
d3566 1
a3566 1
    size_t blocksize = et->blocksize;
d3570 1
a3570 1
    res =  (res + blocksize - 1) / blocksize * blocksize;
d3686 1
a3686 1
    HMAC_SHA1_DES3_checksum(context, d, data, 28, &res);
@


1.3
log
@Merge heimdal-0.4e
@
text
@d251 1
a251 1
    des_cbc_cksum (password, &ivec, passlen, schedule, &ivec);
d256 1
a256 1
    des_cbc_cksum (password, key, passlen, schedule, &ivec);
d362 3
a364 2
	des_ede3_cbc_encrypt(tmp, tmp, sizeof(tmp), 
			     s[0], s[1], s[2], &ivec, DES_ENCRYPT);
d898 2
a899 2
    des_cbc_encrypt(p, 
		    p, 
d973 2
a974 2
    des_cbc_encrypt(p, 
		    p, 
d1035 2
a1036 2
    des_ede3_cbc_encrypt(p, 
			 p, 
@


1.2
log
@-Wall
@
text
@d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.50 2001/05/14 06:14:45 assar Exp $");
d1727 1
a1727 1
    char *cdata = (char *)data;
d1783 1
a1783 1
    char *cdata = (char *)data;
d2657 1
a2657 1
#ifdef HAVE_OPENSSL_DES_H
d2685 1
a2685 1
	char *p;
d3001 1
d3010 9
d3020 7
a3026 3
    tmp = malloc (et->keytype->bits / 8);
    _krb5_n_fold(str, len, tmp, et->keytype->bits / 8);
    krb5_data_alloc(&kd.key->keyvalue, et->keytype->size);
d3028 4
a3031 2
    DES3_postproc (context, tmp, et->keytype->bits / 8, &kd); /* XXX */
    ret = derive_key(context,
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.43 2001/01/30 17:10:55 assar Exp $");
d115 1
a115 1
    struct checksum_type *cksumtype;
d118 2
a119 1
    krb5_error_code (*encrypt)(struct key_data *key,
d172 2
a173 1
    if(s == NULL)
d175 1
d251 1
a251 1
    des_cbc_cksum ((des_cblock *)password, &ivec, passlen, schedule, &ivec);
d256 1
a256 1
    des_cbc_cksum ((des_cblock *)password, key, passlen, schedule, &ivec);
d341 2
a342 1
    if(len != 0 && str == NULL)
d344 1
d362 1
a362 2
	des_ede3_cbc_encrypt((des_cblock *)tmp,
			     (des_cblock *)tmp, sizeof(tmp), 
d394 2
a395 1
    if(len != 0 && s == NULL)
d397 1
d442 2
a443 1
    if (len != 0 && s == NULL)
d445 1
d590 3
a592 1
    if (e == NULL)
d594 1
d598 2
a599 1
	    if (*string == NULL)
d601 1
d605 1
d619 3
a621 1
    if (e == NULL)
d623 1
d630 1
d716 3
a718 1
    if(et == NULL)
d720 1
d724 2
d754 2
a755 1
    if(kt == NULL)
d757 1
d759 2
a760 1
    if(*string == NULL)
d762 1
d777 1
d788 3
a790 1
    if(et == NULL)
d792 1
d818 2
a819 1
    if(key->schedule == NULL)
d821 1
d897 2
a898 2
    des_cbc_encrypt((des_cblock*)p, 
		    (des_cblock*)p, 
d930 2
a931 1
    if(memcmp(res, tmp + 8, sizeof(res)) != 0)
d933 1
d972 2
a973 2
    des_cbc_encrypt((des_cblock*)p, 
		    (des_cblock*)p, 
d1006 2
a1007 1
    if(memcmp(res, tmp + 8, sizeof(res)) != 0)
d1009 1
d1034 2
a1035 2
    des_ede3_cbc_encrypt((des_cblock*)p, 
			 (des_cblock*)p, 
d1068 2
a1069 1
    if(memcmp(res, tmp + 8, sizeof(res)) != 0)
d1071 1
d1399 2
a1400 1
	if(*key == NULL)
d1402 1
d1430 2
a1431 1
    if(keyed_checksum && crypto == NULL)
d1433 1
d1449 2
a1450 2
		unsigned usage, /* not krb5_key_usage */
		krb5_cksumtype type, /* if crypto == NULL */
d1455 1
a1455 1
    struct checksum_type *ct;
d1457 3
a1459 1
    if(crypto) {
d1461 7
a1467 5
	if(ct == NULL)
	    ct = crypto->et->cksumtype;
    } else
	ct = _find_checksum(type);
    if(ct == NULL)
d1469 1
d1476 2
a1477 1
		     unsigned usage_or_type,
d1483 2
a1484 2
			   CHECKSUM_USAGE(usage_or_type), 
			   usage_or_type, data, len, result);
d1502 3
a1504 1
    if(ct == NULL)
d1506 3
a1508 1
    if(ct->checksumsize != cksum->checksum.length)
d1510 1
d1512 2
a1513 1
    if(keyed_checksum && crypto == NULL)
d1515 1
d1530 2
a1531 1
       memcmp(c.checksum.data, cksum->checksum.data, c.checksum.length))
d1533 1
a1533 1
    else
d1535 1
d1558 3
a1560 1
    if(ct == NULL)
d1562 1
d1572 3
a1574 1
    if(ct == NULL)
d1576 1
d1585 3
a1587 1
    if(ct == NULL)
d1589 1
d1598 2
a1599 1
NULL_encrypt(struct key_data *key, 
d1610 2
a1611 1
DES_CBC_encrypt_null_ivec(struct key_data *key, 
d1626 2
a1627 1
DES_CBC_encrypt_key_ivec(struct key_data *key, 
d1642 2
a1643 1
DES3_CBC_encrypt(struct key_data *key, 
d1658 2
a1659 1
DES3_CBC_encrypt_ivec(struct key_data *key, 
d1673 2
a1674 1
DES_CFB64_encrypt_null_ivec(struct key_data *key, 
d1691 2
a1692 1
DES_PCBC_encrypt_key_ivec(struct key_data *key, 
d1714 2
a1715 1
ARCFOUR_subencrypt(struct key_data *key,
d1770 2
a1771 1
ARCFOUR_subdecrypt(struct key_data *key,
d1825 2
a1826 1
    if (memcmp (cksum.checksum.data, data, 16) != 0)
d1828 1
a1828 1
    else
d1830 1
d1880 2
a1881 1
ARCFOUR_encrypt(struct key_data *key,
d1891 1
a1891 1
	return ARCFOUR_subencrypt (key, data, len, usage, ivec);
d1893 1
a1893 1
	return ARCFOUR_subdecrypt (key, data, len, usage, ivec);
d1901 158
a2058 144
static struct encryption_type etypes[] = {
    {
	ETYPE_NULL,
	"null",
	1,
	0,
	&keytype_null,
	&checksum_none,
	NULL,
	0,
	NULL_encrypt,
    },
    {
	ETYPE_DES_CBC_CRC,
	"des-cbc-crc",
	8,
	8,
	&keytype_des,
	&checksum_crc32,
	NULL,
	0,
	DES_CBC_encrypt_key_ivec,
    },
    {
	ETYPE_DES_CBC_MD4,
	"des-cbc-md4",
	8,
	8,
	&keytype_des,
	&checksum_rsa_md4,
	&checksum_rsa_md4_des,
	0,
	DES_CBC_encrypt_null_ivec,
    },
    {
	ETYPE_DES_CBC_MD5,
	"des-cbc-md5",
	8,
	8,
	&keytype_des,
	&checksum_rsa_md5,
	&checksum_rsa_md5_des,
	0,
	DES_CBC_encrypt_null_ivec,
    },
    {
	ETYPE_ARCFOUR_HMAC_MD5,
	"arcfour-hmac-md5",
	1,
	8,
	&keytype_arcfour,
	&checksum_hmac_md5_enc,
	&checksum_hmac_md5_enc,
	F_SPECIAL,
	ARCFOUR_encrypt
    },
    { 
	ETYPE_DES3_CBC_MD5,
	"des3-cbc-md5",
	8,
	8,
	&keytype_des3,
	&checksum_rsa_md5,
	&checksum_rsa_md5_des3,
	0,
 	DES3_CBC_encrypt,
    },
    {
	ETYPE_DES3_CBC_SHA1,
	"des3-cbc-sha1",
	8,
	8,
	&keytype_des3_derived,
	&checksum_sha1,
	&checksum_hmac_sha1_des3,
	F_DERIVED,
 	DES3_CBC_encrypt,
    },
    {
	ETYPE_OLD_DES3_CBC_SHA1,
	"old-des3-cbc-sha1",
	8,
	8,
	&keytype_des3,
	&checksum_sha1,
	&checksum_hmac_sha1_des3,
	0,
 	DES3_CBC_encrypt,
    },
    {
	ETYPE_DES_CBC_NONE,
	"des-cbc-none",
	8,
	0,
	&keytype_des,
	&checksum_none,
	NULL,
	F_PSEUDO,
	DES_CBC_encrypt_null_ivec,
    },
    {
	ETYPE_DES_CFB64_NONE,
	"des-cfb64-none",
	1,
	0,
	&keytype_des,
	&checksum_none,
	NULL,
	F_PSEUDO,
	DES_CFB64_encrypt_null_ivec,
    },
    {
	ETYPE_DES_PCBC_NONE,
	"des-pcbc-none",
	8,
	0,
	&keytype_des,
	&checksum_none,
	NULL,
	F_PSEUDO,
	DES_PCBC_encrypt_key_ivec,
    },
    {
	ETYPE_DES3_CBC_NONE,
	"des3-cbc-none",
	8,
	0,
	&keytype_des3_derived,
	&checksum_none,
	NULL,
	F_PSEUDO,
	DES3_CBC_encrypt,
    },
    {
	ETYPE_DES3_CBC_NONE_IVEC,
	"des3-cbc-none-ivec",
	8,
	0,
	&keytype_des3_derived,
	&checksum_none,
	NULL,
	F_PSEUDO,
	DES3_CBC_encrypt_ivec,
    }
d2069 2
a2070 2
	if(etypes[i].type == type)
	    return &etypes[i];
d2082 3
a2084 1
    if(e == NULL)
d2086 1
d2088 2
a2089 1
    if(*string == NULL)
d2091 1
d2102 2
a2103 2
	if(strcasecmp(etypes[i].name, string) == 0){
	    *etype = etypes[i].type;
d2106 2
d2117 3
a2119 1
    if(e == NULL)
d2121 1
d2152 2
a2153 2
	if (etypes[i].keytype->type == keytype
	    && !(etypes[i].flags & F_PSEUDO))
d2157 2
a2158 1
    if (ret == NULL && n != 0)
d2160 1
d2163 3
a2165 3
	if (etypes[i].keytype->type == keytype
	    && !(etypes[i].flags & F_PSEUDO))
	    ret[n++] = etypes[i].type;
d2192 2
a2193 1
    if (ret == NULL && n != 0)
d2195 1
d2270 1
a2270 1
			  0,
d2276 1
d2301 1
a2301 1
    (*et->encrypt)(dkey, p, block_sz, 1, usage, ivec);
d2321 1
a2321 1
    checksum_sz = CHECKSUMSIZE(et->cksumtype);
d2326 2
a2327 1
    if(p == NULL)
d2329 1
d2339 1
a2339 1
			  NULL,
d2341 1
a2341 1
			  CHECKSUMTYPE(et->cksumtype),
d2346 1
a2346 1
	free_Checksum (&cksum);
d2366 1
a2366 1
    (*et->encrypt)(&crypto->key, p, block_sz, 1, 0, ivec);
d2382 1
a2382 1
    size_t cksum_sz = CHECKSUMSIZE(et->cksumtype);
d2387 2
a2388 1
    if (tmp == NULL)
d2390 1
d2397 1
a2397 1
    (*et->encrypt)(&crypto->key, tmp, sz, TRUE, usage, ivec);
d2421 4
a2424 2
    if (len < checksum_sz)
	return EINVAL;		/* better error code? */
d2427 2
a2428 1
    if(len != 0 && p == NULL)
d2430 1
d2448 1
a2448 1
    (*et->encrypt)(dkey, p, len, 0, usage, ivec);
d2467 1
a2467 1
    if(p == NULL) {
d2469 1
d2490 1
a2490 1
    checksum_sz = CHECKSUMSIZE(et->cksumtype);
d2492 2
a2493 1
    if(len != 0 && p == NULL)
d2495 1
d2506 1
a2506 1
    (*et->encrypt)(&crypto->key, p, len, 0, 0, ivec);
d2513 1
a2513 1
    cksum.cksumtype = CHECKSUMTYPE(et->cksumtype);
d2525 1
d2542 1
a2542 1
    size_t cksum_sz = CHECKSUMSIZE(et->cksumtype);
d2548 2
a2549 1
    if (tmp == NULL)
d2551 1
d2553 1
a2553 1
    (*et->encrypt)(&crypto->key, data, len, FALSE, usage, ivec);
d2657 66
d2748 1
d2789 1
a2789 1
	   void *constant,
d2804 2
a2805 1
	if(k == NULL)
d2807 1
d2814 2
a2815 2
	    (*et->encrypt)(key, k + i * et->blocksize, et->blocksize, 1, 0,
			   NULL);
d2822 2
a2823 1
	if(len != 0 && c == NULL)
d2825 1
d2827 1
a2827 1
	(*et->encrypt)(key, c, len, 1, 0, NULL);
d2829 3
a2831 1
	if(res_len != 0 && k == NULL)
d2833 1
d2844 3
a2846 2
	krb5_warnx(context, "derive_key() called with unknown keytype (%u)", 
		   kt->type);
d2869 32
d2917 2
a2918 1
    if(d == NULL)
d2920 1
d2931 1
a2931 1
		 krb5_keyblock *key,
d2937 2
a2938 1
    if(*crypto == NULL)
d2940 1
d2946 2
d3003 3
a3005 1
    if(et == NULL)
d3007 1
d3034 1
a3034 1
    res =  et->confoundersize + et->cksumtype->checksumsize + data_len;
d3050 1
a3050 1
    res += et->cksumtype->checksumsize;
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.50 2001/05/14 06:14:45 assar Exp $");
d115 1
a115 1
    struct checksum_type *checksum;
d118 1
a118 2
    krb5_error_code (*encrypt)(krb5_context context,
			       struct key_data *key,
d171 1
a171 2
    if(s == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a172 1
    }
d338 1
a338 2
    if(len != 0 && str == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a339 1
    }
d390 1
a390 2
    if(len != 0 && s == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a391 1
    }
d436 1
a436 2
    if (len != 0 && s == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a437 1
    }
d582 1
a582 3
    if (e == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      etype);
a583 1
    }
d587 1
a587 2
	    if (*string == NULL) {
		krb5_set_error_string(context, "malloc: out of memory");
a588 1
	    }
a591 1
    krb5_set_error_string(context, "salttype %d not supported", stype);
d605 1
a605 3
    if (e == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      etype);
a606 1
    }
a612 1
    krb5_set_error_string(context, "salttype %s not supported", string);
d698 1
a698 3
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      enctype);
a699 1
    }
a702 2
    krb5_set_error_string(context, "salt type %d not supported",
			  salt.salttype);
d731 1
a731 2
    if(kt == NULL) {
	krb5_set_error_string(context, "key type %d not supported", keytype);
a732 1
    }
d734 1
a734 2
    if(*string == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a735 1
    }
a749 1
    krb5_set_error_string(context, "key type %s not supported", string);
d760 1
a760 3
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      type);
a761 1
    }
d787 1
a787 2
    if(key->schedule == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a788 1
    }
d897 1
a897 2
    if(memcmp(res, tmp + 8, sizeof(res)) != 0) {
	krb5_clear_error_string (context);
a898 1
    }
d971 1
a971 2
    if(memcmp(res, tmp + 8, sizeof(res)) != 0) {
	krb5_clear_error_string (context);
a972 1
    }
d1031 1
a1031 2
    if(memcmp(res, tmp + 8, sizeof(res)) != 0) {
	krb5_clear_error_string (context);
a1032 1
    }
d1360 1
a1360 2
	if(*key == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
a1361 1
	}
d1389 1
a1389 2
    if(keyed_checksum && crypto == NULL) {
	krb5_clear_error_string (context);
a1390 1
    }
d1406 2
a1407 2
		krb5_key_usage usage, /* not krb5_key_usage */
		krb5_cksumtype type, /* 0 -> pick from crypto */
d1412 1
a1412 1
    struct checksum_type *ct = NULL;
d1414 5
a1418 1
    if (type) {
d1420 1
a1420 9
    } else if (crypto) {
	ct = crypto->et->keyed_checksum;
	if (ct == NULL)
	    ct = crypto->et->checksum;
    }

    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
a1421 1
    }
d1428 1
a1428 2
		     krb5_key_usage usage,
		     int type,
d1434 2
a1435 2
			   CHECKSUM_USAGE(usage), 
			   type, data, len, result);
d1453 1
a1453 3
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       cksum->cksumtype);
d1455 1
a1455 3
    }
    if(ct->checksumsize != cksum->checksum.length) {
	krb5_clear_error_string (context);
a1456 1
    }
d1458 1
a1458 2
    if(keyed_checksum && crypto == NULL) {
	krb5_clear_error_string (context);
a1459 1
    }
d1474 1
a1474 2
       memcmp(c.checksum.data, cksum->checksum.data, c.checksum.length)) {
	krb5_clear_error_string (context);
d1476 1
a1476 1
    } else {
a1477 1
    }
d1500 1
a1500 3
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
a1501 1
    }
d1511 1
a1511 3
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
a1512 1
    }
d1521 1
a1521 3
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       type);
a1522 1
    }
d1531 1
a1531 2
NULL_encrypt(krb5_context context,
	     struct key_data *key, 
d1542 1
a1542 2
DES_CBC_encrypt_null_ivec(krb5_context context,
			  struct key_data *key, 
d1557 1
a1557 2
DES_CBC_encrypt_key_ivec(krb5_context context,
			 struct key_data *key, 
d1572 1
a1572 2
DES3_CBC_encrypt(krb5_context context,
		 struct key_data *key, 
d1587 1
a1587 2
DES3_CBC_encrypt_ivec(krb5_context context,
		      struct key_data *key, 
d1601 1
a1601 2
DES_CFB64_encrypt_null_ivec(krb5_context context,
			    struct key_data *key, 
d1618 1
a1618 2
DES_PCBC_encrypt_key_ivec(krb5_context context,
			  struct key_data *key, 
d1640 1
a1640 2
ARCFOUR_subencrypt(krb5_context context,
		   struct key_data *key,
d1695 1
a1695 2
ARCFOUR_subdecrypt(krb5_context context,
		   struct key_data *key,
d1749 1
a1749 2
    if (memcmp (cksum.checksum.data, data, 16) != 0) {
	krb5_clear_error_string (context);
d1751 1
a1751 1
    } else {
a1752 1
    }
d1802 1
a1802 2
ARCFOUR_encrypt(krb5_context context,
		struct key_data *key,
d1812 1
a1812 1
	return ARCFOUR_subencrypt (context, key, data, len, usage, ivec);
d1814 1
a1814 1
	return ARCFOUR_subdecrypt (context, key, data, len, usage, ivec);
d1822 144
a1965 158
static struct encryption_type enctype_null = {
    ETYPE_NULL,
    "null",
    1,
    0,
    &keytype_null,
    &checksum_none,
    NULL,
    0,
    NULL_encrypt,
};
static struct encryption_type enctype_des_cbc_crc = {
    ETYPE_DES_CBC_CRC,
    "des-cbc-crc",
    8,
    8,
    &keytype_des,
    &checksum_crc32,
    NULL,
    0,
    DES_CBC_encrypt_key_ivec,
};
static struct encryption_type enctype_des_cbc_md4 = {
    ETYPE_DES_CBC_MD4,
    "des-cbc-md4",
    8,
    8,
    &keytype_des,
    &checksum_rsa_md4,
    &checksum_rsa_md4_des,
    0,
    DES_CBC_encrypt_null_ivec,
};
static struct encryption_type enctype_des_cbc_md5 = {
    ETYPE_DES_CBC_MD5,
    "des-cbc-md5",
    8,
    8,
    &keytype_des,
    &checksum_rsa_md5,
    &checksum_rsa_md5_des,
    0,
    DES_CBC_encrypt_null_ivec,
};
static struct encryption_type enctype_arcfour_hmac_md5 = {
    ETYPE_ARCFOUR_HMAC_MD5,
    "arcfour-hmac-md5",
    1,
    8,
    &keytype_arcfour,
    &checksum_hmac_md5_enc,
    &checksum_hmac_md5_enc,
    F_SPECIAL,
    ARCFOUR_encrypt
};
static struct encryption_type enctype_des3_cbc_md5 = { 
    ETYPE_DES3_CBC_MD5,
    "des3-cbc-md5",
    8,
    8,
    &keytype_des3,
    &checksum_rsa_md5,
    &checksum_rsa_md5_des3,
    0,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_des3_cbc_sha1 = {
    ETYPE_DES3_CBC_SHA1,
    "des3-cbc-sha1",
    8,
    8,
    &keytype_des3_derived,
    &checksum_sha1,
    &checksum_hmac_sha1_des3,
    F_DERIVED,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_old_des3_cbc_sha1 = {
    ETYPE_OLD_DES3_CBC_SHA1,
    "old-des3-cbc-sha1",
    8,
    8,
    &keytype_des3,
    &checksum_sha1,
    &checksum_hmac_sha1_des3,
    0,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_des_cbc_none = {
    ETYPE_DES_CBC_NONE,
    "des-cbc-none",
    8,
    0,
    &keytype_des,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES_CBC_encrypt_null_ivec,
};
static struct encryption_type enctype_des_cfb64_none = {
    ETYPE_DES_CFB64_NONE,
    "des-cfb64-none",
    1,
    0,
    &keytype_des,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES_CFB64_encrypt_null_ivec,
};
static struct encryption_type enctype_des_pcbc_none = {
    ETYPE_DES_PCBC_NONE,
    "des-pcbc-none",
    8,
    0,
    &keytype_des,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES_PCBC_encrypt_key_ivec,
};
static struct encryption_type enctype_des3_cbc_none = {
    ETYPE_DES3_CBC_NONE,
    "des3-cbc-none",
    8,
    0,
    &keytype_des3_derived,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES3_CBC_encrypt,
};
static struct encryption_type enctype_des3_cbc_none_ivec = {
    ETYPE_DES3_CBC_NONE_IVEC,
    "des3-cbc-none-ivec",
    8,
    0,
    &keytype_des3_derived,
    &checksum_none,
    NULL,
    F_PSEUDO,
    DES3_CBC_encrypt_ivec,
};

static struct encryption_type *etypes[] = {
    &enctype_null,
    &enctype_des_cbc_crc,
    &enctype_des_cbc_md4,
    &enctype_des_cbc_md5,
    &enctype_arcfour_hmac_md5,
    &enctype_des3_cbc_md5, 
    &enctype_des3_cbc_sha1,
    &enctype_old_des3_cbc_sha1,
    &enctype_des_cbc_none,
    &enctype_des_cfb64_none,
    &enctype_des_pcbc_none,
    &enctype_des3_cbc_none,
    &enctype_des3_cbc_none_ivec
d1976 2
a1977 2
	if(etypes[i]->type == type)
	    return etypes[i];
d1989 1
a1989 3
    if(e == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
a1990 1
    }
d1992 1
a1992 2
    if(*string == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a1993 1
    }
d2004 2
a2005 2
	if(strcasecmp(etypes[i]->name, string) == 0){
	    *etype = etypes[i]->type;
a2007 2
    krb5_set_error_string (context, "encryption type %s not supported",
			   string);
d2017 1
a2017 3
    if(e == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
a2018 1
    }
d2049 2
a2050 2
	if (etypes[i]->keytype->type == keytype
	    && !(etypes[i]->flags & F_PSEUDO))
d2054 1
a2054 2
    if (ret == NULL && n != 0) {
	krb5_set_error_string(context, "malloc: out of memory");
a2055 1
    }
d2058 3
a2060 3
	if (etypes[i]->keytype->type == keytype
	    && !(etypes[i]->flags & F_PSEUDO))
	    ret[n++] = etypes[i]->type;
d2087 1
a2087 2
    if (ret == NULL && n != 0) {
	krb5_set_error_string(context, "malloc: out of memory");
a2088 1
    }
d2163 1
a2163 1
			  et->keyed_checksum->type,
a2168 1
	krb5_clear_error_string (context);
d2193 1
a2193 1
    (*et->encrypt)(context, dkey, p, block_sz, 1, usage, ivec);
d2213 1
a2213 1
    checksum_sz = CHECKSUMSIZE(et->checksum);
d2218 1
a2218 2
    if(p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2219 1
    }
d2229 1
a2229 1
			  crypto,
d2231 1
a2231 1
			  et->checksum->type,
d2236 1
a2236 1
	krb5_clear_error_string (context);
d2256 1
a2256 1
    (*et->encrypt)(context, &crypto->key, p, block_sz, 1, 0, ivec);
d2272 1
a2272 1
    size_t cksum_sz = CHECKSUMSIZE(et->checksum);
d2277 1
a2277 2
    if (tmp == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2278 1
    }
d2285 1
a2285 1
    (*et->encrypt)(context, &crypto->key, tmp, sz, TRUE, usage, ivec);
d2309 2
a2310 4
    if (len < checksum_sz) {
	krb5_clear_error_string (context);
	return EINVAL;		/* XXX - better error code? */
    }
d2313 1
a2313 2
    if(len != 0 && p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2314 1
    }
d2332 1
a2332 1
    (*et->encrypt)(context, dkey, p, len, 0, usage, ivec);
d2351 1
a2351 1
    if(result->data == NULL) {
a2352 1
	krb5_set_error_string(context, "malloc: out of memory");
d2373 1
a2373 1
    checksum_sz = CHECKSUMSIZE(et->checksum);
d2375 1
a2375 2
    if(len != 0 && p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2376 1
    }
d2387 1
a2387 1
    (*et->encrypt)(context, &crypto->key, p, len, 0, 0, ivec);
d2394 1
a2394 1
    cksum.cksumtype = CHECKSUMTYPE(et->checksum);
a2405 1
	krb5_set_error_string(context, "malloc: out of memory");
d2422 1
a2422 1
    size_t cksum_sz = CHECKSUMSIZE(et->checksum);
d2428 1
a2428 2
    if (tmp == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2429 1
    }
d2431 1
a2431 1
    (*et->encrypt)(context, &crypto->key, data, len, FALSE, usage, ivec);
a2534 67
#ifdef HAVE_OPENSSL_DES_H
#include <openssl/rand.h>

/* From openssl/crypto/rand/rand_lcl.h */
#define ENTROPY_NEEDED 20
static int
seed_something(void)
{
    int fd = -1;
    size_t len;
    char buf[1024], seedfile[256];

    /* If there is a seed file, load it. But such a file cannot be trusted,
       so use 0 for the entropy estimate */
    if (RAND_file_name(seedfile, sizeof(seedfile))) {
	fd = open(seedfile, O_RDONLY);
	if (fd >= 0) {
	    read(fd, buf, sizeof(buf));
	    /* Use the full buffer anyway */
	    RAND_add(buf, sizeof(buf), 0.0);
	} else
	    seedfile[0] = '\0';
    } else
	seedfile[0] = '\0';

    /* Calling RAND_status() will try to use /dev/urandom if it exists so
       we do not have to deal with it. */
    if (RAND_status() != 1) {
	krb5_context context;
	char *p;

	/* Try using egd */
	if (!krb5_init_context(&context)) {
	    p = krb5_config_get_string(context, NULL, "libdefaults",
		"egd_socket", NULL);
	    if (p != NULL)
		RAND_egd_bytes(p, ENTROPY_NEEDED);
	    krb5_free_context(context);
	}
    }
    
    if (RAND_status() == 1)	{
	/* Update the seed file */
	if (seedfile[0])
	    RAND_write_file(seedfile);

	return 0;
    } else
	return -1;
}

void
krb5_generate_random_block(void *buf, size_t len)
{
    static int rng_initialized = 0;
    
    if (!rng_initialized) {
	if (seed_something())
	    krb5_abortx(NULL, "Fatal: could not seed the random number generator");
	
	rng_initialized = 1;
    }
    RAND_bytes(buf, len);
}

#else

a2559 1
#endif
d2600 1
a2600 1
	   const void *constant,
d2615 1
a2615 2
	if(k == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
a2616 1
	}
d2623 2
a2624 2
	    (*et->encrypt)(context, key, k + i * et->blocksize, et->blocksize,
			   1, 0, NULL);
d2631 1
a2631 2
	if(len != 0 && c == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
a2632 1
	}
d2634 1
a2634 1
	(*et->encrypt)(context, key, c, len, 1, 0, NULL);
d2636 1
a2636 3
	if(res_len != 0 && k == NULL) {
	    free(c);
	    krb5_set_error_string(context, "malloc: out of memory");
a2637 1
	}
d2648 2
a2649 3
	krb5_set_error_string(context,
			      "derive_key() called with unknown keytype (%u)", 
			      kt->type);
a2671 32
krb5_error_code
krb5_derive_key(krb5_context context,
		const krb5_keyblock *key,
		krb5_enctype etype,
		const void *constant,
		size_t constant_len,
		krb5_keyblock **derived_key)
{
    krb5_error_code ret;
    struct encryption_type *et;
    struct key_data d;

    et = _find_enctype (etype);
    if (et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      etype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }

    ret = krb5_copy_keyblock(context, key, derived_key);
    if (ret)
	return ret;

    d.key = *derived_key;
    d.schedule = NULL;
    ret = derive_key(context, et, &d, constant, constant_len);
    if (ret)
	return ret;
    ret = krb5_copy_keyblock(context, d.key, derived_key);
    return ret;
}

d2688 1
a2688 2
    if(d == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2689 1
    }
d2700 1
a2700 1
		 const krb5_keyblock *key,
d2706 1
a2706 2
    if(*crypto == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2707 1
    }
a2712 2
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
d2768 1
a2768 3
    if(et == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
a2769 1
    }
d2796 1
a2796 1
    res =  et->confoundersize + et->checksum->checksumsize + data_len;
d2812 1
a2812 1
    res += et->checksum->checksumsize;
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.53 2001/08/22 20:30:29 assar Exp $");
d1728 1
a1728 1
    unsigned char *cdata = data;
d1784 1
a1784 1
    unsigned char *cdata = data;
d2658 1
a2658 1
#ifdef HAVE_OPENSSL
d2667 1
d2687 1
a2687 1
	const char *p;
a3002 1
    size_t keylen = et->keytype->bits / 8;
a3010 9
    if(kd.key == NULL) {
	krb5_set_error_string (context, "malloc: out of memory");
	return ENOMEM;
    }
    ret = krb5_data_alloc(&kd.key->keyvalue, et->keytype->size);
    if(ret) {
	free(kd.key);
	return ret;
    }
d3012 3
a3014 7
    tmp = malloc (keylen);
    if(tmp == NULL) {
	krb5_free_keyblock(context, kd.key);
	krb5_set_error_string (context, "malloc: out of memory");
	return ENOMEM;
    }
    _krb5_n_fold(str, len, tmp, keylen);
d3016 2
a3017 4
    DES3_postproc (context, tmp, keylen, &kd); /* XXX */
    memset(tmp, 0, keylen);
    free(tmp);
    ret = derive_key(context, 
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.73 2003/04/01 16:51:54 lha Exp $");
d74 1
a74 1
				     krb5_salt, krb5_data, krb5_keyblock*);
a112 1
    size_t padsize;
a135 13
static krb5_error_code derive_key(krb5_context context,
				  struct encryption_type *et,
				  struct key_data *key,
				  const void *constant,
				  size_t len);
static void hmac(krb5_context context,
		 struct checksum_type *cm, 
		 const void *data, 
		 size_t len, 
		 unsigned usage,
		 struct key_data *keyblock,
		 Checksum *result);
static void free_key_data(krb5_context context, struct key_data *key);
d142 1
a142 1
krb5_DES_random_key(krb5_context context,
d153 1
a153 1
krb5_DES_schedule(krb5_context context,
a158 31
static void
DES_string_to_key_int(unsigned char *data, size_t length, des_cblock *key)
{
    des_key_schedule schedule;
    int i;
    int reverse = 0;
    unsigned char *p;

    unsigned char swap[] = { 0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe, 
			     0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf };
    memset(key, 0, 8);
    
    p = (unsigned char*)key;
    for (i = 0; i < length; i++) {
	unsigned char tmp = data[i];
	if (!reverse)
	    *p++ ^= (tmp << 1);
	else
	    *--p ^= (swap[tmp & 0xf] << 4) | swap[(tmp & 0xf0) >> 4];
	if((i % 8) == 7)
	    reverse = !reverse;
    }
    des_set_odd_parity(key);
    if(des_is_weak_key(key))
	(*key)[7] ^= 0xF0;
    des_set_key(key, schedule);
    des_cbc_cksum((void*)data, key, length, schedule, key);
    memset(schedule, 0, sizeof(schedule));
    des_set_odd_parity(key);
}

d160 1
a160 1
krb5_DES_string_to_key(krb5_context context,
a163 1
		  krb5_data opaque,
d166 1
a166 1
    unsigned char *s;
d170 1
a170 1
    len = password.length + salt.saltvalue.length;
d172 1
a172 1
    if(len > 0 && s == NULL) {
d178 2
a179 1
    DES_string_to_key_int(s, len, &tmp);
d198 1
a198 1
krb5_DES_AFS3_CMU_string_to_key (krb5_data pw,
d213 1
a213 1
    memcpy(key, crypt(password, "p1") + 2, sizeof(des_cblock));
d227 1
a227 1
krb5_DES_AFS3_Transarc_string_to_key (krb5_data pw,
d251 1
a251 1
    des_cbc_cksum (password, &ivec, passlen, schedule, &ivec);
d256 1
a256 1
    des_cbc_cksum (password, key, passlen, schedule, &ivec);
a269 1
		       krb5_data opaque,
d274 1
a274 1
	krb5_DES_AFS3_Transarc_string_to_key(password, salt.saltvalue, &tmp);
d276 1
a276 1
	krb5_DES_AFS3_CMU_string_to_key(password, salt.saltvalue, &tmp);
a331 1
		   krb5_data opaque,
d358 1
a358 1
		xor(keys + i, (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
d362 2
a363 2
	des_ede3_cbc_encrypt(tmp,
			     tmp, sizeof(tmp), 
d371 1
a371 1
		xor(keys + i, (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
a387 1
			   krb5_data opaque,
a433 1
		  krb5_data opaque,
a460 174
#ifdef ENABLE_AES
/*
 * AES
 */

/* iter is really 1 based, so iter == 0 will be 1 iteration */

krb5_error_code
krb5_PKCS5_PBKDF2(krb5_context context, krb5_cksumtype cktype,
		  krb5_data password, krb5_salt salt, u_int32_t iter,
		  krb5_keytype type, krb5_keyblock *key)
{
    struct checksum_type *c = _find_checksum(cktype);
    struct key_type *kt;
    size_t datalen, leftofkey;
    krb5_error_code ret;
    u_int32_t keypart;
    struct key_data ksign;
    krb5_keyblock kb;
    Checksum result;
    char *data, *tmpcksum;
    int i, j;
    char *p;
    
    if (c == NULL) {
	krb5_set_error_string(context, "checksum %d not supported", cktype);
	return KRB5_PROG_KEYTYPE_NOSUPP;
    }

    kt = _find_keytype(type);
    if (kt == NULL) {
	krb5_set_error_string(context, "key type %d not supported", type);
	return KRB5_PROG_KEYTYPE_NOSUPP;
    }
    
    key->keytype = type;
    ret = krb5_data_alloc (&key->keyvalue, kt->bits / 8);
    if (ret) {
	krb5_set_error_string(context, "malloc: out of memory");
	return ret;
    }
	
    ret = krb5_data_alloc (&result.checksum, c->checksumsize);
    if (ret) {
	krb5_set_error_string(context, "malloc: out of memory");
	krb5_data_free (&key->keyvalue);
	return ret;
    }

    tmpcksum = malloc(c->checksumsize);
    if (tmpcksum == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	krb5_data_free (&key->keyvalue);
	krb5_data_free (&result.checksum);
	return ENOMEM;
    }

    datalen = salt.saltvalue.length + 4;
    data = malloc(datalen);
    if (data == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	free(tmpcksum);
	krb5_data_free (&key->keyvalue);
	krb5_data_free (&result.checksum);
	return ENOMEM;
    }

    kb.keyvalue = password;
    ksign.key = &kb;

    memcpy(data, salt.saltvalue.data, salt.saltvalue.length);

    keypart = 1;
    leftofkey = key->keyvalue.length;
    p = key->keyvalue.data;

    while (leftofkey) {
	int len;

	if (leftofkey > c->checksumsize)
	    len = c->checksumsize;
	else
	    len = leftofkey;

	_krb5_put_int(data + datalen - 4, keypart, 4);

	hmac(context, c, data, datalen, 0, &ksign, &result);
	memcpy(p, result.checksum.data, len);
	memcpy(tmpcksum, result.checksum.data, result.checksum.length);
	for (i = 0; i < iter; i++) {
	    hmac(context, c, tmpcksum, result.checksum.length,
		 0, &ksign, &result);
	    memcpy(tmpcksum, result.checksum.data, result.checksum.length);
	    for (j = 0; j < len; j++)
		p[j] ^= tmpcksum[j];
	}

	p += len;
	leftofkey -= len;
	keypart++;
    }

    free(data);
    free(tmpcksum);
    krb5_data_free (&result.checksum);

    return 0;
}

static krb5_error_code
AES_string_to_key(krb5_context context,
		  krb5_enctype enctype,
		  krb5_data password,
		  krb5_salt salt,
		  krb5_data opaque,
		  krb5_keyblock *key)
{
    krb5_error_code ret;
    u_int32_t iter;
    struct encryption_type *et;
    struct key_data kd;

    if (opaque.length == 0)
	iter = 45056 - 1;
    else if (opaque.length == 4) {
	unsigned long v;
	_krb5_get_int(opaque.data, &v, 4);
	iter = ((u_int32_t)v) - 1;
    } else
	return KRB5_PROG_KEYTYPE_NOSUPP; /* XXX */
	

    et = _find_enctype(enctype);
    if (et == NULL)
	return KRB5_PROG_KEYTYPE_NOSUPP;

    ret = krb5_PKCS5_PBKDF2(context, CKSUMTYPE_SHA1, password, salt, 
			    iter, enctype, key);
    if (ret)
	return ret;

    ret = krb5_copy_keyblock(context, key, &kd.key);
    kd.schedule = NULL;

    ret = derive_key(context, et, &kd, "kerberos", strlen("kerberos"));

    if (ret) {
	krb5_data_free(&key->keyvalue);
    } else {
	ret = krb5_copy_keyblock_contents(context, kd.key, key);
	free_key_data(context, &kd);
    }

    return ret;
}

static void
AES_schedule(krb5_context context, struct key_data *kd)
{
    AES_KEY *key = kd->schedule->data;
    int bits = kd->key->keyvalue.length * 8;
    
    AES_set_encrypt_key(kd->key->keyvalue.data, bits, &key[0]);
    AES_set_decrypt_key(kd->key->keyvalue.data, bits, &key[1]);
}

/*
 *
 */

extern struct salt_type AES_salt[];

#endif /* ENABLE_AES */

d481 2
a482 2
    krb5_DES_random_key,
    krb5_DES_schedule,
a507 24
#ifdef ENABLE_AES
struct key_type keytype_aes128 = {
    KEYTYPE_AES128,
    "aes-128",
    128,
    16,
    sizeof(AES_KEY) * 2,
    NULL,
    AES_schedule,
    AES_salt
};

struct key_type keytype_aes256 = {
    KEYTYPE_AES256,
    "aes-256",
    256,
    16,
    sizeof(AES_KEY) * 2,
    NULL,
    AES_schedule,
    AES_salt
};
#endif /* ENABLE_AES */

a523 4
#ifdef ENABLE_AES
    &keytype_aes128,
    &keytype_aes256,
#endif /* ENABLE_AES */
d544 1
a544 1
	krb5_DES_string_to_key
a571 11
#ifdef ENABLE_AES
struct salt_type AES_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	AES_string_to_key
    },
    { 0 }
};
#endif /* ENABLE_AES */

d703 5
a714 20
    krb5_data opaque;
    krb5_data_zero(&opaque);
    return krb5_string_to_key_data_salt_opaque(context, enctype, password, 
					       salt, opaque, key);
}

/*
 * Do a string -> key for encryption type `enctype' operation on
 * `password' (with salt `salt' and the enctype specific data string
 * `opaque'), returning the resulting key in `key'
 */

krb5_error_code
krb5_string_to_key_data_salt_opaque (krb5_context context,
				     krb5_enctype enctype,
				     krb5_data password,
				     krb5_salt salt,
				     krb5_data opaque,
				     krb5_keyblock *key)
{
d724 1
a724 2
	    return (*st->string_to_key)(context, enctype, password, 
					salt, opaque, key);
a782 15
krb5_enctype_keysize(krb5_context context,
		     krb5_enctype type,
		     size_t *keysize)
{
    struct encryption_type *et = _find_enctype(type);
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      type);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    *keysize = et->keytype->size;
    return 0;
}

krb5_error_code
d898 2
a899 2
    des_cbc_encrypt(p, 
		    p, 
d973 2
a974 2
    des_cbc_encrypt(p, 
		    p, 
d1035 2
a1036 2
    des_ede3_cbc_encrypt(p, 
			 p, 
d1143 6
a1148 6
SP_HMAC_SHA1_checksum(krb5_context context,
		      struct key_data *key, 
		      const void *data, 
		      size_t len, 
		      unsigned usage,
		      Checksum *result)
a1150 5
    Checksum res;
    char sha1_data[20];

    res.checksum.data = sha1_data;
    res.checksum.length = sizeof(sha1_data);
d1152 1
a1152 2
    hmac(context, c, data, len, usage, key, &res);
    memcpy(result->checksum.data, res.checksum.data, result->checksum.length);
d1330 1
a1330 12
    SP_HMAC_SHA1_checksum,
    NULL
};

#ifdef ENABLE_AES
struct checksum_type checksum_hmac_sha1_aes128 = {
    CKSUMTYPE_HMAC_SHA1_96_AES_128,
    "hmac-sha1-96-aes128",
    64,
    12,
    F_KEYED | F_CPROOF | F_DERIVED,
    SP_HMAC_SHA1_checksum,
a1333 11
struct checksum_type checksum_hmac_sha1_aes256 = {
    CKSUMTYPE_HMAC_SHA1_96_AES_256,
    "hmac-sha1-96-aes256",
    64,
    12,
    F_KEYED | F_CPROOF | F_DERIVED,
    SP_HMAC_SHA1_checksum,
    NULL
};
#endif /* ENABLE_AES */

a1368 4
#ifdef ENABLE_AES
    &checksum_hmac_sha1_aes128,
    &checksum_hmac_sha1_aes256,
#endif
d1450 1
a1450 1
		unsigned usage, /* not krb5_key_usage */
d1649 17
a1665 1
		 void *ivec)
a1666 1
    des_cblock local_ivec;
d1668 1
a1668 4
    if(ivec == NULL) {
	ivec = &local_ivec;
	memset(local_ivec, 0, sizeof(local_ivec));
    }
a1707 108
#ifdef ENABLE_AES

/*
 * AES draft-raeburn-krb-rijndael-krb-02
 */

void
_krb5_aes_cts_encrypt(const unsigned char *in, unsigned char *out,
		      size_t len, const void *aes_key,
		      unsigned char *ivec, const int enc)
{
    unsigned char tmp[AES_BLOCK_SIZE];
    const AES_KEY *key = aes_key; /* XXX remove this when we always have AES */
    int i;

    /*
     * In the framework of kerberos, the length can never be shorter
     * then at least one blocksize.
     */

    if (enc == AES_ENCRYPT) {

	while(len > AES_BLOCK_SIZE) {
	    for (i = 0; i < AES_BLOCK_SIZE; i++)
		tmp[i] = in[i] ^ ivec[i];
	    AES_encrypt(tmp, out, key);
	    memcpy(ivec, out, AES_BLOCK_SIZE);
	    len -= AES_BLOCK_SIZE;
	    in += AES_BLOCK_SIZE;
	    out += AES_BLOCK_SIZE;
	}

	for (i = 0; i < len; i++)
	    tmp[i] = in[i] ^ ivec[i];
	for (; i < AES_BLOCK_SIZE; i++)
	    tmp[i] = 0 ^ ivec[i];

	AES_encrypt(tmp, out - AES_BLOCK_SIZE, key);

	memcpy(out, ivec, len);

    } else {
	char tmp2[AES_BLOCK_SIZE];
	char tmp3[AES_BLOCK_SIZE];

	while(len > AES_BLOCK_SIZE * 2) {
	    memcpy(tmp, in, AES_BLOCK_SIZE);
	    AES_decrypt(in, out, key);
	    for (i = 0; i < AES_BLOCK_SIZE; i++)
		out[i] ^= ivec[i];
	    memcpy(ivec, tmp, AES_BLOCK_SIZE);
	    len -= AES_BLOCK_SIZE;
	    in += AES_BLOCK_SIZE;
	    out += AES_BLOCK_SIZE;
	}

	len -= AES_BLOCK_SIZE;

	AES_decrypt(in, tmp2, key);

	memcpy(tmp3, in + AES_BLOCK_SIZE, len);
	memcpy(tmp3 + len, tmp2 + len, AES_BLOCK_SIZE - len); /* xor 0 */

	for (i = 0; i < len; i++)
	    out[i + AES_BLOCK_SIZE] = tmp2[i] ^ tmp3[i];

	AES_decrypt(tmp3, out, key);
	for (i = 0; i < AES_BLOCK_SIZE; i++)
	    out[i] ^= ivec[i];
    }
}

static krb5_error_code
AES_CTS_encrypt(krb5_context context,
		struct key_data *key,
		void *data,
		size_t len,
		krb5_boolean encrypt,
		int usage,
		void *ivec)
{
    AES_KEY *k = key->schedule->data;
    char local_ivec[AES_BLOCK_SIZE];

    if (encrypt)
	k = &k[0];
    else
	k = &k[1];
    
    if (len < AES_BLOCK_SIZE)
	abort();
    if (len == AES_BLOCK_SIZE) {
	if (encrypt)
	    AES_encrypt(data, data, k);
	else
	    AES_decrypt(data, data, k);
    } else {
	if(ivec == NULL) {
	    memset(local_ivec, 0, sizeof(local_ivec));
	    ivec = local_ivec;
	}
	_krb5_aes_cts_encrypt(data, data, len, k, ivec, encrypt);
    }

    return 0;
}
#endif /* ENABLE_AES */

d1840 2
a1841 2
static krb5_error_code
usage2arcfour (krb5_context context, int *usage)
d1843 1
a1843 1
    switch (*usage) {
d1845 1
a1845 2
	*usage = 1;
	return 0;
d1847 1
a1847 2
	*usage = 2;
	return 0;
d1849 1
a1849 2
	*usage = 8;
	return 0;
d1854 1
a1854 2
	*usage = 7;
	return 0;
d1857 1
a1857 2
	*usage = 8;
	return 0;
d1861 1
a1861 2
	*usage = 11;
	return 0;
a1862 1
	*usage = 0;
d1876 1
a1876 2
	krb5_set_error_string(context, "unknown arcfour usage type %d", *usage);
	return KRB5_PROG_ETYPE_NOSUPP;
d1889 1
a1889 3
    krb5_error_code ret;
    if((ret = usage2arcfour (context, &usage)) != 0)
	return ret;
a1905 1
    1,
a1917 1
    8,
a1928 1
    8,
a1939 1
    8,
a1949 1
    1,
d1952 2
a1953 2
    &checksum_hmac_md5,
    /* &checksum_hmac_md5_enc */ NULL,
a1961 1
    8,
a1972 1
    8,
a1983 1
    8,
a1989 26
#ifdef ENABLE_AES
static struct encryption_type enctype_aes128_cts_hmac_sha1 = {
    ETYPE_AES128_CTS_HMAC_SHA1_96,
    "aes128-cts-hmac-sha1-96",
    16,
    1,
    16,
    &keytype_aes128,
    &checksum_sha1,
    &checksum_hmac_sha1_aes128,
    0,
    AES_CTS_encrypt,
};
static struct encryption_type enctype_aes256_cts_hmac_sha1 = {
    ETYPE_AES256_CTS_HMAC_SHA1_96,
    "aes256-cts-hmac-sha1-96",
    16,
    1,
    16,
    &keytype_aes256,
    &checksum_sha1,
    &checksum_hmac_sha1_aes256,
    0,
    AES_CTS_encrypt,
};
#endif /* ENABLE_AES */
a1993 1
    8,
a2004 1
    1,
a2015 1
    8,
d2027 10
d2043 1
a2043 1
    DES3_CBC_encrypt,
a2054 4
#ifdef ENABLE_AES
    &enctype_aes128_cts_hmac_sha1,
    &enctype_aes256_cts_hmac_sha1,
#endif
d2058 2
a2059 1
    &enctype_des3_cbc_none
d2146 1
a2146 1
			  krb5_enctype **val)
d2150 1
a2150 1
    krb5_enctype *ret;
d2157 1
a2157 1
    ret = malloc(n * sizeof(*ret));
d2182 1
a2182 1
				  krb5_enctype **val)
d2185 1
a2185 1
    krb5_enctype *ret;
d2248 1
a2248 1
    size_t sz, block_sz, checksum_sz, total_sz;
d2253 1
a2253 1
    const struct encryption_type *et = crypto->et;
d2257 4
a2260 6
    sz = et->confoundersize + len;
    block_sz = (sz + et->padsize - 1) &~ (et->padsize - 1); /* pad */
    total_sz = block_sz + checksum_sz;
    p = calloc(1, total_sz);
    if(p == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a2261 1
    }
d2280 5
a2284 2
    if(ret)
	goto fail;
d2288 5
a2292 2
    if(ret)
	goto fail;
d2294 5
a2298 2
    if(ret)
	goto fail;
d2302 1
a2302 3
    ret = (*et->encrypt)(context, dkey, p, block_sz, 1, usage, ivec);
    if (ret)
	goto fail;
d2304 1
a2304 1
    result->length = total_sz;
a2305 4
 fail:
    memset(p, 0, total_sz);
    free(p);
    return ret;
a2307 1

d2320 1
a2320 1
    const struct encryption_type *et = crypto->et;
d2325 1
a2325 1
    block_sz = (sz + et->padsize - 1) &~ (et->padsize - 1); /* pad */
d2348 5
d2354 1
a2354 1
	ret = KRB5_CRYPTO_INTERNAL;
a2355 2
    if(ret)
	goto fail;
d2359 1
a2359 7
    if(ret)
	goto fail;
#ifdef CRYPTO_DEBUG
    krb5_crypto_debug(context, 1, block_sz, crypto->key.key);
#endif
    ret = (*et->encrypt)(context, &crypto->key, p, block_sz, 1, 0, ivec);
    if (ret) {
d2364 4
a2370 4
 fail:
    memset(p, 0, block_sz);
    free(p);
    return ret;
a2385 1
    krb5_error_code ret;
d2398 1
a2398 6
    ret = (*et->encrypt)(context, &crypto->key, tmp, sz, TRUE, usage, ivec);
    if (ret) {
	memset(tmp, 0, sz);
	free(tmp);
	return ret;
    }
d2449 1
a2449 5
    ret = (*et->encrypt)(context, dkey, p, len, 0, usage, ivec);
    if (ret) {
	free(p);
	return ret;
    }
d2507 1
a2507 5
    ret = (*et->encrypt)(context, &crypto->key, p, len, 0, 0, ivec);
    if (ret) {
	free(p);
	return ret;
    }
a2546 1
    krb5_error_code ret;
d2554 1
a2554 5
    ret = (*et->encrypt)(context, &crypto->key, data, len, FALSE, usage, ivec);
    if (ret) {
	free(tmp);
	return ret;
    }
a2843 6
#ifdef ENABLE_AES
    case KEYTYPE_AES128:
    case KEYTYPE_AES256:
	memcpy(key->key->keyvalue.data, k, key->key->keyvalue.length);
	break;
#endif /* ENABLE_AES */
a2950 5
    if((*crypto)->et->keytype->size != key->keyvalue.length) {
	free(*crypto);
	krb5_set_error_string (context, "encryption key has bad length");
	return KRB5_BAD_KEYSIZE;
    }
a2992 9
krb5_crypto_getblocksize(krb5_context context,
			 krb5_crypto crypto,
			 size_t *blocksize)
{
    *blocksize = crypto->et->blocksize;
    return 0;
}

krb5_error_code
d3048 1
a3048 1
    size_t padsize = et->padsize;
d3052 1
a3052 1
    res =  (res + padsize - 1) / padsize * padsize;
d3062 1
a3062 1
    size_t padsize = et->padsize;
d3066 1
a3066 1
    res =  (res + padsize - 1) / padsize * padsize;
d3182 1
a3182 1
    SP_HMAC_SHA1_checksum(context, d, data, 28, &res);
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.73.2.4 2004/03/06 16:38:00 lha Exp $");
d142 7
a148 7
static krb5_error_code hmac(krb5_context context,
			    struct checksum_type *cm, 
			    const void *data, 
			    size_t len, 
			    unsigned usage,
			    struct key_data *keyblock,
			    Checksum *result);
a149 1
static krb5_error_code usage2arcfour (krb5_context, int *);
d596 1
a596 3
	ret = hmac(context, c, data, datalen, 0, &ksign, &result);
	if (ret)
	    krb5_abortx(context, "hmac failed");
d600 2
a601 4
	    ret = hmac(context, c, tmpcksum, result.checksum.length,
		       0, &ksign, &result);
	    if (ret)
		krb5_abortx(context, "hmac failed");
d1387 1
a1387 1
static krb5_error_code
a1400 11
    ipad = malloc(cm->blocksize + len);
    if (ipad == NULL)
	return ENOMEM;
    opad = malloc(cm->blocksize + cm->checksumsize);
    if (opad == NULL) {
	free(ipad);
	return ENOMEM;
    }
    memset(ipad, 0x36, cm->blocksize);
    memset(opad, 0x5c, cm->blocksize);

d1414 4
a1432 2

    return 0;
a1434 30
krb5_error_code
krb5_hmac(krb5_context context,
	  krb5_cksumtype cktype,
	  const void *data,
	  size_t len,
	  unsigned usage, 
	  krb5_keyblock *key,
	  Checksum *result)
{
    struct checksum_type *c = _find_checksum(cktype);
    struct key_data kd;
    krb5_error_code ret;

    if (c == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       cktype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    kd.key = key;
    kd.schedule = NULL;

    ret = hmac(context, c, data, len, usage, &kd, result);

    if (kd.schedule)
	krb5_free_data(context, kd.schedule);

    return ret;
 }

a1445 1
    krb5_error_code ret;
d1450 1
a1450 3
    ret = hmac(context, c, data, len, usage, key, &res);
    if (ret)
	krb5_abortx(context, "hmac failed");
a1474 1
    krb5_error_code ret;
d1478 1
a1478 3
    ret = hmac(context, c, signature, sizeof(signature), 0, key, &ksign_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
d1489 1
a1489 3
    ret = hmac(context, c, tmp, sizeof(tmp), 0, &ksign, result);
    if (ret)
	krb5_abortx(context, "hmac failed");
a1509 1
    krb5_error_code ret;
d1518 1
a1518 3
    ret = hmac(context, c, t, sizeof(t), 0, key, &ksign_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
d1521 1
a1521 3
    ret = hmac(context, c, data, len, 0, &ksign, result);
    if (ret)
	krb5_abortx(context, "hmac failed");
d1743 7
a1749 7
create_checksum (krb5_context context,
		 struct checksum_type *ct,
		 krb5_crypto crypto,
		 unsigned usage,
		 void *data,
		 size_t len,
		 Checksum *result)
d1754 1
a1754 1
    
d1772 8
a1779 15
static int
arcfour_checksum_p(struct checksum_type *ct, krb5_crypto crypto)
{
    return (ct->type == CKSUMTYPE_HMAC_MD5) &&
	(crypto->key.key->keytype == KEYTYPE_ARCFOUR);
}

krb5_error_code
krb5_create_checksum(krb5_context context,
		     krb5_crypto crypto,
		     krb5_key_usage usage,
		     int type,
		     void *data,
		     size_t len,
		     Checksum *result)
a1781 1
    unsigned keyusage;
a1782 1
    /* type 0 -> pick from crypto */
d1796 2
d1799 12
a1810 8
    if (arcfour_checksum_p(ct, crypto)) {
	keyusage = usage;
	usage2arcfour(context, &keyusage);
    } else
	keyusage = CHECKSUM_USAGE(usage);

    return create_checksum(context, ct, crypto, keyusage,
			   data, len, result);
d1828 1
a1828 1
    if (ct == NULL) {
d1874 2
a1875 18
    struct checksum_type *ct;
    unsigned keyusage;

    ct = _find_checksum(cksum->cksumtype);
    if(ct == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       cksum->cksumtype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }

    if (arcfour_checksum_p(ct, crypto)) {
	keyusage = usage;
	usage2arcfour(context, &keyusage);
    } else
	keyusage = CHECKSUM_USAGE(usage);

    return verify_checksum(context, crypto, keyusage,
			   data, len, cksum);
d2111 1
a2111 1
	krb5_abortx(context, "invalid use of AES_CTS_encrypt");
a2150 1
    krb5_error_code ret;
d2160 1
a2160 3
    ret = hmac(NULL, c, t, sizeof(t), 0, key, &k1_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
d2173 1
a2173 3
    ret = hmac(NULL, c, cdata + 16, len - 16, 0, &ke, &cksum);
    if (ret)
	krb5_abortx(context, "hmac failed");
d2181 1
a2181 3
    ret = hmac(NULL, c, data, 16, 0, &ke, &k3_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
a2207 1
    krb5_error_code ret;
d2217 1
a2217 3
    ret = hmac(NULL, c, t, sizeof(t), 0, key, &k1_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
d2230 1
a2230 3
    ret = hmac(NULL, c, cdata, 16, 0, &ke, &k3_c);
    if (ret)
	krb5_abortx(context, "hmac failed");
d2241 1
a2241 3
    ret = hmac(NULL, c, cdata + 16, len - 16, 0, &ke, &cksum);
    if (ret)
	krb5_abortx(context, "hmac failed");
d2258 1
a2258 1
 * draft-brezak-win2k-krb-rc4-hmac-04.txt
d2265 17
a2281 2
    case KRB5_KU_AS_REP_ENC_PART : /* 3 */
    case KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : /* 9 */
d2284 4
a2287 2
    case KRB5_KU_USAGE_SEAL :  /* 22 */
	*usage = 13;
d2289 1
a2289 4
    case KRB5_KU_USAGE_SIGN : /* 23 */
        *usage = 15;
        return 0;
    case KRB5_KU_USAGE_SEQ: /* 24 */
d2292 11
d2304 2
a2305 1
	return 0;
a2732 1
			  et->keyed_checksum,
d2735 1
a2801 1
			  et->checksum,
d2804 1
a2897 5
    if (((len - checksum_sz) % et->padsize) != 0) {
	krb5_clear_error_string(context);
	return KRB5_BAD_MSIZE;
    }

a2965 5
    if ((len % et->padsize) != 0) {
	krb5_clear_error_string(context);
	return KRB5_BAD_MSIZE;
    }

d3024 2
a3025 1
    unsigned char *p;
d3028 2
a3029 7
    if ((len % et->padsize) != 0) {
	krb5_clear_error_string(context);
	return KRB5_BAD_MSIZE;
    }

    p = malloc (len);
    if (p == NULL) {
a3032 1
    memcpy(p, data, len);
d3034 1
a3034 1
    ret = (*et->encrypt)(context, &crypto->key, p, len, FALSE, usage, ivec);
d3036 1
a3036 1
	free(p);
d3040 3
a3042 7
    memmove (p, p + cksum_sz + et->confoundersize, sz);
    result->data = realloc(p, sz);
    if(result->data == NULL) {
	free(p);
	krb5_set_error_string(context, "malloc: out of memory");
	return ENOMEM;
    }
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2005 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: crypto.c,v 1.120.2.1 2005/08/11 07:56:11 lha Exp $");
a57 1
    void *params;
a59 2
#define kcrypto_oid_enc(n) { sizeof(n)/sizeof(n[0]), n }

a68 2
#define F_DISABLED	64	/* enctype/checksum disabled */
#define F_PADCMS	128	/* padding done like in CMS */
a81 1
    size_t minsize;
d87 1
a87 1
    void (*schedule)(krb5_context, struct key_data *, const void *);
a88 5
    void (*random_to_key)(krb5_context, krb5_keyblock*, const void*, size_t);
    krb5_error_code (*get_params)(krb5_context, const krb5_data *,
				  void **, krb5_data *);
    krb5_error_code (*set_params)(krb5_context, const void *,
				  const krb5_data *, krb5_data *);
a111 1
    heim_oid *oid;
d150 1
a150 2
static krb5_error_code usage2arcfour (krb5_context, unsigned *);
static void xor (DES_cblock *, const unsigned char *);
a155 3
static HEIMDAL_MUTEX crypto_mutex = HEIMDAL_MUTEX_INITIALIZER;


d160 1
a160 1
    DES_cblock *k = key->keyvalue.data;
d162 3
a164 3
	krb5_generate_random_block(k, sizeof(DES_cblock));
	DES_set_odd_parity(k);
    } while(DES_is_weak_key(k));
d169 1
a169 2
		  struct key_data *key,
		  const void *params)
d171 1
a171 1
    DES_set_key(key->key->keyvalue.data, key->schedule->data);
d175 1
a175 1
DES_string_to_key_int(unsigned char *data, size_t length, DES_cblock *key)
d177 1
a177 1
    DES_key_schedule schedule;
d196 2
a197 8
    DES_set_odd_parity(key);
    if(DES_is_weak_key(key))
	(*key)[7] ^= 0xF0;
    DES_set_key(key, &schedule);
    DES_cbc_cksum((void*)data, key, length, &schedule, key);
    memset(&schedule, 0, sizeof(schedule));
    DES_set_odd_parity(key);
    if(DES_is_weak_key(key))
d199 4
d215 1
a215 1
    DES_cblock tmp;
d246 1
a246 1
			    DES_cblock *key)
d259 1
a259 1
    memcpy(key, crypt(password, "p1") + 2, sizeof(DES_cblock));
d264 1
a264 1
    for (i = 0; i < sizeof(DES_cblock); i++)
d266 1
a266 1
    DES_set_odd_parity (key);
d275 1
a275 1
				 DES_cblock *key)
d277 3
a279 3
    DES_key_schedule schedule;
    DES_cblock temp_key;
    DES_cblock ivec;
d295 3
a297 3
    DES_set_odd_parity (&temp_key);
    DES_set_key (&temp_key, &schedule);
    DES_cbc_cksum ((void*)password, &ivec, passlen, &schedule, &ivec);
d300 3
a302 3
    DES_set_odd_parity (&temp_key);
    DES_set_key (&temp_key, &schedule);
    DES_cbc_cksum ((void*)password, key, passlen, &schedule, &ivec);
d308 1
a308 1
    DES_set_odd_parity (key);
d319 1
a319 1
    DES_cblock tmp;
a330 17
krb5_DES_random_to_key(krb5_context context,
		       krb5_keyblock *key,
		       const void *data,
		       size_t size)
{
    DES_cblock *k = key->keyvalue.data;
    memcpy(k, data, key->keyvalue.length);
    DES_set_odd_parity(k);
    if(DES_is_weak_key(k))
	xor(k, (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
}

/*
 *
 */

static void
d334 1
a334 1
    DES_cblock *k = key->keyvalue.data;
d336 7
a342 7
	krb5_generate_random_block(k, 3 * sizeof(DES_cblock));
	DES_set_odd_parity(&k[0]);
	DES_set_odd_parity(&k[1]);
	DES_set_odd_parity(&k[2]);
    } while(DES_is_weak_key(&k[0]) ||
	    DES_is_weak_key(&k[1]) ||
	    DES_is_weak_key(&k[2]));
d347 1
a347 2
	      struct key_data *key,
	      const void *params)
d349 5
a353 5
    DES_cblock *k = key->key->keyvalue.data;
    DES_key_schedule *s = key->schedule->data;
    DES_set_key(&k[0], &s[0]);
    DES_set_key(&k[1], &s[1]);
    DES_set_key(&k[2], &s[2]);
d361 1
a361 1
xor (DES_cblock *key, const unsigned char *b)
d385 1
a385 1
    DES_cblock keys[3];
d396 2
a397 2
	DES_cblock ivec;
	DES_key_schedule s[3];
d404 2
a405 2
	    DES_set_odd_parity(keys + i);
	    if(DES_is_weak_key(keys + i))
d407 1
a407 1
	    DES_set_key(keys + i, &s[i]);
d410 1
a410 1
	DES_ede3_cbc_encrypt(tmp,
d412 1
a412 1
			     &s[0], &s[1], &s[2], &ivec, DES_ENCRYPT);
d417 2
a418 2
	    DES_set_odd_parity(keys + i);
	    if(DES_is_weak_key(keys + i))
d460 4
d465 1
a465 4
DES3_random_to_key(krb5_context context,
		   krb5_keyblock *key,
		   const void *data,
		   size_t size)
d467 2
a468 26
    unsigned char *x = key->keyvalue.data;
    const u_char *q = data;
    DES_cblock *k;
    int i, j;

    memset(x, 0, sizeof(x));
    for (i = 0; i < 3; ++i) {
	unsigned char foo;
	for (j = 0; j < 7; ++j) {
	    unsigned char b = q[7 * i + j];

	    x[8 * i + j] = b;
	}
	foo = 0;
	for (j = 6; j >= 0; --j) {
	    foo |= q[7 * i + j] & 1;
	    foo <<= 1;
	}
	x[8 * i + 7] = foo;
    }
    k = key->keyvalue.data;
    for (i = 0; i < 3; i++) {
	DES_set_odd_parity(&k[i]);
	if(DES_is_weak_key(&k[i]))
	    xor(&k[i], (const unsigned char*)"\0\0\0\0\0\0\0\xf0");
    }    
a470 4
/*
 * ARCFOUR
 */

d472 1
a472 3
ARCFOUR_schedule(krb5_context context, 
		 struct key_data *kd,
		 const void *params)
d511 1
d518 4
a521 4
krb5_error_code KRB5_LIB_FUNCTION
_krb5_PKCS5_PBKDF2(krb5_context context, krb5_cksumtype cktype,
		   krb5_data password, krb5_salt salt, u_int32_t iter,
		   krb5_keytype type, krb5_keyblock *key)
a623 2
int _krb5_AES_string_to_default_iterator = 4096;

d638 1
a638 1
	iter = _krb5_AES_string_to_default_iterator - 1;
d651 2
a652 2
    ret = _krb5_PKCS5_PBKDF2(context, CKSUMTYPE_SHA1, password, salt, 
			     iter, enctype, key);
d660 4
a663 2
    krb5_free_keyblock_contents(context, key);
    if (ret == 0) {
a670 5
struct krb5_aes_schedule {
    AES_KEY ekey;
    AES_KEY dkey;
};

d672 1
a672 3
AES_schedule(krb5_context context,
	     struct key_data *kd,
	     const void *params)
d674 1
a674 1
    struct krb5_aes_schedule *key = kd->schedule->data;
d676 3
a678 112

    memset(key, 0, sizeof(*key));
    AES_set_encrypt_key(kd->key->keyvalue.data, bits, &key->ekey);
    AES_set_decrypt_key(kd->key->keyvalue.data, bits, &key->dkey);
}

/*
 * RC2
 */

struct _RC2_params {
    int maximum_effective_key;
};

static krb5_error_code
rc2_get_params(krb5_context context,
	       const krb5_data *data,
	       void **params,
	       krb5_data *ivec)
{
    RC2CBCParameter rc2params;
    struct _RC2_params *p;
    krb5_error_code ret;
    size_t size;

    ret = decode_RC2CBCParameter(data->data, data->length, &rc2params, &size);
    if (ret) {
	krb5_set_error_string(context, "Can't decode RC2 parameters");
	return ret;
    }
    p = malloc(sizeof(*p));
    if (p == NULL) {
	free_RC2CBCParameter(&rc2params);
	krb5_set_error_string(context, "malloc - out of memory");
	return ENOMEM;
    }
    /* XXX  */
    switch(rc2params.rc2ParameterVersion) {
    case 160:
	p->maximum_effective_key = 40;
	break;
    case 120:
	p->maximum_effective_key = 64;
	break;
    case 58:
	p->maximum_effective_key = 128;
	break;
	
    }
    if (ivec)
	ret = copy_octet_string(&rc2params.iv, ivec);
    free_RC2CBCParameter(&rc2params);
    *params = p;

    return ret;
}

static krb5_error_code
rc2_set_params(krb5_context context,
	       const void *params,
	       const krb5_data *ivec,
	       krb5_data *data)
{
    RC2CBCParameter rc2params;
    const struct _RC2_params *p = params;
    int maximum_effective_key = 128;
    krb5_error_code ret;
    size_t size;

    memset(&rc2params, 0, sizeof(rc2params));

    if (p)
	maximum_effective_key = p->maximum_effective_key;

    /* XXX */
    switch(maximum_effective_key) {
    case 40:
	rc2params.rc2ParameterVersion = 160;
	break;
    case 64:
	rc2params.rc2ParameterVersion = 120;
	break;
    case 128:
	rc2params.rc2ParameterVersion = 58;
	break;
    }
    ret = copy_octet_string(ivec, &rc2params.iv);
    if (ret)
	return ret;

    ASN1_MALLOC_ENCODE(RC2CBCParameter, data->data, data->length,
		       &rc2params, &size, ret);
    if (ret == 0 && size != data->length)
	krb5_abortx(context, "Internal asn1 encoder failure");
    free_RC2CBCParameter(&rc2params);

    return ret;
}

static void
rc2_schedule(krb5_context context,
	     struct key_data *kd,
	     const void *params)
{
    const struct _RC2_params *p = params;
    int maximum_effective_key = 128;
    if (p)
	maximum_effective_key = p->maximum_effective_key;
    RC2_set_key (kd->schedule->data,
		 kd->key->keyvalue.length,
		 kd->key->keyvalue.data,
		 maximum_effective_key);
a680 1

d685 1
a685 40
static struct salt_type des_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	krb5_DES_string_to_key
    },
    {
	KRB5_AFS3_SALT,
	"afs3-salt",
	DES_AFS3_string_to_key
    },
    { 0 }
};

static struct salt_type des3_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	DES3_string_to_key
    },
    { 0 }
};

static struct salt_type des3_salt_derived[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	DES3_string_to_key_derived
    },
    { 0 }
};

static struct salt_type AES_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	AES_string_to_key
    },
    { 0 }
};
d687 1
a687 8
static struct salt_type arcfour_salt[] = {
    {
	KRB5_PW_SALT,
	"pw-salt",
	ARCFOUR_string_to_key
    },
    { 0 }
};
d689 2
a690 3
/*
 *
 */
d692 1
a692 1
static struct key_type keytype_null = {
a697 1
    0,
d703 1
a703 1
static struct key_type keytype_des = {
d707 2
a708 3
    sizeof(DES_cblock),
    sizeof(DES_cblock),
    sizeof(DES_key_schedule),
d711 1
a711 2
    des_salt,
    krb5_DES_random_to_key
d714 1
a714 1
static struct key_type keytype_des3 = {
d718 2
a719 3
    3 * sizeof(DES_cblock), 
    3 * sizeof(DES_cblock), 
    3 * sizeof(DES_key_schedule), 
d722 1
a722 2
    des3_salt,
    DES3_random_to_key
d725 1
a725 1
static struct key_type keytype_des3_derived = {
d729 2
a730 3
    3 * sizeof(DES_cblock),
    3 * sizeof(DES_cblock),
    3 * sizeof(DES_key_schedule), 
d733 1
a733 2
    des3_salt_derived,
    DES3_random_to_key
d736 2
a737 1
static struct key_type keytype_aes128 = {
d742 1
a742 2
    16,
    sizeof(struct krb5_aes_schedule),
d748 1
a748 13
static struct key_type keytype_aes192 = {
    KEYTYPE_AES192,
    "aes-192",
    192,
    24,
    24,
    sizeof(struct krb5_aes_schedule),
    NULL,
    AES_schedule,
    AES_salt
};

static struct key_type keytype_aes256 = {
d752 2
a753 3
    32,
    32,
    sizeof(struct krb5_aes_schedule),
d758 1
d760 1
a760 1
static struct key_type keytype_arcfour = {
a764 1
    16,
d766 1
a766 1
    NULL,
d771 1
a771 16
static struct key_type keytype_rc2 = {
    KEYTYPE_RC2,
    "rc2",
    128,
    16,
    1,
    sizeof(RC2_KEY),
    NULL,
    rc2_schedule,
    NULL, /* XXX salt */
    NULL,
    rc2_get_params,
    rc2_set_params
};

static struct key_type *keytypes[] = {
d776 1
a777 1
    &keytype_aes192,
d779 1
a779 1
    &keytype_rc2,
d796 53
a848 1
krb5_error_code KRB5_LIB_FUNCTION
d877 1
a877 1
krb5_error_code KRB5_LIB_FUNCTION
d902 1
a902 1
krb5_error_code KRB5_LIB_FUNCTION
d931 1
a931 1
krb5_error_code KRB5_LIB_FUNCTION
d939 1
a939 1
krb5_error_code KRB5_LIB_FUNCTION
d957 1
a957 1
krb5_error_code KRB5_LIB_FUNCTION
d970 1
a970 1
krb5_error_code KRB5_LIB_FUNCTION
d989 1
a989 1
krb5_error_code KRB5_LIB_FUNCTION
d1019 1
a1019 1
krb5_error_code KRB5_LIB_FUNCTION
d1032 1
a1032 16
krb5_error_code KRB5_LIB_FUNCTION
krb5_string_to_key_salt_opaque (krb5_context context,
				krb5_enctype enctype,
				const char *password,
				krb5_salt salt,
				krb5_data opaque,
				krb5_keyblock *key)
{
    krb5_data pw;
    pw.data = (void*)password;
    pw.length = strlen(password);
    return krb5_string_to_key_data_salt_opaque(context, enctype, 
					       pw, salt, opaque, key);
}

krb5_error_code KRB5_LIB_FUNCTION
d1050 1
a1050 1
krb5_error_code KRB5_LIB_FUNCTION
d1065 1
a1065 1
krb5_error_code KRB5_LIB_FUNCTION
d1080 1
a1080 1
krb5_error_code KRB5_LIB_FUNCTION
d1106 1
a1106 2
	      struct key_data *key,
	      const void *params)
d1127 1
a1127 1
    (*kt->schedule)(context, key, params);
d1187 1
a1187 1
    DES_cblock ivec;
d1196 1
a1196 1
    DES_cbc_encrypt(p, 
d1215 1
a1215 1
    DES_cblock ivec;
d1219 1
a1219 1
    DES_cbc_encrypt(C->checksum.data,
d1262 1
a1262 1
    DES_cblock ivec;
d1271 1
a1271 1
    DES_cbc_encrypt(p, 
d1290 2
a1291 2
    DES_cblock ivec;
    DES_key_schedule *sched = key->schedule->data;
d1295 1
a1295 1
    DES_cbc_encrypt(C->checksum.data, 
d1298 1
a1298 1
		    &sched[0],
d1323 1
a1323 1
    DES_cblock ivec;
d1325 1
a1325 1
    DES_key_schedule *sched = key->schedule->data;
d1333 1
a1333 1
    DES_ede3_cbc_encrypt(p, 
d1336 1
a1336 1
			 &sched[0], &sched[1], &sched[2],
d1352 2
a1353 2
    DES_cblock ivec;
    DES_key_schedule *sched = key->schedule->data;
d1357 1
a1357 1
    DES_ede3_cbc_encrypt(C->checksum.data, 
d1360 1
a1360 1
			 &sched[0], &sched[1], &sched[2],
d1449 1
a1449 1
krb5_error_code KRB5_LIB_FUNCTION
d1581 1
a1581 1
static struct checksum_type checksum_none = {
d1586 1
a1586 1
    0,
d1590 1
a1590 1
static struct checksum_type checksum_crc32 = {
d1599 1
a1599 1
static struct checksum_type checksum_rsa_md4 = {
d1608 1
a1608 1
static struct checksum_type checksum_rsa_md4_des = {
d1618 1
a1618 1
static struct checksum_type checksum_des_mac = { 
d1626 1
a1626 1
static struct checksum_type checksum_des_mac_k = {
d1634 1
a1634 1
static struct checksum_type checksum_rsa_md4_des_k = {
d1644 1
a1644 1
static struct checksum_type checksum_rsa_md5 = {
d1653 1
a1653 1
static struct checksum_type checksum_rsa_md5_des = {
d1662 1
a1662 1
static struct checksum_type checksum_rsa_md5_des3 = {
d1671 1
a1671 1
static struct checksum_type checksum_sha1 = {
d1680 1
a1680 1
static struct checksum_type checksum_hmac_sha1_des3 = {
d1690 2
a1691 1
static struct checksum_type checksum_hmac_sha1_aes128 = {
d1701 1
a1701 1
static struct checksum_type checksum_hmac_sha1_aes256 = {
d1710 1
d1712 1
a1712 1
static struct checksum_type checksum_hmac_md5 = {
d1722 1
a1722 1
static struct checksum_type checksum_hmac_md5_enc = {
d1732 1
a1732 1
static struct checksum_type *checksum_types[] = {
d1747 1
d1750 1
d1795 1
a1795 1
	ret = _key_schedule(context, *key, crypto->params);
a1811 4
    if (ct->flags & F_DISABLED) {
	krb5_clear_error_string (context);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
d1836 1
a1836 1
krb5_error_code KRB5_LIB_FUNCTION
d1888 1
a1888 1
    if (ct == NULL || (ct->flags & F_DISABLED)) {
d1926 1
a1926 1
krb5_error_code KRB5_LIB_FUNCTION
d1954 1
a1954 25
krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_get_checksum_type(krb5_context context,
                              krb5_crypto crypto,
			      krb5_cksumtype *type)
{
    struct checksum_type *ct = NULL;
    
    if (crypto != NULL) {
        ct = crypto->et->keyed_checksum;
        if (ct == NULL)
            ct = crypto->et->checksum;
    }
    
    if (ct == NULL) {
	krb5_set_error_string (context, "checksum type not found");
        return KRB5_PROG_SUMTYPE_NOSUPP;
    }    

    *type = ct->type;
    
    return 0;      
}


krb5_error_code KRB5_LIB_FUNCTION
d1969 1
a1969 1
krb5_boolean KRB5_LIB_FUNCTION
d1975 2
a1976 3
	if (context)
	    krb5_set_error_string (context, "checksum type %d not supported",
				   type);
d1982 1
a1982 1
krb5_boolean KRB5_LIB_FUNCTION
d1988 2
a1989 3
	if (context)
	    krb5_set_error_string (context, "checksum type %d not supported",
				   type);
a1994 15
krb5_error_code KRB5_LIB_FUNCTION
krb5_checksum_disable(krb5_context context,
		      krb5_cksumtype type)
{
    struct checksum_type *ct = _find_checksum(type);
    if(ct == NULL) {
	if (context)
	    krb5_set_error_string (context, "checksum type %d not supported",
				   type);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    ct->flags |= F_DISABLED;
    return 0;
}

d2020 2
a2021 2
    DES_cblock ivec;
    DES_key_schedule *s = key->schedule->data;
d2023 1
a2023 1
    DES_cbc_encrypt(data, data, len, s, &ivec, encrypt);
d2036 2
a2037 2
    DES_cblock ivec;
    DES_key_schedule *s = key->schedule->data;
d2039 1
a2039 1
    DES_cbc_encrypt(data, data, len, s, &ivec, encrypt);
d2052 2
a2053 2
    DES_cblock local_ivec;
    DES_key_schedule *s = key->schedule->data;
d2058 1
a2058 1
    DES_ede3_cbc_encrypt(data, data, len, &s[0], &s[1], &s[2], ivec, encrypt);
d2071 1
a2071 1
    DES_cblock ivec;
d2073 1
a2073 1
    DES_key_schedule *s = key->schedule->data;
d2076 1
a2076 1
    DES_cfb64_encrypt(data, data, len, s, &ivec, &num, encrypt);
d2089 2
a2090 2
    DES_cblock ivec;
    DES_key_schedule *s = key->schedule->data;
d2093 1
a2093 1
    DES_pcbc_encrypt(data, data, len, s, &ivec, encrypt);
d2097 2
d2103 1
a2103 1
void KRB5_LIB_FUNCTION
d2106 1
a2106 1
		      unsigned char *ivec, const int encrypt)
d2117 1
a2117 1
    if (encrypt) {
a2136 1
	memcpy(ivec, out - AES_BLOCK_SIZE, AES_BLOCK_SIZE);
d2139 2
a2140 2
	unsigned char tmp2[AES_BLOCK_SIZE];
	unsigned char tmp3[AES_BLOCK_SIZE];
a2154 1
	memcpy(tmp, in, AES_BLOCK_SIZE); /* save last iv */
a2165 1
	memcpy(ivec, tmp, AES_BLOCK_SIZE);
d2178 1
a2178 1
    struct krb5_aes_schedule *aeskey = key->schedule->data;
a2179 1
    AES_KEY *k;
d2182 1
a2182 1
	k = &aeskey->ekey;
d2184 1
a2184 1
	k = &aeskey->dkey;
d2203 1
a2203 49

static krb5_error_code 
AES_CBC_encrypt(krb5_context context,
                struct key_data *key, 
                void *data,
                size_t len,  
                krb5_boolean encrypt, 
                int usage,
                void *ivec)
{
    struct krb5_aes_schedule *aeskey = key->schedule->data;
    char local_ivec[AES_BLOCK_SIZE];
    AES_KEY *k;

    if (encrypt)
	k = &aeskey->ekey;
    else
	k = &aeskey->dkey;

    if(ivec == NULL) {
        ivec = &local_ivec;
        memset(local_ivec, 0, sizeof(local_ivec));
    }
    AES_cbc_encrypt(data, data, len, k, ivec, encrypt);
    return 0;
}

/*
 * RC2
 */

static krb5_error_code 
RC2_CBC_encrypt(krb5_context context,
                struct key_data *key, 
                void *data,
                size_t len,  
                krb5_boolean encrypt, 
                int usage,
                void *ivec)
{
    unsigned char local_ivec[8];
    RC2_KEY *s = key->schedule->data; 
    if(ivec == NULL) {
        ivec = &local_ivec;
        memset(local_ivec, 0, sizeof(local_ivec));
    }
    RC2_cbc_encrypt(data, data, len, s, ivec, encrypt);
    return 0;
}
d2216 1
a2216 1
		   unsigned usage,
d2279 1
a2279 1
		   unsigned usage,
d2352 1
a2352 1
usage2arcfour (krb5_context context, unsigned *usage)
d2383 1
a2383 3
    unsigned keyusage = usage;

    if((ret = usage2arcfour (context, &keyusage)) != 0)
d2387 1
a2387 1
	return ARCFOUR_subencrypt (context, key, data, len, keyusage, ivec);
d2389 1
a2389 1
	return ARCFOUR_subdecrypt (context, key, data, len, keyusage, ivec);
a2399 1
    NULL,
d2406 1
a2406 1
    F_DISABLED,
a2411 1
    NULL,
a2423 1
    NULL,
a2435 1
    NULL,
a2447 1
    NULL,
d2453 1
a2453 1
    NULL,
a2459 1
    NULL,
a2471 1
    NULL,
a2483 1
    NULL,
d2493 1
a2496 1
    NULL,
d2503 1
a2503 1
    F_DERIVED,
a2508 1
    NULL,
d2515 1
a2515 1
    F_DERIVED,
d2518 1
a2518 45
static unsigned aes_128_cbc_num[] = { 2, 16, 840, 1, 101, 3, 4, 1, 2 };
static heim_oid aes_128_cbc_oid = kcrypto_oid_enc(aes_128_cbc_num);
static struct encryption_type enctype_aes128_cbc_none = {
    ETYPE_AES128_CBC_NONE,
    "aes128-cbc-none",
    &aes_128_cbc_oid,
    16,
    16,
    16,
    &keytype_aes128,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    AES_CBC_encrypt,
};
static unsigned aes_192_cbc_num[] = { 2, 16, 840, 1, 101, 3, 4, 1, 22 };
static heim_oid aes_192_cbc_oid = kcrypto_oid_enc(aes_192_cbc_num);
static struct encryption_type enctype_aes192_cbc_none = {
    ETYPE_AES192_CBC_NONE,
    "aes192-cbc-none",
    &aes_192_cbc_oid,
    16,
    16,
    16,
    &keytype_aes192,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    AES_CBC_encrypt,
};
static unsigned aes_256_cbc_num[] = { 2, 16, 840, 1, 101, 3, 4, 1, 42 };
static heim_oid aes_256_cbc_oid = kcrypto_oid_enc(aes_256_cbc_num);
static struct encryption_type enctype_aes256_cbc_none = {
    ETYPE_AES256_CBC_NONE,
    "aes256-cbc-none",
    &aes_256_cbc_oid,
    16,
    16,
    16,
    &keytype_aes256,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    AES_CBC_encrypt,
};
a2521 1
    NULL,
a2533 1
    NULL,
a2545 1
    NULL,
a2554 15
static unsigned des_ede3_cbc_num[] = { 1, 2, 840, 113549, 3, 7 };
static heim_oid des_ede3_cbc_oid = kcrypto_oid_enc(des_ede3_cbc_num);
static struct encryption_type enctype_des3_cbc_none_cms = {
    ETYPE_DES3_CBC_NONE_CMS,
    "des3-cbc-none-cms",
    &des_ede3_cbc_oid,
    8,
    8,
    0,
    &keytype_des3_derived,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    DES3_CBC_encrypt,
};
a2557 1
    NULL,
a2566 15
static unsigned rc2CBC_num[] = { 1, 2, 840, 113549, 3, 2 };
static heim_oid rc2CBC_oid = kcrypto_oid_enc(rc2CBC_num);
static struct encryption_type enctype_rc2_cbc_none = {
    ETYPE_RC2_CBC_NONE,
    "rc2-cbc-none",
    &rc2CBC_oid,
    8,
    8,
    0,
    &keytype_rc2,
    &checksum_none,
    NULL,
    F_PSEUDO|F_PADCMS,
    RC2_CBC_encrypt,
};
d2577 1
d2580 1
a2580 3
    &enctype_aes128_cbc_none,
    &enctype_aes192_cbc_none,
    &enctype_aes256_cbc_none,
d2584 1
a2584 3
    &enctype_des3_cbc_none,
    &enctype_des3_cbc_none_cms,
    &enctype_rc2_cbc_none
d2601 1
a2601 1
krb5_error_code KRB5_LIB_FUNCTION
d2621 1
a2621 1
krb5_error_code KRB5_LIB_FUNCTION
d2637 1
a2637 36
krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_to_oid(krb5_context context,
		    krb5_enctype etype,
		    heim_oid *oid)
{
    struct encryption_type *et = _find_enctype(etype);
    if(et == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    if(et->oid == NULL) {
	krb5_set_error_string (context, "%s have not oid", et->name);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    krb5_clear_error_string(context);
    return copy_oid(et->oid, oid);
}

krb5_error_code KRB5_LIB_FUNCTION
_krb5_oid_to_enctype(krb5_context context,
		     const heim_oid *oid,
		     krb5_enctype *etype)
{
    int i;
    for(i = 0; i < num_etypes; i++) {
	if(etypes[i]->oid && heim_oid_cmp(etypes[i]->oid, oid) == 0) {
	    *etype = etypes[i]->type;
	    return 0;
	}
    }
    krb5_set_error_string(context, "enctype for oid not supported");
    return KRB5_PROG_ETYPE_NOSUPP;
}

krb5_error_code KRB5_LIB_FUNCTION
d2653 1
a2653 1
krb5_error_code KRB5_LIB_FUNCTION
d2667 1
a2667 1
krb5_error_code KRB5_LIB_FUNCTION
d2703 1
a2703 1
krb5_error_code KRB5_LIB_FUNCTION
d2729 1
a2729 1
krb5_error_code KRB5_LIB_FUNCTION
d2733 1
a2733 30
    struct encryption_type *e = _find_enctype(etype);
    if(e == NULL) {
	krb5_set_error_string (context, "encryption type %d not supported",
			       etype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    if (e->flags & F_DISABLED) {
	krb5_set_error_string (context, "encryption type %s is disabled",
			       e->name);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_cksumtype_valid(krb5_context context, 
		     krb5_cksumtype ctype)
{
    struct checksum_type *c = _find_checksum(ctype);
    if (c == NULL) {
	krb5_set_error_string (context, "checksum type %d not supported",
			       ctype);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    if (c->flags & F_DISABLED) {
	krb5_set_error_string (context, "checksum type %s is disabled",
			       c->name);
	return KRB5_PROG_SUMTYPE_NOSUPP;
    }
    return 0;
a2735 1

d2737 1
a2737 1
krb5_boolean KRB5_LIB_FUNCTION
d2815 1
a2815 1
    ret = _key_schedule(context, dkey, crypto->params);
d2842 1
a2842 1
    size_t sz, block_sz, checksum_sz, padsize = 0;
a2851 5
    if ((et->flags & F_PADCMS) && et->padsize != 1) {
	padsize = et->padsize - (sz % et->padsize);
	if (padsize == et->padsize)
	    block_sz += et->padsize;
    }
d2881 1
a2881 1
    ret = _key_schedule(context, &crypto->key, crypto->params);
a2883 6
    if (et->flags & F_PADCMS) {
	int i;
	q = p + len + checksum_sz + et->confoundersize;
	for (i = 0; i < padsize; i++)
	    q[i] = padsize;
    }
d2981 1
a2981 1
    ret = _key_schedule(context, dkey, crypto->params);
d3048 1
a3048 1
    ret = _key_schedule(context, &crypto->key, crypto->params);
d3131 1
a3131 1
krb5_error_code KRB5_LIB_FUNCTION
d3150 1
a3150 1
krb5_error_code KRB5_LIB_FUNCTION
d3161 1
a3161 1
krb5_error_code KRB5_LIB_FUNCTION
d3179 1
a3179 1
krb5_error_code KRB5_LIB_FUNCTION
d3198 1
a3198 1
krb5_error_code KRB5_LIB_FUNCTION
d3210 1
a3210 1
krb5_error_code KRB5_LIB_FUNCTION
d3233 1
a3238 1
	int fd;
d3241 3
a3243 5
	    ssize_t ret;
	    ret = read(fd, buf, sizeof(buf));
	    if (ret > 0)
		RAND_add(buf, ret, 0.0);
	    close(fd);
d3275 1
a3275 1
void KRB5_LIB_FUNCTION
a3279 1
    HEIMDAL_MUTEX_lock(&crypto_mutex);
a3285 1
    HEIMDAL_MUTEX_unlock(&crypto_mutex);
d3291 1
a3291 1
void KRB5_LIB_FUNCTION
d3294 3
a3296 3
    DES_cblock key, out;
    static DES_cblock counter;
    static DES_key_schedule schedule;
a3299 1
    HEIMDAL_MUTEX_lock(&crypto_mutex);
d3301 2
a3302 2
	DES_new_random_key(&key);
	DES_set_key(&key, &schedule);
d3304 1
a3304 2
	DES_new_random_key(&counter);
	initialized = 1;
a3305 1
    HEIMDAL_MUTEX_unlock(&crypto_mutex);
d3307 1
a3307 1
	DES_ecb_encrypt(&counter, &out, &schedule, DES_ENCRYPT);
d3322 9
a3330 1
    DES3_random_to_key(context, key->key, k, len);
d3332 12
d3348 3
d3365 1
a3365 3
    /* since RC2 is only the weird crypto alg with parameter and this
     * function not defined with work with RC2, this is ok */
    ret = _key_schedule(context, key, NULL);
d3411 1
d3416 1
a3423 4
    if (key->schedule) {
	krb5_free_data(context, key->schedule);
	key->schedule = NULL;
    }
d3443 1
a3443 1
krb5_error_code KRB5_LIB_FUNCTION
d3503 1
a3503 1
krb5_error_code KRB5_LIB_FUNCTION
d3518 1
a3518 1
    if((*crypto)->et == NULL || ((*crypto)->et->flags & F_DISABLED)) {
a3519 1
	*crypto = NULL;
d3524 1
a3524 1
    if((*crypto)->et->keytype->minsize > key->keyvalue.length) {
a3525 1
	*crypto = NULL;
a3531 1
	*crypto = NULL;
a3536 1
    (*crypto)->params = NULL;
d3556 1
a3556 1
krb5_error_code KRB5_LIB_FUNCTION
a3565 1
    free(crypto->params);
d3570 1
a3570 69
krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_get_params(krb5_context context,
		       const krb5_crypto crypto,
		       const krb5_data *params,
		       krb5_data *ivec)
{
    krb5_error_code (*gp)(krb5_context, const krb5_data *,void **,krb5_data *);
    krb5_error_code ret;

    gp = crypto->et->keytype->get_params;
    if (gp) {
	if (crypto->params) {
	    krb5_set_error_string(context,
				  "krb5_crypto_get_params called "
				  "more than once");
	    return KRB5_PROG_ETYPE_NOSUPP;
	}
	ret = (*gp)(context, params, &crypto->params, ivec);
    } else {
	size_t size;
	if (ivec == NULL)
	    return 0;
	ret = decode_CBCParameter(params->data, params->length, ivec, &size);
    }
    if (ret)
	return ret;
    if (ivec->length < crypto->et->blocksize) {
	krb5_data_free(ivec);
	krb5_set_error_string(context, "%s IV of wrong size", 
			      crypto->et->name);
	return ASN1_PARSE_ERROR;
    }
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_set_params(krb5_context context,
		       const krb5_crypto crypto,
		       const krb5_data *ivec,
		       krb5_data *params)
{
    krb5_error_code (*sp)(krb5_context, const void *,
			  const krb5_data *, krb5_data *);
    krb5_error_code ret;

    sp = crypto->et->keytype->set_params;
    if (sp == NULL) {
	size_t size;
	if (ivec == NULL)
	    return 0;
	ASN1_MALLOC_ENCODE(CBCParameter, params->data, params->length,
			   ivec, &size, ret);
	if (ret)
	    return ret;
	if (size != params->length)
	    krb5_abortx(context, "Internal asn1 encoder failure");
	return 0;
    }
    if (crypto->params) {
	krb5_set_error_string(context,
			      "krb5_crypto_set_params called "
			      "more than once");
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    return (*sp)(context, crypto->params, ivec, params);
}


krb5_error_code KRB5_LIB_FUNCTION
d3579 1
a3579 43
krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_getenctype(krb5_context context,
		       krb5_crypto crypto,
		       krb5_enctype *enctype)
{
    *enctype = crypto->et->type;
     return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_getpadsize(krb5_context context,
                       krb5_crypto crypto,
                       size_t *padsize)      
{
    *padsize = crypto->et->padsize;
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_crypto_getconfoundersize(krb5_context context,
                              krb5_crypto crypto,
                              size_t *confoundersize)
{
    *confoundersize = crypto->et->confoundersize;
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_enctype_disable(krb5_context context,
		     krb5_enctype enctype)
{
    struct encryption_type *et = _find_enctype(enctype);
    if(et == NULL) {
	if (context)
	    krb5_set_error_string (context, "encryption type %d not supported",
				   enctype);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    et->flags |= F_DISABLED;
    return 0;
}

krb5_error_code KRB5_LIB_FUNCTION
a3635 1
    size_t checksumsize = CHECKSUMSIZE(et->checksum);
d3638 1
a3638 1
    res =  et->confoundersize + checksumsize + data_len;
d3654 1
a3654 4
    if (et->keyed_checksum)
	res += et->keyed_checksum->checksumsize;
    else
	res += et->checksum->checksumsize;
a3670 32
}

krb5_error_code KRB5_LIB_FUNCTION
krb5_random_to_key(krb5_context context,
		   krb5_enctype type,
		   const void *data,
		   size_t size,
		   krb5_keyblock *key)
{
    krb5_error_code ret;
    struct encryption_type *et = _find_enctype(type);
    if(et == NULL) {
	krb5_set_error_string(context, "encryption type %d not supported",
			      type);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    if ((et->keytype->bits + 7) / 8 > size) {
	krb5_set_error_string(context, "encryption key %s needs %d bytes "
			      "of random to make an encryption key out of it",
			      et->name, (int)et->keytype->size);
	return KRB5_PROG_ETYPE_NOSUPP;
    }
    ret = krb5_data_alloc(&key->keyvalue, et->keytype->size);
    if(ret) 
	return ret;
    key->keytype = type;
    if (et->keytype->random_to_key)
 	(*et->keytype->random_to_key)(context, key, data, size);
    else
	memcpy(key->keyvalue.data, data, et->keytype->size);

    return 0;
@


