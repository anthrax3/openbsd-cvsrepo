head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.28
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.26
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.24
	OPENBSD_5_0:1.3.0.22
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.20
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.18
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.14
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.16
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.12
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.10
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.2.0.6
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.6
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.4
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.04.22.10.01.29;	author reyk;	state dead;
branches;
next	1.4;

1.4
date	2013.06.17.18.57.43;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.15.05.51.35;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.18;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.18;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.12;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.43;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.33.03;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 2000 - 2004 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "hdb_locl.h"
#ifndef O_BINARY
#define O_BINARY 0
#endif

struct hdb_master_key_data {
    krb5_keytab_entry keytab;
    krb5_crypto crypto;
    struct hdb_master_key_data *next;
};

void
hdb_free_master_key(krb5_context context, hdb_master_key mkey)
{
    struct hdb_master_key_data *ptr;
    while(mkey) {
	krb5_kt_free_entry(context, &mkey->keytab);
	if (mkey->crypto)
	    krb5_crypto_destroy(context, mkey->crypto);
	ptr = mkey;
	mkey = mkey->next;
	free(ptr);
    }
}

krb5_error_code
hdb_process_master_key(krb5_context context,
		       int kvno, krb5_keyblock *key, krb5_enctype etype,
		       hdb_master_key *mkey)
{
    krb5_error_code ret;

    *mkey = calloc(1, sizeof(**mkey));
    if(*mkey == NULL) {
	krb5_set_error_message(context, ENOMEM, "malloc: out of memory");
	return ENOMEM;
    }
    (*mkey)->keytab.vno = kvno;
    ret = krb5_parse_name(context, "K/M", &(*mkey)->keytab.principal);
    if(ret)
	goto fail;
    ret = krb5_copy_keyblock_contents(context, key, &(*mkey)->keytab.keyblock);
    if(ret)
	goto fail;
    if(etype != 0)
	(*mkey)->keytab.keyblock.keytype = etype;
    (*mkey)->keytab.timestamp = time(NULL);
    ret = krb5_crypto_init(context, key, etype, &(*mkey)->crypto);
    if(ret)
	goto fail;
    return 0;
 fail:
    hdb_free_master_key(context, *mkey);
    *mkey = NULL;
    return ret;
}

krb5_error_code
hdb_add_master_key(krb5_context context, krb5_keyblock *key,
		   hdb_master_key *inout)
{
    int vno = 0;
    hdb_master_key p;
    krb5_error_code ret;

    for(p = *inout; p; p = p->next)
	vno = max(vno, p->keytab.vno);
    vno++;
    ret = hdb_process_master_key(context, vno, key, 0, &p);
    if(ret)
	return ret;
    p->next = *inout;
    *inout = p;
    return 0;
}

static krb5_error_code
read_master_keytab(krb5_context context, const char *filename,
		   hdb_master_key *mkey)
{
    krb5_error_code ret;
    krb5_keytab id;
    krb5_kt_cursor cursor;
    krb5_keytab_entry entry;
    hdb_master_key p;

    ret = krb5_kt_resolve(context, filename, &id);
    if(ret)
	return ret;

    ret = krb5_kt_start_seq_get(context, id, &cursor);
    if(ret)
	goto out;
    *mkey = NULL;
    while(krb5_kt_next_entry(context, id, &entry, &cursor) == 0) {
	p = calloc(1, sizeof(*p));
	if(p == NULL) {
	    krb5_kt_end_seq_get(context, id, &cursor);
	    ret = ENOMEM;
	    goto out;
	}
	p->keytab = entry;
	ret = krb5_crypto_init(context, &p->keytab.keyblock, 0, &p->crypto);
	p->next = *mkey;
	*mkey = p;
    }
    krb5_kt_end_seq_get(context, id, &cursor);
  out:
    krb5_kt_close(context, id);
    return ret;
}

/* read a MIT master keyfile */
static krb5_error_code
read_master_mit(krb5_context context, const char *filename,
		int byteorder, hdb_master_key *mkey)
{
    int fd;
    krb5_error_code ret;
    krb5_storage *sp;
    int16_t enctype;
    krb5_keyblock key;

    fd = open(filename, O_RDONLY | O_BINARY);
    if(fd < 0) {
	int save_errno = errno;
	krb5_set_error_message(context, save_errno, "failed to open %s: %s",
			       filename, strerror(save_errno));
	return save_errno;
    }
    sp = krb5_storage_from_fd(fd);
    if(sp == NULL) {
	close(fd);
	return errno;
    }
    krb5_storage_set_flags(sp, byteorder);
    /* could possibly use ret_keyblock here, but do it with more
       checks for now */
    {
	ret = krb5_ret_int16(sp, &enctype);
	if (ret)
	    goto out;
	ret = krb5_enctype_valid(context, enctype);
	if (ret)
	   goto out;
	key.keytype = enctype;
	ret = krb5_ret_data(sp, &key.keyvalue);
	if(ret)
	    goto out;
    }
    ret = hdb_process_master_key(context, 1, &key, 0, mkey);
    krb5_free_keyblock_contents(context, &key);
  out:
    krb5_storage_free(sp);
    close(fd);
    return ret;
}

/* read an old master key file */
static krb5_error_code
read_master_encryptionkey(krb5_context context, const char *filename,
			  hdb_master_key *mkey)
{
    int fd;
    krb5_keyblock key;
    krb5_error_code ret;
    unsigned char buf[256];
    ssize_t len;
    size_t ret_len;

    fd = open(filename, O_RDONLY | O_BINARY);
    if(fd < 0) {
	int save_errno = errno;
	krb5_set_error_message(context, save_errno, "failed to open %s: %s",
			      filename, strerror(save_errno));
	return save_errno;
    }

    len = read(fd, buf, sizeof(buf));
    close(fd);
    if(len < 0) {
	int save_errno = errno;
	krb5_set_error_message(context, save_errno, "error reading %s: %s",
			      filename, strerror(save_errno));
	return save_errno;
    }

    ret = decode_EncryptionKey(buf, len, &key, &ret_len);
    memset(buf, 0, sizeof(buf));
    if(ret)
	return ret;

    /* Originally, the keytype was just that, and later it got changed
       to des-cbc-md5, but we always used des in cfb64 mode. This
       should cover all cases, but will break if someone has hacked
       this code to really use des-cbc-md5 -- but then that's not my
       problem. */
    if(key.keytype == ETYPE_DES_CBC_CRC || key.keytype == ETYPE_DES_CBC_MD5)
	key.keytype = ETYPE_DES_CFB64_NONE;

    ret = hdb_process_master_key(context, 0, &key, 0, mkey);
    krb5_free_keyblock_contents(context, &key);
    return ret;
}

/* read a krb4 /.k style file */
static krb5_error_code
read_master_krb4(krb5_context context, const char *filename,
		 hdb_master_key *mkey)
{
    int fd;
    krb5_keyblock key;
    krb5_error_code ret;
    unsigned char buf[256];
    ssize_t len;

    fd = open(filename, O_RDONLY | O_BINARY);
    if(fd < 0) {
	int save_errno = errno;
	krb5_set_error_message(context, save_errno, "failed to open %s: %s",
			       filename, strerror(save_errno));
	return save_errno;
    }

    len = read(fd, buf, sizeof(buf));
    close(fd);
    if(len < 0) {
	int save_errno = errno;
	krb5_set_error_message(context, save_errno, "error reading %s: %s",
			       filename, strerror(save_errno));
	return save_errno;
    }
    if(len != 8) {
	krb5_set_error_message(context, HEIM_ERR_EOF,
			       "bad contents of %s", filename);
	return HEIM_ERR_EOF; /* XXX file might be too large */
    }

    memset(&key, 0, sizeof(key));
    key.keytype = ETYPE_DES_PCBC_NONE;
    ret = krb5_data_copy(&key.keyvalue, buf, len);
    memset(buf, 0, sizeof(buf));
    if(ret)
	return ret;

    ret = hdb_process_master_key(context, 0, &key, 0, mkey);
    krb5_free_keyblock_contents(context, &key);
    return ret;
}

krb5_error_code
hdb_read_master_key(krb5_context context, const char *filename,
		    hdb_master_key *mkey)
{
    FILE *f;
    unsigned char buf[16];
    krb5_error_code ret;

    off_t len;

    *mkey = NULL;

    if(filename == NULL)
	filename = HDB_DB_DIR "/m-key";

    f = fopen(filename, "r");
    if(f == NULL) {
	int save_errno = errno;
	krb5_set_error_message(context, save_errno, "failed to open %s: %s",
			       filename, strerror(save_errno));
	return save_errno;
    }

    if(fread(buf, 1, 2, f) != 2) {
	fclose(f);
	krb5_set_error_message(context, HEIM_ERR_EOF, "end of file reading %s", filename);
	return HEIM_ERR_EOF;
    }

    fseek(f, 0, SEEK_END);
    len = ftell(f);

    if(fclose(f) != 0)
	return errno;

    if(len < 0)
	return errno;

    if(len == 8) {
	ret = read_master_krb4(context, filename, mkey);
    } else if(buf[0] == 0x30 && len <= 127 && buf[1] == len - 2) {
	ret = read_master_encryptionkey(context, filename, mkey);
    } else if(buf[0] == 5 && buf[1] >= 1 && buf[1] <= 2) {
	ret = read_master_keytab(context, filename, mkey);
    } else {
      /*
       * Check both LittleEndian and BigEndian since they key file
       * might be moved from a machine with diffrent byte order, or
       * its running on MacOS X that always uses BE master keys.
       */
      ret = read_master_mit(context, filename, KRB5_STORAGE_BYTEORDER_LE, mkey);
      if (ret)
          ret = read_master_mit(context, filename, KRB5_STORAGE_BYTEORDER_BE, mkey);
    }
    return ret;
}

krb5_error_code
hdb_write_master_key(krb5_context context, const char *filename,
		     hdb_master_key mkey)
{
    krb5_error_code ret;
    hdb_master_key p;
    krb5_keytab kt;

    if(filename == NULL)
	filename = HDB_DB_DIR "/m-key";

    ret = krb5_kt_resolve(context, filename, &kt);
    if(ret)
	return ret;

    for(p = mkey; p; p = p->next) {
	ret = krb5_kt_add_entry(context, kt, &p->keytab);
    }

    krb5_kt_close(context, kt);

    return ret;
}

hdb_master_key
_hdb_find_master_key(uint32_t *mkvno, hdb_master_key mkey)
{
    hdb_master_key ret = NULL;
    while(mkey) {
	if(ret == NULL && mkey->keytab.vno == 0)
	    ret = mkey;
	if(mkvno == NULL) {
	    if(ret == NULL || mkey->keytab.vno > ret->keytab.vno)
		ret = mkey;
	} else if((uint32_t)mkey->keytab.vno == *mkvno)
	    return mkey;
	mkey = mkey->next;
    }
    return ret;
}

int
_hdb_mkey_version(hdb_master_key mkey)
{
    return mkey->keytab.vno;
}

int
_hdb_mkey_decrypt(krb5_context context, hdb_master_key key,
		  krb5_key_usage usage,
		  void *ptr, size_t size, krb5_data *res)
{
    return krb5_decrypt(context, key->crypto, usage,
			ptr, size, res);
}

int
_hdb_mkey_encrypt(krb5_context context, hdb_master_key key,
		  krb5_key_usage usage,
		  const void *ptr, size_t size, krb5_data *res)
{
    return krb5_encrypt(context, key->crypto, usage,
			ptr, size, res);
}

krb5_error_code
hdb_unseal_key_mkey(krb5_context context, Key *k, hdb_master_key mkey)
{

    krb5_error_code ret;
    krb5_data res;
    size_t keysize;

    hdb_master_key key;

    if(k->mkvno == NULL)
	return 0;

    key = _hdb_find_master_key(k->mkvno, mkey);

    if (key == NULL)
	return HDB_ERR_NO_MKEY;

    ret = _hdb_mkey_decrypt(context, key, HDB_KU_MKEY,
			    k->key.keyvalue.data,
			    k->key.keyvalue.length,
			    &res);
    if(ret == KRB5KRB_AP_ERR_BAD_INTEGRITY) {
	/* try to decrypt with MIT key usage */
	ret = _hdb_mkey_decrypt(context, key, 0,
				k->key.keyvalue.data,
				k->key.keyvalue.length,
				&res);
    }
    if (ret)
	return ret;

    /* fixup keylength if the key got padded when encrypting it */
    ret = krb5_enctype_keysize(context, k->key.keytype, &keysize);
    if (ret) {
	krb5_data_free(&res);
	return ret;
    }
    if (keysize > res.length) {
	krb5_data_free(&res);
	return KRB5_BAD_KEYSIZE;
    }

    memset(k->key.keyvalue.data, 0, k->key.keyvalue.length);
    free(k->key.keyvalue.data);
    k->key.keyvalue = res;
    k->key.keyvalue.length = keysize;
    free(k->mkvno);
    k->mkvno = NULL;

    return 0;
}

krb5_error_code
hdb_unseal_keys_mkey(krb5_context context, hdb_entry *ent, hdb_master_key mkey)
{
    size_t i;

    for(i = 0; i < ent->keys.len; i++){
	krb5_error_code ret;

	ret = hdb_unseal_key_mkey(context, &ent->keys.val[i], mkey);
	if (ret)
	    return ret;
    }
    return 0;
}

krb5_error_code
hdb_unseal_keys(krb5_context context, HDB *db, hdb_entry *ent)
{
    if (db->hdb_master_key_set == 0)
	return 0;
    return hdb_unseal_keys_mkey(context, ent, db->hdb_master_key);
}

krb5_error_code
hdb_unseal_key(krb5_context context, HDB *db, Key *k)
{
    if (db->hdb_master_key_set == 0)
	return 0;
    return hdb_unseal_key_mkey(context, k, db->hdb_master_key);
}

krb5_error_code
hdb_seal_key_mkey(krb5_context context, Key *k, hdb_master_key mkey)
{
    krb5_error_code ret;
    krb5_data res;
    hdb_master_key key;

    if(k->mkvno != NULL)
	return 0;

    key = _hdb_find_master_key(k->mkvno, mkey);

    if (key == NULL)
	return HDB_ERR_NO_MKEY;

    ret = _hdb_mkey_encrypt(context, key, HDB_KU_MKEY,
			    k->key.keyvalue.data,
			    k->key.keyvalue.length,
			    &res);
    if (ret)
	return ret;

    memset(k->key.keyvalue.data, 0, k->key.keyvalue.length);
    free(k->key.keyvalue.data);
    k->key.keyvalue = res;

    if (k->mkvno == NULL) {
	k->mkvno = malloc(sizeof(*k->mkvno));
	if (k->mkvno == NULL)
	    return ENOMEM;
    }
    *k->mkvno = key->keytab.vno;

    return 0;
}

krb5_error_code
hdb_seal_keys_mkey(krb5_context context, hdb_entry *ent, hdb_master_key mkey)
{
    size_t i;
    for(i = 0; i < ent->keys.len; i++){
	krb5_error_code ret;

	ret = hdb_seal_key_mkey(context, &ent->keys.val[i], mkey);
	if (ret)
	    return ret;
    }
    return 0;
}

krb5_error_code
hdb_seal_keys(krb5_context context, HDB *db, hdb_entry *ent)
{
    if (db->hdb_master_key_set == 0)
	return 0;

    return hdb_seal_keys_mkey(context, ent, db->hdb_master_key);
}

krb5_error_code
hdb_seal_key(krb5_context context, HDB *db, Key *k)
{
    if (db->hdb_master_key_set == 0)
	return 0;

    return hdb_seal_key_mkey(context, k, db->hdb_master_key);
}

krb5_error_code
hdb_set_master_key (krb5_context context,
		    HDB *db,
		    krb5_keyblock *key)
{
    krb5_error_code ret;
    hdb_master_key mkey;

    ret = hdb_process_master_key(context, 0, key, 0, &mkey);
    if (ret)
	return ret;
    db->hdb_master_key = mkey;
#if 0 /* XXX - why? */
    des_set_random_generator_seed(key.keyvalue.data);
#endif
    db->hdb_master_key_set = 1;
    return 0;
}

krb5_error_code
hdb_set_master_keyfile (krb5_context context,
			HDB *db,
			const char *keyfile)
{
    hdb_master_key key;
    krb5_error_code ret;

    ret = hdb_read_master_key(context, keyfile, &key);
    if (ret) {
	if (ret != ENOENT)
	    return ret;
	krb5_clear_error_message(context);
	return 0;
    }
    db->hdb_master_key = key;
    db->hdb_master_key_set = 1;
    return ret;
}

krb5_error_code
hdb_clear_master_key (krb5_context context,
		      HDB *db)
{
    if (db->hdb_master_key_set) {
	hdb_free_master_key(context, db->hdb_master_key);
	db->hdb_master_key_set = 0;
    }
    return 0;
}
@


1.4
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.3
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 2000 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a38 2
RCSID("$KTH: mkey.c,v 1.18.4.2 2005/08/19 13:23:11 lha Exp $");

d68 1
a68 1
	krb5_set_error_string(context, "malloc: out of memory");
d111 1
a111 1
read_master_keytab(krb5_context context, const char *filename, 
d119 1
a119 1
    
d130 5
d148 2
a149 2
read_master_mit(krb5_context context, const char *filename, 
		hdb_master_key *mkey)
d156 1
a156 1
	       
d160 2
a161 2
	krb5_set_error_string(context, "failed to open %s: %s", filename,
			      strerror(save_errno));
d169 1
a169 2
    krb5_storage_set_flags(sp, KRB5_STORAGE_HOST_BYTEORDER);
#if 0
d172 11
a182 8
    ret = krb5_ret_keyblock(sp, &key);
#else
    ret = krb5_ret_int16(sp, &enctype);
    if((htons(enctype) & 0xff00) == 0x3000) {
	krb5_set_error_string(context, "unknown keytype in %s: %#x, expected %#x", 
			      filename, htons(enctype), 0x3000);
	ret = HEIM_ERR_BAD_MKEY;
	goto out;
d184 1
a184 6
    key.keytype = enctype;
    ret = krb5_ret_data(sp, &key.keyvalue);
    if(ret)
	goto out;
#endif
    ret = hdb_process_master_key(context, 0, &key, 0, mkey);
d194 1
a194 1
read_master_encryptionkey(krb5_context context, const char *filename, 
d203 1
a203 1
	       
d207 1
a207 1
	krb5_set_error_string(context, "failed to open %s: %s", 
d211 1
a211 1
    
d216 1
a216 1
	krb5_set_error_string(context, "error reading %s: %s", 
d231 1
a231 1
    if(key.keytype == KEYTYPE_DES || key.keytype == ETYPE_DES_CBC_MD5)
d233 1
a233 1
    
d241 1
a241 1
read_master_krb4(krb5_context context, const char *filename, 
d249 1
a249 1
	       
d253 2
a254 2
	krb5_set_error_string(context, "failed to open %s: %s", 
			      filename, strerror(save_errno));
d257 1
a257 1
    
d262 2
a263 2
	krb5_set_error_string(context, "error reading %s: %s", 
			      filename, strerror(save_errno));
d267 2
a268 1
	krb5_set_error_string(context, "bad contents of %s", filename);
d276 1
a276 1
    if(ret) 
d285 1
a285 1
hdb_read_master_key(krb5_context context, const char *filename, 
d302 2
a303 2
	krb5_set_error_string(context, "failed to open %s: %s", 
			      filename, strerror(save_errno));
d306 1
a306 1
    
a307 1
	krb5_set_error_string(context, "end of file reading %s", filename);
d309 1
d312 1
a312 1
    
d314 1
a314 1
    len = ftello(f);
d318 1
a318 1
    
d321 1
a321 1
    
d329 8
a336 1
	ret = read_master_mit(context, filename, mkey);
d342 1
a342 1
hdb_write_master_key(krb5_context context, const char *filename, 
d365 2
a366 2
static hdb_master_key
find_master_key(Key *key, hdb_master_key mkey)
d372 1
a372 1
	if(key->mkvno == NULL) {
d375 1
a375 1
	} else if(mkey->keytab.vno == *key->mkvno)
d382 24
d407 1
a407 1
hdb_unseal_key_mkey(krb5_context context, Key *k, hdb_master_key mkey) 
d409 1
a409 1
	
d418 2
a419 2
	
    key = find_master_key(k, mkey);
d424 11
a434 4
    ret = krb5_decrypt(context, key->crypto, HDB_KU_MKEY,
		       k->key.keyvalue.data,
		       k->key.keyvalue.length,
		       &res);
d462 1
a462 1
    int i;
d468 1
a468 1
	if (ret) 
d500 1
a500 1
    key = find_master_key(k, mkey);
d505 4
a508 4
    ret = krb5_encrypt(context, key->crypto, HDB_KU_MKEY,
		       k->key.keyvalue.data,
		       k->key.keyvalue.length,
		       &res);
d516 5
a520 3
    k->mkvno = malloc(sizeof(*k->mkvno));
    if (k->mkvno == NULL)
	return ENOMEM;
d522 1
a522 1
	
d529 1
a529 1
    int i;
d545 1
a545 1
    
d554 1
a554 1
    
d589 1
a589 1
	krb5_clear_error_string(context);
@


1.2
log
@Use ftello() rather than ftell() if you want an off_t value.
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2002 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: mkey.c,v 1.15 2003/03/28 02:01:33 lha Exp $");
d151 1
a151 1
    u_int16_t enctype;
d375 1
a375 1
hdb_unseal_keys_mkey(krb5_context context, hdb_entry *ent, hdb_master_key mkey)
d377 1
a377 1
    int i;
a380 1
    Key *k;
d382 27
a408 2
    for(i = 0; i < ent->keys.len; i++){
	hdb_master_key key;
d410 6
a415 3
	k = &ent->keys.val[i];
	if(k->mkvno == NULL)
	    continue;
d417 2
a418 1
	key = find_master_key(&ent->keys.val[i], mkey);
d420 4
a423 2
	if (key == NULL)
	    return HDB_ERR_NO_MKEY;
d425 2
a426 6
	ret = krb5_decrypt(context, key->crypto, HDB_KU_MKEY,
			   k->key.keyvalue.data,
			   k->key.keyvalue.length,
			   &res);
	if (ret)
	    return ret;
d428 2
a429 4
	/* fixup keylength if the key got padded when encrypting it */
	ret = krb5_enctype_keysize(context, k->key.keytype, &keysize);
	if (ret) {
	    krb5_data_free(&res);
a430 12
	}
	if (keysize > res.length) {
	    krb5_data_free(&res);
	    return KRB5_BAD_KEYSIZE;
	}

	memset(k->key.keyvalue.data, 0, k->key.keyvalue.length);
	free(k->key.keyvalue.data);
	k->key.keyvalue = res;
	k->key.keyvalue.length = keysize;
	free(k->mkvno);
	k->mkvno = NULL;
d438 1
a438 1
    if (db->master_key_set == 0)
d440 1
a440 1
    return hdb_unseal_keys_mkey(context, ent, db->master_key);
d444 9
a452 1
hdb_seal_keys_mkey(krb5_context context, hdb_entry *ent, hdb_master_key mkey)
a453 1
    int i;
d456 9
a464 3
    for(i = 0; i < ent->keys.len; i++){
	Key *k = &ent->keys.val[i];
	hdb_master_key key;
d466 6
a471 2
	if(k->mkvno != NULL)
	    continue;
d473 3
a475 1
	key = find_master_key(k, mkey);
d477 7
a483 2
	if (key == NULL)
	    return HDB_ERR_NO_MKEY;
d485 8
a492 4
	ret = krb5_encrypt(context, key->crypto, HDB_KU_MKEY,
			   k->key.keyvalue.data,
			   k->key.keyvalue.length,
			   &res);
a494 9

	memset(k->key.keyvalue.data, 0, k->key.keyvalue.length);
	free(k->key.keyvalue.data);
	k->key.keyvalue = res;

	k->mkvno = malloc(sizeof(*k->mkvno));
	if (k->mkvno == NULL)
	    return ENOMEM;
	*k->mkvno = key->keytab.vno;
d502 10
a511 1
    if (db->master_key_set == 0)
d514 1
a514 1
    return hdb_seal_keys_mkey(context, ent, db->master_key);
d528 1
a528 1
    db->master_key = mkey;
d532 1
a532 1
    db->master_key_set = 1;
d551 2
a552 2
    db->master_key = key;
    db->master_key_set = 1;
d560 3
a562 3
    if (db->master_key_set) {
	hdb_free_master_key(context, db->master_key);
	db->master_key_set = 0;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2001 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: mkey.c,v 1.8 2001/01/30 01:20:57 assar Exp $");
d53 2
a54 1
	krb5_crypto_destroy(context, mkey->crypto);
d67 1
d69 2
a70 1
    if(*mkey == NULL)
d72 1
d75 2
d78 2
a79 5
    if(ret) {
	free(*mkey);
	*mkey = NULL;
	return ret;
    }
d84 6
a89 5
    if(ret) {
	krb5_free_keyblock_contents(context, &(*mkey)->keytab.keyblock);
	free(*mkey);
	*mkey = NULL;
    }
d155 6
a160 2
    if(fd < 0)
	return errno;
d174 2
d202 1
d205 6
a210 2
    if(fd < 0)
	return errno;
d214 6
a219 2
    if(len < 0)
	return errno;
d221 1
a221 1
    ret = decode_EncryptionKey(buf, len, &key, &len);
d251 6
a256 2
    if(fd < 0)
	return errno;
d260 10
a269 2
    if(len < 0)
	return errno;
d299 6
a304 2
    if(f == NULL)
	return errno;
d307 1
d313 1
a313 1
    len = ftell(f);
d380 1
d402 11
d416 1
d508 1
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d39 1
a39 1
RCSID("$KTH: mkey.c,v 1.11 2001/07/13 06:30:41 assar Exp $");
a65 1

d67 1
a67 2
    if(*mkey == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a68 1
    }
a70 2
    if(ret)
	goto fail;
d72 5
a76 2
    if(ret)
	goto fail;
d81 5
a85 6
    if(ret)
	goto fail;
    return 0;
 fail:
    hdb_free_master_key(context, *mkey);
    *mkey = NULL;
d151 2
a152 6
    if(fd < 0) {
	int save_errno = errno;
	krb5_set_error_string(context, "failed to open %s: %s", filename,
			      strerror(save_errno));
	return save_errno;
    }
a165 2
	krb5_set_error_string(context, "unknown keytype in %s: %#x, expected %#x", 
			      filename, htons(enctype), 0x3000);
d194 2
a195 6
    if(fd < 0) {
	int save_errno = errno;
	krb5_set_error_string(context, "failed to open %s: %s", 
			      filename, strerror(save_errno));
	return save_errno;
    }
d199 2
a200 6
    if(len < 0) {
	int save_errno = errno;
	krb5_set_error_string(context, "error reading %s: %s", 
			      filename, strerror(save_errno));
	return save_errno;
    }
d232 2
a233 6
    if(fd < 0) {
	int save_errno = errno;
	krb5_set_error_string(context, "failed to open %s: %s", 
			      filename, strerror(save_errno));
	return save_errno;
    }
d237 2
a238 10
    if(len < 0) {
	int save_errno = errno;
	krb5_set_error_string(context, "error reading %s: %s", 
			      filename, strerror(save_errno));
	return save_errno;
    }
    if(len != 8) {
	krb5_set_error_string(context, "bad contents of %s", filename);
	return HEIM_ERR_EOF; /* XXX file might be too large */
    }
d268 2
a269 6
    if(f == NULL) {
	int save_errno = errno;
	krb5_set_error_string(context, "failed to open %s: %s", 
			      filename, strerror(save_errno));
	return save_errno;
    }
a271 1
	krb5_set_error_string(context, "end of file reading %s", filename);
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2002 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: mkey.c,v 1.15 2003/03/28 02:01:33 lha Exp $");
d53 1
a53 2
	if (mkey->crypto)
	    krb5_crypto_destroy(context, mkey->crypto);
a200 1
    size_t ret_len;
d219 1
a219 1
    ret = decode_EncryptionKey(buf, len, &key, &ret_len);
a377 1
    size_t keysize;
a398 11
	/* fixup keylength if the key got padded when encrypting it */
	ret = krb5_enctype_keysize(context, k->key.keytype, &keysize);
	if (ret) {
	    krb5_data_free(&res);
	    return ret;
	}
	if (keysize > res.length) {
	    krb5_data_free(&res);
	    return KRB5_BAD_KEYSIZE;
	}

a401 1
	k->key.keyvalue.length = keysize;
a492 1
	krb5_clear_error_string(context);
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2004 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: mkey.c,v 1.18.4.2 2005/08/19 13:23:11 lha Exp $");
d151 1
a151 1
    int16_t enctype;
d375 1
a375 1
hdb_unseal_key_mkey(krb5_context context, Key *k, hdb_master_key mkey) 
d377 1
a377 1
	
d381 1
d383 2
a384 1
    hdb_master_key key;
d386 3
a388 7
    if(k->mkvno == NULL)
	return 0;
	
    key = find_master_key(k, mkey);

    if (key == NULL)
	return HDB_ERR_NO_MKEY;
d390 1
a390 6
    ret = krb5_decrypt(context, key->crypto, HDB_KU_MKEY,
		       k->key.keyvalue.data,
		       k->key.keyvalue.length,
		       &res);
    if (ret)
	return ret;
d392 2
a393 10
    /* fixup keylength if the key got padded when encrypting it */
    ret = krb5_enctype_keysize(context, k->key.keytype, &keysize);
    if (ret) {
	krb5_data_free(&res);
	return ret;
    }
    if (keysize > res.length) {
	krb5_data_free(&res);
	return KRB5_BAD_KEYSIZE;
    }
d395 6
a400 6
    memset(k->key.keyvalue.data, 0, k->key.keyvalue.length);
    free(k->key.keyvalue.data);
    k->key.keyvalue = res;
    k->key.keyvalue.length = keysize;
    free(k->mkvno);
    k->mkvno = NULL;
d402 4
a405 13
    return 0;
}

krb5_error_code
hdb_unseal_keys_mkey(krb5_context context, hdb_entry *ent, hdb_master_key mkey)
{
    int i;

    for(i = 0; i < ent->keys.len; i++){
	krb5_error_code ret;

	ret = hdb_unseal_key_mkey(context, &ent->keys.val[i], mkey);
	if (ret) 
d407 12
d426 1
a426 1
    if (db->hdb_master_key_set == 0)
d428 1
a428 1
    return hdb_unseal_keys_mkey(context, ent, db->hdb_master_key);
d432 1
a432 9
hdb_unseal_key(krb5_context context, HDB *db, Key *k)
{
    if (db->hdb_master_key_set == 0)
	return 0;
    return hdb_unseal_key_mkey(context, k, db->hdb_master_key);
}

krb5_error_code
hdb_seal_key_mkey(krb5_context context, Key *k, hdb_master_key mkey)
d434 1
d437 3
a439 4
    hdb_master_key key;

    if(k->mkvno != NULL)
	return 0;
d441 2
a442 1
    key = find_master_key(k, mkey);
d444 1
a444 2
    if (key == NULL)
	return HDB_ERR_NO_MKEY;
d446 2
a447 18
    ret = krb5_encrypt(context, key->crypto, HDB_KU_MKEY,
		       k->key.keyvalue.data,
		       k->key.keyvalue.length,
		       &res);
    if (ret)
	return ret;

    memset(k->key.keyvalue.data, 0, k->key.keyvalue.length);
    free(k->key.keyvalue.data);
    k->key.keyvalue = res;

    k->mkvno = malloc(sizeof(*k->mkvno));
    if (k->mkvno == NULL)
	return ENOMEM;
    *k->mkvno = key->keytab.vno;
	
    return 0;
}
d449 4
a452 8
krb5_error_code
hdb_seal_keys_mkey(krb5_context context, hdb_entry *ent, hdb_master_key mkey)
{
    int i;
    for(i = 0; i < ent->keys.len; i++){
	krb5_error_code ret;

	ret = hdb_seal_key_mkey(context, &ent->keys.val[i], mkey);
d455 9
d471 1
a471 10
    if (db->hdb_master_key_set == 0)
	return 0;
    
    return hdb_seal_keys_mkey(context, ent, db->hdb_master_key);
}

krb5_error_code
hdb_seal_key(krb5_context context, HDB *db, Key *k)
{
    if (db->hdb_master_key_set == 0)
d474 1
a474 1
    return hdb_seal_key_mkey(context, k, db->hdb_master_key);
d488 1
a488 1
    db->hdb_master_key = mkey;
d492 1
a492 1
    db->hdb_master_key_set = 1;
d511 2
a512 2
    db->hdb_master_key = key;
    db->hdb_master_key_set = 1;
d520 3
a522 3
    if (db->hdb_master_key_set) {
	hdb_free_master_key(context, db->hdb_master_key);
	db->hdb_master_key_set = 0;
@


