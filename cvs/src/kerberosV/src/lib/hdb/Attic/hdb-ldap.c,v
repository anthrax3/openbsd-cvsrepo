head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.26
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.24
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.22
	OPENBSD_5_0:1.2.0.20
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.18
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.16
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.6
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.4
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.2
	OPENBSD_3_4_BASE:1.1.1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.1.1.3.0.6
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.4
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.2
	OPENBSD_3_1_BASE:1.1.1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.29;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.43;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.30.17.48.22;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.16;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.16;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.22.53;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.55.11;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.42;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.34;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.33.02;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1999-2001, 2003, PADL Software Pty Ltd.
 * Copyright (c) 2004, Andrew Bartlett.
 * Copyright (c) 2003 - 2008, Kungliga Tekniska HÃ¶gskolan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of PADL Software  nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY PADL SOFTWARE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL PADL SOFTWARE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "hdb_locl.h"

#ifdef OPENLDAP

#include <lber.h>
#include <ldap.h>
#include <sys/un.h>
#include <hex.h>

static krb5_error_code LDAP__connect(krb5_context context, HDB *);
static krb5_error_code LDAP_close(krb5_context context, HDB *);

static krb5_error_code
LDAP_message2entry(krb5_context context, HDB * db, LDAPMessage * msg,
		   int flags, hdb_entry_ex * ent);

static const char *default_structural_object = "account";
static char *structural_object;
static krb5_boolean samba_forwardable;

struct hdbldapdb {
    LDAP *h_lp;
    int   h_msgid;
    char *h_base;
    char *h_url;
    char *h_createbase;
};

#define HDB2LDAP(db) (((struct hdbldapdb *)(db)->hdb_db)->h_lp)
#define HDB2MSGID(db) (((struct hdbldapdb *)(db)->hdb_db)->h_msgid)
#define HDBSETMSGID(db,msgid) \
	do { ((struct hdbldapdb *)(db)->hdb_db)->h_msgid = msgid; } while(0)
#define HDB2BASE(dn) (((struct hdbldapdb *)(db)->hdb_db)->h_base)
#define HDB2URL(dn) (((struct hdbldapdb *)(db)->hdb_db)->h_url)
#define HDB2CREATE(db) (((struct hdbldapdb *)(db)->hdb_db)->h_createbase)

/*
 *
 */

static char * krb5kdcentry_attrs[] = {
    "cn",
    "createTimestamp",
    "creatorsName",
    "krb5EncryptionType",
    "krb5KDCFlags",
    "krb5Key",
    "krb5KeyVersionNumber",
    "krb5MaxLife",
    "krb5MaxRenew",
    "krb5PasswordEnd",
    "krb5PrincipalName",
    "krb5PrincipalRealm",
    "krb5ValidEnd",
    "krb5ValidStart",
    "modifiersName",
    "modifyTimestamp",
    "objectClass",
    "sambaAcctFlags",
    "sambaKickoffTime",
    "sambaNTPassword",
    "sambaPwdLastSet",
    "sambaPwdMustChange",
    "uid",
    NULL
};

static char *krb5principal_attrs[] = {
    "cn",
    "createTimestamp",
    "creatorsName",
    "krb5PrincipalName",
    "krb5PrincipalRealm",
    "modifiersName",
    "modifyTimestamp",
    "objectClass",
    "uid",
    NULL
};

static int
LDAP_no_size_limit(krb5_context context, LDAP *lp)
{
    int ret, limit = LDAP_NO_LIMIT;

    ret = ldap_set_option(lp, LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (ret != LDAP_SUCCESS) {
	krb5_set_error_message(context, HDB_ERR_BADVERSION,
			       "ldap_set_option: %s",
			       ldap_err2string(ret));
	return HDB_ERR_BADVERSION;
    }
    return 0;
}

static int
check_ldap(krb5_context context, HDB *db, int ret)
{
    switch (ret) {
    case LDAP_SUCCESS:
	return 0;
    case LDAP_SERVER_DOWN:
	LDAP_close(context, db);
	return 1;
    default:
	return 1;
    }
}

static krb5_error_code
LDAP__setmod(LDAPMod *** modlist, int modop, const char *attribute,
	     int *pIndex)
{
    int cMods;

    if (*modlist == NULL) {
	*modlist = (LDAPMod **)ber_memcalloc(1, sizeof(LDAPMod *));
	if (*modlist == NULL)
	    return ENOMEM;
    }

    for (cMods = 0; (*modlist)[cMods] != NULL; cMods++) {
	if ((*modlist)[cMods]->mod_op == modop &&
	    strcasecmp((*modlist)[cMods]->mod_type, attribute) == 0) {
	    break;
	}
    }

    *pIndex = cMods;

    if ((*modlist)[cMods] == NULL) {
	LDAPMod *mod;

	*modlist = (LDAPMod **)ber_memrealloc(*modlist,
					      (cMods + 2) * sizeof(LDAPMod *));
	if (*modlist == NULL)
	    return ENOMEM;

	(*modlist)[cMods] = (LDAPMod *)ber_memalloc(sizeof(LDAPMod));
	if ((*modlist)[cMods] == NULL)
	    return ENOMEM;

	mod = (*modlist)[cMods];
	mod->mod_op = modop;
	mod->mod_type = ber_strdup(attribute);
	if (mod->mod_type == NULL) {
	    ber_memfree(mod);
	    (*modlist)[cMods] = NULL;
	    return ENOMEM;
	}

	if (modop & LDAP_MOD_BVALUES) {
	    mod->mod_bvalues = NULL;
	} else {
	    mod->mod_values = NULL;
	}

	(*modlist)[cMods + 1] = NULL;
    }

    return 0;
}

static krb5_error_code
LDAP_addmod_len(LDAPMod *** modlist, int modop, const char *attribute,
		unsigned char *value, size_t len)
{
    krb5_error_code ret;
    int cMods, i = 0;

    ret = LDAP__setmod(modlist, modop | LDAP_MOD_BVALUES, attribute, &cMods);
    if (ret)
	return ret;

    if (value != NULL) {
	struct berval **bv;

	bv = (*modlist)[cMods]->mod_bvalues;
	if (bv != NULL) {
	    for (i = 0; bv[i] != NULL; i++)
		;
	    bv = ber_memrealloc(bv, (i + 2) * sizeof(*bv));
	} else
	    bv = ber_memalloc(2 * sizeof(*bv));
	if (bv == NULL)
	    return ENOMEM;

	(*modlist)[cMods]->mod_bvalues = bv;

	bv[i] = ber_memalloc(sizeof(**bv));;
	if (bv[i] == NULL)
	    return ENOMEM;

	bv[i]->bv_val = (void *)value;
	bv[i]->bv_len = len;

	bv[i + 1] = NULL;
    }

    return 0;
}

static krb5_error_code
LDAP_addmod(LDAPMod *** modlist, int modop, const char *attribute,
	    const char *value)
{
    int cMods, i = 0;
    krb5_error_code ret;

    ret = LDAP__setmod(modlist, modop, attribute, &cMods);
    if (ret)
	return ret;

    if (value != NULL) {
	char **bv;

	bv = (*modlist)[cMods]->mod_values;
	if (bv != NULL) {
	    for (i = 0; bv[i] != NULL; i++)
		;
	    bv = ber_memrealloc(bv, (i + 2) * sizeof(*bv));
	} else
	    bv = ber_memalloc(2 * sizeof(*bv));
	if (bv == NULL)
	    return ENOMEM;

	(*modlist)[cMods]->mod_values = bv;

	bv[i] = ber_strdup(value);
	if (bv[i] == NULL)
	    return ENOMEM;

	bv[i + 1] = NULL;
    }

    return 0;
}

static krb5_error_code
LDAP_addmod_generalized_time(LDAPMod *** mods, int modop,
			     const char *attribute, KerberosTime * time)
{
    char buf[22];
    struct tm *tm;

    /* XXX not threadsafe */
    tm = gmtime(time);
    strftime(buf, sizeof(buf), "%Y%m%d%H%M%SZ", tm);

    return LDAP_addmod(mods, modop, attribute, buf);
}

static krb5_error_code
LDAP_addmod_integer(krb5_context context,
		    LDAPMod *** mods, int modop,
		    const char *attribute, unsigned long l)
{
    krb5_error_code ret;
    char *buf;

    ret = asprintf(&buf, "%ld", l);
    if (ret < 0) {
	krb5_set_error_message(context, ENOMEM,
			       "asprintf: out of memory:");
	return ENOMEM;
    }
    ret = LDAP_addmod(mods, modop, attribute, buf);
    free (buf);
    return ret;
}

static krb5_error_code
LDAP_get_string_value(HDB * db, LDAPMessage * entry,
		      const char *attribute, char **ptr)
{
    struct berval **vals;

    vals = ldap_get_values_len(HDB2LDAP(db), entry, attribute);
    if (vals == NULL || vals[0] == NULL) {
	*ptr = NULL;
	return HDB_ERR_NOENTRY;
    }

    *ptr = malloc(vals[0]->bv_len + 1);
    if (*ptr == NULL) {
	ldap_value_free_len(vals);
	return ENOMEM;
    }

    memcpy(*ptr, vals[0]->bv_val, vals[0]->bv_len);
    (*ptr)[vals[0]->bv_len] = 0;

    ldap_value_free_len(vals);

    return 0;
}

static krb5_error_code
LDAP_get_integer_value(HDB * db, LDAPMessage * entry,
		       const char *attribute, int *ptr)
{
    krb5_error_code ret;
    char *val;

    ret = LDAP_get_string_value(db, entry, attribute, &val);
    if (ret)
	return ret;
    *ptr = atoi(val);
    free(val);
    return 0;
}

static krb5_error_code
LDAP_get_generalized_time_value(HDB * db, LDAPMessage * entry,
				const char *attribute, KerberosTime * kt)
{
    char *tmp, *gentime;
    struct tm tm;
    int ret;

    *kt = 0;

    ret = LDAP_get_string_value(db, entry, attribute, &gentime);
    if (ret)
	return ret;

    tmp = strptime(gentime, "%Y%m%d%H%M%SZ", &tm);
    if (tmp == NULL) {
	free(gentime);
	return HDB_ERR_NOENTRY;
    }

    free(gentime);

    *kt = timegm(&tm);

    return 0;
}

static int
bervalstrcmp(struct berval *v, const char *str)
{
    size_t len = strlen(str);
    return (v->bv_len == len) && strncasecmp(str, (char *)v->bv_val, len) == 0;
}


static krb5_error_code
LDAP_entry2mods(krb5_context context, HDB * db, hdb_entry_ex * ent,
		LDAPMessage * msg, LDAPMod *** pmods)
{
    krb5_error_code ret;
    krb5_boolean is_new_entry;
    char *tmp = NULL;
    LDAPMod **mods = NULL;
    hdb_entry_ex orig;
    unsigned long oflags, nflags;
    int i;

    krb5_boolean is_samba_account = FALSE;
    krb5_boolean is_account = FALSE;
    krb5_boolean is_heimdal_entry = FALSE;
    krb5_boolean is_heimdal_principal = FALSE;

    struct berval **vals;

    *pmods = NULL;

    if (msg != NULL) {

	ret = LDAP_message2entry(context, db, msg, 0, &orig);
	if (ret)
	    goto out;

	is_new_entry = FALSE;

	vals = ldap_get_values_len(HDB2LDAP(db), msg, "objectClass");
	if (vals) {
	    int num_objectclasses = ldap_count_values_len(vals);
	    for (i=0; i < num_objectclasses; i++) {
		if (bervalstrcmp(vals[i], "sambaSamAccount"))
		    is_samba_account = TRUE;
		else if (bervalstrcmp(vals[i], structural_object))
		    is_account = TRUE;
		else if (bervalstrcmp(vals[i], "krb5Principal"))
		    is_heimdal_principal = TRUE;
		else if (bervalstrcmp(vals[i], "krb5KDCEntry"))
		    is_heimdal_entry = TRUE;
	    }
	    ldap_value_free_len(vals);
	}

	/*
	 * If this is just a "account" entry and no other objectclass
	 * is hanging on this entry, it's really a new entry.
	 */
	if (is_samba_account == FALSE && is_heimdal_principal == FALSE &&
	    is_heimdal_entry == FALSE) {
	    if (is_account == TRUE) {
		is_new_entry = TRUE;
	    } else {
		ret = HDB_ERR_NOENTRY;
		goto out;
	    }
	}
    } else
	is_new_entry = TRUE;

    if (is_new_entry) {

	/* to make it perfectly obvious we're depending on
	 * orig being intiialized to zero */
	memset(&orig, 0, sizeof(orig));

	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", "top");
	if (ret)
	    goto out;

	/* account is the structural object class */
	if (is_account == FALSE) {
	    ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass",
			      structural_object);
	    is_account = TRUE;
	    if (ret)
		goto out;
	}

	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", "krb5Principal");
	is_heimdal_principal = TRUE;
	if (ret)
	    goto out;

	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", "krb5KDCEntry");
	is_heimdal_entry = TRUE;
	if (ret)
	    goto out;
    }

    if (is_new_entry ||
	krb5_principal_compare(context, ent->entry.principal, orig.entry.principal)
	== FALSE)
    {
	if (is_heimdal_principal || is_heimdal_entry) {

	    ret = krb5_unparse_name(context, ent->entry.principal, &tmp);
	    if (ret)
		goto out;

	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE,
			      "krb5PrincipalName", tmp);
	    if (ret) {
		free(tmp);
		goto out;
	    }
	    free(tmp);
	}

	if (is_account || is_samba_account) {
	    ret = krb5_unparse_name_short(context, ent->entry.principal, &tmp);
	    if (ret)
		goto out;
	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "uid", tmp);
	    if (ret) {
		free(tmp);
		goto out;
	    }
	    free(tmp);
	}
    }

    if (is_heimdal_entry && (ent->entry.kvno != orig.entry.kvno || is_new_entry)) {
	ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
			    "krb5KeyVersionNumber",
			    ent->entry.kvno);
	if (ret)
	    goto out;
    }

    if (is_heimdal_entry && ent->entry.valid_start) {
	if (orig.entry.valid_end == NULL
	    || (*(ent->entry.valid_start) != *(orig.entry.valid_start))) {
	    ret = LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
					       "krb5ValidStart",
					       ent->entry.valid_start);
	    if (ret)
		goto out;
	}
    }

    if (ent->entry.valid_end) {
 	if (orig.entry.valid_end == NULL || (*(ent->entry.valid_end) != *(orig.entry.valid_end))) {
	    if (is_heimdal_entry) {
		ret = LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
						   "krb5ValidEnd",
						   ent->entry.valid_end);
		if (ret)
		    goto out;
            }
	    if (is_samba_account) {
		ret = LDAP_addmod_integer(context, &mods,  LDAP_MOD_REPLACE,
					  "sambaKickoffTime",
					  *(ent->entry.valid_end));
		if (ret)
		    goto out;
	    }
   	}
    }

    if (ent->entry.pw_end) {
	if (orig.entry.pw_end == NULL || (*(ent->entry.pw_end) != *(orig.entry.pw_end))) {
	    if (is_heimdal_entry) {
		ret = LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
						   "krb5PasswordEnd",
						   ent->entry.pw_end);
		if (ret)
		    goto out;
	    }

	    if (is_samba_account) {
		ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
					  "sambaPwdMustChange",
					  *(ent->entry.pw_end));
		if (ret)
		    goto out;
	    }
	}
    }


#if 0 /* we we have last_pw_change */
    if (is_samba_account && ent->entry.last_pw_change) {
	if (orig.entry.last_pw_change == NULL || (*(ent->entry.last_pw_change) != *(orig.entry.last_pw_change))) {
	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "sambaPwdLastSet",
				      *(ent->entry.last_pw_change));
	    if (ret)
		goto out;
	}
    }
#endif

    if (is_heimdal_entry && ent->entry.max_life) {
	if (orig.entry.max_life == NULL
	    || (*(ent->entry.max_life) != *(orig.entry.max_life))) {

	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "krb5MaxLife",
				      *(ent->entry.max_life));
	    if (ret)
		goto out;
	}
    }

    if (is_heimdal_entry && ent->entry.max_renew) {
	if (orig.entry.max_renew == NULL
	    || (*(ent->entry.max_renew) != *(orig.entry.max_renew))) {

	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "krb5MaxRenew",
				      *(ent->entry.max_renew));
	    if (ret)
		goto out;
	}
    }

    oflags = HDBFlags2int(orig.entry.flags);
    nflags = HDBFlags2int(ent->entry.flags);

    if (is_heimdal_entry && oflags != nflags) {

	ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				  "krb5KDCFlags",
				  nflags);
	if (ret)
	    goto out;
    }

    /* Remove keys if they exists, and then replace keys. */
    if (!is_new_entry && orig.entry.keys.len > 0) {
	vals = ldap_get_values_len(HDB2LDAP(db), msg, "krb5Key");
	if (vals) {
	    ldap_value_free_len(vals);

	    ret = LDAP_addmod(&mods, LDAP_MOD_DELETE, "krb5Key", NULL);
	    if (ret)
		goto out;
	}
    }

    for (i = 0; i < ent->entry.keys.len; i++) {

	if (is_samba_account
	    && ent->entry.keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5) {
	    char *ntHexPassword;
	    char *nt;
	    time_t now = time(NULL);

	    /* the key might have been 'sealed', but samba passwords
	       are clear in the directory */
	    ret = hdb_unseal_key(context, db, &ent->entry.keys.val[i]);
	    if (ret)
		goto out;

	    nt = ent->entry.keys.val[i].key.keyvalue.data;
	    /* store in ntPassword, not krb5key */
	    ret = hex_encode(nt, 16, &ntHexPassword);
	    if (ret < 0) {
		ret = ENOMEM;
		krb5_set_error_message(context, ret, "hdb-ldap: failed to "
				      "hex encode key");
		goto out;
	    }
	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "sambaNTPassword",
			      ntHexPassword);
	    free(ntHexPassword);
	    if (ret)
		goto out;
	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "sambaPwdLastSet", now);
	    if (ret)
		goto out;

	    /* have to kill the LM passwod if it exists */
	    vals = ldap_get_values_len(HDB2LDAP(db), msg, "sambaLMPassword");
	    if (vals) {
		ldap_value_free_len(vals);
		ret = LDAP_addmod(&mods, LDAP_MOD_DELETE,
				  "sambaLMPassword", NULL);
		if (ret)
		    goto out;
	    }

	} else if (is_heimdal_entry) {
	    unsigned char *buf;
	    size_t len, buf_size;

	    ASN1_MALLOC_ENCODE(Key, buf, buf_size, &ent->entry.keys.val[i], &len, ret);
	    if (ret)
		goto out;
	    if(buf_size != len)
		krb5_abortx(context, "internal error in ASN.1 encoder");

	    /* addmod_len _owns_ the key, doesn't need to copy it */
	    ret = LDAP_addmod_len(&mods, LDAP_MOD_ADD, "krb5Key", buf, len);
	    if (ret)
		goto out;
	}
    }

    if (ent->entry.etypes) {
	int add_krb5EncryptionType = 0;

	/*
	 * Only add/modify krb5EncryptionType if it's a new heimdal
	 * entry or krb5EncryptionType already exists on the entry.
	 */

	if (!is_new_entry) {
	    vals = ldap_get_values_len(HDB2LDAP(db), msg, "krb5EncryptionType");
	    if (vals) {
		ldap_value_free_len(vals);
		ret = LDAP_addmod(&mods, LDAP_MOD_DELETE, "krb5EncryptionType",
				  NULL);
		if (ret)
		    goto out;
		add_krb5EncryptionType = 1;
	    }
	} else if (is_heimdal_entry)
	    add_krb5EncryptionType = 1;

	if (add_krb5EncryptionType) {
	    for (i = 0; i < ent->entry.etypes->len; i++) {
		if (is_samba_account &&
		    ent->entry.keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5)
		{
		    ;
		} else if (is_heimdal_entry) {
		    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_ADD,
					      "krb5EncryptionType",
					      ent->entry.etypes->val[i]);
		    if (ret)
			goto out;
		}
	    }
	}
    }

    /* for clarity */
    ret = 0;

 out:

    if (ret == 0)
	*pmods = mods;
    else if (mods != NULL) {
	ldap_mods_free(mods, 1);
	*pmods = NULL;
    }

    if (msg)
	hdb_free_entry(context, &orig);

    return ret;
}

static krb5_error_code
LDAP_dn2principal(krb5_context context, HDB * db, const char *dn,
		  krb5_principal * principal)
{
    krb5_error_code ret;
    int rc;
    const char *filter = "(objectClass=krb5Principal)";
    LDAPMessage *res = NULL, *e;
    char *p;

    ret = LDAP_no_size_limit(context, HDB2LDAP(db));
    if (ret)
	goto out;

    rc = ldap_search_ext_s(HDB2LDAP(db), dn, LDAP_SCOPE_SUBTREE,
			   filter, krb5principal_attrs, 0,
			   NULL, NULL, NULL,
			   0, &res);
    if (check_ldap(context, db, rc)) {
	ret = HDB_ERR_NOENTRY;
	krb5_set_error_message(context, ret, "ldap_search_ext_s: "
			       "filter: %s error: %s",
			       filter, ldap_err2string(rc));
	goto out;
    }

    e = ldap_first_entry(HDB2LDAP(db), res);
    if (e == NULL) {
	ret = HDB_ERR_NOENTRY;
	goto out;
    }

    ret = LDAP_get_string_value(db, e, "krb5PrincipalName", &p);
    if (ret) {
	ret = HDB_ERR_NOENTRY;
	goto out;
    }

    ret = krb5_parse_name(context, p, principal);
    free(p);

  out:
    if (res)
	ldap_msgfree(res);

    return ret;
}

static int
need_quote(unsigned char c)
{
    return (c & 0x80) ||
	(c < 32) ||
	(c == '(') ||
	(c == ')') ||
	(c == '*') ||
	(c == '\\') ||
	(c == 0x7f);
}

const static char hexchar[] = "0123456789ABCDEF";

static krb5_error_code
escape_value(krb5_context context, const unsigned char *unquoted, char **quoted)
{
    size_t i, len;

    for (i = 0, len = 0; unquoted[i] != '\0'; i++, len++) {
	if (need_quote((unsigned char)unquoted[i]))
	    len += 2;
    }

    *quoted = malloc(len + 1);
    if (*quoted == NULL) {
	krb5_set_error_message(context, ENOMEM, "malloc: out of memory");
	return ENOMEM;
    }

    for (i = 0; unquoted[0] ; unquoted++) {
	if (need_quote((unsigned char *)unquoted[0])) {
	    (*quoted)[i++] = '\\';
	    (*quoted)[i++] = hexchar[(unquoted[0] >> 4) & 0xf];
	    (*quoted)[i++] = hexchar[(unquoted[0]     ) & 0xf];
	} else
	    (*quoted)[i++] = (char)unquoted[0];
    }
    (*quoted)[i] = '\0';
    return 0;
}


static krb5_error_code
LDAP__lookup_princ(krb5_context context,
		   HDB *db,
		   const char *princname,
		   const char *userid,
		   LDAPMessage **msg)
{
    krb5_error_code ret;
    int rc;
    char *quote, *filter = NULL;

    ret = LDAP__connect(context, db);
    if (ret)
	return ret;

    /*
     * Quote searches that contain filter language, this quote
     * searches for *@@REALM, which takes very long time.
     */

    ret = escape_value(context, princname, &quote);
    if (ret)
	goto out;

    rc = asprintf(&filter,
		  "(&(objectClass=krb5Principal)(krb5PrincipalName=%s))",
		  quote);
    free(quote);

    if (rc < 0) {
	ret = ENOMEM;
	krb5_set_error_message(context, ret, "malloc: out of memory");
	goto out;
    }

    ret = LDAP_no_size_limit(context, HDB2LDAP(db));
    if (ret)
	goto out;

    rc = ldap_search_ext_s(HDB2LDAP(db), HDB2BASE(db),
			   LDAP_SCOPE_SUBTREE, filter,
			   krb5kdcentry_attrs, 0,
			   NULL, NULL, NULL,
			   0, msg);
    if (check_ldap(context, db, rc)) {
	ret = HDB_ERR_NOENTRY;
	krb5_set_error_message(context, ret, "ldap_search_ext_s: "
			      "filter: %s - error: %s",
			      filter, ldap_err2string(rc));
	goto out;
    }

    if (userid && ldap_count_entries(HDB2LDAP(db), *msg) == 0) {
	free(filter);
	filter = NULL;
	ldap_msgfree(*msg);
	*msg = NULL;

	ret = escape_value(context, userid, &quote);
	if (ret)
	    goto out;

	rc = asprintf(&filter,
	    "(&(|(objectClass=sambaSamAccount)(objectClass=%s))(uid=%s))",
		      structural_object, quote);
	free(quote);
	if (rc < 0) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "asprintf: out of memory");
	    goto out;
	}

	ret = LDAP_no_size_limit(context, HDB2LDAP(db));
	if (ret)
	    goto out;

	rc = ldap_search_ext_s(HDB2LDAP(db), HDB2BASE(db), LDAP_SCOPE_SUBTREE,
			       filter, krb5kdcentry_attrs, 0,
			       NULL, NULL, NULL,
			       0, msg);
	if (check_ldap(context, db, rc)) {
	    ret = HDB_ERR_NOENTRY;
	    krb5_set_error_message(context, ret,
				   "ldap_search_ext_s: filter: %s error: %s",
				   filter, ldap_err2string(rc));
	    goto out;
	}
    }

    ret = 0;

  out:
    if (filter)
	free(filter);

    return ret;
}

static krb5_error_code
LDAP_principal2message(krb5_context context, HDB * db,
		       krb5_const_principal princ, LDAPMessage ** msg)
{
    char *name, *name_short = NULL;
    krb5_error_code ret;
    krb5_realm *r, *r0;

    *msg = NULL;

    ret = krb5_unparse_name(context, princ, &name);
    if (ret)
	return ret;

    ret = krb5_get_default_realms(context, &r0);
    if(ret) {
	free(name);
	return ret;
    }
    for (r = r0; *r != NULL; r++) {
	if(strcmp(krb5_principal_get_realm(context, princ), *r) == 0) {
	    ret = krb5_unparse_name_short(context, princ, &name_short);
	    if (ret) {
		krb5_free_host_realm(context, r0);
		free(name);
		return ret;
	    }
	    break;
	}
    }
    krb5_free_host_realm(context, r0);

    ret = LDAP__lookup_princ(context, db, name, name_short, msg);
    free(name);
    free(name_short);

    return ret;
}

/*
 * Construct an hdb_entry from a directory entry.
 */
static krb5_error_code
LDAP_message2entry(krb5_context context, HDB * db, LDAPMessage * msg,
		   int flags, hdb_entry_ex * ent)
{
    char *unparsed_name = NULL, *dn = NULL, *ntPasswordIN = NULL;
    char *samba_acct_flags = NULL;
    struct berval **keys;
    struct berval **vals;
    int tmp, tmp_time, i, ret, have_arcfour = 0;

    memset(ent, 0, sizeof(*ent));
    ent->entry.flags = int2HDBFlags(0);

    ret = LDAP_get_string_value(db, msg, "krb5PrincipalName", &unparsed_name);
    if (ret == 0) {
	ret = krb5_parse_name(context, unparsed_name, &ent->entry.principal);
	if (ret)
	    goto out;
    } else {
	ret = LDAP_get_string_value(db, msg, "uid",
				    &unparsed_name);
	if (ret == 0) {
	    ret = krb5_parse_name(context, unparsed_name, &ent->entry.principal);
	    if (ret)
		goto out;
	} else {
	    krb5_set_error_message(context, HDB_ERR_NOENTRY,
				   "hdb-ldap: ldap entry missing"
				  "principal name");
	    return HDB_ERR_NOENTRY;
	}
    }

    {
	int integer;
	ret = LDAP_get_integer_value(db, msg, "krb5KeyVersionNumber",
				     &integer);
	if (ret)
	    ent->entry.kvno = 0;
	else
	    ent->entry.kvno = integer;
    }

    keys = ldap_get_values_len(HDB2LDAP(db), msg, "krb5Key");
    if (keys != NULL) {
	int i;
	size_t l;

	ent->entry.keys.len = ldap_count_values_len(keys);
	ent->entry.keys.val = (Key *) calloc(ent->entry.keys.len, sizeof(Key));
	if (ent->entry.keys.val == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "calloc: out of memory");
	    goto out;
	}
	for (i = 0; i < ent->entry.keys.len; i++) {
	    decode_Key((unsigned char *) keys[i]->bv_val,
		       (size_t) keys[i]->bv_len, &ent->entry.keys.val[i], &l);
	}
	ber_bvecfree(keys);
    } else {
#if 1
	/*
	 * This violates the ASN1 but it allows a principal to
	 * be related to a general directory entry without creating
	 * the keys. Hopefully it's OK.
	 */
	ent->entry.keys.len = 0;
	ent->entry.keys.val = NULL;
#else
	ret = HDB_ERR_NOENTRY;
	goto out;
#endif
    }

    vals = ldap_get_values_len(HDB2LDAP(db), msg, "krb5EncryptionType");
    if (vals != NULL) {
	int i;

	ent->entry.etypes = malloc(sizeof(*(ent->entry.etypes)));
	if (ent->entry.etypes == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret,"malloc: out of memory");
	    goto out;
	}
	ent->entry.etypes->len = ldap_count_values_len(vals);
	ent->entry.etypes->val = calloc(ent->entry.etypes->len, sizeof(int));
	if (ent->entry.etypes->val == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "malloc: out of memory");
	    ent->entry.etypes->len = 0;
	    goto out;
	}
	for (i = 0; i < ent->entry.etypes->len; i++) {
	    char *buf;

	    buf = malloc(vals[i]->bv_len + 1);
	    if (buf == NULL) {
		ret = ENOMEM;
		krb5_set_error_message(context, ret, "malloc: out of memory");
		goto out;
	    }
	    memcpy(buf, vals[i]->bv_val, vals[i]->bv_len);
	    buf[vals[i]->bv_len] = '\0';
	    ent->entry.etypes->val[i] = atoi(buf);
	    free(buf);
	}
	ldap_value_free_len(vals);
    }

    for (i = 0; i < ent->entry.keys.len; i++) {
	if (ent->entry.keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5) {
	    have_arcfour = 1;
	    break;
	}
    }

    /* manually construct the NT (type 23) key */
    ret = LDAP_get_string_value(db, msg, "sambaNTPassword", &ntPasswordIN);
    if (ret == 0 && have_arcfour == 0) {
	unsigned *etypes;
	Key *keys;
	int i;

	keys = realloc(ent->entry.keys.val,
		       (ent->entry.keys.len + 1) * sizeof(ent->entry.keys.val[0]));
	if (keys == NULL) {
	    free(ntPasswordIN);
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "malloc: out of memory");
	    goto out;
	}
	ent->entry.keys.val = keys;
	memset(&ent->entry.keys.val[ent->entry.keys.len], 0, sizeof(Key));
	ent->entry.keys.val[ent->entry.keys.len].key.keytype = ETYPE_ARCFOUR_HMAC_MD5;
	ret = krb5_data_alloc (&ent->entry.keys.val[ent->entry.keys.len].key.keyvalue, 16);
	if (ret) {
	    krb5_set_error_message(context, ret, "malloc: out of memory");
	    free(ntPasswordIN);
	    ret = ENOMEM;
	    goto out;
	}
	ret = hex_decode(ntPasswordIN,
			 ent->entry.keys.val[ent->entry.keys.len].key.keyvalue.data, 16);
	ent->entry.keys.len++;

	if (ent->entry.etypes == NULL) {
	    ent->entry.etypes = malloc(sizeof(*(ent->entry.etypes)));
	    if (ent->entry.etypes == NULL) {
		ret = ENOMEM;
		krb5_set_error_message(context, ret, "malloc: out of memory");
		goto out;
	    }
	    ent->entry.etypes->val = NULL;
	    ent->entry.etypes->len = 0;
	}

	for (i = 0; i < ent->entry.etypes->len; i++)
	    if (ent->entry.etypes->val[i] == ETYPE_ARCFOUR_HMAC_MD5)
		break;
	/* If there is no ARCFOUR enctype, add one */
	if (i == ent->entry.etypes->len) {
	    etypes = realloc(ent->entry.etypes->val,
			     (ent->entry.etypes->len + 1) *
			     sizeof(ent->entry.etypes->val[0]));
	    if (etypes == NULL) {
		ret = ENOMEM;
		krb5_set_error_message(context, ret, "malloc: out of memory");
		goto out;
	    }
	    ent->entry.etypes->val = etypes;
	    ent->entry.etypes->val[ent->entry.etypes->len] =
		ETYPE_ARCFOUR_HMAC_MD5;
	    ent->entry.etypes->len++;
	}
    }

    ret = LDAP_get_generalized_time_value(db, msg, "createTimestamp",
					  &ent->entry.created_by.time);
    if (ret)
	ent->entry.created_by.time = time(NULL);

    ent->entry.created_by.principal = NULL;

    if (flags & HDB_F_ADMIN_DATA) {
	ret = LDAP_get_string_value(db, msg, "creatorsName", &dn);
	if (ret == 0) {
	    LDAP_dn2principal(context, db, dn, &ent->entry.created_by.principal);
	    free(dn);
	}

	ent->entry.modified_by = calloc(1, sizeof(*ent->entry.modified_by));
	if (ent->entry.modified_by == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "malloc: out of memory");
	    goto out;
	}

	ret = LDAP_get_generalized_time_value(db, msg, "modifyTimestamp",
					      &ent->entry.modified_by->time);
	if (ret == 0) {
	    ret = LDAP_get_string_value(db, msg, "modifiersName", &dn);
	    if (ret == 0) {
		LDAP_dn2principal(context, db, dn, &ent->entry.modified_by->principal);
		free(dn);
	    } else {
		free(ent->entry.modified_by);
		ent->entry.modified_by = NULL;
	    }
	}
    }

    ent->entry.valid_start = malloc(sizeof(*ent->entry.valid_start));
    if (ent->entry.valid_start == NULL) {
	ret = ENOMEM;
	krb5_set_error_message(context, ret, "malloc: out of memory");
	goto out;
    }
    ret = LDAP_get_generalized_time_value(db, msg, "krb5ValidStart",
					  ent->entry.valid_start);
    if (ret) {
	/* OPTIONAL */
	free(ent->entry.valid_start);
	ent->entry.valid_start = NULL;
    }

    ent->entry.valid_end = malloc(sizeof(*ent->entry.valid_end));
    if (ent->entry.valid_end == NULL) {
	ret = ENOMEM;
	krb5_set_error_message(context, ret, "malloc: out of memory");
	goto out;
    }
    ret = LDAP_get_generalized_time_value(db, msg, "krb5ValidEnd",
					  ent->entry.valid_end);
    if (ret) {
	/* OPTIONAL */
	free(ent->entry.valid_end);
	ent->entry.valid_end = NULL;
    }

    ret = LDAP_get_integer_value(db, msg, "sambaKickoffTime", &tmp_time);
    if (ret == 0) {
 	if (ent->entry.valid_end == NULL) {
 	    ent->entry.valid_end = malloc(sizeof(*ent->entry.valid_end));
 	    if (ent->entry.valid_end == NULL) {
 		ret = ENOMEM;
 		krb5_set_error_message(context, ret, "malloc: out of memory");
 		goto out;
 	    }
 	}
 	*ent->entry.valid_end = tmp_time;
    }

    ent->entry.pw_end = malloc(sizeof(*ent->entry.pw_end));
    if (ent->entry.pw_end == NULL) {
	ret = ENOMEM;
	krb5_set_error_message(context, ret, "malloc: out of memory");
	goto out;
    }
    ret = LDAP_get_generalized_time_value(db, msg, "krb5PasswordEnd",
					  ent->entry.pw_end);
    if (ret) {
	/* OPTIONAL */
	free(ent->entry.pw_end);
	ent->entry.pw_end = NULL;
    }

    ret = LDAP_get_integer_value(db, msg, "sambaPwdLastSet", &tmp_time);
    if (ret == 0) {
	time_t delta;

	if (ent->entry.pw_end == NULL) {
            ent->entry.pw_end = malloc(sizeof(*ent->entry.pw_end));
            if (ent->entry.pw_end == NULL) {
                ret = ENOMEM;
                krb5_set_error_message(context, ret, "malloc: out of memory");
                goto out;
            }
        }

	delta = krb5_config_get_time_default(context, NULL,
					     365 * 24 * 60 * 60,
					     "kadmin",
					     "password_lifetime",
					     NULL);
        *ent->entry.pw_end = tmp_time + delta;
    }

    ret = LDAP_get_integer_value(db, msg, "sambaPwdMustChange", &tmp_time);
    if (ret == 0) {
	if (ent->entry.pw_end == NULL) {
	    ent->entry.pw_end = malloc(sizeof(*ent->entry.pw_end));
	    if (ent->entry.pw_end == NULL) {
		ret = ENOMEM;
		krb5_set_error_message(context, ret, "malloc: out of memory");
		goto out;
	    }
	}
	*ent->entry.pw_end = tmp_time;
    }

    /* OPTIONAL */
    ret = LDAP_get_integer_value(db, msg, "sambaPwdLastSet", &tmp_time);
    if (ret == 0)
	hdb_entry_set_pw_change_time(context, &ent->entry, tmp_time);

    {
	int max_life;

	ent->entry.max_life = malloc(sizeof(*ent->entry.max_life));
	if (ent->entry.max_life == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "malloc: out of memory");
	    goto out;
	}
	ret = LDAP_get_integer_value(db, msg, "krb5MaxLife", &max_life);
	if (ret) {
	    free(ent->entry.max_life);
	    ent->entry.max_life = NULL;
	} else
	    *ent->entry.max_life = max_life;
    }

    {
	int max_renew;

	ent->entry.max_renew = malloc(sizeof(*ent->entry.max_renew));
	if (ent->entry.max_renew == NULL) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "malloc: out of memory");
	    goto out;
	}
	ret = LDAP_get_integer_value(db, msg, "krb5MaxRenew", &max_renew);
	if (ret) {
	    free(ent->entry.max_renew);
	    ent->entry.max_renew = NULL;
	} else
	    *ent->entry.max_renew = max_renew;
    }

    ret = LDAP_get_integer_value(db, msg, "krb5KDCFlags", &tmp);
    if (ret)
	tmp = 0;

    ent->entry.flags = int2HDBFlags(tmp);

    /* Try and find Samba flags to put into the mix */
    ret = LDAP_get_string_value(db, msg, "sambaAcctFlags", &samba_acct_flags);
    if (ret == 0) {
	/* parse the [UXW...] string:

	   'N'    No password
	   'D'    Disabled
	   'H'    Homedir required
	   'T'    Temp account.
	   'U'    User account (normal)
	   'M'    MNS logon user account - what is this ?
	   'W'    Workstation account
	   'S'    Server account
	   'L'    Locked account
	   'X'    No Xpiry on password
	   'I'    Interdomain trust account

	*/

	int i;
	int flags_len = strlen(samba_acct_flags);

	if (flags_len < 2)
	    goto out2;

	if (samba_acct_flags[0] != '['
	    || samba_acct_flags[flags_len - 1] != ']')
	    goto out2;

	/* Allow forwarding */
	if (samba_forwardable)
	    ent->entry.flags.forwardable = TRUE;

	for (i=0; i < flags_len; i++) {
	    switch (samba_acct_flags[i]) {
	    case ' ':
	    case '[':
	    case ']':
		break;
	    case 'N':
		/* how to handle no password in kerberos? */
		break;
	    case 'D':
		ent->entry.flags.invalid = TRUE;
		break;
	    case 'H':
		break;
	    case 'T':
		/* temp duplicate */
		ent->entry.flags.invalid = TRUE;
		break;
	    case 'U':
		ent->entry.flags.client = TRUE;
		break;
	    case 'M':
		break;
	    case 'W':
	    case 'S':
		ent->entry.flags.server = TRUE;
		ent->entry.flags.client = TRUE;
		break;
	    case 'L':
		ent->entry.flags.invalid = TRUE;
		break;
	    case 'X':
		if (ent->entry.pw_end) {
		    free(ent->entry.pw_end);
		    ent->entry.pw_end = NULL;
		}
		break;
	    case 'I':
		ent->entry.flags.server = TRUE;
		ent->entry.flags.client = TRUE;
		break;
	    }
	}
    out2:
	free(samba_acct_flags);
    }

    ret = 0;

out:
    if (unparsed_name)
	free(unparsed_name);

    if (ret)
	hdb_free_entry(context, ent);

    return ret;
}

static krb5_error_code
LDAP_close(krb5_context context, HDB * db)
{
    if (HDB2LDAP(db)) {
	ldap_unbind_ext(HDB2LDAP(db), NULL, NULL);
	((struct hdbldapdb *)db->hdb_db)->h_lp = NULL;
    }

    return 0;
}

static krb5_error_code
LDAP_lock(krb5_context context, HDB * db, int operation)
{
    return 0;
}

static krb5_error_code
LDAP_unlock(krb5_context context, HDB * db)
{
    return 0;
}

static krb5_error_code
LDAP_seq(krb5_context context, HDB * db, unsigned flags, hdb_entry_ex * entry)
{
    int msgid, rc, parserc;
    krb5_error_code ret;
    LDAPMessage *e;

    msgid = HDB2MSGID(db);
    if (msgid < 0)
	return HDB_ERR_NOENTRY;

    do {
	rc = ldap_result(HDB2LDAP(db), msgid, LDAP_MSG_ONE, NULL, &e);
	switch (rc) {
	case LDAP_RES_SEARCH_REFERENCE:
	    ldap_msgfree(e);
	    ret = 0;
	    break;
	case LDAP_RES_SEARCH_ENTRY:
	    /* We have an entry. Parse it. */
	    ret = LDAP_message2entry(context, db, e, flags, entry);
	    ldap_msgfree(e);
	    break;
	case LDAP_RES_SEARCH_RESULT:
	    /* We're probably at the end of the results. If not, abandon. */
	    parserc =
		ldap_parse_result(HDB2LDAP(db), e, NULL, NULL, NULL,
				  NULL, NULL, 1);
	    ret = HDB_ERR_NOENTRY;
	    if (parserc != LDAP_SUCCESS
		&& parserc != LDAP_MORE_RESULTS_TO_RETURN) {
	        krb5_set_error_message(context, ret, "ldap_parse_result: %s",
				       ldap_err2string(parserc));
		ldap_abandon_ext(HDB2LDAP(db), msgid, NULL, NULL);
	    }
	    HDBSETMSGID(db, -1);
	    break;
	case LDAP_SERVER_DOWN:
	    ldap_msgfree(e);
	    LDAP_close(context, db);
	    HDBSETMSGID(db, -1);
	    ret = ENETDOWN;
	    break;
	default:
	    /* Some unspecified error (timeout?). Abandon. */
	    ldap_msgfree(e);
	    ldap_abandon_ext(HDB2LDAP(db), msgid, NULL, NULL);
	    ret = HDB_ERR_NOENTRY;
	    HDBSETMSGID(db, -1);
	    break;
	}
    } while (rc == LDAP_RES_SEARCH_REFERENCE);

    if (ret == 0) {
	if (db->hdb_master_key_set && (flags & HDB_F_DECRYPT)) {
	    ret = hdb_unseal_keys(context, db, &entry->entry);
	    if (ret)
		hdb_free_entry(context, entry);
	}
    }

    return ret;
}

static krb5_error_code
LDAP_firstkey(krb5_context context, HDB *db, unsigned flags,
	      hdb_entry_ex *entry)
{
    krb5_error_code ret;
    int msgid;

    ret = LDAP__connect(context, db);
    if (ret)
	return ret;

    ret = LDAP_no_size_limit(context, HDB2LDAP(db));
    if (ret)
	return ret;

    ret = ldap_search_ext(HDB2LDAP(db), HDB2BASE(db),
			LDAP_SCOPE_SUBTREE,
			"(|(objectClass=krb5Principal)(objectClass=sambaSamAccount))",
			krb5kdcentry_attrs, 0,
			NULL, NULL, NULL, 0, &msgid);
    if (msgid < 0)
	return HDB_ERR_NOENTRY;

    HDBSETMSGID(db, msgid);

    return LDAP_seq(context, db, flags, entry);
}

static krb5_error_code
LDAP_nextkey(krb5_context context, HDB * db, unsigned flags,
	     hdb_entry_ex * entry)
{
    return LDAP_seq(context, db, flags, entry);
}

static krb5_error_code
LDAP__connect(krb5_context context, HDB * db)
{
    int rc, version = LDAP_VERSION3;
    /*
     * Empty credentials to do a SASL bind with LDAP. Note that empty
     * different from NULL credentials. If you provide NULL
     * credentials instead of empty credentials you will get a SASL
     * bind in progress message.
     */
    struct berval bv = { 0, "" };

    if (HDB2LDAP(db)) {
	/* connection has been opened. ping server. */
	struct sockaddr_un addr;
	socklen_t len = sizeof(addr);
	int sd;

	if (ldap_get_option(HDB2LDAP(db), LDAP_OPT_DESC, &sd) == 0 &&
	    getpeername(sd, (struct sockaddr *) &addr, &len) < 0) {
	    /* the other end has died. reopen. */
	    LDAP_close(context, db);
	}
    }

    if (HDB2LDAP(db) != NULL) /* server is UP */
	return 0;

    rc = ldap_initialize(&((struct hdbldapdb *)db->hdb_db)->h_lp, HDB2URL(db));
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_message(context, HDB_ERR_NOENTRY, "ldap_initialize: %s",
			       ldap_err2string(rc));
	return HDB_ERR_NOENTRY;
    }

    rc = ldap_set_option(HDB2LDAP(db), LDAP_OPT_PROTOCOL_VERSION,
			 (const void *)&version);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_message(context, HDB_ERR_BADVERSION,
			       "ldap_set_option: %s", ldap_err2string(rc));
	LDAP_close(context, db);
	return HDB_ERR_BADVERSION;
    }

    rc = ldap_sasl_bind_s(HDB2LDAP(db), NULL, "EXTERNAL", &bv,
			  NULL, NULL, NULL);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_message(context, HDB_ERR_BADVERSION,
			      "ldap_sasl_bind_s: %s", ldap_err2string(rc));
	LDAP_close(context, db);
	return HDB_ERR_BADVERSION;
    }

    return 0;
}

static krb5_error_code
LDAP_open(krb5_context context, HDB * db, int flags, mode_t mode)
{
    /* Not the right place for this. */
#ifdef HAVE_SIGACTION
    struct sigaction sa;

    sa.sa_flags = 0;
    sa.sa_handler = SIG_IGN;
    sigemptyset(&sa.sa_mask);

    sigaction(SIGPIPE, &sa, NULL);
#else
    signal(SIGPIPE, SIG_IGN);
#endif /* HAVE_SIGACTION */

    return LDAP__connect(context, db);
}

static krb5_error_code
LDAP_fetch_kvno(krb5_context context, HDB * db, krb5_const_principal principal,
		unsigned flags, krb5_kvno kvno, hdb_entry_ex * entry)
{
    LDAPMessage *msg, *e;
    krb5_error_code ret;

    ret = LDAP_principal2message(context, db, principal, &msg);
    if (ret)
	return ret;

    e = ldap_first_entry(HDB2LDAP(db), msg);
    if (e == NULL) {
	ret = HDB_ERR_NOENTRY;
	goto out;
    }

    ret = LDAP_message2entry(context, db, e, flags, entry);
    if (ret == 0) {
	if (db->hdb_master_key_set && (flags & HDB_F_DECRYPT)) {
	    ret = hdb_unseal_keys(context, db, &entry->entry);
	    if (ret)
		hdb_free_entry(context, entry);
	}
    }

  out:
    ldap_msgfree(msg);

    return ret;
}

static krb5_error_code
LDAP_fetch(krb5_context context, HDB * db, krb5_const_principal principal,
	   unsigned flags, hdb_entry_ex * entry)
{
    return LDAP_fetch_kvno(context, db, principal,
			   flags & (~HDB_F_KVNO_SPECIFIED), 0, entry);
}

static krb5_error_code
LDAP_store(krb5_context context, HDB * db, unsigned flags,
	   hdb_entry_ex * entry)
{
    LDAPMod **mods = NULL;
    krb5_error_code ret;
    const char *errfn;
    int rc;
    LDAPMessage *msg = NULL, *e = NULL;
    char *dn = NULL, *name = NULL;

    ret = LDAP_principal2message(context, db, entry->entry.principal, &msg);
    if (ret == 0)
	e = ldap_first_entry(HDB2LDAP(db), msg);

    ret = krb5_unparse_name(context, entry->entry.principal, &name);
    if (ret) {
	free(name);
	return ret;
    }

    ret = hdb_seal_keys(context, db, &entry->entry);
    if (ret)
	goto out;

    /* turn new entry into LDAPMod array */
    ret = LDAP_entry2mods(context, db, entry, e, &mods);
    if (ret)
	goto out;

    if (e == NULL) {
	ret = asprintf(&dn, "krb5PrincipalName=%s,%s", name, HDB2CREATE(db));
	if (ret < 0) {
	    ret = ENOMEM;
	    krb5_set_error_message(context, ret, "asprintf: out of memory");
	    goto out;
	}
    } else if (flags & HDB_F_REPLACE) {
	/* Entry exists, and we're allowed to replace it. */
	dn = ldap_get_dn(HDB2LDAP(db), e);
    } else {
	/* Entry exists, but we're not allowed to replace it. Bail. */
	ret = HDB_ERR_EXISTS;
	goto out;
    }

    /* write entry into directory */
    if (e == NULL) {
	/* didn't exist before */
	rc = ldap_add_ext_s(HDB2LDAP(db), dn, mods, NULL, NULL );
	errfn = "ldap_add_ext_s";
    } else {
	/* already existed, send deltas only */
	rc = ldap_modify_ext_s(HDB2LDAP(db), dn, mods, NULL, NULL );
	errfn = "ldap_modify_ext_s";
    }

    if (check_ldap(context, db, rc)) {
	char *ld_error = NULL;
	ldap_get_option(HDB2LDAP(db), LDAP_OPT_ERROR_STRING,
			&ld_error);
	ret = HDB_ERR_CANT_LOCK_DB;
	krb5_set_error_message(context, ret, "%s: %s (DN=%s) %s: %s",
			      errfn, name, dn, ldap_err2string(rc), ld_error);
    } else
	ret = 0;

  out:
    /* free stuff */
    if (dn)
	free(dn);
    if (msg)
	ldap_msgfree(msg);
    if (mods)
	ldap_mods_free(mods, 1);
    if (name)
	free(name);

    return ret;
}

static krb5_error_code
LDAP_remove(krb5_context context, HDB *db, krb5_const_principal principal)
{
    krb5_error_code ret;
    LDAPMessage *msg, *e;
    char *dn = NULL;
    int rc, limit = LDAP_NO_LIMIT;

    ret = LDAP_principal2message(context, db, principal, &msg);
    if (ret)
	goto out;

    e = ldap_first_entry(HDB2LDAP(db), msg);
    if (e == NULL) {
	ret = HDB_ERR_NOENTRY;
	goto out;
    }

    dn = ldap_get_dn(HDB2LDAP(db), e);
    if (dn == NULL) {
	ret = HDB_ERR_NOENTRY;
	goto out;
    }

    rc = ldap_set_option(HDB2LDAP(db), LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (rc != LDAP_SUCCESS) {
	ret = HDB_ERR_BADVERSION;
	krb5_set_error_message(context, ret, "ldap_set_option: %s",
			      ldap_err2string(rc));
	goto out;
    }

    rc = ldap_delete_ext_s(HDB2LDAP(db), dn, NULL, NULL );
    if (check_ldap(context, db, rc)) {
	ret = HDB_ERR_CANT_LOCK_DB;
	krb5_set_error_message(context, ret, "ldap_delete_ext_s: %s",
			       ldap_err2string(rc));
    } else
	ret = 0;

  out:
    if (dn != NULL)
	free(dn);
    if (msg != NULL)
	ldap_msgfree(msg);

    return ret;
}

static krb5_error_code
LDAP_destroy(krb5_context context, HDB * db)
{
    krb5_error_code ret;

    LDAP_close(context, db);

    ret = hdb_clear_master_key(context, db);
    if (HDB2BASE(db))
	free(HDB2BASE(db));
    if (HDB2CREATE(db))
	free(HDB2CREATE(db));
    if (HDB2URL(db))
	free(HDB2URL(db));
    if (db->hdb_name)
	free(db->hdb_name);
    free(db->hdb_db);
    free(db);

    return ret;
}

static krb5_error_code
hdb_ldap_common(krb5_context context,
		HDB ** db,
		const char *search_base,
		const char *url)
{
    struct hdbldapdb *h;
    const char *create_base = NULL;

    if (search_base == NULL && search_base[0] == '\0') {
	krb5_set_error_message(context, ENOMEM, "ldap search base not configured");
	return ENOMEM; /* XXX */
    }

    if (structural_object == NULL) {
	const char *p;

	p = krb5_config_get_string(context, NULL, "kdc",
				   "hdb-ldap-structural-object", NULL);
	if (p == NULL)
	    p = default_structural_object;
	structural_object = strdup(p);
	if (structural_object == NULL) {
	    krb5_set_error_message(context, ENOMEM, "malloc: out of memory");
	    return ENOMEM;
	}
    }

    samba_forwardable =
	krb5_config_get_bool_default(context, NULL, TRUE,
				     "kdc", "hdb-samba-forwardable", NULL);

    *db = calloc(1, sizeof(**db));
    if (*db == NULL) {
	krb5_set_error_message(context, ENOMEM, "malloc: out of memory");
	return ENOMEM;
    }
    memset(*db, 0, sizeof(**db));

    h = calloc(1, sizeof(*h));
    if (h == NULL) {
	free(*db);
	*db = NULL;
	krb5_set_error_message(context, ENOMEM, "malloc: out of memory");
	return ENOMEM;
    }
    (*db)->hdb_db = h;

    /* XXX */
    if (asprintf(&(*db)->hdb_name, "ldap:%s", search_base) == -1) {
	LDAP_destroy(context, *db);
	*db = NULL;
	krb5_set_error_message(context, ENOMEM, "strdup: out of memory");
	return ENOMEM;
    }

    h->h_url = strdup(url);
    h->h_base = strdup(search_base);
    if (h->h_url == NULL || h->h_base == NULL) {
	LDAP_destroy(context, *db);
	*db = NULL;
	krb5_set_error_message(context, ENOMEM, "strdup: out of memory");
	return ENOMEM;
    }

    create_base = krb5_config_get_string(context, NULL, "kdc",
					 "hdb-ldap-create-base", NULL);
    if (create_base == NULL)
	create_base = h->h_base;

    h->h_createbase = strdup(create_base);
    if (h->h_createbase == NULL) {
	LDAP_destroy(context, *db);
	*db = NULL;
	krb5_set_error_message(context, ENOMEM, "strdup: out of memory");
	return ENOMEM;
    }

    (*db)->hdb_master_key_set = 0;
    (*db)->hdb_openp = 0;
    (*db)->hdb_capability_flags = 0;
    (*db)->hdb_open = LDAP_open;
    (*db)->hdb_close = LDAP_close;
    (*db)->hdb_fetch_kvno = LDAP_fetch_kvno;
    (*db)->hdb_store = LDAP_store;
    (*db)->hdb_remove = LDAP_remove;
    (*db)->hdb_firstkey = LDAP_firstkey;
    (*db)->hdb_nextkey = LDAP_nextkey;
    (*db)->hdb_lock = LDAP_lock;
    (*db)->hdb_unlock = LDAP_unlock;
    (*db)->hdb_rename = NULL;
    (*db)->hdb__get = NULL;
    (*db)->hdb__put = NULL;
    (*db)->hdb__del = NULL;
    (*db)->hdb_destroy = LDAP_destroy;

    return 0;
}

krb5_error_code
hdb_ldap_create(krb5_context context, HDB ** db, const char *arg)
{
    return hdb_ldap_common(context, db, arg, "ldapi:///");
}

krb5_error_code
hdb_ldapi_create(krb5_context context, HDB ** db, const char *arg)
{
    krb5_error_code ret;
    char *search_base, *p;

    asprintf(&p, "ldapi:%s", arg);
    if (p == NULL) {
	*db = NULL;
	krb5_set_error_message(context, ENOMEM, "out of memory");
	return ENOMEM;
    }
    search_base = strchr(p + strlen("ldapi://"), ':');
    if (search_base == NULL) {
	*db = NULL;
	krb5_set_error_message(context, HDB_ERR_BADVERSION,
			       "search base missing");
	return HDB_ERR_BADVERSION;
    }
    *search_base = '\0';
    search_base++;

    ret = hdb_ldap_common(context, db, search_base, p);
    free(p);
    return ret;
}

#ifdef OPENLDAP_MODULE

struct hdb_so_method hdb_ldap_interface = {
    HDB_INTERFACE_VERSION,
    "ldap",
    hdb_ldap_create
};

struct hdb_so_method hdb_ldapi_interface = {
    HDB_INTERFACE_VERSION,
    "ldapi",
    hdb_ldapi_create
};

#endif

#endif				/* OPENLDAP */
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.2
log
@Clear errno before calling the strtol functions.

From Paul Stoeber <x0001 at x dot de1 dot cc>.

OK deraadt@@.
@
text
@d4 1
a4 1
 * Copyright (c) 2003 - 2004, Kungliga Tekniska Högskolan.
a36 2
RCSID("$KTH: hdb-ldap.c,v 1.49 2005/04/18 08:03:54 lha Exp $");

d49 1
a49 1
		   hdb_entry * ent);
d59 1
d68 1
d75 1
a75 1
static char * krb5kdcentry_attrs[] = { 
d122 3
a124 2
	krb5_set_error_string(context, "ldap_set_option: %s",
			      ldap_err2string(ret));
d224 1
a224 1
	bv[i] = ber_memalloc(sizeof(*bv));;
d228 1
a228 1
	bv[i]->bv_val = value;
d297 3
a299 2
	krb5_set_error_string(context, "asprintf: out of memory:");
	return ret;
d310 1
a310 2
    char **vals;
    int ret;
d312 2
a313 2
    vals = ldap_get_values(HDB2LDAP(db), entry, (char *) attribute);
    if (vals == NULL) {
d318 8
a325 5
    *ptr = strdup(vals[0]);
    if (*ptr == NULL)
	ret = ENOMEM;
    else
	ret = 0;
d327 1
a327 1
    ldap_value_free(vals);
d329 1
a329 1
    return ret;
d336 2
a337 1
    char **vals;
d339 5
a343 6
    vals = ldap_get_values(HDB2LDAP(db), entry, (char *) attribute);
    if (vals == NULL)
	return HDB_ERR_NOENTRY;

    *ptr = atoi(vals[0]);
    ldap_value_free(vals);
d374 8
d383 1
a383 1
LDAP_entry2mods(krb5_context context, HDB * db, hdb_entry * ent,
d390 1
a390 1
    hdb_entry orig;
d399 1
a399 1
    char **values;
d405 1
a405 1
	ret = LDAP_message2entry(context, db, msg, &orig);
d410 4
a413 4
	    
	values = ldap_get_values(HDB2LDAP(db), msg, "objectClass");
	if (values) {
	    int num_objectclasses = ldap_count_values(values);
d415 1
a415 1
		if (strcasecmp(values[i], "sambaSamAccount") == 0) {
d417 1
a417 1
		} else if (strcasecmp(values[i], structural_object) == 0) {
d419 1
a419 1
		} else if (strcasecmp(values[i], "krb5Principal") == 0) {
d421 1
a421 1
		} else if (strcasecmp(values[i], "krb5KDCEntry") == 0) {
a422 1
		}
d424 1
a424 1
	    ldap_value_free(values);
d429 1
a429 1
	 * is hanging on this entry, its really a new entry.
d431 1
a431 1
	if (is_samba_account == FALSE && is_heimdal_principal == FALSE && 
d452 1
a452 1
	
d455 1
a455 1
	    ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", 
d473 2
a474 2
    if (is_new_entry || 
	krb5_principal_compare(context, ent->principal, orig.principal)
d479 1
a479 1
	    ret = krb5_unparse_name(context, ent->principal, &tmp);
d493 1
a493 1
	    ret = krb5_unparse_name_short(context, ent->principal, &tmp);
d505 1
a505 1
    if (is_heimdal_entry && (ent->kvno != orig.kvno || is_new_entry)) {
d507 2
a508 2
			    "krb5KeyVersionNumber", 
			    ent->kvno);
d513 3
a515 3
    if (is_heimdal_entry && ent->valid_start) {
	if (orig.valid_end == NULL
	    || (*(ent->valid_start) != *(orig.valid_start))) {
d518 1
a518 1
					       ent->valid_start);
d524 3
a526 3
    if (ent->valid_end) {
 	if (orig.valid_end == NULL || (*(ent->valid_end) != *(orig.valid_end))) {
	    if (is_heimdal_entry) { 
d529 1
a529 1
						   ent->valid_end);
d535 2
a536 2
					  "sambaKickoffTime", 
					  *(ent->valid_end));
d543 2
a544 2
    if (ent->pw_end) {
	if (orig.pw_end == NULL || (*(ent->pw_end) != *(orig.pw_end))) {
d548 1
a548 1
						   ent->pw_end);
d555 2
a556 2
					  "sambaPwdMustChange", 
					  *(ent->pw_end));
d565 2
a566 2
    if (is_samba_account && ent->last_pw_change) {
	if (orig.last_pw_change == NULL || (*(ent->last_pw_change) != *(orig.last_pw_change))) {
d568 2
a569 2
				      "sambaPwdLastSet", 
				      *(ent->last_pw_change));
d576 3
a578 3
    if (is_heimdal_entry && ent->max_life) {
	if (orig.max_life == NULL
	    || (*(ent->max_life) != *(orig.max_life))) {
d581 2
a582 2
				      "krb5MaxLife", 
				      *(ent->max_life));
d588 3
a590 3
    if (is_heimdal_entry && ent->max_renew) {
	if (orig.max_renew == NULL
	    || (*(ent->max_renew) != *(orig.max_renew))) {
d594 1
a594 1
				      *(ent->max_renew));
d600 2
a601 2
    oflags = HDBFlags2int(orig.flags);
    nflags = HDBFlags2int(ent->flags);
d613 4
a616 4
    if (!is_new_entry && orig.keys.len > 0) {
	values = ldap_get_values(HDB2LDAP(db), msg, "krb5Key");
	if (values) {
	    ldap_value_free(values);
d624 1
a624 1
    for (i = 0; i < ent->keys.len; i++) {
d627 1
a627 1
	    && ent->keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5) {
d630 2
a631 1
		    
d634 1
a634 1
	    ret = hdb_unseal_key(context, db, &ent->keys.val[i]);
d637 2
a638 2
		    
	    nt = ent->keys.val[i].key.keyvalue.data;
d642 2
a643 1
		krb5_set_error_string(context, "hdb-ldap: failed to "
a644 1
		ret = ENOMEM;
d647 1
a647 1
	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "sambaNTPassword", 
d652 5
a656 1
		    
d658 3
a660 3
	    values = ldap_get_values(HDB2LDAP(db), msg, "sambaLMPassword");
	    if (values) {
		ldap_value_free(values);
d666 1
a666 1
		    
d671 1
a671 1
	    ASN1_MALLOC_ENCODE(Key, buf, buf_size, &ent->keys.val[i], &len, ret);
d684 8
a691 2
    if (ent->etypes) {
	/* clobber and replace encryption types. */
d693 3
a695 3
	    values = ldap_get_values(HDB2LDAP(db), msg, "krb5EncryptionType");
	    if (values) {
		ldap_value_free(values);
d700 1
d702 16
a717 12
	}
	for (i = 0; i < ent->etypes->len; i++) {
	    if (is_samba_account && 
		ent->keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5)
	    {
		;
	    } else if (is_heimdal_entry) {
		ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_ADD,
					  "krb5EncryptionType",
					  ent->etypes->val[i]);
		if (ret)
		    goto out;
d746 1
a746 1
    char **values;
d748 1
d754 4
a757 3
    rc = ldap_search_s(HDB2LDAP(db), dn, LDAP_SCOPE_SUBTREE,
		       "(objectClass=krb5Principal)", krb5principal_attrs,
		       0, &res);
a758 2
	krb5_set_error_string(context, "ldap_search_s: %s",
			      ldap_err2string(rc));
d760 3
d772 2
a773 2
    values = ldap_get_values(HDB2LDAP(db), e, "krb5PrincipalName");
    if (values == NULL) {
d778 2
a779 2
    ret = krb5_parse_name(context, values[0], principal);
    ldap_value_free(values);
d788 43
d840 1
a840 1
    char *filter = NULL;
d846 9
d857 3
a859 1
		  princname);
a860 1
	krb5_set_error_string(context, "asprintf: out of memory");
d862 1
d870 5
a874 2
    rc = ldap_search_s(HDB2LDAP(db), HDB2BASE(db), LDAP_SCOPE_SUBTREE, filter, 
		       krb5kdcentry_attrs, 0, msg);
a875 2
	krb5_set_error_string(context, "ldap_search_s: %s",
			      ldap_err2string(rc));
d877 3
d888 5
a892 1
	
d895 2
a896 1
		      structural_object, userid);
a897 1
	    krb5_set_error_string(context, "asprintf: out of memory");
d899 1
d902 1
a902 1
	    
d907 4
a910 2
	rc = ldap_search_s(HDB2LDAP(db), HDB2BASE(db), LDAP_SCOPE_SUBTREE, 
			   filter, krb5kdcentry_attrs, 0, msg);
a911 2
	    krb5_set_error_string(context, "ldap_search_s: %s",
				  ldap_err2string(rc));
d913 3
d931 1
a931 1
		       krb5_principal princ, LDAPMessage ** msg)
d973 1
a973 1
		   hdb_entry * ent)
a976 2
    int ret;
    unsigned long tmp;
d978 2
a979 2
    char **values;
    int tmp_time;
d982 1
a982 1
    ent->flags = int2HDBFlags(0);
d986 1
a986 1
	ret = krb5_parse_name(context, unparsed_name, &ent->principal);
d993 1
a993 1
	    ret = krb5_parse_name(context, unparsed_name, &ent->principal);
d997 2
a998 1
	    krb5_set_error_string(context, "hdb-ldap: ldap entry missing"
d1004 9
a1012 4
    ret = LDAP_get_integer_value(db, msg, "krb5KeyVersionNumber",
				 &ent->kvno);
    if (ret)
	ent->kvno = 0;
d1019 3
a1021 4
	ent->keys.len = ldap_count_values_len(keys);
	ent->keys.val = (Key *) calloc(ent->keys.len, sizeof(Key));
	if (ent->keys.val == NULL) {
	    krb5_set_error_string(context, "calloc: out of memory");
d1023 1
d1026 1
a1026 1
	for (i = 0; i < ent->keys.len; i++) {
d1028 1
a1028 1
		       (size_t) keys[i]->bv_len, &ent->keys.val[i], &l);
d1038 2
a1039 2
	ent->keys.len = 0;
	ent->keys.val = NULL;
d1046 2
a1047 2
    values = ldap_get_values(HDB2LDAP(db), msg, "krb5EncryptionType");
    if (values != NULL) {
d1050 2
a1051 3
	ent->etypes = malloc(sizeof(*(ent->etypes)));
	if (ent->etypes == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
d1053 1
d1056 3
a1058 4
	ent->etypes->len = ldap_count_values(values);
	ent->etypes->val = calloc(ent->etypes->len, sizeof(int));
	if (ent->etypes->val == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
d1060 2
d1064 21
a1084 2
	for (i = 0; i < ent->etypes->len; i++) {
	    ent->etypes->val[i] = atoi(values[i]);
a1085 1
	ldap_value_free(values);
d1090 2
a1091 2
    if (ret == 0) {
	int *etypes;
d1093 1
d1095 2
a1096 2
	keys = realloc(ent->keys.val,
		       (ent->keys.len + 1) * sizeof(ent->keys.val[0]));
a1098 1
	    krb5_set_error_string(context, "malloc: out of memory");
d1100 1
d1103 4
a1106 4
	ent->keys.val = keys;
	memset(&ent->keys.val[ent->keys.len], 0, sizeof(Key));
	ent->keys.val[ent->keys.len].key.keytype = ETYPE_ARCFOUR_HMAC_MD5;
	ret = krb5_data_alloc (&ent->keys.val[ent->keys.len].key.keyvalue, 16);
d1108 1
a1108 1
	    krb5_set_error_string(context, "malloc: out of memory");
d1114 2
a1115 2
			 ent->keys.val[ent->keys.len].key.keyvalue.data, 16);
	ent->keys.len++;
d1117 3
a1119 4
	if (ent->etypes == NULL) {
	    ent->etypes = malloc(sizeof(*(ent->etypes)));
	    if (ent->etypes == NULL) {
		krb5_set_error_string(context, "malloc: out of memory");
d1121 1
d1124 2
a1125 2
	    ent->etypes->val = NULL;
	    ent->etypes->len = 0;
d1128 17
a1144 6
	etypes = realloc(ent->etypes->val, 
			 (ent->etypes->len + 1) * sizeof(ent->etypes->val[0]));
	if (etypes == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    ret = ENOMEM;
	    goto out;			    
a1145 3
	ent->etypes->val = etypes;
	ent->etypes->val[ent->etypes->len] = ETYPE_ARCFOUR_HMAC_MD5;
	ent->etypes->len++;
d1149 1
a1149 1
					  &ent->created_by.time);
d1151 1
a1151 1
	ent->created_by.time = time(NULL);
d1153 1
a1153 1
    ent->created_by.principal = NULL;
d1155 12
a1166 5
    ret = LDAP_get_string_value(db, msg, "creatorsName", &dn);
    if (ret == 0) {
	if (LDAP_dn2principal(context, db, dn, &ent->created_by.principal)
	    != 0) {
	    ent->created_by.principal = NULL;
a1167 2
	free(dn);
    }
d1169 12
a1180 16
    ent->modified_by = (Event *) malloc(sizeof(Event));
    if (ent->modified_by == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
	goto out;
    }
    ret = LDAP_get_generalized_time_value(db, msg, "modifyTimestamp",
					  &ent->modified_by->time);
    if (ret == 0) {
	ret = LDAP_get_string_value(db, msg, "modifiersName", &dn);
	if (LDAP_dn2principal(context, db, dn, &ent->modified_by->principal))
	    ent->modified_by->principal = NULL;
	free(dn);
    } else {
	free(ent->modified_by);
	ent->modified_by = NULL;
d1183 2
a1184 3
    ent->valid_start = malloc(sizeof(*ent->valid_start));
    if (ent->valid_start == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d1186 1
d1190 1
a1190 1
					  ent->valid_start);
d1193 2
a1194 2
	free(ent->valid_start);
	ent->valid_start = NULL;
d1196 3
a1198 4
    
    ent->valid_end = malloc(sizeof(*ent->valid_end));
    if (ent->valid_end == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d1200 1
d1204 1
a1204 1
					  ent->valid_end);
d1207 2
a1208 2
	free(ent->valid_end);
	ent->valid_end = NULL;
d1213 3
a1215 4
 	if (ent->valid_end == NULL) {
 	    ent->valid_end = malloc(sizeof(*ent->valid_end));
 	    if (ent->valid_end == NULL) {
 		krb5_set_error_string(context, "malloc: out of memory");
d1217 1
d1221 1
a1221 1
 	*ent->valid_end = tmp_time;
d1224 2
a1225 3
    ent->pw_end = malloc(sizeof(*ent->pw_end));
    if (ent->pw_end == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
d1227 1
d1231 1
a1231 1
					  ent->pw_end);
d1234 23
a1256 2
	free(ent->pw_end);
	ent->pw_end = NULL;
d1261 3
a1263 4
	if (ent->pw_end == NULL) {
	    ent->pw_end = malloc(sizeof(*ent->pw_end));
	    if (ent->pw_end == NULL) {
		krb5_set_error_string(context, "malloc: out of memory");
d1265 1
d1269 1
a1269 1
	*ent->pw_end = tmp_time;
d1272 7
a1278 16
#if 0 /* we we have last_pw_change */
    ent->last_pw_change = malloc(sizeof(*ent->last_pw_change));
    if (ent->last_pw_change == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
	goto out;
    }
    ret = LDAP_get_integer_value(db, msg, "sambaPwdLastSet",
				 &tmp_time);
    if (ret) {
	/* OPTIONAL */
	free(ent->last_pw_change);
	ent->last_pw_change = NULL;
    } else
	*ent->last_pw_change = tmp_time;
#endif
d1280 12
a1291 10
    ent->max_life = malloc(sizeof(*ent->max_life));
    if (ent->max_life == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
	goto out;
    }
    ret = LDAP_get_integer_value(db, msg, "krb5MaxLife", ent->max_life);
    if (ret) {
	free(ent->max_life);
	ent->max_life = NULL;
d1294 2
a1295 11
    ent->max_renew = malloc(sizeof(*ent->max_renew));
    if (ent->max_renew == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
	goto out;
    }
    ret = LDAP_get_integer_value(db, msg, "krb5MaxRenew", ent->max_renew);
    if (ret) {
	free(ent->max_renew);
	ent->max_renew = NULL;
    }
d1297 4
a1300 7
    values = ldap_get_values(HDB2LDAP(db), msg, "krb5KDCFlags");
    if (values != NULL) {
	errno = 0;
	tmp = strtoul(values[0], (char **) NULL, 10);
	if (tmp == ULONG_MAX && errno == ERANGE) {
	    krb5_set_error_string(context, "strtoul: could not convert flag");
	    ret = ERANGE;
d1303 10
a1312 1
    } else {
a1313 1
    }
d1315 1
a1315 1
    ent->flags = int2HDBFlags(tmp);
d1321 15
a1335 15
	       
	'N'    No password	 
	'D'    Disabled	 
	'H'    Homedir required	 
	'T'    Temp account.	 
	'U'    User account (normal) 	 
	'M'    MNS logon user account - what is this ? 	 
	'W'    Workstation account	 
	'S'    Server account 	 
	'L'    Locked account	 
	'X'    No Xpiry on password 	 
	'I'    Interdomain trust account	 
	    
	*/	 
	    
d1342 2
a1343 2
	if (samba_acct_flags[0] != '[' 
	    || samba_acct_flags[flags_len - 1] != ']') 
d1348 1
a1348 1
	    ent->flags.forwardable = TRUE;
d1360 1
a1360 1
		ent->flags.invalid = TRUE;
d1366 1
a1366 1
		ent->flags.invalid = TRUE;
d1369 1
a1369 1
		ent->flags.client = TRUE;
d1375 2
a1376 2
		ent->flags.server = TRUE;
		ent->flags.client = TRUE;
d1379 1
a1379 1
		ent->flags.invalid = TRUE;
d1382 3
a1384 3
		if (ent->pw_end) {
		    free(ent->pw_end);
		    ent->pw_end = NULL;
d1388 2
a1389 2
		ent->flags.server = TRUE;
		ent->flags.client = TRUE;
d1399 1
a1399 1
 out:
d1416 1
a1416 1
    
d1433 1
a1433 1
LDAP_seq(krb5_context context, HDB * db, unsigned flags, hdb_entry * entry)
d1452 1
a1452 1
	    ret = LDAP_message2entry(context, db, e, entry);
d1460 1
d1463 3
a1465 3
	        krb5_set_error_string(context, "ldap_parse_result: %s",
				      ldap_err2string(parserc));
		ldap_abandon(HDB2LDAP(db), msgid);
a1466 1
	    ret = HDB_ERR_NOENTRY;
d1478 1
a1478 1
	    ldap_abandon(HDB2LDAP(db), msgid);
d1487 1
a1487 1
	    ret = hdb_unseal_keys(context, db, entry);
d1489 1
a1489 1
		hdb_free_entry(context,entry);
d1498 1
a1498 1
	      hdb_entry *entry)
d1511 1
a1511 1
    msgid = ldap_search(HDB2LDAP(db), HDB2BASE(db),
d1514 2
a1515 1
			krb5kdcentry_attrs, 0);
d1526 1
a1526 1
	     hdb_entry * entry)
a1531 6
LDAP_rename(krb5_context context, HDB * db, const char *new_name)
{
    return HDB_ERR_DB_INUSE;
}

static krb5_error_code
d1559 1
a1559 1
    rc = ldap_initialize(&((struct hdbldapdb *)db->hdb_db)->h_lp, "ldapi:///");
d1561 2
a1562 2
	krb5_set_error_string(context, "ldap_initialize: %s", 
			      ldap_err2string(rc));
d1569 2
a1570 2
	krb5_set_error_string(context, "ldap_set_option: %s",
			      ldap_err2string(rc));
d1578 2
a1579 2
	krb5_set_error_string(context, "ldap_sasl_bind_s: %s",
			      ldap_err2string(rc));
d1607 2
a1608 2
LDAP_fetch(krb5_context context, HDB * db, unsigned flags,
	   hdb_entry * entry)
d1613 1
a1613 1
    ret = LDAP_principal2message(context, db, entry->principal, &msg);
d1623 1
a1623 1
    ret = LDAP_message2entry(context, db, e, entry);
d1626 1
a1626 1
	    ret = hdb_unseal_keys(context, db, entry);
d1628 1
a1628 1
		hdb_free_entry(context,entry);
d1639 8
d1648 1
a1648 1
	   hdb_entry * entry)
d1657 1
a1657 1
    ret = LDAP_principal2message(context, db, entry->principal, &msg);
d1661 1
a1661 1
    ret = krb5_unparse_name(context, entry->principal, &name);
d1667 1
a1667 1
    ret = hdb_seal_keys(context, db, entry);
a1678 1
	    krb5_set_error_string(context, "asprintf: out of memory");
d1680 1
d1695 2
a1696 2
	rc = ldap_add_s(HDB2LDAP(db), dn, mods);
	errfn = "ldap_add_s";
d1699 2
a1700 2
	rc = ldap_modify_s(HDB2LDAP(db), dn, mods);
	errfn = "ldap_modify_s";
d1707 2
a1708 1
	krb5_set_error_string(context, "%s: %s (dn=%s) %s: %s", 
a1709 1
	ret = HDB_ERR_CANT_LOCK_DB;
d1728 1
a1728 1
LDAP_remove(krb5_context context, HDB * db, hdb_entry * entry)
d1735 1
a1735 1
    ret = LDAP_principal2message(context, db, entry->principal, &msg);
d1753 2
a1754 1
	krb5_set_error_string(context, "ldap_set_option: %s",
a1755 1
	ret = HDB_ERR_BADVERSION;
d1759 1
a1759 1
    rc = ldap_delete_s(HDB2LDAP(db), dn);
a1760 2
	krb5_set_error_string(context, "ldap_delete_s: %s", 
			      ldap_err2string(rc));
d1762 2
d1788 2
d1798 5
a1802 2
krb5_error_code
hdb_ldap_create(krb5_context context, HDB ** db, const char *arg)
d1807 2
a1808 2
    if (arg == NULL && arg[0] == '\0') {
	krb5_set_error_string(context, "ldap search base not configured");
d1815 1
a1815 1
	p = krb5_config_get_string(context, NULL, "kdc", 
d1821 1
a1821 1
	    krb5_set_error_string(context, "malloc: out of memory");
d1826 1
a1826 1
    samba_forwardable = 
d1830 1
a1830 1
    *db = malloc(sizeof(**db));
d1832 1
a1832 1
	krb5_set_error_string(context, "malloc: out of memory");
d1837 1
a1837 1
    h = malloc(sizeof(*h));
a1838 1
	krb5_set_error_string(context, "malloc: out of memory");
d1841 1
d1844 1
a1844 1
    memset(h, 0, sizeof(*h));
d1846 7
a1852 1
    asprintf(&(*db)->hdb_name, "ldap:%s", arg);
d1854 3
a1856 3
    (*db)->hdb_db = h;
    h->h_base = strdup(arg);
    if (h->h_base == NULL) {
a1857 1
	krb5_set_error_string(context, "strdup: out of memory");
d1859 1
d1863 1
a1863 1
    create_base = krb5_config_get_string(context, NULL, "kdc", 
a1870 1
	krb5_set_error_string(context, "strdup: out of memory");
d1872 1
d1878 1
d1881 1
a1881 1
    (*db)->hdb_fetch = LDAP_fetch;
d1888 1
a1888 1
    (*db)->hdb_rename = LDAP_rename;
d1897 33
d1936 6
@


1.1
log
@Initial revision
@
text
@d2 3
a4 1
 * Copyright (c) 1999 - 2001, PADL Software Pty Ltd.
d37 1
a37 1
RCSID("$KTH: hdb-ldap.c,v 1.7 2001/01/30 16:59:08 assar Exp $");
d41 1
a42 2
#include <lber.h>
#include <ctype.h>
d44 1
d46 2
a47 1
static krb5_error_code LDAP__connect(krb5_context context, HDB * db);
d53 46
a98 6
static char *krb5kdcentry_attrs[] =
    { "krb5PrincipalName", "cn", "krb5PrincipalRealm",
    "krb5KeyVersionNumber", "krb5Key",
    "krb5ValidStart", "krb5ValidEnd", "krb5PasswordEnd",
    "krb5MaxLife", "krb5MaxRenew", "krb5KDCFlags", "krb5EncryptionType",
    "modifiersName", "modifyTimestamp", "creatorsName", "createTimestamp",
d102 10
a111 3
static char *krb5principal_attrs[] =
    { "krb5PrincipalName", "cn", "krb5PrincipalRealm",
    "modifiersName", "modifyTimestamp", "creatorsName", "createTimestamp",
d115 28
a142 1
/* based on samba: source/passdb/ldap.c */
d144 2
a145 2
LDAP_addmod_len(LDAPMod *** modlist, int modop, const char *attribute,
		unsigned char *value, size_t len)
d147 1
a147 2
    LDAPMod **mods = *modlist;
    int i, j;
d149 3
a151 3
    if (mods == NULL) {
	mods = (LDAPMod **) calloc(1, sizeof(LDAPMod *));
	if (mods == NULL) {
a152 2
	}
	mods[0] = NULL;
d155 3
a157 3
    for (i = 0; mods[i] != NULL; ++i) {
	if ((mods[i]->mod_op & (~LDAP_MOD_BVALUES)) == modop
	    && (!strcasecmp(mods[i]->mod_type, attribute))) {
d162 8
a169 3
    if (mods[i] == NULL) {
	mods = (LDAPMod **) realloc(mods, (i + 2) * sizeof(LDAPMod *));
	if (mods == NULL) {
d171 11
a181 3
	}
	mods[i] = (LDAPMod *) malloc(sizeof(LDAPMod));
	if (mods[i] == NULL) {
d184 5
a188 5
	mods[i]->mod_op = modop | LDAP_MOD_BVALUES;
	mods[i]->mod_bvalues = NULL;
	mods[i]->mod_type = strdup(attribute);
	if (mods[i]->mod_type == NULL) {
	    return ENOMEM;
d190 2
a191 1
	mods[i + 1] = NULL;
d194 14
d209 10
a218 8
	j = 0;
	if (mods[i]->mod_bvalues != NULL) {
	    for (; mods[i]->mod_bvalues[j] != NULL; j++);
	}
	mods[i]->mod_bvalues =
	    (struct berval **) realloc(mods[i]->mod_bvalues,
				       (j + 2) * sizeof(struct berval *));
	if (mods[i]->mod_bvalues == NULL) {
d220 5
a224 5
	}
	/* Caller allocates memory on our behalf, unlike LDAP_addmod. */
	mods[i]->mod_bvalues[j] =
	    (struct berval *) malloc(sizeof(struct berval));
	if (mods[i]->mod_bvalues[j] == NULL) {
d226 5
a230 4
	}
	mods[i]->mod_bvalues[j]->bv_val = value;
	mods[i]->mod_bvalues[j]->bv_len = len;
	mods[i]->mod_bvalues[j + 1] = NULL;
d232 1
a232 1
    *modlist = mods;
d240 9
a248 2
    LDAPMod **mods = *modlist;
    int i, j;
d250 8
a257 3
    if (mods == NULL) {
	mods = (LDAPMod **) calloc(1, sizeof(LDAPMod *));
	if (mods == NULL) {
a258 3
	}
	mods[0] = NULL;
    }
d260 1
a260 6
    for (i = 0; mods[i] != NULL; ++i) {
	if (mods[i]->mod_op == modop
	    && (!strcasecmp(mods[i]->mod_type, attribute))) {
	    break;
	}
    }
d262 2
a263 3
    if (mods[i] == NULL) {
	mods = (LDAPMod **) realloc(mods, (i + 2) * sizeof(LDAPMod *));
	if (mods == NULL) {
d265 2
a266 12
	}
	mods[i] = (LDAPMod *) malloc(sizeof(LDAPMod));
	if (mods[i] == NULL) {
	    return ENOMEM;
	}
	mods[i]->mod_op = modop;
	mods[i]->mod_values = NULL;
	mods[i]->mod_type = strdup(attribute);
	if (mods[i]->mod_type == NULL) {
	    return ENOMEM;
	}
	mods[i + 1] = NULL;
a268 17
    if (value != NULL) {
	j = 0;
	if (mods[i]->mod_values != NULL) {
	    for (; mods[i]->mod_values[j] != NULL; j++);
	}
	mods[i]->mod_values = (char **) realloc(mods[i]->mod_values,
						(j + 2) * sizeof(char *));
	if (mods[i]->mod_values == NULL) {
	    return ENOMEM;
	}
	mods[i]->mod_values[j] = strdup(value);
	if (mods[i]->mod_values[j] == NULL) {
	    return ENOMEM;
	}
	mods[i]->mod_values[j + 1] = NULL;
    }
    *modlist = mods;
d287 18
d311 1
a311 1
    vals = ldap_get_values((LDAP *) db->db, entry, (char *) attribute);
d313 1
d316 1
d318 1
a318 1
    if (*ptr == NULL) {
d320 1
a320 1
    } else {
a321 1
    }
d334 2
a335 2
    vals = ldap_get_values((LDAP *) db->db, entry, (char *) attribute);
    if (vals == NULL) {
d337 1
a337 1
    }
d354 1
a354 1
    if (ret != 0) {
a355 1
    }
a375 1
    int rc, i;
d380 10
d392 1
d394 1
a394 1
	if (ret != 0) {
d396 32
d429 5
a433 2
	is_new_entry = FALSE;
    } else {
a436 2
	is_new_entry = TRUE;
    }
a437 1
    if (is_new_entry) {
d439 1
a439 1
	if (ret != 0) {
d441 8
d450 4
a453 3
	/* person is the structural object class */
	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", "person");
	if (ret != 0) {
d455 4
a458 5
	}
	ret =
	    LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass",
			"krb5Principal");
	if (ret != 0) {
a459 6
	}
	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass",
			  "krb5KDCEntry");
	if (ret != 0) {
	    goto out;
	}
d462 17
a478 6
    if (is_new_entry ||
	krb5_principal_compare(context, ent->principal, orig.principal) ==
	FALSE) {
	ret = krb5_unparse_name(context, ent->principal, &tmp);
	if (ret != 0) {
	    goto out;
d480 10
a489 3
	ret =
	    LDAP_addmod(&mods, LDAP_MOD_REPLACE, "krb5PrincipalName", tmp);
	if (ret != 0) {
a490 1
	    goto out;
a491 1
	free(tmp);
d494 5
a498 4
    if (ent->kvno != orig.kvno) {
	rc = asprintf(&tmp, "%d", ent->kvno);
	if (rc < 0) {
	    ret = ENOMEM;
a499 8
	}
	ret =
	    LDAP_addmod(&mods, LDAP_MOD_REPLACE, "krb5KeyVersionNumber",
			tmp);
	free(tmp);
	if (ret != 0) {
	    goto out;
	}
d502 1
a502 1
    if (ent->valid_start) {
d505 4
a508 5
	    ret =
		LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
					     "krb5ValidStart",
					     ent->valid_start);
	    if (ret != 0) {
a509 1
	    }
d514 14
a527 8
	if (orig.valid_end == NULL
	    || (*(ent->valid_end) != *(orig.valid_end))) {
	    ret =
		LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
					     "krb5ValidEnd",
					     ent->valid_end);
	    if (ret != 0) {
		goto out;
d529 1
a529 1
	}
d534 26
a559 5
	    ret =
		LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
					     "krb5PasswordEnd",
					     ent->pw_end);
	    if (ret != 0) {
a560 1
	    }
d563 1
d565 1
a565 1
    if (ent->max_life) {
d568 5
a572 8
	    rc = asprintf(&tmp, "%d", *(ent->max_life));
	    if (rc < 0) {
		ret = ENOMEM;
		goto out;
	    }
	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "krb5MaxLife", tmp);
	    free(tmp);
	    if (ret != 0) {
a573 1
	    }
d577 1
a577 1
    if (ent->max_renew) {
d580 5
a584 3
	    rc = asprintf(&tmp, "%d", *(ent->max_renew));
	    if (rc < 0) {
		ret = ENOMEM;
a585 7
	    }
	    ret =
		LDAP_addmod(&mods, LDAP_MOD_REPLACE, "krb5MaxRenew", tmp);
	    free(tmp);
	    if (ret != 0) {
		goto out;
	    }
d589 2
a590 4
    memset(&oflags, 0, sizeof(oflags));
    memcpy(&oflags, &orig.flags, sizeof(HDBFlags));
    memset(&nflags, 0, sizeof(nflags));
    memcpy(&nflags, &ent->flags, sizeof(HDBFlags));
d592 6
a597 9
    if (memcmp(&oflags, &nflags, sizeof(HDBFlags))) {
	rc = asprintf(&tmp, "%lu", nflags);
	if (rc < 0) {
	    ret = ENOMEM;
	    goto out;
	}
	ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "krb5KDCFlags", tmp);
	free(tmp);
	if (ret != 0) {
a598 1
	}
d601 9
a609 5
    if (is_new_entry == FALSE && orig.keys.len > 0) {
	/* for the moment, clobber and replace keys. */
	ret = LDAP_addmod(&mods, LDAP_MOD_DELETE, "krb5Key", NULL);
	if (ret != 0) {
	    goto out;
a613 3
	unsigned char *buf;
	size_t len;
	Key new;
d615 39
a653 4
	ret = copy_Key(&ent->keys.val[i], &new);
	if (ret != 0) {
	    goto out;
	}
d655 5
a659 7
	len = length_Key(&new);
	buf = malloc(len);
	if (buf == NULL) {
	    ret = ENOMEM;
	    free_Key(&new);
	    goto out;
	}
d661 4
a664 12
	ret = encode_Key(buf + len - 1, len, &new, &len);
	if (ret != 0) {
	    free(buf);
	    free_Key(&new);
	    goto out;
	}
	free_Key(&new);

	/* addmod_len _owns_ the key, doesn't need to copy it */
	ret = LDAP_addmod_len(&mods, LDAP_MOD_ADD, "krb5Key", buf, len);
	if (ret != 0) {
	    goto out;
d670 9
a678 4
	if (is_new_entry == FALSE) {
	    ret =
		LDAP_addmod(&mods, LDAP_MOD_DELETE, "krb5EncryptionType",
			    NULL);
d681 10
a690 11
	    rc = asprintf(&tmp, "%d", ent->etypes->val[i]);
	    if (rc < 0) {
		ret = ENOMEM;
		goto out;
	    }
	    free(tmp);
	    ret =
		LDAP_addmod(&mods, LDAP_MOD_ADD, "krb5EncryptionType",
			    tmp);
	    if (ret != 0) {
		goto out;
d698 1
a698 1
  out:
d700 1
a700 1
    if (ret == 0) {
d702 1
a702 1
    } else if (mods != NULL) {
d707 1
a707 1
    if (msg != NULL) {
a708 1
    }
d722 6
a727 4
    rc = 1;
    (void) ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, &rc);
    rc = ldap_search_s((LDAP *) db->db, db->name, LDAP_SCOPE_BASE,
		       "(objectclass=krb5Principal)", krb5principal_attrs,
d729 3
a731 2

    if (rc != LDAP_SUCCESS) {
d736 1
a736 1
    e = ldap_first_entry((LDAP *) db->db, res);
d742 1
a742 1
    values = ldap_get_values((LDAP *) db->db, e, "krb5PrincipalName");
d752 1
a752 1
    if (res != NULL) {
d754 1
a754 1
    }
d759 5
a763 2
LDAP__lookup_princ(krb5_context context, HDB * db, const char *princname,
		   LDAPMessage ** msg)
d769 3
a771 1
    (void) LDAP__connect(context, db);
d773 3
a775 4
    rc =
	asprintf(&filter,
		 "(&(objectclass=krb5KDCEntry)(krb5PrincipalName=%s))",
		 princname);
d777 1
d782 3
a784 2
    rc = 1;
    (void) ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, (void *) &rc);
d786 1
a786 1
    rc = ldap_search_s((LDAP *) db->db, db->name, LDAP_SCOPE_ONELEVEL, filter, 
d788 3
a790 1
    if (rc != LDAP_SUCCESS) {
d795 29
d827 1
a827 1
    if (filter != NULL) {
d829 1
a829 1
    }
d837 1
a837 1
    char *princname = NULL;
d839 3
d843 2
a844 2
    ret = krb5_unparse_name(context, princ, &princname);
    if (ret != 0) {
d846 16
d863 1
d865 3
a867 2
    ret = LDAP__lookup_princ(context, db, princname, msg);
    free(princname);
d879 2
a880 1
    char *unparsed_name = NULL, *dn = NULL;
d885 1
d888 1
a888 1
    memset(&ent->flags, 0, sizeof(HDBFlags));
d890 17
a906 5
    ret =
	LDAP_get_string_value(db, msg, "krb5PrincipalName",
			      &unparsed_name);
    if (ret != 0) {
	return ret;
d909 33
a941 2
    ret = krb5_parse_name(context, unparsed_name, &ent->principal);
    if (ret != 0) {
d943 53
a995 1
    }
d997 10
a1006 6
    ret =
	LDAP_get_integer_value(db, msg, "krb5KeyVersionNumber",
			       &ent->kvno);
    if (ret != 0) {
	ent->kvno = 0;
    }
d1008 6
a1013 10
    keys = ldap_get_values_len((LDAP *) db->db, msg, "krb5Key");
    if (keys != NULL) {
	int i;
	size_t l;

	ent->keys.len = ldap_count_values_len(keys);
	ent->keys.val = (Key *) calloc(ent->keys.len, sizeof(Key));
	for (i = 0; i < ent->keys.len; i++) {
	    decode_Key((unsigned char *) keys[i]->bv_val,
		       (size_t) keys[i]->bv_len, &ent->keys.val[i], &l);
d1015 3
a1017 14
	ber_bvecfree(keys);
    } else {
#if 1
	/*
	 * This violates the ASN1 but it allows a principal to
	 * be related to a general directory entry without creating
	 * the keys. Hopefully it's OK.
	 */
	ent->keys.len = 0;
	ent->keys.val = NULL;
#else
	ret = HDB_ERR_NOENTRY;
	goto out;
#endif
d1020 3
a1022 4
    ret =
	LDAP_get_generalized_time_value(db, msg, "createTimestamp",
					&ent->created_by.time);
    if (ret != 0) {
a1023 1
    }
d1038 1
d1042 2
a1043 3
    ret =
	LDAP_get_generalized_time_value(db, msg, "modifyTimestamp",
					&ent->modified_by->time);
d1046 1
a1046 2
	if (LDAP_dn2principal
	    (context, db, dn, &ent->modified_by->principal) != 0) {
a1047 1
	}
d1054 3
a1056 2
    if ((ent->valid_start = (KerberosTime *) malloc(sizeof(KerberosTime)))
	== NULL) {
d1060 3
a1062 4
    ret =
	LDAP_get_generalized_time_value(db, msg, "krb5ValidStart",
					ent->valid_start);
    if (ret != 0) {
d1067 5
a1071 3

    if ((ent->valid_end = (KerberosTime *) malloc(sizeof(KerberosTime))) ==
	NULL) {ret = ENOMEM;
d1074 3
a1076 4
    ret =
	LDAP_get_generalized_time_value(db, msg, "krb5ValidEnd",
					ent->valid_end);
    if (ret != 0) {
d1082 17
a1098 2
    if ((ent->pw_end = (KerberosTime *) malloc(sizeof(KerberosTime))) ==
	NULL) {ret = ENOMEM;
d1101 3
a1103 4
    ret =
	LDAP_get_generalized_time_value(db, msg, "krb5PasswordEnd",
					ent->pw_end);
    if (ret != 0) {
d1109 31
a1139 1
    ent->max_life = (int *) malloc(sizeof(int));
d1141 1
d1146 1
a1146 1
    if (ret != 0) {
d1151 1
a1151 1
    ent->max_renew = (int *) malloc(sizeof(int));
d1153 1
d1158 1
a1158 1
    if (ret != 0) {
d1163 1
a1163 1
    values = ldap_get_values((LDAP *) db->db, msg, "krb5KDCFlags");
d1165 1
d1168 1
a1174 1
    memcpy(&ent->flags, &tmp, sizeof(HDBFlags));
d1176 21
a1196 2
    values = ldap_get_values((LDAP *) db->db, msg, "krb5EncryptionType");
    if (values != NULL) {
d1198 4
d1203 50
a1252 9
	ent->etypes = malloc(sizeof(*(ent->etypes)));
	if (ent->etypes == NULL) {
	    ret = ENOMEM;
	    goto out;
	}
	ent->etypes->len = ldap_count_values(values);
	ent->etypes->val = calloc(ent->etypes->len, sizeof(int));
	for (i = 0; i < ent->etypes->len; i++) {
	    ent->etypes->val[i] = atoi(values[i]);
d1254 2
a1255 1
	ldap_value_free(values);
d1260 2
a1261 2
  out:
    if (unparsed_name != NULL) {
a1262 1
    }
d1264 1
a1264 2
    if (ret != 0) {
	/* I don't think this frees ent itself. */
a1265 1
    }
d1270 2
a1271 1
static krb5_error_code LDAP_close(krb5_context context, HDB * db)
d1273 5
a1277 4
    LDAP *ld = (LDAP *) db->db;

    ldap_unbind(ld);
    db->db = NULL;
d1287 2
a1288 1
static krb5_error_code LDAP_unlock(krb5_context context, HDB * db)
d1300 2
a1301 2
    msgid = db->openp;		/* BOGUS OVERLOADING */
    if (msgid < 0) {
a1302 1
    }
d1305 1
a1305 1
	rc = ldap_result((LDAP *) db->db, msgid, LDAP_MSG_ONE, NULL, &e);
d1307 4
d1319 1
a1319 1
		ldap_parse_result((LDAP *) db->db, e, NULL, NULL, NULL,
d1323 3
a1325 1
		ldap_abandon((LDAP *) db->db, msgid);
d1328 7
a1334 1
	    db->openp = -1;
a1335 2
	case 0:
	case -1:
d1339 1
a1339 1
	    ldap_abandon((LDAP *) db->db, msgid);
d1341 1
a1341 1
	    db->openp = -1;
d1347 1
a1347 1
	if (db->master_key_set && (flags & HDB_F_DECRYPT)) {
d1358 2
a1359 2
LDAP_firstkey(krb5_context context, HDB * db, unsigned flags,
	      hdb_entry * entry)
d1361 1
d1364 3
a1366 1
    (void) LDAP__connect(context, db);
d1368 3
a1370 2
    msgid = LDAP_NO_LIMIT;
    (void) ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, &msgid);
d1372 3
a1374 2
    msgid = ldap_search((LDAP *) db->db, db->name,
			LDAP_SCOPE_ONELEVEL, "(objectclass=krb5KDCEntry)",
d1376 1
a1376 1
    if (msgid < 0) {
a1377 1
    }
d1379 1
a1379 1
    db->openp = msgid;
d1397 2
a1398 22
static krb5_boolean LDAP__is_user_namingcontext(const char *ctx,
						char *const *subschema)
{
    char *const *p;

    if (!strcasecmp(ctx, "CN=MONITOR")
	|| !strcasecmp(ctx, "CN=CONFIG")) {
	return FALSE;
    }

    if (subschema != NULL) {
	for (p = subschema; *p != NULL; p++) {
	    if (!strcasecmp(ctx, *p)) {
		return FALSE;
	    }
	}
    }

    return TRUE;
}

static krb5_error_code LDAP__connect(krb5_context context, HDB * db)
d1400 8
a1407 4
    int rc;
    krb5_error_code ret;
    char *attrs[] = { "namingContexts", "subschemaSubentry", NULL };
    LDAPMessage *res = NULL, *e;
d1409 1
a1409 1
    if (db->db != NULL) {
d1412 1
a1412 1
	socklen_t len;
d1415 1
a1415 1
	if (ldap_get_option((LDAP *) db->db, LDAP_OPT_DESC, &sd) == 0 &&
d1422 1
a1422 2
    if (db->db != NULL) {
	/* server is UP */
a1423 1
    }
d1425 1
a1425 1
    rc = ldap_initialize((LDAP **) & db->db, "ldapi:///");
d1427 2
d1432 2
a1433 6
    rc = LDAP_VERSION3;
    (void) ldap_set_option((LDAP *) db->db, LDAP_OPT_PROTOCOL_VERSION, &rc);

    /* XXX set db->name to the search base */
    rc = ldap_search_s((LDAP *) db->db, "", LDAP_SCOPE_BASE,
		       "(objectclass=*)", attrs, 0, &res);
d1435 4
a1438 2
	ret = HDB_ERR_BADVERSION;
	goto out;
d1441 7
a1447 4
    e = ldap_first_entry((LDAP *) db->db, res);
    if (e == NULL) {
	ret = HDB_ERR_NOENTRY;
	goto out;
d1450 1
a1450 52
    if (db->name == NULL) {
	char **contexts = NULL, **schema_contexts, **p;

	contexts = ldap_get_values((LDAP *) db->db, e, "namingContexts");
	if (contexts == NULL) {
	    ret = HDB_ERR_NOENTRY;
	    goto out;
	}

	schema_contexts =
	    ldap_get_values((LDAP *) db->db, e, "subschemaSubentry");

	if (db->name != NULL) {
	    free(db->name);
	    db->name = NULL;
	}

	for (p = contexts; *p != NULL; p++) {
	    if (LDAP__is_user_namingcontext(*p, schema_contexts)) {
		break;
	    }
	}

	db->name = strdup(*p);
	if (db->name == NULL) {
	    ldap_value_free(contexts);
	    ret = ENOMEM;
	    goto out;
	}

	ldap_value_free(contexts);
	if (schema_contexts != NULL) {
	    ldap_value_free(schema_contexts);
	}
    }

    ret = 0;

  out:

    if (res != NULL) {
	ldap_msgfree(res);
    }

    if (ret != 0) {
	if (db->db != NULL) {
	    ldap_unbind((LDAP *) db->db);
	    db->db = NULL;
	}
    }

    return ret;
a1455 2
    krb5_error_code ret;

d1458 1
a1458 2
    {
	struct sigaction sa;
d1460 3
a1462 3
	sa.sa_flags = 0;
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
d1464 1
a1464 2
	sigaction(SIGPIPE, &sa, NULL);
    }
d1467 1
a1467 11
#endif

    if (db->name != NULL) {
	free(db->name);
	db->name = NULL;
    }

    ret = LDAP__connect(context, db);
    if (ret != 0) {
	return ret;
    }
d1469 1
a1469 1
    return ret;
d1480 1
a1480 1
    if (ret != 0) {
a1481 1
    }
d1483 1
a1483 1
    e = ldap_first_entry((LDAP *) db->db, msg);
d1491 1
a1491 1
	if (db->master_key_set && (flags & HDB_F_DECRYPT)) {
d1510 2
d1515 4
d1520 3
a1522 7
    if (ret != 0) {
	goto out;
    }

    ret = LDAP__lookup_princ(context, db, name, &msg);
    if (ret == 0) {
	e = ldap_first_entry((LDAP *) db->db, msg);
d1531 1
a1531 1
    if (ret != 0) {
a1532 1
    }
d1535 1
a1535 27
	/* Doesn't exist yet. */
	char *p;

	e = NULL;

	/* normalize the naming attribute */
	for (p = name; *p != '\0'; p++) {
	    *p = (char) tolower((int) *p);
	}

	/*
	 * We could do getpwnam() on the local component of
	 * the principal to find cn/sn but that's probably
	 * bad thing to do from inside a KDC. Better leave
	 * it to management tools.
	 */
	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "cn", name);
	if (ret < 0) {
	    goto out;
	}

	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "sn", name);
	if (ret < 0) {
	    goto out;
	}

	ret = asprintf(&dn, "cn=%s,%s", name, db->name);
d1537 1
d1543 1
a1543 1
	dn = ldap_get_dn((LDAP *) db->db, e);
d1553 2
a1554 1
	ret = ldap_add_s((LDAP *) db->db, dn, mods);
d1557 2
a1558 1
	ret = ldap_modify_s((LDAP *) db->db, dn, mods);
d1561 8
a1568 1
    if (ret == LDAP_SUCCESS) {
a1569 3
    } else {
	ret = HDB_ERR_CANT_LOCK_DB;
    }
d1573 1
a1573 1
    if (dn != NULL) {
d1575 1
a1575 3
    }

    if (msg != NULL) {
d1577 1
a1577 3
    }

    if (mods != NULL) {
d1579 1
a1579 3
    }

    if (name != NULL) {
a1580 1
    }
d1591 1
d1594 1
a1594 1
    if (ret != 0) {
a1595 1
    }
d1597 1
a1597 1
    e = ldap_first_entry((LDAP *) db->db, msg);
d1603 1
a1603 1
    dn = ldap_get_dn((LDAP *) db->db, e);
d1609 7
a1615 2
    ret = LDAP_NO_LIMIT;
    (void) ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, &ret);
d1617 6
a1622 2
    ret = ldap_delete_s((LDAP *) db->db, dn);
    if (ret == LDAP_SUCCESS) {
a1623 3
    } else {
	ret = HDB_ERR_CANT_LOCK_DB;
    }
d1626 1
a1626 1
    if (dn != NULL) {
d1628 1
a1628 3
    }

    if (msg != NULL) {
a1629 1
    }
d1635 1
a1635 1
LDAP__get(krb5_context context, HDB * db, krb5_data key, krb5_data * reply)
d1637 1
a1637 21
    fprintf(stderr, "LDAP__get not implemented\n");
    abort();
    return 0;
}

static krb5_error_code
LDAP__put(krb5_context context, HDB * db, int replace,
	  krb5_data key, krb5_data value)
{
    fprintf(stderr, "LDAP__put not implemented\n");
    abort();
    return 0;
}

static krb5_error_code
LDAP__del(krb5_context context, HDB * db, krb5_data key)
{
    fprintf(stderr, "LDAP__del not implemented\n");
    abort();
    return 0;
}
d1639 1
a1639 3
static krb5_error_code LDAP_destroy(krb5_context context, HDB * db)
{
    krb5_error_code ret;
d1642 7
a1648 1
    free(db->name);
d1655 1
a1655 1
hdb_ldap_create(krb5_context context, HDB ** db, const char *filename)
d1657 26
d1684 2
a1685 1
    if (*db == NULL)
d1687 22
d1710 29
a1738 20
    (*db)->db = NULL;
/*    (*db)->name = strdup(filename); */
    (*db)->name = NULL;
    (*db)->master_key_set = 0;
    (*db)->openp = 0;
    (*db)->open = LDAP_open;
    (*db)->close = LDAP_close;
    (*db)->fetch = LDAP_fetch;
    (*db)->store = LDAP_store;
    (*db)->remove = LDAP_remove;
    (*db)->firstkey = LDAP_firstkey;
    (*db)->nextkey = LDAP_nextkey;
    (*db)->lock = LDAP_lock;
    (*db)->unlock = LDAP_unlock;
    (*db)->rename = LDAP_rename;
    /* can we ditch these? */
    (*db)->_get = LDAP__get;
    (*db)->_put = LDAP__put;
    (*db)->_del = LDAP__del;
    (*db)->destroy = LDAP_destroy;
d1742 10
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 1
RCSID("$KTH: hdb-ldap.c,v 1.8 2001/03/26 00:59:37 assar Exp $");
d39 1
a40 1
#include <ldap.h>
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d35 1
a35 1
RCSID("$KTH: hdb-ldap.c,v 1.9 2001/08/31 18:19:49 joda Exp $");
a337 1
	    krb5_set_error_string(context, "asprintf: out of memory");
a392 1
		krb5_set_error_string(context, "asprintf: out of memory");
a408 1
		krb5_set_error_string(context, "asprintf: out of memory");
a428 1
	    krb5_set_error_string(context, "asprintf: out of memory");
a459 1
	    krb5_set_error_string(context, "malloc: out of memory");
a489 1
		krb5_set_error_string(context, "asprintf: out of memory");
d527 1
a527 1
    int rc, limit = 1;
d531 3
a533 8
    rc = ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_string(context, "ldap_set_option: %s", ldap_err2string(rc));
	ret = HDB_ERR_BADVERSION;
	goto out;
     }

    rc = ldap_search_s((LDAP *) db->db, dn, LDAP_SCOPE_BASE,
d536 1
a537 1
	krb5_set_error_string(context, "ldap_search_s: %s", ldap_err2string(rc));
d569 1
a569 1
    int rc, limit = 1;
a578 1
	krb5_set_error_string(context, "asprintf: out of memory");
d583 2
a584 6
    rc = ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_string(context, "ldap_set_option: %s", ldap_err2string(rc));
	ret = HDB_ERR_BADVERSION;
	goto out;
    }
a588 1
	krb5_set_error_string(context, "ldap_search_s: %s", ldap_err2string(rc));
a661 5
	if (ent->keys.val == NULL) {
	    krb5_set_error_string(context, "calloc: out of memory");
	    ret = ENOMEM;
	    goto out;
	}
a701 1
	krb5_set_error_string(context, "malloc: out of memory");
a721 1
	krb5_set_error_string(context, "malloc: out of memory");
d735 1
a735 3
	NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
d748 1
a748 3
	NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
a761 1
	krb5_set_error_string(context, "malloc: out of memory");
a772 1
	krb5_set_error_string(context, "malloc: out of memory");
a785 1
	    krb5_set_error_string(context, "strtoul: could not convert flag");
a799 1
	    krb5_set_error_string(context, "malloc: out of memory");
d828 3
a830 1
    ldap_unbind_ext((LDAP *) db->db, NULL, NULL);
a831 1

a872 1
	        krb5_set_error_string(context, "ldap_parse_result: %s", ldap_err2string(parserc));
d905 1
a905 1
    int msgid, limit = LDAP_NO_LIMIT, rc;
d909 2
a910 5
    rc = ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_string(context, "ldap_set_option: %s", ldap_err2string(rc));
	return HDB_ERR_BADVERSION;
    }
d937 21
d960 4
a963 1
    int rc, version = LDAP_VERSION3;
a984 1
	krb5_set_error_string(context, "ldap_initialize: %s", ldap_err2string(rc));
d988 6
a993 1
    rc = ldap_set_option((LDAP *) db->db, LDAP_OPT_PROTOCOL_VERSION, (const void *)&version);
d995 8
a1002 4
	krb5_set_error_string(context, "ldap_set_option: %s", ldap_err2string(rc));
	ldap_unbind_ext((LDAP *) db->db, NULL, NULL);
	db->db = NULL;
	return HDB_ERR_BADVERSION;
d1005 52
a1056 1
    return 0;
d1062 2
d1066 2
a1067 1
    struct sigaction sa;
d1069 3
a1071 3
    sa.sa_flags = 0;
    sa.sa_handler = SIG_IGN;
    sigemptyset(&sa.sa_mask);
d1073 2
a1074 1
    sigaction(SIGPIPE, &sa, NULL);
d1077 6
a1082 1
#endif /* HAVE_SIGACTION */
d1084 6
a1089 1
    return LDAP__connect(context, db);
a1130 2
    const char *errfn;
    int rc;
d1145 1
a1145 1
    if (ret != 0) {
a1146 1
    }
d1181 1
a1181 6
	if (db->name != NULL) {
	    ret = asprintf(&dn, "cn=%s,%s", name, db->name);
	} else {
	    /* A bit bogus, but we don't have a search base */
	    ret = asprintf(&dn, "cn=%s", name, db->name);
	}
a1182 1
	    krb5_set_error_string(context, "asprintf: out of memory");
d1198 1
a1198 2
	rc = ldap_add_s((LDAP *) db->db, dn, mods);
	errfn = "ldap_add_s";
d1201 1
a1201 2
	rc = ldap_modify_s((LDAP *) db->db, dn, mods);
	errfn = "ldap_modify_s";
d1204 1
a1204 1
    if (rc == LDAP_SUCCESS) {
a1206 1
	krb5_set_error_string(context, "%s: %s", errfn, ldap_err2string(rc));
a1236 1
    int rc, limit = LDAP_NO_LIMIT;
d1255 2
a1256 6
    rc = ldap_set_option((LDAP *) db->db, LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_string(context, "ldap_set_option: %s", ldap_err2string(rc));
	ret = HDB_ERR_BADVERSION;
	goto out;
    }
d1258 2
a1259 2
    rc = ldap_delete_s((LDAP *) db->db, dn);
    if (rc == LDAP_SUCCESS) {
a1261 1
	krb5_set_error_string(context, "ldap_delete_s: %s", ldap_err2string(rc));
d1307 1
a1307 3
    if (db->name != NULL) {
	free(db->name);
    }
d1314 1
a1314 1
hdb_ldap_create(krb5_context context, HDB ** db, const char *arg)
d1317 1
a1317 2
    if (*db == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
a1318 1
    }
d1321 2
a1322 20

    if (arg == NULL || arg[0] == '\0') {
	/*
	 * if no argument specified in the configuration file
	 * then use NULL, which tells OpenLDAP to look in
	 * the ldap.conf file. This doesn't work for
	 * writing entries because we don't know where to
	 * put new principals.
	 */
	(*db)->name = NULL;
    } else {
	(*db)->name = strdup(arg); 
	if ((*db)->name == NULL) {
	    krb5_set_error_string(context, "strdup: out of memory");
	    free(*db);
	    *db = NULL;
	    return ENOMEM;
	}
    }

@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001, PADL Software Pty Ltd.
d35 1
a35 1
RCSID("$KTH: hdb-ldap.c,v 1.10 2002/09/04 18:42:22 joda Exp $");
d454 1
d456 11
a466 2
	ASN1_MALLOC_ENCODE(Key, buf, len, &ent->keys.val[i], &len, ret);
	if (ret != 0)
d468 9
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d35 1
a35 1
RCSID("$KTH: hdb-ldap.c,v 1.10.4.1 2003/09/18 20:49:09 lha Exp $");
d65 1
d67 2
a68 2
LDAP__setmod(LDAPMod *** modlist, int modop, const char *attribute,
	int *pIndex)
d70 2
a71 1
    int cMods;
d73 3
a75 3
    if (*modlist == NULL) {
	*modlist = (LDAPMod **)ber_memcalloc(1, sizeof(LDAPMod *));
	if (*modlist == NULL) {
d78 1
d81 3
a83 3
    for (cMods = 0; (*modlist)[cMods] != NULL; cMods++) {
	if ((*modlist)[cMods]->mod_op == modop &&
	    strcasecmp((*modlist)[cMods]->mod_type, attribute) == 0) {
d88 3
a90 8
    *pIndex = cMods;

    if ((*modlist)[cMods] == NULL) {
	LDAPMod *mod;

	*modlist = (LDAPMod **)ber_memrealloc(*modlist,
					      (cMods + 2) * sizeof(LDAPMod *));
	if (*modlist == NULL) {
d93 2
a94 2
	(*modlist)[cMods] = (LDAPMod *)ber_memalloc(sizeof(LDAPMod));
	if ((*modlist)[cMods] == NULL) {
d97 4
a100 7

	mod = (*modlist)[cMods];
	mod->mod_op = modop;
	mod->mod_type = ber_strdup(attribute);
	if (mod->mod_type == NULL) {
	    ber_memfree(mod);
	    (*modlist)[cMods] = NULL;
d103 1
a103 23

	if (modop & LDAP_MOD_BVALUES) {
	    mod->mod_bvalues = NULL;
	} else {
	    mod->mod_values = NULL;
	}

	(*modlist)[cMods + 1] = NULL;
    }

    return 0;
}

static krb5_error_code
LDAP_addmod_len(LDAPMod *** modlist, int modop, const char *attribute,
		unsigned char *value, size_t len)
{
    int cMods, cValues = 0;
    krb5_error_code ret;

    ret = LDAP__setmod(modlist, modop | LDAP_MOD_BVALUES, attribute, &cMods);
    if (ret != 0) {
	return ret;
d107 8
a114 12
	struct berval *bValue;
	struct berval ***pbValues = &((*modlist)[cMods]->mod_bvalues);

	if (*pbValues != NULL) {
	    for (cValues = 0; (*pbValues)[cValues] != NULL; cValues++)
		;
	    *pbValues = (struct berval **)ber_memrealloc(*pbValues, (cValues + 2)
							 * sizeof(struct berval *));
	} else {
	    *pbValues = (struct berval **)ber_memalloc(2 * sizeof(struct berval *));
	}
	if (*pbValues == NULL) {
d117 4
a120 2
	(*pbValues)[cValues] = (struct berval *)ber_memalloc(sizeof(struct berval));;
	if ((*pbValues)[cValues] == NULL) {
d123 3
a125 6

	bValue = (*pbValues)[cValues];
	bValue->bv_val = value;
	bValue->bv_len = len;

	(*pbValues)[cValues + 1] = NULL;
d127 1
a127 1

d135 2
a136 2
    int cMods, cValues = 0;
    krb5_error_code ret;
d138 6
a143 3
    ret = LDAP__setmod(modlist, modop, attribute, &cMods);
    if (ret != 0) {
	return ret;
d146 6
a151 2
    if (value != NULL) {
	char ***pValues = &((*modlist)[cMods]->mod_values);
d153 4
a156 6
	if (*pValues != NULL) {
	    for (cValues = 0; (*pValues)[cValues] != NULL; cValues++)
		;
	    *pValues = (char **)ber_memrealloc(*pValues, (cValues + 2) * sizeof(char *));
	} else {
	    *pValues = (char **)ber_memalloc(2 * sizeof(char *));
d158 2
a159 1
	if (*pValues == NULL) {
d162 4
a165 2
	(*pValues)[cValues] = ber_strdup(value);
	if ((*pValues)[cValues] == NULL) {
d168 1
a168 1
	(*pValues)[cValues + 1] = NULL;
d171 17
d424 4
a427 2
    oflags = HDBFlags2int(orig.flags);
    nflags = HDBFlags2int(ent->flags);
d429 1
a429 1
    if (oflags != nflags) {
d632 1
a632 1
    ent->flags = int2HDBFlags(0);
d804 1
a804 1
    ent->flags = int2HDBFlags(tmp);
a955 7
    /*
     * Empty credentials to do a SASL bind with LDAP. Note that empty
     * different from NULL credentials. If you provide NULL
     * credentials instead of empty credentials you will get a SASL
     * bind in progress message.
     */
    struct berval bv = { 0, "" };
a988 8
    rc = ldap_sasl_bind_s((LDAP *) db->db, NULL, "EXTERNAL", &bv, NULL, NULL, NULL);
    if (rc != LDAP_SUCCESS) {
	krb5_set_error_string(context, "ldap_sasl_bind_s: %s", ldap_err2string(rc));
	ldap_unbind_ext((LDAP *) db->db, NULL, NULL);
	db->db = NULL;
	return HDB_ERR_BADVERSION;
    }

d1107 1
a1107 1
	    ret = asprintf(&dn, "cn=%s", name);
d1137 1
a1137 2
	krb5_set_error_string(context, "%s: %s (dn=%s) %s", 
			      errfn, name, dn, ldap_err2string(rc));
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 3
 * Copyright (c) 1999-2001, 2003, PADL Software Pty Ltd.
 * Copyright (c) 2004, Andrew Bartlett.
 * Copyright (c) 2003 - 2004, Kungliga Tekniska Högskolan.
d35 1
a35 1
RCSID("$KTH: hdb-ldap.c,v 1.49 2005/04/18 08:03:54 lha Exp $");
d41 1
a42 1
#include <hex.h>
d44 1
a44 2
static krb5_error_code LDAP__connect(krb5_context context, HDB *);
static krb5_error_code LDAP_close(krb5_context context, HDB *);
d50 6
a55 46
static const char *default_structural_object = "account";
static char *structural_object;
static krb5_boolean samba_forwardable;

struct hdbldapdb {
    LDAP *h_lp;
    int   h_msgid;
    char *h_base;
    char *h_createbase;
};

#define HDB2LDAP(db) (((struct hdbldapdb *)(db)->hdb_db)->h_lp)
#define HDB2MSGID(db) (((struct hdbldapdb *)(db)->hdb_db)->h_msgid)
#define HDBSETMSGID(db,msgid) \
	do { ((struct hdbldapdb *)(db)->hdb_db)->h_msgid = msgid; } while(0)
#define HDB2BASE(dn) (((struct hdbldapdb *)(db)->hdb_db)->h_base)
#define HDB2CREATE(db) (((struct hdbldapdb *)(db)->hdb_db)->h_createbase)

/*
 *
 */

static char * krb5kdcentry_attrs[] = { 
    "cn",
    "createTimestamp",
    "creatorsName",
    "krb5EncryptionType",
    "krb5KDCFlags",
    "krb5Key",
    "krb5KeyVersionNumber",
    "krb5MaxLife",
    "krb5MaxRenew",
    "krb5PasswordEnd",
    "krb5PrincipalName",
    "krb5PrincipalRealm",
    "krb5ValidEnd",
    "krb5ValidStart",
    "modifiersName",
    "modifyTimestamp",
    "objectClass",
    "sambaAcctFlags",
    "sambaKickoffTime",
    "sambaNTPassword",
    "sambaPwdLastSet",
    "sambaPwdMustChange",
    "uid",
d59 3
a61 10
static char *krb5principal_attrs[] = {
    "cn",
    "createTimestamp",
    "creatorsName",
    "krb5PrincipalName",
    "krb5PrincipalRealm",
    "modifiersName",
    "modifyTimestamp",
    "objectClass",
    "uid",
a64 28
static int
LDAP_no_size_limit(krb5_context context, LDAP *lp)
{
    int ret, limit = LDAP_NO_LIMIT;

    ret = ldap_set_option(lp, LDAP_OPT_SIZELIMIT, (const void *)&limit);
    if (ret != LDAP_SUCCESS) {
	krb5_set_error_string(context, "ldap_set_option: %s",
			      ldap_err2string(ret));
	return HDB_ERR_BADVERSION;
    }
    return 0;
}

static int
check_ldap(krb5_context context, HDB *db, int ret)
{
    switch (ret) {
    case LDAP_SUCCESS:
	return 0;
    case LDAP_SERVER_DOWN:
	LDAP_close(context, db);
	return 1;
    default:
	return 1;
    }
}

d67 1
a67 1
	     int *pIndex)
d73 1
a73 1
	if (*modlist == NULL)
d75 1
d92 1
a92 1
	if (*modlist == NULL)
d94 1
a94 1

d96 1
a96 1
	if ((*modlist)[cMods] == NULL)
d98 1
d125 1
a126 1
    int cMods, i = 0;
d129 1
a129 1
    if (ret)
d131 1
d134 2
a135 1
	struct berval **bv;
d137 2
a138 3
	bv = (*modlist)[cMods]->mod_bvalues;
	if (bv != NULL) {
	    for (i = 0; bv[i] != NULL; i++)
d140 6
a145 4
	    bv = ber_memrealloc(bv, (i + 2) * sizeof(*bv));
	} else
	    bv = ber_memalloc(2 * sizeof(*bv));
	if (bv == NULL)
d147 3
a149 5

	(*modlist)[cMods]->mod_bvalues = bv;

	bv[i] = ber_memalloc(sizeof(*bv));;
	if (bv[i] == NULL)
d151 1
d153 3
a155 2
	bv[i]->bv_val = value;
	bv[i]->bv_len = len;
d157 1
a157 1
	bv[i + 1] = NULL;
d167 1
a167 1
    int cMods, i = 0;
d171 1
a171 1
    if (ret)
d173 1
d176 1
a176 1
	char **bv;
d178 2
a179 3
	bv = (*modlist)[cMods]->mod_values;
	if (bv != NULL) {
	    for (i = 0; bv[i] != NULL; i++)
d181 5
a185 4
	    bv = ber_memrealloc(bv, (i + 2) * sizeof(*bv));
	} else
	    bv = ber_memalloc(2 * sizeof(*bv));
	if (bv == NULL)
d187 3
a189 5

	(*modlist)[cMods]->mod_values = bv;

	bv[i] = ber_strdup(value);
	if (bv[i] == NULL)
d191 2
a192 2

	bv[i + 1] = NULL;
a212 18
LDAP_addmod_integer(krb5_context context,
		    LDAPMod *** mods, int modop,
		    const char *attribute, unsigned long l)
{
    krb5_error_code ret;
    char *buf;

    ret = asprintf(&buf, "%ld", l);
    if (ret < 0) {
	krb5_set_error_string(context, "asprintf: out of memory:");
	return ret;
    }
    ret = LDAP_addmod(mods, modop, attribute, buf);
    free (buf);
    return ret;
}

static krb5_error_code
d219 1
a219 1
    vals = ldap_get_values(HDB2LDAP(db), entry, (char *) attribute);
a220 1
	*ptr = NULL;
a222 1

d224 1
a224 1
    if (*ptr == NULL)
d226 1
a226 1
    else
d228 1
d241 2
a242 2
    vals = ldap_get_values(HDB2LDAP(db), entry, (char *) attribute);
    if (vals == NULL)
d244 1
a244 1

d261 1
a261 1
    if (ret)
d263 1
d284 1
a288 10
    int i;

    krb5_boolean is_samba_account = FALSE;
    krb5_boolean is_account = FALSE;
    krb5_boolean is_heimdal_entry = FALSE;
    krb5_boolean is_heimdal_principal = FALSE;

    char **values;

    *pmods = NULL;
a290 1

d292 1
a292 1
	if (ret)
d294 1
a294 1

d296 1
a296 36
	    
	values = ldap_get_values(HDB2LDAP(db), msg, "objectClass");
	if (values) {
	    int num_objectclasses = ldap_count_values(values);
	    for (i=0; i < num_objectclasses; i++) {
		if (strcasecmp(values[i], "sambaSamAccount") == 0) {
		    is_samba_account = TRUE;
		} else if (strcasecmp(values[i], structural_object) == 0) {
		    is_account = TRUE;
		} else if (strcasecmp(values[i], "krb5Principal") == 0) {
		    is_heimdal_principal = TRUE;
		} else if (strcasecmp(values[i], "krb5KDCEntry") == 0) {
		    is_heimdal_entry = TRUE;
		}
	    }
	    ldap_value_free(values);
	}

	/*
	 * If this is just a "account" entry and no other objectclass
	 * is hanging on this entry, its really a new entry.
	 */
	if (is_samba_account == FALSE && is_heimdal_principal == FALSE && 
	    is_heimdal_entry == FALSE) {
	    if (is_account == TRUE) {
		is_new_entry = TRUE;
	    } else {
		ret = HDB_ERR_NOENTRY;
		goto out;
	    }
	}
    } else
	is_new_entry = TRUE;

    if (is_new_entry) {

d300 2
d303 1
d305 6
a310 1
	if (ret)
a311 8
	
	/* account is the structural object class */
	if (is_account == FALSE) {
	    ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", 
			      structural_object);
	    is_account = TRUE;
	    if (ret)
		goto out;
d313 4
a316 4

	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", "krb5Principal");
	is_heimdal_principal = TRUE;
	if (ret)
d318 4
a321 4

	ret = LDAP_addmod(&mods, LDAP_MOD_ADD, "objectClass", "krb5KDCEntry");
	is_heimdal_entry = TRUE;
	if (ret)
d323 1
d326 6
a331 17
    if (is_new_entry || 
	krb5_principal_compare(context, ent->principal, orig.principal)
	== FALSE)
    {
	if (is_heimdal_principal || is_heimdal_entry) {

	    ret = krb5_unparse_name(context, ent->principal, &tmp);
	    if (ret)
		goto out;

	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE,
			      "krb5PrincipalName", tmp);
	    if (ret) {
		free(tmp);
		goto out;
	    }
	    free(tmp);
d333 3
a335 10

	if (is_account || is_samba_account) {
	    ret = krb5_unparse_name_short(context, ent->principal, &tmp);
	    if (ret)
		goto out;
	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "uid", tmp);
	    if (ret) {
		free(tmp);
		goto out;
	    }
d337 1
d339 1
d342 5
a346 5
    if (is_heimdal_entry && (ent->kvno != orig.kvno || is_new_entry)) {
	ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
			    "krb5KeyVersionNumber", 
			    ent->kvno);
	if (ret)
d348 8
d358 1
a358 1
    if (is_heimdal_entry && ent->valid_start) {
d361 5
a365 4
	    ret = LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
					       "krb5ValidStart",
					       ent->valid_start);
	    if (ret)
d367 1
d372 8
a379 14
 	if (orig.valid_end == NULL || (*(ent->valid_end) != *(orig.valid_end))) {
	    if (is_heimdal_entry) { 
		ret = LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
						   "krb5ValidEnd",
						   ent->valid_end);
		if (ret)
		    goto out;
            }
	    if (is_samba_account) {
		ret = LDAP_addmod_integer(context, &mods,  LDAP_MOD_REPLACE,
					  "sambaKickoffTime", 
					  *(ent->valid_end));
		if (ret)
		    goto out;
d381 1
a381 1
   	}
d386 6
a391 14
	    if (is_heimdal_entry) {
		ret = LDAP_addmod_generalized_time(&mods, LDAP_MOD_REPLACE,
						   "krb5PasswordEnd",
						   ent->pw_end);
		if (ret)
		    goto out;
	    }

	    if (is_samba_account) {
		ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
					  "sambaPwdMustChange", 
					  *(ent->pw_end));
		if (ret)
		    goto out;
d396 1
a396 14

#if 0 /* we we have last_pw_change */
    if (is_samba_account && ent->last_pw_change) {
	if (orig.last_pw_change == NULL || (*(ent->last_pw_change) != *(orig.last_pw_change))) {
	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "sambaPwdLastSet", 
				      *(ent->last_pw_change));
	    if (ret)
		goto out;
	}
    }
#endif

    if (is_heimdal_entry && ent->max_life) {
d399 9
a407 5

	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "krb5MaxLife", 
				      *(ent->max_life));
	    if (ret)
d409 1
d413 1
a413 1
    if (is_heimdal_entry && ent->max_renew) {
d416 10
a425 5

	    ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				      "krb5MaxRenew",
				      *(ent->max_renew));
	    if (ret)
d427 1
d434 10
a443 6
    if (is_heimdal_entry && oflags != nflags) {

	ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_REPLACE,
				  "krb5KDCFlags",
				  nflags);
	if (ret)
d445 1
d448 5
a452 9
    /* Remove keys if they exists, and then replace keys. */
    if (!is_new_entry && orig.keys.len > 0) {
	values = ldap_get_values(HDB2LDAP(db), msg, "krb5Key");
	if (values) {
	    ldap_value_free(values);

	    ret = LDAP_addmod(&mods, LDAP_MOD_DELETE, "krb5Key", NULL);
	    if (ret)
		goto out;
d457 2
d460 3
a462 39
	if (is_samba_account
	    && ent->keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5) {
	    char *ntHexPassword;
	    char *nt;
		    
	    /* the key might have been 'sealed', but samba passwords
	       are clear in the directory */
	    ret = hdb_unseal_key(context, db, &ent->keys.val[i]);
	    if (ret)
		goto out;
		    
	    nt = ent->keys.val[i].key.keyvalue.data;
	    /* store in ntPassword, not krb5key */
	    ret = hex_encode(nt, 16, &ntHexPassword);
	    if (ret < 0) {
		krb5_set_error_string(context, "hdb-ldap: failed to "
				      "hex encode key");
		ret = ENOMEM;
		goto out;
	    }
	    ret = LDAP_addmod(&mods, LDAP_MOD_REPLACE, "sambaNTPassword", 
			      ntHexPassword);
	    free(ntHexPassword);
	    if (ret)
		goto out;
		    
	    /* have to kill the LM passwod if it exists */
	    values = ldap_get_values(HDB2LDAP(db), msg, "sambaLMPassword");
	    if (values) {
		ldap_value_free(values);
		ret = LDAP_addmod(&mods, LDAP_MOD_DELETE,
				  "sambaLMPassword", NULL);
		if (ret)
		    goto out;
	    }
		    
	} else if (is_heimdal_entry) {
	    unsigned char *buf;
	    size_t len, buf_size;
d464 4
a467 10
	    ASN1_MALLOC_ENCODE(Key, buf, buf_size, &ent->keys.val[i], &len, ret);
	    if (ret)
		goto out;
	    if(buf_size != len)
		krb5_abortx(context, "internal error in ASN.1 encoder");

	    /* addmod_len _owns_ the key, doesn't need to copy it */
	    ret = LDAP_addmod_len(&mods, LDAP_MOD_ADD, "krb5Key", buf, len);
	    if (ret)
		goto out;
d473 4
a476 9
	if (!is_new_entry) {
	    values = ldap_get_values(HDB2LDAP(db), msg, "krb5EncryptionType");
	    if (values) {
		ldap_value_free(values);
		ret = LDAP_addmod(&mods, LDAP_MOD_DELETE, "krb5EncryptionType",
				  NULL);
		if (ret)
		    goto out;
	    }
d479 12
a490 10
	    if (is_samba_account && 
		ent->keys.val[i].key.keytype == ETYPE_ARCFOUR_HMAC_MD5)
	    {
		;
	    } else if (is_heimdal_entry) {
		ret = LDAP_addmod_integer(context, &mods, LDAP_MOD_ADD,
					  "krb5EncryptionType",
					  ent->etypes->val[i]);
		if (ret)
		    goto out;
d498 1
a498 1
 out:
d500 1
a500 1
    if (ret == 0)
d502 1
a502 1
    else if (mods != NULL) {
d507 1
a507 1
    if (msg)
d509 1
d519 1
a519 1
    int rc;
d523 4
a526 2
    ret = LDAP_no_size_limit(context, HDB2LDAP(db));
    if (ret)
d528 1
d530 2
a531 2
    rc = ldap_search_s(HDB2LDAP(db), dn, LDAP_SCOPE_SUBTREE,
		       "(objectClass=krb5Principal)", krb5principal_attrs,
d533 2
a534 3
    if (check_ldap(context, db, rc)) {
	krb5_set_error_string(context, "ldap_search_s: %s",
			      ldap_err2string(rc));
d539 1
a539 1
    e = ldap_first_entry(HDB2LDAP(db), res);
d545 1
a545 1
    values = ldap_get_values(HDB2LDAP(db), e, "krb5PrincipalName");
d555 1
a555 1
    if (res)
d557 1
a557 1

d562 2
a563 5
LDAP__lookup_princ(krb5_context context,
		   HDB *db,
		   const char *princname,
		   const char *userid,
		   LDAPMessage **msg)
d566 1
a566 1
    int rc;
d569 1
a569 3
    ret = LDAP__connect(context, db);
    if (ret)
	return ret;
d571 4
a574 3
    rc = asprintf(&filter,
		  "(&(objectClass=krb5Principal)(krb5PrincipalName=%s))",
		  princname);
d581 4
a584 2
    ret = LDAP_no_size_limit(context, HDB2LDAP(db));
    if (ret)
d586 1
d588 1
a588 1
    rc = ldap_search_s(HDB2LDAP(db), HDB2BASE(db), LDAP_SCOPE_SUBTREE, filter, 
d590 2
a591 3
    if (check_ldap(context, db, rc)) {
	krb5_set_error_string(context, "ldap_search_s: %s",
			      ldap_err2string(rc));
a595 29
    if (userid && ldap_count_entries(HDB2LDAP(db), *msg) == 0) {
	free(filter);
	filter = NULL;
	ldap_msgfree(*msg);
	*msg = NULL;
	
	rc = asprintf(&filter,
	    "(&(|(objectClass=sambaSamAccount)(objectClass=%s))(uid=%s))",
		      structural_object, userid);
	if (rc < 0) {
	    krb5_set_error_string(context, "asprintf: out of memory");
	    ret = ENOMEM;
	    goto out;
	}
	    
	ret = LDAP_no_size_limit(context, HDB2LDAP(db));
	if (ret)
	    goto out;

	rc = ldap_search_s(HDB2LDAP(db), HDB2BASE(db), LDAP_SCOPE_SUBTREE, 
			   filter, krb5kdcentry_attrs, 0, msg);
	if (check_ldap(context, db, rc)) {
	    krb5_set_error_string(context, "ldap_search_s: %s",
				  ldap_err2string(rc));
	    ret = HDB_ERR_NOENTRY;
	    goto out;
	}
    }

d599 1
a599 1
    if (filter)
d601 1
a601 1

d609 1
a609 1
    char *name, *name_short = NULL;
a610 1
    krb5_realm *r, *r0;
d612 2
a613 9
    *msg = NULL;

    ret = krb5_unparse_name(context, princ, &name);
    if (ret)
	return ret;

    ret = krb5_get_default_realms(context, &r0);
    if(ret) {
	free(name);
a615 12
    for (r = r0; *r != NULL; r++) {
	if(strcmp(krb5_principal_get_realm(context, princ), *r) == 0) {
	    ret = krb5_unparse_name_short(context, princ, &name_short);
	    if (ret) {
		krb5_free_host_realm(context, r0);
		free(name);
		return ret;
	    }
	    break;
	}
    }
    krb5_free_host_realm(context, r0);
d617 2
a618 3
    ret = LDAP__lookup_princ(context, db, name, name_short, msg);
    free(name);
    free(name_short);
d630 1
a630 2
    char *unparsed_name = NULL, *dn = NULL, *ntPasswordIN = NULL;
    char *samba_acct_flags = NULL;
a634 1
    int tmp_time;
d639 10
a648 17
    ret = LDAP_get_string_value(db, msg, "krb5PrincipalName", &unparsed_name);
    if (ret == 0) {
	ret = krb5_parse_name(context, unparsed_name, &ent->principal);
	if (ret)
	    goto out;
    } else {
	ret = LDAP_get_string_value(db, msg, "uid",
				    &unparsed_name);
	if (ret == 0) {
	    ret = krb5_parse_name(context, unparsed_name, &ent->principal);
	    if (ret)
		goto out;
	} else {
	    krb5_set_error_string(context, "hdb-ldap: ldap entry missing"
				  "principal name");
	    return HDB_ERR_NOENTRY;
	}
d651 4
a654 3
    ret = LDAP_get_integer_value(db, msg, "krb5KeyVersionNumber",
				 &ent->kvno);
    if (ret)
d656 1
d658 1
a658 1
    keys = ldap_get_values_len(HDB2LDAP(db), msg, "krb5Key");
d690 5
a694 72
    values = ldap_get_values(HDB2LDAP(db), msg, "krb5EncryptionType");
    if (values != NULL) {
	int i;

	ent->etypes = malloc(sizeof(*(ent->etypes)));
	if (ent->etypes == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    ret = ENOMEM;
	    goto out;
	}
	ent->etypes->len = ldap_count_values(values);
	ent->etypes->val = calloc(ent->etypes->len, sizeof(int));
	if (ent->etypes->val == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    ret = ENOMEM;
	    goto out;
	}
	for (i = 0; i < ent->etypes->len; i++) {
	    ent->etypes->val[i] = atoi(values[i]);
	}
	ldap_value_free(values);
    }

    /* manually construct the NT (type 23) key */
    ret = LDAP_get_string_value(db, msg, "sambaNTPassword", &ntPasswordIN);
    if (ret == 0) {
	int *etypes;
	Key *keys;

	keys = realloc(ent->keys.val,
		       (ent->keys.len + 1) * sizeof(ent->keys.val[0]));
	if (keys == NULL) {
	    free(ntPasswordIN);
	    krb5_set_error_string(context, "malloc: out of memory");
	    ret = ENOMEM;
	    goto out;
	}
	ent->keys.val = keys;
	memset(&ent->keys.val[ent->keys.len], 0, sizeof(Key));
	ent->keys.val[ent->keys.len].key.keytype = ETYPE_ARCFOUR_HMAC_MD5;
	ret = krb5_data_alloc (&ent->keys.val[ent->keys.len].key.keyvalue, 16);
	if (ret) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    free(ntPasswordIN);
	    ret = ENOMEM;
	    goto out;
	}
	ret = hex_decode(ntPasswordIN,
			 ent->keys.val[ent->keys.len].key.keyvalue.data, 16);
	ent->keys.len++;

	if (ent->etypes == NULL) {
	    ent->etypes = malloc(sizeof(*(ent->etypes)));
	    if (ent->etypes == NULL) {
		krb5_set_error_string(context, "malloc: out of memory");
		ret = ENOMEM;
		goto out;
	    }
	    ent->etypes->val = NULL;
	    ent->etypes->len = 0;
	}

	etypes = realloc(ent->etypes->val, 
			 (ent->etypes->len + 1) * sizeof(ent->etypes->val[0]));
	if (etypes == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    ret = ENOMEM;
	    goto out;			    
	}
	ent->etypes->val = etypes;
	ent->etypes->val[ent->etypes->len] = ETYPE_ARCFOUR_HMAC_MD5;
	ent->etypes->len++;
a696 5
    ret = LDAP_get_generalized_time_value(db, msg, "createTimestamp",
					  &ent->created_by.time);
    if (ret)
	ent->created_by.time = time(NULL);

d714 3
a716 2
    ret = LDAP_get_generalized_time_value(db, msg, "modifyTimestamp",
					  &ent->modified_by->time);
d719 2
a720 1
	if (LDAP_dn2principal(context, db, dn, &ent->modified_by->principal))
d722 1
d729 2
a730 2
    ent->valid_start = malloc(sizeof(*ent->valid_start));
    if (ent->valid_start == NULL) {
d735 4
a738 3
    ret = LDAP_get_generalized_time_value(db, msg, "krb5ValidStart",
					  ent->valid_start);
    if (ret) {
d743 3
a745 3
    
    ent->valid_end = malloc(sizeof(*ent->valid_end));
    if (ent->valid_end == NULL) {
d750 4
a753 3
    ret = LDAP_get_generalized_time_value(db, msg, "krb5ValidEnd",
					  ent->valid_end);
    if (ret) {
d759 2
a760 15
    ret = LDAP_get_integer_value(db, msg, "sambaKickoffTime", &tmp_time);
    if (ret == 0) {
 	if (ent->valid_end == NULL) {
 	    ent->valid_end = malloc(sizeof(*ent->valid_end));
 	    if (ent->valid_end == NULL) {
 		krb5_set_error_string(context, "malloc: out of memory");
 		ret = ENOMEM;
 		goto out;
 	    }
 	}
 	*ent->valid_end = tmp_time;
    }

    ent->pw_end = malloc(sizeof(*ent->pw_end));
    if (ent->pw_end == NULL) {
d765 4
a768 3
    ret = LDAP_get_generalized_time_value(db, msg, "krb5PasswordEnd",
					  ent->pw_end);
    if (ret) {
d774 1
a774 31
    ret = LDAP_get_integer_value(db, msg, "sambaPwdMustChange", &tmp_time);
    if (ret == 0) {
	if (ent->pw_end == NULL) {
	    ent->pw_end = malloc(sizeof(*ent->pw_end));
	    if (ent->pw_end == NULL) {
		krb5_set_error_string(context, "malloc: out of memory");
		ret = ENOMEM;
		goto out;
	    }
	}
	*ent->pw_end = tmp_time;
    }

#if 0 /* we we have last_pw_change */
    ent->last_pw_change = malloc(sizeof(*ent->last_pw_change));
    if (ent->last_pw_change == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	ret = ENOMEM;
	goto out;
    }
    ret = LDAP_get_integer_value(db, msg, "sambaPwdLastSet",
				 &tmp_time);
    if (ret) {
	/* OPTIONAL */
	free(ent->last_pw_change);
	ent->last_pw_change = NULL;
    } else
	*ent->last_pw_change = tmp_time;
#endif

    ent->max_life = malloc(sizeof(*ent->max_life));
d781 1
a781 1
    if (ret) {
d786 1
a786 1
    ent->max_renew = malloc(sizeof(*ent->max_renew));
d793 1
a793 1
    if (ret) {
d798 1
a798 1
    values = ldap_get_values(HDB2LDAP(db), msg, "krb5KDCFlags");
a808 1

d811 2
a812 19
    /* Try and find Samba flags to put into the mix */
    ret = LDAP_get_string_value(db, msg, "sambaAcctFlags", &samba_acct_flags);
    if (ret == 0) {
	/* parse the [UXW...] string:
	       
	'N'    No password	 
	'D'    Disabled	 
	'H'    Homedir required	 
	'T'    Temp account.	 
	'U'    User account (normal) 	 
	'M'    MNS logon user account - what is this ? 	 
	'W'    Workstation account	 
	'S'    Server account 	 
	'L'    Locked account	 
	'X'    No Xpiry on password 	 
	'I'    Interdomain trust account	 
	    
	*/	 
	    
a813 1
	int flags_len = strlen(samba_acct_flags);
d815 10
a824 53
	if (flags_len < 2)
	    goto out2;

	if (samba_acct_flags[0] != '[' 
	    || samba_acct_flags[flags_len - 1] != ']') 
	    goto out2;

	/* Allow forwarding */
	if (samba_forwardable)
	    ent->flags.forwardable = TRUE;

	for (i=0; i < flags_len; i++) {
	    switch (samba_acct_flags[i]) {
	    case ' ':
	    case '[':
	    case ']':
		break;
	    case 'N':
		/* how to handle no password in kerberos? */
		break;
	    case 'D':
		ent->flags.invalid = TRUE;
		break;
	    case 'H':
		break;
	    case 'T':
		/* temp duplicate */
		ent->flags.invalid = TRUE;
		break;
	    case 'U':
		ent->flags.client = TRUE;
		break;
	    case 'M':
		break;
	    case 'W':
	    case 'S':
		ent->flags.server = TRUE;
		ent->flags.client = TRUE;
		break;
	    case 'L':
		ent->flags.invalid = TRUE;
		break;
	    case 'X':
		if (ent->pw_end) {
		    free(ent->pw_end);
		    ent->pw_end = NULL;
		}
		break;
	    case 'I':
		ent->flags.server = TRUE;
		ent->flags.client = TRUE;
		break;
	    }
d826 1
a826 2
    out2:
	free(samba_acct_flags);
d831 2
a832 2
 out:
    if (unparsed_name)
d834 1
d836 2
a837 1
    if (ret)
d839 1
d844 1
a844 2
static krb5_error_code
LDAP_close(krb5_context context, HDB * db)
d846 3
a848 5
    if (HDB2LDAP(db)) {
	ldap_unbind_ext(HDB2LDAP(db), NULL, NULL);
	((struct hdbldapdb *)db->hdb_db)->h_lp = NULL;
    }
    
d858 1
a858 2
static krb5_error_code
LDAP_unlock(krb5_context context, HDB * db)
d870 2
a871 2
    msgid = HDB2MSGID(db);
    if (msgid < 0)
d873 1
d876 1
a876 1
	rc = ldap_result(HDB2LDAP(db), msgid, LDAP_MSG_ONE, NULL, &e);
a877 4
	case LDAP_RES_SEARCH_REFERENCE:
	    ldap_msgfree(e);
	    ret = 0;
	    break;
d886 1
a886 1
		ldap_parse_result(HDB2LDAP(db), e, NULL, NULL, NULL,
d890 2
a891 3
	        krb5_set_error_string(context, "ldap_parse_result: %s",
				      ldap_err2string(parserc));
		ldap_abandon(HDB2LDAP(db), msgid);
d894 1
a894 7
	    HDBSETMSGID(db, -1);
	    break;
	case LDAP_SERVER_DOWN:
	    ldap_msgfree(e);
	    LDAP_close(context, db);
	    HDBSETMSGID(db, -1);
	    ret = ENETDOWN;
d896 2
d901 1
a901 1
	    ldap_abandon(HDB2LDAP(db), msgid);
d903 1
a903 1
	    HDBSETMSGID(db, -1);
d909 1
a909 1
	if (db->hdb_master_key_set && (flags & HDB_F_DECRYPT)) {
d920 2
a921 2
LDAP_firstkey(krb5_context context, HDB *db, unsigned flags,
	      hdb_entry *entry)
d923 1
a923 2
    krb5_error_code ret;
    int msgid;
d925 1
a925 3
    ret = LDAP__connect(context, db);
    if (ret)
	return ret;
d927 5
a931 3
    ret = LDAP_no_size_limit(context, HDB2LDAP(db));
    if (ret)
	return ret;
d933 2
a934 3
    msgid = ldap_search(HDB2LDAP(db), HDB2BASE(db),
			LDAP_SCOPE_SUBTREE,
			"(|(objectClass=krb5Principal)(objectClass=sambaSamAccount))",
d936 1
a936 1
    if (msgid < 0)
d938 1
d940 1
a940 1
    HDBSETMSGID(db, msgid);
d958 1
a958 2
static krb5_error_code
LDAP__connect(krb5_context context, HDB * db)
d969 1
a969 1
    if (HDB2LDAP(db)) {
d972 1
a972 1
	socklen_t len = sizeof(addr);
d975 1
a975 1
	if (ldap_get_option(HDB2LDAP(db), LDAP_OPT_DESC, &sd) == 0 &&
d982 2
a983 1
    if (HDB2LDAP(db) != NULL) /* server is UP */
d985 1
d987 1
a987 1
    rc = ldap_initialize(&((struct hdbldapdb *)db->hdb_db)->h_lp, "ldapi:///");
d989 1
a989 2
	krb5_set_error_string(context, "ldap_initialize: %s", 
			      ldap_err2string(rc));
d993 1
a993 2
    rc = ldap_set_option(HDB2LDAP(db), LDAP_OPT_PROTOCOL_VERSION,
			 (const void *)&version);
d995 3
a997 3
	krb5_set_error_string(context, "ldap_set_option: %s",
			      ldap_err2string(rc));
	LDAP_close(context, db);
d1001 1
a1001 2
    rc = ldap_sasl_bind_s(HDB2LDAP(db), NULL, "EXTERNAL", &bv,
			  NULL, NULL, NULL);
d1003 3
a1005 3
	krb5_set_error_string(context, "ldap_sasl_bind_s: %s",
			      ldap_err2string(rc));
	LDAP_close(context, db);
d1039 1
a1039 1
    if (ret)
d1041 1
d1043 1
a1043 1
    e = ldap_first_entry(HDB2LDAP(db), msg);
d1051 1
a1051 1
	if (db->hdb_master_key_set && (flags & HDB_F_DECRYPT)) {
d1075 4
a1078 3
    ret = LDAP_principal2message(context, db, entry->principal, &msg);
    if (ret == 0)
	e = ldap_first_entry(HDB2LDAP(db), msg);
d1080 3
a1082 4
    ret = krb5_unparse_name(context, entry->principal, &name);
    if (ret) {
	free(name);
	return ret;
d1086 1
a1086 1
    if (ret)
d1088 1
d1092 1
a1092 1
    if (ret)
d1094 1
d1097 32
a1128 1
	ret = asprintf(&dn, "krb5PrincipalName=%s,%s", name, HDB2CREATE(db));
d1136 1
a1136 1
	dn = ldap_get_dn(HDB2LDAP(db), e);
d1146 1
a1146 1
	rc = ldap_add_s(HDB2LDAP(db), dn, mods);
d1150 1
a1150 1
	rc = ldap_modify_s(HDB2LDAP(db), dn, mods);
d1154 5
a1158 6
    if (check_ldap(context, db, rc)) {
	char *ld_error = NULL;
	ldap_get_option(HDB2LDAP(db), LDAP_OPT_ERROR_STRING,
			&ld_error);
	krb5_set_error_string(context, "%s: %s (dn=%s) %s: %s", 
			      errfn, name, dn, ldap_err2string(rc), ld_error);
d1160 1
a1160 2
    } else
	ret = 0;
d1164 1
a1164 1
    if (dn)
d1166 3
a1168 1
    if (msg)
d1170 3
a1172 1
    if (mods)
d1174 3
a1176 1
    if (name)
d1178 1
d1192 1
a1192 1
    if (ret)
d1194 1
d1196 1
a1196 1
    e = ldap_first_entry(HDB2LDAP(db), msg);
d1202 1
a1202 1
    dn = ldap_get_dn(HDB2LDAP(db), e);
d1208 1
a1208 1
    rc = ldap_set_option(HDB2LDAP(db), LDAP_OPT_SIZELIMIT, (const void *)&limit);
d1210 1
a1210 2
	krb5_set_error_string(context, "ldap_set_option: %s",
			      ldap_err2string(rc));
d1215 5
a1219 4
    rc = ldap_delete_s(HDB2LDAP(db), dn);
    if (check_ldap(context, db, rc)) {
	krb5_set_error_string(context, "ldap_delete_s: %s", 
			      ldap_err2string(rc));
d1221 1
a1221 2
    } else
	ret = 0;
d1224 1
a1224 1
    if (dn != NULL)
d1226 3
a1228 1
    if (msg != NULL)
d1230 1
d1236 25
a1260 1
LDAP_destroy(krb5_context context, HDB * db)
a1263 2
    LDAP_close(context, db);

d1265 3
a1267 7
    if (HDB2BASE(db))
	free(HDB2BASE(db));
    if (HDB2CREATE(db))
	free(HDB2CREATE(db));
    if (db->hdb_name)
	free(db->hdb_name);
    free(db->hdb_db);
a1275 26
    struct hdbldapdb *h;
    const char *create_base = NULL;

    if (arg == NULL && arg[0] == '\0') {
	krb5_set_error_string(context, "ldap search base not configured");
	return ENOMEM; /* XXX */
    }

    if (structural_object == NULL) {
	const char *p;

	p = krb5_config_get_string(context, NULL, "kdc", 
				   "hdb-ldap-structural-object", NULL);
	if (p == NULL)
	    p = default_structural_object;
	structural_object = strdup(p);
	if (structural_object == NULL) {
	    krb5_set_error_string(context, "malloc: out of memory");
	    return ENOMEM;
	}
    }

    samba_forwardable = 
	krb5_config_get_bool_default(context, NULL, TRUE,
				     "kdc", "hdb-samba-forwardable", NULL);

a1280 1
    memset(*db, 0, sizeof(**db));
d1282 1
a1282 8
    h = malloc(sizeof(*h));
    if (h == NULL) {
	krb5_set_error_string(context, "malloc: out of memory");
	free(*db);
	*db = NULL;
	return ENOMEM;
    }
    memset(h, 0, sizeof(*h));
d1284 17
a1300 22
    asprintf(&(*db)->hdb_name, "ldap:%s", arg);

    (*db)->hdb_db = h;
    h->h_base = strdup(arg);
    if (h->h_base == NULL) {
	LDAP_destroy(context, *db);
	krb5_set_error_string(context, "strdup: out of memory");
	*db = NULL;
	return ENOMEM;
    }

    create_base = krb5_config_get_string(context, NULL, "kdc", 
					 "hdb-ldap-create-base", NULL);
    if (create_base == NULL)
	create_base = h->h_base;

    h->h_createbase = strdup(create_base);
    if (h->h_createbase == NULL) {
	LDAP_destroy(context, *db);
	krb5_set_error_string(context, "strdup: out of memory");
	*db = NULL;
	return ENOMEM;
d1303 17
a1319 16
    (*db)->hdb_master_key_set = 0;
    (*db)->hdb_openp = 0;
    (*db)->hdb_open = LDAP_open;
    (*db)->hdb_close = LDAP_close;
    (*db)->hdb_fetch = LDAP_fetch;
    (*db)->hdb_store = LDAP_store;
    (*db)->hdb_remove = LDAP_remove;
    (*db)->hdb_firstkey = LDAP_firstkey;
    (*db)->hdb_nextkey = LDAP_nextkey;
    (*db)->hdb_lock = LDAP_lock;
    (*db)->hdb_unlock = LDAP_unlock;
    (*db)->hdb_rename = LDAP_rename;
    (*db)->hdb__get = NULL;
    (*db)->hdb__put = NULL;
    (*db)->hdb__del = NULL;
    (*db)->hdb_destroy = LDAP_destroy;
a1322 10

#ifdef OPENLDAP_MODULE

struct hdb_so_method hdb_ldap_interface = {
    HDB_INTERFACE_VERSION,
    "ldap",
    hdb_ldap_create
};

#endif
@


