head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.6
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.4
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.04.22.10.01.27;	author reyk;	state dead;
branches;
next	1.5;

1.5
date	2013.06.17.18.57.42;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.12.23.20.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.55;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.55;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.01;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.36;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.32.52;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.6
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Portions Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "gen_locl.h"

RCSID("$Id: gen.c,v 1.5 2013/06/17 18:57:42 robert Exp $");

FILE *privheaderfile, *headerfile, *codefile, *logfile, *templatefile;

#define STEM "asn1"

static const char *orig_filename;
static char *privheader, *header, *template;
static const char *headerbase = STEM;

/*
 * list of all IMPORTs
 */

struct import {
    const char *module;
    struct import *next;
};

static struct import *imports = NULL;

void
add_import (const char *module)
{
    struct import *tmp = emalloc (sizeof(*tmp));

    tmp->module = module;
    tmp->next   = imports;
    imports     = tmp;

    fprintf (headerfile, "#include <%s_asn1.h>\n", module);
}

/*
 * List of all exported symbols
 */

struct sexport {
    const char *name;
    int defined;
    struct sexport *next;
};

static struct sexport *exports = NULL;

void
add_export (const char *name)
{
    struct sexport *tmp = emalloc (sizeof(*tmp));

    tmp->name   = name;
    tmp->next   = exports;
    exports     = tmp;
}

int
is_export(const char *name)
{
    struct sexport *tmp;

    if (exports == NULL) /* no export list, all exported */
	return 1;

    for (tmp = exports; tmp != NULL; tmp = tmp->next) {
	if (strcmp(tmp->name, name) == 0) {
	    tmp->defined = 1;
	    return 1;
	}
    }
    return 0;
}

const char *
get_filename (void)
{
    return orig_filename;
}

void
init_generate (const char *filename, const char *base)
{
    char *fn = NULL;

    orig_filename = filename;
    if (base != NULL) {
	headerbase = strdup(base);
	if (headerbase == NULL)
	    errx(1, "strdup");
    }

    /* public header file */
    if (asprintf(&header, "%s.h", headerbase) < 0 || header == NULL)
	errx(1, "malloc");
    if (asprintf(&fn, "%s.hx", headerbase) < 0 || fn == NULL)
	errx(1, "malloc");
    headerfile = fopen (fn, "w");
    if (headerfile == NULL)
	err (1, "open %s", fn);
    free(fn);
    fn = NULL;

    /* private header file */
    if (asprintf(&privheader, "%s-priv.h", headerbase) < 0 || privheader == NULL)
	errx(1, "malloc");
    if (asprintf(&fn, "%s-priv.hx", headerbase) < 0 || fn == NULL)
	errx(1, "malloc");
    privheaderfile = fopen (fn, "w");
    if (privheaderfile == NULL)
	err (1, "open %s", fn);
    free(fn);
    fn = NULL;

    /* template file */
    if (asprintf(&template, "%s-template.c", headerbase) < 0 || template == NULL)
	errx(1, "malloc");
    fprintf (headerfile,
	     "/* Generated from %s */\n"
	     "/* Do not edit */\n\n",
	     filename);
    fprintf (headerfile,
	     "#ifndef __%s_h__\n"
	     "#define __%s_h__\n\n", headerbase, headerbase);
    fprintf (headerfile,
	     "#include <stddef.h>\n"
	     "#include <time.h>\n\n");
    fprintf (headerfile,
	     "#ifndef __asn1_common_definitions__\n"
	     "#define __asn1_common_definitions__\n\n");
    fprintf (headerfile,
	     "typedef struct heim_integer {\n"
	     "  size_t length;\n"
	     "  void *data;\n"
	     "  int negative;\n"
	     "} heim_integer;\n\n");
    fprintf (headerfile,
	     "typedef struct heim_octet_string {\n"
	     "  size_t length;\n"
	     "  void *data;\n"
	     "} heim_octet_string;\n\n");
    fprintf (headerfile,
	     "typedef char *heim_general_string;\n\n"
	     );
    fprintf (headerfile,
	     "typedef char *heim_utf8_string;\n\n"
	     );
    fprintf (headerfile,
	     "typedef struct heim_octet_string heim_printable_string;\n\n"
	     );
    fprintf (headerfile,
	     "typedef struct heim_octet_string heim_ia5_string;\n\n"
	     );
    fprintf (headerfile,
	     "typedef struct heim_bmp_string {\n"
	     "  size_t length;\n"
	     "  uint16_t *data;\n"
	     "} heim_bmp_string;\n\n");
    fprintf (headerfile,
	     "typedef struct heim_universal_string {\n"
	     "  size_t length;\n"
	     "  uint32_t *data;\n"
	     "} heim_universal_string;\n\n");
    fprintf (headerfile,
	     "typedef char *heim_visible_string;\n\n"
	     );
    fprintf (headerfile,
	     "typedef struct heim_oid {\n"
	     "  size_t length;\n"
	     "  unsigned *components;\n"
	     "} heim_oid;\n\n");
    fprintf (headerfile,
	     "typedef struct heim_bit_string {\n"
	     "  size_t length;\n"
	     "  void *data;\n"
	     "} heim_bit_string;\n\n");
    fprintf (headerfile,
	     "typedef struct heim_octet_string heim_any;\n"
	     "typedef struct heim_octet_string heim_any_set;\n\n");
    fputs("#define ASN1_MALLOC_ENCODE(T, B, BL, S, L, R)                  \\\n"
	  "  do {                                                         \\\n"
	  "    (BL) = length_##T((S));                                    \\\n"
	  "    (B) = malloc((BL));                                        \\\n"
	  "    if((B) == NULL) {                                          \\\n"
	  "      (R) = ENOMEM;                                            \\\n"
	  "    } else {                                                   \\\n"
	  "      (R) = encode_##T(((unsigned char*)(B)) + (BL) - 1, (BL), \\\n"
	  "                       (S), (L));                              \\\n"
	  "      if((R) != 0) {                                           \\\n"
	  "        free((B));                                             \\\n"
	  "        (B) = NULL;                                            \\\n"
	  "      }                                                        \\\n"
	  "    }                                                          \\\n"
	  "  } while (0)\n\n",
	  headerfile);
    fputs("#ifdef _WIN32\n"
	  "#ifndef ASN1_LIB\n"
	  "#define ASN1EXP  __declspec(dllimport)\n"
	  "#else\n"
	  "#define ASN1EXP\n"
	  "#endif\n"
	  "#define ASN1CALL __stdcall\n"
	  "#else\n"
	  "#define ASN1EXP\n"
	  "#define ASN1CALL\n"
	  "#endif\n",
	  headerfile);
    fprintf (headerfile, "struct units;\n\n");
    fprintf (headerfile, "#endif\n\n");
    if (asprintf(&fn, "%s_files", base) < 0 || fn == NULL)
	errx(1, "malloc");
    logfile = fopen(fn, "w");
    if (logfile == NULL)
	err (1, "open %s", fn);

    /* if one code file, write into the one codefile */
    if (one_code_file)
	return;

    templatefile = fopen (template, "w");
    if (templatefile == NULL)
	err (1, "open %s", template);

    fprintf (templatefile,
	     "/* Generated from %s */\n"
	     "/* Do not edit */\n\n"
	     "#include <stdio.h>\n"
	     "#include <stdlib.h>\n"
	     "#include <time.h>\n"
	     "#include <string.h>\n"
	     "#include <errno.h>\n"
	     "#include <limits.h>\n"
	     "#include <krb5-types.h>\n",
	     filename);

    fprintf (templatefile,
	     "#include <%s>\n"
	     "#include <%s>\n"
	     "#include <der.h>\n"
	     "#include <der-private.h>\n"
	     "#include <asn1-template.h>\n",
	     header, privheader);


}

void
close_generate (void)
{
    fprintf (headerfile, "#endif /* __%s_h__ */\n", headerbase);

    if (headerfile)
        fclose (headerfile);
    if (privheaderfile)
        fclose (privheaderfile);
    if (templatefile)
        fclose (templatefile);
    if (logfile)
        fprintf (logfile, "\n");
        fclose (logfile);
}

void
gen_assign_defval(const char *var, struct value *val)
{
    switch(val->type) {
    case stringvalue:
	fprintf(codefile, "if((%s = strdup(\"%s\")) == NULL)\nreturn ENOMEM;\n", var, val->u.stringvalue);
	break;
    case integervalue:
	fprintf(codefile, "%s = %d;\n", var, val->u.integervalue);
	break;
    case booleanvalue:
	if(val->u.booleanvalue)
	    fprintf(codefile, "%s = TRUE;\n", var);
	else
	    fprintf(codefile, "%s = FALSE;\n", var);
	break;
    default:
	abort();
    }
}

void
gen_compare_defval(const char *var, struct value *val)
{
    switch(val->type) {
    case stringvalue:
	fprintf(codefile, "if(strcmp(%s, \"%s\") != 0)\n", var, val->u.stringvalue);
	break;
    case integervalue:
	fprintf(codefile, "if(%s != %d)\n", var, val->u.integervalue);
	break;
    case booleanvalue:
	if(val->u.booleanvalue)
	    fprintf(codefile, "if(!%s)\n", var);
	else
	    fprintf(codefile, "if(%s)\n", var);
	break;
    default:
	abort();
    }
}

void
generate_header_of_codefile(const char *name)
{
    char *filename = NULL;

    if (codefile != NULL)
	abort();

    if (asprintf (&filename, "%s_%s.x", STEM, name) < 0 || filename == NULL)
	errx(1, "malloc");
    codefile = fopen (filename, "w");
    if (codefile == NULL)
	err (1, "fopen %s", filename);
    fprintf(logfile, "%s ", filename);
    free(filename);
    filename = NULL;
    fprintf (codefile,
	     "/* Generated from %s */\n"
	     "/* Do not edit */\n\n"
	     "#define  ASN1_LIB\n\n"
	     "#include <stdio.h>\n"
	     "#include <stdlib.h>\n"
	     "#include <time.h>\n"
	     "#include <string.h>\n"
	     "#include <errno.h>\n"
	     "#include <limits.h>\n"
	     "#include <krb5-types.h>\n",
	     orig_filename);

    fprintf (codefile,
	     "#include <%s>\n"
	     "#include <%s>\n",
	     header, privheader);
    fprintf (codefile,
	     "#include <asn1_err.h>\n"
	     "#include <der.h>\n"
	     "#include <der-private.h>\n"
	     "#include <asn1-template.h>\n"
	     "#include <parse_units.h>\n\n");

}

void
close_codefile(void)
{
    if (codefile == NULL)
	abort();

    fclose(codefile);
    codefile = NULL;
}


void
generate_constant (const Symbol *s)
{
    switch(s->value->type) {
    case booleanvalue:
	break;
    case integervalue:
	fprintf (headerfile, "enum { %s = %d };\n\n",
		 s->gen_name, s->value->u.integervalue);
	break;
    case nullvalue:
	break;
    case stringvalue:
	break;
    case objectidentifiervalue: {
	struct objid *o, **list;
	unsigned int i, len;
	char *gen_upper;

	if (!one_code_file)
	    generate_header_of_codefile(s->gen_name);

	len = 0;
	for (o = s->value->u.objectidentifiervalue; o != NULL; o = o->next)
	    len++;
	if (len == 0) {
	    printf("s->gen_name: %s",s->gen_name);
	    fflush(stdout);
	    break;
	}
	list = emalloc(sizeof(*list) * len);

	i = 0;
	for (o = s->value->u.objectidentifiervalue; o != NULL; o = o->next)
	    list[i++] = o;

	fprintf (headerfile, "/* OBJECT IDENTIFIER %s ::= { ", s->name);
	for (i = len ; i > 0; i--) {
	    o = list[i - 1];
	    fprintf(headerfile, "%s(%d) ",
		    o->label ? o->label : "label-less", o->value);
	}

	fprintf (codefile, "static unsigned oid_%s_variable_num[%d] =  {",
		 s->gen_name, len);
	for (i = len ; i > 0; i--) {
	    fprintf(codefile, "%d%s ", list[i - 1]->value, i > 1 ? "," : "");
	}
	fprintf(codefile, "};\n");

	fprintf (codefile, "const heim_oid asn1_oid_%s = "
		 "{ %d, oid_%s_variable_num };\n\n",
		 s->gen_name, len, s->gen_name);

	free(list);

	/* header file */

	gen_upper = strdup(s->gen_name);
	len = strlen(gen_upper);
	for (i = 0; i < len; i++)
	    gen_upper[i] = toupper((int)s->gen_name[i]);

	fprintf (headerfile, "} */\n");
	fprintf (headerfile,
		 "extern ASN1EXP const heim_oid asn1_oid_%s;\n"
		 "#define ASN1_OID_%s (&asn1_oid_%s)\n\n",
		 s->gen_name,
		 gen_upper,
		 s->gen_name);

	free(gen_upper);

	if (!one_code_file)
	    close_codefile();

	break;
    }
    default:
	abort();
    }
}

int
is_primitive_type(int type)
{
    switch(type) {
    case TInteger:
    case TBoolean:
    case TOctetString:
    case TBitString:
    case TEnumerated:
    case TGeneralizedTime:
    case TGeneralString:
    case TTeletexString:
    case TOID:
    case TUTCTime:
    case TUTF8String:
    case TPrintableString:
    case TIA5String:
    case TBMPString:
    case TUniversalString:
    case TVisibleString:
    case TNull:
	return 1;
    default:
	return 0;
    }
}

static void
space(int level)
{
    while(level-- > 0)
	fprintf(headerfile, "  ");
}

static const char *
last_member_p(struct member *m)
{
    struct member *n = ASN1_TAILQ_NEXT(m, members);
    if (n == NULL)
	return "";
    if (n->ellipsis && ASN1_TAILQ_NEXT(n, members) == NULL)
	return "";
    return ",";
}

static struct member *
have_ellipsis(Type *t)
{
    struct member *m;
    ASN1_TAILQ_FOREACH(m, t->members, members) {
	if (m->ellipsis)
	    return m;
    }
    return NULL;
}

static void
define_asn1 (int level, Type *t)
{
    switch (t->type) {
    case TType:
	fprintf (headerfile, "%s", t->symbol->name);
	break;
    case TInteger:
	if(t->members == NULL) {
            fprintf (headerfile, "INTEGER");
	    if (t->range)
		fprintf (headerfile, " (%d..%d)",
			 t->range->min, t->range->max);
        } else {
	    Member *m;
            fprintf (headerfile, "INTEGER {\n");
	    ASN1_TAILQ_FOREACH(m, t->members, members) {
                space (level + 1);
		fprintf(headerfile, "%s(%d)%s\n", m->gen_name, m->val,
			last_member_p(m));
            }
	    space(level);
            fprintf (headerfile, "}");
        }
	break;
    case TBoolean:
	fprintf (headerfile, "BOOLEAN");
	break;
    case TOctetString:
	fprintf (headerfile, "OCTET STRING");
	break;
    case TEnumerated :
    case TBitString: {
	Member *m;

	space(level);
	if(t->type == TBitString)
	    fprintf (headerfile, "BIT STRING {\n");
	else
	    fprintf (headerfile, "ENUMERATED {\n");
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    space(level + 1);
	    fprintf (headerfile, "%s(%d)%s\n", m->name, m->val,
		     last_member_p(m));
	}
	space(level);
	fprintf (headerfile, "}");
	break;
    }
    case TChoice:
    case TSet:
    case TSequence: {
	Member *m;
	int max_width = 0;

	if(t->type == TChoice)
	    fprintf(headerfile, "CHOICE {\n");
	else if(t->type == TSet)
	    fprintf(headerfile, "SET {\n");
	else
	    fprintf(headerfile, "SEQUENCE {\n");
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    if(strlen(m->name) > max_width)
		max_width = strlen(m->name);
	}
	max_width += 3;
	if(max_width < 16) max_width = 16;
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    int width = max_width;
	    space(level + 1);
	    if (m->ellipsis) {
		fprintf (headerfile, "...");
	    } else {
		width -= fprintf(headerfile, "%s", m->name);
		fprintf(headerfile, "%*s", width, "");
		define_asn1(level + 1, m->type);
		if(m->optional)
		    fprintf(headerfile, " OPTIONAL");
	    }
	    if(last_member_p(m))
		fprintf (headerfile, ",");
	    fprintf (headerfile, "\n");
	}
	space(level);
	fprintf (headerfile, "}");
	break;
    }
    case TSequenceOf:
	fprintf (headerfile, "SEQUENCE OF ");
	define_asn1 (0, t->subtype);
	break;
    case TSetOf:
	fprintf (headerfile, "SET OF ");
	define_asn1 (0, t->subtype);
	break;
    case TGeneralizedTime:
	fprintf (headerfile, "GeneralizedTime");
	break;
    case TGeneralString:
	fprintf (headerfile, "GeneralString");
	break;
    case TTeletexString:
	fprintf (headerfile, "TeletexString");
	break;
    case TTag: {
	const char *classnames[] = { "UNIVERSAL ", "APPLICATION ",
				     "" /* CONTEXT */, "PRIVATE " };
	if(t->tag.tagclass != ASN1_C_UNIV)
	    fprintf (headerfile, "[%s%d] ",
		     classnames[t->tag.tagclass],
		     t->tag.tagvalue);
	if(t->tag.tagenv == TE_IMPLICIT)
	    fprintf (headerfile, "IMPLICIT ");
	define_asn1 (level, t->subtype);
	break;
    }
    case TUTCTime:
	fprintf (headerfile, "UTCTime");
	break;
    case TUTF8String:
	space(level);
	fprintf (headerfile, "UTF8String");
	break;
    case TPrintableString:
	space(level);
	fprintf (headerfile, "PrintableString");
	break;
    case TIA5String:
	space(level);
	fprintf (headerfile, "IA5String");
	break;
    case TBMPString:
	space(level);
	fprintf (headerfile, "BMPString");
	break;
    case TUniversalString:
	space(level);
	fprintf (headerfile, "UniversalString");
	break;
    case TVisibleString:
	space(level);
	fprintf (headerfile, "VisibleString");
	break;
    case TOID :
	space(level);
	fprintf(headerfile, "OBJECT IDENTIFIER");
	break;
    case TNull:
	space(level);
	fprintf (headerfile, "NULL");
	break;
    default:
	abort ();
    }
}

static void
getnewbasename(char **newbasename, int typedefp, const char *basename, const char *name)
{
    if (typedefp)
	*newbasename = strdup(name);
    else {
	if (name[0] == '*')
	    name++;
	if (asprintf(newbasename, "%s_%s", basename, name) < 0)
	    errx(1, "malloc");
    }
    if (*newbasename == NULL)
	err(1, "malloc");
}

static void
define_type (int level, const char *name, const char *basename, Type *t, int typedefp, int preservep)
{
    char *newbasename = NULL;

    switch (t->type) {
    case TType:
	space(level);
	fprintf (headerfile, "%s %s;\n", t->symbol->gen_name, name);
	break;
    case TInteger:
	space(level);
	if(t->members) {
            Member *m;
            fprintf (headerfile, "enum %s {\n", typedefp ? name : "");
	    ASN1_TAILQ_FOREACH(m, t->members, members) {
                space (level + 1);
                fprintf(headerfile, "%s = %d%s\n", m->gen_name, m->val,
                        last_member_p(m));
            }
            fprintf (headerfile, "} %s;\n", name);
	} else if (t->range == NULL) {
	    fprintf (headerfile, "heim_integer %s;\n", name);
	} else if (t->range->min == INT_MIN && t->range->max == INT_MAX) {
	    fprintf (headerfile, "int %s;\n", name);
	} else if (t->range->min == 0 && t->range->max == UINT_MAX) {
	    fprintf (headerfile, "unsigned int %s;\n", name);
	} else if (t->range->min == 0 && t->range->max == INT_MAX) {
	    fprintf (headerfile, "unsigned int %s;\n", name);
	} else
	    errx(1, "%s: unsupported range %d -> %d",
		 name, t->range->min, t->range->max);
	break;
    case TBoolean:
	space(level);
	fprintf (headerfile, "int %s;\n", name);
	break;
    case TOctetString:
	space(level);
	fprintf (headerfile, "heim_octet_string %s;\n", name);
	break;
    case TBitString: {
	Member *m;
	Type i;
	struct range range = { 0, INT_MAX };

	i.type = TInteger;
	i.range = &range;
	i.members = NULL;
	i.constraint = NULL;

	space(level);
	if(ASN1_TAILQ_EMPTY(t->members))
	    fprintf (headerfile, "heim_bit_string %s;\n", name);
	else {
	    int pos = 0;
	    getnewbasename(&newbasename, typedefp, basename, name);

	    fprintf (headerfile, "struct %s {\n", newbasename);
	    ASN1_TAILQ_FOREACH(m, t->members, members) {
		char *n = NULL;

		/* pad unused */
		while (pos < m->val) {
		    if (asprintf (&n, "_unused%d:1", pos) < 0 || n == NULL)
			errx(1, "malloc");
		    define_type (level + 1, n, newbasename, &i, FALSE, FALSE);
		    free(n);
		    pos++;
		}

		n = NULL;
		if (asprintf (&n, "%s:1", m->gen_name) < 0 || n == NULL)
		    errx(1, "malloc");
		define_type (level + 1, n, newbasename, &i, FALSE, FALSE);
		free (n);
		n = NULL;
		pos++;
	    }
	    /* pad to 32 elements */
	    while (pos < 32) {
		char *n = NULL;
		if (asprintf (&n, "_unused%d:1", pos) < 0 || n == NULL)
		    errx(1, "malloc");
		define_type (level + 1, n, newbasename, &i, FALSE, FALSE);
		free(n);
		pos++;
	    }

	    space(level);
	    fprintf (headerfile, "} %s;\n\n", name);
	}
	break;
    }
    case TEnumerated: {
	Member *m;

	space(level);
	fprintf (headerfile, "enum %s {\n", typedefp ? name : "");
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    space(level + 1);
	    if (m->ellipsis)
		fprintf (headerfile, "/* ... */\n");
	    else
		fprintf (headerfile, "%s = %d%s\n", m->gen_name, m->val,
			 last_member_p(m));
	}
	space(level);
	fprintf (headerfile, "} %s;\n\n", name);
	break;
    }
    case TSet:
    case TSequence: {
	Member *m;

	getnewbasename(&newbasename, typedefp, basename, name);

	space(level);
	fprintf (headerfile, "struct %s {\n", newbasename);
	if (t->type == TSequence && preservep) {
	    space(level + 1);
	    fprintf(headerfile, "heim_octet_string _save;\n");
	}
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    if (m->ellipsis) {
		;
	    } else if (m->optional) {
		char *n = NULL;

		if (asprintf (&n, "*%s", m->gen_name) < 0 || n == NULL)
		    errx(1, "malloc");
		define_type (level + 1, n, newbasename, m->type, FALSE, FALSE);
		free (n);
	    } else
		define_type (level + 1, m->gen_name, newbasename, m->type, FALSE, FALSE);
	}
	space(level);
	fprintf (headerfile, "} %s;\n", name);
	break;
    }
    case TSetOf:
    case TSequenceOf: {
	Type i;
	struct range range = { 0, INT_MAX };

	getnewbasename(&newbasename, typedefp, basename, name);

	i.type = TInteger;
	i.range = &range;
	i.members = NULL;
	i.constraint = NULL;

	space(level);
	fprintf (headerfile, "struct %s {\n", newbasename);
	define_type (level + 1, "len", newbasename, &i, FALSE, FALSE);
	define_type (level + 1, "*val", newbasename, t->subtype, FALSE, FALSE);
	space(level);
	fprintf (headerfile, "} %s;\n", name);
	break;
    }
    case TGeneralizedTime:
	space(level);
	fprintf (headerfile, "time_t %s;\n", name);
	break;
    case TGeneralString:
	space(level);
	fprintf (headerfile, "heim_general_string %s;\n", name);
	break;
    case TTeletexString:
	space(level);
	fprintf (headerfile, "heim_general_string %s;\n", name);
	break;
    case TTag:
	define_type (level, name, basename, t->subtype, typedefp, preservep);
	break;
    case TChoice: {
	int first = 1;
	Member *m;

	getnewbasename(&newbasename, typedefp, basename, name);

	space(level);
	fprintf (headerfile, "struct %s {\n", newbasename);
	if (preservep) {
	    space(level + 1);
	    fprintf(headerfile, "heim_octet_string _save;\n");
	}
	space(level + 1);
	fprintf (headerfile, "enum {\n");
	m = have_ellipsis(t);
	if (m) {
	    space(level + 2);
	    fprintf (headerfile, "%s = 0,\n", m->label);
	    first = 0;
	}
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    space(level + 2);
	    if (m->ellipsis)
		fprintf (headerfile, "/* ... */\n");
	    else
		fprintf (headerfile, "%s%s%s\n", m->label,
			 first ? " = 1" : "",
			 last_member_p(m));
	    first = 0;
	}
	space(level + 1);
	fprintf (headerfile, "} element;\n");
	space(level + 1);
	fprintf (headerfile, "union {\n");
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    if (m->ellipsis) {
		space(level + 2);
		fprintf(headerfile, "heim_octet_string asn1_ellipsis;\n");
	    } else if (m->optional) {
		char *n = NULL;

		if (asprintf (&n, "*%s", m->gen_name) < 0 || n == NULL)
		    errx(1, "malloc");
		define_type (level + 2, n, newbasename, m->type, FALSE, FALSE);
		free (n);
	    } else
		define_type (level + 2, m->gen_name, newbasename, m->type, FALSE, FALSE);
	}
	space(level + 1);
	fprintf (headerfile, "} u;\n");
	space(level);
	fprintf (headerfile, "} %s;\n", name);
	break;
    }
    case TUTCTime:
	space(level);
	fprintf (headerfile, "time_t %s;\n", name);
	break;
    case TUTF8String:
	space(level);
	fprintf (headerfile, "heim_utf8_string %s;\n", name);
	break;
    case TPrintableString:
	space(level);
	fprintf (headerfile, "heim_printable_string %s;\n", name);
	break;
    case TIA5String:
	space(level);
	fprintf (headerfile, "heim_ia5_string %s;\n", name);
	break;
    case TBMPString:
	space(level);
	fprintf (headerfile, "heim_bmp_string %s;\n", name);
	break;
    case TUniversalString:
	space(level);
	fprintf (headerfile, "heim_universal_string %s;\n", name);
	break;
    case TVisibleString:
	space(level);
	fprintf (headerfile, "heim_visible_string %s;\n", name);
	break;
    case TOID :
	space(level);
	fprintf (headerfile, "heim_oid %s;\n", name);
	break;
    case TNull:
	space(level);
	fprintf (headerfile, "int %s;\n", name);
	break;
    default:
	abort ();
    }
    if (newbasename)
	free(newbasename);
}

static void
generate_type_header (const Symbol *s)
{
    int preservep = preserve_type(s->name) ? TRUE : FALSE;

    fprintf (headerfile, "/*\n");
    fprintf (headerfile, "%s ::= ", s->name);
    define_asn1 (0, s->type);
    fprintf (headerfile, "\n*/\n\n");

    fprintf (headerfile, "typedef ");
    define_type (0, s->gen_name, s->gen_name, s->type, TRUE, preservep);

    fprintf (headerfile, "\n");
}

void
generate_type (const Symbol *s)
{
    FILE *h;
    const char * exp;

    if (!one_code_file)
	generate_header_of_codefile(s->gen_name);

    generate_type_header (s);

    if (template_flag)
	generate_template(s);

    if (template_flag == 0 || is_template_compat(s) == 0) {
	generate_type_encode (s);
	generate_type_decode (s);
	generate_type_free (s);
	generate_type_length (s);
	generate_type_copy (s);
    }
    generate_type_seq (s);
    generate_glue (s->type, s->gen_name);

    /* generate prototypes */

    if (is_export(s->name)) {
	h = headerfile;
	exp = "ASN1EXP ";
    } else {
	h = privheaderfile;
	exp = "";
    }

    fprintf (h,
	     "%sint    ASN1CALL "
	     "decode_%s(const unsigned char *, size_t, %s *, size_t *);\n",
	     exp,
	     s->gen_name, s->gen_name);
    fprintf (h,
	     "%sint    ASN1CALL "
	     "encode_%s(unsigned char *, size_t, const %s *, size_t *);\n",
	     exp,
	     s->gen_name, s->gen_name);
    fprintf (h,
	     "%ssize_t ASN1CALL length_%s(const %s *);\n",
	     exp,
	     s->gen_name, s->gen_name);
    fprintf (h,
	     "%sint    ASN1CALL copy_%s  (const %s *, %s *);\n",
	     exp,
	     s->gen_name, s->gen_name, s->gen_name);
    fprintf (h,
	     "%svoid   ASN1CALL free_%s  (%s *);\n",
	     exp,
	     s->gen_name, s->gen_name);

    fprintf(h, "\n\n");

    if (!one_code_file) {
	fprintf(codefile, "\n\n");
	close_codefile();
	}
}
@


1.5
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d38 1
a38 1
RCSID("$Id$");
@


1.4
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 1
a6 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d8 3
a10 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d12 2
a13 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d15 3
a17 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d19 15
a33 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d38 1
a38 1
RCSID("$KTH: gen.c,v 1.58 2005/03/31 00:08:58 lha Exp $");
d40 1
a40 1
FILE *headerfile, *codefile, *logfile;
d45 2
a46 2
static char *header;
static char *headerbase;
d67 41
d111 1
a111 1
filename (void)
d119 2
d122 12
a133 6
    if(base)
	asprintf(&headerbase, "%s", base);
    else
	headerbase = strdup(STEM);
    asprintf(&header, "%s.h", headerbase);
    headerfile = fopen (header, "w");
d135 18
a152 1
	err (1, "open %s", header);
d157 1
a157 1
    fprintf (headerfile, 
d160 1
a160 1
    fprintf (headerfile, 
a162 3
#ifndef HAVE_TIMEGM
    fprintf (headerfile, "time_t timegm (struct tm*);\n\n");
#endif
d167 6
d184 19
d207 8
d231 13
d245 3
a247 1
    logfile = fopen(STEM "_files", "w");
d249 31
a279 1
	err (1, "open " STEM "_files");
d287 103
a389 3
    fclose (headerfile);
    fprintf (logfile, "\n");
    fclose (logfile);
d392 1
d396 105
a500 2
  fprintf (headerfile, "enum { %s = %d };\n\n",
	   s->gen_name, s->constant);
d510 22
a536 1
	space(level);
d540 16
a555 2
	space(level);
	fprintf (headerfile, "INTEGER");
d557 2
a558 3
    case TUInteger:
	space(level);
	fprintf (headerfile, "UNSIGNED INTEGER");
a560 1
	space(level);
d563 1
a563 4
    case TOID :
	space(level);
	fprintf(headerfile, "OBJECT IDENTIFIER");
	break;
a565 19
	int tag = -1;

	space(level);
	fprintf (headerfile, "BIT STRING {\n");
	for (m = t->members; m && m->val != tag; m = m->next) {
	    if (tag == -1)
		tag = m->val;
	    space(level + 1);
	    fprintf (headerfile, "%s(%d)%s\n", m->name, m->val, 
		     m->next->val == tag?"":",");

	}
	space(level);
	fprintf (headerfile, "}");
	break;
    }
    case TEnumerated : {
	Member *m;
	int tag = -1;
d568 5
a572 4
	fprintf (headerfile, "ENUMERATED {\n");
	for (m = t->members; m && m->val != tag; m = m->next) {
	    if (tag == -1)
		tag = m->val;
d574 2
a575 3
	    fprintf (headerfile, "%s(%d)%s\n", m->name, m->val, 
		     m->next->val == tag?"":",");

d581 2
a584 1
	int tag;
d587 9
a595 7
	space(level);
	fprintf (headerfile, "SEQUENCE {\n");
	for (m = t->members, tag = -1; m && m->val != tag; m = m->next) {
	    if (tag == -1)
		tag = m->val;
	    if(strlen(m->name) + (m->val > 9) > max_width)
		max_width = strlen(m->name) + (m->val > 9);
d597 1
a597 1
	max_width += 3 + 2;
d599 2
a600 4
	for (m = t->members, tag = -1 ; m && m->val != tag; m = m->next) {
	    int width;
	    if (tag == -1)
		tag = m->val;
d602 10
a611 7
	    fprintf(headerfile, "%s[%d]", m->name, m->val);
	    width = max_width - strlen(m->name) - 3 - (m->val > 9) - 2;
	    fprintf(headerfile, "%*s", width, "");
	    define_asn1(level + 1, m->type);
	    if(m->optional)
		fprintf(headerfile, " OPTIONAL");
	    if(m->next->val != tag)
d619 1
a619 2
    case TSequenceOf: {
	space(level);
d623 4
a626 1
    }
a627 1
	space(level);
a630 1
	space(level);
d633 12
a644 2
    case TApplication:
	fprintf (headerfile, "[APPLICATION %d] ", t->application);
d647 3
a649 3
    case TBoolean:
	space(level);
	fprintf (headerfile, "BOOLEAN");
d655 24
d689 1
a689 1
define_type (int level, const char *name, Type *t, int typedefp)
d691 17
d715 1
a715 3
        if(t->members == NULL) {
            fprintf (headerfile, "int %s;\n", name);
        } else {
a716 1
            int tag = -1;
d718 1
a718 3
	    for (m = t->members; m && m->val != tag; m = m->next) {
                if(tag == -1)
                    tag = m->val;
d720 2
a721 2
                fprintf(headerfile, "%s = %d%s\n", m->gen_name, m->val, 
                        m->next->val == tag ? "" : ",");
d724 11
a734 1
        }
d736 1
a736 1
    case TUInteger:
d738 1
a738 1
	fprintf (headerfile, "unsigned int %s;\n", name);
a743 4
    case TOID :
	space(level);
	fprintf (headerfile, "heim_oid %s;\n", name);
	break;
d747 44
a790 1
	int tag = -1;
d792 2
a793 11
	i.type = TUInteger;
	space(level);
	fprintf (headerfile, "struct %s {\n", typedefp ? name : "");
	for (m = t->members; m && m->val != tag; m = m->next) {
	    char *n;

	    asprintf (&n, "%s:1", m->gen_name);
	    define_type (level + 1, n, &i, FALSE);
	    free (n);
	    if (tag == -1)
		tag = m->val;
a794 2
	space(level);
	fprintf (headerfile, "} %s;\n\n", name);
a798 1
	int tag = -1;
d802 1
a802 3
	for (m = t->members; m && m->val != tag; m = m->next) {
	    if (tag == -1)
		tag = m->val;
d804 5
a808 2
	    fprintf (headerfile, "%s = %d%s\n", m->gen_name, m->val,
                        m->next->val == tag ? "" : ",");
d814 1
d817 2
a818 1
	int tag = -1;
d821 14
a834 7
	fprintf (headerfile, "struct %s {\n", typedefp ? name : "");
	for (m = t->members; m && m->val != tag; m = m->next) {
	    if (m->optional) {
		char *n;

		asprintf (&n, "*%s", m->gen_name);
		define_type (level + 1, n, m->type, FALSE);
d837 1
a837 3
		define_type (level + 1, m->gen_name, m->type, FALSE);
	    if (tag == -1)
		tag = m->val;
d843 1
d846 3
d850 4
a853 2
	i.type = TUInteger;
	i.application = 0;
d856 3
a858 3
	fprintf (headerfile, "struct %s {\n", typedefp ? name : "");
	define_type (level + 1, "len", &i, FALSE);
	define_type (level + 1, "*val", t->subtype, FALSE);
d871 65
d940 21
a960 1
    case TBoolean:
d962 1
a962 1
	fprintf (headerfile, "int %s;\n", name);
d966 1
a966 4
	fprintf (headerfile, "NULL %s;\n", name);
	break;
    case TApplication:
	define_type (level, name, t->subtype, FALSE);
d971 2
d978 2
d986 1
a986 1
    define_type (0, s->gen_name, s->type, TRUE);
a990 1

d994 2
a995 2
    struct import *i;
    char *filename;
d997 4
a1000 15
    asprintf (&filename, "%s_%s.x", STEM, s->gen_name);
    codefile = fopen (filename, "w");
    if (codefile == NULL)
	err (1, "fopen %s", filename);
    fprintf(logfile, "%s ", filename);
    free(filename);
    fprintf (codefile, 
	     "/* Generated from %s */\n"
	     "/* Do not edit */\n\n"
	     "#include <stdio.h>\n"
	     "#include <stdlib.h>\n"
	     "#include <time.h>\n"
	     "#include <string.h>\n"
	     "#include <errno.h>\n",
	     orig_filename);
d1002 2
a1003 11
    for (i = imports; i != NULL; i = i->next)
	fprintf (codefile,
		 "#include <%s_asn1.h>\n",
		 i->module);
    fprintf (codefile,
	     "#include <%s.h>\n",
	     headerbase);
    fprintf (codefile,
	     "#include <asn1_err.h>\n"
	     "#include <der.h>\n"
	     "#include <parse_units.h>\n\n");
d1005 1
a1005 6
    if (s->stype == Stype && s->type->type == TChoice) {
	fprintf(codefile,
		"/* CHOICE */\n"
		"int asn1_%s_dummy_holder = 1;\n", s->gen_name);
    } else {
	generate_type_header (s);
a1010 1
	generate_glue (s);
d1012 42
a1053 2
    fprintf(headerfile, "\n\n");
    fclose(codefile);
@


1.3
log
@Merge 0.6rc1
@
text
@d36 1
a36 1
RCSID("$KTH: gen.c,v 1.50 2003/04/17 07:09:18 lha Exp $");
d44 1
a44 1
static char *headerbase = STEM;
d79 2
d102 1
a102 1
	     "typedef struct octet_string {\n"
d105 1
a105 1
	     "} octet_string;\n\n");
d107 1
a107 1
	     "typedef char *general_string;\n\n"
d110 4
a113 1
	     "typedef struct oid {\n"
d116 1
a116 1
	     "} oid;\n\n");
d275 12
d293 1
a293 1
define_type (int level, char *name, Type *t, int typedefp)
d324 1
a324 1
	fprintf (headerfile, "octet_string %s;\n", name);
d328 1
a328 1
	fprintf (headerfile, "oid %s;\n", name);
d410 13
a422 1
	fprintf (headerfile, "general_string %s;\n", name);
d480 14
a493 7
    generate_type_header (s);
    generate_type_encode (s);
    generate_type_decode (s);
    generate_type_free (s);
    generate_type_length (s);
    generate_type_copy (s);
    generate_glue (s);
@


1.2
log
@string cleaning; parts by me, then parts by hin, then more parts by me.
since this is not a very important part of the source tree, and since it
does compile, i am dumping it in now.
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: gen.c,v 1.45 2001/07/15 04:51:36 assar Exp $");
d43 23
a65 2
static char header[1024];
static char headerbase[1024] = STEM;
d78 2
a79 2
	strlcpy(headerbase, base, sizeof(headerbase));
    snprintf(header, sizeof(header), "%s.h", headerbase);
a104 6
#if 0
	     "typedef struct general_string {\n"
	     "  size_t length;\n"
	     "  char *data;\n"
	     "} general_string;\n\n"
#else
a105 1
#endif
d107 21
d178 4
d200 18
d309 4
d334 17
d421 1
a432 2
	     "#include \"libasn1.h\"\n\n"
#if 0
d436 12
a447 1
	     "#include <" STEM ".h>\n\n"
d450 1
a450 2
#endif
	     ,orig_filename);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: gen.c,v 1.44 2000/06/19 15:17:52 joda Exp $");
d57 2
a58 2
	strcpy(headerbase, base);
    sprintf(header, "%s.h", headerbase);
a144 1
	Type i;
a146 1
	i.type = TInteger;
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: gen.c,v 1.45 2001/07/15 04:51:36 assar Exp $");
d145 1
d148 1
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: gen.c,v 1.50 2003/04/17 07:09:18 lha Exp $");
d43 2
a44 23
static char *header;
static char *headerbase = STEM;

/*
 * list of all IMPORTs
 */

struct import {
    const char *module;
    struct import *next;
};

static struct import *imports = NULL;

void
add_import (const char *module)
{
    struct import *tmp = emalloc (sizeof(*tmp));

    tmp->module = module;
    tmp->next   = imports;
    imports     = tmp;
}
d57 2
a58 2
	asprintf(&headerbase, "%s", base);
    asprintf(&header, "%s.h", headerbase);
d84 6
d91 1
a92 21
    fprintf (headerfile,
	     "typedef struct oid {\n"
	     "  size_t length;\n"
	     "  unsigned *components;\n"
	     "} oid;\n\n");
    fputs("#define ASN1_MALLOC_ENCODE(T, B, BL, S, L, R)                  \\\n"
	  "  do {                                                         \\\n"
	  "    (BL) = length_##T((S));                                    \\\n"
	  "    (B) = malloc((BL));                                        \\\n"
	  "    if((B) == NULL) {                                          \\\n"
	  "      (R) = ENOMEM;                                            \\\n"
	  "    } else {                                                   \\\n"
	  "      (R) = encode_##T(((unsigned char*)(B)) + (BL) - 1, (BL), \\\n"
	  "                       (S), (L));                              \\\n"
	  "      if((R) != 0) {                                           \\\n"
	  "        free((B));                                             \\\n"
	  "        (B) = NULL;                                            \\\n"
	  "      }                                                        \\\n"
	  "    }                                                          \\\n"
	  "  } while (0)\n\n",
	  headerfile);
a142 4
    case TOID :
	space(level);
	fprintf(headerfile, "OBJECT IDENTIFIER");
	break;
a160 18
    case TEnumerated : {
	Member *m;
	int tag = -1;

	space(level);
	fprintf (headerfile, "ENUMERATED {\n");
	for (m = t->members; m && m->val != tag; m = m->next) {
	    if (tag == -1)
		tag = m->val;
	    space(level + 1);
	    fprintf (headerfile, "%s(%d)%s\n", m->name, m->val, 
		     m->next->val == tag?"":",");

	}
	space(level);
	fprintf (headerfile, "}");
	break;
    }
a251 4
    case TOID :
	space(level);
	fprintf (headerfile, "oid %s;\n", name);
	break;
a272 17
    case TEnumerated: {
	Member *m;
	int tag = -1;

	space(level);
	fprintf (headerfile, "enum %s {\n", typedefp ? name : "");
	for (m = t->members; m && m->val != tag; m = m->next) {
	    if (tag == -1)
		tag = m->val;
	    space(level + 1);
	    fprintf (headerfile, "%s = %d%s\n", m->gen_name, m->val,
                        m->next->val == tag ? "" : ",");
	}
	space(level);
	fprintf (headerfile, "} %s;\n\n", name);
	break;
    }
a342 1
    struct import *i;
d354 2
d359 1
a359 12
	     "#include <string.h>\n"
	     "#include <errno.h>\n",
	     orig_filename);

    for (i = imports; i != NULL; i = i->next)
	fprintf (codefile,
		 "#include <%s_asn1.h>\n",
		 i->module);
    fprintf (codefile,
	     "#include <%s.h>\n",
	     headerbase);
    fprintf (codefile,
d362 2
a363 1
	     "#include <parse_units.h>\n\n");
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: gen.c,v 1.58 2005/03/31 00:08:58 lha Exp $");
d44 1
a44 1
static char *headerbase;
a78 2
    else
	headerbase = strdup(STEM);
d100 1
a100 1
	     "typedef struct heim_octet_string {\n"
d103 1
a103 1
	     "} heim_octet_string;\n\n");
d105 1
a105 1
	     "typedef char *heim_general_string;\n\n"
d108 1
a108 4
	     "typedef char *heim_utf8_string;\n\n"
	     );
    fprintf (headerfile,
	     "typedef struct heim_oid {\n"
d111 1
a111 1
	     "} heim_oid;\n\n");
a269 12
    case TBoolean:
	space(level);
	fprintf (headerfile, "BOOLEAN");
	break;
    case TUTF8String:
	space(level);
	fprintf (headerfile, "UTF8String");
	break;
    case TNull:
	space(level);
	fprintf (headerfile, "NULL");
	break;
d276 1
a276 1
define_type (int level, const char *name, Type *t, int typedefp)
d307 1
a307 1
	fprintf (headerfile, "heim_octet_string %s;\n", name);
d311 1
a311 1
	fprintf (headerfile, "heim_oid %s;\n", name);
d393 1
a393 13
	fprintf (headerfile, "heim_general_string %s;\n", name);
	break;
    case TUTF8String:
	space(level);
	fprintf (headerfile, "heim_utf8_string %s;\n", name);
	break;
    case TBoolean:
	space(level);
	fprintf (headerfile, "int %s;\n", name);
	break;
    case TNull:
	space(level);
	fprintf (headerfile, "NULL %s;\n", name);
d451 7
a457 14

    if (s->stype == Stype && s->type->type == TChoice) {
	fprintf(codefile,
		"/* CHOICE */\n"
		"int asn1_%s_dummy_holder = 1;\n", s->gen_name);
    } else {
	generate_type_header (s);
	generate_type_encode (s);
	generate_type_decode (s);
	generate_type_free (s);
	generate_type_length (s);
	generate_type_copy (s);
	generate_glue (s);
    }
@


