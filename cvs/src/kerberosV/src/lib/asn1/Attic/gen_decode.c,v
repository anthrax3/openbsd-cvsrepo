head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.4.0.28
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.26
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.24
	OPENBSD_5_0:1.1.1.4.0.22
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.20
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.18
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.14
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	HEIMDAL_0_7_2:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.12
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.10
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.8
	OPENBSD_3_7_BASE:1.1.1.3
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.8
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.04.22.10.01.27;	author reyk;	state dead;
branches;
next	1.2;

1.2
date	2013.06.17.18.57.42;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.56;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.56;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.22.13;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.36;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.32.52;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.3
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2006 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "gen_locl.h"
#include "lex.h"

RCSID("$Id: gen_decode.c,v 1.2 2013/06/17 18:57:42 robert Exp $");

static void
decode_primitive (const char *typename, const char *name, const char *forwstr)
{
#if 0
    fprintf (codefile,
	     "e = decode_%s(p, len, %s, &l);\n"
	     "%s;\n",
	     typename,
	     name,
	     forwstr);
#else
    fprintf (codefile,
	     "e = der_get_%s(p, len, %s, &l);\n"
	     "if(e) %s;\np += l; len -= l; ret += l;\n",
	     typename,
	     name,
	     forwstr);
#endif
}

static void
find_tag (const Type *t,
	  Der_class *cl, Der_type *ty, unsigned *tag)
{
    switch (t->type) {
    case TBitString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_BitString;
	break;
    case TBoolean:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_Boolean;
	break;
    case TChoice:
	errx(1, "Cannot have recursive CHOICE");
    case TEnumerated:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_Enumerated;
	break;
    case TGeneralString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_GeneralString;
	break;
    case TTeletexString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_TeletexString;
	break;
    case TGeneralizedTime:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_GeneralizedTime;
	break;
    case TIA5String:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_IA5String;
	break;
    case TInteger:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_Integer;
	break;
    case TNull:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_Null;
	break;
    case TOID:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_OID;
	break;
    case TOctetString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_OctetString;
	break;
    case TPrintableString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_PrintableString;
	break;
    case TSequence:
    case TSequenceOf:
	*cl  = ASN1_C_UNIV;
	*ty  = CONS;
	*tag = UT_Sequence;
	break;
    case TSet:
    case TSetOf:
	*cl  = ASN1_C_UNIV;
	*ty  = CONS;
	*tag = UT_Set;
	break;
    case TTag:
	*cl  = t->tag.tagclass;
	*ty  = is_primitive_type(t->subtype->type) ? PRIM : CONS;
	*tag = t->tag.tagvalue;
	break;
    case TType:
	if ((t->symbol->stype == Stype && t->symbol->type == NULL)
	    || t->symbol->stype == SUndefined) {
	    lex_error_message("%s is imported or still undefined, "
			      " can't generate tag checking data in CHOICE "
			      "without this information",
			      t->symbol->name);
	    exit(1);
	}
	find_tag(t->symbol->type, cl, ty, tag);
	return;
    case TUTCTime:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_UTCTime;
	break;
    case TUTF8String:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_UTF8String;
	break;
    case TBMPString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_BMPString;
	break;
    case TUniversalString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_UniversalString;
	break;
    case TVisibleString:
	*cl  = ASN1_C_UNIV;
	*ty  = PRIM;
	*tag = UT_VisibleString;
	break;
    default:
	abort();
    }
}

static void
range_check(const char *name,
	    const char *length,
	    const char *forwstr,
	    struct range *r)
{
    if (r->min == r->max + 2 || r->min < r->max)
	fprintf (codefile,
		 "if ((%s)->%s > %d) {\n"
		 "e = ASN1_MAX_CONSTRAINT; %s;\n"
		 "}\n",
		 name, length, r->max, forwstr);
    if (r->min - 1 == r->max || r->min < r->max)
	fprintf (codefile,
		 "if ((%s)->%s < %d) {\n"
		 "e = ASN1_MIN_CONSTRAINT; %s;\n"
		 "}\n",
		 name, length, r->min, forwstr);
    if (r->max == r->min)
	fprintf (codefile,
		 "if ((%s)->%s != %d) {\n"
		 "e = ASN1_EXACT_CONSTRAINT; %s;\n"
		 "}\n",
		 name, length, r->min, forwstr);
}

static int
decode_type (const char *name, const Type *t, int optional,
	     const char *forwstr, const char *tmpstr, const char *dertype,
	     unsigned int depth)
{
    switch (t->type) {
    case TType: {
	if (optional)
	    fprintf(codefile,
		    "%s = calloc(1, sizeof(*%s));\n"
		    "if (%s == NULL) %s;\n",
		    name, name, name, forwstr);
	fprintf (codefile,
		 "e = decode_%s(p, len, %s, &l);\n",
		 t->symbol->gen_name, name);
	if (optional) {
	    fprintf (codefile,
		     "if(e) {\n"
		     "free(%s);\n"
		     "%s = NULL;\n"
		     "} else {\n"
		     "p += l; len -= l; ret += l;\n"
		     "}\n",
		     name, name);
	} else {
	    fprintf (codefile,
		     "if(e) %s;\n",
		     forwstr);
	    fprintf (codefile,
		     "p += l; len -= l; ret += l;\n");
	}
	break;
    }
    case TInteger:
	if(t->members) {
	    fprintf(codefile,
		    "{\n"
		    "int enumint;\n");
	    decode_primitive ("integer", "&enumint", forwstr);
	    fprintf(codefile,
		    "*%s = enumint;\n"
		    "}\n",
		    name);
	} else if (t->range == NULL) {
	    decode_primitive ("heim_integer", name, forwstr);
	} else if (t->range->min == INT_MIN && t->range->max == INT_MAX) {
	    decode_primitive ("integer", name, forwstr);
	} else if (t->range->min == 0 && t->range->max == UINT_MAX) {
	    decode_primitive ("unsigned", name, forwstr);
	} else if (t->range->min == 0 && t->range->max == INT_MAX) {
	    decode_primitive ("unsigned", name, forwstr);
	} else
	    errx(1, "%s: unsupported range %d -> %d",
		 name, t->range->min, t->range->max);
	break;
    case TBoolean:
      decode_primitive ("boolean", name, forwstr);
      break;
    case TEnumerated:
	decode_primitive ("enumerated", name, forwstr);
	break;
    case TOctetString:
	if (dertype) {
	    fprintf(codefile,
		    "if (%s == CONS) {\n",
		    dertype);
	    decode_primitive("octet_string_ber", name, forwstr);
	    fprintf(codefile,
		    "} else {\n");
	}
	decode_primitive ("octet_string", name, forwstr);
	if (dertype)
	    fprintf(codefile, "}\n");
	if (t->range)
	    range_check(name, "length", forwstr, t->range);
	break;
    case TBitString: {
	Member *m;
	int pos = 0;

	if (ASN1_TAILQ_EMPTY(t->members)) {
	    decode_primitive ("bit_string", name, forwstr);
	    break;
	}
	fprintf(codefile,
		"if (len < 1) return ASN1_OVERRUN;\n"
		"p++; len--; ret++;\n");
	fprintf(codefile,
		"do {\n"
		"if (len < 1) break;\n");
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    while (m->val / 8 > pos / 8) {
		fprintf (codefile,
			 "p++; len--; ret++;\n"
			 "if (len < 1) break;\n");
		pos += 8;
	    }
	    fprintf (codefile,
		     "(%s)->%s = (*p >> %d) & 1;\n",
		     name, m->gen_name, 7 - m->val % 8);
	}
	fprintf(codefile,
		"} while(0);\n");
	fprintf (codefile,
		 "p += len; ret += len;\n");
	break;
    }
    case TSequence: {
	Member *m;

	if (t->members == NULL)
	    break;

	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    char *s = NULL;

	    if (m->ellipsis)
		continue;

	    if (asprintf (&s, "%s(%s)->%s", m->optional ? "" : "&",
			  name, m->gen_name) < 0 || s == NULL)
		errx(1, "malloc");
	    decode_type (s, m->type, m->optional, forwstr, m->gen_name, NULL,
		depth + 1);
	    free (s);
	}

	break;
    }
    case TSet: {
	Member *m;
	unsigned int memno;

	if(t->members == NULL)
	    break;

	fprintf(codefile, "{\n");
	fprintf(codefile, "unsigned int members = 0;\n");
	fprintf(codefile, "while(len > 0) {\n");
	fprintf(codefile,
		"Der_class class;\n"
		"Der_type type;\n"
		"int tag;\n"
		"e = der_get_tag (p, len, &class, &type, &tag, NULL);\n"
		"if(e) %s;\n", forwstr);
	fprintf(codefile, "switch (MAKE_TAG(class, type, tag)) {\n");
	memno = 0;
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    char *s;

	    assert(m->type->type == TTag);

	    fprintf(codefile, "case MAKE_TAG(%s, %s, %s):\n",
		    classname(m->type->tag.tagclass),
		    is_primitive_type(m->type->subtype->type) ? "PRIM" : "CONS",
		    valuename(m->type->tag.tagclass, m->type->tag.tagvalue));

	    if (asprintf (&s, "%s(%s)->%s", m->optional ? "" : "&", name, m->gen_name) < 0 || s == NULL)
		errx(1, "malloc");
	    if(m->optional)
		fprintf(codefile,
			"%s = calloc(1, sizeof(*%s));\n"
			"if (%s == NULL) { e = ENOMEM; %s; }\n",
			s, s, s, forwstr);
	    decode_type (s, m->type, 0, forwstr, m->gen_name, NULL, depth + 1);
	    free (s);

	    fprintf(codefile, "members |= (1 << %d);\n", memno);
	    memno++;
	    fprintf(codefile, "break;\n");
	}
	fprintf(codefile,
		"default:\n"
		"return ASN1_MISPLACED_FIELD;\n"
		"break;\n");
	fprintf(codefile, "}\n");
	fprintf(codefile, "}\n");
	memno = 0;
	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    char *s;

	    if (asprintf (&s, "%s->%s", name, m->gen_name) < 0 || s == NULL)
		errx(1, "malloc");
	    fprintf(codefile, "if((members & (1 << %d)) == 0)\n", memno);
	    if(m->optional)
		fprintf(codefile, "%s = NULL;\n", s);
	    else if(m->defval)
		gen_assign_defval(s, m->defval);
	    else
		fprintf(codefile, "return ASN1_MISSING_FIELD;\n");
	    free(s);
	    memno++;
	}
	fprintf(codefile, "}\n");
	break;
    }
    case TSetOf:
    case TSequenceOf: {
	char *n = NULL;
	char *sname = NULL;

	fprintf (codefile,
		 "{\n"
		 "size_t %s_origlen = len;\n"
		 "size_t %s_oldret = ret;\n"
		 "size_t %s_olen = 0;\n"
		 "void *%s_tmp;\n"
		 "ret = 0;\n"
		 "(%s)->len = 0;\n"
		 "(%s)->val = NULL;\n",
		 tmpstr,
		 tmpstr,
		 tmpstr,
		 tmpstr,
		 name,
		 name);

	fprintf (codefile,
		 "while(ret < %s_origlen) {\n"
		 "size_t %s_nlen = %s_olen + sizeof(*((%s)->val));\n"
		 "if (%s_olen > %s_nlen) { e = ASN1_OVERFLOW; %s; }\n"
		 "%s_olen = %s_nlen;\n"
		 "%s_tmp = realloc((%s)->val, %s_olen);\n"
		 "if (%s_tmp == NULL) { e = ENOMEM; %s; }\n"
		 "(%s)->val = %s_tmp;\n",
		 tmpstr,
		 tmpstr, tmpstr, name,
		 tmpstr, tmpstr, forwstr,
		 tmpstr, tmpstr,
		 tmpstr, name, tmpstr,
		 tmpstr, forwstr,
		 name, tmpstr);

	if (asprintf (&n, "&(%s)->val[(%s)->len]", name, name) < 0 || n == NULL)
	    errx(1, "malloc");
	if (asprintf (&sname, "%s_s_of", tmpstr) < 0 || sname == NULL)
	    errx(1, "malloc");
	decode_type (n, t->subtype, 0, forwstr, sname, NULL, depth + 1);
	fprintf (codefile,
		 "(%s)->len++;\n"
		 "len = %s_origlen - ret;\n"
		 "}\n"
		 "ret += %s_oldret;\n"
		 "}\n",
		 name,
		 tmpstr, tmpstr);
	if (t->range)
	    range_check(name, "len", forwstr, t->range);
	free (n);
	free (sname);
	break;
    }
    case TGeneralizedTime:
	decode_primitive ("generalized_time", name, forwstr);
	break;
    case TGeneralString:
	decode_primitive ("general_string", name, forwstr);
	break;
    case TTeletexString:
	decode_primitive ("general_string", name, forwstr);
	break;
    case TTag:{
    	char *tname = NULL, *typestring = NULL;
	char *ide = NULL;

	if (asprintf(&typestring, "%s_type", tmpstr) < 0 || typestring == NULL)
	    errx(1, "malloc");

	fprintf(codefile,
		"{\n"
		"size_t %s_datalen, %s_oldlen;\n"
		"Der_type %s;\n",
		tmpstr, tmpstr, typestring);
	if(support_ber)
	    fprintf(codefile,
		    "int is_indefinite%u;\n", depth);

	fprintf(codefile, "e = der_match_tag_and_length(p, len, %s, &%s, %s, "
		"&%s_datalen, &l);\n",
		classname(t->tag.tagclass),
		typestring,
		valuename(t->tag.tagclass, t->tag.tagvalue),
		tmpstr);

	/* XXX hardcode for now */
	if (support_ber && t->subtype->type == TOctetString) {
	    ide = typestring;
	} else {
	    fprintf(codefile,
		    "if (e == 0 && %s != %s) { e = ASN1_BAD_ID; }\n",
		    typestring,
		    is_primitive_type(t->subtype->type) ? "PRIM" : "CONS");
	}

	if(optional) {
	    fprintf(codefile,
		    "if(e) {\n"
		    "%s = NULL;\n"
		    "} else {\n"
		     "%s = calloc(1, sizeof(*%s));\n"
		     "if (%s == NULL) { e = ENOMEM; %s; }\n",
		     name, name, name, name, forwstr);
	} else {
	    fprintf(codefile, "if(e) %s;\n", forwstr);
	}
	fprintf (codefile,
		 "p += l; len -= l; ret += l;\n"
		 "%s_oldlen = len;\n",
		 tmpstr);
	if(support_ber)
	    fprintf (codefile,
		     "if((is_indefinite%u = _heim_fix_dce(%s_datalen, &len)) < 0)\n"
		     "{ e = ASN1_BAD_FORMAT; %s; }\n"
		     "if (is_indefinite%u) { if (len < 2) { e = ASN1_OVERRUN; %s; } len -= 2; }",
		     depth, tmpstr, forwstr, depth, forwstr);
	else
	    fprintf(codefile,
		    "if (%s_datalen > len) { e = ASN1_OVERRUN; %s; }\n"
		    "len = %s_datalen;\n", tmpstr, forwstr, tmpstr);
	if (asprintf (&tname, "%s_Tag", tmpstr) < 0 || tname == NULL)
	    errx(1, "malloc");
	decode_type (name, t->subtype, 0, forwstr, tname, ide, depth + 1);
	if(support_ber)
	    fprintf(codefile,
		    "if(is_indefinite%u){\n"
		    "len += 2;\n"
		    "e = der_match_tag_and_length(p, len, "
		    "(Der_class)0, &%s, UT_EndOfContent, "
		    "&%s_datalen, &l);\n"
		    "if(e) %s;\n"
		    "p += l; len -= l; ret += l;\n"
		    "if (%s != (Der_type)0) { e = ASN1_BAD_ID; %s; }\n"
		    "} else \n",
		    depth,
		    typestring,
		    tmpstr,
		    forwstr,
		    typestring, forwstr);
	fprintf(codefile,
		"len = %s_oldlen - %s_datalen;\n",
		tmpstr, tmpstr);
	if(optional)
	    fprintf(codefile,
		    "}\n");
	fprintf(codefile,
		"}\n");
	free(tname);
	free(typestring);
	break;
    }
    case TChoice: {
	Member *m, *have_ellipsis = NULL;
	const char *els = "";

	if (t->members == NULL)
	    break;

	ASN1_TAILQ_FOREACH(m, t->members, members) {
	    const Type *tt = m->type;
	    char *s = NULL;
	    Der_class cl;
	    Der_type  ty;
	    unsigned  tag;

	    if (m->ellipsis) {
		have_ellipsis = m;
		continue;
	    }

	    find_tag(tt, &cl, &ty, &tag);

	    fprintf(codefile,
		    "%sif (der_match_tag(p, len, %s, %s, %s, NULL) == 0) {\n",
		    els,
		    classname(cl),
		    ty ? "CONS" : "PRIM",
		    valuename(cl, tag));
	    if (asprintf (&s, "%s(%s)->u.%s", m->optional ? "" : "&",
			  name, m->gen_name) < 0 || s == NULL)
		errx(1, "malloc");
	    decode_type (s, m->type, m->optional, forwstr, m->gen_name, NULL,
		depth + 1);
	    fprintf(codefile,
		    "(%s)->element = %s;\n",
		    name, m->label);
	    free(s);
	    fprintf(codefile,
		    "}\n");
	    els = "else ";
	}
	if (have_ellipsis) {
	    fprintf(codefile,
		    "else {\n"
		    "(%s)->u.%s.data = calloc(1, len);\n"
		    "if ((%s)->u.%s.data == NULL) {\n"
		    "e = ENOMEM; %s;\n"
		    "}\n"
		    "(%s)->u.%s.length = len;\n"
		    "memcpy((%s)->u.%s.data, p, len);\n"
		    "(%s)->element = %s;\n"
		    "p += len;\n"
		    "ret += len;\n"
		    "len = 0;\n"
		    "}\n",
		    name, have_ellipsis->gen_name,
		    name, have_ellipsis->gen_name,
		    forwstr,
		    name, have_ellipsis->gen_name,
		    name, have_ellipsis->gen_name,
		    name, have_ellipsis->label);
	} else {
	    fprintf(codefile,
		    "else {\n"
		    "e = ASN1_PARSE_ERROR;\n"
		    "%s;\n"
		    "}\n",
		    forwstr);
	}
	break;
    }
    case TUTCTime:
	decode_primitive ("utctime", name, forwstr);
	break;
    case TUTF8String:
	decode_primitive ("utf8string", name, forwstr);
	break;
    case TPrintableString:
	decode_primitive ("printable_string", name, forwstr);
	break;
    case TIA5String:
	decode_primitive ("ia5_string", name, forwstr);
	break;
    case TBMPString:
	decode_primitive ("bmp_string", name, forwstr);
	break;
    case TUniversalString:
	decode_primitive ("universal_string", name, forwstr);
	break;
    case TVisibleString:
	decode_primitive ("visible_string", name, forwstr);
	break;
    case TNull:
	fprintf (codefile, "/* NULL */\n");
	break;
    case TOID:
	decode_primitive ("oid", name, forwstr);
	break;
    default :
	abort ();
    }
    return 0;
}

void
generate_type_decode (const Symbol *s)
{
    int preserve = preserve_type(s->name) ? TRUE : FALSE;

    fprintf (codefile, "int ASN1CALL\n"
	     "decode_%s(const unsigned char *p HEIMDAL_UNUSED_ATTRIBUTE,"
	     " size_t len HEIMDAL_UNUSED_ATTRIBUTE, %s *data, size_t *size)\n"
	     "{\n",
	     s->gen_name, s->gen_name);

    switch (s->type->type) {
    case TInteger:
    case TBoolean:
    case TOctetString:
    case TOID:
    case TGeneralizedTime:
    case TGeneralString:
    case TTeletexString:
    case TUTF8String:
    case TPrintableString:
    case TIA5String:
    case TBMPString:
    case TUniversalString:
    case TVisibleString:
    case TUTCTime:
    case TNull:
    case TEnumerated:
    case TBitString:
    case TSequence:
    case TSequenceOf:
    case TSet:
    case TSetOf:
    case TTag:
    case TType:
    case TChoice:
	fprintf (codefile,
		 "size_t ret = 0;\n"
		 "size_t l HEIMDAL_UNUSED_ATTRIBUTE;\n"
		 "int e HEIMDAL_UNUSED_ATTRIBUTE;\n");
	if (preserve)
	    fprintf (codefile, "const unsigned char *begin = p;\n");

	fprintf (codefile, "\n");
	fprintf (codefile, "memset(data, 0, sizeof(*data));\n"); /* hack to avoid `unused variable' */

	decode_type ("data", s->type, 0, "goto fail", "Top", NULL, 1);
	if (preserve)
	    fprintf (codefile,
		     "data->_save.data = calloc(1, ret);\n"
		     "if (data->_save.data == NULL) { \n"
		     "e = ENOMEM; goto fail; \n"
		     "}\n"
		     "data->_save.length = ret;\n"
		     "memcpy(data->_save.data, begin, ret);\n");
	fprintf (codefile,
		 "if(size) *size = ret;\n"
		 "return 0;\n");
	fprintf (codefile,
		 "fail:\n"
		 "free_%s(data);\n"
		 "return e;\n",
		 s->gen_name);
	break;
    default:
	abort ();
    }
    fprintf (codefile, "}\n\n");
}
@


1.2
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d37 1
a37 1
RCSID("$Id$");
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d35 1
d37 1
a37 1
RCSID("$KTH: gen_decode.c,v 1.15 2001/01/29 08:36:45 assar Exp $");
d40 1
a40 1
decode_primitive (const char *typename, const char *name)
d42 1
d45 8
a52 1
	     "FORW;\n",
d54 3
a56 1
	     name);
d60 2
a61 1
decode_type (const char *name, const Type *t)
d64 79
d144 78
a221 3
#if 0
	decode_type (name, t->symbol->type);
#endif
d223 1
a223 2
		 "e = decode_%s(p, len, %s, &l);\n"
		 "FORW;\n",
d225 16
d242 1
d244 20
a263 10
	if(t->members == NULL)
	    decode_primitive ("integer", name);
	else {
	    char *s;
	    asprintf(&s, "(int*)%s", name);
	    if(s == NULL)
		errx (1, "out of memory");
	    decode_primitive ("integer", s);
	    free(s);
	}
d265 5
a269 2
    case TUInteger:
	decode_primitive ("unsigned", name);
d272 13
a284 1
	decode_primitive ("octet_string", name);
d288 1
a288 2
	int tag = -1;
	int pos;
d290 11
a300 12
	fprintf (codefile,
		 "e = der_match_tag_and_length (p, len, UNIV, PRIM, UT_BitString,"
		 "&reallen, &l);\n"
		 "FORW;\n"
		 "if(len < reallen)\n"
		 "return ASN1_OVERRUN;\n"
		 "p++;\n"
		 "len--;\n"
		 "reallen--;\n"
		 "ret++;\n");
	pos = 0;
	for (m = t->members; m && tag != m->val; m = m->next) {
d303 2
a304 1
			 "p++; len--; reallen--; ret++;\n");
d308 1
a308 1
		     "%s->%s = (*p >> %d) & 1;\n",
a309 2
	    if (tag == -1)
		tag = m->val;
d311 2
d314 1
a314 1
		 "p += reallen; len -= reallen; ret += reallen;\n");
a318 1
	int tag = -1;
d323 22
a344 8
	fprintf (codefile,
		 "e = der_match_tag_and_length (p, len, UNIV, CONS, UT_Sequence,"
		 "&reallen, &l);\n"
		 "FORW;\n"
		 "{\n"
		 "int dce_fix;\n"
		 "if((dce_fix = fix_dce(reallen, &len)) < 0)\n"
		 "return ASN1_BAD_FORMAT;\n");
d346 12
a357 1
	for (m = t->members; m && tag != m->val; m = m->next) {
d360 15
a374 70
	    asprintf (&s, "%s(%s)->%s", m->optional ? "" : "&", name, m->gen_name);
	    if (0 && m->type->type == TType){
		if(m->optional)
		    fprintf (codefile,
			     "%s = malloc(sizeof(*%s));\n"
			     "if(%s == NULL) return ENOMEM;\n", s, s, s);
		fprintf (codefile, 
			 "e = decode_seq_%s(p, len, %d, %d, %s, &l);\n",
			 m->type->symbol->gen_name,
			 m->val, 
			 m->optional,
			 s);
		if(m->optional)
		    fprintf (codefile, 
			     "if (e == ASN1_MISSING_FIELD) {\n"
			     "free(%s);\n"
			     "%s = NULL;\n"
			     "e = l = 0;\n"
			     "}\n",
			     s, s);
	  
		fprintf (codefile, "FORW;\n");
	  
	    }else{
		fprintf (codefile, "{\n"
			 "size_t newlen, oldlen;\n\n"
			 "e = der_match_tag (p, len, CONTEXT, CONS, %d, &l);\n",
			 m->val);
		fprintf (codefile,
			 "if (e)\n");
		if(m->optional)
		    /* XXX should look at e */
		    fprintf (codefile,
			     "%s = NULL;\n", s);
		else
		    fprintf (codefile,
			     "return e;\n");
		fprintf (codefile, 
			 "else {\n");
		fprintf (codefile,
			 "p += l;\n"
			 "len -= l;\n"
			 "ret += l;\n"
			 "e = der_get_length (p, len, &newlen, &l);\n"
			 "FORW;\n"
			 "{\n"
	       
			 "int dce_fix;\n"
			 "oldlen = len;\n"
			 "if((dce_fix = fix_dce(newlen, &len)) < 0)"
			 "return ASN1_BAD_FORMAT;\n");
		if (m->optional)
		    fprintf (codefile,
			     "%s = malloc(sizeof(*%s));\n"
			     "if(%s == NULL) return ENOMEM;\n", s, s, s);
		decode_type (s, m->type);
		fprintf (codefile,
			 "if(dce_fix){\n"
			 "e = der_match_tag_and_length (p, len, "
			 "(Der_class)0, (Der_type)0, 0, &reallen, &l);\n"
			 "FORW;\n"
			 "}else \n"
			 "len = oldlen - newlen;\n"
			 "}\n"
			 "}\n");
		fprintf (codefile,
			 "}\n");
	    }
	    if (tag == -1)
		tag = m->val;
d376 4
d382 8
a389 6
		"if(dce_fix){\n"
		"e = der_match_tag_and_length (p, len, "
		"(Der_class)0, (Der_type)0, 0, &reallen, &l);\n"
		"FORW;\n"
		"}\n"
		"}\n");
d391 13
d406 1
d408 2
a409 9
	char *n;

	fprintf (codefile,
		 "e = der_match_tag_and_length (p, len, UNIV, CONS, UT_Sequence,"
		 "&reallen, &l);\n"
		 "FORW;\n"
		 "if(len < reallen)\n"
		 "return ASN1_OVERRUN;\n"
		 "len = reallen;\n");
d413 4
a416 2
		 "size_t origlen = len;\n"
		 "int oldret = ret;\n"
d419 30
a448 2
		 "(%s)->val = NULL;\n"
		 "while(ret < origlen) {\n"
d450 1
a450 6
		 "(%s)->val = realloc((%s)->val, sizeof(*((%s)->val)) * (%s)->len);\n",
		 name, name, name, name, name, name, name);
	asprintf (&n, "&(%s)->val[(%s)->len-1]", name, name);
	decode_type (n, t->subtype);
	fprintf (codefile, 
		 "len = origlen - ret;\n"
d452 6
a457 2
		 "ret += oldret;\n"
		 "}\n");
d459 1
d463 1
a463 1
	decode_primitive ("generalized_time", name);
d466 1
a466 1
	decode_primitive ("general_string", name);
d468 47
a514 1
    case TApplication:
d516 38
a553 9
		 "e = der_match_tag_and_length (p, len, APPL, CONS, %d, "
		 "&reallen, &l);\n"
		 "FORW;\n"
		 "{\n"
		 "int dce_fix;\n"
		 "if((dce_fix = fix_dce(reallen, &len)) < 0)\n"
		 "return ASN1_BAD_FORMAT;\n", 
		 t->application);
	decode_type (name, t->subtype);
a554 5
		"if(dce_fix){\n"
		"e = der_match_tag_and_length (p, len, "
		"(Der_class)0, (Der_type)0, 0, &reallen, &l);\n"
		"FORW;\n"
		"}\n"
d556 22
d579 77
d660 1
d666 1
a666 46
  fprintf (headerfile,
	   "int    "
	   "decode_%s(const unsigned char *, size_t, %s *, size_t *);\n",
	   s->gen_name, s->gen_name);

  fprintf (codefile, "#define FORW "
	   "if(e) return e; "
	   "p += l; "
	   "len -= l; "
	   "ret += l\n\n");


  fprintf (codefile, "int\n"
	   "decode_%s(const unsigned char *p,"
	   " size_t len, %s *data, size_t *size)\n"
	   "{\n",
	   s->gen_name, s->gen_name);

  switch (s->type->type) {
  case TInteger:
  case TUInteger:
  case TOctetString:
  case TGeneralizedTime:
  case TGeneralString:
  case TBitString:
  case TSequence:
  case TSequenceOf:
  case TApplication:
  case TType:
    fprintf (codefile,
	     "size_t ret = 0, reallen;\n"
	     "size_t l;\n"
	     "int i, e;\n\n");
    fprintf(codefile, "i = 0;\n"); /* hack to avoid `unused variable' */
    fprintf(codefile, "reallen = 0;\n"); /* hack to avoid `unused variable' */

    decode_type ("data", s->type);
    fprintf (codefile, 
	     "if(size) *size = ret;\n"
	     "return 0;\n");
    break;
  default:
    abort ();
  }
  fprintf (codefile, "}\n\n");
}
d668 4
a671 6
void
generate_seq_type_decode (const Symbol *s)
{
    fprintf (headerfile,
	     "int decode_seq_%s(const unsigned char *, size_t, int, int, "
	     "%s *, size_t *);\n",
d674 31
a704 5
    fprintf (codefile, "int\n"
	     "decode_seq_%s(const unsigned char *p, size_t len, int tag, "
	     "int optional, %s *data, size_t *size)\n"
	     "{\n",
	     s->gen_name, s->gen_name);
d706 2
a707 41
    fprintf (codefile,
	     "size_t newlen, oldlen;\n"
	     "size_t l, ret = 0;\n"
	     "int e;\n"
	     "int dce_fix;\n");
    
    fprintf (codefile,
	     "e = der_match_tag(p, len, CONTEXT, CONS, tag, &l);\n"
	     "if (e)\n"
	     "return e;\n");
    fprintf (codefile, 
	     "p += l;\n"
	     "len -= l;\n"
	     "ret += l;\n"
	     "e = der_get_length(p, len, &newlen, &l);\n"
	     "if (e)\n"
	     "return e;\n"
	     "p += l;\n"
	     "len -= l;\n"
	     "ret += l;\n"
	     "oldlen = len;\n"
	     "if ((dce_fix = fix_dce(newlen, &len)) < 0)\n"
	     "return ASN1_BAD_FORMAT;\n"
	     "e = decode_%s(p, len, data, &l);\n"
	     "if (e)\n"
	     "return e;\n"
	     "p += l;\n"
	     "len -= l;\n"
	     "ret += l;\n"
	     "if (dce_fix) {\n"
	     "size_t reallen;\n\n"
	     "e = der_match_tag_and_length(p, len, "
	     "(Der_class)0, (Der_type)0, 0, &reallen, &l);\n"
	     "if (e)\n"
	     "return e;\n"
	     "ret += l;\n"
	     "}\n",
	     s->gen_name);
    fprintf (codefile, 
	     "if(size) *size = ret;\n"
	     "return 0;\n");
d709 21
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d36 1
a36 1
RCSID("$KTH: gen_decode.c,v 1.16 2001/02/10 18:14:38 assar Exp $");
d284 1
a284 1
	   "if(e) goto fail; "
d311 2
a312 3
    fprintf (codefile, "memset(data, 0, sizeof(*data));\n");
    fprintf (codefile, "i = 0;\n"); /* hack to avoid `unused variable' */
    fprintf (codefile, "reallen = 0;\n"); /* hack to avoid `unused variable' */
a317 5
    fprintf (codefile,
	     "fail:\n"
	     "free_%s(data);\n"
	     "return e;\n",
	     s->gen_name);
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d36 1
a36 1
RCSID("$KTH: gen_decode.c,v 1.18 2002/08/09 15:37:34 joda Exp $");
a75 3
    case TEnumerated:
	decode_primitive ("enumerated", name);
	break;
a78 3
    case TOID :
	decode_primitive ("oid", name);
	break;
a299 1
  case TOID:
d310 1
a310 1
	     "int e;\n\n");
d312 1
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d36 1
a36 1
RCSID("$KTH: gen_decode.c,v 1.21 2005/05/29 14:23:01 lha Exp $");
d91 1
a91 1
		 "e = der_match_tag_and_length (p, len, ASN1_C_UNIV, PRIM, UT_BitString,"
d125 1
a125 1
		 "e = der_match_tag_and_length (p, len, ASN1_C_UNIV, CONS, UT_Sequence,"
d162 1
a162 1
			 "e = der_match_tag (p, len, ASN1_C_CONTEXT, CONS, %d, &l);\n",
d222 1
a222 1
		 "e = der_match_tag_and_length (p, len, ASN1_C_UNIV, CONS, UT_Sequence,"
a255 8
    case TUTF8String:
	decode_primitive ("utf8string", name);
	break;
    case TNull:
	fprintf (codefile,
		 "e = decode_nulltype(p, len, &l);\n"
		 "FORW;\n");
	break;
d258 1
a258 1
		 "e = der_match_tag_and_length (p, len, ASN1_C_APPL, CONS, %d, "
a275 3
    case TBoolean:
	decode_primitive ("boolean", name);
	break;
a304 1
  case TBoolean:
a308 3
  case TUTF8String:
  case TNull:
  case TEnumerated:
d358 1
a358 1
	     "e = der_match_tag(p, len, ASN1_C_CONTEXT, CONS, tag, &l);\n"
@


