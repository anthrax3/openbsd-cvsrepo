head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	HEIMDAL_0_7_2:1.1.1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	HEIMDAL_0_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	HEIMDAL_0_6:1.1.1.2
	HEIMDAL_0_6RC1:1.1.1.2
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	HEIMDAL_0_4e:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.04.22.10.01.27;	author reyk;	state dead;
branches;
next	1.5;

1.5
date	2013.06.17.18.57.42;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.12.23.20.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.55;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.55;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.02.15.36;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.14.07.32.52;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.6
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "der_locl.h"

RCSID("$Id: der_put.c,v 1.5 2013/06/17 18:57:42 robert Exp $");

/*
 * All encoding functions take a pointer `p' to first position in
 * which to write, from the right, `len' which means the maximum
 * number of characters we are able to write.  The function returns
 * the number of characters written in `size' (if non-NULL).
 * The return value is 0 or an error.
 */

int
der_put_unsigned (unsigned char *p, size_t len, const unsigned *v, size_t *size)
{
    unsigned char *base = p;
    unsigned val = *v;

    if (val) {
	while (len > 0 && val) {
	    *p-- = val % 256;
	    val /= 256;
	    --len;
	}
	if (val != 0)
	    return ASN1_OVERFLOW;
	else {
	    if(p[1] >= 128) {
		if(len < 1)
		    return ASN1_OVERFLOW;
		*p-- = 0;
	    }
	    *size = base - p;
	    return 0;
	}
    } else if (len < 1)
	return ASN1_OVERFLOW;
    else {
	*p    = 0;
	*size = 1;
	return 0;
    }
}

int
der_put_integer (unsigned char *p, size_t len, const int *v, size_t *size)
{
    unsigned char *base = p;
    int val = *v;

    if(val >= 0) {
	do {
	    if(len < 1)
		return ASN1_OVERFLOW;
	    *p-- = val % 256;
	    len--;
	    val /= 256;
	} while(val);
	if(p[1] >= 128) {
	    if(len < 1)
		return ASN1_OVERFLOW;
	    *p-- = 0;
	    len--;
	}
    } else {
	val = ~val;
	do {
	    if(len < 1)
		return ASN1_OVERFLOW;
	    *p-- = ~(val % 256);
	    len--;
	    val /= 256;
	} while(val);
	if(p[1] < 128) {
	    if(len < 1)
		return ASN1_OVERFLOW;
	    *p-- = 0xff;
	    len--;
	}
    }
    *size = base - p;
    return 0;
}


int
der_put_length (unsigned char *p, size_t len, size_t val, size_t *size)
{
    if (len < 1)
	return ASN1_OVERFLOW;

    if (val < 128) {
	*p = val;
	*size = 1;
    } else {
	size_t l = 0;

	while(val > 0) {
	    if(len < 2)
		return ASN1_OVERFLOW;
	    *p-- = val % 256;
	    val /= 256;
	    len--;
	    l++;
	}
	*p = 0x80 | l;
	if(size)
	    *size = l + 1;
    }
    return 0;
}

int
der_put_boolean(unsigned char *p, size_t len, const int *data, size_t *size)
{
    if(len < 1)
	return ASN1_OVERFLOW;
    if(*data != 0)
	*p = 0xff;
    else
	*p = 0;
    *size = 1;
    return 0;
}

int
der_put_general_string (unsigned char *p, size_t len,
			const heim_general_string *str, size_t *size)
{
    size_t slen = strlen(*str);

    if (len < slen)
	return ASN1_OVERFLOW;
    p -= slen;
    memcpy (p+1, *str, slen);
    *size = slen;
    return 0;
}

int
der_put_utf8string (unsigned char *p, size_t len,
		    const heim_utf8_string *str, size_t *size)
{
    return der_put_general_string(p, len, str, size);
}

int
der_put_printable_string (unsigned char *p, size_t len,
			  const heim_printable_string *str, size_t *size)
{
    return der_put_octet_string(p, len, str, size);
}

int
der_put_ia5_string (unsigned char *p, size_t len,
		    const heim_ia5_string *str, size_t *size)
{
    return der_put_octet_string(p, len, str, size);
}

int
der_put_bmp_string (unsigned char *p, size_t len,
		    const heim_bmp_string *data, size_t *size)
{
    size_t i;
    if (len / 2 < data->length)
	return ASN1_OVERFLOW;
    p -= data->length * 2;
    for (i = 0; i < data->length; i++) {
	p[1] = (data->data[i] >> 8) & 0xff;
	p[2] = data->data[i] & 0xff;
	p += 2;
    }
    if (size) *size = data->length * 2;
    return 0;
}

int
der_put_universal_string (unsigned char *p, size_t len,
			  const heim_universal_string *data, size_t *size)
{
    size_t i;
    if (len / 4 < data->length)
	return ASN1_OVERFLOW;
    p -= data->length * 4;
    for (i = 0; i < data->length; i++) {
	p[1] = (data->data[i] >> 24) & 0xff;
	p[2] = (data->data[i] >> 16) & 0xff;
	p[3] = (data->data[i] >> 8) & 0xff;
	p[4] = data->data[i] & 0xff;
	p += 4;
    }
    if (size) *size = data->length * 4;
    return 0;
}

int
der_put_visible_string (unsigned char *p, size_t len,
			 const heim_visible_string *str, size_t *size)
{
    return der_put_general_string(p, len, str, size);
}

int
der_put_octet_string (unsigned char *p, size_t len,
		      const heim_octet_string *data, size_t *size)
{
    if (len < data->length)
	return ASN1_OVERFLOW;
    p -= data->length;
    memcpy (p+1, data->data, data->length);
    *size = data->length;
    return 0;
}

int
der_put_heim_integer (unsigned char *p, size_t len,
		     const heim_integer *data, size_t *size)
{
    unsigned char *buf = data->data;
    int hibitset = 0;

    if (data->length == 0) {
	if (len < 1)
	    return ASN1_OVERFLOW;
	*p-- = 0;
	if (size)
	    *size = 1;
	return 0;
    }
    if (len < data->length)
	return ASN1_OVERFLOW;

    len -= data->length;

    if (data->negative) {
	int i, carry;
	for (i = data->length - 1, carry = 1; i >= 0; i--) {
	    *p = buf[i] ^ 0xff;
	    if (carry)
		carry = !++*p;
	    p--;
	}
	if (p[1] < 128) {
	    if (len < 1)
		return ASN1_OVERFLOW;
	    *p-- = 0xff;
	    len--;
	    hibitset = 1;
	}
    } else {
	p -= data->length;
	memcpy(p + 1, buf, data->length);

	if (p[1] >= 128) {
	    if (len < 1)
		return ASN1_OVERFLOW;
	    p[0] = 0;
	    len--;
	    hibitset = 1;
	}
    }
    if (size)
	*size = data->length + hibitset;
    return 0;
}

int
der_put_generalized_time (unsigned char *p, size_t len,
			  const time_t *data, size_t *size)
{
    heim_octet_string k;
    size_t l;
    int e;

    e = _heim_time2generalizedtime (*data, &k, 1);
    if (e)
	return e;
    e = der_put_octet_string(p, len, &k, &l);
    free(k.data);
    if(e)
	return e;
    if(size)
	*size = l;
    return 0;
}

int
der_put_utctime (unsigned char *p, size_t len,
		 const time_t *data, size_t *size)
{
    heim_octet_string k;
    size_t l;
    int e;

    e = _heim_time2generalizedtime (*data, &k, 0);
    if (e)
	return e;
    e = der_put_octet_string(p, len, &k, &l);
    free(k.data);
    if(e)
	return e;
    if(size)
	*size = l;
    return 0;
}

int
der_put_oid (unsigned char *p, size_t len,
	     const heim_oid *data, size_t *size)
{
    unsigned char *base = p;
    int n;

    for (n = data->length - 1; n >= 2; --n) {
	unsigned u = data->components[n];

	if (len < 1)
	    return ASN1_OVERFLOW;
	*p-- = u % 128;
	u /= 128;
	--len;
	while (u > 0) {
	    if (len < 1)
		return ASN1_OVERFLOW;
	    *p-- = 128 + u % 128;
	    u /= 128;
	    --len;
	}
    }
    if (len < 1)
	return ASN1_OVERFLOW;
    *p-- = 40 * data->components[0] + data->components[1];
    *size = base - p;
    return 0;
}

int
der_put_tag (unsigned char *p, size_t len, Der_class class, Der_type type,
	     unsigned int tag, size_t *size)
{
    if (tag <= 30) {
	if (len < 1)
	    return ASN1_OVERFLOW;
	*p = MAKE_TAG(class, type, tag);
	*size = 1;
    } else {
	size_t ret = 0;
	unsigned int continuation = 0;

	do {
	    if (len < 1)
		return ASN1_OVERFLOW;
	    *p-- = tag % 128 | continuation;
	    len--;
	    ret++;
	    tag /= 128;
	    continuation = 0x80;
	} while(tag > 0);
	if (len < 1)
	    return ASN1_OVERFLOW;
	*p-- = MAKE_TAG(class, type, 0x1f);
	ret++;
	*size = ret;
    }
    return 0;
}

int
der_put_length_and_tag (unsigned char *p, size_t len, size_t len_val,
			Der_class class, Der_type type,
			unsigned int tag, size_t *size)
{
    size_t ret = 0;
    size_t l;
    int e;

    e = der_put_length (p, len, len_val, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_tag (p, len, class, type, tag, &l);
    if(e)
	return e;

    ret += l;
    *size = ret;
    return 0;
}

int
_heim_time2generalizedtime (time_t t, heim_octet_string *s, int gtimep)
{
     struct tm tm;
     const size_t len = gtimep ? 15 : 13;

     s->data = malloc(len + 1);
     if (s->data == NULL)
	 return ENOMEM;
     s->length = len;
     if (_der_gmtime(t, &tm) == NULL)
	 return ASN1_BAD_TIMEFORMAT;
     if (gtimep)
	 snprintf (s->data, len + 1, "%04d%02d%02d%02d%02d%02dZ",
		   tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
		   tm.tm_hour, tm.tm_min, tm.tm_sec);
     else
	 snprintf (s->data, len + 1, "%02d%02d%02d%02d%02d%02dZ",
		   tm.tm_year % 100, tm.tm_mon + 1, tm.tm_mday,
		   tm.tm_hour, tm.tm_min, tm.tm_sec);

     return 0;
}

int
der_put_bit_string (unsigned char *p, size_t len,
		    const heim_bit_string *data, size_t *size)
{
    size_t data_size = (data->length + 7) / 8;
    if (len < data_size + 1)
	return ASN1_OVERFLOW;
    p -= data_size + 1;

    memcpy (p+2, data->data, data_size);
    if (data->length && (data->length % 8) != 0)
	p[1] = 8 - (data->length % 8);
    else
	p[1] = 0;
    *size = data_size + 1;
    return 0;
}

int
_heim_der_set_sort(const void *a1, const void *a2)
{
    const struct heim_octet_string *s1 = a1, *s2 = a2;
    int ret;

    ret = memcmp(s1->data, s2->data,
		 s1->length < s2->length ? s1->length : s2->length);
    if(ret)
	return ret;
    return s1->length - s2->length;
}
@


1.5
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d36 1
a36 1
RCSID("$Id$");
@


1.4
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d36 1
a36 1
RCSID("$KTH: der_put.c,v 1.32 2005/05/29 14:23:01 lha Exp $");
d46 2
a47 2
static int
der_put_unsigned (unsigned char *p, size_t len, unsigned val, size_t *size)
d50 1
d61 5
d79 1
a79 1
der_put_int (unsigned char *p, size_t len, int val, size_t *size)
d82 1
d124 1
a127 1
	return 0;
d129 1
a129 2
	size_t l;
	int e;
d131 8
a138 4
	e = der_put_unsigned (p, len - 1, val, &l);
	if (e)
	    return e;
	p -= l;
d140 2
a141 2
	*size = l + 1;
	return 0;
d143 1
d160 1
a160 1
der_put_general_string (unsigned char *p, size_t len, 
a167 1
    len -= slen;
d174 2
a175 2
der_put_octet_string (unsigned char *p, size_t len, 
		      const heim_octet_string *data, size_t *size)
d177 1
a177 7
    if (len < data->length)
	return ASN1_OVERFLOW;
    p -= data->length;
    len -= data->length;
    memcpy (p+1, data->data, data->length);
    *size = data->length;
    return 0;
d181 2
a182 2
der_put_oid (unsigned char *p, size_t len,
	     const heim_oid *data, size_t *size)
d184 2
a185 2
    unsigned char *base = p;
    int n;
d187 5
a191 21
    for (n = data->length - 1; n >= 2; --n) {
	unsigned u = data->components[n];

	if (len < 1)
	    return ASN1_OVERFLOW;
	*p-- = u % 128;
	u /= 128;
	--len;
	while (u > 0) {
	    if (len < 1)
		return ASN1_OVERFLOW;
	    *p-- = 128 + u % 128;
	    u /= 128;
	    --len;
	}
    }
    if (len < 1)
	return ASN1_OVERFLOW;
    *p-- = 40 * data->components[0] + data->components[1];
    *size = base - p;
    return 0;
d195 2
a196 2
der_put_tag (unsigned char *p, size_t len, Der_class class, Der_type type,
	     int tag, size_t *size)
d198 2
a199 1
    if (len < 1)
d201 7
a207 2
    *p = (class << 6) | (type << 5) | tag; /* XXX */
    *size = 1;
d212 2
a213 2
der_put_length_and_tag (unsigned char *p, size_t len, size_t len_val,
			Der_class class, Der_type type, int tag, size_t *size)
d215 12
a226 17
    size_t ret = 0;
    size_t l;
    int e;

    e = der_put_length (p, len, len_val, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_tag (p, len, class, type, tag, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d231 2
a232 2
encode_boolean (unsigned char *p, size_t len, const int *data,
		size_t *size)
d234 1
a234 18
    size_t ret = 0;
    size_t l;
    int e;
    
    e = der_put_boolean (p, len, data, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Boolean, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
    return 0;
d238 2
a239 1
encode_integer (unsigned char *p, size_t len, const int *data, size_t *size)
d241 5
a245 18
    int num = *data;
    size_t ret = 0;
    size_t l;
    int e;
    
    e = der_put_int (p, len, num, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Integer, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d250 2
a251 2
encode_unsigned (unsigned char *p, size_t len, const unsigned *data,
		 size_t *size)
d253 5
a257 14
    unsigned num = *data;
    size_t ret = 0;
    size_t l;
    int e;
    
    e = der_put_unsigned (p, len, num, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    /* if first octet has msb set, we need to pad with a zero byte */
    if(p[1] >= 128) {
	if(len == 0)
d260 35
a294 3
	len--;
	ret++;
	l++;
d296 2
a297 7
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Integer, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d302 2
a303 2
encode_enumerated (unsigned char *p, size_t len, const unsigned *data,
		   size_t *size)
d305 1
a305 2
    unsigned num = *data;
    size_t ret = 0;
d308 6
a313 2
    
    e = der_put_int (p, len, num, &l);
d316 2
a317 10
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Enumerated, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d322 2
a323 2
encode_general_string (unsigned char *p, size_t len, 
		       const heim_general_string *data, size_t *size)
d325 1
a325 1
    size_t ret = 0;
d329 1
a329 1
    e = der_put_general_string (p, len, data, &l);
d332 3
a334 5
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_GeneralString, &l);
    if (e)
d336 32
a367 4
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d372 2
a373 2
encode_octet_string (unsigned char *p, size_t len, 
		     const heim_octet_string *k, size_t *size)
d375 8
a382 3
    size_t ret = 0;
    size_t l;
    int e;
d384 15
a398 13
    e = der_put_octet_string (p, len, k, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_OctetString, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d403 3
a405 2
encode_oid(unsigned char *p, size_t len,
	   const heim_oid *k, size_t *size)
d411 2
a412 2
    e = der_put_oid (p, len, k, &l);
    if (e)
d417 2
a418 2
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_OID, &l);
    if (e)
d420 1
a420 2
    p -= l;
    len -= l;
d427 1
a427 1
time2generalizedtime (time_t t, heim_octet_string *s)
d429 2
a430 4
     struct tm *tm;
     size_t len;

     len = 15;
d436 10
a445 4
     tm = gmtime (&t);
     snprintf (s->data, len + 1, "%04d%02d%02d%02d%02d%02dZ", 
	       tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, 
	       tm->tm_hour, tm->tm_min, tm->tm_sec);
d451 2
a452 2
encode_generalized_time (unsigned char *p, size_t len,
			 const time_t *t, size_t *size)
d454 4
a457 4
    size_t ret = 0;
    size_t l;
    heim_octet_string k;
    int e;
d459 6
a464 18
    e = time2generalizedtime (*t, &k);
    if (e)
	return e;
    e = der_put_octet_string (p, len, &k, &l);
    free (k.data);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, k.length, ASN1_C_UNIV, PRIM, 
				UT_GeneralizedTime, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
d466 13
@


1.3
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: der_put.c,v 1.28 2003/04/17 07:12:24 lha Exp $");
d136 13
d150 1
a150 1
			const general_string *str, size_t *size)
d165 1
a165 1
		      const octet_string *data, size_t *size)
d178 1
a178 1
	     const oid *data, size_t *size)
d242 24
d279 1
a279 1
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_Integer, &l);
d304 10
a313 1
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_Integer, &l);
d338 1
a338 1
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_Enumerated, &l);
d350 1
a350 1
		       const general_string *data, size_t *size)
d362 1
a362 1
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_GeneralString, &l);
d374 1
a374 1
		     const octet_string *k, size_t *size)
d386 1
a386 1
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_OctetString, &l);
d398 1
a398 1
	   const oid *k, size_t *size)
d410 1
a410 1
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_OID, &l);
d421 1
a421 1
time2generalizedtime (time_t t, octet_string *s)
d446 1
a446 1
    octet_string k;
d459 1
a459 1
    e = der_put_length_and_tag (p, len, k.length, UNIV, PRIM, 
@


1.2
log
@string cleaning; parts by me, then parts by hin, then more parts by me.
since this is not a very important part of the source tree, and since it
does compile, i am dumping it in now.
@
text
@d36 1
a36 1
RCSID("$KTH: der_put.c,v 1.24 2001/01/29 08:31:27 assar Exp $");
d41 3
a43 2
 * number of characters we are able to write and return an int
 * indicating how many actually got written, or <0 in case of errors.
d115 2
d118 3
a120 7
	if (len < 1)
	    return ASN1_OVERFLOW;
	else {
	    *p = val;
	    *size = 1;
	    return 0;
	}
d164 30
d278 25
d351 24
d378 1
d380 3
a382 1
     s->data = malloc(16);
d385 1
a385 1
     s->length = 15;
d387 4
a390 3
     snprintf (s->data, 16, "%04d%02d%02d%02d%02d%02dZ", tm->tm_year + 1900,
	      tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
	      tm->tm_sec);
@


1.1
log
@Initial revision
@
text
@d306 1
a306 1
     sprintf (s->data, "%04d%02d%02d%02d%02d%02dZ", tm->tm_year + 1900,
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.6rc1
@
text
@d36 1
a36 1
RCSID("$KTH: der_put.c,v 1.28 2003/04/17 07:12:24 lha Exp $");
d41 2
a42 3
 * number of characters we are able to write.  The function returns
 * the number of characters written in `size' (if non-NULL).
 * The return value is 0 or an error.
a113 2
    if (len < 1)
	return ASN1_OVERFLOW;
d115 7
a121 3
	*p = val;
	*size = 1;
	return 0;
a164 30
der_put_oid (unsigned char *p, size_t len,
	     const oid *data, size_t *size)
{
    unsigned char *base = p;
    int n;

    for (n = data->length - 1; n >= 2; --n) {
	unsigned u = data->components[n];

	if (len < 1)
	    return ASN1_OVERFLOW;
	*p-- = u % 128;
	u /= 128;
	--len;
	while (u > 0) {
	    if (len < 1)
		return ASN1_OVERFLOW;
	    *p-- = 128 + u % 128;
	    u /= 128;
	    --len;
	}
    }
    if (len < 1)
	return ASN1_OVERFLOW;
    *p-- = 40 * data->components[0] + data->components[1];
    *size = base - p;
    return 0;
}

int
a248 25
encode_enumerated (unsigned char *p, size_t len, const unsigned *data,
		   size_t *size)
{
    unsigned num = *data;
    size_t ret = 0;
    size_t l;
    int e;
    
    e = der_put_int (p, len, num, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_Enumerated, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
    return 0;
}

int
a296 24
encode_oid(unsigned char *p, size_t len,
	   const oid *k, size_t *size)
{
    size_t ret = 0;
    size_t l;
    int e;

    e = der_put_oid (p, len, k, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, UNIV, PRIM, UT_OID, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
    return 0;
}

int
a299 3
     size_t len;

     len = 15;
d301 1
a301 1
     s->data = malloc(len + 1);
d304 1
a304 1
     s->length = len;
d306 3
a308 3
     snprintf (s->data, len + 1, "%04d%02d%02d%02d%02d%02dZ", 
	       tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, 
	       tm->tm_hour, tm->tm_min, tm->tm_sec);
@


1.1.1.3
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: der_put.c,v 1.32 2005/05/29 14:23:01 lha Exp $");
a135 13
der_put_boolean(unsigned char *p, size_t len, const int *data, size_t *size)
{
    if(len < 1)
	return ASN1_OVERFLOW;
    if(*data != 0)
	*p = 0xff;
    else
	*p = 0;
    *size = 1;
    return 0;
}

int
d137 1
a137 1
			const heim_general_string *str, size_t *size)
d152 1
a152 1
		      const heim_octet_string *data, size_t *size)
d165 1
a165 1
	     const heim_oid *data, size_t *size)
a228 24
encode_boolean (unsigned char *p, size_t len, const int *data,
		size_t *size)
{
    size_t ret = 0;
    size_t l;
    int e;
    
    e = der_put_boolean (p, len, data, &l);
    if(e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Boolean, &l);
    if (e)
	return e;
    p -= l;
    len -= l;
    ret += l;
    *size = ret;
    return 0;
}

int
d242 1
a242 1
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Integer, &l);
d267 1
a267 10
    /* if first octet has msb set, we need to pad with a zero byte */
    if(p[1] >= 128) {
	if(len == 0)
	    return ASN1_OVERFLOW;
	*p-- = 0;
	len--;
	ret++;
	l++;
    }
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Integer, &l);
d292 1
a292 1
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_Enumerated, &l);
d304 1
a304 1
		       const heim_general_string *data, size_t *size)
d316 1
a316 1
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_GeneralString, &l);
d328 1
a328 1
		     const heim_octet_string *k, size_t *size)
d340 1
a340 1
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_OctetString, &l);
d352 1
a352 1
	   const heim_oid *k, size_t *size)
d364 1
a364 1
    e = der_put_length_and_tag (p, len, l, ASN1_C_UNIV, PRIM, UT_OID, &l);
d375 1
a375 1
time2generalizedtime (time_t t, heim_octet_string *s)
d399 1
a399 1
    heim_octet_string k;
d412 1
a412 1
    e = der_put_length_and_tag (p, len, k.length, ASN1_C_UNIV, PRIM, 
@


