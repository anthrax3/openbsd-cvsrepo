head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.28
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.26
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.24
	OPENBSD_5_0:1.10.0.22
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.20
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.18
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.14
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	HEIMDAL_0_7_2:1.1.1.7
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	HEIMDAL_0_6_3:1.1.1.6
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	HEIMDAL_0_6:1.1.1.5
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.11;

1.11
date	2013.06.17.18.57.42;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.29.16.20.30;	author biorn;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.02.02.19.02;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.13.03.09.16;	author hin;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.06.00.37.37;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.05.16.16.50;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.06.09.10.02;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.11.10.05.20;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.50;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.50;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.22.02;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.54.57;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.34;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.13.02.59.45;	author hin;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.10.29.15.55.32;	author biorn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.04.14.07.32.49;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.12
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2007 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Portions Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kuser_locl.h"

#ifdef __APPLE__
#include <Security/Security.h>
#endif

#ifndef NO_NTLM
#include "heimntlm.h"
#endif

int forwardable_flag	= -1;
int proxiable_flag	= -1;
int renewable_flag	= -1;
int renew_flag		= 0;
int pac_flag		= -1;
int validate_flag	= 0;
int version_flag	= 0;
int help_flag		= 0;
int addrs_flag		= -1;
struct getarg_strings extra_addresses;
int anonymous_flag	= 0;
char *lifetime 		= NULL;
char *renew_life	= NULL;
char *server_str	= NULL;
char *cred_cache	= NULL;
char *start_str		= NULL;
static int switch_cache_flags = 1;
struct getarg_strings etype_str;
int use_keytab		= 0;
char *keytab_str	= NULL;
int do_afslog		= -1;
int fcache_version;
char *password_file	= NULL;
char *pk_user_id	= NULL;
int pk_enterprise_flag = 0;
struct hx509_certs_data *ent_user_id = NULL;
char *pk_x509_anchors	= NULL;
int pk_use_enckey	= 0;
static int canonicalize_flag = 0;
static int enterprise_flag = 0;
static int ok_as_delegate_flag = 0;
static int use_referrals_flag = 0;
static int windows_flag = 0;
#ifndef NO_NTLM
static char *ntlm_domain;
#endif


static struct getargs args[] = {
    /*
     * used by MIT
     * a: ~A
     * V: verbose
     * F: ~f
     * P: ~p
     * C: v4 cache name?
     * 5:
     *
     * old flags
     * 4:
     * 9:
     */
    { "afslog", 	0  , arg_flag, &do_afslog,
      NP_("obtain afs tokens", ""), NULL },

    { "cache", 		'c', arg_string, &cred_cache,
      NP_("credentials cache", ""), "cachename" },

    { "forwardable",	0, arg_negative_flag, &forwardable_flag,
      NP_("get tickets not forwardable", ""), NULL },

    { NULL,		'f', arg_flag, &forwardable_flag,
      NP_("get forwardable tickets", ""), NULL },

    { "keytab",         't', arg_string, &keytab_str,
      NP_("keytab to use", ""), "keytabname" },

    { "lifetime",	'l', arg_string, &lifetime,
      NP_("lifetime of tickets", ""), "time" },

    { "proxiable",	'p', arg_flag, &proxiable_flag,
      NP_("get proxiable tickets", ""), NULL },

    { "renew",          'R', arg_flag, &renew_flag,
      NP_("renew TGT", ""), NULL },

    { "renewable",	0,   arg_flag, &renewable_flag,
      NP_("get renewable tickets", ""), NULL },

    { "renewable-life",	'r', arg_string, &renew_life,
      NP_("renewable lifetime of tickets", ""), "time" },

    { "server", 	'S', arg_string, &server_str,
      NP_("server to get ticket for", ""), "principal" },

    { "start-time",	's', arg_string, &start_str,
      NP_("when ticket gets valid", ""), "time" },

    { "use-keytab",     'k', arg_flag, &use_keytab,
      NP_("get key from keytab", ""), NULL },

    { "validate",	'v', arg_flag, &validate_flag,
      NP_("validate TGT", ""), NULL },

    { "enctypes",	'e', arg_strings, &etype_str,
      NP_("encryption types to use", ""), "enctypes" },

    { "fcache-version", 0,   arg_integer, &fcache_version,
      NP_("file cache version to create", ""), NULL },

    { "addresses",	'A',   arg_negative_flag,	&addrs_flag,
      NP_("request a ticket with no addresses", ""), NULL },

    { "extra-addresses",'a', arg_strings,	&extra_addresses,
      NP_("include these extra addresses", ""), "addresses" },

    { "anonymous",	0,   arg_flag,	&anonymous_flag,
      NP_("request an anonymous ticket", ""), NULL },

    { "request-pac",	0,   arg_flag,	&pac_flag,
      NP_("request a Windows PAC", ""), NULL },

    { "password-file",	0,   arg_string, &password_file,
      NP_("read the password from a file", ""), NULL },

    { "canonicalize",0,   arg_flag, &canonicalize_flag,
      NP_("canonicalize client principal", ""), NULL },

    { "enterprise",0,   arg_flag, &enterprise_flag,
      NP_("parse principal as a KRB5-NT-ENTERPRISE name", ""), NULL },
#ifdef PKINIT
    { "pk-enterprise",	0,	arg_flag,	&pk_enterprise_flag,
      NP_("use enterprise name from certificate", ""), NULL },

    { "pk-user",	'C',	arg_string,	&pk_user_id,
      NP_("principal's public/private/certificate identifier", ""), "id" },

    { "x509-anchors",	'D',  arg_string, &pk_x509_anchors,
      NP_("directory with CA certificates", ""), "directory" },

    { "pk-use-enckey",	0,  arg_flag, &pk_use_enckey,
      NP_("Use RSA encrypted reply (instead of DH)", ""), NULL },
#endif
#ifndef NO_NTLM
    { "ntlm-domain",	0,  arg_string, &ntlm_domain,
      NP_("NTLM domain", ""), "domain" },
#endif

    { "change-default",  0,  arg_negative_flag, &switch_cache_flags,
      NP_("switch the default cache to the new credentials cache", ""), NULL },

    { "ok-as-delegate",	0,  arg_flag, &ok_as_delegate_flag,
      NP_("honor ok-as-delegate on tickets", ""), NULL },

    { "use-referrals",	0,  arg_flag, &use_referrals_flag,
      NP_("only use referrals, no dns canalisation", ""), NULL },

    { "windows",	0,  arg_flag, &windows_flag,
      NP_("get windows behavior", ""), NULL },

    { "version", 	0,   arg_flag, &version_flag, NULL, NULL },
    { "help",		0,   arg_flag, &help_flag, NULL, NULL }
};

static void
usage (int ret)
{
    arg_printusage_i18n (args,
			 sizeof(args)/sizeof(*args),
			 N_("Usage: ", ""),
			 NULL,
			 "[principal [command]]",
			 getarg_i18n);
    exit (ret);
}

static krb5_error_code
get_server(krb5_context context,
	   krb5_principal client,
	   const char *server,
	   krb5_principal *princ)
{
    krb5_const_realm realm;
    if(server)
	return krb5_parse_name(context, server, princ);

    realm = krb5_principal_get_realm(context, client);
    return krb5_make_principal(context, princ, realm,
			       KRB5_TGS_NAME, realm, NULL);
}

static int
renew_validate(krb5_context context,
	       int renew,
	       int validate,
	       krb5_ccache cache,
	       const char *server,
	       krb5_deltat life)
{
    krb5_error_code ret;
    krb5_creds in, *out = NULL;
    krb5_kdc_flags flags;

    memset(&in, 0, sizeof(in));

    ret = krb5_cc_get_principal(context, cache, &in.client);
    if(ret) {
	krb5_warn(context, ret, "krb5_cc_get_principal");
	return ret;
    }
    ret = get_server(context, in.client, server, &in.server);
    if(ret) {
	krb5_warn(context, ret, "get_server");
	goto out;
    }

    if (renew) {
	/*
	 * no need to check the error here, it's only to be
	 * friendly to the user
	 */
	krb5_get_credentials(context, KRB5_GC_CACHED, cache, &in, &out);
    }

    flags.i = 0;
    flags.b.renewable         = flags.b.renew = renew;
    flags.b.validate          = validate;

    if (forwardable_flag != -1)
	flags.b.forwardable       = forwardable_flag;
    else if (out)
	flags.b.forwardable 	  = out->flags.b.forwardable;

    if (proxiable_flag != -1)
	flags.b.proxiable         = proxiable_flag;
    else if (out)
	flags.b.proxiable 	  = out->flags.b.proxiable;

    if (anonymous_flag)
	flags.b.request_anonymous = anonymous_flag;
    if(life)
	in.times.endtime = time(NULL) + life;

    if (out) {
	krb5_free_creds (context, out);
	out = NULL;
    }


    ret = krb5_get_kdc_cred(context,
			    cache,
			    flags,
			    NULL,
			    NULL,
			    &in,
			    &out);
    if(ret) {
	krb5_warn(context, ret, "krb5_get_kdc_cred");
	goto out;
    }
    ret = krb5_cc_initialize(context, cache, in.client);
    if(ret) {
	krb5_free_creds (context, out);
	krb5_warn(context, ret, "krb5_cc_initialize");
	goto out;
    }
    ret = krb5_cc_store_cred(context, cache, out);

    if(ret == 0 && server == NULL) {
	/* only do this if it's a general renew-my-tgt request */
#ifndef NO_AFS
	if(do_afslog && k_hasafs())
	    krb5_afslog(context, cache, NULL, NULL);
#endif
    }

    krb5_free_creds (context, out);
    if(ret) {
	krb5_warn(context, ret, "krb5_cc_store_cred");
	goto out;
    }
out:
    krb5_free_cred_contents(context, &in);
    return ret;
}

#ifndef NO_NTLM

static krb5_error_code
store_ntlmkey(krb5_context context, krb5_ccache id,
	      const char *domain, struct ntlm_buf *buf)
{
    krb5_error_code ret;
    krb5_data data;
    char *name;

    asprintf(&name, "ntlm-key-%s", domain);
    if (name == NULL) {
	krb5_clear_error_message(context);
	return ENOMEM;
    }

    data.length = buf->length;
    data.data = buf->data;

    ret = krb5_cc_set_config(context, id, NULL, name, &data);
    free(name);
    return ret;
}
#endif

static krb5_error_code
get_new_tickets(krb5_context context,
		krb5_principal principal,
		krb5_ccache ccache,
		krb5_deltat ticket_life,
		int interactive)
{
    krb5_error_code ret;
    krb5_get_init_creds_opt *opt;
    krb5_creds cred;
    char passwd[256];
    krb5_deltat start_time = 0;
    krb5_deltat renew = 0;
    const char *renewstr = NULL;
    krb5_enctype *enctype = NULL;
    krb5_ccache tempccache;
#ifndef NO_NTLM
    struct ntlm_buf ntlmkey;
    memset(&ntlmkey, 0, sizeof(ntlmkey));
#endif
    passwd[0] = '\0';

    if (password_file) {
	FILE *f;

	if (strcasecmp("STDIN", password_file) == 0)
	    f = stdin;
	else
	    f = fopen(password_file, "r");
	if (f == NULL)
	    krb5_errx(context, 1, "Failed to open the password file %s",
		      password_file);

	if (fgets(passwd, sizeof(passwd), f) == NULL)
	    krb5_errx(context, 1,
		      N_("Failed to read password from file %s", ""),
		      password_file);
	if (f != stdin)
	    fclose(f);
	passwd[strcspn(passwd, "\n")] = '\0';
    }

#ifdef __APPLE__
    if (passwd[0] == '\0') {
	const char *realm;
	OSStatus osret;
	UInt32 length;
	void *buffer;
	char *name;

	realm = krb5_principal_get_realm(context, principal);

	ret = krb5_unparse_name_flags(context, principal,
				      KRB5_PRINCIPAL_UNPARSE_NO_REALM, &name);
	if (ret)
	    goto nopassword;

	osret = SecKeychainFindGenericPassword(NULL, strlen(realm), realm,
					       strlen(name), name,
					       &length, &buffer, NULL);
	free(name);
	if (osret == noErr && length < sizeof(passwd) - 1) {
	    memcpy(passwd, buffer, length);
	    passwd[length] = '\0';
	}
    nopassword:
	do { } while(0);
    }
#endif

    memset(&cred, 0, sizeof(cred));

    ret = krb5_get_init_creds_opt_alloc (context, &opt);
    if (ret)
	krb5_err(context, 1, ret, "krb5_get_init_creds_opt_alloc");

    krb5_get_init_creds_opt_set_default_flags(context, "kinit",
	krb5_principal_get_realm(context, principal), opt);

    if(forwardable_flag != -1)
	krb5_get_init_creds_opt_set_forwardable (opt, forwardable_flag);
    if(proxiable_flag != -1)
	krb5_get_init_creds_opt_set_proxiable (opt, proxiable_flag);
    if(anonymous_flag)
	krb5_get_init_creds_opt_set_anonymous (opt, anonymous_flag);
    if (pac_flag != -1)
	krb5_get_init_creds_opt_set_pac_request(context, opt,
						pac_flag ? TRUE : FALSE);
    if (canonicalize_flag)
	krb5_get_init_creds_opt_set_canonicalize(context, opt, TRUE);
    if (pk_enterprise_flag || enterprise_flag || canonicalize_flag || windows_flag)
	krb5_get_init_creds_opt_set_win2k(context, opt, TRUE);
    if (pk_user_id || ent_user_id || anonymous_flag) {
	ret = krb5_get_init_creds_opt_set_pkinit(context, opt,
						 principal,
						 pk_user_id,
						 pk_x509_anchors,
						 NULL,
						 NULL,
						 pk_use_enckey ? 2 : 0 |
						 anonymous_flag ? 4 : 0,
						 krb5_prompter_posix,
						 NULL,
						 passwd);
	if (ret)
	    krb5_err(context, 1, ret, "krb5_get_init_creds_opt_set_pkinit");
	if (ent_user_id)
	    krb5_get_init_creds_opt_set_pkinit_user_certs(context, opt, ent_user_id);
    }

    if (addrs_flag != -1)
	krb5_get_init_creds_opt_set_addressless(context, opt,
						addrs_flag ? FALSE : TRUE);

    if (renew_life == NULL && renewable_flag)
	renewstr = "1 month";
    if (renew_life)
	renewstr = renew_life;
    if (renewstr) {
	renew = parse_time (renewstr, "s");
	if (renew < 0)
	    errx (1, "unparsable time: %s", renewstr);

	krb5_get_init_creds_opt_set_renew_life (opt, renew);
    }

    if(ticket_life != 0)
	krb5_get_init_creds_opt_set_tkt_life (opt, ticket_life);

    if(start_str) {
	int tmp = parse_time (start_str, "s");
	if (tmp < 0)
	    errx (1, N_("unparsable time: %s", ""), start_str);

	start_time = tmp;
    }

    if(etype_str.num_strings) {
	int i;

	enctype = malloc(etype_str.num_strings * sizeof(*enctype));
	if(enctype == NULL)
	    errx(1, "out of memory");
	for(i = 0; i < etype_str.num_strings; i++) {
	    ret = krb5_string_to_enctype(context,
					 etype_str.strings[i],
					 &enctype[i]);
	    if(ret)
		errx(1, "unrecognized enctype: %s", etype_str.strings[i]);
	}
	krb5_get_init_creds_opt_set_etype_list(opt, enctype,
					       etype_str.num_strings);
    }

    if(use_keytab || keytab_str) {
	krb5_keytab kt;
	if(keytab_str)
	    ret = krb5_kt_resolve(context, keytab_str, &kt);
	else
	    ret = krb5_kt_default(context, &kt);
	if (ret)
	    krb5_err (context, 1, ret, "resolving keytab");
	ret = krb5_get_init_creds_keytab (context,
					  &cred,
					  principal,
					  kt,
					  start_time,
					  server_str,
					  opt);
	krb5_kt_close(context, kt);
    } else if (pk_user_id || ent_user_id || anonymous_flag) {
	ret = krb5_get_init_creds_password (context,
					    &cred,
					    principal,
					    passwd,
					    krb5_prompter_posix,
					    NULL,
					    start_time,
					    server_str,
					    opt);
    } else if (!interactive) {
	krb5_warnx(context, "Not interactive, failed to get initial ticket");
	krb5_get_init_creds_opt_free(context, opt);
	return 0;
    } else {

	if (passwd[0] == '\0') {
	    char *p, *prompt;

	    krb5_unparse_name (context, principal, &p);
	    asprintf (&prompt, N_("%s's Password: ", ""), p);
	    free (p);

	    if (UI_UTIL_read_pw_string(passwd, sizeof(passwd)-1, prompt, 0)){
		memset(passwd, 0, sizeof(passwd));
		exit(1);
	    }
	    free (prompt);
	}


	ret = krb5_get_init_creds_password (context,
					    &cred,
					    principal,
					    passwd,
					    krb5_prompter_posix,
					    NULL,
					    start_time,
					    server_str,
					    opt);
    }
    krb5_get_init_creds_opt_free(context, opt);
#ifndef NO_NTLM
    if (ntlm_domain && passwd[0])
	heim_ntlm_nt_key(passwd, &ntlmkey);
#endif
    memset(passwd, 0, sizeof(passwd));

    switch(ret){
    case 0:
	break;
    case KRB5_LIBOS_PWDINTR: /* don't print anything if it was just C-c:ed */
	exit(1);
    case KRB5KRB_AP_ERR_BAD_INTEGRITY:
    case KRB5KRB_AP_ERR_MODIFIED:
    case KRB5KDC_ERR_PREAUTH_FAILED:
	krb5_errx(context, 1, N_("Password incorrect", ""));
	break;
    case KRB5KRB_AP_ERR_V4_REPLY:
	krb5_errx(context, 1, N_("Looks like a Kerberos 4 reply", ""));
	break;
    default:
	krb5_err(context, 1, ret, "krb5_get_init_creds");
    }

    if(ticket_life != 0) {
	if(abs(cred.times.endtime - cred.times.starttime - ticket_life) > 30) {
	    char life[64];
	    unparse_time_approx(cred.times.endtime - cred.times.starttime,
				life, sizeof(life));
	    krb5_warnx(context, N_("NOTICE: ticket lifetime is %s", ""), life);
	}
    }
    if(renew_life) {
	if(abs(cred.times.renew_till - cred.times.starttime - renew) > 30) {
	    char life[64];
	    unparse_time_approx(cred.times.renew_till - cred.times.starttime,
				life, sizeof(life));
	    krb5_warnx(context,
		       N_("NOTICE: ticket renewable lifetime is %s", ""),
		       life);
	}
    }

    ret = krb5_cc_new_unique(context, krb5_cc_get_type(context, ccache),
			     NULL, &tempccache);
    if (ret)
	krb5_err (context, 1, ret, "krb5_cc_new_unique");

    ret = krb5_cc_initialize (context, tempccache, cred.client);
    if (ret)
	krb5_err (context, 1, ret, "krb5_cc_initialize");

    ret = krb5_cc_store_cred (context, tempccache, &cred);
    if (ret)
	krb5_err (context, 1, ret, "krb5_cc_store_cred");

    krb5_free_cred_contents (context, &cred);

    ret = krb5_cc_move(context, tempccache, ccache);
    if (ret)
	krb5_err (context, 1, ret, "krb5_cc_move");

    if (switch_cache_flags)
	krb5_cc_switch(context, ccache);

#ifndef NO_NTLM
    if (ntlm_domain && ntlmkey.data)
	store_ntlmkey(context, ccache, ntlm_domain, &ntlmkey);
#endif

    if (ok_as_delegate_flag || windows_flag || use_referrals_flag) {
	unsigned char d = 0;
	krb5_data data;

	if (ok_as_delegate_flag || windows_flag)
	    d |= 1;
	if (use_referrals_flag || windows_flag)
	    d |= 2;

	data.length = 1;
	data.data = &d;

	krb5_cc_set_config(context, ccache, NULL, "realm-config", &data);
    }


    if (enctype)
	free(enctype);

    return 0;
}

static time_t
ticket_lifetime(krb5_context context, krb5_ccache cache,
		krb5_principal client, const char *server)
{
    krb5_creds in_cred, *cred;
    krb5_error_code ret;
    time_t timeout;

    memset(&in_cred, 0, sizeof(in_cred));

    ret = krb5_cc_get_principal(context, cache, &in_cred.client);
    if(ret) {
	krb5_warn(context, ret, "krb5_cc_get_principal");
	return 0;
    }
    ret = get_server(context, in_cred.client, server, &in_cred.server);
    if(ret) {
	krb5_free_principal(context, in_cred.client);
	krb5_warn(context, ret, "get_server");
	return 0;
    }

    ret = krb5_get_credentials(context, KRB5_GC_CACHED,
			       cache, &in_cred, &cred);
    krb5_free_principal(context, in_cred.client);
    krb5_free_principal(context, in_cred.server);
    if(ret) {
	krb5_warn(context, ret, "krb5_get_credentials");
	return 0;
    }
    timeout = cred->times.endtime - cred->times.starttime;
    if (timeout < 0)
	timeout = 0;
    krb5_free_creds(context, cred);
    return timeout;
}

struct renew_ctx {
    krb5_context context;
    krb5_ccache  ccache;
    krb5_principal principal;
    krb5_deltat ticket_life;
};

static time_t
renew_func(void *ptr)
{
    struct renew_ctx *ctx = ptr;
    krb5_error_code ret;
    time_t expire;
    int new_tickets = 0;

    if (renewable_flag) {
	ret = renew_validate(ctx->context, renewable_flag, validate_flag,
			     ctx->ccache, server_str, ctx->ticket_life);
	if (ret)
	    new_tickets = 1;
    } else
	new_tickets = 1;

    if (new_tickets)
	get_new_tickets(ctx->context, ctx->principal,
			ctx->ccache, ctx->ticket_life, 0);

#ifndef NO_AFS
    if(do_afslog && k_hasafs())
	krb5_afslog(ctx->context, ctx->ccache, NULL, NULL);
#endif

    expire = ticket_lifetime(ctx->context, ctx->ccache, ctx->principal,
			     server_str) / 2;
    return expire + 1;
}

int
main (int argc, char **argv)
{
    krb5_error_code ret;
    krb5_context context;
    krb5_ccache  ccache;
    krb5_principal principal;
    int optidx = 0;
    krb5_deltat ticket_life = 0;
    int parseflags = 0;

    setprogname (argv[0]);

    setlocale (LC_ALL, "");
    bindtextdomain ("heimdal_kuser", HEIMDAL_LOCALEDIR);
    textdomain("heimdal_kuser");

    ret = krb5_init_context (&context);
    if (ret == KRB5_CONFIG_BADFORMAT)
	errx (1, "krb5_init_context failed to parse configuration file");
    else if (ret)
	errx(1, "krb5_init_context failed: %d", ret);

    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optidx))
	usage(1);

    if (help_flag)
	usage (0);

    if(version_flag) {
	print_version(NULL);
	exit(0);
    }

    argc -= optidx;
    argv += optidx;

    if (canonicalize_flag || enterprise_flag)
	parseflags |= KRB5_PRINCIPAL_PARSE_ENTERPRISE;

    if (pk_enterprise_flag) {
	ret = krb5_pk_enterprise_cert(context, pk_user_id,
				      argv[0], &principal,
				      &ent_user_id);
	if (ret)
	    krb5_err(context, 1, ret, "krb5_pk_enterprise_certs");

	pk_user_id = NULL;

    } else if (anonymous_flag) {

	ret = krb5_make_principal(context, &principal, argv[0],
				  KRB5_WELLKNOWN_NAME, KRB5_ANON_NAME,
				  NULL);
	if (ret)
	    krb5_err(context, 1, ret, "krb5_make_principal");
	krb5_principal_set_type(context, principal, KRB5_NT_WELLKNOWN);

    } else {
	if (argv[0]) {
	    ret = krb5_parse_name_flags (context, argv[0], parseflags,
					 &principal);
	    if (ret)
		krb5_err (context, 1, ret, "krb5_parse_name");
	} else {
	    ret = krb5_get_default_principal (context, &principal);
	    if (ret)
		krb5_err (context, 1, ret, "krb5_get_default_principal");
	}
    }

    if(fcache_version)
	krb5_set_fcache_version(context, fcache_version);

    if(renewable_flag == -1)
	/* this seems somewhat pointless, but whatever */
	krb5_appdefault_boolean(context, "kinit",
				krb5_principal_get_realm(context, principal),
				"renewable", FALSE, &renewable_flag);
    if(do_afslog == -1)
	krb5_appdefault_boolean(context, "kinit",
				krb5_principal_get_realm(context, principal),
				"afslog", TRUE, &do_afslog);

    if(cred_cache)
	ret = krb5_cc_resolve(context, cred_cache, &ccache);
    else {
	if(argc > 1) {
	    char s[1024];
	    ret = krb5_cc_new_unique(context, NULL, NULL, &ccache);
	    if(ret)
		krb5_err(context, 1, ret, "creating cred cache");
	    snprintf(s, sizeof(s), "%s:%s",
		     krb5_cc_get_type(context, ccache),
		     krb5_cc_get_name(context, ccache));
	    setenv("KRB5CCNAME", s, 1);
	} else {
	    ret = krb5_cc_cache_match(context, principal, &ccache);
	    if (ret) {
		const char *type;
		ret = krb5_cc_default (context, &ccache);
		if (ret)
		    krb5_err (context, 1, ret, N_("resolving credentials cache", ""));

		/*
		 * Check if the type support switching, and we do,
		 * then do that instead over overwriting the current
		 * default credential
		 */
		type = krb5_cc_get_type(context, ccache);
		if (krb5_cc_support_switch(context, type)) {
		    krb5_cc_close(context, ccache);
		    ret = krb5_cc_new_unique(context, type, NULL, &ccache);
		}
	    }
	}
    }
    if (ret)
	krb5_err (context, 1, ret, N_("resolving credentials cache", ""));

#ifndef NO_AFS
    if(argc > 1 && k_hasafs ())
	k_setpag();
#endif

    if (lifetime) {
	int tmp = parse_time (lifetime, "s");
	if (tmp < 0)
	    errx (1, N_("unparsable time: %s", ""), lifetime);

	ticket_life = tmp;
    }

    if(addrs_flag == 0 && extra_addresses.num_strings > 0)
	krb5_errx(context, 1,
		  N_("specifying both extra addresses and "
		     "no addresses makes no sense", ""));
    {
	int i;
	krb5_addresses addresses;
	memset(&addresses, 0, sizeof(addresses));
	for(i = 0; i < extra_addresses.num_strings; i++) {
	    ret = krb5_parse_address(context, extra_addresses.strings[i],
				     &addresses);
	    if (ret == 0) {
		krb5_add_extra_addresses(context, &addresses);
		krb5_free_addresses(context, &addresses);
	    }
	}
	free_getarg_strings(&extra_addresses);
    }

    if(renew_flag || validate_flag) {
	ret = renew_validate(context, renew_flag, validate_flag,
			     ccache, server_str, ticket_life);
	exit(ret != 0);
    }

    get_new_tickets(context, principal, ccache, ticket_life, 1);

#ifndef NO_AFS
    if(do_afslog && k_hasafs())
	krb5_afslog(context, ccache, NULL, NULL);
#endif
    if(argc > 1) {
	struct renew_ctx ctx;
	time_t timeout;

	timeout = ticket_lifetime(context, ccache, principal, server_str) / 2;

	ctx.context = context;
	ctx.ccache = ccache;
	ctx.principal = principal;
	ctx.ticket_life = ticket_life;

	ret = simple_execvp_timed(argv[1], argv+1,
				  renew_func, &ctx, timeout);
#define EX_NOEXEC	126
#define EX_NOTFOUND	127
	if(ret == EX_NOEXEC)
	    krb5_warnx(context, N_("permission denied: %s", ""), argv[1]);
	else if(ret == EX_NOTFOUND)
	    krb5_warnx(context, N_("command not found: %s", ""), argv[1]);

	krb5_cc_destroy(context, ccache);
#ifndef NO_AFS
	if(k_hasafs())
	    k_unlog();
#endif
    } else {
	krb5_cc_close (context, ccache);
	ret = 0;
    }
    krb5_free_principal(context, principal);
    krb5_free_context (context);
    return ret;
}
@


1.11
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.10
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 1
a6 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d8 3
a10 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d12 2
a13 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d15 3
a17 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d19 15
a33 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
a36 1
RCSID("$KTH: kinit.c,v 1.121 2005/06/14 00:14:43 lha Exp $");
d38 2
a39 2
#ifndef KRB4
#include "krb5-v4compat.h"
d42 3
a44 5
struct krb5_pk_identity;
struct krb5_pk_cert;
struct ContentInfo;
struct _krb5_krb_auth_data;
#include "krb5-private.h"
d54 1
a54 1
int addrs_flag		= 1;
d59 1
a59 1
char *server		= NULL;
d62 1
a66 2
int get_v4_tgt		= -1;
int convert_524		= 0;
d68 1
d70 2
d73 9
a81 1
int pk_use_dh		= -1;
a82 1
static char *krb4_cc_name;
d85 1
a85 1
    /* 
d92 5
a96 1
     * 5: 
a97 6
    { "524init", 	'4', arg_flag, &get_v4_tgt,
      "obtain version 4 TGT" },

    { "524convert", 	'9', arg_flag, &convert_524,
      "only convert ticket to version 4" },

d99 1
a99 1
      "obtain afs tokens"  },
d102 1
a102 1
      "credentials cache", "cachename" },
d104 5
a108 2
    { "forwardable",	'f', arg_flag, &forwardable_flag,
      "get forwardable tickets"},
d111 1
a111 1
      "keytab to use", "keytabname" },
d114 1
a114 1
      "lifetime of tickets", "time"},
d117 1
a117 1
      "get proxiable tickets" },
d120 1
a120 1
      "renew TGT" },
d123 1
a123 1
      "get renewable tickets" },
d126 1
a126 1
      "renewable lifetime of tickets", "time" },
d128 2
a129 2
    { "server", 	'S', arg_string, &server,
      "server to get ticket for", "principal" },
d132 1
a132 1
      "when ticket gets valid", "time" },
d135 1
a135 1
      "get key from keytab" },
d138 1
a138 1
      "validate TGT" },
d141 1
a141 1
      "encryption types to use", "enctypes" },
d144 1
a144 1
      "file cache version to create" },
d147 1
a147 1
      "request a ticket with no addresses" },
d150 1
a150 1
      "include these extra addresses", "addresses" },
d153 1
a153 1
      "request an anonymous ticket" },
d156 1
a156 1
      "request a Windows PAC" },
d158 2
a159 4
#ifdef PKINIT
    {  "pk-user",	'C',	arg_string,	&pk_user_id,
       "principal's public/private/certificate identifier",
       "id" },
d161 2
a162 2
    {  "x509-anchors",	'D',  arg_string, &pk_x509_anchors,
       "directory with CA certificates", "directory" },
d164 5
a168 6
    {  "pkinit-use-dh",       0,  arg_flag, &pk_use_dh,
       "make pkinit use DH" },
#endif
    { "version", 	0,   arg_flag, &version_flag },
    { "help",		0,   arg_flag, &help_flag }
};
d170 2
a171 9
static void
usage (int ret)
{
    arg_printusage (args,
		    sizeof(args)/sizeof(*args),
		    NULL,
		    "[principal [command]]");
    exit (ret);
}
d173 2
a174 2
#ifdef KRB4
/* for when the KDC tells us it's a v4 one, we try to talk that */
d176 7
a182 10
static int
key_to_key(const char *user,
	   char *instance,
	   const char *realm,
	   const void *arg,
	   des_cblock *key)
{
    memcpy(key, arg, sizeof(des_cblock));
    return 0;
}
d184 2
a185 60
static int
do_v4_fallback (krb5_context context,
		const krb5_principal principal,
		int lifetime,
		int use_srvtab, const char *srvtab_str,
		const char *passwd)
{
    int ret;
    krb_principal princ;
    des_cblock key;
    krb5_error_code kret;

    if (lifetime == 0)
	lifetime = DEFAULT_TKT_LIFE;
    else
	lifetime = krb_time_to_life (0, lifetime);

    kret = krb5_524_conv_principal (context, principal,
				    princ.name,
				    princ.instance,
				    princ.realm);
    if (kret) {
	krb5_warn (context, kret, "krb5_524_conv_principal");
	return 1;
    }

    if (use_srvtab || srvtab_str) {
	if (srvtab_str == NULL)
	    srvtab_str = KEYFILE;

	ret = read_service_key (princ.name, princ.instance, princ.realm,
				0, srvtab_str, (char *)&key);
	if (ret) {
	    warnx ("read_service_key %s: %s", srvtab_str,
		   krb_get_err_text (ret));
	    return 1;
	}
	ret = krb_get_in_tkt (princ.name, princ.instance, princ.realm,
			      KRB_TICKET_GRANTING_TICKET, princ.realm,
			      lifetime, key_to_key, NULL, key);
    } else {
	ret = krb_get_pw_in_tkt(princ.name, princ.instance, princ.realm, 
				KRB_TICKET_GRANTING_TICKET, princ.realm, 
				lifetime, passwd);
    }
    memset (key, 0, sizeof(key));
    if (ret) {
	warnx ("%s", krb_get_err_text(ret));
	return 1;
    }
    if (do_afslog && k_hasafs()) {
	if ((ret = krb_afslog(NULL, NULL)) != 0 && ret != KDC_PR_UNKNOWN) {
	    if(ret > 0)
		warnx ("%s", krb_get_err_text(ret));
	    else
		warnx ("failed to store AFS token");
	}
    }
    return 0;
}
d187 2
d190 2
a191 3
/*
 * the special version of get_default_principal that takes v4 into account
 */
d193 2
a194 32
static krb5_error_code
kinit_get_default_principal (krb5_context context,
			     krb5_principal *princ)
{
    krb5_error_code ret;
    krb5_ccache id;
    krb_principal v4_princ;
    int kret;

    ret = krb5_cc_default (context, &id);
    if (ret == 0) {
	ret = krb5_cc_get_principal (context, id, princ);
	krb5_cc_close (context, id);
	if (ret == 0)
	    return 0;
    }

    kret = krb_get_tf_fullname (tkt_string(),
				v4_princ.name,
				v4_princ.instance,
				v4_princ.realm);
    if (kret == KSUCCESS) {
	ret = krb5_425_conv_principal (context,
				       v4_princ.name,
				       v4_princ.instance,
				       v4_princ.realm,
				       princ);
	if (ret == 0)
	    return 0;
    }
    return krb5_get_default_principal (context, princ);
}
d196 3
a198 1
#else /* !KRB4 */
d200 2
a201 3
static krb5_error_code
kinit_get_default_principal (krb5_context context,
			     krb5_principal *princ)
d203 7
a209 1
    return krb5_get_default_principal (context, princ);
a211 2
#endif /* !KRB4 */

d218 1
a218 1
    krb5_realm *client_realm;
d222 3
a224 46
    client_realm = krb5_princ_realm (context, client);
    return krb5_make_principal(context, princ, *client_realm,
			       KRB5_TGS_NAME, *client_realm, NULL);
}

static krb5_error_code
do_524init(krb5_context context, krb5_ccache ccache, 
	   krb5_creds *creds, const char *server)
{
    krb5_error_code ret;

    struct credentials c;
    krb5_creds in_creds, *real_creds;

    if(creds != NULL)
	real_creds = creds;
    else {
	krb5_principal client;
	krb5_cc_get_principal(context, ccache, &client);
	memset(&in_creds, 0, sizeof(in_creds));
	ret = get_server(context, client, server, &in_creds.server);
	if(ret) {
	    krb5_free_principal(context, client);
	    return ret;
	}
	in_creds.client = client;
	ret = krb5_get_credentials(context, 0, ccache, &in_creds, &real_creds);
	krb5_free_principal(context, client);
	krb5_free_principal(context, in_creds.server);
	if(ret)
	    return ret;
    }
    ret = krb524_convert_creds_kdc_ccache(context, ccache, real_creds, &c);
    if(ret)
	krb5_warn(context, ret, "converting creds");
    else {
	krb5_error_code tret = _krb5_krb_tf_setup(context, &c, NULL, 0);
	if(tret)
	    krb5_warn(context, tret, "saving v4 creds");
    }

    if(creds == NULL)
	krb5_free_creds(context, real_creds);
    memset(&c, 0, sizeof(c));

    return ret;
d228 1
a228 1
renew_validate(krb5_context context, 
d231 1
a231 1
	       krb5_ccache cache, 
d236 1
a236 1
    krb5_creds in, *out;
d251 9
d263 1
d266 3
d271 4
a274 1
    if (anonymous_flag != -1)
d279 6
d306 1
a306 2
	if(get_v4_tgt)
	    do_524init(context, cache, out, NULL);
d309 1
d322 2
d325 24
a348 1
get_new_tickets(krb5_context context, 
a355 1
    krb5_addresses no_addrs;
d360 56
a415 1
    char *renewstr = NULL;
d422 3
a424 3
    
    krb5_get_init_creds_opt_set_default_flags(context, "kinit", 
					      /* XXX */principal->realm, opt);
d430 1
a430 1
    if(anonymous_flag != -1)
d433 1
a433 1
	krb5_get_init_creds_opt_set_pac_request(context, opt, 
d435 5
a439 4
    if (pk_user_id) {
	int flags = 0;
	if (pk_use_dh == 1)
	    flags |= 1;
a443 1
						 flags,
d446 5
a450 1
						 NULL);
d453 2
d457 3
a459 6
    if (!addrs_flag) {
	no_addrs.len = 0;
	no_addrs.val = NULL;

	krb5_get_init_creds_opt_set_address_list (opt, &no_addrs);
    }
d469 1
a469 1
	
d479 1
a479 1
	    errx (1, "unparsable time: %s", start_str);
a484 1
	krb5_enctype *enctype = NULL;
d486 1
d491 2
a492 2
	    ret = krb5_string_to_enctype(context, 
					 etype_str.strings[i], 
d497 1
a497 1
	krb5_get_init_creds_opt_set_etype_list(opt, enctype, 
d514 1
a514 1
					  server,
d517 1
a517 1
    } else if (pk_user_id) {
d521 1
a521 1
					    NULL,
d525 1
a525 1
					    server,
d529 1
a529 1
	krb5_get_init_creds_opt_free(opt);
a531 1
	char *p, *prompt;
d533 12
a544 7
	krb5_unparse_name (context, principal, &p);
	asprintf (&prompt, "%s's Password: ", p);
	free (p);

	if (UI_UTIL_read_pw_string(passwd, sizeof(passwd)-1, prompt, 0)){
	    memset(passwd, 0, sizeof(passwd));
	    exit(1);
d547 1
a547 2
	free (prompt);
	
d555 1
a555 1
					    server,
d558 4
a561 13
    krb5_get_init_creds_opt_free(opt);
#ifdef KRB4
    if (ret == KRB5KRB_AP_ERR_V4_REPLY || ret == KRB5_KDC_UNREACH) {
	int exit_val;

	exit_val = do_v4_fallback (context, principal, ticket_life,
				   use_keytab, keytab_str, passwd);
	get_v4_tgt = 0;
	do_afslog  = 0;
	memset(passwd, 0, sizeof(passwd));
	if (exit_val == 0 || ret == KRB5KRB_AP_ERR_V4_REPLY)
	    return exit_val;
    }
d572 5
a576 1
	krb5_errx(context, 1, "Password incorrect");
d585 1
a585 1
	    unparse_time_approx(cred.times.endtime - cred.times.starttime, 
d587 1
a587 1
	    krb5_warnx(context, "NOTICE: ticket lifetime is %s", life);
d593 1
a593 1
	    unparse_time_approx(cred.times.renew_till - cred.times.starttime, 
d595 2
a596 1
	    krb5_warnx(context, "NOTICE: ticket renewable lifetime is %s", 
d601 6
a606 1
    ret = krb5_cc_initialize (context, ccache, cred.client);
d609 2
a610 2
    
    ret = krb5_cc_store_cred (context, ccache, &cred);
d616 31
d651 1
a651 1
ticket_lifetime(krb5_context context, krb5_ccache cache, 
d700 1
d702 7
d710 2
a711 4
    ret = renew_validate(ctx->context, renewable_flag, validate_flag,
			     ctx->ccache, server, ctx->ticket_life);
    if (ret)
	get_new_tickets(ctx->context, ctx->principal, 
d714 1
a714 2
    if(get_v4_tgt || convert_524)
	do_524init(ctx->context, ctx->ccache, NULL, server);
d717 1
d720 1
a720 1
			     server) / 2;
d731 1
a731 1
    int optind = 0;
d733 7
d746 2
a747 2
  
    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optind))
d749 1
a749 1
    
d758 16
a773 2
    argc -= optind;
    argv += optind;
d775 3
a777 2
    if (argv[0]) {
	ret = krb5_parse_name (context, argv[0], &principal);
d779 3
a781 1
	    krb5_err (context, 1, ret, "krb5_parse_name");
d783 10
a792 3
	ret = kinit_get_default_principal (context, &principal);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_get_default_principal");
d798 11
a808 1
    if(cred_cache) 
d813 1
a813 1
	    ret = krb5_cc_gen_new(context, &krb5_fcc_ops, &ccache);
d820 17
a836 10
	    if (get_v4_tgt) {
		int fd;
		if (asprintf(&krb4_cc_name, "%s_XXXXXXXXXXX", TKT_ROOT) < 0)
		    krb5_errx(context, 1, "out of memory");
		if((fd = mkstemp(krb4_cc_name)) >= 0) {
		    close(fd);
		    setenv("KRBTKFILE", krb4_cc_name, 1);
		} else {
		    free(krb4_cc_name);
		    krb4_cc_name = NULL;
d839 1
a839 2
	} else
	    ret = krb5_cc_default (context, &ccache);
d842 1
a842 1
	krb5_err (context, 1, ret, "resolving credentials cache");
d844 1
d847 1
d852 1
a852 1
	    errx (1, "unparsable time: %s", lifetime);
a855 18
    if(renewable_flag == -1)
	/* this seems somewhat pointless, but whatever */
	krb5_appdefault_boolean(context, "kinit",
				krb5_principal_get_realm(context, principal),
				"renewable", FALSE, &renewable_flag);
    if(get_v4_tgt == -1)
	krb5_appdefault_boolean(context, "kinit", 
				krb5_principal_get_realm(context, principal), 
				"krb4_get_tickets", FALSE, &get_v4_tgt);
    if(do_afslog == -1)
	krb5_appdefault_boolean(context, "kinit", 
				krb5_principal_get_realm(context, principal), 
				"afslog", TRUE, &do_afslog);

    if (pk_x509_anchors == NULL)
	krb5_appdefault_string(context, "kinit",
			       krb5_principal_get_realm(context, principal), 
			       "pkinit-anchors", NULL, &pk_x509_anchors);
d857 4
a860 10
#ifdef PKINIT
    if(pk_use_dh == -1)
	krb5_appdefault_boolean(context, "kinit", 
				krb5_principal_get_realm(context, principal), 
				"pkinit-use-dh", FALSE, &pk_use_dh);
#endif

    if(!addrs_flag && extra_addresses.num_strings > 0)
	krb5_errx(context, 1, "specifying both extra addresses and "
		  "no addresses makes no sense");
d866 1
a866 1
	    ret = krb5_parse_address(context, extra_addresses.strings[i], 
d877 2
a878 2
	ret = renew_validate(context, renew_flag, validate_flag, 
			     ccache, server, ticket_life);
d882 1
a882 2
    if(!convert_524)
	get_new_tickets(context, principal, ccache, ticket_life, 1);
d884 1
a884 2
    if(get_v4_tgt || convert_524)
	do_524init(context, ccache, NULL, server);
d887 1
d892 1
a892 1
	timeout = ticket_lifetime(context, ccache, principal, server) / 2;
d899 1
a899 1
	ret = simple_execvp_timed(argv[1], argv+1, 
d904 1
a904 1
	    krb5_warnx(context, "permission denied: %s", argv[1]);
d906 2
a907 2
	    krb5_warnx(context, "command not found: %s", argv[1]);
	
d909 1
a909 1
	_krb5_krb_dest_tkt(context, krb4_cc_name);
d912 1
@


1.9
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d35 11
a45 1
RCSID("$KTH: kinit.c,v 1.90.4.5 2004/06/21 08:17:06 lha Exp $");
d51 1
a66 1
#ifdef KRB4
d68 1
a68 2
int convert_524;
#endif
d70 5
d77 9
a85 1
#ifdef KRB4
d88 1
a88 1
    
d91 1
a91 1
#endif
d137 1
a137 1
    { "addresses",	0,   arg_negative_flag,	&addrs_flag,
d146 14
a312 1
#ifdef KRB4
d318 2
a319 1
    CREDENTIALS c;
d344 1
a344 1
	int tret = tf_setup(&c, c.pname, c.pinst);
d346 1
a346 1
	    krb5_warnx(context, "saving v4 creds: %s", krb_get_err_text(tret));
a354 1
#endif
a411 1
#ifdef KRB4
a414 1
#endif
d425 1
a425 1
    krb5_free_creds_contents(context, &in);
d433 2
a434 1
		krb5_deltat ticket_life)
d437 1
a437 1
    krb5_get_init_creds_opt opt;
d443 1
d447 3
a449 1
    krb5_get_init_creds_opt_init (&opt);
d452 1
a452 1
					      /* XXX */principal->realm, &opt);
d455 1
a455 1
	krb5_get_init_creds_opt_set_forwardable (&opt, forwardable_flag);
d457 1
a457 1
	krb5_get_init_creds_opt_set_proxiable (&opt, proxiable_flag);
d459 19
a477 1
	krb5_get_init_creds_opt_set_anonymous (&opt, anonymous_flag);
d483 1
a483 1
	krb5_get_init_creds_opt_set_address_list (&opt, &no_addrs);
d487 5
a491 3
	renew_life = "1 month";
    if(renew_life) {
	renew = parse_time (renew_life, "s");
d493 3
a495 3
	    errx (1, "unparsable time: %s", renew_life);

	krb5_get_init_creds_opt_set_renew_life (&opt, renew);
d499 1
a499 1
	krb5_get_init_creds_opt_set_tkt_life (&opt, ticket_life);
d522 1
a522 1
	krb5_get_init_creds_opt_set_etype_list(&opt, enctype, 
d540 1
a540 1
					  &opt);
d542 14
d563 1
a563 1
	if (des_read_pw_string(passwd, sizeof(passwd)-1, prompt, 0)){
d569 1
a569 1

d578 1
a578 1
					    &opt);
d580 1
d611 3
a613 3
	    char life[32];
	    unparse_time(cred.times.endtime - cred.times.starttime, 
			 life, sizeof(life));
d617 1
a617 1
    if(renew != 0) {
d619 3
a621 3
	    char life[32];
	    unparse_time(cred.times.renew_till - cred.times.starttime, 
			 life, sizeof(life));
d635 1
a635 1
    krb5_free_creds_contents (context, &cred);
d640 68
d719 3
a721 1
    if (ret)
d763 1
a763 2
#ifdef KRB4
	    {
d765 3
a767 2
		snprintf(s, sizeof(s), "%s_XXXXXXXXXX", TKT_ROOT);
		if((fd = mkstemp(s)) >= 0) {
d769 4
a772 1
		    setenv("KRBTKFILE", s, 1);
a774 1
#endif
d781 1
a781 1
    if (argc > 1 && k_hasafs ())
d791 5
a795 1
#ifdef KRB4
d798 2
a799 3
				(krb5_realm)krb5_principal_get_realm(context, principal), 
				"krb4_get_tickets", TRUE, &get_v4_tgt);
#endif
d805 12
a834 1
    
a840 1
#ifdef KRB4
d842 1
a842 2
#endif
	get_new_tickets(context, principal, ccache, ticket_life);
d844 1
a844 2
#ifdef KRB4
    if(get_v4_tgt)
a845 1
#endif
d849 19
a867 17
	pid_t pid = fork();
	if(pid == 0) {
	    execvp(argv[1], argv+1);
	    exit(1);
	}
	while(1) {
	    int status;
	    while(waitpid(pid, &status, 0) < 0)
		if(errno != EINTR)
		    break;
	    if(WIFSTOPPED(status))
		continue;
	    if(WIFEXITED(status))
		break;
	    if(WIFSIGNALED(status))
		break;
	}
d869 1
a869 3
#ifdef KRB4
	dest_tkt();
#endif
@


1.8
log
@bump mktemp randomness from 6 to 10 X's
@
text
@d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.90.4.1 2003/05/08 18:58:37 lha Exp $");
d293 2
a294 2
	krb5_free_principal(context, client);
	if(ret)
d296 2
d299 1
d431 2
d439 1
a439 3
    } else if (renewable_flag == 1)
	krb5_get_init_creds_opt_set_renew_life (&opt, 1 << 30);

a627 2
		    if (k_hasafs ())
			k_setpag();
d637 3
d718 1
a718 1
    } else 
d720 2
d724 1
a724 1
    return 0;
@


1.7
log
@Merge with heimdal-0.6
@
text
@d621 1
a621 1
		snprintf(s, sizeof(s), "%s_XXXXXX", TKT_ROOT);
@


1.6
log
@Merge 0.6rc1
@
text
@d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.90 2002/09/09 22:17:53 joda Exp $");
d55 1
a57 1
int do_afslog		= -1;
d69 1
a69 1
    
d72 1
a72 1
#endif
d373 1
a374 1
    if(ret == 0 && server == NULL) {
d378 1
a378 1

a381 1
#endif
d648 1
a652 1
#endif
d687 1
a689 1
#endif
d711 1
a713 1
#endif
@


1.5
log
@-Wall -Werror sweep on i386.
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.85 2001/09/02 16:57:32 joda Exp $");
d45 1
d118 3
d193 3
a195 3
	ret = krb_get_pw_in_tkt2(princ.name, princ.instance, princ.realm, 
				 KRB_TICKET_GRANTING_TICKET, princ.realm, 
				 lifetime, passwd, &key);
d293 1
d297 1
d406 1
d430 2
a431 2
	int tmp = parse_time (renew_life, "s");
	if (tmp < 0)
d434 1
a434 1
	krb5_get_init_creds_opt_set_renew_life (&opt, tmp);
d438 1
d535 18
d649 4
d654 18
@


1.4
log
@Remove all uses of setprogname() and getprogname() in kerberosV subtree.
@
text
@d621 1
a621 1
				krb5_principal_get_realm(context, principal), 
@


1.3
log
@Merge heimdal-0.4e
@
text
@a549 2
    setprogname (argv[0]);
    
@


1.2
log
@Remove the need for simple_exec.c
@
text
@d35 98
a132 1
RCSID("$KTH: kinit.c,v 1.75 2001/05/07 21:08:15 assar Exp $");
d153 1
a153 1
		char *passwd, size_t passwd_size)
a192 1
    memset (passwd, 0, passwd_size);
d198 1
a198 1
    if (k_hasafs()) {
d258 14
a271 22
int forwardable_flag	= -1;
int proxiable_flag	= -1;
int renewable_flag	= -1;
int renew_flag		= 0;
int validate_flag	= 0;
int version_flag	= 0;
int help_flag		= 0;
int addrs_flag		= 1;
int anonymous_flag	= 0;
char *lifetime 		= NULL;
char *renew_life	= NULL;
char *server		= NULL;
char *cred_cache	= NULL;
char *start_str		= NULL;
struct getarg_strings etype_str;
int use_keytab		= 0;
char *keytab_str	= NULL;
#ifdef KRB4
extern int do_afslog;
extern int get_v4_tgt;
#endif
int fcache_version;
a272 1
static struct getargs args[] = {
d274 7
a280 8
    { "524init", 	'4', arg_flag, &get_v4_tgt,
      "obtain version 4 TGT" },
    
    { "afslog", 	0  , arg_flag, &do_afslog,
      "obtain afs tokens"  },
#endif
    { "cache", 		'c', arg_string, &cred_cache,
      "credentials cache", "cachename" },
d282 21
a302 5
    { "forwardable",	'f', arg_flag, &forwardable_flag,
      "get forwardable tickets"},

    { "keytab",         't', arg_string, &keytab_str,
      "keytab to use", "keytabname" },
d304 3
a306 2
    { "lifetime",	'l', arg_string, &lifetime,
      "lifetime of tickets", "time"},
d308 1
a308 48
    { "proxiable",	'p', arg_flag, &proxiable_flag,
      "get proxiable tickets" },

    { "renew",          'R', arg_flag, &renew_flag,
      "renew TGT" },

    { "renewable",	0,   arg_flag, &renewable_flag,
      "get renewable tickets" },

    { "renewable-life",	'r', arg_string, &renew_life,
      "renewable lifetime of tickets", "time" },

    { "server", 	'S', arg_string, &server,
      "server to get ticket for", "principal" },

    { "start-time",	's', arg_string, &start_str,
      "when ticket gets valid", "time" },

    { "use-keytab",     'k', arg_flag, &use_keytab,
      "get key from keytab" },

    { "validate",	'v', arg_flag, &validate_flag,
      "validate TGT" },

    { "enctypes",	'e', arg_strings, &etype_str,
      "encryption types to use", "enctypes" },

    { "fcache-version", 0,   arg_integer, &fcache_version,
      "file cache version to create" },

    { "addresses",	0,   arg_negative_flag,	&addrs_flag,
      "request a ticket with no addresses" },

    { "anonymous",	0,   arg_flag,	&anonymous_flag,
      "request an anonymous ticket" },

    { "version", 	0,   arg_flag, &version_flag },
    { "help",		0,   arg_flag, &help_flag }
};

static void
usage (int ret)
{
    arg_printusage (args,
		    sizeof(args)/sizeof(*args),
		    NULL,
		    "[principal [command]]");
    exit (ret);
d310 1
d331 4
a334 15
    if(server) {
	ret = krb5_parse_name(context, server, &in.server);
	if(ret) {
	    krb5_warn(context, ret, "krb5_parse_name");
	    goto out;
	}
    } else {
	krb5_realm *client_realm = krb5_princ_realm (context, in.client);

	ret = krb5_make_principal(context, &in.server, *client_realm,
				  KRB5_TGS_NAME, *client_realm, NULL);
	if(ret) {
	    krb5_warn(context, ret, "krb5_make_principal");
	    goto out;
	}
d366 12
d388 5
a392 2
int
main (int argc, char **argv)
a394 5
    krb5_context context;
    krb5_ccache  ccache;
    krb5_principal principal;
    krb5_creds cred;
    int optind = 0;
a395 2
    krb5_deltat start_time = 0;
    krb5_deltat ticket_life = 0;
d397 1
d399 1
a400 1
    setprogname (argv[0]);
a401 85
    
    ret = krb5_init_context (&context);
    if (ret)
	errx(1, "krb5_init_context failed: %d", ret);
  
    /* XXX no way to figure out if set without explict test */
    if(krb5_config_get_string(context, NULL, "libdefaults", 
			      "forwardable", NULL))
	forwardable_flag = krb5_config_get_bool (context, NULL,
						 "libdefaults",
						 "forwardable",
						 NULL);

#ifdef KRB4
    get_v4_tgt = krb5_config_get_bool_default (context, NULL,
					       get_v4_tgt,
					       "libdefaults",
					       "krb4_get_tickets",
					       NULL);
#endif

    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optind))
	usage(1);
    
    if (help_flag)
	usage (0);

    if(version_flag) {
	print_version(NULL);
	exit(0);
    }

    argc -= optind;
    argv += optind;

    if (argv[0]) {
	ret = krb5_parse_name (context, argv[0], &principal);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_parse_name");
    } else {
	ret = kinit_get_default_principal (context, &principal);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_get_default_principal");
    }

    if(fcache_version)
	krb5_set_fcache_version(context, fcache_version);

    if(cred_cache) 
	ret = krb5_cc_resolve(context, cred_cache, &ccache);
    else {
	if(argc > 1) {
	    char s[1024];
	    ret = krb5_cc_gen_new(context, &krb5_fcc_ops, &ccache);
	    if(ret)
		krb5_err(context, 1, ret, "creating cred cache");
	    snprintf(s, sizeof(s), "%s:%s",
		     krb5_cc_get_type(context, ccache),
		     krb5_cc_get_name(context, ccache));
	    setenv("KRB5CCNAME", s, 1);
#ifdef KRB4
	    snprintf(s, sizeof(s), "%s_XXXXXX", TKT_ROOT);
	    close(mkstemp(s));
	    setenv("KRBTKFILE", s, 1);
	    if (k_hasafs ())
		k_setpag();
#endif
	} else
	    ret = krb5_cc_default (context, &ccache);
    }
    if (ret)
	krb5_err (context, 1, ret, "resolving credentials cache");

    if (lifetime) {
	int tmp = parse_time (lifetime, "s");
	if (tmp < 0)
	    errx (1, "unparsable time: %s", lifetime);

	ticket_life = tmp;
    }
    if(renew_flag || validate_flag) {
	ret = renew_validate(context, renew_flag, validate_flag, 
			     ccache, server, ticket_life);
	exit(ret != 0);
    }
a458 11
#ifdef KRB4
    get_v4_tgt = krb5_config_get_bool_default (context,
					       NULL,
					       get_v4_tgt,
					       "realms",
					       krb5_princ_realm(context,
								principal),
					       "krb4_get_tickets",
					       NULL);
#endif

d504 3
a506 2
				   use_keytab, keytab_str,
				   passwd, sizeof(passwd));
d508 1
a508 2
	if (exit_val == 0 || ret == KRB5KRB_AP_ERR_V4_REPLY) {
	    krb5_free_context (context);
a509 1
	}
a517 1
	memset(passwd, 0, sizeof(passwd));
a520 1
	memset(passwd, 0, sizeof(passwd));
d535 60
d596 36
a631 8
    if(get_v4_tgt) {
	CREDENTIALS c;
	ret = krb524_convert_creds_kdc(context, ccache, &cred, &c);
	if(ret)
	    krb5_warn(context, ret, "converting creds");
	else
	    tf_setup(&c, c.pname, c.pinst);
	memset(&c, 0, sizeof(c));
d633 9
a643 1
    krb5_free_creds_contents (context, &cred);
d671 1
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.69 2001/01/05 16:32:55 joda Exp $");
d251 1
a251 1
		    "[principal]");
d293 6
a298 3
    flags.b.forwardable       = forwardable_flag;
    flags.b.proxiable         = proxiable_flag;
    flags.b.request_anonymous = anonymous_flag;
d345 1
a345 1
    set_progname (argv[0]);
a381 3
    if (argc > 1)
	usage (1);

d397 20
a416 2
    else
	ret = krb5_cc_default (context, &ccache);
d458 1
a458 1
    } else if (renewable_flag)
d591 1
d593 26
a618 2
    krb5_free_creds_contents (context, &cred);
    krb5_cc_close (context, ccache);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.75 2001/05/07 21:08:15 assar Exp $");
d251 1
a251 1
		    "[principal [command]]");
d293 3
a295 6
    if (forwardable_flag != -1)
	flags.b.forwardable       = forwardable_flag;
    if (proxiable_flag != -1)
	flags.b.proxiable         = proxiable_flag;
    if (anonymous_flag != -1)
	flags.b.request_anonymous = anonymous_flag;
d342 1
a342 1
    setprogname (argv[0]);
d379 3
d397 2
a398 20
    else {
	if(argc > 1) {
	    char s[1024];
	    ret = krb5_cc_gen_new(context, &krb5_fcc_ops, &ccache);
	    if(ret)
		krb5_err(context, 1, ret, "creating cred cache");
	    snprintf(s, sizeof(s), "%s:%s",
		     krb5_cc_get_type(context, ccache),
		     krb5_cc_get_name(context, ccache));
	    setenv("KRB5CCNAME", s, 1);
#ifdef KRB4
	    snprintf(s, sizeof(s), "%s_XXXXXX", TKT_ROOT);
	    close(mkstemp(s));
	    setenv("KRBTKFILE", s, 1);
	    if (k_hasafs ())
		k_setpag();
#endif
	} else
	    ret = krb5_cc_default (context, &ccache);
    }
d440 1
a440 1
    } else if (renewable_flag == 1)
d573 1
d575 1
a575 11
#endif
    if(argc > 1) {
	simple_execvp(argv[1], argv+1);
	krb5_cc_destroy(context, ccache);
#ifdef KRB4
	dest_tkt();
	if(k_hasafs())
	    k_unlog();
#endif
    } else 
	krb5_cc_close (context, ccache);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d35 1
a35 98
RCSID("$KTH: kinit.c,v 1.85 2001/09/02 16:57:32 joda Exp $");

int forwardable_flag	= -1;
int proxiable_flag	= -1;
int renewable_flag	= -1;
int renew_flag		= 0;
int validate_flag	= 0;
int version_flag	= 0;
int help_flag		= 0;
int addrs_flag		= 1;
int anonymous_flag	= 0;
char *lifetime 		= NULL;
char *renew_life	= NULL;
char *server		= NULL;
char *cred_cache	= NULL;
char *start_str		= NULL;
struct getarg_strings etype_str;
int use_keytab		= 0;
char *keytab_str	= NULL;
#ifdef KRB4
int get_v4_tgt		= -1;
int do_afslog		= -1;
int convert_524;
#endif
int fcache_version;

static struct getargs args[] = {
#ifdef KRB4
    { "524init", 	'4', arg_flag, &get_v4_tgt,
      "obtain version 4 TGT" },
    
    { "524convert", 	'9', arg_flag, &convert_524,
      "only convert ticket to version 4" },
    
    { "afslog", 	0  , arg_flag, &do_afslog,
      "obtain afs tokens"  },
#endif
    { "cache", 		'c', arg_string, &cred_cache,
      "credentials cache", "cachename" },

    { "forwardable",	'f', arg_flag, &forwardable_flag,
      "get forwardable tickets"},

    { "keytab",         't', arg_string, &keytab_str,
      "keytab to use", "keytabname" },

    { "lifetime",	'l', arg_string, &lifetime,
      "lifetime of tickets", "time"},

    { "proxiable",	'p', arg_flag, &proxiable_flag,
      "get proxiable tickets" },

    { "renew",          'R', arg_flag, &renew_flag,
      "renew TGT" },

    { "renewable",	0,   arg_flag, &renewable_flag,
      "get renewable tickets" },

    { "renewable-life",	'r', arg_string, &renew_life,
      "renewable lifetime of tickets", "time" },

    { "server", 	'S', arg_string, &server,
      "server to get ticket for", "principal" },

    { "start-time",	's', arg_string, &start_str,
      "when ticket gets valid", "time" },

    { "use-keytab",     'k', arg_flag, &use_keytab,
      "get key from keytab" },

    { "validate",	'v', arg_flag, &validate_flag,
      "validate TGT" },

    { "enctypes",	'e', arg_strings, &etype_str,
      "encryption types to use", "enctypes" },

    { "fcache-version", 0,   arg_integer, &fcache_version,
      "file cache version to create" },

    { "addresses",	0,   arg_negative_flag,	&addrs_flag,
      "request a ticket with no addresses" },

    { "anonymous",	0,   arg_flag,	&anonymous_flag,
      "request an anonymous ticket" },

    { "version", 	0,   arg_flag, &version_flag },
    { "help",		0,   arg_flag, &help_flag }
};

static void
usage (int ret)
{
    arg_printusage (args,
		    sizeof(args)/sizeof(*args),
		    NULL,
		    "[principal [command]]");
    exit (ret);
}
d56 1
a56 1
		const char *passwd)
d96 1
d102 1
a102 1
    if (do_afslog && k_hasafs()) {
d162 22
a183 14
static krb5_error_code
get_server(krb5_context context,
	   krb5_principal client,
	   const char *server,
	   krb5_principal *princ)
{
    krb5_realm *client_realm;
    if(server)
	return krb5_parse_name(context, server, princ);

    client_realm = krb5_princ_realm (context, client);
    return krb5_make_principal(context, princ, *client_realm,
			       KRB5_TGS_NAME, *client_realm, NULL);
}
d185 1
d187 50
a236 7
static krb5_error_code
do_524init(krb5_context context, krb5_ccache ccache, 
	   krb5_creds *creds, const char *server)
{
    krb5_error_code ret;
    CREDENTIALS c;
    krb5_creds in_creds, *real_creds;
d238 2
a239 21
    if(creds != NULL)
	real_creds = creds;
    else {
	krb5_principal client;
	krb5_cc_get_principal(context, ccache, &client);
	memset(&in_creds, 0, sizeof(in_creds));
	ret = get_server(context, client, server, &in_creds.server);
	if(ret)
	    return ret;
	ret = krb5_get_credentials(context, 0, ccache, &in_creds, &real_creds);
	if(ret)
	    return ret;
    }
    ret = krb524_convert_creds_kdc_ccache(context, ccache, real_creds, &c);
    if(ret)
	krb5_warn(context, ret, "converting creds");
    else {
	int tret = tf_setup(&c, c.pname, c.pinst);
	if(tret)
	    krb5_warnx(context, "saving v4 creds: %s", krb_get_err_text(tret));
    }
d241 3
a243 3
    if(creds == NULL)
	krb5_free_creds(context, real_creds);
    memset(&c, 0, sizeof(c));
d245 8
a252 1
    return ret;
a253 1
#endif
d274 15
a288 4
    ret = get_server(context, in.client, server, &in.server);
    if(ret) {
	krb5_warn(context, ret, "get_server");
	goto out;
a319 12

#ifdef KRB4
    if(ret == 0 && server == NULL) {
	/* only do this if it's a general renew-my-tgt request */
	if(get_v4_tgt)
	    do_524init(context, cache, out, NULL);

	if(do_afslog && k_hasafs())
	    krb5_afslog(context, cache, NULL, NULL);
    }
#endif

d330 2
a331 5
static krb5_error_code
get_new_tickets(krb5_context context, 
		krb5_principal principal,
		krb5_ccache ccache,
		krb5_deltat ticket_life)
d334 5
d340 2
a342 1
    krb5_creds cred;
a343 1
    krb5_deltat start_time = 0;
d345 1
d347 85
d489 11
d545 2
a546 3
				   use_keytab, keytab_str, passwd);
	get_v4_tgt = 0;
	do_afslog  = 0;
d548 2
a549 1
	if (exit_val == 0 || ret == KRB5KRB_AP_ERR_V4_REPLY)
d551 1
d560 1
d564 1
a578 60
    krb5_free_creds_contents (context, &cred);

    return 0;
}

int
main (int argc, char **argv)
{
    krb5_error_code ret;
    krb5_context context;
    krb5_ccache  ccache;
    krb5_principal principal;
    int optind = 0;
    krb5_deltat ticket_life = 0;

    setprogname (argv[0]);
    
    ret = krb5_init_context (&context);
    if (ret)
	errx(1, "krb5_init_context failed: %d", ret);
  
    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optind))
	usage(1);
    
    if (help_flag)
	usage (0);

    if(version_flag) {
	print_version(NULL);
	exit(0);
    }

    argc -= optind;
    argv += optind;

    if (argv[0]) {
	ret = krb5_parse_name (context, argv[0], &principal);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_parse_name");
    } else {
	ret = kinit_get_default_principal (context, &principal);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_get_default_principal");
    }

    if(fcache_version)
	krb5_set_fcache_version(context, fcache_version);

    if(cred_cache) 
	ret = krb5_cc_resolve(context, cred_cache, &ccache);
    else {
	if(argc > 1) {
	    char s[1024];
	    ret = krb5_cc_gen_new(context, &krb5_fcc_ops, &ccache);
	    if(ret)
		krb5_err(context, 1, ret, "creating cred cache");
	    snprintf(s, sizeof(s), "%s:%s",
		     krb5_cc_get_type(context, ccache),
		     krb5_cc_get_name(context, ccache));
	    setenv("KRB5CCNAME", s, 1);
d580 8
a587 13
	    {
		int fd;
		snprintf(s, sizeof(s), "%s_XXXXXX", TKT_ROOT);
		if((fd = mkstemp(s)) >= 0) {
		    close(fd);
		    setenv("KRBTKFILE", s, 1);
		    if (k_hasafs ())
			k_setpag();
		}
	    }
#endif
	} else
	    ret = krb5_cc_default (context, &ccache);
a588 32
    if (ret)
	krb5_err (context, 1, ret, "resolving credentials cache");

    if (lifetime) {
	int tmp = parse_time (lifetime, "s");
	if (tmp < 0)
	    errx (1, "unparsable time: %s", lifetime);

	ticket_life = tmp;
    }
#ifdef KRB4
    if(get_v4_tgt == -1)
	krb5_appdefault_boolean(context, "kinit", 
				krb5_principal_get_realm(context, principal), 
				"krb4_get_tickets", TRUE, &get_v4_tgt);
#endif

    
    if(renew_flag || validate_flag) {
	ret = renew_validate(context, renew_flag, validate_flag, 
			     ccache, server, ticket_life);
	exit(ret != 0);
    }

#ifdef KRB4
    if(!convert_524)
#endif
	get_new_tickets(context, principal, ccache, ticket_life);

#ifdef KRB4
    if(get_v4_tgt)
	do_524init(context, ccache, NULL, server);
d591 1
a602 1
    krb5_free_principal(context, principal);
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.90 2002/09/09 22:17:53 joda Exp $");
a44 1
struct getarg_strings extra_addresses;
a116 3
    { "extra-addresses",'a', arg_strings,	&extra_addresses,
      "include these extra addresses", "addresses" },

d189 3
a191 3
	ret = krb_get_pw_in_tkt(princ.name, princ.instance, princ.realm, 
				KRB_TICKET_GRANTING_TICKET, princ.realm, 
				lifetime, passwd);
a288 1
	krb5_free_principal(context, client);
a291 1
	krb5_free_principal(context, in_creds.server);
a399 1
    krb5_deltat renew = 0;
d423 2
a424 2
	renew = parse_time (renew_life, "s");
	if (renew < 0)
d427 1
a427 1
	krb5_get_init_creds_opt_set_renew_life (&opt, renew);
a430 1

a526 18
    if(ticket_life != 0) {
	if(abs(cred.times.endtime - cred.times.starttime - ticket_life) > 30) {
	    char life[32];
	    unparse_time(cred.times.endtime - cred.times.starttime, 
			 life, sizeof(life));
	    krb5_warnx(context, "NOTICE: ticket lifetime is %s", life);
	}
    }
    if(renew != 0) {
	if(abs(cred.times.renew_till - cred.times.starttime - renew) > 30) {
	    char life[32];
	    unparse_time(cred.times.renew_till - cred.times.starttime, 
			 life, sizeof(life));
	    krb5_warnx(context, "NOTICE: ticket renewable lifetime is %s", 
		       life);
	}
    }

a624 4
    if(do_afslog == -1)
	krb5_appdefault_boolean(context, "kinit", 
				krb5_principal_get_realm(context, principal), 
				"afslog", TRUE, &do_afslog);
a625 18

    if(!addrs_flag && extra_addresses.num_strings > 0)
	krb5_errx(context, 1, "specifying both extra addresses and "
		  "no addresses makes no sense");
    {
	int i;
	krb5_addresses addresses;
	memset(&addresses, 0, sizeof(addresses));
	for(i = 0; i < extra_addresses.num_strings; i++) {
	    ret = krb5_parse_address(context, extra_addresses.strings[i], 
				     &addresses);
	    if (ret == 0) {
		krb5_add_extra_addresses(context, &addresses);
		krb5_free_addresses(context, &addresses);
	    }
	}
	free_getarg_strings(&extra_addresses);
    }
@


1.1.1.5
log
@Import of heimdal-0.6, released earlier today.
@
text
@d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.90.4.1 2003/05/08 18:58:37 lha Exp $");
a54 1
int do_afslog		= -1;
d57 1
d69 1
a69 1
#endif
d72 1
a72 1

d373 1
a374 1
#ifdef KRB4
d378 1
a378 1
#endif
d382 1
a650 1
#endif
d655 1
a689 1
#endif
d692 1
a697 1
#endif
d700 1
@


1.1.1.6
log
@Import of heimdal-0.6.3
@
text
@d35 1
a35 1
RCSID("$KTH: kinit.c,v 1.90.4.5 2004/06/21 08:17:06 lha Exp $");
d293 2
a294 2
	if(ret) {
	    krb5_free_principal(context, client);
a295 2
	}
	in_creds.client = client;
a296 1
	krb5_free_principal(context, client);
a427 2
    if (renew_life == NULL && renewable_flag)
	renew_life = "1 month";
d434 3
a436 1
    }
d627 2
a637 3
    if (argc > 1 && k_hasafs ())
	k_setpag();

d693 1
a693 1
	ret = simple_execvp(argv[1], argv+1);
d700 1
a700 1
    } else {
a701 2
	ret = 0;
    }
d704 1
a704 1
    return ret;
@


1.1.1.7
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
d35 1
a35 11
RCSID("$KTH: kinit.c,v 1.121 2005/06/14 00:14:43 lha Exp $");

#ifndef KRB4
#include "krb5-v4compat.h"
#endif

struct krb5_pk_identity;
struct krb5_pk_cert;
struct ContentInfo;
struct _krb5_krb_auth_data;
#include "krb5-private.h"
a40 1
int pac_flag		= -1;
d56 1
d58 2
a59 1
int convert_524		= 0;
a60 5
char *pk_user_id	= NULL;
char *pk_x509_anchors	= NULL;
int pk_use_dh		= -1;

static char *krb4_cc_name;
d63 1
a63 9
    /* 
     * used by MIT
     * a: ~A
     * V: verbose
     * F: ~f
     * P: ~p
     * C: v4 cache name?
     * 5: 
     */
d66 1
a66 1

d69 1
a69 1

d115 1
a115 1
    { "addresses",	'A',   arg_negative_flag,	&addrs_flag,
a123 14
    { "request-pac",	0,   arg_flag,	&pac_flag,
      "request a Windows PAC" },

#ifdef PKINIT
    {  "pk-user",	'C',	arg_string,	&pk_user_id,
       "principal's public/private/certificate identifier",
       "id" },

    {  "x509-anchors",	'D',  arg_string, &pk_x509_anchors,
       "directory with CA certificates", "directory" },

    {  "pkinit-use-dh",       0,  arg_flag, &pk_use_dh,
       "make pkinit use DH" },
#endif
d277 1
d283 1
a283 2

    struct credentials c;
d308 1
a308 1
	krb5_error_code tret = _krb5_krb_tf_setup(context, &c, NULL, 0);
d310 1
a310 1
	    krb5_warn(context, tret, "saving v4 creds");
d319 1
d377 1
d381 1
d392 1
a392 1
    krb5_free_cred_contents(context, &in);
d400 1
a400 2
		krb5_deltat ticket_life,
		int interactive)
d403 1
a403 1
    krb5_get_init_creds_opt *opt;
a408 1
    char *renewstr = NULL;
d412 1
a412 3
    ret = krb5_get_init_creds_opt_alloc (context, &opt);
    if (ret)
	krb5_err(context, 1, ret, "krb5_get_init_creds_opt_alloc");
d415 1
a415 1
					      /* XXX */principal->realm, opt);
d418 1
a418 1
	krb5_get_init_creds_opt_set_forwardable (opt, forwardable_flag);
d420 1
a420 1
	krb5_get_init_creds_opt_set_proxiable (opt, proxiable_flag);
d422 1
a422 19
	krb5_get_init_creds_opt_set_anonymous (opt, anonymous_flag);
    if (pac_flag != -1)
	krb5_get_init_creds_opt_set_pac_request(context, opt, 
						pac_flag ? TRUE : FALSE);
    if (pk_user_id) {
	int flags = 0;
	if (pk_use_dh == 1)
	    flags |= 1;
	ret = krb5_get_init_creds_opt_set_pkinit(context, opt,
						 principal,
						 pk_user_id,
						 pk_x509_anchors,
						 flags,
						 NULL,
						 NULL,
						 NULL);
	if (ret)
	    krb5_err(context, 1, ret, "krb5_get_init_creds_opt_set_pkinit");
    }
d428 1
a428 1
	krb5_get_init_creds_opt_set_address_list (opt, &no_addrs);
d432 3
a434 5
	renewstr = "1 month";
    if (renew_life)
	renewstr = renew_life;
    if (renewstr) {
	renew = parse_time (renewstr, "s");
d436 3
a438 3
	    errx (1, "unparsable time: %s", renewstr);
	
	krb5_get_init_creds_opt_set_renew_life (opt, renew);
d442 1
a442 1
	krb5_get_init_creds_opt_set_tkt_life (opt, ticket_life);
d465 1
a465 1
	krb5_get_init_creds_opt_set_etype_list(opt, enctype, 
d483 1
a483 1
					  opt);
a484 14
    } else if (pk_user_id) {
	ret = krb5_get_init_creds_password (context,
					    &cred,
					    principal,
					    NULL,
					    krb5_prompter_posix,
					    NULL,
					    start_time,
					    server,
					    opt);
    } else if (!interactive) {
	krb5_warnx(context, "Not interactive, failed to get initial ticket");
	krb5_get_init_creds_opt_free(opt);
	return 0;
d492 1
a492 1
	if (UI_UTIL_read_pw_string(passwd, sizeof(passwd)-1, prompt, 0)){
d498 1
a498 1
	
d507 1
a507 1
					    opt);
a508 1
    krb5_get_init_creds_opt_free(opt);
d539 3
a541 3
	    char life[64];
	    unparse_time_approx(cred.times.endtime - cred.times.starttime, 
				life, sizeof(life));
d545 1
a545 1
    if(renew_life) {
d547 3
a549 3
	    char life[64];
	    unparse_time_approx(cred.times.renew_till - cred.times.starttime, 
				life, sizeof(life));
d563 1
a563 1
    krb5_free_cred_contents (context, &cred);
a567 68
static time_t
ticket_lifetime(krb5_context context, krb5_ccache cache, 
		krb5_principal client, const char *server)
{
    krb5_creds in_cred, *cred;
    krb5_error_code ret;
    time_t timeout;

    memset(&in_cred, 0, sizeof(in_cred));

    ret = krb5_cc_get_principal(context, cache, &in_cred.client);
    if(ret) {
	krb5_warn(context, ret, "krb5_cc_get_principal");
	return 0;
    }
    ret = get_server(context, in_cred.client, server, &in_cred.server);
    if(ret) {
	krb5_free_principal(context, in_cred.client);
	krb5_warn(context, ret, "get_server");
	return 0;
    }

    ret = krb5_get_credentials(context, KRB5_GC_CACHED,
			       cache, &in_cred, &cred);
    krb5_free_principal(context, in_cred.client);
    krb5_free_principal(context, in_cred.server);
    if(ret) {
	krb5_warn(context, ret, "krb5_get_credentials");
	return 0;
    }
    timeout = cred->times.endtime - cred->times.starttime;
    if (timeout < 0)
	timeout = 0;
    krb5_free_creds(context, cred);
    return timeout;
}

struct renew_ctx {
    krb5_context context;
    krb5_ccache  ccache;
    krb5_principal principal;
    krb5_deltat ticket_life;
};

static time_t
renew_func(void *ptr)
{
    struct renew_ctx *ctx = ptr;
    krb5_error_code ret;
    time_t expire;


    ret = renew_validate(ctx->context, renewable_flag, validate_flag,
			     ctx->ccache, server, ctx->ticket_life);
    if (ret)
	get_new_tickets(ctx->context, ctx->principal, 
			ctx->ccache, ctx->ticket_life, 0);

    if(get_v4_tgt || convert_524)
	do_524init(ctx->context, ctx->ccache, NULL, server);
    if(do_afslog && k_hasafs())
	krb5_afslog(ctx->context, ctx->ccache, NULL, NULL);

    expire = ticket_lifetime(ctx->context, ctx->ccache, ctx->principal,
			     server) / 2;
    return expire + 1;
}

d581 1
a581 3
    if (ret == KRB5_CONFIG_BADFORMAT)
	errx (1, "krb5_init_context failed to parse configuration file");
    else if (ret)
d623 2
a624 1
	    if (get_v4_tgt) {
d626 2
a627 3
		if (asprintf(&krb4_cc_name, "%s_XXXXXXXXXXX", TKT_ROOT) < 0)
		    krb5_errx(context, 1, "out of memory");
		if((fd = mkstemp(krb4_cc_name)) >= 0) {
d629 1
a629 4
		    setenv("KRBTKFILE", krb4_cc_name, 1);
		} else {
		    free(krb4_cc_name);
		    krb4_cc_name = NULL;
d632 1
d639 1
a639 1
    if(argc > 1 && k_hasafs ())
d649 1
a649 5
    if(renewable_flag == -1)
	/* this seems somewhat pointless, but whatever */
	krb5_appdefault_boolean(context, "kinit",
				krb5_principal_get_realm(context, principal),
				"renewable", FALSE, &renewable_flag);
d653 2
a654 1
				"krb4_get_tickets", FALSE, &get_v4_tgt);
a659 12
    if (pk_x509_anchors == NULL)
	krb5_appdefault_string(context, "kinit",
			       krb5_principal_get_realm(context, principal), 
			       "pkinit-anchors", NULL, &pk_x509_anchors);

#ifdef PKINIT
    if(pk_use_dh == -1)
	krb5_appdefault_boolean(context, "kinit", 
				krb5_principal_get_realm(context, principal), 
				"pkinit-use-dh", FALSE, &pk_use_dh);
#endif

d678 1
d685 1
d687 2
a688 1
	get_new_tickets(context, principal, ccache, ticket_life, 1);
d690 2
a691 1
    if(get_v4_tgt || convert_524)
d693 1
d697 1
a697 19
	struct renew_ctx ctx;
	time_t timeout;

	timeout = ticket_lifetime(context, ccache, principal, server) / 2;

	ctx.context = context;
	ctx.ccache = ccache;
	ctx.principal = principal;
	ctx.ticket_life = ticket_life;

	ret = simple_execvp_timed(argv[1], argv+1, 
				  renew_func, &ctx, timeout);
#define EX_NOEXEC	126
#define EX_NOTFOUND	127
	if(ret == EX_NOEXEC)
	    krb5_warnx(context, "permission denied: %s", argv[1]);
	else if(ret == EX_NOTFOUND)
	    krb5_warnx(context, "command not found: %s", argv[1]);
	
d699 3
a701 1
	_krb5_krb_dest_tkt(context, krb4_cc_name);
@


