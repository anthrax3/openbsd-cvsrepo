head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.28
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	HEIMDAL_0_7_2:1.1.1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	HEIMDAL_0_6_3:1.1.1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.8;

1.8
date	2013.06.17.18.57.42;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.14.08.15.04;	author biorn;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.29.16.20.30;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.13.03.09.16;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.11.03.40.00;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.05.16.16.50;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.05.10.29.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.51;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.51;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.22.03;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.35;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.13.02.59.46;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.10.29.15.55.32;	author biorn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.04.14.07.32.49;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.9
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2008 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Portions Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kuser_locl.h"
#include "rtbl.h"
#include "parse_units.h"
#include "kcc-commands.h"

static char*
printable_time_internal(time_t t, int x)
{
    static char s[128];
    char *p;

    if ((p = ctime(&t)) == NULL)
	strlcpy(s, "?", sizeof(s));
    else
	strlcpy(s, p + 4, sizeof(s));
    s[x] = 0;
    return s;
}

static char*
printable_time(time_t t)
{
    return printable_time_internal(t, 20);
}

static char*
printable_time_long(time_t t)
{
    return printable_time_internal(t, 20);
}

#define COL_ISSUED		NP_("  Issued","")
#define COL_EXPIRES		NP_("  Expires", "")
#define COL_FLAGS		NP_("Flags", "")
#define COL_NAME		NP_("  Name", "")
#define COL_PRINCIPAL		NP_("  Principal", "in klist output")
#define COL_PRINCIPAL_KVNO	NP_("  Principal (kvno)", "in klist output")
#define COL_CACHENAME		NP_("  Cache name", "name in klist output")
#define COL_DEFCACHE		NP_("", "")

static void
print_cred(krb5_context context, krb5_creds *cred, rtbl_t ct, int do_flags)
{
    char *str;
    krb5_error_code ret;
    krb5_timestamp sec;

    krb5_timeofday (context, &sec);


    if(cred->times.starttime)
	rtbl_add_column_entry(ct, COL_ISSUED,
			      printable_time(cred->times.starttime));
    else
	rtbl_add_column_entry(ct, COL_ISSUED,
			      printable_time(cred->times.authtime));

    if(cred->times.endtime > sec)
	rtbl_add_column_entry(ct, COL_EXPIRES,
			      printable_time(cred->times.endtime));
    else
	rtbl_add_column_entry(ct, COL_EXPIRES, N_(">>>Expired<<<", ""));
    ret = krb5_unparse_name (context, cred->server, &str);
    if (ret)
	krb5_err(context, 1, ret, "krb5_unparse_name");
    rtbl_add_column_entry(ct, COL_PRINCIPAL, str);
    if(do_flags) {
	char s[16], *sp = s;
	if(cred->flags.b.forwardable)
	    *sp++ = 'F';
	if(cred->flags.b.forwarded)
	    *sp++ = 'f';
	if(cred->flags.b.proxiable)
	    *sp++ = 'P';
	if(cred->flags.b.proxy)
	    *sp++ = 'p';
	if(cred->flags.b.may_postdate)
	    *sp++ = 'D';
	if(cred->flags.b.postdated)
	    *sp++ = 'd';
	if(cred->flags.b.renewable)
	    *sp++ = 'R';
	if(cred->flags.b.initial)
	    *sp++ = 'I';
	if(cred->flags.b.invalid)
	    *sp++ = 'i';
	if(cred->flags.b.pre_authent)
	    *sp++ = 'A';
	if(cred->flags.b.hw_authent)
	    *sp++ = 'H';
	*sp = '\0';
	rtbl_add_column_entry(ct, COL_FLAGS, s);
    }
    free(str);
}

static void
print_cred_verbose(krb5_context context, krb5_creds *cred)
{
    size_t j;
    char *str;
    krb5_error_code ret;
    krb5_timestamp sec;

    krb5_timeofday (context, &sec);

    ret = krb5_unparse_name(context, cred->server, &str);
    if(ret)
	exit(1);
    printf(N_("Server: %s\n", ""), str);
    free (str);

    ret = krb5_unparse_name(context, cred->client, &str);
    if(ret)
	exit(1);
    printf(N_("Client: %s\n", ""), str);
    free (str);

    {
	Ticket t;
	size_t len;
	char *s;

	decode_Ticket(cred->ticket.data, cred->ticket.length, &t, &len);
	ret = krb5_enctype_to_string(context, t.enc_part.etype, &s);
	printf(N_("Ticket etype: ", ""));
	if (ret == 0) {
	    printf("%s", s);
	    free(s);
	} else {
	    printf(N_("unknown-enctype(%d)", ""), t.enc_part.etype);
	}
	if(t.enc_part.kvno)
	    printf(N_(", kvno %d", ""), *t.enc_part.kvno);
	printf("\n");
	if(cred->session.keytype != t.enc_part.etype) {
	    ret = krb5_enctype_to_string(context, cred->session.keytype, &str);
	    if(ret)
		krb5_warn(context, ret, "session keytype");
	    else {
		printf(N_("Session key: %s\n", "enctype"), str);
		free(str);
	    }
	}
	free_Ticket(&t);
	printf(N_("Ticket length: %lu\n", ""),
	       (unsigned long)cred->ticket.length);
    }
    printf(N_("Auth time:  %s\n", ""),
	   printable_time_long(cred->times.authtime));
    if(cred->times.authtime != cred->times.starttime)
	printf(N_("Start time: %s\n", ""),
	       printable_time_long(cred->times.starttime));
    printf(N_("End time:   %s", ""),
	   printable_time_long(cred->times.endtime));
    if(sec > cred->times.endtime)
	printf(N_(" (expired)", ""));
    printf("\n");
    if(cred->flags.b.renewable)
	printf(N_("Renew till: %s\n", ""),
	       printable_time_long(cred->times.renew_till));
    {
	char flags[1024];
	unparse_flags(TicketFlags2int(cred->flags.b),
		      asn1_TicketFlags_units(),
		      flags, sizeof(flags));
	printf(N_("Ticket flags: %s\n", ""), flags);
    }
    printf(N_("Addresses: ", ""));
    if (cred->addresses.len != 0) {
	for(j = 0; j < cred->addresses.len; j++){
	    char buf[128];
	    size_t len;
	    if(j) printf(", ");
	    ret = krb5_print_address(&cred->addresses.val[j],
				     buf, sizeof(buf), &len);

	    if(ret == 0)
		printf("%s", buf);
	}
    } else {
	printf(N_("addressless", ""));
    }
    printf("\n\n");
}

/*
 * Print all tickets in `ccache' on stdout, verbosily iff do_verbose.
 */

static void
print_tickets (krb5_context context,
	       krb5_ccache ccache,
	       krb5_principal principal,
	       int do_verbose,
	       int do_flags,
	       int do_hidden)
{
    krb5_error_code ret;
    char *str, *name;
    krb5_cc_cursor cursor;
    krb5_creds creds;
    krb5_deltat sec;

    rtbl_t ct = NULL;

    ret = krb5_unparse_name (context, principal, &str);
    if (ret)
	krb5_err (context, 1, ret, "krb5_unparse_name");

    printf ("%17s: %s:%s\n",
	    N_("Credentials cache", ""),
	    krb5_cc_get_type(context, ccache),
	    krb5_cc_get_name(context, ccache));
    printf ("%17s: %s\n", N_("Principal", ""), str);

    ret = krb5_cc_get_friendly_name(context, ccache, &name);
    if (ret == 0) {
	if (strcmp(name, str) != 0)
	    printf ("%17s: %s\n", N_("Friendly name", ""), name);
	free(name);
    }
    free (str);

    if(do_verbose) {
	printf ("%17s: %d\n", N_("Cache version", ""),
		krb5_cc_get_version(context, ccache));
    } else {
        krb5_cc_set_flags(context, ccache, KRB5_TC_NOTICKET);
    }

    ret = krb5_cc_get_kdc_offset(context, ccache, &sec);

    if (ret == 0 && do_verbose && sec != 0) {
	char buf[BUFSIZ];
	int val;
	int sig;

	val = sec;
	sig = 1;
	if (val < 0) {
	    sig = -1;
	    val = -val;
	}

	unparse_time (val, buf, sizeof(buf));

	printf ("%17s: %s%s\n", N_("KDC time offset", ""),
		sig == -1 ? "-" : "", buf);
    }

    printf("\n");

    ret = krb5_cc_start_seq_get (context, ccache, &cursor);
    if (ret)
	krb5_err(context, 1, ret, "krb5_cc_start_seq_get");

    if(!do_verbose) {
	ct = rtbl_create();
	rtbl_add_column(ct, COL_ISSUED, 0);
	rtbl_add_column(ct, COL_EXPIRES, 0);
	if(do_flags)
	    rtbl_add_column(ct, COL_FLAGS, 0);
	rtbl_add_column(ct, COL_PRINCIPAL, 0);
	rtbl_set_separator(ct, "  ");
    }
    while ((ret = krb5_cc_next_cred (context,
				     ccache,
				     &cursor,
				     &creds)) == 0) {
	if (!do_hidden && krb5_is_config_principal(context, creds.server)) {
	    ;
	}else if(do_verbose){
	    print_cred_verbose(context, &creds);
	}else{
	    print_cred(context, &creds, ct, do_flags);
	}
	krb5_free_cred_contents (context, &creds);
    }
    if(ret != KRB5_CC_END)
	krb5_err(context, 1, ret, "krb5_cc_get_next");
    ret = krb5_cc_end_seq_get (context, ccache, &cursor);
    if (ret)
	krb5_err (context, 1, ret, "krb5_cc_end_seq_get");
    if(!do_verbose) {
	rtbl_format(ct, stdout);
	rtbl_destroy(ct);
    }
}

/*
 * Check if there's a tgt for the realm of `principal' and ccache and
 * if so return 0, else 1
 */

static int
check_for_tgt (krb5_context context,
	       krb5_ccache ccache,
	       krb5_principal principal,
	       time_t *expiration)
{
    krb5_error_code ret;
    krb5_creds pattern;
    krb5_creds creds;
    krb5_const_realm client_realm;
    int expired;

    krb5_cc_clear_mcred(&pattern);

    client_realm = krb5_principal_get_realm(context, principal);

    ret = krb5_make_principal (context, &pattern.server,
			       client_realm, KRB5_TGS_NAME, client_realm, NULL);
    if (ret)
	krb5_err (context, 1, ret, "krb5_make_principal");
    pattern.client = principal;

    ret = krb5_cc_retrieve_cred (context, ccache, 0, &pattern, &creds);
    krb5_free_principal (context, pattern.server);
    if (ret) {
	if (ret == KRB5_CC_END)
	    return 1;
	krb5_err (context, 1, ret, "krb5_cc_retrieve_cred");
    }

    expired = time(NULL) > creds.times.endtime;

    if (expiration)
	*expiration = creds.times.endtime;

    krb5_free_cred_contents (context, &creds);

    return expired;
}

/*
 * Print a list of all AFS tokens
 */

#ifndef NO_AFS

static void
display_tokens(int do_verbose)
{
    uint32_t i;
    unsigned char t[4096];
    struct ViceIoctl parms;

    parms.in = (void *)&i;
    parms.in_size = sizeof(i);
    parms.out = (void *)t;
    parms.out_size = sizeof(t);

    for (i = 0;; i++) {
        int32_t size_secret_tok, size_public_tok;
        unsigned char *cell;
	struct ClearToken ct;
	unsigned char *r = t;
	struct timeval tv;
	char buf1[20], buf2[20];

	if(k_pioctl(NULL, VIOCGETTOK, &parms, 0) < 0) {
	    if(errno == EDOM)
		break;
	    continue;
	}
	if(parms.out_size > sizeof(t))
	    continue;
	if(parms.out_size < sizeof(size_secret_tok))
	    continue;
	t[min(parms.out_size,sizeof(t)-1)] = 0;
	memcpy(&size_secret_tok, r, sizeof(size_secret_tok));
	/* dont bother about the secret token */
	r += size_secret_tok + sizeof(size_secret_tok);
	if (parms.out_size < (r - t) + sizeof(size_public_tok))
	    continue;
	memcpy(&size_public_tok, r, sizeof(size_public_tok));
	r += sizeof(size_public_tok);
	if (parms.out_size < (r - t) + size_public_tok + sizeof(int32_t))
	    continue;
	memcpy(&ct, r, size_public_tok);
	r += size_public_tok;
	/* there is a int32_t with length of cellname, but we dont read it */
	r += sizeof(int32_t);
	cell = r;

	gettimeofday (&tv, NULL);
	strlcpy (buf1, printable_time(ct.BeginTimestamp),
		 sizeof(buf1));
	if (do_verbose || tv.tv_sec < ct.EndTimestamp)
	    strlcpy (buf2, printable_time(ct.EndTimestamp),
		     sizeof(buf2));
	else
	    strlcpy (buf2, N_(">>> Expired <<<", ""), sizeof(buf2));

	printf("%s  %s  ", buf1, buf2);

	if ((ct.EndTimestamp - ct.BeginTimestamp) & 1)
	    printf(N_("User's (AFS ID %d) tokens for %s", ""), ct.ViceId, cell);
	else
	    printf(N_("Tokens for %s", ""), cell);
	if (do_verbose)
	    printf(" (%d)", ct.AuthHandle);
	putchar('\n');
    }
}
#endif

/*
 * display the ccache in `cred_cache'
 */

static int
display_v5_ccache (krb5_context context, krb5_ccache ccache,
		   int do_test, int do_verbose,
		   int do_flags, int do_hidden)
{
    krb5_error_code ret;
    krb5_principal principal;
    int exit_status = 0;


    ret = krb5_cc_get_principal (context, ccache, &principal);
    if (ret) {
	if(ret == ENOENT) {
	    if (!do_test)
		krb5_warnx(context, N_("No ticket file: %s", ""),
			   krb5_cc_get_name(context, ccache));
	    return 1;
	} else
	    krb5_err (context, 1, ret, "krb5_cc_get_principal");
    }
    if (do_test)
	exit_status = check_for_tgt (context, ccache, principal, NULL);
    else
	print_tickets (context, ccache, principal, do_verbose,
		       do_flags, do_hidden);

    ret = krb5_cc_close (context, ccache);
    if (ret)
	krb5_err (context, 1, ret, "krb5_cc_close");

    krb5_free_principal (context, principal);

    return exit_status;
}

/*
 *
 */

static int
list_caches(krb5_context context)
{
    krb5_cc_cache_cursor cursor;
    const char *cdef_name;
    char *def_name;
    krb5_error_code ret;
    krb5_ccache id;
    rtbl_t ct;

    cdef_name = krb5_cc_default_name(context);
    if (cdef_name == NULL)
	krb5_errx(context, 1, "krb5_cc_default_name");
    def_name = strdup(cdef_name);

    ret = krb5_cc_cache_get_first (context, NULL, &cursor);
    if (ret == KRB5_CC_NOSUPP)
	return 0;
    else if (ret)
	krb5_err (context, 1, ret, "krb5_cc_cache_get_first");

    ct = rtbl_create();
    rtbl_add_column(ct, COL_NAME, 0);
    rtbl_add_column(ct, COL_CACHENAME, 0);
    rtbl_add_column(ct, COL_EXPIRES, 0);
    rtbl_add_column(ct, COL_DEFCACHE, 0);
    rtbl_set_prefix(ct, "   ");
    rtbl_set_column_prefix(ct, COL_NAME, "");

    while (krb5_cc_cache_next (context, cursor, &id) == 0) {
	krb5_principal principal = NULL;
	int expired = 0;
	char *name;
	time_t t;

	ret = krb5_cc_get_principal(context, id, &principal);
	if (ret)
	    continue;

	expired = check_for_tgt (context, id, principal, &t);

	ret = krb5_cc_get_friendly_name(context, id, &name);
	if (ret == 0) {
	    const char *str;
	    char *fname;
	    rtbl_add_column_entry(ct, COL_NAME, name);
	    rtbl_add_column_entry(ct, COL_CACHENAME,
				  krb5_cc_get_name(context, id));
	    if (expired)
		str = N_(">>> Expired <<<", "");
	    else
		str = printable_time(t);
	    rtbl_add_column_entry(ct, COL_EXPIRES, str);
	    free(name);

	    ret = krb5_cc_get_full_name(context, id, &fname);
	    if (ret)
		krb5_err (context, 1, ret, "krb5_cc_get_full_name");

	    if (strcmp(fname, def_name) == 0)
		rtbl_add_column_entry(ct, COL_DEFCACHE, "*");
	    else
		rtbl_add_column_entry(ct, COL_DEFCACHE, "");

	    krb5_xfree(fname);
	}
	krb5_cc_close(context, id);

	krb5_free_principal(context, principal);
    }

    krb5_cc_cache_end_seq_get(context, cursor);

    free(def_name);
    rtbl_format(ct, stdout);
    rtbl_destroy(ct);

    return 0;
}

/*
 *
 */

int
klist(struct klist_options *opt, int argc, char **argv)
{
    krb5_error_code ret;
    int exit_status = 0;

    int do_verbose =
	opt->verbose_flag ||
	opt->a_flag ||
	opt->n_flag;
    int do_test =
	opt->test_flag ||
	opt->s_flag;

    if (opt->list_all_flag) {
	exit_status = list_caches(kcc_context);
	return exit_status;
    }

    if (opt->v5_flag) {
	krb5_ccache id;

	if (opt->all_content_flag) {
	    krb5_cc_cache_cursor cursor;

	    ret = krb5_cc_cache_get_first(kcc_context, NULL, &cursor);
	    if (ret)
		krb5_err(kcc_context, 1, ret, "krb5_cc_cache_get_first");


	    while (krb5_cc_cache_next(kcc_context, cursor, &id) == 0) {
		exit_status |= display_v5_ccache(kcc_context, id, do_test,
						 do_verbose, opt->flags_flag,
						 opt->hidden_flag);
		printf("\n\n");
	    }
	    krb5_cc_cache_end_seq_get(kcc_context, cursor);

	} else {
	    if(opt->cache_string) {
		ret = krb5_cc_resolve(kcc_context, opt->cache_string, &id);
		if (ret)
		    krb5_err(kcc_context, 1, ret, "%s", opt->cache_string);
	    } else {
		ret = krb5_cc_default(kcc_context, &id);
		if (ret)
		    krb5_err(kcc_context, 1, ret, "krb5_cc_resolve");
	    }
	    exit_status = display_v5_ccache(kcc_context, id, do_test,
					    do_verbose, opt->flags_flag,
					    opt->hidden_flag);
	}
    }

    if (!do_test) {
#ifndef NO_AFS
	if (opt->tokens_flag && k_hasafs()) {
	    if (opt->v5_flag)
		printf("\n");
	    display_tokens(opt->verbose_flag);
	}
#endif
    }

    return exit_status;
}
@


1.8
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@@


1.7
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 1
a6 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d8 3
a10 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d12 2
a13 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d15 3
a17 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d19 15
a33 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d38 2
d41 13
a53 1
RCSID("$KTH: klist.c,v 1.76 2005/04/24 19:47:44 lha Exp $");
d58 1
a58 4
    static char s[128];
    strlcpy(s, ctime(&t)+ 4, sizeof(s));
    s[15] = 0;
    return s;
d64 1
a64 4
    static char s[128];
    strlcpy(s, ctime(&t)+ 4, sizeof(s));
    s[20] = 0;
    return s;
d67 8
a74 5
#define COL_ISSUED		"  Issued"
#define COL_EXPIRES		"  Expires"
#define COL_FLAGS		"Flags"
#define COL_PRINCIPAL		"  Principal"
#define COL_PRINCIPAL_KVNO	"  Principal (kvno)"
d92 1
a92 1
    
d97 1
a97 1
	rtbl_add_column_entry(ct, COL_EXPIRES, ">>>Expired<<<");
d126 1
a126 1
	*sp++ = '\0';
d135 1
a135 1
    int j;
a137 1
    int first_flag;
d145 1
a145 1
    printf("Server: %s\n", str);
d147 7
d161 1
a161 1
	printf("Ticket etype: ");
d166 1
a166 1
	    printf("unknown(%d)", t.enc_part.etype);
d169 1
a169 1
	    printf(", kvno %d", *t.enc_part.kvno);
d176 1
a176 1
		printf("Session key: %s\n", str);
d181 2
d184 2
a185 1
    printf("Auth time:  %s\n", printable_time_long(cred->times.authtime));
d187 4
a190 2
	printf("Start time: %s\n", printable_time_long(cred->times.starttime));
    printf("End time:   %s", printable_time_long(cred->times.endtime));
d192 1
a192 1
	printf(" (expired)");
d195 1
a195 1
	printf("Renew till: %s\n", 
d197 15
a211 26
    printf("Ticket flags: ");
#define PRINT_FLAG2(f, s) if(cred->flags.b.f) { if(!first_flag) printf(", "); printf("%s", #s); first_flag = 0; }
#define PRINT_FLAG(f) PRINT_FLAG2(f, f)
    first_flag = 1;
    PRINT_FLAG(forwardable);
    PRINT_FLAG(forwarded);
    PRINT_FLAG(proxiable);
    PRINT_FLAG(proxy);
    PRINT_FLAG2(may_postdate, may-postdate);
    PRINT_FLAG(postdated);
    PRINT_FLAG(invalid);
    PRINT_FLAG(renewable);
    PRINT_FLAG(initial);
    PRINT_FLAG2(pre_authent, pre-authenticated);
    PRINT_FLAG2(hw_authent, hw-authenticated);
    PRINT_FLAG2(transited_policy_checked, transited-policy-checked);
    PRINT_FLAG2(ok_as_delegate, ok-as-delegate);
    PRINT_FLAG(anonymous);
    printf("\n");
    printf("Addresses: ");
    for(j = 0; j < cred->addresses.len; j++){
	char buf[128];
	size_t len;
	if(j) printf(", ");
	ret = krb5_print_address(&cred->addresses.val[j], 
				 buf, sizeof(buf), &len);
d213 5
a217 2
	if(ret == 0)
	    printf("%s", buf);
d231 2
a232 1
	       int do_flags)
d235 1
a235 1
    char *str;
d238 1
d246 2
a247 2
    printf ("%17s: %s:%s\n", 
	    "Credentials cache",
d250 8
a257 1
    printf ("%17s: %s\n", "Principal", str);
d259 3
a261 3
    
    if(do_verbose)
	printf ("%17s: %d\n", "Cache version",
d263 7
a269 2
    
    if (do_verbose && context->kdc_sec_offset) {
d274 1
a274 1
	val = context->kdc_sec_offset;
d280 1
a280 1
	
d283 1
a283 1
	printf ("%17s: %s%s\n", "KDC time offset",
d306 3
a308 1
	if(do_verbose){
d334 2
a335 1
	       krb5_principal principal)
d340 1
a340 1
    krb5_realm *client_realm;
d345 1
a345 1
    client_realm = krb5_princ_realm (context, principal);
d348 1
a348 2
			       *client_realm, KRB5_TGS_NAME, *client_realm,
			       NULL);
a353 1
    expired = time(NULL) > creds.times.endtime;
a354 1
    krb5_free_cred_contents (context, &creds);
a359 2
    return expired;
}
d361 1
a361 3
#ifdef KRB4
/* prints the approximate kdc time differential as something human
   readable */
d363 2
a364 5
static void
print_time_diff(int do_verbose)
{
    int d = abs(krb_get_kdc_time_diff());
    char buf[80];
d366 1
a366 5
    if ((do_verbose && d > 0) || d > 60) {
	unparse_time_approx (d, buf, sizeof(buf));
	printf ("Time diff:\t%s\n", buf);
    }
}
d368 1
a368 14
/*
 * return a short representation of `dp' in string form.
 */

static char *
short_date(int32_t dp)
{
    char *cp;
    time_t t = (time_t)dp;

    if (t == (time_t)(-1L)) return "***  Never  *** ";
    cp = ctime(&t) + 4;
    cp[15] = '\0';
    return (cp);
d372 1
a372 1
 * Print a list of all the v4 tickets
d375 1
a375 106
static int
display_v4_tickets (int do_verbose)
{
    char *file;
    int ret;
    krb_principal princ;
    CREDENTIALS cred;
    int found = 0;

    rtbl_t ct;

    file = getenv ("KRBTKFILE");
    if (file == NULL)
	file = TKT_FILE;

    printf("%17s: %s\n", "V4-ticket file", file);

    ret = krb_get_tf_realm (file, princ.realm);
    if (ret) {
	warnx ("%s", krb_get_err_text(ret));
	return 1;
    }

    ret = tf_init (file, R_TKT_FIL);
    if (ret) {
	warnx ("tf_init: %s", krb_get_err_text(ret));
	return 1;
    }
    ret = tf_get_pname (princ.name);
    if (ret) {
	tf_close ();
	warnx ("tf_get_pname: %s", krb_get_err_text(ret));
	return 1;
    }
    ret = tf_get_pinst (princ.instance);
    if (ret) {
	tf_close ();
	warnx ("tf_get_pname: %s", krb_get_err_text(ret));
	return 1;
    }

    printf ("%17s: %s\n", "Principal", krb_unparse_name(&princ));
    print_time_diff(do_verbose);
    printf("\n");

    ct = rtbl_create();
    rtbl_add_column(ct, COL_ISSUED, 0);
    rtbl_add_column(ct, COL_EXPIRES, 0);
    if (do_verbose)
	rtbl_add_column(ct, COL_PRINCIPAL_KVNO, 0);
    else
	rtbl_add_column(ct, COL_PRINCIPAL, 0);
    rtbl_set_prefix(ct, "  ");
    rtbl_set_column_prefix(ct, COL_ISSUED, "");

    while ((ret = tf_get_cred(&cred)) == KSUCCESS) {
	struct timeval tv;
	char buf1[20], buf2[20];
	const char *pp;

	found++;

	strlcpy(buf1,
		short_date(cred.issue_date),
		sizeof(buf1));
	cred.issue_date = krb_life_to_time(cred.issue_date, cred.lifetime);
	krb_kdctimeofday(&tv);
	if (do_verbose || tv.tv_sec < (unsigned long) cred.issue_date)
	    strlcpy(buf2,
		    short_date(cred.issue_date),
		    sizeof(buf2));
	else
	    strlcpy(buf2,
		    ">>> Expired <<<",
		    sizeof(buf2));
	rtbl_add_column_entry(ct, COL_ISSUED, buf1);
	rtbl_add_column_entry(ct, COL_EXPIRES, buf2);
	pp = krb_unparse_name_long(cred.service,
				   cred.instance,
				   cred.realm);
	if (do_verbose) {
	    char *tmp;

	    asprintf(&tmp, "%s (%d)", pp, cred.kvno);
	    rtbl_add_column_entry(ct, COL_PRINCIPAL_KVNO, tmp);
	    free(tmp);
	} else {
	    rtbl_add_column_entry(ct, COL_PRINCIPAL, pp);
	}
    }
    rtbl_format(ct, stdout);
    rtbl_destroy(ct);
    if (!found && ret == EOF)
	printf("No tickets in file.\n");
    tf_close();
    
    /*
     * should do NAT stuff here
     */
    return 0;
}
#endif /* KRB4 */

/*
 * Print a list of all AFS tokens
 */
d380 1
a380 1
    u_int32_t i;
d429 1
a429 1
	    strlcpy (buf2, ">>> Expired <<<", sizeof(buf2));
d434 1
a434 1
	    printf("User's (AFS ID %d) tokens for %s", ct.ViceId, cell);
d436 1
a436 1
	    printf("Tokens for %s", cell);
d442 1
d449 3
a451 2
display_v5_ccache (const char *cred_cache, int do_test, int do_verbose, 
		   int do_flags)
a453 2
    krb5_context context;
    krb5_ccache ccache;
a456 13
    ret = krb5_init_context (&context);
    if (ret)
	errx (1, "krb5_init_context failed: %d", ret);

    if(cred_cache) {
	ret = krb5_cc_resolve(context, cred_cache, &ccache);
	if (ret)
	    krb5_err (context, 1, ret, "%s", cred_cache);
    } else {
	ret = krb5_cc_default (context, &ccache);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_cc_resolve");
    }
d462 1
a462 1
		krb5_warnx(context, "No ticket file: %s",
d469 1
a469 1
	exit_status = check_for_tgt (context, ccache, principal);
d471 2
a472 1
	print_tickets (context, ccache, principal, do_verbose, do_flags);
d479 1
a479 1
    krb5_free_context (context);
d483 3
a485 36
static int version_flag = 0;
static int help_flag	= 0;
static int do_verbose	= 0;
static int do_test	= 0;
#ifdef KRB4
static int do_v4	= 1;
#endif
static int do_tokens	= 0;
static int do_v5	= 1;
static char *cred_cache;
static int do_flags = 0;

static struct getargs args[] = {
    { NULL, 'f', arg_flag, &do_flags },
    { "cache",			'c', arg_string, &cred_cache,
      "credentials cache to list", "cache" },
    { "test",			't', arg_flag, &do_test,
      "test for having tickets", NULL },
    { NULL,			's', arg_flag, &do_test },
#ifdef KRB4
    { "v4",			'4',	arg_flag, &do_v4,
      "display v4 tickets", NULL },
#endif
    { "tokens",			'T',   arg_flag, &do_tokens,
      "display AFS tokens", NULL },
    { "v5",			'5',	arg_flag, &do_v5,
      "display v5 cred cache", NULL},
    { "verbose",		'v', arg_flag, &do_verbose,
      "verbose output", NULL },
    { NULL,			'a', arg_flag, &do_verbose },
    { NULL,			'n', arg_flag, &do_verbose },
    { "version", 		0,   arg_flag, &version_flag, 
      "print version", NULL },
    { "help",			0,   arg_flag, &help_flag, 
      NULL, NULL}
};
d487 2
a488 2
static void
usage (int ret)
d490 75
a564 5
    arg_printusage (args,
		    sizeof(args)/sizeof(*args),
		    NULL,
		    "");
    exit (ret);
d567 4
d572 1
a572 1
main (int argc, char **argv)
d574 1
a574 1
    int optind = 0;
d577 47
a623 20
    if(getarg(args, sizeof(args) / sizeof(args[0]), argc, argv, &optind))
	usage(1);
    
    if (help_flag)
	usage (0);

    if(version_flag){
	print_version(NULL);
	exit(0);
    }

    argc -= optind;
    argv += optind;

    if (argc != 0)
	usage (1);

    if (do_v5)
	exit_status = display_v5_ccache (cred_cache, do_test, 
					 do_verbose, do_flags);
d626 5
a630 5
#ifdef KRB4
	if (do_v4) {
	    if (do_v5)
		printf ("\n");
	    display_v4_tickets (do_verbose);
a632 9
	if (do_tokens && k_hasafs ()) {
	    if (do_v5)
		printf ("\n");
#ifdef KRB4
	    else if (do_v4)
		printf ("\n");
#endif
	    display_tokens (do_verbose);
	}
@


1.6
log
@Merge with heimdal-0.6.3 Tested by beck@@, msf@@, me and others. ok beck@@
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: klist.c,v 1.68.2.2 2003/10/13 15:13:39 joda Exp $");
d43 1
a43 1
    strlcpy(s, ctime(&t)+ 4, sizeof s);
d52 1
a52 1
    strlcpy(s, ctime(&t)+ 4, sizeof s);
d153 1
a153 4
	    ret = krb5_keytype_to_string(context, cred->session.keytype, &str);
	    if(ret == KRB5_PROG_KEYTYPE_NOSUPP)
		ret = krb5_enctype_to_string(context, cred->session.keytype, 
					     &str);
d270 1
a270 2
	rtbl_set_prefix(ct, "  ");
	rtbl_set_column_prefix(ct, COL_ISSUED, "");
d281 1
a281 1
	krb5_free_creds_contents (context, &creds);
d310 2
d319 1
d324 1
a324 1
    krb5_free_creds_contents (context, &creds);
@


1.5
log
@Merge with heimdal-0.6
@
text
@d37 1
a37 1
RCSID("$KTH: klist.c,v 1.68.2.1 2003/05/08 18:59:56 lha Exp $");
d276 4
a279 4
    while (krb5_cc_next_cred (context,
			      ccache,
			      &cursor,
			      &creds) == 0) {
d287 2
@


1.4
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: klist.c,v 1.68 2002/10/17 11:59:51 joda Exp $");
d469 1
d504 1
a504 1
	t[parms.out_size] = 0;
a539 1
#endif /* KRB4 */
d599 1
a600 1
#endif
d615 1
a617 1
#endif
d667 1
a668 1
    if (!do_test) {
d674 1
d676 1
a676 1
	    if (do_v4 || do_v5)
d678 4
a684 1
#endif
@


1.3
log
@Remove all uses of setprogname() and getprogname() in kerberosV subtree.
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: klist.c,v 1.64 2001/05/11 19:55:13 assar Exp $");
d383 1
a383 1
    printf("v4-ticket file:	%s\n", file);
d409 1
a409 1
    printf("Principal:\t%s\n", krb_unparse_name (&princ));
d478 1
a478 1
    unsigned char t[128];
d486 1
a486 1
    for (i = 0; k_pioctl(NULL, VIOCGETTOK, &parms, 0) == 0; i++) {
d494 10
d507 2
d511 2
d521 1
a521 1
			 sizeof(buf1));
d524 1
a524 1
			     sizeof(buf2));
d531 1
a531 1
	  printf("User's (AFS ID %d) tokens for %s", ct.ViceId, cell);
d533 1
a533 1
	  printf("Tokens for %s", cell);
@


1.2
log
@use strlcpy instead
@
text
@a631 2
    setprogname (argv[0]);

@


1.1
log
@Initial revision
@
text
@d37 1
a37 1
RCSID("$KTH: klist.c,v 1.62 2001/01/25 12:37:01 assar Exp $");
d43 1
a43 1
    strcpy(s, ctime(&t)+ 4);
d52 1
a52 1
    strcpy(s, ctime(&t)+ 4);
d278 2
a279 2
			      &creds,
			      &cursor) == 0) {
d632 1
a632 1
    set_progname (argv[0]);
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d37 1
a37 1
RCSID("$KTH: klist.c,v 1.64 2001/05/11 19:55:13 assar Exp $");
d278 2
a279 2
			      &cursor,
			      &creds) == 0) {
d632 1
a632 1
    setprogname (argv[0]);
@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: klist.c,v 1.68 2002/10/17 11:59:51 joda Exp $");
d383 1
a383 1
    printf("%17s: %s\n", "V4-ticket file", file);
d409 1
a409 1
    printf ("%17s: %s\n", "Principal", krb_unparse_name(&princ));
d478 1
a478 1
    unsigned char t[4096];
d486 1
a486 1
    for (i = 0;; i++) {
a493 10
	if(k_pioctl(NULL, VIOCGETTOK, &parms, 0) < 0) {
	    if(errno == EDOM)
		break;
	    continue;
	}
	if(parms.out_size > sizeof(t))
	    continue;
	if(parms.out_size < sizeof(size_secret_tok))
	    continue;
	t[parms.out_size] = 0;
a496 2
	if (parms.out_size < (r - t) + sizeof(size_public_tok))
	    continue;
a498 2
	if (parms.out_size < (r - t) + size_public_tok + sizeof(int32_t))
	    continue;
d507 1
a507 1
		 sizeof(buf1));
d510 1
a510 1
		     sizeof(buf2));
d517 1
a517 1
	    printf("User's (AFS ID %d) tokens for %s", ct.ViceId, cell);
d519 1
a519 1
	    printf("Tokens for %s", cell);
@


1.1.1.4
log
@Import of heimdal-0.6, released earlier today.
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2003 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: klist.c,v 1.68.2.1 2003/05/08 18:59:56 lha Exp $");
a468 1
#endif /* KRB4 */
d503 1
a503 1
	t[min(parms.out_size,sizeof(t)-1)] = 0;
d539 1
d599 1
a600 1
static int do_tokens	= 0;
a614 1
#endif
d617 1
d669 1
a670 1
#ifdef KRB4
a675 1
#endif
d677 1
a677 1
	    if (do_v5)
a678 4
#ifdef KRB4
	    else if (do_v4)
		printf ("\n");
#endif
d682 1
@


1.1.1.5
log
@Import of heimdal-0.6.3
@
text
@d37 1
a37 1
RCSID("$KTH: klist.c,v 1.68.2.2 2003/10/13 15:13:39 joda Exp $");
d276 4
a279 4
    while ((ret = krb5_cc_next_cred (context,
				     ccache,
				     &cursor,
				     &creds)) == 0) {
a286 2
    if(ret != KRB5_CC_END)
	krb5_err(context, 1, ret, "krb5_cc_get_next");
@


1.1.1.6
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2004 Kungliga Tekniska Högskolan
d37 1
a37 1
RCSID("$KTH: klist.c,v 1.76 2005/04/24 19:47:44 lha Exp $");
d43 1
a43 1
    strlcpy(s, ctime(&t)+ 4, sizeof(s));
d52 1
a52 1
    strlcpy(s, ctime(&t)+ 4, sizeof(s));
d153 4
a156 1
	    ret = krb5_enctype_to_string(context, cred->session.keytype, &str);
d273 2
a274 1
	rtbl_set_separator(ct, "  ");
d285 1
a285 1
	krb5_free_cred_contents (context, &creds);
a313 2
    krb5_cc_clear_mcred(&pattern);

a320 1
    pattern.client = principal;
d325 1
a325 1
    krb5_free_cred_contents (context, &creds);
@


