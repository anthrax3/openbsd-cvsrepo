head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	HEIMDAL_0_7_2:1.1.1.4
	HEIMDAL_0_6_3:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.6
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.4
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2014.04.22.10.01.20;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.41;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.17.18.45;	author hin;	state dead;
branches;
next	1.1;

1.1
date	2001.05.25.07.52.38;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.52.38;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.56.28;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.10.29.15.55.43;	author biorn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.14.07.34.02;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@# Make prototypes from .c files
# $Id: make-proto.pl,v 1.3 2013/06/17 18:57:41 robert Exp $

##use Getopt::Std;
require 'getopts.pl';

my $comment = 0;
my $if_0 = 0;
my $brace = 0;
my $line = "";
my $debug = 0;
my $oproto = 1;
my $private_func_re = "^_";
my %depfunction = ();

Getopts('x:m:o:p:dqE:R:P:') || die "foo";

if($opt_d) {
    $debug = 1;
}

if($opt_q) {
    $oproto = 0;
}

if($opt_R) {
    $private_func_re = $opt_R;
}
my %flags = (
	  'multiline-proto' => 1,
	  'header' => 1,
	  'function-blocking' => 0,
	  'gnuc-attribute' => 1,
	  'cxx' => 1
	  );
if($opt_m) {
    foreach $i (split(/,/, $opt_m)) {
	if($i eq "roken") {
	    $flags{"multiline-proto"} = 0;
	    $flags{"header"} = 0;
	    $flags{"function-blocking"} = 0;
	    $flags{"gnuc-attribute"} = 0;
	    $flags{"cxx"} = 0;
	} else {
	    if(substr($i, 0, 3) eq "no-") {
		$flags{substr($i, 3)} = 0;
	    } else {
		$flags{$i} = 1;
	    }
	}
    }
}

if($opt_x) {
    open(EXP, $opt_x);
    while(<EXP>) {
	chomp;
	s/\#.*//g;
	s/\s+/ /g;
	if(/^([a-zA-Z0-9_]+)\s?(.*)$/) {
	    $exported{$1} = $2;
	} else {
	    print $_, "\n";
	}
    }
    close EXP;
}

while(<>) {
    print $brace, " ", $_ if($debug);
    
    # Handle C comments
    s@@/\*.*\*/@@@@;
    s@@//.*/@@@@;
    if ( s@@/\*.*@@@@) { $comment = 1;
    } elsif ($comment && s@@.*\*/@@@@) { $comment = 0;
    } elsif ($comment) { next; }

    if(/^\#if 0/) {
	$if_0 = 1;
    }
    if($if_0 && /^\#endif/) {
	$if_0 = 0;
    }
    if($if_0) { next }
    if(/^\s*\#/) {
	next;
    }
    if(/^\s*$/) {
	$line = "";
	next;
    }
    if(/\{/){
	if (!/\}/) {
	    $brace++;
	}
	$_ = $line;
	while(s/\*\//\ca/){
	    s/\/\*(.|\n)*\ca//;
	}
	s/^\s*//;
	s/\s*$//;
	s/\s+/ /g;
	if($_ =~ /\)$/){
	    if(!/^static/ && !/^PRIVATE/){
		$attr = "";
		if(m/(.*)(__attribute__\s?\(.*\))/) {
		    $attr .= " $2";
		    $_ = $1;
		}
		if(m/(.*)\s(\w+DEPRECATED_FUNCTION)\s?(\(.*\))(.*)/) {
		    $depfunction{$2} = 1;
		    $attr .= " $2$3";
		    $_ = "$1 $4";
		}
		if(m/(.*)\s(\w+DEPRECATED)(.*)/) {
		    $attr .= " $2";
		    $_ = "$1 $3";
		}
		# remove outer ()
		s/\s*\(/</;
		s/\)\s?$/>/;
		# remove , within ()
		while(s/\(([^()]*),(.*)\)/($1\$$2)/g){}
		s/\<\s*void\s*\>/<>/;
		# remove parameter names 
		if($opt_P eq "remove") {
		    s/(\s*)([a-zA-Z0-9_]+)([,>])/$3/g;
		    s/\s+\*/*/g;
		    s/\(\*(\s*)([a-zA-Z0-9_]+)\)/(*)/g;
		} elsif($opt_P eq "comment") {
		    s/([a-zA-Z0-9_]+)([,>])/\/\*$1\*\/$2/g;
		    s/\(\*([a-zA-Z0-9_]+)\)/(*\/\*$1\*\/)/g;
		}
		s/\<\>/<void>/;
		# add newlines before parameters
		if($flags{"multiline-proto"}) {
		    s/,\s*/,\n\t/g;
		} else {
		    s/,\s*/, /g;
		}
		# fix removed ,
		s/\$/,/g;
		# match function name
		/([a-zA-Z0-9_]+)\s*\</;
		$f = $1;
		if($oproto) {
		    $LP = "__P((";
		    $RP = "))";
		} else {
		    $LP = "(";
		    $RP = ")";
		}
		# only add newline if more than one parameter
                if($flags{"multiline-proto"} && /,/){ 
		    s/\</ $LP\n\t/;
		}else{
		    s/\</ $LP/;
		}
		s/\>/$RP/;
		# insert newline before function name
		if($flags{"multiline-proto"}) {
		    s/(.*)\s([a-zA-Z0-9_]+ \Q$LP\E)/$1\n$2/;
		}
		if($attr ne "") {
		    $_ .= "\n    $attr";
		}
		$_ = $_ . ";";
		$funcs{$f} = $_;
	    }
	}
	$line = "";
    }
    if(/\}/){
	$brace--;
    }
    if(/^\}/){
	$brace = 0;
    }
    if($brace == 0) {
	$line = $line . " " . $_;
    }
}

sub foo {
    local ($arg) = @@_;
    $_ = $arg;
    s/.*\/([^\/]*)/$1/;
    s/.*\\([^\\]*)/$1/;
    s/[^a-zA-Z0-9]/_/g;
    "__" . $_ . "__";
}

if($opt_o) {
    open(OUT, ">$opt_o");
    $block = &foo($opt_o);
} else {
    $block = "__public_h__";
}

if($opt_p) {
    open(PRIV, ">$opt_p");
    $private = &foo($opt_p);
} else {
    $private = "__private_h__";
}

$public_h = "";
$private_h = "";

$public_h_header .= "/* This is a generated file */
#ifndef $block
#define $block

";
if ($oproto) {
    $public_h_header .= "#ifdef __STDC__
#include <stdarg.h>
#ifndef __P
#define __P(x) x
#endif
#else
#ifndef __P
#define __P(x) ()
#endif
#endif

";
} else {
    $public_h_header .= "#include <stdarg.h>

";
}
$public_h_trailer = "";

$private_h_header = "/* This is a generated file */
#ifndef $private
#define $private

";
if($oproto) {
    $private_h_header .= "#ifdef __STDC__
#include <stdarg.h>
#ifndef __P
#define __P(x) x
#endif
#else
#ifndef __P
#define __P(x) ()
#endif
#endif

";
} else {
    $private_h_header .= "#include <stdarg.h>

";
}
$private_h_trailer = "";

foreach(sort keys %funcs){
    if(/^(main)$/) { next }
    if ($funcs{$_} =~ /\^/) {
	$beginblock = "#ifdef __BLOCKS__\n";
	$endblock = "#endif /* __BLOCKS__ */\n";
    } else {
	$beginblock = $endblock = "";
    }
    if(!defined($exported{$_}) && /$private_func_re/) {
	$private_h .= $beginblock . $funcs{$_} . "\n" . $endblock . "\n";
	if($funcs{$_} =~ /__attribute__/) {
	    $private_attribute_seen = 1;
	}
    } else {
	if($flags{"function-blocking"}) {
	    $fupper = uc $_;
	    if($exported{$_} =~ /proto/) {
		$public_h .= "#if !defined(HAVE_$fupper) || defined(NEED_${fupper}_PROTO)\n";
	    } else {
		$public_h .= "#ifndef HAVE_$fupper\n";
	    }
	}
	$public_h .= $beginblock . $funcs{$_} . "\n" . $endblock;
	if($funcs{$_} =~ /__attribute__/) {
	    $public_attribute_seen = 1;
	}
	if($flags{"function-blocking"}) {
	    $public_h .= "#endif\n";
	}
	$public_h .= "\n";
    }
}

if($flags{"gnuc-attribute"}) {
    if ($public_attribute_seen) {
	$public_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
#define __attribute__(x)
#endif

";
    }

    if ($private_attribute_seen) {
	$private_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
#define __attribute__(x)
#endif

";
    }
}

my $depstr = "";
my $undepstr = "";
foreach (keys %depfunction) {
    $depstr .= "#ifndef $_
#if defined(__GNUC__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1 )))
#define $_(X) __attribute__((__deprecated__))
#else
#define $_(X)
#endif
#endif


";
    $public_h_trailer .= "#undef $_

";
    $private_h_trailer .= "#undef $_
#define $_(X)

";
}

$public_h_header .= $depstr;
$private_h_header .= $depstr;


if($flags{"cxx"}) {
    $public_h_header .= "#ifdef __cplusplus
extern \"C\" {
#endif

";
    $public_h_trailer = "#ifdef __cplusplus
}
#endif

" . $public_h_trailer;

}
if ($opt_E) {
    $public_h_header .= "#ifndef $opt_E
#ifndef ${opt_E}_FUNCTION
#if defined(_WIN32)
#define ${opt_E}_FUNCTION __declspec(dllimport)
#define ${opt_E}_CALL __stdcall
#define ${opt_E}_VARIABLE __declspec(dllimport)
#else
#define ${opt_E}_FUNCTION
#define ${opt_E}_CALL
#define ${opt_E}_VARIABLE
#endif
#endif
#endif
";
    
    $private_h_header .= "#ifndef $opt_E
#ifndef ${opt_E}_FUNCTION
#if defined(_WIN32)
#define ${opt_E}_FUNCTION __declspec(dllimport)
#define ${opt_E}_CALL __stdcall
#define ${opt_E}_VARIABLE __declspec(dllimport)
#else
#define ${opt_E}_FUNCTION
#define ${opt_E}_CALL
#define ${opt_E}_VARIABLE
#endif
#endif
#endif

";
}
    
$public_h_trailer .= $undepstr;
$private_h_trailer .= $undepstr;

if ($public_h ne "" && $flags{"header"}) {
    $public_h = $public_h_header . $public_h . 
	$public_h_trailer . "#endif /* $block */\n";
}
if ($private_h ne "" && $flags{"header"}) {
    $private_h = $private_h_header . $private_h .
	$private_h_trailer . "#endif /* $private */\n";
}

if($opt_o) {
    print OUT $public_h;
} 
if($opt_p) {
    print PRIV $private_h;
} 

close OUT;
close PRIV;
@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d2 1
a2 1
# $Id$
@


1.2
log
@These files are not use by us, so they're removed to make the tree
a little bit leaner, and to get rid of some bad string functions.
@
text
@d2 1
a2 1
# $KTH: make-proto.pl,v 1.11 1999/04/15 12:37:54 joda Exp $
d7 8
a14 3
$brace = 0;
$line = "";
$debug = 0;
d16 1
a16 1
do Getopts('o:p:d') || die "foo";
d22 47
d71 8
d94 3
d102 1
a102 1
	s/\s$//;
d104 1
a104 1
	if($line =~ /\)\s$/){
d106 3
a108 2
		if(/(.*)(__attribute__\s?\(.*\))/) {
		    $attr = $2;
d110 9
a118 2
		} else {
		    $attr = "";
d121 2
a122 2
		s/\s*\(/@@/;
		s/\)\s?$/@@/;
d125 17
a141 1
		s/,\s*/,\n\t/g;
d145 1
a145 1
		/([a-zA-Z0-9_]+)\s*@@/;
d147 7
d155 2
a156 5
		$LP = "((";  # XXX workaround for indentation bug in emacs
		$RP = "))";
		$P = "__P((";
                if(/,/){ 
		    s/@@/ __P$LP\n\t/;
d158 1
a158 1
		    s/@@/ __P$LP/;
d160 1
a160 1
		s/@@/$RP/;
d162 3
a164 1
		s/(.*)\s([a-zA-Z0-9_]+ __P)/$1\n$2/;
a172 1
	$brace++;
d189 1
d211 1
a211 1
$public_h_header = "/* This is a generated file */
d215 3
a217 1
#ifdef __STDC__
d229 6
d240 3
a242 1
#ifdef __STDC__
d254 6
d263 8
a270 2
    if(/^_/) {
	$private_h .= $funcs{$_} . "\n\n";
d275 9
a283 1
	$public_h .= $funcs{$_} . "\n\n";
d287 4
d294 11
a304 2
if ($public_attribute_seen) {
    $public_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
d309 1
d312 29
a340 3
if ($private_attribute_seen) {
    $private_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
#define __attribute__(x)
d344 1
d346 1
d348 32
d381 9
a389 2
if ($public_h ne "") {
    $public_h = $public_h_header . $public_h . "#endif /* $block */\n";
d391 3
a393 2
if ($private_h ne "") {
    $private_h = $private_h_header . $private_h . "#endif /* $private */\n";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
# $KTH: make-proto.pl,v 1.12 2001/06/23 22:29:18 assar Exp $
a33 3
	if (!/\}/) {
	    $brace++;
	}
d80 1
@


1.1.1.3
log
@Import of heimdal-0.6.3
@
text
@d2 1
a2 1
# $KTH: make-proto.pl,v 1.16 2002/09/19 19:29:42 joda Exp $
a9 2
$oproto = 1;
$private_func_re = "^_";
d11 1
a11 1
do Getopts('o:p:dqR:P:') || die "foo";
a16 8
if($opt_q) {
    $oproto = 0;
}

if($opt_R) {
    $private_func_re = $opt_R;
}

d42 1
a42 1
	s/\s*$//;
d44 1
a44 1
	if($_ =~ /\)$/){
d53 2
a54 2
		s/\s*\(/</;
		s/\)\s?$/>/;
a56 11
		s/\<\s*void\s*\>/<>/;
		# remove parameter names 
		if($opt_P eq "remove") {
		    s/(\s*)([a-zA-Z0-9_]+)([,>])/$3/g;
		    s/\(\*(\s*)([a-zA-Z0-9_]+)\)/(*)/g;
		} elsif($opt_P eq "comment") {
		    s/([a-zA-Z0-9_]+)([,>])/\/\*$1\*\/$2/g;
		    s/\(\*([a-zA-Z0-9_]+)\)/(*\/\*$1\*\/)/g;
		}
		s/\<\>/<void>/;
		# add newlines before parameters
d61 1
a61 1
		/([a-zA-Z0-9_]+)\s*\</;
a62 7
		if($oproto) {
		    $LP = "__P((";
		    $RP = "))";
		} else {
		    $LP = "(";
		    $RP = ")";
		}
d64 3
d68 1
a68 1
		    s/\</ $LP\n\t/;
d70 1
a70 1
		    s/\</ $LP/;
d72 1
a72 1
		s/\>/$RP/;
d74 1
a74 1
		s/(.*)\s([a-zA-Z0-9_]+ \Q$LP\E)/$1\n$2/;
d124 1
a124 3
";
if ($oproto) {
$public_h_header .= "#ifdef __STDC__
a135 5
} else {
    $public_h_header .= "#include <stdarg.h>

";
}
d141 1
a141 3
";
if($oproto) {
$private_h_header .= "#ifdef __STDC__
a152 2
} else {
    $private_h_header .= "#include <stdarg.h>
a153 2
";
}
d156 1
a156 1
    if(/$private_func_re/) {
@


1.1.1.4
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
# $KTH: make-proto.pl,v 1.20 2004/09/03 08:50:57 lha Exp $
d13 1
a13 1
do Getopts('x:m:o:p:dqE:R:P:') || die "foo";
a25 39
%flags = (
	  'multiline-proto' => 1,
	  'header' => 1,
	  'function-blocking' => 0,
	  'gnuc-attribute' => 1,
	  'cxx' => 1
	  );
if($opt_m) {
    foreach $i (split(/,/, $opt_m)) {
	if($i eq "roken") {
	    $flags{"multiline-proto"} = 0;
	    $flags{"header"} = 0;
	    $flags{"function-blocking"} = 0;
	    $flags{"gnuc-attribute"} = 0;
	    $flags{"cxx"} = 0;
	} else {
	    if(substr($i, 0, 3) eq "no-") {
		$flags{substr($i, 3)} = 0;
	    } else {
		$flags{$i} = 1;
	    }
	}
    }
}

if($opt_x) {
    open(EXP, $opt_x);
    while(<EXP>) {
	chomp;
	s/\#.*//g;
	s/\s+/ /g;
	if(/^([a-zA-Z0-9_]+)\s?(.*)$/) {
	    $exported{$1} = $2;
	} else {
	    print $_, "\n";
	}
    }
    close EXP;
}
a70 1
		    s/\s+\*/*/g;
d78 1
a78 5
		if($flags{"multiline-proto"}) {
		    s/,\s*/,\n\t/g;
		} else {
		    s/,\s*/, /g;
		}
d92 1
a92 1
                if($flags{"multiline-proto"} && /,/){ 
d99 1
a99 3
		if($flags{"multiline-proto"}) {
		    s/(.*)\s([a-zA-Z0-9_]+ \Q$LP\E)/$1\n$2/;
		}
d145 1
a145 1
$public_h_header .= "/* This is a generated file */
d151 1
a151 1
    $public_h_header .= "#ifdef __STDC__
a167 1
$public_h_trailer = "";
d175 1
a175 1
    $private_h_header .= "#ifdef __STDC__
a191 2
$private_h_trailer = "";

d194 1
a194 1
    if(!defined($exported{$_}) && /$private_func_re/) {
d200 1
a200 9
	if($flags{"function-blocking"}) {
	    $fupper = uc $_;
	    if($exported{$_} =~ /proto/) {
		$public_h .= "#if !defined(HAVE_$fupper) || defined(NEED_${fupper}_PROTO)\n";
	    } else {
		$public_h .= "#ifndef HAVE_$fupper\n";
	    }
	}
	$public_h .= $funcs{$_} . "\n";
a203 4
	if($flags{"function-blocking"}) {
	    $public_h .= "#endif\n";
	}
	$public_h .= "\n";
d207 2
a208 3
if($flags{"gnuc-attribute"}) {
    if ($public_attribute_seen) {
	$public_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
d213 1
a213 1
    }
d215 2
a216 2
    if ($private_attribute_seen) {
	$private_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
a220 14
    }
}
if($flags{"cxx"}) {
    $public_h_header .= "#ifdef __cplusplus
extern \"C\" {
#endif

";
    $public_h_trailer .= "#ifdef __cplusplus
}
#endif

";

a221 8
if ($opt_E) {
    $public_h_header .= "#ifndef $opt_E
#if defined(_WIN32)
#define $opt_E _stdcall
#else
#define $opt_E
#endif
#endif
a222 9
";
    
    $private_h_header .= "#ifndef $opt_E
#if defined(_WIN32)
#define $opt_E _stdcall
#else
#define $opt_E
#endif
#endif
d224 2
a225 1
";
d227 2
a228 8
    
if ($public_h ne "" && $flags{"header"}) {
    $public_h = $public_h_header . $public_h . 
	$public_h_trailer . "#endif /* $block */\n";
}
if ($private_h ne "" && $flags{"header"}) {
    $private_h = $private_h_header . $private_h .
	$private_h_trailer . "#endif /* $private */\n";
@


