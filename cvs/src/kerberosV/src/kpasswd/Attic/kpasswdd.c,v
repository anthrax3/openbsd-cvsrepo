head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.26
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.24
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.22
	OPENBSD_5_0:1.6.0.20
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.18
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.16
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.12
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.14
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.10
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	HEIMDAL_0_6:1.1.1.4
	HEIMDAL_0_6RC1:1.1.1.4
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	HEIMDAL_0_4e:1.1.1.3
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	HEIMDAL_0_3f:1.1.1.2
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.22.10.01.26;	author reyk;	state dead;
branches;
next	1.7;

1.7
date	2013.06.17.18.57.42;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.14.08.15.03;	author biorn;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.11.03.39.59;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.06.09.10.02;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.18.00.48.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.49.48;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.49.48;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.22.21.21.59;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.02.06.08.54.56;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.02.15.34;	author hin;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.32.48;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997-2005 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kpasswd_locl.h"
RCSID("$Id: kpasswdd.c,v 1.7 2013/06/17 18:57:42 robert Exp $");

#include <kadm5/admin.h>
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
#include <hdb.h>
#include <kadm5/private.h>

static krb5_context context;
static krb5_log_facility *log_facility;

static struct getarg_strings addresses_str;
krb5_addresses explicit_addresses;

static sig_atomic_t exit_flag = 0;

static void
add_one_address (const char *str, int first)
{
    krb5_error_code ret;
    krb5_addresses tmp;

    ret = krb5_parse_address (context, str, &tmp);
    if (ret)
	krb5_err (context, 1, ret, "parse_address `%s'", str);
    if (first)
	krb5_copy_addresses(context, &tmp, &explicit_addresses);
    else
	krb5_append_addresses(context, &explicit_addresses, &tmp);
    krb5_free_addresses (context, &tmp);
}

static void
send_reply (int s,
	    struct sockaddr *sa,
	    int sa_size,
	    krb5_data *ap_rep,
	    krb5_data *rest)
{
    struct msghdr msghdr;
    struct iovec iov[3];
    uint16_t len, ap_rep_len;
    u_char header[6];
    u_char *p;

    if (ap_rep)
	ap_rep_len = ap_rep->length;
    else
	ap_rep_len = 0;

    len = 6 + ap_rep_len + rest->length;
    p = header;
    *p++ = (len >> 8) & 0xFF;
    *p++ = (len >> 0) & 0xFF;
    *p++ = 0;
    *p++ = 1;
    *p++ = (ap_rep_len >> 8) & 0xFF;
    *p++ = (ap_rep_len >> 0) & 0xFF;

    memset (&msghdr, 0, sizeof(msghdr));
    msghdr.msg_name       = (void *)sa;
    msghdr.msg_namelen    = sa_size;
    msghdr.msg_iov        = iov;
    msghdr.msg_iovlen     = sizeof(iov)/sizeof(*iov);
#if 0
    msghdr.msg_control    = NULL;
    msghdr.msg_controllen = 0;
#endif

    iov[0].iov_base       = (char *)header;
    iov[0].iov_len        = 6;
    if (ap_rep_len) {
	iov[1].iov_base   = ap_rep->data;
	iov[1].iov_len    = ap_rep->length;
    } else {
	iov[1].iov_base   = NULL;
	iov[1].iov_len    = 0;
    }
    iov[2].iov_base       = rest->data;
    iov[2].iov_len        = rest->length;

    if (sendmsg (s, &msghdr, 0) < 0)
	krb5_warn (context, errno, "sendmsg");
}

static int
make_result (krb5_data *data,
	     uint16_t result_code,
	     const char *expl)
{
    char *str;
    krb5_data_zero (data);

    data->length = asprintf (&str,
			     "%c%c%s",
			     (result_code >> 8) & 0xFF,
			     result_code & 0xFF,
			     expl);

    if (str == NULL) {
	krb5_warnx (context, "Out of memory generating error reply");
	return 1;
    }
    data->data = str;
    return 0;
}

static void
reply_error (krb5_realm realm,
	     int s,
	     struct sockaddr *sa,
	     int sa_size,
	     krb5_error_code error_code,
	     uint16_t result_code,
	     const char *expl)
{
    krb5_error_code ret;
    krb5_data error_data;
    krb5_data e_data;
    krb5_principal server = NULL;

    if (make_result(&e_data, result_code, expl))
	return;

    if (realm) {
	ret = krb5_make_principal (context, &server, realm,
				   "kadmin", "changepw", NULL);
	if (ret) {
	    krb5_data_free (&e_data);
	    return;
	}
    }

    ret = krb5_mk_error (context,
			 error_code,
			 NULL,
			 &e_data,
			 NULL,
			 server,
			 NULL,
			 NULL,
			 &error_data);
    if (server)
	krb5_free_principal(context, server);
    krb5_data_free (&e_data);
    if (ret) {
	krb5_warn (context, ret, "Could not even generate error reply");
	return;
    }
    send_reply (s, sa, sa_size, NULL, &error_data);
    krb5_data_free (&error_data);
}

static void
reply_priv (krb5_auth_context auth_context,
	    int s,
	    struct sockaddr *sa,
	    int sa_size,
	    uint16_t result_code,
	    const char *expl)
{
    krb5_error_code ret;
    krb5_data krb_priv_data;
    krb5_data ap_rep_data;
    krb5_data e_data;

    ret = krb5_mk_rep (context,
		       auth_context,
		       &ap_rep_data);
    if (ret) {
	krb5_warn (context, ret, "Could not even generate error reply");
	return;
    }

    if (make_result(&e_data, result_code, expl))
	return;

    ret = krb5_mk_priv (context,
			auth_context,
			&e_data,
			&krb_priv_data,
			NULL);
    krb5_data_free (&e_data);
    if (ret) {
	krb5_warn (context, ret, "Could not even generate error reply");
	return;
    }
    send_reply (s, sa, sa_size, &ap_rep_data, &krb_priv_data);
    krb5_data_free (&ap_rep_data);
    krb5_data_free (&krb_priv_data);
}

/*
 * Change the password for `principal', sending the reply back on `s'
 * (`sa', `sa_size') to `pwd_data'.
 */

static void
change (krb5_auth_context auth_context,
	krb5_principal admin_principal,
	uint16_t version,
	int s,
	struct sockaddr *sa,
	int sa_size,
	krb5_data *in_data)
{
    krb5_error_code ret;
    char *client = NULL, *admin = NULL;
    const char *pwd_reason;
    kadm5_config_params conf;
    void *kadm5_handle = NULL;
    krb5_principal principal = NULL;
    krb5_data *pwd_data = NULL;
    char *tmp;
    ChangePasswdDataMS chpw;

    memset (&conf, 0, sizeof(conf));
    memset(&chpw, 0, sizeof(chpw));

    if (version == KRB5_KPASSWD_VERS_CHANGEPW) {
	ret = krb5_copy_data(context, in_data, &pwd_data);
	if (ret) {
	    krb5_warn (context, ret, "krb5_copy_data");
	    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_MALFORMED,
			"out out memory copying password");
	    return;
	}
	principal = admin_principal;
    } else if (version == KRB5_KPASSWD_VERS_SETPW) {
	size_t len;

	ret = decode_ChangePasswdDataMS(in_data->data, in_data->length,
					&chpw, &len);
	if (ret) {
	    krb5_warn (context, ret, "decode_ChangePasswdDataMS");
	    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_MALFORMED,
			"malformed ChangePasswdData");
	    return;
	}


	ret = krb5_copy_data(context, &chpw.newpasswd, &pwd_data);
	if (ret) {
	    krb5_warn (context, ret, "krb5_copy_data");
	    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_MALFORMED,
			"out out memory copying password");
	    goto out;
	}

	if (chpw.targname == NULL && chpw.targrealm != NULL) {
	    krb5_warn (context, ret, "kadm5_init_with_password_ctx");
	    reply_priv (auth_context, s, sa, sa_size,
			KRB5_KPASSWD_MALFORMED,
			"targrealm but not targname");
	    goto out;
	}

	if (chpw.targname) {
	    krb5_principal_data princ;

	    princ.name = *chpw.targname;
	    princ.realm = *chpw.targrealm;
	    if (princ.realm == NULL) {
		ret = krb5_get_default_realm(context, &princ.realm);

		if (ret) {
		    krb5_warnx (context,
				"kadm5_init_with_password_ctx: "
				"failed to allocate realm");
		    reply_priv (auth_context, s, sa, sa_size,
				KRB5_KPASSWD_SOFTERROR,
				"failed to allocate realm");
		    goto out;
		}
	    }
	    ret = krb5_copy_principal(context, &princ, &principal);
	    if (*chpw.targrealm == NULL)
		free(princ.realm);
	    if (ret) {
		krb5_warn(context, ret, "krb5_copy_principal");
		reply_priv(auth_context, s, sa, sa_size,
			   KRB5_KPASSWD_HARDERROR,
			   "failed to allocate principal");
		goto out;
	    }
	} else
	    principal = admin_principal;
    } else {
	krb5_warnx (context, "kadm5_init_with_password_ctx: unknown proto");
	reply_priv (auth_context, s, sa, sa_size,
		    KRB5_KPASSWD_HARDERROR,
		    "Unknown protocol used");
	return;
    }

    ret = krb5_unparse_name (context, admin_principal, &admin);
    if (ret) {
	krb5_warn (context, ret, "unparse_name failed");
	reply_priv (auth_context, s, sa, sa_size,
		    KRB5_KPASSWD_HARDERROR, "out of memory error");
	goto out;
    }

    conf.realm = principal->realm;
    conf.mask |= KADM5_CONFIG_REALM;

    ret = kadm5_init_with_password_ctx(context,
				       admin,
				       NULL,
				       KADM5_ADMIN_SERVICE,
				       &conf, 0, 0,
				       &kadm5_handle);
    if (ret) {
	krb5_warn (context, ret, "kadm5_init_with_password_ctx");
	reply_priv (auth_context, s, sa, sa_size, 2,
		    "Internal error");
	goto out;
    }

    ret = krb5_unparse_name(context, principal, &client);
    if (ret) {
	krb5_warn (context, ret, "unparse_name failed");
	reply_priv (auth_context, s, sa, sa_size,
		    KRB5_KPASSWD_HARDERROR, "out of memory error");
	goto out;
    }

    /*
     * Check password quality if not changing as administrator
     */

    if (krb5_principal_compare(context, admin_principal, principal) == TRUE) {

	pwd_reason = kadm5_check_password_quality (context, principal,
						   pwd_data);
	if (pwd_reason != NULL ) {
	    krb5_warnx (context,
			"%s didn't pass password quality check with error: %s",
			client, pwd_reason);
	    reply_priv (auth_context, s, sa, sa_size,
			KRB5_KPASSWD_SOFTERROR, pwd_reason);
	    goto out;
	}
	krb5_warnx (context, "Changing password for %s", client);
    } else {
	ret = _kadm5_acl_check_permission(kadm5_handle, KADM5_PRIV_CPW,
					  principal);
	if (ret) {
	    krb5_warn (context, ret,
		       "Check ACL failed for %s for changing %s password",
		       admin, client);
	    reply_priv (auth_context, s, sa, sa_size,
			KRB5_KPASSWD_HARDERROR, "permission denied");
	    goto out;
	}
	krb5_warnx (context, "%s is changing password for %s", admin, client);
    }

    ret = krb5_data_realloc(pwd_data, pwd_data->length + 1);
    if (ret) {
	krb5_warn (context, ret, "malloc: out of memory");
	reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_HARDERROR,
		    "Internal error");
	goto out;
    }
    tmp = pwd_data->data;
    tmp[pwd_data->length - 1] = '\0';

    ret = kadm5_s_chpass_principal_cond (kadm5_handle, principal, tmp);
    krb5_free_data (context, pwd_data);
    pwd_data = NULL;
    if (ret) {
	const char *str = krb5_get_error_message(context, ret);
	krb5_warnx(context, "kadm5_s_chpass_principal_cond: %s", str);
	reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_SOFTERROR,
		    str ? str : "Internal error");
	krb5_free_error_message(context, str);
	goto out;
    }
    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_SUCCESS,
		"Password changed");
out:
    free_ChangePasswdDataMS(&chpw);
    if (principal != admin_principal)
	krb5_free_principal(context, principal);
    if (admin)
	free(admin);
    if (client)
	free(client);
    if (pwd_data)
	krb5_free_data(context, pwd_data);
    if (kadm5_handle)
	kadm5_destroy (kadm5_handle);
}

static int
verify (krb5_auth_context *auth_context,
	krb5_realm *realms,
	krb5_keytab keytab,
	krb5_ticket **ticket,
	krb5_data *out_data,
	uint16_t *version,
	int s,
	struct sockaddr *sa,
	int sa_size,
	u_char *msg,
	size_t len,
	krb5_address *client_addr)
{
    krb5_error_code ret;
    uint16_t pkt_len, pkt_ver, ap_req_len;
    krb5_data ap_req_data;
    krb5_data krb_priv_data;
    krb5_realm *r;

    /*
     * Only send an error reply if the request passes basic length
     * verification.  Otherwise, kpasswdd would reply to every UDP packet,
     * allowing an attacker to set up a ping-pong DoS attack via a spoofed UDP
     * packet with a source address of another UDP service that also replies
     * to every packet.
     *
     * Also suppress the error reply if ap_req_len is 0, which indicates
     * either an invalid request or an error packet.  An error packet may be
     * the result of a ping-pong attacker pointing us at another kpasswdd.
     */
    pkt_len = (msg[0] << 8) | (msg[1]);
    pkt_ver = (msg[2] << 8) | (msg[3]);
    ap_req_len = (msg[4] << 8) | (msg[5]);
    if (pkt_len != len) {
	krb5_warnx (context, "Strange len: %ld != %ld",
		    (long)pkt_len, (long)len);
	return 1;
    }
    if (ap_req_len == 0) {
	krb5_warnx (context, "Request is error packet (ap_req_len == 0)");
	return 1;
    }
    if (pkt_ver != KRB5_KPASSWD_VERS_CHANGEPW &&
	pkt_ver != KRB5_KPASSWD_VERS_SETPW) {
	krb5_warnx (context, "Bad version (%d)", pkt_ver);
	reply_error (NULL, s, sa, sa_size, 0, 1, "Wrong program version");
	return 1;
    }
    *version = pkt_ver;

    ap_req_data.data   = msg + 6;
    ap_req_data.length = ap_req_len;

    ret = krb5_rd_req (context,
		       auth_context,
		       &ap_req_data,
		       NULL,
		       keytab,
		       NULL,
		       ticket);
    if (ret) {
	krb5_warn (context, ret, "krb5_rd_req");
	reply_error (NULL, s, sa, sa_size, ret, 3, "Authentication failed");
	return 1;
    }

    /* verify realm and principal */
    for (r = realms; *r != NULL; r++) {
	krb5_principal principal;
	krb5_boolean same;

	ret = krb5_make_principal (context,
				   &principal,
				   *r,
				   "kadmin",
				   "changepw",
				   NULL);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_make_principal");

	same = krb5_principal_compare(context, principal, (*ticket)->server);
	krb5_free_principal(context, principal);
	if (same == TRUE)
	    break;
    }
    if (*r == NULL) {
	char *str;
	krb5_unparse_name(context, (*ticket)->server, &str);
	krb5_warnx (context, "client used not valid principal %s", str);
	free(str);
	reply_error (NULL, s, sa, sa_size, ret, 1,
		     "Bad request");
	goto out;
    }

    if (strcmp((*ticket)->server->realm, (*ticket)->client->realm) != 0) {
	krb5_warnx (context, "server realm (%s) not same a client realm (%s)",
		    (*ticket)->server->realm, (*ticket)->client->realm);
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 1,
		     "Bad request");
	goto out;
    }

    if (!(*ticket)->ticket.flags.initial) {
	krb5_warnx (context, "initial flag not set");
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 1,
		     "Bad request");
	goto out;
    }
    krb_priv_data.data   = msg + 6 + ap_req_len;
    krb_priv_data.length = len - 6 - ap_req_len;

    /*
     * Only enforce client addresses on on tickets with addresses.  If
     * its addressless, we are guessing its behind NAT and really
     * can't know this information.
     */

    if ((*ticket)->ticket.caddr && (*ticket)->ticket.caddr->len > 0) {
	ret = krb5_auth_con_setaddrs (context, *auth_context,
				      NULL, client_addr);
	if (ret) {
	    krb5_warn (context, ret, "krb5_auth_con_setaddr(this)");
	    goto out;
	}
    }

    ret = krb5_rd_priv (context,
			*auth_context,
			&krb_priv_data,
			out_data,
			NULL);

    if (ret) {
	krb5_warn (context, ret, "krb5_rd_priv");
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 3,
		     "Bad request");
	goto out;
    }
    return 0;
out:
    krb5_free_ticket (context, *ticket);
    ticket = NULL;
    return 1;
}

static void
process (krb5_realm *realms,
	 krb5_keytab keytab,
	 int s,
	 krb5_address *this_addr,
	 struct sockaddr *sa,
	 int sa_size,
	 u_char *msg,
	 int len)
{
    krb5_error_code ret;
    krb5_auth_context auth_context = NULL;
    krb5_data out_data;
    krb5_ticket *ticket;
    krb5_address other_addr;
    uint16_t version;

    memset(&other_addr, 0, sizeof(other_addr));
    krb5_data_zero (&out_data);

    ret = krb5_auth_con_init (context, &auth_context);
    if (ret) {
	krb5_warn (context, ret, "krb5_auth_con_init");
	return;
    }

    krb5_auth_con_setflags (context, auth_context,
			    KRB5_AUTH_CONTEXT_DO_SEQUENCE);

    ret = krb5_sockaddr2address (context, sa, &other_addr);
    if (ret) {
	krb5_warn (context, ret, "krb5_sockaddr2address");
	goto out;
    }

    ret = krb5_auth_con_setaddrs (context, auth_context, this_addr, NULL);
    if (ret) {
	krb5_warn (context, ret, "krb5_auth_con_setaddr(this)");
	goto out;
    }

    if (verify (&auth_context, realms, keytab, &ticket, &out_data,
		&version, s, sa, sa_size, msg, len, &other_addr) == 0)
    {
	/*
	 * We always set the client_addr, to assume that the client
	 * can ignore it if it choose to do so (just the server does
	 * so for addressless tickets).
	 */
	ret = krb5_auth_con_setaddrs (context, auth_context, 
				      this_addr, &other_addr);
	if (ret) {
	    krb5_warn (context, ret, "krb5_auth_con_setaddr(other)");
	    goto out;
	}

	change (auth_context,
		ticket->client,
		version,
		s,
		sa, sa_size,
		&out_data);
	memset (out_data.data, 0, out_data.length);
	krb5_free_ticket (context, ticket);
    }

out:
    krb5_free_address(context, &other_addr);
    krb5_data_free(&out_data);
    krb5_auth_con_free(context, auth_context);
}

static int
doit (krb5_keytab keytab, int port)
{
    krb5_error_code ret;
    int *sockets;
    int maxfd;
    krb5_realm *realms;
    krb5_addresses addrs;
    unsigned n, i;
    fd_set real_fdset;
    struct sockaddr_storage __ss;
    struct sockaddr *sa = (struct sockaddr *)&__ss;

    ret = krb5_get_default_realms(context, &realms);
    if (ret)
	krb5_err (context, 1, ret, "krb5_get_default_realms");

    if (explicit_addresses.len) {
	addrs = explicit_addresses;
    } else {
	ret = krb5_get_all_server_addrs (context, &addrs);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_get_all_server_addrs");
    }
    n = addrs.len;

    sockets = malloc (n * sizeof(*sockets));
    if (sockets == NULL)
	krb5_errx (context, 1, "out of memory");
    maxfd = -1;
    FD_ZERO(&real_fdset);
    for (i = 0; i < n; ++i) {
	krb5_socklen_t sa_size = sizeof(__ss);

	krb5_addr2sockaddr (context, &addrs.val[i], sa, &sa_size, port);

	sockets[i] = socket (sa->sa_family, SOCK_DGRAM, 0);
	if (sockets[i] < 0)
	    krb5_err (context, 1, errno, "socket");
	if (bind (sockets[i], sa, sa_size) < 0) {
	    char str[128];
	    size_t len;
	    int save_errno = errno;

	    ret = krb5_print_address (&addrs.val[i], str, sizeof(str), &len);
	    if (ret)
		strlcpy(str, "unknown address", sizeof(str));
	    krb5_warn (context, save_errno, "bind(%s)", str);
	    continue;
	}
	maxfd = max (maxfd, sockets[i]);
	if (maxfd >= FD_SETSIZE)
	    krb5_errx (context, 1, "fd too large");
	FD_SET(sockets[i], &real_fdset);
    }
    if (maxfd == -1)
	krb5_errx (context, 1, "No sockets!");

    while(exit_flag == 0) {
	krb5_ssize_t retx;
	fd_set fdset = real_fdset;

	retx = select (maxfd + 1, &fdset, NULL, NULL, NULL);
	if (retx < 0) {
	    if (errno == EINTR)
		continue;
	    else
		krb5_err (context, 1, errno, "select");
	}
	for (i = 0; i < n; ++i)
	    if (FD_ISSET(sockets[i], &fdset)) {
		u_char buf[BUFSIZ];
		socklen_t addrlen = sizeof(__ss);

		retx = recvfrom(sockets[i], buf, sizeof(buf), 0,
				sa, &addrlen);
		if (retx < 0) {
		    if(errno == EINTR)
			break;
		    else
			krb5_err (context, 1, errno, "recvfrom");
		}

		process (realms, keytab, sockets[i],
			 &addrs.val[i],
			 sa, addrlen,
			 buf, retx);
	    }
    }

    for (i = 0; i < n; ++i)
	close(sockets[i]);
    free(sockets);

    krb5_free_addresses (context, &addrs);
    krb5_free_host_realm (context, realms);
    krb5_free_context (context);
    return 0;
}

static RETSIGTYPE
sigterm(int sig)
{
    exit_flag = 1;
}

static const char *check_library  = NULL;
static const char *check_function = NULL;
static getarg_strings policy_libraries = { 0, NULL };
static char sHDB[] = "HDB:";
static char *keytab_str = sHDB;
static char *realm_str;
static int version_flag;
static int help_flag;
static char *port_str;
static char *config_file;

struct getargs args[] = {
#ifdef HAVE_DLOPEN
    { "check-library", 0, arg_string, &check_library,
      "library to load password check function from", "library" },
    { "check-function", 0, arg_string, &check_function,
      "password check function to load", "function" },
    { "policy-libraries", 0, arg_strings, &policy_libraries,
      "password check function to load", "function" },
#endif
    { "addresses",	0,	arg_strings, &addresses_str,
      "addresses to listen on", "list of addresses" },
    { "keytab", 'k', arg_string, &keytab_str,
      "keytab to get authentication key from", "kspec" },
    { "config-file", 'c', arg_string, &config_file, NULL, NULL },
    { "realm", 'r', arg_string, &realm_str, "default realm", "realm" },
    { "port",  'p', arg_string, &port_str, "port", NULL },
    { "version", 0, arg_flag, &version_flag, NULL, NULL },
    { "help", 0, arg_flag, &help_flag, NULL, NULL }
};
int num_args = sizeof(args) / sizeof(args[0]);

int
main (int argc, char **argv)
{
    krb5_keytab keytab;
    krb5_error_code ret;
    char **files;
    int port, i;

    krb5_program_setup(&context, argc, argv, args, num_args, NULL);

    if(help_flag)
	krb5_std_usage(0, args, num_args);
    if(version_flag) {
	print_version(NULL);
	exit(0);
    }

    if (config_file == NULL) {
	asprintf(&config_file, "%s/kdc.conf", hdb_db_dir(context));
	if (config_file == NULL)
	    errx(1, "out of memory");
    }

    ret = krb5_prepend_config_files_default(config_file, &files);
    if (ret)
	krb5_err(context, 1, ret, "getting configuration files");

    ret = krb5_set_config_files(context, files);
    krb5_free_config_files(files);
    if (ret)
	krb5_err(context, 1, ret, "reading configuration files");

    if(realm_str)
	krb5_set_default_realm(context, realm_str);

    krb5_openlog (context, "kpasswdd", &log_facility);
    krb5_set_warn_dest(context, log_facility);

    if (port_str != NULL) {
	struct servent *s = roken_getservbyname (port_str, "udp");

	if (s != NULL)
	    port = s->s_port;
	else {
	    char *ptr;

	    port = strtol (port_str, &ptr, 10);
	    if (port == 0 && ptr == port_str)
		krb5_errx (context, 1, "bad port `%s'", port_str);
	    port = htons(port);
	}
    } else
	port = krb5_getportbyname (context, "kpasswd", "udp", KPASSWD_PORT);

    ret = krb5_kt_register(context, &hdb_kt_ops);
    if(ret)
	krb5_err(context, 1, ret, "krb5_kt_register");

    ret = krb5_kt_resolve(context, keytab_str, &keytab);
    if(ret)
	krb5_err(context, 1, ret, "%s", keytab_str);

    kadm5_setup_passwd_quality_check (context, check_library, check_function);

    for (i = 0; i < policy_libraries.num_strings; i++) {
	ret = kadm5_add_passwd_quality_verifier(context,
						policy_libraries.strings[i]);
	if (ret)
	    krb5_err(context, 1, ret, "kadm5_add_passwd_quality_verifier");
    }
    ret = kadm5_add_passwd_quality_verifier(context, NULL);
    if (ret)
	krb5_err(context, 1, ret, "kadm5_add_passwd_quality_verifier");


    explicit_addresses.len = 0;

    if (addresses_str.num_strings) {
	int j;

	for (j = 0; j < addresses_str.num_strings; ++j)
	    add_one_address (addresses_str.strings[j], j == 0);
	free_getarg_strings (&addresses_str);
    } else {
	char **foo = krb5_config_get_strings (context, NULL,
					      "kdc", "addresses", NULL);

	if (foo != NULL) {
	    add_one_address (*foo++, TRUE);
	    while (*foo)
		add_one_address (*foo++, FALSE);
	}
    }

#ifdef HAVE_SIGACTION
    {
	struct sigaction sa;

	sa.sa_flags = 0;
	sa.sa_handler = sigterm;
	sigemptyset(&sa.sa_mask);

	sigaction(SIGINT,  &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);
    }
#else
    signal(SIGINT,  sigterm);
    signal(SIGTERM, sigterm);
#endif

    pidfile(NULL);

    return doit (keytab, port);
}
@


1.7
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d35 1
a35 1
RCSID("$Id$");
@


1.6
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d2 3
a4 3
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.62 2005/04/22 11:03:11 lha Exp $");
d50 1
a50 1
static volatile sig_atomic_t exit_flag = 0;
d77 1
a77 1
    u_int16_t len, ap_rep_len;
d123 1
a123 1
	     u_int16_t result_code,
d126 1
d129 1
a129 1
    data->length = asprintf ((char **)&data->data,
d135 1
a135 1
    if (data->data == NULL) {
d138 2
a139 1
   }
d149 1
a149 1
	     u_int16_t result_code,
d194 1
a194 1
	    u_int16_t result_code,
d236 1
a236 1
	u_int16_t version,
d247 1
a247 1
    krb5_principal principal;
d254 1
a254 1
    
d275 1
a275 1
	
d287 1
a287 1
	    reply_priv (auth_context, s, sa, sa_size, 
d302 1
a302 1
		    krb5_warnx (context, 
d305 1
a305 1
		    reply_priv (auth_context, s, sa, sa_size, 
d316 1
a316 1
		reply_priv(auth_context, s, sa, sa_size, 
d325 1
a325 1
	reply_priv (auth_context, s, sa, sa_size, 
d334 1
a334 1
	reply_priv (auth_context, s, sa, sa_size, 
d339 4
a342 1
    ret = kadm5_init_with_password_ctx(context, 
d346 1
a346 1
				       &conf, 0, 0, 
d358 1
a358 1
	reply_priv (auth_context, s, sa, sa_size, 
d369 1
a369 1
	pwd_reason = kadm5_check_password_quality (context, principal, 
d372 1
a372 1
	    krb5_warnx (context, 
d375 1
a375 1
	    reply_priv (auth_context, s, sa, sa_size, 
d381 1
a381 1
	ret = _kadm5_acl_check_permission(kadm5_handle, KADM5_PRIV_CPW, 
d384 1
a384 1
	    krb5_warn (context, ret, 
d387 1
a387 1
	    reply_priv (auth_context, s, sa, sa_size, 
d408 5
a412 3
	krb5_warn (context, ret, "kadm5_s_chpass_principal_cond");
	reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_HARDERROR,
		    "Internal error");
d419 2
d437 1
a437 1
	u_int16_t *version,
d442 2
a443 1
	size_t len)
d446 1
a446 1
    u_int16_t pkt_len, pkt_ver, ap_req_len;
d451 11
d466 1
a466 1
	krb5_warnx (context, "Strange len: %ld != %ld", 
d468 4
a471 1
	reply_error (NULL, s, sa, sa_size, 0, 1, "Bad request");
d503 1
a503 1
	ret = krb5_make_principal (context, 
d544 15
d564 1
a564 1
    
d567 1
a567 1
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 3, 
d593 1
a593 2
    u_int16_t version;

d595 1
d613 1
a613 5
    ret = krb5_auth_con_setaddrs (context,
				  auth_context,
				  this_addr,
				  &other_addr);
    krb5_free_address (context, &other_addr);
d615 1
a615 1
	krb5_warn (context, ret, "krb5_auth_con_setaddr");
d620 14
a633 1
		&version, s, sa, sa_size, msg, len) == 0) {
d645 3
a647 2
    krb5_data_free (&out_data);
    krb5_auth_con_free (context, auth_context);
d682 1
a682 1
	int sa_size = sizeof(__ss);
d685 1
a685 1
	
d709 1
a709 1
	int ret;
d712 2
a713 2
	ret = select (maxfd + 1, &fdset, NULL, NULL, NULL);
	if (ret < 0) {
d724 1
a724 1
		ret = recvfrom (sockets[i], buf, sizeof(buf), 0,
d726 1
a726 1
		if (ret < 0) {
d736 1
a736 1
			 buf, ret);
d756 2
a757 2
const char *check_library  = NULL;
const char *check_function = NULL;
d759 7
a765 6
char *keytab_str = "HDB:";
char *realm_str;
int version_flag;
int help_flag;
char *port_str;
char *config_file;
d769 1
a769 1
    { "check-library", 0, arg_string, &check_library, 
d778 1
a778 1
    { "keytab", 'k', arg_string, &keytab_str, 
d780 1
a780 1
    { "config-file", 'c', arg_string, &config_file },
d782 3
a784 3
    { "port",  'p', arg_string, &port_str, "port" },
    { "version", 0, arg_flag, &version_flag },
    { "help", 0, arg_flag, &help_flag }
a790 1
    int optind;
d795 3
a797 3
    
    optind = krb5_program_setup(&context, argc, argv, args, num_args, NULL);
    
d805 5
a809 2
    if (config_file == NULL)
	config_file = HDB_DB_DIR "/kdc.conf";
d822 1
a822 1
    
d849 1
a849 1
    
d853 1
a853 1
	ret = kadm5_add_passwd_quality_verifier(context, 
d866 1
a866 1
	int i;
d868 2
a869 2
	for (i = 0; i < addresses_str.num_strings; ++i)
	    add_one_address (addresses_str.strings[i], i == 0);
@


1.5
log
@Merge of heimdal 0.7.2
Tested by todd & beck, ok beck.
@
text
@d690 5
@


1.4
log
@Merge 0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.54 2002/12/02 14:31:52 joda Exp $");
d47 3
d53 16
d137 1
a137 1
    }
d142 1
a142 1
reply_error (krb5_principal server,
d153 1
d158 9
d176 2
d233 2
a234 1
	krb5_principal principal,
d238 1
a238 1
	krb5_data *pwd_data)
d241 1
a241 1
    char *client;
d244 3
a246 1
    void *kadm5_handle;
d248 1
d251 1
d253 83
a335 1
    krb5_unparse_name (context, principal, &client);
d338 1
a338 1
				       client,
a343 1
	free (client);
d347 1
a347 1
	return;
d350 7
a356 2
    krb5_warnx (context, "Changing password for %s", client);
    free (client);
d358 29
a386 6
    pwd_reason = kadm5_check_password_quality (context, principal, pwd_data);
    if (pwd_reason != NULL ) {
	krb5_warnx (context, "%s", pwd_reason);
	reply_priv (auth_context, s, sa, sa_size, 4, pwd_reason);
	kadm5_destroy (kadm5_handle);
	return;
d389 4
a392 4
    tmp = malloc (pwd_data->length + 1);
    if (tmp == NULL) {
	krb5_warnx (context, "malloc: out of memory");
	reply_priv (auth_context, s, sa, sa_size, 2,
d396 2
a397 2
    memcpy (tmp, pwd_data->data, pwd_data->length);
    tmp[pwd_data->length] = '\0';
d400 2
a401 2
    memset (tmp, 0, pwd_data->length);
    free (tmp);
d404 1
a404 1
	reply_priv (auth_context, s, sa, sa_size, 2,
d408 2
a409 1
    reply_priv (auth_context, s, sa, sa_size, 0, "Password changed");
d411 9
a419 1
    kadm5_destroy (kadm5_handle);
d424 1
a424 1
	krb5_principal server,
d428 1
d439 1
d447 1
a447 1
	reply_error (server, s, sa, sa_size, 0, 1, "Bad request");
d450 2
a451 1
    if (pkt_ver != 0x0001) {
d453 1
a453 1
	reply_error (server, s, sa, sa_size, 0, 1, "Wrong program version");
d456 1
d464 1
a464 1
		       server,
d469 2
a470 9
	if(ret == KRB5_KT_NOTFOUND) {
	    char *name;
	    krb5_unparse_name(context, server, &name);
	    krb5_warnx (context, "krb5_rd_req: %s (%s)", 
			krb5_get_err_text(context, ret), name);
	    free(name);
	} else
	    krb5_warn (context, ret, "krb5_rd_req");
	reply_error (server, s, sa, sa_size, ret, 3, "Authentication failed");
d474 37
d513 1
a513 1
	reply_error (server, s, sa, sa_size, ret, 1,
d528 2
a529 1
	reply_error (server, s, sa, sa_size, ret, 3, "Bad request");
d535 1
d540 1
a540 1
process (krb5_principal server,
d554 2
d584 2
a585 2
    if (verify (&auth_context, server, keytab, &ticket, &out_data,
		s, sa, sa_size, msg, len) == 0) {
d588 1
a593 1
	free (ticket);
a604 1
    krb5_principal server;
d607 1
a607 1
    char *realm;
d614 1
a614 1
    ret = krb5_get_default_realm (context, &realm);
d616 1
a616 17
	krb5_err (context, 1, ret, "krb5_get_default_realm");

    ret = krb5_build_principal (context,
				&server,
				strlen(realm),
				realm,
				"kadmin",
				"changepw",
				NULL);
    if (ret)
	krb5_err (context, 1, ret, "krb5_build_principal");

    free (realm);

    ret = krb5_get_all_server_addrs (context, &addrs);
    if (ret)
	krb5_err (context, 1, ret, "krb5_get_all_server_addrs");
d618 7
d684 1
a684 1
		process (server, keytab, sockets[i],
d691 1
a691 1
    krb5_free_principal (context, server);
d704 1
d710 1
d718 2
d721 2
d725 1
d739 2
a740 1
    int port;
d751 12
d794 30
@


1.3
log
@Merge heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.52 2001/07/02 16:27:09 assar Exp $");
d38 3
a40 1

d42 1
d451 1
a451 1
	int sa_size;
@


1.2
log
@volatile sig_atomic_t
@
text
@d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.51 2001/05/14 06:18:56 assar Exp $");
d445 1
a445 1
    maxfd = 0;
d458 2
d461 4
a464 1
	    krb5_err (context, 1, errno, "bind(%s)", str);
d471 2
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.49 2001/01/11 21:33:53 assar Exp $");
d44 1
a44 1
static sig_atomic_t exit_flag = 0;
d141 2
a142 1
			 0,
d370 4
a373 1
    ret = krb5_sockaddr2address (sa, &other_addr);
d450 1
a450 2
	krb5_addr2sockaddr (&addrs.val[i], sa, &sa_size, port);

@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.3f

Lots of changes, highlights include:

 * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,
   the new keytab type that tries both of these in order (SRVTAB is
   also an alias for krb4:)

 * improve error reporting and error handling (error messages should
   be more detailed and more useful)

 * the API is closer to what MIT krb5 is using

 * more compatible with windows 2000

 * removed some memory leaks

 * bug fixes
@
text
@d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.51 2001/05/14 06:18:56 assar Exp $");
d141 1
a141 2
			 NULL,
			 NULL,
d369 1
a369 4
    krb5_auth_con_setflags (context, auth_context,
			    KRB5_AUTH_CONTEXT_DO_SEQUENCE);

    ret = krb5_sockaddr2address (context, sa, &other_addr);
d446 2
a447 1
	krb5_addr2sockaddr (context, &addrs.val[i], sa, &sa_size, port);
@


1.1.1.3
log
@Import of heimdal-0.4e
@
text
@d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.52 2001/07/02 16:27:09 assar Exp $");
d445 1
a445 1
    maxfd = -1;
a457 2
	    int save_errno = errno;

d459 1
a459 4
	    if (ret)
		strlcpy(str, "unknown address", sizeof(str));
	    krb5_warn (context, save_errno, "bind(%s)", str);
	    continue;
a465 2
    if (maxfd == -1)
	krb5_errx (context, 1, "No sockets!");
@


1.1.1.4
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2002 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.54 2002/12/02 14:31:52 joda Exp $");
d38 1
a38 3
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
a39 1
#include <kadm5/private.h>
d448 1
a448 1
	int sa_size = sizeof(__ss);
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997-2005 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kpasswdd.c,v 1.62 2005/04/22 11:03:11 lha Exp $");
a46 3
static struct getarg_strings addresses_str;
krb5_addresses explicit_addresses;

a49 16
add_one_address (const char *str, int first)
{
    krb5_error_code ret;
    krb5_addresses tmp;

    ret = krb5_parse_address (context, str, &tmp);
    if (ret)
	krb5_err (context, 1, ret, "parse_address `%s'", str);
    if (first)
	krb5_copy_addresses(context, &tmp, &explicit_addresses);
    else
	krb5_append_addresses(context, &explicit_addresses, &tmp);
    krb5_free_addresses (context, &tmp);
}

static void
d118 1
a118 1
   }
d123 1
a123 1
reply_error (krb5_realm realm,
a133 1
    krb5_principal server = NULL;
a137 9
    if (realm) {
	ret = krb5_make_principal (context, &server, realm,
				   "kadmin", "changepw", NULL);
	if (ret) {
	    krb5_data_free (&e_data);
	    return;
	}
    }

a146 2
    if (server)
	krb5_free_principal(context, server);
d202 1
a202 2
	krb5_principal admin_principal,
	u_int16_t version,
d206 1
a206 1
	krb5_data *in_data)
d209 1
a209 1
    char *client = NULL, *admin = NULL;
d212 1
a212 3
    void *kadm5_handle = NULL;
    krb5_principal principal;
    krb5_data *pwd_data = NULL;
a213 1
    ChangePasswdDataMS chpw;
a215 1
    memset(&chpw, 0, sizeof(chpw));
d217 1
a217 83
    if (version == KRB5_KPASSWD_VERS_CHANGEPW) {
	ret = krb5_copy_data(context, in_data, &pwd_data);
	if (ret) {
	    krb5_warn (context, ret, "krb5_copy_data");
	    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_MALFORMED,
			"out out memory copying password");
	    return;
	}
	principal = admin_principal;
    } else if (version == KRB5_KPASSWD_VERS_SETPW) {
	size_t len;

	ret = decode_ChangePasswdDataMS(in_data->data, in_data->length,
					&chpw, &len);
	if (ret) {
	    krb5_warn (context, ret, "decode_ChangePasswdDataMS");
	    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_MALFORMED,
			"malformed ChangePasswdData");
	    return;
	}
	

	ret = krb5_copy_data(context, &chpw.newpasswd, &pwd_data);
	if (ret) {
	    krb5_warn (context, ret, "krb5_copy_data");
	    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_MALFORMED,
			"out out memory copying password");
	    goto out;
	}

	if (chpw.targname == NULL && chpw.targrealm != NULL) {
	    krb5_warn (context, ret, "kadm5_init_with_password_ctx");
	    reply_priv (auth_context, s, sa, sa_size, 
			KRB5_KPASSWD_MALFORMED,
			"targrealm but not targname");
	    goto out;
	}

	if (chpw.targname) {
	    krb5_principal_data princ;

	    princ.name = *chpw.targname;
	    princ.realm = *chpw.targrealm;
	    if (princ.realm == NULL) {
		ret = krb5_get_default_realm(context, &princ.realm);

		if (ret) {
		    krb5_warnx (context, 
				"kadm5_init_with_password_ctx: "
				"failed to allocate realm");
		    reply_priv (auth_context, s, sa, sa_size, 
				KRB5_KPASSWD_SOFTERROR,
				"failed to allocate realm");
		    goto out;
		}
	    }
	    ret = krb5_copy_principal(context, &princ, &principal);
	    if (*chpw.targrealm == NULL)
		free(princ.realm);
	    if (ret) {
		krb5_warn(context, ret, "krb5_copy_principal");
		reply_priv(auth_context, s, sa, sa_size, 
			   KRB5_KPASSWD_HARDERROR,
			   "failed to allocate principal");
		goto out;
	    }
	} else
	    principal = admin_principal;
    } else {
	krb5_warnx (context, "kadm5_init_with_password_ctx: unknown proto");
	reply_priv (auth_context, s, sa, sa_size, 
		    KRB5_KPASSWD_HARDERROR,
		    "Unknown protocol used");
	return;
    }

    ret = krb5_unparse_name (context, admin_principal, &admin);
    if (ret) {
	krb5_warn (context, ret, "unparse_name failed");
	reply_priv (auth_context, s, sa, sa_size, 
		    KRB5_KPASSWD_HARDERROR, "out of memory error");
	goto out;
    }
d220 1
a220 1
				       admin,
d226 1
d230 1
a230 1
	goto out;
d233 2
a234 7
    ret = krb5_unparse_name(context, principal, &client);
    if (ret) {
	krb5_warn (context, ret, "unparse_name failed");
	reply_priv (auth_context, s, sa, sa_size, 
		    KRB5_KPASSWD_HARDERROR, "out of memory error");
	goto out;
    }
d236 6
a241 29
    /*
     * Check password quality if not changing as administrator
     */

    if (krb5_principal_compare(context, admin_principal, principal) == TRUE) {

	pwd_reason = kadm5_check_password_quality (context, principal, 
						   pwd_data);
	if (pwd_reason != NULL ) {
	    krb5_warnx (context, 
			"%s didn't pass password quality check with error: %s",
			client, pwd_reason);
	    reply_priv (auth_context, s, sa, sa_size, 
			KRB5_KPASSWD_SOFTERROR, pwd_reason);
	    goto out;
	}
	krb5_warnx (context, "Changing password for %s", client);
    } else {
	ret = _kadm5_acl_check_permission(kadm5_handle, KADM5_PRIV_CPW, 
					  principal);
	if (ret) {
	    krb5_warn (context, ret, 
		       "Check ACL failed for %s for changing %s password",
		       admin, client);
	    reply_priv (auth_context, s, sa, sa_size, 
			KRB5_KPASSWD_HARDERROR, "permission denied");
	    goto out;
	}
	krb5_warnx (context, "%s is changing password for %s", admin, client);
d244 4
a247 4
    ret = krb5_data_realloc(pwd_data, pwd_data->length + 1);
    if (ret) {
	krb5_warn (context, ret, "malloc: out of memory");
	reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_HARDERROR,
d251 2
a252 2
    tmp = pwd_data->data;
    tmp[pwd_data->length - 1] = '\0';
d255 2
a256 2
    krb5_free_data (context, pwd_data);
    pwd_data = NULL;
d259 1
a259 1
	reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_HARDERROR,
d263 1
a263 2
    reply_priv (auth_context, s, sa, sa_size, KRB5_KPASSWD_SUCCESS,
		"Password changed");
d265 1
a265 9
    free_ChangePasswdDataMS(&chpw);
    if (admin)
	free(admin);
    if (client)
	free(client);
    if (pwd_data)
	krb5_free_data(context, pwd_data);
    if (kadm5_handle)
	kadm5_destroy (kadm5_handle);
d270 1
a270 1
	krb5_realm *realms,
a273 1
	u_int16_t *version,
a283 1
    krb5_realm *r;
d291 1
a291 1
	reply_error (NULL, s, sa, sa_size, 0, 1, "Bad request");
d294 1
a294 2
    if (pkt_ver != KRB5_KPASSWD_VERS_CHANGEPW &&
	pkt_ver != KRB5_KPASSWD_VERS_SETPW) {
d296 1
a296 1
	reply_error (NULL, s, sa, sa_size, 0, 1, "Wrong program version");
a298 1
    *version = pkt_ver;
d306 1
a306 1
		       NULL,
d311 9
a319 2
	krb5_warn (context, ret, "krb5_rd_req");
	reply_error (NULL, s, sa, sa_size, ret, 3, "Authentication failed");
a322 37
    /* verify realm and principal */
    for (r = realms; *r != NULL; r++) {
	krb5_principal principal;
	krb5_boolean same;

	ret = krb5_make_principal (context, 
				   &principal,
				   *r,
				   "kadmin",
				   "changepw",
				   NULL);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_make_principal");

	same = krb5_principal_compare(context, principal, (*ticket)->server);
	krb5_free_principal(context, principal);
	if (same == TRUE)
	    break;
    }
    if (*r == NULL) {
	char *str;
	krb5_unparse_name(context, (*ticket)->server, &str);
	krb5_warnx (context, "client used not valid principal %s", str);
	free(str);
	reply_error (NULL, s, sa, sa_size, ret, 1,
		     "Bad request");
	goto out;
    }

    if (strcmp((*ticket)->server->realm, (*ticket)->client->realm) != 0) {
	krb5_warnx (context, "server realm (%s) not same a client realm (%s)",
		    (*ticket)->server->realm, (*ticket)->client->realm);
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 1,
		     "Bad request");
	goto out;
    }

d325 1
a325 1
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 1,
d340 1
a340 2
	reply_error ((*ticket)->server->realm, s, sa, sa_size, ret, 3, 
		     "Bad request");
a345 1
    ticket = NULL;
d350 1
a350 1
process (krb5_realm *realms,
a363 2
    u_int16_t version;

d392 2
a393 2
    if (verify (&auth_context, realms, keytab, &ticket, &out_data,
		&version, s, sa, sa_size, msg, len) == 0) {
a395 1
		version,
d401 1
d413 1
d416 1
a416 1
    krb5_realm *realms;
d423 11
a433 1
    ret = krb5_get_default_realms(context, &realms);
d435 7
a441 1
	krb5_err (context, 1, ret, "krb5_get_default_realms");
a442 7
    if (explicit_addresses.len) {
	addrs = explicit_addresses;
    } else {
	ret = krb5_get_all_server_addrs (context, &addrs);
	if (ret)
	    krb5_err (context, 1, ret, "krb5_get_all_server_addrs");
    }
d502 1
a502 1
		process (realms, keytab, sockets[i],
d509 1
a509 1
    krb5_free_host_realm (context, realms);
a521 1
static getarg_strings policy_libraries = { 0, NULL };
a526 1
char *config_file;
a533 2
    { "policy-libraries", 0, arg_strings, &policy_libraries,
      "password check function to load", "function" },
a534 2
    { "addresses",	0,	arg_strings, &addresses_str,
      "addresses to listen on", "list of addresses" },
a536 1
    { "config-file", 'c', arg_string, &config_file },
d550 1
a550 2
    char **files;
    int port, i;
a560 12
    if (config_file == NULL)
	config_file = HDB_DB_DIR "/kdc.conf";

    ret = krb5_prepend_config_files_default(config_file, &files);
    if (ret)
	krb5_err(context, 1, ret, "getting configuration files");

    ret = krb5_set_config_files(context, files);
    krb5_free_config_files(files);
    if (ret)
	krb5_err(context, 1, ret, "reading configuration files");

a591 30

    for (i = 0; i < policy_libraries.num_strings; i++) {
	ret = kadm5_add_passwd_quality_verifier(context, 
						policy_libraries.strings[i]);
	if (ret)
	    krb5_err(context, 1, ret, "kadm5_add_passwd_quality_verifier");
    }
    ret = kadm5_add_passwd_quality_verifier(context, NULL);
    if (ret)
	krb5_err(context, 1, ret, "kadm5_add_passwd_quality_verifier");


    explicit_addresses.len = 0;

    if (addresses_str.num_strings) {
	int i;

	for (i = 0; i < addresses_str.num_strings; ++i)
	    add_one_address (addresses_str.strings[i], i == 0);
	free_getarg_strings (&addresses_str);
    } else {
	char **foo = krb5_config_get_strings (context, NULL,
					      "kdc", "addresses", NULL);

	if (foo != NULL) {
	    add_one_address (*foo++, TRUE);
	    while (*foo)
		add_one_address (*foo++, FALSE);
	}
    }
@


