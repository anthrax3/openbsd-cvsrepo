head	1.14;
access;
symbols;
locks; strict;
comment	@ * @;


1.14
date	2007.01.09.00.44.37;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.08.17.10.23;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.08.16.50.04;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.08.14.30.31;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.05.35;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.14
log
@rename to hoststate{d,ctl}, using a repository copy
as discussed with reyk
@
text
@/*	$OpenBSD: parse.y,v 1.13 2007/01/08 20:46:18 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <netdb.h>
#include <string.h>

#include "hostated.h"

struct hostated			*conf = NULL;
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
const char			*infile;
char				*start_state;
objid_t				 last_service_id = 0;
objid_t				 last_table_id = 0;
objid_t				 last_host_id = 0;

static struct service		*service = NULL;
static struct table		*table = NULL;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(FILE *);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};

int		 symset(const char *, const char *, int);
char		*symget(const char *);
int		 cmdline_symset(char *);

struct address	*host_v4(const char *);
struct address	*host_v6(const char *);
int		 host_dns(const char *, struct addresslist *,
		    int, in_port_t, const char *);
int		 host(const char *, struct addresslist *,
		    int, in_port_t, const char *);

typedef struct {
	union {
		u_int32_t	 number;
		char		*string;
		struct host	*host;
		struct timeval	 tv;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	SERVICE TABLE BACKUP HOST REAL
%token  CHECK HTTP TCP ICMP EXTERNAL
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE
%token	VIRTUAL IP INTERVAL DISABLE STICKYADDR
%token	SEND EXPECT NOTHING
%token	ERROR
%token	<v.string>	STRING
%type	<v.string>	interface
%type	<v.number>	number port
%type	<v.host>	host
%type	<v.tv>		timeout

%%

grammar		: /* empty */
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar service '\n'
		| grammar table '\n'
		| grammar error '\n'		{ errors++; }
		;

number		: STRING	{
			const char	*estr;

			$$ = strtonum($1, 0, UINT_MAX, &estr);
			if (estr) {
				yyerror("cannot parse number %s : %s",
				    $1, estr);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

port		: PORT STRING	{
			const char	*estr;
			struct servent	*servent;
			
			$$ = strtonum($2, 1, USHRT_MAX, &estr);
			if (estr) {
				if (errno == ERANGE) {
					yyerror("port %s is out of range", $2);
					free($2);
					YYERROR;
				}
				servent = getservbyname($2, "tcp");
				if (servent == NULL) {
					yyerror("port %s is invalid", $2);
					free($2);
					YYERROR;
				}
				$$ = servent->s_port;
			} else
				$$ = htons($$);
			free($2);
		}
		| PORT HTTP {
			struct servent	*servent;

			servent = getservbyname("http", "tcp");
			if (servent == NULL)
				$$ = htons(80);
			else
				$$ = servent->s_port;
		}
		;

varset		: STRING '=' STRING	{
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

sendbuf		: NOTHING		{
			bzero(table->sendbuf, sizeof(table->sendbuf));
		}
		| STRING		{
			if (strlcpy(table->sendbuf, $1, sizeof(table->sendbuf))
			    >= sizeof(table->sendbuf)) {
				yyerror("yyparse: send buffer truncated");
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

main		: INTERVAL number	{ conf->interval.tv_sec = $2; }
		| TIMEOUT timeout	{
			bcopy(&$2, &conf->timeout, sizeof(struct timeval));
		}
		;

service		: SERVICE STRING	{
			struct service *srv;

			TAILQ_FOREACH(srv, &conf->services, entry)
				if (!strcmp(srv->name, $2))
					break;
			if (srv != NULL) {
				yyerror("service %s defined twice", $2);
				free($2);
				YYERROR;
			}
			if ((srv = calloc(1, sizeof (*srv))) == NULL)
				fatal("out of memory");

			if (strlcpy(srv->name, $2, sizeof(srv->name)) >=
			    sizeof(srv->name)) {
				yyerror("service name truncated");
				YYERROR;
			}
			free($2);
			srv->id = last_service_id++;
			if (last_service_id == UINT_MAX) {
				yyerror("too many services defined");
				YYERROR;
			}
			service = srv;
		} '{' optnl serviceopts_l '}'	{
			if (service->table == NULL) {
				yyerror("service %s has no table",
				    service->name);
				YYERROR;
			}
			if (TAILQ_EMPTY(&service->virts)) {
				yyerror("service %s has no virtual ip",
				    service->name);
				YYERROR;
			}
			conf->servicecount++;
			if (service->backup == NULL)
				service->backup = &conf->empty_table;
			else if (service->backup->port !=
			    service->table->port) {
				yyerror("service %s uses two different ports "
				    "for its table and backup table",
				    service->name);
				YYERROR;
			}

			if (!(service->flags & F_DISABLE))
				service->flags |= F_ADD;
			TAILQ_INSERT_HEAD(&conf->services, service, entry);
		}
		;

serviceopts_l	: serviceopts_l serviceoptsl nl
		| serviceoptsl optnl
		;

serviceoptsl	: TABLE STRING	{
			struct table *tb;

			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $2))
					break;
			if (tb == NULL) {
				yyerror("no such table: %s", $2);
				free($2);
				YYERROR;
			} else {
				service->table = tb;
				service->table->serviceid = service->id;
				service->table->flags |= F_USED;
				free($2);
			}
		}
		| BACKUP TABLE STRING	{
			struct table *tb;

			if (service->backup) {
				yyerror("backup already specified");
				free($3);
				YYERROR;
			}

			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $3))
					break;

			if (tb == NULL) {
				yyerror("no such table: %s", $3);
				free($3);
				YYERROR;
			} else {
				service->backup = tb;
				service->backup->serviceid = service->id;
				service->backup->flags |= (F_USED|F_BACKUP);
				free($3);
			}
		}
		| VIRTUAL IP STRING port interface {
			if (host($3, &service->virts,
				 SRV_MAX_VIRTS, $4, $5) <= 0) {
				yyerror("invalid virtual ip: %s", $3);
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
		}
		| DISABLE			{ service->flags |= F_DISABLE; }
		| STICKYADDR			{ service->flags |= F_STICKY; }
		| TAG STRING {
			if (strlcpy(service->tag, $2, sizeof(service->tag)) >=
			    sizeof(service->tag)) {
				yyerror("service tag name truncated");
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

table		: TABLE STRING	{
			struct table *tb;

			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $2))
					break;
			if (tb != NULL) {
				yyerror("table %s defined twice");
				free($2);
				YYERROR;
			}

			if ((tb = calloc(1, sizeof (*tb))) == NULL)
				fatal("out of memory");

			if (strlcpy(tb->name, $2, sizeof(tb->name)) >=
			    sizeof(tb->name)) {
				yyerror("table name truncated");
				YYERROR;
			}
			tb->id = last_table_id++;
			bcopy(&conf->timeout, &tb->timeout,
			    sizeof(struct timeval));
			if (last_table_id == UINT_MAX) {
				yyerror("too many tables defined");
				YYERROR;
			}
			free($2);
			table = tb;
		} '{' optnl tableopts_l '}'	{
			if (table->port == 0) {
				yyerror("table %s has no port", table->name);
				YYERROR;
			}
			if (TAILQ_EMPTY(&table->hosts)) {
				yyerror("table %s has no hosts", table->name);
				YYERROR;
			}
			if (table->check == CHECK_NOCHECK) {
				yyerror("table %s has no check", table->name);
				YYERROR;
			}
			conf->tablecount++;
			TAILQ_INSERT_HEAD(&conf->tables, table, entry);
		}
		;

tableopts_l	: tableopts_l tableoptsl nl
		| tableoptsl optnl
		;

tableoptsl	: host			{
			$1->tableid = table->id;
			$1->tablename = table->name;
			TAILQ_INSERT_HEAD(&table->hosts, $1, entry);
		}
		| TIMEOUT timeout	{
			bcopy(&$2, &table->timeout, sizeof(struct timeval));
		}
		| CHECK ICMP		{
			table->check = CHECK_ICMP;
		}
		| CHECK TCP		{
			table->check = CHECK_TCP;
		}
		| CHECK HTTP STRING CODE number {
			table->check = CHECK_HTTP_CODE;
			table->retcode = $5;
			if (strlcpy(table->path, $3, sizeof(table->path)) >=
			    sizeof(table->path)) {
				yyerror("http path truncated");
				free($3);
				YYERROR;
			}
		}
		| CHECK HTTP STRING DIGEST STRING {
			table->check = CHECK_HTTP_DIGEST;
			if (strlcpy(table->path, $3, sizeof(table->path)) >=
			    sizeof(table->path)) {
				yyerror("http path truncated");
				free($3);
				free($5);
				YYERROR;
			}
			if (strlcpy(table->digest, $5,
			    sizeof(table->digest)) >= sizeof(table->digest)) {
				yyerror("http digest truncated");
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
		}
		| CHECK SEND sendbuf EXPECT STRING {
			table->check = CHECK_SEND_EXPECT;
			if (strlcpy(table->exbuf, $5, sizeof(table->exbuf))
			    >= sizeof(table->exbuf)) {
				yyerror("yyparse: expect buffer truncated");
				free($5);
				YYERROR;
			}
			free($5);
		}
		| REAL port {
			table->port = $2;
		}
		| DISABLE			{ table->flags |= F_DISABLE; }
		;

interface	: /*empty*/		{ $$ = NULL; }
		| INTERFACE STRING	{ $$ = $2; }
		;

host		: HOST STRING {
			struct host *r;
			struct address *a;
			struct addresslist al;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal("out of memory");

			TAILQ_INIT(&al);
			if (host($2, &al, 1, 0, NULL) <= 0) {
				yyerror("invalid host %s", $2);
				free($2);
				YYERROR;
			}
			a = TAILQ_FIRST(&al);
			memcpy(&r->ss, &a->ss, sizeof(r->ss));
			free(a);

			if (strlcpy(r->name, $2, sizeof(r->name)) >=
			    sizeof(r->name)) {
				yyerror("host name truncated");
				free($2);
				YYERROR;
			} else {
				r->id = last_host_id++;
				if (last_host_id == UINT_MAX) {
					yyerror("too many hosts defined");
					YYERROR;
				}
				free($2);
				$$ = r;
			}
		}
		;

timeout		: number
		{
			$$.tv_sec = $1 / 1000;
			$$.tv_usec = ($1 % 1000) * 1000;
		}
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list	ap;

	errors = 1;
	va_start(ap, fmt);
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{

	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "backup",		BACKUP },
		{ "check",		CHECK },
		{ "code",		CODE },
		{ "digest",		DIGEST },
		{ "disable",		DISABLE },
		{ "expect",		EXPECT },
		{ "external",		EXTERNAL },
		{ "host",		HOST },
		{ "http",		HTTP },
		{ "icmp",		ICMP },
		{ "interface",		INTERFACE },
		{ "interval",		INTERVAL },
		{ "ip",			IP },
		{ "nothing",		NOTHING },
		{ "port",		PORT },
		{ "real",		REAL },
		{ "send",		SEND },
		{ "service",		SERVICE },
		{ "sticky-address",	STICKYADDR },
		{ "table",		TABLE },
		{ "tag",		TAG },
		{ "tcp",		TCP },
		{ "timeout",		TIMEOUT },
		{ "virtual",		VIRTUAL }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

char	*parsebuf;
int	 parseindex;
char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(FILE *f)
{
	int	c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	while ((c = getc(f)) == '\\') {
		next = getc(f);
		if (next == 'n') {
			c = '\n';
			break;
		} else if (next == 'r') {
			c = '\r';
			break;
		} else if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = lineno;
		lineno++;
	}
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(f);
		} while (c == '\t' || c == ' ');
		ungetc(c, f);
		c = ' ';
	}

	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;
	pushback_index = 0;

	/* skip to either EOF or the first real EOL */
	while (1) {
		c = lgetc(fin);
		if (c == '\n') {
			lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	char	 buf[8096];
	char	*p, *val;
	int	 endc, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(fin)) == ' ')
		; /* nothing */

	yylval.lineno = lineno;
	if (c == '#')
		while ((c = lgetc(fin)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = (char)c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		endc = c;
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);
			if (c == endc) {
				*p = '\0';
				break;
			}
			if (c == '\n') {
				lineno++;
				continue;
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = (char)c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			errx(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = lineno;
		lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
parse_config(struct hostated *x_conf, const char *filename, int opts)
{
	struct sym	*sym, *next;

	conf = x_conf;

	TAILQ_INIT(&conf->services);
	TAILQ_INIT(&conf->tables);
	memset(&conf->empty_table, 0, sizeof(conf->empty_table));
	conf->empty_table.id = EMPTY_TABLE;
	conf->empty_table.flags |= F_DISABLE;
	(void)strlcpy(conf->empty_table.name, "empty",
	    sizeof(conf->empty_table.name));

	conf->timeout.tv_sec = CHECK_TIMEOUT / 1000;
	conf->timeout.tv_usec = (CHECK_TIMEOUT % 1000) * 1000;
	conf->interval.tv_sec = CHECK_INTERVAL;
	conf->interval.tv_usec = 0;
	conf->opts = opts;

	if ((fin = fopen(filename, "r")) == NULL) {
		warn("%s", filename);
		return (NULL);
	}
	infile = filename;
	setservent(1);
	yyparse();
	endservent();
	fclose(fin);

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
		if ((conf->opts & HOSTATED_OPT_VERBOSE) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
		}
	}

	if (TAILQ_EMPTY(&conf->services)) {
		log_warnx("no services, nothing to do");
		errors++;
	}

	if (timercmp(&conf->timeout, &conf->interval, >=)) {
		log_warnx("global timeout exceeds interval");
		errors++;
	}

	/* Verify that every table is used */
	TAILQ_FOREACH(table, &conf->tables, entry) {
		if (!(table->flags & F_USED)) {
			log_warnx("unused table: %s", table->name);
			errors++;
		}
		if (timercmp(&table->timeout, &conf->interval, >=)) {
			log_warnx("table timeout exceeds interval: %s",
			    table->name);
			errors++;
		}
	}

	if (errors) {
		bzero(&conf, sizeof (*conf));
		return (-1);
	}

	return (0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entries))
		;	/* nothing */

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entries)
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	return (NULL);
}

struct address *
host_v4(const char *s)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sain;
	struct address		*h;

	bzero(&ina, sizeof(ina));
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
	sain = (struct sockaddr_in *)&h->ss;
	sain->sin_len = sizeof(struct sockaddr_in);
	sain->sin_family = AF_INET;
	sain->sin_addr.s_addr = ina.s_addr;

	return (h);
}

struct address *
host_v6(const char *s)
{
	struct in6_addr		 ina6;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	bzero(&ina6, sizeof(ina6));
	if (inet_pton(AF_INET6, s, &ina6) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
	sin6 = (struct sockaddr_in6 *)&h->ss;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_family = AF_INET6;
	memcpy(&sin6->sin6_addr, &ina6, sizeof(ina6));

	return (h);
}

int
host_dns(const char *s, struct addresslist *al, int max,
	 in_port_t port, const char *ifname)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	bzero(&hints, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
		return (0);
	if (error) {
		log_warnx("host_dns: could not parse \"%s\": %s", s,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res && cnt < max; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(NULL);

		h->port = port;
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("host_dns: interface name truncated");
			return (-1);
		}
		h->ss.ss_family = res->ai_family;
		if (res->ai_family == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		cnt++;
	}
	if (cnt == max && res) {
		log_warnx("host_dns: %s resolves to more than %d hosts",
		    s, max);
	}
	freeaddrinfo(res0);
	return (cnt);
}

int
host(const char *s, struct addresslist *al, int max,
    in_port_t port, const char *ifname)
{
	struct address *h;

	h = host_v4(s);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(s);

	if (h != NULL) {
		h->port = port;
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname)) {
				log_warnx("host: interface name truncated");
				return (-1);
			}
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		return (1);
	}

	return (host_dns(s, al, max, port, ifname));
}
@


1.13
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2007/01/08 17:10:23 reyk Exp $	*/
@


1.12
log
@allow to use service names in addition to numerical port numbers in
the configuration file, eg. "real port http".

> From Pierre-Yves Ritschard (pyr at spootnik dot org)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2007/01/08 16:50:04 reyk Exp $	*/
a42 1
#include <regex.h>
a415 3
			int	ret;
			char	ebuf[32];

d417 3
a419 5
			ret = regcomp(&table->regx, $5, REG_EXTENDED|REG_NOSUB);
			if (ret != 0) {
				regerror(ret, &table->regx, ebuf, sizeof(ebuf));
				yyerror("cannot compile expect regexp: %s",
				    ebuf);
@


1.11
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2007/01/08 14:30:31 reyk Exp $	*/
d109 1
a109 1
%type	<v.number>	number
d138 33
d298 1
a298 7
		| VIRTUAL IP STRING PORT number	interface {
			if ($5 < 1 || $5 > USHRT_MAX) {
				yyerror("invalid port number: %d", $5);
				free($3);
				free($6);
				YYERROR;
			}
d300 1
a300 1
				 SRV_MAX_VIRTS, htons($5), $6) <= 0) {
d303 1
a303 1
				free($6);
d307 1
a307 1
			free($6);
d431 2
a432 6
		| REAL PORT number {
			if ($3 < 1 || $3 >= USHRT_MAX) {
				yyerror("invalid port number: %d", $3);
				YYERROR;
			}
			table->port = $3;
d776 1
d778 1
@


1.10
log
@remove unused token.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2007/01/08 13:37:26 reyk Exp $	*/
d160 1
a160 1
main		: INTERVAL number	{ conf->interval = $2; }
d744 2
a745 1
	conf->interval = CHECK_INTERVAL;
d775 5
d781 1
a781 1
	TAILQ_FOREACH(table, &conf->tables, entry)
d786 6
@


1.9
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2007/01/03 09:45:29 reyk Exp $	*/
d102 1
a102 1
%token  CHECK HTTP HTTPS TCP ICMP EXTERNAL
a508 1
		{ "https",		HTTPS },
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2007/01/03 09:42:30 reyk Exp $	*/
d43 1
d105 1
d146 14
d380 1
a380 1
			    sizeof(table->digest)) >= sizeof (table->digest)) {
d389 15
d505 1
d514 1
d517 1
d565 7
a571 1
		if (next != '\n') {
@


1.7
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2006/12/25 19:05:41 reyk Exp $	*/
d300 2
a301 1
			bcopy(&conf->timeout, &tb->timeout, sizeof(struct timeval));
d364 1
a364 1
			    sizeof (table->digest)) >= sizeof (table->digest)) {
@


1.6
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2006/12/25 18:12:14 reyk Exp $	*/
d103 1
a103 1
%token	VIRTUAL IP INTERVAL DISABLE
d267 1
d484 1
@


1.5
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2006/12/16 18:05:35 martin Exp $	*/
d93 1
d109 1
d145 3
a147 1
		| TIMEOUT number	{ conf->timeout = $2; }
d299 1
a299 1
			tb->timeout = conf->timeout;
d333 2
a334 2
		| TIMEOUT number	{
			table->timeout = $2;
d420 7
d700 2
a701 1
	conf->timeout = CHECK_TIMEOUT;
@


1.4
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2006/12/16 17:48:27 deraadt Exp $	*/
d143 1
d295 1
a295 1
			tb->timeout = CONNECT_TIMEOUT;
d689 1
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d475 1
a475 1
		{ "virtual",		VIRTUA L}
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d126 1
a126 1
					$1, estr);
d174 1
a174 1
					service->name);
d179 1
a179 1
					service->name);
d356 2
a357 2
			if (strlcpy(table->digest, $5, sizeof (table->digest))
					>= sizeof (table->digest)) {
d376 1
a376 1
interface	: /*empty*/ 		{ $$ = NULL; }
d455 21
a475 21
		{"backup",		BACKUP},
		{"check",		CHECK},
		{"code",		CODE},
		{"digest",		DIGEST},
		{"disable",		DISABLE},
		{"external",		EXTERNAL},
		{"host",		HOST},
		{"http",		HTTP},
		{"https",		HTTPS},
		{"icmp",		ICMP},
		{"interface",		INTERFACE},
		{"interval",		INTERVAL},
		{"ip",			IP},
		{"port",		PORT},
		{"real",		REAL},
		{"service",		SERVICE},
		{"table",		TABLE},
		{"tag",			TAG},
		{"tcp",			TCP},
		{"timeout",		TIMEOUT},
		{"virtual",		VIRTUAL}
d864 1
a864 1
			return (0);
d903 1
a903 1
			s, max);
a905 1

d911 1
a911 1
     in_port_t port, const char *ifname)
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 3
a79 3
int			 symset(const char *, const char *, int);
char			*symget(const char *);
int			 cmdline_symset(char *);
d84 1
a84 1
			  int, in_port_t, const char *);
d86 1
a86 1
		      int, in_port_t, const char *);
d120 1
a120 1
number		: STRING 		{
d145 1
a145 1
service		: SERVICE STRING 	{
d159 2
a160 2
			if (strlcpy(srv->name, $2, sizeof (srv->name)) >=
					sizeof (srv->name)) {
d164 1
a164 1
			free ($2);
d186 1
a186 1
			         service->table->port) {
d188 2
a189 2
					"for its table and backup table",
					service->name);
d192 1
a192 1
			
d203 1
a203 1
serviceoptsl	: TABLE STRING 			{
d220 1
a220 1
		| BACKUP TABLE STRING 		{
d273 1
a273 1
table		: TABLE STRING 			{
d284 1
a284 1
			
d287 3
a289 3
			
			if (strlcpy(tb->name, $2, sizeof (tb->name)) >=
					sizeof (tb->name)) {
d299 1
a299 1
			free ($2);
d301 1
a301 1
		} '{' optnl tableopts_l '}' 	{
d323 1
a323 1
tableoptsl	: host 				{
d328 1
a328 1
		| TIMEOUT number 		{
d331 1
a331 1
		| CHECK ICMP 			{
d334 1
a334 1
		| CHECK TCP 			{
d340 2
a341 2
			if (strlcpy(table->path, $3, sizeof (table->path)) >=
					sizeof (table->path)) {
d349 2
a350 2
			if (strlcpy(table->path, $3, sizeof (table->path)) >=
					sizeof (table->path)) {
d381 1
a381 1
                        struct host *r;
d385 2
a386 2
                        if ((r = calloc(1, sizeof (*r))) == NULL)
                                fatal("out of memory");
d398 2
a399 2
                        if (strlcpy(r->name, $2, sizeof (r->name)) >=
					sizeof (r->name)) {
d686 1
a686 1
		      sizeof(conf->empty_table.name)); 
d838 1
a838 1
	
d915 1
a915 1
		
d931 1
a931 1
		
@

