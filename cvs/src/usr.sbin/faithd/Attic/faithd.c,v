head	1.32;
access;
symbols
	OPENBSD_5_3:1.31.0.8
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.8
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.6
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.18
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.16
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.14
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.12
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.10
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.8
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.6
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	snap19991220:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2013.03.14.11.08.20;	author mpi;	state dead;
branches;
next	1.31;

1.31
date	2011.03.02.04.56.59;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.26.09.51.29;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.16.05.27.33;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.02.23.35.24;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.02.22.55.26;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.15.00.27.29;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.15.00.26.55;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.13.09.09.46;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.08.01.20.15;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.07.00.18.05;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.26.01.21.12;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.09.14.12.17;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.11.03.51.08;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.21.04.54.51;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.21.04.53.13;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.05.09.56.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.05.01.31.33;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.01.07.40.04;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.20.01.13.54;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.15.17.37.33;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.06.02.46.58;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.16.10.33.45;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.05.17.23.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.00.21.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.31.03.09.22;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.25.10.25.46;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.12.30.16.31.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.12.20.16.32.53;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.20.16.07.40;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.20.16.07.40;	author itojun;	state Exp;
branches;
next	;

1.4.2.1
date	2000.10.07.04.20.44;	author jason;	state Exp;
branches;
next	;


desc
@@


1.32
log
@tedu faithd(8), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@/*	$OpenBSD: faithd.c,v 1.31 2011/03/02 04:56:59 deraadt Exp $	*/
/*	$KAME: faithd.c,v 1.58 2002/09/08 01:12:30 itojun Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * User level translator from IPv6 to IPv4.
 *
 * Usage: faithd [<port> <progpath> <arg1(progname)> <arg2> ...]
 *   e.g. faithd telnet /usr/libexec/telnetd telnetd
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#ifdef __FreeBSD__
#include <libutil.h>
#endif

#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <termios.h>

#include <net/if_types.h>
#ifdef IFT_FAITH
# define USE_ROUTE
# include <net/if.h>
# include <net/route.h>
# include <net/if_dl.h>
#endif

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <ifaddrs.h>

#include "faithd.h"
#include "prefix.h"

char *serverpath = NULL;
char *serverarg[MAXARGV + 1];
static char *faithdname = NULL;
char logname[BUFSIZ];
char procname[BUFSIZ];

struct myaddrs {
	struct myaddrs *next;
	struct sockaddr *addr;
};
struct myaddrs *myaddrs = NULL;

static const char *service;
#ifdef USE_ROUTE
static int sockfd = 0;
#endif
int dflag = 0;
static int pflag = 0;
static int inetd = 0;
static char *configfile = NULL;

int main(int, char **);
#if 0
static int inetd_main(int, char **);
#endif
static int daemon_main(int, char **);
static void play_service(int);
static void play_child(int, struct sockaddr *);
static int faith_prefix(struct sockaddr *);
static int map6to4(struct sockaddr_in6 *, struct sockaddr_in *);
static void sig_child(int);
static void sig_terminate(int);
static void start_daemon(void);
static void exit_stderr(const char *, ...)
	__attribute__((__format__(__printf__, 1, 2)));
static void grab_myaddrs(void);
static void free_myaddrs(void);
static void update_myaddrs(void);
static void usage(void);

int
main(int argc, char **argv)
{

	/*
	 * Initializing stuff
	 */

	faithdname = strrchr(argv[0], '/');
	if (faithdname)
		faithdname++;
	else
		faithdname = argv[0];

#if 0
	if (strcmp(faithdname, "faithd") != 0) {
		inetd = 1;
		return inetd_main(argc, argv);
	} else
		return daemon_main(argc, argv);
#else
	return daemon_main(argc, argv);
#endif
}

#if 0
static int
inetd_main(int argc, char **argv)
{
	char path[MAXPATHLEN];
	struct sockaddr_storage me;
	struct sockaddr_storage from;
	socklen_t melen, fromlen;
	int i;
	int error;
	const int on = 1;
	char sbuf[NI_MAXSERV], snum[NI_MAXSERV];

	if (config_load(configfile) < 0 && configfile) {
		exit_failure("could not load config file");
		/*NOTREACHED*/
	}

	if (strrchr(argv[0], '/') == NULL)
		snprintf(path, sizeof(path), "%s/%s", DEFAULT_DIR, argv[0]);
	else
		snprintf(path, sizeof(path), "%s", argv[0]);

#ifdef USE_ROUTE
	grab_myaddrs();

	sockfd = socket(PF_ROUTE, SOCK_RAW, PF_UNSPEC);
	if (sockfd < 0) {
		exit_failure("socket(PF_ROUTE): %s", strerror(errno));
		/*NOTREACHED*/
	}
#endif

	melen = sizeof(me);
	if (getsockname(STDIN_FILENO, (struct sockaddr *)&me, &melen) < 0) {
		exit_failure("getsockname: %s", strerror(errno));
		/*NOTREACHED*/
	}
	fromlen = sizeof(from);
	if (getpeername(STDIN_FILENO, (struct sockaddr *)&from, &fromlen) < 0) {
		exit_failure("getpeername: %s", strerror(errno));
		/*NOTREACHED*/
	}
	if (getnameinfo((struct sockaddr *)&me, melen, NULL, 0,
	    sbuf, sizeof(sbuf), NI_NUMERICHOST) == 0)
		service = sbuf;
	else
		service = DEFAULT_PORT_NAME;
	if (getnameinfo((struct sockaddr *)&me, melen, NULL, 0,
	    snum, sizeof(snum), NI_NUMERICHOST) != 0)
		snprintf(snum, sizeof(snum), "?");

	snprintf(logname, sizeof(logname), "faithd %s", snum);
	snprintf(procname, sizeof(procname), "accepting port %s", snum);
	openlog(logname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);

	if (argc >= MAXARGV) {
		exit_failure("too many arguments");
		/*NOTREACHED*/
	}
	serverarg[0] = serverpath = path;
	for (i = 1; i < argc; i++)
		serverarg[i] = argv[i];
	serverarg[i] = NULL;

	error = setsockopt(STDIN_FILENO, SOL_SOCKET, SO_OOBINLINE, &on,
	    sizeof(on));
	if (error < 0) {
		exit_failure("setsockopt(SO_OOBINLINE): %s", strerror(errno));
		/*NOTREACHED*/
	}

	play_child(STDIN_FILENO, (struct sockaddr *)&from);
	exit_failure("should not reach here");
	return 0;	/*dummy!*/
}
#endif

static int
daemon_main(int argc, char **argv)
{
	struct addrinfo hints, *res;
	int s_wld, error, i, serverargc, on = 1;
	int family = AF_INET6;
	int c;

	while ((c = getopt(argc, argv, "df:p")) != -1) {
		switch (c) {
		case 'd':
			dflag++;
			break;
		case 'f':
			configfile = optarg;
			break;
		case 'p':
			pflag++;
			break;
		default:
			usage();
			/*NOTREACHED*/
		}
	}
	argc -= optind;
	argv += optind;

	if (config_load(configfile) < 0 && configfile) {
		exit_failure("could not load config file");
		/*NOTREACHED*/
	}


#ifdef USE_ROUTE
	grab_myaddrs();
#endif

	switch (argc) {
	case 0:
		usage();
		/*NOTREACHED*/
	default:
		serverargc = argc - NUMARG;
		if (serverargc >= MAXARGV)
			exit_stderr("too many arguments");

		serverpath = strdup(argv[NUMPRG]);
		if (!serverpath)
			exit_stderr("not enough core");
		for (i = 0; i < serverargc; i++) {
			serverarg[i] = strdup(argv[i + NUMARG]);
			if (!serverarg[i])
				exit_stderr("not enough core");
		}
		serverarg[i] = NULL;
		/* fall throuth */
	case 1:	/* no local service */
		service = argv[NUMPRT];
		break;
	}

	start_daemon();

	/*
	 * Opening wild card socket for this service.
	 */

	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_PASSIVE;
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	error = getaddrinfo(NULL, service, &hints, &res);
	if (error)
		exit_failure("getaddrinfo: %s", gai_strerror(error));

	s_wld = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (s_wld == -1)
		exit_failure("socket: %s", strerror(errno));

#ifdef IPV6_FAITH
	if (res->ai_family == AF_INET6) {
		error = setsockopt(s_wld, IPPROTO_IPV6, IPV6_FAITH, &on, sizeof(on));
		if (error == -1)
			exit_failure("setsockopt(IPV6_FAITH): %s",
			    strerror(errno));
	}
#endif

	error = setsockopt(s_wld, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
	if (error == -1)
		exit_failure("setsockopt(SO_REUSEADDR): %s", strerror(errno));
	
	error = setsockopt(s_wld, SOL_SOCKET, SO_OOBINLINE, &on, sizeof(on));
	if (error == -1)
		exit_failure("setsockopt(SO_OOBINLINE): %s", strerror(errno));

#ifdef IPV6_V6ONLY
	error = setsockopt(s_wld, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on));
	if (error == -1)
		exit_failure("setsockopt(IPV6_V6ONLY): %s", strerror(errno));
#endif

	error = bind(s_wld, (struct sockaddr *)res->ai_addr, res->ai_addrlen);
	if (error == -1)
		exit_failure("bind: %s", strerror(errno));

	error = listen(s_wld, 5);
	if (error == -1)
		exit_failure("listen: %s", strerror(errno));

#ifdef USE_ROUTE
	sockfd = socket(PF_ROUTE, SOCK_RAW, PF_UNSPEC);
	if (sockfd < 0) {
		exit_failure("socket(PF_ROUTE): %s", strerror(errno));
		/*NOTREACHED*/
	}
#endif

	/*
	 * Everything is OK.
	 */

	snprintf(logname, sizeof(logname), "faithd %s", service);
	snprintf(procname, sizeof(procname), "accepting port %s", service);
	openlog(logname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
	syslog(LOG_INFO, "Starting faith daemon for %s port", service);

	play_service(s_wld);
	/* NOTREACHED */
	exit(1);	/*pacify gcc*/
}

static void
play_service(int s_wld)
{
	struct sockaddr_storage srcaddr;
	socklen_t len;
	int s_src;
	pid_t child_pid;
	struct pollfd pfd[2];
	int error;
	int maxfd;

	/*
	 * Wait, accept, fork, faith....
	 */
again:
	setproctitle("%s", procname);

	pfd[0].fd = s_wld;
	pfd[0].events = POLLIN;
	pfd[1].revents = 0;
	maxfd = 1;
#ifdef USE_ROUTE
	if (sockfd) {
		pfd[1].fd = sockfd;
		pfd[1].events = POLLIN;
		maxfd = 2;
	}
#endif

	error = poll(pfd, maxfd, INFTIM);
	if (error < 0) {
		if (errno == EINTR)
			goto again;
		exit_failure("poll: %s", strerror(errno));
		/*NOTREACHED*/
	}

#ifdef USE_ROUTE
	if (pfd[1].revents & POLLIN) {
		update_myaddrs();
	}
#endif
	if (pfd[0].revents & POLLIN) {
		len = sizeof(srcaddr);
		s_src = accept(s_wld, (struct sockaddr *)&srcaddr, &len);
		if (s_src < 0) {
			if (errno == ECONNABORTED)
				goto again;
			exit_failure("socket: %s", strerror(errno));
			/*NOTREACHED*/
		}
		if (srcaddr.ss_family == AF_INET6 &&
		    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)&srcaddr)->sin6_addr)) {
			close(s_src);
			syslog(LOG_ERR, "connection from IPv4 mapped address?");
			goto again;
		}

		child_pid = fork();

		if (child_pid == 0) {
			/* child process */
			close(s_wld);
			closelog();
			openlog(logname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
			play_child(s_src, (struct sockaddr *)&srcaddr);
			exit_failure("should never reach here");
			/*NOTREACHED*/
		} else {
			/* parent process */
			close(s_src);
			if (child_pid == -1)
				syslog(LOG_ERR, "can't fork");
		}
	}
	goto again;
}

static void
play_child(int s_src, struct sockaddr *srcaddr)
{
	struct sockaddr_storage dstaddr6;
	struct sockaddr_storage dstaddr4;
	char src[NI_MAXHOST];
	char dst6[NI_MAXHOST];
	char dst4[NI_MAXHOST];
	socklen_t len = sizeof(dstaddr6);
	int s_dst, error, hport, nresvport, on = 1;
	struct timeval tv;
	struct sockaddr *sa4;
	const struct config *conf;
	
	tv.tv_sec = 1;
	tv.tv_usec = 0;

	getnameinfo(srcaddr, srcaddr->sa_len,
	    src, sizeof(src), NULL, 0, NI_NUMERICHOST);
	syslog(LOG_INFO, "accepted a client from %s", src);

	error = getsockname(s_src, (struct sockaddr *)&dstaddr6, &len);
	if (error == -1) {
		exit_failure("getsockname: %s", strerror(errno));
		/*NOTREACHED*/
	}

	getnameinfo((struct sockaddr *)&dstaddr6, len,
	    dst6, sizeof(dst6), NULL, 0, NI_NUMERICHOST);
	syslog(LOG_INFO, "the client is connecting to %s", dst6);
	
	if (!faith_prefix((struct sockaddr *)&dstaddr6)) {
		if (serverpath) {
			/*
			 * Local service
			 */
			syslog(LOG_INFO, "executing local %s", serverpath);
			if (!inetd) {
				dup2(s_src, 0);
				close(s_src);
				dup2(0, 1);
				dup2(0, 2);
			}
			execv(serverpath, serverarg);
			syslog(LOG_ERR, "execv %s: %s", serverpath,
			    strerror(errno));
			_exit(EXIT_FAILURE);
		} else {
			close(s_src);
			exit_success("no local service for %s", service);
		}
	}

	/*
	 * Act as a translator
	 */

	switch (((struct sockaddr *)&dstaddr6)->sa_family) {
	case AF_INET6:
		if (!map6to4((struct sockaddr_in6 *)&dstaddr6,
		    (struct sockaddr_in *)&dstaddr4)) {
			close(s_src);
			exit_failure("map6to4 failed");
			/*NOTREACHED*/
		}
		syslog(LOG_INFO, "translating from v6 to v4");
		break;
	default:
		close(s_src);
		exit_failure("family not supported");
		/*NOTREACHED*/
	}

	sa4 = (struct sockaddr *)&dstaddr4;
	getnameinfo(sa4, sa4->sa_len,
	    dst4, sizeof(dst4), NULL, 0, NI_NUMERICHOST);

	conf = config_match(srcaddr, sa4);
	if (!conf || !conf->permit) {
		close(s_src);
		if (conf) {
			exit_failure("translation to %s not permitted for %s",
			    dst4, prefix_string(&conf->match));
			/*NOTREACHED*/
		} else {
			exit_failure("translation to %s not permitted", dst4);
			/*NOTREACHED*/
		}
	}

	syslog(LOG_INFO, "the translator is connecting to %s", dst4);

	setproctitle("port %s, %s -> %s", service, src, dst4);

	if (sa4->sa_family == AF_INET6)
		hport = ntohs(((struct sockaddr_in6 *)&dstaddr4)->sin6_port);
	else /* AF_INET */
		hport = ntohs(((struct sockaddr_in *)&dstaddr4)->sin_port);

	if (pflag)
		s_dst = rresvport_af(&nresvport, sa4->sa_family);
	else
		s_dst = socket(sa4->sa_family, SOCK_STREAM, 0);
	if (s_dst < 0) {
		exit_failure("socket: %s", strerror(errno));
		/*NOTREACHED*/
	}

	if (conf->src.a.ss_family) {
		if (bind(s_dst, (const struct sockaddr *)&conf->src.a,
		    conf->src.a.ss_len) < 0) {
			exit_failure("bind: %s", strerror(errno));
			/*NOTREACHED*/
		}
	}

	error = setsockopt(s_dst, SOL_SOCKET, SO_OOBINLINE, &on, sizeof(on));
	if (error < 0) {
		exit_failure("setsockopt(SO_OOBINLINE): %s", strerror(errno));
		/*NOTREACHED*/
	}

	error = setsockopt(s_src, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
	if (error < 0) {
		exit_failure("setsockopt(SO_SNDTIMEO): %s", strerror(errno));
		/*NOTREACHED*/
	}
	error = setsockopt(s_dst, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
	if (error < 0) {
		exit_failure("setsockopt(SO_SNDTIMEO): %s", strerror(errno));
		/*NOTREACHED*/
	}

	error = connect(s_dst, sa4, sa4->sa_len);
	if (error < 0) {
		exit_failure("connect: %s", strerror(errno));
		/*NOTREACHED*/
	}

	switch (hport) {
	case FTP_PORT:
		ftp_relay(s_src, s_dst);
		break;
	default:
		tcp_relay(s_src, s_dst, service);
		break;
	}

	/* NOTREACHED */
}

/* 0: non faith, 1: faith */
static int
faith_prefix(struct sockaddr *dst)
{
#ifndef USE_ROUTE
	int mib[4], size;
	struct in6_addr faith_prefix;
	struct sockaddr_in6 *dst6 = (struct sockaddr_in *)dst;

	if (dst->sa_family != AF_INET6)
		return 0;

	mib[0] = CTL_NET;
	mib[1] = PF_INET6;
	mib[2] = IPPROTO_IPV6;
	mib[3] = IPV6CTL_FAITH_PREFIX;
	size = sizeof(struct in6_addr);
	if (sysctl(mib, 4, &faith_prefix, &size, NULL, 0) < 0) {
		exit_failure("sysctl: %s", strerror(errno));
		/*NOTREACHED*/
	}

	if (memcmp(dst, &faith_prefix,
	    sizeof(struct in6_addr) - sizeof(struct in_addr) == 0) {
		return 1;
	}
	return 0;
#else
	struct myaddrs *p;
	struct sockaddr_in6 *sin6;
	struct sockaddr_in *sin4;
	struct sockaddr_in6 *dst6;
	struct sockaddr_in *dst4;
	struct sockaddr_in dstmap;

	dst6 = (struct sockaddr_in6 *)dst;
	if (dst->sa_family == AF_INET6 &&
	    IN6_IS_ADDR_V4MAPPED(&dst6->sin6_addr)) {
		/* ugly... */
		memset(&dstmap, 0, sizeof(dstmap));
		dstmap.sin_family = AF_INET;
		dstmap.sin_len = sizeof(dstmap);
		memcpy(&dstmap.sin_addr, &dst6->sin6_addr.s6_addr[12],
		    sizeof(dstmap.sin_addr));
		dst = (struct sockaddr *)&dstmap;
	}

	dst6 = (struct sockaddr_in6 *)dst;
	dst4 = (struct sockaddr_in *)dst;

	for (p = myaddrs; p; p = p->next) {
		sin6 = (struct sockaddr_in6 *)p->addr;
		sin4 = (struct sockaddr_in *)p->addr;

		if (p->addr->sa_len != dst->sa_len ||
		    p->addr->sa_family != dst->sa_family)
			continue;

		switch (dst->sa_family) {
		case AF_INET6:
			if (sin6->sin6_scope_id == dst6->sin6_scope_id &&
			    IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &dst6->sin6_addr))
				return 0;
			break;
		case AF_INET:
			if (sin4->sin_addr.s_addr == dst4->sin_addr.s_addr)
				return 0;
			break;
		}
	}
	return 1;
#endif
}

/* 0: non faith, 1: faith */
static int
map6to4(struct sockaddr_in6 *dst6, struct sockaddr_in *dst4)
{
	memset(dst4, 0, sizeof(*dst4));
	dst4->sin_len = sizeof(*dst4);
	dst4->sin_family = AF_INET;
	dst4->sin_port = dst6->sin6_port;
	memcpy(&dst4->sin_addr, &dst6->sin6_addr.s6_addr[12],
	    sizeof(dst4->sin_addr));

	if (dst4->sin_addr.s_addr == INADDR_ANY ||
	    dst4->sin_addr.s_addr == INADDR_BROADCAST ||
	    IN_MULTICAST(ntohl(dst4->sin_addr.s_addr)))
		return 0;
	return 1;
}


static void
sig_child(int sig)
{
	int save_errno = errno, status;
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	pid_t pid;

	while ((pid = wait3(&status, WNOHANG, (struct rusage *)0)) > 0) {
		if (pid && WEXITSTATUS(status))
			syslog_r(LOG_WARNING, &sdata,
			    "child %ld exit status 0x%x", (long)pid, status);
	}

	errno = save_errno;
}

void
sig_terminate(int sig)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	syslog_r(LOG_INFO, &sdata, "Terminating faith daemon");	
	_exit(EXIT_SUCCESS);
}

static void
start_daemon(void)
{
#ifdef SA_NOCLDWAIT
	struct sigaction sa;
#endif

	if (daemon(0, 0) == -1)
		exit_stderr("daemon: %s", strerror(errno));

#ifdef SA_NOCLDWAIT
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = sig_child;
	sa.sa_flags = SA_NOCLDWAIT;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGCHLD, &sa, (struct sigaction *)0);
#else
	if (signal(SIGCHLD, sig_child) == SIG_ERR) {
		exit_failure("signal CHLD: %s", strerror(errno));
		/*NOTREACHED*/
	}
#endif

	if (signal(SIGTERM, sig_terminate) == SIG_ERR) {
		exit_failure("signal TERM: %s", strerror(errno));
		/*NOTREACHED*/
	}
}

static void
exit_stderr(const char *fmt, ...)
{
	va_list ap;
	char buf[BUFSIZ];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	fprintf(stderr, "%s\n", buf);
	exit(EXIT_FAILURE);
}

void
exit_failure(const char *fmt, ...)
{
	va_list ap;
	char buf[BUFSIZ];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	syslog(LOG_ERR, "%s", buf);
	exit(EXIT_FAILURE);
}

void
exit_success(const char *fmt, ...)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	va_list ap;
	char buf[BUFSIZ];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	syslog_r(LOG_INFO, &sdata, "%s", buf);
	_exit(EXIT_SUCCESS);
}

#ifdef USE_ROUTE
static void
grab_myaddrs()
{
	struct ifaddrs *ifap, *ifa;
	struct myaddrs *p;
	struct sockaddr_in6 *sin6;

	if (getifaddrs(&ifap) != 0) {
		exit_failure("getifaddrs");
		/*NOTREACHED*/
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
		case AF_INET6:
			break;
		default:
			continue;
		}

		p = (struct myaddrs *)malloc(sizeof(struct myaddrs) +
		    ifa->ifa_addr->sa_len);
		if (!p) {
			exit_failure("not enough core");
			/*NOTREACHED*/
		}
		memcpy(p + 1, ifa->ifa_addr, ifa->ifa_addr->sa_len);
		p->next = myaddrs;
		p->addr = (struct sockaddr *)(p + 1);
#ifdef __KAME__
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			sin6 = (struct sockaddr_in6 *)p->addr;
			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) ||
			    IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr)) {
				sin6->sin6_scope_id =
				    ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
				sin6->sin6_addr.s6_addr[2] = 0;
				sin6->sin6_addr.s6_addr[3] = 0;
			}
		}
#endif
		myaddrs = p;
		if (dflag) {
			char hbuf[NI_MAXHOST];

			getnameinfo(p->addr, p->addr->sa_len,
			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
			syslog(LOG_INFO, "my interface: %s %s", hbuf,
			    ifa->ifa_name);
		}
	}

	freeifaddrs(ifap);
}

static void
free_myaddrs()
{
	struct myaddrs *p, *q;

	p = myaddrs;
	while (p) {
		q = p->next;
		free(p);
		p = q;
	}
	myaddrs = NULL;
}

static void
update_myaddrs()
{
	char msg[BUFSIZ];
	int len;
	struct rt_msghdr *rtm;

	len = read(sockfd, msg, sizeof(msg));
	if (len < 0) {
		syslog(LOG_ERR, "read(PF_ROUTE) failed");
		return;
	}
	rtm = (struct rt_msghdr *)msg;
	if (len < 4 || len < rtm->rtm_msglen) {
		syslog(LOG_ERR, "read(PF_ROUTE) short read");
		return;
	}
	if (rtm->rtm_version != RTM_VERSION)
		return;
	switch (rtm->rtm_type) {
	case RTM_NEWADDR:
	case RTM_DELADDR:
	case RTM_IFINFO:
		break;
	default:
		return;
	}
	/* XXX more filters here? */

	syslog(LOG_INFO, "update interface address list");
	free_myaddrs();
	grab_myaddrs();
}
#endif /*USE_ROUTE*/

static void
usage()
{
	fprintf(stderr,
	    "usage: %s [-dp] [-f configfile] service [serverpath [serverargs]]\n",
	    faithdname);
	exit(0);
}
@


1.31
log
@fix typo; spotted by Peter J. Philipp
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.30 2009/06/26 09:51:29 claudio Exp $	*/
@


1.30
log
@There is no need to log routing socket version mismatches.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.29 2008/05/17 23:31:52 sobrado Exp $	*/
d349 1
a349 1
	syslog(LOG_INFO, "Staring faith daemon for %s port", service);
@


1.29
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.28 2003/10/16 05:27:33 itojun Exp $	*/
d860 1
a860 4
	if (rtm->rtm_version != RTM_VERSION) {
		syslog(LOG_ERR, "routing socket version mismatch");
		close(sockfd);
		sockfd = 0;
a861 1
	}
@


1.28
log
@poll() arg mistake.  Tatoku Ogaito
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.27 2003/09/02 23:35:24 itojun Exp $	*/
d885 2
a886 1
	fprintf(stderr, "usage: %s [-dp] [-f conf] service [serverpath [serverargs]]\n",
@


1.27
log
@no need for extra {}.  sync w/ kame
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.26 2003/09/02 22:55:26 deraadt Exp $	*/
d385 1
a385 1
	error = poll(pfd, maxfd, 0);
@


1.26
log
@use poll since it is easier than fd_set overflows; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.25 2003/05/15 00:27:29 itojun Exp $	*/
a264 1
	    {
a278 1
	    }
@


1.25
log
@kill unused
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.24 2003/05/15 00:26:55 itojun Exp $	*/
d52 1
d85 1
d91 1
d365 1
a365 1
	fd_set rfds;
d375 4
a378 5
	FD_ZERO(&rfds);
	if (s_wld >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_SET(s_wld, &rfds);
	maxfd = s_wld;
d381 3
a383 4
		if (sockfd >= FD_SETSIZE)
			exit_failure("descriptor too big");
		FD_SET(sockfd, &rfds);
		maxfd = (maxfd < sockfd) ? sockfd : maxfd;
d387 1
a387 1
	error = select(maxfd + 1, &rfds, NULL, NULL, NULL);
d391 1
a391 1
		exit_failure("select: %s", strerror(errno));
d396 1
a396 1
	if (FD_ISSET(sockfd, &rfds)) {
d400 1
a400 1
	if (FD_ISSET(s_wld, &rfds)) {
d454 1
a454 1
		src, sizeof(src), NULL, 0, NI_NUMERICHOST);
d464 1
a464 1
		dst6, sizeof(dst6), NULL, 0, NI_NUMERICHOST);
d511 1
a511 1
		dst4, sizeof(dst4), NULL, 0, NI_NUMERICHOST);
d610 1
a610 1
			sizeof(struct in6_addr) - sizeof(struct in_addr) == 0) {
d623 2
a624 2
	if (dst->sa_family == AF_INET6
	 && IN6_IS_ADDR_V4MAPPED(&dst6->sin6_addr)) {
d630 1
a630 1
			sizeof(dstmap.sin_addr));
d641 2
a642 2
		if (p->addr->sa_len != dst->sa_len
		 || p->addr->sa_family != dst->sa_family)
d647 2
a648 2
			if (sin6->sin6_scope_id == dst6->sin6_scope_id
			 && IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &dst6->sin6_addr))
d670 1
a670 1
		sizeof(dst4->sin_addr));
d672 3
a674 3
	if (dst4->sin_addr.s_addr == INADDR_ANY
	 || dst4->sin_addr.s_addr == INADDR_BROADCAST
	 || IN_MULTICAST(ntohl(dst4->sin_addr.s_addr)))
a675 1

d808 2
a809 2
			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)
			 || IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr)) {
d811 1
a811 1
					ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
d820 1
d822 1
a822 2
				hbuf, sizeof(hbuf), NULL, 0,
				NI_NUMERICHOST);
d888 1
a888 1
		faithdname);
@


1.24
log
@simplify by strdup.  expilcitly specify IPPROTO_TCP (to cope with sctp-ready
getaddrinfo).
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.23 2003/03/13 09:09:46 deraadt Exp $	*/
a262 2
		int len;

@


1.23
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.22 2002/09/08 01:20:15 itojun Exp $	*/
d269 1
a269 2
		len = strlen(argv[NUMPRG]) + 1;
		serverpath = malloc(len);
a271 1
		strlcpy(serverpath, argv[NUMPRG], len);
d273 1
a273 3
			int len = strlen(argv[i + NUMARG]) + 1;

			serverarg[i] = malloc(len);
a275 1
			strlcpy(serverarg[i], argv[i + NUMARG], len);
d295 1
a295 1
	hints.ai_protocol = 0;
@


1.22
log
@-ansi -pedantic (socklen_t).  from cloder@@loder.us
die if FD_SET overruns.
sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.21 2002/06/07 00:18:05 itojun Exp $	*/
d262 3
d269 2
a270 1
		serverpath = malloc(strlen(argv[NUMPRG]) + 1);
d273 1
a273 1
		strcpy(serverpath, argv[NUMPRG]);
d275 3
a277 1
			serverarg[i] = malloc(strlen(argv[i + NUMARG]) + 1);
d280 1
a280 1
			strcpy(serverarg[i], argv[i + NUMARG]);
d284 1
@


1.21
log
@nuke unmaintained code (#ifdef FAITH4).  sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.20 2002/05/26 01:21:12 deraadt Exp $	*/
/*	$KAME: faithd.c,v 1.50 2002/05/09 14:06:52 itojun Exp $	*/
d149 1
a149 1
	int melen, fromlen;
a226 3
#ifdef FAITH_NS
	char *ns;
#endif /* FAITH_NS */
a251 17
#ifdef FAITH_NS
	if ((ns = getenv(FAITH_NS)) != NULL) {
		struct sockaddr_storage ss;
		struct addrinfo hints, *res;
		char serv[NI_MAXSERV];

		memset(&ss, 0, sizeof(ss));
		memset(&hints, 0, sizeof(hints));
		snprintf(serv, sizeof(serv), "%u", NAMESERVER_PORT);
		hints.ai_flags = AI_NUMERICHOST;
		if (getaddrinfo(ns, serv, &hints, &res) ==  0) {
			res_init();
			memcpy(&_res_ext.nsaddr, res->ai_addr, res->ai_addrlen);
			_res.nscount = 1;
		}
	}
#endif /* FAITH_NS */
d319 6
d359 1
a359 1
	int len;
d373 2
d379 2
d401 1
a401 2
		s_src = accept(s_wld, (struct sockaddr *)&srcaddr,
			&len);
d408 6
d416 1
a416 1
		
d443 1
a443 1
	int len = sizeof(dstaddr6);
@


1.20
log
@pid_t cleanup; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.19 2002/05/09 14:12:17 itojun Exp $	*/
a75 8
#ifdef FAITH4
#include <resolv.h>
#include <arpa/nameser.h>
#ifndef FAITH_NS
#define FAITH_NS "FAITH_NS"
#endif
#endif

a106 3
#ifdef FAITH4
static int map4to6(struct sockaddr_in *, struct sockaddr_in6 *);
#endif
d231 1
a231 1
	while ((c = getopt(argc, argv, "df:p46")) != -1) {
a241 8
#ifdef FAITH4
		case '4':
			family = AF_INET;
			break;
		case '6':
			family = AF_INET6;
			break;
#endif
a329 10
#ifdef FAITH4
#ifdef IP_FAITH
	if (res->ai_family == AF_INET) {
		error = setsockopt(s_wld, IPPROTO_IP, IP_FAITH, &on, sizeof(on));
		if (error == -1)
			exit_failure("setsockopt(IP_FAITH): %s",
			    strerror(errno));
	}
#endif
#endif /* FAITH4 */
a506 11
#ifdef FAITH4
	case AF_INET:
		if (!map4to6((struct sockaddr_in *)&dstaddr6,
		    (struct sockaddr_in6 *)&dstaddr4)) {
			close(s_src);
			exit_failure("map4to6 failed");
			/*NOTREACHED*/
		}
		syslog(LOG_INFO, "translating from v4 to v6");
		break;
#endif
a683 33
#ifdef FAITH4
/* 0: non faith, 1: faith */
static int
map4to6(struct sockaddr_in *dst4, struct sockaddr_in6 *dst6)
{
	char host[NI_MAXHOST];
	char serv[NI_MAXSERV];
	struct addrinfo hints, *res;
	int ai_errno;

	if (getnameinfo((struct sockaddr *)dst4, dst4->sin_len, host, sizeof(host),
			serv, sizeof(serv), NI_NAMEREQD|NI_NUMERICSERV) != 0)
		return 0;

	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = 0;
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = 0;

	if ((ai_errno = getaddrinfo(host, serv, &hints, &res)) != 0) {
		syslog(LOG_INFO, "%s %s: %s", host, serv,
		    gai_strerror(ai_errno));
		return 0;
	}

	memcpy(dst6, res->ai_addr, res->ai_addrlen);

	freeaddrinfo(res);

	return 1;
}
#endif /* FAITH4 */
@


1.19
log
@drop support for rlogin/rsh service (we shouldn't have support it as
they usually use IP address for authentication).  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.18 2002/02/16 21:28:02 millert Exp $	*/
d768 1
a768 1
			    "child %d exit status 0x%x", pid, status);
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.17 2002/01/11 03:51:08 itojun Exp $	*/
/*	$KAME: faithd.c,v 1.40 2001/07/02 14:36:48 itojun Exp $	*/
d442 3
a444 1
		if (s_src == -1) {
d474 3
a476 3
	char src[MAXHOSTNAMELEN];
	char dst6[MAXHOSTNAMELEN];
	char dst4[MAXHOSTNAMELEN];
d579 1
a579 3
	switch (hport) {
	case RLOGIN_PORT:
	case RSH_PORT:
d581 2
a582 8
		break;
	default:
		if (pflag)
			s_dst = rresvport_af(&nresvport, sa4->sa_family);
		else
			s_dst = socket(sa4->sa_family, SOCK_STREAM, 0);
		break;
	}
a622 9
	case RSH_PORT:
		syslog(LOG_WARNING,
		    "WARINNG: it is insecure to relay rsh port");
		rsh_relay(s_src, s_dst);
		break;
	case RLOGIN_PORT:
		syslog(LOG_WARNING,
		    "WARINNG: it is insecure to relay rlogin port");
		/*FALLTHROUGH*/
@


1.17
log
@call daemon(3) prior to socket setups to avoid file descriptor close mistakes.
noted by markus, sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.16 2001/11/21 04:54:51 itojun Exp $	*/
d106 1
a106 1
int main __P((int, char **));
d108 1
a108 1
static int inetd_main __P((int, char **));
d110 5
a114 5
static int daemon_main __P((int, char **));
static void play_service __P((int));
static void play_child __P((int, struct sockaddr *));
static int faith_prefix __P((struct sockaddr *));
static int map6to4 __P((struct sockaddr_in6 *, struct sockaddr_in *));
d116 1
a116 1
static int map4to6 __P((struct sockaddr_in *, struct sockaddr_in6 *));
d118 4
a121 4
static void sig_child __P((int));
static void sig_terminate __P((int));
static void start_daemon __P((void));
static void exit_stderr __P((const char *, ...))
d123 4
a126 4
static void grab_myaddrs __P((void));
static void free_myaddrs __P((void));
static void update_myaddrs __P((void));
static void usage __P((void));
@


1.16
log
@assume the presense of getifaddrs(3).  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.15 2001/11/21 04:53:13 itojun Exp $	*/
d322 2
d335 1
a335 1
		exit_stderr("getaddrinfo: %s", gai_strerror(error));
d339 1
a339 1
		exit_stderr("socket: %s", strerror(errno));
d345 1
a345 1
			exit_stderr("setsockopt(IPV6_FAITH): %s",
d354 1
a354 1
			exit_stderr("setsockopt(IP_FAITH): %s",
d362 1
a362 1
		exit_stderr("setsockopt(SO_REUSEADDR): %s", strerror(errno));
d366 1
a366 1
		exit_stderr("setsockopt(SO_OOBINLINE): %s", strerror(errno));
d370 1
a370 1
		exit_stderr("bind: %s", strerror(errno));
d374 1
a374 1
		exit_stderr("listen: %s", strerror(errno));
d379 1
a379 1
		exit_stderr("socket(PF_ROUTE): %s", strerror(errno));
a387 2
	start_daemon();

d780 1
a780 1
	while ((pid = wait3(&status, WNOHANG, (struct rusage *)0)) != -1) {
@


1.15
log
@be more careful on malloc failures.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.14 2001/11/05 09:56:01 deraadt Exp $	*/
a38 1
#define HAVE_GETIFADDRS
a73 1
#ifdef HAVE_GETIFADDRS
a74 1
#endif
a122 3
#ifndef HAVE_GETIFADDRS
static unsigned int if_maxindex __P((void));
#endif
a867 17
#ifndef HAVE_GETIFADDRS
static unsigned int
if_maxindex()
{
	struct if_nameindex *p, *p0;
	unsigned int max = 0;

	p0 = if_nameindex();
	for (p = p0; p && p->if_index && p->if_name; p++) {
		if (max < p->if_index)
			max = p->if_index;
	}
	if_freenameindex(p0);
	return max;
}
#endif

a870 1
#ifdef HAVE_GETIFADDRS
a921 88
#else
	int s;
	unsigned int maxif;
	struct ifreq *iflist;
	struct ifconf ifconf;
	struct ifreq *ifr, *ifrp, *ifr_end;
	struct myaddrs *p;
	struct sockaddr_in6 *sin6;
	size_t siz;
	char ifrbuf[sizeof(struct ifreq) + 1024];

	maxif = if_maxindex() + 1;
	iflist = (struct ifreq *)malloc(maxif * BUFSIZ);	/* XXX */
	if (!iflist) {
		exit_failure("not enough core");
		/*NOTREACHED*/
	}

	if ((s = socket(PF_INET, SOCK_DGRAM, 0)) < 0) {
		exit_failure("socket(SOCK_DGRAM)");
		/*NOTREACHED*/
	}
	memset(&ifconf, 0, sizeof(ifconf));
	ifconf.ifc_req = iflist;
	ifconf.ifc_len = maxif * BUFSIZ;	/* XXX */
	if (ioctl(s, SIOCGIFCONF, &ifconf) < 0) {
		exit_failure("ioctl(SIOCGIFCONF)");
		/*NOTREACHED*/
	}
	close(s);

	/* Look for this interface in the list */
	ifr_end = (struct ifreq *) (ifconf.ifc_buf + ifconf.ifc_len);
	for (ifrp = ifconf.ifc_req;
	     ifrp < ifr_end;
	     ifrp = (struct ifreq *)((char *)ifrp + siz)) {
		memcpy(ifrbuf, ifrp, sizeof(*ifrp));
		ifr = (struct ifreq *)ifrbuf;
		siz = ifr->ifr_addr.sa_len;
		if (siz < sizeof(ifr->ifr_addr))
			siz = sizeof(ifr->ifr_addr);
		siz += (sizeof(*ifrp) - sizeof(ifr->ifr_addr));
		if (siz > sizeof(ifrbuf)) {
			/* ifr too big */
			break;
		}
		memcpy(ifrbuf, ifrp, siz);

		switch (ifr->ifr_addr.sa_family) {
		case AF_INET:
		case AF_INET6:
			p = (struct myaddrs *)malloc(sizeof(struct myaddrs)
				+ ifr->ifr_addr.sa_len);
			if (!p) {
				exit_failure("not enough core");
				/*NOTREACHED*/
			}
			memcpy(p + 1, &ifr->ifr_addr, ifr->ifr_addr.sa_len);
			p->next = myaddrs;
			p->addr = (struct sockaddr *)(p + 1);
#ifdef __KAME__
			if (ifr->ifr_addr.sa_family == AF_INET6) {
				sin6 = (struct sockaddr_in6 *)p->addr;
				if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)
				 || IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr)) {
					sin6->sin6_scope_id =
						ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
					sin6->sin6_addr.s6_addr[2] = 0;
					sin6->sin6_addr.s6_addr[3] = 0;
				}
			}
#endif
			myaddrs = p;
			if (dflag) {
				char hbuf[NI_MAXHOST];
				getnameinfo(p->addr, p->addr->sa_len,
					hbuf, sizeof(hbuf), NULL, 0,
					NI_NUMERICHOST);
				syslog(LOG_INFO, "my interface: %s %s", hbuf, ifr->ifr_name);
			}
			break;
		default:
			break;
		}
	}

	free(iflist);
#endif
@


1.14
log
@mark more handlers, and some syslog_r attempts
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.13 2001/09/05 01:31:33 itojun Exp $	*/
d312 2
d317 2
@


1.13
log
@sync with latest kame
- fix select() size.  from deraadt
- constify, remove bogus ERRSTR macro, and others
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.12 2001/05/01 07:40:04 itojun Exp $	*/
d778 2
a779 1
	int status;
d782 7
a788 3
	pid = wait3(&status, WNOHANG, (struct rusage *)0);
	if (pid && WEXITSTATUS(status))
		syslog(LOG_WARNING, "child %d exit status 0x%x", pid, status);
d794 4
a797 2
	syslog(LOG_INFO, "Terminating faith daemon");	
	exit(EXIT_SUCCESS);
d858 1
d865 2
a866 2
	syslog(LOG_INFO, "%s", buf);
	exit(EXIT_SUCCESS);
@


1.12
log
@avodi null pointer dereference.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.11 2001/03/20 01:13:54 itojun Exp $	*/
/*	$KAME: faithd.c,v 1.39 2001/04/25 11:20:42 itojun Exp $	*/
d100 1
a100 1
static char *service;
d187 1
a187 1
		exit_failure("socket(PF_ROUTE): %s", ERRSTR);
d194 1
a194 1
		exit_failure("getsockname: %s", ERRSTR);
d199 1
a199 1
		exit_failure("getpeername: %s", ERRSTR);
d227 1
a227 1
		exit_failure("setsockopt(SO_OOBINLINE): %s", ERRSTR);
d339 1
a339 1
		exit_stderr("socket: %s", ERRSTR);
d345 2
a346 1
			exit_stderr("setsockopt(IPV6_FAITH): %s", ERRSTR);
d354 2
a355 1
			exit_stderr("setsockopt(IP_FAITH): %s", ERRSTR);
d362 1
a362 1
		exit_stderr("setsockopt(SO_REUSEADDR): %s", ERRSTR);
d366 1
a366 1
		exit_stderr("setsockopt(SO_OOBINLINE): %s", ERRSTR);
d370 1
a370 1
		exit_stderr("bind: %s", ERRSTR);
d374 1
a374 1
		exit_stderr("listen: %s", ERRSTR);
d379 1
a379 1
		exit_stderr("socket(PF_ROUTE): %s", ERRSTR);
d431 1
a431 1
		exit_failure("select: %s", ERRSTR);
d445 1
a445 1
			exit_failure("socket: %s", ERRSTR);
d492 1
a492 1
		exit_failure("getsockname: %s", ERRSTR);
d513 2
a514 1
			syslog(LOG_ERR, "execv %s: %s", serverpath, ERRSTR);
d592 1
a592 1
		exit_failure("socket: %s", ERRSTR);
d597 1
a597 1
		if (bind(s_dst, (struct sockaddr *)&conf->src.a,
d599 1
a599 1
			exit_failure("bind: %s", ERRSTR);
d606 1
a606 1
		exit_failure("setsockopt(SO_OOBINLINE): %s", ERRSTR);
d612 1
a612 1
		exit_failure("setsockopt(SO_SNDTIMEO): %s", ERRSTR);
d617 1
a617 1
		exit_failure("setsockopt(SO_SNDTIMEO): %s", ERRSTR);
d623 1
a623 1
		exit_failure("connect: %s", ERRSTR);
d666 1
a666 1
		exit_failure("sysctl: %s", ERRSTR);
d762 2
a763 1
		syslog(LOG_INFO, "%s %s: %s", host, serv, gai_strerror(ai_errno));
d801 1
a801 1
		exit_stderr("daemon: %s", ERRSTR);
d811 1
a811 1
		exit_failure("signal CHLD: %s", ERRSTR);
d817 1
a817 1
		exit_failure("signal TERM: %s", ERRSTR);
@


1.11
log
@avoid zombies on abnormal disconnections.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.10 2001/02/15 17:37:33 itojun Exp $	*/
/*	$KAME: faithd.c,v 1.38 2001/02/27 06:46:52 itojun Exp $	*/
d557 8
a564 3
		exit_failure("translation to %s not permitted for %s", dst4,
		    prefix_string(&conf->match));
		/*NOTREACHED*/
@


1.10
log
@pull latest KAME faithd.  access control is possible by /etc/faithd.conf.
req'ed by todd
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.9 2000/10/06 02:46:58 itojun Exp $	*/
/*	$KAME: faithd.c,v 1.35 2001/02/10 05:24:52 itojun Exp $	*/
d787 4
d794 7
d805 1
@


1.9
log
@printf string format audit.  from: sommerfeld@@netbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.8 2000/09/16 10:33:45 itojun Exp $	*/
/*	$KAME: faithd.c,v 1.31 2000/10/05 22:20:37 itojun Exp $	*/
d88 1
d107 1
d172 5
d193 1
a193 1
	if (getsockname(STDIN_FILENO, (struct sockaddr *)&me, &melen) < 0)
d195 2
d198 1
a198 1
	if (getpeername(STDIN_FILENO, (struct sockaddr *)&from, &fromlen) < 0)
d200 2
d215 1
a215 1
	if (argc >= MAXARGV)
d217 2
d226 1
a226 1
	if (error < 0)
d228 2
d248 1
a248 1
	while ((c = getopt(argc, argv, "dp46")) != -1) {
d253 3
d275 5
d442 1
a442 1
		if (s_src == -1)
d444 2
d456 1
d479 1
d489 1
a489 1
	if (error == -1)
d491 2
d529 1
d539 1
d553 9
d583 1
a583 1
	if (s_dst == -1)
d585 10
d597 1
a597 1
	if (error == -1)
d599 2
d603 1
a603 1
	if (error == -1)
d605 2
d608 1
a608 1
	if (error == -1)
d610 2
d614 1
a614 1
	if (error == -1)
d616 2
d624 2
d628 4
d657 1
a657 1
	if (sysctl(mib, 4, &faith_prefix, &size, NULL, 0) < 0)
d659 2
d790 1
a790 1
	if (signal(SIGCHLD, sig_child) == SIG_ERR)
d792 2
d795 1
a795 1
	if (signal(SIGTERM, sig_terminate) == SIG_ERR)
d797 2
d810 1
a810 1
	fprintf(stderr, "%s", buf);
d1059 1
a1059 1
	fprintf(stderr, "usage: %s [-dp] service [serverpath [serverargs]]\n",
@


1.8
log
@synchronize with latest kame.
- improve exit code and logging.
- repair multicast address rejection (IN_MULTICAST takes host endian value)
- repair ftp relaying, when the result of PASV does not have paren.
- repair ftp relaying, when EPSV is sent from client.
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.7 2000/07/05 17:23:13 deraadt Exp $	*/
/*	$KAME: faithd.c,v 1.29 2000/09/12 05:20:35 itojun Exp $	*/
d122 2
a123 1
static void exit_stderr __P((const char *, ...));
d187 1
a187 1
		exit_failure("getsockname");
d190 1
a190 1
		exit_failure("getpeername");
@


1.7
log
@setproctitle with %s
@
text
@d1 2
a2 2
/*	$OpenBSD: faithd.c,v 1.6 2000/06/29 00:21:52 deraadt Exp $	*/
/*	$KAME: faithd.c,v 1.18 2000/05/31 03:06:07 itojun Exp $	*/
d37 1
a37 1
 *   e.g. faithd telnet /usr/local/v6/sbin/telnetd telnetd
d105 1
d108 4
d122 1
d132 1
a132 1
main(int argc, char *argv[])
a133 7
	struct addrinfo hints, *res;
	int s_wld, error, i, serverargc, on = 1;
	int family = AF_INET6;
	int c;
#ifdef FAITH_NS
	char *ns;
#endif /* FAITH_NS */
d145 87
d250 1
a250 1
			break;
d280 2
a281 5
		serverpath = DEFAULT_PATH;
		serverarg[0] = DEFAULT_NAME;
		serverarg[1] = NULL;
		service = DEFAULT_PORT_NAME;
		break;
d284 2
a285 2
		if (serverargc > MAXARGV)
			exit_error("too many augments");
d311 1
a311 1
		exit_error("getaddrinfo: %s", gai_strerror(error));
d315 1
a315 1
		exit_error("socket: %s", ERRSTR);
d321 1
a321 1
			exit_error("setsockopt(IPV6_FAITH): %s", ERRSTR);
d329 1
a329 1
			exit_error("setsockopt(IP_FAITH): %s", ERRSTR);
d336 1
a336 1
		exit_error("setsockopt(SO_REUSEADDR): %s", ERRSTR);
d340 1
a340 1
		exit_error("setsockopt(SO_OOBINLINE): %s", ERRSTR);
d344 1
a344 1
		exit_error("bind: %s", ERRSTR);
d348 1
a348 1
		exit_error("listen: %s", ERRSTR);
d353 1
a353 1
		exit_error("socket(PF_ROUTE): %s", ERRSTR);
d370 1
a370 1
	/*NOTRECHED*/
d474 6
a479 4
			dup2(s_src, 0);
			close(s_src);
			dup2(0, 1);
			dup2(0, 2);
d498 1
a498 1
			exit_error("map6to4 failed");
d507 1
a507 1
			exit_error("map4to6 failed");
d514 1
a514 1
		exit_error("family not supported");
d547 1
a547 1
		exit_error("setsockopt(SO_OOBINLINE): %s", ERRSTR);
d551 1
a551 1
		exit_error("setsockopt(SO_SNDTIMEO): %s", ERRSTR);
d554 1
a554 1
		exit_error("setsockopt(SO_SNDTIMEO): %s", ERRSTR);
d593 1
a593 1
		exit_error("sysctl: %s", ERRSTR);
d660 1
a660 1
	 || IN_MULTICAST(dst4->sin_addr.s_addr))
d706 1
a706 1
	if (pid && status)
d721 1
a721 1
		exit_error("daemon: %s", ERRSTR);
d730 2
a731 2
void
exit_error(const char *fmt, ...)
d739 1
a739 1
	fprintf(stderr, "%s\n", buf);
d988 1
a988 1
	fprintf(stderr, "usage: %s [-dp] [service [serverpath [serverargs]]]\n",
@


1.6
log
@use %s with syslog, at least crashable from command line
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.5 2000/05/31 03:09:22 itojun Exp $	*/
d306 1
a306 1
	setproctitle(procname);
@


1.5
log
@sync with the latest kame code.  insufficient len in malloc() call is
corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.4 2000/02/25 10:25:46 itojun Exp $	*/
d667 1
a667 1
	syslog(LOG_ERR, buf);
d680 1
a680 1
	syslog(LOG_INFO, buf);
@


1.4
log
@use getifaddrs, not SIOCGIFCONF, to avoid LP64 alignment issues.
@
text
@d1 2
a2 1
/*	$OpenBSD: faithd.c,v 1.3 1999/12/30 16:31:01 deraadt Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
a134 2
	extern int optind;
	extern char *optarg;
d204 1
a204 1
		serverpath = malloc(strlen(argv[NUMPRG]));
d207 1
a207 1
			serverarg[i] = malloc(strlen(argv[i + NUMARG]));
d227 1
a227 1
	if (error) 
d360 1
a360 1
	struct sockaddr_storage dstaddr6; 
@


1.4.2.1
log
@Pull in patches from current:
Fix (deraadt):
- setproctitle with %s
- use %s with syslog, at least crashable from command line
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.4 2000/02/25 10:25:46 itojun Exp $	*/
d307 1
a307 1
	setproctitle("%s", procname);
d668 1
a668 1
	syslog(LOG_ERR, "%s", buf);
d681 1
a681 1
	syslog(LOG_INFO, "%s", buf);
@


1.3
log
@correct connect() call
@
text
@d1 1
a1 1
/*	$OpenBSD: faithd.c,v 1.2 1999/12/20 16:32:53 itojun Exp $	*/
d38 1
d74 3
d116 1
d118 1
d686 1
d701 1
d706 53
d763 1
a763 1
	struct ifreq *ifr, *ifr_end;
d766 2
d791 15
a805 4
	for (ifr = ifconf.ifc_req;
	     ifr < ifr_end;
	     ifr = (struct ifreq *) ((char *) &ifr->ifr_addr
				    + ifr->ifr_addr.sa_len)) {
d845 1
@


1.2
log
@rcsid police.
pathname change (/usr/local/v6/libexec -> /usr/libexec)
bring in some of kame fixes (sprintf -> snprintf, proc title).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d466 1
a466 1
	error = connect(s_dst, sa4, sa4->sa_family);
@


1.1
log
@Initial revision
@
text
@d1 2
d88 1
d173 1
a173 1
		sprintf(serv, "%u", NAMESERVER_PORT);
d276 2
a277 1
	sprintf(logname, "accepting port %s", service);
d301 1
a301 1
	setproctitle(logname);
d647 1
a647 1
	vsprintf(buf, fmt, ap);
d660 1
a660 1
	vsprintf(buf, fmt, ap);
d673 1
a673 1
	vsprintf(buf, fmt, ap);
@


1.1.1.1
log
@faith translator deamon, from KAME
@
text
@@
