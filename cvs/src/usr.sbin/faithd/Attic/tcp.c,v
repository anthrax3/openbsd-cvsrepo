head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.44
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.42
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.40
	OPENBSD_5_0:1.12.0.38
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.36
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.34
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.30
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.32
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.28
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.26
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.24
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.22
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.20
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.18
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.16
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.14
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.12
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.10
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.8
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	snap19991220:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2013.03.14.11.08.20;	author mpi;	state dead;
branches;
next	1.12;

1.12
date	2002.09.08.01.20.15;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.26.01.21.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.17.19.49.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.16.19.55.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.05.09.56.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.01.31.33;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.06.02.46.59;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.16.10.33.46;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.31.03.09.22;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.20.16.32.53;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.20.16.07.35;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.20.16.07.35;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.13
log
@tedu faithd(8), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@/*	$OpenBSD: tcp.c,v 1.12 2002/09/08 01:20:15 itojun Exp $	*/
/*	$KAME: tcp.c,v 1.10 2002/08/20 23:01:01 itojun Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "faithd.h"

static char tcpbuf[16*1024];
	/* bigger than MSS and may be lesser than window size */
static int tblen, tboff, oob_exists;
static fd_set readfds, writefds, exceptfds;
static char atmark_buf[2];
static pid_t cpid = (pid_t)0;
static pid_t ppid = (pid_t)0;
volatile time_t child_lastactive = (time_t)0;
static time_t parent_lastactive = (time_t)0;

static void sig_ctimeout(int);
static void sig_child(int);
static void notify_inactive(void);
static void notify_active(void);
static void send_data(int, int, const char *, int);
static void relay(int, int, const char *, int);

/*
 * Inactivity timer:
 * - child side (ppid != 0) will send SIGUSR1 to parent every (FAITH_TIMEOUT/4)
 *   second if traffic is active.  if traffic is inactive, don't send SIGUSR1.
 * - parent side (ppid == 0) will check the last SIGUSR1 it have seen.
 */
static void
sig_ctimeout(int sig)
{
	int save_errno = errno;
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	/* parent side: record notification from the child */
	if (dflag)
		syslog_r(LOG_DEBUG, &sdata, "activity timer from child");
	child_lastactive = time(NULL);
	errno = save_errno;
}

/* parent will terminate if child dies. */
static void
sig_child(int sig)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	int status;
	pid_t pid;

	pid = wait3(&status, WNOHANG, (struct rusage *)0);
	if (pid > 0 && WEXITSTATUS(status))
		syslog_r(LOG_WARNING, &sdata,
		    "child %ld exit status 0x%x", (long)pid, status);
	exit_success("terminate connection due to child termination");
}

static void
notify_inactive()
{
	time_t t;

	/* only on parent side... */
	if (ppid)
		return;

	/* parent side should check for timeout. */
	t = time(NULL);
	if (dflag) {
		syslog(LOG_DEBUG, "parent side %sactive, child side %sactive",
			(FAITH_TIMEOUT < t - parent_lastactive) ? "in" : "",
			(FAITH_TIMEOUT < t - child_lastactive) ? "in" : "");
	}

	if (FAITH_TIMEOUT < t - child_lastactive
	 && FAITH_TIMEOUT < t - parent_lastactive) {
		/* both side timeouted */
		signal(SIGCHLD, SIG_DFL);
		kill(cpid, SIGTERM);
		wait(NULL);
		exit_failure("connection timeout");
		/* NOTREACHED */
	}
}

static void
notify_active()
{
	if (ppid) {
		/* child side: notify parent of active traffic */
		time_t t;
		t = time(NULL);
		if (FAITH_TIMEOUT / 4 < t - child_lastactive) {
			if (kill(ppid, SIGUSR1) < 0) {
				exit_failure("terminate connection due to parent termination");
				/* NOTREACHED */
			}
			child_lastactive = t;
		}
	} else {
		/* parent side */
		parent_lastactive = time(NULL);
	}
}

static void
send_data(int s_rcv, int s_snd, const char *service, int direction)
{
	int cc;

	if (oob_exists) {
		cc = send(s_snd, atmark_buf, 1, MSG_OOB);
		if (cc == -1)
			goto retry_or_err;
		oob_exists = 0;
		if (s_rcv >= FD_SETSIZE)
			exit_failure("descriptor too big");
		FD_SET(s_rcv, &exceptfds);
	}

	for (; tboff < tblen; tboff += cc) {
		cc = write(s_snd, tcpbuf + tboff, tblen - tboff);
		if (cc < 0)
			goto retry_or_err;
	}
#ifdef DEBUG
	if (tblen) {
		if (tblen >= sizeof(tcpbuf))
			tblen = sizeof(tcpbuf) - 1;
	    	tcpbuf[tblen] = '\0';
		syslog(LOG_DEBUG, "from %s (%dbytes): %s",
		       direction == 1 ? "client" : "server", tblen, tcpbuf);
	}
#endif /* DEBUG */
	tblen = 0; tboff = 0;
	if (s_snd >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_CLR(s_snd, &writefds);
	if (s_rcv >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_SET(s_rcv, &readfds);
	return;
    retry_or_err:
	if (errno != EAGAIN)
		exit_failure("writing relay data failed: %s", strerror(errno));
	if (s_snd >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_SET(s_snd, &writefds);
}

static void
relay(int s_rcv, int s_snd, const char *service, int direction)
{
	int atmark, error, maxfd;
	struct timeval tv;
	fd_set oreadfds, owritefds, oexceptfds;

	FD_ZERO(&readfds);
	FD_ZERO(&writefds);
	FD_ZERO(&exceptfds);
	fcntl(s_snd, F_SETFD, O_NONBLOCK);
	oreadfds = readfds; owritefds = writefds; oexceptfds = exceptfds;
	if (s_rcv >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_SET(s_rcv, &readfds);
	FD_SET(s_rcv, &exceptfds);
	oob_exists = 0;
	maxfd = (s_rcv > s_snd) ? s_rcv : s_snd;

	for (;;) {
		tv.tv_sec = FAITH_TIMEOUT / 4;
		tv.tv_usec = 0;
		oreadfds = readfds;
		owritefds = writefds;
		oexceptfds = exceptfds;
		error = select(maxfd + 1, &readfds, &writefds, &exceptfds, &tv);
		if (error == -1) {
			if (errno == EINTR)
				continue;
			exit_failure("select: %s", strerror(errno));
		} else if (error == 0) {
			readfds = oreadfds;
			writefds = owritefds;
			exceptfds = oexceptfds;
			notify_inactive();
			continue;
		}

		/* activity notification */
		notify_active();

		if (FD_ISSET(s_rcv, &exceptfds)) {
			error = ioctl(s_rcv, SIOCATMARK, &atmark);
			if (error != -1 && atmark == 1) {
				int cc;
			    oob_read_retry:
				cc = read(s_rcv, atmark_buf, 1);
				if (cc == 1) {
					if (s_rcv >= FD_SETSIZE)
						exit_failure("descriptor too big");
					FD_CLR(s_rcv, &exceptfds);
					if (s_snd >= FD_SETSIZE)
						exit_failure("descriptor too big");
					FD_SET(s_snd, &writefds);
					oob_exists = 1;
				} else if (cc == -1) {
					if (errno == EINTR)
						goto oob_read_retry;
					exit_failure("reading oob data failed"
						     ": %s",
						     strerror(errno));
				}
			}
		}
		if (FD_ISSET(s_rcv, &readfds)) {
		    relaydata_read_retry:
			tblen = read(s_rcv, tcpbuf, sizeof(tcpbuf));
			tboff = 0;

			switch (tblen) {
			case -1:
				if (errno == EINTR)
					goto relaydata_read_retry;
				exit_failure("reading relay data failed: %s",
					     strerror(errno));
				/* NOTREACHED */
			case 0:
				/* to close opposite-direction relay process */
				shutdown(s_snd, 0);

				close(s_rcv);
				close(s_snd);
				exit_success("terminating %s relay", service);
				/* NOTREACHED */
			default:
				if (s_rcv >= FD_SETSIZE)
					exit_failure("descriptor too big");
				FD_CLR(s_rcv, &readfds);
				if (s_snd >= FD_SETSIZE)
					exit_failure("descriptor too big");
				FD_SET(s_snd, &writefds);
				break;
			}
		}
		if (FD_ISSET(s_snd, &writefds))
			send_data(s_rcv, s_snd, service, direction);
	}
}

void
tcp_relay(int s_src, int s_dst, const char *service)
{
	syslog(LOG_INFO, "starting %s relay", service);

	child_lastactive = parent_lastactive = time(NULL);

	cpid = fork();
	switch (cpid) {
	case -1:
		exit_failure("tcp_relay: can't fork grand child: %s",
		    strerror(errno));
		/* NOTREACHED */
	case 0:
		/* child process: relay going traffic */
		ppid = getppid();
		/* this is child so reopen log */
		closelog();
		openlog(logname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
		relay(s_src, s_dst, service, 1);
		/* NOTREACHED */
	default:
		/* parent process: relay coming traffic */
		ppid = (pid_t)0;
		signal(SIGUSR1, sig_ctimeout);
		signal(SIGCHLD, sig_child);
		relay(s_dst, s_src, service, 0);
		/* NOTREACHED */
	}
}
@


1.12
log
@-ansi -pedantic (socklen_t).  from cloder@@loder.us
die if FD_SET overruns.
sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp.c,v 1.11 2002/05/26 01:21:12 deraadt Exp $	*/
@


1.11
log
@pid_t cleanup; itojun ok
@
text
@d1 2
a2 2
/*	$OpenBSD: tcp.c,v 1.10 2002/02/16 21:28:02 millert Exp $	*/
/*	$KAME: tcp.c,v 1.6 2001/07/02 14:36:49 itojun Exp $	*/
d164 2
d184 2
d187 2
d194 2
d211 2
d247 2
d250 2
d284 2
d287 2
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp.c,v 1.9 2001/11/17 19:49:38 deraadt Exp $	*/
d102 1
a102 1
		    "child %d exit status 0x%x", pid, status);
@


1.9
log
@use volatile sig_atomic_t where possible; simply volatile i other places
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp.c,v 1.8 2001/11/16 19:55:49 deraadt Exp $	*/
d65 6
a70 6
static void sig_ctimeout __P((int));
static void sig_child __P((int));
static void notify_inactive __P((void));
static void notify_active __P((void));
static void send_data __P((int, int, const char *, int));
static void relay __P((int, int, const char *, int));
@


1.8
log
@report for wait3() returning 0
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp.c,v 1.7 2001/11/05 09:56:02 deraadt Exp $	*/
d62 1
a62 1
static time_t child_lastactive = (time_t)0;
@


1.7
log
@mark more handlers, and some syslog_r attempts
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp.c,v 1.6 2001/09/05 01:31:33 itojun Exp $	*/
d100 1
a100 1
	if (pid && WEXITSTATUS(status))
@


1.6
log
@sync with latest kame
- fix select() size.  from deraadt
- constify, remove bogus ERRSTR macro, and others
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp.c,v 1.5 2000/10/06 02:46:59 itojun Exp $	*/
d81 3
d86 1
a86 1
		syslog(LOG_DEBUG, "activity timer from child");
d88 1
d95 1
d101 2
a102 1
		syslog(LOG_WARNING, "child %d exit status 0x%x", pid, status);
@


1.5
log
@printf string format audit.  from: sommerfeld@@netbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: tcp.c,v 1.4 2000/09/16 10:33:46 itojun Exp $	*/
/*	$KAME: tcp.c,v 1.5 2000/09/29 03:48:31 sakane Exp $	*/
d181 1
a181 1
		exit_failure("writing relay data failed: %s", ERRSTR);
d212 1
a212 1
			exit_failure("select: %s", ERRSTR);
d239 1
a239 1
						     ERRSTR);
d253 1
a253 1
					     ERRSTR);
d284 2
a285 1
		exit_failure("tcp_relay: can't fork grand child: %s", ERRSTR);
@


1.4
log
@synchronize with latest kame.
- improve exit code and logging.
- repair multicast address rejection (IN_MULTICAST takes host endian value)
- repair ftp relaying, when the result of PASV does not have paren.
- repair ftp relaying, when EPSV is sent from client.
@
text
@d1 2
a2 2
/*	$OpenBSD: tcp.c,v 1.3 2000/05/31 03:09:22 itojun Exp $	*/
/*	$KAME: tcp.c,v 1.4 2000/07/28 08:05:00 itojun Exp $	*/
d197 2
a198 1
	FD_SET(s_rcv, &readfds); FD_SET(s_rcv, &exceptfds);
@


1.3
log
@sync with the latest kame code.  insufficient len in malloc() call is
corrected.
@
text
@d1 2
a2 2
/*	$OpenBSD: tcp.c,v 1.2 1999/12/20 16:32:53 itojun Exp $	*/
/*	$KAME: tcp.c,v 1.2 2000/05/31 03:06:07 itojun Exp $	*/
d95 1
a95 1
	if (pid && status)
d97 1
a97 1
	exit_failure("terminate connection due to child termination");
@


1.2
log
@rcsid police.
pathname change (/usr/local/v6/libexec -> /usr/libexec)
bring in some of kame fixes (sprintf -> snprintf, proc title).
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@faith translator deamon, from KAME
@
text
@@
