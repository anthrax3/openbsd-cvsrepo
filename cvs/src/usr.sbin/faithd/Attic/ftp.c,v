head	1.16;
access;
symbols
	OPENBSD_5_3:1.15.0.24
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.22
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.20
	OPENBSD_5_0:1.15.0.18
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.16
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.14
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.10
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.12
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	snap19991220:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2013.03.14.11.08.20;	author mpi;	state dead;
branches;
next	1.15;

1.15
date	2007.03.20.04.00.32;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.16.05.07.48;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.02.23.35.44;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.02.22.55.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.19.22.23.51;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.08.01.20.15;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.24.06.06.25;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.07.00.18.05;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.09.14.12.17;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.05.01.31.33;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.16.10.33.45;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.31.03.09.22;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.20.16.32.53;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.20.16.07.38;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.20.16.07.38;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.16
log
@tedu faithd(8), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@/*	$OpenBSD: ftp.c,v 1.15 2007/03/20 04:00:32 tedu Exp $	*/
/*	$KAME: ftp.c,v 1.20 2002/09/08 01:12:30 itojun Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/time.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <poll.h>
#include <errno.h>
#include <ctype.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "faithd.h"

static char rbuf[MSS];
static char sbuf[MSS];
static int passivemode = 0;
static int wport4 = -1;			/* listen() to active */
static int wport6 = -1;			/* listen() to passive */
static int port4 = -1;			/* active: inbound  passive: outbound */
static int port6 = -1;			/* active: outbound  passive: inbound */
static struct sockaddr_storage data4;	/* server data address */
static struct sockaddr_storage data6;	/* client data address */
static int epsvall = 0;

enum state { NONE, LPRT, EPRT, LPSV, EPSV };

static int ftp_activeconn(void);
static int ftp_passiveconn(void);
static int ftp_copy(int, int);
static int ftp_copyresult(int, int, enum state);
static int ftp_copycommand(int, int, enum state *);

void
ftp_relay(int ctl6, int ctl4)
{
	struct pollfd pfd[6];
	int error;
	enum state state = NONE;
	struct timeval tv;

	syslog(LOG_INFO, "starting ftp control connection");

	for (;;) {
		int maxfd = 0;

		pfd[0].fd = ctl4;
		pfd[0].events = POLLIN;
		pfd[1].fd = ctl6;
		pfd[1].events = POLLIN;

		maxfd = (ctl6 > maxfd) ? ctl6 : maxfd;
		if (0 <= port4) {
			pfd[2].fd = port4;
			pfd[2].events = POLLIN;
		} else
			pfd[2].fd = -1;

		if (0 <= port6) {
			pfd[3].fd = port6;
			pfd[3].events = POLLIN;
		} else
			pfd[3].fd = -1;
#if 0
		if (0 <= wport4) {
			pfd[4].fd = wport4;
			pfd[4].events = POLLIN;
		} else
			pfd[4].fd = -1;
		if (0 <= wport6) {
			pfd[5].fd = wport6;
			pfd[5].events = POLLIN;
		} else
			pfd[5].fd = -1;
#endif
		tv.tv_sec = FAITH_TIMEOUT;
		tv.tv_usec = 0;

		error = poll(pfd, 6, FAITH_TIMEOUT * 1000);
		if (error == -1)
			exit_failure("poll: %s", strerror(errno));
		else if (error == 0)
			exit_failure("connection timeout");

		/*
		 * The order of the following checks does (slightly) matter.
		 * It is important to visit all checks (do not use "continue"),
		 * otherwise some of the pipe may become full and we cannot
		 * relay correctly.
		 */
		if (pfd[1].revents & POLLIN) {
			/*
			 * copy control connection from the client.
			 * command translation is necessary.
			 */
			error = ftp_copycommand(ctl6, ctl4, &state);

			if (error < 0)
				goto bad;
			else if (error == 0) {
				close(ctl4);
				close(ctl6);
				exit_success("terminating ftp control connection");
				/*NOTREACHED*/
			}
		}
		if (pfd[1].revents & POLLIN) {
			/*
			 * copy control connection from the server
			 * translation of result code is necessary.
			 */
			error = ftp_copyresult(ctl4, ctl6, state);

			if (error < 0)
				goto bad;
			else if (error == 0) {
				close(ctl4);
				close(ctl6);
				exit_success("terminating ftp control connection");
				/*NOTREACHED*/
			}
		}
		if (0 <= port4 && 0 <= port6 && (pfd[2].revents & POLLIN)) {
			/*
			 * copy data connection.
			 * no special treatment necessary.
			 */
			if (pfd[2].revents & POLLIN)
				error = ftp_copy(port4, port6);
			switch (error) {
			case -1:
				goto bad;
			case 0:
				close(port4);
				close(port6);
				port4 = port6 = -1;
				syslog(LOG_INFO, "terminating data connection");
				break;
			default:
				break;
			}
		}
		if (0 <= port4 && 0 <= port6 && (pfd[3].revents & POLLIN)) {
			/*
			 * copy data connection.
			 * no special treatment necessary.
			 */
			if (pfd[3].revents & POLLIN)
				error = ftp_copy(port6, port4);
			switch (error) {
			case -1:
				goto bad;
			case 0:
				close(port4);
				close(port6);
				port4 = port6 = -1;
				syslog(LOG_INFO, "terminating data connection");
				break;
			default:
				break;
			}
		}
#if 0
		if (wport4 && (pfd[4].revents & POLLIN)) {
			/*
			 * establish active data connection from the server.
			 */
			ftp_activeconn();
		}
		if (wport6 && (pfd[5].revents & POLLIN)) {
			/*
			 * establish passive data connection from the client.
			 */
			ftp_passiveconn();
		}
#endif
	}

 bad:
	exit_failure("%s", strerror(errno));
}

static int
ftp_activeconn()
{
	socklen_t n;
	int error;
	struct pollfd pfd[1];
	struct sockaddr *sa;

	/* get active connection from server */
	pfd[0].fd = wport4;
	pfd[0].events = POLLIN;
	n = sizeof(data4);
	if (poll(pfd, 1, 120 * 1000) == 0
	 || (port4 = accept(wport4, (struct sockaddr *)&data4, &n)) < 0) {
		close(wport4);
		wport4 = -1;
		syslog(LOG_INFO, "active mode data connection failed");
		return -1;
	}

	/* ask active connection to client */
	sa = (struct sockaddr *)&data6;
	port6 = socket(sa->sa_family, SOCK_STREAM, 0);
	if (port6 == -1) {
		close(port4);
		close(wport4);
		port4 = wport4 = -1;
		syslog(LOG_INFO, "active mode data connection failed");
		return -1;
	}
	error = connect(port6, sa, sa->sa_len);
	if (error < 0) {
		close(port6);
		close(port4);
		close(wport4);
		port6 = port4 = wport4 = -1;
		syslog(LOG_INFO, "active mode data connection failed");
		return -1;
	}

	syslog(LOG_INFO, "active mode data connection established");
	return 0;
}

static int
ftp_passiveconn()
{
	socklen_t len;
	int error;
	struct pollfd pfd[1];
	struct sockaddr *sa;

	/* get passive connection from client */
	pfd[0].fd = wport6;
	pfd[0].events = POLLIN;
	len = sizeof(data6);
	if (poll(pfd, 1, 120 * 1000) == 0
	 || (port6 = accept(wport6, (struct sockaddr *)&data6, &len)) < 0) {
		close(wport6);
		wport6 = -1;
		syslog(LOG_INFO, "passive mode data connection failed");
		return -1;
	}

	/* ask passive connection to server */
	sa = (struct sockaddr *)&data4;
	port4 = socket(sa->sa_family, SOCK_STREAM, 0);
	if (port4 == -1) {
		close(wport6);
		close(port6);
		wport6 = port6 = -1;
		syslog(LOG_INFO, "passive mode data connection failed");
		return -1;
	}
	error = connect(port4, sa, sa->sa_len);
	if (error < 0) {
		close(wport6);
		close(port4);
		close(port6);
		wport6 = port4 = port6 = -1;
		syslog(LOG_INFO, "passive mode data connection failed");
		return -1;
	}

	syslog(LOG_INFO, "passive mode data connection established");
	return 0;
}

static int
ftp_copy(int src, int dst)
{
	int error, atmark, n;

	/* OOB data handling */
	error = ioctl(src, SIOCATMARK, &atmark);
	if (error != -1 && atmark == 1) {
		n = read(src, rbuf, 1);
		if (n == -1)
			goto bad;
		send(dst, rbuf, n, MSG_OOB);
#if 0
		n = read(src, rbuf, sizeof(rbuf));
		if (n == -1)
			goto bad;
		write(dst, rbuf, n);
		return n;
#endif
	}

	n = read(src, rbuf, sizeof(rbuf));
	switch (n) {
	case -1:
	case 0:
		return n;
	default:
		write(dst, rbuf, n);
		return n;
	}

 bad:
	exit_failure("%s", strerror(errno));
	/*NOTREACHED*/
	return 0;	/* to make gcc happy */
}

static int
ftp_copyresult(int src, int dst, enum state state)
{
	int error, atmark, n;
	socklen_t len;
	char *param;
	int code;
	char *a, *p;
	int i;

	/* OOB data handling */
	error = ioctl(src, SIOCATMARK, &atmark);
	if (error != -1 && atmark == 1) {
		n = read(src, rbuf, 1);
		if (n == -1)
			goto bad;
		send(dst, rbuf, n, MSG_OOB);
#if 0
		n = read(src, rbuf, sizeof(rbuf));
		if (n == -1)
			goto bad;
		write(dst, rbuf, n);
		return n;
#endif
	}

	n = read(src, rbuf, sizeof(rbuf));
	if (n <= 0)
		return n;
	rbuf[n] = '\0';

	/*
	 * parse argument
	 */
	p = rbuf;
	for (i = 0; i < 3; i++) {
		if (!isdigit(*p)) {
			/* invalid reply */
			write(dst, rbuf, n);
			return n;
		}
		p++;
	}
	if (!isspace(*p)) {
		/* invalid reply */
		write(dst, rbuf, n);
		return n;
	}
	code = atoi(rbuf);
	param = p;
	/* param points to first non-command token, if any */
	while (isspace(*param))
		param++;
	if (!*param)
		param = NULL;

	switch (state) {
	case NONE:
		if (!passivemode && rbuf[0] == '1') {
			if (ftp_activeconn() < 0) {
				n = snprintf(rbuf, sizeof(rbuf),
					"425 Cannot open data connetion\r\n");
				if (n < 0 || n >= sizeof(rbuf))
					n = 0;
			}
		}
		if (n)
			write(dst, rbuf, n);
		return n;
	case LPRT:
	case EPRT:
		/* expecting "200 PORT command successful." */
		if (code == 200) {
			p = strstr(rbuf, "PORT");
			if (p) {
				p[0] = (state == LPRT) ? 'L' : 'E';
				p[1] = 'P';
			}
		} else {
			close(wport4);
			wport4 = -1;
		}
		write(dst, rbuf, n);
		return n;
	case LPSV:
	case EPSV:
		/*
		 * expecting "227 Entering Passive Mode (x,x,x,x,x,x,x)"
		 * (in some cases result comes without paren)
		 */
		if (code != 227) {
passivefail0:
			close(wport6);
			wport6 = -1;
			write(dst, rbuf, n);
			return n;
		}

	    {
		unsigned int ho[4], po[2];
		struct sockaddr_in *sin;
		struct sockaddr_in6 *sin6;
		u_short port;

		/*
		 * PASV result -> LPSV/EPSV result
		 */
		p = param;
		while (*p && *p != '(' && !isdigit(*p))	/*)*/
			p++;
		if (!*p)
			goto passivefail0;	/*XXX*/
		if (*p == '(')	/*)*/
			p++;
		n = sscanf(p, "%u,%u,%u,%u,%u,%u",
			&ho[0], &ho[1], &ho[2], &ho[3], &po[0], &po[1]);
		if (n != 6)
			goto passivefail0;	/*XXX*/

		/* keep PORT parameter */
		memset(&data4, 0, sizeof(data4));
		sin = (struct sockaddr_in *)&data4;
		sin->sin_len = sizeof(*sin);
		sin->sin_family = AF_INET;
		sin->sin_addr.s_addr = 0;
		for (n = 0; n < 4; n++) {
			sin->sin_addr.s_addr |=
				htonl((ho[n] & 0xff) << ((3 - n) * 8));
		}
		sin->sin_port = htons(((po[0] & 0xff) << 8) | (po[1] & 0xff));

		/* get ready for passive data connection */
		memset(&data6, 0, sizeof(data6));
		sin6 = (struct sockaddr_in6 *)&data6;
		sin6->sin6_len = sizeof(*sin6);
		sin6->sin6_family = AF_INET6;
		wport6 = socket(sin6->sin6_family, SOCK_STREAM, 0);
		if (wport6 == -1) {
passivefail:
			n = snprintf(sbuf, sizeof(sbuf),
				"500 could not translate from PASV\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
#ifdef IPV6_FAITH
	    {
		int on = 1;
		error = setsockopt(wport6, IPPROTO_IPV6, IPV6_FAITH,
			&on, sizeof(on));
		if (error == -1)
			exit_failure("setsockopt(IPV6_FAITH): %s", strerror(errno));
	    }
#endif
		error = bind(wport6, (struct sockaddr *)sin6, sin6->sin6_len);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail;
		}
		error = listen(wport6, 1);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail;
		}

		/* transmit LPSV or EPSV */
		/*
		 * addr from dst, port from wport6
		 */
		len = sizeof(data6);
		error = getsockname(wport6, (struct sockaddr *)&data6, &len);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail;
		}
		sin6 = (struct sockaddr_in6 *)&data6;
		port = sin6->sin6_port;

		len = sizeof(data6);
		error = getsockname(dst, (struct sockaddr *)&data6, &len);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail;
		}
		sin6 = (struct sockaddr_in6 *)&data6;
		sin6->sin6_port = port;

		if (state == LPSV) {
			a = (char *)&sin6->sin6_addr;
			p = (char *)&sin6->sin6_port;
			n = snprintf(sbuf, sizeof(sbuf),
"228 Entering Long Passive Mode (%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)\r\n",
				6, 16, UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				UC(a[4]), UC(a[5]), UC(a[6]), UC(a[7]),
				UC(a[8]), UC(a[9]), UC(a[10]), UC(a[11]),
				UC(a[12]), UC(a[13]), UC(a[14]), UC(a[15]),
				2, UC(p[0]), UC(p[1]));
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(dst, sbuf, n);
			passivemode = 1;
			return n;
		} else {
			n = snprintf(sbuf, sizeof(sbuf),
"229 Entering Extended Passive Mode (|||%d|)\r\n",
				ntohs(sin6->sin6_port));
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(dst, sbuf, n);
			passivemode = 1;
			return n;
		}
	    }
	}

 bad:
	exit_failure("%s", strerror(errno));
	/*NOTREACHED*/
	return 0;	/* to make gcc happy */
}

static int
ftp_copycommand(int src, int dst, enum state *state)
{
	int error, atmark, n;
	socklen_t len;
	unsigned int af, hal, ho[16], pal, po[2];
	char *a, *p, *q;
	char cmd[5], *param;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	enum state nstate;
	char ch;
	int i;

	/* OOB data handling */
	error = ioctl(src, SIOCATMARK, &atmark);
	if (error != -1 && atmark == 1) {
		n = read(src, rbuf, 1);
		if (n == -1)
			goto bad;
		send(dst, rbuf, n, MSG_OOB);
#if 0
		n = read(src, rbuf, sizeof(rbuf));
		if (n == -1)
			goto bad;
		write(dst, rbuf, n);
		return n;
#endif
	}

	n = read(src, rbuf, sizeof(rbuf));
	if (n <= 0)
		return n;
	rbuf[n] = '\0';

	if (n < 4) {
		write(dst, rbuf, n);
		return n;
	}

	/*
	 * parse argument
	 */
	p = rbuf;
	q = cmd;
	for (i = 0; i < 4; i++) {
		if (!isalpha(*p)) {
			/* invalid command */
			write(dst, rbuf, n);
			return n;
		}
		*q++ = islower(*p) ? toupper(*p) : *p;
		p++;
	}
	if (!isspace(*p)) {
		/* invalid command */
		write(dst, rbuf, n);
		return n;
	}
	*q = '\0';
	param = p;
	/* param points to first non-command token, if any */
	while (isspace(*param))
		param++;
	if (!*param)
		param = NULL;

	*state = NONE;

	if (strcmp(cmd, "LPRT") == 0 && param) {
		/*
		 * LPRT -> PORT
		 */
		nstate = LPRT;

		close(wport4);
		close(wport6);
		close(port4);
		close(port6);
		wport4 = wport6 = port4 = port6 = -1;

		if (epsvall) {
			n = snprintf(sbuf, sizeof(sbuf), "501 %s disallowed in EPSV ALL\r\n",
				cmd);
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}

		n = sscanf(param,
"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
			      &af, &hal, &ho[0], &ho[1], &ho[2], &ho[3],
			      &ho[4], &ho[5], &ho[6], &ho[7],
			      &ho[8], &ho[9], &ho[10], &ho[11],
			      &ho[12], &ho[13], &ho[14], &ho[15],
			      &pal, &po[0], &po[1]);
		if (n != 21 || af != 6 || hal != 16|| pal != 2) {
			n = snprintf(sbuf, sizeof(sbuf),
				"501 illegal parameter to LPRT\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}

		/* keep LPRT parameter */
		memset(&data6, 0, sizeof(data6));
		sin6 = (struct sockaddr_in6 *)&data6;
		sin6->sin6_len = sizeof(*sin6);
		sin6->sin6_family = AF_INET6;
		for (n = 0; n < 16; n++)
			sin6->sin6_addr.s6_addr[n] = ho[n];
		sin6->sin6_port = htons(((po[0] & 0xff) << 8) | (po[1] & 0xff));

sendport:
		/* get ready for active data connection */
		len = sizeof(data4);
		error = getsockname(dst, (struct sockaddr *)&data4, &len);
		if (error == -1) {
lprtfail:
			n = snprintf(sbuf, sizeof(sbuf),
				"500 could not translate to PORT\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
		if (((struct sockaddr *)&data4)->sa_family != AF_INET)
			goto lprtfail;
		sin = (struct sockaddr_in *)&data4;
		sin->sin_port = 0;
		wport4 = socket(sin->sin_family, SOCK_STREAM, 0);
		if (wport4 == -1)
			goto lprtfail;
		error = bind(wport4, (struct sockaddr *)sin, sin->sin_len);
		if (error == -1) {
			close(wport4);
			wport4 = -1;
			goto lprtfail;
		}
		error = listen(wport4, 1);
		if (error == -1) {
			close(wport4);
			wport4 = -1;
			goto lprtfail;
		}

		/* transmit PORT */
		len = sizeof(data4);
		error = getsockname(wport4, (struct sockaddr *)&data4, &len);
		if (error == -1) {
			close(wport4);
			wport4 = -1;
			goto lprtfail;
		}
		if (((struct sockaddr *)&data4)->sa_family != AF_INET) {
			close(wport4);
			wport4 = -1;
			goto lprtfail;
		}
		sin = (struct sockaddr_in *)&data4;
		a = (char *)&sin->sin_addr;
		p = (char *)&sin->sin_port;
		n = snprintf(sbuf, sizeof(sbuf), "PORT %d,%d,%d,%d,%d,%d\r\n",
				  UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				  UC(p[0]), UC(p[1]));
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(dst, sbuf, n);
		*state = nstate;
		passivemode = 0;
		return n;
	} else if (strcmp(cmd, "EPRT") == 0 && param) {
		/*
		 * EPRT -> PORT
		 */
		char *afp, *hostp, *portp;
		struct addrinfo hints, *res;

		nstate = EPRT;

		close(wport4);
		close(wport6);
		close(port4);
		close(port6);
		wport4 = wport6 = port4 = port6 = -1;

		if (epsvall) {
			n = snprintf(sbuf, sizeof(sbuf), "501 %s disallowed in EPSV ALL\r\n",
				cmd);
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}

		p = param;
		ch = *p++;	/* boundary character */
		afp = p;
		while (*p && *p != ch)
			p++;
		if (!*p) {
eprtparamfail:
			n = snprintf(sbuf, sizeof(sbuf),
				"501 illegal parameter to EPRT\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
		*p++ = '\0';
		hostp = p;
		while (*p && *p != ch)
			p++;
		if (!*p)
			goto eprtparamfail;
		*p++ = '\0';
		portp = p;
		while (*p && *p != ch)
			p++;
		if (!*p)
			goto eprtparamfail;
		*p++ = '\0';

		n = sscanf(afp, "%d", &af);
		if (n != 1 || af != 2) {
			n = snprintf(sbuf, sizeof(sbuf),
				"501 unsupported address family to EPRT\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = AF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
		error = getaddrinfo(hostp, portp, &hints, &res);
		if (error) {
			n = snprintf(sbuf, sizeof(sbuf),
				"501 EPRT: %s\r\n", gai_strerror(error));
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
		if (res->ai_next) {
			n = snprintf(sbuf, sizeof(sbuf),
				"501 EPRT: %s resolved to multiple addresses\r\n", hostp);
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			freeaddrinfo(res);
			return n;
		}

		memcpy(&data6, res->ai_addr, res->ai_addrlen);

		freeaddrinfo(res);
		goto sendport;
	} else if (strcmp(cmd, "LPSV") == 0 && !param) {
		/*
		 * LPSV -> PASV
		 */
		nstate = LPSV;

		close(wport4);
		close(wport6);
		close(port4);
		close(port6);
		wport4 = wport6 = port4 = port6 = -1;

		if (epsvall) {
			n = snprintf(sbuf, sizeof(sbuf), "501 %s disallowed in EPSV ALL\r\n",
				cmd);
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}

		/* transmit PASV */
		n = snprintf(sbuf, sizeof(sbuf), "PASV\r\n");
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(dst, sbuf, n);
		*state = LPSV;
		passivemode = 0;	/* to be set to 1 later */
		return n;
	} else if (strcmp(cmd, "EPSV") == 0 && !param) {
		/*
		 * EPSV -> PASV
		 */
		close(wport4);
		close(wport6);
		close(port4);
		close(port6);
		wport4 = wport6 = port4 = port6 = -1;

		n = snprintf(sbuf, sizeof(sbuf), "PASV\r\n");
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(dst, sbuf, n);
		*state = EPSV;
		passivemode = 0;	/* to be set to 1 later */
		return n;
	} else if (strcmp(cmd, "EPSV") == 0 && param
	 && strncasecmp(param, "ALL", 3) == 0 && isspace(param[3])) {
		/*
		 * EPSV ALL
		 */
		epsvall = 1;
		n = snprintf(sbuf, sizeof(sbuf), "200 EPSV ALL command successful.\r\n");
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(src, sbuf, n);
		return n;
	} else if (strcmp(cmd, "PORT") == 0 || strcmp(cmd, "PASV") == 0) {
		/*
		 * reject PORT/PASV
		 */
		n = snprintf(sbuf, sizeof(sbuf), "502 %s not implemented.\r\n", cmd);
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(src, sbuf, n);
		return n;
	} else if (passivemode
		&& (strcmp(cmd, "STOR") == 0
		 || strcmp(cmd, "STOU") == 0
		 || strcmp(cmd, "RETR") == 0
		 || strcmp(cmd, "LIST") == 0
		 || strcmp(cmd, "NLST") == 0
		 || strcmp(cmd, "APPE") == 0)) {
		/*
		 * commands with data transfer.  need to care about passive
		 * mode data connection.
		 */

		if (ftp_passiveconn() < 0) {
			n = snprintf(sbuf, sizeof(sbuf), "425 Cannot open data connetion\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
		} else {
			/* simply relay the command */
			write(dst, rbuf, n);
		}

		*state = NONE;
		return n;
	} else {
		/* simply relay it */
		*state = NONE;
		write(dst, rbuf, n);
		return n;
	}

 bad:
	exit_failure("%s", strerror(errno));
	/*NOTREACHED*/
	return 0;	/* to make gcc happy */
}
@


1.15
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.14 2005/03/16 05:07:48 itojun Exp $	*/
@


1.14
log
@plug memory leak.  Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.13 2003/09/02 23:35:44 itojun Exp $	*/
d398 1
a398 1
	while (*param && isspace(*param))
d638 1
a638 1
	while (*param && isspace(*param))
@


1.13
log
@make sure to open TCP socket (in case getaddrinfo supports SCTP).  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.12 2003/09/02 22:55:26 deraadt Exp $	*/
d838 1
d844 1
@


1.12
log
@use poll since it is easier than fd_set overflows; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.11 2003/08/19 22:23:51 itojun Exp $	*/
d820 1
@


1.11
log
@fix tv_usec setting.  deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.10 2002/09/08 01:20:15 itojun Exp $	*/
d44 1
d76 1
a76 1
	fd_set readfds;
d86 5
a90 8
		FD_ZERO(&readfds);
		if (ctl4 >= FD_SETSIZE)
			exit_failure("descriptor too big");
		FD_SET(ctl4, &readfds);
		maxfd = ctl4;
		if (ctl6 >= FD_SETSIZE)
			exit_failure("descriptor too big");
		FD_SET(ctl6, &readfds);
d93 5
a97 5
			if (port4 >= FD_SETSIZE)
				exit_failure("descriptor too big");
			FD_SET(port4, &readfds);
			maxfd = (port4 > maxfd) ? port4 : maxfd;
		}
d99 4
a102 5
			if (port6 >= FD_SETSIZE)
				exit_failure("descriptor too big");
			FD_SET(port6, &readfds);
			maxfd = (port6 > maxfd) ? port6 : maxfd;
		}
d105 4
a108 5
			if (wport4 >= FD_SETSIZE)
				exit_failure("descriptor too big");
			FD_SET(wport4, &readfds);
			maxfd = (wport4 > maxfd) ? wport4 : maxfd;
		}
d110 4
a113 5
			if (wport6 >= FD_SETSIZE)
				exit_failure("descriptor too big");
			FD_SET(wport6, &readfds);
			maxfd = (wport6 > maxfd) ? wport6 : maxfd;
		}
d118 1
a118 1
		error = select(maxfd + 1, &readfds, NULL, NULL, &tv);
d120 1
a120 1
			exit_failure("select: %s", strerror(errno));
d130 1
a130 1
		if (FD_ISSET(ctl6, &readfds)) {
d146 1
a146 1
		if (FD_ISSET(ctl4, &readfds)) {
d162 1
a162 1
		if (0 <= port4 && 0 <= port6 && FD_ISSET(port4, &readfds)) {
d167 1
a167 1
			if (FD_ISSET(port4, &readfds))
d182 1
a182 1
		if (0 <= port4 && 0 <= port6 && FD_ISSET(port6, &readfds)) {
d187 1
a187 1
			if (FD_ISSET(port6, &readfds))
d203 1
a203 1
		if (wport4 && FD_ISSET(wport4, &readfds)) {
d209 1
a209 1
		if (wport6 && FD_ISSET(wport6, &readfds)) {
d227 1
a227 2
	fd_set set;
	struct timeval timeout;
d231 2
a232 6
	FD_ZERO(&set);
	if (wport4 >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_SET(wport4, &set);
	timeout.tv_sec = 120;
	timeout.tv_usec = 0;
d234 1
a234 1
	if (select(wport4 + 1, &set, NULL, NULL, &timeout) == 0
d271 1
a271 2
	fd_set set;
	struct timeval timeout;
d275 2
a276 6
	FD_ZERO(&set);
	if (wport6 >= FD_SETSIZE)
		exit_failure("descriptor too big");
	FD_SET(wport6, &set);
	timeout.tv_sec = 120;
	timeout.tv_usec = 0;
d278 1
a278 1
	if (select(wport6 + 1, &set, NULL, NULL, &timeout) == 0
@


1.10
log
@-ansi -pedantic (socklen_t).  from cloder@@loder.us
die if FD_SET overruns.
sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.9 2002/06/24 06:06:25 itojun Exp $	*/
d242 1
a242 1
	timeout.tv_usec = -1;
@


1.9
log
@correct ftp relay functionality.
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.8 2002/06/07 00:18:05 itojun Exp $	*/
/*	$KAME: ftp.c,v 1.18 2002/06/23 14:41:47 itojun Exp $	*/
d86 2
d90 2
d95 2
d101 2
d108 2
d114 2
d230 1
a230 1
	int n;
d238 2
d279 1
a279 1
	int n;
d287 2
d292 1
a292 1
	n = sizeof(data6);
d294 1
a294 1
	 || (port6 = accept(wport6, (struct sockaddr *)&data6, &n)) < 0) {
d328 1
a328 2
	int error, atmark;
	int n;
d365 2
a366 2
	int error, atmark;
	int n;
d535 2
a536 2
		n = sizeof(data6);
		error = getsockname(wport6, (struct sockaddr *)&data6, &n);
d545 2
a546 2
		n = sizeof(data6);
		error = getsockname(dst, (struct sockaddr *)&data6, &n);
d594 2
a595 2
	int error, atmark;
	int n;
d710 2
a711 2
		n = sizeof(data4);
		error = getsockname(dst, (struct sockaddr *)&data4, &n);
d743 2
a744 2
		n = sizeof(data4);
		error = getsockname(wport4, (struct sockaddr *)&data4, &n);
@


1.8
log
@nuke unmaintained code (#ifdef FAITH4).  sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.7 2002/05/09 14:12:17 itojun Exp $	*/
/*	$KAME: ftp.c,v 1.14 2002/04/24 08:17:23 itojun Exp $	*/
d87 1
d89 1
d92 1
a92 2
			if (port4 > maxfd)
				maxfd = port4;
d96 1
a96 2
			if (port6 > maxfd)
				maxfd = port6;
d101 1
a101 2
			if (wport4 > maxfd)
				maxfd = wport4;
d105 1
a105 2
			if (wport6 > maxfd)
				maxfd = wport6;
d130 1
a130 2
			switch (error) {
			case -1:
d132 1
a132 1
			case 0:
a136 2
			default:
				break;
d146 1
a146 2
			switch (error) {
			case -1:
d148 1
a148 1
			case 0:
a152 2
			default:
				break;
d489 1
@


1.7
log
@drop support for rlogin/rsh service (we shouldn't have support it as
they usually use IP address for authentication).  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.6 2002/02/16 21:28:02 millert Exp $	*/
a63 3
#ifdef FAITH4
enum state { NONE, LPRT, EPRT, PORT, LPSV, EPSV, PASV };
#else
a64 1
#endif
a438 16
#ifdef FAITH4
	case PORT:
		/* expecting "200 EPRT command successful." */
		if (code == 200) {
			p = strstr(rbuf, "EPRT");
			if (p) {
				p[0] = 'P';
				p[1] = 'O';
			}
		} else {
			close(wport4);
			wport4 = -1;
		}
		write(dst, rbuf, n);
		return n;
#endif
a574 117
#ifdef FAITH4
	case PASV:
		/* expecting "229 Entering Extended Passive Mode (|||x|)" */
		if (code != 229) {
passivefail1:
			close(wport6);
			wport6 = -1;
			write(dst, rbuf, n);
			return n;
		}

	    {
		u_short port;
		struct sockaddr_in *sin;
		struct sockaddr_in6 *sin6;

		/*
		 * EPSV result -> PORT result
		 */
		p = param;
		while (*p && *p != '(')	/*)*/
			p++;
		if (!*p)
			goto passivefail1;	/*XXX*/
		p++;
		n = sscanf(p, "|||%hu|", &port);
		if (n != 1)
			goto passivefail1;	/*XXX*/

		/* keep EPRT parameter */
		n = sizeof(data4);
		error = getpeername(src, (struct sockaddr *)&data4, &n);
		if (error == -1)
			goto passivefail1;	/*XXX*/
		sin6 = (struct sockaddr_in6 *)&data4;
		sin6->sin6_port = htons(port);

		/* get ready for passive data connection */
		memset(&data6, 0, sizeof(data6));
		sin = (struct sockaddr_in *)&data6;
		sin->sin_len = sizeof(*sin);
		sin->sin_family = AF_INET;
		wport6 = socket(sin->sin_family, SOCK_STREAM, 0);
		if (wport6 == -1) {
passivefail2:
			n = snprintf(sbuf, sizeof(sbuf),
				"500 could not translate from EPSV\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
#ifdef IP_FAITH
	    {
		int on = 1;
		error = setsockopt(wport6, IPPROTO_IP, IP_FAITH,
			&on, sizeof(on));
		if (error == -1)
			exit_error("setsockopt(IP_FAITH): %s", strerror(errno));
	    }
#endif
		error = bind(wport6, (struct sockaddr *)sin, sin->sin_len);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail2;
		}
		error = listen(wport6, 1);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail2;
		}

		/* transmit PORT */
		/*
		 * addr from dst, port from wport6
		 */
		n = sizeof(data6);
		error = getsockname(wport6, (struct sockaddr *)&data6, &n);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail2;
		}
		sin = (struct sockaddr_in *)&data6;
		port = sin->sin_port;

		n = sizeof(data6);
		error = getsockname(dst, (struct sockaddr *)&data6, &n);
		if (error == -1) {
			close(wport6);
			wport6 = -1;
			goto passivefail2;
		}
		sin = (struct sockaddr_in *)&data6;
		sin->sin_port = port;

		{
			char *a, *p;

			a = (char *)&sin->sin_addr;
			p = (char *)&sin->sin_port;
			n = snprintf(sbuf, sizeof(sbuf),
"227 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n",
				UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				UC(p[0]), UC(p[1]));
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(dst, sbuf, n);
			passivemode = 1;
			return n;
		}
	    }
#endif /* FAITH4 */
a910 118
#ifdef FAITH4
	} else if (strcmp(cmd, "PORT") == 0 && param) {
		/*
		 * PORT -> EPRT
		 */
		char host[NI_MAXHOST], serv[NI_MAXSERV];

		nstate = PORT;

		close(wport4);
		close(wport6);
		close(port4);
		close(port6);
		wport4 = wport6 = port4 = port6 = -1;

		p = param;
		n = sscanf(p, "%u,%u,%u,%u,%u,%u",
			&ho[0], &ho[1], &ho[2], &ho[3], &po[0], &po[1]);
		if (n != 6) {
			n = snprintf(sbuf, sizeof(sbuf),
				"501 illegal parameter to PORT\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}

		memset(&data6, 0, sizeof(data6));
		sin = (struct sockaddr_in *)&data6;
		sin->sin_len = sizeof(*sin);
		sin->sin_family = AF_INET;
		sin->sin_addr.s_addr = htonl(
			((ho[0] & 0xff) << 24) | ((ho[1] & 0xff) << 16) |
			((ho[2] & 0xff) << 8) | (ho[3] & 0xff));
		sin->sin_port = htons(((po[0] & 0xff) << 8) | (po[1] & 0xff));

		/* get ready for active data connection */
		n = sizeof(data4);
		error = getsockname(dst, (struct sockaddr *)&data4, &n);
		if (error == -1) {
portfail:
			n = snprintf(sbuf, sizeof(sbuf),
				"500 could not translate to EPRT\r\n");
			if (n < 0 || n >= sizeof(sbuf))
				n = 0;
			if (n)
				write(src, sbuf, n);
			return n;
		}
		if (((struct sockaddr *)&data4)->sa_family != AF_INET6)
			goto portfail;

		((struct sockaddr_in6 *)&data4)->sin6_port = 0;
		sa = (struct sockaddr *)&data4;
		wport4 = socket(sa->sa_family, SOCK_STREAM, 0);
		if (wport4 == -1)
			goto portfail;
		error = bind(wport4, sa, sa->sa_len);
		if (error == -1) {
			close(wport4);
			wport4 = -1;
			goto portfail;
		}
		error = listen(wport4, 1);
		if (error == -1) {
			close(wport4);
			wport4 = -1;
			goto portfail;
		}

		/* transmit EPRT */
		n = sizeof(data4);
		error = getsockname(wport4, (struct sockaddr *)&data4, &n);
		if (error == -1) {
			close(wport4);
			wport4 = -1;
			goto portfail;
		}
		af = 2;
		sa = (struct sockaddr *)&data4;
		if (getnameinfo(sa, sa->sa_len, host, sizeof(host),
			serv, sizeof(serv), NI_NUMERICHOST | NI_NUMERICSERV)) {
			close(wport4);
			wport4 = -1;
			goto portfail;
		}
		n = snprintf(sbuf, sizeof(sbuf), "EPRT |%d|%s|%s|\r\n", af, host, serv);
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(dst, sbuf, n);
		*state = nstate;
		passivemode = 0;
		return n;
	} else if (strcmp(cmd, "PASV") == 0 && !param) {
		/*
		 * PASV -> EPSV
		 */

		nstate = PASV;

		close(wport4);
		close(wport6);
		close(port4);
		close(port6);
		wport4 = wport6 = port4 = port6 = -1;

		/* transmit EPSV */
		n = snprintf(sbuf, sizeof(sbuf), "EPSV\r\n");
		if (n < 0 || n >= sizeof(sbuf))
			n = 0;
		if (n)
			write(dst, sbuf, n);
		*state = PASV;
		passivemode = 0;	/* to be set to 1 later */
		return n;
#else /* FAITH4 */
a920 1
#endif /* FAITH4 */
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.5 2001/09/05 01:31:33 itojun Exp $	*/
/*	$KAME: ftp.c,v 1.13 2001/09/05 01:10:30 itojun Exp $	*/
d261 1
a261 1
	if (port6 == -1) {
d308 1
a308 1
	if (port4 == -1) {
@


1.5
log
@sync with latest kame
- fix select() size.  from deraadt
- constify, remove bogus ERRSTR macro, and others
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.4 2000/09/16 10:33:45 itojun Exp $	*/
d70 5
a74 5
static int ftp_activeconn __P((void));
static int ftp_passiveconn __P((void));
static int ftp_copy __P((int, int));
static int ftp_copyresult __P((int, int, enum state));
static int ftp_copycommand __P((int, int, enum state *));
@


1.4
log
@synchronize with latest kame.
- improve exit code and logging.
- repair multicast address rejection (IN_MULTICAST takes host endian value)
- repair ftp relaying, when the result of PASV does not have paren.
- repair ftp relaying, when EPSV is sent from client.
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.3 2000/05/31 03:09:22 itojun Exp $	*/
/*	$KAME: ftp.c,v 1.10 2000/09/14 00:23:39 itojun Exp $	*/
d87 2
d92 1
a92 1
		if (0 <= port4)
d94 4
a97 1
		if (0 <= port6)
d99 3
d103 1
a103 1
		if (0 <= wport4)
d105 4
a108 1
		if (0 <= wport6)
d110 3
d117 1
a117 1
		error = select(256, &readfds, NULL, NULL, &tv);
d119 1
a119 1
			exit_failure("select: %s", ERRSTR);
d224 1
a224 1
	exit_failure(ERRSTR);
d354 1
a354 1
	exit_failure(ERRSTR);
d366 2
a392 4
    {
	char *p;
	int i;

a413 1
    }
d421 2
d425 2
a426 1
		write(dst, rbuf, n);
a431 2
			char *p;

a446 2
			char *p;

a477 1
		char *p;
d516 3
a518 1
			write(src, sbuf, n);
d527 1
a527 1
			exit_failure("setsockopt(IPV6_FAITH): %s", ERRSTR);
a567 2
			char *a, *p;

d577 4
a580 1
			write(dst, sbuf, n);
d587 4
a590 1
			write(dst, sbuf, n);
a607 1
		char *p;
d642 4
a645 1
			write(src, sbuf, n);
d654 1
a654 1
			exit_error("setsockopt(IP_FAITH): %s", ERRSTR);
d703 4
a706 1
			write(dst, sbuf, n);
d715 1
a715 1
	exit_failure(ERRSTR);
d726 1
a726 1
	char *a, *p;
d732 1
a762 4
    {
	char *p, *q;
	int i;

a785 1
    }
d804 4
a807 1
			write(src, sbuf, n);
d821 4
a824 1
			write(src, sbuf, n);
d845 4
a848 1
			write(src, sbuf, n);
d890 4
a893 1
		write(dst, sbuf, n);
d915 4
a918 1
			write(src, sbuf, n);
d931 4
a934 1
			write(src, sbuf, n);
d955 4
a958 1
			write(src, sbuf, n);
d968 4
a971 1
			write(src, sbuf, n);
d977 4
a980 1
			write(src, sbuf, n);
d1002 4
a1005 1
			write(src, sbuf, n);
d1011 4
a1014 1
		write(dst, sbuf, n);
d1029 4
a1032 1
		write(dst, sbuf, n);
d1043 4
a1046 1
		write(src, sbuf, n);
d1069 4
a1072 1
			write(src, sbuf, n);
d1092 4
a1095 1
			write(src, sbuf, n);
d1136 4
a1139 1
		write(dst, sbuf, n);
d1158 4
a1161 1
		write(dst, sbuf, n);
d1171 4
a1174 1
		write(src, sbuf, n);
d1191 4
a1194 1
			write(src, sbuf, n);
d1210 1
a1210 1
	exit_failure(ERRSTR);
@


1.3
log
@sync with the latest kame code.  insufficient len in malloc() call is
corrected.
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.2 1999/12/20 16:32:53 itojun Exp $	*/
/*	$KAME: ftp.c,v 1.7 2000/05/31 03:06:07 itojun Exp $	*/
d451 4
a454 1
		/* expecting "227 Entering Passive Mode (x,x,x,x,x,x,x)" */
d474 1
a474 1
		while (*p && *p != '(')
d478 2
a479 1
		p++;
d516 1
a516 1
			exit_error("setsockopt(IPV6_FAITH): %s", ERRSTR);
d601 1
a601 1
		while (*p && *p != '(')
d926 1
@


1.2
log
@rcsid police.
pathname change (/usr/local/v6/libexec -> /usr/libexec)
bring in some of kame fixes (sprintf -> snprintf, proc title).
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d559 4
a562 4
				6, 16, UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), 
				UC(a[4]), UC(a[5]), UC(a[6]), UC(a[7]), 
				UC(a[8]), UC(a[9]), UC(a[10]), UC(a[11]), 
				UC(a[12]), UC(a[13]), UC(a[14]), UC(a[15]), 
d680 1
a680 1
				UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), 
@


1.1
log
@Initial revision
@
text
@d1 2
d407 1
a407 1
				n = sprintf(rbuf,
d500 1
a500 1
			n = sprintf(sbuf,
d556 1
a556 1
			n = sprintf(sbuf,
d567 1
a567 1
			n = sprintf(sbuf,
d621 1
a621 1
			n = sprintf(sbuf,
d677 1
a677 1
			n = sprintf(sbuf,
d781 1
a781 1
			n = sprintf(sbuf, "501 %s disallowed in EPSV ALL\r\n",
d795 1
a795 1
			n = sprintf(sbuf,
d816 1
a816 1
			n = sprintf(sbuf,
d857 1
a857 1
		n = sprintf(sbuf, "PORT %d,%d,%d,%d,%d,%d\r\n",
d880 1
a880 1
			n = sprintf(sbuf, "501 %s disallowed in EPSV ALL\r\n",
d893 1
a893 1
			n = sprintf(sbuf,
d914 1
a914 1
			n = sprintf(sbuf,
d923 1
a923 1
			n = sprintf(sbuf,
d929 1
a929 1
			n = sprintf(sbuf,
d951 1
a951 1
			n = sprintf(sbuf, "501 %s disallowed in EPSV ALL\r\n",
d958 1
a958 1
		n = sprintf(sbuf, "PASV\r\n");
d973 1
a973 1
		n = sprintf(sbuf, "PASV\r\n");
d984 1
a984 1
		n = sprintf(sbuf, "200 EPSV ALL command successful.\r\n");
d1006 1
a1006 1
			n = sprintf(sbuf,
d1026 1
a1026 1
			n = sprintf(sbuf,
d1068 1
a1068 1
		n = sprintf(sbuf, "EPRT |%d|%s|%s|\r\n", af, host, serv);
d1087 1
a1087 1
		n = sprintf(sbuf, "EPSV\r\n");
d1097 1
a1097 1
		n = sprintf(sbuf, "502 %s not implemented.\r\n", cmd);
d1114 1
a1114 1
			n = sprintf(sbuf, "425 Cannot open data connetion\r\n");
@


1.1.1.1
log
@faith translator deamon, from KAME
@
text
@@
