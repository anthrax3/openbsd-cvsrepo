head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2016.08.02.16.05.32;	author jca;	state Exp;
branches;
next	1.16;
commitid	M3zXmxiZhTfusmGR;

1.16
date	2015.12.05.13.13.47;	author claudio;	state Exp;
branches;
next	1.15;
commitid	b7fx00QUWNpx3oj5;

1.15
date	2015.10.09.07.54.28;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	NtNcRAjF2IYQRJgf;

1.14
date	2015.09.27.17.32.36;	author stsp;	state Exp;
branches;
next	1.13;
commitid	i6S6VoG4dUqAlOvy;

1.13
date	2015.09.13.11.13.12;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	HmZqjbpn4mjxGSj3;

1.12
date	2013.11.14.20.48.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.09.14.51.33;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.02.20.29.17;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.14.11.49.25;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.17.09.14.26;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.06.08.20.55;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.31.14.10.20;	author sobrado;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.11.17.29.05;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.30.03.45.46;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.15.25;	author norby;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Allow specifying an alternate socket path.

This allows one to run multiple ripd instances, for example to serve
multiple rdomains.  Diff from Nima GHOTBI, ok claudio@@ florian@@ benno@@
@
text
@/*	$OpenBSD: ripctl.c,v 1.16 2015/12/05 13:13:47 claudio Exp $
 *
 * Copyright (c) 2006 Michele Marchetto <mydecay@@openbeer.it>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_media.h>
#include <net/if_types.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rip.h"
#include "ripd.h"
#include "ripe.h"
#include "parser.h"

__dead void	 usage(void);
const char	*fmt_timeframe_core(time_t);
const char	*get_linkstate(uint8_t, int);
int		 show_interface_msg(struct imsg *);
uint64_t	 get_ifms_type(uint8_t);
int		 show_rib_msg(struct imsg *);
int		 show_nbr_msg(struct imsg *);
void		 show_fib_head(void);
int		 show_fib_msg(struct imsg *);
void		 show_interface_head(void);
int		 show_fib_interface_msg(struct imsg *);
const char	*get_media_descr(uint64_t);
void		 print_baudrate(uint64_t);

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-s socket] command [argument ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	unsigned int		 ifidx = 0;
	int			 ctl_sock;
	int			 done = 0, verbose = 0;
	int			 n;
	int			 ch;
	char			*sockname = RIPD_SOCKET;

	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			sockname = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;

	/* parse options */
	if ((res = parse(argc, argv)) == NULL)
		exit(1);

	/* connect to ripd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, sockname, sizeof(sun.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "connect: %s", sockname);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock);
	done = 0;

	/* process user request */
	switch (res->action) {
	case NONE:
		usage();
		/* not reached */
	case SHOW:
	case SHOW_IFACE:
		printf("%-11s %-18s %-10s %-10s %-8s\n",
		    "Interface", "Address", "State", "Linkstate",
		    "Uptime");
		if (*res->ifname) {
			ifidx = if_nametoindex(res->ifname);
			if (ifidx == 0)
				errx(1, "no such interface %s", res->ifname);
		}
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
		    &ifidx, sizeof(ifidx));
		break;
	case SHOW_NBR:
		printf("%-15s %-15s %-15s %-9s %-10s\n", "ID",
		    "State", "Address", "Iface", "Uptime");
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_RIB:
		printf("%-20s %-17s %-7s\n", "Destination",
		    "Nexthop", "Cost");
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, -1, NULL, 0);
		break;
	case SHOW_FIB:
		if (!res->addr.s_addr)
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
			    &res->flags, sizeof(res->flags));
		else
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
			    &res->addr, sizeof(res->addr));
		show_fib_head();
		break;
	case SHOW_FIB_IFACE:
		if (*res->ifname)
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1,
			    res->ifname, sizeof(res->ifname));
		else
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1, NULL, 0);
		show_interface_head();
		break;
	case FIB:
		errx(1, "fib couple|decouple");
		break;
	case FIB_COUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, -1, NULL, 0);
		printf("couple request sent.\n");
		done = 1;
		break;
	case FIB_DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, -1, NULL, 0);
		printf("decouple request sent.\n");
		done = 1;
		break;
	case LOG_VERBOSE:
		verbose = 1;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));
		printf("logging request sent.\n");
		done = 1;
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		printf("reload request sent.\n");
		done = 1;
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW:
			case SHOW_IFACE:
				done = show_interface_msg(&imsg);
				break;
			case SHOW_NBR:
				done = show_nbr_msg(&imsg);
				break;
			case SHOW_RIB:
				done = show_rib_msg(&imsg);
				break;
			case SHOW_FIB:
				done = show_fib_msg(&imsg);
				break;
			case SHOW_FIB_IFACE:
				done = show_fib_interface_msg(&imsg);
				break;
			case NONE:
			case FIB:
			case FIB_COUPLE:
			case FIB_DECOUPLE:
			case LOG_VERBOSE:
			case LOG_BRIEF:
			case RELOAD:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

uint64_t
get_ifms_type(uint8_t if_type)
{
	switch (if_type) {
	case IFT_ETHER:
		return (IFM_ETHER);
		break;
	case IFT_FDDI:
		return (IFM_FDDI);
		break;
	case IFT_CARP:
		return (IFM_CARP);
		break;
	default:
		return (0);
		break;
	}
}

#define	TF_BUFS	8
#define	TF_LEN	9

const char *
fmt_timeframe_core(time_t t)
{
	char		*buf;
	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
	static int	 idx = 0;
	unsigned int	 sec, min, hrs, day;
	unsigned long long	week;

	if (t == 0)
		return ("Stopped");

	buf = tfbuf[idx++];
	if (idx == TF_BUFS)
		idx = 0;

	week = t;

	sec = week % 60;
	week /= 60;
	min = week % 60;
	week /= 60;
	hrs = week % 24;
	week /= 24;
	day = week % 7;
	week /= 7;

	if (week > 0)
		snprintf(buf, TF_LEN, "%02lluw%01ud%02uh", week, day, hrs);
	else if (day > 0)
		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
	else
		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);

	return (buf);
}

/* prototype defined in ripd.h and shared with the kroute.c version */
u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

int
show_interface_msg(struct imsg *imsg)
{
	struct ctl_iface	*iface;
	char			*netid;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_IFACE:
		iface = imsg->data;

		if (asprintf(&netid, "%s/%d", inet_ntoa(iface->addr),
		    mask2prefixlen(iface->mask.s_addr)) == -1)
			err(1, NULL);
		printf("%-11s %-18s %-10s %-10s %-8s\n",
		    iface->name, netid, if_state_name(iface->state),
		    get_linkstate(iface->if_type, iface->linkstate),
		    iface->uptime == 0 ? "00:00:00" :
		    fmt_timeframe_core(iface->uptime));
		free(netid);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_rib_msg(struct imsg *imsg)
{
	struct ctl_rt	*rt;
	char		*dstnet;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		rt = imsg->data;
		if (asprintf(&dstnet, "%s/%d", inet_ntoa(rt->prefix),
		    mask2prefixlen(rt->netmask.s_addr)) == -1)
			err(1, NULL);

		printf("%-20s %-17s %-7d\n", dstnet,
		    inet_ntoa(rt->nexthop),
		    rt->metric);
		free(dstnet);

		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_nbr_msg(struct imsg *imsg)
{
	struct ctl_nbr	*nbr;
	char		*state;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NBR:
		nbr = imsg->data;
		if (asprintf(&state, "%s/%s", nbr_state_name(nbr->nbr_state),
		    if_state_name(nbr->iface_state)) == -1)
			err(1, NULL);
		printf("%-15s %-16s", inet_ntoa(nbr->id),
		    state);
		printf("%-15s %-10s", inet_ntoa(nbr->addr), nbr->name);
		printf("%-15s\n", nbr->uptime == 0 ? "-" :
		    fmt_timeframe_core(nbr->uptime));
		free(state);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_fib_head(void)
{
	printf("flags: * = valid, R = RIP, C = Connected, S = Static\n");
	printf("%-6s %-20s %-17s\n", "Flags", "Destination", "Nexthop");
}

int
show_fib_msg(struct imsg *imsg)
{
	struct kroute		*k;
	char			*p;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(struct kroute))
			errx(1, "wrong imsg len");
		k = imsg->data;

		if (k->flags & F_DOWN)
			printf(" ");
		else
			printf("*");

		if (k->flags & F_RIPD_INSERTED)
			printf("R");
		else if (k->flags & F_CONNECTED)
			printf("C");
		else if (k->flags & F_STATIC)
			printf("S");
		else
			printf(" ");

		printf("     ");
		if (asprintf(&p, "%s/%u", inet_ntoa(k->prefix),
		    mask2prefixlen(k->netmask.s_addr)) == -1)
			err(1, NULL);
		printf("%-20s ", p);
		free(p);

		if (k->nexthop.s_addr)
			printf("%s", inet_ntoa(k->nexthop));
		else if (k->flags & F_CONNECTED)
			printf("link#%u", k->ifindex);
		printf("\n");

		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_interface_head(void)
{
	printf("%-15s%-15s%s\n", "Interface", "Flags",
	    "Link state");
}

int
show_fib_interface_msg(struct imsg *imsg)
{
	struct kif	*k;
	uint64_t	 ifms_type;

	switch (imsg->hdr.type) {
	case IMSG_CTL_IFINFO:
		k = imsg->data;
		printf("%-15s", k->ifname);
		printf("%-15s", k->flags & IFF_UP ? "UP" : "");
		ifms_type = get_ifms_type(k->if_type);
		if (ifms_type)
			printf("%s, ", get_media_descr(ifms_type));

		printf("%s", get_linkstate(k->if_type, k->link_state));

		if (k->link_state != LINK_STATE_DOWN && k->baudrate > 0) {
			printf(", ");
			print_baudrate(k->baudrate);
		}
		printf("\n");
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const struct if_status_description
		if_status_descriptions[] = LINK_STATE_DESCRIPTIONS;
const struct ifmedia_description
		ifm_type_descriptions[] = IFM_TYPE_DESCRIPTIONS;

const char *
get_media_descr(uint64_t media_type)
{
	const struct ifmedia_description	*p;

	for (p = ifm_type_descriptions; p->ifmt_string != NULL; p++)
		if (media_type == p->ifmt_word)
			return (p->ifmt_string);

	return ("unknown");
}

const char *
get_linkstate(uint8_t if_type, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, if_type, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return (buf);
}

void
print_baudrate(uint64_t baudrate)
{
	if (baudrate > IF_Gbps(1))
		printf("%llu GBit/s", baudrate / IF_Gbps(1));
	else if (baudrate > IF_Mbps(1))
		printf("%llu MBit/s", baudrate / IF_Mbps(1));
	else if (baudrate > IF_Kbps(1))
		printf("%llu KBit/s", baudrate / IF_Kbps(1));
	else
		printf("%llu Bit/s", baudrate);
}
@


1.16
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.15 2015/10/09 07:54:28 deraadt Exp $
d62 2
a63 1
	fprintf(stderr, "usage: %s command [argument ...]\n", __progname);
d77 16
d95 1
a95 1
	if ((res = parse(argc - 1, argv + 1)) == NULL)
d104 1
a104 1
	strlcpy(sun.sun_path, RIPD_SOCKET, sizeof(sun.sun_path));
d106 1
a106 1
		err(1, "connect: %s", RIPD_SOCKET);
@


1.15
log
@All commands seem to work fine with pledge "stdio" after the connect(),
direct source and symbol table inspection suggests it is good.  The same
principle will likely apply to most of our network daemon *ctl programs,
since many are derived from ospfd.  Still, each needs testing.
discussion about network daemons and ctl's has been mostly with renato
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.14 2015/09/27 17:32:36 stsp Exp $
d178 1
a178 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.14
log
@As done for bgpd recently, rename if_mediatype to if_type in ripd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.13 2015/09/13 11:13:12 deraadt Exp $
d90 3
@


1.13
log
@match a few if_media uint64_t conversions; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.12 2013/11/14 20:48:52 deraadt Exp $
d43 1
a43 1
const char	*get_linkstate(uint64_t, int);
d45 1
a45 1
int		 get_ifms_type(int);
d53 1
a53 1
void		 print_baudrate(u_int64_t);
d220 2
a221 2
int
get_ifms_type(int mediatype)
d223 1
a223 1
	switch (mediatype) {
d304 1
a304 1
		    get_linkstate(iface->mediatype, iface->linkstate),
d445 1
a445 1
	int		 ifms_type;
d452 1
a452 1
		ifms_type = get_ifms_type(k->media_type);
d456 1
a456 1
		printf("%s", get_linkstate(k->media_type, k->link_state));
d492 1
a492 1
get_linkstate(uint64_t media_type, int link_state)
d498 1
a498 1
		if (LINK_STATE_DESC_MATCH(p, media_type, link_state))
d506 1
a506 1
print_baudrate(u_int64_t baudrate)
@


1.12
log
@cope with the EAGAIN API change for msgbuf_write()
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.11 2013/04/09 14:51:33 gilles Exp $
d43 1
a43 1
const char	*get_linkstate(int, int);
d52 1
a52 1
const char	*get_media_descr(int);
d480 1
a480 1
get_media_descr(int media_type)
d492 1
a492 1
get_linkstate(int media_type, int link_state)
@


1.11
log
@do not store a time_t or the result of a time_t division in an int

prompted by deraadt@@, ok claudio@@ chl@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.10 2009/11/02 20:29:17 claudio Exp $
d30 1
d171 1
a171 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.10
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.9 2009/09/14 11:49:25 claudio Exp $
d247 2
a248 1
	unsigned int	 sec, min, hrs, day, week;
d269 1
a269 1
		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
@


1.9
log
@Switch the various link state printing codes to use the new if_media
independent LINK_STATE_DESCRIPTIONS. Code is now more or less a one to
one copy of get_linkstate() in route/route.c.
OK henning, michele, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.8 2009/07/17 09:14:26 michele Exp $
d73 1
a73 1
	int			 done = 0;
d153 9
d205 2
@


1.8
log
@Correcly mark as 'R' ripd(8) inserted routes even
if they have been modified by ldpd(8).

Spotted by Rolf Sommerhalder
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.7 2009/06/06 08:20:55 eric Exp $
d291 2
a292 2
		    get_linkstate(get_ifms_type(iface->mediatype),
		    iface->linkstate), iface->uptime == 0 ? "00:00:00" :
d439 3
a441 14
		switch (k->media_type) {
		case IFT_ETHER:
			ifms_type = IFM_ETHER;
			break;
		case IFT_FDDI:
			ifms_type = IFM_FDDI;
			break;
		case IFT_CARP:
			ifms_type = IFM_CARP;
			break;
		default:
			ifms_type = 0;
			break;
		}
d443 1
a443 7
		if (ifms_type)
			printf("%s, %s", get_media_descr(ifms_type),
			    get_linkstate(ifms_type, k->link_state));
		else if (k->link_state == LINK_STATE_UNKNOWN)
			printf("unknown");
		else
			printf("link state %u", k->link_state);
d461 2
a462 3
const int	ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
const struct ifmedia_status_description
		ifm_status_descriptions[] = IFM_STATUS_DESCRIPTIONS;
d481 2
a482 2
	const struct ifmedia_status_description	*p;
	int					 i;
d484 6
a489 14
	if (link_state == LINK_STATE_UNKNOWN)
		return ("unknown");

	for (i = 0; ifm_status_valid_list[i] != 0; i++)
		for (p = ifm_status_descriptions; p->ifms_valid != 0; p++) {
			if (p->ifms_type != media_type ||
			    p->ifms_valid != ifm_status_valid_list[i])
				continue;
			if (LINK_STATE_IS_UP(link_state))
				return (p->ifms_string[1]);
			return (p->ifms_string[0]);
		}

	return ("unknown link state");
@


1.7
log
@make ripctl/ripd imsg-in-a-lib ready too.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.6 2008/12/31 14:10:20 sobrado Exp $
d388 1
a388 1
		if (!(k->flags & F_KERNEL))
@


1.6
log
@sync synopsis/usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.5 2007/10/15 02:16:35 deraadt Exp $
a64 6
/* dummy function to allow ripctl to run without libevent */
void
imsg_event_add(struct imsgbuf *i)
{
}

d92 1
a92 1
	imsg_init(ibuf, ctl_sock, NULL);
d110 1
a110 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0,
d116 1
a116 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, NULL, 0);
d121 1
a121 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, NULL, 0);
d125 1
a125 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0,
d128 1
a128 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0,
d134 1
a134 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0,
d137 1
a137 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, NULL, 0);
d144 1
a144 1
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, NULL, 0);
d149 1
a149 1
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, NULL, 0);
d154 1
a154 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
@


1.5
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.4 2007/09/11 17:29:05 henning Exp $
d61 1
a61 1
	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
@


1.4
log
@64bit baudrate and %llu to print
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.3 2007/05/30 03:45:46 henning Exp $
d242 1
a242 1
	unsigned	 sec, min, hrs, day, week;
@


1.3
log
@token fallout.. bad henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.2 2006/11/28 19:21:15 reyk Exp $
d52 1
a52 1
void		 print_baudrate(u_long);
d525 1
a525 1
print_baudrate(u_long baudrate)
d528 1
a528 1
		printf("%lu GBit/s", baudrate / IF_Gbps(1));
d530 1
a530 1
		printf("%lu MBit/s", baudrate / IF_Mbps(1));
d532 1
a532 1
		printf("%lu KBit/s", baudrate / IF_Kbps(1));
d534 1
a534 1
		printf("%lu Bit/s", baudrate);
@


1.2
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripctl.c,v 1.1 2006/10/18 16:15:25 norby Exp $
a223 3
	case IFT_ISO88025:
		return (IFM_TOKEN);
		break;
a450 3
			break;
		case IFT_ISO88025:
			ifms_type = IFM_TOKEN;
@


1.1
log
@Controller for the ripd.

All relevant information in the rip daemon can be displayed with this
controller.

Not connected to builds yet.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$
d522 3
a524 1
			return (p->ifms_string[link_state == LINK_STATE_UP]);
@

