head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.8
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.6
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.49.0.14
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.12
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.10
	OPENBSD_5_0:1.49.0.8
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.6
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.10
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.6
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.6
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.41.0.4
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.4
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	z3HrihslRYb4HqW9;

1.56
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	822YD61EeG0Xl9Na;

1.55
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	Uu5nFG3wCl0LACBb;

1.54
date	2014.10.07.02.16.54;	author guenther;	state Exp;
branches;
next	1.53;
commitid	lrmHf0eaOnSMIuuS;

1.53
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.52;
commitid	0acpjAf5myNxgwB5;

1.52
date	2014.05.18.05.08.07;	author chl;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.23.22.51.42;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.21.12.33.06;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.17.20.02.33;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.08.31.23.14.21;	author ray;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.06.19.16.07;	author sobrado;	state Exp;
branches;
next	1.45;

1.45
date	2006.10.18.21.18.59;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.02.00.50.40;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.12.15.26.23;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.01.04.31.11;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.09.18.26.42;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.26.19.47.08;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.25.18.55.39;	author avsm;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.02.20.30.09;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.13.09.09.46;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.06.21.49.21;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.06.18.29.37;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.29.09.47.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.15.05.17.17;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.14.23.03.39;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.21.09.48.05;	author pjanzen;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.30.16.00.24;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.06.15.17.21.25;	author deraadt;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	99.06.15.17.08.25;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	99.01.03.10.06.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.07.13.02.11.47;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.05.18.19.09.52;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.03.22.21.22.59;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.08.20.05.32.17;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.06.30.06.05.01;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.28.21.28.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.17.07.14.04;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	96.09.16.02.19.37;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.09.01.01.41.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.29.03.33.48;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.06.19.13.27.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.06.06.20.27.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.06.12.10.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.06.12.00.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.25.11.04.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.23.40.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.07.05.28.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.06.21.40.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.24.14.32.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.33;	author deraadt;	state Exp;
branches;
next	;

1.23.4.1
date	2000.10.06.21.24.21;	author jason;	state Exp;
branches;
next	;


desc
@@


1.57
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@/*
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Elz at The University of Melbourne.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Disk quota editor.
 */
#include <sys/param.h>	/* btodb dbtob */
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/wait.h>
#include <ufs/ufs/quota.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fstab.h>
#include <grp.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

char *qfname = QUOTAFILENAME;
char *qfextension[] = INITQFNAMES;
char *quotagroup = QUOTAGROUP;
char tmpfil[] = "/tmp/edquota.XXXXXXXXXX";

struct quotause {
	struct	quotause *next;
	long	flags;
	struct	dqblk dqblk;
	char	fsname[PATH_MAX];
	char	qfname[1];	/* actually longer */
} *getprivs(u_int, int);
#define	FOUND	0x01

void	usage(void);
int	getentry(char *, int, u_int *);
struct quotause *
	getprivs(u_int, int);
void	putprivs(long, int, struct quotause *);
int	editit(const char *);
int	writeprivs(struct quotause *, int, char *, int);
int	readprivs(struct quotause *, int);
int	writetimes(struct quotause *, int, int);
int	readtimes(struct quotause *, int);
char *	cvtstoa(time_t);
int	cvtatos(long long, char *, time_t *);
void	freeprivs(struct quotause *);
int	alldigits(char *s);
int	hasquota(struct fstab *, int, char **);

void
usage(void)
{
	(void)fprintf(stderr, "%s%s%s%s",
	    "usage: edquota [-u] [-p proto-username] username | uid ...\n",
	    "       edquota -g [-p proto-groupname] groupname | gid ...\n",
	    "       edquota -t [-u]\n",
	    "       edquota -g -t\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct quotause *qup, *protoprivs, *curprivs;
	u_int id, protoid;
	int quotatype, tmpfd;
	char *protoname = NULL;
	int ch;
	int tflag = 0, pflag = 0;

	if (argc < 2)
		usage();
	if (getuid())
		errx(1, "%s", strerror(EPERM));
	quotatype = USRQUOTA;
	while ((ch = getopt(argc, argv, "ugtp:")) != -1) {
		switch(ch) {
		case 'p':
			protoname = optarg;
			pflag = 1;
			break;
		case 'g':
			quotatype = GRPQUOTA;
			break;
		case 'u':
			quotatype = USRQUOTA;
			break;
		case 't':
			tflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (pflag) {
		if (getentry(protoname, quotatype, &protoid) == -1)
			exit(1);
		protoprivs = getprivs(protoid, quotatype);
		for (qup = protoprivs; qup; qup = qup->next) {
			qup->dqblk.dqb_btime = 0;
			qup->dqblk.dqb_itime = 0;
		}
		while (argc-- > 0) {
			if (getentry(*argv++, quotatype, &id) == -1)
				continue;
			putprivs(id, quotatype, protoprivs);
		}
		exit(0);
	}
	if ((tmpfd = mkstemp(tmpfil)) == -1)
		errx(1, "%s", tmpfil);
	if (tflag) {
		protoprivs = getprivs(0, quotatype);
		if (writetimes(protoprivs, tmpfd, quotatype) == 0) {
			unlink(tmpfil);
			exit(1);
		}
		if (editit(tmpfil) == -1) {
			int saved_errno = errno;
			unlink(tmpfil);
			errc(1, saved_errno, "error starting editor");
		}
		if (readtimes(protoprivs, tmpfd))
			putprivs(0, quotatype, protoprivs);
		freeprivs(protoprivs);
		unlink(tmpfil);
		exit(0);
	}
	for ( ; argc > 0; argc--, argv++) {
		if (getentry(*argv, quotatype, &id) == -1)
			continue;
		curprivs = getprivs(id, quotatype);
		if (writeprivs(curprivs, tmpfd, *argv, quotatype) == 0)
			continue;
		if (editit(tmpfil) == -1) {
			warn("error starting editor");
			continue;
		}
		if (readprivs(curprivs, tmpfd))
			putprivs(id, quotatype, curprivs);
		freeprivs(curprivs);
	}
	close(tmpfd);
	unlink(tmpfil);
	exit(0);
}

/*
 * This routine converts a name for a particular quota type to
 * an identifier. This routine must agree with the kernel routine
 * getinoquota as to the interpretation of quota types.
 */
int
getentry(char *name, int quotatype, u_int *idp)
{
	struct passwd *pw;
	struct group *gr;
	u_int id;

	switch(quotatype) {
	case USRQUOTA:
		if ((pw = getpwnam(name))) {
			*idp = pw->pw_uid;
			return 0;
		} else if (alldigits(name)) {
			if ((id = strtoul(name, NULL, 10)) <= UID_MAX) {
				*idp = id;
				return 0;
			}
		}
		warnx("%s: no such user", name);
		break;
	case GRPQUOTA:
		if ((gr = getgrnam(name))) {
			*idp = gr->gr_gid;
			return 0;
		} else if (alldigits(name)) {
			if ((id = strtoul(name, NULL, 10)) <= GID_MAX) {
				*idp = id;
				return (0);
			}
		}
		warnx("%s: no such group", name);
		break;
	default:
		warnx("%d: unknown quota type", quotatype);
		break;
	}
	sleep(1);
	return(-1);
}

/*
 * Collect the requested quota information.
 */
struct quotause *
getprivs(u_int id, int quotatype)
{
	struct fstab *fs;
	struct quotause *qup, *quptail;
	struct quotause *quphead;
	int qcmd, qupsize, fd;
	u_int mid;
	char *qfpathname;
	static int warned = 0;
	size_t qfpathnamelen;

	setfsent();
	quphead = NULL;
	qcmd = QCMD(Q_GETQUOTA, quotatype);
	while ((fs = getfsent())) {
		if (strcmp(fs->fs_vfstype, "ffs") &&
		    strcmp(fs->fs_vfstype, "ufs") &&
		    strcmp(fs->fs_vfstype, "mfs"))
			continue;
		if (!hasquota(fs, quotatype, &qfpathname))
			continue;
		qfpathnamelen = strlen(qfpathname);
		qupsize = sizeof(*qup) + qfpathnamelen;
		if ((qup = malloc(qupsize)) == NULL)
			errx(2, "out of memory");
		if (quotactl(fs->fs_file, qcmd, id, (char *)&qup->dqblk) != 0) {
	    		if (errno == EOPNOTSUPP && !warned) {
				warned++;
				(void)fprintf(stderr, "Warning: %s\n",
				    "Quotas are not compiled into this kernel");
				sleep(3);
			}
			if (getentry(quotagroup, GRPQUOTA, &mid) == -1) {
				warned++;
				(void)fprintf(stderr, "Warning: "
				    "group %s not known, skipping %s\n",
				    quotagroup, fs->fs_file);
			}
			if ((fd = open(qfpathname, O_RDONLY)) < 0) {
				fd = open(qfpathname, O_RDWR|O_CREAT, 0640);
				if (fd < 0 && errno != ENOENT) {
					perror(qfpathname);
					free(qup);
					continue;
				}
				(void)fprintf(stderr, "Creating quota file %s\n",
				    qfpathname);
				sleep(3);
				(void)fchown(fd, getuid(), mid);
				(void)fchmod(fd, 0640);
			}
			lseek(fd, (off_t)(id * sizeof(struct dqblk)), SEEK_SET);
			switch (read(fd, &qup->dqblk, sizeof(struct dqblk))) {
			case 0:			/* EOF */
				/*
				 * Convert implicit 0 quota (EOF)
				 * into an explicit one (zero'ed dqblk)
				 */
				bzero((caddr_t)&qup->dqblk,
				    sizeof(struct dqblk));
				break;

			case sizeof(struct dqblk):	/* OK */
				break;

			default:		/* ERROR */
				warn("read error in %s", qfpathname);
				close(fd);
				free(qup);
				continue;
			}
			close(fd);
		}
		strlcpy(qup->qfname, qfpathname, qfpathnamelen + 1);
		strlcpy(qup->fsname, fs->fs_file, sizeof qup->fsname);
		if (quphead == NULL)
			quphead = qup;
		else
			quptail->next = qup;
		quptail = qup;
		qup->next = NULL;
	}
	endfsent();
	return(quphead);
}

/*
 * Store the requested quota information.
 */
void
putprivs(long id, int quotatype, struct quotause *quplist)
{
	struct quotause *qup;
	int qcmd, fd;

	qcmd = QCMD(Q_SETQUOTA, quotatype);
	for (qup = quplist; qup; qup = qup->next) {
		if (quotactl(qup->fsname, qcmd, id, (char *)&qup->dqblk) == 0)
			continue;
		if ((fd = open(qup->qfname, O_WRONLY)) < 0) {
			perror(qup->qfname);
		} else {
			lseek(fd, (off_t)(id * sizeof (struct dqblk)), SEEK_SET);
			if (write(fd, &qup->dqblk, sizeof (struct dqblk)) !=
			    sizeof (struct dqblk))
				warn("%s", qup->qfname);
			close(fd);
		}
	}
}

/*
 * Execute an editor on the specified pathname, which is interpreted
 * from the shell.  This means flags may be included.
 *
 * Returns -1 on error, or the exit value on success.
 */
int
editit(const char *pathname)
{
	char *argp[] = {"sh", "-c", NULL, NULL}, *ed, *p;
	sig_t sighup, sigint, sigquit, sigchld;
	pid_t pid;
	int saved_errno, st, ret = -1;

	ed = getenv("VISUAL");
	if (ed == NULL || ed[0] == '\0')
		ed = getenv("EDITOR");
	if (ed == NULL || ed[0] == '\0')
		ed = _PATH_VI;
	if (asprintf(&p, "%s %s", ed, pathname) == -1)
		return (-1);
	argp[2] = p;

	sighup = signal(SIGHUP, SIG_IGN);
	sigint = signal(SIGINT, SIG_IGN);
	sigquit = signal(SIGQUIT, SIG_IGN);
	sigchld = signal(SIGCHLD, SIG_DFL);
	if ((pid = fork()) == -1)
		goto fail;
	if (pid == 0) {
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}
	while (waitpid(pid, &st, 0) == -1)
		if (errno != EINTR)
			goto fail;
	if (!WIFEXITED(st))
		errno = EINTR;
	else
		ret = WEXITSTATUS(st);

 fail:
	saved_errno = errno;
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	(void)signal(SIGCHLD, sigchld);
	free(p);
	errno = saved_errno;
	return (ret);
}

/*
 * Convert a quotause list to an ASCII file.
 */
int
writeprivs(struct quotause *quplist, int outfd, char *name, int quotatype)
{
	struct quotause *qup;
	FILE *fp;

	ftruncate(outfd, 0);
	lseek(outfd, 0, SEEK_SET);
	if ((fp = fdopen(dup(outfd), "w")) == NULL)
		err(1, "%s", tmpfil);
	(void)fprintf(fp, "Quotas for %s %s:\n", qfextension[quotatype], name);
	for (qup = quplist; qup; qup = qup->next) {
		(void)fprintf(fp, "%s: %s %d, limits (soft = %d, hard = %d)\n",
		    qup->fsname, "KBytes in use:",
		    (int)(dbtob((u_quad_t)qup->dqblk.dqb_curblocks) / 1024),
		    (int)(dbtob((u_quad_t)qup->dqblk.dqb_bsoftlimit) / 1024),
		    (int)(dbtob((u_quad_t)qup->dqblk.dqb_bhardlimit) / 1024));
		(void)fprintf(fp, "%s %d, limits (soft = %d, hard = %d)\n",
		    "\tinodes in use:", qup->dqblk.dqb_curinodes,
		    qup->dqblk.dqb_isoftlimit, qup->dqblk.dqb_ihardlimit);
	}
	fclose(fp);
	return(1);
}

/*
 * Merge changes to an ASCII file into a quotause list.
 */
int
readprivs(struct quotause *quplist, int infd)
{
	struct quotause *qup;
	FILE *fp;
	int cnt;
	char *cp;
	struct dqblk dqblk;
	char *fsp, line1[BUFSIZ], line2[BUFSIZ];

	lseek(infd, 0, SEEK_SET);
	fp = fdopen(dup(infd), "r");
	if (fp == NULL) {
		warnx("can't re-read temp file!!");
		return(0);
	}
	/*
	 * Discard title line, then read pairs of lines to process.
	 */
	(void)fgets(line1, sizeof (line1), fp);
	while (fgets(line1, sizeof (line1), fp) != NULL &&
	       fgets(line2, sizeof (line2), fp) != NULL) {
		if ((fsp = strtok(line1, " \t:")) == NULL) {
			warnx("%s: bad format", line1);
			return(0);
		}
		if ((cp = strtok(NULL, "\n")) == NULL) {
			warnx("%s: %s: bad format", fsp, &fsp[strlen(fsp) + 1]);
			return(0);
		}
		cnt = sscanf(cp,
		    " KBytes in use: %d, limits (soft = %d, hard = %d)",
		    &dqblk.dqb_curblocks, &dqblk.dqb_bsoftlimit,
		    &dqblk.dqb_bhardlimit);
		if (cnt != 3) {
			warnx("%s:%s: bad format", fsp, cp);
			return(0);
		}
		dqblk.dqb_curblocks = btodb((u_quad_t)
		    dqblk.dqb_curblocks * 1024);
		dqblk.dqb_bsoftlimit = btodb((u_quad_t)
		    dqblk.dqb_bsoftlimit * 1024);
		dqblk.dqb_bhardlimit = btodb((u_quad_t)
		    dqblk.dqb_bhardlimit * 1024);
		if ((cp = strtok(line2, "\n")) == NULL) {
			warnx("%s: %s: bad format", fsp, line2);
			return(0);
		}
		cnt = sscanf(cp,
		    "\tinodes in use: %d, limits (soft = %d, hard = %d)",
		    &dqblk.dqb_curinodes, &dqblk.dqb_isoftlimit,
		    &dqblk.dqb_ihardlimit);
		if (cnt != 3) {
			warnx("%s: %s: bad format", fsp, line2);
			return(0);
		}
		for (qup = quplist; qup; qup = qup->next) {
			if (strcmp(fsp, qup->fsname))
				continue;
			/*
			 * Cause time limit to be reset when the quota
			 * is next used if previously had no soft limit
			 * or were under it, but now have a soft limit
			 * and are over it.
			 */
			if (dqblk.dqb_bsoftlimit &&
			    qup->dqblk.dqb_curblocks >= dqblk.dqb_bsoftlimit &&
			    (qup->dqblk.dqb_bsoftlimit == 0 ||
			     qup->dqblk.dqb_curblocks <
			     qup->dqblk.dqb_bsoftlimit))
				qup->dqblk.dqb_btime = 0;
			if (dqblk.dqb_isoftlimit &&
			    qup->dqblk.dqb_curinodes >= dqblk.dqb_isoftlimit &&
			    (qup->dqblk.dqb_isoftlimit == 0 ||
			     qup->dqblk.dqb_curinodes <
			     qup->dqblk.dqb_isoftlimit))
				qup->dqblk.dqb_itime = 0;
			qup->dqblk.dqb_bsoftlimit = dqblk.dqb_bsoftlimit;
			qup->dqblk.dqb_bhardlimit = dqblk.dqb_bhardlimit;
			qup->dqblk.dqb_isoftlimit = dqblk.dqb_isoftlimit;
			qup->dqblk.dqb_ihardlimit = dqblk.dqb_ihardlimit;
			qup->flags |= FOUND;
			if (dqblk.dqb_curblocks == qup->dqblk.dqb_curblocks &&
			    dqblk.dqb_curinodes == qup->dqblk.dqb_curinodes)
				break;
			warnx("%s: cannot change current allocation", fsp);
			break;
		}
	}
	fclose(fp);
	/*
	 * Disable quotas for any filesystems that have not been found.
	 */
	for (qup = quplist; qup; qup = qup->next) {
		if (qup->flags & FOUND) {
			qup->flags &= ~FOUND;
			continue;
		}
		qup->dqblk.dqb_bsoftlimit = 0;
		qup->dqblk.dqb_bhardlimit = 0;
		qup->dqblk.dqb_isoftlimit = 0;
		qup->dqblk.dqb_ihardlimit = 0;
	}
	return(1);
}

/*
 * Convert a quotause list to an ASCII file of grace times.
 */
int
writetimes(struct quotause *quplist, int outfd, int quotatype)
{
	struct quotause *qup;
	FILE *fp;

	ftruncate(outfd, 0);
	lseek(outfd, 0, SEEK_SET);
	if ((fp = fdopen(dup(outfd), "w")) == NULL)
		err(1, "%s", tmpfil);
	(void)fprintf(fp,
	    "Time units may be: days, hours, minutes, or seconds\n");
	(void)fprintf(fp,
	    "Grace period before enforcing soft limits for %ss:\n",
	    qfextension[quotatype]);
	for (qup = quplist; qup; qup = qup->next) {
		(void)fprintf(fp, "%s: block grace period: %s, ",
		    qup->fsname, cvtstoa(qup->dqblk.dqb_btime));
		(void)fprintf(fp, "file grace period: %s\n",
		    cvtstoa(qup->dqblk.dqb_itime));
	}
	fclose(fp);
	return(1);
}

/*
 * Merge changes of grace times in an ASCII file into a quotause list.
 */
int
readtimes(struct quotause *quplist, int infd)
{
	struct quotause *qup;
	FILE *fp;
	int cnt;
	char *cp;
	long long itime, btime;
	time_t iseconds, bseconds;
	char *fsp, bunits[10], iunits[10], line1[BUFSIZ];

	lseek(infd, 0, SEEK_SET);
	fp = fdopen(dup(infd), "r");
	if (fp == NULL) {
		warnx("can't re-read temp file!!");
		return(0);
	}
	/*
	 * Discard two title lines, then read lines to process.
	 */
	(void)fgets(line1, sizeof (line1), fp);
	(void)fgets(line1, sizeof (line1), fp);
	while (fgets(line1, sizeof (line1), fp) != NULL) {
		if ((fsp = strtok(line1, " \t:")) == NULL) {
			warnx("%s: bad format", line1);
			return(0);
		}
		if ((cp = strtok(NULL, "\n")) == NULL) {
			warnx("%s: %s: bad format", fsp,
			    &fsp[strlen(fsp) + 1]);
			return(0);
		}
		cnt = sscanf(cp,
		    " block grace period: %lld %9s file grace period: %lld %9s",
		    &btime, bunits, &itime, iunits);
		if (cnt != 4) {
			warnx("%s:%s: bad format", fsp, cp);
			return(0);
		}
		if (cvtatos(btime, bunits, &bseconds) == 0)
			return(0);
		if (cvtatos(itime, iunits, &iseconds) == 0)
			return(0);
		for (qup = quplist; qup; qup = qup->next) {
			if (strcmp(fsp, qup->fsname))
				continue;
			qup->dqblk.dqb_btime = bseconds;
			qup->dqblk.dqb_itime = iseconds;
			qup->flags |= FOUND;
			break;
		}
	}
	fclose(fp);
	/*
	 * reset default grace periods for any filesystems
	 * that have not been found.
	 */
	for (qup = quplist; qup; qup = qup->next) {
		if (qup->flags & FOUND) {
			qup->flags &= ~FOUND;
			continue;
		}
		qup->dqblk.dqb_btime = 0;
		qup->dqblk.dqb_itime = 0;
	}
	return(1);
}

/*
 * Convert seconds to ASCII times.
 */
char *
cvtstoa(time_t time)
{
	static char buf[20];

	if (time % (24 * 60 * 60) == 0) {
		time /= 24 * 60 * 60;
		(void)snprintf(buf, sizeof buf, "%lld day%s", (long long)time,
		    time == 1 ? "" : "s");
	} else if (time % (60 * 60) == 0) {
		time /= 60 * 60;
		(void)snprintf(buf, sizeof buf, "%lld hour%s", (long long)time,
		    time == 1 ? "" : "s");
	} else if (time % 60 == 0) {
		time /= 60;
		(void)snprintf(buf, sizeof buf, "%lld minute%s",
		    (long long)time, time == 1 ? "" : "s");
	} else
		(void)snprintf(buf, sizeof buf, "%lld second%s",
		    (long long)time, time == 1 ? "" : "s");
	return(buf);
}

/*
 * Convert ASCII input times to seconds.
 */
int
cvtatos(long long time, char *units, time_t *seconds)
{

	if (bcmp(units, "second", 6) == 0)
		*seconds = time;
	else if (bcmp(units, "minute", 6) == 0)
		*seconds = time * 60;
	else if (bcmp(units, "hour", 4) == 0)
		*seconds = time * 60 * 60;
	else if (bcmp(units, "day", 3) == 0)
		*seconds = time * 24 * 60 * 60;
	else {
		(void)printf("%s: bad units, specify %s\n", units,
		    "days, hours, minutes, or seconds");
		return(0);
	}
	return(1);
}

/*
 * Free a list of quotause structures.
 */
void
freeprivs(struct quotause *quplist)
{
	struct quotause *qup, *nextqup;

	for (qup = quplist; qup; qup = nextqup) {
		nextqup = qup->next;
		free(qup);
	}
}

/*
 * Check whether a string is completely composed of digits.
 */
int
alldigits(char *s)
{
	int c;

	c = (unsigned char)*s++;
	do {
		if (!isdigit(c))
			return(0);
	} while ((c = (unsigned char)*s++));
	return(1);
}

/*
 * Check to see if a particular quota is to be enabled.
 */
int
hasquota(struct fstab *fs, int type, char **qfnamep)
{
	char *opt;
	char *cp;
	static char initname, usrname[100], grpname[100];
	static char buf[BUFSIZ];

	if (!initname) {
		(void)snprintf(usrname, sizeof usrname, "%s%s",
		    qfextension[USRQUOTA], qfname);
		(void)snprintf(grpname, sizeof grpname, "%s%s",
		    qfextension[GRPQUOTA], qfname);
		initname = 1;
	}
	strlcpy(buf, fs->fs_mntops, sizeof buf);
	for (opt = strtok(buf, ","); opt; opt = strtok(NULL, ",")) {
		if ((cp = strchr(opt, '=')))
			*cp++ = '\0';
		if (type == USRQUOTA && strcmp(opt, usrname) == 0)
			break;
		if (type == GRPQUOTA && strcmp(opt, grpname) == 0)
			break;
	}
	if (!opt)
		return(0);
	if (cp) {
		*qfnamep = cp;
		return(1);
	}
	(void)snprintf(buf, sizeof buf, "%s/%s.%s",
	    fs->fs_file, qfname, qfextension[type]);
	*qfnamep = buf;
	return(1);
}
@


1.56
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d258 1
a258 1
		if ((qup = (struct quotause *)malloc(qupsize)) == NULL)
@


1.55
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d116 1
a116 1
			pflag++;
d125 1
a125 1
			tflag++;
@


1.54
log
@When reading time intervals, start with a long long and convert from there.
Similarly, print them by casting to long long and using %lld.

ok otto@@
@
text
@d36 1
a36 1
#include <sys/param.h>
d54 1
d65 1
a65 1
	char	fsname[MAXPATHLEN];
@


1.53
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d80 1
a80 1
int	cvtatos(time_t, char *, time_t *);
d572 2
a573 1
	time_t itime, btime, iseconds, bseconds;
d598 2
a599 2
		    " block grace period: %d %9s file grace period: %d %9s",
		    (int *)&btime, bunits, (int *)&itime, iunits);
d643 1
a643 1
		(void)snprintf(buf, sizeof buf, "%d day%s", (int)time,
d647 1
a647 1
		(void)snprintf(buf, sizeof buf, "%d hour%s", (int)time,
d651 2
a652 2
		(void)snprintf(buf, sizeof buf, "%d minute%s", (int)time,
		    time == 1 ? "" : "s");
d654 2
a655 2
		(void)snprintf(buf, sizeof buf, "%d second%s", (int)time,
		    time == 1 ? "" : "s");
d663 1
a663 1
cvtatos(time_t time, char *units, time_t *seconds)
@


1.52
log
@replace some (type *)0 to NULL

ok krw@@ millert@@
@
text
@d156 1
d158 1
a158 1
			err(1, "error starting editor");
@


1.51
log
@yet more unsigned char casts for ctype
checked by jca
@
text
@d245 1
a245 1
	quphead = (struct quotause *)0;
d313 1
a313 1
		qup->next = 0;
d453 1
a453 1
		if ((cp = strtok((char *)0, "\n")) == NULL) {
d590 1
a590 1
		if ((cp = strtok((char *)0, "\n")) == NULL) {
@


1.50
log
@Unbreak edquota by fixing the temporary file name template. Whilst here,
fold pathnames.h into edquota.c - we do not really need a header file for
a single define.

ok deraadt@@ guenther@@ millert@@
@
text
@d702 1
a702 1
	c = *s++;
d706 1
a706 1
	} while ((c = *s++));
@


1.49
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d41 2
d46 2
a48 2
#include <grp.h>
#include <ctype.h>
a53 1
#include "pathnames.h"
d58 1
a58 1
char tmpfil[] = _PATH_TMPFILE;
@


1.48
log
@- Be more careful about pre-existing SIGCHLD handlers (or SIG_IGN) by
  temporarily restoring default behaviour.  This is not 100% ideal.
  But this fixes editor handling in mail... bah, it is really unfortunate
  that got broken
- refactor the restoration code as well, to make it simpler
ok ray
@
text
@a32 11
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)edquota.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$Id: edquota.c,v 1.47 2007/08/31 23:14:21 ray Exp $";
#endif /* not lint */

@


1.47
log
@Copy editit() from sendbug, synchronizing editor calling code.

OK otto, millert, beck, mbalmer, deraadt.
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.46 2007/08/06 19:16:07 sobrado Exp $";
d364 1
a364 1
	sig_t sighup, sigint, sigquit;
d366 1
a366 1
	int saved_errno, st;
d380 1
d390 1
a390 5
	free(p);
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	if (!WIFEXITED(st)) {
d392 2
a393 3
		return (-1);
	}
	return (WEXITSTATUS(st));
d400 1
d403 1
a403 1
	return (-1);
@


1.46
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.45 2006/10/18 21:18:59 deraadt Exp $";
d84 1
a84 1
int	editit(char *);
d165 5
a169 1
		if (editit(tmpfil) && readtimes(protoprivs, tmpfd))
d181 5
a185 1
		if (editit(tmpfil) && readprivs(curprivs, tmpfd))
d355 4
a358 1
 * Take a list of privileges and get it edited.
d361 1
a361 1
editit(char *tmpfile)
d363 9
a371 7
	pid_t pid, xpid;
	char *argp[] = {"sh", "-c", NULL, NULL};
	char *ed, *p;
	sigset_t mask, omask;
	int stat;

	if ((ed = getenv("EDITOR")) == (char *)0)
d373 2
a374 2
	if (asprintf(&p, "%s %s", ed, tmpfile) == -1)
		return (0);
d377 5
a381 20
	sigemptyset(&mask);
	sigaddset(&mask, SIGINT);
	sigaddset(&mask, SIGQUIT);
	sigaddset(&mask, SIGHUP);
	sigprocmask(SIG_SETMASK, &mask, &omask);
 top:
	if ((pid = fork()) < 0) {
		if (errno == EPROCLIM) {
			warnx("you have too many processes");
			free(p);
			return(0);
		}
		if (errno == EAGAIN) {
			sleep(1);
			goto top;
		}
		perror("fork");
		free(p);
		return(0);
	}
a382 3
		sigprocmask(SIG_SETMASK, &omask, NULL);
		setgid(getgid());
		setuid(getuid());
d386 3
d390 6
a395 6
	for (;;) {
		xpid = waitpid(pid, (int *)&stat, WUNTRACED);
		if (WIFSTOPPED(stat))
			raise(WSTOPSIG(stat));
		else if (WIFEXITED(stat))
			break;
d397 10
a406 4
	sigprocmask(SIG_SETMASK, &omask, NULL);
	if (!WIFEXITED(stat) || WEXITSTATUS(stat) != 0)
		return(0);
	return(1);
@


1.45
log
@do not name FILE * variables "fd" since it is confusing
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.44 2006/04/02 00:50:40 deraadt Exp $";
d99 4
a102 3
		"Usage: edquota [-u] [-p username] username ...\n",
		"\tedquota -g [-p groupname] groupname ...\n",
		"\tedquota [-u] -t\n", "\tedquota -g -t\n");
@


1.44
log
@use SEEK_* for lseek()
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.43 2005/11/12 15:26:23 deraadt Exp $";
d411 1
a411 1
	FILE *fd;
d415 1
a415 1
	if ((fd = fdopen(dup(outfd), "w")) == NULL)
d417 1
a417 1
	(void)fprintf(fd, "Quotas for %s %s:\n", qfextension[quotatype], name);
d419 1
a419 1
		(void)fprintf(fd, "%s: %s %d, limits (soft = %d, hard = %d)\n",
d424 1
a424 1
		(void)fprintf(fd, "%s %d, limits (soft = %d, hard = %d)\n",
d428 1
a428 1
	fclose(fd);
d439 1
a439 1
	FILE *fd;
d446 2
a447 2
	fd = fdopen(dup(infd), "r");
	if (fd == NULL) {
d454 3
a456 3
	(void)fgets(line1, sizeof (line1), fd);
	while (fgets(line1, sizeof (line1), fd) != NULL &&
	       fgets(line2, sizeof (line2), fd) != NULL) {
d524 1
a524 1
	fclose(fd);
d548 1
a548 1
	FILE *fd;
d552 1
a552 1
	if ((fd = fdopen(dup(outfd), "w")) == NULL)
d554 1
a554 1
	(void)fprintf(fd,
d556 1
a556 1
	(void)fprintf(fd,
d560 1
a560 1
		(void)fprintf(fd, "%s: block grace period: %s, ",
d562 1
a562 1
		(void)fprintf(fd, "file grace period: %s\n",
d565 1
a565 1
	fclose(fd);
d576 1
a576 1
	FILE *fd;
d583 2
a584 2
	fd = fdopen(dup(infd), "r");
	if (fd == NULL) {
d591 3
a593 3
	(void)fgets(line1, sizeof (line1), fd);
	(void)fgets(line1, sizeof (line1), fd);
	while (fgets(line1, sizeof (line1), fd) != NULL) {
d623 1
a623 1
	fclose(fd);
@


1.43
log
@more asprintf; ok dhill@@mindcry.org
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.42 2005/04/01 04:31:11 deraadt Exp $";
d336 1
a336 1
			lseek(fd, (off_t)(id * sizeof (struct dqblk)), 0);
@


1.42
log
@these commands said "blocks" when they meant "KBytes" (they even calculated
it so).  pointed out by janc@@cyberspace.org, pr 3956
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.41 2004/03/09 18:26:42 tedu Exp $";
d355 1
a355 1
	int stat, len;
d359 2
a360 5
	len = strlen(ed) + 1 + strlen(tmpfile) + 1;
	p = (char *)malloc(len);
	if (!p)
		return(0);
	(void)snprintf(p, len, "%s %s", ed, tmpfile);
@


1.41
log
@type, Marek Blaszkowski
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.40 2003/06/26 19:47:08 deraadt Exp $";
d423 1
a423 1
		    qup->fsname, "blocks in use:",
d469 1
a469 1
		    " blocks in use: %d, limits (soft = %d, hard = %d)",
@


1.40
log
@strict proto cleanups
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.39 2003/06/02 23:36:53 millert Exp $";
d523 1
a523 1
			warnx("%s: cannot change current allocationn", fsp);
@


1.39
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.38 2003/04/25 18:55:39 avsm Exp $";
d96 1
a96 1
usage()
d106 1
a106 3
main(argc, argv)
	int argc;
	char **argv;
d191 1
a191 4
getentry(name, quotatype, idp)
	char *name;
	int quotatype;
	u_int *idp;
d234 1
a234 3
getprivs(id, quotatype)
	u_int id;
	int quotatype;
d324 1
a324 4
putprivs(id, quotatype, quplist)
	long id;
	int quotatype;
	struct quotause *quplist;
d349 1
a349 2
editit(tmpfile)
	char *tmpfile;
d411 1
a411 5
writeprivs(quplist, outfd, name, quotatype)
	struct quotause *quplist;
	int outfd;
	char *name;
	int quotatype;
d439 1
a439 3
readprivs(quplist, infd)
	struct quotause *quplist;
	int infd;
d548 1
a548 4
writetimes(quplist, outfd, quotatype)
	struct quotause *quplist;
	int outfd;
	int quotatype;
a550 1
	char *cvtstoa();
d576 1
a576 3
readtimes(quplist, infd)
	struct quotause *quplist;
	int infd;
d646 1
a646 2
cvtstoa(time)
	time_t time;
d672 1
a672 4
cvtatos(time, units, seconds)
	time_t time;
	char *units;
	time_t *seconds;
d695 1
a695 2
freeprivs(quplist)
	struct quotause *quplist;
d709 1
a709 2
alldigits(s)
	char *s;
d725 1
a725 4
hasquota(fs, type, qfnamep)
	struct fstab *fs;
	int type;
	char **qfnamep;
@


1.38
log
@replace an unbounded %s in a sscanf with a bounded one
ok millert@@
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char *rcsid = "$Id: edquota.c,v 1.37 2003/04/02 20:30:09 deraadt Exp $";
@


1.37
log
@strlcpy; millert ok
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.36 2003/03/13 09:09:46 deraadt Exp $";
d634 1
a634 1
		    " block grace period: %d %s file grace period: %d %s",
@


1.36
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.35 2002/09/06 21:49:21 deraadt Exp $";
d254 1
d266 2
a267 1
		qupsize = sizeof(*qup) + strlen(qfpathname);
d318 2
a319 2
		strcpy(qup->qfname, qfpathname);
		strcpy(qup->fsname, fs->fs_file);
@


1.35
log
@cope with INITQFNAMES without a ;
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.34 2002/09/06 18:29:37 deraadt Exp $";
d368 1
a368 1
	int stat;
d372 2
a373 1
	p = (char *)malloc(strlen(ed) + 1 + strlen(tmpfile) + 1);
d376 1
a376 1
	(void)sprintf(p, "%s %s", ed, tmpfile);
@


1.34
log
@no ; after INITQFNAMES
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.33 2002/06/04 00:09:08 deraadt Exp $";
d70 1
a70 1
char *qfextension[] = INITQFNAMES
@


1.33
log
@spelling; raj@@cerias.purdue.edu
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.32 2002/05/29 09:47:20 deraadt Exp $";
d70 1
a70 1
char *qfextension[] = INITQFNAMES;
@


1.32
log
@more snprintf
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.31 2002/05/26 09:25:21 deraadt Exp $";
d358 1
a358 1
 * Take a list of priviledges and get it edited.
@


1.31
log
@pid_t cleanup
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.30 2002/03/14 16:44:24 mpech Exp $";
d677 1
a677 1
		(void)sprintf(buf, "%d day%s", (int)time,
d681 1
a681 1
		(void)sprintf(buf, "%d hour%s", (int)time,
d685 1
a685 1
		(void)sprintf(buf, "%d minute%s", (int)time,
d688 1
a688 1
		(void)sprintf(buf, "%d second%s", (int)time,
@


1.30
log
@kill more registers.

millert@@ ok
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.29 2002/02/16 21:28:01 millert Exp $";
d364 1
a364 1
	int pid, stat, xpid;
d368 1
@


1.29
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.28 2001/09/04 23:35:59 millert Exp $";
d247 2
a248 2
	register struct fstab *fs;
	register struct quotause *qup, *quptail;
d338 1
a338 1
	register struct quotause *qup;
d428 1
a428 1
	register struct quotause *qup;
d458 1
a458 1
	register struct quotause *qup;
d461 1
a461 1
	register char *cp;
d570 1
a570 1
	register struct quotause *qup;
d601 1
a601 1
	register struct quotause *qup;
d604 1
a604 1
	register char *cp;
d725 1
a725 1
	register struct quotause *qup, *nextqup;
d759 1
a759 1
	register char *opt;
@


1.28
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.27 2001/01/15 05:17:17 angelos Exp $";
d80 1
a80 1
} *getprivs __P((u_int, int));
d83 2
a84 2
void	usage __P((void));
int	getentry __P((char *, int, u_int *));
d86 12
a97 12
	getprivs __P((u_int, int));
void	putprivs __P((long, int, struct quotause *));
int	editit __P((char *));
int	writeprivs __P((struct quotause *, int, char *, int));
int	readprivs __P((struct quotause *, int));
int	writetimes __P((struct quotause *, int, int));
int	readtimes __P((struct quotause *, int));
char *	cvtstoa __P((time_t));
int	cvtatos __P((time_t, char *, time_t *));
void	freeprivs __P((struct quotause *));
int	alldigits __P((char *s));
int	hasquota __P((struct fstab *, int, char **));
@


1.27
log
@Revert previous patch (I should stop believing Theo, esp. when he's
intoxicated). Thanks to Paul Janzen for pointing this out.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.25 2000/12/21 09:48:05 pjanzen Exp $";
a363 1
	int omask;
d366 2
a367 2
	register char *ed;
	char *p;
d377 5
a381 1
	omask = sigblock(sigmask(SIGINT)|sigmask(SIGQUIT)|sigmask(SIGHUP));
d398 1
a398 1
		sigsetmask(omask);
d412 1
a412 1
	sigsetmask(omask);
@


1.26
log
@Handle quotas over 4G, PR 1534 (bob@@prophecy.lu)
@
text
@a68 6
#if DEV_BSHIFT < 10
#define dbtokb(x) ((x) >> (10 - DEV_BSHIFT))
#else
#define dbtokb(x) ((x) << (DEV_BSHIFT - 10))
#endif

d434 1
a434 1
		(void)fprintf(fd, "%s: %s %lu, limits (soft = %lu, hard = %lu)\n",
d436 4
a439 4
		    (int)(dbtokb((u_quad_t)qup->dqblk.dqb_curblocks)),
		    (int)(dbtokb((u_quad_t)qup->dqblk.dqb_bsoftlimit)),
		    (int)(dbtokb((u_quad_t)qup->dqblk.dqb_bhardlimit)));
		(void)fprintf(fd, "%s %lu, limits (soft = %lu, hard = %lu)\n",
@


1.25
log
@Deal with quotas over 4G correctly; also, tidy a bit and be a touch more
paranoid with some buffers.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.24 2000/06/30 16:00:24 millert Exp $";
d69 6
d440 1
a440 1
		(void)fprintf(fd, "%s: %s %d, limits (soft = %d, hard = %d)\n",
d442 4
a445 4
		    (int)(dbtob((u_quad_t)qup->dqblk.dqb_curblocks) / 1024),
		    (int)(dbtob((u_quad_t)qup->dqblk.dqb_bsoftlimit) / 1024),
		    (int)(dbtob((u_quad_t)qup->dqblk.dqb_bhardlimit) / 1024));
		(void)fprintf(fd, "%s %d, limits (soft = %d, hard = %d)\n",
@


1.24
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.23 1999/06/15 17:21:25 deraadt Exp $";
d83 4
d88 3
a90 1
void	freeprivs __P((struct quotause *));
a91 1
int	editit __P((char *));
d93 3
a95 1
int	writeprivs __P((struct quotause *, int, char *, int));
a96 1
int	readprivs __P((struct quotause *, int));
a97 2
int	cvtatos __P((time_t, char *, time_t *));
int	getentry __P((char *, int, u_int *));
a110 1
	register char **argv;
d112 1
d114 1
a114 1
	register struct quotause *qup, *protoprivs, *curprivs;
d116 1
a116 1
	register int quotatype, tmpfd;
d244 1
a244 1
	register u_int id;
d436 3
a438 3
		    dbtob(qup->dqblk.dqb_curblocks) / 1024,
		    dbtob(qup->dqblk.dqb_bsoftlimit) / 1024,
		    dbtob(qup->dqblk.dqb_bhardlimit) / 1024);
d490 6
a495 3
		dqblk.dqb_curblocks = btodb(dqblk.dqb_curblocks * 1024);
		dqblk.dqb_bsoftlimit = btodb((off_t)dqblk.dqb_bsoftlimit * 1024);
		dqblk.dqb_bhardlimit = btodb((off_t)dqblk.dqb_bhardlimit * 1024);
d735 1
a735 1
	register char *s;
d737 1
a737 1
	register int c;
d752 1
a752 1
	register struct fstab *fs;
d762 4
a765 2
		(void)sprintf(usrname, "%s%s", qfextension[USRQUOTA], qfname);
		(void)sprintf(grpname, "%s%s", qfextension[GRPQUOTA], qfname);
d768 1
a768 1
	strcpy(buf, fs->fs_mntops);
d783 2
a784 1
	(void)sprintf(buf, "%s/%s.%s", fs->fs_file, qfname, qfextension[type]);
@


1.23
log
@change getentry() args to solve problem
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.21 1999/01/03 10:06:35 deraadt Exp $";
d120 1
a120 1
		errx(1, strerror(EPERM));
d159 1
a159 1
		errx(1, tmpfil);
d347 1
a347 1
				warn(qup->qfname);
d427 1
a427 1
		err(1, tmpfil);
d567 1
a567 1
		err(1, tmpfil);
@


1.23.4.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.24 2000/06/30 16:00:24 millert Exp $";
d120 1
a120 1
		errx(1, "%s", strerror(EPERM));
d159 1
a159 1
		errx(1, "%s", tmpfil);
d347 1
a347 1
				warn("%s", qup->qfname);
d427 1
a427 1
		err(1, "%s", tmpfil);
d567 1
a567 1
		err(1, "%s", tmpfil);
@


1.22
log
@Check return value of getentry() for -1, not < 0 since it returns
an unsigned value; jon@@oaktree.co.uk
@
text
@d93 1
a93 1
u_int	getentry __P((char *, int));
d111 1
a111 1
	register u_int id, protoid;
d144 1
a144 1
		if ((protoid = getentry(protoname, quotatype)) == -1)
d152 1
a152 1
			if ((id = getentry(*argv++, quotatype)) == -1)
d173 1
a173 1
		if ((id = getentry(*argv, quotatype)) == -1)
d192 2
a193 2
u_int
getentry(name, quotatype)
d196 1
d200 1
a200 1
	u_long id;
d204 8
a211 5
		if ((pw = getpwnam(name)))
			return(pw->pw_uid);
		else if (alldigits(name)) {
			if ((id = strtoul(name, NULL, 10)) <= UID_MAX)
				return((uid_t)id);
d216 8
a223 5
		if ((gr = getgrnam(name)))
			return(gr->gr_gid);
		else if (alldigits(name)) {
			if ((id = strtoul(name, NULL, 10)) <= GID_MAX)
				return((gid_t)id);
d247 1
d271 6
d287 1
a287 2
				(void)fchown(fd, getuid(),
				    getentry(quotagroup, GRPQUOTA));
@


1.21
log
@fix overflow; bde
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.20 1998/07/13 02:11:47 millert Exp $";
d152 1
a152 1
			if ((id = getentry(*argv++, quotatype)) < 0)
@


1.20
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.19 1998/05/18 19:09:52 deraadt Exp $";
d474 2
a475 2
		dqblk.dqb_bsoftlimit = btodb(dqblk.dqb_bsoftlimit * 1024);
		dqblk.dqb_bhardlimit = btodb(dqblk.dqb_bhardlimit * 1024);
@


1.19
log
@MAXPATHLEN not MAXPATHLEN+1
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.18 1998/03/22 21:22:59 millert Exp $";
d277 1
a277 1
			lseek(fd, (off_t)(id * sizeof(struct dqblk)), L_SET);
d412 1
a412 1
	lseek(outfd, 0, L_SET);
d445 1
a445 1
	lseek(infd, 0, L_SET);
d552 1
a552 1
	lseek(outfd, 0, L_SET);
d585 1
a585 1
	lseek(infd, 0, L_SET);
@


1.18
log
@Don't assume all-numeric names are id's, look up as a name in
passwd first.  Noted by Solar Designer <solar@@FALSE.COM>
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.17 1997/08/20 05:32:17 millert Exp $";
d78 1
a78 1
	char	fsname[MAXPATHLEN + 1];
@


1.17
log
@Some KNF and use warn/err.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.16 1997/06/30 06:05:01 deraadt Exp $";
a84 1
int	getentry __P((char *, int));
d93 1
a110 2
	extern char *optarg;
	extern int optind;
d192 1
a192 1
int
d199 1
a200 2
	if (alldigits(name))
		return(atoi(name));
d205 4
d214 4
a241 1
	extern int errno;
a363 2
		extern errno;

d717 1
a717 1
	register c;
@


1.16
log
@Wall. uid & gid are not perfect .. but that is OK
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.15 1997/01/28 21:28:43 deraadt Exp $";
d56 1
d98 1
a98 1
	fprintf(stderr, "%s%s%s%s",
d121 2
a122 4
	if (getuid()) {
		fprintf(stderr, "edquota: permission denied\n");
		exit(1);
	}
d160 2
a161 5
	tmpfd = mkstemp(tmpfil);
	if (tmpfd == -1) {
		fprintf(stderr, "edquota: cannot open file\n");
		exit(1);
	}
d203 1
a203 1
		return (atoi(name));
d207 2
a208 2
			return (pw->pw_uid);
		fprintf(stderr, "%s: no such user\n", name);
d212 2
a213 2
			return (gr->gr_gid);
		fprintf(stderr, "%s: no such group\n", name);
d216 1
a216 1
		fprintf(stderr, "%d: unknown quota type\n", quotatype);
d220 1
a220 1
	return (-1);
d250 2
a251 4
		if ((qup = (struct quotause *)malloc(qupsize)) == NULL) {
			fprintf(stderr, "edquota: out of memory\n");
			exit(2);
		}
d255 1
a255 1
				fprintf(stderr, "Warning: %s\n",
d266 1
a266 1
				fprintf(stderr, "Creating quota file %s\n",
d269 1
a269 1
				(void) fchown(fd, getuid(),
d271 1
a271 1
				(void) fchmod(fd, 0640);
d288 1
a288 2
				fprintf(stderr, "edquota: read error in ");
				perror(qfpathname);
d305 1
a305 1
	return (quphead);
d329 2
a330 4
			    sizeof (struct dqblk)) {
				fprintf(stderr, "edquota: ");
				perror(qup->qfname);
			}
d353 2
a354 2
		return (0);
	sprintf(p, "%s %s", ed, tmpfile);
d363 1
a363 1
			fprintf(stderr, "You have too many processes\n");
d373 1
a373 1
		return (0);
d392 2
a393 2
		return (0);
	return (1);
d411 3
a413 6
	if ((fd = fdopen(dup(outfd), "w")) == NULL) {
		fprintf(stderr, "edquota: ");
		perror(tmpfil);
		exit(1);
	}
	fprintf(fd, "Quotas for %s %s:\n", qfextension[quotatype], name);
d415 1
a415 1
		fprintf(fd, "%s: %s %d, limits (soft = %d, hard = %d)\n",
d420 1
a420 1
		fprintf(fd, "%s %d, limits (soft = %d, hard = %d)\n",
d425 1
a425 1
	return (1);
d446 2
a447 2
		fprintf(stderr, "Can't re-read temp file!!\n");
		return (0);
d452 1
a452 1
	(void) fgets(line1, sizeof (line1), fd);
d456 2
a457 2
			fprintf(stderr, "%s: bad format\n", line1);
			return (0);
d460 2
a461 3
			fprintf(stderr, "%s: %s: bad format\n", fsp,
			    &fsp[strlen(fsp) + 1]);
			return (0);
d468 2
a469 2
			fprintf(stderr, "%s:%s: bad format\n", fsp, cp);
			return (0);
d475 2
a476 2
			fprintf(stderr, "%s: %s: bad format\n", fsp, line2);
			return (0);
d483 2
a484 2
			fprintf(stderr, "%s: %s: bad format\n", fsp, line2);
			return (0);
d515 1
a515 2
			fprintf(stderr,
			    "%s: cannot change current allocation\n", fsp);
d533 1
a533 1
	return (1);
d551 6
a556 7
	if ((fd = fdopen(dup(outfd), "w")) == NULL) {
		fprintf(stderr, "edquota: ");
		perror(tmpfil);
		exit(1);
	}
	fprintf(fd, "Time units may be: days, hours, minutes, or seconds\n");
	fprintf(fd, "Grace period before enforcing soft limits for %ss:\n",
d559 1
a559 1
		fprintf(fd, "%s: block grace period: %s, ",
d561 1
a561 1
		fprintf(fd, "file grace period: %s\n",
d565 1
a565 1
	return (1);
d586 2
a587 2
		fprintf(stderr, "Can't re-read temp file!!\n");
		return (0);
d592 2
a593 2
	(void) fgets(line1, sizeof (line1), fd);
	(void) fgets(line1, sizeof (line1), fd);
d596 2
a597 2
			fprintf(stderr, "%s: bad format\n", line1);
			return (0);
d600 1
a600 1
			fprintf(stderr, "%s: %s: bad format\n", fsp,
d602 1
a602 1
			return (0);
d608 2
a609 2
			fprintf(stderr, "%s:%s: bad format\n", fsp, cp);
			return (0);
d612 1
a612 1
			return (0);
d614 1
a614 1
			return (0);
d637 1
a637 1
	return (1);
d651 2
a652 1
		sprintf(buf, "%d day%s", (int) time, time == 1 ? "" : "s");
d655 2
a656 1
		sprintf(buf, "%d hour%s", (int) time, time == 1 ? "" : "s");
d659 2
a660 1
		sprintf(buf, "%d minute%s", (int) time, time == 1 ? "" : "s");
d662 3
a664 2
		sprintf(buf, "%d second%s", (int) time, time == 1 ? "" : "s");
	return (buf);
d686 1
a686 1
		printf("%s: bad units, specify %s\n", units,
d688 1
a688 1
		return (0);
d690 1
a690 1
	return (1);
d720 1
a720 1
			return (0);
d722 1
a722 1
	return (1);
d740 2
a741 2
		sprintf(usrname, "%s%s", qfextension[USRQUOTA], qfname);
		sprintf(grpname, "%s%s", qfextension[GRPQUOTA], qfname);
d754 1
a754 1
		return (0);
d757 1
a757 1
		return (1);
d759 1
a759 1
	(void) sprintf(buf, "%s/%s.%s", fs->fs_file, qfname, qfextension[type]);
d761 1
a761 1
	return (1);
@


1.15
log
@repair quotactl() types
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.14 1997/01/17 07:14:04 millert Exp $";
d62 1
d79 1
a79 1
} *getprivs();
d82 11
a92 2
void putprivs __P((long, int, struct quotause *));
void freeprivs __P((struct quotause *));
d112 1
a112 1
	register long id, protoid;
d114 1
a114 1
	char *protoname;
d162 4
a165 1
	fchown(tmpfd, getuid(), getgid());
d210 1
a210 1
		if (pw = getpwnam(name))
d215 1
a215 1
		if (gr = getgrnam(name))
d232 1
a232 1
	register long id;
d352 1
a352 1
	long omask;
d621 1
a621 1
		    &btime, bunits, &itime, iunits);
d666 1
a666 1
		sprintf(buf, "%d day%s", time, time == 1 ? "" : "s");
d669 1
a669 1
		sprintf(buf, "%d hour%s", time, time == 1 ? "" : "s");
d672 1
a672 1
		sprintf(buf, "%d minute%s", time, time == 1 ? "" : "s");
d674 1
a674 1
		sprintf(buf, "%d second%s", time, time == 1 ? "" : "s");
d732 1
a732 1
	} while (c = *s++);
@


1.14
log
@r?index -> strr?chr
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.13 1996/09/16 02:19:37 millert Exp $";
d245 1
a245 1
		if (quotactl(fs->fs_file, qcmd, id, &qup->dqblk) != 0) {
d316 1
a316 1
		if (quotactl(qup->fsname, qcmd, id, &qup->dqblk) == 0)
@


1.13
log
@_PATH_TMP -> _PATH_TMPFILE
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.12 1996/09/01 01:41:44 deraadt Exp $";
d733 1
a733 1
	char *cp, *index(), *strtok();
d744 1
a744 1
		if ((cp = index(opt, '=')))
@


1.12
log
@fix warnings
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.11 1996/08/29 03:33:48 deraadt Exp $";
d70 1
a70 1
char tmpfil[] = _PATH_TMP;
@


1.11
log
@type fixes
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.10 1996/06/19 13:27:16 deraadt Exp $";
d80 3
@


1.10
log
@do not use system() to start $EDITOR, but fake system() ourselves
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.9 1996/06/06 20:27:49 deraadt Exp $";
d81 11
a176 9
usage()
{
	fprintf(stderr, "%s%s%s%s",
		"Usage: edquota [-u] [-p username] username ...\n",
		"\tedquota -g [-p groupname] groupname ...\n",
		"\tedquota [-u] -t\n", "\tedquota -g -t\n");
	exit(1);
}

d182 1
d230 1
a230 1
	while (fs = getfsent()) {
d302 1
d332 1
d392 1
d427 1
d537 1
d570 1
d665 1
d691 1
d706 1
d723 1
d741 1
a741 1
		if (cp = index(opt, '='))
@


1.9
log
@do not forget to unlink tmpfil
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.8 1996/06/06 12:10:04 deraadt Exp $";
d332 2
a333 3
	int pid, stat;
	extern char *getenv();

d336 1
d343 1
a349 1
		free(p);
d352 1
d360 1
d367 2
a368 3
		if (system(p) == -1)
			perror(ed);
		exit(1);
d371 7
a377 1
	waitpid(pid, &stat, 0);
@


1.8
log
@system() $EDITOR safely
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.7 1996/06/06 12:00:55 deraadt Exp $";
d141 2
a142 1
		if (writetimes(protoprivs, tmpfd, quotatype) == 0)
d144 1
d148 1
@


1.7
log
@use system, so that $EDITOR expansion works
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.6 1996/04/25 11:04:08 deraadt Exp $";
d332 9
d346 1
a358 3
		register char *ed;
		char *p;

a361 4
		if ((ed = getenv("EDITOR")) == (char *)0)
			ed = _PATH_VI;
		p = (char *)malloc(strlen(ed) + 1 + strlen(tmpfile) + 1);
		sprintf(p, "%s %s", ed, tmpfile);
d366 1
@


1.6
log
@permit quotas to work on mfs; problem reported by rdante@@pnet.net
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.5 1996/04/21 23:40:32 deraadt Exp $";
d350 1
d357 4
a360 2
		execlp(ed, ed, tmpfile, 0);
		perror(ed);
@


1.5
log
@sync to netbsd 960418
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.4 1996/01/07 05:28:04 deraadt Exp $";
d226 2
a227 1
		    strcmp(fs->fs_vfstype, "ufs"))
@


1.4
log
@accept either ffs or ufs for filesystem name
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.3 1995/11/06 21:40:46 deraadt Exp $";
d90 2
a91 1
	char *protoname, ch;
d101 1
a101 1
	while ((ch = getopt(argc, argv, "ugtp:")) != EOF) {
@


1.3
log
@Complete change from ufs -> ffs; (From Tatoku Ogaito; PR #1679)
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.9.2.1 1995/11/01 00:32:21 jtc Exp $";
d224 2
a225 1
		if (strcmp(fs->fs_vfstype, "ffs"))
@


1.2
log
@ufs -> ffs
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.1.1.1 1995/10/18 08:47:33 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
static char *rcsid = "$Id: edquota.c,v 1.9 1995/04/21 04:41:21 cgd Exp $";
d224 1
a224 1
		if (strcmp(fs->fs_vfstype, "ufs"))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
