head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.8
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.16
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.5.0.6
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2016.09.02.16.20.34;	author benno;	state Exp;
branches;
next	1.28;
commitid	GeTQXXDZkuCy2ybg;

1.28
date	2016.09.02.15.38.08;	author renato;	state Exp;
branches;
next	1.27;
commitid	RZy3B9dNz2typ92I;

1.27
date	2016.09.02.15.35.34;	author renato;	state Exp;
branches;
next	1.26;
commitid	mZZPdF3JSUT0PFss;

1.26
date	2016.09.02.15.33.27;	author renato;	state Exp;
branches;
next	1.25;
commitid	XYNgWRJ78YI9wKPC;

1.25
date	2015.12.05.13.11.00;	author claudio;	state Exp;
branches;
next	1.24;
commitid	IgfRve2khGGqPTCy;

1.24
date	2014.07.12.19.22.32;	author krw;	state Exp;
branches;
next	1.23;
commitid	XAgbiXPNNyS0mzjf;

1.23
date	2013.11.26.11.32.31;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.02.20.31.50;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.06.09.52.14;	author michele;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.06.07.52.04;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.01.23.22.58;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.31.20.31.35;	author jacekm;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.31.17.13.04;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.20.16.10.04;	author michele;	state Exp;
branches;
next	1.15;

1.15
date	2009.04.16.20.11.12;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.11.10.21.20;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.14.15.32.55;	author michele;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.07.12.47.17;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.06.18.39.13;	author michele;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.27.08.53.47;	author michele;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.24.16.25.47;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.20.01.35.34;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.19.20.40.31;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.02.13.42.44;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.21.19.33.48;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.24.09.57.51;	author norby;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.03.20.14.37;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.01.21.47.27;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.29
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@
@
text
@/*	$OpenBSD: rde.c,v 1.28 2016/09/02 15:38:08 renato Exp $ */

/*
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2006 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>

#include "igmp.h"
#include "dvmrp.h"
#include "dvmrpd.h"
#include "dvmrpe.h"
#include "log.h"
#include "rde.h"

void		 rde_sig_handler(int sig, short, void *);
__dead void	 rde_shutdown(void);
void		 rde_dispatch_imsg(int, short, void *);

int		 rde_select_ds_ifs(struct mfc *, struct iface *);

volatile sig_atomic_t	 rde_quit = 0;
struct dvmrpd_conf	*rdeconf = NULL;
struct rde_nbr		*nbrself;
struct imsgev		*iev_dvmrpe;
struct imsgev		*iev_main;

void
rde_sig_handler(int sig, short event, void *arg)
{
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		rde_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* route decision engine */
pid_t
rde(struct dvmrpd_conf *xconf, int pipe_parent2rde[2], int pipe_dvmrpe2rde[2],
    int pipe_parent2dvmrpe[2])
{
	struct passwd		*pw;
	struct event		 ev_sigint, ev_sigterm;
	pid_t			 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	rdeconf = xconf;

	if ((pw = getpwnam(DVMRPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("route decision engine");
	dvmrpd_process = PROC_RDE_ENGINE;
	log_procname = log_procnames[dvmrpd_process];

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, rde_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, rde_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes */
	close(pipe_dvmrpe2rde[0]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2dvmrpe[0]);
	close(pipe_parent2dvmrpe[1]);

	if ((iev_dvmrpe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);

	imsg_init(&iev_dvmrpe->ibuf, pipe_dvmrpe2rde[1]);
	iev_dvmrpe->handler = rde_dispatch_imsg;

	imsg_init(&iev_main->ibuf, pipe_parent2rde[1]);
	iev_main->handler = rde_dispatch_imsg;

	/* setup event handler */
	iev_dvmrpe->events = EV_READ;
	event_set(&iev_dvmrpe->ev, iev_dvmrpe->ibuf.fd, iev_dvmrpe->events,
	    iev_dvmrpe->handler, iev_dvmrpe);
	event_add(&iev_dvmrpe->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	rt_init();
	mfc_init();

	event_dispatch();

	rde_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
rde_shutdown(void)
{
	struct iface	*iface;

	/* close pipes */
	msgbuf_clear(&iev_dvmrpe->ibuf.w);
	close(iev_dvmrpe->ibuf.fd);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	rt_clear();
	mfc_clear();

	LIST_FOREACH(iface, &rdeconf->iface_list, entry) {
		if_del(iface);
	}

	free(iev_dvmrpe);
	free(iev_main);
	free(rdeconf);

	log_info("route decision engine exiting");
	_exit(0);
}

/* imesg */
int
rde_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
rde_imsg_compose_dvmrpe(int type, u_int32_t peerid, pid_t pid, void *data,
    u_int16_t datalen)
{
	return (imsg_compose_event(iev_dvmrpe, type, peerid, pid, -1,
	     data, datalen));
}

void
rde_dispatch_imsg(int fd, short event, void *bula)
{
	struct mfc		 mfc;
	struct prune		 p;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct route_report	 rr;
	struct nbr_msg		 nm;
	int			 i, connected = 0, shut = 0, verbose;
	ssize_t			 n;
	struct iface		*iface;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_imsg: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_RIB:
			rt_dump(imsg.hdr.pid);
			imsg_compose_event(iev_dvmrpe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_CTL_SHOW_MFC:
			mfc_dump(imsg.hdr.pid);
			imsg_compose_event(iev_dvmrpe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_ROUTE_REPORT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rr))
				fatalx("invalid size of OE request");
			memcpy(&rr, imsg.data, sizeof(rr));

			/* directly connected networks from parent */
			if (imsg.hdr.peerid == 0)
				connected = 1;

			if (srt_check_route(&rr, connected) == -1)
				log_debug("rde_dispatch_imsg: "
				    "packet malformed");
			break;
		case IMSG_FULL_ROUTE_REPORT:
			rt_snap(imsg.hdr.peerid);
			rde_imsg_compose_dvmrpe(IMSG_FULL_ROUTE_REPORT_END,
			    imsg.hdr.peerid, 0, NULL, 0);
			break;
		case IMSG_MFC_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(mfc))
				fatalx("invalid size of OE request");
			memcpy(&mfc, imsg.data, sizeof(mfc));
#if 1
			for (i = 0; i < MAXVIFS; i++)
				mfc.ttls[i] = 0;

			LIST_FOREACH(iface, &rdeconf->iface_list, entry) {
				if (rde_select_ds_ifs(&mfc, iface))
					mfc.ttls[iface->ifindex] = 1;
			}

			mfc_update(&mfc);
#endif
			break;
		case IMSG_MFC_DEL:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(mfc))
				fatalx("invalid size of OE request");
			memcpy(&mfc, imsg.data, sizeof(mfc));
#if 1
			mfc_delete(&mfc);
#endif
			break;
		case IMSG_GROUP_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(mfc))
				fatalx("invalid size of OE request");
			memcpy(&mfc, imsg.data, sizeof(mfc));

			iface = if_find_index(mfc.ifindex);
			if (iface == NULL) {
				fatalx("rde_dispatch_imsg: "
				    "cannot find matching interface");
			}

			rde_group_list_add(iface, mfc.group);
			break;
		case IMSG_GROUP_DEL:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(mfc))
				fatalx("invalid size of OE request");
			memcpy(&mfc, imsg.data, sizeof(mfc));

			iface = if_find_index(mfc.ifindex);
			if (iface == NULL) {
				fatalx("rde_dispatch_imsg: "
				    "cannot find matching interface");
			}

			rde_group_list_remove(iface, mfc.group);
			break;
		case IMSG_NBR_DEL:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(nm))
				fatalx("invalid size of OE request");

			memcpy(&nm, imsg.data, sizeof(nm));

			srt_expire_nbr(nm.address, nm.ifindex);
			break;
		case IMSG_RECV_PRUNE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(p))
				fatalx("invalid size of OE request");
			memcpy(&p, imsg.data, sizeof(p));

			mfc_recv_prune(&p);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by dvmrpe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("rde_dispatch_msg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

int
rde_select_ds_ifs(struct mfc *mfc, struct iface *iface)
{
	struct rt_node	*rn;

	if (mfc->ifindex == iface->ifindex)
		return (0);

	if (rde_group_list_find(iface, mfc->group))
		return (1);

	rn = rt_match_origin(mfc->origin.s_addr);
	if (rn == NULL) {
		log_debug("rde_selected_ds_iface: no informations about "
		    "the origin %s", inet_ntoa(mfc->origin));
		return (0);
	}

	if (rn->ds_cnt[iface->ifindex] != 0)
		return (1);

	return (0);
}

/* rde group functions */
void
rde_group_list_add(struct iface *iface, struct in_addr group)
{
	struct rde_group	*rdegrp;

	/* validate group id */
	if (!IN_MULTICAST(htonl(group.s_addr))) {
		log_debug("rde_group_list_add: interface %s, %s is not a "
		    "multicast address", iface->name,
		    inet_ntoa(group));
		return;
	}

	if (rde_group_list_find(iface, group))
		return;

	rdegrp = calloc(1, sizeof(*rdegrp));
	if (rdegrp == NULL)
		fatal("rde_group_list_add");

	rdegrp->rde_group.s_addr = group.s_addr;

	TAILQ_INSERT_TAIL(&iface->rde_group_list, rdegrp, entry);

	log_debug("rde_group_list_add: interface %s, group %s", iface->name,
	    inet_ntoa(rdegrp->rde_group));

	return;
}

int
rde_group_list_find(struct iface *iface, struct in_addr group)
{
	struct rde_group	*rdegrp = NULL;

	/* validate group id */
	if (!IN_MULTICAST(htonl(group.s_addr))) {
		log_debug("rde_group_list_find: interface %s, %s is not a "
		    "multicast address", iface->name,
		    inet_ntoa(group));
		return (0);
	}

	TAILQ_FOREACH(rdegrp, &iface->rde_group_list, entry) {
		if (rdegrp->rde_group.s_addr == group.s_addr)
			return (1);
	}

	return (0);
}

void
rde_group_list_remove(struct iface *iface, struct in_addr group)
{
	struct rde_group	*rg;
	struct rt_node		*rn;

	if (TAILQ_EMPTY(&iface->rde_group_list))
		fatalx("rde_group_list_remove: group does not exist");

	for (rg = TAILQ_FIRST(&iface->rde_group_list); rg != NULL;
	    rg = TAILQ_NEXT(rg, entry)) {
		if (rg->rde_group.s_addr == group.s_addr) {
			log_debug("group_list_remove: interface %s, group %s",
			    iface->name, inet_ntoa(rg->rde_group));
			TAILQ_REMOVE(&iface->rde_group_list, rg, entry);
			free(rg);
		}
	}

	rn = mfc_find_origin(group);
	if (rn == NULL)
		return;

	srt_check_downstream_ifaces(rn, iface);
}
@


1.28
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.27 2016/09/02 15:35:34 renato Exp $ */
d101 1
@


1.27
log
@Close connections when msgbuf_write() returns 0.

Pulled from ospfd. Original author: claudio@@

ok rzalamena@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.26 2016/09/02 15:33:27 renato Exp $ */
d43 1
a43 1
void		 rde_shutdown(void);
a149 1

d153 1
a153 1
void
d158 6
a170 1
	msgbuf_clear(&iev_dvmrpe->ibuf.w);
a171 1
	msgbuf_clear(&iev_main->ibuf.w);
@


1.26
log
@Don't fatal if the imsg pipe is closed, this is often triggered in the
parent and hides the real cause of the termination.

Pulled from ospfd. Original author: claudio@@

ok rzalamena@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.25 2015/12/05 13:11:00 claudio Exp $ */
d212 1
a212 1
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
d214 2
@


1.25
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.24 2014/07/12 19:22:32 krw Exp $ */
d201 1
a201 1
	int			 i, connected = 0, verbose;
d209 1
a209 1
			fatalx("pipe closed");
d328 7
a334 1
	imsg_event_add(iev);
@


1.24
log
@msgbuf_write() <= 0 for a few more daemons.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.23 2013/11/26 11:32:31 henning Exp $ */
d206 1
a206 1
		if ((n = imsg_read(ibuf)) == -1)
d218 1
a218 1
			fatal("rde_dispatch_imsg: imsg_read error");
@


1.23
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.22 2009/11/02 20:31:50 claudio Exp $ */
d212 1
a212 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
@


1.22
log
@Yet another implementation of IMSG_CTL_LOG_VERBOSE. Similar to the one in
ripd, ospfd and friends. OK michele, henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.21 2009/09/06 09:52:14 michele Exp $ */
d212 1
a212 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.21
log
@When dvmrpd receives a prune, it must checks if every downstream member
on that interfaces has already sent prunes. If so (and there are no local groups) removes the interface from the downstream list.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.20 2009/06/06 07:52:04 pyr Exp $ */
d201 1
a201 1
	int			 i, connected = 0;
d315 5
@


1.20
log
@make dvmrpd imsg-in-a-lib ready as well.
``put it in'' claudio@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.19 2009/06/01 23:22:58 henning Exp $ */
d306 1
a307 1

d314 1
@


1.19
log
@no endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.18 2009/05/31 20:31:35 jacekm Exp $ */
d51 2
a52 2
struct imsgbuf		*ibuf_dvmrpe;
struct imsgbuf		*ibuf_main;
d122 2
a123 2
	if ((ibuf_dvmrpe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d125 6
a130 2
	imsg_init(ibuf_dvmrpe, pipe_dvmrpe2rde[1], rde_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2rde[1], rde_dispatch_imsg);
d133 9
a141 9
	ibuf_dvmrpe->events = EV_READ;
	event_set(&ibuf_dvmrpe->ev, ibuf_dvmrpe->fd, ibuf_dvmrpe->events,
	    ibuf_dvmrpe->handler, ibuf_dvmrpe);
	event_add(&ibuf_dvmrpe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d166 4
a169 4
	msgbuf_clear(&ibuf_dvmrpe->w);
	free(ibuf_dvmrpe);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d180 1
a180 1
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
d187 2
a188 1
	return (imsg_compose(ibuf_dvmrpe, type, peerid, pid, data, datalen));
d196 2
a197 1
	struct imsgbuf		*ibuf = bula;
d225 2
a226 2
			imsg_compose(ibuf_dvmrpe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d230 2
a231 2
			imsg_compose(ibuf_dvmrpe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d322 1
a322 1
	imsg_event_add(ibuf);
@


1.18
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.17 2009/05/31 17:13:04 claudio Exp $ */
a105 2

	endpwent();
@


1.17
log
@More libevent callback fixes. While there make n also ssize_t as in all
other daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.16 2009/05/20 16:10:04 michele Exp $ */
a209 1
		imsg_event_add(ibuf);
@


1.16
log
@Whitespaces cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.15 2009/04/16 20:11:12 michele Exp $ */
d197 2
a198 1
	int			 i, n, connected = 0;
d201 1
a201 2
	switch (event) {
	case EV_READ:
d206 2
a207 2
		break;
	case EV_WRITE:
a210 3
		return;
	default:
		fatalx("unknown event");
@


1.15
log
@Notify the rde when a neighbor goes down.
When this happens we have to rebuild the list of downstream
interfaces.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.14 2009/04/11 10:21:20 michele Exp $ */
d277 1
a277 1
				fatalx("invalid size of OE request"); 
d290 1
a290 1
				fatalx("invalid size of OE request"); 
d303 1
a303 1
				fatalx("invalid size of OE request"); 
d410 1
a410 1
	for(rg = TAILQ_FIRST(&iface->rde_group_list); rg != NULL;
@


1.14
log
@When inserting a new route add as downstream interfaces just the ones with
downstream neighbors or group members.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.13 2009/03/14 15:32:55 michele Exp $ */
d196 1
d300 8
@


1.13
log
@Initial support for pruning. When every single interface is removed from the
downstream list for a particular source send a prune to the upstream router.

input and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.12 2009/03/07 12:47:17 michele Exp $ */
d46 2
d259 1
a259 1
				if (mfc.ifindex != iface->ifindex)
d314 24
@


1.12
log
@Get rid of rde_nbr structure as it is no more needed in RDE to make
routing decisions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.11 2009/03/06 18:39:13 michele Exp $ */
d190 1
d298 6
d370 1
d384 6
@


1.11
log
@Make RDE aware of multicast group members per interface. This is needed to
make unicast routing decisions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.10 2009/01/27 08:53:47 michele Exp $ */
a41 6
void		 rde_nbr_init(u_int32_t);
void		 rde_nbr_free(void);
struct rde_nbr	*rde_nbr_find(u_int32_t);
struct rde_nbr	*rde_nbr_new(u_int32_t, struct rde_nbr *);
void		 rde_nbr_del(struct rde_nbr *);

a107 1
	rde_nbr_init(NBR_HASHSIZE);
a160 1
	rde_nbr_free();
a192 1
	struct rde_nbr		 rn;
a270 13
		case IMSG_NEIGHBOR_UP:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rn))
				fatalx("invalid size of OE request"); 
			memcpy(&rn, imsg.data, sizeof(rn));

			if (rde_nbr_new(imsg.hdr.peerid, &rn) == NULL)
				fatalx("rde_dispatch_imsg: "
				    "neighbor already exists");
			break;
		case IMSG_NEIGHBOR_DOWN:
			rde_nbr_del(rde_nbr_find(imsg.hdr.peerid));

			break;
a304 93
}

LIST_HEAD(rde_nbr_head, rde_nbr);

struct nbr_table {
	struct rde_nbr_head	*hashtbl;
	u_int32_t		 hashmask;
} rdenbrtable;

#define RDE_NBR_HASH(x)		\
	&rdenbrtable.hashtbl[(x) & rdenbrtable.hashmask]

void
rde_nbr_init(u_int32_t hashsize)
{
	struct rde_nbr_head	*head;
	u_int32_t		 hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	rdenbrtable.hashtbl = calloc(hs, sizeof(struct rde_nbr_head));
	if (rdenbrtable.hashtbl == NULL)
		fatal("rde_nbr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&rdenbrtable.hashtbl[i]);

	rdenbrtable.hashmask = hs - 1;

	if ((nbrself = calloc(1, sizeof(*nbrself))) == NULL)
		fatal("rde_nbr_init");

	nbrself->peerid = NBR_IDSELF;
	head = RDE_NBR_HASH(NBR_IDSELF);
	LIST_INSERT_HEAD(head, nbrself, hash);
}

void
rde_nbr_free(void)
{
	free(nbrself);
	free(rdenbrtable.hashtbl);
}

struct rde_nbr *
rde_nbr_find(u_int32_t peerid)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr;

	head = RDE_NBR_HASH(peerid);

	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
}

struct rde_nbr *
rde_nbr_new(u_int32_t peerid, struct rde_nbr *new)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr;

	if (rde_nbr_find(peerid))
		return (NULL);

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("rde_nbr_new");

	memcpy(nbr, new, sizeof(*nbr));
	nbr->peerid = peerid;

	head = RDE_NBR_HASH(peerid);
	LIST_INSERT_HEAD(head, nbr, hash);

	return (nbr);
}

void
rde_nbr_del(struct rde_nbr *nbr)
{
	if (nbr == NULL)
		return;

	srt_expire_nbr(nbr->addr, nbr->iface);

	LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);

	free(nbr);
@


1.10
log
@Get rid of the 24h timer as it useless here.
While there fix minor bugs.

ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.9 2009/01/24 16:25:47 michele Exp $ */
d286 1
a286 1
				fatalx("rde_rispatch_imsg: "
d293 26
d420 71
@


1.9
log
@Fix an evil typo.

ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.8 2009/01/20 01:35:34 todd Exp $ */
d168 1
d285 1
a285 1
			if (rde_nbr_find(imsg.hdr.peerid))
a287 1
			rde_nbr_new(imsg.hdr.peerid, &rn);
d291 1
@


1.8
log
@revert earlier commit that broke the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.6 2008/12/02 13:42:44 michele Exp $ */
d284 1
a284 1
			if (rde_nbr_find(imsg.hdr.peerid));
@


1.7
log
@When inserting a new route into the kernel set as
downstream interfaces the ones with neighbors or
group members.

ok norby@@
@
text
@a41 2
void		 rde_ds_iface(struct mfc *, struct iface *, struct rt_node *);

a200 1
	struct rt_node		*r;
d263 3
a265 5
			r = rt_matchorigin(mfc.origin.s_addr);
			if (r == NULL) {
				log_debug("rde_dispatch_imsg: "
				    "packet from unknown origin");
				break;
a267 3
			LIST_FOREACH(iface, &rdeconf->iface_list, entry)
				rde_ds_iface(&mfc, iface, r);

a299 24
}

/* 1) Add interfaces with downstream routers for this
      source.
   2) Add interfaces with member for this group if i am
      the designated forwarder.
*/
void
rde_ds_iface(struct mfc *mfc, struct iface *iface, struct rt_node *r)
{
	if (mfc->ifindex == iface->ifindex) {
		return;
	}

	if (r->ds_cnt[iface->ifindex] != 0) {
		mfc->ttls[iface->ifindex] = 1;
		return;
	}

	if (group_list_find(iface, mfc->group.s_addr) &&
	    r->adv_rtr[iface->ifindex].addr.s_addr == iface->addr.s_addr) {
		mfc->ttls[iface->ifindex] = 1;
		return;
	}
@


1.6
log
@Initial support for neighbor expiry.
When a nbr goes down delete it from the lists of
downstream dependent neighbors.

OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.5 2007/03/21 19:33:48 michele Exp $ */
d42 2
d203 1
d266 5
a270 3
			LIST_FOREACH(iface, &rdeconf->iface_list, entry) {
				if (mfc.ifindex != iface->ifindex)
					mfc.ttls[iface->ifindex] = 1;
d273 3
d308 24
@


1.5
log
@Added code to parse unicast routes learned from route report packets.
Now we are able to select correctly designated forwarders and downstream
dependent routers per interface.

Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.4 2007/01/24 09:57:51 norby Exp $ */
d42 6
d54 1
d114 1
d200 1
d279 13
d300 93
@


1.4
log
@Ignore SIGPIPE in the parent and RDE as well.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.3 2006/12/03 20:14:37 michele Exp $ */
d237 1
a237 1
			if (rde_check_route(&rr, connected) == -1)
@


1.3
log
@introduce rde_check_route that selects which routes must be accepted and which discarded.
Still not complete, just a step forward.

ok norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.2 2006/06/01 21:47:27 claudio Exp $ */
d113 1
@


1.2
log
@Remove some unneeded lint goo and use setres[ug]id() instead of the setuid
dance.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d191 1
a191 2
	int			 n, connected = 0;
	int			 i;
d233 1
a233 1
			if (imsg.hdr.peerid == 0) {
d235 4
a238 4
			}
			rt_update(rr.net, mask2prefixlen(rr.mask.s_addr),
			    rr.nexthop, rr.metric, rr.adv_rtr, rr.ifindex, 0,
			    connected);
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a64 1
		/* NOTREACHED */
a79 1
		/* NOTREACHED */
d100 2
a101 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
a102 1
	}
@

