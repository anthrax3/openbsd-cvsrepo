head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.20
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.12
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.16
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.07.19.14.49;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	AdGyxnW7jQntaErG;

1.9
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.22.16.24.21;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.06.09.52.14;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.13.18.58.46;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.14.15.32.55;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.06.18.39.13;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.03.16.21.19;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.03.20.14.37;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Replace bzero with memset, and change a strings.h include to string.h to
get the declaration. From Serguey Parkhomovsky. No objects from
deraadt@@.
@
text
@/*	$OpenBSD: rde_mfc.c,v 1.9 2011/04/06 11:36:26 miod Exp $ */

/*
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2006 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <stdlib.h>
#include <string.h>

#include "igmp.h"
#include "dvmrp.h"
#include "dvmrpd.h"
#include "log.h"
#include "dvmrpe.h"
#include "rde.h"

/* multicast forwarding cache */

void			 mfc_send_prune(struct rt_node *, struct mfc_node *);
void			 mfc_add_prune(struct mfc_node *, struct prune *);
struct prune_node	*mfc_find_prune(struct mfc_node *, struct prune *);
void			 mfc_delete_prune(struct mfc_node *,
			    struct prune_node *);

int	prune_compare(struct mfc_node *, struct rt_node *, int);
void	prune_expire_timer(int, short, void *);
int	mfc_reset_prune_expire_timer(struct prune_node *);


void	 mfc_expire_timer(int, short, void *);
int	 mfc_start_expire_timer(struct mfc_node *);
int	 mfc_reset_expire_timer(struct mfc_node *);
void	 mfc_prune_timer(int, short, void *);
int	 mfc_start_prune_timer(struct mfc_node *);
int	 mfc_reset_prune_timer(struct mfc_node *);

int	 mfc_compare(struct mfc_node *, struct mfc_node *);
void	 mfc_invalidate(void);

RB_HEAD(mfc_tree, mfc_node)	 mfc;
RB_PROTOTYPE(mfc_tree, mfc_node, entry, mfc_compare)
RB_GENERATE(mfc_tree, mfc_node, entry, mfc_compare)

extern struct dvmrpd_conf	*rdeconf;

/* timers */
void
mfc_expire_timer(int fd, short event, void *arg)
{
	struct mfc_node	*mn = arg;
	struct mfc	 nmfc;

	log_debug("mfc_expire_timer: group %s", inet_ntoa(mn->group));

	/* remove route entry */
	nmfc.origin = mn->origin;
	nmfc.group = mn->group;
	rde_imsg_compose_parent(IMSG_MFC_DEL, 0, &nmfc, sizeof(nmfc));

	event_del(&mn->expiration_timer);
	mfc_remove(mn);
}

int
mfc_reset_expire_timer(struct mfc_node *mn)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = ROUTE_EXPIRATION_TIME;
	return (evtimer_add(&mn->expiration_timer, &tv));
}

int
mfc_start_expire_timer(struct mfc_node *mn)
{
	struct timeval	tv;

	log_debug("mfc_start_expire_timer: group %s", inet_ntoa(mn->group));

	timerclear(&tv);
	tv.tv_sec = ROUTE_EXPIRATION_TIME;
	return (evtimer_add(&mn->expiration_timer, &tv));
}

void
mfc_prune_timer(int fd, short event, void *arg)
{
	struct mfc_node	*mn = arg;

	log_debug("mfc_prune_timer: group %s", inet_ntoa(mn->group));

	event_del(&mn->prune_timer);
}

int
mfc_start_prune_timer(struct mfc_node *mn)
{
	struct timeval	tv;

	log_debug("mfc_start_prune_timer: group %s", inet_ntoa(mn->group));

	timerclear(&tv);
	tv.tv_sec = MAX_PRUNE_LIFETIME;
	return (evtimer_add(&mn->prune_timer, &tv));
}

int
mfc_reset_prune_timer(struct mfc_node *mn)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = MAX_PRUNE_LIFETIME;
	return (evtimer_add(&mn->prune_timer, &tv));
}

/* route table */
void
mfc_init(void)
{
	RB_INIT(&mfc);
}

int
mfc_compare(struct mfc_node *a, struct mfc_node *b)
{
	if (ntohl(a->origin.s_addr) < ntohl(b->origin.s_addr))
		return (-1);
	if (ntohl(a->origin.s_addr) > ntohl(b->origin.s_addr))
		return (1);
	if (ntohl(a->group.s_addr) < ntohl(b->group.s_addr))
		return (-1);
	if (ntohl(a->group.s_addr) > ntohl(b->group.s_addr))
		return (1);
	return (0);
}

struct mfc_node *
mfc_find(in_addr_t origin, in_addr_t group)
{
	struct mfc_node	s;

	s.origin.s_addr = origin;
	s.group.s_addr = group;

	return (RB_FIND(mfc_tree, &mfc, &s));
}

int
mfc_insert(struct mfc_node *m)
{
	if (RB_INSERT(mfc_tree, &mfc, m) != NULL) {
		log_warnx("mfc_insert failed for group %s",
		    inet_ntoa(m->group));
		free(m);
		return (-1);
	}

	return (0);
}

int
mfc_remove(struct mfc_node *m)
{
	if (RB_REMOVE(mfc_tree, &mfc, m) == NULL) {
		log_warnx("mfc_remove failed for group %s",
		    inet_ntoa(m->group));
		return (-1);
	}

	free(m);
	return (0);
}

void
mfc_clear(void)
{
	struct mfc_node	*m;

	while ((m = RB_MIN(mfc_tree, &mfc)) != NULL)
		mfc_remove(m);
}

void
mfc_dump(pid_t pid)
{
	static struct ctl_mfc	 mfcctl;
	struct timespec		 now;
	struct timeval		 tv, now2, res;
	struct mfc_node		*mn;
	int			 i;

	clock_gettime(CLOCK_MONOTONIC, &now);

	RB_FOREACH(mn, mfc_tree, &mfc) {
		mfcctl.origin.s_addr = mn->origin.s_addr;
		mfcctl.group.s_addr = mn->group.s_addr;
		mfcctl.uptime = now.tv_sec - mn->uptime;
		mfcctl.ifindex = mn->ifindex;

		for (i = 0; i < MAXVIFS; i ++) {
			mfcctl.ttls[i] = mn->ttls[i];
		}

		gettimeofday(&now2, NULL);
		if (evtimer_pending(&mn->expiration_timer, &tv)) {
			timersub(&tv, &now2, &res);
			mfcctl.expire = res.tv_sec;
		} else
			mfcctl.expire = -1;

		rde_imsg_compose_dvmrpe(IMSG_CTL_SHOW_MFC, 0, pid, &mfcctl,
		    sizeof(mfcctl));
	}
}

struct rt_node *
mfc_find_origin(struct in_addr group)
{
	struct mfc_node	*mn;

	RB_FOREACH(mn, mfc_tree, &mfc)
		if (group.s_addr == mn->group.s_addr)
			return (rt_match_origin(mn->origin.s_addr));

	return (NULL);
}

void
mfc_send_prune(struct rt_node *rn, struct mfc_node *mn)
{
	struct prune	p;

	memset(&p, 0, sizeof(p));

	p.origin.s_addr = (mn->origin.s_addr &
	    htonl(prefixlen2mask(rn->prefixlen)));
	p.netmask.s_addr = htonl(prefixlen2mask(rn->prefixlen));
	p.group.s_addr = mn->group.s_addr;
	p.nexthop.s_addr = rn->nexthop.s_addr;
	p.ifindex = mn->ifindex;

	rde_imsg_compose_dvmrpe(IMSG_SEND_PRUNE, 0, 0, &p, sizeof(p));

	mfc_start_prune_timer(mn);
}

void
mfc_update_source(struct rt_node *rn)
{
	struct mfc_node		*mn;
	struct mfc		 m;
	int			 i;
	u_int8_t		 found;

	RB_FOREACH(mn, mfc_tree, &mfc) {
		if (rn->prefix.s_addr == (mn->origin.s_addr &
		    htonl(prefixlen2mask(rn->prefixlen)))) {
			mn->ifindex = rn->ifindex;

			found = 0;

			for (i = 0; i < MAXVIFS; i++) {
				mn->ttls[i] = rn->ttls[i];
				if (mn->ttls[i] != 0)
					found = 1;
			}

			m.origin.s_addr = mn->origin.s_addr;
			m.group.s_addr = mn->group.s_addr;
			m.ifindex = mn->ifindex;

			for (i = 0; i < MAXVIFS; i++)
				m.ttls[i] = mn->ttls[i];

			rde_imsg_compose_parent(IMSG_MFC_ADD, 0, &m, sizeof(m));

			mfc_reset_expire_timer(mn);

			if (!found && !rn->connected)
				mfc_send_prune(rn, mn);
		}
	}
}

void
mfc_update(struct mfc *nmfc)
{
	struct mfc_node		*mn;
	struct rt_node		*rn;
	struct timespec		 now;
	int			 i;
	u_int8_t		 found = 0;

	clock_gettime(CLOCK_MONOTONIC, &now);

	if ((mn = mfc_find(nmfc->origin.s_addr, nmfc->group.s_addr)) == NULL) {
		if ((mn = calloc(1, sizeof(struct mfc_node))) == NULL)
			fatalx("mfc_update");

		mn->origin.s_addr = nmfc->origin.s_addr;
		mn->group.s_addr = nmfc->group.s_addr;
		mn->ifindex = nmfc->ifindex;
		mn->uptime = now.tv_sec;
		for (i = 0; i < MAXVIFS; i++) {
			mn->ttls[i] = nmfc->ttls[i];
			if (mn->ttls[i] != 0)
				found = 1;
		}

		if (mfc_insert(mn) == 0) {
			rde_imsg_compose_parent(IMSG_MFC_ADD, 0, nmfc,
			    sizeof(*nmfc));
		}

		evtimer_set(&mn->expiration_timer, mfc_expire_timer, mn);
		evtimer_set(&mn->prune_timer, mfc_expire_timer, mn);
		mfc_start_expire_timer(mn);

		if (!found) {
			/* We removed all downstream interfaces,
			   start the pruning process */
			rn = rt_match_origin(mn->origin.s_addr);
			if (rn == NULL) {
				fatal("mfc_update: cannot find information "
				    " about source");
			}

			mfc_send_prune(rn, mn);
		}
	}
}

void
mfc_delete(struct mfc *nmfc)
{
	struct mfc_node	*mn;

	if ((mn = mfc_find(nmfc->origin.s_addr, nmfc->group.s_addr)) == NULL)
		return;

	/* XXX decide if it should really be removed */
	mfc_remove(mn);

	/* XXX notify parent */
}

int
mfc_check_members(struct rt_node *rn, struct iface *iface)
{
	struct mfc_node		*mn;

	RB_FOREACH(mn, mfc_tree, &mfc) {
		if (mn->origin.s_addr == rn->prefix.s_addr) {
			if (rde_group_list_find(iface, mn->group) != 0)
				return (1);
		}
	}

	return (0);
}

void
mfc_recv_prune(struct prune *p)
{
	struct rt_node		*rn;
	struct mfc_node		*mn;
	struct prune_node	*pn;
	struct iface		*iface;
	struct mfc		 m;

	iface = if_find_index(p->ifindex);
	if (iface == NULL) {
		log_debug("mfc_recv_prune: unknown interface");
		return;
	}

	rn = rt_match_origin(p->origin.s_addr);
	if (rn == NULL) {
		log_debug("mfc_recv_prune: no information for %s\n",
		    inet_ntoa(p->origin));
		return;
	}

	if (srt_find_ds(rn, p->nexthop.s_addr) == NULL) {
		log_debug("mfc_recv_prune: prune received from a "
		    "non downstream neighbor\n");
		return;
	}

	mn = mfc_find(p->origin.s_addr, p->group.s_addr);
	if (mn) {
		log_debug("mfc_recv_prune: no information for %s\n",
		    inet_ntoa(p->origin));
		return;
	}

	pn = mfc_find_prune(mn, p);
	if (pn == NULL) {
		mfc_add_prune(mn, p);
		if (prune_compare(mn, rn, p->ifindex) &&
		    !rde_group_list_find(iface, p->group)) {
			mn->ttls[p->ifindex] = 0;

			m.ifindex = p->ifindex;
			m.origin.s_addr = p->origin.s_addr;
			m.group.s_addr = p->group.s_addr;
			mfc_update(&m);
		}
	} else
		mfc_reset_prune_expire_timer(pn);
}

void
mfc_add_prune(struct mfc_node *mn, struct prune *p)
{
	struct prune_node	*pn;
	struct timeval		 tv;

	pn = calloc(1, sizeof(struct prune));
	if (pn == NULL)
		fatal("prune_add");

	timerclear(&tv);
	tv.tv_sec = MAX_PRUNE_LIFETIME;

	pn->nbr.s_addr = p->nexthop.s_addr;
	pn->ifindex = p->ifindex;
	pn->parent = mn;

	evtimer_set(&pn->lifetime_timer, prune_expire_timer, pn);
	evtimer_add(&pn->lifetime_timer, &tv);

	LIST_INSERT_HEAD(&mn->prune_list, pn, entry);

	mn->prune_cnt[p->ifindex]++;
}

struct prune_node *
mfc_find_prune(struct mfc_node *mn, struct prune *p)
{
	struct prune_node	*pn;

	LIST_FOREACH(pn, &mn->prune_list, entry) {
		if (p->nexthop.s_addr == pn->nbr.s_addr)
			return (pn);
	}

	return (NULL);
}

void
mfc_delete_prune(struct mfc_node *mn, struct prune_node *pn)
{
	unsigned int	ifindex = pn->ifindex;

	if (evtimer_pending(&pn->lifetime_timer, NULL))
		if (evtimer_del(&pn->lifetime_timer) == -1)
			fatal("mfc_delete_prune");

	LIST_REMOVE(pn, entry);
	free(pn);
	mn->prune_cnt[ifindex]--;
}

int
prune_compare(struct mfc_node *mn, struct rt_node *rn, int ifindex)
{
	if (mn->prune_cnt[ifindex] == rn->ds_cnt[ifindex])
		return (1);

	return (0);
}

int
mfc_reset_prune_expire_timer(struct prune_node *pn)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = MAX_PRUNE_LIFETIME;

	return (evtimer_add(&pn->lifetime_timer, &tv));
}

void
prune_expire_timer(int fd, short event, void *arg)
{
	struct prune_node	*pn = arg;

	LIST_REMOVE(pn, entry);

	pn->parent->prune_cnt[pn->ifindex]--;
	pn->parent->ttls[pn->ifindex] = 1;

	free(pn);
}
@


1.9
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.8 2009/09/22 16:24:21 michele Exp $ */
d254 1
a254 1
	bzero(&p, sizeof(p));
@


1.8
log
@Whitespaces fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.7 2009/09/06 09:52:14 michele Exp $ */
d375 1
a375 2
			if (rde_group_list_find(iface, mn->group)
			    != NULL)
@


1.7
log
@When dvmrpd receives a prune, it must checks if every downstream member
on that interfaces has already sent prunes. If so (and there are no local groups) removes the interface from the downstream list.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.6 2009/07/13 18:58:46 michele Exp $ */
d38 1
a38 1
void	 		 mfc_send_prune(struct rt_node *, struct mfc_node *);
d387 5
a391 5
       struct rt_node		*rn;
       struct mfc_node		*mn;
       struct prune_node	*pn;
       struct iface		*iface;
       struct mfc		 m;
d492 1
a492 1
       
@


1.6
log
@If there are no downstream members for a particular prefix, send a prune
upstream.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.5 2009/03/14 15:32:55 michele Exp $ */
d38 10
a47 1
void	 mfc_send_prune(struct rt_node *, struct mfc_node *);
d382 136
@


1.5
log
@Initial support for pruning. When every single interface is removed from the
downstream list for a particular source send a prune to the upstream router.

input and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.4 2009/03/06 18:39:13 michele Exp $ */
d38 2
d241 19
a263 1
	struct prune		 p;
d268 2
a269 1
		if (rn->prefix.s_addr == mn->origin.s_addr) {
d291 2
a292 17
			if (!found) {
				/* We have removed all downstream interfaces,
				   start the pruning process */
				bzero(&p, sizeof(p));

				p.origin.s_addr = mn->origin.s_addr;
				p.netmask.s_addr =
				    prefixlen2mask(rn->prefixlen);
				p.group.s_addr = mn->group.s_addr;
				p.nexthop.s_addr = rn->nexthop.s_addr;
				p.ifindex = mn->ifindex;

				rde_imsg_compose_dvmrpe(IMSG_SEND_PRUNE, 0, 0,
				    &p, sizeof(p));

				mfc_start_prune_timer(mn);
			}
d300 2
a302 1
	struct mfc_node		*mn;
d304 1
d316 1
a316 1
		for (i = 0; i < MAXVIFS; i++)
d318 3
d330 12
@


1.4
log
@Make RDE aware of multicast group members per interface. This is needed to
make unicast routing decisions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.3 2009/02/03 16:21:19 michele Exp $ */
d4 1
d27 1
a37 1
void	 mfc_invalidate(void);
d41 4
d46 1
d94 32
d226 12
d243 1
d245 1
d251 3
a253 1
			for (i = 0; i < MAXVIFS; i++)
d255 3
d266 1
a266 3
			if (mn->origin.s_addr != 0)
				rde_imsg_compose_parent(IMSG_MFC_ADD, 0, &m,
				    sizeof(m));
d269 18
d312 2
a313 3
			if (nmfc->origin.s_addr != 0)
				rde_imsg_compose_parent(IMSG_MFC_ADD, 0, nmfc,
				    sizeof(*nmfc));
d317 1
@


1.3
log
@Correctly update kernel and mfc when change in routing table happens.

ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.2 2006/12/03 20:14:37 michele Exp $ */
d261 16
@


1.2
log
@introduce rde_check_route that selects which routes must be accepted and which discarded.
Still not complete, just a step forward.

ok norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_mfc.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d39 1
d67 10
d81 2
d185 30
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a29 1
#include "rde.h"
d32 1
@

