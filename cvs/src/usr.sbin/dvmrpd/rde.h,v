head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.28
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.24
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.26
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.3.0.6
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2009.09.06.09.52.14;	author michele;	state Exp;
branches;
next	1.15;

1.15
date	2009.04.16.20.11.12;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.14.19.27.43;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.14.15.32.55;	author michele;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.07.12.47.17;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.06.18.39.13;	author michele;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.03.16.21.19;	author michele;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.20.01.35.34;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.19.20.40.31;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.07.16.37.04;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.02.13.42.44;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.24.21.55.52;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.21.20.20.00;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.21.19.33.48;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.03.20.14.37;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.16
log
@When dvmrpd receives a prune, it must checks if every downstream member
on that interfaces has already sent prunes. If so (and there are no local groups) removes the interface from the downstream list.

ok claudio@@
@
text
@/*	$OpenBSD: rde.h,v 1.15 2009/04/16 20:11:12 michele Exp $ */

/*
 * Copyright (c) 2005, 2006 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _RDE_H_
#define _RDE_H_

#include <sys/types.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <event.h>
#include <limits.h>

struct adv_rtr {
	struct in_addr		 addr;
	u_int8_t		 metric;
};

struct rt_node {
	RB_ENTRY(rt_node)	 entry;
	struct event		 expiration_timer;
	struct event		 holddown_timer;

	struct adv_rtr		 adv_rtr[MAXVIFS];

	u_int16_t		 ds_cnt[MAXVIFS];
	u_int8_t		 ttls[MAXVIFS];	/* downstream vif(s) */

	LIST_HEAD(, ds_nbr)	 ds_list;

	struct in_addr		 prefix;
	struct in_addr		 nexthop;
	time_t			 uptime;

	u_short			 ifindex;	/* learned from this iface */

	u_int8_t		 cost;
	u_int8_t		 old_cost;	/* used when in hold-down */
	u_int8_t		 flags;
	u_int8_t		 prefixlen;
	u_int8_t		 invalid;
	u_int8_t		 connected;
};

struct prune_node {
	LIST_ENTRY(prune_node)	 entry;
	struct event		 lifetime_timer;

	struct mfc_node		*parent;	/* back ptr to mfc_node */

	struct in_addr		 nbr;
	unsigned int		 ifindex;
};

struct mfc_node {
	RB_ENTRY(mfc_node)	 entry;
	struct event		 expiration_timer;
	struct event		 prune_timer;

	LIST_HEAD(, prune_node)	 prune_list;

	struct in_addr		 origin;
	struct in_addr		 group;
	time_t			 uptime;
	u_short			 ifindex;		/* incoming vif */
	u_int8_t		 ttls[MAXVIFS];		/* outgoing vif(s) */
	u_int8_t		 prune_cnt[MAXVIFS];
};

/* downstream neighbor per source */
struct ds_nbr {
	LIST_ENTRY(ds_nbr)	 entry;
	struct in_addr		 addr;
};

/* rde.c */
pid_t	rde(struct dvmrpd_conf *, int [2], int [2], int [2]);
int	rde_imsg_compose_parent(int, pid_t, void *, u_int16_t);
int	rde_imsg_compose_dvmrpe(int, u_int32_t, pid_t, void *, u_int16_t);

void	rde_group_list_add(struct iface *, struct in_addr);
int	rde_group_list_find(struct iface *, struct in_addr);
void	rde_group_list_remove(struct iface *, struct in_addr);

/* rde_mfc.c */
void		 mfc_init(void);
int		 mfc_compare(struct mfc_node *, struct mfc_node *);
struct mfc_node *mfc_find(in_addr_t, in_addr_t);
int		 mfc_insert(struct mfc_node *);
int		 mfc_remove(struct mfc_node *);
void		 mfc_clear(void);
void		 mfc_dump(pid_t);
void		 mfc_update(struct mfc *);
void		 mfc_delete(struct mfc *);
struct rt_node	*mfc_find_origin(struct in_addr);
void		 mfc_update_source(struct rt_node *);
int		 mfc_check_members(struct rt_node *, struct iface *);
void		 mfc_recv_prune(struct prune *);

/* rde_srt.c */
void		 rt_init(void);
int		 rt_compare(struct rt_node *, struct rt_node *);
struct rt_node	*rt_find(in_addr_t, u_int8_t);
struct rt_node	*rr_new_rt(struct route_report *, u_int32_t, int);
int		 rt_insert(struct rt_node *);
void		 rt_update(struct rt_node *);
int		 rt_remove(struct rt_node *);
void		 rt_clear(void);
void		 rt_snap(u_int32_t);
void		 rt_dump(pid_t);
struct rt_node	*rt_match_origin(in_addr_t);

int		 srt_check_route(struct route_report *, int);
int		 src_compare(struct src_node *, struct src_node *);

struct ds_nbr	*srt_find_ds(struct rt_node *, u_int32_t);
void		 srt_expire_nbr(struct in_addr, unsigned int);
void		 srt_check_downstream_ifaces(struct rt_node *, struct iface *);

RB_PROTOTYPE(src_head, src_node, entry, src_compare);

#endif	/* _RDE_H_ */
@


1.15
log
@Notify the rde when a neighbor goes down.
When this happens we have to rebuild the list of downstream
interfaces.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.14 2009/04/14 19:27:43 michele Exp $ */
d60 10
d74 3
d80 3
a82 2
	u_short			 ifindex;	/* incoming vif */
	u_int8_t		 ttls[MAXVIFS];	/* outgoing vif(s) */
d113 1
d131 1
@


1.14
log
@Route costs can be safely stored in one byte.
While there re order structs fields a little bit.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.13 2009/03/14 15:32:55 michele Exp $ */
d116 1
a116 1
void		 srt_expire_nbr(struct in_addr, struct iface *);
@


1.13
log
@Initial support for pruning. When every single interface is removed from the
downstream list for a particular source send a prune to the upstream router.

input and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.12 2009/03/07 12:47:17 michele Exp $ */
d31 1
a31 1
	u_int32_t		 metric;
d38 4
d43 3
d48 2
a49 2
	u_int32_t		 cost;
	u_int32_t		 old_cost;	/* used when in hold-down */
d51 3
a53 4
	struct adv_rtr		 adv_rtr[MAXVIFS];
	u_int16_t		 ds_cnt[MAXVIFS];
	LIST_HEAD(, ds_nbr)	 ds_list;
	time_t			 uptime;
a63 1
	u_int8_t		 ttls[MAXVIFS];	/* outgoing vif(s) */
d66 1
d68 1
a68 1
	time_t			 uptime;
@


1.12
log
@Get rid of rde_nbr structure as it is no more needed in RDE to make
routing decisions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.11 2009/03/06 18:39:13 michele Exp $ */
d57 1
d90 1
d105 1
d111 1
@


1.11
log
@Make RDE aware of multicast group members per interface. This is needed to
make unicast routing decisions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.10 2009/02/03 16:21:19 michele Exp $ */
a61 9
};

/* just the infos rde needs */
struct rde_nbr {
	LIST_ENTRY(rde_nbr)	 entry, hash;
	struct in_addr		 addr;
	u_int32_t		 peerid;

	struct iface		*iface;
@


1.10
log
@Correctly update kernel and mfc when change in routing table happens.

ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.9 2009/01/20 01:35:34 todd Exp $ */
d84 4
d99 1
@


1.9
log
@revert earlier commit that broke the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.7 2008/12/07 16:37:04 michele Exp $ */
d94 1
@


1.8
log
@When inserting a new route into the kernel set as
downstream interfaces the ones with neighbors or
group members.

ok norby@@
@
text
@a98 1
struct rt_node	*rt_matchorigin(in_addr_t);
@


1.7
log
@Kill src_node structure. It is mostly redundant with rt_node and
adds unneeded complexity. Move any stuff to rt_node structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.6 2008/12/02 13:42:44 michele Exp $ */
d99 1
@


1.6
log
@Initial support for neighbor expiry.
When a nbr goes down delete it from the lists of
downstream dependent neighbors.

OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.5 2008/11/24 21:55:52 michele Exp $ */
d29 5
d44 3
d73 3
a75 2
struct ds {
	LIST_ENTRY(ds)		 entry;
a76 14
};

struct adv_rtr {
	struct in_addr		 addr;
	u_int32_t		 metric;
};

struct src_node {
	RB_ENTRY(src_node)	 entry;
	struct in_addr		 origin;
	struct in_addr		 mask;
	struct adv_rtr		 adv_rtr[MAXVIFS];
	u_int16_t		 ds_cnt[MAXVIFS];
	LIST_HEAD(, ds)		 ds_list;
@


1.5
log
@Introduce support for route hold down.
When a route is deleted we must continue advertising it with
a metric of infinity to avoid routing loops.

OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.4 2008/10/21 20:20:00 michele Exp $ */
d56 9
d114 2
@


1.4
log
@Code cleanup. No functional change.

OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.3 2007/03/21 19:33:48 michele Exp $ */
d32 1
d37 1
@


1.3
log
@Added code to parse unicast routes learned from route report packets.
Now we are able to select correctly designated forwarders and downstream
dependent routers per interface.

Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.2 2006/12/03 20:14:37 michele Exp $ */
d93 1
a93 1
struct rt_node	*rr_new_rt(struct route_report *, int, int);
@


1.2
log
@introduce rde_check_route that selects which routes must be accepted and which discarded.
Still not complete, just a step forward.

ok norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d32 1
a34 1
	struct in_addr		 adv_rtr;
d54 19
d100 5
a104 1
int		 rde_check_route(struct route_report *, int);
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d74 1
d76 1
d81 1
a81 2
void		 rt_update(struct in_addr, u_int8_t, struct in_addr,
		     u_int32_t, struct in_addr, u_short, u_int8_t, u_int8_t);
@

