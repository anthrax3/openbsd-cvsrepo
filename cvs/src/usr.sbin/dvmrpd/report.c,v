head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.20
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.18
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.14
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.12
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.10
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2015.12.07.18.59.31;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	ftjgRJKACMjEVqNx;

1.10
date	2015.05.05.01.26.37;	author jsg;	state Exp;
branches;
next	1.9;
commitid	t9z5FiHTkQbSNv6Z;

1.9
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.8;
commitid	2uw1UTO4k6erpWzK;

1.8
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.10.09.37.25;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.03.20.14.37;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.10.11.15.32;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.10.11.09.56;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.17.16.53.33;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.02.15.43.16;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.11
log
@strings.h -> string.h to prevent implicit declarations. From Serguey
Parkhomovsky.
@
text
@/*	$OpenBSD: report.c,v 1.10 2015/05/05 01:26:37 jsg Exp $ */

/*
 * Copyright (c) 2005, 2006 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <string.h>

#include "igmp.h"
#include "dvmrpd.h"
#include "dvmrp.h"
#include "dvmrpe.h"
#include "log.h"

extern struct dvmrpd_conf	*deconf;

void	 rr_list_remove(struct route_report *);

/* DVMRP report packet handling */
int
send_report(struct iface *iface, struct in_addr addr, void *data, int len)
{
	struct sockaddr_in	 dst;
	struct ibuf		*buf;
	struct dvmrp_hdr	*dvmrp_hdr;
	int			 ret = 0;

	log_debug("send_report: interface %s addr %s",
	    iface->name, inet_ntoa(addr));

	if (iface->passive)
		return (0);

	if ((buf = ibuf_open(iface->mtu - sizeof(struct ip))) == NULL)
		fatal("send_report");

	/* DVMRP header */
	if (gen_dvmrp_hdr(buf, iface, DVMRP_CODE_REPORT))
		goto fail;

	ibuf_add(buf, data, len);

	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);
	dst.sin_addr.s_addr = addr.s_addr;

	/* update chksum */
	dvmrp_hdr = ibuf_seek(buf, 0, sizeof(*dvmrp_hdr));
	dvmrp_hdr->chksum = in_cksum(buf->buf, buf->wpos);

	ret = send_packet(iface, buf->buf, buf->wpos, &dst);
	ibuf_free(buf);
	return (ret);
fail:
	log_warn("send_report");
	ibuf_free(buf);
	return (-1);
}

void
recv_report(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct route_report	 rr;
	u_int32_t		 netid, netmask;
	u_int8_t		 metric, netid_len, prefixlen;

	log_debug("recv_report: neighbor ID %s", inet_ntoa(nbr->id));

	if ((nbr->state != NBR_STA_2_WAY) && (!nbr->compat)) {
		log_warnx("recv_report: neighbor %s not in state %s",
		    inet_ntoa(nbr->id), "2-WAY");
		return;
	}

	/* parse route report */
	do {
		/*
		 * get netmask
		 *
		 * The netmask in a DVMRP report is only represented by 3 bytes,
		 * to cope with that we read 4 bytes and shift 8 bits.
		 * The most significant part of the mask is always 255.
		 */

		/* read four bytes */
		memcpy(&netmask, buf, sizeof(netmask));
		/* ditch one byte, since we only need three */
		netmask = ntohl(netmask) >> 8;
		netmask = htonl(netmask);

		/* set the highest byte to 255 */
		netmask |= htonl(0xff000000);
		buf += 3;
		len -= 3;

		prefixlen = mask2prefixlen(netmask);
		netid_len = PREFIX_SIZE(prefixlen);

		do {
			/*
			 * get netid
			 *
			 * The length of the netid is depending on the above
			 * netmask.
			 * Read 4 bytes and use the netmask from above to
			 * determine the netid.
			 */
			memcpy(&netid, buf, sizeof(netid));
			netid &= netmask;

			buf += netid_len;
			len -= netid_len;

			/* get metric */
			memcpy(&metric, buf, sizeof(metric));
			buf += sizeof(metric);
			len -= sizeof(metric);

			rr.net.s_addr = netid;
			rr.mask.s_addr = netmask;
			rr.nexthop = nbr->id;
			rr.metric = (metric & METRIC_MASK);

			/* ifindex */
			rr.ifindex = nbr->iface->ifindex;

			/* send route report to RDE */
			dvmrpe_imsg_compose_rde(IMSG_ROUTE_REPORT, nbr->peerid,
			    0, &rr, sizeof(rr));

		} while (!(metric & LAST_MASK) && (len > 0));
	} while (len > 0);

	return;
}

/* timers */
void
report_timer(int fd, short event, void *arg)
{
	struct timeval		 tv;

	/* request full route report */
	dvmrpe_imsg_compose_rde(IMSG_FULL_ROUTE_REPORT, 0, 0, NULL, 0);

	/* restart report timer */
	timerclear(&tv);
	tv.tv_sec = ROUTE_REPORT_INTERVAL;
	evtimer_add(&deconf->report_timer, &tv);
}

int
start_report_timer(void)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = MIN_FLASH_UPDATE_INTERVAL;	/* XXX safe?? */
	return (evtimer_add(&deconf->report_timer, &tv));
}

int
stop_report_timer(void)
{
	return (evtimer_del(&deconf->report_timer));
}

/* route report list */
void
rr_list_add(struct rr_head *rr_list, struct route_report *rr)
{
	struct rr_entry		*le;

	if (rr == NULL)
		fatalx("rr_list_add: no route report");

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("rr_list_add");

	TAILQ_INSERT_TAIL(rr_list, le, entry);
	le->re = rr;
	rr->refcount++;
}

void
rr_list_remove(struct route_report *rr)
{
	if (--rr->refcount == 0)
		free(rr);
}

void
rr_list_clr(struct rr_head *rr_list)
{
	struct rr_entry		*le;

	while ((le = TAILQ_FIRST(rr_list)) != NULL) {
		TAILQ_REMOVE(rr_list, le, entry);
		rr_list_remove(le->re);
		free(le);
	}
}

void
rr_list_send(struct rr_head *rr_list, struct iface *xiface, struct nbr *nbr)
{
	struct rr_entry		*le, *le2;
	struct ibuf		*buf;
	struct iface		*iface;
	struct in_addr		 addr;
	u_int32_t		 netid, netmask;
	u_int8_t		 metric, netid_len, prefixlen;

	/* set destination */
	if (xiface == NULL) {
		/* directly to a nbr */
		iface = nbr->iface;
		addr = nbr->addr;
	} else {
		/* multicast on interface */
		iface = xiface;
		inet_aton(AllDVMRPRouters, &addr);
	}

	while (!TAILQ_EMPTY(rr_list)) {
		if ((buf = ibuf_open(iface->mtu - sizeof(struct ip))) == NULL)
			fatal("rr_list_send");

		prefixlen = 0;
		while (((le = TAILQ_FIRST(rr_list)) != NULL) &&
		    (buf->wpos < 1000)) {
			/* netmask */
			netmask = le->re->mask.s_addr;
			if (prefixlen != mask2prefixlen(netmask)) {
				prefixlen = mask2prefixlen(netmask);
				netmask = ntohl(netmask) << 8;
				netmask = htonl(netmask);
				ibuf_add(buf, &netmask, 3);
			}
			netid_len = PREFIX_SIZE(prefixlen);

			/* netid */
			netid = le->re->net.s_addr;
			ibuf_add(buf, &netid, netid_len);

			/* metric */
			if (iface->ifindex == le->re->ifindex)
				/* poison reverse */
				metric = le->re->metric + INFINITY_METRIC;
			else
				metric = le->re->metric;

			/*
			 * determine if we need to flag last entry with current
			 * netmask.
			 */
			le2 = TAILQ_NEXT(le, entry);
			if (le2 != NULL) {
				if (mask2prefixlen(le2->re->mask.s_addr) !=
				    prefixlen)
					metric = metric | LAST_MASK;
			} else {
				metric = metric | LAST_MASK;
			}

			ibuf_add(buf, &metric, sizeof(metric));

			TAILQ_REMOVE(rr_list, le, entry);
			rr_list_remove(le->re);
			free(le);
		}
		send_report(iface, addr, buf->buf, buf->wpos);
		ibuf_free(buf);
	}
}
@


1.10
log
@use the sizeof the struct not the sizeof a pointer to the struct
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.9 2014/10/25 03:23:49 lteo Exp $ */
d26 1
a26 1
#include <strings.h>
@


1.9
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.8 2010/05/26 13:56:07 nicm Exp $ */
d67 1
a67 1
	dvmrp_hdr = ibuf_seek(buf, 0, sizeof(dvmrp_hdr));
@


1.8
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.7 2007/04/10 09:37:25 michele Exp $ */
a21 1
#include <netinet/in_systm.h>
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.6 2006/12/03 20:14:37 michele Exp $ */
d44 1
a44 1
	struct buf		*buf;
d54 1
a54 1
	if ((buf = buf_open(iface->mtu - sizeof(struct ip))) == NULL)
d61 1
a61 1
	buf_add(buf, data, len);
d68 1
a68 1
	dvmrp_hdr = buf_seek(buf, 0, sizeof(dvmrp_hdr));
d72 1
a72 1
	buf_free(buf);
d76 1
a76 1
	buf_free(buf);
d228 1
a228 1
	struct buf		*buf;
d246 1
a246 1
		if ((buf = buf_open(iface->mtu - sizeof(struct ip))) == NULL)
d258 1
a258 1
				buf_add(buf, &netmask, 3);
d264 1
a264 1
			buf_add(buf, &netid, netid_len);
d286 1
a286 1
			buf_add(buf, &metric, sizeof(metric));
d293 1
a293 1
		buf_free(buf);
@


1.6
log
@introduce rde_check_route that selects which routes must be accepted and which discarded.
Still not complete, just a step forward.

ok norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.5 2006/11/10 11:15:32 michele Exp $ */
d210 1
a210 1
} 
d219 1
a219 1
		rr_list_remove(le->re);	
@


1.5
log
@In report packet parsing, interpret 0.0.0.0/8 as 0.0.0.0/0.

OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.4 2006/11/10 11:09:56 michele Exp $ */
a130 4
			/* Interpret special case 0.0.0.0/8 as 0.0.0.0/0 */
			if (netid == 0)
				netmask = 0;

d142 1
a142 2
			/* adjusted metric */
			rr.metric = (metric & METRIC_MASK) + nbr->iface->metric;
@


1.4
log
@introduce reference count for struct route_report so it can be shared and
freed correctly.

OK norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.3 2006/06/17 16:53:33 norby Exp $ */
a104 2
		/* XXX handle special case 0.0.0.0/0 */

d112 1
a112 1
		netmask = netmask | htonl(0xff000000);
d129 6
a134 1
			netid = netid & netmask;
@


1.3
log
@make dvmrpd(8) behave correctly on sparc64 when generating and parsing
route reports.

help from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.2 2006/06/02 15:43:16 norby Exp $ */
d37 1
a37 1
void	 rr_list_remove(struct rr_head *, struct route_report *);
d204 1
d208 7
d221 1
a221 1
		free(le->re);
a289 1
			/* XXX rr_list_remove */
d291 1
a291 1
			/* XXX free(le->re); */
@


1.2
log
@simplify netid_len calculation, inspired by stuff from bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: report.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d110 3
a112 1
		netmask = netmask << 8;
d250 2
a251 1
				netmask = netmask >> 8;
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a115 1
		netid_len = 0;
d117 1
a117 8
		if (prefixlen > 0)
			netid_len = 1;
		if (prefixlen > 8)
			netid_len = 2;
		if (prefixlen > 16)
			netid_len = 3;
		if (prefixlen > 24)
			netid_len = 4;
d251 1
a251 10

			netid_len = 0;
			if (prefixlen > 0)
				netid_len = 1;
			if (prefixlen > 8)
				netid_len = 2;
			if (prefixlen > 16)
				netid_len = 3;
			if (prefixlen > 24)
				netid_len = 4;
@

