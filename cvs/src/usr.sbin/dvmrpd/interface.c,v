head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.20
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.12
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.16
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2015.09.27.17.29.46;	author stsp;	state Exp;
branches;
next	1.10;
commitid	4R1EROmhJjzhK6EW;

1.10
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.22.16.43.42;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.06.18.39.13;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.20.01.35.34;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.19.20.40.31;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.11.18.23.05;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.03.20.14.37;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.02.17.06.50;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.01.18.18.25;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.11
log
@As done for bgpd recently, rename if_mediatype to if_type in dvrmpd.
Remove unused function get_ifms_type(). No ifmedia in here anymore.
"move forward" deraadt@@
@
text
@/*	$OpenBSD: interface.c,v 1.10 2011/07/04 04:34:14 claudio Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2006 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip_mroute.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_types.h>

#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <event.h>

#include "igmp.h"
#include "dvmrpd.h"
#include "dvmrp.h"
#include "log.h"
#include "dvmrpe.h"

extern struct dvmrpd_conf	*conf;

void	 if_probe_timer(int, short, void *);
int	 if_start_probe_timer(struct iface *);
int	 if_stop_probe_timer(struct iface *);
void	 if_query_timer(int, short, void *);
int	 if_start_query_timer(struct iface *);
int	 if_stop_query_timer(struct iface *);
void	 if_querier_present_timer(int, short, void *);
int	 if_start_querier_present_timer(struct iface *);
int	 if_stop_querier_present_timer(struct iface *);
int	 if_reset_querier_present_timer(struct iface *);
int	 if_act_start(struct iface *);
int	 if_act_query_seen(struct iface *);
int	 if_act_reset(struct iface *);

struct {
	int			state;
	enum iface_event	event;
	enum iface_action	action;
	int			new_state;
} iface_fsm[] = {
    /* current state	event that happened	action to take	resulting state */
    {IF_STA_DOWN,	IF_EVT_UP,		IF_ACT_STRT,	0},
    {IF_STA_ACTIVE,	IF_EVT_QRECVD,		IF_ACT_QPRSNT,	0},
    {IF_STA_NONQUERIER, IF_EVT_QPRSNTTMOUT,	IF_ACT_STRT,	0},
    {IF_STA_ANY,	IF_EVT_DOWN,		IF_ACT_RST,	IF_STA_DOWN},
    {-1,		IF_EVT_NOTHING,		IF_ACT_NOTHING,	0},
};

const char * const if_action_names[] = {
	"NOTHING",
	"START",
	"QPRSNT",
	"RESET"
};

static const char * const if_event_names[] = {
	"NOTHING",
	"UP",
	"QTMOUT",
	"QRECVD",
	"QPRSNTTMOUT",
	"DOWN"
};

int
if_fsm(struct iface *iface, enum iface_event event)
{
	int	old_state;
	int	new_state = 0;
	int	i, ret = 0;

	old_state = iface->state;

	for (i = 0; iface_fsm[i].state != -1; i++)
		if ((iface_fsm[i].state & old_state) &&
		    (iface_fsm[i].event == event)) {
			new_state = iface_fsm[i].new_state;
			break;
		}

	if (iface_fsm[i].state == -1) {
		/* XXX event outside of the defined fsm, ignore it. */
		log_debug("fsm_if: interface %s, "
		    "event '%s' not expected in state '%s'", iface->name,
		    if_event_name(event), if_state_name(old_state));
		return (0);
	}

	switch (iface_fsm[i].action) {
	case IF_ACT_STRT:
		ret = if_act_start(iface);
		break;
	case IF_ACT_QPRSNT:
		ret = if_act_query_seen(iface);
		break;
	case IF_ACT_RST:
		ret = if_act_reset(iface);
		break;
	case IF_ACT_NOTHING:
		/* do nothing */
		break;
	}

	if (ret) {
		log_debug("fsm_if: error changing state for interface %s, "
		    "event '%s', state '%s'", iface->name, if_event_name(event),
		    if_state_name(old_state));
		return (-1);
	}

	if (new_state != 0)
		iface->state = new_state;

	log_debug("fsm_if: event '%s' resulted in action '%s' and changing "
	    "state for interface %s from '%s' to '%s'",
	    if_event_name(event), if_action_name(iface_fsm[i].action),
	    iface->name, if_state_name(old_state), if_state_name(iface->state));

	return (ret);
}

struct iface *
if_find_index(u_short ifindex)
{
	struct iface	*iface;

	LIST_FOREACH(iface, &conf->iface_list, entry) {
		if (iface->ifindex == ifindex)
			return (iface);
	}

	return (NULL);
}

struct iface *
if_new(struct kif *kif)
{
	struct sockaddr_in	*sain;
	struct iface		*iface;
	struct ifreq		*ifr;
	int			 s;

	if ((iface = calloc(1, sizeof(*iface))) == NULL)
		err(1, "if_new: calloc");

	iface->state = IF_STA_DOWN;
	iface->passive = 1;

	LIST_INIT(&iface->nbr_list);
	TAILQ_INIT(&iface->group_list);
	TAILQ_INIT(&iface->rde_group_list);
	strlcpy(iface->name, kif->ifname, sizeof(iface->name));

	if ((ifr = calloc(1, sizeof(*ifr))) == NULL)
		err(1, "if_new: calloc");

	/* set up ifreq */
	strlcpy(ifr->ifr_name, kif->ifname, sizeof(ifr->ifr_name));
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "if_new: socket");

	/* get type */
	if ((kif->flags & IFF_POINTOPOINT))
		iface->type = IF_TYPE_POINTOPOINT;
	if ((kif->flags & IFF_BROADCAST) &&
	    (kif->flags & IFF_MULTICAST))
		iface->type = IF_TYPE_BROADCAST;

	/* get mtu, index and flags */
	iface->mtu = kif->mtu;
	iface->ifindex = kif->ifindex;
	iface->flags = kif->flags;
	iface->linkstate = kif->link_state;
	iface->if_type = kif->if_type;
	iface->baudrate = kif->baudrate;

	/* get address */
	if (ioctl(s, SIOCGIFADDR, (caddr_t)ifr) < 0)
		err(1, "if_new: cannot get address");
	sain = (struct sockaddr_in *) &ifr->ifr_addr;
	iface->addr = sain->sin_addr;

	/* get mask */
	if (ioctl(s, SIOCGIFNETMASK, (caddr_t)ifr) < 0)
		err(1, "if_new: cannot get mask");
	sain = (struct sockaddr_in *) &ifr->ifr_addr;
	iface->mask = sain->sin_addr;

	/* get p2p dst address */
	if (iface->type == IF_TYPE_POINTOPOINT) {
		if (ioctl(s, SIOCGIFDSTADDR, (caddr_t)ifr) < 0)
			err(1, "if_new: cannot get dst addr");
		sain = (struct sockaddr_in *) &ifr->ifr_addr;
		iface->dst = sain->sin_addr;
	}

	free(ifr);
	close(s);

	return (iface);
}

void
if_init(struct dvmrpd_conf *xconf, struct iface *iface)
{
	/* set event handlers for interface */
	evtimer_set(&iface->probe_timer, if_probe_timer, iface);
	evtimer_set(&iface->query_timer, if_query_timer, iface);
	evtimer_set(&iface->querier_present_timer, if_querier_present_timer,
	    iface);

	TAILQ_INIT(&iface->rr_list);

	iface->fd = xconf->dvmrp_socket;
	iface->gen_id = xconf->gen_id;
}

int
if_del(struct iface *iface)
{
	struct nbr	*nbr = NULL;

	/* clear lists etc */
	while ((nbr = LIST_FIRST(&iface->nbr_list)) != NULL) {
		LIST_REMOVE(nbr, entry);
		nbr_del(nbr);
	}
	group_list_clr(iface);

	return (-1);
}

int
if_nbr_list_empty(struct iface *iface)
{
	return (LIST_EMPTY(&iface->nbr_list));
}

/* timers */
void
if_probe_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;
	struct timeval tv;

	send_probe(iface);

	/* reschedule probe_timer */
	if (!iface->passive) {
		timerclear(&tv);
		tv.tv_sec = iface->probe_interval;
		evtimer_add(&iface->probe_timer, &tv);
	}
}

int
if_start_probe_timer(struct iface *iface)
{
	struct timeval tv;

	timerclear(&tv);
	return (evtimer_add(&iface->probe_timer, &tv));
}

int
if_stop_probe_timer(struct iface *iface)
{
	return (evtimer_del(&iface->probe_timer));
}

void
if_query_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;
	struct timeval tv;

	/* send a general query */
	send_igmp_query(iface, NULL);

	/* reschedule query_timer */
	if (!iface->passive) {
		timerclear(&tv);
		if (iface->startup_query_counter != 0) {
			tv.tv_sec = iface->startup_query_interval;
			iface->startup_query_counter--;
		} else
			tv.tv_sec = iface->query_interval;

		evtimer_add(&iface->query_timer, &tv);
	}
}

int
if_start_query_timer(struct iface *iface)
{
	struct timeval tv;

	timerclear(&tv);
	return (evtimer_add(&iface->query_timer, &tv));
}

int
if_stop_query_timer(struct iface *iface)
{
	return (evtimer_del(&iface->query_timer));
}

void
if_querier_present_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;

	if_fsm(iface, IF_EVT_QPRSNTTMOUT);
}

int
if_start_querier_present_timer(struct iface *iface)
{
	struct timeval tv;

	/* Other Querier Present Interval */
	timerclear(&tv);
	tv.tv_sec = iface->robustness * iface->query_interval +
	    (iface->query_resp_interval / 2);

	return (evtimer_add(&iface->querier_present_timer, &tv));
}

int
if_stop_querier_present_timer(struct iface *iface)
{
	return (evtimer_del(&iface->querier_present_timer));
}

int
if_reset_querier_present_timer(struct iface *iface)
{
	struct timeval	tv;

	/* Other Querier Present Interval */
	timerclear(&tv);
	tv.tv_sec = iface->robustness * iface->query_interval +
	    (iface->query_resp_interval / 2);

	return (evtimer_add(&iface->querier_present_timer, &tv));
}

/* actions */
int
if_act_start(struct iface *iface)
{
	struct in_addr	 addr;
	struct timeval	 now;

	if (iface->passive) {
		log_debug("if_act_start: cannot start passive interface %s",
		    iface->name);
		return (-1);
	}

	if (!((iface->flags & IFF_UP) && LINK_STATE_IS_UP(iface->linkstate))) {
		log_debug("if_act_start: interface %s link down",
		    iface->name);
		return (0);
	}

	gettimeofday(&now, NULL);
	iface->uptime = now.tv_sec;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		inet_aton(AllSystems, &addr);
		if (if_join_group(iface, &addr)) {
			log_warnx("if_act_start: error joining group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}
		inet_aton(AllRouters, &addr);
		if (if_join_group(iface, &addr)) {
			log_warnx("if_act_start: error joining group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}
		inet_aton(AllDVMRPRouters, &addr);
		if (if_join_group(iface, &addr)) {
			log_warnx("if_act_start: error joining group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}

		iface->state = IF_STA_QUERIER;
		if_start_query_timer(iface);
		if_start_probe_timer(iface);
		iface->startup_query_counter = iface->startup_query_cnt;
		break;
	default:
		fatalx("if_act_start: unknown type");
	}

	return (0);
}

int
if_act_query_seen(struct iface *iface)
{
	log_debug("if_act_query_seen: interface %s", iface->name);

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		iface->state = IF_STA_NONQUERIER;
		if_stop_query_timer(iface);
		if_reset_querier_present_timer(iface);
		break;
	default:
		fatalx("if_act_querier_seen: unknown type");
	}

	return (0);
}

int
if_act_reset(struct iface *iface)
{
	struct in_addr	 addr;
	struct nbr	*nbr;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		inet_aton(AllSystems, &addr);
		if (if_leave_group(iface, &addr)) {
			log_warnx("if_act_reset: error leaving group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}
		inet_aton(AllRouters, &addr);
		if (if_leave_group(iface, &addr)) {
			log_warnx("if_act_reset: error leaving group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}
		inet_aton(AllDVMRPRouters, &addr);
		if (if_leave_group(iface, &addr)) {
			log_warnx("if_act_reset: error leaving group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
			return (-1);
		}

		iface->state = IF_STA_DOWN;
		iface->gen_id++;
		if_stop_query_timer(iface);
		if_stop_querier_present_timer(iface);
		/* XXX clear nbr list? */
		break;
	default:
		fatalx("if_act_reset: unknown type");
	}

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr_fsm(nbr, NBR_EVT_KILL_NBR)) {
			log_debug("if_act_reset: error killing neighbor %s",
			    inet_ntoa(nbr->id));
		}
	}

	group_list_clr(iface);	/* XXX clear group list? */

	return (0);
}

const char *
if_event_name(int event)
{
	return (if_event_names[event]);
}

const char *
if_action_name(int action)
{
	return (if_action_names[action]);
}

/* misc */
int
if_set_mcast_ttl(int fd, u_int8_t ttl)
{
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
	    (char *)&ttl, sizeof(ttl)) < 0) {
		log_warn("if_set_mcast_ttl: error setting "
		    "IP_MULTICAST_TTL to %d", ttl);
		return (-1);
	}

	return (0);
}

int
if_set_tos(int fd, int tos)
{
	if (setsockopt(fd, IPPROTO_IP, IP_TOS,
	    (int *)&tos, sizeof(tos)) < 0) {
		log_warn("if_set_tos: error setting IP_TOS to 0x%x", tos);
		return (-1);
	}

	return (0);
}

void
if_set_recvbuf(int fd)
{
	int	bsize;

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;
}

int
if_join_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq	 mreq;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		mreq.imr_multiaddr.s_addr = addr->s_addr;
		mreq.imr_interface.s_addr = iface->addr.s_addr;

		if (setsockopt(iface->fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
		    (void *)&mreq, sizeof(mreq)) < 0) {
			log_debug("if_join_group: error IP_ADD_MEMBERSHIP, "
			    "interface %s", iface->name);
			return (-1);
		}
		break;
	default:
		fatalx("if_join_group: unknown interface type");
	}

	return (0);
}

int
if_leave_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq	 mreq;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		mreq.imr_multiaddr.s_addr = addr->s_addr;
		mreq.imr_interface.s_addr = iface->addr.s_addr;

		if (setsockopt(iface->fd, IPPROTO_IP, IP_DROP_MEMBERSHIP,
		    (void *)&mreq, sizeof(mreq)) < 0) {
			log_debug("if_leave_group: error IP_DROP_MEMBERSHIP, "
			    "interface %s", iface->name);
			return (-1);
		}
		break;
	default:
		fatalx("if_leave_group: unknown interface type");
	}

	return (0);
}

int
if_set_mcast(struct iface *iface)
{
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		if (setsockopt(iface->fd, IPPROTO_IP, IP_MULTICAST_IF,
		    (char *)&iface->addr.s_addr,
		    sizeof(iface->addr.s_addr)) < 0) {
			log_debug("if_set_mcast: error setting "
			    "IP_MULTICAST_IF, interface %s", iface->name);
			return (-1);
		}
		break;
	default:
		fatalx("if_set_mcast: unknown interface type");
	}

	return (0);
}

int
if_set_mcast_loop(int fd)
{
	u_int8_t	loop = 0;

	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
	    (char *)&loop, sizeof(loop)) < 0) {
		log_warn("if_set_mcast_loop: error setting IP_MULTICAST_LOOP");
		return (-1);
	}

	return (0);
}

struct ctl_iface *
if_to_ctl(struct iface *iface)
{
	static struct ctl_iface	 ictl;
	struct timeval		 tv, now, res;

	memcpy(ictl.name, iface->name, sizeof(ictl.name));
	memcpy(&ictl.addr, &iface->addr, sizeof(ictl.addr));
	memcpy(&ictl.mask, &iface->mask, sizeof(ictl.mask));
	memcpy(&ictl.querier, &iface->querier, sizeof(ictl.querier));

	ictl.ifindex = iface->ifindex;
	ictl.state = iface->state;
	ictl.mtu = iface->mtu;
	ictl.nbr_cnt = iface->nbr_cnt;
	ictl.adj_cnt = iface->adj_cnt;

	ictl.gen_id = iface->gen_id;
	ictl.group_cnt = iface->group_cnt;
	ictl.probe_interval = iface->probe_interval;
	ictl.query_interval = iface->query_interval;
	ictl.query_resp_interval = iface->query_resp_interval;
	ictl.recv_query_resp_interval = iface->recv_query_resp_interval;
	ictl.group_member_interval = iface->group_member_interval;
	ictl.querier_present_interval = iface->querier_present_interval;
	ictl.startup_query_interval = iface->startup_query_interval;
	ictl.startup_query_cnt = iface->startup_query_cnt;
	ictl.last_member_query_interval = iface->last_member_query_interval;
	ictl.last_member_query_cnt = iface->last_member_query_cnt;
	ictl.last_member_query_time = iface->last_member_query_time;
	ictl.v1_querier_present_tmout = iface->v1_querier_present_tmout;
	ictl.v1_host_present_interval = iface->v1_host_present_interval;
	ictl.dead_interval = iface->dead_interval;

	ictl.baudrate = iface->baudrate;
	ictl.flags = iface->flags;
	ictl.metric = iface->metric;
	ictl.type = iface->type;
	ictl.robustness = iface->robustness;
	ictl.linkstate = iface->linkstate;
	ictl.passive = iface->passive;
	ictl.igmp_version = iface->igmp_version;
	ictl.if_type = iface->if_type;

	gettimeofday(&now, NULL);
	if (evtimer_pending(&iface->probe_timer, &tv)) {
		timersub(&tv, &now, &res);
		ictl.probe_timer = res.tv_sec;
	} else
		ictl.probe_timer = -1;

	if (evtimer_pending(&iface->query_timer, &tv)) {
		timersub(&tv, &now, &res);
		ictl.query_timer = res.tv_sec;
	} else
		ictl.query_timer = -1;

	if (evtimer_pending(&iface->querier_present_timer, &tv)) {
		timersub(&tv, &now, &res);
		ictl.querier_present_timer = res.tv_sec;
	} else
		ictl.querier_present_timer = -1;

	if (iface->state != IF_STA_DOWN) {
		ictl.uptime = now.tv_sec - iface->uptime;
	} else
		ictl.uptime = 0;

	return (&ictl);
}
@


1.10
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.9 2009/09/22 16:43:42 michele Exp $ */
d200 1
a200 1
	iface->media_type = kif->media_type;
d675 1
a675 1
	ictl.mediatype = iface->media_type;
@


1.9
log
@Sync the link state check code with others daemons.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.8 2009/03/06 18:39:13 michele Exp $ */
d387 1
a387 4
	if (!((iface->flags & IFF_UP) &&
	    (LINK_STATE_IS_UP(iface->linkstate) ||
	    (iface->linkstate == LINK_STATE_UNKNOWN &&
	    iface->media_type != IFT_CARP)))) {
@


1.8
log
@Make RDE aware of multicast group members per interface. This is needed to
make unicast routing decisions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.7 2009/01/20 01:35:34 todd Exp $ */
d29 1
d388 3
a390 1
	    (iface->linkstate != LINK_STATE_DOWN))) {
@


1.7
log
@revert earlier commit that broke the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.5 2007/09/11 18:23:05 claudio Exp $ */
d176 1
@


1.6
log
@When inserting a new route into the kernel set as
downstream interfaces the ones with neighbors or
group members.

ok norby@@
@
text
@d646 1
@


1.5
log
@The same dance as in all other routing daemons. baudrate is 64bit plus
initialize iface->baudrate when the interface is created. An additional
gimmick don't set the ictl->baudrate twice when building the control message.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.4 2006/12/03 20:14:37 michele Exp $ */
a645 1
	ictl.nbr_cnt = iface->nbr_cnt;
@


1.4
log
@introduce rde_check_route that selects which routes must be accepted and which discarded.
Still not complete, just a step forward.

ok norby@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.3 2006/06/02 17:06:50 norby Exp $ */
d199 1
a650 1
	ictl.baudrate = iface->baudrate;
@


1.3
log
@allow igmp to work properly on p2p interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.2 2006/06/01 18:18:25 norby Exp $ */
d44 2
d145 13
@


1.2
log
@implement adjacent nbr count, needed when we want to decide where to flood
multicast streams.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
a419 2
		/* XXX iface p2p */
		break;
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d632 2
a633 2
	ictl.nbr_cnt = 0;	/* XXX */
	ictl.adj_cnt = 0;	/* XXX */
@

