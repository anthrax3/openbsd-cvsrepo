head	1.19;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2016.09.02.16.20.34;	author benno;	state Exp;
branches;
next	1.18;
commitid	GeTQXXDZkuCy2ybg;

1.18
date	2016.09.02.15.38.08;	author renato;	state Exp;
branches;
next	1.17;
commitid	RZy3B9dNz2typ92I;

1.17
date	2016.09.02.15.35.34;	author renato;	state Exp;
branches;
next	1.16;
commitid	mZZPdF3JSUT0PFss;

1.16
date	2016.09.02.15.33.27;	author renato;	state Exp;
branches;
next	1.15;
commitid	XYNgWRJ78YI9wKPC;

1.15
date	2015.12.05.13.11.00;	author claudio;	state Exp;
branches;
next	1.14;
commitid	IgfRve2khGGqPTCy;

1.14
date	2015.02.10.08.49.30;	author claudio;	state Exp;
branches;
next	1.13;
commitid	ZNoTbhFNTqPuXdMF;

1.13
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.12;
commitid	yCis8OrOsfixbKpI;

1.12
date	2014.07.12.19.22.32;	author krw;	state Exp;
branches;
next	1.11;
commitid	XAgbiXPNNyS0mzjf;

1.11
date	2013.11.26.11.32.31;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.22.16.38.31;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.06.07.52.04;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.20.31.35;	author jacekm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.17.13.04;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.14.15.32.55;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.21.10.39.32;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.01.21.47.27;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.19
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@
@
text
@/*	$OpenBSD: dvmrpe.c,v 1.18 2016/09/02 15:38:08 renato Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2006 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_types.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>

#include "igmp.h"
#include "dvmrp.h"
#include "dvmrpd.h"
#include "dvmrpe.h"
#include "control.h"
#include "log.h"

void		 dvmrpe_sig_handler(int, short, void *);
__dead void	 dvmrpe_shutdown(void);

volatile sig_atomic_t	 dvmrpe_quit = 0;
struct dvmrpd_conf	*deconf = NULL;
struct imsgev		*iev_main;
struct imsgev		*iev_rde;
struct ctl_conn		*ctl_conn;

void
dvmrpe_sig_handler(int sig, short event, void *bula)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		dvmrpe_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* dvmrp engine */
pid_t
dvmrpe(struct dvmrpd_conf *xconf, int pipe_parent2dvmrpe[2],
    int pipe_dvmrpe2rde[2], int pipe_parent2rde[2])
{
	struct iface	*iface = NULL;
	struct passwd	*pw;
	struct event	 ev_sigint, ev_sigterm;
	pid_t		 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:

		return (pid);
	}

	/* create the raw ip socket */
	if ((xconf->dvmrp_socket = socket(AF_INET,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    IPPROTO_IGMP)) == -1)
		fatal("error creating raw socket");

	/* create dvmrpd control socket outside chroot */
	if (control_init() == -1)
		fatalx("control socket setup failed");

	/* set some defaults */
	if (if_set_mcast_ttl(xconf->dvmrp_socket,
	    IP_DEFAULT_MULTICAST_TTL) == -1)
		fatal("if_set_mcast_ttl");

	if (if_set_mcast_loop(xconf->dvmrp_socket) == -1)
		fatal("if_set_mcast_loop");

	if (if_set_tos(xconf->dvmrp_socket, IPTOS_PREC_INTERNETCONTROL) == -1)
		fatal("if_set_tos");

	if_set_recvbuf(xconf->dvmrp_socket);

	deconf = xconf;

	if ((pw = getpwnam(DVMRPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("dvmrp engine");
	dvmrpd_process = PROC_DVMRP_ENGINE;
	log_procname = log_procnames[dvmrpd_process];

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	event_init();
	nbr_init(NBR_HASHSIZE);

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, dvmrpe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, dvmrpe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes */
	close(pipe_parent2dvmrpe[0]);
	close(pipe_dvmrpe2rde[1]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2rde[1]);

	if ((iev_rde = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_rde->ibuf, pipe_dvmrpe2rde[0]);
	iev_rde->handler = dvmrpe_dispatch_rde;

	imsg_init(&iev_main->ibuf, pipe_parent2dvmrpe[1]);
	iev_main->handler = dvmrpe_dispatch_main;

	/* setup event handler */
	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	event_set(&deconf->ev, deconf->dvmrp_socket, EV_READ|EV_PERSIST,
	    recv_packet, deconf);
	event_add(&deconf->ev, NULL);

	/* listen on dvmrpd control socket */
	TAILQ_INIT(&ctl_conns);
	control_listen();

	if ((pkt_ptr = calloc(1, IBUF_READ_SIZE)) == NULL)
		fatal("dvmrpe");

	/* start interfaces */
	LIST_FOREACH(iface, &deconf->iface_list, entry) {
		if_init(xconf, iface);
		if (if_fsm(iface, IF_EVT_UP)) {
			log_debug("error starting interface %s", iface->name);
		}
	}

	evtimer_set(&deconf->report_timer, report_timer, deconf);
	start_report_timer();

	event_dispatch();

	dvmrpe_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
dvmrpe_shutdown(void)
{
	struct iface	*iface;

	/* close pipes */
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	/* stop all interfaces and delete them */
	LIST_FOREACH(iface, &deconf->iface_list, entry) {
		if (if_fsm(iface, IF_EVT_DOWN)) {
			log_debug("error stopping interface %s",
			    iface->name);
		}
		if_del(iface);
	}

	/* clean up */
	free(iev_rde);
	free(iev_main);
	free(pkt_ptr);

	log_info("dvmrp engine exiting");
	_exit(0);
}

int
dvmrpe_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
dvmrpe_imsg_compose_rde(int type, u_int32_t peerid, pid_t pid,
    void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_rde, type, peerid, pid,
	     -1, data, datalen));
}

void
dvmrpe_dispatch_main(int fd, short event, void *bula)
{
	struct imsg	 imsg;
	struct imsgev	*iev = bula;
	struct imsgbuf  *ibuf = &iev->ibuf;
	struct kif	*kif;
	struct iface	*iface;
	ssize_t		 n;
	int		 shut = 0, link_ok;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("dvmrpe_dispatch_main: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFINFO:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kif))
				fatalx("IFINFO imsg with wrong len");
			kif = imsg.data;
			link_ok = (kif->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(kif->link_state);

			LIST_FOREACH(iface, &deconf->iface_list, entry) {
				if (kif->ifindex == iface->ifindex) {
					iface->flags = kif->flags;
					iface->linkstate = kif->link_state;

					if (link_ok) {
						if_fsm(iface, IF_EVT_UP);
						log_warnx("interface %s up",
						    iface->name);
					} else {
						if_fsm(iface, IF_EVT_DOWN);
						log_warnx("interface %s down",
						    iface->name);
					}
				}
			}
			break;
		default:
			log_debug("dvmrpe_dispatch_main: error handling "
			    "imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
dvmrpe_dispatch_rde(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct nbr		*nbr;
	struct prune		 p;
	struct iface		*iface;
	struct route_report	*rr;
	ssize_t			 n;
	int			 shut = 0;

	 if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("dvmrpe_dispatch_rde: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_SUM:
		case IMSG_CTL_SHOW_MFC:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		case IMSG_FULL_ROUTE_REPORT:
			/* add route reports to list */
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(*rr))
				fatalx("invalid size of RDE request");

			if ((rr = calloc(1, sizeof(*rr))) == NULL)
				fatal("dvmrpe_dispatch_rde");

			memcpy(rr, imsg.data, sizeof(*rr));

			/* general update, per interface */
			if (imsg.hdr.peerid == 0) {
				/* add to interface list */
				LIST_FOREACH(iface, &deconf->iface_list,
				    entry) {
					if (!if_nbr_list_empty(iface))
						rr_list_add(&iface->rr_list,
						    rr);
				}
				break;
			}

			/* add to neighbor list */
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			rr_list_add(&nbr->rr_list, rr);
			break;
		case IMSG_FULL_ROUTE_REPORT_END:
			/* transmit route report */
			if (imsg.hdr.peerid == 0) {
				/*
				 * send general route report on all
				 * interfaces with neighbors.
				 */
				LIST_FOREACH(iface, &deconf->iface_list,
				    entry) {
					rr_list_send(&iface->rr_list,
					    iface, NULL);
				}
				break;
			}

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			rr_list_send(&nbr->rr_list, NULL, nbr);
			break;
		case IMSG_SEND_PRUNE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(p))
				fatalx("invalid size of RDE request");

			memcpy(&p, imsg.data, sizeof(p));

			LIST_FOREACH(iface, &deconf->iface_list, entry)
				if (p.ifindex == iface->ifindex)
					break;

			if (iface == NULL)
				fatalx("invalid interface in mfc");

			nbr = nbr_find_ip(iface, p.nexthop.s_addr);
			if (nbr == NULL)
				fatalx("unknown neighbor to send prune");

			send_prune(nbr, &p);

			break;
		case IMSG_FLASH_UPDATE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(*rr))
				fatalx("invalid size of RDE request");

			if ((rr = calloc(1, sizeof(*rr))) == NULL)
				fatal("dvmrpe_dispatch_rde");

			memcpy(rr, imsg.data, sizeof(*rr));

			LIST_FOREACH(iface, &deconf->iface_list, entry) {
				if (!if_nbr_list_empty(iface)) {
					rr_list_add(&iface->rr_list, rr);
					rr_list_send(&iface->rr_list, iface,
					    NULL);
				}
			}
			break;
		case IMSG_FLASH_UPDATE_DS:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(*rr))
				fatalx("invalid size of RDE request");

			if ((rr = calloc(1, sizeof(*rr))) == NULL)
				fatal("dvmrpe_dispatch_rde");

			memcpy(rr, imsg.data, sizeof(*rr));

			LIST_FOREACH(iface, &deconf->iface_list, entry) {
				if (iface->ifindex == rr->ifindex)
					continue;
				if (!if_nbr_list_empty(iface)) {
					rr_list_add(&iface->rr_list, rr);
					rr_list_send(&iface->rr_list, iface,
					    NULL);
				}
			}
			break;
		default:
			log_debug("dvmrpe_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
dvmrpe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct iface		*iface;
	struct ctl_iface	*ictl;

	LIST_FOREACH(iface, &deconf->iface_list, entry)
		if (idx == 0 || idx == iface->ifindex) {
			ictl = if_to_ctl(iface);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_IFACE,
			    0, 0, -1, ictl, sizeof(struct ctl_iface));
		}
}

void
dvmrpe_iface_igmp_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct iface		*iface;
	struct ctl_iface	*ictl;

	LIST_FOREACH(iface, &deconf->iface_list, entry)
		if (idx == 0 || idx == iface->ifindex) {
			ictl = if_to_ctl(iface);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_IFACE,
			    0, 0, -1, ictl, sizeof(struct ctl_iface));
			group_list_dump(iface, c);

		}
}

void
dvmrpe_nbr_ctl(struct ctl_conn *c)
{
	struct iface	*iface;
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	LIST_FOREACH(iface, &deconf->iface_list, entry)
		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
			nctl = nbr_to_ctl(nbr);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_NBR,
			    0, 0, -1, nctl, sizeof(struct ctl_nbr));
		}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}
@


1.18
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.17 2016/09/02 15:35:34 renato Exp $ */
d122 1
@


1.17
log
@Close connections when msgbuf_write() returns 0.

Pulled from ospfd. Original author: claudio@@

ok rzalamena@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.16 2016/09/02 15:33:27 renato Exp $ */
d45 2
a46 2
void	 dvmrpe_sig_handler(int, short, void *);
void	 dvmrpe_shutdown(void);
d193 1
a193 1
void
d198 8
a215 2
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
a216 2
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
@


1.16
log
@Don't fatal if the imsg pipe is closed, this is often triggered in the
parent and hides the real cause of the termination.

Pulled from ospfd. Original author: claudio@@

ok rzalamena@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.15 2015/12/05 13:11:00 claudio Exp $ */
d252 1
a252 1
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
d254 2
d326 1
a326 1
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
d328 2
@


1.15
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.14 2015/02/10 08:49:30 claudio Exp $ */
d243 1
a243 1
	int		 link_ok;
d249 1
a249 1
			fatalx("pipe closed");
d295 7
a301 1
	imsg_event_add(iev);
d315 1
d321 1
a321 1
			fatalx("pipe closed");
d448 7
a454 1
	imsg_event_add(iev);
@


1.14
log
@More SOCK_NONBLOCK adjustments similar to the other daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.13 2014/11/18 20:54:28 krw Exp $ */
d246 1
a246 1
		if ((n = imsg_read(ibuf)) == -1)
d311 1
a311 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.13
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.12 2014/07/12 19:22:32 krw Exp $ */
d88 2
a89 1
	if ((xconf->dvmrp_socket = socket(AF_INET, SOCK_RAW,
@


1.12
log
@msgbuf_write() <= 0 for a few more daemons.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.11 2013/11/26 11:32:31 henning Exp $ */
a36 1
#include <stdlib.h>
@


1.11
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.10 2011/07/04 04:34:14 claudio Exp $ */
d252 1
a252 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d317 1
a317 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
@


1.10
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.9 2010/05/26 13:56:07 nicm Exp $ */
d252 1
a252 1
		if (msgbuf_write(&ibuf->w) == -1)
d317 1
a317 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.9
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.8 2009/09/22 16:38:31 michele Exp $ */
d269 1
a269 3
			    (LINK_STATE_IS_UP(kif->link_state) ||
			    (kif->link_state == LINK_STATE_UNKNOWN &&
			    kif->media_type != IFT_CARP));
@


1.8
log
@React putting the interface in state 'down' when dvmrpd detects that
the link went down.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.7 2009/06/06 07:52:04 pyr Exp $ */
d172 1
a172 1
	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
@


1.7
log
@make dvmrpd imsg-in-a-lib ready as well.
``put it in'' claudio@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.6 2009/05/31 20:31:35 jacekm Exp $ */
d26 1
d240 2
d243 1
d263 27
@


1.6
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.5 2009/05/31 17:13:04 claudio Exp $ */
d50 2
a51 2
struct imsgbuf		*ibuf_main;
struct imsgbuf		*ibuf_rde;
d143 2
a144 2
	if ((ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d146 5
a150 2
	imsg_init(ibuf_rde, pipe_dvmrpe2rde[0], dvmrpe_dispatch_rde);
	imsg_init(ibuf_main, pipe_parent2dvmrpe[1], dvmrpe_dispatch_main);
d153 9
a161 9
	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d207 6
a212 6
	msgbuf_write(&ibuf_rde->w);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d222 1
a222 1
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
d229 2
a230 1
	return (imsg_compose(ibuf_rde, type, peerid, pid, data, datalen));
d237 2
a238 1
	struct imsgbuf  *ibuf = bula;
d266 1
a266 1
	imsg_event_add(ibuf);
d272 2
a273 1
	struct imsgbuf		*ibuf = bula;
d412 1
a412 1
	imsg_event_add(ibuf);
d424 2
a425 2
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_IFACE,
			    0, 0, ictl, sizeof(struct ctl_iface));
d438 2
a439 2
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_IFACE,
			    0, 0, ictl, sizeof(struct ctl_iface));
d455 2
a456 2
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_NBR, 0, 0, nctl,
			    sizeof(struct ctl_nbr));
d459 1
a459 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
@


1.5
log
@More libevent callback fixes. While there make n also ssize_t as in all
other daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.4 2009/03/14 15:32:55 michele Exp $ */
a244 1
		imsg_event_add(ibuf);
a283 1
		imsg_event_add(ibuf);
@


1.4
log
@Initial support for pruning. When every single interface is removed from the
downstream list for a particular source send a prune to the upstream router.

input and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.3 2008/11/21 10:39:32 michele Exp $ */
d234 1
a234 1
	int		 n;
d236 1
a236 2
	switch (event) {
	case EV_READ:
d241 2
a242 2
		break;
	case EV_WRITE:
a245 3
		return;
	default:
		fatalx("unknown event");
d274 1
a274 1
	int			 n;
d276 1
a276 2
	switch (event) {
	case EV_READ:
d281 2
a282 2
		break;
	case EV_WRITE:
a285 3
		return;
	default:
		fatalx("unknown event");
@


1.3
log
@Introduce support for flash updates.
They spread routing changes immediately as they happen
avoiding wait until the next report interval.

OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.2 2006/06/01 21:47:27 claudio Exp $ */
d275 1
d352 20
@


1.2
log
@Remove some unneeded lint goo and use setres[ug]id() instead of the setuid
dance.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpe.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d351 36
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a63 1
		/* NOTREACHED */
a79 1
		/* NOTREACHED */
d123 2
a124 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
a125 1
	}
a215 1
/* imesg */
@

