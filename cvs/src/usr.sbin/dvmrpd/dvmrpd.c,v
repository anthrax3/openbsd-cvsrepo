head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.8
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.6
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2016.09.02.16.20.34;	author benno;	state Exp;
branches;
next	1.24;
commitid	GeTQXXDZkuCy2ybg;

1.24
date	2016.09.02.15.38.08;	author renato;	state Exp;
branches;
next	1.23;
commitid	RZy3B9dNz2typ92I;

1.23
date	2016.09.02.15.35.34;	author renato;	state Exp;
branches;
next	1.22;
commitid	mZZPdF3JSUT0PFss;

1.22
date	2016.09.02.15.33.27;	author renato;	state Exp;
branches;
next	1.21;
commitid	XYNgWRJ78YI9wKPC;

1.21
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.20;
commitid	LQHdRRMF0nq0fugE;

1.20
date	2015.12.05.13.11.00;	author claudio;	state Exp;
branches;
next	1.19;
commitid	IgfRve2khGGqPTCy;

1.19
date	2015.02.10.08.49.30;	author claudio;	state Exp;
branches;
next	1.18;
commitid	ZNoTbhFNTqPuXdMF;

1.18
date	2015.02.09.11.45.22;	author claudio;	state Exp;
branches;
next	1.17;
commitid	k1i5i8dXVxLjUfN3;

1.17
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	Uu5nFG3wCl0LACBb;

1.16
date	2014.07.12.19.22.32;	author krw;	state Exp;
branches;
next	1.15;
commitid	XAgbiXPNNyS0mzjf;

1.15
date	2013.11.26.11.32.30;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.08.00.36.20;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.08.00.26.51;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.02.20.31.50;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.06.07.52.04;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.01.23.22.58;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.20.31.35;	author jacekm;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.17.13.04;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.20.13.26.50;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.13.16.35.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.24.09.57.51;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.01.22.07.30;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.25
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@
@
text
@/*	$OpenBSD: dvmrpd.c,v 1.24 2016/09/02 15:38:08 renato Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2005, 2006 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/wait.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <event.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <util.h>

#include "igmp.h"
#include "dvmrpd.h"
#include "dvmrp.h"
#include "dvmrpe.h"
#include "control.h"
#include "log.h"
#include "rde.h"

void		main_sig_handler(int, short, void *);
__dead void	usage(void);
__dead void	dvmrpd_shutdown(void);

void	main_dispatch_dvmrpe(int, short, void *);
void	main_dispatch_rde(int, short, void *);
void	main_imsg_compose_dvmrpe(int, pid_t, void *, u_int16_t);
void	main_imsg_compose_rde(int, pid_t, void *, u_int16_t);

int	pipe_parent2dvmrpe[2];
int	pipe_parent2rde[2];
int	pipe_dvmrpe2rde[2];

struct dvmrpd_conf	*conf = NULL;
struct imsgev		*iev_dvmrpe;
struct imsgev		*iev_rde;

pid_t			 dvmrpe_pid;
pid_t			 rde_pid;

void
main_sig_handler(int sig, short event, void *arg)
{
	/* signal handler rules don't apply, libevent decouples for us */
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		dvmrpd_shutdown();
		/* NOTREACHED */
	case SIGHUP:
		/* reconfigure */
		/* ... */
		break;
	default:
		fatalx("unexpected signal");
		/* NOTREACHED */
	}
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dnv] [-f file]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct event	 ev_sigint, ev_sigterm, ev_sighup;
	char		*conffile;
	int		 ch, opts = 0;
	int		 debug = 0;
	int		 ipmforwarding;
	int		 mib[4];
	size_t		 len;

	conffile = CONF_FILE;
	dvmrpd_process = PROC_MAIN;
	log_procname = log_procnames[dvmrpd_process];

	log_init(1);	/* log to stderr until daemonized */
	log_verbose(1);

	while ((ch = getopt(argc, argv, "df:nv")) != -1) {
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			opts |= DVMRPD_OPT_NOACTION;
			break;
		case 'v':
			if (opts & DVMRPD_OPT_VERBOSE)
				opts |= DVMRPD_OPT_VERBOSE2;
			opts |= DVMRPD_OPT_VERBOSE;
			log_verbose(1);
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	log_init(debug);
	log_verbose(opts & DVMRPD_OPT_VERBOSE);

	/* multicast IP forwarding must be enabled */
	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_MFORWARDING;
	len = sizeof(ipmforwarding);
	if (sysctl(mib, 4, &ipmforwarding, &len, NULL, 0) == -1)
		err(1, "sysctl");

	if (!ipmforwarding)
		errx(1, "multicast IP forwarding not enabled");

	/* fetch interfaces early */
	kif_init();

	/* parse config file */
	if ((conf = parse_config(conffile, opts)) == NULL )
		exit(1);

	if (conf->opts & DVMRPD_OPT_NOACTION) {
		if (conf->opts & DVMRPD_OPT_VERBOSE)
			print_config(conf);
		else
			fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	/* check for root privileges  */
	if (geteuid())
		errx(1, "need root privileges");

	/* check for dvmrpd user */
	if (getpwnam(DVMRPD_USER) == NULL)
		errx(1, "unknown user %s", DVMRPD_USER);

	/* start logging */
	log_init(1);

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2dvmrpe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2rde) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_dvmrpe2rde) == -1)
		fatal("socketpair");

	/* start children */
	rde_pid = rde(conf, pipe_parent2rde, pipe_dvmrpe2rde,
	    pipe_parent2dvmrpe);
	dvmrpe_pid = dvmrpe(conf, pipe_parent2dvmrpe, pipe_dvmrpe2rde,
	    pipe_parent2rde);

	/* create the raw ip socket */
	if ((conf->mroute_socket = socket(AF_INET,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    IPPROTO_IGMP)) == -1)
		fatal("error creating raw socket");

	if_set_recvbuf(conf->mroute_socket);

	if (mrt_init(conf->mroute_socket))
		fatal("multicast routing not enabled in kernel");

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes to children */
	close(pipe_parent2dvmrpe[1]);
	close(pipe_parent2rde[1]);
	close(pipe_dvmrpe2rde[0]);
	close(pipe_dvmrpe2rde[1]);

	if ((iev_dvmrpe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_rde = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_dvmrpe->ibuf, pipe_parent2dvmrpe[0]);
	imsg_init(&iev_rde->ibuf, pipe_parent2rde[0]);
	iev_dvmrpe->handler =  main_dispatch_dvmrpe;
	iev_rde->handler = main_dispatch_rde;

	/* setup event handler */
	iev_dvmrpe->events = EV_READ;
	event_set(&iev_dvmrpe->ev, iev_dvmrpe->ibuf.fd, iev_dvmrpe->events,
	    iev_dvmrpe->handler, iev_dvmrpe);
	event_add(&iev_dvmrpe->ev, NULL);

	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	if (kmr_init(!(conf->flags & DVMRPD_FLAG_NO_FIB_UPDATE)) == -1)
		dvmrpd_shutdown();
	if (kr_init() == -1)
		dvmrpd_shutdown();

	event_set(&conf->ev, conf->mroute_socket, EV_READ|EV_PERSIST,
	    kmr_recv_msg, conf);
	event_add(&conf->ev, NULL);

	event_dispatch();

	dvmrpd_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
dvmrpd_shutdown(void)
{
	struct iface	*iface;
	pid_t		 pid;
	int		 status;

	/* close pipes */
	msgbuf_clear(&iev_dvmrpe->ibuf.w);
	close(iev_dvmrpe->ibuf.fd);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);

	control_cleanup();
	kmr_shutdown();
	kr_shutdown();
	LIST_FOREACH(iface, &conf->iface_list, entry) {
		if_del(iface);
	}
	mrt_done(conf->mroute_socket);

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == rde_pid) ? "route decision engine" :
			    "dvmrp engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(iev_dvmrpe);
	free(iev_rde);

	log_info("terminating");
	exit(0);
}

/* imsg handling */
void
main_dispatch_dvmrpe(int fd, short event, void *bula)
{
	struct imsgev	*iev = bula;
	struct imsgbuf  *ibuf = &iev->ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 shut = 0, verbose;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_RELOAD:
			log_debug("main_dispatch_dvmrpe: IMSG_CTL_RELOAD");
			/* reconfig */
			break;
		case IMSG_CTL_MFC_COUPLE:
			kmr_mfc_couple();
			break;
		case IMSG_CTL_MFC_DECOUPLE:
			kmr_mfc_decouple();
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by dvmrpe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("main_dispatch_dvmrpe: error handling "
			    "imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_dispatch_rde(int fd, short event, void *bula)
{
	struct mfc	 mfc;
	struct imsgev	*iev = bula;
	struct imsgbuf  *ibuf = &iev->ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_MFC_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(mfc))
				fatalx("invalid size of RDE request");
			memcpy(&mfc, imsg.data, sizeof(mfc));

			/* add to MFC */
			mrt_add_mfc(conf->mroute_socket, &mfc);
			break;
		case IMSG_MFC_DEL:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(mfc))
				fatalx("invalid size of RDE request");
			memcpy(&mfc, imsg.data, sizeof(mfc));

			/* remove from MFC */
			mrt_del_mfc(conf->mroute_socket, &mfc);
			break;
		default:
			log_debug("main_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_imsg_compose_dvmrpe(int type, pid_t pid, void *data, u_int16_t datalen)
{
	imsg_compose_event(iev_dvmrpe, type, 0, pid, -1, data, datalen);
}

void
main_imsg_compose_rde(int type, pid_t pid, void *data, u_int16_t datalen)
{
	imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen);
}

void
imsg_event_add(struct imsgev *iev)
{
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, u_int16_t type,
    u_int32_t peerid, pid_t pid, int fd, void *data, u_int16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}
@


1.24
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.23 2016/09/02 15:35:34 renato Exp $ */
d112 1
@


1.23
log
@Close connections when msgbuf_write() returns 0.

Pulled from ospfd. Original author: claudio@@

ok rzalamena@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.22 2016/09/02 15:33:27 renato Exp $ */
d53 1
a53 2
void		dvmrpd_shutdown(void);
int		check_child(pid_t, const char *);
d74 1
a74 5
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */
	int	die = 0;

d78 2
a79 14
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(dvmrpe_pid, "dvmrp engine")) {
			dvmrpe_pid = 0;
			die = 1;
		}
		if (check_child(rde_pid, "route decision engine")) {
			rde_pid = 0;
			die = 1;
		}
		if (die)
			dvmrpd_shutdown();
		break;
d102 1
a102 1
	struct event	 ev_sigint, ev_sigterm, ev_sigchld, ev_sighup;
a221 1
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
a224 1
	signal_add(&ev_sigchld, NULL);
d269 1
a269 1
void
d274 1
d276 5
a280 5
	if (dvmrpe_pid)
		kill(dvmrpe_pid, SIGTERM);

	if (rde_pid)
		kill(rde_pid, SIGTERM);
a284 1

a287 1

d290 1
d292 8
a299 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a301 1
	msgbuf_clear(&iev_dvmrpe->ibuf.w);
a302 1
	msgbuf_clear(&iev_rde->ibuf.w);
a306 20
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
@


1.22
log
@Don't fatal if the imsg pipe is closed, this is often triggered in the
parent and hides the real cause of the termination.

Pulled from ospfd. Original author: claudio@@

ok rzalamena@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.21 2016/02/02 17:51:11 sthen Exp $ */
d362 1
a362 1
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
d364 2
d424 1
a424 1
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
d426 2
@


1.21
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.20 2015/12/05 13:11:00 claudio Exp $ */
d353 1
a353 1
	int		 verbose;
d359 1
a359 1
			fatalx("pipe closed");
d396 7
a402 1
	imsg_event_add(iev);
d413 1
d419 1
a419 1
			fatalx("pipe closed");
d457 7
a463 1
	imsg_event_add(iev);
@


1.20
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.19 2015/02/10 08:49:30 claudio Exp $ */
a232 3

	/* show who we are */
	setproctitle("parent");
@


1.19
log
@More SOCK_NONBLOCK adjustments similar to the other daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.18 2015/02/09 11:45:22 claudio Exp $ */
d359 1
a359 1
		if ((n = imsg_read(ibuf)) == -1)
d412 1
a412 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.18
log
@Kill another session_socket_blockmode() ... 6 or so to go.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.17 2015/01/16 06:40:16 deraadt Exp $ */
d224 2
a225 1
	if ((conf->mroute_socket = socket(AF_INET, SOCK_RAW,
@


1.17
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.16 2014/07/12 19:22:32 krw Exp $ */
d207 2
a208 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2dvmrpe) == -1)
d210 2
a211 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2rde) == -1)
d213 2
a214 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_dvmrpe2rde) == -1)
a215 6
	session_socket_blockmode(pipe_parent2dvmrpe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2dvmrpe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_dvmrpe2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_dvmrpe2rde[1], BM_NONBLOCK);
@


1.16
log
@msgbuf_write() <= 0 for a few more daemons.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.15 2013/11/26 11:32:30 henning Exp $ */
a25 1
#include <sys/param.h>
@


1.15
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.13 2010/02/08 00:36:20 guenther Exp $ */
d369 1
a369 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d422 1
a422 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
@


1.14
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d369 1
a369 1
		if (msgbuf_write(&ibuf->w) == -1)
d422 1
a422 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.13
log
@...and yet another typo copied from ospfd: the ev_sighup event handler
should handle SIGHUP and not SIGTERM.  SIGTERM is already handled by
ev_sigterm.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.12 2010/02/08 00:26:51 guenther Exp $ */
d132 1
d163 1
@


1.12
log
@Use SIGCHLD for the sigchild handler not SIGINT twice.
(This was inherited from ospfd; claudio fixed it there some time ago)
Spotted in ripd by haesbaert <at> haesbaert.org
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.11 2009/11/02 20:31:50 claudio Exp $ */
d245 1
a245 1
	signal_set(&ev_sighup, SIGTERM, main_sig_handler, NULL);
@


1.11
log
@Yet another implementation of IMSG_CTL_LOG_VERBOSE. Similar to the one in
ripd, ospfd and friends. OK michele, henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.10 2009/06/06 07:52:04 pyr Exp $ */
d244 1
a244 1
	signal_set(&ev_sigchld, SIGINT, main_sig_handler, NULL);
@


1.10
log
@make dvmrpd imsg-in-a-lib ready as well.
``put it in'' claudio@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.9 2009/06/01 23:22:58 henning Exp $ */
d148 1
d358 1
d388 5
@


1.9
log
@no endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.8 2009/05/31 20:31:35 jacekm Exp $ */
d67 2
a68 2
struct imsgbuf		*ibuf_dvmrpe;
struct imsgbuf		*ibuf_rde;
d257 2
a258 2
	if ((ibuf_dvmrpe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL)
d260 4
a263 2
	imsg_init(ibuf_dvmrpe, pipe_parent2dvmrpe[0], main_dispatch_dvmrpe);
	imsg_init(ibuf_rde, pipe_parent2rde[0], main_dispatch_rde);
d266 9
a274 9
	ibuf_dvmrpe->events = EV_READ;
	event_set(&ibuf_dvmrpe->ev, ibuf_dvmrpe->fd, ibuf_dvmrpe->events,
	    ibuf_dvmrpe->handler, ibuf_dvmrpe);
	event_add(&ibuf_dvmrpe->ev, NULL);

	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);
d320 4
a323 4
	msgbuf_clear(&ibuf_dvmrpe->w);
	free(ibuf_dvmrpe);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
d353 2
a354 1
	struct imsgbuf  *ibuf = bula;
d394 1
a394 1
	imsg_event_add(ibuf);
d401 2
a402 1
	struct imsgbuf  *ibuf = bula;
d448 1
a448 1
	imsg_event_add(ibuf);
d454 1
a454 1
	imsg_compose(ibuf_dvmrpe, type, 0, pid, data, datalen);
d460 1
a460 1
	imsg_compose(ibuf_rde, type, 0, pid, data, datalen);
a462 1
/* this needs to be added here so that dvmrpctl can be used without libevent */
d464 1
a464 1
imsg_event_add(struct imsgbuf *ibuf)
d466 19
a484 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
@


1.8
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.7 2009/05/31 17:13:04 claudio Exp $ */
a195 2

	endpwent();
@


1.7
log
@More libevent callback fixes. While there make n also ssize_t as in all
other daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.6 2008/05/12 19:15:02 pyr Exp $ */
a365 1
		imsg_event_add(ibuf);
a412 1
		imsg_event_add(ibuf);
@


1.6
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.5 2007/10/20 13:26:50 pyr Exp $ */
d355 1
a355 1
	int		 n;
d357 1
a357 2
	switch (event) {
	case EV_READ:
d362 2
a363 2
		break;
	case EV_WRITE:
a366 3
		return;
	default:
		fatalx("unknown event");
d403 1
a403 1
	int		 n;
d405 1
a405 2
	switch (event) {
	case EV_READ:
d410 2
a411 2
		break;
	case EV_WRITE:
a414 3
		return;
	default:
		fatalx("unknown event");
@


1.5
log
@Sync parse.y with recent enhancements in hoststated.
Fix behavior when running -n.
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.4 2007/10/13 16:35:20 deraadt Exp $ */
d154 5
@


1.4
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.3 2007/01/24 09:57:51 norby Exp $ */
d131 1
a131 2
	/* start logging */
	log_init(1);
d193 3
@


1.3
log
@Ignore SIGPIPE in the parent and RDE as well.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.2 2006/06/01 22:07:30 claudio Exp $ */
a61 2
int	check_file_secrecy(int, const char *);

a461 23
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
@


1.2
log
@More kroute.c cleanup and start using the routing socket to track interface
states.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvmrpd.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d246 1
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d271 2
@

