head	1.23;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.01.08.23.04.42;	author krw;	state Exp;
branches;
next	1.22;
commitid	T1ZdV0xhVeBLIhr0;

1.22
date	2015.12.07.19.14.49;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	AdGyxnW7jQntaErG;

1.21
date	2015.12.05.13.11.00;	author claudio;	state Exp;
branches;
next	1.20;
commitid	IgfRve2khGGqPTCy;

1.20
date	2015.02.09.11.45.22;	author claudio;	state Exp;
branches;
next	1.19;
commitid	k1i5i8dXVxLjUfN3;

1.19
date	2014.07.11.16.43.33;	author krw;	state Exp;
branches;
next	1.18;
commitid	TgA9QmI8ib2B7iAZ;

1.18
date	2013.11.26.11.32.30;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.11.08.34.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.10.07.56.54;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.14.11.52.19;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.21.20.53.20;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.08.15.54.50;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.02.20.31.50;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.06.07.52.04;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.20.31.35;	author jacekm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.17.13.04;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.25.17.09.55;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.31.12.17.35;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.19.10.13.20;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.23.17.42.33;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@/*	$OpenBSD: control.c,v 1.22 2015/12/07 19:14:49 mmcc Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "igmp.h"
#include "dvmrpd.h"
#include "dvmrp.h"
#include "dvmrpe.h"
#include "log.h"
#include "control.h"

#define	CONTROL_BACKLOG	5

struct ctl_conn	*control_connbyfd(int);
struct ctl_conn	*control_connbypid(pid_t);
void		 control_close(int);

int
control_init(void)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    0)) == -1) {
		log_warn("control_init: socket");
		return (-1);
	}

	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, DVMRPD_SOCKET, sizeof(sun.sun_path));

	if (unlink(DVMRPD_SOCKET) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", DVMRPD_SOCKET);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("control_init: bind: %s", DVMRPD_SOCKET);
		close(fd);
		umask(old_umask);
		return (-1);
	}
	umask(old_umask);

	if (chmod(DVMRPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init: chmod");
		close(fd);
		(void)unlink(DVMRPD_SOCKET);
		return (-1);
	}

	control_state.fd = fd;

	return (0);
}

int
control_listen(void)
{

	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

	event_set(&control_state.ev, control_state.fd, EV_READ,
	    control_accept, NULL);
	event_add(&control_state.ev, NULL);
	evtimer_set(&control_state.evt, control_accept, NULL);

	return (0);
}

void
control_cleanup(void)
{
	event_del(&control_state.ev);
	event_del(&control_state.evt);
	unlink(DVMRPD_SOCKET);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *bula)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&control_state.ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd, (struct sockaddr *)&sun, &len,
	    SOCK_NONBLOCK | SOCK_CLOEXEC)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&control_state.ev);
			evtimer_add(&control_state.evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("control_accept: accept");
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, &c->iev);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.pid == pid)
			break;
	}

	return (c);
}

void
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_close: fd %d: not found", fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&control_state.evt, NULL)) {
		evtimer_del(&control_state.evt);
		event_add(&control_state.ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *bula)
{
	struct ctl_conn	*c;
	struct imsg	 imsg;
	int		 n;
	unsigned int	 ifidx;
	int		 verbose;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1  && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd);
			return;
		}

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_MFC_COUPLE:
		case IMSG_CTL_MFC_DECOUPLE:
		case IMSG_CTL_RELOAD:
			dvmrpe_imsg_compose_parent(imsg.hdr.type, 0, NULL, 0);
			break;
		case IMSG_CTL_SHOW_IFACE:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(ifidx)) {
				memcpy(&ifidx, imsg.data, sizeof(ifidx));
				dvmrpe_iface_ctl(c, ifidx);
				imsg_compose_event(&c->iev, IMSG_CTL_END, 0,
				    0, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_SHOW_IGMP:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(ifidx)) {
				memcpy(&ifidx, imsg.data, sizeof(ifidx));
				dvmrpe_iface_igmp_ctl(c, ifidx);
				imsg_compose_event(&c->iev, IMSG_CTL_END, 0,
				    0, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_SHOW_NBR:
			dvmrpe_nbr_ctl(c);
			break;
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_MFC:
		case IMSG_CTL_SHOW_SUM:
			c->iev.ibuf.pid = imsg.hdr.pid;
			dvmrpe_imsg_compose_rde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(verbose))
				break;

			/* forward to other processes */
			dvmrpe_imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			dvmrpe_imsg_compose_rde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose_event(&c->iev, imsg->hdr.type, 0, imsg->hdr.pid,
	    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
}
@


1.22
log
@Replace bzero with memset, and change a strings.h include to string.h to
get the declaration. From Serguey Parkhomovsky. No objects from
deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2015/12/05 13:11:00 claudio Exp $ */
d164 4
a167 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
d177 4
a180 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.21
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2015/02/09 11:45:22 claudio Exp $ */
d55 1
a55 1
	bzero(&sun, sizeof(sun));
@


1.20
log
@Kill another session_socket_blockmode() ... 6 or so to go.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2014/07/11 16:43:33 krw Exp $ */
d224 2
a225 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.19
log
@Close the control fd when it has reported EOF.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2013/11/26 11:32:30 henning Exp $ */
d49 2
a50 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a81 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d126 2
a127 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a142 2
	session_socket_blockmode(connfd, BM_NONBLOCK);

a313 17
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.18
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2012/04/11 08:34:41 deraadt Exp $ */
d232 1
a232 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1 && errno != EAGAIN) {
@


1.17
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d232 1
a232 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1) {
@


1.16
log
@delete excessive evtimer_pending; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2012/04/10 07:56:54 deraadt Exp $ */
d137 2
a138 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.15
log
@Handle file descriptor exhaustion in the accept() case.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2010/09/02 14:03:21 sobrado Exp $ */
d108 1
a108 2
	if (evtimer_pending(&control_state.evt, NULL))
		event_del(&control_state.evt);
@


1.14
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2010/05/14 11:52:19 claudio Exp $ */
d96 1
a96 1
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
d99 1
d107 3
d122 4
d129 10
a138 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d200 7
@


1.13
log
@Use calloc() instead of malloc() to allocate the connection structure. This
way the memory is zeroed. This is equivalent to the relayd commit by reyk.
OK reyk, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2010/02/21 20:53:20 michele Exp $ */
d270 1
a270 1
			break;		
@


1.12
log
@Kill double declaration of control_imsg_relay().

From Christiano F. Haesbaert.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2009/12/08 15:54:50 jsg Exp $ */
d128 1
a128 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.11
log
@porcesses -> processes
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2009/12/02 19:10:02 mk Exp $ */
a36 2

int control_imsg_relay(struct imsg *imsg);
@


1.10
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2009/11/02 20:31:50 claudio Exp $ */
d264 1
a264 1
			/* forward to other porcesses */
@


1.9
log
@Yet another implementation of IMSG_CTL_LOG_VERBOSE. Similar to the one in
ripd, ospfd and friends. OK michele, henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2009/06/06 07:52:04 pyr Exp $ */
d124 1
a124 1
			log_warn("control_accept");
@


1.8
log
@make dvmrpd imsg-in-a-lib ready as well.
``put it in'' claudio@@, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2009/05/31 20:31:35 jacekm Exp $ */
d196 1
d259 14
@


1.7
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2009/05/31 17:13:04 claudio Exp $ */
d136 6
a141 5
	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, &c->ibuf);
	event_add(&c->ibuf.ev, NULL);
d151 1
a151 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d163 1
a163 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
d180 1
a180 1
	msgbuf_clear(&c->ibuf.w);
d183 2
a184 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d203 1
a203 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d209 1
a209 1
		if (msgbuf_write(&c->ibuf.w) == -1) {
d216 1
a216 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d235 2
a236 2
				imsg_compose(&c->ibuf, IMSG_CTL_END, 0,
				    0, NULL, 0);
d244 2
a245 2
				imsg_compose(&c->ibuf, IMSG_CTL_END, 0,
				    0, NULL, 0);
d254 1
a254 1
			c->ibuf.pid = imsg.hdr.pid;
d266 1
a266 1
	imsg_event_add(&c->ibuf);
d277 2
a278 2
	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
@


1.6
log
@More libevent callback fixes. While there make n also ssize_t as in all
other daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2009/02/25 17:09:55 claudio Exp $ */
a211 1
		imsg_event_add(&c->ibuf);
@


1.5
log
@Fix an invalid pointer dereference in control_close(). If control_connbyfd()
fails -- which should never happen -- the function does not return and is
accession the NULL set control pointer later on.
Found by Matthew Haub. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2008/01/31 12:17:35 henning Exp $ */
d201 1
a201 2
	switch (event) {
	case EV_READ:
d206 3
a208 3
		break;
	case EV_WRITE:
		if (msgbuf_write(&c->ibuf.w) < 0) {
a212 3
		return;
	default:
		fatalx("unknown event");
@


1.4
log
@do not leak confd on malloc failure in control_accept()
found by Igor Zinovik <zinovik@@cs.karelia.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2007/03/19 10:13:20 henning Exp $ */
d174 1
a174 1
	if ((c = control_connbyfd(fd)) == NULL)
d176 2
@


1.3
log
@do not signal "connection closed" upstream on EINTR/EAGAIN, from bgpd et al
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2007/01/23 17:42:33 claudio Exp $ */
d132 1
@


1.2
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2006/06/01 14:12:20 norby Exp $ */
d200 1
a200 1
		if ((n = imsg_read(&c->ibuf)) <= 0) {
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d288 1
a288 1
		fatal("fnctl F_GETFL");
d296 1
a296 1
		fatal("fnctl F_SETFL");
@

