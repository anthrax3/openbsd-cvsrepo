head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.6
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.32
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.31;
commitid	3AKCl24jEn0sIt6p;

1.31
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.30;
commitid	uzjOUwLRoN7KbcZI;

1.30
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.29;
commitid	AL6SnrmnHkmPOpjv;

1.29
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.28;
commitid	3Z7yItGpFsmshk0c;

1.28
date	2014.11.14.03.20.36;	author doug;	state Exp;
branches;
next	1.27;
commitid	M08zdkdK3z1pxKwF;

1.27
date	2014.11.03.16.55.59;	author bluhm;	state Exp;
branches;
next	1.26;
commitid	SvRBB6vjZmF8ZSzf;

1.26
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.25.12.54.14;	author benno;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.21.04.33.41;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.04.13.11.45;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.31.21.03.48;	author tobias;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.07.16.37.04;	author michele;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.17.14.32.47;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.02.08.52.30;	author norby;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.27.15.36.42;	author mpf;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.20.13.26.50;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.13.16.35.20;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.12.02.07.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.11.23.06.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.11.22.15.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.21.19.33.48;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.25.18.55.41;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.25.18.52.13;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.14.12.20;	author norby;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@/*	$OpenBSD: parse.y,v 1.31 2017/01/05 12:42:18 krw Exp $ */

/*
 * Copyright (c) 2004, 2005, 2006 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <unistd.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include "igmp.h"
#include "dvmrp.h"
#include "dvmrpd.h"
#include "dvmrpe.h"
#include "log.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

static struct dvmrpd_conf	*conf;
char				*start_state;
struct iface			*iface = NULL;

static struct {
	u_int32_t	 probe_interval;
	u_int32_t	 query_interval;
	u_int32_t	 query_resp_interval;
	u_int32_t	 startup_query_interval;
	u_int32_t	 startup_query_cnt;
	u_int32_t	 last_member_query_interval;
	u_int32_t	 last_member_query_cnt;
	u_int32_t	 dead_interval;
	u_int16_t	 metric;
	u_int8_t	 robustness;
	u_int8_t	 igmp_version;
} *defs, *grdefs, globaldefs, groupdefs, ifacedefs;

void		 clear_config(struct dvmrpd_conf *xconf);
struct iface	*conf_get_if(struct kif *);
struct iface	*new_group(void);

typedef struct {
	union {
		int64_t		 number;
		char		*string;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	INTERFACE FIBUPDATE
%token	GROUP
%token	METRIC PASSIVE
%token	ROBUSTNESS QUERYINTERVAL QUERYRESPINTERVAL
%token	STARTUPQUERYINTERVAL STARTUPQUERYCNT
%token	LASTMEMBERQUERYINTERVAL LASTMEMBERQUERYCNT
%token	IGMPVERSION
%token	ERROR
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.number>	yesno
%type	<v.string>	string

%%

grammar		: /* empty */
		| grammar '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar interface '\n'
		| grammar group '\n'
		| grammar error '\n'		{ file->errors++; }
		;

string		: string STRING {
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

yesno		: STRING {
			if (!strcmp($1, "yes"))
				$$ = 1;
			else if (!strcmp($1, "no"))
				$$ = 0;
			else {
				yyerror("syntax error, "
				    "either yes or no expected");
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

varset		: STRING '=' string		{
			char *s = $1;
			if (conf->opts & DVMRPD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

conf_main	: FIBUPDATE yesno {
			if ($2 == 0)
				conf->flags |= DVMRPD_FLAG_NO_FIB_UPDATE;
			else
				conf->flags &= ~DVMRPD_FLAG_NO_FIB_UPDATE;
		}
		| defaults
		;

defaults	: LASTMEMBERQUERYCNT NUMBER {
			if ($2 < MIN_LAST_MEMBER_QUERY_CNT ||
			    $2 > MAX_LAST_MEMBER_QUERY_CNT) {
				yyerror("last-member-query-count out of "
				    "range (%d-%d)",
				    MIN_LAST_MEMBER_QUERY_CNT,
				    MAX_LAST_MEMBER_QUERY_CNT);
				YYERROR;
			}
			defs->last_member_query_cnt = $2;
		}
		| LASTMEMBERQUERYINTERVAL NUMBER {
			if ($2 < MIN_LAST_MEMBER_QUERY_INTERVAL ||
			    $2 > MAX_LAST_MEMBER_QUERY_INTERVAL) {
				yyerror("last-member-query-interval out of "
				    "range (%d-%d)",
				    MIN_LAST_MEMBER_QUERY_INTERVAL,
				    MAX_LAST_MEMBER_QUERY_INTERVAL);
				YYERROR;
			}
			defs->last_member_query_interval = $2;
		}
		| METRIC NUMBER {
			if ($2 < MIN_METRIC || $2 > MAX_METRIC) {
				yyerror("metric out of range (%d-%d)",
				    MIN_METRIC, MAX_METRIC);
				YYERROR;
			}
			defs->metric = $2;
		}
		| QUERYINTERVAL NUMBER {
			if ($2 < MIN_QUERY_INTERVAL ||
			    $2 > MAX_QUERY_INTERVAL) {
				yyerror("query-interval out of range (%d-%d)",
				    MIN_QUERY_INTERVAL, MAX_QUERY_INTERVAL);
				YYERROR;
			}
			defs->query_interval = $2;
		}
		| QUERYRESPINTERVAL NUMBER {
			if ($2 < MIN_QUERY_RESP_INTERVAL ||
			    $2 > MAX_QUERY_RESP_INTERVAL) {
				yyerror("query-response-interval out of "
				    "range (%d-%d)",
				    MIN_QUERY_RESP_INTERVAL,
				    MAX_QUERY_RESP_INTERVAL);
				YYERROR;
			}
			defs->query_resp_interval = $2;
		}
		| ROBUSTNESS NUMBER {
			if ($2 < MIN_ROBUSTNESS || $2 > MAX_ROBUSTNESS) {
				yyerror("robustness out of range (%d-%d)",
				    MIN_ROBUSTNESS, MAX_ROBUSTNESS);
				YYERROR;
			}
			defs->robustness = $2;
		}
		| STARTUPQUERYCNT NUMBER {
			if ($2 < MIN_STARTUP_QUERY_CNT ||
			    $2 > MAX_STARTUP_QUERY_CNT) {
				yyerror("startup-query-count out of "
				    "range (%d-%d)",
				    MIN_STARTUP_QUERY_CNT,
				    MAX_STARTUP_QUERY_CNT);
				YYERROR;
			}
			defs->startup_query_cnt = $2;
		}
		| STARTUPQUERYINTERVAL NUMBER {
			if ($2 < MIN_STARTUP_QUERY_INTERVAL ||
			    $2 > MAX_STARTUP_QUERY_INTERVAL) {
				yyerror("startup-query-interval out of "
				    "range (%d-%d)",
				    MIN_STARTUP_QUERY_INTERVAL,
				    MAX_STARTUP_QUERY_INTERVAL);
				YYERROR;
			}
			defs->startup_query_interval = $2;
		}
		| IGMPVERSION NUMBER {
			if ($2 < MIN_IGMP_VERSION ||
			    $2 > MAX_IGMP_VERSION) {
				yyerror("igmp-version out of range (%d-%d)",
				    MIN_IGMP_VERSION, MAX_IGMP_VERSION);
				YYERROR;
			}
			defs->igmp_version = $2;
		}
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

interface	: INTERFACE STRING	{
			struct kif *kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			iface = conf_get_if(kif);
			if (iface == NULL)
				YYERROR;
			LIST_INSERT_HEAD(&conf->iface_list, iface, entry);

			memcpy(&ifacedefs, defs, sizeof(ifacedefs));
			defs = &ifacedefs;
		} interface_block {
			iface->probe_interval = defs->probe_interval;
			iface->query_interval = defs->query_interval;
			iface->query_resp_interval = defs->query_resp_interval;
			iface->startup_query_interval =
			    defs->startup_query_interval;
			iface->startup_query_cnt = defs->startup_query_cnt;
			iface->last_member_query_interval =
			    defs->last_member_query_interval;
			iface->last_member_query_cnt =
			    defs->last_member_query_cnt;
			iface->dead_interval = defs->dead_interval;
			iface->metric = defs->metric;
			iface->robustness = defs->robustness;
			iface->igmp_version = defs->igmp_version;
			if (grdefs)
				defs = grdefs;
			else
				defs = &globaldefs;
			iface = NULL;
		}
		;

interface_block	: '{' optnl interfaceopts_l '}'
		| '{' optnl '}'
		|
		;

interfaceopts_l	: interfaceopts_l interfaceoptsl
		| interfaceoptsl
		;

interfaceoptsl	: PASSIVE nl		{ iface->passive = 1; }
		| defaults nl
		;

group		: GROUP optnl '{' optnl {
			memcpy(&groupdefs, defs, sizeof(groupdefs));
			grdefs = defs = &groupdefs;
		}
		    groupopts_l '}' {
			grdefs = NULL;
			defs = &globaldefs;
		}
		;

groupopts_l	: groupopts_l groupoptsl
		| groupoptsl
		;

groupoptsl	: interface nl
		| defaults nl
		| error nl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{"fib-update",			FIBUPDATE},
		{"group",			GROUP},
		{"igmp-version",		IGMPVERSION},
		{"interface",			INTERFACE},
		{"last-member-query-count",	LASTMEMBERQUERYCNT},
		{"last-member-query-interval",	LASTMEMBERQUERYINTERVAL},
		{"metric",			METRIC},
		{"passive",			PASSIVE},
		{"query-interval",		QUERYINTERVAL},
		{"query-response-interval",	QUERYRESPINTERVAL},
		{"robustness",			ROBUSTNESS},
		{"startup-query-count",		STARTUPQUERYCNT},
		{"startup-query-interval",	STARTUPQUERYINTERVAL}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct dvmrpd_conf *
parse_config(char *filename, int opts)
{
	int		 errors = 0;
	struct sym	*sym, *next;
	struct timeval	 now;

	if ((conf = calloc(1, sizeof(struct dvmrpd_conf))) == NULL) {
		errx(1, "parse_config calloc");
		return (NULL);
	}

	defs = &globaldefs;
	defs->probe_interval = DEFAULT_PROBE_INTERVAL;
	defs->last_member_query_cnt = DEFAULT_LAST_MEMBER_QUERY_CNT;
	defs->last_member_query_interval = DEFAULT_LAST_MEMBER_QUERY_INTERVAL;
	defs->metric = DEFAULT_METRIC;
	defs->query_interval = DEFAULT_QUERY_INTERVAL;
	defs->query_resp_interval = DEFAULT_QUERY_RESP_INTERVAL;
	defs->robustness = DEFAULT_ROBUSTNESS;
	defs->startup_query_cnt = DEFAULT_STARTUP_QUERY_CNT;
	defs->startup_query_interval = DEFAULT_STARTUP_QUERY_INTERVAL;
	defs->igmp_version = DEFAULT_IGMP_VERSION;
	defs->dead_interval = NBR_TMOUT;

	if ((file = pushfile(filename, 1)) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;

	gettimeofday(&now, NULL);
	conf->gen_id = (u_int32_t)now.tv_sec;	/* for a while after 2038 */
	conf->opts = opts;

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((conf->opts & DVMRPD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (errors) {
		clear_config(conf);
		return (NULL);
	}

	return (conf);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

struct iface *
conf_get_if(struct kif *kif)
{
	struct iface	*i;

	if (kif->ifindex >= MAXVIFS) {
		yyerror("interface %s index too large", kif->ifname);
		return (NULL);
	}

	LIST_FOREACH(i, &conf->iface_list, entry)
		if (i->ifindex == kif->ifindex) {
			yyerror("interface %s already configured",
			    kif->ifname);
			return (NULL);
		}

	i = if_new(kif);
	i->passive = 0;
	i->recv_query_resp_interval = DEFAULT_QUERY_RESP_INTERVAL;

	return (i);
}

void
clear_config(struct dvmrpd_conf *xconf)
{
	/* XXX clear conf */
		/* ... */
}
@


1.31
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2016/06/21 21:35:24 benno Exp $ */
d770 1
a770 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.30
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2014/11/20 05:51:20 jsg Exp $ */
d796 4
a799 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d858 1
a858 1
	TAILQ_FOREACH(sym, &symhead, entry)
d863 1
@


1.29
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2014/11/14 03:20:36 doug Exp $ */
d166 1
d169 7
@


1.28
log
@Add gcc printf format attributes to yyerror() in parse.y files.
No yyerror() calls needed to be changed.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2014/11/03 16:55:59 bluhm Exp $ */
d573 3
@


1.27
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK benno@@ doug@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2014/01/22 00:21:16 henning Exp $ */
d61 3
a63 1
int		 yyerror(const char *, ...);
@


1.26
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2013/04/21 04:33:41 deraadt Exp $ */
d362 1
a362 1
	char		*nfmt;
d366 2
a367 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d369 2
a370 1
	free(nfmt);
@


1.25
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d663 2
a664 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.24
log
@the DVMRP protocol generation number can work beyond 2038 because it
is unsigned.  Cast it specifically, with a comment, to make this more
clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2013/03/06 21:42:40 sthen Exp $ */
d412 1
a412 1
char	*parsebuf;
d414 1
a414 1
char	 pushback_buffer[MAXPUSHBACK];
d507 2
a508 2
	char	 buf[8096];
	char	*p, *val;
d531 1
a531 1
				*p++ = (char)c;
d576 1
a576 1
			*p++ = (char)c;
@


1.23
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2010/12/31 21:22:42 guenther Exp $ */
a747 1
	/* Generation ID must be non decreasing */
d749 1
a749 1
	conf->gen_id = now.tv_sec;
@


1.22
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2010/08/03 18:42:40 henning Exp $ */
d361 2
a362 1
	va_list	ap;
d366 3
a368 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d370 1
@


1.21
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2009/09/04 13:11:45 claudio Exp $ */
d34 1
@


1.20
log
@Dvrmpd inherited the same yesno porblem from bgpd. Make sure it throws
a proper syntax error.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2009/03/31 21:03:48 tobias Exp $ */
d560 2
a561 1
				else if (next == '\n')
d563 1
a563 1
				else
@


1.19
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2008/12/07 16:37:04 michele Exp $ */
d153 2
@


1.18
log
@Kill src_node structure. It is mostly redundant with rt_node and
adds unneeded complexity. Move any stuff to rt_node structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2008/10/17 14:32:47 henning Exp $ */
d669 1
a669 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d671 5
@


1.17
log
@bring in findeol() fix from pfctl
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2008/07/02 08:52:30 norby Exp $ */
a741 1
	RB_INIT(&conf->src_list);
@


1.16
log
@Prevent dvmrpd from using illegal ifindex's.
Report and fix from Matthew Dempsky.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2008/02/27 15:36:42 mpf Exp $ */
a481 1
	pushback_index = 0;
d485 4
a488 1
		c = lgetc(0);
@


1.15
log
@Unbreak parser by initializing topfile correctly.
I got fooled by patch(1). Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2008/02/26 10:09:58 mpf Exp $ */
d846 5
@


1.14
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2007/11/12 23:59:41 mpf Exp $ */
a715 1
	topfile = file;
d734 1
@


1.13
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2007/10/20 13:26:50 pyr Exp $ */
d54 1
a54 1
} *file;
d433 3
a435 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d453 1
a453 1
		if (popfile() == EOF)
d694 1
a694 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d696 7
a702 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d716 1
@


1.12
log
@Sync parse.y with recent enhancements in hoststated.
Fix behavior when running -n.
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2007/10/16 20:01:23 mpf Exp $ */
a449 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d506 1
a506 1
	while ((c = lgetc(0)) == ' ')
@


1.11
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2007/10/16 06:06:49 deraadt Exp $ */
d675 2
a676 1
	    (nfile->name = strdup(name)) == NULL)
d678 1
d680 1
a738 1
		warn("%s", filename);
@


1.10
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2007/10/13 16:35:20 deraadt Exp $ */
d584 1
a584 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.9
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2007/10/11 14:39:17 deraadt Exp $ */
d561 1
a561 1
				if (next == quotec)
d563 2
@


1.8
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2007/09/12 02:07:07 deraadt Exp $ */
d27 1
d34 1
d47 31
a78 4
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
char				*infile;
d80 1
a80 13

struct iface	*iface = NULL;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
void	 clear_config(struct dvmrpd_conf *xconf);
int	 check_file_secrecy(int fd, const char *fname);
d96 3
a98 13
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};

int			 symset(const char *, const char *, int);
char			*symget(const char *);
struct iface		*conf_get_if(struct kif *);
struct iface		*new_group(void);
d131 1
a131 1
		| grammar error '\n'		{ errors++; }
d134 1
a134 1
string		: string STRING	{
d360 1
a360 1
	errors = 1;
d362 1
a362 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
d413 1
a413 1
lgetc(int inquot)
d415 1
a415 2
	int	c, next;
	FILE *f = fin;
d431 7
a437 2
	if (inquot) {
		c = getc(f);
d441 2
a442 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d447 2
a448 2
		yylval.lineno = lineno;
		lineno++;
d453 1
a453 1
			c = getc(f);
d455 1
a455 1
		ungetc(c, f);
d459 5
d495 1
a495 1
			lineno++;
d509 1
a509 1
	int	 endc, next, c;
d517 1
a517 1
	yylval.lineno = lineno;
d551 1
a551 1
		endc = c;
d553 1
a553 1
			if ((c = lgetc(1)) == EOF)
d556 1
a556 1
				lineno++;
d559 1
a559 1
				if ((next = lgetc(1)) == EOF)
d561 1
a561 1
				if (next == endc)
d565 1
a565 1
			} else if (c == endc) {
d639 2
a640 2
		yylval.lineno = lineno;
		lineno++;
d647 61
d711 1
d733 1
a733 1
	if ((fin = fopen(filename, "r")) == NULL) {
a737 1
	infile = filename;
a744 6
	if (check_file_secrecy(fileno(fin), filename)) {
		fclose(fin);
		free(conf);
		return (NULL);
	}

d746 2
a747 2

	fclose(fin);
d751 1
a751 1
		next = TAILQ_NEXT(sym, entries);
d758 1
a758 1
			TAILQ_REMOVE(&symhead, sym, entries);
d777 1
a777 1
	    sym = TAILQ_NEXT(sym, entries))
d786 1
a786 1
			TAILQ_REMOVE(&symhead, sym, entries);
d806 1
a806 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d837 1
a837 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2007/09/11 23:06:37 deraadt Exp $ */
d58 1
a58 1
int	 lgetc(FILE *);
d406 1
a406 1
lgetc(FILE *f)
d409 1
d425 5
d433 1
a433 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
d477 1
a477 1
		c = lgetc(fin);
d493 1
a493 1
	int	 endc, c;
d498 1
a498 1
	while ((c = lgetc(fin)) == ' ')
d503 1
a503 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d507 1
a507 1
			if ((c = lgetc(fin)) == EOF)
d537 1
a537 1
			if ((c = lgetc(fin)) == EOF)
a538 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d542 10
d561 1
a561 1
			errx(1, "yylex: strdup");
d575 1
a575 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
d614 1
a614 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.6
log
@macro argument unused, using local instead; spotted by mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2007/09/11 22:15:20 deraadt Exp $ */
d174 1
a174 1
			     $2 > MAX_LAST_MEMBER_QUERY_CNT) {
d185 1
a185 1
			     $2 > MAX_LAST_MEMBER_QUERY_INTERVAL) {
d204 1
a204 1
			     $2 > MAX_QUERY_INTERVAL) {
d213 1
a213 1
			     $2 > MAX_QUERY_RESP_INTERVAL) {
d232 1
a232 1
			     $2 > MAX_STARTUP_QUERY_CNT) {
d243 1
a243 1
			     $2 > MAX_STARTUP_QUERY_INTERVAL) {
d254 1
a254 1
			     $2 > MAX_IGMP_VERSION) {
@


1.5
log
@extend lex to spot numbers in the stream, without impacting the parsing
of ip addresses and such.  this change is being pushed into all the pfctl
derived parsers, starting with the easy ones;  ok claudio michele
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2007/03/21 19:33:48 michele Exp $ */
d556 1
a556 1
	(isspace(x) || c == ')' || c ==',' || c == '/' || c == '}')
@


1.4
log
@Added code to parse unicast routes learned from route report packets.
Now we are able to select correctly designated forwarders and downstream
dependent routers per interface.

Tested and OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2006/10/25 18:55:41 henning Exp $ */
d95 1
a95 1
		u_int32_t	 number;
d112 2
a113 1
%type	<v.number>	number yesno
a126 15
number		: STRING {
			u_int32_t	 uval;
			const char	*errstr;

			uval = strtonum($1, 0, UINT_MAX, &errstr);
			if (errstr) {
				yyerror("number %s is %s", $1, errstr);
				free($1);
				YYERROR;
			} else
				$$ = uval;
			free($1);
		}
		;

d172 1
a172 1
defaults	: LASTMEMBERQUERYCNT number {
d183 1
a183 1
		| LASTMEMBERQUERYINTERVAL number {
d194 1
a194 1
		| METRIC number {
d202 1
a202 1
		| QUERYINTERVAL number {
d211 1
a211 1
		| QUERYRESPINTERVAL number {
d222 1
a222 1
		| ROBUSTNESS number {
d230 1
a230 1
		| STARTUPQUERYCNT number {
d241 1
a241 1
		| STARTUPQUERYINTERVAL number {
d252 1
a252 1
		| IGMPVERSION number {
d553 36
@


1.3
log
@strtonum, Pierre-Yves Ritschard <pyr@@spootnik.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2006/10/25 18:52:13 henning Exp $ */
d634 1
@


1.2
log
@remove unused debug crap, that years ago accidently hit the tree with
bgpd (2004 :)), and spread ;(
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2006/06/01 14:12:20 norby Exp $ */
a89 1
int			 atoul(char *, u_long *);
d127 2
a128 1
			u_long	ulval;
d130 3
a132 2
			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
d136 1
a136 1
				$$ = ulval;
a738 16
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
@


1.1
log
@Welcome dvmrpd
started by Esben Norby some time ago by using the imsg/three process framework
of ospfd.
Right now it is not particularly useful, major parts are still missing but is
imported to allow more people to work on it.

Status:

The IGMP part is mostly complete, allowing clients to join and leave groups.
Election the IGMP querier of a network is also functional, only thing missing is
some corner cases when going from non-querier to querier.

About half of the DVMRP is functional, probes and route reports are functional.

Multicast streams can be detected and the MFC can be manipulated.
The RIB is not complete but operational.

Not yet connected to the builds.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a48 1
static int			 pdebug = 1;
d405 1
a405 3
	if (p) {
		if (pdebug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
d407 1
a407 3
	} else {
		if (pdebug > 1)
			fprintf(stderr, "string: %s\n", s);
a408 1
	}
@

