head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.11.12.22.33.07;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	yL2gco0cO8wLO0qe;

1.27
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	z3HrihslRYb4HqW9;

1.26
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	F55lwc3gS4GN2mLs;

1.25
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2013.11.12.22.27.12;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.11.16.42.19;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.04.23.18.18.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.17.20.30.17;	author sobrado;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.02.15.19.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.04.17.14.45;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.25.20.22.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.02.00.50.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.25.23.28.16;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.26.19.47.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.25.21.18.24;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.21.04.23.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.07.03.55.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.06.18.29.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.09.22.05.04.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.08.06.20.41.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.08.19.43.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.08.32.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.11.04.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.40.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@use symbolics for flags to open
from Ricardo Mestre
@
text
@/*	$OpenBSD: quot.c,v 1.27 2015/08/20 22:39:29 deraadt Exp $	*/

/*
 * Copyright (C) 1991, 1994 Wolfgang Solfrank.
 * Copyright (C) 1991, 1994 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE */
#include <sys/mount.h>
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <unistd.h>

/* some flags of what to do: */
static char estimate;
static char count;
static char unused;
static void (*func)(int, struct fs *, char *);
static int cmpusers(const void *, const void *);
void	quot(char *, char *);
static long blocksize;
static char *header;
static int headerlen;

/*
 * Original BSD quot doesn't round to number of frags/blocks,
 * doesn't account for indirection blocks and gets it totally
 * wrong if the	size is a multiple of the blocksize.
 * The new code always counts the number of DEV_BSIZE byte blocks
 * instead of the number of kilobytes and converts them	to
 * KByte when done (on request).
 */
#ifdef	COMPAT
#define	SIZE(n)	(n)
#else
#define	SIZE(n)	(howmany(((off_t)(n)) * DEV_BSIZE, blocksize))
#endif

#define	INOCNT(fs)	((fs)->fs_ipg)
#define	INOSZ(fs)	(((fs)->fs_magic == FS_UFS1_MAGIC ? \
			    sizeof(struct ufs1_dinode) : \
			    sizeof(struct ufs2_dinode)) * INOCNT(fs))

union dinode {
	struct ufs1_dinode dp1;
	struct ufs2_dinode dp2;
};
#define	DIP(fs, dp, field) \
	(((fs)->fs_magic == FS_UFS1_MAGIC) ? \
	(dp)->dp1.field : (dp)->dp2.field)

static union dinode *
get_inode(int fd, struct fs *super, ino_t ino)
{
	static caddr_t ipbuf;
	static struct cg *cgp;
	static ino_t last;
	static int cg;
	struct ufs2_dinode *di2;

	if (fd < 0) {		/* flush cache */
		if (ipbuf) {
			free(ipbuf);
			ipbuf = NULL;
			if (super != NULL && super->fs_magic == FS_UFS2_MAGIC) {
				free(cgp);
				cgp = NULL;
			}
		}
		return 0;
	}

	if (!ipbuf || ino < last || ino >= last + INOCNT(super)) {
		if (super->fs_magic == FS_UFS2_MAGIC &&
		    (!cgp || cg != ino_to_cg(super, ino))) {
			cg = ino_to_cg(super, ino);
			if (!cgp && !(cgp = malloc(super->fs_cgsize)))
				errx(1, "allocate cg");
			if (pread(fd, cgp, super->fs_cgsize,
			    (off_t)cgtod(super, cg) << super->fs_fshift)
			    != super->fs_cgsize)
			if (read(fd, cgp, super->fs_cgsize) != super->fs_cgsize)
				err(1, "read cg");
			if (!cg_chkmagic(cgp))
				errx(1, "cg has bad magic");
		}
		if (!ipbuf && !(ipbuf = malloc(INOSZ(super))))
			err(1, "allocate inodes");
		last = (ino / INOCNT(super)) * INOCNT(super);
		if (lseek(fd, (off_t)ino_to_fsba(super, last)
		    << super->fs_fshift, SEEK_SET) < 0 ||
		    read(fd, ipbuf, INOSZ(super)) != INOSZ(super)) {
			err(1, "read inodes");
		}
	}

	if (super->fs_magic == FS_UFS1_MAGIC)
		return ((union dinode *)
		    &((struct ufs1_dinode *)ipbuf)[ino % INOCNT(super)]);
	di2 = &((struct ufs2_dinode *)ipbuf)[ino % INOCNT(super)];
	/* If the inode is unused, it might be unallocated too, so zero it. */
	if (isclr(cg_inosused(cgp), ino % super->fs_ipg))
		memset(di2, 0, sizeof(*di2));
	return ((union dinode *)di2);
}

#ifdef	COMPAT
#define	actualblocks(fs, ip)	(DIP(fs, dp, di_blocks) / 2)
#else
#define	actualblocks(fs, ip)	DIP(fs, dp, di_blocks)
#endif

static int
virtualblocks(struct fs *super, union dinode *dp)
{
	off_t nblk, sz;

	sz = DIP(super, dp, di_size);
#ifdef	COMPAT
	if (lblkno(super, sz) >= NDADDR) {
		nblk = blkroundup(super, sz);
		if (sz == nblk)
			nblk += super->fs_bsize;
	}

	return sz / 1024;
#else	/* COMPAT */

	if (lblkno(super, sz) >= NDADDR) {
		nblk = blkroundup(super, sz);
		sz = lblkno(super, nblk);
		sz = howmany(sz - NDADDR, NINDIR(super));
		while (sz > 0) {
			nblk += sz * super->fs_bsize;
			/* One block on this level is in the inode itself */
			sz = howmany(sz - 1, NINDIR(super));
		}
	} else
		nblk = fragroundup(super, sz);

	return nblk / DEV_BSIZE;
#endif	/* COMPAT */
}

static int
isfree(struct fs *super, union dinode *dp)
{
#ifdef	COMPAT
	return (DIP(super, dp, di_mode) & IFMT) == 0;
#else	/* COMPAT */
	switch (DIP(super, dp, di_mode) & IFMT) {
	case IFIFO:
	case IFLNK:		/* should check FASTSYMLINK? */
	case IFDIR:
	case IFREG:
		return 0;
	case IFCHR:
	case IFBLK:
	case IFSOCK:
	case 0:
		return 1;
	default:
		errx(1, "unknown IFMT 0%o", DIP(super, dp, di_mode) & IFMT);
	}
#endif
}

static struct user {
	uid_t uid;
	char *name;
	daddr_t space;
	long count;
	daddr_t spc30;
	daddr_t spc60;
	daddr_t spc90;
} *users;
static int nusers;

static void
inituser(void)
{
	int i;
	struct user *usr;

	if (!nusers) {
		nusers = 8;
		if (!(users = calloc(nusers, sizeof(struct user)))) {
			err(1, "allocate users");
		}
	} else {
		for (usr = users, i = nusers; --i >= 0; usr++) {
			usr->space = usr->spc30 = usr->spc60 = usr->spc90 = 0;
			usr->count = 0;
		}
	}
}

static void
usrrehash(void)
{
	int i;
	struct user *usr, *usrn;
	struct user *svusr;

	svusr = users;
	nusers <<= 1;
	if (!(users = calloc(nusers, sizeof(struct user))))
		err(1, "allocate users");
	for (usr = svusr, i = nusers >> 1; --i >= 0; usr++) {
		for (usrn = users + (usr->uid&(nusers - 1));
		     usrn->name;
		    usrn--) {
			if (usrn <= users)
				usrn = users + nusers;
		}
		*usrn = *usr;
	}
}

static struct user *
user(uid_t uid)
{
	int i;
	struct passwd *pwd;
	struct user *usr;

	while (1) {
		for (usr = users + (uid&(nusers - 1)), i = nusers;
		     --i >= 0;
		    usr--) {
			if (!usr->name) {
				usr->uid = uid;

				if (!(pwd = getpwuid(uid)))
					asprintf(&usr->name, "#%u", uid);
				else
					usr->name = strdup(pwd->pw_name);
				if (!usr->name)
					err(1, "allocate users");
				return usr;
			} else if (usr->uid == uid)
				return usr;

			if (usr <= users)
				usr = users + nusers;
		}
		usrrehash();
	}
}

static int
cmpusers(const void *v1, const void *v2)
{
	const struct user *u1 = v1, *u2 = v2;

	return u2->space - u1->space;
}

#define	sortusers(users)	(qsort((users), nusers, sizeof(struct user), \
				    cmpusers))

static void
uses(uid_t uid, daddr_t blks, time_t act)
{
	static time_t today;
	struct user *usr;

	if (!today)
		time(&today);

	usr = user(uid);
	usr->count++;
	usr->space += blks;

	if (today - act > 90L * 24L * 60L * 60L)
		usr->spc90 += blks;
	if (today - act > 60L * 24L * 60L * 60L)
		usr->spc60 += blks;
	if (today - act > 30L * 24L * 60L * 60L)
		usr->spc30 += blks;
}

#ifdef	COMPAT
#define	FSZCNT	500
#else
#define	FSZCNT	512
#endif
struct fsizes {
	struct fsizes *fsz_next;
	daddr_t fsz_first, fsz_last;
	ino_t fsz_count[FSZCNT];
	daddr_t fsz_sz[FSZCNT];
} *fsizes;

static void
initfsizes(void)
{
	struct fsizes *fp;
	int i;

	for (fp = fsizes; fp; fp = fp->fsz_next) {
		for (i = FSZCNT; --i >= 0;) {
			fp->fsz_count[i] = 0;
			fp->fsz_sz[i] = 0;
		}
	}
}

static void
dofsizes(int fd, struct fs *super, char *name)
{
	ino_t inode, maxino;
	union dinode *dp;
	daddr_t sz, ksz;
	struct fsizes *fp, **fsp;
	int i;

	maxino = super->fs_ncg * super->fs_ipg - 1;
#ifdef	COMPAT
	if (!(fsizes = malloc(sizeof(struct fsizes))))
		err(1, "alloc fsize structure");
#endif	/* COMPAT */
	for (inode = 0; inode < maxino; inode++) {
		errno = 0;
		if ((dp = get_inode(fd, super, inode))
#ifdef	COMPAT
		    && ((DIP(super, dp, di_mode) & IFMT) == IFREG
			|| (DIP(super, dp, di_mode) & IFMT) == IFDIR)
#else	/* COMPAT */
		    && !isfree(super, dp)
#endif	/* COMPAT */
		    ) {
			sz = estimate ? virtualblocks(super, dp) :
			    actualblocks(super, dp);
#ifdef	COMPAT
			if (sz >= FSZCNT) {
				fsizes->fsz_count[FSZCNT-1]++;
				fsizes->fsz_sz[FSZCNT-1] += sz;
			} else {
				fsizes->fsz_count[sz]++;
				fsizes->fsz_sz[sz] += sz;
			}
#else	/* COMPAT */
			ksz = SIZE(sz);
			for (fsp = &fsizes; (fp = *fsp); fsp = &fp->fsz_next) {
				if (ksz < fp->fsz_last)
					break;
			}
			if (!fp || ksz < fp->fsz_first) {
				if (!(fp = (struct fsizes *)
				    malloc(sizeof(struct fsizes)))) {
					err(1, "alloc fsize structure");
				}
				fp->fsz_next = *fsp;
				*fsp = fp;
				fp->fsz_first = (ksz / FSZCNT) * FSZCNT;
				fp->fsz_last = fp->fsz_first + FSZCNT;
				for (i = FSZCNT; --i >= 0;) {
					fp->fsz_count[i] = 0;
					fp->fsz_sz[i] = 0;
				}
			}
			fp->fsz_count[ksz % FSZCNT]++;
			fp->fsz_sz[ksz % FSZCNT] += sz;
#endif	/* COMPAT */
		} else if (errno)
			err(1, "%s", name);
	}
	sz = 0;
	for (fp = fsizes; fp; fp = fp->fsz_next) {
		for (i = 0; i < FSZCNT; i++) {
			if (fp->fsz_count[i])
				printf("%lld\t%llu\t%lld\n",
				    (long long)fp->fsz_first + i,
				    (unsigned long long)fp->fsz_count[i],
				    SIZE(sz += fp->fsz_sz[i]));
		}
	}
}

static void
douser(int fd, struct fs *super, char *name)
{
	ino_t inode, maxino;
	struct user *usr, *usrs;
	union dinode *dp;
	int n;

	maxino = super->fs_ncg * super->fs_ipg - 1;
	for (inode = 0; inode < maxino; inode++) {
		errno = 0;
		if ((dp = get_inode(fd,super,inode))
		    && !isfree(super, dp))
			uses(DIP(super, dp, di_uid),
			    estimate ? virtualblocks(super, dp) :
				actualblocks(super, dp),
			    DIP(super, dp, di_atime));
		else if (errno)
			err(1, "%s", name);
	}
	if (!(usrs = calloc(nusers, sizeof(struct user))))
		err(1, "allocate users");
	memcpy(usrs, users, nusers * sizeof(struct user));
	sortusers(usrs);
	for (usr = usrs, n = nusers; --n >= 0 && usr->count; usr++) {
		printf("%14lld", SIZE(usr->space));
		if (count)
			printf("\t%5ld", usr->count);
		printf("\t%-8s", usr->name);
		if (unused)
			printf("\t%14lld\t%14lld\t%14lld",
			       SIZE(usr->spc30),
			       SIZE(usr->spc60),
			       SIZE(usr->spc90));
		printf("\n");
	}
	free(usrs);
}

static void
donames(int fd, struct fs *super, char *name)
{
	int c;
	unsigned long long inode;
	ino_t inode1;
	ino_t maxino;
	union dinode *dp;

	maxino = super->fs_ncg * super->fs_ipg - 1;
	/* first skip the name of the filesystem */
	while ((c = getchar()) != EOF && (c < '0' || c > '9'))
		while ((c = getchar()) != EOF && c != '\n');
	ungetc(c, stdin);
	inode1 = -1;
	while (scanf("%llu", &inode) == 1) {
		if (inode < 0 || inode > maxino) {
#ifndef	COMPAT
			fprintf(stderr, "invalid inode %llu\n",
			    (unsigned long long)inode);
#endif
			return;
		}
#ifdef	COMPAT
		if (inode < inode1)
			continue;
#endif
		errno = 0;
		if ((dp = get_inode(fd, super, inode)) && !isfree(super, dp)) {
			printf("%s\t", user(DIP(super, dp, di_uid))->name);
			/* now skip whitespace */
			while ((c = getchar()) == ' ' || c == '\t');
			/* and print out the remainder of the input line */
			while (c != EOF && c != '\n') {
				putchar(c);
				c = getchar();
			}
			putchar('\n');
			inode1 = inode;
		} else {
			if (errno)
				err(1, "%s", name);
			/* skip this line */
			while ((c = getchar()) != EOF && c != '\n')
				;
		}
		if (c == EOF)
			break;
	}
}

static void
usage(void)
{
#ifdef	COMPAT
	fprintf(stderr, "usage: quot [-nfcvha] [filesystem ...]\n");
#else	/* COMPAT */
	fprintf(stderr, "usage: quot [-acfhknv] [filesystem ...]\n");
#endif	/* COMPAT */
	exit(1);
}

/*
 * Possible superblock locations ordered from most to least likely.
 */
static int sblock_try[] = SBLOCKSEARCH;
static char superblock[SBLOCKSIZE];

#define	max(a,b)	MAX((a),(b))
/*
 * Sanity checks for old file systems.
 * Stolen from <sys/lib/libsa/ufs.c>
 */
static void
ffs_oldfscompat(struct fs *fs)
{
	int i;

	fs->fs_npsect = max(fs->fs_npsect, fs->fs_nsect);	/* XXX */
	fs->fs_interleave = max(fs->fs_interleave, 1);		/* XXX */
	if (fs->fs_postblformat == FS_42POSTBLFMT)		/* XXX */
		fs->fs_nrpos = 8;				/* XXX */
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		quad_t sizepb = fs->fs_bsize;			/* XXX */
								/* XXX */
		fs->fs_maxfilesize = fs->fs_bsize * NDADDR - 1;	/* XXX */
		for (i = 0; i < NIADDR; i++) {			/* XXX */
			sizepb *= NINDIR(fs);			/* XXX */
			fs->fs_maxfilesize += sizepb;		/* XXX */
		}						/* XXX */
		fs->fs_qbmask = ~fs->fs_bmask;			/* XXX */
		fs->fs_qfmask = ~fs->fs_fmask;			/* XXX */
	}							/* XXX */
}

void
quot(char *name, char *mp)
{
	int i, fd;
	struct fs *fs;

	get_inode(-1, NULL, 0);		/* flush cache */
	inituser();
	initfsizes();
	/*
	 * XXX this is completely broken.  Of course you can't read a
	 * directory, well, not anymore.  How to fix this, though...
	 */
	if ((fd = open(name, O_RDONLY)) < 0) {
		warn("%s", name);
		return;
	}
	for (i = 0; sblock_try[i] != -1; i++) {
		if (lseek(fd, sblock_try[i], 0) != sblock_try[i]) {
			close(fd);
			return;
		}
		if (read(fd, superblock, SBLOCKSIZE) != SBLOCKSIZE) {
			close(fd);
			return;
		}
		fs = (struct fs *)superblock;
		if ((fs->fs_magic == FS_UFS1_MAGIC ||
		    (fs->fs_magic == FS_UFS2_MAGIC &&
		    fs->fs_sblockloc == sblock_try[i])) &&
		    fs->fs_bsize <= MAXBSIZE &&
		    fs->fs_bsize >= sizeof(struct fs))
			break;
	}
	if (sblock_try[i] == -1) {
		warnx("%s: not a BSD filesystem", name);
		close(fd);
		return;
	}
	ffs_oldfscompat(fs);
	printf("%s:", name);
	if (mp)
		printf(" (%s)", mp);
	putchar('\n');
	(*func)(fd, fs, name);
	close(fd);
}

int
main(int argc, char *argv[])
{
	int cnt, all, i;
	char dev[MNAMELEN], *nm, *mountpoint, *cp;
	struct statfs *mp;

	all = 0;
	func = douser;
#ifndef	COMPAT
	header = getbsize(&headerlen, &blocksize);
#endif
	while (--argc > 0 && **++argv == '-') {
		while (*++*argv) {
			switch (**argv) {
			case 'n':
				func = donames;
				break;
			case 'c':
				func = dofsizes;
				break;
			case 'a':
				all = 1;
				break;
			case 'f':
				count = 1;
				break;
			case 'h':
				estimate = 1;
				break;
#ifndef	COMPAT
			case 'k':
				blocksize = 1024;
				break;
#endif	/* COMPAT */
			case 'v':
				unused = 1;
				break;
			default:
				usage();
			}
		}
	}
	cnt = getmntinfo(&mp, MNT_NOWAIT);
	if (all) {
		for (; --cnt >= 0; mp++) {
			if (strcmp(mp->f_fstypename, MOUNT_FFS) == 0 ||
			    strcmp(mp->f_fstypename, "ufs") == 0) {
				if ((nm = strrchr(mp->f_mntfromname, '/'))) {
					snprintf(dev, sizeof(dev), "%sr%s",
					    _PATH_DEV, nm + 1);
					nm = dev;
				} else
					nm = mp->f_mntfromname;
				quot(nm, mp->f_mntonname);
			}
		}
	}
	for (; --argc >= 0; argv++) {
		mountpoint = NULL;
		nm = *argv;

		/* Remove trailing slashes from name. */
		cp = nm + strlen(nm);
		while (*(--cp) == '/' && cp != nm)
			*cp = '\0';

		/* Look up the name in the mount table. */
		for (i = 0; i < cnt; i++) {
			/* Remove trailing slashes from name. */
			cp = mp[i].f_mntonname + strlen(mp[i].f_mntonname);
			while (*(--cp) == '/' && cp != mp[i].f_mntonname)
				*cp = '\0';

			if ((!strcmp(mp->f_fstypename, MOUNT_FFS) ||
			     !strcmp(mp->f_fstypename, MOUNT_MFS) ||
			     !strcmp(mp->f_fstypename, "ufs")) &&
			    strcmp(nm, mp[i].f_mntonname) == 0) {
				nm = mp[i].f_mntfromname;
				mountpoint = mp[i].f_mntonname;
				break;
			}
		}

		/* Make sure we have the raw device... */
		if (strncmp(nm, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0 &&
		    nm[sizeof(_PATH_DEV) - 1] != 'r') {
			snprintf(dev, sizeof(dev), "%sr%s", _PATH_DEV,
			    nm + sizeof(_PATH_DEV) - 1);
			nm = dev;
		}
		quot(nm, mountpoint);
	}
	exit(0);
}
@


1.27
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.26 2015/01/20 18:22:21 deraadt Exp $	*/
d564 1
a564 1
	if ((fd = open(name, 0)) < 0) {
@


1.26
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.25 2015/01/16 06:40:19 deraadt Exp $	*/
d223 1
a223 2
		if (!(users =
		    (struct user *)calloc(nusers, sizeof(struct user)))) {
d243 1
a243 1
	if (!(users = (struct user *)calloc(nusers, sizeof(struct user))))
d356 1
a356 1
	if (!(fsizes = (struct fsizes *)malloc(sizeof(struct fsizes))))
d437 1
a437 1
	if (!(usrs = (struct user *)calloc(nusers, sizeof(struct user))))
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.24 2013/11/12 22:27:12 deraadt Exp $	*/
d34 1
a34 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE MAXBSIZE */
@


1.24
log
@ensure there are prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.23 2013/08/22 04:43:41 guenther Exp $	*/
d34 1
a34 1
#include <sys/param.h>
@


1.23
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.22 2013/06/11 16:42:19 deraadt Exp $	*/
d56 1
@


1.22
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.21 2013/04/23 18:18:59 deraadt Exp $	*/
d409 3
a411 2
				printf("%d\t%d\t%lld\n",
				    fp->fsz_first + i, fp->fsz_count[i],
d460 2
a461 1
	ino_t inode, inode1;
d471 1
a471 1
	while (scanf("%d", &inode) == 1) {
@


1.21
log
@handle large ino_t
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.20 2009/10/27 23:59:54 deraadt Exp $	*/
d206 1
a206 1
	daddr64_t space;
d208 3
a210 3
	daddr64_t spc30;
	daddr64_t spc60;
	daddr64_t spc90;
d299 1
a299 1
uses(uid_t uid, daddr64_t blks, time_t act)
d326 1
a326 1
	daddr64_t fsz_first, fsz_last;
d328 1
a328 1
	daddr64_t fsz_sz[FSZCNT];
d350 1
a350 1
	daddr64_t sz, ksz;
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.19 2008/03/17 20:30:17 sobrado Exp $	*/
d472 2
a473 1
			fprintf(stderr, "invalid inode %d\n", inode);
@


1.19
log
@sync the synopsis and usage; "usage:" is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.18 2007/09/02 15:19:40 deraadt Exp $	*/
a32 4

#ifndef lint
static char rcsid[] = "$Id: quot.c,v 1.18 2007/09/02 15:19:40 deraadt Exp $";
#endif /* not lint */
@


1.18
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.17 2007/07/04 17:14:45 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$Id: quot.c,v 1.17 2007/07/04 17:14:45 millert Exp $";
d512 1
a512 1
	fprintf(stderr, "Usage: quot [-nfcvha] [filesystem ...]\n");
d514 1
a514 1
	fprintf(stderr, "Usage: quot [ -acfhknv ] [ filesystem ... ]\n");
@


1.17
log
@Add ffs2 support; from FreeBSD.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.16 2007/06/25 20:22:00 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$Id: quot.c,v 1.16 2007/06/25 20:22:00 deraadt Exp $";
d440 1
a440 1
	if (!(usrs = (struct user *)malloc(nusers * sizeof(struct user))))
@


1.16
log
@daddr64_t changes to match other parts of tree; ok otto
@
text
@d1 1
a1 2
/*	$OpenBSD: quot.c,v 1.15 2006/04/02 00:50:42 deraadt Exp $	*/
/*	$NetBSD: quot.c,v 1.7.4.1 1996/05/31 18:06:36 jtc Exp $	*/
d35 1
a35 1
static char rcsid[] = "$Id: quot.c,v 1.15 2006/04/02 00:50:42 deraadt Exp $";
d41 1
a42 2
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
d79 11
a89 1
#define	INOSZ(fs)	(sizeof(struct ufs1_dinode) * INOCNT(fs))
d91 1
a91 1
static struct ufs1_dinode *
d94 2
a95 1
	static struct ufs1_dinode *ip;
d97 2
d101 7
a107 3
		if (ip) {
			free(ip);
			ip = 0;
d112 15
a126 2
	if (!ip || ino < last || ino >= last + INOCNT(super)) {
		if (!ip && !(ip = (struct ufs1_dinode *)malloc(INOSZ(super))))
d129 3
a131 4
		if (lseek(fd,
			  (off_t)ino_to_fsba(super, last) << super->fs_fshift,
			  SEEK_SET) < 0
		    || read(fd, ip, INOSZ(super)) != INOSZ(super)) {
d136 8
a143 1
	return ip + ino % INOCNT(super);
d147 1
a147 1
#define	actualblocks(super, ip)	((ip)->di_blocks / 2)
d149 1
a149 1
#define	actualblocks(super, ip)	((ip)->di_blocks)
d153 1
a153 1
virtualblocks(struct fs *super, struct ufs1_dinode *ip)
d157 1
a157 1
	sz = ip->di_size;
d185 1
a185 1
isfree(struct ufs1_dinode *ip)
d188 1
a188 1
	return (ip->di_mode&IFMT) == 0;
d190 1
a190 1
	switch (ip->di_mode&IFMT) {
d196 5
d202 1
a202 1
		return 1;
d353 1
a353 1
	struct ufs1_dinode *ip;
d365 1
a365 1
		if ((ip = get_inode(fd, super, inode))
d367 2
a368 2
		    && ((ip->di_mode&IFMT) == IFREG
			|| (ip->di_mode&IFMT) == IFDIR)
d370 1
a370 1
		    && !isfree(ip)
d373 2
a374 2
			sz = estimate ? virtualblocks(super, ip) :
			    actualblocks(super, ip);
d425 1
a425 1
	struct ufs1_dinode *ip;
d431 6
a436 6
		if ((ip = get_inode(fd, super, inode))
		    && !isfree(ip))
			uses(ip->di_uid,
			     estimate ? virtualblocks(super, ip)
				: actualblocks(super, ip),
			    ip->di_atime);
d465 1
a465 1
	struct ufs1_dinode *ip;
d485 2
a486 3
		if ((ip = get_inode(fd, super, inode))
		    && !isfree(ip)) {
			printf("%s\t", user(ip->di_uid)->name);
d519 5
a523 1
static char superblock[SBSIZE];
d555 2
a556 1
	int fd;
d569 18
a586 5
	if (lseek(fd, SBOFF, SEEK_SET) != SBOFF
	    || read(fd, superblock, SBSIZE) != SBSIZE
	    || ((struct fs *)superblock)->fs_magic != FS_MAGIC
	    || ((struct fs *)superblock)->fs_bsize > MAXBSIZE
	    || ((struct fs *)superblock)->fs_bsize < sizeof(struct fs)) {
d591 1
a591 1
	ffs_oldfscompat((struct fs *)superblock);
d596 1
a596 1
	(*func)(fd, (struct fs *)superblock, name);
@


1.15
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.14 2003/08/25 23:28:16 tedu Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.14 2003/08/25 23:28:16 tedu Exp $";
d171 1
a171 1
	daddr_t space;
d173 3
a175 3
	daddr_t spc30;
	daddr_t spc60;
	daddr_t spc90;
d264 1
a264 1
uses(uid_t uid, daddr_t blks, time_t act)
d291 1
a291 1
	daddr_t fsz_first, fsz_last;
d293 1
a293 1
	daddr_t fsz_sz[FSZCNT];
d315 1
a315 1
	daddr_t sz, ksz;
d374 3
a376 3
				printf("%d\t%d\t%qd\n",
				       fp->fsz_first + i, fp->fsz_count[i],
				    (quad_t) SIZE(sz += fp->fsz_sz[i]));
d406 1
a406 1
		printf("%5qd", (quad_t) SIZE(usr->space));
d411 4
a414 4
			printf("\t%5qd\t%5qd\t%5qd",
			       (quad_t) SIZE(usr->spc30),
			       (quad_t) SIZE(usr->spc60),
			       (quad_t) SIZE(usr->spc90));
@


1.14
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.13 2003/06/26 19:47:09 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.13 2003/06/26 19:47:09 deraadt Exp $";
d103 1
a103 1
			  0) < 0
d526 1
a526 1
	if (lseek(fd, SBOFF, 0) != SBOFF
@


1.13
log
@strict proto cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.12 2003/06/25 21:18:24 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.12 2003/06/25 21:18:24 deraadt Exp $";
d81 1
a81 1
#define	INOSZ(fs)	(sizeof(struct dinode) * INOCNT(fs))
d83 1
a83 1
static struct dinode *
d86 1
a86 1
	static struct dinode *ip;
d98 1
a98 1
		if (!ip && !(ip = (struct dinode *)malloc(INOSZ(super))))
d119 1
a119 1
virtualblocks(struct fs *super, struct dinode *ip)
d151 1
a151 1
isfree(struct dinode *ip)
d314 1
a314 1
	struct dinode *ip;
d386 1
a386 1
	struct dinode *ip;
d426 1
a426 1
	struct dinode *ip;
@


1.12
log
@proto cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.11 2002/05/30 19:09:05 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.11 2002/05/30 19:09:05 deraadt Exp $";
d471 1
a471 1
usage()
@


1.11
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.10 2000/11/21 04:23:09 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.10 2000/11/21 04:23:09 millert Exp $";
d60 2
a61 1
static void (*func)();
d84 1
a84 4
get_inode(fd, super, ino)
	int fd;
	struct fs *super;
	ino_t ino;
d119 1
a119 3
virtualblocks(super, ip)
	struct fs *super;
	struct dinode *ip;
d151 1
a151 2
isfree(ip)
	struct dinode *ip;
d180 1
a180 1
inituser()
d200 1
a200 1
usrrehash()
d222 1
a222 2
user(uid)
	uid_t uid;
d253 1
a253 2
cmpusers(u1, u2)
	struct user *u1, *u2;
d255 2
d264 1
a264 4
uses(uid, blks, act)
	uid_t uid;
	daddr_t blks;
	time_t act;
d297 1
a297 1
initfsizes()
d311 1
a311 4
dofsizes(fd, super, name)
	int fd;
	struct fs *super;
	char *name;
d382 1
a382 4
douser(fd, super, name)
	int fd;
	struct fs *super;
	char *name;
d421 1
a421 4
donames(fd, super, name)
	int fd;
	struct fs *super;
	char *name;
d489 1
a489 2
ffs_oldfscompat(fs)
	struct fs *fs;
d511 1
a511 2
quot(name, mp)
	char *name, *mp;
d515 1
a515 1
	get_inode(-1);		/* flush cache */
d535 1
a535 1
	ffs_oldfscompat(superblock);
d540 1
a540 1
	(*func)(fd, superblock, name);
d545 1
a545 3
main(argc, argv)
	int argc;
	char **argv;
@


1.10
log
@Don't include mfs partitions in 'quot -a' since there is no device file
to open.
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.9 2000/06/07 03:55:03 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.9 2000/06/07 03:55:03 millert Exp $";
d90 1
a90 1
	
d98 1
a98 1
	
d110 1
a110 1
	
d126 1
a126 1
	
d134 1
a134 1
	
d137 1
a137 1
	
d149 1
a149 1
	
d189 1
a189 1
	
d210 1
a210 1
	
d233 1
a233 1
	
d240 1
a240 1
				
d276 1
a276 1
	
d279 1
a279 1
	
d283 1
a283 1
	
d309 1
a309 1
	
d329 1
a329 1
	
d402 1
a402 1
	
d444 1
a444 1
	
d533 1
a533 1
	
d571 1
a571 1
	
@


1.9
log
@Strip trailing slashes from dir names and give a reasonable error if
what is specified on the command line is not a mount point or device.
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.8 2000/06/06 18:29:46 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.8 2000/06/06 18:29:46 millert Exp $";
d611 2
a612 3
			if (!strcmp(mp->f_fstypename, MOUNT_FFS) ||
			    !strcmp(mp->f_fstypename, MOUNT_MFS) ||
			    !strcmp(mp->f_fstypename, "ufs")) {
@


1.8
log
@Make quot work when passed a filesystem mount point like the documentation
leads one to believe.  Also some -Wall and other cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.7 1999/09/22 05:04:34 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.7 1999/09/22 05:04:34 deraadt Exp $";
d541 1
a541 3
	if ((fd = open(name, 0)) < 0
	    || lseek(fd, SBOFF, 0) != SBOFF
	    || read(fd, superblock, SBSIZE) != SBSIZE) {
a542 1
		close(fd);
d545 3
a547 1
	if (((struct fs *)superblock)->fs_magic != FS_MAGIC
d550 1
a550 1
		fprintf(stderr, "%s: not a BSD filesystem\n", name);
d569 1
a569 1
	char dev[MNAMELEN], *nm, *mountpoint;
d625 1
d627 5
a631 1
		mountpoint = NULL;
d635 5
d643 1
a643 1
			    strcmp(*argv, mp[i].f_mntonname) == 0) {
d646 1
@


1.7
log
@do not know how to fix, doc it at least
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.6 1999/08/06 20:41:08 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.6 1999/08/06 20:41:08 deraadt Exp $";
d49 1
d51 2
d71 1
a71 1
 * kByte when done (on request).
d76 1
a76 1
#define	SIZE(n)	howmany(((off_t)(n)) * DEV_BSIZE, blocksize)
d100 2
a101 5
		if (!ip
		    && !(ip = (struct dinode *)malloc(INOSZ(super)))) {
			perror("allocate inodes");
			exit(1);
		}
d107 1
a107 2
			perror("read inodes");
			exit(1);
d125 1
a125 1
	register off_t nblk, sz;
d187 2
a188 2
	register i;
	register struct user *usr;
d194 1
a194 2
			perror("allocate users");
			exit(1);
d207 2
a208 2
	register i;
	register struct user *usr, *usrn;
d213 2
a214 4
	if (!(users = (struct user *)calloc(nusers, sizeof(struct user)))) {
		perror("allocate users");
		exit(1);
	}
d230 1
a230 2
	register struct user *usr;
	register i;
d232 1
d241 6
a246 13
				if (!(pwd = getpwuid(uid))) {
					if (usr->name = (char *)malloc(7))
						sprintf(usr->name, "#%u",
						    uid);
				} else {
					if (usr->name = (char *)
					    malloc(strlen(pwd->pw_name) + 1))
						strcpy(usr->name, pwd->pw_name);
				}
				if (!usr->name) {
					perror("allocate users");
					exit(1);
				}
d275 1
a275 1
	register struct user *usr;
d307 2
a308 2
	register struct fsizes *fp;
	register i;
d328 1
a328 1
	register i;
d332 2
a333 4
	if (!(fsizes = (struct fsizes *)malloc(sizeof(struct fsizes)))) {
		perror("alloc fsize structure");
		exit(1);
	}
d357 1
a357 1
			for (fsp = &fsizes; fp = *fsp; fsp = &fp->fsz_next) {
d364 1
a364 2
					perror("alloc fsize structure");
					exit(1);
d378 2
a379 4
		} else if (errno) {
			perror(name);
			exit(1);
		}
d385 1
a385 1
				printf("%d\t%d\t%d\n",
d387 1
a387 1
				    SIZE(sz += fp->fsz_sz[i]));
d401 1
a401 1
	register n;
d412 2
a413 8
		else if (errno) {
			perror(name);
			exit(1);
		}
	}
	if (!(usrs = (struct user *)malloc(nusers * sizeof(struct user)))) {
		perror("allocate users");
		exit(1);
d415 3
a417 1
	bcopy(users, usrs, nusers * sizeof(struct user));
d420 1
a420 1
		printf("%5d", SIZE(usr->space));
d422 1
a422 1
			printf("\t%5d", usr->count);
d425 4
a428 4
			printf("\t%5d\t%5d\t%5d",
			       SIZE(usr->spc30),
			       SIZE(usr->spc60),
			       SIZE(usr->spc90));
d476 2
a477 4
			if (errno) {
				perror(name);
				exit(1);
			}
d479 2
a480 1
			while ((c = getchar()) != EOF && c != '\n');
d544 1
a544 1
		perror(name);
d569 2
a570 3
	int fd;
	char all = 0;
	FILE *fp;
a571 3
	char dev[MNAMELEN + 1];
	char *nm;
	int cnt;
d573 1
d609 1
a610 1
		cnt = getmntinfo(&mp, MNT_NOWAIT);
d612 6
a617 5
			if (!strncmp(mp->f_fstypename, MOUNT_FFS, MFSNAMELEN) ||
			    !strncmp(mp->f_fstypename, MOUNT_MFS, MFSNAMELEN) ||
			    !strncmp(mp->f_fstypename, "ufs", MFSNAMELEN)) {
				if (nm = strrchr(mp->f_mntfromname, '/')) {
					sprintf(dev, "/dev/r%s", nm + 1);
d625 25
a649 3
	while (--argc >= 0)
		quot(*argv++, 0);
	return 0;
@


1.6
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.5 1998/07/08 19:43:23 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.5 1998/07/08 19:43:23 millert Exp $";
d558 4
@


1.5
log
@When multiplying bumber of blocks by DEV_BSIZE, cast nblocks to off_t so we don't wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: quot.c,v 1.4 1996/06/10 08:32:15 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.4 1996/06/10 08:32:15 deraadt Exp $";
d247 2
a248 1
						sprintf(usr->name, "#%d", uid);
@


1.4
log
@random cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.3 1996/04/25 11:04:11 deraadt Exp $";
d73 1
a73 1
#define	SIZE(n)	howmany((n) * DEV_BSIZE, blocksize)
@


1.3
log
@permit quotas to work on mfs; problem reported by rdante@@pnet.net
@
text
@d1 3
d36 1
a36 1
static char rcsid[] = "$Id: quot.c,v 1.2 1995/11/06 21:40:54 deraadt Exp $";
d51 1
d57 1
a57 1
static int (*func)();
d66 1
a66 1
 * The new code always counts the number of 512 byte blocks
d73 1
a73 1
#define	SIZE(n)	(((n) * 512 + blocksize - 1)/blocksize)
d79 3
a81 1
static struct dinode *get_inode(fd,super,ino)
d103 4
a106 2
		if (lseek(fd,ino_to_fsba(super,last) << super->fs_fshift,0) < 0
		    || read(fd,ip,INOSZ(super)) != INOSZ(super)) {
d116 1
a116 1
#define	actualblocks(super,ip)	((ip)->di_blocks/2)
d118 1
a118 1
#define	actualblocks(super,ip)	((ip)->di_blocks)
d121 2
a122 1
static virtualblocks(super,ip)
d130 2
a131 2
	if (lblkno(super,sz) >= NDADDR) {
		nblk = blkroundup(super,sz);
a136 1
	
d139 4
a142 4
	if (lblkno(super,sz) >= NDADDR) {
		nblk = blkroundup(super,sz);
		sz = lblkno(super,nblk);
		sz = (sz - NDADDR + NINDIR(super) - 1) / NINDIR(super);
d145 2
a146 2
			/* sz - 1 rounded up */
			sz = (sz - 1 + NINDIR(super) - 1) / NINDIR(super);
d149 1
a149 1
		nblk = fragroundup(super,sz);
d151 1
a151 1
	return nblk / 512;
d155 2
a156 1
static isfree(ip)
a161 1
	
d185 2
a186 1
static inituser()
d194 1
a194 1
		    (struct user *)calloc(nusers,sizeof(struct user)))) {
d206 2
a207 1
static usrrehash()
d215 1
a215 1
	if (!(users = (struct user *)calloc(nusers,sizeof(struct user)))) {
d220 2
a221 1
		for (usrn = users + (usr->uid&(nusers - 1)); usrn->name;
d230 2
a231 1
static struct user *user(uid)
d239 2
a240 1
		for (usr = users + (uid&(nusers - 1)), i = nusers; --i >= 0;
d247 1
a247 1
						sprintf(usr->name,"#%d",uid);
d251 1
a251 1
						strcpy(usr->name,pwd->pw_name);
a256 1
				
a257 1
				
d268 2
a269 1
static cmpusers(u1,u2)
d275 1
a275 1
#define	sortusers(users)	(qsort((users),nusers,sizeof(struct user), \
d278 2
a279 1
static uses(uid,blks,act)
d314 2
a315 1
static initfsizes()
d328 3
a330 1
static dofsizes(fd,super,name)
d349 1
a349 1
		if ((ip = get_inode(fd,super,inode))
d357 2
a358 2
			sz = estimate ? virtualblocks(super,ip) :
			    actualblocks(super,ip);
d400 2
a401 2
				printf("%d\t%d\t%d\n",fp->fsz_first + i,
				    fp->fsz_count[i],
d407 3
a409 1
static douser(fd,super,name)
d421 1
a421 1
		if ((ip = get_inode(fd,super,inode))
d424 2
a425 2
			    estimate ? virtualblocks(super,ip) :
				actualblocks(super,ip),
d436 1
a436 1
	bcopy(users,usrs,nusers * sizeof(struct user));
d439 1
a439 1
		printf("%5d",SIZE(usr->space));
d441 2
a442 2
			printf("\t%5d",usr->count);
		printf("\t%-8s",usr->name);
d453 3
a455 1
static donames(fd,super,name)
d468 1
a468 1
	ungetc(c,stdin);
d470 1
a470 1
	while (scanf("%d",&inode) == 1) {
d472 3
a474 1
			fprintf(stderr,"illegal inode %d\n",inode);
d477 4
d482 1
a482 1
		if ((ip = get_inode(fd,super,inode))
d484 1
a484 1
			printf("%s\t",user(ip->di_uid)->name);
d507 2
a508 1
static usage()
d511 1
a511 1
	fprintf(stderr,"Usage: quot [-nfcvha] [filesystem ...]\n");
d513 1
a513 1
	fprintf(stderr,"Usage: quot [ -acfhknv ] [ filesystem ... ]\n");
d520 30
a549 1
quot(name,mp)
d557 3
a559 3
	if ((fd = open(name,0)) < 0
	    || lseek(fd,SBOFF,0) != SBOFF
	    || read(fd,superblock,SBSIZE) != SBSIZE) {
d564 4
a567 2
	if (((struct fs *)superblock)->fs_magic != FS_MAGIC) {
		fprintf(stderr,"%s: not a BSD filesystem\n",name);
d571 2
a572 1
	printf("%s:",name);
d574 1
a574 1
		printf(" (%s)",mp);
d576 1
a576 1
	(*func)(fd,superblock,name);
d580 3
a582 1
int main(argc,argv)
d595 1
a595 1
	header = getbsize(&headerlen,&blocksize);
d629 1
a629 1
		cnt = getmntinfo(&mp,MNT_NOWAIT);
d634 2
a635 2
				if (nm = strrchr(mp->f_mntfromname,'/')) {
					sprintf(dev,"/dev/r%s",nm + 1);
d639 1
a639 1
				quot(nm,mp->f_mntonname);
d644 1
a644 1
		quot(*argv++,0);
@


1.2
log
@Complete change from ufs -> ffs; (From Tatoku Ogaito; PR #1679)
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: quot.c,v 1.6.4.1 1995/11/01 00:06:41 jtc Exp $";
d570 3
a572 1
			if (!strncmp(mp->f_fstypename, MOUNT_FFS, MFSNAMELEN)) {
@


1.1
log
@Initial revision
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: quot.c,v 1.6 1994/06/13 20:56:47 cgd Exp $";
d570 1
a570 1
			if (!strncmp(mp->f_fstypename, MOUNT_UFS, MFSNAMELEN)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
