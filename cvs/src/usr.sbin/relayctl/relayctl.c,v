head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.6
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.56.0.4
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.53.0.6
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.51.0.4
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.45.0.8
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.6
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.4
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33;
locks; strict;
comment	@ * @;


1.57
date	2016.09.03.14.44.21;	author reyk;	state Exp;
branches;
next	1.56;
commitid	n0F9VKkYrh9A46uy;

1.56
date	2015.12.05.13.13.11;	author claudio;	state Exp;
branches;
next	1.55;
commitid	eFaXCW6lAjqOxsAo;

1.55
date	2015.10.12.12.17.36;	author semarie;	state Exp;
branches;
next	1.54;
commitid	YTEg2QxwT3yx20ij;

1.54
date	2015.10.10.00.37.40;	author benno;	state Exp;
branches;
next	1.53;
commitid	NZseHad3LHm1ePkv;

1.53
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.52;
commitid	puppem00jmzmdm4f;

1.52
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Uu5nFG3wCl0LACBb;

1.51
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.50;
commitid	YhQvyAop4vC3AmzJ;

1.50
date	2014.06.25.11.12.45;	author reyk;	state Exp;
branches;
next	1.49;
commitid	b8NNT7Q82DkYrCh4;

1.49
date	2013.11.14.20.48.52;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.27.16.39.29;	author benno;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.03.03.10.42;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.20.09.43.53;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.09.12.08.46;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.01.08.51.34;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.17.11.36.01;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2009.08.07.11.21.53;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.31.15.22.27;	author sobrado;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.05.16.37.56;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.19.12.10.07;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.31.12.12.50;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.31.09.56.29;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.20.20.15.43;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.08.20.11.48;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.07.17.17.01;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.24.17.09.12;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.19.12.08.54;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.29.16.23.06;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.07.08.33.31;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.07.08.31.36;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.12.18.09.00;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.28.00.04.47;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.05.59.13;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.06.08.45.46;	author pyr;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.03.17.51.46;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.01.21.57.18;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.01.21.01.10;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.01.20.03.38;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.13.50.10;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.16.17.52.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.15.02.35;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.14.21.15;	author bernd;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.47.18;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Replace [RELAY|SERVER]_MAXPROC with the new PROC_MAX_INSTANCES
variable and limit it from 128 to 32 instances (the old value).
While here, move a few PROC_ defines around.

OK rzalamena@@
@
text
@/*	$OpenBSD: relayctl.c,v 1.56 2015/12/05 13:13:11 claudio Exp $	*/

/*
 * Copyright (c) 2007 - 2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/un.h>

#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <imsg.h>

#include "relayd.h"
#include "parser.h"

__dead void	 usage(void);
int		 show_summary_msg(struct imsg *, int);
int		 show_session_msg(struct imsg *);
int		 show_command_output(struct imsg *);
char		*print_rdr_status(int);
char		*print_host_status(int, int);
char		*print_table_status(int, int);
char		*print_relay_status(int);
void		 print_statistics(struct ctl_stats[PROC_MAX_INSTANCES + 1]);

struct imsgname {
	int type;
	char *name;
	void (*func)(struct imsg *);
};

struct imsgname *monitor_lookup(u_int8_t);
void		 monitor_host_status(struct imsg *);
void		 monitor_id(struct imsg *);
int		 monitor(struct imsg *);

struct imsgname imsgs[] = {
	{ IMSG_HOST_STATUS,		"host_status",	monitor_host_status },
	{ IMSG_CTL_RDR_DISABLE,		"ctl_rdr_disable",	monitor_id },
	{ IMSG_CTL_RDR_ENABLE,		"ctl_rdr_enable",	monitor_id },
	{ IMSG_CTL_TABLE_DISABLE,	"ctl_table_disable",	monitor_id },
	{ IMSG_CTL_TABLE_ENABLE,	"ctl_table_enable",	monitor_id },
	{ IMSG_CTL_HOST_DISABLE,	"ctl_host_disable",	monitor_id },
	{ IMSG_CTL_HOST_ENABLE,		"ctl_host_enable",	monitor_id },
	{ IMSG_CTL_TABLE_CHANGED,	"ctl_table_changed",	monitor_id },
	{ IMSG_CTL_PULL_RULESET,	"ctl_pull_ruleset",	monitor_id },
	{ IMSG_CTL_PUSH_RULESET,	"ctl_push_ruleset",	monitor_id },
	{ IMSG_SYNC,			"sync",			NULL },
	{ 0,				NULL,			NULL }
};
struct imsgname imsgunknown = {
	-1,				"<unknown>",		NULL
};

struct imsgbuf	*ibuf;
int error = 0;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s command [argument ...]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	int			 ctl_sock;
	int			 done = 0;
	int			 n, verbose = 0;

	/* parse options */
	if ((res = parse(argc - 1, argv + 1)) == NULL)
		exit(1);

	/* connect to relayd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	(void)strlcpy(sun.sun_path, RELAYD_SOCKET, sizeof(sun.sun_path));
 reconnect:
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		/* Keep retrying if running in monitor mode */
		if (res->action == MONITOR &&
		    (errno == ENOENT || errno == ECONNREFUSED)) {
			usleep(100);
			goto reconnect;
		}
		err(1, "connect: %s", RELAYD_SOCKET);
	}

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock);
	done = 0;

	/* process user request */
	switch (res->action) {
	case NONE:
		usage();
		/* not reached */
	case SHOW_SUM:
	case SHOW_HOSTS:
	case SHOW_RDRS:
	case SHOW_RELAYS:
	case SHOW_ROUTERS:
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, -1, NULL, 0);
		printf("%-4s\t%-8s\t%-24s\t%-7s\tStatus\n",
		    "Id", "Type", "Name", "Avlblty");
		break;
	case SHOW_SESSIONS:
		imsg_compose(ibuf, IMSG_CTL_SESSION, 0, 0, -1, NULL, 0);
		break;
	case RDR_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_RDR_ENABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case RDR_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_RDR_DISABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case TABLE_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_TABLE_ENABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case TABLE_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_TABLE_DISABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case HOST_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_HOST_ENABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case HOST_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_HOST_DISABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case SHUTDOWN:
		imsg_compose(ibuf, IMSG_CTL_SHUTDOWN, 0, 0, -1, NULL, 0);
		break;
	case POLL:
		imsg_compose(ibuf, IMSG_CTL_POLL, 0, 0, -1, NULL, 0);
		break;
	case LOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1,
		    res->path, strlen(res->path));
		done = 1;
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		done = 1;
		break;
	case MONITOR:
		imsg_compose(ibuf, IMSG_CTL_NOTIFY, 0, 0, -1, NULL, 0);
		break;
	case LOG_VERBOSE:
		verbose = 2;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));
		printf("logging request sent.\n");
		done = 1;
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW_SUM:
			case SHOW_HOSTS:
			case SHOW_RDRS:
			case SHOW_RELAYS:
			case SHOW_ROUTERS:
				done = show_summary_msg(&imsg, res->action);
				break;
			case SHOW_SESSIONS:
				done = show_session_msg(&imsg);
				break;
			case RDR_DISABLE:
			case RDR_ENABLE:
			case TABLE_DISABLE:
			case TABLE_ENABLE:
			case HOST_DISABLE:
			case HOST_ENABLE:
			case POLL:
			case SHUTDOWN:
				done = show_command_output(&imsg);
				break;
			case NONE:
			case LOG_VERBOSE:
			case LOG_BRIEF:
			case RELOAD:
			case LOAD:
				break;
			case MONITOR:
				done = monitor(&imsg);
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (error ? 1 : 0);
}

struct imsgname *
monitor_lookup(u_int8_t type)
{
	int i;

	for (i = 0; imsgs[i].name != NULL; i++)
		if (imsgs[i].type == type)
			return (&imsgs[i]);
	return (&imsgunknown);
}

void
monitor_host_status(struct imsg *imsg)
{
	struct ctl_status	 cs;

	memcpy(&cs, imsg->data, sizeof(cs));
	printf("\tid: %u\n", cs.id);
	printf("\tstate: ");
	switch (cs.up) {
	case HOST_UP:
		printf("up\n");
		break;
	case HOST_DOWN:
		printf("down\n");
		break;
	default:
		printf("unknown\n");
		break;
	}
}

void
monitor_id(struct imsg *imsg)
{
	struct ctl_id		 id;

	memcpy(&id, imsg->data, sizeof(id));
	printf("\tid: %u\n", id.id);
	if (strlen(id.name))
		printf("\tname: %s\n", id.name);
}

int
monitor(struct imsg *imsg)
{
	time_t			 now;
	int			 done = 0;
	struct imsgname		*imn;

	now = time(NULL);

	imn = monitor_lookup(imsg->hdr.type);
	printf("%s: imsg type %u len %u peerid %u pid %d\n", imn->name,
	    imsg->hdr.type, imsg->hdr.len, imsg->hdr.peerid, imsg->hdr.pid);
	printf("\ttimestamp: %lld, %s", (long long)now, ctime(&now));
	if (imn->type == -1)
		done = 1;
	if (imn->func != NULL)
		(*imn->func)(imsg);

	return (done);
}

int
show_summary_msg(struct imsg *imsg, int type)
{
	struct rdr		*rdr;
	struct table		*table;
	struct host		*host;
	struct relay		*rlay;
	struct router		*rt;
	struct netroute		*nr;
	struct ctl_stats	 stats[PROC_MAX_INSTANCES];
	char			 name[HOST_NAME_MAX+1];

	switch (imsg->hdr.type) {
	case IMSG_CTL_RDR:
		if (!(type == SHOW_SUM || type == SHOW_RDRS))
			break;
		rdr = imsg->data;
		printf("%-4u\t%-8s\t%-24s\t%-7s\t%s\n",
		    rdr->conf.id, "redirect", rdr->conf.name, "",
		    print_rdr_status(rdr->conf.flags));
		break;
	case IMSG_CTL_TABLE:
		if (!(type == SHOW_SUM || type == SHOW_HOSTS))
			break;
		table = imsg->data;
		printf("%-4u\t%-8s\t%-24s\t%-7s\t%s\n",
		    table->conf.id, "table", table->conf.name, "",
		    print_table_status(table->up, table->conf.flags));
		break;
	case IMSG_CTL_HOST:
		if (!(type == SHOW_SUM || type == SHOW_HOSTS))
			break;
		host = imsg->data;
		if (host->conf.parentid)
			snprintf(name, sizeof(name), "%s parent %u",
			    host->conf.name, host->conf.parentid);
		else
			strlcpy(name, host->conf.name, sizeof(name));
		printf("%-4u\t%-8s\t%-24s\t%-7s\t%s\n",
		    host->conf.id, "host", name,
		    print_availability(host->check_cnt, host->up_cnt),
		    print_host_status(host->up, host->flags));
		if (type == SHOW_HOSTS && host->check_cnt) {
			printf("\t%8s\ttotal: %lu/%lu checks",
			    "", host->up_cnt, host->check_cnt);
			if (host->retry_cnt)
				printf(", %d retries", host->retry_cnt);
			if (host->he && host->up == HOST_DOWN)
				printf(", error: %s", host_error(host->he));
			printf("\n");
		}
		break;
	case IMSG_CTL_RELAY:
		if (!(type == SHOW_SUM || type == SHOW_RELAYS))
			break;
		rlay = imsg->data;
		printf("%-4u\t%-8s\t%-24s\t%-7s\t%s\n",
		    rlay->rl_conf.id, "relay", rlay->rl_conf.name, "",
		    print_relay_status(rlay->rl_conf.flags));
		break;
	case IMSG_CTL_RDR_STATS:
		if (type != SHOW_RDRS)
			break;
		bcopy(imsg->data, &stats[0], sizeof(stats[0]));
		stats[1].id = EMPTY_ID;
		print_statistics(stats);
		break;
	case IMSG_CTL_RELAY_STATS:
		if (type != SHOW_RELAYS)
			break;
		bcopy(imsg->data, &stats, sizeof(stats));
		print_statistics(stats);
		break;
	case IMSG_CTL_ROUTER:
		if (!(type == SHOW_SUM || type == SHOW_ROUTERS))
			break;
		rt = imsg->data;
		printf("%-4u\t%-8s\t%-24s\t%-7s\t%s\n",
		    rt->rt_conf.id, "router", rt->rt_conf.name, "",
		    print_relay_status(rt->rt_conf.flags));
		if (type != SHOW_ROUTERS)
			break;
		if (rt->rt_conf.rtable)
			printf("\t%8s\trtable: %d\n", "", rt->rt_conf.rtable);
		if (strlen(rt->rt_conf.label))
			printf("\t%8s\trtlabel: %s\n", "", rt->rt_conf.label);
		break;
	case IMSG_CTL_NETROUTE:
		if (type != SHOW_ROUTERS)
			break;
		nr = imsg->data;
		(void)print_host(&nr->nr_conf.ss, name, sizeof(name));
		printf("\t%8s\troute: %s/%d\n",
		    "", name, nr->nr_conf.prefixlen);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		errx(1, "wrong message in summary: %u", imsg->hdr.type);
		break;
	}
	return (0);
}

int
show_session_msg(struct imsg *imsg)
{
	struct rsession		*con;
	char			 a[128], b[128];
	struct timeval		 tv_now;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SESSION:
		con = imsg->data;

		(void)print_host(&con->se_in.ss, a, sizeof(a));
		(void)print_host(&con->se_out.ss, b, sizeof(b));
		printf("session %u:%u %s:%u -> %s:%u\t%s\n",
		    imsg->hdr.peerid, con->se_id,
		    a, ntohs(con->se_in.port), b, ntohs(con->se_out.port),
		    con->se_done ? "DONE" : "RUNNING");

		getmonotime(&tv_now);
		print_time(&tv_now, &con->se_tv_start, a, sizeof(a));
		print_time(&tv_now, &con->se_tv_last, b, sizeof(b));
		printf("\tage %s, idle %s, relay %u, pid %u",
		    a, b, con->se_relayid, con->se_pid);
		/* XXX grab tagname instead of tag id */
		if (con->se_tag)
			printf(", tag (id) %u", con->se_tag);
		printf("\n");
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		errx(1, "wrong message in session: %u", imsg->hdr.type);
		break;
	}
	return (0);
}

int
show_command_output(struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	case IMSG_CTL_OK:
		printf("command succeeded\n");
		break;
	case IMSG_CTL_FAIL:
		printf("command failed\n");
		error++;
		break;
	default:
		errx(1, "wrong message in summary: %u", imsg->hdr.type);
	}
	return (1);
}

char *
print_rdr_status(int flags)
{
	if (flags & F_DISABLE) {
		return ("disabled");
	} else if (flags & F_DOWN) {
		return ("down");
	} else if (flags & F_BACKUP) {
		return ("active (using backup table)");
	} else
		return ("active");
}

char *
print_table_status(int up, int fl)
{
	static char buf[1024];

	bzero(buf, sizeof(buf));

	if (fl & F_DISABLE) {
		snprintf(buf, sizeof(buf) - 1, "disabled");
	} else if (!up) {
		snprintf(buf, sizeof(buf) - 1, "empty");
	} else
		snprintf(buf, sizeof(buf) - 1, "active (%d hosts)", up);
	return (buf);
}

char *
print_host_status(int status, int fl)
{
	if (fl & F_DISABLE)
		return ("disabled");

	switch (status) {
	case HOST_DOWN:
		return ("down");
	case HOST_UNKNOWN:
		return ("unknown");
	case HOST_UP:
		return ("up");
	default:
		errx(1, "invalid status: %d", status);
	}
}

char *
print_relay_status(int flags)
{
	if (flags & F_DISABLE) {
		return ("disabled");
	} else
		return ("active");
}

void
print_statistics(struct ctl_stats stats[PROC_MAX_INSTANCES + 1])
{
	struct ctl_stats	 crs;
	int			 i;

	bzero(&crs, sizeof(crs));
	crs.interval = stats[0].interval;
	for (i = 0; stats[i].id != EMPTY_ID; i++) {
		crs.cnt += stats[i].cnt;
		crs.last += stats[i].last;
		crs.avg += stats[i].avg;
		crs.last_hour += stats[i].last_hour;
		crs.avg_hour += stats[i].avg_hour;
		crs.last_day += stats[i].last_day;
		crs.avg_day += stats[i].avg_day;
	}
	if (crs.cnt == 0)
		return;
	printf("\t%8s\ttotal: %llu sessions\n"
	    "\t%8s\tlast: %u/%llus %u/h %u/d sessions\n"
	    "\t%8s\taverage: %u/%llus %u/h %u/d sessions\n",
	    "", crs.cnt,
	    "", crs.last, crs.interval,
	    crs.last_hour, crs.last_day,
	    "", crs.avg, crs.interval,
	    crs.avg_hour, crs.avg_day);
}
@


1.56
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.55 2015/10/12 12:17:36 semarie Exp $	*/
d52 1
a52 1
void		 print_statistics(struct ctl_stats[RELAY_MAXPROC + 1]);
d333 1
a333 1
	struct ctl_stats	 stats[RELAY_MAXPROC];
d539 1
a539 1
print_statistics(struct ctl_stats stats[RELAY_MAXPROC + 1])
@


1.55
log
@two leftovers string missed in tame->pledge conversion

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.54 2015/10/10 00:37:40 benno Exp $	*/
d210 1
a210 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.54
log
@relayctl pledges to use stdio only
ok reyk@@ sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.53 2015/01/22 17:42:09 reyk Exp $	*/
d128 1
a128 1
		err(1, "tame");
@


1.53
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.52 2015/01/16 06:40:20 deraadt Exp $	*/
d126 3
@


1.52
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.51 2014/07/09 16:42:05 reyk Exp $	*/
d25 1
a28 4
#include <net/if.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <netinet/in.h>
d31 2
a35 2
#include <stdio.h>
#include <stdlib.h>
d38 2
a39 3
#include <event.h>

#include <openssl/ssl.h>
@


1.51
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.50 2014/06/25 11:12:45 reyk Exp $	*/
d335 1
a335 1
	char			 name[MAXHOSTNAMELEN];
@


1.50
log
@I did enough significant changes and/or additions since 2007 after
pyr@@'s initial version to rightfully add my copyright to these files:
sync with reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.49 2013/11/14 20:48:52 deraadt Exp $	*/
d119 1
a119 1
	strlcpy(sun.sun_path, RELAYD_SOCKET, sizeof(sun.sun_path));
d452 3
a454 2
		if (con->se_mark)
			printf(", mark %u", con->se_mark);
@


1.49
log
@cope with the EAGAIN API change for msgbuf_write()
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.48 2013/04/27 16:39:29 benno Exp $	*/
d4 1
@


1.48
log
@time_t 64bit fixes for relayd and relayctl:
- fix statistics
- set INT_MAX limit on session timeouts
- make sure we dont use to large session timeouts in pf redirects and
  openssl

tested with old and new time_t

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.47 2013/04/03 03:10:42 guenther Exp $	*/
d206 1
a206 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.47
log
@Handle big time_t

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.46 2013/03/10 23:32:53 reyk Exp $	*/
d557 2
a558 2
	    "\t%8s\tlast: %u/%us %u/h %u/d sessions\n"
	    "\t%8s\taverage: %u/%us %u/h %u/d sessions\n",
@


1.46
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.45 2011/05/20 09:43:53 reyk Exp $	*/
d315 1
a315 1
	printf("\ttimestamp: %u, %s", now, ctime(&now));
@


1.45
log
@Concurrent calls of "relayctl show sessions" could crash relayd.  Fix
the show sessions handler by implementing it in an asynchronous way.

Closes PR 6509
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.44 2011/05/19 08:56:49 reyk Exp $	*/
d446 1
a446 2
		if (gettimeofday(&tv_now, NULL))
			fatal("show_session_msg: gettimeofday");
@


1.44
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.43 2011/05/09 12:08:46 reyk Exp $	*/
d450 2
a451 1
		printf("\tage %s, idle %s, relay %u", a, b, con->se_relayid);
@


1.43
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.42 2010/12/31 21:22:42 guenther Exp $	*/
d182 5
d189 1
a237 1
			case RELOAD:
d244 2
@


1.42
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.41 2010/01/11 06:40:14 jsg Exp $	*/
d192 1
a192 1
		imsg_compose(ibuf, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
@


1.41
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.40 2009/09/01 08:51:34 claudio Exp $	*/
d35 1
@


1.40
log
@If relayd returned an error don't exit with success. This may help scripts
to recognize when something did not work in a much easier way then parsing
the relayctl output. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.39 2009/08/17 11:36:01 reyk Exp $	*/
d105 1
a105 1
	int			 n;
d187 9
d236 2
@


1.39
log
@also report routers and their host states in relayctl

ok pyr@@, jmc@@ for man bits
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.38 2009/08/07 11:21:53 reyk Exp $	*/
d86 1
d238 1
a238 1
	return (0);
d454 1
@


1.38
log
@rename 'struct session' to 'struct rsession' because it conflicts with
another 'struct session' in sys/sysctl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.37 2009/06/05 23:39:51 pyr Exp $	*/
d142 1
d208 1
d311 2
d318 1
a318 1
		if (type == SHOW_HOSTS || type == SHOW_RELAYS)
d326 1
a326 1
		if (type == SHOW_RELAYS || type == SHOW_RDRS)
d334 1
a334 1
		if (type == SHOW_RELAYS || type == SHOW_RDRS)
d357 1
a357 1
		if (type == SHOW_HOSTS || type == SHOW_RDRS)
d376 22
@


1.37
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.36 2008/12/31 15:22:27 sobrado Exp $	*/
d385 1
a385 1
	struct session		*con;
@


1.36
log
@an ellipsis allows more than one argument being specified;
sync synopsis/usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.35 2008/12/05 16:37:56 reyk Exp $	*/
a95 7
/* dummy function so that relayctl does not need libevent */
void
imsg_event_add(struct imsgbuf *i)
{
	/* nothing */
}

d130 1
a130 1
	imsg_init(ibuf, ctl_sock, NULL);
@


1.35
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.34 2008/07/19 12:10:07 reyk Exp $	*/
d92 1
a92 1
	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
@


1.34
log
@print the host parent id if available
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.33 2008/01/31 12:12:50 thib Exp $	*/
d354 2
d466 1
a466 1
		snprintf(buf, sizeof(buf) - 1, "active (%d hosts up)", up);
@


1.33
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct session;

ok reyk@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.32 2008/01/31 09:56:29 reyk Exp $	*/
d317 1
d340 5
d346 1
a346 1
		    host->conf.id, "host", host->conf.name,
@


1.32
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.31 2007/12/20 20:15:43 reyk Exp $	*/
d392 2
a393 2
		(void)print_host(&con->in.ss, a, sizeof(a));
		(void)print_host(&con->out.ss, b, sizeof(b));
d395 3
a397 3
		    imsg->hdr.peerid, con->id,
		    a, ntohs(con->in.port), b, ntohs(con->out.port),
		    con->done ? "DONE" : "RUNNING");
d401 5
a405 5
		print_time(&tv_now, &con->tv_start, a, sizeof(a));
		print_time(&tv_now, &con->tv_last, b, sizeof(b));
		printf("\tage %s, idle %s, relay %u", a, b, con->relayid);
		if (con->mark)
			printf(", mark %u", con->mark);
@


1.31
log
@implement statistics for redirections, like the existing statistics
for relays.  they can be viewed with the new "relayctl show redirects"
command.

(uses the previous change to pf_table.c to get the statistics)

looks good pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.30 2007/12/08 20:36:36 pyr Exp $	*/
d356 2
a357 2
		    rlay->conf.id, "relay", rlay->conf.name, "",
		    print_relay_status(rlay->conf.flags));
@


1.30
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.29 2007/12/08 20:11:48 reyk Exp $	*/
d54 1
d147 1
d212 1
d316 1
a316 2
	struct ctl_stats	 stats[RELAY_MAXPROC], crs;
	int			 i;
d320 1
a320 1
		if (type == SHOW_RELAYS)
d328 1
a328 1
		if (type == SHOW_RELAYS)
d336 1
a336 1
		if (type == SHOW_RELAYS)
d352 1
a352 1
		if (type == SHOW_HOSTS)
d359 8
a366 1
	case IMSG_CTL_STATISTICS:
d370 1
a370 21
		bzero(&crs, sizeof(crs));
		crs.interval = stats[0].interval;
		for (i = 0; stats[i].id != EMPTY_ID; i++) {
			crs.cnt += stats[i].cnt;
			crs.last += stats[i].last;
			crs.avg += stats[i].avg;
			crs.last_hour += stats[i].last_hour;
			crs.avg_hour += stats[i].avg_hour;
			crs.last_day += stats[i].last_day;
			crs.avg_day += stats[i].avg_day;
		}
		if (crs.cnt == 0)
			break;
		printf("\t%8s\ttotal: %lu sessions\n"
		    "\t%8s\tlast: %lu/%us %lu/h %lu/d sessions\n"
		    "\t%8s\taverage: %lu/%us %lu/h %lu/d sessions\n",
		    "", crs.cnt,
		    "", crs.last, crs.interval,
		    crs.last_hour, crs.last_day,
		    "", crs.avg, crs.interval,
		    crs.avg_hour, crs.avg_day);
d489 28
@


1.29
log
@service -> redirect

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.28 2007/12/07 17:17:01 reyk Exp $	*/
d50 1
a50 1
char		*print_service_status(int);
d68 2
a69 2
	{ IMSG_CTL_SERVICE_DISABLE,	"ctl_disable_service",	monitor_id },
	{ IMSG_CTL_SERVICE_ENABLE,	"ctl_service_enable",	monitor_id },
d154 2
a155 2
	case SERV_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_SERVICE_ENABLE, 0, 0, -1,
d158 2
a159 2
	case SERV_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_SERVICE_DISABLE, 0, 0, -1,
d216 2
a217 2
			case SERV_DISABLE:
			case SERV_ENABLE:
d309 1
a309 1
	struct service		*service;
d317 1
a317 1
	case IMSG_CTL_SERVICE:
d320 1
a320 1
		service = imsg->data;
d322 2
a323 2
		    service->conf.id, "redirect", service->conf.name, "",
		    print_service_status(service->conf.flags));
d445 1
a445 1
print_service_status(int flags)
@


1.28
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: relayctl.c,v 1.27 2007/11/24 17:09:12 reyk Exp $	*/
d148 2
a149 2
		printf("Type\t%4s\t%-24s\t%-7s\tStatus\n",
		    "Id", "Name", "Avlblty");
d321 2
a322 2
		printf("service\t%4u\t%-24s\t%-7s\t%s\n",
		    service->conf.id, service->conf.name, "",
d329 2
a330 2
		printf("table\t%4u\t%-24s\t%-7s\t%s\n",
		    table->conf.id, table->conf.name, "",
d337 2
a338 2
		printf("host\t%4u\t%-24s\t%-7s\t%s\n",
		    host->conf.id, host->conf.name,
d342 1
a342 1
			printf("\t%4s\ttotal: %lu/%lu checks",
d353 2
a354 2
		printf("relay\t%4u\t%-24s\t%-7s\t%s\n",
		    rlay->conf.id, rlay->conf.name, "",
d374 3
a376 3
		printf("\t%4s\ttotal: %lu sessions\n"
		    "\t%4s\tlast: %lu/%us %lu/h %lu/d sessions\n"
		    "\t%4s\taverage: %lu/%us %lu/h %lu/d sessions\n",
@


1.27
log
@style(9) for includes
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.26 2007/11/23 09:39:42 reyk Exp $	*/
d43 1
a43 1
#include "hoststated.h"
d95 1
a95 1
/* dummy function so that hoststatectl does not need libevent */
d116 1
a116 1
	/* connect to hoststated control socket */
d122 1
a122 1
	strlcpy(sun.sun_path, HOSTSTATED_SOCKET, sizeof(sun.sun_path));
d131 1
a131 1
		err(1, "connect: %s", HOSTSTATED_SOCKET);
@


1.26
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.25 2007/10/19 12:08:54 pyr Exp $	*/
d26 1
a26 2
#include <netinet/in.h>
#include <arpa/inet.h>
d30 2
@


1.25
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.24 2007/09/29 16:23:06 pyr Exp $	*/
d413 4
a416 1
		printf("\tage %s, idle %s, relay %u\n", a, b, con->relayid);
@


1.24
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.23 2007/09/28 13:29:56 pyr Exp $	*/
d180 3
d221 1
@


1.23
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.22 2007/09/07 08:33:31 reyk Exp $	*/
d66 1
a66 1
	{ IMSG_HOST_STATUS,		"host_status",		monitor_host_status },
@


1.22
log
@add a "show sessions" command to dump the complete list of running relay
sessions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.20 2007/06/12 18:09:00 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.21
log
@simple style change in the switch
@
text
@d47 1
d150 3
d209 3
d382 33
@


1.20
log
@reflect msf's changes to the imsg framework in hoststated.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.19 2007/05/29 23:19:18 pyr Exp $	*/
a200 2
				done = show_summary_msg(&imsg, SHOW_SUM);
				break;
a201 2
				done = show_summary_msg(&imsg, SHOW_HOSTS);
				break;
d203 1
a203 1
				done = show_summary_msg(&imsg, SHOW_RELAYS);
@


1.19
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.18 2007/05/29 00:21:10 pyr Exp $	*/
d145 1
a145 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, NULL, 0);
d150 1
a150 1
		imsg_compose(ibuf, IMSG_CTL_SERVICE_ENABLE, 0, 0,
d154 1
a154 1
		imsg_compose(ibuf, IMSG_CTL_SERVICE_DISABLE, 0, 0,
d158 1
a158 1
		imsg_compose(ibuf, IMSG_CTL_TABLE_ENABLE, 0, 0,
d162 1
a162 1
		imsg_compose(ibuf, IMSG_CTL_TABLE_DISABLE, 0, 0,
d166 1
a166 1
		imsg_compose(ibuf, IMSG_CTL_HOST_ENABLE, 0, 0,
d170 1
a170 1
		imsg_compose(ibuf, IMSG_CTL_HOST_DISABLE, 0, 0,
d174 1
a174 1
		imsg_compose(ibuf, IMSG_CTL_SHUTDOWN, 0, 0, NULL, 0);
d177 1
a177 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
d180 1
a180 1
		imsg_compose(ibuf, IMSG_CTL_NOTIFY, 0, 0, NULL, 0);
@


1.18
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.17 2007/05/28 00:04:47 pyr Exp $	*/
d215 2
a218 2
			case RELOAD:
			case SHUTDOWN:
@


1.17
log
@Reflect recent hoststated changes into hoststatectl
This unbreaks the tree.
Fixed from the depth of the OpenBSD lair.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.16 2007/02/22 05:59:13 reyk Exp $	*/
d346 2
a347 2
		    rlay->id, rlay->name, "",
		    print_relay_status(rlay->flags));
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.15 2007/02/22 03:32:40 reyk Exp $	*/
d314 2
a315 2
		    service->id, service->name, "",
		    print_service_status(service->flags));
d322 2
a323 2
		    table->id, table->name, "",
		    print_table_status(table->up, table->flags));
d330 1
a330 1
		    host->id, host->name,
@


1.15
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.14 2007/02/06 08:45:46 pyr Exp $	*/
d306 1
a306 1
	int		 	 i;
@


1.14
log
@inform hoststatectl monitor of ruleset changes and table syncs.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.13 2007/02/03 17:51:46 reyk Exp $	*/
d46 1
a46 1
int		 show_summary_msg(struct imsg *);
d51 1
d143 2
d146 2
a147 1
		printf("Type\t%4s\t%-24s\tStatus\n", "Id", "Name");
d201 7
a207 1
				done = show_summary_msg(&imsg);
d299 1
a299 1
show_summary_msg(struct imsg *imsg)
d301 6
a306 3
	struct service	*service;
	struct table	*table;
	struct host	*host;
d310 2
d313 2
a314 2
		printf("service\t%4u\t%-24s\t%s\n",
		    service->id, service->name,
d318 2
d321 2
a322 2
		printf("table\t%4u\t%-24s\t%s",
		    table->id, table->name,
a323 1
		printf("\n");
d326 2
d329 1
a329 1
		printf("host\t%4u\t%-24s\t%s\n",
d331 1
d333 41
d446 10
@


1.13
log
@wait for hoststated to become available in monitor mode.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.11 2007/02/01 21:01:10 reyk Exp $	*/
d71 3
@


1.12
log
@print id name in the monitor output if available
@
text
@d33 1
d117 8
a124 1
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
d126 1
@


1.11
log
@modify the imsg monitor to look even nicer and to use a more flexible
API (inspired by the ipsec pfkey monitor).

ok pyr@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.9 2007/01/29 14:23:31 pyr Exp $	*/
d251 2
@


1.10
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@a46 1
int		 monitor(struct imsg *);
d51 26
d212 41
d257 2
a258 3
	int			 done;
	struct ctl_status	 cs; 
	struct ctl_id		 id; 
a259 1
	done = 0;
d261 6
a266 35
	printf("got message of size %u on  %s", imsg->hdr.len, ctime(&now));
	switch (imsg->hdr.type) {
	case IMSG_HOST_STATUS:
		memcpy(&cs, imsg->data, sizeof(cs));
		printf("HOST_STATUS: %u is in state %d\n", cs.id, cs.up);
		break;
	case IMSG_CTL_SERVICE_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_SERVICE_DISABLE: %u\n", id.id);
		break;
	case IMSG_CTL_SERVICE_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_SERVICE_ENABLE: %u\n", id.id);
		break;
	case IMSG_CTL_TABLE_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_TABLE_DISABLE: %u\n", id.id);
		break;
	case IMSG_CTL_TABLE_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_TABLE_ENABLE: %u\n", id.id);
		break;
	case IMSG_CTL_HOST_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_HOST_DISABLE: %u\n", id.id);
		break;
	case IMSG_CTL_HOST_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_HOST_ENABLE: %u\n", id.id);
		break;
	case IMSG_SYNC:
		printf("SYNC\n");
		break;
	default:
		printf("INVALID\n");
d268 3
a270 2
		break;
	}
@


1.9
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.8 2007/01/09 13:50:10 pyr Exp $	*/
d47 1
d138 3
d174 3
d185 51
@


1.8
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.7 2007/01/09 00:45:32 deraadt Exp $	*/
d38 2
@


1.7
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.6 2006/12/16 18:50:33 reyk Exp $	*/
d60 1
a60 1
/* dummy function so that hostatectl does not need libevent */
d81 1
a81 1
	/* connect to hostated control socket */
d87 1
a87 1
	strlcpy(sun.sun_path, HOSTATED_SOCKET, sizeof(sun.sun_path));
d89 1
a89 1
		err(1, "connect: %s", HOSTATED_SOCKET);
@


1.6
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.5 2006/12/16 17:52:21 deraadt Exp $	*/
d39 1
a39 1
#include "hostated.h"
@


1.5
log
@spacing, plus dubious \% in format string
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.4 2006/12/16 15:02:35 reyk Exp $	*/
d103 1
a103 1
		printf("type\t%4s\t%-16s\tstatus\n\n", "id", "name");
d188 1
a188 1
		printf("service\t%4u\t%-16s\t%s\n",
d194 1
a194 1
		printf("table\t%4u\t%-16s\t%s",
d201 1
a201 1
		printf("host\t%4u\t%-16s\t%s\n",
@


1.4
log
@more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.3 2006/12/16 14:21:15 bernd Exp $	*/
d103 1
a103 1
		printf("type\t\%4s\t%-16s\tstatus\n\n", "id", "name");
d107 1
a107 1
		     &res->id, sizeof(res->id));
d115 1
a115 1
		     &res->id, sizeof(res->id));
d119 1
a119 1
		     &res->id, sizeof(res->id));
d123 1
a123 1
		     &res->id, sizeof(res->id));
d127 1
a127 1
		     &res->id, sizeof(res->id));
@


1.3
log
@Fix two comments. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.2 2006/12/16 12:47:18 reyk Exp $	*/
d107 1
a107 1
			     &res->id, sizeof(res->id));
d111 1
a111 1
			     &res->id, sizeof(res->id));
d115 1
a115 1
			     &res->id, sizeof(res->id));
d119 1
a119 1
			     &res->id, sizeof(res->id));
d123 1
a123 1
			     &res->id, sizeof(res->id));
d127 1
a127 1
			     &res->id, sizeof(res->id));
d255 1
a255 2
		snprintf(buf, sizeof(buf) - 1, "active (%d hosts up)",
			 up);
@


1.2
log
@knf, spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d60 1
a60 1
/* dummy function so that ospfctl does not need libevent */
d81 1
a81 1
	/* connect to ospfd control socket */
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d189 2
a190 2
		       service->id, service->name,
		       print_service_status(service->flags));
d195 2
a196 2
		       table->id, table->name,
		       print_table_status(table->up, table->flags));
d202 2
a203 2
		       host->id, host->name,
		       print_host_status(host->up, host->flags));
d234 1
a234 1
		return("disabled");
d236 1
a236 1
		return("down");
d238 1
a238 1
		return("active (using backup table)");
d240 1
a240 1
		return("active");
d264 1
a264 1
		return("disabled");
d268 1
a268 1
		return("down");
d270 1
a270 1
		return("unknown");
d272 1
a272 1
		return("up");
@

