head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.8
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.17.0.18
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.16
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.22
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.18
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.16
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.09.11.19.03.30;	author millert;	state Exp;
branches;
next	1.21;
commitid	2QXXvPxjHIjOK2wR;

1.21
date	2014.10.26.02.43.50;	author guenther;	state Exp;
branches;
next	1.20;
commitid	QMh02q5MFiw3np67;

1.20
date	2014.10.20.06.55.59;	author guenther;	state Exp;
branches;
next	1.19;
commitid	1xnKI9ul35JBjA4W;

1.19
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.18;
commitid	bZbpWDoZDVt0RPe1;

1.18
date	2014.10.20.00.20.04;	author guenther;	state Exp;
branches;
next	1.17;
commitid	ciYfifbFHhmQvDo5;

1.17
date	2010.12.21.18.45.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.12.13.21.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.21.20.57.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.04.15.19.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.18.00.50.23;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.23.03.07.18;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.29.18.39.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.26.02.49.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.25.07.37.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.25.07.33.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.02.06.22.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Since immediate_abort is modified by a signal handler it must be
volatile sig_atomic_t.
@
text
@/*
 * Copyright (c) 1989 Jan-Simon Pendry
 * Copyright (c) 1989 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)amd.c	8.1 (Berkeley) 6/6/93
 *	$Id: amd.c,v 1.21 2014/10/26 02:43:50 guenther Exp $
 */

/*
 * Automounter
 */

#include "am.h"
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <setjmp.h>
#include <endian.h>

#include <rpc/rpc.h>
#include <rpcsvc/ypclnt.h>
#include <rpcsvc/yp_prot.h>

#if BYTE_ORDER == LITTLE_ENDIAN
#define ARCH_ENDIAN "little"
#elif BYTE_ORDER == BIG_ENDIAN
#define ARCH_ENDIAN "big"
#else
#error "unknown endian"
#endif

char pid_fsname[16 + MAXHOSTNAMELEN];	/* "kiska.southseas.nz:(pid%d)" */
#ifdef HAS_HOST
#ifdef HOST_EXEC
char *host_helper;
#endif /* HOST_EXEC */
#endif /* HAS_HOST */
char *auto_dir = "/tmp_mnt";
char *hostdomain = "unknown.domain";
char hostname[MAXHOSTNAMELEN] = "localhost"; /* Hostname */
char hostd[2*MAXHOSTNAMELEN];		/* Host+domain */
char *op_sys = "bsd44";			/* Name of current op_sys */
char *arch = ARCH_REP;			/* Name of current architecture */
char *endian = ARCH_ENDIAN;		/* Big or Little endian */
char *wire;
int foreground = 1;			/* This is the top-level server */
pid_t mypid;				/* Current process id */
volatile sig_atomic_t immediate_abort;	/* Should close-down unmounts be retried */
struct in_addr myipaddr;		/* (An) IP address of this host */
serv_state amd_state;
struct amd_stats amd_stats;		/* Server statistics */
time_t do_mapc_reload = 0;		/* mapc_reload() call required? */
jmp_buf select_intr;
int select_intr_valid;
int orig_umask;

/*
 * Signal handler:
 * SIGINT - tells amd to do a full shutdown, including unmounting all filesystem.
 * SIGTERM - tells amd to shutdown now.  Just unmounts the automount nodes.
 */
static void
sigterm(int sig)
{

	switch (sig) {
	case SIGINT:
		immediate_abort = 15;
		break;

	case SIGTERM:
		immediate_abort = -1;
		/* fall through... */

	default:
		plog(XLOG_WARNING, "WARNING: automounter going down on signal %d", sig);
		break;
	}
	if (select_intr_valid)
		longjmp(select_intr, sig);
}

/*
 * Hook for cache reload.
 * When a SIGHUP arrives it schedules a call to mapc_reload
 */
static void
sighup(int sig)
{

#ifdef DEBUG
	if (sig != SIGHUP)
		dlog("spurious call to sighup");
#endif /* DEBUG */
	/*
	 * Force a reload by zero'ing the timer
	 */
	if (amd_state == Run)
		do_mapc_reload = 0;
}

static void
parent_exit(int sig)
{
	_exit(0);
}

static pid_t
daemon_mode(void)
{
	pid_t bgpid;

	signal(SIGQUIT, parent_exit);
	bgpid = background();

	if (bgpid != 0) {
		if (print_pid) {
			printf("%ld\n", (long)bgpid);
			fflush(stdout);
		}
		/*
		 * Now wait for the automount points to
		 * complete.
		 */
		for (;;)
			pause();
	}

	signal(SIGQUIT, SIG_DFL);

	/*
	 * Pretend we are in the foreground again
	 */
	foreground = 1;

#ifdef TIOCNOTTY
	{
		int t = open("/dev/tty", O_RDWR);
		if (t < 0) {
			if (errno != ENXIO)	/* not an error if already no controlling tty */
				plog(XLOG_WARNING, "Could not open controlling tty: %m");
		} else {
			if (ioctl(t, TIOCNOTTY, 0) < 0 && errno != ENOTTY)
				plog(XLOG_WARNING, "Could not disassociate tty (TIOCNOTTY): %m");
			(void) close(t);
		}
	}
#else
	(void) setpgrp();
#endif /* TIOCNOTTY */

	return getppid();
}

int
main(int argc, char *argv[])
{
	char *domdot;
	pid_t ppid = 0;
	int error;

	/*
	 * Make sure some built-in assumptions are true before we start
	 */
	assert(sizeof(nfscookie) >= sizeof (unsigned int));
	assert(sizeof(int) >= 4);

	/*
	 * Set processing status.
	 */
	amd_state = Start;

	/*
	 * Initialise process id.  This is kept
	 * cached since it is used for generating
	 * and using file handles.
	 */
	mypid = getpid();

	/*
	 * Get local machine name
	 */
	if (gethostname(hostname, sizeof(hostname)) < 0) {
		plog(XLOG_FATAL, "gethostname: %m");
		going_down(1);
	}
	/*
	 * Check it makes sense
	 */
	if (!*hostname) {
		plog(XLOG_FATAL, "host name is not set");
		going_down(1);
	}
	/*
	 * Partially initialise hostd[].  This
	 * is completed in get_args().
	 */
	if ((domdot = strchr(hostname, '.'))) {
		/*
		 * Hostname already contains domainname.
		 * Split out hostname and domainname
		 * components
		 */
		*domdot++ = '\0';
		hostdomain = domdot;
	}
	strlcpy(hostd, hostname, sizeof hostd);

	/*
	 * Trap interrupts for shutdowns.
	 */
	(void) signal(SIGINT, sigterm);

	/*
	 * Hangups tell us to reload the cache
	 */
	(void) signal(SIGHUP, sighup);

	/*
	 * Trap Terminate so that we can shutdown gracefully (some chance)
	 */
	(void) signal(SIGTERM, sigterm);
	/*
	 * Trap Death-of-a-child.  These allow us to
	 * pick up the exit status of backgrounded mounts.
	 * See "sched.c".
	 */
	(void) signal(SIGCHLD, sigchld);

	/*
	 * Fix-up any umask problems.  Most systems default
	 * to 002 which is not too convenient for our purposes
	 */
	orig_umask = umask(0);

	/*
	 * Figure out primary network name
	 */
	wire = getwire();

	/*
	 * Determine command-line arguments
	 */
	get_args(argc, argv);

	if (mkdir(auto_dir, 0755) == -1) {
		if (errno != EEXIST)
			plog(XLOG_FATAL, "mkdir(autodir = %s: %m", auto_dir);
	}

	/*
	 * Get our own IP address so that we
	 * can mount the automounter.
	 */
	{ struct sockaddr_in sin;
	  get_myaddress(&sin);
	  myipaddr.s_addr = sin.sin_addr.s_addr;
	}

	/*
	 * Now check we are root.
	 */
	if (geteuid() != 0) {
		plog(XLOG_FATAL, "Must be root to mount filesystems (euid = %u)", geteuid());
		going_down(1);
	}

	/*
	 * If the domain was specified then bind it here
	 * to circumvent any default bindings that may
	 * be done in the C library.
	 */
	if (domain && yp_bind(domain)) {
		plog(XLOG_FATAL, "Can't bind to domain \"%s\"", domain);
		going_down(1);
	}

#ifdef DEBUG
	Debug(D_DAEMON)
#endif /* DEBUG */
	ppid = daemon_mode();

	snprintf(pid_fsname, sizeof(pid_fsname), "%s:(pid%ld)", hostname, (long)mypid);

	do_mapc_reload = clocktime() + ONE_HOUR;

	/*
	 * Register automounter with system
	 */
	error = mount_automounter(ppid);
	if (error && ppid)
		kill(ppid, SIGALRM);
	going_down(error);

	abort();
}
@


1.21
log
@Lint is dead
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.20 2014/10/20 06:55:59 guenther Exp $
d79 1
a79 1
int immediate_abort;			/* Should close-down unmounts be retried */
@


1.20
log
@Change MTAB_TYPE_UFS from "ufs" to "ffs", fixing mount-restarting for them.
Perform one level of expansion on the various "portability" macros from os-*.h
Delete support for Hesiod and the pre-4.4 versions of the NFS API
Delete the no-op unlock_mntlist()
unifdef -UFASCIST_DF_COMMAND -UMOUNT_HELPER_SOURCE
Move the struct mntent and MNTMAXSTR definitions into include/am.h
Move the commented-out -DHAS_NDBM_MAPS into amd/Makefile
Expand OS_REP to "bsd44".
With config/* empty, delete them.

"lot of stuff...but I know your process on this" deraadt@@
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.19 2014/10/20 02:33:42 guenther Exp $
a117 1
/*ARGSUSED*/
a132 1
/*ARGSUSED*/
@


1.19
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.18 2014/10/20 00:20:04 guenther Exp $
d73 1
a73 1
char *op_sys = OS_REP;			/* Name of current op_sys */
@


1.18
log
@Start removing portability goo: we have syslog(), strerror(), POSIX regexp,
    BSD-style getmntinfo(), BSD signals, 4.4BSD unmount(), etc
Delete configurations for other OSes
Delete fsinfo and mk-amd-map, as we don't build them.

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.17 2010/12/21 18:45:54 deraadt Exp $
a300 1
#ifdef HAS_NIS_MAPS
a309 1
#endif /* HAS_NIS_MAPS */
@


1.17
log
@parent_exit() signal handler must use _exit() not exit()
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.16 2009/10/27 23:59:50 deraadt Exp $
d49 1
d55 8
a95 3
#ifdef SYS5_SIGNALS
	signal(sig, sigterm);
#endif /* SYS5_SIGNALS */
a121 3
#ifdef SYS5_SIGNALS
	signal(sig, sighup);
#endif /* SYS5_SIGNALS */
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.15 2009/08/12 13:21:17 deraadt Exp $
d135 1
a135 1
	exit(0);
@


1.15
log
@change some defaults inside amd itself, so that the rc scripts no longer
have to pass those options.  this makes amd much easier to restart by
hand (though it still remains a nasty daemon do that with)
ok millert
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.14 2004/10/21 20:57:08 millert Exp $
a36 6

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */
@


1.14
log
@Backout poll changes; the first mount gets an error for some reason.
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.13 2004/10/04 15:19:04 millert Exp $
d66 1
a66 1
char *auto_dir = "/a";
@


1.13
log
@Use poll(2) and svc_getreq_poll(2).  Tested by matthieu@@, ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.12 2003/06/02 23:36:51 millert Exp $
d81 2
a82 2
jmp_buf poll_intr;
int poll_intr_valid;
d110 2
a111 2
	if (poll_intr_valid)
		longjmp(poll_intr, sig);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: amd.c,v 1.11 2002/08/05 07:24:26 pvalchev Exp $
d81 2
a82 2
jmp_buf select_intr;
int select_intr_valid;
d110 2
a111 2
	if (select_intr_valid)
		longjmp(select_intr, sig);
@


1.11
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: amd.c,v 1.10 2002/08/03 08:29:31 pvalchev Exp $
@


1.10
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.9 2002/07/18 00:50:23 pvalchev Exp $
d149 1
a149 1
daemon_mode(P_void)
@


1.9
log
@ANSIfy; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.8 2002/06/23 03:07:18 deraadt Exp $
d94 2
a95 1
static void sigterm(int sig)
d123 2
a124 1
static void sighup(int sig)
d142 2
a143 1
static void parent_exit(int sig)
d148 2
a149 1
static pid_t daemon_mode(P_void)
@


1.8
log
@uid_t and gid_t are unsigned
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.7 2002/06/11 05:29:54 itojun Exp $
d94 1
a94 2
static void sigterm(sig)
int sig;
d122 1
a122 2
static void sighup(sig)
int sig;
d140 1
a140 2
static void parent_exit(sig)
int sig;
d192 1
a192 3
main(argc, argv)
int argc;
char *argv[];
@


1.7
log
@use snprintf.
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.6 2002/05/29 18:39:00 deraadt Exp $
d305 1
a305 1
		plog(XLOG_FATAL, "Must be root to mount filesystems (euid = %d)", geteuid());
@


1.6
log
@more strlcat and strlcpy
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.5 2002/05/26 02:49:50 deraadt Exp $
d326 1
a326 1
	sprintf(pid_fsname, "%s:(pid%ld)", hostname, (long)mypid);
@


1.5
log
@pid_cleanup, inspired by work by jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.4 2002/05/25 07:37:19 deraadt Exp $
d248 1
a248 1
	strcpy(hostd, hostname);
@


1.4
log
@__progname stuff; jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.3 2002/05/25 07:33:36 deraadt Exp $
d79 1
a79 1
int mypid;				/* Current process id */
d148 1
a148 1
static int daemon_mode(P_void)
d150 1
a150 1
	int bgpid;
d157 1
a157 1
			printf("%d\n", bgpid);
d200 1
a200 1
	int ppid = 0;
d326 1
a326 1
	sprintf(pid_fsname, "%s:(pid%d)", hostname, mypid);
@


1.3
log
@incorrrect kill(); jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.2 2001/03/02 06:22:21 deraadt Exp $
a64 1
char *progname;				/* "amd" */
a212 14

	/*
	 * Determine program name
	 */
	if (argv[0]) {
		progname = strrchr(argv[0], '/');
		if (progname && progname[1])
			progname++;
		else
			progname = argv[0];
	}

	if (!progname)
		progname = "amd";
@


1.2
log
@if auto_dir does not exist, create it
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.1.1.1 1995/10/18 08:47:10 deraadt Exp $
d350 1
a350 1
		kill(SIGALRM, ppid);
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: amd.c,v 1.3 1994/06/13 20:47:01 mycroft Exp $
d53 1
a53 1
#include <sys/signal.h>
d55 1
d57 1
d60 4
d195 1
d254 1
a254 1
	if (domdot = strchr(hostname, '.')) {
d301 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
