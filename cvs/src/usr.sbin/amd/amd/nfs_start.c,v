head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.34
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.32
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.30
	OPENBSD_5_0:1.15.0.28
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.26
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.24
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.20
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.22
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.18
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.16
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.14
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.12
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.08.20.22.46.32;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	bryBnuht7UhcZOWL;

1.19
date	2015.01.21.09.50.25;	author guenther;	state Exp;
branches;
next	1.18;
commitid	cGf82el9lnnFrg2e;

1.18
date	2014.10.26.03.03.34;	author guenther;	state Exp;
branches;
next	1.17;
commitid	RhupU2WFUkfzry1g;

1.17
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.16;
commitid	bZbpWDoZDVt0RPe1;

1.16
date	2013.04.17.15.55.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.21.20.57.08;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.04.15.19.04;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.10.05.43.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.18.00.50.23;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.26.02.49.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.23.24.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.02.06.22.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.12.17.20.37.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.01.31.14.42.01;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)nfs_start.c	8.1 (Berkeley) 6/6/93
 *	$Id: nfs_start.c,v 1.19 2015/01/21 09:50:25 guenther Exp $
 */

#include "am.h"
#include "amq.h"
#include <signal.h>
#include <unistd.h>
#include <setjmp.h>

extern jmp_buf select_intr;
extern int select_intr_valid;

#ifdef HAS_TFS
/*
 * Use replacement for RPC/UDP transport
 * so that we do NFS gatewaying.
 */
#define	svcudp_create svcudp2_create
extern SVCXPRT *svcudp2_create(int);
#endif /* HAS_TFS */

unsigned short nfs_port;
SVCXPRT *nfsxprt, *lnfsxprt;
SVCXPRT *amqp, *lamqp;

extern int fwd_sock;
int max_fds = -1;

#ifdef DEBUG
/*
 * Check that we are not burning resources
 */
static void
checkup(void)
{
	static int max_fd = 0;
	static char *max_mem = 0;

	int next_fd = dup(0);
	extern caddr_t sbrk(int);
	caddr_t next_mem = sbrk(0);
	close(next_fd);

	/*if (max_fd < 0) {
		max_fd = next_fd;
	} else*/ if (max_fd < next_fd) {
		dlog("%d new fds allocated; total is %d",
			next_fd - max_fd, next_fd);
		max_fd = next_fd;
	}

	/*if (max_mem == 0) {
		max_mem = next_mem;
	} else*/ if (max_mem < next_mem) {
		dlog("%#lx bytes of memory allocated; total is %#lx (%ld pages)",
			(unsigned long)(next_mem - max_mem),
			(unsigned long)next_mem,
			((unsigned long)next_mem+getpagesize()-1)/getpagesize());
		max_mem = next_mem;
	}
}
#endif /* DEBUG */

static int
do_select(sigset_t *mask, sigset_t *omask, int fds, fd_set *fdp,
    struct timeval *tvp)
{
	int sig;
	int nsel;

	if ((sig = setjmp(select_intr))) {
		select_intr_valid = 0;
		/* Got a signal */
		switch (sig) {
		case SIGINT:
		case SIGTERM:
			amd_state = Finishing;
			reschedule_timeout_mp();
			break;
		}
		nsel = -1;
		errno = EINTR;
	} else {
		select_intr_valid = 1;
		/*
		 * Invalidate the current clock value
		 */
		clock_valid = 0;
		/*
		 * Allow interrupts.  If a signal
		 * occurs, then it will cause a longjmp
		 * up above.
		 */
		sigprocmask(SIG_SETMASK, omask, NULL);
		/*
		 * Wait for input
		 */
		nsel = select(fds, fdp, NULL, NULL,
		    tvp->tv_sec ? tvp : (struct timeval *) 0);

	}

	sigprocmask(SIG_BLOCK, mask, NULL);

	/*
	 * Perhaps reload the cache?
	 */
	if (do_mapc_reload < clocktime()) {
		mapc_reload();
		do_mapc_reload = clocktime() + ONE_HOUR;
	}
	return nsel;
}

/*
 * Determine whether anything is left in
 * the RPC input queue.
 */
static int
rpc_pending_now(void)
{
	struct timeval tvv;
	int nsel;
	fd_set *fdsp;
	int fdsn;

	fdsn = howmany(max_fds+1, NFDBITS) * sizeof(fd_mask);
	if ((fdsp = malloc(fdsn)) == NULL)
		return(0);
	memset(fdsp, 0, fdsn);
	FD_SET(fwd_sock, fdsp);

	tvv.tv_sec = tvv.tv_usec = 0;
	nsel = select(max_fds+1, fdsp, NULL, NULL, &tvv);
	if (nsel < 1) {
		free(fdsp);
		return(0);
	}
	if (FD_ISSET(fwd_sock, fdsp)) {
		free(fdsp);
		return(1);
	}
	free(fdsp);
	return(0);
}

static serv_state
run_rpc(void)
{
	sigset_t mask, omask;

	sigemptyset(&mask);
	sigaddset(&mask, SIGINT);
	sigaddset(&mask, SIGTERM);
	sigaddset(&mask, SIGCHLD);
	sigaddset(&mask, SIGHUP);
	sigprocmask(SIG_BLOCK, &mask, &omask);

	next_softclock = clocktime();

	amd_state = Run;

	/*
	 * Keep on trucking while we are in Run mode.  This state
	 * is switched to Quit after all the file systems have
	 * been unmounted.
	 */
	while ((int)amd_state <= (int)Finishing) {
		struct timeval tvv;
		int nsel;
		time_t now;
#ifdef __OpenBSD__
		extern int __svc_fdsetsize;
		extern fd_set *__svc_fdset;
		fd_set *fdsp;
		int fdsn = __svc_fdsetsize;
		int bytes;

		if (fwd_sock > fdsn)
			fdsn = fwd_sock;
		bytes = howmany(fdsn, NFDBITS) * sizeof(fd_mask);

		fdsp = malloc(bytes);
		memset(fdsp, 0, bytes);
		memcpy(fdsp, __svc_fdset, bytes);
		FD_SET(fwd_sock, fdsp);
#else
		fd_set *fdsp;
		int fdsn = FDSETSIZE;
		bytes = howmany(fdsn, NFDBITS) * sizeof(fd_mask);
		fdsp = malloc(bytes);
		memcpy(fdsp, &svc_fdset, bytes);
		FD_SET(fwd_sock, fdsp);
#endif

#ifdef DEBUG
		checkup();
#endif /* DEBUG */

		/*
		 * If the full timeout code is not called,
		 * then recompute the time delta manually.
		 */
		now = clocktime();

		if (next_softclock <= now) {
			if (amd_state == Finishing)
				umount_exported();
			tvv.tv_sec = softclock();
		} else {
			tvv.tv_sec = next_softclock - now;
		}
		tvv.tv_usec = 0;

		if (amd_state == Finishing && last_used_map < 0) {
			flush_mntfs();
			amd_state = Quit;
			break;
		}

#ifdef DEBUG
		if (tvv.tv_sec)
			dlog("Select waits for %llds", (long long)tvv.tv_sec);
		else
			dlog("Select waits for Godot");
#endif /* DEBUG */

		nsel = do_select(&mask, &omask, fdsn + 1, fdsp, &tvv);


		switch (nsel) {
		case -1:
			if (errno == EINTR) {
#ifdef DEBUG
				dlog("select interrupted");
#endif /* DEBUG */
				continue;
			}
			perror("select");
			break;

		case 0:
#ifdef DEBUG
			/*dlog("select returned 0");*/
#endif /* DEBUG */
			break;

		default:
			/* Read all pending NFS responses at once to avoid
			   having responses queue up as a consequence of
			   retransmissions. */
			if (FD_ISSET(fwd_sock, fdsp)) {
				FD_CLR(fwd_sock, fdsp);
				--nsel;
				do {
					fwd_reply();
				} while (rpc_pending_now() > 0);
			}

			if (nsel) {
				/*
				 * Anything left must be a normal
				 * RPC request.
				 */
#ifdef __OpenBSD__
				svc_getreqset2(fdsp, fdsn);
#else
				svc_getreqset(fdsp);
#endif
			}
			break;
		}
		free(fdsp);
	}

	sigprocmask(SIG_SETMASK, &omask, NULL);

	if (amd_state == Quit)
		amd_state = Done;

	return amd_state;
}

static int
bindnfs_port(int so)
{
	unsigned short port;
	int error = bind_resv_port(so, &port);
	if (error == 0)
		nfs_port = port;
	return error;
}

void
unregister_amq(void)
{
#ifdef DEBUG
	Debug(D_AMQ)
#endif /* DEBUG */
	(void) pmap_unset(AMQ_PROGRAM, AMQ_VERSION);
}

int
mount_automounter(pid_t ppid)
{
	struct sockaddr_in sin;
	int so, so2, nmount;
	int sinlen;
	int on = 1;

	so = socket(AF_INET, SOCK_DGRAM, 0);

	if (so < 0 || bindnfs_port(so) < 0) {
		perror("Can't create privileged nfs port");
		return 1;
	}

	if ((nfsxprt = svcudp_create(so)) == NULL ||
	    (amqp = svcudp_create(so)) == NULL) {
		plog(XLOG_FATAL, "cannot create rpc/udp service");
		return 2;
	}

	sinlen = sizeof sin;
	if (getsockname(so, (struct sockaddr *)&sin, &sinlen) == -1) {
		perror("Can't get information on socket");
		return 1;
	}

	so2 = socket(AF_INET, SOCK_DGRAM, 0);
	if (so2 < 0) {
		perror("Can't create 2nd socket");
		return 1;
	}

	setsockopt(so2, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);

	sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	if (bind(so2, (struct sockaddr *)&sin, sizeof sin) == -1) {
		perror("Can't bind 2nd socket");
		return 1;
	}

	if ((lnfsxprt = svcudp_create(so2)) == NULL ||
	    (lamqp = svcudp_create(so2)) == NULL) {
		plog(XLOG_FATAL, "cannot create rpc/udp service");
		return 2;
	}

	if (!svc_register(nfsxprt, NFS_PROGRAM, NFS_VERSION, nfs_program_2, 0)) {
		plog(XLOG_FATAL, "unable to register (NFS_PROGRAM, NFS_VERSION, 0)");
		return 3;
	}

	/*
	 * Start RPC forwarding
	 */
	if (fwd_init() != 0)
		return 3;

	/*
	 * One or other of so, fwd_sock
	 * must be the highest fd on
	 * which to select.
	 */
	if (so > max_fds)
		max_fds = so;
	if (so2 > max_fds)
		max_fds = so2;
	if (fwd_sock > max_fds)
		max_fds = fwd_sock;

	/*
	 * Construct the root automount node
	 */
	make_root_node();

	/*
	 * Pick up the pieces from a previous run
	 * This is likely to (indirectly) need the rpc_fwd package
	 * so it *must* come after the call to fwd_init().
	 */
	if (restart_existing_mounts)
		restart();

	/*
	 * Mount the top-level auto-mountpoints
	 */
	nmount = mount_exported();

	/*
	 * Now safe to tell parent that we are up and running
	 */
	if (ppid)
		kill(ppid, SIGQUIT);

	if (nmount == 0) {
		plog(XLOG_FATAL, "No work to do - quitting");
		amd_state = Done;
		return 0;
	}

#ifdef DEBUG
	Debug(D_AMQ) {
#endif /* DEBUG */
	/*
	 * Register with amq
	 */
	unregister_amq();

	if (!svc_register(amqp, AMQ_PROGRAM, AMQ_VERSION, amq_program_57, IPPROTO_UDP)) {
		plog(XLOG_FATAL, "unable to register (AMQ_PROGRAM, AMQ_VERSION, udp)");
		return 3;
	}
#ifdef DEBUG
	}
#endif /* DEBUG */

	/*
	 * Start timeout_mp rolling
	 */
	reschedule_timeout_mp();

	/*
	 * Start the server
	 */
	if (run_rpc() != Done) {
		plog(XLOG_FATAL, "run_rpc failed");
		amd_state = Done;
	}

	return 0;
}
@


1.19
log
@Pass times as int64_t and eliminate the (long disabled) mount request.
ABI change, so roll the RPC protocol version; how about 57 for OpenBSD 5.7?
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.18 2014/10/26 03:03:34 guenther Exp $
d162 1
a162 1
	if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
@


1.18
log
@Update to the modern RPC style with different names for server and client
    stubs (they have different prototypes, after all).
Fill in missing prototypes.
Use void* arguments on closure-style callbacks, with local variables of
    the expected type.
Keep deleting unnecessary casts.
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.17 2014/10/20 02:33:42 guenther Exp $
d445 1
a445 1
	if (!svc_register(amqp, AMQ_PROGRAM, AMQ_VERSION, amq_program_1, IPPROTO_UDP)) {
@


1.17
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.16 2013/04/17 15:55:44 deraadt Exp $
a55 3
extern void nfs_program_2();
extern void amq_program_1();

d154 1
a154 1
rpc_pending_now()
@


1.16
log
@first few large time_t changes; more might be required -- still digging.
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.15 2004/10/21 20:57:08 millert Exp $
a208 1
#ifdef RPC_4
a231 6
#else
		fd_set readfds;
		FD_ZERO(&readfds);
		readfds.fds_bits[0] = svc_fds;
		FD_SET(fwd_sock, &readfds);
#endif /* RPC_4 */
a301 1
#ifdef RPC_4
a306 3
#else
				svc_getreq(readfds.fds_bits[0]);
#endif /* RPC_4 */
@


1.15
log
@Backout poll changes; the first mount gets an error for some reason.
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.14 2004/10/04 15:19:04 millert Exp $
d267 1
a267 1
			dlog("Select waits for %ds", tvv.tv_sec);
@


1.14
log
@Use poll(2) and svc_getreq_poll(2).  Tested by matthieu@@, ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.13 2003/06/02 23:36:51 millert Exp $
d44 2
a45 2
extern jmp_buf poll_intr;
extern int poll_intr_valid;
d64 1
d102 2
a103 2
do_poll(sigset_t *mask, sigset_t *omask, struct pollfd *pfd, int nfds,
    int timeout)
d106 1
a106 1
	int nready;
d108 2
a109 2
	if ((sig = setjmp(poll_intr))) {
		poll_intr_valid = 0;
d118 1
a118 1
		nready = -1;
d121 1
a121 1
		poll_intr_valid = 1;
d135 3
a137 1
		nready = poll(pfd, nfds, timeout ? timeout * 1000 : INFTIM);
d149 1
a149 1
	return nready;
d159 23
a181 6
	struct pollfd pfd[1];

	pfd[0].fd = fwd_sock;
	pfd[0].events = POLLIN;

	return (poll(pfd, 1, 0) == 1);
d206 2
a207 2
		struct pollfd *pfd;
		int nready, timeout;
d209 30
a238 5

		pfd = xmalloc(sizeof(*pfd) * (svc_max_pollfd + 1));
		memcpy(&pfd[1], svc_pollfd, sizeof(*pfd) * svc_max_pollfd);
		pfd[0].fd = fwd_sock;
		pfd[0].events = POLLIN;
d253 1
a253 1
			timeout = softclock();
d255 1
a255 1
			timeout = next_softclock - now;
d257 1
d266 2
a267 2
		if (timeout)
			dlog("Poll waits for %ds", timeout);
d269 1
a269 1
			dlog("Poll waits for Godot");
d272 1
a272 1
		nready = do_poll(&mask, &omask, pfd, svc_max_pollfd + 1, timeout);
d274 2
a275 1
		switch (nready) {
d279 1
a279 1
				dlog("poll interrupted");
d283 1
a283 1
			perror("poll");
d288 1
a288 1
			/*dlog("poll returned 0");*/
d296 3
a298 4
			if (pfd[0].revents & (POLLIN|POLLHUP)) {
				pfd[0].fd = -1;
				pfd[0].events = pfd[0].revents = 0;
				--nready;
d304 1
a304 1
			if (nready) {
d309 9
a317 1
				svc_getreq_poll(pfd + 1, nready);
d321 1
a321 1
		free(pfd);
d408 12
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: nfs_start.c,v 1.12 2002/09/10 05:43:47 deraadt Exp $
d44 2
a45 2
extern jmp_buf select_intr;
extern int select_intr_valid;
a63 1
int max_fds = -1;
d101 2
a102 2
do_select(sigset_t *mask, sigset_t *omask, int fds, fd_set *fdp,
    struct timeval *tvp)
d105 1
a105 1
	int nsel;
d107 2
a108 2
	if ((sig = setjmp(select_intr))) {
		select_intr_valid = 0;
d117 1
a117 1
		nsel = -1;
d120 1
a120 1
		select_intr_valid = 1;
d134 1
a134 3
		nsel = select(fds, fdp, NULL, NULL,
		    tvp->tv_sec ? tvp : (struct timeval *) 0);

d146 1
a146 1
	return nsel;
d156 6
a161 23
	struct timeval tvv;
	int nsel;
	fd_set *fdsp;
	int fdsn;

	fdsn = howmany(max_fds+1, NFDBITS) * sizeof(fd_mask);
	if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
		return(0);
	memset(fdsp, 0, fdsn);
	FD_SET(fwd_sock, fdsp);

	tvv.tv_sec = tvv.tv_usec = 0;
	nsel = select(max_fds+1, fdsp, NULL, NULL, &tvv);
	if (nsel < 1) {
		free(fdsp);
		return(0);
	}
	if (FD_ISSET(fwd_sock, fdsp)) {
		free(fdsp);
		return(1);
	}
	free(fdsp);
	return(0);
d186 2
a187 2
		struct timeval tvv;
		int nsel;
d189 5
a193 30
#ifdef RPC_4
#ifdef __OpenBSD__
		extern int __svc_fdsetsize;
		extern fd_set *__svc_fdset;
		fd_set *fdsp;
		int fdsn = __svc_fdsetsize;
		int bytes;

		if (fwd_sock > fdsn)
			fdsn = fwd_sock;
		bytes = howmany(fdsn, NFDBITS) * sizeof(fd_mask);

		fdsp = malloc(bytes);
		memset(fdsp, 0, bytes);
		memcpy(fdsp, __svc_fdset, bytes);
		FD_SET(fwd_sock, fdsp);
#else
		fd_set *fdsp;
		int fdsn = FDSETSIZE;
		bytes = howmany(fdsn, NFDBITS) * sizeof(fd_mask);
		fdsp = malloc(bytes);
		memcpy(fdsp, &svc_fdset, bytes);
		FD_SET(fwd_sock, fdsp);
#endif
#else
		fd_set readfds;
		FD_ZERO(&readfds);
		readfds.fds_bits[0] = svc_fds;
		FD_SET(fwd_sock, &readfds);
#endif /* RPC_4 */
d208 1
a208 1
			tvv.tv_sec = softclock();
d210 1
a210 1
			tvv.tv_sec = next_softclock - now;
a211 1
		tvv.tv_usec = 0;
d220 2
a221 2
		if (tvv.tv_sec)
			dlog("Select waits for %ds", tvv.tv_sec);
d223 1
a223 1
			dlog("Select waits for Godot");
d226 1
a226 1
		nsel = do_select(&mask, &omask, fdsn + 1, fdsp, &tvv);
d228 1
a228 2

		switch (nsel) {
d232 1
a232 1
				dlog("select interrupted");
d236 1
a236 1
			perror("select");
d241 1
a241 1
			/*dlog("select returned 0");*/
d249 4
a252 3
			if (FD_ISSET(fwd_sock, fdsp)) {
				FD_CLR(fwd_sock, fdsp);
				--nsel;
d258 1
a258 1
			if (nsel) {
d263 1
a263 9
#ifdef RPC_4
#ifdef __OpenBSD__
				svc_getreqset2(fdsp, fdsn);
#else
				svc_getreqset(fdsp);
#endif
#else
				svc_getreq(readfds.fds_bits[0]);
#endif /* RPC_4 */
d267 1
a267 1
		free(fdsp);
a353 12

	/*
	 * One or other of so, fwd_sock
	 * must be the highest fd on
	 * which to select.
	 */
	if (so > max_fds)
		max_fds = so;
	if (so2 > max_fds)
		max_fds = so2;
	if (fwd_sock > max_fds)
		max_fds = fwd_sock;
@


1.12
log
@create a 127.0.0.1: socket to match the *: socket upon which amq requests
are serviced, then only respond to amq requests on that particular socket.
we may extend this later to improve nfs protocol handling....
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: nfs_start.c,v 1.11 2002/08/05 07:24:26 pvalchev Exp $
@


1.11
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.10 2002/08/03 08:29:31 pvalchev Exp $
d47 1
d64 2
a65 1
SVCXPRT *nfsxprt;
a164 1
#ifdef FD_SET
a172 6
#else
	int *fdsp;
	int readfds = (1 << fwd_sock);
	fdsp = (int *)malloc(sizeof readfds);
	memcpy(fdsp, &readfds, sizeof readfds);
#endif /* FD_SET */
a179 1
#ifdef FD_SET
a183 6
#else
	if (readfds & (1 << fwd_sock)) {
		free(fdsp);
		return(1);
	}
#endif
a237 1
#ifdef FD_SET
a241 3
#else
		int readfds = svc_fds | (1 << fwd_sock);
#endif /* FD_SET */
a299 1
#ifdef FD_SET
a306 9
#else
			if (readfds & (1 << fwd_sock)) {
				readfds &= ~(1 << fwd_sock);
				--nsel;
				do {
					fwd_reply();
				} while (rpc_pending_now() > 0);
			}
#endif
a319 1
#ifdef FD_SET
a320 3
#else
				svc_getreq(readfds);
#endif /* FD_SET */
d358 6
a363 3
	int so = socket(AF_INET, SOCK_DGRAM, 0);
	SVCXPRT *amqp;
	int nmount;
d371 27
a397 1
			(amqp = svcudp_create(so)) == NULL) {
d420 2
@


1.10
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.9 2002/07/18 02:03:00 deraadt Exp $
d73 1
a73 1
checkup(P_void)
d201 1
a201 1
run_rpc(P_void)
d377 1
a377 1
unregister_amq(P_void)
@


1.9
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.8 2002/07/18 00:50:23 pvalchev Exp $
d72 2
a73 1
static void checkup(P_void)
d103 3
a105 6
static int do_select(mask, omask, fds, fdp, tvp)
sigset_t *mask;
sigset_t *omask;
int fds;
fd_set *fdp;
struct timeval *tvp;
d109 1
d158 2
a159 1
static int rpc_pending_now()
d200 2
a201 1
static serv_state run_rpc(P_void)
d366 2
a367 1
static int bindnfs_port(int so)
d376 2
a377 1
void unregister_amq(P_void)
d385 2
a386 1
int mount_automounter(pid_t ppid)
@


1.8
log
@ANSIfy; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.7 2002/05/26 02:49:50 deraadt Exp $
d318 1
a318 1
				--nsel;	
d326 1
a326 1
				--nsel;	
d393 1
a393 1
	if ((nfsxprt = svcudp_create(so)) == NULL || 
@


1.7
log
@pid_cleanup, inspired by work by jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.6 2001/09/05 23:24:21 millert Exp $
d56 1
a56 1
extern SVCXPRT *svcudp2_create P((int));
d74 2
a75 3

static int max_fd = 0;
static char *max_mem = 0;
d78 1
a78 1
	extern caddr_t sbrk P((int));
d365 1
a365 2
static int bindnfs_port(so)
int so;
d382 1
a382 2
int mount_automounter(ppid)
pid_t ppid;
@


1.6
log
@Call do_select() with sigset_t *, not a sigset_t.
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.5 2001/09/04 23:35:59 millert Exp $
d385 1
a385 1
int ppid;
@


1.5
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.4 2001/03/02 06:22:04 deraadt Exp $
d292 1
a292 1
		nsel = do_select(mask, omask, fdsn + 1, fdsp, &tvv);
@


1.4
log
@KNF
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.3 1997/12/17 20:37:37 deraadt Exp $
a67 2
#define	MASKED_SIGS	(sigmask(SIGINT)|sigmask(SIGTERM)|sigmask(SIGCHLD)|sigmask(SIGHUP))

d103 3
a105 2
static int do_select(smask, fds, fdp, tvp)
int smask;
d135 1
a135 1
		(void) sigsetmask(smask);
d144 1
a144 1
	(void) sigblock(MASKED_SIGS);
d203 8
a210 1
	int smask = sigblock(MASKED_SIGS);
d292 1
a292 1
		nsel = do_select(smask, fdsn + 1, fdsp, &tvv);
d358 1
a358 1
	(void) sigsetmask(smask);
@


1.3
log
@do not overflow fd_set. i _pray_ I got this right...
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.2 1997/01/31 14:42:01 graichen Exp $
d44 2
a45 1
#include <sys/signal.h>
d108 1
a108 1
int *fdp;
d113 1
a113 1
	if (sig = setjmp(select_intr)) {
d140 2
a141 2
		nsel = select(fds, fdp, (int *) 0, (int *) 0,
				tvp->tv_sec ? tvp : (struct timeval *) 0);
d182 1
a182 1
	nsel = select(max_fds+1, fdsp, (int *) 0, (int *) 0, &tvv);
@


1.2
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.1.1.1 1995/10/18 08:47:11 deraadt Exp $
d165 2
a166 1
	fd_set readfds;
d168 5
a172 2
	FD_ZERO(&readfds);
	FD_SET(fwd_sock, &readfds);
d174 1
d176 2
d181 3
a183 2
	nsel = select(max_fds+1, &readfds, (int *) 0, (int *) 0, &tvv);
	if (nsel < 1)
d185 1
d187 2
a188 1
	if (FD_ISSET(fwd_sock, &readfds))
d190 1
d192 2
a193 1
	if (readfds & (1 << fwd_sock))
d195 1
d197 1
a202 1
	int dtbsz = max_fds + 1;
d219 23
a241 3
		fd_set readfds;
		readfds = svc_fdset;
		FD_SET(fwd_sock, &readfds);
d285 1
a285 1
		nsel = do_select(smask, dtbsz, &readfds, &tvv);
d310 7
a316 2
			if (FD_ISSET(fwd_sock, &readfds)) {
				FD_CLR(fwd_sock, &readfds);
a319 1
#endif
d325 1
d333 5
a337 1
				svc_getreqset(&readfds);
d348 1
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: nfs_start.c,v 1.3 1994/06/13 20:47:46 mycroft Exp $
d95 4
a98 4
		dlog("%#x bytes of memory allocated; total is %#x (%d pages)",
			next_mem - max_mem,
			next_mem,
			((int)next_mem+getpagesize()-1)/getpagesize());
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
