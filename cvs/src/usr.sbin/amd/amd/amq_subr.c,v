head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.10
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.12
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.26
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.24
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.22
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.20
	OPENBSD_5_0:1.12.0.18
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.16
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.14
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.10
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.12
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.01.21.09.50.25;	author guenther;	state Exp;
branches;
next	1.17;
commitid	cGf82el9lnnFrg2e;

1.17
date	2015.01.21.08.24.41;	author guenther;	state Exp;
branches;
next	1.16;
commitid	fwWHCHQH9uktPmic;

1.16
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.15;
commitid	RUbgWdu1CNTVPIOS;

1.15
date	2014.10.26.03.03.34;	author guenther;	state Exp;
branches;
next	1.14;
commitid	RhupU2WFUkfzry1g;

1.14
date	2014.10.26.02.43.50;	author guenther;	state Exp;
branches;
next	1.13;
commitid	QMh02q5MFiw3np67;

1.13
date	2013.12.03.02.14.57;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.20.04.00.32;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.18.15.51.02;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.10.15.33.13;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	99.08.26.14.57.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.02.16.00.04.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.01.31.14.41.57;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Pass times as int64_t and eliminate the (long disabled) mount request.
ABI change, so roll the RPC protocol version; how about 57 for OpenBSD 5.7?
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)amq_subr.c	8.1 (Berkeley) 6/6/93
 *	$Id: amq_subr.c,v 1.17 2015/01/21 08:24:41 guenther Exp $
 */

/*
 * Auxilliary routines for amq tool
 */

#include "am.h"
#include "amq.h"
#include <ctype.h>

bool_t	xdr_amq_mount_info_list(XDR *, amq_mount_info_list *);

void *
amqproc_null_57_svc(void *argp, struct svc_req *rqstp)
{
	static char res;

	return &res;
}

/*
 * Return a sub-tree of mounts
 */
amq_mount_tree_p *
amqproc_mnttree_57_svc(amq_string *argp, struct svc_req *rqstp)
{
	static am_node *mp;

	mp = find_ap(*argp);
	return (amq_mount_tree_p *) &mp;
}

/*
 * Unmount a single node
 */
void *
amqproc_umnt_57_svc(amq_string *argp, struct svc_req *rqstp)
{
	static char res;

	am_node *mp = find_ap(*argp);
	if (mp)
		forcibly_timeout_mp(mp);

	return &res;
}

/*
 * Return global statistics
 */
amq_mount_stats *
amqproc_stats_57_svc(void *argp, struct svc_req *rqstp)
{
	return (amq_mount_stats *) &amd_stats;
}

/*
 * Return the entire tree of mount nodes
 */
amq_mount_tree_list *
amqproc_export_57_svc(void *argp, struct svc_req *rqstp)
{
	static amq_mount_tree_list aml;

	aml.amq_mount_tree_list_val = (amq_mount_tree_p *) &exported_ap[0];
	aml.amq_mount_tree_list_len = 1;	/* XXX */

	return &aml;
}

int *
amqproc_setopt_57_svc(amq_setopt *argp, struct svc_req *rqstp)
{
	static int rc;

	rc = 0;
	switch (argp->as_opt) {
	case AMOPT_DEBUG:
#ifdef DEBUG
		if (debug_option(argp->as_str))
			rc = EINVAL;
#else
		rc = EINVAL;
#endif /* DEBUG */
		break;

	case AMOPT_LOGFILE:
#ifdef not_yet
		if (switch_to_logfile(argp->as_str))
			rc = EINVAL;
#else
		rc = EACCES;
#endif /* not_yet */
		break;

	case AMOPT_XLOG:
		if (switch_option(argp->as_str))
			rc = EINVAL;
		break;

	case AMOPT_FLUSHMAPC:
		if (amd_state == Run) {
			plog(XLOG_INFO, "amq says flush cache");
			do_mapc_reload = 0;
			flush_nfs_fhandle_cache((fserver *) 0);
			flush_srvr_nfs_cache();
		}
		break;
	}
	return &rc;
}

amq_mount_info_list *
amqproc_getmntfs_57_svc(void *argp, struct svc_req *rqstp)
{
	extern qelem mfhead;
	return (amq_mount_info_list *) &mfhead;	/* XXX */
}

amq_string *
amqproc_getvers_57_svc(void *argp, struct svc_req *rqstp)
{
	static amq_string res;

	res = "amd 1.1.1.1 of 1995/10/18 08:47:13 bsd44";
	return &res;
}

/*
 * XDR routines.
 */
bool_t
xdr_amq_string(XDR *xdrs, amq_string *objp)
{
	if (!xdr_string(xdrs, objp, AMQ_STRLEN)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_amq_setopt(XDR *xdrs, amq_setopt *objp)
{
	if (!xdr_enum(xdrs, (enum_t *)&objp->as_opt)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->as_str, AMQ_STRLEN)) {
		return (FALSE);
	}
	return (TRUE);
}

/*
 * More XDR routines  - Should be used for OUTPUT ONLY.
 */
static bool_t
xdr_amq_mount_tree_node(XDR *xdrs, amq_mount_tree *objp)
{
	am_node *mp = (am_node *) objp;
	long long mounttime = mp->am_stats.s_mtime;

	if (!xdr_amq_string(xdrs, &mp->am_mnt->mf_info)) {
		return (FALSE);
	}
	if (!xdr_amq_string(xdrs, &mp->am_path)) {
		return (FALSE);
	}
	if (!xdr_amq_string(xdrs, mp->am_link ? &mp->am_link : &mp->am_mnt->mf_mount)) {
		return (FALSE);
	}
	if (!xdr_amq_string(xdrs, &mp->am_mnt->mf_ops->fs_type)) {
		return (FALSE);
	}
	if (!xdr_int64_t(xdrs, &mounttime)) {
		return (FALSE);
	}
	if (!xdr_u_short(xdrs, &mp->am_stats.s_uid)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &mp->am_stats.s_getattr)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &mp->am_stats.s_lookup)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &mp->am_stats.s_readdir)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &mp->am_stats.s_readlink)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &mp->am_stats.s_statfs)) {
		return (FALSE);
	}
	return (TRUE);
}

static bool_t
xdr_amq_mount_subtree(XDR *xdrs, amq_mount_tree *objp)
{
	am_node *mp = (am_node *) objp;

	if (!xdr_amq_mount_tree_node(xdrs, objp)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&mp->am_osib, sizeof(amq_mount_tree), xdr_amq_mount_subtree)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&mp->am_child, sizeof(amq_mount_tree), xdr_amq_mount_subtree)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_amq_mount_tree(XDR *xdrs, amq_mount_tree *objp)
{
	am_node *mp = (am_node *) objp;
	am_node *mnil = 0;

	if (!xdr_amq_mount_tree_node(xdrs, objp)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&mnil, sizeof(amq_mount_tree), xdr_amq_mount_subtree)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&mp->am_child, sizeof(amq_mount_tree), xdr_amq_mount_subtree)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_amq_mount_tree_p(XDR *xdrs, amq_mount_tree_p *objp)
{
	if (!xdr_pointer(xdrs, (char **)objp, sizeof(amq_mount_tree), xdr_amq_mount_tree)) {
		return (FALSE);
	}
	return (TRUE);
}


bool_t
xdr_amq_mount_stats(XDR *xdrs, amq_mount_stats *objp)
{
	if (!xdr_int(xdrs, &objp->as_drops)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->as_stale)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->as_mok)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->as_merr)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->as_uerr)) {
		return (FALSE);
	}
	return (TRUE);
}


bool_t
xdr_amq_mount_tree_list(XDR *xdrs, amq_mount_tree_list *objp)
{
	 if (!xdr_array(xdrs, (char **)&objp->amq_mount_tree_list_val, (u_int *)&objp->amq_mount_tree_list_len, ~0, sizeof(amq_mount_tree_p), xdr_amq_mount_tree_p)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_amq_mount_info_list(XDR *xdrs, amq_mount_info_list *arg)
{
	qelem *qhead = (qelem *)arg;

	/*
	 * Compute length of list
	 */
	mntfs *mf;
	u_int len = 0;

	for (mf = LAST(mntfs, qhead); mf != HEAD(mntfs, qhead); mf = PREV(mntfs, mf)) {
		if (!(mf->mf_ops->fs_flags & FS_AMQINFO))
			continue;
		len++;
	}
	xdr_u_int(xdrs, &len);

	/*
	 * Send individual data items
	 */
	for (mf = LAST(mntfs, qhead); mf != HEAD(mntfs, qhead); mf = PREV(mntfs, mf)) {
		int up;
		if (!(mf->mf_ops->fs_flags & FS_AMQINFO))
			continue;

		if (!xdr_amq_string(xdrs, &mf->mf_ops->fs_type)) {
			return (FALSE);
		}
		if (!xdr_amq_string(xdrs, &mf->mf_mount)) {
			return (FALSE);
		}
		if (!xdr_amq_string(xdrs, &mf->mf_info)) {
			return (FALSE);
		}
		if (!xdr_amq_string(xdrs, &mf->mf_server->fs_host)) {
			return (FALSE);
		}
		if (!xdr_int(xdrs, &mf->mf_error)) {
			return (FALSE);
		}
		if (!xdr_int(xdrs, &mf->mf_refc)) {
			return (FALSE);
		}
		if (mf->mf_server->fs_flags & FSF_ERROR)
			up = 0;
		else switch (mf->mf_server->fs_flags & (FSF_DOWN|FSF_VALID)) {
		case FSF_DOWN|FSF_VALID: up = 0; break;
		case FSF_VALID: up = 1; break;
		default: up = -1; break;
		}
		if (!xdr_int(xdrs, &up)) {
			return (FALSE);
		}
	}
	return (TRUE);
}
@


1.17
log
@Regenerate the amq RPC stubs with a -current rpcgen, with some
post-processing of the server stub to match previous local changes.
This corrects the type handling of mt_mounttime, so "amq /mountpoint"
doesn't segv trying to treat a time_t as a pointer.
With the file (re)generation fixed, we can more easily update the
protocol to support 64bit time_t...
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.16 2014/10/26 03:28:41 guenther Exp $
d49 1
a49 1
amqproc_null_1_svc(void *argp, struct svc_req *rqstp)
d60 1
a60 1
amqproc_mnttree_1_svc(amq_string *argp, struct svc_req *rqstp)
d72 1
a72 1
amqproc_umnt_1_svc(amq_string *argp, struct svc_req *rqstp)
d87 1
a87 1
amqproc_stats_1_svc(void *argp, struct svc_req *rqstp)
d96 1
a96 1
amqproc_export_1_svc(void *argp, struct svc_req *rqstp)
d107 1
a107 1
amqproc_setopt_1_svc(amq_setopt *argp, struct svc_req *rqstp)
d149 1
a149 1
amqproc_getmntfs_1_svc(void *argp, struct svc_req *rqstp)
a154 84
#if 0
/*
 * amd does not allocate a separate socket to distinguish local
 * connects so this "security" check is useless.
 */
static int ok_security(rqstp)
struct svc_req *rqstp;
{
	struct sockaddr_in *sin;

	sin = svc_getcaller(rqstp->rq_xprt);
	if (ntohs(sin->sin_port) >= 1024 ||
	    !(sin->sin_addr.s_addr == htonl(0x7f000001) ||
	      sin->sin_addr.s_addr == myipaddr.s_addr)) {
		char dq[20];
		plog(XLOG_INFO, "AMQ request from %s.%d DENIED",
		     inet_dquad(dq, sizeof(dq), sin->sin_addr.s_addr),
		     ntohs(sin->sin_port));
		return(0);
	}
	return(1);
}

int *
amqproc_mount_1_svc(amq_string *argp, struct svc_req *rqstp)
{
	static int rc;
	char *s = *argp;
	char *cp;

	plog(XLOG_INFO, "amq requested mount of %s", s);

	/*
	 * Minimalist (read useless) security check.
	 */
	if (!ok_security(rqstp)) {
		rc = EACCES;
		return &rc;
	}

	/*
	 * Find end of key
	 */
	for (cp = (char *) s;
	    *cp&&(!isascii((unsigned char)*cp) || !isspace((unsigned char)*cp));
	    cp++)
		;

	if (!*cp) {
		plog(XLOG_INFO, "amqproc_mount: Invalid arguments");
		rc = EINVAL;
		return &rc;
	}
	*cp++ = '\0';

	/*
	 * Find start of value
	 */
	while (isascii((unsigned char)*cp) && isspace((unsigned char)*cp))
		cp++;

	root_newmap(s, cp, (char *) 0);
	rc = mount_auto_node(s, root_node);
	if (rc < 0)
		return 0;
	return &rc;
}
#else
/*
 * Disable "amq -M" functionality since it is inherently insecure.
 */
int *
amqproc_mount_1_svc(amq_string *argp, struct svc_req *rqstp)
{
	static int rc;
	char *s = *argp;

	plog(XLOG_ERROR, "amq requested mount of %s, but code is disabled", s);

	rc = EACCES;
	return &rc;
}
#endif

d156 1
a156 1
amqproc_getvers_1_svc(void *argp, struct svc_req *rqstp)
d195 1
d209 1
a209 2
	/* XXX really a time_t, but need to transmit a 32-bit integer */
	if (!xdr_int(xdrs, (int *)&mp->am_stats.s_mtime)) {
@


1.16
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.15 2014/10/26 03:03:34 guenther Exp $
d46 1
a46 1
bool_t	xdr_amq_mount_info_qelem(XDR *, qelem *);
d60 1
a60 1
amqproc_mnttree_1_svc(void *argp, struct svc_req *rqstp)
d64 1
a64 1
	mp = find_ap(*(char **) argp);
d72 1
a72 1
amqproc_umnt_1_svc(void *argp, struct svc_req *rqstp)
d76 1
a76 1
	am_node *mp = find_ap(*(char **) argp);
d107 1
a107 1
amqproc_setopt_1_svc(void *argp, struct svc_req *rqstp)
a110 2
	amq_setopt *opt = (amq_setopt *) argp;

d112 1
a112 1
	switch (opt->as_opt) {
d115 1
a115 1
		if (debug_option(opt->as_str))
d124 1
a124 1
		if (switch_to_logfile(opt->as_str))
d132 1
a132 1
		if (switch_option(opt->as_str))
d179 1
a179 3
amqproc_mount_1_svc(argp, rqstp)
void *argp;
struct svc_req *rqstp;
d182 1
a182 1
	char *s = *(amq_string *) argp;
d227 1
a227 1
amqproc_mount_1_svc(void *argp, struct svc_req *rqstp)
d230 1
a230 1
	char *s = *(amq_string *) argp;
d394 1
a394 1
xdr_amq_mount_info_qelem(XDR *xdrs, qelem *qhead)
d396 2
@


1.15
log
@Update to the modern RPC style with different names for server and client
    stubs (they have different prototypes, after all).
Fill in missing prototypes.
Use void* arguments on closure-style callbacks, with local variables of
    the expected type.
Keep deleting unnecessary casts.
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.14 2014/10/26 02:43:50 guenther Exp $
d53 1
a53 1
	return (void *)&res;
d80 1
a80 1
	return (void *)&res;
d221 1
a221 1
	rc = mount_auto_node(s, (void *)root_node);
@


1.14
log
@Lint is dead
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.13 2013/12/03 02:14:57 deraadt Exp $
d46 2
d49 1
a49 1
amqproc_null_1(void *argp, struct svc_req *rqstp)
d60 1
a60 1
amqproc_mnttree_1(void *argp, struct svc_req *rqstp)
d72 1
a72 1
amqproc_umnt_1(void *argp, struct svc_req *rqstp)
d87 1
a87 1
amqproc_stats_1(void *argp, struct svc_req *rqstp)
d96 1
a96 1
amqproc_export_1(void *argp, struct svc_req *rqstp)
d107 1
a107 1
amqproc_setopt_1(void *argp, struct svc_req *rqstp)
d151 1
a151 1
amqproc_getmntfs_1(void *argp, struct svc_req *rqstp)
d181 1
a181 1
amqproc_mount_1(argp, rqstp)
d231 1
a231 1
amqproc_mount_1(void *argp, struct svc_req *rqstp)
d244 1
a244 1
amqproc_getvers_1(void *argp, struct svc_req *rqstp)
d279 1
a279 1
bool_t
d321 1
a321 1
bool_t
@


1.13
log
@ctype cleanups
ok okan
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.12 2007/03/20 04:00:32 tedu Exp $
a45 1
/*ARGSUSED*/
a56 1
/*ARGSUSED*/
a68 1
/*ARGSUSED*/
a83 1
/*ARGSUSED*/
a92 1
/*ARGSUSED*/
@


1.12
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.11 2005/02/18 15:51:02 henning Exp $
d205 3
a207 1
	for (cp = (char *) s; *cp&&(!isascii(*cp)||!isspace(*cp)); cp++)
d220 1
a220 1
	while (isascii(*cp) && isspace(*cp))
@


1.11
log
@do not embed compile date and such in the binaries so they don't change
all time, ok millert@@
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.10 2003/06/02 23:36:51 millert Exp $
d218 1
a218 1
	while (*cp && isascii(*cp) && isspace(*cp))
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: amq_subr.c,v 1.9 2002/08/05 07:24:26 pvalchev Exp $
d249 1
a249 1
	res = version;
@


1.9
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: amq_subr.c,v 1.8 2002/08/03 08:29:31 pvalchev Exp $
@


1.8
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.7 2002/07/18 02:03:00 deraadt Exp $
d51 2
a52 2
voidp
amqproc_null_1(voidp argp, struct svc_req *rqstp)
d56 1
a56 1
	return (voidp) &res;
d64 1
a64 1
amqproc_mnttree_1(voidp argp, struct svc_req *rqstp)
d76 2
a77 2
voidp
amqproc_umnt_1(voidp argp, struct svc_req *rqstp)
d85 1
a85 1
	return (voidp) &res;
d93 1
a93 1
amqproc_stats_1(voidp argp, struct svc_req *rqstp)
d103 1
a103 1
amqproc_export_1(voidp argp, struct svc_req *rqstp)
d114 1
a114 1
amqproc_setopt_1(voidp argp, struct svc_req *rqstp)
d158 1
a158 1
amqproc_getmntfs_1(voidp argp, struct svc_req *rqstp)
d189 1
a189 1
voidp argp;
d226 1
a226 1
	rc = mount_auto_node(s, (voidp) root_node);
d236 1
a236 1
amqproc_mount_1(voidp argp, struct svc_req *rqstp)
d249 1
a249 1
amqproc_getvers_1(voidp argp, struct svc_req *rqstp)
@


1.7
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.6 2002/06/11 05:29:54 itojun Exp $
d52 1
a52 3
amqproc_null_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d64 1
a64 3
amqproc_mnttree_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d67 1
d77 1
a77 3
amqproc_umnt_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d80 1
d93 1
a93 3
amqproc_stats_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d103 1
a103 3
amqproc_export_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d114 1
a114 3
amqproc_setopt_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d158 1
a158 3
amqproc_getmntfs_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d160 1
a160 1
extern qelem mfhead;
d236 1
a236 3
amqproc_mount_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d249 1
a249 3
amqproc_getvers_1(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d251 2
a252 1
static amq_string res;
d261 1
a261 3
xdr_amq_string(xdrs, objp)
	XDR *xdrs;
	amq_string *objp;
d270 1
a270 3
xdr_amq_setopt(xdrs, objp)
	XDR *xdrs;
	amq_setopt *objp;
d285 1
a285 3
xdr_amq_mount_tree_node(xdrs, objp)
	XDR *xdrs;
	amq_mount_tree *objp;
d327 1
a327 3
xdr_amq_mount_subtree(xdrs, objp)
	XDR *xdrs;
	amq_mount_tree *objp;
d344 1
a344 3
xdr_amq_mount_tree(xdrs, objp)
	XDR *xdrs;
	amq_mount_tree *objp;
d362 1
a362 3
xdr_amq_mount_tree_p(xdrs, objp)
	XDR *xdrs;
	amq_mount_tree_p *objp;
d372 1
a372 3
xdr_amq_mount_stats(xdrs, objp)
	XDR *xdrs;
	amq_mount_stats *objp;
d394 1
a394 3
xdr_amq_mount_tree_list(xdrs, objp)
	XDR *xdrs;
	amq_mount_tree_list *objp;
d403 1
a403 3
xdr_amq_mount_info_qelem(xdrs, qhead)
	XDR *xdrs;
	qelem *qhead;
d410 1
@


1.6
log
@use snprintf.
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.5 2000/11/10 15:33:13 provos Exp $
d254 1
a254 1
  
d256 1
a256 1
   
@


1.5
log
@seperate -> separate, okay aaron@@
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.4 1999/08/26 14:57:19 millert Exp $
d192 1
a192 1
		     inet_dquad(dq, sin->sin_addr.s_addr),
@


1.4
log
@Make it clear that "amq -M" mounts are disabled and kill some dead code.
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.3 1997/02/16 00:04:25 deraadt Exp $
d178 1
a178 1
 * amd does not allocate a seperate socket to distinguish local
@


1.3
log
@give up on amd -M until amd gets proper localhost detection
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.2 1997/01/31 14:41:57 graichen Exp $
d176 5
d209 1
a209 1
#if 0
d211 1
a211 1
	 * Minimalist security check.
a216 10
#else
	/*
	 * Better security check. amd does not allocate a seperate
	 * socket to distinguish local connects; so the above security
	 * check is useless
	 */
	rc = EACCES;
	return &rc;
#endif

d243 18
@


1.2
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.1.1.1 1995/10/18 08:47:10 deraadt Exp $
d204 1
d212 10
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: amq_subr.c,v 1.3 1994/06/13 20:47:03 mycroft Exp $
d298 2
a299 1
	if (!xdr_long(xdrs, &mp->am_stats.s_mtime)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
