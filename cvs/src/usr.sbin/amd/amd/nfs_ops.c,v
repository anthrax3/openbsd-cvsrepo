head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.14
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.12
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.28
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.24
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.22
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.20
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.18
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.16
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.14
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.12
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.10
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.25;
commitid	RUbgWdu1CNTVPIOS;

1.25
date	2014.10.26.03.08.21;	author guenther;	state Exp;
branches;
next	1.24;
commitid	WHJr6yXZrF36RX5I;

1.24
date	2014.10.26.03.03.34;	author guenther;	state Exp;
branches;
next	1.23;
commitid	RhupU2WFUkfzry1g;

1.23
date	2014.10.26.01.22.34;	author guenther;	state Exp;
branches;
next	1.22;
commitid	9PVNXrh0iWHa31SJ;

1.22
date	2014.10.26.01.16.48;	author guenther;	state Exp;
branches;
next	1.21;
commitid	Qcgfc5DGBBARLngk;

1.21
date	2014.10.20.06.55.59;	author guenther;	state Exp;
branches;
next	1.20;
commitid	1xnKI9ul35JBjA4W;

1.20
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.19;
commitid	bZbpWDoZDVt0RPe1;

1.19
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.07.23.45.45;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.18.00.50.23;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.10.21.07.14;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.26.02.49.50;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.13.22.32.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.21.29.31;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.02.06.22.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.31.14.42.00;	author graichen;	state Exp;
branches;
next	1.5;

1.5
date	96.05.24.09.22.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.03.14.13.06;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.03.25.15.54.48;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.17.02.55.19;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@/*	$OpenBSD: nfs_ops.c,v 1.25 2014/10/26 03:08:21 guenther Exp $	*/

/*-
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "am.h"
#include <sys/stat.h>

#ifdef HAS_NFS

#define NFS
#define NFSCLIENT

#include "mount.h"

/*
 * Network file system
 */

/*
 * Convert from nfsstat to UN*X error code
 */
#define unx_error(e)	((int)(e))

/*
 * The NFS layer maintains a cache of file handles.
 * This is *fundamental* to the implementation and
 * also allows quick remounting when a filesystem
 * is accessed soon after timing out.
 *
 * The NFS server layer knows to flush this cache
 * when a server goes down so avoiding stale handles.
 *
 * Each cache entry keeps a hard reference to
 * the corresponding server.  This ensures that
 * the server keepalive information is maintained.
 *
 * The copy of the sockaddr_in here is taken so
 * that the port can be twiddled to talk to mountd
 * instead of portmap or the NFS server as used
 * elsewhere.
 * The port# is flushed if a server goes down.
 * The IP address is never flushed - we assume
 * that the address of a mounted machine never
 * changes.  If it does, then you have other
 * problems...
 */
typedef struct fh_cache fh_cache;
struct fh_cache {
	qelem	fh_q;			/* List header */
	void	*fh_wchan;		/* Wait channel */
	int	fh_error;		/* Valid data? */
	int	fh_id;			/* Unique id */
	int	fh_cid;			/* Callout id */
	fhstatus fh_handle;		/* Handle on filesystem */
	struct sockaddr_in fh_sin;	/* Address of mountd */
	fserver *fh_fs;			/* Server holding filesystem */
	char	*fh_path;		/* Filesystem on host */
};

/*
 * FH_TTL is the time a file handle will remain in the cache since
 * last being used.  If the file handle becomes invalid, then it
 * will be flushed anyway.
 */
#define	FH_TTL		(5 * 60)		/* five minutes */
#define	FH_TTL_ERROR	(30)			/* 30 seconds */

static int fh_id = 0;
#define	FHID_ALLOC()	(++fh_id)
extern qelem fh_head;
qelem fh_head = { &fh_head, &fh_head };

static int call_mountd(fh_cache*, unsigned long, fwd_fun, void *);

AUTH *nfs_auth;

static fh_cache *
find_nfs_fhandle_cache(void *idv, int done)
{
	fh_cache *fp, *fp2 = 0;
	/* XXX EVIL XXX */
	int id = (int) ((long)idv);

	ITER(fp, fh_cache, &fh_head) {
		if (fp->fh_id == id) {
			fp2 = fp;
			break;
		}
	}

#ifdef DEBUG
	if (fp2) {
		dlog("fh cache gives fp %#x, fs %s", fp2, fp2->fh_path);
	} else {
		dlog("fh cache search failed");
	}
#endif /* DEBUG */

	if (fp2 && !done) {
		fp2->fh_error = ETIMEDOUT;
		return 0;
	}

	return fp2;
}

/*
 * Called when a filehandle appears
 */
static void
got_nfs_fh(void *pkt, int len, struct sockaddr_in *sa,
    struct sockaddr_in *ia, void *idv, int done)
{
	fh_cache *fp = find_nfs_fhandle_cache(idv, done);
	if (fp) {
		fp->fh_handle.fhs_vers = MOUNTVERS;
		fp->fh_error = pickup_rpc_reply(pkt, len, &fp->fh_handle,
		    xdr_fhstatus);
		if (!fp->fh_error) {
#ifdef DEBUG
			dlog("got filehandle for %s:%s", fp->fh_fs->fs_host, fp->fh_path);
#endif /* DEBUG */
			/*
			 * Wakeup anything sleeping on this filehandle
			 */
			if (fp->fh_wchan) {
#ifdef DEBUG
				dlog("Calling wakeup on %#x", fp->fh_wchan);
#endif /* DEBUG */
				wakeup(fp->fh_wchan);
			}
		}
	}
}

void
flush_nfs_fhandle_cache(fserver *fs)
{
	fh_cache *fp;
	ITER(fp, fh_cache, &fh_head) {
		if (fp->fh_fs == fs || fs == 0) {
			fp->fh_sin.sin_port = (u_short) 0;
			fp->fh_error = -1;
		}
	}
}

static void
discard_fh(void *arg)
{
	fh_cache *fp = arg;

	rem_que(&fp->fh_q);
#ifdef DEBUG
	dlog("Discarding filehandle for %s:%s", fp->fh_fs->fs_host, fp->fh_path);
#endif /* DEBUG */
	free_srvr(fp->fh_fs);
	free(fp->fh_path);
	free(fp);
}

/*
 * Determine the file handle for a node
 */
static int
prime_nfs_fhandle_cache(char *path, fserver *fs, fhstatus *fhbuf, void *wchan)
{
	fh_cache *fp, *fp_save = 0;
	int error;
	int reuse_id = FALSE;

#ifdef DEBUG
	dlog("Searching cache for %s:%s", fs->fs_host, path);
#endif /* DEBUG */

	/*
	 * First search the cache
	 */
	ITER(fp, fh_cache, &fh_head) {
		if (fs == fp->fh_fs && strcmp(path, fp->fh_path) == 0) {
			switch (fp->fh_error) {
			case 0:
				error = fp->fh_error = unx_error(fp->fh_handle.fhs_stat);
				if (error == 0) {
					if (fhbuf)
						bcopy(&fp->fh_handle, fhbuf,
							sizeof(fp->fh_handle));
					if (fp->fh_cid)
						untimeout(fp->fh_cid);
					fp->fh_cid = timeout(FH_TTL,
					    discard_fh, fp);
				} else if (error == EACCES) {
					/*
					 * Now decode the file handle return code.
					 */
					plog(XLOG_INFO, "Filehandle denied for \"%s:%s\"",
						fs->fs_host, path);
				} else {
					errno = error;	/* XXX */
					plog(XLOG_INFO, "Filehandle error for \"%s:%s\": %m",
						fs->fs_host, path);
				}

				/*
				 * The error was returned from the remote mount daemon.
				 * Policy: this error will be cached for now...
				 */
				return error;

			case -1:
				/*
				 * Still thinking about it, but we can re-use.
				 */
				fp_save = fp;
				reuse_id = TRUE;
				break;

			default:
				/*
				 * Return the error.
				 * Policy: make sure we recompute if required again
				 * in case this was caused by a network failure.
				 * This can thrash mountd's though...  If you find
				 * your mountd going slowly then:
				 * 1.  Add a fork() loop to main.
				 * 2.  Remove the call to innetgr() and don't use
				 *     netgroups, especially if you don't use YP.
				 */
				error = fp->fh_error;
				fp->fh_error = -1;
				return error;
			}
			break;
		}
	}

	/*
	 * Not in cache
	 */
	if (fp_save) {
		fp = fp_save;
		/*
		 * Re-use existing slot
		 */
		untimeout(fp->fh_cid);
		free_srvr(fp->fh_fs);
		free(fp->fh_path);
	} else {
		fp = ALLOC(fh_cache);
		bzero(fp, sizeof(*fp));
		ins_que(&fp->fh_q, &fh_head);
	}
	if (!reuse_id)
		fp->fh_id = FHID_ALLOC();
	fp->fh_wchan = wchan;
	fp->fh_error = -1;
	fp->fh_cid = timeout(FH_TTL, discard_fh, fp);

	/*
	 * If the address has changed then don't try to re-use the
	 * port information
	 */
	if (fp->fh_sin.sin_addr.s_addr != fs->fs_ip->sin_addr.s_addr) {
		fp->fh_sin = *fs->fs_ip;
		fp->fh_sin.sin_port = 0;
	}
	fp->fh_fs = dup_srvr(fs);
	fp->fh_path = strdup(path);

	error = call_mountd(fp, MOUNTPROC_MNT, got_nfs_fh, wchan);
	if (error) {
		/*
		 * Local error - cache for a short period
		 * just to prevent thrashing.
		 */
		untimeout(fp->fh_cid);
		fp->fh_cid = timeout(error < 0 ? 2 * ALLOWED_MOUNT_TIME : FH_TTL_ERROR,
						discard_fh, fp);
		fp->fh_error = error;
	} else {
		error = fp->fh_error;
	}
	return error;
}

int
make_nfs_auth(void)
{
	/*
	 * From: Chris Metcalf <metcalf@@masala.lcs.mit.edu>
	 * Use hostd, not just hostname.  Note that uids
	 * and gids and the gidlist are type *int* and not the
	 * system uid_t and gid_t types.
	 */
	static int group_wheel = 0;
	nfs_auth = authunix_create(hostd, 0, 0, 1, &group_wheel);
	if (!nfs_auth)
		return ENOBUFS;
	return 0;
}

static int
call_mountd(fh_cache *fp, u_long proc, fwd_fun f, void *wchan)
{
	struct rpc_msg mnt_msg;
	int len;
	char iobuf[8192];
	int error;

	if (!nfs_auth) {
		error = make_nfs_auth();
		if (error)
			return error;
	}

	if (fp->fh_sin.sin_port == 0) {
		u_short port;
		error = nfs_srvr_port(fp->fh_fs, &port, wchan);
		if (error)
			return error;
		fp->fh_sin.sin_port = port;
	}

	rpc_msg_init(&mnt_msg, MOUNTPROG, MOUNTVERS, (unsigned long) 0);
	len = make_rpc_packet(iobuf, sizeof(iobuf), proc,
			&mnt_msg, &fp->fh_path, xdr_nfspath,  nfs_auth);

	/*
	 * XXX EVIL!  We cast fh_id to a pointer, then back to an int
	 * XXX later.
	 */
	if (len > 0) {
		error = fwd_packet(MK_RPC_XID(RPC_XID_MOUNTD, fp->fh_id),
			iobuf, len, &fp->fh_sin, &fp->fh_sin,
			(void *)((long)fp->fh_id), f);
	} else {
		error = -len;
	}
/*
 * It may be the case that we're sending to the wrong MOUNTD port.  This
 * occurs if mountd is restarted on the server after the port has been
 * looked up and stored in the filehandle cache somewhere.  The correct
 * solution, if we're going to cache port numbers is to catch the ICMP
 * port unreachable reply from the server and cause the portmap request
 * to be redone.  The quick solution here is to invalidate the MOUNTD
 * port.
 */
      fp->fh_sin.sin_port = 0;

	return error;
}

/*-------------------------------------------------------------------------*/

/*
 * NFS needs the local filesystem, remote filesystem
 * remote hostname.
 * Local filesystem defaults to remote and vice-versa.
 */
static char *
nfs_match(am_opts *fo)
{
	char *xmtab;
	if (fo->opt_fs && !fo->opt_rfs)
		fo->opt_rfs = fo->opt_fs;
	if (!fo->opt_rfs) {
		plog(XLOG_USER, "nfs: no remote filesystem specified");
		return FALSE;
	}
	if (!fo->opt_rhost) {
		plog(XLOG_USER, "nfs: no remote host specified");
		return FALSE;
	}
	/*
	 * Determine magic cookie to put in mtab
	 */
	xmtab = xmalloc(strlen(fo->opt_rhost) + strlen(fo->opt_rfs) + 2);
	snprintf(xmtab, strlen(fo->opt_rhost) + strlen(fo->opt_rfs) + 2,
		"%s:%s", fo->opt_rhost, fo->opt_rfs);
#ifdef DEBUG
	dlog("NFS: mounting remote server \"%s\", remote fs \"%s\" on \"%s\"",
		fo->opt_rhost, fo->opt_rfs, fo->opt_fs);
#endif /* DEBUG */

	return xmtab;
}

/*
 * Initialise am structure for nfs
 */
static int
nfs_init(mntfs *mf)
{
	if (!mf->mf_private) {
		int error;
		fhstatus fhs;

		char *colon = strchr(mf->mf_info, ':');
		if (colon == 0)
			return ENOENT;

		error = prime_nfs_fhandle_cache(colon+1, mf->mf_server,
		    &fhs, mf);
		if (!error) {
			mf->mf_private = ALLOC(fhstatus);
			mf->mf_prfree = free;
			bcopy(&fhs, mf->mf_private, sizeof(fhs));
		}
		return error;
	}

	return 0;
}

int
mount_nfs_fh(fhstatus *fhp, char *dir, char *fs_name, char *opts,
    mntfs *mf)
{
	struct nfs_args nfs_args;
	struct mntent mnt;
	int retry;
	char *colon;
	/*char *path;*/
	char host[MAXHOSTNAMELEN + MAXPATHLEN + 2];
	fserver *fs = mf->mf_server;
	int flags;
	char *xopts;
	int error;
#ifdef notdef
	unsigned short port;
#endif /* notdef */

	const char *type = MOUNT_NFS;

	bzero(&nfs_args, sizeof(nfs_args));	/* Paranoid */

	/*
	 * Extract host name to give to kernel
	 */
	if (!(colon = strchr(fs_name, ':')))
		return ENOENT;
	strlcpy(host, fs_name, sizeof(host));
	/*path = colon + 1;*/

	if (mf->mf_remopts && *mf->mf_remopts && !islocalnet(fs->fs_ip->sin_addr.s_addr))
		xopts = strdup(mf->mf_remopts);
	else
		xopts = strdup(opts);

	bzero(&nfs_args, sizeof(nfs_args));

	mnt.mnt_dir = dir;
	mnt.mnt_fsname = fs_name;
	mnt.mnt_type = "nfs";
	mnt.mnt_opts = xopts;
	mnt.mnt_freq = 0;
	mnt.mnt_passno = 0;

	retry = hasmntval(&mnt, "retry");
	if (retry <= 0)
		retry = 1;	/* XXX */

/*again:*/

	/*
	 * set mount args
	 */
	nfs_args.fh = (void *)fhp->fhs_fhandle;
	nfs_args.fhsize = fhp->fhs_size;
	nfs_args.version = NFS_ARGSVERSION;

	nfs_args.hostname = host;
#ifdef HOSTNAMESZ
	/*
	 * Most kernels have a name length restriction.
	 */
	if (strlen(host) >= HOSTNAMESZ)
		strlcpy(host + HOSTNAMESZ - 3, "..", sizeof host - HOSTNAMESZ + 3);
#endif /* HOSTNAMESZ */

	if ((nfs_args.rsize = hasmntval(&mnt, "rsize")))
		nfs_args.flags |= NFSMNT_RSIZE;

#ifdef NFSMNT_READDIRSIZE
	if ((nfs_args.readdirsize = hasmntval(&mnt, "readdirsize"))) {
		nfs_args.flags |= NFSMNT_READDIRSIZE;
	} else if (nfs_args.rsize) {
		nfs_args.readdirsize = nfs_args.rsize;
		nfs_args.flags |= NFSMNT_READDIRSIZE;
	}
#endif

	if ((nfs_args.wsize = hasmntval(&mnt, "wsize")))
		nfs_args.flags |= NFSMNT_WSIZE;

	if ((nfs_args.timeo = hasmntval(&mnt, "timeo")))
		nfs_args.flags |= NFSMNT_TIMEO;

	if ((nfs_args.retrans = hasmntval(&mnt, "retrans")))
		nfs_args.flags |= NFSMNT_RETRANS;

#ifdef NFSMNT_BIODS
	if ((nfs_args.biods = hasmntval(&mnt, "biods")))
		nfs_args.flags |= NFSMNT_BIODS;

#endif /* NFSMNT_BIODS */

#ifdef NFSMNT_MAXGRPS
	if ((nfs_args.maxgrouplist = hasmntval(&mnt, "maxgroups")))
		nfs_args.flags |= NFSMNT_MAXGRPS;
#endif /* NFSMNT_MAXGRPS */

#ifdef NFSMNT_READAHEAD
	if ((nfs_args.readahead = hasmntval(&mnt, "readahead")))
		nfs_args.flags |= NFSMNT_READAHEAD;
#endif /* NFSMNT_READAHEAD */

#ifdef notdef
/*
 * This isn't supported by the ping algorithm yet.
 * In any case, it is all done in nfs_init().
 */
	if ((port = hasmntval(&mnt, "port")))
		sin.sin_port = htons(port);
	else
		sin.sin_port = htons(NFS_PORT);	/* XXX should use portmapper */
#endif /* notdef */

	if (hasmntopt(&mnt, "soft") != NULL)
		nfs_args.flags |= NFSMNT_SOFT;

#ifdef NFSMNT_SPONGY
	if (hasmntopt(&mnt, "spongy") != NULL) {
		nfs_args.flags |= NFSMNT_SPONGY;
		if (nfs_args.flags & NFSMNT_SOFT) {
			plog(XLOG_USER, "Mount opts soft and spongy are incompatible - soft ignored");
			nfs_args.flags &= ~NFSMNT_SOFT;
		}
	}
#endif /* MNTOPT_SPONGY */

	if (hasmntopt(&mnt, "intr") != NULL)
		nfs_args.flags |= NFSMNT_INT;

#ifdef MNTOPT_NODEVS
	if (hasmntopt(&mnt, MNTOPT_NODEVS) != NULL)
		nfs_args.flags |= NFSMNT_NODEVS;
#endif /* MNTOPT_NODEVS */


	if (hasmntopt(&mnt, "noconn") != NULL)
		nfs_args.flags |= NFSMNT_NOCONN;

	if (hasmntopt(&mnt, "resvport") != NULL)
		nfs_args.flags |= NFSMNT_RESVPORT;

#ifdef NFSMNT_PGTHRESH
	if ((nfs_args.pg_thresh = hasmntval(&mnt, "pgthresh")))
		nfs_args.flags |= NFSMNT_PGTHRESH;
#endif /* NFSMNT_PGTHRESH */

	nfs_args.addr = (struct sockaddr *)fs->fs_ip;
	nfs_args.addrlen = sizeof(*fs->fs_ip);
	nfs_args.sotype = SOCK_DGRAM;
	nfs_args.proto = 0;

	flags = compute_mount_flags(&mnt);

#ifdef NFSMNT_NOCTO
	if (hasmntopt(&mnt, "nocto") != NULL)
		nfs_args.flags |= NFSMNT_NOCTO;
#endif /* NFSMNT_NOCTO */

	if (hasmntopt(&mnt, "tcp") != NULL)
		nfs_args.sotype = SOCK_STREAM;



	error = mount_fs(&mnt, flags, (caddr_t) &nfs_args, retry, type);
	free(xopts);
	return error;
}

static int
mount_nfs(char *dir, char *fs_name, char *opts, mntfs *mf)
{
#ifdef notdef
	int error;
	fhstatus fhs;
	char *colon;

	if (!(colon = strchr(fs_name, ':')))
		return ENOENT;

#ifdef DEBUG
	dlog("locating fhandle for %s", fs_name);
#endif /* DEBUG */
	error = prime_nfs_fhandle_cache(colon+1, mf->mf_server, &fhs, NULL);

	if (error)
		return error;

	return mount_nfs_fh(&fhs, dir, fs_name, opts, mf);
#endif
	if (!mf->mf_private) {
		plog(XLOG_ERROR, "Missing filehandle for %s", fs_name);
		return EINVAL;
	}

	return mount_nfs_fh((fhstatus *) mf->mf_private, dir, fs_name, opts, mf);
}

static int
nfs_fmount(mntfs *mf)
{
	int error;

	error = mount_nfs(mf->mf_mount, mf->mf_info, mf->mf_mopts, mf);

#ifdef DEBUG
	if (error) {
		errno = error;
		dlog("mount_nfs: %m");
	}
#endif /* DEBUG */
	return error;
}

static int
nfs_fumount(mntfs *mf)
{
	return (umount_fs(mf->mf_mount));
}

static void
nfs_umounted(am_node *mp)
{

#ifdef KICK_KERNEL
	/* This should go into the mainline code, not in nfs_ops... */

	/*
	 * Run lstat over the underlying directory in
	 * case this was a direct mount.  This will
	 * get the kernel back in sync with reality.
	 */
	if (mp->am_parent && mp->am_parent->am_path &&
	    STREQ(mp->am_parent->am_mnt->mf_ops->fs_type, "direct")) {
		struct stat stb;
		pid_t pid;
		if ((pid = background()) == 0) {
			if (lstat(mp->am_parent->am_path, &stb) < 0) {
				plog(XLOG_ERROR, "lstat(%s) after unmount: %m", mp->am_parent->am_path);
#ifdef DEBUG
			} else {
				dlog("hack lstat(%s): ok", mp->am_parent->am_path);
#endif /* DEBUG */
			}
			_exit(0);
		}
	}
#endif /* KICK_KERNEL */
}

/*
 * Network file system
 */
am_ops nfs_ops = {
	"nfs",
	nfs_match,
	nfs_init,
	auto_fmount,
	nfs_fmount,
	auto_fumount,
	nfs_fumount,
	efs_lookuppn,
	efs_readdir,
	0, /* nfs_readlink */
	0, /* nfs_mounted */
	nfs_umounted,
	find_nfs_srvr,
	FS_MKMNT|FS_BACKGROUND|FS_AMQINFO
};

#endif /* HAS_NFS */
@


1.25
log
@Delete casts to void* of the argument to free(): only needed when lying
about constness and none of these were
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.24 2014/10/26 03:03:34 guenther Exp $	*/
d149 2
a150 1
		fp->fh_error = pickup_rpc_reply(pkt, len, (void *)&fp->fh_handle, xdr_fhstatus);
d218 1
a218 1
						bcopy((void *)&fp->fh_handle, (void *)fhbuf,
d282 1
a282 1
		bzero((void *)fp, sizeof(*fp));
d358 1
a358 1
			&mnt_msg, (void *)&fp->fh_path, xdr_nfspath,  nfs_auth);
d366 2
a367 1
			(void *)iobuf, len, &fp->fh_sin, &fp->fh_sin, (void *)((long)fp->fh_id), f);
d467 1
a467 1
	bzero((void *)&nfs_args, sizeof(nfs_args));	/* Paranoid */
d482 1
a482 1
	bzero((void *)&nfs_args, sizeof(nfs_args));
d630 1
a630 1
	error = prime_nfs_fhandle_cache(colon+1, mf->mf_server, &fhs, (void *)0);
@


1.24
log
@Update to the modern RPC style with different names for server and client
    stubs (they have different prototypes, after all).
Fill in missing prototypes.
Use void* arguments on closure-style callbacks, with local variables of
    the expected type.
Keep deleting unnecessary casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.23 2014/10/26 01:22:34 guenther Exp $	*/
d189 2
a190 2
	free((void *)fp->fh_path);
	free((void *)fp);
@


1.23
log
@Consistently use the extra parens in  'if ((var = hasmntval(...)))'  to
suppress compiler warnings.

Noted with gcc -Wall, then prodded by brad@@ and clang
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.22 2014/10/26 01:16:48 guenther Exp $	*/
d180 1
a180 1
discard_fh(fh_cache *fp)
d182 2
d221 2
a222 1
					fp->fh_cid = timeout(FH_TTL, discard_fh, (void *)fp);
d288 1
a288 1
	fp->fh_cid = timeout(FH_TTL, discard_fh, (void *)fp);
d309 1
a309 1
						discard_fh, (void *)fp);
d432 2
a433 1
		error = prime_nfs_fhandle_cache(colon+1, mf->mf_server, &fhs, (void *)mf);
d435 3
a437 3
			mf->mf_private = (void *)ALLOC(fhstatus);
			mf->mf_prfree = (void (*)()) free;
			bcopy((void *)&fhs, mf->mf_private, sizeof(fhs));
@


1.22
log
@Replace xrealloc() with xreallocarray().  Break-out the 'log and die'
function as xmallocfailure() and use that in the locations where
reallocarray's checks alone aren't sufficient.

ok doug@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.21 2014/10/20 06:55:59 guenther Exp $	*/
d529 1
a529 1
	if (nfs_args.biods = hasmntval(&mnt, "biods"))
d540 1
a540 1
	if (nfs_args.readahead = hasmntval(&mnt, "readahead"))
d549 1
a549 1
	if (port = hasmntval(&mnt, "port"))
d584 1
a584 1
	if (nfs_args.pg_thresh = hasmntval(&mnt, "pgthresh"))
@


1.21
log
@Change MTAB_TYPE_UFS from "ufs" to "ffs", fixing mount-restarting for them.
Perform one level of expansion on the various "portability" macros from os-*.h
Delete support for Hesiod and the pre-4.4 versions of the NFS API
Delete the no-op unlock_mntlist()
unifdef -UFASCIST_DF_COMMAND -UMOUNT_HELPER_SOURCE
Move the struct mntent and MNTMAXSTR definitions into include/am.h
Move the commented-out -DHAS_NDBM_MAPS into amd/Makefile
Expand OS_REP to "bsd44".
With config/* empty, delete them.

"lot of stuff...but I know your process on this" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.20 2014/10/20 02:33:42 guenther Exp $	*/
d404 1
a404 1
	xmtab = (char *) xmalloc(strlen(fo->opt_rhost) + strlen(fo->opt_rfs) + 2);
@


1.20
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.19 2009/10/27 23:59:50 deraadt Exp $	*/
d44 1
a44 6
#ifdef NFS_3
typedef nfs_fh fhandle_t;
#endif /* NFS_3 */
#ifdef NFS_HDR
#include NFS_HDR
#endif /* NFS_HDR */
d459 1
a459 1
	MTYPE_TYPE type = MOUNT_TYPE_NFS;
d480 1
a480 1
	mnt.mnt_type = MTAB_TYPE_NFS;
d494 1
a494 2
	NFS_FH_DREF(nfs_args.fh, (NFS_FH_TYPE) fhp->fhs_fhandle);

a498 1
	nfs_args.flags |= NFSMNT_HOSTNAME;
d555 1
a555 1
	if (hasmntopt(&mnt, MNTOPT_SOFT) != NULL)
d568 1
a568 2
#ifdef MNTOPT_INTR
	if (hasmntopt(&mnt, MNTOPT_INTR) != NULL)
a569 1
#endif /* MNTOPT_INTR */
d577 1
a577 2
#ifdef MNTOPT_NOCONN
	if (hasmntopt(&mnt, MNTOPT_NOCONN) != NULL)
a578 1
#endif /* MNTOPT_NOCONN */
d580 1
a580 2
#ifdef MNTOPT_RESVPORT
	if (hasmntopt(&mnt, MNTOPT_RESVPORT) != NULL)
a581 2
#endif /* MNTOPT_RESVPORT */

d588 4
a591 1
	NFS_SA_DREF(nfs_args, fs->fs_ip);
d658 1
a658 5
	int error = UMOUNT_FS(mf->mf_mount);
	if (error)
		return error;

	return 0;
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.18 2003/06/02 23:36:51 millert Exp $	*/
a152 1
#if NFS_PROTOCOL_VERSION >= 3
a153 1
#endif
a321 1
#ifdef HAS_NFS_QUALIFIED_NAMES
a329 3
#else
	nfs_auth = authunix_create_default();
#endif
a472 3
#ifndef NFS_ARGS_NEEDS_PATH
	*colon = '\0';
#endif
a473 3
#ifndef NFS_ARGS_NEEDS_PATH
	*colon = ':';
#endif /* NFS_ARGS_NEEDS_PATH */
a500 1
#if NFS_PROTOCOL_VERSION >= 3
a502 4
#endif
#ifdef ULTRIX_HACK
	nfs_args.optstr = mnt.mnt_opts;
#endif /* ULTRIX_HACK */
a584 4
#ifdef MNTOPT_COMPRESS
	if (hasmntopt(&mnt, MNTOPT_COMPRESS) != NULL)
		nfs_args.flags |= NFSMNT_COMPRESS;
#endif /* MNTOPT_COMPRESS */
a595 8
#ifdef MNTOPT_NQNFS
	if (hasmntopt(&mnt, MNTOPT_NQNFS) != NULL)
		nfs_args.flags |= NFSMNT_NQNFS;
#ifdef NFSMNT_NQLOOKLEASE
	if (hasmntopt(&mnt, "nolooklease") == NULL)
		nfs_args.flags |= NFSMNT_NQLOOKLEASE;
#endif /* NFSMNT_NQLOOKLEASE */
#endif /* MNTOPT_NQNFS */
a610 1
#ifdef HAS_TCP_NFS
a612 1
#endif /* HAS_TCP_NFS */
a614 16
#ifdef ULTRIX_HACK
	/*
	 * Ultrix passes the flags argument as part of the
	 * mount data structure, rather than using the
	 * flags argument to the system call.  This is
	 * confusing...
	 */
	if (!(nfs_args.flags & NFSMNT_PGTHRESH)) {
		nfs_args.pg_thresh = 64; /* 64k - XXX */
		nfs_args.flags |= NFSMNT_PGTHRESH;
	}
	nfs_args.gfs_flags = flags;
	flags &= M_RDONLY;
	if (flags & M_RDONLY)
		nfs_args.flags |= NFSMNT_RONLY;
#endif /* ULTRIX_HACK */
a678 45
#ifdef INFORM_MOUNTD
	/*
	 * Don't bother to inform remote mountd
	 * that we are finished.  Until a full
	 * track of filehandles is maintained
	 * the mountd unmount callback cannot
	 * be done correctly anyway...
	 */

	mntfs *mf = mp->am_mnt;
	fserver *fs;
	char *colon, *path;

	if (mf->mf_error || mf->mf_refc > 1)
		return;

	fs = mf->mf_server;

	/*
	 * Call the mount daemon on the server to
	 * announce that we are not using the fs any more.
	 *
	 * This is *wrong*.  The mountd should be called
	 * when the fhandle is flushed from the cache, and
	 * a reference held to the cached entry while the
	 * fs is mounted...
	 */
	colon = path = strchr(mf->mf_info, ':');
	if (fs && colon) {
		fh_cache f;
#ifdef DEBUG
		dlog("calling mountd for %s", mf->mf_info);
#endif /* DEBUG */
		*path++ = '\0';
		f.fh_path = path;
		f.fh_sin = *fs->fs_ip;
		f.fh_sin.sin_port = (u_short) 0;
		f.fh_fs = fs;
		f.fh_id = 0;
		f.fh_error = 0;
		(void) prime_nfs_fhandle_cache(colon+1, mf->mf_server, (fhstatus *) 0, (void *)mf);
		(void) call_mountd(&f, MOUNTPROC_UMNT, (fwd_fun) 0, (void *)0);
		*colon = ':';
	}
#endif /* INFORM_MOUNTD */
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.17 2003/04/07 23:45:45 tedu Exp $	*/
a35 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)nfs_ops.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.17 2003/04/07 23:45:45 tedu Exp $";
#endif /* not lint */
@


1.17
log
@strcpy -> strlcpy.  some from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.16 2002/08/05 07:24:26 pvalchev Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.16 2002/08/05 07:24:26 pvalchev Exp $";
@


1.16
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.15 2002/08/03 08:29:31 pvalchev Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.15 2002/08/03 08:29:31 pvalchev Exp $";
d537 1
a537 1
		strcpy(host + HOSTNAMESZ - 3, "..");
@


1.15
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.14 2002/07/18 02:03:00 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.14 2002/07/18 02:03:00 deraadt Exp $";
d96 1
a96 1
	voidp	fh_wchan;		/* Wait channel */
d119 1
a119 1
static int call_mountd(fh_cache*, unsigned long, fwd_fun, voidp);
d124 1
a124 1
find_nfs_fhandle_cache(voidp idv, int done)
d157 2
a158 2
got_nfs_fh(voidp pkt, int len, struct sockaddr_in *sa,
    struct sockaddr_in *ia, voidp idv, int done)
d165 1
a165 1
		fp->fh_error = pickup_rpc_reply(pkt, len, (voidp) &fp->fh_handle, xdr_fhstatus);
d203 2
a204 2
	free((voidp) fp->fh_path);
	free((voidp) fp);
d211 1
a211 1
prime_nfs_fhandle_cache(char *path, fserver *fs, fhstatus *fhbuf, voidp wchan)
d231 1
a231 1
						bcopy((voidp) &fp->fh_handle, (voidp) fhbuf,
d235 1
a235 1
					fp->fh_cid = timeout(FH_TTL, discard_fh, (voidp) fp);
d294 1
a294 1
		bzero((voidp) fp, sizeof(*fp));
d301 1
a301 1
	fp->fh_cid = timeout(FH_TTL, discard_fh, (voidp) fp);
d322 1
a322 1
						discard_fh, (voidp) fp);
d351 1
a351 1
call_mountd(fh_cache *fp, u_long proc, fwd_fun f, voidp wchan)
d374 1
a374 1
			&mnt_msg, (voidp) &fp->fh_path, xdr_nfspath,  nfs_auth);
d382 1
a382 1
			(voidp) iobuf, len, &fp->fh_sin, &fp->fh_sin, (voidp) ((long)fp->fh_id), f);
d449 1
a449 1
		error = prime_nfs_fhandle_cache(colon+1, mf->mf_server, &fhs, (voidp) mf);
d451 1
a451 1
			mf->mf_private = (voidp) ALLOC(fhstatus);
d453 1
a453 1
			bcopy((voidp) &fhs, mf->mf_private, sizeof(fhs));
d481 1
a481 1
	bzero((voidp) &nfs_args, sizeof(nfs_args));	/* Paranoid */
d502 1
a502 1
	bzero((voidp) &nfs_args, sizeof(nfs_args));
d691 1
a691 1
	error = prime_nfs_fhandle_cache(colon+1, mf->mf_server, &fhs, (voidp) 0);
d775 2
a776 2
		(void) prime_nfs_fhandle_cache(colon+1, mf->mf_server, (fhstatus *) 0, (voidp) mf);
		(void) call_mountd(&f, MOUNTPROC_UMNT, (fwd_fun) 0, (voidp) 0);
@


1.14
log
@space nits
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.13 2002/07/18 00:50:23 pvalchev Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.13 2002/07/18 00:50:23 pvalchev Exp $";
d123 2
a124 1
static fh_cache *find_nfs_fhandle_cache(voidp idv, int done)
d156 3
a158 2
static void got_nfs_fh(voidp pkt, int len, struct sockaddr_in *sa,
	struct sockaddr_in *ia, voidp idv, int done)
d183 2
a184 1
void flush_nfs_fhandle_cache(fserver *fs)
d195 2
a196 1
static void discard_fh(fh_cache *fp)
d210 2
a211 1
static int prime_nfs_fhandle_cache(char *path, fserver *fs, fhstatus *fhbuf, voidp wchan)
d330 2
a331 1
int make_nfs_auth(void)
d350 2
a351 1
static int call_mountd(fh_cache *fp, u_long proc, fwd_fun f, voidp wchan)
d407 2
a408 1
static char *nfs_match(am_opts *fo)
d438 2
a439 1
static int nfs_init(mntfs *mf)
d461 3
a463 1
int mount_nfs_fh(fhstatus *fhp, char *dir, char *fs_name, char *opts, mntfs *mf)
d677 2
a678 1
static int mount_nfs(char *dir, char *fs_name, char *opts, mntfs *mf)
d706 2
a707 1
static int nfs_fmount(mntfs *mf)
d722 2
a723 1
static int nfs_fumount(mntfs *mf)
d732 2
a733 1
static void nfs_umounted(am_node *mp)
@


1.13
log
@ANSIfy; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.12 2002/06/11 05:29:54 itojun Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.12 2002/06/11 05:29:54 itojun Exp $";
d435 1
a435 1
	
d571 1
a571 1
 	if (port = hasmntval(&mnt, "port"))
@


1.12
log
@use snprintf.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.11 2002/06/10 21:07:14 itojun Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.11 2002/06/10 21:07:14 itojun Exp $";
d119 1
a119 1
static int call_mountd P((fh_cache*, unsigned long, fwd_fun, voidp));
d123 1
a123 4
static fh_cache *find_nfs_fhandle_cache P((voidp idv, int done));
static fh_cache *find_nfs_fhandle_cache(idv, done)
voidp idv;
int done;
d155 2
a156 8
static void got_nfs_fh P((voidp pkt, int len, struct sockaddr_in *sa,
				struct sockaddr_in *ia, voidp idv, int done));
static void got_nfs_fh(pkt, len, sa, ia, idv, done)
voidp pkt;
int len;
struct sockaddr_in *sa, *ia;
voidp idv;
int done;
d181 1
a181 3
void flush_nfs_fhandle_cache P((fserver *fs));
void flush_nfs_fhandle_cache(fs)
fserver *fs;
d192 1
a192 3
static void discard_fh P((fh_cache *fp));
static void discard_fh(fp)
fh_cache *fp;
d206 1
a206 6
static int prime_nfs_fhandle_cache P((char *path, fserver *fs, fhstatus *fhbuf, voidp wchan));
static int prime_nfs_fhandle_cache(path, fs, fhbuf, wchan)
char *path;
fserver *fs;
fhstatus *fhbuf;
voidp wchan;
d325 1
a325 1
int make_nfs_auth P((void))
d344 1
a344 6
static int call_mountd P((fh_cache *fp, u_long proc, fwd_fun f, voidp wchan));
static int call_mountd(fp, proc, f, wchan)
fh_cache *fp;
u_long proc;
fwd_fun f;
voidp wchan;
d400 1
a400 2
static char *nfs_match(fo)
am_opts *fo;
d430 1
a430 2
static int nfs_init(mf)
mntfs *mf;
d452 1
a452 7
int mount_nfs_fh P((fhstatus *fhp, char *dir, char *fs_name, char *opts, mntfs *mf));
int mount_nfs_fh(fhp, dir, fs_name, opts, mf)
fhstatus *fhp;
char *dir;
char *fs_name;
char *opts;
mntfs *mf;
d666 1
a666 5
static int mount_nfs(dir, fs_name, opts, mf)
char *dir;
char *fs_name;
char *opts;
mntfs *mf;
d694 1
a694 2
static int nfs_fmount(mf)
mntfs *mf;
d709 1
a709 2
static int nfs_fumount(mf)
mntfs *mf;
d718 1
a718 2
static void nfs_umounted(mp)
am_node *mp;
@


1.11
log
@strlcpy, strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.10 2002/05/26 02:49:50 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.10 2002/05/26 02:49:50 deraadt Exp $";
d441 2
a442 1
	sprintf(xmtab, "%s:%s", fo->opt_rhost, fo->opt_rfs);
@


1.10
log
@pid_cleanup, inspired by work by jason@@ackley.net
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.9 2002/02/13 22:32:33 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.9 2002/02/13 22:32:33 deraadt Exp $";
d510 1
a510 1
	strncpy(host, fs_name, sizeof(host));
@


1.9
log
@be a bit more pendrantic about spelling than the brit was
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.8 2001/06/25 21:29:31 niklas Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.8 2001/06/25 21:29:31 niklas Exp $";
d814 1
a814 1
		int pid;
@


1.8
log
@support readahead option
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.7 2001/03/02 06:22:04 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.7 2001/03/02 06:22:04 deraadt Exp $";
d393 1
a393 1
	 * XXX EVIL!  We case fh_id to a pointer, then back to an int
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.6 1997/01/31 14:42:00 graichen Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.6 1997/01/31 14:42:00 graichen Exp $";
d590 5
@


1.6
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.5 1996/05/24 09:22:06 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.5 1996/05/24 09:22:06 deraadt Exp $";
d559 1
a559 1
	if (nfs_args.rsize = hasmntval(&mnt, "rsize"))
d563 1
a563 1
	if (nfs_args.readdirsize = hasmntval(&mnt, "readdirsize")) {
d571 1
a571 1
	if (nfs_args.wsize = hasmntval(&mnt, "wsize"))
d574 1
a574 1
	if (nfs_args.timeo = hasmntval(&mnt, "timeo"))
d577 1
a577 1
	if (nfs_args.retrans = hasmntval(&mnt, "retrans"))
d587 1
a587 1
	if (nfs_args.maxgrouplist = hasmntval(&mnt, "maxgroups"))
@


1.5
log
@netbsd pr#2395
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_ops.c,v 1.3 1996/03/25 15:54:48 niklas Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: nfs_ops.c,v 1.3 1996/03/25 15:54:48 niklas Exp $";
d129 2
a130 1
	int id = (int) idv;
d392 4
d398 1
a398 1
			(voidp) iobuf, len, &fp->fh_sin, &fp->fh_sin, (voidp) fp->fh_id, f);
@


1.4
log
@fixed compilation errors--but NQNFS may not work with new NFS code
@
text
@d167 1
d169 1
a169 1
	fp->fh_handle.fhs_vers = MOUNTVERS;
a170 1
	if (fp) {
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD$";
d638 1
d641 1
@


1.2
log
@added nqnfs option to nfs mounts
@
text
@d1 2
d43 1
a43 1
static char *rcsid = "$Id: nfs_ops.c,v 1.1.1.1 1995/10/18 08:47:11 deraadt Exp $";
a58 1
#include <sys/mount.h>
d100 1
a100 1
	struct fhstatus fh_handle;	/* Handle on filesystem */
d167 3
d218 1
a218 1
static int prime_nfs_fhandle_cache P((char *path, fserver *fs, struct fhstatus *fhbuf, voidp wchan));
d222 1
a222 1
struct fhstatus *fhbuf;
d240 1
a240 1
				error = fp->fh_error = unx_error(fp->fh_handle.fhs_status);
d453 1
a453 1
		struct fhstatus fhs;
d471 1
a471 1
int mount_nfs_fh P((struct fhstatus *fhp, char *dir, char *fs_name, char *opts, mntfs *mf));
d473 1
a473 1
struct fhstatus *fhp;
d534 1
a534 1
	NFS_FH_DREF(nfs_args.fh, (NFS_FH_TYPE) fhp->fhstatus_u.fhs_fhandle);
d536 4
d557 9
d692 1
a692 1
	struct fhstatus fhs;
d713 1
a713 1
	return mount_nfs_fh((struct fhstatus *) mf->mf_private, dir, fs_name, opts, mf);
d785 1
a785 1
		(void) prime_nfs_fhandle_cache(colon+1, mf->mf_server, (struct fhstatus *) 0, (voidp) mf);
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
static char *rcsid = "$Id: nfs_ops.c,v 1.4 1995/03/22 17:15:08 mycroft Exp $";
d617 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
