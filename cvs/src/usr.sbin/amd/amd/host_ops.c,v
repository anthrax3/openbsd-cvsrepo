head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.6
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.13.0.48
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.46
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.42
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.40
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.38
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.36
	OPENBSD_5_0:1.13.0.34
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.32
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.30
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.26
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.12.05.21.15.01;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	dGqLLvlPAG0kHsOT;

1.18
date	2014.10.26.03.00.35;	author guenther;	state Exp;
branches;
next	1.17;
commitid	QAQ5yvIvMPom00DJ;

1.17
date	2014.10.26.01.38.02;	author guenther;	state Exp;
branches;
next	1.16;
commitid	xqK74Ng7qRvcG53D;

1.16
date	2014.10.26.01.16.48;	author guenther;	state Exp;
branches;
next	1.15;
commitid	Qcgfc5DGBBARLngk;

1.15
date	2014.10.20.06.55.59;	author guenther;	state Exp;
branches;
next	1.14;
commitid	1xnKI9ul35JBjA4W;

1.14
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.13;
commitid	bZbpWDoZDVt0RPe1;

1.13
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.07.23.45.45;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.04.00.43.17;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.03.21.49.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.21.07.14;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.02.06.22.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.31.14.41.58;	author graichen;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.54.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove a bunch of NULL-checks before free().
@
text
@/*	$OpenBSD: host_ops.c,v 1.18 2014/10/26 03:00:35 guenther Exp $	*/

/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)host_ops.c	8.1 (Berkeley) 6/6/93
 */

#include "am.h"

#ifdef HAS_HOST

#include "mount.h"
#include <sys/stat.h>

/*
 * NFS host file system.
 * Mounts all exported filesystems from a given host.
 * This has now degenerated into a mess but will not
 * be rewritten.  Amd 6 will support the abstractions
 * needed to make this work correctly.
 */

/*
 * Define HOST_RPC_UDP to use dgram instead of stream RPC.
 * Datagrams are generally much faster.
 */
/*#define	HOST_RPC_UDP*/

/*
 * Define HOST_MKDIRS to make Amd automatically try
 * to create the mount points.
 */
#define HOST_MKDIRS

/*
 * Determine the mount point
 */
#define MAKE_MNTPT(mntpt, ex, mf) { \
			if (strcmp((ex)->ex_dir, "/") == 0) \
				strlcpy((mntpt), (mf)->mf_mount, sizeof((mntpt))); \
			else \
				snprintf((mntpt), sizeof(mntpt), "%s%s", (mf)->mf_mount, (ex)->ex_dir); \
}

/*
 * Execute needs the same as NFS plus a helper command
 */
static char *
host_match(am_opts *fo)
{
#ifdef HOST_EXEC
	if (!host_helper) {
		plog(XLOG_USER, "No host helper command given");
		return FALSE;
	}
#endif /* HOST_EXEC */

	/*
	 * Make sure rfs is specified to keep nfs_match happy...
	 */
	if (!fo->opt_rfs)
		fo->opt_rfs = "/";

	return (*nfs_ops.fs_match)(fo);
}

static int
host_init(mntfs *mf)
{
	if (strchr(mf->mf_info, ':') == 0)
		return ENOENT;
	return 0;
}

/*
 * Two implementations:
 * HOST_EXEC gets you the external version.  The program specified with
 * the -h option is called.  The external program is not published...
 * roll your own.
 *
 * Otherwise you get the native version.  Faster but makes the program
 * bigger.
 */

#ifndef HOST_EXEC

static bool_t
xdr_pri_free(xdrproc_t xdr_args, void *args_ptr)
{
	XDR xdr;

	xdr.x_op = XDR_FREE;
	return ((*xdr_args)(&xdr, args_ptr));
}

static int
do_mount(fhstatus *fhp, char *dir, char *fs_name, char *opts, mntfs *mf)
{
	struct stat stb;

#ifdef DEBUG
	dlog("host: mounting fs %s on %s", fs_name, dir);
#endif /* DEBUG */
#ifdef HOST_MKDIRS
	(void) mkdirs(dir, 0555);
#endif /* HOST_MKDIRS */
	if (stat(dir, &stb) < 0 || (stb.st_mode & S_IFMT) != S_IFDIR) {
		plog(XLOG_ERROR, "No mount point for %s - skipping", dir);
		return ENOENT;
	}

	return mount_nfs_fh(fhp, dir, fs_name, opts, mf);
}

static int
sortfun(const void *arg1, const void *arg2)
{
	const exports *a = arg1, *b = arg2;
	return strcmp((*a)->ex_dir, (*b)->ex_dir);
}

/*
 * Get filehandle
 */
static int
fetch_fhandle(CLIENT *client, char *dir, fhstatus *fhp)
{
	struct timeval tv;
	enum clnt_stat clnt_stat;

	/*
	 * Pick a number, any number...
	 */
	tv.tv_sec = 20;
	tv.tv_usec = 0;

#ifdef DEBUG
	dlog("Fetching fhandle for %s", dir);
#endif /* DEBUG */
	/*
	 * Call the mount daemon on the remote host to
	 * get the filehandle.
	 */
	fhp->fhs_vers = MOUNTVERS;
	clnt_stat = clnt_call(client, MOUNTPROC_MNT, xdr_dirpath, &dir, xdr_fhstatus, fhp, tv);
	if (clnt_stat != RPC_SUCCESS) {
		char *msg = clnt_sperrno(clnt_stat);
		plog(XLOG_ERROR, "mountd rpc failed: %s", msg);
		return EIO;
	}
	/*
	 * Check status of filehandle
	 */
	if (fhp->fhs_stat) {
#ifdef DEBUG
		errno = fhp->fhs_stat;
		dlog("fhandle fetch failed: %m");
#endif /* DEBUG */
		return fhp->fhs_stat;
	}
	return 0;
}

/*
 * Scan mount table to see if something already mounted
 */
static int
already_mounted(mntlist *mlist, char *dir)
{
	mntlist *ml;

	for (ml = mlist; ml; ml = ml->mnext)
		if (strcmp(ml->mnt->mnt_dir, dir) == 0)
			return 1;
	return 0;
}

/*
 * Mount the export tree from a host
 */
static int
host_fmount(mntfs *mf)
{
	struct timeval tv2;
	CLIENT *client;
	enum clnt_stat clnt_stat;
	int n_export;
	int j, k;
	exports exlist = 0, ex;
	exports *ep = 0;
	fhstatus *fp = 0;
	char *host = mf->mf_server->fs_host;
	int error = 0;
	struct sockaddr_in sin;
	int sock = RPC_ANYSOCK;
	int ok = FALSE;
	mntlist *mlist;
	char fs_name[MAXPATHLEN], *rfs_dir;
	char mntpt[MAXPATHLEN];
	struct timeval tv;
	tv.tv_sec = 10; tv.tv_usec = 0;

	/*
	 * Read the mount list
	 */
	mlist = read_mtab(mf->mf_mount);

	/*
	 * Take a copy of the server address
	 */
	sin = *mf->mf_server->fs_ip;

	/*
	 * Zero out the port - make sure we recompute
	 */
	sin.sin_port = 0;
	/*
	 * Make a client end-point.
	 * Try TCP first
	 */
	if ((client = clnttcp_create(&sin, MOUNTPROG, MOUNTVERS, &sock, 0, 0)) == NULL &&
		(client = clntudp_create(&sin, MOUNTPROG, MOUNTVERS, tv, &sock)) == NULL) {
		plog(XLOG_ERROR, "Failed to make rpc connection to mountd on %s", host);
		error = EIO;
		goto out;
	}

	if (!nfs_auth) {
		error = make_nfs_auth();
		if (error)
			goto out;
	}

	client->cl_auth = nfs_auth;

#ifdef DEBUG
	dlog("Fetching export list from %s", host);
#endif /* DEBUG */

	/*
	 * Fetch the export list
	 */
	tv2.tv_sec = 10; tv2.tv_usec = 0;
	clnt_stat = clnt_call(client, MOUNTPROC_EXPORT, xdr_void, 0, xdr_exports, &exlist, tv2);
	if (clnt_stat != RPC_SUCCESS) {
		/*clnt_perror(client, "rpc");*/
		error = EIO;
		goto out;
	}

	/*
	 * Figure out how many exports were returned
	 */
	for (n_export = 0, ex = exlist; ex; ex = ex->ex_next) {
		/*printf("export %s\n", ex->ex_dir);*/
		n_export++;
	}
#ifdef DEBUG
	/*dlog("%d exports returned", n_export);*/
#endif /* DEBUG */

	/*
	 * Allocate an array of pointers into the list
	 * so that they can be sorted.  If the filesystem
	 * is already mounted then ignore it.
	 */
	ep = xreallocarray(NULL, n_export, sizeof *ep);
	for (j = 0, ex = exlist; ex; ex = ex->ex_next) {
		MAKE_MNTPT(mntpt, ex, mf);
		if (!already_mounted(mlist, mntpt))
			ep[j++] = ex;
	}
	n_export = j;

	/*
	 * Sort into order.
	 * This way the mounts are done in order down the tree,
	 * instead of any random order returned by the mount
	 * daemon (the protocol doesn't specify...).
	 */
	qsort(ep, n_export, sizeof(exports), sortfun);

	/*
	 * Allocate an array of filehandles
	 */
	fp = xreallocarray(NULL, n_export, sizeof *fp);

	/*
	 * Try to obtain filehandles for each directory.
	 * If a fetch fails then just zero out the array
	 * reference but discard the error.
	 */
	for (j = k = 0; j < n_export; j++) {
		/* Check and avoid a duplicated export entry */
		if (j > k && ep[k] && strcmp(ep[j]->ex_dir, ep[k]->ex_dir) == 0) {
#ifdef DEBUG
			dlog("avoiding dup fhandle requested for %s", ep[j]->ex_dir);
#endif
			ep[j] = 0;
		} else {
			k = j;
			if ((error = fetch_fhandle(client, ep[j]->ex_dir, &fp[j])))
				ep[j] = 0;
		}
	}

	/*
	 * Mount each filesystem for which we have a filehandle.
	 * If any of the mounts succeed then mark "ok" and return
	 * error code 0 at the end.  If they all fail then return
	 * the last error code.
	 */
	strlcpy(fs_name, mf->mf_info, sizeof(fs_name));
	if ((rfs_dir = strchr(fs_name, ':')) == (char *) 0) {
		plog(XLOG_FATAL, "host_fmount: mf_info has no colon");
		error = EINVAL;
		goto out;
	}
	++rfs_dir;
	for (j = 0; j < n_export; j++) {
		ex = ep[j];
		if (ex) {
			strlcpy(rfs_dir, ex->ex_dir, fs_name + sizeof fs_name - rfs_dir);
			MAKE_MNTPT(mntpt, ex, mf);
			if (do_mount(&fp[j], mntpt, fs_name, mf->mf_mopts, mf) == 0)
				ok = TRUE;
		}
	}

	/*
	 * Clean up and exit
	 */
out:
	discard_mntlist(mlist);
	free(ep);
	free(fp);
	if (client)
		clnt_destroy(client);
	if (exlist)
		xdr_pri_free(xdr_exports, &exlist);
	if (ok)
		return 0;
	return error;
}

/*
 * Return true if pref is a directory prefix of dir.
 *
 * TODO:
 * Does not work if pref is "/".
 */
static int
directory_prefix(char *pref, char *dir)
{
	int len = strlen(pref);
	if (strncmp(pref, dir, len) != 0)
		return FALSE;
	if (dir[len] == '/' || dir[len] == '\0')
		return TRUE;
	return FALSE;
}

/*
 * Unmount a mount tree
 */
static int
host_fumount(mntfs *mf)
{
	mntlist *ml, *mprev;
	int xerror = 0;

	/*
	 * Read the mount list
	 */
	mntlist *mlist = read_mtab(mf->mf_mount);

	/*
	 * Reverse list...
	 */
	ml = mlist;
	mprev = 0;
	while (ml) {
		mntlist *ml2 = ml->mnext;
		ml->mnext = mprev;
		mprev = ml;
		ml = ml2;
	}
	mlist = mprev;

	/*
	 * Unmount all filesystems...
	 */
	for (ml = mlist; ml && !xerror; ml = ml->mnext) {
		char *dir = ml->mnt->mnt_dir;
		if (directory_prefix(mf->mf_mount, dir)) {
			int error;
#ifdef DEBUG
			dlog("host: unmounts %s", dir);
#endif /* DEBUG */
			/*
			 * Unmount "dir"
			 */
			error = umount_fs(dir);
			/*
			 * Keep track of errors
			 */
			if (error) {
				if (!xerror)
					xerror = error;
				if (error != EBUSY) {
					errno = error;
					plog(XLOG_ERROR, "Tree unmount of %s failed: %m", ml->mnt->mnt_dir);
				}
			} else {
#ifdef HOST_MKDIRS
				(void) rmdirs(dir);
#endif /* HOST_MKDIRS */
			}
		}
	}

	/*
	 * Throw away mount list
	 */
	discard_mntlist(mlist);

	/*
	 * Try to remount, except when we are shutting down.
	 */
	if (xerror && amd_state != Finishing) {
		xerror = host_fmount(mf);
		if (!xerror) {
			/*
			 * Don't log this - it's usually too verbose
			plog(XLOG_INFO, "Remounted host %s", mf->mf_info);
			 */
			xerror = EBUSY;
		}
	}
	return xerror;
}

/*
 * Tell mountd we're done.
 * This is not quite right, because we may still
 * have other filesystems mounted, but the existing
 * mountd protocol is badly broken anyway.
 */
static void host_umounted(am_node *mp)
{
}


#else /* HOST_EXEC */

static int
host_exec(char *op, char *host, char *fs, char *opts)
{
	int error;
	char *argv[7];

	/*
	 * Build arg vector
	 */
	argv[0] = host_helper;
	argv[1] = host_helper;
	argv[2] = op;
	argv[3] = host;
	argv[4] = fs;
	argv[5] = opts && *opts ? opts : "rw,default";
	argv[6] = 0;

	/*
	 * Put stdout to stderr
	 */
	(void) fclose(stdout);
	(void) dup(fileno(logfp));
	if (fileno(logfp) != fileno(stderr)) {
		(void) fclose(stderr);
		(void) dup(fileno(logfp));
	}
	/*
	 * Try the exec
	 */
#ifdef DEBUG
	Debug(D_FULL) {
		char **cp = argv;
		plog(XLOG_DEBUG, "executing (un)mount command...");
		while (*cp) {
			plog(XLOG_DEBUG, "arg[%d] = '%s'", cp-argv, *cp);
			cp++;
		}
	}
#endif /* DEBUG */
	if (argv[0] == 0 || argv[1] == 0) {
		errno = EINVAL;
		plog(XLOG_USER, "1st/2nd args missing to (un)mount program");
	} else {
		(void) execv(argv[0], argv+1);
	}
	/*
	 * Save error number
	 */
	error = errno;
	plog(XLOG_ERROR, "exec %s failed: %m", argv[0]);

	/*
	 * Return error
	 */
	return error;
}

static int
host_mount(am_node *mp)
{
	mntfs *mf = mp->am_mnt;

	return host_exec("mount", mf->mf_server->fs_host, mf->mf_mount, mf->mf_opts);
}

static int
host_umount(am_node *mp)
{
	mntfs *mf = mp->am_mnt;

	return host_exec("unmount", mf->mf_server->fs_host, mf->mf_mount, "xxx");
}

#endif /* HOST_EXEC */

/*
 * Ops structure
 */
am_ops host_ops = {
	"host",
	host_match,
	host_init,
	auto_fmount,
	host_fmount,
	auto_fumount,
	host_fumount,
	efs_lookuppn,
	efs_readdir,
	0, /* host_readlink */
	0, /* host_mounted */
#ifdef HOST_EXEC
	0, /* host_umounted */
#else
	host_umounted,
#endif
	find_nfs_srvr,
	FS_MKMNT|FS_BACKGROUND|FS_AMQINFO
};

#endif /* HAS_HOST */
@


1.18
log
@clnt_sperrno() is declared nowadays in <rpc/clnt.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.17 2014/10/26 01:38:02 guenther Exp $	*/
d366 2
a367 4
	if (ep)
		free(ep);
	if (fp)
		free(fp);
@


1.17
log
@Remove trailing newlines from a couple log messages
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.16 2014/10/26 01:16:48 guenther Exp $	*/
a177 1
		extern char *clnt_sperrno();
@


1.16
log
@Replace xrealloc() with xreallocarray().  Break-out the 'log and die'
function as xmallocfailure() and use that in the locations where
reallocarray's checks alone aren't sufficient.

ok doug@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.15 2014/10/20 06:55:59 guenther Exp $	*/
d133 1
a133 1
	dlog("host: mounting fs %s on %s\n", fs_name, dir);
d291 1
a291 1
	/*dlog("%d exports returned\n", n_export);*/
@


1.15
log
@Change MTAB_TYPE_UFS from "ufs" to "ffs", fixing mount-restarting for them.
Perform one level of expansion on the various "portability" macros from os-*.h
Delete support for Hesiod and the pre-4.4 versions of the NFS API
Delete the no-op unlock_mntlist()
unifdef -UFASCIST_DF_COMMAND -UMOUNT_HELPER_SOURCE
Move the struct mntent and MNTMAXSTR definitions into include/am.h
Move the commented-out -DHAS_NDBM_MAPS into amd/Makefile
Expand OS_REP to "bsd44".
With config/* empty, delete them.

"lot of stuff...but I know your process on this" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.14 2014/10/20 02:33:42 guenther Exp $	*/
d299 1
a299 1
	ep = (exports *) xmalloc(n_export * sizeof(exports));
d318 1
a318 1
	fp = (fhstatus *) xmalloc(n_export * sizeof(fhstatus));
@


1.14
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.13 2003/06/02 23:36:51 millert Exp $	*/
a240 5
	 * Unlock the mount list
	 */
	unlock_mntlist();

	/*
a411 5
	 * Unlock the mount list
	 */
	unlock_mntlist();

	/*
d437 1
a437 1
			error = UMOUNT_FS(dir);
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.12 2003/04/07 23:45:45 tedu Exp $	*/
a174 1
#if NFS_PROTOCOL_VERSION >= 3
a175 1
#endif
a494 55
#ifdef INFORM_MOUNTD
	mntfs *mf = mp->am_mnt;
	char *host;
	CLIENT *client;
	enum clnt_stat clnt_stat;
	struct sockaddr_in sin;
	int sock = RPC_ANYSOCK;
	struct timeval tv;
	tv.tv_sec = 10; tv.tv_usec = 0;

	if (mf->mf_error || mf->mf_refc > 1 || ! mf->mf_server)
		return;

	host = mf->mf_server->fs_host;
	sin = *mf->mf_server->fs_ip;

	/*
	 * Zero out the port - make sure we recompute
	 */
	sin.sin_port = 0;
	/*
	 * Make a client end-point.
	 * Try TCP first
	 */
	if ((client = clnttcp_create(&sin, MOUNTPROG, MOUNTVERS, &sock, 0, 0)) == NULL &&
		(client = clntudp_create(&sin, MOUNTPROG, MOUNTVERS, tv, &sock)) == NULL) {
		plog(XLOG_ERROR, "Failed to make rpc connection to mountd on %s", host);
		goto out;
	}

	if (!nfs_auth) {
		if (make_nfs_auth())
			goto out;
	}

	client->cl_auth = nfs_auth;

#ifdef DEBUG
	dlog("Unmounting all from %s", host);
#endif /* DEBUG */

	clnt_stat = clnt_call(client, MOUNTPROC_UMNTALL, xdr_void, 0, xdr_void, 0, tv);
	if (clnt_stat != RPC_SUCCESS && clnt_stat != RPC_SYSTEMERROR) {
		/* RPC_SYSTEMERROR seems to be returned for no good reason ...*/
		extern char *clnt_sperrno();
		char *msg = clnt_sperrno(clnt_stat);
		plog(XLOG_ERROR, "unmount all from %s rpc failed: %s", host, msg, clnt_stat);
		goto out;
	}

out:
	if (client)
		clnt_destroy(client);

#endif /* INFORM_MOUNTD */
@


1.12
log
@strcpy -> strlcpy.  some from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.11 2003/04/04 00:43:17 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.10 2002/08/05 07:24:26 pvalchev Exp $	*/
d366 1
a366 1
			strcpy(rfs_dir, ex->ex_dir);
@


1.10
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.9 2002/08/03 21:49:24 deraadt Exp $	*/
d75 1
a75 1
				strcpy((mntpt), (mf)->mf_mount); \
@


1.9
log
@xdr_pri_free() ansi; pvalchev ok
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.8 2002/08/03 08:29:31 pvalchev Exp $	*/
d206 1
a206 1
already_mounted(mntlist *mlist, char*dir)
@


1.8
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.7 2002/07/18 02:03:00 deraadt Exp $	*/
d123 1
a123 1
xdr_pri_free(xdrproc_t xdr_args, caddr_t args_ptr)
@


1.7
log
@space nits
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.6 2002/06/11 05:29:54 itojun Exp $	*/
d83 2
a84 3
static char *host_match P((am_opts *fo));
static char *host_match(fo)
am_opts *fo;
d102 2
a103 2
static int host_init(mf)
mntfs *mf;
d123 1
a123 3
xdr_pri_free(xdr_args, args_ptr)
xdrproc_t xdr_args;
caddr_t args_ptr;
d126 1
d131 2
a132 7
static int do_mount P((fhstatus *fhp, char *dir, char *fs_name, char *opts, mntfs *mf));
static int do_mount(fhp, dir, fs_name, opts, mf)
fhstatus *fhp;
char *dir;
char *fs_name;
char *opts;
mntfs *mf;
d135 1
d150 2
a151 3
static int sortfun P((const void *arg1, const void *arg2));
static int sortfun(arg1, arg2)
const void *arg1, *arg2;
d160 2
a161 5
static int fetch_fhandle P((CLIENT *client, char *dir, fhstatus *fhp));
static int fetch_fhandle(client, dir, fhp)
CLIENT *client;
char *dir;
fhstatus *fhp;
d205 2
a206 4
static int already_mounted P((mntlist *mlist, char*dir));
static int already_mounted(mlist, dir)
mntlist *mlist;
char *dir;
d219 2
a220 3
static int host_fmount P((mntfs *mf));
static int host_fmount(mf)
mntfs *mf;
d397 2
a398 4
static int directory_prefix P((char *pref, char *dir));
static int directory_prefix(pref, dir)
char *pref;
char *dir;
d411 2
a412 3
static int host_fumount P((mntfs *mf));
static int host_fumount(mf)
mntfs *mf;
d462 1
a462 1
					plog("Tree unmount of %s failed: %m", ml->mnt->mnt_dir);
d499 1
a499 2
static void host_umounted(mp)
am_node *mp;
d561 2
a562 6
static int host_exec P((char*op, char*host, char*fs, char*opts));
static int host_exec(op, host, fs, opts)
char *op;
char *host;
char *fs;
char *opts;
d618 2
a619 3
static int host_mount P((am_node *mp));
static int host_mount(mp)
am_node *mp;
d626 2
a627 3
static int host_umount P((am_node *mp));
static int host_umount(mp)
am_node *mp;
@


1.6
log
@use snprintf.
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.5 2002/06/10 21:07:14 itojun Exp $	*/
a99 1
	
d616 1
a616 1
	  		plog(XLOG_DEBUG, "arg[%d] = '%s'", cp-argv, *cp);
@


1.5
log
@strlcpy, strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.4 2001/03/02 06:22:02 deraadt Exp $	*/
d77 1
a77 1
				sprintf((mntpt), "%s%s", (mf)->mf_mount, (ex)->ex_dir); \
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.3 1997/01/31 14:41:58 graichen Exp $	*/
d370 1
a370 1
	strncpy(fs_name, mf->mf_info, sizeof(fs_name));
@


1.3
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d1 1
a1 1
/*	$OpenBSD: host_ops.c,v 1.2 1996/03/25 15:54:46 niklas Exp $	*/
d359 1
a359 1
			if (error = fetch_fhandle(client, ep[j]->ex_dir, &fp[j]))
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d157 3
a159 3
static int sortfun P((exports *a, exports *b));
static int sortfun(a, b)
exports *a,*b;
d161 1
@


1.1
log
@Initial revision
@
text
@d1 2
a40 1
 *	$Id: host_ops.c,v 1.3 1994/06/13 20:47:12 mycroft Exp $
d189 3
d202 1
a202 1
	if (fhp->fhs_status) {
d204 1
a204 1
		errno = fhp->fhs_status;
d207 1
a207 1
		return fhp->fhs_status;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
