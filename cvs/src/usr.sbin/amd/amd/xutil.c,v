head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.6
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.12.12.20.06.42;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	UYpZcqSFaggVdA2d;

1.18
date	2015.12.11.04.26.01;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	QfxsBeGJitJUAfkd;

1.17
date	2014.10.26.02.58.43;	author guenther;	state Exp;
branches;
next	1.16;
commitid	ZhyKR2nBKiFvutY0;

1.16
date	2014.10.26.02.43.50;	author guenther;	state Exp;
branches;
next	1.15;
commitid	QMh02q5MFiw3np67;

1.15
date	2014.10.26.02.32.51;	author guenther;	state Exp;
branches;
next	1.14;
commitid	iT0Nq2N4oC6UxuDO;

1.14
date	2014.10.26.01.16.48;	author guenther;	state Exp;
branches;
next	1.13;
commitid	Qcgfc5DGBBARLngk;

1.13
date	2014.10.20.00.20.04;	author guenther;	state Exp;
branches;
next	1.12;
commitid	ciYfifbFHhmQvDo5;

1.12
date	2009.08.12.13.21.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.11.04.45.54;	author david;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.26.02.49.50;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.25.07.37.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.02.06.22.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.08.28.13.43.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.31.14.42.04;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove the rest of the 20+ year-old memory debugging gunk. Discussed
with deraadt@@
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)xutil.c	8.1 (Berkeley) 6/6/93
 *	$Id: xutil.c,v 1.18 2015/12/11 04:26:01 mmcc Exp $
 */

#include "am.h"

#include <sys/stat.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

FILE *logfp = stderr;		/* Log errors to stderr initially */
int syslogging;
int xlog_level = XLOG_ALL & ~XLOG_MAP & ~XLOG_STATS & ~XLOG_INFO;
int xlog_level_init = ~0;

/*
 * List of log options
 */
struct opt_tab xlog_opt[] = {
	{ "all", XLOG_ALL },		/* All messages */
#ifdef DEBUG
	{ "debug", XLOG_DEBUG },	/* Debug messages */
#endif /* DEBUG */
	{ "error", XLOG_ERROR },	/* Non-fatal system errors */
	{ "fatal", XLOG_FATAL },	/* Fatal errors */
	{ "info", XLOG_INFO },		/* Information */
	{ "map", XLOG_MAP },		/* Map errors */
	{ "stats", XLOG_STATS },	/* Additional statistical information */
	{ "user", XLOG_USER },		/* Non-fatal user errors */
	{ "warn", XLOG_WARNING },	/* Warnings */
	{ "warning", XLOG_WARNING },	/* Warnings */
	{ 0, 0 }
};

__dead void
xmallocfailure(void)
{
	plog(XLOG_FATAL, "Out of memory");
	going_down(1);
	abort();
}

void *
xmalloc(size_t len)
{
	void *p;
	int retries = 600;

	do {
		if ((p = malloc(len)) != NULL)
			return p;

		if (retries > 0) {
			plog(XLOG_ERROR, "Retrying memory allocation");
			sleep(1);
		}
	} while (--retries);

	xmallocfailure();
}

void *
xreallocarray(void *ptr, size_t nmemb, size_t size)
{
	ptr = reallocarray(ptr, nmemb, size);

	if (ptr == NULL)
		xmallocfailure();
	return (ptr);
}


/*
 * Take a log format string and expand occurrences of %m
 * with the current error code taken from errno.  Make sure
 * 'e' never gets longer than maxlen characters.
 */
static void
expand_error(const char *f, char *e, int maxlen)
{
	const char *p;
	char *q;
	int error = errno;
	int len = 0;

	for (p = f, q = e; (*q = *p) && len < maxlen; len++, q++, p++) {
		if (p[0] == '%' && p[1] == 'm') {
			char *errstr;
			errstr = strerror(error);
			if (errstr)
				strlcpy(q, errstr, maxlen - (q - e));
			else
				snprintf(q, maxlen - (q - e),
				    "Error %d", error);
			len += strlen(q) - 1;
			q += strlen(q) - 1;
			p++;
		}
	}
	e[maxlen-1] = '\0';		/* null terminate, to be sure */
}

/*
 * Output the time of day and hostname to the logfile
 */
static void
show_time_host_and_name(int lvl)
{
	static time_t last_t = 0;
	static char *last_ctime = 0;
	time_t t = clocktime();
	char *sev;

#if defined(DEBUG) && defined(PARANOID)
extern char **gargv;
#endif /* defined(DEBUG) && defined(PARANOID) */

	if (t != last_t) {
		last_ctime = ctime(&t);
		last_t = t;
	}

	switch (lvl) {
	case XLOG_FATAL:	sev = "fatal:"; break;
	case XLOG_ERROR:	sev = "error:"; break;
	case XLOG_USER:		sev = "user: "; break;
	case XLOG_WARNING:	sev = "warn: "; break;
	case XLOG_INFO:		sev = "info: "; break;
	case XLOG_DEBUG:	sev = "debug:"; break;
	case XLOG_MAP:		sev = "map:  "; break;
	case XLOG_STATS:	sev = "stats:"; break;
	default:		sev = "hmm:  "; break;
	}
	fprintf(logfp, "%15.15s %s %s[%ld]/%s ",
		last_ctime+4, hostname,
#if defined(DEBUG) && defined(PARANOID)
		gargv[0],
#else
		__progname,
#endif /* defined(DEBUG) && defined(PARANOID) */
		(long)mypid,
		sev);
}

void
plog(int lvl, const char *fmt, ...)
{
	char efmt[1024];
	va_list ap;

	if (!(xlog_level & lvl))
		return;


	if (syslogging) {
		switch(lvl) {	/* from mike <mcooper@@usc.edu> */
		case XLOG_FATAL:	lvl = LOG_CRIT; break;
		case XLOG_ERROR:	lvl = LOG_ERR; break;
		case XLOG_USER:		lvl = LOG_WARNING; break;
		case XLOG_WARNING:	lvl = LOG_WARNING; break;
		case XLOG_INFO:		lvl = LOG_INFO; break;
		case XLOG_DEBUG:	lvl = LOG_DEBUG; break;
		case XLOG_MAP:		lvl = LOG_DEBUG; break;
		case XLOG_STATS:	lvl = LOG_INFO; break;
		default:		lvl = LOG_ERR; break;
		}
		va_start(ap, fmt);
		vsyslog(lvl, fmt, ap);
		va_end(ap);
		return;
	}

	expand_error(fmt, efmt, sizeof(efmt));

	/*
	 * Mimic syslog header
	 */
	show_time_host_and_name(lvl);
	va_start(ap, fmt);
	vfprintf(logfp, efmt, ap);
	va_end(ap);
	fputc('\n', logfp);
	fflush(logfp);
}

void
show_opts(int ch, struct opt_tab *opts)
{
	/*
	 * Display current debug options
	 */
	int i;
	int s = '{';

	fprintf(stderr, "\t[-%c {no}", ch);
	for (i = 0; opts[i].opt; i++) {
		fprintf(stderr, "%c%s", s, opts[i].opt);
		s = ',';
	}
	fputs("}]\n", stderr);
}

int
cmdoption(char *s, struct opt_tab *optb, int *flags)
{
	char *p = s;
	int errs = 0;

	while (p && *p) {
		int neg;
		char *opt;
		struct opt_tab *dp, *dpn = 0;

		s = p;
		p = strchr(p, ',');
		if (p)
			*p = '\0';

		if (s[0] == 'n' && s[1] == 'o') {
			opt = s + 2;
			neg = 1;
		} else {
			opt = s;
			neg = 0;
		}

		/*
		 * Scan the array of debug options to find the
		 * corresponding flag value.  If it is found
		 * then set (or clear) the flag (depending on
		 * whether the option was prefixed with "no").
		 */
		for (dp = optb; dp->opt; dp++) {
			if (strcmp(opt, dp->opt) == 0)
				break;
			if (opt != s && !dpn && strcmp(s, dp->opt) == 0)
				dpn = dp;
		}

		if (dp->opt || dpn) {
			if (!dp->opt) {
				dp = dpn;
				neg = !neg;
			}
			if (neg)
				*flags &= ~dp->flag;
			else
				*flags |= dp->flag;
		} else {
			/*
			 * This will log to stderr when parsing the command line
			 * since any -l option will not yet have taken effect.
			 */
			plog(XLOG_USER, "option \"%s\" not recognised", s);
			errs++;
		}
		/*
		 * Put the comma back
		 */
		if (p)
			*p++ = ',';
	}

	return errs;
}

/*
 * Switch on/off logging options
 */
int
switch_option(char *opt)
{
	int xl = xlog_level;
	int rc = cmdoption(opt, xlog_opt, &xl);
	if (rc) {
		rc = EINVAL;
	} else {
		/*
		 * Keep track of initial log level, and
		 * don't allow options to be turned off.
		 */
		if (xlog_level_init == ~0)
			xlog_level_init = xl;
		else
			xl |= xlog_level_init;
		xlog_level = xl;
	}
	return rc;
}

/*
 * Change current logfile
 */
int
switch_to_logfile(char *logfile)
{
	FILE *new_logfp = stderr;

	if (logfile) {
		syslogging = 0;
		if (strcmp(logfile, "/dev/stderr") == 0)
			new_logfp = stderr;
		else if (strcmp(logfile, "syslog") == 0) {
			syslogging = 1;
			new_logfp = stderr;
#if defined(LOG_CONS) && defined(LOG_NOWAIT)
			openlog(__progname, LOG_PID|LOG_CONS|LOG_NOWAIT,
				LOG_DAEMON);
#else
			/* 4.2 compat mode - XXX */
			openlog(__progname, LOG_PID);
#endif /* LOG_CONS && LOG_NOWAIT */
		} else {
			(void) umask(orig_umask);
			new_logfp = fopen(logfile, "a");
			umask(0);
		}
	}

	/*
	 * If we couldn't open a new file, then continue using the old.
	 */
	if (!new_logfp && logfile) {
		plog(XLOG_USER, "%s: Can't open logfile: %m", logfile);
		return 1;
	}
	/*
	 * Close the previous file
	 */
	if (logfp && logfp != stderr)
		(void) fclose(logfp);
	logfp = new_logfp;
	return 0;
}

time_t clock_valid = 0;
time_t xclock_valid = 0;
#ifndef clocktime
time_t
clocktime(void)
{
	time_t now = time(&clock_valid);
	if (xclock_valid > now) {
		/*
		 * Someone set the clock back!
		 */
		plog(XLOG_WARNING, "system clock reset");
		reschedule_timeouts(now, xclock_valid);
	}
	return xclock_valid = now;
}
#endif /* clocktime */
@


1.18
log
@Remove debugging fluff from allocation functions. There's probably more
of this stuff elsewhere in amd.

"such clutter just makes people not care" deraadt@@
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.17 2014/10/26 02:58:43 guenther Exp $
a108 28
#ifdef DEBUG_MEM
static int mem_bytes;
static int orig_mem_bytes;

static void
checkup_mem(void)
{
	extern struct mallinfo __mallinfo;
	if (mem_bytes != __mallinfo.uordbytes) {
		if (orig_mem_bytes == 0)
			mem_bytes = orig_mem_bytes = __mallinfo.uordbytes;
		else {
			fprintf(logfp, "%s[%ld]: ", __progname, (long)mypid);
			if (mem_bytes < __mallinfo.uordbytes) {
				fprintf(logfp, "ALLOC: %d bytes",
					__mallinfo.uordbytes - mem_bytes);
			} else {
				fprintf(logfp, "FREE: %d bytes",
					mem_bytes - __mallinfo.uordbytes);
			}
			mem_bytes = __mallinfo.uordbytes;
			fprintf(logfp, ", making %d missing\n",
				mem_bytes - orig_mem_bytes);
		}
	}
	malloc_verify();
}
#endif /* DEBUG_MEM */
a190 3
#ifdef DEBUG_MEM
	checkup_mem();
#endif /* DEBUG_MEM */
@


1.17
log
@Sort #includes; pull in <time.h> for ctime()
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.16 2014/10/26 02:43:50 guenther Exp $
d87 1
a87 5
		p = malloc(len);
		if (p) {
#if defined(DEBUG) && defined(DEBUG_MEM)
			Debug(D_MEM) plog(XLOG_DEBUG, "Allocated size %zu; block %#x", len, p);
#endif /* defined(DEBUG) && defined(DEBUG_MEM) */
d89 1
a89 1
		}
a101 4
#if defined(DEBUG) && defined(DEBUG_MEM)
	Debug(D_MEM) plog(XLOG_DEBUG, "Reallocated nmemb %zu of size %zu; block %#x", nmemb, size, ptr);
#endif /* defined(DEBUG) && defined(DEBUG_MEM) */

a108 8
#if defined(DEBUG) && defined(DEBUG_MEM)
xfree(char *f, int l, void *p)
{
	Debug(D_MEM) plog(XLOG_DEBUG, "Free in %s:%d: block %#x", f, l, p);
#undef free
	free(p);
}
#endif /* defined(DEBUG) && defined(DEBUG_MEM) */
@


1.16
log
@Lint is dead
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.15 2014/10/26 02:32:51 guenther Exp $
d38 1
a38 3
#include "config.h"
#include <syslog.h>
#include <string.h>
d40 1
a40 1
#include <unistd.h>
d43 4
a46 1
#include <sys/stat.h>
a193 1
	extern char *ctime();
@


1.15
log
@Use vsyslog() instead of manually expanding the string and calling syslog(%s)
Now that newline stripping isn't needed, use vfprintf() instead of formatting
   and then writing it out.
Delete bogus XXX comment that predated the switch to vsnprintf()
Make the format string const char *
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.14 2014/10/26 01:16:48 guenther Exp $
a225 1
/*VARARGS1*/
@


1.14
log
@Replace xrealloc() with xreallocarray().  Break-out the 'log and die'
function as xmallocfailure() and use that in the locations where
reallocarray's checks alone aren't sufficient.

ok doug@@ deraadt@@
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.13 2014/10/20 00:20:04 guenther Exp $
d159 1
a159 1
expand_error(char *f, char *e, int maxlen)
d161 2
a162 1
	char *p, *q;
d228 1
a228 1
plog(int lvl, char *fmt, ...)
a229 1
	char msg[1024];
a230 1
	char *ptr;
a232 2
	va_start(ap, fmt);

a239 10
	expand_error(fmt, efmt, sizeof(efmt));
	/*
	 * XXX: msg is 1024 bytes long.  It is possible to write into it
	 * more than 1024 bytes, if efmt is already large, and vargs expand
	 * as well.
	 */
	vsnprintf(msg, sizeof(msg), efmt, ap);
	ptr = msg + strlen(msg);
	if (ptr[-1] == '\n')
		*--ptr  = '\0';
d252 3
a254 1
		syslog(lvl, "%s", msg);
d258 2
d263 3
a266 2
	show_time_host_and_name(lvl);
	fwrite(msg, ptr - msg, 1, logfp);
@


1.13
log
@Start removing portability goo: we have syslog(), strerror(), POSIX regexp,
    BSD-style getmntinfo(), BSD signals, 4.4BSD unmount(), etc
Delete configurations for other OSes
Delete fsinfo and mk-amd-map, as we don't build them.

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.12 2009/08/12 13:21:17 deraadt Exp $
d71 8
d80 1
a80 1
xmalloc(int len)
a84 6
	/*
	 * Avoid malloc's which return NULL for malloc(0)
	 */
	if (len == 0)
		len = 1;

d86 1
a86 1
		p = (void *)malloc((unsigned) len);
d89 1
a89 1
			Debug(D_MEM) plog(XLOG_DEBUG, "Allocated size %d; block %#x", len, p);
d99 1
a99 6
	plog(XLOG_FATAL, "Out of memory");
	going_down(1);

	abort();

	return 0;
d103 1
a103 1
xrealloc(void *ptr, int len)
d106 1
a106 1
	Debug(D_MEM) plog(XLOG_DEBUG, "Reallocated size %d; block %#x", len, ptr);
d109 1
a109 2
	if (len == 0)
		len = 1;
d111 3
a113 11
	if (ptr)
		ptr = (void *)realloc(ptr, (unsigned) len);
	else
		ptr = (void *)xmalloc((unsigned) len);

	if (!ptr) {
		plog(XLOG_FATAL, "Out of memory in realloc");
		going_down(1);
		abort();
	}
	return ptr;
@


1.12
log
@change some defaults inside amd itself, so that the rc scripts no longer
have to pass those options.  this makes amd much easier to restart by
hand (though it still remains a nasty daemon do that with)
ok millert
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.11 2003/06/02 23:36:51 millert Exp $
a38 1
#ifdef HAS_SYSLOG
a39 2
#endif /* HAS_SYSLOG */
#ifdef HAS_STRERROR
a40 1
#endif
a47 1
#ifdef HAS_SYSLOG
a48 1
#endif /* HAS_SYSLOG */
d170 1
a170 1
INLINE static void
a172 4
#ifndef HAS_STRERROR
	extern int sys_nerr;
	extern char *sys_errlist[];
#endif
a179 1
#ifdef HAS_STRERROR
a180 6
#else
			if (error < 0 || error >= sys_nerr)
				errstr = 0;
			else
				errstr = sys_errlist[error];
#endif
a264 1
#ifdef HAS_SYSLOG
a279 1
#endif /* HAS_SYSLOG */
a404 1
#ifdef HAS_SYSLOG
a405 1
#endif /* HAS_SYSLOG */
a408 1
#ifdef HAS_SYSLOG
a417 3
#else
			plog(XLOG_WARNING, "syslog option not supported, logging unchanged");
#endif /* HAS_SYSLOG */
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: xutil.c,v 1.10 2003/03/11 04:45:54 david Exp $
d55 1
a55 1
int xlog_level = XLOG_ALL & ~XLOG_MAP & ~XLOG_STATS;
@


1.10
log
@spelling
ok millert@@
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: xutil.c,v 1.9 2002/08/05 07:24:26 pvalchev Exp $
@


1.9
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.8 2002/08/03 08:29:31 pvalchev Exp $
d176 1
a176 1
 * Take a log format string and expand occurences of %m
@


1.8
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.7 2002/07/18 02:03:00 deraadt Exp $
d81 1
a81 1
voidp
d84 1
a84 1
	voidp p;
d94 1
a94 1
		p = (voidp) malloc((unsigned) len);
d115 2
a116 2
voidp
xrealloc(voidp ptr, int len)
d126 1
a126 1
		ptr = (voidp) realloc(ptr, (unsigned) len);
d128 1
a128 1
		ptr = (voidp) xmalloc((unsigned) len);
d139 1
a139 1
xfree(char *f, int l, voidp p)
d151 1
a151 1
checkup_mem(P_void)
d474 1
a474 1
clocktime(P_void)
@


1.7
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.6 2002/05/26 02:49:50 deraadt Exp $
d51 1
a61 2
extern char *__progname;

d81 2
a82 2
voidp xmalloc(len)
int len;
d115 2
a116 3
voidp xrealloc(ptr, len)
voidp ptr;
int len;
d139 1
a139 4
xfree(f, l, p)
char *f;
int l;
voidp p;
d149 3
a151 1
static void checkup_mem(P_void)
d153 1
a153 1
extern struct mallinfo __mallinfo;
d180 2
a181 4
INLINE
static void expand_error(f, e, maxlen)
char *f;
char *e;
d218 2
a219 2
static void show_time_host_and_name(lvl)
int lvl;
d221 2
a222 2
static time_t last_t = 0;
static char *last_ctime = 0;
a257 10
#ifdef DEBUG
/*VARARGS1*/
void dplog(fmt, j,s,_,p,e,n,d,r,y)
char *fmt;
char *j, *s, *_, *p, *e, *n, *d, *r, *y;
{
	plog(XLOG_DEBUG, fmt, j,s,_,p,e,n,d,r,y);
}

#endif /* DEBUG */
d259 2
a260 4
void plog(lvl, fmt, j,s,_,p,e,n,d,r,y)
int lvl;
char *fmt;
char *j, *s, *_, *p, *e, *n, *d, *r, *y;
d265 3
d282 1
a282 1
	snprintf(msg, sizeof(msg), efmt, j,s,_,p,e,n,d,r,y);
d307 1
d314 2
a315 4
void show_opts P((int ch, struct opt_tab *opts));
void show_opts(ch, opts)
int ch;
struct opt_tab *opts;
d322 1
d331 2
a332 5
int cmdoption P((char *s, struct opt_tab *optb, int *flags));
int cmdoption(s, optb, flags)
char *s;
struct opt_tab *optb;
int *flags;
d398 2
a399 2
int switch_option(opt)
char *opt;
d422 2
a423 3
int switch_to_logfile P((char *logfile));
int switch_to_logfile(logfile)
char *logfile;
d473 2
a474 1
time_t clocktime(P_void)
@


1.6
log
@pid_cleanup, inspired by work by jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.5 2002/05/25 07:37:19 deraadt Exp $
d243 1
a243 1
	case XLOG_ERROR: 	sev = "error:"; break;
d304 1
a304 1
		case XLOG_ERROR: 	lvl = LOG_ERR; break;
@


1.5
log
@__progname stuff; jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.4 2001/03/02 06:22:05 deraadt Exp $
d161 1
a161 1
			fprintf(logfp, "%s[%d]: ", __progname, mypid);
d252 1
a252 1
	fprintf(logfp, "%15.15s %s %s[%d]/%s ",
d259 1
a259 1
		mypid,
@


1.4
log
@KNF
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.3 1999/08/28 13:43:11 millert Exp $
d61 2
d161 1
a161 1
			fprintf(logfp, "%s[%d]: ", progname, mypid);
d257 1
a257 1
		progname,
d456 1
a456 1
			openlog(progname, LOG_PID|LOG_CONS|LOG_NOWAIT,
d460 1
a460 1
			openlog(progname, LOG_PID);
@


1.3
log
@Fix potential buf oflow in log routines.  Adapted from am-utils patch.
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.2 1997/01/31 14:42:04 graichen Exp $
d50 1
d52 1
@


1.2
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.1.1.1 1995/10/18 08:47:12 deraadt Exp $
d176 2
a177 1
 * with the current error code take from errno.
d180 1
a180 1
static void expand_error(f, e)
d188 1
a188 1
	char *p;
d190 1
d192 1
a192 1
	for (p = f; *e = *p; e++, p++) {
d204 1
a204 1
				strcpy(e, errstr);
d206 4
a209 2
				sprintf(e, "Error %d", error);
			e += strlen(e) - 1;
d213 1
d277 1
a277 1
	char *ptr = msg;
d286 8
a293 3
	expand_error(fmt, efmt);
	sprintf(ptr, efmt, j,s,_,p,e,n,d,r,y);
	ptr += strlen(ptr);
a313 3
	*ptr++ = '\n';
	*ptr = '\0';

d319 1
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: xutil.c,v 1.4 1994/06/13 20:48:13 mycroft Exp $
d49 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
