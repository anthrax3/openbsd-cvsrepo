head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.48
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.46
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.42
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.40
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.38
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.36
	OPENBSD_5_0:1.7.0.34
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.32
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.30
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.26
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.13.15.44.47;	author guenther;	state Exp;
branches;
next	1.9;
commitid	pjR4xrhVkhrUEI1x;

1.9
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.8;
commitid	RUbgWdu1CNTVPIOS;

1.8
date	2014.10.26.03.08.21;	author guenther;	state Exp;
branches;
next	1.7;
commitid	WHJr6yXZrF36RX5I;

1.7
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.06.19.46.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@More FNDELAY/FIONBIO --> SOCK_NONBLOCK conversions

ok millert@@
@
text
@/*
 * Copyright (c) 1989 Jan-Simon Pendry
 * Copyright (c) 1989 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)rpc_fwd.c	8.1 (Berkeley) 6/6/93
 *	$Id: rpc_fwd.c,v 1.9 2014/10/26 03:28:41 guenther Exp $
 */

/*
 * RPC packet forwarding
 */

#include "am.h"
#include <sys/ioctl.h>

/*
 * Note that the ID field in the external packet is only
 * ever treated as a 32 bit opaque data object, so there
 * is no need to convert to and from network byte ordering.
 */

/*
 * Each pending reply has an rpc_forward structure
 * associated with it.  These have a 15 second lifespan.
 * If a new structure is required, then an expired
 * one will be re-allocated if available, otherwise a fresh
 * one is allocated.  Whenever a reply is received the
 * structure is discarded.
 */
typedef struct rpc_forward rpc_forward;
struct rpc_forward {
	qelem	rf_q;		/* Linked list */
	time_t	rf_ttl;		/* Time to live */
	u_int	rf_xid;		/* Packet id */
	u_int	rf_oldid;	/* Original packet id */
	fwd_fun	rf_fwd;		/* Forwarding function */
	void *	rf_ptr;
	struct sockaddr_in rf_sin;
};

/*
 * Head of list of pending replies
 */
extern qelem rpc_head;
qelem rpc_head = { &rpc_head, &rpc_head };

static u_int xid;
#define	XID_ALLOC()	(xid++)

#define	MAX_PACKET_SIZE	8192	/* Maximum UDP packet size */

int fwd_sock;

/*
 * Allocate a rely structure
 */
static rpc_forward *
fwd_alloc()
{
	time_t now = clocktime();
	rpc_forward *p = 0, *p2;

#ifdef DEBUG
	/*dlog("fwd_alloca: rpc_head = %#x", rpc_head.q_forw);*/
#endif /* DEBUG */
	/*
	 * First search for an existing expired one.
	 */
	ITER(p2, rpc_forward, &rpc_head) {
		if (p2->rf_ttl <= now) {
			p = p2;
			break;
		}
	}

	/*
	 * If one couldn't be found then allocate
	 * a new structure and link it at the
	 * head of the list.
	 */
	if (p) {
		/*
		 * Call forwarding function to say that
		 * this message was junked.
		 */
#ifdef DEBUG
		dlog("Re-using packet forwarding slot - id %#x", p->rf_xid);
#endif /* DEBUG */
		if (p->rf_fwd)
			(*p->rf_fwd)(0, 0, 0, &p->rf_sin, p->rf_ptr, FALSE);
		rem_que(&p->rf_q);
	} else {
		p = ALLOC(rpc_forward);
	}
	ins_que(&p->rf_q, &rpc_head);

	/*
	 * Set the time to live field
	 * Timeout in 43 seconds
	 */
	p->rf_ttl = now + 43;

#ifdef DEBUG
	/*dlog("fwd_alloca: rpc_head = %#x", rpc_head.q_forw);*/
#endif /* DEBUG */
	return p;
}

/*
 * Free an allocated reply structure.
 * First unlink it from the list, then
 * discard it.
 */
static void
fwd_free(rpc_forward *p)
{
#ifdef DEBUG
	/*dlog("fwd_free: rpc_head = %#x", rpc_head.q_forw);*/
#endif /* DEBUG */
	rem_que(&p->rf_q);
#ifdef DEBUG
	/*dlog("fwd_free: rpc_head = %#x", rpc_head.q_forw);*/
#endif /* DEBUG */
	free(p);
}

/*
 * Initialise the RPC forwarder
 */
int fwd_init()
{
	/*
	 * Create ping socket
	 */
	fwd_sock = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK, 0);
	if (fwd_sock < 0) {
		plog(XLOG_ERROR, "Unable to create RPC forwarding socket: %m");
		return errno;
	}

	/*
	 * Some things we talk to require a priv port - so make one here
	 */
	if (bind_resv_port(fwd_sock, (unsigned short *) 0) < 0)
		plog(XLOG_ERROR, "can't bind privileged port");

	return 0;
}

/*
 * Locate a packet in the forwarding list
 */
static rpc_forward *
fwd_locate(u_int id)
{
	rpc_forward *p;

	ITER(p, rpc_forward, &rpc_head) {
		if (p->rf_xid == id)
			return p;
	}

	return 0;
}

/*
 * This is called to forward a packet to another
 * RPC server.  The message id is changed and noted
 * so that when a reply appears we can tie it up
 * correctly.  Just matching the reply's source address
 * would not work because it might come from a
 * different address.
 */
int
fwd_packet(int type_id, void *pkt, int len, struct sockaddr_in *fwdto,
    struct sockaddr_in *replyto, void *i, fwd_fun cb)
{
	rpc_forward *p;
	u_int *pkt_int;
	int error;

	if ((int)amd_state >= (int)Finishing)
		return ENOENT;

	/*
	 * See if the type_id is fully specified.
	 * If so, then discard any old entries
	 * for this id.
	 * Otherwise make sure the type_id is
	 * fully qualified by allocating an id here.
	 */
#ifdef DEBUG
	switch (type_id & RPC_XID_MASK) {
	case RPC_XID_PORTMAP: dlog("Sending PORTMAP request"); break;
	case RPC_XID_MOUNTD: dlog("Sending MOUNTD request %#x", type_id); break;
	case RPC_XID_NFSPING: dlog("Sending NFS ping"); break;
	default: dlog("UNKNOWN RPC XID"); break;
	}
#endif /* DEBUG */

	if (type_id & ~RPC_XID_MASK) {
#ifdef DEBUG
		/*dlog("Fully qualified rpc type provided");*/
#endif /* DEBUG */
		p = fwd_locate(type_id);
		if (p) {
#ifdef DEBUG
			dlog("Discarding earlier rpc fwd handle");
#endif /* DEBUG */
			fwd_free(p);
		}
	} else {
#ifdef DEBUG
		dlog("Allocating a new xid...");
#endif /* DEBUG */
		type_id = MK_RPC_XID(type_id, XID_ALLOC());
	}

	p = fwd_alloc();
	if (!p)
		return ENOBUFS;

	error = 0;

	pkt_int = (u_int *) pkt;

	/*
	 * Get the original packet id
	 */
	p->rf_oldid = *pkt_int;

	/*
	 * Replace with newly allocated id
	 */
	p->rf_xid = *pkt_int = type_id;

	/*
	 * The sendto may fail if, for example, the route
	 * to a remote host is lost because an intermediate
	 * gateway has gone down.  Important to fill in the
	 * rest of "p" otherwise nasty things happen later...
	 */
#ifdef DEBUG
	{ char dq[20];

	dlog("Sending packet id %#x to %s.%d", p->rf_xid,
	    inet_dquad(dq, sizeof(dq), fwdto->sin_addr.s_addr),
	    ntohs(fwdto->sin_port));
	}
#endif /* DEBUG */
	if (sendto(fwd_sock, (char *) pkt, len, 0,
			(struct sockaddr *) fwdto, sizeof(*fwdto)) < 0)
		error = errno;

	/*
	 * Save callback function and return address
	 */
	p->rf_fwd = cb;
	if (replyto)
		p->rf_sin = *replyto;
	else
		bzero(&p->rf_sin, sizeof(p->rf_sin));
	p->rf_ptr = i;

	return error;
}

/*
 * Called when some data arrives on the forwarding socket
 */
void
fwd_reply()
{
	int len;
#ifdef DYNAMIC_BUFFERS
	void *pkt;
#else
	u_int pkt[MAX_PACKET_SIZE/sizeof(u_int)+1];
#endif /* DYNAMIC_BUFFERS */
	u_int *pkt_int;
	int rc;
	rpc_forward *p;
	struct sockaddr_in src_addr;
	socklen_t src_addr_len;

	/*
	 * Determine the length of the packet
	 */
#ifdef DYNAMIC_BUFFERS
	if (ioctl(fwd_sock, FIONREAD, &len) < 0 || len < 0) {
		plog(XLOG_ERROR, "Error reading packet size: %m");
		return;
	}

	/*
	 * Allocate a buffer
	 */
	pkt = malloc(len);
	if (!pkt) {
		plog(XLOG_ERROR, "Out of buffers in fwd_reply");
		return;
	}
#else
	len = MAX_PACKET_SIZE;
#endif /* DYNAMIC_BUFFERS */

	/*
	 * Read the packet and check for validity
	 */
again:
	src_addr_len = sizeof(src_addr);
	rc = recvfrom(fwd_sock, (char *) pkt, len, 0,
	    (struct sockaddr *) &src_addr, &src_addr_len);
	if (rc < 0 || src_addr_len != sizeof(src_addr) ||
			src_addr.sin_family != AF_INET) {
		if (rc < 0 && errno == EINTR)
			goto again;
		plog(XLOG_ERROR, "Error reading RPC reply: %m");
		goto out;
	}

#ifdef DYNAMIC_BUFFERS
	if (rc != len) {
		plog(XLOG_ERROR, "Short read in fwd_reply");
		goto out;
	}
#endif /* DYNAMIC_BUFFERS */

	/*
	 * Do no more work if finishing soon
	 */
	if ((int)amd_state >= (int)Finishing)
		goto out;

	/*
	 * Find packet reference
	 */
	pkt_int = (u_int *) pkt;

#ifdef DEBUG
	switch (*pkt_int & RPC_XID_MASK) {
	case RPC_XID_PORTMAP: dlog("Receiving PORTMAP reply"); break;
	case RPC_XID_MOUNTD: dlog("Receiving MOUNTD reply %#x", *pkt_int); break;
	case RPC_XID_NFSPING: dlog("Receiving NFS ping %#x", *pkt_int); break;
	default: dlog("UNKNOWN RPC XID"); break;
	}
#endif /* DEBUG */

	p = fwd_locate(*pkt_int);
	if (!p) {
#ifdef DEBUG
		dlog("Can't forward reply id %#x", *pkt_int);
#endif /* DEBUG */
		goto out;
	}

	if (p->rf_fwd) {
		/*
		 * Put the original message id back
		 * into the packet.
		 */
		*pkt_int = p->rf_oldid;

		/*
		 * Call forwarding function
		 */
		(*p->rf_fwd)(pkt, rc, &src_addr, &p->rf_sin, p->rf_ptr, TRUE);
	}

	/*
	 * Free forwarding info
	 */
	fwd_free(p);

out:;
#ifdef DYNAMIC_BUFFERS
	/*
	 * Free the packet
	 */
	free(pkt);
#endif /* DYNAMIC_BUFFERS */
}
@


1.9
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d35 1
a35 1
 *	$Id: rpc_fwd.c,v 1.8 2014/10/26 03:08:21 guenther Exp $
a43 6
#ifndef F_SETFL
#include <fcntl.h>
#endif /* F_SETFL */
#ifndef FNDELAY
#include <sys/file.h>
#endif /* FNDELAY */
a160 2
	int on = 1;

d164 1
a164 1
	fwd_sock = socket(AF_INET, SOCK_DGRAM, 0);
a174 6

	if (fcntl(fwd_sock, F_SETFL, FNDELAY) < 0 &&
			ioctl(fwd_sock, FIONBIO, &on) < 0) {
		plog(XLOG_ERROR, "Can't set non-block on forwarding socket: %m");
		return errno;
	}
@


1.8
log
@Delete casts to void* of the argument to free(): only needed when lying
about constness and none of these were
@
text
@d35 1
a35 1
 *	$Id: rpc_fwd.c,v 1.7 2003/06/02 23:36:51 millert Exp $
d305 1
a305 1
		bzero((void *)&p->rf_sin, sizeof(p->rf_sin));
d333 1
a333 1
	if (ioctl(fwd_sock, FIONREAD, &len) < 0) {
d341 1
a341 1
	pkt = (void *)malloc((unsigned) len);
d410 1
a410 1
		(*p->rf_fwd)((void *)pkt, rc, &src_addr, &p->rf_sin, p->rf_ptr, TRUE);
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: rpc_fwd.c,v 1.6 2002/09/06 19:46:52 deraadt Exp $
d159 1
a159 1
	free((void *)p);
d423 1
a423 1
	free((void *)pkt);
@


1.6
log
@use more socklen_t; pvalchev
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: rpc_fwd.c,v 1.5 2002/08/05 07:24:26 pvalchev Exp $
@


1.5
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: rpc_fwd.c,v 1.4 2002/08/03 08:29:31 pvalchev Exp $
d331 1
a331 1
	int src_addr_len;
d360 1
a360 1
			(struct sockaddr *) &src_addr, &src_addr_len);
@


1.4
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: rpc_fwd.c,v 1.3 2002/07/18 02:03:00 deraadt Exp $
d76 1
a76 1
	voidp	rf_ptr;
d163 1
a163 1
	free((voidp) p);
d222 2
a223 2
fwd_packet(int type_id, voidp pkt, int len, struct sockaddr_in *fwdto,
    struct sockaddr_in *replyto, voidp i, fwd_fun cb)
d309 1
a309 1
		bzero((voidp) &p->rf_sin, sizeof(p->rf_sin));
d323 1
a323 1
	voidp pkt;
d345 1
a345 1
	pkt = (voidp) malloc((unsigned) len);
d414 1
a414 1
		(*p->rf_fwd)((voidp) pkt, rc, &src_addr, &p->rf_sin, p->rf_ptr, TRUE);
d427 1
a427 1
	free((voidp) pkt);
@


1.3
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: rpc_fwd.c,v 1.2 2002/06/11 05:29:54 itojun Exp $
d96 2
a97 1
static rpc_forward *fwd_alloc()
d153 2
a154 2
static void fwd_free(p)
rpc_forward *p;
d200 2
a201 2
static rpc_forward *fwd_locate(id)
u_int id;
d221 3
a223 7
int fwd_packet(type_id, pkt, len, fwdto, replyto, i, cb)
int type_id;
voidp pkt;
int len;
struct sockaddr_in *fwdto, *replyto;
voidp i;
fwd_fun cb;
d318 2
a319 1
void fwd_reply()
@


1.2
log
@use snprintf.
@
text
@d39 1
a39 1
 *	$Id: rpc_fwd.c,v 1.1.1.1 1995/10/18 08:47:12 deraadt Exp $
d137 1
a137 1
	 * Timeout in 43 seconds 
d294 5
a298 2
	{ char dq[20]; 
	dlog("Sending packet id %#x to %s.%d", p->rf_xid, inet_dquad(dq, sizeof(dq), fwdto->sin_addr.s_addr), ntohs(fwdto->sin_port));
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: rpc_fwd.c,v 1.3 1994/06/13 20:47:58 mycroft Exp $
d295 1
a295 1
	dlog("Sending packet id %#x to %s.%d", p->rf_xid, inet_dquad(dq, fwdto->sin_addr.s_addr), ntohs(fwdto->sin_port));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
