head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.10
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.5.0.48
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.46
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.42
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.40
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.01.22.03.43.58;	author guenther;	state Exp;
branches;
next	1.8;
commitid	rWRB7wdvhHzZsMSB;

1.8
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.7;
commitid	RUbgWdu1CNTVPIOS;

1.7
date	2014.10.26.02.43.50;	author guenther;	state Exp;
branches;
next	1.6;
commitid	QMh02q5MFiw3np67;

1.6
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.5;
commitid	bZbpWDoZDVt0RPe1;

1.5
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.18.00.50.23;	author pvalchev;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@amd's nfs_prot.x file has some tweaks from the standard; automate them with ed.
Regenerate the amd's NFS RPC stubs with a current rpcgen, automating the
  post-generation tweaks to the svc stubs.  However, do follow the modern
  naming style where the svc stubs have a _svc suffix.
As a side benefit, this eliminates the need to #include <nfs/nfsproto.h>
This is all a prelude to updating amd to talk NFSv3 with the kernel for
  its own "toplvl" mounts, to squash another y2038 issue.
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)nfs_subr.c	8.1 (Berkeley) 6/6/93
 *	$Id: nfs_subr.c,v 1.8 2014/10/26 03:28:41 guenther Exp $
 */

#include "am.h"

/*
 * Convert from UN*X to NFS error code
 */
#ifdef NFS_ERROR_MAPPING
NFS_ERROR_MAPPING
#define nfs_error(e) \
        ((nfsstat)((e) > NFS_LOMAP && (e) < NFS_HIMAP ? \
        nfs_errormap[(e) - NFS_LOMAP] : (e)))
#else
#define nfs_error(e) ((nfsstat)(e))
#endif /* NFS_ERROR_MAPPING */

static char *
do_readlink(am_node *mp, int *error_return, struct attrstat **attrpp)
{
	char *ln;

	/*
	 * If there is a readlink method, then use
	 * that, otherwise if a link exists use
	 * that, otherwise use the mount point.
	 */
	if (mp->am_mnt->mf_ops->readlink) {
		int retry = 0;
		mp = (*mp->am_mnt->mf_ops->readlink)(mp, &retry);
		if (mp == 0) {
			*error_return = retry;
			return 0;
		}
		/*reschedule_timeout_mp();*/
	}
	if (mp->am_link) {
		ln = mp->am_link;
	} else {
		ln = mp->am_mnt->mf_mount;
	}
	if (attrpp)
		*attrpp = &mp->am_attr;
	return ln;
}

void *
nfsproc_null_2_svc(void *argp, struct svc_req *rqstp)
{
	static char res;

	return &res;
}


struct attrstat *
nfsproc_getattr_2_svc(struct nfs_fh *argp, struct svc_req *rqstp)
{
	static struct attrstat res;
	am_node *mp;
	int retry;

#ifdef DEBUG
	Debug(D_TRACE)
		plog(XLOG_DEBUG, "gettattr:");
#endif /* DEBUG */

	mp = fh_to_mp2(argp, &retry);
	if (mp == 0) {
getattr_retry:

		if (retry < 0)
			return 0;
		res.status = nfs_error(retry);
	} else {
		struct attrstat *attrp = &mp->am_attr;
		if (mp->am_fattr.type == NFLNK) {
			/*
			 * Make sure we can read the link,
			 * and then determine the length.
			 */
			char *ln = do_readlink(mp, &retry, &attrp);
			if (ln == 0)
				goto getattr_retry;
		}
#ifdef DEBUG
		Debug(D_TRACE)
			plog(XLOG_DEBUG, "\tstat(%s), size = %d", mp->am_path, attrp->attrstat_u.attributes.size);
#endif /* DEBUG */
		mp->am_stats.s_getattr++;
		return attrp;
	}

	return &res;
}


struct attrstat *
nfsproc_setattr_2_svc(struct sattrargs *argp, struct svc_req *rqstp)
{
	static struct attrstat res;

	if (!fh_to_mp(&argp->file))
		res.status = nfs_error(ESTALE);
	else
		res.status = nfs_error(EROFS);

	return &res;
}


void *
nfsproc_root_2_svc(void *argp, struct svc_req *rqstp)
{
	static char res;

	return &res;
}


struct diropres *
nfsproc_lookup_2_svc(struct diropargs *argp, struct svc_req *rqstp)
{
	static struct diropres res;
	am_node *mp;
	int retry;

#ifdef DEBUG
	Debug(D_TRACE)
		plog(XLOG_DEBUG, "lookup:");
#endif /* DEBUG */

	mp = fh_to_mp2(&argp->dir, &retry);
	if (mp == 0) {
		if (retry < 0)
			return 0;
		res.status = nfs_error(retry);
	} else {
		int error;
		am_node *ap;
#ifdef DEBUG
		Debug(D_TRACE)
			plog(XLOG_DEBUG, "\tlookuppn(%s, %s)", mp->am_path, argp->name);
#endif /* DEBUG */
		ap = (*mp->am_mnt->mf_ops->lookuppn)(mp, argp->name, &error, VLOOK_CREATE);
		if (ap == 0) {
			if (error < 0) {
#ifdef DEBUG
				dlog("Not sending RPC reply");
#endif /* DEBUG */
				amd_stats.d_drops++;
				return 0;
			}
			res.status = nfs_error(error);
		} else {
			mp_to_fh(ap, &res.diropres_u.diropres.file);
			res.diropres_u.diropres.attributes = ap->am_fattr;
			res.status = NFS_OK;
		}
		mp->am_stats.s_lookup++;
		/*reschedule_timeout_mp();*/
	}

	return &res;
}


struct readlinkres *
nfsproc_readlink_2_svc(struct nfs_fh *argp, struct svc_req *rqstp)
{
	static struct readlinkres res;
	am_node *mp;
	int retry;

#ifdef DEBUG
	Debug(D_TRACE)
		plog(XLOG_DEBUG, "readlink:");
#endif /* DEBUG */

	mp = fh_to_mp2(argp, &retry);
	if (mp == 0) {
readlink_retry:
		if (retry < 0)
			return 0;
		res.status = nfs_error(retry);
	} else {
		char *ln = do_readlink(mp, &retry, (struct attrstat **) 0);
		if (ln == 0)
			goto readlink_retry;
		res.status = NFS_OK;
#ifdef DEBUG
		Debug(D_TRACE)
			if (ln)
				plog(XLOG_DEBUG, "\treadlink(%s) = %s", mp->am_path, ln);
#endif /* DEBUG */
		res.readlinkres_u.data = ln;
		mp->am_stats.s_readlink++;
	}

	return &res;
}


struct readres *
nfsproc_read_2_svc(struct readargs *argp, struct svc_req *rqstp)
{
	static struct readres res;

	bzero(&res, sizeof(res));

	res.status = nfs_error(EACCES);

	return &res;
}


void *
nfsproc_writecache_2_svc(void *argp, struct svc_req *rqstp)
{
	static char res;

	return &res;
}


struct attrstat *
nfsproc_write_2_svc(writeargs *argp, struct svc_req *rqstp)
{
	static struct attrstat res;

	if (!fh_to_mp(&argp->file))
		res.status = nfs_error(ESTALE);
	else
		res.status = nfs_error(EROFS);

	return &res;
}


struct diropres *
nfsproc_create_2_svc(createargs *argp, struct svc_req *rqstp)
{
	static struct diropres res;

	if (!fh_to_mp(&argp->where.dir))
		res.status = nfs_error(ESTALE);
	else
		res.status = nfs_error(EROFS);

	return &res;
}


static nfsstat *
unlink_or_rmdir(struct diropargs *argp, struct svc_req *rqstp,
    int unlinkp)
{
	static nfsstat res;
	int retry;
	/*mntfs *mf;*/
	am_node *mp = fh_to_mp3(&argp->dir, &retry, VLOOK_DELETE);

	if (mp == 0) {
		if (retry < 0)
			return 0;
		res = nfs_error(retry);
		goto out;
	}
	/*mf = mp->am_mnt;*/
	if (mp->am_fattr.type != NFDIR) {
		res = nfs_error(ENOTDIR);
		goto out;
	}
#ifdef DEBUG
	Debug(D_TRACE)
		plog(XLOG_DEBUG, "\tremove(%s, %s)", mp->am_path, argp->name);
#endif /* DEBUG */
	mp = (*mp->am_mnt->mf_ops->lookuppn)(mp, argp->name, &retry, VLOOK_DELETE);
	if (mp == 0) {
		/*
		 * Ignore retries...
		 */
		if (retry < 0)
			retry = 0;
		/*
		 * Usual NFS workaround...
		 */
		else if (retry == ENOENT)
			retry = 0;
		res = nfs_error(retry);
	} else {
		forcibly_timeout_mp(mp);
		res = NFS_OK;
	}

out:
	return &res;
}


nfsstat *
nfsproc_remove_2_svc(struct diropargs *argp, struct svc_req *rqstp)
{
	return unlink_or_rmdir(argp, rqstp, TRUE);
}

nfsstat *
nfsproc_rename_2_svc(renameargs *argp, struct svc_req *rqstp)
{
	static nfsstat res;
	if (!fh_to_mp(&argp->from.dir) || !fh_to_mp(&argp->to.dir))
		res = nfs_error(ESTALE);
	/*
	 * If the kernel is doing clever things with referenced files
	 * then let it pretend...
	 */
	else if (strncmp(argp->to.name, ".nfs", 4) == 0)
		res = NFS_OK;
	/*
	 * otherwise a failure
	 */
	else
		res = nfs_error(EROFS);
	return &res;
}


nfsstat *
nfsproc_link_2_svc(linkargs *argp, struct svc_req *rqstp)
{
	static nfsstat res;
	if (!fh_to_mp(&argp->from) || !fh_to_mp(&argp->to.dir))
		res = nfs_error(ESTALE);
	else
		res = nfs_error(EROFS);

	return &res;
}


nfsstat *
nfsproc_symlink_2_svc(symlinkargs *argp, struct svc_req *rqstp)
{
	static nfsstat res;
	if (!fh_to_mp(&argp->from.dir))
		res = nfs_error(ESTALE);
	else
		res = nfs_error(EROFS);

	return &res;
}


struct diropres *
nfsproc_mkdir_2_svc(createargs *argp, struct svc_req *rqstp)
{
	static struct diropres res;
	if (!fh_to_mp(&argp->where.dir))
		res.status = nfs_error(ESTALE);
	else
		res.status = nfs_error(EROFS);

	return &res;
}


nfsstat *
nfsproc_rmdir_2_svc(struct diropargs *argp, struct svc_req *rqstp)
{
	return unlink_or_rmdir(argp, rqstp, FALSE);
}


struct readdirres *
nfsproc_readdir_2_svc(readdirargs *argp, struct svc_req *rqstp)
{
	static readdirres res;
	static entry e_res[MAX_READDIR_ENTRIES];
	am_node *mp;
	int retry;

#ifdef DEBUG
	Debug(D_TRACE)
		plog(XLOG_DEBUG, "readdir:");
#endif /* DEBUG */

	mp = fh_to_mp2(&argp->dir, &retry);
	if (mp == 0) {
		if (retry < 0)
			return 0;
		res.status = nfs_error(retry);
	} else {
#ifdef DEBUG
		Debug(D_TRACE)
			plog(XLOG_DEBUG, "\treaddir(%s)", mp->am_path);
#endif /* DEBUG */
		res.status = nfs_error((*mp->am_mnt->mf_ops->readdir)(mp, argp->cookie,
					&res.readdirres_u.reply, e_res, argp->count));
		mp->am_stats.s_readdir++;
	}

	return &res;
}

struct statfsres *
nfsproc_statfs_2_svc(struct nfs_fh *argp, struct svc_req *rqstp)
{
	static statfsres res;
	am_node *mp;
	int retry;

#ifdef DEBUG
	Debug(D_TRACE)
		plog(XLOG_DEBUG, "statfs:");
#endif /* DEBUG */

	mp = fh_to_mp2(argp, &retry);
	if (mp == 0) {
		if (retry < 0)
			return 0;
		res.status = nfs_error(retry);
	} else {
		statfsokres *fp;
#ifdef DEBUG
		Debug(D_TRACE)
			plog(XLOG_DEBUG, "\tstat_fs(%s)", mp->am_path);
#endif /* DEBUG */
		/*
		 * just return faked up file system information
		 */

		fp = &res.statfsres_u.reply;

		fp->tsize = 1024;
		fp->bsize = 4096;
		fp->blocks = 0;
		fp->bfree = 0;
		fp->bavail = 0;

		res.status = NFS_OK;
		mp->am_stats.s_statfs++;
	}

	return &res;
}
@


1.8
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d35 1
a35 1
 *	$Id: nfs_subr.c,v 1.7 2014/10/26 02:43:50 guenther Exp $
d82 1
a82 1
nfsproc_null_2(void *argp, struct svc_req *rqstp)
d91 1
a91 1
nfsproc_getattr_2(struct nfs_fh *argp, struct svc_req *rqstp)
d133 1
a133 1
nfsproc_setattr_2(struct sattrargs *argp, struct svc_req *rqstp)
d147 1
a147 1
nfsproc_root_2(void *argp, struct svc_req *rqstp)
d156 1
a156 1
nfsproc_lookup_2(struct diropargs *argp, struct svc_req *rqstp)
d203 1
a203 1
nfsproc_readlink_2(struct nfs_fh *argp, struct svc_req *rqstp)
d239 1
a239 1
nfsproc_read_2(struct readargs *argp, struct svc_req *rqstp)
d252 1
a252 1
nfsproc_writecache_2(void *argp, struct svc_req *rqstp)
d261 1
a261 1
nfsproc_write_2(writeargs *argp, struct svc_req *rqstp)
d275 1
a275 1
nfsproc_create_2(createargs *argp, struct svc_req *rqstp)
d336 1
a336 1
nfsproc_remove_2(struct diropargs *argp, struct svc_req *rqstp)
d342 1
a342 1
nfsproc_rename_2(renameargs *argp, struct svc_req *rqstp)
d363 1
a363 1
nfsproc_link_2(linkargs *argp, struct svc_req *rqstp)
d376 1
a376 1
nfsproc_symlink_2(symlinkargs *argp, struct svc_req *rqstp)
d389 1
a389 1
nfsproc_mkdir_2(createargs *argp, struct svc_req *rqstp)
d402 1
a402 1
nfsproc_rmdir_2(struct diropargs *argp, struct svc_req *rqstp)
d409 1
a409 1
nfsproc_readdir_2(readdirargs *argp, struct svc_req *rqstp)
d440 1
a440 1
nfsproc_statfs_2(struct nfs_fh *argp, struct svc_req *rqstp)
@


1.7
log
@Lint is dead
@
text
@d35 1
a35 1
 *	$Id: nfs_subr.c,v 1.6 2014/10/20 02:33:42 guenther Exp $
d86 1
a86 1
	return (void *)&res;
d151 1
a151 1
	return (void *)&res;
d243 1
a243 1
	bzero((char *)&res, sizeof(res));
d256 1
a256 1
	return (void *)&res;
@


1.6
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: nfs_subr.c,v 1.5 2003/06/02 23:36:51 millert Exp $
a80 1
/*ARGSUSED*/
a89 1
/*ARGSUSED*/
a131 1
/*ARGSUSED*/
a145 1
/*ARGSUSED*/
a154 1
/*ARGSUSED*/
a201 1
/*ARGSUSED*/
a237 1
/*ARGSUSED*/
a250 1
/*ARGSUSED*/
a259 1
/*ARGSUSED*/
a273 1
/*ARGSUSED*/
a287 1
/*ARGSUSED*/
a334 1
/*ARGSUSED*/
a340 1
/*ARGSUSED*/
a361 1
/*ARGSUSED*/
a374 1
/*ARGSUSED*/
a387 1
/*ARGSUSED*/
a400 1
/*ARGSUSED*/
a407 1
/*ARGSUSED*/
a438 1
/*ARGSUSED*/
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: nfs_subr.c,v 1.4 2002/08/05 07:24:26 pvalchev Exp $
a105 1
#ifdef PRECISE_SYMLINKS
a106 1
#endif /* PRECISE_SYMLINKS */
a112 1
#ifdef PRECISE_SYMLINKS
a121 1
#endif /* PRECISE_SYMLINKS */
a488 1
#ifdef HAS_EMPTY_AUTOMOUNTS
a489 3
#else
		fp->blocks = 1;
#endif
@


1.4
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: nfs_subr.c,v 1.3 2002/08/03 08:29:31 pvalchev Exp $
@


1.3
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: nfs_subr.c,v 1.2 2002/07/18 00:50:23 pvalchev Exp $
d86 2
a87 2
voidp
nfsproc_null_2(voidp argp, struct svc_req *rqstp)
d91 1
a91 1
	return (voidp) &res;
d158 2
a159 2
voidp
nfsproc_root_2(voidp argp, struct svc_req *rqstp)
d163 1
a163 1
	return (voidp)&res;
d267 2
a268 2
voidp
nfsproc_writecache_2(voidp argp, struct svc_req *rqstp)
d272 1
a272 1
	return (voidp) &res;
@


1.2
log
@ANSIfy; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: nfs_subr.c,v 1.1.1.1 1995/10/18 08:47:11 deraadt Exp $
d56 2
a57 1
static char *do_readlink(am_node *mp, int *error_return, struct attrstat **attrpp)
d86 2
a87 1
voidp nfsproc_null_2(voidp argp, struct svc_req *rqstp)
d96 2
a97 2
struct attrstat *nfsproc_getattr_2(struct nfs_fh *argp,
	struct svc_req *rqstp)
d143 2
a144 2
struct attrstat *nfsproc_setattr_2(struct sattrargs *argp,
	struct svc_req *rqstp)
d158 2
a159 1
voidp nfsproc_root_2(voidp argp, struct svc_req *rqstp)
d168 2
a169 2
struct diropres *nfsproc_lookup_2(struct diropargs *argp,
	struct svc_req *rqstp)
d216 2
a217 2
struct readlinkres *nfsproc_readlink_2(struct nfs_fh *argp,
	struct svc_req *rqstp)
d253 2
a254 2
struct readres *nfsproc_read_2(struct readargs *argp,
	struct svc_req *rqstp)
d267 2
a268 1
voidp nfsproc_writecache_2(voidp argp, struct svc_req *rqstp)
d277 2
a278 2
struct attrstat *nfsproc_write_2(writeargs *argp,
	struct svc_req *rqstp)
d292 2
a293 2
struct diropres *nfsproc_create_2(createargs *argp,
	struct svc_req *rqstp)
d307 3
a309 2
static nfsstat *unlink_or_rmdir(struct diropargs *argp,
	struct svc_req *rqstp, int unlinkp)
d315 1
d355 2
a356 1
nfsstat *nfsproc_remove_2(struct diropargs *argp, struct svc_req *rqstp)
d362 2
a363 1
nfsstat *nfsproc_rename_2(renameargs *argp, struct svc_req *rqstp)
d384 2
a385 1
nfsstat *nfsproc_link_2(linkargs *argp, struct svc_req *rqstp)
d398 2
a399 1
nfsstat *nfsproc_symlink_2(symlinkargs *argp, struct svc_req *rqstp)
d412 2
a413 1
struct diropres *nfsproc_mkdir_2(createargs *argp, struct svc_req *rqstp)
d426 2
a427 1
nfsstat *nfsproc_rmdir_2(struct diropargs *argp, struct svc_req *rqstp)
d434 2
a435 2
struct readdirres *nfsproc_readdir_2(readdirargs *argp,
	struct svc_req *rqstp)
d466 2
a467 2
struct statfsres *nfsproc_statfs_2(struct nfs_fh *argp,
	struct svc_req *rqstp)
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: nfs_subr.c,v 1.3 1994/06/13 20:47:47 mycroft Exp $
d56 1
a56 5
static char *do_readlink P((am_node *mp, int *error_return, struct attrstat **attrpp));
static char *do_readlink(mp, error_return, attrpp)
am_node *mp;
int *error_return;
struct attrstat **attrpp;
d85 1
a85 4
voidp 
nfsproc_null_2(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d94 2
a95 4
struct attrstat *
nfsproc_getattr_2(argp, rqstp)
struct nfs_fh *argp;
struct svc_req *rqstp;
d141 2
a142 4
struct attrstat *
nfsproc_setattr_2(argp, rqstp)
struct sattrargs *argp;
struct svc_req *rqstp;
d156 1
a156 4
voidp 
nfsproc_root_2(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d165 2
a166 4
struct diropres *
nfsproc_lookup_2(argp, rqstp)
struct diropargs *argp;
struct svc_req *rqstp;
d213 2
a214 4
struct readlinkres *
nfsproc_readlink_2(argp, rqstp)
struct nfs_fh *argp;
struct svc_req *rqstp;
d250 2
a251 4
struct readres *
nfsproc_read_2(argp, rqstp)
struct readargs *argp;
struct svc_req *rqstp;
d264 1
a264 4
voidp 
nfsproc_writecache_2(argp, rqstp)
voidp argp;
struct svc_req *rqstp;
d273 2
a274 4
struct attrstat *
nfsproc_write_2(argp, rqstp)
writeargs *argp;
struct svc_req *rqstp;
d288 2
a289 4
struct diropres *
nfsproc_create_2(argp, rqstp)
createargs *argp;
struct svc_req *rqstp;
d303 2
a304 5
static nfsstat *
unlink_or_rmdir(argp, rqstp, unlinkp)
struct diropargs *argp;
struct svc_req *rqstp;
int unlinkp;
d349 1
a349 4
nfsstat *
nfsproc_remove_2(argp, rqstp)
struct diropargs *argp;
struct svc_req *rqstp;
d355 1
a355 4
nfsstat *
nfsproc_rename_2(argp, rqstp)
renameargs *argp;
struct svc_req *rqstp;
d376 1
a376 4
nfsstat *
nfsproc_link_2(argp, rqstp)
linkargs *argp;
struct svc_req *rqstp;
d389 1
a389 4
nfsstat *
nfsproc_symlink_2(argp, rqstp)
symlinkargs *argp;
struct svc_req *rqstp;
d402 1
a402 4
struct diropres *
nfsproc_mkdir_2(argp, rqstp)
createargs *argp;
struct svc_req *rqstp;
d415 1
a415 4
nfsstat *
nfsproc_rmdir_2(argp, rqstp)
struct diropargs *argp;
struct svc_req *rqstp;
d422 2
a423 4
struct readdirres *
nfsproc_readdir_2(argp, rqstp)
readdirargs *argp;
struct svc_req *rqstp;
d454 2
a455 4
struct statfsres *
nfsproc_statfs_2(argp, rqstp)
struct nfs_fh *argp;
struct svc_req *rqstp;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
