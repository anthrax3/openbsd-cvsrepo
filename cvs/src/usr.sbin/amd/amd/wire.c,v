head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.48
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.46
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.42
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.40
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.38
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.36
	OPENBSD_5_0:1.12.0.34
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.32
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.30
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.26
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.28
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.24
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.22
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.20
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.18
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.16
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.14
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.10.24.10.29.56;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	NbQ5g9jHXLDVwqNb;

1.12
date	2003.06.17.18.00.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.02.06.22.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.22.17.29.04;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.21.02.03.18;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	98.03.20.03.04.00;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	98.03.20.02.58.19;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.01.31.14.42.03;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@retire networks(5) support;
OK deraadt@@
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)wire.c	8.1 (Berkeley) 6/6/93
 *	$Id: wire.c,v 1.12 2003/06/17 18:00:24 millert Exp $
 */

/*
 * This function returns the subnet (address&netmask) for the primary network
 * interface.  If the resulting address has an entry in the hosts file, the
 * corresponding name is retuned, otherwise the address is returned in
 * standard internet format.
 * As a side-effect, a list of local IP/net address is recorded for use
 * by the islocalnet() function.
 *
 * Derived from original by Paul Anderson (23/4/90)
 * Updates from Dirk Grunwald (11/11/91)
 * Modified to use getifaddrs() by Todd C. Miller (6/14/2003)
 */

#include "am.h"

#include <ifaddrs.h>
#include <netdb.h>
#include <net/if.h>

#define NO_SUBNET "notknown"

/*
 * List of locally connected networks
 */
typedef struct addrlist addrlist;
struct addrlist {
	addrlist *ip_next;
	in_addr_t ip_addr;
	in_addr_t ip_mask;
};
static addrlist *localnets = 0;

char *
getwire(void)
{
	struct ifaddrs *ifa, *ifaddrs;
	struct hostent *hp;
	addrlist *al;
	char *s, *netname = NULL;

	if (getifaddrs(&ifaddrs))
		return strdup(NO_SUBNET);

	for (ifa = ifaddrs; ifa != NULL; ifa = ifa -> ifa_next) {
		/*
		 * Ignore non-AF_INET interfaces as well as any that
		 * are down or loopback.
		 */
		if (ifa->ifa_addr == NULL ||
		    ifa->ifa_addr->sa_family != AF_INET ||
		    !(ifa->ifa_flags & IFF_UP) ||
		    (ifa->ifa_flags & IFF_LOOPBACK))
			continue;
		
		/*
		 * Add interface to local network list
		 */
		al = ALLOC(addrlist);
		al->ip_addr =
		    ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
		al->ip_mask =
		    ((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr.s_addr;
		al->ip_next = localnets;
		localnets = al;

		/*
		 * Look up the host name; fall back to a dotted quad.
		 */
		if (netname == NULL) {
			in_addr_t subnet;
			char dq[20];

			subnet = al->ip_addr & al->ip_mask;
			hp = gethostbyaddr((char *) &subnet, 4, AF_INET);
			if (hp)
				s = hp->h_name;
			else
				s = inet_dquad(dq, sizeof(dq), subnet);
			netname = strdup(s);
		}
	}
	freeifaddrs(ifaddrs);
	return (netname ? netname : strdup(NO_SUBNET));
}

/*
 * Determine whether a network is on a local network
 * (addr) is in network byte order.
 */
int
islocalnet(in_addr_t addr)
{
	addrlist *al;

	for (al = localnets; al; al = al->ip_next)
		if (((addr ^ al->ip_addr) & al->ip_mask) == 0)
			return TRUE;

#ifdef DEBUG
	{ char buf[16];
	plog(XLOG_INFO, "%s is on a remote network", inet_dquad(buf, sizeof(buf), addr));
	}
#endif
	return FALSE;
}
@


1.12
log
@Use getifaddrs() to get the list of interfaces.  This fixes the
"wire" variable which may be used in amd maps to select an NFS
server based on the subnet.  Tested by matthieu@@; OK by deraadt@@
@
text
@d35 1
a35 1
 *	$Id: wire.c,v 1.11 2003/06/02 23:36:51 millert Exp $
a74 1
	struct netent *np;
d103 3
a106 2
			in_addr_t net;
			in_addr_t mask;
a107 1
			in_addr_t subnetshift;
a109 3
			/*
			 * Figure out the subnet's network address
			 */
d111 5
a115 51

#ifdef IN_CLASSA
			subnet = ntohl(subnet);

			if (IN_CLASSA(subnet)) {
				mask = IN_CLASSA_NET;
				subnetshift = 8;
			} else if (IN_CLASSB(subnet)) {
				mask = IN_CLASSB_NET;
				subnetshift = 8;
			} else {
				mask = IN_CLASSC_NET;
				subnetshift = 4;
			}

			/*
			 * If there are more bits than the standard mask
			 * would suggest, subnets must be in use.
			 * Guess at the subnet mask, assuming reasonable
			 * width subnet fields.
			 * XXX: Or-in at least 1 byte's worth of 1s to make
			 * sure the top bits remain set.
			 */
			while (subnet &~ mask)
				mask = (mask >> subnetshift) | 0xff000000;

			net = subnet & mask;
			while ((mask & 1) == 0)
				mask >>= 1, net >>= 1;

			/*
			 * Now get a usable name.
			 * First use the network database,
			 * then the host database,
			 * and finally just make a dotted quad.
			 */
			np = getnetbyaddr(net, AF_INET);
#else
			/* This is probably very wrong. */
			np = getnetbyaddr(subnet, AF_INET);
#endif /* IN_CLASSA */
			if (np)
				s = np->n_name;
			else {
				subnet = al->ip_addr & al->ip_mask;
				hp = gethostbyaddr((char *) &subnet, 4, AF_INET);
				if (hp)
					s = hp->h_name;
				else
					s = inet_dquad(dq, sizeof(dq), subnet);
			}
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: wire.c,v 1.10 2002/08/03 08:29:31 pvalchev Exp $
d48 1
d53 3
a55 2
#include <unistd.h>
#include <sys/ioctl.h>
d65 2
a66 2
	u_int32_t ip_addr;
	u_int32_t ip_mask;
a69 15
#ifdef SIOCGIFFLAGS
#ifdef STELLIX
#include <sys/sema.h>
#endif /* STELLIX */
#include <net/if.h>
#include <netdb.h>

#if defined(IFF_LOCAL_LOOPBACK) && !defined(IFF_LOOPBACK)
#define IFF_LOOPBACK IFF_LOCAL_LOOPBACK
#endif

#define GFBUFLEN 1024
#define clist (ifc.ifc_ifcu.ifcu_req)
#define count (ifc.ifc_len/sizeof(struct ifreq))

d73 1
d76 2
a77 50
	struct ifconf ifc;
	struct ifreq *ifr, ifrpool;
	caddr_t cp, cplim;
	u_int32_t address, netmask, subnet;
	char buf[GFBUFLEN], *s;
	int sk = -1;
	char *netname = 0;

	/*
	 * Get suitable socket
	 */
	if ((sk = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		goto out;

	/*
	 * Fill in ifconf details
	 */
	ifc.ifc_len = sizeof buf;
	ifc.ifc_buf = buf;

	/*
	 * Get network interface configurations
	 */
	if (ioctl(sk, SIOCGIFCONF, (caddr_t) &ifc) < 0)
		goto out;

	/*
	 * Upper bound on array
	 */
	cplim = buf + ifc.ifc_len;

	/*
	 * This is some magic to cope with both "traditional" and the
	 * new 4.4BSD-style struct sockaddrs.  The new structure has
	 * variable length and a size field to support longer addresses.
	 * AF_LINK is a new definition for 4.4BSD.
	 */
#ifdef AF_LINK
#define max(a, b) ((a) > (b) ? (a) : (b))
#define size(ifr) (max((ifr)->ifr_addr.sa_len, sizeof((ifr)->ifr_addr)) + sizeof(ifr->ifr_name))
#else
#define size(ifr) sizeof(*ifr)
#endif
	/*
	 * Scan the list looking for a suitable interface
	 */
	for (cp = buf; cp < cplim; cp += size(ifr)) {
		addrlist *al;
		memcpy(&ifrpool, cp, sizeof(ifrpool));
		ifr = &ifrpool;
d79 2
a80 4
		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;
		else
			address = ((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr;
d82 1
d84 2
a85 1
		 * Get interface flags
d87 4
a90 1
		if (ioctl(sk, SIOCGIFFLAGS, (caddr_t) ifr) < 0)
d92 1
a92 19

		/*
		 * If the interface is a loopback, or its not running
		 * then ignore it.
		 */
		if ((ifr->ifr_flags & IFF_LOOPBACK) != 0)
			continue;
		if ((ifr->ifr_flags & IFF_RUNNING) == 0)
			continue;

		/*
		 * Get the netmask of this interface
		 */
		((struct sockaddr_in *)&ifr->ifr_addr)->sin_addr.s_addr = address;
		if (ioctl(sk, SIOCGIFNETMASK, (caddr_t) ifr) < 0)
			continue;

		netmask = ((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr;

d97 4
a100 2
		al->ip_addr = address;
		al->ip_mask = netmask;
d104 7
a110 4
		if (netname == 0) {
			u_int32_t net;
			u_int32_t mask;
			u_int32_t subnetshift;
d114 1
a114 1
			subnet = address & netmask;
a150 1

d159 1
a159 1
				subnet = address & netmask;
d164 1
a164 1
					s = inet_dquad(buf, sizeof(buf), subnet);
d169 2
a170 15

out:
	if (sk >= 0)
		(void) close(sk);
	if (netname)
		return netname;
	return strdup(NO_SUBNET);
}

#else

char *
getwire(void)
{
	return strdup(NO_SUBNET);
a171 1
#endif /* SIOCGIFFLAGS */
d178 1
a178 1
islocalnet(u_int32_t addr)
@


1.10
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: wire.c,v 1.9 2002/07/18 02:03:00 deraadt Exp $
@


1.9
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.8 2002/06/11 05:29:54 itojun Exp $
d87 2
a88 2
char *getwire P((void));
char *getwire()
d255 2
a256 2
char *getwire P((void));
char *getwire()
d266 2
a267 3
int islocalnet P((u_int32_t addr));
int islocalnet(addr)
u_int32_t addr;
@


1.8
log
@use snprintf.
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.7 2001/03/02 06:22:05 deraadt Exp $
d189 1
a189 1
		  
d191 1
a191 1
			subnet = ntohl(subnet); 
d247 1
a247 1
		(void) close(sk); 
@


1.7
log
@KNF
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.6 2000/02/22 17:29:04 itojun Exp $
d239 1
a239 1
					s = inet_dquad(buf, subnet);
d278 1
a278 1
	plog(XLOG_INFO, "%s is on a remote network", inet_dquad(buf, addr));
@


1.6
log
@sorry previous fix against alignment issue was totally broken.
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.5 2000/02/21 02:03:18 itojun Exp $
d56 1
@


1.5
log
@prevent align fault on alpha.
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.4 1998/03/20 03:04:00 angelos Exp $
d92 1
a92 1
	struct ifreq *ifr;
d139 2
a140 1
		memcpy(&ifr, cp, sizeof(ifr));
@


1.4
log
@Cleaner handling.
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.3 1998/03/20 02:58:19 angelos Exp $
d139 1
a139 1
		ifr = (struct ifreq *) cp;
@


1.3
log
@Be "aware" of ifaliases.
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.2 1997/01/31 14:42:03 graichen Exp $
a138 1
		struct sockaddr_in sintmp;
a145 2
		sintmp.sin_addr.s_addr = address;

d164 1
a164 1
		memcpy(&ifr->ifr_addr, &sintmp, sizeof(sintmp));
@


1.2
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.1.1.1 1995/10/18 08:47:12 deraadt Exp $
d139 1
d147 2
d167 1
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: wire.c,v 1.3 1994/06/13 20:48:11 mycroft Exp $
d66 2
a67 2
	unsigned long ip_addr;
	unsigned long ip_mask;
d94 1
a94 1
	unsigned long address, netmask, subnet;
d179 3
a181 3
			unsigned long net;
			unsigned long mask;
			unsigned long subnetshift;
d263 1
a263 1
int islocalnet P((unsigned long addr));
d265 1
a265 1
unsigned long addr;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

