head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.42
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.40
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.38
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.36
	OPENBSD_5_0:1.11.0.34
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.32
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.30
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.26
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.12.20.06.42;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	UYpZcqSFaggVdA2d;

1.15
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.14;
commitid	RUbgWdu1CNTVPIOS;

1.14
date	2014.10.26.01.16.48;	author guenther;	state Exp;
branches;
next	1.13;
commitid	Qcgfc5DGBBARLngk;

1.13
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.12;
commitid	bZbpWDoZDVt0RPe1;

1.12
date	2013.12.03.02.14.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.13.22.08.02;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.26.02.49.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.02.06.22.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.31.14.42.02;	author graichen;	state Exp;
branches;
next	1.2;

1.2
date	96.08.10.21.39.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.12;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove the rest of the 20+ year-old memory debugging gunk. Discussed
with deraadt@@
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)util.c	8.1 (Berkeley) 6/6/93
 *	$Id: util.c,v 1.15 2014/10/26 03:28:41 guenther Exp $
 */

/*
 * Utils
 */

#include "am.h"
#include <ctype.h>
#include <unistd.h>
#include <sys/stat.h>
#include <netdb.h>


char *
strnsave(const char *str, int len)
{
	char *sp = xmalloc(len+1);

	bcopy(str, sp, len);
	sp[len] = 0;

	return sp;
}

/*
 * Concatenate three strings and store in buffer pointed to
 * by p, making p large enough to hold the strings
 */
char *
str3cat(char *p, char *s1, char *s2, char *s3)
{
	size_t l1 = strlen(s1);
	size_t l2 = strlen(s2);
	size_t l3 = strlen(s3);

	if (l1 > SIZE_MAX - l2 || l1 + l2 > SIZE_MAX - l3)
		 xmallocfailure();
	p = xreallocarray(p, l1 + l2 + l3 + 1, 1);
	bcopy(s1, p, l1);
	bcopy(s2, p + l1, l2);
	bcopy(s3, p + l1 + l2, l3 + 1);
	return p;
}

char *
strealloc(char *p, char *s)
{
	size_t len = strlen(s) + 1;

	if (len > SIZE_MAX - 1)
		 xmallocfailure();
	p = xreallocarray(p, len, 1);

	strlcpy(p, s, len);
	return p;
}

char **
strsplit(char *s, int ch, int qc)
{
	char **ivec;
	int ic = 0;
	int done = 0;

	ivec = xreallocarray(NULL, ic + 1, sizeof *ivec);

	while (!done) {
		char *v;
		/*
		 * skip to split char
		 */
		while (*s && (ch == ' ' ?
		    (isascii((unsigned char)*s) && isspace((unsigned char)*s)) :
		    *s == ch))
				*s++ = '\0';

		/*
		 * End of string?
		 */
		if (!*s)
			break;

		/*
		 * remember start of string
		 */
		v = s;

		/*
		 * skip to split char
		 */
		while (*s && !(ch == ' ' ?
		    (isascii((unsigned char)*s) && isspace((unsigned char)*s)) :
		    *s == ch)) {
			if (*s++ == qc) {
				/*
				 * Skip past string.
				 */
				s++;
				while (*s && *s != qc)
					s++;
				if (*s == qc)
					s++;
			}
		}

		if (!*s)
			done = 1;
		*s++ = '\0';

		/*
		 * save string in new ivec slot
		 */
		ivec[ic++] = v;
		ivec = xreallocarray(ivec, ic + 1, sizeof *ivec);
#ifdef DEBUG
		Debug(D_STR)
			plog(XLOG_DEBUG, "strsplit saved \"%s\"", v);
#endif /* DEBUG */
	}

#ifdef DEBUG
	Debug(D_STR)
		plog(XLOG_DEBUG, "strsplit saved a total of %d strings", ic);
#endif /* DEBUG */

	ivec[ic] = 0;

	return ivec;
}

/*
 * Strip off the trailing part of a domain
 * to produce a short-form domain relative
 * to the local host domain.
 * Note that this has no effect if the domain
 * names do not have the same number of
 * components.  If that restriction proves
 * to be a problem then the loop needs recoding
 * to skip from right to left and do partial
 * matches along the way -- ie more expensive.
 */
static void
domain_strip(char *otherdom, char *localdom)
{
#ifdef PARTIAL_DOMAINS
        char *p1 = otherdom-1;
	char *p2 = localdom-1;

        do {
                if (p1 = strchr(p1+1, '.'))
                if (p2 = strchr(p2+1, '.'))
                if (strcmp(p1+1, p2+1) == 0) {
                        *p1 = '\0';
                        break;
                }
        } while (p1 && p2);
#else
	char *p1, *p2;

	if ((p1 = strchr(otherdom, '.')) &&
			(p2 = strchr(localdom, '.')) &&
			(strcmp(p1+1, p2+1) == 0))
		*p1 = '\0';
#endif /* PARTIAL_DOMAINS */
}

/*
 * Normalize a host name
 */
void
host_normalize(char **chp)
{
	/*
	 * Normalize hosts is used to resolve host name aliases
	 * and replace them with the standard-form name.
	 * Invoked with "-n" command line option.
	 */
	if (normalize_hosts) {
		struct hostent *hp;
		clock_valid = 0;
		hp = gethostbyname(*chp);
		if (hp && hp->h_addrtype == AF_INET) {
#ifdef DEBUG
			dlog("Hostname %s normalized to %s", *chp, hp->h_name);
#endif /* DEBUG */
			*chp = strealloc(*chp, hp->h_name);
		}
	}
	domain_strip(*chp, hostd);
}

/*
 * Make a dotted quad from a 32bit IP address
 * addr is in network byte order.
 * sizeof(buf) needs to be at least 16.
 */
char *
inet_dquad(char *buf, size_t buflen, u_int32_t addr)
{
	addr = ntohl(addr);
	snprintf(buf, buflen, "%d.%d.%d.%d",
		((addr >> 24) & 0xff),
		((addr >> 16) & 0xff),
		((addr >> 8) & 0xff),
		((addr >> 0) & 0xff));
	return buf;
}

/*
 * Keys are not allowed to contain " ' ! or ; to avoid
 * problems with macro expansions.
 */
static char invalid_keys[] = "\"'!;@@ \t\n";
int
valid_key(char *key)
{
	while (*key)
		if (strchr(invalid_keys, *key++))
			return FALSE;
	return TRUE;
}

void
going_down(int rc)
{
	if (foreground) {
		if (amd_state != Start) {
			if (amd_state != Done)
				return;
			unregister_amq();
		}
	}
	if (foreground) {
		plog(XLOG_INFO, "Finishing with status %d", rc);
	} else {
#ifdef DEBUG
		dlog("background process exiting with status %d", rc);
#endif /* DEBUG */
	}

	exit(rc);
}


int
bind_resv_port(int so, u_short *pp)
{
	struct sockaddr_in sin;
	int rc;

	bzero(&sin, sizeof(sin));
	sin.sin_family = AF_INET;

	rc = bindresvport(so, &sin);
	if (pp && rc == 0)
		*pp = ntohs(sin.sin_port);
	return rc;
}

void
forcibly_timeout_mp(am_node *mp)
{
	mntfs *mf = mp->am_mnt;
	/*
	 * Arrange to timeout this node
	 */
	if (mf && ((mp->am_flags & AMF_ROOT) ||
		(mf->mf_flags & (MFF_MOUNTING|MFF_UNMOUNTING)))) {
		if (!(mf->mf_flags & MFF_UNMOUNTING))
			plog(XLOG_WARNING, "ignoring timeout request for active node %s", mp->am_path);
	} else {
		plog(XLOG_INFO, "\"%s\" forcibly timed out", mp->am_path);
		mp->am_flags &= ~AMF_NOTIMEOUT;
		mp->am_ttl = clocktime();
		reschedule_timeout_mp();
	}
}

void
mf_mounted(mntfs *mf)
{
	int quoted;
	int wasmounted = mf->mf_flags & MFF_MOUNTED;

	if (!wasmounted) {
		/*
		 * If this is a freshly mounted
		 * filesystem then update the
		 * mntfs structure...
		 */
		mf->mf_flags |= MFF_MOUNTED;
		mf->mf_error = 0;

		/*
		 * Do mounted callback
		 */
		if (mf->mf_ops->mounted)
			(*mf->mf_ops->mounted)(mf);

		mf->mf_fo = 0;
	}

	/*
	 * Log message
	 */
	quoted = strchr(mf->mf_info, ' ') != 0;
	plog(XLOG_INFO, "%s%s%s %s fstype %s on %s",
		quoted ? "\"" : "",
		mf->mf_info,
		quoted ? "\"" : "",
		wasmounted ? "referenced" : "mounted",
		mf->mf_ops->fs_type, mf->mf_mount);
}

void
am_mounted(am_node *mp)
{
	mntfs *mf = mp->am_mnt;

	mf_mounted(mf);

	/*
	 * Patch up path for direct mounts
	 */
	if (mp->am_parent && mp->am_parent->am_mnt->mf_ops == &dfs_ops)
		mp->am_path = str3cat(mp->am_path, mp->am_parent->am_path, "/", ".");

	/*
	 * Check whether this mount should be cached permanently
	 */
	if (mf->mf_ops->fs_flags & FS_NOTIMEOUT) {
		mp->am_flags |= AMF_NOTIMEOUT;
	} else if (mf->mf_mount[1] == '\0' && mf->mf_mount[0] == '/') {
		mp->am_flags |= AMF_NOTIMEOUT;
	} else {
		struct mntent mnt;
		if (mf->mf_mopts) {
			mnt.mnt_opts = mf->mf_mopts;
			if (hasmntopt(&mnt, "nounmount"))
				mp->am_flags |= AMF_NOTIMEOUT;
			if ((mp->am_timeo = hasmntval(&mnt, "utimeout")) == 0)
				mp->am_timeo = am_timeo;
		}
	}

	/*
	 * If this node is a symlink then
	 * compute the length of the returned string.
	 */
	if (mp->am_fattr.type == NFLNK)
		mp->am_fattr.size = strlen(mp->am_link ? mp->am_link : mp->am_mnt->mf_mount);

	/*
	 * Record mount time
	 */
	mp->am_fattr.mtime.seconds = mp->am_stats.s_mtime = clocktime();
	new_ttl(mp);
	/*
	 * Update mtime of parent node
	 */
	if (mp->am_parent && mp->am_parent->am_mnt)
		mp->am_parent->am_fattr.mtime.seconds = mp->am_stats.s_mtime;


	/*
	 * Update stats
	 */
	amd_stats.d_mok++;
}

int
mount_node(am_node *mp)
{
	mntfs *mf = mp->am_mnt;
	int error;

	mf->mf_flags |= MFF_MOUNTING;
	error = (*mf->mf_ops->mount_fs)(mp);
	mf = mp->am_mnt;
	if (error >= 0)
		mf->mf_flags &= ~MFF_MOUNTING;
	if (!error && !(mf->mf_ops->fs_flags & FS_MBACKGROUND)) {
		/* ...but see ifs_mount */
		am_mounted(mp);
	}

	return error;
}

void
am_unmounted(am_node *mp)
{
	mntfs *mf = mp->am_mnt;

	if (!foreground) /* firewall - should never happen */
		return;

#ifdef DEBUG
	/*dlog("in am_unmounted(), foreground = %d", foreground);*/
#endif /* DEBUG */

	/*
	 * Do unmounted callback
	 */
	if (mf->mf_ops->umounted)
		(*mf->mf_ops->umounted)(mp);

	/*
	 * Update mtime of parent node
	 */
	if (mp->am_parent && mp->am_parent->am_mnt)
		mp->am_parent->am_fattr.mtime.seconds = clocktime();

	free_map(mp);
}

int
auto_fmount(am_node *mp)
{
	mntfs *mf = mp->am_mnt;
	return (*mf->mf_ops->fmount_fs)(mf);
}

int
auto_fumount(am_node *mp)
{
	mntfs *mf = mp->am_mnt;
	return (*mf->mf_ops->fumount_fs)(mf);
}

/*
 * Fork the automounter
 *
 * TODO: Need a better strategy for handling errors
 */
static pid_t
dofork(void)
{
	pid_t pid;
top:
	pid = fork();

	if (pid < 0) {
		sleep(1);
		goto top;
	}

	if (pid == 0) {
		mypid = getpid();
		foreground = 0;
	}

	return pid;
}

pid_t
background(void)
{
	pid_t pid = dofork();
	if (pid == 0) {
#ifdef DEBUG
		dlog("backgrounded");
#endif
		foreground = 0;
	}

	return pid;
}

/*
 * Make all the directories in the path.
 */
int
mkdirs(char *path, int mode)
{
	/*
	 * take a copy in case path is in readonly store
	 */
	char *p2 = strdup(path);
	char *sp = p2;
	struct stat stb;
	int error_so_far = 0;

	/*
	 * Skip through the string make the directories.
	 * Mostly ignore errors - the result is tested at the end.
	 *
	 * This assumes we are root so that we can do mkdir in a
	 * mode 555 directory...
	 */
	while ((sp = strchr(sp+1, '/'))) {
		*sp = '\0';
		if (mkdir(p2, mode) < 0) {
			error_so_far = errno;
		} else {
#ifdef DEBUG
			dlog("mkdir(%s)", p2);
#endif
		}
		*sp = '/';
	}

	if (mkdir(p2, mode) < 0) {
		error_so_far = errno;
	} else {
#ifdef DEBUG
		dlog("mkdir(%s)", p2);
#endif
	}


	free(p2);

	return stat(path, &stb) == 0 &&
		(stb.st_mode & S_IFMT) == S_IFDIR ? 0 : error_so_far;
}

/*
 * Remove as many directories in the path as possible.
 * Give up if the directory doesn't appear to have
 * been created by Amd (not mode dr-x) or an rmdir
 * fails for any reason.
 */
void
rmdirs(char *dir)
{
	char *xdp = strdup(dir);
	char *dp;

	do {
		struct stat stb;
		/*
		 * Try to find out whether this was
		 * created by amd.  Do this by checking
		 * for owner write permission.
		 */
		if (stat(xdp, &stb) == 0 && (stb.st_mode & 0200) == 0) {
			if (rmdir(xdp) < 0) {
				if (errno != ENOTEMPTY &&
				    errno != EBUSY &&
				    errno != EEXIST &&
				    errno != EINVAL)
					plog(XLOG_ERROR, "rmdir(%s): %m", xdp);
				break;
			} else {
#ifdef DEBUG
				dlog("rmdir(%s)", xdp);
#endif
			}
		} else {
			break;
		}
		dp = strrchr(xdp, '/');
		if (dp)
			*dp = '\0';
	} while (dp && dp > xdp);
	free(xdp);
}
@


1.15
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d35 1
a35 1
 *	$Id: util.c,v 1.14 2014/10/26 01:16:48 guenther Exp $
a89 3
#ifdef DEBUG_MEM
	malloc_verify();
#endif /* DEBUG_MEM */
@


1.14
log
@Replace xrealloc() with xreallocarray().  Break-out the 'log and die'
function as xmallocfailure() and use that in the locations where
reallocarray's checks alone aren't sufficient.

ok doug@@ deraadt@@
@
text
@d35 1
a35 1
 *	$Id: util.c,v 1.13 2014/10/20 02:33:42 guenther Exp $
d289 1
a289 1
	bzero((void *)&sin, sizeof(sin));
@


1.13
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d35 1
a35 1
 *	$Id: util.c,v 1.12 2013/12/03 02:14:57 deraadt Exp $
d52 1
a52 1
	char *sp = (char *) xmalloc(len+1);
d67 7
a73 4
	int l1 = strlen(s1);
	int l2 = strlen(s2);
	int l3 = strlen(s3);
	p = (char *) xrealloc(p, l1 + l2 + l3 + 1);
d83 1
a83 1
	int len = strlen(s) + 1;
d85 3
a87 1
	p = (char *) xrealloc((void *)p, len);
d103 1
a103 1
	ivec = (char **) xmalloc((ic+1)*sizeof(char *));
d152 1
a152 1
		ivec = (char **) xrealloc((void *)ivec, (ic+1)*sizeof(char *));
@


1.12
log
@ctype cleanups
ok okan
@
text
@d35 1
a35 1
 *	$Id: util.c,v 1.11 2003/06/02 23:36:51 millert Exp $
a543 16
#ifdef SUNOS4_WORKAROUND
	/*
	 * Do a sync - if we do rmdirs() immediately
	 * and then the system crashes it leaves
	 * the filesystem in a state that fsck -p
	 * can't fix.  (Observed more than once on
	 * SunOS 4 ...)
	 *
	 * The problem was caused by a bug somewhere
	 * in the UFS code which has since been fixed
	 * (at least at Berkeley).
	 *
	 * Attempted workaround - XXX.
	 */
	sync();
#endif /* SUNOS4_WORKAROUND */
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: util.c,v 1.10 2003/03/13 22:08:02 deraadt Exp $
d105 3
a107 1
		while (*s && (ch == ' ' ? (isascii(*s) && isspace(*s)) : *s == ch))
d124 3
a126 1
		while (*s && !(ch == ' ' ? (isascii(*s) && isspace(*s)) : *s == ch)) {
@


1.10
log
@more strlcpy; ok beck, and others pointed out a glitch
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: util.c,v 1.9 2002/08/05 07:24:26 pvalchev Exp $
@


1.9
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.8 2002/08/03 08:29:31 pvalchev Exp $
d88 1
a88 1
	strcpy(p, s);
@


1.8
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.7 2002/07/18 02:03:00 deraadt Exp $
d54 1
a54 1
strnsave(Const char *str, int len)
d86 1
a86 1
	p = (char *) xrealloc((voidp) p, len);
d147 1
a147 1
		ivec = (char **) xrealloc((voidp) ivec, (ic+1)*sizeof(char *));
d284 1
a284 1
	bzero((voidp) &sin, sizeof(sin));
d470 1
a470 1
dofork(P_void)
d490 1
a490 1
background(P_void)
@


1.7
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.6 2002/06/11 05:29:54 itojun Exp $
d53 2
a54 3
char *strnsave(str, len)
Const char *str;
int len;
a63 6
char *strdup(s)
Const char *s;
{
	return strnsave(s, strlen(s));
}

d68 2
a69 5
char *str3cat(p, s1, s2, s3)
char *p;
char *s1;
char *s2;
char *s3;
d81 2
a82 3
char *strealloc(p, s)
char *p;
char *s;
d95 2
a96 5
char **strsplit P((char *s, int ch, int qc));
char **strsplit(s, ch, qc)
char *s;
int ch;
int qc;
d175 2
a176 3
static void domain_strip P((char *otherdom, char *localdom));
static void domain_strip(otherdom, localdom)
char *otherdom, *localdom;
d203 2
a204 3
void host_normalize P((char **chp));
void host_normalize(chp)
char **chp;
d230 2
a231 5
char *inet_dquad P((char *buf, size_t, u_int32_t addr));
char *inet_dquad(buf, buflen, addr)
char *buf;
size_t buflen;
u_int32_t addr;
d247 2
a248 3
int valid_key P((char *key));
int valid_key(key)
char *key;
d256 2
a257 3
void going_down P((int rc));
void going_down(rc)
int rc;
d278 2
a279 4
int bind_resv_port P((int so, u_short *pp));
int bind_resv_port(so, pp)
int so;
u_short *pp;
d293 2
a294 3
void forcibly_timeout_mp P((am_node *mp));
void forcibly_timeout_mp(mp)
am_node *mp;
d312 2
a313 3
void mf_mounted P((mntfs *mf));
void mf_mounted(mf)
mntfs *mf;
d348 2
a349 3
void am_mounted P((am_node *mp));
void am_mounted(mp)
am_node *mp;
d404 2
a405 3
int mount_node P((am_node *mp));
int mount_node(mp)
am_node *mp;
d423 2
a424 3
void am_unmounted P((am_node *mp));
void am_unmounted(mp)
am_node *mp;
d450 2
a451 3
int auto_fmount P((am_node *mp));
int auto_fmount(mp)
am_node *mp;
d457 2
a458 3
int auto_fumount P((am_node *mp));
int auto_fumount(mp)
am_node *mp;
d469 2
a470 2
static pid_t dofork(P_void);
static pid_t dofork()
d489 2
a490 2
pid_t background(P_void);
pid_t background()
d506 2
a507 4
int mkdirs P((char *path, int mode));
int mkdirs(path, mode)
char *path;
int mode;
d573 2
a574 3
void rmdirs P((char *dir));
void rmdirs(dir)
char *dir;
@


1.6
log
@use snprintf.
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.5 2002/05/26 02:49:50 deraadt Exp $
d147 1
a147 1
				 	s++;
@


1.5
log
@pid_cleanup, inspired by work by jason@@ackley.net
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.4 2001/03/02 06:22:05 deraadt Exp $
d246 2
a247 2
char *inet_dquad P((char *buf, u_int32_t addr));
char *inet_dquad(buf, addr)
d249 1
d253 1
a253 1
	sprintf(buf, "%d.%d.%d.%d",
@


1.4
log
@KNF
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.3 1997/01/31 14:42:02 graichen Exp $
d498 2
a499 2
static int dofork(P_void);
static int dofork()
d501 1
a501 1
	int pid;
d518 2
a519 2
int background(P_void);
int background()
d521 1
a521 1
	int pid = dofork();
@


1.3
log
@make amd 64bit ready for the alpha (from NetBSD/thorpej)
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.2 1996/08/10 21:39:43 deraadt Exp $
d48 1
d555 1
a555 1
	while (sp = strchr(sp+1, '/')) {
@


1.2
log
@call bindresvport() instead of faking it badly
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.1.1.1 1995/10/18 08:47:12 deraadt Exp $
d245 1
a245 1
char *inet_dquad P((char *buf, unsigned long addr));
d248 1
a248 1
unsigned long addr;
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: util.c,v 1.3 1994/06/13 20:48:09 mycroft Exp $
a303 1
	unsigned short port;
d308 1
a308 8
	port = IPPORT_RESERVED;

	do {
		--port;
		sin.sin_port = htons(port);
		rc = bind(so, (struct sockaddr *) &sin, sizeof(sin));
	} while (rc < 0 && port > IPPORT_RESERVED/2);

d310 1
a310 1
		*pp = port;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
