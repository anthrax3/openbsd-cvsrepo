head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.6
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.14.0.20
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.18
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.14
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.12
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.26
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.22
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.20
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.18
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.16
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.12.05.21.15.01;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	dGqLLvlPAG0kHsOT;

1.22
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.21;
commitid	RUbgWdu1CNTVPIOS;

1.21
date	2014.10.26.03.08.21;	author guenther;	state Exp;
branches;
next	1.20;
commitid	WHJr6yXZrF36RX5I;

1.20
date	2014.10.26.03.03.34;	author guenther;	state Exp;
branches;
next	1.19;
commitid	RhupU2WFUkfzry1g;

1.19
date	2014.10.26.02.51.47;	author guenther;	state Exp;
branches;
next	1.18;
commitid	hxTw7gpR0gTwgt1l;

1.18
date	2014.10.26.02.43.50;	author guenther;	state Exp;
branches;
next	1.17;
commitid	QMh02q5MFiw3np67;

1.17
date	2014.10.20.06.55.59;	author guenther;	state Exp;
branches;
next	1.16;
commitid	1xnKI9ul35JBjA4W;

1.16
date	2014.10.20.02.33.42;	author guenther;	state Exp;
branches;
next	1.15;
commitid	bZbpWDoZDVt0RPe1;

1.15
date	2014.10.20.00.20.04;	author guenther;	state Exp;
branches;
next	1.14;
commitid	ciYfifbFHhmQvDo5;

1.14
date	2010.07.05.21.54.11;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.30.16.04.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.05.19.38.43;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.05.19.19.44;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.13.22.08.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.11.05.29.54;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.29.18.39.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.02.06.22.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove a bunch of NULL-checks before free().
@
text
@/*	$OpenBSD: mapc.c,v 1.22 2014/10/26 03:28:41 guenther Exp $	*/

/*-
 * Copyright (c) 1989 Jan-Simon Pendry
 * Copyright (c) 1989 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Mount map cache
 */

#include "am.h"
#include <regex.h>

/*
 * Hash table size
 */
#define	NKVHASH	(1 << 2)		/* Power of two */

/*
 * Wildcard key
 */
static char wildcard[] = "*";

/*
 * Map cache types
 * default, none, incremental, all, regexp
 * MAPC_RE implies MAPC_ALL and must be numerically
 * greater.
 */
#define	MAPC_DFLT	0x000
#define	MAPC_NONE	0x001
#define	MAPC_INC	0x002
#define	MAPC_ROOT	0x004
#define	MAPC_ALL	0x010
#define MAPC_RE		0x020
#define	MAPC_ISRE(m) ((m)->alloc == MAPC_RE)
#define	MAPC_CACHE_MASK	0x0ff
#define	MAPC_SYNC	0x100

static struct opt_tab mapc_opt[] = {
	{ "all", MAPC_ALL },
	{ "default", MAPC_DFLT },
	{ "inc", MAPC_INC },
	{ "mapdefault", MAPC_DFLT },
	{ "none", MAPC_NONE },
	{ "re", MAPC_RE },
	{ "regexp", MAPC_RE },
	{ "sync", MAPC_SYNC },
	{ 0, 0 }
};

/*
 * Lookup recursion
 */
#define	MREC_FULL	2
#define	MREC_PART	1
#define	MREC_NONE	0

/*
 * Cache map operations
 */
typedef void	add_fn(mnt_map *, char *, char *);
typedef int	init_fn(char *, time_t *);
typedef int	search_fn(mnt_map *, char *, char *, char **, time_t *);
typedef int	reload_fn(mnt_map *, char *, add_fn *);
typedef int	mtime_fn(char *, time_t *);

static void	mapc_sync(mnt_map *);

/*
 * Map type
 */
typedef struct map_type map_type;
struct map_type {
	char *name;			/* Name of this map type */
	init_fn *init;			/* Initialisation */
	reload_fn *reload;		/* Reload or fill */
	search_fn *search;		/* Search for new entry */
	mtime_fn *mtime;		/* Find modify time */
	int def_alloc;			/* Default allocation mode */
};

/*
 * Key-value pair
 */
typedef struct kv kv;
struct kv {
	kv *next;
	char *key;
	char *val;
};

struct mnt_map {
	qelem hdr;
	int refc;			/* Reference count */
	short flags;			/* Allocation flags */
	short alloc;			/* Allocation mode */
	time_t modify;			/* Modify time of map */
	char *map_name;			/* Name of this map */
	char *wildcard;			/* Wildcard value */
	reload_fn *reload;		/* Function to be used for reloads */
	search_fn *search;		/* Function to be used for searching */
	mtime_fn *mtime;		/* Modify time function */
	kv *kvhash[NKVHASH];		/* Cached data */
};

/*
 * Map for root node
 */
static mnt_map *root_map;

/*
 * List of known maps
 */
extern qelem map_list_head;
qelem map_list_head = { &map_list_head, &map_list_head };

/*
 * Configuration
 */

/* ROOT MAP */
static int	root_init(char *, time_t *);

/* FILE MAPS */
extern int	file_init(char *, time_t *);
extern int	file_reload(mnt_map *, char *, add_fn *);
extern int	file_search(mnt_map *, char *, char *, char **, time_t *);
extern int	file_mtime(char *, time_t *);

/* Network Information Service (NIS) MAPS */
extern int	nis_init(char *, time_t *);
extern int	nis_reload(mnt_map *, char *, add_fn *);
extern int	nis_search(mnt_map *, char *, char *, char **, time_t *);
#define nis_mtime nis_init

/* NDBM MAPS */
#ifdef HAS_NDBM_MAPS
extern int	ndbm_init(char *, time_t *);
extern int	ndbm_search(mnt_map *, char *, charo *, char **, time_t *);
#define ndbm_mtime ndbm_init
#endif /* HAS_NDBM_MAPS */

/* PASSWD MAPS */
extern int	passwd_init(char *, time_t *);
extern int	passwd_search(mnt_map *, char *, char *, char **, time_t *);

/* UNION MAPS */
extern int	union_init(char *, time_t *);
extern int	union_search(mnt_map *, char *, char *, char **, time_t *);
extern int	union_reload(mnt_map *, char *, add_fn *);

/* ERROR MAP */
static int	error_init(char *, time_t *);
static int	error_reload(mnt_map *, char *, add_fn *);
static int	error_search(mnt_map *, char *, char *, char **, time_t *);
static int	error_mtime(char *, time_t *);

static map_type maptypes[] = {
	{ "root", root_init, error_reload, error_search, error_mtime, MAPC_ROOT },

	{ "passwd", passwd_init, error_reload, passwd_search, error_mtime, MAPC_INC },

	{ "union", union_init, union_reload, union_search, error_mtime, MAPC_ALL },

	{ "nis", nis_init, nis_reload, nis_search, nis_mtime, MAPC_INC },

#ifdef HAS_NDBM_MAPS
	{ "ndbm", ndbm_init, error_reload, ndbm_search, ndbm_mtime, MAPC_INC },
#endif

	{ "file", file_init, file_reload, file_search, file_mtime, MAPC_ALL },

	{ "error", error_init, error_reload, error_search, error_mtime, MAPC_NONE },
};

/*
 * Hash function
 */
static unsigned int
kvhash_of(char *key)
{
	unsigned int i, j;

	for (i = 0; (j = *key++); i += j)
		;

	return i % NKVHASH;
}

void
mapc_showtypes(FILE *fp)
{
	map_type *mt;
	char *sep = "";

	for (mt = maptypes; mt < maptypes+sizeof(maptypes)/sizeof(maptypes[0]); mt++) {
		fprintf(fp, "%s%s", sep, mt->name);
		sep = ", ";
	}
}

/*
 * Add key and val to the map m.
 * key and val are assumed to be safe copies
 */
void
mapc_add_kv(mnt_map *m, char *key, char *val)
{
	kv **h;
	kv *n;
	int hash = kvhash_of(key);

#ifdef DEBUG
	dlog("add_kv: %s -> %s", key, val);
#endif

	if (MAPC_ISRE(m)) {
		char keyb[MAXPATHLEN];
		regex_t *re;
		int err;

		/*
		 * Make sure the string is bound to the start and end
		 */
		snprintf(keyb, sizeof(keyb), "^%s$", key);
		re = malloc(sizeof(*re));
		if (re == NULL) {
			plog(XLOG_USER, "error allocating RE \"%s\"", keyb);
			return;
		}
		err = regcomp(re, keyb, 0);
		if (err) {
			char errbuf[100];

			regerror(err, re, errbuf, sizeof errbuf);
			free(re);
			plog(XLOG_USER, "error compiling RE \"%s\": %s",
			    keyb, errbuf);
			return;
		}

		free(key);
		key = (char *)re;
	}

	h = &m->kvhash[hash];
	n = ALLOC(kv);
	n->key = key;
	n->val = val;
	n->next = *h;
	*h = n;
}

static void
mapc_repl_kv(mnt_map *m, char *key, char *val)
{
	kv *k;

	/*
	 * Compute the hash table offset
	 */
	k = m->kvhash[kvhash_of(key)];

	/*
	 * Scan the linked list for the key
	 */
	while (k && !FSTREQ(k->key, key))
		k = k->next;

	if (k) {
		free(k->val);
		k->val = val;
	} else {
		mapc_add_kv(m, key, val);
	}

}

/*
 * Search a map for a key.
 * Calls map specific search routine.
 * While map is out of date, keep re-syncing.
 */
static int search_map(mnt_map *m, char *key, char **valp)
{
	int rc;

	do {
		rc = (*m->search)(m, m->map_name, key, valp, &m->modify);
		if (rc < 0) {
			plog(XLOG_MAP, "Re-synchronizing cache for map %s", m->map_name);
			mapc_sync(m);
		}
	} while (rc < 0);

	return rc;
}

/*
 * Do a wildcard lookup in the map and
 * save the result.
 */
static void
mapc_find_wildcard(mnt_map *m)
{
	/*
	 * Attempt to find the wildcard entry
	 */
	int rc = search_map(m, wildcard, &m->wildcard);

	if (rc != 0)
		m->wildcard = 0;
}

/*
 * Make a duplicate reference to an existing map
 */
#define mapc_dup(m) ((m)->refc++, (m))

/*
 * Do a map reload
 */
static int
mapc_reload_map(mnt_map *m)
{
	int error;
#ifdef DEBUG
	dlog("calling map reload on %s", m->map_name);
#endif
	error = (*m->reload)(m, m->map_name, mapc_add_kv);
	if (error)
		return error;
	m->wildcard = 0;
#ifdef DEBUG
	dlog("calling mapc_search for wildcard");
#endif
	error = mapc_search(m, wildcard, &m->wildcard);
	if (error)
		m->wildcard = 0;
	return 0;
}

/*
 * Create a new map
 */
static mnt_map *
mapc_create(char *map, char *opt)
{
	mnt_map *m = ALLOC(mnt_map);
	map_type *mt;
	time_t modify;
	int alloc = 0;

	(void) cmdoption(opt, mapc_opt, &alloc);

	for (mt = maptypes; mt < maptypes+sizeof(maptypes)/sizeof(maptypes[0]); mt++)
		if ((*mt->init)(map, &modify) == 0)
			break;
	/* assert: mt in maptypes */

	m->flags = alloc & ~MAPC_CACHE_MASK;
	alloc &= MAPC_CACHE_MASK;

	if (alloc == MAPC_DFLT)
		alloc = mt->def_alloc;
	switch (alloc) {
	default:
		plog(XLOG_USER, "Ambiguous map cache type \"%s\"; using \"inc\"", opt);
		alloc = MAPC_INC;
		/* fallthrough... */
	case MAPC_NONE:
	case MAPC_INC:
	case MAPC_ROOT:
		break;
	case MAPC_ALL:
		/*
		 * If there is no support for reload and it was requested
		 * then back off to incremental instead.
		 */
		if (mt->reload == error_reload) {
			plog(XLOG_WARNING, "Map type \"%s\" does not support cache type \"all\"; using \"inc\"", mt->name);
			alloc = MAPC_INC;
		}
		break;
	case MAPC_RE:
		if (mt->reload == error_reload) {
			plog(XLOG_WARNING, "Map type \"%s\" does not support cache type \"re\"", mt->name);
			mt = &maptypes[sizeof(maptypes)/sizeof(maptypes[0]) - 1];
			/* assert: mt->name == "error" */
		}
		break;
	}

#ifdef DEBUG
	dlog("Map for %s coming from maptype %s", map, mt->name);
#endif

	m->alloc = alloc;
	m->reload = mt->reload;
	m->modify = modify;
	m->search = alloc >= MAPC_ALL ? error_search : mt->search;
	m->mtime = mt->mtime;
	bzero(m->kvhash, sizeof(m->kvhash));
	m->map_name = strdup(map);
	m->refc = 1;
	m->wildcard = 0;

	/*
	 * synchronize cache with reality
	 */
	mapc_sync(m);

	return m;
}

/*
 * Free the cached data in a map
 */
static void
mapc_clear(mnt_map *m)
{
	int i;

	/*
	 * For each of the hash slots, chain
	 * along free'ing the data.
	 */
	for (i = 0; i < NKVHASH; i++) {
		kv *k = m->kvhash[i];
		while (k) {
			kv *n = k->next;
			free(k->key);
			free(k->val);
			free(k);
			k = n;
		}
	}
	/*
	 * Zero the hash slots
	 */
	bzero(m->kvhash, sizeof(m->kvhash));
	/*
	 * Free the wildcard if it exists
	 */
	if (m->wildcard) {
		free(m->wildcard);
		m->wildcard = 0;
	}
}

/*
 * Find a map, or create one if it does not exist
 */
mnt_map *
mapc_find(char *map, char *opt)
{
	mnt_map *m;

	/*
	 * Search the list of known maps to see if
	 * it has already been loaded.  If it is found
	 * then return a duplicate reference to it.
	 * Otherwise make a new map as required and
	 * add it to the list of maps
	 */
	ITER(m, mnt_map, &map_list_head)
		if (STREQ(m->map_name, map))
			return mapc_dup(m);

	m = mapc_create(map, opt);
	ins_que(&m->hdr, &map_list_head);
	return m;
}

/*
 * Free a map.
 */
void
mapc_free(void *arg)
{
	mnt_map *m = arg;
	/*
	 * Decrement the reference count.
	 * If the reference count hits zero
	 * then throw the map away.
	 */
	if (m && --m->refc == 0) {
		mapc_clear(m);
		free(m->map_name);
		rem_que(&m->hdr);
		free(m);
	}
}

/*
 * Search the map for the key.
 * Put a safe copy in *pval or return
 * an error code
 */
int
mapc_meta_search(mnt_map *m, char *key, char **pval, int recurse)
{
	int error = 0;
	kv *k = 0;

	/*
	 * Firewall
	 */
	if (!m) {
		plog(XLOG_ERROR, "Null map request for %s", key);
		return ENOENT;
	}

	if (m->flags & MAPC_SYNC) {
		/*
		 * Get modify time...
		 */
		time_t t;
		error = (*m->mtime)(m->map_name, &t);
		if (error || t > m->modify) {
			m->modify = t;
			plog(XLOG_INFO, "Map %s is out of date", m->map_name);
			mapc_sync(m);
		}
	}

	if (!MAPC_ISRE(m)) {
		/*
		 * Compute the hash table offset
		 */
		k = m->kvhash[kvhash_of(key)];

		/*
		 * Scan the linked list for the key
		 */
		while (k && !FSTREQ(k->key, key)) k = k->next;

	}
	else if (recurse == MREC_FULL) {
		/*
		 * Try for an RE match against the entire map.
		 * Note that this will be done in a "random"
		 * order.
		 */

		int i;

		for (i = 0; i < NKVHASH; i++) {
			k = m->kvhash[i];
			while (k) {
				if (regexec((regex_t *)k->key, key,
				    0, NULL, 0) == 0)
					break;
				k = k->next;
			}
			if (k)
				break;
		}
	}

	/*
	 * If found then take a copy
	 */
	if (k) {
		if (k->val)
			*pval = strdup(k->val);
		else
			error = ENOENT;
	} else if (m->alloc >= MAPC_ALL) {
		/*
		 * If the entire map is cached then this
		 * key does not exist.
		 */
		error = ENOENT;
	} else {
		/*
		 * Otherwise search the map.  If we are
		 * in incremental mode then add the key
		 * to the cache.
		 */
		error = search_map(m, key, pval);
		if (!error && m->alloc == MAPC_INC)
			mapc_add_kv(m, strdup(key), strdup(*pval));
	}

	/*
	 * If an error, and a wildcard exists,
	 * and the key is not internal then
	 * return a copy of the wildcard.
	 */
	if (error > 0) {
		if (recurse == MREC_FULL && !MAPC_ISRE(m)) {
			char wildname[MAXPATHLEN];
			char *subp;
			if (*key == '/')
				return error;
			/*
			 * Keep chopping sub-directories from the RHS
			 * and replacing with "/ *" and repeat the lookup.
			 * For example:
			 * "src/gnu/gcc" -> "src / gnu / *" -> "src / *"
			 */
			strlcpy(wildname, key, sizeof wildname);
			while (error && (subp = strrchr(wildname, '/'))) {
				strlcpy(subp, "/*", 3);
#ifdef DEBUG
				dlog("mapc recurses on %s", wildname);
#endif
				error = mapc_meta_search(m, wildname, pval, MREC_PART);
				if (error)
					*subp = 0;
			}
			if (error > 0 && m->wildcard) {
				*pval = strdup(m->wildcard);
				error = 0;
			}
		}
	}

	return error;
}

int
mapc_search(mnt_map *m, char *key, char **pval)
{
	return mapc_meta_search(m, key, pval, MREC_FULL);
}

/*
 * Get map cache in sync with physical representation
 */
static void
mapc_sync(mnt_map *m)
{
	if (m->alloc != MAPC_ROOT) {
		mapc_clear(m);

		if (m->alloc >= MAPC_ALL)
			if (mapc_reload_map(m))
				m->alloc = MAPC_INC;
		/*
		 * Attempt to find the wildcard entry
		 */
		if (m->alloc < MAPC_ALL)
			mapc_find_wildcard(m);
	}
}

/*
 * Reload all the maps
 * Called when Amd gets hit by a SIGHUP.
 */
void mapc_reload(void)
{
	mnt_map *m;

	/*
	 * For all the maps,
	 * Throw away the existing information.
	 * Do a reload
	 * Find the wildcard
	 */
	ITER(m, mnt_map, &map_list_head)
		mapc_sync(m);
}

/*
 * Root map.
 * The root map is used to bootstrap amd.
 * All the require top-level mounts are added
 * into the root map and then the map is iterated
 * and a lookup is done on all the mount points.
 * This causes the top level mounts to be automounted.
 */

static int
root_init(char *map, time_t *tp)
{
	*tp = clocktime();
	return strcmp(map, ROOT_MAP) == 0 ? 0 : ENOENT;
}

/*
 * Add a new entry to the root map
 *
 * dir - directory (key)
 * opts - mount options
 * map - map name
 */
void
root_newmap(char *dir, char *opts, char *map)
{
	char str[MAXPATHLEN];

	/*
	 * First make sure we have a root map to talk about...
	 */
	if (!root_map)
		root_map = mapc_find(ROOT_MAP, "mapdefault");

	/*
	 * Then add the entry...
	 */
	dir = strdup(dir);
	if (map)
		snprintf(str, sizeof(str), "cache:=mapdefault;type:=toplvl;fs:=\"%s\";%s",
			map, opts ? opts : "");
	else
		strlcpy(str, opts, sizeof str);
	mapc_repl_kv(root_map, dir, strdup(str));
}

int
mapc_keyiter(mnt_map *m, void (*fn)(char *,void *), void *arg)
{
	int i;
	int c = 0;

	for (i = 0; i < NKVHASH; i++) {
		kv *k = m->kvhash[i];
		while (k) {
			(*fn)(k->key, arg);
			k = k->next;
			c++;
		}
	}

	return c;
}

/*
 * Iterate over the root map
 * and call (*fn)() on the key
 * of all the nodes.
 * Finally throw away the root map.
 */
int
root_keyiter(void (*fn)(char *,void *), void *arg)
{
	if (root_map) {
		int c = mapc_keyiter(root_map, fn, arg);
#ifdef notdef
		mapc_free(root_map);
		root_map = 0;
#endif
		return c;
	}
	return 0;
}

/*
 * Error map
 */
static int
error_init(char *map, time_t *tp)
{
	plog(XLOG_USER, "No source data for map %s", map);
	*tp = 0;
	return 0;
}

static int
error_search(mnt_map *m, char *map, char *key, char **pval, time_t *tp)
{
	return ENOENT;
}

static int
error_reload(mnt_map *m, char *map, add_fn *fn)
{
	return ENOENT;
}

static int
error_mtime(char *map, time_t *tp)
{
	*tp = 0;
	return 0;
}
@


1.22
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.21 2014/10/26 03:08:21 guenther Exp $	*/
d464 1
a464 2
			if (k->val)
				free(k->val);
@


1.21
log
@Delete casts to void* of the argument to free(): only needed when lying
about constness and none of these were
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.20 2014/10/26 03:03:34 guenther Exp $	*/
d434 1
a434 1
	bzero((void *)m->kvhash, sizeof(m->kvhash));
d473 1
a473 1
	bzero((void *)m->kvhash, sizeof(m->kvhash));
@


1.20
log
@Update to the modern RPC style with different names for server and client
    stubs (they have different prototypes, after all).
Fill in missing prototypes.
Use void* arguments on closure-style callbacks, with local variables of
    the expected type.
Keep deleting unnecessary casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.19 2014/10/26 02:51:47 guenther Exp $	*/
d463 1
a463 1
			free((void *)k->key);
d465 2
a466 2
				free((void *)k->val);
			free((void *)k);
d521 1
a521 1
		free((void *)m->map_name);
d523 1
a523 1
		free((void *)m);
@


1.19
log
@When regcomp() fails, use regerror() to get a useful error message
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.18 2014/10/26 02:43:50 guenther Exp $	*/
d285 1
a285 1
void
d511 1
a511 1
mapc_free(mnt_map *m)
d513 1
@


1.18
log
@Lint is dead
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.17 2014/10/20 06:55:59 guenther Exp $	*/
d251 2
d258 9
a266 1
		if (!re || regcomp(re, keyb, 0)) {
d268 2
a269 1
			plog(XLOG_USER, "error compiling RE \"%s\": %s", keyb);
a270 3
		} else {
			free(key);
			key = (char *)re;
d272 3
@


1.17
log
@Change MTAB_TYPE_UFS from "ufs" to "ffs", fixing mount-restarting for them.
Perform one level of expansion on the various "portability" macros from os-*.h
Delete support for Hesiod and the pre-4.4 versions of the NFS API
Delete the no-op unlock_mntlist()
unifdef -UFASCIST_DF_COMMAND -UMOUNT_HELPER_SOURCE
Move the struct mntent and MNTMAXSTR definitions into include/am.h
Move the commented-out -DHAS_NDBM_MAPS into amd/Makefile
Expand OS_REP to "bsd44".
With config/* empty, delete them.

"lot of stuff...but I know your process on this" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.16 2014/10/20 02:33:42 guenther Exp $	*/
a781 1
/*ARGSUSED*/
a787 1
/*ARGSUSED*/
@


1.16
log
@unifdef -DHAS_REGEXP -DHAS_PASSWD_MAPS -DHAS_FILE_MAPS \
  -DHAS_NIS_MAPS -DHAS_NIS_RELOAD -DRPC_4 -DHAS_UNION_MAPS \
  -DHAS_TCP_NFS -DOS_HAS_NDBM -DNFS_PROTOCOL_VERSION=3 \
  -DNFS_ARGS_NEEDS_PATH -DPRECISE_SYMLINKS -DHAS_EMPTY_AUTOMOUNTS \
  -DNEED_MNTOPT_PARSER -DSHORT_MOUNT_NAME -DHAS_NFS_QUALIFIED_NAMES \
  -UUPDATE_MTAB -UFIXUP_MNTENT -UMNTENT_HDR -UMNTINFO_DEV \
  -UMNTOPT_COMPRESS -UMNTOPT_NQNFS -UINFORM_MOUNTD \
  -USUNOS4_WORKAROUND -UULTRIX_HACK

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.15 2014/10/20 00:20:04 guenther Exp $	*/
a177 11
/* HESIOD MAPS */
#ifdef HAS_HESIOD_MAPS
extern int	hesiod_init(char *, time_t *);
#ifdef HAS_HESIOD_RELOAD
extern int	hesiod_reload(mnt_map *, char *, add_fn *);
#else
#define hesiod_reload error_reload
#endif
extern int	hesiod_search(mnt_map *, char *, char *, char **, time_t *);
#endif /* HAS_HESIOD_MAPS */

a192 4

#ifdef HAS_HESIOD_MAPS
	{ "hesiod", hesiod_init, hesiod_reload, hesiod_search, error_mtime, MAPC_ALL },
#endif
@


1.15
log
@Start removing portability goo: we have syslog(), strerror(), POSIX regexp,
    BSD-style getmntinfo(), BSD signals, 4.4BSD unmount(), etc
Delete configurations for other OSes
Delete fsinfo and mk-amd-map, as we don't build them.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.14 2010/07/05 21:54:11 tedu Exp $	*/
a41 1
#ifdef HAS_REGEXP
a42 1
#endif
a64 1
#ifdef HAS_REGEXP
a66 3
#else
#define MAPC_ISRE(m) FALSE
#endif
a75 1
#ifdef HAS_REGEXP
a77 1
#endif
a155 1
#ifdef HAS_FILE_MAPS
a159 1
#endif /* HAS_FILE_MAPS */
a161 1
#ifdef HAS_NIS_MAPS
a162 1
#ifdef HAS_NIS_RELOAD
a163 3
#else
#define nis_reload error_reload
#endif
a165 1
#endif /* HAS_NIS_MAPS */
a168 1
#ifdef OS_HAS_NDBM
a171 1
#endif /* OS_HAS_NDBM */
a174 1
#ifdef HAS_PASSWD_MAPS
a176 1
#endif /* HAS_PASSWD_MAPS */
a189 1
#ifdef HAS_UNION_MAPS
a192 1
#endif /* HAS_UNION_MAPS */
a202 1
#ifdef HAS_PASSWD_MAPS
a203 1
#endif
a208 1
#ifdef HAS_UNION_MAPS
a209 1
#endif
a210 1
#ifdef HAS_NIS_MAPS
a211 1
#endif
a216 1
#ifdef HAS_FILE_MAPS
a217 1
#endif
a262 1
#ifdef HAS_REGEXP
a279 1
#endif
a419 1
#ifdef HAS_REGEXP
a426 1
#endif
a573 1
#ifdef HAS_REGEXP
a594 1
#endif
@


1.14
log
@convert last user of libcompat in base to modern regexes.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.13 2009/10/27 23:59:50 deraadt Exp $	*/
d43 1
a43 1
#include RE_HDR
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mapc.c,v 1.12 2003/10/30 16:04:06 millert Exp $	*/
a277 7
static const char *reg_error = "?";
void
regerror(const char *m)
{
	reg_error = m;
}

d296 1
a296 1
		regexp *re;
d301 4
a304 3
		re = regcomp(keyb);
		if (re == 0) {
			plog(XLOG_USER, "error compiling RE \"%s\": %s", keyb, reg_error);
d308 1
a308 1
			key = (char *) re;
d621 2
a622 1
				if (regexec((regexp *) k->key, key))
@


1.12
log
@Fix "the the" typos in comments; Bruno Rohee
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)mapc.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$Id: mapc.c,v 1.11 2003/06/02 23:36:51 millert Exp $";
#endif /* not lint */
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
d39 1
a39 1
static char *rcsid = "$Id: mapc.c,v 1.10 2003/04/05 19:38:43 tedu Exp $";
d813 1
a813 1
 * Iterate of the the root map
@


1.10
log
@strncpy should be strlcpy.  ok pvalchev
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char *rcsid = "$Id: mapc.c,v 1.9 2003/04/05 19:19:44 pvalchev Exp $";
@


1.9
log
@strlcat, strncpy; ok tedu henning
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.8 2003/03/13 22:08:02 deraadt Exp $";
d688 1
a688 1
				strncpy(subp, "/*", 2);
@


1.8
log
@more strlcpy; ok beck, and others pointed out a glitch
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.7 2002/08/05 07:24:26 pvalchev Exp $";
d688 1
a688 1
				strcpy(subp, "/*");	/* ok */
@


1.7
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.6 2002/08/03 08:29:31 pvalchev Exp $";
d688 1
a688 1
				strcpy(subp, "/*");
d792 1
a792 1
		strcpy(str, opts);
@


1.6
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.5 2002/07/18 02:03:00 deraadt Exp $";
d285 1
a285 1
static Const char *reg_error = "?";
d287 1
a287 1
regerror(Const char *m)
d485 1
a485 1
	bzero((voidp) m->kvhash, sizeof(m->kvhash));
d514 1
a514 1
			free((voidp) k->key);
d516 2
a517 2
				free((voidp) k->val);
			free((voidp) k);
d524 1
a524 1
	bzero((voidp) m->kvhash, sizeof(m->kvhash));
d571 1
a571 1
		free((voidp) m->map_name);
d573 1
a573 1
		free((voidp) m);
d736 1
a736 1
void mapc_reload(P_void)
d797 1
a797 1
mapc_keyiter(mnt_map *m, void (*fn)(char*,voidp), voidp arg)
d821 1
a821 1
root_keyiter(void (*fn)(char*,voidp), voidp arg)
@


1.5
log
@space nits
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.4 2002/06/11 05:29:54 itojun Exp $";
d107 5
a111 5
typedef void add_fn P((mnt_map*, char*, char*));
typedef int init_fn P((char*, time_t*));
typedef int search_fn P((mnt_map*, char*, char*, char**, time_t*));
typedef int reload_fn P((mnt_map*, char*, add_fn*));
typedef int mtime_fn P((char*, time_t*));
d113 1
a113 1
static void mapc_sync P((mnt_map*));
d168 1
a168 1
static int root_init P((char*, time_t*));
d172 4
a175 4
extern int file_init P((char*, time_t*));
extern int file_reload P((mnt_map*, char*, add_fn*));
extern int file_search P((mnt_map*, char*, char*, char**, time_t*));
extern int file_mtime P((char*, time_t*));
d180 1
a180 1
extern int nis_init P((char*, time_t*));
d182 1
a182 1
extern int nis_reload P((mnt_map*, char*, add_fn*));
d186 1
a186 1
extern int nis_search P((mnt_map*, char*, char*, char**, time_t*));
d193 2
a194 2
extern int ndbm_init P((char*, time_t*));
extern int ndbm_search P((mnt_map*, char*, char*, char**, time_t*));
d201 2
a202 2
extern int passwd_init P((char*, time_t*));
extern int passwd_search P((mnt_map*, char*, char*, char**, time_t*));
d207 1
a207 1
extern int hesiod_init P((char*, time_t*));
d209 1
a209 1
extern int hesiod_reload P((mnt_map*, char*, add_fn*));
d213 1
a213 1
extern int hesiod_search P((mnt_map*, char*, char*, char**, time_t*));
d218 3
a220 3
extern int union_init P((char*, time_t*));
extern int union_search P((mnt_map*, char*, char*, char**, time_t*));
extern int union_reload P((mnt_map*, char*, add_fn*));
d224 4
a227 4
static int error_init P((char*, time_t*));
static int error_reload P((mnt_map*, char*, add_fn*));
static int error_search P((mnt_map*, char*, char*, char**, time_t*));
static int error_mtime P((char*, time_t*));
d262 2
a263 3
static unsigned int kvhash_of P((char *key));
static unsigned int kvhash_of(key)
char *key;
d273 2
a274 3
void mapc_showtypes P((FILE *fp));
void mapc_showtypes(fp)
FILE *fp;
d278 1
d286 2
a287 3
void regerror P((Const char *m));
void regerror(m)
Const char *m;
d296 2
a297 5
void mapc_add_kv P((mnt_map *m, char *key, char *val));
void mapc_add_kv(m, key, val)
mnt_map *m;
char *key;
char *val;
d334 2
a335 5
void mapc_repl_kv P((mnt_map *m, char *key, char *val));
void mapc_repl_kv(m, key, val)
mnt_map *m;
char *key;
char *val;
d364 1
a364 5
static int search_map P((mnt_map *m, char *key, char **valp));
static int search_map(m, key, valp)
mnt_map *m;
char *key;
char **valp;
d367 1
d383 2
a384 3
static void mapc_find_wildcard P((mnt_map *m));
static void mapc_find_wildcard(m)
mnt_map *m;
d403 2
a404 2
static int mapc_reload_map(m)
mnt_map *m;
d426 2
a427 4
static mnt_map *mapc_create P((char *map, char *opt));
static mnt_map *mapc_create(map, opt)
char *map;
char *opt;
d501 2
a502 3
static void mapc_clear P((mnt_map *m));
static void mapc_clear(m)
mnt_map *m;
d537 2
a538 4
mnt_map *mapc_find P((char *map, char *opt));
mnt_map *mapc_find(map, opt)
char *map;
char *opt;
d561 2
a562 3
void mapc_free P((mnt_map *m));
void mapc_free(m)
mnt_map *m;
d582 2
a583 6
int mapc_meta_search P((mnt_map *m, char *key, char **pval, int recurse));
int mapc_meta_search(m, key, pval, recurse)
mnt_map *m;
char *key;
char **pval;
int recurse;
d706 2
a707 5
int mapc_search P((mnt_map *m, char *key, char **pval));
int mapc_search(m, key, pval)
mnt_map *m;
char *key;
char **pval;
d715 2
a716 3
static void mapc_sync P((mnt_map *m));
static void mapc_sync(m)
mnt_map *m;
d736 1
a736 2
void mapc_reload(P_void);
void mapc_reload()
d759 2
a760 4
static int root_init P((char *map, time_t *tp));
static int root_init(map, tp)
char *map;
time_t *tp;
d773 2
a774 5
void root_newmap P((char *dir, char *opts, char *map));
void root_newmap(dir, opts, map)
char *dir;
char *opts;
char *map;
d796 2
a797 5
int mapc_keyiter P((mnt_map *m, void (*fn)(char*,voidp), voidp arg));
int mapc_keyiter(m, fn, arg)
mnt_map *m;
void (*fn)P((char*, voidp));
voidp arg;
d820 2
a821 4
int root_keyiter P((void (*fn)(char*,voidp), voidp arg));
int root_keyiter(fn, arg)
void (*fn)P((char*,voidp));
voidp arg;
d837 2
a838 4
static int error_init P((char *map, time_t *tp));
static int error_init(map, tp)
char *map;
time_t *tp;
d846 2
a847 7
static int error_search P((mnt_map *m, char *map, char *key, char **pval, time_t *tp));
static int error_search(m, map, key, pval, tp)
mnt_map *m;
char *map;
char *key;
char **pval;
time_t *tp;
d853 2
a854 5
static int error_reload P((mnt_map *m, char *map, add_fn *fn));
static int error_reload(m, map, fn)
mnt_map *m;
char *map;
add_fn *fn;
d859 2
a860 4
static int error_mtime P((char *map, time_t *tp));
static int error_mtime(map, tp)
char *map;
time_t *tp;
@


1.4
log
@use snprintf.
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.3 2002/05/29 18:39:00 deraadt Exp $";
d166 1
a166 1
 
@


1.3
log
@more strlcat and strlcpy
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.2 2001/03/02 06:22:03 deraadt Exp $";
d319 1
a319 1
		sprintf(keyb, "^%s$", key);
d821 1
a821 1
		sprintf(str, "cache:=mapdefault;type:=toplvl;fs:=\"%s\";%s",
@


1.2
log
@KNF
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.1.1.1 1995/10/18 08:47:10 deraadt Exp $";
d708 1
a708 1
			strcpy(wildname, key);
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
static char *rcsid = "$Id: mapc.c,v 1.5 1994/06/13 20:47:34 mycroft Exp $";
d268 1
a268 1
	for (i = 0; j = *key++; i += j)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
