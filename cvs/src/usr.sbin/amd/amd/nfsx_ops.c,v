head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.6.0.48
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.46
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.42
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.40
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.38
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.36
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.05.21.15.01;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	dGqLLvlPAG0kHsOT;

1.9
date	2014.10.26.03.28.41;	author guenther;	state Exp;
branches;
next	1.8;
commitid	RUbgWdu1CNTVPIOS;

1.8
date	2014.10.26.03.08.21;	author guenther;	state Exp;
branches;
next	1.7;
commitid	WHJr6yXZrF36RX5I;

1.7
date	2014.10.26.01.16.48;	author guenther;	state Exp;
branches;
next	1.6;
commitid	Qcgfc5DGBBARLngk;

1.6
date	2003.06.02.23.36.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.05.07.24.26;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.03.08.29.31;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.18.02.03.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.02.06.22.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove a bunch of NULL-checks before free().
@
text
@/*
 * Copyright (c) 1990 Jan-Simon Pendry
 * Copyright (c) 1990 Imperial College of Science, Technology & Medicine
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry at Imperial College, London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)nfsx_ops.c	8.1 (Berkeley) 6/6/93
 *	$Id: nfsx_ops.c,v 1.9 2014/10/26 03:28:41 guenther Exp $
 */

#include "am.h"

#ifdef HAS_NFSX

/*
 * NFS hierarchical mounts
 *
 * TODO: Re-implement.
 */

/*
 * The rfs field contains a list of mounts to be done from
 * the remote host.
 */
typedef struct nfsx_mnt {
	mntfs *n_mnt;
	int n_error;
} nfsx_mnt;

struct nfsx {
	int nx_c;		/* Number of elements in nx_v */
	nfsx_mnt *nx_v;		/* Underlying mounts */
	nfsx_mnt *nx_try;
};

static int nfsx_fmount(mntfs *);

static char *
nfsx_match(am_opts *fo)
{
	char *xmtab;
	char *ptr;
	int len;

	if (!fo->opt_rfs) {
		plog(XLOG_USER, "nfsx: no remote filesystem specified");
		return FALSE;
	}
	if (!fo->opt_rhost) {
		plog(XLOG_USER, "nfsx: no remote host specified");
		return FALSE;
	}

#ifdef notdef
	/* fiddle sublink, must be last... */
	if (fo->opt_sublink) {
		plog(XLOG_WARNING, "nfsx: sublink %s ignored", fo->opt_sublink);
		free(fo->opt_sublink);
		fo->opt_sublink = 0;
	}
#endif

	/* set default sublink */
	if (fo->opt_sublink == 0) {
		ptr = strchr(fo->opt_rfs, ',');
		if (ptr && ptr != (fo->opt_rfs + 1))
			fo->opt_sublink = strnsave(fo->opt_rfs + 1, ptr - fo->opt_rfs - 1);
	}

	/*
	 * Remove trailing ",..." from ${fs}
	 * After deslashifying, overwrite the end of ${fs} with "/"
	 * to make sure it is unique.
	 */
	if ((ptr = strchr(fo->opt_fs, ',')))
		*ptr = '\0';
	deslashify(fo->opt_fs);
	/*
	 * Bump string length to allow trailing /
	 */
	len = strlen(fo->opt_fs);
	if (len > SIZE_MAX - 2)
		 xmallocfailure();
	fo->opt_fs = xreallocarray(fo->opt_fs, len + 1 + 1, 1);
	ptr = fo->opt_fs + len;
	/*
	 * Make unique...
	 */
	*ptr++ = '/';
	*ptr = '\0';

	/*
	 * Determine magic cookie to put in mtab
	 */
	xmtab = str3cat((char *) 0, fo->opt_rhost, ":", fo->opt_rfs);
#ifdef DEBUG
	dlog("NFS: mounting remote server \"%s\", remote fs \"%s\" on \"%s\"",
		fo->opt_rhost, fo->opt_rfs, fo->opt_fs);
#endif /* DEBUG */

	return xmtab;
}

static void
nfsx_prfree(void *vp)
{
	struct nfsx *nx = (struct nfsx *) vp;
	int i;

	for (i = 0; i < nx->nx_c; i++) {
		mntfs *m = nx->nx_v[i].n_mnt;
		if (m)
			free_mntfs(m);
	}

	free(nx->nx_v);
	free(nx);
}

static int
nfsx_init(mntfs *mf)
{
	/*
	 * mf_info has the form:
	 *   host:/prefix/path,sub,sub,sub
	 */
	int i;
	int glob_error;
	struct nfsx *nx;
	int asked_for_wakeup = 0;

	nx = (struct nfsx *) mf->mf_private;

	if (nx == 0) {
		char **ivec;
		char *info = 0;
		char *host;
		char *pref;
		int error = 0;

		info = strdup(mf->mf_info);
		host = strchr(info, ':');
		if (!host) {
			error = EINVAL;
			goto errexit;
		}

		pref = host+1;
		host = info;

		/*
		 * Split the prefix off from the suffices
		 */
		ivec = strsplit(pref, ',', '\'');

		/*
		 * Count array size
		 */
		for (i = 0; ivec[i]; i++)
			;

		nx = ALLOC(nfsx);
		mf->mf_private = nx;
		mf->mf_prfree = nfsx_prfree;

		nx->nx_c = i - 1;	/* i-1 because we don't want the prefix */
		nx->nx_v = xreallocarray(NULL, nx->nx_c, sizeof *nx->nx_v);
		{ char *mp = 0;
		  char *xinfo = 0;
		  char *fs = mf->mf_fo->opt_fs;
		  char *rfs = 0;
		  for (i = 0; i < nx->nx_c; i++) {
			char *path = ivec[i+1];
			rfs = str3cat(rfs, pref, "/", path);
			/*
			 * Determine the mount point.
			 * If this is the root, then don't remove
			 * the trailing slash to avoid mntfs name clashes.
			 */
			mp = str3cat(mp, fs, "/", rfs);
			normalize_slash(mp);
			deslashify(mp);
			/*
			 * Determine the mount info
			 */
			xinfo = str3cat(xinfo, host, *path == '/' ? "" : "/", path);
			normalize_slash(xinfo);
			if (pref[1] != '\0')
				deslashify(xinfo);
#ifdef DEBUG
			dlog("nfsx: init mount for %s on %s", xinfo, mp);
#endif
			nx->nx_v[i].n_error = -1;
			nx->nx_v[i].n_mnt = find_mntfs(&nfs_ops, mf->mf_fo, mp, xinfo, "", mf->mf_mopts, mf->mf_remopts);
		  }
		  free(rfs);
		  free(mp);
		  free(xinfo);
		}

		free(ivec);
errexit:
		free(info);
		if (error)
			return error;
	}

	/*
	 * Iterate through the mntfs's and call
	 * the underlying init routine on each
	 */
	glob_error = 0;
	for (i = 0; i < nx->nx_c; i++) {
		nfsx_mnt *n = &nx->nx_v[i];
		mntfs *m = n->n_mnt;
		int error = (*m->mf_ops->fs_init)(m);
		/*
		 * If HARD_NFSX_ERRORS is defined, make any
		 * initialisation failure a hard error and
		 * fail the entire group.  Otherwise only fail
		 * if none of the group is mountable (see nfsx_fmount).
		 */
#ifdef HARD_NFSX_ERRORS
		if (error > 0)
			return error;
#else
		if (error > 0)
			n->n_error = error;
#endif
		else if (error < 0) {
			glob_error = -1;
			if (!asked_for_wakeup) {
				asked_for_wakeup = 1;
				sched_task(wakeup_task, mf, m);
			}
		}
	}

	return glob_error;
}

static void
nfsx_cont(int rc, int term, void *closure)
{
	mntfs *mf = (mntfs *) closure;
	struct nfsx *nx = (struct nfsx *) mf->mf_private;
	nfsx_mnt *n = nx->nx_try;

	n->n_mnt->mf_flags &= ~(MFF_ERROR|MFF_MOUNTING);
	mf->mf_flags &= ~MFF_ERROR;

	/*
	 * Wakeup anything waiting for this mount
	 */
	wakeup(n->n_mnt);

	if (rc || term) {
		if (term) {
			/*
			 * Not sure what to do for an error code.
			 */
			plog(XLOG_ERROR, "mount for %s got signal %d", n->n_mnt->mf_mount, term);
			n->n_error = EIO;
		} else {
			/*
			 * Check for exit status
			 */
			errno = rc;	/* XXX */
			plog(XLOG_ERROR, "%s: mount (nfsx_cont): %m", n->n_mnt->mf_mount);
			n->n_error = rc;
		}
		free_mntfs(n->n_mnt);
		n->n_mnt = new_mntfs();
		n->n_mnt->mf_error = n->n_error;
		n->n_mnt->mf_flags |= MFF_ERROR;
	} else {
		/*
		 * The mount worked.
		 */
		mf_mounted(n->n_mnt);
		n->n_error = 0;
	}

	/*
	 * Do the remaining bits
	 */
	if (nfsx_fmount(mf) >= 0) {
		wakeup(mf);
		mf->mf_flags &= ~MFF_MOUNTING;
		mf_mounted(mf);
	}
}

static int
try_nfsx_mount(void *mv)
{
	mntfs *mf = (mntfs *) mv;
	int error;

	mf->mf_flags |= MFF_MOUNTING;
	error = (*mf->mf_ops->fmount_fs)(mf);
	mf->mf_flags &= ~MFF_MOUNTING;
	return error;
}

static int
nfsx_remount(mntfs *mf, int fg)
{
	struct nfsx *nx = (struct nfsx *) mf->mf_private;
	nfsx_mnt *n;
	int glob_error = -1;

	for (n = nx->nx_v; n < nx->nx_v + nx->nx_c; n++) {
		mntfs *m = n->n_mnt;
		if (n->n_error < 0) {
			if (!(m->mf_flags & MFF_MKMNT) && m->mf_ops->fs_flags & FS_MKMNT) {
				int error = mkdirs(m->mf_mount, 0555);
				if (!error)
					m->mf_flags |= MFF_MKMNT;
			}
		}
	}

	/*
	 * Iterate through the mntfs's and mount each filesystem
	 * which is not yet mounted.
	 */
	for (n = nx->nx_v; n < nx->nx_v + nx->nx_c; n++) {
		mntfs *m = n->n_mnt;
		if (n->n_error < 0) {
			/*
			 * Check fmount entry pt. exists
			 * and then mount...
			 */
			if (!m->mf_ops->fmount_fs) {
				n->n_error = EINVAL;
			} else {
#ifdef DEBUG
				dlog("calling underlying fmount on %s", m->mf_mount);
#endif
				if (!fg && foreground && (m->mf_ops->fs_flags & FS_MBACKGROUND)) {
					m->mf_flags |= MFF_MOUNTING;	/* XXX */
#ifdef DEBUG
					dlog("backgrounding mount of \"%s\"", m->mf_info);
#endif
					nx->nx_try = n;
					run_task(try_nfsx_mount, m,
					    nfsx_cont, mf);
					n->n_error = -1;
					return -1;
				} else {
#ifdef DEBUG
					dlog("foreground mount of \"%s\" ...", mf->mf_info);
#endif
					n->n_error = (*m->mf_ops->fmount_fs)(m);
				}
			}
#ifdef DEBUG
			if (n->n_error > 0) {
				errno = n->n_error;	/* XXX */
				dlog("underlying fmount of %s failed: %m", m->mf_mount);
			}
#endif
			if (n->n_error == 0) {
				glob_error = 0;
			} else if (glob_error < 0) {
				glob_error = n->n_error;
			}
		}
	}

	return glob_error < 0 ? 0 : glob_error;
}

static int
nfsx_fmount(mntfs *mf)
{
	return nfsx_remount(mf, FALSE);
}

/*
 * Unmount an NFS hierarchy.
 * Note that this is called in the foreground
 * and so may hang under extremely rare conditions.
 */
static int
nfsx_fumount(mntfs *mf)
{
	struct nfsx *nx = (struct nfsx *) mf->mf_private;
	nfsx_mnt *n;
	int glob_error = 0;

	/*
	 * Iterate in reverse through the mntfs's and unmount each filesystem
	 * which is mounted.
	 */
	for (n = nx->nx_v + nx->nx_c - 1; n >= nx->nx_v; --n) {
		mntfs *m = n->n_mnt;
		/*
		 * If this node has not been messed with
		 * and there has been no error so far
		 * then try and unmount.
		 * If an error had occured then zero
		 * the error code so that the remount
		 * only tries to unmount those nodes
		 * which had been successfully unmounted.
		 */
		if (n->n_error == 0) {
#ifdef DEBUG
			dlog("calling underlying fumount on %s", m->mf_mount);
#endif
			n->n_error = (*m->mf_ops->fumount_fs)(m);
			if (n->n_error) {
				glob_error = n->n_error;
				n->n_error = 0;
			} else {
				/*
				 * Make sure remount gets this node
				 */
				n->n_error = -1;
			}
		}
	}

	/*
	 * If any unmounts failed then remount the
	 * whole lot...
	 */
	if (glob_error) {
		glob_error = nfsx_remount(mf, TRUE);
		if (glob_error) {
			errno = glob_error; /* XXX */
			plog(XLOG_USER, "nfsx: remount of %s failed: %m", mf->mf_mount);
		}
		glob_error = EBUSY;
	} else {
		/*
		 * Remove all the mount points
		 */
		for (n = nx->nx_v; n < nx->nx_v + nx->nx_c; n++) {
			mntfs *m = n->n_mnt;
			if (n->n_error < 0) {
				if (m->mf_ops->fs_flags & FS_MKMNT) {
					(void) rmdirs(m->mf_mount);
					m->mf_flags &= ~MFF_MKMNT;
				}
			}
			free_mntfs(m);
			n->n_mnt = 0;
			n->n_error = -1;
		}
	}

	return glob_error;
}

/*
 * Ops structure
 */
am_ops nfsx_ops = {
	"nfsx",
	nfsx_match,
	nfsx_init,
	auto_fmount,
	nfsx_fmount,
	auto_fumount,
	nfsx_fumount,
	efs_lookuppn,
	efs_readdir,
	0, /* nfsx_readlink */
	0, /* nfsx_mounted */
	0, /* nfsx_umounted */
	find_nfs_srvr,			/* XXX */
	/*FS_UBACKGROUND|*/FS_AMQINFO
};

#endif /* HAS_NFSX */
@


1.9
log
@Remove a gazillion useless casts to void*
Eliminate a couple function pointer casts, fixing the function to match
    in one case
@
text
@d35 1
a35 1
 *	$Id: nfsx_ops.c,v 1.8 2014/10/26 03:08:21 guenther Exp $
d223 3
a225 3
		  if (rfs) free(rfs);
		  if (mp) free(mp);
		  if (xinfo) free(xinfo);
d230 1
a230 2
		if (info)
			free(info);
@


1.8
log
@Delete casts to void* of the argument to free(): only needed when lying
about constness and none of these were
@
text
@d35 1
a35 1
 *	$Id: nfsx_ops.c,v 1.7 2014/10/26 01:16:48 guenther Exp $
d190 1
a190 1
		mf->mf_private = (void *)nx;
d262 1
a262 1
				sched_task(wakeup_task, (void *)mf, (void *)m);
d283 1
a283 1
	wakeup((void *)n->n_mnt);
d316 1
a316 1
		wakeup((void *)mf);
d375 2
a376 1
					run_task(try_nfsx_mount, (void *)m, nfsx_cont, (void *)mf);
@


1.7
log
@Replace xrealloc() with xreallocarray().  Break-out the 'log and die'
function as xmallocfailure() and use that in the locations where
reallocarray's checks alone aren't sufficient.

ok doug@@ deraadt@@
@
text
@d35 1
a35 1
 *	$Id: nfsx_ops.c,v 1.6 2003/06/02 23:36:51 millert Exp $
d85 1
a85 1
		free((void *)fo->opt_sublink);
d143 2
a144 2
	free((void *)nx->nx_v);
	free((void *)nx);
d228 1
a228 1
		free((void *)ivec);
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
 *	$Id: nfsx_ops.c,v 1.5 2002/08/05 07:24:26 pvalchev Exp $
d109 3
a111 1
	fo->opt_fs = xrealloc(fo->opt_fs, len + 1 + 1);
d194 1
a194 1
		nx->nx_v = (nfsx_mnt *) xmalloc(nx->nx_c * sizeof(nfsx_mnt));
@


1.5
log
@Get rid of useless local definitions P_void, voidp, Const and use
void, void *, const respectively; some cosmetics; ok deraadt
@
text
@d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 *	$Id: nfsx_ops.c,v 1.4 2002/08/03 08:29:31 pvalchev Exp $
@


1.4
log
@various KNF and code cleanup/simplification, parts checked by millert/deraadt
@
text
@d39 1
a39 1
 *	$Id: nfsx_ops.c,v 1.3 2002/07/18 02:03:00 deraadt Exp $
d89 1
a89 1
		free((voidp) fo->opt_sublink);
d134 1
a134 1
nfsx_prfree(voidp vp)
d145 2
a146 2
	free((voidp) nx->nx_v);
	free((voidp) nx);
d192 1
a192 1
		mf->mf_private = (voidp) nx;
d230 1
a230 1
		free((voidp) ivec);
d264 1
a264 1
				sched_task(wakeup_task, (voidp) mf, (voidp) m);
d273 1
a273 1
nfsx_cont(int rc, int term, voidp closure)
d285 1
a285 1
	wakeup((voidp) n->n_mnt);
d318 1
a318 1
		wakeup((voidp) mf);
d325 1
a325 1
try_nfsx_mount(voidp mv)
d377 1
a377 1
					run_task(try_nfsx_mount, (voidp) m, nfsx_cont, (voidp) mf);
@


1.3
log
@space nits
@
text
@d39 1
a39 1
 *	$Id: nfsx_ops.c,v 1.2 2001/03/02 06:22:04 deraadt Exp $
d67 1
a67 1
static int nfsx_fmount P((mntfs*));
d69 2
a70 2
static char *nfsx_match(fo)
am_opts *fo;
d133 2
a134 3
static void nfsx_prfree P((voidp vp));
static void nfsx_prfree(vp)
voidp vp;
d149 2
a150 2
static int nfsx_init(mf)
mntfs *mf;
d272 2
a273 5
static void nfsx_cont P((int rc, int term, voidp closure));
static void nfsx_cont(rc, term, closure)
int rc;
int term;
voidp closure;
d324 2
a325 3
static int try_nfsx_mount P((voidp mv));
static int try_nfsx_mount(mv)
voidp mv;
d336 2
a337 4
static int nfsx_remount P((mntfs *mf, int fg));
static int nfsx_remount(mf, fg)
mntfs *mf;
int fg;
d404 2
a405 3
static int nfsx_fmount P((mntfs *mf));
static int nfsx_fmount(mf)
mntfs *mf;
d415 2
a416 2
static int nfsx_fumount(mf)
mntfs *mf;
@


1.2
log
@KNF
@
text
@d39 1
a39 1
 *	$Id: nfsx_ops.c,v 1.1.1.1 1995/10/18 08:47:11 deraadt Exp $
d203 1
a203 1
		  	char *path = ivec[i+1];
d205 1
a205 1
		  	/*
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
 *	$Id: nfsx_ops.c,v 1.3 1994/06/13 20:47:50 mycroft Exp $
d106 1
a106 1
	if (ptr = strchr(fo->opt_fs, ','))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
